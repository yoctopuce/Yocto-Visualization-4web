/* Yocto-Visualization-4web installer (version 1.10.55319) - www.yoctopuce.com */
// obj/full/Renderer/YDataRendererCommon.js
var Vector3 = class {
  constructor(a, b, c) {
    this.a = a;
    this.b = b;
    this.c = c;
  }
  static FromXYCoord(x, y) {
    return new Vector3(x, y, 1);
  }
  multiplyByM(m) {
    return new Vector3(m.a * this.a + m.b * this.b + m.c * this.c, m.d * this.a + m.e * this.b + m.f * this.c, m.g * this.a + m.h * this.b + m.i * this.c);
  }
  multiplyByN(n) {
    return new Vector3(this.a * n, this.b * n, this.c * n);
  }
  AddV(v) {
    return new Vector3(this.a + v.a, this.b + v.b, this.c + v.c);
  }
  SubstractV(v) {
    return new Vector3(this.a - v.a, this.b - v.b, this.c - v.c);
  }
  toPointF() {
    return new PointF(this.a, this.b);
  }
  toPoint() {
    return new Point(this.a, this.b);
  }
};
var Matrix3x3 = class {
  constructor(a, b, c, d, e, f, g, h, i, flags) {
    this.a = a;
    this.b = b;
    this.c = c;
    this.d = d;
    this.e = e;
    this.f = f;
    this.g = g;
    this.h = h;
    this.i = i;
    if (b == 0 && d == 0 && a == 1 && e == 1 && i == 1 && g == 0 && h == 0) {
      flags |= Matrix3x3.Flag_TRANSLATION;
      if (c == 0 && f == 0)
        flags |= Matrix3x3.Flag_IDENTITY;
    }
    this.isTranslation = (flags & Matrix3x3.Flag_TRANSLATION) != 0;
    this.isIdentity = (flags & Matrix3x3.Flag_IDENTITY) != 0;
  }
  clone() {
    let flag = 0;
    if (this.isTranslation)
      flag |= Matrix3x3.Flag_TRANSLATION;
    if (this.isIdentity)
      flag |= Matrix3x3.Flag_IDENTITY;
    return new Matrix3x3(this.a, this.b, this.c, this.d, this.e, this.f, this.g, this.h, this.i, flag);
  }
  get determinant() {
    let detA = this.e * this.i - this.h * this.f;
    let detB = this.d * this.i - this.g * this.f;
    let detC = this.d * this.h - this.g * this.e;
    return this.a * detA + -this.b * detB + this.c * detC;
  }
  get transpose() {
    if (this.isIdentity)
      return Matrix3x3.newIdentityMatrix();
    return new Matrix3x3(this.a, this.d, this.g, this.b, this.e, this.h, this.c, this.f, this.i, Matrix3x3.Flag_NONE);
  }
  multiplyByV(v) {
    if (this.isTranslation)
      return new Vector3(this.c + v.a, this.f + v.b, 1);
    return new Vector3(this.a * v.a + this.b * v.b + this.c * v.c, this.d * v.a + this.e * v.b + this.f * v.c, this.g * v.a + this.h * v.b + this.i * v.c);
  }
  static newMatrix(a, b, c, d, e, f, g, h, i) {
    return new Matrix3x3(a, b, c, d, e, f, g, h, i, Matrix3x3.Flag_NONE);
  }
  static newTranslateMatrix(offsetX, offsetY) {
    let flag = Matrix3x3.Flag_TRANSLATION;
    if (offsetX == 0 && offsetY == 0)
      flag |= Matrix3x3.Flag_IDENTITY;
    return new Matrix3x3(1, 0, offsetX, 0, 1, offsetY, 0, 0, 1, flag);
  }
  static newRotateMatrix(AngleDeg) {
    AngleDeg = Math.PI * AngleDeg / 180;
    return new Matrix3x3(Math.cos(AngleDeg), -Math.sin(AngleDeg), 0, Math.sin(AngleDeg), -Math.cos(AngleDeg), 0, 0, 0, 1, Matrix3x3.Flag_NONE);
  }
  static newScaleMatrix(Coef) {
    return new Matrix3x3(Coef, 0, 0, 0, Coef, 0, 0, 0, 1, Matrix3x3.Flag_NONE);
  }
  static newIdentityMatrix() {
    return new Matrix3x3(1, 0, 0, 0, 1, 0, 0, 0, 1, Matrix3x3.Flag_IDENTITY | Matrix3x3.Flag_TRANSLATION);
  }
  toCSS() {
    return "matrix(" + this.a.toString() + "," + this.d.toString() + "," + this.b.toString() + "," + this.e.toString() + "," + this.c.toString() + "," + this.f.toString() + ")";
  }
  toString() {
    return "| " + this.a.toFixed(2) + " " + this.b.toFixed(2) + " " + this.c.toFixed(2) + " |" + (this.isIdentity ? " I" : "") + "\n| " + this.d.toFixed(2) + " " + this.e.toFixed(2) + " " + this.f.toFixed(2) + " |" + (this.isTranslation ? " T" : "") + "\n| " + this.g.toFixed(2) + " " + this.g.toFixed(2) + " " + this.i.toFixed(2) + " |\n";
  }
  multiplyByM(m) {
    if (this.isIdentity)
      return m.clone();
    if (m.isIdentity)
      return this.clone();
    if (this.isTranslation && m.isTranslation)
      return Matrix3x3.newTranslateMatrix(this.c + m.c, this.f + m.f);
    return new Matrix3x3(this.a * m.a + this.b * m.d + this.c * m.g, this.a * m.b + this.b * m.e + this.c * m.h, this.a * m.c + this.b * m.f + this.c * m.i, this.d * m.a + this.e * m.d + this.f * m.g, this.d * m.b + this.e * m.e + this.f * m.h, this.d * m.c + this.e * m.f + this.f * m.i, this.g * m.a + this.h * m.d + this.i * m.g, this.g * m.b + this.h * m.e + this.i * m.h, this.g * m.c + this.h * m.f + this.i * m.i, Matrix3x3.Flag_NONE);
  }
  get inverse() {
    if (this.isIdentity)
      return Matrix3x3.newIdentityMatrix();
    if (this.isTranslation)
      return Matrix3x3.newTranslateMatrix(-this.c, -this.f);
    let det = this.determinant;
    if (det == 0)
      throw "matrix cannot be inverted";
    let detA = this.e * this.i - this.f * this.h;
    let detB = this.b * this.i - this.c * this.h;
    let detC = this.b * this.f - this.c * this.e;
    let detD = this.d * this.i - this.f * this.g;
    let detE = this.a * this.i - this.c * this.g;
    let detF = this.a * this.f - this.c * this.d;
    let detG = this.d * this.h - this.e * this.g;
    let detH = this.a * this.h - this.b * this.g;
    let detI = this.a * this.e - this.b * this.d;
    return new Matrix3x3(detA / det, -detB / det, detC / det, -detD / det, detE / det, -detF / det, detG / det, -detH / det, detI / det, Matrix3x3.Flag_NONE);
  }
  log() {
    console.log(this.toString());
  }
};
Matrix3x3.Flag_NONE = 0;
Matrix3x3.Flag_IDENTITY = 1;
Matrix3x3.Flag_TRANSLATION = 2;
var YEnum = class {
  static fromString(container, value) {
    let p = Object.getOwnPropertyNames(container);
    for (let i = 0; i < p.length; i++) {
      if (p[i] == value)
        return container[value];
    }
    throw "YEnum" + value + " is not a " + container + " value";
  }
  static siblings(container) {
    let res = [];
    let p = Object.getOwnPropertyNames(container);
    for (let i = 0; i < p.length; i++) {
      if (container[p[i]] instanceof YEnumItem) {
        res.push(container[p[i]]);
      }
    }
    return res;
  }
};
var YEnumItem = class {
  constructor(value, humanreadable, container) {
    this._value = value;
    this._container = container;
    this._humanreadable = humanreadable;
  }
  fromString(value) {
    return YEnum.fromString(this._container, value);
  }
  get toString() {
    return this._value.toString();
  }
  get description() {
    return this._humanreadable;
  }
  get sibblings() {
    return YEnum.siblings(this._container);
  }
};
var ViewPortSettings = class {
  constructor() {
    this.IRLx = 0;
    this.IRLy = 0;
    this.zoomx = 0;
    this.zoomy = 0;
    this.Lmargin = 0;
    this.Rmargin = 0;
    this.Tmargin = 0;
    this.Bmargin = 0;
    this.Width = 0;
    this.Height = 0;
    this.Capture = false;
    this.IRLCaptureStartX = 0;
    this.CaptureStartY = 0;
    this.OriginalXAxisMin = 0;
    this.OriginalXAxisMax = 0;
    this.OriginalIRLx = 0;
    this.OriginalLmargin = 0;
    this.OriginalZoomx = 0;
  }
};
var YFont = class {
  constructor(parentRenderer, directParent, size, fontChangeCallback) {
    this._userData = null;
    this._fontChangeCallback = null;
    this._name = "Arial";
    this._italic = false;
    this._bold = false;
    this._color = YColor.Black;
    this._alternateColor = null;
    this._font = null;
    this._brush = new YSolidBrush(YColor.Black);
    this._parentRenderer = parentRenderer;
    this._directParent = directParent;
    this._fontChangeCallback = fontChangeCallback ? fontChangeCallback : null;
    this._size = new Proportional(size ? size : 10, Proportional.ResizeRule.FIXED, parentRenderer, this, this.ResetFont);
  }
  get userData() {
    return this._userData;
  }
  set userData(value) {
    this._userData = value;
  }
  get directParent() {
    return this._directParent;
  }
  ResetFont(source) {
    this._font = null;
    if (source != null)
      this._parentRenderer.ProportionnalValueChanged(source);
  }
  get name() {
    return this._name;
  }
  set name(value) {
    this._name = value;
    this.ResetFont(null);
    this._parentRenderer.redraw();
  }
  get hasChanged() {
    return this._font == null;
  }
  get size() {
    return this._size.value;
  }
  set size(value) {
    if (value <= 0)
      throw new RangeError("Size must be a positive value");
    value = Math.round(100 * value) / 100;
    this._size.value = value;
    this.ResetFont(null);
    if (this._fontChangeCallback != null)
      this._fontChangeCallback(this);
    this._parentRenderer.redraw();
  }
  get italic() {
    return this._italic;
  }
  set italic(value) {
    if (this._italic != value) {
      this._italic = value;
      this.ResetFont(null);
      this._parentRenderer.redraw();
    }
  }
  get bold() {
    return this._bold;
  }
  set bold(value) {
    if (this._bold != value) {
      this._bold = value;
      this.ResetFont(null);
      this._parentRenderer.redraw();
    }
  }
  get color() {
    return this._color;
  }
  set color(value) {
    if (this._color != value) {
      this._color = value;
      this._brush = null;
      this._parentRenderer.redraw();
    }
  }
  get alternateColor() {
    return this._alternateColor;
  }
  set alternateColor(value) {
    if (this._alternateColor != value) {
      this._alternateColor = value;
      this._brush = null;
      this._parentRenderer.redraw();
    }
  }
  get fontObject() {
    return this._name ? this._name : "Arial";
  }
  get brush() {
    if (this._brush == null)
      this._brush = new YSolidBrush(this._alternateColor != null ? this._alternateColor : this._color);
    return this._brush;
  }
  get sizeInPoints() {
    return this._size.value * 0.75;
  }
  get sizeForCanvas() {
    return this._size.value * 1.15;
  }
  get htmlCode() {
    return (this._italic ? "italic " : "") + (this._bold ? "bold " : "") + this.sizeForCanvas.toString() + "px " + this._name;
  }
};
var YSizeF = class {
  constructor(font, st) {
    this._w = 0;
    this._h = 0;
    this._lines = [];
    this._linesCount = 0;
    this._lineHeight = 0;
    this._firstlineHeight = 0;
    if (font != null) {
      this._lineHeight = font.size * 1.25;
      this._firstlineHeight = this._lineHeight * 0.75;
      if (st.indexOf("\n") < 0) {
        this._lines = [st];
        this._linesCount = 1;
      } else {
        this._lines = st.split("\n");
        this._linesCount = this._lines.length;
      }
    }
  }
  get lines() {
    return this._lines;
  }
  get linesCount() {
    return this._linesCount;
  }
  get firstLineHeight() {
    return this._firstlineHeight;
  }
  get lineHeight() {
    return this._lineHeight;
  }
  get height() {
    return this._h;
  }
  get width() {
    return this._w;
  }
  set width(value) {
    this._w = value;
  }
  set height(value) {
    this._h = value;
  }
};
var YTextRenderingHint = class {
  constructor(value) {
    this._value = 0;
    this._value = value;
  }
};
YTextRenderingHint.SystemDefault = new YTextRenderingHint(0);
YTextRenderingHint.SingleBitPerPixelGridFit = new YTextRenderingHint(1);
YTextRenderingHint.SingleBitPerPixel = new YTextRenderingHint(2);
YTextRenderingHint.AntiAliasGridFit = new YTextRenderingHint(3);
YTextRenderingHint.AntiAlias = new YTextRenderingHint(4);
YTextRenderingHint.ClearTypeGridFit = new YTextRenderingHint(5);
var YSmoothingMode = class {
  constructor(value) {
    this._value = 0;
    this._value = value;
  }
};
YSmoothingMode.Invalid = new YSmoothingMode(-1);
YSmoothingMode.Default = new YSmoothingMode(0);
YSmoothingMode.HighSpeed = new YSmoothingMode(1);
YSmoothingMode.HighQuality = new YSmoothingMode(2);
YSmoothingMode.None = new YSmoothingMode(3);
YSmoothingMode.AntiAlias = new YSmoothingMode(4);
var YStringBuilder = class {
  constructor() {
    this._str = "";
  }
  AppendLine(s) {
    this._str += s + "\n";
  }
  Append(s) {
    this._str += s;
  }
  get contents() {
    return this._str;
  }
};
var YStringFormat = class {
  constructor(clip) {
    this._Alignment = 0;
    this._LineAlignment = 0;
    this._formatFlags = 0;
    this._Trimming = 0;
    this._clip = 16384;
    this._clip = clip;
  }
  get Alignment() {
    return this._Alignment;
  }
  set Alignment(value) {
    this._Alignment = value;
  }
  get LineAlignment() {
    return this._LineAlignment;
  }
  set LineAlignment(value) {
    this._LineAlignment = value;
  }
  get FormatFlags() {
    return this._formatFlags;
  }
  set FormatFlags(value) {
    this._formatFlags = value;
  }
  get Trimming() {
    return this._Trimming;
  }
  set Trimming(value) {
    this._Trimming = value;
  }
};
var YColor = class {
  constructor(isHsl, transparency, r_h, g_s, b_l, isPredefined) {
    this.hslConvertionDone = false;
    this.rgbConvertionDone = false;
    this.transparency = 0;
    this.r = 0;
    this.g = 0;
    this.b = 0;
    this.h = 0;
    this.s = 0;
    this.l = 0;
    this._name = "";
    this._htmlcode = this.computeHTMLCode();
    this.hslConvertionDone = isHsl;
    this.isHSLColor = isHsl;
    this.transparency = transparency;
    this._isPredefined = isPredefined === true;
    if (isHsl) {
      this.h = r_h;
      this.s = g_s;
      this.l = b_l;
      this.hsl2rgb();
    } else {
      this.r = r_h;
      this.g = g_s;
      this.b = b_l;
      this.rgbConvertionDone = true;
    }
    this._htmlcode = this.computeHTMLCode();
  }
  get name() {
    return this._name;
  }
  set predefname(value) {
    this._name = value;
  }
  static get predefinedColors() {
    if (YColor._predefinedColors == null) {
      YColor._predefinedColors = {};
      let names = Object.getOwnPropertyNames(YColor);
      for (let i = 0; i < names.length; i++) {
        if (YColor[names[i]] instanceof YColor) {
          YColor._predefinedColors[names[i]] = YColor[names[i]];
          YColor._predefinedColors[names[i]].predefname = names[i];
        }
      }
    }
    return YColor._predefinedColors;
  }
  static FromString(value) {
    let valueUpper = value.toUpperCase();
    let propNames = Object.getOwnPropertyNames(YColor);
    for (let i = 0; i < propNames.length; i++) {
      if (propNames[i].toUpperCase() == valueUpper) {
        if (YColor[propNames[i]] instanceof YColor) {
          return YColor[propNames[i]];
        }
      }
    }
    if (value.length == 7 && value.substr(0, 1).toUpperCase() == "#") {
      let r = parseInt(value.substr(1, 2), 16);
      let g = parseInt(value.substr(3, 2), 16);
      let b = parseInt(value.substr(5, 2), 16);
      return new YColor(false, 255, r, g, b);
    }
    if (value.length == 12) {
      if (value.substr(0, 4).toUpperCase() == "RGB:") {
        let alpha = parseInt(value.substr(4, 2), 16);
        let r = parseInt(value.substr(6, 2), 16);
        let g = parseInt(value.substr(8, 2), 16);
        let b = parseInt(value.substr(10, 2), 16);
        return new YColor(false, alpha, r, g, b);
      } else if (value.substr(0, 4).toUpperCase() == "HSL:") {
        let alpha = parseInt(value.substr(4, 2), 16);
        let h = parseInt(value.substr(6, 2), 16);
        let s = parseInt(value.substr(8, 2), 16);
        let l = parseInt(value.substr(10, 2), 16);
        return new YColor(true, alpha, h, s, l);
      }
    }
    return null;
  }
  static hex(v) {
    let s = v.toString(16);
    if (s.length <= 1)
      return "0" + s;
    return s;
  }
  toString() {
    if (this.isHSLColor) {
      return "HSL:" + (YColor.hex(this.transparency) + YColor.hex(this.h) + YColor.hex(this.s) + YColor.hex(this.l)).toUpperCase();
    } else {
      let propNames = Object.getOwnPropertyNames(YColor);
      for (let i = 0; i < propNames.length; i++) {
        let o = Reflect.get(YColor, propNames[i]);
        let c = o;
        if (c.alpha == this.alpha && c.red == this.red && c.green == this.green && c.blue == this.blue)
          return propNames[i];
      }
    }
    return "RGB:" + (YColor.hex(this.transparency) + YColor.hex(this.r) + YColor.hex(this.g) + YColor.hex(this.b)).toUpperCase();
  }
  get svgCode() {
    return "rgb(" + this.r.toString() + ", " + this.g.toString() + ", " + this.b.toString() + ")";
  }
  get alphaCode() {
    return (this.transparency / 255).toFixed(3);
  }
  static hsl2rgbInt(temp1, temp2, temp3) {
    if (temp3 >= 170)
      return (temp1 + 127) / 255 >> 0;
    if (temp3 > 42) {
      if (temp3 <= 127)
        return (temp2 + 127) / 255 >> 0;
      temp3 = 170 - temp3;
    }
    return (temp1 * 255 + (temp2 - temp1) * (6 * temp3) + 32512) / 65025 >> 0;
  }
  hsl2rgb() {
    let temp1;
    let temp2;
    let temp3;
    this.rgbConvertionDone = true;
    if (this.s == 0) {
      this.r = this.l;
      this.g = this.l;
      this.b = this.l;
      return;
    }
    if (this.l <= 127) {
      temp2 = this.l * (255 + this.s);
    } else {
      temp2 = (this.l + this.s) * 255 - this.l * this.s;
    }
    temp1 = 510 * this.l - temp2;
    temp3 = this.h + 85;
    if (temp3 > 255)
      temp3 = temp3 - 255;
    this.r = YColor.hsl2rgbInt(temp1, temp2, temp3);
    temp3 = this.h;
    if (temp3 > 255)
      temp3 = temp3 - 255;
    this.g = YColor.hsl2rgbInt(temp1, temp2, temp3);
    if (this.h >= 85) {
      temp3 = this.h - 85;
    } else {
      temp3 = this.h + 170;
    }
    this.b = YColor.hsl2rgbInt(temp1, temp2, temp3);
    if (this.r > 255)
      this.r = 255;
    if (this.g > 255)
      this.g = 255;
    if (this.b > 255)
      this.b = 255;
  }
  computeHSL() {
    let R = this.r;
    let G = this.g;
    let B = this.b;
    let H;
    let S;
    let L;
    let max = R > G ? R : G;
    let min = R < G ? R : G;
    let correction = 0;
    let divisor = 0;
    this.hslConvertionDone = true;
    if (B > max)
      max = B;
    if (B < min)
      min = B;
    L = (max + min + 1) / 2 >> 0;
    if (max == min) {
      this.h = 0;
      this.s = 0;
      this.l = L;
      return;
    }
    correction = (max + min) / 2 >> 0;
    if (L <= 127) {
      S = (255 * (max - min) + correction) / (max + min) >> 0;
    } else {
      S = (255 * (max - min) + 255 - correction) / (510 - (max + min)) >> 0;
    }
    correction = 3 * (max - min);
    divisor = 2 * correction;
    if (R == max) {
      H = 0;
      R = G;
      G = B;
    } else if (G == max) {
      H = 85;
      G = R;
      R = B;
    } else {
      H = 170;
    }
    if (R >= G) {
      H += (255 * (R - G) + correction) / divisor >> 0;
    } else {
      H += 255 - (255 * (G - R) - correction) / divisor >> 0;
    }
    if (H > 255)
      H -= 255;
    if (S > 255)
      S = 255;
    if (L > 255)
      L = 255;
    this.h = H;
    this.s = S;
    this.l = L;
  }
  get hue() {
    if (!this.hslConvertionDone)
      this.computeHSL();
    return this.h;
  }
  get saturation() {
    if (!this.hslConvertionDone)
      this.computeHSL();
    return this.s;
  }
  get luminosity() {
    if (!this.hslConvertionDone)
      this.computeHSL();
    return this.l;
  }
  get red() {
    if (!this.rgbConvertionDone)
      this.hsl2rgb();
    return this.r;
  }
  get green() {
    if (!this.rgbConvertionDone)
      this.hsl2rgb();
    return this.g;
  }
  get blue() {
    if (!this.rgbConvertionDone)
      this.hsl2rgb();
    return this.b;
  }
  get alpha() {
    return this.transparency;
  }
  static FromArgb(a, r, g, b) {
    return new YColor(false, a, r, g, b);
  }
  static FromAhsl(a, h, s, l) {
    return new YColor(true, a, h, s, l);
  }
  get isHSL() {
    return this.isHSLColor;
  }
  get isRGB() {
    return !this.isHSLColor;
  }
  equal(c) {
    if (this.isHSLColor) {
      if (!c.isHSLColor)
        return false;
      if (c.hue != this.hue)
        return false;
      if (c.saturation != this.saturation)
        return false;
      if (c.luminosity != this.luminosity)
        return false;
      if (c.alpha != this.alpha)
        return false;
    } else {
      if (c.isHSLColor)
        return false;
      if (c.red != this.red)
        return false;
      if (c.green != this.green)
        return false;
      if (c.blue != this.blue)
        return false;
      if (c.alpha != this.alpha)
        return false;
    }
    return true;
  }
  clone() {
    if (this.isHSLColor)
      return new YColor(true, this.transparency, this.h, this.s, this.l, this.isPredefined);
    return new YColor(false, this.transparency, this.r, this.g, this.b, this.isPredefined);
  }
  get isPredefined() {
    return this._isPredefined;
  }
  computeHTMLCode() {
    let a = this.transparency / 255;
    let r = this.r;
    let g = this.g;
    let b = this.b;
    return "rgba(" + r + "," + g + "," + b + "," + a.toFixed(3) + ")";
  }
  get htmlCode() {
    return this._htmlcode;
  }
};
YColor.AliceBlue = new YColor(false, 255, 240, 248, 255, true);
YColor.AntiqueWhite = new YColor(false, 255, 250, 235, 215, true);
YColor.Aqua = new YColor(false, 255, 0, 255, 255, true);
YColor.Aquamarine = new YColor(false, 255, 127, 255, 212, true);
YColor.Azure = new YColor(false, 255, 240, 255, 255, true);
YColor.Beige = new YColor(false, 255, 245, 245, 220, true);
YColor.Bisque = new YColor(false, 255, 255, 228, 196, true);
YColor.Black = new YColor(false, 255, 0, 0, 0, true);
YColor.BlanchedAlmond = new YColor(false, 255, 255, 235, 205, true);
YColor.Blue = new YColor(false, 255, 0, 0, 255, true);
YColor.BlueViolet = new YColor(false, 255, 138, 43, 226, true);
YColor.Brown = new YColor(false, 255, 165, 42, 42, true);
YColor.BurlyWood = new YColor(false, 255, 222, 184, 135, true);
YColor.CadetBlue = new YColor(false, 255, 95, 158, 160, true);
YColor.Chartreuse = new YColor(false, 255, 127, 255, 0, true);
YColor.Chocolate = new YColor(false, 255, 210, 105, 30, true);
YColor.Coral = new YColor(false, 255, 255, 127, 80, true);
YColor.CornflowerBlue = new YColor(false, 255, 100, 149, 237, true);
YColor.Cornsilk = new YColor(false, 255, 255, 248, 220, true);
YColor.Crimson = new YColor(false, 255, 220, 20, 60, true);
YColor.Cyan = new YColor(false, 255, 0, 255, 255, true);
YColor.DarkBlue = new YColor(false, 255, 0, 0, 139, true);
YColor.DarkCyan = new YColor(false, 255, 0, 139, 139, true);
YColor.DarkGoldenrod = new YColor(false, 255, 184, 134, 11, true);
YColor.DarkGray = new YColor(false, 255, 169, 169, 169, true);
YColor.DarkGreen = new YColor(false, 255, 0, 100, 0, true);
YColor.DarkKhaki = new YColor(false, 255, 189, 183, 107, true);
YColor.DarkMagenta = new YColor(false, 255, 139, 0, 139, true);
YColor.DarkOliveGreen = new YColor(false, 255, 85, 107, 47, true);
YColor.DarkOrange = new YColor(false, 255, 255, 140, 0, true);
YColor.DarkOrchid = new YColor(false, 255, 153, 50, 204, true);
YColor.DarkRed = new YColor(false, 255, 139, 0, 0, true);
YColor.DarkSalmon = new YColor(false, 255, 233, 150, 122, true);
YColor.DarkSeaGreen = new YColor(false, 255, 143, 188, 143, true);
YColor.DarkSlateBlue = new YColor(false, 255, 72, 61, 139, true);
YColor.DarkSlateGray = new YColor(false, 255, 47, 79, 79, true);
YColor.DarkTurquoise = new YColor(false, 255, 0, 206, 209, true);
YColor.DarkViolet = new YColor(false, 255, 148, 0, 211, true);
YColor.DeepPink = new YColor(false, 255, 255, 20, 147, true);
YColor.DeepSkyBlue = new YColor(false, 255, 0, 191, 255, true);
YColor.DimGray = new YColor(false, 255, 105, 105, 105, true);
YColor.DodgerBlue = new YColor(false, 255, 30, 144, 255, true);
YColor.Firebrick = new YColor(false, 255, 178, 34, 34, true);
YColor.FloralWhite = new YColor(false, 255, 255, 250, 240, true);
YColor.ForestGreen = new YColor(false, 255, 34, 139, 34, true);
YColor.Fuchsia = new YColor(false, 255, 255, 0, 255, true);
YColor.Gainsboro = new YColor(false, 255, 220, 220, 220, true);
YColor.GhostWhite = new YColor(false, 255, 248, 248, 255, true);
YColor.Gold = new YColor(false, 255, 255, 215, 0, true);
YColor.Goldenrod = new YColor(false, 255, 218, 165, 32, true);
YColor.Gray = new YColor(false, 255, 128, 128, 128, true);
YColor.Green = new YColor(false, 255, 0, 128, 0, true);
YColor.GreenYellow = new YColor(false, 255, 173, 255, 47, true);
YColor.Honeydew = new YColor(false, 255, 240, 255, 240, true);
YColor.HotPink = new YColor(false, 255, 255, 105, 180, true);
YColor.IndianRed = new YColor(false, 255, 205, 92, 92, true);
YColor.Indigo = new YColor(false, 255, 75, 0, 130, true);
YColor.Ivory = new YColor(false, 255, 255, 255, 240, true);
YColor.Khaki = new YColor(false, 255, 240, 230, 140, true);
YColor.Lavender = new YColor(false, 255, 230, 230, 250, true);
YColor.LavenderBlush = new YColor(false, 255, 255, 240, 245, true);
YColor.LawnGreen = new YColor(false, 255, 124, 252, 0, true);
YColor.LemonChiffon = new YColor(false, 255, 255, 250, 205, true);
YColor.LightBlue = new YColor(false, 255, 173, 216, 230, true);
YColor.LightCoral = new YColor(false, 255, 240, 128, 128, true);
YColor.LightCyan = new YColor(false, 255, 224, 255, 255, true);
YColor.LightGoldenrodYellow = new YColor(false, 255, 250, 250, 210, true);
YColor.LightGray = new YColor(false, 255, 211, 211, 211, true);
YColor.LightGreen = new YColor(false, 255, 144, 238, 144, true);
YColor.LightPink = new YColor(false, 255, 255, 182, 193, true);
YColor.LightSalmon = new YColor(false, 255, 255, 160, 122, true);
YColor.LightSeaGreen = new YColor(false, 255, 32, 178, 170, true);
YColor.LightSkyBlue = new YColor(false, 255, 135, 206, 250, true);
YColor.LightSlateGray = new YColor(false, 255, 119, 136, 153, true);
YColor.LightSteelBlue = new YColor(false, 255, 176, 196, 222, true);
YColor.LightYellow = new YColor(false, 255, 255, 255, 224, true);
YColor.Lime = new YColor(false, 255, 0, 255, 0, true);
YColor.LimeGreen = new YColor(false, 255, 50, 205, 50, true);
YColor.Linen = new YColor(false, 255, 250, 240, 230, true);
YColor.Magenta = new YColor(false, 255, 255, 0, 255, true);
YColor.Maroon = new YColor(false, 255, 128, 0, 0, true);
YColor.MediumAquamarine = new YColor(false, 255, 102, 205, 170, true);
YColor.MediumBlue = new YColor(false, 255, 0, 0, 205, true);
YColor.MediumOrchid = new YColor(false, 255, 186, 85, 211, true);
YColor.MediumPurple = new YColor(false, 255, 147, 112, 219, true);
YColor.MediumSeaGreen = new YColor(false, 255, 60, 179, 113, true);
YColor.MediumSlateBlue = new YColor(false, 255, 123, 104, 238, true);
YColor.MediumSpringGreen = new YColor(false, 255, 0, 250, 154, true);
YColor.MediumTurquoise = new YColor(false, 255, 72, 209, 204, true);
YColor.MediumVioletRed = new YColor(false, 255, 199, 21, 133, true);
YColor.MidnightBlue = new YColor(false, 255, 25, 25, 112, true);
YColor.MintCream = new YColor(false, 255, 245, 255, 250, true);
YColor.MistyRose = new YColor(false, 255, 255, 228, 225, true);
YColor.Moccasin = new YColor(false, 255, 255, 228, 181, true);
YColor.NavajoWhite = new YColor(false, 255, 255, 222, 173, true);
YColor.Navy = new YColor(false, 255, 0, 0, 128, true);
YColor.OldLace = new YColor(false, 255, 253, 245, 230, true);
YColor.Olive = new YColor(false, 255, 128, 128, 0, true);
YColor.OliveDrab = new YColor(false, 255, 107, 142, 35, true);
YColor.Orange = new YColor(false, 255, 255, 165, 0, true);
YColor.OrangeRed = new YColor(false, 255, 255, 69, 0, true);
YColor.Orchid = new YColor(false, 255, 218, 112, 214, true);
YColor.PaleGoldenrod = new YColor(false, 255, 238, 232, 170, true);
YColor.PaleGreen = new YColor(false, 255, 152, 251, 152, true);
YColor.PaleTurquoise = new YColor(false, 255, 175, 238, 238, true);
YColor.PaleVioletRed = new YColor(false, 255, 219, 112, 147, true);
YColor.PapayaWhip = new YColor(false, 255, 255, 239, 213, true);
YColor.PeachPuff = new YColor(false, 255, 255, 218, 185, true);
YColor.Peru = new YColor(false, 255, 205, 133, 63, true);
YColor.Pink = new YColor(false, 255, 255, 192, 203, true);
YColor.Plum = new YColor(false, 255, 221, 160, 221, true);
YColor.PowderBlue = new YColor(false, 255, 176, 224, 230, true);
YColor.Purple = new YColor(false, 255, 128, 0, 128, true);
YColor.Red = new YColor(false, 255, 255, 0, 0, true);
YColor.RosyBrown = new YColor(false, 255, 188, 143, 143, true);
YColor.RoyalBlue = new YColor(false, 255, 65, 105, 225, true);
YColor.SaddleBrown = new YColor(false, 255, 139, 69, 19, true);
YColor.Salmon = new YColor(false, 255, 250, 128, 114, true);
YColor.SandyBrown = new YColor(false, 255, 244, 164, 96, true);
YColor.SeaGreen = new YColor(false, 255, 46, 139, 87, true);
YColor.SeaShell = new YColor(false, 255, 255, 245, 238, true);
YColor.Sienna = new YColor(false, 255, 160, 82, 45, true);
YColor.Silver = new YColor(false, 255, 192, 192, 192, true);
YColor.SkyBlue = new YColor(false, 255, 135, 206, 235, true);
YColor.SlateBlue = new YColor(false, 255, 106, 90, 205, true);
YColor.SlateGray = new YColor(false, 255, 112, 128, 144, true);
YColor.Snow = new YColor(false, 255, 255, 250, 250, true);
YColor.SpringGreen = new YColor(false, 255, 0, 255, 127, true);
YColor.SteelBlue = new YColor(false, 255, 70, 130, 180, true);
YColor.Tan = new YColor(false, 255, 210, 180, 140, true);
YColor.Teal = new YColor(false, 255, 0, 128, 128, true);
YColor.Thistle = new YColor(false, 255, 216, 191, 216, true);
YColor.Tomato = new YColor(false, 255, 255, 99, 71, true);
YColor.Transparent = new YColor(false, 0, 255, 255, 255, true);
YColor.Turquoise = new YColor(false, 255, 64, 224, 208, true);
YColor.Violet = new YColor(false, 255, 238, 130, 238, true);
YColor.Wheat = new YColor(false, 255, 245, 222, 179, true);
YColor.White = new YColor(false, 255, 255, 255, 255, true);
YColor.WhiteSmoke = new YColor(false, 255, 245, 245, 245, true);
YColor.Yellow = new YColor(false, 255, 255, 255, 0, true);
YColor.YellowGreen = new YColor(false, 255, 154, 205, 50, true);
YColor._predefinedColors = null;
var YBrush = class {
  constructor(c, disableAntialias) {
    this._noAntiAlias = false;
    this._color = c;
    if (typeof disableAntialias != "undefined") {
      this._noAntiAlias = disableAntialias;
    }
  }
  get noAntiAlias() {
    return this._noAntiAlias;
  }
  get color() {
    return this._color;
  }
};
var YSolidBrush = class extends YBrush {
};
var YLinearGradientBrush = class extends YBrush {
  constructor(c1, c2) {
    super(c1);
    this._color1 = c1;
    this._color2 = c2;
  }
  get color1() {
    return this._color1;
  }
  get color2() {
    return this._color2;
  }
};
var YPen = class {
  constructor(color, thickness, disableAntialias) {
    this._thickness = 1;
    this._color = YColor.Black;
    this._noAntiAlias = false;
    this._startCap = 1;
    this._endCap = 1;
    this._linejoin = YPen.LineJoin.Miter;
    this._thickness = thickness;
    this._color = thickness > 0 ? color : YColor.Transparent;
    if (typeof disableAntialias != "undefined") {
      this._noAntiAlias = disableAntialias;
    }
  }
  get noAntiAlias() {
    return this._noAntiAlias;
  }
  get lineWidth() {
    return this._thickness;
  }
  get strokeStyle() {
    return this._color.htmlCode;
  }
  get color() {
    return this._color;
  }
  set startCap(value) {
    this._startCap = value;
  }
  set endCap(value) {
    this._endCap = value;
  }
  set linejoin(value) {
    this._linejoin = value;
  }
};
(function(YPen2) {
  let LineJoin;
  (function(LineJoin2) {
    LineJoin2[LineJoin2["Miter"] = 0] = "Miter";
    LineJoin2[LineJoin2["Bevel"] = 1] = "Bevel";
    LineJoin2[LineJoin2["Round"] = 2] = "Round";
    LineJoin2[LineJoin2["MiterClipped"] = 3] = "MiterClipped";
  })(LineJoin = YPen2.LineJoin || (YPen2.LineJoin = {}));
})(YPen || (YPen = {}));
var YRectangle = class {
  constructor(x, y, w, h) {
    this.x = x;
    this.y = y;
    this.w = w;
    this.h = h;
  }
};
var Point = class {
  constructor(valueX, valueY) {
    this.X = valueX >> 0;
    this.Y = valueY >> 0;
  }
};
var minMaxPoint = class {
  constructor(valueX1, valueYMIN, valueX2, valueYMAX) {
    this.X1 = valueX1 >> 0;
    this.YMIN = valueYMIN >> 0;
    this.X2 = valueX2 >> 0;
    this.YMAX = valueYMAX >> 0;
  }
};
var PointF = class {
  constructor(valueX, valueY) {
    this.X = valueX;
    this.Y = valueY;
  }
};
var GenericPanel = class {
  constructor(parent, directParent) {
    this._userData = null;
    this._enabled = false;
    this._panelTextAlign = GenericPanel.TextAlign.LEFT;
    this._text = "";
    this._bgColor = new YColor(false, 255, 255, 255, 192);
    this._borderColor = YColor.Black;
    this._borderthickness = 1;
    this._padding = 10;
    this._verticalMargin = 10;
    this._horizontalMargin = 10;
    this._bgBrush = null;
    this._pen = null;
    this._font = null;
    this._directParent = directParent;
    this._parentRenderer = parent;
    this._font = new YFont(parent, this, 8, null);
  }
  get userData() {
    return this._userData;
  }
  set userData(value) {
    this._userData = value;
  }
  get directParent() {
    return this._directParent;
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    if (this._enabled != value) {
      this._enabled = value;
      this._parentRenderer.clearCachedObjects();
      this._parentRenderer.redraw();
    }
  }
  get panelTextAlign() {
    return this._panelTextAlign;
  }
  set panelTextAlign(value) {
    this._panelTextAlign = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get text() {
    return this._text;
  }
  set text(value) {
    this._text = value;
    this._parentRenderer.clearCachedObjects();
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get bgColor() {
    return this._bgColor;
  }
  set bgColor(value) {
    this._bgColor = value;
    this._bgBrush = null;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get borderColor() {
    return this._borderColor;
  }
  set borderColor(value) {
    this._borderColor = value;
    this._pen = null;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get borderthickness() {
    return this._borderthickness;
  }
  set borderthickness(value) {
    if (value < 0)
      throw "Border thickness must be a positive value";
    this._borderthickness = value;
    this._parentRenderer.clearCachedObjects();
    this._pen = null;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get padding() {
    return this._padding;
  }
  set padding(value) {
    if (value < 0)
      throw new RangeError("Padding must be a positive value");
    this._padding = value;
    this._parentRenderer.clearCachedObjects();
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get verticalMargin() {
    return this._verticalMargin;
  }
  set verticalMargin(value) {
    this._verticalMargin = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get horizontalMargin() {
    return this._horizontalMargin;
  }
  set horizontalMargin(value) {
    this._horizontalMargin = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get bgBrush() {
    if (this._bgBrush == null)
      this._bgBrush = new YSolidBrush(this._bgColor);
    return this._bgBrush;
  }
  get pen() {
    if (this._pen == null) {
      this._pen = new YPen(this._borderColor, this._borderthickness, true);
    }
    return this._pen;
  }
  get font() {
    return this._font;
  }
};
(function(GenericPanel2) {
  class HorizontalAlignPosEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, HorizontalAlignPos);
    }
  }
  GenericPanel2.HorizontalAlignPosEnumItem = HorizontalAlignPosEnumItem;
  class HorizontalAlignPos extends YEnum {
  }
  HorizontalAlignPos.LEFT = new HorizontalAlignPosEnumItem("LEFT", "Left");
  HorizontalAlignPos.CENTER = new HorizontalAlignPosEnumItem("CENTER", "Center");
  HorizontalAlignPos.RIGHT = new HorizontalAlignPosEnumItem("RIGHT", "Right");
  GenericPanel2.HorizontalAlignPos = HorizontalAlignPos;
  class VerticalAlignPosEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, VerticalAlignPos);
    }
  }
  GenericPanel2.VerticalAlignPosEnumItem = VerticalAlignPosEnumItem;
  class VerticalAlignPos extends YEnum {
  }
  VerticalAlignPos.TOP = new VerticalAlignPosEnumItem("TOP", "Top");
  VerticalAlignPos.CENTER = new VerticalAlignPosEnumItem("CENTER", "Center");
  VerticalAlignPos.BOTTOM = new VerticalAlignPosEnumItem("BOTTOM", "Bottom");
  GenericPanel2.VerticalAlignPos = VerticalAlignPos;
  class TextAlignEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, TextAlign);
    }
  }
  GenericPanel2.TextAlignEnumItem = TextAlignEnumItem;
  class TextAlign extends YEnum {
  }
  TextAlign.LEFT = new TextAlignEnumItem("LEFT", "Left");
  TextAlign.CENTER = new TextAlignEnumItem("CENTER", "Center");
  TextAlign.RIGHT = new TextAlignEnumItem("RIGHT", "Right");
  GenericPanel2.TextAlign = TextAlign;
})(GenericPanel || (GenericPanel = {}));
var MessagePanel = class extends GenericPanel {
  constructor(parent, directParent) {
    super(parent, directParent);
    this._panelHrzAlign = GenericPanel.HorizontalAlignPos.CENTER;
    this._panelVrtAlign = GenericPanel.VerticalAlignPos.CENTER;
  }
  get panelHrzAlign() {
    return this._panelHrzAlign;
  }
  set panelHrzAlign(value) {
    this._panelHrzAlign = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get panelVrtAlign() {
    return this._panelVrtAlign;
  }
  set panelVrtAlign(value) {
    this._panelVrtAlign = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
};
var AnnotationPanel = class extends GenericPanel {
  constructor(parent, directParent) {
    super(parent, directParent);
    this._overlap = false;
    this._positionOffsetX = 50;
    this._positionOffsetY = 50;
    this._panelHrzAlign = GenericPanel.HorizontalAlignPos.CENTER;
    this._panelVrtAlign = GenericPanel.VerticalAlignPos.TOP;
  }
  get overlap() {
    return this._overlap;
  }
  set overlap(value) {
    if (!value && this._panelHrzAlign == GenericPanel.HorizontalAlignPos.CENTER && this._panelVrtAlign == GenericPanel.VerticalAlignPos.CENTER) {
      this._panelVrtAlign = GenericPanel.VerticalAlignPos.TOP;
    }
    this._overlap = value;
    this._parentRenderer.clearCachedObjects();
    this._parentRenderer.redraw();
  }
  get positionOffsetX() {
    return this._positionOffsetX;
  }
  set positionOffsetX(value) {
    this._positionOffsetX = value;
    this._parentRenderer.clearCachedObjects();
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get positionOffsetY() {
    return this._positionOffsetY;
  }
  set positionOffsetY(value) {
    this._positionOffsetY = value;
    this._parentRenderer.clearCachedObjects();
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get panelHrzAlign() {
    return this._panelHrzAlign;
  }
  set panelHrzAlign(value) {
    if (!this._overlap && value == GenericPanel.HorizontalAlignPos.CENTER && this._panelVrtAlign == GenericPanel.VerticalAlignPos.CENTER) {
      this._panelVrtAlign = GenericPanel.VerticalAlignPos.TOP;
    }
    this._panelHrzAlign = value;
    this._parentRenderer.clearCachedObjects();
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get panelVrtAlign() {
    return this._panelVrtAlign;
  }
  set panelVrtAlign(value) {
    if (!this._overlap && value == GenericPanel.VerticalAlignPos.CENTER && this._panelHrzAlign == GenericPanel.HorizontalAlignPos.CENTER) {
      this._panelHrzAlign = GenericPanel.HorizontalAlignPos.RIGHT;
    }
    this._panelVrtAlign = value;
    this._parentRenderer.clearCachedObjects();
    if (this._enabled)
      this._parentRenderer.redraw();
  }
};
var Zone = class {
  constructor(parentRenderer, directParent) {
    this._userData = null;
    this._zoneBrush = null;
    this._color = YColor.Red;
    this._visible = false;
    this._min = 0;
    this._max = 100;
    this._directParent = directParent;
    this._parentRenderer = parentRenderer;
  }
  get directParent() {
    return this._directParent;
  }
  get userData() {
    return this._userData;
  }
  set userData(value) {
    this._userData = value;
  }
  resetCache() {
  }
  get zoneBrush() {
    if (this._zoneBrush == null)
      this._zoneBrush = new YSolidBrush(this._color);
    return this._zoneBrush;
  }
  get color() {
    return this._color;
  }
  set color(value) {
    this._color = value;
    this._zoneBrush = null;
    if (this.visible)
      this._parentRenderer.redraw();
  }
  get visible() {
    return this._visible;
  }
  set visible(value) {
    this._visible = value;
    this._parentRenderer.redraw();
  }
  set_minMax(min, max) {
    if (min > max)
      throw new RangeError("Min cannot be greater than max ");
    this._min = min;
    this._max = max;
    this.resetCache();
    if (this.visible)
      this._parentRenderer.redraw();
  }
  get min() {
    return this._min;
  }
  set min(value) {
    if (value >= this._max && !YDataRenderer.minMaxCheckDisabled) {
      throw new RangeError("Min cannot be greater than max (" + this._max.toString() + ")");
    }
    this._min = value;
    this.resetCache();
    if (this.visible)
      this._parentRenderer.redraw();
  }
  get max() {
    return this._max;
  }
  set max(value) {
    if (value <= this._min && !YDataRenderer.minMaxCheckDisabled) {
      throw new RangeError("Max cannot be greater than min (" + this._min.toString() + ")");
    }
    this._max = value;
    this.resetCache();
    if (this.visible)
      this._parentRenderer.redraw();
  }
};
var Proportional = class {
  constructor(value, resizeRule, parentRenderer, directParent, resetCallBack) {
    this._reset = null;
    this._refWidth = 1;
    this._refHeight = 1;
    this._refValue = 1;
    this.valueStack = [];
    this._resizeRule = Proportional.ResizeRule.FIXED;
    this._userData = null;
    this._reset = resetCallBack;
    this._parentRenderer = parentRenderer;
    this._value = value;
    this._resizeRule = resizeRule;
    this._directParent = directParent;
    this.set_refPoint();
    this._parentRenderer.AddNewProportionalToSizeValue(this);
  }
  get userData() {
    return this._userData;
  }
  set userData(value) {
    this._userData = value;
  }
  get directParent() {
    return this._directParent;
  }
  get value() {
    return this._value;
  }
  set value(v) {
    this._value = v;
    this.set_refPoint();
    if (this._reset != null)
      this._reset(this);
  }
  get resizeRule() {
    return this._resizeRule;
  }
  set resizeRule(value) {
    this.set_refPoint();
    this._resizeRule = value;
  }
  set_refPoint() {
    this._refWidth = Math.max(1, this._parentRenderer.usableUiWidth());
    this._refHeight = Math.max(1, this._parentRenderer.usableUiHeight());
    this._refValue = this._value;
  }
  containerResizedPushNewCoef(coef) {
    this.valueStack.push(this._value);
    this._value = Math.round(100 * this._refValue * coef) / 100;
    if (this._reset != null)
      this._reset(this);
  }
  containerResizedPop() {
    if (this.valueStack.length <= 0)
      throw new RangeError("Can't pop, empty stack.");
    this._value = this.valueStack.pop();
    if (this._reset != null)
      this._reset(this);
  }
  static resizeCoef(rule, refWidth, refHeight, newWidth, newHeight) {
    switch (rule) {
      case Proportional.ResizeRule.RELATIVETOWIDTH:
        return newWidth / refWidth;
      case Proportional.ResizeRule.RELATIVETOHEIGHT:
        return newHeight / refHeight;
      case Proportional.ResizeRule.RELATIVETOBOTH:
        return Math.min(newHeight / refHeight, newWidth / refWidth);
    }
    return 1;
  }
  containerResized(newWidth, newHeight) {
    this._value = Math.round(100 * this._refValue * Proportional.resizeCoef(this._resizeRule, this._refWidth, this._refHeight, newWidth, newHeight)) / 100;
    if (this._reset != null)
      this._reset(this);
  }
  forceChangeCallback() {
    if (this._reset != null)
      this._reset(this);
  }
};
(function(Proportional2) {
  class ResizeRuleEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, ResizeRule);
    }
  }
  Proportional2.ResizeRuleEnumItem = ResizeRuleEnumItem;
  class ResizeRule extends YEnum {
  }
  ResizeRule.FIXED = new ResizeRuleEnumItem("FIXED", "Fixed");
  ResizeRule.RELATIVETOWIDTH = new ResizeRuleEnumItem("RELATIVETOWIDTH", "Relative to Width");
  ResizeRule.RELATIVETOHEIGHT = new ResizeRuleEnumItem("RELATIVETOHEIGHT", "Relative to height");
  ResizeRule.RELATIVETOBOTH = new ResizeRuleEnumItem("RELATIVETOBOTH", "Relative to Width and Height");
  Proportional2.ResizeRule = ResizeRule;
})(Proportional || (Proportional = {}));
var YDataRenderer = class {
  constructor(UIContainer, logFunction) {
    this._redrawAllowed = 1;
    this._refWidth = 1;
    this._refHeight = 1;
    this.rendererTimingTotal = 0;
    this.rendererTimingCount = 0;
    this._PatchAnnotationCallback = null;
    this._logFunction = null;
    this._annotationPanels = [];
    this._userData = null;
    this.documentVisibiltyChangeFct = null;
    this.containerResizedFct = null;
    this._getCaptureParameters = null;
    this.OnDblClick = null;
    this.OnRightClick = null;
    this._messagePanels = [];
    this._Scr2ElmMatrix = null;
    this._Elm2ScrMatrix = null;
    this.ProportionalToSizeValues = [];
    this._proportionnalValueChangeCallback = null;
    this._resizeRule = Proportional.ResizeRule.FIXED;
    this.requestAnimationFrameID = null;
    this._snapshotPanel = null;
    this._snapshotTimer = null;
    this._AllowPrintScreenCapture = false;
    if (!YDataRenderer.globalMouseMoveSet) {
      document.addEventListener("mousemove", (e) => {
        YDataRenderer.globalMouseMove(e);
      });
      YDataRenderer.globalMouseMoveSet = true;
    }
    this.UIContainer = UIContainer;
    this.UIContainer.width = this.getContainerInnerWidth();
    this.UIContainer.height = this.getContainerInnerHeight();
    this._logFunction = logFunction;
    this.parentForm = UIContainer.ownerDocument;
    this._annotationPanels = [];
    this._messagePanels = [];
    this.DisableRedraw();
    this._snapshotPanel = this.addMessagePanel();
    this._snapshotPanel.panelTextAlign = MessagePanel.TextAlign.CENTER;
    this._snapshotPanel.text = "Captured to clipboard";
    this._snapshotPanel.panelHrzAlign = MessagePanel.HorizontalAlignPos.CENTER;
    this._snapshotPanel.panelVrtAlign = MessagePanel.VerticalAlignPos.CENTER;
    this._snapshotPanel.bgColor = new YColor(false, 200, 204, 247, 161);
    this._snapshotPanel.font.size = 16;
    this.AllowRedrawNoRefresh();
    this.containerResizedFct = () => {
      this.containerResize(null, null);
    };
    document.addEventListener("resize", this.containerResizedFct);
    this.resetRefrenceSize();
    this.documentVisibiltyChangeFct = () => {
      if (document.visibilityState === "visible") {
        this.redraw();
      }
    };
    document.addEventListener("visibilitychange", this.documentVisibiltyChangeFct);
  }
  get annotationPanels() {
    return this._annotationPanels;
  }
  get userData() {
    return this._userData;
  }
  static get minMaxCheckDisabled() {
    return YDataRenderer._disableMinMaxCheck;
  }
  static set minMaxCheckDisabled(value) {
    YDataRenderer._disableMinMaxCheck = value;
  }
  resetlegendPens() {
  }
  get getCaptureParameters() {
    return this._getCaptureParameters;
  }
  set getCaptureParameters(value) {
    this._getCaptureParameters = value;
  }
  get messagePanels() {
    return this._messagePanels;
  }
  static globalMouseMove(e) {
    YDataRenderer.globalMouseX = e.pageX;
    YDataRenderer.globalMouseY = e.pageY;
  }
  clearTransformationMatrix() {
    this._Scr2ElmMatrix = null;
    this._Elm2ScrMatrix = null;
  }
  findElementAbsolutePosition(el) {
    let staticFound = false;
    let relativeFound = false;
    let dx = 0;
    let dy = 0;
    while (el != null) {
      let style = window.getComputedStyle(el);
      if (!relativeFound && style.position == "static" && !staticFound) {
        dx = el.offsetLeft + parseFloat(style.borderLeftWidth);
        dy = el.offsetTop + parseFloat(style.borderTopWidth);
        staticFound = true;
      }
      if (style.position == "relative" || style.position == "absolute") {
        dx += el.offsetLeft + parseFloat(style.borderLeftWidth);
        dy += el.offsetTop + parseFloat(style.borderTopWidth);
        relativeFound = true;
      }
      el = el.parentElement;
    }
    return new PointF(dx, dy);
  }
  get Elm2ScrMatrix() {
    if (this._Elm2ScrMatrix == null) {
      let el = this.UIContainer;
      let AsolutePositionsStack = [];
      while (el != null) {
        AsolutePositionsStack.push(this.findElementAbsolutePosition(el));
        el = el.parentElement;
      }
      el = this.UIContainer;
      let MatrixStack = [];
      let staticFound = false;
      let relativeFound = false;
      let index = 0;
      while (el != null) {
        let parent = el.parentElement;
        let style = window.getComputedStyle(el);
        let dx = AsolutePositionsStack[index].X;
        let dy = AsolutePositionsStack[index].Y;
        if (index < AsolutePositionsStack.length - 1) {
          dx -= AsolutePositionsStack[index + 1].X;
          dy -= AsolutePositionsStack[index + 1].Y;
        }
        let matrix = style["transform"];
        if (matrix != "none") {
          let matrixStr = matrix.match(/matrix.*\((.+)\)/)[1].split(", ");
          let matrixValues = [];
          for (let i = 0; i < 6; i++) {
            matrixValues.push(parseFloat(matrixStr[i]));
          }
          let OriginMatrixMatrixBefore = null;
          let TransformMatrix = Matrix3x3.newMatrix(matrixValues[0], matrixValues[2], matrixValues[4], matrixValues[1], matrixValues[3], matrixValues[5], 0, 0, 1);
          let OriginMatrixMatrixAfter = null;
          if (style.transformOrigin) {
            let parts = style.transformOrigin.split(" ");
            let Ox = Number.parseFloat(parts[0]);
            let Oy = Number.parseFloat(parts[1]);
            OriginMatrixMatrixBefore = Matrix3x3.newTranslateMatrix(-Ox, -Oy);
            OriginMatrixMatrixAfter = Matrix3x3.newTranslateMatrix(Ox, Oy);
          }
          if (OriginMatrixMatrixBefore != null)
            MatrixStack.push(OriginMatrixMatrixBefore);
          if (TransformMatrix != null)
            MatrixStack.push(TransformMatrix);
          if (OriginMatrixMatrixAfter != null)
            MatrixStack.push(OriginMatrixMatrixAfter);
        }
        if (dx != 0 || dy != 0)
          MatrixStack.push(Matrix3x3.newTranslateMatrix(dx, dy));
        el = parent;
        index++;
      }
      this._Elm2ScrMatrix = Matrix3x3.newIdentityMatrix();
      for (let i = MatrixStack.length - 1; i >= 0; i--) {
        this._Elm2ScrMatrix = this._Elm2ScrMatrix.multiplyByM(MatrixStack[i]);
      }
    }
    return this._Elm2ScrMatrix;
  }
  get Scr2ElmMatrix() {
    if (this._Scr2ElmMatrix == null) {
      this._Scr2ElmMatrix = this.Elm2ScrMatrix.inverse;
    }
    return this._Scr2ElmMatrix;
  }
  addAnnotationPanel() {
    let p = new AnnotationPanel(this, this);
    this._annotationPanels.push(p);
    this.redraw();
    return p;
  }
  AllowRedraw() {
    this._redrawAllowed--;
    if (this._redrawAllowed < 0)
      throw new RangeError("Too many AllowRedraw calls");
    if (this._redrawAllowed == 0)
      this.redraw();
  }
  AllowRedrawNoRefresh() {
    this._redrawAllowed--;
    if (this._redrawAllowed < 0)
      throw new RangeError("Too many AllowRedraw calls");
  }
  DisableRedraw() {
    this._redrawAllowed++;
  }
  AddNewProportionalToSizeValue(v) {
    if (this.ProportionalToSizeValues.indexOf(v) < 0)
      this.ProportionalToSizeValues.push(v);
  }
  canRedraw() {
    return this._redrawAllowed == 0;
  }
  setPatchAnnotationCallback(callback) {
    this._PatchAnnotationCallback = callback;
  }
  patchAnnotation(text) {
    text = text.replace("\\n", "\n");
    if (text.indexOf("$") < 0)
      return text;
    let now = new Date();
    text = text.replace("$DAY$", now.getDay().toString());
    text = text.replace("$MONTH$", now.getMonth().toString());
    text = text.replace("$YEAR$", now.getFullYear().toString());
    text = text.replace("$HOUR$", now.getHours().toString());
    text = text.replace("$MINUTE$", now.getMinutes().toString());
    text = text.replace("$SECOND$", now.getSeconds().toString());
    if (this._PatchAnnotationCallback != null)
      text = this._PatchAnnotationCallback(text);
    return text;
  }
  mouseLocalPosition() {
    let v = Vector3.FromXYCoord(YDataRenderer.globalMouseX, YDataRenderer.globalMouseY);
    let m = this.Scr2ElmMatrix;
    let p = m.multiplyByV(v).toPoint();
    if (p.X < 0 || p.Y < 0 || p.X > this.UIContainer.offsetWidth || p.Y > this.UIContainer.offsetHeight)
      return null;
    return p;
  }
  set proportionnalValueChangeCallback(value) {
    this._proportionnalValueChangeCallback = value;
  }
  ProportionnalValueChanged(source) {
    if (this._proportionnalValueChangeCallback != null)
      this._proportionnalValueChangeCallback(source);
  }
  getContainerInnerWidth() {
    return this.UIContainer.offsetWidth;
  }
  getContainerInnerHeight() {
    return this.UIContainer.offsetHeight;
  }
  Draw(timestamp) {
    if (!this.canRedraw())
      return 0;
    let w = this.getContainerInnerWidth();
    let h = this.getContainerInnerHeight();
    if (w <= 5 || h <= 5)
      return 0;
    this.DisableRedraw();
    let offscreenCanvas = document.createElement("canvas");
    offscreenCanvas.width = w;
    offscreenCanvas.height = h;
    let g = new YGraphics(offscreenCanvas, w, h, 90);
    let start = performance.now();
    try {
      this.Render(g, w, h);
    } catch (e) {
      debugger;
      this.log("Rendering error: " + e.message);
    }
    let elapsed = performance.now() - start;
    let drawArea = this.UIContainer.getContext("2d");
    drawArea.clearRect(0, 0, w, h);
    drawArea.drawImage(offscreenCanvas, 0, 0);
    this.rendererTimingTotal += elapsed;
    this.rendererTimingCount++;
    let avg = this.rendererTimingTotal / this.rendererTimingCount;
    g.Dispose();
    this.AllowRedrawNoRefresh();
    this.renderingPostProcessing();
    return 0;
  }
  renderingPostProcessing() {
  }
  get resizeRule() {
    return this._resizeRule;
  }
  set resizeRule(value) {
    if (value != this._resizeRule) {
      this.DisableRedraw();
      this._resizeRule = value;
      for (let i = 0; i < this.ProportionalToSizeValues.length; i++) {
        this.ProportionalToSizeValues[i].resizeRule = this._resizeRule;
      }
      this.AllowRedraw();
      this.redraw();
    }
  }
  redraw() {
    if (!(document.visibilityState === "visible"))
      return;
    if (this._redrawAllowed > 0)
      return;
    if (this.getContainerInnerWidth() < 2)
      return;
    if (this.getContainerInnerHeight() < 2)
      return;
    if (this.requestAnimationFrameID != null) {
      window.cancelAnimationFrame(this.requestAnimationFrameID);
    }
    this.requestAnimationFrameID = window.requestAnimationFrame((timestamp) => {
      try {
        this.Draw(timestamp);
      } catch (e) {
        console.log("caught");
        this.requestAnimationFrameID = null;
        throw e;
      }
      this.requestAnimationFrameID = null;
    });
  }
  usableUiWidth() {
    return this.getContainerInnerWidth();
  }
  usableUiHeight() {
    return this.getContainerInnerHeight();
  }
  resetProportionalSizeObjectsCachePush(newcoef) {
    this.clearCachedObjects();
    if (this._resizeRule != Proportional.ResizeRule.FIXED) {
      for (let i = 0; i < this.ProportionalToSizeValues.length; i++) {
        this.ProportionalToSizeValues[i].containerResizedPushNewCoef(newcoef);
      }
    }
  }
  resetProportionalSizeObjectsCachePop() {
    this.clearCachedObjects();
    if (this._resizeRule != Proportional.ResizeRule.FIXED) {
      for (let i = 0; i < this.ProportionalToSizeValues.length; i++) {
        this.ProportionalToSizeValues[i].containerResizedPop();
      }
    }
  }
  resetProportionalSizeObjectsCache(w, h) {
    this.clearCachedObjects();
    if (this._resizeRule != Proportional.ResizeRule.FIXED) {
      for (let i = 0; i < this.ProportionalToSizeValues.length; i++) {
        this.ProportionalToSizeValues[i].containerResized(w, h);
      }
    }
  }
  containerResized() {
    this.containerResize(null, null);
  }
  containerResize(sender, e) {
    this.clearTransformationMatrix();
    this.DisableRedraw();
    this.UIContainer.width = this.UIContainer.offsetWidth;
    this.UIContainer.height = this.UIContainer.offsetHeight;
    this.resetProportionalSizeObjectsCache(this.usableUiWidth(), this.usableUiHeight());
    this.AllowRedraw();
    this.redraw();
  }
  proportionnalsizeReset() {
    this.resetProportionalSizeObjectsCache(this.usableUiWidth(), this.usableUiHeight());
  }
  captureAndDownloadImage(captureType, defaultFilename, captureWidth, captureHeight, captureDPI) {
    let error = "";
    let w;
    let h;
    let ratio = this.getContainerInnerWidth() / this.getContainerInnerHeight();
    if (captureDPI == null)
      captureDPI = 90;
    if (defaultFilename == null || typeof defaultFilename == "undefined") {
      defaultFilename = "capture.";
      if (captureType == YDataRenderer.CaptureType.PNG) {
        defaultFilename = defaultFilename + "png";
      }
      if (captureType == YDataRenderer.CaptureType.SVG) {
        defaultFilename = defaultFilename + "svg";
      }
    }
    if (captureWidth == null || typeof captureWidth == "undefined") {
      w = this.getContainerInnerWidth();
      if (captureHeight == null || typeof captureHeight == "undefined") {
        h = this.getContainerInnerHeight();
      } else {
        h = captureHeight >> 0;
        w = h * ratio >> 0;
      }
    } else {
      w = captureWidth >> 0;
      if (captureHeight == null || typeof captureHeight == "undefined") {
        h = w * ratio >> 0;
      } else {
        h = captureHeight >> 0;
      }
    }
    if (w <= 5 || h <= 5)
      return;
    this.DisableRedraw();
    let DrawArea = document.createElement("canvas");
    DrawArea.width = w;
    DrawArea.height = h;
    let g;
    switch (captureType) {
      case YDataRenderer.CaptureType.PNG:
        g = new YGraphics(DrawArea, w, h, captureDPI);
        break;
      case YDataRenderer.CaptureType.SVG:
        g = new YGraphicsSVG(DrawArea, w, h, captureDPI);
        break;
      default:
        throw new RangeError("capture :unknown type");
    }
    let newCoef = Proportional.resizeCoef(Proportional.ResizeRule.RELATIVETOBOTH, this.refWidth, this.refHeight, w, h);
    this.log("start capture");
    this.resetProportionalSizeObjectsCachePush(newCoef);
    let renderok = false;
    this._snapshotPanel.enabled = false;
    try {
      let t = this.Render(g, w, h);
      renderok = true;
    } catch (e) {
      error = e.message;
      this.log("Render error: " + error);
    }
    this.log("capture completed");
    this.resetProportionalSizeObjectsCachePop();
    if (renderok) {
      let element = document.createElement("a");
      let data = g.get_downloadableData();
      element.setAttribute("href", data);
      element.setAttribute("download", defaultFilename);
      element.style.display = "none";
      document.body.appendChild(element);
      element.click();
      document.body.removeChild(element);
    }
    g.Dispose();
    this.AllowRedraw();
  }
  getFocus(sender, e) {
    this.log("got focus");
  }
  gainFocus() {
  }
  lostFocus(sender, e) {
  }
  get AllowPrintScreenCapture() {
    return this._AllowPrintScreenCapture;
  }
  set AllowPrintScreenCapture(value) {
    this._AllowPrintScreenCapture = value;
  }
  destroy() {
    document.removeEventListener("visibilitychange", this.documentVisibiltyChangeFct);
    document.removeEventListener("resize", this.containerResized);
    this.UIContainer.parentNode.removeChild(this.UIContainer);
    this.UIContainer = null;
    this.parentForm = null;
    this._annotationPanels = null;
    this._messagePanels = null;
    this._Scr2ElmMatrix = null;
    this._Elm2ScrMatrix = null;
  }
  resetRefrenceSize() {
    this._refWidth = this.getContainerInnerWidth();
    this._refHeight = this.getContainerInnerHeight();
  }
  get refWidth() {
    return this._refWidth;
  }
  get refHeight() {
    return this._refHeight;
  }
  RendererCanvas_Click(sender, e) {
  }
  RendererCanvas_DoubleClick(sender, e) {
  }
  addMessagePanel() {
    let p = new MessagePanel(this, this);
    this._messagePanels.push(p);
    return p;
  }
  DrawMessagePanels(g, viewPortWidth, viewPortHeight) {
    for (let i = 0; i < this._messagePanels.length; i++) {
      if (this._messagePanels[i].enabled) {
        let p = this._messagePanels[i];
        let AvailableWidth = viewPortWidth - 2 * p.padding - p.borderthickness;
        if (AvailableWidth < 100)
          AvailableWidth = 100;
        let ssize = null;
        let sizeok = false;
        while (!sizeok) {
          ssize = g.MeasureString(p.text, p.font, AvailableWidth);
          if ((ssize.width >= this.UIContainer.width || ssize.height >= this.UIContainer.height) && p.font.size > 5) {
            p.font.size = Math.round(p.font.size * 9) / 10;
          } else
            sizeok = true;
        }
        if (ssize == null)
          return;
        let panelWidth = ssize.width + 2 * p.padding + p.borderthickness;
        let panelHeight = ssize.height + 2 * p.padding + p.borderthickness;
        let x = 0;
        switch (p.panelHrzAlign) {
          case MessagePanel.HorizontalAlignPos.LEFT:
            x = p.horizontalMargin;
            break;
          case MessagePanel.HorizontalAlignPos.RIGHT:
            x = viewPortWidth - panelWidth - p.horizontalMargin;
            break;
          default:
            x = (viewPortWidth - panelWidth) / 2;
            break;
        }
        let y = 0;
        switch (p.panelVrtAlign) {
          case MessagePanel.VerticalAlignPos.TOP:
            y = p.verticalMargin;
            break;
          case MessagePanel.VerticalAlignPos.BOTTOM:
            y = viewPortHeight - panelHeight - p.verticalMargin;
            break;
          default:
            y = (viewPortHeight - panelHeight) / 2;
            break;
        }
        g.FillRectangleXYHW(p.bgBrush, x, y, panelWidth, panelHeight);
        if (p.borderthickness > 0)
          g.DrawRectangleXYHW(p.pen, x, y, panelWidth, panelHeight);
        let sf = new YStringFormat(16384);
        switch (p.panelTextAlign) {
          case MessagePanel.TextAlign.LEFT:
            sf.LineAlignment = 0;
            sf.Alignment = 0;
            break;
          case MessagePanel.TextAlign.RIGHT:
            sf.LineAlignment = 2;
            sf.Alignment = 2;
            break;
          default:
            sf.LineAlignment = 1;
            sf.Alignment = 1;
            break;
        }
        let r = new YRectangle(x + p.padding + p.borderthickness / 2 >> 0, y + p.padding + p.borderthickness / 2 >> 0, ssize.width + 1, ssize.height + 1);
        g.DrawStringRect(p.text, p.font, p.font.brush, r, sf);
      }
    }
  }
  drawAnnotationPanels(g, annotationPanels, viewPortWidth, viewPortHeight, overlap, mainViewPort) {
    let active = false;
    for (let i = 0; i < this.annotationPanels.length; i++) {
      if (this.annotationPanels[i].enabled)
        active = true;
    }
    if (!active)
      return;
    for (let i = 0; i < this.annotationPanels.length; i++) {
      if (annotationPanels[i].enabled && annotationPanels[i].overlap == overlap) {
        let p = annotationPanels[i];
        let AvailableWidth = viewPortWidth - 2 * p.padding - p.borderthickness;
        if (AvailableWidth < 100)
          AvailableWidth = 100;
        let textToDisplay = p.text.replace("\\n", "\n");
        if (textToDisplay.indexOf("$") >= 0) {
          textToDisplay = textToDisplay.replace("\\n", "\n");
          textToDisplay = this.patchAnnotation(textToDisplay);
        }
        let ssize = g.MeasureString(textToDisplay, p.font, AvailableWidth);
        let panelWidth = ssize.width + 2 * p.padding + p.borderthickness;
        let panelHeight = ssize.height + 2 * p.padding + p.borderthickness;
        let x = 0;
        switch (p.panelHrzAlign) {
          case MessagePanel.HorizontalAlignPos.LEFT:
            x = p.horizontalMargin;
            if (!annotationPanels[i].overlap && mainViewPort.Lmargin < panelWidth + 10) {
              mainViewPort.Lmargin = panelWidth + 10;
            }
            break;
          case MessagePanel.HorizontalAlignPos.RIGHT:
            x = viewPortWidth - panelWidth - p.horizontalMargin;
            if (!annotationPanels[i].overlap && mainViewPort.Rmargin < panelWidth + 20) {
              mainViewPort.Rmargin = panelWidth + 20;
            }
            break;
          default:
            x = (viewPortWidth - panelWidth) / 2;
            break;
        }
        let y = 0;
        switch (p.panelVrtAlign) {
          case MessagePanel.VerticalAlignPos.TOP:
            y = p.verticalMargin;
            if (!annotationPanels[i].overlap && mainViewPort.Tmargin < panelHeight + 20) {
              mainViewPort.Tmargin = panelHeight + 20;
            }
            break;
          case MessagePanel.VerticalAlignPos.BOTTOM:
            y = viewPortHeight - panelHeight - p.verticalMargin;
            if (!annotationPanels[i].overlap && mainViewPort.Bmargin < panelHeight + 20) {
              mainViewPort.Bmargin = panelHeight + 20;
            }
            break;
          default:
            y = (viewPortHeight - panelHeight) / 2;
            break;
        }
        if (annotationPanels[i].overlap) {
          x += annotationPanels[i].positionOffsetX / 100 * (viewPortWidth - panelWidth);
          y += annotationPanels[i].positionOffsetY / 100 * (viewPortHeight - panelHeight);
          if (x < 0)
            x = 0;
          if (y < 0)
            y = 0;
          if (x > viewPortWidth - panelWidth)
            x = viewPortWidth - panelWidth;
          if (y > viewPortHeight - panelHeight)
            y = viewPortHeight - panelHeight;
        }
        g.FillRectangleXYHW(p.bgBrush, x, y, panelWidth, panelHeight);
        if (p.borderthickness > 0)
          g.DrawRectangleXYHW(p.pen, x, y, panelWidth, panelHeight);
        let sf = new YStringFormat(16384);
        switch (p.panelTextAlign) {
          case MessagePanel.TextAlign.LEFT:
            sf.LineAlignment = 0;
            sf.Alignment = 0;
            break;
          case MessagePanel.TextAlign.RIGHT:
            sf.LineAlignment = 2;
            sf.Alignment = 2;
            break;
          default:
            sf.LineAlignment = 1;
            sf.Alignment = 1;
            break;
        }
        let r = new YRectangle(x + p.padding + p.borderthickness / 2, y + p.padding + p.borderthickness / 2, ssize.width + 1, ssize.height + 1);
        g.DrawStringRect(textToDisplay, p.font, p.font.brush, r, sf);
      }
    }
  }
  log(s) {
    if (this._logFunction == null)
      return;
    this._logFunction(s);
  }
};
YDataRenderer.RendererDebug = false;
YDataRenderer.FloatToStrformats = ["0", "0", "0", "0.0", "0.00", "0.000", "0.0000"];
YDataRenderer._disableMinMaxCheck = false;
YDataRenderer.globalMouseMoveSet = false;
YDataRenderer.globalMouseX = -1;
YDataRenderer.globalMouseY = -1;
(function(YDataRenderer2) {
  class CaptureTypeEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, CaptureType);
    }
  }
  YDataRenderer2.CaptureTypeEnumItem = CaptureTypeEnumItem;
  class CaptureType extends YEnum {
  }
  CaptureType.PNG = new CaptureTypeEnumItem("PNG", "Bitmap (PNG)");
  CaptureType.SVG = new CaptureTypeEnumItem("SVG", "Vector (SVG)");
  YDataRenderer2.CaptureType = CaptureType;
  class CaptureTargetEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, CaptureTarget);
    }
  }
  YDataRenderer2.CaptureTargetEnumItem = CaptureTargetEnumItem;
  class CaptureTarget extends YEnum {
  }
  CaptureTarget.ToClipBoard = new CaptureTargetEnumItem("ToClipBoard", "ClipBoard");
  CaptureTarget.ToFile = new CaptureTargetEnumItem("ToFile", "File");
  YDataRenderer2.CaptureTarget = CaptureTarget;
  class CaptureFormatsEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, CaptureFormats);
    }
  }
  YDataRenderer2.CaptureFormatsEnumItem = CaptureFormatsEnumItem;
  class CaptureFormats extends YEnum {
  }
  CaptureFormats.Keep = new CaptureFormatsEnumItem("Keep", "Keep original size");
  CaptureFormats.Fixed = new CaptureFormatsEnumItem("Fixed", "Fixed size");
  CaptureFormats.FixedWidth = new CaptureFormatsEnumItem("FixedWidth", "Fixed width, keep ration aspect");
  CaptureFormats.FixedHeight = new CaptureFormatsEnumItem("FixedHeight", "Fixed height, keep ration aspect");
  YDataRenderer2.CaptureFormats = CaptureFormats;
})(YDataRenderer || (YDataRenderer = {}));
var YGraphics = class {
  constructor(canvas, width, height, dpi) {
    this._c = null;
    this._g = null;
    this._width = 0;
    this._height = 0;
    this._dpi = 0;
    this._image = null;
    this._lastPen = null;
    this._lastBrush = null;
    this._lastFont = null;
    this._clipCounter = 0;
    this._textRenderingHint = null;
    this._smoothingMode = YSmoothingMode.Default;
    this._c = canvas;
    this._g = this._c.getContext("2d");
    this._g.textBaseline = "top";
    this._width = width;
    this._height = height;
    this._dpi = dpi;
  }
  get_downloadableData() {
    return this._c.toDataURL("image/png");
  }
  get graphics() {
    return this._g;
  }
  setPen(p) {
    if (p == this._lastPen)
      return;
    if (p != null) {
      this._g.lineWidth = p.lineWidth;
      let st = p.strokeStyle;
      this._g.strokeStyle = p.strokeStyle;
    } else {
      this._g.lineWidth = 0;
    }
    this._lastPen = p;
  }
  setBrush(b) {
    if (b == this._lastBrush)
      return;
    if (b instanceof YSolidBrush) {
      this._g.fillStyle = b.color.htmlCode;
    } else if (b instanceof YLinearGradientBrush) {
      let lingrad = this._g.createLinearGradient(0, 0, 0, this._height);
      lingrad.addColorStop(0, b.color1.htmlCode);
      lingrad.addColorStop(1, b.color2.htmlCode);
      this._g.fillStyle = lingrad;
    } else {
      throw new Error("invalid / insupported brush type");
    }
    this._lastBrush = b;
  }
  setFont(f) {
    if (f == this._lastFont && !f.hasChanged)
      return;
    this._g.font = f.htmlCode;
    this._lastFont = f;
  }
  DrawLineXY(p, x1, y1, x2, y2) {
    if (p.noAntiAlias) {
      let offset = p.lineWidth == p.lineWidth >> 0 && (p.lineWidth & 1) == 1 ? 0.5 : 0;
      x1 = Math.round(x1) + offset;
      y1 = Math.round(y1) + offset;
      x2 = Math.round(x2) + offset;
      y2 = Math.round(y2) + offset;
    }
    this.setPen(p);
    this._g.beginPath();
    this._g.moveTo(x1, y1);
    this._g.lineTo(x2, y2);
    this._g.stroke();
  }
  DrawLine(p, p1, p2) {
    this.setPen(p);
    this._g.beginPath();
    this._g.moveTo(p1.X, p1.Y);
    this._g.lineTo(p2.X, p2.Y);
    this._g.stroke();
  }
  SetClip(rect) {
    this._g.save();
    this._g.beginPath();
    this._g.rect(rect.x, rect.y, rect.w, rect.h);
    this._g.clip();
    this._clipCounter++;
  }
  ResetClip() {
    if (this._clipCounter <= 0)
      throw new Error("clipping stack error");
    this._g.restore();
    this._clipCounter--;
  }
  MeasureString(text, font, width) {
    this.setFont(font);
    let res = new YSizeF(font, text);
    let count = res.linesCount;
    if (count == 0)
      return res;
    res.height = res.firstLineHeight * 1.2 + (count - 1) * res.lineHeight;
    let max = 0;
    let dim;
    for (let i = 0; i < count; i++) {
      dim = this._g.measureText(res.lines[i]);
      max = Math.max(max, dim.width);
    }
    res.width = max;
    return res;
  }
  MeasureStringSF(text, font, width, stringFormat) {
    return this.MeasureString(text, font, width);
  }
  FillRectangle(brush, rect) {
    this.setBrush(brush);
    this._g.beginPath();
    this._g.fillRect(rect.x, rect.y, rect.w, rect.h);
    this._g.fill();
  }
  FillRectangleXYHW(brush, x, y, width, height) {
    this.setBrush(brush);
    this._g.beginPath();
    this._g.fillRect(x, y, width, height);
    this._g.fill();
  }
  DrawRectangle(p, rect) {
    this.setPen(p);
    this._g.beginPath();
    if (p.noAntiAlias) {
      let offset = p.lineWidth == p.lineWidth >> 0 && (p.lineWidth & 1) == 1 ? 0.5 : 0;
      this._g.rect(Math.round(rect.x) + offset, Math.round(rect.y) + offset, Math.round(rect.w), Math.round(rect.h));
    } else {
      this._g.rect(rect.x, rect.y, rect.w, rect.h);
    }
    this._g.stroke();
  }
  DrawRectangleXYHW(p, x, y, width, height) {
    if (p.noAntiAlias) {
      let offset = p.lineWidth == p.lineWidth >> 0 && (p.lineWidth & 1) == 1 ? 0.5 : 0;
      x = Math.round(x) + offset;
      y = Math.round(y) + offset;
      width = Math.round(width);
      height = Math.round(height);
    }
    this.setPen(p);
    this._g.beginPath();
    this._g.rect(x, y, width, height);
    this._g.stroke();
  }
  DrawStringXY(s, font, brush, x, y) {
    this.setPen(null);
    this.setBrush(brush);
    this.setFont(font);
    let totalsz = this.MeasureString(s, font, 0);
    let dy = totalsz.lineHeight;
    for (let i = 0; i < totalsz.linesCount; i++) {
      this._g.fillText(totalsz.lines[i], x, y);
      y += dy;
    }
  }
  DrawStringXYF(s, font, brush, x, y, format) {
    if (YGraphics._debugDrawString) {
      let pen = new YPen(YColor.Red, 1);
      this.DrawLineXY(pen, x - 5, y, x + 5, y);
      this.DrawLineXY(pen, x, y - 5, x, y + 5);
    }
    let sz = this.MeasureString(s, font, 1e4);
    if (format.Alignment == 1) {
      x -= sz.width >> 1;
    } else if (format.Alignment == 2)
      x -= sz.width;
    if (format.LineAlignment == 1) {
      y -= sz.height / 2 >> 0;
    } else if (format.LineAlignment == 2)
      y -= sz.height;
    this.DrawStringXY(s, font, brush, x, y);
  }
  DrawStringPF(s, font, brush, p, format) {
    this.DrawStringXYF(s, font, brush, p.X, p.Y, format);
  }
  DrawString(s, font, brush, p) {
    if (YGraphics._debugDrawString) {
      let pen = new YPen(YColor.Red, 1);
      this.DrawLineXY(pen, p.X - 5, p.Y, p.X + 5, p.Y);
      this.DrawLineXY(pen, p.X, p.Y - 5, p.X, p.Y + 5);
    }
    this.setPen(null);
    this.setBrush(brush);
    this.setFont(font);
    this._g.fillText(s, p.X, p.Y);
  }
  DrawStringRect(s, font, brush, layoutRectangle, format) {
    if (YGraphics._debugDrawString) {
      let pen = new YPen(YColor.Red, 1);
      this.DrawRectangle(pen, layoutRectangle);
    }
    this.setPen(null);
    this.setBrush(brush);
    this.setFont(font);
    let totalsz = this.MeasureString(s, font, 0);
    let dy = totalsz.lineHeight;
    let y = layoutRectangle.y;
    switch (format.LineAlignment) {
      case 0:
        break;
      case 1:
        y += (layoutRectangle.h - totalsz.height) / 2;
        break;
      case 2:
        y += layoutRectangle.h - totalsz.height;
        break;
    }
    let xOrigin = layoutRectangle.x;
    if (format.FormatFlags & 2) {
      this.Transform(layoutRectangle.x, layoutRectangle.y, Math.PI / 2);
      y -= layoutRectangle.y + layoutRectangle.w;
      xOrigin -= layoutRectangle.x;
    }
    for (let i = 0; i < totalsz.linesCount; i++) {
      let s2 = totalsz.lines[i];
      let sz = this.MeasureString(s2, font, 0);
      let x = xOrigin;
      switch (format.Alignment) {
        case 0:
          break;
        case 1:
          x += (layoutRectangle.w - sz.width) / 2;
          break;
        case 2:
          x += layoutRectangle.w - sz.width;
          break;
      }
      this._g.fillText(s2, x, y);
      y += dy;
    }
    if (format.FormatFlags & 2)
      this.ResetTransform();
  }
  Transform(dx, dy, angle) {
    let sin = Math.sin(angle);
    let cos = Math.cos(angle);
    this._g.save();
    this._g.transform(cos, sin, -sin, cos, dx, dy);
  }
  ResetTransform() {
    this._g.restore();
  }
  FillEllipse(brush, x, y, width, height) {
    this.setBrush(brush);
    this._g.beginPath();
    this._g.ellipse(x + width / 2, y + height / 2, width / 2, height / 2, 0, 0, 2 * Math.PI);
    this._g.fill();
  }
  DrawEllipse(pen, x, y, width, height) {
    this.setPen(pen);
    this._g.beginPath();
    this._g.ellipse(x + width / 2, y + height / 2, width / 2, height / 2, 0, 0, 2 * Math.PI);
    this._g.stroke();
  }
  FillPolygon(brush, points) {
    this.setBrush(brush);
    if (points.length <= 2)
      return;
    this._g.beginPath();
    if (brush.noAntiAlias) {
      this._g.moveTo(Math.round(points[0].X) + 0.5, Math.round(points[0].Y) + 0.5);
      for (let i = 1; i < points.length; i++) {
        this._g.lineTo(Math.round(points[i].X) + 0.5, Math.round(points[i].Y) + 0.5);
      }
    } else {
      this._g.moveTo(points[0].X, points[0].Y);
      for (let i = 1; i < points.length; i++) {
        this._g.lineTo(points[i].X, points[i].Y);
      }
    }
    this._g.closePath();
    this._g.fill();
  }
  DrawPolygon(pen, points) {
    this.setPen(pen);
    if (points.length <= 1)
      return;
    this._g.beginPath();
    if (pen.noAntiAlias) {
      let offset = pen.lineWidth == pen.lineWidth >> 0 && (pen.lineWidth & 1) == 1 ? 0.5 : 0;
      this._g.moveTo(Math.round(points[0].X) + offset, Math.round(points[0].Y) + offset);
      for (let i = 1; i < points.length; i++) {
        this._g.lineTo(Math.round(points[i].X) + offset, Math.round(points[i].Y) + offset);
      }
    } else {
      this._g.moveTo(points[0].X, points[0].Y);
      for (let i = 1; i < points.length; i++) {
        this._g.lineTo(points[i].X, points[i].Y);
      }
    }
    this._g.closePath();
    this._g.stroke();
  }
  DrawLines(pen, points) {
    this.setPen(pen);
    if (points.length <= 1)
      return;
    this._g.beginPath();
    this._g.lineCap = "round";
    this._g.lineJoin = "round";
    this._g.moveTo(points[0].X, points[0].Y);
    for (let i = 1; i < points.length; i++) {
      this._g.lineTo(points[i].X, points[i].Y);
    }
    this._g.stroke();
  }
  Dispose() {
    this._c = null;
    this._g = null;
    this._width = 0;
    this._height = 0;
    this._dpi = 0;
  }
  get TextRenderingHint() {
    return this._textRenderingHint;
  }
  set TextRenderingHint(value) {
    this._textRenderingHint = value;
  }
  get SmoothingMode() {
    return this._smoothingMode;
  }
  set SmoothingMode(value) {
    this._smoothingMode = value;
  }
  DrawImage(srcimage, destRect, srcRect, srcUnit) {
    this._g.drawImage(srcimage, srcRect.x, srcRect.y, srcRect.w, srcRect.h, destRect.x, destRect.y, destRect.w, destRect.h);
  }
  comment(s) {
  }
};
YGraphics._debugDrawString = false;
var YGraphicsSVG = class extends YGraphics {
  constructor(canvas, width, height, dpi) {
    super(canvas, width, height, dpi);
    this._clipcount = 0;
    this._clipSectionsToClose = 0;
    this._transformSectionsToClose = 0;
    this._gradientCount = 0;
    YGraphicsSVG.SVGID++;
    this._SVGdefs = new YStringBuilder();
    this._SVGcontents = new YStringBuilder();
    this._SVGdefs.AppendLine('<clipPath id="pageClip_' + YGraphicsSVG.SVGID.toString() + '"><rect x="0" y="0"  width="' + width.toString() + '" height="' + height.toString() + '"/></clipPath>');
  }
  static escapeXml(unsafe) {
    return unsafe.replace(/[^ !#$%(-;=?-z]/g, (c) => "&#" + c.charCodeAt(0) + ";");
  }
  get_downloadableData() {
    return "data:image/svg+xml;base64," + btoa(this.get_svgContents());
  }
  DrawLineXY(p, x1, y1, x2, y2) {
    this._SVGcontents.AppendLine('<line x1="' + x1.toString() + '"  y1 ="' + y1.toString() + '"  x2 ="' + x2.toString() + '"  y2 ="' + y2.toString() + '" style = "stroke:' + p.color.svgCode + ";stroke-opacity:" + p.color.alphaCode + "; stroke-width:" + p.lineWidth.toString() + '"/>');
  }
  DrawLine(p, p1, p2) {
    this.DrawLineXY(p, p1.X, p1.Y, p2.X, p2.Y);
  }
  SetClip(rect) {
    this.ResetClip();
    this._SVGdefs.AppendLine('<clipPath id="clip_' + YGraphicsSVG.SVGID.toString() + "_" + this._clipcount.toString() + '"><rect x="' + rect.x.toString() + '" y="' + rect.y.toString() + '"  width="' + rect.w.toString() + '" height="' + rect.h.toString() + '"/></clipPath>');
    this._SVGcontents.AppendLine('<g clip-path="url(#clip_' + YGraphicsSVG.SVGID.toString() + "_" + this._clipcount.toString() + ')">');
    this._clipcount++;
    this._clipSectionsToClose++;
  }
  ResetClip() {
    if (this._clipSectionsToClose > 0) {
      this._SVGcontents.AppendLine("</g>");
      this._clipSectionsToClose--;
    }
  }
  BrushToSVG(brush, revert) {
    let fillParam = "";
    if (brush instanceof YSolidBrush) {
      fillParam = 'fill = "' + brush.color.svgCode + '" fill-opacity="' + brush.color.alphaCode + '" ';
    } else if (brush instanceof YLinearGradientBrush) {
      this._SVGdefs.AppendLine('<linearGradient id="grad_' + YGraphicsSVG.SVGID.toString() + "_" + this._gradientCount + '" x1="0%" ' + (revert ? 'y1="100%" ' : 'y1="0%" ') + 'x2="0%" ' + (revert ? 'y2="0%" ' : 'y2="100%" ') + '>\r\n<stop offset="0%" style ="stop-color:' + brush.color1.svgCode + ";stop-opacity:" + brush.color1.alphaCode + '"/>\r\n<stop offset="100%" style ="stop-color:' + brush.color2.svgCode + ";stop-opacity:" + brush.color2.alphaCode + '"/>\r\n</linearGradient>');
      fillParam = 'fill="url(#grad_' + YGraphicsSVG.SVGID.toString() + "_" + this._gradientCount + ')" ';
      this._gradientCount++;
    } else {
      throw new ReferenceError("unsupported brush type.");
    }
    return fillParam;
  }
  FillRectangle(brush, rect) {
    this._SVGcontents.AppendLine('<rect x="' + rect.x.toString() + '"  y ="' + rect.y.toString() + '"  width ="' + rect.w.toString() + '"  height ="' + rect.h.toString() + '" ' + this.BrushToSVG(brush, true) + 'style="stroke-width:0"/>');
  }
  FillRectangleXYHW(brush, x, y, width, height) {
    this.FillRectangle(brush, new YRectangle(x, y, width, height));
  }
  DrawRectangle(p, rect) {
    this._SVGcontents.AppendLine('<rect x="' + rect.x.toString() + '"  y ="' + rect.y.toString() + '"  width ="' + rect.w.toString() + '"  height ="' + rect.h.toString() + '"  fill="none" style = "stroke:' + p.color.svgCode + ";stroke-opacity:" + p.color.alphaCode + "; stroke-width:" + p.lineWidth.toString() + '"/>');
  }
  DrawRectangleXYHW(p, x, y, width, height) {
    this.DrawRectangle(p, new YRectangle(x, y, width, height));
  }
  DrawEllipse(pen, x, y, width, height) {
    this._SVGcontents.AppendLine('<ellipse  cx="' + (x + width / 2).toString() + '"  cy ="' + (y + height / 2).toString() + '"  rx ="' + (width / 2).toString() + '"  ry ="' + (height / 2).toString() + '"  fill="none" style = "stroke:' + pen.color.svgCode + ";stroke-opacity:" + pen.color.alphaCode + "; stroke-width:" + pen.lineWidth.toString() + '"/>');
  }
  FillEllipse(brush, x, y, width, height) {
    this._SVGcontents.AppendLine('<ellipse  cx="' + (x + width / 2).toString() + '"  cy ="' + (y + height / 2).toString() + '"  rx ="' + (width / 2).toString() + '"  ry ="' + (height / 2).toString() + '" ' + this.BrushToSVG(brush, false) + 'style="stroke-width:0"/>');
  }
  DrawStringXY(s, font, brush, x, y) {
    let tokens = s.split("\n");
    for (let i = 0; i < tokens.length; i++) {
      s = tokens[i];
      this._SVGcontents.AppendLine('<text x="' + x.toString() + '" y="' + (y + font.sizeInPoints).toString() + '" text-anchor="start" font-family="' + font.name.toString() + '" font-size="' + font.sizeInPoints.toString() + 'pt" font-weight="' + (font.bold ? "bold" : "normal") + '" font-style="' + (font.italic ? "italic" : "normal") + '" ' + this.BrushToSVG(brush, false) + 'style="stroke-width:0">\r\n' + YGraphicsSVG.escapeXml(s) + "\r\n</text>");
      y += font.sizeInPoints * 1.75;
    }
  }
  DrawString(s, font, brush, p) {
    if (YGraphics._debugDrawString) {
      let pen = new YPen(YColor.Red, 1);
      this.DrawLineXY(pen, p.X - 5, p.Y, p.X + 5, p.Y);
      this.DrawLineXY(pen, p.X, p.Y - 5, p.X, p.Y + 5);
    }
    this.DrawStringXY(s, font, brush, p.X, p.Y);
  }
  DrawStringF(s, font, brush, point, format) {
    let totalsz = this.MeasureString(s, font, 0);
    let y = point.Y + font.size * 1.25;
    switch (format.LineAlignment) {
      case 0:
        break;
      case 1:
        y += -totalsz.height / 2;
        break;
      case 2:
        y += -totalsz.height;
        break;
    }
    let tokens = s.split("\n");
    for (let i = 0; i < tokens.length; i++) {
      let s2 = tokens[i];
      let sz = this.MeasureString(s2, font, 0);
      let x = point.X;
      switch (format.Alignment) {
        case 0:
          break;
        case 1:
          x += -sz.width / 2;
          break;
        case 2:
          x += -sz.width;
          break;
      }
      this._SVGcontents.AppendLine('<text x="' + x.toString() + '" y="' + y.toString() + '" text-anchor="start" font-family="' + font.name.toString() + '" font-size="' + font.sizeInPoints.toString() + 'pt" font-weight="' + (font.bold ? "bold" : "normal") + '" font-style="' + (font.italic ? "italic" : "normal") + '" ' + this.BrushToSVG(brush, false) + 'style="stroke-width:0">\r\n' + YGraphicsSVG.escapeXml(s2) + "\r\n</text>");
      y += font.sizeInPoints * 1.75;
    }
  }
  DrawStringRect(s, font, brush, layoutRectangle, format) {
    if (YGraphics._debugDrawString) {
      let pen = new YPen(YColor.Red, 1);
      this.DrawRectangle(pen, layoutRectangle);
    }
    let totalsz = this.MeasureString(s, font, 0);
    let y = layoutRectangle.y + font.sizeInPoints * 1.1;
    switch (format.LineAlignment) {
      case 0:
        break;
      case 1:
        y += (layoutRectangle.h - totalsz.height) / 2;
        break;
      case 2:
        y += layoutRectangle.h - totalsz.height;
        break;
    }
    let tokens = s.split("\n");
    for (let i = 0; i < tokens.length; i++) {
      let s2 = tokens[i];
      let sz = this.MeasureString(s2, font, 0);
      let x = layoutRectangle.x;
      switch (format.Alignment) {
        case 0:
          break;
        case 1:
          x += (layoutRectangle.w - sz.width) / 2;
          break;
        case 2:
          x += layoutRectangle.w - sz.width;
          break;
      }
      this._SVGcontents.AppendLine('<text x="' + x.toString() + '" y="' + y.toString() + '" text-anchor="start" font-family="' + font.name.toString() + '" font-size="' + (font.sizeInPoints * 1.1).toString() + 'pt" font-weight="' + (font.bold ? "bold" : "normal") + '" font-style="' + (font.italic ? "italic" : "normal") + '" ' + this.BrushToSVG(brush, false) + 'style="stroke-width:0">\r\n' + YGraphicsSVG.escapeXml(s2) + "\r\n</text>");
      y += font.sizeInPoints * 1.75;
    }
  }
  Transform(dx, dy, angle) {
    this._SVGcontents.AppendLine('<g transform="translate(' + dx.toString() + " " + dy.toString() + ") rotate(" + (180 * angle / Math.PI).toString() + ')">');
    this._transformSectionsToClose++;
  }
  ResetTransform() {
    if (this._transformSectionsToClose > 0) {
      this._SVGcontents.AppendLine("</g>");
      this._transformSectionsToClose--;
    }
  }
  DrawPolygon(pen, points) {
    if (points.length < 2)
      return;
    this._SVGcontents.Append('<path  d="M ' + points[0].X.toString() + " " + points[0].Y.toString());
    for (let i = 1; i < points.length; i += 1) {
      this._SVGcontents.Append(" L " + points[i].X.toString() + " " + points[i].Y.toString());
    }
    this._SVGcontents.AppendLine(' z" fill="none" style="stroke:' + pen.color.svgCode + ";stroke-opacity:" + pen.color.alphaCode + "; stroke-width:" + pen.lineWidth.toString() + '"/>');
  }
  DrawLines(pen, points) {
    if (points.length < 2)
      return;
    this._SVGcontents.Append('<path  d="M ' + points[0].X.toString() + " " + points[0].Y.toString());
    for (let i = 1; i < points.length; i++) {
      this._SVGcontents.Append(" L " + points[i].X.toString() + " " + points[i].Y.toString());
    }
    this._SVGcontents.AppendLine('" fill="none" style="stroke:' + pen.color.svgCode + ";stroke-opacity:" + pen.color.alphaCode + "; stroke-linecap:round; stroke-linejoin:round;stroke-width:" + pen.lineWidth.toString() + '"/>');
  }
  FillPolygon(brush, points) {
    if (points.length < 2)
      return;
    this._SVGcontents.Append('<path  d="M ' + points[0].X.toString() + " " + points[0].Y.toString());
    for (let i = 1; i < points.length; i++) {
      this._SVGcontents.Append(" L " + points[i].X.toString() + " " + points[i].Y.toString());
    }
    this._SVGcontents.AppendLine(' z" ' + this.BrushToSVG(brush, false) + 'style="stroke-width:0"/>\r\n');
  }
  DrawImage(image, destRect, srcRect, srcUnit) {
    throw new Error("DrawImage not supported, find an other way.");
  }
  save(filename) {
    throw new Error("Direct save to file not supported.");
  }
  comment(s) {
    this._SVGcontents.AppendLine("<!--" + s + "-->");
  }
  get_svgContents() {
    let physicalWidth = (2.54 * (this._width / this._dpi)).toFixed(3);
    let physicalheight = (2.54 * (this._height / this._dpi)).toFixed(3);
    while (this._clipSectionsToClose > 0) {
      this._SVGcontents.AppendLine("</g>");
      this._clipSectionsToClose--;
    }
    while (this._transformSectionsToClose > 0) {
      this._SVGcontents.AppendLine("</g>");
      this._transformSectionsToClose--;
    }
    return '<?xml version = "1.0" standalone = "no" ?>\r\n<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">\r\n<svg width = "' + physicalWidth + 'cm" height = "' + physicalheight + 'cm" viewBox = "0 0 ' + this._width.toString() + " " + this._height.toString() + '" xmlns = "http://www.w3.org/2000/svg" version = "1.1" >\r\n<defs>\r\n' + this._SVGdefs.contents + '</defs>\r\n<g clip-path="url(#pageClip_' + YGraphicsSVG.SVGID.toString() + ')">\r\n' + this._SVGcontents.contents + "</g>\r\n</svg>\n";
  }
};
YGraphicsSVG.SVGID = 0;

// obj/full/Renderer/YAngularGauge.js
var YAngularZone = class extends Zone {
  constructor(parentRenderer, directParent) {
    super(parentRenderer, directParent);
    this._path = null;
    this._width = 10;
    this._outerRadius = 98;
  }
  get path() {
    return this._path;
  }
  setPathSize(count) {
    this._path = new Array(count).fill(null);
  }
  setPathPoint(index, p) {
    this._path[index] = p;
  }
  resetPath() {
    this._path = null;
  }
  resetCache() {
    this.resetPath();
  }
  get width() {
    return this._width;
  }
  set width(value) {
    if (value <= 0)
      throw new RangeError("Width must be a positive value");
    this._width = value;
    this._path = null;
    this._parentRenderer.redraw();
  }
  get outerRadius() {
    return this._outerRadius;
  }
  set outerRadius(value) {
    this._outerRadius = Math.max(0, Math.min(100, value));
    this._path = null;
    this._parentRenderer.redraw();
  }
};
var YAngularGauge = class extends YDataRenderer {
  constructor(UIContainer, logFunction) {
    super(UIContainer, logFunction);
    this._min = 0;
    this._max = 100;
    this.SegmentMaxLength = 8;
    this._borderpen = null;
    this._borderColor = YColor.Black;
    this._bgBrush = null;
    this._backgroundColor1 = YColor.FromArgb(255, 240, 240, 240);
    this._backgroundColor2 = YColor.FromArgb(255, 200, 200, 200);
    this._borderThickness = 5;
    this._valueFormater = null;
    this._minmaxFormater = null;
    this._thickness = 20;
    this._value = 0;
    this._needleValue = 0;
    this._color1 = YColor.Green;
    this._color2 = YColor.Red;
    this._graduationPen = null;
    this._graduationColor = YColor.Black;
    this._graduationThickness = 2;
    this._graduationSize = 10;
    this._graduation = 10;
    this._unitFactor = 1;
    this._unit = "";
    this._subgraduationPen = null;
    this._subgraduationColor = YColor.Black;
    this._subgraduationThickness = 1;
    this._subgraduationSize = 5;
    this._graduationOuterRadiusSize = 98;
    this._subgraduationCount = 5;
    this._statusColor = YColor.Gray;
    this._statusLine = "";
    this._showNeedle = true;
    this._needleBrush = null;
    this._needleColor = YColor.Red;
    this._needleMaxSpeed = 5;
    this._needleLength1 = 90;
    this._needleLength2 = 5;
    this._needleWidth = 5;
    this._needleContourPen = null;
    this._needleContourColor = YColor.DarkRed;
    this._needleContourThickness = 1;
    this._showMinMax = true;
    this._path = null;
    this._graduationFont = new YFont(this, this, Math.min(this.getContainerInnerWidth(), this.getContainerInnerHeight()) / 15, null);
    this._unitFont = new YFont(this, this, Math.min(this.getContainerInnerWidth(), this.getContainerInnerHeight()) / 20, null);
    this._statusFont = new YFont(this, this, Math.min(this.getContainerInnerWidth(), this.getContainerInnerHeight()) / 15, null);
    this.unitFont.color = YColor.DarkGray;
    this._statusFont.color = YColor.DarkGray;
    this.resizeRule = Proportional.ResizeRule.RELATIVETOBOTH;
    this._zones = [];
  }
  get min() {
    return this._min;
  }
  set min(value) {
    if (value >= this._max && !YDataRenderer.minMaxCheckDisabled) {
      throw new RangeError("Min cannot be greater than max (" + this._max.toString() + ")");
    }
    this._min = value;
    for (let i = 0; i < this._zones.length; i++) {
      this._zones[i].resetPath();
    }
    if (this._needleValue < this._min) {
      this._needleValue = this._min;
    }
    this.redraw();
  }
  get max() {
    return this._max;
  }
  set max(value) {
    if (value <= this._min && !YDataRenderer.minMaxCheckDisabled) {
      throw new RangeError("Max cannot be less than min (" + this._min.toString() + ")");
    }
    this._max = value;
    for (let i = 0; i < this._zones.length; i++) {
      this._zones[i].resetPath();
    }
    if (this._needleValue > this._max) {
      this._needleValue = this._max;
    }
    this.redraw();
  }
  get borderpen() {
    if (this._borderpen == null) {
      this._borderpen = new YPen(this._borderColor, this._borderThickness);
      this._borderpen.startCap = 1;
      this._borderpen.endCap = 1;
    }
    return this._borderpen;
  }
  get borderColor() {
    return this._borderColor;
  }
  set borderColor(value) {
    this._borderColor = value;
    this._borderpen = null;
    this.redraw();
  }
  get backgroundColor1() {
    return this._backgroundColor1;
  }
  set backgroundColor1(value) {
    this._backgroundColor1 = value;
    this._bgBrush = null;
    this.redraw();
  }
  get backgroundColor2() {
    return this._backgroundColor2;
  }
  set backgroundColor2(value) {
    this._backgroundColor2 = value;
    this._bgBrush = null;
    this.redraw();
  }
  get borderThickness() {
    return this._borderThickness;
  }
  set borderThickness(value) {
    if (value < 0)
      throw new RangeError("thickness must be a positive value");
    this._borderThickness = value;
    this._borderpen = null;
    this.redraw();
  }
  get valueFormater() {
    return this._valueFormater;
  }
  set valueFormater(value) {
    this._valueFormater = value;
    this.redraw();
  }
  get minmaxFormater() {
    return this._minmaxFormater;
  }
  set minmaxFormater(value) {
    this._minmaxFormater = value;
    this.redraw();
  }
  get thickness() {
    return this._thickness;
  }
  set thickness(value) {
    if (value < 0)
      throw new RangeError("Thickness must be a positive value");
    this._thickness = Math.max(Math.min(value, 80), 1);
    this.redraw();
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value;
    this.redraw();
  }
  get color1() {
    return this._color1;
  }
  set color1(value) {
    this._color1 = value;
    this.redraw();
  }
  get color2() {
    return this._color2;
  }
  set color2(value) {
    this._color2 = value;
    this.redraw();
  }
  get graduationColor() {
    return this._graduationColor;
  }
  set graduationColor(value) {
    this._graduationColor = value;
    this._graduationPen = null;
    this.redraw();
  }
  get graduationThickness() {
    return this._graduationThickness;
  }
  set graduationThickness(value) {
    if (value < 0)
      throw new RangeError("Thickness must be a positive value");
    this._graduationThickness = value;
    this._graduationPen = null;
    this.redraw();
  }
  get graduationSize() {
    return this._graduationSize;
  }
  set graduationSize(value) {
    if (value <= 0)
      throw new RangeError("Graduation size must be a positive value");
    this._graduationSize = value;
    this.redraw();
  }
  get graduation() {
    return this._graduation;
  }
  set graduation(value) {
    this._graduation = value;
    this.redraw();
  }
  get unitFactor() {
    return this._unitFactor;
  }
  set unitFactor(value) {
    if (value == 0)
      throw new RangeError("Factor cannot be zero.");
    this._unitFactor = value;
    this.redraw();
  }
  get unit() {
    return this._unit;
  }
  set unit(value) {
    this._unit = value;
    this.redraw();
  }
  get unitFont() {
    return this._unitFont;
  }
  get subgraduationColor() {
    return this._subgraduationColor;
  }
  set subgraduationColor(value) {
    this._subgraduationColor = value;
    this._subgraduationPen = null;
    this.redraw();
  }
  get subgraduationThickness() {
    return this._subgraduationThickness;
  }
  set subgraduationThickness(value) {
    if (value < 0)
      throw new RangeError("Thickness must be a positive value");
    this._subgraduationThickness = value;
    this._subgraduationPen = null;
    this.redraw();
  }
  get subgraduationSize() {
    return this._subgraduationSize;
  }
  set subgraduationSize(value) {
    if (value <= 0)
      throw new RangeError("Size must be a positive value");
    this._subgraduationSize = value;
    this.redraw();
  }
  get graduationOuterRadiusSize() {
    return this._graduationOuterRadiusSize;
  }
  set graduationOuterRadiusSize(value) {
    this._graduationOuterRadiusSize = Math.max(0, Math.min(100, value));
    this.redraw();
  }
  get subgraduationCount() {
    return this._subgraduationCount;
  }
  set subgraduationCount(value) {
    if (value < 0)
      throw new RangeError("Count must be a positive value");
    this._subgraduationCount = value;
    this.redraw();
  }
  get statusColor() {
    return this._statusColor;
  }
  set statusColor(value) {
    this._statusColor = value;
    this.redraw();
  }
  get statusFont() {
    return this._unitFont;
  }
  get statusLine() {
    return this._statusLine;
  }
  set statusLine(value) {
    this._statusLine = value;
    this.redraw();
  }
  get showNeedle() {
    return this._showNeedle;
  }
  set showNeedle(value) {
    this._showNeedle = value;
    this.redraw();
  }
  get needleColor() {
    return this._needleColor;
  }
  set needleColor(value) {
    this._needleColor = value;
    this._needleBrush = null;
    this.redraw();
  }
  get needleMaxSpeed() {
    return this._needleMaxSpeed;
  }
  set needleMaxSpeed(value) {
    if (value <= 0)
      throw new RangeError("Speed must be a positive value");
    this._needleMaxSpeed = value;
    this.redraw();
  }
  get needleLength1() {
    return this._needleLength1;
  }
  set needleLength1(value) {
    this._needleLength1 = value;
    this.redraw();
  }
  get needleLength2() {
    return this._needleLength2;
  }
  set needleLength2(value) {
    this._needleLength2 = value;
    this.redraw();
  }
  get needleWidth() {
    return this._needleWidth;
  }
  set needleWidth(value) {
    if (value <= 0)
      throw new RangeError("Width must be a positive value");
    this._needleWidth = value;
    this.redraw();
  }
  get needleContourColor() {
    return this._needleContourColor;
  }
  set needleContourColor(value) {
    this._needleContourColor = value;
    this._needleContourPen = null;
    this.redraw();
  }
  get needleContourThickness() {
    return this._needleContourThickness;
  }
  set needleContourThickness(value) {
    if (value < 0)
      throw new RangeError("Thickness must be a positive value");
    this._needleContourThickness = value;
    this._needleContourPen = null;
    this.redraw();
  }
  get graduationFont() {
    return this._graduationFont;
  }
  get showMinMax() {
    return this._showMinMax;
  }
  set showMinMax(value) {
    this._showMinMax = value;
    this.redraw();
  }
  clearCachedObjects() {
    if (this._zones != null) {
      for (let i = 0; i < this._zones.length; i++) {
        this._zones[i].resetPath();
      }
    }
    this._path = null;
    this._bgBrush = null;
  }
  get zones() {
    return this._zones;
  }
  AddZone() {
    let z = new YAngularZone(this, this);
    this._zones.push(z);
    return z;
  }
  Render(g, w, h) {
    let mainViewPort = new ViewPortSettings();
    mainViewPort.Lmargin = 0;
    mainViewPort.Rmargin = 0;
    mainViewPort.Tmargin = 0;
    mainViewPort.Bmargin = 0;
    g.SmoothingMode = YSmoothingMode.HighQuality;
    g.TextRenderingHint = YTextRenderingHint.AntiAlias;
    let stringFormat4Sizing = new YStringFormat(16384);
    let stringFormat = new YStringFormat(16384);
    stringFormat.Alignment = 1;
    stringFormat.LineAlignment = 1;
    this.drawAnnotationPanels(g, this._annotationPanels, w, h, false, mainViewPort);
    g.TextRenderingHint = YTextRenderingHint.AntiAlias;
    let xcenter = mainViewPort.Lmargin + (w - mainViewPort.Lmargin - mainViewPort.Rmargin) / 2;
    let ycenter = mainViewPort.Tmargin + (h - mainViewPort.Tmargin - mainViewPort.Bmargin) / 2;
    let radius = Math.min((w - mainViewPort.Lmargin - mainViewPort.Rmargin) / 2, (h - mainViewPort.Tmargin - mainViewPort.Bmargin) / 2) - this.borderThickness;
    let circonference = 2 * radius * 3.14 >> 0;
    let AngleAperture = 4 * 2 * Math.PI / 5;
    if (this._path == null) {
      let outterlength = 2 * radius * Math.PI;
      let stepCount = outterlength / this.SegmentMaxLength >> 0;
      let stepsize = 2 * Math.PI / stepCount;
      this._path = new Array(stepCount).fill(null);
      let n = 0;
      for (let i = 0; i < stepCount; i++) {
        let a = 2 * i * Math.PI / stepCount;
        this._path[n++] = new PointF(xcenter + radius * Math.cos(a), ycenter - radius * Math.sin(a));
      }
    }
    if (this._bgBrush == null)
      this._bgBrush = new YLinearGradientBrush(this._backgroundColor1, this._backgroundColor2);
    if (this._borderpen == null) {
      this._borderpen = new YPen(this._borderColor, this._borderThickness);
      this._borderpen.linejoin = YPen.LineJoin.Round;
    }
    if (this._path.length > 3)
      g.FillPolygon(this._bgBrush, this._path);
    if (this._graduationPen == null)
      this._graduationPen = new YPen(this._graduationColor, this._graduationThickness);
    if (this._subgraduationPen == null)
      this._subgraduationPen = new YPen(this._subgraduationColor, this._subgraduationThickness);
    let unitDesc = (this._unitFactor != 1 ? "x" + this._unitFactor.toString() + " " : "") + this._unit;
    let size = g.MeasureStringSF(unitDesc.toString(), this._unitFont, 1e4, stringFormat4Sizing);
    let unitPos = new YRectangle(xcenter - size.width / 2 >> 0, ycenter + radius / 2 - size.height / 2 >> 0, size.width + 1 >> 0, size.height + 1 >> 0);
    g.DrawStringRect(unitDesc, this._unitFont, this._unitFont.brush, unitPos, stringFormat);
    if (this._statusLine != "") {
      size = g.MeasureStringSF(this._statusLine, this._statusFont, 1e4, stringFormat4Sizing);
      let statusPos = new YRectangle(xcenter - size.width / 2 >> 0, ycenter - radius / 3 - size.height / 2 >> 0, size.width + 1, size.height + 1);
      g.DrawStringRect(this._statusLine, this._statusFont, this._statusFont.brush, statusPos, stringFormat);
    }
    let firstGraduation;
    let gratuationCount;
    let Angle, C, S, R1, R2;
    let outerCoef = this._graduationOuterRadiusSize / 100;
    for (let i = 0; i < this._zones.length; i++) {
      if (this._zones[i].visible) {
        if (this._zones[i].path == null) {
          let zmin = Math.max(this._min, Math.min(this._max, this._zones[i].min));
          let zmax = Math.max(this._min, Math.min(this._max, this._zones[i].max));
          if (zmax > zmin) {
            let zOuterCoef = this._zones[i].outerRadius / 100;
            let Angle1 = (Math.PI - AngleAperture) / 2 + AngleAperture * (zmin - this._min) / (this._max - this._min);
            let Angle2 = (Math.PI - AngleAperture) / 2 + AngleAperture * (zmax - this._min) / (this._max - this._min);
            let outterlength = (Angle2 - Angle1) * radius;
            let stepCount = outterlength / this.SegmentMaxLength >> 0;
            if (stepCount < 2)
              stepCount = 2;
            this._zones[i].setPathSize(2 * stepCount + 2);
            for (let j = 0; j <= stepCount; j++) {
              let A = Angle1 + (Angle2 - Angle1) * j / stepCount;
              this._zones[i].setPathPoint(j, new PointF(xcenter - radius * zOuterCoef * Math.cos(A), ycenter - radius * zOuterCoef * Math.sin(A)));
            }
            let innerRadiusCoef = zOuterCoef - this._zones[i].width / 100;
            for (let j = stepCount; j >= 0; j--) {
              let A = Angle1 + (Angle2 - Angle1) * j / stepCount;
              this._zones[i].setPathPoint(2 * stepCount + 1 - j, new PointF(xcenter - radius * innerRadiusCoef * Math.cos(A), ycenter - radius * innerRadiusCoef * Math.sin(A)));
            }
          }
        }
        if (this._zones[i].path != null)
          g.FillPolygon(this._zones[i].zoneBrush, this._zones[i].path);
      }
    }
    firstGraduation = this._graduation * (this._min / this._graduation) >> 0;
    if (this._min < 0)
      firstGraduation -= this._graduation;
    while (firstGraduation < this._min) {
      firstGraduation += this._graduation;
    }
    gratuationCount = 1 + (this._max - this._min) / this._graduation >> 0;
    if (this._subgraduationCount > 0 && this._subgraduationCount * gratuationCount < circonference) {
      let subgraduation = this._graduation / this._subgraduationCount;
      firstGraduation = subgraduation * (this._min / subgraduation >> 0);
      if (this._min < 0)
        firstGraduation -= subgraduation;
      while (firstGraduation < this._min) {
        firstGraduation += subgraduation;
      }
      gratuationCount = 1 + (this._max - this._min) / subgraduation >> 0;
      for (let i = 0; i < gratuationCount; i++) {
        let value = firstGraduation + i * subgraduation;
        if (value <= this._max) {
          Angle = (Math.PI - AngleAperture) / 2 + AngleAperture * (value - this._min) / (this._max - this._min);
          C = Math.cos(Angle);
          S = Math.sin(Angle);
          R1 = outerCoef * (radius - this._borderThickness / 2);
          R2 = (100 - this._subgraduationSize) * (outerCoef * (radius - this._borderThickness / 2)) / 100;
          g.DrawLineXY(this._subgraduationPen, xcenter - R1 * C, ycenter - R1 * S, xcenter - R2 * C, ycenter - R2 * S);
        }
      }
    }
    if (gratuationCount < circonference) {
      for (let i = 0; i < gratuationCount; i++) {
        let gvalue = firstGraduation + i * this._graduation;
        if (gvalue <= this._max) {
          Angle = (Math.PI - AngleAperture) / 2 + AngleAperture * (gvalue - this._min) / (this._max - this._min);
          C = Math.cos(Angle);
          S = Math.sin(Angle);
          R1 = outerCoef * (radius - this._borderThickness / 2);
          R2 = (100 - this._graduationSize) * (outerCoef * (radius - this._borderThickness / 2)) / 100;
          g.DrawLineXY(this._graduationPen, xcenter - R1 * C, ycenter - R1 * S, xcenter - R2 * C, ycenter - R2 * S);
          size = g.MeasureStringSF(gvalue.toString().trim(), this._graduationFont, 1e3, stringFormat4Sizing);
          let HalfDiagonal = 0.4 * Math.sqrt(size.width * size.width + size.height * size.height);
          let position = new YRectangle(xcenter - (R2 - HalfDiagonal) * C - size.width / 2 >> 0, ycenter - (R2 - HalfDiagonal) * S - size.height / 2 >> 0, (size.width >> 0) + 1, size.height >> 0);
          g.DrawStringRect(gvalue.toString(), this._graduationFont, this._graduationFont.brush, position, stringFormat);
        }
      }
    }
    if (this._borderThickness > 0 && this._path.length > 3)
      g.DrawPolygon(this._borderpen, this._path);
    this.drawAnnotationPanels(g, this._annotationPanels, w, h, true, mainViewPort);
    if (this._showNeedle) {
      if (this._needleValue != this._value) {
        let step = this._unitFactor * this._needleMaxSpeed * (this._max - this._min) / 100;
        if (Math.abs(this._value - this._needleValue) < step) {
          this._needleValue = this._value;
        } else if (this._needleValue < this.value) {
          this._needleValue += step;
        } else {
          this._needleValue -= step;
        }
      }
      let needlevalue = this._needleValue / this._unitFactor;
      let allowedOverflow = (this._max - this.min) * 0.05;
      if (needlevalue < this._min - allowedOverflow)
        needlevalue = this._min - allowedOverflow;
      if (needlevalue > this._max + allowedOverflow)
        needlevalue = this._max + allowedOverflow;
      Angle = (Math.PI - AngleAperture) / 2 + AngleAperture * (needlevalue - this._min) / (this._max - this._min);
      C = Math.cos(Angle);
      S = Math.sin(Angle);
      R1 = radius * this._needleLength1 / 100;
      R2 = radius * this._needleLength2 / 100;
      let R3 = radius * this._needleWidth / 200;
      let needlepath = new Array(4).fill(null);
      needlepath[0] = new PointF(xcenter - R1 * C, ycenter - R1 * S);
      needlepath[1] = new PointF(xcenter + R3 * S, ycenter - R3 * C);
      needlepath[2] = new PointF(xcenter + R2 * C, ycenter + R2 * S);
      needlepath[3] = new PointF(xcenter - R3 * S, ycenter + R3 * C);
      if (this._needleBrush == null)
        this._needleBrush = new YSolidBrush(this._needleColor);
      g.FillPolygon(this._needleBrush, needlepath);
      if (this._needleContourThickness > 0) {
        if (this._needleContourPen == null) {
          this._needleContourPen = new YPen(this._needleContourColor, this._needleContourThickness);
          this._needleContourPen.startCap = 2;
          this._needleContourPen.endCap = 2;
          this._needleContourPen.linejoin = YPen.LineJoin.Round;
        }
        let needlepath2 = new Array(5).fill(null);
        needlepath2[0] = needlepath[0];
        needlepath2[1] = needlepath[1];
        needlepath2[2] = needlepath[2];
        needlepath2[3] = needlepath[3];
        needlepath2[4] = needlepath[0];
        g.DrawLines(this._needleContourPen, needlepath2);
      }
    }
    this.DrawMessagePanels(g, w, h);
    return 0;
  }
  renderingPostProcessing() {
    if (this._needleValue != this._value)
      this.redraw();
  }
};

// obj/full/Renderer/YDigitalDisplay.js
var YDigitalDisplay = class extends YDataRenderer {
  constructor(UIContainer, logFunction) {
    super(UIContainer, logFunction);
    this._bgBrush = null;
    this._backgroundColor1 = YColor.Black;
    this._backgroundColor2 = YColor.FromArgb(255, 48, 48, 48);
    this._alternateValue = null;
    this._valueFormater = null;
    this._hrzAlignmentOfset = 5;
    this._hrzAlignment = YDigitalDisplay.HrzAlignment.DECIMAL;
    this._outOfRangeMin = Number.NaN;
    this._outOfRangeMax = Number.NaN;
    this._outOfRangeColor = YColor.Red;
    this._value = 0;
    this._font = new YFont(this, this, Math.min(UIContainer.width / 5, UIContainer.height / 2), null);
    this._font.color = YColor.LightGreen;
    this.resizeRule = Proportional.ResizeRule.RELATIVETOBOTH;
  }
  get backgroundColor1() {
    return this._backgroundColor1;
  }
  set backgroundColor1(value) {
    this._backgroundColor1 = value;
    this._bgBrush = null;
    this.redraw();
  }
  get backgroundColor2() {
    return this._backgroundColor2;
  }
  set backgroundColor2(value) {
    this._backgroundColor2 = value;
    this._bgBrush = null;
    this.redraw();
  }
  get alternateValue() {
    return this._alternateValue;
  }
  set alternateValue(value) {
    this._alternateValue = value;
    this.redraw();
  }
  get valueFormater() {
    return this._valueFormater;
  }
  set valueFormater(value) {
    this._valueFormater = value;
    this.redraw();
  }
  get hrzAlignmentOfset() {
    return this._hrzAlignmentOfset;
  }
  set hrzAlignmentOfset(value) {
    this._hrzAlignmentOfset = value;
    this.redraw();
  }
  get hrzAlignment() {
    return this._hrzAlignment;
  }
  set hrzAlignment(value) {
    this._hrzAlignment = value;
    this.redraw();
  }
  get outOfRangeMin() {
    return this._outOfRangeMin;
  }
  set outOfRangeMin(value) {
    if (!Number.isNaN(value) && !Number.isNaN(this._outOfRangeMax) && !YDataRenderer.minMaxCheckDisabled) {
      if (value >= this._outOfRangeMax)
        throw new RangeError("Min cannot be greater than max (" + this._outOfRangeMax.toString() + ")");
    }
    this._outOfRangeMin = value;
    this.redraw();
  }
  get outOfRangeMax() {
    return this._outOfRangeMax;
  }
  set outOfRangeMax(value) {
    if (!Number.isNaN(value) && !Number.isNaN(this._outOfRangeMin) && !YDataRenderer.minMaxCheckDisabled) {
      if (value <= this._outOfRangeMin)
        throw new RangeError("Min cannot be less than max (" + this._outOfRangeMin.toString() + ")");
    }
    this._outOfRangeMax = value;
    this.redraw();
  }
  get outOfRangeColor() {
    return this._outOfRangeColor;
  }
  set outOfRangeColor(value) {
    this._outOfRangeColor = value;
    this.redraw();
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value;
    this.redraw();
  }
  get font() {
    return this._font;
  }
  clearCachedObjects() {
    if (this.font != null)
      this.font.ResetFont(null);
    this._bgBrush = null;
  }
  Render(g, w, h) {
    let mainViewPort = new ViewPortSettings();
    mainViewPort.Lmargin = 0;
    mainViewPort.Rmargin = 0;
    mainViewPort.Tmargin = 0;
    mainViewPort.Bmargin = 0;
    g.SmoothingMode = YSmoothingMode.HighQuality;
    g.TextRenderingHint = YTextRenderingHint.AntiAlias;
    let stringFormat = new YStringFormat(16384);
    stringFormat.Alignment = 1;
    stringFormat.LineAlignment = 1;
    if (this._bgBrush == null) {
      this._bgBrush = new YLinearGradientBrush(this._backgroundColor1, this._backgroundColor2);
    }
    g.FillRectangleXYHW(this._bgBrush, 0, 0, w, h);
    this.drawAnnotationPanels(g, this._annotationPanels, w, h, false, mainViewPort);
    if (mainViewPort.Tmargin >= 20)
      mainViewPort.Tmargin -= 10;
    if (mainViewPort.Bmargin >= 20)
      mainViewPort.Bmargin -= 10;
    g.TextRenderingHint = YTextRenderingHint.AntiAlias;
    let availWidth = w - (mainViewPort.Lmargin + mainViewPort.Rmargin);
    let availHeight = h - (mainViewPort.Tmargin + mainViewPort.Bmargin);
    if (availWidth > 10 && availHeight > 10) {
      let svalue;
      if (this._alternateValue == null) {
        svalue = this._valueFormater == null ? this.value.toFixed(3) : this._valueFormater(this, this.value);
        if (!Number.isNaN(this._outOfRangeMin) && this.value < this._outOfRangeMin) {
          this.font.alternateColor = this._outOfRangeColor;
        } else if (!Number.isNaN(this._outOfRangeMax) && this.value > this._outOfRangeMax) {
          this.font.alternateColor = this._outOfRangeColor;
        } else {
          this.font.alternateColor = null;
        }
      } else {
        this._font.alternateColor = null;
        svalue = this._alternateValue;
      }
      let size = g.MeasureStringSF(svalue, this.font, 1e4, stringFormat);
      let pos;
      let align = this._hrzAlignment;
      if (this._alternateValue != null && align == YDigitalDisplay.HrzAlignment.DECIMAL)
        align = YDigitalDisplay.HrzAlignment.RIGHT;
      if (align == YDigitalDisplay.HrzAlignment.DECIMAL && svalue.indexOf(".") < 0)
        align = YDigitalDisplay.HrzAlignment.RIGHT;
      switch (align) {
        case YDigitalDisplay.HrzAlignment.LEFT:
          pos = new YRectangle(mainViewPort.Lmargin + (availWidth * this.hrzAlignmentOfset / 100 >> 0), mainViewPort.Tmargin + (availHeight - size.height) / 2 >> 0, size.width + 1 >> 0, size.height + 1 >> 0);
          g.DrawStringRect(svalue, this.font, this.font.brush, pos, stringFormat);
          break;
        case YDigitalDisplay.HrzAlignment.CENTER:
          pos = new YRectangle(mainViewPort.Lmargin + (availWidth - size.width) / 2 >> 0, mainViewPort.Tmargin + (availHeight - size.height) / 2 >> 0, size.width + 1 >> 0, size.height + 1 >> 0);
          g.DrawStringRect(svalue, this.font, this.font.brush, pos, stringFormat);
          break;
        case YDigitalDisplay.HrzAlignment.DECIMAL:
          let left = "";
          let p = svalue.lastIndexOf(",");
          if (p < 0)
            p = svalue.lastIndexOf(".");
          if (p >= 0) {
            left = svalue.substring(0, p + 1);
          } else {
            p = 0;
            while (p < svalue.length && (svalue[p] >= "0" && svalue[p] <= "9" || svalue[p] == "-" || svalue[p] == "'" || svalue[p] == " ")) {
              p++;
            }
            left = svalue.substring(0, p);
          }
          let lsize = g.MeasureStringSF(left, this.font, 1e4, stringFormat);
          pos = new YRectangle(mainViewPort.Lmargin + (availWidth - lsize.width - availWidth * this.hrzAlignmentOfset / 100) >> 0, mainViewPort.Tmargin + (availHeight - size.height) / 2 >> 0, size.width + 1 >> 0, size.height + 1 >> 0);
          g.DrawStringRect(svalue, this.font, this.font.brush, pos, stringFormat);
          break;
        case YDigitalDisplay.HrzAlignment.RIGHT:
          pos = new YRectangle(mainViewPort.Lmargin + (availWidth - size.width - availWidth * this.hrzAlignmentOfset / 100) >> 0, mainViewPort.Tmargin + (availHeight - size.height) / 2 >> 0, size.width + 1 >> 0, size.height + 1 >> 0);
          g.DrawStringRect(svalue, this.font, this.font.brush, pos, stringFormat);
          break;
      }
    }
    this.drawAnnotationPanels(g, this._annotationPanels, w, h, true, mainViewPort);
    this.DrawMessagePanels(g, w, h);
    return 0;
  }
};
(function(YDigitalDisplay2) {
  class HrzAlignmentEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, HrzAlignment);
    }
  }
  YDigitalDisplay2.HrzAlignmentEnumItem = HrzAlignmentEnumItem;
  class HrzAlignment extends YEnum {
  }
  HrzAlignment.LEFT = new HrzAlignmentEnumItem("LEFT", "Left");
  HrzAlignment.CENTER = new HrzAlignmentEnumItem("CENTER", "Center");
  HrzAlignment.DECIMAL = new HrzAlignmentEnumItem("DECIMAL", "Decimal");
  HrzAlignment.RIGHT = new HrzAlignmentEnumItem("RIGHT", "Right");
  YDigitalDisplay2.HrzAlignment = HrzAlignment;
})(YDigitalDisplay || (YDigitalDisplay = {}));

// obj/full/Renderer/YGraph.js
var SUMMARY_GRANULARITY = 100;
var pointXY = class {
  constructor(X, Y) {
    this.x = X === void 0 ? 0 : X;
    this.y = Y === void 0 ? 0 : Y;
  }
  clone() {
    return new pointXY(this.x, this.y);
  }
};
var pointsSummary = class {
  constructor(X1, X2, YMIN, YMAX) {
    this.x1 = X1;
    this.x2 = X2;
    this.ymin = YMIN;
    this.ymax = YMAX;
  }
  clone() {
    return new pointsSummary(this.x1, this.x2, this.ymin, this.ymin);
  }
};
var TimeConverterParseResult = class {
  constructor() {
    this.success = false;
    this.result = 0;
  }
};
var TimeResolution = class {
  constructor() {
    this.step = 0;
    this.format = 0;
  }
};
var YDate = class extends Date {
  ToString(format) {
    let res = "";
    let ampm = "";
    if (format & YDate.D)
      res = res + this.getDate() + " ";
    if (format & YDate.M)
      res = res + YDate.months[this.getMonth()] + " ";
    if (format & YDate.YY) {
      let y = this.getFullYear().toString();
      res = res + y.substr(y.length - 2) + " ";
    } else if (format & YDate.YYYY) {
      let y = this.getFullYear().toString();
      res = res + y + " ";
    }
    if (format & YDate.CR)
      res = res + "\n";
    if (format & YDate.h) {
      if (YDate.use24Hformat) {
        let h = "0" + this.getHours().toString();
        res = res + h.substring(h.length - 2);
        if (!(format & YDate.m))
          res = res + "H";
      } else {
        let hour = this.getHours();
        ampm = "AM";
        if (hour > 11)
          ampm = "PM";
        if (hour > 12)
          hour = hour - 12;
        if (hour == 0)
          hour = 12;
        res = res + hour.toString();
      }
    }
    if (format & YDate.m) {
      let m = "0" + this.getMinutes().toString();
      res = res + ":" + m.substring(m.length - 2);
    }
    if (format & YDate.s) {
      let s = "0" + this.getSeconds().toString();
      res = res + ":" + s.substring(s.length - 2);
    }
    if (format & YDate.ms1) {
      let ms = "00" + this.getMilliseconds().toString();
      res = res + "." + ms.substring(ms.length - 3).substring(1);
    } else if (format & YDate.ms01) {
      let ms = "00" + this.getMilliseconds().toString();
      res = res + "." + ms.substring(ms.length - 3).substring(2);
    } else if (format & YDate.ms001) {
      let ms = "00" + this.getMilliseconds().toString();
      res = res + "." + ms.substring(ms.length - 3).substring(3);
    }
    if (format & YDate.h && !YDate.use24Hformat) {
      res = res + ampm;
    }
    return res;
  }
};
YDate.D = 1;
YDate.DD = 2;
YDate.M = 4;
YDate.YY = 8;
YDate.h = 16;
YDate.m = 32;
YDate.s = 64;
YDate.ms1 = 128;
YDate.ms01 = 256;
YDate.ms001 = 512;
YDate.CR = 1024;
YDate.isRelative = 2048;
YDate.YYYY = 4096;
YDate.d = new Date().toLocaleTimeString().toUpperCase();
YDate.use24Hformat = YDate.d.indexOf("AM") < 0 && YDate.d.indexOf("PM") < 0;
YDate.months = ["jan", "feb", "mar", "apr", "may", "jun", "jul", "aug", "sep", "oct", "nov", "dec"];
var TimeConverter = class {
  static UTCNow() {
    return new YDate();
  }
  static ToUnixTime(datetime) {
    return datetime.getTime() / 1e3;
  }
  static FromUnixTime(unixtime) {
    let t = new YDate();
    t.setTime(unixtime * 1e3);
    return t;
  }
  static tryParseStringToAbsDateTime(str) {
    let res = new TimeConverterParseResult();
    res.success = false;
    let date = new Date();
    let year = date.getFullYear();
    let month = date.getMonth();
    let day = date.getDate();
    let hours = 0;
    let minutes = 0;
    let seconds = 0;
    str = str.trim();
    while (str.indexOf("  ") > 0) {
      str = str.replace("  ", " ");
    }
    let dateFound = false;
    let timeFound = false;
    let it = str.split(" ");
    if (it.length <= 0)
      return res;
    for (let i = 0; i < it.length && i < 2; i++) {
      if (it[i].indexOf("-") > 0) {
        let tokens = it[i].split("-");
        if (tokens.length == 1) {
          day = parseInt(tokens[0]);
        } else if (tokens.length == 2) {
          day = parseInt(tokens[1]);
          month = parseInt(tokens[0]) - 1;
        } else {
          day = parseInt(tokens[2]);
          month = parseInt(tokens[1]) - 1;
          year = parseInt(tokens[0]);
        }
        dateFound = true;
      } else if (it[i].indexOf(":") > 0) {
        let tokens = it[i].split(":");
        if (tokens.length == 1) {
          hours = parseInt(tokens[0]);
        } else if (tokens.length == 2) {
          hours = parseInt(tokens[0]);
          minutes = parseInt(tokens[1]);
        } else {
          hours = parseInt(tokens[0]);
          minutes = parseInt(tokens[1]);
          seconds = parseFloat(tokens[2]);
        }
        timeFound = true;
      }
    }
    if (!timeFound && !dateFound)
      return res;
    if (isNaN(year) || isNaN(month) || isNaN(day) || isNaN(hours) || isNaN(minutes) || isNaN(seconds))
      return res;
    date.setFullYear(year, month, day);
    date.setHours(hours, minutes, seconds >> 0, 1e3 * (seconds % 1) >> 0);
    res.result = date.getTime() / 1e3;
    res.success = true;
    return res;
  }
  static tryParseStringToSecTimeSpan(st) {
    let res = new TimeConverterParseResult();
    let d = 0;
    st = st.toUpperCase();
    let n = st.indexOf("D");
    if (n > 0) {
      d = parseFloat(st.substring(0, n));
      if (isNaN(d)) {
        return res;
      }
      res.result += +d * 86400;
      if (n == st.length - 1) {
        res.success = true;
        return res;
      }
      st = st.substring(n + 1);
    }
    n = st.indexOf("H");
    if (n > 0) {
      d = parseFloat(st.substring(0, n));
      if (isNaN(d)) {
        return res;
      }
      res.result += d * 3600;
      if (n == st.length - 1) {
        res.success = true;
        return res;
      }
      st = st.substring(n + 1);
    }
    n = st.indexOf("M");
    if (n > 0) {
      d = parseFloat(st.substring(0, n));
      if (isNaN(d)) {
        return res;
      }
      res.result += d * 60;
      if (n == st.length - 1) {
        res.success = true;
        return res;
      }
      st = st.substring(n + 1);
    }
    n = st.indexOf("S");
    if (n < 0)
      n = st.length;
    d = parseFloat(st.substring(0, n));
    if (isNaN(d)) {
      return res;
    }
    res.result += d;
    res.success = true;
    return res;
  }
  static secTimeSpanToString(timespan, resolution) {
    let started = false;
    let res = "";
    if (timespan < 0) {
      res = "-";
      timespan = -timespan;
    }
    if (timespan >= 86400) {
      let d = timespan / 86400 >> 0;
      res = res + d.toString() + "d";
      timespan -= 86400 * d;
      started = true;
    }
    if (resolution >= 86400)
      return res != "" ? res : "0d";
    if (timespan >= 3600) {
      let d = timespan / 3600 >> 0;
      let ds = d.toString();
      if (started && ds.length == 1)
        ds = "0" + ds;
      res = res + ds + "h";
      timespan -= 3600 * d;
      started = true;
    }
    if (resolution >= 3600)
      return res != "" ? res : "0h";
    if (timespan < resolution)
      return res != "" ? res : "0h";
    if (timespan >= 60) {
      let d = timespan / 60 >> 0;
      let ds = d.toString();
      if (started && ds.length == 1)
        ds = "0" + ds;
      res = res + ds + "m";
      timespan -= 60 * d;
      started = true;
    }
    if (resolution >= 60)
      return res != "" ? res : "0m";
    if (timespan < resolution)
      return res != "" ? res : "0m";
    timespan = Math.round(timespan * 100) / 100;
    let s;
    if (resolution > 0.1) {
      s = timespan.toFixed(0);
    } else if (resolution > 0.01) {
      s = timespan.toFixed(1);
    } else if (resolution > 1e-3) {
      s = timespan.toFixed(2);
    } else {
      s = timespan.toString();
    }
    if (started && timespan < 10)
      s = "0" + s;
    res = res + s + "s";
    return res;
  }
  static RelativeFormat(dataDeltaTime, viewportDeltaTime, resolution) {
    let ShowSecondsTenth = true;
    let ShowSecondsHundredth = true;
    let ShowSeconds = true;
    let ShowMinutes = false;
    let ShowHours = false;
    let ShowDays = false;
    if (dataDeltaTime <= 0.1) {
      ShowSecondsHundredth = true;
    }
    if (dataDeltaTime <= 1) {
      ShowSecondsTenth = true;
    }
    if (dataDeltaTime >= 60 || viewportDeltaTime >= 60) {
      ShowMinutes = true;
    }
    if (dataDeltaTime >= 3600 || viewportDeltaTime >= 3600) {
      ShowHours = true;
    }
    if (dataDeltaTime >= 86400 || viewportDeltaTime >= 86400) {
      ShowDays = true;
    }
    if (resolution >= 0.1)
      ShowSecondsHundredth = false;
    if (resolution >= 1)
      ShowSecondsTenth = false;
    if (resolution >= 60)
      ShowSeconds = false;
    if (resolution >= 3600)
      ShowMinutes = false;
    if (resolution >= 86400)
      ShowHours = false;
    let format = 0;
    format |= YDate.isRelative;
    if (ShowSecondsTenth)
      format |= YDate.ms1;
    if (ShowSecondsHundredth)
      format |= YDate.ms01;
    if (ShowSeconds)
      format |= YDate.s;
    if (ShowMinutes)
      format |= YDate.m;
    if (ShowHours)
      format |= YDate.h;
    if (ShowDays)
      format |= YDate.D;
    return format;
  }
  static BestTimeformat(dataDeltaTime, viewportDeltaTime, tref) {
    let res = new TimeResolution();
    let ShowSecondsTenth = true;
    let ShowSecondsHundredth = true;
    let ShowSeconds = true;
    let ShowMinutes = false;
    let ShowHours = false;
    let ShowDays = false;
    let ShowMonths = false;
    let ShowYears = false;
    if (viewportDeltaTime <= 0.1) {
      res.step = 0.01;
    } else if (viewportDeltaTime <= 1) {
      res.step = 0.1;
    } else if (viewportDeltaTime <= 2) {
      res.step = 0.2;
    } else if (viewportDeltaTime <= 5) {
      res.step = 0.5;
    } else if (viewportDeltaTime <= 10) {
      res.step = 1;
    } else if (viewportDeltaTime <= 20) {
      res.step = 2;
    } else if (viewportDeltaTime <= 30) {
      res.step = 3;
    } else if (viewportDeltaTime <= 40) {
      res.step = 4;
    } else if (viewportDeltaTime <= 60) {
      res.step = 5;
    } else if (viewportDeltaTime <= 120) {
      res.step = 10;
    } else if (viewportDeltaTime <= 300) {
      res.step = 30;
    } else if (viewportDeltaTime <= 900) {
      res.step = 60;
    } else if (viewportDeltaTime <= 1800) {
      res.step = 180;
    } else if (viewportDeltaTime <= 3600) {
      res.step = 300;
    } else if (viewportDeltaTime <= 7200) {
      res.step = 600;
    } else if (viewportDeltaTime <= 14e3) {
      res.step = 900;
    } else if (viewportDeltaTime <= 21600) {
      res.step = 1800;
    } else if (viewportDeltaTime <= 43200) {
      res.step = 3600;
    } else if (viewportDeltaTime <= 86400) {
      res.step = 7200;
    } else if (viewportDeltaTime <= 2 * 86400) {
      res.step = 2 * 7200;
    } else if (viewportDeltaTime <= 4 * 86400) {
      res.step = 4 * 7200;
    } else if (viewportDeltaTime <= 7 * 86400) {
      res.step = 86400;
    } else if (viewportDeltaTime <= 14 * 86400) {
      res.step = 2 * 86400;
    } else if (viewportDeltaTime <= 28 * 86400) {
      res.step = 4 * 86400;
    } else if (viewportDeltaTime <= 56 * 86400) {
      res.step = 7 * 86400;
    } else if (viewportDeltaTime <= 112 * 86400) {
      res.step = 14 * 86400;
    } else if (viewportDeltaTime <= 224 * 86400) {
      res.step = 31 * 86400;
    } else if (viewportDeltaTime <= 448 * 86400) {
      res.step = 62 * 86400;
    } else if (viewportDeltaTime <= 896 * 86400) {
      res.step = 93 * 86400;
    } else {
      res.step = 365 * 86400;
    }
    if (tref == TimeConverter.TimeReference.ABSOLUTE) {
      ShowSecondsHundredth = true;
      ShowSecondsTenth = true;
      ShowMinutes = true;
      ShowHours = true;
      ShowDays = dataDeltaTime > 86400;
      ShowMonths = dataDeltaTime > 86400;
      ShowYears = dataDeltaTime > 28 * 6 * 86400;
      if (res.step >= 0.1)
        ShowSecondsHundredth = false;
      if (res.step >= 1)
        ShowSecondsTenth = false;
      if (res.step >= 60)
        ShowSeconds = false;
      if (res.step >= 3600)
        ShowMinutes = false;
      if (res.step >= 86400)
        ShowHours = false;
      if (res.step >= 31 * 86400)
        ShowDays = false;
      if (res.step >= 365 * 86400)
        ShowMonths = false;
      res.format = 0;
      if (ShowSecondsHundredth)
        res.format |= YDate.ms01;
      if (ShowSecondsTenth)
        res.format |= YDate.ms1;
      if (ShowSeconds)
        res.format |= YDate.s;
      if (ShowMinutes)
        res.format = res.format |= YDate.m;
      if (ShowHours)
        res.format = res.format |= YDate.h;
      if (res.format != 0 && (ShowDays || ShowMonths))
        res.format |= YDate.CR;
      if (ShowDays)
        res.format |= YDate.D;
      if (ShowMonths)
        res.format |= YDate.M;
      if (ShowYears)
        res.format |= YDate.YY;
      if (res.format == YDate.YY)
        res.format = YDate.YYYY;
    } else {
      res.format = TimeConverter.RelativeFormat(dataDeltaTime, viewportDeltaTime, res.step);
    }
    return res;
  }
};
(function(TimeConverter2) {
  class TimeReferenceEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, TimeReference);
    }
  }
  TimeConverter2.TimeReferenceEnumItem = TimeReferenceEnumItem;
  class TimeReference extends YEnum {
  }
  TimeReference.ABSOLUTE = new TimeReferenceEnumItem("ABSOLUTE", "Absolute");
  TimeReference.RELATIVE = new TimeReferenceEnumItem("RELATIVE", "Relative to first data");
  TimeConverter2.TimeReference = TimeReference;
})(TimeConverter || (TimeConverter = {}));
var MinMax = class {
  constructor(minimum, maximum) {
    this.Min = 0;
    this.Max = 0;
    this.Min = minimum;
    this.Max = maximum;
  }
};
var MinMaxHandler = class {
  static extend(M, factor) {
    if (isNaN(M.Min))
      return M;
    let delta = M.Max - M.Min;
    return new MinMax(M.Min - delta * (factor - 1) / 2, M.Max + delta * (factor - 1) / 2);
  }
  static DefaultValue(value1, value2) {
    if (typeof value2 === "undefined") {
      if (typeof value1 === "undefined")
        return new MinMax(Number.NaN, Number.NaN);
      return new MinMax(value1, value1);
    }
    if (typeof value1 === "undefined")
      return new MinMax(value2, value2);
    if (value2 < value1)
      throw new RangeError("MinMax invalid parameters (" + value1.toString() + ">" + value2.toString());
    return new MinMax(value1, value2);
  }
  static isDefined(v) {
    return !isNaN(v.Min);
  }
  static Combine(M1, M2) {
    if (isNaN(M1.Min))
      return new MinMax(M2.Min, M2.Max);
    if (isNaN(M2.Min))
      return new MinMax(M1.Min, M1.Max);
    let res = new MinMax(M2.Min, M2.Max);
    if (M1.Min < res.Min)
      res.Min = M1.Min;
    if (M1.Max < res.Min)
      res.Min = M1.Max;
    if (M1.Min > res.Max)
      res.Max = M1.Min;
    if (M1.Max > res.Max)
      res.Max = M1.Max;
    return res;
  }
  static CombineWithNumber(M1, value) {
    if (isNaN(M1.Min))
      return new MinMax(value, value);
    if (value < M1.Min)
      return new MinMax(value, M1.Max);
    if (value > M1.Max)
      return new MinMax(M1.Min, value);
    return new MinMax(M1.Min, M1.Max);
  }
};
var DataSegment = class {
  constructor(p) {
    this.data = [];
    this.count = 0;
    if (p instanceof Array) {
      this.data = new Array(p.length);
      DataSegment.ArrayCopy(p, 0, this.data, 0, p.length);
      this.count = p.length;
    } else if (p instanceof pointXY) {
      this.data = new Array(DataSegment.SegmentGranularity);
      this.data[0] = p;
      this.count = 1;
    } else {
      throw new Error("invalid constructor paramter type");
    }
  }
  static ArrayCopy(sourceArray, sourceIndex, destinationArray, destinationIndex, length) {
    for (let i = 0; i < length; i++) {
      destinationArray[destinationIndex + i] = sourceArray[sourceIndex + i].clone();
    }
  }
  grow() {
    let targetCount = this.data.length + DataSegment.SegmentGranularity;
    while (this.data.length < targetCount) {
      this.data.push(null);
    }
  }
};
DataSegment.SegmentGranularity = 1e3;
var Summary = class {
  constructor(index, array, pointSize) {
    this.segments = [];
    this.totalpoints = 0;
    this.Xmin = 0;
    this.Xmax = 0;
    this.Ymin = 0;
    this.Ymax = 0;
    this.vtlPtCount = 0;
    this.pointSize = 0;
    this.isLast = false;
    this.newSummaryLevelTrigger = 0;
    this.selfIndex = index;
    this.selfArray = array;
    this.pointSize = pointSize;
    this.isLast = true;
  }
  getBufferpoint() {
    if (this.vtlPtCount <= 0)
      return null;
    return new pointsSummary(this.Xmin, this.Xmax, this.Ymin, this.Ymax);
  }
  Dump() {
    var _a, _b, _c, _d;
    console.log("Summary level" + this.selfIndex + ", " + this.segments.length + " segments, " + this.totalpoints + " points");
    let lastx = 0;
    for (let s = 0; s < this.segments.length; s++) {
      console.log("  segment " + s);
      for (let i = 0; i < this.segments[s].ptCount; i++) {
        console.log(((_a = this.segments[s].data[i]) === null || _a === void 0 ? void 0 : _a.x1) + "," + ((_b = this.segments[s].data[i]) === null || _b === void 0 ? void 0 : _b.ymin) + " delataX=" + Math.round(this.segments[s].data[i].x1 - lastx));
        console.log(((_c = this.segments[s].data[i]) === null || _c === void 0 ? void 0 : _c.x2) + "," + ((_d = this.segments[s].data[i]) === null || _d === void 0 ? void 0 : _d.ymax) + " delataX=" + Math.round(this.segments[s].data[i].x2 - this.segments[s].data[i].x1));
        lastx = this.segments[s].data[i].x2;
      }
    }
  }
  processSegments(segments) {
    if (segments.length <= 0)
      return;
    let last = segments.length - 1;
    this.Xmin = segments[last].data[0].x;
    this.Xmax = segments[last].data[0].x;
    this.Ymin = segments[last].data[0].y;
    this.Ymax = segments[last].data[0].y;
    this.totalpoints = 0;
    this.vtlPtCount = 0;
    for (let s = last; s >= 0; s--) {
      for (let i = 0; i < segments[s].data.length; i++) {
        let p = segments[s].data[i];
        if (p.x < this.Ymin)
          this.Ymin = p.y;
        if (p.x > this.Ymax)
          this.Ymax = p.y;
        this.Xmax = p.x;
        this.vtlPtCount++;
        if (this.vtlPtCount >= this.pointSize) {
          this.flush(false);
          this.Xmin = p.x;
          this.Ymin = p.y;
          this.Ymax = p.y;
        }
      }
      if (s > 0) {
        let len = segments[s].data.length;
        let p2 = segments[s - 1].data[0];
        let p1 = segments[s].data[len - 1];
        let lastDelta = 1;
        if (len > 1) {
          let p0 = segments[s].data[len - 2];
          lastDelta = p1.x - p0.x;
        }
        if (p2.x - p1.x > this.pointSize * lastDelta) {
          this.flush(false);
          this.Xmin = p2.x;
          this.Ymin = p2.y;
          this.Ymax = p2.y;
          this.addNewEmptySegment();
        }
      }
    }
    if (this.totalpoints > 1) {
      let it = new Summary(this.selfIndex + 1, this.selfArray, this.pointSize * SUMMARY_GRANULARITY);
      this.selfArray.push(it);
      this.isLast = false;
      it.processSegments(segments);
    }
  }
  addNewLevel() {
    let newIndex = this.selfArray.length;
    if (Summary.DBG)
      console.log("--- ADDING NEW LEVEL " + newIndex);
    let it = new Summary(newIndex, this.selfArray, this.pointSize * SUMMARY_GRANULARITY);
    this.selfArray.push(it);
    this.isLast = false;
    let _xmin = this.segments[0].data[0].x1;
    let _xmax = this.segments[0].data[0].x2;
    let _ymin = this.segments[0].data[0].ymin;
    let _ymax = this.segments[0].data[0].ymax;
    let _count = 0;
    for (let s = 0; s < this.segments.length; s++) {
      for (let i = 0; i < this.segments[s].ptCount; i++) {
        _xmax = this.segments[s].data[i].x2;
        if (this.segments[s].data[i].ymin < _ymin)
          _ymin = this.segments[s].data[i].ymin;
        if (this.segments[s].data[i].ymin > _ymax)
          _ymax = this.segments[s].data[i].ymin;
      }
      _count += this.segments[s].ptCount;
      if (s < this.segments.length - 1) {
        if (this.segments[s].ptCount > 2) {
          let lastIndex = this.segments[s].ptCount - 1;
          let lastDelta = this.segments[s].data[lastIndex].x1 - this.segments[s].data[lastIndex - 1].x2;
          if (this.segments[s + 1].data[0].x1 - this.segments[s].data[this.segments[s].ptCount - 1].x2 > lastDelta * SUMMARY_GRANULARITY) {
            it.addNewEmptySegment();
            _xmin = this.segments[s + 1].data[0].x1;
            _xmax = this.segments[s + 1].data[0].x2;
            _ymin = this.segments[s + 1].data[0].ymin;
            _ymax = this.segments[s + 1].data[0].ymax;
            _count = 0;
          }
        }
      }
    }
    if (_count != 0) {
      it.addNewSinglePointSegment(_xmin, _xmax, _ymin, _ymax, _count);
    }
  }
  addNewSinglePointSegment(xmin, xmax, ymin, ymax, _count) {
    if (Summary.DBG)
      console.log(" ===> level " + this.selfIndex + " new single point segment");
    this.segments.push(new DataSummarySegment(new pointsSummary(xmin, xmax, ymin, ymax), _count));
  }
  addNewEmptySegment() {
    if (Summary.DBG)
      console.log(" ===> level " + this.selfIndex + " new empty segment");
    this.segments.push(new DataSummarySegment(null, null));
  }
  addSequentialPoint(p, maxHoleSize) {
    if (Summary.DBG)
      console.log(" ADD Point, LEVEL " + this.selfIndex + " Vtl point = " + this.vtlPtCount + "/" + this.pointSize + " TOTAL Points= " + this.totalpoints);
    if (this.isLast && this.totalpoints >= SUMMARY_GRANULARITY)
      this.addNewLevel();
    if (this.vtlPtCount == 0) {
      this.Xmin = p.x;
      this.Xmax = p.x;
      this.Ymin = p.y;
      this.Ymax = p.y;
      this.vtlPtCount = 1;
      if (Summary.DBG) {
        if (this.selfIndex == 1)
          console.log(" --> added 1srt virtual pt vtlPtCount=" + this.vtlPtCount + "/" + this.pointSize);
      }
      if (!this.isLast)
        this.selfArray[this.selfIndex + 1].addSequentialPoint(p, maxHoleSize * SUMMARY_GRANULARITY);
      return;
    } else {
      if (Summary.DBG)
        console.log(" --> level " + this.selfIndex + " delta = " + (p.x - this.Xmax) + "/" + maxHoleSize);
      if (maxHoleSize > 0 && p.x - this.Xmax > maxHoleSize) {
        if (Summary.DBG)
          console.log(" --> level " + this.selfIndex + " hole detected");
        this.flush(false);
        this.addNewEmptySegment();
        this.Xmin = p.x;
        this.Xmax = p.x;
        this.Ymin = p.y;
        this.Ymax = p.y;
        this.vtlPtCount = 1;
        if (!this.isLast)
          this.selfArray[this.selfIndex + 1].addSequentialPoint(p, maxHoleSize * SUMMARY_GRANULARITY);
        return;
      }
      if (p.y < this.Ymin)
        this.Ymin = p.y;
      if (p.y > this.Ymax)
        this.Ymax = p.y;
      this.Xmax = p.x;
      this.vtlPtCount++;
      if (Summary.DBG) {
        if (this.selfIndex == 1)
          console.log(" --> level " + this.selfIndex + " added subsequent virtual pt vtlPtCount=" + this.vtlPtCount + "/" + this.pointSize);
      }
      if (this.vtlPtCount >= this.pointSize) {
        if (Summary.DBG) {
          if (this.selfIndex == 1)
            console.log(" --> level " + this.selfIndex + " flushing");
        }
        this.flush(false);
      }
    }
    if (!this.isLast)
      this.selfArray[this.selfIndex + 1].addSequentialPoint(p, maxHoleSize * SUMMARY_GRANULARITY);
  }
  flush(forceNewSegment) {
    if (this.segments.length == 0 || forceNewSegment)
      this.segments.push(new DataSummarySegment(null, null));
    let lastsegment = this.segments[this.segments.length - 1];
    lastsegment.data[lastsegment.ptCount] = new pointsSummary(this.Xmin, this.Xmax, this.Ymin, this.Ymax);
    this.totalpoints++;
    lastsegment.ptCount++;
    this.vtlPtCount = 0;
  }
};
Summary.DBG = false;
var DataSummarySegment = class {
  constructor(p, virtualPointCount) {
    this.data = [];
    this.ptCount = 0;
    if (p instanceof Array) {
      this.data = new Array(p.length);
      DataSummarySegment.ArrayCopy(p, 0, this.data, 0, p.length);
      this.ptCount = p.length;
    } else if (p instanceof pointsSummary) {
      this.data = new Array(DataSummarySegment.SegmentGranularity);
      this.data[0] = p;
      this.ptCount = 1;
    } else if (p == null) {
      this.data = new Array(DataSummarySegment.SegmentGranularity);
      this.ptCount = 0;
    }
  }
  static ArrayCopy(sourceArray, sourceIndex, destinationArray, destinationIndex, length) {
    for (let i = 0; i < length; i++) {
      destinationArray[destinationIndex + i] = sourceArray[sourceIndex + i].clone();
    }
  }
  grow() {
    let targetCount = this.data.length + DataSummarySegment.SegmentGranularity;
    while (this.data.length < targetCount) {
      this.data.push(null);
    }
  }
};
DataSummarySegment.SegmentGranularity = 1e3;
var DataSerie = class {
  constructor(parent) {
    this.totalPointCount = 0;
    this._userData = null;
    this._yAxisIndex = 0;
    this._pen = null;
    this._legendPen = null;
    this._brush = null;
    this._navigatorpen = null;
    this._visible = true;
    this._disabled = false;
    this._color = YColor.Black;
    this._thickness = 1;
    this._legend = "";
    this._unit = "";
    this.segments = [];
    this.summaries = null;
    if (parent.yAxes.length <= 0)
      throw new Error("Define at least one yAxis");
    this._timeRange = MinMaxHandler.DefaultValue();
    this._valueRange = MinMaxHandler.DefaultValue();
    this.parent = parent;
  }
  get userData() {
    return this._userData;
  }
  set userData(value) {
    this._userData = value;
  }
  static get MaxPointsPerSeries() {
    return DataSerie._MaxPointsPerSeries;
  }
  static set MaxPointsPerSeries(value) {
    DataSerie._MaxPointsPerSeries = value;
  }
  get timeRange() {
    return this._timeRange;
  }
  get valueRange() {
    return this._valueRange;
  }
  get yAxisIndex() {
    return this._yAxisIndex;
  }
  set yAxisIndex(value) {
    if (value >= this.parent.yAxes.length)
      throw new RangeError("No such yAxis (" + value.toString() + ")");
    this._yAxisIndex = value;
    this.parent.yAxes[this._yAxisIndex].AutoShow();
  }
  get pen() {
    if (this._pen == null) {
      this._pen = new YPen(this._color, this._thickness);
      this._pen.endCap = 2;
      this._pen.linejoin = YPen.LineJoin.Round;
    }
    return this._pen;
  }
  get legendPen() {
    if (this._legendPen == null) {
      this._legendPen = new YPen(this._color, this._thickness * this.parent.legendPanel.traceWidthFactor);
    }
    return this._legendPen;
  }
  resetlegendPen() {
    this._legendPen = null;
  }
  get brush() {
    if (this._brush == null)
      this._brush = new YSolidBrush(this._color);
    return this._brush;
  }
  get navigatorpen() {
    if (this._navigatorpen == null) {
      this._navigatorpen = new YPen(YColor.FromArgb(100, this._color.red, this._color.green, this._color.blue), 1);
    }
    return this._navigatorpen;
  }
  get visible() {
    return this._visible;
  }
  set visible(value) {
    this._visible = value;
    this.parent.redraw();
  }
  get disabled() {
    return this._disabled;
  }
  set disabled(value) {
    this._disabled = value;
    this.parent.redraw();
  }
  get color() {
    return this._color;
  }
  set color(value) {
    this._color = value;
    this._pen = null;
    this._legendPen = null;
    this._brush = null;
    this._navigatorpen = null;
    this.parent.redraw();
  }
  get thickness() {
    return this._thickness;
  }
  set thickness(value) {
    if (value < 0)
      throw new RangeError("Thickness must be a positive value");
    this._thickness = value;
    this._pen = null;
    this._legendPen = null;
    this.parent.redraw();
  }
  get legend() {
    return this._legend;
  }
  set legend(value) {
    this._legend = value;
    this.parent.redraw();
  }
  get unit() {
    return this._unit;
  }
  set unit(value) {
    this._unit = value;
    this.parent.redraw();
  }
  AddNewSegment(p) {
    this.segments.splice(0, 0, new DataSegment(p));
  }
  getlastPoint() {
    if (this.segments.length <= 0) {
      return new pointXY(NaN, NaN);
    }
    return this.segments[this.segments.length - 1].data[this.segments[this.segments.length - 1].count - 1];
  }
  handleSummary(p, delta) {
    if (this.summaries == null) {
      this.summaries = [];
      this.summaries.push(new Summary(0, this.summaries, SUMMARY_GRANULARITY));
    }
    if (this.summaries != null)
      this.summaries[0].addSequentialPoint(p, delta);
  }
  AddPoint(p) {
    this._timeRange = MinMaxHandler.CombineWithNumber(this._timeRange, p.x);
    this._valueRange = MinMaxHandler.CombineWithNumber(this._valueRange, p.y);
    let delta1 = -1;
    let delta2 = -1;
    if (this.segments.length <= 0) {
      this.AddNewSegment(p);
      this.totalPointCount++;
      if (SUMMARY_GRANULARITY > 0)
        this.handleSummary(p, delta1);
      return;
    } else if (this.segments[0].count > 1) {
      delta1 = this.segments[0].data[this.segments[0].count - 1].x - this.segments[0].data[this.segments[0].count - 2].x;
      delta2 = p.x - this.segments[0].data[this.segments[0].count - 1].x;
      if (delta2 > 0.1 && (delta2 < 0 || delta2 > 2 * delta1)) {
        this.AddNewSegment(p);
        if (SUMMARY_GRANULARITY > 0)
          this.handleSummary(p, delta1);
        return;
      }
    }
    if (SUMMARY_GRANULARITY > 0)
      this.handleSummary(p, delta1);
    this.segments[0].data[this.segments[0].count] = p;
    this.segments[0].count++;
    this.totalPointCount++;
    if (DataSerie._MaxPointsPerSeries > 0 && this.totalPointCount > DataSerie._MaxPointsPerSeries) {
      this.dataCleanUp();
      this.rebuildSummaries();
    }
    this.parent.adjustGlobalTimeRange(p.x);
    this.parent.redraw();
  }
  rebuildSummaries() {
    if (SUMMARY_GRANULARITY <= 0)
      return;
    this.summaries = [];
    this.summaries.push(new Summary(0, this.summaries, SUMMARY_GRANULARITY));
    this.summaries[0].processSegments(this.segments);
  }
  dumpSummaries() {
    if (this.summaries != null)
      for (let i = 0; i < this.summaries.length; i++)
        this.summaries[i].Dump();
    else
      console.log("****No summaries ****");
  }
  dataCleanUp() {
    if (this.segments.length <= 0)
      return;
    let newLimit = DataSerie._MaxPointsPerSeries * 90 / 100;
    while (this.segments[this.segments.length - 1].count <= this.totalPointCount - newLimit) {
      this.totalPointCount -= this.segments[this.segments.length - 1].count;
      this.segments.splice(this.segments.length - 1, 1);
    }
    if (this.totalPointCount > newLimit) {
      let delta = this.totalPointCount - newLimit;
      let newsize = this.segments[this.segments.length - 1].count - delta;
      let newdata = new Array(newsize);
      DataSegment.ArrayCopy(this.segments[this.segments.length - 1].data, delta, newdata, 0, this.segments[this.segments.length - 1].count - delta);
      this.segments[this.segments.length - 1].data = newdata;
      this.segments[this.segments.length - 1].count -= delta;
      this.totalPointCount -= delta;
    }
    let tmin = this.segments[0].data[0].x;
    let tmax = this.segments[0].data[0].x;
    let ymin = this.segments[0].data[0].y;
    let ymax = this.segments[0].data[0].y;
    for (let i = 0; i < this.segments.length; i++) {
      let count = this.segments[i].count;
      if (tmin > this.segments[i].data[0].x)
        tmin = this.segments[i].data[0].x;
      if (tmax < this.segments[i].data[count - 1].x)
        tmax = this.segments[i].data[count - 1].x;
      for (let j = 0; j < count; j++) {
        if (ymin > this.segments[i].data[j].y)
          ymin = this.segments[i].data[j].y;
        if (ymax < this.segments[i].data[j].y)
          ymax = this.segments[i].data[j].y;
      }
    }
    this._timeRange.Min = tmin;
    this._timeRange.Max = tmax;
    this._valueRange.Min = ymin;
    this._valueRange.Max = ymax;
  }
  InsertPoints(points) {
    if (points.length == 0)
      return;
    if (points.length == 1) {
      this._timeRange = MinMaxHandler.CombineWithNumber(this._timeRange, points[0].x);
      this._valueRange = MinMaxHandler.CombineWithNumber(this._valueRange, points[0].y);
      return;
    }
    let FirstStep = points[1].x - points[0].x;
    let LastStep = points[points.length - 1].x - points[points.length - 2].x;
    let InsertAtBegining = -1;
    let InsertAtEnd = -1;
    for (let i = 0; i < this.segments.length; i++) {
      if (this.segments[i].count > 1) {
        let DeltaInsertAtBegining = this.segments[i].data[0].x - points[points.length - 1].x;
        let DeltaInsertAtEnd = points[0].x - this.segments[i].data[this.segments[i].count - 1].x;
        if (DeltaInsertAtBegining > 0 && DeltaInsertAtBegining < 2 * FirstStep)
          InsertAtBegining = i;
        if (DeltaInsertAtEnd > 0 && DeltaInsertAtEnd < 2 * LastStep)
          InsertAtEnd = i;
      }
    }
    if (InsertAtBegining >= 0) {
      DataSegment.ArrayCopy(this.segments[InsertAtBegining].data, 0, this.segments[InsertAtBegining].data, points.length, this.segments[InsertAtBegining].count);
      DataSegment.ArrayCopy(points, 0, this.segments[InsertAtBegining].data, 0, points.length);
      this.segments[InsertAtBegining].count += points.length;
      this.totalPointCount += points.length;
    } else if (InsertAtEnd >= 0) {
      DataSegment.ArrayCopy(points, 0, this.segments[InsertAtEnd].data, this.segments[InsertAtEnd].count, points.length);
      this.segments[InsertAtEnd].count += points.length;
      this.totalPointCount += points.length;
    } else {
      let inserted = false;
      for (let i = 0; i < this.segments.length; i++) {
        if (this.segments[i].data[this.segments[i].data.length - 1].x < points[0].x && !inserted) {
          this.segments.splice(i, 0, new DataSegment(points));
          inserted = true;
        }
      }
      if (!inserted)
        this.segments.push(new DataSegment(points));
      this.totalPointCount += points.length;
    }
    this._timeRange = MinMaxHandler.CombineWithNumber(this._timeRange, points[0].x);
    this._timeRange = MinMaxHandler.CombineWithNumber(this._timeRange, points[points.length - 1].x);
    for (let i = 0; i < points.length; i++) {
      this._valueRange = MinMaxHandler.CombineWithNumber(this._valueRange, points[i].y);
    }
    if (DataSerie._MaxPointsPerSeries > 0 && this.totalPointCount > DataSerie._MaxPointsPerSeries)
      this.dataCleanUp();
    this.parent.redraw();
  }
  static CompareSegments(a, b) {
    if (a.data[0].x > b.data[0].x)
      return -1;
    if (a.data[0].x < b.data[0].x)
      return 1;
    return 0;
  }
  getData() {
    let res = [];
    this.segments.sort(DataSerie.CompareSegments);
    for (let i = this.segments.length - 1; i >= 0; i--) {
      for (let j = 0; j < this.segments[i].count; j++) {
        res.push(this.segments[i].data[j]);
      }
    }
    return res;
  }
  findClosestValue(x, AllowInterpolation) {
    let N1 = 0;
    let N2 = 0;
    let Pos = 0;
    if (this.segments.length <= 0)
      return null;
    for (let i = 0; i < this.segments.length; i++) {
      if (x >= this.segments[i].data[0].x && x <= this.segments[i].data[this.segments[i].count - 1].x) {
        let data = this.segments[i].data;
        N1 = 0;
        N2 = this.segments[i].count - 1;
        while (N2 - N1 > 1) {
          let N = N1 + N2 >> 1;
          if (data[N].x > x)
            N2 = N;
          else
            N1 = N;
        }
        Pos = N1 - 1;
        if (Pos < 0)
          Pos = 0;
        if (!AllowInterpolation) {
          if (x - data[Pos].x < data[Pos + 1].x - x)
            return data[Pos];
          else
            return data[Pos + 1];
        } else {
          Pos++;
          if (x == data[Pos].x)
            return data[Pos];
          if (x == data[Pos + 1].x)
            return data[Pos + 1];
          let p = new pointXY();
          p.x = x;
          p.y = data[Pos].y + (data[Pos + 1].y - data[Pos].y) * (x - data[Pos].x) / (data[Pos + 1].x - data[Pos].x);
          return p;
        }
      }
    }
    if (AllowInterpolation)
      return null;
    try {
      this.segments[0].data[0].clone();
    } catch (e) {
      debugger;
    }
    let match = this.segments[0].data[0];
    let delta = Math.abs(this.segments[0].data[0].x - x);
    for (let i = 0; i < this.segments.length; i++) {
      let d1 = Math.abs(this.segments[i].data[0].x - x);
      let d2 = Math.abs(this.segments[i].data[this.segments[i].count - 1].x - x);
      if (d1 < delta) {
        match = this.segments[i].data[0];
        delta = d1;
      }
      if (d2 < delta) {
        match = this.segments[i].data[this.segments[i].count - 1];
        delta = d2;
      }
    }
    return match.clone();
  }
  clear() {
    this.segments = [];
    this._timeRange = MinMaxHandler.DefaultValue();
    this._valueRange = MinMaxHandler.DefaultValue();
    this.parent.clearCachedObjects();
    this.totalPointCount = 0;
  }
};
DataSerie._MaxPointsPerSeries = 0;
var DataTracker = class {
  constructor(parent, directParent) {
    this._userData = null;
    this._enabled = false;
    this._showSerieName = false;
    this._showTimeStamp = false;
    this._dataPrecisionString = "";
    this._dataPrecision = DataTracker.DataPrecision.PRECISION_NOLIMIT;
    this._diameter = 5;
    this._handleLength = 25;
    this._detectionDistance = 50;
    this._bgColor = YColor.FromArgb(200, 255, 255, 255);
    this._borderColor = YColor.Black;
    this._borderthickness = 1;
    this._padding = 10;
    this._verticalMargin = 10;
    this._horizontalMargin = 10;
    this._bgBrush = null;
    this._pen = null;
    this._font = null;
    this._directParent = directParent;
    this._parentRenderer = parent;
    this._font = new YFont(parent, this, 8, null);
  }
  get directParent() {
    return this._directParent;
  }
  get userData() {
    return this._userData;
  }
  set userData(value) {
    this._userData = value;
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    this._enabled = value;
    this._parentRenderer.redraw();
  }
  get showSerieName() {
    return this._showSerieName;
  }
  set showSerieName(value) {
    this._showSerieName = value;
    this._parentRenderer.redraw();
  }
  get showTimeStamp() {
    return this._showTimeStamp;
  }
  set showTimeStamp(value) {
    this._showTimeStamp = value;
    this._parentRenderer.redraw();
  }
  get dataPrecisionString() {
    return this._dataPrecisionString;
  }
  get dataPrecision() {
    return this._dataPrecision;
  }
  set dataPrecision(value) {
    this._dataPrecision = value;
    this.compute_dataPrecisionString();
    this._parentRenderer.redraw();
  }
  compute_dataPrecisionString() {
    if (this._dataPrecision == DataTracker.DataPrecision.PRECISION_NOLIMIT) {
      this._dataPrecisionString = "";
      return;
    }
    this._dataPrecisionString = "0.";
  }
  get diameter() {
    return this._diameter;
  }
  set diameter(value) {
    if (value < 0)
      throw new RangeError("Diameter must be a positive value");
    this._diameter = value;
    this._parentRenderer.redraw();
  }
  get handleLength() {
    return this._handleLength;
  }
  set handleLength(value) {
    if (value < 0)
      throw new RangeError("Hanle length must be a positive value");
    this._handleLength = value;
    this._parentRenderer.redraw();
  }
  get detectionDistance() {
    return this._detectionDistance;
  }
  set detectionDistance(value) {
    if (value <= 0)
      throw new RangeError("Distance must be a positive value");
    this._detectionDistance = value;
  }
  get bgColor() {
    return this._bgColor;
  }
  set bgColor(value) {
    this._bgColor = value;
    this._bgBrush = null;
    this._parentRenderer.redraw();
  }
  get borderColor() {
    return this._borderColor;
  }
  set borderColor(value) {
    this._borderColor = value;
    this._pen = null;
    this._parentRenderer.redraw();
  }
  get borderthickness() {
    return this._borderthickness;
  }
  set borderthickness(value) {
    if (value < 0)
      throw new RangeError("Thickness must be a positive value");
    this._borderthickness = value;
    this._pen = null;
    this._parentRenderer.redraw();
  }
  get padding() {
    return this._padding;
  }
  set padding(value) {
    if (value < 0)
      throw new RangeError("Padding must be a positive value");
    this._padding = value;
    this._parentRenderer.redraw();
  }
  get verticalMargin() {
    return this._verticalMargin;
  }
  set verticalMargin(value) {
    if (value < 0)
      throw new RangeError("Margin must be a positive value");
    this._verticalMargin = value;
    this._parentRenderer.redraw();
  }
  get horizontalMargin() {
    return this._horizontalMargin;
  }
  set horizontalMargin(value) {
    if (value < 0)
      throw new RangeError("Margin must be a positive value");
    this._horizontalMargin = value;
    this._parentRenderer.redraw();
  }
  get bgBrush() {
    if (this._bgBrush == null) {
      this._bgBrush = new YSolidBrush(this._bgColor);
    }
    return this._bgBrush;
  }
  get pen() {
    if (this._pen == null)
      this._pen = new YPen(this._borderColor, this._borderthickness, true);
    return this._pen;
  }
  get font() {
    return this._font;
  }
};
(function(DataTracker2) {
  class DataPrecisionEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, DataPrecision);
    }
  }
  DataTracker2.DataPrecisionEnumItem = DataPrecisionEnumItem;
  class DataPrecision extends YEnum {
  }
  DataPrecision.PRECISION_NOLIMIT = new DataPrecisionEnumItem("PRECISION_NOLIMIT", "As is");
  DataPrecision.PRECISION_1 = new DataPrecisionEnumItem("PRECISION_1", "1");
  DataPrecision.PRECISION_01 = new DataPrecisionEnumItem("PRECISION_01", "0.1");
  DataPrecision.PRECISION_001 = new DataPrecisionEnumItem("PRECISION_001", "0.01");
  DataPrecision.PRECISION_0001 = new DataPrecisionEnumItem("PRECISION_0001", "0.001");
  DataPrecision.PRECISION_00001 = new DataPrecisionEnumItem("PRECISION_00001", "0.0001");
  DataPrecision.PRECISION_000001 = new DataPrecisionEnumItem("PRECISION_000001", "0.00001");
  DataPrecision.PRECISION_0000001 = new DataPrecisionEnumItem("PRECISION_0000001", "0.000001");
  DataPrecision.PRECISION_00000001 = new DataPrecisionEnumItem("PRECISION_00000001", "0.0000001");
  DataPrecision.PRECISION_000000001 = new DataPrecisionEnumItem("PRECISION_000000001", "0.00000001");
  DataPrecision.PRECISION_0000000001 = new DataPrecisionEnumItem("PRECISION_0000000001", "0.000000001");
  DataTracker2.DataPrecision = DataPrecision;
})(DataTracker || (DataTracker = {}));
var LegendPanel = class {
  constructor(parent, directParent) {
    this._userData = null;
    this._traceWidth = 1;
    this._enabled = false;
    this._position = LegendPanel.Position.BOTTOM;
    this._overlap = false;
    this._bgColor = YColor.FromArgb(200, 255, 255, 255);
    this._borderColor = YColor.Black;
    this._borderthickness = 1;
    this._padding = 10;
    this._verticalMargin = 10;
    this._horizontalMargin = 10;
    this._bgBrush = null;
    this._pen = null;
    this._font = null;
    this._directParent = directParent;
    this._parentRenderer = parent;
    this._font = new YFont(parent, this, 8, null);
  }
  get directParent() {
    return this._directParent;
  }
  get userData() {
    return this._userData;
  }
  set userData(value) {
    this._userData = value;
  }
  get traceWidthFactor() {
    return this._traceWidth;
  }
  set traceWidthFactor(value) {
    if (value <= 0)
      throw new RangeError("This has to be a strictly positive value");
    this._traceWidth = value;
    this._parentRenderer.resetlegendPens();
    this._parentRenderer.redraw();
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    this._enabled = value;
    this._parentRenderer.redraw();
  }
  get position() {
    return this._position;
  }
  set position(value) {
    this._position = value;
    this._parentRenderer.redraw();
  }
  get overlap() {
    return this._overlap;
  }
  set overlap(value) {
    this._overlap = value;
    this._parentRenderer.redraw();
  }
  get bgColor() {
    return this._bgColor;
  }
  set bgColor(value) {
    this._bgColor = value;
    this._bgBrush = null;
    this._parentRenderer.redraw();
  }
  get borderColor() {
    return this._borderColor;
  }
  set borderColor(value) {
    this._borderColor = value;
    this._pen = null;
    this._parentRenderer.redraw();
  }
  get borderthickness() {
    return this._borderthickness;
  }
  set borderthickness(value) {
    if (value < 0)
      throw new RangeError("Thickness must be a positive value");
    this._borderthickness = value;
    this._pen = null;
    this._parentRenderer.redraw();
  }
  get padding() {
    return this._padding;
  }
  set padding(value) {
    if (value < 0)
      throw new RangeError("Padding must be a positive value");
    this._padding = value;
    this._parentRenderer.redraw();
  }
  get verticalMargin() {
    return this._verticalMargin;
  }
  set verticalMargin(value) {
    if (value < 0)
      throw new RangeError("Margin must be a positive value");
    this._verticalMargin = value;
    this._parentRenderer.redraw();
  }
  get horizontalMargin() {
    return this._horizontalMargin;
  }
  set horizontalMargin(value) {
    if (value < 0)
      throw new RangeError("Margin must be a positive value");
    this._horizontalMargin = value;
    this._parentRenderer.redraw();
  }
  get bgBrush() {
    if (this._bgBrush == null) {
      this._bgBrush = new YSolidBrush(this._bgColor);
    }
    return this._bgBrush;
  }
  get pen() {
    if (this._pen == null)
      this._pen = new YPen(this._borderColor, this._borderthickness, true);
    return this._pen;
  }
  get font() {
    return this._font;
  }
};
(function(LegendPanel2) {
  class PositionEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, Position);
    }
  }
  LegendPanel2.PositionEnumItem = PositionEnumItem;
  class Position extends YEnum {
  }
  Position.LEFT = new PositionEnumItem("LEFT", "Left");
  Position.TOPLEFT = new PositionEnumItem("TOPLEFT", "Top-Left");
  Position.TOP = new PositionEnumItem("TOP", "Top");
  Position.TOPRIGHT = new PositionEnumItem("TOPRIGHT", "Top-Right");
  Position.RIGHT = new PositionEnumItem("RIGHT", "Right");
  Position.BOTTOMRIGHT = new PositionEnumItem("BOTTOMRIGHT", "Bottom-Right");
  Position.BOTTOM = new PositionEnumItem("BOTTOM", "Bottom");
  Position.BOTTOMLEFT = new PositionEnumItem("BOTTOMLEFT", "Bottom-Left");
  LegendPanel2.Position = Position;
})(LegendPanel || (LegendPanel = {}));
var Navigator = class {
  constructor(parent, directParent) {
    this._userData = null;
    this._viewport = new ViewPortSettings();
    this.Xrange = null;
    this._showXAxisZones = true;
    this._relativeheight = 10;
    this._enabled = false;
    this._bgColor1 = YColor.FromArgb(255, 225, 225, 225);
    this._cursorBorderColor = YColor.FromArgb(255, 40, 40, 40);
    this._yAxisHandling = Navigator.YAxisHandling.AUTO;
    this._bgColor2 = YColor.FromArgb(255, 225, 225, 225);
    this._cursorColor = YColor.FromArgb(100, 0, 255, 0);
    this._cursorBrush = null;
    this._pen = null;
    this._cursorBorderPen = null;
    this._xAxisColor = YColor.Black;
    this._xAxisThickness = 1;
    this._borderPen = null;
    this._borderColor = YColor.DimGray;
    this._borderThickness = 1;
    this._bgBrush = null;
    this._font = null;
    this._directParent = directParent;
    this._parentRenderer = parent;
    this._font = new YFont(parent, this, 8, null);
  }
  get directParent() {
    return this._directParent;
  }
  get userData() {
    return this._userData;
  }
  set userData(value) {
    this._userData = value;
  }
  get showXAxisZones() {
    return this._showXAxisZones;
  }
  set showXAxisZones(value) {
    this._showXAxisZones = value;
  }
  get relativeheight() {
    return this._relativeheight;
  }
  set relativeheight(value) {
    if (value < 10)
      value = 10;
    if (value > 50)
      value = 50;
    this._relativeheight = value;
    this._parentRenderer.redraw();
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    this._enabled = value;
    this._parentRenderer.redraw();
  }
  get bgColor1() {
    return this._bgColor1;
  }
  set bgColor1(value) {
    this._bgColor1 = value;
    this._bgBrush = null;
    this._parentRenderer.redraw();
  }
  get cursorBorderColor() {
    return this._cursorBorderColor;
  }
  set cursorBorderColor(value) {
    this._cursorBorderColor = value;
    this._cursorBorderPen = null;
    this._parentRenderer.redraw();
  }
  get yAxisHandling() {
    return this._yAxisHandling;
  }
  set yAxisHandling(value) {
    this._yAxisHandling = value;
    this._parentRenderer.redraw();
  }
  get bgColor2() {
    return this._bgColor2;
  }
  set bgColor2(value) {
    this._bgColor2 = value;
    this._bgBrush = null;
    this._parentRenderer.redraw();
  }
  get cursorColor() {
    return this._cursorColor;
  }
  set cursorColor(value) {
    this._cursorColor = value;
    this._cursorBrush = null;
    this._parentRenderer.redraw();
  }
  get cursorBrush() {
    if (this._cursorBrush == null) {
      this._cursorBrush = new YSolidBrush(this._cursorColor);
    }
    return this._cursorBrush;
  }
  get pen() {
    if (this._pen == null)
      this._pen = new YPen(this._xAxisColor, this._xAxisThickness, true);
    return this._pen;
  }
  get cursorBorderPen() {
    if (this._cursorBorderPen == null)
      this._cursorBorderPen = new YPen(this._cursorBorderColor, 1, true);
    return this._cursorBorderPen;
  }
  get xAxisColor() {
    return this._xAxisColor;
  }
  set xAxisColor(value) {
    this._xAxisColor = value;
    this._pen = null;
    this._parentRenderer.redraw();
  }
  get xAxisThickness() {
    return this._xAxisThickness;
  }
  set xAxisThickness(value) {
    if (value < 0)
      throw new RangeError("Thickness must be a positive value");
    this._xAxisThickness = value;
    this._pen = null;
    this._parentRenderer.redraw();
  }
  get borderPen() {
    if (this._borderPen == null)
      this._borderPen = new YPen(this._borderColor, this._borderThickness, true);
    return this._borderPen;
  }
  get borderColor() {
    return this._borderColor;
  }
  set borderColor(value) {
    this._borderColor = value;
    this._borderPen = null;
    this._parentRenderer.redraw();
  }
  get borderThickness() {
    return this._borderThickness;
  }
  set borderThickness(value) {
    if (value < 0)
      throw new RangeError("Thickness must be a positive value");
    this._borderThickness = value;
    this._borderPen = null;
    this._parentRenderer.redraw();
  }
  setPosition(ParentWidth, ParentHeight, Lmargin, Rmargin, Tmargin, Bmargin) {
    if (this._viewport.Lmargin != Lmargin || this._viewport.Rmargin != Rmargin || this._viewport.Tmargin != Tmargin || this._viewport.Bmargin != Bmargin) {
      this._bgBrush = null;
    }
    this._viewport.Lmargin = Lmargin;
    this._viewport.Rmargin = Rmargin;
    this._viewport.Bmargin = Bmargin;
    this._viewport.Tmargin = Tmargin;
    this._viewport.Width = ParentWidth;
    this._viewport.Height = ParentHeight;
  }
  setIRLPosition(IRLx, IRLy, xZoom, yZoom) {
    this._viewport.IRLx = IRLx;
    this._viewport.IRLy = IRLy;
    this._viewport.zoomx = xZoom;
    this._viewport.zoomy = yZoom;
  }
  startCapture(IRLStartPoint, xAxisMin, xAxisMax) {
    this._viewport.OriginalXAxisMin = xAxisMin;
    this._viewport.OriginalXAxisMax = xAxisMax;
    this._viewport.OriginalIRLx = this._viewport.IRLx;
    this._viewport.OriginalLmargin = this._viewport.Lmargin;
    this._viewport.OriginalZoomx = this._viewport.zoomx;
    this._viewport.IRLCaptureStartX = IRLStartPoint.x;
    this._viewport.Capture = true;
  }
  get Capture() {
    return this._viewport.Capture;
  }
  stopCapture() {
    this._viewport.Capture = false;
  }
  get viewport() {
    return this._viewport;
  }
  get bgBrush() {
    if (this._bgBrush == null) {
      this._bgBrush = new YLinearGradientBrush(this._bgColor1, this._bgColor2);
    }
    return this._bgBrush;
  }
  get font() {
    return this._font;
  }
};
(function(Navigator2) {
  class YAxisHandlingEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, YAxisHandling);
    }
  }
  Navigator2.YAxisHandlingEnumItem = YAxisHandlingEnumItem;
  class YAxisHandling extends YEnum {
  }
  YAxisHandling.AUTO = new YAxisHandlingEnumItem("AUTO", "Automatic");
  YAxisHandling.INHERIT = new YAxisHandlingEnumItem("INHERIT", "Inherit from main view");
  Navigator2.YAxisHandling = YAxisHandling;
})(Navigator || (Navigator = {}));
var Marker = class {
  constructor(parent, directParent) {
    this._userData = null;
    this._stringFormat = null;
    this._MarkerTextCallback = null;
    this._enabled = false;
    this._xposition = 0;
    this._xpositionIsRelative = false;
    this._yposition = 92;
    this._text = "Marker";
    this._textAlign = Marker.TextAlign.CENTER;
    this._bgColor = YColor.FromArgb(255, 255, 255, 192);
    this._borderColor = YColor.DarkRed;
    this._borderthickness = 1;
    this._arrowSize = 5;
    this._padding = 5;
    this._verticalMargin = 5;
    this._horizontalMargin = 5;
    this._bgBrush = null;
    this._arrowBrush = null;
    this._pen = null;
    this._navigatorpen = null;
    this._font = null;
    this._directParent = directParent;
    this._parentRenderer = parent;
    this._font = new YFont(parent, this, 8, null);
  }
  get userData() {
    return this._userData;
  }
  set userData(value) {
    this._userData = value;
  }
  static _round100(v) {
    return Math.round(100 * v) / 100;
  }
  get stringFormat() {
    if (this._stringFormat != null)
      return this._stringFormat;
    this._stringFormat = new YStringFormat(16384);
    this._stringFormat.LineAlignment = 1;
    switch (this._textAlign) {
      case Marker.TextAlign.LEFT:
        this._stringFormat.Alignment = 0;
        break;
      case Marker.TextAlign.CENTER:
        this._stringFormat.Alignment = 1;
        break;
      case Marker.TextAlign.RIGHT:
        this._stringFormat.Alignment = 2;
        break;
    }
    return this._stringFormat;
  }
  get PatchTextCallback() {
    return this._MarkerTextCallback;
  }
  set PatchTextCallback(callback) {
    this._MarkerTextCallback = callback;
  }
  get directParent() {
    return this._directParent;
  }
  startCapture() {
    this._parentRenderer.startMarkerCapture(this);
  }
  setCapturedPosition(position, axis) {
    this.enabled = true;
    this._xpositionIsRelative = axis.timeReference == TimeConverter.TimeReference.RELATIVE && axis.zeroTime > 0;
    this._xposition = Marker._round100(this._xpositionIsRelative ? position - axis.zeroTime : position);
    this._parentRenderer.clearCachedObjects();
    this._parentRenderer.redraw();
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    if (this._enabled != value) {
      this._enabled = value;
      this._parentRenderer.clearCachedObjects();
      this._parentRenderer.redraw();
    }
  }
  get xposition() {
    return this._xposition;
  }
  set xposition(value) {
    this._xposition = Marker._round100(value);
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get timereference() {
    return this._xpositionIsRelative ? TimeConverter.TimeReference.RELATIVE : TimeConverter.TimeReference.ABSOLUTE;
  }
  set timereference(value) {
    let v = value == TimeConverter.TimeReference.RELATIVE;
    if (this._xpositionIsRelative != v) {
      let ZeroPosition = this._directParent.zeroTime;
      if (isNaN(ZeroPosition))
        ZeroPosition = 0;
      if (v) {
        this._xpositionIsRelative = true;
        this._xposition -= ZeroPosition;
      } else {
        this._xpositionIsRelative = false;
        this._xposition += ZeroPosition;
      }
      this._xposition = Marker._round100(this._xposition);
      this._parentRenderer.redraw();
    }
  }
  get positionOnXAxis() {
    return new xAxisPosition(this._xposition, this._xpositionIsRelative);
  }
  set positionOnXAxis(value) {
    if (value.capture) {
      this.startCapture();
    } else {
      let v = Marker._round100(value.value);
      if (this._xpositionIsRelative != value.relative || this._xposition != v) {
        this._xposition = v;
        this._xpositionIsRelative = value.relative;
        if (this._enabled)
          this._parentRenderer.redraw();
      }
    }
  }
  get yposition() {
    return this._yposition;
  }
  set yposition(value) {
    this._yposition = Math.min(100, Math.max(0, value));
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get text() {
    return this._text;
  }
  set text(value) {
    this._text = value;
    this._parentRenderer.clearCachedObjects();
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get textAlign() {
    return this._textAlign;
  }
  set textAlign(value) {
    this._textAlign = value;
    this._stringFormat = null;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get shortText() {
    if (this._text.length <= 20)
      return this._text;
    return this._text.substring(0, 18) + "..";
  }
  get bgColor() {
    return this._bgColor;
  }
  set bgColor(value) {
    this._bgColor = value;
    this._bgBrush = null;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get borderColor() {
    return this._borderColor;
  }
  set borderColor(value) {
    this._borderColor = value;
    this._arrowBrush = null;
    this._pen = null;
    this._navigatorpen = null;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get borderthickness() {
    return this._borderthickness;
  }
  set borderthickness(value) {
    if (value < 0)
      throw new RangeError("thickness must be a positive value");
    this._borderthickness = value;
    this._parentRenderer.clearCachedObjects();
    this._pen = null;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get arrowSize() {
    return this._arrowSize;
  }
  set arrowSize(value) {
    this._arrowSize = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get padding() {
    return this._padding;
  }
  set padding(value) {
    if (value < 0)
      throw new RangeError("Padding must be a positive value");
    this._padding = value;
    this._parentRenderer.clearCachedObjects();
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get verticalMargin() {
    return this._verticalMargin;
  }
  set verticalMargin(value) {
    this._verticalMargin = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get horizontalMargin() {
    return this._horizontalMargin;
  }
  set horizontalMargin(value) {
    this._horizontalMargin = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get bgBrush() {
    if (this._bgBrush == null) {
      this._bgBrush = new YSolidBrush(this._bgColor);
    }
    return this._bgBrush;
  }
  get arrowBrush() {
    if (this._arrowBrush == null) {
      this._arrowBrush = new YSolidBrush(this._borderColor, true);
    }
    return this._arrowBrush;
  }
  get pen() {
    if (this._pen == null)
      this._pen = new YPen(this._borderColor, this._borderthickness, true);
    return this._pen;
  }
  get navigatorpen() {
    if (this._navigatorpen == null)
      this._navigatorpen = new YPen(this._borderColor, 1);
    return this._navigatorpen;
  }
  get font() {
    return this._font;
  }
};
(function(Marker2) {
  class TextAlignEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, TextAlign);
    }
  }
  Marker2.TextAlignEnumItem = TextAlignEnumItem;
  class TextAlign extends YEnum {
  }
  TextAlign.LEFT = new TextAlignEnumItem("LEFT", "Left");
  TextAlign.CENTER = new TextAlignEnumItem("CENTER", "Center");
  TextAlign.RIGHT = new TextAlignEnumItem("RIGHT", "Right");
  Marker2.TextAlign = TextAlign;
})(Marker || (Marker = {}));
var Legend = class {
  constructor(parent, directParent) {
    this._userData = null;
    this._title = "";
    this._font = null;
    this._directParent = directParent;
    this._parentRenderer = parent;
    this._font = new YFont(parent, this, 12, null);
  }
  get directParent() {
    return this._directParent;
  }
  get userData() {
    return this._userData;
  }
  set userData(value) {
    this._userData = value;
  }
  get title() {
    return this._title;
  }
  set title(value) {
    this._title = value;
    this._parentRenderer.redraw();
  }
  get font() {
    return this._font;
  }
};
var GenericAxis = class {
  constructor(parent, directParent) {
    this._userData = null;
    this._AxisChanged = null;
    this._pen = null;
    this._gridPen = null;
    this._visible = true;
    this._AllowAutoShow = false;
    this._min = Number.NaN;
    this._max = Number.NaN;
    this._step = Number.NaN;
    this._thickness = 1;
    this._color = YColor.Black;
    this._showGrid = false;
    this._gridColor = YColor.FromArgb(50, 0, 0, 0);
    this._gridThickness = 1;
    this._font = null;
    this._zones = [];
    this._directParent = directParent;
    this._parentRenderer = parent;
    this._legend = new Legend(parent, this);
    this._font = new YFont(parent, this);
  }
  get directParent() {
    return this._directParent;
  }
  get zones() {
    return this._zones;
  }
  AddZone() {
    let z = new Zone(this._parentRenderer, this);
    this._zones.push(z);
    return z;
  }
  get userData() {
    return this._userData;
  }
  set userData(value) {
    this._userData = value;
  }
  get AxisChanged() {
    return this._AxisChanged;
  }
  set AxisChanged(value) {
    this._AxisChanged = value;
  }
  get pen() {
    if (this._pen == null)
      this._pen = new YPen(this._color, this._thickness, true);
    return this._pen;
  }
  get gridPen() {
    if (this._gridPen == null)
      this._gridPen = new YPen(this._gridColor, this._gridThickness, true);
    return this._gridPen;
  }
  get visible() {
    return this._visible;
  }
  set visible(value) {
    this._visible = value;
    if (!value) {
      this._AllowAutoShow = false;
    }
    this._parentRenderer.redraw();
  }
  get AllowAutoShow() {
    return this._AllowAutoShow;
  }
  set AllowAutoShow(value) {
    this._AllowAutoShow = value;
  }
  AutoShow() {
    if (this._AllowAutoShow) {
      this.visible = true;
      if (this._AxisChanged != null)
        this._AxisChanged(this);
    }
  }
  set_minMax(value_min, value_max) {
    if (!isNaN(value_min) && !isNaN(value_max) && value_min >= value_max) {
      throw new RangeError("Min (" + value_min.toString() + ") cannot be greater than max (" + value_max.toString() + ")");
    }
    this._min = value_min;
    this._max = value_max;
    this._parentRenderer.redraw();
  }
  get min() {
    return this._min;
  }
  set min(value) {
    if (!isNaN(value) && !isNaN(this._max) && !YDataRenderer.minMaxCheckDisabled) {
      if (value >= this._max) {
        throw new RangeError("Min cannot be greater than max (" + this._max.toString() + ")");
      }
    }
    this._min = value;
    this._parentRenderer.redraw();
  }
  setMinMax(min, max) {
    if (min < max) {
      this._min = min;
      this._max = max;
      this._parentRenderer.redraw();
    }
  }
  get max() {
    return this._max;
  }
  set max(value) {
    if (!isNaN(value) && !isNaN(this._min) && !YDataRenderer.minMaxCheckDisabled) {
      if (value <= this._min)
        throw new RangeError("Max cannot be less than min (" + this._min.toString() + ")");
    }
    this._max = value;
    this._parentRenderer.redraw();
  }
  get step() {
    return this._step;
  }
  set step(value) {
    if (!isNaN(value) && value < 0)
      throw new RangeError("Steps must be a strictely positive value");
    this._step = value;
    this._parentRenderer.redraw();
  }
  get thickness() {
    return this._thickness;
  }
  set thickness(value) {
    if (value < 0)
      throw new RangeError("Thickness must be a positive value");
    this._thickness = value;
    this._pen = null;
    this._parentRenderer.redraw();
  }
  get color() {
    return this._color;
  }
  set color(value) {
    this._color = value;
    this._pen = null;
    this._parentRenderer.redraw();
  }
  get showGrid() {
    return this._showGrid;
  }
  set showGrid(value) {
    this._showGrid = value;
    this._parentRenderer.redraw();
  }
  get gridColor() {
    return this._gridColor;
  }
  set gridColor(value) {
    this._gridColor = value;
    this._gridPen = null;
    this._parentRenderer.redraw();
  }
  get gridThickness() {
    return this._gridThickness;
  }
  set gridThickness(value) {
    if (value < 0)
      throw new RangeError("Thickness must be a positive value");
    this._gridThickness = value;
    this._gridPen = null;
    this._parentRenderer.redraw();
  }
  get font() {
    return this._font;
  }
  get legend() {
    return this._legend;
  }
};
var StartStopStep = class {
  constructor() {
    this.dataMin = 0;
    this.dataMax = 0;
    this.absMin = 0;
    this.absMax = 0;
    this.step = 0;
    this.start = 0;
    this.stop = 0;
    this.precision = 0;
  }
};
var xAxisPosition = class {
  constructor(v, rel, capture) {
    this._isRelative = false;
    this._value = 0;
    this._capture = false;
    this._isRelative = rel;
    this._value = v;
    this._capture = typeof capture == "undefined" ? false : capture;
  }
  get relative() {
    return this._isRelative;
  }
  set relative(value) {
    this._isRelative = value;
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value;
  }
  clone() {
    return new xAxisPosition(this._value, this._isRelative, this._capture);
  }
  toString() {
    if (this._isRelative) {
      return TimeConverter.secTimeSpanToString(this._value, 0);
    } else {
      let date = TimeConverter.FromUnixTime(this._value);
      let res = date.getFullYear().toString() + "-" + (date.getMonth() + 1).toString() + "-" + date.getDate().toString() + " " + date.getHours().toString() + ":";
      let st = date.getMinutes().toString();
      if (st.length <= 1)
        st = "0" + st;
      res = res + st + ":";
      let s = date.getSeconds();
      let ms = date.getMilliseconds();
      s = s + ms / 1e3;
      if (s < 10)
        res = res + "0";
      if (ms == 0) {
        res = res + s.toString();
      } else {
        res = res + s.toFixed(3);
      }
      return res;
    }
  }
  TryParse(str) {
    if (this._isRelative)
      return TimeConverter.tryParseStringToSecTimeSpan(str);
    return TimeConverter.tryParseStringToAbsDateTime(str);
  }
  get capture() {
    return this._capture;
  }
  set capture(value) {
    this._capture = value;
  }
};
xAxisPosition.DTdisplayformat = "DD/MM/YY hh:mm:ss.ff";
xAxisPosition.TSdisplayformat = "dd.hh:mm:ss.ff";
var YNumberFormatInfo = class {
  constructor() {
    this.NumberDecimalSeparator = ".";
  }
};
var YAxis = class extends GenericAxis {
  constructor(parent, directParent, index) {
    super(parent, directParent);
    this._index = 0;
    this._highlightZero = false;
    this._position = YAxis.HrzPosition.LEFT;
    this.innerWidth = 0;
    this.zoom = 0;
    this.IRLy = 0;
    this._index = index;
    this.nfi = new YNumberFormatInfo();
    this.nfi.NumberDecimalSeparator = ".";
    this.startStopStep = new StartStopStep();
    this.startStopStep.start = 0;
    this.startStopStep.stop = 1;
    this.startStopStep.step = 0.1;
  }
  get index() {
    return this._index;
  }
  lockMinMax() {
    this._min = this.startStopStep.absMin;
    this._max = this.startStopStep.absMax;
    this._parentRenderer.redraw();
  }
  unlockMinMax() {
    this._min = Number.NaN;
    this._max = Number.NaN;
    this._parentRenderer.redraw();
  }
  get highlightZero() {
    return this._highlightZero;
  }
  set highlightZero(value) {
    this._highlightZero = value;
    this._parentRenderer.redraw();
  }
  get position() {
    return this._position;
  }
  set position(value) {
    this._position = value;
    this._parentRenderer.redraw();
  }
  computeStartAndStep(M) {
    let res = new StartStopStep();
    let min = this.min;
    let max = this.max;
    res.step = this.step;
    res.precision = 0;
    if (!MinMaxHandler.isDefined(M)) {
      M = MinMaxHandler.DefaultValue();
      M.Min = 0;
      M.Max = 100;
    }
    if (isNaN(min))
      min = M.Min;
    if (isNaN(max))
      max = M.Max;
    res.absMax = max;
    res.absMin = min;
    if (min == max) {
      min -= 0.5;
      max += 0.5;
    }
    if (min != 0)
      min -= (max - min) * 0.025;
    if (max != 0)
      max += (max - min) * 0.025;
    res.start = min;
    res.stop = max;
    res.dataMin = min;
    res.dataMax = max;
    let Delta = max - min;
    if (isNaN(res.step)) {
      let MagnitudePwr = Math.log10(Delta);
      if (MagnitudePwr - Math.floor(MagnitudePwr) != 0)
        MagnitudePwr = Math.floor(MagnitudePwr) + 1;
      res.precision = MagnitudePwr - 1 >> 0;
      let Magnitude = Math.pow(10, res.precision);
      let C = Delta / Magnitude;
      if (C <= 2) {
        res.step = Magnitude / 5;
        res.precision--;
      } else if (C <= 5) {
        res.step = Magnitude / 2;
        res.precision--;
      } else {
        res.step = Magnitude;
      }
      if (isNaN(this.min)) {
        let c = min / res.step;
        if (c - Math.floor(c) != 0)
          c = c > 0 ? Math.floor(c) + 1 : Math.floor(c) - 1;
        res.start = res.step * c;
      }
    } else {
      let v = res.step.toString();
      let p = v.indexOf(".");
      if (p >= 0) {
        res.precision = -(v.length - p - 1);
      } else {
        res.precision = 0;
      }
    }
    this.startStopStep = res;
    return res;
  }
};
(function(YAxis2) {
  class HrzPositionEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, HrzPosition);
    }
  }
  YAxis2.HrzPositionEnumItem = HrzPositionEnumItem;
  class HrzPosition extends YEnum {
  }
  HrzPosition.LEFT = new HrzPositionEnumItem("LEFT", "Left");
  HrzPosition.RIGHT = new HrzPositionEnumItem("RIGHT", "Right");
  YAxis2.HrzPosition = HrzPosition;
})(YAxis || (YAxis = {}));
var XAxis = class extends GenericAxis {
  constructor(parent, directParent) {
    super(parent, directParent);
    this._position = XAxis.VrtPosition.BOTTOM;
    this._markers = [];
    this._initialZoom = 300;
    this._initialOffset = 0;
    this._format = XAxis.FORMATAUTO;
    this._timeReference = TimeConverter.TimeReference.ABSOLUTE;
    this._zeroTime = 0;
    this._fullSize = 0;
    this.innerHeight = 0;
    this._overflowHandling = XAxis.OverflowHandling.DONOTHING;
    this._parentGraph = parent;
    this._markers = [];
    this.min = TimeConverter.ToUnixTime(TimeConverter.UTCNow());
    this.max = this.min + this.initialZoom;
    this.step = 30;
  }
  get position() {
    return this._position;
  }
  set position(value) {
    this._position = value;
    this._parentRenderer.redraw();
  }
  get markers() {
    return this._markers;
  }
  AddMarker() {
    let m = new Marker(this._parentGraph, this);
    this._markers.push(m);
    this._parentGraph.clearCachedObjects();
    this._parentGraph.redraw();
    return m;
  }
  get initialZoom() {
    return this._initialZoom;
  }
  set initialZoom(value) {
    if (value <= 0)
      throw new RangeError("Zoom must be a positive value");
    this._initialZoom = value;
    this.min = this.min - this._initialZoom * this._initialOffset / 100;
    this.max = this.min + this.initialZoom;
    this._parentRenderer.redraw();
  }
  get initialOffset() {
    return this._initialOffset;
  }
  set initialOffset(value) {
    this._initialOffset = value;
    let p = this._parentGraph.getMostRecentPoint();
    if (isNaN(p.x)) {
      this._min = this._min - this._initialZoom * this._initialOffset / 100;
      this._max = this._min + this._initialZoom;
      this._parentRenderer.redraw();
    } else {
      let zoom = this._max - this._min;
      this._min = p.x - zoom * this._initialOffset / 100;
      this._max = this._min + zoom;
    }
    this._parentRenderer.redraw();
  }
  get labelFormat() {
    return this._format;
  }
  set labelFormat(value) {
    this._format = value;
    this._parentRenderer.redraw();
  }
  get timeReference() {
    return this._timeReference;
  }
  set timeReference(value) {
    this._timeReference = value;
    this._parentRenderer.redraw();
  }
  get zeroTime() {
    return this._zeroTime;
  }
  set zeroTime(value) {
    this._zeroTime = value;
  }
  get fullSize() {
    return this._fullSize;
  }
  set fullSize(value) {
    this._fullSize = value;
  }
  bestFormat(dataTimedelta, viewportTimedelta) {
    return TimeConverter.BestTimeformat(dataTimedelta, viewportTimedelta, this._timeReference);
  }
  get overflowHandling() {
    return this._overflowHandling;
  }
  set overflowHandling(value) {
    this._overflowHandling = value;
  }
};
XAxis.FORMATAUTO = 0;
(function(XAxis2) {
  class VrtPositionEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, VrtPosition);
    }
  }
  XAxis2.VrtPositionEnumItem = VrtPositionEnumItem;
  class VrtPosition extends YEnum {
  }
  VrtPosition.TOP = new VrtPositionEnumItem("TOP", "Top");
  VrtPosition.BOTTOM = new VrtPositionEnumItem("BOTTOM", "Bottom");
  XAxis2.VrtPosition = VrtPosition;
  class OverflowHandlingEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, OverflowHandling);
    }
  }
  XAxis2.OverflowHandlingEnumItem = OverflowHandlingEnumItem;
  class OverflowHandling extends YEnum {
  }
  OverflowHandling.DONOTHING = new OverflowHandlingEnumItem("DONOTHING", "Do nothing");
  OverflowHandling.SCROLL = new OverflowHandlingEnumItem("SCROLL", "Scroll contents");
  OverflowHandling.CONTRACT = new OverflowHandlingEnumItem("CONTRACT", "Squeeze contents");
  XAxis2.OverflowHandling = OverflowHandling;
})(XAxis || (XAxis = {}));
var DataPanel = class extends GenericPanel {
  constructor(parent, directParent) {
    super(parent, directParent);
    this._panelHrzAlign = DataPanel.HorizontalAlign.CENTERED;
    this._panelVrtAlign = DataPanel.VerticalAlign.CENTERED;
    this._horizontalPosition = DataPanel.HorizontalPosition.ABSOLUTEX;
    this._verticalPosition = DataPanel.VerticalPosition.ABSOLUTEY;
    this._AbsoluteXposition = 0;
    this._AbsoluteYposition = 0;
    this._YScaleIndex = 0;
  }
  get panelHrzAlign() {
    return this._panelHrzAlign;
  }
  set panelHrzAlign(value) {
    this._panelHrzAlign = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get panelVrtAlign() {
    return this._panelVrtAlign;
  }
  set panelVrtAlign(value) {
    this._panelVrtAlign = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get horizontalPosition() {
    return this._horizontalPosition;
  }
  set horizontalPosition(value) {
    this._horizontalPosition = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get verticalPosition() {
    return this._verticalPosition;
  }
  set verticalPosition(value) {
    this._verticalPosition = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get AbsoluteXposition() {
    return this._AbsoluteXposition;
  }
  set AbsoluteXposition(value) {
    this._AbsoluteXposition = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get AbsoluteYposition() {
    return this._AbsoluteYposition;
  }
  set AbsoluteYposition(value) {
    this._AbsoluteYposition = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get yScaleIndex() {
    return this._YScaleIndex;
  }
  set yScaleIndex(value) {
    this._YScaleIndex = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
};
(function(DataPanel2) {
  class HorizontalAlignEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, HorizontalAlign);
    }
  }
  DataPanel2.HorizontalAlignEnumItem = HorizontalAlignEnumItem;
  class HorizontalAlign extends YEnum {
  }
  HorizontalAlign.LEFTOF = new HorizontalAlignEnumItem("LEFTOF", "Left");
  HorizontalAlign.CENTERED = new HorizontalAlignEnumItem("CENTERED", "Center");
  HorizontalAlign.RIGHTOF = new HorizontalAlignEnumItem("RIGHTOF", "Right");
  DataPanel2.HorizontalAlign = HorizontalAlign;
  class VerticalAlignEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, VerticalAlign);
    }
  }
  DataPanel2.VerticalAlignEnumItem = VerticalAlignEnumItem;
  class VerticalAlign extends YEnum {
  }
  VerticalAlign.ABOVE = new VerticalAlignEnumItem("ABOVE", "Top");
  VerticalAlign.CENTERED = new VerticalAlignEnumItem("CENTERED", "Center");
  VerticalAlign.BELOW = new VerticalAlignEnumItem("BELOW", "Bottom");
  DataPanel2.VerticalAlign = VerticalAlign;
  class HorizontalPositionEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, HorizontalPosition);
    }
  }
  DataPanel2.HorizontalPositionEnumItem = HorizontalPositionEnumItem;
  class HorizontalPosition extends YEnum {
  }
  HorizontalPosition.LEFTBORDER = new HorizontalPositionEnumItem("LEFTBORDER", "Left border");
  HorizontalPosition.ABSOLUTEX = new HorizontalPositionEnumItem("ABSOLUTEX", "Absolute X position");
  HorizontalPosition.RIGHTBORDER = new HorizontalPositionEnumItem("RIGHTBORDER", "Right borde");
  DataPanel2.HorizontalPosition = HorizontalPosition;
  class VerticalPositionEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, VerticalPosition);
    }
  }
  DataPanel2.VerticalPositionEnumItem = VerticalPositionEnumItem;
  class VerticalPosition extends YEnum {
  }
  VerticalPosition.TOPBORDER = new VerticalPositionEnumItem("TOPBORDER", "Top border");
  VerticalPosition.ABSOLUTEY = new VerticalPositionEnumItem("ABSOLUTEY", "Absolute Y position");
  VerticalPosition.BOTTOMBORDER = new VerticalPositionEnumItem("BOTTOMBORDER", "Bottom border");
  DataPanel2.VerticalPosition = VerticalPosition;
})(DataPanel || (DataPanel = {}));
var YCursor = class {
  constructor(pngImageData) {
  }
  get handle() {
    return "crosshair";
  }
};
var YTimeSpan = class {
  constructor(value) {
    this._value = 0;
    this._value = value;
  }
  toString(format) {
    let res = "";
    let v = Math.abs(this._value / 1e3);
    let dec = Math.floor(v);
    let frac = Math.round(1e3 * (v - Math.floor(v)));
    if (format & YDate.ms1) {
      let ms = "00" + frac.toString();
      res = "." + ms.substring(ms.length - 3).substring(0, 1);
    } else if (format & YDate.ms01) {
      let ms = "00" + frac.toString();
      res = "." + ms.substring(ms.length - 3).substring(0, 2);
    } else if (format & YDate.ms001) {
      let ms = "00" + frac.toString();
      res = "." + ms.substring(ms.length - 3).substring(0, 3);
    }
    if (format & YDate.s) {
      let sec = dec % 60;
      let s = "0" + sec.toString();
      res = s.substring(s.length - 2) + res + "s";
    }
    dec = Math.floor(dec / 60);
    if (format & YDate.m) {
      let min = dec % 60;
      let s = "0" + min.toString();
      res = s.substring(s.length - 2) + "m" + res;
    }
    dec = Math.floor(dec / 60);
    if (format & YDate.h) {
      let hrs = dec % 24;
      let s = "0" + hrs.toString();
      res = s.substring(s.length - 2) + "h" + res;
    }
    dec = Math.floor(dec / 24);
    if (format & YDate.D) {
      let s = dec.toString();
      res = s.substring(s.length - 2) + "d" + res;
    }
    return res;
  }
};
YTimeSpan.TicksPerSecond = 1e3;
var YGraph = class extends YDataRenderer {
  constructor(ChartContainer, logFunction) {
    super(ChartContainer, logFunction);
    this._markerCaptureStartedCallback = null;
    this._markerCaptureStoppedCallback = null;
    this.lastPointCount = -1;
    this.lastTopMargin = -1;
    this.lastBottomMargin = -1;
    this.navigatorCache = null;
    this.markerCapture = null;
    this._borderPen = null;
    this._borderColor = YColor.LightGray;
    this._borderThickness = 1;
    this._touchStartfct = null;
    this._touchMovefct = null;
    this._touchEndfct = null;
    this._mouseDownfct = null;
    this._mouseMovefct = null;
    this._mouseWheelfct = null;
    this._mouseKeyDownfct = null;
    this.mainViewPort = new ViewPortSettings();
    this._timeRange = null;
    this._bgBrush = null;
    this._bgColor1 = YColor.FromArgb(255, 200, 200, 200);
    this._bgColor2 = YColor.FromArgb(255, 255, 255, 255);
    this._touchStartPinchDistance = -1;
    this._touchStartPinchCenter = new Point(0, 0);
    this._touchStartPinchZoom = 1;
    this._touchStartPinchIRLx = 0;
    this._touchStartPinchRange = 0;
    this.dataTrackerRefreshtimeout = null;
    YGraph.createCaptureCursor();
    this._xAxis = new XAxis(this, this);
    this._yAxes = [];
    this._series = [];
    this._dataPanels = [];
    this._navigator = new Navigator(this, this);
    this._legendPanel = new LegendPanel(this, this);
    this._dataTracker = new DataTracker(this, this);
    this._touchStartfct = (e) => {
      this.TouchStart(this.UIContainer, e);
    };
    this._touchMovefct = (e) => {
      this.TouchMove(this.UIContainer, e);
    };
    this._touchEndfct = (e) => {
      this.TouchEnd(this.UIContainer, e);
    };
    this._mouseDownfct = (e) => {
      this.MouseDown(this.UIContainer, e);
    };
    this._mouseMovefct = (e) => {
      this.MouseMove(this.UIContainer, e);
    };
    this._mouseWheelfct = (e) => {
      this.mouseWheelEvent(this.UIContainer, e);
    };
    this._mouseKeyDownfct = (e) => {
      this.KeyDown(this.UIContainer, e);
    };
    this.UIContainer.addEventListener("touchstart", this._touchStartfct);
    this.UIContainer.addEventListener("touchmove", this._touchMovefct);
    this.UIContainer.addEventListener("touchend", this._touchEndfct);
    this.UIContainer.addEventListener("mousedown", this._mouseDownfct);
    this.UIContainer.addEventListener("mousemove", this._mouseMovefct);
    this.UIContainer.addEventListener("wheel", this._mouseWheelfct);
    this.UIContainer.addEventListener("keydown", this._mouseKeyDownfct);
    this._timeRange = MinMaxHandler.DefaultValue();
    let originalContainerWidth = ChartContainer.width;
    let originalContainerHeight = ChartContainer.height;
    let originalFormWidth = ChartContainer.width;
    let originalFormHeight = ChartContainer.height;
  }
  get legendPanel() {
    return this._legendPanel;
  }
  get dataTracker() {
    return this._dataTracker;
  }
  get borderColor() {
    return this._borderColor;
  }
  set borderColor(value) {
    this._borderColor = value;
    this._borderPen = null;
    this.redraw();
  }
  get borderThickness() {
    return this._borderThickness;
  }
  set borderThickness(value) {
    if (value < 0)
      throw new RangeError("thickness must be a positive value");
    this._borderThickness = value;
    this._borderPen = null;
    this.redraw();
  }
  static get verticalDragZoomEnabled() {
    return YGraph._defaultVerticalDragZoomEnabled;
  }
  static set verticalDragZoomEnabled(value) {
    YGraph._defaultVerticalDragZoomEnabled = value;
  }
  static createCaptureCursor() {
    if (YGraph.captureCursor != null)
      return;
    let base64png = "iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAALHRFWHRDcmVhdGlvbiBUaW1lAFRodSAyMCBBdWcgMjAyMCAxMjoxNTo1MCArMDEwMP38NhoAAAAHdElNRQfkCBQOJAvCrm0ZAAAACXBIWXMAAFxGAABcRgEUlENBAAAABGdBTUEAALGPC / xhBQAAAmVJREFUeNrtVrFuFDEQHd9eBImAIBFoAgVC0NJQUFDwL / QgRXzAfUz + Iy0pQwsIJAhCQMQBUS5c2DXv7T5fzN5qs / Fxdw0jPY3ttT3jt54ZmyXIYDDoQXnodWBV / SRJXZhJbwCXov65pZ + 4zklfBsZRf2EMxOuTjc / igIu0s0UygAvnonWZ0NP4fB2QkQz6yHvP / i76V4E1jZ / bic4LIuMnND7ZwDl + u4 / me + AnkKPvu + 7rFMNZBzZ64eRTm5w6sQ8cAcUZexVytOCpOnv7j + QdDD + CHgKjMg80nWpeQrYgd4A3wHjWPJAqN4BVoLcsB1ZMd25ZDkzkvwNLd6AMQ4XGIuXElKz6SAo3rYpLhsZKyyJmwu2WTLiF5g / g2NozIY1 / BkacRwaYkZgUPlr7L2EdeAhjLxpqwTOr0vAHOZG37FPIOO3mfXXG1qEWAGvM + TC6Rydk / KmMv7bmWlD / v95qtaCThGpo1TPsFvp7wBO0v4nBqWoYvR0yOeLFThHmdH4TcgGQy8i + hkn5V / WbSjGr7e9oD96372LJB1o7izbPtYHpPw7V / 8u4yvzFkvPTO3MXuMbx8JRPij8svgAcAw / EwCe0f8XGxZYFB6JQZzl + rHWj1Gf5WZLVTj5py5HbVoXjeF4OuMhYnQHKulW / x6U64CPtbfpVxQu7CX0PeicMov3cKup5EZmw / KwMFNb8pMtl5G3MhIyHkOX3PPUSMmXzOX7Fqsw35Gu5NidEwXWr / jnnD + XUFzLARJRaDXnCQ53o0BpSLzcXzQfAK + Cl9EEwXrKTyr1OWGa3sFnLvPDsn6Tg8P0PrBcSMR2NtfsAAAAASUVORK5CYII =";
    try {
      YGraph.captureCursor = new YCursor(atob(base64png));
    } catch (Exception) {
      console.log("Cannot create custom cursor");
    }
  }
  get dataPanels() {
    return this._dataPanels;
  }
  addDataPanel() {
    let p = new DataPanel(this, this);
    this._dataPanels.push(p);
    return p;
  }
  setMarkerCaptureCallbacks(start, stop) {
    this._markerCaptureStartedCallback = start;
    this._markerCaptureStoppedCallback = stop;
  }
  startMarkerCapture(m) {
    if (this._markerCaptureStartedCallback != null)
      this._markerCaptureStartedCallback(m);
    this.markerCapture = m;
    this.UIContainer.focus();
  }
  destroy() {
    if (this._touchStartfct != null)
      this.UIContainer.removeEventListener("touchstart", this._touchStartfct);
    if (this._touchMovefct != null)
      this.UIContainer.removeEventListener("touchstart", this._touchMovefct);
    if (this._touchEndfct != null)
      this.UIContainer.removeEventListener("touchstart", this._touchEndfct);
    if (this._mouseDownfct != null)
      this.UIContainer.removeEventListener("mousedown", this._mouseDownfct);
    if (this._mouseMovefct != null)
      this.UIContainer.removeEventListener("mousemove", this._mouseMovefct);
    if (this._mouseWheelfct != null)
      this.UIContainer.removeEventListener("wheel", this._mouseWheelfct);
    if (this._mouseKeyDownfct != null)
      this.UIContainer.removeEventListener("keydown", this._mouseKeyDownfct);
    super.destroy();
    Object.entries(this).forEach((pair) => {
      Reflect.set(this, pair[0], null);
    });
  }
  getMostRecentPoint() {
    let res = new pointXY(NaN, NaN);
    for (let i = 0; i < this._series.length; i++)
      if (!this.series[i].disabled) {
        let p = this.series[i].getlastPoint();
        if (!isNaN(p.x)) {
          if (isNaN(res.x))
            res = p;
          else if (p.x > res.x)
            res = p;
        }
      }
    return res;
  }
  adjustGlobalTimeRange(x) {
    let max = this._timeRange.Max;
    this._timeRange = MinMaxHandler.CombineWithNumber(this._timeRange, x);
    if (isNaN(max))
      return;
    let ofset = x - max;
    if (ofset > 0) {
      switch (this._xAxis.overflowHandling) {
        case XAxis.OverflowHandling.SCROLL:
          if (max > this._xAxis.min + (this._xAxis.max - this._xAxis.min) * 0.85 && max <= this._xAxis.max) {
            this.DisableRedraw();
            this._xAxis.set_minMax(this._xAxis.min + ofset, this._xAxis.max + ofset);
            this.AllowRedraw();
          }
          break;
        case XAxis.OverflowHandling.CONTRACT:
          if (max > this._xAxis.min + (this._xAxis.max - this._xAxis.min) * 0.95 && max <= this._xAxis.max) {
            this.DisableRedraw();
            this._xAxis.max += ofset;
            this.AllowRedraw();
          }
          break;
      }
    }
  }
  get bgColor1() {
    return this._bgColor1;
  }
  set bgColor1(value) {
    this._bgColor1 = value;
    this._bgBrush = null;
    this.redraw();
  }
  get bgColor2() {
    return this._bgColor2;
  }
  set bgColor2(value) {
    this._bgColor2 = value;
    this._bgBrush = null;
    this.redraw();
  }
  get xAxis() {
    return this._xAxis;
  }
  get navigator() {
    return this._navigator;
  }
  get yAxes() {
    return this._yAxes;
  }
  get series() {
    return this._series;
  }
  addYAxis() {
    let s = new YAxis(this, this, this._yAxes.length);
    this._yAxes.push(s);
    this.redraw();
    return s;
  }
  addSerie() {
    let s = new DataSerie(this);
    this._series.push(s);
    this.redraw();
    return s;
  }
  clearCachedObjects() {
    this._bgBrush = null;
    this.navigatorCache = null;
  }
  TouchStart(sender, e) {
    if (e.touches.length == 1) {
      this.HandleMouseDown(sender, e.touches[0].pageX, e.touches[0].pageY);
    } else if (e.touches.length == 2) {
      e.preventDefault();
      this.HandleEndOfMouseCapture();
      this._touchStartPinchDistance = Math.sqrt(Math.pow(e.touches[1].pageX - e.touches[0].pageX, 2) + Math.pow(e.touches[1].pageY - e.touches[0].pageY, 2));
      this._touchStartPinchCenter = new Point(e.touches[1].pageX + e.touches[0].pageX >> 2, e.touches[1].pageY + e.touches[0].pageY >> 2);
      this._touchStartPinchZoom = this.mainViewPort.zoomx;
      this._touchStartPinchIRLx = this.mainViewPort.IRLx;
      this._touchStartPinchRange = this._xAxis.max - this._xAxis.min;
    }
  }
  MouseDown(sender, e) {
    if (e.buttons == 2 && this.markerCapture != null) {
      this.markerCapture = null;
      if (this._markerCaptureStoppedCallback != null)
        this._markerCaptureStoppedCallback(null);
    }
    if (e.buttons != 1)
      return;
    this.HandleMouseDown(sender, e.pageX, e.pageY);
  }
  HandleMouseDown(sender, pageX, pageY) {
    let p = this.Scr2ElmMatrix.multiplyByV(Vector3.FromXYCoord(pageX, pageY)).toPoint();
    let eX = p.X;
    let eY = p.Y;
    if (eX >= this.mainViewPort.Lmargin && eX <= this.mainViewPort.Width - this.mainViewPort.Rmargin && eY >= this.mainViewPort.Tmargin && eY <= this.mainViewPort.Height - this.mainViewPort.Bmargin) {
      if (this.markerCapture != null) {
        let p22 = YGraph.ViewPortPointToIRL(this.mainViewPort, new Point(eX, eY));
        this.markerCapture.setCapturedPosition(p22.x, this.xAxis);
        if (this._markerCaptureStoppedCallback != null)
          this._markerCaptureStoppedCallback(this.markerCapture);
        this.markerCapture = null;
        return;
      }
      let p2 = YGraph.ViewPortPointToIRL(this.mainViewPort, new Point(eX, eY));
      this.mainViewPort.OriginalXAxisMin = this.xAxis.min;
      this.mainViewPort.OriginalXAxisMax = this.xAxis.max;
      this.mainViewPort.OriginalIRLx = this.mainViewPort.IRLx;
      this.mainViewPort.OriginalLmargin = this.mainViewPort.Lmargin;
      this.mainViewPort.OriginalZoomx = this.mainViewPort.zoomx;
      this.mainViewPort.CaptureStartY = eY;
      this.mainViewPort.IRLCaptureStartX = p2.x;
      this.mainViewPort.Capture = true;
    } else if (eX >= this._navigator.viewport.Lmargin && eX <= this._navigator.viewport.Width - this._navigator.viewport.Rmargin && eY >= this._navigator.viewport.Lmargin && eY <= this._navigator.viewport.Height - this._navigator.viewport.Bmargin) {
      let p2 = YGraph.ViewPortPointToIRL(this._navigator.viewport, new Point(eX, eY));
      let p22 = YGraph.ViewPortPointToIRL(this.mainViewPort, new Point(this.mainViewPort.Lmargin, 0));
      let p3 = YGraph.ViewPortPointToIRL(this.mainViewPort, new Point(this.mainViewPort.Width - this.mainViewPort.Rmargin, 0));
      if (p2.x >= p22.x && p2.x <= p3.x) {
        this._navigator.startCapture(p2, this._xAxis.min, this._xAxis.max);
      } else {
        this.DisableRedraw();
        let min = p2.x - (p3.x - p22.x) / 2;
        let max = min + (p3.x - p22.x);
        this._xAxis.set_minMax(min, max);
        this.AllowRedraw();
        this.Draw(0);
      }
    }
  }
  TouchMove(sender, e) {
    if (e.touches.length == 1) {
      e.preventDefault();
      this.HandleMouseMove(sender, e.touches[0].pageX, e.touches[0].pageY);
    } else if (e.touches.length == 2) {
      e.preventDefault();
      let newdistance = Math.sqrt(Math.pow(e.touches[1].pageX - e.touches[0].pageX, 2) + Math.pow(e.touches[1].pageY - e.touches[0].pageY, 2));
      let ZoomFactor = newdistance / this._touchStartPinchDistance;
      let NextZoomX = this._touchStartPinchZoom * ZoomFactor;
      if (NextZoomX > this.mainViewPort.zoomx && NextZoomX > 1e3)
        return;
      let currentRange = this._xAxis.max - this._xAxis.min;
      this.mainViewPort.IRLx = this._touchStartPinchIRLx + (this._touchStartPinchCenter.X - this.mainViewPort.Lmargin) / this._touchStartPinchZoom - (this._touchStartPinchCenter.X - this.mainViewPort.Lmargin) / NextZoomX;
      this._xAxis.set_minMax(this.mainViewPort.IRLx, this.mainViewPort.IRLx + this._touchStartPinchRange / ZoomFactor);
      this.mainViewPort.zoomx = NextZoomX;
      this.redraw();
    }
  }
  TouchEnd(sender, e) {
    this.HandleEndOfMouseCapture();
  }
  MouseMove(sender, e) {
    if (e.buttons != 1 && (this.mainViewPort.Capture || this._navigator.Capture))
      this.HandleEndOfMouseCapture();
    this.HandleMouseMove(sender, e.pageX, e.pageY);
    if (this.dataTracker.enabled) {
      if (this.dataTrackerRefreshtimeout != null)
        clearTimeout(this.dataTrackerRefreshtimeout);
      this.dataTrackerRefreshtimeout = setTimeout(() => {
        this.redraw();
      }, 100);
    }
  }
  HandleEndOfMouseCapture() {
    this.mainViewPort.Capture = false;
    this._navigator.stopCapture();
    if (this._dataTracker.enabled)
      this.redraw();
  }
  HandleMouseMove(sender, pageX, pageY) {
    let p = this.Scr2ElmMatrix.multiplyByV(Vector3.FromXYCoord(pageX, pageY)).toPoint();
    let eX = p.X;
    let eY = p.Y;
    if (this.markerCapture != null) {
      if (eX > this.mainViewPort.Lmargin && eX < this.mainViewPort.Width - this.mainViewPort.Rmargin && eY > this.mainViewPort.Tmargin && eY < this.mainViewPort.Height - this.mainViewPort.Bmargin) {
        if (this.UIContainer.style.cursor != YGraph.captureCursor.handle && this.UIContainer.style.cursor != "crosshair") {
          this.UIContainer.style.cursor = YGraph.captureCursor != null ? YGraph.captureCursor.handle : "crosshair";
        }
      } else if (this.UIContainer.style.cursor != "default")
        this.UIContainer.style.cursor = "default";
    } else if (this.UIContainer.style.cursor != "default")
      this.UIContainer.style.cursor = "default";
    if (this.mainViewPort.Capture) {
      let x1 = this.mainViewPort.OriginalIRLx + (eX - this.mainViewPort.OriginalLmargin) / this.mainViewPort.OriginalZoomx;
      let deltaX = x1 - this.mainViewPort.IRLCaptureStartX;
      let deltaY = eY - this.mainViewPort.CaptureStartY;
      this.DisableRedraw();
      let halfAxisDelta = (this.mainViewPort.OriginalXAxisMax - this.mainViewPort.OriginalXAxisMin) / 2;
      let Axismiddle = (this.mainViewPort.OriginalXAxisMax + this.mainViewPort.OriginalXAxisMin) / 2;
      let deltaCoef = YGraph._defaultVerticalDragZoomEnabled && Math.abs(deltaY) > 10 ? Math.pow(1.01, deltaY) : 1;
      this._xAxis.set_minMax(Axismiddle - halfAxisDelta * deltaCoef - deltaX, Axismiddle + halfAxisDelta * deltaCoef - deltaX);
      this.AllowRedraw();
      this.redraw();
      return;
    }
    if (this._navigator.viewport.Capture) {
      let x1 = this._navigator.viewport.OriginalIRLx + (eX - this._navigator.viewport.OriginalLmargin) / this._navigator.viewport.OriginalZoomx;
      let delta = x1 - this._navigator.viewport.IRLCaptureStartX;
      this.DisableRedraw();
      this._xAxis.set_minMax(this._navigator.viewport.OriginalXAxisMin + delta, this._navigator.viewport.OriginalXAxisMax + delta);
      this.AllowRedraw();
      this.redraw();
      return;
    }
  }
  cross(p) {
  }
  static IRLPointToViewPort(viewport, p, IRLy, zoomy) {
    if (IRLy === void 0) {
      let xx2 = viewport.Lmargin + Math.round((p.x - viewport.IRLx) * viewport.zoomx);
      let yy2 = viewport.Height - viewport.Bmargin - Math.round((p.y - viewport.IRLy) * viewport.zoomy);
      return new Point(xx2 >> 0, yy2 >> 0);
    }
    let xx = viewport.Lmargin + Math.round((p.x - viewport.IRLx) * viewport.zoomx);
    let yy = viewport.Height - viewport.Bmargin - Math.round((p.y - IRLy) * zoomy);
    return new Point(xx >> 0, yy >> 0);
  }
  static IRLPointSummaryToViewPort(viewport, p, IRLy, zoomy) {
    if (IRLy === void 0) {
      let x12 = viewport.Lmargin + Math.round((p.x1 - viewport.IRLx) * viewport.zoomx);
      let ymin2 = viewport.Height - viewport.Bmargin - Math.round((p.ymin - viewport.IRLy) * viewport.zoomy);
      let x22 = viewport.Lmargin + Math.round((p.x2 - viewport.IRLx) * viewport.zoomx);
      let ymax2 = viewport.Height - viewport.Bmargin - Math.round((p.ymax - viewport.IRLy) * viewport.zoomy);
      return new minMaxPoint(x12, ymin2, x22, ymax2);
    }
    let x1 = viewport.Lmargin + Math.round((p.x1 - viewport.IRLx) * viewport.zoomx);
    let ymin = viewport.Height - viewport.Bmargin - Math.round((p.ymin - IRLy) * zoomy);
    let x2 = viewport.Lmargin + Math.round((p.x2 - viewport.IRLx) * viewport.zoomx);
    let ymax = viewport.Height - viewport.Bmargin - Math.round((p.ymax - IRLy) * zoomy);
    return new minMaxPoint(x1, ymin, x2, ymax);
  }
  static ViewPortPointToIRL(viewport, p, IRLy, zoomy) {
    if (IRLy === void 0) {
      return new pointXY(viewport.IRLx + (p.X - viewport.Lmargin) / viewport.zoomx, viewport.IRLy + (+viewport.Height - p.Y - viewport.Bmargin) / viewport.zoomy);
    }
    return new pointXY(viewport.IRLx + (p.X - viewport.Lmargin) / viewport.zoomx, IRLy + (+viewport.Height - p.Y - viewport.Bmargin) / zoomy);
  }
  static FindMinMax(start, end, data, count) {
    let res = MinMaxHandler.DefaultValue();
    if (data[0].x > end)
      return res;
    if (data[count - 1].x < start)
      return res;
    let N1 = 0;
    let N2 = 0;
    let First = 0;
    if (data[0].x < start) {
      N1 = 0;
      N2 = count - 1;
      while (N2 - N1 > 1) {
        let N = N1 + N2 >> 1;
        if (data[N].x > start)
          N2 = N;
        else
          N1 = N;
      }
      First = N1 - 1;
      if (First < 0)
        First = 0;
    }
    let Last = count - 1;
    if (data[Last] === void 0) {
      debugger;
    }
    if (data[Last].x > end) {
      N1 = 0;
      N2 = count - 1;
      while (N2 - N1 > 1) {
        let N = N1 + N2 >> 1;
        if (data[N].x < end)
          N1 = N;
        else
          N2 = N;
      }
      Last = N2 + 1;
      if (Last > count - 1)
        Last = count - 1;
    }
    res.Min = data[First].y;
    res.Max = data[First].y;
    for (let i = First + 1; i <= Last; i++) {
      if (data[i].y < res.Min)
        res.Min = data[i].y;
      if (data[i].y > res.Max)
        res.Max = data[i].y;
    }
    return res;
  }
  resetlegendPens() {
    for (let i = 0; i < this._series.length; i++) {
      this._series[i].resetlegendPen();
    }
  }
  drawLegendPanel(g, viewPortWidth, viewPortHeight, mainViewPort) {
    let verticalRatio = 1.25;
    if (!this._legendPanel.enabled)
      return;
    let legendWidths = new Array(this._series.length);
    let legendHeight = new Array(this._series.length);
    let ofsetx = new Array(this._series.length);
    let ofsety = new Array(this._series.length);
    let legends = new Array(this._series.length);
    let totalHeight = 0;
    let totalWidth = 0;
    let maxWidth = 0;
    let maxHeight = 0;
    g.TextRenderingHint = YTextRenderingHint.SingleBitPerPixelGridFit;
    g.SetClip(new YRectangle(0, 0, viewPortWidth, viewPortHeight));
    for (let i = 0; i < this._series.length; i++) {
      if (this._series[i].legend != "")
        legends[i] = this._series[i].legend;
      else
        legends[i] = "Series " + (i + 1).toString();
    }
    if (this._legendPanel.position == LegendPanel.Position.TOP || this._legendPanel.position == LegendPanel.Position.BOTTOM) {
      let availableWidth = viewPortWidth - 2 * this._legendPanel.padding + this._legendPanel.borderthickness;
      if (this._legendPanel.overlap)
        availableWidth = availableWidth - mainViewPort.Lmargin - mainViewPort.Rmargin;
      totalHeight = 0;
      let xx = 0;
      let yy = 0;
      for (let i = 0; i < this._series.length; i++) {
        if (this._series[i].segments.length > 0 && this._series[i].visible && !this._series[i].disabled) {
          let ssize = g.MeasureString(legends[i], this._legendPanel.font, 1e5);
          legendHeight[i] = ssize.height + 1;
          let ww = ssize.width + 20;
          if (xx == 0)
            totalHeight += ssize.height;
          if (availableWidth - xx < ww) {
            if (xx == 0) {
              ofsetx[i] = xx;
              ofsety[i] = yy;
              yy += ssize.height;
              if (maxWidth < ww)
                maxWidth = ww;
            } else {
              yy += ssize.height;
              ofsetx[i] = 0;
              ofsety[i] = yy;
              xx = ww;
              totalHeight += ssize.height;
              if (maxWidth < xx)
                maxWidth = xx;
            }
          } else {
            ofsetx[i] = xx;
            ofsety[i] = yy;
            xx += ww;
            if (maxWidth < xx)
              maxWidth = xx;
          }
        }
      }
      if (totalWidth > availableWidth) {
        totalWidth = availableWidth;
      }
    } else {
      let ty = 0;
      for (let i = 0; i < this._series.length; i++) {
        if (this._series[i].segments.length > 0 && this._series[i].visible && !this._series[i].disabled) {
          let ssize = g.MeasureString(legends[i], this._legendPanel.font, 1e5);
          legendWidths[i] = ssize.width + 1;
          if (maxWidth < legendWidths[i] + 20)
            maxWidth = legendWidths[i] + 20;
          legendHeight[i] = ssize.height + 1;
          if (maxHeight < legendHeight[i])
            maxHeight = legendHeight[i];
          ofsetx[i] = 0;
          ofsety[i] = ty;
          ty += ssize.height * verticalRatio;
          totalHeight += i == 0 ? ssize.height : ssize.height * verticalRatio;
        }
      }
    }
    let w = maxWidth + 2 * this._legendPanel.padding + this._legendPanel.borderthickness;
    let h = totalHeight + 2 * this._legendPanel.padding + this._legendPanel.borderthickness;
    let x = 0;
    let y = 0;
    switch (this._legendPanel.position) {
      case LegendPanel.Position.LEFT:
        x = this._legendPanel.horizontalMargin;
        if (!this._legendPanel.overlap) {
          mainViewPort.Lmargin += w + 2 * this.legendPanel.horizontalMargin + this.legendPanel.borderthickness >> 0;
          y = (viewPortHeight - h) / 2;
        } else {
          x += mainViewPort.Lmargin;
          y = mainViewPort.Tmargin + (viewPortHeight - mainViewPort.Tmargin - mainViewPort.Bmargin - h) / 2;
        }
        break;
      case LegendPanel.Position.TOPLEFT:
        x = this._legendPanel.horizontalMargin;
        y = this._legendPanel.verticalMargin;
        if (!this._legendPanel.overlap) {
          mainViewPort.Lmargin += w + 2 * this.legendPanel.horizontalMargin + this.legendPanel.borderthickness >> 0;
        } else {
          x += mainViewPort.Lmargin;
          y += mainViewPort.Tmargin;
        }
        break;
      case LegendPanel.Position.TOP:
        if (!this._legendPanel.overlap) {
          x = (viewPortWidth - w) / 2 - this._legendPanel.horizontalMargin - this._legendPanel.borderthickness;
          y = this._legendPanel.verticalMargin + this._legendPanel.borderthickness;
          mainViewPort.Tmargin += totalHeight + this._legendPanel.verticalMargin + 2 * this._legendPanel.verticalMargin + this._legendPanel.borderthickness >> 0;
        } else {
          x = mainViewPort.Lmargin + (viewPortWidth - mainViewPort.Lmargin - mainViewPort.Rmargin - w) / 2 - this._legendPanel.horizontalMargin - this._legendPanel.borderthickness;
          y = mainViewPort.Tmargin + this._legendPanel.verticalMargin - this._legendPanel.borderthickness;
        }
        break;
      case LegendPanel.Position.TOPRIGHT:
        x = viewPortWidth - this._legendPanel.horizontalMargin - w;
        y = this._legendPanel.verticalMargin;
        if (!this._legendPanel.overlap) {
          mainViewPort.Rmargin += w + 2 * this._legendPanel.horizontalMargin + this._legendPanel.borderthickness >> 0;
        } else {
          x -= mainViewPort.Rmargin;
          y += mainViewPort.Tmargin;
        }
        break;
      case LegendPanel.Position.RIGHT:
        x = viewPortWidth - this._legendPanel.horizontalMargin - w;
        if (!this._legendPanel.overlap) {
          mainViewPort.Rmargin += w + 2 * this._legendPanel.horizontalMargin + this._legendPanel.borderthickness >> 0;
          y = (viewPortHeight - h) / 2;
        } else {
          x -= mainViewPort.Rmargin;
          y = mainViewPort.Tmargin + (viewPortHeight - mainViewPort.Tmargin - mainViewPort.Bmargin - h) / 2;
        }
        break;
      case LegendPanel.Position.BOTTOMRIGHT:
        x = viewPortWidth - this._legendPanel.horizontalMargin - w;
        if (!this._legendPanel.overlap) {
          mainViewPort.Rmargin += w + 2 * this._legendPanel.horizontalMargin + this._legendPanel.borderthickness >> 0;
          y = viewPortHeight - this._legendPanel.verticalMargin - h;
        } else {
          x -= mainViewPort.Rmargin;
          y = viewPortHeight - mainViewPort.Bmargin - h - this._legendPanel.verticalMargin;
        }
        break;
      case LegendPanel.Position.BOTTOM:
        if (!this._legendPanel.overlap) {
          x = (viewPortWidth - w) / 2 - this._legendPanel.horizontalMargin - this._legendPanel.borderthickness;
          y = viewPortHeight - this._legendPanel.verticalMargin - 2 * this._legendPanel.padding - this._legendPanel.borderthickness - totalHeight;
          mainViewPort.Bmargin += totalHeight + 2 * this._legendPanel.padding + 2 * this._legendPanel.verticalMargin + this._legendPanel.borderthickness;
        } else {
          x = mainViewPort.Lmargin + (viewPortWidth - mainViewPort.Lmargin - mainViewPort.Rmargin - w) / 2 - this._legendPanel.horizontalMargin - this._legendPanel.borderthickness;
          y = viewPortHeight - mainViewPort.Bmargin - totalHeight - 2 * this._legendPanel.padding - 2 * this._legendPanel.verticalMargin - this._legendPanel.borderthickness;
        }
        break;
      case LegendPanel.Position.BOTTOMLEFT:
        x = this._legendPanel.horizontalMargin;
        y = this._legendPanel.verticalMargin;
        if (!this._legendPanel.overlap) {
          mainViewPort.Lmargin += w + 2 * this._legendPanel.horizontalMargin + this._legendPanel.borderthickness;
          y = viewPortHeight - this._legendPanel.verticalMargin - h;
        } else {
          x += mainViewPort.Lmargin;
          y = viewPortHeight - mainViewPort.Bmargin - h - this._legendPanel.verticalMargin;
        }
        break;
    }
    let rect = new YRectangle(x >> 0, y >> 0, w >> 0, h >> 0);
    g.FillRectangle(this._legendPanel.bgBrush, rect);
    g.DrawRectangle(this._legendPanel.pen, rect);
    g.TextRenderingHint = YTextRenderingHint.AntiAlias;
    for (let i = 0; i < this._series.length; i++) {
      if (this._series[i].segments.length > 0 && this._series[i].visible && !this._series[i].disabled) {
        g.DrawStringXY(legends[i], this._legendPanel.font, this._legendPanel.font.brush, x + ofsetx[i] + 20 + this._legendPanel.padding >> 0, y + ofsety[i] + this._legendPanel.padding >> 0);
        let px = x + ofsetx[i] + this._legendPanel.borderthickness / 2 + this._legendPanel.padding + 6 >> 0;
        let py = y + ofsety[i] + this._legendPanel.padding + legendHeight[i] / 2 >> 0;
        g.DrawLine(this._series[i].legendPen, new PointF(px, py), new PointF(px + 12, py));
      }
    }
  }
  static DoSegmentRendering(w, g, p, data, count, xTimeStart, xTimeEnd) {
    if (data[0].x > xTimeEnd || data[count - 1].x < xTimeStart)
      return 0;
    let isSVG = g instanceof YGraphicsSVG;
    let N1 = 0;
    let N2 = 0;
    let First = 0;
    if (data[0].x < xTimeStart) {
      N1 = 0;
      N2 = count - 1;
      while (N2 - N1 > 1) {
        let N = N1 + N2 >> 1;
        if (data[N].x > xTimeStart)
          N2 = N;
        else
          N1 = N;
      }
      First = N1 - 1;
      if (First < 0)
        First = 0;
    }
    let Last = count - 1;
    if (data[Last].x > xTimeEnd) {
      N1 = 0;
      N2 = count - 1;
      while (N2 - N1 > 1) {
        let N = N1 + N2 >> 1;
        if (data[N].x < xTimeEnd)
          N1 = N;
        else
          N2 = N;
      }
      Last = N2 + 1;
      if (Last > count - 1)
        Last = count - 1;
    }
    if (Last - First > 2 * w.Width - w.Lmargin - w.Rmargin) {
      let ToDraw = new Array(3 * (Last - First + 1));
      let Current = YGraph.IRLPointToViewPort(w, data[First]);
      let New;
      let i = First + 1;
      let n = 0;
      let max;
      let min;
      let limit;
      while (i < Last) {
        ToDraw[n++] = new PointF(Current.X, Current.Y);
        min = data[i].y;
        max = min;
        limit = YGraph.ViewPortPointToIRL(w, new Point(Current.X + 1, Current.Y + 1)).x;
        do {
          if (data[i].y > max)
            max = data[i].y;
          if (data[i].y < min)
            min = data[i].y;
          i++;
        } while (i < Last && data[i].x < limit);
        let p1 = YGraph.IRLPointToViewPort(w, new pointXY(data[i].x, min));
        let p2 = YGraph.IRLPointToViewPort(w, new pointXY(data[i].x, max));
        if (Math.abs(p1.Y - p2.Y) > 2) {
          ToDraw[n++] = new PointF(p1.X, p1.Y);
          ToDraw[n++] = new PointF(p2.X, p2.Y);
        }
        Current = YGraph.IRLPointToViewPort(w, data[i]);
      }
      ToDraw[n++] = Current;
      ToDraw = ToDraw.slice(0, n);
      if (n > 1)
        g.DrawLines(p, ToDraw);
      return n;
    } else {
      if (isSVG) {
        let ToDraw = new Array(Last - First + 1);
        for (let i = First; i <= Last; i++) {
          ToDraw[i - First] = YGraph.IRLPointToViewPort(w, data[i]);
        }
        g.DrawLines(p, ToDraw);
      } else {
        for (let i = First; i < Last; i++) {
          g.DrawLine(p, YGraph.IRLPointToViewPort(w, data[i]), YGraph.IRLPointToViewPort(w, data[i + 1]));
        }
      }
    }
    return Last - First;
  }
  static DoSummarySegmentRendering(w, g, p, data, count, finalPoint, xTimeStart, xTimeEnd) {
    let ToDraw = new Array(2 * count + 1);
    let n = 0;
    if (count > 0) {
      if (data[0].x1 > xTimeEnd || data[count - 1].x2 < xTimeStart)
        return 0;
      let isSVG = g instanceof YGraphicsSVG;
      let N1 = 0;
      let N2 = 0;
      let First = 0;
      if (data[0].x1 < xTimeStart) {
        N1 = 0;
        N2 = count - 1;
        while (N2 - N1 > 1) {
          let N = N1 + N2 >> 1;
          if (data[N].x1 > xTimeStart)
            N2 = N;
          else
            N1 = N;
        }
        First = N1 - 1;
        if (First < 0)
          First = 0;
      }
      let Last = count - 1;
      if (data[Last].x2 > xTimeEnd) {
        N1 = 0;
        N2 = count - 1;
        while (N2 - N1 > 1) {
          let N = N1 + N2 >> 1;
          if (data[N].x2 < xTimeEnd)
            N1 = N;
          else
            N2 = N;
        }
        Last = N2 + 1;
        if (Last > count - 1)
          Last = count - 1;
      }
      let Current;
      let New;
      let i = First;
      let max;
      let min;
      let limit;
      Current = YGraph.IRLPointSummaryToViewPort(w, data[i]);
      ToDraw[n++] = new PointF(Current.X1, Current.YMIN);
      let ymin = Current.YMAX;
      let ymax = Current.YMIN;
      let x = Current.X1;
      let buffered = 0;
      while (i <= Last) {
        Current = YGraph.IRLPointSummaryToViewPort(w, data[i]);
        if (ymin > Current.YMAX)
          ymin = Current.YMAX;
        if (ymax < Current.YMIN)
          ymax = Current.YMIN;
        buffered++;
        if (Current.X2 > x) {
          ToDraw[n++] = new PointF(x, ymin);
          if (ymax - ymin > 2)
            ToDraw[n++] = new PointF(x + Current.X2 >> 1, ymax);
          x = Current.X2;
          ymin = Current.YMAX;
          ymax = Current.YMIN;
          buffered = 0;
        }
        i++;
      }
      if (buffered > 0) {
        ToDraw[n++] = new PointF(x, Current.YMIN);
        ToDraw[n++] = new PointF(x + Current.X2 >> 1, Current.YMAX);
      }
    }
    if (finalPoint) {
      let Current = YGraph.IRLPointSummaryToViewPort(w, finalPoint);
      ToDraw[n++] = new PointF(Current.X1, Current.YMIN);
      ToDraw[n++] = new PointF(Current.X2, Current.YMAX);
    }
    if (n > 1) {
      ToDraw = ToDraw.slice(0, n);
      g.DrawLines(p, ToDraw);
    }
    return n;
  }
  DrawYAxisZones(w, g, scale) {
    if (!scale.visible)
      return;
    let Delta = scale.startStopStep.dataMax - scale.startStopStep.dataMin;
    let YZoom = Delta / (w.Height - w.Bmargin - w.Tmargin);
    for (let i = 0; i < scale.zones.length; i++) {
      if (scale.zones[i].visible) {
        let max = scale.zones[i].max;
        let min = scale.zones[i].min;
        if (Number.isNaN(max)) {
          max = scale.startStopStep.dataMax;
        }
        if (Number.isNaN(min))
          min = scale.startStopStep.dataMin;
        if (max < min) {
          let t = max;
          max = min;
          min = t;
        }
        let y0 = w.Height - w.Bmargin - Math.round((max - scale.startStopStep.dataMin) / YZoom) >> 0;
        let h = Math.round((max - min) / YZoom) >> 0;
        g.FillRectangleXYHW(scale.zones[i].zoneBrush, this.mainViewPort.Lmargin, y0, this.mainViewPort.Width - this.mainViewPort.Rmargin - this.mainViewPort.Lmargin + 1, h);
      }
    }
  }
  DrawXAxisZones(w, g, scale) {
    if (!scale.visible)
      return;
    let delta = scale.max - scale.min;
    let XZoom = delta / (w.Width - w.Lmargin - w.Rmargin);
    for (let i = 0; i < scale.zones.length; i++) {
      if (scale.zones[i].visible) {
        let max = scale.zones[i].max;
        let min = scale.zones[i].min;
        if (Number.isNaN(max))
          max = scale.min;
        if (Number.isNaN(min))
          min = scale.max;
        if (max < min) {
          let t = max;
          max = min;
          min = t;
        }
        let x0 = w.Lmargin + Math.round((min - scale.min) / XZoom) >> 0;
        g.FillRectangleXYHW(scale.zones[i].zoneBrush, x0, this.mainViewPort.Tmargin, (max - min) / XZoom >> 0, this.mainViewPort.Height - this.mainViewPort.Tmargin - this.mainViewPort.Bmargin);
      }
    }
  }
  static DrawYAxis(w, g, axis, ofset, simulation) {
    if (!axis.visible) {
      axis.innerWidth = 0;
      return axis.innerWidth;
    }
    let Delta = axis.startStopStep.dataMax - axis.startStopStep.dataMin;
    let YZoom = Delta / (w.Height - w.Bmargin - w.Tmargin);
    let leftSide = axis.position == YAxis.HrzPosition.LEFT;
    let x = leftSide ? w.Lmargin - ofset : w.Width - w.Rmargin + ofset;
    if (!simulation)
      g.DrawLineXY(axis.pen, x, w.Tmargin, x, w.Height - w.Bmargin);
    let format = new YStringFormat(16384);
    format.LineAlignment = 1;
    format.Alignment = leftSide ? 2 : 0;
    let FirstStep = axis.startStopStep.step * Math.floor(axis.startStopStep.start / axis.startStopStep.step);
    if (FirstStep < 0) {
      FirstStep -= axis.startStopStep.step;
    }
    let stepCount = ((Delta - (FirstStep - axis.startStopStep.dataMin)) / axis.startStopStep.step >> 0) + 1;
    if (!simulation)
      g.TextRenderingHint = YTextRenderingHint.AntiAlias;
    let UnitWidth = 0;
    let labelPrecision = 0;
    if (axis.startStopStep.precision < 0)
      labelPrecision = -axis.startStopStep.precision;
    if (stepCount < w.Height) {
      for (let i = 0; i < stepCount; i++) {
        let y = Math.round((FirstStep + i * axis.startStopStep.step - axis.startStopStep.dataMin) / YZoom) >> 0;
        if (y >= 0) {
          y = w.Height - w.Bmargin - y;
          let v = FirstStep + i * axis.startStopStep.step;
          if (!simulation) {
            if (axis.showGrid && (i > 0 || axis.startStopStep.dataMin != 0))
              g.DrawLineXY(axis.gridPen, w.Lmargin, y, w.Width - w.Rmargin, y);
            if (Math.abs(v) < 1e-6 && axis.highlightZero) {
              g.DrawLineXY(axis.pen, w.Lmargin, y, w.Width - w.Rmargin, y);
            }
            g.DrawLineXY(axis.pen, x + (leftSide ? -2 : 2), y, x + (leftSide ? 5 : -5), y);
          }
          let label = v.toFixed(labelPrecision);
          let ssize = g.MeasureString(label, axis.font, 1e5);
          if (ssize.width > UnitWidth)
            UnitWidth = ssize.width;
          if (!simulation) {
            let p = new Point(x + (leftSide ? -3 : 3), y);
            g.DrawStringPF(label, axis.font, axis.font.brush, p, format);
          }
        }
      }
    }
    if (axis.legend.title != "") {
      let size = g.MeasureString(axis.legend.title, axis.legend.font, 1e5);
      if (!simulation) {
        let format2 = new YStringFormat(16384);
        format2.Alignment = 1;
        format2.LineAlignment = 1;
        format2.Trimming = 0;
        let legendX = x + (leftSide ? -UnitWidth - size.height : UnitWidth + size.height + 2) >> 0;
        let legendY = w.Tmargin + (w.Height - w.Tmargin - w.Bmargin) / 2 >> 0;
        g.Transform(legendX, legendY, leftSide ? -Math.PI / 2 : Math.PI / 2);
        g.DrawStringPF(axis.legend.title, axis.legend.font, axis.legend.font.brush, new Point(0, 0), format2);
        g.ResetTransform();
      }
      UnitWidth += size.height;
    }
    axis.innerWidth = (UnitWidth >> 0) + 10;
    return axis.innerWidth;
  }
  DrawMonitorXAxis(w, g, xRange, format) {
    let delta = xRange.Max - xRange.Min;
    let scale = TimeConverter.BestTimeformat(delta, delta, this.xAxis.timeReference);
    let XZoom = delta / (w.Width - w.Lmargin - w.Rmargin);
    let stepCount = (delta / scale.step >> 0) + 2;
    let FirstStep = scale.step * Math.floor(xRange.Min / scale.step);
    if (FirstStep < xRange.Min)
      FirstStep += scale.step;
    g.TextRenderingHint = YTextRenderingHint.AntiAlias;
    let y = w.Height - w.Bmargin;
    g.DrawLineXY(this._navigator.pen, w.Lmargin, w.Height - w.Bmargin - 1, w.Width - w.Rmargin, w.Height - w.Bmargin - 1);
    let label;
    let t = FirstStep;
    do {
      let d = TimeConverter.FromUnixTime(t);
      if (scale.step > 31.1 * 86400) {
        t = TimeConverter.ToUnixTime(new Date(d.getFullYear(), d.getMonth(), 1));
      }
      if (t >= xRange.Min) {
        let x = w.Lmargin + Math.round((t - xRange.Min) / XZoom);
        g.DrawLineXY(this._navigator.pen, x, y, x, y - 4);
        if (format == XAxis.FORMATAUTO) {
          label = TimeConverter.FromUnixTime(t).ToString(scale.format);
        } else {
          label = TimeConverter.FromUnixTime(t).ToString(format);
        }
        let ssize = g.MeasureString(label, this._navigator.font, 1e5);
        g.DrawString(label, this._navigator.font, this._navigator.font.brush, new Point(x - ssize.width / 2, y - ssize.height - 1));
      }
      t += scale.step;
    } while (t < xRange.Max);
  }
  static XLabel(t, scale, scaleFormat, timeRange) {
    let label;
    if (scale.timeReference == TimeConverter.TimeReference.ABSOLUTE) {
      if (scale.labelFormat == XAxis.FORMATAUTO) {
        label = TimeConverter.FromUnixTime(t).ToString(scaleFormat.format);
      } else {
        label = t.toString();
      }
    } else {
      let ticks = YTimeSpan.TicksPerSecond * (Math.round(1e3 * (t - scale.zeroTime)) / 1e3);
      label = ticks < 0 ? "-" + new YTimeSpan(-ticks).toString(scaleFormat.format) : new YTimeSpan(ticks).toString(scaleFormat.format);
    }
    return label;
  }
  DrawXAxis(w, g, scale, simulation) {
    if (w.Width - w.Rmargin - w.Lmargin < 10)
      return 1;
    let stringFormat = new YStringFormat(16384);
    stringFormat.Alignment = 1;
    let bottomSide = scale.position == XAxis.VrtPosition.BOTTOM;
    let y = bottomSide ? w.Height - w.Bmargin : w.Tmargin;
    if (!simulation)
      g.DrawLineXY(scale.pen, w.Lmargin, y, w.Width - w.Rmargin, y);
    let delta = scale.max - scale.min;
    let XZoom = delta / (w.Width - w.Lmargin - w.Rmargin);
    let stepCount = (delta / scale.step >> 0) + 1;
    let FirstStep = 0;
    let timeRange = MinMaxHandler.DefaultValue();
    for (let i = 0; i < this._series.length; i++) {
      if (!this._series[i].disabled) {
        timeRange = MinMaxHandler.Combine(timeRange, this._series[i].timeRange);
      }
    }
    scale.zeroTime = timeRange.Min;
    if (scale.timeReference == TimeConverter.TimeReference.ABSOLUTE) {
      FirstStep = scale.step * Math.floor(scale.min / scale.step);
      timeRange.Min = scale.min;
      timeRange.Max = scale.max;
    } else {
      if (Number.isNaN(timeRange.Min))
        return 0;
      FirstStep = timeRange.Min + scale.step * Math.floor((scale.min - scale.zeroTime) / scale.step);
    }
    if (FirstStep < scale.min)
      FirstStep += scale.step;
    let timeOffset = 0;
    if (scale.timeReference != TimeConverter.TimeReference.ABSOLUTE) {
      timeOffset = FirstStep;
    }
    scale.fullSize = timeRange.Max - timeRange.Min;
    let scaleFormat = scale.bestFormat(timeRange.Max - timeRange.Min, scale.max - scale.min);
    if (!simulation)
      g.TextRenderingHint = YTextRenderingHint.AntiAlias;
    let UnitHeight = 0;
    let label;
    scale.step = scaleFormat.step;
    let t = parseFloat(FirstStep.toString());
    label = YGraph.XLabel(t, scale, scaleFormat, timeRange);
    let ssize = g.MeasureString(label, scale.font, 1e5);
    let mod = 1;
    while (mod * (w.Width - w.Rmargin - w.Lmargin) / stepCount < ssize.width) {
      mod++;
    }
    let steps = Math.round((t - timeOffset) / scale.step) >> 0;
    let previousT = 0;
    do {
      let d = TimeConverter.FromUnixTime(t);
      if (scale.step > 32 * 86400 && scale.timeReference == TimeConverter.TimeReference.ABSOLUTE) {
        if (scale.step >= 365 * 86400) {
          let m = d.getMonth();
          t = TimeConverter.ToUnixTime(new Date(d.getFullYear() + (m > 5 ? 1 : 0), 0, 1));
        } else
          t = TimeConverter.ToUnixTime(new Date(d.getFullYear(), d.getMonth(), 1));
        if (t < previousT) {
          debugger;
        }
      }
      if (t >= scale.min) {
        let x = w.Lmargin + Math.round((t - scale.min) / XZoom) >> 0;
        if (x <= w.Width - w.Rmargin) {
          if (!simulation) {
            if (scale.showGrid)
              g.DrawLineXY(scale.gridPen, x, w.Tmargin, x, w.Height - w.Bmargin);
            g.DrawLineXY(scale.pen, x, y + (bottomSide ? 2 : -2), x, y + (bottomSide ? -5 : 5));
          }
          label = YGraph.XLabel(t, scale, scaleFormat, timeRange);
          ssize = g.MeasureString(label, scale.font, 1e5);
          if (ssize.height > UnitHeight)
            UnitHeight = ssize.height;
          if (!simulation) {
            if (steps % mod == 0) {
              g.DrawStringPF(label, scale.font, scale.font.brush, new PointF(x, y + (bottomSide ? 5 : -ssize.height >> 0) - 2), stringFormat);
            }
          }
        }
      }
      previousT = t;
      t += scale.step;
      if (t < previousT)
        debugger;
      steps++;
    } while (t <= scale.max);
    if (scale.legend.title != "") {
      let size = g.MeasureString(scale.legend.title, scale.legend.font, 1e5);
      if (!simulation) {
        let legendX = w.Lmargin + (w.Width - w.Lmargin - w.Rmargin - size.width) / 2 >> 0;
        let legendY = bottomSide ? w.Height - w.Bmargin + UnitHeight + 5 : w.Tmargin - UnitHeight - size.height * 1.5;
        g.DrawString(scale.legend.title, scale.legend.font, scale.legend.font.brush, new PointF(legendX, legendY));
      }
      UnitHeight += size.height >> 0;
    }
    scale.innerHeight = (UnitHeight >> 0) + 10;
    return scale.innerHeight;
  }
  pixelxSize(mainViewPort, scaleX) {
    let dtime = scaleX.max - scaleX.min;
    let dview = mainViewPort.Width - mainViewPort.Lmargin - mainViewPort.Rmargin;
    if (dview > 0)
      return dtime / dview;
    return 0;
  }
  TimeToAutoSting(t, mainViewPort, scaleX) {
    let strValue = "";
    let dtime = scaleX.max - scaleX.min;
    let months = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
    if (dtime > 0) {
      let pixelSize = this.pixelxSize(mainViewPort, scaleX);
      if (pixelSize > 0) {
        if (scaleX.timeReference == TimeConverter.TimeReference.ABSOLUTE) {
          let date = TimeConverter.FromUnixTime(t);
          let MMMM = months[date.getMonth()];
          let dd = date.getDate().toString();
          let HH = date.getHours().toString();
          if (HH.length < 2)
            HH = "0" + HH;
          let mm = date.getMinutes().toString();
          if (mm.length < 2)
            mm = "0" + mm;
          let ss = date.getSeconds().toString();
          if (ss.length < 2)
            ss = "0" + ss;
          let ff = Math.round(date.getMilliseconds() / 10).toString();
          if (ff.length < 2)
            ff = "0" + ss;
          let f = Math.round(date.getMilliseconds() / 100).toString();
          if (dtime >= 86400)
            strValue += MMMM + " " + dd;
          if (pixelSize < 0.1) {
            strValue += (strValue != "" ? " " : "") + HH + ":" + mm + ":" + ss + "." + ff;
          } else if (pixelSize < 1) {
            strValue += (strValue != "" ? " " : "") + HH + ":" + mm + ":" + ss + "." + f;
          } else if (pixelSize < 60) {
            strValue += (strValue != "" ? " " : "") + HH + ":" + mm + ":" + ss;
          } else if (pixelSize < 3600) {
            strValue += (strValue != "" ? " " : "") + HH + ":" + mm;
          } else if (pixelSize < 86400)
            strValue += (strValue != "" ? " " : "") + HH + "H";
        } else {
          let format = TimeConverter.RelativeFormat(scaleX.fullSize, dtime, pixelSize);
          let ticks = YTimeSpan.TicksPerSecond * (Math.round(100 * (t - scaleX.zeroTime)) / 100);
          strValue += ticks < 0 ? "-" + new YTimeSpan(-ticks).toString(format) : new YTimeSpan(ticks).toString(format);
        }
      }
    }
    return strValue;
  }
  DrawDataTracker(g, viewPortWidth, viewPortHeight, scaleX) {
    if (!this._dataTracker.enabled) {
      return;
    }
    let p = this.mouseLocalPosition();
    if (p == null) {
      return;
    }
    if (p.X <= this.mainViewPort.Lmargin) {
      return;
    }
    if (p.Y <= this.mainViewPort.Tmargin) {
      return;
    }
    if (p.X >= this.UIContainer.width - this.mainViewPort.Rmargin) {
      return;
    }
    if (p.Y >= this.UIContainer.height - this.mainViewPort.Bmargin) {
      return;
    }
    g.SetClip(new YRectangle(0, 0, viewPortWidth, viewPortHeight));
    let DataPoint = YGraph.ViewPortPointToIRL(this.mainViewPort, p);
    let delta = -1;
    let bestindex = -1;
    let bestmatch = new Array(this._series.length);
    let IRLmatch = new Array(this._series.length);
    for (let i = 0; i < this._series.length; i++) {
      if (this._series[i].visible && !this._series[i].disabled) {
        let p2 = this._series[i].findClosestValue(DataPoint.x, false);
        if (p2 != null) {
          IRLmatch[i] = p2;
          bestmatch[i] = YGraph.IRLPointToViewPort(this.mainViewPort, IRLmatch[i], this.yAxes[this._series[i].yAxisIndex].IRLy, this.yAxes[this._series[i].yAxisIndex].zoom);
          if (bestindex < 0 || delta > Math.abs(bestmatch[i].Y - p.Y)) {
            delta = Math.abs(bestmatch[i].Y - p.Y);
            if (this._dataTracker.detectionDistance == 0 || delta <= this._dataTracker.detectionDistance && Math.abs(bestmatch[i].X - p.X) < this._dataTracker.detectionDistance) {
              bestindex = i;
            }
          }
        }
      }
    }
    if (bestindex >= 0) {
      let xx = bestmatch[bestindex].X - this._dataTracker.diameter / 2 >> 0;
      let yy = bestmatch[bestindex].Y - this._dataTracker.diameter / 2 >> 0;
      let dd = this._dataTracker.diameter;
      g.FillEllipse(this._series[bestindex].brush, xx, yy, dd, dd);
      g.DrawEllipse(this._dataTracker.pen, xx, yy, dd, dd);
      let dx;
      let dy;
      if (p.X > this.mainViewPort.Lmargin + (viewPortWidth - this.mainViewPort.Lmargin - this.mainViewPort.Rmargin) / 2)
        dx = -1;
      else
        dx = 1;
      if (p.Y > this.mainViewPort.Tmargin + (viewPortHeight - this.mainViewPort.Tmargin - this.mainViewPort.Bmargin) / 2)
        dy = -1;
      else
        dy = 1;
      let xx2 = bestmatch[bestindex].X + dx * (this._dataTracker.handleLength * 1.5) >> 0;
      let yy2 = bestmatch[bestindex].Y + dy * this._dataTracker.handleLength >> 0;
      g.DrawLineXY(this._dataTracker.pen, bestmatch[bestindex].X + dx * 0.707 * this._dataTracker.diameter / 2 >> 0, bestmatch[bestindex].Y + dy * 0.707 * this._dataTracker.diameter / 2 >> 0, bestmatch[bestindex].X + dx * this._dataTracker.handleLength >> 0, bestmatch[bestindex].Y + dy * this._dataTracker.handleLength >> 0);
      g.DrawLineXY(this._dataTracker.pen, bestmatch[bestindex].X + dx * this._dataTracker.handleLength >> 0, bestmatch[bestindex].Y + dy * this._dataTracker.handleLength >> 0, xx2, yy2);
      let strValue = "";
      if (this._dataTracker.showSerieName)
        strValue += this._series[bestindex].legend + "\r\n";
      if (this._dataTracker.showTimeStamp) {
        let t = IRLmatch[bestindex].x;
        strValue += this.TimeToAutoSting(t, this.mainViewPort, scaleX) + "\r\n";
      }
      if (this._dataTracker.dataPrecision.toString == DataTracker.DataPrecision.PRECISION_NOLIMIT.toString) {
        strValue += IRLmatch[bestindex].y.toString() + this._series[bestindex].unit;
      } else {
        let strvalue = this._dataTracker.dataPrecision.description;
        let precision = -Math.log10(Number(strvalue));
        strValue += IRLmatch[bestindex].y.toFixed(precision) + this._series[bestindex].unit;
      }
      let ssize = g.MeasureString(strValue, this._dataTracker.font, 1e4);
      let labelwidth = ssize.width + 2 * this._dataTracker.padding + this._dataTracker.borderthickness;
      let labelHeight = ssize.height + 2 * this._dataTracker.padding + this._dataTracker.borderthickness;
      if (dx > 0) {
        g.FillRectangleXYHW(this._dataTracker.bgBrush, xx2, yy2 - (labelHeight >> 1), labelwidth, labelHeight);
        g.DrawRectangleXYHW(this._dataTracker.pen, xx2, yy2 - (labelHeight >> 1), labelwidth, labelHeight);
        g.DrawStringXY(strValue, this._dataTracker.font, this._dataTracker.font.brush, xx2 + this._dataTracker.padding >> 0, yy2 - (labelHeight >> 1) + this._dataTracker.padding >> 0);
      } else {
        g.FillRectangleXYHW(this._dataTracker.bgBrush, xx2 - labelwidth, yy2 - (labelHeight >> 1), labelwidth, labelHeight);
        g.DrawRectangleXYHW(this._dataTracker.pen, xx2 - labelwidth, yy2 - (labelHeight >> 1), labelwidth, labelHeight);
        g.DrawStringXY(strValue, this._dataTracker.font, this.dataTracker.font.brush, xx2 + this._dataTracker.padding - labelwidth >> 0, yy2 - (labelHeight >> 1) + this._dataTracker.padding >> 0);
      }
    }
  }
  DrawMarkers(w, g, scaleX, viewPortWidth, viewPortHeight) {
    if (this._xAxis.markers.length == 0)
      return;
    g.SetClip(new YRectangle(w.Lmargin, w.Tmargin, w.Width - w.Rmargin - w.Lmargin, w.Height - w.Bmargin - w.Tmargin));
    let Bottomleft = YGraph.ViewPortPointToIRL(w, new Point(w.Lmargin, w.Height - w.Bmargin));
    let TopRight = YGraph.ViewPortPointToIRL(w, new Point(w.Width - w.Rmargin, w.Tmargin));
    let dy = (w.Height - w.Bmargin - w.Tmargin) / 100;
    let pixelSize = -1;
    g.TextRenderingHint = YTextRenderingHint.AntiAlias;
    for (let i = 0; i < this._xAxis.markers.length; i++) {
      if (this._xAxis.markers[i].enabled) {
        if (pixelSize < 0)
          pixelSize = this.pixelxSize(this.mainViewPort, scaleX);
        let mustdraw = true;
        let xpos = 0;
        if (this._xAxis.markers[i].timereference == TimeConverter.TimeReference.RELATIVE) {
          if (this._xAxis.zeroTime > 0) {
            xpos = this._xAxis.markers[i].xposition + this._xAxis.zeroTime;
          } else {
            mustdraw = false;
          }
        } else {
          xpos = this._xAxis.markers[i].xposition;
        }
        if (xpos > Bottomleft.x - 100 * pixelSize && xpos < TopRight.x + 100 * pixelSize && mustdraw) {
          let p = YGraph.IRLPointToViewPort(w, new pointXY(xpos, 0));
          let xxCenter = p.X >> 0;
          let yyCenter = w.Height - w.Bmargin - this._xAxis.markers[i].yposition * dy >> 0;
          let strValue = this._xAxis.markers[i].text.replace("\\n", "\n");
          let now = new Date();
          if (strValue.indexOf("$") >= 0) {
            if (strValue.indexOf("$MARKERTIME$") >= 0) {
              let s = this._xAxis.markers[i].timereference == TimeConverter.TimeReference.RELATIVE ? TimeConverter.secTimeSpanToString(this._xAxis.markers[i].xposition, pixelSize) : this.TimeToAutoSting(this._xAxis.markers[i].xposition, this.mainViewPort, scaleX);
              strValue = strValue.replace("$MARKERTIME$", s);
            }
            if (strValue.indexOf("$VALUE") >= 0) {
              for (let j = 0; j < this._series.length; j++) {
                if (!this._series[j].disabled) {
                  let pt = this._series[j].findClosestValue(xpos, true);
                  let st = pt != null ? pt.y.toFixed(0) : "--";
                  strValue = strValue.replace("$VALUE" + (j + 1).toString() + "$", st);
                } else {
                  strValue = strValue.replace("$VALUE" + (j + 1).toString() + "$", "");
                }
              }
            }
            if (strValue.indexOf("$UNIT") >= 0) {
              for (let j = 0; j < this._series.length; j++) {
                if (!this._series[j].disabled) {
                  strValue = strValue.replace("$UNIT" + (j + 1).toString() + "$", this._series[j].unit);
                } else {
                  strValue = strValue.replace("$UNIT" + (j + 1).toString() + "$", "");
                }
              }
            }
            if (strValue.indexOf("$LEGEND") >= 0) {
              for (let j = 0; j < this._series.length; j++) {
                if (!this._series[j].disabled) {
                  strValue = strValue.replace("$LEGEND" + (j + 1).toString() + "$", this._series[j].legend);
                } else {
                  strValue = strValue.replace("$LEGEND" + (j + 1).toString() + "$", "");
                }
              }
            }
            if (this._xAxis.markers[i].PatchTextCallback != null) {
              strValue = this._xAxis.markers[i].PatchTextCallback(strValue);
            }
          }
          let ssize = g.MeasureString(strValue, this._xAxis.markers[i].font, 1e4);
          let labelWidth = ssize.width + 2 * this._xAxis.markers[i].padding + this._xAxis.markers[i].borderthickness;
          let labelHeight = ssize.height + 2 * this._xAxis.markers[i].padding + this._xAxis.markers[i].borderthickness;
          g.FillRectangleXYHW(this._xAxis.markers[i].bgBrush, xxCenter - (labelWidth >> 1), yyCenter - (labelHeight >> 1), labelWidth >> 0, labelHeight >> 0);
          g.DrawRectangleXYHW(this._xAxis.markers[i].pen, xxCenter - (labelWidth >> 1), yyCenter - (labelHeight >> 1), labelWidth >> 0, labelHeight >> 0);
          let xText;
          switch (this._xAxis.markers[i].textAlign) {
            case Marker.TextAlign.LEFT:
              xText = xxCenter - (labelWidth >> 1) + this._xAxis.markers[i].padding;
              break;
            case Marker.TextAlign.RIGHT:
              xText = xxCenter + (labelWidth >> 1) - this._xAxis.markers[i].padding;
              break;
            default:
              xText = xxCenter;
              break;
          }
          g.DrawStringPF(strValue, this._xAxis.markers[i].font, this._xAxis.markers[i].font.brush, new PointF(xText, yyCenter), this._xAxis.markers[i].stringFormat);
          g.DrawLineXY(this._xAxis.markers[i].pen, xxCenter, w.Tmargin >> 0, xxCenter, yyCenter - (labelHeight >> 1));
          g.DrawLineXY(this._xAxis.markers[i].pen, xxCenter, yyCenter + (labelHeight >> 1), xxCenter, w.Height - w.Bmargin >> 0);
          if (this._xAxis.markers[i].arrowSize > 0) {
            if (this._xAxis.markers[i].yposition > 25) {
              let triangle = [
                new PointF(xxCenter - this._xAxis.markers[i].arrowSize, yyCenter + (labelHeight >> 1)),
                new PointF(xxCenter + this._xAxis.markers[i].arrowSize, yyCenter + (labelHeight >> 1)),
                new PointF(xxCenter, yyCenter + (labelHeight >> 1) + this._xAxis.markers[i].arrowSize)
              ];
              g.FillPolygon(this._xAxis.markers[i].arrowBrush, triangle);
            }
            if (this._xAxis.markers[i].yposition < 75) {
              let triangle = [
                new PointF(xxCenter - this._xAxis.markers[i].arrowSize, yyCenter + (labelHeight >> 1)),
                new PointF(xxCenter + this._xAxis.markers[i].arrowSize, yyCenter + (labelHeight >> 1)),
                new PointF(xxCenter, yyCenter - (labelHeight >> 1) - this._xAxis.markers[i].arrowSize)
              ];
              g.FillPolygon(this._xAxis.markers[i].arrowBrush, triangle);
            }
          }
        }
      }
    }
    g.ResetClip();
  }
  DrawDataPanels(w, g, scaleX, scalesY, viewPortWidth, viewPortHeight) {
    if (this._dataPanels.length == 0)
      return;
    g.SetClip(new YRectangle(w.Lmargin, w.Tmargin, w.Width - w.Rmargin - w.Lmargin, w.Height - w.Bmargin - w.Tmargin));
    for (let i = 0; i < this._dataPanels.length; i++) {
      if (this._dataPanels[i].enabled) {
        let p = this._dataPanels[i];
        if (p.yScaleIndex < scalesY.length) {
          let AvailableWidth = w.Width - 2 * p.padding - p.borderthickness;
          if (AvailableWidth < 100)
            AvailableWidth = 100;
          let ssize = g.MeasureString(p.text, p.font, AvailableWidth >> 0);
          let panelWidth = ssize.width + 2 * p.padding + p.borderthickness;
          let panelHeight = ssize.height + 2 * p.padding + p.borderthickness;
          let x = 0;
          switch (p.horizontalPosition) {
            case DataPanel.HorizontalPosition.LEFTBORDER:
              x = w.Lmargin;
              break;
            case DataPanel.HorizontalPosition.RIGHTBORDER:
              x = w.Width - w.Rmargin;
              break;
            case DataPanel.HorizontalPosition.ABSOLUTEX:
              let delta = scaleX.max - scaleX.min;
              let XZoom = delta / (w.Width - w.Lmargin - w.Rmargin);
              x = w.Lmargin + Math.round((p.AbsoluteXposition - scaleX.min) / XZoom) >> 0;
              break;
          }
          let y = 0;
          switch (p.verticalPosition) {
            case DataPanel.VerticalPosition.TOPBORDER:
              y = w.Tmargin;
              break;
            case DataPanel.VerticalPosition.BOTTOMBORDER:
              y = w.Height - w.Bmargin;
              break;
            case DataPanel.VerticalPosition.ABSOLUTEY:
              y = w.Height - w.Bmargin - Math.round((p.AbsoluteYposition - scalesY[p.yScaleIndex].IRLy) * scalesY[p.yScaleIndex].zoom) >> 0;
              break;
          }
          switch (p.panelHrzAlign) {
            case DataPanel.HorizontalAlign.LEFTOF:
              x -= panelWidth + p.horizontalMargin;
              break;
            case DataPanel.HorizontalAlign.RIGHTOF:
              x += p.horizontalMargin;
              break;
            default:
              x -= panelWidth / 2;
              break;
          }
          switch (p.panelVrtAlign) {
            case DataPanel.VerticalAlign.ABOVE:
              y -= panelHeight + p.verticalMargin;
              break;
            case DataPanel.VerticalAlign.BELOW:
              y += p.verticalMargin;
              break;
            default:
              y -= panelHeight / 2;
              break;
          }
          g.FillRectangleXYHW(p.bgBrush, x >> 0, y >> 0, panelWidth >> 0, panelHeight >> 0);
          if (p.borderthickness > 0)
            g.DrawRectangleXYHW(p.pen, x >> 0, y >> 0, panelWidth >> 0, panelHeight >> 0);
          let sf = new YStringFormat(16384);
          switch (p.panelTextAlign) {
            case MessagePanel.TextAlign.LEFT:
              sf.LineAlignment = 0;
              sf.Alignment = 0;
              break;
            case MessagePanel.TextAlign.RIGHT:
              sf.LineAlignment = 2;
              sf.Alignment = 2;
              break;
            default:
              sf.LineAlignment = 1;
              sf.Alignment = 1;
              break;
          }
          let rect = new YRectangle(x + p.padding + p.borderthickness / 2 >> 0, y + p.padding + p.borderthickness / 2 >> 0, ssize.width >>= 1, (ssize.height >> 0) + 1);
          g.DrawStringRect(p.text, p.font, p.font.brush, rect, sf);
        } else {
          throw new RangeError("Cannot renderer data panel #" + i.toString() + ", no such Y axis");
        }
      }
    }
  }
  findSegmentIndex(serieIndex, timeStamp, debug) {
    let s = this._series[serieIndex];
    if (s.segments.length <= 0)
      return -1;
    let start = 0;
    let end = s.segments.length - 1;
    if (debug) {
      console.log("looking for " + timeStamp);
      for (let i = 0; i < s.segments.length; i++)
        console.log("seg " + i + " [" + s.segments[i].data[0].x + ".." + s.segments[i].data[s.segments[i].count - 1].x + "]");
      debugger;
    }
    while (true) {
      let startSeg = s.segments[start];
      let endSeg = s.segments[end];
      if (timeStamp > startSeg.data[startSeg.count - 1].x)
        return start - 0.5;
      if (timeStamp < endSeg.data[0].x)
        return end + 0.5;
      if (timeStamp >= startSeg.data[0].x)
        return start;
      if (timeStamp <= endSeg.data[endSeg.count - 1].x)
        return end;
      if (end == start) {
        debugger;
        return -99;
      }
      if (end - start == 1)
        return start + 0.5;
      let middle = start + end >> 1;
      let middleSeg = s.segments[middle];
      if (timeStamp <= middleSeg.data[middleSeg.count - 1].x) {
        end = end - 1;
        start = middle;
      } else {
        end = middle - 1;
        start = start + 1;
      }
    }
  }
  findTimestampIndexInSegment(serieIndex, segmentIndex, timeStamp) {
    let seg = this._series[serieIndex].segments[segmentIndex];
    if (!seg)
      debugger;
    if (timeStamp <= seg.data[0].x)
      return 0;
    let count = this._series[serieIndex].segments[segmentIndex].count;
    if (timeStamp >= seg.data[count - 1].x)
      return count - 1;
    let start = 0;
    let end = count - 1;
    let middle = 0;
    while (true) {
      if (end - start <= 1) {
        if (timeStamp <= seg.data[start].x)
          return start;
        return end;
      }
      middle = start + end >> 1;
      if (timeStamp <= seg.data[middle].x)
        end = middle;
      else
        start = middle;
    }
  }
  Render(g, UIw, UIh) {
    if (UIw < 50 || UIh < 50)
      return 0;
    let lastLmargin = this.mainViewPort.Lmargin;
    let lastRmargin = this.mainViewPort.Rmargin;
    this.mainViewPort.Width = UIw;
    this.mainViewPort.Height = UIh;
    this.mainViewPort.Lmargin = 0;
    this.mainViewPort.Rmargin = 0;
    g.SmoothingMode = YSmoothingMode.HighQuality;
    let yMarginOffset = 5;
    for (let i = 0; i < this._yAxes.length; i++) {
      if (this._yAxes[i].visible) {
        let s = g.MeasureString("8", this._yAxes[i].font, 1e5);
        let o = (s.height + 1) / 2 >> 0;
        if (yMarginOffset < o)
          yMarginOffset = o;
      }
    }
    this.mainViewPort.Tmargin = this._xAxis.position == XAxis.VrtPosition.TOP ? 0 : yMarginOffset;
    this.mainViewPort.Bmargin = this._xAxis.position == XAxis.VrtPosition.BOTTOM ? 0 : yMarginOffset;
    if (!this._legendPanel.overlap)
      this.drawLegendPanel(g, UIw, UIh, this.mainViewPort);
    this.drawAnnotationPanels(g, this._annotationPanels, UIw, UIh, false, this.mainViewPort);
    if (this.mainViewPort.Bmargin == 0)
      this.mainViewPort.Bmargin = 5;
    if (this.mainViewPort.Tmargin == 0)
      this.mainViewPort.Tmargin = 5;
    let h = this.DrawXAxis(this.mainViewPort, g, this._xAxis, true);
    if (this._xAxis.position == XAxis.VrtPosition.TOP)
      this.mainViewPort.Tmargin += h;
    else
      this.mainViewPort.Bmargin += h;
    this.mainViewPort.IRLx = this._xAxis.min;
    let M;
    for (let i = 0; i < this._yAxes.length; i++) {
      M = MinMaxHandler.DefaultValue();
      for (let k = 0; k < this._series.length; k++) {
        if (this._series[k].yAxisIndex == i && !this._series[k].disabled) {
          for (let j = 0; j < this._series[k].segments.length; j++) {
            M = MinMaxHandler.Combine(M, YGraph.FindMinMax(this._xAxis.min, this._xAxis.max, this._series[k].segments[j].data, this._series[k].segments[j].count));
          }
        }
      }
      this._yAxes[i].computeStartAndStep(M);
    }
    if (this.mainViewPort.Lmargin == 0)
      this.mainViewPort.Lmargin = 5;
    if (this.mainViewPort.Rmargin == 0)
      this.mainViewPort.Rmargin = 5;
    for (let i = 0; i < this._yAxes.length; i++) {
      let sw = YGraph.DrawYAxis(this.mainViewPort, g, this._yAxes[i], 0, true);
      this.mainViewPort.Lmargin += this._yAxes[i].position == YAxis.HrzPosition.LEFT ? sw : 0;
      this.mainViewPort.Rmargin += this._yAxes[i].position == YAxis.HrzPosition.RIGHT ? sw : 0;
    }
    if (this._navigator.enabled) {
      if (lastLmargin != this.mainViewPort.Lmargin || lastRmargin != this.mainViewPort.Rmargin) {
        this.navigatorCache = null;
      }
      let nh = this._navigator.relativeheight * this.UIContainer.height / 100 >> 0;
      let ofset = this.xAxis.position == XAxis.VrtPosition.BOTTOM ? h : 0;
      this._navigator.setPosition(UIw, UIh, this.mainViewPort.Lmargin, this.mainViewPort.Rmargin, this.mainViewPort.Height - nh - this.mainViewPort.Bmargin + ofset, this.mainViewPort.Bmargin - ofset);
      this.mainViewPort.Bmargin += nh;
    }
    if (this.lastTopMargin != this.mainViewPort.Tmargin || this.lastBottomMargin != this.mainViewPort.Bmargin) {
      this._bgBrush = null;
      this.lastTopMargin = this.mainViewPort.Tmargin;
      this.lastBottomMargin = this.mainViewPort.Bmargin;
    }
    if (this._bgBrush == null) {
      this._bgBrush = new YLinearGradientBrush(this._bgColor2, this._bgColor1);
    }
    g.FillRectangleXYHW(this._bgBrush, this.mainViewPort.Lmargin, this.mainViewPort.Tmargin, this.mainViewPort.Width - this.mainViewPort.Rmargin - this.mainViewPort.Lmargin, this.mainViewPort.Height - this.mainViewPort.Bmargin - this.mainViewPort.Tmargin);
    if (this._borderThickness > 0) {
      if (this._borderPen == null)
        this._borderPen = new YPen(this._borderColor, this._borderThickness);
      g.DrawRectangleXYHW(this._borderPen, this.mainViewPort.Lmargin, this.mainViewPort.Tmargin, this.mainViewPort.Width - this.mainViewPort.Rmargin - this.mainViewPort.Lmargin, this.mainViewPort.Height - this.mainViewPort.Bmargin - this.mainViewPort.Tmargin);
    }
    g.SetClip(new YRectangle(this.mainViewPort.Lmargin, this.mainViewPort.Tmargin, this.mainViewPort.Width - this.mainViewPort.Rmargin - this.mainViewPort.Lmargin, this.mainViewPort.Height - this.mainViewPort.Bmargin - this.mainViewPort.Tmargin));
    for (let i = 0; i < this._yAxes.length; i++) {
      this.DrawYAxisZones(this.mainViewPort, g, this._yAxes[i]);
    }
    this.DrawXAxisZones(this.mainViewPort, g, this.xAxis);
    g.ResetClip();
    this.DrawXAxis(this.mainViewPort, g, this._xAxis, false);
    let leftOffset = 0;
    let rightOffset = 0;
    for (let i = 0; i < this._yAxes.length; i++) {
      let ww = YGraph.DrawYAxis(this.mainViewPort, g, this._yAxes[i], this._yAxes[i].position == YAxis.HrzPosition.LEFT ? leftOffset : rightOffset, false);
      if (this._yAxes[i].position == YAxis.HrzPosition.LEFT)
        leftOffset += ww;
      if (this._yAxes[i].position == YAxis.HrzPosition.RIGHT)
        rightOffset += ww;
    }
    g.SetClip(new YRectangle(this.mainViewPort.Lmargin, this.mainViewPort.Tmargin, this.mainViewPort.Width - this.mainViewPort.Rmargin - this.mainViewPort.Lmargin, this.mainViewPort.Height - this.mainViewPort.Bmargin - this.mainViewPort.Tmargin));
    this.mainViewPort.zoomx = (this.mainViewPort.Width - this.mainViewPort.Lmargin - this.mainViewPort.Rmargin) / (this._xAxis.max - this._xAxis.min);
    let mypenb = null;
    let lineCount = 0;
    let pointCount = 0;
    let Bottomleft = YGraph.ViewPortPointToIRL(this.mainViewPort, new Point(this.mainViewPort.Lmargin, this.mainViewPort.Height - this.mainViewPort.Bmargin));
    let TopRight = YGraph.ViewPortPointToIRL(this.mainViewPort, new Point(this.mainViewPort.Width - this.mainViewPort.Rmargin, this.mainViewPort.Tmargin));
    let xTimeStart = Bottomleft.x;
    let xTimeEnd = TopRight.x;
    let availabelPixelWidth = this.mainViewPort.Width - this.mainViewPort.Rmargin - this.mainViewPort.Lmargin;
    for (let k = 0; k < this._series.length; k++) {
      if (this._series[k].visible && !this._series[k].disabled && this._series[k].segments.length > 0) {
        let scaleIndex = this._series[k].yAxisIndex;
        mypenb = this._series[k].pen;
        this.mainViewPort.IRLy = this._yAxes[scaleIndex].startStopStep.dataMin;
        this._yAxes[this._series[k].yAxisIndex].IRLy = this.mainViewPort.IRLy;
        let delta = this._yAxes[scaleIndex].startStopStep.dataMax - this._yAxes[scaleIndex].startStopStep.dataMin;
        if (delta == 0) {
          delta = 1;
          this.mainViewPort.IRLy -= delta / 2;
        }
        this.mainViewPort.zoomy = (this.mainViewPort.Height - this.mainViewPort.Tmargin - this.mainViewPort.Bmargin) / delta;
        this._yAxes[this._series[k].yAxisIndex].zoom = this.mainViewPort.zoomy;
        g.comment("** main view-port series " + k.toString());
        let FirstSegmentIndexTmp = this.findSegmentIndex(k, xTimeEnd, false);
        let LastSegmentIndexTmp = this.findSegmentIndex(k, xTimeStart, false);
        let inside = true;
        let maxIndex = this._series[k].segments.length - 1;
        if (FirstSegmentIndexTmp < 0 && LastSegmentIndexTmp < 0) {
          inside = false;
        }
        if (FirstSegmentIndexTmp > maxIndex && LastSegmentIndexTmp > maxIndex) {
          inside = false;
        }
        if (inside) {
          let FirstSegmentIndex = Math.floor(FirstSegmentIndexTmp + 0.5);
          let LastSegmentIndex = Math.floor(LastSegmentIndexTmp);
          if (LastSegmentIndex < 0) {
            throw new Error("findSegmentIndex return an invalid index (" + LastSegmentIndex + ")");
          }
          if (FirstSegmentIndex < 0) {
            throw new Error("findSegmentIndex return an invalid index (" + FirstSegmentIndex + ")!");
          }
          if (FirstSegmentIndex > this._series[k].segments.length - 1) {
            throw new Error("findSegmentIndex return an invalid index (" + FirstSegmentIndex + ")!!");
          }
          if (LastSegmentIndex > this._series[k].segments.length - 1) {
            throw new Error("findSegmentIndex return an invalid index (" + LastSegmentIndex + ")!!!");
          }
          let firstDataIndex = this.findTimestampIndexInSegment(k, FirstSegmentIndex, xTimeEnd);
          let lastDataIndex = this.findTimestampIndexInSegment(k, LastSegmentIndex, xTimeStart);
          let totalPointsToDraw = 0;
          if (FirstSegmentIndex == LastSegmentIndex)
            totalPointsToDraw = firstDataIndex - lastDataIndex;
          else if (FirstSegmentIndex < LastSegmentIndex) {
            totalPointsToDraw = this._series[k].segments[LastSegmentIndex].count - lastDataIndex + firstDataIndex;
            for (let i = FirstSegmentIndex + 1; i < LastSegmentIndex; i++)
              totalPointsToDraw += this._series[k].segments[i].count;
          }
          let density = Math.round(totalPointsToDraw / availabelPixelWidth);
          if (density < SUMMARY_GRANULARITY || SUMMARY_GRANULARITY <= 0) {
            for (let i = 0; i < this._series[k].segments.length; i++) {
              lineCount += YGraph.DoSegmentRendering(this.mainViewPort, g, mypenb, this._series[k].segments[i].data, this._series[k].segments[i].count, xTimeStart, xTimeEnd);
              pointCount += this._series[k].segments[i].count;
            }
          } else {
            let level = Math.floor(Math.log(density) / Math.log(SUMMARY_GRANULARITY)) - 1;
            let s = this._series[k].summaries[level];
            let finalpoint = null;
            for (let i = 0; i < s.segments.length; i++) {
              if (i == s.segments.length - 1) {
                finalpoint = s.getBufferpoint();
              }
              lineCount += YGraph.DoSummarySegmentRendering(this.mainViewPort, g, mypenb, s.segments[i].data, s.segments[i].ptCount, finalpoint, xTimeStart, xTimeEnd);
              pointCount += s.segments[i].ptCount;
            }
          }
        } else
          console.log("Data are ouside dataview");
      }
    }
    g.ResetClip();
    if (this._navigator.enabled) {
      g.comment("** navigator **");
      let v = this._navigator.viewport;
      let range = MinMaxHandler.DefaultValue();
      for (let i = 0; i < this._series.length; i++) {
        if (!this._series[i].disabled)
          range = MinMaxHandler.Combine(range, this._series[i].timeRange);
      }
      this._navigator.Xrange = MinMaxHandler.extend(range, 1.05);
      v.zoomx = (v.Width - v.Lmargin - v.Rmargin) / (this._navigator.Xrange.Max - this._navigator.Xrange.Min);
      if (this.lastPointCount != pointCount && !this.mainViewPort.Capture && !this._navigator.Capture || this.navigatorCache == null || g instanceof YGraphicsSVG) {
        g.comment("Redraw navigator");
        if (this.navigatorCache != null)
          this.navigatorCache = null;
        this.navigatorCache = document.createElement("canvas");
        this.navigatorCache.width = v.Width;
        this.navigatorCache.height = v.Height;
        this.lastPointCount = pointCount;
        let ng;
        if (g instanceof YGraphicsSVG) {
          ng = g;
        } else {
          ng = new YGraphics(this.navigatorCache, v.Width, v.Height, 90);
        }
        ng.SetClip(new YRectangle(v.Lmargin, v.Tmargin, v.Width - v.Rmargin - v.Lmargin, v.Height - v.Bmargin - v.Tmargin));
        ng.FillRectangleXYHW(this._navigator.bgBrush, v.Lmargin, v.Tmargin, v.Width - v.Rmargin - v.Lmargin, v.Height - v.Bmargin - v.Tmargin);
        if (this.xAxis.zones.length > 0 && this._navigator.showXAxisZones) {
          let delta = this._navigator.Xrange.Max - this._navigator.Xrange.Min;
          let XZoom = delta / (v.Width - v.Lmargin - v.Rmargin);
          for (let i = 0; i < this.xAxis.zones.length; i++) {
            if (this.xAxis.zones[i].visible) {
              let min = this.xAxis.zones[i].min;
              let max = this.xAxis.zones[i].max;
              if (isNaN(min))
                min = this._navigator.Xrange.Min;
              if (isNaN(max))
                max = this._navigator.Xrange.Max;
              ng.FillRectangleXYHW(this.xAxis.zones[i].zoneBrush, v.Lmargin + (min - this._navigator.Xrange.Min) / XZoom >> 0, v.Tmargin >> 0, (max - min) / XZoom >> 0, v.Height - v.Bmargin - v.Tmargin);
            }
          }
        }
        if (MinMaxHandler.isDefined(this._navigator.Xrange) && this._navigator.Xrange.Max - this._navigator.Xrange.Min > 0) {
          let Min;
          let Max;
          v.IRLx = this._navigator.Xrange.Min;
          let dontSticktoBorderZoom = 4 / (v.Height - v.Bmargin - v.Tmargin);
          let Bottomleft2 = YGraph.ViewPortPointToIRL(v, new Point(v.Lmargin, v.Height - v.Bmargin));
          let TopRight2 = YGraph.ViewPortPointToIRL(v, new Point(v.Width - v.Rmargin, v.Tmargin));
          let xTimeStart2 = Bottomleft2.x;
          let xTimeEnd2 = TopRight2.x;
          if (this._navigator.yAxisHandling == Navigator.YAxisHandling.AUTO) {
            for (let k = 0; k < this._series.length; k++) {
              if (!this._series[k].disabled) {
                ng.comment("** navigator series " + k.toString());
                v.IRLy = this._series[k].valueRange.Min;
                let yAxisIndex = this._series[k].yAxisIndex;
                mypenb = this._series[k].navigatorpen;
                Min = this._series[k].valueRange.Min;
                Max = this._series[k].valueRange.Max;
                if (Max - Min <= 0) {
                  v.IRLy = Min - 0.5;
                  Max = Min + 0.5;
                } else {
                  let delta = Max - Min;
                  Min -= delta * dontSticktoBorderZoom;
                  Max += delta * dontSticktoBorderZoom;
                }
                v.IRLy = Min;
                v.zoomy = (v.Height - v.Tmargin - v.Bmargin) / (Max - Min);
                let availableWidth = v.Width - v.Lmargin - v.Rmargin;
                let totalPoint = 0;
                for (let i = 0; i < this._series[k].segments.length; i++)
                  totalPoint += this._series[k].segments[i].count;
                let density = Math.round(totalPoint / availableWidth);
                if (density < SUMMARY_GRANULARITY || SUMMARY_GRANULARITY <= 0) {
                  for (let i = 0; i < this._series[k].segments.length; i++) {
                    lineCount += YGraph.DoSegmentRendering(v, ng, mypenb, this._series[k].segments[i].data, this._series[k].segments[i].count, xTimeStart2, xTimeEnd2);
                  }
                } else {
                  let level = Math.floor(Math.log(density) / Math.log(SUMMARY_GRANULARITY)) - 1;
                  let s = this._series[k].summaries[level];
                  let finalpoint = null;
                  for (let i = 0; i < s.segments.length; i++) {
                    if (i == s.segments.length - 1)
                      finalpoint = s.getBufferpoint();
                    lineCount += YGraph.DoSummarySegmentRendering(v, ng, mypenb, s.segments[i].data, s.segments[i].ptCount, finalpoint, xTimeStart2, xTimeEnd2);
                  }
                }
              }
            }
          } else {
            for (let i = 0; i < this._yAxes.length; i++) {
              let Yrange = MinMaxHandler.DefaultValue();
              for (let j = 0; j < this._series.length; j++) {
                if (this._series[j].yAxisIndex == i && !this._series[j].disabled) {
                  Yrange = MinMaxHandler.Combine(Yrange, this._series[j].valueRange);
                }
              }
              Yrange = MinMaxHandler.extend(Yrange, 1 + 2 * dontSticktoBorderZoom);
              Min = this._yAxes[i].min;
              if (isNaN(Min))
                Min = Yrange.Min;
              Max = this._yAxes[i].max;
              if (isNaN(Max))
                Max = Yrange.Max;
              if (Number.isNaN(Min)) {
                Min = 0;
                Max = 1;
              }
              if (Max - Min <= 0) {
                Min = Min - 0.5;
                Max = Min + 0.5;
              }
              v.IRLy = Min;
              v.zoomy = (v.Height - v.Tmargin - v.Bmargin) / (Max - Min);
              for (let j = 0; j < this._series.length; j++) {
                if (this._series[j].yAxisIndex == i && !this._series[j].disabled && this._series[j].visible) {
                  ng.comment("** navigator series " + j.toString());
                  mypenb = this._series[j].navigatorpen;
                  let availableWidth = v.Width - v.Lmargin - v.Rmargin;
                  let totalPoint = 0;
                  for (let i2 = 0; i2 < this._series[j].segments.length; i2++)
                    totalPoint += this._series[j].segments[i2].count;
                  let density = Math.round(totalPoint / availableWidth);
                  if (density < SUMMARY_GRANULARITY || SUMMARY_GRANULARITY <= 0) {
                    for (let i2 = 0; i2 < this._series[j].segments.length; i2++) {
                      lineCount += YGraph.DoSegmentRendering(v, ng, mypenb, this._series[j].segments[i2].data, this._series[j].segments[i2].count, xTimeStart2, xTimeEnd2);
                    }
                  } else {
                    let level = Math.floor(Math.log(density) / Math.log(SUMMARY_GRANULARITY)) - 1;
                    console.log("Navigator (YAXIS=INHERIT), Serie " + j + ", density is ~" + density + "pts/pixel drawing summarized data level " + level);
                    let s = this._series[j].summaries[level];
                    let finalpoint = null;
                    for (let i2 = 0; i2 < s.segments.length; i2++) {
                      if (i2 == s.segments.length - 1)
                        finalpoint = s.getBufferpoint();
                      lineCount += YGraph.DoSummarySegmentRendering(v, ng, mypenb, s.segments[i2].data, s.segments[i2].ptCount, finalpoint, xTimeStart2, xTimeEnd2);
                    }
                  }
                }
              }
            }
          }
          for (let i = 0; i < this._xAxis.markers.length; i++) {
            if (this._xAxis.markers[i].enabled) {
              let p = YGraph.IRLPointToViewPort(v, new pointXY(this._xAxis.markers[i].xposition + (this._xAxis.markers[i].timereference == TimeConverter.TimeReference.RELATIVE ? this._xAxis.zeroTime : 0), 0));
              ng.DrawLineXY(this._xAxis.markers[i].navigatorpen, p.X, v.Tmargin, p.X, v.Height - v.Bmargin);
            }
          }
          if (this._navigator.borderThickness > 0) {
            ng.DrawLineXY(this._navigator.borderPen, v.Lmargin, v.Tmargin, v.Width - v.Rmargin, v.Tmargin);
          }
          this.DrawMonitorXAxis(v, ng, this._navigator.Xrange, this.xAxis.labelFormat);
          this._navigator.setIRLPosition(v.IRLx, v.IRLy, v.zoomx, v.zoomy);
        }
        ng.ResetClip();
        if (!(g instanceof YGraphicsSVG))
          ng.Dispose();
      }
      let cacheW = v.Width - v.Rmargin - v.Lmargin + 1;
      let cacheH = v.Width - v.Rmargin - v.Lmargin + 1;
      let rectsrc = new YRectangle(v.Lmargin, v.Tmargin - 1, cacheW, cacheH);
      let rectdst = new YRectangle(v.Lmargin, v.Tmargin, cacheW, cacheH);
      g.SetClip(rectdst);
      if (!(g instanceof YGraphicsSVG)) {
        g.DrawImage(this.navigatorCache, rectsrc, rectdst, 2);
      }
      if (this._navigator.borderThickness > 0) {
        g.DrawLineXY(this._navigator.borderPen, v.Lmargin + 1, v.Tmargin, v.Lmargin + 1, v.Height - v.Bmargin - 1);
        g.DrawLineXY(this._navigator.borderPen, v.Width - v.Rmargin, v.Tmargin, v.Width - v.Rmargin, v.Height - v.Bmargin - 1);
        g.DrawLineXY(this._navigator.borderPen, v.Lmargin + 1, v.Tmargin, v.Width - v.Rmargin, v.Tmargin);
      }
      let IRLCursorStart = YGraph.ViewPortPointToIRL(this.mainViewPort, new Point(this.mainViewPort.Lmargin, 0));
      let IRLCursorEnd = YGraph.ViewPortPointToIRL(this.mainViewPort, new Point(this.mainViewPort.Width - this.mainViewPort.Rmargin, 0));
      let CursorStart = YGraph.IRLPointToViewPort(this._navigator.viewport, new pointXY(IRLCursorStart.x, 0));
      let CursorEnd = YGraph.IRLPointToViewPort(this._navigator.viewport, new pointXY(IRLCursorEnd.x, 0));
      g.FillRectangle(this._navigator.cursorBrush, new YRectangle(CursorStart.X - 1, v.Tmargin, CursorEnd.X - CursorStart.X + 2, v.Height - v.Bmargin - v.Tmargin - 1));
      g.DrawLineXY(this._navigator.cursorBorderPen, CursorStart.X - 1 >> 0, v.Tmargin >> 0, CursorStart.X - 1 >> 0, v.Height - v.Bmargin - 1);
      g.DrawLineXY(this._navigator.cursorBorderPen, CursorEnd.X + 1 >> 0, v.Tmargin >> 0, CursorEnd.X + 1 >> 0, v.Height - v.Bmargin - 1);
      g.ResetClip();
    }
    if (this._legendPanel.overlap)
      this.drawLegendPanel(g, UIw, UIh, this.mainViewPort);
    g.TextRenderingHint = YTextRenderingHint.SingleBitPerPixelGridFit;
    this.DrawMarkers(this.mainViewPort, g, this.xAxis, UIw, UIh);
    this.drawAnnotationPanels(g, this._annotationPanels, UIw, UIh, true, this.mainViewPort);
    this.DrawDataPanels(this.mainViewPort, g, this.xAxis, this._yAxes, UIw, UIh);
    this.DrawDataTracker(g, UIw, UIh, this.xAxis);
    this.DrawMessagePanels(g, UIw, UIh);
    return 0;
  }
  KeyDown(sender, e) {
    if (e.code == "ArrowLeft") {
      let delta = 0.2 * (this._xAxis.max - this._xAxis.min);
      this._xAxis.set_minMax(this._xAxis.min - delta, this._xAxis.max - delta);
      this.redraw();
    }
    if (e.code == "ArrowRight") {
      let delta = 0.2 * (this._xAxis.max - this._xAxis.min);
      this._xAxis.set_minMax(this._xAxis.min + delta, this._xAxis.max + delta);
      this.redraw();
    }
    if (e.code == "ArrowUp") {
      this.mouseWheel(new Point(this.UIContainer.width >> 1, this.UIContainer.height >> 1), 10);
    }
    if (e.code == "ArrowDown") {
      this.mouseWheel(new Point(this.UIContainer.width >> 1, this.UIContainer.height >> 1), -10);
    }
  }
  mouseWheel(pos, delta) {
    let ZoomFactor = Math.pow(1.25, delta / 120);
    let NextZoomX = this.mainViewPort.zoomx * ZoomFactor;
    if (NextZoomX > this.mainViewPort.zoomx && NextZoomX > 1e3)
      return;
    let currentRange = this._xAxis.max - this._xAxis.min;
    if (currentRange / ZoomFactor > 25 * 365 * 86400)
      return;
    this.mainViewPort.IRLx += (pos.X - this.mainViewPort.Lmargin) / this.mainViewPort.zoomx - (pos.X - this.mainViewPort.Lmargin) / NextZoomX;
    let range = this._xAxis.max - this._xAxis.min;
    this._xAxis.set_minMax(this.mainViewPort.IRLx, this.mainViewPort.IRLx + range / ZoomFactor);
    this.mainViewPort.zoomx = NextZoomX;
    this.redraw();
  }
  mouseWheelEvent(sender, e) {
    let p = this.Scr2ElmMatrix.multiplyByV(Vector3.FromXYCoord(e.pageX, e.pageY)).toPoint();
    let eX = p.X;
    let eY = p.Y;
    this.mouseWheel(new Point(eX, eY), e.deltaY > 0 ? -150 : 150);
    e.preventDefault();
  }
};
YGraph._defaultVerticalDragZoomEnabled = false;
YGraph.captureCursor = null;

// obj/full/Renderer/YSolidGauge.js
var DrawPrameters = class {
  constructor() {
    this.outerRadius = 0;
    this.innerRadius = 0;
    this.angleStart = 0;
    this.angleEnd = 0;
    this.ycenter = 0;
    this.xcenter = 0;
    this.heightTop = 0;
    this.heightBottom = 0;
    this.valueRectangle = new YRectangle(0, 0, 0, 0);
    this.valueFormat = new YStringFormat(16384);
    this.minValueRectangle = new YRectangle(0, 0, 0, 0);
    this.minValueFormat = new YStringFormat(16384);
    this.maxValueRectangle = new YRectangle(0, 0, 0, 0);
    this.maxValueFormat = new YStringFormat(16384);
    this.minValue = "";
    this.maxValue = "";
    this.value = "";
  }
};
var YSolidGauge = class extends YDataRenderer {
  constructor(UIContainer, mode, logFunction) {
    super(UIContainer, logFunction);
    this._shownValue = 0;
    this._min = 0;
    this._max = 100;
    this.SegmentMaxLength = 8;
    this.mainViewPort = new ViewPortSettings();
    this._borderpen = null;
    this._borderColor = YColor.Black;
    this._bgBrush = null;
    this._backgroundColor1 = YColor.FromArgb(255, 240, 240, 240);
    this._backgroundColor2 = YColor.FromArgb(255, 200, 200, 200);
    this._borderThickness = 5;
    this._valueFormater = null;
    this._minmaxFormater = null;
    this._thickness = 25;
    this._maxSpeed = 0.1;
    this._value = 0;
    this._color1 = YColor.Green;
    this._color2 = YColor.Red;
    this._font = null;
    this._minMaxFont = null;
    this._showMinMax = true;
    this._path = null;
    this.lastDrawParameters = new DrawPrameters();
    this._displayMode = YSolidGauge.DisplayMode.DISPLAY90;
    this._minMaxFont = new YFont(this, this, Math.min(UIContainer.width, UIContainer.height) / 15, () => {
      this.FontsizeChange(this._minMaxFont);
    });
    this._displayMode = mode;
    this._font = new YFont(this, this, Math.min(UIContainer.width, UIContainer.height) / 5, null);
    this.resizeRule = Proportional.ResizeRule.RELATIVETOBOTH;
    let g = new YGraphics(UIContainer, UIContainer.width, UIContainer.height, 90);
    let p = this.ComputeDrawParameters(g, UIContainer.width, UIContainer.height, this.mainViewPort);
    g.Dispose();
  }
  get min() {
    return this._min;
  }
  set min(value) {
    if (value >= this._max && !YDataRenderer.minMaxCheckDisabled) {
      throw new RangeError("Min cannot be greater than max (" + this._max.toString() + ")");
    }
    this._min = value;
    if (this._shownValue < this._min)
      this._shownValue = this._min;
    this.redraw();
  }
  get max() {
    return this._max;
  }
  set max(value) {
    if (value <= this._min && !YDataRenderer.minMaxCheckDisabled) {
      throw new RangeError("Max cannot be less than min (" + this._min.toString() + ")");
    }
    this._max = value;
    if (this._shownValue > this._max)
      this._shownValue = this._max;
    this.redraw();
  }
  get borderpen() {
    if (this._borderpen == null) {
      this._borderpen = new YPen(this._borderColor, this._borderThickness);
      this._borderpen.startCap = 1;
      this._borderpen.endCap = 1;
    }
    return this._borderpen;
  }
  get borderColor() {
    return this._borderColor;
  }
  set borderColor(value) {
    this._borderColor = value;
    this._borderpen = null;
    this.redraw();
  }
  get backgroundColor1() {
    return this._backgroundColor1;
  }
  set backgroundColor1(value) {
    this._backgroundColor1 = value;
    this._bgBrush = null;
    this.redraw();
  }
  get backgroundColor2() {
    return this._backgroundColor2;
  }
  set backgroundColor2(value) {
    this._backgroundColor2 = value;
    this._bgBrush = null;
    this.redraw();
  }
  get borderThickness() {
    return this._borderThickness;
  }
  set borderThickness(value) {
    if (value < 0)
      throw new RangeError("Thickness must be a positive value");
    this._borderThickness = value;
    this._borderpen = null;
    this._path = null;
    this.redraw();
  }
  get valueFormater() {
    return this._valueFormater;
  }
  set valueFormater(value) {
    this._valueFormater = value;
    this.redraw();
  }
  get minmaxFormater() {
    return this._minmaxFormater;
  }
  set minmaxFormater(value) {
    this._minmaxFormater = value;
    this.redraw();
  }
  get thickness() {
    return this._thickness;
  }
  set thickness(value) {
    if (value < 0)
      throw new RangeError("Thickness must be a positive value");
    this._thickness = Math.max(Math.min(value, 80), 1);
    this._path = null;
    this.redraw();
  }
  get maxSpeed() {
    return this._maxSpeed;
  }
  set maxSpeed(value) {
    if (value <= 0)
      throw new RangeError("Speed must be a positive value");
    this._maxSpeed = value;
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value;
    this.redraw();
  }
  get color1() {
    return this._color1;
  }
  set color1(value) {
    this._color1 = value;
    this.redraw();
  }
  get color2() {
    return this._color2;
  }
  set color2(value) {
    this._color2 = value;
    this.redraw();
  }
  get font() {
    return this._font;
  }
  get minMaxFont() {
    return this._minMaxFont;
  }
  get showMinMax() {
    return this._showMinMax;
  }
  set showMinMax(value) {
    this._showMinMax = value;
    this._path = null;
    this.redraw();
  }
  get displayMode() {
    return this._displayMode;
  }
  set displayMode(value) {
    this._displayMode = value;
    this._path = null;
    this._bgBrush = null;
    this.redraw();
  }
  FontsizeChange(source) {
    this._path = null;
  }
  clearCachedObjects() {
    this._bgBrush = null;
    this._path = null;
  }
  ComputeDrawParameters(g, UIw, UIh, mainViewPort) {
    UIw -= mainViewPort.Lmargin + mainViewPort.Rmargin;
    UIh -= mainViewPort.Tmargin + mainViewPort.Bmargin;
    let w = UIw - 5 - this._borderThickness;
    let h = UIh - 5 - this._borderThickness;
    let xcenter = UIw / 2;
    let outerRadius = 0;
    let angleStart = 0;
    let angleEnd = 0;
    let ycenter = 0;
    let ValueRectangle = new YRectangle(0, 0, 0, 0);
    let valueFormat = new YStringFormat(16384);
    let innerRadius = 0;
    let minMaxHeight = 0;
    let s1 = new YSizeF(null, "");
    let s2 = new YSizeF(null, "");
    this.lastDrawParameters.value = this._valueFormater == null ? this._value.toFixed(0) : this._valueFormater(this, this._value);
    if (this._showMinMax) {
      this.lastDrawParameters.minValue = this._minmaxFormater == null ? this._min.toFixed(0) : this._minmaxFormater(this, this._min);
      this.lastDrawParameters.maxValue = this._minmaxFormater == null ? this._max.toFixed(0) : this._minmaxFormater(this, this._max);
      s1 = g.MeasureString(this.lastDrawParameters.minValue, this._minMaxFont, 1e5);
      s2 = g.MeasureString(this.lastDrawParameters.maxValue, this._minMaxFont, 1e5);
      this.lastDrawParameters.minValueFormat = new YStringFormat(16384);
      this.lastDrawParameters.maxValueFormat = new YStringFormat(16384);
      minMaxHeight = s1.height;
      if (s2.height > minMaxHeight)
        minMaxHeight = s2.height;
    }
    switch (this._displayMode) {
      case YSolidGauge.DisplayMode.DISPLAY90:
        h = h - minMaxHeight;
        w = w - minMaxHeight;
        outerRadius = w;
        if (outerRadius > h - this._borderThickness)
          outerRadius = h - this.borderThickness;
        if (outerRadius > w - this.borderThickness)
          outerRadius = w - this.borderThickness;
        angleStart = Math.PI / 2;
        angleEnd = Math.PI;
        this.lastDrawParameters.heightTop = outerRadius;
        this.lastDrawParameters.heightBottom = 0;
        ycenter = mainViewPort.Tmargin + h;
        xcenter = mainViewPort.Lmargin + UIw / 2 + outerRadius / 2 - minMaxHeight + this._borderThickness;
        innerRadius = outerRadius * (100 - this._thickness) / 100;
        ValueRectangle = new YRectangle(xcenter - innerRadius >> 0, ycenter - innerRadius >> 0, innerRadius >> 0, innerRadius >> 0);
        valueFormat.Alignment = 2;
        valueFormat.LineAlignment = 2;
        if (this._showMinMax) {
          this.lastDrawParameters.minValueRectangle = new YRectangle(xcenter - (outerRadius + innerRadius + s1.width) / 2 >> 0, ycenter + this._borderThickness >> 0, s1.width + 1 >> 0, minMaxHeight + 1 >> 0);
          this.lastDrawParameters.minValueFormat.Alignment = 0;
          this.lastDrawParameters.minValueFormat.LineAlignment = 0;
          this.lastDrawParameters.maxValueRectangle = new YRectangle(xcenter + this._borderThickness >> 0, ycenter - outerRadius + (outerRadius - innerRadius - s2.width) / 2 >> 0, minMaxHeight + 1 >> 0, s2.width + 1 >> 0);
          this.lastDrawParameters.maxValueFormat.Alignment = 0;
          this.lastDrawParameters.maxValueFormat.LineAlignment = 0;
          this.lastDrawParameters.maxValueFormat.FormatFlags = 2;
        }
        break;
      case YSolidGauge.DisplayMode.DISPLAY180:
        h = h - minMaxHeight;
        let s0 = new YSizeF(null, "");
        s0 = g.MeasureString(this.lastDrawParameters.value, this._font, 1e5);
        outerRadius = w / 2 - this.borderThickness;
        if (outerRadius > h - this._borderThickness)
          outerRadius = h - this._borderThickness;
        if (outerRadius > w - this.borderThickness)
          outerRadius = w - this.borderThickness;
        angleStart = 0;
        angleEnd = Math.PI;
        ycenter = outerRadius + this._borderThickness / 2;
        innerRadius = outerRadius * (100 - this._thickness) / 100;
        this.lastDrawParameters.heightTop = outerRadius;
        this.lastDrawParameters.heightBottom = 0;
        ValueRectangle = new YRectangle(xcenter - innerRadius >> 0, ycenter + this._borderThickness + minMaxHeight - s0.height >> 0, 2 * innerRadius >> 0, s0.height + 1 >> 0);
        valueFormat.Alignment = 1;
        valueFormat.LineAlignment = 2;
        if (this._showMinMax) {
          this.lastDrawParameters.minValueRectangle = new YRectangle(xcenter - (outerRadius + innerRadius + s1.width) / 2 >> 0, ycenter + this._borderThickness >> 0, s1.width + 1 >> 0, minMaxHeight + 1 >> 0);
          this.lastDrawParameters.minValueFormat.Alignment = 0;
          this.lastDrawParameters.minValueFormat.LineAlignment = 0;
          this.lastDrawParameters.maxValueRectangle = new YRectangle(xcenter + (outerRadius + innerRadius - s2.width) / 2 >> 0, ycenter + this._borderThickness >> 0, s2.width + 1 >> 0, minMaxHeight + 1 >> 0);
          this.lastDrawParameters.maxValueFormat.Alignment = 0;
          this.lastDrawParameters.maxValueFormat.LineAlignment = 0;
        }
        break;
      case YSolidGauge.DisplayMode.DISPLAY270:
        outerRadius = w;
        if (outerRadius > h / 2)
          outerRadius = h / 2;
        if (outerRadius > w / 2)
          outerRadius = w / 2;
        this.lastDrawParameters.heightTop = outerRadius;
        this.lastDrawParameters.heightBottom = outerRadius;
        angleStart = 0;
        angleEnd = 3 * Math.PI / 2;
        ycenter = mainViewPort.Tmargin + UIh / 2;
        innerRadius = outerRadius * (100 - this._thickness) / 100;
        ValueRectangle = new YRectangle(xcenter - innerRadius >> 0, ycenter - innerRadius >> 0, 2 * innerRadius >> 0, 2 * innerRadius >> 0);
        valueFormat.Alignment = 1;
        valueFormat.LineAlignment = 1;
        if (this._showMinMax) {
          this.lastDrawParameters.minValueRectangle = new YRectangle(xcenter + this._borderThickness >> 0, ycenter + (innerRadius + innerRadius + s1.height) / 2 >> 0, s1.width + 1 >> 0, s1.height + 1 >> 0);
          this.lastDrawParameters.minValueFormat.Alignment = 0;
          this.lastDrawParameters.minValueFormat.LineAlignment = 0;
          this.lastDrawParameters.maxValueRectangle = new YRectangle(xcenter + (innerRadius + innerRadius + s1.height) / 2 >> 0, ycenter + this._borderThickness >> 0, s2.height + 1 >> 0, s2.width + 1 >> 0);
          this.lastDrawParameters.maxValueFormat.Alignment = 0;
          this.lastDrawParameters.maxValueFormat.LineAlignment = 0;
          this.lastDrawParameters.maxValueFormat.FormatFlags = 2;
        }
        break;
      case YSolidGauge.DisplayMode.DISPLAY360:
        outerRadius = w;
        if (outerRadius > h / 0.85 / 2)
          outerRadius = h / 0.85 / 2;
        if (outerRadius > w / 2)
          outerRadius = w / 2;
        this.lastDrawParameters.heightTop = outerRadius;
        this.lastDrawParameters.heightBottom = outerRadius * 0.7;
        ycenter = mainViewPort.Tmargin + outerRadius + this._borderThickness / 2;
        angleStart = -Math.PI / 4;
        angleEnd = 5 * Math.PI / 4;
        innerRadius = outerRadius * (100 - this._thickness) / 100;
        ValueRectangle = new YRectangle(xcenter - innerRadius >> 0, ycenter - innerRadius >> 0, 2 * innerRadius >> 0, 2 * innerRadius >> 0);
        valueFormat.Alignment = 1;
        valueFormat.LineAlignment = 1;
        if (this._showMinMax) {
          let dx = Math.abs(innerRadius * Math.cos(angleStart));
          let dy = innerRadius * Math.abs(Math.sin(angleStart)) + 2 * Math.abs((outerRadius - innerRadius) * Math.sin(angleStart) / 3);
          this.lastDrawParameters.minValueRectangle = new YRectangle(xcenter - dx >> 0, ycenter + dy - minMaxHeight / 2 >> 0, s1.width + 1 >> 0, minMaxHeight + 1 >> 0);
          this.lastDrawParameters.minValueFormat.Alignment = 0;
          this.lastDrawParameters.minValueFormat.LineAlignment = 1;
          this.lastDrawParameters.maxValueRectangle = new YRectangle(xcenter + dx - s2.width >> 0, ycenter + dy - minMaxHeight / 2 >> 0, s2.width + 1 >> 0, minMaxHeight + 1 >> 0);
          this.lastDrawParameters.maxValueFormat.Alignment = 0;
          this.lastDrawParameters.maxValueFormat.LineAlignment = 1;
        }
        break;
    }
    this.lastDrawParameters.outerRadius = outerRadius;
    this.lastDrawParameters.innerRadius = innerRadius;
    this.lastDrawParameters.angleStart = angleStart;
    this.lastDrawParameters.angleEnd = angleEnd;
    this.lastDrawParameters.ycenter = ycenter;
    this.lastDrawParameters.xcenter = xcenter;
    this.lastDrawParameters.valueRectangle = ValueRectangle;
    this.lastDrawParameters.valueFormat = valueFormat;
    return this.lastDrawParameters;
  }
  Render(g, w, h) {
    this.mainViewPort = new ViewPortSettings();
    g.SmoothingMode = YSmoothingMode.HighQuality;
    g.TextRenderingHint = YTextRenderingHint.AntiAlias;
    this.drawAnnotationPanels(g, this._annotationPanels, w, h, false, this.mainViewPort);
    let p = this.ComputeDrawParameters(g, w, h, this.mainViewPort);
    if (this._path == null) {
      let outterlength = 2 * p.outerRadius * Math.PI * (p.angleEnd - p.angleStart) / (2 * Math.PI);
      let stepCount = outterlength / this.SegmentMaxLength >> 0;
      let stepsize = (p.angleEnd - p.angleStart) / stepCount;
      this._path = new Array(2 * (stepCount + 1));
      let n = 0;
      for (let i = 0; i <= stepCount; i++) {
        let a = p.angleStart + i * stepsize;
        this._path[n++] = new PointF(p.xcenter + p.outerRadius * Math.cos(a), p.ycenter - p.outerRadius * Math.sin(a));
      }
      for (let i = stepCount; i >= 0; i--) {
        let a = p.angleStart + i * stepsize;
        this._path[n++] = new PointF(p.xcenter + p.innerRadius * Math.cos(a), p.ycenter - p.innerRadius * Math.sin(a));
      }
    }
    if (this._bgBrush == null) {
      this._bgBrush = new YLinearGradientBrush(this._backgroundColor1, this._backgroundColor2);
    }
    if (this._borderpen == null) {
      this._borderpen = new YPen(this._borderColor, this._borderThickness);
      this._borderpen.linejoin = YPen.LineJoin.Round;
    }
    g.FillPolygon(this._bgBrush, this._path);
    if (this._shownValue != this._value) {
      let step = this._maxSpeed * (this._max - this._min) / 100;
      if (Math.abs(this._value - this._shownValue) < step) {
        this._shownValue = this._value;
      } else if (this._shownValue < this._value) {
        this._shownValue += step;
      } else {
        this._shownValue -= step;
      }
    }
    let v = this._shownValue;
    if (v >= this._min) {
      if (v > this._max)
        v = this._max;
      let valueFactor = (v - this._min) / (this._max - this.min);
      let angleValue = p.angleStart + (p.angleEnd - p.angleStart) * valueFactor;
      let outterlength = 2 * p.outerRadius * Math.PI * (angleValue - p.angleStart) / (2 * Math.PI);
      let stepCount = outterlength / this.SegmentMaxLength >> 0;
      let stepsize = (angleValue - p.angleStart) / stepCount;
      let pt = new Array(2 * (stepCount + 1));
      let n = 0;
      for (let i = 0; i <= stepCount; i++) {
        let a = p.angleEnd - i * stepsize;
        pt[n++] = new PointF(p.xcenter + p.outerRadius * Math.cos(a), p.ycenter - p.outerRadius * Math.sin(a));
      }
      for (let i = stepCount; i >= 0; i--) {
        let a = p.angleEnd - i * stepsize;
        pt[n++] = new PointF(p.xcenter + p.innerRadius * Math.cos(a), p.ycenter - p.innerRadius * Math.sin(a));
      }
      let b;
      if (this._color1 == this._color2) {
        b = new YSolidBrush(this._color1);
      } else {
        let A1 = this._color1.alpha;
        let H1 = this._color1.hue;
        let S1 = this._color1.saturation;
        let L1 = this._color1.luminosity;
        let A2 = this._color2.alpha;
        let H2 = this._color2.hue;
        let S2 = this._color2.saturation;
        let L2 = this._color2.luminosity;
        let A = Math.round(A1 + (A2 - A1) * valueFactor) >> 0 & 255;
        let H;
        if (Math.abs(H2 - H1) <= 127) {
          H = H1 + (H2 - H1) * valueFactor >> 0;
        } else {
          H = H1 + 256 + (H2 - H1 + 256) * valueFactor >> 0;
          if (H > 256)
            H -= 256;
        }
        let S = S1 + (S2 - S1) * valueFactor >> 0;
        let L = L1 + (L2 - L1) * valueFactor >> 0;
        b = new YSolidBrush(new YColor(true, A, H, S, L));
      }
      g.FillPolygon(b, pt);
    }
    if (this._borderThickness > 0)
      g.DrawPolygon(this._borderpen, this._path);
    g.DrawStringRect(this.lastDrawParameters.value, this._font, this._font.brush, p.valueRectangle, p.valueFormat);
    if (this._showMinMax) {
      g.DrawStringRect(this.lastDrawParameters.minValue, this._minMaxFont, this._minMaxFont.brush, this.lastDrawParameters.minValueRectangle, this.lastDrawParameters.minValueFormat);
      g.DrawStringRect(this.lastDrawParameters.maxValue, this._minMaxFont, this._minMaxFont.brush, this.lastDrawParameters.maxValueRectangle, this.lastDrawParameters.maxValueFormat);
    }
    this.drawAnnotationPanels(g, this._annotationPanels, w, h, true, this.mainViewPort);
    this.DrawMessagePanels(g, w, h);
    return 0;
  }
  renderingPostProcessing() {
    if (this._shownValue != this._value)
      this.redraw();
  }
};
(function(YSolidGauge2) {
  class DisplayModeEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, DisplayMode);
    }
  }
  YSolidGauge2.DisplayModeEnumItem = DisplayModeEnumItem;
  class DisplayMode extends YEnum {
  }
  DisplayMode.DISPLAY90 = new DisplayModeEnumItem("DISPLAY90", "90\xB0");
  DisplayMode.DISPLAY180 = new DisplayModeEnumItem("DISPLAY180", "180\xB0");
  DisplayMode.DISPLAY270 = new DisplayModeEnumItem("DISPLAY270", "270\xB0");
  DisplayMode.DISPLAY360 = new DisplayModeEnumItem("DISPLAY360", "360\xB0");
  YSolidGauge2.DisplayMode = DisplayMode;
})(YSolidGauge || (YSolidGauge = {}));

// obj/full/Api/yocto_api.js
var YAPI_SUCCESS = 0;
var YAPI_INVALID_ARGUMENT = -2;
var YAPI_NOT_SUPPORTED = -3;
var YAPI_DEVICE_NOT_FOUND = -4;
var YAPI_VERSION_MISMATCH = -5;
var YAPI_DEVICE_BUSY = -6;
var YAPI_TIMEOUT = -7;
var YAPI_IO_ERROR = -8;
var YAPI_UNAUTHORIZED = -12;
var YAPI_FILE_NOT_FOUND = -14;
var YAPI_INVALID_INT = 2147483647;
var YAPI_INVALID_UINT = -1;
var YAPI_INVALID_LONG = 9223372036854776e3;
var YAPI_INVALID_DOUBLE = -Number.MAX_VALUE;
var YAPI_INVALID_STRING = "!INVALID!";
var YAPI_MIN_DOUBLE = -Number.MAX_VALUE;
var YAPI_MAX_DOUBLE = Number.MAX_VALUE;
var Y_FUNCTIONDESCRIPTOR_INVALID = YAPI_INVALID_STRING;
var Y_DETECT_NONE = 0;
var Y_DETECT_USB = 1;
var Y_DETECT_NET = 2;
var Y_DETECT_ALL = Y_DETECT_USB | Y_DETECT_NET;
var DEFAULT_DEVICE_LIST_VALIDITY_MS = 1e4;
var DEFAULT_NETWORK_TIMEOUT_MS = 2e4;
var YOCTO_CALIB_TYPE_OFS = 30;
var NOTIFY_NETPKT_CONFCHGYDX = "s";
var NOTIFY_NETPKT_FLUSHV2YDX = "t";
var NOTIFY_NETPKT_FUNCV2YDX = "u";
var NOTIFY_NETPKT_TIMEV2YDX = "v";
var NOTIFY_NETPKT_DEVLOGYDX = "w";
var NOTIFY_NETPKT_TIMEVALYDX = "x";
var NOTIFY_NETPKT_FUNCVALYDX = "y";
var NOTIFY_NETPKT_TIMEAVGYDX = "z";
var NOTIFY_NETPKT_STOP = 10;
var NOTIFY_V2_6RAWBYTES = 1;
var NOTIFY_V2_TYPEDDATA = 2;
var PUBVAL_LEGACY = 0;
var PUBVAL_1RAWBYTE = 1;
var PUBVAL_2RAWBYTES = 2;
var PUBVAL_3RAWBYTES = 3;
var PUBVAL_4RAWBYTES = 4;
var PUBVAL_5RAWBYTES = 5;
var PUBVAL_6RAWBYTES = 6;
var PUBVAL_C_LONG = 7;
var PUBVAL_C_FLOAT = 8;
var PUBVAL_YOCTO_FLOAT_E3 = 9;
var YOCTO_PUBVAL_SIZE = 6;
var YOCTO_HASH_BUF_SIZE = 28;
var YOCTO_BASETYPE_FUNCTION = 0;
var YOCTO_BASETYPE_SENSOR = 1;
var Y_BASETYPES = {
  Function: YOCTO_BASETYPE_FUNCTION,
  Sensor: YOCTO_BASETYPE_SENSOR
};
var YErrorMsg = class {
  constructor(msg = "") {
    this.msg = msg;
  }
};
var YoctoError = class extends Error {
  constructor(...params) {
    super(...params);
    this.errorMsg = this.name;
    this.name = "YoctoError";
    if ("captureStackTrace" in Error) {
      Error.captureStackTrace(this, YoctoError);
    }
  }
};
var Y_MD5Ctx = class {
  constructor() {
    this.buf = new Uint32Array(4);
    this.bits = new Uint32Array(2);
    this.inBuf = new ArrayBuffer(64);
    this.in8 = new Uint8Array(this.inBuf);
    this.in32 = new Uint32Array(this.inBuf);
    this.in32[0] = 1;
    this.bigEndian = this.in8[0] != 1;
    this.buf[0] = 1732584193 >>> 0;
    this.buf[1] = 4023233417 >>> 0;
    this.buf[2] = 2562383102 >>> 0;
    this.buf[3] = 271733878 >>> 0;
    this.bits[0] = 0;
    this.bits[1] = 0;
  }
  _byteReverseIn() {
    for (let i = 0; i < 16; i++) {
      let a = this.in32[i];
      this.in32[i] = (a >>> 24 | (a & 255) << 24 | (a & 16711680) >>> 8 | (a & 65280) << 8) >>> 0;
    }
  }
  _transform() {
    let F1 = (x, y, z) => (z ^ x & (y ^ z)) >>> 0;
    let F2 = (x, y, z) => F1(z, x, y);
    let F3 = (x, y, z) => (x ^ y ^ z) >>> 0;
    let F4 = (x, y, z) => (y ^ (x | ~z)) >>> 0;
    let MD5STEP = (f, w, x, y, z, data, s) => {
      w = w + f(x, y, z) + (data >>> 0) >>> 0;
      w = (w << s >>> 0 | w >>> 32 - s) >>> 0;
      return w + x >>> 0;
    };
    let a = this.buf[0];
    let b = this.buf[1];
    let c = this.buf[2];
    let d = this.buf[3];
    let dataIn = this.in32;
    a = MD5STEP(F1, a, b, c, d, dataIn[0] + 3614090360, 7);
    d = MD5STEP(F1, d, a, b, c, dataIn[1] + 3905402710, 12);
    c = MD5STEP(F1, c, d, a, b, dataIn[2] + 606105819, 17);
    b = MD5STEP(F1, b, c, d, a, dataIn[3] + 3250441966, 22);
    a = MD5STEP(F1, a, b, c, d, dataIn[4] + 4118548399, 7);
    d = MD5STEP(F1, d, a, b, c, dataIn[5] + 1200080426, 12);
    c = MD5STEP(F1, c, d, a, b, dataIn[6] + 2821735955, 17);
    b = MD5STEP(F1, b, c, d, a, dataIn[7] + 4249261313, 22);
    a = MD5STEP(F1, a, b, c, d, dataIn[8] + 1770035416, 7);
    d = MD5STEP(F1, d, a, b, c, dataIn[9] + 2336552879, 12);
    c = MD5STEP(F1, c, d, a, b, dataIn[10] + 4294925233, 17);
    b = MD5STEP(F1, b, c, d, a, dataIn[11] + 2304563134, 22);
    a = MD5STEP(F1, a, b, c, d, dataIn[12] + 1804603682, 7);
    d = MD5STEP(F1, d, a, b, c, dataIn[13] + 4254626195, 12);
    c = MD5STEP(F1, c, d, a, b, dataIn[14] + 2792965006, 17);
    b = MD5STEP(F1, b, c, d, a, dataIn[15] + 1236535329, 22);
    a = MD5STEP(F2, a, b, c, d, dataIn[1] + 4129170786, 5);
    d = MD5STEP(F2, d, a, b, c, dataIn[6] + 3225465664, 9);
    c = MD5STEP(F2, c, d, a, b, dataIn[11] + 643717713, 14);
    b = MD5STEP(F2, b, c, d, a, dataIn[0] + 3921069994, 20);
    a = MD5STEP(F2, a, b, c, d, dataIn[5] + 3593408605, 5);
    d = MD5STEP(F2, d, a, b, c, dataIn[10] + 38016083, 9);
    c = MD5STEP(F2, c, d, a, b, dataIn[15] + 3634488961, 14);
    b = MD5STEP(F2, b, c, d, a, dataIn[4] + 3889429448, 20);
    a = MD5STEP(F2, a, b, c, d, dataIn[9] + 568446438, 5);
    d = MD5STEP(F2, d, a, b, c, dataIn[14] + 3275163606, 9);
    c = MD5STEP(F2, c, d, a, b, dataIn[3] + 4107603335, 14);
    b = MD5STEP(F2, b, c, d, a, dataIn[8] + 1163531501, 20);
    a = MD5STEP(F2, a, b, c, d, dataIn[13] + 2850285829, 5);
    d = MD5STEP(F2, d, a, b, c, dataIn[2] + 4243563512, 9);
    c = MD5STEP(F2, c, d, a, b, dataIn[7] + 1735328473, 14);
    b = MD5STEP(F2, b, c, d, a, dataIn[12] + 2368359562, 20);
    a = MD5STEP(F3, a, b, c, d, dataIn[5] + 4294588738, 4);
    d = MD5STEP(F3, d, a, b, c, dataIn[8] + 2272392833, 11);
    c = MD5STEP(F3, c, d, a, b, dataIn[11] + 1839030562, 16);
    b = MD5STEP(F3, b, c, d, a, dataIn[14] + 4259657740, 23);
    a = MD5STEP(F3, a, b, c, d, dataIn[1] + 2763975236, 4);
    d = MD5STEP(F3, d, a, b, c, dataIn[4] + 1272893353, 11);
    c = MD5STEP(F3, c, d, a, b, dataIn[7] + 4139469664, 16);
    b = MD5STEP(F3, b, c, d, a, dataIn[10] + 3200236656, 23);
    a = MD5STEP(F3, a, b, c, d, dataIn[13] + 681279174, 4);
    d = MD5STEP(F3, d, a, b, c, dataIn[0] + 3936430074, 11);
    c = MD5STEP(F3, c, d, a, b, dataIn[3] + 3572445317, 16);
    b = MD5STEP(F3, b, c, d, a, dataIn[6] + 76029189, 23);
    a = MD5STEP(F3, a, b, c, d, dataIn[9] + 3654602809, 4);
    d = MD5STEP(F3, d, a, b, c, dataIn[12] + 3873151461, 11);
    c = MD5STEP(F3, c, d, a, b, dataIn[15] + 530742520, 16);
    b = MD5STEP(F3, b, c, d, a, dataIn[2] + 3299628645, 23);
    a = MD5STEP(F4, a, b, c, d, dataIn[0] + 4096336452, 6);
    d = MD5STEP(F4, d, a, b, c, dataIn[7] + 1126891415, 10);
    c = MD5STEP(F4, c, d, a, b, dataIn[14] + 2878612391, 15);
    b = MD5STEP(F4, b, c, d, a, dataIn[5] + 4237533241, 21);
    a = MD5STEP(F4, a, b, c, d, dataIn[12] + 1700485571, 6);
    d = MD5STEP(F4, d, a, b, c, dataIn[3] + 2399980690, 10);
    c = MD5STEP(F4, c, d, a, b, dataIn[10] + 4293915773, 15);
    b = MD5STEP(F4, b, c, d, a, dataIn[1] + 2240044497, 21);
    a = MD5STEP(F4, a, b, c, d, dataIn[8] + 1873313359, 6);
    d = MD5STEP(F4, d, a, b, c, dataIn[15] + 4264355552, 10);
    c = MD5STEP(F4, c, d, a, b, dataIn[6] + 2734768916, 15);
    b = MD5STEP(F4, b, c, d, a, dataIn[13] + 1309151649, 21);
    a = MD5STEP(F4, a, b, c, d, dataIn[4] + 4149444226, 6);
    d = MD5STEP(F4, d, a, b, c, dataIn[11] + 3174756917, 10);
    c = MD5STEP(F4, c, d, a, b, dataIn[2] + 718787259, 15);
    b = MD5STEP(F4, b, c, d, a, dataIn[9] + 3951481745, 21);
    this.buf[0] = (this.buf[0] + a & 4294967295) >>> 0;
    this.buf[1] = (this.buf[1] + b & 4294967295) >>> 0;
    this.buf[2] = (this.buf[2] + c & 4294967295) >>> 0;
    this.buf[3] = (this.buf[3] + d & 4294967295) >>> 0;
  }
  addData(buf) {
    let len = buf.length;
    let pos = 0;
    let t = this.bits[0];
    this.bits[0] = t + (len << 3) >>> 0;
    if (this.bits[0] < t) {
      this.bits[1]++;
    }
    this.bits[1] += len >>> 29;
    t = t >>> 3 & 63;
    while (pos < len) {
      while (pos < len && t < 64) {
        this.in8[t++] = buf[pos++];
      }
      if (t < 64)
        return;
      if (this.bigEndian)
        this._byteReverseIn();
      this._transform();
      t = 0;
    }
  }
  calculate() {
    let t = this.bits[0] >>> 3 & 63;
    this.in8[t++] = 128;
    if (t > 56) {
      while (t < 64) {
        this.in8[t++] = 0;
      }
      if (this.bigEndian)
        this._byteReverseIn();
      this._transform();
      for (t = 0; t < 14; t++) {
        this.in32[t] = 0;
      }
    } else {
      while (t < 56) {
        this.in8[t++] = 0;
      }
      if (this.bigEndian)
        this._byteReverseIn();
    }
    this.in32[14] = this.bits[0];
    this.in32[15] = this.bits[1];
    this._transform();
    let res = new Uint8Array(16);
    for (t = 0; t < 16; t++) {
      res[t] = this.buf[t >>> 2] >>> 8 * (t & 3) & 255;
    }
    return res;
  }
};
var YFunctionType = class {
  constructor(yapi, classname) {
    this._yapi = yapi;
    this._className = classname;
    this._connectedFns = {};
    this._requestedFns = {};
    this._hwIdByName = {};
    this._nameByHwId = {};
    this._valueByHwId = {};
    this._baseType = 0;
  }
  imm_reindexFunction(str_hwid, str_name, str_val, int_basetype) {
    let currname = this._nameByHwId[str_hwid];
    let res = false;
    if (currname == void 0 || currname == "") {
      if (str_name != "") {
        this._nameByHwId[str_hwid] = str_name;
        res = true;
      }
    } else if (currname != str_name) {
      if (this._hwIdByName[currname] == str_hwid) {
        delete this._hwIdByName[currname];
      }
      if (str_name != "") {
        this._nameByHwId[str_hwid] = str_name;
      } else {
        delete this._nameByHwId[str_hwid];
      }
      res = true;
    }
    if (str_name != "") {
      this._hwIdByName[str_name] = str_hwid;
    }
    if (str_val) {
      this._valueByHwId[str_hwid] = str_val;
    } else {
      if (this._valueByHwId[str_hwid] == void 0) {
        this._valueByHwId[str_hwid] = "";
      }
    }
    if (int_basetype) {
      if (this._baseType == 0) {
        this._baseType = int_basetype;
      }
    }
    return res;
  }
  imm_forgetFunction(str_hwid) {
    let currname = this._nameByHwId[str_hwid];
    if (currname != void 0) {
      if (currname != "" && this._hwIdByName[currname] == str_hwid) {
        delete this._hwIdByName[currname];
      }
      delete this._nameByHwId[str_hwid];
    }
    if (this._valueByHwId[str_hwid] != void 0) {
      delete this._valueByHwId[str_hwid];
    }
    let con_fn = this._connectedFns[str_hwid];
    if (con_fn) {
      this._requestedFns[str_hwid] = con_fn;
      delete this._connectedFns[str_hwid];
    }
  }
  imm_resolve(str_func) {
    let res;
    let dotpos = str_func.indexOf(".");
    if (dotpos < 0) {
      res = this._hwIdByName[str_func];
      if (res != void 0) {
        return {
          errorType: YAPI_SUCCESS,
          errorMsg: "no error",
          result: String(res)
        };
      }
      dotpos = str_func.length;
      str_func += "." + this._className.substr(0, 1).toLowerCase() + this._className.substr(1);
    }
    if (this._valueByHwId[str_func] != void 0) {
      return {
        errorType: YAPI_SUCCESS,
        errorMsg: "no error",
        result: String(str_func)
      };
    }
    let serial = "";
    let funcid;
    if (dotpos > 0) {
      let devid = str_func.substr(0, dotpos);
      funcid = str_func.substr(dotpos + 1);
      let dev = this._yapi.imm_getDevice(devid);
      if (!dev) {
        return {
          errorType: YAPI_DEVICE_NOT_FOUND,
          errorMsg: "Device [" + devid + "] not online",
          result: ""
        };
      }
      serial = dev.imm_getSerialNumber();
      res = serial + "." + funcid;
      if (this._valueByHwId[res] != void 0) {
        return {
          errorType: YAPI_SUCCESS,
          errorMsg: "no error",
          result: String(res)
        };
      }
      let i, nfun = dev.imm_functionCount();
      for (i = 0; i < nfun; i++) {
        res = serial + "." + dev.imm_functionId(i);
        let name = this._nameByHwId[res];
        if (name != void 0 && name == funcid) {
          return {
            errorType: YAPI_SUCCESS,
            errorMsg: "no error",
            result: String(res)
          };
        }
      }
    } else {
      funcid = str_func.substr(1);
      for (let hwid_str in this._connectedFns) {
        let pos = hwid_str.indexOf(".");
        let str_function = hwid_str.substr(pos + 1);
        if (str_function == funcid) {
          return {
            errorType: YAPI_SUCCESS,
            errorMsg: "no error",
            result: String(hwid_str)
          };
        }
      }
    }
    return {
      errorType: YAPI_DEVICE_NOT_FOUND,
      errorMsg: "No function [" + funcid + "] found on device [" + serial + "]",
      result: ""
    };
  }
  imm_getFriendlyName(str_func) {
    let resolved = this.imm_resolve(str_func);
    let name;
    if (resolved.errorType != YAPI_SUCCESS) {
      return resolved;
    }
    let hwId = resolved.result;
    if (this._className == "Module") {
      let friend = hwId;
      name = this._nameByHwId[friend];
      if (name != void 0 && name != "") {
        friend = this._nameByHwId[friend];
      }
      return {
        errorType: YAPI_SUCCESS,
        errorMsg: "no error",
        result: String(friend)
      };
    } else {
      let pos = hwId.indexOf(".");
      let str_serialMod = hwId.substr(0, pos);
      let str_friendModFull = this._yapi.imm_getFriendlyNameFunction("Module", str_serialMod).result;
      let int_friendModDot = str_friendModFull.indexOf(".");
      let str_friendMod = int_friendModDot > 0 ? str_friendModFull.substr(0, int_friendModDot) : str_friendModFull;
      let str_friendFunc = hwId.substr(pos + 1);
      name = this._nameByHwId[hwId];
      if (name != void 0 && name != "") {
        str_friendFunc = name;
      }
      return {
        errorType: YAPI_SUCCESS,
        errorMsg: "no error",
        result: String(str_friendMod + "." + str_friendFunc)
      };
    }
  }
  imm_setFunction(str_func, obj_func) {
    let funres = this.imm_resolve(str_func);
    if (funres.result) {
      this._connectedFns[funres.result] = obj_func;
    } else {
      this._requestedFns[str_func] = obj_func;
    }
  }
  imm_getFunction(str_func) {
    let funres = this.imm_resolve(str_func);
    if (funres.errorType == YAPI_SUCCESS) {
      let conn_fn = this._connectedFns[funres.result];
      if (conn_fn != void 0) {
        return conn_fn;
      }
      let req_fn = this._requestedFns[str_func];
      if (req_fn != void 0) {
        this._connectedFns[funres.result] = req_fn;
        delete this._requestedFns[str_func];
      }
      return req_fn;
    } else {
      return this._requestedFns[str_func];
    }
  }
  imm_setFunctionValue(str_hwid, str_pubval) {
    let currval = this._valueByHwId[str_hwid];
    if (!(currval == void 0) && currval == str_pubval) {
      return false;
    }
    this._valueByHwId[str_hwid] = str_pubval;
    return true;
  }
  imm_getFunctionValue(str_hwid) {
    return this._valueByHwId[str_hwid];
  }
  imm_getBaseType() {
    return this._baseType;
  }
  imm_matchBaseType(baseclass) {
    return baseclass == YOCTO_BASETYPE_FUNCTION || baseclass == this._baseType;
  }
  imm_getFirstHardwareId() {
    let res = null;
    for (res in this._valueByHwId) {
      break;
    }
    return res;
  }
  imm_getNextHardwareId(str_hwid) {
    for (let iter_hwid in this._valueByHwId) {
      if (str_hwid == "!") {
        return iter_hwid;
      }
      if (str_hwid == iter_hwid) {
        str_hwid = "!";
      }
    }
    return null;
  }
};
var YHTTPBody = class {
  constructor(str_fname, bin_data, fun_progressCb) {
    this.fname = str_fname;
    this.data = bin_data;
    this.progressCb = fun_progressCb;
  }
};
var YHTTPRequest = class {
  constructor(bin_res, int_errType = YAPI_SUCCESS, str_errMsg = "no error") {
    this.devUrl = null;
    this.obj_result = null;
    this.asyncId = 0;
    this.acceptor = null;
    this.toBeSent = null;
    this.sendPos = 0;
    this.progressCb = null;
    this.timeoutId = null;
    this.sendTimeoutId = null;
    this.next = null;
    this._creat = "";
    this._sent = "";
    this.bin_result = bin_res;
    this.errorType = int_errType;
    this.errorMsg = str_errMsg;
  }
};
var YFuncRequest = class {
  constructor(obj_res, int_errType = YAPI_SUCCESS, str_errMsg = "no error") {
    this.errorType = int_errType;
    this.errorMsg = str_errMsg;
    this.obj_result = obj_res;
  }
};
var YDataStream = class {
  constructor(obj_parent, obj_dataset, encoded) {
    this._runNo = 0;
    this._utcStamp = 0;
    this._nCols = 0;
    this._nRows = 0;
    this._startTime = 0;
    this._duration = 0;
    this._dataSamplesInterval = 0;
    this._firstMeasureDuration = 0;
    this._columnNames = [];
    this._functionId = "";
    this._isClosed = false;
    this._isAvg = false;
    this._minVal = 0;
    this._avgVal = 0;
    this._maxVal = 0;
    this._caltyp = 0;
    this._calpar = [];
    this._calraw = [];
    this._calref = [];
    this._values = [];
    this._isLoaded = false;
    this.DATA_INVALID = YAPI_INVALID_DOUBLE;
    this.DURATION_INVALID = YAPI_INVALID_DOUBLE;
    this._parent = obj_parent;
    this._yapi = this._parent._yapi;
    this.imm_calhdl = null;
    if (typeof obj_dataset != "undefined") {
      this.imm_initFromDataSet(obj_dataset, encoded);
    }
  }
  imm_initFromDataSet(dataset, encoded) {
    let val;
    let i;
    let maxpos;
    let ms_offset;
    let samplesPerHour;
    let fRaw;
    let fRef;
    let iCalib = [];
    this._runNo = encoded[0] + (encoded[1] << 16);
    this._utcStamp = encoded[2] + (encoded[3] << 16);
    val = encoded[4];
    this._isAvg = (val & 256) == 0;
    samplesPerHour = val & 255;
    if ((val & 256) != 0) {
      samplesPerHour = samplesPerHour * 3600;
    } else {
      if ((val & 512) != 0) {
        samplesPerHour = samplesPerHour * 60;
      }
    }
    this._dataSamplesInterval = 3600 / samplesPerHour;
    ms_offset = encoded[6];
    if (ms_offset < 1e3) {
      this._startTime = this._utcStamp + ms_offset / 1e3;
    } else {
      this._startTime = this._utcStamp - this._dataSamplesInterval;
    }
    this._firstMeasureDuration = encoded[5];
    if (!this._isAvg) {
      this._firstMeasureDuration = this._firstMeasureDuration / 1e3;
    }
    val = encoded[7];
    this._isClosed = val != 65535;
    if (val == 65535) {
      val = 0;
    }
    this._nRows = val;
    if (this._nRows > 0) {
      if (this._firstMeasureDuration > 0) {
        this._duration = this._firstMeasureDuration + (this._nRows - 1) * this._dataSamplesInterval;
      } else {
        this._duration = this._nRows * this._dataSamplesInterval;
      }
    } else {
      this._duration = 0;
    }
    iCalib = dataset.imm_get_calibration();
    this._caltyp = iCalib[0];
    if (this._caltyp != 0) {
      this.imm_calhdl = this._yapi.imm_getCalibrationHandler(this._caltyp);
      maxpos = iCalib.length;
      this._calpar.length = 0;
      this._calraw.length = 0;
      this._calref.length = 0;
      i = 1;
      while (i < maxpos) {
        this._calpar.push(iCalib[i]);
        i = i + 1;
      }
      i = 1;
      while (i + 1 < maxpos) {
        fRaw = iCalib[i];
        fRaw = fRaw / 1e3;
        fRef = iCalib[i + 1];
        fRef = fRef / 1e3;
        this._calraw.push(fRaw);
        this._calref.push(fRef);
        i = i + 2;
      }
    }
    this._functionId = dataset.imm_get_functionId();
    if (this._isAvg) {
      this._columnNames.length = 0;
      this._columnNames.push(this._functionId + "_min");
      this._columnNames.push(this._functionId + "_avg");
      this._columnNames.push(this._functionId + "_max");
      this._nCols = 3;
    } else {
      this._columnNames.length = 0;
      this._columnNames.push(this._functionId);
      this._nCols = 1;
    }
    if (this._nRows > 0) {
      this._avgVal = this.imm_decodeAvg(encoded[8] + ((encoded[9] ^ 32768) << 16), 1);
      this._minVal = this.imm_decodeVal(encoded[10] + (encoded[11] << 16));
      this._maxVal = this.imm_decodeVal(encoded[12] + (encoded[13] << 16));
    }
    return 0;
  }
  imm_parseStream(sdata) {
    let idx;
    let udat = [];
    let dat = [];
    if (this._isLoaded && !this._isClosed) {
      return YAPI_SUCCESS;
    }
    if (sdata.length == 0) {
      this._nRows = 0;
      return YAPI_SUCCESS;
    }
    udat = this._yapi.imm_decodeWords(this._parent.imm_json_get_string(sdata));
    this._values.length = 0;
    idx = 0;
    if (this._isAvg) {
      while (idx + 3 < udat.length) {
        dat.length = 0;
        if (udat[idx] == 65535 && udat[idx + 1] == 65535) {
          dat.push(NaN);
          dat.push(NaN);
          dat.push(NaN);
        } else {
          dat.push(this.imm_decodeVal(udat[idx + 2] + (udat[idx + 3] << 16)));
          dat.push(this.imm_decodeAvg(udat[idx] + ((udat[idx + 1] ^ 32768) << 16), 1));
          dat.push(this.imm_decodeVal(udat[idx + 4] + (udat[idx + 5] << 16)));
        }
        idx = idx + 6;
        this._values.push(dat.slice());
      }
    } else {
      while (idx + 1 < udat.length) {
        dat.length = 0;
        if (udat[idx] == 65535 && udat[idx + 1] == 65535) {
          dat.push(NaN);
        } else {
          dat.push(this.imm_decodeAvg(udat[idx] + ((udat[idx + 1] ^ 32768) << 16), 1));
        }
        this._values.push(dat.slice());
        idx = idx + 2;
      }
    }
    this._nRows = this._values.length;
    this._isLoaded = true;
    return YAPI_SUCCESS;
  }
  imm_wasLoaded() {
    return this._isLoaded;
  }
  imm_get_url() {
    let url;
    url = "logger.json?id=" + this._functionId + "&run=" + String(Math.round(this._runNo)) + "&utc=" + String(Math.round(this._utcStamp));
    return url;
  }
  imm_get_baseurl() {
    let url;
    url = "logger.json?id=" + this._functionId + "&run=" + String(Math.round(this._runNo)) + "&utc=";
    return url;
  }
  imm_get_urlsuffix() {
    let url;
    url = String(Math.round(this._utcStamp));
    return url;
  }
  async loadStream() {
    return this.imm_parseStream(await this._parent._download(this.imm_get_url()));
  }
  imm_decodeVal(w) {
    let val;
    val = w;
    val = val / 1e3;
    if (this._caltyp != 0) {
      if (this.imm_calhdl != null) {
        val = this.imm_calhdl(val, this._caltyp, this._calpar, this._calraw, this._calref);
      }
    }
    return val;
  }
  imm_decodeAvg(dw, count) {
    let val;
    val = dw;
    val = val / 1e3;
    if (this._caltyp != 0) {
      if (this.imm_calhdl != null) {
        val = this.imm_calhdl(val, this._caltyp, this._calpar, this._calraw, this._calref);
      }
    }
    return val;
  }
  async isClosed() {
    return this._isClosed;
  }
  async get_runIndex() {
    return this._runNo;
  }
  async get_startTime() {
    return this._utcStamp - (Date.now() / 1e3 >> 0);
  }
  async get_startTimeUTC() {
    return Math.round(this._startTime);
  }
  async get_realStartTimeUTC() {
    return this._startTime;
  }
  async get_dataSamplesIntervalMs() {
    return Math.round(this._dataSamplesInterval * 1e3);
  }
  async get_dataSamplesInterval() {
    return this._dataSamplesInterval;
  }
  async get_firstDataSamplesInterval() {
    return this._firstMeasureDuration;
  }
  async get_rowCount() {
    if (this._nRows != 0 && this._isClosed) {
      return this._nRows;
    }
    await this.loadStream();
    return this._nRows;
  }
  async get_columnCount() {
    if (this._nCols != 0) {
      return this._nCols;
    }
    await this.loadStream();
    return this._nCols;
  }
  async get_columnNames() {
    if (this._columnNames.length != 0) {
      return this._columnNames;
    }
    await this.loadStream();
    return this._columnNames;
  }
  async get_minValue() {
    return this._minVal;
  }
  async get_averageValue() {
    return this._avgVal;
  }
  async get_maxValue() {
    return this._maxVal;
  }
  async get_realDuration() {
    if (this._isClosed) {
      return this._duration;
    }
    return (Date.now() / 1e3 >> 0) - this._utcStamp;
  }
  async get_dataRows() {
    if (this._values.length == 0 || !this._isClosed) {
      await this.loadStream();
    }
    return this._values;
  }
  async get_data(row, col) {
    if (this._values.length == 0 || !this._isClosed) {
      await this.loadStream();
    }
    if (row >= this._values.length) {
      return YDataStream.DATA_INVALID;
    }
    if (col >= this._values[row].length) {
      return YDataStream.DATA_INVALID;
    }
    return this._values[row][col];
  }
};
YDataStream.DATA_INVALID = YAPI_INVALID_DOUBLE;
YDataStream.DURATION_INVALID = YAPI_INVALID_DOUBLE;
var YDataSet = class {
  constructor(obj_parent, str_functionId = "", str_unit = "", double_startTime = 0, double_endTime = 0) {
    this._hardwareId = "";
    this._functionId = "";
    this._unit = "";
    this._bulkLoad = 0;
    this._startTimeMs = 0;
    this._endTimeMs = 0;
    this._progress = 0;
    this._calib = [];
    this._streams = [];
    this._preview = [];
    this._measures = [];
    this._summaryMinVal = 0;
    this._summaryMaxVal = 0;
    this._summaryTotalAvg = 0;
    this._summaryTotalTime = 0;
    this.DATA_INVALID = YAPI_INVALID_DOUBLE;
    this.DURATION_INVALID = YAPI_INVALID_DOUBLE;
    this.HARDWAREID_INVALID = YAPI_INVALID_STRING;
    this.FUNCTIONID_INVALID = YAPI_INVALID_STRING;
    this.UNIT_INVALID = YAPI_INVALID_STRING;
    this._summary = new YMeasure(0, 0, 0, 0, 0);
    if (str_functionId == "") {
      this._parent = obj_parent;
      this._yapi = obj_parent._yapi;
      this._startTimeMs = 0;
      this._endTimeMs = 0;
    } else {
      this._parent = obj_parent;
      this._yapi = obj_parent._yapi;
      this._functionId = str_functionId;
      this._unit = str_unit;
      this._startTimeMs = double_startTime * 1e3;
      this._endTimeMs = double_endTime * 1e3;
      this._progress = -1;
    }
  }
  imm_get_functionId() {
    return this._functionId;
  }
  imm_get_calibration() {
    return this._calib;
  }
  async loadSummary(data) {
    let dataRows = [];
    let tim;
    let mitv;
    let itv;
    let fitv;
    let end_;
    let nCols;
    let minCol;
    let avgCol;
    let maxCol;
    let res;
    let m_pos;
    let previewTotalTime;
    let previewTotalAvg;
    let previewMinVal;
    let previewMaxVal;
    let previewAvgVal;
    let previewStartMs;
    let previewStopMs;
    let previewDuration;
    let streamStartTimeMs;
    let streamDuration;
    let streamEndTimeMs;
    let minVal;
    let avgVal;
    let maxVal;
    let summaryStartMs;
    let summaryStopMs;
    let summaryTotalTime;
    let summaryTotalAvg;
    let summaryMinVal;
    let summaryMaxVal;
    let url;
    let strdata;
    let measure_data = [];
    if (this._progress < 0) {
      strdata = this._yapi.imm_bin2str(data);
      if (strdata == "{}") {
        this._parent._throw(YAPI_VERSION_MISMATCH, "device firmware is too old");
        return YAPI_VERSION_MISMATCH;
      }
      res = await this._parse(strdata);
      if (res < 0) {
        return res;
      }
    }
    summaryTotalTime = 0;
    summaryTotalAvg = 0;
    summaryMinVal = YAPI_MAX_DOUBLE;
    summaryMaxVal = YAPI_MIN_DOUBLE;
    summaryStartMs = YAPI_MAX_DOUBLE;
    summaryStopMs = YAPI_MIN_DOUBLE;
    for (let ii in this._streams) {
      streamStartTimeMs = Math.round(await this._streams[ii].get_realStartTimeUTC() * 1e3);
      streamDuration = await this._streams[ii].get_realDuration();
      streamEndTimeMs = streamStartTimeMs + Math.round(streamDuration * 1e3);
      if (streamStartTimeMs >= this._startTimeMs && (this._endTimeMs == 0 || streamEndTimeMs <= this._endTimeMs)) {
        previewMinVal = await this._streams[ii].get_minValue();
        previewAvgVal = await this._streams[ii].get_averageValue();
        previewMaxVal = await this._streams[ii].get_maxValue();
        previewStartMs = streamStartTimeMs;
        previewStopMs = streamEndTimeMs;
        previewDuration = streamDuration;
      } else {
        if (!this._streams[ii].imm_wasLoaded()) {
          url = this._streams[ii].imm_get_url();
          data = await this._parent._download(url);
          this._streams[ii].imm_parseStream(data);
        }
        dataRows = await this._streams[ii].get_dataRows();
        if (dataRows.length == 0) {
          return await this.get_progress();
        }
        tim = streamStartTimeMs;
        fitv = Math.round(await this._streams[ii].get_firstDataSamplesInterval() * 1e3);
        itv = Math.round(await this._streams[ii].get_dataSamplesInterval() * 1e3);
        nCols = dataRows[0].length;
        minCol = 0;
        if (nCols > 2) {
          avgCol = 1;
        } else {
          avgCol = 0;
        }
        if (nCols > 2) {
          maxCol = 2;
        } else {
          maxCol = 0;
        }
        previewTotalTime = 0;
        previewTotalAvg = 0;
        previewStartMs = streamEndTimeMs;
        previewStopMs = streamStartTimeMs;
        previewMinVal = YAPI_MAX_DOUBLE;
        previewMaxVal = YAPI_MIN_DOUBLE;
        m_pos = 0;
        while (m_pos < dataRows.length) {
          measure_data = dataRows[m_pos];
          if (m_pos == 0) {
            mitv = fitv;
          } else {
            mitv = itv;
          }
          end_ = tim + mitv;
          if (end_ > this._startTimeMs && (this._endTimeMs == 0 || tim < this._endTimeMs)) {
            minVal = measure_data[minCol];
            avgVal = measure_data[avgCol];
            maxVal = measure_data[maxCol];
            if (previewStartMs > tim) {
              previewStartMs = tim;
            }
            if (previewStopMs < end_) {
              previewStopMs = end_;
            }
            if (previewMinVal > minVal) {
              previewMinVal = minVal;
            }
            if (previewMaxVal < maxVal) {
              previewMaxVal = maxVal;
            }
            if (!isNaN(avgVal)) {
              previewTotalAvg = previewTotalAvg + avgVal * mitv;
              previewTotalTime = previewTotalTime + mitv;
            }
          }
          tim = end_;
          m_pos = m_pos + 1;
        }
        if (previewTotalTime > 0) {
          previewAvgVal = previewTotalAvg / previewTotalTime;
          previewDuration = (previewStopMs - previewStartMs) / 1e3;
        } else {
          previewAvgVal = 0;
          previewDuration = 0;
        }
      }
      this._preview.push(new YMeasure(previewStartMs / 1e3, previewStopMs / 1e3, previewMinVal, previewAvgVal, previewMaxVal));
      if (summaryMinVal > previewMinVal) {
        summaryMinVal = previewMinVal;
      }
      if (summaryMaxVal < previewMaxVal) {
        summaryMaxVal = previewMaxVal;
      }
      if (summaryStartMs > previewStartMs) {
        summaryStartMs = previewStartMs;
      }
      if (summaryStopMs < previewStopMs) {
        summaryStopMs = previewStopMs;
      }
      summaryTotalAvg = summaryTotalAvg + previewAvgVal * previewDuration;
      summaryTotalTime = summaryTotalTime + previewDuration;
    }
    if (this._startTimeMs == 0 || this._startTimeMs > summaryStartMs) {
      this._startTimeMs = summaryStartMs;
    }
    if (this._endTimeMs == 0 || this._endTimeMs < summaryStopMs) {
      this._endTimeMs = summaryStopMs;
    }
    if (summaryTotalTime > 0) {
      this._summary = new YMeasure(summaryStartMs / 1e3, summaryStopMs / 1e3, summaryMinVal, summaryTotalAvg / summaryTotalTime, summaryMaxVal);
    } else {
      this._summary = new YMeasure(0, 0, YAPI_INVALID_DOUBLE, YAPI_INVALID_DOUBLE, YAPI_INVALID_DOUBLE);
    }
    return await this.get_progress();
  }
  async processMore(progress, data) {
    let stream;
    let dataRows = [];
    let tim;
    let itv;
    let fitv;
    let avgv;
    let end_;
    let nCols;
    let minCol;
    let avgCol;
    let maxCol;
    let firstMeasure;
    let baseurl;
    let url;
    let suffix;
    let suffixes = [];
    let idx;
    let bulkFile;
    let streamStr = [];
    let urlIdx;
    let streamBin;
    if (progress != this._progress) {
      return this._progress;
    }
    if (this._progress < 0) {
      return await this.loadSummary(data);
    }
    stream = this._streams[this._progress];
    if (!stream.imm_wasLoaded()) {
      stream.imm_parseStream(data);
    }
    dataRows = await stream.get_dataRows();
    this._progress = this._progress + 1;
    if (dataRows.length == 0) {
      return await this.get_progress();
    }
    tim = Math.round(await stream.get_realStartTimeUTC() * 1e3);
    fitv = Math.round(await stream.get_firstDataSamplesInterval() * 1e3);
    itv = Math.round(await stream.get_dataSamplesInterval() * 1e3);
    if (fitv == 0) {
      fitv = itv;
    }
    if (tim < itv) {
      tim = itv;
    }
    nCols = dataRows[0].length;
    minCol = 0;
    if (nCols > 2) {
      avgCol = 1;
    } else {
      avgCol = 0;
    }
    if (nCols > 2) {
      maxCol = 2;
    } else {
      maxCol = 0;
    }
    firstMeasure = true;
    for (let ii in dataRows) {
      if (firstMeasure) {
        end_ = tim + fitv;
        firstMeasure = false;
      } else {
        end_ = tim + itv;
      }
      avgv = dataRows[ii][avgCol];
      if (end_ > this._startTimeMs && (this._endTimeMs == 0 || tim < this._endTimeMs) && !isNaN(avgv)) {
        this._measures.push(new YMeasure(tim / 1e3, end_ / 1e3, dataRows[ii][minCol], avgv, dataRows[ii][maxCol]));
      }
      tim = end_;
    }
    if (this._bulkLoad > 0 && this._progress < this._streams.length) {
      stream = this._streams[this._progress];
      if (stream.imm_wasLoaded()) {
        return await this.get_progress();
      }
      baseurl = stream.imm_get_baseurl();
      url = stream.imm_get_url();
      suffix = stream.imm_get_urlsuffix();
      suffixes.push(suffix);
      idx = this._progress + 1;
      while (idx < this._streams.length && suffixes.length < this._bulkLoad) {
        stream = this._streams[idx];
        if (!stream.imm_wasLoaded() && stream.imm_get_baseurl() == baseurl) {
          suffix = stream.imm_get_urlsuffix();
          suffixes.push(suffix);
          url = url + "," + suffix;
        }
        idx = idx + 1;
      }
      bulkFile = await this._parent._download(url);
      streamStr = this._parent.imm_json_get_array(bulkFile);
      urlIdx = 0;
      idx = this._progress;
      while (idx < this._streams.length && urlIdx < suffixes.length && urlIdx < streamStr.length) {
        stream = this._streams[idx];
        if (stream.imm_get_baseurl() == baseurl && stream.imm_get_urlsuffix() == suffixes[urlIdx]) {
          streamBin = this._yapi.imm_str2bin(streamStr[urlIdx]);
          stream.imm_parseStream(streamBin);
          urlIdx = urlIdx + 1;
        }
        idx = idx + 1;
      }
    }
    return await this.get_progress();
  }
  async get_privateDataStreams() {
    return this._streams;
  }
  async get_hardwareId() {
    let mo;
    if (!(this._hardwareId == "")) {
      return this._hardwareId;
    }
    mo = await this._parent.get_module();
    this._hardwareId = await mo.get_serialNumber() + "." + await this.get_functionId();
    return this._hardwareId;
  }
  async get_functionId() {
    return this._functionId;
  }
  async get_unit() {
    return this._unit;
  }
  async get_startTimeUTC() {
    return this.imm_get_startTimeUTC();
  }
  imm_get_startTimeUTC() {
    return this._startTimeMs / 1e3;
  }
  async get_endTimeUTC() {
    return this.imm_get_endTimeUTC();
  }
  imm_get_endTimeUTC() {
    return Math.round(this._endTimeMs / 1e3);
  }
  async get_progress() {
    if (this._progress < 0) {
      return 0;
    }
    if (this._progress >= this._streams.length) {
      return 100;
    }
    return (1 + (1 + this._progress) * 98) / (1 + this._streams.length) >> 0;
  }
  async loadMore() {
    let url;
    let stream;
    if (this._progress < 0) {
      url = "logger.json?id=" + this._functionId;
      if (this._startTimeMs != 0) {
        url = url + "&from=" + String(Math.round(this.imm_get_startTimeUTC()));
      }
      if (this._endTimeMs != 0) {
        url = url + "&to=" + String(Math.round(this.imm_get_endTimeUTC() + 1));
      }
    } else {
      if (this._progress >= this._streams.length) {
        return 100;
      } else {
        stream = this._streams[this._progress];
        if (stream.imm_wasLoaded()) {
          return await this.processMore(this._progress, this._yapi.imm_str2bin(""));
        }
        url = stream.imm_get_url();
      }
    }
    try {
      return await this.processMore(this._progress, await this._parent._download(url));
    } catch (e) {
      return await this.processMore(this._progress, await this._parent._download(url));
    }
  }
  async get_summary() {
    return this._summary;
  }
  async get_preview() {
    return this._preview;
  }
  async get_measuresAt(measure) {
    let startUtcMs;
    let stream;
    let dataRows = [];
    let measures = [];
    let tim;
    let itv;
    let end_;
    let nCols;
    let minCol;
    let avgCol;
    let maxCol;
    startUtcMs = measure.get_startTimeUTC() * 1e3;
    stream = null;
    for (let ii in this._streams) {
      if (Math.round(await this._streams[ii].get_realStartTimeUTC() * 1e3) == startUtcMs) {
        stream = this._streams[ii];
      }
    }
    if (stream == null) {
      return measures;
    }
    dataRows = await stream.get_dataRows();
    if (dataRows.length == 0) {
      return measures;
    }
    tim = Math.round(await stream.get_realStartTimeUTC() * 1e3);
    itv = Math.round(await stream.get_dataSamplesInterval() * 1e3);
    if (tim < itv) {
      tim = itv;
    }
    nCols = dataRows[0].length;
    minCol = 0;
    if (nCols > 2) {
      avgCol = 1;
    } else {
      avgCol = 0;
    }
    if (nCols > 2) {
      maxCol = 2;
    } else {
      maxCol = 0;
    }
    for (let ii in dataRows) {
      end_ = tim + itv;
      if (end_ > this._startTimeMs && (this._endTimeMs == 0 || tim < this._endTimeMs)) {
        measures.push(new YMeasure(tim / 1e3, end_ / 1e3, dataRows[ii][minCol], dataRows[ii][avgCol], dataRows[ii][maxCol]));
      }
      tim = end_;
    }
    return measures;
  }
  async get_measures() {
    return this._measures;
  }
  async _parse(str_json) {
    let loadval = null;
    try {
      loadval = JSON.parse(str_json);
    } catch (err) {
    }
    if (!loadval) {
      this._progress = 0;
      return await this.get_progress();
    }
    this._functionId = loadval.id;
    this._unit = loadval.unit;
    this._bulkLoad = loadval.bulk ? parseInt(loadval.bulk) : 0;
    if (loadval.calib) {
      this._calib = this._yapi.imm_decodeFloats(loadval.calib);
      this._calib[0] = this._calib[0] / 1e3 >> 0;
    } else {
      this._calib = this._yapi.imm_decodeWords(loadval.cal);
    }
    this._summary = new YMeasure(0, 0, 0, 0, 0);
    this._streams = [];
    this._preview = [];
    this._measures = [];
    for (let i = 0; i < loadval.streams.length; i++) {
      let stream = this._parent.imm_findDataStream(this, loadval.streams[i]);
      if (!stream)
        continue;
      let streamStartTime = await stream.get_realStartTimeUTC() * 1e3;
      let streamEndTime = streamStartTime + await stream.get_realDuration() * 1e3;
      if (this._startTimeMs > 0 && streamEndTime <= this._startTimeMs) {
      } else if (this._endTimeMs > 0 && streamStartTime >= this._endTimeMs) {
      } else {
        this._streams.push(stream);
      }
    }
    this._progress = 0;
    return this.get_progress();
  }
};
YDataSet.DATA_INVALID = YAPI_INVALID_DOUBLE;
YDataSet.DURATION_INVALID = YAPI_INVALID_DOUBLE;
YDataSet.HARDWAREID_INVALID = YAPI_INVALID_STRING;
YDataSet.FUNCTIONID_INVALID = YAPI_INVALID_STRING;
YDataSet.UNIT_INVALID = YAPI_INVALID_STRING;
YDataSet.DATA_INVALID = YAPI_INVALID_DOUBLE;
YDataSet.DURATION_INVALID = YAPI_INVALID_DOUBLE;
YDataSet.HARDWAREID_INVALID = YAPI_INVALID_STRING;
YDataSet.FUNCTIONID_INVALID = YAPI_INVALID_STRING;
YDataSet.UNIT_INVALID = YAPI_INVALID_STRING;
var YDevice = class {
  constructor(obj_yapi, str_rooturl, obj_wpRec, obj_ypRecs) {
    this._yapi = obj_yapi;
    this._rootUrl = str_rooturl;
    this._serialNumber = "";
    this._logicalName = "";
    this._productName = "";
    this._productId = 0;
    this._beacon = 0;
    this._devYdx = -1;
    this._lastErrorType = YAPI_SUCCESS;
    this._lastErrorMsg = "no error";
    this._cache = {_expiration: 0, _json: new Uint8Array(0), _precooked: {}};
    this._functions = [];
    this._busy = 0;
    this._pendingQueries = Promise.resolve();
    this._lastTimeRef = 0;
    this._lastDuration = 0;
    this._logCallback = null;
    this._logIsPulling = false;
    this._logpos = 0;
    if (obj_wpRec && obj_ypRecs) {
      this._serialNumber = obj_wpRec.serialNumber;
      this._logicalName = obj_wpRec.logicalName;
      this._productName = obj_wpRec.productName;
      this._productId = obj_wpRec.productId;
      this._beacon = obj_wpRec.beacon;
      this._devYdx = obj_wpRec.index == void 0 ? -1 : obj_wpRec.index;
      this.imm_updateFromYP(obj_ypRecs);
      this._yapi.imm_reindexDevice(this);
    }
  }
  _throw(int_errType, str_errMsg, obj_retVal) {
    this._lastErrorType = int_errType;
    this._lastErrorMsg = str_errMsg;
    return this._yapi._throw(int_errType, str_errMsg, obj_retVal);
  }
  imm_getRootUrl() {
    return this._rootUrl;
  }
  imm_getSerialNumber() {
    return this._serialNumber;
  }
  imm_getLogicalName() {
    return this._logicalName;
  }
  async getLogicalName() {
    if (this._cache._expiration == 0) {
      await this.refresh();
    }
    return this._logicalName;
  }
  imm_getProductName() {
    return this._productName;
  }
  imm_getProductId() {
    return this._productId;
  }
  imm_getBeacon() {
    return this._beacon;
  }
  async getBeacon() {
    if (this._cache._expiration == 0) {
      await this.refresh();
    }
    return this._beacon;
  }
  imm_getLastTimeRef() {
    return this._lastTimeRef;
  }
  imm_getLastDuration() {
    return this._lastDuration;
  }
  imm_triggerLogPull() {
    if (this._logCallback == null || this._logIsPulling) {
      return;
    }
    this._logIsPulling = true;
    let request = "GET logs.txt?pos=" + this._logpos;
    let prom = this._yapi.devRequest(this._rootUrl, request, null, 0);
    prom.then(async (yreq) => {
      if (yreq.errorType != YAPI_SUCCESS) {
        this._logIsPulling = false;
        return;
      }
      if (this._logCallback == null) {
        this._logIsPulling = false;
        return;
      }
      let resultStr = YAPI.imm_bin2str(yreq.bin_result);
      let pos = resultStr.lastIndexOf("\n@");
      if (pos < 0) {
        this._logIsPulling = false;
        return;
      }
      let logs = resultStr.substring(0, pos);
      let posStr = resultStr.substring(pos + 2);
      this._logpos = parseInt(posStr);
      let module = YModule.FindModuleInContext(this._yapi, this._serialNumber);
      let lines = logs.trim().split("\n");
      try {
        for (let i = 0; i < lines.length; i++) {
          await this._logCallback(module, lines[i]);
        }
      } catch (e) {
        this._yapi.imm_log("Exception in device log callback:", e);
      }
      this._logIsPulling = false;
    });
  }
  imm_registerLogCallback(callback) {
    this._logCallback = callback;
    if (callback != null) {
      this.imm_triggerLogPull();
    }
  }
  imm_setTimeRef(float_timestamp, float_duration) {
    this._lastTimeRef = float_timestamp;
    this._lastDuration = float_duration;
  }
  imm_getDevYdx() {
    return this._devYdx;
  }
  imm_describe() {
    let res = this._rootUrl;
    if (this._serialNumber != "") {
      res = this._serialNumber;
      if (this._logicalName != "") {
        res = res + " (" + this._logicalName + ")";
      }
    }
    return this._productName + " " + res;
  }
  imm_updateFromYP(obj_ypRecs) {
    let funidx = 0;
    for (let categ in obj_ypRecs) {
      for (let key in obj_ypRecs[categ]) {
        let rec = obj_ypRecs[categ][key];
        let hwid = rec["hardwareId"];
        let dotpos = hwid.indexOf(".");
        if (hwid.substr(0, dotpos) == this._serialNumber) {
          let funydx = rec["index"];
          if (funydx == void 0)
            funydx = funidx;
          this._functions[funydx] = [hwid.substr(dotpos + 1), rec["logicalName"]];
          funidx++;
        }
      }
    }
  }
  async updateFromReq(yreq, loadval) {
    this._cache._expiration = this._yapi.GetTickCount() + this._yapi.defaultCacheValidity;
    this._cache._json = yreq.bin_result;
    let func;
    let reindex = false;
    if (this._productName == "") {
      for (func in loadval) {
        if (func == "module") {
          this._serialNumber = loadval.module.serialNumber;
          this._logicalName = loadval.module.logicalName;
          this._productName = loadval.module.productName;
          this._productId = loadval.module.productId;
          this._beacon = loadval.module.beacon;
        } else if (func == "services") {
          this.imm_updateFromYP(loadval.services.yellowPages);
        }
      }
      reindex = true;
    } else {
      let renamed = false;
      for (func in loadval) {
        if (func == "module") {
          if (this._logicalName != loadval.module.logicalName) {
            this._logicalName = loadval.module.logicalName;
            reindex = true;
          }
          this._beacon = loadval.module.beacon;
        } else if (func != "services") {
          let name = loadval[func]["logicalName"];
          if (name == void 0)
            name = loadval.module.logicalName;
          let pubval = loadval[func]["advertisedValue"];
          if (pubval != void 0) {
            await this._yapi.setFunctionValue(loadval.module.serialNumber + "." + func, pubval);
          }
          let funydx;
          for (funydx in this._functions) {
            if (this._functions[funydx][0] == func) {
              if (this._functions[funydx][1] != name) {
                this._functions[funydx][1] = name;
                reindex = true;
              }
              break;
            }
          }
        }
      }
    }
    if (reindex) {
      this._yapi.imm_reindexDevice(this);
    }
  }
  imm_dropCache() {
    this._cache._expiration = 0;
    this._cache._precooked = {};
  }
  imm_functionCount() {
    let funcPos = 0;
    for (let key in this._functions) {
      funcPos++;
    }
    return funcPos;
  }
  imm_functionId(int_idx) {
    let funcPos = 0;
    for (let key in this._functions) {
      if (int_idx === funcPos) {
        return this._functions[key][0];
      }
      funcPos++;
    }
    return "";
  }
  imm_functionBaseType(int_idx) {
    let funid = this.imm_functionId(int_idx);
    if (funid !== "") {
      let ftype = this._yapi.imm_getFunctionBaseType(this._serialNumber + "." + funid);
      for (let baseType in Y_BASETYPES) {
        if (Y_BASETYPES[baseType] === ftype) {
          return baseType;
        }
      }
    }
    return "Function";
  }
  imm_functionType(int_idx) {
    let funid = this.imm_functionId(int_idx);
    if (funid !== "") {
      let i;
      for (i = funid.length; i > 0; i--) {
        if (funid[i - 1] > "9") {
          break;
        }
      }
      let functionType = funid[0].toUpperCase() + funid.substr(1, i - 1);
      return functionType;
    }
    return "";
  }
  imm_functionName(int_idx) {
    let funcPos = 0;
    for (let key in this._functions) {
      if (int_idx === funcPos) {
        return this._functions[key][1];
      }
      funcPos++;
    }
    return "";
  }
  imm_functionValue(int_idx) {
    let funid = this.imm_functionId(int_idx);
    if (funid !== "") {
      return this._yapi.imm_getFunctionValue(this._serialNumber + "." + funid);
    }
    return "";
  }
  imm_functionIdByFunYdx(int_funydx) {
    if (this._functions[int_funydx]) {
      return this._functions[int_funydx][0];
    }
    return "";
  }
  imm_jzon2json(jzon, json) {
    if (Array.isArray(jzon)) {
      let sz = jzon.length;
      if (Array.isArray(json)) {
        let defval = json.length > 0 ? json[0] : null;
        let res = [];
        for (let idx = 0; idx < sz; idx++) {
          res[idx] = this.imm_jzon2json(jzon[idx], defval);
        }
        return res;
      } else if (typeof json === "object") {
        let idx = 0;
        let res = {};
        for (let key in json) {
          if (json.hasOwnProperty(key)) {
            res[key] = this.imm_jzon2json(jzon[idx], json[key]);
            idx++;
          }
        }
        return res;
      } else {
        return jzon;
      }
    } else if (typeof jzon === "object") {
      if (Array.isArray(json)) {
        return jzon;
      } else if (typeof json === "object") {
        let defval = null;
        for (let key in json) {
          if (json.hasOwnProperty(key)) {
            defval = json[key];
            break;
          }
        }
        let res = {};
        for (let key in jzon) {
          if (jzon.hasOwnProperty(key)) {
            if (json.hasOwnProperty(key) && (!Array.isArray(json[key]) || json[key].length > 0)) {
              res[key] = this.imm_jzon2json(jzon[key], json[key]);
            } else {
              res[key] = this.imm_jzon2json(jzon[key], defval);
            }
          }
        }
        return res;
      } else {
        return jzon;
      }
    }
    return jzon;
  }
  async requestAPI(int_msValidity) {
    if (this._cache._expiration > this._yapi.GetTickCount()) {
      let res = new YHTTPRequest(this._cache._json);
      res.obj_result = JSON.parse(JSON.stringify(this._cache._precooked));
      return res;
    }
    let req = "GET /api.json";
    let precooked = this._cache._precooked;
    if (precooked.module && precooked.module.firmwareRelease) {
      req += "?fw=" + encodeURIComponent(precooked.module.firmwareRelease);
    }
    let yreq = await this._yapi.devRequest(this._rootUrl, req, null, 0);
    if (yreq.errorType != YAPI_SUCCESS)
      return yreq;
    if (!int_msValidity) {
      int_msValidity = this._yapi.defaultCacheValidity;
    }
    this._cache._json = yreq.bin_result;
    try {
      yreq.obj_result = JSON.parse(this._yapi.imm_bin2str(yreq.bin_result));
      if (Array.isArray(yreq.obj_result)) {
        if (precooked.module) {
          let objres = this.imm_jzon2json(yreq.obj_result, precooked);
          yreq.obj_result = objres;
          if (objres.module && objres.module.serialNumber === objres.module.serialNumber && objres.module.firmwareRelease === objres.module.firmwareRelease) {
            let jsonstr = JSON.stringify(yreq.obj_result);
            this._cache._json = yreq.bin_result = this._yapi.imm_str2bin(jsonstr);
            this._cache._precooked = JSON.parse(jsonstr);
          } else {
            this.imm_dropCache();
            yreq.errorType = YAPI_IO_ERROR;
            yreq.errorMsg = "Request failed, could not parse API JZON result for " + this._rootUrl;
          }
        } else {
          yreq.errorType = YAPI_IO_ERROR;
          yreq.errorMsg = "Request failed, could not parse API array result for " + this._rootUrl;
        }
      } else if (yreq.obj_result.module && yreq.obj_result.module.firmwareRelease) {
        this._cache._precooked = JSON.parse(JSON.stringify(yreq.obj_result));
      }
      this._cache._expiration = this._yapi.GetTickCount() + int_msValidity;
      this._logicalName = yreq.obj_result.module.logicalName;
      this._beacon = yreq.obj_result.module.beacon;
    } catch (err) {
      yreq.errorType = YAPI_IO_ERROR;
      yreq.errorMsg = "Request failed, could not parse API JSON result for " + this._rootUrl;
    }
    return yreq;
  }
  async refresh() {
    let yreq = await this.requestAPI(this._yapi.defaultCacheValidity);
    if (yreq.errorType != YAPI_SUCCESS) {
      return this._throw(yreq.errorType, yreq.errorMsg, yreq.errorType);
    }
    await this.updateFromReq(yreq, yreq.obj_result);
    return YAPI_SUCCESS;
  }
};
var YFirmwareFile = class {
  constructor(path, serial, pictype, product, firmware, prog_version, ROM_nb_zone, FLA_nb_zone, ROM_total_size, FLA_total_size, data, zone_ofs) {
    this._path = path;
    this._serial = serial;
    this._pictype = pictype;
    this._product = product;
    this._firmware = firmware;
    this._prog_version = prog_version;
    this._ROM_nb_zone = ROM_nb_zone;
    this._FLA_nb_zone = FLA_nb_zone;
    this._ROM_total_size = ROM_total_size;
    this._FLA_total_size = FLA_total_size;
    this._data = data;
    this._zone_ofs = zone_ofs;
  }
  static imm_Parse(path, data, force) {
    const BYN_REV_V4 = 4;
    const BYN_REV_V5 = 5;
    const BYN_REV_V6 = 6;
    const MAX_ROM_ZONES_PER_FILES = 16;
    const MAX_FLASH_ZONES_PER_FILES = 4;
    const BYN_HEAD_SIZE_V4 = 96 + 8;
    const BYN_HEAD_SIZE_V5 = 96 + 32;
    const BYN_HEAD_SIZE_V6 = 96 + 48;
    const BYN_MD5_OFS_V6 = 96 + 16;
    let pos = 0;
    let getShort = () => {
      let res = data[pos] + (data[pos + 1] << 8);
      pos += 2;
      return res;
    };
    let getInt = () => {
      let res = data[pos] + (data[pos + 1] << 8) + (data[pos + 2] << 16) + (data[pos + 3] << 24);
      pos += 4;
      return res;
    };
    let getString = (maxlen) => {
      let end = pos + maxlen;
      while (end > pos && data[end - 1] == 0) {
        end--;
      }
      let res = YAPI.imm_bin2str(data.subarray(pos, end));
      pos += maxlen;
      return res;
    };
    let sign = getString(4);
    if (sign != "BYN")
      return null;
    let rev = getShort();
    let serial = getString(20);
    let pictype = getString(20);
    let product = getString(28);
    let firmware = getString(22);
    if (serial.length >= 20)
      return null;
    if (product.length >= 28)
      return null;
    if (firmware.length >= 22)
      return null;
    let ROM_nb_zone = 0;
    let FLA_nb_zone = 0;
    let ROM_total_size = 0;
    let FLA_total_size = 0;
    let prog_buf;
    let prog_version = "";
    let zone_ofs;
    let datasize;
    switch (rev) {
      case BYN_REV_V4:
        zone_ofs = BYN_HEAD_SIZE_V4;
        ROM_nb_zone = getInt();
        datasize = getInt();
        if (ROM_nb_zone > MAX_ROM_ZONES_PER_FILES)
          return null;
        if (datasize != data.length - BYN_HEAD_SIZE_V4)
          return null;
        break;
      case BYN_REV_V5:
        zone_ofs = BYN_HEAD_SIZE_V5;
        prog_version = getString(22);
        if (!force && !YFirmwareFile.imm_progCompatible(prog_version))
          return null;
        getShort();
        ROM_nb_zone = getInt();
        datasize = getInt();
        if (ROM_nb_zone > MAX_ROM_ZONES_PER_FILES)
          return null;
        if (datasize != data.length - BYN_HEAD_SIZE_V5)
          return null;
        break;
      case BYN_REV_V6:
        zone_ofs = BYN_HEAD_SIZE_V6;
        let md5hdr = data.subarray(pos, pos + 16);
        pos += 16;
        let md5hdrstr = YAPI.imm_bin2hexstr(md5hdr);
        let md5ctx = new Y_MD5Ctx();
        md5ctx.addData(data.subarray(BYN_MD5_OFS_V6));
        let md5bynstr = YAPI.imm_bin2hexstr(md5ctx.calculate());
        if (md5hdrstr != md5bynstr) {
          YAPI.imm_log("Invalid firmware image signature, file is corrupt");
          if (YAPI._logLevel >= 2) {
            YAPI.imm_log("hdr MD5: " + md5hdrstr);
            YAPI.imm_log("byn MD5: " + md5bynstr);
            YAPI.imm_log("byn size: " + data.length);
          }
          return null;
        }
        prog_version = getString(22);
        if (!force && !YFirmwareFile.imm_progCompatible(prog_version))
          return null;
        ROM_nb_zone = data[pos++];
        FLA_nb_zone = data[pos++];
        ROM_total_size = getInt();
        FLA_total_size = getInt();
        if (ROM_nb_zone > MAX_ROM_ZONES_PER_FILES)
          return null;
        if (FLA_nb_zone > MAX_FLASH_ZONES_PER_FILES)
          return null;
        break;
      default:
        return null;
    }
    return new YFirmwareFile(path, serial, pictype, product, firmware, prog_version, ROM_nb_zone, FLA_nb_zone, ROM_total_size, FLA_total_size, data, zone_ofs);
  }
  static imm_progCompatible(prog_version) {
    if (prog_version == "")
      return true;
    let apiVer = YAPI.imm_GetAPIVersion();
    let dashpos = apiVer.indexOf("-");
    if (dashpos > 0) {
      apiVer = apiVer.slice(0, dashpos);
    }
    apiVer = apiVer.slice(apiVer.lastIndexOf(".") + 1);
    if (parseInt(prog_version) > parseInt(apiVer)) {
      YAPI.imm_log("checkProgField: byn=" + prog_version + " api=" + apiVer);
      return false;
    }
    return true;
  }
  imm_getSerial() {
    return this._serial;
  }
  imm_getPictype() {
    return this._pictype;
  }
  imm_getProduct() {
    return this._product;
  }
  imm_getFirmwareRelease() {
    return this._firmware;
  }
  imm_getFirmwareReleaseAsInt() {
    return parseInt(this._firmware);
  }
  imm_getProg_version() {
    return this._prog_version;
  }
  imm_getROM_nb_zone() {
    return this._ROM_nb_zone;
  }
  imm_getFLA_nb_zone() {
    return this._FLA_nb_zone;
  }
  imm_getROM_total_size() {
    return this._ROM_total_size;
  }
  imm_getFLA_total_size() {
    return this._FLA_total_size;
  }
  imm_getData() {
    return this._data;
  }
  imm_getPath() {
    return this._path;
  }
};
var YFirmwareUpdate = class {
  constructor(obj_yapi, str_serial, str_path, bin_settings, bool_force) {
    this._serial = "";
    this._settings = new Uint8Array(0);
    this._firmwarepath = "";
    this._progress_msg = "";
    this._progress_c = 0;
    this._progress = 0;
    this._restore_step = 0;
    this._force = false;
    this._yapi = obj_yapi;
    this._serial = str_serial;
    this._firmwarepath = str_path;
    this._settings = bin_settings;
    this._force = bool_force;
  }
  imm_progress(progress, msg) {
    this._progress = progress;
    this._progress_msg = msg;
  }
  async _processMore_internal(newupdate) {
    if (!newupdate)
      return YAPI_SUCCESS;
    let bytes;
    this.imm_progress(0, "Firmware update started");
    if (typeof this._firmwarepath == "string" && this._firmwarepath.indexOf("yoctopuce.com") >= 0) {
      this.imm_progress(1, "Downloading firmware");
      bytes = await this._yapi.system_env.downloadfile(this._firmwarepath);
    } else {
      this.imm_progress(1, "Loading firmware");
      bytes = await this._yapi.system_env.loadfile(this._firmwarepath);
    }
    let firmware = YFirmwareFile.imm_Parse(this._firmwarepath, bytes, this._force);
    if (!firmware) {
      return this._yapi._throw(YAPI_DEVICE_NOT_FOUND, "Device " + this._serial + " is not detected", YAPI_DEVICE_NOT_FOUND);
    }
    this.imm_progress(5, "Check if module is already in bootloader");
    let hub = null;
    let module = YModule.FindModuleInContext(this._yapi, this._serial + ".module");
    if (await module.isOnline()) {
      let dev = this._yapi.imm_getDevice(this._serial);
      let baseUrl = dev.imm_getRootUrl();
      let byPos = baseUrl.indexOf("/bySerial/");
      if (byPos >= 0) {
        baseUrl = baseUrl.slice(0, byPos + 1);
      } else if (baseUrl.slice(-1) != "/")
        baseUrl = baseUrl + "/";
      let urlInfo = this._yapi.imm_parseRegisteredUrl(baseUrl);
      hub = this._yapi.imm_getHub(urlInfo);
    } else {
      let hubs = this._yapi._connectedHubs;
      for (let i = 0; i < hubs.length; i++) {
        let ldrs = await hubs[i].getBootloaders();
        if (ldrs.indexOf(this._serial) >= 0) {
          hub = hubs[i];
          break;
        }
      }
    }
    if (hub == null) {
      this.imm_progress(-1, "Device " + this._serial + " is not detected");
      return this._yapi._throw(YAPI_DEVICE_NOT_FOUND, "Device " + this._serial + " is not detected", YAPI_DEVICE_NOT_FOUND);
    }
    try {
      await hub.firmwareUpdate(this._serial, firmware, this._settings, (percent, msg) => {
        this.imm_progress(5 + (percent * 80 + 50) / 100 >> 0, msg);
      });
    } catch (e) {
      this.imm_progress(-1, e.message);
      return this._yapi._throw(YAPI_IO_ERROR, e.message, YAPI_IO_ERROR);
    }
    this.imm_progress(80, "Wait for the device to restart");
    let timeout = this._yapi.GetTickCount() + 6e4;
    await module.clearCache();
    while (!await module.isOnline() && timeout > this._yapi.GetTickCount()) {
      await this._yapi.Sleep(500);
      await this._yapi.UpdateDeviceList();
    }
    if (await module.isOnline()) {
      if (this._settings != null) {
        this.imm_progress(95, "Restoring device settings");
        await module.set_allSettingsAndFiles(this._settings);
        await module.saveToFlash();
      }
      let real_fw = await module.get_firmwareRelease();
      if (real_fw == firmware.imm_getFirmwareRelease()) {
        this.imm_progress(100, "Success");
      } else {
        this.imm_progress(-1, "Unable to update firmware");
      }
    } else {
      this.imm_progress(-1, "Device did not reboot correctly");
    }
    return YAPI_SUCCESS;
  }
  static async checkFirmware_r(file, serial_base, force) {
    if (file.substr(-4).toLowerCase() != ".byn")
      return null;
    let bynfile = await YAPI.system_env.loadfile(file);
    let firmware = YFirmwareFile.imm_Parse(file, bynfile, force);
    if (!firmware)
      return null;
    if (firmware.imm_getSerial().slice(0, serial_base.length) != serial_base)
      return null;
    return firmware;
  }
  static async CheckFirmwareEx(serial, path, minrelease, force) {
    let link = "";
    let best_rev = 0;
    let current_rev;
    if (typeof path == "string" && path.indexOf("yoctopuce.com") >= 0) {
      try {
        let data = await YAPI.system_env.downloadfile("http://www.yoctopuce.com/FR/common/getLastFirmwareLink.php?serial=" + serial);
        let obj = JSON.parse(YAPI.imm_bin2str(data));
        link = obj["link"];
        best_rev = obj["version"];
      } catch (e) {
        YAPI.imm_log("failed to retrieve firmware information from www.yoctopuce.com", e);
        YAPI._throw(YAPI_IO_ERROR, "failed to retrieve firmware information from www.yoctopuce.com", "");
        return "";
      }
    } else {
      let firmware = await YFirmwareUpdate.checkFirmware_r(path, serial.substring(0, 8), force);
      if (firmware != null) {
        best_rev = firmware.imm_getFirmwareReleaseAsInt();
        link = firmware.imm_getPath();
      }
    }
    if (minrelease != 0) {
      if (minrelease < best_rev) {
        return link;
      } else {
        return "";
      }
    }
    return link;
  }
  static async CheckFirmware_internal(serial, path, minrelease) {
    return YFirmwareUpdate.CheckFirmwareEx(serial, path, minrelease, false);
  }
  static async GetAllBootLoadersInContext_internal(yctx) {
    let hubs = yctx._connectedHubs;
    let res = [];
    for (let i = 0; i < hubs.length; i++) {
      let ldrs = await hubs[i].getBootloaders();
      for (let j = 0; j < ldrs.length; j++) {
        res.push(ldrs[j]);
      }
    }
    return res;
  }
  static async GetAllBootLoaders_internal() {
    return YFirmwareUpdate.GetAllBootLoadersInContext(YAPI);
  }
  async _processMore(newupdate) {
    return await this._processMore_internal(newupdate);
  }
  static async GetAllBootLoaders() {
    return await this.GetAllBootLoaders_internal();
  }
  static async GetAllBootLoadersInContext(yctx) {
    return await this.GetAllBootLoadersInContext_internal(yctx);
  }
  static async CheckFirmware(serial, path, minrelease) {
    return await this.CheckFirmware_internal(serial, path, minrelease);
  }
  async get_progress() {
    if (this._progress >= 0) {
      await this._processMore(0);
    }
    return this._progress;
  }
  async get_progressMessage() {
    return this._progress_msg;
  }
  async startUpdate() {
    let err;
    let leng;
    err = this._yapi.imm_bin2str(this._settings);
    leng = err.length;
    if (leng >= 6 && err.substr(0, 6) == "error:") {
      this._progress = -1;
      this._progress_msg = err.substr(6, leng - 6);
    } else {
      this._progress = 0;
      this._progress_c = 0;
      await this._processMore(1);
    }
    return this._progress;
  }
};
var YFunction = class {
  constructor(obj_yapi, str_func) {
    this._logicalName = YFunction.LOGICALNAME_INVALID;
    this._advertisedValue = YFunction.ADVERTISEDVALUE_INVALID;
    this._valueCallbackFunction = null;
    this._cacheExpiration = 0;
    this._serial = "";
    this._funId = "";
    this._hwId = "";
    this.LOGICALNAME_INVALID = YAPI_INVALID_STRING;
    this.ADVERTISEDVALUE_INVALID = YAPI_INVALID_STRING;
    this._yapi = obj_yapi;
    this._className = "Function";
    this._func = str_func;
    this._lastErrorType = YAPI_SUCCESS;
    this._lastErrorMsg = "no error";
    this._dataStreams = {};
    this._userData = null;
    this._cache = {_expiration: -1, functionid: "", hwid: ""};
    this._valueCallbackFunction = null;
  }
  _throw(int_errType, str_errMsg, obj_retVal) {
    this._lastErrorType = int_errType;
    this._lastErrorMsg = str_errMsg;
    return this._yapi._throw(int_errType, str_errMsg, obj_retVal);
  }
  async isReadOnly_internal() {
    try {
      let serial = await this.get_serialNumber();
      return this._yapi.isReadOnly(serial);
    } catch (e) {
      return true;
    }
  }
  imm_parseAttr(name, val) {
    switch (name) {
      case "_expiration":
        this._cacheExpiration = val;
        return 1;
      case "logicalName":
        this._logicalName = val;
        return 1;
      case "advertisedValue":
        this._advertisedValue = val;
        return 1;
    }
    return 0;
  }
  async get_logicalName() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YFunction.LOGICALNAME_INVALID;
      }
    }
    res = this._logicalName;
    return res;
  }
  async set_logicalName(newval) {
    let rest_val;
    if (!await YAPI.CheckLogicalName(newval)) {
      return this._throw(YAPI.INVALID_ARGUMENT, "Invalid name :" + newval, YAPI.INVALID_ARGUMENT);
    }
    rest_val = String(newval);
    return await this._setAttr("logicalName", rest_val);
  }
  async get_advertisedValue() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YFunction.ADVERTISEDVALUE_INVALID;
      }
    }
    res = this._advertisedValue;
    return res;
  }
  async set_advertisedValue(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("advertisedValue", rest_val);
  }
  static FindFunction(func) {
    let obj;
    obj = YFunction._FindFromCache("Function", func);
    if (obj == null) {
      obj = new YFunction(YAPI, func);
      YFunction._AddToCache("Function", func, obj);
    }
    return obj;
  }
  static FindFunctionInContext(yctx, func) {
    let obj;
    obj = YFunction._FindFromCacheInContext(yctx, "Function", func);
    if (obj == null) {
      obj = new YFunction(yctx, func);
      YFunction._AddToCache("Function", func, obj);
    }
    return obj;
  }
  async registerValueCallback(callback) {
    let val;
    if (callback != null) {
      await YFunction._UpdateValueCallbackList(this, true);
    } else {
      await YFunction._UpdateValueCallbackList(this, false);
    }
    this._valueCallbackFunction = callback;
    if (callback != null && await this.isOnline()) {
      val = this._advertisedValue;
      if (!(val == "")) {
        await this._invokeValueCallback(val);
      }
    }
    return 0;
  }
  async _invokeValueCallback(value) {
    if (this._valueCallbackFunction != null) {
      try {
        await this._valueCallbackFunction(this, value);
      } catch (e) {
        this._yapi.imm_log("Exception in valueCallback:", e);
      }
    } else {
    }
    return 0;
  }
  async muteValueCallbacks() {
    return await this.set_advertisedValue("SILENT");
  }
  async unmuteValueCallbacks() {
    return await this.set_advertisedValue("");
  }
  async loadAttribute(attrName) {
    let url;
    let attrVal;
    url = "api/" + await this.get_functionId() + "/" + attrName;
    attrVal = await this._download(url);
    return this._yapi.imm_bin2str(attrVal);
  }
  async isReadOnly() {
    return await this.isReadOnly_internal();
  }
  async get_serialNumber() {
    let m;
    m = await this.get_module();
    return await m.get_serialNumber();
  }
  async _parserHelper() {
    return 0;
  }
  nextFunction() {
    let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
    if (resolve.errorType != YAPI.SUCCESS)
      return null;
    let next_hwid = this._yapi.imm_getNextHardwareId(this._className, resolve.result);
    if (next_hwid == null)
      return null;
    return YFunction.FindFunctionInContext(this._yapi, next_hwid);
  }
  static FirstFunction() {
    let next_hwid = YAPI.imm_getFirstHardwareId("Function");
    if (next_hwid == null)
      return null;
    return YFunction.FindFunction(next_hwid);
  }
  static FirstFunctionInContext(yctx) {
    let next_hwid = yctx.imm_getFirstHardwareId("Function");
    if (next_hwid == null)
      return null;
    return YFunction.FindFunctionInContext(yctx, next_hwid);
  }
  static _FindFromCacheInContext(yctx, className, func) {
    return yctx.imm_getFunction(className, func);
  }
  static _FindFromCache(className, func) {
    return YAPI.imm_getFunction(className, func);
  }
  static _AddToCache(className, func, obj) {
    obj._yapi.imm_setFunction(className, func, obj);
  }
  static _ClearCache(obj_yapi = null) {
    if (!obj_yapi)
      obj_yapi = YAPI;
    obj_yapi.imm_ResetToDefaults();
  }
  static async _UpdateValueCallbackList(obj_func, bool_add) {
    await obj_func._yapi._UpdateValueCallbackList(obj_func, bool_add);
  }
  static async _UpdateTimedReportCallbackList(obj_func, bool_add) {
    await obj_func._yapi._UpdateTimedReportCallbackList(obj_func, bool_add);
  }
  async describe() {
    if (this._hwId != "") {
      return this._className + "(" + this._func + ")=" + this._hwId;
    }
    let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
    if (resolve.errorType != YAPI_SUCCESS && resolve.result != this._func) {
      return this._className + "(" + this._func + ")=unresolved";
    }
    return this._className + "(" + this._func + ")=" + resolve.result;
  }
  async get_hardwareId() {
    if (this._hwId != "") {
      return this._hwId;
    }
    let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
    if (resolve.errorType != YAPI_SUCCESS) {
      await this.isOnline();
      resolve = this._yapi.imm_resolveFunction(this._className, this._func);
      if (resolve.errorType != YAPI_SUCCESS) {
        return this._throw(resolve.errorType, resolve.errorMsg, YFunction.HARDWAREID_INVALID);
      }
    }
    return resolve.result;
  }
  async get_functionId() {
    if (this._funId != "") {
      return this._funId;
    }
    let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
    if (resolve.errorType != YAPI_SUCCESS) {
      await this.isOnline();
      resolve = this._yapi.imm_resolveFunction(this._className, this._func);
      if (resolve.errorType != YAPI_SUCCESS) {
        return this._throw(resolve.errorType, resolve.errorMsg, YFunction.FUNCTIONID_INVALID);
      }
    }
    let hardwareId = resolve.result;
    let pos = hardwareId.indexOf(".");
    return hardwareId.substr(pos + 1);
  }
  imm_get_functionId() {
    if (this._funId != "") {
      return this._funId;
    }
    let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
    if (resolve.errorType != YAPI_SUCCESS) {
      return this._throw(resolve.errorType, resolve.errorMsg, YFunction.FUNCTIONID_INVALID);
    }
    let hardwareId = resolve.result;
    let pos = hardwareId.indexOf(".");
    return hardwareId.substr(pos + 1);
  }
  async get_friendlyName() {
    let resolve = this._yapi.imm_getFriendlyNameFunction(this._className, this._func);
    if (resolve.errorType != YAPI_SUCCESS) {
      await this.isOnline();
      resolve = this._yapi.imm_getFriendlyNameFunction(this._className, this._func);
      if (resolve.errorType != YAPI_SUCCESS) {
        return this._throw(resolve.errorType, resolve.errorMsg, YFunction.FRIENDLYNAME_INVALID);
      }
    }
    return resolve.result;
  }
  async _parse(yreq, msValidity) {
    if (!yreq.obj_result)
      return;
    yreq.obj_result._expiration = this._yapi.GetTickCount() + msValidity;
    this._cache = yreq.obj_result;
    this._serial = yreq.obj_result.deviceid;
    this._funId = yreq.obj_result.functionid;
    this._hwId = yreq.obj_result.hwid;
    for (let key in yreq.obj_result) {
      this.imm_parseAttr(key, yreq.obj_result[key]);
    }
    await this._parserHelper();
  }
  isOnline_async(func, ctx) {
    this.isOnline().then((res) => {
      func(ctx, this, res);
    }).catch((e) => {
      func(ctx, this, false);
    });
  }
  load_async(ms_validiy, func, ctx) {
    this.load(ms_validiy).then((res) => {
      func(ctx, this, YAPI_SUCCESS);
    }).catch((e) => {
      func(ctx, this, this.get_errorType());
    });
  }
  async _getAttr(str_attr) {
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS)
        return null;
    }
    if (typeof this._cache[str_attr] == "undefined") {
      this._throw(YAPI_VERSION_MISMATCH, "No such attribute " + str_attr + " in function", null);
    }
    return this._cache[str_attr];
  }
  async _getFixedAttr(str_attr) {
    if (this._cacheExpiration == 0) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS)
        return null;
    }
    if (typeof this._cache[str_attr] == "undefined") {
      this._throw(YAPI_VERSION_MISMATCH, "No such attribute " + str_attr + " in function", null);
    }
    return this._cache[str_attr];
  }
  imm_escapeAttr(str_newval) {
    return escape(str_newval).replace(/[+]/g, "%2B").replace(/%20/g, "+").replace(/%21/g, "!").replace(/%24/g, "$").replace(/%27/g, "'").replace(/%28/g, "(").replace(/%29/g, ")").replace(/%2[cC]/g, ",").replace(/%2[fF]/g, "/").replace(/%3[aA]/g, ":").replace(/%3[bB]/g, ";").replace(/%3[fF]/g, "?").replace(/%5[bB]/g, "[").replace(/%5[dD]/g, "]");
  }
  async _setAttr(str_attr, str_newval) {
    if (str_newval == void 0) {
      return this._throw(YAPI_INVALID_ARGUMENT, "Undefined value to set for attribute " + str_attr, null);
    }
    let attrname = encodeURIComponent(str_attr);
    let attrval = this.imm_escapeAttr(str_newval);
    let extra = "/" + attrname + "?" + attrname + "=" + attrval + "&.";
    if (this._cacheExpiration != 0) {
      this._cacheExpiration = this._yapi.GetTickCount();
      this._cache._expiration = this._cacheExpiration;
    }
    let yreq = await this._yapi.funcRequest(this._className, this._func, extra);
    if (yreq.errorType != YAPI_SUCCESS) {
      return this._throw(yreq.errorType, yreq.errorMsg, yreq.errorType);
    }
    return YAPI_SUCCESS;
  }
  async _download(str_path) {
    let devid = this._serial;
    if (devid == "") {
      devid = await (await this.module()).get_serialNumber();
    }
    if (devid == YAPI_INVALID_STRING) {
      return new Uint8Array(0);
    }
    let yreq = await this._yapi.devRequest(devid, "GET /" + str_path, null, 0);
    if (yreq.errorType != YAPI_SUCCESS) {
      return this._throw(yreq.errorType, yreq.errorMsg, "");
    }
    return yreq.bin_result;
  }
  async _downloadOutOfBand(str_path) {
    let devid = this._serial;
    if (devid == "") {
      devid = await (await this.module()).get_serialNumber();
    }
    if (devid == YAPI_INVALID_STRING) {
      return new Uint8Array(0);
    }
    let yreq = await this._yapi.devRequest(devid, "GET /" + str_path, null, 1);
    if (yreq.errorType != YAPI_SUCCESS) {
      return this._throw(yreq.errorType, yreq.errorMsg, "");
    }
    return yreq.bin_result;
  }
  async _uploadWithProgress(str_path, bin_content, fun_progressCb) {
    let devid = this._serial;
    if (devid == "") {
      devid = await (await this.module()).get_serialNumber();
    }
    if (devid == YAPI_INVALID_STRING) {
      let res = new YHTTPRequest(null);
      res.errorType = this.get_errorType();
      res.errorMsg = this.get_errorMessage();
      return res;
    }
    let httpreq = "POST /upload.html";
    let len = bin_content.length;
    if (typeof bin_content == "string" || bin_content instanceof String) {
      bin_content = this._yapi.imm_str2bin(bin_content);
    } else if (bin_content instanceof Array) {
      bin_content = new Uint8Array(bin_content);
    }
    return this._yapi.devRequest(devid, httpreq, new YHTTPBody(str_path, bin_content, fun_progressCb), 0);
  }
  async _uploadEx(str_path, bin_content) {
    let yreq = await this._uploadWithProgress(str_path, bin_content, null);
    if (yreq.errorType != YAPI_SUCCESS) {
      return this._throw(yreq.errorType, yreq.errorMsg, null);
    }
    return yreq.bin_result;
  }
  async _upload(str_path, bin_content) {
    let yreq = await this._uploadWithProgress(str_path, bin_content, null);
    if (yreq.errorType != YAPI_SUCCESS) {
      return this._throw(yreq.errorType, yreq.errorMsg, null);
    }
    return yreq.errorType;
  }
  wait_async(callback, context) {
    let devid = this._serial;
    if (devid == "") {
      this.module().then((module) => module.get_serialNumber().then(() => this.wait_async(callback, context)));
      return YAPI_SUCCESS;
    }
    if (devid == YAPI_INVALID_STRING) {
      callback(context, this);
      return YAPI_SUCCESS;
    }
    let lockdev = this._yapi.imm_getDevice(devid);
    let delayedCode = () => {
      callback(context, this);
    };
    lockdev._pendingQueries = lockdev._pendingQueries.then(delayedCode, delayedCode);
    return YAPI_SUCCESS;
  }
  imm_json_get_key(bin_jsonbuff, str_key) {
    let loadval = JSON.parse(this._yapi.imm_bin2str(bin_jsonbuff));
    if (typeof loadval[str_key] != "undefined") {
      return loadval[str_key];
    }
    return "";
  }
  imm_json_get_string(bin_jsonbuff) {
    return JSON.parse(this._yapi.imm_bin2str(bin_jsonbuff));
  }
  imm_json_get_array(bin_jsonbuff) {
    let loadval = JSON.parse(this._yapi.imm_bin2str(bin_jsonbuff));
    let res = [];
    for (let idx in loadval) {
      res.push(JSON.stringify(loadval[idx]));
    }
    return res;
  }
  imm_get_json_path(str_json, str_path) {
    let json = JSON.parse(str_json);
    let paths = str_path.split("|");
    for (let i = 0; i < paths.length; i++) {
      let tmp = paths[i];
      json = json[tmp];
      if (json == void 0) {
        return "";
      }
    }
    return JSON.stringify(json);
  }
  imm_decode_json_string(str_json) {
    if (str_json === "") {
      return "";
    }
    return JSON.parse(str_json);
  }
  imm_findDataStream(obj_dataset, str_def) {
    let key = obj_dataset.imm_get_functionId() + ":" + str_def;
    if (this._dataStreams[key]) {
      return this._dataStreams[key];
    }
    let words = this._yapi.imm_decodeWords(str_def);
    if (words.length < 14) {
      this._throw(YAPI.VERSION_MISMATCH, "device firwmare is too old", null);
      return null;
    }
    let newDataStream = new YDataStream(this, obj_dataset, words);
    this._dataStreams[key] = newDataStream;
    return newDataStream;
  }
  async clearDataStreamCache() {
    this._dataStreams = {};
  }
  async isOnline() {
    if (this._cacheExpiration > this._yapi.GetTickCount())
      return true;
    let yreq = await this._yapi.funcRequest(this._className, this._func, "", this._yapi.defaultCacheValidity);
    if (yreq.errorType != YAPI_SUCCESS) {
      return yreq.errorType == YAPI_DEVICE_BUSY;
    }
    await this._parse(yreq, this._yapi.defaultCacheValidity);
    return true;
  }
  get_errorType() {
    return this._lastErrorType;
  }
  get_errorMessage() {
    return this._lastErrorMsg;
  }
  async load(msValidity) {
    let yreq = await this._yapi.funcRequest(this._className, this._func, "", msValidity);
    if (yreq.errorType != YAPI_SUCCESS) {
      return this._throw(yreq.errorType, yreq.errorMsg, yreq.errorType);
    }
    await this._parse(yreq, msValidity);
    return YAPI_SUCCESS;
  }
  async clearCache() {
    let devreq = await this._yapi._funcDev(this._className, this._func);
    if (devreq.errorType != YAPI_SUCCESS) {
      return;
    }
    devreq.obj_result.device.imm_dropCache();
    if (this._cacheExpiration > 0) {
      this._cacheExpiration = this._yapi.GetTickCount();
    }
  }
  async module() {
    if (this._serial != "") {
      return YModule.FindModuleInContext(this._yapi, this._serial + ".module");
    }
    let hwid = this._func;
    let resolve;
    if (hwid.indexOf(".") < 0) {
      resolve = this._yapi.imm_resolveFunction(this._className, this._func);
      if (resolve.errorType == YAPI_SUCCESS)
        hwid = resolve.result;
    }
    let dotidx = hwid.indexOf(".");
    if (dotidx >= 0) {
      return YModule.FindModuleInContext(this._yapi, hwid.substr(0, dotidx) + ".module");
    }
    if (await this.load(this._yapi.defaultCacheValidity) == YAPI_SUCCESS) {
      resolve = this._yapi.imm_resolveFunction(this._className, this._func);
      if (resolve.result)
        hwid = resolve.result;
    }
    dotidx = hwid.indexOf(".");
    if (dotidx >= 0) {
      return YModule.FindModuleInContext(this._yapi, hwid.substr(0, dotidx) + ".module");
    }
    return YModule.FindModuleInContext(this._yapi, "module_of_" + this._className + "_" + this._func);
  }
  async get_module() {
    return this.module();
  }
  async get_functionDescriptor() {
    if (this._hwId != "") {
      return this._hwId;
    }
    let hwid = this._func;
    if (hwid.indexOf(".") < 0) {
      let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
      if (resolve.errorType != YAPI_SUCCESS)
        hwid = resolve.result;
    }
    let dotidx = hwid.indexOf(".");
    if (dotidx >= 0) {
      return hwid;
    }
    return Y_FUNCTIONDESCRIPTOR_INVALID;
  }
  async get_userData() {
    return this._userData;
  }
  async set_userData(data) {
    this._userData = data;
  }
};
YFunction.LOGICALNAME_INVALID = YAPI_INVALID_STRING;
YFunction.ADVERTISEDVALUE_INVALID = YAPI_INVALID_STRING;
(function(YFunction2) {
  YFunction2.FUNCTIONDESCRIPTOR_INVALID = YAPI_INVALID_STRING;
  YFunction2.HARDWAREID_INVALID = YAPI_INVALID_STRING;
  YFunction2.FUNCTIONID_INVALID = YAPI_INVALID_STRING;
  YFunction2.FRIENDLYNAME_INVALID = YAPI_INVALID_STRING;
})(YFunction || (YFunction = {}));
var YModule = class extends YFunction {
  constructor(yapi, func) {
    super(yapi, func);
    this._productName = YModule.PRODUCTNAME_INVALID;
    this._serialNumber = YModule.SERIALNUMBER_INVALID;
    this._productId = YModule.PRODUCTID_INVALID;
    this._productRelease = YModule.PRODUCTRELEASE_INVALID;
    this._firmwareRelease = YModule.FIRMWARERELEASE_INVALID;
    this._persistentSettings = YModule.PERSISTENTSETTINGS_INVALID;
    this._luminosity = YModule.LUMINOSITY_INVALID;
    this._beacon = YModule.BEACON_INVALID;
    this._upTime = YModule.UPTIME_INVALID;
    this._usbCurrent = YModule.USBCURRENT_INVALID;
    this._rebootCountdown = YModule.REBOOTCOUNTDOWN_INVALID;
    this._userVar = YModule.USERVAR_INVALID;
    this._valueCallbackModule = null;
    this._logCallback = null;
    this._confChangeCallback = null;
    this._beaconCallback = null;
    this.PRODUCTNAME_INVALID = YAPI_INVALID_STRING;
    this.SERIALNUMBER_INVALID = YAPI_INVALID_STRING;
    this.PRODUCTID_INVALID = YAPI_INVALID_UINT;
    this.PRODUCTRELEASE_INVALID = YAPI_INVALID_UINT;
    this.FIRMWARERELEASE_INVALID = YAPI_INVALID_STRING;
    this.PERSISTENTSETTINGS_LOADED = 0;
    this.PERSISTENTSETTINGS_SAVED = 1;
    this.PERSISTENTSETTINGS_MODIFIED = 2;
    this.PERSISTENTSETTINGS_INVALID = -1;
    this.LUMINOSITY_INVALID = YAPI_INVALID_UINT;
    this.BEACON_OFF = 0;
    this.BEACON_ON = 1;
    this.BEACON_INVALID = -1;
    this.UPTIME_INVALID = YAPI_INVALID_LONG;
    this.USBCURRENT_INVALID = YAPI_INVALID_UINT;
    this.REBOOTCOUNTDOWN_INVALID = YAPI_INVALID_INT;
    this.USERVAR_INVALID = YAPI_INVALID_INT;
    this._className = "Module";
    let devid = this._func;
    let dotidx = devid.indexOf(".");
    if (dotidx > 0)
      devid = devid.substr(0, dotidx);
    let dev = this._yapi.imm_getDevice(devid);
    if (dev) {
      this._serial = dev.imm_getSerialNumber();
      this._funId = "module";
      this._hwId = this._serial + ".module";
    }
  }
  _throw(int_errType, str_errMsg, obj_retVal) {
    this._lastErrorType = int_errType;
    this._lastErrorMsg = str_errMsg;
    return this._yapi._throw(int_errType, str_errMsg, obj_retVal);
  }
  static async _updateModuleCallbackList(YModule_module, bool_add) {
  }
  imm_getDev() {
    let devid = this._func;
    let dotidx = devid.indexOf(".");
    if (dotidx > 0)
      devid = devid.substr(0, dotidx);
    let dev = this._yapi.imm_getDevice(devid);
    if (!dev) {
      this._throw(YAPI_DEVICE_NOT_FOUND, "Device [" + devid + "] is not online", null);
    }
    return dev;
  }
  async forceDeviceRefresh() {
    let dev = this.imm_getDev();
    if (!dev || !this._serial)
      return;
    await this._yapi.ForceDeviceRefresh(this._serial);
    if (this._cacheExpiration > 0) {
      this._cacheExpiration = this._yapi.GetTickCount();
    }
  }
  async functionCount() {
    let dev = this.imm_getDev();
    if (!dev)
      return YAPI_DEVICE_NOT_FOUND;
    return dev.imm_functionCount();
  }
  async functionId(functionIndex) {
    let dev = this.imm_getDev();
    if (!dev)
      return "";
    return dev.imm_functionId(functionIndex);
  }
  async functionType(functionIndex) {
    let dev = this.imm_getDev();
    if (!dev)
      return "";
    return dev.imm_functionType(functionIndex);
  }
  async functionBaseType(functionIndex) {
    let dev = this.imm_getDev();
    if (!dev)
      return "";
    return dev.imm_functionBaseType(functionIndex);
  }
  async functionName(functionIndex) {
    let dev = this.imm_getDev();
    if (!dev)
      return "";
    return dev.imm_functionName(functionIndex);
  }
  async functionValue(functionIndex) {
    let dev = this.imm_getDev();
    if (!dev)
      return "";
    return dev.imm_functionValue(functionIndex);
  }
  async get_logicalName() {
    let dev = this.imm_getDev();
    if (dev != null && this._cache._expiration <= this._yapi.GetTickCount()) {
      return dev.getLogicalName();
    }
    let json_val = await this._getAttr("logicalName");
    return json_val == null ? YModule.LOGICALNAME_INVALID : json_val;
  }
  async set_logicalName(newval) {
    let res = await super.set_logicalName(newval);
    let dev = this.imm_getDev();
    if (dev != null) {
      dev.imm_dropCache();
    }
    return res;
  }
  imm_flattenJsonStruct_internal(jsoncomplex) {
    let decoded = JSON.parse(this._yapi.imm_bin2str(jsoncomplex));
    let attrs = [];
    for (let function_name in decoded) {
      if (function_name == "services") {
        continue;
      }
      let function_attrs = decoded[function_name];
      for (let attr_name in function_attrs) {
        let attr_value = function_attrs[attr_name];
        if (attr_value === null || typeof attr_value === "object") {
          continue;
        }
        let flat = function_name + "/" + attr_name + "=" + attr_value;
        attrs.push(flat);
      }
    }
    return this._yapi.imm_str2bin(JSON.stringify(attrs));
  }
  async get_subDevices_internal() {
    let baseUrl = await this.get_url_internal();
    if (!baseUrl) {
      return [];
    }
    let hub = null;
    let hubUrl = "";
    for (let i = 0; i < this._yapi._connectedHubs.length; i++) {
      hubUrl = this._yapi._connectedHubs[i].urlInfo.rootUrl;
      if (baseUrl.slice(0, hubUrl.length) == hubUrl) {
        hub = this._yapi._connectedHubs[i];
        break;
      }
    }
    if (!hub || !hubUrl) {
      return [];
    }
    let hubSerial = hub.serialByYdx[0];
    if (hubSerial != this._serial) {
      return [];
    }
    let res = [];
    for (let serial in this._yapi._devs) {
      let rooturl = this._yapi._devs[serial].imm_getRootUrl();
      if (rooturl.substr(0, hubUrl.length) == hubUrl && serial != hubSerial) {
        res.push(serial);
      }
    }
    return res;
  }
  async get_parentHub_internal() {
    let baseUrl = await this.get_url_internal();
    if (!baseUrl) {
      return "";
    }
    let hub = null;
    for (let i = 0; i < this._yapi._connectedHubs.length; i++) {
      let hubUrl = this._yapi._connectedHubs[i].urlInfo.rootUrl;
      if (baseUrl.slice(0, hubUrl.length) == hubUrl) {
        hub = this._yapi._connectedHubs[i];
        break;
      }
    }
    if (!hub) {
      return "";
    }
    let hubSerial = hub.serialByYdx[0];
    if (hubSerial == this._serial) {
      return "";
    }
    return hubSerial;
  }
  async get_url_internal() {
    let devid = this._serial;
    if (devid == "") {
      devid = await this.get_serialNumber();
    }
    if (devid == YAPI_INVALID_STRING) {
      return "";
    }
    let lockdev = this._yapi.imm_getDevice(devid);
    if (!lockdev) {
      return "";
    }
    return lockdev.imm_getRootUrl();
  }
  async _startStopDevLog_internal(str_serial, bool_start) {
    let dev = this.imm_getDev();
    if (dev != null) {
      return dev.imm_registerLogCallback(this._logCallback);
    }
  }
  imm_parseAttr(name, val) {
    switch (name) {
      case "productName":
        this._productName = val;
        return 1;
      case "serialNumber":
        this._serialNumber = val;
        return 1;
      case "productId":
        this._productId = val;
        return 1;
      case "productRelease":
        this._productRelease = val;
        return 1;
      case "firmwareRelease":
        this._firmwareRelease = val;
        return 1;
      case "persistentSettings":
        this._persistentSettings = val;
        return 1;
      case "luminosity":
        this._luminosity = val;
        return 1;
      case "beacon":
        this._beacon = val;
        return 1;
      case "upTime":
        this._upTime = val;
        return 1;
      case "usbCurrent":
        this._usbCurrent = val;
        return 1;
      case "rebootCountdown":
        this._rebootCountdown = val;
        return 1;
      case "userVar":
        this._userVar = val;
        return 1;
    }
    return super.imm_parseAttr(name, val);
  }
  async get_productName() {
    let res;
    let dev;
    if (this._cacheExpiration == 0) {
      dev = this.imm_getDev();
      if (!(dev == null)) {
        return dev.imm_getProductName();
      }
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YModule.PRODUCTNAME_INVALID;
      }
    }
    res = this._productName;
    return res;
  }
  async get_serialNumber() {
    let res;
    let dev;
    if (this._cacheExpiration == 0) {
      dev = this.imm_getDev();
      if (!(dev == null)) {
        return dev.imm_getSerialNumber();
      }
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YModule.SERIALNUMBER_INVALID;
      }
    }
    res = this._serialNumber;
    return res;
  }
  async get_productId() {
    let res;
    let dev;
    if (this._cacheExpiration == 0) {
      dev = this.imm_getDev();
      if (!(dev == null)) {
        return dev.imm_getProductId();
      }
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YModule.PRODUCTID_INVALID;
      }
    }
    res = this._productId;
    return res;
  }
  async get_productRelease() {
    let res;
    if (this._cacheExpiration == 0) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YModule.PRODUCTRELEASE_INVALID;
      }
    }
    res = this._productRelease;
    return res;
  }
  async get_firmwareRelease() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YModule.FIRMWARERELEASE_INVALID;
      }
    }
    res = this._firmwareRelease;
    return res;
  }
  async get_persistentSettings() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YModule.PERSISTENTSETTINGS_INVALID;
      }
    }
    res = this._persistentSettings;
    return res;
  }
  async set_persistentSettings(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("persistentSettings", rest_val);
  }
  async get_luminosity() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YModule.LUMINOSITY_INVALID;
      }
    }
    res = this._luminosity;
    return res;
  }
  async set_luminosity(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("luminosity", rest_val);
  }
  async get_beacon() {
    let res;
    let dev;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      dev = this.imm_getDev();
      if (!(dev == null)) {
        return dev.imm_getBeacon();
      }
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YModule.BEACON_INVALID;
      }
    }
    res = this._beacon;
    return res;
  }
  async set_beacon(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("beacon", rest_val);
  }
  async get_upTime() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YModule.UPTIME_INVALID;
      }
    }
    res = this._upTime;
    return res;
  }
  async get_usbCurrent() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YModule.USBCURRENT_INVALID;
      }
    }
    res = this._usbCurrent;
    return res;
  }
  async get_rebootCountdown() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YModule.REBOOTCOUNTDOWN_INVALID;
      }
    }
    res = this._rebootCountdown;
    return res;
  }
  async set_rebootCountdown(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("rebootCountdown", rest_val);
  }
  async get_userVar() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YModule.USERVAR_INVALID;
      }
    }
    res = this._userVar;
    return res;
  }
  async set_userVar(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("userVar", rest_val);
  }
  static FindModule(func) {
    let obj;
    let cleanHwId;
    let modpos;
    cleanHwId = func;
    modpos = func.indexOf(".module");
    if (modpos != func.length - 7) {
      cleanHwId = func + ".module";
    }
    obj = YFunction._FindFromCache("Module", cleanHwId);
    if (obj == null) {
      obj = new YModule(YAPI, cleanHwId);
      YFunction._AddToCache("Module", cleanHwId, obj);
    }
    return obj;
  }
  static FindModuleInContext(yctx, func) {
    let obj;
    let cleanHwId;
    let modpos;
    cleanHwId = func;
    modpos = func.indexOf(".module");
    if (modpos != func.length - 7) {
      cleanHwId = func + ".module";
    }
    obj = YFunction._FindFromCacheInContext(yctx, "Module", cleanHwId);
    if (obj == null) {
      obj = new YModule(yctx, cleanHwId);
      YFunction._AddToCache("Module", cleanHwId, obj);
    }
    return obj;
  }
  async registerValueCallback(callback) {
    let val;
    if (callback != null) {
      await YFunction._UpdateValueCallbackList(this, true);
    } else {
      await YFunction._UpdateValueCallbackList(this, false);
    }
    this._valueCallbackModule = callback;
    if (callback != null && await this.isOnline()) {
      val = this._advertisedValue;
      if (!(val == "")) {
        await this._invokeValueCallback(val);
      }
    }
    return 0;
  }
  async _invokeValueCallback(value) {
    if (this._valueCallbackModule != null) {
      try {
        await this._valueCallbackModule(this, value);
      } catch (e) {
        this._yapi.imm_log("Exception in valueCallback:", e);
      }
    } else {
      super._invokeValueCallback(value);
    }
    return 0;
  }
  async get_productNameAndRevision() {
    let prodname;
    let prodrel;
    let fullname;
    prodname = await this.get_productName();
    prodrel = await this.get_productRelease();
    if (prodrel > 1) {
      fullname = prodname + " rev. " + String.fromCharCode(64 + prodrel);
    } else {
      fullname = prodname;
    }
    return fullname;
  }
  async saveToFlash() {
    return await this.set_persistentSettings(1);
  }
  async revertFromFlash() {
    return await this.set_persistentSettings(0);
  }
  async reboot(secBeforeReboot) {
    return await this.set_rebootCountdown(secBeforeReboot);
  }
  async triggerFirmwareUpdate(secBeforeReboot) {
    return await this.set_rebootCountdown(-secBeforeReboot);
  }
  async _startStopDevLog(serial, start) {
    return await this._startStopDevLog_internal(serial, start);
  }
  async registerLogCallback(callback) {
    let serial;
    serial = await this.get_serialNumber();
    if (serial == YAPI_INVALID_STRING) {
      return YAPI_DEVICE_NOT_FOUND;
    }
    this._logCallback = callback;
    await this._startStopDevLog(serial, callback != null);
    return 0;
  }
  async get_logCallback() {
    return this._logCallback;
  }
  async registerConfigChangeCallback(callback) {
    if (callback != null) {
      await YModule._updateModuleCallbackList(this, true);
    } else {
      await YModule._updateModuleCallbackList(this, false);
    }
    this._confChangeCallback = callback;
    return 0;
  }
  async _invokeConfigChangeCallback() {
    if (this._confChangeCallback != null) {
      try {
        await this._confChangeCallback(this);
      } catch (e) {
        this._yapi.imm_log("Exception in configChangeCallback:", e);
      }
    }
    return 0;
  }
  async registerBeaconCallback(callback) {
    if (callback != null) {
      await YModule._updateModuleCallbackList(this, true);
    } else {
      await YModule._updateModuleCallbackList(this, false);
    }
    this._beaconCallback = callback;
    return 0;
  }
  async _invokeBeaconCallback(beaconState) {
    if (this._beaconCallback != null) {
      try {
        await this._beaconCallback(this, beaconState);
      } catch (e) {
        this._yapi.imm_log("Exception in beaconCallback:", e);
      }
    }
    return 0;
  }
  async triggerConfigChangeCallback() {
    await this._setAttr("persistentSettings", "2");
    return 0;
  }
  async checkFirmware(path, onlynew) {
    let serial;
    let release;
    let tmp_res;
    if (onlynew) {
      release = this._yapi.imm_atoi(await this.get_firmwareRelease());
    } else {
      release = 0;
    }
    serial = await this.get_serialNumber();
    tmp_res = await YFirmwareUpdate.CheckFirmware(serial, path, release);
    if (tmp_res.indexOf("error:") == 0) {
      this._throw(YAPI_INVALID_ARGUMENT, tmp_res);
    }
    return tmp_res;
  }
  async updateFirmwareEx(path, force) {
    let serial;
    let settings;
    serial = await this.get_serialNumber();
    settings = await this.get_allSettings();
    if (settings.length == 0) {
      this._throw(YAPI_IO_ERROR, "Unable to get device settings");
      settings = this._yapi.imm_str2bin("error:Unable to get device settings");
    }
    return new YFirmwareUpdate(this._yapi, serial, path, settings, force);
  }
  async updateFirmware(path) {
    return await this.updateFirmwareEx(path, false);
  }
  async get_allSettings() {
    let settings;
    let json;
    let res;
    let sep;
    let name;
    let item;
    let t_type;
    let id;
    let url;
    let file_data;
    let file_data_bin;
    let temp_data_bin;
    let ext_settings;
    let filelist = [];
    let templist = [];
    settings = await this._download("api.json");
    if (settings.length == 0) {
      return settings;
    }
    ext_settings = ', "extras":[';
    templist = await this.get_functionIds("Temperature");
    sep = "";
    for (let ii in templist) {
      if (this._yapi.imm_atoi(await this.get_firmwareRelease()) > 9e3) {
        url = "api/" + templist[ii] + "/sensorType";
        t_type = this._yapi.imm_bin2str(await this._download(url));
        if (t_type == "RES_NTC" || t_type == "RES_LINEAR") {
          id = templist[ii].substr(11, templist[ii].length - 11);
          if (id == "") {
            id = "1";
          }
          temp_data_bin = await this._download("extra.json?page=" + id);
          if (temp_data_bin.length > 0) {
            item = sep + '{"fid":"' + templist[ii] + '", "json":' + this._yapi.imm_bin2str(temp_data_bin) + "}\n";
            ext_settings = ext_settings + item;
            sep = ",";
          }
        }
      }
    }
    ext_settings = ext_settings + '],\n"files":[';
    if (await this.hasFunction("files")) {
      json = await this._download("files.json?a=dir&f=");
      if (json.length == 0) {
        return json;
      }
      filelist = this.imm_json_get_array(json);
      sep = "";
      for (let ii in filelist) {
        name = this.imm_json_get_key(this._yapi.imm_str2bin(filelist[ii]), "name");
        if (name.length > 0 && !(name == "startupConf.json")) {
          file_data_bin = await this._download(this.imm_escapeAttr(name));
          file_data = this._yapi.imm_bin2hexstr(file_data_bin);
          item = sep + '{"name":"' + name + '", "data":"' + file_data + '"}\n';
          ext_settings = ext_settings + item;
          sep = ",";
        }
      }
    }
    res = this._yapi.imm_str2bin('{ "api":' + this._yapi.imm_bin2str(settings) + ext_settings + "]}");
    return res;
  }
  async loadThermistorExtra(funcId, jsonExtra) {
    let values = [];
    let url;
    let curr;
    let currTemp;
    let ofs;
    let size;
    url = "api/" + funcId + ".json?command=Z";
    await this._download(url);
    values = this.imm_json_get_array(this._yapi.imm_str2bin(jsonExtra));
    ofs = 0;
    size = values.length;
    while (ofs + 1 < size) {
      curr = values[ofs];
      currTemp = values[ofs + 1];
      url = "api/" + funcId + ".json?command=m" + curr + ":" + currTemp;
      await this._download(url);
      ofs = ofs + 2;
    }
    return YAPI_SUCCESS;
  }
  async set_extraSettings(jsonExtra) {
    let extras = [];
    let functionId;
    let data;
    extras = this.imm_json_get_array(this._yapi.imm_str2bin(jsonExtra));
    for (let ii in extras) {
      functionId = this.imm_get_json_path(extras[ii], "fid");
      functionId = this.imm_decode_json_string(functionId);
      data = this.imm_get_json_path(extras[ii], "json");
      if (await this.hasFunction(functionId)) {
        await this.loadThermistorExtra(functionId, data);
      }
    }
    return YAPI_SUCCESS;
  }
  async set_allSettingsAndFiles(settings) {
    let down;
    let json;
    let json_api;
    let json_files;
    let json_extra;
    let fuperror;
    let globalres;
    fuperror = 0;
    json = this._yapi.imm_bin2str(settings);
    json_api = this.imm_get_json_path(json, "api");
    if (json_api == "") {
      return await this.set_allSettings(settings);
    }
    json_extra = this.imm_get_json_path(json, "extras");
    if (!(json_extra == "")) {
      await this.set_extraSettings(json_extra);
    }
    await this.set_allSettings(this._yapi.imm_str2bin(json_api));
    if (await this.hasFunction("files")) {
      let files = [];
      let res;
      let name;
      let data;
      down = await this._download("files.json?a=format");
      res = this.imm_get_json_path(this._yapi.imm_bin2str(down), "res");
      res = this.imm_decode_json_string(res);
      if (!(res == "ok")) {
        return this._throw(YAPI_IO_ERROR, "format failed", YAPI_IO_ERROR);
      }
      json_files = this.imm_get_json_path(json, "files");
      files = this.imm_json_get_array(this._yapi.imm_str2bin(json_files));
      for (let ii in files) {
        name = this.imm_get_json_path(files[ii], "name");
        name = this.imm_decode_json_string(name);
        data = this.imm_get_json_path(files[ii], "data");
        data = this.imm_decode_json_string(data);
        if (name == "") {
          fuperror = fuperror + 1;
        } else {
          await this._upload(name, this._yapi.imm_hexstr2bin(data));
        }
      }
    }
    globalres = await this.set_allSettings(this._yapi.imm_str2bin(json_api));
    if (!(fuperror == 0)) {
      return this._throw(YAPI_IO_ERROR, "Error during file upload", YAPI_IO_ERROR);
    }
    return globalres;
  }
  async hasFunction(funcId) {
    let count;
    let i;
    let fid;
    count = await this.functionCount();
    i = 0;
    while (i < count) {
      fid = await this.functionId(i);
      if (fid == funcId) {
        return true;
      }
      i = i + 1;
    }
    return false;
  }
  async get_functionIds(funType) {
    let count;
    let i;
    let ftype;
    let res = [];
    count = await this.functionCount();
    i = 0;
    while (i < count) {
      ftype = await this.functionType(i);
      if (ftype == funType) {
        res.push(await this.functionId(i));
      } else {
        ftype = await this.functionBaseType(i);
        if (ftype == funType) {
          res.push(await this.functionId(i));
        }
      }
      i = i + 1;
    }
    return res;
  }
  imm_flattenJsonStruct(jsoncomplex) {
    return this.imm_flattenJsonStruct_internal(jsoncomplex);
  }
  async calibVersion(cparams) {
    if (cparams == "0,") {
      return 3;
    }
    if (cparams.indexOf(",") >= 0) {
      if (cparams.indexOf(" ") > 0) {
        return 3;
      } else {
        return 1;
      }
    }
    if (cparams == "" || cparams == "0") {
      return 1;
    }
    if (cparams.length < 2 || cparams.indexOf(".") >= 0) {
      return 0;
    } else {
      return 2;
    }
  }
  async calibScale(unit_name, sensorType) {
    if (unit_name == "g" || unit_name == "gauss" || unit_name == "W") {
      return 1e3;
    }
    if (unit_name == "C") {
      if (sensorType == "") {
        return 16;
      }
      if (this._yapi.imm_atoi(sensorType) < 8) {
        return 16;
      } else {
        return 100;
      }
    }
    if (unit_name == "m" || unit_name == "deg") {
      return 10;
    }
    return 1;
  }
  async calibOffset(unit_name) {
    if (unit_name == "% RH" || unit_name == "mbar" || unit_name == "lx") {
      return 0;
    }
    return 32767;
  }
  async calibConvert(param, currentFuncValue, unit_name, sensorType) {
    let paramVer;
    let funVer;
    let funScale;
    let funOffset;
    let paramScale;
    let paramOffset;
    let words = [];
    let words_str = [];
    let calibData = [];
    let iCalib = [];
    let calibType;
    let i;
    let maxSize;
    let ratio;
    let nPoints;
    let wordVal;
    paramVer = await this.calibVersion(param);
    funVer = await this.calibVersion(currentFuncValue);
    funScale = await this.calibScale(unit_name, sensorType);
    funOffset = await this.calibOffset(unit_name);
    paramScale = funScale;
    paramOffset = funOffset;
    if (funVer < 3) {
      if (funVer == 2) {
        words = this._yapi.imm_decodeWords(currentFuncValue);
        if (words[0] == 1366 && words[1] == 12500) {
          funScale = 1;
          funOffset = 0;
        } else {
          funScale = words[1];
          funOffset = words[0];
        }
      } else {
        if (funVer == 1) {
          if (currentFuncValue == "" || this._yapi.imm_atoi(currentFuncValue) > 10) {
            funScale = 0;
          }
        }
      }
    }
    calibData.length = 0;
    calibType = 0;
    if (paramVer < 3) {
      if (paramVer == 2) {
        words = this._yapi.imm_decodeWords(param);
        if (words[0] == 1366 && words[1] == 12500) {
          paramScale = 1;
          paramOffset = 0;
        } else {
          paramScale = words[1];
          paramOffset = words[0];
        }
        if (words.length >= 3 && words[2] > 0) {
          maxSize = 3 + 2 * (words[2] % 10);
          if (maxSize > words.length) {
            maxSize = words.length;
          }
          i = 3;
          while (i < maxSize) {
            calibData.push(words[i]);
            i = i + 1;
          }
        }
      } else {
        if (paramVer == 1) {
          words_str = param.split(",");
          for (let ii in words_str) {
            words.push(this._yapi.imm_atoi(words_str[ii]));
          }
          if (param == "" || words[0] > 10) {
            paramScale = 0;
          }
          if (words.length > 0 && words[0] > 0) {
            maxSize = 1 + 2 * (words[0] % 10);
            if (maxSize > words.length) {
              maxSize = words.length;
            }
            i = 1;
            while (i < maxSize) {
              calibData.push(words[i]);
              i = i + 1;
            }
          }
        } else {
          if (paramVer == 0) {
            ratio = parseFloat(param);
            if (ratio > 0) {
              calibData.push(0);
              calibData.push(0);
              calibData.push(Math.round(65535 / ratio));
              calibData.push(65535);
            }
          }
        }
      }
      i = 0;
      while (i < calibData.length) {
        if (paramScale > 0) {
          calibData[i] = (calibData[i] - paramOffset) / paramScale;
        } else {
          calibData[i] = this._yapi.imm_decimalToDouble(Math.round(calibData[i]));
        }
        i = i + 1;
      }
    } else {
      iCalib = this._yapi.imm_decodeFloats(param);
      calibType = Math.round(iCalib[0] / 1e3);
      if (calibType >= 30) {
        calibType = calibType - 30;
      }
      i = 1;
      while (i < iCalib.length) {
        calibData.push(iCalib[i] / 1e3);
        i = i + 1;
      }
    }
    if (funVer >= 3) {
      if (calibData.length == 0) {
        param = "0,";
      } else {
        param = (30 + calibType).toString();
        i = 0;
        while (i < calibData.length) {
          if ((i & 1) > 0) {
            param = param + ":";
          } else {
            param = param + " ";
          }
          param = param + Math.round(calibData[i] * 1e3 / 1e3).toString();
          i = i + 1;
        }
        param = param + ",";
      }
    } else {
      if (funVer >= 1) {
        nPoints = calibData.length / 2 >> 0;
        param = nPoints.toString();
        i = 0;
        while (i < 2 * nPoints) {
          if (funScale == 0) {
            wordVal = this._yapi.imm_doubleToDecimal(Math.round(calibData[i]));
          } else {
            wordVal = calibData[i] * funScale + funOffset;
          }
          param = param + "," + Math.round(wordVal).toString();
          i = i + 1;
        }
      } else {
        if (calibData.length == 4) {
          param = Math.round(1e3 * (calibData[3] - calibData[1]) / calibData[2] - calibData[0]).toString();
        }
      }
    }
    return param;
  }
  async _tryExec(url) {
    let res;
    let done;
    res = YAPI_SUCCESS;
    done = 1;
    try {
      await this._download(url);
    } catch (e) {
      done = 0;
    }
    if (done == 0) {
      try {
        YAPI.Sleep(500);
        await this._download(url);
      } catch (e) {
        res = await this.get_errorType();
      }
    }
    return res;
  }
  async set_allSettings(settings) {
    let restoreLast = [];
    let old_json_flat;
    let old_dslist = [];
    let old_jpath = [];
    let old_jpath_len = [];
    let old_val_arr = [];
    let actualSettings;
    let new_dslist = [];
    let new_jpath = [];
    let new_jpath_len = [];
    let new_val_arr = [];
    let cpos;
    let eqpos;
    let leng;
    let i;
    let j;
    let subres;
    let res;
    let njpath;
    let jpath;
    let fun;
    let attr;
    let value;
    let url;
    let tmp;
    let new_calib;
    let sensorType;
    let unit_name;
    let newval;
    let oldval;
    let old_calib;
    let each_str;
    let do_update;
    let found;
    res = YAPI_SUCCESS;
    tmp = this._yapi.imm_bin2str(settings);
    tmp = this.imm_get_json_path(tmp, "api");
    if (!(tmp == "")) {
      settings = this._yapi.imm_str2bin(tmp);
    }
    oldval = "";
    newval = "";
    old_json_flat = this.imm_flattenJsonStruct(settings);
    old_dslist = this.imm_json_get_array(old_json_flat);
    for (let ii in old_dslist) {
      each_str = this.imm_json_get_string(this._yapi.imm_str2bin(old_dslist[ii]));
      leng = each_str.length;
      eqpos = each_str.indexOf("=");
      if (eqpos < 0 || leng == 0) {
        this._throw(YAPI_INVALID_ARGUMENT, "Invalid settings");
        return YAPI_INVALID_ARGUMENT;
      }
      jpath = each_str.substr(0, eqpos);
      eqpos = eqpos + 1;
      value = each_str.substr(eqpos, leng - eqpos);
      old_jpath.push(jpath);
      old_jpath_len.push(jpath.length);
      old_val_arr.push(value);
    }
    try {
      actualSettings = await this._download("api.json");
    } catch (e) {
      YAPI.Sleep(500);
      actualSettings = await this._download("api.json");
    }
    actualSettings = this.imm_flattenJsonStruct(actualSettings);
    new_dslist = this.imm_json_get_array(actualSettings);
    for (let ii in new_dslist) {
      each_str = this.imm_json_get_string(this._yapi.imm_str2bin(new_dslist[ii]));
      leng = each_str.length;
      eqpos = each_str.indexOf("=");
      if (eqpos < 0 || leng == 0) {
        this._throw(YAPI_INVALID_ARGUMENT, "Invalid settings");
        return YAPI_INVALID_ARGUMENT;
      }
      jpath = each_str.substr(0, eqpos);
      eqpos = eqpos + 1;
      value = each_str.substr(eqpos, leng - eqpos);
      new_jpath.push(jpath);
      new_jpath_len.push(jpath.length);
      new_val_arr.push(value);
    }
    i = 0;
    while (i < new_jpath.length) {
      njpath = new_jpath[i];
      leng = njpath.length;
      cpos = njpath.indexOf("/");
      if (cpos < 0 || leng == 0) {
        continue;
      }
      fun = njpath.substr(0, cpos);
      cpos = cpos + 1;
      attr = njpath.substr(cpos, leng - cpos);
      do_update = true;
      if (fun == "services") {
        do_update = false;
      }
      if (do_update && attr == "firmwareRelease") {
        do_update = false;
      }
      if (do_update && attr == "usbCurrent") {
        do_update = false;
      }
      if (do_update && attr == "upTime") {
        do_update = false;
      }
      if (do_update && attr == "persistentSettings") {
        do_update = false;
      }
      if (do_update && attr == "adminPassword") {
        do_update = false;
      }
      if (do_update && attr == "userPassword") {
        do_update = false;
      }
      if (do_update && attr == "rebootCountdown") {
        do_update = false;
      }
      if (do_update && attr == "advertisedValue") {
        do_update = false;
      }
      if (do_update && attr == "poeCurrent") {
        do_update = false;
      }
      if (do_update && attr == "readiness") {
        do_update = false;
      }
      if (do_update && attr == "ipAddress") {
        do_update = false;
      }
      if (do_update && attr == "subnetMask") {
        do_update = false;
      }
      if (do_update && attr == "router") {
        do_update = false;
      }
      if (do_update && attr == "linkQuality") {
        do_update = false;
      }
      if (do_update && attr == "ssid") {
        do_update = false;
      }
      if (do_update && attr == "channel") {
        do_update = false;
      }
      if (do_update && attr == "security") {
        do_update = false;
      }
      if (do_update && attr == "message") {
        do_update = false;
      }
      if (do_update && attr == "signalValue") {
        do_update = false;
      }
      if (do_update && attr == "currentValue") {
        do_update = false;
      }
      if (do_update && attr == "currentRawValue") {
        do_update = false;
      }
      if (do_update && attr == "currentRunIndex") {
        do_update = false;
      }
      if (do_update && attr == "pulseTimer") {
        do_update = false;
      }
      if (do_update && attr == "lastTimePressed") {
        do_update = false;
      }
      if (do_update && attr == "lastTimeReleased") {
        do_update = false;
      }
      if (do_update && attr == "filesCount") {
        do_update = false;
      }
      if (do_update && attr == "freeSpace") {
        do_update = false;
      }
      if (do_update && attr == "timeUTC") {
        do_update = false;
      }
      if (do_update && attr == "rtcTime") {
        do_update = false;
      }
      if (do_update && attr == "unixTime") {
        do_update = false;
      }
      if (do_update && attr == "dateTime") {
        do_update = false;
      }
      if (do_update && attr == "rawValue") {
        do_update = false;
      }
      if (do_update && attr == "lastMsg") {
        do_update = false;
      }
      if (do_update && attr == "delayedPulseTimer") {
        do_update = false;
      }
      if (do_update && attr == "rxCount") {
        do_update = false;
      }
      if (do_update && attr == "txCount") {
        do_update = false;
      }
      if (do_update && attr == "msgCount") {
        do_update = false;
      }
      if (do_update && attr == "rxMsgCount") {
        do_update = false;
      }
      if (do_update && attr == "txMsgCount") {
        do_update = false;
      }
      if (do_update) {
        do_update = false;
        newval = new_val_arr[i];
        j = 0;
        found = false;
        while (j < old_jpath.length && !found) {
          if (new_jpath_len[i] == old_jpath_len[j] && new_jpath[i] == old_jpath[j]) {
            found = true;
            oldval = old_val_arr[j];
            if (!(newval == oldval)) {
              do_update = true;
            }
          }
          j = j + 1;
        }
      }
      if (do_update) {
        if (attr == "calibrationParam") {
          old_calib = "";
          unit_name = "";
          sensorType = "";
          new_calib = newval;
          j = 0;
          found = false;
          while (j < old_jpath.length && !found) {
            if (new_jpath_len[i] == old_jpath_len[j] && new_jpath[i] == old_jpath[j]) {
              found = true;
              old_calib = old_val_arr[j];
            }
            j = j + 1;
          }
          tmp = fun + "/unit";
          j = 0;
          found = false;
          while (j < new_jpath.length && !found) {
            if (tmp == new_jpath[j]) {
              found = true;
              unit_name = new_val_arr[j];
            }
            j = j + 1;
          }
          tmp = fun + "/sensorType";
          j = 0;
          found = false;
          while (j < new_jpath.length && !found) {
            if (tmp == new_jpath[j]) {
              found = true;
              sensorType = new_val_arr[j];
            }
            j = j + 1;
          }
          newval = await this.calibConvert(old_calib, new_val_arr[i], unit_name, sensorType);
          url = "api/" + fun + ".json?" + attr + "=" + this.imm_escapeAttr(newval);
          subres = await this._tryExec(url);
          if (res == YAPI_SUCCESS && subres != YAPI_SUCCESS) {
            res = subres;
          }
        } else {
          url = "api/" + fun + ".json?" + attr + "=" + this.imm_escapeAttr(oldval);
          if (attr == "resolution") {
            restoreLast.push(url);
          } else {
            subres = await this._tryExec(url);
            if (res == YAPI_SUCCESS && subres != YAPI_SUCCESS) {
              res = subres;
            }
          }
        }
      }
      i = i + 1;
    }
    for (let ii in restoreLast) {
      subres = await this._tryExec(restoreLast[ii]);
      if (res == YAPI_SUCCESS && subres != YAPI_SUCCESS) {
        res = subres;
      }
    }
    await this.clearCache();
    return res;
  }
  async addFileToHTTPCallback(filename) {
    let content;
    content = await this._download("@YCB+" + filename);
    if (content.length == 0) {
      return YAPI_NOT_SUPPORTED;
    }
    return YAPI_SUCCESS;
  }
  async get_hardwareId() {
    let serial;
    serial = await this.get_serialNumber();
    return serial + ".module";
  }
  async download(pathname) {
    return await this._download(pathname);
  }
  async get_icon2d() {
    return await this._download("icon2d.png");
  }
  async get_lastLogs() {
    let content;
    content = await this._download("logs.txt");
    return this._yapi.imm_bin2str(content);
  }
  async log(text) {
    return await this._upload("logs.txt", this._yapi.imm_str2bin(text));
  }
  async get_subDevices() {
    return await this.get_subDevices_internal();
  }
  async get_parentHub() {
    return await this.get_parentHub_internal();
  }
  async get_url() {
    return await this.get_url_internal();
  }
  nextModule() {
    let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
    if (resolve.errorType != YAPI.SUCCESS)
      return null;
    let next_hwid = this._yapi.imm_getNextHardwareId(this._className, resolve.result);
    if (next_hwid == null)
      return null;
    return YModule.FindModuleInContext(this._yapi, next_hwid);
  }
  static FirstModule() {
    let next_hwid = YAPI.imm_getFirstHardwareId("Module");
    if (next_hwid == null)
      return null;
    return YModule.FindModule(next_hwid);
  }
  static FirstModuleInContext(yctx) {
    let next_hwid = yctx.imm_getFirstHardwareId("Module");
    if (next_hwid == null)
      return null;
    return YModule.FindModuleInContext(yctx, next_hwid);
  }
};
YModule.PRODUCTNAME_INVALID = YAPI_INVALID_STRING;
YModule.SERIALNUMBER_INVALID = YAPI_INVALID_STRING;
YModule.PRODUCTID_INVALID = YAPI_INVALID_UINT;
YModule.PRODUCTRELEASE_INVALID = YAPI_INVALID_UINT;
YModule.FIRMWARERELEASE_INVALID = YAPI_INVALID_STRING;
YModule.PERSISTENTSETTINGS_LOADED = 0;
YModule.PERSISTENTSETTINGS_SAVED = 1;
YModule.PERSISTENTSETTINGS_MODIFIED = 2;
YModule.PERSISTENTSETTINGS_INVALID = -1;
YModule.LUMINOSITY_INVALID = YAPI_INVALID_UINT;
YModule.BEACON_OFF = 0;
YModule.BEACON_ON = 1;
YModule.BEACON_INVALID = -1;
YModule.UPTIME_INVALID = YAPI_INVALID_LONG;
YModule.USBCURRENT_INVALID = YAPI_INVALID_UINT;
YModule.REBOOTCOUNTDOWN_INVALID = YAPI_INVALID_INT;
YModule.USERVAR_INVALID = YAPI_INVALID_INT;
var YSensor = class extends YFunction {
  constructor(yapi, func) {
    super(yapi, func);
    this._unit = YSensor.UNIT_INVALID;
    this._currentValue = YSensor.CURRENTVALUE_INVALID;
    this._lowestValue = YSensor.LOWESTVALUE_INVALID;
    this._highestValue = YSensor.HIGHESTVALUE_INVALID;
    this._currentRawValue = YSensor.CURRENTRAWVALUE_INVALID;
    this._logFrequency = YSensor.LOGFREQUENCY_INVALID;
    this._reportFrequency = YSensor.REPORTFREQUENCY_INVALID;
    this._advMode = YSensor.ADVMODE_INVALID;
    this._calibrationParam = YSensor.CALIBRATIONPARAM_INVALID;
    this._resolution = YSensor.RESOLUTION_INVALID;
    this._sensorState = YSensor.SENSORSTATE_INVALID;
    this._valueCallbackSensor = null;
    this._timedReportCallbackSensor = null;
    this._prevTimedReport = 0;
    this._iresol = 0;
    this._offset = 0;
    this._scale = 0;
    this._decexp = 0;
    this._caltyp = 0;
    this._calpar = [];
    this._calraw = [];
    this._calref = [];
    this.imm_calhdl = null;
    this.UNIT_INVALID = YAPI_INVALID_STRING;
    this.CURRENTVALUE_INVALID = YAPI_INVALID_DOUBLE;
    this.LOWESTVALUE_INVALID = YAPI_INVALID_DOUBLE;
    this.HIGHESTVALUE_INVALID = YAPI_INVALID_DOUBLE;
    this.CURRENTRAWVALUE_INVALID = YAPI_INVALID_DOUBLE;
    this.LOGFREQUENCY_INVALID = YAPI_INVALID_STRING;
    this.REPORTFREQUENCY_INVALID = YAPI_INVALID_STRING;
    this.ADVMODE_IMMEDIATE = 0;
    this.ADVMODE_PERIOD_AVG = 1;
    this.ADVMODE_PERIOD_MIN = 2;
    this.ADVMODE_PERIOD_MAX = 3;
    this.ADVMODE_INVALID = -1;
    this.CALIBRATIONPARAM_INVALID = YAPI_INVALID_STRING;
    this.RESOLUTION_INVALID = YAPI_INVALID_DOUBLE;
    this.SENSORSTATE_INVALID = YAPI_INVALID_INT;
    this._className = "Sensor";
  }
  imm_parseAttr(name, val) {
    switch (name) {
      case "unit":
        this._unit = val;
        return 1;
      case "currentValue":
        this._currentValue = Math.round(val / 65.536) / 1e3;
        return 1;
      case "lowestValue":
        this._lowestValue = Math.round(val / 65.536) / 1e3;
        return 1;
      case "highestValue":
        this._highestValue = Math.round(val / 65.536) / 1e3;
        return 1;
      case "currentRawValue":
        this._currentRawValue = Math.round(val / 65.536) / 1e3;
        return 1;
      case "logFrequency":
        this._logFrequency = val;
        return 1;
      case "reportFrequency":
        this._reportFrequency = val;
        return 1;
      case "advMode":
        this._advMode = val;
        return 1;
      case "calibrationParam":
        this._calibrationParam = val;
        return 1;
      case "resolution":
        this._resolution = Math.round(val / 65.536) / 1e3;
        return 1;
      case "sensorState":
        this._sensorState = val;
        return 1;
    }
    return super.imm_parseAttr(name, val);
  }
  async get_unit() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YSensor.UNIT_INVALID;
      }
    }
    res = this._unit;
    return res;
  }
  async get_currentValue() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YSensor.CURRENTVALUE_INVALID;
      }
    }
    res = await this._applyCalibration(this._currentRawValue);
    if (res == YSensor.CURRENTVALUE_INVALID) {
      res = this._currentValue;
    }
    res = res * this._iresol;
    res = Math.round(res) / this._iresol;
    return res;
  }
  async set_lowestValue(newval) {
    let rest_val;
    rest_val = String(Math.round(newval * 65536));
    return await this._setAttr("lowestValue", rest_val);
  }
  async get_lowestValue() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YSensor.LOWESTVALUE_INVALID;
      }
    }
    res = this._lowestValue * this._iresol;
    res = Math.round(res) / this._iresol;
    return res;
  }
  async set_highestValue(newval) {
    let rest_val;
    rest_val = String(Math.round(newval * 65536));
    return await this._setAttr("highestValue", rest_val);
  }
  async get_highestValue() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YSensor.HIGHESTVALUE_INVALID;
      }
    }
    res = this._highestValue * this._iresol;
    res = Math.round(res) / this._iresol;
    return res;
  }
  async get_currentRawValue() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YSensor.CURRENTRAWVALUE_INVALID;
      }
    }
    res = this._currentRawValue;
    return res;
  }
  async get_logFrequency() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YSensor.LOGFREQUENCY_INVALID;
      }
    }
    res = this._logFrequency;
    return res;
  }
  async set_logFrequency(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("logFrequency", rest_val);
  }
  async get_reportFrequency() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YSensor.REPORTFREQUENCY_INVALID;
      }
    }
    res = this._reportFrequency;
    return res;
  }
  async set_reportFrequency(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("reportFrequency", rest_val);
  }
  async get_advMode() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YSensor.ADVMODE_INVALID;
      }
    }
    res = this._advMode;
    return res;
  }
  async set_advMode(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("advMode", rest_val);
  }
  async get_calibrationParam() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YSensor.CALIBRATIONPARAM_INVALID;
      }
    }
    res = this._calibrationParam;
    return res;
  }
  async set_calibrationParam(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("calibrationParam", rest_val);
  }
  async set_resolution(newval) {
    let rest_val;
    rest_val = String(Math.round(newval * 65536));
    return await this._setAttr("resolution", rest_val);
  }
  async get_resolution() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YSensor.RESOLUTION_INVALID;
      }
    }
    res = this._resolution;
    return res;
  }
  async get_sensorState() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YSensor.SENSORSTATE_INVALID;
      }
    }
    res = this._sensorState;
    return res;
  }
  static FindSensor(func) {
    let obj;
    obj = YFunction._FindFromCache("Sensor", func);
    if (obj == null) {
      obj = new YSensor(YAPI, func);
      YFunction._AddToCache("Sensor", func, obj);
    }
    return obj;
  }
  static FindSensorInContext(yctx, func) {
    let obj;
    obj = YFunction._FindFromCacheInContext(yctx, "Sensor", func);
    if (obj == null) {
      obj = new YSensor(yctx, func);
      YFunction._AddToCache("Sensor", func, obj);
    }
    return obj;
  }
  async registerValueCallback(callback) {
    let val;
    if (callback != null) {
      await YFunction._UpdateValueCallbackList(this, true);
    } else {
      await YFunction._UpdateValueCallbackList(this, false);
    }
    this._valueCallbackSensor = callback;
    if (callback != null && await this.isOnline()) {
      val = this._advertisedValue;
      if (!(val == "")) {
        await this._invokeValueCallback(val);
      }
    }
    return 0;
  }
  async _invokeValueCallback(value) {
    if (this._valueCallbackSensor != null) {
      try {
        await this._valueCallbackSensor(this, value);
      } catch (e) {
        this._yapi.imm_log("Exception in valueCallback:", e);
      }
    } else {
      super._invokeValueCallback(value);
    }
    return 0;
  }
  async _parserHelper() {
    let position;
    let maxpos;
    let iCalib = [];
    let iRaw;
    let iRef;
    let fRaw;
    let fRef;
    this._caltyp = -1;
    this._scale = -1;
    this._calpar.length = 0;
    this._calraw.length = 0;
    this._calref.length = 0;
    if (this._resolution > 0) {
      this._iresol = Math.round(1 / this._resolution);
    } else {
      this._iresol = 1e4;
      this._resolution = 1e-4;
    }
    if (this._calibrationParam == "" || this._calibrationParam == "0") {
      this._caltyp = 0;
      return 0;
    }
    if (this._calibrationParam.indexOf(",") >= 0) {
      iCalib = this._yapi.imm_decodeFloats(this._calibrationParam);
      this._caltyp = iCalib[0] / 1e3 >> 0;
      if (this._caltyp > 0) {
        if (this._caltyp < YOCTO_CALIB_TYPE_OFS) {
          this._caltyp = -1;
          return 0;
        }
        this.imm_calhdl = this._yapi.imm_getCalibrationHandler(this._caltyp);
        if (!(this.imm_calhdl != null)) {
          this._caltyp = -1;
          return 0;
        }
      }
      this._offset = 0;
      this._scale = 1e3;
      maxpos = iCalib.length;
      this._calpar.length = 0;
      position = 1;
      while (position < maxpos) {
        this._calpar.push(iCalib[position]);
        position = position + 1;
      }
      this._calraw.length = 0;
      this._calref.length = 0;
      position = 1;
      while (position + 1 < maxpos) {
        fRaw = iCalib[position];
        fRaw = fRaw / 1e3;
        fRef = iCalib[position + 1];
        fRef = fRef / 1e3;
        this._calraw.push(fRaw);
        this._calref.push(fRef);
        position = position + 2;
      }
    } else {
      iCalib = this._yapi.imm_decodeWords(this._calibrationParam);
      if (iCalib.length < 2) {
        this._caltyp = -1;
        return 0;
      }
      this._offset = 0;
      this._scale = 1;
      this._decexp = 1;
      position = iCalib[0];
      while (position > 0) {
        this._decexp = this._decexp * 10;
        position = position - 1;
      }
      if (iCalib.length == 2) {
        this._caltyp = 0;
        return 0;
      }
      this._caltyp = iCalib[2];
      this.imm_calhdl = this._yapi.imm_getCalibrationHandler(this._caltyp);
      if (this._caltyp <= 10) {
        maxpos = this._caltyp;
      } else {
        if (this._caltyp <= 20) {
          maxpos = this._caltyp - 10;
        } else {
          maxpos = 5;
        }
      }
      maxpos = 3 + 2 * maxpos;
      if (maxpos > iCalib.length) {
        maxpos = iCalib.length;
      }
      this._calpar.length = 0;
      this._calraw.length = 0;
      this._calref.length = 0;
      position = 3;
      while (position + 1 < maxpos) {
        iRaw = iCalib[position];
        iRef = iCalib[position + 1];
        this._calpar.push(iRaw);
        this._calpar.push(iRef);
        this._calraw.push(this._yapi.imm_decimalToDouble(iRaw));
        this._calref.push(this._yapi.imm_decimalToDouble(iRef));
        position = position + 2;
      }
    }
    return 0;
  }
  async isSensorReady() {
    if (!await this.isOnline()) {
      return false;
    }
    if (!(this._sensorState == 0)) {
      return false;
    }
    return true;
  }
  async get_dataLogger() {
    let logger;
    let modu;
    let serial;
    let hwid;
    modu = await this.get_module();
    serial = await modu.get_serialNumber();
    if (serial == YAPI_INVALID_STRING) {
      return null;
    }
    hwid = serial + ".dataLogger";
    logger = YDataLogger.FindDataLogger(hwid);
    return logger;
  }
  async startDataLogger() {
    let res;
    res = await this._download("api/dataLogger/recording?recording=1");
    if (!(res.length > 0)) {
      return this._throw(YAPI_IO_ERROR, "unable to start datalogger", YAPI_IO_ERROR);
    }
    return YAPI_SUCCESS;
  }
  async stopDataLogger() {
    let res;
    res = await this._download("api/dataLogger/recording?recording=0");
    if (!(res.length > 0)) {
      return this._throw(YAPI_IO_ERROR, "unable to stop datalogger", YAPI_IO_ERROR);
    }
    return YAPI_SUCCESS;
  }
  async get_recordedData(startTime, endTime) {
    let funcid;
    let funit;
    funcid = await this.get_functionId();
    funit = await this.get_unit();
    return new YDataSet(this, funcid, funit, startTime, endTime);
  }
  async registerTimedReportCallback(callback) {
    let sensor;
    sensor = this;
    if (callback != null) {
      await YFunction._UpdateTimedReportCallbackList(sensor, true);
    } else {
      await YFunction._UpdateTimedReportCallbackList(sensor, false);
    }
    this._timedReportCallbackSensor = callback;
    return 0;
  }
  async _invokeTimedReportCallback(value) {
    if (this._timedReportCallbackSensor != null) {
      try {
        await this._timedReportCallbackSensor(this, value);
      } catch (e) {
        this._yapi.imm_log("Exception in timedReportCallback:", e);
      }
    } else {
    }
    return 0;
  }
  async calibrateFromPoints(rawValues, refValues) {
    let rest_val;
    let res;
    rest_val = await this._encodeCalibrationPoints(rawValues, refValues);
    res = await this._setAttr("calibrationParam", rest_val);
    return res;
  }
  async loadCalibrationPoints(rawValues, refValues) {
    rawValues.length = 0;
    refValues.length = 0;
    if (this._scale == 0) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YAPI_DEVICE_NOT_FOUND;
      }
    }
    if (this._caltyp < 0) {
      this._throw(YAPI_NOT_SUPPORTED, "Calibration parameters format mismatch. Please upgrade your library or firmware.");
      return YAPI_NOT_SUPPORTED;
    }
    rawValues.length = 0;
    refValues.length = 0;
    for (let ii in this._calraw) {
      rawValues.push(this._calraw[ii]);
    }
    for (let ii in this._calref) {
      refValues.push(this._calref[ii]);
    }
    return YAPI_SUCCESS;
  }
  async _encodeCalibrationPoints(rawValues, refValues) {
    let res;
    let npt;
    let idx;
    npt = rawValues.length;
    if (npt != refValues.length) {
      this._throw(YAPI_INVALID_ARGUMENT, "Invalid calibration parameters (size mismatch)");
      return YAPI_INVALID_STRING;
    }
    if (npt == 0) {
      return "0";
    }
    if (this._scale == 0) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YAPI_INVALID_STRING;
      }
    }
    if (this._caltyp < 0 || this._scale < 0) {
      this._throw(YAPI_NOT_SUPPORTED, "Calibration parameters format mismatch. Please upgrade your library or firmware.");
      return "0";
    }
    res = String(Math.round(YOCTO_CALIB_TYPE_OFS));
    idx = 0;
    while (idx < npt) {
      res = res + "," + String(Math.round(rawValues[idx] * 1e3) / 1e3) + "," + String(Math.round(refValues[idx] * 1e3) / 1e3);
      idx = idx + 1;
    }
    return res;
  }
  async _applyCalibration(rawValue) {
    if (rawValue == YSensor.CURRENTVALUE_INVALID) {
      return YSensor.CURRENTVALUE_INVALID;
    }
    if (this._caltyp == 0) {
      return rawValue;
    }
    if (this._caltyp < 0) {
      return YSensor.CURRENTVALUE_INVALID;
    }
    if (!(this.imm_calhdl != null)) {
      return YSensor.CURRENTVALUE_INVALID;
    }
    return this.imm_calhdl(rawValue, this._caltyp, this._calpar, this._calraw, this._calref);
  }
  async _decodeTimedReport(timestamp, duration, report) {
    let i;
    let byteVal;
    let poww;
    let minRaw;
    let avgRaw;
    let maxRaw;
    let sublen;
    let difRaw;
    let startTime;
    let endTime;
    let minVal;
    let avgVal;
    let maxVal;
    if (duration > 0) {
      startTime = timestamp - duration;
    } else {
      startTime = this._prevTimedReport;
    }
    endTime = timestamp;
    this._prevTimedReport = endTime;
    if (startTime == 0) {
      startTime = endTime;
    }
    if (report.length <= 5) {
      poww = 1;
      avgRaw = 0;
      byteVal = 0;
      i = 1;
      while (i < report.length) {
        byteVal = report[i];
        avgRaw = avgRaw + poww * byteVal;
        poww = poww * 256;
        i = i + 1;
      }
      if ((byteVal & 128) != 0) {
        avgRaw = avgRaw - poww;
      }
      avgVal = avgRaw / 1e3;
      if (this._caltyp != 0) {
        if (this.imm_calhdl != null) {
          avgVal = this.imm_calhdl(avgVal, this._caltyp, this._calpar, this._calraw, this._calref);
        }
      }
      minVal = avgVal;
      maxVal = avgVal;
    } else {
      sublen = 1 + (report[1] & 3);
      poww = 1;
      avgRaw = 0;
      byteVal = 0;
      i = 2;
      while (sublen > 0 && i < report.length) {
        byteVal = report[i];
        avgRaw = avgRaw + poww * byteVal;
        poww = poww * 256;
        i = i + 1;
        sublen = sublen - 1;
      }
      if ((byteVal & 128) != 0) {
        avgRaw = avgRaw - poww;
      }
      sublen = 1 + (report[1] >> 2 & 3);
      poww = 1;
      difRaw = 0;
      while (sublen > 0 && i < report.length) {
        byteVal = report[i];
        difRaw = difRaw + poww * byteVal;
        poww = poww * 256;
        i = i + 1;
        sublen = sublen - 1;
      }
      minRaw = avgRaw - difRaw;
      sublen = 1 + (report[1] >> 4 & 3);
      poww = 1;
      difRaw = 0;
      while (sublen > 0 && i < report.length) {
        byteVal = report[i];
        difRaw = difRaw + poww * byteVal;
        poww = poww * 256;
        i = i + 1;
        sublen = sublen - 1;
      }
      maxRaw = avgRaw + difRaw;
      avgVal = avgRaw / 1e3;
      minVal = minRaw / 1e3;
      maxVal = maxRaw / 1e3;
      if (this._caltyp != 0) {
        if (this.imm_calhdl != null) {
          avgVal = this.imm_calhdl(avgVal, this._caltyp, this._calpar, this._calraw, this._calref);
          minVal = this.imm_calhdl(minVal, this._caltyp, this._calpar, this._calraw, this._calref);
          maxVal = this.imm_calhdl(maxVal, this._caltyp, this._calpar, this._calraw, this._calref);
        }
      }
    }
    return new YMeasure(startTime, endTime, minVal, avgVal, maxVal);
  }
  imm_decodeVal(w) {
    let val;
    val = w;
    if (this._caltyp != 0) {
      if (this.imm_calhdl != null) {
        val = this.imm_calhdl(val, this._caltyp, this._calpar, this._calraw, this._calref);
      }
    }
    return val;
  }
  imm_decodeAvg(dw) {
    let val;
    val = dw;
    if (this._caltyp != 0) {
      if (this.imm_calhdl != null) {
        val = this.imm_calhdl(val, this._caltyp, this._calpar, this._calraw, this._calref);
      }
    }
    return val;
  }
  nextSensor() {
    let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
    if (resolve.errorType != YAPI.SUCCESS)
      return null;
    let next_hwid = this._yapi.imm_getNextHardwareId(this._className, resolve.result);
    if (next_hwid == null)
      return null;
    return YSensor.FindSensorInContext(this._yapi, next_hwid);
  }
  static FirstSensor() {
    let next_hwid = YAPI.imm_getFirstHardwareId("Sensor");
    if (next_hwid == null)
      return null;
    return YSensor.FindSensor(next_hwid);
  }
  static FirstSensorInContext(yctx) {
    let next_hwid = yctx.imm_getFirstHardwareId("Sensor");
    if (next_hwid == null)
      return null;
    return YSensor.FindSensorInContext(yctx, next_hwid);
  }
};
YSensor.UNIT_INVALID = YAPI_INVALID_STRING;
YSensor.CURRENTVALUE_INVALID = YAPI_INVALID_DOUBLE;
YSensor.LOWESTVALUE_INVALID = YAPI_INVALID_DOUBLE;
YSensor.HIGHESTVALUE_INVALID = YAPI_INVALID_DOUBLE;
YSensor.CURRENTRAWVALUE_INVALID = YAPI_INVALID_DOUBLE;
YSensor.LOGFREQUENCY_INVALID = YAPI_INVALID_STRING;
YSensor.REPORTFREQUENCY_INVALID = YAPI_INVALID_STRING;
YSensor.ADVMODE_IMMEDIATE = 0;
YSensor.ADVMODE_PERIOD_AVG = 1;
YSensor.ADVMODE_PERIOD_MIN = 2;
YSensor.ADVMODE_PERIOD_MAX = 3;
YSensor.ADVMODE_INVALID = -1;
YSensor.CALIBRATIONPARAM_INVALID = YAPI_INVALID_STRING;
YSensor.RESOLUTION_INVALID = YAPI_INVALID_DOUBLE;
YSensor.SENSORSTATE_INVALID = YAPI_INVALID_INT;
var YMeasure = class {
  constructor(float_start, float_end, float_minVal, float_avgVal, float_maxVal) {
    this._start = 0;
    this._end = 0;
    this._minVal = 0;
    this._avgVal = 0;
    this._maxVal = 0;
    this._start = float_start;
    this._end = float_end;
    this._minVal = float_minVal;
    this._avgVal = float_avgVal;
    this._maxVal = float_maxVal;
  }
  get_startTimeUTC() {
    return this._start;
  }
  get_endTimeUTC() {
    return this._end;
  }
  get_minValue() {
    return this._minVal;
  }
  get_averageValue() {
    return this._avgVal;
  }
  get_maxValue() {
    return this._maxVal;
  }
  get_startTimeUTC_asDate() {
    return new Date(Math.round(this._start * 1e3));
  }
  get_endTimeUTC_asDate() {
    return new Date(Math.round(this._end * 1e3));
  }
};
var YDataLogger = class extends YFunction {
  constructor(yapi, func) {
    super(yapi, func);
    this._currentRunIndex = YDataLogger.CURRENTRUNINDEX_INVALID;
    this._timeUTC = YDataLogger.TIMEUTC_INVALID;
    this._recording = YDataLogger.RECORDING_INVALID;
    this._autoStart = YDataLogger.AUTOSTART_INVALID;
    this._beaconDriven = YDataLogger.BEACONDRIVEN_INVALID;
    this._usage = YDataLogger.USAGE_INVALID;
    this._clearHistory = YDataLogger.CLEARHISTORY_INVALID;
    this._valueCallbackDataLogger = null;
    this.CURRENTRUNINDEX_INVALID = YAPI_INVALID_UINT;
    this.TIMEUTC_INVALID = YAPI_INVALID_LONG;
    this.RECORDING_OFF = 0;
    this.RECORDING_ON = 1;
    this.RECORDING_PENDING = 2;
    this.RECORDING_INVALID = -1;
    this.AUTOSTART_OFF = 0;
    this.AUTOSTART_ON = 1;
    this.AUTOSTART_INVALID = -1;
    this.BEACONDRIVEN_OFF = 0;
    this.BEACONDRIVEN_ON = 1;
    this.BEACONDRIVEN_INVALID = -1;
    this.USAGE_INVALID = YAPI_INVALID_UINT;
    this.CLEARHISTORY_FALSE = 0;
    this.CLEARHISTORY_TRUE = 1;
    this.CLEARHISTORY_INVALID = -1;
    this._className = "DataLogger";
  }
  imm_parseAttr(name, val) {
    switch (name) {
      case "currentRunIndex":
        this._currentRunIndex = val;
        return 1;
      case "timeUTC":
        this._timeUTC = val;
        return 1;
      case "recording":
        this._recording = val;
        return 1;
      case "autoStart":
        this._autoStart = val;
        return 1;
      case "beaconDriven":
        this._beaconDriven = val;
        return 1;
      case "usage":
        this._usage = val;
        return 1;
      case "clearHistory":
        this._clearHistory = val;
        return 1;
    }
    return super.imm_parseAttr(name, val);
  }
  async get_currentRunIndex() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YDataLogger.CURRENTRUNINDEX_INVALID;
      }
    }
    res = this._currentRunIndex;
    return res;
  }
  async get_timeUTC() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YDataLogger.TIMEUTC_INVALID;
      }
    }
    res = this._timeUTC;
    return res;
  }
  async set_timeUTC(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("timeUTC", rest_val);
  }
  async get_recording() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YDataLogger.RECORDING_INVALID;
      }
    }
    res = this._recording;
    return res;
  }
  async set_recording(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("recording", rest_val);
  }
  async get_autoStart() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YDataLogger.AUTOSTART_INVALID;
      }
    }
    res = this._autoStart;
    return res;
  }
  async set_autoStart(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("autoStart", rest_val);
  }
  async get_beaconDriven() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YDataLogger.BEACONDRIVEN_INVALID;
      }
    }
    res = this._beaconDriven;
    return res;
  }
  async set_beaconDriven(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("beaconDriven", rest_val);
  }
  async get_usage() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YDataLogger.USAGE_INVALID;
      }
    }
    res = this._usage;
    return res;
  }
  async get_clearHistory() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YDataLogger.CLEARHISTORY_INVALID;
      }
    }
    res = this._clearHistory;
    return res;
  }
  async set_clearHistory(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("clearHistory", rest_val);
  }
  static FindDataLogger(func) {
    let obj;
    obj = YFunction._FindFromCache("DataLogger", func);
    if (obj == null) {
      obj = new YDataLogger(YAPI, func);
      YFunction._AddToCache("DataLogger", func, obj);
    }
    return obj;
  }
  static FindDataLoggerInContext(yctx, func) {
    let obj;
    obj = YFunction._FindFromCacheInContext(yctx, "DataLogger", func);
    if (obj == null) {
      obj = new YDataLogger(yctx, func);
      YFunction._AddToCache("DataLogger", func, obj);
    }
    return obj;
  }
  async registerValueCallback(callback) {
    let val;
    if (callback != null) {
      await YFunction._UpdateValueCallbackList(this, true);
    } else {
      await YFunction._UpdateValueCallbackList(this, false);
    }
    this._valueCallbackDataLogger = callback;
    if (callback != null && await this.isOnline()) {
      val = this._advertisedValue;
      if (!(val == "")) {
        await this._invokeValueCallback(val);
      }
    }
    return 0;
  }
  async _invokeValueCallback(value) {
    if (this._valueCallbackDataLogger != null) {
      try {
        await this._valueCallbackDataLogger(this, value);
      } catch (e) {
        this._yapi.imm_log("Exception in valueCallback:", e);
      }
    } else {
      super._invokeValueCallback(value);
    }
    return 0;
  }
  async forgetAllDataStreams() {
    return await this.set_clearHistory(1);
  }
  async get_dataSets() {
    return await this.parse_dataSets(await this._download("logger.json"));
  }
  async parse_dataSets(json) {
    let dslist = [];
    let dataset;
    let res = [];
    dslist = this.imm_json_get_array(json);
    res.length = 0;
    for (let ii in dslist) {
      dataset = new YDataSet(this);
      await dataset._parse(dslist[ii]);
      res.push(dataset);
    }
    return res;
  }
  nextDataLogger() {
    let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
    if (resolve.errorType != YAPI.SUCCESS)
      return null;
    let next_hwid = this._yapi.imm_getNextHardwareId(this._className, resolve.result);
    if (next_hwid == null)
      return null;
    return YDataLogger.FindDataLoggerInContext(this._yapi, next_hwid);
  }
  static FirstDataLogger() {
    let next_hwid = YAPI.imm_getFirstHardwareId("DataLogger");
    if (next_hwid == null)
      return null;
    return YDataLogger.FindDataLogger(next_hwid);
  }
  static FirstDataLoggerInContext(yctx) {
    let next_hwid = yctx.imm_getFirstHardwareId("DataLogger");
    if (next_hwid == null)
      return null;
    return YDataLogger.FindDataLoggerInContext(yctx, next_hwid);
  }
};
YDataLogger.CURRENTRUNINDEX_INVALID = YAPI_INVALID_UINT;
YDataLogger.TIMEUTC_INVALID = YAPI_INVALID_LONG;
YDataLogger.RECORDING_OFF = 0;
YDataLogger.RECORDING_ON = 1;
YDataLogger.RECORDING_PENDING = 2;
YDataLogger.RECORDING_INVALID = -1;
YDataLogger.AUTOSTART_OFF = 0;
YDataLogger.AUTOSTART_ON = 1;
YDataLogger.AUTOSTART_INVALID = -1;
YDataLogger.BEACONDRIVEN_OFF = 0;
YDataLogger.BEACONDRIVEN_ON = 1;
YDataLogger.BEACONDRIVEN_INVALID = -1;
YDataLogger.USAGE_INVALID = YAPI_INVALID_UINT;
YDataLogger.CLEARHISTORY_FALSE = 0;
YDataLogger.CLEARHISTORY_TRUE = 1;
YDataLogger.CLEARHISTORY_INVALID = -1;
var YSystemEnv = class {
  constructor() {
    this.isNodeJS = false;
    this.hasSSDP = false;
  }
  unknownSystemEnvError() {
    return new YoctoError("Unspecified runtime environment, your project should include at least once either yocto_api_nodejs or yocto_api_html");
  }
  hookUnhandledRejection(handler) {
    throw this.unknownSystemEnvError();
  }
  getWebSocketHub(obj_yapi, urlInfo) {
    throw this.unknownSystemEnvError();
  }
  getHttpHub(obj_yapi, urlInfo) {
    throw this.unknownSystemEnvError();
  }
  getWebSocketCallbackHub(obj_yapi, urlInfo, ws) {
    throw this.unknownSystemEnvError();
  }
  getHttpCallbackHub(yapi, urlInfo, incomingMessage, serverResponse) {
    throw this.unknownSystemEnvError();
  }
  getSSDPManager(obj_yapi) {
    throw this.unknownSystemEnvError();
  }
  async loadfile(file) {
    throw this.unknownSystemEnvError();
  }
  async downloadfile(url) {
    throw this.unknownSystemEnvError();
  }
};
var _UnspecifiedSystemEnv = new YSystemEnv();
var YGenericHub = class {
  constructor(yapi, urlInfo) {
    this._lastErrorType = YAPI_IO_ERROR;
    this._lastErrorMsg = "Hub attachment has not been triggered";
    this.hubSerial = "";
    this.serialByYdx = [];
    this._currentState = -6;
    this._targetState = -5;
    this.currentConnID = "";
    this.connResolvers = [];
    this.disconnResolvers = [];
    this.retryDelay = 15;
    this._reconnectionTimer = null;
    this._rwAccess = null;
    this.keepTryingExpiration = 0;
    this.keepTryingTimeoutId = null;
    this.timeoutId = null;
    this.lastPingStamp = 0;
    this.isNotifWorking = false;
    this.devListExpires = 0;
    this.notifPos = -1;
    this.notifCarryOver = "";
    this.missing = {};
    this._firstArrivalCallback = true;
    this._missing = {};
    this._knownUrls = [];
    this._yapi = yapi;
    this.urlInfo = urlInfo;
    this.stalledTimeoutMs = yapi._networkTimeoutMs;
    this._hubRef = YGenericHub.globalHubRefCounter++;
    this._knownUrls.push(urlInfo.orgUrl);
  }
  _throw(int_errType, str_errMsg, obj_retVal) {
    this._lastErrorType = int_errType;
    this._lastErrorMsg = str_errMsg;
    return this._yapi._throw(int_errType, str_errMsg, obj_retVal);
  }
  get_errorType() {
    return this._lastErrorType;
  }
  get_errorMessage() {
    return this._lastErrorMsg;
  }
  imm_forceUpdate() {
    this.devListExpires = this._yapi.GetTickCount();
  }
  imm_logrequest(method, devUrl, obj_body) {
    let msg = "Request: " + method + " " + devUrl;
    if (obj_body) {
      msg += " (file=" + obj_body.fname + ")";
    }
    this._yapi.imm_log(msg);
  }
  imm_setState(newState) {
    this._currentState = newState;
  }
  imm_setTargetState(newState) {
    this._targetState = newState;
  }
  imm_isDisconnecting() {
    return this._targetState <= -5;
  }
  imm_isDisconnected() {
    return this._targetState <= -5 && this._currentState <= -5;
  }
  imm_isPreOrRegistered() {
    return this._targetState >= 1;
  }
  imm_isOnline() {
    return Date.now() - this.lastPingStamp < this.stalledTimeoutMs;
  }
  imm_isForwarded() {
    return false;
  }
  imm_updateUrl(urlInfo) {
    if (!this._knownUrls.includes(urlInfo.orgUrl)) {
      this._knownUrls.push(urlInfo.orgUrl);
    }
    if (this.urlInfo.authUrl == urlInfo.authUrl) {
      this.urlInfo = urlInfo;
      return;
    }
    this.urlInfo = urlInfo;
    if (this._currentState < -1) {
      if (this._yapi._logLevel >= 4) {
        this._yapi.imm_log("Updating auth credentials for " + this.urlInfo.rootUrl);
      }
    }
  }
  imm_inheritFrom(otherHub) {
    if (this._targetState < otherHub._targetState) {
      this.imm_setTargetState(otherHub._targetState);
    }
    for (let j = 0; j < otherHub.serialByYdx.length; j++) {
      let serial = otherHub.serialByYdx[j];
      if (serial && !this.serialByYdx[j]) {
        this.serialByYdx[j] = serial;
      }
    }
    if (this._currentState >= 0 && otherHub._currentState < 0) {
      let res_struct = {errorType: YAPI_SUCCESS, errorMsg: "Hub " + this.hubSerial + " already connected"};
      let resolvers = otherHub.connResolvers;
      for (let resolveOne of resolvers) {
        resolveOne(res_struct);
      }
    } else {
      for (let resolver of otherHub.connResolvers) {
        this.connResolvers.push(resolver);
      }
    }
    otherHub.connResolvers = [];
    if (this._yapi._logLevel >= 3) {
      this._yapi.imm_log("Hub " + this.hubSerial + " is connected as " + this.urlInfo.rootUrl + ", dropping connection to " + otherHub.urlInfo.rootUrl);
    }
    otherHub.imm_commonDisconnect("inherit", YAPI_SUCCESS, "Hub " + this.hubSerial + " is already connected via " + this.urlInfo.rootUrl);
    otherHub.imm_disconnectNow();
    for (const url of otherHub.get_knownUrls()) {
      if (!this._knownUrls.includes(url)) {
        this._knownUrls.push(url);
      }
    }
  }
  imm_getNewConnID() {
    let time = new Date();
    return (time.getHours() + "h" + time.getMinutes() + "m" + time.getTime() % 6e4 / 1e3).toString() + "_0";
  }
  imm_tryTestConnectFor(mstimeout) {
    let minimalExpiration = Date.now() + mstimeout;
    if (this.keepTryingExpiration < minimalExpiration) {
      this.keepTryingExpiration = minimalExpiration;
      if (this.keepTryingTimeoutId) {
        clearTimeout(this.keepTryingTimeoutId);
      }
      this.keepTryingTimeoutId = setTimeout(() => {
        this.keepTryingTimeoutId = null;
        if (this._targetState == 0) {
          if (this._yapi._logLevel >= 4) {
            this._yapi.imm_log("TestHub timeout reached, disconnecting");
          }
          this.detach(YAPI.IO_ERROR, "TestHub timeout reached");
        }
      }, mstimeout);
    }
  }
  async attach(targetConnType) {
    if (this._targetState <= 0 || targetConnType > 0) {
      this.imm_setTargetState(targetConnType);
      if (this._currentState == 0 && targetConnType > 0) {
        try {
          await this._yapi._ensureUpdateDeviceListNotRunning();
          await this._yapi._addConnectedHub(this);
          this.imm_setState(targetConnType);
        } catch (e) {
          this.imm_disconnectNow();
        }
      }
      if (targetConnType == 0) {
        this.imm_tryTestConnectFor(100);
      }
    }
    if (this._currentState <= -5) {
      this.imm_setState(-1);
      this.reconnect(this.imm_getNewConnID());
    } else if (this._currentState == -3) {
      if (this._reconnectionTimer) {
        if (this._yapi._logLevel >= 4) {
          this._yapi.imm_log("New hub connection requested, retry now (drop [" + this.currentConnID + "])");
        }
        clearTimeout(this._reconnectionTimer);
        this._reconnectionTimer = null;
        this.currentConnID = "";
      } else {
        if (this._yapi._logLevel >= 4) {
          this._yapi.imm_log("New hub connection requested, retry now (no pending reconnection ?!?)");
        }
      }
      this.reconnect(this.imm_getNewConnID());
    } else if (this._currentState == -4 || this._currentState == -2) {
      if (this._yapi._logLevel >= 4) {
        this._yapi.imm_log("Hub is currently disconnecting, reconnection will be triggered soon [" + this.currentConnID + "]");
        this._yapi.imm_log("Current state: " + this._currentState);
        this._yapi.imm_log("Target state: " + this._targetState + " (" + targetConnType + ")");
      }
    }
  }
  async waitForConnection(mstimeout, errmsg) {
    if (this._targetState < 0) {
      errmsg.msg = this._lastErrorMsg;
      return this._lastErrorType;
    }
    if (this._currentState >= 0) {
      return YAPI_SUCCESS;
    }
    if (mstimeout <= 1) {
      errmsg.msg = "Hub not connected";
      return YAPI_TIMEOUT;
    }
    if (this._targetState == 0) {
      this.imm_tryTestConnectFor(mstimeout);
    }
    let connOpenPromise = null;
    let connOpenTimeoutObj = null;
    let addResolverPromise;
    addResolverPromise = new Promise((resolverReady, noResolver) => {
      connOpenPromise = new Promise((resolve, reject) => {
        this.connResolvers.push(resolve);
        resolverReady(resolve);
        connOpenTimeoutObj = setTimeout(() => {
          if (this._yapi._logLevel >= 4) {
            this._yapi.imm_log("Timeout waiting for hub connection");
          }
          resolve({errorType: YAPI_TIMEOUT, errorMsg: "Timeout waiting for hub connection"});
        }, mstimeout);
      });
    });
    let resolver = await addResolverPromise;
    if (this._targetState < 0) {
      clearTimeout(connOpenTimeoutObj);
      errmsg.msg = this._lastErrorMsg;
      return this._lastErrorType;
    }
    if (this._currentState >= 0) {
      clearTimeout(connOpenTimeoutObj);
      return YAPI_SUCCESS;
    }
    let openRes = await connOpenPromise;
    clearTimeout(connOpenTimeoutObj);
    if (openRes.errorType != YAPI_SUCCESS) {
      if (errmsg) {
        errmsg.msg = openRes.errorMsg;
      }
    }
    return openRes.errorType;
  }
  async reconnect(tryOpenID) {
  }
  async signalHubConnected(tryOpenID, hubSerial) {
    this.imm_setState(0);
    this.hubSerial = hubSerial;
    if (this._yapi._logLevel >= 4) {
      this._yapi.imm_log("Hub " + hubSerial + " connected [" + tryOpenID + "]");
    }
    let primaryHub = this._yapi.imm_getPrimaryHub(this);
    if (primaryHub._targetState >= 1) {
      if (primaryHub._currentState < 1) {
        try {
          await primaryHub._yapi._ensureUpdateDeviceListNotRunning();
          await primaryHub._yapi._addConnectedHub(primaryHub);
        } catch (e) {
          primaryHub.imm_disconnectNow();
          return;
        }
      }
      if (primaryHub._currentState < primaryHub._targetState) {
        primaryHub.imm_setState(primaryHub._targetState);
      }
    } else {
      primaryHub.keepTryingExpiration = 0;
      primaryHub.imm_tryTestConnectFor(100);
    }
    let res_struct = {errorType: YAPI_SUCCESS, errorMsg: "Hub " + hubSerial + " connected"};
    let resolvers = primaryHub.connResolvers;
    primaryHub.connResolvers = [];
    primaryHub._lastErrorType = res_struct.errorType;
    primaryHub._lastErrorMsg = res_struct.errorMsg;
    for (let resolveOne of resolvers) {
      resolveOne(res_struct);
    }
  }
  imm_signalHubDisconnected(tryOpenID) {
    if (this._currentState > -3) {
      this.imm_setState(-3);
    }
    this.isNotifWorking = false;
    this.devListExpires = 0;
    this._yapi.imm_dropConnectedHub(this);
    this._firstArrivalCallback = true;
    let resolvers = this.disconnResolvers;
    this.disconnResolvers = [];
    for (let resolveOne of resolvers) {
      resolveOne({errorType: YAPI_SUCCESS, errorMsg: "Hub disconnect completed"});
    }
    if (this.imm_isDisconnecting()) {
      this.imm_setState(-5);
      if (this._yapi._logLevel >= 4) {
        this._yapi.imm_log("Hub " + this.urlInfo.rootUrl + " detached");
      }
      return false;
    }
    if (this._reconnectionTimer) {
      if (this._yapi._logLevel >= 4) {
        this._yapi.imm_log("Hub disconnected, reconnection is already scheduled [" + this.currentConnID + "]");
      }
      return true;
    }
    let openIDwords = tryOpenID.split("_");
    let nextOpenID = openIDwords[0] + "_" + (parseInt(openIDwords[1]) + 1).toString();
    if (this.retryDelay < 5e3)
      this.retryDelay *= 2;
    if (this._yapi._logLevel >= 4) {
      this._yapi.imm_log("Hub reconnection scheduled in " + this.retryDelay / 1e3 + "s [" + nextOpenID + "]");
    }
    this.currentConnID = nextOpenID;
    this._reconnectionTimer = setTimeout(() => {
      this._reconnectionTimer = null;
      this.currentConnID = "";
      if (this.imm_isDisconnecting()) {
        return;
      }
      if (this._yapi._logLevel >= 4) {
        this._yapi.imm_log("Retry hub connection now [" + nextOpenID + "]");
      }
      this.reconnect(nextOpenID);
    }, this.retryDelay);
    return true;
  }
  imm_commonDisconnect(tryOpenID, errType, errMsg) {
    this._lastErrorType = errType;
    this._lastErrorMsg = errMsg;
    if (this._currentState >= -2) {
      this.imm_setState(-4);
    } else if (this._currentState == -3) {
      this.imm_setState(-5);
    }
    this.imm_setTargetState(-5);
    if (this._reconnectionTimer) {
      clearTimeout(this._reconnectionTimer);
      this._reconnectionTimer = null;
    }
    if (this.timeoutId) {
      clearTimeout(this.timeoutId);
      this.timeoutId = null;
    }
    if (errType != YAPI_SUCCESS && this._yapi._logLevel >= 4 && tryOpenID != "detach") {
      this._yapi.imm_log("Hub connection failed: " + errMsg + " [" + tryOpenID + "]");
    }
    this._firstArrivalCallback = true;
    let res_struct = {errorType: errType, errorMsg: errMsg};
    let resolvers = this.connResolvers;
    this.connResolvers = [];
    for (let resolveOne of resolvers) {
      resolveOne(res_struct);
    }
  }
  imm_disconnectNow(connID = "") {
    if (connID && connID != this.currentConnID) {
      return false;
    }
    if (this._currentState > -2) {
      this.imm_setState(-2);
    }
    if (this.timeoutId) {
      clearTimeout(this.timeoutId);
      this.timeoutId = null;
    }
    return true;
  }
  async detach(errType = YAPI.IO_ERROR, errMsg = "Hub has been forcibly detached") {
    this.imm_commonDisconnect("detach", errType, errMsg);
    this.imm_disconnectNow();
  }
  async waitForDisconnection(mstimeout) {
    let disconnPromise = null;
    let disconnTimeoutObj = null;
    disconnPromise = new Promise((resolve, reject) => {
      this.disconnResolvers.push(resolve);
      disconnTimeoutObj = setTimeout(() => {
        if (this._yapi._logLevel >= 4) {
          this._yapi.imm_log("Timeout waiting for hub disconnection");
        }
        resolve({errorType: YAPI_TIMEOUT, errorMsg: "Timeout waiting for hub connection"});
      }, mstimeout);
    });
    await disconnPromise;
    clearTimeout(disconnTimeoutObj);
  }
  async hubUpdateDeviceList() {
    let hubDev = this._yapi.imm_getDevice(this.urlInfo.rootUrl);
    try {
      hubDev.imm_dropCache();
      let retcode = await hubDev.refresh();
      if (retcode != YAPI_SUCCESS) {
        if (this._currentState >= 1) {
          await this._yapi.updateDeviceList_process(this, hubDev, [], {});
        }
        this.imm_disconnectNow();
        return this._throw(retcode, hubDev._lastErrorMsg, retcode);
      }
      let yreq = await hubDev.requestAPI(this._yapi.defaultCacheValidity);
      if (yreq.errorType != YAPI_SUCCESS) {
        if (this._currentState >= 1) {
          await this._yapi.updateDeviceList_process(this, hubDev, [], {});
        }
        this.imm_disconnectNow();
        return yreq.errorType;
      }
      let whitePages = yreq.obj_result.services.whitePages;
      let yellowPages = yreq.obj_result.services.yellowPages;
      if (!whitePages) {
        this.imm_disconnectNow();
        return this._throw(YAPI_IO_ERROR, "Device " + hubDev.imm_describe() + " is not a hub", YAPI_IO_ERROR);
      }
      retcode = await this._yapi.updateDeviceList_process(this, hubDev, whitePages, yellowPages);
      if (retcode < 0) {
        this.imm_disconnectNow();
        return this._throw(this._yapi._lastErrorType, this._yapi._lastErrorMsg, this._yapi._lastErrorType);
      }
      if (this.isNotifWorking) {
        this.devListExpires = this._yapi.GetTickCount() + this._yapi._deviceListValidityMs;
      } else {
        this.devListExpires = this._yapi.GetTickCount() + 500;
      }
      return retcode;
    } catch (e) {
      this._yapi.imm_log("Exception during device enumeration: ", e);
      if (this._currentState >= 1) {
        try {
          await this._yapi.updateDeviceList_process(this, hubDev, [], {});
        } catch (e2) {
        }
      }
      this.imm_disconnectNow();
      return YAPI_IO_ERROR;
    }
  }
  async request(method, devUrl, obj_body, tcpchan) {
    let res = new YHTTPRequest(null);
    res.errorType = YAPI_NOT_SUPPORTED;
    res.errorMsg = "GenericHub subclass expected";
    return res;
  }
  imm_getBoundary() {
    return "Zz" + Math.floor(Math.random() * 16777215).toString(16) + "zZ";
  }
  imm_formEncodeBody(obj_body, str_boundary) {
    let hdr = this._yapi.imm_str2bin('Content-Disposition: form-data; name="' + obj_body.fname + '"; filename="api"\r\nContent-Type: application/octet-stream\r\nContent-Transfer-Encoding: binary\r\n\r\n');
    let boundary = this._yapi.imm_str2bin(str_boundary);
    let dash = this._yapi.imm_str2bin("--");
    let crlf = this._yapi.imm_str2bin("\r\n");
    let parts = [dash, boundary, crlf, hdr, obj_body.data, crlf, dash, boundary, dash, crlf];
    let i, len = 0;
    for (i = 0; i < parts.length; i++) {
      len += parts[i].length;
    }
    let res = new Uint8Array(len);
    len = 0;
    for (i = 0; i < parts.length; i++) {
      res.set(parts[i], len);
      len += parts[i].length;
    }
    return res;
  }
  async getBootloaders() {
    let yreq = await this.request("GET", "/flash.json?a=list", null, 1);
    if (yreq.errorType != YAPI_SUCCESS) {
      return this._throw(yreq.errorType, yreq.errorMsg, []);
    }
    let flashState = JSON.parse(YAPI.imm_bin2str(yreq.bin_result));
    return flashState["list"];
  }
  async firmwareUpdate(serial, firmware, settings, progress) {
    let use_self_flash = false;
    let baseUrl = "";
    let need_reboot = true;
    let _throw = (msg) => {
      return this._throw(YAPI.IO_ERROR, msg, [msg]);
    };
    progress(5, "Check bootloader type");
    let yreq = await this.request("GET", "/api/module.json", null, 0);
    if (yreq.errorType != YAPI_SUCCESS) {
      return _throw("Hub is not responding");
    }
    let json = JSON.parse(this._yapi.imm_bin2str(yreq.bin_result));
    let ownSerial = json.serialNumber;
    if (ownSerial.slice(0, 7) == "VIRTHUB") {
      use_self_flash = false;
    } else if (serial == ownSerial) {
      use_self_flash = true;
    } else {
      yreq = await this.request("GET", "/bySerial/" + serial + "/flash.json?a=state", null, 0);
      if (yreq.errorType == YAPI_SUCCESS && yreq.bin_result.length > 0) {
        use_self_flash = true;
        baseUrl = "/bySerial/" + serial;
      }
    }
    let bootloaders = await this.getBootloaders();
    let is_shield = serial.slice(0, 7) == "YHUBSHL";
    let i;
    for (i = 0; i < bootloaders.length; i++) {
      let bl = bootloaders[i];
      if (bl == serial) {
        need_reboot = false;
      } else if (is_shield) {
        if (bl.slice(0, 7) == "YHUBSHL") {
          return _throw("Only one YoctoHub-Shield is allowed in update mode");
        }
      }
    }
    if (!use_self_flash && need_reboot) {
      if (bootloaders.length >= 4) {
        return _throw("Too many devices in update mode");
      }
    }
    yreq = await this.request("GET", baseUrl + "/flash.json?a=state", null, 0);
    if (yreq.errorType != YAPI_SUCCESS) {
      return _throw("Cannot check state of firmware upload");
    }
    json = JSON.parse(this._yapi.imm_bin2str(yreq.bin_result));
    if (json["state"] == "uploading" || json["state"] == "flashing") {
      return _throw("Cannot start firmware update: busy (" + json["state"] + ")");
    }
    progress(10, "Send firmware file");
    let progressCb = function(curr, total) {
      curr >>= 10;
      total >>= 10;
      progress(10 + (28 * curr / total >> 0), "Send firmware file: " + curr + "KB / " + total + "KB");
    };
    yreq = await this.request("POST", baseUrl + "/upload.html", new YHTTPBody("firmware", firmware.imm_getData(), progressCb), 0);
    if (yreq.errorType != YAPI_SUCCESS) {
      return _throw("Firmware upload failed: " + yreq.errorMsg);
    }
    yreq = await this.request("GET", baseUrl + "/flash.json?a=state", null, 0);
    if (yreq.errorType != YAPI_SUCCESS) {
      return _throw("Cannot check state of firmware upload");
    }
    json = JSON.parse(this._yapi.imm_bin2str(yreq.bin_result));
    if (json["state"] != "valid") {
      return _throw("Upload of firmware failed: invalid firmware(" + json["state"] + ")");
    }
    if (json["progress"] != "100") {
      return _throw("Upload of firmware failed: incomplete upload");
    }
    if (use_self_flash) {
      let settingsStr = this._yapi.imm_bin2str(settings);
      let settingsAndFiles = JSON.parse(settingsStr);
      let settingsOnly = settingsAndFiles["api"];
      let startupApi = {};
      for (let key in settingsOnly) {
        if (key != "services") {
          startupApi[key] = settingsOnly[key];
        }
      }
      let startupConf = this._yapi.imm_str2bin(JSON.stringify(startupApi));
      progress(38, "Save current settings");
      yreq = await this.request("POST", baseUrl + "/upload.html", new YHTTPBody("startupConf.json", startupConf, null), 0);
      if (yreq.errorType != YAPI_SUCCESS) {
        return _throw("Failed to save settings on hub");
      }
      progress(39, "Save current settings");
      yreq = await this.request("POST", baseUrl + "/upload.html", new YHTTPBody("firmwareConf", startupConf, null), 0);
      if (yreq.errorType != YAPI_SUCCESS) {
        return _throw("Failed to save settings on hub");
      }
    }
    if (use_self_flash) {
      progress(40, "Flash firmware");
      await this.request("GET", baseUrl + "/api/module/rebootCountdown?rebootCountdown=-1003", null, 0);
      await this._yapi.Sleep(7e3);
    } else {
      if (need_reboot) {
        await this.request("GET", "/bySerial/" + serial + "/api/module/rebootCountdown?rebootCountdown=-2", null, 0);
      }
      let timeout = YAPI.GetTickCount() + 2e4;
      let res;
      let found = false;
      progress(40, "Wait for device to be in bootloader");
      do {
        bootloaders = await this.getBootloaders();
        for (i = 0; i < bootloaders.length; i++) {
          let bl = bootloaders[i];
          if (bl == serial) {
            found = true;
            break;
          }
        }
        if (!found) {
          await this._yapi.Sleep(500);
        }
      } while (!found && YAPI.GetTickCount() < timeout);
      progress(45, "Flash firmware");
      let fwsize = firmware.imm_getData().length + 512 >> 10;
      let checkTimer;
      let checkFlash = () => {
        this.request("GET", baseUrl + "/flash.json?a=state", null, 1).then((flashReq) => {
          if (flashReq.errorType == YAPI_SUCCESS) {
            let jsonState = YAPI.imm_bin2str(flashReq.bin_result);
            let res2 = JSON.parse(jsonState);
            if (res2.state == "flashing") {
              if (res2.progress < 20) {
                progress(45 + (res2.progress / 3 >> 0), "Erasing previous firmware: " + (fwsize * (res2.progress - 3) / 18 >> 0) + "KB / " + fwsize + "KB");
              } else {
                progress(45 + (res2.progress / 3 >> 0), "Flashing new firmware: " + (fwsize * (res2.progress - 20) / 76 >> 0) + "KB / " + fwsize + "KB");
              }
            }
          }
          checkTimer = setTimeout(checkFlash, 500);
        }).catch((e) => {
          this._yapi.imm_log("Exception during firmware flash: ", e);
          checkTimer = setTimeout(checkFlash, 500);
        });
      };
      checkTimer = setTimeout(checkFlash, 1e3);
      yreq = await this.request("GET", "/flash.json?a=flash&s=" + serial, null, 0);
      clearTimeout(checkTimer);
      if (yreq.errorType != YAPI_SUCCESS) {
        return _throw("Cannot check state of firmware flash");
      }
      return JSON.parse(this._yapi.imm_bin2str(yreq.bin_result));
    }
    return null;
  }
  async reportFailure(message) {
  }
  async hasRwAccess() {
    if (this._rwAccess == null) {
      let yreq = await this.request("GET", "/api/module/serialNumber.json?serialNumber=rwTest", null, 0);
      this._rwAccess = yreq.errorType == YAPI_SUCCESS;
    }
    return this._rwAccess;
  }
  getHubRef() {
    return this._hubRef;
  }
  get_knownUrls() {
    let res = this._knownUrls.slice();
    return res;
  }
  imm_forgetUrls() {
    this._knownUrls = [];
  }
};
YGenericHub.globalHubRefCounter = 0;
var YHttpHub = class extends YGenericHub {
  constructor(yapi, urlInfo) {
    super(yapi, urlInfo);
    this.infoJson = null;
    this.realm = "";
    this.nonce = "";
    this.nonceCount = 0;
    this.notbynRequest = null;
  }
  imm_makeRequest(method, relUrl, contentType, body, onProgress, onSuccess, onError) {
  }
  imm_abortRequest(clientRequest) {
  }
  imm_sendRequest(method, relUrl, obj_body, onProgress, onSuccess, onError) {
    let body = null;
    let contentType = "text/plain; charset=x-user-defined";
    if (this.infoJson && this.infoJson.realm && this.infoJson.nonce) {
      if (this.realm != this.infoJson.realm || this.nonce != this.infoJson.nonce) {
        this.realm = this.infoJson.realm;
        this.nonce = this.infoJson.nonce;
        this.nonceCount = 0;
      }
      let shorturi = "/" + this.urlInfo.domain + relUrl;
      let jsonBody = {
        "x-yauth": {
          method,
          uri: shorturi
        }
      };
      if (this.urlInfo.user || this.urlInfo.pass) {
        let cnonce = Math.floor(Math.random() * 2147483647).toString(16).toLowerCase();
        let nc = (++this.nonceCount).toString(16).toLowerCase();
        let ha1_str = this.urlInfo.user + ":" + this.realm + ":" + this.urlInfo.pass;
        let ha2_str = method + ":" + shorturi;
        let A1 = this._yapi.imm_bin2hexstr(this._yapi.imm_yMD5(ha1_str)).toLowerCase();
        let A2 = this._yapi.imm_bin2hexstr(this._yapi.imm_ySHA1(ha2_str)).toLowerCase();
        let signature = A1 + ":" + this.nonce + ":" + nc + ":" + cnonce + ":auth:" + A2;
        let response = this._yapi.imm_bin2hexstr(this._yapi.imm_ySHA1(signature)).toLowerCase();
        jsonBody["x-yauth"]["username"] = this.urlInfo.user;
        jsonBody["x-yauth"]["cnonce"] = cnonce;
        jsonBody["x-yauth"]["nonce"] = this.nonce;
        jsonBody["x-yauth"]["nc"] = nc;
        jsonBody["x-yauth"]["qop"] = "auth";
        jsonBody["x-yauth"]["response"] = response;
      }
      if (obj_body) {
        let binstr = this._yapi.imm_bin2str(obj_body.data);
        jsonBody["body"] = {
          filename: obj_body.fname,
          b64content: btoa(binstr)
        };
      }
      method = "POST";
      body = JSON.stringify(jsonBody);
      let qpos = relUrl.indexOf("?");
      if (qpos > 0) {
        relUrl = relUrl.slice(0, qpos);
      }
    } else if (obj_body != null) {
      let boundary = this.imm_getBoundary();
      if (this.infoJson && this.infoJson.nonce) {
        contentType = "x-upload; boundary=" + boundary;
      } else {
        contentType = "multipart/form-data; boundary=" + boundary;
      }
      body = this.imm_formEncodeBody(obj_body, boundary);
    }
    return this.imm_makeRequest(method, relUrl, contentType, body, onProgress, onSuccess, onError);
  }
  async tryFetch(relUrl) {
    return new Promise((resolve, reject) => {
      this.imm_sendRequest("GET", relUrl, null, null, (responseText) => {
        resolve({errorType: YAPI_SUCCESS, errorMsg: "", result: responseText});
      }, (errorType, errorMsg) => {
        resolve({errorType, errorMsg});
      });
    });
  }
  async reconnect(tryOpenID) {
    this.currentConnID = tryOpenID;
    if (!this.hubSerial || this.infoJson && this.infoJson.nonce && YAPI.GetTickCount() - this.infoJson.stamp > 12e3) {
      if (this._yapi._logLevel >= 4) {
        this._yapi.imm_log("Trying info.json [" + tryOpenID + "]");
      }
      let res_struct = await this.tryFetch("info.json");
      if (res_struct.errorType == YAPI_SUCCESS && res_struct.result) {
        this.infoJson = JSON.parse(res_struct.result);
        this.infoJson.stamp = YAPI.GetTickCount();
        if (this.infoJson && this.infoJson.serialNumber) {
          this.hubSerial = this.infoJson.serialNumber;
        }
      } else if (res_struct.errorType == YAPI_FILE_NOT_FOUND) {
        res_struct = await this.tryFetch("api/module/serialNumber");
        if (res_struct.errorType == YAPI_SUCCESS && res_struct.result) {
          this.hubSerial = res_struct.result;
        }
      }
      if (!this.hubSerial) {
        if (!super.imm_disconnectNow(tryOpenID)) {
          return;
        }
        if (!this.imm_isDisconnecting()) {
          if (this._yapi._logLevel >= 3) {
            this._yapi.imm_log("Failed to load info.json: " + res_struct.errorMsg + " [" + tryOpenID + "]");
          }
        }
        this._lastErrorType = res_struct.errorType;
        this._lastErrorMsg = res_struct.errorMsg;
        this.currentConnID = "";
        this.imm_signalHubDisconnected(tryOpenID);
        return;
      }
    }
    let primaryHub = this._yapi.imm_getPrimaryHub(this);
    if (primaryHub !== this) {
      this.imm_commonDisconnect(tryOpenID, YAPI_SUCCESS, "Hub " + this.hubSerial + " is already connected");
      this.currentConnID = "";
      this.imm_signalHubDisconnected(tryOpenID);
      return;
    }
    let args = "";
    if (this.notifPos >= 0) {
      args = "?abs=" + this.notifPos.toString();
    } else {
      this._firstArrivalCallback = true;
    }
    if (this._yapi._logLevel >= 4) {
      this._yapi.imm_log("Opening http connection to hub (" + args + ") [" + tryOpenID + "]");
    }
    this.notbynRequest = this.imm_sendRequest("GET", "not.byn" + args, null, (moreText) => {
      if (tryOpenID != this.currentConnID) {
        if (this._yapi._logLevel >= 3) {
          this._yapi.imm_log("Previous request still sending data [" + tryOpenID + "]");
        }
        return;
      }
      if (this.infoJson) {
        this.infoJson.stamp = YAPI.GetTickCount();
      }
      if (this._currentState < 0) {
        this.signalHubConnected(tryOpenID, this.hubSerial);
      }
      this._yapi.parseEvents(this, moreText);
    }, (resultText) => {
      if (tryOpenID != this.currentConnID) {
        if (this._yapi._logLevel >= 3) {
          this._yapi.imm_log("Previous request completed [" + tryOpenID + "]");
        }
        return;
      }
      this.reconnect(tryOpenID);
    }, (errorType, errorMsg) => {
      if (tryOpenID != this.currentConnID) {
        if (this._yapi._logLevel >= 3) {
          this._yapi.imm_log("Previous not.byn request says: " + errorMsg + " [" + tryOpenID + "]");
        }
        return;
      }
      if (!this.imm_isDisconnecting()) {
        if (this._yapi._logLevel >= 3) {
          this._yapi.imm_log("Failed to load not.byn (" + args + "): " + errorMsg + " [" + tryOpenID + "]");
        }
      }
      this._lastErrorType = errorType;
      this._lastErrorMsg = errorMsg;
      if (errorType == YAPI_UNAUTHORIZED) {
        this.imm_commonDisconnect(tryOpenID, errorType, errorMsg);
      }
      this.imm_disconnectNow();
    });
  }
  imm_disconnectNow(connID = "") {
    if (!super.imm_disconnectNow(connID)) {
      return false;
    }
    if (!this.notbynRequest) {
      return false;
    }
    let closeConnID = connID ? connID : this.currentConnID;
    this.imm_abortRequest(this.notbynRequest);
    this.notbynRequest = null;
    this.currentConnID = "";
    this.imm_signalHubDisconnected(closeConnID);
    return true;
  }
  async request(method, devUrl, obj_body, tcpchan) {
    if (this._yapi._logLevel >= 3) {
      this.imm_logrequest(method, devUrl, obj_body);
    }
    if (this._currentState < 0) {
      return new YHTTPRequest(null, YAPI.IO_ERROR, "Hub is currently unavailable");
    }
    return new Promise((resolve, reject) => {
      this.imm_sendRequest(method, devUrl.slice(1), obj_body, null, (responseText) => {
        if (this._currentState < 0) {
          resolve(new YHTTPRequest(null, YAPI.IO_ERROR, "Hub is currently unavailable"));
        } else {
          if (this._yapi._logLevel >= 4) {
            this._yapi.imm_log(method + " " + devUrl + " succeeded");
          }
          resolve(new YHTTPRequest(this._yapi.imm_str2bin(responseText)));
        }
      }, (errorType, errorMsg) => {
        if (this._yapi._logLevel >= 4) {
          this._yapi.imm_log(method + " " + devUrl + " failed (" + errorMsg + ")");
        }
        resolve(new YHTTPRequest(null, errorType, errorMsg));
      });
    });
  }
};
var YWebSocketHub = class extends YGenericHub {
  constructor(yapi, urlInfo) {
    super(yapi, urlInfo);
    this._DEFAULT_TCP_ROUND_TRIP_TIME = 30;
    this._DEFAULT_TCP_MAX_WINDOW_SIZE = 4 * 65536;
    this._YIO_DEFAULT_TCP_TIMEOUT = 2e4;
    this._YIO_1_MINUTE_TCP_TIMEOUT = 6e4;
    this._YIO_10_MINUTES_TCP_TIMEOUT = 6e5;
    this._USB_META_UTCTIME_SIZE = 5;
    this._USB_META_DLFLUSH_SIZE = 1;
    this._USB_META_ACK_D2H_PACKET_SIZE = 2;
    this._USB_META_WS_ANNOUNCE_SIZE = 8 + 20;
    this._USB_META_WS_AUTHENTICATION_SIZE = 28;
    this._USB_META_WS_ERROR_SIZE = 6;
    this._USB_META_ACK_UPLOAD_SIZE = 6;
    this._USB_META_WS_VALID_SHA1 = 1;
    this._USB_META_WS_RW = 2;
    this.websocket = null;
    this.tcpChan = [];
    this.nextAsyncId = 48;
    this._connectionTime = 0;
    this._remoteVersion = 0;
    this._remoteSerial = "";
    this._remoteNonce = -1;
    this._nonce = -1;
    this._session_error = null;
    this._session_errno = null;
    this._lastUploadAckBytes = [0];
    this._lastUploadAckTime = [0];
    this._lastUploadRateBytes = [0];
    this._lastUploadRateTime = [0];
    this._uploadRate = [0];
    this.fwd_nonce = -1;
    this.fwd_websocket = null;
    this.fwd_credentials = [];
    this.fwd_closeCallback = null;
    this._connectionState = 2;
    this._tcpRoundTripTime = this._DEFAULT_TCP_ROUND_TRIP_TIME;
    this._tcpMaxWindowSize = this._DEFAULT_TCP_MAX_WINDOW_SIZE;
    this.fwd_connectionState = 1;
  }
  imm_asyncWebSocketError(errorType, message) {
    this._yapi.imm_log("WS: " + message + " on " + this.urlInfo.rootUrl);
  }
  async reconnect(tryOpenID) {
    this._connectionState = 2;
    if (this._yapi._logLevel >= 4) {
      this._yapi.imm_log("Opening websocket connection [" + tryOpenID + "]");
    }
    this.currentConnID = tryOpenID;
    this.imm_webSocketOpen(this.urlInfo.authUrl + "not.byn");
    this._firstArrivalCallback = true;
    if (!this.websocket) {
      this.imm_commonDisconnect(tryOpenID, YAPI_IO_ERROR, "Failed to create WebSocket");
      return;
    }
    this.websocket.onmessage = (evt) => {
      if (this.currentConnID != tryOpenID) {
        if (this._yapi._logLevel >= 4) {
          this._yapi.imm_log("Incoming WebSocket data for previous connection [" + tryOpenID + "]");
        }
        return;
      }
      this._webSocketMsg(new Uint8Array(evt.data));
      if (this._connectionState == 4) {
        this._connectionState = 5;
        this.signalHubConnected(tryOpenID, this._remoteSerial);
      } else if (this._connectionState == 0) {
        let errMsg = this._session_error ? "WebSocket error: " + this._session_error : "Websocket I/O error";
        if (this._session_errno == 401) {
          this.imm_commonDisconnect(tryOpenID, YAPI_UNAUTHORIZED, errMsg);
        } else {
          this._lastErrorType = YAPI_IO_ERROR;
          this._lastErrorMsg = errMsg;
        }
        this.imm_disconnectNow();
      }
    };
    this.websocket.onclose = (evt) => {
      if (this.currentConnID != tryOpenID) {
        if (this._yapi._logLevel >= 4) {
          this._yapi.imm_log("WebSocket close received for previous connection [" + tryOpenID + "], now using [" + this.currentConnID + "]");
        }
        return;
      }
      if (this._yapi._logLevel >= 4) {
        this._yapi.imm_log("WebSocket connection closed [" + tryOpenID + "]");
      }
      this._connectionState = 1;
      this.websocket = null;
      if (this.retryDelay < 0) {
        this.imm_commonDisconnect(tryOpenID, YAPI_IO_ERROR, "Websocket callback connection closed");
      }
      this.imm_dropAllPendingConnection();
      this.imm_signalHubDisconnected(tryOpenID);
    };
    this.websocket.onerror = (evt) => {
      if (this.currentConnID != tryOpenID) {
        if (this._yapi._logLevel >= 4) {
          this._yapi.imm_log("WebSocket error received for previous connection [" + tryOpenID + "]");
        }
        return;
      }
      if (evt.message && (!/ ETIMEDOUT /.test(evt.message) || this._yapi._logLevel >= 4)) {
        this._yapi.imm_log("WebSocket error [" + tryOpenID + "]: ", evt);
        this._lastErrorType = YAPI_IO_ERROR;
        this._lastErrorMsg = evt.message;
      }
      if (this.retryDelay < 0) {
        this.imm_commonDisconnect(tryOpenID, YAPI_IO_ERROR, "Websocket callback connection closed");
      }
      this.imm_disconnectNow();
      this.imm_signalHubDisconnected(tryOpenID);
    };
    if (this.timeoutId) {
      clearTimeout(this.timeoutId);
    }
    this.timeoutId = setTimeout(() => {
      if (!this.imm_isForwarded()) {
        this._yapi.imm_log("WS: connection stalled during open [" + tryOpenID + "]");
        this.imm_disconnectNow();
      }
    }, this.stalledTimeoutMs);
  }
  imm_computeAuth(user, pass, serial, nonce) {
    let ha1_str = user + ":" + serial + ":" + pass;
    let ha1 = this._yapi.imm_bin2hexstr(this._yapi.imm_yMD5(ha1_str)).toLowerCase();
    let nonce8 = new Uint8Array([(nonce & 255) >>> 0, (nonce & 65280) >>> 8, (nonce & 16711680) >>> 16, nonce >>> 24]);
    let sha1_raw = ha1 + this._yapi.imm_bin2hexstr(nonce8).toLowerCase();
    return this._yapi.imm_ySHA1(sha1_raw.toLowerCase());
  }
  imm_isForwarded() {
    return this.fwd_connectionState == 5 && this.fwd_websocket !== null;
  }
  async _webSocketMsg(arr_bytes) {
    try {
      if (this.imm_isForwarded()) {
        this.lastPingStamp = Date.now();
        this.fwd_websocket.send(arr_bytes);
        return;
      }
      let reltime = (this._yapi.GetTickCount() - this._connectionTime) / 1e3;
      let ystream = arr_bytes[0] >>> 3;
      let text = "";
      if (ystream == 8) {
        for (let i = 1; i < arr_bytes.length; i++) {
          text += String.fromCharCode(arr_bytes[i]);
        }
        await this._yapi.parseEvents(this, text);
        return;
      }
      let ws = this.websocket;
      let tcpchan = arr_bytes[0] & 7;
      if (ystream == 1 || ystream == 2 || ystream == 9) {
        if (tcpchan > 3) {
          this.imm_asyncWebSocketError(YAPI_IO_ERROR, "Unexpected frame for tcpChan " + tcpchan + " (" + ystream + ")");
          return;
        }
        let tcp_end = arr_bytes.length;
        let yreq = this.tcpChan[tcpchan];
        if (!yreq) {
          this.imm_asyncWebSocketError(YAPI_IO_ERROR, "Drop frame for closed tcpChan " + tcpchan + " (" + ystream + ")");
          return;
        }
        if (ystream == 9) {
          tcp_end--;
          let rcvId = arr_bytes[tcp_end];
          if (this._yapi._logLevel >= 5) {
            this._yapi.imm_log("async-" + rcvId + " close received");
          }
          if (yreq.asyncId == 0) {
            if (this._yapi._logLevel >= 4) {
              this._yapi.imm_log("async-" + rcvId + " close received while req @" + yreq._creat + " was pending");
            }
            this.imm_asyncWebSocketError(YAPI_IO_ERROR, "Asynchronous close received, sync reply request");
            return;
          } else if (yreq.asyncId != rcvId) {
            if (this._yapi._logLevel >= 4) {
              this._yapi.imm_log("async-" + rcvId + " close received instead of async-" + yreq.asyncId + " close");
            }
            this.imm_asyncWebSocketError(YAPI_IO_ERROR, "Incorrect async-close signature on tcpChan " + tcpchan);
            return;
          }
        }
        let oldArr = yreq.bin_result;
        let newArr = new Uint8Array(oldArr.length + tcp_end - 1);
        newArr.set(oldArr, 0);
        newArr.set(arr_bytes.subarray(1, tcp_end), oldArr.length);
        yreq.bin_result = newArr;
        if (ystream == 2 || ystream == 9) {
          this.tcpChan[tcpchan] = yreq.next;
          if (ystream == 2) {
            if (yreq.asyncId != 0) {
              if (this._yapi._logLevel >= 4) {
                this._yapi.imm_log("Synchronous close received instead of async-" + yreq.asyncId + " close");
              }
              this.imm_asyncWebSocketError(YAPI_IO_ERROR, "Synchronous close received, async ack expected");
              return;
            } else if (this.websocket) {
              if (yreq.toBeSent && yreq.sendPos < yreq.toBeSent.length) {
                this._yapi.imm_log("WS: tcpclose at " + yreq.sendPos + " < " + yreq.toBeSent.length);
                this.imm_disconnectNow();
                if (yreq.timeoutId) {
                  clearTimeout(yreq.timeoutId);
                }
                if (yreq.asyncId == 0) {
                  yreq.errorType = YAPI_IO_ERROR;
                  yreq.errorMsg = "TCP closed during upload";
                  if (yreq.acceptor) {
                    try {
                      yreq.acceptor(yreq);
                    } catch (e) {
                    }
                  }
                }
                return;
              }
              if (yreq.timeoutId) {
                let frame = new Uint8Array(1);
                frame[0] = (2 << 3) + tcpchan;
                this.websocket.send(frame);
              }
            }
          }
          if (yreq.timeoutId) {
            clearTimeout(yreq.timeoutId);
            yreq.timeoutId = 0;
          }
          let pos = yreq.bin_result.indexOf(13);
          if (pos < 0) {
            yreq.errorType = YAPI_IO_ERROR;
            yreq.errorMsg = "Bad response header";
          } else {
            let header = this._yapi.imm_bin2str(yreq.bin_result.subarray(0, pos));
            let words = header.split(" ");
            if (words[0] == "OK") {
              yreq.errorType = YAPI_SUCCESS;
              let nextpos = yreq.bin_result.indexOf(13, pos + 2);
              while (nextpos > pos + 2) {
                pos = nextpos;
                nextpos = yreq.bin_result.indexOf(13, pos + 2);
              }
              if (nextpos < 0) {
                nextpos = pos;
              }
              yreq.bin_result = yreq.bin_result.subarray(nextpos + 2);
            } else if (words[0] == "0K") {
              yreq.errorType = YAPI_IO_ERROR;
              yreq.errorMsg = "Unexpected persistent connection";
            } else {
              let status = parseInt(words[1]);
              yreq.errorType = status == 401 ? YAPI_UNAUTHORIZED : YAPI_IO_ERROR;
              yreq.errorMsg = "HTTP error " + header.slice(words[0].length + 1) + " on " + yreq.devUrl;
            }
          }
          if (yreq.asyncId == 0) {
            if (this._yapi._logLevel >= 5) {
              this._yapi.imm_log("request @" + yreq._creat + " done, status=" + yreq.errorType);
            }
            this.imm_sendPendingRequest(tcpchan);
            if (yreq.acceptor) {
              yreq.acceptor(yreq);
            }
          } else {
            if (yreq.errorType != YAPI_SUCCESS) {
              this.imm_asyncWebSocketError(YAPI_IO_ERROR, "Async request error: " + yreq.errorMsg);
            }
          }
        }
        return;
      }
      if (!this.websocket) {
        return;
      }
      if (ystream == 5) {
        let metatype = arr_bytes[1];
        switch (metatype) {
          case 4:
            if (arr_bytes.length < 1 + this._USB_META_WS_ANNOUNCE_SIZE) {
              return;
            }
            this._remoteVersion = arr_bytes[2];
            if (this._remoteVersion < 1) {
              return;
            }
            let maxtcpws = (arr_bytes[3] << 4) + (arr_bytes[4] << 12);
            if (maxtcpws > 0) {
              this._tcpMaxWindowSize = maxtcpws;
            }
            this._remoteNonce = arr_bytes[5] + (arr_bytes[6] << 8) + (arr_bytes[7] << 16) + (arr_bytes[8] << 24);
            for (let i = 9; i < 9 + 20; i++) {
              if (arr_bytes[i] == 0) {
                this._remoteSerial = this._yapi.imm_bin2str(arr_bytes.subarray(9, i));
                break;
              }
            }
            let nonce = new Uint8Array(4);
            this.imm_getRandomValues(nonce);
            this._nonce = nonce[0] + (nonce[1] << 8) + (nonce[2] << 16) + (nonce[3] << 24);
            this._connectionTime = this._yapi.GetTickCount();
            this._connectionState = 3;
            let frame = new Uint8Array(1 + this._USB_META_WS_AUTHENTICATION_SIZE);
            let version = this._remoteVersion < 2 ? this._remoteVersion : 2;
            let flags = 0;
            frame[0] = 5 << 3;
            frame[1] = 5;
            frame[2] = version;
            if (this.urlInfo.pass != "") {
              flags = this._USB_META_WS_VALID_SHA1;
              let sha1 = this.imm_computeAuth(this.urlInfo.user, this.urlInfo.pass, this._remoteSerial, this._remoteNonce);
              for (let i = 0; i < sha1.length; i++) {
                frame[9 + i] = sha1[i];
              }
            }
            frame[3] = flags & 255;
            frame[4] = flags >>> 8;
            frame[5] = this._nonce & 255;
            frame[6] = this._nonce >>> 8 & 255;
            frame[7] = this._nonce >>> 16 & 255;
            frame[8] = this._nonce >>> 24 & 255;
            this.websocket.send(frame);
            break;
          case 5:
            if (this._connectionState != 3) {
              return;
            }
            if (arr_bytes.length < 1 + this._USB_META_WS_AUTHENTICATION_SIZE) {
              return;
            }
            this._tcpRoundTripTime = this._yapi.GetTickCount() - this._connectionTime + 1;
            if (this._tcpMaxWindowSize < 2048 && this._tcpRoundTripTime < 7) {
              this._tcpRoundTripTime = 7;
            }
            let uploadRate = this._tcpMaxWindowSize * 1e3 / this._tcpRoundTripTime >> 0;
            if (this._yapi._logLevel >= 4) {
              this._yapi.imm_log("RTT=" + this._tcpRoundTripTime + "ms, WS=" + this._tcpMaxWindowSize + ", uploadRate=" + uploadRate / 1e3 + " KB/s");
            }
            this._remoteVersion = arr_bytes[2];
            if (this._remoteVersion < 1) {
              return;
            }
            let inflags = arr_bytes[3] + (arr_bytes[4] << 8);
            if ((inflags & this._USB_META_WS_RW) != 0) {
              this._rwAccess = true;
            } else {
              this._rwAccess = false;
            }
            if ((inflags & this._USB_META_WS_VALID_SHA1) != 0) {
              let remote_sha1 = arr_bytes.subarray(9, 29);
              let sha1 = this.imm_computeAuth(this.urlInfo.user, this.urlInfo.pass, this._remoteSerial, this._nonce);
              for (let i = 0; i < sha1.length; i++) {
                if (sha1[i] != remote_sha1[i]) {
                  this._session_errno = 401;
                  this._session_error = "Authentication failed";
                  this._connectionState = 0;
                  return;
                }
              }
              this._connectionState = 4;
            } else {
              if (this.urlInfo.pass == "") {
                this._connectionState = 4;
              } else {
                this._session_errno = 401;
                if (this.urlInfo.user == "admin" && !this._rwAccess) {
                  this._session_error = "Authentication as admin failed";
                } else {
                  this._session_error = "Password not set on remote hub";
                }
                this._connectionState = 0;
                return;
              }
            }
            break;
          case 6:
            this._session_errno = arr_bytes[3] + (arr_bytes[4] << 8);
            if (this._session_errno == 401) {
              this._session_error = "Authentication failed";
            } else {
              this._session_error = "Remote hub closed connection with error " + this._session_errno;
            }
            this._connectionState = 0;
            break;
          case 7:
            tcpchan = arr_bytes[2];
            if (this.tcpChan[tcpchan]) {
              let yreq = this.tcpChan[tcpchan];
              let ackBytes = arr_bytes[3] + (arr_bytes[4] << 8) + (arr_bytes[5] << 16) + (arr_bytes[6] << 24);
              let ackTime = this._yapi.GetTickCount();
              if (this._lastUploadAckTime[tcpchan] != 0 && ackBytes > this._lastUploadAckBytes[tcpchan]) {
                this._lastUploadAckBytes[tcpchan] = ackBytes;
                this._lastUploadAckTime[tcpchan] = ackTime;
                let deltaBytes = ackBytes - this._lastUploadRateBytes[tcpchan];
                let deltaTime = ackTime - this._lastUploadRateTime[tcpchan];
                if (deltaTime < 500)
                  break;
                if (deltaTime < 1e3 && deltaBytes < 65536)
                  break;
                this._lastUploadRateBytes[tcpchan] = ackBytes;
                this._lastUploadRateTime[tcpchan] = ackTime;
                if (yreq.progressCb && yreq.toBeSent) {
                  yreq.progressCb(ackBytes, yreq.toBeSent.length);
                }
                let newRate = deltaBytes * 1e3 / deltaTime;
                this._uploadRate[tcpchan] = 0.8 * this._uploadRate[tcpchan] + 0.3 * newRate >> 0;
                if (this._yapi._logLevel >= 5) {
                  this._yapi.imm_log("New rate: " + this._uploadRate[tcpchan] / 1e3 + " KB/s (last " + (deltaBytes / 1e3 >> 0) + "KB sent at " + (newRate >> 0) / 1e3 + " KB/s)");
                }
              } else {
                this._lastUploadAckBytes[tcpchan] = ackBytes;
                this._lastUploadAckTime[tcpchan] = ackTime;
                this._lastUploadRateBytes[tcpchan] = ackBytes;
                this._lastUploadRateTime[tcpchan] = ackTime;
                if (yreq.progressCb && yreq.toBeSent) {
                  yreq.progressCb(ackBytes, yreq.toBeSent.length);
                }
                this.imm_sendPendingRequest(tcpchan);
              }
            }
            break;
        }
        return;
      }
      this.imm_asyncWebSocketError(YAPI_IO_ERROR, "Unsupported message: " + this._yapi.imm_bin2hexstr(arr_bytes));
    } catch (e) {
      this._yapi.imm_log("Unhandled exception in _webSocketMsg:", e);
    }
  }
  imm_webSocketSend(arr_bytes) {
    if (this.websocket) {
      this.websocket.send(arr_bytes);
    }
  }
  async request(method, devUrl, obj_body, tcpchan) {
    if (this._yapi._logLevel >= 3) {
      this.imm_logrequest(method, devUrl, obj_body);
    }
    let httpPromise = new Promise((resolve, reject) => {
      let subReq = method + " " + devUrl + " \r\n\r\n";
      let ws = this.websocket;
      let isAsync = this._remoteVersion > 0 && devUrl.slice(-2) == "&.";
      let yreq = new YHTTPRequest(new Uint8Array(0));
      if (this._yapi._logLevel >= 5) {
        yreq._creat = (Date.now() % 6e5).toString();
        this._yapi.imm_log("request @" + yreq._creat + ": " + method + " " + devUrl);
      }
      yreq.acceptor = resolve;
      yreq.devUrl = devUrl;
      yreq.sendPos = 0;
      if (obj_body) {
        let boundary = this.imm_getBoundary();
        let body = this.imm_formEncodeBody(obj_body, boundary);
        subReq = subReq.slice(0, -2) + "Content-Type: x-upload, boundary=" + boundary + "\r\n\r\n";
        yreq.toBeSent = new Uint8Array(subReq.length + body.length);
        yreq.toBeSent.set(body, subReq.length);
        yreq.progressCb = obj_body.progressCb;
      } else {
        yreq.toBeSent = new Uint8Array(subReq.length);
      }
      for (let i = 0; i < subReq.length; i++) {
        yreq.toBeSent[i] = subReq.charCodeAt(i);
      }
      if (tcpchan > 3) {
        yreq.errorType = YAPI_IO_ERROR;
        yreq.errorMsg = "Unsupported tcpChan " + tcpchan;
        try {
          yreq.acceptor(yreq);
        } catch (e) {
        }
        return;
      }
      if (!ws || this.imm_isDisconnecting() || this._connectionState != 5) {
        if (this._yapi._logLevel >= 4) {
          let wsState = ws ? " websocket=NULL" : "";
          let dsState = this.imm_isDisconnecting() ? " disconnecting" : "";
          let cnState = this._connectionState != 5 ? " connState=" + this._connectionState : "";
          this._yapi.imm_log("request @" + yreq._creat + " failed, websocket is down:" + wsState + dsState + cnState);
        }
        yreq.errorType = YAPI_IO_ERROR;
        yreq.errorMsg = "WebSocket not connected";
        try {
          yreq.acceptor(yreq);
        } catch (e) {
        }
        return;
      }
      if (isAsync) {
        yreq.asyncId = this.nextAsyncId++;
        if (this.nextAsyncId >= 127) {
          this.nextAsyncId = 48;
        }
      }
      let queue = this.tcpChan[tcpchan];
      if (queue) {
        while (queue.next) {
          queue = queue.next;
        }
        queue.next = yreq;
      } else {
        this.tcpChan[tcpchan] = yreq;
      }
      this.imm_sendPendingRequest(tcpchan);
    });
    return httpPromise;
  }
  imm_sendPendingRequest(tcpchan) {
    let yreq = this.tcpChan[tcpchan];
    while (yreq) {
      if (!this.websocket || this.imm_isDisconnecting() || this._connectionState != 5) {
        if (this._yapi._logLevel >= 4) {
          this._yapi.imm_log("request @" + yreq._creat + " failed, websocket is down");
        }
        yreq.errorType = YAPI_IO_ERROR;
        yreq.errorMsg = "WebSocket not connected";
        if (yreq.acceptor) {
          try {
            yreq.acceptor(yreq);
          } catch (e) {
          }
        }
        yreq = yreq.next;
        continue;
      }
      let pendingCount = 1;
      for (let yr = yreq; yr.next; yr = yr.next) {
        pendingCount++;
      }
      if (!yreq.toBeSent) {
        if (yreq.asyncId == 0) {
          if (this._yapi._logLevel >= 5) {
            this._yapi.imm_log(pendingCount.toString() + " req pending, @" + yreq._creat + " not completed");
          }
          return;
        }
        yreq = yreq.next;
        continue;
      }
      let isAsync = yreq.asyncId != 0;
      let asyncCloseSet = false;
      let pos = yreq.sendPos;
      let end = yreq.toBeSent.length;
      let i, frame;
      if (end > 2108 && this._remoteVersion >= 2 && tcpchan == 0) {
        if (pos == 0) {
          end = 2108;
          this._lastUploadAckBytes[tcpchan] = 0;
          this._lastUploadAckTime[tcpchan] = 0;
          this._uploadRate[tcpchan] = this._tcpMaxWindowSize * 1e3 / this._tcpRoundTripTime >> 0;
        } else if (this._lastUploadAckTime[tcpchan] == 0) {
          if (yreq.sendTimeoutId)
            clearTimeout(yreq.sendTimeoutId);
          yreq.sendTimeoutId = setTimeout(() => {
            this.imm_sendPendingRequest(tcpchan);
          }, this._tcpRoundTripTime);
          return;
        } else {
          let bytesOnTheAir = pos - this._lastUploadAckBytes[tcpchan];
          let uploadRate = this._uploadRate[tcpchan];
          let timeOnTheAir = this._yapi.GetTickCount() - this._lastUploadAckTime[tcpchan];
          let toBeSent = 2 * uploadRate + 1024 - bytesOnTheAir + uploadRate * timeOnTheAir / 1e3 >> 0;
          if (toBeSent + bytesOnTheAir > this._DEFAULT_TCP_MAX_WINDOW_SIZE) {
            toBeSent = this._DEFAULT_TCP_MAX_WINDOW_SIZE - bytesOnTheAir;
          }
          if (toBeSent < 64) {
            let waitTime = 1e3 * (128 - toBeSent) / uploadRate >> 0;
            if (waitTime < 2)
              waitTime = 2;
            if (yreq.sendTimeoutId)
              clearTimeout(yreq.sendTimeoutId);
            yreq.sendTimeoutId = setTimeout(() => {
              this.imm_sendPendingRequest(tcpchan);
            }, waitTime);
            return;
          }
          if (end > pos + toBeSent) {
            if (toBeSent > 124) {
              toBeSent = (toBeSent / 124 >> 0) * 124;
            }
            end = pos + toBeSent;
          }
        }
      }
      while (pos < end) {
        let framelen = 1 + end - pos;
        if (framelen > 125)
          framelen = 125;
        let datalen = framelen - 1;
        if (isAsync && pos + datalen == yreq.toBeSent.length && framelen < 125) {
          frame = new Uint8Array(framelen + 1);
          frame[0] = 8 * 9 + tcpchan;
          frame[framelen] = yreq.asyncId;
          asyncCloseSet = true;
        } else {
          frame = new Uint8Array(framelen);
          frame[0] = 8 * 1 + tcpchan;
        }
        frame.set(yreq.toBeSent.subarray(pos, pos + datalen), 1);
        pos += datalen;
        this.imm_webSocketSend(frame);
      }
      let sent = pos - yreq.sendPos;
      yreq.sendPos = pos;
      if (yreq.sendPos < yreq.toBeSent.length) {
        let waitTime = 1e3 * sent / this._uploadRate[tcpchan] >> 0;
        if (waitTime < 2)
          waitTime = 2;
        if (yreq.sendTimeoutId)
          clearTimeout(yreq.sendTimeoutId);
        yreq.sendTimeoutId = setTimeout(() => {
          this.imm_sendPendingRequest(tcpchan);
        }, waitTime);
        return;
      }
      if (isAsync && !asyncCloseSet) {
        frame = new Uint8Array(2);
        frame[0] = 8 * 9 + tcpchan;
        frame[1] = yreq.asyncId;
        this.imm_webSocketSend(frame);
      }
      yreq.toBeSent = null;
      if (isAsync && yreq.acceptor) {
        try {
          yreq.acceptor(yreq);
        } catch (e) {
          this._yapi.imm_log("WS: async acceptor exception: ", e);
        }
      }
      let mstimeout = this._yapi._networkTimeoutMs;
      if (yreq.devUrl) {
        if (yreq.devUrl.indexOf("/testcb.txt") >= 0) {
          mstimeout = this._YIO_1_MINUTE_TCP_TIMEOUT;
        } else if (yreq.devUrl.indexOf("/logger.json") >= 0) {
          mstimeout = this._YIO_1_MINUTE_TCP_TIMEOUT;
        } else if (yreq.devUrl.indexOf("/rxmsg.json") >= 0) {
          mstimeout = this._YIO_1_MINUTE_TCP_TIMEOUT;
        } else if (yreq.devUrl.indexOf("/rxdata.bin") >= 0) {
          mstimeout = this._YIO_1_MINUTE_TCP_TIMEOUT;
        } else if (yreq.devUrl.indexOf("/at.txt") >= 0) {
          mstimeout = this._YIO_1_MINUTE_TCP_TIMEOUT;
        } else if (yreq.devUrl.indexOf("/files.json") >= 0) {
          mstimeout = this._YIO_1_MINUTE_TCP_TIMEOUT;
        } else if (yreq.devUrl.indexOf("/upload.html") >= 0) {
          mstimeout = this._YIO_10_MINUTES_TCP_TIMEOUT;
        } else if (yreq.devUrl.indexOf("/flash.json") >= 0) {
          mstimeout = this._YIO_10_MINUTES_TCP_TIMEOUT;
        } else if (yreq.devUrl.indexOf("/Yvw4I.js") >= 0) {
          mstimeout = this._YIO_10_MINUTES_TCP_TIMEOUT;
        }
      }
      yreq.timeoutId = setTimeout((chan, yr) => {
        this.imm_abortRequest(chan, yr);
      }, mstimeout, tcpchan, yreq);
      yreq._sent = (Date.now() % 6e5).toString();
      if (this._yapi._logLevel >= 5) {
        this._yapi.imm_log("req @" + yreq._creat + " sent (1/" + pendingCount.toString() + ")" + (isAsync ? " async-" + yreq.asyncId + ", continue" : ", waiting for reply"));
      }
      if (!isAsync) {
        return;
      }
      yreq = yreq.next;
    }
  }
  imm_abortRequest(tcpchan, yreq) {
    if (!yreq.timeoutId)
      return;
    yreq.timeoutId = null;
    if (yreq.asyncId == 0) {
      let frame = new Uint8Array(1);
      frame[0] = 8 * 2 + tcpchan;
      this.imm_webSocketSend(frame);
      if (this._yapi._logLevel >= 4) {
        let pendingCount = 1;
        for (let yr = yreq; yr.next; yr = yr.next) {
          pendingCount++;
        }
        this._yapi.imm_log(pendingCount.toString() + " req pending, @" + yreq._creat + " is in timeout");
      }
      setTimeout((chan, yr) => {
        this._yapi.imm_log("Dropping synchronous request after timeout: " + yr.devUrl);
        this.imm_forgetRequest(chan, yr);
      }, 5e3, tcpchan, yreq);
    }
    this.imm_asyncWebSocketError(YAPI_IO_ERROR, "Timeout on " + yreq.devUrl + " (tcpchan " + tcpchan + ")");
  }
  imm_forgetRequest(tcpchan, yreq) {
    let queue = this.tcpChan[tcpchan];
    if (queue == yreq) {
      this.tcpChan[tcpchan] = yreq.next;
      if (yreq.asyncId == 0) {
        yreq.errorType = YAPI_IO_ERROR;
        yreq.errorMsg = "Timeout on " + yreq.devUrl + " (tcpchan " + tcpchan + ")";
        if (yreq.acceptor) {
          try {
            yreq.acceptor(yreq);
          } catch (e) {
          }
        }
      }
      this.imm_sendPendingRequest(tcpchan);
    }
  }
  imm_dropAllPendingConnection() {
    if (this.fwd_connectionState != 1 && this.fwd_websocket) {
      this.fwd_connectionState = 1;
      this.fwd_websocket.close();
      this.fwd_websocket = null;
    }
    for (let tcpchan = 0; tcpchan < this.tcpChan.length; tcpchan++) {
      for (let yreq = this.tcpChan[tcpchan]; yreq; yreq = yreq.next) {
        this.tcpChan[tcpchan] = yreq.next;
        if (yreq.timeoutId) {
          clearTimeout(yreq.timeoutId);
          yreq.timeoutId = 0;
        }
        if (yreq.asyncId == 0) {
          if (this._yapi._logLevel >= 4) {
            this._yapi.imm_log("drop @" + yreq._creat + " (websocket down)");
          }
          yreq.errorType = YAPI_IO_ERROR;
          yreq.errorMsg = "Request " + yreq.devUrl + " dropped (websocket down)";
          if (yreq.acceptor) {
            try {
              yreq.acceptor(yreq);
            } catch (e) {
            }
          }
        }
      }
    }
  }
  async websocketJoin(ws, arr_credentials, close_callback) {
    if (this._connectionState != 5) {
      this.imm_asyncWebSocketError(YAPI_IO_ERROR, "Hub is disconnected, cannot join");
      return false;
    }
    this.fwd_websocket = ws;
    this.fwd_credentials = arr_credentials;
    this.fwd_closeCallback = close_callback;
    this.fwd_connectionState = 2;
    ws.onmessage = (evt) => {
      if (this.fwd_connectionState == 5) {
        if (this._connectionState == 5) {
          this.imm_webSocketSend(evt.data);
        } else {
          this._yapi.imm_log("WS: drop packet from fwd API (state=" + this._connectionState + ")");
        }
      } else if (this.fwd_connectionState == 3) {
        this.imm_handleAPIAuthPkt(evt.data);
      } else {
        this._yapi.imm_log("WS: drop packet from fwd API (fwd_state=" + this.fwd_connectionState + ")");
      }
    };
    ws.onclose = (evt) => {
      this.fwd_connectionState = 1;
      this.fwd_websocket = null;
      if (this.fwd_closeCallback) {
        this.fwd_closeCallback();
      }
    };
    return this.imm_sendAPIAnnouncePkt();
  }
  imm_sendAPIAnnouncePkt() {
    if (!this.fwd_websocket) {
      return false;
    }
    let frame = new Uint8Array(1 + this._USB_META_WS_ANNOUNCE_SIZE);
    let nonce = new Uint8Array(4);
    this.imm_getRandomValues(nonce);
    frame[0] = 5 << 3;
    frame[1] = 4;
    frame[2] = 2;
    frame[3] = this._tcpMaxWindowSize >> 4 & 255;
    frame[4] = this._tcpMaxWindowSize >> 12 & 255;
    for (let i = 0; i < 4; i++) {
      frame[5 + i] = nonce[i];
    }
    for (let i = 0; i < this._remoteSerial.length && i < 20; i++) {
      frame[9 + i] = this._remoteSerial.charCodeAt(i);
    }
    this.fwd_nonce = frame[5] + (frame[6] << 8) + (frame[7] << 16) + (frame[8] << 24);
    this.fwd_connectionState = 3;
    this.fwd_websocket.send(frame);
    return true;
  }
  imm_handleAPIAuthPkt(msg) {
    if (msg.length < 1 + this._USB_META_WS_AUTHENTICATION_SIZE || msg[0] != 5 << 3) {
      this._yapi.imm_log("bad-apiauth1\n");
      this.fwd_connectionState = 0;
      return;
    }
    if (msg[1] != 5 || msg[2] > 2) {
      this._yapi.imm_log("bad-apiauth2\n");
      this.fwd_connectionState = 0;
      return;
    }
    this._remoteVersion = msg[2];
    let flags = msg[3] + (msg[4] << 8);
    if ((flags & this._USB_META_WS_VALID_SHA1) == 0) {
      this._yapi.imm_log("bad-apiauth3\n");
      this.fwd_connectionState = 0;
      return;
    }
    if (!this.fwd_websocket) {
      this._yapi.imm_log("no-fwd-ws\n");
      this.fwd_connectionState = 0;
      return;
    }
    let credIdx, remote_sha1 = msg.subarray(9, 29);
    let credentials = this.fwd_credentials;
    for (credIdx = 0; credIdx < credentials.length; credIdx++) {
      let j, sha12 = this.imm_computeAuth(credentials[credIdx].user, credentials[credIdx].pass, this._remoteSerial, this.fwd_nonce);
      for (j = 0; j < sha12.length; j++) {
        if (sha12[j] != remote_sha1[j])
          break;
      }
      if (j >= sha12.length)
        break;
    }
    if (credIdx >= credentials.length) {
      this._yapi.imm_log("bad-apiauth4\n");
      msg.fill(0, 3);
      this.fwd_websocket.send(msg);
      this.fwd_connectionState = 0;
      return;
    }
    msg[3] |= this._USB_META_WS_RW;
    this.fwd_nonce = msg[5] + (msg[6] << 8) + (msg[7] << 16) + (msg[8] << 24);
    let sha1 = this.imm_computeAuth(credentials[credIdx].user, credentials[credIdx].pass, this._remoteSerial, this.fwd_nonce);
    for (let i = 0; i < sha1.length; i++) {
      msg[9 + i] = sha1[i];
    }
    this.fwd_websocket.send(msg);
    this.fwd_connectionState = 5;
  }
  async detach(errType = YAPI.IO_ERROR, errMsg = "Hub has been forcibly detached") {
    let tcpchan_busy;
    let timeout = this._yapi.GetTickCount() + 3e3;
    do {
      tcpchan_busy = false;
      for (let tcpchan = 0; tcpchan < 4; tcpchan++) {
        if (this.tcpChan[tcpchan] != null) {
          tcpchan_busy = true;
          break;
        }
      }
      if (tcpchan_busy) {
        await this._yapi._microSleep_internal();
      }
    } while (tcpchan_busy && timeout > this._yapi.GetTickCount());
    this.imm_commonDisconnect("detach", errType, errMsg);
    this.imm_disconnectNow();
  }
  imm_disconnectNow(connID = "") {
    if (!super.imm_disconnectNow(connID)) {
      return false;
    }
    if (!this.websocket) {
      return false;
    }
    this._connectionState = 1;
    let prevOpenID = connID ? connID : this.currentConnID;
    let websocket = this.websocket;
    this.currentConnID = "";
    this.websocket = null;
    websocket.onclose = null;
    websocket.onerror = null;
    try {
      websocket.close();
    } catch (e) {
    }
    if (websocket.terminate) {
      setTimeout(() => {
        try {
          if (websocket.terminate) {
            websocket.terminate();
          }
        } catch (e) {
        }
      }, 900);
    }
    this.imm_dropAllPendingConnection();
    this.imm_signalHubDisconnected(prevOpenID);
    return true;
  }
  imm_isOnline() {
    if (this._connectionState != 5) {
      return false;
    }
    return super.imm_isOnline();
  }
};
var YHub = class {
  constructor(obj_yapi, hubref) {
    this._hubref = 0;
    this._ctx = obj_yapi;
    this._hubref = hubref;
  }
  async _getStrAttr_internal(attrName) {
    let hub = this._ctx.getGenHub(this._hubref);
    if (hub == null) {
      return "";
    }
    switch (attrName) {
      case "registeredUrl":
        return hub.urlInfo.orgUrl;
      case "connectionUrl":
        return hub.urlInfo.rootUrl;
      case "serialNumber":
        return hub.hubSerial;
      case "errorMessage":
        return hub.get_errorMessage();
      default:
        return "";
    }
  }
  async _getIntAttr_internal(attrName) {
    let hub = this._ctx.getGenHub(this._hubref);
    if (attrName == "isInUse") {
      return hub != null ? 1 : 0;
    }
    if (hub == null) {
      return -1;
    }
    switch (attrName) {
      case "isOnline":
        return hub.imm_isOnline() ? 1 : 0;
      case "isReadOnly":
        return hub.hasRwAccess() ? 0 : 1;
      case "networkTimeout":
        return hub.stalledTimeoutMs;
      case "errorType":
        return hub.get_errorType();
      default:
        return -1;
    }
  }
  async _setIntAttr_internal(attrName, value) {
    let hub = this._ctx.getGenHub(this._hubref);
    if (hub != null && attrName == "networkTimeout") {
      hub.stalledTimeoutMs = value;
    }
  }
  get_knownUrls_internal() {
    let hub = this._ctx.getGenHub(this._hubref);
    if (hub != null) {
      return hub.get_knownUrls();
    }
    return [];
  }
  async _getStrAttr(attrName) {
    return await this._getStrAttr_internal(attrName);
  }
  async _getIntAttr(attrName) {
    return await this._getIntAttr_internal(attrName);
  }
  async _setIntAttr(attrName, value) {
    return await this._setIntAttr_internal(attrName, value);
  }
  async get_registeredUrl() {
    return await this._getStrAttr("registeredUrl");
  }
  async get_knownUrls() {
    return await this.get_knownUrls_internal();
  }
  async get_connectionUrl() {
    return await this._getStrAttr("connectionUrl");
  }
  async get_serialNumber() {
    return await this._getStrAttr("serialNumber");
  }
  async isInUse() {
    return await this._getIntAttr("isInUse") > 0;
  }
  async isOnline() {
    return await this._getIntAttr("isOnline") > 0;
  }
  async isReadOnly() {
    return await this._getIntAttr("isReadOnly") > 0;
  }
  async set_networkTimeout(networkMsTimeout) {
    await this._setIntAttr("networkTimeout", networkMsTimeout);
  }
  async get_networkTimeout() {
    return await this._getIntAttr("networkTimeout");
  }
  async get_errorType() {
    return await this._getIntAttr("errorType");
  }
  async get_errorMessage() {
    return await this._getStrAttr("errorMessage");
  }
  async get_userData() {
    return this._userData;
  }
  async set_userData(data) {
    this._userData = data;
  }
  static FirstHubInUse() {
    return YAPI.nextHubInUseInternal(-1);
  }
  static FirstHubInUseInContext(yctx) {
    return yctx.nextHubInUseInternal(-1);
  }
  nextHubInUse() {
    return this._ctx.nextHubInUseInternal(this._hubref);
  }
};
var YAPIContext = class {
  constructor(system_env) {
    this._detectType = Y_DETECT_NONE;
    this._knownHubsBySerial = {};
    this._knownHubsByUrl = {};
    this._connectedHubs = [];
    this._yhub_cache = {};
    this._ssdpManager = null;
    this._devs = {};
    this._snByUrl = {};
    this._snByName = {};
    this._fnByType = {};
    this._lastErrorType = YAPI_SUCCESS;
    this._lastErrorMsg = "no error";
    this._updateDevListStarted = 0;
    this._pendingCallbacks = [];
    this._logLevel = 2;
    this._logCallback = null;
    this._arrivalCallback = null;
    this._namechgCallback = null;
    this._removalCallback = null;
    this._hubDiscoveryCallback = null;
    this._forwardValues = 0;
    this._calibHandlers = [];
    this._ValueCallbackList = [];
    this._TimedReportCallbackList = [];
    this._beacons = {};
    this._isNodeJS = false;
    this._networkTimeoutMs = DEFAULT_NETWORK_TIMEOUT_MS;
    this._deviceListValidityMs = DEFAULT_DEVICE_LIST_VALIDITY_MS;
    this.defaultEncoding = "binary";
    this.exceptionsDisabled = false;
    this.SUCCESS = 0;
    this.NOT_INITIALIZED = -1;
    this.INVALID_ARGUMENT = -2;
    this.NOT_SUPPORTED = -3;
    this.DEVICE_NOT_FOUND = -4;
    this.VERSION_MISMATCH = -5;
    this.DEVICE_BUSY = -6;
    this.TIMEOUT = -7;
    this.IO_ERROR = -8;
    this.NO_MORE_DATA = -9;
    this.EXHAUSTED = -10;
    this.DOUBLE_ACCES = -11;
    this.UNAUTHORIZED = -12;
    this.RTC_NOT_READY = -13;
    this.FILE_NOT_FOUND = -14;
    this.SSL_ERROR = -15;
    this.defaultCacheValidity = 5;
    this.INVALID_INT = YAPI_INVALID_INT;
    this.INVALID_UINT = YAPI_INVALID_UINT;
    this.INVALID_LONG = YAPI_INVALID_LONG;
    this.INVALID_DOUBLE = YAPI_INVALID_DOUBLE;
    this.MIN_DOUBLE = YAPI_MIN_DOUBLE;
    this.MAX_DOUBLE = YAPI_MAX_DOUBLE;
    this.INVALID_STRING = YAPI_INVALID_STRING;
    this.HASH_BUF_SIZE = YOCTO_HASH_BUF_SIZE;
    this.DETECT_NONE = Y_DETECT_NONE;
    this.DETECT_USB = Y_DETECT_USB;
    this.DETECT_NET = Y_DETECT_NET;
    this.DETECT_ALL = Y_DETECT_ALL;
    this.system_env = system_env || YAPI && YAPI.system_env || _UnspecifiedSystemEnv;
    this._isNodeJS = this.system_env.isNodeJS;
    this._uniqueID = String.fromCharCode(Math.random() * 79 + 48, Math.random() * 79 + 48, Math.random() * 79 + 48);
    this.imm_ResetToDefaults();
  }
  imm_ResetToDefaults() {
    this._detectType = this.DETECT_NONE;
    this._knownHubsBySerial = {};
    this._knownHubsByUrl = {};
    this._connectedHubs = [];
    this._devs = {};
    this._snByUrl = {};
    this._snByName = {};
    this._fnByType = {};
    this._fnByType.Module = new YFunctionType(this, "Module");
    this._lastErrorType = YAPI_SUCCESS;
    this._lastErrorMsg = "no error";
    this._updateDevListStarted = 0;
    this._pendingCallbacks = [];
    this._logLevel = 2;
    this._logCallback = null;
    this._arrivalCallback = null;
    this._namechgCallback = null;
    this._removalCallback = null;
    this._hubDiscoveryCallback = null;
    this._forwardValues = 0;
    this._ValueCallbackList = [];
    this._TimedReportCallbackList = [];
    this._beacons = {};
    this._calibHandlers = [];
    for (let i = 1; i <= 20; i++) {
      this.RegisterCalibrationHandler(i, this.LinearCalibrationHandler);
    }
    this.RegisterCalibrationHandler(YOCTO_CALIB_TYPE_OFS, this.LinearCalibrationHandler);
    this.exceptionsDisabled = false;
  }
  _throw(int_errType, str_errMsg, obj_retVal) {
    this._lastErrorType = int_errType;
    this._lastErrorMsg = str_errMsg;
    if (!this.exceptionsDisabled) {
      let exc = new YoctoError(str_errMsg);
      exc.errorType = int_errType;
      throw exc;
    }
    return obj_retVal;
  }
  imm_setErr(errmsg, int_errType, str_errMsg, obj_retVal) {
    if (errmsg) {
      errmsg.msg = str_errMsg;
    }
    this._lastErrorType = int_errType;
    this._lastErrorMsg = str_errMsg;
    return obj_retVal;
  }
  imm_setSystemEnv(env) {
    this.system_env = env;
    this._isNodeJS = env.isNodeJS;
  }
  imm_log(msg, ...moreArgs) {
    let now = new Date();
    let day = now.getFullYear().toString() + "-" + ("0" + (now.getMonth() + 1)).slice(-2) + "-" + ("0" + now.getDate()).slice(-2);
    let time = ("0" + now.getHours().toString()).slice(-2) + ":" + ("0" + now.getMinutes()).slice(-2) + ":" + ("0" + now.getSeconds()).slice(-2);
    let prefix = day + " " + time + " [" + this._uniqueID + "] ";
    let isError = false;
    if (moreArgs.length > 0) {
      if (moreArgs[0].constructor && /Error/i.test(moreArgs[0].constructor.name)) {
        isError = true;
      }
    }
    if (this._logCallback) {
      try {
        if (moreArgs.length > 0) {
          if (moreArgs[0].message) {
            msg += moreArgs[0].message;
          } else {
            msg += moreArgs[0].toString();
          }
        }
        this._logCallback(prefix + msg);
      } catch (e) {
        console.error(prefix + "Exception in custom log callback: ", e);
        console.log("... while trying to log:");
        if (isError) {
          console.error(prefix + msg, ...moreArgs);
        } else {
          console.log(prefix + msg, ...moreArgs);
        }
      }
    } else {
      if (isError) {
        console.error(prefix + msg, ...moreArgs);
      } else {
        console.log(prefix + msg, ...moreArgs);
      }
    }
  }
  async RegisterLogFunction(logfun) {
    this._logCallback = logfun;
    return YAPI_SUCCESS;
  }
  imm_getHub(obj_urlInfo) {
    return this._knownHubsByUrl[obj_urlInfo.rootUrl];
  }
  imm_getPrimaryHub(hub) {
    let primaryHub = this._knownHubsBySerial[hub.hubSerial];
    if (!primaryHub || primaryHub === hub) {
      this._knownHubsBySerial[hub.hubSerial] = hub;
      this._knownHubsByUrl[hub.urlInfo.rootUrl] = hub;
      return hub;
    }
    if (primaryHub._currentState >= hub._currentState) {
      primaryHub.imm_inheritFrom(hub);
      return primaryHub;
    }
    this._knownHubsBySerial[hub.hubSerial] = hub;
    hub.imm_inheritFrom(primaryHub);
    return hub;
  }
  async _addConnectedHub(newhub) {
    let serial = this._snByUrl[newhub.urlInfo.rootUrl];
    if (!serial) {
      let newdev = new YDevice(this, newhub.urlInfo.rootUrl, null, null);
      await newdev.refresh();
    }
    let hubFound = false;
    for (let i = 0; i < this._connectedHubs.length; i++) {
      let url = this._connectedHubs[i].urlInfo.rootUrl;
      if (newhub.urlInfo.rootUrl == url) {
        hubFound = true;
        break;
      }
    }
    if (!hubFound) {
      this._connectedHubs.push(newhub);
    }
  }
  imm_isActiveHub(hubSerial) {
    for (let i = 0; i < this._connectedHubs.length; i++) {
      let hubSerials = this._connectedHubs[i].serialByYdx;
      if (hubSerials && hubSerials[0] == hubSerial) {
        return true;
      }
    }
    return false;
  }
  imm_dropConnectedHub(hub) {
    let idx = this._connectedHubs.indexOf(hub);
    if (idx < 0) {
      return;
    }
    for (let j = 0; j < hub.serialByYdx.length; j++) {
      let serial = hub.serialByYdx[j];
      if (serial && this._devs[serial]) {
        if (this._removalCallback) {
          let module = YModule.FindModuleInContext(this, serial + ".module");
          this._pendingCallbacks.push({event: "-", serial, module});
        }
        try {
          this.imm_forgetDevice(this._devs[serial]);
        } catch (e) {
        }
      }
    }
    idx = this._connectedHubs.indexOf(hub);
    if (idx >= 0) {
      this._connectedHubs.splice(idx, 1);
    }
  }
  async _ensureUpdateDeviceListNotRunning() {
    while (this._updateDevListStarted && this.GetTickCount() - this._updateDevListStarted < 30 * 1e3) {
      await this.Sleep(25);
    }
  }
  async _updateDeviceList_internal(bool_forceupdate, bool_invokecallbacks) {
    if (this._updateDevListStarted && this.GetTickCount() - this._updateDevListStarted < 30 * 1e3) {
      return {
        errorType: YAPI_SUCCESS,
        errorMsg: "no error"
      };
    }
    for (let i = 0; i < this._connectedHubs.length; i++) {
      if (this._connectedHubs[i]._firstArrivalCallback && bool_invokecallbacks && this._arrivalCallback) {
        bool_forceupdate = true;
        break;
      }
    }
    if (bool_forceupdate) {
      for (let i = 0; i < this._connectedHubs.length; i++) {
        this._connectedHubs[i].imm_forceUpdate();
      }
    }
    try {
      this._updateDevListStarted = this.GetTickCount();
      let hubs = [];
      for (let i = 0; i < this._connectedHubs.length; i++) {
        let hub = this._connectedHubs[i];
        let rootUrl = hub.urlInfo.rootUrl;
        let hubDev = this.imm_getDevice(rootUrl);
        if (!hubDev) {
          continue;
        }
        if (hub._currentState < 1) {
          if (this._logLevel >= 4) {
            this.imm_log("Skip updateDeviceList for hub " + hub.urlInfo.host + ", currently offline");
          }
          continue;
        }
        if (hub.devListExpires <= this.GetTickCount()) {
          hub._missing = {};
          hubs.push(hub);
        }
      }
      for (let serial in this._devs) {
        let rooturl = this._devs[serial].imm_getRootUrl();
        for (let i = 0; i < hubs.length; i++) {
          let huburl = hubs[i].urlInfo.rootUrl;
          if (rooturl.substr(0, huburl.length) == huburl) {
            hubs[i]._missing[serial] = true;
          }
        }
      }
      let update_promises = [];
      for (let i = 0; i < hubs.length; i++) {
        let prom = hubs[i].hubUpdateDeviceList();
        update_promises.push(prom);
      }
      let newDeviceCounts = await Promise.all(update_promises);
      let newDeviceArrived = false;
      for (let res of newDeviceCounts) {
        newDeviceArrived = newDeviceArrived || res > 0;
      }
      if (bool_invokecallbacks) {
        let nbEvents = this._pendingCallbacks.length;
        for (let i = 0; i < nbEvents; i++) {
          let evt = this._pendingCallbacks[i];
          switch (evt.event) {
            case "+":
              if (this._logLevel >= 3) {
                this.imm_log("Device " + evt.serial + " plugged");
              }
              if (this._arrivalCallback) {
                try {
                  await evt.module.load(this.defaultCacheValidity);
                  await this._arrivalCallback(evt.module);
                } catch (e) {
                  this.imm_log("Exception in device arrival callback:", e);
                }
              }
              break;
            case "/":
              if (this._namechgCallback) {
                try {
                  await this._namechgCallback(evt.module);
                } catch (e) {
                  this.imm_log("Exception in device change callback:", e);
                }
              }
              break;
            case "-":
              if (this._logLevel >= 3) {
                this.imm_log("Device " + evt.serial + " unplugged");
              }
              if (this._removalCallback) {
                try {
                  await this._removalCallback(evt.module);
                } catch (e) {
                  this.imm_log("Exception in device removal callback:", e);
                }
              }
              break;
          }
        }
        this._pendingCallbacks = this._pendingCallbacks.slice(nbEvents);
      }
      if (newDeviceArrived) {
        for (let fun of this._ValueCallbackList) {
          if (!fun._hwId) {
            fun.isOnline();
          }
        }
        for (let fun of this._TimedReportCallbackList) {
          if (!fun._hwId) {
            fun.isOnline();
          }
        }
      }
    } finally {
      this._updateDevListStarted = 0;
    }
    return {
      errorType: YAPI_SUCCESS,
      errorMsg: "no error"
    };
  }
  async updateDeviceList_process(hub, hubDev, whitePages, yellowPages) {
    let newDevices = 0;
    let refresh = {};
    let serial = null;
    for (let classname in yellowPages) {
      let obj_yprecs = yellowPages[classname];
      let ftype = this._fnByType[classname];
      if (ftype == void 0) {
        ftype = new YFunctionType(this, classname);
        this._fnByType[classname] = ftype;
      }
      for (let i = 0; i < obj_yprecs.length; i++) {
        let yprec = obj_yprecs[i];
        let hwid = yprec.hardwareId;
        let basetype = yprec.baseType;
        if (ftype.imm_reindexFunction(hwid, yprec["logicalName"], yprec["advertisedValue"], basetype)) {
          serial = hwid.substr(0, hwid.indexOf("."));
          refresh[serial] = true;
        }
      }
    }
    for (let i = 0; i < whitePages.length; i++) {
      let devinfo = whitePages[i];
      serial = devinfo.serialNumber;
      let devydx = devinfo.index;
      let rooturl = devinfo.networkUrl.slice(0, -3);
      if (rooturl.charAt(0) == "/")
        rooturl = hubDev.imm_getRootUrl() + rooturl.substr(1);
      let currdev = this._devs[serial];
      if (this._logLevel >= 5) {
        this.imm_log("Device " + serial + " present, currdev " + (currdev ? "" : "NOT ") + "set" + (hub._firstArrivalCallback ? ", firstArrival" : ""));
      }
      if (currdev && hub._firstArrivalCallback) {
        newDevices++;
        if (this._arrivalCallback) {
          let module = YModule.FindModuleInContext(this, serial + ".module");
          this._pendingCallbacks.push({event: "+", serial, module});
        }
      }
      hub.serialByYdx[devydx] = serial;
      if (!currdev) {
        new YDevice(this, rooturl, devinfo, yellowPages);
        newDevices++;
        if (this._arrivalCallback) {
          let module = YModule.FindModuleInContext(this, serial + ".module");
          this._pendingCallbacks.push({event: "+", serial, module});
        }
      } else if (currdev.imm_getLogicalName() != devinfo["logicalName"]) {
        await currdev.refresh();
        if (this._namechgCallback) {
          let module = YModule.FindModuleInContext(this, serial + ".module");
          this._pendingCallbacks.push({event: "/", serial, module});
        }
      } else if (refresh[serial] || currdev.imm_getRootUrl() != rooturl || currdev.imm_getBeacon() != devinfo["beacon"]) {
        await currdev.refresh();
      }
      hub._missing[serial] = false;
    }
    if (this._arrivalCallback && hub._firstArrivalCallback) {
      hub._firstArrivalCallback = false;
    }
    for (serial in hub._missing) {
      if (hub._missing[serial] && this._devs[serial]) {
        if (this._removalCallback) {
          let module = YModule.FindModuleInContext(this, serial + ".module");
          this._pendingCallbacks.push({event: "-", serial, module});
        }
        this.imm_forgetDevice(this._devs[serial]);
      }
    }
    return newDevices;
  }
  async parseEvents(hub, str_lines) {
    if (hub.imm_isDisconnecting()) {
      return;
    }
    hub.isNotifWorking = true;
    hub.lastPingStamp = Date.now();
    if (hub.timeoutId) {
      clearTimeout(hub.timeoutId);
    }
    hub.timeoutId = setTimeout(() => {
      if (!hub.imm_isForwarded()) {
        this.imm_log("Closing stalled connection after " + hub.stalledTimeoutMs / 1e3 + "s");
        hub.imm_disconnectNow();
      }
    }, hub.stalledTimeoutMs);
    let rows = (hub.notifCarryOver + str_lines).split("\n");
    let nrows = rows.length;
    let value;
    if (str_lines.substr(-1) != "\n") {
      hub.notifCarryOver = rows[--nrows];
    } else {
      nrows--;
      hub.notifCarryOver = "";
    }
    for (let idx = 0; idx < nrows; idx++) {
      let ev = rows[idx];
      if (ev.length == 0)
        continue;
      let firstCode = ev.charAt(0);
      if (ev.length >= 3 && firstCode >= NOTIFY_NETPKT_CONFCHGYDX && firstCode <= NOTIFY_NETPKT_TIMEAVGYDX) {
        hub.retryDelay = 15;
        if (hub.notifPos >= 0)
          hub.notifPos += ev.length + 1;
        let devydx = ev.charCodeAt(1) - 65;
        let funydx = ev.charCodeAt(2) - 48;
        if (funydx >= 64) {
          funydx -= 64;
          devydx += 128;
        }
        let serial = hub.serialByYdx[devydx];
        if (serial && this._devs[serial]) {
          let funcid = funydx == 15 ? "time" : this._devs[serial].imm_functionIdByFunYdx(funydx);
          if (funcid != "") {
            let dev;
            value = ev.slice(3);
            switch (firstCode) {
              case NOTIFY_NETPKT_FUNCVALYDX:
                if (value != "")
                  value = value.split("\0")[0];
                await this.setFunctionValue(serial + "." + funcid, value);
                break;
              case NOTIFY_NETPKT_DEVLOGYDX:
                dev = this._devs[serial];
                if (dev != null) {
                  dev.imm_triggerLogPull();
                }
                break;
              case NOTIFY_NETPKT_CONFCHGYDX:
                await this.setConfChange(serial);
                break;
              case NOTIFY_NETPKT_TIMEVALYDX:
              case NOTIFY_NETPKT_TIMEAVGYDX:
              case NOTIFY_NETPKT_TIMEV2YDX:
                let pos, arr = [firstCode == "x" ? 0 : firstCode == "z" ? 1 : 2];
                for (pos = 0; pos < value.length; pos += 2) {
                  arr.push(parseInt(value.substr(pos, 2), 16));
                }
                dev = this._devs[serial];
                if (funcid == "time") {
                  let time = arr[1] + 256 * arr[2] + 65536 * arr[3] + 16777216 * arr[4];
                  let ms = arr[5] * 4;
                  let duration;
                  if (arr.length >= 7) {
                    ms += arr[6] >> 6;
                    let duration_ms = arr[7];
                    duration_ms += (arr[6] & 15) * 256;
                    if (arr[6] & 16) {
                      duration = duration_ms;
                    } else {
                      duration = duration_ms / 1e3;
                    }
                  } else {
                    duration = 0;
                  }
                  dev.imm_setTimeRef(time + ms / 1e3, duration);
                } else {
                  await this.setTimedReport(serial + "." + funcid, dev.imm_getLastTimeRef(), dev.imm_getLastDuration(), arr);
                }
                break;
              case NOTIFY_NETPKT_FUNCV2YDX:
                let rawval = this.imm_decodeNetFuncValV2(value);
                if (rawval != null) {
                  let decodedval = this.imm_decodePubVal(rawval[0], rawval, 1, 6);
                  await this.setFunctionValue(serial + "." + funcid, decodedval);
                }
                break;
              case NOTIFY_NETPKT_FLUSHV2YDX:
              default:
                break;
            }
          }
        }
      } else if (ev.length > 5 && ev.substr(0, 4) == "YN01") {
        hub.retryDelay = 15;
        if (hub.notifPos >= 0)
          hub.notifPos += ev.length + 1;
        let notype = ev.substr(4, 1);
        let parts;
        if (notype == "@") {
          hub.notifPos = parseInt(ev.slice(5));
        } else {
          switch (parseInt(notype)) {
            case 0:
              parts = ev.slice(5).split(",");
              if (parts.length > 2) {
                let int_beacon = parseInt(parts[2]);
                await this.setBeaconChange(parts[0], int_beacon);
              }
            case 2:
            case 4:
            case 8:
              hub.devListExpires = 0;
              break;
            case 5:
              parts = ev.slice(5).split(",");
              if (parts.length > 2) {
                value = parts[2].split("\0");
                await this.setFunctionValue(parts[0] + "." + parts[1], value[0]);
              }
              break;
          }
        }
      } else {
        hub.devListExpires = 0;
        this.imm_log("Bad event on received from server:", ev);
        hub.notifPos = -1;
      }
    }
    if (this._forwardValues > 0) {
      await this.HandleEvents(new YErrorMsg());
    }
  }
  imm_decodeNetFuncValV2(p) {
    let p_ofs = 0;
    let ch = p.charCodeAt(p_ofs) & 255;
    let len = 0;
    let funcVal = [0, 0, 0, 0, 0, 0, 0];
    if (ch < 32 || ch > 32 + 127) {
      return null;
    }
    ch -= 32;
    funcVal[0] = (ch & 64) != 0 ? NOTIFY_V2_6RAWBYTES : NOTIFY_V2_TYPEDDATA;
    ch &= 63;
    while (len < YOCTO_PUBVAL_SIZE) {
      p_ofs++;
      if (p_ofs >= p.length) {
        break;
      }
      let newCh = p.charCodeAt(p_ofs) & 255;
      if (newCh == NOTIFY_NETPKT_STOP) {
        break;
      }
      if (newCh < 32 || newCh > 32 + 127) {
        return null;
      }
      newCh -= 32;
      ch = (ch << 7) + newCh;
      funcVal[len + 1] = ch >>> 5 - len & 255;
      len++;
    }
    return funcVal;
  }
  imm_decodePubVal(int_typeV2, arr_funcval, int_ofs, int_funcvalen) {
    let buffer = "";
    let endp;
    if (int_typeV2 == NOTIFY_V2_6RAWBYTES || int_typeV2 == NOTIFY_V2_TYPEDDATA) {
      let funcValType;
      if (int_typeV2 == NOTIFY_V2_6RAWBYTES) {
        funcValType = PUBVAL_6RAWBYTES;
      } else {
        funcValType = arr_funcval[int_ofs++];
      }
      switch (funcValType) {
        case PUBVAL_LEGACY:
          break;
        case PUBVAL_1RAWBYTE:
        case PUBVAL_2RAWBYTES:
        case PUBVAL_3RAWBYTES:
        case PUBVAL_4RAWBYTES:
        case PUBVAL_5RAWBYTES:
        case PUBVAL_6RAWBYTES:
          for (let i = 0; i < funcValType; i++) {
            let c = arr_funcval[int_ofs++];
            let b = c >>> 4;
            buffer += b.toString(16);
            b = c & 15;
            buffer += b.toString(16);
          }
          return buffer;
        case PUBVAL_C_LONG:
        case PUBVAL_YOCTO_FLOAT_E3:
          let numVal = arr_funcval[int_ofs++];
          numVal += arr_funcval[int_ofs++] << 8;
          numVal += arr_funcval[int_ofs++] << 16;
          numVal += arr_funcval[int_ofs++] << 24;
          if (funcValType == PUBVAL_C_LONG) {
            return String(Math.round(numVal));
          } else {
            buffer = String(Math.round(numVal * 1e3) / 1e6);
            endp = buffer.length;
            while (endp > 0 && buffer[endp - 1] == "0") {
              --endp;
            }
            if (endp > 0 && buffer[endp - 1] == ".") {
              --endp;
              buffer = buffer.substr(0, endp);
            }
            return buffer;
          }
        case PUBVAL_C_FLOAT:
          let v = arr_funcval[int_ofs++];
          v += arr_funcval[int_ofs++] << 8;
          v += arr_funcval[int_ofs++] << 16;
          v += arr_funcval[int_ofs++] << 24;
          let fraction = (v & (1 << 23) - 1) + (1 << 23) * (v >>> 31 | 1);
          let exp = (v >>> 23 & 255) - 127;
          let floatVal = fraction * Math.pow(2, exp - 23);
          buffer = String(Math.round(floatVal * 1e6) / 1e6);
          endp = buffer.length;
          while (endp > 0 && buffer[endp - 1] == "0") {
            --endp;
          }
          if (endp > 0 && buffer[endp - 1] == ".") {
            --endp;
            buffer = buffer.substr(0, endp);
          }
          return buffer;
        default:
          return "?";
      }
      let len = 0;
      buffer = "";
      while (len < YOCTO_PUBVAL_SIZE && len < int_funcvalen) {
        if (arr_funcval[len] == 0) {
          break;
        }
        buffer += String.fromCharCode(arr_funcval[len]);
        len++;
      }
    }
    return buffer;
  }
  imm_decExp(int_pow) {
    const arr = [
      1e-6,
      1e-5,
      1e-4,
      1e-3,
      0.01,
      0.1,
      1,
      10,
      100,
      1e3,
      1e4,
      1e5,
      1e6,
      1e7,
      1e8,
      1e9
    ];
    return arr[int_pow];
  }
  imm_decimalToDouble(val) {
    let negate = false;
    let res;
    let mantis = val & 2047;
    if (mantis == 0)
      return 0;
    if (val > 32767) {
      negate = true;
      val = 65536 - val;
    } else if (val < 0) {
      negate = true;
      val = -val;
    }
    let decexp = this.imm_decExp(val >>> 11);
    if (decexp >= 1) {
      res = mantis * decexp;
    } else {
      res = mantis / Math.round(1 / decexp);
    }
    return negate ? -res : res;
  }
  imm_doubleToDecimal(val) {
    let negate = false;
    let comp, mant;
    let decpow;
    let res;
    if (val == 0) {
      return 0;
    }
    if (val < 0) {
      negate = true;
      val = -val;
    }
    comp = val / 1999;
    decpow = 0;
    while (comp > this.imm_decExp(decpow) && decpow < 15) {
      decpow++;
    }
    mant = val / this.imm_decExp(decpow);
    if (decpow == 15 && mant > 2047) {
      res = (15 << 11) + 2047;
    } else {
      res = (decpow << 11) + Math.round(mant);
    }
    return negate ? -res : res;
  }
  imm_getCalibrationHandler(calibType) {
    return this._calibHandlers[calibType];
  }
  imm_decodeWords(data) {
    let udata = [];
    for (let i = 0; i < data.length; ) {
      let c = data[i];
      let val = 0;
      if (c == "*") {
        i++;
      } else if (c == "X") {
        val = 65535;
        i++;
      } else if (c == "Y") {
        val = 32767;
        i++;
      } else if (c >= "a") {
        let srcpos = udata.length - 1 - (data.charCodeAt(i++) - 97);
        if (srcpos >= 0) {
          val = udata[srcpos];
        }
      } else {
        if (i + 3 > data.length) {
          return udata;
        }
        val = data.charCodeAt(i++) - 48;
        val += data.charCodeAt(i++) - 48 << 5;
        let lastcode = data.charCodeAt(i++);
        if (lastcode == 122)
          lastcode = 92;
        val += lastcode - 48 << 10;
      }
      udata.push(val);
    }
    return udata;
  }
  imm_decodeFloats(data) {
    let idata = [];
    let p = 0;
    let datalen = data.length;
    while (p < datalen) {
      let val = 0;
      let sign = 1;
      let dec = 0;
      let decInc = 0;
      let c = data[p++];
      while (c != "-" && (c < "0" || c > "9")) {
        if (p >= datalen) {
          return idata;
        }
        c = data[p++];
      }
      if (c == "-") {
        if (p >= datalen) {
          return idata;
        }
        sign = -sign;
        c = data[p++];
      }
      while (c >= "0" && c <= "9" || c == ".") {
        if (c == ".") {
          decInc = 1;
        } else if (dec < 3) {
          val = val * 10 + (c.charCodeAt(0) - 48);
          dec += decInc;
        }
        if (p < datalen) {
          c = data[p++];
        } else {
          c = "\0";
        }
      }
      if (dec < 3) {
        if (dec == 0) {
          val *= 1e3;
        } else if (dec == 1) {
          val *= 100;
        } else {
          val *= 10;
        }
      }
      idata.push(sign * val);
    }
    return idata;
  }
  imm_atoi(str_data) {
    let num = parseInt(str_data);
    if (isNaN(num)) {
      return 0;
    }
    return Math.floor(num);
  }
  imm_bin2str(bin_data) {
    let len = bin_data.length;
    let res = "";
    for (let i = 0; i < len; i += 20) {
      let subdata = bin_data.subarray(i, Math.min(i + 20, len));
      res += String.fromCharCode.apply(null, Array.from(subdata));
    }
    return res;
  }
  imm_str2bin(str_data) {
    let len = str_data.length;
    let res = new Uint8Array(len);
    for (let i = 0; i < len; i++) {
      res[i] = str_data.charCodeAt(i);
    }
    return res;
  }
  imm_bin2hexstr(bin_data) {
    let len = bin_data.length;
    let res = "";
    for (let i = 0; i < len; i++) {
      let n = bin_data[i].toString(16);
      res += n.length < 2 ? "0" + n : n;
    }
    return res.toUpperCase();
  }
  imm_hexstr2bin(str_data) {
    let len = str_data.length >>> 1;
    let res = new Uint8Array(len);
    for (let i = 0; i < len; i++) {
      res[i] = parseInt(str_data.substr(2 * i, 2), 16);
    }
    return res;
  }
  imm_getDevice(str_device) {
    let dev = null;
    let serial;
    if (str_device.substr(0, 7) == "http://" || str_device.substr(0, 5) == "ws://" || str_device.substr(0, 8) == "https://" || str_device.substr(0, 6) == "wss://") {
      serial = this._snByUrl[str_device];
      if (serial != void 0)
        dev = this._devs[serial];
    } else {
      if (this._devs[str_device]) {
        dev = this._devs[str_device];
      } else {
        serial = this._snByName[str_device];
        if (serial) {
          dev = this._devs[serial];
        }
      }
    }
    return dev;
  }
  async _UpdateValueCallbackList(obj_func, bool_add) {
    let index = this._ValueCallbackList.indexOf(obj_func);
    if (bool_add) {
      await obj_func.isOnline();
      if (index < 0) {
        this._ValueCallbackList.push(obj_func);
      }
    } else if (index >= 0) {
      this._ValueCallbackList.splice(index, 1);
    }
  }
  async _UpdateTimedReportCallbackList(obj_func, bool_add) {
    let index = this._TimedReportCallbackList.indexOf(obj_func);
    if (bool_add) {
      await obj_func.isOnline();
      if (index < 0) {
        this._TimedReportCallbackList.push(obj_func);
      }
    } else if (index >= 0) {
      this._TimedReportCallbackList.splice(index, 1);
    }
  }
  imm_functionClass(str_funcid) {
    let dotpos = str_funcid.indexOf(".");
    if (dotpos >= 0)
      str_funcid = str_funcid.substr(dotpos + 1);
    let classlen = str_funcid.length;
    while (str_funcid.substr(classlen - 1, 1) <= "9") {
      classlen--;
    }
    let classname = str_funcid.substr(0, 1).toUpperCase() + str_funcid.substr(1, classlen - 1);
    if (this._fnByType[classname] == void 0) {
      this._fnByType[classname] = new YFunctionType(this, classname);
    }
    return classname;
  }
  imm_reindexDevice(obj_dev) {
    let rootUrl = obj_dev.imm_getRootUrl();
    let serial = obj_dev.imm_getSerialNumber();
    let lname = obj_dev.imm_getLogicalName();
    this._devs[serial] = obj_dev;
    this._snByUrl[rootUrl] = serial;
    if (lname != "")
      this._snByName[lname] = serial;
    this._fnByType["Module"].imm_reindexFunction(serial + ".module", lname, null, null);
    let i, count = obj_dev.imm_functionCount();
    for (i = 0; i < count; i++) {
      let funcid = obj_dev.imm_functionId(i);
      if (funcid != "") {
        let funcname = obj_dev.imm_functionName(i);
        let classname = this.imm_functionClass(funcid);
        this._fnByType[classname].imm_reindexFunction(serial + "." + funcid, funcname, null, null);
      }
    }
  }
  imm_forgetDevice(obj_dev) {
    let rootUrl = obj_dev.imm_getRootUrl();
    let serial = obj_dev.imm_getSerialNumber();
    let lname = obj_dev.imm_getLogicalName();
    delete this._devs[serial];
    delete this._snByUrl[rootUrl];
    if (this._snByName[lname] == serial) {
      delete this._snByName[lname];
    }
    this._fnByType["Module"].imm_forgetFunction(serial + ".module");
    let i, count = obj_dev.imm_functionCount();
    for (i = 0; i < count; i++) {
      let funcid = obj_dev.imm_functionId(i);
      if (funcid != "") {
        let classname = this.imm_functionClass(funcid);
        this._fnByType[classname].imm_forgetFunction(serial + "." + funcid);
      }
    }
  }
  imm_resolveFunction(str_className, str_func) {
    if (Y_BASETYPES[str_className] == void 0) {
      if (this._fnByType[str_className] == void 0) {
        this._fnByType[str_className] = new YFunctionType(this, str_className);
      }
      return this._fnByType[str_className].imm_resolve(str_func);
    }
    let baseType = Y_BASETYPES[str_className];
    let res;
    for (str_className in this._fnByType) {
      if (this._fnByType[str_className].imm_matchBaseType(baseType)) {
        res = this._fnByType[str_className].imm_resolve(str_func);
        if (res.errorType == YAPI_SUCCESS)
          return res;
      }
    }
    return {
      errorType: YAPI_DEVICE_NOT_FOUND,
      errorMsg: "No " + str_className + " [" + str_func + "] found (old firmware?)"
    };
  }
  imm_getFriendlyNameFunction(str_className, str_func) {
    if (Y_BASETYPES[str_className] == void 0) {
      if (this._fnByType[str_className] == void 0) {
        this._fnByType[str_className] = new YFunctionType(this, str_className);
      }
      return this._fnByType[str_className].imm_getFriendlyName(str_func);
    }
    let baseType = Y_BASETYPES[str_className];
    let res;
    for (str_className in this._fnByType) {
      if (this._fnByType[str_className].imm_matchBaseType(baseType)) {
        res = this._fnByType[str_className].imm_getFriendlyName(str_func);
        if (res.errorType == YAPI_SUCCESS)
          return res;
      }
    }
    return {
      errorType: YAPI_DEVICE_NOT_FOUND,
      errorMsg: "No " + str_className + " [" + str_func + "] found (old firmware?)"
    };
  }
  imm_setFunction(str_className, str_func, obj_func) {
    if (this._fnByType[str_className] == void 0) {
      this._fnByType[str_className] = new YFunctionType(this, str_className);
    }
    this._fnByType[str_className].imm_setFunction(str_func, obj_func);
  }
  imm_getFunction(str_className, str_func) {
    if (this._fnByType[str_className] == void 0) {
      this._fnByType[str_className] = new YFunctionType(this, str_className);
    }
    return this._fnByType[str_className].imm_getFunction(str_func);
  }
  async setFunctionValue(str_hwid, str_pubval) {
    let classname = this.imm_functionClass(str_hwid);
    if (this._fnByType[classname].imm_setFunctionValue(str_hwid, str_pubval)) {
      let receivers = this._ValueCallbackList;
      for (let i = 0; i < receivers.length; i++) {
        let fun = receivers[i];
        if (!fun._hwId)
          continue;
        if (fun._hwId == str_hwid) {
          await fun._invokeValueCallback(str_pubval);
        }
      }
    }
  }
  async setTimedReport(str_hwid, float_timestamp, float_duration, arr_report) {
    let classname = this.imm_functionClass(str_hwid);
    let receivers = this._TimedReportCallbackList;
    for (let i = 0; i < receivers.length; i++) {
      let fun = receivers[i];
      if (!fun._hwId)
        continue;
      if (fun._hwId == str_hwid) {
        let dev = this.imm_getDevice(fun._serial);
        if (dev) {
          let sensor = fun;
          let report = await sensor._decodeTimedReport(float_timestamp, float_duration, arr_report);
          await sensor._invokeTimedReportCallback(report);
        }
      }
    }
  }
  async setConfChange(str_serial) {
    let module = YModule.FindModuleInContext(this, str_serial + ".module");
    await module._invokeConfigChangeCallback();
  }
  async setBeaconChange(str_serial, int_beacon) {
    if (this._beacons[str_serial] === void 0 || this._beacons[str_serial] != int_beacon) {
      this._beacons[str_serial] = int_beacon;
      let dev = this.imm_getDevice(str_serial);
      if (dev) {
        dev._beacon = int_beacon;
      }
      let module = YModule.FindModuleInContext(this, str_serial + ".module");
      await module._invokeBeaconCallback(int_beacon);
    }
  }
  imm_getFunctionValue(str_hwid) {
    let classname = this.imm_functionClass(str_hwid);
    return this._fnByType[classname].imm_getFunctionValue(str_hwid);
  }
  imm_getFunctionBaseType(str_hwid) {
    let classname = this.imm_functionClass(str_hwid);
    return this._fnByType[classname].imm_getBaseType();
  }
  imm_getFirstHardwareId(str_className) {
    if (Y_BASETYPES[str_className] == void 0) {
      if (this._fnByType[str_className] == void 0) {
        this._fnByType[str_className] = new YFunctionType(this, str_className);
      }
      return this._fnByType[str_className].imm_getFirstHardwareId();
    }
    let baseType = Y_BASETYPES[str_className];
    let res;
    for (str_className in this._fnByType) {
      if (this._fnByType[str_className].imm_matchBaseType(baseType)) {
        res = this._fnByType[str_className].imm_getFirstHardwareId();
        if (res)
          return res;
      }
    }
    return null;
  }
  imm_getNextHardwareId(str_className, str_hwid) {
    if (Y_BASETYPES[str_className] == void 0) {
      return this._fnByType[str_className].imm_getNextHardwareId(str_hwid);
    }
    let baseType = Y_BASETYPES[str_className];
    let prevclass = this.imm_functionClass(str_hwid);
    let res = this._fnByType[prevclass].imm_getNextHardwareId(str_hwid);
    if (res)
      return res;
    for (str_className in this._fnByType) {
      if (prevclass != "") {
        if (str_className != prevclass)
          continue;
        prevclass = "";
        continue;
      }
      if (this._fnByType[str_className].imm_matchBaseType(baseType)) {
        res = this._fnByType[str_className].imm_getFirstHardwareId();
        if (res)
          return res;
      }
    }
    return null;
  }
  async devRequest(str_device, str_request, obj_body = null, int_tcpchan = 0) {
    let lines = str_request.split("\n");
    let res = new YHTTPRequest(null);
    let lockdev = null;
    let baseUrl;
    if (str_device.substr(0, 7) == "http://" || str_device.substr(0, 5) == "ws://" || str_device.substr(0, 8) == "https://" || str_device.substr(0, 6) == "wss://") {
      baseUrl = str_device;
      if (baseUrl.slice(-1) != "/")
        baseUrl = baseUrl + "/";
      if (lines[0].substr(0, 12) != "GET /not.byn") {
        let serial = this._snByUrl[baseUrl];
        if (serial) {
          lockdev = this._devs[serial];
        }
      }
    } else {
      lockdev = this.imm_getDevice(str_device);
      if (!lockdev) {
        res.errorType = YAPI_DEVICE_NOT_FOUND;
        res.errorMsg = "Device [" + str_device + "] not online";
        return res;
      }
      if (lines[0] == "GET /api.json") {
        return lockdev.requestAPI(this.defaultCacheValidity);
      }
      baseUrl = lockdev.imm_getRootUrl();
    }
    let words = lines[0].split(" ");
    if (words.length < 2) {
      res.errorType = YAPI_INVALID_ARGUMENT;
      res.errorMsg = "Invalid request, not enough words; expected a method name and a URL";
      return res;
    } else if (words.length > 2) {
      res.errorType = YAPI_INVALID_ARGUMENT;
      res.errorMsg = "Invalid request, too many words; make sure the URL is URI-encoded";
      return res;
    }
    let hub = null;
    for (let i = 0; i < this._connectedHubs.length; i++) {
      let hubUrl = this._connectedHubs[i].urlInfo.rootUrl;
      if (baseUrl.slice(0, hubUrl.length) == hubUrl) {
        hub = this._connectedHubs[i];
        break;
      }
    }
    if (!hub && this._knownHubsByUrl[str_device]) {
      hub = this._knownHubsByUrl[str_device];
    }
    if (!hub) {
      res.errorType = YAPI_DEVICE_NOT_FOUND;
      res.errorMsg = "No hub found for URL " + baseUrl;
      return res;
    }
    let method = words[0];
    let devUrl = words[1];
    if (devUrl.substr(0, 1) == "/")
      devUrl = devUrl.substr(1);
    if (baseUrl.substr(0, hub.urlInfo.rootUrl.length) == hub.urlInfo.rootUrl) {
      devUrl = baseUrl.substr(hub.urlInfo.rootUrl.length - 1) + devUrl;
    } else {
      let pos = baseUrl.indexOf("//");
      pos = baseUrl.indexOf("/", pos + 3);
      devUrl = baseUrl.slice(pos) + devUrl;
    }
    if (devUrl.slice(-2) == "&." && !await hub.hasRwAccess()) {
      res.errorType = YAPI_UNAUTHORIZED;
      res.errorMsg = "Access denied: admin credentials required";
      return res;
    }
    let delayedCode = function delayedRequest() {
      return hub.request(method, devUrl, obj_body, int_tcpchan).catch((e) => {
        let res2 = new YHTTPRequest(null);
        res2.errorType = YAPI_IO_ERROR;
        res2.errorMsg = e.message;
        return res2;
      });
    };
    if (lockdev && int_tcpchan == 0) {
      let newPromise = lockdev._pendingQueries.then(delayedCode, delayedCode);
      lockdev._pendingQueries = newPromise;
      res = await newPromise;
    } else {
      res = await delayedCode();
    }
    return res;
  }
  async isReadOnly(str_device) {
    let lockdev = this.imm_getDevice(str_device);
    if (!lockdev) {
      return true;
    }
    let baseUrl = lockdev.imm_getRootUrl();
    let hub = null;
    for (let i = 0; i < this._connectedHubs.length; i++) {
      let hubUrl = this._connectedHubs[i].urlInfo.rootUrl;
      if (baseUrl.slice(0, hubUrl.length) == hubUrl) {
        hub = this._connectedHubs[i];
        break;
      }
    }
    if (!hub || !await hub.hasRwAccess()) {
      return true;
    }
    return false;
  }
  imm_funcDev_internal(str_className, str_func) {
    let res = new YFuncRequest(null);
    let resolve = this.imm_resolveFunction(str_className, str_func);
    if (resolve.errorType != YAPI_SUCCESS) {
      res.errorType = resolve.errorType;
      res.errorMsg = resolve.errorMsg;
    } else {
      str_func = resolve.result;
      let dotpos = str_func.indexOf(".");
      let devid = str_func.substr(0, dotpos);
      let funcid = str_func.substr(dotpos + 1);
      let dev = this.imm_getDevice(devid);
      if (dev == null) {
        res.errorType = YAPI_DEVICE_NOT_FOUND;
        res.errorMsg = "Device [" + devid + "] not found";
      } else {
        res.obj_result = {_expiration: -1, device: dev, deviceid: devid, functionid: funcid, hwid: str_func};
      }
    }
    return res;
  }
  async _funcDev(str_className, str_func) {
    let res = this.imm_funcDev_internal(str_className, str_func);
    if (res.errorType == YAPI_SUCCESS) {
      return res;
    } else if (res.errorType == YAPI_DEVICE_NOT_FOUND && this._connectedHubs.length == 0) {
      res.errorMsg = "Impossible to contact any device because no hub has been registered";
      return res;
    }
    let updRes = await this._updateDeviceList_internal(true, false);
    if (updRes.errorType != YAPI_SUCCESS) {
      res.errorType = updRes.errorType;
      res.errorMsg = updRes.errorMsg;
      return res;
    }
    return this.imm_funcDev_internal(str_className, str_func);
  }
  async funcRequest(str_className, str_func, str_extra, int_msValidity = 0) {
    let funcreq = this.imm_funcDev_internal(str_className, str_func);
    if (funcreq.errorType != YAPI_SUCCESS) {
      funcreq = await this._funcDev(str_className, str_func);
      if (funcreq.errorType != YAPI_SUCCESS) {
        return funcreq;
      }
    }
    let devreq = funcreq.obj_result;
    let loadval = null;
    if (str_extra == "") {
      let yreq = await devreq.device.requestAPI(int_msValidity);
      if (yreq != null) {
        if (yreq.errorType != YAPI_SUCCESS || !yreq.obj_result) {
          let res = new YFuncRequest(null);
          res.errorType = yreq.errorType;
          res.errorMsg = yreq.errorMsg;
          return res;
        }
        loadval = yreq.obj_result[devreq.functionid];
      }
    } else {
      devreq.device.imm_dropCache();
    }
    if (!loadval) {
      if (str_extra == "")
        str_extra = ".json";
      let httpreq = "GET /api/" + devreq.functionid + str_extra;
      let yreq = await this.devRequest(devreq.deviceid, httpreq, null, 0);
      if (yreq.errorType != YAPI_SUCCESS)
        return yreq;
      let replyBuff = yreq.bin_result;
      if (replyBuff.length == 0 && httpreq.indexOf("?") >= 0) {
        funcreq.obj_result = null;
        return funcreq;
      }
      try {
        loadval = JSON.parse(this.imm_bin2str(replyBuff));
      } catch (err) {
      }
    }
    if (!loadval) {
      funcreq.errorType = YAPI_IO_ERROR;
      funcreq.errorMsg = "Request failed, could not parse API value for function " + devreq.hwid;
    } else {
      for (let key in devreq) {
        loadval[key] = devreq[key];
      }
      funcreq.obj_result = loadval;
    }
    return funcreq;
  }
  async HTTPRequest(str_device, str_request) {
    let yreq = await this.devRequest(str_device, str_request, null, 0);
    if (yreq.errorType != YAPI_SUCCESS) {
      return this._throw(yreq.errorType, yreq.errorMsg, null);
    }
    return yreq.bin_result;
  }
  async ForceDeviceRefresh(str_device) {
    let dev = this.imm_getDevice(str_device);
    if (!dev)
      return YAPI_DEVICE_NOT_FOUND;
    let rootUrl = dev.imm_getRootUrl();
    for (let i = 0; i < this._connectedHubs.length; i++) {
      let hub = this._connectedHubs[i];
      let hubUrl = hub.urlInfo.rootUrl;
      if (rootUrl.substr(0, hubUrl.length) === hubUrl) {
        let hubDev = this.imm_getDevice(hubUrl);
        hubDev.imm_dropCache();
        let retcode = await hubDev.refresh();
        if (retcode != YAPI_SUCCESS) {
          return this._throw(retcode, hubDev._lastErrorMsg, retcode);
        }
        let yreq = await hubDev.requestAPI(this.defaultCacheValidity);
        if (yreq.errorType != YAPI_SUCCESS) {
          return yreq.errorType;
        }
        let yellowPages = yreq.obj_result["services"]["yellowPages"];
        dev.imm_updateFromYP(yellowPages);
      }
    }
    dev.imm_dropCache();
    return YAPI_SUCCESS;
  }
  async SetDeviceListValidity_internal(deviceListValidity) {
    this._deviceListValidityMs = deviceListValidity * 1e3;
  }
  async GetDeviceListValidity_internal() {
    return this._deviceListValidityMs / 1e3 >> 0;
  }
  async SetNetworkTimeout_internal(networkMsTimeout) {
    this._networkTimeoutMs = networkMsTimeout;
  }
  async GetNetworkTimeout_internal() {
    return this._networkTimeoutMs;
  }
  async AddUdevRule_internal(force) {
    return "error: Not supported in TypeScript";
  }
  async SetDeviceListValidity(deviceListValidity) {
    return await this.SetDeviceListValidity_internal(deviceListValidity);
  }
  async GetDeviceListValidity() {
    return await this.GetDeviceListValidity_internal();
  }
  async AddUdevRule(force) {
    return await this.AddUdevRule_internal(force);
  }
  async SetNetworkTimeout(networkMsTimeout) {
    return await this.SetNetworkTimeout_internal(networkMsTimeout);
  }
  async GetNetworkTimeout() {
    return await this.GetNetworkTimeout_internal();
  }
  async SetCacheValidity(cacheValidityMs) {
    this.defaultCacheValidity = cacheValidityMs;
  }
  async GetCacheValidity() {
    return this.defaultCacheValidity;
  }
  nextHubInUseInternal(hubref) {
    return this.nextHubInUseInternal_internal(hubref);
  }
  getYHubObj(hubref) {
    let obj;
    obj = this._findYHubFromCache(hubref);
    if (obj == null) {
      obj = new YHub(this, hubref);
      this._addYHubToCache(hubref, obj);
    }
    return obj;
  }
  async GetAPIVersion() {
    return this.imm_GetAPIVersion();
  }
  imm_GetAPIVersion() {
    return "1.10.55319";
  }
  async InitAPI(mode, errmsg) {
    this._detectType = mode;
    if (this.system_env.hasSSDP) {
      if ((mode & this.DETECT_NET) !== 0) {
        await this.TriggerHubDiscovery();
      }
    } else {
    }
    return YAPI_SUCCESS;
  }
  async FreeAPI() {
    for (let serial in this._devs) {
      let lockdev = this._devs[serial];
      let newPromise = lockdev._pendingQueries;
      if (newPromise != null) {
        try {
          await newPromise;
        } catch (e) {
        }
      }
    }
    await this.KillAPI();
  }
  async KillAPI() {
    if (this._ssdpManager) {
      await this._ssdpManager.ySSDPStop();
      this._ssdpManager = null;
    }
    for (let hub of this._connectedHubs) {
      this.imm_dropConnectedHub(hub);
    }
    for (let serial in this._knownHubsBySerial) {
      let hub = this._knownHubsBySerial[serial];
      if (hub._currentState > -5) {
        await hub.detach(YAPI.IO_ERROR, "Connection closed by FreeAPI");
      }
    }
    this.imm_ResetToDefaults();
  }
  async DisableExceptions() {
    this.exceptionsDisabled = true;
  }
  async EnableExceptions() {
    this.exceptionsDisabled = false;
  }
  async LogUnhandledPromiseRejections() {
    this.system_env.hookUnhandledRejection((reason, promise) => {
      this.imm_log("Unhandled Rejection at: Promise ", promise, " reason: ", reason);
    });
  }
  imm_parseRegisteredUrl(str_url) {
    let org_url = str_url;
    let proto = "ws://";
    let user = "";
    let pass = "";
    let port = "4444";
    let host;
    let dom = "";
    let url = "";
    let rooturl = "";
    if (!this._isNodeJS && window && window.navigator && window.navigator.userAgent && /(iPad|iPhone|iPod)/g.test(window.navigator.userAgent)) {
      proto = "http://";
    }
    if (str_url.slice(0, 7) == "http://") {
      proto = "http://";
      str_url = str_url.slice(7);
    } else if (str_url.slice(0, 5) == "ws://") {
      str_url = str_url.slice(5);
    } else if (str_url.slice(0, 8) == "https://") {
      proto = "https://";
      str_url = str_url.slice(8);
    } else if (str_url.slice(0, 6) == "wss://") {
      proto = "wss://";
      str_url = str_url.slice(6);
    }
    str_url = str_url.replace("/not.byn", "");
    let pos = str_url.indexOf("/");
    if (pos > 0) {
      dom = str_url.slice(pos + 1);
      if (dom.length > 0 && dom.slice(-1) != "/") {
        dom += "/";
      }
      str_url = str_url.slice(0, pos);
    }
    url = proto;
    let authpos = str_url.indexOf("@");
    if (authpos >= 0) {
      let auth = str_url.slice(0, authpos);
      let passpos = auth.indexOf(":");
      if (passpos >= 0) {
        user = auth.slice(0, passpos);
        pass = auth.slice(passpos + 1);
        url += user + ":" + pass + "@";
      } else {
        user = auth;
        url += user + "@";
      }
      str_url = str_url.slice(authpos + 1);
    }
    pos = str_url.indexOf(":");
    if (pos < 0) {
      host = str_url;
      if (dom != "") {
        if (proto == "http://") {
          port = "80";
        } else if (proto == "https://") {
          port = "443";
        }
      }
    } else {
      host = str_url.slice(0, pos);
      port = str_url.slice(pos + 1);
    }
    if (host == "callback") {
      if (proto == "ws:") {
        url = "ws://callback:4444/";
      } else {
        url = "http://callback:4444/";
      }
      rooturl = url;
    } else {
      url += host + ":" + port + "/" + dom;
      rooturl = proto + host + ":" + port + "/" + dom;
    }
    return {
      proto,
      user,
      pass,
      host,
      port,
      domain: dom,
      authUrl: url,
      rootUrl: rooturl,
      orgUrl: org_url
    };
  }
  imm_registerHub_internal(urlInfo) {
    let newhub;
    if (urlInfo.proto.slice(0, 3) == "ws:" || urlInfo.proto.slice(0, 4) == "wss:") {
      newhub = this.system_env.getWebSocketHub(this, urlInfo);
    } else {
      newhub = this.system_env.getHttpHub(this, urlInfo);
    }
    if (newhub) {
      this._knownHubsByUrl[urlInfo.rootUrl] = newhub;
    }
    return newhub;
  }
  async RegisterHub(url, errmsg) {
    if (url === "net") {
      if (this.system_env.hasSSDP) {
        this._detectType |= this.DETECT_NET;
        return this.TriggerHubDiscovery();
      } else {
        return this.imm_setErr(errmsg, YAPI_NOT_SUPPORTED, "Network discovery is not possible in a browser", YAPI_NOT_SUPPORTED);
      }
    }
    if (url === "usb") {
      return this.imm_setErr(errmsg, YAPI_NOT_SUPPORTED, "Use the VirtualHub on 127.0.0.1 to access USB devices", YAPI_NOT_SUPPORTED);
    }
    let urlInfo = this.imm_parseRegisteredUrl(url);
    let hub = this.imm_getHub(urlInfo);
    if (!hub) {
      if (this._logLevel >= 3) {
        this.imm_log("Registering new hub: " + urlInfo.rootUrl);
      }
      hub = this.imm_registerHub_internal(urlInfo);
      if (!hub) {
        return this.imm_setErr(errmsg, YAPI_NOT_SUPPORTED, "Unsupported hub protocol: " + urlInfo.proto, YAPI_NOT_SUPPORTED);
      }
    } else {
      if (this._logLevel >= 3) {
        this.imm_log("Registering existing hub: " + urlInfo.rootUrl);
      }
      hub.imm_updateUrl(urlInfo);
    }
    await hub.attach(2);
    let sub_errmsg = new YErrorMsg();
    let retcode = await hub.waitForConnection(this._networkTimeoutMs, sub_errmsg);
    if (retcode != YAPI_SUCCESS) {
      this.imm_dropConnectedHub(hub);
      await hub.detach(retcode, sub_errmsg.msg);
      return this.imm_setErr(errmsg, retcode, sub_errmsg.msg, retcode);
    }
    let yreq = await this._updateDeviceList_internal(true, false);
    if (yreq.errorType != YAPI_SUCCESS) {
      this.imm_dropConnectedHub(hub);
      await hub.detach(yreq.errorType, yreq.errorMsg);
      return this.imm_setErr(errmsg, yreq.errorType, yreq.errorMsg, yreq.errorType);
    }
    return YAPI_SUCCESS;
  }
  async PreregisterHub(url, errmsg) {
    let urlInfo = this.imm_parseRegisteredUrl(url);
    let hub = this.imm_getHub(urlInfo);
    if (!hub) {
      if (this._logLevel >= 3) {
        this.imm_log("Preregistering new hub: " + urlInfo.rootUrl);
      }
      hub = this.imm_registerHub_internal(urlInfo);
      if (!hub) {
        return this.imm_setErr(errmsg, YAPI_NOT_SUPPORTED, "Unsupported hub protocol: " + urlInfo.proto, YAPI_NOT_SUPPORTED);
      }
    } else {
      if (this._logLevel >= 3) {
        this.imm_log("Preregistering existing hub: " + urlInfo.rootUrl);
      }
      hub.imm_updateUrl(urlInfo);
    }
    await hub.attach(1);
    return YAPI_SUCCESS;
  }
  async RegisterHubHttpCallback(incomingMessage, serverResponse, errmsg) {
    let url = "http://callback:4444";
    let urlInfo = this.imm_parseRegisteredUrl(url);
    let hub = this.imm_getHub(urlInfo);
    if (!hub) {
      hub = this.system_env.getHttpCallbackHub(this, urlInfo, incomingMessage, serverResponse);
      if (!hub) {
        return this.imm_setErr(errmsg, YAPI_NOT_SUPPORTED, "HTTP Callback mode is not available in this environment", YAPI_NOT_SUPPORTED);
      }
    }
    await hub.attach(3);
    let sub_errmsg = new YErrorMsg();
    let retcode = await hub.waitForConnection(this._networkTimeoutMs, sub_errmsg);
    if (retcode != YAPI_SUCCESS) {
      this.imm_dropConnectedHub(hub);
      await hub.detach(retcode, sub_errmsg.msg);
      return this.imm_setErr(errmsg, retcode, sub_errmsg.msg, retcode);
    }
    let yreq = await this._updateDeviceList_internal(true, false);
    if (yreq.errorType != YAPI_SUCCESS) {
      hub.reportFailure(yreq.errorMsg);
      return this.imm_setErr(errmsg, yreq.errorType, yreq.errorMsg, yreq.errorType);
    }
    return YAPI_SUCCESS;
  }
  async RegisterHubWebSocketCallback(ws, errmsg, authpwd) {
    let authstr = authpwd ? "ws:" + authpwd + "@" : "";
    let url = "http://" + authstr + "callback:4444";
    let urlInfo = this.imm_parseRegisteredUrl(url);
    let hub = this.imm_getHub(urlInfo);
    if (!hub) {
      hub = this.system_env.getWebSocketCallbackHub(this, urlInfo, ws);
      if (!hub) {
        return this.imm_setErr(errmsg, YAPI_NOT_SUPPORTED, "WebSocket Callback mode is not available in this environment", YAPI_NOT_SUPPORTED);
      }
    }
    await hub.attach(3);
    let sub_errmsg = new YErrorMsg();
    let retcode = await hub.waitForConnection(this._networkTimeoutMs, sub_errmsg);
    if (retcode != YAPI_SUCCESS) {
      this.imm_dropConnectedHub(hub);
      await hub.detach(retcode, sub_errmsg.msg);
      return this.imm_setErr(errmsg, retcode, sub_errmsg.msg, retcode);
    }
    let yreq = await this._updateDeviceList_internal(true, false);
    if (yreq.errorType != YAPI_SUCCESS) {
      this.imm_dropConnectedHub(hub);
      await hub.detach(yreq.errorType, yreq.errorMsg);
      return this.imm_setErr(errmsg, yreq.errorType, yreq.errorMsg, yreq.errorType);
    }
    return YAPI_SUCCESS;
  }
  async WebSocketJoin(ws, arr_credentials, closeCallback) {
    if (this._connectedHubs.length == 0) {
      return false;
    }
    return this._connectedHubs[0].websocketJoin(ws, arr_credentials, closeCallback);
  }
  async UnregisterHub(url) {
    let urlInfo = this.imm_parseRegisteredUrl(url);
    let hub = this.imm_getHub(urlInfo);
    if (hub) {
      if (hub.hubSerial) {
        let activeHub = this._knownHubsBySerial[hub.hubSerial];
        if (activeHub) {
          hub.imm_forgetUrls();
          hub = activeHub;
          urlInfo = hub.urlInfo;
        }
      }
      if (this._logLevel >= 3) {
        this.imm_log("Unregistering hub " + url + " (" + urlInfo.rootUrl + ")");
      }
      this.imm_dropConnectedHub(hub);
      if (hub.imm_isDisconnected()) {
        if (this._logLevel >= 3) {
          this.imm_log("Hub " + urlInfo.rootUrl + " is already disconnected");
        }
        return;
      }
      let before = this.GetTickCount();
      let disconnected = hub.waitForDisconnection(500);
      if (hub.imm_isDisconnecting()) {
        if (this._logLevel >= 3) {
          this.imm_log("Hub " + urlInfo.rootUrl + " is already disconnecting");
        }
      } else {
        await hub.detach(YAPI.IO_ERROR, "Hub has been unregistered");
      }
      await disconnected;
      hub.imm_forgetUrls();
      if (this._logLevel >= 4) {
        this.imm_log("Disconnected after " + (this.GetTickCount() - before) + " ms");
      }
    }
  }
  async TestHub(url, mstimeout, errmsg) {
    let urlInfo = this.imm_parseRegisteredUrl(url);
    let hub = this.imm_getHub(urlInfo);
    if (!hub) {
      if (this._logLevel >= 4) {
        this.imm_log("Testing new hub: " + urlInfo.rootUrl);
      }
      hub = this.imm_registerHub_internal(urlInfo);
      if (!hub) {
        return this.imm_setErr(errmsg, YAPI_NOT_SUPPORTED, "Unsupported hub protocol: " + urlInfo.proto, YAPI_NOT_SUPPORTED);
      }
    } else {
      if (this._logLevel >= 4) {
        this.imm_log("Testing existing hub: " + urlInfo.rootUrl);
      }
    }
    await hub.attach(0);
    let sub_errmsg = new YErrorMsg();
    let retcode = await hub.waitForConnection(mstimeout, sub_errmsg);
    if (retcode != YAPI_SUCCESS) {
      return this.imm_setErr(errmsg, retcode, sub_errmsg.msg, retcode);
    }
    return YAPI_SUCCESS;
  }
  async UpdateDeviceList(errmsg = null) {
    let yreq = await this._updateDeviceList_internal(false, true);
    if (yreq.errorType !== YAPI_SUCCESS) {
      return this.imm_setErr(errmsg, yreq.errorType, yreq.errorMsg, yreq.errorType);
    }
    return YAPI_SUCCESS;
  }
  async _hubDiscoveryCallback_internal(serial, urlToRegister, urlToUnregister) {
    if (this._hubDiscoveryCallback && urlToRegister) {
      try {
        await this._hubDiscoveryCallback(serial, urlToRegister, urlToUnregister);
      } catch (e) {
        this.imm_log("Exception in hub discovery callback:", e);
      }
    }
    if ((this._detectType & Y_DETECT_NET) !== 0) {
      if (urlToRegister) {
        if (urlToUnregister) {
          await this.UnregisterHub(urlToUnregister);
        }
        await this.PreregisterHub(urlToRegister, new YErrorMsg());
      }
    }
  }
  async TriggerHubDiscovery(errmsg = null) {
    if (!this._ssdpManager) {
      this._ssdpManager = this.system_env.getSSDPManager(this);
      if (!this._ssdpManager)
        return this._lastErrorType;
      await this._ssdpManager.ySSDPStart((serial, newUrl, oldUrl) => {
        this._hubDiscoveryCallback_internal(serial, newUrl, oldUrl);
      });
    } else {
      await this._ssdpManager.ySSDPDiscover();
    }
    return YAPI_SUCCESS;
  }
  async HandleEvents(errmsg = null) {
    return YAPI_SUCCESS;
  }
  async Sleep(ms_duration, errmsg = null) {
    let end = this.GetTickCount() + ms_duration;
    let remaining = ms_duration;
    while (remaining > 0) {
      let waitTime = Math.min(remaining, 25);
      await new Promise((resolve, reject) => {
        setTimeout(resolve, waitTime);
      });
      remaining = end - this.GetTickCount();
    }
    return YAPI_SUCCESS;
  }
  _microSleep_internal() {
    return new Promise(function(resolve, reject) {
      setTimeout(resolve, 3);
    });
  }
  SetTimeout(callback, ms_timeout, args) {
    let endtime = this.GetTickCount() + ms_timeout;
    let setTimeout_internal = async () => {
      let delay = endtime - this.GetTickCount();
      if (delay < 40) {
        if (delay > 3) {
          await new Promise((resolve, reject) => {
            setTimeout(resolve, delay);
          });
        }
        callback.apply(null, args);
      } else {
        if (delay >= 150) {
          await this.UpdateDeviceList();
          delay = Math.min(endtime - YAPI.GetTickCount(), 110);
        }
        await this.Sleep(delay - 20);
        setTimeout_internal();
      }
    };
    setTimeout_internal();
    return YAPI_SUCCESS;
  }
  GetTickCount() {
    return Date.now();
  }
  imm_CheckLogicalName(name) {
    if (name == "")
      return true;
    if (!name)
      return false;
    if (name.length > 19)
      return false;
    return /^[A-Za-z0-9_\-]*$/.test(name);
  }
  async CheckLogicalName(name) {
    return this.imm_CheckLogicalName(name);
  }
  async RegisterDeviceArrivalCallback(arrivalCallback) {
    this._arrivalCallback = arrivalCallback;
  }
  async RegisterDeviceChangeCallback(changeCallback) {
    this._namechgCallback = changeCallback;
  }
  async RegisterDeviceRemovalCallback(removalCallback) {
    this._removalCallback = removalCallback;
  }
  async RegisterHubDiscoveryCallback(hubDiscoveryCallback) {
    if (!this.system_env.hasSSDP) {
      return this._throw(YAPI_NOT_SUPPORTED, "Hub discovery is not supported in this environment", YAPI_NOT_SUPPORTED);
    }
    this._hubDiscoveryCallback = hubDiscoveryCallback;
    return this.TriggerHubDiscovery();
  }
  async RegisterCalibrationHandler(calibrationType, calibrationHandler) {
    this._calibHandlers[calibrationType] = calibrationHandler;
  }
  LinearCalibrationHandler(float_rawValue, int_calibType, arr_calibParams, arr_calibRawValues, arr_calibRefValues) {
    let npt;
    let x = arr_calibRawValues[0];
    let adj = arr_calibRefValues[0] - x;
    let i = 0;
    if (int_calibType < YOCTO_CALIB_TYPE_OFS) {
      npt = Math.min(int_calibType % 10, arr_calibRawValues.length, arr_calibRefValues.length);
    } else {
      npt = arr_calibRefValues.length;
    }
    while (float_rawValue > arr_calibRawValues[i] && ++i < npt) {
      let x2 = x;
      let adj2 = adj;
      x = arr_calibRawValues[i];
      adj = arr_calibRefValues[i] - x;
      if (float_rawValue < x && x > x2) {
        adj = adj2 + (adj - adj2) * (float_rawValue - x2) / (x - x2);
      }
    }
    return float_rawValue + adj;
  }
  imm_yMD5(text) {
    let ctx = new Y_MD5Ctx();
    ctx.addData(this.imm_str2bin(text));
    return ctx.calculate();
  }
  imm_initshaw(str_s, int_ofs, int_pad, int_xinit, _shaw) {
    let ii;
    let j = -1;
    let k = 0;
    let n = str_s.length;
    for (ii = 0; ii < 64; ii++) {
      let i = int_ofs + ii;
      let c = 0;
      if (i < n) {
        c = str_s.charCodeAt(i);
      } else if (int_pad != 0) {
        if ((int_pad & 128) != 0) {
          if (i == n)
            c = int_pad;
        } else {
          if (i == n + 3) {
            c = int_pad;
          } else if (i == n + 4)
            c = 128;
        }
      }
      if (k == 0) {
        j++;
        _shaw[j] = 0;
        k = 32;
      }
      k -= 8;
      _shaw[j] |= c << k;
    }
    if (int_pad != 0) {
      if (int_pad == 128) {
        if (n <= int_ofs + 55) {
          _shaw[15] = 8 * n;
        }
      } else {
        _shaw[15] = 8 * (64 + n + 4);
      }
    }
    if (int_xinit != 0) {
      let xdw = int_xinit << 16 | int_xinit;
      for (j = 0; j < 16; j++) {
        _shaw[j] ^= xdw;
      }
    }
  }
  imm_itershaw(s, _shaw) {
    let a, b, c, d, e, t, k;
    a = s[0];
    b = s[1];
    c = s[2];
    d = s[3];
    e = s[4];
    for (k = 16; k < 80; k++) {
      t = _shaw[k - 3] ^ _shaw[k - 8] ^ _shaw[k - 14] ^ _shaw[k - 16];
      _shaw[k] = t << 1 | t >>> 31;
    }
    for (k = 0; k < 20; k++) {
      t = (a << 5 | a >>> 27) + e + _shaw[k] + 1518500249 + (b & c | ~b & d);
      e = d;
      d = c;
      c = b << 30 | b >>> 2;
      b = a;
      a = t & 4294967295;
    }
    for (k = 20; k < 40; k++) {
      t = (a << 5 | a >>> 27) + e + _shaw[k] + 1859775393 + (b ^ c ^ d);
      e = d;
      d = c;
      c = b << 30 | b >>> 2;
      b = a;
      a = t & 4294967295;
    }
    for (k = 40; k < 60; k++) {
      t = (a << 5 | a >>> 27) + e + _shaw[k] + 2400959708 + (b & c | b & d | c & d);
      e = d;
      d = c;
      c = b << 30 | b >>> 2;
      b = a;
      a = t & 4294967295;
    }
    for (k = 60; k < 80; k++) {
      t = (a << 5 | a >>> 27) + e + _shaw[k] + 3395469782 + (b ^ c ^ d);
      e = d;
      d = c;
      c = b << 30 | b >>> 2;
      b = a;
      a = t & 4294967295;
    }
    _shaw[0] = s[0] + a & 4294967295;
    _shaw[1] = s[1] + b & 4294967295;
    _shaw[2] = s[2] + c & 4294967295;
    _shaw[3] = s[3] + d & 4294967295;
    _shaw[4] = s[4] + e & 4294967295;
  }
  imm_ySHA1(text) {
    let shau = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
    let i, ofs = 0;
    let n = text.length;
    let _shaw = new Uint32Array(80);
    do {
      this.imm_initshaw(text, ofs, 128, 0, _shaw);
      this.imm_itershaw(shau, _shaw);
      for (i = 0; i < 5; i++) {
        shau[i] = _shaw[i];
      }
      ofs += 64;
    } while (n > ofs - 9);
    let res = new Uint8Array(20);
    for (i = 0; i < 20; i++) {
      res[i] = shau[i >>> 2] >>> 24 - 8 * (i & 3) & 255;
    }
    return res;
  }
  async ComputePSK(ssid, pass) {
    let sha1_init = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
    let inner = [], outer = [], shau = [], res = [];
    let iter, pos, k, _shaw;
    _shaw = new Uint32Array(80);
    this.imm_initshaw(pass, 0, 0, 13878, _shaw);
    this.imm_itershaw(sha1_init, _shaw);
    for (k = 0; k < 5; k++) {
      inner[k] = _shaw[k];
    }
    _shaw = new Uint32Array(80);
    this.imm_initshaw(pass, 0, 0, 23644, _shaw);
    this.imm_itershaw(sha1_init, _shaw);
    for (k = 0; k < 5; k++) {
      outer[k] = _shaw[k];
    }
    pos = 0;
    for (k = 0; k < 5; k++) {
      shau[k] = 0;
    }
    _shaw = new Uint32Array(80);
    this.imm_initshaw(ssid, 0, 1, 0, _shaw);
    for (iter = 0; iter < 8192; ) {
      this.imm_itershaw(inner, _shaw);
      _shaw[5] = 2147483648;
      for (k = 6; k < 15; k++) {
        _shaw[k] = 0;
      }
      _shaw[15] = 8 * (64 + 20);
      this.imm_itershaw(outer, _shaw);
      shau[0] ^= _shaw[0];
      shau[1] ^= _shaw[1];
      shau[2] ^= _shaw[2];
      shau[3] ^= _shaw[3];
      shau[4] ^= _shaw[4];
      iter++;
      if ((iter & 4095) == 0) {
        for (k = 0; k < 5 && pos < 32; k++) {
          res[pos++] = shau[k] >>> 24 & 255;
          res[pos++] = shau[k] >>> 16 & 255;
          res[pos++] = shau[k] >>> 8 & 255;
          res[pos++] = shau[k] & 255;
        }
        if (iter == 4096) {
          for (k = 0; k < 5; k++) {
            shau[k] = 0;
          }
          _shaw = new Uint32Array(80);
          this.imm_initshaw(ssid, 0, 2, 0, _shaw);
        }
      }
    }
    let hex = "";
    for (k = 0; k < 32; k++) {
      hex += ("0" + Number(res[k]).toString(16)).slice(-2);
    }
    return hex;
  }
  nextHubInUseInternal_internal(hubref) {
    let nextref = hubref < 0 ? 0 : hubref + 1;
    for (let url in this._knownHubsByUrl) {
      let hub = this._knownHubsByUrl[url];
      if (hub.getHubRef() == nextref) {
        if (hub.imm_isPreOrRegistered()) {
          return this.getYHubObj(nextref);
        } else {
          nextref++;
        }
      }
    }
    return null;
  }
  getGenHub(hubref) {
    for (let url in this._knownHubsByUrl) {
      let hub = this._knownHubsByUrl[url];
      if (hub.getHubRef() == hubref && hub.imm_isPreOrRegistered()) {
        return hub;
      }
    }
    return null;
  }
  _findYHubFromCache(hubref) {
    return this._yhub_cache[hubref];
  }
  _addYHubToCache(hubref, obj) {
    this._yhub_cache[hubref] = obj;
  }
};
YAPIContext.SUCCESS = 0;
YAPIContext.NOT_INITIALIZED = -1;
YAPIContext.INVALID_ARGUMENT = -2;
YAPIContext.NOT_SUPPORTED = -3;
YAPIContext.DEVICE_NOT_FOUND = -4;
YAPIContext.VERSION_MISMATCH = -5;
YAPIContext.DEVICE_BUSY = -6;
YAPIContext.TIMEOUT = -7;
YAPIContext.IO_ERROR = -8;
YAPIContext.NO_MORE_DATA = -9;
YAPIContext.EXHAUSTED = -10;
YAPIContext.DOUBLE_ACCES = -11;
YAPIContext.UNAUTHORIZED = -12;
YAPIContext.RTC_NOT_READY = -13;
YAPIContext.FILE_NOT_FOUND = -14;
YAPIContext.SSL_ERROR = -15;
var YAPI = new YAPIContext();

// obj/full/Api/yocto_api_html.js
var YSystemEnvHtml = class extends YSystemEnv {
  constructor() {
    super(...arguments);
    this.isNodeJS = false;
    this.hasSSDP = false;
  }
  hookUnhandledRejection(handler) {
    window.addEventListener("onunhandledrejection", (event) => {
      let promiseRejectionEvent = event;
      handler(promiseRejectionEvent.reason, promiseRejectionEvent.promise);
    });
  }
  getWebSocketHub(obj_yapi, urlInfo) {
    return new YWebSocketHtmlHub(obj_yapi, urlInfo);
  }
  getHttpHub(obj_yapi, urlInfo) {
    return new YHttpHtmlHub(obj_yapi, urlInfo);
  }
  getWebSocketCallbackHub(obj_yapi, urlInfo, ws) {
    return obj_yapi._throw(YAPI.NOT_SUPPORTED, "WebSocket Callback mode is not available in this environment", null);
  }
  getHttpCallbackHub(obj_yapi, urlInfo, incomingMessage, serverResponse) {
    return obj_yapi._throw(YAPI.NOT_SUPPORTED, "HTTP Callback mode is not available in this environment", null);
  }
  getSSDPManager(obj_yapi) {
    return obj_yapi._throw(YAPI.NOT_SUPPORTED, "Hub discovery is not available in this environment", null);
  }
  loadfile(file) {
    return new Promise((resolve, reject) => {
      let reader = new FileReader();
      reader.onerror = function(evt) {
        reject(evt.target.error);
      };
      reader.onload = function(evt) {
        resolve(new Uint8Array(evt.target.result));
      };
      reader.readAsArrayBuffer(file);
    });
  }
  downloadfile(url) {
    return new Promise((resolve, reject) => {
      let httpRequest = new XMLHttpRequest();
      httpRequest.open("GET", url, true);
      httpRequest.overrideMimeType("text/plain; charset=x-user-defined");
      httpRequest.onreadystatechange = () => {
        if (httpRequest.readyState == 4) {
          if (httpRequest.status != 200 && httpRequest.status != 304) {
            if (httpRequest.status) {
              reject(new Error("HTTP error " + httpRequest.status));
            } else {
              reject(new Error("Unable to complete HTTP request, network down?"));
            }
          } else {
            resolve(YAPI.imm_str2bin(httpRequest.responseText));
          }
        }
      };
      httpRequest.send("");
    });
  }
};
var _HtmlSystemEnv = new YSystemEnvHtml();
YAPI.imm_setSystemEnv(_HtmlSystemEnv);
var YHttpHtmlHub = class extends YHttpHub {
  constructor(yapi, urlInfo) {
    super(yapi, urlInfo);
  }
  imm_makeRequest(method, relUrl, contentType, body, onProgress, onSuccess, onError) {
    let xhr = new XMLHttpRequest();
    let currPos = 0;
    xhr.open(method, this.urlInfo.authUrl + relUrl, true, "", "");
    xhr.setRequestHeader("Content-Type", contentType);
    xhr.overrideMimeType("text/plain; charset=x-user-defined");
    xhr.onreadystatechange = () => {
      if (xhr.readyState >= 3) {
        let httpStatus = xhr.status >> 0;
        if (xhr.readyState == 4 && httpStatus != 200 && httpStatus != 304) {
          if (httpStatus == 401 || httpStatus == 204) {
            this.infoJson.stamp = 0;
            onError(YAPI.UNAUTHORIZED, "Unauthorized access (" + xhr.status + ")");
          } else if (httpStatus == 404) {
            onError(YAPI.FILE_NOT_FOUND, "HTTP request return status 404 (not found)");
          } else if (this.imm_isDisconnecting()) {
            onError(YAPI.IO_ERROR, "Hub is disconnecting");
          } else {
            onError(YAPI.IO_ERROR, "HTTP request failed with status " + xhr.status);
          }
          return;
        }
        if (this.imm_isDisconnecting()) {
          if (this._yapi._logLevel >= 4) {
            this._yapi.imm_log("Dropping request " + relUrl + " because hub is disconnecting");
          }
          return;
        }
        if (onProgress && xhr.responseText) {
          let newlen = xhr.responseText.length;
          if (newlen > currPos) {
            onProgress(xhr.responseText.slice(currPos, newlen));
            currPos = newlen;
          }
        }
        if (onSuccess && xhr.readyState == 4) {
          onSuccess(xhr.responseText);
        }
      }
    };
    xhr.onerror = () => {
      onError(YAPI.IO_ERROR, "HTTP request failed without status");
    };
    xhr.send(body);
    return xhr;
  }
  imm_abortRequest(clientRequest) {
    clientRequest.abort();
  }
};
var YWebSocketHtmlHub = class extends YWebSocketHub {
  imm_webSocketOpen(str_url) {
    let websock = new WebSocket(str_url);
    websock.binaryType = "arraybuffer";
    this.websocket = websock;
  }
  imm_getRandomValues(arr) {
    return window.crypto.getRandomValues(arr);
  }
};

// obj/full/Api/yocto_network.js
var YNetwork = class extends YFunction {
  constructor(yapi, func) {
    super(yapi, func);
    this._readiness = YNetwork.READINESS_INVALID;
    this._macAddress = YNetwork.MACADDRESS_INVALID;
    this._ipAddress = YNetwork.IPADDRESS_INVALID;
    this._subnetMask = YNetwork.SUBNETMASK_INVALID;
    this._router = YNetwork.ROUTER_INVALID;
    this._currentDNS = YNetwork.CURRENTDNS_INVALID;
    this._ipConfig = YNetwork.IPCONFIG_INVALID;
    this._primaryDNS = YNetwork.PRIMARYDNS_INVALID;
    this._secondaryDNS = YNetwork.SECONDARYDNS_INVALID;
    this._ntpServer = YNetwork.NTPSERVER_INVALID;
    this._userPassword = YNetwork.USERPASSWORD_INVALID;
    this._adminPassword = YNetwork.ADMINPASSWORD_INVALID;
    this._httpPort = YNetwork.HTTPPORT_INVALID;
    this._defaultPage = YNetwork.DEFAULTPAGE_INVALID;
    this._discoverable = YNetwork.DISCOVERABLE_INVALID;
    this._wwwWatchdogDelay = YNetwork.WWWWATCHDOGDELAY_INVALID;
    this._callbackUrl = YNetwork.CALLBACKURL_INVALID;
    this._callbackMethod = YNetwork.CALLBACKMETHOD_INVALID;
    this._callbackEncoding = YNetwork.CALLBACKENCODING_INVALID;
    this._callbackTemplate = YNetwork.CALLBACKTEMPLATE_INVALID;
    this._callbackCredentials = YNetwork.CALLBACKCREDENTIALS_INVALID;
    this._callbackInitialDelay = YNetwork.CALLBACKINITIALDELAY_INVALID;
    this._callbackSchedule = YNetwork.CALLBACKSCHEDULE_INVALID;
    this._callbackMinDelay = YNetwork.CALLBACKMINDELAY_INVALID;
    this._callbackMaxDelay = YNetwork.CALLBACKMAXDELAY_INVALID;
    this._poeCurrent = YNetwork.POECURRENT_INVALID;
    this._valueCallbackNetwork = null;
    this.READINESS_DOWN = 0;
    this.READINESS_EXISTS = 1;
    this.READINESS_LINKED = 2;
    this.READINESS_LAN_OK = 3;
    this.READINESS_WWW_OK = 4;
    this.READINESS_INVALID = -1;
    this.MACADDRESS_INVALID = YAPI.INVALID_STRING;
    this.IPADDRESS_INVALID = YAPI.INVALID_STRING;
    this.SUBNETMASK_INVALID = YAPI.INVALID_STRING;
    this.ROUTER_INVALID = YAPI.INVALID_STRING;
    this.CURRENTDNS_INVALID = YAPI.INVALID_STRING;
    this.IPCONFIG_INVALID = YAPI.INVALID_STRING;
    this.PRIMARYDNS_INVALID = YAPI.INVALID_STRING;
    this.SECONDARYDNS_INVALID = YAPI.INVALID_STRING;
    this.NTPSERVER_INVALID = YAPI.INVALID_STRING;
    this.USERPASSWORD_INVALID = YAPI.INVALID_STRING;
    this.ADMINPASSWORD_INVALID = YAPI.INVALID_STRING;
    this.HTTPPORT_INVALID = YAPI.INVALID_UINT;
    this.DEFAULTPAGE_INVALID = YAPI.INVALID_STRING;
    this.DISCOVERABLE_FALSE = 0;
    this.DISCOVERABLE_TRUE = 1;
    this.DISCOVERABLE_INVALID = -1;
    this.WWWWATCHDOGDELAY_INVALID = YAPI.INVALID_UINT;
    this.CALLBACKURL_INVALID = YAPI.INVALID_STRING;
    this.CALLBACKMETHOD_POST = 0;
    this.CALLBACKMETHOD_GET = 1;
    this.CALLBACKMETHOD_PUT = 2;
    this.CALLBACKMETHOD_INVALID = -1;
    this.CALLBACKENCODING_FORM = 0;
    this.CALLBACKENCODING_JSON = 1;
    this.CALLBACKENCODING_JSON_ARRAY = 2;
    this.CALLBACKENCODING_CSV = 3;
    this.CALLBACKENCODING_YOCTO_API = 4;
    this.CALLBACKENCODING_JSON_NUM = 5;
    this.CALLBACKENCODING_EMONCMS = 6;
    this.CALLBACKENCODING_AZURE = 7;
    this.CALLBACKENCODING_INFLUXDB = 8;
    this.CALLBACKENCODING_MQTT = 9;
    this.CALLBACKENCODING_YOCTO_API_JZON = 10;
    this.CALLBACKENCODING_PRTG = 11;
    this.CALLBACKENCODING_INFLUXDB_V2 = 12;
    this.CALLBACKENCODING_INVALID = -1;
    this.CALLBACKTEMPLATE_OFF = 0;
    this.CALLBACKTEMPLATE_ON = 1;
    this.CALLBACKTEMPLATE_INVALID = -1;
    this.CALLBACKCREDENTIALS_INVALID = YAPI.INVALID_STRING;
    this.CALLBACKINITIALDELAY_INVALID = YAPI.INVALID_UINT;
    this.CALLBACKSCHEDULE_INVALID = YAPI.INVALID_STRING;
    this.CALLBACKMINDELAY_INVALID = YAPI.INVALID_UINT;
    this.CALLBACKMAXDELAY_INVALID = YAPI.INVALID_UINT;
    this.POECURRENT_INVALID = YAPI.INVALID_UINT;
    this._className = "Network";
  }
  imm_parseAttr(name, val) {
    switch (name) {
      case "readiness":
        this._readiness = val;
        return 1;
      case "macAddress":
        this._macAddress = val;
        return 1;
      case "ipAddress":
        this._ipAddress = val;
        return 1;
      case "subnetMask":
        this._subnetMask = val;
        return 1;
      case "router":
        this._router = val;
        return 1;
      case "currentDNS":
        this._currentDNS = val;
        return 1;
      case "ipConfig":
        this._ipConfig = val;
        return 1;
      case "primaryDNS":
        this._primaryDNS = val;
        return 1;
      case "secondaryDNS":
        this._secondaryDNS = val;
        return 1;
      case "ntpServer":
        this._ntpServer = val;
        return 1;
      case "userPassword":
        this._userPassword = val;
        return 1;
      case "adminPassword":
        this._adminPassword = val;
        return 1;
      case "httpPort":
        this._httpPort = val;
        return 1;
      case "defaultPage":
        this._defaultPage = val;
        return 1;
      case "discoverable":
        this._discoverable = val;
        return 1;
      case "wwwWatchdogDelay":
        this._wwwWatchdogDelay = val;
        return 1;
      case "callbackUrl":
        this._callbackUrl = val;
        return 1;
      case "callbackMethod":
        this._callbackMethod = val;
        return 1;
      case "callbackEncoding":
        this._callbackEncoding = val;
        return 1;
      case "callbackTemplate":
        this._callbackTemplate = val;
        return 1;
      case "callbackCredentials":
        this._callbackCredentials = val;
        return 1;
      case "callbackInitialDelay":
        this._callbackInitialDelay = val;
        return 1;
      case "callbackSchedule":
        this._callbackSchedule = val;
        return 1;
      case "callbackMinDelay":
        this._callbackMinDelay = val;
        return 1;
      case "callbackMaxDelay":
        this._callbackMaxDelay = val;
        return 1;
      case "poeCurrent":
        this._poeCurrent = val;
        return 1;
    }
    return super.imm_parseAttr(name, val);
  }
  async get_readiness() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.READINESS_INVALID;
      }
    }
    res = this._readiness;
    return res;
  }
  async get_macAddress() {
    let res;
    if (this._cacheExpiration == 0) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.MACADDRESS_INVALID;
      }
    }
    res = this._macAddress;
    return res;
  }
  async get_ipAddress() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.IPADDRESS_INVALID;
      }
    }
    res = this._ipAddress;
    return res;
  }
  async get_subnetMask() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.SUBNETMASK_INVALID;
      }
    }
    res = this._subnetMask;
    return res;
  }
  async get_router() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.ROUTER_INVALID;
      }
    }
    res = this._router;
    return res;
  }
  async get_currentDNS() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.CURRENTDNS_INVALID;
      }
    }
    res = this._currentDNS;
    return res;
  }
  async get_ipConfig() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.IPCONFIG_INVALID;
      }
    }
    res = this._ipConfig;
    return res;
  }
  async set_ipConfig(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("ipConfig", rest_val);
  }
  async get_primaryDNS() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.PRIMARYDNS_INVALID;
      }
    }
    res = this._primaryDNS;
    return res;
  }
  async set_primaryDNS(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("primaryDNS", rest_val);
  }
  async get_secondaryDNS() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.SECONDARYDNS_INVALID;
      }
    }
    res = this._secondaryDNS;
    return res;
  }
  async set_secondaryDNS(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("secondaryDNS", rest_val);
  }
  async get_ntpServer() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.NTPSERVER_INVALID;
      }
    }
    res = this._ntpServer;
    return res;
  }
  async set_ntpServer(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("ntpServer", rest_val);
  }
  async get_userPassword() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.USERPASSWORD_INVALID;
      }
    }
    res = this._userPassword;
    return res;
  }
  async set_userPassword(newval) {
    let rest_val;
    if (newval.length > YAPI.HASH_BUF_SIZE) {
      return this._throw(YAPI.INVALID_ARGUMENT, "Password too long :" + newval, YAPI.INVALID_ARGUMENT);
    }
    rest_val = String(newval);
    return await this._setAttr("userPassword", rest_val);
  }
  async get_adminPassword() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.ADMINPASSWORD_INVALID;
      }
    }
    res = this._adminPassword;
    return res;
  }
  async set_adminPassword(newval) {
    let rest_val;
    if (newval.length > YAPI.HASH_BUF_SIZE) {
      return this._throw(YAPI.INVALID_ARGUMENT, "Password too long :" + newval, YAPI.INVALID_ARGUMENT);
    }
    rest_val = String(newval);
    return await this._setAttr("adminPassword", rest_val);
  }
  async get_httpPort() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.HTTPPORT_INVALID;
      }
    }
    res = this._httpPort;
    return res;
  }
  async set_httpPort(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("httpPort", rest_val);
  }
  async get_defaultPage() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.DEFAULTPAGE_INVALID;
      }
    }
    res = this._defaultPage;
    return res;
  }
  async set_defaultPage(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("defaultPage", rest_val);
  }
  async get_discoverable() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.DISCOVERABLE_INVALID;
      }
    }
    res = this._discoverable;
    return res;
  }
  async set_discoverable(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("discoverable", rest_val);
  }
  async get_wwwWatchdogDelay() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.WWWWATCHDOGDELAY_INVALID;
      }
    }
    res = this._wwwWatchdogDelay;
    return res;
  }
  async set_wwwWatchdogDelay(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("wwwWatchdogDelay", rest_val);
  }
  async get_callbackUrl() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.CALLBACKURL_INVALID;
      }
    }
    res = this._callbackUrl;
    return res;
  }
  async set_callbackUrl(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("callbackUrl", rest_val);
  }
  async get_callbackMethod() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.CALLBACKMETHOD_INVALID;
      }
    }
    res = this._callbackMethod;
    return res;
  }
  async set_callbackMethod(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("callbackMethod", rest_val);
  }
  async get_callbackEncoding() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.CALLBACKENCODING_INVALID;
      }
    }
    res = this._callbackEncoding;
    return res;
  }
  async set_callbackEncoding(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("callbackEncoding", rest_val);
  }
  async get_callbackTemplate() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.CALLBACKTEMPLATE_INVALID;
      }
    }
    res = this._callbackTemplate;
    return res;
  }
  async set_callbackTemplate(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("callbackTemplate", rest_val);
  }
  async get_callbackCredentials() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.CALLBACKCREDENTIALS_INVALID;
      }
    }
    res = this._callbackCredentials;
    return res;
  }
  async set_callbackCredentials(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("callbackCredentials", rest_val);
  }
  async callbackLogin(username, password) {
    let rest_val;
    rest_val = username + ":" + password;
    return await this._setAttr("callbackCredentials", rest_val);
  }
  async get_callbackInitialDelay() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.CALLBACKINITIALDELAY_INVALID;
      }
    }
    res = this._callbackInitialDelay;
    return res;
  }
  async set_callbackInitialDelay(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("callbackInitialDelay", rest_val);
  }
  async get_callbackSchedule() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.CALLBACKSCHEDULE_INVALID;
      }
    }
    res = this._callbackSchedule;
    return res;
  }
  async set_callbackSchedule(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("callbackSchedule", rest_val);
  }
  async get_callbackMinDelay() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.CALLBACKMINDELAY_INVALID;
      }
    }
    res = this._callbackMinDelay;
    return res;
  }
  async set_callbackMinDelay(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("callbackMinDelay", rest_val);
  }
  async get_callbackMaxDelay() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.CALLBACKMAXDELAY_INVALID;
      }
    }
    res = this._callbackMaxDelay;
    return res;
  }
  async set_callbackMaxDelay(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("callbackMaxDelay", rest_val);
  }
  async get_poeCurrent() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.POECURRENT_INVALID;
      }
    }
    res = this._poeCurrent;
    return res;
  }
  static FindNetwork(func) {
    let obj;
    obj = YFunction._FindFromCache("Network", func);
    if (obj == null) {
      obj = new YNetwork(YAPI, func);
      YFunction._AddToCache("Network", func, obj);
    }
    return obj;
  }
  static FindNetworkInContext(yctx, func) {
    let obj;
    obj = YFunction._FindFromCacheInContext(yctx, "Network", func);
    if (obj == null) {
      obj = new YNetwork(yctx, func);
      YFunction._AddToCache("Network", func, obj);
    }
    return obj;
  }
  async registerValueCallback(callback) {
    let val;
    if (callback != null) {
      await YFunction._UpdateValueCallbackList(this, true);
    } else {
      await YFunction._UpdateValueCallbackList(this, false);
    }
    this._valueCallbackNetwork = callback;
    if (callback != null && await this.isOnline()) {
      val = this._advertisedValue;
      if (!(val == "")) {
        await this._invokeValueCallback(val);
      }
    }
    return 0;
  }
  async _invokeValueCallback(value) {
    if (this._valueCallbackNetwork != null) {
      try {
        await this._valueCallbackNetwork(this, value);
      } catch (e) {
        this._yapi.imm_log("Exception in valueCallback:", e);
      }
    } else {
      super._invokeValueCallback(value);
    }
    return 0;
  }
  async useDHCP(fallbackIpAddr, fallbackSubnetMaskLen, fallbackRouter) {
    return await this.set_ipConfig("DHCP:" + fallbackIpAddr + "/" + String(Math.round(fallbackSubnetMaskLen)) + "/" + fallbackRouter);
  }
  async useDHCPauto() {
    return await this.set_ipConfig("DHCP:");
  }
  async useStaticIP(ipAddress, subnetMaskLen, router) {
    return await this.set_ipConfig("STATIC:" + ipAddress + "/" + String(Math.round(subnetMaskLen)) + "/" + router);
  }
  async ping(host) {
    let content;
    content = await this._download("ping.txt?host=" + host);
    return this._yapi.imm_bin2str(content);
  }
  async triggerCallback() {
    return await this.set_callbackMethod(await this.get_callbackMethod());
  }
  async set_periodicCallbackSchedule(interval, offset) {
    return await this.set_callbackSchedule("every " + interval + "+" + String(Math.round(offset)));
  }
  nextNetwork() {
    let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
    if (resolve.errorType != YAPI.SUCCESS)
      return null;
    let next_hwid = this._yapi.imm_getNextHardwareId(this._className, resolve.result);
    if (next_hwid == null)
      return null;
    return YNetwork.FindNetworkInContext(this._yapi, next_hwid);
  }
  static FirstNetwork() {
    let next_hwid = YAPI.imm_getFirstHardwareId("Network");
    if (next_hwid == null)
      return null;
    return YNetwork.FindNetwork(next_hwid);
  }
  static FirstNetworkInContext(yctx) {
    let next_hwid = yctx.imm_getFirstHardwareId("Network");
    if (next_hwid == null)
      return null;
    return YNetwork.FindNetworkInContext(yctx, next_hwid);
  }
};
YNetwork.READINESS_DOWN = 0;
YNetwork.READINESS_EXISTS = 1;
YNetwork.READINESS_LINKED = 2;
YNetwork.READINESS_LAN_OK = 3;
YNetwork.READINESS_WWW_OK = 4;
YNetwork.READINESS_INVALID = -1;
YNetwork.MACADDRESS_INVALID = YAPI.INVALID_STRING;
YNetwork.IPADDRESS_INVALID = YAPI.INVALID_STRING;
YNetwork.SUBNETMASK_INVALID = YAPI.INVALID_STRING;
YNetwork.ROUTER_INVALID = YAPI.INVALID_STRING;
YNetwork.CURRENTDNS_INVALID = YAPI.INVALID_STRING;
YNetwork.IPCONFIG_INVALID = YAPI.INVALID_STRING;
YNetwork.PRIMARYDNS_INVALID = YAPI.INVALID_STRING;
YNetwork.SECONDARYDNS_INVALID = YAPI.INVALID_STRING;
YNetwork.NTPSERVER_INVALID = YAPI.INVALID_STRING;
YNetwork.USERPASSWORD_INVALID = YAPI.INVALID_STRING;
YNetwork.ADMINPASSWORD_INVALID = YAPI.INVALID_STRING;
YNetwork.HTTPPORT_INVALID = YAPI.INVALID_UINT;
YNetwork.DEFAULTPAGE_INVALID = YAPI.INVALID_STRING;
YNetwork.DISCOVERABLE_FALSE = 0;
YNetwork.DISCOVERABLE_TRUE = 1;
YNetwork.DISCOVERABLE_INVALID = -1;
YNetwork.WWWWATCHDOGDELAY_INVALID = YAPI.INVALID_UINT;
YNetwork.CALLBACKURL_INVALID = YAPI.INVALID_STRING;
YNetwork.CALLBACKMETHOD_POST = 0;
YNetwork.CALLBACKMETHOD_GET = 1;
YNetwork.CALLBACKMETHOD_PUT = 2;
YNetwork.CALLBACKMETHOD_INVALID = -1;
YNetwork.CALLBACKENCODING_FORM = 0;
YNetwork.CALLBACKENCODING_JSON = 1;
YNetwork.CALLBACKENCODING_JSON_ARRAY = 2;
YNetwork.CALLBACKENCODING_CSV = 3;
YNetwork.CALLBACKENCODING_YOCTO_API = 4;
YNetwork.CALLBACKENCODING_JSON_NUM = 5;
YNetwork.CALLBACKENCODING_EMONCMS = 6;
YNetwork.CALLBACKENCODING_AZURE = 7;
YNetwork.CALLBACKENCODING_INFLUXDB = 8;
YNetwork.CALLBACKENCODING_MQTT = 9;
YNetwork.CALLBACKENCODING_YOCTO_API_JZON = 10;
YNetwork.CALLBACKENCODING_PRTG = 11;
YNetwork.CALLBACKENCODING_INFLUXDB_V2 = 12;
YNetwork.CALLBACKENCODING_INVALID = -1;
YNetwork.CALLBACKTEMPLATE_OFF = 0;
YNetwork.CALLBACKTEMPLATE_ON = 1;
YNetwork.CALLBACKTEMPLATE_INVALID = -1;
YNetwork.CALLBACKCREDENTIALS_INVALID = YAPI.INVALID_STRING;
YNetwork.CALLBACKINITIALDELAY_INVALID = YAPI.INVALID_UINT;
YNetwork.CALLBACKSCHEDULE_INVALID = YAPI.INVALID_STRING;
YNetwork.CALLBACKMINDELAY_INVALID = YAPI.INVALID_UINT;
YNetwork.CALLBACKMAXDELAY_INVALID = YAPI.INVALID_UINT;
YNetwork.POECURRENT_INVALID = YAPI.INVALID_UINT;

// obj/full/Api/yocto_files.js
var YFileRecord = class {
  constructor(str_json) {
    this._name = "";
    this._size = 0;
    this._crc = 0;
    var loadval = JSON.parse(str_json);
    this._name = loadval.name;
    this._size = loadval.size;
    this._crc = loadval.crc;
  }
  get_name() {
    return this._name;
  }
  get_size() {
    return this._size;
  }
  get_crc() {
    return this._crc;
  }
};
var YFiles = class extends YFunction {
  constructor(yapi, func) {
    super(yapi, func);
    this._filesCount = YFiles.FILESCOUNT_INVALID;
    this._freeSpace = YFiles.FREESPACE_INVALID;
    this._valueCallbackFiles = null;
    this.FILESCOUNT_INVALID = YAPI.INVALID_UINT;
    this.FREESPACE_INVALID = YAPI.INVALID_UINT;
    this._className = "Files";
  }
  imm_parseAttr(name, val) {
    switch (name) {
      case "filesCount":
        this._filesCount = val;
        return 1;
      case "freeSpace":
        this._freeSpace = val;
        return 1;
    }
    return super.imm_parseAttr(name, val);
  }
  async get_filesCount() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YFiles.FILESCOUNT_INVALID;
      }
    }
    res = this._filesCount;
    return res;
  }
  async get_freeSpace() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YFiles.FREESPACE_INVALID;
      }
    }
    res = this._freeSpace;
    return res;
  }
  static FindFiles(func) {
    let obj;
    obj = YFunction._FindFromCache("Files", func);
    if (obj == null) {
      obj = new YFiles(YAPI, func);
      YFunction._AddToCache("Files", func, obj);
    }
    return obj;
  }
  static FindFilesInContext(yctx, func) {
    let obj;
    obj = YFunction._FindFromCacheInContext(yctx, "Files", func);
    if (obj == null) {
      obj = new YFiles(yctx, func);
      YFunction._AddToCache("Files", func, obj);
    }
    return obj;
  }
  async registerValueCallback(callback) {
    let val;
    if (callback != null) {
      await YFunction._UpdateValueCallbackList(this, true);
    } else {
      await YFunction._UpdateValueCallbackList(this, false);
    }
    this._valueCallbackFiles = callback;
    if (callback != null && await this.isOnline()) {
      val = this._advertisedValue;
      if (!(val == "")) {
        await this._invokeValueCallback(val);
      }
    }
    return 0;
  }
  async _invokeValueCallback(value) {
    if (this._valueCallbackFiles != null) {
      try {
        await this._valueCallbackFiles(this, value);
      } catch (e) {
        this._yapi.imm_log("Exception in valueCallback:", e);
      }
    } else {
      super._invokeValueCallback(value);
    }
    return 0;
  }
  async sendCommand(command) {
    let url;
    url = "files.json?a=" + command;
    return await this._download(url);
  }
  async format_fs() {
    let json;
    let res;
    json = await this.sendCommand("format");
    res = this.imm_json_get_key(json, "res");
    if (!(res == "ok")) {
      return this._throw(this._yapi.IO_ERROR, "format failed", this._yapi.IO_ERROR);
    }
    return this._yapi.SUCCESS;
  }
  async get_list(pattern) {
    let json;
    let filelist = [];
    let res = [];
    json = await this.sendCommand("dir&f=" + pattern);
    filelist = this.imm_json_get_array(json);
    res.length = 0;
    for (let ii in filelist) {
      res.push(new YFileRecord(filelist[ii]));
    }
    return res;
  }
  async fileExist(filename) {
    let json;
    let filelist = [];
    if (filename.length == 0) {
      return false;
    }
    json = await this.sendCommand("dir&f=" + filename);
    filelist = this.imm_json_get_array(json);
    if (filelist.length > 0) {
      return true;
    }
    return false;
  }
  async download(pathname) {
    return await this._download(pathname);
  }
  async upload(pathname, content) {
    return await this._upload(pathname, content);
  }
  async remove(pathname) {
    let json;
    let res;
    json = await this.sendCommand("del&f=" + pathname);
    res = this.imm_json_get_key(json, "res");
    if (!(res == "ok")) {
      return this._throw(this._yapi.IO_ERROR, "unable to remove file", this._yapi.IO_ERROR);
    }
    return this._yapi.SUCCESS;
  }
  nextFiles() {
    let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
    if (resolve.errorType != YAPI.SUCCESS)
      return null;
    let next_hwid = this._yapi.imm_getNextHardwareId(this._className, resolve.result);
    if (next_hwid == null)
      return null;
    return YFiles.FindFilesInContext(this._yapi, next_hwid);
  }
  static FirstFiles() {
    let next_hwid = YAPI.imm_getFirstHardwareId("Files");
    if (next_hwid == null)
      return null;
    return YFiles.FindFiles(next_hwid);
  }
  static FirstFilesInContext(yctx) {
    let next_hwid = yctx.imm_getFirstHardwareId("Files");
    if (next_hwid == null)
      return null;
    return YFiles.FindFilesInContext(yctx, next_hwid);
  }
};
YFiles.FILESCOUNT_INVALID = YAPI.INVALID_UINT;
YFiles.FREESPACE_INVALID = YAPI.INVALID_UINT;

// obj/full/constants.js
var constants = class {
  static get buildVersion() {
    return "1.10.55319";
  }
  static get deviceScreenWidth() {
    return screen.width * window.devicePixelRatio;
  }
  static get deviceScreenHeight() {
    return screen.height * window.devicePixelRatio;
  }
  static get isPhoneOrTablet() {
    return constants.ScreenDPI > 96 && Math.max(constants.deviceScreenWidth, constants.deviceScreenHeight) / constants.ScreenDPI < 12;
  }
  static get captureSizePolicy() {
    return constants._defaultCaptureSizePolicy;
  }
  static set captureSizePolicy(value) {
    constants._defaultCaptureSizePolicy = value;
  }
  static get dbleClickBringsUpContextMenu() {
    return constants._defaulDbleClickBringsUpContextMenu;
  }
  static set dbleClickBringsUpContextMenu(value) {
    constants._defaulDbleClickBringsUpContextMenu = value;
  }
  static get maxPointsPerGraphSerie() {
    return constants._defaultMaxPointsPerGraphSerie;
  }
  static set maxPointsPerGraphSerie(value) {
    if (value >= 0)
      constants._defaultMaxPointsPerGraphSerie = value >> 0;
  }
  static get maxPointsPerDataloggerSerie() {
    return constants._defaultMaxPointsPerDataloggerSerie;
  }
  static set maxPointsPerDataloggerSerie(value) {
    if (value >= -1)
      constants._defaultMaxPointsPerDataloggerSerie = value >> 0;
  }
  static get maxDataRecordsPerSensor() {
    return constants._defaultMaxDataRecordsPerSensor;
  }
  static set maxDataRecordsPerSensor(value) {
    if (value >= 0)
      constants._defaultMaxDataRecordsPerSensor = value >> 0;
  }
  static get captureWidth() {
    return constants._defaultCaptureWidth;
  }
  static set captureWidth(value) {
    if (value > 0)
      constants._defaultCaptureWidth = value;
  }
  static get captureHeight() {
    return constants._defaultCaptureHeight;
  }
  static set captureHeight(value) {
    if (value > 0)
      constants._defaultCaptureHeight = value;
  }
  static get captureDPI() {
    return constants._defaultCaptureDPI;
  }
  static set captureDPI(value) {
    if (value > 0)
      constants._defaultCaptureDPI = value;
  }
  static get captureType() {
    return constants._defaultCaptureType;
  }
  static set captureType(value) {
    constants._defaultCaptureType = value;
  }
  static get generalFontFamily() {
    return constants.FontFamily;
  }
  static get generalFontSize() {
    return constants.FontSize;
  }
  static get generalSizeCoef() {
    return constants.FontSize / 12;
  }
  static get screenDPI() {
    return constants.ScreenDPI;
  }
  static get guiDPIFactor() {
    return constants.DPIfactor;
  }
  static get guiDPIFactorWasOverriden() {
    return constants.DPIfactorOverriden;
  }
  static get guiDPIFactorIsOverriden() {
    let vs = constants.getCookie(constants.DPIFactorKey);
    if (vs == null)
      return false;
    let v = parseFloat(vs);
    if (v > 0)
      return true;
    return false;
  }
  static get guiDPIFactorOverrideValue() {
    let vs = constants.getCookie(constants.DPIFactorKey);
    if (vs == null)
      return constants.DPIfactor;
    let v = parseFloat(vs);
    if (v > 0)
      return v;
    return constants.DPIfactor;
  }
  static overrideGuiDPIFactor(override, value) {
    if (override && typeof value !== "undefined") {
      constants.setCookie(constants.DPIFactorKey, value.toString(), 3650);
    } else {
      constants.setCookie(constants.DPIFactorKey, "none", 3650);
    }
  }
  static get RunningOnAndroid() {
    return constants.isAndroid;
  }
  static get WindowBackgroundColor() {
    return "#f0f0f0";
  }
  static get WindowBorder() {
    return "1px solid #808080";
  }
  static get WindowPadding() {
    return 2;
  }
  static get WindowInnerBorderColor() {
    return " #A0A0A0";
  }
  static get WindowInnerBackgroundColor() {
    return "#fAfAfA";
  }
  static get WindowInnerBorder() {
    return "1px solid " + constants.WindowInnerBorderColor;
  }
  static get WindowHeaderBackgroundColor() {
    return "#0072ca";
  }
  static get WindowHeaderColor() {
    return "white";
  }
  static get WindowHeaderBorder() {
    return "1px solid #0072ca";
  }
  static get WindowHeaderHeight() {
    return 20;
  }
  static get WindowHeaderFontSize() {
    return 8 * constants.FontSize / 6;
  }
  static get WindowHeaderFontFamily() {
    return constants.FontFamily;
  }
  static get mustCheckForUpdate() {
    return constants._checkForUpdate;
  }
  static set mustCheckForUpdate(value) {
    if (value != constants._checkForUpdate) {
      constants._checkForUpdate = value;
      constants.edited = true;
    }
  }
  static get edited() {
    return constants._edited;
  }
  static set edited(value) {
    if (constants._edited != value) {
      constants._edited = value;
      YWebPage.ShowSaveReminder(value);
    }
  }
  static InitColorHistory(node) {
    let nodes = node.get_childsByIndex();
    for (let i = 0; i < nodes.length; i++) {
      let node2 = nodes[i];
      switch (nodes[i].Name) {
        case "Color":
          try {
            let colordef = node2.Attributes["value"];
            let color = YColor.FromString(colordef);
            if (color != null)
              colorEditor.AddColorToHistory(color);
          } catch (_a) {
          }
      }
    }
  }
  static findDPI() {
    let DPI = 1;
    while (!matchMedia("(max-resolution: " + DPI.toString() + "dpi)").matches) {
      DPI = DPI << 1;
    }
    let a = DPI >> 1;
    let b = DPI;
    while (b - a > 1) {
      let pivot = b + a >> 1;
      if (matchMedia("(max-resolution: " + pivot.toString() + "dpi)").matches) {
        b = pivot;
      } else {
        a = pivot;
      }
    }
    return b * (constants.isAndroid ? window.devicePixelRatio : 1);
  }
  static InitCaptureParams(node) {
    let nodes = node.get_childsByName();
    for (let nodeName in nodes) {
      let node2 = nodes[nodeName];
      let value;
      switch (nodeName) {
        case "Target":
          if ("value" in node2.Attributes) {
            constants._captureTarget = YDataRenderer.CaptureTarget.fromString(YDataRenderer.CaptureTarget, node2.Attributes["value"]);
          }
          break;
        case "Type":
          if ("value" in node2.Attributes) {
            constants._defaultCaptureType = YDataRenderer.CaptureType.fromString(YDataRenderer.CaptureType, node2.Attributes["value"]);
          }
          break;
        case "Size":
          if ("value" in node2.Attributes) {
            constants._defaultCaptureSizePolicy = YDataRenderer.CaptureFormats.fromString(YDataRenderer.CaptureFormats, node2.Attributes["value"]);
          }
          break;
        case "Resolution":
          if ("value" in node2.Attributes) {
            constants.captureDPI = parseInt(node2.Attributes["value"]);
          }
          break;
        case "Width":
          if ("value" in node2.Attributes) {
            constants.captureWidth = value = parseInt(node2.Attributes["value"]);
          }
          break;
        case "Height":
          if ("value" in node2.Attributes) {
            constants.captureHeight = parseInt(node2.Attributes["value"]);
          }
          break;
        case "Folder":
          if ("value" in node2.Attributes) {
            constants._captureFolder = node2.Attributes["value"];
          }
          break;
      }
    }
  }
  static InitUIParams(node) {
    let nodes = node.get_childsByName();
    for (let nodeName in nodes) {
      let node2 = nodes[nodeName];
      switch (nodeName) {
        case "VerticalDragZoom":
          if ("value" in node2.Attributes) {
            YGraph.verticalDragZoomEnabled = node2.Attributes["value"].toUpperCase() == "TRUE";
          }
          break;
        case "DbleClickContextMenu":
          if ("value" in node2.Attributes) {
            constants.dbleClickBringsUpContextMenu = node2.Attributes["value"].toUpperCase() == "TRUE";
          }
          break;
      }
    }
  }
  static InitCheckForUpdateParams(node) {
    let nodes = node.get_childsByName();
    for (let nodeName in nodes) {
      let node2 = nodes[nodeName];
      switch (nodeName) {
        case "checkForUpdate":
          if ("value" in node2.Attributes) {
            constants._checkForUpdate = node2.Attributes["value"].toUpperCase() == "TRUE";
          }
          break;
        case "ignoreBuild":
          if ("value" in node2.Attributes) {
            constants._ignoreBuild = parseInt(node2.Attributes["value"].toUpperCase());
          }
          break;
      }
    }
  }
  static InitMemoryUsageParams(node) {
    let nodes = node.get_childsByName();
    for (let nodeName in nodes) {
      let node2 = nodes[nodeName];
      switch (nodeName) {
        case "maxPointsPerGraphSerie":
          if ("value" in node2.Attributes) {
            let value = parseInt(node2.Attributes["value"]);
            constants.maxPointsPerGraphSerie = value;
            DataSerie.MaxPointsPerSeries = value;
          }
          break;
        case "maxDataRecordsPerSensor":
          if ("value" in node2.Attributes) {
            let value = parseInt(node2.Attributes["value"]);
            if (value >= 0) {
              constants.maxDataRecordsPerSensor = value;
              CustomYSensor.MaxDataRecords = value;
            }
          }
          break;
        case "maxPointsPerDataloggerSerie":
          if ("value" in node2.Attributes) {
            let value = parseInt(node2.Attributes["value"]);
            constants.maxPointsPerDataloggerSerie = value;
            CustomYSensor.MaxLoggerRecords = value;
          }
          break;
        case "deviceListValidity":
          if ("value" in node2.Attributes) {
            let value = parseInt(node2.Attributes["value"]);
            if (value > 0) {
              constants._deviceListValidity = value;
              YAPI.SetDeviceListValidity(value).then();
            }
          }
          break;
      }
    }
  }
  static Init(initData) {
    let nodes = initData.get_childsByName();
    for (let nodeName in nodes) {
      let node = nodes[nodeName];
      switch (nodeName) {
        case "UseUSB":
          if ("value" in node.Attributes) {
            constants._useUSB = node.Attributes["value"].toUpperCase() == "TRUE";
          }
          break;
        case "Colors":
          constants.InitColorHistory(node);
          break;
        case "Capture":
          constants.InitCaptureParams(node);
          break;
        case "UI":
          constants.InitUIParams(node);
          break;
        case "Updates":
          constants.InitCheckForUpdateParams(node);
          break;
        case "MemoryUsage":
          constants.InitMemoryUsageParams(node);
          break;
        case "UseVirtualHub":
          if ("value" in node.Attributes) {
            constants._useVirtualHub = node.Attributes["value"].toUpperCase() == "TRUE";
          }
          break;
        case "Hubs":
          sensorsManager.InitHubList(node);
          break;
      }
    }
  }
  static get CRCTable() {
    if (constants._crcTable != null)
      return constants._crcTable;
    constants._crcTable = [];
    let c;
    var crcTable = [];
    for (var n = 0; n < 256; n++) {
      c = n;
      for (var k = 0; k < 8; k++) {
        c = c & 1 ? 3988292384 ^ c >>> 1 : c >>> 1;
      }
      constants._crcTable[n] = c;
    }
    return constants._crcTable;
  }
  static crc32(str) {
    var crcTable = constants.CRCTable;
    var crc = 0 ^ -1;
    for (var i = 0; i < str.length; i++) {
      crc = crc >>> 8 ^ crcTable[(crc ^ str.charCodeAt(i)) & 255];
    }
    return (crc ^ -1) >>> 0;
  }
  static setCookie(cname, cvalue, exdays) {
    let d = new Date();
    d.setTime(d.getTime() + exdays * 24 * 60 * 60 * 1e3);
    let expires = "expires=" + d.toUTCString();
    document.cookie = cname + "=" + cvalue + ";" + expires + ";path=/";
  }
  static getCookie(cname) {
    let name = cname + "=";
    let decodedCookie = decodeURIComponent(document.cookie);
    let ca = decodedCookie.split(";");
    for (let i = 0; i < ca.length; i++) {
      let c = ca[i];
      while (c.charAt(0) == " ") {
        c = c.substring(1);
      }
      if (c.indexOf(name) == 0) {
        return c.substring(name.length, c.length);
      }
    }
    return null;
  }
  static XMLquote(st) {
    return st.replace("'", "&apos;").replace('"', "&quot;");
  }
  static GetXMLConfiguration() {
    let res = '<Config>\n  <UseUSB value="' + (constants._useUSB ? "TRUE" : "FALSE") + '"/>\n  <UseVirtualHub value="' + (constants._useVirtualHub ? "TRUE" : "FALSE") + '"/>\n  <Hubs>\n';
    res += sensorsManager.getXmlHublist();
    res += "  </Hubs>\n";
    res += "  <Colors>\n";
    for (let i = 0; i < colorEditor.colorHistory.length; i++) {
      res = res + '    <Color value="' + colorEditor.colorHistory[i].toString() + '"/>\n';
    }
    res += "  </Colors>\n";
    res += "  <MemoryUsage>\n";
    res += '    <maxPointsPerGraphSerie value= "' + constants.maxPointsPerGraphSerie.toString() + '"/>\n';
    res += '    <maxDataRecordsPerSensor value= "' + constants.maxDataRecordsPerSensor.toString() + '"/>\n';
    res += '    <maxPointsPerDataloggerSerie value= "' + constants.maxPointsPerDataloggerSerie.toString() + '"/>\n';
    res += '    <deviceListValidity value= "' + constants._deviceListValidity.toString() + '"/>\n';
    res += "  </MemoryUsage>\n";
    res += "  <Capture>\n";
    res += '    <Target value= "' + constants._captureTarget.toString + '"/>\n';
    res += '    <Type value= "' + constants.captureType.toString + '"/>\n';
    res += '    <Size value= "' + constants.captureSizePolicy.toString + '"/>\n';
    res += '    <Resolution value= "' + constants.captureDPI.toString() + '"/>\n';
    res += '    <Folder value= "' + constants.XMLquote(constants._captureFolder) + '"/>\n';
    res += '    <Width value= "' + constants.captureWidth.toString() + '"/>\n';
    res += '    <Height value= "' + constants.captureHeight.toString() + '"/>\n';
    res += "  </Capture>\n";
    res += "  <Updates>\n";
    res += '    <checkForUpdate  value = "' + (constants._checkForUpdate ? "True" : "False") + '"/>\n';
    res += '    <ignoreBuild  value = "' + constants._ignoreBuild.toString() + '"/>\n';
    res += "  </Updates>\n";
    res += "  <UI>\n";
    res += '    <VerticalDragZoom value= "' + (YGraph.verticalDragZoomEnabled ? "True" : "False") + '"/>\n';
    res += '    <DbleClickContextMenu value= "' + (constants.dbleClickBringsUpContextMenu ? "True" : "False") + '"/>\n';
    res += "  </UI>\n";
    res += "</Config>\n";
    return res;
  }
};
constants.DPIFactorKey = "YoctoVisualization4WebDPIFactor";
constants.isAndroid = navigator.userAgent.toLowerCase().indexOf("android") >= 0;
constants.ScreenDPI = constants.findDPI();
constants.FontFamily = "Arial, Helvetica, sans-serif";
constants.DPIfactorCookieValue = constants.getCookie(constants.DPIFactorKey);
constants.DPIfactorOverriden = constants.DPIfactorCookieValue != null;
constants.DPIfactor = constants.DPIfactorOverriden && parseFloat(constants.DPIfactorCookieValue) > 0 ? parseFloat(constants.DPIfactorCookieValue) : constants.isPhoneOrTablet ? Math.round(10 * constants.ScreenDPI / (96 * 1.2)) / 10 : 1;
constants.FontSize = 12 * constants.DPIfactor;
constants._defaultCaptureType = YDataRenderer.CaptureType.PNG;
constants._defaultCaptureWidth = 1024;
constants._defaultCaptureHeight = 1024;
constants._defaultCaptureDPI = 70;
constants._defaultCaptureSizePolicy = YDataRenderer.CaptureFormats.Keep;
constants._defaultMaxPointsPerGraphSerie = 0;
constants._defaultMaxPointsPerDataloggerSerie = 0;
constants._defaultMaxDataRecordsPerSensor = 0;
constants._defaulDbleClickBringsUpContextMenu = false;
constants._useUSB = true;
constants._useVirtualHub = false;
constants._captureTarget = YDataRenderer.CaptureTarget.ToFile;
constants._captureFolder = "";
constants._checkForUpdate = true;
constants._ignoreBuild = 0;
constants._deviceListValidity = 3600;
constants._edited = false;
constants._crcTable = null;

// obj/full/sensorManager.js
var Hub = class {
  constructor(hubType, protocol, user, password, clearPassword, addr, port, path, removeable) {
    this._netname = "";
    this._module = null;
    this._logicname = "";
    this._previousURL = "";
    this._previousobfuscatedURL = "";
    this._hubType = 2;
    this._protocol = "";
    this._user = "";
    this._password = "";
    this._addr = "";
    this._port = "";
    this._removable = true;
    this._path = "";
    this._state = 0;
    while (/^\//.test(path)) {
      path = path.slice(1);
    }
    while (/\/$/.test(path)) {
      path = path.slice(0, -1);
    }
    this._hubType = hubType;
    this._protocol = protocol;
    this._user = user;
    this._port = port;
    this._password = clearPassword ? password != "" ? Hub.Encrypt(password, Hub.loginCypherPassword) : "" : password;
    this._addr = addr;
    this._path = path;
    this._removable = typeof removeable === "undefined" ? true : removeable;
  }
  static Decrypt(data, loginCypherPassword) {
    if (data == "")
      return "";
    if (data.length % 4)
      return "";
    let buffer = new Uint16Array(data.length >> 2);
    for (let i = 0; i < buffer.length; i++) {
      buffer[i] = parseInt(data.slice(i * 4, i * 4 + 4), 16);
    }
    let checksum = buffer[0];
    for (let i = 1; i < buffer.length - 1; i++) {
      checksum ^= buffer[i];
    }
    if (checksum != buffer[buffer.length - 1])
      return "";
    let res = "";
    for (let i = 0; i < buffer.length - 2; i++) {
      res += String.fromCharCode(buffer[i + 1] & 255 ^ loginCypherPassword.charCodeAt(i % loginCypherPassword.length) ^ buffer[0] + i & 255 ^ (buffer[i + 1] & 2048) >> 11 << ((buffer[i + 1] & 1792) >> 8) ^ (buffer[i + 1] & 32768) >> 15 << ((buffer[i + 1] & 28672) >> 12));
    }
    return res;
  }
  static Encrypt(data, loginCypherPassword) {
    if (data == "")
      return "";
    let buffer = crypto.getRandomValues(new Uint16Array(data.length + 2));
    for (let i = 0; i < data.length; i++) {
      buffer[i + 1] = buffer[i + 1] & 65280 | data.charCodeAt(i) ^ loginCypherPassword.charCodeAt(i % loginCypherPassword.length) ^ buffer[0] + i & 255 ^ (buffer[i + 1] & 2048) >> 11 << ((buffer[i + 1] & 1792) >> 8) ^ (buffer[i + 1] & 32768) >> 15 << ((buffer[i + 1] & 28672) >> 12);
    }
    buffer[buffer.length - 1] = buffer[0];
    for (let i = 1; i < buffer.length - 1; i++) {
      buffer[buffer.length - 1] ^= buffer[i];
    }
    let res = "";
    for (let i = 0; i < buffer.length; i++) {
      res += ("000" + buffer[i].toString(16)).slice(-4).toUpperCase();
    }
    return res;
  }
  static encryptPassword(clearPassword) {
    return clearPassword == "" ? "" : Hub.Encrypt(clearPassword, Hub.loginCypherPassword);
  }
  get hubType() {
    return this._hubType;
  }
  set hubType(value) {
    this._hubType = value;
  }
  get protocol() {
    return this._protocol;
  }
  set protocol(value) {
    this._protocol = value;
  }
  get user() {
    return this._user;
  }
  set user(value) {
    this._user = value;
  }
  get encryptedPassword() {
    return this._password;
  }
  set encryptedPassword(value) {
    this._password = value;
  }
  get clearPassword() {
    return this._password == "" ? "" : Hub.Decrypt(this._password, Hub.loginCypherPassword);
  }
  set clearPassword(value) {
    this._password = value == "" ? "" : Hub.encryptPassword(value);
  }
  get addr() {
    return this._addr;
  }
  set addr(value) {
    this._addr = value;
  }
  get port() {
    return this._port;
  }
  set port(value) {
    this._port = value;
  }
  get removable() {
    return this._removable;
  }
  set removable(value) {
    this._removable = value;
  }
  get path() {
    return this._path;
  }
  set path(value) {
    this._path = value;
  }
  get ConnectionState() {
    return this._state;
  }
  get ConnectionDescription() {
    switch (this._state) {
      case 1:
        return "Connecting..";
      case 2:
        return (this._logicname != "" ? this._logicname : this._netname) + " OK";
      case 3:
        return "Connection failed ";
      default:
        return "Not connected.";
    }
  }
  static HubFromXml(subnode) {
    let hubType = 2;
    let protocol = "ws";
    let removable = true;
    if ("protocol" in subnode.Attributes)
      protocol = subnode.Attributes["protocol"];
    let user = "";
    if ("user" in subnode.Attributes)
      user = subnode.Attributes["user"];
    let password = "";
    if ("password" in subnode.Attributes)
      password = subnode.Attributes["password"];
    let port = "";
    if ("port" in subnode.Attributes)
      port = subnode.Attributes["port"];
    let path = "";
    if ("path" in subnode.Attributes)
      path = subnode.Attributes["path"];
    let addr = "";
    if ("addr" in subnode.Attributes)
      addr = subnode.Attributes["addr"];
    if ("removable" in subnode.Attributes)
      removable = subnode.Attributes["removable"].toUpperCase() == "TRUE";
    return new Hub(hubType, protocol, user, password, false, addr, port, path, removable);
  }
  async Connect() {
    let errmsg = new YErrorMsg();
    this._state = 1;
    logForm.log("preregistering  " + this.get_obfuscatedURL());
    if (!YWebPage.readonly)
      configForm.hubStateChanged(this);
    let url = this.get_fullUrl();
    if (await YAPI.PreregisterHub(url, errmsg) != YAPI_SUCCESS) {
      logForm.log("[!] preregistering  " + this.get_obfuscatedURL() + " failed (" + errmsg.msg + ")");
      this._state = 3;
      this._previousURL = "";
      this._previousobfuscatedURL = "";
    } else {
      this._previousURL = url;
      this._previousobfuscatedURL = this.get_obfuscatedURL();
    }
    if (!YWebPage.readonly)
      configForm.hubStateChanged(this);
  }
  async Disconnect() {
    if (this._previousURL == "")
      return;
    logForm.log("Unregistering  " + this._previousobfuscatedURL);
    await YAPI.UnregisterHub(this._previousURL);
    this._previousURL = "";
    this._previousobfuscatedURL = "";
    this._state = 0;
    if (!YWebPage.readonly)
      configForm.hubStateChanged(this);
  }
  arrival(ip, netname, module, logicname) {
    this._state = 2;
    this._netname = netname;
    this._module = module;
    this._logicname = logicname;
    this._state = 2;
    if (!YWebPage.readonly) {
      configForm.hubStateChanged(this);
    }
  }
  get address() {
    return this._addr;
  }
  get_consoleUrl() {
    let fullurl = this._protocol + "://" + this._addr;
    if (this._port != "")
      fullurl = fullurl + ":" + this._port;
    return fullurl;
  }
  toString() {
    return this.get_consoleUrl();
  }
  get_fullUrl() {
    let fullurl = "";
    if (this._protocol != "")
      fullurl = this._protocol + "://";
    if (this._user != "") {
      fullurl = fullurl + this._user;
      if (this._password != "")
        fullurl = fullurl + ":" + Hub.Decrypt(this._password, Hub.loginCypherPassword);
      fullurl = fullurl + "@";
    }
    fullurl = fullurl + this._addr;
    if (this._port != "")
      fullurl = fullurl + ":" + this._port;
    else
      fullurl = fullurl + ":4444";
    fullurl = fullurl + "/";
    if (this._path) {
      fullurl = fullurl + this._path + "/";
    }
    return fullurl;
  }
  get_connexionUrl() {
    let fullurl;
    if (this._protocol != "")
      fullurl = this._protocol + "://";
    else
      fullurl = "ws://";
    fullurl = fullurl + this._addr;
    if (this._port != "")
      fullurl = fullurl + ":" + this._port;
    else
      fullurl = fullurl + ":4444";
    fullurl = fullurl + "/";
    return fullurl.toLowerCase();
  }
  get_obfuscatedURL() {
    let fullurl = "";
    if (this._protocol != "")
      fullurl = this._protocol + "://";
    if (this._user != "") {
      fullurl = fullurl + this._user;
      if (this._password != "")
        fullurl = fullurl + ":#####";
      fullurl = fullurl + "@";
    }
    fullurl = fullurl + this._addr;
    if (this._port != "")
      fullurl = fullurl + ":" + this._port;
    if (this._path != "")
      fullurl = fullurl + "/" + this._path;
    return fullurl;
  }
  XmlCode() {
    let NodeLine = "<Hub ";
    if (this._protocol != "")
      NodeLine = NodeLine + 'protocol="' + constants.XMLquote(this._protocol) + '" ';
    if (this._user != "")
      NodeLine = NodeLine + 'user="' + constants.XMLquote(this._user) + '" ';
    if (this._password != "")
      NodeLine = NodeLine + 'password="' + constants.XMLquote(this._password) + '" ';
    NodeLine = NodeLine + 'addr="' + constants.XMLquote(this._addr) + '" ';
    if (this._port != "")
      NodeLine = NodeLine + 'port="' + constants.XMLquote(this.port) + '" ';
    if (this._path != "")
      NodeLine = NodeLine + 'path="' + constants.XMLquote(this._path) + '" ';
    if (!this._removable)
      NodeLine = NodeLine + 'removable="FALSE" ';
    return NodeLine + "/>";
  }
};
Hub.loginCypherPassword = "+>*X[?_ih$N7wA!}";
var TimedSensorValue = class {
  constructor(DateTime, value) {
    this._DateTime = DateTime;
    this._value = value;
  }
  get DateTime() {
    return this._DateTime;
  }
  get value() {
    return this._value;
  }
};
var AlarmSettings = class {
  constructor(index, owner, xmldata) {
    this.index = 0;
    this.Condition = 0;
    this.Source = 0;
    this.Value = 0;
    this.Delay = 15;
    this.Commandline = "";
    this.lastAlarm = new Date(0);
    this.index = index;
    this.parent = owner;
    if (typeof xmldata !== "undefined") {
      if ("Source" in xmldata.Attributes)
        this.Source = parseInt(xmldata.Attributes["Source"]);
      if ("Condition" in xmldata.Attributes)
        this.Condition = parseInt(xmldata.Attributes["Condition"]);
      if ("Value" in xmldata.Attributes)
        this.Value = parseFloat(xmldata.Attributes["Value"]);
      if ("Cmd" in xmldata.Attributes)
        this.Commandline = xmldata.Attributes["Cmd"];
      if ("Delay" in xmldata.Attributes)
        this.Delay = parseInt(xmldata.Attributes["Delay"]);
    }
  }
  static ExecuteCommand(source, command) {
  }
  getXmlData() {
    return '<Alarm Source="' + this.Source.toString() + '" Condition="' + this.Condition.toString() + '" Value="' + this.Value.toString() + '" Cmd="' + GenericProperties.escapeXml(this.Commandline) + '" Delay="' + this.Delay.toString() + '"/>\n';
  }
  setCondition(condition) {
    this.Condition = condition;
  }
  getCondition() {
    return this.Condition;
  }
  setSource(source) {
    this.Source = source;
  }
  getSource() {
    return this.Source;
  }
  setValue(value) {
    this.Value = value;
  }
  getValue() {
    return this.Value;
  }
  setDelay(value) {
    if (value < 0)
      throw "delay must be a positive value";
    this.Delay = value;
  }
  getDelay() {
    return this.Delay;
  }
  setCommandline(value) {
    this.Commandline = value;
  }
  getCommandline() {
    return this.Commandline;
  }
  check(m) {
    let alarm = false;
    let reason = "";
    let src;
    let SensorValue;
    switch (this.Source) {
      case 1:
        src = "MIN";
        SensorValue = m.get_minValue();
        break;
      case 2:
        src = "MAX";
        SensorValue = m.get_maxValue();
        break;
      default:
        src = "AVG";
        SensorValue = m.get_averageValue();
        break;
    }
    switch (this.Condition) {
      default:
        return;
      case 1:
        reason = ">";
        if (SensorValue > this.Value)
          alarm = true;
        break;
      case 2:
        reason = ">=";
        if (SensorValue >= this.Value)
          alarm = true;
        break;
      case 3:
        reason = "=";
        if (SensorValue == this.Value)
          alarm = true;
        break;
      case 4:
        reason = "<=";
        if (SensorValue <= this.Value)
          alarm = true;
        break;
      case 5:
        reason = "<";
        if (SensorValue < this.Value)
          alarm = true;
        break;
    }
    let now = new Date();
    if (!alarm)
      return;
    if (now.getTime() - this.lastAlarm.getTime() < 1e3 * this.Delay)
      return;
    let source = "ALARM " + (this.index + 1).toString();
    logForm.log(source + " on " + this.parent.get_hardwareId() + "/" + this.parent.get_friendlyName() + " (" + SensorValue.toString() + reason + this.Value.toString() + ")");
    let Execute = this.Commandline;
    Execute = Execute.replace("$SENSORVALUE$", SensorValue.toString());
    Execute = Execute.replace("$HWDID$", this.parent.get_hardwareId());
    Execute = Execute.replace("$NAME$", this.parent.get_friendlyName());
    Execute = Execute.replace("$UNIT$", this.parent.get_unit());
    Execute = Execute.replace("$CONDITION$", reason);
    Execute = Execute.replace("$DATATYPE$", src);
    Execute = Execute.replace("$TRIGGER$", this.Value.toString());
    Execute = Execute.replace("$NOW$", logForm.dateToString(now));
    try {
      Function(Execute)();
    } catch (e) {
      logForm.log("ALARM " + (this.index + 1) + " code (" + Execute + ") caused an exception :" + e.message);
    }
    this.lastAlarm = now;
  }
};
var DataLoggerBoundary = class {
  constructor(start, stop) {
    this._start = 0;
    this._stop = 0;
    this._start = start;
    this._stop = stop;
  }
  get start() {
    return this._start;
  }
  get stop() {
    return this._stop;
  }
};
var MergeSourceRange = class {
  constructor(start, stop) {
    this.MergeSourceStart = 0;
    this.MergeSourceStop = 0;
    this.MergeSourceStart = start;
    this.MergeSourceStop = stop;
  }
};
var CustomYSensor = class {
  constructor(s, name, SensorLocalConfig) {
    this.unit = "";
    this._frequency = "";
    this.resolution = 1;
    this._recording = false;
    this._online = false;
    this.preloadDone = false;
    this.loadDone = false;
    this.cfgChgNotificationsSupported = false;
    this.mustReloadConfig = false;
    this._readonly = false;
    this._plzCancelDataloggerLoading = false;
    this._predloadProcessIsBusy = false;
    this._loadProcessIsBusy = false;
    this.lastGetConfig = 0;
    this.recordedDataLoadProgress = 0;
    this.recordedData = null;
    this.dataLoggerFeature = false;
    this.dataLoggerLoadCompleted = false;
    this.loadFailed = false;
    this.loadCanceled = false;
    this.firstLiveDataTimeStamp = 0;
    this.firstDataloggerTimeStamp = 0;
    this.lastDataTimeStamp = 0;
    this.lastDataSource = "";
    this.consecutiveBadTimeStamp = 0;
    this.minData = [];
    this.curData = [];
    this.maxData = [];
    this.previewMinData = [];
    this.previewCurData = [];
    this.previewMaxData = [];
    this._lastAvgValue = Number.NaN;
    this._lastMinValue = Number.NaN;
    this._lastMaxValue = Number.NaN;
    this._dataloggerLoadisRunning = true;
    this._dataloggerLoadProgress = 0;
    this.dataLoggerStartReadTime = 0;
    this.Alarms = [];
    this.FormsToNotify = [];
    this.sensor = s;
    this.hwdName = name;
    this._friendlyname = name;
    if (s == null)
      return;
    if (SensorLocalConfig != null) {
      let index = 0;
      let childs = SensorLocalConfig.get_childsByIndex();
      for (let i = 0; i < childs.length; i++) {
        let n = childs[i];
        if (n.Name == "Alarm") {
          this.checkAlarmIndex(index);
          this.Alarms[index] = new AlarmSettings(index, this, n);
          index++;
        }
      }
    }
  }
  get isReadOnly() {
    return this._readonly || !this._online;
  }
  get dataloggerLoadisRunning() {
    return this._dataloggerLoadisRunning;
  }
  get dataloggerLoadProgress() {
    return this._dataloggerLoadProgress;
  }
  setDataloggerLoadProgress(value) {
    this._dataloggerLoadProgress = value;
    for (let i = 0; i < this.FormsToNotify.length; i++) {
      if (this.FormsToNotify[i] instanceof graphWidget) {
        this.FormsToNotify[i].dataLoggerLoadprocessIsRunningNotification(this);
      }
    }
  }
  static get MaxDataRecords() {
    return CustomYSensor._MaxDataRecords;
  }
  static set MaxDataRecords(value) {
    CustomYSensor._MaxDataRecords = value;
  }
  static get MaxLoggerRecords() {
    return CustomYSensor._MaxLoggerRecords;
  }
  static set MaxLoggerRecords(value) {
    CustomYSensor._MaxLoggerRecords = value;
  }
  get_lastAvgValue() {
    if (this._online)
      return this._lastAvgValue;
    return Number.NaN;
  }
  get_lastMaxValue() {
    if (this._online)
      return this._lastMaxValue;
    return Number.NaN;
  }
  get_lastMinValue() {
    if (this._online)
      return this._lastMinValue;
    return Number.NaN;
  }
  async ConfigHasChanged() {
    this.cfgChgNotificationsSupported = true;
    this.mustReloadConfig = true;
    this._online = true;
    await this.reloadConfig();
    await this.forceUpdate();
  }
  checkAlarmIndex(index) {
    while (this.Alarms.length < index + 1) {
      this.Alarms.push(new AlarmSettings(this.Alarms.length, this));
    }
  }
  getAlarmCount() {
    return this.Alarms.length;
  }
  setAlarmCondition(index, condition) {
    this.checkAlarmIndex(index);
    this.Alarms[index].setCondition(condition);
  }
  getAlarmCondition(index) {
    this.checkAlarmIndex(index);
    return this.Alarms[index].getCondition();
  }
  setAlarmSource(index, source) {
    this.checkAlarmIndex(index);
    this.Alarms[index].setSource(source);
  }
  getAlarmSource(index) {
    this.checkAlarmIndex(index);
    return this.Alarms[index].getSource();
  }
  setAlarmValue(index, value) {
    this.checkAlarmIndex(index);
    this.Alarms[index].setValue(value);
  }
  getAlarmValue(index) {
    this.checkAlarmIndex(index);
    return this.Alarms[index].getValue();
  }
  setAlarmDelay(index, value) {
    this.checkAlarmIndex(index);
    this.Alarms[index].setDelay(value);
  }
  getAlarmDelay(index) {
    this.checkAlarmIndex(index);
    return this.Alarms[index].getDelay();
  }
  setAlarmCommandline(index, value) {
    this.checkAlarmIndex(index);
    this.Alarms[index].setCommandline(value);
  }
  getAlarmCommandline(index) {
    this.checkAlarmIndex(index);
    return this.Alarms[index].getCommandline();
  }
  GetXmlData() {
    let res = '<Sensor ID="' + this.get_hardwareId() + '">\n';
    for (let i = 0; i < this.getAlarmCount(); i++) {
      res = res + this.Alarms[i].getXmlData();
    }
    res = res + "</Sensor>\n";
    return res;
  }
  get_firstLiveDataTimeStamp() {
    return this.firstLiveDataTimeStamp;
  }
  get_firstDataloggerTimeStamp() {
    return this.firstDataloggerTimeStamp;
  }
  get_lastDataTimeStamp() {
    return this.lastDataTimeStamp;
  }
  async preload_DoWork(arg) {
    if (this._predloadProcessIsBusy) {
      console.log("!!! multiple datalogger load attempt");
      return;
    }
    if (this.dataLoggerLoadCompleted) {
      console.log("!!!  datalogger load attempt although datalogger is already loaded.");
      return;
    }
    this._predloadProcessIsBusy = true;
    logForm.log(this.hwdName + ": preloading data from " + arg.start.toString() + " to " + arg.stop.toString() + "(delta= " + (arg.stop - arg.start).toFixed(3) + ")");
    this.setDataloggerLoadProgress(1);
    this.recordedData = await this.sensor.get_recordedData(arg.start, arg.stop);
    try {
      this.recordedDataLoadProgress = await this.recordedData.loadMore();
    } catch (e) {
      logForm.log(this.hwdName + ": load more caused an exception " + e.message);
    }
    let measures = await this.recordedData.get_preview();
    this.previewMinData = [];
    this.previewCurData = [];
    this.previewMaxData = [];
    let startIndex = 0;
    let errCount = 0;
    let maxErrorCount = 10;
    let lastT = -1;
    if (CustomYSensor._MaxDataRecords > 0 && measures.length > CustomYSensor._MaxDataRecords)
      startIndex = measures.length - CustomYSensor._MaxDataRecords;
    for (let i = startIndex; i < measures.length; i++) {
      let t = measures[i].get_endTimeUTC();
      if (t >= arg.start && t <= arg.stop) {
        this.previewMinData.push(new TimedSensorValue(t, measures[i].get_minValue()));
        this.previewCurData.push(new TimedSensorValue(t, measures[i].get_averageValue()));
        this.previewMaxData.push(new TimedSensorValue(t, measures[i].get_maxValue()));
        if (t < lastT && errCount < maxErrorCount) {
          logForm.log(this.hwdName + " preloading warning:  timestamp going back in time " + t + "<" + lastT + (errCount < maxErrorCount - 1 ? "" : ", further similar errors wont be logged."));
          errCount++;
        } else if (t == lastT && errCount < maxErrorCount) {
          logForm.log(this.hwdName + " preloading warning: duplicate timestamp  " + t + (errCount < maxErrorCount - 1 ? "" : ", further similar errors wont be logged."));
          errCount++;
        }
        lastT = t;
      }
    }
    if (this.previewCurData.length > 1) {
      let a = this.previewCurData[0].DateTime;
      let b = this.previewCurData[this.previewCurData.length - 1].DateTime;
      logForm.log(this.hwdName + ": preloaded data from " + a.toString() + " to " + b.toString() + " (delta=" + (b - a).toFixed(3) + ")");
      if (CustomYSensor._MaxLoggerRecords > 0 && arg.start == 0) {
        let list = await this.recordedData.get_privateDataStreams();
        let index = list.length - 1;
        let totalRecords = 0;
        while (index > 0 && totalRecords < CustomYSensor._MaxLoggerRecords) {
          totalRecords += await list[index].get_rowCount();
          this.dataLoggerStartReadTime = await list[index].get_startTimeUTC();
          index--;
        }
        let n = 0;
        while (n < this.previewMinData.length && this.previewMinData[n].DateTime < this.dataLoggerStartReadTime) {
          n++;
        }
        if (n > 1) {
          this.previewMinData.splice(0, n - 1);
          this.previewCurData.splice(0, n - 1);
          this.previewMaxData.splice(0, n - 1);
        }
      }
    }
    this.preload_Completed(arg);
  }
  findMergeBoundaries(previewMinData) {
    let MergeSourceStart = 0;
    let MergeSourceStop = 0;
    if (this.minData.length > 0) {
      while (MergeSourceStart < this.minData.length && previewMinData[0].DateTime > this.minData[MergeSourceStart].DateTime) {
        MergeSourceStart++;
      }
      MergeSourceStop = MergeSourceStart;
      while (MergeSourceStop < this.minData.length && previewMinData[previewMinData.length - 1].DateTime >= this.minData[MergeSourceStop].DateTime) {
        MergeSourceStop++;
      }
    }
    return new MergeSourceRange(MergeSourceStart, MergeSourceStop);
  }
  preload_Completed(arg) {
    if (this.previewMinData == null)
      return;
    logForm.log(this.hwdName + " : datalogger preloading completed (" + this.previewMinData.length + " rows)");
    if (this.previewMinData.length > 1) {
      let it = this.findMergeBoundaries(this.previewMinData);
      let insertIndex = it.MergeSourceStart;
      let deleteCount = it.MergeSourceStop - it.MergeSourceStart;
      this.minData = this.minData.slice(0, insertIndex).concat(this.previewMinData, this.minData.slice(insertIndex + deleteCount));
      this.curData = this.curData.slice(0, insertIndex).concat(this.previewCurData, this.curData.slice(insertIndex + deleteCount));
      this.maxData = this.maxData.slice(0, insertIndex).concat(this.previewMaxData, this.maxData.slice(insertIndex + deleteCount));
      for (let i = 0; i < this.FormsToNotify.length; i++) {
        if (this.FormsToNotify[i] instanceof graphWidget) {
          this.FormsToNotify[i].SensorNewDataBlock(this, it.MergeSourceStart, it.MergeSourceStart + this.previewMinData.length - 1, 0, true);
        }
      }
    }
    let count = this.curData.length;
    if (count > 0) {
      if (this.curData[count - 1].DateTime > this.lastDataTimeStamp) {
        this.lastDataTimeStamp = this.curData[count - 1].DateTime;
        this.lastDataSource = "last preload timestamp";
      }
    }
    logForm.log(this.hwdName + " : start datalogger loading");
    this._predloadProcessIsBusy = false;
    this.load_DoWork(arg).then();
  }
  get_frequency() {
    return this._frequency;
  }
  async updateFrequncy(frequencyToSet) {
    if (await this.sensor.isOnline()) {
      this._frequency = frequencyToSet;
      await this.sensor.set_reportFrequency(this._frequency);
      let lfreq = await this.sensor.get_logFrequency();
      try {
        if (lfreq != "OFF")
          await this.sensor.set_logFrequency(this._frequency);
        let m = await this.sensor.get_module();
        await m.saveToFlash();
      } catch (e) {
        logForm.log("failed to change " + this.hwdName + " log frequency (" + e.message + ")");
      }
    } else {
      this._online = false;
    }
  }
  set_frequency(frequencyToSet) {
    if (this._online) {
      this.updateFrequncy(frequencyToSet).then();
    }
  }
  get_recording() {
    return this._recording;
  }
  set_recording(recordingStatus) {
    this.updaterecording(recordingStatus).then();
  }
  async updaterecording(recordingStatus) {
    if (!this.dataLoggerFeature)
      return;
    if (await this.sensor.isOnline()) {
      this._recording = recordingStatus;
      try {
        await this.sensor.set_logFrequency(this._recording ? this._frequency : "OFF");
        let module = await this.sensor.get_module();
        let serial = await module.get_serialNumber();
        let dl = YDataLogger.FindDataLogger(serial + ".dataLogger");
        await dl.set_recording(this._recording ? YDataLogger.RECORDING_ON : YDataLogger.RECORDING_OFF);
        await dl.set_autoStart(this._recording ? YDataLogger.AUTOSTART_ON : YDataLogger.AUTOSTART_OFF);
        await module.saveToFlash();
      } catch (e) {
        logForm.log("failed to change " + this.hwdName + " recording (" + e.message + ")");
      }
    } else {
      this._online = false;
    }
  }
  reportDataloggerLoadProgress(progress) {
  }
  async load_DoWork(arg) {
    if (this._loadProcessIsBusy)
      return;
    this._loadProcessIsBusy = true;
    if (this.dataLoggerLoadCompleted)
      return;
    logForm.log(this.hwdName + " loading main data from datalogger");
    if (this.dataLoggerStartReadTime > 0) {
      this.recordedData = await this.sensor.get_recordedData(this.dataLoggerStartReadTime, 0);
    }
    let errCount = 0;
    let maxErrorCount = 10;
    let lastT = -1;
    let lastProgress = this.recordedDataLoadProgress;
    while (this.recordedDataLoadProgress < 100) {
      if (this._plzCancelDataloggerLoading) {
        this.loadDone = true;
        this.loadFailed = false;
        this.loadCanceled = true;
        this.setDataloggerLoadProgress(100);
        break;
      }
      try {
        this.recordedDataLoadProgress = await this.recordedData.loadMore();
      } catch (Exception) {
        this.loadFailed = true;
        return;
      }
      if (lastProgress != this.recordedDataLoadProgress) {
        lastProgress = this.recordedDataLoadProgress;
        let p = lastProgress;
        if (p < 1)
          p = 1;
        if (p > 99)
          p = 99;
        this.setDataloggerLoadProgress(p < 1 ? 1 : p > 99 ? 99 : p);
      }
      if (this.recordedDataLoadProgress - lastProgress >= 2) {
        lastProgress = this.recordedDataLoadProgress;
      }
    }
    let measures = await this.recordedData.get_measures();
    this.previewMinData = [];
    this.previewCurData = [];
    this.previewMaxData = [];
    for (let i = 0; i < measures.length; i++) {
      let t = measures[i].get_endTimeUTC();
      if (t >= arg.start && t <= arg.stop) {
        if (t < lastT && errCount < maxErrorCount) {
          logForm.log(this.hwdName + " loading warning:  timestamp going back in time " + t + "<" + lastT + (errCount < maxErrorCount - 1 ? "" : ", further similar errors wont be logged."));
          errCount++;
        } else if (t == lastT && errCount < maxErrorCount) {
          logForm.log(this.hwdName + " loading warning: duplicate timestamp  " + t + (errCount < maxErrorCount - 1 ? "" : ", further similar errors wont be logged."));
          errCount++;
        }
        lastT = t;
        if (this.previewMinData.length == 0 || t > this.previewMinData[this.previewMinData.length - 1].DateTime) {
          this.previewMinData.push(new TimedSensorValue(t, measures[i].get_minValue()));
          this.previewCurData.push(new TimedSensorValue(t, measures[i].get_averageValue()));
          this.previewMaxData.push(new TimedSensorValue(t, measures[i].get_maxValue()));
        }
      } else {
        let d = new Date(t * 1e3);
        let d1 = new Date(arg.start * 1e3);
        let d2 = new Date(arg.stop * 1e3);
        let dstr = d.toLocaleDateString() + " " + d.toLocaleTimeString();
        let d1str = d1.toLocaleDateString() + " " + d1.toLocaleTimeString();
        let d2str = d2.toLocaleDateString() + " " + d2.toLocaleTimeString();
        logForm.log(this.hwdName + " note: skipping measure at " + dstr + ", not in range " + d1str + " ... " + d2str);
      }
    }
    if (CustomYSensor._MaxDataRecords > 0)
      this.previewDataCleanUp();
    for (let i = 0; i < this.previewMinData.length - 1; i++) {
      if (this.previewMinData[i].DateTime >= this.previewMinData[i + 1].DateTime) {
        throw "Time-stamp inconsistency";
      }
    }
    if (this.previewCurData.length > 1) {
      logForm.log(this.hwdName + " loaded " + this.previewCurData.length.toString() + "/" + measures.length.toString() + " records over " + (this.previewCurData[this.previewCurData.length - 1].DateTime - this.previewCurData[0].DateTime).toFixed(3) + " sec, last timed stamp was " + this.previewCurData[this.previewCurData.length - 1].DateTime);
    } else {
      logForm.log(this.hwdName + " loaded " + this.previewCurData.length.toString() + " records");
    }
    if (this.previewMinData.length > 2) {
      let lastPreviewTimeStamp = this.previewMinData[this.previewMinData.length - 1].DateTime;
      let it = this.findMergeBoundaries(this.previewMinData);
      let deleteCount = it.MergeSourceStop - it.MergeSourceStart;
      this.minData = this.minData.slice(0, it.MergeSourceStart).concat(this.previewMinData, this.minData.slice(it.MergeSourceStart + deleteCount));
      this.curData = this.curData.slice(0, it.MergeSourceStart).concat(this.previewCurData, this.curData.slice(it.MergeSourceStart + deleteCount));
      this.maxData = this.maxData.slice(0, it.MergeSourceStart).concat(this.previewMaxData, this.maxData.slice(it.MergeSourceStart + deleteCount));
      this.firstDataloggerTimeStamp = this.curData[0].DateTime;
    }
    this.loadDone = true;
    this.loadFailed = false;
    let count = this.curData.length;
    if (count > 0) {
      if (this.curData[count - 1].DateTime > this.lastDataTimeStamp) {
        this.lastDataTimeStamp = this.curData[count - 1].DateTime;
        this.lastDataSource = "end of datalogger";
      }
    }
    this.load_Completed();
  }
  load_Completed() {
    logForm.log(this.hwdName + ".loadcompleted()");
    if (this.loadFailed) {
      logForm.log(this.hwdName + " : datalogger loading failed");
      this._loadProcessIsBusy = false;
      return;
    }
    if (this.loadCanceled) {
      logForm.log(this.hwdName + " : datalogger loading was canceled");
      this.previewMinData = [];
      this.previewCurData = [];
      this.previewMaxData = [];
      this.loadCanceled = false;
      this._loadProcessIsBusy = false;
      this.preloadDone = false;
      this.loadDone = false;
      return;
    }
    if (this.previewCurData.length <= 2) {
      this.preloadDone = false;
      this.loadDone = false;
    }
    logForm.log(this.hwdName + " : datalogger loading completed  (" + this.previewMinData.length + " rows)");
    this.resetDataloggerLoader();
    this.dataLoggerLoadCompleted = true;
    for (let i = 0; i < this.FormsToNotify.length; i++) {
      if (this.FormsToNotify[i] instanceof graphWidget) {
        this.FormsToNotify[i].DataloggerCompleted(this);
      }
    }
    this.setDataloggerLoadProgress(100);
  }
  get dataloggerWasUsed() {
    return this.dataLoggerLoadCompleted;
  }
  dataCleanUp() {
    if (CustomYSensor._MaxDataRecords <= 0)
      return;
    let newsize = CustomYSensor._MaxDataRecords * 90 / 100 >> 0;
    if (this.curData != null && CustomYSensor._MaxDataRecords < this.curData.length) {
      this.minData.splice(0, this.minData.length - newsize);
      this.curData.splice(0, this.curData.length - newsize);
      this.maxData.splice(0, this.maxData.length - newsize);
    }
  }
  previewDataCleanUp() {
    if (CustomYSensor._MaxDataRecords <= 0)
      return;
    let newsize = CustomYSensor._MaxDataRecords * 90 / 100 >> 0;
    if (this.previewMinData != null && CustomYSensor._MaxDataRecords < this.previewMinData.length) {
      this.previewMinData.splice(0, this.previewMinData.length - newsize);
      this.previewCurData.splice(0, this.previewCurData.length - newsize);
      this.previewMaxData.splice(0, this.previewMaxData.length - newsize);
    }
  }
  stopDataloggerloading() {
  }
  isOnline() {
    return this._online;
  }
  async reloadConfig() {
    if (this._online) {
      let ison = await this.sensor.isOnline();
      if (ison) {
        try {
          this.unit = await this.sensor.get_unit();
          this._friendlyname = await this.sensor.get_friendlyName();
          this.resolution = await this.sensor.get_resolution();
          this._frequency = await this.sensor.get_reportFrequency();
          this._readonly = await this.sensor.isReadOnly();
          if (this.dataLoggerFeature) {
            this._recording = await this.sensor.get_logFrequency() != "OFF";
          } else {
            this._recording = false;
          }
          this.lastGetConfig = YAPI.GetTickCount();
          this.mustReloadConfig = false;
        } catch (e) {
          logForm.log("reload configuration error: " + e.message);
        }
      } else {
        this._online = false;
      }
    }
  }
  get_unit() {
    if (this.cfgChgNotificationsSupported && !this.mustReloadConfig)
      return this.unit;
    if (this.lastGetConfig <= 0 || YAPI.GetTickCount() - this.lastGetConfig > 5e3)
      this.reloadConfig().then();
    return this.unit;
  }
  get_resolution() {
    if (this.cfgChgNotificationsSupported && !this.mustReloadConfig)
      return this.resolution;
    if (this.lastGetConfig <= 0 || YAPI.GetTickCount() - this.lastGetConfig > 5e3)
      this.reloadConfig().then();
    return this.resolution;
  }
  resetDataloggerLoader() {
    this._predloadProcessIsBusy = false;
    this._loadProcessIsBusy = false;
    this.dataLoggerLoadCompleted = false;
    this.preloadDone = false;
    this.loadDone = false;
    this._dataloggerLoadisRunning = false;
    this.previewMinData = [];
    this.previewCurData = [];
    this.previewMaxData = [];
  }
  loadDatalogger(start, stop) {
    if (!this.dataLoggerFeature)
      return;
    if (this._predloadProcessIsBusy)
      return;
    if (this._loadProcessIsBusy)
      return;
    if (constants.maxPointsPerDataloggerSerie < 0) {
      logForm.log(this.hwdName + " : datalogger access is disabled");
      return;
    }
    if (!this.preloadDone && this.dataLoggerFeature) {
      logForm.log(this.hwdName + " : start datalogger preloading");
      this.preload_DoWork(new DataLoggerBoundary(start, stop)).then();
    }
  }
  async arrival(dataloggerOn) {
    await this.configureSensor();
    this._online = true;
    await this.reloadConfig();
    let dt = await this.sensor.get_dataLogger();
    if (dt == null)
      return;
    let now = Math.floor(new Date().getTime() / 1e3);
    if (this.curData.length > 0 && this.dataLoggerLoadCompleted) {
      let end = await dt.get_timeUTC();
      let start = this.curData[this.curData.length - 1].DateTime;
      let duration = end - start;
      if (duration == 0) {
        start = this.curData[this.curData.length - 2].DateTime;
        duration = end - start;
      }
      if (duration > 1) {
        logForm.log(this.hwdName + " is back online trying to load " + duration.toFixed(3) + " sec of data from datalogger ");
        this.resetDataloggerLoader();
        this.loadDatalogger(start, end);
      }
    }
    if (this.isReadOnly)
      logForm.log(this.hwdName + " is read only");
    this.notifySensorStateChange();
    this.notifySensorArrival();
  }
  async startDataloggerload(source) {
    if (!this.dataLoggerFeature)
      return;
    if (this.sensor == null)
      return;
    if (this._loadProcessIsBusy)
      return;
    if (this._predloadProcessIsBusy)
      return;
    if (this.dataLoggerLoadCompleted) {
      source.DataloggerCompleted(this);
      return;
    }
    let dt = await this.sensor.get_dataLogger();
    if (dt == null)
      return;
    this.loadDatalogger(0, await dt.get_timeUTC());
  }
  notifySensorArrival() {
    for (let i = 0; i < this.FormsToNotify.length; i++) {
      this.FormsToNotify[i].SensorArrivalcallback(this);
    }
  }
  notifySensorStateChange() {
    for (let i = 0; i < this.FormsToNotify.length; i++) {
      this.FormsToNotify[i].SensorStateChangedcallback(this);
    }
  }
  removal() {
    this._online = false;
    this.forceUpdate();
    this.notifySensorStateChange();
  }
  async configureSensor() {
    logForm.log("Configuring  " + this.hwdName);
    if (!await this.sensor.isOnline())
      return;
    let mustSave = false;
    let olfreq = await this.sensor.get_logFrequency();
    let orfreq = await this.sensor.get_reportFrequency();
    let readOnly = await this.sensor.isReadOnly();
    let lfreq = olfreq;
    let rfreq = orfreq;
    let m = await this.sensor.get_module();
    for (let i = 0; i < await m.functionCount(); i++) {
      if (await m.functionType(i) == "DataLogger") {
        this.dataLoggerFeature = true;
      }
    }
    try {
      if (this.dataLoggerFeature) {
        let m2 = await this.sensor.get_module();
        let dl = YDataLogger.FindDataLogger(await m2.get_serialNumber() + ".dataLogger");
        let dataloggerOn = await dl.get_recording() != YDataLogger.RECORDING_OFF;
        let dataloggerAS = await dl.get_autoStart() != YDataLogger.AUTOSTART_OFF;
        if (!dataloggerOn) {
          lfreq = "OFF";
        }
        if (lfreq != "OFF") {
          rfreq = lfreq;
        } else if (rfreq == "OFF") {
          rfreq = "1/s";
        }
        if (lfreq != olfreq) {
          if (readOnly)
            throw new Error(this.hwdName + " is read only, cannot change its logFrequency from " + olfreq + " to " + lfreq);
          await this.sensor.set_logFrequency(lfreq);
          mustSave = true;
        }
        if (rfreq != orfreq) {
          if (readOnly)
            throw new Error(this.hwdName + " is read only, connot change its  reportFrequency from " + orfreq + " to " + rfreq);
          await this.sensor.set_reportFrequency(rfreq);
          mustSave = true;
        }
        if (lfreq != "OFF") {
          if (!dataloggerOn) {
            if (readOnly)
              throw new Error(this.hwdName + " is read only, cannot change set its  datalogger recording to ON");
            await dl.set_recording(YDataLogger.RECORDING_ON);
          }
          if (!dataloggerAS) {
            if (readOnly)
              throw new Error(this.hwdName + " is read only, cannot change set its datalogger autostart to ON");
            await dl.set_autoStart(YDataLogger.AUTOSTART_ON);
            mustSave = true;
          }
        }
      } else {
        lfreq = "OFF";
        if (rfreq == "OFF") {
          rfreq = "1/s";
          if (readOnly)
            throw new Error(this.hwdName + " is read only, connot change is reportFrequency from OFF to " + rfreq);
          await this.sensor.set_reportFrequency(rfreq);
          mustSave = true;
        }
      }
      if (mustSave)
        await m.saveToFlash();
    } catch (e) {
      logForm.log("failed to configure " + this.hwdName + "  (" + e.message + ")");
    }
    logForm.log("registering timed callback for  " + await this.sensor.get_hardwareId());
    await this.sensor.registerTimedReportCallback((callbacksource, M) => {
      this.TimedCallback(callbacksource, M);
    });
    this._recording = lfreq != "OFF";
    this._frequency = rfreq;
  }
  registerCallback(f) {
    if (this.FormsToNotify.indexOf(f) >= 0)
      return;
    this.FormsToNotify.push(f);
    return;
  }
  forceUpdate() {
    this.TimedCallback(this.sensor, null).then();
  }
  async TimedCallback(source, M) {
    this._online = true;
    if (M != null) {
      let t = M.get_endTimeUTC();
      if (this.firstLiveDataTimeStamp == 0)
        this.firstLiveDataTimeStamp = t;
      if (t > this.lastDataTimeStamp) {
        this.lastDataTimeStamp = t;
        this.lastDataSource = "last timedReport";
        this.consecutiveBadTimeStamp = 0;
      } else {
        this.consecutiveBadTimeStamp++;
        if (this.consecutiveBadTimeStamp < 10) {
          logForm.log(this.hwdName + ": ignoring bad timestamp " + t.toFixed(3) + " (previous " + this.lastDataSource + " at " + this.lastDataTimeStamp.toFixed(3) + ")");
        }
      }
      if (this.consecutiveBadTimeStamp == 0 || this.consecutiveBadTimeStamp >= 10) {
        this._lastAvgValue = M.get_averageValue();
        this._lastMinValue = M.get_minValue();
        this._lastMaxValue = M.get_maxValue();
        this.curData.push(new TimedSensorValue(t, this._lastAvgValue));
        this.minData.push(new TimedSensorValue(t, this._lastMinValue));
        this.maxData.push(new TimedSensorValue(t, this._lastMaxValue));
        if (CustomYSensor._MaxDataRecords > 0)
          this.dataCleanUp();
      }
      for (let i = 0; i < this.Alarms.length; i++) {
        this.Alarms[i].check(M);
      }
      for (let i = 0; i < this.FormsToNotify.length; i++) {
        this.FormsToNotify[i].SensorValuecallback(this, M);
      }
    }
  }
  forgetForm(source) {
    for (let i = this.FormsToNotify.length - 1; i >= 0; i--) {
      if (source == this.FormsToNotify[i]) {
        this.FormsToNotify.splice(i, 1);
      }
    }
  }
  get_sensor() {
    return this.sensor;
  }
  get_hardwareId() {
    return this.hwdName;
  }
  get_friendlyName() {
    return this._friendlyname;
  }
  toString() {
    let name = this._friendlyname;
    if (this._readonly)
      name += " (readonly)";
    if (this._online)
      return name;
    return name + " (OFFLINE)";
  }
};
CustomYSensor._MaxDataRecords = 0;
CustomYSensor._MaxLoggerRecords = 0;
var NullYSensor = class extends CustomYSensor {
  constructor() {
    super(null, "", null);
    this.hwdName = "NOTAREALSENSOR";
    this._friendlyname = "NOTAREALSENSOR";
    this.dataLoggerFeature = false;
  }
  async preload_DoWork(arg) {
    return;
  }
  get dataloggerLoadisRunning() {
    return false;
  }
  get_unit() {
    return "";
  }
  registerCallback(Form) {
  }
  forceUpdate() {
  }
  get_frequency() {
    return "";
  }
  set_frequency(frequencyToSet) {
  }
  get_sensor() {
    return null;
  }
  toString() {
    return "(none)";
  }
  setAlarmCondition(index, condition) {
  }
  getAlarmCondition(index) {
    return 0;
  }
  setAlarmValue(index, value) {
  }
  getAlarmValue(index) {
    return 0;
  }
  setAlarmDelay(index, value) {
  }
  getAlarmDelay(index) {
    return 0;
  }
  setAlarmCommandline(index, value) {
  }
  getAlarmCommandline(index) {
    return "";
  }
};
var sensorsManager = class {
  static async clearHublist() {
    for (let i = sensorsManager._hubList.length - 1; i >= 0; i--) {
      if (sensorsManager._hubList[i].removable) {
        await YAPI.UnregisterHub(sensorsManager._hubList[i].get_fullUrl());
        sensorsManager._hubList.splice(i, 1);
      }
    }
  }
  static registerChangeCallback(changeCallback) {
    this._changeCallback = changeCallback;
  }
  static registerChangeExternalCallback(changeCallback) {
    this._changeExternalCallback = changeCallback;
  }
  static forgetForm(source) {
    for (let i = 0; i < sensorsManager.sensorList.length; i++) {
      sensorsManager.sensorList[i].forgetForm(source);
    }
  }
  static InitHubList(node) {
    let nodes = node.get_childsByIndex();
    for (let i = 0; i < nodes.length; i++) {
      if (nodes[i].Name.toUpperCase() == "HUB") {
        let h = Hub.HubFromXml(nodes[i]);
        let alreadthere = false;
        for (let j = 0; j < sensorsManager._hubList.length; j++) {
          if (h.get_connexionUrl() == sensorsManager._hubList[j].get_connexionUrl())
            alreadthere = true;
        }
        if (!alreadthere) {
          sensorsManager._hubList.push(h);
          h.Connect().then();
        }
      }
    }
  }
  static get hubList() {
    return sensorsManager._hubList;
  }
  static hubWasremoved(h) {
    for (let i = sensorsManager._hubList.length - 1; i >= 0; i--) {
      if (sensorsManager._hubList[i] == h)
        sensorsManager._hubList.splice(i, 1);
    }
  }
  static newHubCreated(h) {
    let url = h.get_connexionUrl();
    for (let i = 0; i < sensorsManager._hubList.length; i++) {
      if (sensorsManager._hubList[i].get_connexionUrl() == url) {
        alert("This connection already exists");
        return false;
      }
    }
    sensorsManager._hubList.push(h);
    return true;
  }
  static removeExtraInfoFromUrl(url) {
    let it = new URL(url);
    let res = it.hostname + it.pathname;
    if (res.slice(0, 4).toLowerCase() === "www.") {
      res = res.slice(4);
    }
    return res;
  }
  static async NetworkArrival(net) {
    logForm.log("Network device detected: " + await net.get_hardwareId());
    let ip = await net.get_ipAddress();
    let netname = await net.get_logicalName();
    let module = await net.get_module();
    let loginame = await module.get_logicalName();
    let url = sensorsManager.removeExtraInfoFromUrl(await module.get_url());
    for (let i = 0; i < sensorsManager._hubList.length; i++) {
      let str = sensorsManager.removeExtraInfoFromUrl(sensorsManager.hubList[i].get_fullUrl());
      if (str == url) {
        sensorsManager.hubList[i].arrival(ip, netname, module, loginame);
      }
    }
  }
  static getXmlHublist() {
    let res = "";
    for (let i = 0; i < sensorsManager._hubList.length; i++) {
      res += "    " + sensorsManager._hubList[i].XmlCode() + "\n";
    }
    return res;
  }
  static getXMLSensorsConfig() {
    let res = "<Sensors>\n";
    sensorsManager.sensorList.forEach((s) => {
      if (!(s instanceof NullYSensor)) {
        res = res + s.GetXmlData();
      }
    });
    res = res + "</Sensors>\n";
    return res;
  }
  static setKnownSensors(sensorXMLList) {
    this.KnownSensors = sensorXMLList;
  }
  static FindSensorLastLocalConfig(hwdId) {
    let SensorConfig = null;
    if (sensorsManager.KnownSensors != null) {
      let childs = sensorsManager.KnownSensors.get_childsByIndex();
      for (let i = 0; i < childs.length; i++) {
        let node = childs[i];
        if (node.Name == "Sensor") {
          let id = node.get_attributes()["ID"];
          if (id == hwdId) {
            SensorConfig = node;
          }
        }
      }
    }
    return SensorConfig;
  }
  static async deviceConfigChanged(m) {
    logForm.log("Configuration change on device  " + await m.get_serialNumber());
    let serialprefix = (await m.get_serialNumber()).substring(0, 8);
    for (let i = 0; i < sensorsManager.sensorList.length; i++) {
      if (sensorsManager.sensorList[i].get_hardwareId().substring(0, 8) == serialprefix) {
        await sensorsManager.sensorList[i].ConfigHasChanged();
      }
    }
    if (sensorsManager._changeCallback != null)
      sensorsManager._changeCallback();
    if (sensorsManager._changeExternalCallback != null) {
      let data = await sensorsManager._changeExternalCallback(m);
      if (data != null)
        YWebPage.ConfigChanged(data);
    }
  }
  static async deviceArrival(m) {
    try {
      let count = await m.functionCount();
      let serial = await m.get_serialNumber();
      let luminosity = await m.get_luminosity();
      logForm.log("Device Arrival " + serial);
      let recording = false;
      for (let i = 0; i < count; i++) {
        let ftype = await m.functionType(i);
        let fid = await m.functionId(i);
        if (ftype == "Network") {
          let net = await YNetwork.FindNetwork(serial + "." + fid);
          await sensorsManager.NetworkArrival(net);
        } else if (ftype == "DataLogger") {
          let dlog = YDataLogger.FindDataLogger(serial + "." + fid);
          let state = await dlog.get_recording();
          if (state == YDataLogger.RECORDING_ON || state == YDataLogger.RECORDING_PENDING) {
            recording = true;
          }
        }
      }
      for (let i = 0; i < count; i++) {
        let fbasetype = await m.functionBaseType(i);
        let fid = await m.functionId(i);
        if (fbasetype == "Sensor") {
          let hwdID = serial + "." + fid;
          logForm.log("New sensor arrival: " + hwdID);
          let found = false;
          for (let j = 0; j < sensorsManager.sensorList.length && !found; j++) {
            if (sensorsManager.sensorList[j].get_hardwareId() == hwdID) {
              found = true;
              await sensorsManager.sensorList[j].arrival(recording);
            }
          }
          if (!found) {
            let s = YSensor.FindSensor(hwdID);
            let hwd = await s.get_hardwareId();
            let cs = new CustomYSensor(s, hwd, sensorsManager.FindSensorLastLocalConfig(hwd));
            sensorsManager.sensorList.push(cs);
            await cs.configureSensor();
            YWebPage.refreshEditor();
            cs.notifySensorStateChange();
          }
        }
      }
      await m.registerConfigChangeCallback(sensorsManager.deviceConfigChanged);
      setTimeout(() => {
        sensorsManager.deviceConfigChanged(m);
      }, 100);
      if (sensorsManager._changeCallback != null)
        sensorsManager._changeCallback();
    } catch (e) {
      logForm.log("Device Arrival Error: " + e.message);
    }
  }
  static async deviceRemoval(m) {
    let serial = await m.get_serialNumber();
    logForm.log("Device removal " + serial);
    sensorsManager.sensorList.forEach((alreadyThereSensor) => {
      if (!(alreadyThereSensor instanceof NullYSensor)) {
        let hwd = alreadyThereSensor.get_hardwareId();
        if (hwd.length >= serial.length) {
          if (hwd.substring(0, serial.length) == serial) {
            alreadyThereSensor.removal();
          }
        }
      }
    });
    if (sensorsManager._changeCallback != null)
      sensorsManager._changeCallback();
  }
  static AddNewSensor(hwdID) {
    for (let i = 0; i < sensorsManager.sensorList.length; i++) {
      if (sensorsManager.sensorList[i] != null) {
        if (sensorsManager.sensorList[i].get_hardwareId() == hwdID)
          return sensorsManager.sensorList[i];
      }
    }
    let s = YSensor.FindSensor(hwdID);
    let cs = new CustomYSensor(s, hwdID, sensorsManager.FindSensorLastLocalConfig(hwdID));
    sensorsManager.sensorList.push(cs);
    return cs;
  }
  static getNullSensor() {
    return sensorsManager.NullSensor;
  }
  static async UpdateDeviceList() {
    let err = new YErrorMsg();
    try {
      if (await YAPI.UpdateDeviceList(err) != YAPI_SUCCESS) {
        logForm.log("UpdateDeviceList failed :" + err.msg);
      }
    } catch (e) {
      logForm.log("UpdateDeviceList failed :" + e.errorMsg);
    }
  }
  static async _runAsync() {
    let errmsg = new YErrorMsg();
    await YAPI.RegisterDeviceArrivalCallback((m) => {
      sensorsManager.deviceArrival(m);
    });
    await YAPI.RegisterDeviceRemovalCallback((m) => {
      sensorsManager.deviceRemoval(m);
    });
    await sensorsManager.UpdateDeviceList();
    setInterval(() => {
      sensorsManager.UpdateDeviceList();
    }, 2e3);
  }
  static run() {
    sensorsManager.NullSensor = new NullYSensor();
    sensorsManager.sensorList = [];
    sensorsManager.sensorList.push(sensorsManager.NullSensor);
    this._runAsync().then();
  }
};
sensorsManager.counter = 0;
sensorsManager.KnownSensors = null;
sensorsManager._hubList = [];
sensorsManager._changeCallback = null;
sensorsManager._changeExternalCallback = null;

// obj/full/formManager.js
var ResizeMoveHandle = class {
  constructor(container, index, mouseDownListener, touchStartlistener) {
    this.index = index;
    this.container = container;
    this.isactive = false;
    this.div = document.createElement("DIV");
    let size = ResizeMoveHandle.HANDLESIZE - 2;
    if (this.index == ResizeMoveHandle.RESIZEHANDLE_CENTER)
      size = size * 2;
    this.div.style.position = "absolute";
    this.div.style.border = "0px solid black";
    this.div.style.background = "transparent";
    this.div.style.pointerEvents = "auto";
    this.div.style.width = size.toString() + "px";
    this.div.style.height = size.toString() + "px";
    switch (index) {
      case ResizeMoveHandle.RESIZEHANDLE_TOPLEFT:
        this.div.style.cursor = "nw-resize";
        this.div.style.left = "0px";
        this.div.style.top = "0px";
        break;
      case ResizeMoveHandle.RESIZEHANDLE_TOPCENTER:
        this.div.style.cursor = "n-resize";
        this.div.style.top = "0px";
        this.div.style.left = "50%";
        this.div.style.transform = "translate(-50%,0)";
        break;
      case ResizeMoveHandle.RESIZEHANDLE_TOPRIGHT:
        this.div.style.cursor = "ne-resize";
        this.div.style.right = "0px";
        this.div.style.top = "0px";
        break;
      case ResizeMoveHandle.RESIZEHANDLE_CENTERRIGHT:
        this.div.style.cursor = "e-resize";
        this.div.style.right = "0px";
        this.div.style.top = "50%";
        this.div.style.transform = "translate(0,-50%)";
        break;
      case ResizeMoveHandle.RESIZEHANDLE_BOTTOMRIGHT:
        this.div.style.cursor = "se-resize";
        this.div.style.right = "0px";
        this.div.style.bottom = "0px";
        break;
      case ResizeMoveHandle.RESIZEHANDLE_BOTTOMCENTER:
        this.div.style.cursor = "s-resize";
        this.div.style.bottom = "0px";
        this.div.style.left = "50%";
        this.div.style.transform = "translate(-50%,0)";
        break;
      case ResizeMoveHandle.RESIZEHANDLE_BOTTOMLEFT:
        this.div.style.cursor = "sw-resize";
        this.div.style.left = "0px";
        this.div.style.bottom = "0px";
        break;
      case ResizeMoveHandle.RESIZEHANDLE_CENTERLEFT:
        this.div.style.cursor = "w-resize";
        this.div.style.left = "0px";
        this.div.style.top = "50%";
        this.div.style.transform = "translate(0,-50%)";
        break;
      case ResizeMoveHandle.RESIZEHANDLE_CENTER:
        this.div.style.cursor = "move";
        this.div.style.left = "50%";
        this.div.style.top = "50%";
        this.div.style.transform = "translate(-50%,-50%)";
        break;
    }
    this.container.appendChild(this.div);
    this.div.addEventListener("mousedown", mouseDownListener);
    this.div.addEventListener("touchstart", touchStartlistener);
    this.svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    this.svg.setAttribute("viewBox", "0 0 " + size + " " + size);
    this.svg.setAttribute("version", "1.1");
    this.svg.setAttribute("width", size.toString());
    this.svg.setAttribute("height", size.toString());
    let x = 0;
    let y = 0;
    let r = size;
    switch (this.index) {
      case ResizeMoveHandle.RESIZEHANDLE_TOPLEFT:
        break;
      case ResizeMoveHandle.RESIZEHANDLE_TOPCENTER:
        x = size / 2;
        break;
      case ResizeMoveHandle.RESIZEHANDLE_TOPRIGHT:
        x = size;
        break;
      case ResizeMoveHandle.RESIZEHANDLE_CENTERRIGHT:
        x = size;
        y = size / 2;
        break;
      case ResizeMoveHandle.RESIZEHANDLE_BOTTOMRIGHT:
        x = size;
        y = size;
        break;
      case ResizeMoveHandle.RESIZEHANDLE_BOTTOMCENTER:
        x = size / 2;
        y = size;
        break;
      case ResizeMoveHandle.RESIZEHANDLE_BOTTOMLEFT:
        y = size;
        break;
      case ResizeMoveHandle.RESIZEHANDLE_CENTERLEFT:
        y = size / 2;
        break;
      case ResizeMoveHandle.RESIZEHANDLE_CENTER:
        x = size / 2;
        y = size / 2;
        r = size / 2;
        break;
    }
    this.circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
    this.circle.setAttribute("cx", x.toString());
    this.circle.setAttribute("cy", y.toString());
    this.circle.setAttribute("r", r.toString());
    this.circle.setAttribute("style", "fill:white");
    this.circle.setAttribute("opacity", "0.75");
    this.svg.appendChild(this.circle);
    this.arrow = document.createElementNS("http://www.w3.org/2000/svg", "path");
    let d = "";
    for (let i = 0; i < ResizeMoveHandle.RESIZEHANDLE_data[index].length >> 1; i++) {
      let x2 = 1 + (size - 2) * ResizeMoveHandle.RESIZEHANDLE_data[index][i << 1] / 12;
      let y2 = 1 + (size - 2) * ResizeMoveHandle.RESIZEHANDLE_data[index][1 + (i << 1)] / 12;
      d += i == 0 ? "M " : "L ";
      d += Math.round(x2).toString() + " " + Math.round(y2).toString() + " ";
    }
    d += "z";
    this.arrow.setAttribute("d", d);
    this.arrow.setAttribute("fill", ResizeMoveHandle.inactiveColor);
    this.svg.appendChild(this.arrow);
    this.div.appendChild(this.svg);
    this.container.appendChild(this.div);
  }
  get active() {
    return this.isactive;
  }
  set active(value) {
    if (value != this.isactive) {
      this.isactive = value;
      this.arrow.setAttribute("fill", this.active ? ResizeMoveHandle.activeColor : ResizeMoveHandle.inactiveColor);
    }
  }
};
ResizeMoveHandle.HANDLESIZE = Math.round(20 * (1 + 2 * (constants.guiDPIFactor - 1)));
ResizeMoveHandle.activeColor = "lightgreen";
ResizeMoveHandle.inactiveColor = "grey";
ResizeMoveHandle.RESIZEHANDLE_TOPLEFT = 0;
ResizeMoveHandle.RESIZEHANDLE_TOPCENTER = 1;
ResizeMoveHandle.RESIZEHANDLE_TOPRIGHT = 2;
ResizeMoveHandle.RESIZEHANDLE_CENTERRIGHT = 3;
ResizeMoveHandle.RESIZEHANDLE_BOTTOMRIGHT = 4;
ResizeMoveHandle.RESIZEHANDLE_BOTTOMCENTER = 5;
ResizeMoveHandle.RESIZEHANDLE_BOTTOMLEFT = 6;
ResizeMoveHandle.RESIZEHANDLE_CENTERLEFT = 7;
ResizeMoveHandle.RESIZEHANDLE_CENTER = 8;
ResizeMoveHandle.RESIZEHANDLE_data = [
  [0, 0, 0, 7, 2, 5, 7, 10, 10, 7, 5, 2, 7, 0],
  [6, 0, 11, 5, 8, 5, 8, 12, 4, 12, 4, 5, 1, 5],
  [12, 0, 12, 7, 10, 5, 5, 10, 2, 7, 7, 2, 5, 0],
  [12, 6, 7, 11, 7, 8, 0, 8, 0, 4, 7, 4, 7, 1],
  [12, 12, 5, 12, 7, 10, 2, 5, 5, 2, 10, 7, 12, 5],
  [6, 12, 1, 7, 4, 7, 4, 0, 8, 0, 8, 7, 11, 7],
  [0, 12, 0, 5, 2, 7, 7, 2, 10, 5, 5, 10, 7, 12],
  [0, 6, 5, 1, 5, 4, 12, 4, 12, 8, 5, 8, 5, 11],
  [
    6,
    0,
    8,
    2,
    7,
    2,
    7,
    5,
    10,
    5,
    10,
    4,
    12,
    6,
    10,
    8,
    10,
    7,
    7,
    7,
    7,
    10,
    8,
    10,
    6,
    12,
    4,
    10,
    5,
    10,
    5,
    7,
    2,
    7,
    2,
    8,
    0,
    6,
    2,
    4,
    2,
    5,
    5,
    5,
    5,
    2,
    4,
    2
  ]
];
var YWidget = class {
  constructor(node, editor, default_x, default_y, default_width, default_height) {
    this._genProp = null;
    this._genRenderer = null;
    this._BackColor = YColor.Transparent;
    this._BorderColor = YColor.Gray;
    this._relativePositionX = 0;
    this._relativePositionY = 0;
    this._PositionX = 0;
    this._PositionY = 0;
    this._relativeWidth = 100;
    this._relativeHeight = 100;
    this._Width = 300;
    this._Height = 0;
    this._InitialSizeIsRelative = false;
    this._SizeIsRelative = false;
    this._initialContainerID = "";
    this._containerID = "";
    this._Text = "";
    this.resizeCaptureRunning = false;
    this.resizeCaptureXOrigineMouse = 0;
    this.resizeCaptureYOrigineMouse = 0;
    this.resizeCaptureXOrigine = 0;
    this.resizeCaptureYOrigine = 0;
    this.resizeCaptureOriginalTop = 0;
    this.resizeCaptureOriginalLeft = 0;
    this.resizeCaptureOriginalWidth = 0;
    this.resizeCaptureOriginalHeight = 0;
    this.resizeCaptureHandleIndex = 0;
    this.resizeCaptureOriginalMatrix = null;
    this.resizeCaptureOriginalMatrixInv = null;
    this.previousTRansform = "";
    this.previousWidth = 0;
    this.previousHeight = 0;
    let left = typeof default_x != "undefined" ? default_x : 0;
    let top2 = typeof default_y != "undefined" ? default_y : 0;
    let width = typeof default_width != "undefined" ? default_width : 0;
    let height = typeof default_height != "undefined" ? default_height : 0;
    let bottom = Number.NaN;
    let right = Number.NaN;
    if (node != null) {
      let childnodes = node.get_childsByName();
      if ("location" in childnodes) {
        let it = childnodes["location"];
        let attributes = it.get_attributes();
        if ("x" in attributes)
          left = parseInt(attributes["x"]);
        if ("y" in attributes)
          top2 = parseInt(attributes["y"]);
      }
      if ("size" in childnodes) {
        let it = childnodes["size"];
        let attributes = it.get_attributes();
        if ("w" in attributes)
          width = parseInt(attributes["w"]);
        if ("h" in attributes)
          height = parseInt(attributes["h"]);
      }
      if ("relativeCoord" in childnodes) {
        let it = childnodes["relativeCoord"];
        let attributes = it.get_attributes();
        if ("x" in attributes)
          this._relativePositionX = this.sizeRound(parseFloat(attributes["x"]));
        if ("y" in attributes)
          this._relativePositionY = this.sizeRound(parseFloat(attributes["y"]));
        if ("w" in attributes)
          this._relativeWidth = this.sizeRound(parseFloat(attributes["w"]));
        if ("h" in attributes)
          this._relativeHeight = this.sizeRound(parseFloat(attributes["h"]));
        if ("active" in attributes)
          this._InitialSizeIsRelative = attributes["active"].toUpperCase() == "TRUE";
      }
      if ("container" in childnodes) {
        let it = childnodes["container"];
        let attributes = it.get_attributes();
        if ("id" in attributes)
          this._initialContainerID = attributes["id"];
      }
    }
    this.UIContainer = document.createElement("CANVAS");
    this.UIContainer.style.position = "absolute";
    YWidget.currentEdited = null;
    let h = window.innerHeight;
    let w = window.innerWidth;
    this.PositionX = this._InitialSizeIsRelative ? Math.round(w * (this._relativePositionX / 100)) : left;
    this.PositionY = this._InitialSizeIsRelative ? Math.round(h * (this._relativePositionY / 100)) : top2;
    this.Width = this._InitialSizeIsRelative ? Math.round(w * (this._relativeWidth / 100)) : width;
    this.Height = this._InitialSizeIsRelative ? Math.round(h * (this._relativeHeight / 100)) : height;
    this.UIContainer.style.border = "1px solid black";
    this.UIContainer.style.backgroundColor = this._BackColor.htmlCode;
    this.UIContainer.setAttribute("name", "YoctoVisualizationWidget");
    document.body.appendChild(this.UIContainer);
    this._windowResizeCallback = () => this.windowResized();
    window.addEventListener("resize", this._windowResizeCallback);
  }
  static log(st) {
    logForm.log(st);
  }
  SourceChanged(src, index) {
  }
  loadRecordedDataIfNeeded() {
  }
  removeDataloggerData() {
  }
  delete() {
    this.editStopped();
    sensorsManager.forgetForm(this);
    this.destroy();
  }
  get confirmDeleteString() {
    return "not defined";
  }
  snapshot() {
    let w = 1024;
    let h = 1024;
    let ratio = this.UIContainer.offsetHeight != 0 ? this.UIContainer.offsetWidth / this.UIContainer.offsetHeight : 1;
    switch (constants.captureSizePolicy) {
      case YDataRenderer.CaptureFormats.Keep:
        w = this.UIContainer.offsetWidth;
        h = this.UIContainer.offsetHeight;
        break;
      case YDataRenderer.CaptureFormats.FixedHeight:
        h = constants.captureHeight;
        w = h * ratio;
        break;
      case YDataRenderer.CaptureFormats.FixedWidth:
        w = constants.captureWidth;
        h = w / ratio;
        break;
      case YDataRenderer.CaptureFormats.Fixed:
        w = constants.captureWidth;
        h = constants.captureHeight;
        break;
    }
    this._genRenderer.captureAndDownloadImage(constants.captureType, "", w, h, constants.captureDPI);
  }
  get BackColor() {
    return this._BackColor;
  }
  set BackColor(value) {
    this._BackColor = value;
    this.UIContainer.style.backgroundColor = this._BackColor.htmlCode;
  }
  get BorderColor() {
    return this._BorderColor;
  }
  set BorderColor(value) {
    this._BorderColor = value;
    this.UIContainer.style.border = "1px solid " + this._BorderColor.htmlCode;
  }
  get parentWidth() {
    if (this.UIContainer.parentNode == document.body || this.UIContainer.parentNode == null)
      return window.innerWidth;
    return this.UIContainer.parentNode.clientWidth;
  }
  get parentHeight() {
    if (this.UIContainer.parentNode == document.body || this.UIContainer.parentNode == null)
      return window.innerHeight;
    return this.UIContainer.parentNode.clientHeight;
  }
  get relativePositionX() {
    if (this._SizeIsRelative)
      return this._relativePositionX;
    return this.sizeRound(100 * this.UIContainer.offsetLeft / this.parentWidth);
  }
  set relativePositionX(value) {
    this._relativePositionX = value;
    this._PositionX = Math.round(value * this.parentWidth / 100);
  }
  set relativePositionY(value) {
    this._relativePositionY = value;
    this._PositionY = Math.round(value * this.parentHeight / 100);
  }
  get relativePositionY() {
    if (this._SizeIsRelative)
      return this._relativePositionY;
    return this.sizeRound(100 * this.UIContainer.offsetTop / this.parentHeight);
  }
  get PositionX() {
    if (this._SizeIsRelative)
      return this.relativePositionX;
    return this.UIContainer.offsetLeft;
  }
  set PositionX(value) {
    if (this._SizeIsRelative)
      this.relativePositionX = value;
    else
      this._PositionX = value;
    this.UIContainer.style.left = this._PositionX.toString() + "px";
    if (this._genRenderer != null)
      this._genRenderer.clearTransformationMatrix();
    this.DrawHandles(this.UIContainer.offsetLeft, this.UIContainer.offsetTop, this.UIContainer.offsetWidth, this.UIContainer.offsetHeight);
  }
  get PositionY() {
    if (this._SizeIsRelative)
      return this.relativePositionY;
    return this.UIContainer.offsetTop;
  }
  set PositionY(value) {
    if (this._SizeIsRelative)
      this.relativePositionY = value;
    else
      this._PositionY = value;
    this.UIContainer.style.top = this._PositionY.toString() + "px";
    if (this._genRenderer != null)
      this._genRenderer.clearTransformationMatrix();
    this.DrawHandles(this.UIContainer.offsetLeft, this.UIContainer.offsetTop, this.UIContainer.offsetWidth, this.UIContainer.offsetHeight);
  }
  sizeRound(v) {
    return Math.round(100 * v) / 100;
  }
  get relativeWidth() {
    if (this._SizeIsRelative)
      return this._relativeWidth;
    return this.sizeRound(100 * this.UIContainer.offsetWidth / this.parentWidth);
  }
  set relativeWidth(value) {
    if (value <= 0)
      throw "Value must be strictly positive";
    this._relativeWidth = value;
    this._Width = Math.round(value * this.parentWidth / 100);
  }
  set relativeHeight(value) {
    if (value <= 0)
      throw "Value must be strictly positive";
    this._relativeHeight = value;
    this._Height = Math.round(value * this.parentHeight / 100);
  }
  get relativeHeight() {
    if (this._SizeIsRelative)
      return this._relativeHeight;
    return this.sizeRound(100 * this.UIContainer.offsetHeight / this.parentHeight);
  }
  updateRelativeSize() {
    if (Math.abs(this._relativeWidth * this.parentWidth / 100 - this.UIContainer.offsetWidth) > 1)
      this._relativeWidth = this.sizeRound(100 * this.UIContainer.offsetWidth / this.parentWidth);
    if (Math.abs(this._relativeHeight * this.parentHeight / 100 - this.UIContainer.offsetHeight) > 1)
      this._relativeHeight = this.sizeRound(100 * this.UIContainer.offsetHeight / this.parentHeight);
    if (Math.abs(this._relativePositionX * this.parentWidth / 100 - this.UIContainer.offsetLeft) > 1)
      this._relativePositionX = this.sizeRound(100 * this.UIContainer.offsetLeft / this.parentWidth);
    if (Math.abs(this._relativePositionY * this.parentHeight / 100 - this.UIContainer.offsetTop) > 1)
      this._relativePositionY = this.sizeRound(100 * this.UIContainer.offsetTop / this.parentHeight);
  }
  get Width() {
    if (this._SizeIsRelative)
      return this.relativeWidth;
    else
      return this.UIContainer.offsetWidth;
  }
  set Width(value) {
    if (value <= 0)
      throw "Value must be strictly positive";
    if (this._SizeIsRelative)
      this.relativeWidth = value;
    else
      this._Width = value;
    this.UIContainer.style.width = (this._Width - 2).toString() + "px";
    this.UIContainer.width = this._Width - 2;
    if (this._genRenderer != null)
      this._genRenderer.clearTransformationMatrix();
    this.DrawHandles(this.UIContainer.offsetLeft, this.UIContainer.offsetTop, this.UIContainer.offsetWidth, this.UIContainer.offsetHeight);
    this.containerResized();
  }
  get Height() {
    if (this._SizeIsRelative)
      return this.relativeHeight;
    else
      return this.UIContainer.offsetHeight;
  }
  set Height(value) {
    if (value <= 0)
      throw "Value must be strictly positive";
    if (this._SizeIsRelative)
      this.relativeHeight = value;
    else
      this._Height = value;
    this.UIContainer.style.height = (this._Height - 2).toString() + "px";
    this.UIContainer.height = this._Height - 2;
    if (this._genRenderer != null)
      this._genRenderer.clearTransformationMatrix();
    this.DrawHandles(this.UIContainer.offsetLeft, this.UIContainer.offsetTop, this.UIContainer.offsetWidth, this.UIContainer.offsetHeight);
    this.containerResized();
  }
  get SizeIsRelative() {
    return this._SizeIsRelative;
  }
  set SizeIsRelative(value) {
    if (this._SizeIsRelative != value) {
      this._SizeIsRelative = value;
      if (this._SizeIsRelative) {
        this._relativePositionX = this.sizeRound(100 * this.UIContainer.offsetLeft / this.parentWidth);
        this._relativePositionY = this.sizeRound(100 * this.UIContainer.offsetTop / this.parentHeight);
        this._relativeWidth = this.sizeRound(100 * this.UIContainer.offsetWidth / this.parentWidth);
        this._relativeHeight = this.sizeRound(100 * this.UIContainer.offsetHeight / this.parentHeight);
      }
      this.windowResized();
    }
  }
  get containerID() {
    return this._containerID;
  }
  set containerID(value) {
    if (this._containerID == value)
      return;
    let target = value != "" ? document.getElementById(value) : null;
    if (value != "" && target == null)
      throw "No HTMLElement on the page with such ID (" + value + ")";
    if (this.UIContainer.parentNode != null) {
      this.UIContainer.parentNode.removeChild(this.UIContainer);
    } else {
      document.body.removeChild(this.UIContainer);
    }
    if (target != null) {
      this.UIContainer.style.position = "relative";
      target.insertBefore(this.UIContainer, target.firstChild);
    } else {
      this.UIContainer.style.position = "absolute";
      document.body.insertBefore(this.UIContainer, document.body.firstChild);
    }
    this._genRenderer.clearTransformationMatrix();
    this.windowResized();
    this.DrawHandles(this.UIContainer.offsetLeft, this.UIContainer.offsetTop, this.UIContainer.offsetWidth, this.UIContainer.offsetHeight);
    this._containerID = value;
  }
  get Text() {
    return this._Text;
  }
  set Text(value) {
    this._Text = value;
    this.UIContainer.title = value;
  }
  set_name(name) {
    this.Text = name;
    this._genProp.Form_Text = name;
  }
  windowResized() {
    this._genRenderer.DisableRedraw();
    if (this._SizeIsRelative) {
      this.PositionX = this._relativePositionX;
      this.PositionY = this._relativePositionY;
      this.Height = this._relativeHeight;
      this.Width = this._relativeWidth;
    }
    this.containerResized();
    this._genRenderer.AllowRedraw();
  }
  ApplyRelativeSizeIfRequired() {
    if (this._initialContainerID != "") {
      if (document.getElementById(this._initialContainerID) != null) {
        this.containerID = this._initialContainerID;
      } else {
        logForm.log('Warning: cannot place widget in "' + this._initialContainerID + '" : no such HTML element.');
      }
    }
    this._SizeIsRelative = this._InitialSizeIsRelative;
    this.windowResized();
  }
  destroy() {
    window.removeEventListener("resize", this._windowResizeCallback);
    this._genRenderer.destroy();
    Object.entries(this).forEach((pair) => {
      Reflect.set(this, pair[0], null);
    });
  }
  getContainerOffset() {
    let it = this.UIContainer.offsetParent;
    let absx = 0;
    let absy = 0;
    while (it) {
      absy += it.offsetTop;
      absx += it.offsetLeft;
      it = it.offsetParent;
    }
    return new pointXY(absx, absy);
  }
  contextMenuCallBack(mouseX, mouseY) {
    let p = this._genRenderer.Scr2ElmMatrix.multiplyByV(Vector3.FromXYCoord(mouseX, mouseY)).toPoint();
    if (p.X >= 0 && p.X <= this.UIContainer.offsetWidth && p.Y >= 0 && p.Y <= this.UIContainer.offsetHeight) {
      this.contextMenuIsOpening();
    }
  }
  contextMenuIsOpening() {
  }
  rearrangeZindexes() {
    let containers = document.getElementsByName("YoctoVisualizationWidget");
    let n = 0;
    for (let i = 0; i < containers.length; i++) {
      if (containers[i] != this.UIContainer) {
        containers[i].style.zIndex = n.toString();
        n++;
      }
    }
    this.UIContainer.style.zIndex = n.toString();
    n++;
    YWidget.HandlesDiv.style.zIndex = n.toString();
  }
  SensorArrivalcallback(source) {
  }
  SensorStateChangedcallback(source) {
    if (YWidget.currentEdited == this) {
      YWebPage.refreshEditor();
    }
  }
  SensorValuecallback(source, M) {
  }
  get isBeingEdited() {
    return YWidget.currentEdited == this;
  }
  static stopEdition() {
    if (YWidget.currentEdited != null) {
      YWidget.currentEdited.editStopped();
      YWidget.currentEdited = null;
    }
  }
  refreshProperties() {
  }
  edit() {
    YWidget.stopEdition();
    YWidget.currentEdited = this;
    if (YWidget.editHandles.length <= 0) {
      YWidget.HandlesDiv = document.createElement("DIV");
      YWidget.HandlesDiv.style.position = "absolute";
      YWidget.HandlesDiv.style.left = "0px";
      YWidget.HandlesDiv.style.top = "0px";
      YWidget.HandlesDiv.style.backgroundColor = "transparent";
      YWidget.HandlesDiv.style.transformOrigin = "top left";
      YWidget.HandlesDiv.style.pointerEvents = "none";
      for (let i = 0; i < 9; i++) {
        YWidget.editHandles.push(new ResizeMoveHandle(YWidget.HandlesDiv, i, (e) => {
          if (YWidget.currentEdited != null)
            YWidget.currentEdited.mouseStartCapture(e, i);
        }, (e) => {
          if (YWidget.currentEdited != null) {
            YWidget.currentEdited.touchStartCapture(e, i);
          }
        }));
      }
      document.body.appendChild(YWidget.HandlesDiv);
      document.addEventListener("touchmove", (e) => {
        if (YWidget.currentEdited != null)
          YWidget.currentEdited.touchCaptureRun(e);
      }, {passive: false});
      document.addEventListener("touchend", (e) => {
        if (YWidget.currentEdited != null)
          YWidget.currentEdited.touchCaptureStop(e);
      }, {passive: false});
      document.addEventListener("mousemove", (e) => {
        if (YWidget.currentEdited != null)
          YWidget.currentEdited.mouseCaptureRun(e);
      }, {passive: false});
      document.addEventListener("mouseup", (e) => {
        if (YWidget.currentEdited != null)
          YWidget.currentEdited.mouseCaptureStop(e);
      }, {passive: false});
    }
    this.DrawHandles(this.UIContainer.offsetLeft, this.UIContainer.offsetTop, this.UIContainer.offsetWidth, this.UIContainer.offsetHeight);
    YWidget.HandlesDiv.style.display = "";
    this.rearrangeZindexes();
  }
  DrawHandles(offsetLeft, offsetTop, offsetWidth, offsetHeight) {
    if (YWidget.currentEdited == null)
      return;
    if (YWidget.editHandles.length <= 0)
      return;
    YWidget.HandlesDiv.style.width = offsetWidth.toString() + "px";
    YWidget.HandlesDiv.style.height = offsetHeight.toString() + "px";
    if (this._genRenderer == null)
      debugger;
    let borderWidth = parseFloat(this.UIContainer.style.border);
    let borderMatrix = Matrix3x3.newTranslateMatrix(-borderWidth, -borderWidth);
    YWidget.HandlesDiv.style.transform = borderMatrix.multiplyByM(this._genRenderer.Elm2ScrMatrix).toCSS();
    YWidget.HandlesDiv.style.transform = "top left";
  }
  updateWindowPositionProperties(prop) {
    prop.Form_PositionX = this.PositionX;
    prop.Form_PositionY = this.PositionY;
    prop.Form_Width = this.Width;
    prop.Form_Height = this.Height;
  }
  touchStartCapture(e, handleIndex) {
    if (e.touches.length == 1) {
      this.handleMouseStartCapture(e.touches[0].pageX, e.touches[0].pageY, handleIndex);
      e.preventDefault();
    }
  }
  mouseStartCapture(e, handleIndex) {
    if (e.button != 0)
      return;
    this.handleMouseStartCapture(e.pageX, e.pageY, handleIndex);
  }
  handleMouseStartCapture(pageX, pageY, handleIndex) {
    this.resizeCaptureOriginalMatrix = this._genRenderer.Scr2ElmMatrix;
    this.resizeCaptureOriginalMatrixInv = this._genRenderer.Elm2ScrMatrix;
    let p = this.resizeCaptureOriginalMatrix.multiplyByV(Vector3.FromXYCoord(pageX, pageY)).toPoint();
    this.resizeCaptureRunning = true;
    this.resizeCaptureXOrigine = p.X;
    this.resizeCaptureYOrigine = p.Y;
    this.resizeCaptureOriginalLeft = this.UIContainer.offsetLeft;
    this.resizeCaptureOriginalTop = this.UIContainer.offsetTop;
    this.resizeCaptureOriginalWidth = this.UIContainer.offsetWidth;
    this.resizeCaptureOriginalHeight = this.UIContainer.offsetHeight;
    this.resizeCaptureHandleIndex = handleIndex;
    YWidget.editHandles[this.resizeCaptureHandleIndex].active = true;
    this.previousTRansform = YWidget.HandlesDiv.style.transform;
  }
  touchCaptureRun(e) {
    if (e.touches.length == 1) {
      this.handleCaptureRun(e.touches[0].pageX, e.touches[0].pageY);
      e.preventDefault();
    }
  }
  mouseCaptureRun(e) {
    this.handleCaptureRun(e.pageX, e.pageY);
  }
  handleCaptureRun(pageX, pageY) {
    if (!this.resizeCaptureRunning)
      return;
    let p = this.resizeCaptureOriginalMatrix.multiplyByV(Vector3.FromXYCoord(pageX, pageY)).toPoint();
    let dx = p.X - this.resizeCaptureXOrigine;
    let dy = p.Y - this.resizeCaptureYOrigine;
    let newLeft = this.resizeCaptureOriginalLeft;
    let newTop = this.resizeCaptureOriginalTop;
    let newWidth = this.resizeCaptureOriginalWidth;
    let newHeight = this.resizeCaptureOriginalHeight;
    switch (this.resizeCaptureHandleIndex) {
      case 0:
        newLeft += dx;
        newTop += dy;
        newWidth -= dx;
        newHeight -= dy;
        break;
      case 1:
        newTop += dy;
        newHeight -= dy;
        break;
      case 2:
        newTop += dy;
        newWidth += dx;
        newHeight -= dy;
        break;
      case 3:
        newWidth += dx;
        break;
      case 4:
        newWidth += dx;
        newHeight += dy;
        break;
      case 5:
        newHeight += dy;
        break;
      case 6:
        newLeft += dx;
        newWidth -= dx;
        newHeight += dy;
        break;
      case 7:
        newLeft += dx;
        newWidth -= dx;
        break;
      case 8:
        newLeft += dx;
        newTop += dy;
        break;
    }
    if (newWidth < 2 * YWidget.HANDLESIZE)
      newWidth = 2 * YWidget.HANDLESIZE;
    if (newHeight < 2 * YWidget.HANDLESIZE)
      newHeight = 2 * YWidget.HANDLESIZE;
    this.UIContainer.style.left = newLeft.toString() + "px";
    this.UIContainer.style.top = newTop.toString() + "px";
    if (this.resizeCaptureOriginalWidth != newWidth || this.resizeCaptureOriginalHeight != newHeight) {
      this.resize(newWidth - 2, newHeight - 2);
    }
    this._genRenderer.clearTransformationMatrix();
    YWidget.HandlesDiv.style.width = newWidth.toString() + "px";
    YWidget.HandlesDiv.style.height = newHeight.toString() + "px";
    YWidget.HandlesDiv.style.left = "0px";
    YWidget.HandlesDiv.style.top = "0px";
    let A = this.resizeCaptureOriginalMatrixInv;
    let B = Matrix3x3.newTranslateMatrix(newLeft - this.resizeCaptureOriginalLeft, newTop - this.resizeCaptureOriginalTop);
    let borderWidth = parseFloat(this.UIContainer.style.border);
    let borderMatrix = Matrix3x3.newTranslateMatrix(-borderWidth, -borderWidth);
    YWidget.HandlesDiv.style.transform = borderMatrix.multiplyByM(A.multiplyByM(B)).toCSS();
  }
  editStopped() {
    this.resizeCaptureRunning = false;
    if (YWidget.HandlesDiv != null)
      YWidget.HandlesDiv.style.display = "none";
  }
  touchCaptureStop(e) {
    this.mouseCaptureStop(null);
  }
  mouseCaptureStop(e) {
    if (!this.resizeCaptureRunning)
      return;
    this.resizeCaptureRunning = false;
    YWidget.editHandles[this.resizeCaptureHandleIndex].active = false;
    if (this.previousTRansform != YWidget.HandlesDiv.style.transform || this.resizeCaptureOriginalWidth != this.UIContainer.offsetWidth || this.resizeCaptureOriginalHeight != this.UIContainer.offsetHeight) {
      if (this._SizeIsRelative)
        this.updateRelativeSize();
      constants.edited = true;
    }
    this.refreshProperties();
  }
  resize(newWidth, newHeight) {
    this.UIContainer.style.width = newWidth.toString() + "px";
    this.UIContainer.style.height = newHeight.toString() + "px";
    this.containerResized();
  }
  containerResized() {
  }
  getContentsConfigData() {
    return "  <location x='" + this.UIContainer.offsetLeft.toString() + "' y='" + this.UIContainer.offsetTop.toString() + "'/>\n  <size     w='" + this.UIContainer.offsetWidth.toString() + "' h='" + this.UIContainer.offsetHeight.toString() + "'  state='Normal'/>\n  <relativeCoord x='" + this._relativePositionX.toString() + "' y='" + this._relativePositionY.toString() + "' w='" + this._relativeWidth.toString() + "' h='" + this._relativeHeight.toString() + "' active='" + (this._SizeIsRelative ? "True" : "False") + "'/>\n  <container id='" + constants.XMLquote(this._containerID) + "'/>\n" + this.getPropertiesXml();
  }
  getPropertiesXml() {
    return "";
  }
  PatchSensorAnnotationCallback(sensor, text) {
    let name = "None";
    let avgvalue = "N/A";
    let minvalue = "N/A";
    let maxvalue = "N/A";
    let unit = "";
    if (!(sensor instanceof NullYSensor)) {
      let resolution = -Math.round(Math.log10(sensor.get_resolution()));
      name = sensor.get_friendlyName();
      if (sensor.isOnline()) {
        avgvalue = sensor.get_lastAvgValue().toFixed(resolution);
        minvalue = sensor.get_lastMinValue().toFixed(resolution);
        maxvalue = sensor.get_lastMaxValue().toFixed(resolution);
      }
      unit = sensor.get_unit();
    }
    text = text.replace("$NAME$", name);
    text = text.replace("$AVGVALUE$", avgvalue);
    text = text.replace("$MAXVALUE$", maxvalue);
    text = text.replace("$MINVALUE$", minvalue);
    text = text.replace("$UNIT$", unit);
    return text;
  }
};
YWidget.HANDLESIZE = Math.round(20 * (1 + 2 * (constants.guiDPIFactor - 1)));
YWidget.editHandles = [];
YWidget.currentEdited = null;
var gaugeWidget = class extends YWidget {
  constructor(node, editor, x, y, width, height) {
    super(node, editor, x, y, width, height);
    this._gauge = new YSolidGauge(this.UIContainer, YSolidGauge.DisplayMode.DISPLAY90, YWidget.log);
    this._genRenderer = this._gauge;
    this.noDataSourcepanel = this._gauge.addMessagePanel();
    this.noDataSourcepanel.font.size = constants.generalFontSize;
    this.noDataSourcepanel.text = 'No data source configured\n 1 - Make sure you have a Yoctopuce sensor connected.\n 2 - Do a right-click or a long touch on this widget.\n 3 - Choose "Configure this gauge" to bring up the properties editor.\n 4 - Choose a data source\n';
    this.prop = new GaugeFormProperties(node, this);
    this._genProp = this.prop;
    let propDesc = GenericProperties.getAllProperties(this.prop);
    if (gaugeWidget.AnnotationPanelCount == 0) {
      for (let propname in propDesc.byName) {
        if (propname.startsWith("SolidGauge_annotationPanel"))
          gaugeWidget.AnnotationPanelCount++;
      }
    }
    for (let i = 0; i < gaugeWidget.AnnotationPanelCount; i++) {
      this._gauge.addAnnotationPanel();
    }
    this._gauge.setPatchAnnotationCallback((s) => {
      return this.AnnotationCallback(s);
    });
    this._gauge.valueFormater = (source, value) => {
      return this.valueFormater(source, value);
    };
    this.updateWindowPositionProperties(this.prop);
    this.prop.ApplyAllProperties(this);
    YDataRenderer.minMaxCheckDisabled = true;
    this.prop.ApplyAllProperties(this._gauge);
    YDataRenderer.minMaxCheckDisabled = false;
    this._gauge.resetRefrenceSize();
    this._gauge.resizeRule = Proportional.ResizeRule.RELATIVETOBOTH;
    this.ApplyRelativeSizeIfRequired();
    if (this.SizeIsRelative)
      this.refreshProperties();
    this._gauge.AllowRedraw();
  }
  getPropertiesXml() {
    return this.prop.getXml(1);
  }
  containerResized() {
    if (this._gauge != null)
      this._gauge.containerResized();
  }
  destroy() {
    this.prop.destroy();
    super.destroy();
    Object.entries(this).forEach((pair) => {
      Reflect.set(this, pair[0], null);
    });
  }
  contextMenuIsOpening() {
    YWebPage.snapshotMenuItem.userdata = this;
    YWebPage.snapshotMenuItem.visible = true;
    YWebPage.resetDataViewMenuItem.visible = false;
    if (YWebPage.editMenuItem == null)
      return;
    YWebPage.clearDataloggerMenuItem.visible = true;
    YWebPage.editMenuItem.caption = "Configure this gauge";
    YWebPage.editMenuItem.visible = true;
    YWebPage.deleteMenuItem.caption = "Delete this gauge";
    YWebPage.deleteMenuItem.visible = true;
    YWebPage.addMarkerMenuItem.visible = false;
    YWebPage.disableMarkerMenuItem.visible = false;
    YWebPage.editMenuItem.userdata = this;
    YWebPage.deleteMenuItem.userdata = this;
  }
  get confirmDeleteString() {
    return "Do you really want to delete this gauge ?";
  }
  AnnotationCallback(text) {
    let sensor = this.prop.DataSource_source;
    return this.PatchSensorAnnotationCallback(sensor, text);
  }
  valueFormater(source, value) {
    if (this.prop.DataSource_source instanceof NullYSensor) {
      return "N/A";
    } else if (!this.prop.DataSource_source.isOnline())
      return "OFFLINE";
    let format = this.prop.DataSource_precision;
    let p = format.indexOf(".");
    let n = 0;
    if (p >= 0)
      n = format.length - p - 1;
    let unit = this.prop.DataSource_source.get_unit();
    return value.toFixed(n) + unit;
  }
  PropertyChanged2(src) {
    let info = new PropPathinfo();
    let path = src.ExtractPropPath(info);
    switch (info.propType) {
      case "Form":
        GenericProperties.copyProperty_STT(this, this.prop, info.fullpropname, path);
        break;
      case "SolidGauge":
        GenericProperties.copyProperty_STT(this._gauge, this.prop, info.fullpropname, path);
        break;
      case "DataSource":
        break;
    }
  }
  Get_PropertyValue(src) {
    let info = new PropPathinfo();
    let path = src.ExtractPropPath(info);
    switch (info.propType) {
      case "Form":
        return GenericProperties.newGetProperty(this, this.prop, info.fullpropname, path, null);
      case "SolidGauge":
        return GenericProperties.newGetProperty(this._gauge, this.prop, info.fullpropname, path, null);
    }
    return null;
  }
  edit() {
    super.edit();
    YWebPage.EditObject(this, this.prop, (src) => {
      this.PropertyChanged2(src);
    }, (src) => {
      return this.Get_PropertyValue(src);
    }, () => {
      this.editStopped();
    });
  }
  refreshProperties() {
    this.prop.RefreshAllProperties(this);
    this.prop.RefreshAllProperties(this._gauge);
    YWebPage.refreshPropertiesForm();
  }
  SourceChanged(value, index) {
    this.noDataSourcepanel.enabled = value instanceof NullYSensor;
    if (value instanceof NullYSensor) {
      this._gauge.value = 0;
    } else {
      value.registerCallback(this);
    }
  }
  SensorValuecallback(source, M) {
    if (this.prop == null)
      return;
    if (source == this.prop.DataSource_source) {
      this._gauge.value = source.isOnline() ? M.get_averageValue() : 0;
    }
  }
  getConfigData() {
    return "<GaugeForm>\n" + this.getContentsConfigData() + "</GaugeForm>\n";
  }
};
gaugeWidget.AnnotationPanelCount = 0;
var angularGaugeWidget = class extends YWidget {
  constructor(node, editor, x, y, width, height) {
    super(node, editor, x, y, width, height);
    this._angularGauge = new YAngularGauge(this.UIContainer, YWidget.log);
    this._genRenderer = this._angularGauge;
    this.noDataSourcepanel = this._angularGauge.addMessagePanel();
    this.noDataSourcepanel.font.size = constants.generalFontSize;
    this.noDataSourcepanel.text = 'No data source configured\n 1 - Make sure you have a Yoctopuce sensor connected.\n 2 - Do a right-click  or a long touch on this widget.\n 3 - Choose "Configure this gauge" to bring up the properties editor.\n 4 - Choose a data source\n';
    this.prop = new AngularGaugeFormProperties(node, this);
    this._genProp = this.prop;
    let propDesc = GenericProperties.getAllProperties(this.prop);
    if (angularGaugeWidget.AnnotationPanelCount == 0) {
      for (let propname in propDesc.byName) {
        if (propname.startsWith("AngularGauge_annotationPanel"))
          angularGaugeWidget.AnnotationPanelCount++;
        if (propname.startsWith("AngularGauge_zone"))
          angularGaugeWidget.zonesCount++;
      }
    }
    for (let i = 0; i < angularGaugeWidget.zonesCount; i++) {
      this._angularGauge.AddZone();
    }
    for (let i = 0; i < angularGaugeWidget.AnnotationPanelCount; i++) {
      this._angularGauge.addAnnotationPanel();
    }
    this._angularGauge.setPatchAnnotationCallback((s) => {
      return this.AnnotationCallback(s);
    });
    this.initDataNode = node;
    this.updateWindowPositionProperties(this.prop);
    this.prop.ApplyAllProperties(this);
    YDataRenderer.minMaxCheckDisabled = true;
    this.prop.ApplyAllProperties(this._angularGauge);
    YDataRenderer.minMaxCheckDisabled = false;
    this._angularGauge.resetRefrenceSize();
    this._angularGauge.resizeRule = Proportional.ResizeRule.RELATIVETOBOTH;
    this.ApplyRelativeSizeIfRequired();
    if (this.SizeIsRelative)
      this.refreshProperties();
    this._angularGauge.AllowRedraw();
  }
  getPropertiesXml() {
    return this.prop.getXml(1);
  }
  containerResized() {
    if (this._angularGauge != null)
      this._angularGauge.containerResized();
  }
  destroy() {
    this.prop.destroy();
    super.destroy();
    Object.entries(this).forEach((pair) => {
      Reflect.set(this, pair[0], null);
    });
  }
  AnnotationCallback(text) {
    let sensor = this.prop.DataSource_source;
    return this.PatchSensorAnnotationCallback(sensor, text);
  }
  contextMenuIsOpening() {
    YWebPage.snapshotMenuItem.userdata = this;
    YWebPage.snapshotMenuItem.visible = true;
    YWebPage.resetDataViewMenuItem.visible = false;
    if (YWebPage.editMenuItem == null)
      return;
    YWebPage.clearDataloggerMenuItem.visible = false;
    YWebPage.editMenuItem.caption = "Configure this gauge";
    YWebPage.editMenuItem.visible = true;
    YWebPage.deleteMenuItem.caption = "Delete this gauge";
    YWebPage.deleteMenuItem.visible = true;
    YWebPage.addMarkerMenuItem.visible = false;
    YWebPage.disableMarkerMenuItem.visible = false;
    YWebPage.editMenuItem.userdata = this;
    YWebPage.deleteMenuItem.userdata = this;
  }
  get confirmDeleteString() {
    return "Do you really want to delete this gauge ?";
  }
  PropertyChanged2(src) {
    let info = new PropPathinfo();
    let path = src.ExtractPropPath(info);
    switch (info.propType) {
      case "Form":
        GenericProperties.copyProperty_STT(this, this.prop, info.fullpropname, path);
        break;
      case "AngularGauge":
        GenericProperties.copyProperty_STT(this._angularGauge, this.prop, info.fullpropname, path);
        break;
      case "DataSource":
        break;
    }
  }
  Get_PropertyValue(src) {
    let info = new PropPathinfo();
    let path = src.ExtractPropPath(info);
    switch (info.propType) {
      case "Form":
        return GenericProperties.newGetProperty(this, this.prop, info.fullpropname, path, null);
      case "AngularGauge":
        return GenericProperties.newGetProperty(this._angularGauge, this.prop, info.fullpropname, path, null);
    }
    return null;
  }
  edit() {
    super.edit();
    YWebPage.EditObject(this, this.prop, (src) => {
      this.PropertyChanged2(src);
    }, (src) => {
      return this.Get_PropertyValue(src);
    }, () => {
      this.editStopped();
    });
  }
  refreshProperties() {
    this.prop.RefreshAllProperties(this);
    this.prop.RefreshAllProperties(this._angularGauge);
    YWebPage.refreshPropertiesForm();
  }
  showStatus(status) {
    if (status != "")
      this._angularGauge.value = 0;
    this._angularGauge.showNeedle = status == "";
    this._angularGauge.statusLine = status;
  }
  SourceChanged(value, index) {
    this._angularGauge.DisableRedraw();
    this.noDataSourcepanel.enabled = value instanceof NullYSensor;
    if (value instanceof NullYSensor) {
      this.showStatus("N/A");
      this._angularGauge.unit = "";
    } else if (!value.isOnline()) {
      this.showStatus("OFFLINE");
    } else {
      this.showStatus("");
      this._angularGauge.unit = value.get_unit();
    }
    this._angularGauge.AllowRedraw();
    value.registerCallback(this);
  }
  SensorValuecallback(source, M) {
    if (this.prop == null)
      return;
    if (source == this.prop.DataSource_source) {
      this._angularGauge.DisableRedraw();
      if (this.prop.DataSource_source instanceof NullYSensor) {
        this.showStatus("N/A");
        this._angularGauge.unit = "";
      } else if (!this.prop.DataSource_source.isOnline()) {
        this.showStatus("OFFLINE");
      } else {
        this._angularGauge.DisableRedraw();
        this.showStatus("");
        this._angularGauge.unit = source.get_unit();
        this._angularGauge.value = M.get_averageValue();
        this._angularGauge.AllowRedraw();
      }
      this._angularGauge.AllowRedraw();
    }
  }
  getConfigData() {
    return "<angularGaugeForm>\n" + this.getContentsConfigData() + "</angularGaugeForm>\n";
  }
};
angularGaugeWidget.AnnotationPanelCount = 0;
angularGaugeWidget.zonesCount = 0;
var digitalDisplayWidget = class extends YWidget {
  constructor(node, editor, x, y, width, height) {
    super(node, editor, x, y, width, height);
    this._unit = "";
    this._display = new YDigitalDisplay(this.UIContainer, YWidget.log);
    this._genRenderer = this._display;
    this.noDataSourcepanel = this._display.addMessagePanel();
    this.noDataSourcepanel.font.size = constants.generalFontSize;
    this.noDataSourcepanel.text = 'No data source configured\n 1 - Make sure you have a Yoctopuce sensor connected.\n 2 - Do a right-click  or a long touch on this widget.\n 3 - Choose "Configure this digital display" to bring up the properties editor.\n 4 - Choose a data source\n';
    this.prop = new digitalDisplayFormProperties(node, this);
    this._genProp = this.prop;
    let propDesc = GenericProperties.getAllProperties(this.prop);
    if (digitalDisplayWidget.AnnotationPanelCount == 0) {
      for (let propname in propDesc.byName) {
        if (propname.startsWith("display_annotationPanel"))
          digitalDisplayWidget.AnnotationPanelCount++;
      }
    }
    for (let i = 0; i < digitalDisplayWidget.AnnotationPanelCount; i++) {
      this._display.addAnnotationPanel();
    }
    this._display.setPatchAnnotationCallback((s) => {
      return this.AnnotationCallback(s);
    });
    this._display.valueFormater = (source, value) => {
      return this.valueFormater(source, value);
    };
    this.updateWindowPositionProperties(this.prop);
    this.prop.ApplyAllProperties(this);
    YDataRenderer.minMaxCheckDisabled = true;
    this.prop.ApplyAllProperties(this._display);
    YDataRenderer.minMaxCheckDisabled = false;
    this._display.resetRefrenceSize();
    this._display.AllowPrintScreenCapture = true;
    this._display.resetRefrenceSize();
    this._display.resizeRule = Proportional.ResizeRule.RELATIVETOBOTH;
    this.ApplyRelativeSizeIfRequired();
    if (this.SizeIsRelative)
      this.refreshProperties();
    this._display.AllowRedraw();
  }
  getPropertiesXml() {
    return this.prop.getXml(1);
  }
  containerResized() {
    if (this._display != null)
      this._display.containerResized();
  }
  destroy() {
    this.prop.destroy();
    super.destroy();
    Object.entries(this).forEach((pair) => {
      Reflect.set(this, pair[0], null);
    });
  }
  AnnotationCallback(text) {
    let sensor = this.prop.DataSource_source;
    return this.PatchSensorAnnotationCallback(sensor, text);
  }
  contextMenuIsOpening() {
    YWebPage.snapshotMenuItem.userdata = this;
    YWebPage.snapshotMenuItem.visible = true;
    YWebPage.resetDataViewMenuItem.visible = false;
    if (YWebPage.editMenuItem == null)
      return;
    YWebPage.clearDataloggerMenuItem.visible = false;
    YWebPage.editMenuItem.caption = "Configure this digital display";
    YWebPage.editMenuItem.visible = true;
    YWebPage.deleteMenuItem.caption = "Delete this digital display";
    YWebPage.deleteMenuItem.visible = true;
    YWebPage.addMarkerMenuItem.visible = false;
    YWebPage.disableMarkerMenuItem.visible = false;
    YWebPage.editMenuItem.userdata = this;
    YWebPage.deleteMenuItem.userdata = this;
  }
  get confirmDeleteString() {
    return "Do you really want to delete this digital display ?";
  }
  valueFormater(source, value) {
    if (this.prop.DataSource_source instanceof NullYSensor) {
      return "N/A";
    } else if (!this.prop.DataSource_source.isOnline())
      return "OFFLINE";
    let format = this.prop.DataSource_precision;
    let p = format.indexOf(".");
    let n = 0;
    if (p >= 0)
      n = format.length - p - 1;
    let unit = this.prop.DataSource_source.get_unit();
    return value.toFixed(n) + unit;
  }
  PropertyChanged2(src) {
    let info = new PropPathinfo();
    let path = src.ExtractPropPath(info);
    switch (info.propType) {
      case "Form":
        GenericProperties.copyProperty_STT(this, this.prop, info.fullpropname, path);
        break;
      case "display":
        GenericProperties.copyProperty_STT(this._display, this.prop, info.fullpropname, path);
        break;
      case "DataSource":
        break;
    }
  }
  Get_PropertyValue(src) {
    let info = new PropPathinfo();
    let path = src.ExtractPropPath(info);
    switch (info.propType) {
      case "Form":
        return GenericProperties.newGetProperty(this, this.prop, info.fullpropname, path, null);
      case "display":
        return GenericProperties.newGetProperty(this._display, this.prop, info.fullpropname, path, null);
    }
    return null;
  }
  edit() {
    super.edit();
    YWebPage.EditObject(this, this.prop, (src) => {
      this.PropertyChanged2(src);
    }, (src) => {
      return this.Get_PropertyValue(src);
    }, () => {
      this.editStopped();
    });
  }
  refreshProperties() {
    this.prop.RefreshAllProperties(this);
    this.prop.RefreshAllProperties(this._display);
    YWebPage.refreshPropertiesForm();
  }
  SourceChanged(value, index) {
    this.noDataSourcepanel.enabled = value instanceof NullYSensor;
    this.SensorValuecallback(value, null);
    if (value instanceof NullYSensor) {
      this._display.alternateValue = "N/A";
    } else if (!value.isOnline())
      this._display.alternateValue = "OFFLINE";
    value.registerCallback(this);
  }
  SensorValuecallback(source, M) {
    if (this.prop == null)
      return;
    if (this.prop.DataSource_source instanceof NullYSensor) {
      this._display.alternateValue = "N/A";
    } else if (!this.prop.DataSource_source.isOnline()) {
      this._display.alternateValue = "OFFLINE";
    } else if (M == null) {
      this._display.alternateValue = "--" + this._unit;
    } else if (source == this.prop.DataSource_source) {
      this._display.DisableRedraw();
      this._display.alternateValue = null;
      this._display.value = M.get_averageValue();
      this._display.AllowRedraw();
    }
  }
  getConfigData() {
    return "<digitalDisplayForm>\n" + this.getContentsConfigData() + "</digitalDisplayForm>\n";
  }
};
digitalDisplayWidget.AnnotationPanelCount = 0;
var graphWidget = class extends YWidget {
  constructor(node, editor, x, y, width, height) {
    super(node, editor, x, y, width, height);
    this.editedMarkerWasEnabled = false;
    this.editedMarkerPosition = 0;
    this._graph = new YGraph(this.UIContainer, YWidget.log);
    this.noDataSourcepanel = this._graph.addMessagePanel();
    this.noDataSourcepanel.font.size = constants.generalFontSize;
    this.noDataSourcepanel.text = 'No data source configured\n 1 - Make sure you have a Yoctopuce sensor connected.\n 2 - Do a right-click  or a long touch on this widget.\n 3 - Choose "Configure this graph" to bring up the properties editor.\n 4 - Choose a data source\n';
    this.dataloggerProgress = this._graph.addMessagePanel();
    this.dataloggerProgress.font.size = 12 * constants.guiDPIFactor;
    this.dataloggerProgress.font.color = YColor.DarkGray;
    this.dataloggerProgress.borderColor = YColor.Gray;
    this.dataloggerProgress.panelHrzAlign = MessagePanel.HorizontalAlignPos.LEFT;
    this.dataloggerProgress.panelVrtAlign = MessagePanel.VerticalAlignPos.TOP;
    this.dataloggerProgress.text = graphWidget.DataLoggerLoadingMsg;
    this.dataloggerProgress.enabled = false;
    this.prop = new GraphFormProperties(node, this);
    this._genProp = this.prop;
    let propDesc = GenericProperties.getAllProperties(this.prop);
    if (graphWidget.YAxisCount == 0) {
      for (let propname in propDesc.byName) {
        if (propname.startsWith("Graph_annotationPanel"))
          graphWidget.AnnotationPanelCount++;
        if (propname.startsWith("Graph_series"))
          graphWidget.SeriesCount++;
        if (propname.startsWith("Graph_yAxes"))
          graphWidget.YAxisCount++;
      }
    }
    if (graphWidget.ZoneCountPerYaxis == 0) {
      let yAxisProp = new YaxisDescription(0, false);
      let propDesc2 = GenericProperties.getAllProperties(yAxisProp);
      for (let propname in propDesc2.byName) {
        if (propname.startsWith("zones"))
          graphWidget.ZoneCountPerYaxis++;
      }
    }
    if (graphWidget.MarkerCountPerXaxis == 0) {
      let xAxisProp = new XaxisDescription();
      let propDesc2 = GenericProperties.getAllProperties(xAxisProp);
      for (let propname in propDesc2.byName) {
        if (propname.startsWith("markers"))
          graphWidget.MarkerCountPerXaxis++;
      }
    }
    this.offLineSourcesPanel = this._graph.addMessagePanel();
    this.offLineSourcesPanel.bgColor = YColor.FromArgb(192, 255, 192, 192);
    this.offLineSourcesPanel.borderColor = YColor.DarkRed;
    this.offLineSourcesPanel.font.color = YColor.DarkRed;
    this.offLineSourcesPanel.panelHrzAlign = MessagePanel.HorizontalAlignPos.RIGHT;
    this.offLineSourcesPanel.panelVrtAlign = MessagePanel.VerticalAlignPos.TOP;
    this.captureRunningPanel = this._graph.addMessagePanel();
    this.captureRunningPanel.bgColor = YColor.FromArgb(240, 200, 255, 193);
    this.captureRunningPanel.borderColor = YColor.DarkGreen;
    this.captureRunningPanel.font.color = YColor.DarkGreen;
    this.captureRunningPanel.panelHrzAlign = MessagePanel.HorizontalAlignPos.LEFT;
    this.captureRunningPanel.panelVrtAlign = MessagePanel.VerticalAlignPos.TOP;
    for (let i = 0; i < graphWidget.YAxisCount; i++) {
      let axis = this._graph.addYAxis();
      for (let j = 0; j < graphWidget.ZoneCountPerYaxis; j++) {
        axis.AddZone();
      }
    }
    this.markers = [];
    for (let i = 0; i < graphWidget.MarkerCountPerXaxis; i++) {
      let m = this._graph.xAxis.AddMarker();
      m.xposition = TimeConverter.ToUnixTime(new Date()) + i * 60;
      this.markers.push(m);
    }
    for (let i = 0; i < graphWidget.AnnotationPanelCount; i++) {
      this._graph.addAnnotationPanel();
    }
    this.seriesProperties = [];
    for (let i = 0; i < graphWidget.SeriesCount; i++) {
      this.seriesProperties.push(Reflect.get(this.prop, "Graph_series" + i.toString()));
      this._graph.addSerie();
    }
    this._graph.yAxes[0].visible = true;
    this._graph.setPatchAnnotationCallback((s) => {
      return this.AnnotationCallback(s);
    });
    this._genRenderer = this._graph;
    this._graph.resetRefrenceSize();
    this._graph.AllowPrintScreenCapture = true;
    this._graph.setMarkerCaptureCallbacks((m) => {
      this.MarkedCaptureStarted(m);
    }, (m) => {
      this.MarkedCaptureStopped(m);
    });
    this.offlineMessages = new Array(graphWidget.SeriesCount);
    this.showOffline = new Array(graphWidget.SeriesCount);
    this.updateWindowPositionProperties(this.prop);
    this.prop.ApplyAllProperties(this);
    YDataRenderer.minMaxCheckDisabled = true;
    this.prop.ApplyAllProperties(this._graph);
    YDataRenderer.minMaxCheckDisabled = false;
    for (let i = 0; i < graphWidget.YAxisCount; i++) {
      this._graph.yAxes[i].AxisChanged = () => {
        this.AxisParamtersChangedAutomatically(this._graph.yAxes[i]);
      };
      this._graph.yAxes[i].AllowAutoShow = true;
    }
    for (let i = 0; i < graphWidget.SeriesCount; i++) {
      let s = Reflect.get(this.prop, "Graph_series" + i.toString());
      s.Init(this, i);
      if (s.DataSource_source != null) {
        this.SourceChanged(s.DataSource_source, i);
      }
    }
    this._graph.resetRefrenceSize();
    this._graph.resizeRule = Proportional.ResizeRule.FIXED;
    this.ApplyRelativeSizeIfRequired();
    if (this.SizeIsRelative)
      this.refreshProperties();
    this.loadRecordedDataIfNeeded();
    this._graph.AllowRedraw();
  }
  AnnotationCallback(text) {
    for (let i = 0; i < graphWidget.SeriesCount; i++) {
      let s = Reflect.get(this.prop, "Graph_series" + i.toString());
      let sensor = s.DataSource_source;
      let name = "None";
      let avgvalue = "N/A";
      let minvalue = "N/A";
      let maxvalue = "N/A";
      let unit = "";
      if (!(sensor instanceof NullYSensor)) {
        let resolution = -Math.round(Math.log10(sensor.get_resolution()));
        name = s.legend != "" ? s.legend : sensor.get_friendlyName();
        if (sensor.isOnline()) {
          avgvalue = sensor.get_lastAvgValue().toFixed(resolution);
          minvalue = sensor.get_lastMinValue().toFixed(resolution);
          maxvalue = sensor.get_lastMaxValue().toFixed(resolution);
        }
        unit = sensor.get_unit();
      }
      text = text.replace("$NAME" + (i + 1).toString() + "$", name);
      text = text.replace("$AVGVALUE" + (i + 1).toString() + "$", avgvalue);
      text = text.replace("$MAXVALUE" + (i + 1).toString() + "$", maxvalue);
      text = text.replace("$MINVALUE" + (i + 1).toString() + "$", minvalue);
      text = text.replace("$UNIT" + (i + 1).toString() + "$", unit);
    }
    return text;
  }
  destroy() {
    this.prop.destroy();
    super.destroy();
    Object.entries(this).forEach((pair) => {
      Reflect.set(this, pair[0], null);
    });
  }
  getPropertiesXml() {
    return this.prop.getXml(1);
  }
  containerResized() {
    if (this._graph != null)
      this._graph.containerResized();
  }
  contextMenuIsOpening() {
    YWebPage.snapshotMenuItem.userdata = this;
    YWebPage.snapshotMenuItem.visible = true;
    YWebPage.resetDataViewMenuItem.visible = true;
    YWebPage.resetDataViewMenuItem.userdata = this;
    if (YWebPage.editMenuItem == null)
      return;
    YWebPage.clearDataloggerMenuItem.visible = true;
    YWebPage.clearDataloggerMenuItem.userdata = this;
    YWebPage.editMenuItem.caption = "Configure this graph";
    YWebPage.editMenuItem.visible = true;
    YWebPage.deleteMenuItem.caption = "Delete this graph";
    YWebPage.deleteMenuItem.visible = true;
    YWebPage.addMarkerMenuItem.visible = true;
    YWebPage.disableMarkerMenuItem.visible = true;
    YWebPage.editMenuItem.userdata = this;
    YWebPage.deleteMenuItem.userdata = this;
    YWebPage.disableMarkerMenuItem.userdata = this;
    for (let i = 0; i < YWebPage.markersSubMenuItems.length; i++) {
      YWebPage.markersSubMenuItems[i].caption = "Place marker #" + (i + 1).toString();
      YWebPage.markersSubMenuItems[i].userdata = this;
    }
  }
  startMarkerCapture(markerIndex) {
    this.markers[markerIndex].startCapture();
  }
  AxisParamtersChangedAutomatically(source) {
    let yaxis = source.userData;
    yaxis.visible = source.visible;
    YWebPage.refreshPropertiesForm();
  }
  get confirmDeleteString() {
    return "Do you really want to delete this graph ?";
  }
  MarkedCaptureStarted(src) {
    let str = src.text != "" ? 'Click to place the "' + src.shortText + '" marker.' : "Click to place the marker.";
    str += "\nRight-click to cancel the operation.";
    this.editedMarkerWasEnabled = src.enabled;
    this.editedMarkerPosition = src.positionOnXAxis.value;
    this.captureRunningPanel.text = str;
    this.captureRunningPanel.enabled = true;
  }
  MarkedCaptureStopped(src) {
    if (src != null) {
      if (this.editedMarkerWasEnabled != src.enabled && this.editedMarkerPosition != src.positionOnXAxis.value) {
        constants.edited = true;
      }
    }
    this.captureRunningPanel.enabled = false;
    this.refreshProperties();
  }
  refreshProperties() {
    this.prop.RefreshAllProperties(this);
    this.prop.RefreshAllProperties(this._graph);
    YWebPage.refreshPropertiesForm();
  }
  decomposeToSegments(data, start, dataCount) {
    let n1 = start;
    let n2 = 0;
    let l = [];
    let deltaT = 0;
    while (n1 < start + dataCount - 1) {
      try {
        deltaT = data[n1 + 1].DateTime - data[n1].DateTime;
      } catch (Exception) {
        debugger;
      }
      n2 = n1 + 1;
      while (n2 < dataCount && data[n2].DateTime - data[n2 - 1].DateTime < 2 * deltaT) {
        n2++;
      }
      let count = n2 - n1;
      if (count > 0) {
        let p = new Array(count);
        for (let i = 0; i < count; i++) {
          p[i] = new pointXY(data[n1 + i].DateTime, data[n1 + i].value);
        }
        l.push(p);
      }
      n1 = n2;
    }
    return l;
  }
  SourceChanged(value, index) {
    this._graph.DisableRedraw();
    let s;
    let noDataSource = true;
    for (let i = 0; i < graphWidget.SeriesCount; i++) {
      s = Reflect.get(this.prop, "Graph_series" + i.toString());
      if (!(s.DataSource_source instanceof NullYSensor))
        noDataSource = false;
    }
    this.noDataSourcepanel.enabled = noDataSource;
    if (value != null) {
      if (!(value instanceof NullYSensor)) {
        if (value.isOnline()) {
          this.showOffline[index] = false;
        } else {
          this.offlineMessages[index] = value.get_friendlyName() + " is OFFLINE";
          this.showOffline[index] = true;
          logForm.log(value.get_friendlyName() + " is OFFLINE");
        }
      } else {
        this.showOffline[index] = false;
      }
    } else {
      this.showOffline[index] = false;
    }
    this.updateOfflinePanel();
    this.preLoadSensorData(value, index);
    this.loadRecordedDataIfNeeded();
    if (value)
      value.registerCallback(this);
    this._graph.AllowRedraw();
  }
  SensorArrivalcallback(source) {
    this.loadRecordedDataIfNeeded();
  }
  preLoadSensorData(value, index) {
    if (value instanceof NullYSensor) {
      this._graph.series[index].clear();
      return;
    }
    let s = Reflect.get(this.prop, "Graph_series" + index.toString());
    let data;
    switch (s.DataSource_datatype) {
      case 1:
        data = value.minData;
        break;
      case 2:
        data = value.maxData;
        break;
      default:
        data = value.curData;
        break;
    }
    let l = this.decomposeToSegments(data, 0, data.length);
    this._graph.series[index].clear();
    for (let i = l.length - 1; i >= 0; i--) {
      this._graph.series[index].InsertPoints(l[i]);
    }
    this._graph.series[index].rebuildSummaries();
  }
  PropertyChanged2(src) {
    let info = new PropPathinfo();
    let path = src.ExtractPropPath(info);
    switch (info.propType) {
      case "Form":
        GenericProperties.copyProperty_STT(this, this.prop, info.fullpropname, path);
        break;
      case "Graph":
        GenericProperties.copyProperty_STT(this._graph, this.prop, info.fullpropname, path);
        break;
      case "DataSource":
        break;
    }
  }
  Get_PropertyValue(src) {
    let info = new PropPathinfo();
    let path = src.ExtractPropPath(info);
    switch (info.propType) {
      case "Form":
        return GenericProperties.newGetProperty(this, this.prop, info.fullpropname, path, null);
      case "Graph":
        return GenericProperties.newGetProperty(this._graph, this.prop, info.fullpropname, path, null);
      case "DataSource":
        return null;
    }
    return null;
  }
  edit() {
    super.edit();
    YWebPage.EditObject(this, this.prop, (src) => {
      this.PropertyChanged2(src);
    }, (src) => {
      return this.Get_PropertyValue(src);
    }, () => {
      this.editStopped();
    });
  }
  updateOfflinePanel() {
    let message = "";
    for (let i = 0; i < graphWidget.SeriesCount; i++) {
      if (this.showOffline[i])
        message = message + (message != "" ? "\n" : "") + this.offlineMessages[i];
    }
    if (message == "" && this.offLineSourcesPanel.enabled)
      this.offLineSourcesPanel.enabled = false;
    if (message != "" && (this.offLineSourcesPanel.text != message || !this.offLineSourcesPanel.enabled)) {
      this.offLineSourcesPanel.text = message;
      this.offLineSourcesPanel.enabled = true;
    }
  }
  SensorValuecallback(source, M) {
    if (this.prop == null)
      return;
    for (let i = 0; i < graphWidget.SeriesCount; i++) {
      let s = this.seriesProperties[i];
      if (s.DataSource_source == source) {
        if (!s.DataSource_source.isOnline()) {
          this.offlineMessages[i] = s.DataSource_source.get_friendlyName() + " is OFFLINE";
          this.showOffline[i] = true;
          this.updateOfflinePanel();
          return;
        }
        this.showOffline[i] = false;
        this.updateOfflinePanel();
        let index = s.DataSource_source.curData.length - 1;
        if (index >= 0)
          switch (s.DataSource_datatype) {
            case 1:
              this._graph.series[i].AddPoint(new pointXY(s.DataSource_source.minData[index].DateTime, s.DataSource_source.minData[index].value));
              break;
            case 2:
              this._graph.series[i].AddPoint(new pointXY(s.DataSource_source.maxData[index].DateTime, s.DataSource_source.maxData[index].value));
              break;
            default:
              this._graph.series[i].AddPoint(new pointXY(s.DataSource_source.curData[index].DateTime, s.DataSource_source.curData[index].value));
              break;
          }
        this._graph.series[i].unit = s.DataSource_source.get_unit();
      }
    }
  }
  disableAllMarkers() {
    confirm.ask("Do you really want to disable all markers?", () => {
      for (let i = 0; i < this.markers.length; i++) {
        this.markers[i].enabled = false;
      }
    }, () => {
    }, null);
  }
  clearDataLogger() {
    confirm.ask("Do you really want to erase contents of all dataloggers related to this graph?", () => {
      this.startToClearDataLoggers();
    }, () => {
    }, null);
  }
  truncateView() {
    for (let i = 0; i < graphWidget.SeriesCount; i++) {
      this._graph.series[i].clear();
    }
    let FirstLiveValue = Math.floor(new Date().getTime() / 1e3);
    this._graph.xAxis.set_minMax(FirstLiveValue, FirstLiveValue + this._graph.xAxis.initialZoom);
  }
  resetDataView() {
    this.prop.Graph_showRecordedData = false;
    this.truncateView();
  }
  async startToClearDataLoggers() {
    let loggers = [];
    for (let i = 0; i < graphWidget.SeriesCount; i++) {
      let s = Reflect.get(this.prop, "Graph_series" + i.toString());
      let sensor = s.DataSource_source;
      if (!(sensor instanceof NullYSensor)) {
        sensor.stopDataloggerloading();
        let serial = sensor.get_hardwareId();
        let n = serial.indexOf(".");
        serial = serial.substring(0, n);
        let d = await YDataLogger.FindDataLogger(serial + ".dataLogger");
        if (await d.isOnline()) {
          let found = false;
          for (let j = 0; j < loggers.length; j++) {
            if (loggers[j] == d)
              found = true;
          }
          if (!found)
            loggers.push(d);
        }
      }
    }
    for (let i = 0; i < loggers.length; i++) {
      await loggers[i].forgetAllDataStreams();
      await loggers[i].set_recording(YDataLogger.RECORDING_ON);
    }
    let tmp = this.prop.Graph_showRecordedData;
    this.prop.Graph_showRecordedData = false;
    this.truncateView();
    this.prop.Graph_showRecordedData = tmp;
  }
  dataLoggerLoadprocessIsRunningNotification(source) {
    let loadTotalPercent = 0;
    let sensorCount = 0;
    if (!this.prop.Graph_showRecordedData)
      return;
    for (let i = 0; i < graphWidget.SeriesCount; i++) {
      let s = Reflect.get(this.prop, "Graph_series" + i.toString());
      let sensor = s.DataSource_source;
      if (sensor.dataloggerLoadisRunning) {
        loadTotalPercent += sensor.dataloggerLoadProgress;
        sensorCount++;
      }
    }
    if (sensorCount > 0)
      this.dataloggerProgress.text = graphWidget.DataLoggerLoadingMsg + " (" + (loadTotalPercent / sensorCount).toFixed(0) + "%)";
    let showPanel = sensorCount > 0 && loadTotalPercent > 0 && loadTotalPercent < sensorCount * 100;
    this.dataloggerProgress.enabled = showPanel;
  }
  SensorNewDataBlock(source, sourceFromIndex, sourcetoIndex, targetIndex, fromDataLogger) {
    if (this.prop == null)
      return;
    if (fromDataLogger && !this.prop.Graph_showRecordedData)
      return;
    let l = null;
    for (let i = 0; i < graphWidget.SeriesCount; i++) {
      let s = Reflect.get(this.prop, "Graph_series" + i.toString());
      if (s.DataSource_source == source) {
        let count = sourcetoIndex - sourceFromIndex + 1;
        if (count > 1) {
          switch (s.DataSource_datatype) {
            case 1:
              l = this.decomposeToSegments(s.DataSource_source.minData, sourceFromIndex, count);
              for (let j = l.length - 1; j >= 0; j--) {
                this._graph.series[i].InsertPoints(l[j]);
              }
              break;
            case 2:
              l = this.decomposeToSegments(s.DataSource_source.maxData, sourceFromIndex, count);
              for (let j = l.length - 1; j >= 0; j--) {
                this._graph.series[i].InsertPoints(l[j]);
              }
              break;
            default:
              l = this.decomposeToSegments(s.DataSource_source.curData, sourceFromIndex, count);
              for (let j = l.length - 1; j >= 0; j--) {
                this._graph.series[i].InsertPoints(l[j]);
              }
              break;
          }
        }
      }
    }
  }
  loadRecordedDataIfNeeded() {
    if (this.prop == null)
      return;
    if (!this.prop.Graph_showRecordedData)
      return;
    for (let i = 0; i < graphWidget.SeriesCount; i++) {
      let s = Reflect.get(this.prop, "Graph_series" + i.toString());
      s.DataSource_source.startDataloggerload(this);
    }
  }
  removeDataloggerData() {
  }
  DataloggerCompleted(Source) {
    if (!this.prop.Graph_showRecordedData)
      return;
    let props = GenericProperties.getAllProperties(this.prop);
    for (let i = 0; i < this.seriesProperties.length; i++) {
      if (this.seriesProperties[i].DataSource_source == Source) {
        if (!this.seriesProperties[i].dataloggerAlreadyLoaded) {
          this._graph.DisableRedraw();
          this.preLoadSensorData(Source, i);
          this._graph.AllowRedraw();
        }
      }
    }
  }
  getConfigData() {
    return "<GraphForm>\n" + this.getContentsConfigData() + "</GraphForm>\n";
  }
};
graphWidget.AnnotationPanelCount = 0;
graphWidget.SeriesCount = 0;
graphWidget.ZoneCountPerYaxis = 0;
graphWidget.MarkerCountPerXaxis = 0;
graphWidget.YAxisCount = 0;
graphWidget.DataLoggerLoadingMsg = "Loading from datalogger";

// obj/full/propertiesMngmt.js
var YXmlNode = class {
  constructor(node) {
    this.node = node;
  }
  get Name() {
    return this.node.nodeName;
  }
  get_childsByName() {
    let res = {};
    this.node.childNodes.forEach((child) => {
      res[child.nodeName] = new YXmlNode(child);
    });
    return res;
  }
  get_childsByIndex() {
    let res = [];
    this.node.childNodes.forEach((child) => {
      res.push(new YXmlNode(child));
    });
    return res;
  }
  get_attributes() {
    let el = this.node;
    let res = {};
    let keys = el.getAttributeNames();
    for (let i = 0; i < keys.length; i++) {
      res[keys[i]] = el.getAttribute(keys[i]);
    }
    return res;
  }
  get Attributes() {
    return this.get_attributes();
  }
};
var PropertyAccess = class {
  constructor() {
    this.ttype = "";
    this.stype = "";
    this.finalTarget = null;
    this.terminalSource = null;
    this.propertyName = null;
  }
};
var doubleNan = class {
  constructor(v) {
    this._value = Number.NaN;
    if (typeof v == "undefined") {
      return;
    } else if (typeof v == "number") {
      this._value = v;
    } else if (typeof v == "string") {
      if (v == "") {
        this._value = Number.NaN;
      } else {
        this._value = Number(v);
      }
    } else {
      debugger;
    }
  }
  toString() {
    if (Number.isNaN(this._value))
      return "";
    return this._value.toString();
  }
  clone() {
    return new doubleNan(this.value);
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value;
  }
};
var PropertyDescriptor = class {
  constructor(name) {
    this.isWritable = false;
    this.isEnum = false;
    this.type = "";
    this.Attributes = {};
    this.name = name;
  }
};
var PropertiesList = class {
  constructor() {
    this.byIndex = [];
    this.byName = {};
  }
};
var PropDescription = class {
  constructor(name, prop) {
    this.name = name;
    this.prop = prop;
  }
};
var GenericProperties = class {
  constructor(Owner) {
    this._Form_Text = "New window";
    this._Form_BackColor = YColor.FromArgb(255, 240, 240, 240);
    this._Form_BorderColor = YColor.LightGray;
    this._SizeIsRelative = false;
    this._Form_PositionX = 0;
    this._Form_PositionY = 0;
    this._Form_Width = 300;
    this._Form_Height = 200;
    this._containerID = "";
    this.ownerForm = Owner;
    this._Form_Text = "new window";
  }
  static NoFilter(propNname) {
    return true;
  }
  static escapeXml(unsafe) {
    return unsafe.replace(/[^ !#$%(-;=?-z]/g, (c) => "&#" + c.charCodeAt(0) + ";");
  }
  destroy() {
    Object.entries(this).forEach((pair) => {
      Reflect.set(this, pair[0], null);
    });
  }
  initFromXmlData(initData) {
    if (initData != null)
      this.loadProperties(initData, this.ownerForm, this);
  }
  loadProperties(initData, Owner, o) {
    let value;
    this.ownerForm = Owner;
    if (initData != null) {
      let properties = GenericProperties.getAllProperties(o);
      let childs = initData.get_childsByName();
      for (let propname in properties.byName) {
        let p = properties.byName[propname];
        if (p.isWritable) {
          for (let childName in childs) {
            if (childName == propname) {
              let target = Reflect.get(o, propname);
              let Mustload = true;
              if ("NotSavedInXMLAttribute" in p.Attributes) {
                Mustload = p.Attributes["NotSavedInXMLAttribute"];
              }
              if (Mustload) {
                if (GenericProperties.IsStructured(target)) {
                  this.loadProperties(childs[childName], Owner, target);
                } else {
                  let targetType = typeof target;
                  let attributes = childs[childName].get_attributes();
                  let value2 = attributes["value"];
                  if (target instanceof CustomYSensor) {
                    if (value2.toUpperCase() != "NULL" && value2 != "") {
                      let s = sensorsManager.AddNewSensor(value2);
                      Reflect.set(o, propname, s);
                    } else {
                      Reflect.set(o, propname, sensorsManager.getNullSensor());
                    }
                  } else if (target instanceof YEnumItem) {
                    Reflect.set(o, propname, target.fromString(value2));
                  } else if (target instanceof doubleNan) {
                    let d = new doubleNan(value2);
                    Reflect.set(o, propname, d);
                  } else if (target instanceof xAxisPosition) {
                    let xpos = Number(value2);
                    let rel = attributes["relative"].toUpperCase() == "TRUE";
                    Reflect.set(o, propname, new xAxisPosition(xpos, rel));
                  } else if (target instanceof YColor) {
                    let c = YColor.FromString(value2);
                    if (c == null)
                      c = YColor.Black;
                    Reflect.set(o, propname, c.clone());
                  } else if (target instanceof YFont) {
                    let size = attributes["size"];
                    let color = attributes["color"];
                    let italic = attributes["italic"];
                    let bold = attributes["bold"];
                    let f = Reflect.get(o, propname);
                    f.name = value2;
                    f.size = size !== "undefined" ? Number(size) : 10;
                    let c = YColor.FromString(color);
                    f.color = c != null ? c : YColor.Black.clone();
                    f.italic = italic.toUpperCase() == "TRUE";
                    f.bold = bold.toUpperCase() == "TRUE";
                  } else {
                    switch (targetType) {
                      case "string":
                        Reflect.set(o, propname, value2);
                        break;
                      case "number":
                        Reflect.set(o, propname, Number(value2));
                        break;
                      case "boolean":
                        let v = value2.toUpperCase() == "TRUE";
                        Reflect.set(o, propname, v);
                        break;
                      default:
                        debugger;
                        throw "unhandled target type : " + targetType + "(" + target.constructor.name + ")";
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  get ATTR_Form_Text__DisplayName() {
    return "Window title";
  }
  get ATTR_Form_Text__CategoryAttribute() {
    return "Window";
  }
  get ATTR_Form_Text__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_Form_Text__DescriptionAttribute() {
    return "Widget name. This name is not show on display, but it might help you to identify each widget. ";
  }
  get Form_Text() {
    return this._Form_Text;
  }
  set Form_Text(value) {
    this._Form_Text = value;
  }
  get ATTR_Form_BackColor__DisplayName() {
    return "Background color";
  }
  get ATTR_Form_BackColor__CategoryAttribute() {
    return "Window";
  }
  get ATTR_Form_BackColor__DescriptionAttribute() {
    return "Window background color.";
  }
  get Form_BackColor() {
    return this._Form_BackColor;
  }
  set Form_BackColor(value) {
    this._Form_BackColor = value;
  }
  get ATTR_Form_BorderColor__DisplayName() {
    return "Border color";
  }
  get ATTR_Form_BorderColor__CategoryAttribute() {
    return "Window";
  }
  get ATTR_Form_BorderColor__DescriptionAttribute() {
    return "Window border color, use transparent color to hide the border.";
  }
  get Form_BorderColor() {
    return this._Form_BorderColor;
  }
  set Form_BorderColor(value) {
    this._Form_BorderColor = value;
  }
  get ATTR_Form_SizeIsRelative__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_Form_SizeIsRelative__DisplayName() {
    return "Rel. size and pos.";
  }
  get ATTR_Form_SizeIsRelative__CategoryAttribute() {
    return "Window";
  }
  get ATTR_Form_SizeIsRelative__DescriptionAttribute() {
    return "Makes widget size and position relative to container size. This, for instance, allows to make a widget automatically occupy all of the browser viewport, no matter the browser window size. In relative mode, position and size value are expressed in %";
  }
  get ATTR_Form_SizeIsRelative__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get Form_SizeIsRelative() {
    return this._SizeIsRelative;
  }
  set Form_SizeIsRelative(value) {
    this._SizeIsRelative = value;
  }
  get ATTR_Form_PositionX__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_Form_PositionX__DisplayName() {
    return "Left";
  }
  get ATTR_Form_PositionX__CategoryAttribute() {
    return "Window";
  }
  get ATTR_Form_PositionX__DescriptionAttribute() {
    return "Widget left border X position";
  }
  get Form_PositionX() {
    return this._Form_PositionX;
  }
  set Form_PositionX(value) {
    this._Form_PositionX = value;
  }
  get ATTR_Form_PositionY__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_Form_PositionY__DisplayName() {
    return "Top";
  }
  get ATTR_Form_PositionY__CategoryAttribute() {
    return "Window";
  }
  get ATTR_Form_PositionY__DescriptionAttribute() {
    return "Widget top border Y position";
  }
  get Form_PositionY() {
    return this._Form_PositionY;
  }
  set Form_PositionY(value) {
    this._Form_PositionY = value;
  }
  get ATTR_Form_Width__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_Form_Width__DisplayName() {
    return "Width";
  }
  get ATTR_Form_Width__CategoryAttribute() {
    return "Window";
  }
  get ATTR_Form_Width__DescriptionAttribute() {
    return "Widget width";
  }
  get Form_Width() {
    return this._Form_Width;
  }
  set Form_Width(value) {
    this._Form_Width = value;
  }
  get ATTR_Form_Height__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_Form_Height__DisplayName() {
    return "Height";
  }
  get ATTR_Form_Height__CategoryAttribute() {
    return "Window";
  }
  get ATTR_Form_Height__DescriptionAttribute() {
    return "Widget height";
  }
  get Form_Height() {
    return this._Form_Height;
  }
  set Form_Height(value) {
    this._Form_Height = value;
  }
  get ATTR_Form_containerID__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_Form_containerID__DisplayName() {
    return "Container ID";
  }
  get ATTR_Form_containerID__CategoryAttribute() {
    return "Window";
  }
  get ATTR_Form_containerID__DescriptionAttribute() {
    return "Forces the widget to be shown inside an HTML element with a specific ID already present on the page. If ID is empty, the widget is inserted at root level. Be aware that X,Y offsets are kept, you may want to set them to Zero. ";
  }
  get Form_containerID() {
    return this._containerID;
  }
  set Form_containerID(value) {
    this._containerID = value;
  }
  indent(n) {
    return " ".repeat(n);
  }
  getXml(deep, o) {
    if (typeof o == "undefined")
      o = this;
    let res = "";
    let value = "";
    let properties = GenericProperties.getAllProperties(o);
    let propName = "";
    for (propName in properties.byName) {
      let p = properties.byName[propName];
      if (p.isWritable) {
        let Mustsave = true;
        if ("NotSavedInXMLAttribute" in p.Attributes)
          Mustsave = !p.Attributes["NotSavedInXMLAttribute"];
        let child = Reflect.get(o, p.name);
        if (GenericProperties.IsStructured(child)) {
          if (Mustsave) {
            res = res + this.indent(2 * deep) + "<" + p.name + ">\r\n" + this.getXml(deep + 1, child) + this.indent(2 * deep) + "</" + p.name + ">\r\n";
          }
        } else {
          if (Mustsave) {
            if (child instanceof YEnumItem) {
              value = child.toString;
            } else {
              let type = typeof child;
              if (type == "object")
                type = child.constructor.name;
              switch (type) {
                case "boolean":
                  value = child ? "TRUE" : "FALSE";
                  break;
                case "number":
                  value = child.toString();
                  break;
                case "string":
                  value = GenericProperties.escapeXml(child);
                  break;
                case YColor.name:
                  value = child.toString();
                  break;
                case doubleNan.name:
                  value = child.value.toString();
                  break;
                case xAxisPosition.name:
                  let it = child;
                  value = it.value.toString() + '" relative="' + (it.relative ? "True" : "False");
                  break;
                case NullYSensor.name:
                case CustomYSensor.name:
                  let s = child;
                  value = s == null || s instanceof NullYSensor ? "NULL" : s.get_hardwareId();
                  break;
                default:
                  throw "XML generation : unhandled type (" + p.type + ")";
              }
            }
            res = res + this.indent(2 * deep) + "<" + p.name + ' value="' + value + '"/>\n';
          }
        }
      }
    }
    return res;
  }
  static IsStructured(o) {
    if (o == null)
      return false;
    if (typeof o === "string" || o instanceof String)
      return false;
    if (typeof o === "number" || o instanceof Number)
      return false;
    if (typeof o === "boolean" || o instanceof Boolean)
      return false;
    if (o instanceof YEnumItem)
      return false;
    if (o instanceof CustomYSensor)
      return false;
    if (o instanceof YColor)
      return false;
    if (o instanceof doubleNan)
      return false;
    if (o instanceof xAxisPosition)
      return false;
    if (Object.getOwnPropertyNames(o).length > 0)
      return true;
    return false;
  }
  static getObjectFromPath(rootTarget, path) {
    let FinalTarget = rootTarget;
    for (let i = 0; i < path.length - 1; i++) {
      let name = path[i];
      let index = "";
      while (name.charCodeAt(name.length - 1) >= 48 && name.charCodeAt(name.length - 1) <= 57) {
        index = name.charAt(name.length - 1) + index;
        name = name.substring(0, name.length - 1);
      }
      if (index == "") {
        FinalTarget = Reflect.get(FinalTarget, name);
      } else {
        let arrayObject = Reflect.get(FinalTarget, name);
        FinalTarget = Reflect.get(arrayObject, parseInt(index));
      }
    }
    return FinalTarget;
  }
  static computePropertyAccess_SFT(WidgetObject, SettingObject, propertySourceName, path) {
    let res = new PropertyAccess();
    res.ttype = "";
    res.stype = "";
    res.finalTarget = null;
    res.terminalSource = null;
    res.terminalSource = GenericProperties.getObjectFromPath(WidgetObject, path);
    let props = GenericProperties.getAllProperties(res.terminalSource);
    if (!(path[path.length - 1] in props.byName))
      return res;
    res.stype = typeof res.terminalSource[path[path.length - 1]];
    if (res.stype == "object" && res.terminalSource[path[path.length - 1]] != null) {
      res.stype = res.terminalSource[path[path.length - 1]].constructor.name;
    }
    res.terminalSource = res.terminalSource[path[path.length - 1]];
    if (res.terminalSource == null)
      return res;
    res.propertyName = propertySourceName;
    res.finalTarget = SettingObject;
    let o = res.finalTarget[propertySourceName];
    res.ttype = typeof o;
    if (res.ttype == "object" && o != null)
      res.ttype = o.constructor.name;
    if (path.length <= 1)
      return res;
    for (let i = 1; i < path.length; i++) {
      res.finalTarget = res.finalTarget[res.propertyName];
      res.propertyName = path[i];
    }
    res.ttype = typeof res.finalTarget[res.propertyName];
    if (res.ttype == "object" && res.finalTarget[res.propertyName] != null)
      res.ttype = res.finalTarget[res.propertyName].constructor.name;
    return res;
  }
  static Reflect_getIndexed(o, indexedProp) {
    let res = Reflect.get(o, indexedProp);
    if (typeof res !== "undefined")
      return res;
    let name = indexedProp;
    let index = "";
    while (name.charCodeAt(name.length - 1) >= 48 && name.charCodeAt(name.length - 1) <= 57) {
      index = name.charAt(name.length - 1) + index;
      name = name.substring(0, name.length - 1);
    }
    if (index == "") {
      return null;
    }
    res = Reflect.get(o, name);
    return Reflect.get(res, parseInt(index));
  }
  static computePropertyAccess(rootTarget, source, propertySourceName, path) {
    let res = new PropertyAccess();
    res.ttype = "";
    res.finalTarget = GenericProperties.getObjectFromPath(rootTarget, path);
    res.terminalSource = source;
    res.terminalSource = Reflect.get(res.terminalSource, propertySourceName);
    for (let i = 1; i < path.length; i++) {
      res.terminalSource = Reflect.get(res.terminalSource, path[i]);
    }
    res.stype = typeof res.terminalSource;
    if (res.stype == "object")
      res.stype = res.terminalSource.constructor.name;
    if (path.length > 0) {
      res.propertyName = path[path.length - 1];
      let o = GenericProperties.Reflect_getIndexed(rootTarget, path[0]);
      if (o == null)
        return null;
      for (let i = 1; i < path.length; i++) {
        try {
          o = GenericProperties.Reflect_getIndexed(o, path[i]);
        } catch (e) {
          debugger;
        }
      }
      res.ttype = typeof o;
      if (res.ttype == "object")
        res.ttype = o.constructor.name;
    } else {
      let targetname = propertySourceName;
      let n = targetname.indexOf("__");
      res.propertyName = targetname.substring(n + 2);
      let o = Reflect.get(rootTarget, res.propertyName);
      res.ttype = typeof o;
      if (res.ttype == "object")
        res.ttype = o.constructor.name;
    }
    return res;
  }
  static newGetProperty(rootTarget, source, propertySourceName, path, filterAllow) {
    let access = GenericProperties.computePropertyAccess(rootTarget, source, propertySourceName, path);
    if (access == null)
      return null;
    return Reflect.get(access.finalTarget, access.propertyName);
  }
  static copyProperty_SFT(rootTarget, source, propertySourceName, path, filterAllow) {
    let ttype = "";
    let stype = "";
    let TerminalSource = null;
    let p = GenericProperties.computePropertyAccess_SFT(rootTarget, source, propertySourceName, path);
    if (p.finalTarget == null)
      return;
    ttype = p.ttype;
    stype = p.stype;
    if (stype == YColor.name && ttype == YColor.name) {
      Reflect.set(p.finalTarget, p.propertyName, p.terminalSource.clone());
    } else if (stype == xAxisPosition.name && ttype == xAxisPosition.name) {
      Reflect.set(p.finalTarget, p.propertyName, p.terminalSource.clone());
    } else if (p.stype == "number" && ttype == doubleNan.name) {
      Reflect.set(p.finalTarget, p.propertyName, new doubleNan(p.terminalSource));
    } else {
      Reflect.set(p.finalTarget, p.propertyName, p.terminalSource);
    }
  }
  static copyProperty_STT(rootTarget, source, propertySourceName, path, filterAllow) {
    let p = GenericProperties.computePropertyAccess(rootTarget, source, propertySourceName, path);
    if (p == null)
      return;
    if (p.stype == doubleNan.name && p.ttype == "number") {
      let v = p.terminalSource.value;
      if (Reflect.get(p.finalTarget, p.propertyName) != v) {
        Reflect.set(p.finalTarget, p.propertyName, v);
        constants.edited = true;
      }
    } else if (p.stype != p.ttype) {
      debugger;
    } else if (p.stype == YColor.name && p.ttype == YColor.name) {
      let color = p.terminalSource;
      if (!color.equal(Reflect.get(p.finalTarget, p.propertyName))) {
        Reflect.set(p.finalTarget, p.propertyName, color.clone());
        constants.edited = true;
      }
    } else if (p.stype == doubleNan.name && p.ttype == doubleNan.name) {
      let v = p.terminalSource;
      if (Reflect.get(p.finalTarget, p.propertyName) != v) {
        Reflect.set(p.finalTarget, p.propertyName, v.clone());
        constants.edited = true;
      }
    } else if (p.stype == xAxisPosition.name && p.ttype == xAxisPosition.name) {
      let x = p.terminalSource;
      let x2 = Reflect.get(p.finalTarget, p.propertyName);
      if (x.relative != x2.relative || x.value != x2.value) {
        Reflect.set(p.finalTarget, p.propertyName, x.clone());
        constants.edited = true;
      }
    } else if (Reflect.get(p.finalTarget, p.propertyName) != p.terminalSource) {
      Reflect.set(p.finalTarget, p.propertyName, p.terminalSource);
      constants.edited = true;
    }
  }
  ApplyAllProperties(target) {
    this.ApplyAllPropertiesEx(target, GenericProperties.NoFilter, 0);
  }
  RefreshAllProperties(target) {
    this.ApplyAllPropertiesEx(target, GenericProperties.NoFilter, 1);
  }
  ApplyProperties(rootSource, rootTarget, fullpropname, sourceValue, path, direction) {
    if (sourceValue instanceof AlarmSection)
      return;
    let sourceproperties = GenericProperties.getAllProperties(this);
    if ("CopyToTarget" in sourceproperties.byName[fullpropname].Attributes) {
      if (!sourceproperties.byName[fullpropname].Attributes["CopyToTarget"]) {
        return;
      }
    }
    if (!GenericProperties.IsStructured(sourceValue)) {
      if (direction == 0) {
        GenericProperties.copyProperty_STT(rootTarget, this, fullpropname, path);
      } else {
        GenericProperties.copyProperty_SFT(rootTarget, this, fullpropname, path);
      }
    } else {
      let path2 = path.slice();
      path2.push("");
      let target = GenericProperties.getObjectFromPath(rootTarget, path2);
      Reflect.set(target, "userData", sourceValue);
      let sourceproperties2 = GenericProperties.getAllProperties(sourceValue);
      for (let subpropname in sourceproperties2.byName) {
        let shouldcopy = true;
        if ("CopyToTarget" in sourceproperties2.byName[subpropname].Attributes) {
          shouldcopy = sourceproperties2.byName[subpropname].Attributes["CopyToTarget"];
        }
        if (sourceproperties2.byName[subpropname].isWritable && shouldcopy) {
          path.push(subpropname);
          this.ApplyProperties(rootSource, rootTarget, fullpropname, Reflect.get(sourceValue, subpropname), path, direction);
          path.splice(path.length - 1, 1);
        }
      }
    }
  }
  static isProperty(proto, propName) {
    let d = Reflect.getOwnPropertyDescriptor(proto, propName);
    let list = Object.getOwnPropertyNames(d);
    for (let i = 0; i < list.length; i++) {
      if (list[i] == "set")
        return true;
      if (list[i] == "get")
        return true;
    }
    return false;
  }
  static isWritable(proto, propName) {
    let d = Reflect.getOwnPropertyDescriptor(proto, propName);
    let list = Object.getOwnPropertyNames(d);
    for (let i = 0; i < list.length; i++) {
      if (list[i] == "set") {
        if (typeof d.set !== "undefined")
          return true;
      }
    }
    return false;
  }
  static getAllProperties(o) {
    if (typeof o === "undefined")
      debugger;
    if (o.hasOwnProperty("PropertiesDescriptionCache")) {
      return o["PropertiesDescriptionCache"];
    }
    let proto = Object.getPrototypeOf(o);
    let res = new PropertiesList();
    let p = proto;
    let entries = [];
    let genealogy = [];
    while (p != null) {
      genealogy.push(p);
      p = Object.getPrototypeOf(p);
    }
    for (let j = genealogy.length - 1; j >= 0; j--) {
      let names = Object.getOwnPropertyNames(genealogy[j]);
      let index = 0;
      for (let i = 0; i < names.length; i++) {
        if (names[i] != "constructor" && !names[i].startsWith("__")) {
          entries.splice(index, 0, new PropDescription(names[i], genealogy[j]));
          index++;
          for (let k = entries.length - 1; k >= index; k--) {
            if (entries[k].name == names[i])
              entries.splice(k, 1);
          }
        }
      }
    }
    for (let i = 0; i < entries.length; i++) {
      if (!entries[i].name.startsWith("ATTR") && entries[i].name != "constructor" && !entries[i].name.startsWith("__")) {
        if (GenericProperties.isProperty(entries[i].prop, entries[i].name)) {
          let d = new PropertyDescriptor(entries[i].name);
          res.byIndex.push(d);
          res.byName[d.name] = d;
          d.isWritable = GenericProperties.isWritable(entries[i].prop, entries[i].name);
          d.isEnum = o[entries[i].name] instanceof YEnumItem;
          d.type = typeof o[entries[i].name];
          if (d.type == "object" && o[entries[i].name] != null) {
            d.type = o[entries[i].name].constructor.name;
          }
        }
      }
    }
    for (let i = 0; i < entries.length; i++) {
      if (entries[i].name.startsWith("ATTR_")) {
        let p2 = entries[i].name.indexOf("__");
        if (p2 < 5)
          debugger;
        let name = entries[i].name.substring(5, p2);
        let attr = entries[i].name.substring(p2 + 2);
        if (typeof res.byName[name] === "undefined")
          debugger;
        try {
          res.byName[name].Attributes[attr] = Reflect.get(o, entries[i].name);
        } catch (e) {
          debugger;
        }
      }
    }
    o["PropertiesDescriptionCache"] = res;
    return res;
  }
  ApplyAllPropertiesEx(target, filter, direction) {
    let properties = GenericProperties.getAllProperties(this);
    for (let fullpropname in properties.byName) {
      if (properties.byName[fullpropname].isWritable) {
        let index = fullpropname.indexOf("_");
        if (index < 0)
          throw "invalid Property name";
        let propType = fullpropname.substring(0, index);
        let propname = fullpropname.substring(index + 1);
        let path = [];
        path.push(propname);
        if (target instanceof YWidget && propType == "Form") {
          this.ApplyProperties(this, target, fullpropname, Reflect.get(this, fullpropname), path, direction);
        }
        if (target instanceof YAngularGauge && propType == "AngularGauge") {
          this.ApplyProperties(this, target, fullpropname, Reflect.get(this, fullpropname), path, direction);
        }
        if (target instanceof YDigitalDisplay && propType == "display") {
          this.ApplyProperties(this, target, fullpropname, Reflect.get(this, fullpropname), path, direction);
        }
        if (target instanceof YSolidGauge && propType == "SolidGauge") {
          this.ApplyProperties(this, target, fullpropname, Reflect.get(this, fullpropname), path, direction);
        }
        if (target instanceof YGraph && propType == "Graph") {
          this.ApplyProperties(this, target, fullpropname, Reflect.get(this, fullpropname), path, direction);
        }
      }
    }
  }
};
GenericProperties.XmlFileVersion = -1;

// obj/full/properties.js
var GenericHints = class {
};
GenericHints.DevConfAffected = " Changing this value will affect the device configuration.";
GenericHints.CheckSensor = "If the sensor you want to use is connected, but not listed or listed as OFFLINE, check USB / Network configuration in the global configuration.";
GenericHints.AnnotationGraph = "Annotation text.  Use \\n for carriage returns. Some variables are available: $DAY$ $MONTH$ $YEAR$ for date, $HOUR$ $MINUTE$ $SECOND$ for time, $AVGVALUE1$ $MINVALUE1$ $MAXVALUE1$ $NAME1$ $UNIT1$  for first series data, $AVGVALUE2$ $MINVALUE2$ $MAXVALUE2$ $NAME2$ $UNIT2$  for second series data and so on";
GenericHints.Annotation = "Annotation text.  Use \\n for carriage returns. Some variables are available: $DAY$ $MONTH$ $YEAR$ for date, $HOUR$ $MINUTE$ $SECOND$ for time, $AVGVALUE$ $MINVALUE$ $MAXVALUE$ $NAME$ $UNIT$ for sensor related data.";
var sensorFreqTypeDescription = class {
  static get AllowedValues() {
    return this._AllowedValues;
  }
};
sensorFreqTypeDescription._AllowedValues = [
  "25/s",
  "10/s",
  "5/s",
  "4/s",
  "3/s",
  "2/s",
  "1/s",
  "60/m",
  "30/m",
  "12/m",
  "6/m",
  "4/m",
  "3/m",
  "2/m",
  "1/m",
  "30/h",
  "12/h",
  "6/h",
  "4/h",
  "3/h",
  "2/h",
  "1/h"
];
var yAxisDescription = class {
  static initialize() {
    let yaxiscount = 0;
    let obj = new GraphFormProperties(null, null);
    let names = Object.getOwnPropertyNames(obj);
    names.forEach((name) => {
      if (name.startsWith("_Graph_yAxes"))
        yaxiscount++;
    });
    for (let i = 0; i < yaxiscount; i++) {
      switch (i) {
        case 0:
          this._AllowedValues.push("1srt Y axis");
          break;
        case 1:
          this._AllowedValues.push("2nd Y axis");
          break;
        case 2:
          this._AllowedValues.push("3rd Y axis");
          break;
        default:
          this._AllowedValues.push((i + 1).toString() + "th Y axis");
          break;
      }
    }
    yAxisDescription.initialized = true;
  }
  static get AllowedValues() {
    if (!yAxisDescription.initialized)
      yAxisDescription.initialize();
    return this._AllowedValues;
  }
};
yAxisDescription._AllowedValues = [];
var AlarmTestTypeDescription = class {
  static get AllowedValues() {
    return this._AllowedValues;
  }
};
AlarmTestTypeDescription._AllowedValues = ["Disabled", ">", ">=", "=", "<=", "<"];
var fontNameTypeDescription = class {
  static fontNameTypeDescription() {
  }
  static get AllowedValues() {
    return this._AllowedValues;
  }
};
fontNameTypeDescription._AllowedValues = [
  "Arial",
  "Brush Script MT",
  "Comic Sans MS",
  "Courier New",
  "Garamond",
  "Georgia",
  "Helvetica",
  "Impact",
  "Tahoma",
  "Times New Roman",
  "Trebuchet MS",
  "Verdana"
];
var sensorPrecisionTypeDescription = class {
  static get AllowedValues() {
    return this._AllowedValues;
  }
};
sensorPrecisionTypeDescription._AllowedValues = ["0", "0.1", "0.12", "0.123"];
var sensorDataTypeDescription = class {
  static get AllowedValues() {
    return this._AllowedValues;
  }
};
sensorDataTypeDescription._AllowedValues = ["Avg values", "Min values", "Max values"];
var GaugeFormProperties = class extends GenericProperties {
  constructor(initData, owner) {
    super(owner);
    this._DataSource_source = sensorsManager.getNullSensor();
    this._DataSource_precision = "0.1";
    this._DataSource_AlarmSection0 = new AlarmSection(0);
    this._DataSource_AlarmSection1 = new AlarmSection(1);
    this._SolidGauge_min = 0;
    this._SolidGauge_max = 100;
    this._SolidGauge_showMinMax = true;
    this._SolidGauge_color1 = YColor.LightGreen;
    this._SolidGauge_color2 = YColor.Red;
    this._SolidGauge_font = new FontDescription("Arial", 20, YColor.Black, false, true);
    this._SolidGauge_minMaxFont = new FontDescription("Arial", 10, YColor.Black, false, true);
    this._SolidGauge_displayMode = YSolidGauge.DisplayMode.DISPLAY90;
    this._SolidGauge_borderColor = YColor.Black;
    this._SolidGauge_borderThickness = 2;
    this._SolidGauge_backgroundColor1 = YColor.FromArgb(255, 240, 240, 240);
    this._SolidGauge_backgroundColor2 = YColor.FromArgb(255, 200, 200, 200);
    this._SolidGauge_thickness = 25;
    this._SolidGauge_maxSpeed = 1;
    this._annotationPanels0 = new AnnotationPanelDescription(GenericPanel.HorizontalAlignPos.CENTER, GenericPanel.VerticalAlignPos.BOTTOM, 0, false, "$NAME$", YColor.FromArgb(0, 127, 127, 127), YColor.FromArgb(0, 127, 127, 127), 10, YColor.FromArgb(255, 0, 0, 0));
    this._annotationPanels1 = new AnnotationPanelDescription(GenericPanel.HorizontalAlignPos.CENTER, GenericPanel.VerticalAlignPos.BOTTOM, 0, false, "$NAME$", YColor.FromArgb(0, 127, 127, 127), YColor.FromArgb(0, 127, 127, 127), 10, YColor.FromArgb(255, 0, 0, 0));
    this.initFromXmlData(initData);
    this.PropagateDataSourceChange();
  }
  PropagateDataSourceChange() {
    this.ownerForm.SourceChanged(this._DataSource_source, 0);
    let props = GenericProperties.getAllProperties(this).byName;
    let name;
    for (name in props) {
      if (name.startsWith("DataSource_AlarmSection")) {
        this[name].setDataSource(this._DataSource_source);
      }
    }
  }
  get ATTR_DataSource_source__DisplayName() {
    return "Sensor";
  }
  get ATTR_DataSource_source__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_source__ParamCategorySummaryAttribute() {
    return "sensorDescription";
  }
  get ATTR_DataSource_source__PreExpandedCategoryAttribute() {
    return true;
  }
  get ATTR_DataSource_source__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_DataSource_source__DescriptionAttribute() {
    return "Yoctopuce sensor feeding the gauge. ";
  }
  get DataSource_source() {
    return this._DataSource_source;
  }
  set DataSource_source(value) {
    let prev = this._DataSource_source;
    this._DataSource_source = value;
    this.PropagateDataSourceChange();
    if (this._DataSource_source != prev)
      constants.edited = true;
  }
  get sensorDescription() {
    return this._DataSource_source instanceof NullYSensor ? "none" : this._DataSource_source.get_friendlyName();
  }
  get isSensorReadOnly() {
    return this._DataSource_source.isReadOnly;
  }
  get ATTR_DataSource_freq__DisplayName() {
    return "Sensor freq";
  }
  get ATTR_DataSource_freq__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_freq__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_DataSource_freq__IsReadonlyCallAttribute() {
    return this.isSensorReadOnly;
  }
  get ATTR_DataSource_freq__AllowedValues() {
    return sensorFreqTypeDescription.AllowedValues;
  }
  get ATTR_DataSource_freq__DescriptionAttribute() {
    return "Sensor data acquisition frequency." + GenericHints.DevConfAffected;
  }
  get DataSource_freq() {
    return this._DataSource_source.get_frequency();
  }
  set DataSource_freq(value) {
    this._DataSource_source.set_frequency(value);
  }
  get ATTR_DataSource_precision__DisplayName() {
    return "Precision";
  }
  get ATTR_DataSource_precision__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_precision__DescriptionAttribute() {
    return "How many digits shown after the decimal point";
  }
  get ATTR_DataSource_precision__AllowedValues() {
    return sensorPrecisionTypeDescription.AllowedValues;
  }
  get DataSource_precision() {
    return this._DataSource_precision;
  }
  set DataSource_precision(value) {
    this._DataSource_precision = value;
  }
  get ATTR_DataSource_AlarmSection0__DisplayName() {
    return "Sensor value alarm 1";
  }
  get ATTR_DataSource_AlarmSection0__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection0__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection0__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_AlarmSection0__DescriptionAttribute() {
    return "Alarm 1 for this data source, expand for more.";
  }
  get DataSource_AlarmSection0() {
    return this._DataSource_AlarmSection0;
  }
  set DataSource_AlarmSection0(value) {
    this._DataSource_AlarmSection0 = value;
  }
  get ATTR_DataSource_AlarmSection1__DisplayName() {
    return "Sensor value alarm 2";
  }
  get ATTR_DataSource_AlarmSection1__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection1__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection1__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_AlarmSection1__DescriptionAttribute() {
    return "Alarm 2 for this data source, expand for more.";
  }
  get DataSource_AlarmSection1() {
    return this._DataSource_AlarmSection1;
  }
  set DataSource_AlarmSection1(value) {
    this._DataSource_AlarmSection1 = value;
  }
  get ATTR_SolidGauge_min__DisplayName() {
    return "Minimum value";
  }
  get ATTR_SolidGauge_min__CategoryAttribute() {
    return "Values range";
  }
  get ATTR_SolidGauge_min__DescriptionAttribute() {
    return "Minimum value displayable by the gauge.";
  }
  get SolidGauge_min() {
    return this._SolidGauge_min;
  }
  set SolidGauge_min(value) {
    this._SolidGauge_min = value;
  }
  get ATTR_SolidGauge_max__DisplayName() {
    return "Maximum value";
  }
  get ATTR_SolidGauge_max__CategoryAttribute() {
    return "Values range";
  }
  get ATTR_SolidGauge_max__DescriptionAttribute() {
    return "Maximum value displayable by the gauge.";
  }
  get SolidGauge_max() {
    return this._SolidGauge_max;
  }
  set SolidGauge_max(value) {
    this._SolidGauge_max = value;
  }
  get ATTR_SolidGauge_showMinMax__DisplayName() {
    return "show  min/max";
  }
  get ATTR_SolidGauge_showMinMax__CategoryAttribute() {
    return "Values range";
  }
  get ATTR_SolidGauge_showMinMax__DescriptionAttribute() {
    return "Show the min / max values.";
  }
  get SolidGauge_showMinMax() {
    return this._SolidGauge_showMinMax;
  }
  set SolidGauge_showMinMax(value) {
    this._SolidGauge_showMinMax = value;
  }
  get ATTR_SolidGauge_color1__DisplayName() {
    return "Min Color";
  }
  get ATTR_SolidGauge_color1__CategoryAttribute() {
    return "Values range";
  }
  get ATTR_SolidGauge_color1__DescriptionAttribute() {
    return "Color for minimum value.";
  }
  get SolidGauge_color1() {
    return this._SolidGauge_color1;
  }
  set SolidGauge_color1(value) {
    this._SolidGauge_color1 = value;
  }
  get ATTR_SolidGauge_color2__DisplayName() {
    return "Max Color";
  }
  get ATTR_SolidGauge_color2__CategoryAttribute() {
    return "Values range";
  }
  get ATTR_SolidGauge_color2__DescriptionAttribute() {
    return "Color for maximum value.";
  }
  get SolidGauge_color2() {
    return this._SolidGauge_color2;
  }
  set SolidGauge_color2(value) {
    this._SolidGauge_color2 = value;
  }
  get ATTR_SolidGauge_font__DisplayName() {
    return "Unit  Font";
  }
  get ATTR_SolidGauge_font__CategoryAttribute() {
    return "Fonts";
  }
  get ATTR_SolidGauge_font__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_SolidGauge_font__DescriptionAttribute() {
    return "Font for displaying the value/status indicator";
  }
  get SolidGauge_font() {
    return this._SolidGauge_font;
  }
  set SolidGauge_font(value) {
    this._SolidGauge_font = value;
  }
  get ATTR_SolidGauge_minMaxFont__DisplayName() {
    return "Min Max  Font";
  }
  get ATTR_SolidGauge_minMaxFont__CategoryAttribute() {
    return "Fonts";
  }
  get ATTR_SolidGauge_minMaxFont__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_SolidGauge_minMaxFont__DescriptionAttribute() {
    return "Font for displaying min/max values";
  }
  get SolidGauge_minMaxFont() {
    return this._SolidGauge_minMaxFont;
  }
  set SolidGauge_minMaxFont(value) {
    this._SolidGauge_minMaxFont = value;
  }
  get ATTR_SolidGauge_displayMode__DisplayName() {
    return "Display mode";
  }
  get ATTR_SolidGauge_displayMode__CategoryAttribute() {
    return "Dial";
  }
  get ATTR_SolidGauge_displayMode__DescriptionAttribute() {
    return "Dial general shape";
  }
  get SolidGauge_displayMode() {
    return this._SolidGauge_displayMode;
  }
  set SolidGauge_displayMode(value) {
    this._SolidGauge_displayMode = value;
  }
  get ATTR_SolidGauge_borderColor__DisplayName() {
    return "Border color";
  }
  get ATTR_SolidGauge_borderColor__CategoryAttribute() {
    return "Dial";
  }
  get ATTR_SolidGauge_borderColor__DescriptionAttribute() {
    return "Dial border color.";
  }
  get SolidGauge_borderColor() {
    return this._SolidGauge_borderColor;
  }
  set SolidGauge_borderColor(value) {
    this._SolidGauge_borderColor = value;
  }
  get ATTR_SolidGauge_borderThickness__DisplayName() {
    return "Border thickness ";
  }
  get ATTR_SolidGauge_borderThickness__CategoryAttribute() {
    return "Dial";
  }
  get ATTR_SolidGauge_borderThickness__DescriptionAttribute() {
    return "Thickness of the dial border";
  }
  get SolidGauge_borderThickness() {
    return this._SolidGauge_borderThickness;
  }
  set SolidGauge_borderThickness(value) {
    this._SolidGauge_borderThickness = value;
  }
  get ATTR_SolidGauge_backgroundColor1__DisplayName() {
    return "Background color 1";
  }
  get ATTR_SolidGauge_backgroundColor1__CategoryAttribute() {
    return "Dial";
  }
  get ATTR_SolidGauge_backgroundColor1__DescriptionAttribute() {
    return "Dial background gradient color 1.";
  }
  get SolidGauge_backgroundColor1() {
    return this._SolidGauge_backgroundColor1;
  }
  set SolidGauge_backgroundColor1(value) {
    this._SolidGauge_backgroundColor1 = value;
  }
  get ATTR_SolidGauge_backgroundColor2__DisplayName() {
    return "Background color 2";
  }
  get ATTR_SolidGauge_backgroundColor2__CategoryAttribute() {
    return "Dial";
  }
  get ATTR_SolidGauge_backgroundColor2__DescriptionAttribute() {
    return "Dial background gradient color 2.";
  }
  get SolidGauge_backgroundColor2() {
    return this._SolidGauge_backgroundColor2;
  }
  set SolidGauge_backgroundColor2(value) {
    this._SolidGauge_backgroundColor2 = value;
  }
  get ATTR_SolidGauge_thickness__DisplayName() {
    return "Dial thickness (%) ";
  }
  get ATTR_SolidGauge_thickness__CategoryAttribute() {
    return "Dial";
  }
  get ATTR_SolidGauge_thickness__DescriptionAttribute() {
    return "Thickness of the dial, in percentage relative to radius";
  }
  get SolidGauge_thickness() {
    return this._SolidGauge_thickness;
  }
  set SolidGauge_thickness(value) {
    this._SolidGauge_thickness = value;
  }
  get ATTR_SolidGauge_maxSpeed__DisplayName() {
    return "Max speed (%) ";
  }
  get ATTR_SolidGauge_maxSpeed__CategoryAttribute() {
    return "Dial";
  }
  get ATTR_SolidGauge_maxSpeed__DescriptionAttribute() {
    return 'Maximum speed of the dial in percentage relative to Max-Min. This is meant to limit "teleporting" effects.';
  }
  get SolidGauge_maxSpeed() {
    return this._SolidGauge_maxSpeed;
  }
  set SolidGauge_maxSpeed(value) {
    this._SolidGauge_maxSpeed = value;
  }
  IsDataSourceAssigned() {
    return !(this._DataSource_source instanceof NullYSensor);
  }
  get ATTR_SolidGauge_annotationPanels0__DisplayName() {
    return "Annotation 1";
  }
  get ATTR_SolidGauge_annotationPanels0__CategoryAttribute() {
    return "Annotations";
  }
  get ATTR_SolidGauge_annotationPanels0__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_SolidGauge_annotationPanels0__DescriptionAttribute() {
    return "Customizable text panels";
  }
  get SolidGauge_annotationPanels0() {
    return this._annotationPanels0;
  }
  set SolidGauge_annotationPanels0(value) {
    this._annotationPanels0 = value;
  }
  get ATTR_SolidGauge_annotationPanels1__DisplayName() {
    return "Annotation 2";
  }
  get ATTR_SolidGauge_annotationPanels1__CategoryAttribute() {
    return "Annotations";
  }
  get ATTR_SolidGauge_annotationPanels1__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_SolidGauge_annotationPanels1__DescriptionAttribute() {
    return "Customizable text panels";
  }
  get SolidGauge_annotationPanels1() {
    return this._annotationPanels1;
  }
  set SolidGauge_annotationPanels1(value) {
    this._annotationPanels1 = value;
  }
};
var AngularGaugeFormProperties = class extends GenericProperties {
  constructor(initData, owner) {
    super(owner);
    this._DataSource_source = sensorsManager.getNullSensor();
    this._DataSource_AlarmSection0 = new AlarmSection(0);
    this._DataSource_AlarmSection1 = new AlarmSection(1);
    this._AngularGauge_min = 0;
    this._AngularGauge_max = 100;
    this._AngularGauge_unitFactor = 1;
    this._AngularGauge_graduation = 10;
    this._AngularGauge_graduationSize = 10;
    this._AngularGauge_graduationOuterRadiusSize = 98;
    this._AngularGauge_graduationThickness = 2;
    this._AngularGauge_graduationColor = YColor.Black;
    this._AngularGauge_graduationFont = new FontDescription("Arial", 20, YColor.Black, false, true);
    this._AngularGauge_subgraduationCount = 5;
    this._AngularGauge_subgraduationSize = 5;
    this._AngularGauge_subgraduationThickness = 1;
    this._AngularGauge_subgraduationColor = YColor.Black;
    this._AngularGauge_needleColor = YColor.Red;
    this._AngularGauge_needleContourColor = YColor.DarkRed;
    this._AngularGauge_needleContourThickness = 1;
    this._AngularGauge_needleLength1 = 90;
    this._AngularGauge_needleLength2 = 15;
    this._AngularGauge_needleWidth = 5;
    this._AngularGauge_needleMaxSpeed = 0.5;
    this._AngularGauge_unitFont = new FontDescription("Arial", 24, YColor.DarkGray, false, true);
    this._AngularGauge_statusFont = new FontDescription("Arial", 24, YColor.DarkGray, false, true);
    this._AngularGauge_borderColor = YColor.Black;
    this._AngularGauge_borderThickness = 5;
    this._AngularGauge_backgroundColor1 = YColor.FromArgb(255, 240, 240, 240);
    this._AngularGauge_backgroundColor2 = YColor.FromArgb(255, 200, 200, 200);
    this._AngularGauge_zones0 = new AngularZoneDescription(0, 50, YColor.LightGreen);
    this._AngularGauge_zones1 = new AngularZoneDescription(50, 80, YColor.Yellow);
    this._AngularGauge_zones2 = new AngularZoneDescription(80, 100, YColor.Red);
    this._annotationPanels0 = new AnnotationPanelDescription(GenericPanel.HorizontalAlignPos.CENTER, GenericPanel.VerticalAlignPos.CENTER, 0, false, "$NAME$", YColor.FromArgb(0, 127, 127, 127), YColor.FromArgb(0, 127, 127, 127), 10, YColor.FromArgb(255, 0, 0, 0));
    this._annotationPanels1 = new AnnotationPanelDescription(GenericPanel.HorizontalAlignPos.CENTER, GenericPanel.VerticalAlignPos.BOTTOM, 0, false, "$NAME$", YColor.FromArgb(0, 127, 127, 127), YColor.FromArgb(0, 127, 127, 127), 10, YColor.FromArgb(255, 0, 0, 0));
    this.initFromXmlData(initData);
    this.PropagateDataSourceChange();
  }
  PropagateDataSourceChange() {
    this.ownerForm.SourceChanged(this._DataSource_source, 0);
    let props = GenericProperties.getAllProperties(this).byName;
    let name;
    for (name in props) {
      if (name.startsWith("DataSource_AlarmSection")) {
        this[name].setDataSource(this._DataSource_source);
      }
    }
  }
  IsDataSourceAssigned() {
    return !(this._DataSource_source instanceof NullYSensor);
  }
  get ATTR_DataSource_source__DisplayName() {
    return "Sensor";
  }
  get ATTR_DataSource_source__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_source__ParamCategorySummaryAttribute() {
    return "sensorDescription";
  }
  get ATTR_DataSource_source__PreExpandedCategoryAttribute() {
    return true;
  }
  get ATTR_DataSource_source__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_DataSource_source__DescriptionAttribute() {
    return "Yoctopuce sensor feeding the gauge. " + GenericHints.CheckSensor;
  }
  get DataSource_source() {
    return this._DataSource_source;
  }
  set DataSource_source(value) {
    let prev = this._DataSource_source;
    this._DataSource_source = value;
    this.PropagateDataSourceChange();
    if (this._DataSource_source != prev)
      constants.edited = true;
  }
  get sensorDescription() {
    return this._DataSource_source instanceof NullYSensor ? "none" : this._DataSource_source.get_friendlyName();
  }
  get isSensorReadOnly() {
    return this._DataSource_source.isReadOnly;
  }
  get ATTR_DataSource_freq__DisplayName() {
    return "Sensor freq";
  }
  get ATTR_DataSource_freq__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_freq__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_DataSource_freq__IsReadonlyCallAttribute() {
    return "isSensorReadOnly";
  }
  get ATTR_DataSource_freq__DescriptionAttribute() {
    return "Sensor data acquisition frequency." + GenericHints.DevConfAffected;
  }
  get ATTR_DataSource_freq__AllowedValues() {
    return sensorFreqTypeDescription.AllowedValues;
  }
  get DataSource_freq() {
    return this._DataSource_source.get_frequency();
  }
  set DataSource_freq(value) {
    this._DataSource_source.set_frequency(value);
  }
  get ATTR_DataSource_AlarmSection0__DisplayName() {
    return "Sensor value alarm 1";
  }
  get ATTR_DataSource_AlarmSection0__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection0__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection0__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_AlarmSection0__DescriptionAttribute() {
    return "Alarm 1 for this data source, expand for more.";
  }
  get DataSource_AlarmSection0() {
    return this._DataSource_AlarmSection0;
  }
  set DataSource_AlarmSection0(value) {
    this._DataSource_AlarmSection0 = value;
  }
  get ATTR_DataSource_AlarmSection1__DisplayName() {
    return "Sensor value alarm 2";
  }
  get ATTR_DataSource_AlarmSection1__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection1__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection1__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_AlarmSection1__DescriptionAttribute() {
    return "Alarm 2 for this data source, expand for more.";
  }
  get DataSource_AlarmSection1() {
    return this._DataSource_AlarmSection1;
  }
  set DataSource_AlarmSection1(value) {
    this._DataSource_AlarmSection1 = value;
  }
  get ATTR_AngularGauge_min__DisplayName() {
    return "Minimum value";
  }
  get ATTR_AngularGauge_min__CategoryAttribute() {
    return "Gauge gradations";
  }
  get ATTR_AngularGauge_min__DescriptionAttribute() {
    return "Minimum value displayable by the gauge.";
  }
  get AngularGauge_min() {
    return this._AngularGauge_min;
  }
  set AngularGauge_min(value) {
    this._AngularGauge_min = value;
  }
  get ATTR_AngularGauge_max__DisplayName() {
    return "Maximum value";
  }
  get ATTR_AngularGauge_max__CategoryAttribute() {
    return "Gauge gradations";
  }
  get ATTR_AngularGauge_max__DescriptionAttribute() {
    return "Maximum value displayable by the gauge.";
  }
  get AngularGauge_max() {
    return this._AngularGauge_max;
  }
  set AngularGauge_max(value) {
    this._AngularGauge_max = value;
  }
  get ATTR_AngularGauge_unitFactor__DisplayName() {
    return "Unit factor";
  }
  get ATTR_AngularGauge_unitFactor__CategoryAttribute() {
    return "Gauge gradations";
  }
  get ATTR_AngularGauge_unitFactor__DescriptionAttribute() {
    return "Data  will be divided by this value before being displayed, this allows simpler gradation marks.";
  }
  get AngularGauge_unitFactor() {
    return this._AngularGauge_unitFactor;
  }
  set AngularGauge_unitFactor(value) {
    this._AngularGauge_unitFactor = value;
  }
  get ATTR_AngularGauge_graduation__DisplayName() {
    return "Main gradation steps";
  }
  get ATTR_AngularGauge_graduation__CategoryAttribute() {
    return "Gauge gradations";
  }
  get ATTR_AngularGauge_graduation__DescriptionAttribute() {
    return "Difference between two consecutive main gradation marks";
  }
  get AngularGauge_graduation() {
    return this._AngularGauge_graduation;
  }
  set AngularGauge_graduation(value) {
    this._AngularGauge_graduation = value;
  }
  get ATTR_AngularGauge_graduationSize__DisplayName() {
    return "Main gradation size (%)";
  }
  get ATTR_AngularGauge_graduationSize__CategoryAttribute() {
    return "Gauge gradations";
  }
  get ATTR_AngularGauge_graduationSize__DescriptionAttribute() {
    return "Main gradation marks size in percent, relative to dial radius";
  }
  get AngularGauge_graduationSize() {
    return this._AngularGauge_graduationSize;
  }
  set AngularGauge_graduationSize(value) {
    this._AngularGauge_graduationSize = value;
  }
  get ATTR_AngularGauge_graduationOuterRadiusSize__DisplayName() {
    return "Main gradation radius (%)";
  }
  get ATTR_AngularGauge_graduationOuterRadiusSize__CategoryAttribute() {
    return "Gauge gradations";
  }
  get ATTR_AngularGauge_graduationOuterRadiusSize__DescriptionAttribute() {
    return "Main gradation marks outer radius in percent, relative to dial radius";
  }
  get AngularGauge_graduationOuterRadiusSize() {
    return this._AngularGauge_graduationOuterRadiusSize;
  }
  set AngularGauge_graduationOuterRadiusSize(value) {
    this._AngularGauge_graduationOuterRadiusSize = value;
  }
  get ATTR_AngularGauge_graduationThickness__DisplayName() {
    return "Main gradation thickness";
  }
  get ATTR_AngularGauge_graduationThickness__CategoryAttribute() {
    return "Gauge gradations";
  }
  get ATTR_AngularGauge_graduationThickness__DescriptionAttribute() {
    return "Main gradation marks thickness";
  }
  get AngularGauge_graduationThickness() {
    return this._AngularGauge_graduationThickness;
  }
  set AngularGauge_graduationThickness(value) {
    this._AngularGauge_graduationThickness = value;
  }
  get ATTR_AngularGauge_graduationColor__DisplayName() {
    return "Main gradation color";
  }
  get ATTR_AngularGauge_graduationColor__CategoryAttribute() {
    return "Gauge gradations";
  }
  get ATTR_AngularGauge_graduationColor__DescriptionAttribute() {
    return "Main gradation marks color.";
  }
  get AngularGauge_graduationColor() {
    return this._AngularGauge_graduationColor;
  }
  set AngularGauge_graduationColor(value) {
    this._AngularGauge_graduationColor = value;
  }
  get ATTR_AngularGauge_graduationFont__DisplayName() {
    return "Main gradation font";
  }
  get ATTR_AngularGauge_graduationFont__CategoryAttribute() {
    return "Gauge gradations";
  }
  get ATTR_AngularGauge_graduationFont__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_AngularGauge_graduationFont__DescriptionAttribute() {
    return "Font used for gradation labels";
  }
  get AngularGauge_graduationFont() {
    return this._AngularGauge_graduationFont;
  }
  set AngularGauge_graduationFont(value) {
    this._AngularGauge_graduationFont = value;
  }
  get ATTR_AngularGauge_subgraduationCount__DisplayName() {
    return "Sub-gradation count";
  }
  get ATTR_AngularGauge_subgraduationCount__CategoryAttribute() {
    return "Gauge gradations";
  }
  get ATTR_AngularGauge_subgraduationCount__DescriptionAttribute() {
    return "How many sub-gradation (+1) marks between two consecutive main graduation marks";
  }
  get AngularGauge_subgraduationCount() {
    return this._AngularGauge_subgraduationCount;
  }
  set AngularGauge_subgraduationCount(value) {
    this._AngularGauge_subgraduationCount = value;
  }
  get ATTR_AngularGauge_subgraduationSize__DisplayName() {
    return "Sub-gradation size (%)";
  }
  get ATTR_AngularGauge_subgraduationSize__CategoryAttribute() {
    return "Gauge gradations";
  }
  get ATTR_AngularGauge_subgraduationSize__DescriptionAttribute() {
    return "Sub-gradation marks size in percent, relative to dial radius";
  }
  get AngularGauge_subgraduationSize() {
    return this._AngularGauge_subgraduationSize;
  }
  set AngularGauge_subgraduationSize(value) {
    this._AngularGauge_subgraduationSize = value;
  }
  get ATTR_AngularGauge_subgraduationThickness__DisplayName() {
    return "Sub-gradation thickness";
  }
  get ATTR_AngularGauge_subgraduationThickness__CategoryAttribute() {
    return "Gauge gradations";
  }
  get ATTR_AngularGauge_subgraduationThickness__DescriptionAttribute() {
    return "Sub-gradation marks thickness";
  }
  get AngularGauge_subgraduationThickness() {
    return this._AngularGauge_subgraduationThickness;
  }
  set AngularGauge_subgraduationThickness(value) {
    this._AngularGauge_subgraduationThickness = value;
  }
  get ATTR_AngularGauge_subgraduationColor__DisplayName() {
    return "Sub-gradation color";
  }
  get ATTR_AngularGauge_subgraduationColor__CategoryAttribute() {
    return "Gauge gradations";
  }
  get ATTR_AngularGauge_subgraduationColor__DescriptionAttribute() {
    return "Sub-gradation marks color.";
  }
  get AngularGauge_subgraduationColor() {
    return this._AngularGauge_subgraduationColor;
  }
  set AngularGauge_subgraduationColor(value) {
    this._AngularGauge_subgraduationColor = value;
  }
  get ATTR_AngularGauge_needleColor__DisplayName() {
    return "Needle color";
  }
  get ATTR_AngularGauge_needleColor__CategoryAttribute() {
    return "Needle";
  }
  get ATTR_AngularGauge_needleColor__DescriptionAttribute() {
    return "Needle filling color.";
  }
  get AngularGauge_needleColor() {
    return this._AngularGauge_needleColor;
  }
  set AngularGauge_needleColor(value) {
    this._AngularGauge_needleColor = value;
  }
  get ATTR_AngularGauge_needleContourColor__DisplayName() {
    return "Needle contour color";
  }
  get ATTR_AngularGauge_needleContourColor__CategoryAttribute() {
    return "Needle";
  }
  get ATTR_AngularGauge_needleContourColor__DescriptionAttribute() {
    return "Needle contour color.";
  }
  get AngularGauge_needleContourColor() {
    return this._AngularGauge_needleContourColor;
  }
  set AngularGauge_needleContourColor(value) {
    this._AngularGauge_needleContourColor = value;
  }
  get ATTR_AngularGauge_needleContourThickness__DisplayName() {
    return "Needle contour thickness";
  }
  get ATTR_AngularGauge_needleContourThickness__CategoryAttribute() {
    return "Needle";
  }
  get ATTR_AngularGauge_needleContourThickness__DescriptionAttribute() {
    return "Thickness of the needle contour";
  }
  get AngularGauge_needleContourThickness() {
    return this._AngularGauge_needleContourThickness;
  }
  set AngularGauge_needleContourThickness(value) {
    this._AngularGauge_needleContourThickness = value;
  }
  get ATTR_AngularGauge_needleLength1__DisplayName() {
    return "Needle main size (%)";
  }
  get ATTR_AngularGauge_needleLength1__CategoryAttribute() {
    return "Needle";
  }
  get ATTR_AngularGauge_needleLength1__DescriptionAttribute() {
    return "Length of the needle part pointing to gradations, in % relative to radius";
  }
  get AngularGauge_needleLength1() {
    return this._AngularGauge_needleLength1;
  }
  set AngularGauge_needleLength1(value) {
    this._AngularGauge_needleLength1 = value;
  }
  get ATTR_AngularGauge_needleLength2__DisplayName() {
    return "Needle foot size (%)";
  }
  get ATTR_AngularGauge_needleLength2__CategoryAttribute() {
    return "Needle";
  }
  get ATTR_AngularGauge_needleLength2__DescriptionAttribute() {
    return "Length of the needle part not pointing to gradations, in % relative to radius";
  }
  get AngularGauge_needleLength2() {
    return this._AngularGauge_needleLength2;
  }
  set AngularGauge_needleLength2(value) {
    this._AngularGauge_needleLength2 = value;
  }
  get ATTR_AngularGauge_needleWidth__DisplayName() {
    return "Needle width (%)";
  }
  get ATTR_AngularGauge_needleWidth__CategoryAttribute() {
    return "Needle";
  }
  get ATTR_AngularGauge_needleWidth__DescriptionAttribute() {
    return "Width of the needle, in % relative to radius";
  }
  get AngularGauge_needleWidth() {
    return this._AngularGauge_needleWidth;
  }
  set AngularGauge_needleWidth(value) {
    this._AngularGauge_needleWidth = value;
  }
  get ATTR_AngularGauge_needleMaxSpeed__DisplayName() {
    return "Needle max speed (%)";
  }
  get ATTR_AngularGauge_needleMaxSpeed__CategoryAttribute() {
    return "Needle";
  }
  get ATTR_AngularGauge_needleMaxSpeed__DescriptionAttribute() {
    return 'Needle Maximum speed, in % relative to (max-min). This is meant to limit "teleporting" effects.';
  }
  get AngularGauge_needleMaxSpeed() {
    return this._AngularGauge_needleMaxSpeed;
  }
  set AngularGauge_needleMaxSpeed(value) {
    this._AngularGauge_needleMaxSpeed = value;
  }
  get ATTR_AngularGauge_unitFont__DisplayName() {
    return "Unit Line Font";
  }
  get ATTR_AngularGauge_unitFont__CategoryAttribute() {
    return "Text lines";
  }
  get ATTR_AngularGauge_unitFont__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_AngularGauge_unitFont__DescriptionAttribute() {
    return "Font used in the text line describing unit";
  }
  get AngularGauge_unitFont() {
    return this._AngularGauge_unitFont;
  }
  set AngularGauge_unitFont(value) {
    this._AngularGauge_unitFont = value;
  }
  get ATTR_AngularGauge_statusFont__DisplayName() {
    return "Status Line Font";
  }
  get ATTR_AngularGauge_statusFont__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_AngularGauge_statusFont__CategoryAttribute() {
    return "Text lines";
  }
  get ATTR_AngularGauge_statusFont__DescriptionAttribute() {
    return "Font used in the text line gauge status";
  }
  get AngularGauge_statusFont() {
    return this._AngularGauge_statusFont;
  }
  set AngularGauge_statusFont(value) {
    this._AngularGauge_statusFont = value;
  }
  get ATTR_AngularGauge_borderColor__DisplayName() {
    return "Border color";
  }
  get ATTR_AngularGauge_borderColor__CategoryAttribute() {
    return "Dial";
  }
  get ATTR_AngularGauge_borderColor__DescriptionAttribute() {
    return "Dial border color.";
  }
  get AngularGauge_borderColor() {
    return this._AngularGauge_borderColor;
  }
  set AngularGauge_borderColor(value) {
    this._AngularGauge_borderColor = value;
  }
  get ATTR_AngularGauge_borderThickness__DisplayName() {
    return "Border thickness ";
  }
  get ATTR_AngularGauge_borderThickness__CategoryAttribute() {
    return "Dial";
  }
  get ATTR_AngularGauge_borderThickness__DescriptionAttribute() {
    return "Thickness of the dial border";
  }
  get AngularGauge_borderThickness() {
    return this._AngularGauge_borderThickness;
  }
  set AngularGauge_borderThickness(value) {
    this._AngularGauge_borderThickness = value;
  }
  get ATTR_AngularGauge_backgroundColor1__DisplayName() {
    return "Background color 1";
  }
  get ATTR_AngularGauge_backgroundColor1__CategoryAttribute() {
    return "Dial";
  }
  get ATTR_AngularGauge_backgroundColor1__DescriptionAttribute() {
    return "Dial background gradient color 1.";
  }
  get AngularGauge_backgroundColor1() {
    return this._AngularGauge_backgroundColor1;
  }
  set AngularGauge_backgroundColor1(value) {
    this._AngularGauge_backgroundColor1 = value;
  }
  get ATTR_AngularGauge_backgroundColor2__DisplayName() {
    return "Background color 2";
  }
  get ATTR_AngularGauge_backgroundColor2__CategoryAttribute() {
    return "Dial";
  }
  get ATTR_AngularGauge_backgroundColor2__DescriptionAttribute() {
    return "Dial background gradient color 2.";
  }
  get AngularGauge_backgroundColor2() {
    return this._AngularGauge_backgroundColor2;
  }
  set AngularGauge_backgroundColor2(value) {
    this._AngularGauge_backgroundColor2 = value;
  }
  get ATTR_AngularGauge_zones0__DisplayName() {
    return "Zone 1";
  }
  get ATTR_AngularGauge_zones0__CategoryAttribute() {
    return "Zones";
  }
  get ATTR_AngularGauge_zones0__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_AngularGauge_zones0__DescriptionAttribute() {
    return "Zone 1 parameters";
  }
  get AngularGauge_zones0() {
    return this._AngularGauge_zones0;
  }
  set AngularGauge_zones0(value) {
    this._AngularGauge_zones0 = value;
  }
  get ATTR_AngularGauge_zones1__DisplayName() {
    return "Zone 2";
  }
  get ATTR_AngularGauge_zones1__CategoryAttribute() {
    return "Zones";
  }
  get ATTR_AngularGauge_zones1__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_AngularGauge_zones1__DescriptionAttribute() {
    return "Zone 2 parameters";
  }
  get AngularGauge_zones1() {
    return this._AngularGauge_zones1;
  }
  set AngularGauge_zones1(value) {
    this._AngularGauge_zones1 = value;
  }
  get ATTR_AngularGauge_zones2__DisplayName() {
    return "Zone 2";
  }
  get ATTR_AngularGauge_zones2__CategoryAttribute() {
    return "Zones";
  }
  get ATTR_AngularGauge_zones2__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_AngularGauge_zones2__DescriptionAttribute() {
    return "Zone 2 parameters";
  }
  get AngularGauge_zones2() {
    return this._AngularGauge_zones2;
  }
  set AngularGauge_zones2(value) {
    this._AngularGauge_zones2 = value;
  }
  get ATTR_AngularGauge_annotationPanels0__DisplayName() {
    return "Annotation 1";
  }
  get ATTR_AngularGauge_annotationPanels0__CategoryAttribute() {
    return "Annotations";
  }
  get ATTR_AngularGauge_annotationPanels0__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_AngularGauge_annotationPanels0__DescriptionAttribute() {
    return "Customizable text panels";
  }
  get AngularGauge_annotationPanels0() {
    return this._annotationPanels0;
  }
  set AngularGauge_annotationPanels0(value) {
    this._annotationPanels0 = value;
  }
  get ATTR_AngularGauge_annotationPanels1__DisplayName() {
    return "Annotation 2";
  }
  get ATTR_AngularGauge_annotationPanels1__CategoryAttribute() {
    return "Annotations";
  }
  get ATTR_AngularGauge_annotationPanels1__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_AngularGauge_annotationPanels1__DescriptionAttribute() {
    return "Customizable text panels";
  }
  get AngularGauge_annotationPanels1() {
    return this._annotationPanels1;
  }
  set AngularGauge_annotationPanels1(value) {
    this._annotationPanels1 = value;
  }
};
var ZoneDescription = class {
  constructor(min, max, color) {
    this._visible = false;
    this._min = min;
    this._max = max;
    this._color = color;
  }
  get summary() {
    return this._visible ? this._min.toString() + ".." + this._max.toString() : "Disabled";
  }
  get ATTR_visible__DisplayName() {
    return "Visible";
  }
  get ATTR_visible__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_visible__DescriptionAttribute() {
    return "Zone visibility.";
  }
  get visible() {
    return this._visible;
  }
  set visible(value) {
    this._visible = value;
  }
  get ATTR_min__DisplayName() {
    return "Minimum value";
  }
  get ATTR_min__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_min__DescriptionAttribute() {
    return "Zone minimum value";
  }
  get min() {
    return this._min;
  }
  set min(value) {
    this._min = value;
  }
  get ATTR_max__DisplayName() {
    return "Maximum value";
  }
  get ATTR_max__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_max__DescriptionAttribute() {
    return "Zone maximum value";
  }
  get max() {
    return this._max;
  }
  set max(value) {
    this._max = value;
  }
  get ATTR_color__DisplayName() {
    return "Color";
  }
  get ATTR_color__DescriptionAttribute() {
    return "Zone color";
  }
  get color() {
    return this._color;
  }
  set color(value) {
    this._color = value;
  }
};
var AngularZoneDescription = class {
  constructor(min, max, color) {
    this._width = 5;
    this._outerRadius = 98;
    this._visible = false;
    this._min = min;
    this._max = max;
    this._color = color;
  }
  get summary() {
    return this._visible ? this._min.toString() + ".." + this._max.toString() : "Disabled";
  }
  get ATTR_visible__DisplayName() {
    return "Visible";
  }
  get ATTR_visible__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_visible__DescriptionAttribute() {
    return "Zone visibility.";
  }
  get visible() {
    return this._visible;
  }
  set visible(value) {
    this._visible = value;
  }
  get ATTR_min__DisplayName() {
    return "Minimum value";
  }
  get ATTR_min__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_min__DescriptionAttribute() {
    return "Zone minimum value";
  }
  get min() {
    return this._min;
  }
  set min(value) {
    this._min = value;
  }
  get ATTR_max__DisplayName() {
    return "Maximum value";
  }
  get ATTR_max__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_max__DescriptionAttribute() {
    return "Zone maximum value";
  }
  get max() {
    return this._max;
  }
  set max(value) {
    this._max = value;
  }
  get ATTR_color__DisplayName() {
    return "Color";
  }
  get ATTR_color__DescriptionAttribute() {
    return "Zone color";
  }
  get color() {
    return this._color;
  }
  set color(value) {
    this._color = value;
  }
  get ATTR_outerRadius__DisplayName() {
    return "Outer radius (%)";
  }
  get ATTR_outerRadius__DescriptionAttribute() {
    return "Zone outer radius, in percentage relative to dial radius ";
  }
  get outerRadius() {
    return this._outerRadius;
  }
  set outerRadius(value) {
    this._outerRadius = value;
  }
  get ATTR_width__DisplayName() {
    return "Width (%)";
  }
  get ATTR_width__DescriptionAttribute() {
    return "Zone  width, in percentage relative to dial radius ";
  }
  get width() {
    return this._width;
  }
  set width(value) {
    this._width = value;
  }
};
var FontDescription = class {
  constructor(name, size, color, italic, bold) {
    this._name = name;
    this._size = size;
    this._color = color;
    this._italic = italic;
    this._bold = bold;
  }
  ToString() {
    return this._name + " " + this._size.toString();
  }
  get summary() {
    return this._name + " " + this._size.toString();
  }
  get ATTR_name__DisplayName() {
    return "Font name";
  }
  get ATTR_name__AllowedValues() {
    return fontNameTypeDescription.AllowedValues;
  }
  get ATTR_name__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_name__DescriptionAttribute() {
    return "Name of the font";
  }
  get name() {
    return this._name;
  }
  set name(value) {
    this._name = value;
  }
  get ATTR_size__DisplayName() {
    return "Font size";
  }
  get ATTR_size__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_size__DescriptionAttribute() {
    return "Size of the font";
  }
  get size() {
    return this._size;
  }
  set size(value) {
    this._size = Math.round(100 * value) / 100;
  }
  get ATTR_color__DisplayName() {
    return "Font color";
  }
  get ATTR_color__DescriptionAttribute() {
    return "Color of the font.";
  }
  get color() {
    return this._color;
  }
  set color(value) {
    this._color = value;
  }
  get ATTR_italic__DisplayName() {
    return "Italic";
  }
  get ATTR_italic__DescriptionAttribute() {
    return "Is the font style italic?.";
  }
  get italic() {
    return this._italic;
  }
  set italic(value) {
    this._italic = value;
  }
  get ATTR_bold__DisplayName() {
    return "Bold";
  }
  get ATTR_bold__DescriptionAttribute() {
    return "Is the font style bold?.";
  }
  get bold() {
    return this._bold;
  }
  set bold(value) {
    this._bold = value;
  }
};
var digitalDisplayFormProperties = class extends GenericProperties {
  constructor(initData, owner) {
    super(owner);
    this._DataSource_source = sensorsManager.getNullSensor();
    this._DataSource_precision = "0.1";
    this._DataSource_AlarmSection0 = new AlarmSection(0);
    this._DataSource_AlarmSection1 = new AlarmSection(1);
    this._font = new FontDescription("Arial", 48, YColor.LightGreen, false, true);
    this._display_backgroundColor1 = YColor.Black;
    this._display_backgroundColor2 = YColor.Black;
    this._hrzAlignment = YDigitalDisplay.HrzAlignment.RIGHT;
    this._hrzAlignmentOfset = 5;
    this._outOfRangeMin = new doubleNan(Number.NaN);
    this._outOfRangeMax = new doubleNan(Number.NaN);
    this._outOfRangeColor = YColor.Red;
    this._annotationPanels0 = new AnnotationPanelDescription(GenericPanel.HorizontalAlignPos.CENTER, GenericPanel.VerticalAlignPos.CENTER, 0, false, "$NAME$", YColor.FromArgb(0, 127, 127, 127), YColor.FromArgb(0, 127, 127, 127), 10, YColor.FromArgb(255, 0, 0, 0));
    this._annotationPanels1 = new AnnotationPanelDescription(GenericPanel.HorizontalAlignPos.CENTER, GenericPanel.VerticalAlignPos.BOTTOM, 0, false, "$NAME$", YColor.FromArgb(0, 127, 127, 127), YColor.FromArgb(0, 127, 127, 127), 10, YColor.FromArgb(255, 0, 0, 0));
    this.initFromXmlData(initData);
    this.PropagateDataSourceChange();
  }
  PropagateDataSourceChange() {
    this.ownerForm.SourceChanged(this._DataSource_source, 0);
    let props = GenericProperties.getAllProperties(this).byName;
    let name;
    for (name in props) {
      if (name.startsWith("DataSource_AlarmSection")) {
        this[name].setDataSource(this._DataSource_source);
      }
    }
  }
  IsDataSourceAssigned() {
    return !(this._DataSource_source instanceof NullYSensor);
  }
  get ATTR_DataSource_source__DisplayName() {
    return "Sensor";
  }
  get ATTR_DataSource_source__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_source__ParamCategorySummaryAttribute() {
    return "sensorDescription";
  }
  get ATTR_DataSource_source__PreExpandedCategoryAttribute() {
    return true;
  }
  get ATTR_DataSource_source__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_DataSource_source__DescriptionAttribute() {
    return "Yoctopuce sensor feeding the display. " + GenericHints.CheckSensor;
  }
  get DataSource_source() {
    return this._DataSource_source;
  }
  set DataSource_source(value) {
    let prev = this._DataSource_source;
    this._DataSource_source = value;
    this.PropagateDataSourceChange();
    if (this._DataSource_source != prev)
      constants.edited = true;
  }
  get isSensorReadOnly() {
    return this._DataSource_source.isReadOnly;
  }
  get sensorDescription() {
    return this._DataSource_source instanceof NullYSensor ? "none" : this._DataSource_source.get_friendlyName();
  }
  get ATTR_DataSource_freq__DisplayName() {
    return "Sensor freq";
  }
  get ATTR_DataSource_freq__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_freq__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_DataSource_freq__IsReadonlyCallAttribute() {
    return "isSensorReadOnly";
  }
  get ATTR_DataSource_freq__DescriptionAttribute() {
    return "Sensor data acquisition frequency." + GenericHints.DevConfAffected;
  }
  get ATTR_DataSource_freq__AllowedValues() {
    return sensorFreqTypeDescription.AllowedValues;
  }
  get DataSource_freq() {
    return this._DataSource_source.get_frequency();
  }
  set DataSource_freq(value) {
    this._DataSource_source.set_frequency(value);
  }
  get ATTR_DataSource_precision__DisplayName() {
    return "Precision";
  }
  get ATTR_DataSource_precision__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_precision__DescriptionAttribute() {
    return "How many digits shown after the decimal point.";
  }
  get ATTR_DataSource_precision__AllowedValues() {
    return sensorPrecisionTypeDescription.AllowedValues;
  }
  get DataSource_precision() {
    return this._DataSource_precision;
  }
  set DataSource_precision(value) {
    this._DataSource_precision = value;
  }
  get ATTR_DataSource_AlarmSection0__DisplayName() {
    return "Sensor value alarm 1";
  }
  get ATTR_DataSource_AlarmSection0__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection0__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection0__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_AlarmSection0__DescriptionAttribute() {
    return "Alarm 1 for this data source, expand for more.";
  }
  get DataSource_AlarmSection0() {
    return this._DataSource_AlarmSection0;
  }
  set DataSource_AlarmSection0(value) {
    this._DataSource_AlarmSection0 = value;
  }
  get ATTR_DataSource_AlarmSection1__DisplayName() {
    return "Sensor value alarm 2";
  }
  get ATTR_DataSource_AlarmSection1__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection1__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection1__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_AlarmSection1__DescriptionAttribute() {
    return "Alarm 2 for this data source, expand for more.";
  }
  get DataSource_AlarmSection1() {
    return this._DataSource_AlarmSection1;
  }
  set DataSource_AlarmSection1(value) {
    this._DataSource_AlarmSection1 = value;
  }
  get ATTR_display_font__DisplayName() {
    return "Font";
  }
  get ATTR_display_font__CategoryAttribute() {
    return "Display";
  }
  get ATTR_display_font__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_display_font__DescriptionAttribute() {
    return "Display font";
  }
  get display_font() {
    return this._font;
  }
  set display_font(value) {
    this._font = value;
  }
  get ATTR_display_backgroundColor1__DisplayName() {
    return "Background color 1";
  }
  get ATTR_display_backgroundColor1__CategoryAttribute() {
    return "Display";
  }
  get ATTR_display_backgroundColor1__DescriptionAttribute() {
    return "Display background gradient color 1.";
  }
  get display_backgroundColor1() {
    return this._display_backgroundColor1;
  }
  set display_backgroundColor1(value) {
    this._display_backgroundColor1 = value;
  }
  get ATTR_display_backgroundColor2__DisplayName() {
    return "Background color 2";
  }
  get ATTR_display_backgroundColor2__CategoryAttribute() {
    return "Display";
  }
  get ATTR_display_backgroundColor2__DescriptionAttribute() {
    return "Display background gradient color 2.";
  }
  get display_backgroundColor2() {
    return this._display_backgroundColor2;
  }
  set display_backgroundColor2(value) {
    this._display_backgroundColor2 = value;
  }
  get ATTR_display_hrzAlignment__DisplayName() {
    return "Hrz alignment method";
  }
  get ATTR_display_hrzAlignment__CategoryAttribute() {
    return "Display";
  }
  get ATTR_display_hrzAlignment__DescriptionAttribute() {
    return "Horizontal alignment method";
  }
  get display_hrzAlignment() {
    return this._hrzAlignment;
  }
  set display_hrzAlignment(value) {
    this._hrzAlignment = value;
  }
  get ATTR_display_hrzAlignmentOfset__DisplayName() {
    return "Hrz alignment offset";
  }
  get ATTR_display_hrzAlignmentOfset__CategoryAttribute() {
    return "Display";
  }
  get ATTR_display_hrzAlignmentOfset__DescriptionAttribute() {
    return "Horizontal alignment offset in percentage. No effect when chosen horizontal alignment is CENTER";
  }
  get display_hrzAlignmentOfset() {
    return this._hrzAlignmentOfset;
  }
  set display_hrzAlignmentOfset(value) {
    this._hrzAlignmentOfset = value;
  }
  get ATTR_display_outOfRangeMin__DisplayName() {
    return "Minimum value";
  }
  get ATTR_display_outOfRangeMin__CategoryAttribute() {
    return "Range Control";
  }
  get ATTR_display_outOfRangeMin__DescriptionAttribute() {
    return `Regular range minimum value. if value goes  outside regular  range, color will turn to "Out of range Color".Leave blank if you don't want to define such a range. `;
  }
  get display_outOfRangeMin() {
    return this._outOfRangeMin;
  }
  set display_outOfRangeMin(value) {
    this._outOfRangeMin = value;
  }
  get ATTR_display_outOfRangeMax__DisplayName() {
    return "Maximum value";
  }
  get ATTR_display_outOfRangeMax__CategoryAttribute() {
    return "Range Control";
  }
  get ATTR_display_outOfRangeMax__DescriptionAttribute() {
    return `Regular range minimum value. if value goes  outside regular  range, color will turn to "Out of range Color".Leave blank if you don't want to define such a range. `;
  }
  get display_outOfRangeMax() {
    return this._outOfRangeMax;
  }
  set display_outOfRangeMax(value) {
    this._outOfRangeMax = value;
  }
  get ATTR_display_outOfRangeColor__DisplayName() {
    return "Out of range Color";
  }
  get ATTR_display_outOfRangeColor__CategoryAttribute() {
    return "Range Control";
  }
  get ATTR_display_outOfRangeColor__DescriptionAttribute() {
    return "Digits color when value is out of range.";
  }
  get display_outOfRangeColor() {
    return this._outOfRangeColor;
  }
  set display_outOfRangeColor(value) {
    this._outOfRangeColor = value;
  }
  get ATTR_display_annotationPanels0__DisplayName() {
    return "Annotation 1";
  }
  get ATTR_display_annotationPanels0__CategoryAttribute() {
    return "Annotations";
  }
  get ATTR_display_annotationPanels0__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_display_annotationPanels0__DescriptionAttribute() {
    return "Customizable text panels";
  }
  get display_annotationPanels0() {
    return this._annotationPanels0;
  }
  set display_annotationPanels0(value) {
    this._annotationPanels0 = value;
  }
  get ATTR_display_annotationPanels1__DisplayName() {
    return "Annotation 2";
  }
  get ATTR_display_annotationPanels1__CategoryAttribute() {
    return "Annotations";
  }
  get ATTR_display_annotationPanels1__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_display_annotationPanels1__DescriptionAttribute() {
    return "Customizable text panels";
  }
  get display_annotationPanels1() {
    return this._annotationPanels1;
  }
  set display_annotationPanels1(value) {
    this._annotationPanels1 = value;
  }
};
var AlarmSection = class {
  constructor(index) {
    this._sensor = sensorsManager.getNullSensor();
    this._index = 0;
    this._index = index;
  }
  get summary() {
    let c = this._sensor.getAlarmCondition(this._index);
    if (c == 0)
      return "Disabled";
    return "Enabled";
  }
  get ATTR_source__DisplayName() {
    return "Data source type";
  }
  get ATTR_source__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_source__AllowedValues() {
    return sensorDataTypeDescription.AllowedValues;
  }
  get ATTR_source__DescriptionAttribute() {
    return "Alarm sensor data source (Average, minimum or maximum value during last interval)";
  }
  get source() {
    return this._sensor.getAlarmSource(this._index);
  }
  set source(value) {
    this._sensor.setAlarmSource(this._index, value);
  }
  get ATTR_condition__DisplayName() {
    return "Test Condition";
  }
  get ATTR_condition__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_condition__AllowedValues() {
    return AlarmTestTypeDescription.AllowedValues;
  }
  get ATTR_condition__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_condition__DescriptionAttribute() {
    return "Alarm trigger condition";
  }
  get condition() {
    return this._sensor.getAlarmCondition(this._index);
  }
  set condition(value) {
    this._sensor.setAlarmCondition(this._index, value);
  }
  setDataSource(sensor) {
    this._sensor = sensor;
  }
  get ATTR_value__DisplayName() {
    return "Test Value";
  }
  get ATTR_value__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_value__DescriptionAttribute() {
    return "Value for the Alarm trigger";
  }
  get value() {
    return this._sensor.getAlarmValue(this._index);
  }
  set value(value) {
    this._sensor.setAlarmValue(this._index, value);
  }
  get ATTR_commandLine__DisplayName() {
    return "Trigger action";
  }
  get ATTR_commandLine__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_commandLine__DescriptionAttribute() {
    return "Javascript snippet executed in your browser each time the alarm is triggered, you can use the following variables: $SENSORVALUE$, $UNIT$, $HWDID$, $NAME$, $CONDITION$, $TRIGGER$, $DATATYPE$, $NOW$. Example : <tt>alarm('Warning $NAME$ = $SENSORVALUE$!');</tt>. You can check logs to find out if your alarm code works.";
  }
  get commandLine() {
    return this._sensor.getAlarmCommandline(this._index);
  }
  set commandLine(value) {
    this._sensor.setAlarmCommandline(this._index, value);
  }
  get ATTR_delay__DisplayName() {
    return "Trigger delay";
  }
  get ATTR_delay__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_delay__DescriptionAttribute() {
    return "Minimum delay, in seconds, between two alarms. Think carefully and make sure you won't create alarm storms.";
  }
  get delay() {
    return this._sensor.getAlarmDelay(this._index);
  }
  set delay(value) {
    this._sensor.setAlarmDelay(this._index, value);
  }
};
var ChartSerie = class {
  constructor(defaultColor) {
    this.ownerForm = null;
    this.index = -1;
    this.dataloggerAlreadyLoaded = false;
    this._DataSource_source = sensorsManager.getNullSensor();
    this._DataType = 0;
    this._thickness = 2;
    this._legend = "";
    this._color = YColor.Red;
    this._yAxisIndex = 0;
    this._DataSource_AlarmSection0 = new AlarmSection(0);
    this._DataSource_AlarmSection1 = new AlarmSection(1);
    this._color = defaultColor;
  }
  get summary() {
    return this._DataSource_source instanceof NullYSensor ? "none" : this._DataSource_source.get_friendlyName() + (this._DataSource_source.isOnline() ? "" : " - OFFLINE");
  }
  Init(owner, serieIndex) {
    this.ownerForm = owner;
    this.index = serieIndex;
    this.PropagateDataSourceChange(this._DataSource_source);
  }
  PropagateDataSourceChange(value) {
    this.ownerForm.SourceChanged(this._DataSource_source, this.index);
    let props = GenericProperties.getAllProperties(this).byName;
    let name;
    for (name in props) {
      if (name.startsWith("DataSource_AlarmSection")) {
        this[name].setDataSource(this._DataSource_source);
      }
    }
  }
  get ATTR_DataSource_source__DisplayName() {
    return "Sensor";
  }
  get ATTR_DataSource_source__CopyToTarget() {
    return false;
  }
  get ATTR_DataSource_source__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_DataSource_source__DescriptionAttribute() {
    return "Yoctopuce sensor feeding the graph. " + GenericHints.CheckSensor;
  }
  get DataSource_source() {
    return this._DataSource_source;
  }
  set DataSource_source(value) {
    let prev = this._DataSource_source;
    this._DataSource_source = value;
    if (this._DataSource_source != prev)
      constants.edited = true;
    if (this.ownerForm != null)
      this.PropagateDataSourceChange(this._DataSource_source);
  }
  get isSensorReadOnly() {
    return this._DataSource_source.isReadOnly;
  }
  get ATTR_DataSource_freq__DisplayName() {
    return "Sensor frequency";
  }
  get ATTR_DataSource_freq__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_DataSource_freq__CopyToTarget() {
    return false;
  }
  get ATTR_DataSource_freq__IsReadonlyCallAttribute() {
    return "isSensorReadOnly";
  }
  get ATTR_DataSource_freq__DescriptionAttribute() {
    return "Sensor data acquisition frequency." + GenericHints.DevConfAffected;
  }
  get ATTR_DataSource_freq__AllowedValues() {
    return sensorFreqTypeDescription.AllowedValues;
  }
  get DataSource_freq() {
    return this._DataSource_source.get_frequency();
  }
  set DataSource_freq(value) {
    this._DataSource_source.set_frequency(value);
  }
  get ATTR_DataSource_datatype__DisplayName() {
    return "Sensor data";
  }
  get ATTR_DataSource_datatype__AllowedValues() {
    return sensorDataTypeDescription.AllowedValues;
  }
  get ATTR_DataSource_datatype__CopyToTarget() {
    return false;
  }
  get ATTR_DataSource_datatype__DescriptionAttribute() {
    return "Which data for sensor are displayed on the graph. Min and Max are available only for frequencies <1Hz";
  }
  get DataSource_datatype() {
    return this._DataType;
  }
  set DataSource_datatype(value) {
    this._DataType = value;
    if (this.ownerForm != null) {
      this.ownerForm.SourceChanged(this._DataSource_source, this.index);
    }
  }
  get ATTR_DataSource_recording__DisplayName() {
    return "Sensor recording";
  }
  get ATTR_DataSource_recording__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_DataSource_recording__IsReadonlyCallAttribute() {
    return "isSensorReadOnly";
  }
  get ATTR_DataSource_recording__CopyToTarget() {
    return false;
  }
  get ATTR_DataSource_recording__DescriptionAttribute() {
    return "Enable/ disable sensor data recording in the device on-board datalogger." + GenericHints.DevConfAffected;
  }
  get DataSource_recording() {
    return this._DataSource_source.get_recording();
  }
  set DataSource_recording(value) {
    this._DataSource_source.set_recording(value);
  }
  get ATTR_thickness__DisplayName() {
    return "Thickness";
  }
  get ATTR_thickness__DescriptionAttribute() {
    return "Line thickness.";
  }
  get thickness() {
    return this._thickness;
  }
  set thickness(value) {
    this._thickness = value;
  }
  get ATTR_legend__DisplayName() {
    return "Legend";
  }
  get ATTR_legend__DescriptionAttribute() {
    return "Short description of the series.";
  }
  get legend() {
    return this._legend;
  }
  set legend(value) {
    this._legend = value;
  }
  get ATTR_color__DisplayName() {
    return "Color";
  }
  get ATTR_color__DescriptionAttribute() {
    return "Line color.";
  }
  get color() {
    return this._color;
  }
  set color(value) {
    this._color = value;
  }
  get ATTR_yAxisIndex__AllowedValues() {
    return yAxisDescription.AllowedValues;
  }
  get ATTR_yAxisIndex__DisplayName() {
    return "Y axis";
  }
  get ATTR_yAxisIndex__DescriptionAttribute() {
    return "Choose which Y axis the data with be scaled to.";
  }
  get yAxisIndex() {
    return this._yAxisIndex;
  }
  set yAxisIndex(value) {
    this._yAxisIndex = value;
  }
  get ATTR_DataSource_AlarmSection0__DisplayName() {
    return "Sensor value alarm 1";
  }
  get ATTR_DataSource_AlarmSection0__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection0__DescriptionAttribute() {
    return "Alarm 1 for this data source, expand for more.";
  }
  get DataSource_AlarmSection0() {
    return this._DataSource_AlarmSection0;
  }
  set DataSource_AlarmSection0(value) {
    this._DataSource_AlarmSection0 = value;
  }
  get ATTR_DataSource_AlarmSection1__DisplayName() {
    return "Sensor value alarm 2";
  }
  get ATTR_DataSource_AlarmSection1__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection1__DescriptionAttribute() {
    return "Alarm 2 for this data source, expand for more.";
  }
  get DataSource_AlarmSection1() {
    return this._DataSource_AlarmSection1;
  }
  set DataSource_AlarmSection1(value) {
    this._DataSource_AlarmSection1 = value;
  }
};
var LegendPanelDescription = class {
  constructor() {
    this._enabled = false;
    this._overlap = false;
    this._position = LegendPanel.Position.RIGHT;
    this._font = new FontDescription("Arial", 7, YColor.FromArgb(255, 32, 32, 32), false, true);
    this._bgColor = YColor.FromArgb(200, 255, 255, 255);
    this._borderColor = YColor.Black;
    this._borderthickness = 1;
    this._padding = 10;
    this._verticalMargin = 10;
    this._horizontalMargin = 10;
    this._traceWidthFactor = 1;
  }
  get summary() {
    return this._enabled ? "Enabled" : "Disabled";
  }
  get ATTR_enabled__DisplayName() {
    return "Enabled";
  }
  get ATTR_enabled__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_enabled__DescriptionAttribute() {
    return "Should the legend panel be shown or not";
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    this._enabled = value;
  }
  get ATTR_overlap__DisplayName() {
    return "Overlap";
  }
  get ATTR_overlap__DescriptionAttribute() {
    return "Can the panel overlap the graph data, or should we explicitly make space for it?";
  }
  get overlap() {
    return this._overlap;
  }
  set overlap(value) {
    this._overlap = value;
  }
  get ATTR_position__DisplayName() {
    return "Position";
  }
  get ATTR_position__DescriptionAttribute() {
    return "Position of the legend panel";
  }
  get position() {
    return this._position;
  }
  set position(value) {
    this._position = value;
  }
  get ATTR_font__DisplayName() {
    return "Font";
  }
  get ATTR_font__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_font__DescriptionAttribute() {
    return "Legend panel contents fonts";
  }
  get font() {
    return this._font;
  }
  set font(value) {
    this._font = value;
  }
  get ATTR_bgColor__DisplayName() {
    return "Background color ";
  }
  get ATTR_bgColor__DescriptionAttribute() {
    return "Legend panel background color.";
  }
  get bgColor() {
    return this._bgColor;
  }
  set bgColor(value) {
    this._bgColor = value;
  }
  get ATTR_borderColor__DisplayName() {
    return "Border color ";
  }
  get ATTR_borderColor__DescriptionAttribute() {
    return "Legend panel border color.";
  }
  get borderColor() {
    return this._borderColor;
  }
  set borderColor(value) {
    this._borderColor = value;
  }
  get ATTR_borderthickness__DisplayName() {
    return "Border thickness ";
  }
  get ATTR_borderthickness__DescriptionAttribute() {
    return "Legend panel border thickness";
  }
  get borderthickness() {
    return this._borderthickness;
  }
  set borderthickness(value) {
    this._borderthickness = value;
  }
  get ATTR_padding__DisplayName() {
    return "Padding ";
  }
  get ATTR_padding__DescriptionAttribute() {
    return "Distance between the panel border and the panel contents";
  }
  get padding() {
    return this._padding;
  }
  set padding(value) {
    this._padding = value;
  }
  get ATTR_verticalMargin__DisplayName() {
    return "Vertical margin ";
  }
  get ATTR_verticalMargin__DescriptionAttribute() {
    return "Vertical distance between the panel border and its surroundings";
  }
  get verticalMargin() {
    return this._verticalMargin;
  }
  set verticalMargin(value) {
    this._verticalMargin = value;
  }
  get ATTR_horizontalMargin__DisplayName() {
    return "Horizontal margin ";
  }
  get ATTR_horizontalMargin__DescriptionAttribute() {
    return "Distance between the panel border and its surroundings";
  }
  get horizontalMargin() {
    return this._horizontalMargin;
  }
  set horizontalMargin(value) {
    this._horizontalMargin = value;
  }
  get ATTR_traceWidthFactor__DisplayName() {
    return "Color Indicator Factor";
  }
  get ATTR_traceWidthFactor__DescriptionAttribute() {
    return "Factor used to enlarge series color indicators shown in the legend panel";
  }
  get traceWidthFactor() {
    return this._traceWidthFactor;
  }
  set traceWidthFactor(value) {
    this._traceWidthFactor = value;
  }
};
var AnnotationPanelDescription = class {
  constructor(hrzAlignInit, vrtAlignInit, offsetY, overlap, textInit, BgColorInit, BorderColorInit, fontSizeInit, FontColorInit) {
    this._enabled = false;
    this._overlap = false;
    this._text = "Date: $DAY$/$MONTH$/$YEAR$";
    this._panelTextAlign = GenericPanel.TextAlign.CENTER;
    this._panelHrzAlign = GenericPanel.HorizontalAlignPos.CENTER;
    this._positionOffsetX = 0;
    this._panelVrtAlign = GenericPanel.VerticalAlignPos.TOP;
    this._positionOffsetY = 0;
    this._font = new FontDescription("Arial", 12, YColor.FromArgb(255, 32, 32, 32), false, false);
    this._bgColor = YColor.FromArgb(200, 255, 255, 255);
    this._borderColor = YColor.Black;
    this._borderthickness = 1;
    this._padding = 5;
    if (typeof textInit != "undefined")
      this._text = textInit;
    if (typeof offsetY != "undefined")
      this._positionOffsetY = offsetY;
    if (typeof overlap != "undefined")
      this._overlap = overlap;
    if (typeof BgColorInit != "undefined")
      this._bgColor = BgColorInit;
    if (typeof BorderColorInit != "undefined")
      this._borderColor = BorderColorInit;
    if (typeof fontSizeInit != "undefined")
      this._font.size = fontSizeInit;
    if (typeof FontColorInit != "undefined")
      this._font.color = FontColorInit;
    if (typeof vrtAlignInit != "undefined")
      this._panelVrtAlign = vrtAlignInit;
    if (typeof hrzAlignInit != "undefined")
      this._panelHrzAlign = hrzAlignInit;
  }
  get summary() {
    return this._enabled ? "Enabled" : "Disabled";
  }
  get ATTR_enabled__DisplayName() {
    return "Enabled";
  }
  get ATTR_enabled__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_enabled__DescriptionAttribute() {
    return "Should the annotation panel be shown or not";
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    this._enabled = value;
  }
  get ATTR_overlap__DisplayName() {
    return "Overlap";
  }
  get ATTR_overlap__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_overlap__DescriptionAttribute() {
    return "Can the annotation panel overlap the display zone, or should the display zone be squeezed to make space for the panel?";
  }
  get overlap() {
    return this._overlap;
  }
  set overlap(value) {
    this._overlap = value;
  }
  get ATTR_text__DisplayName() {
    return "Text ";
  }
  get ATTR_text__DescriptionAttribute() {
    return GenericHints.Annotation;
  }
  get text() {
    return this._text;
  }
  set text(value) {
    this._text = value;
  }
  get ATTR_panelTextAlign__DisplayName() {
    return "Text Alignment";
  }
  get ATTR_panelTextAlign__DescriptionAttribute() {
    return "How text is aligned, makes sense on multi-lines text only.";
  }
  get panelTextAlign() {
    return this._panelTextAlign;
  }
  set panelTextAlign(value) {
    this._panelTextAlign = value;
  }
  get ATTR_panelHrzAlign__DisplayName() {
    return "X Position";
  }
  get ATTR_panelHrzAlign__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_panelHrzAlign__DescriptionAttribute() {
    return "Annotation panel X position";
  }
  get panelHrzAlign() {
    return this._panelHrzAlign;
  }
  set panelHrzAlign(value) {
    this._panelHrzAlign = value;
  }
  get ATTR_positionOffsetX__DisplayName() {
    return "X Offset";
  }
  get ATTR_positionOffsetX__DescriptionAttribute() {
    return "X Position offset, in %  (overlap mode only)";
  }
  get positionOffsetX() {
    return this._positionOffsetX;
  }
  set positionOffsetX(value) {
    this._positionOffsetX = value;
  }
  get ATTR_panelVrtAlign__DisplayName() {
    return "Y Position";
  }
  get ATTR_panelVrtAlign__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_panelVrtAlign__DescriptionAttribute() {
    return "Annotation panel Y position";
  }
  get panelVrtAlign() {
    return this._panelVrtAlign;
  }
  set panelVrtAlign(value) {
    this._panelVrtAlign = value;
  }
  get ATTR_positionOffsetY__DisplayName() {
    return "Y Offset";
  }
  get ATTR_positionOffsetY__DescriptionAttribute() {
    return "Y Position offset, in %  (overlap mode only)";
  }
  get positionOffsetY() {
    return this._positionOffsetY;
  }
  set positionOffsetY(value) {
    this._positionOffsetY = value;
  }
  get ATTR_font__DisplayName() {
    return "Font";
  }
  get ATTR_font__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_font__DescriptionAttribute() {
    return "Panel font";
  }
  get font() {
    return this._font;
  }
  set font(value) {
    this._font = value;
  }
  get ATTR_bgColor__DisplayName() {
    return "Background color ";
  }
  get ATTR_bgColor__DescriptionAttribute() {
    return "Legend panel background color.";
  }
  get bgColor() {
    return this._bgColor;
  }
  set bgColor(value) {
    this._bgColor = value;
  }
  get ATTR_borderColor__DisplayName() {
    return "Border color ";
  }
  get ATTR_borderColor__DescriptionAttribute() {
    return "Legend panel border color.";
  }
  get borderColor() {
    return this._borderColor;
  }
  set borderColor(value) {
    this._borderColor = value;
  }
  get ATTR_borderthickness__DisplayName() {
    return "Border thickness ";
  }
  get ATTR_borderthickness__DescriptionAttribute() {
    return "Panel border thickness";
  }
  get borderthickness() {
    return this._borderthickness;
  }
  set borderthickness(value) {
    this._borderthickness = value;
  }
  get ATTR_padding__DisplayName() {
    return "Padding ";
  }
  get ATTR_padding__DescriptionAttribute() {
    return "Distance between the panel border and the panel contents";
  }
  get padding() {
    return this._padding;
  }
  set padding(value) {
    this._padding = value;
  }
};
var AnnotationPanelDescriptionGraph = class extends AnnotationPanelDescription {
  get ATTR_enabled__DisplayName() {
    return "Enabled";
  }
  get ATTR_enabled__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_enabled__DescriptionAttribute() {
    return "Should the annotation panel be shown or not";
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    this._enabled = value;
  }
  get ATTR_overlap__DisplayName() {
    return "Overlap";
  }
  get ATTR_overlap__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_overlap__DescriptionAttribute() {
    return "Can the annotation panel overlap the graph, or should the graph be squeezed to make space for the panel?";
  }
  get overlap() {
    return this._overlap;
  }
  set overlap(value) {
    this._overlap = value;
  }
  get ATTR_text__DisplayName() {
    return "Text ";
  }
  get ATTR_text__DescriptionAttribute() {
    return GenericHints.AnnotationGraph;
  }
  get text() {
    return this._text;
  }
  set text(value) {
    this._text = value;
  }
};
var DataTrackerDescription = class {
  constructor() {
    this._enabled = false;
    this._showSerieName = false;
    this._showTimeStamp = false;
    this._dataPrecision = DataTrackerDescription.DataPrecision.PRECISION_NOLIMIT;
    this._diameter = 5;
    this._handleLength = 25;
    this._font = new FontDescription("Arial", 7, YColor.FromArgb(255, 32, 32, 32), false, false);
    this._bgColor = YColor.FromArgb(200, 255, 255, 255);
    this._borderColor = YColor.Black;
    this._borderthickness = 1;
    this._padding = 5;
    this._detectionDistance = 50;
  }
  get summary() {
    return this._enabled ? "Enabled" : "Disabled";
  }
  get ATTR_enabled__DisplayName() {
    return "Enabled";
  }
  get ATTR_enabled__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_enabled__DescriptionAttribute() {
    return "Should the data tracker be shown or not.";
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    this._enabled = value;
  }
  get ATTR_showSerieName__DisplayName() {
    return "Show Series legend";
  }
  get ATTR_showSerieName__DescriptionAttribute() {
    return "Should the data tracker show the value's series legend.";
  }
  get showSerieName() {
    return this._showSerieName;
  }
  set showSerieName(value) {
    this._showSerieName = value;
  }
  get ATTR_showTimeStamp__DisplayName() {
    return "Show Timestamp";
  }
  get ATTR_showTimeStamp__DescriptionAttribute() {
    return "Should the data tracker show the value's timestamp.";
  }
  get showTimeStamp() {
    return this._showTimeStamp;
  }
  set showTimeStamp(value) {
    this._showTimeStamp = value;
  }
  get ATTR_dataPrecision__DisplayName() {
    return "Precision";
  }
  get ATTR_dataPrecision__DescriptionAttribute() {
    return "A way to limit data precision to meaningful digits in the data tracker.";
  }
  get dataPrecision() {
    return this._dataPrecision;
  }
  set dataPrecision(value) {
    this._dataPrecision = value;
  }
  get ATTR_diameter__DisplayName() {
    return "Point Diameter";
  }
  get ATTR_diameter__DescriptionAttribute() {
    return "Data point diameter, in pixels";
  }
  get diameter() {
    return this._diameter;
  }
  set diameter(value) {
    this._diameter = value;
  }
  get ATTR_handleLength__DisplayName() {
    return "Handle size";
  }
  get ATTR_handleLength__DescriptionAttribute() {
    return "size of the handle between the data point and the value panel";
  }
  get handleLength() {
    return this._handleLength;
  }
  set handleLength(value) {
    this._handleLength = value;
  }
  get ATTR_font__DisplayName() {
    return "Font";
  }
  get ATTR_font__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_font__DescriptionAttribute() {
    return "Data tracker label fonts";
  }
  get font() {
    return this._font;
  }
  set font(value) {
    this._font = value;
  }
  get ATTR_bgColor__DisplayName() {
    return "Background color";
  }
  get ATTR_bgColor__DescriptionAttribute() {
    return "Value panel ground color.";
  }
  get bgColor() {
    return this._bgColor;
  }
  set bgColor(value) {
    this._bgColor = value;
  }
  get ATTR_borderColor__DisplayName() {
    return "Border color";
  }
  get ATTR_borderColor__DescriptionAttribute() {
    return "Value panel border and handle  color.";
  }
  get borderColor() {
    return this._borderColor;
  }
  set borderColor(value) {
    this._borderColor = value;
  }
  get ATTR_borderthickness__DisplayName() {
    return "Border thickness ";
  }
  get ATTR_borderthickness__DescriptionAttribute() {
    return "Value panel border and handle  thickness";
  }
  get borderthickness() {
    return this._borderthickness;
  }
  set borderthickness(value) {
    this._borderthickness = value;
  }
  get ATTR_padding__DisplayName() {
    return "Padding";
  }
  get ATTR_padding__DescriptionAttribute() {
    return "Distance between the panel border and its contents ";
  }
  get padding() {
    return this._padding;
  }
  set padding(value) {
    this._padding = value;
  }
  get ATTR_detectionDistance__DisplayName() {
    return "Detection distance";
  }
  get ATTR_detectionDistance__DescriptionAttribute() {
    return "Maximum distance, in pixels, between the mouse and a data point for data tracker to show. Use zero for infinite distance";
  }
  get detectionDistance() {
    return this._detectionDistance;
  }
  set detectionDistance(value) {
    this._detectionDistance = value;
  }
};
(function(DataTrackerDescription2) {
  class DataPrecisionEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, DataPrecision);
    }
  }
  DataTrackerDescription2.DataPrecisionEnumItem = DataPrecisionEnumItem;
  class DataPrecision extends YEnum {
  }
  DataPrecision.PRECISION_NOLIMIT = new DataPrecisionEnumItem("PRECISION_NOLIMIT", "As is");
  DataPrecision.PRECISION_1 = new DataPrecisionEnumItem("PRECISION_1", "1");
  DataPrecision.PRECISION_01 = new DataPrecisionEnumItem("PRECISION_01", "0.1");
  DataPrecision.PRECISION_001 = new DataPrecisionEnumItem("PRECISION_001", "0.01");
  DataPrecision.PRECISION_0001 = new DataPrecisionEnumItem("PRECISION_0001", "0.001");
  DataTrackerDescription2.DataPrecision = DataPrecision;
})(DataTrackerDescription || (DataTrackerDescription = {}));
var NavigatorDescription = class {
  constructor() {
    this._enabled = false;
    this._bgColor1 = YColor.FromArgb(255, 225, 225, 225);
    this._bgColor2 = YColor.FromArgb(255, 225, 225, 225);
    this._borderThickness = 1;
    this._borderColor = YColor.Black;
    this._cursorColor = YColor.FromArgb(25, 0, 255, 0);
    this._cursorBorderColor = YColor.FromArgb(255, 96, 96, 96);
    this._yAxisHandling = Navigator.YAxisHandling.AUTO;
    this._xAxisThickness = 1;
    this._xAxisColor = YColor.Black;
    this._font = new FontDescription("Arial", 10, YColor.FromArgb(255, 32, 32, 32), false, false);
  }
  get summary() {
    return this._enabled ? "Enabled" : "Disabled";
  }
  get ATTR_enabled__DisplayName() {
    return "Enabled";
  }
  get ATTR_enabled__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_enabled__DescriptionAttribute() {
    return "Should the navigator be shown or not.";
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    this._enabled = value;
  }
  get ATTR_bgColor1__DisplayName() {
    return "Background color 1";
  }
  get ATTR_bgColor1__DescriptionAttribute() {
    return "Navigator background gradient color 1.";
  }
  get bgColor1() {
    return this._bgColor1;
  }
  set bgColor1(value) {
    this._bgColor1 = value;
  }
  get ATTR_bgColor2__DisplayName() {
    return "Background color 2";
  }
  get ATTR_bgColor2__DescriptionAttribute() {
    return "Navigator background gradient color 2.";
  }
  get bgColor2() {
    return this._bgColor2;
  }
  set bgColor2(value) {
    this._bgColor2 = value;
  }
  get ATTR_borderThickness__DisplayName() {
    return "Border thickness";
  }
  get ATTR_borderThickness__DescriptionAttribute() {
    return "Navigator";
  }
  get borderThickness() {
    return this._borderThickness;
  }
  set borderThickness(value) {
    this._borderThickness = value;
  }
  get ATTR_borderColor__DisplayName() {
    return "Border color";
  }
  get ATTR_borderColor__DescriptionAttribute() {
    return "Navigator Border color.";
  }
  get borderColor() {
    return this._borderColor;
  }
  set borderColor(value) {
    this._borderColor = value;
  }
  get ATTR_cursorColor__DisplayName() {
    return "Navigator cursor fill color";
  }
  get ATTR_cursorColor__DescriptionAttribute() {
    return "Navigator";
  }
  get cursorColor() {
    return this._cursorColor;
  }
  set cursorColor(value) {
    this._cursorColor = value;
  }
  get ATTR_cursorBorderColor__DisplayName() {
    return "Navigator cursor left/right border color.";
  }
  get ATTR_cursorBorderColor__DescriptionAttribute() {
    return "Navigator";
  }
  get cursorBorderColor() {
    return this._cursorBorderColor;
  }
  set cursorBorderColor(value) {
    this._cursorBorderColor = value;
  }
  get ATTR_yAxisHandling__DisplayName() {
    return "Y axis range";
  }
  get ATTR_yAxisHandling__DescriptionAttribute() {
    return "Is navigator Y axis zoom automatic or inherited from main view settings?";
  }
  get yAxisHandling() {
    return this._yAxisHandling;
  }
  set yAxisHandling(value) {
    this._yAxisHandling = value;
  }
  get ATTR_xAxisThickness__DisplayName() {
    return "X axis thickness";
  }
  get ATTR_xAxisThickness__DescriptionAttribute() {
    return "Navigator";
  }
  get xAxisThickness() {
    return this._xAxisThickness;
  }
  set xAxisThickness(value) {
    this._xAxisThickness = value;
  }
  get ATTR_xAxisColor__DisplayName() {
    return "X axis color";
  }
  get ATTR_xAxisColor__DescriptionAttribute() {
    return "Navigator X axis color.";
  }
  get xAxisColor() {
    return this._xAxisColor;
  }
  set xAxisColor(value) {
    this._xAxisColor = value;
  }
  get ATTR_font__DisplayName() {
    return "X-Axis Font";
  }
  get ATTR_font__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_font__DescriptionAttribute() {
    return "Navigator X axis font";
  }
  get font() {
    return this._font;
  }
  set font(value) {
    this._font = value;
  }
};
var LegendDescription = class {
  constructor() {
    this._title = "";
    this._font = new FontDescription("Arial", 12, YColor.Black, false, true);
  }
  get ATTR_title__DisplayName() {
    return "Text";
  }
  get ATTR_title__DescriptionAttribute() {
    return "Legend text";
  }
  get title() {
    return this._title;
  }
  set title(value) {
    this._title = value;
  }
  get ATTR_font__DisplayName() {
    return "Font";
  }
  get ATTR_font__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_font__DescriptionAttribute() {
    return "Legend font";
  }
  get font() {
    return this._font;
  }
  set font(value) {
    this._font = value;
  }
};
var YaxisDescription = class {
  constructor(index, shown) {
    this._visible = false;
    this._position = YAxis.HrzPosition.LEFT;
    this._min = new doubleNan(Number.NaN);
    this._max = new doubleNan(Number.NaN);
    this._step = new doubleNan(Number.NaN);
    this._color = YColor.FromArgb(255, 127, 127, 127);
    this._thickness = 1;
    this._showGrid = false;
    this._gridColor = YColor.FromArgb(255, 210, 210, 210);
    this._gridThickness = 1;
    this._font = new FontDescription("Arial", 10, YColor.Black, false, false);
    this._legend = new LegendDescription();
    this._zones0 = new ZoneDescription(0, 50, YColor.LightGreen);
    this._zones1 = new ZoneDescription(50, 80, YColor.Yellow);
    this._zones2 = new ZoneDescription(80, 100, YColor.Red);
    this._visible = shown;
    this._showGrid = index == 0;
    this._position = index == 0 ? YAxis.HrzPosition.LEFT : YAxis.HrzPosition.RIGHT;
  }
  get summary() {
    return this._visible ? "Enabled" : "Disabled";
  }
  get ATTR_visible__DisplayName() {
    return "Visible";
  }
  get ATTR_visible__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_visible__DescriptionAttribute() {
    return "Should that YAxis be shown?.";
  }
  get visible() {
    return this._visible;
  }
  set visible(value) {
    this._visible = value;
  }
  get ATTR_position__DisplayName() {
    return "Position";
  }
  get ATTR_position__DescriptionAttribute() {
    return "Y Axis position (left / right)";
  }
  get position() {
    return this._position;
  }
  set position(value) {
    this._position = value;
  }
  get ATTR_min__DisplayName() {
    return "Minimum value";
  }
  get ATTR_min__DescriptionAttribute() {
    return "YAxis minimum value, leave blank for automatic behavior.";
  }
  get min() {
    return this._min;
  }
  set min(value) {
    this._min = value;
  }
  get ATTR_max__DisplayName() {
    return "Maximum value";
  }
  get ATTR_max__DescriptionAttribute() {
    return "YAxis maximum value, leave blank for automatic behavior.";
  }
  get max() {
    return this._max;
  }
  set max(value) {
    this._max = value;
  }
  get ATTR_step__DisplayName() {
    return "Steps";
  }
  get ATTR_step__DescriptionAttribute() {
    return "YAxis step size, leave blank for automatic behavior.";
  }
  get step() {
    return this._step;
  }
  set step(value) {
    this._step = value;
  }
  get ATTR_color__DisplayName() {
    return "Color";
  }
  get ATTR_color__DescriptionAttribute() {
    return "Y Axis Color.";
  }
  get color() {
    return this._color;
  }
  set color(value) {
    this._color = value;
  }
  get ATTR_thickness__DisplayName() {
    return "Thickness";
  }
  get ATTR_thickness__DescriptionAttribute() {
    return "Axis thickness";
  }
  get thickness() {
    return this._thickness;
  }
  set thickness(value) {
    this._thickness = value;
  }
  get ATTR_showGrid__DisplayName() {
    return "Show Grid";
  }
  get ATTR_showGrid__DescriptionAttribute() {
    return "Show grid horizontal lines, or not.";
  }
  get showGrid() {
    return this._showGrid;
  }
  set showGrid(value) {
    this._showGrid = value;
  }
  get ATTR_gridColor__DisplayName() {
    return "Grid Color";
  }
  get ATTR_gridColor__DescriptionAttribute() {
    return "Grid horizontal lines color.";
  }
  get gridColor() {
    return this._gridColor;
  }
  set gridColor(value) {
    this._gridColor = value;
  }
  get ATTR_gridThickness__DisplayName() {
    return "Grid thickness";
  }
  get ATTR_gridThickness__DescriptionAttribute() {
    return "Grid horizontal lines thickness";
  }
  get gridThickness() {
    return this._gridThickness;
  }
  set gridThickness(value) {
    this._gridThickness = value;
  }
  get ATTR_font__DisplayName() {
    return "Font";
  }
  get ATTR_font__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_font__DescriptionAttribute() {
    return "Axis font";
  }
  get font() {
    return this._font;
  }
  set font(value) {
    this._font = value;
  }
  get ATTR_legend__DisplayName() {
    return "Legend";
  }
  get ATTR_legend__DescriptionAttribute() {
    return "Axis legend";
  }
  get legend() {
    return this._legend;
  }
  set legend(value) {
    this._legend = value;
  }
  get ATTR_zones0__DisplayName() {
    return "Zone 1";
  }
  get ATTR_zones0__CategoryAttribute() {
    return "Zones";
  }
  get ATTR_zones0__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_zones0__DescriptionAttribute() {
    return "Zone 1 parameters";
  }
  get zones0() {
    return this._zones0;
  }
  set zones0(value) {
    this._zones0 = value;
  }
  get ATTR_zones1__DisplayName() {
    return "Zone 2";
  }
  get ATTR_zones1__CategoryAttribute() {
    return "Zones";
  }
  get ATTR_zones1__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_zones1__DescriptionAttribute() {
    return "Zone 2 parameters";
  }
  get zones1() {
    return this._zones1;
  }
  set zones1(value) {
    this._zones1 = value;
  }
  get ATTR_zones2__DisplayName() {
    return "Zone 3";
  }
  get ATTR_zones2__CategoryAttribute() {
    return "Zones";
  }
  get ATTR_zones2__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_zones2__DescriptionAttribute() {
    return "Zone 3 parameters";
  }
  get zones2() {
    return this._zones2;
  }
  set zones2(value) {
    this._zones2 = value;
  }
};
var MarkerDescription = class {
  constructor(defaultText) {
    this._enabled = false;
    this._text = "";
    this._textAlign = Marker.TextAlign.CENTER;
    this._timereference = TimeConverter.TimeReference.ABSOLUTE;
    this._positionOnXAxis = new xAxisPosition(TimeConverter.ToUnixTime(new Date()), false);
    this._yposition = 95;
    this._bgColor = YColor.FromArgb(200, 255, 255, 192);
    this._borderColor = YColor.DarkRed;
    this._borderthickness = 1;
    this._padding = 5;
    this._font = new FontDescription("Arial", 7, YColor.Black, false, false);
    this._text = defaultText;
  }
  get summary() {
    return this._enabled ? "Enabled" : "Disabled";
  }
  get ATTR_enabled__DisplayName() {
    return "Enabled";
  }
  get ATTR_enabled__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_enabled__DescriptionAttribute() {
    return "Should that marker be shown?.";
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    this._enabled = value;
  }
  get ATTR_text__DisplayName() {
    return "Text";
  }
  get ATTR_text__DescriptionAttribute() {
    return "Marker text. Use \\n for multi-line text. Some variables are allowed such as $MARKERTIME$, $LEGEND1$, $VALUE1$, $UNIT1$, $LEGEND1$, $VALUE2$ etc.. Extensive use of marker variables migh make the graph rendering significantly slower.";
  }
  get text() {
    return this._text;
  }
  set text(value) {
    this._text = value;
  }
  get ATTR_textAlign__DisplayName() {
    return "Text Alignment";
  }
  get ATTR_textAlign__DescriptionAttribute() {
    return "How text is aligned, makes sense on multi-lines text only.";
  }
  get textAlign() {
    return this._textAlign;
  }
  set textAlign(value) {
    this._textAlign = value;
  }
  get ATTR_timereference__DisplayName() {
    return "Time reference";
  }
  get ATTR_timereference__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_timereference__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_timereference__DescriptionAttribute() {
    return "Should the marker time position be absolute or relative to first data timestamp? Note: relative markers won't be drawn until there is actual data.";
  }
  get timereference() {
    return this._timereference;
  }
  set timereference(value) {
    this._timereference = value;
    this._positionOnXAxis.relative = value == TimeConverter.TimeReference.RELATIVE;
  }
  get ATTR_positionOnXAxis__DisplayName() {
    return "Time position";
  }
  get ATTR_positionOnXAxis__DescriptionAttribute() {
    return "Marker position on X axis.";
  }
  get positionOnXAxis() {
    return this._positionOnXAxis;
  }
  set positionOnXAxis(value) {
    this._positionOnXAxis = value;
    this.timereference = value.relative ? TimeConverter.TimeReference.RELATIVE : TimeConverter.TimeReference.ABSOLUTE;
  }
  get ATTR_yposition__DisplayName() {
    return "Vrt position (%)";
  }
  get ATTR_yposition__DescriptionAttribute() {
    return "Vertical position of the marker label in % of available space. Zero is bottom";
  }
  get yposition() {
    return this._yposition;
  }
  set yposition(value) {
    this._yposition = value;
  }
  get ATTR_bgColor__DisplayName() {
    return "Background color ";
  }
  get ATTR_bgColor__DescriptionAttribute() {
    return "Marker  background color.";
  }
  get bgColor() {
    return this._bgColor;
  }
  set bgColor(value) {
    this._bgColor = value;
  }
  get ATTR_borderColor__DisplayName() {
    return "Border color ";
  }
  get ATTR_borderColor__DescriptionAttribute() {
    return "Marker border color.";
  }
  get borderColor() {
    return this._borderColor;
  }
  set borderColor(value) {
    this._borderColor = value;
  }
  get ATTR_borderthickness__DisplayName() {
    return "Border thickness ";
  }
  get ATTR_borderthickness__DescriptionAttribute() {
    return "Marker border thickness, in pixels.";
  }
  get borderthickness() {
    return this._borderthickness;
  }
  set borderthickness(value) {
    this._borderthickness = value;
  }
  get ATTR_padding__DisplayName() {
    return "Padding ";
  }
  get ATTR_padding__DescriptionAttribute() {
    return "Distance between the marker border and the marker contents, in pixels.";
  }
  get padding() {
    return this._padding;
  }
  set padding(value) {
    this._padding = value;
  }
  get ATTR_font__DisplayName() {
    return "Font";
  }
  get ATTR_font__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_font__DescriptionAttribute() {
    return "Marker Font";
  }
  get font() {
    return this._font;
  }
  set font(value) {
    this._font = value;
  }
};
var XaxisDescription = class {
  constructor() {
    this._initialZoom = 60;
    this._initialOffset = 0;
    this._position = XAxis.VrtPosition.BOTTOM;
    this._timeReference = TimeConverter.TimeReference.ABSOLUTE;
    this._overflowHandling = XAxis.OverflowHandling.SCROLL;
    this._color = YColor.FromArgb(255, 127, 127, 127);
    this._thickness = 1;
    this._showGrid = false;
    this._gridColor = YColor.FromArgb(50, 0, 0, 0);
    this._gridThickness = 1;
    this._font = new FontDescription("Arial", 10, YColor.Black, false, false);
    this._legend = new LegendDescription();
    this._markers0 = new MarkerDescription("Marker 1");
    this._markers1 = new MarkerDescription("Marker 2");
    this._markers2 = new MarkerDescription("Marker 3");
    this._markers3 = new MarkerDescription("Marker 4");
    this._markers4 = new MarkerDescription("Marker 5");
    this._markers5 = new MarkerDescription("Marker 6");
    this._markers6 = new MarkerDescription("Marker 7");
    this._markers7 = new MarkerDescription("Marker 8");
  }
  get ATTR_initialZoom__DisplayName() {
    return "Initial Zoom";
  }
  get ATTR_initialZoom__DescriptionAttribute() {
    return "Zoom level at application startup, i.e. width of the view-port in seconds.";
  }
  get initialZoom() {
    return this._initialZoom;
  }
  set initialZoom(value) {
    this._initialZoom = value;
  }
  get ATTR_initialOffset__DisplayName() {
    return "Initial Offset";
  }
  get ATTR_initialOffset__DescriptionAttribute() {
    return "Offset of the first data point in percentage of the viewport width. For instance a 50% value will put the first point in the middle of the viewport. This can be used to give some room for datalogger contents.";
  }
  get initialOffset() {
    return this._initialOffset;
  }
  set initialOffset(value) {
    this._initialOffset = value;
  }
  get ATTR_position__DisplayName() {
    return "Position";
  }
  get ATTR_position__DescriptionAttribute() {
    return "X Axis position (top / bottom)";
  }
  get position() {
    return this._position;
  }
  set position(value) {
    this._position = value;
  }
  get ATTR_timeReference__DisplayName() {
    return "Time reference";
  }
  get ATTR_timeReference__DescriptionAttribute() {
    return "Are gradation timestamps absolute or relative to experiment start time? ";
  }
  get timeReference() {
    return this._timeReference;
  }
  set timeReference(value) {
    this._timeReference = value;
  }
  get ATTR_overflowHandling__DisplayName() {
    return "Overflow Handling";
  }
  get ATTR_overflowHandling__DescriptionAttribute() {
    return "What to do when new data are about to reach the graph right border";
  }
  get overflowHandling() {
    return this._overflowHandling;
  }
  set overflowHandling(value) {
    this._overflowHandling = value;
  }
  get ATTR_color__DisplayName() {
    return "Color";
  }
  get ATTR_color__DescriptionAttribute() {
    return "X Axis Color.";
  }
  get color() {
    return this._color;
  }
  set color(value) {
    this._color = value;
  }
  get ATTR_thickness__DisplayName() {
    return "Thickness";
  }
  get ATTR_thickness__DescriptionAttribute() {
    return "Axis thickness";
  }
  get thickness() {
    return this._thickness;
  }
  set thickness(value) {
    this._thickness = value;
  }
  get ATTR_showGrid__DisplayName() {
    return "Show Grid";
  }
  get ATTR_showGrid__DescriptionAttribute() {
    return "Show grid vertical lines, or not.";
  }
  get showGrid() {
    return this._showGrid;
  }
  set showGrid(value) {
    this._showGrid = value;
  }
  get ATTR_gridColor__DisplayName() {
    return "Grid Color";
  }
  get ATTR_gridColor__DescriptionAttribute() {
    return "Grid vertical lines color.";
  }
  get gridColor() {
    return this._gridColor;
  }
  set gridColor(value) {
    this._gridColor = value;
  }
  get ATTR_gridThickness__DisplayName() {
    return "Grid thickness";
  }
  get ATTR_gridThickness__DescriptionAttribute() {
    return "Grid vertical lines thickness";
  }
  get gridThickness() {
    return this._gridThickness;
  }
  set gridThickness(value) {
    this._gridThickness = value;
  }
  get ATTR_font__DisplayName() {
    return "Font";
  }
  get ATTR_font__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_font__DescriptionAttribute() {
    return "Axis font";
  }
  get font() {
    return this._font;
  }
  set font(value) {
    this._font = value;
  }
  get ATTR_legend__DisplayName() {
    return "Legend";
  }
  get ATTR_legend__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_legend__DescriptionAttribute() {
    return "X Axis legend";
  }
  get legend() {
    return this._legend;
  }
  set legend(value) {
    this._legend = value;
  }
  get ATTR_markers0__DisplayName() {
    return "Marker 1";
  }
  get ATTR_markers0__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_markers0__CategoryAttribute() {
    return "Markers";
  }
  get ATTR_markers0__DescriptionAttribute() {
    return "First marker parameters";
  }
  get markers0() {
    return this._markers0;
  }
  set markers0(value) {
    this._markers0 = value;
  }
  get ATTR_markers1__DisplayName() {
    return "Marker 2";
  }
  get ATTR_markers1__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_markers1__CategoryAttribute() {
    return "Markers";
  }
  get ATTR_markers1__DescriptionAttribute() {
    return "Second marker parameters";
  }
  get markers1() {
    return this._markers1;
  }
  set markers1(value) {
    this._markers1 = value;
  }
  get ATTR_markers2__DisplayName() {
    return "Marker 3";
  }
  get ATTR_markers2__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_markers2__CategoryAttribute() {
    return "Markers";
  }
  get ATTR_markers2__DescriptionAttribute() {
    return "Third marker parameters";
  }
  get markers2() {
    return this._markers2;
  }
  set markers2(value) {
    this._markers2 = value;
  }
  get ATTR_markers3__DisplayName() {
    return "Marker 4";
  }
  get ATTR_markers3__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_markers3__CategoryAttribute() {
    return "Markers";
  }
  get ATTR_markers3__DescriptionAttribute() {
    return "Fourth marker parameters";
  }
  get markers3() {
    return this._markers3;
  }
  set markers3(value) {
    this._markers3 = value;
  }
  get ATTR_markers4__DisplayName() {
    return "Marker 5";
  }
  get ATTR_markers4__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_markers4__CategoryAttribute() {
    return "Markers";
  }
  get ATTR_markers4__DescriptionAttribute() {
    return "Fith marker parameters";
  }
  get markers4() {
    return this._markers4;
  }
  set markers4(value) {
    this._markers4 = value;
  }
  get ATTR_markers5__DisplayName() {
    return "Marker 6";
  }
  get ATTR_markers5__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_markers5__CategoryAttribute() {
    return "Markers";
  }
  get ATTR_markers5__DescriptionAttribute() {
    return "Sixth marker parameters";
  }
  get markers5() {
    return this._markers5;
  }
  set markers5(value) {
    this._markers5 = value;
  }
  get ATTR_markers6__DisplayName() {
    return "Marker 7";
  }
  get ATTR_markers6__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_markers6__CategoryAttribute() {
    return "Markers";
  }
  get ATTR_markers6__DescriptionAttribute() {
    return "Seventh marker parameters";
  }
  get markers6() {
    return this._markers6;
  }
  set markers6(value) {
    this._markers6 = value;
  }
  get ATTR_markers7__DisplayName() {
    return "Marker 8";
  }
  get ATTR_markers7__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_markers7__CategoryAttribute() {
    return "Markers";
  }
  get ATTR_markers7__DescriptionAttribute() {
    return "Height marker parameters";
  }
  get markers7() {
    return this._markers7;
  }
  set markers7(value) {
    this._markers7 = value;
  }
};
var GraphFormProperties = class extends GenericProperties {
  constructor(initData, owner) {
    super(owner);
    this._Graph_series0 = new ChartSerie(YColor.Tomato);
    this._Graph_series1 = new ChartSerie(YColor.DodgerBlue);
    this._Graph_series2 = new ChartSerie(YColor.SeaGreen);
    this._Graph_series3 = new ChartSerie(YColor.Gold);
    this._Graph_showRecordedData = false;
    this._Graph_borderColor = YColor.LightGray;
    this._Graph_borderThickness = 1;
    this._Graph_bgColor1 = YColor.FromArgb(255, 220, 220, 220);
    this._Graph_bgColor2 = YColor.FromArgb(55, 240, 240, 240);
    this._Graph_resizeRule = Proportional.ResizeRule.FIXED;
    this._Graph_xAxis = new XaxisDescription();
    this._Graph_yAxes0 = new YaxisDescription(0, true);
    this._Graph_yAxes1 = new YaxisDescription(1, false);
    this._Graph_yAxes2 = new YaxisDescription(2, false);
    this._Graph_legendPanel = new LegendPanelDescription();
    this._Graph_dataTracker = new DataTrackerDescription();
    this._Graph_navigator = new NavigatorDescription();
    this._annotationPanels0 = new AnnotationPanelDescriptionGraph();
    this._annotationPanels1 = new AnnotationPanelDescriptionGraph();
    this.initFromXmlData(initData);
  }
  IsDataSourceAssigned() {
    let propList = Object.getOwnPropertyNames(this);
    propList.forEach((name) => {
      if (name.startsWith("Graphs_series")) {
        let s = this[name].GetValue(this, null);
        if (!(s.DataSource_source instanceof NullYSensor))
          return true;
      }
    });
    return false;
  }
  get ATTR_Graph_series0__DisplayName() {
    return "Series 1";
  }
  get ATTR_Graph_series0__CategoryAttribute() {
    return "Data Sources";
  }
  get ATTR_Graph_series0__PreExpandedCategoryAttribute() {
    return true;
  }
  get ATTR_Graph_series0__PreExpandedAttribute() {
    return true;
  }
  get ATTR_Graph_series0__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_Graph_series0__DescriptionAttribute() {
    return "First data series, expand for more.";
  }
  get Graph_series0() {
    return this._Graph_series0;
  }
  set Graph_series0(value) {
    this._Graph_series0 = value;
  }
  get ATTR_Graph_series1__DisplayName() {
    return "Series 2";
  }
  get ATTR_Graph_series1__CategoryAttribute() {
    return "Data Sources";
  }
  get ATTR_Graph_series1__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_Graph_series1__DescriptionAttribute() {
    return "Second data series, expand for more.";
  }
  get Graph_series1() {
    return this._Graph_series1;
  }
  set Graph_series1(value) {
    this._Graph_series1 = value;
  }
  get ATTR_Graph_series2__DisplayName() {
    return "Series 3";
  }
  get ATTR_Graph_series2__CategoryAttribute() {
    return "Data Sources";
  }
  get ATTR_Graph_series2__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_Graph_series2__DescriptionAttribute() {
    return "Third data series, expand for more.";
  }
  get Graph_series2() {
    return this._Graph_series2;
  }
  set Graph_series2(value) {
    this._Graph_series2 = value;
  }
  get ATTR_Graph_series3__DisplayName() {
    return "Series 4";
  }
  get ATTR_Graph_series3__CategoryAttribute() {
    return "Data Sources";
  }
  get ATTR_Graph_series3__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_Graph_series3__DescriptionAttribute() {
    return "Fourth data series, expand for more.";
  }
  get Graph_series3() {
    return this._Graph_series3;
  }
  set Graph_series3(value) {
    this._Graph_series3 = value;
  }
  get ATTR_Graph_showRecordedData__DisplayName() {
    return "Use datalogger data";
  }
  get ATTR_Graph_showRecordedData__CategoryAttribute() {
    return "Graph";
  }
  get ATTR_Graph_showRecordedData__CopyToTarget() {
    return false;
  }
  get ATTR_Graph_showRecordedData__DescriptionAttribute() {
    return "Makes the graph load the sensors datalogger contents. After disabling this feature, you may want to reset the dataview with the right-click context menu.";
  }
  get Graph_showRecordedData() {
    return this._Graph_showRecordedData;
  }
  set Graph_showRecordedData(value) {
    if (this._Graph_showRecordedData != value) {
      this._Graph_showRecordedData = value;
      if (this.ownerForm != null) {
        this._Graph_showRecordedData ? this.ownerForm.loadRecordedDataIfNeeded() : this.ownerForm.removeDataloggerData();
      }
    }
  }
  get ATTR_Graph_borderColor__DisplayName() {
    return "Border color";
  }
  get ATTR_Graph_borderColor__CategoryAttribute() {
    return "Graph";
  }
  get ATTR_Graph_borderColor__DescriptionAttribute() {
    return "Canvas borders color.";
  }
  get Graph_borderColor() {
    return this._Graph_borderColor;
  }
  set Graph_borderColor(value) {
    this._Graph_borderColor = value;
  }
  get ATTR_Graph_borderThickness__DisplayName() {
    return "Border thickness";
  }
  get ATTR_Graph_borderThickness__CategoryAttribute() {
    return "Graph";
  }
  get ATTR_Graph_borderThickness__DescriptionAttribute() {
    return "Canvas borders thickness.";
  }
  get Graph_borderThickness() {
    return this._Graph_borderThickness;
  }
  set Graph_borderThickness(value) {
    this._Graph_borderThickness = value;
  }
  get ATTR_Graph_bgColor1__DisplayName() {
    return "Background color 1";
  }
  get ATTR_Graph_bgColor1__CategoryAttribute() {
    return "Graph";
  }
  get ATTR_Graph_bgColor1__DescriptionAttribute() {
    return "Background gradient color 1.";
  }
  get Graph_bgColor1() {
    return this._Graph_bgColor1;
  }
  set Graph_bgColor1(value) {
    this._Graph_bgColor1 = value;
  }
  get ATTR_Graph_bgColor2__DisplayName() {
    return "Background color 2";
  }
  get ATTR_Graph_bgColor2__CategoryAttribute() {
    return "Graph";
  }
  get ATTR_Graph_bgColor2__DescriptionAttribute() {
    return "Background gradient color 2.";
  }
  get Graph_bgColor2() {
    return this._Graph_bgColor2;
  }
  set Graph_bgColor2(value) {
    this._Graph_bgColor2 = value;
  }
  get ATTR_Graph_resizeRule__DisplayName() {
    return "Font sizes";
  }
  get ATTR_Graph_resizeRule__CategoryAttribute() {
    return "Graph";
  }
  get ATTR_Graph_resizeRule__DescriptionAttribute() {
    return "Are font sizes fixed or do they change when window is resized?";
  }
  get Graph_resizeRule() {
    return this._Graph_resizeRule;
  }
  set Graph_resizeRule(value) {
    this._Graph_resizeRule = value;
  }
  get ATTR_Graph_xAxis__DisplayName() {
    return "X Axis";
  }
  get ATTR_Graph_xAxis__CategoryAttribute() {
    return "X/Y Axes";
  }
  get ATTR_Graph_xAxis__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_Graph_xAxis__DescriptionAttribute() {
    return "X-Axis, expand for more";
  }
  get Graph_xAxis() {
    return this._Graph_xAxis;
  }
  set Graph_xAxis(value) {
    this._Graph_xAxis = value;
  }
  get ATTR_Graph_yAxes0__DisplayName() {
    return "YAxis 1";
  }
  get ATTR_Graph_yAxes0__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_Graph_yAxes0__CategoryAttribute() {
    return "X/Y Axes";
  }
  get ATTR_Graph_yAxes0__DescriptionAttribute() {
    return "First Y Axis, expand for more.";
  }
  get Graph_yAxes0() {
    return this._Graph_yAxes0;
  }
  set Graph_yAxes0(value) {
    this._Graph_yAxes0 = value;
  }
  get ATTR_Graph_yAxes1__DisplayName() {
    return "YAxis 2";
  }
  get ATTR_Graph_yAxes1__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_Graph_yAxes1__CategoryAttribute() {
    return "X/Y Axes";
  }
  get ATTR_Graph_yAxes1__DescriptionAttribute() {
    return "Second Y Axis, expand for more.";
  }
  get Graph_yAxes1() {
    return this._Graph_yAxes1;
  }
  set Graph_yAxes1(value) {
    this._Graph_yAxes1 = value;
  }
  get ATTR_Graph_yAxes2__DisplayName() {
    return "YAxis 3";
  }
  get ATTR_Graph_yAxes2__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_Graph_yAxes2__CategoryAttribute() {
    return "X/Y Axes";
  }
  get ATTR_Graph_yAxes2__DescriptionAttribute() {
    return "Third Y Axis, expand for more.";
  }
  get Graph_yAxes2() {
    return this._Graph_yAxes2;
  }
  set Graph_yAxes2(value) {
    this._Graph_yAxes2 = value;
  }
  get ATTR_Graph_legendPanel__DisplayName() {
    return "Legend Panel";
  }
  get ATTR_Graph_legendPanel__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_Graph_legendPanel__CategoryAttribute() {
    return "Graph";
  }
  get ATTR_Graph_legendPanel__DescriptionAttribute() {
    return "Panel containing a description of all data series. Expand for more.";
  }
  get Graph_legendPanel() {
    return this._Graph_legendPanel;
  }
  set Graph_legendPanel(value) {
    this._Graph_legendPanel = value;
  }
  get ATTR_Graph_dataTracker__DisplayName() {
    return "Data tracker";
  }
  get ATTR_Graph_dataTracker__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_Graph_dataTracker__CategoryAttribute() {
    return "Graph";
  }
  get ATTR_Graph_dataTracker__DescriptionAttribute() {
    return "Show dynamic value labels while the mouse is moving over the graph. Expand for more.";
  }
  get Graph_dataTracker() {
    return this._Graph_dataTracker;
  }
  set Graph_dataTracker(value) {
    this._Graph_dataTracker = value;
  }
  get ATTR_Graph_navigator__DisplayName() {
    return "Navigator";
  }
  get ATTR_Graph_navigator__CategoryAttribute() {
    return "Graph";
  }
  get ATTR_Graph_navigator__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_Graph_navigator__DescriptionAttribute() {
    return "Small additional graph showing the whole data set and allowing to quickly navigate among data. Expand for more.";
  }
  get Graph_navigator() {
    return this._Graph_navigator;
  }
  set Graph_navigator(value) {
    this._Graph_navigator = value;
  }
  get ATTR_Graph_annotationPanels0__DisplayName() {
    return "Annotation 1";
  }
  get ATTR_Graph_annotationPanels0__CategoryAttribute() {
    return "Annotations";
  }
  get ATTR_Graph_annotationPanels0__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_Graph_annotationPanels0__DescriptionAttribute() {
    return "Customizable text panel 1";
  }
  get Graph_annotationPanels0() {
    return this._annotationPanels0;
  }
  set Graph_annotationPanels0(value) {
    this._annotationPanels0 = value;
  }
  get ATTR_Graph_annotationPanels1__DisplayName() {
    return "Annotation 2";
  }
  get ATTR_Graph_annotationPanels1__CategoryAttribute() {
    return "Annotations";
  }
  get ATTR_Graph_annotationPanels1__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_Graph_annotationPanels1__DescriptionAttribute() {
    return "Customizable text panel 2";
  }
  get Graph_annotationPanels1() {
    return this._annotationPanels1;
  }
  set Graph_annotationPanels1(value) {
    this._annotationPanels1 = value;
  }
};

// obj/full/contextMenu.js
var ContextMenuSeparator = class {
  constructor() {
    this.TR = document.createElement("TR");
    this.TR["objectData"] = this;
    this.TR.className = ContextMenu.SEPARATOR_MARKER;
    this.TD_caption = document.createElement("TD");
    this.TD_caption.style.backgroundColor = ContextMenu.iconBGColor;
    this.TD_caption.style.paddingLeft = "3px";
    this.TD_caption.style.paddingRight = "3px";
    let hr = document.createElement("HR");
    this.TD_caption.colSpan = 2;
    this.TD_caption.appendChild(hr);
    this.TD_icon = document.createElement("TD");
    this.TD_icon.style.backgroundColor = ContextMenu.captionBgColor;
    this.TR.appendChild(this.TD_icon);
    this.TR.appendChild(this.TD_caption);
  }
  toString() {
    return "Separator";
  }
  get focusable() {
    return false;
  }
  parentMenuisClosing() {
  }
  get domData() {
    return this.TR;
  }
};
var ContextMenuItemBase = class {
  constructor(menu, icon, caption) {
    this._clickHidesMenu = true;
    this._userdata = null;
    this._menu = menu;
    this.TR = document.createElement("TR");
    this.TR["objectData"] = this;
    this.TD_caption = document.createElement("TD");
    this.TD_caption.style.backgroundColor = ContextMenu.iconBGColor;
    this.TD_caption.style.paddingLeft = "3px";
    this.TD_caption.style.paddingRight = "3px";
    this.TD_caption.style.whiteSpace = "nowrap";
    this.TD_icon = document.createElement("TD");
    if (icon != null)
      this.TD_icon.innerHTML = icon;
    this.TD_icon.style.backgroundColor = ContextMenu.captionBgColor;
    this.A_caption = document.createElement("A");
    this.A_caption.innerHTML = caption;
    this.TR.style.cursor = "pointer";
    this.TR.tabIndex = 0;
    this.TR.style.outline = "none";
    this._TR_keydown = (e) => {
      e.preventDefault();
      this.keydown(e);
    };
    this._TR_mouseover = (e) => {
      this.mouserOver(e);
    };
    this._TR_mouseout = (e) => {
      this.mouserOut(e);
    };
    this._A_mouseover = (e) => {
      this.mouserOver(e);
    };
    this._A_mouseout = (e) => {
      this.mouserOut(e);
    };
    this._A_click = (e) => {
      this.activate();
    };
    this._TR_focusin = () => {
      this.focusIn();
    };
    this._TR_focusout = () => {
      this.focusOut();
    };
    this.TR.addEventListener("mouseover", this._TR_mouseover);
    this.TR.addEventListener("mouseout", this._TR_mouseout);
    this.TR.addEventListener("click", this._A_click);
    this.TR.addEventListener("keydown", this._TR_keydown);
    this.A_caption.addEventListener("mouseover", this._A_mouseover);
    this.A_caption.addEventListener("mouseout", this._A_mouseout);
    this.TD_caption.appendChild(this.A_caption);
    this.TR.appendChild(this.TD_icon);
    this.TR.appendChild(this.TD_caption);
    this.TR.addEventListener("focusin", this._TR_focusin);
    this.TR.addEventListener("focusout", this._TR_focusout);
  }
  get userdata() {
    return this._userdata;
  }
  set userdata(value) {
    this._userdata = value;
  }
  toString() {
    return this.TD_caption.innerText;
  }
  get focusable() {
    return this.visible;
  }
  activate() {
  }
  focus() {
    this.TR.focus();
    this._menu.closeSubmenus();
  }
  focusIn() {
    if (this.TD_caption.style.backgroundColor == ContextMenu.iconBGColor)
      this._menu.closeSubmenus();
    this.TD_caption.style.backgroundColor = ContextMenu.ActiveColor;
    this.TD_icon.style.backgroundColor = ContextMenu.ActiveColor;
  }
  focusOut() {
    this.TD_caption.style.backgroundColor = ContextMenu.iconBGColor;
    this.TD_icon.style.backgroundColor = ContextMenu.captionBgColor;
  }
  removeAndDestroy() {
    if (this.TR.parentNode != null)
      this.TR.parentNode.removeChild(this.TR);
    this.TR.removeEventListener("keydown", this._TR_keydown);
    this.TR.removeEventListener("mouseover", this._TR_mouseover);
    this.TR.removeEventListener("mouseout", this._TR_mouseout);
    this.A_caption.removeEventListener("mouseover", this._A_mouseover);
    this.A_caption.removeEventListener("mouseout", this._A_mouseout);
    this.A_caption.removeEventListener("click", this._A_click);
    this.TR.removeEventListener("focusin", this._TR_focusin);
    this.TR.removeEventListener("focusout", this._TR_focusout);
  }
  set caption(value) {
    this.A_caption.innerHTML = value;
  }
  get caption() {
    return this.A_caption.innerHTML;
  }
  keydown(e) {
    if (e.code == "ArrowDown")
      this._menu.activateNext(this);
    if (e.code == "ArrowUp")
      this._menu.activatePrevious(this);
    if (e.code == "Enter")
      this.activate();
    if (e.code == "Escape") {
      this._menu.close();
      if (this._menu.parentMenuItem != null)
        this._menu.parentMenuItem.focus();
    }
    if (e.code == "ArrowLeft") {
      if (this._menu.parentMenuItem != null) {
        this._menu.close();
        this._menu.parentMenuItem.focus();
      }
    }
  }
  mouserOver(e) {
    this.TD_caption.style.backgroundColor = ContextMenu.ActiveColor;
    this.TD_icon.style.backgroundColor = ContextMenu.ActiveColor;
    this._menu.closeSubmenus();
  }
  mouserOut(e) {
    this.TD_caption.style.backgroundColor = ContextMenu.iconBGColor;
    this.TD_icon.style.backgroundColor = ContextMenu.captionBgColor;
  }
  get domData() {
    return this.TR;
  }
  get visible() {
    return this.TR.style.display != "none";
  }
  set visible(value) {
    this.TR.style.display = value ? "" : "none";
  }
  parentMenuisClosing() {
  }
  closeMenu(all) {
    if (all)
      this._menu.closeAll();
    else
      this._menu.close();
  }
};
var ContextMenuItem = class extends ContextMenuItemBase {
  constructor(menu, icon, caption, callback) {
    super(menu, icon, caption);
    this._callback = callback;
    this.TD_caption.colSpan = 2;
  }
  activate() {
    if (this._clickHidesMenu)
      this.closeMenu(true);
    if (this._callback != null)
      this._callback();
  }
};
var ContextMenuItemSubMenuEntry = class extends ContextMenuItem {
  constructor(menu, icon, caption, submenu) {
    super(menu, icon, caption, null);
    this.TD_caption.colSpan = 1;
    this._submenu = submenu;
    this._submenu.parentMenuItem = this;
    this._parentmenu = menu;
    this._clickHidesMenu = false;
    this.TD_arrow = document.createElement("TD");
    this.TD_arrow.style.backgroundColor = ContextMenu.iconBGColor;
    this.TD_arrow.style.textAlign = "right";
    this.TD_arrow.style.paddingRight = "3px";
    this.TD_arrow.innerHTML = "&#9654;";
    this.TR.appendChild(this.TD_arrow);
    this.A_caption.addEventListener("click", (e) => {
      this.showSubmenu();
    });
    this.A_caption.addEventListener("touchstart", (e) => {
      if (e.touches.length == 1)
        this.activate();
    });
    this._submenu.zIndex = this._parentmenu.zIndex + 1;
  }
  keydown(e) {
    super.keydown(e);
    if (e.code == "ArrowRight") {
      this.activate();
      this._submenu.focusFirst();
    }
  }
  removeAndDestroy() {
    this._submenu.close();
    this._submenu.destroy();
    super.removeAndDestroy();
  }
  activate() {
    this.showSubmenu();
  }
  get submenu() {
    return this._submenu;
  }
  showSubmenu() {
    this._submenu.zIndex = this._parentmenu.zIndex + 1;
    let x = 0;
    let y = 0;
    let it = this.TR;
    do {
      x += it.offsetLeft || 0;
      y += it.offsetTop || 0;
      it = it.offsetParent;
    } while (it);
    this._submenu.showContextMenu(x + this._parentmenu.width - 15, y + 5);
  }
  focusIn() {
    super.focusIn();
    this.TD_arrow.style.backgroundColor = ContextMenu.ActiveColor;
  }
  focusOut() {
    super.focusOut();
    this.TD_arrow.style.backgroundColor = ContextMenu.iconBGColor;
  }
  parentMenuisClosing() {
    this._submenu.close();
  }
  mouserOver(e) {
    this.focusIn();
    this._parentmenu.setDelayedAction(() => {
      if (this.visible)
        this.showSubmenu();
    });
  }
  mouserOut(e) {
    this._parentmenu.cancelDelayedAction();
    this.focusOut();
  }
};
var ContextMenuBase = class {
  constructor(baseSize, openCallback, fontFamily) {
    this._visible = false;
    this._zIndex = 100002;
    this._parentmenu = null;
    this._parentMenuItem = null;
    this._userdata = null;
    this._openCallback = openCallback;
    this.Menutable = document.createElement("TABLE");
    this.Menutable.style.position = "absolute";
    this.Menutable.style.border = "1px solid #808080";
    if (typeof fontFamily !== "undefined")
      this.Menutable.style.fontFamily = fontFamily;
    this.Menutable.style.fontSize = (2 * baseSize / 3).toFixed(1) + "px";
    this.Menutable.style.borderSpacing = "0";
    this.Menutable.style.boxShadow = " 4px 4px 4px 1px rgba(0,0,0,0.05)";
    this.Menutable.style.zIndex = this._zIndex.toString();
    this._timer = null;
    this.visible = false;
  }
  get parentMenuItem() {
    return this._parentMenuItem;
  }
  set parentMenuItem(value) {
    this._parentMenuItem = value;
  }
  get userdata() {
    return this._userdata;
  }
  set userdata(value) {
    this._userdata = value;
  }
  closeAll() {
    this.close();
    if (this._parentmenu != null)
      this._parentmenu.closeAll();
  }
  cancelDelayedAction() {
    if (this._timer != null) {
      clearTimeout(this._timer);
      this._timer = null;
    }
  }
  setDelayedAction(action) {
    this.cancelDelayedAction();
    this._timer = setTimeout(() => {
      action();
    }, 500);
  }
  get parentMenu() {
    return this._parentmenu;
  }
  destroy() {
    for (let i = 0; i < this.Menutable.childNodes.length; i++) {
      let item = this.Menutable.childNodes[i]["objectData"];
      item.removeAndDestroy();
    }
    if (this.Menutable.parentNode != null)
      this.Menutable.parentNode.removeChild(this.Menutable);
  }
  focusFirst() {
    for (let i = 0; i < this.Menutable.childNodes.length; i++) {
      let item = this.Menutable.childNodes[i]["objectData"];
      if (item.focusable) {
        item.focus();
        return;
      }
    }
  }
  toString() {
    let res = "";
    for (let i = 0; i < this.Menutable.childNodes.length; i++) {
      let item = this.Menutable.childNodes[i]["objectData"];
      res = res + item.caption + "";
    }
    return res;
  }
  isXYOnMenu(x, y) {
    if (!this.visible)
      return false;
    if (x >= this.Menutable.offsetLeft && x <= this.Menutable.offsetLeft + this.Menutable.offsetWidth && y >= this.Menutable.offsetTop && y <= this.Menutable.offsetTop + this.Menutable.offsetHeight) {
      return true;
    }
    for (let i = 0; i < this.Menutable.childNodes.length; i++) {
      let item = this.Menutable.childNodes[i]["objectData"];
      if (item instanceof ContextMenuItemSubMenuEntry) {
        if (item.submenu.isXYOnMenu(x, y))
          return true;
      }
    }
    return false;
  }
  activateNext(source) {
    let found = false;
    for (let i = 0; i < this.Menutable.childNodes.length; i++) {
      let item = this.Menutable.childNodes[i]["objectData"];
      if (item == source) {
        found = true;
      } else if (found && item.focusable) {
        item.focus();
        return;
      }
    }
  }
  activatePrevious(source) {
    let previous = null;
    for (let i = 0; i < this.Menutable.childNodes.length; i++) {
      let item = this.Menutable.childNodes[i]["objectData"];
      if (item == source) {
        if (previous != null)
          previous.focus();
        return;
      }
      if (item.focusable)
        previous = item;
    }
  }
  get width() {
    return this.Menutable.offsetWidth;
  }
  closeSubmenus() {
    this.closeSubMenusExcept(null);
  }
  get zIndex() {
    return this._zIndex;
  }
  set zIndex(value) {
    this._zIndex = value;
    this.Menutable.style.zIndex = this._zIndex.toString();
  }
  get visible() {
    return this.Menutable.style.display != "none";
  }
  set visible(value) {
    this.Menutable.style.display = value ? "" : "none";
  }
  close() {
    this.cancelDelayedAction();
    for (let i = 0; i < this.Menutable.childNodes.length; i++) {
      let item = this.Menutable.childNodes[i]["objectData"];
      item.parentMenuisClosing();
    }
    this.visible = false;
    this.closeSubmenus();
  }
  refresh() {
    let showSeparation = false;
    for (let i = 0; i < this.Menutable.childNodes.length; i++) {
      let element = this.Menutable.childNodes[i];
      if (element.className == ContextMenu.SEPARATOR_MARKER) {
        element.style.display = showSeparation ? "" : "none";
        showSeparation = false;
      } else if (element.style.display == "")
        showSeparation = true;
    }
  }
  addMenuItem(icon, caption, callback) {
    let menuItem = new ContextMenuItem(this, icon, caption, callback);
    this.Menutable.appendChild(menuItem.domData);
    return menuItem;
  }
  get menuItemsCount() {
    return this.Menutable.childNodes.length;
  }
  closeSubMenusExcept(doNotClose) {
    for (let i = 0; i < this.Menutable.childNodes.length; i++) {
      let item = this.Menutable.childNodes[i]["objectData"];
      if (item instanceof ContextMenuItemSubMenuEntry) {
        if (item.submenu != doNotClose) {
          item.submenu.close();
        }
      }
    }
  }
  subMenuisOpening(source) {
    this.closeSubMenusExcept(source);
  }
  addSubMenuItem(icon, caption, submenu) {
    submenu.zIndex = this.zIndex + 1;
    let menuItem = new ContextMenuItemSubMenuEntry(this, icon, caption, submenu);
    this.Menutable.appendChild(menuItem.domData);
    return menuItem;
  }
  clearAllContents() {
    while (this.Menutable.childNodes.length > 0) {
      let item = this.Menutable.childNodes[0]["objectData"];
      item.removeAndDestroy();
    }
  }
  AddSeparator() {
    let separator = new ContextMenuSeparator();
    this.Menutable.appendChild(separator.domData);
    return separator;
  }
  showContextMenu(x, y) {
  }
};
ContextMenuBase.SEPARATOR_MARKER = "separator";
ContextMenuBase.iconBGColor = "#fdfdfd";
ContextMenuBase.captionBgColor = "#f1f1f1";
ContextMenuBase.ActiveColor = "#c4e1ff";
var ContextSubMenu = class extends ContextMenuBase {
  constructor(baseSize, parentMenu, openCallback, fontFamily) {
    super(baseSize, openCallback, fontFamily);
    this._parentmenu = parentMenu;
    document.body.appendChild(this.Menutable);
  }
  showContextMenu(x, y) {
    if (this._parentmenu != null)
      this._parentmenu.subMenuisOpening(this);
    if (this._openCallback != null)
      this._openCallback(x, y);
    this.Menutable.style.left = x.toString() + "px";
    this.Menutable.style.top = y.toString() + "px";
    this.visible = true;
    let right = this.Menutable.offsetLeft - this.Menutable.scrollLeft + this.Menutable.offsetWidth;
    let bottom = this.Menutable.offsetTop - this.Menutable.scrollTop + this.Menutable.offsetHeight;
    if (right > window.innerWidth)
      this.Menutable.style.left = (x - (right - window.innerWidth)).toString() + "px";
    if (bottom > window.innerHeight)
      this.Menutable.style.top = (y - (bottom - window.innerHeight)).toString() + "px";
  }
};
var ContextMenu = class extends ContextMenuBase {
  constructor(baseSize, openCallback, fontFamily) {
    super(baseSize, openCallback, fontFamily);
    document.addEventListener("contextmenu", (e) => {
      let tagname = "";
      if (e.target != null && constants.RunningOnAndroid)
        tagname = e.target.tagName;
      if (tagname != "INPUT") {
        e.preventDefault();
        this.showContextMenu(e.pageX, e.pageY);
      }
    });
    document.addEventListener("dblclick", (e) => {
      if (constants.dbleClickBringsUpContextMenu)
        this.showContextMenu(e.pageX, e.pageY);
    });
    document.addEventListener("click", (e) => {
      this.click(e);
    });
    document.body.appendChild(this.Menutable);
  }
  click(e) {
    if (!this.visible)
      return;
    if (!this.isXYOnMenu(e.pageX, e.pageY)) {
      this.close();
    }
  }
  showContextMenu(x, y) {
    let z = YWindow.ConTextMenuBestZindex;
    if (z < 0)
      return;
    this.zIndex = z;
    this.Menutable.style.left = x.toString() + "px";
    this.Menutable.style.top = y.toString() + "px";
    this.visible = true;
    let right = this.Menutable.offsetLeft - this.Menutable.scrollLeft + this.Menutable.offsetWidth;
    let bottom = this.Menutable.offsetTop - this.Menutable.scrollTop + this.Menutable.offsetHeight;
    if (right > window.innerWidth)
      this.Menutable.style.left = Math.max(0, x - (right - window.innerWidth)).toString() + "px";
    if (bottom > window.innerHeight)
      this.Menutable.style.top = Math.max(0, y - (bottom - window.innerHeight)).toString() + "px";
    if (this._openCallback != null)
      this._openCallback(x, y);
    if (x <= 5 && y <= 5)
      this.focusFirst();
  }
};

// obj/full/ressources.js
var ressources = class {
  static SVGheader(size, shadowDef, title) {
    let res = '<svg  xmlns="http://www.w3.org/2000/svg" width="' + size + '" height="' + size + '" viewBox="0 0 128  128">';
    if (typeof title != "undefined")
      res = res + "<title>" + title + "</title>";
    if (shadowDef)
      res = res + '<defs><filter id="f1" x="0" y="0"><feGaussianBlur in="SourceGraphic" stdDeviation="2" /></filter></defs>';
    res = res + '<g transform="translate(0,128)"><g transform="scale(1,-1)">';
    return res;
  }
  static SVGFooter() {
    return "</g></g></svg>";
  }
  static addIconTransparency() {
    return '<g opacity="0.5">';
  }
  static addIconSrcCode() {
    return '<path d="m 8 24 L 8 40 L 24 40 L 24 56 L 40 56 L 40 40 L 56 40 L 56 24 L 40 24 L 40 8 L 24 8 L 24 24   Z" fill="#40ff40" stroke="black" stroke-width="8" stroke-linecap="round"/>';
  }
  static deleteIconSrcCode() {
    return '<path d="m 15 4 L 4 15 L 19 29 L 4 43 L 15 55 L 29 40 L 43 55 L 55 43 L 40 29 L 55 15 L 44 4 L 29 18 Z" fill="#ff4040" stroke="black" stroke-width="8" stroke-linecap="round">';
  }
  static IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, shadowcode, activeCode, title) {
    let res = ressources.SVGheader(size, shadow, title);
    if (shadow)
      res = res + '<g transform="translate(6,-6)">' + shadowcode + "</g>";
    if (semitransparent)
      res = res + ressources.addIconTransparency();
    res = res + activeCode;
    if (semitransparent)
      res = res + "</g>";
    if (addIcon)
      res = res + ressources.addIconSrcCode();
    if (deleteIcon)
      res = res + ressources.deleteIconSrcCode();
    res = res + ressources.SVGFooter();
    return res;
  }
  static GraphIcon(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="m 12 24 L 103 24 L 103 107 L 12 107 z" fill="lightgray" filter="url(#f1)" /><path d="m 112 24 L 12 24 L 12 113"  style="fill:none; stroke:lightgray; stroke-width:4px; stroke-linejoin:round;stroke-linecap:round;" filter="url(#f1)"/>', '<path d="m 12 24 L 103 24 L 103 107 L 12 107 z" fill="#ffffe9" /><line x1="43" y1="24" x2="43" y2="107" stroke="#e3e3e3" stroke-width="2" stroke-linecap="round" /><line x1="43" y1="24" x2="43" y2="107" stroke="#e3e3e3" stroke-width="2" stroke-linecap="round" /><line x1="73" y1="24" x2="73" y2="107" stroke="#e3e3e3" stroke-width="2" stroke-linecap="round" /><line x1="12" y1="51" x2="103" y2="51" stroke="#e3e3e3" stroke-width="2" stroke-linecap="round" /><line x1="12" y1="79" x2="103" y2="79" stroke="#e3e3e3" stroke-width="2" stroke-linecap="round" /><line x1="12" y1="107" x2="103" y2="107" stroke="#e3e3e3" stroke-width="2" stroke-linecap="round" /><path d="m 12 77 L 34 65 L 55 85 L 70 77 L 100 93" fill="none" stroke="#FF0000" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" /><line x1="103" y1="24" x2="103" y2="107" stroke="#e3e3e3" stroke-width="2" stroke-linecap="round" /><path d="m 112 24 L 12 24 L 12 113"  style="fill:none; stroke:black; stroke-width:4px; stroke-linejoin:round;stroke-linecap:round;"/>');
  }
  static SolidGaugeIcon(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="M 34 40 L 14 40 14 52 A 50 50 0 0 0 114 52 L  114 40 L 94 40 L 94 52 A 30 30 0 1 1  34 52 Z" style="fill:lightgray;fill-opacity=0.4;" filter="url(#f1)"/><text x="43" y="-30" fill="black" transform="scale(1,-1)" style="font: bold 24px sans-serif;fill:lightgray;fill-opacity=0.4;" filter="url(#f1)">123</text>', '<path d="M 34 40 L 14 40 14 52 A 50 50 0 0 0 114 52 L  114 40 L 94 40 L 94 52 A 30 30 0 1 1  34 52 Z" style="fill:#ffffe9; stroke:none; "/><path d="M 34 40 L 14 40 14 52 A 50 50 0 0 0 29 88 L  43 72.5   A 30 30 0 0 1  34 52 Z" style="fill:red; stroke:none;"/><path d="M 34 40 L 14 40 14 52 A 50 50 0 0 0 114 52 L  114 40 L 94 40 L 94 52 A 30 30 0 1 1  34 52 Z" style="fill:none; stroke:black; stroke-width:4px; stroke-linejoin:round;stroke-linecap:round;"/><text x="43" y="-30" fill="black" transform="scale(1,-1)" style="font: bold 24px sans-serif;">123</text>');
  }
  static RawDataIcon(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="m 16 27 L 107 27 L 107 107 L 16 107 z" fill="lightgray" filter="url(#f1)" />', '<path d="m 16 27 L 107 27 L 107 107 L 16 107 z" style="fill:#ffffe9;" /><line x1="47" y1="27" x2="47" y2="107" stroke="#e3e3e3" stroke-width="2"  /><line x1="76" y1="27" x2="76" y2="107" stroke="#e3e3e3" stroke-width="2"  /><line x1="16" y1="44" x2="107" y2="44" stroke="#e3e3e3" stroke-width="2"  /><line x1="16" y1="60" x2="107" y2="60" stroke="#e3e3e3" stroke-width="2"  /><line x1="16" y1="76" x2="107" y2="76" stroke="#e3e3e3" stroke-width="2"  /><path d="m 16 27 L 107 27 L 107 107 L 16 107 z" style="fill:none;stroke:black; stroke-width:4px; stroke-linejoin:round;" /><path d="m 19 91 L 104 91 L 104 104 L 19 104 z" style="fill:#b2b2b2; stroke:#6f6f6f; stroke-width:4px; stroke-linejoin:round;" /><line x1="47" y1="91" x2="47" y2="104" stroke="#6f6f6f" stroke-width="2"  /><line x1="76" y1="91" x2="76" y2="104" stroke="#6f6f6f" stroke-width="2"  />');
  }
  static ConfigureIcon(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="M85 85 L 102 80 L 113 91 A  41 100 45 0 0  86 71 L 37 21 A  5 11 45 1 0  21 37 L 71 86  A  41 100 45 0 0  91 113 L 80 102 Z" style="fill:lightgray;fill-opacity=0.4;" filter="url(#f1)"/>', '<path d="M85 85 L 102 80 L 113 91 A  41 100 45 0 0  86 71 L 37 21 A  5 11 45 1 0  21 37 L 71 86  A  41 100 45 0 0  91 113 L 80 102 Z" style="fill:grey; stroke:black; stroke-width:4px; stroke-linejoin:round;stroke-linecap:round;"/>');
  }
  static DigitalDisplayIcon(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="m 12 45 L 111 45 L 111 89 L 12 89 z" fill="lightgray" filter="url(#f1)" />', '<path d="m 12 45 L 111 45 L 111 89 L 12 89 z" style="fill:#ffffe9; stroke:black; stroke-width:4px; stroke-linejoin:round;" /><text x="29" y="-52" fill="black" transform="scale(1,-1)" style="font: bold 40px sans-serif;">123</text> ');
  }
  static AngularGaugeIcon(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<circle  cx="64" cy="64" r="40" fill="lightgray" filter="url(#f1)" />', '<circle  cx="64" cy="64" r="40" stroke="black" stroke-width="4" fill="#ffffe9" /><line x1="64" y1="104" x2="64" y2="94" stroke="black" stroke-width="2"   stroke-linecap="round" /><line x1="29" y1="84" x2="38" y2="79" stroke="black" stroke-width="2"   stroke-linecap="round" /><line x1="29" y1="44" x2="38" y2="48" stroke="black" stroke-width="2"   stroke-linecap="round" /><line x1="98" y1="84" x2="91" y2="79" stroke="black" stroke-width="2"   stroke-linecap="round" /><line x1="98" y1="44" x2="91" y2="48" stroke="black" stroke-width="2"   stroke-linecap="round" /><g transform="translate(64,64)"><g transform="rotate(-70,0,0)"><path d="m 5 0 L 0 5 L -25 0 L 0 -5 z" style="fill:black;stroke:black; stroke-width:2px; stroke-linejoin:round;"/></g></g>');
  }
  static EditIcon(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="m 16 48 L 108 48 L 108 88 L 16 88 z" fill="lightgray" filter="url(#f1)" /><path d="m 87 24 L 75 40 L 67 31 L 62 64 L 93 50 L 82 44  L 94 29 z" fill="lightgray" filter="url(#f1)" />', '<path d="m 16 48 L 108 48 L 108 88 L 16 88 z" style="fill:#ffffe9; stroke:black; stroke-width:4px; stroke-linejoin:round;" /><path d="m 87 24 L 75 40 L 67 31 L 62 64 L 93 50 L 82 44  L 94 29 z" style="fill:white; stroke:black; stroke-width:2px; stroke-linejoin:round;" /> ');
  }
  static AllIcon(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="m 60 108 L 46 74 L 8 72 L 38 48 L 28 12 L 60 32 L 92 12  L 82 48 L 112 70  L 74 74  z" fill="lightgray" filter="url(#f1)" />', '<path d="m 60 108 L 46 74 L 8 72 L 38 48 L 28 12 L 60 32 L 92 12  L 82 48 L 112 70  L 74 74  z" style="fill:#fee403; stroke:#918201; stroke-width:4px; stroke-linejoin:round;" />');
  }
  static TrashIcon(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="m 33 12 L 24 94 L 104 94 L 95 12 z" fill="lightgray" filter="url(#f1)" /><g transform="translate(70,105)"><g transform="rotate(-10,0,0)"><path d="m -40 0 L -30 5 L 30 5 L 40 0 z" fill="lightgray" filter="url(#f1)" /><path d="m -9 5 L -9 12 L 9 12 L 9 5" stroke="lightgray" filter="url(#f1)"/> </g></g>', '<path d="m 33 12 L 24 94 L 104 94 L 95 12 z" style="fill:#f8f8f8; stroke:black; stroke-width:4px; stroke-linejoin:round;" /><Line x1="43" y1="82" x2="48" y2="21" style=" stroke:black; stroke-width:4px; stroke-linecap:round;" /><Line x1="64" y1="82" x2="64" y2="21" style=" stroke:black; stroke-width:4px; stroke-linecap:round;" /><Line x1="86" y1="82" x2="80" y2="21" style=" stroke:black; stroke-width:4px; stroke-linecap:round;" /><g transform="translate(70,105)"><g transform="rotate(-10,0,0)"><path d="m -40 0 L -30 5 L 30 5 L 40 0 z" style="fill:#f8f8f8; stroke:black; stroke-width:4px; stroke-linejoin:round;" /><path d="m -9 5 L -9 12 L 9 12 L 9 5" style="fill:none; stroke:black; stroke-width:4px; stroke-linejoin:round;" /></g></g>');
  }
  static SaveIcon(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="m 20 12 A 4 4 0 0 0 16 16 L 16 106  A 4 4 0 0 0 20 110 L 24 110 L 24 108 L 97 108 L 97 110 L 104 110  A 4 4 0 0 0 108 106 L 108 16   A 4 4 0 0 0 104 12  z" fill="lightgray" filter="url(#f1)" />', '<path d="m 20 12 A 4 4 0 0 0 16 16 L 16 106  A 4 4 0 0 0 20 110 L 24 110 L 24 108 L 97 108 L 97 110 L 104 110  A 4 4 0 0 0 108 106 L 108 16   A 4 4 0 0 0 104 12  z" style="fill:#3583dd; stroke:#226fc8; stroke-width:4px; stroke-linejoin:round;" /><path d="m 24 11 L 24 65  A 5 5 0 0 0 29 70 L 95 70  A 5 5 0 0 0 100 65 L 100 11  z" style="fill:#f7f7f7; stroke:#c6c6c6; stroke-width:2px; stroke-linejoin:round;"/><path d="m 36 111 L 90 111 L 90 80 A 4 4 0 0 0 86 76 L 40 76 A 4 4 0 0 0 36 80 z"  style="fill:#e5e5e5; stroke:#c6c6c6; stroke-width:2px; stroke-linejoin:round;" /><rect x="67" y="79" width="14" height ="28"     style="fill:#3583dd; stroke:#c6c6c6; stroke-width:2px; stroke-linejoin:round;"');
  }
  static SaveNeededIcon(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="m 8 16 L 64 110 L 120 16 z " style="fill:lightgray; stroke:lightgray; stroke-width:10px; stroke-linejoin:round;filter:url(#f1)" />', '<path d="m 8 16 L 64 110 L 120 16 z" style="fill:#FAE701; stroke:#FAE701; stroke-width:10px; stroke-linejoin:round;" /><path d="m 8 16 L 64 110 L 120 16 z" style="fill:none; stroke:black; stroke-width:2px; stroke-linejoin:round;" /><g transform="translate(-64,-64) scale(0.4 0.4) translate(260,215)"><path d="m 20 12 A 4 4 0 0 0 16 16 L 16 106  A 4 4 0 0 0 20 110 L 24 110 L 24 108 L 97 108 L 97 110 L 104 110  A 4 4 0 0 0 108 106 L 108 16   A 4 4 0 0 0 104 12  z" style="fill:black; stroke:black; stroke-width:4px; stroke-linejoin:round;" /><path d="m 24 11 L 24 65  A 5 5 0 0 0 29 70 L 95 70  A 5 5 0 0 0 100 65 L 100 11  z" style="fill:#FAE701; stroke:black; stroke-width:2px; stroke-linejoin:round;"/><path d="m 36 111 L 90 111 L 90 80 A 4 4 0 0 0 86 76 L 40 76 A 4 4 0 0 0 36 80 z"  style="fill:#FAE701; stroke:black; stroke-width:2px; stroke-linejoin:round;" /><rect x="67" y="79" width="14" height ="28"     style="fill:#FAE701; stroke:black; stroke-width:2px; stroke-linejoin:round;"</g>', "Don't forget to save.");
  }
  static snapshotIcon(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="m 16 32  L 16 78 A 6 6 0 0 0 22 84 L 46 84 L 48 94 A 5.75 3.25 30 0 0 54 100 L 78 100 A 3.25 5.75  30 0 0 84 94  L 86 84 L 104 84  A 6 6 0 0 0 110 78  L 110 32 A 6 6 0 0 0 104 26 L 22 26 A 6 6 0 0 0 16 32 z"  fill="lightgray" filter="url(#f1)" />', '<path d="m 16 32  L 16 78 A 6 6 0 0 0 22 84 L 46 84 L 48 94 A 5.75 3.25 30 0 0 54 100 L 78 100 A 3.25 5.75  30 0 0 84 94  L 86 84 L 104 84  A 6 6 0 0 0 110 78  L 110 32 A 6 6 0 0 0 104 26 L 22 26 A 6 6 0 0 0 16 32 z" style="fill:#707070; stroke:#464646; stroke-width:4px; stroke-linejoin:round;" /><Circle cx="65" cy="55" r="26"   style="fill:#895e96; stroke:#464646; stroke-width:6px; stroke-linejoin:round;" />');
  }
  static CloseIcon(size, shadow, semitransparent, addIcon, deleteIcon, title) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="m 21.6 38.6 L 47.1 64.3 L 22 89.5 L 38.4 106.2 L 64 81 L 89.3 106.2 L 105.8 89.5 L 80.6 64 L 105.8 38.9 L 89.3 22.2 L 64 47.5  L 38.3 22.1 z"  fill="lightgray" filter="url(#f1)" />', '<path d="m 21.6 38.6 L 47.1 64.3 L 22 89.5 L 38.4 106.2 L 64 81 L 89.3 106.2 L 105.8 89.5 L 80.6 64 L 105.8 38.9 L 89.3 22.2 L 64 47.5  L 38.3 22.1 z" style="fill:#ffffff; stroke:#004a82; stroke-width:4px; stroke-linejoin:round;" />', title);
  }
  static MoveToRightIcon(size, shadow, semitransparent, addIcon, deleteIcon, title) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<rect x="12" y="52" width="4"  height="24" fill="lightgray" filter="url(#f1)" /><rect x="20" y="52" width="8"  height="24" fill="lightgray" filter="url(#f1)" /><rect x="56" y="16" width="16"  height="96" fill="lightgray" filter="url(#f1)" /><path d="m  32 52 L 32 76 L 56 76 L 56 96 L 88 64 L 56 32 L 56 52 z" fill="lightgray" filter="url(#f1)" />', '<rect x="12" y="52" width="4"  height="24" style="fill:#ffffff; stroke:#004a82; stroke-width:4px; stroke-linejoin:round;" /><rect x="20" y="52" width="8"  height="24" style="fill:#ffffff; stroke:#004a82; stroke-width:4px; stroke-linejoin:round;" /><rect x="96" y="16" width="16"  height="96" style="fill:#ffffff; stroke:#004a82; stroke-width:4px; stroke-linejoin:round;" /><path d="m  32 52 L 32 76 L 56 76 L 56 96 L 88 64 L 56 32 L 56 52 z" style="fill:#ffffff; stroke:#004a82; stroke-width:4px; stroke-linejoin:round;" />', title);
  }
  static MoveToLeftIcon(size, shadow, semitransparent, addIcon, deleteIcon, title) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<rect x="112" y="52" width="4"  height="24" fill="lightgray" filter="url(#f1)" /><rect x="100" y="52" width="8"  height="24" fill="lightgray" filter="url(#f1)" /><rect x="16" y="16" width="16"  height="96" fill="lightgray" filter="url(#f1)" /><path d="m  96 52 L 96 76 L 72 76 L 72 96 L 40 64 L 72 32 L 72 52 z" fill="lightgray" filter="url(#f1)" />', '<rect x="112" y="52" width="4"  height="24" style="fill:#ffffff; stroke:#004a82; stroke-width:4px; stroke-linejoin:round;" /><rect x="100" y="52" width="8"  height="24" style="fill:#ffffff; stroke:#004a82; stroke-width:4px; stroke-linejoin:round;" /><rect x="16" y="16" width="16"  height="96" style="fill:#ffffff; stroke:#004a82; stroke-width:4px; stroke-linejoin:round;" /><path d="m  96 52 L 96 76 L 72 76 L 72 96 L 40 64 L 72 32 L 72 52 z" style="fill:#ffffff; stroke:#004a82; stroke-width:4px; stroke-linejoin:round;" />', title);
  }
  static ExpandIcon(size, shadow, semitransparent, addIcon, deleteIcon, title) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="m  24 56 L 24 72 L 56 72 L 56 104 L 72 104 L 72 72 L 104 72 L 104 56 L 72 56 L 72 24 L 56 24 L 56 56 z"  fill="lightgray" filter="url(#f1)" />', '<path d="m 24 56 L 24 72 L 56 72 L 56 104 L 72 104 L 72 72 L 104 72 L 104 56 L 72 56 L 72 24 L 56 24 L 56 56  z" style="fill:black; " />', title);
  }
  static OkIcon(size, shadow, semitransparent, addIcon, deleteIcon, title) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<circle cx="64" cy="64" r="56"   fill="lightgray" filter="url(#f1)" />', '<circle cx="64" cy="64" r="56" fill="#00b20f"/><path d="m 19 72 L 34 87 L 60 62 L 94 96 L 109 81 L 60 32  z" style="fill:white; " />', title);
  }
  static FailedIcon(size, shadow, semitransparent, addIcon, deleteIcon, title) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<circle cx="64" cy="64" r="56"   fill="lightgray" filter="url(#f1)" />', '<circle cx="64" cy="64" r="56" fill="#ff101e"/><path d="m 43 99 L 64 79 L 85 99 L 100 85 L 79 64 L 100 43 L 85 28 L 64 49 L 43 28 L 28  43 L 49 64 L  28 85   z" style="fill:white; " />', title);
  }
  static DontKnowIcon(size, shadow, semitransparent, addIcon, deleteIcon, title) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<circle cx="64" cy="64" r="56"   fill="lightgray" filter="url(#f1)" />', '<circle cx="64" cy="64" r="56" fill="#f1ba00"/><text x="35" y="-30" fill="white" transform="scale(1,-1)" style="font: bold 96px sans-serif;">?</text> ', title);
  }
  static infoIcon(size, shadow, semitransparent, addIcon, deleteIcon, title) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<circle cx="64" cy="64" r="56"   fill="lightgray" filter="url(#f1)" />', '<circle cx="64" cy="64" r="56" fill="DodgerBlue"/><text x="50" y="-30" fill="white" transform="scale(1,-1)" style="font: bold 96px sans-serif;">i</text> ', title);
  }
  static ColapseIcon(size, shadow, semitransparent, addIcon, deleteIcon, title) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="m 24 56 L 24 72 L 104 72 L 104 56 z"  fill="lightgray" filter="url(#f1)" />', '<path d="m 24 56 L 24 72 L 104 72 L 104 56 z" style="fill:black; " />', title);
  }
  static AddMarkerIcon(size, index) {
    return ressources.IconSourceCode(size, false, false, false, false, "", '<circle  cx="64" cy="64"  r="50"   style="fill:lightyellow;" stroke-width="8" stroke="darkred" /><text x="46" y="-40" fill="black" transform="scale(1,-1)" style="font: bold 64px sans-serif;">' + index.toString() + "</text>");
  }
  static AddMarker(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, "", '<line x1="80" y1="8" x2="80" y2="128" stroke="darkred" stroke-width="8" stroke-linecap="round" /><path d="m 60 64 L 100 64 L 80 20 z" style="fill:darkred; " /><rect x="40" y="56" width="80" height="32" style="fill:lightYellow" stroke="darkred" stroke-width="8" />');
  }
  static EraseDatalogger(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, "", '<g transform="rotate(-35,0,0)"><g transform="translate(-56,24)"><path d="m 108 24 L 108 46 L 60 46  A 22 22 0 1 0 60 90 L 108 90  L 108 112 L 60 112 A 44 44 0 1 1 60 24 z" style="fill:#808080; " /><rect x="88" y="24" width="20" height="22" style="fill:red" stroke="none"  /><rect x="88" y="90" width="20" height="22" style="fill:blue" stroke="none"  /><path d="m 108 24 L 108 46 L 60 46  A 22 22 0 1 0 60 90 L 108 90  L 108 112 L 60 112 A 44 44 0 1 1 60 24 z"  style="fill:none" stroke="black"  stroke-width="4" stroke-linejoin="round"/></g></g>');
  }
  static resetViewPort(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, "", '<line x1="116" y1="52" x2="116" y2="12"  stroke="black"  stroke-width="4"/><line x1="12" y1="52" x2="12" y2="12"  stroke="black"  stroke-width="4"/><path d="m 100 36 L 28 36 L 28 48 L 12 32  L 28 16 L 28 28 L 100 28 L 100 16 L 116 32 L 100 48z" style="fill:white" stroke="black"  stroke-width="4" stroke-linejoin="round" /><path d="m 7.3 97.7 L 20 107.4 L 51.6 114.7 L 78.5 112.2 L 101.6 103.3 L 114.4 91.7  L 117.7 81.7 L 104.3 66.9 L 80.9 61.2 L49.9 65 L 25 76.3 L 12.6 87.5 Z " style="fill:white" stroke="none" /><circle  cx="64" cy="88" r="27" style="fill:#6cc87b" stroke="none"  /> <path d="m 37.2 84.8 A 27 27 0 0 0 46.5 108.8 L 64 88 z" style="fill:#8ed698" stroke="none" /> <circle  cx="64" cy="88" r="16" style="fill:black" stroke="none"  /> <path d="m 6 97 A 59 34 -4 0 0 119 80" style="fill:none" stroke="black"  stroke-width="4"  stroke-linecap="round"/> <path d="m 113 79 A 56 31 -16 0 0 9 93 " style="fill:none" stroke="black"  stroke-width="4"  stroke-linecap="round" /> ');
  }
  static DeleteMarker(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, "", '<line x1="80" y1="8" x2="80" y2="128" stroke="darkred" stroke-width="8" stroke-linecap="round" /><path d="m 60 64 L 100 64 L 80 20 z" style="fill:darkred; " /><rect x="40" y="56" width="80" height="32" style="fill:lightYellow" stroke="darkred" stroke-width="8" />');
  }
  static targetIcon(size, shadow, semitransparent, addIcon, deleteIcon, title) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, "", '<circle  cx="64" cy="64"  r="42"   style="fill:none;" stroke-width="8" stroke="black" /><line  x1="0"   y1="64"  x2="42"  y2="64"  style="fill:none;" stroke-width="8" stroke="black" /><line  x1="128" y1="64"  x2="86"  y2="64"  style="fill:none;" stroke-width="8" stroke="black" /><line  y1="0"   x1="64"  y2="42"  x2="64"  style="fill:none;" stroke-width="8" stroke="black" /><line  y1="128" x1="64"  y2="86"  x2="64"  style="fill:none;" stroke-width="8" stroke="black" />', title);
  }
  static DotDotDotIcon(size, shadow, semitransparent, addIcon, deleteIcon, title) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, "", '<rect x="18" y="36" width="18" height="18" style="fill:black" /><rect x="54" y="36" width="18" height="18" style="fill:black" /><rect x="90" y="36" width="18" height="18" style="fill:black" />', title);
  }
  static LogFileIcon(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, "", '<line x1="4" y1="24" x2="30" y2="24"     style=" stroke:black; stroke-width:8px;" /><line x1="34" y1="24" x2="56" y2="24"    style=" stroke:black; stroke-width:8px; " /><line x1="64" y1="24" x2="74" y2="24"    style=" stroke:black; stroke-width:8px; " /><line x1="80" y1="24" x2="88" y2="24"    style=" stroke:black; stroke-width:8px; " /><line x1="4" y1="40" x2="30" y2="40"     style=" stroke:black; stroke-width:8px;" /><line x1="34" y1="40" x2="56" y2="40"    style=" stroke:black; stroke-width:8px; " /><line x1="61" y1="40" x2="90" y2="40"    style=" stroke:black; stroke-width:8px; " /><line x1="94" y1="40" x2="110" y2="40"    style=" stroke:black; stroke-width:8px; " /><line x1="4" y1="56" x2="30" y2="56"     style=" stroke:black; stroke-width:8px;" /><line x1="34" y1="56" x2="56" y2="56"    style=" stroke:black; stroke-width:8px; " /><line x1="61" y1="56" x2="86" y2="56"    style=" stroke:black; stroke-width:8px; " /><line x1="4" y1="72" x2="30" y2="72"     style=" stroke:black; stroke-width:8px;" /><line x1="34" y1="72" x2="50" y2="72"    style=" stroke:black; stroke-width:8px; " /><line x1="56" y1="72" x2="100" y2="72"    style=" stroke:black; stroke-width:8px; " /><line x1="4" y1="88" x2="30" y2="88"     style=" stroke:black; stroke-width:8px;" /><line x1="34" y1="88" x2="56" y2="88"    style=" stroke:black; stroke-width:8px; " /><line x1="61" y1="88" x2="72" y2="88"    style=" stroke:black; stroke-width:8px; " /><line x1="78" y1="88" x2="106" y2="88"    style=" stroke:black; stroke-width:8px; " />');
  }
};

// obj/full/Pako/utils/common.js
var utils_common = class {
  static flattenChunks(chunks) {
    let len = 0;
    for (let i = 0, l = chunks.length; i < l; i++) {
      len += chunks[i].length;
    }
    const result = new Uint8Array(len);
    for (let i = 0, pos = 0, l = chunks.length; i < l; i++) {
      let chunk = chunks[i];
      result.set(chunk, pos);
      pos += chunk.length;
    }
    return result;
  }
};

// obj/full/Pako/utils/strings.js
var Pako_strings = class {
  static _init() {
    try {
      String.fromCharCode.apply(null, new Uint8Array(1));
    } catch (__) {
      Pako_strings.STR_APPLY_UIA_OK = false;
    }
    for (let q = 0; q < 256; q++) {
      Pako_strings._utf8len[q] = q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1;
    }
    Pako_strings._utf8len[254] = Pako_strings._utf8len[254] = 1;
    return true;
  }
  static string2buf(str) {
    let buf;
    let c;
    let c2;
    let m_pos;
    let i;
    let str_len = str.length;
    let buf_len = 0;
    for (m_pos = 0; m_pos < str_len; m_pos++) {
      c = str.charCodeAt(m_pos);
      if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
        c2 = str.charCodeAt(m_pos + 1);
        if ((c2 & 64512) === 56320) {
          c = 65536 + (c - 55296 << 10) + (c2 - 56320);
          m_pos++;
        }
      }
      buf_len += c < 128 ? 1 : c < 2048 ? 2 : c < 65536 ? 3 : 4;
    }
    buf = new Uint8Array(buf_len);
    for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
      c = str.charCodeAt(m_pos);
      if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
        c2 = str.charCodeAt(m_pos + 1);
        if ((c2 & 64512) === 56320) {
          c = 65536 + (c - 55296 << 10) + (c2 - 56320);
          m_pos++;
        }
      }
      if (c < 128) {
        buf[i++] = c;
      } else if (c < 2048) {
        buf[i++] = 192 | c >>> 6;
        buf[i++] = 128 | c & 63;
      } else if (c < 65536) {
        buf[i++] = 224 | c >>> 12;
        buf[i++] = 128 | c >>> 6 & 63;
        buf[i++] = 128 | c & 63;
      } else {
        buf[i++] = 240 | c >>> 18;
        buf[i++] = 128 | c >>> 12 & 63;
        buf[i++] = 128 | c >>> 6 & 63;
        buf[i++] = 128 | c & 63;
      }
    }
    return buf;
  }
  static buf2binstring(buf, len) {
    let result = "";
    for (let i = 0; i < len; i++) {
      result += String.fromCharCode(buf[i]);
    }
    return result;
  }
  static buf2string(buf, max) {
    let i;
    let out;
    const len = max || buf.length;
    const utf16buf = new Array(len * 2);
    for (out = 0, i = 0; i < len; ) {
      let c = buf[i++];
      if (c < 128) {
        utf16buf[out++] = c;
        continue;
      }
      let c_len = Pako_strings._utf8len[c];
      if (c_len > 4) {
        utf16buf[out++] = 65533;
        i += c_len - 1;
        continue;
      }
      c &= c_len === 2 ? 31 : c_len === 3 ? 15 : 7;
      while (c_len > 1 && i < len) {
        c = c << 6 | buf[i++] & 63;
        c_len--;
      }
      if (c_len > 1) {
        utf16buf[out++] = 65533;
        continue;
      }
      if (c < 65536) {
        utf16buf[out++] = c;
      } else {
        c -= 65536;
        utf16buf[out++] = 55296 | c >> 10 & 1023;
        utf16buf[out++] = 56320 | c & 1023;
      }
    }
    return Pako_strings.buf2binstring(utf16buf, out);
  }
  static utf8border(buf, max) {
    max = max || buf.length;
    if (max > buf.length) {
      max = buf.length;
    }
    let pos = max - 1;
    while (pos >= 0 && (buf[pos] & 192) === 128) {
      pos--;
    }
    if (pos < 0) {
      return max;
    }
    if (pos === 0) {
      return max;
    }
    return pos + Pako_strings._utf8len[buf[pos]] > max ? pos : max;
  }
};
Pako_strings.STR_APPLY_UIA_OK = true;
Pako_strings._utf8len = new Uint8Array(256);
Pako_strings.initDone = Pako_strings._init();

// obj/full/Pako/deflate.js
var Pako_deflate_option = class {
  constructor(CustOption) {
    this.level = zlib_constants.Z_DEFAULT_COMPRESSION;
    this.method = zlib_constants.Z_DEFLATED;
    this.chunkSize = 16384;
    this.windowBits = 15;
    this.memLevel = 8;
    this.strategy = zlib_constants.Z_DEFAULT_STRATEGY;
    this.raw = false;
    this.gzip = false;
    this.header = null;
    this.dictionary = null;
    this.ignore_os = false;
    Pako_deflate_option.ApplyCustomOptions(this, CustOption);
  }
  static ApplyCustomOptions(StdOption, CustOption) {
    if (typeof CustOption != "undefined") {
      let stdKeys = Object.keys(StdOption);
      let custKeys = Object.keys(CustOption);
      for (let i = 0; i < custKeys.length; i++) {
        if (stdKeys.indexOf(custKeys[i]) < 0) {
          debugger;
          throw "Invalid Pako option name '" + custKeys[i] + "', check Pako_deflate_option class";
        }
        let srcType = typeof Reflect.get(CustOption, custKeys[i]);
        let trgtType = typeof Reflect.get(StdOption, custKeys[i]);
        if (srcType != trgtType)
          throw "Invalid Pako type for option '" + custKeys[i] + "' (expected '" + trgtType + "', got '" + srcType + "')";
        Reflect.set(StdOption, custKeys[i], Reflect.get(CustOption, custKeys[i]));
      }
    }
  }
};
var Pako_Deflate = class {
  constructor(options) {
    this._dict_set = false;
    this.result = null;
    this.options = new Pako_deflate_option(options);
    let opt = this.options;
    if (opt.raw && opt.windowBits > 0) {
      opt.windowBits = -opt.windowBits;
    } else if (opt.gzip && opt.windowBits > 0 && opt.windowBits < 16) {
      opt.windowBits += 16;
    }
    this.err = 0;
    this.msg = "";
    this.ended = false;
    this.chunks = [];
    this.strm = new zlib_ZStream();
    this.strm.avail_out = 0;
    let status = zlib_deflate.deflateInit2(this.strm, opt.level, opt.method, opt.windowBits, opt.memLevel, opt.strategy);
    if (status !== zlib_constants.Z_OK) {
      throw new Error(zlib_messages.msg(status));
    }
    if (opt.header) {
      zlib_deflate.deflateSetHeader(this.strm, opt.header);
    }
    if (opt.dictionary) {
      let dict;
      if (typeof opt.dictionary === "string") {
        dict = Pako_strings.string2buf(opt.dictionary);
      } else if (toString.call(opt.dictionary) === "[object ArrayBuffer]") {
        dict = new Uint8Array(opt.dictionary);
      } else {
        dict = opt.dictionary;
      }
      status = zlib_deflate.deflateSetDictionary(this.strm, dict);
      if (status !== zlib_constants.Z_OK) {
        throw new Error(zlib_messages.msg(status));
      }
      this._dict_set = true;
    }
  }
  push(data, flush_mode) {
    const strm = this.strm;
    const chunkSize = this.options.chunkSize;
    let status;
    let _flush_mode;
    if (this.ended) {
      return false;
    }
    if (flush_mode === ~~flush_mode) {
      _flush_mode = flush_mode;
    } else {
      _flush_mode = flush_mode === true ? zlib_constants.Z_FINISH : zlib_constants.Z_NO_FLUSH;
    }
    if (typeof data === "string") {
      strm.input = Pako_strings.string2buf(data);
    } else if (toString.call(data) === "[object ArrayBuffer]") {
      strm.input = new Uint8Array(data);
    } else {
      strm.input = data;
    }
    strm.next_in = 0;
    strm.avail_in = strm.input.length;
    for (; ; ) {
      if (strm.avail_out === 0) {
        strm.output = new Uint8Array(chunkSize);
        strm.next_out = 0;
        strm.avail_out = chunkSize;
      }
      if ((_flush_mode === zlib_constants.Z_SYNC_FLUSH || _flush_mode === zlib_constants.Z_FULL_FLUSH) && strm.avail_out <= 6) {
        this.onData(strm.output.subarray(0, strm.next_out));
        strm.avail_out = 0;
        continue;
      }
      status = zlib_deflate.deflate(strm, _flush_mode);
      if (status === zlib_constants.Z_STREAM_END) {
        if (strm.next_out > 0) {
          this.onData(strm.output.subarray(0, strm.next_out));
        }
        status = zlib_deflate.deflateEnd(this.strm);
        this.onEnd(status);
        this.ended = true;
        return status === zlib_constants.Z_OK;
      }
      if (strm.avail_out === 0) {
        this.onData(strm.output);
        continue;
      }
      if (_flush_mode > 0 && strm.next_out > 0) {
        this.onData(strm.output.subarray(0, strm.next_out));
        strm.avail_out = 0;
        continue;
      }
      if (strm.avail_in === 0)
        break;
    }
    return true;
  }
  onData(chunk) {
    this.chunks.push(chunk);
  }
  onEnd(status) {
    if (status === zlib_constants.Z_OK) {
      this.result = utils_common.flattenChunks(this.chunks);
    }
    this.chunks = [];
    this.err = status;
    this.msg = this.strm.msg;
  }
  static deflate(input, options) {
    const deflator = new Pako_Deflate(options);
    deflator.push(input, true);
    if (deflator.err) {
      throw deflator.msg || zlib_messages.msg(deflator.err);
    }
    return deflator.result;
  }
  static deflateRaw(input, options) {
    options.raw = true;
    return Pako_Deflate.deflate(input, options);
  }
  static gzip(input, options) {
    if (typeof options == "undefined")
      options = {};
    options.gzip = true;
    return Pako_Deflate.deflate(input, options);
  }
};

// obj/full/Pako/inflate.js
var Pako_inflate_option = class {
  constructor(CustOption) {
    this.chunkSize = 1024 * 64;
    this.windowBits = 15;
    this.to = "";
    this.raw = false;
    this.dictionary = null;
    Pako_inflate_option.ApplyCustomOptions(this, CustOption);
  }
  static ApplyCustomOptions(StdOption, CustOption) {
    if (typeof CustOption != "undefined") {
      let stdKeys = Object.keys(StdOption);
      let custKeys = Object.keys(CustOption);
      for (let i = 0; i < custKeys.length; i++) {
        if (stdKeys.indexOf(custKeys[i]) < 0)
          throw "Invalid Pako option name '" + custKeys[i] + "', check Pako_inflate_option class";
        let srcType = typeof Reflect.get(CustOption, custKeys[i]);
        let trgtType = typeof Reflect.get(StdOption, custKeys[i]);
        if (srcType != trgtType) {
          throw "Invalid Pako type for option '" + custKeys[i] + "' (expected '" + trgtType + "', got '" + srcType + "')";
        }
        Reflect.set(StdOption, custKeys[i], Reflect.get(CustOption, custKeys[i]));
      }
    }
  }
};
var Pako_Inflate = class {
  constructor(options) {
    this.err = 0;
    this.msg = "";
    this.ended = false;
    this.result = null;
    this.options = new Pako_inflate_option(options);
    const opt = this.options;
    if (opt.raw && opt.windowBits >= 0 && opt.windowBits < 16) {
      opt.windowBits = -opt.windowBits;
      if (opt.windowBits === 0) {
        opt.windowBits = -15;
      }
    }
    if (opt.windowBits >= 0 && opt.windowBits < 16 && !(options && options.windowBits)) {
      opt.windowBits += 32;
    }
    if (opt.windowBits > 15 && opt.windowBits < 48) {
      if ((opt.windowBits & 15) === 0) {
        opt.windowBits |= 15;
      }
    }
    this.err = 0;
    this.msg = "";
    this.ended = false;
    this.chunks = [];
    this.strm = new zlib_ZStream();
    this.strm.avail_out = 0;
    let status = zlib_inflate.inflateInit2(this.strm, opt.windowBits);
    if (status !== zlib_constants.Z_OK) {
      throw new Error(zlib_messages.msg(status));
    }
    this.header = new zlib_GZheader();
    zlib_inflate.inflateGetHeader(this.strm, this.header);
    if (opt.dictionary) {
      if (typeof opt.dictionary === "string") {
        opt.dictionary = Pako_strings.string2buf(opt.dictionary);
      } else if (toString.call(opt.dictionary) === "[object ArrayBuffer]") {
        opt.dictionary = new Uint8Array(opt.dictionary);
      }
      if (opt.raw) {
        status = zlib_inflate.inflateSetDictionary(this.strm, opt.dictionary);
        if (status !== zlib_constants.Z_OK) {
          throw new Error(zlib_messages.msg(status));
        }
      }
    }
  }
  push(data, flush_mode) {
    const strm = this.strm;
    const chunkSize = this.options.chunkSize;
    const dictionary = this.options.dictionary;
    let status;
    let _flush_mode;
    let last_avail_out;
    if (this.ended)
      return false;
    if (flush_mode === ~~flush_mode) {
      _flush_mode = flush_mode;
    } else {
      _flush_mode = flush_mode === true ? zlib_constants.Z_FINISH : zlib_constants.Z_NO_FLUSH;
    }
    if (toString.call(data) === "[object ArrayBuffer]") {
      strm.input = new Uint8Array(data);
    } else {
      strm.input = data;
    }
    strm.next_in = 0;
    strm.avail_in = strm.input.length;
    for (; ; ) {
      if (strm.avail_out === 0) {
        strm.output = new Uint8Array(chunkSize);
        strm.next_out = 0;
        strm.avail_out = chunkSize;
      }
      status = zlib_inflate.inflate(strm, _flush_mode);
      if (status === zlib_constants.Z_NEED_DICT && dictionary) {
        status = zlib_inflate.inflateSetDictionary(strm, dictionary);
        if (status === zlib_constants.Z_OK) {
          status = zlib_inflate.inflate(strm, _flush_mode);
        } else if (status === zlib_constants.Z_DATA_ERROR) {
          status = zlib_constants.Z_NEED_DICT;
        }
      }
      while (strm.avail_in > 0 && status === zlib_constants.Z_STREAM_END && strm.state.wrap > 0 && data[strm.next_in] !== 0) {
        zlib_inflate.inflateReset(strm);
        status = zlib_inflate.inflate(strm, _flush_mode);
      }
      switch (status) {
        case zlib_constants.Z_STREAM_ERROR:
        case zlib_constants.Z_DATA_ERROR:
        case zlib_constants.Z_NEED_DICT:
        case zlib_constants.Z_MEM_ERROR:
          this.onEnd(status);
          this.ended = true;
          return false;
      }
      last_avail_out = strm.avail_out;
      if (strm.next_out) {
        if (strm.avail_out === 0 || status === zlib_constants.Z_STREAM_END) {
          if (this.options.to === "string") {
            let next_out_utf8 = Pako_strings.utf8border(strm.output, strm.next_out);
            let tail = strm.next_out - next_out_utf8;
            let utf8str = Pako_strings.buf2string(strm.output, next_out_utf8);
            strm.next_out = tail;
            strm.avail_out = chunkSize - tail;
            if (tail)
              strm.output.set(strm.output.subarray(next_out_utf8, next_out_utf8 + tail), 0);
            this.onData(utf8str);
          } else {
            this.onData(strm.output.length === strm.next_out ? strm.output : strm.output.subarray(0, strm.next_out));
          }
        }
      }
      if (status === zlib_constants.Z_OK && last_avail_out === 0)
        continue;
      if (status === zlib_constants.Z_STREAM_END) {
        status = zlib_inflate.inflateEnd(this.strm);
        this.onEnd(status);
        this.ended = true;
        return true;
      }
      if (strm.avail_in === 0)
        break;
    }
    return true;
  }
  onData(chunk) {
    this.chunks[this.chunks.length] = chunk;
  }
  onEnd(status) {
    if (status === zlib_constants.Z_OK) {
      if (this.options.to === "string") {
        this.result = this.chunks.join("");
      } else {
        this.result = utils_common.flattenChunks(this.chunks);
      }
    }
    this.chunks = [];
    this.err = status;
    this.msg = this.strm.msg;
  }
  static inflate(input, options) {
    const inflator = new Pako_Inflate(options);
    inflator.push(input, false);
    if (inflator.err)
      throw inflator.msg || zlib_messages.msg(inflator.err);
    return inflator.result;
  }
  inflateRaw(input, options) {
    options.raw = true;
    return Pako_Inflate.inflate(input, options);
  }
  static ungzip(input, options) {
    return Pako_Inflate.inflate(input, options);
  }
};

// obj/full/Pako/zlib/adler32.js
"use strict";
var zlib_adler32 = class {
  static adler32(adler, buf, len, pos) {
    let s1 = adler & 65535 | 0, s2 = adler >>> 16 & 65535 | 0, n = 0;
    while (len !== 0) {
      n = len > 2e3 ? 2e3 : len;
      len -= n;
      do {
        s1 = s1 + buf[pos++] | 0;
        s2 = s2 + s1 | 0;
      } while (--n);
      s1 %= 65521;
      s2 %= 65521;
    }
    return s1 | s2 << 16 | 0;
  }
};

// obj/full/Pako/zlib/constants.js
"use strict";
var zlib_constants = class {
};
zlib_constants.Z_NO_FLUSH = 0;
zlib_constants.Z_PARTIAL_FLUSH = 1;
zlib_constants.Z_SYNC_FLUSH = 2;
zlib_constants.Z_FULL_FLUSH = 3;
zlib_constants.Z_FINISH = 4;
zlib_constants.Z_BLOCK = 5;
zlib_constants.Z_TREES = 6;
zlib_constants.Z_OK = 0;
zlib_constants.Z_STREAM_END = 1;
zlib_constants.Z_NEED_DICT = 2;
zlib_constants.Z_ERRNO = -1;
zlib_constants.Z_STREAM_ERROR = -2;
zlib_constants.Z_DATA_ERROR = -3;
zlib_constants.Z_MEM_ERROR = -4;
zlib_constants.Z_BUF_ERROR = -5;
zlib_constants.Z_NO_COMPRESSION = 0;
zlib_constants.Z_BEST_SPEED = 1;
zlib_constants.Z_BEST_COMPRESSION = 9;
zlib_constants.Z_DEFAULT_COMPRESSION = -1;
zlib_constants.Z_FILTERED = 1;
zlib_constants.Z_HUFFMAN_ONLY = 2;
zlib_constants.Z_RLE = 3;
zlib_constants.Z_FIXED = 4;
zlib_constants.Z_DEFAULT_STRATEGY = 0;
zlib_constants.Z_BINARY = 0;
zlib_constants.Z_TEXT = 1;
zlib_constants.Z_UNKNOWN = 2;
zlib_constants.Z_DEFLATED = 8;

// obj/full/Pako/zlib/crc32.js
"use strict";
var zlib_crc32 = class {
  static makeTable() {
    let c;
    let table = new Int32Array(256);
    for (let n = 0; n < 256; n++) {
      c = n;
      for (let k = 0; k < 8; k++) {
        c = c & 1 ? 3988292384 ^ c >>> 1 : c >>> 1;
      }
      table[n] = c;
    }
    return table;
  }
  static crc32(crc, buf, len, pos) {
    let t = zlib_crc32.crcTable;
    let end = pos + len;
    crc ^= -1;
    for (let i = pos; i < end; i++) {
      crc = crc >>> 8 ^ t[(crc ^ buf[i]) & 255];
    }
    return crc ^ -1;
  }
};
zlib_crc32.crcTable = zlib_crc32.makeTable();

// obj/full/Pako/zlib/deflate.js
"use strict";
var zlib_config = class {
  constructor(good_length, max_lazy, nice_length, max_chain, func) {
    this.good_length = good_length;
    this.max_lazy = max_lazy;
    this.nice_length = nice_length;
    this.max_chain = max_chain;
    this.func = func;
  }
};
var zlib_DeflateState = class {
  constructor() {
    this.strm = null;
    this.status = 0;
    this.pending_buf = null;
    this.pending_buf_size = 0;
    this.pending_out = 0;
    this.pending = 0;
    this.wrap = 0;
    this.gzhead = null;
    this.gzindex = 0;
    this.method = zlib_constants.Z_DEFLATED;
    this.last_flush = -1;
    this.w_size = 0;
    this.w_bits = 0;
    this.w_mask = 0;
    this.window = null;
    this.window_size = 0;
    this.prev = null;
    this.head = null;
    this.ins_h = 0;
    this.hash_size = 0;
    this.hash_bits = 0;
    this.hash_mask = 0;
    this.hash_shift = 0;
    this.block_start = 0;
    this.match_length = 0;
    this.prev_match = 0;
    this.match_available = 0;
    this.strstart = 0;
    this.match_start = 0;
    this.lookahead = 0;
    this.prev_length = 0;
    this.max_chain_length = 0;
    this.max_lazy_match = 0;
    this.level = 0;
    this.strategy = 0;
    this.good_match = 0;
    this.nice_match = 0;
    this.dyn_ltree = new Uint16Array(zlib_Pako_trees.HEAP_SIZE * 2);
    this.dyn_dtree = new Uint16Array((2 * zlib_Pako_trees.D_CODES + 1) * 2);
    this.bl_tree = new Uint16Array((2 * zlib_Pako_trees.BL_CODES + 1) * 2);
    this.l_desc = null;
    this.d_desc = null;
    this.bl_desc = null;
    this.bl_count = new Uint16Array(zlib_Pako_trees.MAX_BITS + 1);
    this.heap = new Uint16Array(2 * zlib_Pako_trees.L_CODES + 1);
    this.heap_len = 0;
    this.heap_max = 0;
    this.depth = new Uint16Array(2 * zlib_Pako_trees.L_CODES + 1);
    this.l_buf = 0;
    this.lit_bufsize = 0;
    this.last_lit = 0;
    this.d_buf = 0;
    this.opt_len = 0;
    this.static_len = 0;
    this.matches = 0;
    this.insert = 0;
    this.bi_buf = 0;
    this.bi_valid = 0;
    zlib_Pako_trees.zero(this.dyn_ltree);
    zlib_Pako_trees.zero(this.dyn_dtree);
    zlib_Pako_trees.zero(this.bl_tree);
    zlib_Pako_trees.zero(this.heap);
    zlib_Pako_trees.zero(this.depth);
  }
};
var zlib_deflate = class {
  static err(strm, errorCode) {
    strm.msg = zlib_messages.msg(errorCode);
    return errorCode;
  }
  static rank(f) {
    return (f << 1) - (f > 4 ? 9 : 0);
  }
  zero(buf) {
    let len = buf.length;
    while (--len >= 0) {
      buf[len] = 0;
    }
  }
  static HASH_ZLIB(s, prev, data) {
    return (prev << s.hash_shift ^ data) & s.hash_mask;
  }
  static HASH(s, prev, data) {
    return (prev << s.hash_shift ^ data) & s.hash_mask;
  }
  static flush_pending(strm) {
    const s = strm.state;
    let len = s.pending;
    if (len > strm.avail_out) {
      len = strm.avail_out;
    }
    if (len === 0) {
      return;
    }
    strm.output.set(s.pending_buf.subarray(s.pending_out, s.pending_out + len), strm.next_out);
    strm.next_out += len;
    s.pending_out += len;
    strm.total_out += len;
    strm.avail_out -= len;
    s.pending -= len;
    if (s.pending === 0) {
      s.pending_out = 0;
    }
  }
  static flush_block_only(s, last) {
    zlib_Pako_trees._tr_flush_block(s, s.block_start >= 0 ? s.block_start : -1, s.strstart - s.block_start, last);
    s.block_start = s.strstart;
    zlib_deflate.flush_pending(s.strm);
  }
  static put_byte(s, b) {
    s.pending_buf[s.pending++] = b;
  }
  static putShortMSB(s, b) {
    s.pending_buf[s.pending++] = b >>> 8 & 255;
    s.pending_buf[s.pending++] = b & 255;
  }
  static read_buf(strm, buf, start, size) {
    let len = strm.avail_in;
    if (len > size) {
      len = size;
    }
    if (len === 0) {
      return 0;
    }
    strm.avail_in -= len;
    buf.set(strm.input.subarray(strm.next_in, strm.next_in + len), start);
    if (strm.state.wrap === 1) {
      strm.adler = zlib_adler32.adler32(strm.adler, buf, len, start);
    } else if (strm.state.wrap === 2) {
      strm.adler = zlib_crc32.crc32(strm.adler, buf, len, start);
    }
    strm.next_in += len;
    strm.total_in += len;
    return len;
  }
  static longest_match(s, cur_match) {
    let chain_length = s.max_chain_length;
    let scan = s.strstart;
    let match;
    let len;
    let best_len = s.prev_length;
    let nice_match = s.nice_match;
    const limit = s.strstart > s.w_size - zlib_deflate.MIN_LOOKAHEAD ? s.strstart - (s.w_size - zlib_deflate.MIN_LOOKAHEAD) : 0;
    const _win = s.window;
    const wmask = s.w_mask;
    const prev = s.prev;
    const strend = s.strstart + zlib_Pako_trees.MAX_MATCH;
    let scan_end1 = _win[scan + best_len - 1];
    let scan_end = _win[scan + best_len];
    if (s.prev_length >= s.good_match) {
      chain_length >>= 2;
    }
    if (nice_match > s.lookahead) {
      nice_match = s.lookahead;
    }
    do {
      match = cur_match;
      if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1]) {
        continue;
      }
      scan += 2;
      match++;
      do {
      } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend);
      len = zlib_Pako_trees.MAX_MATCH - (strend - scan);
      scan = strend - zlib_Pako_trees.MAX_MATCH;
      if (len > best_len) {
        s.match_start = cur_match;
        best_len = len;
        if (len >= nice_match) {
          break;
        }
        scan_end1 = _win[scan + best_len - 1];
        scan_end = _win[scan + best_len];
      }
    } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);
    if (best_len <= s.lookahead) {
      return best_len;
    }
    return s.lookahead;
  }
  static fill_window(s) {
    const _w_size = s.w_size;
    let p;
    let n;
    let m;
    let more;
    let str;
    do {
      more = s.window_size - s.lookahead - s.strstart;
      if (s.strstart >= _w_size + (_w_size - zlib_deflate.MIN_LOOKAHEAD)) {
        s.window.set(s.window.subarray(_w_size, _w_size + _w_size), 0);
        s.match_start -= _w_size;
        s.strstart -= _w_size;
        s.block_start -= _w_size;
        n = s.hash_size;
        p = n;
        do {
          m = s.head[--p];
          s.head[p] = m >= _w_size ? m - _w_size : 0;
        } while (--n);
        n = _w_size;
        p = n;
        do {
          m = s.prev[--p];
          s.prev[p] = m >= _w_size ? m - _w_size : 0;
        } while (--n);
        more += _w_size;
      }
      if (s.strm.avail_in === 0) {
        break;
      }
      n = zlib_deflate.read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
      s.lookahead += n;
      if (s.lookahead + s.insert >= zlib_Pako_trees.MIN_MATCH) {
        str = s.strstart - s.insert;
        s.ins_h = s.window[str];
        s.ins_h = zlib_deflate.HASH(s, s.ins_h, s.window[str + 1]);
        while (s.insert) {
          s.ins_h = zlib_deflate.HASH(s, s.ins_h, s.window[str + zlib_Pako_trees.MIN_MATCH - 1]);
          s.prev[str & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = str;
          str++;
          s.insert--;
          if (s.lookahead + s.insert < zlib_Pako_trees.MIN_MATCH) {
            break;
          }
        }
      }
    } while (s.lookahead < zlib_deflate.MIN_LOOKAHEAD && s.strm.avail_in !== 0);
  }
  static deflate_stored(s, flush) {
    let max_block_size = 65535;
    if (max_block_size > s.pending_buf_size - 5) {
      max_block_size = s.pending_buf_size - 5;
    }
    for (; ; ) {
      if (s.lookahead <= 1) {
        zlib_deflate.fill_window(s);
        if (s.lookahead === 0 && flush === zlib_constants.Z_NO_FLUSH) {
          return zlib_deflate.BS_NEED_MORE;
        }
        if (s.lookahead === 0) {
          break;
        }
      }
      s.strstart += s.lookahead;
      s.lookahead = 0;
      const max_start = s.block_start + max_block_size;
      if (s.strstart === 0 || s.strstart >= max_start) {
        s.lookahead = s.strstart - max_start;
        s.strstart = max_start;
        zlib_deflate.flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return zlib_deflate.BS_NEED_MORE;
        }
      }
      if (s.strstart - s.block_start >= s.w_size - zlib_deflate.MIN_LOOKAHEAD) {
        zlib_deflate.flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return zlib_deflate.BS_NEED_MORE;
        }
      }
    }
    s.insert = 0;
    if (flush === zlib_constants.Z_FINISH) {
      zlib_deflate.flush_block_only(s, true);
      if (s.strm.avail_out === 0) {
        return zlib_deflate.BS_FINISH_STARTED;
      }
      return zlib_deflate.BS_FINISH_DONE;
    }
    if (s.strstart > s.block_start) {
      zlib_deflate.flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return zlib_deflate.BS_NEED_MORE;
      }
    }
    return zlib_deflate.BS_NEED_MORE;
  }
  static deflate_slow(s, flush) {
    let hash_head;
    let bflush;
    let max_insert;
    for (; ; ) {
      if (s.lookahead < zlib_deflate.MIN_LOOKAHEAD) {
        zlib_deflate.fill_window(s);
        if (s.lookahead < zlib_deflate.MIN_LOOKAHEAD && flush === zlib_constants.Z_NO_FLUSH) {
          return zlib_deflate.BS_NEED_MORE;
        }
        if (s.lookahead === 0) {
          break;
        }
      }
      hash_head = 0;
      if (s.lookahead >= zlib_Pako_trees.MIN_MATCH) {
        s.ins_h = zlib_deflate.HASH(s, s.ins_h, s.window[s.strstart + zlib_Pako_trees.MIN_MATCH - 1]);
        hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
        s.head[s.ins_h] = s.strstart;
      }
      s.prev_length = s.match_length;
      s.prev_match = s.match_start;
      s.match_length = zlib_Pako_trees.MIN_MATCH - 1;
      if (hash_head !== 0 && s.prev_length < s.max_lazy_match && s.strstart - hash_head <= s.w_size - zlib_deflate.MIN_LOOKAHEAD) {
        s.match_length = zlib_deflate.longest_match(s, hash_head);
        if (s.match_length <= 5 && (s.strategy === zlib_constants.Z_FILTERED || s.match_length === zlib_Pako_trees.MIN_MATCH && s.strstart - s.match_start > 4096)) {
          s.match_length = zlib_Pako_trees.MIN_MATCH - 1;
        }
      }
      if (s.prev_length >= zlib_Pako_trees.MIN_MATCH && s.match_length <= s.prev_length) {
        max_insert = s.strstart + s.lookahead - zlib_Pako_trees.MIN_MATCH;
        bflush = zlib_Pako_trees._tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - zlib_Pako_trees.MIN_MATCH);
        s.lookahead -= s.prev_length - 1;
        s.prev_length -= 2;
        do {
          if (++s.strstart <= max_insert) {
            s.ins_h = zlib_deflate.HASH(s, s.ins_h, s.window[s.strstart + zlib_Pako_trees.MIN_MATCH - 1]);
            hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
            s.head[s.ins_h] = s.strstart;
          }
        } while (--s.prev_length !== 0);
        s.match_available = 0;
        s.match_length = zlib_Pako_trees.MIN_MATCH - 1;
        s.strstart++;
        if (bflush) {
          zlib_deflate.flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return zlib_deflate.BS_NEED_MORE;
          }
        }
      } else if (s.match_available) {
        bflush = zlib_Pako_trees._tr_tally(s, 0, s.window[s.strstart - 1]);
        if (bflush) {
          zlib_deflate.flush_block_only(s, false);
        }
        s.strstart++;
        s.lookahead--;
        if (s.strm.avail_out === 0) {
          return zlib_deflate.BS_NEED_MORE;
        }
      } else {
        s.match_available = 1;
        s.strstart++;
        s.lookahead--;
      }
    }
    if (s.match_available) {
      bflush = zlib_Pako_trees._tr_tally(s, 0, s.window[s.strstart - 1]);
      s.match_available = 0;
    }
    s.insert = s.strstart < zlib_Pako_trees.MIN_MATCH - 1 ? s.strstart : zlib_Pako_trees.MIN_MATCH - 1;
    if (flush === zlib_constants.Z_FINISH) {
      zlib_deflate.flush_block_only(s, true);
      if (s.strm.avail_out === 0) {
        return zlib_deflate.BS_FINISH_STARTED;
      }
      return zlib_deflate.BS_FINISH_DONE;
    }
    if (s.last_lit) {
      zlib_deflate.flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return zlib_deflate.BS_NEED_MORE;
      }
    }
    return zlib_deflate.BS_BLOCK_DONE;
  }
  static deflate_rle(s, flush) {
    let bflush;
    let prev;
    let scan;
    let strend;
    const _win = s.window;
    for (; ; ) {
      if (s.lookahead <= zlib_Pako_trees.MAX_MATCH) {
        zlib_deflate.fill_window(s);
        if (s.lookahead <= zlib_Pako_trees.MAX_MATCH && flush === zlib_constants.Z_NO_FLUSH) {
          return zlib_deflate.BS_NEED_MORE;
        }
        if (s.lookahead === 0) {
          break;
        }
      }
      s.match_length = 0;
      if (s.lookahead >= zlib_Pako_trees.MIN_MATCH && s.strstart > 0) {
        scan = s.strstart - 1;
        prev = _win[scan];
        if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
          strend = s.strstart + zlib_Pako_trees.MAX_MATCH;
          do {
          } while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);
          s.match_length = zlib_Pako_trees.MAX_MATCH - (strend - scan);
          if (s.match_length > s.lookahead) {
            s.match_length = s.lookahead;
          }
        }
      }
      if (s.match_length >= zlib_Pako_trees.MIN_MATCH) {
        bflush = zlib_Pako_trees._tr_tally(s, 1, s.match_length - zlib_Pako_trees.MIN_MATCH);
        s.lookahead -= s.match_length;
        s.strstart += s.match_length;
        s.match_length = 0;
      } else {
        bflush = zlib_Pako_trees._tr_tally(s, 0, s.window[s.strstart]);
        s.lookahead--;
        s.strstart++;
      }
      if (bflush) {
        zlib_deflate.flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return zlib_deflate.BS_NEED_MORE;
        }
      }
    }
    s.insert = 0;
    if (flush === zlib_constants.Z_FINISH) {
      zlib_deflate.flush_block_only(s, true);
      if (s.strm.avail_out === 0) {
        return zlib_deflate.BS_FINISH_STARTED;
      }
      return zlib_deflate.BS_FINISH_DONE;
    }
    if (s.last_lit) {
      zlib_deflate.flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return zlib_deflate.BS_NEED_MORE;
      }
    }
    return zlib_deflate.BS_BLOCK_DONE;
  }
  static deflate_huff(s, flush) {
    let bflush;
    for (; ; ) {
      if (s.lookahead === 0) {
        zlib_deflate.fill_window(s);
        if (s.lookahead === 0) {
          if (flush === zlib_constants.Z_NO_FLUSH) {
            return zlib_deflate.BS_NEED_MORE;
          }
          break;
        }
      }
      s.match_length = 0;
      bflush = zlib_Pako_trees._tr_tally(s, 0, s.window[s.strstart]);
      s.lookahead--;
      s.strstart++;
      if (bflush) {
        zlib_deflate.flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return zlib_deflate.BS_NEED_MORE;
        }
      }
    }
    s.insert = 0;
    if (flush === zlib_constants.Z_FINISH) {
      zlib_deflate.flush_block_only(s, true);
      if (s.strm.avail_out === 0) {
        return zlib_deflate.BS_FINISH_STARTED;
      }
      return zlib_deflate.BS_FINISH_DONE;
    }
    if (s.last_lit) {
      zlib_deflate.flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return zlib_deflate.BS_NEED_MORE;
      }
    }
    return zlib_deflate.BS_BLOCK_DONE;
  }
  static lm_init(s) {
    s.window_size = 2 * s.w_size;
    zlib_Pako_trees.zero(s.head);
    s.max_lazy_match = zlib_deflate.configuration_table[s.level].max_lazy;
    s.good_match = zlib_deflate.configuration_table[s.level].good_length;
    s.nice_match = zlib_deflate.configuration_table[s.level].nice_length;
    s.max_chain_length = zlib_deflate.configuration_table[s.level].max_chain;
    s.strstart = 0;
    s.block_start = 0;
    s.lookahead = 0;
    s.insert = 0;
    s.match_length = s.prev_length = zlib_Pako_trees.MIN_MATCH - 1;
    s.match_available = 0;
    s.ins_h = 0;
  }
  static deflateResetKeep(strm) {
    if (!strm || !strm.state) {
      return zlib_deflate.err(strm, zlib_constants.Z_STREAM_ERROR);
    }
    strm.total_in = strm.total_out = 0;
    strm.data_type = zlib_constants.Z_UNKNOWN;
    let s = strm.state;
    s.pending = 0;
    s.pending_out = 0;
    if (s.wrap < 0) {
      s.wrap = -s.wrap;
    }
    s.status = s.wrap ? zlib_deflate.INIT_STATE : zlib_deflate.BUSY_STATE;
    strm.adler = s.wrap === 2 ? 0 : 1;
    s.last_flush = zlib_constants.Z_NO_FLUSH;
    zlib_Pako_trees._tr_init(s);
    return zlib_constants.Z_OK;
  }
  static deflateReset(strm) {
    const ret = zlib_deflate.deflateResetKeep(strm);
    if (ret === zlib_constants.Z_OK) {
      zlib_deflate.lm_init(strm.state);
    }
    return ret;
  }
  static deflateSetHeader(strm, head) {
    if (!strm || !strm.state) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    if (strm.state.wrap !== 2) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    strm.state.gzhead = head;
    return zlib_constants.Z_OK;
  }
  static deflateInit2(strm, level, method, windowBits, memLevel, strategy) {
    if (!strm) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    let wrap = 1;
    if (level === zlib_constants.Z_DEFAULT_COMPRESSION) {
      level = 6;
    }
    if (windowBits < 0) {
      wrap = 0;
      windowBits = -windowBits;
    } else if (windowBits > 15) {
      wrap = 2;
      windowBits -= 16;
    }
    if (memLevel < 1 || memLevel > zlib_deflate.MAX_MEM_LEVEL || method !== zlib_constants.Z_DEFLATED || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > zlib_constants.Z_FIXED) {
      return zlib_deflate.err(strm, zlib_constants.Z_STREAM_ERROR);
    }
    if (windowBits === 8) {
      windowBits = 9;
    }
    const s = new zlib_DeflateState();
    strm.state = s;
    s.strm = strm;
    s.wrap = wrap;
    s.gzhead = null;
    s.w_bits = windowBits;
    s.w_size = 1 << s.w_bits;
    s.w_mask = s.w_size - 1;
    s.hash_bits = memLevel + 7;
    s.hash_size = 1 << s.hash_bits;
    s.hash_mask = s.hash_size - 1;
    s.hash_shift = ~~((s.hash_bits + zlib_Pako_trees.MIN_MATCH - 1) / zlib_Pako_trees.MIN_MATCH);
    s.window = new Uint8Array(s.w_size * 2);
    s.head = new Uint16Array(s.hash_size);
    s.prev = new Uint16Array(s.w_size);
    s.lit_bufsize = 1 << memLevel + 6;
    s.pending_buf_size = s.lit_bufsize * 4;
    s.pending_buf = new Uint8Array(s.pending_buf_size);
    s.d_buf = 1 * s.lit_bufsize;
    s.l_buf = (1 + 2) * s.lit_bufsize;
    s.level = level;
    s.strategy = strategy;
    s.method = method;
    return zlib_deflate.deflateReset(strm);
  }
  static deflateInit(strm, level) {
    return zlib_deflate.deflateInit2(strm, level, zlib_constants.Z_DEFLATED, zlib_deflate.MAX_WBITS, zlib_deflate.DEF_MEM_LEVEL, zlib_constants.Z_DEFAULT_STRATEGY);
  }
  static deflate(strm, flush) {
    let beg, val;
    if (!strm || !strm.state || flush > zlib_constants.Z_BLOCK || flush < 0) {
      return strm ? zlib_deflate.err(strm, zlib_constants.Z_STREAM_ERROR) : zlib_constants.Z_STREAM_ERROR;
    }
    let s = strm.state;
    if (!strm.output || !strm.input && strm.avail_in !== 0 || s.status === zlib_deflate.FINISH_STATE && flush !== zlib_constants.Z_FINISH) {
      return zlib_deflate.err(strm, strm.avail_out === 0 ? zlib_constants.Z_BUF_ERROR : zlib_constants.Z_STREAM_ERROR);
    }
    s.strm = strm;
    const old_flush = s.last_flush;
    s.last_flush = flush;
    if (s.status === zlib_deflate.INIT_STATE) {
      if (s.wrap === 2) {
        strm.adler = 0;
        zlib_deflate.put_byte(s, 31);
        zlib_deflate.put_byte(s, 139);
        zlib_deflate.put_byte(s, 8);
        if (!s.gzhead) {
          zlib_deflate.put_byte(s, 0);
          zlib_deflate.put_byte(s, 0);
          zlib_deflate.put_byte(s, 0);
          zlib_deflate.put_byte(s, 0);
          zlib_deflate.put_byte(s, 0);
          zlib_deflate.put_byte(s, s.level === 9 ? 2 : s.strategy >= zlib_constants.Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
          zlib_deflate.put_byte(s, zlib_deflate.OS_CODE);
          s.status = zlib_deflate.BUSY_STATE;
        } else {
          zlib_deflate.put_byte(s, (s.gzhead.text ? 1 : 0) + (s.gzhead.hcrc ? 2 : 0) + (!s.gzhead.extra ? 0 : 4) + (!s.gzhead.name ? 0 : 8) + (!s.gzhead.comment ? 0 : 16));
          zlib_deflate.put_byte(s, s.gzhead.time & 255);
          zlib_deflate.put_byte(s, s.gzhead.time >> 8 & 255);
          zlib_deflate.put_byte(s, s.gzhead.time >> 16 & 255);
          zlib_deflate.put_byte(s, s.gzhead.time >> 24 & 255);
          zlib_deflate.put_byte(s, s.level === 9 ? 2 : s.strategy >= zlib_constants.Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
          zlib_deflate.put_byte(s, s.gzhead.os & 255);
          if (s.gzhead.extra && s.gzhead.extra.length) {
            zlib_deflate.put_byte(s, s.gzhead.extra.length & 255);
            zlib_deflate.put_byte(s, s.gzhead.extra.length >> 8 & 255);
          }
          if (s.gzhead.hcrc) {
            strm.adler = zlib_crc32.crc32(strm.adler, s.pending_buf, s.pending, 0);
          }
          s.gzindex = 0;
          s.status = zlib_deflate.EXTRA_STATE;
        }
      } else {
        let header = zlib_constants.Z_DEFLATED + (s.w_bits - 8 << 4) << 8;
        let level_flags = -1;
        if (s.strategy >= zlib_constants.Z_HUFFMAN_ONLY || s.level < 2) {
          level_flags = 0;
        } else if (s.level < 6) {
          level_flags = 1;
        } else if (s.level === 6) {
          level_flags = 2;
        } else {
          level_flags = 3;
        }
        header |= level_flags << 6;
        if (s.strstart !== 0) {
          header |= zlib_deflate.PRESET_DICT;
        }
        header += 31 - header % 31;
        s.status = zlib_deflate.BUSY_STATE;
        zlib_deflate.putShortMSB(s, header);
        if (s.strstart !== 0) {
          zlib_deflate.putShortMSB(s, strm.adler >>> 16);
          zlib_deflate.putShortMSB(s, strm.adler & 65535);
        }
        strm.adler = 1;
      }
    }
    if (s.status === zlib_deflate.EXTRA_STATE) {
      if (s.gzhead.extra) {
        beg = s.pending;
        while (s.gzindex < (s.gzhead.extra.length & 65535)) {
          if (s.pending === s.pending_buf_size) {
            if (s.gzhead.hcrc && s.pending > beg) {
              strm.adler = zlib_crc32.crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
            }
            zlib_deflate.flush_pending(strm);
            beg = s.pending;
            if (s.pending === s.pending_buf_size) {
              break;
            }
          }
          zlib_deflate.put_byte(s, s.gzhead.extra[s.gzindex] & 255);
          s.gzindex++;
        }
        if (s.gzhead.hcrc && s.pending > beg) {
          strm.adler = zlib_crc32.crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
        }
        if (s.gzindex === s.gzhead.extra.length) {
          s.gzindex = 0;
          s.status = zlib_deflate.NAME_STATE;
        }
      } else {
        s.status = zlib_deflate.NAME_STATE;
      }
    }
    if (s.status === zlib_deflate.NAME_STATE) {
      if (s.gzhead.name) {
        beg = s.pending;
        do {
          if (s.pending === s.pending_buf_size) {
            if (s.gzhead.hcrc && s.pending > beg) {
              strm.adler = zlib_crc32.crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
            }
            zlib_deflate.flush_pending(strm);
            beg = s.pending;
            if (s.pending === s.pending_buf_size) {
              val = 1;
              break;
            }
          }
          if (s.gzindex < s.gzhead.name.length) {
            val = s.gzhead.name.charCodeAt(s.gzindex++) & 255;
          } else {
            val = 0;
          }
          zlib_deflate.put_byte(s, val);
        } while (val !== 0);
        if (s.gzhead.hcrc && s.pending > beg) {
          strm.adler = zlib_crc32.crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
        }
        if (val === 0) {
          s.gzindex = 0;
          s.status = zlib_deflate.COMMENT_STATE;
        }
      } else {
        s.status = zlib_deflate.COMMENT_STATE;
      }
    }
    if (s.status === zlib_deflate.COMMENT_STATE) {
      if (s.gzhead.comment) {
        beg = s.pending;
        do {
          if (s.pending === s.pending_buf_size) {
            if (s.gzhead.hcrc && s.pending > beg) {
              strm.adler = zlib_crc32.crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
            }
            zlib_deflate.flush_pending(strm);
            beg = s.pending;
            if (s.pending === s.pending_buf_size) {
              val = 1;
              break;
            }
          }
          if (s.gzindex < s.gzhead.comment.length) {
            val = s.gzhead.comment.charCodeAt(s.gzindex++) & 255;
          } else {
            val = 0;
          }
          zlib_deflate.put_byte(s, val);
        } while (val !== 0);
        if (s.gzhead.hcrc && s.pending > beg) {
          strm.adler = zlib_crc32.crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
        }
        if (val === 0) {
          s.status = zlib_deflate.HCRC_STATE;
        }
      } else {
        s.status = zlib_deflate.HCRC_STATE;
      }
    }
    if (s.status === zlib_deflate.HCRC_STATE) {
      if (s.gzhead.hcrc) {
        if (s.pending + 2 > s.pending_buf_size) {
          zlib_deflate.flush_pending(strm);
        }
        if (s.pending + 2 <= s.pending_buf_size) {
          zlib_deflate.put_byte(s, strm.adler & 255);
          zlib_deflate.put_byte(s, strm.adler >> 8 & 255);
          strm.adler = 0;
          s.status = zlib_deflate.BUSY_STATE;
        }
      } else {
        s.status = zlib_deflate.BUSY_STATE;
      }
    }
    if (s.pending !== 0) {
      zlib_deflate.flush_pending(strm);
      if (strm.avail_out === 0) {
        s.last_flush = -1;
        return zlib_constants.Z_OK;
      }
    } else if (strm.avail_in === 0 && zlib_deflate.rank(flush) <= zlib_deflate.rank(old_flush) && flush !== zlib_constants.Z_FINISH) {
      return zlib_deflate.err(strm, zlib_constants.Z_BUF_ERROR);
    }
    if (s.status === zlib_deflate.FINISH_STATE && strm.avail_in !== 0) {
      return zlib_deflate.err(strm, zlib_constants.Z_BUF_ERROR);
    }
    if (strm.avail_in !== 0 || s.lookahead !== 0 || flush !== zlib_constants.Z_NO_FLUSH && s.status !== zlib_deflate.FINISH_STATE) {
      let bstate = s.strategy === zlib_constants.Z_HUFFMAN_ONLY ? zlib_deflate.deflate_huff(s, flush) : s.strategy === zlib_constants.Z_RLE ? zlib_deflate.deflate_rle(s, flush) : zlib_deflate.configuration_table[s.level].func(s, flush);
      if (bstate === zlib_deflate.BS_FINISH_STARTED || bstate === zlib_deflate.BS_FINISH_DONE) {
        s.status = zlib_deflate.FINISH_STATE;
      }
      if (bstate === zlib_deflate.BS_NEED_MORE || bstate === zlib_deflate.BS_FINISH_STARTED) {
        if (strm.avail_out === 0) {
          s.last_flush = -1;
        }
        return zlib_constants.Z_OK;
      }
      if (bstate === zlib_deflate.BS_BLOCK_DONE) {
        if (flush === zlib_constants.Z_PARTIAL_FLUSH) {
          zlib_Pako_trees._tr_align(s);
        } else if (flush !== zlib_constants.Z_BLOCK) {
          zlib_Pako_trees._tr_stored_block(s, 0, 0, false);
          if (flush === zlib_constants.Z_FULL_FLUSH) {
            zlib_Pako_trees.zero(s.head);
            if (s.lookahead === 0) {
              s.strstart = 0;
              s.block_start = 0;
              s.insert = 0;
            }
          }
        }
        zlib_deflate.flush_pending(strm);
        if (strm.avail_out === 0) {
          s.last_flush = -1;
          return zlib_constants.Z_OK;
        }
      }
    }
    if (flush !== zlib_constants.Z_FINISH) {
      return zlib_constants.Z_OK;
    }
    if (s.wrap <= 0) {
      return zlib_constants.Z_STREAM_END;
    }
    if (s.wrap === 2) {
      zlib_deflate.put_byte(s, strm.adler & 255);
      zlib_deflate.put_byte(s, strm.adler >> 8 & 255);
      zlib_deflate.put_byte(s, strm.adler >> 16 & 255);
      zlib_deflate.put_byte(s, strm.adler >> 24 & 255);
      zlib_deflate.put_byte(s, strm.total_in & 255);
      zlib_deflate.put_byte(s, strm.total_in >> 8 & 255);
      zlib_deflate.put_byte(s, strm.total_in >> 16 & 255);
      zlib_deflate.put_byte(s, strm.total_in >> 24 & 255);
    } else {
      zlib_deflate.putShortMSB(s, strm.adler >>> 16);
      zlib_deflate.putShortMSB(s, strm.adler & 65535);
    }
    zlib_deflate.flush_pending(strm);
    if (s.wrap > 0) {
      s.wrap = -s.wrap;
    }
    return s.pending !== 0 ? zlib_constants.Z_OK : zlib_constants.Z_STREAM_END;
  }
  static deflateEnd(strm) {
    if (!strm || !strm.state) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    let status = strm.state.status;
    if (status !== zlib_deflate.INIT_STATE && status !== zlib_deflate.EXTRA_STATE && status !== zlib_deflate.NAME_STATE && status !== zlib_deflate.COMMENT_STATE && status !== zlib_deflate.HCRC_STATE && status !== zlib_deflate.BUSY_STATE && status !== zlib_deflate.FINISH_STATE) {
      return zlib_deflate.err(strm, zlib_constants.Z_STREAM_ERROR);
    }
    strm.state = null;
    return status === zlib_deflate.BUSY_STATE ? zlib_deflate.err(strm, zlib_constants.Z_DATA_ERROR) : zlib_constants.Z_OK;
  }
  static deflateSetDictionary(strm, dictionary) {
    let dictLength = dictionary.length;
    if (!strm || !strm.state) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    const s = strm.state;
    const wrap = s.wrap;
    if (wrap === 2 || wrap === 1 && s.status !== zlib_deflate.INIT_STATE || s.lookahead) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    if (wrap === 1) {
      strm.adler = zlib_adler32.adler32(strm.adler, dictionary, dictLength, 0);
    }
    s.wrap = 0;
    if (dictLength >= s.w_size) {
      if (wrap === 0) {
        zlib_Pako_trees.zero(s.head);
        s.strstart = 0;
        s.block_start = 0;
        s.insert = 0;
      }
      let tmpDict = new Uint8Array(s.w_size);
      tmpDict.set(dictionary.subarray(dictLength - s.w_size, dictLength), 0);
      dictionary = tmpDict;
      dictLength = s.w_size;
    }
    const avail = strm.avail_in;
    const next = strm.next_in;
    const input = strm.input;
    strm.avail_in = dictLength;
    strm.next_in = 0;
    strm.input = dictionary;
    zlib_deflate.fill_window(s);
    while (s.lookahead >= zlib_Pako_trees.MIN_MATCH) {
      let str = s.strstart;
      let n = s.lookahead - (zlib_Pako_trees.MIN_MATCH - 1);
      do {
        s.ins_h = zlib_deflate.HASH(s, s.ins_h, s.window[str + zlib_Pako_trees.MIN_MATCH - 1]);
        s.prev[str & s.w_mask] = s.head[s.ins_h];
        s.head[s.ins_h] = str;
        str++;
      } while (--n);
      s.strstart = str;
      s.lookahead = zlib_Pako_trees.MIN_MATCH - 1;
      zlib_deflate.fill_window(s);
    }
    s.strstart += s.lookahead;
    s.block_start = s.strstart;
    s.insert = s.lookahead;
    s.lookahead = 0;
    s.match_length = s.prev_length = zlib_Pako_trees.MIN_MATCH - 1;
    s.match_available = 0;
    strm.next_in = next;
    strm.input = input;
    strm.avail_in = avail;
    s.wrap = wrap;
    return zlib_constants.Z_OK;
  }
};
zlib_deflate.MAX_MEM_LEVEL = 9;
zlib_deflate.MAX_WBITS = 15;
zlib_deflate.DEF_MEM_LEVEL = 8;
zlib_deflate.LENGTH_CODES = 29;
zlib_deflate.LITERALS = 256;
zlib_deflate.L_CODES = zlib_deflate.LITERALS + 1 + zlib_deflate.LENGTH_CODES;
zlib_deflate.D_CODES = 30;
zlib_deflate.BL_CODES = 19;
zlib_deflate.HEAP_SIZE = 2 * zlib_deflate.L_CODES + 1;
zlib_deflate.MAX_BITS = 15;
zlib_deflate.MIN_MATCH = 3;
zlib_deflate.MAX_MATCH = 258;
zlib_deflate.MIN_LOOKAHEAD = zlib_deflate.MAX_MATCH + zlib_deflate.MIN_MATCH + 1;
zlib_deflate.PRESET_DICT = 32;
zlib_deflate.INIT_STATE = 42;
zlib_deflate.EXTRA_STATE = 69;
zlib_deflate.NAME_STATE = 73;
zlib_deflate.COMMENT_STATE = 91;
zlib_deflate.HCRC_STATE = 103;
zlib_deflate.BUSY_STATE = 113;
zlib_deflate.FINISH_STATE = 666;
zlib_deflate.BS_NEED_MORE = 1;
zlib_deflate.BS_BLOCK_DONE = 2;
zlib_deflate.BS_FINISH_STARTED = 3;
zlib_deflate.BS_FINISH_DONE = 4;
zlib_deflate.OS_CODE = 3;
zlib_deflate.deflate_fast = (s, flush) => {
  let hash_head;
  let bflush;
  for (; ; ) {
    if (s.lookahead < zlib_deflate.MIN_LOOKAHEAD) {
      zlib_deflate.fill_window(s);
      if (s.lookahead < zlib_deflate.MIN_LOOKAHEAD && flush === zlib_constants.Z_NO_FLUSH) {
        return zlib_deflate.BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break;
      }
    }
    hash_head = 0;
    if (s.lookahead >= zlib_Pako_trees.MIN_MATCH) {
      s.ins_h = zlib_deflate.HASH(s, s.ins_h, s.window[s.strstart + zlib_Pako_trees.MIN_MATCH - 1]);
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
    }
    if (hash_head !== 0 && s.strstart - hash_head <= s.w_size - zlib_deflate.MIN_LOOKAHEAD) {
      s.match_length = zlib_deflate.longest_match(s, hash_head);
    }
    if (s.match_length >= zlib_Pako_trees.MIN_MATCH) {
      bflush = zlib_Pako_trees._tr_tally(s, s.strstart - s.match_start, s.match_length - zlib_Pako_trees.MIN_MATCH);
      s.lookahead -= s.match_length;
      if (s.match_length <= s.max_lazy_match && s.lookahead >= zlib_Pako_trees.MIN_MATCH) {
        s.match_length--;
        do {
          s.strstart++;
          s.ins_h = zlib_deflate.HASH(s, s.ins_h, s.window[s.strstart + zlib_Pako_trees.MIN_MATCH - 1]);
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
        } while (--s.match_length !== 0);
        s.strstart++;
      } else {
        s.strstart += s.match_length;
        s.match_length = 0;
        s.ins_h = s.window[s.strstart];
        s.ins_h = zlib_deflate.HASH(s, s.ins_h, s.window[s.strstart + 1]);
      }
    } else {
      bflush = zlib_Pako_trees._tr_tally(s, 0, s.window[s.strstart]);
      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      zlib_deflate.flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return zlib_deflate.BS_NEED_MORE;
      }
    }
  }
  s.insert = s.strstart < zlib_Pako_trees.MIN_MATCH - 1 ? s.strstart : zlib_Pako_trees.MIN_MATCH - 1;
  if (flush === zlib_constants.Z_FINISH) {
    zlib_deflate.flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return zlib_deflate.BS_FINISH_STARTED;
    }
    return zlib_deflate.BS_FINISH_DONE;
  }
  if (s.last_lit) {
    zlib_deflate.flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return zlib_deflate.BS_NEED_MORE;
    }
  }
  return zlib_deflate.BS_BLOCK_DONE;
};
zlib_deflate.configuration_table = [
  new zlib_config(0, 0, 0, 0, zlib_deflate.deflate_stored),
  new zlib_config(4, 4, 8, 4, zlib_deflate.deflate_fast),
  new zlib_config(4, 5, 16, 8, zlib_deflate.deflate_fast),
  new zlib_config(4, 6, 32, 32, zlib_deflate.deflate_fast),
  new zlib_config(4, 4, 16, 16, zlib_deflate.deflate_slow),
  new zlib_config(8, 16, 32, 32, zlib_deflate.deflate_slow),
  new zlib_config(8, 16, 128, 128, zlib_deflate.deflate_slow),
  new zlib_config(8, 32, 128, 256, zlib_deflate.deflate_slow),
  new zlib_config(32, 128, 258, 1024, zlib_deflate.deflate_slow),
  new zlib_config(32, 258, 258, 4096, zlib_deflate.deflate_slow)
];

// obj/full/Pako/zlib/trees.js
"use strict";
var zlib_StaticTreeDesc = class {
  constructor(static_tree, extra_bits, extra_base, elems, max_length) {
    this.static_tree = static_tree;
    this.extra_bits = extra_bits;
    this.extra_base = extra_base;
    this.elems = elems;
    this.max_length = max_length;
    this.has_stree = static_tree != null && static_tree.length > 0;
  }
};
var zlib_TreeDesc = class {
  constructor(dyn_tree, stat_desc) {
    this.max_code = 0;
    this.dyn_tree = dyn_tree;
    this.max_code = 0;
    this.stat_desc = stat_desc;
  }
};
var zlib_Pako_trees = class {
  static zero(buf) {
    let len = buf.length;
    while (--len >= 0) {
      buf[len] = 0;
    }
  }
  static Zeroinit() {
    zlib_Pako_trees.zero(zlib_Pako_trees.static_ltree);
    zlib_Pako_trees.zero(zlib_Pako_trees.base_dist);
    zlib_Pako_trees.zero(zlib_Pako_trees.base_length);
    zlib_Pako_trees.zero(zlib_Pako_trees._length_code);
    zlib_Pako_trees.zero(zlib_Pako_trees._dist_code);
    zlib_Pako_trees.zero(zlib_Pako_trees.static_dtree);
    return true;
  }
  static d_code(dist) {
    return dist < 256 ? zlib_Pako_trees._dist_code[dist] : zlib_Pako_trees._dist_code[256 + (dist >>> 7)];
  }
  static put_short(s, w) {
    s.pending_buf[s.pending++] = w & 255;
    s.pending_buf[s.pending++] = w >>> 8 & 255;
  }
  static send_code(s, c, tree) {
    zlib_Pako_trees.send_bits(s, tree[c * 2], tree[c * 2 + 1]);
  }
  static bi_reverse(code, len) {
    let res = 0;
    do {
      res |= code & 1;
      code >>>= 1;
      res <<= 1;
    } while (--len > 0);
    return res >>> 1;
  }
  static bi_flush(s) {
    if (s.bi_valid === 16) {
      zlib_Pako_trees.put_short(s, s.bi_buf);
      s.bi_buf = 0;
      s.bi_valid = 0;
    } else if (s.bi_valid >= 8) {
      s.pending_buf[s.pending++] = s.bi_buf & 255;
      s.bi_buf >>= 8;
      s.bi_valid -= 8;
    }
  }
  static gen_codes(tree, max_code, bl_count) {
    const next_code = new Array(zlib_Pako_trees.MAX_BITS + 1);
    let code = 0;
    let bits;
    let n;
    for (bits = 1; bits <= zlib_Pako_trees.MAX_BITS; bits++) {
      next_code[bits] = code = code + bl_count[bits - 1] << 1;
    }
    for (n = 0; n <= max_code; n++) {
      let len = tree[n * 2 + 1];
      if (len === 0) {
        continue;
      }
      tree[n * 2] = zlib_Pako_trees.bi_reverse(next_code[len]++, len);
    }
  }
  static tr_static_init() {
    let n;
    let bits;
    let length;
    let code;
    let dist;
    const bl_count = new Uint16Array(zlib_Pako_trees.MAX_BITS + 1);
    length = 0;
    for (code = 0; code < zlib_Pako_trees.LENGTH_CODES - 1; code++) {
      zlib_Pako_trees.base_length[code] = length;
      for (n = 0; n < 1 << zlib_Pako_trees.extra_lbits[code]; n++) {
        zlib_Pako_trees._length_code[length++] = code;
      }
    }
    zlib_Pako_trees._length_code[length - 1] = code;
    dist = 0;
    for (code = 0; code < 16; code++) {
      zlib_Pako_trees.base_dist[code] = dist;
      for (n = 0; n < 1 << zlib_Pako_trees.extra_dbits[code]; n++) {
        zlib_Pako_trees._dist_code[dist++] = code;
      }
    }
    dist >>= 7;
    for (; code < zlib_Pako_trees.D_CODES; code++) {
      zlib_Pako_trees.base_dist[code] = dist << 7;
      for (n = 0; n < 1 << zlib_Pako_trees.extra_dbits[code] - 7; n++) {
        zlib_Pako_trees._dist_code[256 + dist++] = code;
      }
    }
    for (bits = 0; bits <= zlib_Pako_trees.MAX_BITS; bits++) {
      bl_count[bits] = 0;
    }
    n = 0;
    while (n <= 143) {
      zlib_Pako_trees.static_ltree[n * 2 + 1] = 8;
      n++;
      bl_count[8]++;
    }
    while (n <= 255) {
      zlib_Pako_trees.static_ltree[n * 2 + 1] = 9;
      n++;
      bl_count[9]++;
    }
    while (n <= 279) {
      zlib_Pako_trees.static_ltree[n * 2 + 1] = 7;
      n++;
      bl_count[7]++;
    }
    while (n <= 287) {
      zlib_Pako_trees.static_ltree[n * 2 + 1] = 8;
      n++;
      bl_count[8]++;
    }
    zlib_Pako_trees.gen_codes(zlib_Pako_trees.static_ltree, zlib_Pako_trees.L_CODES + 1, bl_count);
    for (n = 0; n < zlib_Pako_trees.D_CODES; n++) {
      zlib_Pako_trees.static_dtree[n * 2 + 1] = 5;
      zlib_Pako_trees.static_dtree[n * 2] = zlib_Pako_trees.bi_reverse(n, 5);
    }
    zlib_Pako_trees.static_l_desc = new zlib_StaticTreeDesc(zlib_Pako_trees.static_ltree, zlib_Pako_trees.extra_lbits, zlib_Pako_trees.LITERALS + 1, zlib_Pako_trees.L_CODES, zlib_Pako_trees.MAX_BITS);
    zlib_Pako_trees.static_d_desc = new zlib_StaticTreeDesc(zlib_Pako_trees.static_dtree, zlib_Pako_trees.extra_dbits, 0, zlib_Pako_trees.D_CODES, zlib_Pako_trees.MAX_BITS);
    zlib_Pako_trees.static_bl_desc = new zlib_StaticTreeDesc(new Uint16Array(0), zlib_Pako_trees.extra_blbits, 0, zlib_Pako_trees.BL_CODES, zlib_Pako_trees.MAX_BL_BITS);
  }
  static init_block(s) {
    let n;
    for (n = 0; n < zlib_Pako_trees.L_CODES; n++) {
      s.dyn_ltree[n * 2] = 0;
    }
    for (n = 0; n < zlib_Pako_trees.D_CODES; n++) {
      s.dyn_dtree[n * 2] = 0;
    }
    for (n = 0; n < zlib_Pako_trees.BL_CODES; n++) {
      s.bl_tree[n * 2] = 0;
    }
    s.dyn_ltree[zlib_Pako_trees.END_BLOCK * 2] = 1;
    s.opt_len = s.static_len = 0;
    s.last_lit = s.matches = 0;
  }
  static bi_windup(s) {
    if (s.bi_valid > 8) {
      zlib_Pako_trees.put_short(s, s.bi_buf);
    } else if (s.bi_valid > 0) {
      s.pending_buf[s.pending++] = s.bi_buf;
    }
    s.bi_buf = 0;
    s.bi_valid = 0;
  }
  static copy_block(s, buf, len, header) {
    zlib_Pako_trees.bi_windup(s);
    if (header) {
      zlib_Pako_trees.put_short(s, len);
      zlib_Pako_trees.put_short(s, ~len);
    }
    s.pending_buf.set(s.window.subarray(buf, buf + len), s.pending);
    s.pending += len;
  }
  static smaller(tree, n, m, depth) {
    const _n2 = n * 2;
    const _m2 = m * 2;
    return tree[_n2] < tree[_m2] || tree[_n2] === tree[_m2] && depth[n] <= depth[m];
  }
  static pqdownheap(s, tree, k) {
    const v = s.heap[k];
    let j = k << 1;
    while (j <= s.heap_len) {
      if (j < s.heap_len && zlib_Pako_trees.smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
        j++;
      }
      if (zlib_Pako_trees.smaller(tree, v, s.heap[j], s.depth)) {
        break;
      }
      s.heap[k] = s.heap[j];
      k = j;
      j <<= 1;
    }
    s.heap[k] = v;
  }
  static compress_block(s, ltree, dtree) {
    let dist;
    let lc;
    let lx = 0;
    let code;
    let extra;
    if (s.last_lit !== 0) {
      do {
        dist = s.pending_buf[s.d_buf + lx * 2] << 8 | s.pending_buf[s.d_buf + lx * 2 + 1];
        lc = s.pending_buf[s.l_buf + lx];
        lx++;
        if (dist === 0) {
          zlib_Pako_trees.send_code(s, lc, ltree);
        } else {
          code = zlib_Pako_trees._length_code[lc];
          zlib_Pako_trees.send_code(s, code + zlib_Pako_trees.LITERALS + 1, ltree);
          extra = zlib_Pako_trees.extra_lbits[code];
          if (extra !== 0) {
            lc -= zlib_Pako_trees.base_length[code];
            zlib_Pako_trees.send_bits(s, lc, extra);
          }
          dist--;
          code = zlib_Pako_trees.d_code(dist);
          zlib_Pako_trees.send_code(s, code, dtree);
          extra = zlib_Pako_trees.extra_dbits[code];
          if (extra !== 0) {
            dist -= zlib_Pako_trees.base_dist[code];
            zlib_Pako_trees.send_bits(s, dist, extra);
          }
        }
      } while (lx < s.last_lit);
    }
    zlib_Pako_trees.send_code(s, zlib_Pako_trees.END_BLOCK, ltree);
  }
  static build_tree(s, desc) {
    const tree = desc.dyn_tree;
    const stree = desc.stat_desc.static_tree;
    const has_stree = desc.stat_desc.has_stree;
    const elems = desc.stat_desc.elems;
    let n, m;
    let max_code = -1;
    let node;
    s.heap_len = 0;
    s.heap_max = zlib_Pako_trees.HEAP_SIZE;
    for (n = 0; n < elems; n++) {
      if (tree[n * 2] !== 0) {
        s.heap[++s.heap_len] = max_code = n;
        s.depth[n] = 0;
      } else {
        tree[n * 2 + 1] = 0;
      }
    }
    while (s.heap_len < 2) {
      node = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0;
      tree[node * 2] = 1;
      s.depth[node] = 0;
      s.opt_len--;
      if (has_stree) {
        s.static_len -= stree[node * 2 + 1];
      }
    }
    desc.max_code = max_code;
    for (n = s.heap_len >> 1; n >= 1; n--) {
      zlib_Pako_trees.pqdownheap(s, tree, n);
    }
    node = elems;
    do {
      n = s.heap[1];
      s.heap[1] = s.heap[s.heap_len--];
      zlib_Pako_trees.pqdownheap(s, tree, 1);
      m = s.heap[1];
      s.heap[--s.heap_max] = n;
      s.heap[--s.heap_max] = m;
      tree[node * 2] = tree[n * 2] + tree[m * 2];
      s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
      tree[n * 2 + 1] = tree[m * 2 + 1] = node;
      s.heap[1] = node++;
      zlib_Pako_trees.pqdownheap(s, tree, 1);
    } while (s.heap_len >= 2);
    s.heap[--s.heap_max] = s.heap[1];
    zlib_Pako_trees.gen_bitlen(s, desc);
    zlib_Pako_trees.gen_codes(tree, max_code, s.bl_count);
  }
  static scan_tree(s, tree, max_code) {
    let n;
    let prevlen = -1;
    let curlen;
    let nextlen = tree[0 * 2 + 1];
    let count = 0;
    let max_count = 7;
    let min_count = 4;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    }
    tree[(max_code + 1) * 2 + 1] = 65535;
    for (n = 0; n <= max_code; n++) {
      curlen = nextlen;
      nextlen = tree[(n + 1) * 2 + 1];
      if (++count < max_count && curlen === nextlen) {
        continue;
      } else if (count < min_count) {
        s.bl_tree[curlen * 2] += count;
      } else if (curlen !== 0) {
        if (curlen !== prevlen) {
          s.bl_tree[curlen * 2]++;
        }
        s.bl_tree[zlib_Pako_trees.REP_3_6 * 2]++;
      } else if (count <= 10) {
        s.bl_tree[zlib_Pako_trees.REPZ_3_10 * 2]++;
      } else {
        s.bl_tree[zlib_Pako_trees.REPZ_11_138 * 2]++;
      }
      count = 0;
      prevlen = curlen;
      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      } else if (curlen === nextlen) {
        max_count = 6;
        min_count = 3;
      } else {
        max_count = 7;
        min_count = 4;
      }
    }
  }
  static send_tree(s, tree, max_code) {
    let n;
    let prevlen = -1;
    let curlen;
    let nextlen = tree[0 * 2 + 1];
    let count = 0;
    let max_count = 7;
    let min_count = 4;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    }
    for (n = 0; n <= max_code; n++) {
      curlen = nextlen;
      nextlen = tree[(n + 1) * 2 + 1];
      if (++count < max_count && curlen === nextlen) {
        continue;
      } else if (count < min_count) {
        do {
          zlib_Pako_trees.send_code(s, curlen, s.bl_tree);
        } while (--count !== 0);
      } else if (curlen !== 0) {
        if (curlen !== prevlen) {
          zlib_Pako_trees.send_code(s, curlen, s.bl_tree);
          count--;
        }
        zlib_Pako_trees.send_code(s, zlib_Pako_trees.REP_3_6, s.bl_tree);
        zlib_Pako_trees.send_bits(s, count - 3, 2);
      } else if (count <= 10) {
        zlib_Pako_trees.send_code(s, zlib_Pako_trees.REPZ_3_10, s.bl_tree);
        zlib_Pako_trees.send_bits(s, count - 3, 3);
      } else {
        zlib_Pako_trees.send_code(s, zlib_Pako_trees.REPZ_11_138, s.bl_tree);
        zlib_Pako_trees.send_bits(s, count - 11, 7);
      }
      count = 0;
      prevlen = curlen;
      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      } else if (curlen === nextlen) {
        max_count = 6;
        min_count = 3;
      } else {
        max_count = 7;
        min_count = 4;
      }
    }
  }
  static build_bl_tree(s) {
    let max_blindex;
    zlib_Pako_trees.scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
    zlib_Pako_trees.scan_tree(s, s.dyn_dtree, s.d_desc.max_code);
    zlib_Pako_trees.build_tree(s, s.bl_desc);
    for (max_blindex = zlib_Pako_trees.BL_CODES - 1; max_blindex >= 3; max_blindex--) {
      if (s.bl_tree[zlib_Pako_trees.bl_order[max_blindex] * 2 + 1] !== 0) {
        break;
      }
    }
    s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
    return max_blindex;
  }
  static send_all_trees(s, lcodes, dcodes, blcodes) {
    let rank;
    zlib_Pako_trees.send_bits(s, lcodes - 257, 5);
    zlib_Pako_trees.send_bits(s, dcodes - 1, 5);
    zlib_Pako_trees.send_bits(s, blcodes - 4, 4);
    for (rank = 0; rank < blcodes; rank++) {
      zlib_Pako_trees.send_bits(s, s.bl_tree[zlib_Pako_trees.bl_order[rank] * 2 + 1], 3);
    }
    zlib_Pako_trees.send_tree(s, s.dyn_ltree, lcodes - 1);
    zlib_Pako_trees.send_tree(s, s.dyn_dtree, dcodes - 1);
  }
  static detect_data_type(s) {
    let black_mask = 4093624447;
    let n;
    for (n = 0; n <= 31; n++, black_mask >>>= 1) {
      if (black_mask & 1 && s.dyn_ltree[n * 2] !== 0) {
        return zlib_constants.Z_BINARY;
      }
    }
    if (s.dyn_ltree[9 * 2] !== 0 || s.dyn_ltree[10 * 2] !== 0 || s.dyn_ltree[13 * 2] !== 0) {
      return zlib_constants.Z_TEXT;
    }
    for (n = 32; n < zlib_Pako_trees.LITERALS; n++) {
      if (s.dyn_ltree[n * 2] !== 0) {
        return zlib_constants.Z_TEXT;
      }
    }
    return zlib_constants.Z_BINARY;
  }
  static _tr_init(s) {
    if (!zlib_Pako_trees.static_init_done) {
      zlib_Pako_trees.tr_static_init();
      zlib_Pako_trees.static_init_done = true;
    }
    s.l_desc = new zlib_TreeDesc(s.dyn_ltree, zlib_Pako_trees.static_l_desc);
    s.d_desc = new zlib_TreeDesc(s.dyn_dtree, zlib_Pako_trees.static_d_desc);
    s.bl_desc = new zlib_TreeDesc(s.bl_tree, zlib_Pako_trees.static_bl_desc);
    s.bi_buf = 0;
    s.bi_valid = 0;
    zlib_Pako_trees.init_block(s);
  }
  static _tr_stored_block(s, buf, stored_len, last) {
    zlib_Pako_trees.send_bits(s, (zlib_Pako_trees.STORED_BLOCK << 1) + (last ? 1 : 0), 3);
    zlib_Pako_trees.copy_block(s, buf, stored_len, true);
  }
  static _tr_align(s) {
    zlib_Pako_trees.send_bits(s, zlib_Pako_trees.STATIC_TREES << 1, 3);
    zlib_Pako_trees.send_code(s, zlib_Pako_trees.END_BLOCK, zlib_Pako_trees.static_ltree);
    zlib_Pako_trees.bi_flush(s);
  }
  static _tr_flush_block(s, buf, stored_len, last) {
    let opt_lenb;
    let static_lenb;
    let max_blindex = 0;
    if (s.level > 0) {
      if (s.strm.data_type === zlib_constants.Z_UNKNOWN) {
        s.strm.data_type = zlib_Pako_trees.detect_data_type(s);
      }
      zlib_Pako_trees.build_tree(s, s.l_desc);
      zlib_Pako_trees.build_tree(s, s.d_desc);
      max_blindex = zlib_Pako_trees.build_bl_tree(s);
      opt_lenb = s.opt_len + 3 + 7 >>> 3;
      static_lenb = s.static_len + 3 + 7 >>> 3;
      if (static_lenb <= opt_lenb) {
        opt_lenb = static_lenb;
      }
    } else {
      opt_lenb = static_lenb = stored_len + 5;
    }
    if (stored_len + 4 <= opt_lenb && buf !== -1) {
      zlib_Pako_trees._tr_stored_block(s, buf, stored_len, last);
    } else if (s.strategy === zlib_constants.Z_FIXED || static_lenb === opt_lenb) {
      zlib_Pako_trees.send_bits(s, (zlib_Pako_trees.STATIC_TREES << 1) + (last ? 1 : 0), 3);
      zlib_Pako_trees.compress_block(s, zlib_Pako_trees.static_ltree, zlib_Pako_trees.static_dtree);
    } else {
      zlib_Pako_trees.send_bits(s, (zlib_Pako_trees.DYN_TREES << 1) + (last ? 1 : 0), 3);
      zlib_Pako_trees.send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
      zlib_Pako_trees.compress_block(s, s.dyn_ltree, s.dyn_dtree);
    }
    zlib_Pako_trees.init_block(s);
    if (last) {
      zlib_Pako_trees.bi_windup(s);
    }
  }
  static _tr_tally(s, dist, lc) {
    s.pending_buf[s.d_buf + s.last_lit * 2] = dist >>> 8 & 255;
    s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 255;
    s.pending_buf[s.l_buf + s.last_lit] = lc & 255;
    s.last_lit++;
    if (dist === 0) {
      s.dyn_ltree[lc * 2]++;
    } else {
      s.matches++;
      dist--;
      s.dyn_ltree[(zlib_Pako_trees._length_code[lc] + zlib_Pako_trees.LITERALS + 1) * 2]++;
      s.dyn_dtree[zlib_Pako_trees.d_code(dist) * 2]++;
    }
    return s.last_lit === s.lit_bufsize - 1;
  }
};
zlib_Pako_trees.Z_FIXED = 4;
zlib_Pako_trees.Z_BINARY = 0;
zlib_Pako_trees.Z_TEXT = 1;
zlib_Pako_trees.Z_UNKNOWN = 2;
zlib_Pako_trees.STORED_BLOCK = 0;
zlib_Pako_trees.STATIC_TREES = 1;
zlib_Pako_trees.DYN_TREES = 2;
zlib_Pako_trees.MIN_MATCH = 3;
zlib_Pako_trees.MAX_MATCH = 258;
zlib_Pako_trees.LENGTH_CODES = 29;
zlib_Pako_trees.LITERALS = 256;
zlib_Pako_trees.L_CODES = zlib_Pako_trees.LITERALS + 1 + zlib_Pako_trees.LENGTH_CODES;
zlib_Pako_trees.D_CODES = 30;
zlib_Pako_trees.BL_CODES = 19;
zlib_Pako_trees.HEAP_SIZE = 2 * zlib_Pako_trees.L_CODES + 1;
zlib_Pako_trees.MAX_BITS = 15;
zlib_Pako_trees.Buf_size = 16;
zlib_Pako_trees.MAX_BL_BITS = 7;
zlib_Pako_trees.END_BLOCK = 256;
zlib_Pako_trees.REP_3_6 = 16;
zlib_Pako_trees.REPZ_3_10 = 17;
zlib_Pako_trees.REPZ_11_138 = 18;
zlib_Pako_trees.extra_lbits = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0]);
zlib_Pako_trees.extra_dbits = new Uint8Array([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]);
zlib_Pako_trees.extra_blbits = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7]);
zlib_Pako_trees.bl_order = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
zlib_Pako_trees.DIST_CODE_LEN = 512;
zlib_Pako_trees.static_ltree = new Uint16Array((zlib_Pako_trees.L_CODES + 2) * 2);
zlib_Pako_trees.static_dtree = new Uint16Array(zlib_Pako_trees.D_CODES * 2);
zlib_Pako_trees._dist_code = new Uint16Array(zlib_Pako_trees.DIST_CODE_LEN);
zlib_Pako_trees._length_code = new Uint16Array(zlib_Pako_trees.MAX_MATCH - zlib_Pako_trees.MIN_MATCH + 1);
zlib_Pako_trees.base_length = new Uint16Array(zlib_Pako_trees.LENGTH_CODES);
zlib_Pako_trees.base_dist = new Uint16Array(zlib_Pako_trees.D_CODES);
zlib_Pako_trees.send_bits = (s, value, length) => {
  if (s.bi_valid > zlib_Pako_trees.Buf_size - length) {
    s.bi_buf |= value << s.bi_valid & 65535;
    zlib_Pako_trees.put_short(s, s.bi_buf);
    s.bi_buf = value >> zlib_Pako_trees.Buf_size - s.bi_valid;
    s.bi_valid += length - zlib_Pako_trees.Buf_size;
  } else {
    s.bi_buf |= value << s.bi_valid & 65535;
    s.bi_valid += length;
  }
};
zlib_Pako_trees.gen_bitlen = (s, desc) => {
  const tree = desc.dyn_tree;
  const max_code = desc.max_code;
  const stree = desc.stat_desc.static_tree;
  const has_stree = desc.stat_desc.has_stree;
  const extra = desc.stat_desc.extra_bits;
  const base = desc.stat_desc.extra_base;
  const max_length = desc.stat_desc.max_length;
  let h;
  let n, m;
  let bits;
  let xbits;
  let f;
  let overflow = 0;
  for (bits = 0; bits <= zlib_Pako_trees.MAX_BITS; bits++) {
    s.bl_count[bits] = 0;
  }
  tree[s.heap[s.heap_max] * 2 + 1] = 0;
  for (h = s.heap_max + 1; h < zlib_Pako_trees.HEAP_SIZE; h++) {
    n = s.heap[h];
    bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;
    if (bits > max_length) {
      bits = max_length;
      overflow++;
    }
    tree[n * 2 + 1] = bits;
    if (n > max_code) {
      continue;
    }
    s.bl_count[bits]++;
    xbits = 0;
    if (n >= base) {
      xbits = extra[n - base];
    }
    f = tree[n * 2];
    s.opt_len += f * (bits + xbits);
    if (has_stree) {
      s.static_len += f * (stree[n * 2 + 1] + xbits);
    }
  }
  if (overflow === 0) {
    return;
  }
  do {
    bits = max_length - 1;
    while (s.bl_count[bits] === 0) {
      bits--;
    }
    s.bl_count[bits]--;
    s.bl_count[bits + 1] += 2;
    s.bl_count[max_length]--;
    overflow -= 2;
  } while (overflow > 0);
  for (bits = max_length; bits !== 0; bits--) {
    n = s.bl_count[bits];
    while (n !== 0) {
      m = s.heap[--h];
      if (m > max_code) {
        continue;
      }
      if (tree[m * 2 + 1] !== bits) {
        s.opt_len += (bits - tree[m * 2 + 1]) * tree[m * 2];
        tree[m * 2 + 1] = bits;
      }
      n--;
    }
  }
};
zlib_Pako_trees.static_init_done = false;
zlib_Pako_trees.initDone = zlib_Pako_trees.Zeroinit();

// obj/full/Pako/zlib/gzheader.js
"use strict";
var zlib_GZheader = class {
  constructor() {
    this.text = 0;
    this.time = 0;
    this.xflags = 0;
    this.os = 0;
    this.extra = null;
    this.extra_len = 0;
    this.name = "";
    this.comment = "";
    this.hcrc = 0;
    this.done = false;
  }
};

// obj/full/Pako/zlib/inffast.js
"use strict";
var zlib_inffast = class {
  static inflate_fast(strm, start) {
    let _in;
    let last;
    let _out;
    let beg;
    let end;
    let wsize;
    let whave;
    let wnext;
    let s_window;
    let hold;
    let bits;
    let lcode;
    let dcode;
    let lmask;
    let dmask;
    let here;
    let op;
    let len;
    let dist;
    let from;
    let from_source;
    let input;
    let output;
    let state = strm.state;
    _in = strm.next_in;
    input = strm.input;
    last = _in + (strm.avail_in - 5);
    _out = strm.next_out;
    output = strm.output;
    beg = _out - (start - strm.avail_out);
    end = _out + (strm.avail_out - 257);
    wsize = state.wsize;
    whave = state.whave;
    wnext = state.wnext;
    s_window = state.window;
    hold = state.hold;
    bits = state.bits;
    lcode = state.lencode;
    dcode = state.distcode;
    lmask = (1 << state.lenbits) - 1;
    dmask = (1 << state.distbits) - 1;
    top:
      do {
        if (bits < 15) {
          hold += input[_in++] << bits;
          bits += 8;
          hold += input[_in++] << bits;
          bits += 8;
        }
        here = lcode[hold & lmask];
        dolen:
          for (; ; ) {
            op = here >>> 24;
            hold >>>= op;
            bits -= op;
            op = here >>> 16 & 255;
            if (op === 0) {
              output[_out++] = here & 65535;
            } else if (op & 16) {
              len = here & 65535;
              op &= 15;
              if (op) {
                if (bits < op) {
                  hold += input[_in++] << bits;
                  bits += 8;
                }
                len += hold & (1 << op) - 1;
                hold >>>= op;
                bits -= op;
              }
              if (bits < 15) {
                hold += input[_in++] << bits;
                bits += 8;
                hold += input[_in++] << bits;
                bits += 8;
              }
              here = dcode[hold & dmask];
              dodist:
                for (; ; ) {
                  op = here >>> 24;
                  hold >>>= op;
                  bits -= op;
                  op = here >>> 16 & 255;
                  if (op & 16) {
                    dist = here & 65535;
                    op &= 15;
                    if (bits < op) {
                      hold += input[_in++] << bits;
                      bits += 8;
                      if (bits < op) {
                        hold += input[_in++] << bits;
                        bits += 8;
                      }
                    }
                    dist += hold & (1 << op) - 1;
                    hold >>>= op;
                    bits -= op;
                    op = _out - beg;
                    if (dist > op) {
                      op = dist - op;
                      if (op > whave) {
                        if (state.sane) {
                          strm.msg = "invalid distance too far back";
                          state.mode = zlib_inffast.BAD;
                          break top;
                        }
                      }
                      from = 0;
                      from_source = s_window;
                      if (wnext === 0) {
                        from += wsize - op;
                        if (op < len) {
                          len -= op;
                          do {
                            output[_out++] = s_window[from++];
                          } while (--op);
                          from = _out - dist;
                          from_source = output;
                        }
                      } else if (wnext < op) {
                        from += wsize + wnext - op;
                        op -= wnext;
                        if (op < len) {
                          len -= op;
                          do {
                            output[_out++] = s_window[from++];
                          } while (--op);
                          from = 0;
                          if (wnext < len) {
                            op = wnext;
                            len -= op;
                            do {
                              output[_out++] = s_window[from++];
                            } while (--op);
                            from = _out - dist;
                            from_source = output;
                          }
                        }
                      } else {
                        from += wnext - op;
                        if (op < len) {
                          len -= op;
                          do {
                            output[_out++] = s_window[from++];
                          } while (--op);
                          from = _out - dist;
                          from_source = output;
                        }
                      }
                      while (len > 2) {
                        output[_out++] = from_source[from++];
                        output[_out++] = from_source[from++];
                        output[_out++] = from_source[from++];
                        len -= 3;
                      }
                      if (len) {
                        output[_out++] = from_source[from++];
                        if (len > 1) {
                          output[_out++] = from_source[from++];
                        }
                      }
                    } else {
                      from = _out - dist;
                      do {
                        output[_out++] = output[from++];
                        output[_out++] = output[from++];
                        output[_out++] = output[from++];
                        len -= 3;
                      } while (len > 2);
                      if (len) {
                        output[_out++] = output[from++];
                        if (len > 1) {
                          output[_out++] = output[from++];
                        }
                      }
                    }
                  } else if ((op & 64) === 0) {
                    here = dcode[(here & 65535) + (hold & (1 << op) - 1)];
                    continue dodist;
                  } else {
                    strm.msg = "invalid distance code";
                    state.mode = zlib_inffast.BAD;
                    break top;
                  }
                  break;
                }
            } else if ((op & 64) === 0) {
              here = lcode[(here & 65535) + (hold & (1 << op) - 1)];
              continue dolen;
            } else if (op & 32) {
              state.mode = zlib_inffast.TYPE;
              break top;
            } else {
              strm.msg = "invalid literal/length code";
              state.mode = zlib_inffast.BAD;
              break top;
            }
            break;
          }
      } while (_in < last && _out < end);
    len = bits >> 3;
    _in -= len;
    bits -= len << 3;
    hold &= (1 << bits) - 1;
    strm.next_in = _in;
    strm.next_out = _out;
    strm.avail_in = _in < last ? 5 + (last - _in) : 5 - (_in - last);
    strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);
    state.hold = hold;
    state.bits = bits;
    return;
  }
};
zlib_inffast.BAD = 30;
zlib_inffast.TYPE = 12;

// obj/full/Pako/zlib/inflate.js
"use strict";
var zlib_InflateState = class {
  constructor() {
    this.mode = 0;
    this.last = 0;
    this.wrap = 0;
    this.havedict = 0;
    this.flags = 0;
    this.dmax = 0;
    this.check = 0;
    this.total = 0;
    this.head = null;
    this.wbits = 0;
    this.wsize = 0;
    this.whave = 0;
    this.wnext = 0;
    this.window = null;
    this.hold = 0;
    this.bits = 0;
    this.length = 0;
    this.offset = 0;
    this.extra = 0;
    this.lencode = null;
    this.distcode = null;
    this.lenbits = 0;
    this.distbits = 0;
    this.ncode = 0;
    this.nlen = 0;
    this.ndist = 0;
    this.have = 0;
    this.next = null;
    this.lens = new Uint16Array(320);
    this.work = new Uint16Array(288);
    this.lendyn = null;
    this.distdyn = null;
    this.sane = 0;
    this.back = 0;
    this.was = 0;
  }
};
var zlib_inflate = class {
  static zswap32(q) {
    return (q >>> 24 & 255) + (q >>> 8 & 65280) + ((q & 65280) << 8) + ((q & 255) << 24);
  }
  static inflateResetKeep(strm) {
    if (!strm || !strm.state) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    let state = strm.state;
    strm.total_in = strm.total_out = state.total = 0;
    strm.msg = "";
    if (state.wrap) {
      strm.adler = state.wrap & 1;
    }
    state.mode = zlib_inflate.HEAD;
    state.last = 0;
    state.havedict = 0;
    state.dmax = 32768;
    state.head = null;
    state.hold = 0;
    state.bits = 0;
    state.lencode = state.lendyn = new Int32Array(zlib_inflate.ENOUGH_LENS);
    state.distcode = state.distdyn = new Int32Array(zlib_inflate.ENOUGH_DISTS);
    state.sane = 1;
    state.back = -1;
    return zlib_constants.Z_OK;
  }
  static inflateReset(strm) {
    if (!strm || !strm.state) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    const state = strm.state;
    state.wsize = 0;
    state.whave = 0;
    state.wnext = 0;
    return zlib_inflate.inflateResetKeep(strm);
  }
  static inflateReset2(strm, windowBits) {
    let wrap;
    if (!strm || !strm.state) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    let state = strm.state;
    if (windowBits < 0) {
      wrap = 0;
      windowBits = -windowBits;
    } else {
      wrap = (windowBits >> 4) + 1;
      if (windowBits < 48) {
        windowBits &= 15;
      }
    }
    if (windowBits && (windowBits < 8 || windowBits > 15)) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    if (state.window !== null && state.wbits !== windowBits) {
      state.window = null;
    }
    state.wrap = wrap;
    state.wbits = windowBits;
    return zlib_inflate.inflateReset(strm);
  }
  static inflateInit2(strm, windowBits) {
    if (!strm) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    let state = new zlib_InflateState();
    strm.state = state;
    state.window = null;
    const ret = zlib_inflate.inflateReset2(strm, windowBits);
    if (ret !== zlib_constants.Z_OK) {
      strm.state = null;
    }
    return ret;
  }
  static inflateInit(strm) {
    return zlib_inflate.inflateInit2(strm, zlib_inflate.DEF_WBITS);
  }
  static fixedtables(state) {
    if (zlib_inflate.virgin) {
      zlib_inflate.lenfix = new Int32Array(512);
      zlib_inflate.distfix = new Int32Array(32);
      let sym = 0;
      while (sym < 144) {
        state.lens[sym++] = 8;
      }
      while (sym < 256) {
        state.lens[sym++] = 9;
      }
      while (sym < 280) {
        state.lens[sym++] = 7;
      }
      while (sym < 288) {
        state.lens[sym++] = 8;
      }
      zlib_inftrees.inflate_table(zlib_inflate.LENS, state.lens, 0, 288, zlib_inflate.lenfix, 0, state.work, {bits: 9});
      sym = 0;
      while (sym < 32) {
        state.lens[sym++] = 5;
      }
      zlib_inftrees.inflate_table(zlib_inflate.DISTS, state.lens, 0, 32, zlib_inflate.distfix, 0, state.work, {bits: 5});
      zlib_inflate.virgin = false;
    }
    state.lencode = zlib_inflate.lenfix;
    state.lenbits = 9;
    state.distcode = zlib_inflate.distfix;
    state.distbits = 5;
  }
  static updatewindow(strm, src, end, copy) {
    let dist;
    const state = strm.state;
    if (state.window === null) {
      state.wsize = 1 << state.wbits;
      state.wnext = 0;
      state.whave = 0;
      state.window = new Uint8Array(state.wsize);
    }
    if (copy >= state.wsize) {
      state.window.set(src.subarray(end - state.wsize, end), 0);
      state.wnext = 0;
      state.whave = state.wsize;
    } else {
      dist = state.wsize - state.wnext;
      if (dist > copy) {
        dist = copy;
      }
      state.window.set(src.subarray(end - copy, end - copy + dist), state.wnext);
      copy -= dist;
      if (copy) {
        state.window.set(src.subarray(end - copy, end), 0);
        state.wnext = copy;
        state.whave = state.wsize;
      } else {
        state.wnext += dist;
        if (state.wnext === state.wsize) {
          state.wnext = 0;
        }
        if (state.whave < state.wsize) {
          state.whave += dist;
        }
      }
    }
    return 0;
  }
  static inflate(strm, flush) {
    let state;
    let input, output;
    let next;
    let put;
    let have, left;
    let hold;
    let bits;
    let _in;
    let _out;
    let copy;
    let from;
    let from_source;
    let here = 0;
    let here_bits;
    let here_op;
    let here_val;
    let last_bits;
    let last_op;
    let last_val;
    let len;
    let ret;
    const hbuf = new Uint8Array(4);
    let opts;
    let n;
    let order = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
    if (!strm || !strm.state || !strm.output || !strm.input && strm.avail_in !== 0) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    state = strm.state;
    if (state.mode === zlib_inflate.TYPE) {
      state.mode = zlib_inflate.TYPEDO;
    }
    put = strm.next_out;
    output = strm.output;
    left = strm.avail_out;
    next = strm.next_in;
    input = strm.input;
    have = strm.avail_in;
    hold = state.hold;
    bits = state.bits;
    _in = have;
    _out = left;
    ret = zlib_constants.Z_OK;
    inf_leave:
      for (; ; ) {
        switch (state.mode) {
          case zlib_inflate.HEAD:
            if (state.wrap === 0) {
              state.mode = zlib_inflate.TYPEDO;
              break;
            }
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (state.wrap & 2 && hold === 35615) {
              state.check = 0;
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              state.check = zlib_crc32.crc32(state.check, hbuf, 2, 0);
              hold = 0;
              bits = 0;
              state.mode = zlib_inflate.FLAGS;
              break;
            }
            state.flags = 0;
            if (state.head) {
              state.head.done = false;
            }
            if (!(state.wrap & 1) || (((hold & 255) << 8) + (hold >> 8)) % 31) {
              strm.msg = "incorrect header check";
              state.mode = zlib_inflate.BAD;
              break;
            }
            if ((hold & 15) !== zlib_constants.Z_DEFLATED) {
              strm.msg = "unknown compression method";
              state.mode = zlib_inflate.BAD;
              break;
            }
            hold >>>= 4;
            bits -= 4;
            len = (hold & 15) + 8;
            if (state.wbits === 0) {
              state.wbits = len;
            } else if (len > state.wbits) {
              strm.msg = "invalid window size";
              state.mode = zlib_inflate.BAD;
              break;
            }
            state.dmax = 1 << state.wbits;
            strm.adler = state.check = 1;
            state.mode = hold & 512 ? zlib_inflate.DICTID : zlib_inflate.TYPE;
            hold = 0;
            bits = 0;
            break;
          case zlib_inflate.FLAGS:
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.flags = hold;
            if ((state.flags & 255) !== zlib_constants.Z_DEFLATED) {
              strm.msg = "unknown compression method";
              state.mode = zlib_inflate.BAD;
              break;
            }
            if (state.flags & 57344) {
              strm.msg = "unknown header flags set";
              state.mode = zlib_inflate.BAD;
              break;
            }
            if (state.head) {
              state.head.text = hold >> 8 & 1;
            }
            if (state.flags & 512) {
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              state.check = zlib_crc32.crc32(state.check, hbuf, 2, 0);
            }
            hold = 0;
            bits = 0;
            state.mode = zlib_inflate.TIME;
          case zlib_inflate.TIME:
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (state.head) {
              state.head.time = hold;
            }
            if (state.flags & 512) {
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              hbuf[2] = hold >>> 16 & 255;
              hbuf[3] = hold >>> 24 & 255;
              state.check = zlib_crc32.crc32(state.check, hbuf, 4, 0);
            }
            hold = 0;
            bits = 0;
            state.mode = zlib_inflate.OS;
          case zlib_inflate.OS:
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (state.head) {
              state.head.xflags = hold & 255;
              state.head.os = hold >> 8;
            }
            if (state.flags & 512) {
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              state.check = zlib_crc32.crc32(state.check, hbuf, 2, 0);
            }
            hold = 0;
            bits = 0;
            state.mode = zlib_inflate.EXLEN;
          case zlib_inflate.EXLEN:
            if (state.flags & 1024) {
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.length = hold;
              if (state.head) {
                state.head.extra_len = hold;
              }
              if (state.flags & 512) {
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                state.check = zlib_crc32.crc32(state.check, hbuf, 2, 0);
              }
              hold = 0;
              bits = 0;
            } else if (state.head) {
              state.head.extra = null;
            }
            state.mode = zlib_inflate.EXTRA;
          case zlib_inflate.EXTRA:
            if (state.flags & 1024) {
              copy = state.length;
              if (copy > have) {
                copy = have;
              }
              if (copy) {
                if (state.head) {
                  len = state.head.extra_len - state.length;
                  if (!state.head.extra) {
                    state.head.extra = new Uint8Array(state.head.extra_len);
                  }
                  state.head.extra.set(input.subarray(next, next + copy), len);
                }
                if (state.flags & 512) {
                  state.check = zlib_crc32.crc32(state.check, input, copy, next);
                }
                have -= copy;
                next += copy;
                state.length -= copy;
              }
              if (state.length) {
                break inf_leave;
              }
            }
            state.length = 0;
            state.mode = zlib_inflate.NAME;
          case zlib_inflate.NAME:
            if (state.flags & 2048) {
              if (have === 0) {
                break inf_leave;
              }
              copy = 0;
              do {
                len = input[next + copy++];
                if (state.head && len && state.length < 65536) {
                  state.head.name += String.fromCharCode(len);
                }
              } while (len && copy < have);
              if (state.flags & 512) {
                state.check = zlib_crc32.crc32(state.check, input, copy, next);
              }
              have -= copy;
              next += copy;
              if (len) {
                break inf_leave;
              }
            } else if (state.head) {
              state.head.name = null;
            }
            state.length = 0;
            state.mode = zlib_inflate.COMMENT;
          case zlib_inflate.COMMENT:
            if (state.flags & 4096) {
              if (have === 0) {
                break inf_leave;
              }
              copy = 0;
              do {
                len = input[next + copy++];
                if (state.head && len && state.length < 65536) {
                  state.head.comment += String.fromCharCode(len);
                }
              } while (len && copy < have);
              if (state.flags & 512) {
                state.check = zlib_crc32.crc32(state.check, input, copy, next);
              }
              have -= copy;
              next += copy;
              if (len) {
                break inf_leave;
              }
            } else if (state.head) {
              state.head.comment = null;
            }
            state.mode = zlib_inflate.HCRC;
          case zlib_inflate.HCRC:
            if (state.flags & 512) {
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (hold !== (state.check & 65535)) {
                strm.msg = "header crc mismatch";
                state.mode = zlib_inflate.BAD;
                break;
              }
              hold = 0;
              bits = 0;
            }
            if (state.head) {
              state.head.hcrc = state.flags >> 9 & 1;
              state.head.done = true;
            }
            strm.adler = state.check = 0;
            state.mode = zlib_inflate.TYPE;
            break;
          case zlib_inflate.DICTID:
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            strm.adler = state.check = zlib_inflate.zswap32(hold);
            hold = 0;
            bits = 0;
            state.mode = zlib_inflate.DICT;
          case zlib_inflate.DICT:
            if (!state.havedict) {
              strm.next_out = put;
              strm.avail_out = left;
              strm.next_in = next;
              strm.avail_in = have;
              state.hold = hold;
              state.bits = bits;
              return zlib_constants.Z_NEED_DICT;
            }
            strm.adler = state.check = 1;
            state.mode = zlib_inflate.TYPE;
          case zlib_inflate.TYPE:
            if (flush === zlib_constants.Z_BLOCK || flush === zlib_constants.Z_TREES) {
              break inf_leave;
            }
          case zlib_inflate.TYPEDO:
            if (state.last) {
              hold >>>= bits & 7;
              bits -= bits & 7;
              state.mode = zlib_inflate.CHECK;
              break;
            }
            while (bits < 3) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.last = hold & 1;
            hold >>>= 1;
            bits -= 1;
            switch (hold & 3) {
              case 0:
                state.mode = zlib_inflate.STORED;
                break;
              case 1:
                zlib_inflate.fixedtables(state);
                state.mode = zlib_inflate.LEN_;
                if (flush === zlib_constants.Z_TREES) {
                  hold >>>= 2;
                  bits -= 2;
                  break inf_leave;
                }
                break;
              case 2:
                state.mode = zlib_inflate.TABLE;
                break;
              case 3:
                strm.msg = "invalid block type";
                state.mode = zlib_inflate.BAD;
            }
            hold >>>= 2;
            bits -= 2;
            break;
          case zlib_inflate.STORED:
            hold >>>= bits & 7;
            bits -= bits & 7;
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if ((hold & 65535) !== (hold >>> 16 ^ 65535)) {
              strm.msg = "invalid stored block lengths";
              state.mode = zlib_inflate.BAD;
              break;
            }
            state.length = hold & 65535;
            hold = 0;
            bits = 0;
            state.mode = zlib_inflate.COPY_;
            if (flush === zlib_constants.Z_TREES) {
              break inf_leave;
            }
          case zlib_inflate.COPY_:
            state.mode = zlib_inflate.COPY;
          case zlib_inflate.COPY:
            copy = state.length;
            if (copy) {
              if (copy > have) {
                copy = have;
              }
              if (copy > left) {
                copy = left;
              }
              if (copy === 0) {
                break inf_leave;
              }
              output.set(input.subarray(next, next + copy), put);
              have -= copy;
              next += copy;
              left -= copy;
              put += copy;
              state.length -= copy;
              break;
            }
            state.mode = zlib_inflate.TYPE;
            break;
          case zlib_inflate.TABLE:
            while (bits < 14) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.nlen = (hold & 31) + 257;
            hold >>>= 5;
            bits -= 5;
            state.ndist = (hold & 31) + 1;
            hold >>>= 5;
            bits -= 5;
            state.ncode = (hold & 15) + 4;
            hold >>>= 4;
            bits -= 4;
            if (state.nlen > 286 || state.ndist > 30) {
              strm.msg = "too many length or distance symbols";
              state.mode = zlib_inflate.BAD;
              break;
            }
            state.have = 0;
            state.mode = zlib_inflate.LENLENS;
          case zlib_inflate.LENLENS:
            while (state.have < state.ncode) {
              while (bits < 3) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.lens[order[state.have++]] = hold & 7;
              hold >>>= 3;
              bits -= 3;
            }
            while (state.have < 19) {
              state.lens[order[state.have++]] = 0;
            }
            state.lencode = state.lendyn;
            state.lenbits = 7;
            opts = {bits: state.lenbits};
            ret = zlib_inftrees.inflate_table(zlib_inflate.CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
            state.lenbits = opts.bits;
            if (ret) {
              strm.msg = "invalid code lengths set";
              state.mode = zlib_inflate.BAD;
              break;
            }
            state.have = 0;
            state.mode = zlib_inflate.CODELENS;
          case zlib_inflate.CODELENS:
            while (state.have < state.nlen + state.ndist) {
              for (; ; ) {
                here = state.lencode[hold & (1 << state.lenbits) - 1];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (here_val < 16) {
                hold >>>= here_bits;
                bits -= here_bits;
                state.lens[state.have++] = here_val;
              } else {
                if (here_val === 16) {
                  n = here_bits + 2;
                  while (bits < n) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  hold >>>= here_bits;
                  bits -= here_bits;
                  if (state.have === 0) {
                    strm.msg = "invalid bit length repeat";
                    state.mode = zlib_inflate.BAD;
                    break;
                  }
                  len = state.lens[state.have - 1];
                  copy = 3 + (hold & 3);
                  hold >>>= 2;
                  bits -= 2;
                } else if (here_val === 17) {
                  n = here_bits + 3;
                  while (bits < n) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  hold >>>= here_bits;
                  bits -= here_bits;
                  len = 0;
                  copy = 3 + (hold & 7);
                  hold >>>= 3;
                  bits -= 3;
                } else {
                  n = here_bits + 7;
                  while (bits < n) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  hold >>>= here_bits;
                  bits -= here_bits;
                  len = 0;
                  copy = 11 + (hold & 127);
                  hold >>>= 7;
                  bits -= 7;
                }
                if (state.have + copy > state.nlen + state.ndist) {
                  strm.msg = "invalid bit length repeat";
                  state.mode = zlib_inflate.BAD;
                  break;
                }
                while (copy--) {
                  state.lens[state.have++] = len;
                }
              }
            }
            if (state.mode === zlib_inflate.BAD) {
              break;
            }
            if (state.lens[256] === 0) {
              strm.msg = "invalid code -- missing end-of-block";
              state.mode = zlib_inflate.BAD;
              break;
            }
            state.lenbits = 9;
            opts = {bits: state.lenbits};
            ret = zlib_inftrees.inflate_table(zlib_inflate.LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
            state.lenbits = opts.bits;
            if (ret) {
              strm.msg = "invalid literal/lengths set";
              state.mode = zlib_inflate.BAD;
              break;
            }
            state.distbits = 6;
            state.distcode = state.distdyn;
            opts = {bits: state.distbits};
            ret = zlib_inftrees.inflate_table(zlib_inflate.DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
            state.distbits = opts.bits;
            if (ret) {
              strm.msg = "invalid distances set";
              state.mode = zlib_inflate.BAD;
              break;
            }
            state.mode = zlib_inflate.LEN_;
            if (flush === zlib_constants.Z_TREES) {
              break inf_leave;
            }
          case zlib_inflate.LEN_:
            state.mode = zlib_inflate.LEN;
          case zlib_inflate.LEN:
            if (have >= 6 && left >= 258) {
              strm.next_out = put;
              strm.avail_out = left;
              strm.next_in = next;
              strm.avail_in = have;
              state.hold = hold;
              state.bits = bits;
              zlib_inffast.inflate_fast(strm, _out);
              put = strm.next_out;
              output = strm.output;
              left = strm.avail_out;
              next = strm.next_in;
              input = strm.input;
              have = strm.avail_in;
              hold = state.hold;
              bits = state.bits;
              if (state.mode === zlib_inflate.TYPE) {
                state.back = -1;
              }
              break;
            }
            state.back = 0;
            for (; ; ) {
              here = state.lencode[hold & (1 << state.lenbits) - 1];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (here_op && (here_op & 240) === 0) {
              last_bits = here_bits;
              last_op = here_op;
              last_val = here_val;
              for (; ; ) {
                here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (last_bits + here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              hold >>>= last_bits;
              bits -= last_bits;
              state.back += last_bits;
            }
            hold >>>= here_bits;
            bits -= here_bits;
            state.back += here_bits;
            state.length = here_val;
            if (here_op === 0) {
              state.mode = zlib_inflate.LIT;
              break;
            }
            if (here_op & 32) {
              state.back = -1;
              state.mode = zlib_inflate.TYPE;
              break;
            }
            if (here_op & 64) {
              strm.msg = "invalid literal/length code";
              state.mode = zlib_inflate.BAD;
              break;
            }
            state.extra = here_op & 15;
            state.mode = zlib_inflate.LENEXT;
          case zlib_inflate.LENEXT:
            if (state.extra) {
              n = state.extra;
              while (bits < n) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.length += hold & (1 << state.extra) - 1;
              hold >>>= state.extra;
              bits -= state.extra;
              state.back += state.extra;
            }
            state.was = state.length;
            state.mode = zlib_inflate.DIST;
          case zlib_inflate.DIST:
            for (; ; ) {
              here = state.distcode[hold & (1 << state.distbits) - 1];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if ((here_op & 240) === 0) {
              last_bits = here_bits;
              last_op = here_op;
              last_val = here_val;
              for (; ; ) {
                here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (last_bits + here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              hold >>>= last_bits;
              bits -= last_bits;
              state.back += last_bits;
            }
            hold >>>= here_bits;
            bits -= here_bits;
            state.back += here_bits;
            if (here_op & 64) {
              strm.msg = "invalid distance code";
              state.mode = zlib_inflate.BAD;
              break;
            }
            state.offset = here_val;
            state.extra = here_op & 15;
            state.mode = zlib_inflate.DISTEXT;
          case zlib_inflate.DISTEXT:
            if (state.extra) {
              n = state.extra;
              while (bits < n) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.offset += hold & (1 << state.extra) - 1;
              hold >>>= state.extra;
              bits -= state.extra;
              state.back += state.extra;
            }
            state.mode = zlib_inflate.MATCH;
          case zlib_inflate.MATCH:
            if (left === 0) {
              break inf_leave;
            }
            copy = _out - left;
            if (state.offset > copy) {
              copy = state.offset - copy;
              if (copy > state.whave) {
                if (state.sane) {
                  strm.msg = "invalid distance too far back";
                  state.mode = zlib_inflate.BAD;
                  break;
                }
              }
              if (copy > state.wnext) {
                copy -= state.wnext;
                from = state.wsize - copy;
              } else {
                from = state.wnext - copy;
              }
              if (copy > state.length) {
                copy = state.length;
              }
              from_source = state.window;
            } else {
              from_source = output;
              from = put - state.offset;
              copy = state.length;
            }
            if (copy > left) {
              copy = left;
            }
            left -= copy;
            state.length -= copy;
            do {
              output[put++] = from_source[from++];
            } while (--copy);
            if (state.length === 0) {
              state.mode = zlib_inflate.LEN;
            }
            break;
          case zlib_inflate.LIT:
            if (left === 0) {
              break inf_leave;
            }
            output[put++] = state.length;
            left--;
            state.mode = zlib_inflate.LEN;
            break;
          case zlib_inflate.CHECK:
            if (state.wrap) {
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold |= input[next++] << bits;
                bits += 8;
              }
              _out -= left;
              strm.total_out += _out;
              state.total += _out;
              if (_out) {
                strm.adler = state.check = state.flags ? zlib_crc32.crc32(state.check, output, _out, put - _out) : zlib_adler32.adler32(state.check, output, _out, put - _out);
              }
              _out = left;
              if ((state.flags ? hold : zlib_inflate.zswap32(hold)) !== state.check) {
                strm.msg = "incorrect data check";
                state.mode = zlib_inflate.BAD;
                break;
              }
              hold = 0;
              bits = 0;
            }
            state.mode = zlib_inflate.LENGTH;
          case zlib_inflate.LENGTH:
            if (state.wrap && state.flags) {
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (hold !== (state.total & 4294967295)) {
                strm.msg = "incorrect length check";
                state.mode = zlib_inflate.BAD;
                break;
              }
              hold = 0;
              bits = 0;
            }
            state.mode = zlib_inflate.DONE;
          case zlib_inflate.DONE:
            ret = zlib_constants.Z_STREAM_END;
            break inf_leave;
          case zlib_inflate.BAD:
            ret = zlib_constants.Z_DATA_ERROR;
            break inf_leave;
          case zlib_inflate.MEM:
            return zlib_constants.Z_MEM_ERROR;
          case zlib_inflate.SYNC:
          default:
            return zlib_constants.Z_STREAM_ERROR;
        }
      }
    strm.next_out = put;
    strm.avail_out = left;
    strm.next_in = next;
    strm.avail_in = have;
    state.hold = hold;
    state.bits = bits;
    if (state.wsize || _out !== strm.avail_out && state.mode < zlib_inflate.BAD && (state.mode < zlib_inflate.CHECK || flush !== zlib_constants.Z_FINISH)) {
      if (zlib_inflate.updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) {
        state.mode = zlib_inflate.MEM;
        return zlib_constants.Z_MEM_ERROR;
      }
    }
    _in -= strm.avail_in;
    _out -= strm.avail_out;
    strm.total_in += _in;
    strm.total_out += _out;
    state.total += _out;
    if (state.wrap && _out) {
      strm.adler = state.check = state.flags ? zlib_crc32.crc32(state.check, output, _out, strm.next_out - _out) : zlib_adler32.adler32(state.check, output, _out, strm.next_out - _out);
    }
    strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === zlib_inflate.TYPE ? 128 : 0) + (state.mode === zlib_inflate.LEN_ || state.mode === zlib_inflate.COPY_ ? 256 : 0);
    if ((_in === 0 && _out === 0 || flush === zlib_constants.Z_FINISH) && ret === zlib_constants.Z_OK) {
      ret = zlib_constants.Z_BUF_ERROR;
    }
    return ret;
  }
  static inflateEnd(strm) {
    if (!strm || !strm.state) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    let state = strm.state;
    if (state.window) {
      state.window = null;
    }
    strm.state = null;
    return zlib_constants.Z_OK;
  }
  static inflateGetHeader(strm, head) {
    if (!strm || !strm.state) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    let state = strm.state;
    if ((state.wrap & 2) === 0) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    state.head = head;
    head.done = false;
    return zlib_constants.Z_OK;
  }
  static inflateSetDictionary(strm, dictionary) {
    const dictLength = dictionary.length;
    let state;
    let dictid;
    let ret;
    if (!strm || !strm.state) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    state = strm.state;
    if (state.wrap !== 0 && state.mode !== zlib_inflate.DICT) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    if (state.mode === zlib_inflate.DICT) {
      dictid = 1;
      dictid = zlib_adler32.adler32(dictid, dictionary, dictLength, 0);
      if (dictid !== state.check) {
        return zlib_constants.Z_DATA_ERROR;
      }
    }
    ret = zlib_inflate.updatewindow(strm, dictionary, dictLength, dictLength);
    if (ret) {
      state.mode = zlib_inflate.MEM;
      return zlib_constants.Z_MEM_ERROR;
    }
    state.havedict = 1;
    return zlib_constants.Z_OK;
  }
};
zlib_inflate.CODES = 0;
zlib_inflate.LENS = 1;
zlib_inflate.DISTS = 2;
zlib_inflate.HEAD = 1;
zlib_inflate.FLAGS = 2;
zlib_inflate.TIME = 3;
zlib_inflate.OS = 4;
zlib_inflate.EXLEN = 5;
zlib_inflate.EXTRA = 6;
zlib_inflate.NAME = 7;
zlib_inflate.COMMENT = 8;
zlib_inflate.HCRC = 9;
zlib_inflate.DICTID = 10;
zlib_inflate.DICT = 11;
zlib_inflate.TYPE = 12;
zlib_inflate.TYPEDO = 13;
zlib_inflate.STORED = 14;
zlib_inflate.COPY_ = 15;
zlib_inflate.COPY = 16;
zlib_inflate.TABLE = 17;
zlib_inflate.LENLENS = 18;
zlib_inflate.CODELENS = 19;
zlib_inflate.LEN_ = 20;
zlib_inflate.LEN = 21;
zlib_inflate.LENEXT = 22;
zlib_inflate.DIST = 23;
zlib_inflate.DISTEXT = 24;
zlib_inflate.MATCH = 25;
zlib_inflate.LIT = 26;
zlib_inflate.CHECK = 27;
zlib_inflate.LENGTH = 28;
zlib_inflate.DONE = 29;
zlib_inflate.BAD = 30;
zlib_inflate.MEM = 31;
zlib_inflate.SYNC = 32;
zlib_inflate.ENOUGH_LENS = 852;
zlib_inflate.ENOUGH_DISTS = 592;
zlib_inflate.MAX_WBITS = 15;
zlib_inflate.DEF_WBITS = zlib_inflate.MAX_WBITS;
zlib_inflate.virgin = true;

// obj/full/Pako/zlib/messages.js
"use strict";
var zlib_messages = class {
  static msg(index) {
    switch (index) {
      case 2:
        return "need dictionary";
      case 1:
        return "stream end";
      case 0:
        return "";
      case -1:
        return "file error";
      case -2:
        return "stream error";
      case -3:
        return "data error";
      case -4:
        return "insufficient memory";
      case -5:
        return "buffer error";
      case -6:
        return "incompatible version";
      default:
        return "unknowwn error";
    }
  }
};

// obj/full/Pako/zlib/inftrees.js
"use strict";
var zlib_inftrees = class {
  static inflate_table(type, lens, lens_index, codes, table, table_index, work, opts) {
    const bits = opts.bits;
    let len;
    let sym;
    let min = 0;
    let max;
    let root;
    let curr = 0;
    let drop = 0;
    let left = 0;
    let used = 0;
    let huff = 0;
    let incr;
    let fill;
    let low;
    let mask;
    let next;
    let base;
    let base_index = 0;
    let end;
    const count = new Uint16Array(zlib_inftrees.MAXBITS + 1);
    const offs = new Uint16Array(zlib_inftrees.MAXBITS + 1);
    let extra;
    let extra_index = 0;
    let here_bits;
    let here_op;
    let here_val;
    for (len = 0; len <= zlib_inftrees.MAXBITS; len++) {
      count[len] = 0;
    }
    for (sym = 0; sym < codes; sym++) {
      count[lens[lens_index + sym]]++;
    }
    root = bits;
    for (max = zlib_inftrees.MAXBITS; max >= 1; max--) {
      if (count[max] !== 0) {
        break;
      }
    }
    if (root > max) {
      root = max;
    }
    if (max === 0) {
      table[table_index++] = 1 << 24 | 64 << 16 | 0;
      table[table_index++] = 1 << 24 | 64 << 16 | 0;
      opts.bits = 1;
      return 0;
    }
    for (min = 1; min < max; min++) {
      if (count[min] !== 0) {
        break;
      }
    }
    if (root < min) {
      root = min;
    }
    left = 1;
    for (len = 1; len <= zlib_inftrees.MAXBITS; len++) {
      left <<= 1;
      left -= count[len];
      if (left < 0) {
        return -1;
      }
    }
    if (left > 0 && (type === zlib_inftrees.CODES || max !== 1)) {
      return -1;
    }
    offs[1] = 0;
    for (len = 1; len < zlib_inftrees.MAXBITS; len++) {
      offs[len + 1] = offs[len] + count[len];
    }
    for (sym = 0; sym < codes; sym++) {
      if (lens[lens_index + sym] !== 0) {
        work[offs[lens[lens_index + sym]]++] = sym;
      }
    }
    if (type === zlib_inftrees.CODES) {
      base = work;
      extra = new Uint8Array();
      end = 19;
    } else if (type === zlib_inftrees.LENS) {
      base = zlib_inftrees.lbase;
      base_index -= 257;
      extra = zlib_inftrees.lext;
      extra_index -= 257;
      end = 256;
    } else {
      base = zlib_inftrees.dbase;
      extra = zlib_inftrees.dext;
      end = -1;
    }
    huff = 0;
    sym = 0;
    len = min;
    next = table_index;
    curr = root;
    drop = 0;
    low = -1;
    used = 1 << root;
    mask = used - 1;
    if (type === zlib_inftrees.LENS && used > zlib_inftrees.ENOUGH_LENS || type === zlib_inftrees.DISTS && used > zlib_inftrees.ENOUGH_DISTS) {
      return 1;
    }
    for (; ; ) {
      here_bits = len - drop;
      if (work[sym] < end) {
        here_op = 0;
        here_val = work[sym];
      } else if (work[sym] > end) {
        here_op = extra[extra_index + work[sym]];
        here_val = base[base_index + work[sym]];
      } else {
        here_op = 32 + 64;
        here_val = 0;
      }
      incr = 1 << len - drop;
      fill = 1 << curr;
      min = fill;
      do {
        fill -= incr;
        table[next + (huff >> drop) + fill] = here_bits << 24 | here_op << 16 | here_val | 0;
      } while (fill !== 0);
      incr = 1 << len - 1;
      while (huff & incr) {
        incr >>= 1;
      }
      if (incr !== 0) {
        huff &= incr - 1;
        huff += incr;
      } else {
        huff = 0;
      }
      sym++;
      if (--count[len] === 0) {
        if (len === max) {
          break;
        }
        len = lens[lens_index + work[sym]];
      }
      if (len > root && (huff & mask) !== low) {
        if (drop === 0) {
          drop = root;
        }
        next += min;
        curr = len - drop;
        left = 1 << curr;
        while (curr + drop < max) {
          left -= count[curr + drop];
          if (left <= 0) {
            break;
          }
          curr++;
          left <<= 1;
        }
        used += 1 << curr;
        if (type === zlib_inftrees.LENS && used > zlib_inftrees.ENOUGH_LENS || type === zlib_inftrees.DISTS && used > zlib_inftrees.ENOUGH_DISTS) {
          return 1;
        }
        low = huff & mask;
        table[low] = root << 24 | curr << 16 | next - table_index | 0;
      }
    }
    if (huff !== 0) {
      table[next + huff] = len - drop << 24 | 64 << 16 | 0;
    }
    opts.bits = root;
    return 0;
  }
};
zlib_inftrees.MAXBITS = 15;
zlib_inftrees.ENOUGH_LENS = 852;
zlib_inftrees.ENOUGH_DISTS = 592;
zlib_inftrees.CODES = 0;
zlib_inftrees.LENS = 1;
zlib_inftrees.DISTS = 2;
zlib_inftrees.lbase = new Uint16Array([
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  13,
  15,
  17,
  19,
  23,
  27,
  31,
  35,
  43,
  51,
  59,
  67,
  83,
  99,
  115,
  131,
  163,
  195,
  227,
  258,
  0,
  0
]);
zlib_inftrees.lext = new Uint8Array([
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  17,
  17,
  17,
  17,
  18,
  18,
  18,
  18,
  19,
  19,
  19,
  19,
  20,
  20,
  20,
  20,
  21,
  21,
  21,
  21,
  16,
  72,
  78
]);
zlib_inftrees.dbase = new Uint16Array([
  1,
  2,
  3,
  4,
  5,
  7,
  9,
  13,
  17,
  25,
  33,
  49,
  65,
  97,
  129,
  193,
  257,
  385,
  513,
  769,
  1025,
  1537,
  2049,
  3073,
  4097,
  6145,
  8193,
  12289,
  16385,
  24577,
  0,
  0
]);
zlib_inftrees.dext = new Uint8Array([
  16,
  16,
  16,
  16,
  17,
  17,
  18,
  18,
  19,
  19,
  20,
  20,
  21,
  21,
  22,
  22,
  23,
  23,
  24,
  24,
  25,
  25,
  26,
  26,
  27,
  27,
  28,
  28,
  29,
  29,
  64,
  64
]);

// obj/full/Pako/zlib/zstream.js
"use strict";
var zlib_ZStream = class {
  constructor() {
    this.input = null;
    this.next_in = 0;
    this.avail_in = 0;
    this.total_in = 0;
    this.output = null;
    this.next_out = 0;
    this.avail_out = 0;
    this.total_out = 0;
    this.msg = "";
    this.state = null;
    this.data_type = 2;
    this.adler = 0;
  }
};

// obj/full/webPage.js
var YWebPage = class {
  edit(widgetIndex) {
    YWebPage.widgets[widgetIndex].edit();
  }
  static get editMenuItem() {
    return YWebPage._editMenuItem;
  }
  static get deleteMenuItem() {
    return YWebPage._deleteMenuItem;
  }
  static get disableMarkerMenuItem() {
    return YWebPage._disableMarkerMenuItem;
  }
  static get clearDataloggerMenuItem() {
    return YWebPage._clearDataloggerMenuItem;
  }
  static get addMarkerMenuItem() {
    return YWebPage._addMarkerMenuItem;
  }
  static get markersSubMenuItems() {
    return YWebPage._markersSubMenuItems;
  }
  static get contextMarkerSubMenu() {
    return YWebPage._contextMarkerSubMenu;
  }
  static get contextWidgetsSubMenu() {
    return YWebPage._contextWidgetsSubMenu;
  }
  static get resetDataViewMenuItem() {
    return YWebPage._resetDataViewMenuItem;
  }
  static get snapshotMenuItem() {
    return YWebPage._snapshotMenuItem;
  }
  static applicationGlobalinit() {
    if (YWebPage._MarkerCountPerXaxis == 0) {
      let xAxisProp = new XaxisDescription();
      let propDesc = GenericProperties.getAllProperties(xAxisProp);
      for (let propname in propDesc.byName) {
        if (propname.startsWith("markers"))
          YWebPage._MarkerCountPerXaxis++;
      }
    }
    if (YWebPage.manager == null)
      YWebPage.manager = new sensorsManager();
    if (!YWebPage.readonly && YWebPage._editor == null)
      YWebPage._editor = new PropertiesForm2();
    if (!YWebPage.readonly && YWebPage._mainform == null)
      YWebPage._mainform = new mainForm();
    if (YWebPage._contextMenu == null) {
      YWebPage._contextMenu = new ContextMenu(YWebPage.baseSize, (mouseX, mouseY) => {
        YWebPage.menuIsOpening(mouseX, mouseY);
      }, constants.generalFontFamily);
      YWebPage._contextMarkerSubMenu = new ContextSubMenu(YWebPage.baseSize, YWebPage._contextMenu, null, constants.generalFontFamily);
      for (let i = 0; i < YWebPage._MarkerCountPerXaxis; i++) {
        YWebPage._markersSubMenuItems.push(YWebPage._contextMarkerSubMenu.addMenuItem(ressources.AddMarkerIcon(YWebPage.baseSize.toString(), i + 1), "Place marker " + (i + 1).toString(), () => {
          let target = YWebPage._markersSubMenuItems[i].userdata;
          target.startMarkerCapture(i);
        }));
      }
      if (!YWebPage.readonly) {
        YWebPage._contextWidgetsSubMenu = new ContextSubMenu(YWebPage.baseSize, YWebPage._contextMenu, (mouseX, mouseY) => {
          YWebPage.WidgetsSubMenuIsOpening(mouseX, mouseY);
        }, constants.generalFontFamily);
        YWebPage._widgetsMenuItem = YWebPage._contextMenu.addSubMenuItem(ressources.AllIcon(YWebPage.baseSize.toString(), false, false, false, false), "All widgets", YWebPage._contextWidgetsSubMenu);
        YWebPage._editMenuItem = YWebPage._contextMenu.addMenuItem(ressources.EditIcon(YWebPage.baseSize.toString(), false, false, false, false), "Configure this widget", () => {
          YWebPage.editWidget();
        });
        YWebPage._deleteMenuItem = YWebPage._contextMenu.addMenuItem(ressources.TrashIcon(YWebPage.baseSize.toString(), false, false, false, false), "Delete this widget", () => {
          YWebPage.deleteWidget();
        });
        YWebPage._editMenuItem.visible = false;
        YWebPage._deleteMenuItem.visible = false;
      }
      YWebPage._resetDataViewMenuItem = YWebPage._contextMenu.addMenuItem(ressources.resetViewPort(YWebPage.baseSize.toString(), false, false, false, false), "Reset dataview", () => {
        YWebPage.resetDataView();
      });
      YWebPage._resetDataViewMenuItem.visible = false;
      if (!YWebPage.readonly) {
        YWebPage._clearDataloggerMenuItem = YWebPage._contextMenu.addMenuItem(ressources.EraseDatalogger(YWebPage.baseSize.toString(), false, false, false, false), "Clear datalogger", () => {
          YWebPage.clearDatalogger();
        });
        YWebPage._resetDataViewMenuItem.visible = false;
      }
      YWebPage._contextMenu.AddSeparator();
      if (!YWebPage.readonly) {
        YWebPage._addMarkerMenuItem = YWebPage._contextMenu.addSubMenuItem(ressources.AddMarker(YWebPage.baseSize.toString(), false, true, true, false), "Place markers", YWebPage._contextMarkerSubMenu);
        YWebPage._disableMarkerMenuItem = YWebPage._contextMenu.addMenuItem(ressources.DeleteMarker(YWebPage.baseSize.toString(), false, true, false, true), "Disable Allmarkers", () => {
          YWebPage.disableAllMarker();
        });
        YWebPage._addMarkerMenuItem.visible = false;
        YWebPage._disableMarkerMenuItem.visible = false;
        YWebPage._contextMenu.AddSeparator();
        YWebPage._contextMenu.addMenuItem(ressources.SolidGaugeIcon(YWebPage.baseSize.toString(), false, true, true, false), "Add a new Solid gauge", () => {
          YWebPage.newGaugeWidget();
        });
        YWebPage._contextMenu.addMenuItem(ressources.AngularGaugeIcon(YWebPage.baseSize.toString(), false, true, true, false), "Add a new Angular gauge", () => {
          YWebPage.newAngularGaugeWidget();
        });
        YWebPage._contextMenu.addMenuItem(ressources.DigitalDisplayIcon(YWebPage.baseSize.toString(), false, true, true, false), "Add a new Digital Display", () => {
          YWebPage.newDigitalDisplayWidget();
        });
        YWebPage._contextMenu.addMenuItem(ressources.GraphIcon(YWebPage.baseSize.toString(), false, true, true, false), "Add a new Graph", () => {
          YWebPage.newGraphWidget();
        });
      }
      YWebPage._contextMenu.addMenuItem(ressources.RawDataIcon(YWebPage.baseSize.toString(), false, false, false, false), "Show raw data", () => {
        rawDataForm.show();
      });
      YWebPage._snapshotMenuItem = YWebPage._contextMenu.addMenuItem(ressources.snapshotIcon(YWebPage.baseSize.toString(), false, false, false, false), "Snapshot", () => {
        YWebPage.snapShot();
      });
      if (!YWebPage.readonly) {
        YWebPage._contextMenu.AddSeparator();
        YWebPage._contextMenu.addMenuItem(ressources.ConfigureIcon(YWebPage.baseSize.toString(), false, false, false, false), "Global configuration", () => {
          configForm.show();
        });
        YWebPage._contextMenu.addMenuItem(ressources.SaveIcon(YWebPage.baseSize.toString(), false, false, false, false), "Save now", () => {
          YWebPage.save(true);
        });
      }
      YWebPage._contextMenu.addMenuItem(ressources.LogFileIcon(YWebPage.baseSize.toString(), false, false, false, false), "Show logs", () => {
        YWebPage.showLogsWindow();
      });
    }
  }
  static WidgetsSubMenuIsOpening(mouseX, mouseY) {
    YWebPage._contextWidgetsSubMenu.clearAllContents();
    for (let i = 0; i < YWebPage.widgets.length; i++) {
      let icon = "";
      let subMenu = new ContextSubMenu(YWebPage.baseSize, YWebPage._contextWidgetsSubMenu, (mouseX2, mouseY2) => {
        YWebPage.specificWidgetSubMenuIsOpening(subMenu, mouseX2, mouseY2);
      }, constants.generalFontFamily);
      subMenu.userdata = YWebPage.widgets[i];
      if (YWebPage.widgets[i] instanceof graphWidget)
        icon = ressources.GraphIcon(YWebPage.baseSize.toString(), false, false, false, false);
      if (YWebPage.widgets[i] instanceof digitalDisplayWidget)
        icon = ressources.DigitalDisplayIcon(YWebPage.baseSize.toString(), false, false, false, false);
      if (YWebPage.widgets[i] instanceof gaugeWidget)
        icon = ressources.SolidGaugeIcon(YWebPage.baseSize.toString(), false, false, false, false);
      if (YWebPage.widgets[i] instanceof angularGaugeWidget)
        icon = ressources.AngularGaugeIcon(YWebPage.baseSize.toString(), false, false, false, false);
      YWebPage._contextWidgetsSubMenu.addSubMenuItem(icon, YWebPage.widgets[i].Text, subMenu);
    }
  }
  static specificWidgetSubMenuIsOpening(source, mouseX, mouseY) {
    if (source.menuItemsCount > 0)
      return;
    let w = source.userdata;
    source.addMenuItem(ressources.EditIcon(YWebPage.baseSize.toString(), false, false, false, false), "Configure", () => {
      w.edit();
    });
    source.addMenuItem(ressources.TrashIcon(YWebPage.baseSize.toString(), false, false, false, false), "Delete", () => {
      YWebPage.deleteWidget(w);
    });
    if (w instanceof graphWidget) {
      source.addMenuItem(ressources.resetViewPort(YWebPage.baseSize.toString(), false, false, false, false), "Reset dataview", () => {
        w.resetDataView();
      });
      source.addMenuItem(ressources.EraseDatalogger(YWebPage.baseSize.toString(), false, false, false, false), "Clear datalogger", () => {
        w.clearDataLogger();
      });
    }
  }
  static showLogsWindow() {
    logForm.show();
  }
  static snapShot() {
    let w = YWebPage._snapshotMenuItem.userdata;
    w.snapshot();
  }
  static menuIsOpening(mouseX, mouseY) {
    if (YWebPage.disableMarkerMenuItem != null)
      YWebPage.disableMarkerMenuItem.visible = false;
    if (YWebPage.addMarkerMenuItem != null)
      YWebPage.addMarkerMenuItem.visible = false;
    if (YWebPage.clearDataloggerMenuItem != null)
      YWebPage.clearDataloggerMenuItem.visible = false;
    if (YWebPage.editMenuItem != null)
      YWebPage.editMenuItem.visible = false;
    if (YWebPage.deleteMenuItem != null)
      YWebPage.deleteMenuItem.visible = false;
    YWebPage.resetDataViewMenuItem.visible = false;
    YWebPage.snapshotMenuItem.visible = false;
    for (let i = 0; i < YWebPage.widgets.length; i++) {
      YWebPage.widgets[i].contextMenuCallBack(mouseX, mouseY);
    }
    YWebPage._widgetsMenuItem.visible = !YWebPage.readonly && YWebPage.widgets.length > 0 && !YWebPage._editMenuItem.visible;
    YWebPage._contextMenu.refresh();
  }
  static resetDataView() {
    YWebPage._resetDataViewMenuItem.userdata.resetDataView();
  }
  static editWidget() {
    let w = YWebPage._editMenuItem.userdata;
    w.edit();
  }
  static disableAllMarker() {
    YWebPage._disableMarkerMenuItem.userdata.disableAllMarkers();
  }
  static clearDatalogger() {
    YWebPage._clearDataloggerMenuItem.userdata.clearDataLogger();
  }
  static deleteWidget(widget) {
    let w = typeof widget == "undefined" ? YWebPage._deleteMenuItem.userdata : widget;
    confirm.ask(w.confirmDeleteString, () => {
      if (!YWebPage.readonly && w.isBeingEdited && YWebPage._editor != null)
        YWebPage._editor.hide();
      w.delete();
      constants.edited = true;
      for (let i = YWebPage.widgets.length - 1; i >= 0; i--) {
        if (YWebPage.widgets[i] == w) {
          YWebPage.widgets.splice(i, 1);
        }
      }
      if (YWebPage.widgets.length <= 0 && YWebPage._mainform != null)
        YWebPage._mainform.show();
    }, null, null);
  }
  static FindUniqueNewName(prefix) {
    let n = 1;
    for (let i = 0; i < YWebPage.widgets.length; i++) {
      if (YWebPage.widgets[i].Text.startsWith(prefix))
        n++;
    }
    if (n > 1)
      prefix = prefix + " " + n.toString();
    return prefix;
  }
  static newGraphWidget() {
    let w = window.innerWidth / 2 >> 0;
    let h = window.innerHeight / 2 >> 0;
    if (w < 350)
      w = 350;
    if (h < 200)
      w = 200;
    let x = (window.innerWidth - w) / 2 >> 0;
    let y = (window.innerHeight - h) / 2 >> 0;
    let index = YWebPage.widgets.length;
    if (index > 0) {
      x = index * 25;
      y = index * 25;
    }
    let wdg = new graphWidget(null, YWebPage._editor, x, y, 765, 470);
    wdg.set_name(YWebPage.FindUniqueNewName("New Graph"));
    YWebPage.widgets.push(wdg);
    wdg.resize(w, h);
    if (this._mainform != null)
      this._mainform.hide();
    if (!YWebPage.readonly) {
      if (YWebPage._editor != null && YWebPage._editor.visible)
        wdg.edit();
    }
  }
  static newAngularGaugeWidget() {
    let s = Math.min(window.innerWidth, window.innerHeight) / 2;
    if (s < 350)
      s = 350;
    let x = (window.innerWidth - s) / 2 >> 0;
    let y = (window.innerHeight - s) / 2 >> 0;
    let w = s >> 0;
    let h = s >> 0;
    let index = YWebPage.widgets.length;
    if (index > 0) {
      x = index * 25;
      y = index * 25;
    }
    let wdg = new angularGaugeWidget(null, YWebPage._editor, x, y, 375, 300);
    wdg.set_name(YWebPage.FindUniqueNewName("New Angular Gauge"));
    YWebPage.widgets.push(wdg);
    wdg.resize(w, h);
    if (this._mainform != null)
      this._mainform.hide();
    if (!YWebPage.readonly) {
      if (YWebPage._editor != null && YWebPage._editor.visible)
        wdg.edit();
    }
  }
  static newGaugeWidget() {
    let s = Math.min(window.innerWidth, window.innerHeight) / 2;
    if (s < 350)
      s = 350;
    let x = (window.innerWidth - s) / 2 >> 0;
    let y = (window.innerHeight - s) / 2 >> 0;
    let w = s >> 0;
    let h = s >> 0;
    let index = YWebPage.widgets.length;
    if (index > 0) {
      x = index * 25;
      y = index * 25;
    }
    let wdg = new gaugeWidget(null, YWebPage._editor, x, y, 355, 201);
    wdg.set_name(YWebPage.FindUniqueNewName("New Solid Gauge"));
    YWebPage.widgets.push(wdg);
    wdg.resize(w, h);
    if (this._mainform != null)
      this._mainform.hide();
    if (!YWebPage.readonly) {
      if (YWebPage._editor != null && YWebPage._editor.visible)
        wdg.edit();
    }
  }
  static newDigitalDisplayWidget() {
    let s = Math.min(window.innerWidth, window.innerHeight) / 8;
    if (s < 90)
      s = 90;
    let x = (window.innerWidth - 4 * s) / 2 >> 0;
    let y = (window.innerHeight - s) / 2 >> 0;
    let w = 4 * s >> 0;
    let h = s >> 0;
    let index = YWebPage.widgets.length;
    if (index > 0) {
      x = index * 25;
      y = index * 25;
    }
    let wdg = new digitalDisplayWidget(null, YWebPage._editor, x, y, 410, 125);
    wdg.set_name(YWebPage.FindUniqueNewName("New Digital Display"));
    let n = 1;
    for (let i = 0; i < YWebPage.widgets.length; i++) {
      if (YWebPage.widgets[i].Text.startsWith(wdg.Text))
        n++;
    }
    if (n > 1)
      wdg.Text = wdg.Text + " " + n.toString();
    YWebPage.widgets.push(wdg);
    wdg.resize(w, h);
    if (this._mainform != null)
      this._mainform.hide();
    if (!YWebPage.readonly) {
      if (YWebPage._editor != null && YWebPage._editor.visible)
        wdg.edit();
    }
  }
  static refreshPropertiesForm() {
    if (!YWebPage.readonly && YWebPage._editor != null)
      YWebPage._editor.refresh();
  }
  static sensorListHaschanged() {
    YWebPage.refreshPropertiesForm();
  }
  static EmptyReadonlyConfig() {
    alert2.show("Yocto-Visualization Error\n\nConfiguration is both empty and read only, check configuration file.");
  }
  static async ForceReloadConfig(newXMLdata) {
    if (!YWebPage.readonly) {
      if (YWebPage._editor != null)
        YWebPage._editor.visible = false;
      configForm.hide();
      rawDataForm.hide();
      HubEdit.hide();
    }
    logForm.log("Reloading the whole configuration.");
    await sensorsManager.clearHublist();
    for (let i = YWebPage.widgets.length - 1; i >= 0; i--) {
      YWebPage.widgets[i].destroy();
      YWebPage.widgets.splice(i, 1);
    }
    YWebPage.loadFromXML(newXMLdata);
    constants.edited = false;
  }
  static ConfigChanged(newXMLdata) {
    if (YWebPage.ConfigChangedConfirmWindows != null) {
      YWebPage.ConfigChangedConfirmWindows.hide();
    }
    let newCRC = constants.crc32(newXMLdata);
    if (newCRC == YWebPage.xmlDataCRC)
      return;
    logForm.log("Config file changed behind our back!");
    if (!this.readonly) {
      YWebPage.ConfigChangedConfirmWindows = confirm.ask("Configuration has changed on server\nWould you like to reload it?", () => {
        YWebPage.ForceReloadConfig(newXMLdata);
        YWebPage.ConfigChangedConfirmWindows = null;
      }, () => {
        YWebPage.ConfigChangedConfirmWindows = null;
      }, null);
    } else {
      YWebPage.ForceReloadConfig(newXMLdata);
    }
    YWebPage.xmlDataCRC = newCRC;
    constants.edited = false;
  }
  static ShowSaveReminder(visible) {
    if (YWebPage.saveIntDiv == null) {
      YWebPage.saveIntDiv = document.createElement("DIV");
      YWebPage.saveIntDiv.style.position = "fixed";
      YWebPage.saveIntDiv.style.left = "5px";
      YWebPage.saveIntDiv.style.top = "5px";
      YWebPage.saveIntDiv.style.zIndex = "200000";
      YWebPage.saveIntDiv.style.cursor = "pointer";
      YWebPage.saveIntDiv.innerHTML = ressources.SaveNeededIcon((48 * constants.guiDPIFactor).toString(), false, false, false, false);
      YWebPage.saveIntDiv.addEventListener("click", () => {
        YWebPage.saveIntDiv.style.display = "none";
        YWebPage.save(true);
      });
      document.body.appendChild(YWebPage.saveIntDiv);
    }
    YWebPage.saveIntDiv.style.display = visible ? "" : "none";
  }
  static loadFromXML(xmlData) {
    if (xmlData == "") {
      if (!YWebPage.readonly && YWebPage._mainform != null) {
        YWebPage._mainform.show();
      } else {
        YWebPage.EmptyReadonlyConfig();
      }
      return;
    }
    let parser = new DOMParser();
    let doc = parser.parseFromString(xmlData.replace("<!-->", "<!-- "), "application/xml");
    let root = null;
    doc.childNodes.forEach((node) => {
      if (node.nodeName.toUpperCase() == "ROOT" && root == null)
        root = node;
    });
    if (root == null)
      throw "No ROOT top node in XML data";
    root.childNodes.forEach((node) => {
      if (node.nodeName.toUpperCase() == "SENSORS") {
        sensorsManager.setKnownSensors(new YXmlNode(node));
      }
    });
    root.childNodes.forEach((node) => {
      let editor = null;
      editor = YWebPage._editor;
      switch (node.nodeName.toUpperCase()) {
        case "CONFIG":
          constants.Init(new YXmlNode(node));
          break;
        case "GRAPHFORM":
          YWebPage.widgets.push(new graphWidget(new YXmlNode(node), editor));
          break;
        case "ANGULARGAUGEFORM":
          YWebPage.widgets.push(new angularGaugeWidget(new YXmlNode(node), editor));
          break;
        case "GAUGEFORM":
          YWebPage.widgets.push(new gaugeWidget(new YXmlNode(node), editor));
          break;
        case "DIGITALDISPLAYFORM":
          YWebPage.widgets.push(new digitalDisplayWidget(new YXmlNode(node), editor));
          break;
      }
      sensorsManager.registerChangeCallback(() => {
        YWebPage.sensorListHaschanged();
      });
      if (node.nodeName.toUpperCase() == "ROOT" && root == null)
        root = node;
    });
    if (YWebPage.widgets.length <= 0) {
      constants.edited = false;
      if (!YWebPage.readonly && YWebPage._mainform != null) {
        YWebPage._mainform.show();
      } else {
        YWebPage.EmptyReadonlyConfig();
      }
    } else if (!YWebPage.readonly && YWebPage._mainform != null)
      YWebPage._mainform.hide();
  }
  static AnimateNewVerwsionMessage(step) {
    YWebPage.NewVersionmessageDiv.style.left = Math.round(100 - step) + "%";
    if (step < 100) {
      step += 2;
      if (step > 100)
        step = 100;
      setTimeout(() => {
        YWebPage.AnimateNewVerwsionMessage(step);
      });
    }
  }
  static StartInstaller(roothub) {
    let installerDiv = document.createElement("DIV");
    installerDiv.style.position = "absolute";
    installerDiv.style.top = "50%";
    installerDiv.style.left = "50%";
    installerDiv.style.transform = "translate(-50%,-50%)";
    installerDiv.style.width = "550px";
    installerDiv.style.height = "380px";
    installerDiv.style.zIndex = YWebPage.getTopZIndex().toString();
    installerDiv.style.border = "1px solid black";
    installerDiv.style.boxShadow = "rgba(0, 0, 0, 0.05) 4px 4px 4px 1px";
    document.body.appendChild(installerDiv);
    let options = {};
    if (roothub != null)
      options = {
        protocol: roothub.protocol,
        addr: roothub.addr,
        port: parseInt(roothub.port),
        path: roothub.path,
        cancelable: true
      };
    window.startYV4W_installer(installerDiv, options);
  }
  static DownloadAndStartInstaller(installerURL, roothub, deleteTimer) {
    clearTimeout(deleteTimer);
    console.log("Downloading installer (" + installerURL + ")...");
    let P = document.createElement("P");
    P.style.textAlign = "center";
    P.style.fontFamily = constants.generalFontFamily;
    P.style.fontSize = "16px";
    P.innerHTML = "Downloading Installer<br>Please wait...";
    YWebPage.NewVersionmessageDiv.removeChild(YWebPage.NewVersionmessageDiv.firstChild);
    YWebPage.NewVersionmessageDiv.appendChild(P);
    let script = document.createElement("script");
    script.async = false;
    script.type = "module";
    script.onerror = (err) => {
      console.log("Failed to donwload installer (" + Event.toString() + ")");
      P.innerHTML = "Failed to download installer,<br>Check conole logs";
    };
    script.onload = () => {
      P.innerHTML = "Starting installer...";
      YWebPage.DeleteNewVersionMessage(100);
      YWebPage.StartInstaller(roothub);
    };
    document.body.appendChild(script);
    script.src = installerURL;
  }
  static DeleteNewVersionMessage(opacity) {
    opacity -= 5;
    if (opacity > 0) {
      YWebPage.NewVersionmessageDiv.style.opacity = (opacity / 100).toString();
      setTimeout(() => {
        YWebPage.DeleteNewVersionMessage(opacity);
      }, 100);
      return;
    }
    document.body.removeChild(YWebPage.NewVersionmessageDiv.parentNode);
  }
  static getTopZIndex() {
    var elems = document.getElementsByTagName("DIV");
    var highestZ = 0;
    for (var i = 0; i < elems.length; i++) {
      var z = Number.parseInt(window.getComputedStyle(elems[i], null).getPropertyValue("z-index"));
      if (z > highestZ)
        highestZ = z;
    }
    return highestZ + 1;
  }
  static async CheckForNewVersion(force) {
    if (!constants.mustCheckForUpdate && !force)
      return;
    let checkurl = location.protocol + "//www.yoctopuce.com/FR/common/getLastFirmwareLink.php?app=yoctovisualization4web.installer&version=" + constants.buildVersion + "&platform=_";
    let response;
    try {
      response = await fetch(checkurl);
    } catch (e) {
      return;
    }
    if (!response.ok)
      return;
    let json;
    try {
      json = await response.json();
    } catch (e) {
      return;
    }
    if (!(json instanceof Array))
      return;
    if (json.length <= 0)
      return;
    if (!("version" in json[0]))
      return;
    if (!("link" in json[0]))
      return;
    let newVersionInstallerURL = json[0]["link"];
    let newVersionNumber = parseInt(json[0]["version"]);
    let currentVersionStr = constants.buildVersion;
    let currentVersionNumber = 0;
    if (currentVersionStr.indexOf("-") < 0) {
      let n = currentVersionStr.lastIndexOf(".");
      if (n >= 0)
        currentVersionStr = currentVersionStr.substr(n + 1);
      currentVersionNumber = parseInt(currentVersionStr);
    }
    if (currentVersionNumber >= newVersionNumber)
      return;
    let generalSize = constants.generalFontSize;
    let NewVersionSizeX = generalSize * 24;
    let NewVersionSizeY = generalSize * 5;
    let containerDiv = document.createElement("DIV");
    containerDiv.style.position = "absolute";
    containerDiv.style.width = NewVersionSizeX + "px";
    containerDiv.style.height = NewVersionSizeY + "px";
    containerDiv.style.zIndex = YWebPage.getTopZIndex().toString();
    containerDiv.style.top = "5px";
    containerDiv.style.right = "0px";
    containerDiv.style.overflow = "hidden";
    document.body.appendChild(containerDiv);
    YWebPage.NewVersionmessageDiv = document.createElement("DIV");
    YWebPage.NewVersionmessageDiv.style.position = "absolute";
    YWebPage.NewVersionmessageDiv.style.width = NewVersionSizeX - 7 + "px";
    YWebPage.NewVersionmessageDiv.style.height = NewVersionSizeY - 2 + "px";
    YWebPage.NewVersionmessageDiv.style.backgroundColor = "GhostWhite";
    YWebPage.NewVersionmessageDiv.style.border = "1px solid dimgray";
    YWebPage.NewVersionmessageDiv.style.top = "0px";
    YWebPage.NewVersionmessageDiv.style.left = NewVersionSizeX + "px";
    let table = document.createElement("TABLE");
    table.style.fontFamily = constants.generalFontFamily;
    table.style.fontSize = generalSize + "px";
    let TR = document.createElement("TR");
    let TD1 = document.createElement("TD");
    TD1.style.paddingLeft = "5px";
    TD1.style.paddingRight = "10px";
    TD1.rowSpan = 2;
    TD1.style.verticalAlign = "middle";
    TD1.innerHTML = ressources.infoIcon((generalSize * 4).toString(), false, false, false, false, "information");
    TR.appendChild(TD1);
    let TD2 = document.createElement("TD");
    TD2.innerHTML = "A new Yocto-Visualization (for web)<br>version is available";
    TR.appendChild(TD2);
    table.appendChild(TR);
    TR = document.createElement("TR");
    TD2 = document.createElement("TD");
    TD2.style.textAlign = "right";
    TD2.style.verticalAlign = "bottom";
    let hubList = sensorsManager.hubList;
    let rootHub = null;
    for (let i = 0; i < hubList.length; i++) {
      if (!hubList[i].removable)
        rootHub = hubList[i];
    }
    let a = document.createElement("A");
    let deleteTimer = setTimeout(() => {
      YWebPage.DeleteNewVersionMessage(100);
    }, 5e3);
    a.style.fontSize = "12px";
    a.style.color = " #0000EE";
    a.style.textDecoration = "underline";
    a.style.cursor = "pointer";
    a.style.fontFamily = constants.generalFontFamily;
    a.style.fontSize = generalSize + "px";
    if (rootHub != null) {
      a.innerText = "Download and start installer..";
      a.addEventListener("click", () => {
        YWebPage.DownloadAndStartInstaller(newVersionInstallerURL, rootHub, deleteTimer);
      });
    } else {
      a.innerText = "www.yoctopuce.com";
      a.addEventListener("click", () => {
        window.location.assign("http://www.yoctopuce.com/EN/tools.php");
      });
    }
    TD2.appendChild(a);
    TR.appendChild(TD2);
    table.appendChild(TR);
    YWebPage.NewVersionmessageDiv.appendChild(table);
    containerDiv.appendChild(YWebPage.NewVersionmessageDiv);
    YWebPage.AnimateNewVerwsionMessage(0);
  }
  static run(xmlData, ExternalConfigChange, saveFunction) {
    if (typeof ExternalConfigChange !== "undefined") {
      if (ExternalConfigChange != null) {
        sensorsManager.registerChangeExternalCallback(ExternalConfigChange);
      }
    }
    YWebPage.xmlDataCRC = constants.crc32(xmlData);
    if (typeof saveFunction !== "undefined")
      YWebPage._saveFunction = saveFunction;
    logForm.log("Application start, Welcome to Yocto-Visualization (for web).");
    logForm.log("This application contains code ported from the Pako library (www.github.com/nodeca/pako).");
    logForm.log("Yocto-Visualization version is " + constants.buildVersion);
    logForm.log("Yoctopuce API version is " + YAPI.imm_GetAPIVersion());
    if (constants.RunningOnAndroid)
      logForm.log("Browser is running on Android");
    let widthCm = Math.round(2.54 * constants.deviceScreenWidth / constants.screenDPI);
    let heightCm = Math.round(2.54 * constants.deviceScreenHeight / constants.screenDPI);
    logForm.log("Reported screen size is " + constants.deviceScreenWidth.toString() + "x" + constants.deviceScreenHeight.toString() + " at " + constants.screenDPI + " dpi, (~" + widthCm.toString() + "x" + heightCm.toString() + "cm) ");
    logForm.log("Reported pixel ratio is " + window.devicePixelRatio.toString());
    logForm.log(constants.isPhoneOrTablet ? "Probably running on a tablet or a phone." : "Probably running on a desktop.");
    logForm.log((constants.guiDPIFactorWasOverriden ? "DPI based zoom overridden  to " : "DPI based zoom factor set to ") + constants.guiDPIFactor.toFixed(1));
    logForm.log("Reported window inner size =" + window.innerWidth.toString() + "x" + window.innerHeight.toString() + "px");
    YWebPage.applicationGlobalinit();
    sensorsManager.run();
    YWebPage.loadFromXML(xmlData);
    constants.edited = false;
    YWebPage.CheckForNewVersion(false);
  }
  static async pageIsleaving(e) {
    if (!e.persistent) {
      if (constants.edited) {
        await YWebPage.save(false);
        await YAPI.FreeAPI();
      }
    }
  }
  static refreshEditor() {
    if (YWebPage.readonly)
      return;
    if (YWebPage._editor == null)
      return;
    YWebPage._editor.refresh();
  }
  static EditObject(widget, structData, setvalueCallBack, getvalueCallBack, EditStoppedCallBack) {
    if (YWebPage.readonly)
      return;
    if (YWebPage._editor == null)
      return;
    YWebPage._editor.showWindow(widget, structData, setvalueCallBack, getvalueCallBack, EditStoppedCallBack);
  }
  static get_XmlData() {
    let XmlConfigFile = `<?xml version="1.0" ?>
<!--
   **************************************************
   Yocto-Visualization (for web)  configuration file
   **************************************************
-->
<ROOT version='2.1'>
<!-- in 2.1 version, floating point values are saved in CultureInfo.InvariantCulture form -->
`;
    XmlConfigFile += constants.GetXMLConfiguration();
    for (let i = 0; i < YWebPage.widgets.length; i++) {
      if (YWebPage.widgets[i] instanceof graphWidget)
        XmlConfigFile += YWebPage.widgets[i].getConfigData();
      if (YWebPage.widgets[i] instanceof angularGaugeWidget)
        XmlConfigFile += YWebPage.widgets[i].getConfigData();
      if (YWebPage.widgets[i] instanceof gaugeWidget)
        XmlConfigFile += YWebPage.widgets[i].getConfigData();
      if (YWebPage.widgets[i] instanceof digitalDisplayWidget)
        XmlConfigFile += YWebPage.widgets[i].getConfigData();
    }
    XmlConfigFile += sensorsManager.getXMLSensorsConfig();
    XmlConfigFile += "</ROOT>\n";
    return XmlConfigFile;
  }
  static get readonly() {
    let res = true;
    res = YWebPage._saveFunction == null;
    return res;
  }
  static async runInternalTest() {
  }
  static async save(force) {
    if (YWebPage.readonly)
      return true;
    let xml = this.get_XmlData();
    let newCRC = constants.crc32(xml);
    if (!force && newCRC == YWebPage.xmlDataCRC)
      return true;
    let saveDoneCallback = (ok, message) => {
      let div = document.createElement("DIV");
      div.style.position = "Fixed";
      div.style.left = "5px";
      div.style.top = "5px";
      div.style.padding = "2px 5px 2px 5px";
      div.style.margin = "2px 2px 2px 2px";
      div.style.border = "1px solid darkgreen";
      div.style.fontFamily = "Arial";
      div.style.fontSize = (12 * constants.guiDPIFactor).toString();
      div.style.whiteSpace = "nowrap";
      div.style.zIndex = "200000";
      div.style.textAlign = "center";
      div.style.opacity = "1";
      let fgcolor = ok ? "darkgreen" : "darkred";
      let bgcolor = ok ? "#b9eea9" : "#eea9a9";
      div.style.opacity = "1";
      div.style.backgroundColor = bgcolor;
      div.style.border = "1px solid " + fgcolor;
      div.style.color = fgcolor;
      div.innerText = message;
      document.body.appendChild(div);
      setTimeout(() => {
        YWebPage.handleSavedNotification(div);
      }, 100);
    };
    try {
      if (YWebPage._saveFunction != null) {
        return await YWebPage._saveFunction(this.get_XmlData(), saveDoneCallback);
      }
    } catch (e) {
      saveDoneCallback(false, "Save failed");
      alert2.show("Configuration save failed, sorry\n" + e.message);
      return false;
    }
    YWebPage.xmlDataCRC = newCRC;
    logForm.log("Configuration saved.");
    constants.edited = false;
    return true;
  }
  static handleSavedNotification(div) {
    let opacity = parseFloat(div.style.opacity) - 0.05;
    if (opacity < 0) {
      document.body.removeChild(div);
      return;
    }
    div.style.opacity = opacity.toString();
    setTimeout(() => {
      YWebPage.handleSavedNotification(div);
    }, 100);
  }
  static Dummysave(xml) {
    let contents = document.createElement("PRE");
    contents.innerText = xml;
    document.body.appendChild(contents);
    return true;
  }
};
YWebPage.baseSize = 18 * constants.generalSizeCoef;
YWebPage.xmlDataCRC = 0;
YWebPage.widgets = [];
YWebPage._markersSubMenuItems = [];
YWebPage._editor = null;
YWebPage._mainform = null;
YWebPage._saveFunction = null;
YWebPage._MarkerCountPerXaxis = 0;
YWebPage.ConfigChangedConfirmWindows = null;
YWebPage.saveIntDiv = null;
var HTTPrequestResult = class {
  constructor(data, status, statusText) {
    this._data = data;
    this._status = status;
    this._statusText = statusText;
  }
  get data() {
    return this._data;
  }
  get status() {
    return this._status;
  }
  get statusText() {
    return this._statusText;
  }
};
var HubInfo = class {
  constructor(protocol, addr, port, path, srvusername, srvpassword) {
    this._userPassword = false;
    this._adminPassword = false;
    this._cred = "";
    this._serial = "";
    this._srvusername = null;
    this._srvpassword = null;
    if (protocol.slice(-1) == ":")
      protocol = protocol.slice(0, -1);
    this._protocol = protocol;
    this._addr = addr;
    this._port = port;
    this._protocol = protocol;
    this._path = path;
    if (srvusername !== void 0)
      this._srvusername = srvusername;
    if (srvpassword !== void 0)
      this._srvpassword = srvpassword;
    if (this._path != "") {
      if (this._path.charAt(0) == "/") {
        this._path = this._path.slice(1);
      }
    }
    if (this._path != "") {
      if (this._path.slice(-1) == "/") {
        this._path = this._path.slice(0, -1);
      }
    }
  }
  get protocol() {
    return this._protocol;
  }
  get addr() {
    return this._addr;
  }
  get port() {
    return this._port;
  }
  get path() {
    return this._path;
  }
  get userPassword() {
    return this._userPassword;
  }
  get adminPassword() {
    return this._adminPassword;
  }
  get serial() {
    return this._serial;
  }
  get srvUsername() {
    return this._srvusername != null ? this._srvusername : "";
  }
  get srvPassword() {
    return this._srvpassword != null ? this._srvpassword : "";
  }
  get_hubUrl(user, password) {
    let url = this.protocol + "://";
    if (typeof user != "undefined" && user != "") {
      if (user != "") {
        url += user + ":" + password + "@";
      }
    }
    url += this.addr + ":" + this.port.toString();
    if (this.path != "")
      url += "/" + this.path;
    return url;
  }
  async makeRequest() {
    let url = this._protocol + "://" + this._addr + ":" + this._port.toString();
    if (this._path != "")
      url += "/" + this._path;
    url += "/info.json";
    let response;
    try {
      response = await fetch(url, {mode: "cors"});
    } catch (e) {
      return -3;
    }
    if (response.ok) {
      let HubData;
      try {
        HubData = await response.json();
      } catch (e) {
        return -1;
      }
      if (HubData.port && HubData.port.length > 0) {
        let proto_port = HubData.port[0].split(":");
        this._protocol = proto_port[0];
        this._port = parseInt(proto_port[1]);
      }
      this._serial = HubData.serialNumber;
      this._path = HubData.dir;
      this._adminPassword = HubData.adminPassword.toUpperCase() == "TRUE";
      this._userPassword = HubData.userPassword.toUpperCase() == "TRUE";
      return true;
    }
    if (response.status == 404 && this._path != "")
      return -2;
    if (response.status == 0 && response.statusText == null)
      return -3;
    return response.status;
  }
  findChild(parent, name) {
    let res = null;
    parent.childNodes.forEach((node) => {
      if (node.nodeName == name) {
        res = node;
        return;
      }
    });
    return res;
  }
  findOutCredentialsFromConfigFile(xmlData) {
    if (xmlData == null)
      return;
    let parser = new DOMParser();
    let doc = parser.parseFromString(xmlData, "application/xml");
    let rootNode = this.findChild(doc, "ROOT");
    if (rootNode == null)
      return;
    let configNode = this.findChild(rootNode, "Config");
    if (configNode == null)
      return;
    let Hubs = this.findChild(configNode, "Hubs");
    if (Hubs == null)
      return;
    let HubSection;
    let list = Hubs.childNodes;
    let sourceHubFound = false;
    for (let i = 0; i < list.length; i++) {
      if (list[i].nodeName == "Hub") {
        let node = new YXmlNode(list[i]);
        let attributes = node.Attributes;
        let addr = attributes.hasOwnProperty("addr") ? attributes["addr"] : "";
        let port = attributes.hasOwnProperty("port") ? attributes["port"] : "80";
        let protocol = attributes.hasOwnProperty("protocol") ? attributes["protocol"] : "";
        let path = attributes.hasOwnProperty("path") ? attributes["path"] : "";
        let username = attributes.hasOwnProperty("user") ? attributes["user"] : "";
        let password = attributes.hasOwnProperty("password") ? attributes["password"] : "";
        let a1 = addr.toUpperCase();
        if (a1.substring(0, 4) == "WWW.")
          a1 = a1.substring(4);
        let a2 = this._addr.toUpperCase();
        if (a2.substring(0, 4) == "WWW.")
          a2 = a2.substring(4);
        if (a1 == a2 && path == this._path) {
          this._srvusername = username;
          this._srvpassword = Hub.Decrypt(password, Hub.loginCypherPassword);
        }
      }
    }
  }
};
var YoctoHubFileHandler = class {
  constructor(hubInfo) {
    this.filename = "";
    this.xmldata = "";
    this.htmlSrcCode = "";
    this.FileSystemAccessDenied = false;
    this._XMLConfigFileChanged = null;
    this.fileSystem = null;
    this.fileSystemReady = false;
    this.configFileCRC = -1;
    this.info = hubInfo;
  }
  async init(defaultXmlConfigFileContents) {
    let url = location.href;
    this.filename = url.substring(url.lastIndexOf("/") + 1);
    let p = this.filename.indexOf("?");
    if (p > 0)
      this.filename = this.filename.substring(0, p);
    this.htmlSrcCode = document.documentElement.outerHTML;
    if (typeof defaultXmlConfigFileContents === "undefined" || defaultXmlConfigFileContents == "") {
      this.xmldata = '<?xml version="1.0" ?>\n<ROOT version="2.1">\n<Config>\n<Hubs>\n<Hub protocol="' + this.info.protocol + '" addr="' + this.info.addr + '" port="' + this.info.port.toString() + '"' + (this.info.path != "" ? ' path="' + this.info.path + '"' : "") + ' removable="FALSE"/>\n</Hubs>\n</Config>\n</ROOT>\n';
    } else {
      this.xmldata = defaultXmlConfigFileContents;
    }
    this.fileSystem = null;
    this.fileSystemReady = false;
    await this.findSourceFileSystem(defaultXmlConfigFileContents);
  }
  static async start(defaultXmlConfigFileContents) {
    let dirpath = location.pathname;
    let defport = "80";
    let slashpos = dirpath.lastIndexOf("/");
    if (slashpos > 0) {
      dirpath = dirpath.slice(0, slashpos);
    } else {
      dirpath = "";
    }
    if (location.protocol == "https:") {
      defport = "443";
    }
    let hubinfo = new HubInfo(location.protocol, location.hostname, parseInt(location.port ? location.port : defport), dirpath);
    await hubinfo.makeRequest();
    let filehandler = new YoctoHubFileHandler(hubinfo);
    await filehandler.init(defaultXmlConfigFileContents);
    return filehandler;
  }
  get xmlConfigData() {
    return this.xmldata;
  }
  static makeRequest(method, url, username, password) {
    return new Promise(function(resolve, reject) {
      let xhr = new XMLHttpRequest();
      if (username !== void 0 && password !== void 0 && username != null && password !== null) {
        xhr.open(method, url, true, username, password);
        xhr.withCredentials = true;
      } else {
        xhr.open(method, url);
      }
      xhr.overrideMimeType("text/plain; charset=x-user-defined");
      xhr.onreadystatechange = function() {
        if (xhr.readyState == 4) {
          if (this.status >= 200 && this.status < 300) {
            resolve(new HTTPrequestResult(YAPI.imm_str2bin(xhr.response), this.status, xhr.statusText));
          } else {
            resolve(new HTTPrequestResult(null, this.status, xhr.statusText));
          }
        }
      };
      xhr.onerror = function() {
        resolve(new HTTPrequestResult(null, this.status, xhr.statusText));
      };
      xhr.send();
    });
  }
  async findSourceFileSystem(xmldata) {
    this.fileSystem = null;
    let errmsg = new YErrorMsg();
    this.info.findOutCredentialsFromConfigFile(xmldata);
    let url = this.info.get_hubUrl(this.info.srvUsername, this.info.srvPassword);
    try {
      await YAPI.RegisterHub(url, errmsg);
    } catch (e) {
      this.fileSystemReady = false;
      if (e.errorType == YAPI.UNAUTHORIZED) {
        console.log("Access to hub " + url + " is denied, waiting for YV callback to save the situation.");
        this.FileSystemAccessDenied = true;
        return;
      }
      throw "YV4F ERROR: Unable to register Hub " + this.info.get_hubUrl() + "(" + e.message + "), save will not work.";
    }
    let fs = YFiles.FirstFiles();
    if (fs == null) {
      this.fileSystemReady = true;
      throw "YV4F ERROR: No file system found on Hub " + this.info.get_hubUrl() + ", save will not work.";
    }
    while (fs != null) {
      if (await fs.get_serialNumber() == this.info.serial) {
        await this.registerSourceFileSystem(fs);
        return;
      }
      fs = fs.nextFiles();
    }
    fs = YFiles.FirstFiles();
    while (fs != null) {
      let m = await fs.get_module();
      let url2 = await m.get_url();
      console.log("URL = (" + url2 + ")");
      let p = url2.indexOf("://");
      if (p >= 0)
        url2 = url2.slice(p + 3);
      p = url2.indexOf(":");
      if (p > 0)
        url2 = url2.slice(0, p);
      {
        if (url2 == this.info.addr) {
          await this.registerSourceFileSystem(fs);
          return;
        }
      }
      fs = fs.nextFiles();
    }
    this.fileSystemReady = true;
    throw "YV4F ERROR: No file system matching Hub " + this.info.get_hubUrl() + " found, save will not work.";
  }
  async registerSourceFileSystem(fs) {
    this.fileSystem = fs;
    this.fileSystemReady = true;
    this.FileSystemAccessDenied = false;
    let entries = await this.fileSystem.get_list(this.filename);
    if (entries.length > 0)
      this.configFileCRC = await entries[0].get_crc();
  }
  async configChangeCallback(m) {
    if (this.fileSystem == null) {
      let urlSignature = this.info.addr + ":" + this.info.port.toString() + "/" + this.info.path + (this.info.path != "" ? "/" : "");
      let sourceUrl = await m.get_url();
      console.log("urlSignature=" + urlSignature);
      console.log("sourceUrl=" + sourceUrl);
      if (sourceUrl.length > urlSignature.length && sourceUrl.substring(sourceUrl.length - urlSignature.length) == urlSignature) {
        let fs = YFiles.FindFiles(await m.get_serialNumber() + ".files");
        if (await fs.isOnline())
          await this.registerSourceFileSystem(fs);
      }
    }
    if (this.fileSystem == null)
      return null;
    if (await this.fileSystem.get_serialNumber() != await m.get_serialNumber())
      return null;
    let entries = await this.fileSystem.get_list(this.filename);
    if (entries.length <= 0)
      return null;
    if (this.configFileCRC == await entries[0].get_crc())
      return null;
    let data = await this.fileSystem.download(this.filename);
    let file = new TextDecoder("utf-8").decode(data);
    let indexStart = file.indexOf(YoctoHubFileHandler.signatureStart);
    if (indexStart < 0)
      return null;
    this.configFileCRC = await entries[0].get_crc();
    indexStart += YoctoHubFileHandler.signatureStart.length;
    let indexEnd = file.indexOf(YoctoHubFileHandler.signatureEnd);
    if (indexEnd < indexStart)
      return "";
    indexEnd += YoctoHubFileHandler.signatureEnd.length - 2;
    let configdata = file.substring(indexStart, indexEnd);
    try {
      return JSON.parse(configdata);
    } catch (e) {
    }
    return null;
  }
  get configChangeCallbackFct() {
    return async (module) => {
      return await this.configChangeCallback(module);
    };
  }
  get saveFct() {
    return async (xml, callback) => {
      return await this.saveFctinternal(xml, callback);
    };
  }
  async retryWithNewCredentials(xml, username, password, callback) {
    if (this.fileSystem == null) {
      debugger;
      return;
    }
    let m = await this.fileSystem.get_module();
    let url = await m.get_url();
    let err = new YErrorMsg();
    let p1 = url.indexOf("://");
    let p2 = url.indexOf("@", p1 + 3);
    let newurl = url.substring(0, p1 + 3) + username + ":" + password + "@";
    if (p2 < 0)
      newurl += url.substring(p1 + 3);
    else
      newurl += url.substring(p2 + 1);
    await YAPI.UnregisterHub(url);
    if (await YAPI.RegisterHub(newurl, err) != YAPI.SUCCESS) {
      await YAPI.RegisterHub(url, err);
    }
    try {
      if (!await this.saveFctinternal(xml, callback))
        return;
    } catch (e) {
      if (callback != null)
        callback(false, "Save failed (" + e.message) + ")";
      return;
    }
  }
  async saveFctinternal(xml, callback) {
    if (this.FileSystemAccessDenied) {
      throw "YV4F ERROR: Access to file system on " + this.info.get_hubUrl() + " is denied, it is probably password protected. Check network connections in the global configuration.";
    }
    if (this.fileSystem == null) {
      throw "YV4F ERROR: No file system, Save aborted";
    }
    if (!this.fileSystemReady) {
      throw "YV4F ERROR: File system is not ready yet, retry in a few seconds.";
    }
    if (!this.fileSystem.isOnline()) {
      throw "YV4F ERROR: File system is off line, Save aborted";
    }
    let tosave = "";
    let index = this.htmlSrcCode.indexOf(YoctoHubFileHandler.signatureStart + ")");
    if (index > 0) {
      tosave = this.htmlSrcCode.substring(0, index + YoctoHubFileHandler.signatureStart.length) + JSON.stringify(xml) + this.htmlSrcCode.substring(index + YoctoHubFileHandler.signatureStart.length);
    } else {
      let index1 = this.htmlSrcCode.indexOf(YoctoHubFileHandler.signatureStart);
      let index2 = this.htmlSrcCode.indexOf(YoctoHubFileHandler.signatureEnd);
      if (index1 > 0 && index2 && index2 > index1) {
        tosave = this.htmlSrcCode.substring(0, index1 + YoctoHubFileHandler.signatureStart.length) + JSON.stringify(xml) + ");" + this.htmlSrcCode.substring(index2 + YoctoHubFileHandler.signatureEnd.length);
      } else {
        throw "Unable to locate YoctoHubFileHandler constructor call in original HTML file.";
      }
    }
    tosave = "<!DOCTYPE html>\n" + tosave;
    let GZdata = Pako_Deflate.gzip(tosave, {level: 9});
    let askForRwCredentials = false;
    try {
      await this.fileSystem.upload(this.filename + ".gz", GZdata);
    } catch (e) {
      if (this.fileSystem.get_errorType() == YAPI_UNAUTHORIZED)
        askForRwCredentials = true;
      else
        throw e;
    }
    if (askForRwCredentials) {
      let m = await this.fileSystem.get_module();
      let url = await m.get_url();
      let err = new YErrorMsg();
      let p1 = url.indexOf("://");
      let p2 = url.indexOf("@", p1 + 3);
      if (p2 >= 0)
        url = url.substring(p2 + 1);
      else if (p1 >= 0)
        url = url.substring(p1 + 3);
      await CredentialsPrompt.show(url, async () => {
        await this.retryWithNewCredentials(xml, CredentialsPrompt.username, CredentialsPrompt.password, callback);
      });
      if (callback != null)
        callback(false, "Save failed, credentials required");
      return false;
    }
    let entries = await this.fileSystem.get_list(this.filename);
    if (entries.length > 0)
      this.configFileCRC = await entries[0].get_crc();
    if (callback != null)
      callback(true, "Save sucessfull");
    return true;
  }
};
YoctoHubFileHandler.signatureStart = "YoctoHubFileHandler.start(";
YoctoHubFileHandler.signatureEnd = '</ROOT>\\n");';

// obj/full/logForm.js
var logForm = class {
  static show() {
    if (logForm._window == null) {
      let params = new newWindowParam();
      params.positionType = 0;
      params.width = 8 * window.innerWidth / 10 >> 0;
      params.height = 6 * window.innerHeight / 10 >> 0;
      params.left = 1 * window.innerWidth / 10 >> 0;
      params.top = 2 * window.innerHeight / 10 >> 0;
      params.title = "LogFile";
      logForm._window = new YWindow(params);
      logForm._contents = logForm._window.innerContentDiv;
      logForm._contents.style.fontFamily = "courrier";
      logForm._contents.style.fontSize = (10 * constants.generalSizeCoef).toString() + "px";
      logForm._contents.style.overflow = "auto";
      for (let i = 0; i < logForm._lines.length; i++) {
        logForm.addLine(logForm._lines[i]);
      }
    }
    logForm._window.show();
  }
  static addLine(st) {
    let pre = document.createElement("PRE");
    pre.style.marginTop = "0";
    pre.style.marginBottom = "0";
    pre.innerText = st;
    logForm._contents.appendChild(pre);
    while (logForm._contents.childElementCount > 1e3) {
      logForm._contents.removeChild(logForm._contents.firstChild);
    }
  }
  static padStart(st, length) {
    while (st.length < length) {
      st = "0" + st;
    }
    return st;
  }
  static dateToString(d) {
    return d.getFullYear().toString() + "-" + logForm.padStart((d.getMonth() + 1).toString(), 2) + "-" + logForm.padStart(d.getDate().toString(), 2) + " " + logForm.padStart(d.getHours().toString(), 2) + ":" + logForm.padStart(d.getMinutes().toString(), 2) + ":" + logForm.padStart((d.getSeconds() + d.getMilliseconds() / 1e3).toFixed(3), 6);
  }
  static log(st) {
    logForm.logNOTS(logForm.dateToString(new Date()) + " " + st);
  }
  static logNOTS(st) {
    logForm._lines.push(st);
    if (logForm._lines.length > 1e3) {
      logForm._lines.splice(0, logForm._lines.length - 1e3);
    }
    if (logForm._window != null)
      logForm.addLine(st);
  }
};
logForm._lines = [];

// obj/full/rawDataForm.js
var rawDataForm = class {
  static hide() {
    if (rawDataForm._window == null)
      return;
    rawDataForm._window.visible = false;
  }
  static show() {
    if (rawDataForm._window == null) {
      let params = new newWindowParam();
      params.positionType = 1;
      params.width = 9 * window.innerWidth / 10 >> 0;
      params.height = 8 * window.innerHeight / 10 >> 0;
      params.title = "Raw data";
      rawDataForm._window = new YWindow(params);
      rawDataForm._contents = rawDataForm._window.innerContentDiv;
      rawDataForm._statusline = document.createElement("DIV");
      rawDataForm._statusline.style.position = "absolute";
      rawDataForm._statusline.style.left = constants.WindowPadding.toString() + "px";
      rawDataForm._statusline.style.right = constants.WindowPadding.toString() + "px";
      rawDataForm._statusline.style.height = (rawDataForm.STATUSLINEHEIGHT * constants.generalSizeCoef).toString() + "px";
      rawDataForm._statusline.style.bottom = constants.WindowPadding.toString() + "px";
      rawDataForm._statusline.style.paddingTop = Math.round(5 * constants.generalSizeCoef).toString() + "px";
      rawDataForm._statusline.style.paddingLeft = "5px";
      rawDataForm._statusline.style.paddingRight = "5px";
      rawDataForm._statusline.style.overflowX = "auto";
      rawDataForm._statusline.style.paddingRight = "5px";
      rawDataForm._contents.append(rawDataForm._statusline);
      rawDataForm._sensorsList = document.createElement("DIV");
      rawDataForm._sensorsList.style.position = "absolute";
      rawDataForm._sensorsList.style.left = constants.WindowPadding.toString() + "px";
      rawDataForm._sensorsList.style.right = (rawDataForm.sensorListWidth * constants.generalSizeCoef + 8 * constants.WindowPadding).toString() + "px";
      rawDataForm._sensorsList.style.top = "2px";
      rawDataForm._sensorsList.style.overflowY = "auto";
      rawDataForm._sensorsList.style.height = (rawDataForm.topMargin * constants.generalSizeCoef).toString() + "px";
      rawDataForm._sensorsList.style.paddingLeft = "5px";
      rawDataForm._sensorsList.style.paddingRight = "5px";
      rawDataForm._sensorsList.style.border = constants.WindowInnerBorder;
      rawDataForm._sensorsList.style.backgroundColor = constants.WindowInnerBackgroundColor;
      rawDataForm._contents.append(rawDataForm._sensorsList);
      rawDataForm._optionsList = document.createElement("DIV");
      rawDataForm._optionsList.style.position = "absolute";
      rawDataForm._optionsList.style.width = (rawDataForm.sensorListWidth * constants.generalSizeCoef).toString() + "px";
      rawDataForm._optionsList.style.right = constants.WindowPadding.toString() + "px";
      rawDataForm._optionsList.style.top = "0px";
      rawDataForm._optionsList.style.height = (rawDataForm.topMargin * constants.generalSizeCoef).toString() + "px";
      rawDataForm._optionsList.style.paddingLeft = "5px";
      rawDataForm._optionsList.style.paddingRight = "5px";
      rawDataForm._optionsList.style.border = "1px solid transparent";
      rawDataForm._contents.append(rawDataForm._optionsList);
      let br;
      rawDataForm._optionMIN = document.createElement("INPUT");
      rawDataForm._optionMIN.type = "input";
      rawDataForm._optionMIN.checked = false;
      rawDataForm._optionMIN.style.display = "inline";
      rawDataForm._optionMIN.type = "checkbox";
      rawDataForm._optionMIN.style.transform = "scale(" + constants.generalSizeCoef.toString() + ")";
      rawDataForm._optionMIN.style.marginRight = Math.round(5 * constants.generalSizeCoef).toString() + "px";
      rawDataForm._optionMIN.addEventListener("change", () => {
        rawDataForm.refresh();
      });
      rawDataForm._optionsList.append(rawDataForm._optionMIN);
      let span;
      span = document.createElement("SPAN");
      span.innerText = "Include minimum values";
      rawDataForm._optionsList.append(span);
      br = document.createElement("BR");
      rawDataForm._optionsList.append(br);
      rawDataForm._optionAVG = document.createElement("INPUT");
      rawDataForm._optionAVG.type = "input";
      rawDataForm._optionAVG.checked = true;
      rawDataForm._optionAVG.style.display = "inline";
      rawDataForm._optionAVG.type = "checkbox";
      rawDataForm._optionAVG.style.transform = "scale(" + constants.generalSizeCoef.toString() + ")";
      rawDataForm._optionAVG.style.marginRight = Math.round(5 * constants.generalSizeCoef).toString() + "px";
      rawDataForm._optionAVG.addEventListener("change", () => {
        rawDataForm.refresh();
      });
      rawDataForm._optionsList.append(rawDataForm._optionAVG);
      span = document.createElement("SPAN");
      span.innerText = "Include average values";
      rawDataForm._optionsList.append(span);
      br = document.createElement("BR");
      rawDataForm._optionsList.append(br);
      rawDataForm._optionMAX = document.createElement("INPUT");
      rawDataForm._optionMAX.type = "input";
      rawDataForm._optionMAX.checked = false;
      rawDataForm._optionMAX.style.display = "inline";
      rawDataForm._optionMAX.type = "checkbox";
      rawDataForm._optionMAX.style.transform = "scale(" + constants.generalSizeCoef.toString() + ")";
      rawDataForm._optionMAX.style.marginRight = Math.round(5 * constants.generalSizeCoef).toString() + "px";
      rawDataForm._optionMAX.addEventListener("change", () => {
        rawDataForm.refresh();
      });
      rawDataForm._optionsList.append(rawDataForm._optionMAX);
      span = document.createElement("SPAN");
      span.innerText = "Include maximum values";
      rawDataForm._optionsList.append(span);
      rawDataForm._optionsList.append(document.createElement("BR"));
      rawDataForm._optionsList.append(document.createElement("BR"));
      let p = document.createElement("P");
      p.style.textAlign = "center";
      let refreshBtn = new button("refresh", () => {
        rawDataForm.refresh();
      });
      p.appendChild(refreshBtn.Element);
      let ExportBtn = new button("export", () => {
        rawDataForm.export();
      });
      p.appendChild(ExportBtn.Element);
      rawDataForm._optionsList.append(p);
      rawDataForm._datacontents = document.createElement("DIV");
      rawDataForm._datacontents.style.position = "absolute";
      rawDataForm._datacontents.style.left = constants.WindowPadding.toString() + "px";
      rawDataForm._datacontents.style.right = constants.WindowPadding.toString() + "px";
      rawDataForm._datacontents.style.top = (rawDataForm.topMargin * constants.generalSizeCoef + 5 * constants.WindowPadding).toString() + "px";
      rawDataForm._datacontents.style.bottom = (4 * constants.WindowPadding + rawDataForm.STATUSLINEHEIGHT * constants.generalSizeCoef).toString() + "px";
      rawDataForm._datacontents.style.paddingLeft = "5px";
      rawDataForm._datacontents.style.paddingRight = "5px";
      rawDataForm._datacontents.style.overflowX = "auto";
      rawDataForm._datacontents.style.paddingRight = "5px";
      rawDataForm._contents.append(rawDataForm._datacontents);
      rawDataForm._dataTable = document.createElement("TABLE");
      rawDataForm._dataTable.style.position = "absolute";
      rawDataForm._dataTable.style.overflow = "auto";
      rawDataForm._dataTable.style.left = "0px";
      rawDataForm._dataTable.style.width = "100%";
      rawDataForm._dataTable.style.top = "0px";
      rawDataForm._dataTable.style.bottom = "0px";
      rawDataForm._dataTable.style.fontSize = constants.generalFontSize.toString() + "px";
      rawDataForm._dataTable.style.borderCollapse = "colapse";
      rawDataForm._dataTable.style.borderSpacing = "0px";
      rawDataForm._dataTable.style.fontFamily = "sans-serif";
      rawDataForm._datacontents.appendChild(rawDataForm._dataTable);
    }
    rawDataForm._window.show();
    rawDataForm.refresh();
  }
  static refresh() {
    let list = [];
    for (let i = 0; i < sensorsManager.sensorList.length; i++) {
      if (!(sensorsManager.sensorList[i] instanceof NullYSensor)) {
        list.push(sensorsManager.sensorList[i]);
      }
    }
    rawDataForm._selection = [];
    for (let i = 0; i < list.length; i++) {
      let spanNode;
      let spanText;
      let input;
      if (i >= rawDataForm._sensorsList.childNodes.length) {
        spanNode = document.createElement("SPAN");
        input = document.createElement("INPUT");
        input.type = "input";
        input.checked = false;
        input.style.display = "inline";
        input.type = "checkbox";
        input.style.transform = "scale(" + constants.generalSizeCoef.toString() + ")";
        input.style.marginRight = Math.round(5 * constants.generalSizeCoef).toString() + "px";
        input.addEventListener("change", () => {
          rawDataForm.refresh();
        });
        spanNode.appendChild(input);
        spanText = document.createElement("SPAN");
        spanNode.appendChild(spanText);
        rawDataForm._sensorsList.appendChild(spanNode);
        spanNode.appendChild(document.createElement("BR"));
      } else {
        spanNode = rawDataForm._sensorsList.childNodes[i];
        input = spanNode.childNodes[0];
        spanText = spanNode.childNodes[1];
      }
      if (input.checked)
        rawDataForm._selection.push(list[i]);
      input.id = list[i].get_hardwareId();
      spanText.innerText = list[i].get_friendlyName();
    }
    while (rawDataForm._sensorsList.childNodes.length > list.length) {
      rawDataForm._sensorsList.removeChild(rawDataForm._sensorsList.lastChild);
    }
    rawDataForm.RefreshContents(rawDataForm._selection);
  }
  static padStart(st, length) {
    while (st.length < length) {
      st = "0" + st;
    }
    return st;
  }
  static UnixTimeStampTostring(ts) {
    let d = new Date(Date.UTC(1970, 0, 1));
    d.setUTCSeconds(ts >> 0, 1e3 * (ts % 1));
    return d.getFullYear().toString() + "-" + rawDataForm.padStart((d.getMonth() + 1).toString(), 2) + "-" + rawDataForm.padStart(d.getDate().toString(), 2) + " " + rawDataForm.padStart(d.getHours().toString(), 2) + ":" + rawDataForm.padStart(d.getMinutes().toString(), 2) + ":" + rawDataForm.padStart((d.getSeconds() + d.getMilliseconds() / 1e3).toFixed(3), 6);
  }
  static RefreshContents(slist) {
    let TH = document.createElement("THEAD");
    let TB = document.createElement("TBODY");
    let HR1 = document.createElement("TR");
    let HR2 = document.createElement("TR");
    let indexes = [];
    for (let i = 0; i < slist.length; i++) {
      indexes.push(slist[i].curData.length - 1);
    }
    while (rawDataForm._dataTable.childNodes.length > 0) {
      rawDataForm._dataTable.removeChild(rawDataForm._dataTable.lastChild);
    }
    rawDataForm._dataTable.appendChild(TH);
    rawDataForm._dataTable.appendChild(TB);
    let sMin = false;
    let sMax = false;
    let sAvg = false;
    let toShow = 0;
    if (rawDataForm._optionMIN.checked) {
      sMin = true;
      toShow++;
    }
    if (rawDataForm._optionAVG.checked) {
      sAvg = true;
      toShow++;
    }
    if (rawDataForm._optionMAX.checked) {
      sMax = true;
      toShow++;
    }
    TH.appendChild(HR1);
    TH.appendChild(HR2);
    let cell = document.createElement("TH");
    HR1.appendChild(cell);
    cell = document.createElement("TH");
    HR2.appendChild(cell);
    for (let i = 0; i < slist.length; i++) {
      cell = document.createElement("TH");
      cell.innerText = slist[i].get_friendlyName();
      cell.colSpan = Math.max(1, toShow);
      cell.style.backgroundColor = "#f0f0f0";
      cell.style.borderLeft = constants.WindowInnerBorder;
      cell.style.borderRight = constants.WindowInnerBorder;
      cell.style.borderTop = constants.WindowInnerBorder;
      HR1.appendChild(cell);
      if (sMin) {
        cell = document.createElement("TH");
        cell.innerText = "Min";
        cell.style.borderLeft = constants.WindowInnerBorder;
        cell.style.borderRight = sAvg || sMax ? "" : constants.WindowInnerBorder;
        cell.style.backgroundColor = "#f0f0f0";
        cell.style.textAlign = "right";
        HR2.appendChild(cell);
      }
      if (sAvg) {
        cell = document.createElement("TH");
        cell.innerText = "Avg";
        cell.style.borderLeft = sMin ? "" : constants.WindowInnerBorder;
        cell.style.borderRight = sMax ? "" : constants.WindowInnerBorder;
        cell.style.backgroundColor = "#f0f0f0";
        cell.style.textAlign = "right";
        HR2.appendChild(cell);
      }
      if (sMax) {
        cell = document.createElement("TH");
        cell.innerText = "Max";
        cell.style.borderLeft = sAvg || sMin ? "" : constants.WindowInnerBorder;
        cell.style.borderRight = constants.WindowInnerBorder;
        cell.style.backgroundColor = "#f0f0f0";
        cell.style.textAlign = "right";
        HR2.appendChild(cell);
      }
    }
    let colcount = slist.length * toShow;
    let MaxTimeStamp = 0;
    for (let i = 0; i < slist.length; i++) {
      if (indexes[i] >= 0) {
        if (MaxTimeStamp < slist[i].curData[indexes[i]].DateTime) {
          MaxTimeStamp = slist[i].curData[indexes[i]].DateTime;
        }
      }
    }
    let rowcount = 0;
    let currentRow = null;
    while (MaxTimeStamp > 0 && rowcount < rawDataForm.MAXRAWDATAROWS) {
      let row = new Array(colcount);
      let nextTimeStamp = 0;
      for (let i = 0; i < slist.length; i++) {
        let Shown = false;
        if (indexes[i] >= 0) {
          if (slist[i].curData[indexes[i]].DateTime == MaxTimeStamp) {
            let n = 0;
            if (sMin) {
              row[n + i * toShow] = slist[i].minData[indexes[i]].value.toString();
              n++;
            }
            if (sAvg) {
              row[n + i * toShow] = slist[i].curData[indexes[i]].value.toString();
              n++;
            }
            if (sMax) {
              row[n + i * toShow] = slist[i].maxData[indexes[i]].value.toString();
              n++;
            }
            Shown = true;
            indexes[i]--;
          }
          if (indexes[i] >= 0) {
            if (slist[i].curData[indexes[i]].DateTime > nextTimeStamp) {
              nextTimeStamp = slist[i].curData[indexes[i]].DateTime;
            }
          }
        }
        if (!Shown) {
          let n = 0;
          if (sMin) {
            row[n + i * toShow] = "";
            n++;
          }
          if (sAvg) {
            row[n + i * toShow] = "";
            n++;
          }
          if (sMax) {
            row[n + i * toShow] = "";
            n++;
          }
        }
      }
      if (colcount > 0 && toShow > 0) {
        currentRow = document.createElement("TR");
        let cell2 = document.createElement("TD");
        cell2.innerText = rawDataForm.UnixTimeStampTostring(MaxTimeStamp).toLocaleString();
        cell2.style.borderLeft = constants.WindowInnerBorder;
        cell2.style.borderTop = rowcount == 0 ? constants.WindowInnerBorder : "";
        cell2.style.backgroundColor = "#f0f0f0";
        currentRow.style.backgroundColor = (rowcount & 1) == 0 ? "white" : "#f0f0f0";
        currentRow.appendChild(cell2);
        for (let j = 0; j < row.length; j++) {
          cell2 = document.createElement("TD");
          cell2.innerText = row[j];
          cell2.style.textAlign = "right";
          cell2.style.borderLeft = j % toShow == 0 ? constants.WindowInnerBorder : "";
          cell2.style.borderRight = (j + 1) % toShow == 0 ? constants.WindowInnerBorder : "";
          cell2.style.fontFamily = "monospace";
          currentRow.appendChild(cell2);
        }
        TB.appendChild(currentRow);
        rowcount++;
      }
      MaxTimeStamp = nextTimeStamp;
    }
    if (currentRow != null) {
      for (let i = 0; i < currentRow.childNodes.length; i++) {
        currentRow.childNodes[i].style.borderBottom = constants.WindowInnerBorder;
      }
    }
    if (toShow == 0) {
      rawDataForm._statusline.style.backgroundColor = "#FF8080";
      rawDataForm._statusline.innerText = "No data shown, select at least Min, Avg or Max options in the top-right checkboxes";
    } else if (rowcount == 0) {
      rawDataForm._statusline.style.backgroundColor = "#FF8080";
      rawDataForm._statusline.innerText = "No data shown, select at least one sensor in the list above.";
    } else {
      rawDataForm._statusline.style.backgroundColor = constants.WindowBackgroundColor;
      if (rowcount < rawDataForm.MAXRAWDATAROWS) {
        rawDataForm._statusline.innerText = "These are the last " + rowcount.toString() + " data rows.";
      } else {
        rawDataForm._statusline.innerText = "These are the last " + rowcount.toString() + " data rows.  Use the export feature to get the whole data set.";
      }
    }
  }
  static getCvsdata(slist, sMin, sAvg, sMax) {
    let toShow = 0;
    let indexes = [];
    for (let i = 0; i < slist.length; i++) {
      indexes.push(0);
    }
    if (sMin)
      toShow++;
    if (sAvg)
      toShow++;
    if (sMax)
      toShow++;
    let res;
    let ColumnHeader = "Timestamp";
    for (let i = 0; i < slist.length; i++) {
      let sName = slist[i].toString();
      if (sMin)
        ColumnHeader += ";" + sName + "(min)";
      if (sAvg)
        ColumnHeader += ";" + sName + "(avg)";
      if (sMax)
        ColumnHeader += ";" + sName + "(max)";
    }
    res = ColumnHeader + "\r\n";
    let colcount = slist.length * toShow;
    let MinTimeStamp = Number.POSITIVE_INFINITY;
    for (let i = 0; i < slist.length; i++) {
      if (indexes[i] < slist[i].curData.length) {
        if (MinTimeStamp > slist[i].curData[indexes[i]].DateTime) {
          MinTimeStamp = slist[i].curData[indexes[i]].DateTime;
        }
      }
    }
    while (MinTimeStamp < Number.POSITIVE_INFINITY) {
      let line = "";
      let nextTimeStamp = Number.POSITIVE_INFINITY;
      for (let i = 0; i < slist.length; i++) {
        let Shown = false;
        if (indexes[i] < slist[i].curData.length) {
          if (slist[i].curData[indexes[i]].DateTime == MinTimeStamp) {
            if (sMin)
              line += ";" + slist[i].minData[indexes[i]].value.toString();
            if (sAvg)
              line += ";" + slist[i].curData[indexes[i]].value.toString();
            if (sMax)
              line += ";" + slist[i].maxData[indexes[i]].value.toString();
            Shown = true;
            indexes[i]++;
          }
          if (indexes[i] < slist[i].curData.length) {
            if (slist[i].curData[indexes[i]].DateTime < nextTimeStamp) {
              nextTimeStamp = slist[i].curData[indexes[i]].DateTime;
            }
          }
        }
        if (!Shown) {
          if (sMin)
            line += " ; ";
          if (sAvg)
            line += " ; ";
          if (sMax)
            line += " ; ";
        }
      }
      if (colcount > 0)
        line = rawDataForm.UnixTimeStampTostring(MinTimeStamp) + line;
      res += line + "\r\n";
      MinTimeStamp = nextTimeStamp;
    }
    return res;
  }
  static export() {
    let element = document.createElement("a");
    let data = "data:text/csv;charset=utf-8," + encodeURI(rawDataForm.getCvsdata(rawDataForm._selection, rawDataForm._optionMIN.checked, rawDataForm._optionAVG.checked, rawDataForm._optionMAX.checked));
    element.setAttribute("href", data);
    element.setAttribute("download", "rawdata.csv");
    element.style.display = "none";
    document.body.appendChild(element);
    element.click();
    document.body.removeChild(element);
  }
};
rawDataForm._lines = [];
rawDataForm.topMargin = 100;
rawDataForm.sensorListWidth = 200;
rawDataForm.MAXRAWDATAROWS = 100;
rawDataForm.STATUSLINEHEIGHT = 20;
rawDataForm._selection = [];

// obj/full/windowManager.js
var button = class {
  constructor(caption, action, sizeCoefOverload) {
    this._enabled = true;
    this._visible = true;
    this._caption = "";
    this._caption = caption;
    this._action = action;
    let GUIcoef = constants.generalSizeCoef;
    if (typeof sizeCoefOverload !== "undefined")
      GUIcoef = sizeCoefOverload;
    this._link = document.createElement("A");
    this._link.innerText = this._caption;
    this._link.style.cursor = "pointer";
    this._link.style.display = "inlineblock";
    let padding = Math.round(5 * GUIcoef).toString() + "px";
    let margin = Math.round(3 * GUIcoef).toString() + "px";
    this._link.tabIndex = 0;
    this._link.style.padding = padding + " " + padding + " " + padding + " " + padding;
    this._link.style.margin = margin + " " + margin + " " + margin + " " + margin;
    this._link.style.borderColor = "#808080";
    this._link.style.backgroundColor = "#f0f0f0";
    this._link.style.fontFamily = constants.generalFontFamily;
    this._link.style.fontSize = (16 * GUIcoef).toString() + "px";
    this._link.style.cursor = "pointer";
    this._link.style.border = constants.WindowInnerBorder;
    this._link.addEventListener("mouseover", () => {
      if (this._enabled)
        this._link.style.backgroundColor = "white";
    });
    this._link.addEventListener("mouseout", () => {
      if (this._enabled)
        this._link.style.backgroundColor = "#f0f0f0";
    });
    this._link.addEventListener("click", () => {
      if (this._enabled)
        this._action(this);
    });
    this._link.addEventListener("keypress", (e) => {
      if (this._enabled && (e.key == "Enter" || e.key == " "))
        this._action(this);
    });
  }
  get Element() {
    return this._link;
  }
  set tabIndex(index) {
    this._link.tabIndex = index;
  }
  focus() {
    this._link.focus();
  }
  get visible() {
    return this._visible;
  }
  set visible(value) {
    this._visible = value;
    this._link.style.display = this._visible ? "" : "none";
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    this.enable(value);
  }
  performAction() {
    if (!this._enabled)
      return;
    this._action(this);
  }
  showShortcut(enable) {
    if (!this._enabled)
      enable = false;
    if (enable) {
      this._link.innerHTML = "<u>" + this._caption.substring(0, 1) + "</u>" + this._caption.substring(1);
    } else {
      this._link.innerText = this._caption;
    }
  }
  enable(state) {
    if (state == this._enabled)
      return;
    this._enabled = state;
    this._link.tabIndex = state ? 0 : -1;
    if (this._enabled) {
      this._link.style.cursor = "pointer";
      this._link.style.backgroundColor = "#f0f0f0";
      this._link.style.color = "black";
    } else {
      this._link.style.backgroundColor = "#e0e0e0";
      this._link.style.cursor = "default";
      this._link.style.color = "#A0A0A0";
    }
  }
};
var newWindowParam = class {
  constructor(sizeCoefOverload) {
    this.createNow = false;
    this.left = 100;
    this.top = 100;
    this.positionType = 0;
    this.width = 400;
    this.height = 300;
    this.isModal = false;
    this.showShadow = true;
    this.showContainerBorders = true;
    this.showHeader = true;
    this.title = "new Window";
    this.closeIcon = true;
    this.headerBgColor = "";
    this.bottomKeepClear = 0;
    this.contentsDefaultFontSize = constants.generalFontSize;
    this.contentsDefaultFontFamily = constants.generalFontFamily;
    this.closingCallBack = null;
    this.WindowBackgroundColor = "#f0f0f0";
    this.WindowBorder = "1px solid #808080";
    this.WindowPadding = 2;
    this.WindowInnerBorderColor = " #A0A0A0";
    this.WindowInnerBackgroundColor = "#fAfAfA";
    this.WindowInnerBorder = "1px solid " + this.WindowInnerBorderColor;
    this.WindowHeaderBackgroundColor = "#0072ca";
    this.WindowHeaderColor = "white";
    this.WindowHeaderBorder = "1px solid #0072ca";
    this._GUICoef = constants.generalSizeCoef;
    this.WindowHeaderHeight = Math.round(20 * constants.generalSizeCoef);
    this.WindowHeaderFontSize = 16 * constants.generalSizeCoef;
    this.WindowHeaderFontFamily = constants.generalFontFamily;
    this.buttons = [];
    if (typeof sizeCoefOverload !== "undefined") {
      this.WindowHeaderHeight = 20 * sizeCoefOverload;
      this.WindowHeaderFontSize = 16 * sizeCoefOverload;
      this._GUICoef = sizeCoefOverload;
    }
  }
  get GUICoef() {
    return this._GUICoef;
  }
  clone() {
    let it = new newWindowParam();
    let keys = Object.keys(this);
    for (let i = 0; i < keys.length; i++) {
      if (keys[i] != "buttons")
        it[keys[i]] = this[keys[i]];
    }
    for (let i = 0; i < this.buttons.length; i++) {
      it.buttons.push(this.buttons[i]);
    }
    return it;
  }
};
var YWindow = class {
  constructor(params) {
    this._div = null;
    this._titleSpan = null;
    this._ModalDivShield = null;
    this._switchSideDiv = null;
    this._buttonsContainer = null;
    this._params = params.clone();
    YWindow.windowList.push(this);
    this._contents = document.createElement("DIV");
    if (params.createNow)
      this.allocate();
  }
  static get ConTextMenuBestZindex() {
    for (let i = 0; i < YWindow.windowList.length; i++) {
      if (YWindow.windowList[i].isModal())
        return -1;
    }
    return 1e5 + 2 * YWindow.windowList.length;
  }
  get innerContentDiv() {
    return this._contents;
  }
  get bottomKeepClear() {
    return this._params.bottomKeepClear;
  }
  set bottomKeepClear(value) {
    this._params.bottomKeepClear = value;
    if (this._contents != null) {
      this._contents.style.bottom = (this._params.WindowPadding + this._params.bottomKeepClear).toString() + "px";
    }
  }
  get outterContentDiv() {
    return this._div;
  }
  isModal() {
    if (this._div == null)
      return false;
    return this._div.style.display == "" && this._params.isModal;
  }
  get visible() {
    if (this._div == null)
      return false;
    return this._div.style.display == "";
  }
  set visible(v) {
    v ? this.show() : this.hide();
  }
  show(width) {
    if (this._div == null)
      this.allocate();
    this._div.style.display = "";
    if (this._ModalDivShield != null)
      this._ModalDivShield.style.display = "";
    this.brintToFront();
    if (typeof width !== "undefined" && this._params.positionType == 2) {
      this._div.style.width = width.toString() + "px";
    }
  }
  allocate() {
    if (this._div != null)
      return;
    if (this._params.isModal) {
      this._ModalDivShield = document.createElement("DIV");
      this._ModalDivShield.style.position = "fixed";
      this._ModalDivShield.style.left = "0px";
      this._ModalDivShield.style.top = "0px";
      this._ModalDivShield.style.right = "0px";
      this._ModalDivShield.style.bottom = "0px";
      this._ModalDivShield.style.backgroundColor = "rgba(255,255,255,0.85) ";
      document.body.appendChild(this._ModalDivShield);
    }
    this._div = document.createElement("DIV");
    this._div.style.display = "none";
    switch (this._params.positionType) {
      case 0:
        this._div.style.position = "absolute";
        this._div.style.left = this._params.left.toString() + "px";
        this._div.style.top = this._params.top.toString() + "px";
        this._div.style.width = this._params.width.toString() + "px";
        this._div.style.height = this._params.height.toString() + "px";
        break;
      case 1:
        this._div.style.position = "absolute";
        this._div.style.left = "50%";
        this._div.style.top = "50%";
        this._div.style.transform = "translate(-50%, -50%)";
        this._div.style.width = this._params.width.toString() + "px";
        this._div.style.height = this._params.height.toString() + "px";
        break;
      case 2:
        this._div.style.position = "fixed";
        this._div.style.top = "5px";
        this._div.style.right = "5px";
        this._div.style.bottom = "5px";
        this._div.style.width = this._params.width.toString() + "px";
        break;
    }
    this._div.style.border = this._params.WindowBorder;
    this._div.style.backgroundColor = this._params.WindowBackgroundColor;
    if (this._params.showShadow)
      this._div.style.boxShadow = " 4px 4px 4px 1px rgba(0,0,0,0.05)";
    let containerTop = this._params.WindowPadding;
    if (this._params.showHeader) {
      containerTop = this._params.WindowHeaderHeight + 3 * this._params.WindowPadding;
      let title = document.createElement("DIV");
      title.style.position = "absolute";
      title.style.left = this._params.WindowPadding.toString() + "px";
      title.style.top = this._params.WindowPadding.toString() + "px";
      title.style.right = this._params.WindowPadding.toString() + "px";
      title.style.height = this._params.WindowHeaderHeight.toString() + "px";
      title.style.border = this._params.WindowHeaderBorder;
      title.style.backgroundColor = this._params.WindowHeaderBackgroundColor;
      title.style.fontFamily = this._params.WindowHeaderFontFamily;
      title.style.color = this._params.WindowHeaderColor;
      title.style.fontSize = this._params.WindowHeaderFontSize.toString() + "px";
      title.style.paddingLeft = "5px";
      title.style.whiteSpace = "nowrap";
      title.addEventListener("click", () => {
        this.brintToFront();
      });
      this._titleSpan = document.createElement("SPAN");
      this._titleSpan.innerText = this._params.title;
      title.appendChild(this._titleSpan);
      if (this._params.closeIcon) {
        let closeDiv = document.createElement("DIV");
        closeDiv.style.position = "absolute";
        closeDiv.style.right = "0px";
        closeDiv.style.top = "0px";
        closeDiv.style.width = Math.round(this._params.WindowHeaderHeight + 5).toString() + "px";
        closeDiv.style.height = this._params.WindowHeaderHeight.toString() + "px";
        closeDiv.style.overflow = "hide";
        closeDiv.style.paddingLeft = "5px";
        closeDiv.tabIndex = 0;
        closeDiv.style.cursor = "pointer";
        closeDiv.style.backgroundColor = this._params.WindowHeaderBackgroundColor;
        closeDiv.innerHTML = ressources.CloseIcon(this._params.WindowHeaderHeight.toString(), false, false, false, false, "Click to close this window");
        closeDiv.addEventListener("click", () => {
          this.hide();
        });
        closeDiv.addEventListener("keypress", (e) => {
          if (e.key == "Enter")
            this.hide();
        });
        title.appendChild(closeDiv);
      }
      if (this._params.positionType == 2) {
        this._switchSideDiv = document.createElement("DIV");
        this._switchSideDiv.style.position = "absolute";
        this._switchSideDiv.style.width = Math.round(this._params.WindowHeaderHeight + 5).toString() + "px";
        this._switchSideDiv.style.right = Math.round(this._params.WindowHeaderHeight + 5) + "px";
        this._switchSideDiv.style.height = this._params.WindowHeaderHeight.toString() + "px";
        this._switchSideDiv.style.overflow = "hide";
        this._switchSideDiv.style.paddingLeft = "5px";
        this._switchSideDiv.style.top = "0px";
        this._switchSideDiv.style.cursor = "pointer";
        this._switchSideDiv.style.backgroundColor = this._params.WindowHeaderBackgroundColor;
        this._switchSideDiv.innerHTML = ressources.MoveToLeftIcon(this._params.WindowHeaderHeight.toString(), false, false, false, false, "Click to move editor on left side");
        this._switchSideDiv.addEventListener("click", () => {
          this.switchSide();
        });
        title.appendChild(this._switchSideDiv);
      }
      this._div.appendChild(title);
    }
    if (this._params.buttons.length > 0) {
      this._buttonsContainer = document.createElement("DIV");
      this._buttonsContainer.style.position = "absolute";
      this._buttonsContainer.style.bottom = Math.round(this._params.WindowPadding).toString() + "px";
      this._buttonsContainer.style.right = Math.round(this._params.WindowPadding).toString() + "px";
      this._buttonsContainer.style.textAlign = "right";
      for (let i = 0; i < this._params.buttons.length; i++) {
        this._buttonsContainer.appendChild(this._params.buttons[i].Element);
      }
      this._div.appendChild(this._buttonsContainer);
      this._buttonsContainer.style.height = (25 * this._params.GUICoef).toString() + "px";
      this._params.bottomKeepClear += Math.round(35 * this._params.GUICoef);
    }
    this._contents.style.position = "absolute";
    this._contents.style.left = this._params.WindowPadding.toString() + "px";
    this._contents.style.right = this._params.WindowPadding.toString() + "px";
    this._contents.style.top = containerTop.toString() + "px";
    this._contents.style.bottom = (this._params.WindowPadding + this._params.bottomKeepClear).toString() + "px";
    this._contents.style.paddingLeft = "5px";
    this._contents.style.paddingRight = "5px";
    if (this._contents.style.fontSize == "") {
      this._contents.style.fontSize = this._params.contentsDefaultFontSize.toString() + "px";
    }
    if (this._contents.style.fontFamily == "") {
      this._contents.style.fontFamily = this._params.contentsDefaultFontFamily;
    }
    if (this._params.showContainerBorders) {
      this._contents.style.border = this._params.WindowInnerBorder;
      this._contents.style.backgroundColor = this._params.WindowInnerBackgroundColor;
    } else {
      this._contents.style.border = "1px solid rgba(0, 0, 0, 0)";
      this._contents.style.backgroundColor = "";
    }
    this._contents.style.overflow = "hide";
    this._div.append(this._contents);
    document.body.appendChild(this._div);
  }
  hide() {
    if (this._div == null)
      return;
    this._div.style.display = "none";
    if (this._ModalDivShield != null)
      this._ModalDivShield.style.display = "none";
    if (this._params.closingCallBack != null)
      this._params.closingCallBack(this);
  }
  set title(value) {
    this._params.title = value;
    if (this._titleSpan != null) {
      this._titleSpan.innerText = value;
    }
  }
  brintToFront() {
    let n = -1;
    for (let i = 0; i < YWindow.windowList.length; i++) {
      if (YWindow.windowList[i] == this)
        n = i;
    }
    if (n < 0)
      return;
    YWindow.windowList.splice(n, 1);
    YWindow.windowList.push(this);
    for (let i = 0; i < YWindow.windowList.length; i++) {
      YWindow.windowList[i].zIndex = i;
    }
  }
  set zIndex(index) {
    if (this._div == null)
      return;
    this._div.style.zIndex = (100001 + 2 * index).toString();
    if (this._params.isModal)
      this._ModalDivShield.style.zIndex = (1e5 + 2 * index).toString();
  }
  switchSide() {
    if (this._div.style.left == "") {
      this._div.style.left = "5px";
      this._div.style.right = "";
      this._switchSideDiv.innerHTML = ressources.MoveToRightIcon(Math.round(20 * this._params.GUICoef).toString(), false, false, false, false, "Click to move editor on right side");
    } else {
      this._div.style.left = "";
      this._div.style.right = "5px";
      this._switchSideDiv.innerHTML = ressources.MoveToLeftIcon(Math.round(20 * this._params.GUICoef).toString(), false, false, false, false, "Click to move editor on left side");
    }
  }
};
YWindow.windowList = [];
var confirm = class {
  static ask(message, yes, no, userdata) {
    let params = new newWindowParam();
    params.positionType = 1;
    params.width = Math.min(Math.round(400 * constants.generalSizeCoef), Math.round(screen.width * 0.9));
    params.height = Math.min(Math.round(160 * constants.generalSizeCoef), Math.round(screen.height * 0.7));
    params.isModal = true;
    params.showHeader = false;
    params.showContainerBorders = false;
    let YesButton = new button("Yes", () => {
      confirm._window.hide();
      if (yes != null)
        yes(userdata);
    });
    let NoButton = new button("No", () => {
      confirm._window.hide();
      if (no != null)
        no(userdata);
    });
    params.buttons.push(YesButton);
    params.buttons.push(NoButton);
    confirm._window = new YWindow(params);
    let contents = confirm._window.innerContentDiv;
    let table = document.createElement("TABLE");
    table.style.width = "100%";
    let TR = document.createElement("TR");
    let TD = document.createElement("TD");
    TD.style.width = "10";
    TD.innerHTML = ressources.DontKnowIcon(Math.round(80 * constants.generalSizeCoef).toString(), true, false, false, false, "");
    TR.appendChild(TD);
    TD = document.createElement("TD");
    TD.style.paddingLeft = "20px";
    TD.style.fontFamily = constants.generalFontFamily;
    TD.style.fontSize = constants.generalFontSize.toString() + "px";
    TD.style.textAlign = "justify";
    TD.innerText = message;
    TR.appendChild(TD);
    table.appendChild(TR);
    contents.appendChild(table);
    confirm._window.show();
    return confirm._window;
  }
};
var notififaction = class {
  static show(icon, message) {
    let params = new newWindowParam();
    params.positionType = 1;
    params.width = Math.min(Math.round(400 * constants.generalSizeCoef), screen.width);
    params.height = Math.min(Math.round(160 * constants.generalSizeCoef), screen.height);
    params.isModal = true;
    params.showHeader = false;
    params.showContainerBorders = false;
    let okButton = new button("OK", () => {
      alert2._window.hide();
    });
    params.buttons.push(okButton);
    alert2._window = new YWindow(params);
    let contents = alert2._window.innerContentDiv;
    let table = document.createElement("TABLE");
    table.style.width = "100%";
    let TR = document.createElement("TR");
    let TD = document.createElement("TD");
    TD.style.width = "10";
    TD.innerHTML = icon;
    TR.appendChild(TD);
    TD = document.createElement("TD");
    TD.style.paddingLeft = "20px";
    TD.style.fontFamily = constants.generalFontFamily;
    TD.style.fontSize = constants.generalFontSize.toString() + "px";
    TD.style.textAlign = "justify";
    TD.innerText = message;
    TR.appendChild(TD);
    table.appendChild(TR);
    contents.appendChild(table);
    alert2._window.show();
    return alert2._window;
  }
};
var alert2 = class extends notififaction {
  static show(message) {
    return super.show(ressources.FailedIcon(Math.round(80 * constants.generalSizeCoef).toString(), true, false, false, false, ""), message);
  }
};

// obj/full/mainForm_rw.js
var mainForm = class {
  constructor() {
    this.GUIcoef = 1;
    let params = new newWindowParam();
    params.positionType = 1;
    this.GUIcoef = constants.generalSizeCoef;
    if (mainForm.REFWIDH * this.GUIcoef > screen.width)
      this.GUIcoef = screen.width / mainForm.REFWIDH;
    if (mainForm.REFHEIGHT * this.GUIcoef > screen.height)
      this.GUIcoef = screen.height / mainForm.REFHEIGHT;
    params.width = Math.round(mainForm.REFWIDH * this.GUIcoef);
    params.height = Math.round(mainForm.REFHEIGHT * this.GUIcoef);
    params.showHeader = false;
    params.showContainerBorders = false;
    this._window = new YWindow(params);
    let contents = this._window.innerContentDiv;
    let title = document.createElement("p");
    title.style.paddingTop = "0px";
    title.style.marginTop = 4 * this.GUIcoef + "px";
    title.style.fontSize = 16 * this.GUIcoef + "px";
    title.innerText = "Hello, welcome to Yocto-Visualization, what would you like to do?";
    title.style.textAlign = "center";
    contents.appendChild(title);
    let table = document.createElement("TABLE");
    table.style.position = "absolute";
    table.style.top = "0px";
    table.style.fontFamily = constants.generalFontFamily;
    table.style.tableLayout = "fixed";
    table.style.paddingLeft = Math.round(10 * this.GUIcoef).toString() + "px";
    table.style.paddingRight = Math.round(10 * this.GUIcoef).toString() + "px";
    table.style.paddingTop = Math.round(30 * this.GUIcoef).toString() + "px";
    table.style.paddingBottom = Math.round(15 * this.GUIcoef).toString() + "px";
    table.style.width = "100%";
    table.style.height = "100%";
    table.style.borderSpacing = Math.round(5 * this.GUIcoef).toString() + "px";
    let tr1 = document.createElement("TR");
    table.appendChild(tr1);
    let td11 = document.createElement("TD");
    tr1.appendChild(td11);
    let td12 = document.createElement("TD");
    tr1.appendChild(td12);
    let td13 = document.createElement("TD");
    tr1.appendChild(td13);
    let tr2 = document.createElement("TR");
    table.appendChild(tr2);
    let td21 = document.createElement("TD");
    tr2.appendChild(td21);
    let td22 = document.createElement("TD");
    tr2.appendChild(td22);
    let td23 = document.createElement("TD");
    tr2.appendChild(td23);
    contents.appendChild(table);
    let version = document.createElement("p");
    version.style.position = "absolute";
    version.style.right = "0px";
    version.style.bottom = "0px";
    version.style.marginBottom = "0px";
    version.style.paddingBottom = "0px";
    version.style.marginRight = "2px";
    version.style.fontSize = (8 * this.GUIcoef).toString() + "px";
    version.innerText = constants.buildVersion;
    version.style.color = "grey";
    version.style.textAlign = "right";
    contents.appendChild(version);
    let size = (128 * this.GUIcoef).toString();
    this.createButton(td11, "Configure global parameters", ressources.ConfigureIcon(size, true, false, false, false), () => {
      this.openConfig();
    });
    this.createButton(td12, "Create a new solid gauge", ressources.SolidGaugeIcon(size, true, false, false, false), () => {
      YWebPage.newGaugeWidget();
    });
    this.createButton(td13, "Create a new graph", ressources.GraphIcon(size, true, false, false, false), () => {
      YWebPage.newGraphWidget();
    });
    this.createButton(td21, "Get Raw data", ressources.RawDataIcon(size, true, false, false, false), () => {
      this.openRawData();
    });
    this.createButton(td22, "Create a new digital display", ressources.DigitalDisplayIcon(size, true, false, false, false), () => {
      YWebPage.newDigitalDisplayWidget();
    });
    this.createButton(td23, "Create a new angular gauge", ressources.AngularGaugeIcon(size, true, false, false, false), () => {
      YWebPage.newAngularGaugeWidget();
    });
  }
  hide() {
    this._window.hide();
  }
  show() {
    this._window.show();
  }
  createButton(container, caption, icon, callback) {
    container.style.border = "1px solid black";
    container.style.textAlign = "center";
    container.style.fontSize = (10 * this.GUIcoef).toString() + "px";
    container.style.paddingBottom = "3px";
    container.style.borderColor = "#808080";
    container.style.backgroundColor = "#f0f0f0";
    container.style.cursor = "pointer";
    container.addEventListener("mouseover", function() {
      container.style.backgroundColor = "white";
    });
    container.addEventListener("mouseout", function() {
      container.style.backgroundColor = "#f0f0f0";
    });
    let a = document.createElement("a");
    a.style.outline = "none";
    a.innerHTML = icon + "<br>" + caption;
    a.addEventListener("click", callback);
    a.tabIndex = 0;
    a.addEventListener("focusin", () => {
      container.style.backgroundColor = "white";
    });
    a.addEventListener("focusout", () => {
      container.style.backgroundColor = "f0f0f0";
    });
    a.addEventListener("keypress", (e) => {
      if (e.key == "Enter")
        callback();
    });
    container.appendChild(a);
  }
  openConfig() {
    configForm.show();
  }
  openRawData() {
    rawDataForm.show();
  }
};
mainForm.REFWIDH = 500;
mainForm.REFHEIGHT = 360;

// obj/full/Editor_rw.js
var EditedDataSource = class {
  constructor(source, root) {
    this._htmlchilds = [];
    this._source = source;
    this._root = root;
    this._htmlchilds = [];
  }
  storeChilds(childsList) {
    this._htmlchilds = [];
    for (let i = 0; i < childsList.length; i++) {
      this._htmlchilds.push(childsList.item(i));
    }
  }
  getStoredChilds() {
    return this._htmlchilds;
  }
  get root() {
    return this._root;
  }
  refresh() {
    if (this._root != null)
      this._root.refresh();
  }
};
var keyDataObject = class {
  constructor(key, data) {
    this.key = key;
    this.data = data;
  }
};
var objectDictionnary = class {
  constructor() {
    this.list = [];
  }
  isInlist(key) {
    for (let i = 0; i < this.list.length; i++) {
      if (key == this.list[i].key)
        return true;
    }
    return false;
  }
  find(key) {
    for (let i = 0; i < this.list.length; i++) {
      if (key == this.list[i].key)
        return this.list[i].data;
    }
    return null;
  }
  insert(key, data) {
    for (let i = 0; i < this.list.length; i++) {
      if (key == this.list[i].key) {
        this.list[i].data = data;
        return;
      }
    }
    this.list.push(new keyDataObject(key, data));
  }
};
var EditorBaseDef = class {
  refresh() {
  }
  get panel() {
    return null;
  }
  get expanded() {
    return true;
  }
  AllocateControls() {
  }
};
var PropertiesForm2 = class extends EditorBaseDef {
  constructor() {
    super();
    this._hostWindow = null;
    this._editorClosedCallback = null;
    this.currentEditedDataSource = null;
    this._changeCallback = null;
    this._getvalueCallback = null;
    this._text = "Properties editor";
    this._helpText = "Properties editor";
    this.EditedDataSourceList = new objectDictionnary();
    let params = new newWindowParam();
    params.positionType = 2;
    params.width = this.bestWidth();
    params.createNow = true;
    params.closingCallBack = (source) => {
      this.editorIsClosing(source);
    };
    params.bottomKeepClear = PropertiesForm2.HelpHeight + 3 * constants.WindowPadding;
    params.title = this._text;
    this._window = new YWindow(params);
    this._container = this._window.innerContentDiv;
    this._helpPanel = document.createElement("DIV");
    this._helpPanel.style.position = "absolute";
    this._helpPanel.style.left = constants.WindowPadding.toString() + "px";
    this._helpPanel.style.bottom = constants.WindowPadding.toString() + "px";
    this._helpPanel.style.right = constants.WindowPadding.toString() + "px";
    this._helpPanel.style.height = PropertiesForm2.HelpHeight.toString() + "px";
    this._helpPanel.style.paddingLeft = "5px";
    this._helpPanel.style.paddingTop = "5px";
    this._helpPanel.style.overflowY = "auto";
    this._helpPanel.style.border = constants.WindowInnerBorder;
    this._helpPanel.style.backgroundColor = constants.WindowInnerBackgroundColor;
    this._helpPanel.style.fontFamily = constants.generalFontFamily;
    this._helpPanel.style.fontSize = constants.generalFontSize.toString() + "px";
    this._helpPanel.style.color = "black";
    this._helpPanel.style.display = "";
    this._helpPanel.innerHTML = "Help panel. Editor is loading, please wait....";
    this._window.outterContentDiv.appendChild(this._helpPanel);
    this._container.style.overflowY = "scroll";
    this._container.style.overflowX = "hidden";
    this._container.style.backgroundColor = constants.WindowInnerBackgroundColor;
    window.addEventListener("resize", () => {
      this.windowResized();
    });
  }
  get visible() {
    return this._window.visible;
  }
  set visible(v) {
    v ? this.show() : this.hide();
  }
  get text() {
    return this._text;
  }
  set text(value) {
    this._text = value;
    this._window.title = this._text;
  }
  get help() {
    return this._helpText;
  }
  set help(value) {
    this._helpText = value;
    this._helpPanel.innerHTML = this._helpText;
  }
  addTest(parentDiv) {
    PropertiesForm2.testid++;
    let mainlabel = document.createElement("DIV");
    mainlabel.style.position = "relative";
    mainlabel.style.display = "inline-block;";
    mainlabel.style.left = "0px";
    mainlabel.style.padding = "2px 2px 2px 2px";
    mainlabel.style.right = "5px";
    mainlabel.style.border = "1px solid black";
    mainlabel.style.marginTop = "2px";
    mainlabel.style.backgroundColor = "yellow";
    if (parentDiv != null) {
      parentDiv.appendChild(mainlabel);
    } else {
      this._container.appendChild(mainlabel);
    }
    let expandCtrl = document.createElement("ANCHOR");
    expandCtrl.innerText = "[+]";
    mainlabel.appendChild(expandCtrl);
    let mainText = document.createElement("SPAN");
    mainText.innerText = "Pouet " + PropertiesForm2.testid.toString();
    mainlabel.appendChild(mainText);
    let subElementPanel = document.createElement("DIV");
    subElementPanel.style.position = "relative";
    subElementPanel.style.display = "inline-block;";
    subElementPanel.style.left = "5px";
    subElementPanel.style.padding = "2px 2px 2px 2px";
    subElementPanel.style.right = "5px";
    subElementPanel.style.marginTop = "2px";
    subElementPanel.style.backgroundColor = "lightgray";
    subElementPanel.innerText = "sub elements";
    if (parentDiv != null) {
      parentDiv.appendChild(subElementPanel);
    } else {
      this._container.appendChild(subElementPanel);
    }
    return subElementPanel;
  }
  editorIsClosing(source) {
    if (this._editorClosedCallback != null)
      this._editorClosedCallback();
  }
  bestWidth() {
    let w = window.innerWidth / 4 >> 0;
    let minWidth = 275 * constants.guiDPIFactor;
    if (w < minWidth)
      w = minWidth;
    if (w > window.innerWidth - 10)
      w = window.innerWidth - 10;
    return w;
  }
  windowResized() {
    if (this._window.innerContentDiv == null)
      return;
    if (this._window.innerContentDiv.offsetHeight < PropertiesForm2.MinHeightforShowingHelp && this._helpPanel.style.display == "") {
      this._helpPanel.style.display = "none";
      this._window.bottomKeepClear = 0;
    } else if (this._window.innerContentDiv.offsetHeight >= PropertiesForm2.MinHeightforShowingHelp + PropertiesForm2.HelpHeight && this._helpPanel.style.display != "") {
      this._helpPanel.style.display = "";
      this._window.bottomKeepClear = PropertiesForm2.HelpHeight;
    }
  }
  show() {
    this._window.show(this.bestWidth());
    this.windowResized();
  }
  hide() {
    YWidget.stopEdition();
    this._window.hide();
  }
  get panel() {
    return this._container;
  }
  refresh() {
    if (!this.visible)
      return;
    if (this.currentEditedDataSource == null)
      return;
    this.currentEditedDataSource.refresh();
  }
  refreshBanner() {
    if (this._hostWindow != null) {
      this.text = "Properties of " + this._hostWindow.Text;
    }
  }
  showWindow(hostWindow, structData, setvalueCallBack, getvalueCallBack, EditStoppedCallBack) {
    this._hostWindow = hostWindow;
    this._changeCallback = setvalueCallBack;
    this._getvalueCallback = getvalueCallBack;
    this.text = "Properties editor";
    this.show();
    this.refreshBanner();
    this.EditObject(structData, setvalueCallBack, getvalueCallBack, EditStoppedCallBack);
  }
  EditObject(structData, setvalueCallBack, getvalueCallBack, EditStoppedCallBack) {
    this._editorClosedCallback = EditStoppedCallBack;
    let helpYourselfMsg = "This is the property editor. Change any parameter you want. All changes are applied in real time.";
    if (!this.visible)
      return;
    this.help = "Please wait....";
    if (this.EditedDataSourceList.isInlist(structData)) {
      if (this.EditedDataSourceList.find(structData) == this.currentEditedDataSource) {
        this.help = helpYourselfMsg;
        return;
      }
    }
    if (this.currentEditedDataSource != null) {
      this.currentEditedDataSource.root.stopEdit();
      this.currentEditedDataSource.storeChilds(this._container.childNodes);
      while (this._container.firstChild) {
        this._container.removeChild(this._container.lastChild);
      }
    }
    let it;
    if (!this.EditedDataSourceList.isInlist(structData)) {
      let rootparam = new UIElementBaseParams(this._helpPanel, this, null, "root", "Root", "root node", "");
      it = new UIElement(rootparam);
      it.rootEditor = this;
      this.currentEditedDataSource = new EditedDataSource(structData, it);
      this.EditedDataSourceList.insert(structData, this.currentEditedDataSource);
      it.showLabel = false;
      it.expandable = true;
      it.ProcessNewType(structData);
      it.expanded = true;
    } else {
      this.currentEditedDataSource = this.EditedDataSourceList.find(structData);
      let childNodes = this.currentEditedDataSource.getStoredChilds();
      for (let i = 0; i < childNodes.length; i++) {
        this._container.appendChild(childNodes[i]);
      }
      this.currentEditedDataSource.refresh();
    }
    this.currentEditedDataSource.root.startEdit(setvalueCallBack, getvalueCallBack);
    this.currentEditedDataSource.root.resizeAll();
    this.help = helpYourselfMsg;
  }
  getConfigData() {
    let p = this._window.outterContentDiv.getBoundingClientRect();
    return "<PropertiesForm>\n<location x='" + p.left.toString() + "' y='" + p.top.toString() + "'/>\n<size     w='" + p.width.toString() + "' h='" + p.width.toString() + "'/>\n</PropertiesForm>\n";
  }
  Form1_SizeChanged(sender) {
    if (this.currentEditedDataSource == null)
      return;
    if (this.currentEditedDataSource.root != null)
      this.currentEditedDataSource.root.resizeAll();
  }
  valuechange(src) {
    let OriginalPropName = "";
    let fullpropname = "";
    let propType = "";
    if (this._changeCallback != null)
      this._changeCallback(src);
  }
};
PropertiesForm2.HelpHeight = Math.round(75 * constants.generalSizeCoef);
PropertiesForm2.MinHeightforShowingHelp = 175;
PropertiesForm2.testid = 0;

// obj/full/UIElements_rw.js
var UIElementBaseParams = class {
  constructor(p_descriptionLabel, p_parentNode, p_RootNode, p_internalname, p_label, p_description, p_isReadonlyCall) {
    this.expandable = false;
    this.isReadonlyCall = "";
    this.summary = null;
    this.structRoot = null;
    this.HelpZoneLabel = p_descriptionLabel;
    this.parentNode = p_parentNode;
    this.RootNode = p_RootNode;
    this.internalname = p_internalname;
    this.label = p_label;
    this.description = p_description;
    this.changeCausesParentRefresh = false;
    this.preExpanded = false;
    this.isReadonlyCall = p_isReadonlyCall;
  }
};
var PropPathinfo = class {
  constructor() {
    this.OriginalPropName = "";
    this.fullpropname = "";
    this.propType = "";
  }
};
var CustomAttributesExtractor = class {
  constructor(ps) {
    this.available = true;
    this.displayName = "unknown";
    this.category = "";
    this.displayDescription = "Not documented";
    this.prefinedValues = null;
    this.changeCausesParentRefresh = false;
    this.PreExpandedCategory = false;
    this.PreExpanded = false;
    this.summaryPropertyName = "";
    this.isReadOnlyCall = "";
    this.NotSavedInXML = false;
    this.ReadOnly = false;
    this.ParamCategorySummary = "";
    if ("OnlyAvailableon" in ps.Attributes)
      this.available = ps.Attributes["OnlyAvailableon"];
    if ("DisplayName" in ps.Attributes)
      this.displayName = ps.Attributes["DisplayName"];
    if ("CategoryAttribute" in ps.Attributes)
      this.category = ps.Attributes["CategoryAttribute"];
    if ("DescriptionAttribute" in ps.Attributes)
      this.displayDescription = ps.Attributes["DescriptionAttribute"];
    if ("AllowedValues" in ps.Attributes)
      this.prefinedValues = ps.Attributes["AllowedValues"];
    if ("ChangeCausesParentRefreshAttribute" in ps.Attributes)
      this.changeCausesParentRefresh = ps.Attributes["ChangeCausesParentRefreshAttribute"];
    if ("PreExpandedCategoryAttribute" in ps.Attributes)
      this.PreExpandedCategory = ps.Attributes["PreExpandedCategoryAttribute"];
    if ("PreExpandedAttribute" in ps.Attributes)
      this.PreExpanded = ps.Attributes["PreExpandedAttribute"];
    if ("ParamCategorySummaryAttribute" in ps.Attributes)
      this.summaryPropertyName = ps.Attributes["ParamCategorySummaryAttribute"];
    if ("IsReadonlyCallAttribute" in ps.Attributes)
      this.isReadOnlyCall = ps.Attributes["IsReadonlyCallAttribute"];
    if ("NotSavedInXMLAttribute" in ps.Attributes)
      this.NotSavedInXML = ps.Attributes["NotSavedInXMLAttribute"];
    if ("ReadOnlyAttribute " in ps.Attributes)
      this.ReadOnly = ps.Attributes["ReadOnlyAttribute "];
    if ("ParamCategorySummaryAttribute " in ps.Attributes)
      this.ParamCategorySummary = ps.Attributes["ParamCategorySummaryAttribute "];
  }
};
var UIElement = class extends EditorBaseDef {
  constructor(p) {
    super();
    this.name = "NoName";
    this._targetFullName = "unknowTargetName";
    this.ExpandableDepth = 0;
    this._expanded = false;
    this._expandButtonSide = 0;
    this._rootEditor = null;
    this._description = "";
    this.expandCtrl = null;
    this.mainlabel = null;
    this.mainText = null;
    this.subElementPanel = null;
    this._rootNode = null;
    this._parentNode = null;
    this._parentPanel = null;
    this._changeCausesParentRefresh = false;
    this._isReadOnlyCall = "";
    this._controlsAllocated = false;
    this.expandButtonInitDone = false;
    this.mainLabelInitDone = false;
    this.subElements = [];
    this._valueChangeCallback = null;
    this._getValueCallback = null;
    this._shown = true;
    this._summaryCallback = null;
    this._showLabel = false;
    this._expandable = false;
    this._preExpanded = false;
    this.name = p.label;
    this._targetFullName = p.internalname;
    this._helpZoneLabel = p.HelpZoneLabel;
    this._description = p.description;
    this._changeCausesParentRefresh = p.changeCausesParentRefresh;
    this._expandable = p.expandable;
    this._preExpanded = p.preExpanded;
    this._structRoot = p.structRoot;
    this._isReadOnlyCall = p.isReadonlyCall;
    this._summaryProperty = p.summary;
    if (UIElement.baseheight == 0) {
      UIElement.baseheight = 12;
      UIElement.expandableShift = UIElement.baseheight + 2;
      UIElement.scrollBarWidth = 20;
    }
    this._parentNode = p.parentNode;
    this._rootNode = p.RootNode == null ? this : p.RootNode;
  }
  get parentNode() {
    return this._parentNode;
  }
  get targetFullName() {
    return this._targetFullName;
  }
  get expandIcon() {
    return ressources.ExpandIcon(UIElement.defaultFontSize.toString(), false, false, false, false, "Click to expand");
  }
  get colapseIcon() {
    return ressources.ColapseIcon(UIElement.defaultFontSize.toString(), false, false, false, false, "Click to colapse");
  }
  removeFromEditor() {
  }
  get panel() {
    return this.subElementPanel;
  }
  get editorHelpText() {
    return "";
  }
  get isRootElement() {
    return this._rootNode == this;
  }
  addToEditor() {
    if (this.mainlabel != null) {
      for (let i = 0; i < this._parentPanel.children.length; i++) {
        if (this._parentPanel.children[i] == this.mainlabel)
          return;
      }
      this._parentPanel.appendChild(this.mainlabel);
      this._parentPanel.appendChild(this.subElementPanel);
    }
  }
  refresh() {
    if (this.mainText != null)
      this.mainText.innerText = this.name + this.getSummary();
    for (let i = 0; i < this.subElements.length; i++) {
      this.subElements[i].refresh();
    }
    if (this._rootNode != null && this._rootNode.rootEditor != null)
      this._rootNode.rootEditor.refreshBanner();
  }
  tabReOrder(index) {
    if (this._expandable && this.expandCtrl != null)
      this.expandCtrl.tabIndex = index++;
    this.subElements.forEach((e) => {
      index = e.tabReOrder(index);
    });
    return index;
  }
  triggerValueChangeCallback() {
    if (this._valueChangeCallback != null)
      this._valueChangeCallback(this);
  }
  scrollToMakeVisible() {
    if (this.mainlabel == null)
      return;
    if (this._parentPanel == null)
      return;
    this.mainlabel.scrollIntoView();
  }
  control_GotFocus(sender) {
    let extraHelp = this.editorHelpText;
    if (extraHelp != "")
      extraHelp = " " + extraHelp;
    this._helpZoneLabel.innerHTML = this._description + extraHelp;
  }
  control_LostFocus(sender) {
    this._helpZoneLabel.innerHTML = "";
  }
  preExpandIfNeeded() {
    if (this._parentNode != null && this._parentNode.expanded) {
      this.AllocateControls();
      if (this.expandable)
        this.initExpandButton();
      this.initMainLabel();
    }
    this.initExpandButton();
  }
  set rootEditor(value) {
    this._rootEditor = value;
  }
  get rootEditor() {
    return this._rootEditor;
  }
  initMainLabel() {
    if (this.mainlabel == null)
      return;
    if (this.mainLabelInitDone)
      return;
    this.ExpandableDepth = 0;
    let p = this;
    while (p != null) {
      if (p.expandable)
        this.ExpandableDepth++;
      p = p.parentNode;
    }
    this.mainText.innerText = this.name + this.getSummary();
    if (this.expandable && this._expandButtonSide == 0) {
      switch (this.ExpandableDepth) {
        case 1:
          this.mainlabel.style.backgroundColor = "Blue";
          this.mainText.style.color = "black";
          break;
        case 2:
          this.mainlabel.style.backgroundColor = "rgb(7,141,255)";
          this.mainText.style.color = "white";
          break;
        case 3:
          this.mainlabel.style.backgroundColor = "rgb(120,196,255)";
          break;
        case 4:
          this.mainlabel.style.backgroundColor = "rgb(213,237,255)";
          break;
        case 5:
          this.mainlabel.style.backgroundColor = "rgb(237,246,253)";
          break;
        default:
          this.mainlabel.style.backgroundColor = "rgb(246,251,255)";
          break;
      }
    } else {
      this.mainlabel.style.backgroundColor = "rgba( 0, 0, 0,0)";
    }
    this.mainLabelInitDone = true;
  }
  AllocateControls() {
    if (this._controlsAllocated)
      return;
    if (!this.isRootElement)
      this.parentNode.AllocateControls();
    this._parentPanel = this.parentNode.panel;
    if (this.mainlabel == null) {
      this.mainlabel = document.createElement("DIV");
      this.mainlabel.style.position = "relative";
      this.mainlabel.style.display = "inline-block;";
      this.mainlabel.style.left = "0px";
      this.mainlabel.style.padding = "2px 2px 2px 2px";
      this.mainlabel.style.overflow = "hidden";
      this.mainlabel.style.fontFamily = UIElement.defaultFontFamily;
      this.mainlabel.style.fontSize = UIElement.defaultFontSize.toString() + "px";
      this.mainlabel.style.right = "5px";
      this.mainlabel.style.whiteSpace = "nowrap";
      this.mainlabel.style.marginTop = "2px";
      this.mainlabel.style.backgroundColor = "yellow";
      this.mainText = document.createElement("SPAN");
      this.mainText.innerText = "Pouet";
      this.mainlabel.appendChild(this.mainText);
      this.mainlabel.style.display = this.isRootElement ? "none" : "";
      this.initMainLabel();
      if (this._parentPanel == null) {
        debugger;
      }
      this._parentPanel.appendChild(this.mainlabel);
    }
    if (this._expandable && this.expandCtrl == null) {
      this.expandCtrl = document.createElement("ANCHOR");
      if (this._expandButtonSide == 0) {
        this.mainlabel.insertBefore(this.expandCtrl, this.mainText);
      }
      this.initExpandButton();
      this.subElementPanel = document.createElement("DIV");
      this.subElementPanel.style.position = "relative";
      this.subElementPanel.style.display = "inline-block;";
      this.subElementPanel.style.left = this.isRootElement ? "0px" : "5px";
      this.subElementPanel.style.padding = "2px 2px 2px 2px";
      this.subElementPanel.style.right = "5px";
      this.subElementPanel.style.display = "none";
      this.subElementPanel.style.marginTop = "2px";
      this.subElementPanel.style.marginRight = "2px";
      this._parentPanel.appendChild(this.subElementPanel);
    }
    this._controlsAllocated = true;
  }
  initExpandButton() {
    if (this.expandCtrl == null)
      return;
    if (this.expandButtonInitDone)
      return;
    this.expandCtrl.innerHTML = this.expandIcon;
    this.expandCtrl.style.top = "0px";
    this.expandCtrl.style.left = "0px";
    this.expandCtrl.style.cursor = "pointer";
    this.expandCtrl.style.backgroundColor = "white";
    this.expandCtrl.style.marginRight = "3px";
    this.expandCtrl.style.paddingLeft = "0px";
    this.expandCtrl.style.paddingRight = "0px";
    this.expandCtrl.style.paddingTop = "1px";
    this.expandCtrl.style.marginTop = "0px";
    this.expandCtrl.style.marginBottom = "0px";
    this.expandCtrl.style.paddingBottom = "0px";
    this.expandCtrl.style.paddingRight = "0px";
    this.expandCtrl.addEventListener("click", () => {
      this.ToggleExpand();
    });
    this.expandCtrl.addEventListener("keyup", (e) => {
      if (e.key === "Enter" || e.key === " ")
        this.ToggleExpand();
    });
    this.expandCtrl.addEventListener("focusin", () => {
      this.control_GotFocus(this);
    });
    this.expandCtrl.addEventListener("focusout", () => {
      this.control_LostFocus(this);
    });
    this.expandButtonInitDone = true;
  }
  get rowHeight() {
    return UIElement.baseheight;
  }
  ExtractPropPath(info) {
    let index = -1;
    let path = [];
    let p = this;
    info.OriginalPropName = p.targetFullName;
    do {
      info.fullpropname = p.targetFullName;
      index = info.fullpropname.indexOf("_");
      if (index < 0) {
        if (info.fullpropname != UIElement.ARTIFICIALSECTIONNAME)
          path.splice(0, 0, info.fullpropname);
        p = p.parentNode;
        if (p == null)
          throw "invalid Property name";
      }
    } while (index < 0);
    info.propType = info.fullpropname.substring(0, index);
    let propname = info.fullpropname.substring(index + 1);
    path.splice(0, 0, propname);
    return path;
  }
  startEdit(setcallback, getCallback) {
    this.addToEditor();
    this._valueChangeCallback = setcallback;
    this._getValueCallback = getCallback;
    this.subElements.forEach((item) => {
      item.startEdit(setcallback, getCallback);
    });
  }
  stopEdit() {
    this.removeFromEditor();
    this._valueChangeCallback = null;
    this._getValueCallback = null;
    this.subElements.forEach((item) => {
      item.stopEdit();
    });
  }
  expand() {
    this.subElements.forEach((e) => {
      e.AllocateControls();
      e.show();
    });
    this._rootNode.tabReOrder(0);
    this._expanded = true;
    this.subElementPanel.style.display = "";
    this.expandCtrl.innerHTML = this.colapseIcon;
  }
  colapse() {
    this.subElementPanel.style.display = "none";
    this.expandCtrl.innerHTML = this.expandIcon;
  }
  get expanded() {
    return this._expanded;
  }
  set expanded(value) {
    this._expanded = value;
    if (this._expanded) {
      this.expand();
    } else {
      this.colapse();
    }
    this._rootNode.resizeAll();
  }
  ToggleExpand() {
    this.expanded = !this.expanded;
  }
  getSummary() {
    if (this._summaryProperty != null) {
      return " (" + Reflect.get(this._structRoot, this._summaryProperty.name) + ")";
    }
    return "";
  }
  sensorList() {
    let res = [];
    sensorsManager.sensorList.forEach((s) => {
      res.push(s);
    });
    return res;
  }
  ProcessNewType(dataStucture) {
    let subsections = {};
    this._structRoot = dataStucture;
    let toExpand = [];
    let properties = GenericProperties.getAllProperties(dataStucture);
    for (let i = 0; i < properties.byIndex.length; i++) {
      let ps = properties.byIndex[i];
      if (ps.isWritable) {
        let attr = new CustomAttributesExtractor(ps);
        if (attr.available) {
          let section = this;
          if (attr.category != "") {
            if (attr.category in subsections) {
              section = subsections[attr.category];
            } else {
              let sectionparam = new UIElementBaseParams(this._helpZoneLabel, this, this._rootNode, UIElement.ARTIFICIALSECTIONNAME, attr.category, attr.category + " section, expand for more...", "");
              sectionparam.preExpanded = attr.PreExpandedCategory;
              sectionparam.expandable = true;
              sectionparam.structRoot = dataStucture;
              if (attr.summaryPropertyName != "") {
                sectionparam.summary = ps;
              }
              section = new UIElement(sectionparam);
              if (attr.PreExpandedCategory)
                toExpand.push(section);
              section.showLabel = true;
              subsections[attr.category] = section;
              this.addSubElement(section);
            }
          }
          let elParam = new UIElementBaseParams(this._helpZoneLabel, section, this._rootNode, ps.name, attr.displayName, attr.displayDescription, attr.isReadOnlyCall);
          elParam.preExpanded = attr.PreExpanded;
          elParam.changeCausesParentRefresh = attr.changeCausesParentRefresh;
          let targetName = this._targetFullName;
          let targetPrefix = "";
          let p = targetName.indexOf("_");
          if (p >= 0) {
            targetPrefix = targetName.substring(0, p);
            targetName = targetName.substring(p + 1);
          }
          if (ps.isEnum) {
            let s = new UIElementEnum(elParam, dataStucture, ps);
            section.addSubElement(s);
          } else {
            switch (ps.type) {
              case "number":
                if (attr.prefinedValues == null) {
                  let n = new UIElementNumber(elParam, dataStucture, ps);
                  section.addSubElement(n);
                } else {
                  let s2 = new UIElementList(elParam, dataStucture, ps, () => {
                    return attr.prefinedValues;
                  });
                  section.addSubElement(s2);
                }
                break;
              case "boolean":
                let b = new UIElementBoolean(elParam, dataStucture, ps);
                section.addSubElement(b);
                break;
              case doubleNan.name:
                let d = new UIElementDoubleNan(elParam, dataStucture, ps);
                section.addSubElement(d);
                break;
              case NullYSensor.name:
              case CustomYSensor.name:
                let s = new UIElementList(elParam, dataStucture, ps, () => {
                  return this.sensorList();
                });
                section.addSubElement(s);
                break;
              case YColor.name:
                let c = new UIElementColor(elParam, dataStucture, ps);
                section.addSubElement(c);
                break;
              case xAxisPosition.name:
                let p2 = new UIElementMarkerPos(elParam, dataStucture, ps);
                section.addSubElement(p2);
                break;
              case "string":
                if (attr.prefinedValues == null) {
                  let s2 = new UIElementString(elParam, dataStucture, ps);
                  section.addSubElement(s2);
                } else {
                  let s2 = new UIElementList(elParam, dataStucture, ps, () => {
                    return attr.prefinedValues;
                  });
                  section.addSubElement(s2);
                }
                break;
              default:
                {
                  elParam.expandable = true;
                  elParam.preExpanded = attr.PreExpanded;
                  let subobjectsection = new UIElement(elParam);
                  if (attr.PreExpanded)
                    toExpand.push(subobjectsection);
                  subobjectsection.showLabel = true;
                  section.addSubElement(subobjectsection);
                  subobjectsection.ProcessNewType(dataStucture[ps.name]);
                }
                break;
            }
          }
        }
      } else {
        if (ps.name == "summary") {
          this._summaryProperty = ps;
        }
      }
    }
    if (this._summaryProperty != null)
      this.refresh();
    toExpand.forEach((e) => {
      e.expand();
    });
  }
  show() {
    this._shown = true;
    if (this.mainlabel != null)
      this.mainlabel.style.display = "";
    if (this.expandCtrl != null)
      this.expandCtrl.style.display = this._expandable ? "" : "hidden";
    if (this.expanded) {
      this.subElements.forEach((e) => {
        e.show();
      });
    }
  }
  hide() {
    this._shown = false;
    if (this.mainlabel != null)
      this.mainlabel.style.display = "hidden";
    if (this.expandCtrl != null)
      this.expandCtrl.style.display = this._expandable ? "hidden" : "";
    this.subElements.forEach((e) => {
      e.hide();
    });
  }
  ExpandCtrl_Click_expand(sender) {
    this.expanded = !this._expanded;
  }
  resizeAll() {
    this.resize(0, 0, 0, 0);
    if (this.expanded) {
      this.subElements.forEach((e) => {
        e.resizeAll();
      });
    }
  }
  get showLabel() {
    return this._showLabel;
  }
  set showLabel(value) {
    this._showLabel = value;
    if (this.expandCtrl != null)
      this.expandCtrl.style.display = value && this._expandable ? "" : "hidden";
  }
  get expandable() {
    return this._expandable;
  }
  set expandable(value) {
    this._expandable = value;
    if (!value)
      return;
    if (this.expandCtrl == null) {
      this.AllocateControls();
      this.initExpandButton();
    }
    this.expandCtrl.style.display = value && this._showLabel ? "" : "hidden";
  }
  addSubElement(node) {
    this.subElements.push(node);
  }
  computeHeight() {
    return 0;
  }
  resize(top2, left1, left2, width) {
    return 0;
  }
};
UIElement.defaultFontFamily = constants.generalFontFamily;
UIElement.defaultFontSize = constants.generalFontSize;
UIElement.ARTIFICIALSECTIONNAME = "-ignore-";
UIElement.baseheight = 0;
UIElement.indentation = 16;
UIElement.expandableShift = 0;
UIElement.scrollBarWidth = 0;
UIElement.expandableVerticalOffset = 2;
var UIElementGeneric = class extends UIElement {
  constructor(p, dataContainer, prop) {
    super(p);
    this.input = null;
    this.select = null;
    this._prop = prop;
    this._dataContainer = dataContainer;
    this._showLabel = true;
    if (this._preExpanded)
      this.AllocateControls();
    if (this._expandable && this._preExpanded)
      this.expand();
  }
  removeFromEditor() {
    super.removeFromEditor();
  }
  tabReOrder(index) {
    if (this.input != null)
      this.input.tabIndex = index++;
    this.subElements.forEach((e) => {
      index = e.tabReOrder(index);
    });
    return index;
  }
  addToEditor() {
    super.addToEditor();
  }
  show() {
    super.show();
    if (this.input != null)
      this.input.style.visibility = "";
  }
  checkForReadOnly() {
    if (this.input == null && this.select == null)
      return;
    if (this._isReadOnlyCall != "") {
      let ro = Reflect.get(this._dataContainer, this._isReadOnlyCall);
      if (this.input != null)
        this.input.disabled = ro;
      if (this.select != null)
        this.select.disabled = ro;
    }
  }
  hide() {
    if (this.input != null)
      this.input.style.visibility = "hidden";
    super.hide();
  }
  resize(top2, left1, left2, width) {
    return 0;
  }
};
var UIElementString = class extends UIElementGeneric {
  constructor(p, dataContainer, prop) {
    super(p, dataContainer, prop);
    this._value = "";
    this.preExpandIfNeeded();
  }
  AllocateControls() {
    super.AllocateControls();
    if (this.input == null) {
      this.input = document.createElement("INPUT");
      this.input.type = "input";
      this.input.value = Reflect.get(this._dataContainer, this._prop.name);
      this.input.style.position = "absolute";
      this.input.style.marginTop = "0px";
      this.input.style.marginBottom = "0px";
      this.input.style.fontFamily = UIElement.defaultFontFamily;
      this.input.style.fontSize = UIElement.defaultFontSize.toString() + "px";
      this.input.style.border = "1px solid grey";
      this.input.style.borderRadius = "1px";
      this.input.style.top = "0px";
      this.input.style.right = "3px";
      this.input.style.width = "50%";
      this.mainlabel.appendChild(this.input);
      new InputFieldManager(this.input, 0, true, Number.NaN, Number.NaN, () => {
        this.Text_TextChanged(null);
      });
      this.input.addEventListener("focusin", () => {
        this.control_GotFocus(this);
      });
      this.input.addEventListener("focusout", () => {
        this.control_LostFocus(this);
      });
      this.checkForReadOnly();
    }
  }
  refresh() {
    if (this.input == null)
      return;
    if (this._getValueCallback == null)
      return;
    let value = this._getValueCallback(this);
    if (value == null)
      return;
    let s = value.toString();
    if (this.input != null) {
      if (s != this.input.value)
        this.input.value = s;
    }
    this.checkForReadOnly();
  }
  Text_TextChanged(sender) {
    if (this.input != null) {
      this._value = this.input.value;
      Reflect.set(this._dataContainer, this._prop.name, this._value);
      if (this._valueChangeCallback != null)
        this._valueChangeCallback(this);
      if (this._changeCausesParentRefresh)
        this.parentNode.refresh();
    }
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value;
    this.input.value = value;
  }
  resize(top2, left1, left2, width) {
    this.mainlabel.style.height = this.input.offsetHeight.toString() + "px";
    return 0;
  }
};
var UIElementNumber = class extends UIElementGeneric {
  constructor(p, dataContainer, prop) {
    super(p, dataContainer, prop);
    this._value = 0;
    this.preExpandIfNeeded();
  }
  AllocateControls() {
    super.AllocateControls();
    if (this.input == null) {
      this.input = document.createElement("INPUT");
      this.input.type = "input";
      this.input.value = Reflect.get(this._dataContainer, this._prop.name);
      this.input.style.textAlign = "right";
      this.input.style.position = "absolute";
      this.input.style.marginTop = "0px";
      this.input.style.marginBottom = "0px";
      this.input.style.fontFamily = UIElement.defaultFontFamily;
      this.input.style.fontSize = UIElement.defaultFontSize.toString() + "px";
      this.input.type = "number";
      this.input.style.border = "1px solid grey";
      this.input.style.borderRadius = "1px";
      this.input.style.top = "0px";
      this.input.style.right = "3px";
      this.input.style.width = "50%";
      this.mainlabel.appendChild(this.input);
      new InputFieldManager(this.input, 4, false, Number.NaN, Number.NaN, () => {
        this.Text_TextChanged(null);
      });
      this.input.addEventListener("focusin", () => {
        this.control_GotFocus(this);
      });
      this.input.addEventListener("focusout", () => {
        this.control_LostFocus(this);
      });
      this.checkForReadOnly();
    }
  }
  refresh() {
    if (this.input == null)
      return;
    if (this._getValueCallback == null)
      return;
    let s = this._getValueCallback(this);
    if (s == null)
      return;
    if (this.input != null) {
      if (s != parseFloat(this.input.value))
        this.input.value = s.toString();
    }
    this.checkForReadOnly();
  }
  Text_TextChanged(sender) {
    if (this.input != null) {
      this._value = parseFloat(this.input.value);
      Reflect.set(this._dataContainer, this._prop.name, this._value);
      if (this._valueChangeCallback != null)
        this._valueChangeCallback(this);
      if (this._changeCausesParentRefresh)
        this.parentNode.refresh();
    }
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value;
    this.input.value = value.toString();
  }
  resize(top2, left1, left2, width) {
    this.mainlabel.style.height = this.input.offsetHeight.toString() + "px";
    return 0;
  }
};
var UIElementBoolean = class extends UIElementGeneric {
  constructor(p, dataContainer, prop) {
    super(p, dataContainer, prop);
    this._text = null;
    this._value = false;
    this.preExpandIfNeeded();
  }
  AllocateControls() {
    super.AllocateControls();
    if (this.input == null) {
      let span = document.createElement("SPAN");
      span.style.position = "absolute";
      span.style.display = "inline-block";
      span.style.width = "50%";
      span.style.right = "0px";
      this.mainlabel.appendChild(span);
      this.input = document.createElement("INPUT");
      this.input.type = "input";
      this.input.checked = Reflect.get(this._dataContainer, this._prop.name);
      this.input.style.textAlign = "right";
      this.input.style.display = "inline";
      this.input.style.marginTop = "0px";
      this.input.style.marginBottom = "0px";
      this.input.type = "checkbox";
      this.input.style.transform = "scale(" + constants.generalSizeCoef.toString() + ")";
      this.input.style.marginRight = Math.round(5 * constants.generalSizeCoef).toString() + "px";
      this.input.style.top = "0px";
      this.input.style.border = "1px solid grey";
      this.input.style.borderRadius = "1px";
      span.appendChild(this.input);
      this.input.addEventListener("keyup", (e) => {
        if (e.key === " ")
          this.value_TextChanged(null);
      });
      this.input.addEventListener("change", () => {
        this.value_TextChanged(null);
      });
      this._text = document.createElement("SPAN");
      this._text.style.display = "inline";
      this._text.style.fontFamily = UIElement.defaultFontFamily;
      this._text.style.fontSize = UIElement.defaultFontSize.toString() + "px";
      span.appendChild(this._text);
      this.updateText();
      this.input.addEventListener("focusin", () => {
        this.control_GotFocus(this);
      });
      this.input.addEventListener("focusout", () => {
        this.control_LostFocus(this);
      });
      this.checkForReadOnly();
    }
  }
  updateText() {
    this._text.innerText = this.input.checked ? "Enabled" : "Disabled";
  }
  refresh() {
    if (this.input == null)
      return;
    this.checkForReadOnly();
    if (this._getValueCallback == null)
      return;
    let v = this._getValueCallback(this);
    if (v == null)
      return;
    let b = v;
    if (this.input != null) {
      this.input.checked = b.valueOf();
      this.updateText();
    }
  }
  value_TextChanged(sender) {
    if (this.input != null) {
      this._value = this.input.checked;
      this.updateText();
      Reflect.set(this._dataContainer, this._prop.name, this._value);
      if (this._valueChangeCallback != null)
        this._valueChangeCallback(this);
      if (this._changeCausesParentRefresh)
        this.parentNode.refresh();
    }
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value;
    this.input.checked = value;
    this.updateText();
  }
  resize(top2, left1, left2, width) {
    return 0;
  }
};
var UIElementDoubleNan = class extends UIElementGeneric {
  constructor(p, dataContainer, prop) {
    super(p, dataContainer, prop);
    this._value = 0;
    this.preExpandIfNeeded();
  }
  AllocateControls() {
    super.AllocateControls();
    if (this.input == null) {
      this.input = document.createElement("INPUT");
      this.input.type = "input";
      this.input.value = Reflect.get(this._dataContainer, this._prop.name).toString();
      this.input.style.textAlign = "right";
      this.input.style.position = "absolute";
      this.input.style.marginTop = "0px";
      this.input.style.marginBottom = "0px";
      this.input.style.fontFamily = UIElement.defaultFontFamily;
      this.input.style.fontSize = UIElement.defaultFontSize.toString() + "px";
      this.input.type = "number";
      this.input.style.border = "1px solid grey";
      this.input.style.borderRadius = "1px";
      this.input.style.top = "0px";
      this.input.style.right = "3px";
      this.input.style.width = "50%";
      this.mainlabel.appendChild(this.input);
      new InputFieldManager(this.input, 4, true, Number.NaN, Number.NaN, () => {
        this.Text_TextChanged(null);
      });
      this.input.addEventListener("focusin", () => {
        this.control_GotFocus(this);
      });
      this.input.addEventListener("focusout", () => {
        this.control_LostFocus(this);
      });
      this.checkForReadOnly();
    }
  }
  refresh() {
    if (this.input == null)
      return;
    if (this._getValueCallback == null)
      return;
    let s = this._getValueCallback(this).toString();
    if (this.input != null) {
      if (s != this.input.value)
        this.input.value = s;
    }
    this.checkForReadOnly();
  }
  Text_TextChanged(sender) {
    if (this.input != null) {
      this._value = this.input.value == "" ? Number.NaN : parseFloat(this.input.value);
      Reflect.set(this._dataContainer, this._prop.name, new doubleNan(this._value));
      if (this._valueChangeCallback != null)
        this._valueChangeCallback(this);
      if (this._changeCausesParentRefresh)
        this.parentNode.refresh();
    }
  }
  get value() {
    return new doubleNan(this._value);
  }
  set value(value) {
    this._value = value.value;
    this.input.value = value.toString();
  }
  resize(top2, left1, left2, width) {
    this.mainlabel.style.height = this.input.offsetHeight.toString() + "px";
    return 0;
  }
};
var UIElementEnum = class extends UIElementGeneric {
  constructor(p, dataContainer, prop) {
    super(p, dataContainer, prop);
    this.allValues = [];
    this._value = "";
    this.preExpandIfNeeded();
  }
  AllocateControls() {
    super.AllocateControls();
    if (this.select == null) {
      this.select = document.createElement("SELECT");
      let enumvalue = Reflect.get(this._dataContainer, this._prop.name);
      this.allValues = enumvalue.sibblings;
      for (let i = 0; i < this.allValues.length; i++) {
        let opt = document.createElement("OPTION");
        opt.text = this.allValues[i].description;
        opt.value = this.allValues[i].toString;
        this.select.add(opt, null);
      }
      this.select.value = enumvalue.toString;
      this.select.style.position = "absolute";
      this.select.style.marginTop = "0px";
      this.select.style.marginBottom = "0px";
      this.select.style.fontFamily = UIElement.defaultFontFamily;
      this.select.style.fontSize = UIElement.defaultFontSize.toString() + "px";
      this.select.style.top = "0px";
      this.select.style.right = "3px";
      this.select.style.width = "50%";
      this.mainlabel.appendChild(this.select);
      this.select.addEventListener("change", () => {
        this.valueChanged(null);
      });
      this.select.addEventListener("focusin", () => {
        this.control_GotFocus(this);
      });
      this.select.addEventListener("focusout", () => {
        this.control_LostFocus(this);
      });
      this.checkForReadOnly();
    }
  }
  refresh() {
    if (this.select == null)
      return;
    if (this._getValueCallback == null)
      return;
    let value = this._getValueCallback(this);
    let s = value.toString;
    if (this.select != null) {
      if (s != this.select.value)
        this.select.value = s;
    }
    this.checkForReadOnly();
  }
  valueChanged(sender) {
    if (this.select != null) {
      this._value = this.select.value;
      let it = null;
      for (let i = 0; i < this.allValues.length; i++) {
        if (this.allValues[i].toString == this._value)
          it = this.allValues[i];
      }
      if (it != null)
        Reflect.set(this._dataContainer, this._prop.name, it);
      if (this._valueChangeCallback != null)
        this._valueChangeCallback(this);
      if (this._changeCausesParentRefresh)
        this.parentNode.refresh();
    }
  }
  tabReOrder(index) {
    if (this.select != null)
      this.select.tabIndex = index++;
    return index;
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value;
    this.select.value = value;
  }
  resize(top2, left1, left2, width) {
    this.mainlabel.style.height = this.select.offsetHeight.toString() + "px";
    return 0;
  }
};
var UIElementList = class extends UIElementGeneric {
  constructor(p, dataContainer, prop, allowedValues) {
    super(p, dataContainer, prop);
    this._refreshCallback = null;
    this._indexedValue = true;
    this.allValues = [];
    this.valueType = "";
    this._value = "";
    this._refreshCallback = allowedValues;
    this.preExpandIfNeeded();
  }
  AllocateControls() {
    super.AllocateControls();
    if (this.select == null) {
      this.allValues = this._refreshCallback();
      this.select = document.createElement("SELECT");
      let value = Reflect.get(this._dataContainer, this._prop.name);
      this.valueType = typeof value;
      this._indexedValue = typeof value == "number" && typeof this.allValues[0] != "number";
      let found = false;
      let first = null;
      for (let i = 0; i < this.allValues.length; i++) {
        let opt = document.createElement("OPTION");
        if (i == 0)
          first = opt;
        opt.text = this.allValues[i].toString();
        opt.value = this._indexedValue ? i : this.allValues[i];
        this.select.add(opt, null);
        if (opt.value.toString() == value.toString())
          found = true;
      }
      if (!found && !this._indexedValue) {
        let opt = document.createElement("OPTION");
        opt.text = value.toString();
        opt.value = value;
        this.select.add(opt, first);
      }
      this.select.value = value;
      this.select.style.position = "absolute";
      this.select.style.marginTop = "0px";
      this.select.style.marginBottom = "0px";
      this.select.style.fontFamily = UIElement.defaultFontFamily;
      this.select.style.fontSize = UIElement.defaultFontSize.toString() + "px";
      this.select.style.top = "0px";
      this.select.style.right = "3px";
      this.select.style.width = "50%";
      this.mainlabel.appendChild(this.select);
      this.select.addEventListener("change", () => {
        this.valueChanged(null);
      });
      this.select.addEventListener("focusin", () => {
        this.control_GotFocus(this);
      });
      this.select.addEventListener("focusout", () => {
        this.control_LostFocus(this);
      });
      this.checkForReadOnly();
    }
  }
  refresh() {
    if (this.select == null)
      return;
    if (this._getValueCallback == null)
      return;
    this.allValues = this._refreshCallback();
    for (let i = 0; i < this.allValues.length; i++) {
      let opt = i < this.select.options.length ? this.select.options[i] : document.createElement("OPTION");
      opt.text = this.allValues[i].toString();
      opt.value = this._indexedValue ? i : this.allValues[i];
      if (i >= this.select.options.length)
        this.select.add(opt, null);
    }
    while (this.allValues.length < this.select.options.length) {
      this.select.options[this.select.options.length - 1].remove();
    }
    let v = Reflect.get(this._dataContainer, this._prop.name);
    if (v == null)
      return;
    if (this._indexedValue) {
      let it = Number(v).toString();
      if (this.select.value != it)
        this.select.value = it;
    } else {
      let it = v.toString();
      if (this.select.value != it)
        this.select.value = it;
    }
    this.checkForReadOnly();
  }
  valueChanged(sender) {
    if (this.select != null) {
      this._value = this.select.value;
      if (this.valueType == "number") {
        let it = parseInt(this._value);
        if (it >= 0)
          Reflect.set(this._dataContainer, this._prop.name, it);
      } else {
        let it = "";
        for (let i = 0; i < this.allValues.length; i++) {
          if (this.allValues[i] == this._value)
            it = this.allValues[i];
        }
        if (it != "")
          Reflect.set(this._dataContainer, this._prop.name, it);
      }
      if (this._valueChangeCallback != null)
        this._valueChangeCallback(this);
      if (this._changeCausesParentRefresh) {
        this.parentNode.refresh();
      }
    }
  }
  tabReOrder(index) {
    if (this.select != null)
      this.select.tabIndex = index++;
    return index;
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value;
    this.select.value = value;
  }
  resize(top2, left1, left2, width) {
    this.mainlabel.style.height = this.select.offsetHeight.toString() + "px";
    return 0;
  }
};
var UIElementColor = class extends UIElementGeneric {
  constructor(p, dataContainer, prop) {
    super(p, dataContainer, prop);
    this.colorSample = null;
    this.colorEditor = null;
    this.colorPreview = null;
    this.currentColor = null;
    this._value = "";
    this.preExpandIfNeeded();
  }
  get expandIcon() {
    return ressources.DotDotDotIcon(UIElement.defaultFontSize.toString(), false, false, false, false, "Click to open color chooser");
  }
  get colapseIcon() {
    return ressources.DotDotDotIcon(UIElement.defaultFontSize.toString(), false, false, false, false, "Click to close color chooser");
  }
  AllocateControls() {
    this._expandable = true;
    this._expandButtonSide = 1;
    super.AllocateControls();
    if (this.input == null) {
      let table = document.createElement("TABLE");
      table.style.position = "absolute";
      table.style.top = "0px";
      table.style.right = "3px";
      table.style.width = "50%";
      table.style.borderCollapse = "collapse";
      let tr = document.createElement("TR");
      table.appendChild(tr);
      let td1 = document.createElement("TD");
      tr.appendChild(td1);
      this.colorSample = document.createElement("Div");
      this.colorSample.style.display = "inline-block";
      this.colorSample.style.border = "1px solid black";
      this.colorSample.style.marginRight = "1px";
      this.colorSample.style.marginTop = "0px";
      this.colorSample.style.width = "16px";
      this.colorSample.style.height = "16px";
      this.colorSample.style.top = "0px";
      this.colorSample.style.bottom = "0px";
      this.colorPreview = new ColorSampler(this.colorSample, null);
      td1.appendChild(this.colorSample);
      let td2 = document.createElement("TD");
      td2.style.width = "100%";
      tr.appendChild(td2);
      this.input = document.createElement("INPUT");
      this.input.type = "input";
      this.currentColor = Reflect.get(this._dataContainer, this._prop.name);
      this.colorPreview.color = this.currentColor;
      this.input.value = this.currentColor.toString();
      this.input.style.marginTop = "0px";
      this.input.style.marginBottom = "0px";
      this.input.style.width = "100%";
      this.input.style.border = "1px solid grey";
      this.input.style.borderRadius = "1px";
      this.input.style.fontFamily = UIElement.defaultFontFamily;
      this.input.style.fontSize = UIElement.defaultFontSize.toString() + "px";
      td2.appendChild(this.input);
      let td3 = document.createElement("TD");
      td3.style.paddingLeft = "5px";
      tr.appendChild(td3);
      td3.appendChild(this.expandCtrl);
      this.mainlabel.appendChild(table);
      new InputFieldManager(this.input, 7, false, Number.NaN, Number.NaN, (sender, refreshInput) => {
        this.Text_TextChanged(sender, refreshInput);
      });
      this.input.addEventListener("focusin", () => {
        this.control_GotFocus(this);
      });
      this.input.addEventListener("focusout", () => {
        this.control_LostFocus(this);
      });
      this.checkForReadOnly();
    }
  }
  expand() {
    if (this.colorEditor == null) {
      this.subElementPanel.style.marginLeft = "20px";
      this.colorEditor = new colorEditor(this.subElementPanel, UIElement.defaultFontSize, this.currentColor, (c) => {
        this.coloredited(c);
      });
    }
    this._rootNode.tabReOrder(0);
    this._expanded = true;
    this.subElementPanel.style.display = "";
    this.expandCtrl.innerHTML = this.colapseIcon;
  }
  colapse() {
    this.subElementPanel.style.display = "none";
    this.expandCtrl.innerHTML = this.expandIcon;
  }
  coloredited(newColor) {
    this.currentColor = newColor.clone();
    this.colorPreview.color = this.currentColor;
    this.input.value = this.currentColor.toString();
    Reflect.set(this._dataContainer, this._prop.name, this.currentColor);
    if (this._valueChangeCallback != null)
      this._valueChangeCallback(this);
    if (this._changeCausesParentRefresh)
      this.parentNode.refresh();
  }
  refresh() {
    if (this.input == null)
      return;
    if (this._getValueCallback == null)
      return;
    let c = this._getValueCallback(this);
    if (c != null) {
      if (this.colorPreview != null)
        this.colorPreview.color = c;
      if (this.input != null) {
        let s = c.toString();
        if (s != this.input.value)
          this.input.value = s;
      }
    }
    this.checkForReadOnly();
  }
  Text_TextChanged(sender, refreshInput) {
    if (this.input != null) {
      this._value = this.input.value;
      let c = YColor.FromString(this._value);
      if (c != null) {
        this.colorPreview.color = c;
        this.currentColor = c;
        if (this.colorEditor != null)
          this.colorEditor.color = c;
        Reflect.set(this._dataContainer, this._prop.name, c);
        if (refreshInput)
          this.input.value = c.toString();
        if (this._valueChangeCallback != null)
          this._valueChangeCallback(this);
        if (this._changeCausesParentRefresh)
          this.parentNode.refresh();
      }
    }
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value;
    this.input.value = value;
  }
  resize(top2, left1, left2, width) {
    let h = this.input.offsetHeight;
    this.mainlabel.style.height = h.toString() + "px";
    return 0;
  }
};
var UIElementMarkerPos = class extends UIElementGeneric {
  constructor(p, dataContainer, prop) {
    super(p, dataContainer, prop);
    this._cachedValue = null;
    this._value = "";
    this.preExpandIfNeeded();
  }
  static expandIconSVG(size) {
    return ressources.targetIcon(size.toString(), false, false, false, false, "Click to place marker on graph");
  }
  get expandIcon() {
    return UIElementMarkerPos.expandIconSVG(UIElement.defaultFontSize);
  }
  get colapseIcon() {
    return UIElementMarkerPos.expandIconSVG(UIElement.defaultFontSize);
  }
  AllocateControls() {
    this._expandable = true;
    this._expandButtonSide = 1;
    super.AllocateControls();
    if (this.input == null) {
      let table = document.createElement("TABLE");
      table.style.position = "absolute";
      table.style.top = "0px";
      table.style.right = "3px";
      table.style.width = "50%";
      table.style.borderCollapse = "collapse";
      let tr = document.createElement("TR");
      table.appendChild(tr);
      let td2 = document.createElement("TD");
      td2.style.width = "100%";
      tr.appendChild(td2);
      this.input = document.createElement("INPUT");
      this.input.type = "input";
      this._cachedValue = Reflect.get(this._dataContainer, this._prop.name);
      this.input.value = this._cachedValue.toString();
      this.input.style.marginTop = "0px";
      this.input.style.marginBottom = "0px";
      this.input.style.textAlign = "right";
      this.input.style.width = "100%";
      this.input.style.border = "1px solid grey";
      this.input.style.borderRadius = "1px";
      this.input.style.fontFamily = UIElement.defaultFontFamily;
      this.input.style.fontSize = UIElement.defaultFontSize.toString() + "px";
      this.input.addEventListener("keyup", () => {
        this.Text_TextChanged(null, true);
      });
      this.input.addEventListener("change", () => {
        this.Text_TextChanged(null, false);
      });
      td2.appendChild(this.input);
      let td3 = document.createElement("TD");
      td3.style.paddingLeft = "5px";
      tr.appendChild(td3);
      td3.appendChild(this.expandCtrl);
      this.mainlabel.appendChild(table);
      this.input.addEventListener("focusin", () => {
        this.control_GotFocus(this);
      });
      this.input.addEventListener("focusout", () => {
        this.control_LostFocus(this);
      });
      this.checkForReadOnly();
    }
  }
  expand() {
    let value = Reflect.get(this._dataContainer, this._prop.name);
    this.expanded = false;
    value.capture = true;
    Reflect.set(this._dataContainer, this._prop.name, value);
    if (this._valueChangeCallback != null)
      this._valueChangeCallback(this);
  }
  colapse() {
  }
  refresh() {
    if (this.input == null)
      return;
    if (this._getValueCallback == null)
      return;
    this._cachedValue = this._getValueCallback(this);
    if (this.input != null) {
      this.input.value = this._cachedValue.toString();
    }
    this.checkForReadOnly();
  }
  Text_TextChanged(sender, refreshInput) {
    let parsedValue = this._cachedValue.TryParse(this.input.value);
    if (parsedValue.success) {
      this._cachedValue.value = parsedValue.result;
      Reflect.set(this._dataContainer, this._prop.name, this._cachedValue);
      if (this._valueChangeCallback != null)
        this._valueChangeCallback(this);
      if (this._changeCausesParentRefresh)
        this.parentNode.refresh();
    }
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value;
    this.input.value = value;
  }
  resize(top2, left1, left2, width) {
    let h = this.input.offsetHeight;
    this.mainlabel.style.height = h.toString() + "px";
    return 0;
  }
};
var InputFieldManager = class {
  constructor(input, type, allowEmpty, min, max, callback) {
    this._allowEmpty = false;
    this._min = Number.NaN;
    this._max = Number.NaN;
    this._callback = null;
    this._input = input;
    this._type = type;
    this._allowEmpty = allowEmpty;
    this._min = min;
    this._max = max;
    this._callback = callback;
    this.checkData();
    this._input.addEventListener("keyup", () => {
      this.InputChange(this._input, true);
    });
    this._input.addEventListener("change", () => {
      this.InputChange(this._input, false);
    });
  }
  static nullCallback(sender) {
  }
  showError(msg) {
    this._input.title = msg;
  }
  clearError() {
    this._input.title = "";
  }
  backGroundColorFeedback(ErrorMsg, state) {
    if (state)
      this.clearError();
    else
      this.showError(ErrorMsg);
    let c = this._input.style.backgroundColor;
    if (state && c != "white")
      this._input.style.backgroundColor = "white";
    if (!state && c != "pink")
      this._input.style.backgroundColor = "pink";
    return state;
  }
  checkData() {
    let intValue = 0;
    let doubleValue = 0;
    if (this._input.disabled)
      return true;
    let strValue = this._input.value;
    if (strValue == "")
      return this.backGroundColorFeedback("This field can't be empty", this._allowEmpty);
    switch (this._type) {
      case 0:
        break;
      case 1:
        intValue = parseInt(strValue);
        doubleValue = parseFloat(strValue);
        if (Number.isNaN(intValue) || intValue != doubleValue)
          return this.backGroundColorFeedback("Integer value expected", false);
        if (!Number.isNaN(this._min) && intValue < this._min)
          return this.backGroundColorFeedback("Integer value greater or equal to " + this._min.toString() + " expected", false);
        if (!Number.isNaN(this._max) && intValue > this._max)
          return this.backGroundColorFeedback("Integer value lower or equal to  " + this._min.toString() + " expected", false);
        break;
      case 2:
        intValue = parseInt(strValue);
        doubleValue = parseFloat(strValue);
        if (Number.isNaN(intValue) || intValue != doubleValue)
          return this.backGroundColorFeedback("Positive integer  expected", false);
        if (intValue < 0)
          return this.backGroundColorFeedback("Positive integer value  expected", false);
        if (!Number.isNaN(this._min) && intValue < this._min)
          return this.backGroundColorFeedback("Positive integer value greater or equal to " + this._min.toString() + " expected", false);
        if (!Number.isNaN(this._max) && intValue > this._max)
          return this.backGroundColorFeedback("Positive integer value lower or equal to  " + this._min.toString() + " expected", false);
        break;
      case 3:
        intValue = parseInt(strValue);
        doubleValue = parseFloat(strValue);
        if (Number.isNaN(intValue) || intValue != doubleValue)
          return this.backGroundColorFeedback("Strictly positive Integer value expected", false);
        if (intValue <= 0)
          return this.backGroundColorFeedback("Strictly positive integer value  expected", false);
        if (!Number.isNaN(this._min) && intValue < this._min)
          return this.backGroundColorFeedback("Positive integer value greater or equal to " + this._min.toString() + " expected", false);
        if (!Number.isNaN(this._max) && intValue > this._max)
          return this.backGroundColorFeedback("Positive integer value lower or equal to  " + this._min.toString() + " expected", false);
        break;
      case 4:
        doubleValue = parseFloat(strValue);
        if (Number.isNaN(intValue))
          return this.backGroundColorFeedback("Floating point value expected", false);
        if (!Number.isNaN(this._min) && doubleValue < this._min)
          return this.backGroundColorFeedback("Floating point value greater or equal to " + this._min.toString() + " expected", false);
        if (!Number.isNaN(this._max) && doubleValue > this._max)
          return this.backGroundColorFeedback("Floating point value lower or equal to  " + this._min.toString() + " expected", false);
        break;
      case 5:
        doubleValue = parseFloat(strValue);
        if (Number.isNaN(doubleValue))
          return this.backGroundColorFeedback("Positive floating point value expected", false);
        if (doubleValue < 0)
          return this.backGroundColorFeedback("Positive floating point value expected", false);
        if (!Number.isNaN(this._min) && doubleValue < this._min)
          return this.backGroundColorFeedback("Floating point value greater or equal to " + this._min.toString() + " expected", false);
        if (!Number.isNaN(this._max) && doubleValue > this._max)
          return this.backGroundColorFeedback("Floating point value lower or equal to  " + this._min.toString() + " expected", false);
        break;
      case 6:
        doubleValue = parseFloat(strValue);
        if (Number.isNaN(doubleValue))
          return this.backGroundColorFeedback("Strictly positive floating point value expected", false);
        if (doubleValue <= 0)
          return this.backGroundColorFeedback("Strictly positive floating point value expected", false);
        if (!Number.isNaN(this._min) && doubleValue < this._min)
          return this.backGroundColorFeedback("Floating point value greater or equal to " + this._min.toString() + " expected", false);
        if (!Number.isNaN(this._max) && doubleValue > this._max)
          return this.backGroundColorFeedback("Floating point value greater or equal to " + this._min.toString() + " expected", false);
        break;
      case 7:
        if (YColor.FromString(strValue) == null)
          return this.backGroundColorFeedback("Value color name/definition expected", false);
        break;
    }
    return this.backGroundColorFeedback("", true);
  }
  InputChange(sender, refreshInput) {
    if (this.checkData()) {
      try {
        if (this._callback != null)
          this._callback(sender, refreshInput);
      } catch (ex) {
        this.backGroundColorFeedback(ex.message, false);
      }
    }
  }
};

// obj/full/colorEditor_rw.js
var ColorEditorTab = class {
  constructor(editor, label, fontSize) {
    this._realTab = false;
    this._div = null;
    this._tabLabel = null;
    this._td = document.createElement("TD");
    this._editor = editor;
    if (label != "") {
      this._div = document.createElement("DIV");
      this._div.style.display = "none";
      this._td.style.paddingTop = "4px";
      this._td.style.fontSize = fontSize.toString() + "px";
      this._td.style.paddingBottom = "2px";
      this._td.style.borderLeft = "1px solid " + this._editor.inactiveBorderColor;
      this._td.style.borderRight = "1px solid " + this._editor.inactiveBorderColor;
      this._td.style.borderTop = "1px solid " + this._editor.inactiveBorderColor;
      this._td.style.borderBottom = "1px solid " + this._editor.activeBorderColor;
      this._td.style.color = this._editor.inactiveColor;
      this._td.style.backgroundColor = this._editor.inactiveBackgroundColor;
      this._td.style.borderTopLeftRadius = "3px";
      this._td.style.borderTopRightRadius = "3px";
      this._td.style.paddingLeft = "5px";
      this._td.style.paddingRight = "5px";
      this._realTab = true;
      this._tabLabel = document.createElement("ANCHOR");
      this._tabLabel.innerText = label;
      this._tabLabel.addEventListener("click", () => {
        this._editor.tabSelected(this);
      });
      this._tabLabel.addEventListener("keyup", (e) => {
        if (e.key === "Enter" || e.key === " ")
          this._editor.tabSelected(this);
      });
      this._tabLabel.style.cursor = "pointer";
      this._td.appendChild(this._tabLabel);
    } else {
      this._td.style.borderBottom = "1px solid " + this._editor.activeBorderColor;
      this._td.innerHTML = "<span>&nbsp;</span>";
    }
  }
  setTabIndex(index) {
    this._tabLabel.tabIndex = index++;
    return index;
  }
  set active(value) {
    if (!this._realTab)
      return;
    this._td.style.borderLeftColor = value ? this._editor.activeBorderColor : this._editor.inactiveBorderColor;
    this._td.style.borderTopColor = value ? this._editor.activeBorderColor : this._editor.inactiveBorderColor;
    this._td.style.borderRightColor = value ? this._editor.activeBorderColor : this._editor.inactiveBorderColor;
    this._td.style.borderBottomColor = value ? "rgba(0, 0, 0, 0)" : this._editor.activeBorderColor;
    this._td.style.color = value ? this._editor.activeColor : this._editor.inactiveColor;
    this._td.style.backgroundColor = value ? this._editor.activeBackgroundColor : this._editor.inactiveBackgroundColor;
    this._div.style.display = value ? "" : "none";
  }
  get active() {
    return this._div.style.display == "";
  }
  get tabElement() {
    return this._td;
  }
  get divElement() {
    return this._div;
  }
};
var ColorEditorSroll = class {
  constructor(div, anchor, input, colorCallback, changeCallBack, checkerBoardBg, value) {
    this._value = 0;
    this._colorCallback = colorCallback;
    this._changeCallBack = changeCallBack;
    this._value = value;
    this._div = div;
    let s = ColorEditorSroll.scrollHeight;
    if (checkerBoardBg)
      this._div.style.background = "url('data:image/svg+xml;utf8," + ColorSampler.checkerboardImage(s, s) + "')";
    this._anchor = anchor;
    this._input = input;
    this._input.size = 3;
    this._input.maxLength = 3;
    this._input.type = "number";
    this._input.min = "0";
    this._input.max = "255";
    this._input.style.fontSize = (12 * constants.guiDPIFactor).toString() + "px";
    this._input.style.textAlign = "right";
    this._input.value = this._value.toString();
    this._input.style.marginLeft = "10px";
    this._div.style.width = "100%";
    this._div.style.position = "relative";
    this._div.style.height = ColorEditorSroll.scrollHeight.toString() + "px";
    this._div.style.border = "1px solid black";
    this._canvasBg = document.createElement("CANVAS");
    this._div.appendChild(this._canvasBg);
    this._canvasBg.style.left = "0px";
    this._canvasBg.style.top = "0px";
    this._canvasBg.style.width = "100%";
    this._canvasBg.style.height = "100%";
    this._canvasBg.width = 256;
    this._canvasBg.height = ColorEditorSroll.scrollHeight;
    this._canvasCursor = document.createElement("CANVAS");
    this._div.appendChild(this._canvasCursor);
    this._canvasCursor.style.position = "absolute";
    this._canvasCursor.style.width = "100%";
    this._canvasCursor.style.height = "100%";
    this._canvasCursor.style.left = "0px";
    this._canvasCursor.style.top = "0px";
    this._canvasCursor.style.display = "block";
    this._div.addEventListener("mousedown", (e) => {
      this.MouseDown(this._div, e);
    });
    this._div.addEventListener("mousemove", (e) => {
      this.MouseMove(this._div, e);
    });
    this._anchor.addEventListener("wheel", (e) => {
      this.mouseWheelEvent(this._div, e);
    });
    this._anchor.addEventListener("keydown", (e) => {
      this.KeyDown(this._div, e);
    });
    this._input.addEventListener("keyup", (e) => {
      this.inputKeyUp();
    });
    this._input.addEventListener("change", (e) => {
      this.inputKeyUp();
    });
    this._anchor.tabIndex = 4;
  }
  setTabIndex(index) {
    this._anchor.tabIndex = index++;
    this._input.tabIndex = index++;
    return index;
  }
  get value() {
    return this._value;
  }
  set value(v) {
    if (v < 0)
      v = 0;
    if (v > 255)
      v = 255;
    this._value = v;
    this._input.value = this._value.toString();
  }
  inputKeyUp() {
    let value = parseInt(this._input.value);
    if (isNaN(value))
      return;
    if (value < 0)
      value = 0;
    if (value > 255)
      value = 255;
    this._value = value;
    this.refresh();
    this._changeCallBack(this);
  }
  TouchStart(div, e) {
    if (e.touches.length == 1)
      this.handleMouseStartCapture(div, e.touches[0].clientX, e.touches[0].clientY);
  }
  TouchCaptureRun(div, e) {
    if (e.touches.length == 1)
      this.handleMouseRun(div, e.touches[0].clientX, e.touches[0].clientY);
  }
  TouchCaptureEnd(div, e) {
  }
  MouseDown(sender, e) {
    if (e.buttons != 1)
      return;
    this.handleMouseStartCapture(sender, e.clientX, e.clientY);
  }
  handleMouseStartCapture(sender, x, y) {
    let SenderRect = sender.getBoundingClientRect();
    let eX = Math.round(x - SenderRect.left);
    let index = Math.round(256 * eX / this._div.offsetWidth) >> 0;
    if (index < 0)
      index = 0;
    if (index > 255)
      index = 255;
    this._value = index;
    this._input.value = index.toString();
    this.refresh();
    this._changeCallBack(this);
  }
  MouseMove(sender, e) {
    if (e.buttons != 1)
      return;
    this.handleMouseRun(sender, e.clientX, e.clientY);
  }
  handleMouseRun(sender, x, y) {
    let SenderRect = sender.getBoundingClientRect();
    let eX = Math.round(x - SenderRect.left);
    let index = Math.round(256 * eX / this._div.offsetWidth) >> 0;
    if (index < 0)
      index = 0;
    if (index > 255)
      index = 255;
    this._value = index;
    this._input.value = index.toString();
    this.refresh();
    this._changeCallBack(this);
  }
  mouseWheelEvent(sender, e) {
    this._value += e.deltaY > 0 ? -1 : 1;
    if (this._value < 0) {
      this._value = 0;
    } else if (this._value > 255) {
      this._value = 255;
    } else {
      e.preventDefault();
    }
    this._input.value = this._value.toString();
    this.refresh();
    this._changeCallBack(this);
  }
  KeyDown(sender, e) {
    if (e.code == "ArrowRight") {
      this._value++;
      if (this._value > 255)
        this._value = 255;
    }
    if (e.code == "ArrowLeft") {
      this._value--;
      if (this._value < 0)
        this._value = 0;
    }
    this._input.value = this._value.toString();
    this.refresh();
    this._changeCallBack(this);
  }
  refresh() {
    let color = this._colorCallback(this);
    let ctx = this._canvasBg.getContext("2d");
    ctx.clearRect(0, 0, this._canvasBg.width, this._canvasBg.height);
    for (let i = 0; i < 256; i++) {
      ctx.beginPath();
      ctx.moveTo(i + 0.5, 0);
      ctx.lineTo(i + 0.5, ColorEditorSroll.scrollHeight);
      ctx.strokeStyle = color[i];
      ctx.stroke();
    }
    this._canvasCursor.width = this._div.offsetWidth;
    this._canvasCursor.height = this._div.offsetHeight;
    ctx = this._canvasCursor.getContext("2d");
    let x = 0.5 + this._value / 255 * this._canvasCursor.width;
    ctx.beginPath();
    let y = 0.5;
    ctx.moveTo(x, y + 5);
    ctx.lineTo(x + 3, y);
    ctx.lineTo(x - 3, y);
    ctx.fillStyle = "black";
    ctx.strokeStyle = "white";
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
    y = this._canvasCursor.height - 0.5;
    ctx.beginPath();
    ctx.moveTo(x, y - 5);
    ctx.lineTo(x + 3, y);
    ctx.lineTo(x - 3, y);
    ctx.fillStyle = "black";
    ctx.strokeStyle = "white";
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
  }
};
ColorEditorSroll.scrollHeight = 26 * constants.guiDPIFactor;
var ColorSampler = class {
  constructor(containerDiv, selectCallback) {
    this._containerDiv = containerDiv;
    this._selectCallback = selectCallback;
    this._containerDiv.style.border = "1px solid grey";
    this._containerDiv.style.background = "url('data:image/svg+xml;utf8," + ColorSampler.checkerboardImage(100, 100) + "')";
    this._containerDiv.style.backgroundSize = "cover";
    this._containerDiv.style.backgroundPosition = "center";
    this._containerDiv.style.backgroundRepeat = "no-repeat";
    this._color = YColor.Transparent;
    this._colorDiv = document.createElement("DIV");
    this._colorDiv.style.display = "display-block";
    this._colorDiv.style.position = "relative";
    this._colorDiv.style.width = "100%";
    this._colorDiv.style.height = "100%";
    this._colorDiv.style.backgroundColor = "rgba(0,0,0,0)";
    this._containerDiv.appendChild(this._colorDiv);
    if (this._selectCallback != null) {
      this._colorDiv.addEventListener("click", () => {
        this._selectCallback(this.color);
      });
      this._colorDiv.addEventListener("keyup", (e) => {
        if (e.key === "Enter" || e.key === " ")
          this._selectCallback(this.color);
      });
      this._colorDiv.style.cursor = "pointer";
    }
  }
  setTabIndex(index) {
    this._colorDiv.tabIndex = index++;
    return index;
  }
  static checkerboardImage(width, height) {
    let halfWidth = width >> 1;
    let halfHeight = height >> 1;
    return '<svg xmlns="http://www.w3.org/2000/svg"   viewbox="0 0 ' + width + " " + height + '" width="' + width + 'px"  height="' + height + 'px" ><rect x="0" y="0" width="' + width + '" height="' + height + '" style="fill:white"/><rect x="0" y="0" width="' + halfWidth + '" height="' + halfHeight + '" style="fill:black"/><rect x="' + halfWidth + '" y="' + halfHeight + '" width="' + halfWidth + '" height="' + halfHeight + '" style="fill:black"/></svg>';
  }
  set color(value) {
    this._color = value.clone();
    this._colorDiv.style.backgroundColor = this._color.htmlCode;
  }
  get color() {
    return this._color.clone();
  }
};
var colorEditor = class {
  constructor(container, fontSize, initialColor, colorChangeCallback) {
    this._firstTabIndex = 0;
    this._memorizeTimer = null;
    colorEditor._editorsList.push(this);
    this._colorChangeCallback = colorChangeCallback;
    this._container = container;
    this._table = document.createElement("TABLE");
    this._table.style.width = "100%";
    this._table.style.borderSpacing = "0";
    this._table.style.paddingLeft = "5px";
    this._table.style.paddingTop = "5px";
    this._table.style.paddingRight = "5px";
    this._table.style.borderCollapse = "separate";
    this._tr1 = document.createElement("TR");
    this._tr2 = document.createElement("TR");
    this._tabRGB = new ColorEditorTab(this, "RGB", fontSize);
    this._tabHSL = new ColorEditorTab(this, "HSL", fontSize);
    this._tabPredef = new ColorEditorTab(this, "Predefined", fontSize);
    this._tabStub = new ColorEditorTab(this, "", fontSize);
    this._contents = document.createElement("TD");
    this._contents.colSpan = 4;
    this._contents.style.borderLeft = "1px solid " + this.activeBorderColor;
    this._contents.style.borderRight = "1px solid " + this.activeBorderColor;
    this._contents.style.borderBottom = "1px solid " + this.activeBorderColor;
    this._contents.style.backgroundColor = this.activeBackgroundColor;
    this._tr1.appendChild(this._tabRGB.tabElement);
    this._tr1.appendChild(this._tabHSL.tabElement);
    this._tr1.appendChild(this._tabPredef.tabElement);
    this._tr1.appendChild(this._tabStub.tabElement);
    this._tr2.appendChild(this._contents);
    this._table.appendChild(this._tr1);
    this._table.appendChild(this._tr2);
    this._contents.appendChild(this._tabRGB.divElement);
    this._contents.appendChild(this._tabHSL.divElement);
    this._contents.appendChild(this._tabPredef.divElement);
    let RGBtable = document.createElement("TABLE");
    RGBtable.style.width = "100%";
    RGBtable.style.borderSpacing = "1";
    this._tabRGB.divElement.appendChild(RGBtable);
    let HSLtable = document.createElement("TABLE");
    HSLtable.style.width = "100%";
    HSLtable.style.borderSpacing = "1";
    this._tabHSL.divElement.appendChild(HSLtable);
    let predefTable = document.createElement("TABLE");
    this._tabPredef.divElement.appendChild(predefTable);
    predefTable.style.width = "100%";
    predefTable.style.borderSpacing = "1";
    predefTable.style.tableLayout = "fixed";
    this._container.appendChild(this._table);
    this._rgb_R_editor = this.AddColorScroll(RGBtable, "R", () => {
      return this.RedScrollBg();
    }, (src) => {
      this.RgbColorChangeCallBack(src);
    }, false, 1);
    this._rgb_G_editor = this.AddColorScroll(RGBtable, "G", () => {
      return this.GreenScrollBg();
    }, (src) => {
      this.RgbColorChangeCallBack(src);
    }, false, 2);
    this._rgb_B_editor = this.AddColorScroll(RGBtable, "B", () => {
      return this.BlueScrollBg();
    }, (src) => {
      this.RgbColorChangeCallBack(src);
    }, false, 3);
    this._rgb_T_editor = this.AddColorScroll(RGBtable, "T", () => {
      return this.RGBTranspScrollBg();
    }, (src) => {
      this.RgbColorChangeCallBack(src);
    }, true, 3);
    this._rgb_R_editor.value = initialColor.red;
    this._rgb_G_editor.value = initialColor.green;
    this._rgb_B_editor.value = initialColor.blue;
    this._rgb_T_editor.value = initialColor.alpha;
    this._rgb_R_editor.refresh();
    this._rgb_G_editor.refresh();
    this._rgb_B_editor.refresh();
    this._rgb_T_editor.refresh();
    this._hsl_H_editor = this.AddColorScroll(HSLtable, "H", () => {
      return this.HueScrollBg();
    }, (src) => {
      this.HslColorChangeCallBack(src);
    }, false, 1);
    this._hsl_S_editor = this.AddColorScroll(HSLtable, "S", () => {
      return this.SaturationScrollBg();
    }, (src) => {
      this.HslColorChangeCallBack(src);
    }, false, 2);
    this._hsl_L_editor = this.AddColorScroll(HSLtable, "L", () => {
      return this.LuminosityScrollBg();
    }, (src) => {
      this.HslColorChangeCallBack(src);
    }, false, 3);
    this._hsl_T_editor = this.AddColorScroll(HSLtable, "T", () => {
      return this.HSLTranspScrollBg();
    }, (src) => {
      this.HslColorChangeCallBack(src);
    }, true, 3);
    this._hsl_H_editor.value = initialColor.hue;
    this._hsl_S_editor.value = initialColor.saturation;
    this._hsl_L_editor.value = initialColor.luminosity;
    this._hsl_T_editor.value = initialColor.alpha;
    this._hsl_H_editor.refresh();
    this._hsl_S_editor.refresh();
    this._hsl_L_editor.refresh();
    this._hsl_T_editor.refresh();
    let samplesTable = document.createElement("TABLE");
    samplesTable.style.position = "relative";
    samplesTable.style.width = "100%";
    samplesTable.style.paddingLeft = "3px";
    samplesTable.style.paddingRight = "3px";
    samplesTable.style.paddingTop = "10px";
    samplesTable.style.bottom = "3px";
    samplesTable.style.tableLayout = "fixed";
    let samplesTD = [];
    let previewTD = null;
    let sampleHeight = 30;
    let sampletr1 = document.createElement("TR");
    sampletr1.style.height = sampleHeight.toString() + "px";
    for (let i = 0; i < 6; i++) {
      let td = document.createElement("TD");
      if (i == 5) {
        td.colSpan = 2;
        td.rowSpan = 3;
        previewTD = td;
      } else {
        samplesTD.push(td);
      }
      sampletr1.appendChild(td);
    }
    samplesTable.appendChild(sampletr1);
    let sampletr2 = document.createElement("TR");
    sampletr2.style.height = sampleHeight.toString() + "px";
    for (let i = 0; i < 5; i++) {
      let td = document.createElement("TD");
      samplesTD.push(td);
      sampletr2.appendChild(td);
    }
    samplesTable.appendChild(sampletr2);
    let sampletr3 = document.createElement("TR");
    sampletr3.style.height = sampleHeight.toString() + "px";
    for (let i = 0; i < 5; i++) {
      let td = document.createElement("TD");
      samplesTD.push(td);
      sampletr3.appendChild(td);
    }
    samplesTable.appendChild(sampletr3);
    this._container.appendChild(samplesTable);
    this._samples = [];
    for (let i = 0; i < samplesTD.length; i++) {
      let div2 = document.createElement("DIV");
      div2.style.position = "relative";
      div2.style.width = "100%";
      div2.style.height = (sampleHeight - 4).toString() + "px";
      div2.style.display = "inline-block";
      div2.title = "Color history";
      samplesTD[i].appendChild(div2);
      let sampler = new ColorSampler(div2, (c) => {
        this.sampleWasSelectedCallback(c);
      });
      sampler.color = colorEditor._colorHistory[i];
      this._samples.push(sampler);
    }
    let prefinedColors = YColor.predefinedColors;
    let colors = [];
    let predefinedColorNames = Object.keys(prefinedColors);
    for (let i = 0; i < predefinedColorNames.length; i++) {
      colors.push(prefinedColors[predefinedColorNames[i]]);
    }
    colors.sort((c1, c2) => {
      if (c1.alpha < c2.alpha)
        return 1;
      if (c1.alpha > c2.alpha)
        return -1;
      if (c1.luminosity < c2.luminosity)
        return 1;
      if (c1.luminosity > c2.luminosity)
        return -1;
      if (c1.saturation < c2.saturation)
        return 1;
      if (c1.saturation > c2.saturation)
        return -1;
      if (c1.hue < c2.hue)
        return 1;
      if (c1.hue > c2.hue)
        return -1;
      return 0;
    });
    let currenTR = null;
    this._prefedDivs = [];
    for (let i = 0; i < colors.length; i++) {
      let c = colors[i];
      if (i % 16 == 0) {
        currenTR = document.createElement("TR");
        predefTable.appendChild(currenTR);
      }
      let td = document.createElement("TD");
      currenTR.appendChild(td);
      let div2 = document.createElement("DIV");
      this._prefedDivs.push(div2);
      div2.style.position = "relative";
      div2.style.width = "100%";
      div2.style.height = Math.round(10 * constants.guiDPIFactor).toString() + "px";
      div2.style.display = "inline-block";
      div2.title = c.name;
      td.appendChild(div2);
      let sampler = new ColorSampler(div2, (c2) => {
        this.sampleWasSelectedCallback(c2);
      });
      sampler.color = c;
    }
    let div = document.createElement("DIV");
    div.style.position = "relative";
    div.style.width = "100%";
    div.style.height = (3 * sampleHeight).toString() + "px";
    div.style.display = "inline-block";
    div.title = "Color preview";
    previewTD.appendChild(div);
    this._preview = new ColorSampler(div, null);
    this._preview.color = initialColor;
    this.selectApropriateTab(initialColor);
  }
  static AddColorToHistory(c) {
    for (let i = 0; i < colorEditor._colorHistory.length; i++) {
      if (c.equal(colorEditor._colorHistory[i]))
        return;
    }
    colorEditor._colorHistory.splice(colorEditor._colorHistory.length - 1, 1);
    colorEditor._colorHistory.splice(0, 0, c);
    for (let i = colorEditor._editorsList.length - 1; i >= 0; i--) {
      colorEditor._editorsList[i].refreshColorHistory();
    }
  }
  static get colorHistory() {
    return colorEditor._colorHistory;
  }
  get activeBorderColor() {
    return "#767676";
  }
  get inactiveBorderColor() {
    return "#b0b0b0";
  }
  get activeColor() {
    return "black";
  }
  get inactiveColor() {
    return "grey";
  }
  get activeBackgroundColor() {
    return "white";
  }
  get inactiveBackgroundColor() {
    return "#f8f8f8";
  }
  tabSelected(source) {
    if (source == this._tabRGB) {
      this._tabRGB.active = true;
      this._rgb_R_editor.refresh();
      this._rgb_G_editor.refresh();
      this._rgb_B_editor.refresh();
      this._rgb_T_editor.refresh();
    } else {
      this._tabRGB.active = false;
    }
    if (source == this._tabHSL) {
      this._tabHSL.active = true;
      this._hsl_H_editor.refresh();
      this._hsl_S_editor.refresh();
      this._hsl_L_editor.refresh();
      this._hsl_T_editor.refresh();
    } else {
      this._tabHSL.active = false;
    }
    this._tabPredef.active = source == this._tabPredef;
  }
  HueScrollBg() {
    let s = 100;
    let l = 50;
    let t = this._hsl_T_editor.value / 255;
    let res = new Array(256);
    for (let i = 0; i < 256; i++) {
      res[i] = "hsl(" + (360 * i / 256).toString() + "," + s.toString() + "%," + l.toString() + "%)";
    }
    return res;
  }
  SaturationScrollBg() {
    let h = 360 * this._hsl_H_editor.value / 256;
    let l = 100 * this._hsl_L_editor.value / 255;
    let t = this._hsl_T_editor.value / 255;
    let res = new Array(256);
    for (let i = 0; i < 256; i++) {
      res[i] = "hsl(" + h.toString() + "," + (100 * i / 255).toString() + "%," + l.toString() + "%)";
    }
    return res;
  }
  LuminosityScrollBg() {
    let h = 360 * this._hsl_H_editor.value / 256;
    let s = 100 * this._hsl_S_editor.value / 255;
    let t = this._hsl_T_editor.value / 255;
    let res = new Array(256);
    for (let i = 0; i < 256; i++) {
      res[i] = "hsl(" + h.toString() + "," + s.toString() + "%," + (100 * i / 255).toString() + "%)";
    }
    return res;
  }
  HSLTranspScrollBg() {
    let h = 360 * this._hsl_H_editor.value / 256;
    let s = 100 * this._hsl_S_editor.value / 255;
    let l = 100 * this._hsl_L_editor.value / 255;
    let res = new Array(256);
    for (let i = 0; i < 256; i++) {
      res[i] = "hsla(" + h.toString() + "," + l.toString() + "%," + s.toString() + "%," + (i / 255).toString() + ")";
    }
    return res;
  }
  RedScrollBg() {
    let g = this._rgb_G_editor.value;
    let b = this._rgb_B_editor.value;
    let t = this._rgb_T_editor.value / 255;
    let res = new Array(256);
    for (let i = 0; i < 256; i++) {
      res[i] = "rgb(" + i.toString() + "," + g.toString() + "," + b.toString() + ")";
    }
    return res;
  }
  GreenScrollBg() {
    let r = this._rgb_R_editor.value;
    let b = this._rgb_B_editor.value;
    let t = this._rgb_T_editor.value / 255;
    let res = new Array(256);
    for (let i = 0; i < 256; i++) {
      res[i] = "rgb(" + r.toString() + "," + i.toString() + "," + b.toString() + ")";
    }
    return res;
  }
  BlueScrollBg() {
    let r = this._rgb_R_editor.value;
    let g = this._rgb_G_editor.value;
    let t = this._rgb_T_editor.value / 255;
    let res = new Array(256);
    for (let i = 0; i < 256; i++) {
      res[i] = "rgb(" + r.toString() + "," + g.toString() + "," + i.toString() + ")";
    }
    return res;
  }
  RGBTranspScrollBg() {
    let r = this._rgb_R_editor.value;
    let g = this._rgb_G_editor.value;
    let b = this._rgb_B_editor.value;
    let res = new Array(256);
    for (let i = 0; i < 256; i++) {
      res[i] = "rgba(" + r.toString() + "," + g.toString() + "," + b.toString() + "," + (i / 255).toString() + ")";
    }
    return res;
  }
  static defaultColorHistory() {
    let defaultHistory = [];
    defaultHistory.push(YColor.FromAhsl(100, 0, 0, 0));
    defaultHistory.push(YColor.FromAhsl(100, 0, 0, 51));
    defaultHistory.push(YColor.FromAhsl(100, 0, 0, 102));
    defaultHistory.push(YColor.FromAhsl(100, 0, 0, 153));
    defaultHistory.push(YColor.FromAhsl(100, 0, 0, 204));
    defaultHistory.push(YColor.FromAhsl(100, 0, 0, 255));
    defaultHistory.push(YColor.FromAhsl(100, 0, 255, 127));
    defaultHistory.push(YColor.FromAhsl(100, 42, 255, 127));
    defaultHistory.push(YColor.FromAhsl(100, 85, 255, 127));
    defaultHistory.push(YColor.FromAhsl(100, 96, 255, 127));
    defaultHistory.push(YColor.FromAhsl(100, 127, 255, 127));
    defaultHistory.push(YColor.FromAhsl(100, 170, 255, 127));
    defaultHistory.push(YColor.FromAhsl(100, 192, 255, 127));
    defaultHistory.push(YColor.FromAhsl(100, 212, 255, 127));
    defaultHistory.push(YColor.FromAhsl(255, 226, 217, 214));
    return defaultHistory;
  }
  destroy() {
    for (let i = colorEditor._editorsList.length - 1; i >= 0; i--) {
      if (colorEditor._editorsList[i] == this) {
        colorEditor._editorsList.splice(i, 1);
      }
    }
  }
  refreshColorHistory() {
    for (let i = 0; i < this._samples.length; i++) {
      if (i < colorEditor._colorHistory.length) {
        this._samples[i].color = colorEditor._colorHistory[i].clone();
      }
    }
  }
  selectApropriateTab(color) {
    if (color.isPredefined) {
      this._tabPredef.active = true;
      this.tabSelected(this._tabPredef);
    } else {
      this._tabPredef.active = false;
      if (color.isRGB) {
        this._tabRGB.active = true;
        this._tabHSL.active = false;
        this.tabSelected(this._tabRGB);
      } else {
        this._tabRGB.active = false;
        this._tabHSL.active = true;
        this.tabSelected(this._tabHSL);
      }
    }
  }
  sampleWasSelectedCallback(color) {
    this._rgb_R_editor.value = color.red;
    this._rgb_G_editor.value = color.green;
    this._rgb_B_editor.value = color.blue;
    this._rgb_T_editor.value = color.alpha;
    this._hsl_H_editor.value = color.hue;
    this._hsl_S_editor.value = color.saturation;
    this._hsl_L_editor.value = color.luminosity;
    this._hsl_T_editor.value = color.alpha;
    this._preview.color = color;
    this._rgb_R_editor.refresh();
    this._rgb_G_editor.refresh();
    this._rgb_B_editor.refresh();
    this._rgb_T_editor.refresh();
    this._hsl_H_editor.refresh();
    this._hsl_S_editor.refresh();
    this._hsl_L_editor.refresh();
    this._hsl_T_editor.refresh();
    this.initColorMemorization(color);
    if (this._colorChangeCallback != null)
      this._colorChangeCallback(color);
  }
  initColorMemorization(color) {
    if (this._memorizeTimer != null)
      clearTimeout(this._memorizeTimer);
    this._memorizeTimer = setTimeout(() => {
      this._memorizeTimer = null;
      colorEditor.AddColorToHistory(color);
    }, 2e3);
  }
  RgbColorChangeCallBack(src) {
    if (src != this._rgb_R_editor)
      this._rgb_R_editor.refresh();
    if (src != this._rgb_G_editor)
      this._rgb_G_editor.refresh();
    if (src != this._rgb_B_editor)
      this._rgb_B_editor.refresh();
    if (src != this._rgb_T_editor)
      this._rgb_T_editor.refresh();
    let color = YColor.FromArgb(this._rgb_T_editor.value, this._rgb_R_editor.value, this._rgb_G_editor.value, this._rgb_B_editor.value);
    this._preview.color = color;
    this.initColorMemorization(color);
    if (this._colorChangeCallback != null)
      this._colorChangeCallback(color);
  }
  HslColorChangeCallBack(src) {
    if (src != this._hsl_H_editor)
      this._hsl_H_editor.refresh();
    if (src != this._hsl_S_editor)
      this._hsl_S_editor.refresh();
    if (src != this._hsl_L_editor)
      this._hsl_L_editor.refresh();
    if (src != this._hsl_T_editor)
      this._hsl_T_editor.refresh();
    let color = YColor.FromAhsl(this._hsl_T_editor.value, this._hsl_H_editor.value, this._hsl_S_editor.value, this._hsl_L_editor.value);
    this._preview.color = color;
    this.initColorMemorization(color);
    if (this._colorChangeCallback != null)
      this._colorChangeCallback(color);
  }
  set color(color) {
    this._preview.color = color;
    this._hsl_H_editor.value = color.hue;
    this._hsl_S_editor.value = color.saturation;
    this._hsl_L_editor.value = color.luminosity;
    this._hsl_T_editor.value = color.alpha;
    this._rgb_R_editor.value = color.red;
    this._rgb_G_editor.value = color.green;
    this._rgb_B_editor.value = color.blue;
    this._rgb_T_editor.value = color.alpha;
    this._hsl_H_editor.refresh();
    this._hsl_S_editor.refresh();
    this._hsl_L_editor.refresh();
    this._hsl_T_editor.refresh();
    this._rgb_R_editor.refresh();
    this._rgb_G_editor.refresh();
    this._rgb_B_editor.refresh();
    this._rgb_T_editor.refresh();
    this.selectApropriateTab(color);
  }
  AddColorScroll(container, label, colorCallback, changeCallBack, checkerBoardBg, value) {
    let RGB_R_Row = document.createElement("TR");
    let RGB_R_Col1 = document.createElement("TD");
    RGB_R_Col1.innerHTML = "&nbsp;" + label + "&nbsp;";
    let RGB_R_Col2 = document.createElement("TD");
    let RGB_R_Anchor = document.createElement("ANCHOR");
    RGB_R_Col2.appendChild(RGB_R_Anchor);
    let RGB_R_Div = document.createElement("DIV");
    RGB_R_Col2.style.width = "100%";
    RGB_R_Anchor.appendChild(RGB_R_Div);
    let RGB_R_Col3 = document.createElement("TD");
    let RGB_R_Input = document.createElement("INPUT");
    RGB_R_Col3.appendChild(RGB_R_Input);
    RGB_R_Row.appendChild(RGB_R_Col1);
    RGB_R_Row.appendChild(RGB_R_Col2);
    RGB_R_Row.appendChild(RGB_R_Col3);
    container.appendChild(RGB_R_Row);
    return new ColorEditorSroll(RGB_R_Div, RGB_R_Anchor, RGB_R_Input, colorCallback, changeCallBack, checkerBoardBg, value);
  }
  setTabIndex(index) {
    this._firstTabIndex = index;
    index = this._tabRGB.setTabIndex(index);
    index = this._tabHSL.setTabIndex(index);
    index = this._tabPredef.setTabIndex(index);
    if (this._tabRGB.active) {
      index = this._rgb_R_editor.setTabIndex(index);
      index = this._rgb_G_editor.setTabIndex(index);
      index = this._rgb_B_editor.setTabIndex(index);
      index = this._rgb_T_editor.setTabIndex(index);
    } else if (this._tabHSL.active) {
      index = this._hsl_H_editor.setTabIndex(index);
      index = this._hsl_S_editor.setTabIndex(index);
      index = this._hsl_L_editor.setTabIndex(index);
      index = this._hsl_T_editor.setTabIndex(index);
    } else {
      for (let i = 0; i < this._prefedDivs.length; i++) {
        this._prefedDivs[i].tabIndex = index++;
      }
    }
    for (let i = 0; i < this._samples.length; i++) {
      index = this._samples[i].setTabIndex(index);
    }
    return index;
  }
};
colorEditor._colorHistory = colorEditor.defaultColorHistory();
colorEditor._editorsList = [];

// obj/full/configForm_rw.js
var configEditorTab = class {
  constructor(editor, label, fontSize, GUIcoef) {
    this._realTab = false;
    this._div = null;
    this._tabLabel = null;
    this._td = document.createElement("TD");
    if (label != "") {
      this._div = document.createElement("DIV");
      this._div.style.display = "none";
      let sz = Math.round(5 * GUIcoef).toString() + "px";
      this._div.style.padding = sz + " " + sz + " " + sz + " " + sz;
      this._td.style.paddingTop = Math.round(4 * GUIcoef).toString() + "px";
      this._td.style.fontSize = fontSize.toString() + "px";
      this._td.style.paddingBottom = Math.round(2 * GUIcoef).toString() + "px";
      this._td.tabIndex = 0;
      this._td.style.borderLeft = "1px solid " + configForm.inactiveBorderColor;
      this._td.style.borderRight = "1px solid " + configForm.inactiveBorderColor;
      this._td.style.borderTop = "1px solid " + configForm.inactiveBorderColor;
      this._td.style.borderBottom = "1px solid " + configForm.activeBorderColor;
      this._td.style.color = configForm.inactiveColor;
      this._td.style.backgroundColor = configForm.inactiveBackgroundColor;
      this._td.style.borderTopLeftRadius = Math.round(3 * GUIcoef).toString() + "px";
      this._td.style.borderTopRightRadius = Math.round(3 * GUIcoef).toString() + "px";
      this._td.style.paddingLeft = "5px";
      this._td.style.paddingRight = "5px";
      this._realTab = true;
      this._tabLabel = document.createElement("ANCHOR");
      this._tabLabel.innerText = label;
      this._tabLabel.addEventListener("click", () => {
        configForm.tabSelected(this);
      });
      this._tabLabel.addEventListener("keyup", (e) => {
        if (e.key === "Enter" || e.key === " ")
          configForm.tabSelected(this);
      });
      this._tabLabel.style.cursor = "pointer";
      this._td.appendChild(this._tabLabel);
    } else {
      this._td.style.borderBottom = "1px solid " + configForm.activeBorderColor;
      this._td.innerHTML = "<span>&nbsp;</span>";
    }
  }
  setTabIndex(index) {
    this._tabLabel.tabIndex = index++;
    return index;
  }
  set active(value) {
    if (!this._realTab)
      return;
    this._td.style.borderLeftColor = value ? configForm.activeBorderColor : configForm.inactiveBorderColor;
    this._td.style.borderTopColor = value ? configForm.activeBorderColor : configForm.inactiveBorderColor;
    this._td.style.borderRightColor = value ? configForm.activeBorderColor : configForm.inactiveBorderColor;
    this._td.style.borderBottomColor = value ? "rgba(0, 0, 0, 0)" : configForm.activeBorderColor;
    this._td.style.color = value ? configForm.activeColor : configForm.inactiveColor;
    this._td.style.backgroundColor = value ? configForm.activeBackgroundColor : configForm.inactiveBackgroundColor;
    this._div.style.display = value ? "" : "none";
  }
  get tabElement() {
    return this._td;
  }
  get divElement() {
    return this._div;
  }
};
var configForm = class {
  static get activeBorderColor() {
    return constants.WindowInnerBorderColor;
  }
  static get inactiveBorderColor() {
    return "#b0b0b0";
  }
  static get activeColor() {
    return "black";
  }
  static get inactiveColor() {
    return "grey";
  }
  static get activeBackgroundColor() {
    return constants.WindowInnerBackgroundColor;
  }
  static get inactiveBackgroundColor() {
    return constants.WindowBackgroundColor;
  }
  static hubStateChanged(source) {
    if (configForm._Hubtable == null)
      return;
    let srvNotification = source.removable ? "" : " (server)";
    for (let i = 1; i < configForm._Hubtable.childElementCount; i++) {
      if (configForm._Hubtable.childNodes[i]["YHUB"] == source) {
        configForm._Hubtable.childNodes[i].childNodes[2].innerText = source.ConnectionDescription + srvNotification;
        switch (source.ConnectionState) {
          case 2:
            configForm._Hubtable.childNodes[i].childNodes[0].innerHTML = ressources.OkIcon((1.2 * configForm.fontSize).toString(), true, false, false, false, " ");
            break;
          case 3:
            configForm._Hubtable.childNodes[i].childNodes[0].innerHTML = ressources.FailedIcon((1.2 * configForm.fontSize).toString(), true, false, false, false, " ");
            break;
          default:
            configForm._Hubtable.childNodes[i].childNodes[0].innerHTML = ressources.DontKnowIcon((1.2 * configForm.fontSize).toString(), true, false, false, false, " ");
            break;
        }
      }
    }
  }
  static RefreshUI(h) {
    for (let i = 1; i < configForm._Hubtable.childElementCount; i++) {
      if (configForm._Hubtable.childNodes[i]["YHUB"] == h) {
        configForm._Hubtable.childNodes[i].childNodes[1].innerText = h.toString();
        configForm._Hubtable.childNodes[i].childNodes[2].innerText = "...";
      }
    }
  }
  static HublineSelected(source) {
    configForm._selectedHub = null;
    for (let i = 1; i < configForm._Hubtable.childElementCount; i++) {
      if (configForm._Hubtable.childNodes[i] == source) {
        configForm._selectedHub = configForm._Hubtable.childNodes[i]["YHUB"];
        configForm._Hubtable.childNodes[i].style.backgroundColor = "#2fa5ff";
        configForm._Hubtable.childNodes[i].childNodes[0].style.color = "white";
        configForm._Hubtable.childNodes[i].childNodes[1].style.color = "white";
        configForm._Hubtable.childNodes[i].childNodes[2].style.color = "white";
      } else {
        configForm._Hubtable.childNodes[i].style.backgroundColor = "white";
        configForm._Hubtable.childNodes[i].childNodes[0].style.color = "black";
        configForm._Hubtable.childNodes[i].childNodes[1].style.color = "black";
        configForm._Hubtable.childNodes[i].childNodes[2].style.color = "black";
      }
    }
    configForm._editButton.enabled = configForm._selectedHub != null;
    configForm._deleteButton.enabled = configForm._selectedHub != null;
    this._editButton.showShortcut(configForm._selectedHub != null);
    this._deleteButton.showShortcut(configForm._selectedHub != null);
  }
  static newHub() {
    HubEdit.newHub(() => {
      configForm._window.show();
    });
  }
  static AddHubToUI(hub) {
    let HubtableTR = document.createElement("TR");
    HubtableTR.style.fontSize = configForm.fontSize.toString() + "px";
    HubtableTR["YHUB"] = hub;
    HubtableTR.style.backgroundColor = "white";
    HubtableTR.style.cursor = "pointer";
    HubtableTR.tabIndex = 0;
    HubtableTR.addEventListener("keypress", (e) => {
      switch (e.key.toUpperCase()) {
        case "D":
          this._deleteButton.performAction();
          break;
        case "E":
          this._editButton.performAction();
          break;
      }
    });
    HubtableTR.style.outline = "none";
    HubtableTR.addEventListener("click", () => {
      configForm.HublineSelected(HubtableTR);
    });
    HubtableTR.addEventListener("focusin", () => {
      configForm.HublineSelected(HubtableTR);
    });
    let HubtableTD = document.createElement("TD");
    switch (hub.ConnectionState) {
      case 2:
        HubtableTD.innerHTML = ressources.OkIcon((1.2 * configForm.fontSize).toString(), true, false, false, false, " ");
        break;
      case 3:
        HubtableTD.innerHTML = ressources.FailedIcon((1.2 * configForm.fontSize).toString(), true, false, false, false, " ");
        break;
      case 1:
      default:
        HubtableTD.innerHTML = ressources.DontKnowIcon((1.2 * configForm.fontSize).toString(), true, false, false, false, " ");
    }
    HubtableTD.style.width = (2 * configForm.fontSize).toString() + "px";
    HubtableTD.style.verticalAlign = "center";
    HubtableTD.style.borderBottom = "1px solid " + configForm.inactiveBorderColor;
    HubtableTD.style.paddingLeft = "5px";
    HubtableTR.appendChild(HubtableTD);
    HubtableTD = document.createElement("TD");
    HubtableTD.innerText = hub.toString();
    HubtableTD.style.borderBottom = "1px solid " + configForm.inactiveBorderColor;
    HubtableTD.style.verticalAlign = "center";
    HubtableTD.style.height = (2 * configForm.fontSize).toString() + "px";
    HubtableTR.appendChild(HubtableTD);
    HubtableTD = document.createElement("TD");
    HubtableTD.style.verticalAlign = "center";
    HubtableTD.innerText = hub.ConnectionDescription + (hub.removable ? "" : " (server)");
    HubtableTD.style.borderBottom = "1px solid " + configForm.inactiveBorderColor;
    HubtableTR.appendChild(HubtableTD);
    configForm._Hubtable.appendChild(HubtableTR);
  }
  static editSelectedHub() {
    if (configForm._selectedHub == null)
      return;
    HubEdit.editHub(configForm._selectedHub, () => {
      configForm._window.show();
    });
  }
  static deleteSelectedHub() {
    if (configForm._selectedHub == null)
      return;
    let ExtraMessage = configForm._selectedHub.removable ? "" : "\n\nThis one is also the one serving the Yocto-Visualization software. If you remove it, you won't be able to save later on.";
    confirm.ask("Do you really want to remove connection " + configForm._selectedHub.toString() + " ?" + ExtraMessage, () => {
      if (configForm._selectedHub == null)
        return;
      configForm._selectedHub.Disconnect().then((r) => {
      });
      for (let i = configForm._Hubtable.childElementCount - 1; i > 0; i--) {
        if (configForm._Hubtable.childNodes[i]["YHUB"] == configForm._selectedHub) {
          configForm._Hubtable.removeChild(configForm._Hubtable.childNodes[i]);
        }
      }
      sensorsManager.hubWasremoved(configForm._selectedHub);
      configForm._selectedHub = null;
      configForm._editButton.enabled = false;
      configForm._deleteButton.enabled = false;
      constants.edited = true;
    }, null, null);
  }
  static hide() {
    if (configForm._window == null)
      return;
    configForm._window.visible = false;
  }
  static show() {
    if (configForm._window == null) {
      configForm.GUIcoef = constants.generalSizeCoef;
      if (configForm.REFWIDH * configForm.GUIcoef > screen.width)
        configForm.GUIcoef = screen.width / configForm.REFWIDH;
      if (configForm.REFHEIGHT * configForm.GUIcoef > screen.height)
        configForm.GUIcoef = screen.height / configForm.REFHEIGHT;
      configForm.fontSize *= configForm.GUIcoef / constants.generalSizeCoef;
      let params = new newWindowParam(configForm.GUIcoef);
      params.positionType = 1;
      params.width = Math.round(configForm.REFWIDH * this.GUIcoef);
      params.height = Math.round(configForm.REFHEIGHT * this.GUIcoef);
      params.showContainerBorders = false;
      params.title = "Global configuration";
      configForm._window = new YWindow(params);
      configForm._contents = configForm._window.innerContentDiv;
      configForm._table = document.createElement("TABLE");
      configForm._contents.appendChild(configForm._table);
      configForm._table.style.position = "absolute";
      configForm._table.style.left = "0px";
      configForm._table.style.right = "0px";
      configForm._table.style.width = "100%";
      configForm._table.style.height = "100%";
      configForm._table.style.borderSpacing = "0";
      configForm._table.style.paddingLeft = (5 * this.GUIcoef).toString() + "px";
      configForm._table.style.paddingTop = (5 * this.GUIcoef).toString() + "px";
      configForm._table.style.paddingRight = (5 * this.GUIcoef).toString() + "px";
      configForm._table.style.borderCollapse = "separate";
      configForm._tr1 = document.createElement("TR");
      configForm._tr2 = document.createElement("TR");
      configForm._tr1.style.height = (2 * configForm.fontSize).toString() + "px";
      configForm._tabNetwork = new configEditorTab(configForm, "Network", configForm.fontSize, configForm.GUIcoef);
      configForm._tabCapture = new configEditorTab(configForm, "Screen capture", configForm.fontSize, configForm.GUIcoef);
      configForm._tabResources = new configEditorTab(configForm, "Ressources", configForm.fontSize, configForm.GUIcoef);
      configForm._tabUI = new configEditorTab(configForm, "User interface", configForm.fontSize, configForm.GUIcoef);
      configForm._tabExport = new configEditorTab(configForm, "Updates & XML", configForm.fontSize, configForm.GUIcoef);
      configForm._tabStub = new configEditorTab(configForm, "", configForm.fontSize, configForm.GUIcoef);
      this._tabPanelContents = document.createElement("TD");
      this._tabPanelContents.colSpan = 6;
      this._tabPanelContents.style.borderLeft = "1px solid " + this.activeBorderColor;
      this._tabPanelContents.style.borderRight = "1px solid " + this.activeBorderColor;
      this._tabPanelContents.style.borderBottom = "1px solid " + this.activeBorderColor;
      this._tabPanelContents.style.backgroundColor = this.activeBackgroundColor;
      configForm._tr1.appendChild(this._tabNetwork.tabElement);
      configForm._tr1.appendChild(this._tabCapture.tabElement);
      configForm._tr1.appendChild(this._tabResources.tabElement);
      configForm._tr1.appendChild(this._tabUI.tabElement);
      configForm._tr1.appendChild(this._tabExport.tabElement);
      configForm._tr1.appendChild(this._tabStub.tabElement);
      configForm._tr2.appendChild(this._tabPanelContents);
      configForm._tr2.childNodes[0].style.verticalAlign = "top";
      configForm._table.appendChild(this._tr1);
      configForm._table.appendChild(this._tr2);
      let p = document.createElement("P");
      p.style.textAlign = "justify";
      p.style.fontSize = configForm.fontSize.toString() + "px";
      p.style.paddingTop = "0px";
      p.style.marginTop = Math.round(3 * this.GUIcoef).toString() + "px";
      p.innerText = "Enter the list of VirtualHub or YoctoHub this page can connect to";
      this._tabNetwork.divElement.appendChild(p);
      configForm._Hubtable = document.createElement("TABLE");
      configForm._Hubtable.style.position = "absolute";
      configForm._Hubtable.style.display = "block";
      configForm._Hubtable.style.left = Math.round(20 * this.GUIcoef).toString() + "px";
      configForm._Hubtable.style.right = Math.round(20 * this.GUIcoef).toString() + "px";
      configForm._Hubtable.style.tableLayout = "auto";
      configForm._Hubtable.style.top = Math.round(80 * this.GUIcoef).toString() + "px";
      configForm._Hubtable.style.bottom = Math.round(40 * this.GUIcoef).toString() + "px";
      configForm._Hubtable.style.borderCollapse = "colapse";
      configForm._Hubtable.style.borderSpacing = "0px";
      configForm._Hubtable.style.border = "1px solid " + configForm.activeBorderColor;
      let HubtableTR = document.createElement("TR");
      HubtableTR.style.fontSize = configForm.fontSize.toString() + "px";
      let HubtableTH = document.createElement("TH");
      HubtableTH.colSpan = 2;
      HubtableTH.innerText = "Address";
      HubtableTH.style.borderBottom = "1px solid " + configForm.activeBorderColor;
      HubtableTH.style.width = Math.round(400 * this.GUIcoef).toString() + "px";
      HubtableTR.appendChild(HubtableTH);
      HubtableTH = document.createElement("TH");
      HubtableTH.innerText = "Status";
      HubtableTH.style.width = "40%";
      HubtableTH.style.borderBottom = "1px solid " + configForm.activeBorderColor;
      HubtableTH.style.borderLeft = "1px solid " + configForm.activeBorderColor;
      HubtableTR.appendChild(HubtableTH);
      configForm._Hubtable.appendChild(HubtableTR);
      let hubList = sensorsManager.hubList;
      for (let i = 0; i < hubList.length; i++) {
        configForm.AddHubToUI(hubList[i]);
      }
      let div = document.createElement("DIV");
      div.style.position = "absolute";
      div.style.bottom = "0px";
      div.style.right = Math.round(20 * configForm.GUIcoef).toString() + "px";
      div.style.height = Math.round(30 * configForm.GUIcoef).toString() + "px";
      div.style.textAlign = "right";
      div.style.verticalAlign = "center";
      configForm._newButton = new button("New", () => {
        configForm._window.hide();
        configForm.newHub();
      }, configForm.GUIcoef);
      div.appendChild(configForm._newButton.Element);
      configForm._editButton = new button("Edit", () => {
        configForm._window.hide();
        configForm.editSelectedHub();
      }, configForm.GUIcoef);
      configForm._editButton.enabled = false;
      div.appendChild(configForm._editButton.Element);
      configForm._deleteButton = new button("Delete", () => {
        configForm.deleteSelectedHub();
      }, configForm.GUIcoef);
      configForm._deleteButton.enabled = false;
      div.appendChild(configForm._deleteButton.Element);
      this._tabNetwork.divElement.appendChild(div);
      this._tabNetwork.divElement.appendChild(configForm._Hubtable);
      p = document.createElement("P");
      p.innerHTML = "Widgets content can be captured at anytime thought the <i>Snapshop</i> option available in right-click contextual menu";
      p.style.textAlign = "justify";
      p.style.fontSize = configForm.fontSize.toString() + "px";
      this._tabCapture.divElement.appendChild(p);
      let tableSize = document.createElement("TABLE");
      tableSize.style.fontSize = configForm.fontSize.toString() + "px";
      let row = document.createElement("TR");
      let td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      td.innerText = "ImageType";
      row.appendChild(td);
      td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      td.style.verticalAlign = "center";
      configForm.inputPNG = document.createElement("INPUT");
      configForm.inputSVG = document.createElement("INPUT");
      configForm.inputPNG.checked = constants.captureType == YDataRenderer.CaptureType.PNG;
      configForm.inputPNG.style.display = "inline";
      configForm.inputPNG.type = "checkbox";
      configForm.inputPNG.style.transform = "scale(" + this.GUIcoef.toString() + ")";
      configForm.inputPNG.style.marginRight = Math.round(5 * this.GUIcoef).toString() + "px";
      configForm.inputPNG.style.marginLeft = Math.round(5 * this.GUIcoef).toString() + "px";
      configForm.inputPNG.addEventListener("change", () => {
        configForm.captureFormatChange(configForm.inputPNG);
      });
      td.append(configForm.inputPNG);
      let span;
      span = document.createElement("SPAN");
      span.innerText = YDataRenderer.CaptureType.PNG.description;
      td.append(span);
      configForm.inputSVG = document.createElement("INPUT");
      configForm.inputSVG.checked = constants.captureType == YDataRenderer.CaptureType.SVG;
      configForm.inputSVG.style.display = "inline";
      configForm.inputSVG.type = "checkbox";
      configForm.inputSVG.style.transform = "scale(" + this.GUIcoef.toString() + ")";
      configForm.inputSVG.style.marginRight = Math.round(5 * this.GUIcoef).toString() + "px";
      configForm.inputSVG.style.marginLeft = Math.round(5 * this.GUIcoef).toString() + "px";
      configForm.inputSVG.addEventListener("change", () => {
        configForm.captureFormatChange(configForm.inputSVG);
      });
      td.append(configForm.inputSVG);
      span = document.createElement("SPAN");
      span.innerText = YDataRenderer.CaptureType.SVG.description;
      td.append(span);
      row.appendChild(td);
      tableSize.appendChild(row);
      row = document.createElement("TR");
      td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      td.innerText = "Resolution:";
      row.appendChild(td);
      td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      configForm.inputResolution = document.createElement("INPUT");
      configForm.inputResolution.style.fontFamily = constants.generalFontFamily;
      configForm.inputResolution.style.fontSize = constants.generalFontSize.toString() + "px";
      configForm.inputResolution.style.border = "1px solid grey";
      configForm.inputResolution.type = "number";
      configForm.inputResolution.style.textAlign = "right";
      configForm.inputResolution.style.marginRight = "5px";
      configForm.inputResolution.style.width = "60px";
      configForm.inputResolution.value = constants.captureDPI.toString();
      configForm.inputResolution.style.display = "inline";
      new InputFieldManager(configForm.inputResolution, 6, false, Number.NaN, Number.NaN, (sender, refreshInput) => {
        configForm.captureDPIChange(configForm.inputResolution);
      });
      td.append(configForm.inputResolution);
      span = document.createElement("SPAN");
      span.innerText = "DPI";
      td.append(span);
      row.appendChild(td);
      tableSize.appendChild(row);
      row = document.createElement("TR");
      td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      td.innerText = "Size:";
      td.style.verticalAlign = "top";
      row.appendChild(td);
      td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      configForm.inputSizeSelect = document.createElement("SELECT");
      configForm.inputSizeSelect.style.border = "1px solid grey";
      configForm.inputSizeSelect.style.fontFamily = constants.generalFontFamily;
      configForm.inputSizeSelect.style.fontSize = constants.generalFontSize.toString() + "px";
      let sizingOptions = YDataRenderer.CaptureFormats.Keep.sibblings;
      for (let i = 0; i < sizingOptions.length; i++) {
        let option = document.createElement("OPTION");
        option.text = sizingOptions[i].description;
        option.value = sizingOptions[i].toString;
        configForm.inputSizeSelect.add(option, null);
      }
      configForm.inputSizeSelect.value = constants.captureSizePolicy.toString;
      configForm.inputSizeSelect.addEventListener("change", () => {
        configForm.captureSizeSelectChange(configForm.inputSizeSelect);
      });
      td.append(configForm.inputSizeSelect);
      row.appendChild(td);
      tableSize.appendChild(row);
      let subtable = document.createElement("TABLE");
      configForm.captureWidthTR = document.createElement("TR");
      let subTD = document.createElement("TD");
      subTD.style.fontSize = configForm.fontSize.toString() + "px";
      subTD.innerText = "Width:";
      configForm.captureWidthTR.appendChild(subTD);
      subTD = document.createElement("TD");
      subTD.style.fontSize = configForm.fontSize.toString() + "px";
      configForm.inputCaptureWidth = document.createElement("INPUT");
      configForm.inputCaptureWidth.style.border = "1px solid grey";
      configForm.inputCaptureWidth.style.fontFamily = constants.generalFontFamily;
      configForm.inputCaptureWidth.style.fontSize = constants.generalFontSize.toString() + "px";
      configForm.inputCaptureWidth.type = "number";
      configForm.inputCaptureWidth.style.textAlign = "right";
      configForm.inputCaptureWidth.style.marginRight = "5px";
      configForm.inputCaptureWidth.style.width = "60px";
      configForm.inputCaptureWidth.value = constants.captureWidth.toString();
      configForm.inputCaptureWidth.style.display = "inline";
      new InputFieldManager(configForm.inputCaptureWidth, 3, false, Number.NaN, Number.NaN, (sender, refreshInput) => {
        configForm.captureWidthChange(configForm.inputCaptureWidth);
      });
      subTD.append(configForm.inputCaptureWidth);
      configForm.inputCaptureWidthInfo = document.createElement("SPAN");
      configForm.inputCaptureWidthInfo.innerText = "pixels";
      subTD.append(configForm.inputCaptureWidthInfo);
      configForm.captureWidthTR.appendChild(subTD);
      subtable.appendChild(configForm.captureWidthTR);
      configForm.captureHeightTR = document.createElement("TR");
      subTD = document.createElement("TD");
      subTD.style.fontSize = configForm.fontSize.toString() + "px";
      subTD.innerText = "Height:";
      configForm.captureHeightTR.appendChild(subTD);
      subTD = document.createElement("TD");
      subTD.style.fontSize = configForm.fontSize.toString() + "px";
      configForm.inputCaptureHeight = document.createElement("INPUT");
      configForm.inputCaptureHeight.style.border = "1px solid grey";
      configForm.inputCaptureHeight.style.fontFamily = constants.generalFontFamily;
      configForm.inputCaptureHeight.style.fontSize = constants.generalFontSize.toString() + "px";
      configForm.inputCaptureHeight.type = "number";
      configForm.inputCaptureHeight.style.textAlign = "right";
      configForm.inputCaptureHeight.style.marginRight = "5px";
      configForm.inputCaptureHeight.style.width = "60px";
      configForm.inputCaptureHeight.value = constants.captureHeight.toString();
      configForm.inputCaptureHeight.style.display = "inline";
      new InputFieldManager(configForm.inputCaptureHeight, 3, false, Number.NaN, Number.NaN, (sender, refreshInput) => {
        configForm.captureHeightChange(configForm.inputCaptureHeight);
      });
      subTD.append(configForm.inputCaptureHeight);
      configForm.inputCaptureHeightInfo = document.createElement("SPAN");
      configForm.inputCaptureHeightInfo.innerText = "pixels";
      subTD.append(configForm.inputCaptureHeightInfo);
      configForm.captureHeightTR.appendChild(subTD);
      subtable.appendChild(configForm.captureHeightTR);
      td.appendChild(subtable);
      configForm._tabCapture.divElement.appendChild(tableSize);
      let tableRessources = document.createElement("TABLE");
      row = document.createElement("TR");
      td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      td.innerText = "If you plan to use YoctoVisualization continuously for an extended period of time (i.e. several weeks),  or if you are running it on a computer with limited resources, you may want to limit the application memory consumption.";
      td.colSpan = 2;
      td.style.textAlign = "justify";
      row.appendChild(td);
      tableRessources.appendChild(row);
      row = document.createElement("TR");
      td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      td.innerText = "Max count of sensors data records:";
      row.appendChild(td);
      td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      let maxSensorRecs = document.createElement("INPUT");
      maxSensorRecs.style.border = "1px solid grey";
      maxSensorRecs.style.fontFamily = constants.generalFontFamily;
      maxSensorRecs.style.fontSize = constants.generalFontSize.toString() + "px";
      maxSensorRecs.type = "number";
      maxSensorRecs.style.textAlign = "right";
      maxSensorRecs.style.marginRight = "5px";
      maxSensorRecs.style.marginLeft = "5px";
      maxSensorRecs.style.width = "60px";
      maxSensorRecs.value = constants.maxDataRecordsPerSensor.toString();
      maxSensorRecs.style.display = "inline";
      new InputFieldManager(maxSensorRecs, 2, false, Number.NaN, Number.NaN, (sender, refreshInput) => {
        configForm.maxSensorRecsChange(maxSensorRecs);
      });
      td.append(maxSensorRecs);
      span = document.createElement("SPAN");
      span.innerText = "(0 = unlimited)";
      td.append(span);
      row.appendChild(td);
      tableRessources.appendChild(row);
      row = document.createElement("TR");
      td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      td.innerText = "Max count of graph series data points:";
      row.appendChild(td);
      td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      let maxSeriesRecs = document.createElement("INPUT");
      maxSeriesRecs.style.border = "1px solid grey";
      maxSeriesRecs.style.fontFamily = constants.generalFontFamily;
      maxSeriesRecs.style.fontSize = constants.generalFontSize.toString() + "px";
      maxSeriesRecs.type = "number";
      maxSeriesRecs.style.textAlign = "right";
      maxSeriesRecs.style.marginRight = "5px";
      maxSeriesRecs.style.marginLeft = "5px";
      maxSeriesRecs.style.width = "60px";
      maxSeriesRecs.value = constants.maxPointsPerGraphSerie.toString();
      maxSeriesRecs.style.display = "inline";
      new InputFieldManager(maxSeriesRecs, 2, false, Number.NaN, Number.NaN, (sender, refreshInput) => {
        configForm.maxSeriesRecsChange(maxSeriesRecs);
      });
      td.append(maxSeriesRecs);
      span = document.createElement("SPAN");
      span.innerText = "(0 = unlimited)";
      td.append(span);
      row.appendChild(td);
      tableRessources.appendChild(row);
      row = document.createElement("TR");
      td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      td.innerText = "\nYocto-Visualization automatically loads datalogger contents for all connected devices.  If you are using networked devices featuring  billable data transfers (GSM) you may want to limit or even disable that feature.";
      td.colSpan = 2;
      td.style.textAlign = "justify";
      row.appendChild(td);
      tableRessources.appendChild(row);
      row = document.createElement("TR");
      td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      td.innerText = "Max data points/series loaded from dataloggers:";
      row.appendChild(td);
      td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      let maxDataLogRecs = document.createElement("INPUT");
      maxDataLogRecs.style.border = "1px solid grey";
      maxDataLogRecs.style.fontFamily = constants.generalFontFamily;
      maxDataLogRecs.style.fontSize = constants.generalFontSize.toString() + "px";
      maxDataLogRecs.type = "number";
      maxDataLogRecs.style.textAlign = "right";
      maxDataLogRecs.style.marginRight = "5px";
      maxDataLogRecs.style.marginLeft = "5px";
      maxDataLogRecs.style.width = "60px";
      maxDataLogRecs.value = constants.maxPointsPerDataloggerSerie.toString();
      maxDataLogRecs.style.display = "inline";
      new InputFieldManager(maxDataLogRecs, 1, false, -1, Number.NaN, (sender, refreshInput) => {
        configForm.maxDataLogRecsChange(maxDataLogRecs);
      });
      td.append(maxDataLogRecs);
      span = document.createElement("SPAN");
      span.innerText = "(0 = unlimited,\n-1 = disabled)";
      td.append(span);
      row.appendChild(td);
      tableRessources.appendChild(row);
      row = document.createElement("TR");
      td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      td.innerText = "After a  limit increase, you'll have to restart the application to get your old data back.";
      td.colSpan = 2;
      td.style.textAlign = "justify";
      row.appendChild(td);
      tableRessources.appendChild(row);
      configForm._tabResources.divElement.appendChild(tableRessources);
      p = document.createElement("P");
      p.style.fontSize = configForm.fontSize.toString() + "px";
      p.innerText = "You can alter user interface behavior according to your hardware capabilities.";
      this._tabUI.divElement.appendChild(p);
      let checkbox1 = document.createElement("INPUT");
      checkbox1.style.fontFamily = constants.generalFontFamily;
      checkbox1.style.fontSize = constants.generalFontSize.toString() + "px";
      checkbox1.style.display = "inline";
      checkbox1.type = "checkbox";
      checkbox1.style.transform = "scale(" + this.GUIcoef.toString() + ")";
      checkbox1.style.marginRight = Math.round(5 * this.GUIcoef).toString() + "px";
      checkbox1.checked = constants.dbleClickBringsUpContextMenu;
      checkbox1.addEventListener("change", () => {
        configForm.dbleClickBringsUpContextMenuChange(checkbox1);
      });
      this._tabUI.divElement.appendChild(checkbox1);
      span = document.createElement("SPAN");
      span.style.fontSize = configForm.fontSize.toString() + "px";
      span.innerText = "Double click/tap  brings up context menu\n";
      this._tabUI.divElement.appendChild(span);
      let checkbox2 = document.createElement("INPUT");
      checkbox2.style.display = "inline";
      checkbox2.type = "checkbox";
      checkbox2.style.transform = "scale(" + this.GUIcoef.toString() + ")";
      checkbox2.style.marginRight = Math.round(5 * this.GUIcoef).toString() + "px";
      checkbox2.checked = YGraph.verticalDragZoomEnabled;
      checkbox2.addEventListener("change", () => {
        configForm.verticalDragZoomChange(checkbox2);
      });
      this._tabUI.divElement.appendChild(checkbox2);
      span = document.createElement("SPAN");
      span.style.fontSize = configForm.fontSize.toString() + "px";
      span.innerText = "Graphs zoom can be driven by vertical drag\n";
      this._tabUI.divElement.appendChild(span);
      p = document.createElement("P");
      p.style.fontSize = configForm.fontSize.toString() + "px";
      p.innerText = "Yocto-Visualization tries to ajust UI size to screen resolution the best it can through a DPI based zoom factor. Unfortunately not all devices can properly report their screen resolution. That's why you can manually override that factor.";
      this._tabUI.divElement.appendChild(p);
      let DPIoverride = document.createElement("INPUT");
      let checkbox3 = document.createElement("INPUT");
      checkbox3.style.display = "inline";
      checkbox3.type = "checkbox";
      checkbox3.style.transform = "scale(" + this.GUIcoef.toString() + ")";
      checkbox3.style.marginRight = Math.round(5 * this.GUIcoef).toString() + "px";
      checkbox3.checked = constants.guiDPIFactorIsOverriden;
      checkbox3.addEventListener("change", () => {
        configForm.DPIoverrideChange(checkbox3, DPIoverride);
      });
      this._tabUI.divElement.appendChild(checkbox3);
      span = document.createElement("SPAN");
      span.style.fontSize = configForm.fontSize.toString() + "px";
      span.innerText = "Override zoom factor to ";
      this._tabUI.divElement.appendChild(span);
      DPIoverride.style.border = "1px solid grey";
      DPIoverride.style.fontFamily = constants.generalFontFamily;
      DPIoverride.style.fontSize = constants.generalFontSize.toString() + "px";
      DPIoverride.disabled = !constants.guiDPIFactorIsOverriden;
      DPIoverride.type = "number";
      DPIoverride.style.textAlign = "right";
      DPIoverride.style.marginRight = "5px";
      DPIoverride.style.marginLeft = "5px";
      DPIoverride.style.width = "60px";
      DPIoverride.value = constants.guiDPIFactorOverrideValue.toString();
      DPIoverride.style.display = "inline";
      new InputFieldManager(DPIoverride, 5, false, Number.NaN, Number.NaN, (sender, refreshInput) => {
        configForm.DPIoverrideChange(checkbox3, DPIoverride);
      });
      this._tabUI.divElement.appendChild(DPIoverride);
      p = document.createElement("P");
      p.style.fontSize = configForm.fontSize.toString() + "px";
      p.innerText = "This setting is stored in your browser cookies. So it is specific to this device, browser and server.You will have to reload this page for this setting to take effect";
      this._tabUI.divElement.appendChild(p);
      p = document.createElement("P");
      p.style.fontSize = configForm.fontSize.toString() + "px";
      p.style.textAlign = "justify";
      p.innerText = "As long as your web browser can reach www.yoctopuce.com, the read/write edition of Yocto-Visualization (for web) can automatically check for new version. If you find this feature anoying, feel free to disable it. ";
      this._tabExport.divElement.appendChild(p);
      let checkbox4 = document.createElement("INPUT");
      checkbox4.style.display = "inline";
      checkbox4.type = "checkbox";
      checkbox4.style.transform = "scale(" + this.GUIcoef.toString() + ")";
      checkbox4.style.marginLeft = Math.round(25 * this.GUIcoef).toString() + "px";
      checkbox4.checked = constants.mustCheckForUpdate;
      checkbox4.addEventListener("change", () => {
        configForm.mustCheckForUpdateChange(checkbox4);
      });
      this._tabExport.divElement.appendChild(checkbox4);
      span = document.createElement("SPAN");
      span.style.fontSize = configForm.fontSize.toString() + "px";
      span.innerText = "Automatically check for updates";
      let a2 = document.createElement("A");
      a2.innerText = "Check now";
      a2.style.paddingLeft = "25px";
      a2.style.cursor = "pointer";
      a2.style.color = "#0000EE";
      a2.style.textDecoration = "underline";
      a2.addEventListener("click", () => {
        YWebPage.CheckForNewVersion(true);
      });
      span.appendChild(a2);
      this._tabExport.divElement.appendChild(span);
      p = document.createElement("P");
      p.style.fontSize = configForm.fontSize.toString() + "px";
      p.style.textAlign = "justify";
      p.innerText = "Yocto-Visualization (for web) stores its configuration in a XML file. This file can be used to create a static web page running Yocto-Visualization (for web) or it can be used in the Yocto-Visualization (for web) installer to create a pre-configured install. Also, it is mostly compatible with the native version of Yocto-Visualization: you can use it instead of the original config.xml file. Just click on the link below to export/download your current configuration.";
      this._tabExport.divElement.appendChild(p);
      p = document.createElement("P");
      p.style.fontSize = configForm.fontSize.toString() + "px";
      p.style.textAlign = "right";
      let a = document.createElement("A");
      a.innerText = "Export current configuration";
      a.style.cursor = "pointer";
      a.style.color = "#0000EE";
      a.style.textDecoration = "underline";
      a.addEventListener("click", () => {
        configForm.downloadCurrentConfig();
      });
      p.appendChild(a);
      this._tabExport.divElement.appendChild(p);
      configForm._tabPanelContents.appendChild(this._tabNetwork.divElement);
      configForm._tabPanelContents.appendChild(this._tabCapture.divElement);
      configForm._tabPanelContents.appendChild(this._tabResources.divElement);
      configForm._tabPanelContents.appendChild(this._tabUI.divElement);
      configForm._tabPanelContents.appendChild(this._tabExport.divElement);
      configForm.tabSelected(this._tabNetwork);
      configForm.refreshSizeParams();
    }
    configForm._window.show();
  }
  static DPIoverrideChange(checkbox, input) {
    let value = parseFloat(input.value);
    input.disabled = !checkbox.checked;
    if (checkbox.checked && value > 0) {
      constants.overrideGuiDPIFactor(true, value);
    } else {
      constants.overrideGuiDPIFactor(false);
    }
  }
  static hubWasAdded(hub) {
    if (sensorsManager.newHubCreated(hub)) {
      configForm.AddHubToUI(hub);
      constants.edited = true;
      hub.Connect().then((r) => {
      });
    }
  }
  static hubGotEdited(hub) {
    configForm.RefreshUI(hub);
    constants.edited = true;
    hub.Disconnect().then((r) => {
    });
    hub.Connect().then((r) => {
    });
  }
  static dbleClickBringsUpContextMenuChange(source) {
    let prev = constants.dbleClickBringsUpContextMenu;
    constants.dbleClickBringsUpContextMenu = source.checked;
    if (prev != constants.dbleClickBringsUpContextMenu)
      constants.edited = true;
  }
  static verticalDragZoomChange(source) {
    let prev = YGraph.verticalDragZoomEnabled;
    YGraph.verticalDragZoomEnabled = source.checked;
    if (prev != YGraph.verticalDragZoomEnabled)
      constants.edited = true;
  }
  static mustCheckForUpdateChange(source) {
    let prev = constants.mustCheckForUpdate;
    constants.mustCheckForUpdate = source.checked;
    if (prev != constants.mustCheckForUpdate)
      constants.edited = true;
  }
  static maxDataLogRecsChange(source) {
    let value = parseInt(source.value);
    if (value != constants.maxPointsPerDataloggerSerie || value != CustomYSensor.MaxLoggerRecords) {
      constants.maxPointsPerDataloggerSerie = value;
      CustomYSensor.MaxLoggerRecords = value;
      constants.edited = true;
    }
  }
  static maxSeriesRecsChange(source) {
    let value = parseInt(source.value);
    if (value != constants.maxPointsPerGraphSerie || value != DataSerie.MaxPointsPerSeries) {
      constants.maxPointsPerGraphSerie = value;
      DataSerie.MaxPointsPerSeries = value;
      constants.edited = true;
    }
  }
  static maxSensorRecsChange(source) {
    let value = parseInt(source.value);
    if (value != constants.maxDataRecordsPerSensor || value != CustomYSensor.MaxDataRecords) {
      constants.maxDataRecordsPerSensor = value;
      CustomYSensor.MaxDataRecords = value;
      constants.edited = true;
    }
  }
  static captureDPIChange(source) {
    let prev = constants.captureDPI;
    constants.captureDPI = parseInt(source.value);
    if (constants.captureDPI != prev)
      constants.edited = true;
    configForm.refreshSizeParams();
  }
  static captureWidthChange(source) {
    let prev = constants.captureWidth;
    constants.captureWidth = parseInt(source.value);
    if (constants.captureWidth != prev)
      constants.edited = true;
    configForm.refreshSizeParams();
  }
  static captureHeightChange(source) {
    let prev = constants.captureHeight;
    constants.captureHeight = parseInt(source.value);
    if (constants.captureHeight != prev)
      constants.edited = true;
    configForm.refreshSizeParams();
  }
  static captureSizeSelectChange(source) {
    let prev = constants.captureSizePolicy;
    constants.captureSizePolicy = YDataRenderer.CaptureFormats.fromString(YDataRenderer.CaptureFormats, source.value);
    if (constants.captureSizePolicy != prev)
      constants.edited = true;
    configForm.refreshSizeParams();
  }
  static refreshSizeParams() {
    let value = YDataRenderer.CaptureFormats.fromString(YDataRenderer.CaptureFormats, configForm.inputSizeSelect.value);
    if (value == YDataRenderer.CaptureFormats.Keep) {
      configForm.captureWidthTR.style.display = "none";
      configForm.captureHeightTR.style.display = "none";
    } else if (value == YDataRenderer.CaptureFormats.FixedWidth) {
      configForm.captureWidthTR.style.display = "";
      configForm.captureHeightTR.style.display = "none";
    } else if (value == YDataRenderer.CaptureFormats.FixedHeight) {
      configForm.captureWidthTR.style.display = "none";
      configForm.captureHeightTR.style.display = "";
    }
    if (value == YDataRenderer.CaptureFormats.Fixed) {
      configForm.captureWidthTR.style.display = "";
      configForm.captureHeightTR.style.display = "";
    }
    let sw = 25.4 * parseInt(configForm.inputCaptureWidth.value) / parseInt(configForm.inputResolution.value);
    configForm.inputCaptureWidthInfo.innerText = "Pixels  (" + sw.toFixed(1) + "mm)";
    let sh = 25.4 * parseInt(configForm.inputCaptureHeight.value) / parseInt(configForm.inputResolution.value);
    configForm.inputCaptureHeightInfo.innerText = "Pixels  (" + sh.toFixed(1) + "mm)";
  }
  static downloadCurrentConfig() {
    let element = document.createElement("a");
    let data = "data:text/xml;base64," + btoa(YWebPage.get_XmlData());
    element.setAttribute("href", data);
    element.setAttribute("download", "config.xml");
    element.style.display = "none";
    document.body.appendChild(element);
    element.click();
    document.body.removeChild(element);
  }
  static captureFormatChange(source) {
    if (source == configForm.inputPNG)
      configForm.inputSVG.checked = !source.checked;
    if (source == configForm.inputSVG)
      configForm.inputPNG.checked = !source.checked;
    let prev = constants.captureType;
    constants.captureType = configForm.inputPNG.checked ? YDataRenderer.CaptureType.PNG : YDataRenderer.CaptureType.SVG;
    if (constants.captureType != prev)
      constants.edited = true;
  }
  static tabSelected(source) {
    this._tabNetwork.active = source == this._tabNetwork;
    this._tabCapture.active = source == this._tabCapture;
    this._tabResources.active = source == this._tabResources;
    this._tabUI.active = source == this._tabUI;
    this._tabExport.active = source == this._tabExport;
  }
};
configForm.GUIcoef = 1;
configForm.REFWIDH = 520;
configForm.REFHEIGHT = 300;
configForm.fontSize = constants.generalFontSize;

// obj/full/HubEdit_rw.js
var HubEdit = class {
  static get activeBorderColor() {
    return constants.WindowInnerBorderColor;
  }
  static get inactiveBorderColor() {
    return "#b0b0b0";
  }
  static get activeColor() {
    return "black";
  }
  static get inactiveColor() {
    return "grey";
  }
  static get activeBackgroundColor() {
    return constants.WindowInnerBackgroundColor;
  }
  static get inactiveBackgroundColor() {
    return constants.WindowBackgroundColor;
  }
  static newHub(whenDone) {
    HubEdit._currenthub = new Hub(2, "ws", "", "", true, "", "", "");
    HubEdit.show(HubEdit._currenthub);
    HubEdit._window.title = "New Connection";
    HubEdit._thisIsEditing = false;
    HubEdit._whenDone = whenDone;
  }
  static editHub(hub, whenDone) {
    HubEdit._currenthub = hub;
    HubEdit.show(HubEdit._currenthub);
    HubEdit._window.title = "Edit Connection";
    HubEdit._thisIsEditing = true;
    HubEdit._whenDone = whenDone;
  }
  static show(hub) {
    if (HubEdit._window == null) {
      HubEdit._okButton = new button("Ok", () => {
        HubEdit.okClicked();
      });
      HubEdit._cancelButton = new button("Cancel", () => {
        HubEdit.hide();
      });
      let params = new newWindowParam();
      params.positionType = 1;
      params.width = Math.round(450 * constants.generalSizeCoef);
      params.height = Math.round(280 * constants.generalSizeCoef);
      params.isModal = true;
      params.closeIcon = false;
      params.title = "...";
      params.buttons.push(HubEdit._okButton);
      params.buttons.push(HubEdit._cancelButton);
      HubEdit._window = new YWindow(params);
      HubEdit._contents = HubEdit._window.innerContentDiv;
      let p = document.createElement("P");
      p.style.paddingTop = "0px";
      p.style.marginTop = Math.round(3 * constants.generalSizeCoef).toString() + "px";
      p.style.lineHeight = Math.round(12 * constants.generalSizeCoef).toString() + "px";
      p.innerText = "Enter the hub connection parameter, The only mandatory parameter is the address, just leave the other fields empty if you want to use default values";
      p.style.textAlign = "justify";
      HubEdit._contents.appendChild(p);
      p.appendChild(document.createElement("BR"));
      p.appendChild(document.createElement("BR"));
      let span = document.createElement("SPAN");
      span.innerText = "Protocol:";
      span.style.marginLeft = "20px";
      p.appendChild(span);
      HubEdit._protocolSelect = document.createElement("SELECT");
      HubEdit._protocolSelect.style.border = "1px solid grey";
      HubEdit._protocolSelect.style.fontFamily = constants.generalFontFamily;
      HubEdit._protocolSelect.style.fontSize = constants.generalFontSize.toString() + "px";
      let httpOption = document.createElement("OPTION");
      httpOption.text = "http";
      httpOption.value = "http";
      HubEdit._protocolSelect.appendChild(httpOption);
      let httpsOption = document.createElement("OPTION");
      httpsOption.text = "https";
      httpsOption.value = "https";
      HubEdit._protocolSelect.appendChild(httpsOption);
      let wsOption = document.createElement("OPTION");
      wsOption.text = "ws";
      wsOption.value = "ws";
      HubEdit._protocolSelect.appendChild(wsOption);
      let wssOption = document.createElement("OPTION");
      wssOption.text = "wss";
      wssOption.value = "wss";
      HubEdit._protocolSelect.appendChild(wssOption);
      p.appendChild(HubEdit._protocolSelect);
      span = document.createElement("SPAN");
      span.style.marginLeft = "20px";
      span.innerText = "Address:";
      p.appendChild(span);
      HubEdit._addressInput = document.createElement("INPUT");
      HubEdit._addressInput.style.border = "1px solid grey";
      HubEdit._addressInput.style.fontFamily = constants.generalFontFamily;
      HubEdit._addressInput.style.fontSize = constants.generalFontSize.toString() + "px";
      HubEdit._addressInput.maxLength = 512;
      HubEdit._addressInput.size = 15;
      HubEdit._addressInput.value = hub.addr;
      new InputFieldManager(HubEdit._addressInput, 0, false, Number.NaN, Number.NaN, null);
      p.appendChild(HubEdit._addressInput);
      span = document.createElement("SPAN");
      span.style.marginLeft = Math.round(20 * constants.generalSizeCoef).toString() + "px";
      span.innerText = "Port:";
      p.appendChild(span);
      HubEdit._portInput = document.createElement("INPUT");
      HubEdit._portInput.style.border = "1px solid grey";
      HubEdit._portInput.style.fontFamily = constants.generalFontFamily;
      HubEdit._portInput.style.fontSize = constants.generalFontSize.toString() + "px";
      HubEdit._portInput.style.textAlign = "right";
      HubEdit._portInput.maxLength = 5;
      HubEdit._portInput.size = 5;
      new InputFieldManager(HubEdit._portInput, 3, true, Number.NaN, Number.NaN, null);
      p.appendChild(HubEdit._portInput);
      p.appendChild(document.createElement("BR"));
      p.appendChild(document.createElement("BR"));
      span = document.createElement("SPAN");
      span.innerText = "Path:";
      span.style.marginLeft = Math.round(20 * constants.generalSizeCoef).toString() + "px";
      p.appendChild(span);
      HubEdit._pathInput = document.createElement("INPUT");
      HubEdit._pathInput.style.border = "1px solid grey";
      HubEdit._pathInput.style.fontFamily = constants.generalFontFamily;
      HubEdit._pathInput.style.fontSize = constants.generalFontSize.toString() + "px";
      HubEdit._pathInput.size = 45;
      p.appendChild(HubEdit._pathInput);
      p.appendChild(document.createElement("BR"));
      p.appendChild(document.createElement("BR"));
      span = document.createElement("SPAN");
      span.innerText = "Username:";
      span.style.marginLeft = Math.round(20 * constants.generalSizeCoef).toString() + "px";
      p.appendChild(span);
      HubEdit._usernameInput = document.createElement("INPUT");
      HubEdit._usernameInput.style.border = "1px solid grey";
      HubEdit._usernameInput.style.fontFamily = constants.generalFontFamily;
      HubEdit._usernameInput.style.fontSize = constants.generalFontSize.toString() + "px";
      HubEdit._usernameInput.size = 15;
      p.appendChild(HubEdit._usernameInput);
      span = document.createElement("SPAN");
      span.innerText = "Password:";
      span.style.marginLeft = Math.round(20 * constants.generalSizeCoef).toString() + "px";
      p.appendChild(span);
      HubEdit._passwordInput = document.createElement("INPUT");
      HubEdit._passwordInput.type = "password";
      HubEdit._passwordInput.style.border = "1px solid grey";
      HubEdit._passwordInput.style.fontFamily = constants.generalFontFamily;
      HubEdit._passwordInput.style.fontSize = constants.generalFontSize.toString() + "px";
      HubEdit._passwordInput.size = 15;
      p.appendChild(HubEdit._passwordInput);
      p = document.createElement("P");
      p.style.paddingTop = "0px";
      p.style.marginTop = Math.round(3 * constants.generalSizeCoef).toString() + "px";
      p.style.lineHeight = Math.round(12 * constants.generalSizeCoef).toString() + "px";
      p.innerText = "Important note: credentials are saved in the configuration file wich is easily accessible. Therefore, if hub is write-protected, it might be wise to use ReadOnly credentials here. When installed on a Yoctopuce hub, Yocto-Visualization (for web) will automatically ask for read/write credentials at save time if neccessary.";
      p.style.textAlign = "justify";
      HubEdit._contents.appendChild(p);
    }
    HubEdit._protocolSelect.value = hub.protocol;
    HubEdit._addressInput.value = hub.addr;
    HubEdit._portInput.value = hub.port;
    HubEdit._pathInput.value = hub.path;
    HubEdit._usernameInput.value = hub.user;
    HubEdit._passwordInput.value = hub.encryptedPassword != "" ? HubEdit.FakePassword : "";
    HubEdit._window.show();
  }
  static hide() {
    if (HubEdit._window == null)
      return;
    HubEdit._window.hide();
    HubEdit._passwordInput.value = "";
    if (HubEdit._whenDone != null)
      HubEdit._whenDone();
  }
  static okClicked() {
    HubEdit._currenthub.protocol = HubEdit._protocolSelect.value;
    HubEdit._currenthub.addr = HubEdit._addressInput.value;
    HubEdit._currenthub.port = HubEdit._portInput.value;
    HubEdit._currenthub.path = HubEdit._pathInput.value;
    HubEdit._currenthub.user = HubEdit._usernameInput.value;
    if (HubEdit._currenthub.user != "") {
      if (HubEdit._passwordInput.value != HubEdit.FakePassword) {
        HubEdit._currenthub.encryptedPassword = Hub.Encrypt(HubEdit._passwordInput.value, Hub.loginCypherPassword);
      }
    } else {
      HubEdit._currenthub.encryptedPassword = "";
    }
    if (HubEdit._thisIsEditing) {
      configForm.hubGotEdited(HubEdit._currenthub);
    } else {
      configForm.hubWasAdded(HubEdit._currenthub);
    }
    HubEdit.hide();
    if (HubEdit._whenDone != null)
      HubEdit._whenDone();
  }
};
HubEdit.FakePassword = "******";
HubEdit._thisIsEditing = false;
HubEdit._whenDone = null;
HubEdit.fontSize = constants.generalFontSize;

// obj/full/credPrompt_rw.js
var CredentialsPrompt = class {
  static get activeBorderColor() {
    return constants.WindowInnerBorderColor;
  }
  static get inactiveBorderColor() {
    return "#b0b0b0";
  }
  static get activeColor() {
    return "black";
  }
  static get inactiveColor() {
    return "grey";
  }
  static get activeBackgroundColor() {
    return constants.WindowInnerBackgroundColor;
  }
  static get inactiveBackgroundColor() {
    return constants.WindowBackgroundColor;
  }
  static get username() {
    return this._username;
  }
  static get password() {
    return this._password;
  }
  static show(targeturl, whenDone) {
    if (CredentialsPrompt._window == null) {
      CredentialsPrompt._okButton = new button("Ok", () => {
        CredentialsPrompt.okClicked();
      });
      CredentialsPrompt._cancelButton = new button("Cancel", () => {
        CredentialsPrompt.hide();
      });
      let params = new newWindowParam();
      params.positionType = 1;
      params.width = Math.round(450 * constants.generalSizeCoef);
      params.height = Math.round(175 * constants.generalSizeCoef);
      params.isModal = true;
      params.closeIcon = false;
      params.title = "Some credentials are required";
      params.buttons.push(CredentialsPrompt._okButton);
      params.buttons.push(CredentialsPrompt._cancelButton);
      CredentialsPrompt._window = new YWindow(params);
      CredentialsPrompt._contents = CredentialsPrompt._window.innerContentDiv;
      let p = document.createElement("P");
      p.style.paddingTop = "10px";
      p.style.marginTop = Math.round(5 * constants.generalSizeCoef).toString() + "px";
      p.style.lineHeight = Math.round(15 * constants.generalSizeCoef).toString() + "px";
      p.innerText = "Saving configuration on " + targeturl + " requires  read/write credentials.";
      p.style.textAlign = "justify";
      CredentialsPrompt._contents.appendChild(p);
      p.appendChild(document.createElement("BR"));
      p.appendChild(document.createElement("BR"));
      let span = document.createElement("SPAN");
      span = document.createElement("SPAN");
      span.innerText = "Username:";
      span.style.marginLeft = Math.round(20 * constants.generalSizeCoef).toString() + "px";
      p.appendChild(span);
      CredentialsPrompt._usernameInput = document.createElement("INPUT");
      CredentialsPrompt._usernameInput.style.border = "1px solid grey";
      CredentialsPrompt._usernameInput.style.fontFamily = constants.generalFontFamily;
      CredentialsPrompt._usernameInput.style.fontSize = constants.generalFontSize.toString() + "px";
      CredentialsPrompt._usernameInput.size = 15;
      p.appendChild(CredentialsPrompt._usernameInput);
      span = document.createElement("SPAN");
      span.innerText = "Password:";
      span.style.marginLeft = Math.round(20 * constants.generalSizeCoef).toString() + "px";
      p.appendChild(span);
      CredentialsPrompt._passwordInput = document.createElement("INPUT");
      CredentialsPrompt._passwordInput.type = "password";
      CredentialsPrompt._passwordInput.style.border = "1px solid grey";
      CredentialsPrompt._passwordInput.style.fontFamily = constants.generalFontFamily;
      CredentialsPrompt._passwordInput.style.fontSize = constants.generalFontSize.toString() + "px";
      CredentialsPrompt._passwordInput.size = 15;
      CredentialsPrompt._passwordInput.addEventListener("keypress", (e) => {
        if (e.key == "Enter")
          this.okClicked();
      });
      p.appendChild(CredentialsPrompt._passwordInput);
    }
    CredentialsPrompt._window.show();
    CredentialsPrompt._usernameInput.focus();
    CredentialsPrompt._whenDone = whenDone;
  }
  static hide() {
    if (CredentialsPrompt._window == null)
      return;
    CredentialsPrompt._window.hide();
    CredentialsPrompt._passwordInput.value = "";
  }
  static okClicked() {
    CredentialsPrompt._username = CredentialsPrompt._usernameInput.value;
    CredentialsPrompt._password = CredentialsPrompt._passwordInput.value;
    CredentialsPrompt.hide();
    if (CredentialsPrompt._whenDone != null)
      CredentialsPrompt._whenDone(CredentialsPrompt._usernameInput.value, CredentialsPrompt._passwordInput.value);
  }
};
CredentialsPrompt._whenDone = null;
CredentialsPrompt.fontSize = constants.generalFontSize;
CredentialsPrompt._username = "";
CredentialsPrompt._password = "";

// obj/full/YoctoVisualizationBinaries.js
var BinariesBlobs = class {
};
BinariesBlobs.ro_js = "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";
BinariesBlobs.rw_js = "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";
BinariesBlobs.ro_minjs = "H4sIAAAAAAACA+y9fX/bNrIw+v9+CllnTypalCzKdppYpvNL7LydJ05c22mT5uSmtARL3FKklqRiu4m++53BO0BQkt1kt/e5e87WEYEBMBgMBoPBYLC12XifDcus83NczKMk/iMq4yzt7FyRi0br6Vm/F/zYyEk06mRpctMIukGvu7u7HTz0Gp3G1dVV9wYLz+ZD0h1m08bm1t8+R3njSRkOk6govgyztCjzOYDkrdInfux9KSdx0Y3C0qc/LkLCfgzDeFGU0Piw8SzPpu/eH2ZZPsJC3peclPM8baTkCmqm9QTeYjpPyniW3Dy5OW6VFZhutMkaapfdC/bzAn4O2c+hX3ZHCoAogEsFMFYAEwUQcwAdgdcOBGjRTdFL8QPa9xaPR6Of60pAC5EvG7vgpRBzb3E2vwBiRsOytnRHle6o0h1ausxOsjgtn7WMoqkoyotJOBNsVgFb+EXtIPu5X/ipn/mRn/iTZUPOfozCnP0gYcF+XIYp+zEOM/ZjEvK24zDxSRj27t3L6d8yDIN79wr6N6F/M5oe0b+tydewKLvPkmj86fz08euzV4/PX7557cc0N63AvDx6+vr85fl7z+OtFed5lBYJnRVha3LPUZm3EfYE9MsRScu4vNFBZZ0AtxgmWUqAuAkpG2XYG3AiVxsDvEon7p7dlgkpW/Nx4Apr4HzB3pTunOqc5pzinN68FR8Ydgy4jkhJ8mmcRpQ1GPasNJsQcYcV2+R1EZY7MnLHIjc2cidGLjFoAnOo3eGTiLT5JIopSiUSa5YVRPGqRZlHQBSggvg8jso8vm55ew7KjIzeXxiUmRhUuxSUERR//eb1U10c6NOzOq6P9Bk7VPP9ks73gCGnSRCUCVyGoEzgUkQOoQIgCuBSAYwVwEQBxJtUJnCBCy1y0lSmryEFitIxv00qqBpFl4mqmvFN7GJqOeZ0RrL53YqXcHXgw5yD/wJAqEf/jfXWT7NSa1oNRwhJk+7Jy81yK3jQE5XRxGFWAKTfoR9FnOJHz9e/Ojpcjzdb1/+zYZRUEZBkZMXLldXYvGtVFMgK7IoExb66RAhI+cOzM1lbc8pqbzLuiLpldgYJ6bjltZs+Tx05Uy+cqcSZOnSmXhqpXnOhPgV6XxsaZs/iazJq9QG2oeFQTR2aqV+b7ZYtHpqNl829ZtNr//a3r43fVDerlRFn6mVtE/qEbzbOK62MnfW5U2M99bfG17/9VqP82N2DOc5Wm73SSKbUETmOhae0OsCkaGVCS9VECbBLS7aa4mukxBeXs5ESSQhAFMBEAQwVwKUCiJ0CcKQE4FgBXCgAogAmCmCoAC4VQOwUoSMlQscK4EIBEAUwUQBDBXCpAOxVBNe1OP1McrqqxZc2y3p8qN0L20AV0MbPLGMPY4evbezfS2+gre3aok+rBrHslZM8u+ICozGM0jQrGxeEIV2SUZOWJy7dgOvWE7H6Xxi5Q5GbG7mXRi7xC5dewWse+2kouKZa89jPjFyz5pEfuXQSIsomRtlJR8dx7E+MXGLkjgamyCZbpd+J4U+OPwr4k+KPDP5E+COBPxP4z2SMJEN5iKp2lpAuftHKlawElXygFwHd0l4KwmDgWAzC/gD3bGOhzvO15xJ2Ybxubel+c/EPMgTGJ+Wbq/Qkz2Yw6DevoynBNXFwCTsAhMtRsd2PuwlJx+VkkLfbHrBP/CH/GIZEsGP5gXwcMG56/zSdT5ttAjIvLhrIUREKP/j8HCVz0hTrYRFfJIAQtvWFsdmHj/6fQKr8gDh9jGH/EqVDkl02khK0j+5sXkxaPNMTw0dgz5Os2th+ogiLrc4nACujOCW52Op8msynUYob6ugiISFZ6GSWgnwMMkJLN6sSGnllmWxoGGiMwdX3YpjHMxQHNryBEQUGMnM66xgp4pv44F4wJQ66cJK8PH11LTZI8PtG/P4jy6bX+ofMeTWN8nGcis9T8/Pc/Hxifv4Sj8qJ+HhB4vGkFF+H0Qz6QsKNQCLDk87KKC/fWXA08b1IfJPH0EqUvHt8HRfHqj0zPbq20/XeizSrfyL5V0YQIOerJVtrwWjzguRHURmF6TxJOHNdwpgcTqJ0TA6jJLmIhr/ruSnMiLD5OI+jpMmT4jJK4qGkyKeLLBmpr2GWZHn4qfskgZp4WpTAkpDC8nFIM63G9e+LHGZRiELvddnilfC966dZlMPKdUrSEclhcojpMopzmMgnNFNYCVydyr9+1Roq4j8IbWdewpbha9Dz52X3lGDy6RyE5bOX754e+awNzlGkIOUzqJdNDkFKe2aI9EWhA5WVESjZFNOQt2vS8xaydVWVRrsN+i8oYQ5CdVG4ZTnOYuCXn3GiM8qMWrwrOMZ245hGu0AzZZuUHUqLIC1s3D1K3ZyM8uiKC5RJVIimreZoX2gnuDD5o4IRpnWpnKJ4UZCSqTv7QsWgy+UptvA0z4H9m2cA1ZjOC6puRA3Y+Mdl/JnwJcIb8L1dns3TUSvo9TZLbwv+8e0ml/e5ym3mgFTzqTxch2Rsstm0YKmUDhxAjhD73ghLtPDo8/Uuo8ZwwAluY4BptH2aKVvHL71tKhvu3jIVJnbTNJG2zbJl4/RTb53JotKULUoGLG3alFk2DmYuRcYqILEy03X0LLF4NzyRt5gu45rCj9TPPS7F2ZBiG5UxpQ1zzm05BLK7Qwj/yJW1p42CsI2yCuUkf5lSw3FRP9k3uz/uSvBnWX4YpZ+jZfBBN2AFJuU0OcxGSpAY8+FRk/3bYNtsjV8fNfEvT6fJRtOG5WF2LTbcTGIu/GfEvQwLdrgSK/gnqXF8AhWJFKiWap+HIJJKA8JUTD5dxnlRmukb5thpmSXtA9Cmv1tT3C6CdPdJNwamu35z2frtb795+71HLQNh4sA48PYMINItZklc0gqq0FoC17E5W9Mke5RposqmVThhaA6bHtjNV7JXlXXHpIKs2w1tAU6cQIy5r1CltLOuqKBgWaViiJIm89pkOmwPgZ2GTq3O3DgIjuArFezpYGNzdlOUZHpELqM5bEBwAoOE6Hk0C5g3IU/i8oTkJ/E1SZ7n8ehZLKECN5TI7tPsx2kZP07iqLAKb5u5InmHJh8mJMrPb2bEKrTr0e3kxZ06e1F2X8LETOIRre6ibHWgB5Cqd/6Cdh4SXwCVz2aESOBAJv+EZ5nljcjo04zXWUpEyjZNMft2QfuG2L+O6/cznyAhbDYXj2czEOPIj6pfkNUOyzZMEJ5tZ/GlMC2JS1KWObDJ1VLKAbbjdEo0eYIYVFNh1zuNStzrFzLtPI+nU2AFmTBM4lkY3N9+sKMnMCRllTaWMoOyugJzoMhqMhC0azMyaY0muKzV7Car+ZnqZFULlVm0Vh1UU7sVkViNgkR2dSKd1iWBZEWSsjjPPy0/F+VlJgWsaNRoBtr8EXKm2Hfl44uaHHbihSrEUG6Wc/FDDuuF+CFXJckCiRx6thkU+0BcX4ewvjIhPsyms3lJXpwfv2KLrl+DcSmOIl+cvTIUHwNRsZGLixPQd8glDCTM2DAMNwAZvgxNhIGkEGfBiTgLhmb7QBJQkvhqJI0pYwF7IWAdpOt56/Vx9fZpRrF3baKEfWosobCPlCIFM+N+AtXPymDamffFlfVlwc2wS0xbn5RpC0TpgOyXwrRF2m3v0we0r+mmrU+gTDjaYnAhh/drIbqq+yEmeAtOJUcJ3ZNDGbe4YRiUrrcgG0EFQxv3cvPdp3VsimaFYUju3ftUMex9EmZHnkXt2byyMPwRDz0K6l/R6vmBZ1fZ/K8mwz8PgasL0HXRx4QXCPy+5wf3Pb9wZG6LzNSRucszdQvxpxbM9v7uLhcWCwPPoM92yQrXnSqup8+f7C1Bd2cZuveXoftAZGYuKvTqOsNPi70FSQrSWIk+yJK/EPo9hb5geGra4Bw+Idcma3N21yoifPT2w+BRs9dskz2iH3GqIxshRDmnMkK0Yc7SRmyx6rW1jInxVRhfiWfRePDlT8oWPjan5DLhFbQ++VQm4KzKu1Eym0QhPxLB3/fu0a0uT4JfmDDOCUl5Ev2NiReoCfIDIPipnxUI+jP+Xo8uufE1Nr4ubLqwrennsbHRbOLSw/eFuXl+rZ/aOpIv7HNtZooAcjh2snoPtmD2e/LMd1t6A/CFkLItO3JAAXgQBj/2PFFXO+j/6GEFBwe9Ac3eYSIjBvaDLA5HTDisohMvRCWbkN5ukU7pbbbub8Zee7u/C5Jn6/5ur48FFnJJZpyEyMijR9cSLJb2sMfXTX7Gl4h1XP+64F98/izYF0X/EV+8k80WosiZfY+EnNNFCnagwyFZkl+Gu0GPfSQdIo4gJ+0Hu358AODobhLGHSS90Ks+dSsUl+VqCo2dhViRg/DB7iNRvvNgd0/iANQXXa8tnvP2OG5ak3rGWMu40DMuaMZCaD1nr0wnrlz4a43l4ayQe2F5QB6VewTPR/fZL9QiQbeUQ+5QZXtAoAwaz0Ik2j5IgFaEP9OwlbWjdgC8B4wEtYeR0IcdymoqeCChxXihlPFCESITbLayTuS1E2+LQkD+npGBnICZMPodCoEg0INtlg/96G8C44Vh9qhFVWlQVwlgCkzFkoBBqKKLaXlIh+ogJI9gM8daKTuENj/BpiEVG2Q5OIE6PMcX45d32BAV/Ltgnyn/TLUBnAj1thDqLVCEWSvmtpZaGYKvXw01Fwec18rEXARlI8dx4PoVcevNHPY9aIq/uXNF7Jwgr5wkVCQJr0FKHz4zaHG6gtytgjEzoyYVoq5Z/kJJdqsCXarrOvFjLC3P82x9SWQYJaDNuhI9VYIeMxRseptOQUK54CCwhkqQDRuE/HMeJeJAxtJNMG2j1FKAJl3gxw0uzOZIpK5iL56uEjBbMQ3PVgmYTUm5oekPfNnaCDQV0sQAuGdDaheYQPlhQ9MuMBHHeENpF8vb4rJnQ/nsuin6SA2DPeaG+6iYw2LPrDbDzGmKjb27itzlnWpUwcdVpVTOmbS8RWX3qy8Gti4i1oZcrA1j6aMzUEpS1KIOHH6zHdO/OfPw0/QYqQRVrPkNc4e+WAw+dR8n8ZA8QXXQ2BX1d0BR33lAf8PeHgHTMv7nnPwyiUsbdhdgt+HfQMICZ5swPQ6pQ0wj0NqsumDFYZBBX0D+gc4EVeSM6p6QeFwB4v/1ewIoLv5Z6Sf+13/gBw/vC6iEnuebyOP/y+x0OCGjx8k0S0eOypAQPYlXhbA9TgqV/3OcAVdYZNh+4O/AnrYvscqzq9SCub/r7/Txfxxknic3v2SZjVS/7wcPdqBK0ehhNCJlFbOHUOUuUOK+6OrhJMrLnMyLmjFScNkwQ1c3q2HY6wVAiW0Jl+VRUqUYVvdAg0kvk+yK5FUE8ZQ52HkIJP5Rgy7i5HfHMCDvypE/zONpkaU2YWAker7q7k2ULmfaoyj/3T2iwfZDDcZVE0KYUM+zZETS3B4vNlbwX6DD5tGNPfoP5X86HG727KZ7in0R6P9Mot9ju1Go6cE2gP6oAR5HY5KWkc2aDysdfpPEn4mj7Qe7tMYdvdI3OZ7qO9hgx8TyTT6cxDZtdrd9FDa9HQ3wlIxcGOp1nUU4W602t6G7UFnQ7+uQJHL0I4C5GDx4QP/VYJHnq/zwY9+/H1gEoqDVQQTC/PgQ/6cgz+f5P+dZXFSYrN+7D//poE7BAXwPsIp5CJmdxKlrhuBk+lEDO/v9xsXcwcNAnwLx1MGLPfUfB8tGY9cU3sZGd7T6nsU5uchjW+IGPz7wYQ5si3F+lqDscK49fP3ZEeP9LMtJUToGEecUDIqqcz6cFHFUrU8X0M+jOC0usjxzyA7+HwecZEXpQhAFkbGQ4rx3dCJQArVGMvSDB1TobwuGdYwELmX8PwHjkgj9B6oxBHhPEhC69hhsCyZlkC9APbsZkauaxViOwIusdLMc5REp6l+mozhKK7MXF8+HffyfAhtb5P+RSVRZ0+csv3HxhY6VQ+pR1ClLCqBX0WfqM2KLCgaHjGbCAYdzXw9r9elR3UMAX6UuodLHidCXA/GKgIw6nMSXlxVRJZhczq9XePDtWCFxyIL7FFkN0LXw7vQsRmGQlZWr39+xVkEKKFnUxTkUV/wvMNCosivKKfGfAeiQwIDG9gP6rwZZw2cPQOV5uK0DOlcAuozqKwADdS4BMOlQKKFhQod1ycyAqoD3dXahsO41IAhQMbhP1zYduiQkcY3wfaqr9k2c3aOwK0dQgE6JS8PpafmOrnPO03qTktQx4nw2MSCn7mBL1+Moz7K0KsLU6n1MRvF8Wrtb6PUpampUGHyN2i2nD4NyahgP7qPWohiSgZ7M81liNw6CMYBtSj94aMC6+Qf5DBb6INg2gd06RNBHXYyxvAE+Q0O3U6bjEAS7OwZ4jTLxY59qEkqNYtBMn6iqUw8BFBUaiXk8St3yp0//F8i923Gcloc5iaaOrRnnGgFYlDenWVGzO+v35chlw2FUxGnNLu6BGLbX0efoH1mdwoBboh+3FeiNQ6OXgvFNMnoVDSvVbLNuSIanOrB7NTZAjvLowuZiYCTYxskNWq2KfF/NVQZTXT2R1R5qUFUWp2oE5Vsx/CdRQup0DmDAPpV9PR3YIaBhJevvBvRfBVjDgMGPouYHGnAN/+H8QnyVtnoSzaKbCAZ35tp/I7eKsT0h0XByMr+8dClcyC+7EjCfV/UQ5Pn7si73WvMQJ5OESeY2r+PUud+j/3KY7Grk3N7+eJ+ttpKlnFKH8pPiTicHKPkJc+rGZTvgmxm1oTnNbiLHenOfaW1qAp5Fo1FCXFUC4XE/+lACulZcrnVI1juL0pELwT6s88H9HV+aZdxSdec+bffBjwrqbAJroUsl29XY7SwmaWpvbGGUQHGQattZnHy2NUEcbfEfh1qqAcgpXSfnAeihvjLVKgl9Rjip/pyl7vVe11KXrhbM8MIB3crGj0zJVir7eUU7DFi20qDPia1q2orm+QSEfVIxFt1nO81ADPh5No3KrNpFWI1+FFPpXJpQtW1wz9B+OKBbDgGD0RnXE7i5ttRU7aQ7AAH1y4REpWNJo8vKQwlUs1nV8aJAZ9Ps9zrjpeTGZRpez4BxCucdU4WrukKhtwX1yRzFy72x00x5c1pXmEq/vJmhFxDZCJvzlDfQlN7VelHCPcFUUsUhTGWtutmw8F9zb84GuS5hZ1ZAN74s/JxUUyvdKuYzgp6fA63GQLtaCJ/9kCgUAicOgQLoOwH6gGW08l4j/B3+npKiCJfdDnOOQYEX6Q6jmSwJPdY/0RX7HxmoTlFJVfj/gd+geJWEn3pobROjbXLQe1TuGbNNDHS8eqDjWw80IvqLyxlcIsjOVssc5s1ZeZMQJ8G74vxjnXsxgni6IzEnJ3OXZcRU2Zy4LFOQVmVLYqO7detyng7pIfA1PwHSkoADyQfCBiLsfQyb9FfTx8Qn5DNJwgAS6S+WeIo3r8I+JNJfLJEWOkzi2Qz0gW1RC09oLrxWGV7LUf/6taU+wi8LzwOAqIRkYFD8pILgHysvR16LWSKdT6+Ez+gkxFk5K5fKkndhiWf29Pd7YLMDvJT5P2Rlu+8CveDxy9e0LPt81w9jLe/xuzBn9aYrcZGIIBZLPNOH7OIqOuWHz8Q1Vvzqnv383NdBnqFSnYfNraaRzC7PwuZ1x0jm10oq6UcnL8OH9wGpbHkXnHdVSYr3jbXbprMoJck5CETq5R1mZVd+dF89fXYuhAEkKsflizG/h+pafkAZkleVshw6fOgQWSynKt5moE+iR3cgbymgH8AwSo7Z5V2ZPsny+A+8DF3JuRg/qdz/whWw/s6s8wJszWVZVhb6/Qo9hejl1gc+dSn+d1xqHVNRRIfUhuPJXFoxEE1c0QT9Lp3gjNJ9Z26IF08OIzzrZB6MRWutC4gmf9lImrnM39ssIFG2GLU0Gbrm5q5xExR5uLKGQBptlmbKxii7354St0CGT6HKDcKxug8pQNTd0LF1z7HK6bfBQE3O6t1UmcWvqCpQ7aaqmtyle6LdGhspENwYqRW/cBQRd5lFtJQnNL8hAeqvMQ/cQukOU+HO/eeCrzpBaDKfGQzE6mflyvYJg1t6a9sQtt+V0U0BXgmbYeTSbloF1O01cyW4gwCw14yKJ4yVz24V2oXU/UJ7CSrvIgaeOC8S85ltXSUW812/TMyFgroezIAYU5GqxEXvb6PWGd8eRrJGNbHdqzXuGjWOl7eoXTEJbH2XbcBKuQVLSkN94bEr2SYMP2BjuLjuvpCkptL/JCswds3LkkzDcsD3dLLKcfllQajyQvtVtpr4u+k3X5HLsun5pHv49PX501ORy74g/xCGCXRthDh9+fyFLE4/IP8UFTLIduETEo5HvHbXctq1nzlbVzoW8wpzo2N59/zNCUUsbjXhJ6B1ns0AqVzvVezqVd598ub8/M2xgGBfAPEkK8tsSjtmYxPmHIti7W6ltFtypZb9KXhNqdGfVA1UYQ9UqnepcHUp1QaqcA2UUhhS2NRkuKnJtE3NY9tOkJW1FgH4OdBUkRf5H1JlrrIDx1xXsn/OlY5tk5mDK41J1O5UmESm0pckuKkuSRzLuyxIGs5ONESmQkOCm2jInt8SjYV/Et9lfDJYKhLYjatNDl3/svTN5SXg+i7c7Tkz3msZ336IYbJSwnLsbJLyZEpMAQJk3CgVlXSUluJkFJFILWE8tRis0w0h+wWdv9mWgTGeOVgV1jOzGfNZRRT7WQP/XTUdi5mWI/7egfj7OsTff2fE/6TE2TDYgQaH/gtwp1sCfj8C/glZ6SZgLTXuIA9a64s1uoh6/jL5/c2JuPDfktsbswBxUtkBCwP5KRkJE1KMQfTUff5PUxUF7tM0ug5VvKq1LEG3N9H8eatQjqGfKImhDlqn7LxdqaKKqedr1NL3D2ZwIQl01+hRkkdcg8NHYq1tIwOt7BdZMtsochC1Q+QDXa5YZaAw8sBxxONj4276gNTspo/jVAu4Os5JVFKjQpQ2gHcacjM91TaAyFSce/SBuzURptU96pRvS6dsJ0pRD2Wr9+5tPOuyrh1OyPD3o7ig8+9ufRM3cLFm61qto9d/rqfRdaWn0TXraXStwtTJVm/b0+i6tqdABNXTOK3raXT9p3u68OdLn28QjEwb0IVaTi75KYFKEOcDKoWGJhQJ1NRzVuLtFRkXK5fhGUNnsMZaScsQKtwCMfZdQVi1tohLuopbljAXAXX++oV74j4ejV6TKxWFMUrOM4xLSPvLAgH+u4zvtM/OWLBMRDEMnWFqnT2nhDZjH9IkrZeKsHa7Koc2rgEKDOraFCNFbeEaxBeL/WisR5yQgXuk5nQSvo35ea1X4dZ1KxDhwzybu3UKy2C4jJNHJ7DaAKMcZuRS9lhNAx5fWJX3DL61w1gazZpRLVcMUgWtbKZFnNAQEhEq6gy5h1H6A+4RZn6DTGflDR5LQzEpkj4riujdxObWw5RfdWUMwMimRFFxFZdDGmZtGBWkYQqM06cYxvrnp+dvfnl5dP5ij/NhvkUGS6FfPEXtUoAXW/Fy8CdvVN2MdWDZg1I+NCRD4QQViuuK4zqjO8errIoG1qywZLDN03gP2LsFe1xm+ZBYwUwNwV9f9Ha2VB73iplH8IPZUhWhV9pQ6bIgrKD0o+k36cVSZiQ1mUCaS81ktMcRjIn/mTTKrEFpaBVnXFEtz9KtCliYP6sGZJRqeUx1Nd+I0lHjBZFWwlNtrVp4rTmaCeeamfDZ8r0JW98fo7cVGekL8oo1O+dS7zzGKGbnGezCZHwxI8sMZXkSwbx8jLoMvdrtCjqdZONnnFH05EgWOsF9nRYx07Hoj7LhHKO+/Yy6TZyUN4xnnw11zcSeeWbupzHqSdRrAdbMaIoPGxRa/pv06CI5TGID+TcpNd/ayZ+mpCiiMbExPxvm/afJlL2roMNDYh8yKxk1eoRW5awm3rOL0uuoVDn5J9RfPk7jKSX+MyTFyyO9miKNZsUkK2nvXBnACMQI/E3Z7QT01BI6SUiqxVl/1h0n2UWUHGcwrMfZZ3JGkKPFgHaj0ejpZ/jxKi5gtoNwaE4RcgqQTT8OD75UKmjF3sJz1qtCvb19eSjj7peVpC4N2slvsgNXiPSXKfzh6kK10EQLrVopJXQEB89zmc2UCwxCGJbd7ArKHHEarJwQbm7ju4xTrtA7B48FNRiNjrUa3KBdy6fhse58Y1iXzWLMGYcP+AilGkaQvMiifNSsb0eafR6vtmY7iksj0ONay5SzcNVXqMeu7Pbxwsz9wE0ZPDqkEXfD4D4DoPzOCP86OyWXMPEky7ikUMsDRnbl0uDZ3GXHXzIn2Mxu1rbgaZtBik86JGc07PpK+Ulxk01/ZgBxeXOGz2eFYdjk+8kmVwLkBnIZvqqaIW2ouQoNHqbbmgKVQN1W/po7LRWa0bFJV8We4Z6KJh4rMPnwSE1pUEmd5YSdLCFjWD5PSFoIY5lrHbJxd8HQfZSzsNzTOZc4tjk0ZEjFvKFnSnpZYpf2VEt8B3JsBqXembL4PU9+v6CmWOqZy6KswrDJN8xuvV4uLuN09DQhyD6PL4osmZfkhB9MqPh7MKVj/INxnIqwR0PYDbgSO2BAaXgFNWVXTIbTICgj5qlbeoON+N69tCsOPID5GS2A9zcIhm5C0U1PQfBUuE1jCD5LsqhspV3ml4DpdAXB6IQC+DybuWAhmYOyIKUto+WcK4rNr1+N9Ih3vukhQu1bYdReH6WYLaZ0MHHh4qRfmC+H4uaMspcxYNoO0xpJHvBUCzWjrbA+PuZjDRnRdsrLOcCB7KDaxoA9YgRraI58Qn3UUzejZHZ1frSEdfwkJB/Sj913/oT9eD9I90Xgx04AY5V0MKMdUBj5+z17bmseRizqDk4VDKs23wibaZYSHgdzHM67U9S1W1vs4a3u5v+2Wt2297/elvcB6mFx2TH2oOePBB2x5Dn07nz//uC83fZGjJrawI8/nH/0GApTNgFnIXsljA/l6EPvoz/60Mc/O/gnwD/b+Gf3I7uO6PlDRjdAW+sFe9SGoX8eVjIExojwVfh6Pr0AHUvD7Bwa9vxLZ07w0RtMw5rXzK78ziWi5M6+8i+9xVRsa2NGkKnnz6ykGVRhJQ29RSvZCHtfv07gryfT3Q2hJwryZOan7fbCNRlqXnATA5eFsWSfQXYAw5h1Op6rIkdaV38fMP6QqWC9DmA6gw1ZbC8QpqA2z3LMPJpmosJfs/Ncm6QF6A6PzVVdhqJCGXMSt+SjPd5gqTLAJYVUhYRavNC0NV0yGTvlTsd3pNa6NZ5nWWMapTcNre4GKKFJIQ1i5kacvlNsqE9uHfL7o7ew9g0uuwEw7Ao7Ny9Wt3+VL02U3r7oeS0sH7fFkIbcYEhZtmSTlKgJ1RgelC5UZ5koFzMzRxzohGh4myXRkLSa//u/adNnj1zIrjT/3oTOyHi0/JVDJD1omerJYr2avx89fv/3pk9wwTiKblqe/lqfb4Iev3l9/kIAH8N6NVkK/v7p41MB/Qym43vQtZYWePHmrSzwIpujzrkMm5ev354/lejEKax1y0ucPT188/pIlDgjsEsZVUosGxn13km4FI6t9QtqJniVAVdLJUAIjidlV39B3tRaLW1VBnQ1xFLXfMu5K59EF8Mcd9/tw0IQd9+zf94dVOwFTNGi6hQFrINgpoNH2Pm9mIeZX27z0VxzVlmHysWyB8PWrMV6kGw1dos6q4oxr2uItag1rqwozR9zOUIJUvIwleyukpQrYvb29DdKa01A8QpjDyo8ZD/cheGFv6pul3lmwCJmyz3zkB77cs2y1RzS14hg8RDGKeJLi1NMy7IHSv6JOjceizzs0RDnJKd7K9jud9MMmynzmy/8gS602rYKeoUTZCvqjhPvy4hczMdjUIRZKMps3GoySPTSJ7h87DWa7UmXbwm9BVNFKg11UvFcqj4QnFR4f6XZH0F3IuaQc4ovWqGySMMZR12kycsp1A+9gWSv1gbdBv2pzgjdblPCJGFd4a26kmIW01Fi78evNuzkgkwgb0qYVUOgEJVrfm9Rm/flzxyT4qrEA5NqgHzWus1/+vmpHcB96SKsBXdfCviBfOzqjVitDmwytix9DGO48zV+PaOTSx066PE4vHVTd79fByDmLkK0llnEhdDjW74hsn5iAi0t7y23t/NqndmwAh58kROZyzM+henwo86nPwQM4mPOzo9W2/jJYiXMwvO8hXV8brBtHdkX9pH58lICilnKdI5DfuPue9S35YSpiFI7XuLlp3hxw3UK4n2vSbHcAWCNLhon89+ggyV0sFyvg+XKDpaODiLCq/ul3Nq+Ub9ijDu/Xr/ilf2Kq/2iCFeP8b2VBnw7S53KLrGELjnLqTmxqlGblh9Y1WlL2rnB8kFEMEsk+Eai5SWzbAkwNEg6ytSvQLwM8S2RWfCL6o/T0VF2lSZZNGJ6h+ZcwqzCzaaf+ZF45b1Owm2t1ggLaR8pQtTSWoQlwIrEQ5CEemQKNOOSsMnx7DbxJQLz6v7J6+cUhrSbs3SMQj6sXu4XEMVngEDV1WwzNtp81MpWqL65VT43y0crNOO9VkSDG/hZGG0m8AOf7spY+IOVVWe0xB6rwfMzqmFHSsOu168nq/XrCZ9KmT8REyRiFtiB5WRUGYS9uVDBJ5RVCm9wAa38PnCAw4hw8OsK+Ii9ZLjntt1wRmjszdPfQdOGtRPqazI9fBya3kHLXJXEnNMdhZSfECDkaVsAGlGkwZtuemtKBboqjxnpMYzDwHV6qqI80L0JszTrO5Q5QwYgelzHmXpf0nAqtiC+vVNR2xT+OJbMF7TD4PbQEHUNWrMr1FFt5HH86tgoggpn4RwZ/9OIyxPsHjt/HEzRqfFxCZL9Yl6SVnMCBG/6M8+3M0TZJiwRmImHCN0R7EWS6Ibb/dXx6kU2uulG9DHJw0mcjNBcPYU1JUZnLQssp54TAmwxX7LBYd7Oz6B4oS1VlI7jDC/RQgbw3RhmNwOCzUwC2xutBH8m0un8UX000gnGn5B0V6E9KOl2MCkXI4LBdm707QSjwZ8+kfaXV7j0SN6xgrOjpNfZiBiDZMM5HFjUuajmQ7LMk6rWUUnLuM3Rq8OtwHbGXcOXRvM5W7EdYFvmS2egJZEugNxv+8qMhfDmZc89f6KeXJx5rayjbA4zWQeoOM5oBxOPy9qDCYPm6lSCGqaOjWN4Hl/LfODQVYn55KEDAh9B5JKWYVmEbig/DUmnv4m8RAMudIqudaN+kO4HvR59iQj+ZdI9YxwSoRSnR6Ub0cDDA9JjEhUwEbmJt6DuQH5BXWb8FHSfjC23B6Fbo/36NeOrsAOCZYB+VCgXnIPdR9qX7kqrJW8+RBdYUCA26AtVGT925toDsxlxxNoaKdoVUvigJ3A0VgDOYei4/lCYLk5cm3A7OuEdc9ATiq4dv0HXLB7XX42DsqSTdGrLC1VjHrYIPkTVZ+lcmbBRFm5VCmXXnca9MeBrBsCwsK2UYrf7oWDcmXRqCgtUx2ELoBSqZfdZnCRoQIzwCet371/8AvjyyBL+3B/TO/9+ZUgO8NyJGk/ssrCQynJcd8EZfVW26EPInkUV6QanyGKGpdobde0XmEdd7cuijirMhtAu3TdK9y3y2NCBAR1o48uivf6jNW8vYVz2ntp4NYiYL4EvZ0QAGiQlMJv91MZrSgA+Jy/oUE1BvVosqBXPdvMy3kZm8oYLGvyIgIQRE4uVM18uGCOx0bcBPkRSLtK36DDGJB4MbGRK7K5ZPxr7jerol7h3HvKNJLqBRB9BcMQgZRMpZZOKlJ1wKTtRUnYeMn9KxznkYG6cQx7geXJrDpqo48hyHnJlwTzmnHM/j3FFbM995uSI82gUjqVklOi3K+j7U4CTknEZ4EyJmeS2knEGBLElm7+h0x3dtV5Nacb+qB3QZUskhJjgrStJZzBio8467Z3K9vqsvVPZXr9nb/JmKM5GpuQdVkiypuQdAj1M4VnF7pxjNxXY8YRwqmG3SlIPw7wz7axu7Ind2BNHY4IUw7AFtSpSmJW1Zm06dbpWnAS8zLJJaegPnRDvGQRW7c/Q26AFLAfA9OcQf84OoDhNZ9UcACzNwzJ4xF9dYRK5wsz8oT/yoe5k3RUmoSuMKDdg/k/OFSZZd4U5r6ww57dYYc4rK8z5khXmvLLCnNesMFd8hZm1lwiArT6M2/L8sVxbxsvWFimmEn1ZufLPYVlZ4L5VhThV7vfm2bWWgUb5xeBZV+wCjvBgFJedZ13qZnaOfgvMXFuEH5q9pq/+6/K/4h/5b6/5ceB2B6YVu64sWOnvwo6V8h5TvkHcKs08tfKy1cnr5+IGE/zEsExxOY1mjRZ8efS609nPEgJ+AsTPBBtvtODLoxeZtPbuHJBK1AFChZSro1FlGFX2Cd49kFGpVBLGapK/MQLVeQbznihI/KJ3yhJidIA2fufgU4ci3irlpJURqP4PITMRQgp/A0L4TyOjTpNR0qBWB4w2Re++CVB2EY5fiLNg2A5dB2T33gQ0nXx+43dshr3Q2YiKGQynqoLv2/U6+JU1UQmbtzW12FSgAbCeff3aeqbutf2zXBlc99PQuM+lfzCjrgzIytCVkTRmsfwdo/XfuJ4WFeWJGSoRkyqxPDDxmRWsFa+6UIcCkssGUIGTHhUvYrNAMc0y+JWOj7MRCS9AxDGhK+qTN9b5g9ifhhWXCgFANcUnIPExnnPYLLNZ06AFMWkRa7SgT8A67JdWbI1umWH629NXrSYl2xY9fuCP7UYzkODViwvUN4+ktvsCp7JIZG7goicyqjZopvK38NDpasG0B6KElmZCsOdhqxVzpxw52uUCEWUxSxyo0gyW3IiBHfHwP7tsvC49UfUlqAyifTOm90C+UKsXzYm4oyBqYKZlXGuj/HkejWK0MLP3PPWR8wYEL9jQi0tnMMoAwlsMZJMokA2YQMD0NZgq6pJc4iCCn0HE6ecoiUeNLezBfIZWc5jidL3lxxEDe6YwguIEoctwGJqz5t69jbI7iQrueyZ8LxAbnFOlRNOebbBKoxqAZHr3Xj+1o08Aa/HZxTmexkKh/nGA6lpLS7gXeGEYPOru7vUGhiWJeO3Uj/WUGFNyPSXHlMKwP0HKQgQ2YDNAUvyCgOw+iTRb6LiLJuDzrKXed+f8CmnYP99k9ZYigxGV/3Ztdd8Bo7yvtBdDeqynyzZBQ8E1U7th1C2iz6S1vDmMSwGUvgYmvIH/ruC/icpFoSmBNQnabi/oOTBtUHOE1kDM8ATiwAwjyaP3Go1IwA6HJIMiMgWsJMTVYqezMDfCFmUpNxPhuodNPiMwYCXe7ckp8QrmTsZOfaVvcD6Qh+85zLa8KHHc2IK5GXT77VbRCbxNVgVLHjDm7fmZZfYoqO0hk1JjyhBGFb/FcYAtEfoCynAWqTDWSLu08B8AJjZ7fPas8qQ4bchFloWxS9KOjDRBupQtLnl54MNr4MMb+O8K/puYEC2rIbqlsqPS3L5JXtxuyti9ma4qK6ZWVfbEd5M9xqzRxVD32mvHvpFyU0m58szvieeZa2DuovjAKV1qaf7vlrW2pL2NnM2dw2/0m7G5ubzoLVBtxTcZL1YJuphIw5r5g44MYarPeHOep7o8keZMzqh0tqdytrOuFO0wM9B/ZtpRYdD+WYLCh/taBcaGLhJRlllsuoAzhLbSRn7e2YWK8vaupJuZ7RcAAH/bu8JJuKbrAdnxBqlmQwBOyDviBObgINgzMvt4r1Fm4xbEtEdA6aIjz2WodXqvAoOVaFBaBxyDrVHx5FmFCZwkhhUz7743yypRuoz0xUrSF1g90hYagF9t+qs6BIXAgoLSXzgUt2dcv8JqpahQ7x6Vo6ZQqO3kpL6TStpOcJP/3eeZH8EifKPOdAxG4Qa33p5mQAv2onYIa+ukkwruESZLBtBHAD1fM4klkHE9KLpso/ssicbFvb5wYpYegFD7NZD3honuk5dbfc+POohnG5ZqP8Gf1+omIG5fJqaEmICE+MLODIRcmHz0xy6qzBlVRmGiiLCCACNKgKsON8xV+j/C/stscVBnc9HcH/kRdAzlVIUi3AMIryJLqngL9ZurYkz1omQq4hS5gS8Fw6yAr0GNVirvmuIs8TsoEalXp93gl4qWSJWPpwkoiQW5s9pBeHnSzrf6ftxGIyf+wn/pc6+bfOCd+siS1tdY7+7QtlwMse8nWXIzRvOopQvJjm+0iIwW1vc0RX2pgmRtRXQV4EPvY/ed1+7u+nbqe0xV8yAOg0EsL1Ur7161kzEqiJ3VxqJaqibZeDFkfN76LVpmzfm8/oXa7GQFcSileBECx7qO2nygdVoHa9P6Gyij9cMUu0YpVqTKgVS5IlW+YpByV6U5r/TfNkRyRshdd7HuEC2bm4gIPs3WzNnzaHo6ffDMzvi2XR44uifcA7+BhZUaBs9t86frlSMDgHoAVosZ7x+ZBlUW0eRMt6XarRiGVtqCCa7e0jMsssxJy/AQVyM60rJiWMBjWMBjWK7j7sS3N1iLYTalLqPQ0GIxcChKePKDdu9r+9mHf5ZuE7h8WoB+DpQ1Y2hEZMOUM0LPigo8/cCXq6VtWqx8dQBjbocUQd6uSzzoeXnUbgu3wZ+fj8gl02FfxyoRHSChXDUDobuPqfMqNV79sI8I4rxoxKOwiZFi0ODz6Ye2aEuPeftD82AfN3CN67DZazZu6F92YBE2f2gTE5YfQmBObOZsHexviXYPfpDBJkkxjGbk3TTBYRL8I10qtj78P42N//r7f7c6g/BR54+PW2OfhAfNe//VhIaHkyhHe+XjstXz2s0Bs4vXG9WbI/jaY2b04vO4fT1NBhegTd3f8ZvtizKLWsIp8hNkH3Jy4g0Gt/mzQnmTyDj/G9eBi0iNm6DhIFGjcd2n6XkFnqUXVjp1Wm6EjSaTJns/tIUlnHZgRIAqLKuTzaJhXN7sNSVIlMwmEQfiz2V26LBSGLk02aP4Q40Z1KQRM3P6wqxZsWJqZsa1GXVYz6TNTyJis5yNdTyMNLq26HjDkm9ssksuL7tXtXxedidLOd1fwSdjGq6tM4uwqXmetP7rT3TUa6oWJYQUHQ7BZJl8a+GYxrKsJ839rfFB06tvqtPxFlSFPc+gCraYszW02Rw4znni8AfU05C/q4wNQ4CZgq9DDUQxNgD9UHsWtITtEuNEiDIfiuWVY2LIbmwdp3/vvwGLdos8+uEGvoIe/d6jH/QnjNp13wATX3v0Jy/htX87+N/8b/uwSZo12P0xBsaFQBMzOpQCe7+15fmULgggvyIGAo1cvwHrVppgzS9rpL+ykb6jkS2TyAe/4Y0pOuB8FtyF4h4QyrWOttsD65jtlFwS6kzPjzDmzlM2DK4swk3UGt/rp7aSOaQicxo3DZbhljo80xY7XO7wXEvwAP9QhIxJtgFr4w90+MKmIeV7TJivtvTb/WYeRwLGacD/i9GlwdiKXur5dy6ay+ls09FF5zrDRD2tuTGi0RhSgjOjhGcTaMio3qLGikpufs1yXSVzXtJV7i9A9mW2pL8k0ZxzOFg+h+tOUMQREYvzRp2YVWiz3iBDgybbuGa4cQ3TD9nHVeoK7gXZ3M1dWlSrgPmHzk8vUxqvp7D7h+U7sApPsjxklx6b9LXIzmU0jZMbNoHTaGrrzBSG3jihEHoTBuRM1HclNbQW6V5kyehRE/8294Ah82mUNLVqGWkpZFxGSTx81GT/WtDVwYnp4PzmHhxc6H7DFUzf5bR/o8sf0gEXvaIdmr3ZDLo/7v41zzRcfFY9pXjmYMElJwXYAKMAHszv3uqYIGuH8gjAtpDredrxQOSeDwnMh2Q/EvMhEcb9SRh9SD4Kh36zCxPWhTF04d3ahv0xoDVnVnsbYy3LMOivMRfHrrmY/Wfq6VNvYk+9zD317njglqxz4Ea9ateZEzftCmrBbafG8hO0rPYE7ftMkevbTBF69jWvOfsas7Ovv/xUaVWH0Pu/csJUzgxXmjykGTRsliJqawtVQn2X12ialrOm18jxKhVpNdut4EFvM94SB2m1RpA6e6uwe1RPIutK3NYCUlcPmkFc507aKUbfqychkA9NRY3GKGwewyCzg4kK3eg5hR75sf7IIgy82saajVe0ttjZRmy3sXzcG380q1uC8F+8IXAcJ/3bKN/+FxH+u5IdiQ0SY4+emxmp/wAZwZNvN0SuQ/D/6wcJZ0fd5u+3us0fCm3O05UjM8tJV8I08NlDae3yGxjUvRGljayckLxxFd10m96CenOUrmrom3cNzMenRoCxrAqxtHb0tkJibnQ6wA7tZqdzwM9vjLMXHu6h1e/u7my2tGPQLXnq6aHwpzdgWtsYx9+A5VsDNzAPOV9v8h54f9birTdRv7Dcqp36dYWbKn/bf3Q9TRoY8RuvAIWNZtDt4bSP0lGUgAjApDRrNh5RQ+zG0ZvD8/cnTxtA+MbJ2yevXh42mp2trV+2D7e2js6PGoBVA1SXra2nr4GxJ2U529vaurq66l5td7N8vPWcX0TZAsAtBIRCeMAWBN1ROWoykzLUze13jeZvMOA/DKdNabRDAz9hSZ9jcvUku8a0XqMnJgQbc3uK6UOs5/3WbAAB0gIrqaLb7/V6iF7TpFDQbFBM8TSA6ULmAYEYmPZv+1sCxnF2I09Tf3Narn/zmlblcsD1BsbMRA5YHvztt8ViIKoCDRwPrD/H1oH1W1J9jEweVgvBQ7GsuBME4uA5m5ckP41G8bwIHz7gD1lXo79gGo/+PaGBaFQM44jfcXuc59ENxmymbjYsMh8vwWI4azZiLPSh/BgSHsaQtWghbL53rIWTotAU1StXpBqaSF0PWLZ8N7Yuajt7Dm46L+i7sBF/kB0kHX02UF5p4KEAfTddlz1sqxHZRlbLoijroJLG+iDJ2wY9Xz6GSJ8d9LxbYrbwXxCLo56twVC1D2efkTGK/+Po+hVdRcMHHIpdPJ6Zd/1Y4iF/qPtJEg1/Fznjyh1ADG89pjoFLRBACQw0/jgfX7T6u7t+f6cn/vPcRfqVIvQFKvqfZ6B0Li5Ih7v626DMjdJ8fg1IARRw5chb1mG/Z7wwKr5SQkYJC4apPEhE355jqC09sW+8ZY6HXHMWLMOkqcpw0VXlqi72K3ln9L2tXiVdpc3TuHwWIYfIVw0xCQM5ctee+UUtikaeC0sDQCEauLIprrsVVN+o6UIhHj5wN46uNqI0OqbMC4EQLG43RsYretdTdnCSXb2mAxhumANa4VyWfFh5j56lw1w5m8EviQZLZvMnCB/2HMl9C5g5Gu5a7aVlNs8t2ht5AqWjKP/dRouDOKgPHWeX61XHbXGjKMxu7YKwfaXF7FJSa43QZbWhyrytYNfX3NYZU37P9mAe6+0xtvgX9lB0kO3J+MBV+HQJRO0jla7wlZ/+AI0Rnzz8/9IT9K6466wjlYDSLJnHVBcqxaAimve1p+ZbVcEtc+1Au//61+wTgpEpbvuU/ben2IHGA/UUi65dFJN6gk03pUCYLyBpigUzwldUC/fK7tmKSZcae9FDOKhkYfRPzKgU0nCmbbmxpll01HVQqdrpalC5RF8yCWWpQ5WWrXzWvF1I4WBrV2WtJrYMjf4KNPouNPq1aPTXRsMcXPcwyGxtKFQRMRnrdghSnVu9S7CVyLUH1dAy7U4YmbQLJnhpvHQuNdLSJZcMpdUh17VcIeL1ArIpS/t1tVXWDUppDEe59kCcrz8QSgWXWya1MPsPQOsPvLphcJJfkd0it7PrQ+fMHKr5OLRm4dCYe9W6+s66+qquvlVX31mXpX1X4oiY2eztU6uICkpgafLlig1KDSK1U9cBYiF0/j04x7X/uGPXeNDeml5hrtUhYVxZbrF4LuFpyKHbdInuiJYzRj3CFrIuTnDWrbaMlceCZQ6tWwMUr8PVEoHBaTrQHyTPurLL2ja1DiUXMhIN1Tm6u63tVpY668F0ClTd8VbuzFQgKBKOgur2THUbXa7efRvIuzfaS3EzZ2FNBd9wItbYAv5UT10zsgJQ7d968/JsrclYtWEsn4+WPaN+elqA1my1q3FMXttystLYWE9nal5ZwelzfgnNUXAVF1GoW5KaWXxctNasPxWUVRbDVQNV01GzHtXXv1pUSFuTGwvM0ZBgt3FMHKihyomCtFlV6pY5rG4FqOpWBi9X3ZqRy65cy6K166Cyet1IVi61pzmaFTY0d8siV2tcFlg9nRFsNZNZtrx6CnG7nhtTnqkhKsAtOgnr4Kp2+sva6Vfa6bvb6S9px/lQgJaltfHLNz2K0S2fyxhSWTrr+FJBGOypFaxwqWY+LVdbXevxql1z3VBV/L7LmltjAb5tT00rcP2SpWSfNC275BPLkfKJAxryidulbXZwPXymrvNToxYPi+h4v820hZWWLax02cJsc7huvKAdpWXtPtJEfPv514wKf/Xexef6h7gZcuqdC/6ujxHBA6tIySCXsbl7fi7jZuPvc+33E/m77J7ZETNfxOPJT/MIX3LxWahj83L4sOzKUAjaw6ky9rKfWrGY9eBDQSXaEDfE1YStdz/AQr1gNgIfH3NZB0N0ueV0abdIR350JIm8rT6NY3MuoOKO/OhIgiFUEkoNqb6q2uJeh/bIMh75k7C/mWxud4MdfApgHu5syigiW7sDycWU53hsT+zXMS0mAJ2Hs1jfr6Gq7XjgPM4/1o/zKc2ew+wQM+Un+P3T/vHgJ+EUPCqhyp+clX543m5/ZOxYtrI2Rw+jyYxKDMLDEzDYDCR4i4U5fSzDr5hUUF1OWm4zZs1BsFcx5H43q7JwhwujknI3hproniIq+lk9Fy8H2xjV3HCC0/uqFfCctgizE9bGSO+ItXGsPx2WlKpstMy2qvswvbnqVnXpSa98LKFlb+M3wuBR81qcbKh0y0For9n0NBh/ZD+7cPaspXuDWweIGDUNA6+JVzyyzkjc28A5E7WTrT4kaUHQ/JEIo84+RCR1fESPzlE7nvrYbtL8lM92pF7lDHojhN59cXXJhqwcC/KOUeqe1nSuk2xt13VO65kjRvzq5ivHlKybpxiuG3HCuP3n/pV/6R/6R/7LcMXeFB8fkILoFATRqWvJPtUfbmKr9unHLn/k2NYDMKsqSuUeWFq9rQNePM7yrWrwTNADAXu3wtG1Rznn14NjhsXz0ALRPIKQEP5PYYsL3c4clpP2fLN13FHHk1uqMS3VB3FdKfbr6mJvQxDRnZ+8zaR2bRm83cfoa2/Dvmf3Tvci62++bfeVF+4vMIy/7IdvB7+IBSUvw5/avLVftt4O3HUx/7JffLG6wGLyXK0vOV9fnqsVBpI8xnWkDJ93rFrZjND56xfE6QCx63Rujxj2MugY6JGyip9IUwiKRdDgTvmwgmOtkID4Q182jBq8BfZrVplhm4pLt+w8D2WBzGavfXQqNXiDmToyH3izdgUC2XoYBm0nZ1VaVY1WDTn0FZCavM3h/oSN02kFg626QgNGlVOdDKf0JdRKv0+rHT0d1HcLa5G8dAxsdLw/HBwLHv81nLWPN08Hv+7rDhSt8zvNzSsVpe/c8y9VBD/4OgxfbraSjlN5wUiIRyEa9zo1Rkpvs7W0uEcFUWmEhHGqB37WOdy8ApY/3LyE30f099HmJTI8cgcMnSnXh1SMc3E8a59uupjqWKOe9+X8TvLwmxHvG1FuPbI5NZxjTcPpwr/Tluf0zwKtYFtoBb+G3R0ugv6Zly2+8m8KDUCs/5sjGdz1udQjWkedX73NK1ufYMmXlk4hqsbJpSkWVGGqaBbHVV3N6oIrkWsXz+ljIHKZt2ivREhFDzfuaplqfVUTv8MmtefnXsWbUFNINKcZ8T4CtdOwafBTaCvBmy5T5KZbHOHKRoc5uihaWt2dStPe/k+P6px4aJG9Gpcpmlkt2g5/qpbohD8tdFGtZW3Z3fSPQ7tP2KXNbm9XKoCQ0DkGAXoaat+ef6pck9pGNn57vkNinP5ZiZFsOuy2dLIfOfP6dGjYVDTzf2GTCko+13bnO8buHHjn+Yee2mMrcQET9UOgbb5/BQkSdX7dvMKMvpZBhUr7iJXY1qqiJdq0RNU8b+4GDcM9BqUrWxUrv3z8y5xiWlH/ubfUJRVExZcai6QLHd1gqW9Oqzbdpa16NVZQ5T/Wr4PgbmS1+UtsBQM25dW47xrj/hMOOo68/xOOMg41/Orjrz7+2sZf2/hrh8OppaaooZL/E4hN3dhY94au3wMwbmQ7yQp863sIYFRaf1kuyrjsVfcR6C2Xk/IOdxLWuzJgXDJYcT1g5wH7nxjxKIENVxqVXARqDdXeDpjw5xZxb/SGhtXadeSEJ2X3hfbdPXp6+PL48St1P+fNJTXlHwNvvJ5PL0jefR29rmZH18uyqx7o5n2EyxWezHxZ38UnRfhK7hkO0Ze65/ErhNBuMazpe/wf58YKGibf2UiYuRQFq4BEwGLg8t/ogViZGHZbFQDaXrWYbLM61Va1u6zJSmvuhpxtGPPVcdlLZYrrXho4O8bb4NM4LmAit/AdbiulOvO9Ot9xkLHCLd8s8Occ8Y26ahzMTcm1glbVUz8j06aV9J+/Na1AaVtCq/3QVWAdWmn+9zWEqvXEN2X4ckI5z7KtbItY1im2vSSU39EH9tJx9Itp7kNZmo/ZxtOhdF2hQTvoQbK+5BhHq3/tw89BYRx2Fu7Dzu902uV4Ztc8WsLnCdR7aHc9cpXkPAjpo8TqpDMMep6isMx+omevRdU0JJ2WOrNVZ6t+FsYd1WJbna3itig9wAeqM/jLX+EZONdESvVHrSh0LWQsU21utYgCew54pUQxcM9fRzAp+H0HwCM1ISTmfBK7pvbeOsuGavHAAXDbFmvB6bTda2mqogPAF5Q3x4XtfxKHkSvyZYPi2G4iIlIZS7UIQuWqXkibeVinitMX3+08+sIzvvleXypST8d3m95+b2k9PCiWnU1foZ5wM5vmrZAy80BF8UELArVZaz4LGb6uLsKBof0t0Q8sE+PA0q/Y33Qiq/Fl5rUJmg61KF029odPX58/PXXi30lknC/E4i+BLh+5PXYA3Wz6ozDq4ouYL8U4+k0qUEZ0MCu5MMqePzoIe94Ysor5RcGW+54/wkNT+qgGmrZHYW8wkjHVoKbow+jjAcbYB6aBn/th82Hz61f8GYbNjvr5g/rZAEy8Ubs9qDTFDramrmPvynwZOIdmygjeWcZk3l9m1Nhb68t47C/XEdO28qfMx0sMM4tbvV7OX69jthX8YK+X66Re+Xw5SivxOjn+hvnyilyW9OFyJgtELvvCp8EJvghKIfj0EyD8E2COyDCmEe4AiI62AKEfAHBKn8TG9651dEOy8Fon5dev8Ee9d31Y0pAVpzXPXnM9FBTxMAw/Z/Go0XvU2+OjcRMSPZWAIpvpztp0j8Bti/xY/wYDbbwkK9/YvpaWieu+eEP6Bq81x+I3bA5yV4MvuUp4HYjyqrT6hWiMYwca4pGr+RANd+FGIE0286QMgYv8n5YVK8lMGJEuqe5Di/xsGfGOYLX9ci62P6V4khlErHwH4N7P3SMQhSQkbXEzHksxpx5gdsg/5vk/d6cwqybFBwF4jJ8t76MCff9ebAIEzDNY5d/DtqOlhw0cYHU5l5/4riuVyJ0+bXQhHxGgFd6qSlqeFz085XhjYE2K3QSdUn7uzgvS33nByCbqhkVA9v9FNs+LenwxRUOZ1jwFbkeY5osmf8XJRJlXOQCyPz5u+vlBEABy8HVyDJSDT/oKZJh3AqgQtF6qqYf4wVpWqIjeTV2Yg7Y6L4kD9+Zesw5/UWHhqvCMAPON7lbhtAhUlQaSSRIXtRV3ayre9rTUwDO4ZFr0vl9b/Upb37GxbU+uUciw9+5tmPzKWRoWGgILDczdMMC/R2Ef/jkOdwY4ZcIH8M8kDO7DP9NwG7OK8D7mwZgAVz0YMJKF/d37A96jcDdAuMNTENN9BI2LU5JE6KoOG8edBwM2F8Od3kMsM6JrAZMU0NNX2TBKyHk8Jer0O3s7gzXtMMLntgZmL0KoQGnpMCOomm4kntDEgZA54YfmP6IU1pxLcgF/QWuAv9Esp79v4O8/5in9m2D6fAx/CzKDv9mwhL9p9hn+jsiw+ZGuRu+4aOUPI709P3ydXZny/WfxatJ59jaNr7FvxrNJMOA0zdsKyLaAxcMMHZrJW1qdcCIn6KXE8jehJA4kL1zmNydRXnASnmePLwokcLWucTwg2soxYKEUxYCA/IhNMekXLIXLaz9ln2z0YA/fgy0g6FjcxRifp2euC4NSjUcDRDwNnheqF6Mw0acqMQtNDIvYHP+MZUxjmgkTZyzfjJOvhhPpmsP08rHUy0f7/cGIeRCOQetWOHQQBUaIaUizeCuQMZjy8vi2XxrOkJAv07I1/dD76O2pzP6jlpEbfETymOCdADbNBlTfhgoQCihtFoSNcLjRk+LCxH6vDvs9C/tsKfZ2LoydiRfgvhIGBpsmPEuyiPcPN9UbPS59NuYgeSZfvzIbRu6JX4X8lcpfmfwVyV8J/GrF9BVbwYVM0fVpIlsOMz/yE9TuYRpstpL/Djyq3BOhBMXmHPM1nu8tmTawZlFBNItSe9qA2tMbUP42hBNfq9VQHTGuzXG84N9YJ1ZpbPvwTJ11OfYUZ0MZ0Yt22I43H9zfAd03p+9SMqEfeEocyE75hCKnrRGwf8Xl1EDuBdUYvgVm8eb2/W+H1/E3xOv+nbHigAZmZ4jZPtOpRJ34AtJaOKJmpzCrY8JCMZ3St9WjW2iqFRo3RwSEll+GHbxCdBBSBpEPOGzRT/ReBJWwbR5g4GuZHQa/iU/Jw5RF2okqRPfRY/1RvtfsjVijByEOtWoBv3Dq4ePRmqIS37uXKUkEeGZUHcxQKc3bWbs5oc1jabN1TPn6tdwnVQwmAoP7Wvv379T6lLZ+32r7fl3L0yZwiPbSKiy4QAPp7VPIJfmgGzwqqFhgxuWetwdpPTMxYIlWat/bY5/SWS7GEy20fLcKin7B0C/azQI0f8EwQrlilmvzAAV4mzJ4in8yZJ4I/yS41pf7YTegdSP/wVdAuQk/GI2/fqUk8Sj5RDIbHj5OmBXJLMo3NI9xEGQmNDM+kC0F9Iu3xD7uYwdT8YXVsgbZN62KNRMI7aAnyD35GurqpZ8DIE3DHYNfqC/Qs/1UfAIZM5kFK5r4DTM5Eb+PYAEWBH5CCrp4XDoIjKvBT7FJ5J4isq+rMkBzwSZI+kc523wDd+xBgvqmn3352cfPXfm5S4F74psBy08KvC0/t/FzR37u4Od9+cmqUoWDHiutitOEhyrhPk0IHqgU+E0L3ddL0aQf+3o5VnCHbIukhyypH9w3KqOJO9ta2W1emHKCSMTKafFNI7m/KTJ2zIwdmfGjmUE/GG52VTKr/8CuTGbt3jezflRZQWAhF2jl+n2rue1AZe7sWA3e15B58NBq8uE2z5T02uVqQhyG77rIufLZvO7jJ2dvXr09f4q6qxAOOIORW3vAreUBKzqXv0AFPwAC3BeqB22ET2g2a0WSmuIi5b6ayiKJz+/ISBSTPDFBOUlwTlp17MqcOc8Rtis6zcWnmvxFJTVgUkBPLJgwkJUZBZhwcOZNFAIb1OAC+u7csyo/PAWRYqWBlJlbSceeP7aS3r/XOki/dUS4Zcvbkynvuo4lgdEOKvo2VmWDq1aalQXXCbOv+IY9H2xNs2ReEmYb5t5k0jzMv9FCzLvEotfnBWz2ojKiJmMDF2ozfgeq1jtlMf6f5abiYxUQGR04xE/l9IKpZLHwp6W52WedlG8d8GNaLCn10XIg3pQ/RsdjzBtopoH/KRl8J95sEVBOt/o+hWzLb/nk8hG5jEBz5F5h4kn1mxm+i0rCsAlqCbmMUzJqyrZZZmlkPuLNaq6G6qe3J5DyS3b10VWFZ3aAoBsn6k/7Zb2nDQa7jNPPURKPGqAsR1NSkrygfjaGUnpgPh7j2cRC9uMEiYsjhpAypmzoQyDgDrPpBX/2uHaYRFcwEfgQj9YHEpS4QGl5NlieZjaxK5FGHkjbj/EvWmsZc9FqWRXVLBphEz8OYvxgWehepJWqZmGp2Or4L3E5YUPMSCBeRtXI8EgbSlhjaKJKY/WCykp/PDIIQBTLaATBMwfnnFMXJHD2hh/4u4XyIXb9sV/qKu0pYC1Gvdx5/VR2adJhNoNkn09dBMffEkxrpJSBUV0PDJ+WzgahGX5H8nkepfMkyuPyxlONoQN3qbcS2A/X8pkgpoBGFDYdqJseTLamZFu9X/IlM2HoAoE1SPeLQYrGrQ+ws4P2PxD4p8vPlxbjnJohWRwKiSjvfNvZIe3VCw12vxwomrBgFextgMXAWUsYkG0qdd+WdWdm4uiJlS0kG5RZGSUz+kSVkMLvtGj176ZKOr/X0t9r6Z/L5IQ9HixSaH00GBZPiItXUVHKczIYnbP5dBrlN6/IZ5Kc5/F4THIBXJDkkroHiPHFBDo04oxP1R+b9ffQhe7J/BIWJgpjOdIpTPfD3iMk6Z5+GPhOHv69kzeM38s07LK3OJpP8fVvJDbnkQHSOktIN8nGrSbvVyPBjvHTBdmhdtNvyDQ2EII7mg2RIkG0oYFs9oNbawstoATjS1ellFW/GOg1RDPQSGq/cWrU8QEYe8aIRd881atptTh/68B0UmYfvZC5fcGuXh37sn/2yu51AAuO32y3WmSNGkilBsLOZYEeI1ROondhs63bCGqqhHY7GJrB7ES8BgpxBYW4e90XncjXqCGv1JDTg+k7dKLfWdJBD43cS8ouFjN2z4TLDxkBqWLdHzCrqzLgDZRcKDGaNZe/4rieCglXxvtKiRtNfLgyHOJIFy/a21NkEOPl8hgvl4vUHM0U+yW+J6VJ00EubsICfUTeh/zjoOhe70s8hecoxRldEHzIPpDYqmzAnGarrku/BYVqu22ncJdyKbpEhZcJiveNwNOEb2EQsDCoRr0jUE8SxxF5aHfYp/3sBJK6fqp3HDL8DN/uQhs5PwyNDID+xwEa9647Ufd6Ach0UkEKif5m9ic6wL6i0eg1uXo6nZU3nCVbnnbxVGMFgSXT996WLUusBtY6Ya0Sm4cl9xuXEGxRFd67anmKu9VJslgwTOlaZa7vqj7Oam/L7tGT5/fuGUK30+k0Hh8dvXz9vPH66S+NV09/foqvoZXeQB1vvC1b5R17QexeiP2PIQt62uxEe3Z9br8iR7Rc6iCTLsuHlTPTZmoEvyP38hThvDTfTDXrjdQShG+o2khHvNnko/TfceUhyvsFNZQshfGWV3GQUuvL8ipwUmXtsK4bvpsSnYA7FTuKHPTFo7l1EB00edZTJujU5KGAuO4PrNx2oDNKTdl6VLDKgwnwKvo6OKe4b3Om1WSFN838Knca+U7+tCAYh8K8zqjpSKB5FqOrPw0/IpClWwA/9TNvUQujbRWcs78B6/8B0wcbVYWQ7lQKWitT8YSC1rTYkW8DAPoTaQmtlXvDQdsCQZPWd8aIYDXroYJO6HR3QlE4I/+cA0wcJdoDZjAp3IiAVGxQOF9JRRudn8uEUyYU2do629ziaVJOQpHzN+ePX7GKi9ChThsCk089fbkJD0WqIfkr+kgoLlQz1cjUh0wlyNR8xJdWV+ALElmbILTxmlTrdA4agBgZNYIiLxuf47ycR0Ak+KnqW4dUBh1AYTcWlw/2Ivux6x5fujAxzZF5z9UONyJey3agC5cRHWNQSXnAgHdMTwbEAVf6rrCRdUDqOHxpSxOAg+ZKMizRtOa71Bin5Pp2Y/2t6Q6t1KiyJdVVuzc1qmxpqrKlU5W9FWfWkp2xLJ7Us778ecZdql1/G6QpW4B4rrCJt/hWY7hgdcJurOVSDkDKQPWepSHUyWCxdzPWP7fO8XFA2KJIxPLNglfcwhxS2bQBs8jaqnsgdHPmKjKqqWhE+USWnhMYJsuZsjJVjJaPWsutlp/I+lZL0Y5M3jPae0ncjUET61osRQsBVG1eXLxFnZIc/xr7pROVW9svnbVI++XfV1iwKafRyWPYGz/NC5IfUcqpUBI3j6/jgs15+eye+bZfQsYkHVkP/l1UXiOMPsfjCBCxSvOAiOpRvxG/Ey3NnJ+Gjrcay8oDgQwN9VKi8TBkxWBbUANjTAqOSxf6KWM3mkHCxTvU9MimEcEegoCsauC7xpQ46tkfPM3Dw6NwCpNTP/Ty9MAXS0HYi6khC0wtxqMSuZ+nswdDBJB6NEQMYyk4Gis7jq6ZKndC8jOCXVfV/r3sfqrmK78uZ2loz12OYy/JUXmBSWSoG99OOJVDARUn2oAqh1JEAzTfB2TENYa65tzvdQYr7HDCqqqe9akb9Nr0KP1KIx9soI/dx3OoaJKJe+qOJ+eqYYErAYGHWrig0o4QNKuG/FkzIjB/WE5OaBszNdNN/DQJsBLLTZ1IvCBeHuuWeTRkwaZYvC0ZAljWzl5l1rFzCSAWQgXFTyVuiuuCezVY1FCEiVIALIK+JsEqcfN16WZFgTIEH6OPFvFHvmHM2sUoBsb32H6Qt3tB73QHEkO9ATajmEitTCeWzOIocBAVSYGLYZOJjZAKQjDb9Yp0WrEEkjVLeb6k6qErtsRQRpQYmnEkhsYDCN9yNXLh9td4SO4WvXV1gsG55zNFnwOU5pxaNmZ3fMXKruoxMwgJK5B1wEqvBwxJC8NEUIdFBKHt4+3nE8fhpKWf0xNKdjWSOoygp8haWr3LQlcHOuRGu8UkSkcJ4YeXmv6ttA1DNqjkilqiNiZvy1bPyvQPMUavlWiELpGpaKqrsSch6fmXGChDg3E4YZhAoDVduzWbuqIKCjUuscvqBH4Mf+SjAtUh5PjZvOK7tFnYLx2qCL3VEdFtLA27SSQXHc2DgN4ycxvo3UWo1bZzqxJ9PONDF6tblgtouQPqyRjvw8Y2PuhvEuCJGjqtRZClQP5t8PuoXA6sHLGZrY6ZW5WUGFkFDtzg+vbvENT09O2sJZ8Lu5jHyehMTIyWZ2jcMEn+AdL4eZJdRMm51FwVh9tyq1rfl0P0h/j69RvMbb86iSsHajp9QSSO5tOZjozkbFM+uJ6aUYjZr80oDMqPXeazwdyDDNPPJvwfVZg5cAMTmoCSPgpflsxu7by8DN0ju/mwJ8OiD24hlXlYLYt9OmJnbaeHt6jad65U7iKgrg1qdt8HpbwR4sTUz26DVCf1dcNH5g1MR7O1lz4fKvJ7/q2a9vz16w+jW9Udpr57wNKFy1SnH8T6y85wlx3h3iw9wV3bc4h5BlVcSmi/Bjz2UcXXBHFzrEB6tufH+zWOKnSBoJfrlwF41ulyRo+S8xqMIugzuz1Wm+35xf7SwsWywgtLvaD+pOI1Dy01uhb+apo+QYFzRzK6SixepgXJmbpo++uESv4YqcFddSI+NndViyhvyTWZ8/YHplpIdv5QahMEM+R3n/E0SJwCVao1ebSiBqVSDarlX8mHHQsdjKXFM5xl3C3RooMMF/xsH5QZymogUSJMiSAlpvyTsjuXGOhoiWDLP0qbtDNd4FvNprjUeee66jdt3pWq2qHZlq34VL16i2rfKu0Xoh92Kl+YapAq7oQUX502gmV+jqJAJlUH0WjmHPbMcLWig79fcqm3IY/e7MU1M7aB9NqaN0jlsZF9psPBlvdx8Q2m+a0LGxPGs6epPjXvLEdSKke+kVpdp1XbWrHy38ccpaxq3vulkhwHRP1+1An2tKx9PSvYox7J3BTO1MQPHwcWi2R52fo7JY7etiKutZYqt0yCHpCk0/GUW2RvYK+tRKzYMQ4Kf/rQhqAoxx/V5YnFZZyODpOsIIV+/4U34qOzNjohr9SNG6i7r+sMplm8Ky5HbIYJtXi1R5KSzbX+U1iQosZ6VFfFIO/EB8GAVTMJ43Z+AJ/JhwkyQvkoDyd7cThB6V6EMa5f++z6MN4wpys2noqWYZigGLsWdMGvAXusHX62AzMLvvnFW2YDkrdvMciWP+nesNpu2i1e+KbDErzNVtnhLW2JzGuR4k+Y9UCMMk/fl3DlI0zZY9/0hrYxjmV+86VWsRTHiMMIw0ZG3pcR7DTRsX+h7RIcBWGfYL6s4dR3O6W3tk8hG++aSiOzUn+yCnAJayFSyX62xDGQdi+BVpZC1TYBhScyLEKqSJzQ0DA1dzq+4Xle1xV12HefxS4WNUIbRgsPdy+WH/U7D3FJah2p4sMvtNbX0ZSYySyAUTSdqWQk7klOhnGBzwrRUzB1zmpkhheke6QndE9Onx6+PHv55vWn129evTx+eS6PedlNOvUyAbU5sddIwr5IZf5FUNFRzDwHwt2ejFgsXhZQzyf0ej4+ocD/M5/FPHQcI7Oc6mHyLBqNsJeBaOwzQMXDKDlmkZpl+iTL4z+ytKzmOB6GsIz37OED9T2KgWrlCTsBJhIT/GTBiVVQe/PRBPZiwgPmu8LPalRV1fMalfeNjpmxFs5jdiU8mdYhQGQVgi9LZ2err8hLlnU91Cwz5VvNCtx4rlkx/rrtyjnhaldmynYVuNGumlnrtOuYdJWRrIJUiy4txM7sDHB1cGdMbHlJcDqbl+STE7sVvVpaVr0/Zba7hkRxIizFlPTtq4fpdZt81jCZVJ0xLJ2fcHKgVed8Rxxw9TGflIXr8IUuJytPSWh57CkJHXgVwi+iNMHnBBB4NdKGvF6LoW1RXiGzDcDoXSkm+hHWU55BrkH5yvLChBlfWyoeBGP1zIEAUe+sjI1nDZwLwBLyaItUpVmVxZrWQFXz2iJXc1q8uvnaw24rW0Pjuxx82+vyHTrEl/CKdw1Lph0QIKsQP2Fwq9EWasM608HUKCrOGkYu89kwC6xCmoGtxtnSbNYSQZbSUxFDVj4TRXahb9WBigq2Thf45KxO8FWvYEg3IT7dPetJkD/h1VX3zLucBv5Gz7OdtWofOvkmwVKMlXdlsJTKyiyioVQyMHxK0UDfSV8vFlQLBAAaWGA9B1wPAXvdCqgTlgP3qtBucAHvKlBTQhZxlqkrpEq5i9WW0wrWlKwvqpetK7yktFG8tvyyCswaaBUW69HYOBfk61f4o6LjHJe33worN0O52avsjpmggVaPy+4J/9198ub8/M2xeN0OpGYSaVvk/2xG/1KbUduZtOK7J/OZ854NvlLFBF2mAO26wKBOdHHCuJnDMrmpdeVTfFe7PunercXK7dS/YtMtZkJlNePpTI0SQLIJOYHWaYPPpcrTYiyZPSnGQdRTYnz+rbfU/0eX/48u/x9d/j+6/P+/dXmhyfypp3TO35zo2fwTIM6zWUeH0iBYrsgwXtER37wC8ZjOird2CFfGDCAtCUCfZGWZTTt2CRNYwmkQeu9UiqqR91GRk6qmx/jUz7H21M/0Dqc0n2NyNcvykj8eyS+N5vR4SQNDU/I7vFH0awaMpC7O5TzOJHslSul+FfWWc3tgPzzd78v/BGcO53mR5U8MldV8rLrH/ufp1wVfoGkQZeeUdN/rCd3Hb8/fmFj018ai0j5enWEqds/Cd4Wuq/fKuilyjei6lHOacV7RzS9clZgq/lE8fS7j0PA8R0VVDeP/LpXcZFvXQYrKlScpWgHjKEXjf1a7yfx27WYurd0qgLWzgOUlexP0YJd97EresuZX+RdQz8VMrtFtA125DSrabXBX9bYiFSpXt2wAdo2rUkxd6arImXL1XF2GoiGHnPdFRaa6MirBJVqmNLvFiPRrRqSvj0i/MiL9PzciS8bCHgUn/Z2UvwNjuLQxvTZTdzLaMS5iKqQ8h4D/E9qZkvJO6e7SzSw+XMbx1QuyFSY2rsnavO8HOgJWWYqMwt/GQ+XQwdYA5VhrS9wdtmImpZzNnxs7S6vAN9xYWkvynTfKjuG8qBnIC/cQ1mn7To66MIbye5gKLm4rLS1s3YicOwwG59/PYFAd2Ft1C3A8kXYpEcYDt0UtU9kWb7ZuhDH3I1ZZpyIrr2Sdi6yikvVEZOGz2q2qOPd8NwbqVoPVvrrXYDUhLsVU0AoLO8O0PMrkF0yXoSftL09f2RRTt8M5PMBcV2uBVBlUWKX+kWXT62qnMPkmpG/A5OVhNAM+I0ZwZQX6Jo+hM1FCtT39NkgNRORoTkAwzKu9qYMXg+Ieq7pSv9I+uwjhoBnv/BkS4p2KGaVgOAAPyNwQxKrc6zfBgbLZTMHW1RnwWAEsva7SP2dgyYlpYLF2oH2nweX7WkGM/ejq5x9gvyqffoDfeG45L7MperlTo8HL1y+enqqDTv4JYC/TCclj6A3sVhvTKE4pqanlwECBmg+meLI11U62fr7DyRZ7uYs9nKGnH0f57yBOoWOHUZJcwJZ2qWvotTTe9+yUl+o5TAl+I8EfimgjJTQVNlmzTS2Nvo4c/gxSSnzwl5mXnKGp8zM/eNh3n6EdQUunMmxG3SlaBOvQFY12vmudq+26j9V2607Vdut1dNrIKvNDXSik77jf/2aRhD7R4NpBr6e9A6oF3YaMzZK+Lsb2/BpL6i5+ejq/l2xaA7T8QXEVoye8i8mhv1dlK7i//WDHc8wCGudGvckd2LwIMgRfdTc4Eq19e46qVDU9/UV4BzcvLx3UlmaPyS8t3OdvuNcSi1L9BG8O6PPdHvWqRKDjXy0nGcEhQ8rbGZKM5V6eE5rKG4VhTUnFAOCoMscTRrqKwquRImyZwCLd0nhsp/K+lHixByPZ/kHyDHMPKjWi+NLmQF1zj8qOqmWvrDnKrb8V8L2sShthKRfqFYam2yPHN4h1Z8bXxqHxdfXUuI7InrlU8dtoS0mEY52Loa1FRBuvOm7Yq3uGjPkNGM3Ih1bLeu6SV71cWGyE8m5YdQZJdhqIVznpBW+8HvWotWShrrBwJ4y9vdYaS7vMbIcixPuaE2EVFxu+BW9Sqr2bL0+/KO066+e2Z3ghiOrENe8hExz8VqohhdT1VmJ1p0t3pN5g2VjhtUf2W2wBJRgOpJxnimRkiXxStd2K2zktb+om3Y0x6W6qk07pb3QZn8YpPVdhH9E1xifx7jIBYamoON1AGps2mKmCDqG6eHshdEtk6CLqwohmSLQYmIEbU1vLFVr2LdApQKMsz2sIJK9+9nuPVOqeBqA/0hs88NrNLr++8J0cXW7Rs+9hzPpTKvWtcf+uTjPlN3CaWX+RvjMl5E7JpoHMoL1XYHL81B6rvH2zf0Enn28jfr6Bd9BS955boPLNvH1WuOvcZt59V+8dJT2czOxqQxc4RjOakV8z5yvwf7W70DcMSFrFYkl80e9roJMb4j/lp8S24iKXfUH+IbAhyVd7GGloUAPdz+jf87Pm33Mc38H1PC4Toi5Of2NzT9D/N7tcY++qoZ5LHnGWZWuRJstkvfu39dzmD+8wCPTwc4JrxWiJPjHOYzuGbCVQ+eMkya5EOGe1a8LXIrQnanlidF1NpG9eV1KrlktX/HN0gnkOSKp2EeWK/XQXPaR6yj8Kgaq+RzYn/kEda2QchNswJo8bi6x5HHPW9GqZ9g7M+ofLe4gmYjzTX2lgBx4ihkZYFCcQJr6s9UG1Eh7YBVD+hlND4zm7Ii2L1qWDyup0ni2/ddhw18rC2d9uQswKsxk5V/SmJDe6GE9vkpf+FoGrRejNysxcx6hmlKmMkp7JxskAVyNltFwutAodAIKEVdGiBtwI6/vJYA9kYWr7QJlzDHt18UqUeEzau3eP/0RzRHkQkvpnrh1B7hvDKE0zqkCPcxLRh36h7QYIM4QmNSHxp5oeiHKPrEH9aVUVnXLtcyrdy6vdko1g0rMuI8PhhAx/P+JRx2m3FVh995f3VdawRp+XeCQca+NU7svHK29LMk6zqPIQAiQxmkXXq2gWp8toth8qsDqP/muNZgluahnBOCuJ4nUEi67Xi74Ba2TFVxTSmIcoZlb6Wb8tPAN4fe/N7myR+ktbdIVeB82/dJD4pR573y7y/qogKqiuuNx+MV06/FIgw9WXajnrjIFcclzLljI8KTDZjFKdynr9b1XTtd5TRqZE4bt4Tpnq3R07U6twr3xIYOFPXRq59gjVsXr7nH6q58+ji0LLxC+VR6eh/B3lpfrIZMZM3hXuASIvVj3h/il2nHhQakq/h6F0lfErRYhRorRKlDczfOIqDsPmHEiMDweNmo82gr3YcFa3yajqN1zUFaNqCJTq8RznuzlMW2IhB6WuxJBd8PhnzvMWClPpr9k/b6GEujrUV9DiMP9dtyBDGvVoFqXnoojeTs8bcGX9Hd20vE3jayygA8FmPSy70NtnwL/vacQ2Y1Hp0KcOIf8YmHQCKUEln2aDQk6sog2e9SKb54WVt9ekkfnHdNWel8TMH8TSUE+D8IfNXrMdI6qkHWPhAX9UGis4I8CFI7QdFqLGJIkLkSq2IXmYt4utgGz7ObuKgJVBvVgs7D3Cr1xDYU8kPIuvQR3chsYXi/P8BjZLBdHcM+zRefSuW3IoVhWMjBomKLhXBXh8USD52NDwlcPtjTYUTmgaiFo/xPxYLAYvyu7R+SguZkl0c8mOU5pHR1vHx1vv3zcmk73pdK8oupeXTYQ8P7MgR6OuAYM2mTKvFz5sm30EImIaJWcE5B9atMJmtwnC4hcuLKR9aRi75AazVNEnEzhNjWfRJvF4kqD96FeSZ45gAr+U3Rf5HzKeAFqs+AOWaUpy5qDJ60KPQfGbOleKNliL3MkxvWQveZe5/F7ST018noHYRF2Ilp7GjhxbzJpZIHQDdw7U2WWOhbHroS6auEiy4e9cExaMMf1/2XvX7rSVZVH0+/kVDnedDGQJAtj4Aci+Nn7Ec9qxg3Fsx9s7WwYBSgAxJeFHEs5vv1X9UrfUApyZufYZe9w11oxRP6qru6urq6qrq7mnpQqQbgqSYJxRhr+rmLmvTccZjS5nqZlrUpenPWVPlzOpMV0pHlvSFeL5v+FqPovWRrxT98bdSyZrx2+tA+EwPwV8zZIFfoXhq7uUEMTWjW9ZxpuzNYqKXkhf00NRD7V2XfTMIhMHSAj3cqlkWIrfA8nnaYFBI9NjWbTtMvEhYD+JbzVsxgHWLNjFqhWY8C/UJi9XY1o+KHjGarGElw4Dmgpl5FSXrQmP/IIlgNC5TOPx39gqYf2hDXXR24Mp4GQkDP7UAzleH/r9cikfGvVxgXz3hj4wm7FBm2eFeCLsaso4jgvlnZ1SnYbjJiUn/lO+XJILGZZjh+98xMJp2JVdhoXtv6vKxQoFowb5VSm/ksznOZakRKJyyKPEeu9oifpQ7suQ9WVoD3dKu0qGWa4p34VyPMQU1OpwNpPij9NEaf+zfHtcJBzlvJcHBmfU/R3cJqVBKuTHPMyzDw3UFEJUvOhUvujiVvo7DjMkhv+3jjMWHFZIzZDjimu0hV1LxxWXi3c4zf4meMVlVPwURPpQOCPiryeZi72xhw9NoSu8vVYqqannvR7wJbGfse0c4B+dt8722tL9YNVdL8sNi1usmW9UDBhkRXIQXZL2WHbboSQF8QHyexKu2IDGeSKteHD+4bz9/uTDscIujwNnMpBMNuoQ4MYCCPtCmr0pXrWbH9AMyEyRYi+DoiZDUIyapPSslf5tYVhYJ9ImJZKMxnXqmamY1z9F+dSw6GzrDEpsXU9WWuxuSItxlJl9Xhq1tKwhssjwyEUXhvfBUovVbZnSo3jq+Y9CqtSqZi28Ey9ALkEUc2dQAZsxHDRTHhBWPNYxlYUayS9hKzNBFK4QUOlAEnuJT97vng0jIdt9+YUxiaW+L2JUviw9LLGDnxcbgQsCnGS8BXwL3qtQ8WaLZ2ToPLhD4f6esKgQf+0wUUpMA+OMSxkfZc6ofWyXZwqn1ZbstKrjt8u0y5lu6jSOpZPWRCHRkODVdAlzTp0aIJZOoIhC8fhwBh/NHtww4sMnPTRxU9yHDGypJzJ1e0schUpm/LpwVHK+iEulVFICVCl7C6q8yjZnl14lYIwt33L4Ho0fVMCQtuWFAkZmVJZFsVGUZmyXgfeWRjUgqCa3VoGvxwAGCr5BvPUSzLx8TiQAcgf+ytiHsR73AcGgeNlsnZ+e8oL0C0pddgJ/OMTn6iKM7U+KNs8/tFt7zTYvzL+x+F9T1/3uyuXTeNsBSFiXKGFdShLWY1LC8qNlJCx8+hikN+pp8hgV3wuPKvlKyeGBJZWHyRDlPzGXMG3p2D1LTJ7ShBDouDR1k7gJJVf7lEgTlW75oeVD6A9BY7xJXSDjObepnNtLgOiy5+WZF6A0ImlfQCmTeQTKxWPJRxnXX3JGlAZaiwbPjNEQxVU0xHT9LX+9iwwRMF0i4bN3kRILNWQR/bpXYxZiyXzFszGNVIrkfgGlFAWmzvGTBehZfqpafJ6foum/gdbtIrRutWjdZqN1+3fQeonXXhIhaVnSewNSUYGEvHZf2fzrdOuBNbX6nHniB9OtVVa5lH59fiRr2OdHaZfBwwPVafDwQOM2GINhn6o2riK2eMNMdZBumApvX7hb7u2ffzrkexr5EDt8oPbN0/ctKO4fnp5f8yLkIyEFyAjZAUMkXLpb48S8pSSXkIEcK32jtvL989YB8+gM6fTRFDaFzBkf8JS2M15aJOD9bbZ2Vm6ExkwqkZlUG5GS+ATTZhLTLHjWmOHvLz0kjjLTqQHxGUBHGRAHRTkJVZ8IdAJRmPR4NJx4n+ZlRYI8GrfyaDhMJFTbkNMEYcQtpbthOyApPaKk9ChJSq7umAa4ivS6heBHOZDfwnDgeAGe03xz9TV1h7f8rFPYC4XtOocHe+pjVbQ0Hr3BMpDtrh6evcn3m9211bxXUEoY9Gnft5+Ko7DMDby5UilnhvKBoYuHMOZYur4jbJNrhnqpx4gfJydQS78FbCUF9vfAXSNPciLIkIML/vdGyfLJmehYBepLVX3xaKlhumYuzJGnPeXhD95toOsqYvvroHOjnOnOAT2IQVfWXwl6oAddWaegDwRoFZ52WBFeF+GxrRhN0N9Aa/M63+gjYHhcbAMFklV0m1A3jpbQNkby1WpysON2dTEhEuX8yURbDtqPpJfLCuU4GVgQuxEip1KOkcgQ1wuI8U8Cr2CRDq84N+biKfLqJaIuRv60MyAj0esoLtAk4wy0eF364bibSB7509A98J/GunQNGJJ+PXDdoS7jT/clDQtjiHzy3KeLZIRQ6Z06eTzSF/ky435ioHr6n7EoOGc6nn08hBfeuDMQD+kUyvoCVN4gPZhEeck3PVGOWFUzYJBgPiV9Hh0JycmoHQDZukHL7QVuOMDB8qdsYG+LHeLsyYisSUKtCbsziS9GEL2kZm7Fm/1l71l2kg/pG32x0zw+X4Dqn5QmSJ2en7ppoCz8O9ajPvSahqU+kTIPGjgqXfv2Dt0j2yKZ7ntXJ00UYLyxG1i+MdPRvloXUxdWZctDrQmJ8yoqC0jUPOOpC6um0D3jqQurimUo6sbJh494J2ERBGm9ChgsbU5dKbHodLukqVNYPS4k5HNkJMmpZE43p8bSMEYwBjnNzC4PASgyl57fpeqT4enCOOQ087w8BLkP8nQvBeEJJzKnm/Glqn9zX1IdiCfcWPxWaJ2dPxSf0MUHHSWKNIQs8QajiWORKHlZEjagd7UkWeKtP8YNdC/9sax/a6jBf3doweifCS2YfNRaNnodBE4fN6jDZCiWW3xTjs6+viiHFs6BBh1eCCcOyaTdwnDEbnnsC5qoBFqq0zPcnPcJ9Lmn0p/HfX8P/vfh8mpweNWHX0383Os3927hz/53dxyUMOH0fevo+n3roDP6NOgeDx8fvP0r57o83Dtq+d3LvZez5v5+97rTP/uKv/eez776zx/afhl+B2cHh09nF2tbHwakrffdw+GH1sfet+b+x/M/9h6bwaj0GTOaN/sn1zdne3tHz8fQdqfVP7waHn7Yx7z94+5+++oQEDm+aK68W3ke7H+E5NGnP1qHR1fuhyD6FBxNjw4OP77vbrv7J6O9k/0jf6//qVn68MfHq6ODp1Oo9bHfuvm+17v6vmKunLyUJh+fwpM/9gbNj2cf968uq53Kwc3jZrva+/6h+lcI5Y+eu0+lrxe3a1HUXvsaVdc/j15uTm4PDvyPN2O/e73/CQpdtv64+Tz44+GpeeM/blQnnwH4+vdvw95++LnVqxyePZ9P2187UNLrn0xLYenqpb/3OPbH159LHy7We/uVj98+ft94ef94gWU2Nz6tH5a/fobfD15n/fRkejb+cLD5+elgCICn65A+cuHX3vjbnxePU/i1GRydffi8//3zxrrbao+qTxvhx63OXufqs/v86SU6b07Ox4+bX6Hkx+7BAfxpvu//+fWsv1UaX0/cj8Ftv7u+t/b0/uv1xR97f31Y3//kn3bC/fLns26l+vng2/dvj08fTrsbe2cf12+OT6Y3h8M/v29c7vlrwe3kdBB+/vPl5Y/R07Ry3T71jqp9wLBf+eB/P7ktw8/9b06n9eTcfvvcv7oYBpunlcOuuzf4evo8+eupfR6UHvfen38+Xts8ujg5P18b9W5ujst/HV7vHT+eAa7t5kbrpfsNAP05OnvcfBhdDw/g43G7+lfkNNuD44lfbl+ER4+Tzaf989Lj+nj/r2v/9rFVejl3T4/ag/ej7vv1dqd//PFlywOAg2/jKk7b9cPl1+Ng0932D7Y31jYrp3/sl/1N7/vDRXT7fnLxtImFtqbrL4/fj749XrTP185upmcPz1t/tC68r1vhY3+vs/cEZQ6fmm6pt3Vz/Pz59mh/44+Pn7/jTAXvr7+Wj3vV68+nn9pfq5OX6vuHT/7NV/do/Xx6Nrgdf3z/53R4jbS8cbWx3ryIHnqTT88fp5vNm9KF63Vgr1vr/DmdVA8/j7CdP5/Ojj48bE3OomH1eO1scPLy/tv5zdrFxdXl2ejm+/nN5tFf4dNa9Xha/eB1D59urgOo9XU8xim/uTr6frrX+qPlHNyMmx+ra35pf3J5+r1z8/1jb+9PJIrh9iFUCv5svwTl8+tjZy08Gp8+XhyE4412f+uidBHsdy7PWpUPUS8kTOLy6tN5689q8/bkZMXOkdfNE6yHyKmwQYHs+wDcjT9uDjoqKq3+0EVfuHyuSe8TUYa20gFm7o9Y4OUcC3QTi9Xad21Jzgw28QP+pbirPMridD2junQFFK9syVooV4JD+ZbxXK06Wkaldme6yGfLwFdvB84rKbxuVLU6SotAPR9GHra9rhtGgf8i3GUV+VNpWK4dEGHtl4RZRTz9LQ2oYqIsvf4W8IogrIi2rwO/jJSsyL2/AH6BCK0Kxq+Dv1DATgrNrwO/SAAnZq6ioFaLuo8VAQZq5PSaLBB1cOhgFEnQz1pub4gliNsTYQd3pXsWPIEIrSm/JomFtKI8+oXDf0a9h56rxKZcqrsN2Q7AbHp11zQNvJ1IPfpI1p17X+yym5ZKtLc4G1AQtjV0qqJ+z8Vn9JVm/rfkA5J28Bd5qMIzhEMrMMCvwDyPh/6DM2xzzUSKT6eqLOg1HcelUzSZpj96gJm59qIBdYpPFrIi7oPtGrJoCX0quMQdbKdkKBE8iVWlmPSPYaE4dR6Y1Jmj5u7I9dEDSwEYO3aJAsZqcav69q3LL7OKgvzeLbvw2hI+hVIx+Vp1ol3PSsAzeXg8crubgzPkSJ+6jnHHk1/r2vYvdw0x5ndIdBjP/uG3Rf5ND2akny3QvlaghtLJjKPDXxVJB58gifSWK1nBqTuuJBWFkluGRMxNriWBRLYrMv6RkFFoluJDK/nDQgOX2JTSwL9oAwlAjEllQdL54v7IGmaN/X4m2xlRUMJQAWhI4v2y7TINbkfWgiuZ+SxRFHhyceL03Zt00i168ichVvDCHPr34+7BLDCc8GkzsF2f90hbIgLkAhs2OdQJ/4JuiBsWMTJlhl9Bg3LFMLNr3KZr3FpxLPS59vJ082a6+Z2dipVuNV3wFgrOs76nzh2UUPY6m3y6hhRjX2uoX8ToZgpxICk9TKMItAYy42mJ9o0SnCTzDGmePD5XqFZK5onQgG4hAqkyq6ejbE7OlIZnmiJ4zZBdHEUgl52gcjgcASkF3nNxBBTtTYYv+y+f8vsROZi5uW36ftDNY0W8nspEBiu0g+KNheeOt7gJhzuamWFPGbx9GzY0ueQ+YiGd3uK1xjqYbZGrg0nvX2iAsvcs4svEmimlA+PYt0VejXS27QOF5VMgLbZe8FYOM/4pMIu6kNIOf4KBkJ/xe0kljYORdc7JmPWMXu76Gx2Whjj1lkbcUXJ/b1EN7vsuVuqcGgtZgbaW8uKGjlLn1JXe3cjiV0q6rCPf2jrIqfc5/OIcQPhEB3eu4Istlh2KyedD4jWnKyQtPV12agXObWg8pyF5PeryxbJcRIiaygo9Wq9dttk0gJGjhn8b2gLuhq0g34Q537GBK7x9C78a9rD4bCT7q0SU9q3E9pWUu9mNFJ2ITtSmAZJZIQ8NFaBZ413FmtoDU3zXMzSUgTXVaSA06QB/l4zZbCYd4bJIURrBzJgvREnnqkvKanW+MDQyG+7nydZY5IR/r+z1bq4giCd1WVLSakB32AzmA0t9B/3KJN14vEjoqet5p50pd3F9USs6Fm8Kmcspo9/Yr8KvwwznatLL7AmkU9lS47vAsDLGmz99Ffsax+4HwmabqQ/MFPKWpM03JMxHJv/nEeBjvsD3eEUczNRAdGtLlRZT/ixF4Wudn+/qwmUUotW1adqCKsYi7xmYUw4pb3CXBzHkFl7X5/Ktps8/5uyjZSvNYaXnrNI+MEXV51wgoRnSf0i6zpJYd3VMQZIAfknonitzv17k3k3ZYMPoZegWO+zIOHGQU6T+uRrTrVpN8tvl9JlV2NYeU+/qG65JgI3aIiTYCfpiFETJfwRmttjIdZr5orSZDwsLxWbGybOl48JiGRcEq3FhgbBcnyO75BcrEYXFmgmVepaAZS4Hq28vdKZ4+1b4gw+NnTILVUECahRLZWto1MpZote0MFjtFxxrapK/2WKYuJPMlDthcNcI3jry0JXTUsm8goltf05JiWZ0xZKkU3+9QX1O43z6TMdasixQwyvGfka4CLl0wJxoyOOXRJPgtBS/gYmnGLZtP/ped6XElSHByU3pegBeey9Q6cVYZQIJKj8xH+Z8t6DWeqG1XnitF2GwZSqMv7NTshz4x5jR6DKvaH+8TPuesRokGw2x0TFpNDFMl9MRwHlZcrSG2diW0+gOlkCXRBJIjBgwjcxmKulm+ss04zzPnZg/3PzQond6Fk1L+dfmBTtKpsbyX9U7Z8nepaYdugQqO7nBzSddp2rz2WY14xnfZYekTIaHdkBVkNQNbpIho2rmTYGmW7yNUeUFX4zacvC8OaAC0ZMjb9yNY/DSHtB5S3ttIh2jivi8A9K9dxcUQIN8bkQ8tmHIVDm8jAIr0y7FFaDQDzwapplQse4XxjvlOm1rYI9NWM3lunc3QOjRrm8PamN7MHMwqJPlNDBiEgCkJDUkAAjs4X28rrruw7TfdwOeg2i+otWGuwst1qDl2dD2TdjidqAGidQEf2G8SPQt7865L75YIQnBRT/EmffAdsxyfdCwh/UBHnIj2JcGqQdgeH1MNCz6d4fAoZkEHsnktBfOQL9wI+be6o7xyIm3hW8uRtrz9QialtPvovuiCgcdWYD3n0oetYmpLxcr1bo4pJcdbLlqoSrvSJB7QeC85DUYkahU8ws4iwoMFxUYLCowBRrow39dDLeGg0ees6D3cL1x/z2sY7sTFS/h99Dd96ILN7jwnt0hxto98iJYnZdu1Bx6kzw29BVvaRDtKXZ5aALUpnZKmskpad4X6ZiC9JzbHcC3rc+vkbwcOcQMV3JmvqmG8ox9FOQ5Eleg7bOoKIITtM8vuE6+uDC92EjpoWm7hcqqpiZ9KchM5yReaqmnS6Czw9CZAOk37WYh4NwLfjHFjswYIa8DmLET+M3HuQW/W9pxblHXEmUoW/cgZvXxqVBebKfEDyfiIizc/Nu3b5I5ql/KGQbUc52QCHlkCgZQKH1TpYjRga2yWzXqPhSwz5grO/AHBPMZEoiXu1kp1Q9sEhBuaopShtUsHDQ+72LObt5BAAfWEP+cWCdxMavb+AwVu/Znw6jl5QxSpcSrHNifralS7YBUO8BqKvQDE8pK+bP+ThN+9+2mEQeea0qTAZNTP9BOxoFmMg4WT8ZB5mQcJCfjRDMZB/MnYwwF7BM29mXoKSbAJJD+st/Ar2gpPmXWqIEpUGZk4w/gV1gAxxf+NK2mKQqvhjjSZN54Ui3Om5Hta2J3zb+1nKyOPf2bENqA/RNMneKGpOMKzAlJZg3kOeC2na6TfPrKylz2u/m2aYtFD5gE3GRj5r2C+IBfXE7rgNoK1CrqmPaED8E8FMxUicRIoDj/ZEOjpAHZPSnBOpfv9ZOmkPpM2fIDY8YjY9T+ic7P6XFtHpYxkiB/6vh3YQIDWlg8XIXFxCqTx6KhXQwOqKhtA86/E79FWC2xIuMuwuJeCE+3+l/bJCqxc6afvr3dhr1/iUGa/F2qL9iCclJU30pR/ZfFZP/l1+j+lb1eukuv4HD/RHeX4HFU4vvH+u/JXS0sopV/ciC8ha3DQM0fpf+LWKM8rtN5YnphMc/472GeS8zHvG4tbKIwtcQQmQskp9/BVxfQzn+PIPEr6+/0d6+/1y0+Iiz3bKput8naxX8m+E+HbF5R8cgbDltuJ3JQa9eIscw31+ph9HT0+phXeOKOaUGtZWBvHHl7Q88Jl1T4k7pPc7Hu08zUfZqy7kN7QlWem9s8mgiylB59cvGBDErbdKAqaDxm5oIgo24Osdi8MgZT1BnEhYTwrpINztzARk/sRc2aPmS/q+BeTgfk1Bu7eb0Z5QJmlsQHifIH1okhfpvlCnwaM24MPfAv6RSJ2eeWMYtYgIkpP6AmUP/nz+AupCbQMTeBUouFY7sr3pj6yfi9lefIGoK+hU9ZTKlRlIKAatSeRzIBVH1QGArzZNcemgM0TwZ3XWxvvDuwu7Wh3Z1N7WGhbE2JUXTKjaJ9AoDA7hP0XgG74e8C3BrAn/Vt1Iv7OyExfRKgJJZRvzDdASbAj+PFpiYO4jng2Ay3toq1THw1d2TfFrXHScHdFNTpCdFoy1QrtXpWkyyxeqfRB3y7d23TvLfZlI2KN9aoeGtYPTu466Ap9smGChneb9zbDWqhGl+8RWyKz/Wuv0Jr7+CDg08MlGHRv40eJPZEYsc0608DD1gGIPT2LUl+bjQ5zWf0jNnoaWlgKwaQ9FJFnwyjLo5eD4q3hRPo7g668qsjcQAjcYAjoSafQDLWmDvonXtxM4rVHlldu1sMh17HzZestmG1d4AAXLGwwrxndSFVuHQ66Qmnsy3Y48ie1kcNu18fATfs3o0K0/tsjEb3Rj3ZGm2Lg+sCuC5QRBegxSWhYCbMLpBWdqZZvjeEqR1Ql3gAPcmbzwoshx/kxQNQWQ3xTYoBXeQh8MWYX5R3nJhhVBq+yjGmKY4h26pjIA22rGkuLutuoS+W9bHdN7t0WR+TJv3drn1c69vHs5HdL6Ahq0SsWIxnTGKeMUGsdpxXQK80nF2AXIMWZmjSKsPOTLnGhHINrNOx2rBAR7imrYN6R5p/3XFpcPcEUza8G0j03CnelK1O8fbs5ANdcSc2fu3dWC2bJltnNin0mZkl608Ne1I3lmvsZIdCA7Q5YMNqNShkSOSNGNZn0wQ8bio7Z3gmpOB4hntKq3BCVmkiyyR1dspWC5YkwRS2nFQXAHcDNlqz/nmnpAHPcciCzRAnnJpx4umC7o9hNBVoUxzDqbahKSI9pW1wvjHYoWdjQ8E0BnjpQ17BeA1kMMMUcsvrM3mmmPmckfcpubQjHyaFoKgmnjNir8gUtOl4mpnXHOwKJ7CYIY2BQMYNr0hfNWai2piKaiz1bixEMO7VIOWgi7+jJHhjXD7scSR66dPHu6dYTdsJw1IKOwY52MzqmeU3HD6dft23HWh+OuP+A3MPs/3s4QoNlLAGtlrcYRnAhhWp+ub2/bU8PPiDCtXZHuma+GyLHPmynWeBswxAREM6unklHZHjfHJnCmkkW3b57yIRxCyDINAzPp7+gZj+wWye+4jDu/vKqdRNGFs/FqMNpJlXOFO2M6eVOyHEUjfnEPEOq5/YFU99GE7+ZCfRr+QdeDS9gH2Q6YwPSXVP1g1tZzcmq6AWkxo3YQX18OfPmDuC1uYRdXNoxeOMv5N4cDdCZMRPUb68sba1btQHRQRCQg6jhGLDAinGX85upcalCk/zHN2qHKpV98bdO10to84UjoKtz6ZKSD4/LkCZLN5jaGGjBmmWcYjy7gLlm7YjCUZJeOI1KybqFDILGFa/wUfc4AxgAlAnIGVOYM2TlddR2OTUnKzqepDNbH2yEAHRzg7s8T86Or7dIZ1q21nQychABnv6F0WsnRLGOtC2+QbakUV3QmzswVsr5tEdK0WmVgdEFK56tI1G2S1svH3rFZWX+FKgJ8uA1dG+mXd2C5VaBVQs+lGtFarwYdBJfrLb4iXPESp8buK09wkYQHy0C0Pcowe7O11ynMu+DOtNyP0YmDpIW16rrWFjTO2gMC+OYqiebCtpkj1oRgiO2hSKkRcNXXTgoNAnKfzUkpb4VHDmyHUSa7xTlNd3J7XiO8V24I1G+PhGiZEP7Va3MOEnz12T/zQrBjV+R/ExhESIglnHHmIVun+0A2cc4mMxeRDkLQBP6OPi5F2lJn7x2RVDOLfjyhcbXTnyKSGWFjosxW0bs65p877MdJtBvkuZiLopEKHhzB97kR/cyDsMd3TyinRzwK0AHyhLPI8TWqF0+7WovpEDe0c4X6yArSMfvhvHPK6CjkwaJgzNs2JA+g2PeYwNTVYYR2SBTZJuE2neUlcWXtJzWF26Gs5U1qxmXTG6YqegtQ7rXZ9ZBhLvF/cJvbPRWCsXy6tbG+ulEjEzKU/DITWQl4m76hPHVld60tgqG6Be9HdsMlp0PkcZUlGfzjAy48XjMbIG+F9hHeOeq8/w7U7TfSqKR5zHRUo1Rm1usYCOVZpdTFOO3TGjkBdYVkFdorq+RsAaCE98V4EO8vUEs2fM+pzWZtTU1W+QpSHcRG9O8UWuxPKp0xuMyitZmc8SGm5RetUrObJh6rVracg8MbLoTSyHDY/fwkyFBV/NJ4PUoxcsf2kLJBG8glgPbRAUdvFBbByjb26+MJb86+KGWa42cyb8NYWOovh+p5ZQzCwa5RKXbctMbVG3gVDeBoSMG4uj+mcoQardTS/TmmD09UArjcaswNese99gxm1Jr0LRdwEPBN7sEKmPy3nMFTPtXsxlMHT2O9Geq5wkHSlP4nMREJH6UnymfN9KlhQRmuhNZk8Qg90nG4C3NClTwTrJxWE8WEeBMVFvXzJGfercSx8CRopN6oOksBFbBKcUITPdCG2lEKNu8BZn0wbJo56EniSUd1FQVrv2JrNrRHKaGij88NfkCPoFglGdclmvKL0vJ2VbssaNNLakOA9Ct9WpU5ztEXs0l4g0E3xx/WjoO2iEihe+QUyJjCe1YaGNrD4XGpNstSNLiSBFlqmRsLc6b10a7waNJ8or60bPNOtUfpQ3lXahKwYfZSv0hGRb30mSmbUNrqrg1lfhG9/yBPcjrm6vbVQpAMqFW/aJtC3W2xl76Ym6l5r51k51t1wDgQtf12C29iUrWyeJjRh7124cCBd8lJPbO8zAwbDUb81tbrAYEj2p1bBTs4LvTif0nwzlpiVp0y2dNq1TQ1qWb+bHoDMXQJBlH4VqrYrihYbKrEUU9sS21Z0JMYU/CZ9e6ETzf/eIs29CXu5oVQ5mfGUogW4kIAMbRWRDavA9sNtWmy95S54GPIdm+3m7wWxK9TkqzMkvqjBBeo7n7QkF5oBLlQzrTLtZmROzGm9YhUlBuNGWi1VVHvoldYOM7BmM4CT23gVsEsoFex45P0loFzR9NsEbAs/0FU7L5aELXcIFXf4GfPZA8NOnYKe0670LaqUZLru2vzdFVieOnPgN7VzOCpXNd2zf5f5wxjkrd+Q+wL9nToDvF00C8vsF/v1jOib/DjF92sf3HN0J/HveieDfD/4jPhvpdnL34sCKXeXDrVPqHWJBon9AEUJASzMuKjKkhDtUhO4ciY3cg6BAvgnDke84gLxAMt77U3yLWZb/pkwwaFTIUTg+UzPlligK3BtPIzdRqy/X6pNafb5VklpUgEzU6sq1uqRW12AbosTRWLPDoRdyKO9AyJMhjWRIIxnSZDEkFVS4Y3MlKjDtoZlbyZl44aZRLO9CQj4gF0wgtQZr3Jya8Nfsk3+7Jj5mNKr5jeVKTqDkRmlRUSi0tlGaUwwKSAiny7zPSRcNkG5a7tDBqPVM2ojlElDNfSSjBYJ/qYSCv6cI/jCIdRyuhOQ/lIbWESK/mjrjDCIgwv6B9NSALPK/yYzJoJ5RxG9rnPrKw5FkPdrk3v/Pn2HxppEdAwrzbxvZkcdIfRYXSb6a/zT/QIaA1VQbLIpYxjqYfWGKajFLxisK0c6CdwDxn799DUzoGOiIM9XqGFON79Y00zFrmryU0reT+T1v3G0O/RBEZqrpjIvP1psy8CERmG8A5ey+NbzLdJFIjQtWoRoOCYF5l2z1BdVQ8hLlPblXumxZvDtqWHmnUfr509+JYwBgudtCiJ4l5PBKl2Pl02TfdSOXvGopIkjaCJmH4JpbVI5BgK3cQCs3RmOJmvQUbWpQCckhpnc67UO8s8lC9agwPGcEYAIqlPRpwduFBbt2dgnmoHgILHwSJnzTADgVRqZW3+qibw31YlMLy1BRWOWF6b5jTeq4tLNPTvNu9rFq9soHuWx3BMutho9NIRPIZC3oy/4rR3/QwAQbmDCbRodNizla1XScxjk5JcsTpT+ibrXZBJmT1fk1VAdBYfRLjqxAoLhZ2lxdNOui7eVLI+yFmFrLd4oTzHK9+p0tWx2rzbXtXC6+gipXQV2N3Fr9AAOBPnamnSR/Kpeb//Ufwf/6L10QIwSBO/Zl5IwmXEEZYM3nOgeXlJdP0kfUsCPTNmZaRMkjB/xIUOz0tv0AKoaSddE6bJ5cnpx/+PLh/PTk7KQtChuADcHrRRLNzGR3p2Mvig2WJ/YiVLpu2Am8CXI1q2XTc5eh3y+XmO0ofwJbqdwyPSlr6VtmztRR6ggtjQbT7dYNq8nP0IT/t0Jfym1DOSfp9n0AcPg51N8BVB+BopSPNE4NmqrM8xtotZA/2NkpG+iClnIDz6iNa0dfU7hdZw6dPplx+46Z2X/C1ViLc0vhtd1XDkKh+evDkFF3yYF4/TgUmq8YCeoXRJ8JSfqPqCEFSQkRZpGb3etuQkyVj8Pa4lemodCa6zsyX9YVsTjnADNQ/F1UPX1CJxDAI8i5KKI2BHJ1oVx3l733gP6tg0b26NLoF9rxxwAXXBH6MSQuGsOUsSHNwrnWMLXfkCgO9WzoaJgIsg0TrcPTvfbJp8NduTrXDYG79O0MuM/8zMXU1awBZuXa4spWfwek/wJqpSD39xt+8dlkH1N+hjnfS7yPgVhB6MObMDpfkgwMXjgGqw7ZwbMwjYAEioE7GTodN5/7j/8Y56z/wu25bXNjMPFlKXqoLZz38rl/5QwiXSdSz/Zafx622idnh7yAvOv98qzdFEO3Q4SCiTMW54MLR33IgtilzGuLKupIsd6xO/EQKT21Toi+IQ/Ep73Tq0M6BMudbyV1T+mIy1BbpqDN/IkaE8SEObFyOel0tGUnIaZ00r71poT+yS0Wa7AliRQlo5YrFHL15Vs/Sw3D1YeT9mtGIWsIdlUkCNjMEagtXTjZHIpMRpLSTw+PDz8c/AO9YICX7cfc4skmqZSthkmWSP0CXx1Dvp8M357PZBGpKvmOQb39dUcjGUBiIbNnPyWEzFRhVUBMZSfFzaY4dPldILWOtFlVmcw1KuR7RGaaFPJN8qOHnLdJVDc3U/xKY4o+KXNg0WtIdc2DQgm2ThwJWDyPT/SSI0miAT0ObN6IOX/I5NutChh6dRzgmBROYSk4LAol1mPXPolTSeJ8bB4VzclTz3sOrImRVZq+PE+NzIljwnnzEotaOB8jMT+vATEx2ZyONPIfVfT11Z0gACUbJCZ20WjR1r9TqfJt+I5fpyssgi3QE7cmR+Yv1BFJCysb92y1XfjDl74/zs+rQJca3XUXdb+x+d/ZfUYYhX+m+/A/5jRJVBlDHE6whyGlq2sSqUgPPNJNC12Hf/zDGhHfOX3YOf1GBiJ1X5aE4uw7X9YfpEiwShHcuJ3iy2XHGbrErN0I+AGACL5J8a+sOkLtdFJcf9gol6iKQo6MqO6T3OIcwlwthzKjIVmwU3sg9jTRgJlqAFSZQbxTzSvYjWM1OdLF+ws1StMjDH0qj7D3/fPWwWGr1o1P6GU2rq9H+LlUMTHjiwHwQ+CbGhUOXnMhp5t1waW49xD6w2nk3vB1zQE+GSKuy4xqUtKY8RgD6RH7lMjB2Des16PYXTrR21Ql6ngn1Us54i4AwAfrVlu7oB+DWzEGwZ1C8PcsQmsqmRzvxOMkxmeCa+d98F0WEpRZjUWF86Nat2BPTScVASKTJCQBAWubdmZdLg5gC+8qWiw/BVECSz6YtJm9/fNPh7VRwcaFpMaWyJgEWm//8PT8ujZC5LS1OGoIWaCmEwwdIQN2iVSA/0zJoRJhDqnVvSM8gpJwUEDQwWDOAglXUWWU2gmJby8l8U0SdwpK1kRyNlUiJO2l5bxk7YpSu5IYs0nq/sJEcWyNV22HBfzomnP4IT1WGS0uwtjwzg60mB9I/lN4UV2WMnHkE6zcUeyVIDtSH7loABsviQtMfEkPYR8OxDvNAbGeuQF5lHmFTMTK/5MzfUVLs1bG/ko47QxWblcc2NbxIecZauTsxjlZqprHGeKAruTOdjKcSEMYNQvcl7hEXmRIlGOxcxMPTQ99/xvgh9ftV3Kmm9ynU1DIDq1AgAJQ0zdzK3c5My6PWzaOBrnAbuaKRW2mmtQBRheRm/Jm7j4HuwH3KySum3XupSRVCu8tR/4ekzFyd3wK3pdAinDFhSIJcus2nBhBnjk2WeaO7adzqed7w2YVHQ10cutzbNuh8UO447HZ2d4m97QL+DSegIjtUdkkNMd4p3sgd2cIUmEDhAXS3EBqbhfawGsaoT00avB7SH5jGAJKUmjxCvEAjRDVyZiR2Fzqipt175l/nxJbuWEH6SEpyR4telgUbfoCLgcRJqakLMWQDonbB7vUXydyq18YN+JBizEZ41CMa37dYUGdrTgPDwx3fdupjW1nNqP2ben6sNuo4l06+FftSjDn1bXQzjw8r2fcfLbdzNuz/OFZXVO27tJtK84rXo58H0qM+2d+17UfACaA/Dh1hl70wsayKtZyD0ezkX5Utd6TxW3qJNJLXHM+wIMEVfTNbeWsRBXhGCqip7KrZGMSVHZsHxizTI8BxeKUeccB5LPdUk33QN3+a8BQiS2GpIuixeIl66Nlp9rnTwRB6T3cDRxsRyhgtBEnkUEg8Rd+NMC0/SPxgrOzq0b2be6sum1Rty55gEr3WVKGcMXwgtbj+tKzl+1PYvu1zH5BpjX3FbD4sTCiGS5H9T+cOTdRXh3hK/aksu3evCBe2fGTNYHCSCxlR77c4li3RTly//wn9qws+CSmMvDIuQUI1+YPaMYrveOPJqCCkLdO9kB2idwJ+kdmc7IMyjudR7Wt+XVbMdUuN9l0Um+LUsiBTMLmPbVKMXVrvazsxMjMDRaw26zNYenLwyJSOALTvZojTCToYDvPcfRN9kZm8BHXvGZNmUQv9QpPwJx1mad+hu8oHjkT87X8fOoiPu3XSvXUM2iuKJbXcuQ5z6S2MnOY7t3L9l8zm9nMudCcw7lNuzejgzp0wqjtT6iC+Wae864ovu9HkT/KrrGfmDfNw+RKq9mNWto25zSZeHBeeW86RgNUpsDNq4/VW8onmkyzPVu4Vv2aaW5n5vxyPBrr9U/KZTtJiqEj2mtbNgnk5ZwLd5wcVpGOA+tESjIZTT1oY57zjwD6P2uQjdTzHf+zurfc7idEOjkc18Ltj+18yfBLWfX4O+HyaYT1WmGSxRNgUTP/yb39VVv3sDYguL2mEo3jwDeFZTd2vBOAtWb/s+k288XaV7xPvYQ7e37B48LcuYxslHHgxd/1PvfrxwxGZvKPP+g9b1469qj4bLXtCQYktX8jAWnXsqpa9TSqVS/zAk4vVqoS0ZR7moDLnEskC8Z6W32aypxot0M8YFGkdVSbtDHG5ELZDd9LEFMNsVizi5sTxD0fJ/7o0IFdzuhawT7AyD76BfqiW6B/IxTcu4OlBwmbtzOwgl0HtFJi38ytrq5ggRV8HLOAr2OuhPwRrZ4SSUDyS0zZ4HtWGxm+1crM75D8M/RL/WwvID9qeD9Br9cWcX2FamUMQfoZEvAflnDG461KgR9OzCIoyB/lpBZxUPvYKBnxkQQ7jUgiusIsm854xRs/OkOvu0Lc2lbyOfOjmTNyBNTx3wV1DKDeMFg7CwfjN7TFGvv4Tzf2kTSGrZFbwlFMDln29Z51jFGUo6WKfsSgV1fUrfnYtj8aV3YXFhK9LrJCZuaj8eMqk77uPvIjkygyu5Hgsdf2sVmuXzc+1q+Bp16Z2QCuGQByBOdG8jXkq3dPZJDdqNGMfv5sRg3J/fEakL5uLBh90nrfRNFME19dI6NNrXmIpg1Wup6QS0pWd4k+x36y1/Ly4hduoOPGO/HRjAyjULaCKA2XBNnFj+t765TIEvFmh+epvagBjCo5Nj18rxHy7XQeCaZ8ihl9N9qf9npuMKHPrRsWH86sUNXaUZWauOtFbCSTiZOoScbvVIxgRokZPQ9VzgDR5WjFCdwVfxp6XZccgyIHzlEPrbRSoDNaqVxcFFhZXc1lGZ74E8hWc441NyKPZma8mpl+NjNSYgs1ZfNr00oVTQQXSiJ4E2AewnCfI5gmAFEuljAgDZd4e0yo6gmJtpeSYJPwivF+n84SxgU05BARkkzbG7vLZSjdk+ZCvooBshxmikqYA9kV9UgNX65MIn14Op5I/vy7CumNYt7QGR11teyu35liM8VO4DqRezh0aaMdB5h4qG+KOgXYbMS1JailEopQqUY3kHa3TqmKzLfa/11k/DX4BzecvyJdnyzevGhjG109kwqfIAco1xa/OKm0BKnEpbj9UihgPVnhyjavxRMuXk35nW3LgRTl8MrxKyiSYXfgS8YGKg7BrvSLq+Dd3LVV1+xlaSzJHsbXtZSNu4hyTMp3hkQZPJU51ec4z3UaBiyI0HYrthb9iqZFTw2yNWSPx7yZTiAQR4HuxRfHg2juiLroRBNTBX7kTwvQAZEzhxJIGFXghF4IjBrYaTdjXo00YSw14VzNu7JckIXkE0Jd6Tqd+3WkknnkC/Oi1ch7XAOftw5g5Z0urJ5YWJa8bkFCAB79bH2N7NPis26HIUrSe7ypTe4vj9zirZxSxDCL8fvRHu6Fnn4v9CJK66qi7UXKG0RZm7TQsjw5UiPuc5LCLIF8xE26pUxGx00XkxR0wGyaLiAwQG39alE7QBnzizjPUKRwRWRdivlVoVjFalfoqSNExu+RjeXqVwX7e7R6DQVM8mPGa7EN/sWWyastyEtowHkEQ8Wbl8iew7CsL55kEv2O8/hdnUfSmaSc+R0n9Ytn2pkl775HXCJGyP9yZS3gi/fuhd6I+per0QNeh0aWLtADppUU/lMYpsV/fSdgycBqMZSp0on3/3LT4v2xhjpi+R6asC5dVcI/cPEg320cpyX8Axe6DPn2sV7CB1DHvyDis8GSgN4duGx4kolcpr902ajMZurjOio7UGzrhBv8YOsyW7h+QQgveobykhKuXyLVV8KLkna9l0g27OVp21z+7rhWqnC8ejE8pCxqQ+myWVm9NgRfoGYmnFXcl+mWeoVb6pXdYfusYBBSWWAKtKxLdmoo0mGbrRLOk0EqIYyywfkISZOZiOCJr+URSw950or62lFPjzGXdBaz/xeV/Sc49kuCYxOOA4xtHt/7lyvxvWPs+3GC4bxoGM4xDsS/XNPOLHl3rPC974r141/uuy809N13nf3jdWi8hu+lMEzzPX0nUnzvWM/3vqfNGnVFl/8gJjV/u3dzcmmffHh/2DppG9YKiexCJhm9mbvuOPSilxUvXPk/ORM4fG4She/Ihf4V1PzQrZhxz+9ul7pGD91HyM2ZxxHd8y5dzQQJjgudsw4SHPdPJIc/3calmxrsP5HjQr6dziMcF0BBzq9yXAno3Z+c4yYTOcc9kDiuntlqIyh4UXYIBWRFyh0oYHbamAE9HjMgC0oc0yCzyN8Jp0CCy6LjWLToLmRKgAPQN5LSyT5TUvUspbmm3Sh0rScroMPDUsquldRnUw8MECLRaxuyBiyFQk9bwkI3ItPJXJuoCsN2C24w4nsGjEHCrKZaIn7+xAHwQphq2K5n9BxpjhJvlq2TBfktO9M0AbITeWDzLLsIKSBFBzzToUzG9WTk9F2t6aRlnVmV9LhpnWheOfvQP3n+5dSUdljWxuDSg88kJG3e32pK35M52iXhwJ9/23k3rHnr+B8/vsZWPs6JlqizDjN++BkUaazejX6t/jGtn/H+cFyvMw1CP9gXd9C/5j8WbwrytHQjSIBEszLXZFIoGwvmnzUlqIA0lLLRSKmvprBkC4i6mW5CTta3IV9TZmdumQ74TAZd3gFfH8Po0sP52feiC8Ad5RIMI37kRRIP5xGk5vo1kUsjv+zlX8r08k/e1p6PhKSXSAjpw9EqPlmis8AcgbXKd8Nhp5796b4c+E9jGsqaRGHo4J0SO7eHd81P3V6U4yGui5XVxU41cgJM+ZeR1lm94CXd1Qu8SwE5OMgbsxQyLSSsfwIbM4WNmcJGReVqkmNUSuL4Xg9cIFCZq6Vi7uL1pAzXaBIHokwChMht4LT87lYK0MxMAiYFMCdqwcR/ypeLFVBX35UrJXwMJ8NZa9Uj1xF3MrLfvg12yu7az58Lp+idt1OprsbPG/BAwto7HyZeR7rJdjQy3mXgU1hUL2DXphagO5egUuhm3Fwxx++8bC+4IEF48WwdPrJLfHzKSMHLTlA5HI5g+gLvuTiaDiNvMnzZf/mU349IAPab2ybogF1YTBNY/zcW/XtrYBShC6oFwTx7IGxjoPnbegbBYYA9qNt1h5Fzu1PaLZSrpRr8h4mTwEXcmJUIkJ7Vb4tf2D1gfuEamFD/M3TxkKox9psyFOrQY8Ym2WeorvfoBCteYHeGThiS66pRMO3AZpQ3fhDU/GnkBi2n601DflGOhOdXk8jmTO6pKCmH4y7/fukAym7AP5/VT7po2v5ETaC+8TyNmp+4KGDHMa/Jo2ZxEfb8kXJ1mxEAzP9iILzUHDjO8zJwWKnF+OC7A0oVkfDIvmYz6yais7RCbW7hypEyX+y6ZTidkJ3J4+wYD/pYK2wccRnFv51nDL1Bv5g+DmuMRqK1t9ILh75Y7Cqe7xN0kRdXIGQHeftLcX8Iu6WVdV/iC4a36hNLEL2fADVwHe0F/Yd8pVq1Kusl/p+hr1JJVYH+sP8ynP/tKkuXCMYNZLRgjGBodDni/rtdqcaDeDlxYZUVyzJcMcgd3rPjwOWejjQRcW+5XZaEVzsTSJwhEmoqzii9lWZzgefLBPaTxC0UFEMunIBGSaaPXnn8wkIXtNWh80IutN5Q5ZV9Fg9OLi9O9263SxocAMQp3QxJJn3JEgoAv3+i5/z8KZZ35aqVN+wdykSwduh9d5sDVNLzScDGzNDg5SqD8oqmq5bkyxC42HBrCmt0SgRj9iXsKu3z/fP2e3YfmfsSWEmoxHOA3Ulu0mt56vgCx07VScui9UAyFPQxggr0wPihyOiQNAtZVkRDCbE3ApDO3r59c1SkQ9ccuJ1vB/y8UB80AehkpUMDJzy4K33iwBFAQ854BYCh452ArARQQH/FmFlEVpKXNESmuC0jMRqRmZTrSJdhB0922XmmXcbNnXa5YUstvK7L0K+4y0NYqKy/MBRxf71xVn9hWaX7uyNNQGZ/iU9Aqr+CRSZ7HfNO3bWjyeuvHSV5MnVMbjoT7oIsZcEOQjJSlSScSVt6rEkWmTO5aMSEBmUHiOZsFepAJXaCVMuJfNp8slKMQ3JjiTI3oXloVBagUdGhUclEo7I0Gurk6qdBZEtTEVfhS6mUsVJEyZXRNCSrxVmh9upHd4XsYGJVJPfPeZOa3IyUbikbbrJTSibpklpcDKq6bUc6LqPs3xoeK+VyditXEE0lBAFdW1HWJEXK9ET/xMTE0gjdEYGDxlujtVXCx+OWmBYuwWg4M0nn7JkWEjw6qwOk2GLkhdwUxbShpYmYFhI0oJ2PjpZ9dGKm0Umwio7CINKwKlpYlRhWJQGrooWFkkwSEqZxgmXikIZYWQ4pGIt/yYJxDsFMKiiwk2THaAmykOSxZGNSFmlNLiqak+W5jPbm8cGk3MjBChCzztB16IlF9/zhK6hjYV4w3rSuEdfTy3DifSm3YAfCyB8Ig7iHyW2RzOPO0bA8bqFa0DJLa2x7mXm+7b6rYAwei13FZG+3JhTKbkJ9RKWYvOlJ0o/cPOllLsfDiEspStzatGLAVEwdX6VxqqUcOV61pkIsnrMMI6WxcCFHg4dQhrV8V8aFCm8JTJL8O0ZlpLhpJ1vlGvfiVomIvHyrKA12Us+BLOp9SuuiT162lwfEOpQBaFH72caKOW1pK03sDleE2uqDnfzT0Kh9LJZellJaw1hcE4y/Bf86dmg5O2P9yiLPU7G8lKDs7ITaHFIpzKg0pFvsxQm+7c1/Z45NbNJyFpQRVq6pxF3Gli+xIOARpvOuUpiYei4ysp1VfIivkBAK6NsTnJv4BRrkkP4R/+Cr73KUwW4q7uAvrOKkacwv5B1zZHaUd0mn+u6Q5xNYdFdyzjUhf5YlXjnE4rJVknEaF1F8qnvZPZkWHDPvFEaFttJ32ierLfVz2YVWfA2mv9hBVo3+ORo6/dCuGHLASv0KLW+xJcoer0ruRU9L87FHiYnFT//C6oRloFufy3GCL7+LFZQkFjC1Hf30A6OYvzJ/I/NILnI9RuZEfuPYqqySwiKYfznFDsr/Pzv4JXaA3Uus+Dnda7+qe7+bGSyxriubpRrbbt9V6ILCu+uweNhnKK6y/w5ydtgKW1uNt1x5d/QWriz9nsfonf5ZROjl30LoczYGMz8ia4AbrispSu+oC/P/aoLX9GUuxUs9+5+2C65tlGoYIJ8tmOJWVSwa8vsfXDirxU1lpWTvTEP24iEsrnVYatXV+Ou/YWnRU/Ze/OjtiOLT8cP80MCHElkC5pEfoTfGHLMSp6OYZaxKue/WmKnpVVtTj9JuszDRLMl/9+ZT/oW12OM7T6Ij/63bTHlGQ5DLViQNDNnhIJvoZR+EUWYpyS1hOL8QeioMMotw54VpZgnuz+Bbc+XZeKr68wsyjbqbVSoRZDn7lH5u9OIsZz7xIOFvDbcrx3yeZ3/T1BR++sSCR++qswjlldVAphnOxVbzgZjZQiBRgvEuX+GFmAdT0u0BV4djZwPw67I5UbyGXlmFpVc2RGC1xGuOtk9ebWSPZMsQzcGqI4G8G5rmvc3etQk4aZmabiJznBpWwAm0oCmDjHBqGLMYGcBjBzEqFP4OMtIKzEQmVYYjE0dUfU1Ay8SBXoY3iJE60vzHzleHwOC++t7YZszuD/hdbCEqPMim+sSQEl6TDK+ROml+I5ti6QSNbfW4hLtixi5zI/bMaF1shRKQQrIJozHezTjDJhVqGaf9JDNV07THqQoFezxTgtWLHFzK4Y7kIfAjVM7WQ+kwnXkJ5kO5l8m+E+uur5Jw5tJdHYPYk8kx/F9hFAM7VW8IEpjCFobIFsirqnwV4ss5o4Y9rI84S5jYEtKj1UF9etd/DR+YLMEHJhIfGGHjyAdGnA+8AgPt4p8ssfgn7B3DbszS2eGbLR+fGfS840OklJFu3I3k4uWiM5wMHHytVU4cTF3xCitLCh2QPchmhRZ1OWc4BULCU8oXHo2PocJg99REhN1UkyTYB2qOBPtEvvk4MvNPKLCO8bmgt+i51ooXcK8wMRp2ubK527InJvlcRff/Wh6/K9UNkoY/aLrV2oHfsIJaBRsT6eo5sztmvlnosDKf7baZPyi06WddjDL++ZJ/U7JOyMWfzwaGxZT5V9eaJq4S6O6BEdf3BMvjzFJlesl3YZa2AsY/2bMxQUKy4gnqzS9Vh1+29exDmWQCQ2ZpXWNJXeAVI5V97vNaXJNqxZLivvFPXdvIuEsRcKn1wg+ji8DvQDHizfVj7pbKfPzFGfOsnu9Nxx1yDRC0UOpiGwkn22GkeNmy9/2oly1+uADhWbYBHI6no5PIBQZVZ+66AlY/+jGTzrLI4ovyOZGQs3Lbpf943i/lyOOWwqKeKAgpUBL+TRatbCaLQgoUhX+TRdc2kkUhBYrCv6yo0inbnRn5m+jnT/jH/jED5oJ+4y+gCj4HNl63cu1CxTqI7MKadQv/rlsfIaVqBZC7YfU8u7Bp/WUXtqwmJGxbLaxUsi7xD4hxkF2G2vi1ZoX4Z906wT9V69S1K+X1zfWttY31TStysbFr196uVNbWNiultY2t6vrm5oa7ZrWhWRYj4Gzv5gt5O9n60869OfkAv08O3uQs19MU8Tw7lTYO7D+tQw+6d+ThQ1qeXbGcwD7yfk4861tgl9116zSwK/Bnz7PXSmQ0/MDOhTnrA/yJctYF/JnmrEf485izzuDPU846hD/POesI/rzkrCH8+Z4jdT8BTArlEzY4ANjk6xY95M8h0/oOSdZxYK9Z+4G9bl0FdtWaBvaG9SWwN633gb1lXQf2NqnVxfQbqLBl9RHAVwQwce0fR4zQa/3AunTHoR/UvgYzy3E1/v+RnctxxTLs2xF6oLsJD3Ti7aPUKhaLEV8e5DdVJVwseBay19vHwEAs8cvO3fpQl8ACCmR3FECU6nzDi1ZuzhvTht6+JX+KqRL02P0Gl6J162XfZXiY9gjRX4Gau1ah0hk/3X7wojCVyS1z3nifVSXp9E57fmNdZG+Jqlu0ZlxNlFmrpOBrS92V7rnR58HrgyzmOUwBgHYg843InfZI2c21SnVrvby9toNbvMgq39vrpcoaLJT18qaaVblHEaGytrVWLlXUrDXI2gSQa1ubW1IOjA62JX8C/NLsy8NLBDvFI2wH7gl6uIpIgBgIsFHeqIvYJq4ddzG6r8sfdt6FtirrP/MuikFGo0F/lzc2y+WNrRLIRztbmLBRrcBXo7GFKaXZ7EsUOOMQ2hzlaSORnZ9afatr2Dv57n9O3+b7/9k1SGHLjbMilGesvmF5UvHpf2JZUjSQkvv/mZ/+/D8cSMhy8FFhEr0RS9h9c5onSYaZ72A5Wrhv5/uNRht//+zDv2sVkLxojtklxSw2s3QqLd+WZs9ybGnCQG+R5gi0DjF+9bGNu+LY8i3HGloDAGSubZTXS9vAHkvWJp5WYoEhKzIA2ObadqkK1LEJXLhcIceqUMJhZQbQnrlR2iiXqlvlbau8iQoWFvBZkQGgYALVldaB7DY2rEoFe6JisX5vrpfLwJ631ra3dVhU781ypVQqbZXWKxtaLDbuzcpWBYixug2ysQ6NTWiksr5d2SivwdahQ2MLWtncLJXWquvlDR0a29DI2tpGFShrc1uLRrmErWxDM1UoqcWjXEYopfXqBuCxrkWkDGMKe/b6Bm5aFe20rGE71fUN6M52VY8KjGplc7uyvVEtlTb0qJBxhQ6tVdcq2wIVV0YFp6ayXd4sbW5tWFWKiSthsoGzi5hUNzbWrW2KhyvjASA21teAUWzCuJfXKRquhAYS4XalXNrY3t6GASmlsQA8YWLX1ktbG6WqDgsc97WtUnmjtLWmRQIhbKytr29tbW+UtVisI4StbZy99S0tFjD91Y2t9XXozZYWCQRR2ayWN2AxbejQwFkrlzZhXtfWqloskAahfnWtXC2VtVjg1Fe2qiX4bwsmTYNHhVD6GhBYFWQlDRqbSOg451vrm/opQQoEwtjC5bRREXh46pzgWFW3tjZhONYpGp6EBnSlUtmswNRu4VIoUzy8BGmUYc2X1krYSnmDIuLJiKwTQgci3tzEm11raURwPW1urG1vwpLb0CGyjlS+WdnahkHXI4K8oby2vb6xjUSsxQMJDFgQNAGUrscDJmZjC1qC1bKuw4PQOQina6USFNDhgayyullZX4f539TiAcsNyAcW5Na2FoltpHNYjUAepW0dEjizsGEDfZXXcSXopgWmtroGOAITK2mxQBiV7e2NytbGelXgEagbC+wqG8At16sVa4PiEUh4IA2WKxtb2+V1kN3xkrVDSiQYGIgWG8CitgHTKsUjkPAgNLi2WV1bq6zDaimn8SCsFHj6+la1ulnWIYLLCbad7S3gPyU9IpSpAxJAhGtaRJAGK+vQzPr69qYWEVzYMOzA82FN6fAok84AdVThfxUtIrjJba6tb+KobejxgN6U10qAaXljfVuLCNls14HJrVdgL9Uhgns+kPBmdWMbqVCDCAzqJvRmaxNWphYPJMNtoLAtgFMlaMhiaF76MMdvyYa5sVnZrhopsTQvfZh+dtGKXBTQc7KLrslFYbyGyaIzp9vF2A3oRM6kURYJykI9jx1LMTmXmGkVwTcw826jsWakROJGwAwKTCY2TUVENm0i2W5DAwFKgG831upew61TQRl/vn0bNDbW64aQ8AO0uUZ3Hvwht/4hV7mnL5QCHj0uIYLza6qxZAyNg6zccYad6dCJXCEqy/0QyPXyApMIMSmDFhntVDcYxpGKLClSksfr1cgxTWG9LkIYcq2gRCIo8narG+l2l2pzFgMF9qP0WtK6YKna8sylMa1TukloesBKafdlhcdF9AU9RkgCOMJbq/no7ZqBOg57qXjFBZ31Rat/Y+QBFofEmXji+gQp+QH1ZldcJB6P3U7kdo/Gof1jxlID96+pGyZTB08n3f0XUl2koRK+//IecuI0YipLJj44odt+mbgwMd5oBC2Q1xu4USG+PSGf/MTAYUiAb70p856HPLA5/Mjldt038K84o1OqQU+hYsmohW9sVxSJu3IX3tt29PZt14WW3RVNtkWg72ph15RqKXwx5IKCmgTYhUkGJXI3NWYI2Ktpk9WzyEQmXuAIBBnz4balp+p4WgCbAJkFoL2+G8WToCjbanfqcQR41iVdj+aNpHtvZY+WYen6xJtU6qlF6lKADYWayTvsou8yRZMBVnFJVDQYjYb+8NEVwwLMPioSsj3v5XNF+riJ1yjRaDx2qsMRIR3ib0DJ9gcxZeEU1F4sbtaq5cb+iksNWNDidBjVmHeza8zqXrzVRKYNjZqJlVwMpw+w7vMgqWCYkFP/yQ2aDt4RzypZNuITdN1w/xqyESBLfTRyOSukr4iXxBF0jKVn1MP42zPLyovGhF0VcfCBLg/cR6/j5sdknN/4abxuIwkxWhoftx+bufsVvMLtj/GQXWCay83Ipmj7vAUMlOkMqQkXdhNYGSYOcaghRvf+704lefUYhCvaOj83IHEoWaBefE3daQzrDpq9ODJq8ZNu3qEjNkivUvoe/ICvmgE+b/+r6NIIxD+kuSrHoW3xDR7NyuFuNePUKhlzIOjk8stoYWz62Xwq+OCv8KFCUgiRFHp4YArEsNIVJAJDey/TxYwRxFHguePukKzfBDtUOYJFoiq5RYHGG/uFP1DvsoXgFmkD0nG12H/t3JnfnQ7dHN/xAr61eel5hT3I45Pqsf0k1BUzrFeOaGiweWZIKBMHO1gQL9zQsHSLVB4xsZHwzlljg40BaAy+CnxoOzulXT9uwDFqoErETYbIG7IHJdAMysD2Xj0EQ7LKBkha2KVQ3g8TAZxUEqh7rG+7mj2E56GMoN+BXEFz+u032ZhCbTZQ24/MnY8THmEHnsK3VjzZky6JFB/uQH3tJQO6HaibaAIYSCM0irly9J8olBxzGrc8OfDJPZ/3Rcy/bbu7b8o1vWDk4gPhydH+xC+Epy+Mi5q8zj4TnNLRHGg6KTdyos5AlJQA23Y/+Pkz4k4qSiVEyAvC6L0TdJ+cwD3pCgVLRFOOYmYroWdQR3LeCIf2wX2WgUXxoYqrB0Mu4wM7epOL2Rd8E1GZpHLPDXL1eWZ9zdA3hCdpj5zLMY0Dgy9zXWMS+H2gnLD5YHsAyM8AZL+AnBWvVgYVWPdVMJTuY/sPX79QOpQSnfBl3DkRccOcTsedRL4cgSny991LV4mJFGLcSl+EI5PQlKp5I9efRgBardfWpI9hCuSL4+TlIxGUC4h9HH89eGPeCzZi8RJ3LfX4Ewft3HvNoM2BlRpEPKP9sGhuvwTT8QdfhKaaRp1LfDFPJIA0Mwzjr5b/FH+ReDI4XiKly1ye4gSglkuAN3TDE3QEAzoVeT1cJuz230GyYscfTkdj3IJC+45r37HIFA++FzaHfkhC2omUvcd+/EldaARg57Evf1KnlbhZZxi9TOTPiRPECMB34Dyp324v/ibLUELYC099pyshd7DX3vvCXBDsNg+HetXaa5+cf0hlfIHGkbbEI8pE85dyaJIldhfAZ9DlawqoxO+toGoHwhJ994freFjWG3sRxklDM9ilG+WRJma6jJh1W8TfhZsZoZuxHETJyEVrX969K983GmhUThCVi2Y7yF5j2R6krN8r05b33qK7Gii5IJt4xAuOJb2xQbaw/dW1jVKpBmnVcgXTgKth6oaI7aYjOazzzgfpx73bADW+UXbXdpM0rOJqjt9Bodr8QoXMFueRuHtXVfosAnVqS2dnIYJ0DDfvk4sB9tGNanWtCtn0BwyTZ4sxouvYk79AcstuSmR2F6PFQ9sTqIWysZo5SDUtTFJv+Urochtx0RUXgPdAc4R1ka3pgTDwsRQgHrqXJpdPWiRuxmDJ804stgOHhLHgBkKplzgHS5P5CfAPXarbi1MDu1wPGiGzb3JQk2k4yA9ASEYDbmCWiSRBipplLOzYmAlSuYOEAcI4fJpl9BQYkgQFAwLMMVQESOKQgq+o7p0S540HW9JgDZmgd/MpHp7qspRFmk02Y+aQceeMV5QHzv6q8sD6RXm6za0Ztd+AugqzbKirTEjgbCMSxNd1MQAxDB8wyC1gk/Bn+/4/1yqbG1sGZZcCFNvSElUhCVkv48CMBRvqPqevQrlymbFlA90psQxQXYj38l1nJFvMYHcLFN7Pdznxtg1nQ1z+fCFl+UDaPNDwiipUkFJecvVRRK/9oBvmla0PM7+G/piQYshNVorVUZq7WEYhJErek6m75lrD4y+AGNJq9YjlkzFO+IB1xD5382wlfnA+oIO79jeQUSDRhjreCA4HHP/GI64vj9SAuAA1UCwS9JBVj7ezztqp8nbQIuaaG+ogEQigpA/RNmdQt/oVNkDlVw+QNA61X+3VPPRIDyp1DQlpZj4lhwGZEdp+clhSUgPkRbn69WUaDLkGJxq1c0O/33eDIhLgrgfiqJlmMG9BJoIMZpSQHP0lickwoByIE3PKcWEDh0UghSrnvwkxqVVoMZz2et5zut2lsCfK3MoQxpdxFXXskzzHeXK8aEWVd7v+0xgBxDQl5sig4mu8AjjPEodrNupVrrobUkFAkoupEBAfjdiJnLyrVFb2e2WTVTZXpNuZugRiuVqyiQF/9V6HoJdC0PtFBD02QZx9p5cGTWfFcOCBVsjTZsmihIakckKCThYUonQe1A23OPaf8gb2H90hdfWv2s0YRIraRDG5LtDS8FJbP1FJqqMRPM/COQ1ryq+ieD4fZCqIXrqIBIAI2weLoeiEcnk4/Cd2QvEjzUNjShOzvStl1+Q1Ka9jWcaRO02FJX17KB6hUid9LoSPhdLwiTCmCcqYEOHixqS8RU1KReWG+cUcTXTGT8qsOY9u4PRdbWEqAspQ2RUaTdxNtSDSNJ/brGWaUNlqmhVWUBdhglpxMgXwvE6usks/fyZlvrdv5w8ohZBoijLD39fSjk4Y+PnTVdPvonuWtfvBVWwztUQxkFZms3qikN2OSFLafEPuXbhZ5tBcDk17OfTDAcWxxC1xA2Hkja1bOovXdOxJxseH6fAbSixpq9xZbKljdk0phdtEZSXUe4gtVyEZSsmUhc9MeK5k+xpRDiMVoc8HvpypBjeeqhraWGrbj5wh2n106bJp8XWGs/d7rYPrvdbhyYHI+pPmHF19aGKVdM7Vh5N2Mo2jQy97uDwAJ4bgdImbSn6OnU42zi2aFaF4LoYkkYQrU4SupWA1FiXi1kIpVdBBoSwOVBTF/keGHWCmNbkkWDBmyVIfHc34WAxIJ2FUtJT7FNaT1bOa+IAdvYhqHVsfrW6EL/7hW+PWtRVE1il98FFRSXm3mCtHL0qqlQ/euIJHkhF56dvO/ZjlVK2UC5wkonH+o2vl2FkzbK8jXKb4+mbk+yv+sJszrI/kKnvfTsisoQttG1a/IXTe/ow9VFuyrm3Pw1fOXQ8fRoPfEf6ux69Wxuc7bDmSziiXhuX2WCHyuKNe8CEyidWyF9WKtxbrzD4xpfZaFMQJZ6QStQnLRkxpyLXPeOx+kWwYnbkYxHur9TS3oLq3Wu35UMXeavXsE6tpn1kHdoveIY/f7ZUqJdTEnz/zp7a+lFBBrMieq7ScGpYegmpqQe4yryvx5my5aauKVBML86XAPFI86Pt4WQrKFjkpGYTLAupmw3DIqQHX13GHcHYquwO7XBuw31O7UsMwyDzKcQ+mrgnd6OCaaZPlY5fq3YYrLBXADdy77j2kg8gX2ONaYGNsZc8MLH9nWcL1Gkm6hYKf7a/R3fDeOsa/g3vrI/6d3lu9HfRM66G3QrPhw8+m7RtWZ+czPqVtfwbibHyEn237o8GetD5GiprYE/N4NYCujcwAVTDbB6S7Zrk+2int5p/sybsRkGm+WegRoQ32iScYgQOY7ZmyL1MrCdumekSDbJJ/O8BD2wD5eqcD7V/bHQNYTqMNv4HztPFJxp0efAADwluHUaOJoxHZTfIgtxuZT6sH1pV9ZR7MFOlM3mVwsFKpO13yZHe6NKRb2vFOpDUiCUBcElKtK3EekdifuxHVnemfa+jCuyvoLg/PrNnNQWIg/wc6zFo2bAOb0DvlZ37gKkdiuInN2cAwm+xh+AO2MbJH8SvovJHE1sNStdtZepHLO6tryEZUvgpVILDnpnmbl2JDLh4E0Ga8JNdJyA7qp1m2gtdwJQ0T8ebuX35WhUXsapxVcQ578m12xjgGdtcYEz8t+DmwA4lrIXcaAKfqA9fqs99d4FpdwrXexIFeznBLD4zRbn5oh6aPmWWjhr/HwAiDu7P7u/69NVyaR4UaHvWG8hfH4Jo8l9QVHhHSUyLyL2kXmJhDf3XvDWTtw5j+uJKxI6wDgiIVSmPjQcSUVxPhcvvXxBancrEVFLeCxE7cVlO43dJinLJtiBguMd3We9ruvH3Lj+wa6nDUjWQne/fWm1TH3r7VoGzbE7IfLMKyY3fMnJUzCcI9duzXnC9mAI8/sLMPSxxyUwE4/AnZTBNMJ2sMThpP0u8DsddqhiCru9q+2vbT3ck9RqpJyugAsQJyev4A8g0rzaFa2IMTs8xGZraIfiSbwyTwHp3IJbyC4p22CpJkqc4g5dGlHkLE+dLtgjgRNDzdrBHRlPhWCr4qGQJYBVIqVFybiY9joquaA9kYltz9pRS8uDjqlynDLaQtNNAqRnq1yEyfnGGaPSPsSmqPMbzs1uQCM11ipi1X8NJ3CQtuTEk/tPt1o7RbqqlJO7ZuMe2W0YWlbML/E3LA6vaW8U4kJ7gqubcmlGkiiDBCtFytrLDMcVDaakCdakBjNnNve4E/yj4q0k+hIQ7wxEjKICN/MUB5njBYmpFQ0+YPL99IMAKedI8jayNyl9iIFOFPqW9lMK1cDt8rt111W5pFwcuPV4GffwhmGLMOeqnmPeM3g5XXNhMuk4uTJisLhOgi6fVBkmU7N5NI9iLJsYCJ0viPIk3X8XJmmsyIEcuLnWpJHLm0xWSBgtqdayqhXrPJHQ7kIyplsxtr+Uw5WZaDOVWF9fFvE3jnyK1jooWOUQsdKrIqatVDolWXiVY9JHJrpSbHI+xSMdWxxyCjOktLo2ONNKpKncRpzXKY1Nm9RxWa/J2yv32UPce2I64FaqgmdTrC0llRZncTRkZCIbjuXPuPy/MPRZ4drxy8PfXG1SthaIPIFEjTFtmi15WNsm4R/yRN9W4Rf+4SRGDe8vTbqJXwFXK0me7mZaO81iPmCFZqFOZZBUO24uMNZfWTn/fUFoKljjYEqrHQBv4LRwWxdRPIzWu4RZV11z0eHyhIC7A9b9yNJTYa5kkAuPPoqnwTGB1/HHnjqcte4qLTF8xZYXiB3kwWi22gWKSeNnDAljZupM2gKUMGFhQ7lUiNTSa0/9TLJRFVMXlKk5BnZ3U3fSLl6k+kIFl3KoLpujMRTFdPRP6tbeH5Wdtb5Lseyk+M49DGjuohiWcm+aqzb0GTyDpDN1LIlg6slISO/173WU2IvJFI4P7SDK9Z4lsjzYqjHUTXTWDnJdEvlK2XWYghEjsrJxJcskKUvZK5g4q7pZLv2xiW2rgR1A3fju7G6CK6XzyCtURjvuVhhwiFQ+gYWL64kz0ka77toW843hbjJ9BjEiW8gw/by9t3wjncmsZCqegQnjMJn9s4WRkG1XeLT1TSD1NMVzKDTZouGaZOcQms81jGHJG6Eai44B3nJAvBjrssfEQ8sfG0GknMyeCGRgpxkh47ZTO806mINk9F7zdqBIjirkwzu/ODPDyhgMIuOTZ3fvZspXXMHCh6Ku8F5BTVXVjcHhQ9IvdVd4Qv9Nu3fgOFcCC8LIixJmP5DWpoK8fvtMuAbX9pxGBjiVGA7tNaA9giikntwkoOje2AykfcdKdEppnuoCENPhw29igsTCXDJnYwMR0Rna0pLqesiUm1a093/9ZkDJPdTJyORcK/O9V0YuVgEl7jrkWSe6turgm38BlJ8ktlZOwg453aY4yUMt7Z3iaZ29so5c1m1vdMHo+RIzTxLgLfj/DaWMw5Y6NI7BQBWq8HEgy5lysSAfMuNKBNjG+YfXlwnY58g8l9vIUdoMCvE2Hg20NxC+slmYpXsaSLqVze6gxc+8cX93niMWeckkXscbVE+BCgfBSfOr7/ze3WfsxmiUN/aW96mIYvMTMEmgaF+uMUhgPkrAtQ272QXOskt00NCU0k/ZbbE1VJJN/k9SsYwKYzHGIwffniGySfhBfwDW3FN6wgdUJu23lv3wbxmY88M15R/tTMkleUvjQT5hWlr9TciVxhz2Cz6BXpD3UyPXpvmb3nWSjXWEK8p08nsNJcvAV1ewFSWVLJZ7FOWDgDzASNmbkK6HZ+lWgiHdG4chsKKG69alHST7la0uSZNgBCQgCR8nj503jYk8WlGYm1sDnlCZkXJSonRycS+wrcHlDkICZHqQGGzkU8yxozG89KlE6bMQU5iAu/hAxS131Jatw5falX94uB5SMcL7q8hi5Yllw6y7NPXqqkfBR4aN6DOcFFmTdiC5m8gJmZIr2ElUBSicVdqtNLy7njw/YKZIXF6DnaxXXObYh02dclsoXl1aKXwfMKbVqRRZhIyShGA3ecZ27G9g45J1IjLvzQchq2u8yy+7egIlUpLxXfH0+6rIsHXgGJan7CQhr81//6f/+LaJTEiWgh8DiyAho2WXAFOSk0K0ZdYZhC//dp/A/HPiRyOQ21cDJugh4LO3I+HmHNpocb/7gITYzyRjGcDEFH+K//BYijwUN9cWbIdWx8d0YWKqSxzIPwfje457aRgbwHk7GDsvnc4TPewsaAHJ4IwQEZKx0GpZazBtw/ITFkMx6Ip++FEaFc0XQkjbKYW+CV3NNdMOck1fOIA3yRSbGy5A0v0m14gpUckK0h5ZFNUpnjftgJvIdEvDRO4vVMRsujRdnprDQbjAubuZW8tNJ4ATNn5AwjvUFCcSg9S+1dwgoWG/c8YiQ1+GdAPtF8wiN1wW+8STi2w2J8fGTNDQJTsnzD1vSQwnTskFatOyLglWOL98CFcHPn3Nt3SmAZVGPjzt9brmnOuGk67icwHXnS0/xaIuJjpJPON+aSbircq+cAJyDPx4PQ7HXJk1gyRJTYQMOOuUad+4AAL5APJ4TYQqKmEzULR9k1PEihp33Cd1SRk9wizV0kLoly86UmUWye8JQslJShRD79NmrYCcAPl30o3yhXCI90gRQpvrjDof90AbpIaNRhrEpygJo3VJnl40PM6nyIDM360PVcyJwLhyggEdzmdY/efqNRVuJe8rBXLipXEsB6/JrUWNsij4VFKjpdUMkiEMy79PEjn7M2mRsTWkzFT9ESBjkD9iy+fdCIU/ERiFhXhqBNeamhmdgWtjQlp4yhscSoJrLsMR1G+vAlxm/iTiHz5GPKQwN/QtZXPnutltQ1J7Qh+wcN55MIs/WDh5fXREWJByAyTTWwinQCnskiEzBYXBU7cVAQj46HQ1pHFkUL5HJKU3IkmURUIAUbcmb5hrIOOWKOEqMpBTPFSwhxuHGEL8LnJ2SJTVzg7zZOPo8OxDHmcFXMfwlr5m0qnDI9NAy8ycNCKJTvd3LbuIMUCiIeFHECjfyryUREu4vj21keuqdrR1WN6/UbprA8ZwpFiKG5I8F7REZjN3vyGLSsmaslGscohFAVpZQow2sDr6rsppNgaDmwr9/9cQX3MbphwngQw0PRC9kbFIYgOjFxyTKuwY9o+OTulHZx/mpEyleOeajt2auPQeYM78b38ZhJmKBROjDiIz/OgnkIExhH/+Gr24lyvGG8OPNjpkavcw0X5JXw/GkMaiFQUfSSH6PpLrtZEHJcyDSsALBLNC+4RQKZSEZGNzS8Yn1OBxLH1qHY/FI9CGGsMcRHeM/YLe2/1PeQinNRuibeXtWmvkkgjXHmfv7EP2I+jd0A46hqhw19JrBKbW4RzxBDmogaJs64mCDHAojtXZwgYceh9ZJbw06mGMdFV7Sm+W4+JbTFkysHSJJOg8lPqqh5vZe8fgdCr8gZXflEK36HiCB4vM+lr1L32L6Nzm9sB+cXSFru0AVGh7Nk2rnd3hNo1u4YD2GvWif4Iqo/dqFzWfUM/oJqSnjIVMNdroaToJnaSIdBHZ91Uq7L6ORiQyMYB7JgjOonaUQ/3hm3cWQQMNoqmcqwDCIpspFRQgyrlCjXwUClSZRCUDD4BIU6EQs2C226VDwxL3KN5JQxKTJBbUrH6vMHNstHcmxkiU3SqI8NuhDjeAyxPGZJ9GD/xb+IOZsR00rP8YZu11rp+NNhl4RjJWBXYOGu/PH5/MMKRRFDR6xw1ZVbJykD+FtNELfVOW3UWRvxYIqp1SRqluHiAZw3cUZi6pZTPzW6nQ7ZtJrHtBddYWZ+pCYcEHr+5sxezp9ZweM5M2e2UCaYK2bSmM8vYC9CWFeY1C5/gJ4Yx+MsKxJ9sqRkQ7nbnTQXRPLkWS/4WtiFm30albzjwRUY8upzpBjmhC1/4nVQAhDH+kzBtoM4PBghQTuUzju/YKR6pBp+aNE6P/syfvgCPM3lD4p/OTrdE2mOVC7Ce7NfQu+7y584J0WlZPlYnb9gTuB88Xuh3efOBsgdLiirljwO7HWQu6rW2N6wfLu8YTmQMLS3N8wta4B/1irWFP+ub1l9/AtF6BWIvGHvUKGZ3szCeENdE2MUbYm57pp2xXKjmTWZW5z+rtCINvQDw+hU1mVA6wRQx4b6FNC13TXdiAhN9eud7tu37t11AYPWlOrGdaFAt9IoYSAmCgj1lu9a14bcgBtZQUSCT3fy68YbO7d/+0HcICXCHUJ8skfkumEnj8/rNNnfA/y7hc7r8LdCNiUe/WvHrpR+/jyIv7Z+/jyJvyqpFlowvGc2PuVaso7hP7weS043I+uqHj55yAKejB8dB1ljDWWrCCijZU8Aryvyb2vH//nz6o2Q5QtDpREalJTUD1n9AbZBULfeeKDTXVAnVyReFFuAfh6GeBcLL7hh/xOtGWpzg6zmxjVoa1rnZCDPBdDChlGHaShv1OnsxhM3cJ/J3EV40Y1IhLdePYiK/MUPCVCfyVCn6epQQXohg8zR9Rv7lON6GRvDT8aPyLWke8Ejpw+D5fXH+ASwa0HOkNwW7vhBMJ2ADmBdEo5/6j66Q5hV2HokeINusHJ2UK0Bo73GkiLj4WXMM05TGbi2MYcPK56v43gC3stPVgsXm2neA0WxH5/JpB1LU3e242gmjDHxmhxZlv+GGbhANsJvcncjcZkbGGVkyCwngVYkgtnytcXOpVw2Y7CdwnbyiXLMPImGGBupC7k42jTxSkCjIA0jhVHriT8H+3aVox80b6PxWRzQRMZO7Kxp7MrTBbtW5xuoV/0jzx12ayswGXhCZuZW0G0B9XgLr3i9KakHtPqjWXGuSTeO1KkmTU6cfmacfUrRiGU5RxMthmRnFN9Dx+K4TjwiSmVDQklsYLprEjxPnGnHe1uyuJQlcIt3vWRpKUuGHW98OvBxrtxCdh01V5wcIVfRRPIRYwISQmosIA0Ejse5Aodwc6RShRRvOIpAAg3ttPOIOi1ENvn/2HvX7rZxJGH4+/4KmecdjxhRsiRfkpZMe31REs/4tpbcmYzXx61ItMVpiVSTVBwn1n9/qnAHCMqyk57MnvM+z07aIkGgUCgUqgp1UV1diOfODRZwzT8dFOcGgR8AWADKRiBz48JROgikE4jmpWPIQRo8oTmLROswnXM+QJxclWsdGW5qm1AgvL9l0MNNiE7xEU0Fhr7BmcxISDODybxjfMC65/AtwG6YSsS9L8AsD9wGlJ+V71C1QFRRUd9KlvSAtW2ns0FQG8QTx93x67vlPAwNzzlksRjQpThZHDMvAL0qeIBlmdwE0ecaD+DAA6ecB8PlWUbMwY6fO9DCQVj9FnbQnCv6vtrOC9Rlp67boW6WVV1hPmYerwfCFRBKZMBo4WhFlWUYZCSjveN95Gq0NtFNzzlAZl0Kb0tUU8IvMflZf/iARrRPoNHgzILE4bYVZtB81r18xanx+yucFcUjwJKekeIl3FrVL66Povbm1kz3H/T0kxS19umBnihrCDQSVB9e81NujG58/Ge1gYLqmkN9IivOmqPXHRGQEC5/wa7ogyGO2sebuzzA72efyiNX3udp9SRkkQFolgqDJa2JEnPzMpZGATQxPMVXfeK9uC/WIgWEielqmNlBH9bEx0/4XRQpBqNVR8jTQbWxPCm53o8gxeThG/cg5lvgkrAWbT6eyRm9MuibqAlZaLlSjl+9qVc26+5ao15H58q+O+duG7Elr6Iy+7g2gb9ASLXN7g/52vuDF0tTO3gDHPIDTgaNAdko4A4gWYxWAmSVjKwW2T22gg16W8k2xwCEjYRZotor+S2zurrA+tt2c7yqOw6CaXkTPYlz7yjq6QoeA4mXhZSYH1de0tMl0atoaHj5BfjLBTkokZUypPDvHA4HFhnIbvrjcZe92YuGb4GTpsZASvv+56AXvwUxYYTZT/ljlu9AF+18GU6eE/t2Lay/DmvZnQ3wvHRYcFBuq1xGfRDFcXnZcShPiaJP2O4YhtSWlATIWYn6A7ti/ADIEEEN9NAmQjSH+EZEeZCswewOsLphFMMCVlYDYTuvdHOLeNd+YqGnl342gawVchpYSR8f05ohqgt2KrQr0F93ccBWqk/kQJ1I54tZBA+kLrzgjo27ISE6BIskBRf5CGWglglqZ78zyrJpa23t/v6+pnW09vZiDf4ziaM15mvIgT0Oo99r09F0l0ublQxPGsX4qdtG+i5m7hjXYJ/8DpMa17hkT1lQX7AgRVeiZkbKKWDKoP4qWnOEZRWJvbSEUcelHOwOsDjUnDmf+u7usLye48jDi+P1M7w3CBJNjKp33xsXLyz7K9L5o19bqEBhEElNUwhEqFeIeSnD7Wg3bTnOQoJS5FnNyRgAthMeaJ56d6gvj8d4uB7Tw1VIM5qszEui6ic4yf0t/QngGE9kzqWEB+7xaBn0Mcid5Ma9sAj7w+vhkMXJ4I2swM0T4EuoVWQUz7LcdS16gnKfrsVF2zWJJ0Aq2/paBPiyK2SHcrkVXUBUBi0pXS+kvWfkRdgx3KU11OdifSwdn1B5pKh/1P/YV0T+YLKVzI0gslQXJQE0jl6lGnCw42+BSif9HLE2iUOuGFoy/aNMomhTTcXXW15Q3XJlrkdTz9Z08SKENdwcxube2eKSser10lnt+Ozd0cHe8eneSYeHXPLiOLqDGrTdO/y1c9E76nYOod2l2Z7kR+W+utytRauUhCJdJ+/cZZo0bmdailMsuSl+WcDl+TkLoBPpOwtK5Uo3J8UDVVgrXhLhM5SJZGSB3BnMEo1DOYTooUBANNxZJxzCEeCN7sl/508i+c8LOeGJwC9ANwZZ+EHls1wM0e728glq2nldXvYnw+8FU1upz2XVib0sYwTM7jAyeofhKIhzWvkoDYXUAq9B7hEchfiNTzR3Ud7c2APGJ+YOgc/4WVVXONdYi5KxJAsyoN0u1pVyWY6fvDzFm1LrLm8Jxw7tPpkvd2oAbubP51InOReOtYa75cAXZWM11gWdksXUlgEWlucioGTXrTEQb/Yu3l2edE57nrhYwepzpRbIo16+lXoMGUvzs/BewJMk7g04dfybk8jXMHgCzSb5Aqr54Y82rFxpStnxWe2GtABpmWriKpskCY9FSQQ0PJ+Vu/gYvtobDntx/hNcZC+wDa6INJYaCCYcamul/wBve2QRBAoS9lcMUkBufULhqUANXL+q/DWHFxZ+skuRDV1T6UL7iFgRSDoKLEu+ZMuGu5C/K4EvyjqrFhGR2MgkKBZFopJHGH2Of9dBQV9Fj/MsawPVGc8KJKtDKu1bC9rSWQu2HywRWaT10yKUbLDayczAr136tm0sp3t0DAzE4ZtvFn1PZ6IbZBS4EcNPs0ytMy63mQMTXluYug0tsxWsBKJFfvPkTEEuGlXEs+XPbesMrMe6mu9JDyE1Kr0YgIvcdcWp6rS8PMn7YDxVQ1Prcww7F2SiR1cpEQUkklmjJkWkU+Q4lxabUvyGurXu5cFBp9vNmYoCi0nbrLdqDlTjjnpiRSmDIOags1oBn5NXBSo/TtL8xLu1gjKykpFJ2ap4bEXp08bR1Emu5y8/4nKzVSZZzMs1mdX0jaflKK19qLUiSt3ch9rgyjnAbYqq86T+mTrigTRIZzy+lDjGdjGTAn58EWDIYXxIJYHU1OOLuT9CzzcLk70XtbV2izGNw4tgGifZkp0v+oJtUCXCUfB91MRWpPtFydgOFaesphSsOK4ID8Yv29+9l61+gKiQ013IEylj492nYZtFbOyh01pqJmyYoiygT6DpT0VB2SoWeN8zlKeP4S7jb3lmSfWEmUNyiNNyjqoBaTbMkcftH34S/HvQpk/lCezlE2K5/Giqcb911amppvBiblfCZC324h0/C88/BwUKsSVhEA3HD6oCbgujU5r9O/biC4Z82Z58e3HUOT08/qhq/7ldyRMlskCwlRXNJfqb+mtJd/ZAs3KpHeh2P61relUq8iZSU6DWQprHVPug1gRtZkbsnzoZvb4g0ZRDzQOcpA/MFW8Rwup8zpf1huBOMa7K9abJLTCtRcaKBKJE4dZYnkn1OV7MuHOU52V/Iq8dy8FKu0vgs4CV9EMvdd6d9lxI44Ic8H5JCN53zDiQ2RKb/InGECIkljWnKTLkVXbtW6qSK7V2TuNSOhuMSn2uSpWoTyWs661Q54lY5un9qnN+G34JhstM3Mzn8p89QSRjkNT608CYG32IlJME03F/EJTXrirXa3ee85fmvqM8/Uuzjk8r+rMGPlvRn23gs/9Pf/Yan/1Vf/YGn5X1Z7/gM1d/djU4IAB5xuPbt+TxmvZ4/aq/Rx63jMef9snjtvGYdbKrPd7kra+Mx8ND8vhaqO7ChsYZYmDxJGJLeBugYwRbXmqowHto6IG4xWirSpeRecVZAvzQUV3GrikrG+CtMdoCwgpMCv8FkTSpOKs1p22lY5Zm20rihVvbWxy1ZPTDXXtyXjVItXrUoe0481JxhkbFoT3KKy+Sx1qkhvbwvNNq1mo1LJsdNTQBOM2qwnwa1cOaWy9ci9mCmDz/7ipu7JqvLVvQRdGXQCQkTpQTAUZecjNn8eyVV14oZw+iW0vNWGTO/2yWnd3u96P/E4ho/AmImE0RDR/CbHSueA/L2CUTGwnDRvJcbCSIDebuyCKO6RZnU4qVeDvbyezFMgRPfy8uur14zjyGzs+6gDg6t9oom4zRhUh6XTDWlPMlenxEH5g060cDfEMvDXaDovBR2FBae7K2wtSvLHfgauZHZY1JhBw0/hc3tXiigi9bGuqWwiPgVXopWDoNq88nFPL5AlL5OdCIl3McUhUn1WQfkkxD39TaOHVSATHydyILmdKXGEhHvjHGglV8YJ2Ljc2FU3yl7hiLg3KIJxMJ0hMfzUWwfy4bZe4JhS3FHGm0GrsoTfN78KDi4umI8UxG5bFNgJXlV1ThaxefiPwXfKSUX6Nx6WmpseaWQjqC3S7Vg+FExTI/UNcnI7wYPajk9EKh4ZPx0Ye+CFXIogKWDM55dKTXVerX2+k2r0rQTrnPVuRjKgdKECFm4wg10QdwpyJJQhiqJdcpXDm8Yr4VB+QXp6Vn37dldFd2Qc1mz6iAKFhRap0obheowOWLaYt3dorWct6z7ACs0lNjwyb3dWu/di66mO785Kh7stc7eK/WBb2fGHVBmQQv7htoyM5pwC7DlKQnNpgxOwHjWMQ/WmJKz6GkO5+IOyCulhoZNTrL5NPQgu2yF0t7wqHn+ZHeyhnqJ4kWyS3sFk8mqViBI8g4fBd4yczz53BB6xPhcKZLnt+DJ8WmVXi0KK+8QB4tQVHMO8MU+hig7UChJU5BBetLwAJmv9AYpq0RSgsWs04uzYSdEl+gt7h8Pvw4VKq4kpNQtXa+OIBHtRySpQpg2qolcruu3MS/yHoc5NDoB/ySkQvXmdX6GWK4z9NTk86LoavMTaOUpUweFLzvnCydmTFNz5yi951ze/JLlmPwJr694fc+yl3QjXoX5KqWZUFtNonMct1xSC7VpuiQ+fz7IuyEGtd1kitIDPcsk71pws78kC/HXN7KKsPigmStKFELwzEPx1xxOPZccWwSTUWaV+Eemc3n7TO7m2f7rNjHs13mOC5/cb99EdcIh53uwcXRee/sQvEH/WKvCf/FXhD+i9WA7v997pbPHh/LZ3DMwtbEIiUd6nhbAuoCETctneVdcNMZmpDxz3Y+Q2endn5xdnh50LN442p5iDq1bufiCPBzebLfuTBaymSeoj85H70Nz1IkGl50jjt7XXNsM6kR7KejixPEn739FKM/UsBBxgObcASUlbq9zmmv2+n1jk7fdY2vxrNJGMUp8BZofXx5cnR61j3qfTRasVQ3ndp+Z+9AVprhXrZTvNqGt5fnvaMcDmfpp4NZgiWEsEV3/+Dy4gLgMVrRCCVysKA5BZpedPbPznoHZ5envcOzD7kxU3QbS0iXnYtf9y4W+UVTJmSk0bdl14dJ3h6M+tFdYHtLsWB5YyEg7gBtIxn+LkcnfhZob4yFFq8LCEH0m1/047O9w84hd/62NOju/QrvG4XvT84Oj94eQZNmYRMOBXfBz1OTmAAjo7O3bzlI/Mkph0GnNNGpTmL+B9Zhnq7EWAV05B+LTzX6Ec9Vb3VKQE5b5flEFkl4JQMhFxBBKsRyC/xYTJgMkS7S5tupUbbBN2LguFVBd9dnp612KWeXo/48T3XdO4aGKFKE5R1jlFzfxqUwFe1MMSvYYWUrJToDKZIVRm9L+Ywn3c8FDl+R255rHi8cE1WNq4vcQZVExtMPLkRWrRW1UCaZyOPjiop1OJ9y4vzbfE9aJPWfIJXb0/TmgBfq325Ws2T3bX3MjP6Ohpb8q2ZvwW6Qz8uKJiC9r4K8tk/1xj7L97cgw+9TfSqf5vvVc9wu3Sf7LN9fURrbpzrk38keC2IdLF3SsvdKJv/8jdOC+2chJ9fMEiTtvOZ9Zws5yHkwdqwREsETsRBsICLT1fKNeCJQGzZDPv0wpxTTXDK3434GEtTf0jjqEgnSEpP5chvjN3blIXOaG3US0dyoZ9RN+S0HxmTiCsa+KCZCja2xktlW667vJ8SNOSKXlnE75BXm5nNLXJByE5GzMGqeybNPlItpgZ/WYKRZMlbatNXsL1fXbVkZFHDlOEZYamEOCy1cVZa4t7QEhNUAhKPoNq6JKigy+RSPIycJ2IOF3bDUFqREKbD6UJ8EMfQSJr7/8HH4BROQ4zqvaAex/omen1mmyabDD4PPqWs+wNmYaUgUzVuZzepqtOInsuyrayvkSmt6wvy+ZxUdR1lFIyr5yQVUopWLcZ/klpDq4nwVUznvdPEqJmqCElFp1uEiXW4JRSyMtoxoQw9V7VtDjibPyOujzOclRRZG66GzmrgKEqhdQsbhZ4RKGvJ8oKURu1k8hQ+Bb2tRxJoVwzwsGLd0xX1bYdkYU6VylwgjVFRwI8BPK5/BYwJVXBnt9fId/AOhkNt7x6obRlOmaNvbcy1cfGSo58ZXpvIux8pp6eZ4eTVexlEKZd0Mo5RavGhMtVWjIa+4wRtR1d1oxPR52Uho8GZDqdqLxoYib3xhqvnKGESfzw1AtXwlxpOe+3n60oPWlQpmPAS96A6G1OGURerVXYBxXOoWEPtMq5EmU0w9y3VNGsYt5oO5ETCvVY95IlDoB89VVz+/e7I2g4g5W730Tn5liWP1n7iu2P+PWlVp3SlYUyz2k5+izBX5dAjti50niyyQMlJWh0YGylpzH/2MaN9Cq6icgwGnPok8u/1Z8yi2qCnLkYNWj122zObZ4cuWE0pnr/Kw+VmoylsWlbh6AZ0RVi+hfjZKlHNXR8UnXq3yKWa0SLF+LpPiJTK/m0PpJlaTPfGyrQoO2XSfjT8miui4o1LGzyIh3Y4syYdCpfMIKeb8NGhz5m0FYgGdDrUhav0s0AvM7xJ+A05915qTeDbpmeKoQYNUvvx5y6pdPahrSuDSccGBfTYOuGxtJKKgNnolQt5LpNqboUe8Yovn1wgeGjZ44vjX5KojU24ZPFsSC3Z7gg6pZgqLTrmLj418EeKDfAKLnD+BUGIxX7PwgASNIdUC1gSAqZL4/jXxPQ5U+J9IfsEhS/KpLzqYxrBwKsl/fuILdkv6n5z2goK4TNILTtw/IuUFqWpD9c4CcNuWBESKyrYXDS+Cz2EaqrKCzEiRMwxpCqyeCNqmInjBTmOX7EMgrM+1klOhDKGGaRcPRv3kIB4G5a0NrGiHO5tToZbXtCDPhkWiFGGeMBgsP26UZ/dRl30gf7Yn1rMfAOxDVoL4rZHNd9l+qplbYCDTkhto/HSRIc3Y2EZVZYNfL7QDklCP3Y9Zq2yrxbwAIHQyZFtDOv6z6yEBTL7APH9lzACY3m14pztDqD7FGm/q1Bbc++rM6emmgjtZvDEyk3FYwVQdbnN9FHCPfENWNVUkSXuSdQwssLTQr9RMmsNxvK85lPybsWt4s+QwmwdOIFX/tAChn4zvn82J9Q6s2YcYEyggAtseXqTlOk1HHkwDM0OnRcwIdnP+7P0sDstmZiHTUOK2sH5m+AQfSGUyXD1daEj81r1UijcsG6ZLLEFGlGTqCh92VoBLy1ErpiVlv8VgJeZ7JZU2KWJHhStfiYQU+YJlJmv40JKhOymKjmIzfOJ7l4Q/fVYvZj2CLMmgdRTYzwsLmla03AbajOV5ni9R5g29iX917U3xwo9cBVkTSjmijCUmGxD4k4VMh/5fvZIDMmjST53W1V+hw8LsVWnZ6QUToG9S+4ggVbleHZAaxO6LqHbnl2Ad1nTME2hNrwbXFWctDaKUug45XlyU4NU67zGsGN5oOxed7s1p78B5fOS/jo9OO3sXjksqJeBAohJxwyM/mQjfAH7WZxdsfd9pwHzvCpBM0EfQvDvt3wW+U+lDY1FvleSQTip//ebchkOn5fyVzu+vDmCerE3rr5WCyd25ld/m//WbN/SHFSzNjcHVtGIVPvnt2vsvB5OC49L9pp7go34qPIVZC24Osk+BtKFT6PvDMFm99VHnypNM0J4oxTj1aKnARhITN7V8QILB7DtyAshxPScinh3iIhbRmGLZdhRNZlNkzJSwAbsz+6RscdcpEMbIRkqsNtgMdjpdKzI+LlZKVwojccjvUeU3x1yTuVRv7ZP667cS0vaCpc7cyrDiXM8dqczhLHqjIJmEWHqgg1Sm3q3C9hd8geA84fsHFWeylpgPvh8N/X86nhVFiebVYga/FcWTurAb67A5uHNAO640tvttWOjwKr4GBMJ/Ko1rrxieiQNoxYCvqBCu2I8rTX50PCjWCrLbclZoxAaeNcFzp4OBGGaxZs1mqsTkYWlkj+xiDW+WGLlQC/y39cK4csGmDfOmH5MSQiXETMWPtQCFYooRJEOcfupeWJg6e8EcQo+QMwmYlqEOZipF5TSjVeSjBf2xQwg2YE7Zzy97pGEuN5h9qRPXfZpJIp7GSE3knG0vyzNpSQJHcBdLQKcdy8A0nQSHVr+0UNQIGgBi4t8dW/AilkwgELB6r473B9ZwKMY2m683fu5+SZX9MsT9MnZnReOMr4bXgpPPFk5vhsfrwm4IA9ZaWbq5w3EwJhXZR6OVD/0uz8wUm5Tzk7ndycoNff9l9BVjxQdjZYivc2k4S2ghrjFWH0NYcJFaPJBGpUbNcorI1kjQ8KOFDVxvh9tBm7kBWloeDSlD8jMZ/Rn6YYX7Pqw0rMncTL7BncuWg8YKCfGDZbDsMkeyIoDdln02wp+W9SM80go7QqhgttJfzeqSaaYSetJvkyt0/XH4idep1IKjnbrn7K63FHO3x2Kt5JMSPKlDo0aLuHM9PpLvnF34zeOVm/AwF65VbzXV8bvwr54+E/u5Y/3d9Wdpyv7+AH0H62S0A2c3YINaxPbA3X6z29hqNep10nrCOhgGd9BFvdVQxz+7vYVdYkz/L6WL9+yjyad+wv4cf3EA+vXm663Xag8g0qHVz6iro6o9yJXv8J8h/kP1H2/g9bx7LECKrDpV6cVYFy8qfBmguGG+pBhFSLx+7iWbbogMNAbO3fei7XUi6PvN3fJscTC6N7uqX/t+Y31ra3V1doWlihvNzXp9F87jBgxWB8qPfXwBP7AtbAXouEEM5AuWa6dRR7UGDnWg+CGX3eseFnZMt9cJf0gBQPLHQhizBTCOAcYRgXFMYRxRGL2ZKGa8jp80r3fqLrKLnr9eab4q45O/AIReb4e3BGB7Pv/hegN/vT3Y7rXdId3PM6IJDPwBMCpiKqfwN9xvpPAGzYHgKTkQDvE8unNn9HMbku6uDq+pAlVm2w1hZ4gbw6zkLOo4ibqcRINOov7kJBqLJ5FSA8a9T9zM3sJBQPJE3RNFkX1Ux/Uz/jrBapMJcNlheWtzc31z7d4V78gDl53MA+DAg22+/m13DPxlCFD4Zfy3OnLXxi3yO08A4aQ/7sWH8Qwr9CoDYnNXmwUONLGTEJkSoaGpr/QxAdStAeeBx0AhONmpP62u1znKJgJgNilUBOkHZFwiP8KX6J09VBTTjLDZNin1hFBlfnm9XpliSTF2fYkd6CgpD1YbyHYzvNtoOS3y35KDWR0rxrRfAQQECr0/BIh85TmCNgG6BiGWW58PtdbE+n2Zf5uHpvnqtu3GMIPdgxweyQJgAmKyIvmVaB34BLa40vcYFCrcBxZgCZASbxvEb1j5Bqb4Cnpfv64OYVO7a0PYrvAnbGylLxnTw026WfLQ+RIM1HToWFglhCU17bZKNi9mrAUmD+LCnCaroUXQukX1/axf5248lGwQXJIL7LqRqTnif1DCgWMC/onxHzh2iCKA/yiHjzdRjx1S95oXvcYS7aQ+uxdk3gcvybxj7zZr3wJG3i1Qs94VSb7vuJr1boW7ehfInu/wPpuUh7/EfxTt1CbnqIqdIfaHkp3+K0N+mlC5MrN8wRPCFIjDV//KkGtM/UTUXJrg30KUQRvTZLv++DhVjZJGLj5eK0Sx5t4G7UPsSIQpTKAff1JpeCfKY1im6gQtSISbHIIAwP4SvDpmnNWdE1p90obKCO9fQDo6nT79ZX/RgvQX6WF9c0HGL12Q8X/GgozEgszMBbkTCyIPspHg2jDrA38EfA9mcMAnMIQ/ZcVcgGWlPBQzIJg6ghYCsKFLDHcN70I+HQJc8PzYX6l7R2oYFWw4eNiAV6urF/DCdM033yv+7LlX1B/efGy5LTKb9IeTMDrvp+k9iGaWIYOk8KXpo5TvWi8ok4MuDormg5WVwwiLi5pvwunecJjY3gC6oyA76ae/57uLZ6BW5R5jBcr/mQG1ZQ/53tIwP+PBqB9FwTjfOBiA+m3phdXDzX8Q3oGSZ0fLgOJk4cuL/v3i97PoCKk2j/MZHNRIKxZs9NMM35wjdoNh4XtGnkML/Y6DlJBD/lUSBN1pf5AHOIMeL3sH+SXLBlaSnkXhF+sLXqog31MRrnBCJ+ldvqdg3H8IhufFqEq+2KeZFTyfpHf2F8mXk6JXme0Vkf/wbziH75BV9UD5us3gQbsnamKurq6AVOCiauD70VXvenV1RP5Oyd9lbF/H4zyG397lih9kdARU7Hp+jwrDx8gQCUmhRkp9Cc/7SX/iuEQQ/kDK7BGZYEj+/R//8jvA+UCg4ePjAO/8o4qzBuudOVq/I73fdz4wbaUjAOnO2pN63/eM/oZ6f5c5ZZ1bFj54ZEVAPhuCCPRPfjtxxG8nnMoFCWm1XRxdgoamnfJc8P0nnH4kedI9zbVz698zx67nDRAASJSxpvF4RpJE7wb0OPwn6NrLD+62qZqmCw2Ba+8hIDJBvpd23qSvJhfzbplU3R+SK4Ze/L7XO1/OM0kRkP7748F+hZQjVq4adw8zkQI4V5ZjccUiw6NAcSDldVCUjMIWLw5VyZAAhIM4ag7Li79waKvaNLpzNB8p4GHHsSX6owAlY2hby75kTmEtqEwWpLormAezdcvOvOLbL2sMtnWyhWHatvjfwh5sEcJ65Gvhp3pULCkudcJzdv1fLi31ZEYzo7CUMenislInPNedraiUOqpZUioHy9MFpcyxlpkhTmze7tjzHLU7BUmO2h1rhqN2pzi9UbtTnNuo3VmU2Mj+lmU1sr+UKY3ancX5jNodezKjdkfLZKT8PCWD5nIYtTv5BEbtjj17UbuzIHVRu2PJW0TSoe2/IB0aygb+fu3y9MhMy6XK0NCCQWkrRDyO74NUNDw++9DpWtuNwruR0vD90bv3BS0NEV0Of7H3wQ7B3dsEM31GgwcCwru3F53/ueycHnzMJRvDIlxq44vO+dlFr6g9KGCwJxCCvcNfgWxykBqSHYIKr/cv9jCv3fnexd5JDgIuPpDBu2fHl9g0l34OJa0ubHgcu9s57Z5ddHt7vYVFoLvkIzVvWZYvPJZvNE2Cz0qFMlEnOiSgip8xuVGRVaTx9kX8GgaD4MtU/IR32YP2Ew4VtM2J36BS6L+DW/EbGRg8Gg3HCpgqifJ0Zzai9HsZL12dI0TxzkZ74mUBrSkd58mLQ1RATUrNbEpEJyedwyNYTo4i/gKY0dHZ4c3er+94NjTjDfAinojNfLP3D3/dGMZIoVZEmhJ6kxzFpC0kaM2XRsnLWSINBFFLjKB/5EYiMYCmxRv1plXmpNjIg7Wtzdrm+paLFwKyBrXgT7ka1JJzPdWLyr2MbjTG9lQ/pvnBOjHB+Z6em+R8+QLbks8pSRo0BphL0qCzR7UwN/LBfEFuwh3lkpmKrlkm3OCWClhCqTIhEuzyKVwoPDOXJ0Ry0+cllECK/DkxgvqhrAQIAkR6uKe6GX4WrDZO3DKcnvvT6fjhQJJA2UryJBmOvUPlekWdM6n19ko9szzt4ixz1/SXes11wQKKwyvVzl7hVe6WW1hoXfIaI3ZeGegnLZLlRFSr0gv4XopLlQ/+CGRqLFfHpjbUT0KnTYiQ+FQhfAlClZ3Nt8ZP3tymQNQydyOHU5+Eeg79PMrPi2wq6UsITe6gwP785BHq4azTr3HQ/iy8FIiraoi+BqcZoq9P4gUh+rowouOISRc/CzeGEC1xwuDSccGBfTYOuGSlz92UlH7a1i/QGJS9b0CqoyU3j2fjJydSSkRRGuTy4Y84cRQx1NyvYpiftlVN3UzdpRw6nfUqcu/PAtuiN0q4Ffi8TMtQQdVIy5Lmc0wwjRPLrJg5JvbLXXxsJGYQH+RzTNBXthwTMkZyYZYI3neQzxKxT3orAib4z88SwSxH/8lZIiiIy2SJ4AT2c7JEGBWOZSCpEjOmZpQi1jRuxWGmN/GTWtekN7FqY7M9DW7Np5J/7PDYCGb8U/0P18zGLk9UwBo3go28kbMRVDfcImup4itteVc3ImmEVbGu4Ub7zPTkJ5QSLvaDtXbk6qbMkDnHEm9R5cVOXavxhY+290Ir3LBgEnDFxpm/q1KU5Pf9aDgOEm0AN2cmtdTKVQYlN80LjLhoQwlEsGARVaHDKIaNaK/J9XeIpZGJmyt1FngWAWK3lQZ2jGGJGbp3RsSqE+NPjFKM/Zg80LplGY71XsnDmILSJNtyweozR/qCxQ9FbEfxWj6FVt02Dj8JFbWznTrHInul/njVQKRkVeJBEopL92bhVtAwTkm1mTekv5TIOE37jbqoYEoftfT3TfN9tVFvBf4mUBZGFwDz3wmlQ74kN/dHcDF/nRNRQoko5cSTp9bEtTxMXQt5PeF+n7g28nvio9Tl5GkcCWFKj6SLoD98EBfsK+UV6yHLuaYiQa34WuoXjMY7jjFHhp6ooDAXDa+jJbJTBDaPDSxaykqvA6orTk2Og975X8k18qEcG7Et5HUMDT/MwfWUwwX66MhR1hLYvQkWNN0Vf/kNJX0CHGEPLSPAbyayRxAYStjdmAH9hwQvnv4p0NWfAV08tQNHlRDsMRjSUl7LJPBQ63fm03dQ4zbJnBGwhFkYRmhJatTL3yNaZHMqTNmFUksPROAMbHLpgsZCNC2+2szlsymAXhzbhV0VCJKF7V8gTlr6sua74SdUgHrHeRxGWfo0CdzQivcKp1e+1OlhkcKNYZxKxgN7dwSdkiUHJs+mZ+IL8xXzw+9jZkrF21Yv+ENQxRQwS1OcSACEnJZYFPYkTCe4SLXSOfHFLc2md0l/GJQe4llSIl8mD6U4KXGXcqyLeJi1rVMU/v+hrOhADxI3U08F+gyr5RZ9Edy6gflFcEu+MDIJLFxbJWERCTkW0QSJzIH4VPTAwI6/chp+DQT6XMDK31lBd74SILfLVfohy/73/KqLAxD7/7cSAU4PVy+0mJf2UIlnhZ7bLsY0Y+CXxQx1lZK4NXJ/6RY0CrRG0G0qI6S5ocByqaYG+Nrv0Yru6zQpkhSctOLc1DsWdicbi5rBtDtNCNOEL02oErn6qNCusHJez4xUHrGlX8IgMJIeAs7cO5Cog9adb/V48Yai8pnpCzP07mg06J0/VJQCf5N6cEc0HBiXHNgprM62SLlCkq0kGCDcr0SvUlRrXjU3t6BZAstYTlcbzTdA43WSvahfjTDqp6/rOYClFZHWSyKSW1/KU99E8fRFKMZQIMCVP52LGM2R36iAXte4Xl3HuGx1ls02Cb1ddqreyB9VqV5om7QYaGenyceawQYqGmPmzxaOEUO3M7XXje/tdQyzmonFmTBldOCPf85ieZNcR5OXdTTIdTR4GflwWQUFyb2gLDafWqD+V6WQliIxLo+/IAdt8EJiDxSw9j7f/eeAhe7STJD8v+0uvV+zGtML3aWNSRe7SzNrud1dWh3VdJfOwfK0u7Q51jIzpO7S+4azYnu/yFOxvV/gptjeL/JRbO8vcFBs7xd4J7b3i10T2/s2v0TlqeqUmH9MPBItj9Edsb1v8UVs7y9wRGzv270Q2/sFLojE9XkvoL7PpsczTYvD1TCi+wuFJIiG4u9JiPUVxc/+5zv156T/Rf1Ju8mUbgK9m1DvJtG7Sec0EBg66dHIPTM1L3lHWkHnBW3gDWlBh5yZRdHZc9Kk/zlI+neBtRkFkfZEwLP0RJ7ngL7pp4f0XlHh/uSJKufK+RBJ1jVm9YxO4CPWxdz7+gJPdyOs0/8qthFs1tPDzj8Mz2oWVQnt0GsfYTX9uLl55ytQ7MHZxeHR6TvTe3yGmRmQWr7W9i57Z0C7Fz1rge3DJPwcRNCMBg4cXhz92skXvsbclV9rl929dzk/dAz9ek+Szz3g1I47exfvj7q9s4uPizzGpblL8bQuwIsoq2zgQ1RillhQqjsrD0WBZ/nsvHOK/+UezTk8iksuiT2lb+Wh6DuHZtGFhtlc/Wn+3KhCrS+ErEWtLoFAjIb1t3vHXeHerb0BzHb4KLaFUm72pF+1XKllfKvNGGa7kzHfCsILl0cS6835TlCcdRnp53x1+ZaQfsN8B5iew2JnGFXr6Eaw1q5je0QpHIdx4WbZONwj0h9Z2RYmEtQd8zynYAN/P8e1opB/5d3yGJy6b0gmzpWfArzBRCTQDC7djYgD+2zvIU7RpjcPI9SfNfsco1N9eRhspq8dB/kFXnZ8uxr+dXwP/iws5Hi14mPHYTO87ATIz/ezE5zIVsiL8pafhQjbWSNxoUKoo0OD/YW1uRjDNasjARv9WdjQDle1MhLAZPhHKzz8p3FhywmusGAFQsMzUoX9+V6R6sFmVHdS7jCX8Z87VC9w8z50X60+dNpHeT86+fo7fOnUMSz+dF+t/nTaR//5PnWKAP6f7FcnwVzGt04lwJ/jX3cbJ8Af9sZjBAW2UtCfpIVFirSd2DB9KLpBZv+UiIeySWGyCEADyzHGuza+zOe5W5QkXamzUc/nRVfu8jnnCGtUkiX3Sfg19dkSOEuI3THv+PB/1PZoeqAsY3+0TL7YBqlwGLsdMucDkxWN9ix7pG3cZWdO7ZJfF6j27a8Wvb791VTq9SeY6+CrTZ1vf7Xq8u2vpiKvP6H92VT49leL/p57SL8v0NzbX3Nqe/urVWc3H1OFvf21SFsnJsgktJggGb8L09N4GPyti1mneGb7bvfwHH7PZ9HvEbCL7gOcTZNO9JnkItcNYv+Ac+0ySqfBILwNg2EpAYEF9JpSEH0OkziaYAFQemU9TeJ/BQPgB6N4Nsbk74PxbBiU+lkJ77ezUhwN4LMwGwUJfAAg3sBuuIkAuH+leM8tn42yydhx56M4/v0yGhH/wOFFgJ2zS2Zyx86q5tingLa+D8Gnbjz4PSAJZ4gEsNx377Ns+sxPxFD8XGDf4x3x8oPmPsZE18t9jit60o/6TPBa4iPpU4OJ3571ET9invHh3PsjIQdEEnq/FhjM+QGNSZE6nH/7f3jG05P0zncARUBZGchdSIGYH78UxVnpUxBEvDwX1jmgBD/7RKvJk5Rn9OTFn/sPH4dflEQQ1GJBI7WrW9wU28fTnD3cpA9ZS+BwEexB3inMJrqg51SSim6HYWp/AXsseTjEXHV+Y1Ox60YRpXOSuk5NlZHc7w0GQZoqz34PgmkveQBhXSnLXjffYU/xLDsaKl9mlmeI4XNoD5OdiPwZyD6y8PZDnPyOxjXORIbBZ5QvybBByhtH2PQ8ToUVkTw4AOnh4QwmL1A1CdMUe/s290Sx9DTbS0Ad7I9FbbgVeUNiNCc0dpmMJTbJ0crvRWbJ+Ci6jfnVCJx/Y+AgDA0nKZxzN1GQ3cOUxDOeJmb26SK49X8Nanfj+FN//J78JlpakFQq5vBUnAlqIPHBT3fOnH/YxtczImhEndmIOlDzcGldzY3sxQu6lk1PaPLKwtYwJC11ECcDXsiSbUFjdQv11jkTo0kQZap7xfjOBX3aKpEaP/Bv0A6x9G3Fd0pl5B2+Uwlrt1gBpOK4+ZRmKJ8ndIyUbUFZEFHbrRlv1JO7VTZVtzBtGaaHdFviViOWON3oLD/Yhk2f+yQYPvEFr4anAqn0dJ4EZ8kFUwkXdrbjN9g3XBPjTfGiCrbXfdmt5jfvtpXuWU9v4wTEuqEy7godhBagA0LWdDFJ7OxEB6WBEzx3hDM2hHivbcdaf5aN4KkP+4/9yVaI71duP5nrTy38ebva4DimuwVo5Tj4HIx3MHe5Tc8jBI4lVnDo0gDQDn3BIUD88Uos6yKHNInjjGxogrEIJJaQFJy10tR2pv1U3DVMgtTaSTfMAKQ+7EU5lbiPUFCp8IJe2vur4Br30op5msFzXv5Qf+oDE5F+jAomd4iDiYHdOtcIvgmm03rwAsY1WuT0ZSgThyvscPQm6Q8fSmKbOHPMNa6fjGLaSSm+LYUuFjmSVQPIsPjC+MrNH7GM+brtrODozZHGup00CmYTpnIiJZAv7DRScbzSMImnU6QteXqjQz18kKMoj+pYWOosjiRHKTuMyhzvwVsAUA7Dpc9hv4h62VhDMcopsou2gWZScI/v37LrFu76oGi7B3SfEOX5ngpFQpXld+psZ5fJeO9BXYChKs4IUQQPTsJolgXk0YQ9Qq5Vdv+yFWyY9RUqzk2d3kOCANWDA+aAzu6tErPrS/ZYydqFstJ2wHeLVZIKCiWp1VViuGG/y0XN3GJRLKVTxK/Lrr/zbQmZTTvIlDqnS3JARBVSFhP9SkBJg1EwBPJVz0J+DA8DFK7L3drR2U3n4uLswivqAG1LnkwVSqVyPcZBPR3Rk1cNXLSe3DaRnDCqnXrO/EenH0TpjNfjpjlIUYIB2fViFkW01EX+o/5weMB3ElG6iOlKBYsDZBgRLftqnvmar16eOBv1uju3Cwa75fygVW61FVpBWS0Eoew1123Z8FVdZ93m9Yrd55EOjFUCTqTyNybyIf0QTQbUr/tSGTlh6YrxI01NqjjXKOLlt00eOHcJbchUwTgGfvSEorg0DSK8wCyp4JR2V3aFxLrM+pStC7QhApD15013gXRTLjrD8MCi/Ywf9E3t6cDfh+MxqMpSUS6lMTwuWje7ZO6w5P8Y1ZYFLX4IaVOxf0i3uvmdwiTgrCsTncGVdmvcu7CJDsQsZOBPjsfIerS1Scr97lW9x7MoTu0i8Yh39kBabPsNvXeCerQ9SKnHuw3bdo69gDtkbpsKeoTIGa2n7ZQcoecgfIZpUC73vTGeFqH+dOTNxBlikZFGwPvwn8R+6ix9gDC+j0tBihWC4KxvIqxTWVZkxttQERqX+HxOThL4l+KC12RL24uXWWMqCaYL/4HLbnb+QEDjFeHEfaLZLFavIB5WV1HSoHCxNwCP1krcFApm4n7jV7ak3ATQmTisFHOZdmbUXdPkFXjPWmMqeuIOlCLmFdmLwAYYgeYvTc6TcNJPHsQRSsPHDUWWZkMwzr6GcpyHzz7Lw6KDPOQHdgSjWqVgpmma8ISGLhfq+NVfM70lLLLDhQsEgTY1kixUsLRlAF0q9UNDlwrzqk9o2poSSWPaSzQ5JYIWhVoQoVqQupEwvXDi0+wfVjvMTnVd136ZILPuvsCWqISxg1BRJKYVWQ7V+z3TBNsuMswqV5qAg8BNywuWRxIUrNFkCp/hGrlako2cnck1S4hKJG26L9mpdpW0RKV3lM29lYZkcXlRSzM8PWPkoUIMhnShqKkpwjAbMx5SIFuwxQpl1cYbUjoa81WArudUyuQK+SjKSFSVW2mo2qDmciNt6tubwToXleTTV37zBVjWZienFEYc/3IA1FUrTorTTRTJSZdWk0L51n48P0cO9laKie+5CuMFEYMNMRmlYmN28shKiCqoowQXeG61eYj7sbx9PLDZx0PPdlBXm7uW3bRRpBJZGdSmrvSpuqjcl7llAHx+vzrjGvcx1k4zw6Cg3964HhUxihd3BasiIUdwiqlcWWNaJRxF8xB4iTj+l+C42oEWSI4Z4uGVF0/b1ouzwqNIP8OxapG0nJNZ5rfE7krDpnvtVJtWQmj+kOVYEclQmBUFXTqEHSWgKgNeWZLrSrx/CT+hyiaYtpTs8oZCtpDE880rNEZoSpPCB5RUhZSLUH2jHegKBQYucf5jHpQik03456gTQxVaPAl+hEbBBMZAN0CEHFHwlSluFrkiAWegjcpWoyspbJpJuYVWRGLiCLNAAXe8BUlnVCbSQqAkG7AxuIbuXEcAmRnA3kyTGO+Gmc+bB3Lgt3kxeXhqqgJ0atLVpIBL+hJeYhvZOz960jGViv6q7vPvnpsyOuNJYS3+9K8b6rhV4/Uba/ejMAvO+3dBSgRrW5OHYDyO70kb4bG2q1e4Xw5m3E8eaKyKnW/Rkmj7SD0YPesbqdpaPhHGJ1363n3WRW9F7X4opslX/SRtPa+7zXrdUyB7Ah1/eA5FLblSoQHU6SAJPwV4G4ACJ9pf+riLMWuRYqwVkm+R0+dwhmJkiU6pFEQzOJeJ+gann2CwJtHaTdDL0S2DDeSeuakLmCj4Yy5sAsr1OvoEER2FcOw4KJMzh5NnKonfP8y8VOh3vvMuiIIkHODZk84+8SDGKTNZpfwOZx/jHvuJTAPm/PMrqx99O47hZKbRkf1oGE/K7qvG1uvXr5uNTUUmb2zBqnz9p8O9CyYdki1mPx4+KI7YRbWK/0ocB6OsCqfWNE5DuhjYTRW9VtuliMSk/RUogboO/Oa0S+hNQJ9jReT/Tf6Ld0IOjRImKgkHZF3XYphvVk2JX67aEGaU3gZJlQAL02iVABrAA7SB//tNVEXOQxy4Xlr0zqlWHUwBUfD6N9p17F+lwCMiWN2MJDWDP1Oai5MWmqbetn34b3875pfD/UrFHVf8+Kp/zR8hZkeEMC7DKHuzR9x2x+zODzRrSw8j9EMuYyceiC5Gf4yqRtIveR/OOfT9ChJRtE5lh5xUnXednuM5a7dAZiNa37Dvj2FXOB4ROxpScdMOi12NDSqWi0xQMmwkt/W37tkp9YIud/X6dzX4izFy163hkNwvm+XRYa4uxmZaacAqgf4Uo9tR3x/4Oyokivg28LDIejspb3rOwSgY/F76JFBSyrA8JT09x4vQgonbaM476p5NkVInp+fYenr2hY0feR3MbxqTawk22shXMFJQGnCsocab+aOammCvPaulY5Rr6t5r1/edX48ueu8v951dRE4r8/0Z/lVvlRfO7NMDNTyuEa1BX39i8Rdz9ZSJkgKTKnwiYx0I4DgqLo7Wt0vnfWfkldPIE3Pr6HP6CBPqvj92vAnZEhPYDpPtO07tE+5tMfDvribXuBgD38/cGCuNUlPfbRnvfu2dKkt1FoE8H0dB6SM6tcLCVbujMECvWDSOYLkLYj+gR0ZpgjnYiX/GSrq6Gq+ucohAdlY67cVxadKPHthpleZ6INRTvDjR8uuhE95BPyIXHITayUeomPH9VKL1JOnwL6DDUS2lyrlDO0KifnyUTwnIhNJzENGEigogQ3Kl9GmWPuANEuuD3CO10exKcmQP5Qd4bLANNPV5vsLywOu53wY7cNDXvR79D35cKTffvBqswRPAlaUj1JcHFefv+6U1+KuHf8GiFq/J+VmXLQqdd424PZOMiP8KyqKcOIghQu/A3IuuN3UXrtZbfV0UbX4sbx7+T5PKiu+QNHEqRVzSyaqD8YmHLKkcf2FSBsJSA2HtDitnQ9+Nen3pnrnpV5tZyrlIwaxCLBesTH7g1jAw5Nb/Nhe2j0Pc3ffu4Ypecf726vDav4d/KNUeFAkWpPeUyGPh7UP51iWAJeX1N0C6/c8BvynGcEBaWR4W9SVkSrbgDO3zt+woO/CoFSRHJo+PCMAvPxgAvigIwYLBXXWHkOUjOU8REg4BMGyiQhBOnLpJeQMYxlvcBWLlHc2LJL9n5Lm+lgQoFxCFB/3ld43ffhXIbF3uqJw60R0HwbT8Olh3ydHzLdZU5SeO3efA0ZTSB6XarqmtNYMNrwckC6cgRcoHhAOtLUxvAkx+CpBgpSgEO2EYk3Rui49oyxEM2MfjF0/eb/doWfwEsvrv8/vHxwIkbaJjDajz46C8cr+6asK/PUDuv7GZX0wy4VvfYLAMlspmo7mzA8z/wDv0pXnrGYwSLypGQVQ+whv72/KRJu9QHnHh6+LrkcrwvBOVS1y47ZP8oQg84UQwr+1mfRdnWlGera3TA6uT9NGJvoRZBsN4lgo04MlQvn2lfFLFtI9v8DNxnN3S46xV1PtbBg+JGVrQc7Purr3esnXtzg9Ue+KhR1bVrVF9+Ui3LhZr8pJHI0SoxR+5nrXnOddAjLck4eV4aaWG/FhNsXC72MyakfHAZEW7T5+TpFNHU3OWOiHnSoijMB6QOkfA8mZJoDgVjPrpBYsoKSuGEhFlQm3ZT2t4CqtRtQmKHvWJn9zjPbjkNsaAmbY95np2F9aIREqRmAzTaZ5GbswNb1a9jfRbpfK7yy0U8BVrn48vmc/b9nAQYFwYe/cpNBJC/Ro8nREqjG7jvwGClJs84HHjiYiQiTBaTv9FhlUibT49RCzCgvRC5jLp/x5c6NYimp0Ulh3f9z8BLYgG7GEKYFs+omsfUxD7voPRnGvTcT+M2kC3SJOZ/6U6gyWuDoPbMAqGMvUunx+/ZGE/6STNh2R27reyRAO7ydE/Y75ypLXZgHYhL3wRlZYuVNxaOsgjm6vyzppx1T6MJ4CISuCN/G/Ol+oDRhU4rW+TIBvFw1bmATNqjedzgRD+HaKLTYQ/mgLxUFzf+YVmtmZj4/XGm/Wtjde6oQ1+HIM2mRz004AovOVKxZjFwg8YmlTwKk5L3GsDzuRPFWBv6mfkzdizirmj4AuxxuhvHk4ON8sT1wSi94weuu/3GuVprot7fyABJXMnP4fk3zv4FxcI/uyBlP3Mwe7NwdqjK7Hk1wRlxPSYQ6SntRtQsrvTnyq0SElQfzvwh/qTP+Kp75C/9efUIJQG/i0KryGnpyIFhBgZYSK1T/Hwwf/GzactFo7lfdraGFDDaOtTFvfLd+58nvlMFI99Q7sY0W0yQ0GKV8DZBelqRsw3ATzm9pKZy32mAMgV5YgZ+6rvrLRBtxeyE4IyOIMBEVQ3aIMESj+F83jcgjcTOBdDOEGzNcWErDaC6YihDWN16I3dnJXeZLF9L2b8kh2sWfLwNmAJ0ZRAanG3ik4PXJox2S89VJkgwRxBd74FRX5IjkcP/laC95z81lZrnsjm6Zy4VtocDTmb0t1JMuZNIrwJeRLuRcuRl7+reqsUI9R2Gk0Qs555YUw87ErYEZEuDMdEraSAWARHNKe6eWIYHROW0GFXP7hUwZs34XeO2kRy2pK3EEWqQMSPK+msWdzWBdFbhTzFrwtmXCCR4VV6weTzkIg5uyYNEGJZkZnqDKcMrme3i/2QuNP7kuFZUlsndhixnqhdSP9Fi6NKsRukxblI9rQoxnuRQyR3KZ3nLx0tLrIrPlntRa4e2TNjwezeZs8BnV7MOU5bi+be8eu78HS3/4loOeorxRGvtUwk95I7/WwaoJ9vaZRlUyOoDv07ysQxyTUXXJeJF/BXB1rWoCl0I5ksrprNg6iISRVQ6zlXr5meBModRlukLIgEzx+Fb6nxrpJllJfhM7a76W0eYmD1GDf2sbokhNF1PgcRK0nnJXCe/JlYES6zBchQTyd5sv1oaBgdyLXqP6TIVlKVm+iL9OMZGgeCUXVufDs3s/EwWDbgKqGaMD7PU4grSqHfWLGj3WKu//i4kt+DLg8v597YDFHa2rVNAUvXUfOdFinAL2N+AfFPLfCzWOgdrbqS5nIgWDfnruKx4amRlbnorVnU/wxUgqW5gCI08RElzSLxEcZmonbD9Rhvi4XlzAAmLb8MHBHMthwzZ6kf4N90NhgEwZAcVGLwgvuL2HXRl7gce/3nOhbKAek1DW6sPk0woU8Z+6YS8dx7eIkV5+aw83bv8rh30zs4v7k4uzw9vOldHJ3fYDIrf52feWqjk71/3Hw4Oj08+3DTPfpnx9+gJaFZy4+wBGpr7Ofssuc3RW1TbNHArPeXvY7WZEtvUmdtukYjnmjmsrt/c9Lp7d1c9g7wLYUm9/bw+O3xZfc9fdsw3+4d/P3msPn+5hz+6PRoo6bZ6EP3Zu/0FHBzwAZ5U2nWbY0ue+87p72jA5KYn3X2xtKQ0Ch9v2WD6PL8+GzvsKABfE8SZ92gZp+fEby++MDncB98SklOJzVtzmB6MOpHIsUAZq/bQ95xNPQ3OLS6m7dS6HYSZ8GvQZIqWXrYUyM/EXt6SowDIiN3pP9MgxR7osle1DBx5UUUqy/wsKC3mXuD3/cfsiD1r+rXtpcEcNu7C+AdxV9esPp5ysuZeCEf3t4PjcngExu+8bmSq0PgnTwfx6nIw6hOU+Kfev1zmoTFu0DFv5eEUwLlk5tYfnjS//IhjIbxfTf8avvQ2NgKlAYwNNUKOW9E0jCaJEvJgKXLCx+6LcbQ4qgwU8kCpb4QIc+UxsUCqSK5IaaYBgRxTN3zyWJvZVtemIoQy5+INGAaqQBnsQ71h6cIXEBLeNUiMG9Id6LLGma2S2k+dyZ35ma34mfPNGAcobsAYlKMT/UBvEkV13I23IpoRb6iApsg9pUNd7+AGvfcgt3gb7j2F4z7F6sOGq9yhUNUwTB13c9T41a7jsQAeSDDwLV2LWzHaO5o7Yy2Zdqpweb8jXpjdxEdZCGIZVx0WSLFXLhASp57OXIh3OhHEovEEOkat3YQfgYyfoJaPBKiNSN3vcVRdxrZvwAkOSyBbphTV3J8r/hQVaL26ot1F9jLkiAGjCPkgXHUpUvi6d54fE71byV9gPu0WcSyzPSw/VOWmXS99DLLJQxqjFWtrpZX1kodPLgOQdwrrdUyVArE+0I9dcMtyCphAsfG1nzjl9hKEoJ/x4LbAgmWWOVsUW6f4ogvawhULtHa42O56GRXY0tpwjbuyhDDSWnuK8sM+QTMdG8uj7qczrJgD85Y0+WZXuCF5N8g76P+xDVemruDi03H86tystrc3HR3dnbqHvy9tdl8U8dfb/BXY+t1o7FFHzS2vAT+09y4dr2+H1WKQYnNy7i8ji6v7vp6W7cwA16pUF7zeTI/TURdoe4RPJ+5dhwjB0gevulx4MqQjEHo2TZlviqLQFxDHd8w0wZ+uTC8pmrTQ0glV0zHBmI4oHrdw3ScJFrL99/QiqL0vr/Rjre5/3U7rlTcpMIqAtRuMVf+qJ8cxEPQ3K/ia7edc8mymBJVuFmkhJgb0h1AtPqagdJ4fIR/m+TfX4gMG+2sKxKeTXIGLnEZ8VCW0i1W2iXsk2lrIFtENKVMyFyBJTixLE/c91UV7yoi/t8r/afHPsSkR3JUdiA+MTidLcwwrlbZ7SkitK1fHihMetN+fhCYqk5lhrkiNEEBfRVrfaacojj2rHOpuN8S8bRDY1npv51Kv3ZDhGpodt9PebIklV0VYI2ozaMkjsj5po3glbjn0viBG+WU847JnWJyK/7sx00ujNIsoO6+vJUYiLdeYnYo6oNcMMhYL3QUcgTBJALU5BQCkXdHLHJEcery8vE83EExrjaY9zKG8BDPM/oncIzZJ5qzv+HF6H/Gym57as/+yDO2mrEBAA40cJBW5L2C8ufSU7dwtX8UyrsL6ImlpgPZQUS85ejJVCrJfLN4HxSeKFtd7RMufB6n2/IpR2tRnCGe74BOCk0/K+HEWC8wsW3y2+yrWJLpF8oofVVAUTc91jpW7nz/8PpKQGDv4JwzKyZxMCd27GKAfpVx4tJYR/G73OcRjHcignFOMSUgYL4nBtUCqd4Bo/fLze3tdbcSmbI1OePQz2TeLw6/NyYqxbA6d0FRCVx4ozTWyT6ZbdfdYnTsAwlyN5rSKCBOzNT1eqEvjTag2HbE1cUb+nc8p0mJuh8MEQW+c/Z3x/2mgkKzSk2KwPdmlSaN4mtPduDvtjvzJ94TzScoXZcnwB31bW+HeAKfiL3AwKwDmMUIU87cKVo1U/QXUoPvJfYmvsjhMsQcLm211wlT3sOW3v/7Xu+cKR5O5Y5dbCBknP81XG4T62Po8WUyRuKR1L/7vKOU3wLqp9oQlD6PuOjO8PpbAVxLGgKbmh59/C4mcpVthOxD2UJuq2+kB1vqtBT3lMJmItHlKpvRtI8xjwwqcmzKgo24EqRmY2mjRaqmsArzjcoTRnyhzug27eyqeW0zdm83hFcIEkMfRNer9evt7Q23An9twF8NINf+jkxpmrO49l2LZTy72rzGHraghzekr9fY1xb58w382dyQ6W6n/i/t6fYvlWa9PaVBBtnV9FoRjDRLfMFmV/bLL97UdVloAj21DYa34bZVn7YL4spJigelZXH7Ts3gY0x1VB7DetCJjAGRbCJjgimYiP1yoVAHKDDDrNtDhK0rnr+RwaBR2/qyFDz601bTu/PrRD5BbrIJbN8bwRT9TfhP89qfeTmv0hVy08xZrf3WhkXrqVYDqeDmXDDzjqv5xc5TlqSaAcxgsD3l6tAAA6avfqkMrv3p1eB6PoLV8e9QyYU5bcCfRLkdAV36yvqy91vaQ2zJXrw2XzS22Js35pvmBnljOztHjBpJ9dHSZqvINLvirz8+Lt7rlpVXvbqKblKWVUUrjYKLle1mfeMNZ87mINuvVfagj/+aHv9D394vFm9es3+6s1Mv1rmKEmP1er5IW2r0V3EmqVf60FUbaLBgwnDlUsypDGnSsNLf99dSx/WeyVgVvjrxka1ylvqGyBvlyartjtMFAX7XiL9YqbfMJw3P+r3cjO4Kt/NPfY03Nn9xuWP4D92kkb49e7A9e9sDvj17lLEPrnrXK7BBe9ei+rp2VwDShvUO1UH48KqRpopg/gNOASut6zZ08/WGrlio0/ORzRV8RWWmhVCruIOu+sNJGDm8GIBYvd1lZggaO/mcT7Vl/egcYL6PE+KqhNGSJZIuGdeGplx5Aj8KV9pq2Wamk623+HpnuTWzT+RCAM0VHy0rcjYS4qYFhsJpKvN7jVxX3a9SmRbbRH+Mu0SbPv61KcWYLXb694p5rORfuTt8GGAFtcDBTpEHAIFswUt/4BX37fcI47n3B9VCRwGc463fqxb5CjBD2+32Zr3++Hi73cDEjffbxC/Gpahd1LcFPqVnv+dNRfDhwafV1ami0atvygNvmlPFWYj1PTk+btumQwP2X3vzyvK4Ult/dYBG72fpH5iUPNFyYmudKsdEqYyzxejKe3wqwilTVMCInaGMw7vKJ67DtLuXr7X3s9bhCT2LMpi56aZZaClOZ1MMiYTdz66lJMKtlx/uEyVERY26UqAWE9VuBWgx0bnmCdGlVv1vujDHaCNn/P8TfBQ1v0IMEvR3vlEFjfvQ/VZi6Y+8sWm3H9k0AVThuAtitYnJUVZrDigN3O1O1zrqrrvQ3l2eMTXcL8v7kb9sBWqyKXuKeUWVnwlVXilEhelvhELuR/CD2g/8AP5kFjpM4EyZ9rAgOIlHz1lDh4ag0fp9EfkE2Kg4elYqHrTkqfFIw8pvHOUzsRFMda3PLSATsUVkY2IBnnh95ZXcX36o/KAM4elhpLw1hONuuM2ft4cgb8nPr4ZoMR6w+6G9rDykETd4fzPTrEgzzYok96M0iSckj6Jco/KMb8KhZndcETFJixyzcxrQpmmy1W7D2aKPdx3p8+SfXh4fOxhypSx6bkD4Qq+mgh9M/SIodml+bypIiAIKerMWD8dYhsSZ+OMpvlphSuo1kmDISWXqzouXQl736/UMllmLEdmu3PZmOkfy0nnKox2/0RQane5HKXI7abJSQuSEO3pV2b4j37TdO5/9Rf/jz5RTTn7pz9qLzpCEO75b3snquGqXGc1S2w7a1DNeZ44/niaftFgGS9CAg6UR1MUPllh8aCQuA5AO5E8s/CTvAjDMkywEBo6G0Sxg0UQNwTzu/IAvG181N6xUyDVrILgIwUKwxMWlXYoKtUpR5JaS3Ul6BproNHnmdnkdZJ1H4gfK3ZfH8sUF/KzwYj8wxRZM3Idzi3eajbqwaujHpY9piHGORG2A/8Y+Ni701wW6E57DeSFNealIjtn1y6wiun+fdTRcHIqDospYxlskQO1Bsf+MdSvOC1x5tcs8fv9UXYBFj5uKNERx3r7AkmXDA3D45qthpVFvblTvKsNXEyaU4+pPK3c7T7oLAxucPu1UXL1zven21gbPLgWDvCo3mm+qU3dtiMMNtpt4YYZJ7v/NqzIQCxDvRJUpzmen0dwg8ypP1+BPVEdeNVCTjf0IjyHCPqPtuM3vCxuVuBq17+A7FP3gd3OTW/Xuqo12sroaVYAf5PbZ6urdNrTdLecs8HeVhuuhbd1/8+qXSgZ/3l3LfYybuO62LJ+JjxqVDC/PUaBShhVmrsgDiFwPBokq/tDi60wk/LE7Zzb3quAXJO+zEDQjT/y9HeQvlxl6YLVHaxaixZW/Iyt/9xNW/k71aIE1wgyGeZQ2jXVoqOtQiDeETsqmJFAT1YtljqOi23juCEA/kQobujTe0YWaqTwgVyiYrhzVFkhJH/qnTHywhk6Xg0+17EvmuBg6y/srit1pWfoAeO9YDp2Xd5J8maR3390HOpPjhfHL++hn34cMzE6Rfuc81NRx+U6s4VJWUETmp+/p5ePn+40j6IX0gXLzk73QrWDdpHegaar7VAufxJdzb0aLBQRo0IyWVqaXujA3ZCpigCo31rCwsyqHuU6lnIC2w/17Aunf45W4oAXKkqfl8icOYA6mIOCFatpcOptb0hmxenArK4HqjEL2q1HuXBcvWdm1nLsK3pdTptWsZEVcKiwsKMPrYEsBOAUBmOo67dSnf7gJCMC2utdLi7EhyQPLJui4c5U21DIOxtod8pq1qhse1yf6txkmM6bdkIBkRsSKKY6mzRIaFIw09zaDdUJqTxrheOUG4rzBdwi6SaK3FLUA0PJ/83l+LK3wn1TIQDSwPqYEo605YdxFitCysKmKUeFRlIBm9MQROl8cpvCtyDV5xW/YXJO5Sm0NPrM5F5ObEKvfMc3PI8g38+vtbFtFL7cDZZWKK6tZm4pyIHatu2h5Cp2+1O2sscG6a67qs7RnUqxU30xlqTOjwuwu1JjZGupUQmpBY9Cx2dNS5IJlAXjtFv793+Iw4rWS9FIaeXtS+amNx0K79fJdA5qM8F8xnvLeSoOHSenEkNlDMoOiiMywOAiy6akRdglnUXb/+92CALPN3QKWnNAAuFaRDEjWfdona4Me7SUYt7R3flQqp4sMcYQftYoBXZfw0PsA6BIvJ89/z74DJBxKA8syNuWUngxDW4jRZUJu1YVUmIz2vMy1cc7acL5ASLNoEOCcXWlSM99Ik5kGhZ4vIlvKSUl1S4PN+hwnLHTgE55J6Aznb3h4c4vkiX49dqvJzg5zwUF/n6ImjSa2EZwzRD+o7Y12CHwyu9qshMD2rsJr433e6UFouOF2s86+/gW/tjRV7O6hHhUjw62XcZgr3rXrC0JTeJG3HOWzOORnuhs9PuLKrJClsSpzv33qD6vwAGOHG1hCoxDquho8C4sMnWLvzeud5pM9N5fvuchrp6zf7i/2pjGtnTaY1peGybbDrL1HcRVaVe/T5bomFIvlUEyHHxbbY5wQhMophadcYAh5pYWYh92YXkIp7A/qHUT+WugVJAicyioxjBWLS6rV1f5VDMJhgtE1GM5EbbK+uNyit8co7O/4qTC6PLEKGwRVNVBNx+W6t74oamsJjCKNPPo2Ry3vBTuY1U7+0Wil4VKI2kiNDkOOBPiNEL0vQcLmd5bKE9RYWGxqPVjHXOQh5i+Xqli9nQJHTpkrsCqUptc8M2Uos4+HlkplN5NwkMQkB/lNiCmBo/64zDORwwfJTiFQyrH00hJ/35eoyXLoFgRuL0re5IWGW0B7QRImQ9oIhbgifspUJuTKMeS6iaJMsYMtrAG6J2FEijTnbJbkW6WB8kPrbO79Uq//kGDxQJyAYXoWjcMoKD8tra80WnKh5HcA1iCh6Yj0HETCmxFrLgRDUUD5ZmDJgtLtHp6T0nz+t7msphb0h0qjj9jo5vzsouc3ABPqw5ODvW7vZu/w8OKm27vwneb6LzUQadj/6o7a9vLi9Obj2UHv7PzyoOM7MOfWA9a9mc4GQRXIu0XLBLRGs0+thvbl4VH34OzXzsXHm5PuO/+3k2q3s3dx8L70qoTBH2uNWuN/k/96f9bttX6rFAInE//K+RAvipO905aTpsNpi+yCz0GCpcFO/tHahP+YfWqTkE4Ycgf7vJAU7PXP8e9SDma6mfS3Zi9yZeIG+heSEBdntg8jWRcT5vAgAuFbDubpI1Q3m4XDXky5t7yyhp2H6RyBO+KVJS0i1k6A7SWVipdW/KYb2GN7RbQOOePRCyr1mq4H5ww9C4BtQj9bP6ifN9/VDxr4Kr5TdVD+kFbW6sHZ27fVTgfTfm3XXSUxPhvZf9POiNQMEnMKopfv1J22SyCibQM+Vt17Q96zilh1B9Nh1sX/c1r8Jyj5FT/kn3Ght4q1Hyu+BB1+MlJ6QNKjBclopVBOS9vEnBH6jTfIoMJXeP3DstwWh3zwKnRi66P1hdQyQftdRjgVcZeH07826X/ZA+U7xOLBPnEq3i2rxGoQecrS0QJ8pLFL/+MHbmu5r6gtSdzPKvKJQbttkQFTm4j/jXbVijwYtxV46oxaiUfng5WGF8ATcUDcuboC50heJ9QcoewezoNKzXq9dPZ3splOz3pHbz8qDMqhkjCJ8mPl/FIs5IPXYSSKzg8eH9lfoYyzj+BgjbYTLklFQiAGQTW65lGDLQwb5OX6oAO85UuvYoyBg10yKbvXfgw6DftBC9fUjs+oJgUHY+2yi/+5cg72Dt53YEuc9i7Ojp1r9krsliI+6O4w+3jk0w84XI4Lw3qxL0fjr9bgFeg9fRnxlx9eSxuQ2wMRycw311aIVNojdUX7zCyaK85rOEWrR569Ujd95+YPRynvkqI2Bi3qeY0kiQbX7ZUQhKRqqG22nZBtNdzPfNfVFxFpyDcNk4twtzGTOofSektrR9TcA/nXVXHZRfFBSxDGBArOJLu17uXBQafbbRviReaZ64bZvKjpLeVCEnl+yA4rcaUkZJZ6ro88yBqw8VTU5XjZauYHRKlSQC3t24WLHdgY6wrs60CubU47uIyS4A6DYhNM+hxQphksRQGBRgGBRgEWuU7Kgyrm5BJ80y3468ReT4fvshJKjfr2dpbHFNpTz4lZslwktZmSZLEQiYLtu9Am2MrMdyDoJMGtcGMaZF+43Zm/4kcnmvNAVNjLskQqX7qzHn6OFafeBRHPu827oWIDK3LD6tw6bR4YS6NiHb5+wfAyGTstIRbwAJw4uYMXJPLDkeK9vS1L1Ecba2nZZVuRm5m2ojcN9FRSWmGJG/UVUDCrxN3iE5krOAIO/D04ykDuCdOj6BJzMHAYqH6822jV82isNkw0cs1GmYOu8JCOWNML2LZYPVNFi1qpaLfeatC2umeG0t5MhKRgE29xbKjE5zk8VhsCj6kNj2Yp44WYpCgj3n4m5ORgMIEGwUovZqRYGLSzb9GoXAFl65XVjPJIravr/G5S6laoLMq+3fKEVvy5hRLz+KVotXRQtASyNPGNtl/LT8yibGxvtSNLBSm9hp11WZQONG7wNCQ681A7UjnF0/3o5R5YN2z3lp9YlrLc5jt18alpyyj+lu1x9WO+l5f5XOx72QGsuOF+hbRlp4myuam8TEWj0c2T8BidqV0p/OKpXiTLyXUgePdTS6odAmo3aMSl9Qp1OxN/riBRNBUWJP7Ez+Z4uRgOSm8x1ypwEINWuuR2nj8/4rRebbjWD48iEuLyJVO4QFbchfoiZy8Dvmb9UGNxIFJ0skW2MiqKk9v7DruRppsX+k33WdVMKUoprzAcSDwXlj58J9IQ3zwAGCAe69JYOpye9CNYLy0r8zD4nCqNImMAfHCKZaTEk1t4QuAWT/RUiw+2VItOFLMsqcIRHBWrw+DzMfC6LhMUuXjFXIq43KlMjDtPiFzB8MCWa7lvZOdVXmEhqcHI+hXeNRR8NWKGVTR02d7f0kR69ApXyon9cfjpPbl7TJRZkFa8F0SAfIVbe3hBaiPaG3wK+khQEvthehoPg791pdnV9A31jxO52OEgwA5/xdLDYfYAb39nb5mUQaLFAPu+8ymM+skDWzHhkoqBI5hxX9p5mVbGZ3161rs5Oj3qHe0dH/2zcyiSaR+d0ivFvYt3lyed055fbcoPupfnKKVjc3afe9j59eigc4Mv32L6a7/KUsmDhN/FC9mTo+7JXu/gvV/d1L7Yv+x+9KssxzrPMV99zYBgdzh+9Q0f/Obk7KJzc7jX2/Orv9CHnX+837vsEmgabFaHZ5f7x52bPZwqPGVzujzFW+KzCzZRNqGL3gGB+6KzdwigNNiM3h4da/NpsAl1u8ccqMamthZEoeJLxTMhczweAQqPA/3ZJT7MjIfHZ6fv/A/GQzofv8fUmJOjU/4oYPwI3fzZozDUPwat6Qj6/Dt9+n6v+x6w/pYmt/9Hwlej1znowXxPO4LFsWeX3X3/rf7otNPzp/qjveNjv886Sx9AIprcBNFnvPDpYjEv+ejx8Y/E3AzGVzX+grOfKPxjFhwdWq26eonD179UNt54Sz5TLmQuArSGxId0JVN2M5Z7mj8PTOz98NPhB7B8/qR2Qgp6EfeWB1o1w3Pos4IKMf//8SCPhx96DphnjeIf2Whn236zTuwrlEExFeMAv6HmLfYlT6p+DEJz3/KeGTAXdLAXPtHDgvNkjgYyvA82rq50EsqsyZxZ+v18v9zhGWn0H0GZVEmBQUpq1bnMS8QVLnMPw67z4ex4B1CbKHnYDdisRdygB95pl7CkTvRZiIIqa8txMcG35qKMjFer1QLVOxzd5r3ED1EBfAsk9xHQXnY1R+2qUyk7dfiHNDoBWXgEjxuuK2PiZSPS5pDcSSvvvdSXb9/HM6ySroyh9dRSezoJo1kWpIuadLE8xFBv4kV+QoLiedEpjW9XnOsSVvxcadDAF3oTQcL88RJCEblXV9fIOqyFLO248b6GGx4TjccYdpVnG8wnVg5Ae2BOortZxVd/t/hvBTP5PstRJePXrH2XKAjxmLnwwjv9jnUwS7N4UoLP5QUrzL3vevw7ci8LVMEy4Ga0HiWp43XXAjYc75ojMCJqqT2IpzRS+bkfUbWO84Xj+O7tLKJOCpmhQak8OfMe5swHkpiJbJWxxcF2lXFz5fXcUr5Qtx/mjkv4Whgyr5kJitjKfd/nZTaf+Eps0BxchjmVtHRbgV7cagf2s/Zgt8xMjtEIBsjeghCCPkmBqAfxNDi579E1R9iv+sPhgSIDKK4aURHkj49U5UfO8jWkJ3qulSwE69ZA3U2CFPhJm7IkxZsJa5En2xZZhF8vJvx6MfUtra6S65ydmjhtGg99P9V8ouahEczOBp3OUrT+MneYPaDOzwHDiowSqLeDRRAHHOLQCnFwza5I9h8+Dr+QUJ3VVRKt4wuPpvqcuzaJEAtzkTRDuAaGuBklVvCVcrBddyX4zGFXhSHn2kiuheV79PelIZJSOATEK4evIfbwBevU3gIwVNZT7CsktXrFqU2YENi2y2x0Mb4FmJC9RZwk6C164tEPSVVgZL1GYM8h0WDLOqyMlaboOjV/Cm9eQKLbbI3wqhg6D7yGuIeHczmdJcEll0eZ+nwaZxezKCIMniZ+KJZb2VjWsG1b++31OobAt13F9kZvw5qbYmfPDIAM+79YvB8IEKPfgprPQoKfW93HrZspVLwcjY0UXtvrLMEBz9fOEOKBtSlukbjSz4KjAAhGeQNGAXiBz4nSrqRYUMsYoyKSU3/VBRDFfLf2rWwmvvYwG7uFOa6sqHEFbLeMXZY2XK+12BAZ1nIhSTI/+u/htGQSG4mCHJEKwBKIUZxmJGxSlGeMb2+p7V3mrCAJkbELcq8epNs2fJHs4DeTMMViQajghJRbYFnEuUChvBVHNqBjizCG+FqEV1D8KHfqY1iA8XbI0T3m6B754dU4f+r0pcvViLti+z7mliHNOazo0A1C5Jyl5sgteGhZ3hDhBFyaHAZLiPBpswoVlB+wzFg1IPtygmKycuDGmKw+dSM/enyMaaKHgPvvFPBhBhHvoQ+A9rfjdp9DOC748Kp/zS9UxzXCxtm1Ksj2Um8ryvhVduhMgYLG7DQCMX86nt3dybI5uR0uHRfH7HypYfh0udBkpnkOmN2VeSf8/BgpNTXyvo7UdlpinajOjiNXySXprCnzN4wJOc9L4/3LIMLgz7ugGKDqyxdkFplLYgoD5oyM9y+bEevENqX5vMAGVEDeVJ+MiQtapJSTwY1SYIRx49rN6P5oCFuoJm8a25ZPC4w09g6AdYVwPo8Xnh5cNnzykGVyQE4MmCYxcUgwairVgU8AI6VlN+VmR5wnfJ8nsKVF+jxu4MNtPvKZk0B5pBn6RPJzpbGvZGWbAS+ZbfNosfaMs5Q7f3w1uyZVCEb9ZHjfT4KjoTeBn5+AXrGj9ogQSBIQsU1okkPvDrXOEOgCDZTwqz/8HCQZsENqWvMmVJMfSn49lK63NYzZjwST1lme4M0K5wtx9rHPNwS9wGaZylniBG8Gf7ELF8ymIPLqrbvtGXfjrWPGwTWHpFQIcodSZcahbegZxvgx1rZs383C7RsjI4WjFTgyPYyhF8y8ebfrOC30Ey05bsVJgwyeZXYhaxeOcfU5posD1N3BmEVSGbpMF3BtnrdugcIQP1dhqAiFIeYKw3BONrmu3Iyu/di7QyHzjuP9WBJQ2V2B1VMoiopJhJ3dScXWbhn+M6a1Zp8WsciUkXIfH+9y9LPiz5TH+8QuTGdGbcQuDxFSpiSyaKlq/swbA8fwilfy37eQmS5TNeZWgBbRY1ZUp7XBovGI/CiGIXqIOqimD8dP6sP9H4qVah4r/bmSvqJIFwY4uRk7ZSeEVveMq4b2FIAimT6xOmfh7QdgaiiCr9S9bEFhuOIahVqBwkXVCYtLEwoGh96xJDEIq0aopMimeUGcSpZzV6OZhkn++qIahfkChUxfA/AjxMIBUN3DGZwzlcDlDvXoTo8md5ZSL22LoIwqJp+H97vm13CaVKvJdaucVKte7iUw2Lb0wa+jD77qfB+ydNTS577ucqWKFS+J5WmjtiSSXn/HJ8Vetv0xhvUolS59vHGmwJzHKc37I39X/FgWtWnTQzFWQ7obbnVrE4QG7WHTrW68acPIW5hpbVSF/3rjit9ovuHVkHQmPSZTm2k7bnbNZQWYa2Nz10Hi4enTWQu6FZhwcDTcfwBBAfrDihPI8GnVDsKyuKaSAqD0hF4H1YAVmXmbtEiFDzzE/JTHC/xv3XGv6teaBpHiBQsdjogb5RlsbKdy56VajYuTpDX0NUi9IfezHBKgsyTERFpwFJ3D07L2dZy09CGBldweEBm/PNNadpIW+e+Y/fdz0iL1Frypf9UHieOLs1tv4R9fnd1Gq0m10QkQ10RGPE8wumlKuY+MjODEPFGjmcw53UHPZFUoknv+9KpxXWlubr2aXjWvKyRTOvy5fl1pbL1+/brZwF8b1949NNy8frXh3ZJEhIJOX7vf7ivwbut6Z2eL5TifXr2+bh9U/DI+Xm1suq+gf4/+2Nq99Q9a8D/c5PTS4hbzALPED4TDXAS35V6FZCP3btnNho5dRYYXyzkUsgLwPN6Nqz8+nPGwAG+qrco5XQWlysQwwPzLp5R4gHB+bZZTgtEBD+il+DM+OJ99gsblAdanH3gNb0sLTymkxZ6q/JVOgRaZ9zDTn+aiAIRgESBMxlJi3kBp9eNpveF8P6tgnW5gMsIRTnkMff+348rvZDwO35qbLhNP2KYVDdCMRSZVR4V25MsP+Kb1HFcYaDCPAuU2ogOs72MikcpLbH9hRSCPpBGGUZotVoOK/OdNKzNsV3qJhc3W0wARDoNAqExmIYNBgMi6YoUiL0WGxIs7sYTCOaA8/djE8nFEqqDVMXgVZ0zmAjwYjh5QrmNXWVi/yqUtzWkBrz4VSOllPpMrUIjsByz0O0/s4kKjjnHZ6kkRuCRnCY0Dvap7yv8nZ0K4vY51IHfWm5VG83UuWDKs+utNghW/HK5ubZDyMb+GrVHihav+1no72R4meGMLEu1Kmdy/MeOd2+bxYxZ42jTr7a8Jq/OAPwkgkQ2QiAAB4kK4vf0aCwimV0mlce2HOzs7m9WETrBSkXJZbocburrjeBELcfgVb7J8f8TexSKEAV/txv4sacWYsqVSuYZFpJvjY9JSyPKMnQ1f2X/fsf/us/9esv9CT1z8oCdEDEdDhRcHYUMM/ClMCrMT+AN5ww3nA74B7uzlXohZU2hu2GgfKI8cs44JY6iwH9vbbzzlR2NL/dXc8GLfv0lESBgdiXpiYeZdZBI0kNa3vCPXGHAYbKHdVJyBpDxAehVVG9cs2rZajXiQgv6yhlICvPWIpMA5ZgTKMZvhezqzEZ/ZSJ3WSJvWSJ0WE4zKo9VyA36vuyBHVtifr8ojrIzceAQmeueTH811UsG6CsToDf3ZKzLJKYi0Te+uCp8UomD4Cmf/Z6HACPjZdebcwELhcZx2n2zJ/jamTL3qYxkYDG62+uHhe2CPlr0DzE76Clw1guqWB/9s4j8bXq1eb8A/8L8GnJqNOvwf/A8EgEYA51CArbD5a/jfG/jfL9dX2TXvOJz0x734MJ59GisRtysNj6TyWG3WN0hB6ATlbwZUvZ0BW3i99Xq3HBBNySeSTzVzWxmpdMmewoO2ctWtzgRLqzVEWAwcrY3d0E9epS34d01ZvMYaxmjvVsMWdVIaEjjRm5AAbgLspYKRKNDiSpiAIV9ea/zyyy8kHD/cMSFMXSCA7camFocOCFnLN4QeQFDAJCOIrN3ILzc2gdyBmvF3C36n9Kcyr4TMKmpF3K3D5pdm+uGr7m7KCgLhgNo6TCUyrnIJrTjViwvxq/CazpwsrfPKIQnguZyEj/7huClZ2E3PfPURXxEK0F/t+E7f4ccM9yCqNqpl7cjBu8fqL69d2IJEokp9LExDRVXU1cPK+o44tniEWDv1851svEH+a3u+vb3Ztpx2+LYNB12jiZJJ5P+CXl4VPyJfNOrzgKoFqeDigYLkt+O4n2lYBiKqk6Bz5UoJsJ20VSN0A/h33QOOgJVbKIsk7cYrmCoBczRvA/t5fBzvOL84Lq1iEO74iZw6/27OpMmqY2kU+cCgREs6wg4yttXV8bYPXcMIhJe1Xfrf3b7faMXb61QJfNWoV8pa7rI64tH14gqW/IRJ7fLOW2Mfxbg2/TbG8q4pSYsAJzPsY/y7Xm+R/2CYLcFo9MrEaT+LQ4lLmVZCMIUwPe2fgnwCGh3ZOLfjmCZo1MqACs8RbpjANBuGO07QTkDnqwu/G5ktK6EezZMwKiewW70A9T4ra671p9PxQ5l4AZGEduQtUIpreFFmSfNTGFkBMzLiKdmcJJwVN8QqGRrVJhIn81xJpCXnL72O0MdIFVhwwvxU3G7uooti2kqV9D7x5XSKfq8k/w9JLUfGtk8TGfvzpprPKNJ8lTAtXJ+3YgDkw9LAfBFeKU/n16jSjbJs2lpbc7DKpniziW/u09zzN/yL/Kst+gl5sVvmflDCowz4ADd2lAPVZBCC7qIacLLrXe19dt3SekODPOnO1pFIVXJDL85zt3j5ONhcE9WZKhBZRpQrO9jowlMo/zVzJ3NboeJQlG/GnIpCdCrSQC64PcwDXtDwWeAX9WGdRFFjdSqq7e0A49xU6lev3NoBMxXITDNBhd90hcZxIZqEVRDdXMKq225YrbaF6xonw4arb8aKeAdbrtrQc03KK0rYY5w682/U280EiIy6bbNrSHO3ZbmbGKLesoddLUKWnIu2C6i2RtfCwZTvpuAanceZddLYGgBv6NrjMay3p6G8hQDZUHpwUqnUixiEYlGZ8xKV3DEtXUTS0nF3EsP6ykxasbS69o02ZMIgII6V6mQaAcUcG2JJxteFM3EqsddXZjFXU3L/OUs1DLAmT0lbMU97KJfNyy+WD4ws15q9XLCMdEa2VfwzV27ZFepfFwEJC8QXJQnSePw5kB7h7B5qSqv1KFkazN2aFe7WTN+tmZtzRsg48ZDB8dSlHIe88hKqCEkvMv6d9Eg0e5qgB8s+c1Eoh+hqkPhPDeqpYSb+A79kKyXtnKfHx0xx9TiNWVnAKyx46FyXblFVKpXj8RDv5ifoNbHrOnMuC7xNwgCUIUJQPwfRBhD/XoTnB/+3IF4x2PKgpR+PWHUQkqCPT1hb5j91XcXwrozf1y3VptRikw/a+ZUOc1OU3Qn13C5ZGUlTRc4yweoiP7lKr9srEXfHYn/4fsZt2RHPcaT1jtOcy4mqV0SGrbZwql60WHhblLqW8eCIuf6srPQp3AC0MgGLn2+/xhJzuNybte/NmNvoqMYUd3U2dC5t0YLiwgIy1lZUMKJcSYrUFwv8HzLlzBJJpaCL8I52oqRuF0No9zK6TzsLfSS07X+Ow2GpzgM+5KsVXyRvUtoHbYNEVWGhHZKUN6w9fO+9aGYMcpWWjG3ESFyL87DuF/ueDnL7kndoDiR45w8YS/QlRyEpNoQHH0vd9m87a4zRXZYQmJ424feeNiQmMPSXHx4YM5+vUMFxlhxbp5g0REHWM47mmr0L84AtWtxApuBUlJ3iTklqTnFxU4RHBD5Z4amdsxU/kR4p6M8inf6fc76nz8F4KjAuLDT/j703728bVxJF/7+fQuZkPGKLViQ7SSeSaY/iJfHpeLle0u32uD2MRVscU6QuScVxJ3qf/VVhBwhSspMzk/d+9yyxTRSAQqFQKBQKVYTiPHL352M1sTRL1eYL01eoevMkIhk0ic1HPWW9gD44++cbUqjnIUYy5E9g0Y+IOo0GftDC+JXkplM5AK8ixLud08bzJC3anx4Spr6PDZNMcNkfE9ukcnIZXzK3Quw3tctDbykVN52KLgXaUqKkm2GOpxdEabok6UtTGnOJ3j6Q61mGJ8YfpFnKWLtpm+V2Ghzt1bjx99G9yTzCzegVIiUKvU/HsKRoFhYGPBv+N6GG/17yGbvhSaY8MoIwSae3o8Y93iT0G+GXCXl70wga47AYpcMG+oI2ggS/nB1/YCONpefBE7ot0rQxDpIH3uk4uAsb+PYMFl6IvWCCnLPjvZWQpPMeYqcsgaPq001vb2ueFinXuranRWPrm0uZMHwi379M3K+jijbES0xQX0bcrGS+mr0kHuUVZcB9owW4D7R1fIhEdXR8loSEcloBI87Ux/yOHnqcd2meZtWAxL2yMe2vdMH2tNc+BjGU1z9mkXvri5pV9fBW91ZGGx5DDZl/D5Z4X//ieOPWGl76cvqPofqMDkNPZr+8vMS1OC0uoY2ERaSRkIKCuEyicNhrBMMxvjqXiTIIi0aZ5Lihz/cXGRxrxBdyc+rdEq2yTR98TPwNlhdWla98g7zWslhdS6wm/EW9dz1zSdTidHk5E3nxxiAPuA/t/56CzhvmbVgm+ERgiJGJjTJ/DPKd0mdM/Wb4n6g3cBKVA8SV1SZdX8QM0eJZL9uMyw7+XqYvUXpeqVmiygnGtrxy6xKNxBJNJJMmMEEVbfAlytDPvn1jHJTpHCQsvTBua5RJnNfDiO2bihJis/qQG1Y550twLo8UFlCKvEgyQyZ+pUsHAaF12Cb6fCdXLc40AzZfwrlLsmDzIOeYezewzWeCuwwNSNmMdIETWbe7hG93RPg4bi9qp5/+64oi5n+9CkXo4N5K12O5BgL2SzTsJR5fRvBH6o3u4Uc4kxdo7LKAkb7ygF2aFsoMmu1D6KVm0XlhfwktvYzFzZeydY0naZ5HnzDWRErSZAbXcGBNHvj7rU/hdTDFRUaFs8iTIiNbOqCg08O9+nis+lHzUgfzvwnPA42D9Omay0Kgp/fqCcgoj2WaAqnqjvOnINeQJKqtOlZ1Wj0dVmq1fR7jXDIWf8OFM+krFltuz6BToKpVGUEnEMljcDdXu8OFr3TAHz+py5oTPlYIrTTixZLQgSR0PEt9teWLpC05/pI5MAqMRSwEEmydCtcU4zrQy4/Id5jqyPzdhUb5HJai0nArwrfRktLKMYD3FQ351UGH6Ysa+flgxUuvT1HChoDQI7k60CIjJM8myZsr5k4VBqSvnDwdT/1/nBwetMk9r3zhwG/wRy5/KDnFYAaUBrm2SeaWVI83QRSTjInpNB4SmUTaJ6n6PqNtgKhGnEYNJBiKGypNtdeAiZviK76EPO9Vh5CaD0sw0YCW+pTKJjvlC5bgAAmuSxS+iEV89PReXc/KGqb3PCBl5XQwVHbxgT4VG8fshdMjdu7GeVG5dT8hlEnyiFAmkeJAJzdt3LWVN9ulbSotrRVVBKTKKy+67h90wwKlceClepQqL+Bu27KdRY5m1etHfhUrSTIUvgDBAeXthzCO0/sj0PXwGQ3JvEH2AQxnc34ES0LsiSUh4T0wDjjh9FFjW2qxxWsCYBboFsoaelffkGFmtzWHbw02RLDgEzSwqOE4LUiV4nUWEpmqygYiZhOsgcFweIarcBqHWr/MP5PMT69xAPIin07Q3gtnXBACOGUn11k0KZw6+tpDas+dijpKWwMPz5uT8mDtmFVQo2qmKodXPaFV81Y1rMrZlThpq03wjDU+qMI2ei2dWWx1Z/aQxnpFG4w2epBS5wBw+Om/hPwVSYu4XQ+2S4TBxc1SC2F6VOkwhGrHOx53SgSCGJJKp6nIRqR4AMFwQUSx7JbGWFFeGOUzyze+ILrtbqf98uVa9w1n/L0kogKwdMWmRuw0g5TiCQozTaCFe9kIc4qPFLSnFKf0Mdh7JYSkItl2sxDzlqrZMmyRTyLdk8o8AJPNhmmAMmRDpOacUzD6LYpj0ifDQfz9tRRK2sgwopS0lTwpFSGo1RwnIqiCtm+6Wg48I0yWLUNKKWLa3Khwl30zTNvKSz4/mECbpH9Ukj86Mv9eg+QBHDY+PfBpcpRHuuUAsJSaLC6lCHwhgsDaQmLyfWQnWbwOT7fyIb09S2jm2yGLGnMc/hdFXTSgMm2a3okKArJJeJ8n8xHvigRgQ0A2gqLHw9M0HND4HDjxBaCzY7xCEA906RHN9FhLiSCVNXTYpEZ0D+8QPPoaxndewH8czL+Ef8f4zwivGJb0eJnLy/ck2TH/2U6Cz9FtQKJAml9IttHBLUz68vLzZnQUDL9FR6M0CeFHOnSf39JwkdXV6P2QuAzAJ1TcAKPdEmyqUB7xgiNgv6I3pKiiXB9sSpiXKoh+kyCazY12X2vtqncMFGH2h1LjFV6z+fjUbxIH8Lcj7hM8x5FPdhWzpNufklCYgWhjSuwqSphM2z1GyyfXGLLnjjd10SEs4mEvZCf/Tk35txv8zD1Uat263thXInv00HIKkJvNDGN/MKgx3nvxP8eIYNzCoKI9ElQUOughOPv47xpitwDNtU5t7BhPc7oOHaV4V7PEz6bKdAO3via595TpIe71wMRrjguzg3UVAhD/LUlFNFf5Dg99Q+aZcIazGTMOEWFxcFU8d9ADnfVulMAigQMTPq1KyagTvEZqBfA5amlfXO/rJEuLtBd5yN+9zMMMvL3cw6BevdRD1bCXeMN0HERJL/Aw1TAs3F7sscNMb+TRrENowaLGP5FjqpziR3ook14FLdbYIiDXZHrRC87HDncaVgQX6B2/h59o5iyebYbE37RBvgdSKUBeKK6hK6ONoitAaEQ4JU1wtwSfZs9xtINWWR3YbJqqwzff0A68apVAMVux6MSht114DlMilUScUU5tANxKB7tj0PgEpz6YWwfq8AxKvjPNP+lIl1o/y+kF1McoK6YkwSw+JO2u/truwH+7aAEM6AXC2clbZgDMaSeGsdIq+FWDMQsCG1ErsTs3YhVvC6NChF/gV/wFk7k2MK4wv5XxMuVMiZ1GMvrJo7pAzdTSumrwtvB85HpL2RwSJ/L0hfZSwvnXaUx7In8RenLzfFAQnWSVvyejz2/FDUfWxh+7aaYkCrafEj3q+ZmYJgKrvpVxd5iMK0UJpuvMb9UkxHxYrMhLKI7pk8y8qWHmfQxuSl0vFSYkG6p2SPUzrDyujR9lYWYKgH82myt9/hM53ejlf5zZtfOy4PmuPBgpghhFupn2mBrtrBuj4+W105UJ7z1luuhSWUrIVl6xrXAcxPaS01zpS4lbRZSIEAVtqQ1euzEGZZbL8OBzEMUBE+JYuQH9RVmajEEFdRSxkHASrfElx8SCvBpYWCykdsuhdeklfOklfOmhZdEqFiKPFZmmxseJhdgQCwkqrsBQu0CpaRY245rlHnmx9dpC/awsd4XHhIJhZ7RokygurQg1yR49uXCVsAXqpcGASS0DkitLkwETdiUiPXkqNKASFyYe9eWpX5ii/ncyYmowYsAZURqWF2bEgJqXF2LElDNiyhkxhgNJxf7Eijz2+mX0JEYcLbw/lXFT6nqj2v3JDql+VhhWTOI/0kh4pOvvpu33vJtL3Z7t3qJz2b4PP+Vmm6w7PZds+c7FvhdGJd5ml9b0Ia+McK9fqJRtN5Ea0T8hzrvyMQrNk4huf17oR/z2xZ0tshnKcbGNlj0JaDqtkO+GLcd1lPkqzTnshVEpzhpGNitHXS71/570qHSFqzCIMXfwQ2OotOZwZpwprvKl9OsRX3FKwDdYdC87eP1pjwW3+aNwhNYcnos9spnT3qseAtNE8RHgiyb3LPM6N3K1SnQRIa5pi3yeuYD8OHdE0PfTMC+Yeicl/BymzktMnTFP2rmYYnc2zS4TilelGlfZlqK/yWZUJK36G2g+S3m9qlKnv2Wlw0rON4OOy3wZ2GbATwS5ZTMI8djAzwDibljDJPUSIr9TKfpKAbQLJbhWuKiA73pL8oo6VAW8BQ/gD0U4h1I4K58lgtYkUZrfiJbzyAa9vByWIi7b4LiUFub9mpjLOInSdKCEXM7cWclesTyJ6P0FSRuvXWPoe0GkxbUyjk0wwTRiFN9HbPaOQvqrlG4P3No7B5lhvM89nMv3DxYNCuuyYlLBZSmltJ71VDZq7qf+nIsQzG7PXtxwa/oclqDAM2GJ5JykBd/idDJgaMYI4ANlFUS2/aFV4LGOPr/ONjoiWoeMBeGtvhSnDJg3ZuFvwvk/xZEowTzh2A/oYmTMFUtPchhX4+g6SwmKlitttZMb7Y2b0lXhrSFlTtQvprQ2BhqC/CPEITFH2QsxG6L9ZP1FBw4WG2vinZg67hT0Un3cII5w3IUaFyNCS2+y4XdfdvRLsnKkfzgOSGqvnJgbeLfbcbXlROc2WVntgEjHKKYidBC5ONSrc6rKiK3EQLs1Cq/v1PfNymUvulxtLnV6SwUaYplNv/sGdcTnf10MVv4MVv7urLy5+o+Vy1+ePacXJeLyu65hLoUsMMaJi5LHCN4rXSbMBH6Ftbrxukw6XBg5/uy1j41Q9qK6mQewKJ8WLRJZp0K1cdiaSrCYbxdmfj3EnKCJdHaA0zw8rAc4YxjW5IDiUZ0Zf8kPZ1UZ/7j3pMfuqkFu+Bm65Qfk8cZK6sUsQli4Pog2lcUQ/mu342Uiyi53keopkcuKjewivlxebrXi9aTP3z2m+O6xj93EtJsYuynW4fScbozIzdW01QxWpu4vzWJl5D5vpisjGb2maAVkkTzsb79UwquAEDiPpHIQDIc0fbVQC0QcGAz1AxS6nsYkaQxNOZVERT4K7m3kWOnymEhqOAwaCPjVCxkJeOSHrcTDwPqj9XhzqkfGAcJEZHNuwtaM0XYxHCIc7mISeD5ye/h7aw2qRfTXF6QAIdEnmtRMWy0P40iTIE1rq/B9xX9Nvnzzp+vrwYw6EnTorRdU3YzXAaeXL9HB9aL78tJ//Uvs9vivzVcvWtAPhtJY4hd5Iz/D+Hff6INw+v61+4q8fMV+/vJH9AopAh7k9GL7F41phvfAHosA6RfISBjCC+Njwo/VSzSuXKxdogkFw83GPjQer7/ukCwvgR9exCtrl3/hj9f0R/cF+/nq0sOYE34A+H0LSMw96mNAssWs8hYw0uPLbxjfcfVXt5W2sE6r+7L7Gg5Uqy/etJrZcv7t/8mWE/KMDMPsAWYw5rXOtwwr4f4I59Jg+cXqmxdvXv26+uYl6wa7gK2ntp/XL9/8+uvLtTdr0M9f+V+P7wTbX39V28nqi07nDfTTeU0HA2P5lj9hPNiLpLy1q7W1Ny9fvHrz6+vVx48HMy0SBmhFymeYw+4lYYhWpn9evSQM0sr1z2uXhGFaif75xSVhoFaqfKZS4eT9oKtEPuv+urb68vWL7ps170VndW11be1F91dQml6trr1e63ZWvdVfAWTt9a+vvbXV1y/XYPpWgWkjFvdUBKtKRKCotVUaKeo1nEWGKfH8EUJGESOZBwvQw+CL0g4hVg2eojwa8O4lyXCFj+39BPO9ZS3/1YsZyRbZzDeylTeqyVgJVAX6BVtl2AowJzaTYjPQFk7KJf7zYgXWebS8RmOn8nMb1wbS8WRahEcnv6mXJU8lGeZU8ki+3wT/SfEfEAXeyJsSRKc2Cnpl0oUkxmyXtD+1ES/CzyMiZl/2RzDqDFNJTOGfJ/SzuvbqxYsF+8m1fkDwaKUJlnYehUKBA/WInwFNdPK6+2a17xo8xfHJEG56AbJ7tfvi1xevAfPXgMErwKBLUZhSFDBguyLjVzu20eXEuwHW518wJJi+BNYk/trFX1fJryiuYe3hr2v46wvyK4jtADaiJqx2kEMuefaFCDNaYBC/tVWCTnoBsgXZekR5kYTb1T92X1k+vja/8cC/sA9Cn6+0/lTaP4buq4TuM5oP7JaHoqONMvxvWzStLos+lEInrhaQTkmJy9fW7WyeJya3w653Nju9oiUThEVWTzm0DWmxNgxPCJYisk0NWyQYuu+zF+DMfAgn/MNMGsWa+mWD4hgauphDc6a914bid2FipuKsRzWyoxrSuNE6qsXycjQPz0jDyOqnqhvSH0BRBy0YijD6qM1F9asFENTkWX+naJ+cbW3tnJwAK8AfB4enV3sHe6d7gw97f+5sgzaIX/cOPsLf21eD43dn+zsHp/7KKgc+OTs6Ojw+RdA1/La983Fva+cKi3YPzw7g8wv8/HHn+GTv8OBqf+9kf3C69d5fealAvz07OfdXXuGX0739ncMz6OFX0jGzzforr2mHV/uHxztX24PTgb/yBj/t/PF+cHZC+u+SEWwfnr39sHM1wEHBN4L/2cHg7PT94TEbEkH++HSLYHm8M9iGzrsE+929DxruXYL8yckHjgaIns9B1jghS2+nIH+8jfxrjG7QgKUQJsO8kUVflbTOcO6FAw+sqHa7HWS3Uzzk5Cx6lUivvdSlC5edwNBzssIHEiafeQLCPBPDC57cwwQ6cNJkyitkvILjhczEEPlhvwCGpJ6QHrniRjMCGi9KfkuKkzEO9YaeuGaq15IBMpYg9gtA/QqInxJPdDb63ts/GoHNdgtu5k+vRODJV+Cib818t0iPtlPyQp1h0sGbSHtmoBmIkORs+mna+V0AxkfFYdbP2mlCjMPyETVmL27m7SLA6w1qOXZnHgJiRxpc2DRUNFGNPd4jFfEOZpATgLfTmxtCD2A3YN/k0aj/sf8BJ5U95EL0J2HSxMd3jlegsRwRBQpm0TDcj8Y0lIeDEXKeT+IgSvqYnzDLw8L/soK+hSvDEGQrud3BEZLrohzdrmkaQ5/Y5ugQHog7to+XHLDPINA0X4IzEhw+5Z9rnReb/K/NiJCHWGSblKMINcnVBAXBSJcq0Bnxq6bvWMcTEpyP1JPRILh3HRBv04HqIXCSetgnT5EnIHnCUxi0S2cgB5HUdByk+sz7k1LybdQ/4bcHJ8T8s5N8bv6ZuUSejTNDnn3S5Rm1fxKRRhY8jZ9yFxovVOn5WISQKk0gMbVw3xo6l8y2xJ+nMd/OVgiT6znEBRgjIoQFa+E94eOmQ+IgJcUKTrjjob3/qXwQVPIBeasqWWHDXxOBrdh8btAsp4HJMCPGKCPCIRioAtS67rdv8HMVOIapvjDef4BUxrbGE9C1U5hbddvC6y6kR5pFf+MtInV0bGLaW9o9uQQmhpUX0CpW1zczJtcYNzW4mZbUbUCVRlM8IIeGpINn+T42LV2agmwyr1kNILVr+kS0cR8VI96/HIa4ReZXJfb8YFyhwTAulktIWiAvYLN0MsG7SI4CiacnHoePrENQEMnRiVxbWyyfi/5VpJfcQDtX3jRKqfYcM0dz0MYT2qzGLYlRC1dtIAQ1YcXFSJtOC0ZdWPtk2dDw9tScGHxKs0IsWMyuQ75gblDvxlz/D9FXrHPPN+ZDslZVW6TYs0kEYHwWG2QkaJLvkIDen4jsd+jyFl4cfsgjUh2D0pKOaXoXZT9gis519jAp0nYZDhRYFFh3Br6HdeKqzy3nwRAWfZ77d21UAfcOQAe+Yoouu9IfB9eDIWhSBGh/sDXY3j4uQ0UTCbR3ZIfJp59Aeu8H+R0AnZy9Pdg53R+c/GZAZTBnYYYIgQa8c2yUsodB2wcnALF1dnwMijj8UcKGhrMjyGwdHuzuvTMgJlk0htmh7Rwd7+0Pjs/L7eQh0HAo4E52oK1tK2RSTE5I+h4AOzg9Otk5/ljCHcXsEUwRBhQCsDMAOhqcnPx+eLxtQJKYLwroYHt/76ACFr3ajoBrAQxXAWpTBgR7YIgvegFoe2d3cPbh9GjwbseEY8oX7sAIuHeydQijGOBJQoe8v7//Ha+yh+ktTUV11/4d/oNnmu3Dd9s7Hwbn5rwxTRJ2Mpy4wYcPbwdbv50df6iA2ydxnRTQ/R3YBLYroHcwBBNmRpTwOwdbh8DP7ypqnIagXaC4kTVOd/aPPgxOdypqbMkIPEqlreOdbWBBOCmeVNTDF4tQidOJV2TnyzpancARFUMZKrVOtt7vbJ99qMJxP0rMfoBx6vrYD76Uagz+sNWYpOEWXXy4Yg532OIzoD6rcTvZSwgaboGUSyGzffj7AU+OJb/u/LF3cnrid83vH/YOfoNT62rp++Dg6vA3f838DsyI31+Y3xmyeL9DSsryzD8RB/2T02NgIApYkmkVcGWxVgGoS7cKoLKAq0RPl3IVYGVBVzUMi6SrAC1Juwo4m7irALWKuwpYU+YpYGd7B+z9jkXmVTSnCb1dWNU7nEm1ktPjsx3OpTY5KRisSixa0bSIxSrG0KXi0eHJKcfTKIKDIUfUrHR2yheUXciKQZRk6u7h8b7ZnyjEeCp+t6bwanB8PDg3+xYgWycf+YIulZ0fbp0eXg2O9vjStndwcLbvv6wA2Nk/PNjaP/FfVZQP/jw73vF/rSjdO9j9cPbH9lv/dQXA/v8+PfXfzEP/6h9/IpGqSHh0fPrO73bn4HD1cdXvrlYC2edQ7HKHu7vmFMqy0gSam2OpXctGOId3bTtg7bIwN795a8PY+WrbNjc9K3B517OCXRFFHP1ofP4Y0JFPrQdFwdVxljyQJgp0hDLu9DTDtlTSQ69Lsto5Uic3YBVlXQAL1dyAlSq7AJUaugGrqO4CmCrqJrJUexdAUl83ABVFXsGUqu0lRJk2LwCl9m6AKmq9HJSixJvDUvV7UUHo8ga01PEFqKrSG9Cati8qaJq9UUPX+kUVruAb0ELvF4CKnm/AqicACa6o+ya8ehIQFUyt36hUOhRIJpDKv8kFyrGgBE7PABU12AGhVIkfBSqqiZNCqSI/EVRUFAeGUkXlYFBRVz06lKqr54OK+toRotQAPyZUVBaniDJ92WmhisL8MFGuyA4NVRX5mUKuV3F2MNerPFQAsAhphnaKdlliMh+G27CQQrFJLTBF30AFRr0jAj6u+4pBTHfH1Hym0RrfVECtEbaW1MbYveGmxX7SwxRLugT3CnUMUlgvNAjfiFPzPciWzz0SW4mWjq7YL34akpcOZXIQAll9DHIf+2kGUT4xylFIdPVh0F3252F97Syr8D1BU0dd7vs/DfrlU7YcgkTXXAxUJ/mJ1oJuAVCXAkVVDiBXB1CODMacXQrNxx1vyYggllqaLpGl6vXT0KRs7pBUkejqdFGG8WjKKGqpThtVz/x5BI/FxqOIHgVlnULaYB5NI00b16kk9OufhkQl25akj0BWJ44cw6MpI48dOlnUg8RPQxmbNU8SR0VZp482mHL8Ifa25aT9fnDy/urt2e7Vyd6fO1ow2pOSI5bn8BZJ0oY4TW4bPadVeGVQt9ecOw/amc6Tj+JwLrQj2k8zGVZ7qZwNDWl9OvTx/JzzoR+ZjQnhp+CfZi5Me7ScBo6qPgNiAI+WF8IuoIsL5az/0xDFYn+XdFEQ1kmjjuTR1FGNIQaBFOPGz0MhyyWCQiIFZYNG6mAeTyTVBKRTybTm/DSUqrpRkdQyUdcpVhrYo6lWsoPplFNsWj/PEad8s6SccSTCOqnUkTyaSqrRz04gasL76WikX4KVyUTRtlOKDenJxGImTzu9uO3yp6OYeelUphlH3U41MbAn001Yfe2U48bbn45y5rVamXIcdTvlxMCeTDlh9rZTTjFd/3TEs1w5lumnDMBOQnWET6aiegcgCclL8WV9ory3Eyk3/IJEfQ0f0XhkmyX1guCnmybbPW95ntQh2CdKG+STZ0q7brHzPL8x+ekoaV6Al6nIUbdTUAzsydQTd00VOzq7Mvr59nTDF8CyqzPUK/Z1PrCn7+z8sq2CcuzO7OejnOEYYaEcQ72CcnxgT6ccv2007M3i6vDnsTeX/EMUe7NAF+mEPunRdQPzWDMPEQt9DttXCCCfPApvEs+SpOOuiXZaDyoNhkP+7FGpwXJ0lHtWUmhbdigTCRVath7i03aOT8TwIbFWq/DBh01QiU0oj0alp30v2aNoxoxNOl3QMg3dU8pET8NsLnV4nLu5kF23zn0VZmyJjU1hlCg/JGl1kX+aoTC1wWm6iPJwSLryQhqRXuVve3571+OZJawAhRJ3y4ZjKZVINSgPtM6CkYXaKxJ7SDKtmR5ZhyQAHr2nr0CYTxof1zQPt99vHRkvIBVstVspB2F7JMrjc6fFJAWJQ5Ph4xykGCkR6hBrPpgWaXPR1pW6J2RZ7C2M3snp4HRv6zEITuwHHHW6+IPApoPA7eJLsYkB/33ohTOomCWeoU7IxILGIhIzUDUG46iqlNrO5trVWJhFcMq63iqpE8oj2IreBKwTkuedhHCtCsK55EE951cm3X2DAKV0prrrnSfTOtLw+mrswBMutF3lkXlfTUwjurFkijc74m895aRSMYX/9O7adlEresHVJIRylpeGfVKVb13IUtFxUdlxs7B2ouAjYhQs3t1C48Thzfp3Jc9/7RN3+9c+cp9//SNz+Nc+cm///p3V1b9/t4iff/9uASf//t0iHv79u3nu/f27RXz7+3fzHfv7d4t49ffvFnPp798t4M/fv1vMmb9/t6Anf/9unht//24hH/7+ndWB3/xMvff7d1Wu+/27Rf32+3cLOe337+we++XvxF3fAo6++v27akf9/l2Vl76thLroV5Vw/3xbOXHOtxUonvmV7RK3fFup8Mm3FTKH/P5dnTe+rZS64tciy/3wbUDMCb+uX+qB37+rc7/v31X43lsL9GmxeN337x7lct+/e4y/ff9ucWf7/t2invb9u0Xd7Pt3833syWPXAX3s+pXtabBdNT5No3hYm0FQAaZ5cU6uszBMfo+GxUiqSzn52L7Hr7+wt7cU/Cj6EsbHeJqsaup9GN2OilJbI/J5kcainOQ8O8xO8UpOaWnQpj1sH+1tvHm1vExDMgZfmoN2aSye/o0i5T5Xmljvrqq9XgcT6CQ8if4Oj9I4un5Q+70SJ2ADiLeQW1sAhaKmrl9oJISxbsHnu7eoDOZnE6Y97IfJ1ILKdg24ilRtsyp+dQ3qmALFj9IoKfKjMHuXBZMRRrsPbeTat0Kq6FW0he/QN0hAx3mN+cXGRsetQg9DYcJRDo4EC+FogFcharZKsV3pVqJrVLDijDDH4XWaDbHGSZjkJGCQDV8bqIGrtbUKqtpgyygy7jYERYm9SbllVdB6BAMdAbWeX9i6NAVKqS4FsHTKalb3SgHs3W6T5KJVfUKppUOsU90blNq7InFJqvvCYktnpJZNxND8r2o/txgVKoh3YUnvBuMo1oSb/FpRBUWWWQG/WcDx81aKEc7K4M91gZtzQWwV8Frb0wi+7AYshpYAho835GMV8O9BfsjCvyTWiqK0qoU9rQF6GB2gkWArTe9g6ZO2KOhv4UPpELrU7ZHXG7txGiAfbnSqOuLdEAvSQl3RdHnE5FUeGDvHa52LI+tGZzPsWcjHQ+W8U+lNg8YtLxfAVOlNA41504THydkcoIHDiqAXypCBrrf26mXH7dVAOwls+Q6FU2l0PE0SaOIwGSTDLI2G6jRGOfuoVvidKBhvg+u7W2JL2UpjhWucf7np4H8dSxUQgKEC2Z18aeSwUQ8b//K6g/+11DkKhswZgSG1WobZS2Bl0MYNXBr/Mujgf52qStWDGOB/ndrObCNxWoO2HatyUzSmUjUOnc6vq9eBU1XRAL8fRUVYCVxD+zndmJvDaqcKsizJXv+iCKdXdfUWFZrjaV6QOPK7aUat7ZpYv9aKtC27XBEkO4fAwI9UUFKxQGNn9pfGaL3eD4dR0HSasOuvEHvgFE2BmPqkUFZgyxlOItdx26ROmPdd2PbW17vc4Lex0cUcSLThaCXc6PZFGrFWCKX9OZ1lNZ1tRn7WC/2Mv22Lfmkqq3ez4kzQ6wpJgBfWbHM7CrJgnKu2OmKyHcHBJ3/7QAL3u3po0ZAPBIMNe3mfPTmO2JPjUxKrzuk5xMLvQIWsjZdv0adpEeZ0H+c7LgH1d9tb6t/tmywds6EbRZ7aVJt04Lr9T1kY3NFHgSRQWW3Xlq1ddgJ/2XvH3C/z+ka2f0zfyslFdATsCnOcW5FgZXPxOBZ8VIuNVLHotraXFM15TROtcpFWqfqZL94ylTuLNM10zIVb3k3jIT67XoAfKahvaZE2OJupC+hs7zvXjrlyPuI133UQb2fB7Z9pOq7B+bz92QCmyeOHFuRBkJxNJniLk4cYKddBU6Wj0UgcVpVDai3F6o7Bj0VBp6outX8whfUNYw5PaLBPo2t0m6RZ+BatSPWdKYB1nK136VoJuB+O0+zhLA9ufzT17MYFpweas31sPM1Q3VrtD9r2dv3ce1a01WM/+Zz7+UyhcMXZ/HuRyvm5vqJ9QO6KIKcU+rlrYFZlsPixJDOtIRy1D+SbQE7FbSgSE3H3k+8nmDiim00DQiftk7DYLpU0c7ddjPAoyCinc/IPY9yzPDw7eVu/AqcE5mnLnG3QDhzIyppVpoGe7XEosX0YAETc5KItmzjUaygLntcqywCjkzyUud7n0kWCPo08GLnd6R0RzOB34iOTlWQX6vtbx1un7AkNsCMK4eyafFgyDuaioK/87l9c9qnTFrIGmvTxE8uPsfryFUlt8bXwI1GeYaDc9df9DApAf1/ubq69ef169c3q2usXfxWYV6BH/lV7wdQYxayMCR8H/L22yoPcUyQGbT4wROavla5HOxZxTbH/yMd0G6//Ci+a0V9azp/MJWk3LpnBAYpXui7AdpQTD7MCaPnR0GMKM4L1MVYxyWNG4/uT39xW9Mvqi19edfB/3XCNJ5p3QnRvAzFLjyBnp1v8FNIfptckxnr7mnSGjsY+iffad1o5/DsJQOd7rh4tOVZiHWMNGPwQhNIwPDvew9QhaYL+dkbjbjufxCACoG250nOgWr7Oc0X1c54xKfGzi5xm0+gnhHJAtQ4yY8Ppu4mftHNgQZZugVh6kjackcIvhzfNkGSe4C4bCmAoUrbwlFRa9oBZX7e4+M55Cr9+jHJYKtHfxD/wxe/hJwHj9JUzmp8En6PbAD638Wno4BZHXqQf0nu+kgSCTkCrOC7sSX3FpAdsJQ6yffUE7TsDTJfrNd6H8ecQtUSvkQdJvgI9RTdOXzFV0QkiRrJa45jNxufb26FLVa3h22ovLyvGNHtL7kZncz5QD8mq3XBtKp4/3c4vCsmeN9+8+qXbXnXd591Or9uX9gq/u/qLau9b5KR4dPCuX2F473ZWX/SrzOP2QpzRXzv9Rx0TfwvDSX/ulU6nv9g1igFn1XsUmNobriUiM9mmutTpl3YSClBvCDhNMah+v3RAc5x+WUGnnaiKNMO1pI+svep0tH2DMCyK6sOC3QEbYY49LSuZklgH05knJCibw0MbpyQwkgxPir6P0bUONMkAq3Sanx1/KH9MP91M82sY0lArHk0/ER5cFeA0Ka+EQEmiNMeDfokvwXColmOcL/EXzXeIxFjqiAaAkQUAidsOJH3+1388Z+kgA7fvBhilnYTf7lI53X/+H8+fWQE6HmxbfX0whTmYUB1LpKKamuPKNzP0hN08LNo7CYlk3cw8+APpnWw9TEbyyb3bc5xeppIhUQcZlIjArPOxr1nnlzq9mO9u2yHtktjz6d2B48hUmv/6gu0pwKs0RQhP6tB9RbM6iIfwG6tyh6PZACO+w2FOwOgiuZS6Nw92nvzywoP/t164XvcV3buBXhedS6WprtLUSpc0lv3lY3sk1c8S/CqLL3V8c57JqIzVyippKm8xZ3tirNpi6koTmm91Saalv0JViUn+lW+o7l+IZyshMAK+8+I16DTd7vp6k3/r/vpmFb69dgXU2uqvrwjYSwVs9fWrXxGuC2JdJEnl08Q5Q5smc2oqwqBXzVgLO9J1kkLVSaKLHPDy6Y/lVy9XX3e+aQpd7uq0yU3a5Jw2uYU2eYk2uY02uUGbvjbbOq/kwCu5yit0GAo88k1+yfhMYQ06/EgdfkbSXXU6Tgur2BNdvXD1cwOfN3FvEtJ5U8NIaJlrYT0r676oWveYM6bBhE3TSO7EPs9yBUTkfxUCirTAxZPZBP9O2hBAohEh1WgrKNPMFvAbqU0KRU0i/mgtRolwqIQI0ZFg30kzZWiJDRectN3rOAyyeW0qtBYCTwOoJHxe6sKCiNJ8ecIJliisTeTwG2mfFMp8wSjX2XzR6B1GWMCsoPPEImMoewutJcS/WVUUkPoSzMgWTDYO2n+gOnXInYb2HzDPDbkB0VpbLEdGmpCsFWYDZAc2ALfD/DqLyKOKpgz+KsGpAaTRZRESnS2RhqPddsjpvLHKypqGtkL2VuNbT1N63JbTOPyNNbNmdpEmPGmG02dKJQc5SIE3KFg4bDvCBMBysf0xVvLbrcKR2bnP8dQIGp7DlxQaKwrdWBH56oc2h3TlfkbC8Fhq5npNhKK1ElKL86ulZmL0ydmf5doktTGcSrlmatQEKForYH0WI0utwOwPtgxSC9VAJkQdXAiWurFeF6FczxGsa6mR6TUEaIXNx8MN87AgKe1RWV7qejHRmDORN5xOurh4xQpB2Fc1zK530CavhUAd5i+4MMEM3r/yByWahtx0XfWVBZbfgPJNImWwjPYn7SPZGKYsw7esS/7DZpP1dbF02Vi8P2B7xtlNvBQe57ckRZCmKK89RdN3e81yrbC2UiVNGMVlep+m3JVE4/QlGafCWWIjgL1j/r7ypC1rkWRwZhfudxx52JkDxkJTwctUc2o5PxDxo1ion8Si0jEs05pfFfsMDUNa3mqI7RkOhGkcKvFXfH2Pbzm95885ybBav7T7MGoX7IW+LAAazeRt/1cjq6bW90zjb4aJWPqGWiI7tKDqKictBTP50ThvGdg/WiOA/rDqvzv0F0koT6fQZpk+PfrpBfzHoa08d5Tzm4Y5fsBypCkjXhJ+gd2oMnSOSq1NO60AAdiD8LcfhLtu65tZFvD/2NT+C/7HWXS2qvhZzIUKJNYH2bdggmZ9O7P4Tmvjlz8uNq+i0bODX+8HSzOH2GeGod0+wwUCWrvRui3sCuSKwqdaEy801zj/ToA+M39BDYJ8nM28+6jKPMQQIDZbkQEhTYYRCbLMPpyk0+w65H9RoytPBEJiW3d5fol0PMZko1EibUbQbzGIg2wszPpNkZOY9MqGPAlY5Gtmwog0B0OYCYeigdt9pG/3KpLC4KDCsEJYyo4YXFU7cvT2pkQ5tvaR3z/ZWqKEUgzBWjvUCIwYjYfVuEh66kiMh1CTRgKoqEtnxj4GUoZPS7mx4Ut4DQWsO8qYM3I5w8Yq1H5JHSKlJIDOeeI7tkKJL5pgE0XqsyK9Mv2INakTLK9I6UnqfbRwO/mGtUSIBTSbrHdcEprRGeJX4l/X+BQ2AjhN5YDh55CuHKevEI10wSNQqF2Qb5QwYmIU0sjJYsSRQCZ5RMmMWIPlsWEJ3e9g7WTSQU0hijwW+c7+3oHj5eyKeRwljCbKBSYekQBu8IcCF3zR4cQJx3cGH99JwAAj4d2GGvBMRUiug6/6KanPUIRhbEB7G3JySGyApY6BIsL5COjXQ64hJAL6cwBfIOA6Qq7PgXxJIBGwCm5GT1PiRhJYain89i2R15ErupSTBevdcO0XyTbMdscPWIMPg+N9UFWbUhK2ukp2dbdPldsUlHY4kbINiApJMkEj+RrZlTuUAnCTRSHwGPM6gGZA6c9V58yoJUetOW3CmYCd6Exu7QckweUkDmDVOs9Odg5ODo8/Dj6c7TwDKiqNgJqtQb7/fXtv+5nj1Y3CrHMw2N+xVNHHZVY6O9g7tVSaoltGCRgfAe+d7h0ePKNJYrVCTCl+en6EKGRm2enx3rt3O8e8I5OEpZEc/g6gB2287znlULCB9DFGhXi0H7hNHogidr+ys42dT2A28SKaZHuF+WqQrKXDRpA0QhGrAjSbuD2GswEsY3dm7sWgFUyyeqUENoes4Bs9/JVOlD+wqFCLqBpCCiwGoKxgxemkXJpOAJtBPTb7YXYbUiF4ouKlfZcYlsALOzhqR1dFtXbEA40g/8jz3Q3JrppcP4hP0geaJ4u6ysgVJKZX4ancr1ISJEX8DadIjHCxnSrfSh+ub263RrcHaRHdRNfkdj4/mU5QWw2HAgi3tWPSGMsOtCSxCIbQ7YP8Mon/3gqS6zCW16gf0kBHFDAbYmtHWYpZhffyt9NcaaK6CDnsHdELEIsOJw5SIhxihx9o1VuSa8lSrlxADgk44rcbBniLKnqRJR/IkGly7KFGxF1i6dA+0WErH28wrMMHUAKwZ5TaJyzXsiyVRCqV41itFXkB03Q4jyB7oZ4F/b0NhqVasIUTAlxcMvBppv3NPPrE38QGEd7vG9XY5y2jNoc2GrkiIuHzLdWtDqbjT2HWPggOlNJ9plpUlDKFolw61NkrZy945D2tDmAyhZxjsoAxQz05IbFiIsZyMQ50LMhPU7JMHsTXnL1hpH+N7ocHqp2FbyTc+MLjGkXMaYt5I3VA44g0P749lMJN8/IzVy8/v9JtPsc7y7RNuoU9H3F2uIJOFD/yibaXuerILrJLonXcR016dPVS10N3q9lsRh9HI0UOk/ihbPSnK/7btyVV6pBaFXNiNlEBZmmCz1p9CxyKaOf2+uJeoYIrCkFtvMwP18uzzskfok9cqfQivIxAuqMEgMPlP1hWcBPEkCwTLuMYAVQpTCZRe6Kmu55IilwV7Su9TH3xY9QCOpTh9UecpotsqSet1OhLryl7051uqQlKlQ3mBFOm2iwLkZ4UBKKRfXHqmNMIB7Q2Io448xphgGojwowP29L7IN8aBcltOOSm5fo9tlO1x3aMbb2jxu7LFNCmFtUPGPk65K/CZqYYYA6YfUUWMM5eL1rdvqt+n0zzUZNJiTI8wc4lRjrynUX406inVcDlySDFuV8oYGU8NXFVXLY1g0Go9qtYEdTO5zepmxgEftyi8DjkWC0FM2mZeDRa3HIhcGK2isehRCspGAmLx6MRYmtD4MOsII/Dh1ZS8BG2lEfjw+wnCk8pJpPHcpWsqvGVZoR5Amcp9hl6P2HVB40lYweS9S0ao60FC5gQdXXdl8p5SD0qcK62099ZBE0RJNGqzbtf2fUMPWcuLS01xtO4iECVVvb4BtZrBEURjieFiHY2401XKOKWtqvabARxMUqntyMVIMrhM+oxDwQW79pF17UHlA67hFX1vZbT48TB60HspoGeX+RhLDmaasaPRpGyknSiFTSHYQyaMzmLk9IVVh2tNrvRF9hO1lzlQrVa1+ERNrVzjxYrENXWNk3tKEGarD+Pdk+tB/UHLG0/kjDkNLSfZqEwOKTc4GBSjszVGECtNganlUoTA1XOqrqkadHIIaTJvCm/8wTDnOA6HtXRux0vwZhQZfUJn/hwR7WNcjFxweDlK+VyqeinftRP1zloP+WKfuCHFymRKVdwosCVeXa6hbf4Gz6bs+XlYN2n88b1f330ci8fhs3AE+1Jw67r2shTVU+33xp12fgq+xTqGlqy1pPl5Ww95z4HOoOoK+s+yFBJ7jUaBVAgR9nUuE2xBINe4mMn/N4gJqt1p5W0mtDsShf9qByvcTPNihGs/TwaRzG+PsEIlXnjPk2IwZ4sI5QD9BTUC3yf4iXcABZAbDidxKjghQqGBJ/vwASYLnCFQDQmh/Fcl58HLTAXncs2v8nzAitEdcsrXVkZbdO10g8Wryr8UovYC/RvTOSBxAtW0rKYsx0dcK0xnsf3KV+pj0+9UIg+wxCIwaQAoT+GA4038mMxRG8KJz6iE4+w9em6rd++O22xbuKLEeXjLL1nOm+9ScGoRpAXi9gbrawQSXPLsbhdt61fii07V+plF7dyltbrMOm7t61W/3ajWyEj8GkRcUi/XenapUE1BF/zGoQ7m6mWyCuxg6MbIz7SIfbSt/giJcA3rPKeqkOfpzG2H2tE2OiwMwwb7dgkkcrzGyoIHsEFP7twkicUB+ncj6qaKixLgV0l8UYjtdGo1RLvoUDyDTJ0+3JnNgp8NVY136jUN31Vq67RUxUaRRhd8w6IE1YlI0ELwL650CasQFywRD7TKy0TVq4McsuPShZyYuUyzOMrZbC+ZqvU5oS/lshcNHVeB4Wtc89SJWvlfIPiRk/1jzkNM9b3LFWUhrn1VP1jHsYUyrNUIQ0b9r9qi1Rit0gl8y1SyWWbvl86CO+x+7dxes2ClltmsPyphsFArnYwLPxM8UG81jaXfkiEuVJwEWqrzH4e4bKrbB6vbspuN8e/+dKROzasiIoFRwS3edDAREjuQtca+vGJPfCm5zp+32PankQBD55OrDq7+DW55j4IZc1ehsvnVk95o1R4ZficnATQHrUrMDHqcV9S+zEC6CFr0oMD+kkf7u7qAfmV/rQqZmcUx6a9M+q/2MRHE6CFnqa7MI8jcdKIxNUm80UFxeOamOP4JbecUgBriE5RXkb8tEEUkBmNvG/craHFQZkxYVimAIyhSxOlTre4uSub1lnBLNfAeB+0VfU7b1ZlD60eOhQs2a+73AV5R140Fn0j6UH9fIqKm8b89ghn1LMUn2XQAyhASJWnEJ/wUstrE3eav0ks9G0xuGbUcpSxOtzXmXO5oI2B4t/t452tw2MSUPjwoKf9ubvLDay0FUx8QOSfpZXB2enhyeng+JS2ovwpWwmtnBs+gnNFj8i14SJcS9d39e0IY6EqG09JrH371qy8rO3UXqO6XLWxilmux4wDONDJ84SUuk69tk3ibTzN/FHTqtcR3vSomXbRKAA7XO7X2kf60tJeBbLe7XT6qi2t8vacLUd5gd9Z8DK6M9de1BHuSD/Q5BMoCHP8OoqBL1+qJ577dR51qWkk7wfrXfIEBE4kwcabN+T3N2/mmsmg2ma3hzU237zpBcyHpaq3lXzDX6VvYmqxZh5ddSfScRjkIH/zH2Wn4npiAHpisM7DMvQDbj6K/eQisJiPYBJixYIUcwuSG69ny8vhelRhk3m0QSYmBpms1YQ2n2AGwRvXXuz7FKkqg8yi1pj4e9CAZR97zWqt1/c7377FG7ZDep2qLDVVdwHzXeyJ+XyU+U6p92jzndqnYr5z+7jZEC4bSQfsmARO8abyC2My+v1W/55O6OehPyLu/9dBjNaaUDEUOS1ZRPV9Fu917E+r60ztdSb+bXWdW2sd+1aVpEUIp4K7aDIhOxZd1o2ggHaGLeAtAMBVkLE9fAx12u02/DaBXdpuR1bnAYu24jBIziaKNwhd5XXcRFa+3baAc2hYMUyAlsqN1LcZf12hCyhK8OoFnzWBHuf059glNytXKj5/bFVX1eyEz51WYvvOtKCcBBQWPoxPMm6uzLGc6sbJRh5eew1yfETRMmxQ2twHuX1QCyLh9n4IuThZ6k07q/xq4emyyosfaRdCq6tpAoqfYgIqV3qsTajcQmu0kJFowa5rrEZ1XdeakRYddbVdqa7rSndEzayirInZAvpoX7mXMKw/acn6k/4460863/oDqlAjvbEcLAw7LWh0xoevFTZZUvNawqkNUorYb0F1Wy7XY+ghUNiWbHYl87pc1fsf0xUKrmtWzy41nuj+afWKrXHvneOxrN3RWwXhOtHRF2mr0spnoY+0qT/OqA46vnn6IFaLeifjjtjqC9jqixrDb2E3/BbzDb8FWR0ML+VOAj26+gscFw1Xzd+D/CwPzWgZFSOcDVW9BhdTWRVaF7HnaORCvwzyy5vOc0BlY6PTV5c+97K1tGmRQpxZxuYNmOU2aKVwDXGuAesNC+CxeS+mfRXA5IaopPT9MOLo7DqPRhVXj/V3hjU6QzHnMrFGPSrm3DLaChWi4ulCsjFbz0DXmTRz2rw9RaZc1cdSGmko0Fz7qTCmkNcddgsUfThk8xi3w+uvk0qPQ6rMXBxA6YpfCFRV0a8DXPO9h23k0mW84oXFpmlRXuQ6gV0k9KqevehvQk6MhNOVD1hKVld2EXRNAKY0kzU1B2DegVA6Ilntq3IydU/BGtff5eUlK3Kbgml6zWZ5iOtoYzCHuVKG23gJp2om/XVOZrcGnuiH30tINvlBg1ByN/w3DEX2hjFJrXvv1+98gDTvadBCb66q3650f4jyRTRWOXYR5K3qJojPoZ0sotTi40miEdcE3V7vLKKHBtfYJrplAi1IuH7pj7lkkpWxgWUQzUXvbaW7hKLtqjcfaJ+aULrJSNxsUxAxV1z1JoxLjZBnVFvcd7/2GkwOkxpsQ907hHpnkLiuN3EK/QrLmitfCj8nYYz57qXrKeIQVulqS18pqXdwhfBdyvVTl00PUs9hiZ+t5P3EJzHkF6i7atZ1vYQ4L1knGtiH2J0pyRuw+6LuXqTUxxRtSKYNh5//zCumxkIKvLHIci9z2R2C3AmXl6tQxY0UUX3gfSVEM6fsQ+Kc0UckTUvxgLGgSBiODK6rOfzu175Wvn1T368RjmKfbBd9dV7e0kupnouKmvMGW+kLL4OQ66+2aeh4VlZ1Z1YCfv3uo1Zba5GnYGevtyrn9If1q7Q6NDqnYcnipu6gIB+nqs+E5rAg47OSkJOWEGeLlakhshjDu95SrZ6snWUAvcW8TIRjwHzVNZunreY+CpjIS+c4IxhGeAqctm/YE3umwBD7u1lGwmgGGBRO+iqIt5qWp8gd6kZTXljce4OZb+d4T8RlBwlaI7C4UxieE96Iu662DbeVJd/wj/CmGqh0kCCgmhMEyorRt28g/6kXiJczBX8z8fMebA7MbaiZ+E73eU4BqP6S0fsI4li5g4p5nVz10KSFNzDMhyIq8obKQdxPOeTOyTl3Fal1bckx8NNSB21uyZIfPQmv1MSrYfAsxy3iuCVVuJnMnkj0OF3pRjD6fgriE0+CrbJTSkcUwPPwQLjbxIa7je5eQxzal6Y/DiVVmQTeoxqfDSPJmbqrDiMbc55B6lHieZwhCa6MJb3vm/DcPt3QyxMnu+BOdqnVsSiwORZxUV72LSJRP3SXInFClmEQ6cUX33IaIBjJUwerNDKisJRgeLuo6A2PySC3+F7WxMDy/gbdwwiAKMKSmVsKh8H5vmTpSGa8I9EE96zT916eYqLA1BJM/9EhyNU4+rCrm6gNR2WYHlHcdY89A5gH4zaODqEaMQDfEpVcOerCTfjCI6oCIIK9tOK6ZbPqtiWqcakt5DTOC03BI3tWALRatfXXux27gt1rkHwH1BVF8e1FkaqfApo81CZfB/qIAIJc59upYL5Ycb3a0fiCmSoANvxuRziA6KEzQovbhi2IRmi4hdhCaYSGG4duv1a9PiJLFA9xVWnxTIksKBlXm9XwDB9XPPyxuUZodwdSH2N5g0pPzmkGIy3sBX282wytla06eGbXwTOugxO0NeUb1vEMZQPQGevwR/eKK7yto5VuP8RcNuHKilv4vjWChO02h1vDQ69LDXm5kdVdEUIzUx5rMGwBzcqWZtMvXRqq1QitagBYFaZvjSCCnN7yYQ3yDzJYMA+60CtwjYI0/7B3sOM6s5nl+SVQzBpkokNCY45Y9KVG+KUAfPLGVaEFYnK/5tMJKL8kLpDjUCHd1wK6OAeHoCXsDD7QeGSOzVpvh7GFGKp8T71QBBWbpdlxrBubsTlVvDSAyiWHdisTkexOpWi8ThMTartOVWyH2igNHVt0g8pYBR1b7IHKSAKd6sgA9S/8gSAz74iF7GLBTdjxF8P2v59+ijFRm3qEPyJ5ETCXjlzJBa7kAlayLMRTu4gVjl6q1kjROrwW1tj1lJ7Yoi+8rgy0KdiAaJolLefqWvsuw77o9XZgpWRJEFfVN8tlO1UiDyPqHDEJpJCJxNJRv+P7PK0NNe0hT5FXkf3QjJpE09uJx9QR9YnDNHUkXlIpVvv7s7cOt3YeFm0l5j7WQRvBUtd4klWad5pLpl2Or+wrPIKvrsoQxCKKp/4czsZKw2S7zFwva4sg8dIirUTtYfByvco2OBj8+XuQEw6k7w/lBNk4WOxFCurhJexLy8tlNiR7D+sHNneg3hZIdfbOUZsubdTGbJUJyqZNQSG6tNI35LnqgjiE051zCgzLkyngRR4P+AB18gKtCsKdpGFSu4DCjlwaSC5g+SzYS25S5AnsUYyKJMM5/oCVUDMfwdkTN4RWSJIQqJtfJBy5SJYXJc61D+x3f3/fdkioAA73AtZ7NNMk0EFY3MNuMZBXEOxkxgoaNKsX/ChIDomePJKVD2L6vQMpjyYDHu9dmte47Q2zKrNr50wrE8Ym/jogs1RJgMcqaKlWmhI5p0RE6PRTC1ukRHBUtHfU5rySmgKUvOrXyvl1Dstl5irxrH5L0vuEqngygJj6UQo+NLHRjx9AlSUOxOx6RzIKJlMjrKw2oZ/s9LJa8UaV1kjVUVk+2gg0037Og8KxvL/Ly7S5QERpBjmyt01WczPEFL381XKosxzlKDoYHtZK8t2WdlnODBzwG+NDg/10ayNnwGYNiJJ3suO9LouL8pYSmVsKkxcq6xutgvDgBhSzZjmiF51CYyflFxKlgibZsu3bpj71vP8KYKB5P+LdfG7r8xHJrUCdNEVMoClZX+6GzdpY7qVndposmMLZD8NbPwjPeIcmMW6wLvGczfPLlHbNUI1gaKJDzOQJCXBrlMDEJYT6KXA1k3eOHgDijpi6WRl5CAj8x41pR21DesauMPalulneZQ8aaEXrC0Ns2LSK95sjXzeMH3z7Znw62jnAn2K7J8fERYnzFnaLBQnElj2nD0O5L7aL+wZldH6djTsFSwk0UqcMY2NMbQtteXlp1J+ai21aXmy+DxwLlBFX4GYFLoHxyTuzVNOe37alWIXZ8ri70LTUhzck+/BV0Zx6t7DiqsXxLXSijYbs+ENulRxaLvKHNfdisxmfBaFCKytTLN6jtkWMwn5Jb+jTadFsoo3TCoZasIc+l95jxE7Ju8lYoDsWvyabDDlml4hiG6uWEoYoYNeP2AWirpAceGsnwKfaMGSc8CZmKhcOq6PC5Wp4VJroPk9yvCEiKi0vZ5o8FykDiViP2uIadDZ7JAkZOUAlgvXC2EHRmukObNuDMq60KoyeXcqutM+WBVO4QjPVQNmGqa0Loncy5g+9opb5C5kIsrwGIkXbBJQOANcTwwQAIlR81ZmFWhlkJvtSJivxbhyOuyYsyTnFDbmOWcxzSvVYTqkya9fUCNvEgW8fq+kYX2XTZIC/mahyNI/Zgt5W91LBHaGyXPmGEuJthL06W0bW6nyJKdWPykQi0mIvgRYRlomLMtTMWw3XpD1giq586rSRUY4KbUGiI1mZH9Ra4pJF0IxfY8xAml6jChHictD1V6rySuUd36qW1pkAqrAtiBzEcVifg5jbKG7D5ChLJ2qmYfh0HIL+nAGSyue3AfocxkCUq/ZpFiQ5DejPS/HRbsbL32XBg7hpigO03B+RDB9p8ocIW2+WnIuSMmwZhtfmmbLN7yJLNi+ggGvibwbA/0SbCYhnzJO9lx+zRqQPYtX3iFbDpNVBlIQZHBJEYPpr28fT8AvJx8Se+tjS62xGvQ4GH6NlmV6WQVnMy3K9LIeyES9L9LIEyqZqXPBb5Q/ikaRq2BPDXESPpQjmxCl1asVUNxMKfepP2vxz6dzUd74g6CnJVigy4Jy2v2C6nQdeFKhFDy658nZyILrRDX6ydHHP24nVdu6xixEvGqlFI9YFZ5etlKVmVPrSyurGVcXp9CYBMD4mWeSV5ENk+Or4q5ZEXRMPpIl7exOU3euq37saeazLp67+iNQPrhFcb8S+lk7bFLYi7yOZDrFkjKkQ3y3TEA313i1L8rQdDXl0tbM9UeIP0+vpGLOSXBPz204c4l9wUB8cfByc8PsVpUY7Lx7isD1h8+M7wSfiRB3SBT3070GdSO/bUQLAlIbeWPtI5oXemBiMYifbJnFXzQj5x79UsRo+X3HdHstubrDP/IaHVQ2fs4bZ+0iFqZ6ALanNGmS7ispmT0CTVmdNjqpm6xPZm3ynO/nSgNmKho1PMWxmTiU8FN6SHul+Zux/7VExjjHntqV+WIjEXk0HzZmO55ynsPl+jPJpEEd/ExkJhAA2BvYS/PcpHT60A1gV0CeK3KbZNNcpKCsdh7gmxa6P+g0pVkvxoMcYLxgOdz5DNx/IS3Q4fYDYI7K1plGhFRF/AeGX7s7oVb84bpErIrybO1YCd+zdHIThkDxxo46VofQ5JdFjMKNZEkzyUSqV325n9YUX0h8shp5K2/TmBshLZ3zJ72xWAFAmq63d6/JkXoP2dTDBm0bkuSNgjesHltRrt71FS/BqJSjy9m9hOOkVfl2vXliPtZrsqtQ+cY1g+IW+QIzJkMIPf4nm1ydoAJaiusDr+QK1bRUNRHjgG1NR5FCDZLgNKi3yw94YjsmSwmiJwRtj1EHFx+2jPfo4Uiwu8+5cFJCk1xJMXLJJtbT43vVMMZGKbAkXWUSxUUAlPooiXCwukXhOS6W6jhfVtsm0GHipzVOoA6jk+5pwYa40VbCo+W2WtqleTZ32dRxxhBQEKZv8d2DI1sp8FCkgy81u7JvmFBt7T8Vu2zPUIth/fqlY+R/Cm+K5kv+M0MtlGeBNZJRM8CVVsnQ0UvbF4hezB7IlWns5r+7lvNTLeWUvys5rpez5kyh7/gjKnqaT5yWEKDKPmt6K2bVPJSGpZcIWathn3HpVmtayhIihM9+A1uKWTL445fO69tRDl8/ojUGO7TdE5EN7MLVZ9KWpk+z8KSQ771XPkUax88dR7LxEsfNqimECOQP4n0UwyZ/Sg0ZZKIRpXVwb2tKwye76ZaEI4YWWhKL7VEobigXPx+rzhKzEfUgkZEXz8HURP4i8rCwjq3m61EwrjxRIbKf4Xkz4CUK36jxWbFm3rfrJUfefhWaH9W2RWTQSKe8HewVMyBDgeGk7RFnJu1LHFa4MY15vIng8e7leBap0eHbyr9QSyYat3SLxFHpXIiwk7aPoi/uCDeFKO9Cj1YW5CJ8/jsgglusQPve/dxemi2thgWeRdxXcRyTI94mwuQiITUcTcuUN554UNxXYlVXXvuWole8VGwqr9YP2JeH9T3sSZgAyGYtLOJuAq1pdZD6+U5LPx0HMiC7sy1MyouVNFXqhSRmpdihe779jWvTB108PIbZRoUKfWiKeStari8J6o/FPlF7eP0vKeP+U7cz75207NhsdZQPlqsjkAaWIMIAKqsacVm+bxJ04uwMvlnzH2RTHbeiRmbrfPuyhEtvj7nYEcHmZx02g6/ggbbw/3f/AqqDDWjEK4bx/Gzbuo2LUyKfXo8beNon2hS97+jVncrqCNutO7dRgWGEG7ekm01pY/hJssznXjM9n2/HCdpTkYVa8DW8wPrNZE8rJuzDSpcsfZC10Q2BYe+u70WHVLr0nCB/TLlzmGGofwctJk//wG2E8UijkDbnHtAjiIiri0Cc1rtAALmqoFfi1M3mZw5qaGUh+LY9zm8Y7OQ6HWXAvhmEXZOblSkmu2a9KSlLKck+hi4byzYgmkCrFv2UeB3GMBKCjmw0mk/hBPRTs3RyH/2caZQp1yndddAE3K9d6RTVXXZgaY1RUYNFX/+13HkCaPTWexME1yoUhyYucNJx/a1U10fo3jDeTpFSAoIhphBTV9r+59tmtuymysvpsGILikeILHmY8ZG7Qj74PscyXaNs7/PRf4XXRhjZFPFdXeG4V/sbX4/AmRghYFvTNG6Zdos+nZmQLEHQ5JLuI/jysvMscUecLnvqJhs7HfEp+IfdML5R/4t7sFeJPWr+v5F46LmjuJZx8WJD7YTLFsb8VT22V3EYaFU6us9WdeEwlTpulrXx4+/Cx+bZok1ch5+QGnQcISkn4I/QmaP+xgc9t4ed67cUKgpwz0PP1+ksWHiVVjmIvP5yE9FnYzP4ZL6mCjASe/pO8ZsaLZUZ/y0Li/hB1N3uh3zHcrzWfa3SXXioNBGUX+lHTLeRv4sTuh4r2SqKq9yu2HAv8rCLcCoy4LiCKKDbeapK7Pmqs+J0sES4lUZbDZsZykhVUrBsSWBG8evm5Xn7OyxWRSm+j2HdVFrNTCF2+SibbqtNaMf8ooJ0kQju8RZkvfyIv5yRl8G2U8mruCN3y2PSg4CTso79tp7wD6lcCkimDX54PHC9nPxP2M0VnIuIXWlj9QgN/RTGGkV9Bbnc7zaIU7BA9ipnfjxk4UQlAA0yaMSg9Jbl43x2QUFftcqpwFSJRIcTjagXChaEVStRH8eLCRxWRbDNN59nBYH/nmQNyy9O/Dz6++zj4cIZlmVm2P/iDlyWlsr0DXpabZWcHe6fwPYXvs5l3HxpPZeOw2tmOvppVP7HD720wvaXPov4oylrgHwXqPND/wz5qxtt7J0cfBudvOh5N5mvZk3ylWR6mSD7QnwRJGKsg6BqwTz2aj7BMxjYyKsFmBjIQOdsfwKQAckG8C59wC66qgpLW/084PZCoYTkpkaE0hv/rP3k0OfQ/BApsRU2qTbm6lugLMOY196xN3qTGqtjhIMRJ7T5sy0VFBkYebmAOTBGTCJWTtP2JsLgb0IwL+e9wnmk6J3gl+w7pcxXozTjA/hWNs/SIMt5RBRyJd2RMgQHX1LijTbZrkBYWOREwxw9bkTwqkFY+4wqj9/3AJixQCAHQSkiBpyTQqpb0guRyHttEaS1PjevtYggEWOhbGE+AKfIy3U5dXTaAyia62jBJEDrQtkC9uWamdLMcT/FTOKRMi/ax+Kt9vPNhcLr3cef08O3h6XuWobxOBdea1VV3y2agABtWJFLfsqNIzVWSSGqcRKL8OA20QjH63OZuOqSkCMftKRxbhzzqvmcB+BzlEcwMzu1nGRPwI8bcLIF0ufUDTrj4KD2UCUb4VrmdNh7SKQYIiuOHxn2QkFBFQwJLjqgNQsHGpjOzbaTiPa2goRRTV1QmafEW6vdlkHXuTF8vWhgaewfGxswGhtt3X0QdtNcsB35zWHgHp6/o42blSRZeA4nThCQX5QF6nDaGB8N3GBsspiR/ELmSrXTpc6akjlDKbsxpFoodO3dbic05rGJzCBO6fA2txTP+3iyJML/TU94P6UH8KrVWMSix9vy6gQprqNqvqgRt2iLM9PCBWr9q72EBNn6I1gDkncZB9k4oD+8tJqR5OoLaSL2qoEL+VBrDlx+mMYy+T2MYKBSy6QyjKp3Bq2nnb1T8aWX8NberGVqpolxokzYYDv9Mk3JMxtFcHcWc+ypVRYP7To0FTUXIGsTzq/jJlBF1oHN1Eo0q1aqJCfZjNRSdExZTVNQ6ur6itfY/rbb8N+34/7/QjgCNe7T3TKmRhhmKLZPKtlkr+2Aj6NuNNn5fvmrSYUgnHzAcX1GpEehVrJb9pysNLJCgHDBRtqwDItkmHMftadt7uYGa2qqVwu2VanKFbf5y9P77FJv51F9ElX0aoRdSdzcXRvQJs+RVcn1N5MDqefuuSUedcVSpM2q7O9Mhv/wQHZLNB8+xQM1MRKs6Kh6vTLL69XokA/qpVMjjH6ZCfvk+FZIRx6Y9flnQ4vRlrjanzECVIsdBvtfqxNv5/7DdiQ1hrpbHh1qt4HEIsvKPYAsvTq6zMEzYMxyBzyOa+uFqoobjfA2RgevKIW/j/+qFP71eOIxuoyKIG2zKUEP8v4atf6ZhC8Htehzh2grLl5DYMQn1UFClhF7+aTrrt2/N+hqKSvL9aubiXLHQOBZTCfkzsPoWV1b4YzqSFGxBhZi3ZvcxquhLCY+hbXd1aqRVzDINcv7cgbL4pdbA+I8fciuZBROaofx8jipYebuILfwMip4MEcxTci6CYbmWgmJ39RfAchptH+3tBkjV+jrXLCjKdpDdycAoFuhPFTFULKCEBO+zvwdxdJv4g6L9Ps2iv3GKYvIJ1Kb2h53d0/oGPmaFaOAjaj7XSvXTw6PK2oT2/2hva/mLYP/Zz28r63C5KLO2MQ08/2Ea+D/a54MvUf4otfsdsoFN6f7HYhZbWh9je4U5rUZSueV10A+DLxxYIgzaPBkC2mnJh6MwOw+gFEfCXDmQXIcYExUz8sY2ggTSwjvCUcd81CMND3KmpBiU+mu1ZgSRfeBXZEda9IcFlfPwu5AYkw4YGpbeABEyv+nNDRqT6OLPjxaVMpZq7U+3fHmhY9ogu/3U7L5Z9VZfvvTwJ/y/rrK2PnE5g/iuBi8t/lroRVb08d6796dzmlhsTbP39yxe+sIktVSzkXT1Rcdb7XQYWdfqKpdI+g6PRdUVLBK1Fv5xgrKyhXlUNQ7i6romp28WWNIgMQFS7mRGaPBZtyzJ/gjaiOUtzozliCDrBwOFmd1bVlMVHl8QCWya1sEMi+0vwn39j/ZpepZEX0huRJ4u0W0Fv7wSuZkJEjQKWuzOTEzmucBwWlSYI6hglbLFNlhF4MqWzYoUQX5qvGWnRrJ3eLoQbwWK0590ouGIkt6amqbUJgIdzp/qKU4t/24PnrKDF7ar9VHj+ELK55keQKKgms2WfU4E/CADJaSpUVgxuh7SGnMgfx4vIiRDtS1n3hIuz3dw2SYg9FBIovDQgxJ+PQqyYAxKPC8eTIsUn2bgueqhaWvMnXn2PnDisPoJ0FxNeF/F/2yRP57XYeWjZz21pwSgYZTPS5q5Rz8UW6ChkdljeLTSprW798fO9sKmrOpwROUVIZ9bWE1GelYGndYhp3W0GK1VZ2KXGDDKBMu5v6/i30t+BuxnLPx9M6u/76jK3zez+ftSSwmIlyF5Icb/6FnTp2e6F3DiZ3VewCN04M3qvIBHGJc5q/MCxqfPsa/mfp/hRY7u/uu0mmGrqz/ypO67Oix3Ca6AT0x47iZcAR+U4JnrcAV8asKjO3EFbCy8nYv/fjdAu+MicrLhuEgWUYUr/P+AVbQaROtmRo4gTEGie6B4o8aUGUwlQ6B4OUiH+SJdZu7A/hCJfiiwK/hvMJ/X6Rj0q/A0PQlvyXsSaoLhcZxRCHRg/V9ceil/2pOth61opdunselTv7jIWkqu6BUSGpn/xUL+xu7XYfhpiodwopXlPtTp5+sRTOBFrlXO1cTT66u/pH0XTl99usnkKxkKnGCjw3cWueEHpvIaUFX1YnTps0dFiOpISU3N/iZ2MrefCMUx83PO9NXmVsZ0hpGOWoxBoiqbI5qDc0Ng5xhpejFZnWuyOppn5Pz2rQm9d5lWWG0UzryCP7SzWUkVrQqTxyx1da+ECpimTX/DMttbDppuk9sTPWuTHY9F+5tbX7361pBSdT9WoJ0kJ1mINiNqcCYhAXGS52/fwLsVxuuarb3yFdSc7mZ2LMmliLH5ftXVfWQiTM9EXuY2taTdT1MWeMRCjRNRpmG0XxazsNvDhzks06Aa7m+VFtA8cKxgGN4E07ggJSyZIQvuR1cPNeNZZFXmdTweV14/BZWHLbM15DJTUoKZkhLM2metu0feRZM3gnkzv0guqzrJQLhF8fBkOgaxjZsdD6Sj8xt7xwda0zxdzsLJeD3gFy36Ln7zP//Xf/Ycx21VrDdA1CdOVZUWGiYG+KVDDQgKE0/z0bIB4za75IP0WZrXnjuvGe5nWYtTp+aKSL0pZKGk9QeQOsEjrjyzE615Xr+ILnHXycqSF6MbkEwIWf214lfrNEWXflZxAfg4QRldinOnje34krfWqxGPLA+MDUeec1SsJEy8DIvJZbIhq5UNlkUUXaLdhz7HZbu1rV8mUVSdwZsDR3d3VxdC34EBFV3zMZBwOgZc2j0dBUb8uSgocBoKM3vXxAsrq72Rns1mQ6rvwK5G9VZ8nhyF7SC/a1bd9NMaDfjYYFrtpuMRE4XMxNjpF+uaEY+9UC64MFT0YSmXZrSZGTs0EFmv5PuZh1mYITeQMwJI+AZsn4ijvDDKaVA2mniberAizTj2dD2hcn6abuld4w6g41Zk0+Qab1HhNNCcf5iv38wozciJ+iZOoSluDm2S3EbEQuo+74Zr+oZF7as5zTMMZ1y87GqVAVh4hD/TdIyHP+UYo538mJIwQu1GqixCougDZslTK6nFtkbFpForqfPFNJdI1VwsPjbEeJGXjBc4q+lExomO6ZVik7tv5OU8RqmfaD4g/QQ+qNltUpedYSpyUyUtR8k665BLRAoaaDsJPfYoNkJ62BFP+kfkST+cefyA5CDAzJTxt28sN0iAS7gmGABLEoTigKbzhHVOyFbA0hljdkEFIteyaOn5s3iOuHns0n8iP3lz68HxVrsTBljQIvI9npmXpGCOaKYIeWKmMSx0jyF7Bzys0bxTHksJ9vijnoVf03ZFmmHMBdjyzWJ+4e3h1M6iDZFP/nH36JjJGa1DzyNpDuuAUvKvrkOnOfNJ2yH5Zz36pdvp9OfdvWdMfTsI77HPt3FKtTeWzVHT4aivzbdv+fLywtNCVyoJJqXnpNRnKOUzFCw2Q6lmpMY1WqEVsvRtK2GLKEfxRpfrRkGtbpRUH3eCakUH6Bar9o9EamYjPOOM7Gec1DjjJCA4DE3psfhQteefgA/Xmx6JEFOCfjxCIEjrkg2UzyDAvPO5V9eIdF5FXWghJi3qxQjVWfTtjXndVWVIkF+2gOrouTlkEd8etSDDOY4zxs5kvTxVQ9dUnNasS5LLPhu8lFMDmm0YhV84FH6MVlNftfUoqrEAkUcW/6hym9MmnPxd9sHBrzaHGPyuOB3hnzZp7jvs98ZNlo4VbdchTnu5NVuXcDHFV5DE5ZeeTLX4bFhK/sGyWTlnE9Pxvs76pVoEEN9Y5uKGADOtFReyQWrFzUOabq2YWXLsSiVy4Q6oWiRalk2riX3U+FfYmhfCIDwWoEZkWUEk8/pEv3DkvsguL42KTfwovX0JeQdq9+poTNxmM+8sskwZm7ECNxfxtibX/rqJkiA+DVDNU9xHizAbYwFdP0rBhC4ZMpnkM3S9W9i5RYSCpD6oSq4vlhKs0FKCYdJFXuD7TkLAHVdtAo5FLOerAki1awBEY9emvcde+TPm5CWtiUsJKS85sVkDUQ5NqGNxNx1HbVINcXUdE5eYr0oos10mpmldMrWf6c2iHtqQfCSxDWmxMOOy0QOt30c1KzPKf8+iIqA++ezpcr4DhJT6szr1kr2Qkylj47RiP7/XsNMnutTwQoj9TbjhK+yF3mlmz/PHZQdpX3G4xMhFz2qGdCUjMpK8tzQUHn8lRgrVRIDS5evlS4+4fdH/u1oFzcnrAwbWUhIEVmXWM2KIdWyfz/XPZoo/NVzYqvhqS8uX3sPfCC4iVCp0SCQdeFKkA9DIY/JIgrPUUoeXhfl1MAkx3JfMDiDvfZ9f/NVY+pdn/9pc6fubK39fPr8FwbbhLP8Lmvyv4XiLGV8GBdH1+476bOY7r3bRwECi8Y1jumOSN8DKhW5MDy9CQzAoQ110ZyUoeXPZ5wJIUjP0tLSCuU0ViWQwMCPdoDhDoBMp53t+cuB/g7pIjwRyNUpLT4w1E5R0se+n3ENC1ecivJif4s0h5p+D8+lJ8Dkc7iV/7H8Q6xXzywXK8gWtZuqrH9r2etAwdv2svZefkIWGjuno1GCjd3IRXwIxR1RKEkxveS7HEaZshvLSRuSN/SEVcySIhWpUuSqw77GebQ82gIOzDx+c5eUx3i3wZI9HbS1t79jtq7wEJPImLP23+f2obWS/dcWWoWETF65ZddRGXYjJ8XFVxd2CI8kkew1yZt33oi7bgsaudw0E4wFa7ZkIS82TACtFc+JduxUdXfF+qEQUY+qzUzQwDJa9jUkg0RL6bbaHVbT+QQxjSB4gkDEQH1jvFH7DV1zRtXcPv35K46F3U+Lv/g3dCMbeDX3BAIcjLTkoI8/E7XU75MywpY/kGpugXrdb7P56q8fGw5GHtikm/qmdrgCA+Pn39mI6dnZcv6VHc65r9EySjdUDM1ddSlBi1jXoT2kah0Hi9ChNxwtywcQ8E3M9pk+jZE+TUZAMMZNyQbS7Bq7dBiYNv205TadFXGX4fkvmA2Nlz+h/iPZ5enost52rKxb5T9P5HepH2SBRlh1rta2gCG/T7EFqukblimosz/A0x1s/DA5L/PTyUbmdpY4dX9j4smiC+7K1bxIRGMfdbpyiWR9/xSs2jBqM51cMLM6fkTegciMqGmPcuxujMJ6Qq4QCdoIhoBbdPDRC2PZYnOF2g45JIGMqeqKAKHsSzKL1FMbYhLZTMSFvRXK5BlkgTnX9R8+M2vcc4hKu+GTg0lbIUplhTy+VBLLk2jPUvxKppJ5XRSwCUUEotfbjSaX1vRCxFFy8BrB9o5BZreln5LcRMByJd0/hNZJWpwo0yxWy2pIGltRkk7S6knx1Zdc3qleoWd86O1DcbuD+0ABBhmk62s6cZh49TSU8amdqP7gLcx5LXEWMKP8ieRNOk1DqCRyVMF4D1ECxkXp4z5je5wg9hoYbAW85UP34Gun19XTyQC4l8cCLMw/iPYeWP0fh/STNCg9jlkMF0P+1cnpGYAjsKfiN0Xwh8cZBkNEQxa0BDNcIv0zQUA+bB6ia/zqX7I+W1ZZmFsg1YqtVkXCkxLHi5PZ4ZlWqWvkUQ5k71XUezZRqf4vsYZibj4uPP8S0KoKhMv+gXippbMkoaIbQrsD5/OnkPa8g72k6caqrPJm65wtSt0gnnLjndcQ9ryXueZm45xXEPS8Rl9gRHk9YVq1Cb4Myx17h0STlHS1CznvZsaxrJZ1MsKUA6iRjIdkNdKiF5fH04vWsBKOFTkWVR5NM9LUIzUZK30ptK9WUPFgqqE43HrLeQEqxRD2eelplKwnFk/3G3rZTV/vR1NT7riUpwF/DJo775D1f4CQdGGj8CW7OqF8FiZb+g6YVChr5JLxGdwFMLhTQO6IG7pNGFiLYbG8QBM4S4XhSwOlB6S0iniZhhg5FQdHI0hQF+GdUdd5Cx+hLAuBQ8od33qCJJHKyJd+FE9jp8dQxDqT3Es4ztD7G3/8Ms1Q7ejwii1MJXjCMnpUH3VuSQloSnYaDpsQwwG/c4qiZlxSjI7/CLxvv4ZtqYaDHfA2QnakNQHqi1gD5cdqAfEs/G1/jwvhwVfpg/L1rArwvNpe6PWYMBdIf3vPnhA/0Mqhw2e3PhjDJIhipgDaNowDlmpLRxLg8CuUtdSZdn8KL7BIfZVE34n6u2mqlc7O74b94vbxcVbruv/y176IvE5brZa3Ey6FAdV9SStG8l+CFi/GAIfJyxWCYlst08NSD800e7qGvI16KMk6JOKHweh+WLyfo4Bq9d65Odk+5lwgnB9rEzqK+ctelXHRZbrnsV1ylr8Q8XJqqjPuAWazHZhMuexx3kQniXaINmFuPv31rckwZE5stXGh1L8XAfCcliDk4v7VVRJAcXnUOfMky5JYpMx9LowI1uzNHgEbeN+4SI2OWQhZkQ/vKnLD5LDOCpR7/oJAkVQZNC1PLsDjK635XYibfs3b7wToHIU9ZdRx13PQBIQW0AWYXgbiSNgYwr52iPN81FUoDr4W2zTVffWylXkE1cuPHnz5Zno14lNHZgCL9Ypev6r58UMblVqZKpsyUW1WlVG6hVzqTW0pZK/cyKFDlllIqZoBcFiOhek1zKJk0iVOxJWRUjp4bdaJpEbGkclCVfCkvn7D8SUXSLPQi9bVLt59IPk4IHz+mrYy8eiELr1ZS2URTpcypWY34sq+0ehTpIqSvlUGzi84l35+IzOE38bobYLefSpqgByC+ZKxoNIFG00uXPWQMlIeMxkpObKtVLMSkPOaZ2CsTEIGaA/HVleOaUlJ1J05bq9ydWOdfvY7bN3AManEMLDjyNcNZH7j6nUgl9aA6bPKJqV8cIs0bi59GlqE6hkRdJF6ij0cuwMkD70BVCSQeDk1H5QV0d4+rENMUin6sdi6EaeLHlELQZExZGn7zrwiJlpcT/uu3b/D1fSE/s9831fsbrQsv1sbnxaWFwm7jerFYXkwbJh3sPrYDdnFp9gMdPBlHt2JWTk+fwB24dNktPf7KB70riCrYl/sIMWUzMSlHb6IX5qwlP11eVmlQB+2l8nqU4bjkM9RccRdnQCgMwwdBP1QNoZ+2w/8zDeLmwoMAjXLxIZRvemvIzb5UovrPonMNku9LSL6vR9LThWUtmv1mKq7ml0Aw8t9hiVPOwo/Up+s7hvMIqpmDeUSvZlWWztVwwmVn/nLRDj4TetbmbkZex51xE/8TW+gyDEzfHR4LEt9aqsdsILLiQ1wZfI8dt5wtEEOnKaWFo0TbI8/rFMeZJXtBW63vohhaMrxmMhfOzX5nE6WZIfFoiEgPj7s9s3hXK5YnZfQfyuPoGt2MAuqP6rCHFbFVS8RYNppPQOw5PM6Dw0+oIxuZMqkZTvF6Z6Q5Mt2i61GJfBzmYqqTr3nr24t0AnoqkPSLWl6+JZoHGe7UVeLplLhCXSWZB7DIJKhvTgjRpGUCGAufN7HdKMpVLcVyclGsNdxuyBwW4RRRY9RR1Gv65keokiSoAzDvRX6J9i2g37dv7A+SipWbT5kStNSVuHK6/A/iurzMj3DIVLZjnAXz8kqkzr/SKKe0IrZGhGiPglzBt+nIRhQz7lZwPQodYTso2tVQ7IWBpAaAFiliAio1MGJEjmS/Y3AOPIZeXJLAJuwsSpWOvsuCgGQ6XdWWlDWUqs9IUnxGkq6scKfAmllJ8EQBOmnHjFiiPuJDR8KLERzpHUUrh0lawq9a8Eo8LZBHi3RBxF6H6HmnGWnAI71Bd0qM/qkaBGG64cf9KSCe4xIl3lk+VkRbA2tyijJ7pr+jytUDFEpJ8lqGONVoaaROT48xrKYoLQ/IXhFHtbz8rK2sYwJIHryIKq4aBPR91JQF/Yh7K/Onj17ERVFAQC79wFN9Nf1nyh/Wzgg48aouLsTXS82oDCDqiUuF40XK2UstFucN3oJSZjmZ1c9G9WQQZmH7jgDST57Ieusv5XKlW5HSpDiIvsTYUyNrUYBnVMUuxGkfX1YIBTyEK1DKjoLPWY1zrpgSdjCfKgfz2QLCAk7c0axCVVECIFWqGkKq4jaa8W2URIlgI8gvNTdg/nJYUpoSOlnvuNRrL0pAoYyGDc7uxCvNEbZQ1aqVYLgy9VPSIlF4QZzFgtv12w7YceF0indgYx4WpLTdEkdt2F7NR2YYwCwmr5q02w/WpJoo7gc1fVTQppkP3g9q9Q/Wqsyp+4MaPqftkvdvT24SNJf+s/Yf4xi05PBjmGFqAR/EMz7K+o0/s5n1fyva2+HnrTS5GdzcQDvh0HcaxAsHn3SRIAXUl+c+iuNGQGDIJeQw/BwpYcnJ27O2g+2R8JPUadp39qijUU7+JHeO/L4R/dKgdWggIf1Sz0h0mYwxBtKwAfDst0BEK/Ea19h64+zkbeN54yAs7tPsTkcCVxB2eRunn4LYhqB8LEdIjCzHPzTw3XK70TgD5P7jPxLiZnUdZFkU3IYNKgfyduMkHaOLE3yFtUjvVIPPQRTjn73Gs+3B+bPGs/3Dg9P38PN8Z3D8jDSEIVG8xrP3h2fHWL53cHa6A7+c7GwdHmxTkAKDbzREQL8uhZO/s8B9+DsGCMSfGGwPfpLqN1GWgxAhb/7IUzylrVWlrVWlrVXW1ipra5W1lYdAuqHaGHXvShtpYpDxJ6agMmhlzGzIbMTP2HgJi/IQHTjgNn3D+Im/RJJKaoM8wgyHJFqQfFN3cTmbeX+Hi4KzG3StEJbt36Hxzb9wVl8+zx3P6XbID/rHC/LvGvl3lRaTf191no+xgP7orpIfr8i/L2gJ+Zd+73LYEYUdEdgRgR0R2BGBJcXw7yUhyb4xRhbjg8Q9Zc8bO17Ig+ATmymxwvVr1NhQvvnJ/I2vma6+GfHli1ZrZr6NLMitNg8ZxJ7Ad3oWIrNjcTfPisZ5A5+7Oto79W5NpVVYBLY6qzV11rJSHT1uj6VSMzPDZxYjo5HZftiWlMcoVrP5PKfX+fZN+1vEkTV5cr/Mk5QTTqLv5PaTqMztPHgx8NwG/t+Hf/D/6+QfxoPbRs8YQB056RQ0REU/w/fmT8Vt24LbAIRWDGi8zWCWGiekm8b+KXzZSsfQyUmQ5I39E/L3FGRnBtvUPfz1DmNsgkTFX8M0u40C+O19GH8O0T8Xft8bTwLQ4j3nNBilY/yCgXdyrN44hg8JfsHQcLAFFrSHjxj9MwkYQZLvnYrEMtwOdNNpd+m/q+zHGusx+N4eAxuBP99SnQNl2T7s5vKP4Av/g/a/FRk5YZ6VX4vSVDAhD11UfstfeujllSBFciaf0qIEMACNdXwCkg1gOkTsTcNmx60H7HLALgeUqiSGVBJPQNXPwRe/27EUoNfZPgnDJEO0K8XE678rH6mK1AIloFUAEvkc1FJcXwTjP4smXwWrHY89lvKWut5Sxz4QQGr3/23v3fvbtpEF0P/3UzDcbiLVtCLS7zhKrmI7ic/6dW0lTdrTX0pLtM2NJHpJyo+mvp/9zuBBAiBAUo9kuz1pkkoCBgNgBhgMBoOBprBbXZhp7IcYKOBD2trNf7Z2989ODroftzSdld9eoDUYgHpXYf/zGN/O8TQg2a2THU6+qmvB5tJeoXS7zf9pSqd5w9a0w+DsOgCRnz/HLAWASOgg3AkakfZhiJ29o97eqRNp3nx4ddzrHR86+BKLQ8NQ/2A7QtPbjutt8H/NkhzCXqnHbfzTbBqa7P7pm1y8aEzTUY/xL0FtzCc6vcjQaD6U5H2RrxQrQecN4spp83htJmMCsxg4AVGPArIfasqGG4NAIooVoMDYcCxMG4UyNaaZe88W8gyuu1TI2qUFS7x2d/MnscpxkJDWHBGNpKrDR7V+QV2owBoHe3fXsA8KBuZGig7Nut7Ndh9RR+BS/+SPESyC15N+tvu+AIFBd/UBfTubu/gWUKvLdgGAePoWi8kvURaLGdfgtHoikZtSKrcqG6rEorbH+ATBMwOwJlbqA/W0pqP2NPAHx+PhfWWtrTDhsFoGArv/XTo/LISwS8rOM0Uohim88gtl90n3IugeRqouFrZYxBCZbCUIDUrj7+xF6UxjLCFm6VxgVKVWjP6/JyG7sIZlJ8G4f9+yl4qmMHVyIHQ17+kgYnhhBCUaJJlPvCaallQ81YvYTCE1jKITnm9XFZ9nIImtKCX/2+jWgg3MPX2aNWFXJPwLfs9wAHhG/tC6xrBolXUZBgvsXoqDRYehhIUZjMq1vLCOdfn+INU2XtoelE98dnMSC1iuXQfbbBNZQcLn6Kzl5xlGKnVKh1KXUoba+shrvzl6B2+bopESM0dRHLQK65tUV8lAkODUwSAj0Q0IeT9YPSjc+oPCs+tgm39QuHMOCndxg8KtNyi8RQwKt+agcMsGhVs5KFxxUMi7ZcNQgM19OJqM6FiwzYVLiE7lohWjRlWCoeLqutgOHtaCROQ+vxdUS4pfRl24mC3lEoIqBfI72bJlxEA8/85EPP+uknhYeD7ikeor7v3fzUY8/66MeP5dgXgYjltHPP/OQLzcgGSgIYlkYgH1nwISuxLHXKSUGlOu2WGrkHLQMOspaBncRFgkYo60hJY5kEpSobiOsoIBTk9gaoIzz25rRwkeoik7F1GzBpQSlLSCCktxphfJSdGVkJICqGRkxXQkZEbKEvJ55vldST5vEeTzpiCfONcN5POqyOdpyeeZyecZyIfWWwPx3o3D1LLQQmuXFC2hHRZNysrWUySKra24fz1O6akw7RQ3bRB6P8UTiQm60wwwKDsfGEoVJdTHbJX2pIiO8sQ0blzQmfm7ZObj8C1hgIhjNjaIGKZmhtSFqVnCFgx+cKNRCxjycu2AAWmUBF7coCvwwwc9e4QDBgN/WCIJdWNX4yjTefHUo0YrSkmMSKzLYBzE8Jlc+ddBgaQCthKaClAqUUUEOqqKpzJ6sp7PGjDLhGMmsp7XD51FyCoGzioK7HNzUCw9lErWc12ALMOxVRlZszOrctJmJ0iWXQ/ZHDQWm1RK5wyQh6Aa5IQ3UDwrUkn1DFJP+RyRmfr5eaCBA8qRYM3YeZIppxTdbEwotqrGaM/beBn7gzAPDudqBr9SQxkvFNACM1RUWm6oR6+12OHVZYdn10S3CHZ4c7LDq2SHV58dXgU7vDrsMCmZaYVkIh3N5VLjH02DbErnlErpXPLIwTPT6yDuAw+o22Iejg9ZMymqMWkNIZWaxFNaKpjSCpHEfQFKtkYJ5peQO0cxE7WFFpQR+wm3ftDmiAuAmd5QZhlUZBZZFf6OAuZAPAxHsG+x02AYYOxCDP5jBeTkJmk90RhQSBPLrSgERGNKoUUN9hTqiJE+7Ce5ra+bJOHlWKjuUaPWAWVTS9+Cc4eB1YIXrmG90WAq4XiOL6mNburdha5z5TvsSZJGo/B3YjZDb2OLvERcnJMFzCrzCwAq64sYsjFQdLhJa3XPreadZ9fFtEjeuQvgnfvVeOdW8c6t4p1r5p1LHqq4+0bOhAvyFRTvyUjegnKG5C8oZeEbnK997FvmRSbloxYyof79brscACOmVgIdw0iIT8nySeC3Nsvhi655BkCdo58B9PUUPowSimRyLlaILyKtVcKRblaD5R11a1Rd0dcxLEbDgIPljpxaoHEKI43D7vrx5zrwFc2lsAfk+qDb2WpXwXgdd80MQ+NylgAc8gW4tWYc5Dqmrzq0x+S9lhK+EzPiPBjMzqgasJy22t7M4JBaVr6OS6pU/vcI2kZlVhQ22s4aTp3co9hcxuVloMQmFvoYoKuGuYDHCwA0yi8ylJsLd3ZlWd+dXb87u9Zwdl2whv/dZfa/0mV2Sb7j+t2D9rsH7eI9aG2VYvZ/wvd1fmfdP6X37Hd3zO/umN/dMb+7YxrcMVXLypQOmcXiJYQnUOTAp2Cr0zRjcY6ZKvLCRV0ln5C3UCgja8EYZSTn1C6axeKLIOeCXTVV5OXkZL6FhUIGcsoehQYbXplv1wWBsGvgWABppSaVH3uiVKCBZc6Rwjch7BEodbOwM+cByAn8QC2cMQFjxRAQ9uxVEuIb8nHeNgt2Lp8THWvyxpVyKAcrMkpAoeeXYFc1sS235xknA2xk8/4kaXBtJLiIbAH8k9pWcWwNuiJsxvrIn/Q2CICWt+TBsiToT+j7YHI/CF80bMnrLGVLDlZki4BCzxbBnF3NFrTc1mQNPnfW+EfTrolzoRxizayQY0UW0Fbnh66OdORKTmTFc+6S2mvyC0HLeEZQVfGNmNOreaecM9RjI+1uPUYWKlgoT4vNn569EeLgfZqXzUqDanJcKVXGfLWCqnGgHiRVD4kqjzmFiJnHhT0N5oWOgtoOdVr+qx2oqKMmS2X3ukqkVWzUutqVHfHVY57qUVqOcaFMq+VpqmWY6HJahrwmp3L301JkVRwquKKWnKrWY86F7ONeim+hrJnG9b28l9UO8BN87RS3t3m/h/555uVQgr4mezNH+DJUVcxVneIrjrtNFpHJ+bI49yZm/upwLoDH2qbWu42eSI1vLLlNNh0r1dlJuT5bbFMpZ4vgRe5qUOo5rPFUqMXlEl1JZnKVxqvBumg211GM5EbPrfYW6q/PUb3+U0RYg5+l+o7eqaQWTys1HhPuRXO2tt6jY2+Z2qOvpT4TS5QfA+oa7KxWgYrOPzUFcYkSpMO5eEFcQxXS8dCoCRXRTyNTtfqQBmUtmVqmFQn+VwZOHRGIchZJWEp4Q3HVwlLOCtaoi3A4REubkQsCylLyC3BFuotI9AQXvdiqKJ07sVURnEDWI7yIdG76Sy2swwapqWVsyDHX4kYObmaKgLKcN4LzYC0WVa1ISt8rlyQT8sWwa/YbbWOpH1XMq7cU6YtUMLFqKTJ4dZYzkzl2lvOQ6MlVeqKCb0625e0q5RYFU1h17ccpjT1FfH0iYbEjV4H+YbwBZG5IDXYySBMXOaIy5nE32zo888p5doHvh0/DM29BPPNm5xm+FrBYvnm1+eaV882rwTevgm/E+bmca7cIUs0xhmlOfvH2lHKLAMnMmp4ZBEkNVhA4EyMokjI2UO/yciYcll+vyySecMvOrolwTnYc1rx2x5oo3b7TsKQBfVgehePmTHftStpXg4+H4t27MlRl3DzM7+KVHE1XxEE5CMeBGorDgKSEfT282gSadJBUo5nBKCl0pKY5kj2KkvJ2WQNS8BwFJ2IznZVXGSU5kOGc3GyIzC5mGHe+2c0L046XRnipZJiIaAZai8Xn4rjUoVnZRpxOLIpKt0nO6ijfHGdgmk1xjsKwGc6vxJh4N3P4DzOW+heTS1oyUwgQE75SCqthQIxI9DQ2hAIpuzE0QzCQcnRzUXyBAUHKsNfgQcluyRgWpPRmlpEfCwgNUoFwVpZ8nfAgpXWUc0YXIqQcnYE3JWFCSm++zRIopALhYpizqGAhpXVMwxyvkjlePeaYdzv0WqGBJT9DpnmO8KIlxEcESVX5GRSDrNWl7KLNx+0q9CoNYt2qTTGVMoWCFFnBiuoZwK5rlpLdLSO7Z1cUnYvs7uxkd2uR3atBdrea7K6B7G4Z2d1ysnuzk92bk+ze7GT3FkZ2r5rsnoHsXhnZzUJmziAqVbimDsVRhXAGHi04lEo57nrBVCpw1AunUopkyoAqVbgWy0d3IXx0vyIfawZWqcBREVplyN+JUwKq4MvItNxNmIT4ZvYjHlOCXCLh3/27TsC+Ey2nE9LLrPSOstoDhutlhkh6RbHVspcytELOs/zVwZwtDJVhiL2nuTr4GW8s5/VVi1kCGw7D9J6pfKywgRyEjRwkVekuzLbpbzzRS06z9bjGxSbS21Gxbs21JX5TSbqcpNxHmv4KEr11NGP/qm8a0f4V69bcI+JXh6TbQsoFoX6J2UWNkd2vYxgh7RMsNX2d9aOfmTr6sl2jz4wYD05UKQVupWgvUe7nnQcL+i4ovguK74LirywosjqF+W9o5bF4z0U+eJMLVzdbvDJTFv9T8BJlplShJrWvQhbpsQia9VsUc0Lvb0sOf3/SnPre1jmcJV2lh8bTdfJWdyB7m52+3spHrbfsXPXB+Tk1yXwndhIOP4beZUIcfRBUKc5+hak/DPudmP08j4aDTvLQy0Sz3DzEumRbXIojXkGMly0MNUoSmiOcgUXkDAfzbRXcED5jNzS9dUeLzShWWBPLvc4Ahpvf8xsaY7E/AmEIw0lmKvMvrzQx+5ITumC+rYLP2MGkji84urUUOphovLgT7qudSB7ZZEwe+ulVi9gzG267/WPafAof9cQp6XV/FplK3xMR2t5aiGylM8nQ2n2SaWugS5u6n2SNtJL0HraitNxL1mT6S20zTSWNZgBZq9l0F5qNM9540DUUFTIGOWWDsRRvLn5XG4tppKkkM2soEUQo7k7/Yg+S6978Xt2Ugv7JoQ/ZFX1dpEIx9KEBzFPAruLfSdy7EQiDzknaeiv8bp3uv3nb0wAeXwCDxE3E8cUpShZQSklXXqeNo8noPIhbR/5RswgGSlINsGKEze9RCb9HJfwelfB7VMJvG5WQSdL/9riEcwcI/A8FNvwel/B7XMLvr3rXeNW79f1Z7+9xJL/HkfweR/L/ThxJvskteXpV8VuXS5Q6FBJAY9F6LFYaWOF2SJ/BzM1nYmmVutnrqRJQRj31vVST1WAWF1ozrpnoOb3vLKVTtfusqQaVliY4ib5mf1mjRaaa/jN5yZpxLYL+3vz098rp79Wkv1dGf6+S/p6O/qIZy0D7t/HvsGIwGGsUpFfRwK7CNBPllcZUqILcWGRonA6pSmgxTyKuVCgjrGQcrCAmsQnWomh0gaB2LXRzk5U3a3ra0mbKR3gt6yhit/Ks26tgbPWvItgWW1c6BLCaUnOemT+kdWVMIgBGTtHiWnZRE62GZ5K1dkrnAgOOEiYRIAsvwMfRsBpTKZt+Ow2Ihxx9QV72QmhZ4QVT9i6jILHwHDgJB3jmSsvQQg4TUCQiLiV5ZOEZNx7/xKyteITUOghACbTOh/74M6K+jyYW7NmfANvZfc1BcIG3xZJJ/8ryadmW9ZvEaalzmoPrPFPisFxMPMQWzOzlnJ3arcKAYzGcrXS7+G/mbNExRMo0cVZ0GpFPRko5W3bhT9PZGqgWwuKat/+IDYPxCaUnZWtIoqlmTVd0B6USM7Hzm4CmohqCF+7/8bJz+rKXoJna/bkE13SbkAU7rxvR1vNbNxev57JuKj+lt3oJmoVxyp2XU+7X4VRNz3Rz8Qqn9Emgc03KPD6IicZ4Fh+OB8Fd9uQm/ZWWuRRRfPS80I9HILcGIY1WnmNodjrtl7l36TN7b6z6mZYeyQnWFyu9vw405aYwIPEiBrusb/RXqneqRY07iXAIwFre6N4EsY+LJl9q0cIjv8YwQU8sC7iHKnAaxJDMfOH0x1wK9aUjVUp66vSTHXZJxRJjMUe05Pc5Tw3s6QXQ3IzxtrbgFPwRShlYdGZkkVB2xlNMsbM1+AzJl5fkYr3U/eznTNOFeTplWQa2aQsj55QDdmXqC9KcjLoyrr5XNFZWYApu8ipKaUmqYebQwJIoyzy7EaCClgRJkY60qImGhULKyAeZNx5gKA4TlRj//X5h7AtFpxr9YpWlVPsf/8an+VYyDq+v8Rz7DkP60gAb9xht7jyObhNoX+CDXp2Go4BQmJrmQQVkRMa4OaiS9/0xxudg3mM4xVAc3fhxiPI6eWb9cLZ3dHZ8+r578G7vB8f64d3Rfg8/3/60u7+LX4iHDHzuHB/t7vf2j4/wR+90/82bvVP8utvtdXsfTwjM0fFPP7SsvTsfnzmxnlnP0/QFaVnjyU9+PMaqKT6rI1f86Elz+/lTgG5ZH1mr++ggYA2jywQ3E7CVGBD1lm41YtbhfgQ7mNsof0NFIHblRCWQGKtEN1VzNObJqkUgDbdBgAt++UAjMHahzBQjjNdS69ElAkxcqpMAJVLiSEGkCV0TElgJNnZ9ELMXoFPcW3iAMfI/434uDsjQuiW7vX4cgHrH2AHKExZm2hJWVMGEXQJTID8taiJ8oRCS/MH5d5mWlDlOdcbQHe6hhbrQMruegws7jDbgSHcIfRrcH0T+IBjk13emc3/sgVaTaV1p4YHwYXAZjAcd25a8x0UnvfvuXZjsS8rb4r0mRW9bgzq4cG+UpYbZUQZUezJzX9qgU1rL1vHr1wf7R3t282F/HKbUK1XhZyoyM6jy4TH6ppUUmdH3Lm8WdcILKp3wQuKEF+LcDJrhVE54YW0nvK/jPhdd3/einh9fCnbYR+5/wVO5sX999Wd3SctG3iMivSjLZxnk/8EHbok70dfyBZtm+H33HvuPe48hKXDXXz5qEMquKD/1jl+LZZrhI7S9PLgoLPlXlOm4C2KiB8Rc/jagFY1FGQQKGtGyDv07Agd7gXBIDFE4TAkWTllYOazn7tvfC44kvHU6PqNGorIzg5dYSnSXUtkzx1qopWoMqmiMQrl8SGRgdhWW2aSJgGBBAkLAOM0oE+lROsyo3e0pDioyVEQrVYaEB2ccBDdhH4fT8nnkxwMrV3nNIkjXqHpSRABXh12eVSFKRMCcUGlFJMGeJiB7WjfMH4nSmUGzvUxqCuOXSjH70mKAvlQXjY9q/4bWH5BMWwNdvsxcRXHKgqUSGH4VLwlA/eYdobjUXtBU0gUGkLWfbVS+5mVsQnExjuWcNwbznZNxgTgMTAuEWFjbxY+WDxC2oUT56cJVFCWBdUuWBoqHzkucrbeg5+PrsknfH8LakEaMGDl6lSJ5DiGLAJjRRthE/rc6Bn/3xv2zeOP+FV1gH5wPulgvvGRAj7VyI1B0E8RD/zpPuI6oOt85TFsn7Lt04VN3MXVDvTm44tG/TfmO6vklv7yZQ7fbDpZg/zJIIQyvfDOV5uTLUNZwf4ALa8fl1qUbdlPyEDSUcJyn505Zak4a+30amZ69Iu2WGZIYLV9mZ4Xa8DQMyjABiseMGfyM5oS8vqrVdTIcEGlNV0R6MEwENrlMAgN7HDFvPIbTQAAyaDlIqo40MaoIHWsmNxWaa+vgy1chn2qDtAOsUL4RIfPWwf4ktM+3Ac7eYdgPU9iGUBvwNTCeTOYwfclii1A8Bb8SmkxjijCQ3H+ETSahz3w6me4VsWxbW6K027woV4tENlJ0HJPaB55OOpEBZb3IJIDQjfqO9NN4wdfxfj8QRye+7AMTISG+8ExnKXWCL3d+Z+Korq+1rStZv/HnCj4e7OBS68DEkmnIg0vFUYnLUSk+wzSB36W+1A/ULvenGLC9JEa7GpZdG4ndEHxdEfkzxFsvYpi6n8qrWApGfXfl3ZRaROm2dmfFVjWT+KC5Yk/zAlXO+uTMIz8ryyQo6y+qN3kin3lMstBKCoKFJlO5wkByscLWZ/FwX1qhTRHcGBC+UghQYl8L5cuP8DmiQa2+k3uVk5hMWGg367lcZSGOm5RLD/flAnlUN1k7Eaii6icm5/nct7xIGQ2OBQwHPUnUugp+60o+IUuhUO6trqpnAmlUBa1s127BNhEIDFAWBbZL8ZQ/C0Kg6MMgaQTKzhCtXswSwSRqyKvj13GZkaq4Lqu1F2wwSj41xaiFcouMqrXiLmAnKIv+5YydyPGdYf1tAfoOdvDULniGLhIff3j6w+HxUe8tfH7c657+YGdaOHQTX2QhNw46UdrKfvAgJgIgjyrTKY16Iqslx+T+xYfsEJkgeh/nFRYipPSOT7Q4PmY4dHsa1yvf1LjfclOz5qBVGzS95FHHhtlHXNEH9uPHDYE9SZNDhXootfthViDWF+DDIM4Ax3pAToNxBhgZAAUSRBmwrwcmQbdIADA/Ax2WgFLL2TCDDQxkkEZMkIGnJeDZSE2b/xf2hLnf7p95XzgjOabcVxZoIW4x2eGXhSHwxU2mmkcI+O9JEPxOlxBl25ktt4vdfaJYMDpP3qWixsBAyyhi/TNt5Q7udCmDUoXlC9LokoWZ+TKFIkrSbMWVoqyV2eU1u6R0ZbwM4v0eJvQiHroTIgsScsCER0jWaDJMw2XyjhiFxbOyFtd3xdqKaq+Yy7RfqYCgBEvLo0oOLmUM1Phg6ewFcsEZ54RafblpVJ0RHzIzgkAvjk1LLp6ZUysDl4mVC96iiYSpAkZqHas3SosFS/uZ05vd+mRvN1oNLgJG6K+JA6Upm1xYBSbLC8uWDDC8SMEOwxUedbDwFcx4rmMaLHnBeQaLUP10g+WjbrBwbNrBwjPzwZKBy4MlW9SNg+WjkVoVg+VjpVvWnIPlY/lg+agZLB9Ng+Xjn8N2R+78CHErvpvqvpvqFm2qO/luo/saNroHZ18NqLsTfPm+g/nr7WDIIZm6daEnZ3+5Pcsb7NaMG5cH500wzck6DrYzNBBiH+TkXjgKzlJ/JNjX8JAyCzLYeRO0dsWE1snp3s7+2f7x0aej44P9w/1eFs2ZvvaWBV2+whs87JH7jrc2+5n9tzZv0e5AX4grAxd9nbX2/wVzC3EtQTvuZxDqiqBqLVRSSaPS5JUDMNYZtW0PVec9FcFMXUQkJJV4/jxJuCWd1sZ6LNVUuHclZtIbxBJ4ftdKmoYKJbKJWEYJBEoQyDYXXgwVUl6TQIGsFh0FssyMAjm4RIFc4oiREkQRM0XgU7Vc+fbPuvXvcfUYhqMwpQTIonuSVSXw8SLlxWTIo5ly716BVvwKnlhzIVqYmEmv3UngeVwwSdZKoSOoNDU6a4Tj1NplQLa2XLlCRzpPsPAi9C2Y8E6IyUAzirHQaDqLvMCAhFhnbCEQDxKFtcB0iEhA1FdBlIKlfUqEBz5oOUldHeRd5soq9fYTzsPE6gqHh0IePTgUgfNDQ3HZ+1PsfXfFmT70z9lG+Fs7rUy/EX6fs8f6s+yBZ9sCiz0RNkxslP4ld8MVXf4T74+/1vaYhpZibmML9V4pKKum2DAcLnM8scuRlF97Z+FYOC5hAXEkSowijJOAJPBFKXzBb9Nw2QRLMGoILesdgP8exBH1gxxf4IMfgdLmQnMLy5QKwO6/q8Xyhaug8sNWa7txMRmT1MZd8ws1Q6SZIWKYSjsw4s/AH/fBH0Hz4eFO3kDtjSej/TQYddJtZtTIsF2mXx6C4gaLbJdgt1TIsB27CzpKYjcdsZhbLOACqKuAtTVwbQTEx4QUUC0sA24XofXgHJ4UUKjSCR6ajTfBH3/A/zpfHprN7Rs/tv41lQM5k+1uR9lNel72T9lJenVAyQTuFTaM5i1mfxInUVzcquIrNuQtm6YE+EpCJDVna53+bYqBC97SyBiXnVHQ+igmtLrvescM8g4zio0mybo2a91O2lX78v8LG+KxfxNeEt+tr7ob5oN3lmjXQtmKJ/6yrlQGpuY4DdqVK6pXbkG/cjVdmymQtFB27q55ctc8Q9c8sWteoWteUavqTalV2WUI6nVT1Jp65VpTT6M19UxaU0+nNX0LDTln4KtvdkIkCGpDv/JWUVjrAoO3Ft5wlPBMw0ChZOFSZp5Fr2YKoPkFTWGpKXTsVSXbCt0bBhfp0xif9dMd1BlxT9/lV2aOFgCE7r/Scbe4jKo3VvkKWXrvlMZ2tc1Fq56RzFcKhvD3KBpZ/iSNRn4a9i2iy14FcYgxxy5gXbVGPmjMNyEsu9DFFP2YXwo3U3nV2supPDO/n5qBy1dUM3VBIIqsHRidVtgt2qLUKpSfZgDIhdXOybmkd0qBrHuKjqP2r2zgs76pE1kqV1NciahaQg+1YzvPyXumjGZBRatnPfqwjCWsr2xEKnR4Hl+KB+dzmWafhukwyAN4GV2iqQJLr3UKR3FYuuTYzi6C1nFfSLOipFThxA4T6ZEdyU7lzvyZLrDNx7ljgzt/dpsE9nOg3Gqu8f5E3m7NbvIe7L3mZ4ejsldZR2VvsSZpcG3O7es2VdJLo2okCfFs9E0cCrvLS/il3aR5sE9i/5oCbHHzZdxj5eM4O+pksSEQ+jN/+Bydd9mDssOw0XbW2tIbvE0RzOVgALSJcB8DDMogwXgcBgDcNgKdBgMOwdkYqARJO/l9h+x6JsYs1rD3mZJGLm+XbRpZrRWbRgZluqVFc3XwM24a8/rqbRr91CIb82zHyF+TZogMvaaXtBhIqs6nb3KT96NF2s3BrQYqhNZTi6iEzYXf5R1N/b7HqPoCGSW99EKDA4pt/qQCGhVzrew8uIKlLVu7R8VbYyN2UWwk3g0bydfBRlO/ZzGqfHOC90REME1Piu8+jNhrDyPxbYeR/KIDSlTTGTRkiWogA63RB4QkR3tTtB/LFE6aIY0eMGNmfq6Mq8DXjKPD5sXO4iLpfNVAS12N4r7gOEt8PShzV8B8W1ukSo7eWriEio8WkdsQjmx64wh1/giYnrkiECDJC4EuZXnbstXd0B+EL7xYIhYq7dEbXWekLUOGSu1LlkE6k4Nlvcn1EqU7Vfs70ijd7k4tPEPXFLQSRl0P5Q2fDC71VLvd+89p1N15d0JfNW4ZaZ3oNrWAEGVUCTW082e8XiZapjl0yTslWCbRFKnHpKw5pYSg7bKu8RV5dE1h9dHCKjloKiEHA8jIwTRwlRxuGTk8uwg9LTncqcjh1iKHpyeHqyWHm5PDVcjhFsjhlZFjxS5CT0sObypyeLXIsaInh6clh5eTw1PI4ZFNcq/0WZnCySW90m4Lv+jdoffGO+vonxcHF/APz6k/tNCr7pT/bnVfnR0fvOvtqXfNxx9QJJBt39u0AaWid+PwDss2MA3v1DeFTeh9prNvrdVzwXW3PL0L7q4ff84DsNd1wjU5C2s2zMKdzr/0gaSP2nssOue+XOxBZIXT+3Q+77D7IW1FUOrW8b//O6ah6rI7rizzLBoF+esZNEwvjSPJ3rlLrB8Ou6f/3Dvt7dNnMw723uwd7br4lTx14fJHNlxdrveDFaT9Fr6hkQbjJIRNCHqlRBecnnndI9jt0isG+QUEYCgMWbw9k8BkDC/Cvj/GoF0JNpFrcXPcQU5nvX6cfqubx6np0nEq3TdOi1eNU90tY0mCmTqNb7BkQLax8IxzT8EyRSRHtfF1nQnYUCNvy2RGFpjI/nkSDaGQRSIxD2E7DMOTvM0SJ8xTOfPIfmlBQ4NnORxFmrBXQwDbIPZvx9ZknIZDrDUmDxj6/XSCEYcAF2eo2ImiPVvIZHZtEVywb4srUapfclq8sWgqVFer072Dbm///Z7mvistXTY6rs3Grrx0HRGVsQP+0iOOlnI3lqIz3o2l2fLdWFakeDeWrcSMXAoNM2q9NJHqmWnFF04vK6yE7+NUsPP9o2nri9aLY3WtRABk45w6G5O7xxhaJYu6Tm5utayf0cUPzaRRmkYjdvJpMi/eS/bF+6KB8V5nYfzql3XZ6Pkr3NNlXfkL39CVe5gVExxXW3/d67ojqfP8CgRL5X7JRVIsyEX5P2ejYUx/Pdep58eyC5fongx7k5+jaNRZz58DJYk0CkLxyOwsbYEEzk7GXh33eseHwubutO7mDu+tXoASmvl5AOZjJa11tnN6fHDwrU5F19oO+fN1j0OZ2kMPRHtBgzMavYslCFeF8FQIT4VYUSFWVIhVFWJVhVhTIdZUiHUVYl2F2FAhNlSITVtwfRAGomGu7VMIC0FsU8EKa0k0sobBDSzssBf1rzF8Mb3QTR7VmlyDCGnB4n6LYQC5PoA+TsvX+IpC/jgeky9C1eqkFLLI3BRBU93kSws9otOvghiFeCtq4VKCUCjeU0Fjp7ccUJ4GcR+Eq38ZiPQg5CBUaoFwirO33yzfWmv/g91NI4/FX09SAXeGlojvcIDXaRS05I3BhLz1eB5ksSIvcbOQ4DY7Rh7y6xf0mZJsBZDZQjtnYAzNFFnDwFXmMCH4TY6wP6hH2Gl0bT1lOubij7AlWT3LNva07jayGxNbxIBOtmw7mBg3j8EdDLwQzQV0apIyL61883datvk7LWz+TvWbv3ylUsJQiCtQSTwKBLM4nF2KouJZKJBH0O1BZN1egc6DgpK+DIampHN84RRyY/q4a27XEZxd8+ARYr26KBJifhZOQiokxZWQ1ueveU794fs59X/inJpHUP4LnFLLXfkLnVErHft+Qv1tTqjr9aTeeTaTbgs+0eb7CKP/FttV6ErU610OX3LSSetJtNVUhAQnaiHbyKunmBxJ0RWMpjN/MAYkOIWxzVWRUG45oTxbV2IqQrmzEcqtfi4UNx4VlHINlHJFSrkFSrkaSnnllFqxdSWmopQ3G6Uqj8RBiMVVhPIMhPJEQnkFQnkaQq2UE2rV1pWYilArsxFqpXLuRZM4vaqg1IqBUisipVYKlFrRUGq1nFJrtq7EVJRanY1Sq9VSqpJOqwY6rYp0Wi3QaVVDp7VyOq3buhJT0WltNjqtVQqp8K6SUGsGQq2JhForEGpNQ6j1ckJt2LoSUxFqfTZCrVdL8xvY2laRat1AqnWRVOsFUq1rSLVRTqpNW1diKlJtzEaqjcqj/4DscssptWGg1IZIqY0CpTaIfTxRQ3T+ULwfRMNiBE32JjuJgPiJhlujRtx/B41PrR56g0fc7CkCuTnQbjS4DOJXw0mgA/RywLPAly7HiGArOdibaDhQQGD7dUqeyA0GGKkiN3nTfNm9id3C8e81MEXLN8s1hqto839NXQEpaAXCr7b5Pxk+DtDj/nQyDDqTtHWa/Wq93v+wtyuB3mV+YR8DKeO+e8e5cxw02sIDikK+y/NFk72Q7/F8r5BP1XESOZcAfQilbLTf9Gh0GJL9Rm5dduOWZP6Ll82DjBLErP37pmxXykaTJZL3w2iIfMfXkfeT/JnLbpIQ15l8shyf/yvop/gu8/Ht+CSOYJCnREIk5NWOZusiivf8/lUj6Lz4El40ghaxxiU/wYLYsElHEjYi7ebjx49IqV+CX1tvgpQEUSIJDj4R3mwV3nLOzMbRhXWVNpuZbEFHvlxSSJPN+AQqiXwo7nSUYiXCiQQZoy1LzAhO4mCPPFcaDMy4RMFoLj9VuXpSWCVSjV0XfYmVlDC9xCphVWWslEkErQyeSVtZWqb6RrvlnPVsY7H5OOvOQuG627UpSeyWkdgtkNjVk9g1kdgrJ/GKbSw2H4m9WUhcc583JYW9Mgp7BQp7egp7JgqvlFN41TYWm4/CK7NQuO4GcUoSr5SReKVA4hU9iVc0JFbUGgOt0VNXOBvEr3Y1qhL6kyJ1UETX972oh2/a5XZKzUJW7EaFD8jnIBFOfYaRT91fEvLsd6I9CLW6Fyl2njiJoyMOeXv7IvABZeBY99EEtOJ769Yfs5Mlei5BKUeiepCH5zGFnDIt94egCVL8d6BRB+OJzHqlU4YxoECJg0FFoI4KJf9RJ82eFjNovcxBMbodB/HrKB496qAeUlHqpVymhdQW8/cvjoJggDrUMwUyDkbRTbCbMYOSodlU+T9zRCJN8alH7RQudTv++MZP2PGifJpSwKVnt+pfVyymMNnga6fdkUwfr8qAZkYa1j7BUeiYtUxDS+MpjhaoQFPNqY5+M1ek7RwR3FQM09OzZgi4V5WB32R8BiKKQeCUAirZNAHh5O3sLGHhVAyz0subnV6ejl5eKb28Ir08A7002lG+nS85SSSX7IsTViw7Na2kiitdVC6yVlgX4V0wwMPwQYSr4L3VJ/c0qHvGbTgeRLfo/k3xD16K9Mzr1FM0zxdoKhRSqCqYQgp0vSu5YkBPHG1DkRJKfniKIQMCY9FpNM27OrcYaBSogm4p0vROd31ByBIoeSdfWxCNRAX6URORKbQaObEtijpeaBo68DKzkD1rZI09PQ32UK6mU3x6YtI8gZoMWCEnM63p6emW0tOzTYWmpqc7Bz3r7uBrE9QtIairEtTVEtQ1ENQrJeiKbSo0NUG9OQhac79em55eCT09lZ6elp6ahUiw2ZZ6g1gn+cMKpuLTkFcqOPUqJre6xkNuuE/zQ3wQBMOW5wXIVabhUNzS46VSMyuEmvX8EAAEpojFFM6IVvMCewSbuSkMvBB03S4tPg17pIJTs0dudbXf3eB+7I/CPnOTJhfNElAswmEghJzH6EnRDXIQvTDz/X85v4Sm6PklAAj8Eosp/BKPMQr8yg4xqoK02iUlp6a3UHYaJouNLWfSCOcI3gNCAH/IDC9oKqCmFFQDo2HApxF9lIXc+Cb5kfXvCWy1hvc8rGpg+aMIcsgF1lL+ZW3Ucy/LFniXF1E4l58wFfhWOGUy8E94dbaoB2mQlLAyR5XUwTQNY3W9Kd+ST5I0GoW/kwudxKBFH7xwRVYUsKosKQAITCkWzphTPOGrZI9bzR7ProFkQexx52OPOyt7vDL2uFXscUvY45rZ45KXNPBFh3+XxH3tnXYGUX+CFxZa/TgAOu8NA/zVsHun/CJU77QVkQNXap7Ek1GeThCTt9U+p62zvZPuabd3fPqJBo1gULuf+j4hmbmq3ayqDLiVpPfDoJXf8aXmNagmhH68ekN+Ggqxu5AHwUXasVeu7+xyuFO0FFPA7SHak40NfQs02VZx9aPhGTC64xVq8a+vQWfYgRUSvWGzbOxAPVogpJkQrJpXlyItTuVaBUTNUgiGrPmQRmdpLN7BgC0Fuq9kq+EFtJzEcBEPC65JCIjDYDwJk51hlFAE9NWYaKQxrfdOHx6cn0N9YFsnzC5HoP3+bQi6IOLuPOKXOkHViHFZIrZxfl8PIVJnAQP7v2nIGgBBL0uDM7z037HH0S2ID3uKARjIhw58KIbjcRC/7R0edIJ5Bmm3krxdTt0MVKg7zLhHa6XB6Ds2uaUH6nWWnfrn++NBcMevAmclokmKVxKQMuOAx4ACwf85uB9Et+NO3HnxJW5dx8TdbTe48CfDtMFaxGAacfMhL0h0X1R4SVGSTJJivG2lA52kBchJKgB2a6Ps1sZI5lIO5PfT8MbHBUxoHZnc4bjTaHIwkrI/LkJhjQoY1sjhUM4MBntIwYMwSQPgXsPOOmVraNesLDhJ7SIhy4qRLtsyBcrgGXOLQ6IwHGv0rVvoWnXxvIfdQgcNC4uEuLmgZaCERmyI2IVBU1lI5h9PoieNXKCr6hBPJ1pQBpSpPdk6kBYXLkslGxEhGNXJsI7RAjw0dD4/vjwQ2FxparHfwsIDqlCUBGeTc/wBWQ/ZvPlSb5lQ1onHj8246y88XexDIC885fJaKPGQz+kvcy1106wQD/Q8ujsegLKdxtG9QHWqZBxFg2x5Kuaw82xxVJ/mA5NmTjnpTeVqCrOSsmXyLJcV9Sovkza1mtCdsgXlslVbpIboMJczSQ9ypZY2NJMLOrWBznoOKc95DfwDX+gRJyj5g6DTsbtxHN3u4mCR5icXFUck3hx6oDpykXfX+gInoGKEQHW10B5RZFiRXBAJAAk0OLAzr5BcTMhSKdfL8QFEadroALhgU9uPeqldUk7xUanXmqyyB0GxSaeQNXNJtzLZnetP6bcUfaW7JfNjBplaO6DGlkdMr9U+bqACd9KXtv2MFTDs4gh5MJVgeakSrjsccrciifOwwTtQ7yj8HBb3ek7MLyrQrR+7rND3h0OkWae4Z8q23OIirdswsiGbdyB3pufo5TnBU0nrr9TWH1S3njqNG40EWVgfOth43/hvZYYIe9JPNEfc4xY2x25GKB8nbb3NKwGdblCLRfJAkzbxuLO1UCXbVgqWi2n78d+31tdWt+1SPZWUqqFVs0Uq4dsUNIaziQ4sroEgjSb9K3J7gGJJWiQlSFpD+t54xy2I6YemwtXf6TZUZSRLX3LFtYaMpVaeoEhiQsJM7otLg1QjEa3kbB3lq0mnysBlWc1TBxzaoY0qoinMP5m+NDQw+6WEYqDJD1KBL9ORjVnr2k4A/8IOGy/b6Pqy1AlbEQmBg0vXH38ATJ7Ui64xJcwSaADTbXKW1cgEEG8GNnGHepBSIbhUaBGJKbTsrkEta6LqT+mW/a476QxKuICNJMwwhw0iXjsadMuy0hWRBkDH3QBWlGDQpY8358YBtgixiaLMQc1qK6Lt402boYyZ1S7YHB6cV0GVLbHwTBYbX24b/vOKYlYwLSpiWcjRGSIjkFc7fPVi16ewbIq7TbNU7r462OOCOQPnApTHQbJ56CFbD0h9Jju2e31nAWA4sP6+2cY/AH9/jVeWQtAPYHQEF+E4GGSSRMWDPmWv/VE4vO+EhjYhyFn4e9BpeD+mT1eaIBlfo/tZw20u2ZmI1zcQLZMYmcduG8Huzq58kIEd21qFvvB/2K/48txvsIB3rfZa04BCEh/0Rys3EohR3QXm5YOEhWIUGV+MyCjmssCMUgFlROcL+4KMHrkC9iXXdDSzU9ZyxOmVIXjQzjQx5HCm5feHgR9jiK1okjYEgCJRyfZMRsm7UTKxGQIU1awSKkvQuLjWZi8P5hTVs4UsL9kS9uUCxAFbL7bT58qA6aNygeYDvqxvp0tLTSPQL+mvwsmBZl3cVooaLBc6gKIBI4NiKwtb1mfp0ReEDzo1O7ZNrk5mdrLml4Bv2bYpvR8eRKsbbYttb/OGwbK8HVQ3LOANC0saFkgNSzvpUsi3T0u2/cD5/xAmHz4ej+k6jTegoQuPxInNb2u62Ln0hVpjrjMAi56bc5e0OT+hGvD4cWBAC3oHZD43ZuqR0pvk2S3TjLohUDespm7IqRuXUDdU2R5Ll1zDx4/jFtcOFArn11+zw0DZHMIHHZD82zS900mbUB2MvSE6JMEYxuYLwzguDuOiQYY3G6frN2z4l0xCFCab0AeQwUEnBrUHBSFRPhUZqB2ZD4qdQ1gyIBGLJHt3/eA6bVDRTZ5kIetm4UkWkkqfZKEA+ZMsbNWdZU0uMXKoiOrYOgxlJJMHWzBLlqTtr7hyaLXxbUURcSQ2cRtVTJ9byOSuML0WK3e3Q8HNQ+fn8bIRmgnsYMuaz1QIWCZQ8+zgM8IPsOvOFSaqsdPJg0ECDkJ6GZ/ZhvRjQjQRxC1mQ2s61KQ2YriTHdgVpcZxVSDQg25mpPm6+/WWt1CVviGXvuT+YPYrt7QltJVhcgyEEINh6vuAJGeJItVDaX5K22zKjKu5mEHURtA1d9h1T6bDbFeR8EV7u2RGtSt0sYcu9JW7sGTThcQhCWv0IM17kD4UTAGoYjw8bL8KCrOiYyeZ3wzmC5vwjv33iwH+IRmyERjzXPxD8gRDAGT0VwP34sImXl33sWKbfBWU2ybxx3Zhjxs42Xb0PBrcF21tgvKp7XztjUZxhNIjj8KOWcYg5pAa9esKPprbSYWlpGQHmkbXnUAPmgnd9rZ2xuYK4LKKuh9Hw2GFaujERt1Pj69CKdwOX9A7XdR+ytTPhplCjXS5ES4XyjSbKjlgukqoaX0m3EjRRrDciJeLZTS48TH6tMbwVY4FspGqMfPSYYkDzXbQwwW5l+BeJG6l5GY7H1Xd1ulkjOPveAxCIo7CAXQq6XAw+LjEha7pJKBa7B+dvOvhQmVyBlKnBMD5l8EHh35+bKIpuKTZg/MhM1Bjm7st+B3sYMIrJFfy7lrALRjPymosr1Coja0O8BudhJpTyAFaCBYYaWP1xx80lo+wO2BNS1nTGARfs7TihM66/bQFOT2W8wok+c8hrkWoJYfP22zLsS2sUtwp7NvIhXjRciFZsFyIp5QLh3561cInqttOqk5jo4RIppQQQiUgK5J6smKWBeJ5Z43ss9cYjGg1YU7Rb5mxOEnJO9hn799cBf4gkzVM/3zyPLm5tKy70XAMwuQqTa+fPX16e3vbul1pRfHlU6/dbj8FEJvuwTr2k6V06YltXQX0oIv9xMAUr6K7jt222pbrbVr4P/vFk0z7MBhm4068ZD9Pw3QYvLCXQvj+lP1oOgHLf/IcCiQvnl+EQ4ycEQ46NugOFlZmW/f4f8gL3viTJAn98avhBHf2HZvGZSFe5WHftpIU9KWb0KcmZs+2nr54/pSihC+khiewJJD6LvEe0zgBzW3UscnXIR4AtR3oVBNqk/KTvj/EIGXLLmQ9AR0wJ/jrKEqF6z7QucsX9B9Q9IXNIUGI7YN47yFOok7082cmsTERWpJT7GlrDapQip3F/R3QEoUS1z7GhunYI2vT8latA/hYbcMHfOefa+vwCT/4J0mHH/yTFIMf/HOTFmMf8NeyfrYtIN8QlLbV9sXFahtJHEefg459jk+t8J/LbNxsZgnolwoaYccmRzj207xHgwAGZVDVKXfNIq3CLweWu2V5W+Tn6gr+XLPWMBnSSF8gkfyG/5F87NMW/U2Kr64SZJDmbgpdwg7N3qW8R6QvZCCS7jCV1UmcsRM5Pp2Ew87bljw7/WzfgXNg2Bmax+S6s7yO425pvESGF8ybkJV529IOrKaDmVEGxovFarGMByAHszwNiyhC0gc+4J0hJwCZfwie9z3bnb5tGckj8dujw9Btr+Rf3PYGfvPIl98534YolC5j/54kpHhKNImHDdhvNMmEF5BmWPNP112xLYtIcxAxgPAZ7u+3GZOfZci3pXHwbPX6blscCP+KwvEzMhC25eHBEjVtgzkwa5dhqF5cBFuke+Th0zu3Y69CR+7h01sFOemx3/AJJfMx/fdgBf+oo9ozjepvXMOGUsPGwmtwPVrDmktrACLTKjBhoTVsbCk1YMJCayBUkaqYm07ScNzAsbeyaq0zYbqJnxttmu6229bWCh+RxCiW1/z6NR4+169ZmUn6XreVwfFVej29iCDLxLziAYRBM1Mi8HwbVJvLYB4ZeoicI8uhSz7h/2ue1bXW2viX/nFp4oFFvhHgrfyTgK+08S+Awh/ECIk/2xIxchGJP5e54tJureql3nNyh/COiY+OvbzS5qOIrbgGRSurFXZXz6zzaDgAFqE/AEAv4/X5i+0ZGvTC9VZAAYU2SfL4m5GPyfJsONGxZQujsk5TQJfZREUNFZ4Nr7UGulpeedtYeRwM5IqnrXchJPga0+lrjjJpzGTT9tS/JSHp5tN7QA2n0nUj/8KUgPWp9J4n0+PVDUtFA9hgIpgtPOR3fQksr/XrMi7ye0ZcLsO1mi0NrGGYMCOu9baCa709My7sm4QLE+rhmoOHZF7NNq3UZXHL2nJJjav5F/xH9mL4RR0+5x7+yWb139cv8M+UDSiMuy1XHXcif2kddccdx5WPu7q48jm/E40vwstJPN9KvclUK7ftWZtE3rorSOYuiHOXKFqra0TaWpvr1gaSfwVGAMmHHa2LuS7mQtIKjgYAAUBNccCJqA+wFqxszpX8yZ+xE5dxcP/1dLPd8DJM/SGL/zD3HneVUIz2nn7Z3KJKJ3zOKOmrsZapH7PICb7Uelt0qV3zZl5qV9vmpdbK2dAdX06GfjyzktwP4/4wsKw+tHodpn3/nn4CZVfbU5C9Ak+pJWm1dDePWOgejy1pJAE+t1Yr8KKMqrOLJNyCz01WwcpmcZu6kApWlQpWNxdUwdam3AOU6AvtAa9gValg3h6Y7HqrzvpqwdYcYwCUoLG8QV/CtsV1GUXiAfzDeb7s8V/La+osp7O6ZIp7JVP86Qtuw84n4N4gTOfWdFc3yXqxmX8hexjIgc8Z7HubG3TPvrFGdyDrG9YKLjTrnrWO6VsruHGBhcNDEzDdonhbs2vUVe1ftJxdRE/FNpFgGqUt8spbJErk4XC+8bDeJhQ8sFZBPaAHGBu4sVxh5PU2cQE7QLgV/Nzy8DfrIyE7WqzamALF4e+MfP0q7ZBHQhCstldy1XjL3fTa7nRjISd8L/aTOY3tKyu0SzCktla5lk+G0Rpm1J6JBrEGgsvF6wwGueZq5NryapvIMti1E9nGPkjqDIJheYtKyC3az+xjLRfjZchgoGcScErCyYzfxD9ziYAD1Ra/6bEdEVtcPTerdJp6xJMKsRquhvBquBay4Go21+VqNtuLrOabjctFc7vmCF6MJY2ejqsL/Zl/E8wnXTx0DoB9HB66MqPhOv5lVguyx8vzENplB9b5FyKQtzaELySLWCHgm4wdYBAtXZGhDjV7lQjs2VaHP29npLG3sra5MshNu3/3vPWL/ubMo480n7Z+fQ1bsGat5YbnjTaVeBttOQs37etr7KgIyhdnyAb+yVvZX8c/02mmgjBeJ1tdaEo7/7LZluiFpgfm/QCfYg6U3iRzWG5isIZ/5mgiEjIO+mR/vL5B9se4PWH7BHeVe9VYIOw2cddglXNy6gbIU5k+lzLfhN6kA36dj2nXI7Pgd8tkTao6THfb5vbTKfnMPCNNrVHG2uvu3kauZKm/azRE1cBrVVspj6uGjmHpWoatIvxrWtSc0m7BMG7BzxzCW287nrsmL1//HdJLotOc6+ZXklzKaJphR/2V5dacDZxXas1ZPdW07d1o/AQDmqEHM8ZxTkCAtexMniVj/zq5iua3Q6yQ/Rt82dgE2q7DHzZCPGtzle4E6ecmavcwUFqw715peWv8eHVtlYyUA0SAX7o0l8BxmE2yNcB9IsOGox++SDXiDAIcZBdJ9pdSJhTwcBRAu7x1OYt0AkfBbJaMvxAFpHG40cY/udRfXcc/U0qTHWrkJTbeNWrjXVsjNl5v3VZH/ubWWrC1XlHjet3NPV6eU9RvZzy1Au62gDibLSJANlouLFqtFUrEza0W2cZstpB/6y2PLmmbKIUgbyVLhI1Sa5ODb7YB1/pqlgzFt3gBz+NIoKo1iyInye6s4/PP1P6CSe/iIud1u73qb3pTGnKAn5zbh9FN0ItIKJzZeM5FNnEQg1HqZSIbJHbmvu2t1rWgcHxeW8W3ORe+tXWCD0/H+ZKyLiDcWp/exIOznziiwCdZKtfWs88t/NzcpCxfW6d2O/hc86baBdan7sJHyRSc+Hp1b1VzbfGVL4LD32DS4k2YOefsoiet217wrHW/wqzdWqc83WK83PCyzy2m8BKewm/C0w1v5ln7n5y2NXjxFSv/D8/bmXn8VectffdlXt0qu1cDnxtM6PBP6h+14eVfNjym9WZf1hgh+Ke3KtzFQQG2PrPW9NUbZti3q4Q+/jwbkfuC2i27VqwRtXtaJw0DIuaD0W6fe+0LW/V6o0d/q3jgSo781j16mLpFjRpbVNWkZ4GG41WVHq/9cBgM/htocnHhtt1ApsnqirW1RRXkDaI0r9HfuOmj9wO2uGrdprevINXbZCr1Fr2d5bGDVHY9i5XAlE30XK5Hx91onP5zHN3+V1DSPfdhCRB8pVbWVLdk0s1pfKW21lVfqZeZp5RAp3B8Ef0X0Gg3GlwG8avhJBDJtNb+CmQKdWTaiYb+9QI224rYVYXqgqS5Bm0NUdwdDA79+HMQ816W9e6Rm/+17RJnN8LHtmoJId27D/AZtm3jJcqOPYD2xMFA8iNcpQrL8ursLvvrBZf9J0vyJXg2BuwicaazJRLSZB5j5ODaJT0Uz7HxYnSxyzVvlsrq1Ho7l6/kyyax1CsDgNVBh0CmCa4yLTTXBLGBXBFc8TQHOB8JB+s0XrRb7cV+EuBtiGF0eTkTRbVH8itr/EjedC6ytu54q/KhBx49sPuUm2jIJMv1KjnrQDOiR66mtDFxq82gtoj7Djmz4L4+Lj04WcW/9C7LOrkpraqpNCqpQvfNTUJ3VPO5g6BAd88rXMrJ6U0v1mmQbbVrITtHgarB9g3pUzgRKzhPFj1jDRcCdR4KcZAE6fswuD2J4nSeuevy2xprzAuFJnjU4lPZZu0tU47Jmw6RyB1yxkPUJf5J3cw8ZrX32FEkfHqbTDBkX+jhnsssIkQn29SpV7OzRB5MGy3QDzdaqC3j8WF7o0X2C2jBdd1Vkr6x2UKHf4/ZZUlWe4VYdBEEL5gAHPmFiDbdFr3rgkbf9XVqqW3Dx7qLGFa38Cu5/b8G20qKxgOcm2i+/dkq7SsdjNAB3dKG8yym15OkGb7e729unGvmlCUe6m208OikhccpHrmuQ48pVtex8+3NFtOINY6im8FgfWuz2EirrJXuukYBqGjjOp7edq21LdzgLK+y4xfY0rTtWaasMdSDJd2vXcEdQpcY6Vxr2aXnN1vosbrIWmXn1F0SwOD76r6g1Z3GlJpFU67UI1c9VY+k11LNCiQbGVz6Ej4RZfSeuS9S90jEe88cGOfGTxgu4UcHxsXgv+ft5+6X9MaBxypaCH7Sfgk/af98+OW9eUr/zjxIMuMl1XZWBOPlZj6o3U2t2BOPmlbnK7/Vnqm8SIyD6PJ1OJzBi1IWPqty9IMV7iK7KvlflLlcbF7fKfcqVxSka+sS0po4Lf3VpSyIx+oCkHLRy5Fubi4AKWvoalsm6Wp7ASTlSDlJGdIZSerKSLfaC0C6pbTUdReBlSFdW5dpSi1Gc9KUI+U0ZUjnoylHurkIpKyhG57c+w1vAb3nSNdkpLM1dG1dRkpPqObFym8LbMrd39xcQPc5Us58hnQ+5nOkG94CkG5sykjd9uxNfcJD+h3JIf0wvGSDxP8/an2ioQY79EkKIQLwZbCdZm+r9O6v8SGhlL7m09n8sRAF8anbfvECIdiytv5jMYZhBkMCK7olSDAmoleGgQT769hsWbSdvCPY9n0M5IxpfRZOuZPlU2wszPJueCNCFd93sfuwpsYhPiWph6OPvLjtH7utS4wj6g8xZScKLgrxGjUY8EXKiyE+5OJP0kh9HQLgcVhI0bKPMMgaXnlp8Nxfgl+bD3n3KG+FUH8EOAvZb3ph5+R0z6bh3HlYyhEo6OG4B4zAh2jk1FdRmkYjlpE9HdtJpS6KcVKD5raYRUJUs7pJ5PEXbrCy3RRBxKc+xPQLjFVJkrNOXvuDM3yFjBqjadhsRrPnwXYzxXYupVlEySxoIPS/x1mU5qHPgZHpa5gMHwM/bshcXLaXjlpZdQ0Ceggtu4JMVwR1vAI0Ad4l74GpgFYR8C2Mu6QI+awIeRiOJ2lQCUuBzwIg5ACAl1jZ4TBMeNpTYEL+UtFK01nPSDyMCImOWvDl6Lh3BiyRyIeTDvtGO5OK5Qg4KctG8/UkuWLTUxzeOAQeP84Sk+th2MfQmQrYMjYyn+484Gk+L1IUerxQ55dfiQA8lwXgVUhCRJ6rWBpZivDGQO4rnInN82nEppuJza1qsblZQ+id+rc4eH3bOddIvXNB6p0bpR7kYK8mCXns3SQVdvff200ZtuTRLR0ckfTd1k+kFSf0qcOCYNQVJC8mzlSSURKYdNbr9t6dHewf7b3d23/ztldHSOswnlNxN0tj2OuOPR7jl9hrGmuztoShQ08xUGIqoNiTkkYwvvp8YMvPFLgUId+QStIRE4yTKE4wvnaN4ZUDV4yvAmDtAVYoGfNhQrMwh0zJIm+WNn9UamjWqwLVGNszZnMGfBQZUIDKxzOgOyTrb93hUySrdvyYwNQBVIBjL+px4uyjkHlF0gzwygOMckE50zTMcqRk6ETkhYia40wALh9nRUAqweuMFi0righrC7hiUTKs2sbs2QeMhj66AWMEUwZMEa74BGOaxRhOTZJFQNMkMeaD7Sz1cP/IyHb6RIHAeABuYUDxjh2OryepLef0r4L+52CArwpJ6fLrPFAUZZytw0ownEd3tg5Bwe/AXiowReJJU4uGKuCU0DOsKDk6zQsIV/74EnpGHhQ8b2WvKD0U5o7KG8BHORNuh0Z2nJ10jzDKtLBhsPfH/eFkEFijcByOJiPrxh9OgsQ21Bc2HbOu8urUNrUzEDK679/UHzAAbBgwmJMNmLacXjVgcqyaAZMjmGvA5GgWMmAQ3SIHDOCDkTDTUPFh0fQvg28wVA67H6aQLd0PJtkCOVrZAumVsiXDqpMtGYL5ZEuGZjGyBdAtVLZ0P8w6VEb+XT2pos8oGz4zlWEPpBhtMHZzOy6+Hd+HzCC2t+m7PbjR2wMGMwrqKApIRNtL0mI10PrHGYrg7jrCt9sZBvpTg2CcITB0OiYZuCXNdp6VqpgIXa6LaSDrKv2aorXVLk1Z8pZTqVa1tFZrp6DBzfaYjVUVwdLM+1gdiXXqnBlO0ec0gLo9ZG18Gl1PLJuNk16tx8FF4OoRJYIpZlgdCBlxmc6t5vJT3Xb7H9p8SWFXM8+5MdWQn5mZM66/ZikmpvcKb4rDjop4JqNBm3wpgc3fHy9pELeP5+6xRdaLMkRE03w4V8zVjii/Mpc8+RHPX35VzOMnwlZMNJGL6b8Ev4rPRaZ//JFS+6MC1NwmW8thQB42LdaVFl+sxNP17eBFR9noFl5ofNmoXLySSjUjkXWLRFQoEpMWkRRUh2QOfSFZgJKQTKcZhPI6hq8sVaoB0gubBeOSmBuq4KVrd/MZ8NHIaxhCwMVQfnsTmiuluL82c849fiyOOGYUx5EIIOGgg1/RQv/pyo8Ht7A93h/ANInFwxYOcRGH0IXhPb7N18B30OPGdtWgfJEN6KYCKp67KFlDn5+8AP5TyqfsvVKxN/OezLwbh3f4uj2UHV33oiQ7omHPTrPDhgb+r/Wut9Nwt0hgU7eZv38E8zuFLH7gkaIF3Q1Wfmyk/wAwJyg/5TkXDk6CylMeATooPeVRAc2nPCpk2SlPobH5KU8w1SmPytPKU8Pe273url2mnvdeHe9+tMtmbu+0VAKSbEki90Ei93OJ3AeJnM2f/q+t/iQmr93y4yJ6qrktrWPaZ3QlCGUa5BnSJBDS5dNOx5gXUi08Qsnt4/+G+L8r6JPOGPX4cSNC+8IVdFJrfCDvaxUAhC0nAPgZQKCKx0CRsKRtkxJ+2+rmYNJ0yuGdRIEvY2QFqokk//o6+QcwoOKADjPOH1UE+mK63gZt//2ijX/sHIKoQQfiHkO0bMtgp9J+wgyHJ0A6qAI1I+DYFGSwQTLM1fThH3/4+CZ5KXwlzYT9Ktlh2QW2N53hlD3r3lxqexZVNlfo3jfqmz8t1/w7bd+AG1N176v3jEiEyw6fpT9eOQOYtmWyGObli0778ePBc1Ee/4Lpv7ZwacSlHcg16JTk03pHnbZzTY7YqRAfvAC8o+fnLRBwp92fdru97unxT2fbdJ3qE82gG8f+feOy6fSEdt7C99u8nbdci78A4Ysv545/ucVGk8P9FL4LrboVWtXpDGi5HcCHE7X/y87S7Y9Xv3ZIoVE4FgoRq5O4XO+gCB4WSslV6Uv5xbr8u8pSFyj4EWB5+YH18PHjku696EE1vU4JRPMBCPTowkAE29b0kSf6msQHRHeJTIUVuPnlulQL2KaMNIKAIrJ9K8yx85Zejxyg9nMQ4b4nI9dtPfl5WxDpo06n/VID+gx6eFs5D68NEI3RY7eJmNlN5WdiEXGC3uar6QUO9+d9PsQvgLzlxHJEYvV/ufg1a3BRLGjoc/GPqzp9F2RV4wLU51qlRAvDKBpHybXfDzR9l/dv101ntLT0MOj0cFhdU6eepiyqrou6H5FaYjpKJbH1r2T3D6HN26QzDa3PSIHpr1/jrU7Vy0JYE44i4tZD/IzGjkW3U5afWsMAlE4LFnrHgjXRimILlg+LGWKtEHZOV4GVRtfLhFsW3+8Hid18NvqGLYzGgUU3jLxRsO+A/POIxFx8VqsZnMyqO0BR7L80trN3FSSBBbtm2ghsm700kjZ5tCNxdJu07GcLQmRZ7xIKSW3p1gVMugkWjiwSfhJybq+iYcCoGKRCJEoA2LlJMIPf3qBSNoE1UNr/TGAgT/K1bJLvf9rNbVhYk6UlfKMXP2LyQTccsNuwURgmKAztMmxf2JL/y+RXoaeIuuEvdexte+lyyW7AYtdkjwYLqf7NZZO9CSzC+neQ+hB1/KXf/jf+22/b9PniTKlIYAN0NBmdB3Hr5Phsv7f/fu/T/tHr/aP93sfSfkMTn5N2yrs+XE/E5F8QUFI+rjol+WzLePXc2CZKowmuY5fVLUeNaZC3fMBpPELtY/zLAPswKPahIab+gnCiJoIA2JMJJTOBzRWQgUYpoMwS4WXcRfhYxZ8pHXr4EVU4Br/igm/uWEm/nl9ClTj2jBBYzR9/ZF23ti077xj9FYu/mg9DVDBAOzcpBFfNJdx3LXUmdHTCYLx8YHakiE9PfjrGrNGmhdXH9+fxDmTqP8Nl9Gk/udnuX/kxTPbOJL1Y3nTspWDch3Xm3ek+CERh2osmNK1ritYCoN31g96eogWsm0IXzydp0LCv4uDCdoKmo2aArB0PI39gO3bs32JLWtBomwDKhmVyndbJun4eDe6lBTjFMv1h2P8MKpUMJtpTiIfuueChKxypddw2WkIUJ6uOR1Jl8c9A1cMxgC0Y89EFeC9gPsB9WDTTeNJPI3aPt/klvQqT1qdgjNYa4s9BEzIfYJ7Q96/pcZKtJKTst0+rDNhJb8Ekvo0W+ejCCh91bFjZggsgwcCG0Rl3wibDAWT5bBxfXVsEE80hYntEEMpDmEsJrvHXUUhOk4sQyvHB+TDqf+aHzpKdPy7a9ccixIoGYluoLvXP96Hrd512sRHsnLCTEHOp9P8iMD2J6IxJvvT/Imx2DEYUHRpgQ0MEs6peABV0VOlgjqbp4dltkXUdDWdgWYn7pQBbPHIZRZMkwENPduoiDX9cdyrJQrcleEZTo6JJOnM9nPyVNRGpo69GnJmkykpkn4P76zhIEtuJNK2OWpDf6dh7hCt//MF/w1qjr+wBdT8+g/N7JlkLHhJcUtisQKO7brKkDxcgEpKGlMuSSAVMWKkVsGRSBwfJquACLjWLAwkQLVN0FSBVMpqoVbJkUiUH4VXS37gEXAcxnkB2KamaXx5Jhf/4Q0NJ3HacXcEy3J+keSeyEo0Ub2s46UtVQL7tHR507OeTF6DGiGKylUzOmQ6Ah0cYz6kMxm0+qxa9D1kPv6SPOvoRzxcaiew5p1+2ny27jgT6sjGLeKgvzPoUgF49h41aDVxBG/+UyC1Y3fzJMDXX9vduG/+givbgXGqXZ8ZjuggeRbd4VkJS6A3CNltC0L8i+6HeWcQ06qCxykGYh/QK/x0mh9HAH2bY6UDz8WINX/sxCQ/G/DATsomU+TbwURjzJHZXBy2SVDozOvR5NPYM8ooUfHXJCMvgqFfIP4Pgegc21zHvCHeu2KXEfW30DTGCV61Z2EAY7Tv+cIhbcGJEoTnafbk6qhhQwc9bXnMlD6eOJyYKqxirwOIDpQhWbEsX/9gGhGKD2DzXVyqWp4wtVtVub3h93y6CSmukBlORNhKqT2/e7aOuWNQei7joBTFR+/J0V1GLBbOBA8pIjXrqDBzYTaQwd0HfdpiWm6parqn90Oi0vI2pQpuULnrsp7oCseQHGMvjoCFfz4Pt2fH5v2BvgMt2QleWbKcewk49fB7wnXoI+9jgl/BX6AfrHenFL5j2KxHu9KuKQKSHiCvNEul5tQAGaJq5I8SDs5+WyMNPg/BGmJifiLAhZ55CIhFpu+HN2VUYDAdiTnIbpv2rs3AQ7Mp4WFsyOSfmXfuxP0o6uMEjRIUWtqgTF3EOyTrEdauarqBpLtyZ9gSCJ+oTDwrBNIavpONiexiMJ6+CJP05JMoSdSqh7G1vp8/lNjHKp0D58KIh5f2S/sqlfqPZpHRfdjkD3GBtyftRh4yMOuUypTr6eM8JrCLHVVhKVVXaE9VJLZkxX18m0yZ49dmlVjlZ8TeVUMqOp2W1FfYvdD6Crp+WkQbG7UNG9kIWvU378pH7LEtStFFYHrmOzdrFsJWpwHUxF3Tkl9ni3mCqH704TBRReTIyWisD2DHVlhkQ5EmqsEzOLKBg6M+BC2kveh1HuL0wyV6JaJKK1PGyCvOGUoUpLXI57xw5K+XF2GELpfs2FTANHaMMnauSEmZ65D6+F+jRZJfBCl68JVC5t24JEPUjrwSTnHvL4FT1Ir489xve2prD/7Vbm2tNq9T8pkHfFMZgLRprxio1+xkHUPNL308Cq12YWjrvaxWGcERCjSkG40heDFkklYKEykJsTIvFSFJlQbZdkErStIKd6xwo+3mbEMSdnSD2GjqS6zptyNHHsW3/w7Hw/83/OC28ElpI01btra4JsXCLQM3j821tngFAW/5QxE0Ud82KKRndhALKpNaVVE45JZB8G6qR0OfRHdui2hYGqub/cFtBhAd5ehjEBj5PTJ0n0o55td/OpLlQOdXDYZ3TFRQ1+KWVH0tQlzuREumD1Zfd2giM8qL8Ik9gEhj1isXFwV6voG6aFMlmLG4eauIe0gnqDzTtLtbRXOkwlhX2e4FkyDGWKNZBtnOlNWjvtZjDX2Q3cHCzjTdXSKDa29i/xrwadmJZe8osw/mOquLGgQJeMAvy9QkBFHdbpWhTnvyZoYjdN6maPyWTJ9ToLGFB2QklKSmYFKrm/lrxMCOcbxqEhYtZqHjn6cVxEIrHSqHJRBrOO19CwaD8tiW8rFi7g/KTCDs4HNE9hHCb7Fcsuuekl1mqxy/bkeih84OMGOBj6eCCbQmy8qqb+kOtHYNsSqijYEolKhUjHfQiBqgZe6xa1KqxV6GccRaYEarzooSyhZlihlX3PToYw6mDDnTmSaZDKU479bW8eeceeiZYwSBMo9iKxhaqGFaCdNUP2RqTMi+gmVoanOIuTblJ8qDqZbJZEd1mDba7OpNRLVQ5Hw0FmNpdPmuMN6JLUdeZj7NhLri5qpc+zWQn90ANyIu8llHgvb3sRr6e7XrMFUzjYX+8NVkXZ8ZwE3H09r0lyaPDgPFBa1k0Dx7dLf4pdGstkqk1dC0Wsj2oB7pow6m+FpPcrr5Xr4XLdG9iQG2Uw8hqqP7AsWAYNNfL9hUVNet2H8bTy2Zxn6yezb40mb1NG6ui94xatHo90x1KZqfp+pYIx4Bs126xv027XjtsE/H1WkIua5R2NStNi1C0+cBiZyqWX42BQms/nMPeTdBoNknCYfUj0QxvgKGHVE3qdIN7r8LBCj26T9WtndJY7Zav+SDvJ9nJ47KrLC3acypcU+RDquDXDhlmWGknIEaSR430ebvZ/CJjYNFSU8c1n8vN2oTW73RfFTwQmv2uuCmVDQFWsuG24T93yfsxle4vT3E+oCIkB3QSNmSpoHZ90RpWYbK8bBhMriWmRrumTpo/uy6fyFetx/UUU3q7g2qmmVRRu1HHXFpbtf4avRDUa/QDlkYb99UNAzler598Vi9FsFi7iRprNxG3h6NQ6sNqW+scIUAkoCsHY4rix9ZWE28vXwk+FgpCd70mQorjx9YGwZi5G7Ud2XfIdUyORq4Su+kjxrMiG44wyIKpUNHsBHw+Bo0Ytx9RVuooMhYKeaGQFNpOZFeFMbZbSomgTKDGH2Y3yP2OUIEaenhYFclne6gJq0PwXpWHCZiUXw5kh8ITFbvNr+aySSA9CivwcrMiyrsD/BReu2w6V1PclN+18yvqkvLnkR35pJ7X8WT6mEGau8D/miRpeHFvy/fti90ZSglXTceXEobiCOGRfvKUhwfnh1DzMAGJFUJNnmySh+okD6ef5OLMRmPZ9LNamsok4lw+jUNlGoel0zjOJuTxP9mEPFUn5AOadKUJB/u/08KEY+Ekks6pecKNKyfc2DThovIJ59eacH5xwvnChEudSBo2fhVexzfPE7/ePPGnnyd+yTzxhXkSFLszlhIiNSTGWGQsnyen4jw5ZeuhBRVAscT6IZSnTObxkkyu0SCAiW9bwivh84gxvK/j3MYzNYE93D5v9UQruJGFBXr8kHc78ZIYvt2JvmH7aTDK/X9uWp+0EKJjWTL2r6Gxqba0mpm9q3GNCrePIunNMDr3h+E4TKlLDJSijwSShy1OgviDfxcmHQwukLshfkQ3xB/w8ld3ODyJI6BYGgYYcSf3JMQ7tLDbI3FNmnhy4cdp8lOYXjXsEakgwQsH+uqWlh5uWiN/7F+CPOLaeZ6CTThpOjds80fd6gQ4KRmBP6eQeu4nAXEtJiIahBYgRLokxzCWSYQmSH5wNPONVKXlREeuDI2rGSPetuRnWfMWGJTOpmOfYglyvfYGijHhetOS6iY2WVODhIcfFPq0uoPBWYDqL7piqtRTWn7q3yJmMvjrtPsMposVZw87sGBo7DEXUpc6FMspx6HrN4AVyEiGGKBVKa/fXJf4Nl3tvg6jyySvC1IAS0KtKFij9OiGmPXlSHniJm/nFw2VWpMkiMmdRp6TlywOXnWk6AdFoY48V/EDvsE1Dya55AScJf4S/toSqJobKKAl2wrFNeERpRH9xTieMwKoc4DTL7tq+dZPaDA+vNGTvcI9uk7vT0GxicbDe1AqLkJgKKorhAu/fYz6abT8PkwmIAN/JwLR2ovjKP7b3yjwJKaJYYIOrVdWgPgsfzyAHvgDC7E6NGKB1ZcKXMCQav2Wv2SU3I/71uso7genAV5XZW3hr9I0bJoMrBTu2UsoW6g63Pphap20+miLfTs5xwAFDdE0orJs2cUgj+3tYHlZ4Fzwa2sQ4KNb90QQ8CLMDBM4LjIQm/M6jkYfDg8a+ZM4tN07jNApck5KIj/iER3vmRNvKRBTGZmfTRd0pv6Kh2sJ7ARvWnejIXJ953QHZDujFUVGaGwxnlvnwRWgs6JJbKGJ8RG3tcWM+S9vWjryPyttGm4Ecff+mzwarvwkqxd+whC9CeK//RRNhgPrPppYw/AziZoQk7qsMH35G5cVujY45W1AEj7w8tWAxJPVEQnXCYQXjUSmEh9YtCohG7VThSnBD/mGZvf48ATvg2PYwWv8guj4M1RA7euhD2PIfv5oefmF7ZBPvNRuCzrHU2gaCapHQiNBG8Q4k6DUxnt+/6qRQH+T1hjSUIUAefwOlM54B+QzkKJjnx4f9+zHj3P9IO6Qq5EsoZlexdEthvxAQAwvYiEq1Eqg73Sd2o5nqPds7+js+PQMqsYgrGSnPT6jYSbJO1IAhvZZjHZpQM5MIdh35mlsqo76pto7x0ev999gVK191NPyWgQfRfvNaffk7evj00P7WT6jqfED4P8nL+WM5YLdozfvDrqnb7rv3uwZy18FZgTlJW9LSu7uv9nvdQ92989ODrofjSjutCgeTmC0XeIpdkynA65AOPUbfFnWLg0PuH+ZelSpcvU5xqIyzJlsjZuMsxv61Ks9ULzaM1OX2pU92KXEY3+YdSlQZnQuJR0mE7v5/LKIsu1YPwXDfjQikki30DVgUAJ7zpu4sjAsOjiQbQlbAzHQ7vkERvV7miaXu570A6t7si+XOGuFo9GnN7BXONlnxTDYRrd1Ohmj6nI87o4HcRQO8Bk0guwVhqMJYiweUxiUsgzK5nHoRetuaw0Djw+CG1i/zoihgz5P1m1Rs8fuyT5G6Swvwp4rE8tsZ4szhs8AaU+zrAQ0RE6PQq3S3vtOBdF4y2AIIgTL6sWwPNehYzX+P3spVtElUkJ/1LRy9mXtvA7vgqFFlivaTrY9py05wdxTzJTin1Ak3VaYnFxF4+A4JvE/05c2bPHO4eu9yA4f73wTI0sM36+xQMt+ZgAFEfgZfdyzlkItl5MQuvrax6thP/nJMQyaGBSB8Usbki3UwwfW71E0siKaA1kWDmWoRAG4IDgsciQG+c0lGXkWLdZtFglF6ULvRFG2djJi5e/cqTwovnJXPFEm55S6bbYDsx1EA0LodSyqLF7DXnc/AUXvhoUPfpAsB1TmZNv9R225dOLfBLlVI88F8TIYBmeQCytTGl6w9uXBcumaDg3DBxrZSSyGVE/vm8ut9hrxdH7ebn4pC5DCtQYFQUfaVQG7MJhNNEm5wDa37cFx221iSMk2aB13s2iJ2ZaEZHs7E9vkaKb1iVkezibnfIPBc3RGDyxfpW8R084krArOgvpGdiZLg3V1Auknsb6F5CIYCaej3gKDNJJJodVsmioAIDo9EOY8PDj/NLaZP1NPC+EG7ATgbqN4kN0w/+QPRuG4mAwCbCCcNwZx6A+F3/ENYhvDwivd54xvrjkmmtxKyEZkGaMIwnQn58c8se0su5nD2XUcpVE/GuYRbAaDOCMsTvFOaAK9hsWgA1191OncwLpitXOvUKGdqHFoIfImNwWEj6QrfiA4MHhSN220sSdPcxcSUrkARvsmdEyHS6RKJS5KJzIieNcLtzdZOgFCyqkAmEYx0OBRcmlIo5k+xhZXL4ayy6bi8FGBxDzWBmFUFRsjZNKRTsZXYZSTVAoQ37xjjCxA5TymStjLQvoz2+ZYTG0SxoGKhaczLJ+uJufv4qF4PETDPTAeLNnPnj61syvUhluQbEjQj0a41ElJCPVgyf5/0ON6ieJEtpF0FlAiTgtuC/n4QiwwmpayZMDzQNeQkf8Ztqr/ngRJ7gsijxza6qV8tOTVflLq3VYHdiMVKv5EayZJ4fgiav0ricY2ey4vje+/BB1q+7gIyNVM58sIVPhndh+2XfZD8wFWCkgOOXuWVx7IjZzoMyM2wREyHAHB3uCl4qyU+0A2o9jyx4/pp+CoStVOmvxL+1diLkkb0OGsb1zExPh8giCDyJq6P04bMb6i8KAZroCWfqHR+EQRFbYGYawVu+gzL/wubGZ6p+/2uOyVxHjYEn8ayoHOkL9GQFeszmp7VZRIyMiXy96zHABEJP9BFjQ6KZZXMpAHGMvcK0s4KcWVNHvBWrNvxgsAwJs427l1OlA47MRc1cArBAT38STdgVUINBOgZoLKFV3C0cabmzzE6741bRt6EwYhRt6n0KFbSOLsFBfrSdQCscOsWbRIUiwyVoskjv12cp7QAuNiAYyVORaISGL0ZzZCjNV/9ZxHM9y+otEF/F+ufhVoixXYPJIm23sjSLOVRd5LnEHnElS25Ph2zI6A7hs2ygC7+fKSyCCMiTvSAJF3uxAIvzyzMazKtQ6MTScKyn4gzr4OGIYjBYQvCNTTAOGoJ0D4hUTs1WKi04Jhy6S4c9FRpsr2hRSCaRXnzk8//dRC4XbRETNXWSTynU4uKhVcO2ZcO50dGRc0pbPz+HG/Iyz7Wu2lp1GxjtPWbtCP76/Txq0DP2A/FI537q+vcomArk0Pzs9lMY3Q9kqq4NodTAii5PLfV+loeBb3d2BMZWk4B8/uE1C7u/1+kCS7wTgMBPURtkH5ZGU6t6Ap4sLQSdniRPZS2a6F3OpHIznGidyWWxgIxKMvYBA3vOOLBiw/+CbKtrAe81KtkMO8xIn2ItP9MrQyuMi8kKtxIg2y/RL/wpwCWrABoq4EWeyDjrjq//EH9fuTiPzb85fwldtZOrbbatvWyxd/e06MnVmy13JtSKQ0hS8oNuhHphN27N+WMuLm2sgTmyiEHfuJkEsWeMgha5qUo6z1APRkqSFk87XiCVEWlbKQggVgijWXfrPITpK8mGa/7h6c7dlPocVPWcufZl15ij198bffnkl0SZVNMH29pzBIsErkmhN2iPSBLUNhXGzHL9ovyeBh6nTcfEZGco6Fk7BjX6XpdUI2KoBxdXXFbgrvHf4zbBTK5FiuoiQlbcmUhBwYqPpS+vUMHwZtblM1JmlJCprgYvczWkoz/xUCjH6+ZMI4Y6LUAsUoLXeLm01GzeygUaglc2Nk8OQoHhbJEGTYxWRMw92R3SP1v8F8mNVvgT4MxXYobKdi4XvmwoeJRG1oRC0QytSIil5KUK8TwY4+vRJW+M6jdvNZDogQzGAUHIajAF2uGjaJZXs99MPxtsXD2d4to5hc5vOMFByjXeUe+x1Qg3En61TzS0TOku7PMBdUIS4QqF7zAoO8Mt2Ipjxfabdf0jOBSdigVlAQEd55OG4gquQaxGrAJAUtAk3Idadm81lWOpeBWsDmA2l8gCeXYovrlsfiCbrUY7jHh+2fYdCHl2MS/Js8zNSh9l2YhCiY3xIzTUxdOhq2BL43HnSesMn5v/87hnnwZJvGHv4yCWBWWt2hH4/OWJTg21BISlOQHYlzlqf1YLgg/3aDpB+HNDTsHc0eX04A4o0/uQxeR/Eo90FxIhHgZyCKWPqEZY6jlEyqE38cDJ2dQJMqFtsPywHexP71lfNvggaWrTg9A10+cD6nJCE/B3cOQiUFTVDOz7rUV6AWOFe6HGa92hvDnsb5twqR+Xg497GQxQo5n2ibJkkajT7ScyvnhqShIKD0+H+z32fBJa5Rzg9CCvbsU5D9noxGfnzPAc+zjF7s9z/DTuaNmiIS9meCFz1txNQd0icdc/s0B41+Yb97FwK7UyGFNv8HMSUvm9CyyCoF64TkvO31TmIqo06DZDJMQTki6ZNz558h+7YPK5ZzSH4dBJcwZZzPwg+xE4dpnk7b9SFUUkTw9wScWiGdXpD/EIESBgTL7N3K3YrTpb9Bk/IvA1rJ/9CkcHzo3zkj4Qebtc6I4D7yb8JLMkr+FUq/xequSPEjfGaOjZRrknKCt2edcf79tfMTwZLTFE/dnLdi4j3HDGgmKc8AwQA1+UNnRGCJtDlLo+uzNLh23hEwNsKcD/gDLcYwokHAg9LkXIaFNLJ/Y/wbBDx7QNv/HkO+O+dkXqiC5RWp7H2AWu6KMyZFue9WLpwI0Acy8j4SEGIpFvGcYerH7sm+s5fyr2wOOnHMUz7t7r3f39n79Ord2UfnY6omHx33Pr0+fne065wJRY7fvTrY+9Td2dk7c07z9L0Pb7vvznp7u06SJ77ePxDRXARZzv7R++7B/u6n7umbd4d7Rz2nlxbyaFXOQbHUPhT4qZh8cHz0xvlnIfmsd7oPGWmxwDtE9O88+fjT3unp8akThlnaYfcDb0ggpO4f8dS7vLvYU3y1YB+Q/wyU2E2lrLN3JyfHp0iiHbHMp8Pj071PGJHd2c3TT3s7pNDpXnf3o7OfZ5ydHbBW3udp75AdZ85F3sLe/uHe8TvYeuVJ746673pvj09J2/7fnBrv907P9o+PoFNnh93ezlvnLcsT1jfnJhTTcElzfmLdw3E4oNmv4kly5Xwi3+lF9F7IfozJBT3QWgZUgqfO7yQHfx1El5cwk15nCacgnYIYo7MEWRoWORJ+pqAIjZz3PCFwTmh7dsPLMMVrT+TOm3NJU/fGk5EzzL+TNc+n6Iiz1WFy6ZzQ36/DeITvhaKe4dzIae+usQ/OAcWEi4ZzTL8yjcd5Twsw2Y+Cux+LKWdnuyeH1InU+Ugz6Mqd5j/CfuLcyb/P3r9x/kVR4yLxKhrcO1H+mym2zjmlN+q6WPUb9hO+xhT4ABRNYGrsD0JYKynDujTrMPATUJ+cPforGkyg/5/Jj6MghT35Z8enjToJxs6/yLdTkFWgowLgK/KbyejXFCMeib12zmmhs1EUgfo3vgTMgXPEEnFU0FZ8EFLooLtlKWRHh+ulD+KL9oju4PfGN84rJeEt7HedPi2JmiUdS4DgLS4YNyT9p+D8BBjg3If851kEakGKdBrSpv9Ezuyc/ZT9wtM2J6F5H0ZDNGo5PmUsCMze3k7vU/fgwLkOpaSjvZ6zpyQdH+05r+W0d2evnDFD9vrd0U4P5uPu3tnO6f5J7/iUyyvnmFavSvsPNBm1YzKUnZ/zBFlddt6RHDJ9hyH/KuI6JQA+wKbOFf0uiAFGlD2SQW9WOP9D8GDobhg7J3izLUjxeBPgQgLXpweWTpf9wLek08Q5JeUG0mxVdKK7oAjCmvCa8GUQTWCTfuSPnV2CDe8ioPFQXVdvCaJLoQv/QxJwbrGEW0J+NAY4R/htGJER5/wPKToi6gvVOS5JCmxq+I116LJzStpDQnp8AHkdZL8SrjqcY1JMfZoJ5rckAfSmaBL3obc+6QJ1GCKqqtKJ34M8/zUoiWr+WCgPSmQ/TNhtH2nzkcMkXAq9JW2/Q0F+wi4JOYeksvuuPNQetv/2/wOTOiChTRQJAA==";
BinariesBlobs.rw_minjs = "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";

// obj/full/installer_rw.js
var codeInstance = class {
  constructor(filename, EStarget, version, readonly) {
    this._compressed = filename.slice(-3) == ".gz";
    this._filename = this._compressed ? filename.slice(0, -3) : filename;
    this._version = version == "" ? "Unknown" : version;
    this._EStarget = EStarget == "" ? "Unknown" : EStarget;
    this._minified = filename.indexOf(".min.") > 0;
    this._readonly = readonly;
  }
  get compressed() {
    return this._compressed;
  }
  get version() {
    return this._version;
  }
  get readonly() {
    return this._readonly;
  }
  get EStarget() {
    return this._EStarget;
  }
  get minified() {
    return this._minified;
  }
  get filename() {
    return this._filename + (this.compressed ? ".gz" : "");
  }
};
var pageInstance = class {
  constructor(filename, contents) {
    let strContents = YAPI.imm_bin2str(contents);
    this._compressed = filename.slice(-3) == ".gz";
    this._filename = this._compressed ? filename.slice(0, -3) : filename;
    this._readonly = strContents.indexOf("yv4web-readonly") > 0;
    this._useMinified = strContents.indexOf("yv4web-readonly.min.js") > 0 || strContents.indexOf("yv4web-full.min.js") > 0;
    this._action = 0;
    this._contents = contents;
  }
  get compressed() {
    return this._compressed;
  }
  get readonly() {
    return this._readonly;
  }
  set readonly(value) {
    this._readonly = value;
  }
  get fs_filename() {
    return this._filename + (this.compressed ? ".gz" : "");
  }
  get http_filename() {
    return this._filename;
  }
  set action(value) {
    this._action = value;
  }
  get action() {
    return this._action;
  }
  get contents() {
    return this._contents;
  }
  get useMinified() {
    return this._useMinified;
  }
  set useMinified(value) {
    this._useMinified = value;
  }
};
var YV4W_installer = class {
  constructor(container, options) {
    this.CALLERISHTTPS = location.protocol.toLowerCase().substr(0, 5) == "HTTPS";
    this.DEFAULT_PROTOCOL = this.CALLERISHTTPS ? YV4W_installer.HTTPS : YV4W_installer.HTTP;
    this.FIRMWAREMINVERSION = 43805;
    this.DEFAULTADDR = "";
    this.DEFAULTPORT = "80";
    this.DEFAULTPATH = "";
    this.DEFAULTCANCELABLE = false;
    this.DEFAULTINTIALFOCUS = true;
    this.DEFAULTUSER = "";
    this.DEFAULTPWD = "";
    this.DEFAULTFILEPREFIX = "default";
    this.DEFAULTSRVUSERNAME = "";
    this.DEFAULTSRVPASSORD = "";
    this._currentStep = 0;
    this._warningRow = null;
    this._welcomeText = null;
    this._hubAddr = null;
    this._connectingText = null;
    this._ipAddrInput = null;
    this._protocolInput = null;
    this._ipPortInput = null;
    this._pathInput = null;
    this._configFileInput = null;
    this._webPageInput = null;
    this._connectiongError = null;
    this._pwdPanel = null;
    this._descPanel = null;
    this._customFilesPanel = null;
    this._doneMsgContainer = null;
    this._confirmUninstallPanel = null;
    this._modInstancesPanel = null;
    this._donePanel = null;
    this._runPanel = null;
    this._modifyInstallPanel = null;
    this._adminNameInput = null;
    this._adminPasswordInput = null;
    this._userNameInput = null;
    this._userPasswordInput = null;
    this._useReadOnlyInput = null;
    this._fileprefixInput = null;
    this._useFullVersionInput = null;
    this._removeUnusedJs = null;
    this._makeDefaultInput = null;
    this._userCredTable = null;
    this._optionsPanel = null;
    this._connectionErrorMsg = null;
    this._instancesFiles = [];
    this._jsCodeinstances = [];
    this._webPageinstances = [];
    this._uninstallOpt = null;
    this._updateOpt = null;
    this._addInstanceOpt = null;
    this._modInstanceOpt = null;
    this._confirmUninstall = null;
    this._history = [];
    this._ErrMsgContainer = null;
    this._currentHub = null;
    this._currentfs = null;
    this._currentHub_RW_username = "";
    this._currentHub_RW_password = "";
    this._currentHub_RO_username = "";
    this._currentHub_RO_password = "";
    this._currentHub_protocol = "";
    this._currentHubLink_protocol = "";
    this._currentHub_Addr = "";
    this._currentHub_port = "";
    this._currentHub_path = "";
    this._currentHub_ReadOnlyProtected = false;
    this._warning = "";
    this._finalURL = "";
    this._plannedaction = 0;
    this._alreadyInstalled = false;
    this._applicationURL = "";
    this.ESVersion = "es2017";
    this.WELCOMEPANEL = 0;
    this.ENTERHUBADDR = 1;
    this.CONNECTINGPANEL = 2;
    this.CONNECTIONERROR = 3;
    this.PASSWORDPANEL = 4;
    this.DESCRIPTIONPANEL = 5;
    this.CUSTOMFILESPANEL = 6;
    this.OPTIONSPANEL = 7;
    this.RUNPANEL = 8;
    this.DONEPANEL = 9;
    this.MODIFYINSTALLPANEL = 10;
    this.CONFIRMUNINSTALLPANEL = 11;
    this.MODINSTANCESPANEL = 12;
    this.ACTIONINSTALL = 1;
    this.ACTIONUNINSTALL = 2;
    this.ACTIONADDINSTANCE = 3;
    this.ACTIONMODINSTANCE = 4;
    this.ACTIONUPDATE = 5;
    this._MODIFYNOTHING = 0;
    this._MODIFYCOMPRESS = 1;
    this._MODIFYUNCOMPRESS = 2;
    this._MODIFYMAKEREADONLY = 3;
    this._MODIFYMAKEREADWRITE = 4;
    this._MODIFYUSEMINIFIED = 5;
    this._MODIFYUSEPLAIN = 6;
    this._MODIFYDELETE = 7;
    this.TARGETEXTENSION = ".html";
    this.icon = '<link rel="icon" type="image/svg+xml" href="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNjQiIGhlaWdodD0iNjQiIHZlcnNpb249IjEuMSIgdmlld0JveD0iMCAwIDE3IDE3IiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPjxyZWN0IHg9IjAiIHk9IjAiIHdpZHRoPSIxNyIgaGVpZ2h0PSIxNyIgcng9IjEuMSIgcnk9IjEuMSIgZmlsbD0iI2ZmZiIgZmlsbC1vcGFjaXR5PSIuOSIvPjxwYXRoIGQ9Im0xMC43IDEuMy0wLjI5IDAuMjljLTAuMDQ3IDAuMDQ3LTAuMDczIDAuMTEtMC4wNzIgMC4xOHYxLjFjLTEuMS0wLjktMi43LTAuODMtMy43IDAuMTRsLTAuNC0wLjR2LTAuOTdjMC4zNS0wLjI1IDAuMi0wLjgyLTAuMjMtMC44My0wLjQzLTAuMDE0LTAuNjMgMC41My0wLjI3IDAuODJ2MS4xYzAgMC4wNjcgMC4wMjcgMC4xMyAwLjA3NCAwLjE4bDAuNDkgMC40OWMtMC40MyAwLjU5LTAuNjMgMS4zLTAuNTQgMi4xdjAuMDA3MmwtMC44My0wLjgzYy0wLjA0Ny0wLjA0Ny0wLjExLTAuMDczLTAuMTgtMC4wNzJoLTJjLTAuMjctMC4zNi0wLjgzLTAuMTktMC44MyAwLjI1IDAuMDAxMiAwLjQ0IDAuNTYgMC42MiAwLjgyIDAuMjVoMS45bDEuMyAxLjNjMC40MyAwLjM4IDAuNzQgMS4yIDAuNTkgMS42aC0yLjVjLTAuMDY2IDAgLTAuMTMgMC4wMjctMC4xOCAwLjA3NGwtMS40IDEuNGMtMC4zOS0wLjA4OS0wLjcyIDAuMzQtMC40OCAwLjY5czAuODYgMC4yIDAuODItMC4zM2wxLjMtMS4zaDIuNmMwLjI2IDAuMTUgMC41MSAwLjQgMC42NyAwLjY1djEuOWwtMS41IDEuNWMtMC4wNDcgMC4wNDctMC4wNzMgMC4xMS0wLjA3NCAwLjE4djAuMjhjLTAuNDUgMC4zLTAuMTUgMC44MyAwLjIzIDAuODMgMC4zOCAwIDAuNjMtMC40NyAwLjI3LTAuODF2LTAuMjFsMS41LTEuNWMwLjA0Ny0wLjA0NiAwLjA3NC0wLjExIDAuMDc0LTAuMTh2LTEuN2MwLjI0LTAuMzIgMS4xLTAuNCAxLjQtMC4wM3YxLjJjIDAgMC4wNjYgMC4wMjcgMC4xMyAwLjA3NCAwLjE4bDEuNSAxLjV2MC42OWMtMC4zNiAwLjI0LTAuMjMgMC44MSAwLjI3IDAuODIgMC40OSAwLjAwMjEgMC41NC0wLjY0IDAuMjMtMC44MnYtMC43OWMgMCAtMC4wNjYtMC4wMjctMC4xMy0wLjA3NC0wLjE4bC0xLjUtMS41di0xLjRjMC4xNS0wLjIgMC4zLTAuMjUgMC41My0wLjI0aDMuMmwwLjkxIDAuOTFjLTAuMDk5IDAuNDQgMC40OCAwLjcyIDAuNzcgMC40IDAuMjgtMC4zMiAwLjA3Mi0wLjc5LTAuNDItMC43NmwtMC45OC0wLjk4Yy0wLjA0Ny0wLjA0Ny0wLjExLTAuMDcyLTAuMTgtMC4wNzJoLTNjLTAuMjEtMC4zMiAwLjI0LTEuNSAwLjY3LTEuOWwyLjIgMC4wMDU5YzAuMDY3IDAgMC4xMy0wLjAyNiAwLjE4LTAuMDcybDEuMS0xLjFjMC4zOSAwLjA5NiAwLjczLTAuNCAwLjQ0LTAuNzNzLTAuODctMC4xLTAuNzggMC4zNmwtMS4xIDEuMWgtMmMwLjI3LTAuOTUgMC4wMDY3LTEuOS0wLjQzLTIuNXYtMS41bDAuMjEtMC4yMWMwLjM4IDAuMDgyIDAuNzEtMC4zMyAwLjQ2LTAuNjlzLTAuODctMC4xOS0wLjggMC4zM3ptLTMuMiA0LjljMC44NC0wLjAyOSAwLjk2IDEuNSAwLjIgMS41LTAuNzYtMC4wMTQtMS0xLjQtMC4yLTEuNXptMi4xIDBjMC43NSAwLjA4NCAwLjYxIDEuNS0wLjIgMS41LTAuODEgMC4wMDMzLTAuNTUtMS41IDAuMi0xLjV6IiBmaWxsLW9wYWNpdHk9Ii4xIi8+PHJlY3QgeD0iMCIgeT0iMCIgd2lkdGg9IjE3IiBoZWlnaHQ9IjE2IiByeT0iMS44IiBvcGFjaXR5PSIwIiBzdHJva2Utd2lkdGg9Ii4yNiIvPjxlbGxpcHNlIGN4PSI5LjQiIGN5PSI3LjQiIHJ4PSIuMzQiIHJ5PSIuMzMiIG9wYWNpdHk9Ii4xIi8+PGVsbGlwc2UgY3g9IjcuNyIgY3k9IjcuNCIgcng9Ii4zNCIgcnk9Ii4zMyIgb3BhY2l0eT0iLjEiLz48ZyBmaWxsPSJub25lIj48cGF0aCBkPSJtMS4xIDEuOSAwLjA2NiAxNCIgc3Ryb2tlPSIjN2U3ZTdlIiBzdHJva2Utd2lkdGg9Ii4yIi8+PHBhdGggZD0ibTE1IDEzaC0xNSIgc3Ryb2tlPSIjN2U3ZTdlIiBzdHJva2Utd2lkdGg9Ii4yIi8+PHBhdGggZD0ibTEuMiAxM2M1LjQtMS4xIDEwLTIuNyAxNS02LjkiIHN0cm9rZT0ibGltZSIgIHN0cm9rZS13aWR0aD0iLjQiLz48cGF0aCBkPSJtMS4yIDEzYzAuMS0wLjA1MyAwLjQ1LTEuNCAxLjItMS40IDAuNzggMCAxLjQgMi44IDIuMyAyLjggMC44Ni0wLjAwMTUgMS42LTIuOCAyLjQtMi44IDAuODQgMCAxLjUgMi44IDIuNCAyLjggMC45IDAuMDEzIDEuNi0yLjggMi40LTIuOCAwLjgyIDAuMDI4IDEuNSAyLjcgMi4zIDIuOCAwLjI2IDAuMDQzIDAuNjgtMC4zNCAwLjY3LTAuNDIiICBzdHJva2U9InJlZCIgIHN0cm9rZS13aWR0aD0iLjQiLz48L2c+PHBhdGggZD0ibTE1IDEyLjQgMS4xIDAuNi0xLjEgMC41N3oiIGZpbGw9IiM3ZTdlN2UiLz48cGF0aCBkPSJtMC41MiAyIDAuNjItMSAwLjU5IDF6IiBmaWxsPSIjN2U3ZTdlIi8+PHBhdGggZD0ibTkuOCAwIDcuMiA3LjJ2LTRsLTMuMi0zLjJ6IiBmaWxsPSJncmVlbiIvPjxnIGZpbGw9IiNmZmYiIHN0cm9rZS13aWR0aD0iMSI+PHBhdGggZD0ibTEyLjcgMS42MyAwLjQ5LTEuMSAwLjE5IDAuMTktMC4zMyAwLjc0IDAuNzUtMC4zMiAwLjEyIDAuMTItMC4zMiAwLjc1IDAuNzMtMC4zNCAwLjE3IDAuMTctMS4xIDAuNDktMC4xMi0wLjEyIDAuMzMtMC43Ny0wLjc3IDAuMzN6Ii8+PHBhdGggZD0ibTEzLjggMi43OSAwLjc5LTAuNzkgMC44MiAwLjgyLTAuMTQgMC4xNC0wLjY0LTAuNjQtMC4xOCAwLjE4IDAuMzYgMC4zNi0wLjE0IDAuMTQtMC4zNi0wLjM2LTAuMTkgMC4xOSAwLjY0IDAuNjQtMC4xNSAwLjE1eiIvPjxwYXRoIGQ9Im0xNi4xIDMuOC0wLjQyLTAuNDItMC4xOSAwLjE5IDAuNDIgMC40MnEwLjA0OSAwLjA0OSAwLjA3OSAwLjA1MyAwLjAzMiAwIDAuMDY0LTAuMDI2bDAuMDc1LTAuMDc1cTAuMDMxLTAuMDMxIDAuMDI1LTAuMDYyLTAuMDA0NS0wLjAzMi0wLjA1Mi0wLjA3OXptLTAuMzIgMC4zMi0wLjQyLTAuNDItMC4yIDAuMiAwLjQyIDAuNDJxMC4wNTIgMC4wNTMgMC4wODYgMC4wNTQgMC4wMzUgMC4wMDMxIDAuMDc1LTAuMDM3bDAuMDYtMC4wNnEwLjA0LTAuMDQgMC4wMzYtMC4wNzQtMC4wMDIzLTAuMDM0LTAuMDU0LTAuMDg2em0tMC45NS0wLjI2IDAuNzktMC43OSAwLjY4IDAuNjhxMC4wOTQgMC4wOTQgMC4xIDAuMTcgMC4wMDUzIDAuMDc5LTAuMDc1IDAuMTZsLTAuMDk4IDAuMDk4cS0wLjA1NyAwLjA1Ny0wLjEyIDAuMDU3LTAuMDY5LTAuMDAxNS0wLjE1LTAuMDU5IDAuMDU5IDAuMDc3IDAuMDU3IDAuMTYtMC4wMDIzIDAuMDc3LTAuMDY2IDAuMTRsLTAuMSAwLjFxLTAuMDc5IDAuMDc5LTAuMTcgMC4wNTktMC4wOTYtMC4wMTktMC4yMi0wLjE0eiIvPjwvZz48L3N2Zz4=">';
    if (typeof options !== "undefined") {
      if (options != null) {
        if (typeof options["protocol"] === "string")
          this.DEFAULT_PROTOCOL = options["protocol"].toUpperCase() == YV4W_installer.HTTPS.toUpperCase() ? YV4W_installer.HTTPS : YV4W_installer.HTTP;
        if (typeof options["addr"] === "string") {
          this.DEFAULTADDR = options["addr"];
          let n = this.DEFAULTADDR.indexOf(":");
          if (n > 0) {
            this.DEFAULTPORT.substring(n + 1);
            this.DEFAULTADDR.substring(0, n);
          }
        }
        if (typeof options["port"] === "number")
          this.DEFAULTPORT = options["port"].toString();
        if (typeof options["path"] === "string")
          this.DEFAULTPATH = options["path"];
        if (typeof options["cancelable"] === "boolean")
          this.DEFAULTCANCELABLE = options["cancelable"];
        if (typeof options["initialFocus"] === "boolean")
          this.DEFAULTINTIALFOCUS = options["initialFocus"];
      }
    }
    this._container = container;
    this._container.innerHTML = "";
    this._container.style.backgroundColor = constants.WindowBackgroundColor;
    this._container.style.fontFamily = constants.WindowHeaderFontFamily;
    let bottomdiv = document.createElement("DIV");
    bottomdiv.style.position = "absolute";
    bottomdiv.style.bottom = "0px";
    bottomdiv.style.right = "5px";
    bottomdiv.style.height = "30px";
    bottomdiv.style.textAlign = "right";
    bottomdiv.style.verticalAlign = "center";
    this._prevButton = new button("< Prev", () => {
      this.gotoPrevious();
    }, 1);
    this._cancelButton = new button("Cancel", async () => {
      this.closeWindow();
    }, 1);
    this._nextButton = new button("Next >", () => {
      this.gotoNext();
    }, 1);
    this._okButton = new button("Ok", async () => {
      this.DEFAULTCANCELABLE ? this.closeWindow() : await this.resetAll();
    }, 1);
    this._prevButton.tabIndex = 100;
    this._cancelButton.tabIndex = 101;
    this._nextButton.tabIndex = 102;
    this._okButton.tabIndex = 103;
    bottomdiv.appendChild(this._prevButton.Element);
    bottomdiv.appendChild(this._cancelButton.Element);
    bottomdiv.appendChild(this._nextButton.Element);
    bottomdiv.appendChild(this._okButton.Element);
    this._prevButton.visible = false;
    this._cancelButton.visible = this.DEFAULTCANCELABLE;
    this._container.appendChild(bottomdiv);
    let topDiv = document.createElement("DIV");
    topDiv.style.position = "absolute";
    topDiv.style.top = "5px";
    topDiv.style.paddingLeft = "10px";
    topDiv.style.paddingTop = "5px";
    topDiv.style.paddingBottom = "5px";
    topDiv.style.left = "5px";
    topDiv.style.right = "5px";
    topDiv.style.backgroundColor = constants.WindowHeaderBackgroundColor;
    topDiv.style.color = constants.WindowHeaderColor;
    topDiv.style.fontSize = "x-large";
    topDiv.style.whiteSpace = "nowrap";
    topDiv.style.overflow = "hidden";
    topDiv.innerText = "Yocto-Visualization (for web) installer";
    this._container.appendChild(topDiv);
    this.gotoPanel(this.WELCOMEPANEL);
  }
  closeWindow() {
    var _a;
    (_a = this._container.parentElement) === null || _a === void 0 ? void 0 : _a.removeChild(this._container);
  }
  createNewContentDiv() {
    let div = document.createElement("DIV");
    div.style.position = "absolute";
    div.style.textAlign = "justify";
    div.style.top = "50px";
    div.style.left = "15px";
    div.style.right = "15px";
    return div;
  }
  loadLocalFile(fileChooser) {
    return new Promise(function(resolve, reject) {
      if (fileChooser.files && fileChooser.files[0]) {
        let reader = new FileReader();
        reader.onload = function(e) {
          resolve(e.target.result);
        };
        reader.readAsText(fileChooser.files[0]);
      } else {
        resolve(null);
      }
    });
  }
  showWelcomePanel(visible, goingback) {
    if (!visible) {
      if (this._welcomeText != null)
        this._welcomeText.style.display = "none";
      return;
    }
    this._okButton.visible = false;
    this._prevButton.visible = false;
    this._nextButton.visible = true;
    this._nextButton.enabled = true;
    this._cancelButton.visible = this.DEFAULTCANCELABLE;
    if (this._welcomeText == null) {
      this._welcomeText = this.createNewContentDiv();
      this._welcomeText.innerText = "Yoctopuce is proud to offer you  Yocto-Visualization (for web), an application that  allows to view Yoctopuce sensors data with a simple web browser.\n\nThis wizard will help you to install Yocto-Visualization (for web) version " + constants.buildVersion + " (" + this.ESVersion + ') on a YoctoHub such as YoctoHub-Ethernet, YoctoHub-Wireless, VirtualHub etc..\n\n Click on "next" to start';
      this._container.appendChild(this._welcomeText);
    }
    this._currentHub = null;
    this._currentfs = null;
    this._currentHub_RW_username = "";
    this._currentHub_RW_password = "";
    this._currentHub_RO_username = "";
    this._currentHub_RO_password = "";
    this._currentHub_protocol = "";
    this._currentHub_Addr = "";
    this._currentHub_port = "";
    this._currentHub_path = "";
    let tabIndex = 1;
    this._nextButton.tabIndex = tabIndex++;
    if (this.DEFAULTINTIALFOCUS)
      this._nextButton.focus();
    this._welcomeText.style.display = "";
  }
  showEnterHubAddr(visible, goingback) {
    if (!visible) {
      if (this._hubAddr != null)
        this._hubAddr.style.display = "none";
      return;
    }
    if (this._hubAddr == null) {
      this._hubAddr = this.createNewContentDiv();
      let p = document.createElement("P");
      p.innerText = "Enter the address of the hub you want to install Yocto-Visualization on. This address must be reacheable from your web browser.";
      this._hubAddr.appendChild(p);
      let Table = document.createElement("TABLE");
      Table.style.fontSize = "smaller";
      let Row = document.createElement("TR");
      let TD1 = document.createElement("TD");
      TD1.innerText = "Hub address:";
      TD1.style.whiteSpace = "normal";
      Row.appendChild(TD1);
      let TD2 = document.createElement("TD");
      TD2.style.whiteSpace = "normal";
      this._protocolInput = document.createElement("SELECT");
      let httpopt1 = document.createElement("OPTION");
      httpopt1.text = "http://";
      httpopt1.value = YV4W_installer.HTTP;
      this._protocolInput.add(httpopt1);
      let httpopt2 = document.createElement("OPTION");
      httpopt2.text = "https://";
      httpopt2.value = YV4W_installer.HTTPS;
      this._protocolInput.add(httpopt2);
      this._protocolInput.value = this.DEFAULT_PROTOCOL;
      this._protocolInput.addEventListener("change", () => {
        if (this._protocolInput != null && this._ipPortInput != null) {
          if (this._protocolInput.value == YV4W_installer.HTTPS && parseInt(this._ipPortInput.value) == 80)
            this._ipPortInput.value = "443";
          if (this._protocolInput.value == YV4W_installer.HTTP && parseInt(this._ipPortInput.value) == 443)
            this._ipPortInput.value = "80";
          if (this._warningRow != null)
            this._warningRow.style.display = this._protocolInput.value == YV4W_installer.HTTP && this.CALLERISHTTPS ? "" : "none";
        }
      });
      TD2.appendChild(this._protocolInput);
      this._ipAddrInput = document.createElement("INPUT");
      this._ipAddrInput.value = this.DEFAULTADDR;
      this._ipAddrInput.size = 34;
      this._ipAddrInput.addEventListener("input", () => {
        this._nextButton.enabled = this._ipAddrInput.value != "" && this._ipPortInput.value != "";
      });
      TD2.appendChild(this._ipAddrInput);
      let span = document.createElement("SPAN");
      span.innerText = ":";
      TD2.appendChild(span);
      this._ipPortInput = document.createElement("INPUT");
      this._ipPortInput.value = this.DEFAULTPORT != "" ? this.DEFAULTPORT : "4444";
      this._ipPortInput.type = "number";
      this._ipPortInput.min = "1";
      this._ipPortInput.max = "65535";
      this._ipPortInput.maxLength = 6;
      this._ipPortInput.style.width = "60px";
      this._ipPortInput.addEventListener("input", () => {
        this._nextButton.enabled = this._ipAddrInput.value != "" && this._ipPortInput.value != "";
      });
      TD2.appendChild(this._ipPortInput);
      Row.appendChild(TD2);
      Table.appendChild(Row);
      this._warningRow = document.createElement("TR");
      TD1 = document.createElement("TD");
      TD1.style.whiteSpace = "normal";
      TD1.style.fontSize = "smaller";
      TD1.innerText = "WARNING: Unless your web browser is configured to accept 'mixed content', trying to establish an HTTP connection from an HTTPS page is likely to fail.";
      TD1.colSpan = 2;
      this._warningRow.style.display = "none";
      this._warningRow.appendChild(TD1);
      Table.appendChild(this._warningRow);
      Row = document.createElement("TR");
      TD1 = document.createElement("TD");
      TD1.style.whiteSpace = "normal";
      TD1.style.paddingTop = "20px";
      TD1.style.paddingBottom = "20px";
      TD1.style.textAlign = "justify";
      TD1.innerText = "On YoctoHubs, protocol is HTTP and port is likely to be 80. On native Virtualhub, protocol is HTTP and port is likely to be 4444. On VirtualHub (for web), the  hub path is mandatory and should be set to your VirtualHub (for web) instance path, protocol and  port can be either HTTP and 80 or HTTPS and 433.";
      TD1.colSpan = 2;
      Row.appendChild(TD1);
      Table.appendChild(Row);
      Row = document.createElement("TR");
      TD1 = document.createElement("TD");
      TD1.style.whiteSpace = "normal";
      TD1.innerText = "Hub path:";
      Row.appendChild(TD1);
      TD2 = document.createElement("TD");
      TD2.style.whiteSpace = "normal";
      this._pathInput = document.createElement("INPUT");
      this._pathInput.value = this.DEFAULTPATH;
      this._pathInput.size = 48;
      TD2.appendChild(this._pathInput);
      Row.appendChild(TD2);
      Table.appendChild(Row);
      this._hubAddr.appendChild(Table);
      this._container.appendChild(this._hubAddr);
    }
    this._hubAddr.style.display = "";
    let tabIndex = 1;
    this._protocolInput.tabIndex = tabIndex++;
    this._ipAddrInput.tabIndex = tabIndex++;
    this._ipPortInput.tabIndex = tabIndex++;
    this._pathInput.tabIndex = tabIndex++;
    this._prevButton.tabIndex = tabIndex++;
    this._nextButton.tabIndex = tabIndex++;
    this._protocolInput.focus();
    this._nextButton.visible = true;
    this._nextButton.enabled = this._ipAddrInput.value != "";
  }
  async showConnectingPanel(visible, goingback) {
    if (!visible) {
      if (this._connectingText != null)
        this._connectingText.style.display = "none";
      return;
    }
    if (this._connectingText == null) {
      this._connectingText = this.createNewContentDiv();
      this._container.appendChild(this._connectingText);
    }
    this.removeCurrentPanelFromHistory();
    this._connectingText.innerText = "Connecting to hub " + this._ipAddrInput.value + ". Please wait...";
    this._connectingText.style.display = "";
    this._nextButton.visible = false;
    this._prevButton.visible = false;
    this._cancelButton.visible = false;
    let IP = this._ipAddrInput.value;
    let port = parseInt(this._ipPortInput.value);
    let protocol = this._protocolInput.value;
    this._currentHubLink_protocol = this._protocolInput.value;
    let RW_username = "";
    let RW_password = "";
    let RO_username = "";
    let RO_password = "";
    if (this._adminNameInput != null)
      RW_username = this._adminNameInput.value;
    if (this._adminPasswordInput != null)
      RW_password = this._adminPasswordInput.value;
    if (this._userNameInput != null)
      RO_username = this._userNameInput.value;
    if (this._userPasswordInput != null)
      RO_password = this._userPasswordInput.value;
    let url = protocol + "://" + IP + ":" + port.toString();
    let HubData = null;
    let serial = "";
    let path = this._pathInput.value;
    if (path != "") {
      if (path.charAt(0) == "/")
        path = path.slice(1);
      url += "/" + path;
    }
    let info = new HubInfo(protocol, IP, port, path, null, null);
    let infoRes = await info.makeRequest();
    if (infoRes !== true) {
      let err = "Failed to connect to the Hub while using the url\n\n" + url + "\n\n";
      let prvmsg = 'Click on the "prev" button,';
      switch (infoRes) {
        case 0:
          err += prvmsg + " and make sure that protocol, address, port and path are correct, and try again.\n\n";
          break;
        case -1:
          err += "(invalid server answer), contact yoctopuce support.";
          break;
        case -2:
          err += prvmsg + " then check path. If path is correct check hub firmware version. This installer doesn't work with versions older that " + this.FIRMWAREMINVERSION + ".";
          break;
        case -3:
          err += "An network error occured, make sure hub address is correct.\n\nAlso connexion migh have been  blocked by your web browser, most likely due to CORS policy.\n\nCheck your browser console (Shift-Control-I on most browsers), if you find an error message about a Cross-Origin Request Blocked over a 404 error, Press '<Prev' and check path carefuly.";
          break;
        case 404:
          err += prvmsg + " make sure the path is correct, and try again.";
          break;
        case 500:
          err += " the hub encountered an interal error (Error 500)";
          break;
        case 503:
          err += " the hub is  not available (Error 503)";
          break;
        case 401:
          err += " Unauthorized access, check server configuration(Error 401)";
          break;
        default:
          err += "server responded with an HTTP error " + infoRes;
          break;
      }
      this.gotoPanel(this.CONNECTIONERROR, err);
      return;
    }
    if (info.serial != "") {
      port = info.port;
      serial = info.serial;
      path = info.path;
      this._currentHub_ReadOnlyProtected = info.userPassword;
    }
    protocol = info.protocol;
    if (info.adminPassword && RW_username == "" && RW_password == "") {
      this.gotoPanel(this.PASSWORDPANEL);
      return;
    }
    await YAPI.DisableExceptions();
    let errmsg = new YErrorMsg();
    if (info.userPassword) {
      let RO_addr = info.get_hubUrl(RO_username, RO_password);
      let RO_res = await YAPI.TestHub(RO_addr, 5e3, errmsg);
      if (RO_res != YAPI.SUCCESS) {
        if (RO_res == YAPI.UNAUTHORIZED) {
          this.gotoPanel(this.PASSWORDPANEL, "ReadOnly test failed, check credentials for read only operations.");
          return;
        } else {
          let err = "Cannot connect to " + url + " : " + errmsg.msg + '.\n\nMake sure the Hub is Up and address is correct, then click the "prev" to try again';
          this.gotoPanel(this.CONNECTIONERROR, err);
          return;
        }
      }
    }
    let addr = info.get_hubUrl(RW_username, RW_password);
    this._applicationURL = IP + ":" + port.toString() + (path != "" ? "/" + path : "");
    let res = await YAPI.TestHub(addr, 5e3, errmsg);
    if (res != YAPI.SUCCESS) {
      if (res == YAPI.UNAUTHORIZED) {
        this.gotoPanel(this.PASSWORDPANEL);
        return;
      } else {
        let err = "Cannot connect to " + url + " : " + errmsg.msg + '.\n\nMake sure the Hub is Up and address is correct, then click the "prev" to try again';
        this.gotoPanel(this.CONNECTIONERROR, err);
        return;
      }
    }
    if (await YAPI.RegisterHub(addr, errmsg) != YAPI.SUCCESS) {
      let err = "Cannot connect to " + IP + " : " + errmsg.msg + '.\nMake sure the Hub is Up and address is correct, then click the "prev" to try again';
      this.gotoPanel(this.CONNECTIONERROR, err);
      return;
    }
    let m = YModule.FirstModule();
    while (m != null) {
      if (await m.get_parentHub() == "") {
        let urlMatch = false;
        let serialMatch = await m.get_serialNumber() == serial;
        if (!serialMatch)
          urlMatch = (await m.get_url()).indexOf(IP + ":" + port.toString()) > 0;
        if (serialMatch || urlMatch) {
          this._currentHub = m;
          this._currentHub_RW_username = RW_username;
          this._currentHub_RW_password = RW_password;
          this._currentHub_protocol = protocol;
          this._currentHub_Addr = IP;
          this._currentHub_port = port.toString();
          this._currentHub_path = path;
          if (await m.isReadOnly()) {
            await YAPI.UnregisterHub(await m.get_url());
            this._currentHub = null;
            this.gotoPanel(this.PASSWORDPANEL, "Write test failed, check credentials for read/write operations.");
          } else {
            this.gotoPanel(this.DESCRIPTIONPANEL);
          }
          return;
        }
      }
      m = m.nextModule();
    }
    this.gotoPanel(this.CONNECTIONERROR, "Internal Error, cannot find Hub after RegisterHub call");
  }
  removeCurrentPanelFromHistory() {
    this._history.pop();
  }
  async showConnectionError(visible, goingback, message) {
    if (!visible) {
      if (this._connectiongError != null)
        this._connectiongError.style.display = "none";
      return;
    }
    if (this._connectiongError == null) {
      this._connectiongError = this.createNewContentDiv();
      this._container.appendChild(this._connectiongError);
    }
    this.removeAllChilds(this._connectiongError);
    let Table = document.createElement("TABLE");
    let Row = document.createElement("TR");
    let TD1 = document.createElement("TD");
    TD1.style.whiteSpace = "normal";
    TD1.innerHTML = ressources.FailedIcon("64", true, false, false, false, "oops");
    Row.appendChild(TD1);
    this._ErrMsgContainer = document.createElement("TD");
    this._ErrMsgContainer.style.whiteSpace = "normal";
    this._ErrMsgContainer.style.textAlign = "justify";
    Row.appendChild(this._ErrMsgContainer);
    Table.appendChild(Row);
    this._connectiongError.appendChild(Table);
    this._ErrMsgContainer.innerText = message;
    this._nextButton.visible = false;
    this._prevButton.visible = true;
    this._cancelButton.visible = this.DEFAULTCANCELABLE;
    this._connectiongError.style.display = "";
    let tabIndex = 1;
    this._prevButton.tabIndex = tabIndex++;
    this._prevButton.focus();
  }
  MakeSureCredentialsAreNotEmpty() {
    if (this._currentHub_ReadOnlyProtected) {
      this._nextButton.enabled = this._userPasswordInput.value != "" && this._userNameInput.value != "";
    } else {
      this._nextButton.enabled = true;
    }
    if (this._adminPasswordInput.value == "" || this._adminNameInput.value == "") {
      this._nextButton.enabled = false;
    }
  }
  showPasswordPanel(visible, goingback, err) {
    if (!visible) {
      if (this._pwdPanel != null)
        this._pwdPanel.style.display = "none";
      return;
    }
    let errmsg = typeof err != "undefined" ? err : "Well, looks like this hub requires some authentication.";
    if (this._history[this._history.length - 2] == this.PASSWORDPANEL) {
      errmsg = "Invalid credentials. " + errmsg;
      this.removeCurrentPanelFromHistory();
    }
    if (this._pwdPanel == null) {
      this._pwdPanel = this.createNewContentDiv();
      this._connectionErrorMsg = document.createElement("P");
      this._connectionErrorMsg.style.marginTop = "0px";
      this._pwdPanel.appendChild(this._connectionErrorMsg);
      let Table = document.createElement("TABLE");
      let Row = document.createElement("TR");
      let TD1 = document.createElement("TD");
      TD1.style.whiteSpace = "normal";
      TD1.innerText = "Enter read/write credentials below, these are required for the installation but won't be saved in Yocto-Visualization's configuration.";
      TD1.style.fontSize = "smaller";
      TD1.colSpan = 4;
      Row.appendChild(TD1);
      Table.appendChild(Row);
      Row = document.createElement("TR");
      TD1 = document.createElement("TD");
      TD1.style.whiteSpace = "normal";
      TD1.innerText = "Username:";
      TD1.style.borderLeft = "20px solid transparent";
      TD1.style.fontSize = "smaller";
      Row.appendChild(TD1);
      let TD2 = document.createElement("TD");
      TD2.style.whiteSpace = "normal";
      TD2.style.fontSize = "smaller";
      this._adminNameInput = document.createElement("INPUT");
      this._adminNameInput.size = 12;
      this._adminNameInput.addEventListener("input", () => {
        this.MakeSureCredentialsAreNotEmpty();
      });
      TD2.appendChild(this._adminNameInput);
      Row.appendChild(TD2);
      let TD3 = document.createElement("TD");
      TD3.style.whiteSpace = "normal";
      TD3.innerText = "Password:";
      TD3.style.fontSize = "smaller";
      Row.appendChild(TD3);
      let TD4 = document.createElement("TD");
      TD4.style.whiteSpace = "normal";
      this._adminPasswordInput = document.createElement("INPUT");
      this._adminPasswordInput.type = "password";
      this._adminPasswordInput.size = 12;
      this._adminPasswordInput.addEventListener("input", () => {
        this.MakeSureCredentialsAreNotEmpty();
      });
      TD4.appendChild(this._adminPasswordInput);
      TD4.style.fontSize = "smaller";
      Row.appendChild(TD4);
      this._adminNameInput.value = this.DEFAULTUSER;
      this._adminPasswordInput.value = this.DEFAULTPWD;
      Table.appendChild(Row);
      let userRow1 = document.createElement("TR");
      TD1 = document.createElement("TD");
      TD1.style.whiteSpace = "normal";
      TD1.innerText = "\n\nEnter read-only credentials below, these will be saved in the configuration";
      TD1.style.fontSize = "smaller";
      TD1.colSpan = 4;
      userRow1.appendChild(TD1);
      Table.appendChild(userRow1);
      let userRow2 = document.createElement("TR");
      TD1 = document.createElement("TD");
      TD1.style.whiteSpace = "normal";
      TD1.innerText = "Username:";
      TD1.style.borderLeft = "20px solid transparent";
      TD1.style.fontSize = "smaller";
      userRow2.appendChild(TD1);
      TD2 = document.createElement("TD");
      TD2.style.whiteSpace = "normal";
      TD2.style.fontSize = "smaller";
      this._userNameInput = document.createElement("INPUT");
      this._userNameInput.size = 12;
      this._userNameInput.addEventListener("input", () => {
        this.MakeSureCredentialsAreNotEmpty();
      });
      TD2.appendChild(this._userNameInput);
      userRow2.appendChild(TD2);
      TD3 = document.createElement("TD");
      TD3.style.whiteSpace = "normal";
      TD3.innerText = "Password:";
      TD3.style.fontSize = "smaller";
      userRow2.appendChild(TD3);
      TD4 = document.createElement("TD");
      TD4.style.whiteSpace = "normal";
      this._userPasswordInput = document.createElement("INPUT");
      this._userPasswordInput.type = "password";
      this._userPasswordInput.size = 12;
      this._userPasswordInput.addEventListener("input", () => {
        this.MakeSureCredentialsAreNotEmpty();
      });
      TD4.appendChild(this._userPasswordInput);
      TD4.style.fontSize = "smaller";
      userRow2.appendChild(TD4);
      this._userNameInput.value = this.DEFAULTUSER;
      this._userPasswordInput.value = this.DEFAULTPWD;
      Table.appendChild(userRow2);
      Table.style.marginTop = "0px";
      Table.style.marginBottom = "20px";
      this._pwdPanel.appendChild(Table);
      let userCredVisible = "";
      if (!this._currentHub_ReadOnlyProtected) {
        userCredVisible = "none";
        this._userPasswordInput.value = "";
        this._userNameInput.value = "";
      }
      userRow1.style.display = userCredVisible;
      userRow2.style.display = userCredVisible;
      let p = document.createElement("P");
      p.innerText = 'Note: On YoctoHubs and VirtualHub, username is either "user" for readonly or "admin" for read/write. Only ready-only credentials (if any) will saved in the configuration as Yocto-Visualization will ask for read/write credentials when saving, if needed.';
      p.style.fontSize = "smaller";
      this._pwdPanel.appendChild(p);
      this._container.appendChild(this._pwdPanel);
    }
    this._connectionErrorMsg.innerText = errmsg;
    this._nextButton.visible = true;
    this._prevButton.visible = true;
    this._cancelButton.visible = this.DEFAULTCANCELABLE;
    this._pwdPanel.style.display = "";
    let tabIndex = 1;
    this._adminNameInput.tabIndex = tabIndex++;
    this._adminPasswordInput.tabIndex = tabIndex++;
    this._userNameInput.tabIndex = tabIndex++;
    this._userPasswordInput.tabIndex = tabIndex++;
    this._prevButton.tabIndex = tabIndex++;
    this._nextButton.tabIndex = tabIndex++;
    this._adminNameInput.focus();
    this.MakeSureCredentialsAreNotEmpty();
  }
  createTextRow(caption, value) {
    let Row = document.createElement("TR");
    let TD1 = document.createElement("TD");
    TD1.style.whiteSpace = "normal";
    TD1.style.whiteSpace = "nowrap";
    TD1.innerText = caption;
    Row.appendChild(TD1);
    let TD2 = document.createElement("TD");
    TD2.style.whiteSpace = "normal";
    TD2.innerText = value;
    Row.appendChild(TD2);
    return Row;
  }
  async showHubDescription(visible, goingback) {
    if (!visible) {
      if (this._descPanel != null)
        this._descPanel.style.display = "none";
      return;
    }
    if (this._descPanel == null) {
      this._descPanel = this.createNewContentDiv();
      this._container.appendChild(this._descPanel);
    }
    if (!goingback) {
      this.removeAllChilds(this._descPanel);
      this._alreadyInstalled = false;
      let p = document.createElement("P");
      p.innerText = "Sucessfully connected to Hub " + this._ipAddrInput.value;
      this._descPanel.appendChild(p);
      let m = this._currentHub;
      let Table = document.createElement("TABLE");
      Table.style.marginTop = "20px";
      Table.style.marginBottom = "20px";
      let serial = await m.get_serialNumber();
      let firmware = await m.get_firmwareRelease();
      Table.appendChild(this.createTextRow("Model:", await m.get_productName()));
      Table.appendChild(this.createTextRow("Serial:", serial));
      Table.appendChild(this.createTextRow("Firmware:", firmware));
      let tmp = firmware.lastIndexOf(".");
      if (tmp >= 0)
        firmware = firmware.substr(tmp + 1);
      this._instancesFiles = [];
      let freespace = 0;
      this._instancesFiles = [];
      this._currentfs = null;
      let error = "";
      if (firmware.indexOf("-") < 0 && parseInt(firmware) < this.FIRMWAREMINVERSION) {
        error = "Hub firmware is too old for Yocto-Visualization to run properly. You need at least version " + this.FIRMWAREMINVERSION;
        this._nextButton.enabled = false;
      }
      if (error == "") {
        let ids = await m.get_functionIds("Files");
        if (ids.length > 0) {
          this._currentfs = await YFiles.FindFiles(serial + "." + ids[0]);
          freespace = Math.floor(await this._currentfs.get_freeSpace() / 1024);
          this._instancesFiles = await this._currentfs.get_list("yv4web*");
          Table.appendChild(this.createTextRow("Free space:", freespace.toString() + "K"));
          this._nextButton.enabled = true;
          if (freespace < 200) {
            error = "Not enough free space on device, please make sure there is at least 200K available.";
            this._nextButton.enabled = false;
          }
        } else {
          error = "No filesystem found on hub. On VirtualHub, the filesystem feature needs to be explicitely enabled at startup with the -F flag.";
        }
      }
      if (error != "") {
        Table.appendChild(this.createTextRow(" ", " "));
        let Row = document.createElement("TR");
        let TD1 = document.createElement("TD");
        TD1.style.whiteSpace = "normal";
        TD1.innerHTML = ressources.FailedIcon("32", true, false, false, false, "oops");
        TD1.style.textAlign = "right";
        Row.appendChild(TD1);
        let TD2 = document.createElement("TD");
        TD2.style.whiteSpace = "normal";
        TD2.style.fontSize = "smaller";
        TD2.innerText = error;
        Row.appendChild(TD2);
        Table.appendChild(Row);
        this._nextButton.enabled = false;
      }
      this._descPanel.appendChild(Table);
      if (this._instancesFiles.length > 0) {
        let p2 = document.createElement("P");
        p2.innerText = "Yocto-Visualization (for web) appears to be already installed on this hub. Click on next to modify this installation.";
        this._descPanel.appendChild(p2);
        this._alreadyInstalled = true;
      }
    }
    this._descPanel.style.display = "";
    this._nextButton.visible = true;
    this._prevButton.visible = true;
    this._cancelButton.visible = this.DEFAULTCANCELABLE;
    let tabIndex = 1;
    this._prevButton.tabIndex = tabIndex++;
    this._nextButton.tabIndex = tabIndex++;
    this._nextButton.focus();
  }
  async loadWebPagesList(filenameDesc) {
    this._webPageinstances = [];
    let webFiles = await this._currentfs.get_list("*");
    for (let i = 0; i < webFiles.length; i++) {
      let filename = await webFiles[i].get_name();
      if (filename.indexOf(".html") >= 0) {
        if (filenameDesc != null) {
          filenameDesc.innerText = "Now downloading " + filename + "...";
        }
        let contents = await this._currentfs.download(filename);
        if (filename.slice(-3) == ".gz") {
          contents = Pako_Inflate.ungzip(contents, {});
        }
        let contentsStr = YAPI.imm_bin2str(contents);
        if (contentsStr.indexOf("window.runYV()") > 0) {
          this._webPageinstances.push(new pageInstance(filename, contents));
        }
      }
    }
  }
  async showModifyInstallPanel(visible, goingback) {
    if (!visible) {
      if (this._modifyInstallPanel != null)
        this._modifyInstallPanel.style.display = "none";
      return;
    }
    this._nextButton.visible = false;
    this._prevButton.visible = false;
    this._cancelButton.visible = false;
    if (this._modifyInstallPanel == null) {
      this._modifyInstallPanel = this.createNewContentDiv();
      this._container.appendChild(this._modifyInstallPanel);
    }
    if (!goingback) {
      this.removeAllChilds(this._modifyInstallPanel);
      this._jsCodeinstances = [];
      this._webPageinstances = [];
      let p = document.createElement("P");
      p.innerText = "Please wait, downloading and parsing files from the hub ";
      this._modifyInstallPanel.appendChild(p);
      this._modifyInstallPanel.style.display = "";
      let files = document.createElement("P");
      files.innerText = "";
      let filenameDesc = document.createElement("P");
      filenameDesc.style.fontSize = "smaller";
      this._modifyInstallPanel.appendChild(filenameDesc);
      for (let i = 0; i < this._instancesFiles.length; i++) {
        let filename = await this._instancesFiles[i].get_name();
        filenameDesc.innerText = "Now downloading " + filename + "...";
        files.innerText = filename;
        let contentsStr = "";
        let contents = await this._currentfs.download(filename);
        if (filename.slice(-3) == ".gz") {
          contents = Pako_Inflate.ungzip(contents, {});
        }
        contentsStr = YAPI.imm_bin2str(contents);
        let esTarget = "";
        let version = "";
        let readonlyVersion = true;
        let p2 = contentsStr.indexOf("*/");
        if (p2 > 0) {
          let firstLine = contentsStr.slice(0, p2);
          let p1 = firstLine.indexOf("(");
          let p22 = firstLine.indexOf(")");
          if (p1 > 0 && p22 > p1) {
            let tokens = firstLine.slice(p1 + 1, p22).split(" ");
            if (tokens.length > 0)
              esTarget = tokens[0];
            if (tokens.length > 1)
              readonlyVersion = tokens[1] != "full";
            if (tokens.length > 2)
              version = tokens[2];
          }
        }
        this._jsCodeinstances.push(new codeInstance(filename, esTarget, version, readonlyVersion));
      }
      await this.loadWebPagesList(filenameDesc);
      filenameDesc.style.display = "none";
      p.innerText = "What would you like to do ?";
      let uninstallLegend = document.createElement("span");
      uninstallLegend.innerText = "Uninstall / delete all Yocto-Visualization (for web) related files\n\n";
      this._uninstallOpt = document.createElement("input");
      this._uninstallOpt.setAttribute("type", "radio");
      this._uninstallOpt.setAttribute("name", "installType");
      this._modifyInstallPanel.appendChild(this._uninstallOpt);
      this._modifyInstallPanel.appendChild(uninstallLegend);
      let BuildsFound = {};
      for (let i = 0; i < this._jsCodeinstances.length; i++) {
        BuildsFound[this._jsCodeinstances[i].version] = 1;
      }
      let BuildsFoundList = "";
      for (let key in BuildsFound) {
        if (BuildsFound.hasOwnProperty(key)) {
          BuildsFoundList += (BuildsFoundList != "" ? ", " : "") + key;
        }
      }
      let updateLegend = document.createElement("span");
      updateLegend.innerText = "Update all from " + BuildsFoundList + " to " + constants.buildVersion + "\n\n";
      this._updateOpt = document.createElement("input");
      this._updateOpt.setAttribute("type", "radio");
      this._updateOpt.setAttribute("name", "installType");
      this._modifyInstallPanel.appendChild(this._updateOpt);
      this._modifyInstallPanel.appendChild(updateLegend);
      let addInstanceLegend = document.createElement("span");
      addInstanceLegend.innerText = "Add a new instance \n\n";
      this._addInstanceOpt = document.createElement("input");
      this._addInstanceOpt.setAttribute("type", "radio");
      this._addInstanceOpt.setAttribute("name", "installType");
      this._modifyInstallPanel.appendChild(this._addInstanceOpt);
      this._modifyInstallPanel.appendChild(addInstanceLegend);
      let modInstanceLegend = document.createElement("span");
      modInstanceLegend.innerText = "Modify or delete existing instances \n\n";
      this._modInstanceOpt = document.createElement("input");
      this._modInstanceOpt.setAttribute("type", "radio");
      this._modInstanceOpt.setAttribute("name", "installType");
      this._modifyInstallPanel.appendChild(this._modInstanceOpt);
      this._modifyInstallPanel.appendChild(modInstanceLegend);
      if (!this._uninstallOpt.checked && !this._updateOpt.checked && !this._addInstanceOpt.checked && !this._modInstanceOpt.checked) {
        this._updateOpt.checked = true;
      }
    }
    this._modifyInstallPanel.style.display = "";
    this._nextButton.enabled = true;
    this._prevButton.enabled = true;
    this._nextButton.visible = true;
    this._prevButton.visible = true;
    this._cancelButton.visible = this.DEFAULTCANCELABLE;
    let tabIndex = 1;
    this._uninstallOpt.tabIndex = tabIndex++;
    this._updateOpt.tabIndex = tabIndex++;
    this._addInstanceOpt.tabIndex = tabIndex++;
    this._modInstanceOpt.tabIndex = tabIndex++;
    this._prevButton.tabIndex = tabIndex++;
    this._nextButton.tabIndex = tabIndex++;
    this._nextButton.focus();
  }
  async showModInstancesPanel(visible, goingback) {
    if (!visible) {
      if (this._modInstancesPanel != null)
        this._modInstancesPanel.style.display = "none";
      return;
    }
    if (this._modInstancesPanel == null) {
      this._modInstancesPanel = this.createNewContentDiv();
      this._container.appendChild(this._modInstancesPanel);
    }
    let tabIndex = 1;
    if (!goingback) {
      this.removeAllChilds(this._modInstancesPanel);
      let p = document.createElement("P");
      this._modInstancesPanel.appendChild(p);
      p.innerText = "Here is a list of installed instances. Select an action for each one, then click on next to have them applied.";
      let table = document.createElement("Table");
      table.style.marginLeft = "20px";
      for (let i = 0; i < this._webPageinstances.length; i++) {
        let tr = document.createElement("TR");
        let td = document.createElement("TD");
        td.style.whiteSpace = "normal";
        td.innerText = this._webPageinstances[i].http_filename + (this._webPageinstances[i].compressed ? "[.gz]" : "");
        tr.appendChild(td);
        let td2 = document.createElement("TD");
        td2.style.whiteSpace = "normal";
        td2.style.paddingLeft = "10px";
        let chooser = document.createElement("SELECT");
        chooser.tabIndex = tabIndex++;
        let opt = document.createElement("OPTION");
        opt.tabIndex = tabIndex++;
        opt.text = "Do Nothing";
        opt.value = this._MODIFYNOTHING.toString();
        chooser.add(opt);
        let opt2 = document.createElement("OPTION");
        if (this._webPageinstances[i].compressed) {
          opt2.text = "Uncompress instance file";
          opt2.value = this._MODIFYUNCOMPRESS.toString();
        } else {
          opt2.text = "Compress instance file";
          opt2.value = this._MODIFYCOMPRESS.toString();
        }
        chooser.add(opt2);
        let opt3 = document.createElement("OPTION");
        if (this._webPageinstances[i].readonly) {
          opt3.text = "Allow read/write";
          opt3.value = this._MODIFYMAKEREADWRITE.toString();
        } else {
          opt3.text = "Make read only";
          opt3.value = this._MODIFYMAKEREADONLY.toString();
        }
        chooser.add(opt3);
        let opt4 = document.createElement("OPTION");
        if (this._webPageinstances[i].useMinified) {
          opt4.text = "Use human readable JS module";
          opt4.value = this._MODIFYUSEPLAIN.toString();
        } else {
          opt4.text = "Use minified JS module";
          opt4.value = this._MODIFYUSEMINIFIED.toString();
        }
        chooser.add(opt4);
        let opt5 = document.createElement("OPTION");
        opt5.text = "Delete (cannot be reverted)";
        opt5.value = this._MODIFYDELETE.toString();
        chooser.add(opt5);
        let index = i;
        chooser.addEventListener("change", () => {
          this._webPageinstances[index].action = Number(chooser.value);
        });
        td2.appendChild(chooser);
        tr.appendChild(td2);
        table.appendChild(tr);
      }
      this._modInstancesPanel.appendChild(table);
      let p2 = document.createElement("P");
      this._removeUnusedJs = document.createElement("INPUT");
      this._removeUnusedJs.tabIndex = tabIndex++;
      this._removeUnusedJs.type = "checkbox";
      this._removeUnusedJs.checked = true;
      p2.appendChild(this._removeUnusedJs);
      let span = document.createElement("SPAN");
      span.innerText = "Remove unused Yocto-Visualization (for web) JS module files";
      p2.appendChild(span);
      this._modInstancesPanel.appendChild(p2);
      this._prevButton.tabIndex = tabIndex++;
      this._nextButton.tabIndex = tabIndex++;
      this._nextButton.focus();
    }
    this._modInstancesPanel.style.display = "";
  }
  async showCustomFilesPanel(visible, goingback) {
    if (!visible) {
      if (this._customFilesPanel != null)
        this._customFilesPanel.style.display = "none";
      return;
    }
    if (this._customFilesPanel == null) {
      this._customFilesPanel = this.createNewContentDiv();
      this._container.appendChild(this._customFilesPanel);
    }
    if (!goingback) {
      this.removeAllChilds(this._customFilesPanel);
      let p = document.createElement("P");
      p.innerText = this._plannedaction == this.ACTIONINSTALL ? "Optionnaly, you can customize your Yocto-Visualization (for web) installation by providing some files" : "Optionnaly, you can customize your new instance by providing some files";
      this._customFilesPanel.appendChild(p);
      let Table = document.createElement("TABLE");
      Table.style.fontSize = "smaller";
      Table.style.marginTop = "20px";
      Table.style.marginBottom = "20px";
      let Row;
      let TD1;
      let TD2;
      Row = document.createElement("TR");
      TD1 = document.createElement("TD");
      TD1.style.whiteSpace = "normal";
      TD1.colSpan = 2;
      TD1.style.textAlign = "justify";
      TD1.innerText = 'You can choose an initial XML configuration file. You can get a XML configuration file from a Yocto-Visualization (for web) instance in the  "Global configulation" panel. You can also use a config.xml file from the Yocto-Visualization native version.';
      Row.appendChild(TD1);
      Table.appendChild(Row);
      Row = document.createElement("TR");
      TD1 = document.createElement("TD");
      TD1.style.whiteSpace = "normal";
      TD1.innerText = "Config file:";
      Row.appendChild(TD1);
      TD2 = document.createElement("TD");
      TD2.style.whiteSpace = "normal";
      this._configFileInput = document.createElement("INPUT");
      this._configFileInput.type = "file";
      this._configFileInput.accept = ".xml";
      TD2.appendChild(this._configFileInput);
      Row.style.marginBottom = "10px";
      Row.appendChild(TD2);
      Table.appendChild(Row);
      Row = document.createElement("TR");
      TD1 = document.createElement("TD");
      TD1.style.whiteSpace = "normal";
      TD1.colSpan = 2;
      TD1.style.textAlign = "justify";
      TD1.innerText = "\nYou can choose a container HTML file. Note: if this file relies on local dependencies such as images or CSS files, you'll have to upload them on the hub yourself.";
      Row.appendChild(TD1);
      Table.appendChild(Row);
      this._customFilesPanel.appendChild(Table);
      Row = document.createElement("TR");
      TD1 = document.createElement("TD");
      TD1.style.whiteSpace = "normal";
      TD1.innerText = "HTML file:";
      Row.appendChild(TD1);
      TD2 = document.createElement("TD");
      TD2.style.whiteSpace = "normal";
      this._webPageInput = document.createElement("INPUT");
      this._webPageInput.type = "file";
      this._webPageInput.accept = ".html";
      TD2.appendChild(this._webPageInput);
      Row.appendChild(TD2);
      Table.appendChild(Row);
    }
    this._customFilesPanel.style.display = "";
    this._nextButton.enabled = true;
    this._prevButton.enabled = true;
    this._nextButton.visible = true;
    this._prevButton.visible = true;
    this._cancelButton.visible = this.DEFAULTCANCELABLE;
    let tabIndex = 1;
    this._webPageInput.tabIndex = tabIndex++;
    this._configFileInput.tabIndex = tabIndex++;
    this._prevButton.tabIndex = tabIndex++;
    this._nextButton.tabIndex = tabIndex++;
    this._nextButton.focus();
  }
  async showOptionsPanel(visible, goingback) {
    if (!visible) {
      if (this._optionsPanel != null)
        this._optionsPanel.style.display = "none";
      return;
    }
    if (this._optionsPanel == null) {
      this._optionsPanel = this.createNewContentDiv();
      let p = document.createElement("P");
      p.innerText = this._plannedaction == this.ACTIONINSTALL ? "You can also customize the installation behavior" : "You can also customize this new instance behavior";
      this._optionsPanel.appendChild(p);
      p = document.createElement("P");
      p.style.fontSize = "smaller";
      p.style.marginBottom = "0px";
      p.style.marginTop = "0px";
      this._fileprefixInput = document.createElement("INPUT");
      let presetname = this.DEFAULTFILEPREFIX;
      let n = 1;
      let checkgain = false;
      do {
        checkgain = false;
        for (let i = 0; i < this._webPageinstances.length; i++) {
          if (presetname + this.TARGETEXTENSION == this._webPageinstances[i].http_filename) {
            n++;
            presetname = this.DEFAULTFILEPREFIX + "(" + n.toString() + ")";
            checkgain = true;
          }
        }
      } while (checkgain);
      this._fileprefixInput.value = presetname;
      this._fileprefixInput.maxLength = 10;
      this._fileprefixInput.size = 10;
      let span = document.createElement("SPAN");
      span.innerText = "Set the instance name to : ";
      p.appendChild(span);
      p.appendChild(this._fileprefixInput);
      this._optionsPanel.appendChild(p);
      p = document.createElement("P");
      p.style.fontSize = "smaller";
      p.style.marginBottom = "0px";
      p.style.marginTop = "0px";
      this._useFullVersionInput = document.createElement("INPUT");
      this._useFullVersionInput.type = "checkbox";
      p.appendChild(this._useFullVersionInput);
      span = document.createElement("SPAN");
      span.innerText = this._plannedaction == this.ACTIONINSTALL ? "Install the non-minified version (easier to debug)" : "Use the non-minified version (easier to debug)";
      p.appendChild(span);
      this._optionsPanel.appendChild(p);
      p = document.createElement("P");
      p.style.fontSize = "smaller";
      p.style.marginBottom = "0px";
      p.style.marginTop = "0px";
      this._makeDefaultInput = document.createElement("INPUT");
      this._makeDefaultInput.type = "checkbox";
      p.appendChild(this._makeDefaultInput);
      span = document.createElement("SPAN");
      span.innerText = this._plannedaction == this.ACTIONINSTALL ? "Make Yocto-Visualization (for web) the hub's default page" : "Make this instance the hub's default page";
      p.appendChild(span);
      this._optionsPanel.appendChild(p);
      p = document.createElement("P");
      p.style.fontSize = "smaller";
      p.style.marginBottom = "0px";
      p.style.marginTop = "0px";
      this._useReadOnlyInput = document.createElement("INPUT");
      this._useReadOnlyInput.type = "checkbox";
      p.appendChild(this._useReadOnlyInput);
      span = document.createElement("SPAN");
      span.innerText = this._plannedaction == this.ACTIONINSTALL ? "Make the install read-only" : "Make this instance read-only";
      p.appendChild(span);
      this._optionsPanel.appendChild(p);
      if (this._jsCodeinstances.length > 0) {
        this._useReadOnlyInput.checked = this._jsCodeinstances[0].readonly;
        this._useFullVersionInput.checked = !this._jsCodeinstances[0].minified;
      }
      p = document.createElement("P");
      p.innerText = 'Click on "Next" button to start the installation';
      this._optionsPanel.appendChild(p);
      this._container.appendChild(this._optionsPanel);
    }
    this._nextButton.visible = true;
    this._prevButton.visible = true;
    this._cancelButton.visible = this.DEFAULTCANCELABLE;
    this._optionsPanel.style.display = "";
    let tabIndex = 1;
    this._fileprefixInput.tabIndex = tabIndex++;
    this._useFullVersionInput.tabIndex = tabIndex++;
    this._makeDefaultInput.tabIndex = tabIndex++;
    this._useReadOnlyInput.tabIndex = tabIndex++;
    this._prevButton.tabIndex = tabIndex++;
    this._nextButton.tabIndex = tabIndex++;
    this._nextButton.focus();
  }
  logLine(line) {
    let p = document.createElement("P");
    p.innerText = line + " ";
    p.style.fontSize = "smaller";
    p.style.marginLeft = "10px";
    p.style.marginTop = "0px;";
    p.style.marginBottom = "0px;";
    p.style.paddingTop = "0px;";
    p.style.paddingBottom = "0px;";
    let span = document.createElement("SPAN");
    p.appendChild(span);
    this._runPanel.appendChild(p);
    return span;
  }
  async showRunPanel(visible, goingback) {
    if (!visible) {
      if (this._runPanel != null)
        this._runPanel.style.display = "none";
      return;
    }
    if (this._runPanel == null) {
      this._runPanel = this.createNewContentDiv();
    }
    this.removeAllChilds(this._runPanel);
    this._runPanel.style.display = "";
    let desc = document.createElement("P");
    this._runPanel.appendChild(desc);
    this._container.appendChild(this._runPanel);
    this._nextButton.visible = false;
    this._prevButton.visible = false;
    this._cancelButton.visible = false;
    switch (this._plannedaction) {
      case this.ACTIONINSTALL:
        desc.innerText = "Installing on " + this._currentHub_Addr + "... please wait.";
        try {
          await this.install((line) => {
            return this.logLine(line);
          });
        } catch (e) {
          this.gotoPanel(this.CONNECTIONERROR, "Installation failed with an internal error : " + e.toString() + "\n\nFeel free to contact Yoctopuce support.");
        }
        break;
      case this.ACTIONADDINSTANCE:
        desc.innerText = "Creating new instance  on " + this._currentHub_Addr + "... please wait.";
        try {
          await this.install((line) => {
            return this.logLine(line);
          });
        } catch (e) {
          this.gotoPanel(this.CONNECTIONERROR, "Instance creation failed with an internal error : " + e.toString() + "\n\nFeel free to contact Yoctopuce support.");
        }
        break;
      case this.ACTIONUNINSTALL:
        desc.innerText = "Uninstalling everything from " + this._currentHub_Addr + "... please wait.";
        try {
          await this.uninstall((line) => {
            return this.logLine(line);
          });
        } catch (e) {
          this.gotoPanel(this.CONNECTIONERROR, "Installation failed with an internal error : " + e.toString() + "\n\nFeel free to contact Yoctopuce support.");
        }
        break;
      case this.ACTIONUPDATE:
        desc.innerText = "Updating js files on " + this._currentHub_Addr + "... please wait.";
        try {
          await this.upgrade((line) => {
            return this.logLine(line);
          });
        } catch (e) {
          this.gotoPanel(this.CONNECTIONERROR, "Update failed with an internal error : " + e.toString() + "\n\nFeel free to contact Yoctopuce support.");
        }
        break;
      case this.ACTIONMODINSTANCE:
        desc.innerText = "Modifying instances on " + this._currentHub_Addr + "... please wait.";
        try {
          await this.modifyInstances((line) => {
            return this.logLine(line);
          });
        } catch (e) {
          this.gotoPanel(this.CONNECTIONERROR, "Instances modification failed with an internal error : " + e.toString() + "\n\nFeel free to contact Yoctopuce support.");
        }
        break;
    }
  }
  checkHTMLfile(htmlData, errmsg) {
    let upper = htmlData.toUpperCase();
    if (upper.indexOf("<HTML") < 0) {
      errmsg.msg = "Provided web page is not a proper HTML file: no HTML tag";
      return false;
    }
    if (upper.indexOf("</BODY>") < 0) {
      errmsg.msg = "Provided web page has an unexpected structure: no closing BODY tag";
      return false;
    }
    return true;
  }
  checkConfigfile(xmlData, errmsg) {
    let parser = new DOMParser();
    let doc = parser.parseFromString(xmlData, "application/xml");
    let root = null;
    doc.childNodes.forEach((node) => {
      if (node.nodeName.toUpperCase() == "ROOT" && root == null)
        root = node;
    });
    if (root == null) {
      errmsg.msg = "Provided config XML file is not a proper YoctoVisualization 2 config file. Unable to find ROOT node, either the root node does not exists or the file caused an XML parse error.";
      return false;
    }
    let rootNode = new YXmlNode(root);
    let attributes = rootNode.Attributes;
    if (!attributes.hasOwnProperty("version")) {
      errmsg.msg = "Provided  XML config file is not a proper Yocto-Visualization 2 config file (No ROOT Version attribute)";
      return false;
    }
    if (parseFloat(attributes["version"]) < 2) {
      errmsg.msg = "Provided XML config file is not a proper Yocto-Visualization 2 config file (at least Version 2.0 is required)";
      return false;
    }
    return true;
  }
  findChild(parent, name) {
    let res = null;
    parent.childNodes.forEach((node) => {
      if (node.nodeName == name) {
        res = node;
        return;
      }
    });
    return res;
  }
  patchConfigFile(xmlData) {
    let startTag = "<Hubs>";
    let endTag = "</Hubs>";
    let parser = new DOMParser();
    let doc = parser.parseFromString(xmlData, "application/xml");
    let rootNode = this.findChild(doc, "ROOT");
    if (rootNode == null)
      throw "No root node in config file.";
    let configNode = this.findChild(rootNode, "Config");
    if (configNode == null)
      throw "No config node in config file.";
    let Hubs = this.findChild(configNode, "Hubs");
    let HubSection;
    if (Hubs == null) {
      HubSection = startTag + "\n" + this.getHubConfig() + "\n" + endTag + "\n";
      xmlData = xmlData.replace("<Config>", "<Config>\n" + HubSection);
    } else {
      let list = Hubs.childNodes;
      let sourceHubFound = false;
      HubSection = startTag + "\n";
      for (let i = 0; i < list.length; i++) {
        if (list[i].nodeName == "Hub") {
          let node = new YXmlNode(list[i]);
          let attributes = node.Attributes;
          let addr = attributes.hasOwnProperty("addr") ? attributes["addr"] : "";
          let port = attributes.hasOwnProperty("port") ? attributes["port"] : "80";
          let protocol = attributes.hasOwnProperty("protocol") ? attributes["protocol"] : "";
          let path = attributes.hasOwnProperty("path") ? attributes["path"] : "";
          let username = attributes.hasOwnProperty("user") ? attributes["user"] : "";
          let password = attributes.hasOwnProperty("password") ? attributes["password"] : "";
          if (!sourceHubFound && addr == this._currentHub_Addr && port == this._currentHub_port && path == this._currentHub_path) {
            sourceHubFound = true;
            HubSection += "    " + this.getHubConfig() + "\n";
          } else {
            HubSection += "    " + this.createHubRecord(protocol, addr, port, path, username, password, true) + "\n";
          }
        }
      }
      if (!sourceHubFound)
        HubSection += "    " + this.getHubConfig() + "\n";
      HubSection += "  ";
      let indexStart = xmlData.indexOf(startTag);
      let indexStop = xmlData.indexOf(endTag);
      if (indexStart < 0)
        throw "Cannot locate Hubs start tag in provided  config file";
      if (indexStop < 0)
        throw "Cannot locate Hubs end tag in provided  config file";
      xmlData = xmlData.substr(0, indexStart) + HubSection + xmlData.substr(indexStop);
    }
    return xmlData;
  }
  createHubRecord(protocol, addr, port, path, username, password, removable) {
    let res = '<Hub protocol="' + constants.XMLquote(protocol) + '" addr="' + constants.XMLquote(addr) + '" port="' + constants.XMLquote(port) + '"';
    if (path != "")
      res += ' path="' + constants.XMLquote(path) + '"';
    if (username != "")
      res += ' user="' + constants.XMLquote(username) + '"';
    if (password != "")
      res += ' password="' + constants.XMLquote(password) + '"';
    if (!removable)
      res += ' removable="FALSE"';
    res += "/>";
    return res;
  }
  getHubConfig() {
    let username = "";
    let password = "";
    if (this._currentHub_ReadOnlyProtected) {
      username = this._userNameInput.value;
      password = Hub.encryptPassword(this._userPasswordInput.value);
    }
    return this.createHubRecord(this._currentHub_protocol, this._currentHub_Addr, this._currentHub_port, this._currentHub_path, username, password, false);
  }
  getSeedCode(configfile, readonly, minified) {
    let res = '\n<script type="module">\n';
    if (configfile == null)
      configfile = '<?xml version="1.0" ?><ROOT version="2.1"><Config><Hubs>' + this.getHubConfig() + "</Hubs></Config></ROOT>\n";
    let filename = "yv4web-" + (readonly ? "readonly" : "full") + (minified ? ".min" : "") + ".js";
    res += ' import { YWebPage, YoctoHubFileHandler }  from "./' + filename + '";\n';
    res += " window.runYV= async ()=>{";
    res += " let filehandler = await YoctoHubFileHandler.start(";
    if (configfile != null)
      res += JSON.stringify(configfile);
    res += ");\n";
    res += "  YWebPage.run(filehandler.xmlConfigData, filehandler.configChangeCallbackFct";
    if (!readonly)
      res += ",filehandler.saveFct";
    res += ");\n";
    res += "};\n window.runYV();</script>\n";
    res += '<script nomodule="">\n';
    res += `document.write("<p style='font-family: sans-serif; text-align:center'>Yocto-Visualization (for web) cannot run on this browser. Sorry.<br>Consider using a more recent browser, or <a href='https://www.yoctopuce.com/EN/tools.php'>the native version</a>. </p>")
`;
    res += "</script>\n";
    return res;
  }
  defaultHTMLfile(configfile, readonly, minified) {
    return "<!DOCTYPE HTML>\n<HTML lang='en-US'><HEAD>\n<title>\nYocto-Visualization</title>\n" + this.icon + "\n<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no'/></HEAD>\n<BODY>\n</BODY>" + this.getSeedCode(configfile, readonly, minified) + "\n</HTML>\n";
  }
  async uploadWidthProgress(str_path, bin_content, progress) {
    let yreq = await this._currentfs._uploadWithProgress(str_path, bin_content, progress);
    return yreq.errorType;
  }
  async upgrade(log) {
    let install_minified_readonly = false;
    let install_plain_readonly = false;
    let install_minified_readwrite = false;
    let install_plain_readwrite = false;
    for (let i = 0; i < this._jsCodeinstances.length; i++) {
      if (this._jsCodeinstances[i].minified) {
        if (this._jsCodeinstances[i].readonly) {
          install_minified_readonly = true;
        } else {
          install_minified_readwrite = true;
        }
      } else {
        if (this._jsCodeinstances[i].readonly) {
          install_plain_readonly = true;
        } else {
          install_plain_readwrite = true;
        }
      }
    }
    if (install_minified_readonly)
      await this.copyJsCode(log, true, true);
    if (install_plain_readonly)
      await this.copyJsCode(log, true, false);
    if (install_minified_readwrite)
      await this.copyJsCode(log, false, true);
    if (install_plain_readwrite)
      await this.copyJsCode(log, false, false);
    log("Done.");
    setTimeout(() => {
      this.gotoPanel(this.DONEPANEL);
    }, 2e3);
  }
  async syncJsFile(log, required, readonly, minified, removeunused) {
    let jsfile = this.get_js_filename(readonly, minified) + ".gz";
    let exists = await this._currentfs.fileExist(jsfile);
    if (required && !exists)
      await this.copyJsCode(log, readonly, minified);
    if (!required && exists && removeunused) {
      let span = log("Deleting " + jsfile);
      await this._currentfs.remove(jsfile);
      span.innerText = "done.";
    }
  }
  async syncJsFileVersions(log, removeunused) {
    let require_minified_readonly = false;
    let require_plain_readonly = false;
    let require_minified_readwrite = false;
    let require_plain_readwrite = false;
    for (let i = 0; i < this._webPageinstances.length; i++) {
      if (this._webPageinstances[i].useMinified) {
        if (this._webPageinstances[i].readonly) {
          require_minified_readonly = true;
        } else {
          require_minified_readwrite = true;
        }
      } else {
        if (this._webPageinstances[i].readonly) {
          require_plain_readonly = true;
        } else {
          require_plain_readwrite = true;
        }
      }
    }
    await this.syncJsFile(log, require_minified_readonly, true, true, removeunused);
    await this.syncJsFile(log, require_plain_readonly, true, false, removeunused);
    await this.syncJsFile(log, require_minified_readwrite, false, true, removeunused);
    await this.syncJsFile(log, require_plain_readwrite, false, false, removeunused);
  }
  async patchPageInstance(log, page, signature1, replace1, altsignature1, altreplace1, signature2, replace2) {
    let contents = YAPI.imm_bin2str(page.contents);
    let p = contents.indexOf(signature1);
    if (p < 0 && altsignature1 != "") {
      signature1 = altsignature1;
      replace1 = altreplace1;
      p = contents.indexOf(signature1);
    }
    if (p < 0)
      throw "Operation failed: cannot find the [" + signature1 + "] import signature in " + page.fs_filename;
    contents = contents.substr(0, p) + replace1 + contents.substr(p + signature1.length);
    if (signature2 != "") {
      p = contents.indexOf(signature2);
      if (p < 0)
        throw "Operation failed: cannot find the [" + signature2 + "] signature parameter in " + page.fs_filename;
      contents = contents.substr(0, p) + replace2 + contents.substr(p + signature2.length);
    }
    let bincontents = YAPI.imm_str2bin(contents);
    let filename = page.fs_filename;
    if (page.compressed) {
      let status2 = log("Compressing  " + filename);
      bincontents = Pako_Deflate.gzip(bincontents, {level: 9});
      status2.innerText = "done";
    }
    let status = log("Uploading  " + filename + " to hub");
    status.innerText = "0%";
    let success = await this.uploadWidthProgress(filename, bincontents, (curr, total) => {
      status.innerText = Math.round(100 * curr / total).toString() + "%";
    });
    status.innerText = "done";
    if (success != YAPI_SUCCESS)
      throw "Upload failed (Error" + success.toString() + ")";
  }
  async modifyInstances(log) {
    for (let i = 0; i < this._webPageinstances.length; i++) {
      switch (this._webPageinstances[i].action) {
        case this._MODIFYNOTHING:
          break;
        case this._MODIFYDELETE:
          let span = log("Deleting " + this._webPageinstances[i].fs_filename);
          await this._currentfs.remove(this._webPageinstances[i].fs_filename);
          span.innerText = "done.";
          break;
        case this._MODIFYUNCOMPRESS:
          {
            let filename = this._webPageinstances[i].http_filename;
            let status = log("Uploading  " + filename + " to hub");
            status.innerText = "0%";
            let success = await this.uploadWidthProgress(filename, this._webPageinstances[i].contents, (curr, total) => {
              status.innerText = Math.round(100 * curr / total).toString() + "%";
            });
            status.innerText = "done";
            if (success != YAPI_SUCCESS)
              throw "Upload failed (Error" + success.toString() + ")";
            status = log("Deleting " + this._webPageinstances[i].fs_filename);
            await this._currentfs.remove(this._webPageinstances[i].fs_filename);
            status.innerText = "done.";
          }
          break;
        case this._MODIFYCOMPRESS:
          {
            let filename = this._webPageinstances[i].http_filename + ".gz";
            let status = log("Compressing  " + filename);
            let GZ_data = Pako_Deflate.gzip(this._webPageinstances[i].contents, {level: 9});
            status.innerText = "done";
            status = log("Uploading  " + filename + " to hub");
            status.innerText = "0%";
            let success = await this.uploadWidthProgress(filename, GZ_data, (curr, total) => {
              status.innerText = Math.round(100 * curr / total).toString() + "%";
            });
            status.innerText = "done";
            if (success != YAPI_SUCCESS)
              throw "Upload failed (Error" + success.toString() + ")";
            status = log("Deleting " + this._webPageinstances[i].http_filename);
            await this._currentfs.remove(this._webPageinstances[i].http_filename);
            status.innerText = "done.";
          }
          break;
        case this._MODIFYMAKEREADONLY:
          await this.patchPageInstance(log, this._webPageinstances[i], 'from "./yv4web-full', 'from "./yv4web-readonly', "", "", ",filehandler.saveFct);", ");");
          this._webPageinstances[i].readonly = true;
          break;
        case this._MODIFYMAKEREADWRITE:
          await this.patchPageInstance(log, this._webPageinstances[i], 'from "./yv4web-readonly', 'from "./yv4web-full', "", "", "filehandler.configChangeCallbackFct);", "filehandler.configChangeCallbackFct,filehandler.saveFct);");
          this._webPageinstances[i].readonly = false;
          break;
        case this._MODIFYUSEPLAIN:
          await this.patchPageInstance(log, this._webPageinstances[i], '"./yv4web-full.min.js"', '"./yv4web-full.js"', '"./yv4web-readonly.min.js"', '"./yv4web-readonly.js"', "", "");
          this._webPageinstances[i].useMinified = false;
          break;
        case this._MODIFYUSEMINIFIED:
          await this.patchPageInstance(log, this._webPageinstances[i], '"./yv4web-full.js"', '"./yv4web-full.min.js"', '"./yv4web-readonly.js"', '"./yv4web-readonly.min.js"', "", "");
          this._webPageinstances[i].useMinified = true;
          break;
      }
    }
    await this.syncJsFileVersions(log, this._removeUnusedJs.checked);
    log("Done.");
    setTimeout(() => {
      this.gotoPanel(this.DONEPANEL);
    }, 2e3);
  }
  async uninstall(log) {
    for (let i = 0; i < this._jsCodeinstances.length; i++) {
      let filename = this._jsCodeinstances[i].filename;
      log("Deleteting " + filename);
      await this._currentfs.remove(filename);
    }
    let network = await YNetwork.FindNetwork(await this._currentHub.get_serialNumber() + ".network");
    let startPage = await network.get_defaultPage();
    let mustResetStartPage = false;
    for (let i = 0; i < this._webPageinstances.length; i++) {
      let filename = this._webPageinstances[i].fs_filename;
      if (startPage == this._webPageinstances[i].http_filename)
        mustResetStartPage = true;
      log("Deleteting " + filename);
      await this._currentfs.remove(filename);
    }
    if (mustResetStartPage) {
      log("Setting default page to index.html");
      await network.set_defaultPage("");
      await this._currentHub.saveToFlash();
    }
    log("Done.");
    setTimeout(() => {
      this.gotoPanel(this.DONEPANEL);
    }, 2e3);
  }
  get_js_filename(readonly, minified) {
    return "yv4web-" + (readonly ? "readonly" : "full") + (minified ? ".min" : "") + ".js";
  }
  get_js_blob(readonly, minified) {
    let data;
    if (readonly) {
      data = minified ? BinariesBlobs.ro_minjs : BinariesBlobs.ro_js;
    } else {
      data = minified ? BinariesBlobs.rw_minjs : BinariesBlobs.rw_js;
    }
    if (data == "")
      return null;
    return YAPI.imm_str2bin(atob(data));
  }
  async copyJsCode(log, readonly, minified) {
    let currentURL = window.location.href;
    let filename = currentURL.split("/").pop().split("#")[0].split("?")[0];
    let jsfile = this.get_js_filename(readonly, minified);
    let GZ_data = this.get_js_blob(readonly, minified);
    let status;
    if (GZ_data == null) {
      status = log("Downloading " + jsfile + " module from server..");
      let jsfileURL = currentURL.replace(filename, "../../dist/" + this.ESVersion + "/" + jsfile);
      let result;
      result = await YoctoHubFileHandler.makeRequest("GET", jsfileURL);
      if (result.data == null) {
        let err = "Installation Failed: cannot download the Yocto-Visualization file from the serveur serving this installer.\n\nError was : " + result.statusText + "\n\nURL was: " + jsfileURL;
        this.gotoPanel(this.CONNECTIONERROR, err);
        return;
      }
      status.innerText = "done.";
      status = log("Compressing JS Module..");
      GZ_data = Pako_Deflate.gzip(result.data, {level: 9});
      status.innerText = "done.";
    }
    status = log("Copying JS Module to hub..");
    status.innerText = "0%";
    let success = await this.uploadWidthProgress(jsfile + ".gz", GZ_data, (curr, total) => {
      status.innerText = Math.round(100 * curr / total).toString() + "%";
    });
    if (success != YAPI_SUCCESS)
      throw "Upload failed (Error" + success.toString() + ")";
    status.innerText = "done.";
  }
  async install(log) {
    let configFile = await this.loadLocalFile(this._configFileInput);
    if (configFile != null) {
      configFile = configFile.replace("<!-->", "<!-- ");
      let err = new YErrorMsg();
      if (!this.checkConfigfile(configFile, err)) {
        this.gotoPanel(this.CONNECTIONERROR, "Installation failed\n\n" + err.msg);
        return;
      }
      let index = configFile.toUpperCase().indexOf("</ROOT");
      if (index < 0)
        this.gotoPanel(this.CONNECTIONERROR, "Installation failed\n\nunable to find ROOT closing tag in provided config file");
      configFile = configFile.substring(0, index) + "</ROOT>\n";
      configFile = this.patchConfigFile(configFile);
    }
    let htmlFile = await this.loadLocalFile(this._webPageInput);
    if (htmlFile != null) {
      let err = new YErrorMsg();
      if (!this.checkHTMLfile(htmlFile, err)) {
        this.gotoPanel(this.CONNECTIONERROR, "Installation failed\n\n" + err.msg);
        return;
      }
    }
    let status;
    let GZ_data;
    let success;
    let readonly = this._useReadOnlyInput.checked;
    let minified = !this._useFullVersionInput.checked;
    let mustInstallJsCode = this._plannedaction == this.ACTIONINSTALL;
    if (this._plannedaction == this.ACTIONADDINSTANCE) {
      mustInstallJsCode = true;
      for (let i = 0; i < this._jsCodeinstances.length; i++) {
        if (this._jsCodeinstances[i].minified == minified && this._jsCodeinstances[i].readonly == readonly) {
          mustInstallJsCode = false;
        }
      }
    }
    if (mustInstallJsCode)
      await this.copyJsCode(log, readonly, minified);
    status = log("Creating HTML file..");
    let targetHTMLfile;
    if (htmlFile != null) {
      let index = htmlFile.toUpperCase().indexOf("</BODY>");
      let tag = htmlFile.substr(index, 7);
      targetHTMLfile = htmlFile.replace(tag, tag + this.getSeedCode(configFile, readonly, minified));
    } else {
      targetHTMLfile = this.defaultHTMLfile(configFile, readonly, minified);
    }
    status = log("Compressing  HTML file..");
    GZ_data = Pako_Deflate.gzip(YAPI.imm_str2bin(targetHTMLfile), {level: 9});
    status.innerText = "done.";
    status = log("Saving HTML file on hub");
    let targetFile = this._fileprefixInput.value + this.TARGETEXTENSION;
    status.innerText = "0%";
    success = await this.uploadWidthProgress(targetFile + ".gz", GZ_data, (curr, total) => {
      status.innerText = Math.round(100 * curr / total).toString() + "%";
    });
    if (success != YAPI_SUCCESS)
      throw "Upload failed (Error" + success.toString() + ")";
    status.innerText = "done.";
    status = log("Configuring hub");
    let url = this._currentHubLink_protocol + "://" + this._applicationURL;
    let network = await YNetwork.FindNetwork(await this._currentHub.get_serialNumber() + ".network");
    if (this._makeDefaultInput.checked) {
      await network.set_defaultPage(targetFile);
    } else {
      if (await network.get_defaultPage() == targetFile)
        await network.set_defaultPage("");
      url += "/" + targetFile;
    }
    let warning = "";
    if (readonly && configFile == null)
      warning = "However, since you chose to install the read-only version without any configuration file, your install is probably useless.";
    await YAPI.UnregisterHub(await this._currentHub.get_url());
    status.innerText = "done.";
    this._warning = warning;
    this._finalURL = url;
    setTimeout(() => {
      this.gotoPanel(this.DONEPANEL);
    }, 2e3);
  }
  removeAllChilds(element) {
    while (element.firstChild) {
      element.removeChild(element.firstChild);
    }
  }
  async showConfirmUninstallPanel(visible, goingback) {
    if (!visible) {
      if (this._confirmUninstallPanel != null)
        this._confirmUninstallPanel.style.display = "none";
      return;
    }
    if (this._confirmUninstallPanel == null) {
      this._confirmUninstallPanel = this.createNewContentDiv();
      this._container.appendChild(this._confirmUninstallPanel);
    }
    if (!goingback) {
      this.removeAllChilds(this._confirmUninstallPanel);
      let p = document.createElement("P");
      p.innerText = "You are about to remove all files related to Yocto-Visualization (for web)  from hub " + this._currentHub_Addr + ", including instances that probably took you quite some time to configure. Are you sure you want to click on Next and start uninstallation? You will not be able to revert this operation.\n\n";
      this._confirmUninstallPanel.appendChild(p);
      this._confirmUninstall = document.createElement("input");
      this._confirmUninstall.type = "checkbox";
      let bt = this._nextButton;
      this._confirmUninstall.addEventListener("change", function() {
        bt.enabled = this.checked;
      });
      this._confirmUninstallPanel.appendChild(this._confirmUninstall);
      let txt = document.createElement("span");
      txt.innerText = "Yes, I know what I am doing.";
      this._confirmUninstallPanel.appendChild(txt);
    }
    this._confirmUninstallPanel.style.display = "";
    this._nextButton.visible = true;
    this._nextButton.enabled = this._confirmUninstall.checked;
    this._prevButton.visible = true;
    this._cancelButton.visible = this.DEFAULTCANCELABLE;
    let tabIndex = 1;
    this._confirmUninstall.tabIndex = tabIndex++;
    this._prevButton.tabIndex = tabIndex++;
    this._nextButton.tabIndex = tabIndex++;
    this._confirmUninstall.focus();
  }
  async showDonePanel(visible, goingback) {
    if (!visible) {
      if (this._donePanel != null)
        this._donePanel.style.display = "none";
      return;
    }
    if (this._donePanel == null) {
      this._donePanel = this.createNewContentDiv();
      let Table = document.createElement("TABLE");
      let Row = document.createElement("TR");
      let TD1 = document.createElement("TD");
      TD1.style.whiteSpace = "normal";
      TD1.innerHTML = ressources.OkIcon("64", true, false, false, false, "youpi!");
      Row.appendChild(TD1);
      this._doneMsgContainer = document.createElement("TD");
      Row.appendChild(this._doneMsgContainer);
      Table.appendChild(Row);
      this._donePanel.appendChild(Table);
      this._container.appendChild(this._donePanel);
    }
    this.removeAllChilds(this._doneMsgContainer);
    let p = document.createElement("P");
    p.style.whiteSpace = "normal";
    switch (this._plannedaction) {
      case this.ACTIONADDINSTANCE:
      case this.ACTIONINSTALL:
        p.innerText = this._plannedaction == this.ACTIONINSTALL ? "Installation sucessfully completed. Application can be accessed through the following URL:" : "New instance sucessfully completed, it can be accessed through the following URL:";
        this._doneMsgContainer.appendChild(p);
        let url = document.createElement("A");
        url.innerText = this._finalURL;
        url.style.cursor = "pointer";
        url.style.color = "#0000EE";
        url.style.textDecoration = "underline";
        url.addEventListener("click", () => {
          if (top)
            top.location.assign(this._finalURL);
        });
        this._doneMsgContainer.appendChild(url);
        if (this._warning != "") {
          p = document.createElement("P");
          p.innerText = this._warning;
          this._doneMsgContainer.appendChild(p);
        }
        break;
      case this.ACTIONUNINSTALL:
        p.innerText = "Files sucessfully removed.";
        this._doneMsgContainer.appendChild(p);
        break;
      case this.ACTIONUPDATE:
        p.innerText = "JS Files sucessfully updated.";
        this._doneMsgContainer.appendChild(p);
        break;
      case this.ACTIONMODINSTANCE:
        p.innerText = "Instances modifications done";
        this._doneMsgContainer.appendChild(p);
        break;
    }
    p = document.createElement("P");
    this._cancelButton.visible = this.DEFAULTCANCELABLE;
    p.innerText = this.DEFAULTCANCELABLE ? 'Click on the "Ok" button to close the wizard' : 'Click on the "Ok" button to restart the wizard';
    this._doneMsgContainer.appendChild(p);
    this.removeCurrentPanelFromHistory();
    this._nextButton.visible = false;
    this._prevButton.visible = false;
    this._cancelButton.visible = false;
    this._okButton.visible = true;
    this._donePanel.style.display = "";
    let tabIndex = 1;
    this._okButton.tabIndex = tabIndex++;
    this._okButton.focus();
  }
  showCurrentStep(back, msg) {
    this.showWelcomePanel(this._currentStep == this.WELCOMEPANEL, back);
    this.showEnterHubAddr(this._currentStep == this.ENTERHUBADDR, back);
    this.showConnectingPanel(this._currentStep == this.CONNECTINGPANEL, back);
    this.showConnectionError(this._currentStep == this.CONNECTIONERROR, back, msg);
    this.showPasswordPanel(this._currentStep == this.PASSWORDPANEL, back, msg);
    this.showHubDescription(this._currentStep == this.DESCRIPTIONPANEL, back);
    this.showCustomFilesPanel(this._currentStep == this.CUSTOMFILESPANEL, back);
    this.showOptionsPanel(this._currentStep == this.OPTIONSPANEL, back);
    this.showRunPanel(this._currentStep == this.RUNPANEL, back);
    this.showDonePanel(this._currentStep == this.DONEPANEL, back);
    this.showModifyInstallPanel(this._currentStep == this.MODIFYINSTALLPANEL, back);
    this.showConfirmUninstallPanel(this._currentStep == this.CONFIRMUNINSTALLPANEL, back);
    this.showModInstancesPanel(this._currentStep == this.MODINSTANCESPANEL, back);
  }
  gotoPrevious() {
    if (this._history.length > 1) {
      this._history.pop();
      this._currentStep = this._history[this._history.length - 1];
    }
    this.showCurrentStep(true);
  }
  gotoPanel(step, errmsg) {
    this._currentStep = step;
    this._prevButton.visible = step > 0;
    this._history.push(step);
    this.showCurrentStep(false, errmsg);
  }
  async resetAll() {
    this._currentStep = this.WELCOMEPANEL;
    this._history = [this.WELCOMEPANEL];
    this._alreadyInstalled = false;
    this._prevButton.visible = false;
    this._nextButton.visible = true;
    this._okButton.visible = false;
    this._cancelButton.visible = this.DEFAULTCANCELABLE;
    this._jsCodeinstances = [];
    this._webPageinstances = [];
    await YAPI.UnregisterHub(await this._currentHub.get_url());
    await YAPI.FreeAPI();
    this._currentHub = null;
    this.showCurrentStep(false);
  }
  gotoNext() {
    switch (this._currentStep) {
      case this.WELCOMEPANEL:
        this.gotoPanel(this.ENTERHUBADDR);
        break;
      case this.ENTERHUBADDR:
        this.gotoPanel(this.CONNECTINGPANEL);
        break;
      case this.PASSWORDPANEL:
        this.gotoPanel(this.CONNECTINGPANEL);
        break;
      case this.DESCRIPTIONPANEL:
        if (this._alreadyInstalled) {
          this.gotoPanel(this.MODIFYINSTALLPANEL);
        } else {
          this._plannedaction = this.ACTIONINSTALL;
          this.gotoPanel(this.CUSTOMFILESPANEL);
        }
        break;
      case this.CUSTOMFILESPANEL:
        this.gotoPanel(this.OPTIONSPANEL);
        break;
      case this.OPTIONSPANEL:
        this.gotoPanel(this.RUNPANEL);
        break;
      case this.MODIFYINSTALLPANEL:
        if (this._uninstallOpt.checked)
          this.gotoPanel(this.CONFIRMUNINSTALLPANEL);
        if (this._addInstanceOpt.checked) {
          this._plannedaction = this.ACTIONADDINSTANCE;
          this.gotoPanel(this.CUSTOMFILESPANEL);
        }
        if (this._updateOpt.checked) {
          this._plannedaction = this.ACTIONUPDATE;
          this.gotoPanel(this.RUNPANEL);
        }
        if (this._modInstanceOpt.checked) {
          this._plannedaction = this.ACTIONMODINSTANCE;
          this.gotoPanel(this.MODINSTANCESPANEL);
        }
        break;
      case this.MODINSTANCESPANEL:
        this.gotoPanel(this.RUNPANEL);
        break;
      case this.CONFIRMUNINSTALLPANEL:
        this._plannedaction = this.ACTIONUNINSTALL;
        this.gotoPanel(this.RUNPANEL);
        break;
    }
  }
};
YV4W_installer.HTTP = "http";
YV4W_installer.HTTPS = "https";
window.startYV4W_installer = (div, options) => {
  new YV4W_installer(div, options);
};
export {
  YV4W_installer
};
//# sourceMappingURL=yv4w-installer.js.map
