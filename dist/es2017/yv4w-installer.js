/* Yocto-Visualization-4web installer (version 1.11.10136) - www.yoctopuce.com */
// obj/full/Renderer/YDataRendererCommon.js
var Vector3 = class {
  constructor(a, b, c) {
    this.a = a;
    this.b = b;
    this.c = c;
  }
  static FromXYCoord(x, y) {
    return new Vector3(x, y, 1);
  }
  multiplyByM(m) {
    return new Vector3(m.a * this.a + m.b * this.b + m.c * this.c, m.d * this.a + m.e * this.b + m.f * this.c, m.g * this.a + m.h * this.b + m.i * this.c);
  }
  multiplyByN(n) {
    return new Vector3(this.a * n, this.b * n, this.c * n);
  }
  AddV(v) {
    return new Vector3(this.a + v.a, this.b + v.b, this.c + v.c);
  }
  SubstractV(v) {
    return new Vector3(this.a - v.a, this.b - v.b, this.c - v.c);
  }
  toPointF() {
    return new PointF(this.a, this.b);
  }
  toPoint() {
    return new Point(this.a, this.b);
  }
};
var Matrix3x3 = class {
  constructor(a, b, c, d, e, f, g, h, i, flags) {
    this.a = a;
    this.b = b;
    this.c = c;
    this.d = d;
    this.e = e;
    this.f = f;
    this.g = g;
    this.h = h;
    this.i = i;
    if (b == 0 && d == 0 && a == 1 && e == 1 && i == 1 && g == 0 && h == 0) {
      flags |= Matrix3x3.Flag_TRANSLATION;
      if (c == 0 && f == 0)
        flags |= Matrix3x3.Flag_IDENTITY;
    }
    this.isTranslation = (flags & Matrix3x3.Flag_TRANSLATION) != 0;
    this.isIdentity = (flags & Matrix3x3.Flag_IDENTITY) != 0;
  }
  clone() {
    let flag = 0;
    if (this.isTranslation)
      flag |= Matrix3x3.Flag_TRANSLATION;
    if (this.isIdentity)
      flag |= Matrix3x3.Flag_IDENTITY;
    return new Matrix3x3(this.a, this.b, this.c, this.d, this.e, this.f, this.g, this.h, this.i, flag);
  }
  get determinant() {
    let detA = this.e * this.i - this.h * this.f;
    let detB = this.d * this.i - this.g * this.f;
    let detC = this.d * this.h - this.g * this.e;
    return this.a * detA + -this.b * detB + this.c * detC;
  }
  get transpose() {
    if (this.isIdentity)
      return Matrix3x3.newIdentityMatrix();
    return new Matrix3x3(this.a, this.d, this.g, this.b, this.e, this.h, this.c, this.f, this.i, Matrix3x3.Flag_NONE);
  }
  multiplyByV(v) {
    if (this.isTranslation)
      return new Vector3(this.c + v.a, this.f + v.b, 1);
    return new Vector3(this.a * v.a + this.b * v.b + this.c * v.c, this.d * v.a + this.e * v.b + this.f * v.c, this.g * v.a + this.h * v.b + this.i * v.c);
  }
  static newMatrix(a, b, c, d, e, f, g, h, i) {
    return new Matrix3x3(a, b, c, d, e, f, g, h, i, Matrix3x3.Flag_NONE);
  }
  static newTranslateMatrix(offsetX, offsetY) {
    let flag = Matrix3x3.Flag_TRANSLATION;
    if (offsetX == 0 && offsetY == 0)
      flag |= Matrix3x3.Flag_IDENTITY;
    return new Matrix3x3(1, 0, offsetX, 0, 1, offsetY, 0, 0, 1, flag);
  }
  static newRotateMatrix(AngleDeg) {
    AngleDeg = Math.PI * AngleDeg / 180;
    return new Matrix3x3(Math.cos(AngleDeg), -Math.sin(AngleDeg), 0, Math.sin(AngleDeg), -Math.cos(AngleDeg), 0, 0, 0, 1, Matrix3x3.Flag_NONE);
  }
  static newScaleMatrix(Coef) {
    return new Matrix3x3(Coef, 0, 0, 0, Coef, 0, 0, 0, 1, Matrix3x3.Flag_NONE);
  }
  static newIdentityMatrix() {
    return new Matrix3x3(1, 0, 0, 0, 1, 0, 0, 0, 1, Matrix3x3.Flag_IDENTITY | Matrix3x3.Flag_TRANSLATION);
  }
  toCSS() {
    return "matrix(" + this.a.toString() + "," + this.d.toString() + "," + this.b.toString() + "," + this.e.toString() + "," + this.c.toString() + "," + this.f.toString() + ")";
  }
  toString() {
    return "| " + this.a.toFixed(2) + " " + this.b.toFixed(2) + " " + this.c.toFixed(2) + " |" + (this.isIdentity ? " I" : "") + "\n| " + this.d.toFixed(2) + " " + this.e.toFixed(2) + " " + this.f.toFixed(2) + " |" + (this.isTranslation ? " T" : "") + "\n| " + this.g.toFixed(2) + " " + this.g.toFixed(2) + " " + this.i.toFixed(2) + " |\n";
  }
  multiplyByM(m) {
    if (this.isIdentity)
      return m.clone();
    if (m.isIdentity)
      return this.clone();
    if (this.isTranslation && m.isTranslation)
      return Matrix3x3.newTranslateMatrix(this.c + m.c, this.f + m.f);
    return new Matrix3x3(this.a * m.a + this.b * m.d + this.c * m.g, this.a * m.b + this.b * m.e + this.c * m.h, this.a * m.c + this.b * m.f + this.c * m.i, this.d * m.a + this.e * m.d + this.f * m.g, this.d * m.b + this.e * m.e + this.f * m.h, this.d * m.c + this.e * m.f + this.f * m.i, this.g * m.a + this.h * m.d + this.i * m.g, this.g * m.b + this.h * m.e + this.i * m.h, this.g * m.c + this.h * m.f + this.i * m.i, Matrix3x3.Flag_NONE);
  }
  get inverse() {
    if (this.isIdentity)
      return Matrix3x3.newIdentityMatrix();
    if (this.isTranslation)
      return Matrix3x3.newTranslateMatrix(-this.c, -this.f);
    let det = this.determinant;
    if (det == 0)
      throw "matrix cannot be inverted";
    let detA = this.e * this.i - this.f * this.h;
    let detB = this.b * this.i - this.c * this.h;
    let detC = this.b * this.f - this.c * this.e;
    let detD = this.d * this.i - this.f * this.g;
    let detE = this.a * this.i - this.c * this.g;
    let detF = this.a * this.f - this.c * this.d;
    let detG = this.d * this.h - this.e * this.g;
    let detH = this.a * this.h - this.b * this.g;
    let detI = this.a * this.e - this.b * this.d;
    return new Matrix3x3(detA / det, -detB / det, detC / det, -detD / det, detE / det, -detF / det, detG / det, -detH / det, detI / det, Matrix3x3.Flag_NONE);
  }
  log() {
    console.log(this.toString());
  }
};
Matrix3x3.Flag_NONE = 0;
Matrix3x3.Flag_IDENTITY = 1;
Matrix3x3.Flag_TRANSLATION = 2;
var YEnum = class {
  static fromString(container, value) {
    let p = Object.getOwnPropertyNames(container);
    for (let i = 0; i < p.length; i++) {
      if (p[i] == value)
        return container[value];
    }
    throw "YEnum" + value + " is not a " + container + " value";
  }
  static siblings(container) {
    let res = [];
    let p = Object.getOwnPropertyNames(container);
    for (let i = 0; i < p.length; i++) {
      if (container[p[i]] instanceof YEnumItem) {
        res.push(container[p[i]]);
      }
    }
    return res;
  }
};
var YEnumItem = class {
  constructor(value, humanreadable, container) {
    this._value = value;
    this._container = container;
    this._humanreadable = humanreadable;
  }
  fromString(value) {
    return YEnum.fromString(this._container, value);
  }
  get toString() {
    return this._value.toString();
  }
  get description() {
    return this._humanreadable;
  }
  get sibblings() {
    return YEnum.siblings(this._container);
  }
};
var ViewPortSettings = class {
  constructor() {
    this.IRLx = 0;
    this.IRLy = 0;
    this.zoomx = 0;
    this.zoomy = 0;
    this.Lmargin = 0;
    this.Rmargin = 0;
    this.Tmargin = 0;
    this.Bmargin = 0;
    this.Width = 0;
    this.Height = 0;
    this.Capture = false;
    this.IRLCaptureStartX = 0;
    this.CaptureStartY = 0;
    this.OriginalXAxisMin = 0;
    this.OriginalXAxisMax = 0;
    this.OriginalIRLx = 0;
    this.OriginalLmargin = 0;
    this.OriginalZoomx = 0;
  }
};
var YFont = class {
  get userData() {
    return this._userData;
  }
  set userData(value) {
    this._userData = value;
  }
  get directParent() {
    return this._directParent;
  }
  constructor(parentRenderer, directParent, size, fontChangeCallback) {
    this._userData = null;
    this._fontChangeCallback = null;
    this._name = "Arial";
    this._italic = false;
    this._bold = false;
    this._color = YColor.Black;
    this._alternateColor = null;
    this._font = null;
    this._brush = new YSolidBrush(YColor.Black);
    this._parentRenderer = parentRenderer;
    this._directParent = directParent;
    this._fontChangeCallback = fontChangeCallback ? fontChangeCallback : null;
    this._size = new Proportional(size ? size : 10, Proportional.ResizeRule.FIXED, parentRenderer, this, this.ResetFont);
  }
  ResetFont(source) {
    this._font = null;
    if (source != null)
      this._parentRenderer.ProportionnalValueChanged(source);
  }
  get name() {
    return this._name;
  }
  set name(value) {
    this._name = value;
    this.ResetFont(null);
    this._parentRenderer.redraw();
  }
  get hasChanged() {
    return this._font == null;
  }
  get size() {
    return this._size.value;
  }
  set size(value) {
    if (value <= 0)
      throw new RangeError("Size must be a positive value");
    value = Math.round(100 * value) / 100;
    this._size.value = value;
    this.ResetFont(null);
    if (this._fontChangeCallback != null)
      this._fontChangeCallback(this);
    this._parentRenderer.redraw();
  }
  get italic() {
    return this._italic;
  }
  set italic(value) {
    if (this._italic != value) {
      this._italic = value;
      this.ResetFont(null);
      this._parentRenderer.redraw();
    }
  }
  get bold() {
    return this._bold;
  }
  set bold(value) {
    if (this._bold != value) {
      this._bold = value;
      this.ResetFont(null);
      this._parentRenderer.redraw();
    }
  }
  get color() {
    return this._color;
  }
  set color(value) {
    if (this._color != value) {
      this._color = value;
      this._brush = null;
      this._parentRenderer.redraw();
    }
  }
  get alternateColor() {
    return this._alternateColor;
  }
  set alternateColor(value) {
    if (this._alternateColor != value) {
      this._alternateColor = value;
      this._brush = null;
      this._parentRenderer.redraw();
    }
  }
  get fontObject() {
    return this._name ? this._name : "Arial";
  }
  get brush() {
    if (this._brush == null)
      this._brush = new YSolidBrush(this._alternateColor != null ? this._alternateColor : this._color);
    return this._brush;
  }
  get sizeInPoints() {
    return this._size.value * 0.75;
  }
  get sizeForCanvas() {
    return this._size.value * 1.15;
  }
  get htmlCode() {
    return (this._italic ? "italic " : "") + (this._bold ? "bold " : "") + this.sizeForCanvas.toString() + "px " + this._name;
  }
};
var YSizeF = class {
  constructor(font, st) {
    this._w = 0;
    this._h = 0;
    this._lines = [];
    this._linesCount = 0;
    this._lineHeight = 0;
    this._firstlineHeight = 0;
    if (font != null) {
      this._lineHeight = font.size * 1.25;
      this._firstlineHeight = this._lineHeight * 0.75;
      if (st.indexOf("\n") < 0) {
        this._lines = [st];
        this._linesCount = 1;
      } else {
        this._lines = st.split("\n");
        this._linesCount = this._lines.length;
      }
    }
  }
  get lines() {
    return this._lines;
  }
  get linesCount() {
    return this._linesCount;
  }
  get firstLineHeight() {
    return this._firstlineHeight;
  }
  get lineHeight() {
    return this._lineHeight;
  }
  get height() {
    return this._h;
  }
  get width() {
    return this._w;
  }
  set width(value) {
    this._w = value;
  }
  set height(value) {
    this._h = value;
  }
};
var YTextRenderingHint = class {
  constructor(value) {
    this._value = 0;
    this._value = value;
  }
};
YTextRenderingHint.SystemDefault = new YTextRenderingHint(0);
YTextRenderingHint.SingleBitPerPixelGridFit = new YTextRenderingHint(1);
YTextRenderingHint.SingleBitPerPixel = new YTextRenderingHint(2);
YTextRenderingHint.AntiAliasGridFit = new YTextRenderingHint(3);
YTextRenderingHint.AntiAlias = new YTextRenderingHint(4);
YTextRenderingHint.ClearTypeGridFit = new YTextRenderingHint(5);
var YSmoothingMode = class {
  constructor(value) {
    this._value = 0;
    this._value = value;
  }
};
YSmoothingMode.Invalid = new YSmoothingMode(-1);
YSmoothingMode.Default = new YSmoothingMode(0);
YSmoothingMode.HighSpeed = new YSmoothingMode(1);
YSmoothingMode.HighQuality = new YSmoothingMode(2);
YSmoothingMode.None = new YSmoothingMode(3);
YSmoothingMode.AntiAlias = new YSmoothingMode(4);
var YStringBuilder = class {
  constructor() {
    this._str = "";
  }
  AppendLine(s) {
    this._str += s + "\n";
  }
  Append(s) {
    this._str += s;
  }
  get contents() {
    return this._str;
  }
};
var YStringFormat = class {
  get Alignment() {
    return this._Alignment;
  }
  set Alignment(value) {
    this._Alignment = value;
  }
  get LineAlignment() {
    return this._LineAlignment;
  }
  set LineAlignment(value) {
    this._LineAlignment = value;
  }
  get FormatFlags() {
    return this._formatFlags;
  }
  set FormatFlags(value) {
    this._formatFlags = value;
  }
  get Trimming() {
    return this._Trimming;
  }
  set Trimming(value) {
    this._Trimming = value;
  }
  constructor(clip) {
    this._Alignment = 0;
    this._LineAlignment = 0;
    this._formatFlags = 0;
    this._Trimming = 0;
    this._clip = 16384;
    this._clip = clip;
  }
};
var YColor = class {
  get name() {
    return this._name;
  }
  set predefname(value) {
    this._name = value;
  }
  static get predefinedColors() {
    if (YColor._predefinedColors == null) {
      YColor._predefinedColors = {};
      let names = Object.getOwnPropertyNames(YColor);
      for (let i = 0; i < names.length; i++) {
        if (YColor[names[i]] instanceof YColor) {
          YColor._predefinedColors[names[i]] = YColor[names[i]];
          YColor._predefinedColors[names[i]].predefname = names[i];
        }
      }
    }
    return YColor._predefinedColors;
  }
  static FromString(value) {
    let valueUpper = value.toUpperCase();
    let propNames = Object.getOwnPropertyNames(YColor);
    for (let i = 0; i < propNames.length; i++) {
      if (propNames[i].toUpperCase() == valueUpper) {
        if (YColor[propNames[i]] instanceof YColor) {
          return YColor[propNames[i]];
        }
      }
    }
    if (value.length == 7 && value.substr(0, 1).toUpperCase() == "#") {
      let r = parseInt(value.substr(1, 2), 16);
      let g = parseInt(value.substr(3, 2), 16);
      let b = parseInt(value.substr(5, 2), 16);
      return new YColor(false, 255, r, g, b);
    }
    if (value.length == 12) {
      if (value.substr(0, 4).toUpperCase() == "RGB:") {
        let alpha = parseInt(value.substr(4, 2), 16);
        let r = parseInt(value.substr(6, 2), 16);
        let g = parseInt(value.substr(8, 2), 16);
        let b = parseInt(value.substr(10, 2), 16);
        return new YColor(false, alpha, r, g, b);
      } else if (value.substr(0, 4).toUpperCase() == "HSL:") {
        let alpha = parseInt(value.substr(4, 2), 16);
        let h = parseInt(value.substr(6, 2), 16);
        let s = parseInt(value.substr(8, 2), 16);
        let l = parseInt(value.substr(10, 2), 16);
        return new YColor(true, alpha, h, s, l);
      }
    }
    return null;
  }
  static hex(v) {
    let s = v.toString(16);
    if (s.length <= 1)
      return "0" + s;
    return s;
  }
  toString() {
    if (this.isHSLColor) {
      return "HSL:" + (YColor.hex(this.transparency) + YColor.hex(this.h) + YColor.hex(this.s) + YColor.hex(this.l)).toUpperCase();
    } else {
      let propNames = Object.getOwnPropertyNames(YColor);
      for (let i = 0; i < propNames.length; i++) {
        let o = Reflect.get(YColor, propNames[i]);
        let c = o;
        if (c.alpha == this.alpha && c.red == this.red && c.green == this.green && c.blue == this.blue)
          return propNames[i];
      }
    }
    return "RGB:" + (YColor.hex(this.transparency) + YColor.hex(this.r) + YColor.hex(this.g) + YColor.hex(this.b)).toUpperCase();
  }
  get svgCode() {
    return "rgb(" + this.r.toString() + ", " + this.g.toString() + ", " + this.b.toString() + ")";
  }
  get alphaCode() {
    return (this.transparency / 255).toFixed(3);
  }
  static hsl2rgbInt(temp1, temp2, temp3) {
    if (temp3 >= 170)
      return (temp1 + 127) / 255 >> 0;
    if (temp3 > 42) {
      if (temp3 <= 127)
        return (temp2 + 127) / 255 >> 0;
      temp3 = 170 - temp3;
    }
    return (temp1 * 255 + (temp2 - temp1) * (6 * temp3) + 32512) / 65025 >> 0;
  }
  hsl2rgb() {
    let temp1;
    let temp2;
    let temp3;
    this.rgbConvertionDone = true;
    if (this.s == 0) {
      this.r = this.l;
      this.g = this.l;
      this.b = this.l;
      return;
    }
    if (this.l <= 127) {
      temp2 = this.l * (255 + this.s);
    } else {
      temp2 = (this.l + this.s) * 255 - this.l * this.s;
    }
    temp1 = 510 * this.l - temp2;
    temp3 = this.h + 85;
    if (temp3 > 255)
      temp3 = temp3 - 255;
    this.r = YColor.hsl2rgbInt(temp1, temp2, temp3);
    temp3 = this.h;
    if (temp3 > 255)
      temp3 = temp3 - 255;
    this.g = YColor.hsl2rgbInt(temp1, temp2, temp3);
    if (this.h >= 85) {
      temp3 = this.h - 85;
    } else {
      temp3 = this.h + 170;
    }
    this.b = YColor.hsl2rgbInt(temp1, temp2, temp3);
    if (this.r > 255)
      this.r = 255;
    if (this.g > 255)
      this.g = 255;
    if (this.b > 255)
      this.b = 255;
  }
  computeHSL() {
    let R = this.r;
    let G = this.g;
    let B = this.b;
    let H;
    let S;
    let L;
    let max = R > G ? R : G;
    let min = R < G ? R : G;
    let correction = 0;
    let divisor = 0;
    this.hslConvertionDone = true;
    if (B > max)
      max = B;
    if (B < min)
      min = B;
    L = (max + min + 1) / 2 >> 0;
    if (max == min) {
      this.h = 0;
      this.s = 0;
      this.l = L;
      return;
    }
    correction = (max + min) / 2 >> 0;
    if (L <= 127) {
      S = (255 * (max - min) + correction) / (max + min) >> 0;
    } else {
      S = (255 * (max - min) + 255 - correction) / (510 - (max + min)) >> 0;
    }
    correction = 3 * (max - min);
    divisor = 2 * correction;
    if (R == max) {
      H = 0;
      R = G;
      G = B;
    } else if (G == max) {
      H = 85;
      G = R;
      R = B;
    } else {
      H = 170;
    }
    if (R >= G) {
      H += (255 * (R - G) + correction) / divisor >> 0;
    } else {
      H += 255 - (255 * (G - R) - correction) / divisor >> 0;
    }
    if (H > 255)
      H -= 255;
    if (S > 255)
      S = 255;
    if (L > 255)
      L = 255;
    this.h = H;
    this.s = S;
    this.l = L;
  }
  get hue() {
    if (!this.hslConvertionDone)
      this.computeHSL();
    return this.h;
  }
  get saturation() {
    if (!this.hslConvertionDone)
      this.computeHSL();
    return this.s;
  }
  get luminosity() {
    if (!this.hslConvertionDone)
      this.computeHSL();
    return this.l;
  }
  get red() {
    if (!this.rgbConvertionDone)
      this.hsl2rgb();
    return this.r;
  }
  get green() {
    if (!this.rgbConvertionDone)
      this.hsl2rgb();
    return this.g;
  }
  get blue() {
    if (!this.rgbConvertionDone)
      this.hsl2rgb();
    return this.b;
  }
  get alpha() {
    return this.transparency;
  }
  static FromArgb(a, r, g, b) {
    return new YColor(false, a, r, g, b);
  }
  static FromAhsl(a, h, s, l) {
    return new YColor(true, a, h, s, l);
  }
  get isHSL() {
    return this.isHSLColor;
  }
  get isRGB() {
    return !this.isHSLColor;
  }
  equal(c) {
    if (this.isHSLColor) {
      if (!c.isHSLColor)
        return false;
      if (c.hue != this.hue)
        return false;
      if (c.saturation != this.saturation)
        return false;
      if (c.luminosity != this.luminosity)
        return false;
      if (c.alpha != this.alpha)
        return false;
    } else {
      if (c.isHSLColor)
        return false;
      if (c.red != this.red)
        return false;
      if (c.green != this.green)
        return false;
      if (c.blue != this.blue)
        return false;
      if (c.alpha != this.alpha)
        return false;
    }
    return true;
  }
  clone() {
    if (this.isHSLColor)
      return new YColor(true, this.transparency, this.h, this.s, this.l, this.isPredefined);
    return new YColor(false, this.transparency, this.r, this.g, this.b, this.isPredefined);
  }
  get isPredefined() {
    return this._isPredefined;
  }
  constructor(isHsl, transparency, r_h, g_s, b_l, isPredefined) {
    this.hslConvertionDone = false;
    this.rgbConvertionDone = false;
    this.transparency = 0;
    this.r = 0;
    this.g = 0;
    this.b = 0;
    this.h = 0;
    this.s = 0;
    this.l = 0;
    this._name = "";
    this._htmlcode = this.computeHTMLCode();
    this.hslConvertionDone = isHsl;
    this.isHSLColor = isHsl;
    this.transparency = transparency;
    this._isPredefined = isPredefined === true;
    if (isHsl) {
      this.h = r_h;
      this.s = g_s;
      this.l = b_l;
      this.hsl2rgb();
    } else {
      this.r = r_h;
      this.g = g_s;
      this.b = b_l;
      this.rgbConvertionDone = true;
    }
    this._htmlcode = this.computeHTMLCode();
  }
  computeHTMLCode() {
    let a = this.transparency / 255;
    let r = this.r;
    let g = this.g;
    let b = this.b;
    return "rgba(" + r + "," + g + "," + b + "," + a.toFixed(3) + ")";
  }
  get htmlCode() {
    return this._htmlcode;
  }
};
YColor.AliceBlue = new YColor(false, 255, 240, 248, 255, true);
YColor.AntiqueWhite = new YColor(false, 255, 250, 235, 215, true);
YColor.Aqua = new YColor(false, 255, 0, 255, 255, true);
YColor.Aquamarine = new YColor(false, 255, 127, 255, 212, true);
YColor.Azure = new YColor(false, 255, 240, 255, 255, true);
YColor.Beige = new YColor(false, 255, 245, 245, 220, true);
YColor.Bisque = new YColor(false, 255, 255, 228, 196, true);
YColor.Black = new YColor(false, 255, 0, 0, 0, true);
YColor.BlanchedAlmond = new YColor(false, 255, 255, 235, 205, true);
YColor.Blue = new YColor(false, 255, 0, 0, 255, true);
YColor.BlueViolet = new YColor(false, 255, 138, 43, 226, true);
YColor.Brown = new YColor(false, 255, 165, 42, 42, true);
YColor.BurlyWood = new YColor(false, 255, 222, 184, 135, true);
YColor.CadetBlue = new YColor(false, 255, 95, 158, 160, true);
YColor.Chartreuse = new YColor(false, 255, 127, 255, 0, true);
YColor.Chocolate = new YColor(false, 255, 210, 105, 30, true);
YColor.Coral = new YColor(false, 255, 255, 127, 80, true);
YColor.CornflowerBlue = new YColor(false, 255, 100, 149, 237, true);
YColor.Cornsilk = new YColor(false, 255, 255, 248, 220, true);
YColor.Crimson = new YColor(false, 255, 220, 20, 60, true);
YColor.Cyan = new YColor(false, 255, 0, 255, 255, true);
YColor.DarkBlue = new YColor(false, 255, 0, 0, 139, true);
YColor.DarkCyan = new YColor(false, 255, 0, 139, 139, true);
YColor.DarkGoldenrod = new YColor(false, 255, 184, 134, 11, true);
YColor.DarkGray = new YColor(false, 255, 169, 169, 169, true);
YColor.DarkGreen = new YColor(false, 255, 0, 100, 0, true);
YColor.DarkKhaki = new YColor(false, 255, 189, 183, 107, true);
YColor.DarkMagenta = new YColor(false, 255, 139, 0, 139, true);
YColor.DarkOliveGreen = new YColor(false, 255, 85, 107, 47, true);
YColor.DarkOrange = new YColor(false, 255, 255, 140, 0, true);
YColor.DarkOrchid = new YColor(false, 255, 153, 50, 204, true);
YColor.DarkRed = new YColor(false, 255, 139, 0, 0, true);
YColor.DarkSalmon = new YColor(false, 255, 233, 150, 122, true);
YColor.DarkSeaGreen = new YColor(false, 255, 143, 188, 143, true);
YColor.DarkSlateBlue = new YColor(false, 255, 72, 61, 139, true);
YColor.DarkSlateGray = new YColor(false, 255, 47, 79, 79, true);
YColor.DarkTurquoise = new YColor(false, 255, 0, 206, 209, true);
YColor.DarkViolet = new YColor(false, 255, 148, 0, 211, true);
YColor.DeepPink = new YColor(false, 255, 255, 20, 147, true);
YColor.DeepSkyBlue = new YColor(false, 255, 0, 191, 255, true);
YColor.DimGray = new YColor(false, 255, 105, 105, 105, true);
YColor.DodgerBlue = new YColor(false, 255, 30, 144, 255, true);
YColor.Firebrick = new YColor(false, 255, 178, 34, 34, true);
YColor.FloralWhite = new YColor(false, 255, 255, 250, 240, true);
YColor.ForestGreen = new YColor(false, 255, 34, 139, 34, true);
YColor.Fuchsia = new YColor(false, 255, 255, 0, 255, true);
YColor.Gainsboro = new YColor(false, 255, 220, 220, 220, true);
YColor.GhostWhite = new YColor(false, 255, 248, 248, 255, true);
YColor.Gold = new YColor(false, 255, 255, 215, 0, true);
YColor.Goldenrod = new YColor(false, 255, 218, 165, 32, true);
YColor.Gray = new YColor(false, 255, 128, 128, 128, true);
YColor.Green = new YColor(false, 255, 0, 128, 0, true);
YColor.GreenYellow = new YColor(false, 255, 173, 255, 47, true);
YColor.Honeydew = new YColor(false, 255, 240, 255, 240, true);
YColor.HotPink = new YColor(false, 255, 255, 105, 180, true);
YColor.IndianRed = new YColor(false, 255, 205, 92, 92, true);
YColor.Indigo = new YColor(false, 255, 75, 0, 130, true);
YColor.Ivory = new YColor(false, 255, 255, 255, 240, true);
YColor.Khaki = new YColor(false, 255, 240, 230, 140, true);
YColor.Lavender = new YColor(false, 255, 230, 230, 250, true);
YColor.LavenderBlush = new YColor(false, 255, 255, 240, 245, true);
YColor.LawnGreen = new YColor(false, 255, 124, 252, 0, true);
YColor.LemonChiffon = new YColor(false, 255, 255, 250, 205, true);
YColor.LightBlue = new YColor(false, 255, 173, 216, 230, true);
YColor.LightCoral = new YColor(false, 255, 240, 128, 128, true);
YColor.LightCyan = new YColor(false, 255, 224, 255, 255, true);
YColor.LightGoldenrodYellow = new YColor(false, 255, 250, 250, 210, true);
YColor.LightGray = new YColor(false, 255, 211, 211, 211, true);
YColor.LightGreen = new YColor(false, 255, 144, 238, 144, true);
YColor.LightPink = new YColor(false, 255, 255, 182, 193, true);
YColor.LightSalmon = new YColor(false, 255, 255, 160, 122, true);
YColor.LightSeaGreen = new YColor(false, 255, 32, 178, 170, true);
YColor.LightSkyBlue = new YColor(false, 255, 135, 206, 250, true);
YColor.LightSlateGray = new YColor(false, 255, 119, 136, 153, true);
YColor.LightSteelBlue = new YColor(false, 255, 176, 196, 222, true);
YColor.LightYellow = new YColor(false, 255, 255, 255, 224, true);
YColor.Lime = new YColor(false, 255, 0, 255, 0, true);
YColor.LimeGreen = new YColor(false, 255, 50, 205, 50, true);
YColor.Linen = new YColor(false, 255, 250, 240, 230, true);
YColor.Magenta = new YColor(false, 255, 255, 0, 255, true);
YColor.Maroon = new YColor(false, 255, 128, 0, 0, true);
YColor.MediumAquamarine = new YColor(false, 255, 102, 205, 170, true);
YColor.MediumBlue = new YColor(false, 255, 0, 0, 205, true);
YColor.MediumOrchid = new YColor(false, 255, 186, 85, 211, true);
YColor.MediumPurple = new YColor(false, 255, 147, 112, 219, true);
YColor.MediumSeaGreen = new YColor(false, 255, 60, 179, 113, true);
YColor.MediumSlateBlue = new YColor(false, 255, 123, 104, 238, true);
YColor.MediumSpringGreen = new YColor(false, 255, 0, 250, 154, true);
YColor.MediumTurquoise = new YColor(false, 255, 72, 209, 204, true);
YColor.MediumVioletRed = new YColor(false, 255, 199, 21, 133, true);
YColor.MidnightBlue = new YColor(false, 255, 25, 25, 112, true);
YColor.MintCream = new YColor(false, 255, 245, 255, 250, true);
YColor.MistyRose = new YColor(false, 255, 255, 228, 225, true);
YColor.Moccasin = new YColor(false, 255, 255, 228, 181, true);
YColor.NavajoWhite = new YColor(false, 255, 255, 222, 173, true);
YColor.Navy = new YColor(false, 255, 0, 0, 128, true);
YColor.OldLace = new YColor(false, 255, 253, 245, 230, true);
YColor.Olive = new YColor(false, 255, 128, 128, 0, true);
YColor.OliveDrab = new YColor(false, 255, 107, 142, 35, true);
YColor.Orange = new YColor(false, 255, 255, 165, 0, true);
YColor.OrangeRed = new YColor(false, 255, 255, 69, 0, true);
YColor.Orchid = new YColor(false, 255, 218, 112, 214, true);
YColor.PaleGoldenrod = new YColor(false, 255, 238, 232, 170, true);
YColor.PaleGreen = new YColor(false, 255, 152, 251, 152, true);
YColor.PaleTurquoise = new YColor(false, 255, 175, 238, 238, true);
YColor.PaleVioletRed = new YColor(false, 255, 219, 112, 147, true);
YColor.PapayaWhip = new YColor(false, 255, 255, 239, 213, true);
YColor.PeachPuff = new YColor(false, 255, 255, 218, 185, true);
YColor.Peru = new YColor(false, 255, 205, 133, 63, true);
YColor.Pink = new YColor(false, 255, 255, 192, 203, true);
YColor.Plum = new YColor(false, 255, 221, 160, 221, true);
YColor.PowderBlue = new YColor(false, 255, 176, 224, 230, true);
YColor.Purple = new YColor(false, 255, 128, 0, 128, true);
YColor.Red = new YColor(false, 255, 255, 0, 0, true);
YColor.RosyBrown = new YColor(false, 255, 188, 143, 143, true);
YColor.RoyalBlue = new YColor(false, 255, 65, 105, 225, true);
YColor.SaddleBrown = new YColor(false, 255, 139, 69, 19, true);
YColor.Salmon = new YColor(false, 255, 250, 128, 114, true);
YColor.SandyBrown = new YColor(false, 255, 244, 164, 96, true);
YColor.SeaGreen = new YColor(false, 255, 46, 139, 87, true);
YColor.SeaShell = new YColor(false, 255, 255, 245, 238, true);
YColor.Sienna = new YColor(false, 255, 160, 82, 45, true);
YColor.Silver = new YColor(false, 255, 192, 192, 192, true);
YColor.SkyBlue = new YColor(false, 255, 135, 206, 235, true);
YColor.SlateBlue = new YColor(false, 255, 106, 90, 205, true);
YColor.SlateGray = new YColor(false, 255, 112, 128, 144, true);
YColor.Snow = new YColor(false, 255, 255, 250, 250, true);
YColor.SpringGreen = new YColor(false, 255, 0, 255, 127, true);
YColor.SteelBlue = new YColor(false, 255, 70, 130, 180, true);
YColor.Tan = new YColor(false, 255, 210, 180, 140, true);
YColor.Teal = new YColor(false, 255, 0, 128, 128, true);
YColor.Thistle = new YColor(false, 255, 216, 191, 216, true);
YColor.Tomato = new YColor(false, 255, 255, 99, 71, true);
YColor.Transparent = new YColor(false, 0, 255, 255, 255, true);
YColor.Turquoise = new YColor(false, 255, 64, 224, 208, true);
YColor.Violet = new YColor(false, 255, 238, 130, 238, true);
YColor.Wheat = new YColor(false, 255, 245, 222, 179, true);
YColor.White = new YColor(false, 255, 255, 255, 255, true);
YColor.WhiteSmoke = new YColor(false, 255, 245, 245, 245, true);
YColor.Yellow = new YColor(false, 255, 255, 255, 0, true);
YColor.YellowGreen = new YColor(false, 255, 154, 205, 50, true);
YColor._predefinedColors = null;
var YBrush = class {
  constructor(c, disableAntialias) {
    this._noAntiAlias = false;
    this._color = c;
    if (typeof disableAntialias != "undefined") {
      this._noAntiAlias = disableAntialias;
    }
  }
  get noAntiAlias() {
    return this._noAntiAlias;
  }
  get color() {
    return this._color;
  }
};
var YSolidBrush = class extends YBrush {
};
var YLinearGradientBrush = class extends YBrush {
  constructor(c1, c2) {
    super(c1);
    this._color1 = c1;
    this._color2 = c2;
  }
  get color1() {
    return this._color1;
  }
  get color2() {
    return this._color2;
  }
};
var YPen = class {
  constructor(color, thickness, disableAntialias) {
    this._thickness = 1;
    this._color = YColor.Black;
    this._noAntiAlias = false;
    this._startCap = 1;
    this._endCap = 1;
    this._linejoin = YPen.LineJoin.Miter;
    this._thickness = thickness;
    this._color = thickness > 0 ? color : YColor.Transparent;
    if (typeof disableAntialias != "undefined") {
      this._noAntiAlias = disableAntialias;
    }
  }
  get noAntiAlias() {
    return this._noAntiAlias;
  }
  get lineWidth() {
    return this._thickness;
  }
  get strokeStyle() {
    return this._color.htmlCode;
  }
  get color() {
    return this._color;
  }
  set startCap(value) {
    this._startCap = value;
  }
  set endCap(value) {
    this._endCap = value;
  }
  set linejoin(value) {
    this._linejoin = value;
  }
};
(function(YPen2) {
  let LineJoin;
  (function(LineJoin2) {
    LineJoin2[LineJoin2["Miter"] = 0] = "Miter";
    LineJoin2[LineJoin2["Bevel"] = 1] = "Bevel";
    LineJoin2[LineJoin2["Round"] = 2] = "Round";
    LineJoin2[LineJoin2["MiterClipped"] = 3] = "MiterClipped";
  })(LineJoin = YPen2.LineJoin || (YPen2.LineJoin = {}));
})(YPen || (YPen = {}));
var YRectangle = class {
  constructor(x, y, w, h) {
    this.x = x;
    this.y = y;
    this.w = w;
    this.h = h;
  }
};
var Point = class {
  constructor(valueX, valueY) {
    this.X = valueX >> 0;
    this.Y = valueY >> 0;
  }
};
var minMaxPoint = class {
  constructor(valueX1, valueYMIN, valueX2, valueYMAX) {
    this.X1 = valueX1 >> 0;
    this.YMIN = valueYMIN >> 0;
    this.X2 = valueX2 >> 0;
    this.YMAX = valueYMAX >> 0;
  }
};
var PointF = class {
  constructor(valueX, valueY) {
    this.X = valueX;
    this.Y = valueY;
  }
};
var GenericPanel = class {
  get userData() {
    return this._userData;
  }
  set userData(value) {
    this._userData = value;
  }
  get directParent() {
    return this._directParent;
  }
  constructor(parent, directParent) {
    this._userData = null;
    this._enabled = false;
    this._panelTextAlign = GenericPanel.TextAlign.LEFT;
    this._text = "";
    this._bgColor = new YColor(false, 255, 255, 255, 192);
    this._borderColor = YColor.Black;
    this._borderthickness = 1;
    this._padding = 10;
    this._verticalMargin = 10;
    this._horizontalMargin = 10;
    this._bgBrush = null;
    this._pen = null;
    this._font = null;
    this._directParent = directParent;
    this._parentRenderer = parent;
    this._font = new YFont(parent, this, 8, null);
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    if (this._enabled != value) {
      this._enabled = value;
      this._parentRenderer.clearCachedObjects();
      this._parentRenderer.redraw();
    }
  }
  get panelTextAlign() {
    return this._panelTextAlign;
  }
  set panelTextAlign(value) {
    this._panelTextAlign = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get text() {
    return this._text;
  }
  set text(value) {
    this._text = value;
    this._parentRenderer.clearCachedObjects();
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get bgColor() {
    return this._bgColor;
  }
  set bgColor(value) {
    this._bgColor = value;
    this._bgBrush = null;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get borderColor() {
    return this._borderColor;
  }
  set borderColor(value) {
    this._borderColor = value;
    this._pen = null;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get borderthickness() {
    return this._borderthickness;
  }
  set borderthickness(value) {
    if (value < 0)
      throw "Border thickness must be a positive value";
    this._borderthickness = value;
    this._parentRenderer.clearCachedObjects();
    this._pen = null;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get padding() {
    return this._padding;
  }
  set padding(value) {
    if (value < 0)
      throw new RangeError("Padding must be a positive value");
    this._padding = value;
    this._parentRenderer.clearCachedObjects();
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get verticalMargin() {
    return this._verticalMargin;
  }
  set verticalMargin(value) {
    this._verticalMargin = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get horizontalMargin() {
    return this._horizontalMargin;
  }
  set horizontalMargin(value) {
    this._horizontalMargin = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get bgBrush() {
    if (this._bgBrush == null)
      this._bgBrush = new YSolidBrush(this._bgColor);
    return this._bgBrush;
  }
  get pen() {
    if (this._pen == null) {
      this._pen = new YPen(this._borderColor, this._borderthickness, true);
    }
    return this._pen;
  }
  get font() {
    return this._font;
  }
};
(function(GenericPanel2) {
  class HorizontalAlignPosEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, HorizontalAlignPos);
    }
  }
  GenericPanel2.HorizontalAlignPosEnumItem = HorizontalAlignPosEnumItem;
  class HorizontalAlignPos extends YEnum {
  }
  HorizontalAlignPos.LEFT = new HorizontalAlignPosEnumItem("LEFT", "Left");
  HorizontalAlignPos.CENTER = new HorizontalAlignPosEnumItem("CENTER", "Center");
  HorizontalAlignPos.RIGHT = new HorizontalAlignPosEnumItem("RIGHT", "Right");
  GenericPanel2.HorizontalAlignPos = HorizontalAlignPos;
  class VerticalAlignPosEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, VerticalAlignPos);
    }
  }
  GenericPanel2.VerticalAlignPosEnumItem = VerticalAlignPosEnumItem;
  class VerticalAlignPos extends YEnum {
  }
  VerticalAlignPos.TOP = new VerticalAlignPosEnumItem("TOP", "Top");
  VerticalAlignPos.CENTER = new VerticalAlignPosEnumItem("CENTER", "Center");
  VerticalAlignPos.BOTTOM = new VerticalAlignPosEnumItem("BOTTOM", "Bottom");
  GenericPanel2.VerticalAlignPos = VerticalAlignPos;
  class TextAlignEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, TextAlign);
    }
  }
  GenericPanel2.TextAlignEnumItem = TextAlignEnumItem;
  class TextAlign extends YEnum {
  }
  TextAlign.LEFT = new TextAlignEnumItem("LEFT", "Left");
  TextAlign.CENTER = new TextAlignEnumItem("CENTER", "Center");
  TextAlign.RIGHT = new TextAlignEnumItem("RIGHT", "Right");
  GenericPanel2.TextAlign = TextAlign;
})(GenericPanel || (GenericPanel = {}));
var MessagePanel = class extends GenericPanel {
  constructor(parent, directParent) {
    super(parent, directParent);
    this._panelHrzAlign = GenericPanel.HorizontalAlignPos.CENTER;
    this._panelVrtAlign = GenericPanel.VerticalAlignPos.CENTER;
  }
  get panelHrzAlign() {
    return this._panelHrzAlign;
  }
  set panelHrzAlign(value) {
    this._panelHrzAlign = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get panelVrtAlign() {
    return this._panelVrtAlign;
  }
  set panelVrtAlign(value) {
    this._panelVrtAlign = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
};
var AnnotationPanel = class extends GenericPanel {
  constructor(parent, directParent) {
    super(parent, directParent);
    this._overlap = false;
    this._positionOffsetX = 50;
    this._positionOffsetY = 50;
    this._panelHrzAlign = GenericPanel.HorizontalAlignPos.CENTER;
    this._panelVrtAlign = GenericPanel.VerticalAlignPos.TOP;
  }
  get overlap() {
    return this._overlap;
  }
  set overlap(value) {
    if (!value && this._panelHrzAlign == GenericPanel.HorizontalAlignPos.CENTER && this._panelVrtAlign == GenericPanel.VerticalAlignPos.CENTER) {
      this._panelVrtAlign = GenericPanel.VerticalAlignPos.TOP;
    }
    this._overlap = value;
    this._parentRenderer.clearCachedObjects();
    this._parentRenderer.redraw();
  }
  get positionOffsetX() {
    return this._positionOffsetX;
  }
  set positionOffsetX(value) {
    this._positionOffsetX = value;
    this._parentRenderer.clearCachedObjects();
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get positionOffsetY() {
    return this._positionOffsetY;
  }
  set positionOffsetY(value) {
    this._positionOffsetY = value;
    this._parentRenderer.clearCachedObjects();
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get panelHrzAlign() {
    return this._panelHrzAlign;
  }
  set panelHrzAlign(value) {
    if (!this._overlap && value == GenericPanel.HorizontalAlignPos.CENTER && this._panelVrtAlign == GenericPanel.VerticalAlignPos.CENTER) {
      this._panelVrtAlign = GenericPanel.VerticalAlignPos.TOP;
    }
    this._panelHrzAlign = value;
    this._parentRenderer.clearCachedObjects();
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get panelVrtAlign() {
    return this._panelVrtAlign;
  }
  set panelVrtAlign(value) {
    if (!this._overlap && value == GenericPanel.VerticalAlignPos.CENTER && this._panelHrzAlign == GenericPanel.HorizontalAlignPos.CENTER) {
      this._panelHrzAlign = GenericPanel.HorizontalAlignPos.RIGHT;
    }
    this._panelVrtAlign = value;
    this._parentRenderer.clearCachedObjects();
    if (this._enabled)
      this._parentRenderer.redraw();
  }
};
var Zone = class {
  get directParent() {
    return this._directParent;
  }
  get userData() {
    return this._userData;
  }
  set userData(value) {
    this._userData = value;
  }
  resetCache() {
  }
  constructor(parentRenderer, directParent) {
    this._userData = null;
    this._zoneBrush = null;
    this._color = YColor.Red;
    this._visible = false;
    this._min = 0;
    this._max = 100;
    this._directParent = directParent;
    this._parentRenderer = parentRenderer;
  }
  get zoneBrush() {
    if (this._zoneBrush == null)
      this._zoneBrush = new YSolidBrush(this._color);
    return this._zoneBrush;
  }
  get color() {
    return this._color;
  }
  set color(value) {
    this._color = value;
    this._zoneBrush = null;
    if (this.visible)
      this._parentRenderer.redraw();
  }
  get visible() {
    return this._visible;
  }
  set visible(value) {
    this._visible = value;
    this._parentRenderer.redraw();
  }
  set_minMax(min, max) {
    if (min > max)
      throw new RangeError("Min cannot be greater than max ");
    this._min = min;
    this._max = max;
    this.resetCache();
    if (this.visible)
      this._parentRenderer.redraw();
  }
  get min() {
    return this._min;
  }
  set min(value) {
    if (value >= this._max && !YDataRenderer.minMaxCheckDisabled) {
      throw new RangeError("Min cannot be greater than max (" + this._max.toString() + ")");
    }
    this._min = value;
    this.resetCache();
    if (this.visible)
      this._parentRenderer.redraw();
  }
  get max() {
    return this._max;
  }
  set max(value) {
    if (value <= this._min && !YDataRenderer.minMaxCheckDisabled) {
      throw new RangeError("Max cannot be greater than min (" + this._min.toString() + ")");
    }
    this._max = value;
    this.resetCache();
    if (this.visible)
      this._parentRenderer.redraw();
  }
};
var Proportional = class {
  get userData() {
    return this._userData;
  }
  set userData(value) {
    this._userData = value;
  }
  get directParent() {
    return this._directParent;
  }
  get value() {
    return this._value;
  }
  set value(v) {
    this._value = v;
    this.set_refPoint();
    if (this._reset != null)
      this._reset(this);
  }
  get resizeRule() {
    return this._resizeRule;
  }
  set resizeRule(value) {
    this.set_refPoint();
    this._resizeRule = value;
  }
  set_refPoint() {
    this._refWidth = Math.max(1, this._parentRenderer.usableUiWidth());
    this._refHeight = Math.max(1, this._parentRenderer.usableUiHeight());
    this._refValue = this._value;
  }
  constructor(value, resizeRule, parentRenderer, directParent, resetCallBack) {
    this._reset = null;
    this._refWidth = 1;
    this._refHeight = 1;
    this._refValue = 1;
    this.valueStack = [];
    this._resizeRule = Proportional.ResizeRule.FIXED;
    this._userData = null;
    this._reset = resetCallBack;
    this._parentRenderer = parentRenderer;
    this._value = value;
    this._resizeRule = resizeRule;
    this._directParent = directParent;
    this.set_refPoint();
    this._parentRenderer.AddNewProportionalToSizeValue(this);
  }
  containerResizedPushNewCoef(coef) {
    this.valueStack.push(this._value);
    this._value = Math.round(100 * this._refValue * coef) / 100;
    if (this._reset != null)
      this._reset(this);
  }
  containerResizedPop() {
    if (this.valueStack.length <= 0)
      throw new RangeError("Can't pop, empty stack.");
    this._value = this.valueStack.pop();
    if (this._reset != null)
      this._reset(this);
  }
  static resizeCoef(rule, refWidth, refHeight, newWidth, newHeight) {
    switch (rule) {
      case Proportional.ResizeRule.RELATIVETOWIDTH:
        return newWidth / refWidth;
      case Proportional.ResizeRule.RELATIVETOHEIGHT:
        return newHeight / refHeight;
      case Proportional.ResizeRule.RELATIVETOBOTH:
        return Math.min(newHeight / refHeight, newWidth / refWidth);
    }
    return 1;
  }
  containerResized(newWidth, newHeight) {
    this._value = Math.round(100 * this._refValue * Proportional.resizeCoef(this._resizeRule, this._refWidth, this._refHeight, newWidth, newHeight)) / 100;
    if (this._reset != null)
      this._reset(this);
  }
  forceChangeCallback() {
    if (this._reset != null)
      this._reset(this);
  }
};
(function(Proportional2) {
  class ResizeRuleEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, ResizeRule);
    }
  }
  Proportional2.ResizeRuleEnumItem = ResizeRuleEnumItem;
  class ResizeRule extends YEnum {
  }
  ResizeRule.FIXED = new ResizeRuleEnumItem("FIXED", "Fixed");
  ResizeRule.RELATIVETOWIDTH = new ResizeRuleEnumItem("RELATIVETOWIDTH", "Relative to Width");
  ResizeRule.RELATIVETOHEIGHT = new ResizeRuleEnumItem("RELATIVETOHEIGHT", "Relative to height");
  ResizeRule.RELATIVETOBOTH = new ResizeRuleEnumItem("RELATIVETOBOTH", "Relative to Width and Height");
  Proportional2.ResizeRule = ResizeRule;
})(Proportional || (Proportional = {}));
var YDataRenderer = class {
  get annotationPanels() {
    return this._annotationPanels;
  }
  get userData() {
    return this._userData;
  }
  static get minMaxCheckDisabled() {
    return YDataRenderer._disableMinMaxCheck;
  }
  static set minMaxCheckDisabled(value) {
    YDataRenderer._disableMinMaxCheck = value;
  }
  resetlegendPens() {
  }
  get getCaptureParameters() {
    return this._getCaptureParameters;
  }
  set getCaptureParameters(value) {
    this._getCaptureParameters = value;
  }
  get messagePanels() {
    return this._messagePanels;
  }
  static globalMouseMove(e) {
    YDataRenderer.globalMouseX = e.pageX;
    YDataRenderer.globalMouseY = e.pageY;
  }
  clearTransformationMatrix() {
    this._Scr2ElmMatrix = null;
    this._Elm2ScrMatrix = null;
  }
  findElementAbsolutePosition(el) {
    let staticFound = false;
    let relativeFound = false;
    let dx = 0;
    let dy = 0;
    while (el != null) {
      let style = window.getComputedStyle(el);
      if (!relativeFound && style.position == "static" && !staticFound) {
        dx = el.offsetLeft + parseFloat(style.borderLeftWidth);
        dy = el.offsetTop + parseFloat(style.borderTopWidth);
        staticFound = true;
      }
      if (style.position == "relative" || style.position == "absolute") {
        dx += el.offsetLeft + parseFloat(style.borderLeftWidth);
        dy += el.offsetTop + parseFloat(style.borderTopWidth);
        relativeFound = true;
      }
      el = el.parentElement;
    }
    return new PointF(dx, dy);
  }
  get Elm2ScrMatrix() {
    if (this._Elm2ScrMatrix == null) {
      let el = this.UIContainer;
      let AsolutePositionsStack = [];
      while (el != null) {
        AsolutePositionsStack.push(this.findElementAbsolutePosition(el));
        el = el.parentElement;
      }
      el = this.UIContainer;
      let MatrixStack = [];
      let staticFound = false;
      let relativeFound = false;
      let index = 0;
      while (el != null) {
        let parent = el.parentElement;
        let style = window.getComputedStyle(el);
        let dx = AsolutePositionsStack[index].X;
        let dy = AsolutePositionsStack[index].Y;
        if (index < AsolutePositionsStack.length - 1) {
          dx -= AsolutePositionsStack[index + 1].X;
          dy -= AsolutePositionsStack[index + 1].Y;
        }
        let matrix = style["transform"];
        if (matrix != "none") {
          let matrixStr = matrix.match(/matrix.*\((.+)\)/)[1].split(", ");
          let matrixValues = [];
          for (let i = 0; i < 6; i++) {
            matrixValues.push(parseFloat(matrixStr[i]));
          }
          let OriginMatrixMatrixBefore = null;
          let TransformMatrix = Matrix3x3.newMatrix(matrixValues[0], matrixValues[2], matrixValues[4], matrixValues[1], matrixValues[3], matrixValues[5], 0, 0, 1);
          let OriginMatrixMatrixAfter = null;
          if (style.transformOrigin) {
            let parts = style.transformOrigin.split(" ");
            let Ox = Number.parseFloat(parts[0]);
            let Oy = Number.parseFloat(parts[1]);
            OriginMatrixMatrixBefore = Matrix3x3.newTranslateMatrix(-Ox, -Oy);
            OriginMatrixMatrixAfter = Matrix3x3.newTranslateMatrix(Ox, Oy);
          }
          if (OriginMatrixMatrixBefore != null)
            MatrixStack.push(OriginMatrixMatrixBefore);
          if (TransformMatrix != null)
            MatrixStack.push(TransformMatrix);
          if (OriginMatrixMatrixAfter != null)
            MatrixStack.push(OriginMatrixMatrixAfter);
        }
        if (dx != 0 || dy != 0)
          MatrixStack.push(Matrix3x3.newTranslateMatrix(dx, dy));
        el = parent;
        index++;
      }
      this._Elm2ScrMatrix = Matrix3x3.newIdentityMatrix();
      for (let i = MatrixStack.length - 1; i >= 0; i--) {
        this._Elm2ScrMatrix = this._Elm2ScrMatrix.multiplyByM(MatrixStack[i]);
      }
    }
    return this._Elm2ScrMatrix;
  }
  get Scr2ElmMatrix() {
    if (this._Scr2ElmMatrix == null) {
      this._Scr2ElmMatrix = this.Elm2ScrMatrix.inverse;
    }
    return this._Scr2ElmMatrix;
  }
  addAnnotationPanel() {
    let p = new AnnotationPanel(this, this);
    this._annotationPanels.push(p);
    this.redraw();
    return p;
  }
  AllowRedraw() {
    this._redrawAllowed--;
    if (this._redrawAllowed < 0)
      throw new RangeError("Too many AllowRedraw calls");
    if (this._redrawAllowed == 0)
      this.redraw();
  }
  AllowRedrawNoRefresh() {
    this._redrawAllowed--;
    if (this._redrawAllowed < 0)
      throw new RangeError("Too many AllowRedraw calls");
  }
  DisableRedraw() {
    this._redrawAllowed++;
  }
  AddNewProportionalToSizeValue(v) {
    if (this.ProportionalToSizeValues.indexOf(v) < 0)
      this.ProportionalToSizeValues.push(v);
  }
  canRedraw() {
    return this._redrawAllowed == 0;
  }
  setPatchAnnotationCallback(callback) {
    this._PatchAnnotationCallback = callback;
  }
  patchAnnotation(text) {
    text = text.replace("\\n", "\n");
    if (text.indexOf("$") < 0)
      return text;
    let now = new Date();
    text = text.replace("$DAY$", now.getDay().toString());
    text = text.replace("$MONTH$", now.getMonth().toString());
    text = text.replace("$YEAR$", now.getFullYear().toString());
    text = text.replace("$HOUR$", now.getHours().toString());
    text = text.replace("$MINUTE$", now.getMinutes().toString());
    text = text.replace("$SECOND$", now.getSeconds().toString());
    if (this._PatchAnnotationCallback != null)
      text = this._PatchAnnotationCallback(text);
    return text;
  }
  mouseLocalPosition() {
    let v = Vector3.FromXYCoord(YDataRenderer.globalMouseX, YDataRenderer.globalMouseY);
    let m = this.Scr2ElmMatrix;
    let p = m.multiplyByV(v).toPoint();
    if (p.X < 0 || p.Y < 0 || p.X > this.UIContainer.offsetWidth || p.Y > this.UIContainer.offsetHeight)
      return null;
    return p;
  }
  set proportionnalValueChangeCallback(value) {
    this._proportionnalValueChangeCallback = value;
  }
  ProportionnalValueChanged(source) {
    if (this._proportionnalValueChangeCallback != null)
      this._proportionnalValueChangeCallback(source);
  }
  getContainerInnerWidth() {
    return this.UIContainer.offsetWidth;
  }
  getContainerInnerHeight() {
    return this.UIContainer.offsetHeight;
  }
  Draw(timestamp) {
    if (!this.canRedraw())
      return 0;
    let w = this.getContainerInnerWidth();
    let h = this.getContainerInnerHeight();
    if (w <= 5 || h <= 5)
      return 0;
    this.DisableRedraw();
    let offscreenCanvas = document.createElement("canvas");
    offscreenCanvas.width = w;
    offscreenCanvas.height = h;
    let g = new YGraphics(offscreenCanvas, w, h, 90);
    let start = performance.now();
    try {
      this.Render(g, w, h);
    } catch (e) {
      debugger;
      this.log("Rendering error: " + e.message);
    }
    let elapsed = performance.now() - start;
    let drawArea = this.UIContainer.getContext("2d");
    drawArea.clearRect(0, 0, w, h);
    drawArea.drawImage(offscreenCanvas, 0, 0);
    this.rendererTimingTotal += elapsed;
    this.rendererTimingCount++;
    let avg = this.rendererTimingTotal / this.rendererTimingCount;
    g.Dispose();
    this.AllowRedrawNoRefresh();
    this.renderingPostProcessing();
    return 0;
  }
  renderingPostProcessing() {
  }
  get resizeRule() {
    return this._resizeRule;
  }
  set resizeRule(value) {
    if (value != this._resizeRule) {
      this.DisableRedraw();
      this._resizeRule = value;
      for (let i = 0; i < this.ProportionalToSizeValues.length; i++) {
        this.ProportionalToSizeValues[i].resizeRule = this._resizeRule;
      }
      this.AllowRedraw();
      this.redraw();
    }
  }
  redraw() {
    if (!(document.visibilityState === "visible"))
      return;
    if (this._redrawAllowed > 0)
      return;
    if (this.getContainerInnerWidth() < 2)
      return;
    if (this.getContainerInnerHeight() < 2)
      return;
    if (this.requestAnimationFrameID != null) {
      window.cancelAnimationFrame(this.requestAnimationFrameID);
    }
    this.requestAnimationFrameID = window.requestAnimationFrame((timestamp) => {
      try {
        this.Draw(timestamp);
      } catch (e) {
        console.log("caught");
        this.requestAnimationFrameID = null;
        throw e;
      }
      this.requestAnimationFrameID = null;
    });
  }
  usableUiWidth() {
    return this.getContainerInnerWidth();
  }
  usableUiHeight() {
    return this.getContainerInnerHeight();
  }
  resetProportionalSizeObjectsCachePush(newcoef) {
    this.clearCachedObjects();
    if (this._resizeRule != Proportional.ResizeRule.FIXED) {
      for (let i = 0; i < this.ProportionalToSizeValues.length; i++) {
        this.ProportionalToSizeValues[i].containerResizedPushNewCoef(newcoef);
      }
    }
  }
  resetProportionalSizeObjectsCachePop() {
    this.clearCachedObjects();
    if (this._resizeRule != Proportional.ResizeRule.FIXED) {
      for (let i = 0; i < this.ProportionalToSizeValues.length; i++) {
        this.ProportionalToSizeValues[i].containerResizedPop();
      }
    }
  }
  resetProportionalSizeObjectsCache(w, h) {
    this.clearCachedObjects();
    if (this._resizeRule != Proportional.ResizeRule.FIXED) {
      for (let i = 0; i < this.ProportionalToSizeValues.length; i++) {
        this.ProportionalToSizeValues[i].containerResized(w, h);
      }
    }
  }
  containerResized() {
    this.containerResize(null, null);
  }
  containerResize(sender, e) {
    this.clearTransformationMatrix();
    this.DisableRedraw();
    this.UIContainer.width = this.UIContainer.offsetWidth;
    this.UIContainer.height = this.UIContainer.offsetHeight;
    this.resetProportionalSizeObjectsCache(this.usableUiWidth(), this.usableUiHeight());
    this.AllowRedraw();
    this.redraw();
  }
  proportionnalsizeReset() {
    this.resetProportionalSizeObjectsCache(this.usableUiWidth(), this.usableUiHeight());
  }
  captureAndDownloadImage(captureType, defaultFilename, captureWidth, captureHeight, captureDPI) {
    let error = "";
    let w;
    let h;
    let ratio = this.getContainerInnerWidth() / this.getContainerInnerHeight();
    if (captureDPI == null)
      captureDPI = 90;
    if (defaultFilename == null || typeof defaultFilename == "undefined") {
      defaultFilename = "capture.";
      if (captureType == YDataRenderer.CaptureType.PNG) {
        defaultFilename = defaultFilename + "png";
      }
      if (captureType == YDataRenderer.CaptureType.SVG) {
        defaultFilename = defaultFilename + "svg";
      }
    }
    if (captureWidth == null || typeof captureWidth == "undefined") {
      w = this.getContainerInnerWidth();
      if (captureHeight == null || typeof captureHeight == "undefined") {
        h = this.getContainerInnerHeight();
      } else {
        h = captureHeight >> 0;
        w = h * ratio >> 0;
      }
    } else {
      w = captureWidth >> 0;
      if (captureHeight == null || typeof captureHeight == "undefined") {
        h = w * ratio >> 0;
      } else {
        h = captureHeight >> 0;
      }
    }
    if (w <= 5 || h <= 5)
      return;
    this.DisableRedraw();
    if (captureType == YDataRenderer.CaptureType.SVG) {
      w = Math.round(w / 1.371);
      h = Math.round(h / 1.371);
    }
    let DrawArea = document.createElement("canvas");
    DrawArea.width = w;
    DrawArea.height = h;
    let g;
    switch (captureType) {
      case YDataRenderer.CaptureType.PNG:
        g = new YGraphics(DrawArea, w, h, captureDPI);
        break;
      case YDataRenderer.CaptureType.SVG:
        g = new YGraphicsSVG(DrawArea, w, h, captureDPI);
        break;
      default:
        throw new RangeError("capture :unknown type");
    }
    let newCoef = Proportional.resizeCoef(Proportional.ResizeRule.RELATIVETOBOTH, this.refWidth, this.refHeight, w, h);
    this.log("start capture");
    this.resetProportionalSizeObjectsCachePush(newCoef);
    let renderok = false;
    this._snapshotPanel.enabled = false;
    try {
      let t = this.Render(g, w, h);
      renderok = true;
    } catch (e) {
      error = e.message;
      this.log("Render error: " + error);
    }
    this.log("capture completed");
    this.resetProportionalSizeObjectsCachePop();
    if (renderok) {
      let element = document.createElement("a");
      let data = g.get_downloadableData();
      element.setAttribute("href", data);
      element.setAttribute("download", defaultFilename);
      element.style.display = "none";
      document.body.appendChild(element);
      element.click();
      document.body.removeChild(element);
    }
    g.Dispose();
    this.AllowRedraw();
  }
  getFocus(sender, e) {
    this.log("got focus");
  }
  gainFocus() {
  }
  lostFocus(sender, e) {
  }
  get AllowPrintScreenCapture() {
    return this._AllowPrintScreenCapture;
  }
  set AllowPrintScreenCapture(value) {
    this._AllowPrintScreenCapture = value;
  }
  constructor(UIContainer, logFunction) {
    this._redrawAllowed = 1;
    this._refWidth = 1;
    this._refHeight = 1;
    this.rendererTimingTotal = 0;
    this.rendererTimingCount = 0;
    this._PatchAnnotationCallback = null;
    this._logFunction = null;
    this._annotationPanels = [];
    this._userData = null;
    this.documentVisibiltyChangeFct = null;
    this.containerResizedFct = null;
    this._getCaptureParameters = null;
    this.OnDblClick = null;
    this.OnRightClick = null;
    this._messagePanels = [];
    this._Scr2ElmMatrix = null;
    this._Elm2ScrMatrix = null;
    this.ProportionalToSizeValues = [];
    this._proportionnalValueChangeCallback = null;
    this._resizeRule = Proportional.ResizeRule.FIXED;
    this.requestAnimationFrameID = null;
    this._snapshotPanel = null;
    this._snapshotTimer = null;
    this._AllowPrintScreenCapture = false;
    if (!YDataRenderer.globalMouseMoveSet) {
      document.addEventListener("mousemove", (e) => {
        YDataRenderer.globalMouseMove(e);
      });
      YDataRenderer.globalMouseMoveSet = true;
    }
    this.UIContainer = UIContainer;
    this.UIContainer.width = this.getContainerInnerWidth();
    this.UIContainer.height = this.getContainerInnerHeight();
    this._logFunction = logFunction;
    this.parentForm = UIContainer.ownerDocument;
    this._annotationPanels = [];
    this._messagePanels = [];
    this.DisableRedraw();
    this._snapshotPanel = this.addMessagePanel();
    this._snapshotPanel.panelTextAlign = MessagePanel.TextAlign.CENTER;
    this._snapshotPanel.text = "Captured to clipboard";
    this._snapshotPanel.panelHrzAlign = MessagePanel.HorizontalAlignPos.CENTER;
    this._snapshotPanel.panelVrtAlign = MessagePanel.VerticalAlignPos.CENTER;
    this._snapshotPanel.bgColor = new YColor(false, 200, 204, 247, 161);
    this._snapshotPanel.font.size = 16;
    this.AllowRedrawNoRefresh();
    this.containerResizedFct = () => {
      this.containerResize(null, null);
    };
    document.addEventListener("resize", this.containerResizedFct);
    this.resetRefrenceSize();
    this.documentVisibiltyChangeFct = () => {
      if (document.visibilityState === "visible") {
        this.redraw();
      }
    };
    document.addEventListener("visibilitychange", this.documentVisibiltyChangeFct);
  }
  destroy() {
    document.removeEventListener("visibilitychange", this.documentVisibiltyChangeFct);
    document.removeEventListener("resize", this.containerResized);
    this.UIContainer.parentNode.removeChild(this.UIContainer);
    this.UIContainer = null;
    this.parentForm = null;
    this._annotationPanels = null;
    this._messagePanels = null;
    this._Scr2ElmMatrix = null;
    this._Elm2ScrMatrix = null;
  }
  resetRefrenceSize() {
    this._refWidth = this.getContainerInnerWidth();
    this._refHeight = this.getContainerInnerHeight();
  }
  get refWidth() {
    return this._refWidth;
  }
  get refHeight() {
    return this._refHeight;
  }
  RendererCanvas_Click(sender, e) {
  }
  RendererCanvas_DoubleClick(sender, e) {
  }
  addMessagePanel() {
    let p = new MessagePanel(this, this);
    this._messagePanels.push(p);
    return p;
  }
  DrawMessagePanels(g, viewPortWidth, viewPortHeight) {
    for (let i = 0; i < this._messagePanels.length; i++) {
      if (this._messagePanels[i].enabled) {
        let p = this._messagePanels[i];
        let AvailableWidth = viewPortWidth - 2 * p.padding - p.borderthickness;
        if (AvailableWidth < 100)
          AvailableWidth = 100;
        let ssize = null;
        let sizeok = false;
        while (!sizeok) {
          ssize = g.MeasureString(p.text, p.font, AvailableWidth);
          if ((ssize.width >= this.UIContainer.width || ssize.height >= this.UIContainer.height) && p.font.size > 5) {
            p.font.size = Math.round(p.font.size * 9) / 10;
          } else
            sizeok = true;
        }
        if (ssize == null)
          return;
        let panelWidth = ssize.width + 2 * p.padding + p.borderthickness;
        let panelHeight = ssize.height + 2 * p.padding + p.borderthickness;
        let x = 0;
        switch (p.panelHrzAlign) {
          case MessagePanel.HorizontalAlignPos.LEFT:
            x = p.horizontalMargin;
            break;
          case MessagePanel.HorizontalAlignPos.RIGHT:
            x = viewPortWidth - panelWidth - p.horizontalMargin;
            break;
          default:
            x = (viewPortWidth - panelWidth) / 2;
            break;
        }
        let y = 0;
        switch (p.panelVrtAlign) {
          case MessagePanel.VerticalAlignPos.TOP:
            y = p.verticalMargin;
            break;
          case MessagePanel.VerticalAlignPos.BOTTOM:
            y = viewPortHeight - panelHeight - p.verticalMargin;
            break;
          default:
            y = (viewPortHeight - panelHeight) / 2;
            break;
        }
        g.FillRectangleXYHW(p.bgBrush, x, y, panelWidth, panelHeight);
        if (p.borderthickness > 0)
          g.DrawRectangleXYHW(p.pen, x, y, panelWidth, panelHeight);
        let sf = new YStringFormat(16384);
        switch (p.panelTextAlign) {
          case MessagePanel.TextAlign.LEFT:
            sf.LineAlignment = 0;
            sf.Alignment = 0;
            break;
          case MessagePanel.TextAlign.RIGHT:
            sf.LineAlignment = 2;
            sf.Alignment = 2;
            break;
          default:
            sf.LineAlignment = 1;
            sf.Alignment = 1;
            break;
        }
        let r = new YRectangle(x + p.padding + p.borderthickness / 2 >> 0, y + p.padding + p.borderthickness / 2 >> 0, ssize.width + 1, ssize.height + 1);
        g.DrawStringRect(p.text, p.font, p.font.brush, r, sf);
      }
    }
  }
  drawAnnotationPanels(g, annotationPanels, viewPortWidth, viewPortHeight, overlap, mainViewPort) {
    let active = false;
    for (let i = 0; i < this.annotationPanels.length; i++) {
      if (this.annotationPanels[i].enabled)
        active = true;
    }
    if (!active)
      return;
    for (let i = 0; i < this.annotationPanels.length; i++) {
      if (annotationPanels[i].enabled && annotationPanels[i].overlap == overlap) {
        let p = annotationPanels[i];
        let AvailableWidth = viewPortWidth - 2 * p.padding - p.borderthickness;
        if (AvailableWidth < 100)
          AvailableWidth = 100;
        let textToDisplay = p.text.replace("\\n", "\n");
        if (textToDisplay.indexOf("$") >= 0) {
          textToDisplay = textToDisplay.replace("\\n", "\n");
          textToDisplay = this.patchAnnotation(textToDisplay);
        }
        let ssize = g.MeasureString(textToDisplay, p.font, AvailableWidth);
        let panelWidth = ssize.width + 2 * p.padding + p.borderthickness;
        let panelHeight = ssize.height + 2 * p.padding + p.borderthickness;
        let x = 0;
        switch (p.panelHrzAlign) {
          case MessagePanel.HorizontalAlignPos.LEFT:
            x = p.horizontalMargin;
            if (!annotationPanels[i].overlap && mainViewPort.Lmargin < panelWidth + 10) {
              mainViewPort.Lmargin = panelWidth + 10;
            }
            break;
          case MessagePanel.HorizontalAlignPos.RIGHT:
            x = viewPortWidth - panelWidth - p.horizontalMargin;
            if (!annotationPanels[i].overlap && mainViewPort.Rmargin < panelWidth + 20) {
              mainViewPort.Rmargin = panelWidth + 20;
            }
            break;
          default:
            x = (viewPortWidth - panelWidth) / 2;
            break;
        }
        let y = 0;
        switch (p.panelVrtAlign) {
          case MessagePanel.VerticalAlignPos.TOP:
            y = p.verticalMargin;
            if (!annotationPanels[i].overlap && mainViewPort.Tmargin < panelHeight + 20) {
              mainViewPort.Tmargin = panelHeight + 20;
            }
            break;
          case MessagePanel.VerticalAlignPos.BOTTOM:
            y = viewPortHeight - panelHeight - p.verticalMargin;
            if (!annotationPanels[i].overlap && mainViewPort.Bmargin < panelHeight + 20) {
              mainViewPort.Bmargin = panelHeight + 20;
            }
            break;
          default:
            y = (viewPortHeight - panelHeight) / 2;
            break;
        }
        if (annotationPanels[i].overlap) {
          x += annotationPanels[i].positionOffsetX / 100 * (viewPortWidth - panelWidth);
          y += annotationPanels[i].positionOffsetY / 100 * (viewPortHeight - panelHeight);
          if (x < 0)
            x = 0;
          if (y < 0)
            y = 0;
          if (x > viewPortWidth - panelWidth)
            x = viewPortWidth - panelWidth;
          if (y > viewPortHeight - panelHeight)
            y = viewPortHeight - panelHeight;
        }
        g.FillRectangleXYHW(p.bgBrush, x, y, panelWidth, panelHeight);
        if (p.borderthickness > 0)
          g.DrawRectangleXYHW(p.pen, x, y, panelWidth, panelHeight);
        let sf = new YStringFormat(16384);
        switch (p.panelTextAlign) {
          case MessagePanel.TextAlign.LEFT:
            sf.LineAlignment = 0;
            sf.Alignment = 0;
            break;
          case MessagePanel.TextAlign.RIGHT:
            sf.LineAlignment = 2;
            sf.Alignment = 2;
            break;
          default:
            sf.LineAlignment = 1;
            sf.Alignment = 1;
            break;
        }
        let r = new YRectangle(x + p.padding + p.borderthickness / 2, y + p.padding + p.borderthickness / 2, ssize.width + 1, ssize.height + 1);
        g.DrawStringRect(textToDisplay, p.font, p.font.brush, r, sf);
      }
    }
  }
  log(s) {
    if (this._logFunction == null)
      return;
    this._logFunction(s);
  }
};
YDataRenderer.RendererDebug = false;
YDataRenderer.FloatToStrformats = ["0", "0", "0", "0.0", "0.00", "0.000", "0.0000"];
YDataRenderer._disableMinMaxCheck = false;
YDataRenderer.globalMouseMoveSet = false;
YDataRenderer.globalMouseX = -1;
YDataRenderer.globalMouseY = -1;
(function(YDataRenderer2) {
  class CaptureTypeEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, CaptureType);
    }
  }
  YDataRenderer2.CaptureTypeEnumItem = CaptureTypeEnumItem;
  class CaptureType extends YEnum {
  }
  CaptureType.PNG = new CaptureTypeEnumItem("PNG", "Bitmap (PNG)");
  CaptureType.SVG = new CaptureTypeEnumItem("SVG", "Vector (SVG)");
  YDataRenderer2.CaptureType = CaptureType;
  class CaptureTargetEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, CaptureTarget);
    }
  }
  YDataRenderer2.CaptureTargetEnumItem = CaptureTargetEnumItem;
  class CaptureTarget extends YEnum {
  }
  CaptureTarget.ToClipBoard = new CaptureTargetEnumItem("ToClipBoard", "ClipBoard");
  CaptureTarget.ToFile = new CaptureTargetEnumItem("ToFile", "File");
  YDataRenderer2.CaptureTarget = CaptureTarget;
  class CaptureFormatsEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, CaptureFormats);
    }
  }
  YDataRenderer2.CaptureFormatsEnumItem = CaptureFormatsEnumItem;
  class CaptureFormats extends YEnum {
  }
  CaptureFormats.Keep = new CaptureFormatsEnumItem("Keep", "Keep original size");
  CaptureFormats.Fixed = new CaptureFormatsEnumItem("Fixed", "Fixed size");
  CaptureFormats.FixedWidth = new CaptureFormatsEnumItem("FixedWidth", "Fixed width, keep ration aspect");
  CaptureFormats.FixedHeight = new CaptureFormatsEnumItem("FixedHeight", "Fixed height, keep ration aspect");
  YDataRenderer2.CaptureFormats = CaptureFormats;
})(YDataRenderer || (YDataRenderer = {}));
var YGraphics = class {
  constructor(canvas, width, height, dpi) {
    this._c = null;
    this._g = null;
    this._width = 0;
    this._height = 0;
    this._dpi = 0;
    this._image = null;
    this._lastPen = null;
    this._lastBrush = null;
    this._lastFont = null;
    this._clipCounter = 0;
    this._textRenderingHint = null;
    this._smoothingMode = YSmoothingMode.Default;
    this._c = canvas;
    this._g = this._c.getContext("2d");
    this._g.textBaseline = "top";
    this._width = width;
    this._height = height;
    this._dpi = dpi;
  }
  get_downloadableData() {
    return this._c.toDataURL("image/png");
  }
  get graphics() {
    return this._g;
  }
  setPen(p) {
    if (p == this._lastPen)
      return;
    if (p != null) {
      this._g.lineWidth = p.lineWidth;
      let st = p.strokeStyle;
      this._g.strokeStyle = p.strokeStyle;
    } else {
      this._g.lineWidth = 0;
    }
    this._lastPen = p;
  }
  setBrush(b) {
    if (b == this._lastBrush)
      return;
    if (b instanceof YSolidBrush) {
      this._g.fillStyle = b.color.htmlCode;
    } else if (b instanceof YLinearGradientBrush) {
      let lingrad = this._g.createLinearGradient(0, 0, 0, this._height);
      lingrad.addColorStop(0, b.color1.htmlCode);
      lingrad.addColorStop(1, b.color2.htmlCode);
      this._g.fillStyle = lingrad;
    } else {
      throw new Error("invalid / insupported brush type");
    }
    this._lastBrush = b;
  }
  setFont(f) {
    if (f == this._lastFont && !f.hasChanged)
      return;
    this._g.font = f.htmlCode;
    this._lastFont = f;
  }
  DrawLineXY(p, x1, y1, x2, y2) {
    if (p.noAntiAlias) {
      let offset = p.lineWidth == p.lineWidth >> 0 && (p.lineWidth & 1) == 1 ? 0.5 : 0;
      x1 = Math.round(x1) + offset;
      y1 = Math.round(y1) + offset;
      x2 = Math.round(x2) + offset;
      y2 = Math.round(y2) + offset;
    }
    this.setPen(p);
    this._g.beginPath();
    this._g.moveTo(x1, y1);
    this._g.lineTo(x2, y2);
    this._g.stroke();
  }
  DrawLine(p, p1, p2) {
    this.setPen(p);
    this._g.beginPath();
    this._g.moveTo(p1.X, p1.Y);
    this._g.lineTo(p2.X, p2.Y);
    this._g.stroke();
  }
  SetClip(rect) {
    this._g.save();
    this._g.beginPath();
    this._g.rect(rect.x, rect.y, rect.w, rect.h);
    this._g.clip();
    this._clipCounter++;
  }
  ResetClip() {
    if (this._clipCounter <= 0)
      throw new Error("clipping stack error");
    this._g.restore();
    this._clipCounter--;
  }
  MeasureString(text, font, width) {
    this.setFont(font);
    let res = new YSizeF(font, text);
    let count = res.linesCount;
    if (count == 0)
      return res;
    res.height = res.firstLineHeight * 1.2 + (count - 1) * res.lineHeight;
    let max = 0;
    let dim;
    for (let i = 0; i < count; i++) {
      dim = this._g.measureText(res.lines[i]);
      max = Math.max(max, dim.width);
    }
    res.width = max;
    return res;
  }
  MeasureStringSF(text, font, width, stringFormat) {
    return this.MeasureString(text, font, width);
  }
  FillRectangle(brush, rect) {
    this.setBrush(brush);
    this._g.beginPath();
    this._g.fillRect(rect.x, rect.y, rect.w, rect.h);
    this._g.fill();
  }
  FillRectangleXYHW(brush, x, y, width, height) {
    this.setBrush(brush);
    this._g.beginPath();
    this._g.fillRect(x, y, width, height);
    this._g.fill();
  }
  DrawRectangle(p, rect) {
    this.setPen(p);
    this._g.beginPath();
    if (p.noAntiAlias) {
      let offset = p.lineWidth == p.lineWidth >> 0 && (p.lineWidth & 1) == 1 ? 0.5 : 0;
      this._g.rect(Math.round(rect.x) + offset, Math.round(rect.y) + offset, Math.round(rect.w), Math.round(rect.h));
    } else {
      this._g.rect(rect.x, rect.y, rect.w, rect.h);
    }
    this._g.stroke();
  }
  DrawRectangleXYHW(p, x, y, width, height) {
    if (p.noAntiAlias) {
      let offset = p.lineWidth == p.lineWidth >> 0 && (p.lineWidth & 1) == 1 ? 0.5 : 0;
      x = Math.round(x) + offset;
      y = Math.round(y) + offset;
      width = Math.round(width);
      height = Math.round(height);
    }
    this.setPen(p);
    this._g.beginPath();
    this._g.rect(x, y, width, height);
    this._g.stroke();
  }
  DrawStringXY(s, font, brush, x, y) {
    this.setPen(null);
    this.setBrush(brush);
    this.setFont(font);
    let totalsz = this.MeasureString(s, font, 0);
    let dy = totalsz.lineHeight;
    for (let i = 0; i < totalsz.linesCount; i++) {
      this._g.fillText(totalsz.lines[i], x, y);
      y += dy;
    }
  }
  DrawStringXYF(s, font, brush, x, y, format) {
    if (YGraphics._debugDrawString) {
      let pen = new YPen(YColor.Red, 1);
      this.DrawLineXY(pen, x - 5, y, x + 5, y);
      this.DrawLineXY(pen, x, y - 5, x, y + 5);
    }
    let sz = this.MeasureString(s, font, 1e4);
    if (format.Alignment == 1) {
      x -= sz.width >> 1;
    } else if (format.Alignment == 2)
      x -= sz.width;
    if (format.LineAlignment == 1) {
      y -= sz.height / 2 >> 0;
    } else if (format.LineAlignment == 2)
      y -= sz.height;
    this.DrawStringXY(s, font, brush, x, y);
  }
  DrawStringPF(s, font, brush, p, format) {
    this.DrawStringXYF(s, font, brush, p.X, p.Y, format);
  }
  DrawString(s, font, brush, p) {
    if (YGraphics._debugDrawString) {
      let pen = new YPen(YColor.Red, 1);
      this.DrawLineXY(pen, p.X - 5, p.Y, p.X + 5, p.Y);
      this.DrawLineXY(pen, p.X, p.Y - 5, p.X, p.Y + 5);
    }
    this.setPen(null);
    this.setBrush(brush);
    this.setFont(font);
    this._g.fillText(s, p.X, p.Y);
  }
  DrawStringRect(s, font, brush, layoutRectangle, format) {
    if (YGraphics._debugDrawString) {
      let pen = new YPen(YColor.Red, 1);
      this.DrawRectangle(pen, layoutRectangle);
    }
    this.setPen(null);
    this.setBrush(brush);
    this.setFont(font);
    let totalsz = this.MeasureString(s, font, 0);
    let dy = totalsz.lineHeight;
    let y = layoutRectangle.y;
    switch (format.LineAlignment) {
      case 0:
        break;
      case 1:
        y += (layoutRectangle.h - totalsz.height) / 2;
        break;
      case 2:
        y += layoutRectangle.h - totalsz.height;
        break;
    }
    let xOrigin = layoutRectangle.x;
    if (format.FormatFlags & 2) {
      this.Transform(layoutRectangle.x, layoutRectangle.y, Math.PI / 2);
      y -= layoutRectangle.y + layoutRectangle.w;
      xOrigin -= layoutRectangle.x;
    }
    for (let i = 0; i < totalsz.linesCount; i++) {
      let s2 = totalsz.lines[i];
      let sz = this.MeasureString(s2, font, 0);
      let x = xOrigin;
      switch (format.Alignment) {
        case 0:
          break;
        case 1:
          x += (layoutRectangle.w - sz.width) / 2;
          break;
        case 2:
          x += layoutRectangle.w - sz.width;
          break;
      }
      this._g.fillText(s2, x, y);
      y += dy;
    }
    if (format.FormatFlags & 2)
      this.ResetTransform();
  }
  Transform(dx, dy, angle) {
    let sin = Math.sin(angle);
    let cos = Math.cos(angle);
    this._g.save();
    this._g.transform(cos, sin, -sin, cos, dx, dy);
  }
  ResetTransform() {
    this._g.restore();
  }
  FillEllipse(brush, x, y, width, height) {
    this.setBrush(brush);
    this._g.beginPath();
    this._g.ellipse(x + width / 2, y + height / 2, width / 2, height / 2, 0, 0, 2 * Math.PI);
    this._g.fill();
  }
  DrawEllipse(pen, x, y, width, height) {
    this.setPen(pen);
    this._g.beginPath();
    this._g.ellipse(x + width / 2, y + height / 2, width / 2, height / 2, 0, 0, 2 * Math.PI);
    this._g.stroke();
  }
  FillPolygon(brush, points) {
    this.setBrush(brush);
    if (points.length <= 2)
      return;
    this._g.beginPath();
    if (brush.noAntiAlias) {
      this._g.moveTo(Math.round(points[0].X) + 0.5, Math.round(points[0].Y) + 0.5);
      for (let i = 1; i < points.length; i++) {
        this._g.lineTo(Math.round(points[i].X) + 0.5, Math.round(points[i].Y) + 0.5);
      }
    } else {
      this._g.moveTo(points[0].X, points[0].Y);
      for (let i = 1; i < points.length; i++) {
        this._g.lineTo(points[i].X, points[i].Y);
      }
    }
    this._g.closePath();
    this._g.fill();
  }
  DrawPolygon(pen, points) {
    this.setPen(pen);
    if (points.length <= 1)
      return;
    this._g.beginPath();
    if (pen.noAntiAlias) {
      let offset = pen.lineWidth == pen.lineWidth >> 0 && (pen.lineWidth & 1) == 1 ? 0.5 : 0;
      this._g.moveTo(Math.round(points[0].X) + offset, Math.round(points[0].Y) + offset);
      for (let i = 1; i < points.length; i++) {
        this._g.lineTo(Math.round(points[i].X) + offset, Math.round(points[i].Y) + offset);
      }
    } else {
      this._g.moveTo(points[0].X, points[0].Y);
      for (let i = 1; i < points.length; i++) {
        this._g.lineTo(points[i].X, points[i].Y);
      }
    }
    this._g.closePath();
    this._g.stroke();
  }
  DrawLines(pen, points) {
    this.setPen(pen);
    if (points.length <= 1)
      return;
    this._g.beginPath();
    this._g.lineCap = "round";
    this._g.lineJoin = "round";
    this._g.moveTo(points[0].X, points[0].Y);
    for (let i = 1; i < points.length; i++) {
      this._g.lineTo(points[i].X, points[i].Y);
    }
    this._g.stroke();
  }
  Dispose() {
    this._c = null;
    this._g = null;
    this._width = 0;
    this._height = 0;
    this._dpi = 0;
  }
  get TextRenderingHint() {
    return this._textRenderingHint;
  }
  set TextRenderingHint(value) {
    this._textRenderingHint = value;
  }
  get SmoothingMode() {
    return this._smoothingMode;
  }
  set SmoothingMode(value) {
    this._smoothingMode = value;
  }
  DrawImage(srcimage, destRect, srcRect, srcUnit) {
    this._g.drawImage(srcimage, srcRect.x, srcRect.y, srcRect.w, srcRect.h, destRect.x, destRect.y, destRect.w, destRect.h);
  }
  comment(s) {
  }
};
YGraphics._debugDrawString = false;
var YGraphicsSVG = class extends YGraphics {
  constructor(canvas, width, height, dpi) {
    super(canvas, width, height, dpi);
    this._clipcount = 0;
    this._clipSectionsToClose = 0;
    this._transformSectionsToClose = 0;
    this._gradientCount = 0;
    YGraphicsSVG.SVGID++;
    this._SVGdefs = new YStringBuilder();
    this._SVGcontents = new YStringBuilder();
    this._SVGdefs.AppendLine('<clipPath id="pageClip_' + YGraphicsSVG.SVGID.toString() + '"><rect x="0" y="0"  width="' + width.toString() + '" height="' + height.toString() + '"/></clipPath>');
  }
  static escapeXml(unsafe) {
    return unsafe.replace(/[^ !#$%(-;=?-z]/g, (c) => "&#" + c.charCodeAt(0) + ";");
  }
  get_downloadableData() {
    return "data:image/svg+xml;base64," + btoa(this.get_svgContents());
  }
  DrawLineXY(p, x1, y1, x2, y2) {
    this._SVGcontents.AppendLine('<line x1="' + x1.toString() + '"  y1 ="' + y1.toString() + '"  x2 ="' + x2.toString() + '"  y2 ="' + y2.toString() + '" style = "stroke:' + p.color.svgCode + ";stroke-opacity:" + p.color.alphaCode + "; stroke-width:" + p.lineWidth.toString() + '"/>');
  }
  DrawLine(p, p1, p2) {
    this.DrawLineXY(p, p1.X, p1.Y, p2.X, p2.Y);
  }
  SetClip(rect) {
    this.ResetClip();
    this._SVGdefs.AppendLine('<clipPath id="clip_' + YGraphicsSVG.SVGID.toString() + "_" + this._clipcount.toString() + '"><rect x="' + rect.x.toString() + '" y="' + rect.y.toString() + '"  width="' + rect.w.toString() + '" height="' + rect.h.toString() + '"/></clipPath>');
    this._SVGcontents.AppendLine('<g clip-path="url(#clip_' + YGraphicsSVG.SVGID.toString() + "_" + this._clipcount.toString() + ')">');
    this._clipcount++;
    this._clipSectionsToClose++;
  }
  ResetClip() {
    if (this._clipSectionsToClose > 0) {
      this._SVGcontents.AppendLine("</g>");
      this._clipSectionsToClose--;
    }
  }
  BrushToSVG(brush, revert) {
    let fillParam = "";
    if (brush instanceof YSolidBrush) {
      fillParam = 'fill = "' + brush.color.svgCode + '" fill-opacity="' + brush.color.alphaCode + '" ';
    } else if (brush instanceof YLinearGradientBrush) {
      this._SVGdefs.AppendLine('<linearGradient id="grad_' + YGraphicsSVG.SVGID.toString() + "_" + this._gradientCount + '" x1="0%" ' + (revert ? 'y1="100%" ' : 'y1="0%" ') + 'x2="0%" ' + (revert ? 'y2="0%" ' : 'y2="100%" ') + '>\r\n<stop offset="0%" style ="stop-color:' + brush.color1.svgCode + ";stop-opacity:" + brush.color1.alphaCode + '"/>\r\n<stop offset="100%" style ="stop-color:' + brush.color2.svgCode + ";stop-opacity:" + brush.color2.alphaCode + '"/>\r\n</linearGradient>');
      fillParam = 'fill="url(#grad_' + YGraphicsSVG.SVGID.toString() + "_" + this._gradientCount + ')" ';
      this._gradientCount++;
    } else {
      throw new ReferenceError("unsupported brush type.");
    }
    return fillParam;
  }
  FillRectangle(brush, rect) {
    this._SVGcontents.AppendLine('<rect x="' + rect.x.toString() + '"  y ="' + rect.y.toString() + '"  width ="' + rect.w.toString() + '"  height ="' + rect.h.toString() + '" ' + this.BrushToSVG(brush, true) + 'style="stroke-width:0"/>');
  }
  FillRectangleXYHW(brush, x, y, width, height) {
    this.FillRectangle(brush, new YRectangle(x, y, width, height));
  }
  DrawRectangle(p, rect) {
    this._SVGcontents.AppendLine('<rect x="' + rect.x.toString() + '"  y ="' + rect.y.toString() + '"  width ="' + rect.w.toString() + '"  height ="' + rect.h.toString() + '"  fill="none" style = "stroke:' + p.color.svgCode + ";stroke-opacity:" + p.color.alphaCode + "; stroke-width:" + p.lineWidth.toString() + '"/>');
  }
  DrawRectangleXYHW(p, x, y, width, height) {
    this.DrawRectangle(p, new YRectangle(x, y, width, height));
  }
  DrawEllipse(pen, x, y, width, height) {
    this._SVGcontents.AppendLine('<ellipse  cx="' + (x + width / 2).toString() + '"  cy ="' + (y + height / 2).toString() + '"  rx ="' + (width / 2).toString() + '"  ry ="' + (height / 2).toString() + '"  fill="none" style = "stroke:' + pen.color.svgCode + ";stroke-opacity:" + pen.color.alphaCode + "; stroke-width:" + pen.lineWidth.toString() + '"/>');
  }
  FillEllipse(brush, x, y, width, height) {
    this._SVGcontents.AppendLine('<ellipse  cx="' + (x + width / 2).toString() + '"  cy ="' + (y + height / 2).toString() + '"  rx ="' + (width / 2).toString() + '"  ry ="' + (height / 2).toString() + '" ' + this.BrushToSVG(brush, false) + 'style="stroke-width:0"/>');
  }
  DrawStringXY(s, font, brush, x, y) {
    let tokens = s.split("\n");
    for (let i = 0; i < tokens.length; i++) {
      s = tokens[i];
      this._SVGcontents.AppendLine('<text x="' + x.toString() + '" y="' + (y + font.sizeInPoints).toString() + '" text-anchor="start" font-family="' + font.name.toString() + '" font-size="' + font.sizeInPoints.toString() + 'pt" font-weight="' + (font.bold ? "bold" : "normal") + '" font-style="' + (font.italic ? "italic" : "normal") + '" ' + this.BrushToSVG(brush, false) + 'style="stroke-width:0">\r\n' + YGraphicsSVG.escapeXml(s) + "\r\n</text>");
      y += font.sizeInPoints * 1.75;
    }
  }
  DrawString(s, font, brush, p) {
    if (YGraphics._debugDrawString) {
      let pen = new YPen(YColor.Red, 1);
      this.DrawLineXY(pen, p.X - 5, p.Y, p.X + 5, p.Y);
      this.DrawLineXY(pen, p.X, p.Y - 5, p.X, p.Y + 5);
    }
    this.DrawStringXY(s, font, brush, p.X, p.Y);
  }
  DrawStringF(s, font, brush, point, format) {
    let totalsz = this.MeasureString(s, font, 0);
    let y = point.Y + font.size * 1.25;
    switch (format.LineAlignment) {
      case 0:
        break;
      case 1:
        y += -totalsz.height / 2;
        break;
      case 2:
        y += -totalsz.height;
        break;
    }
    let tokens = s.split("\n");
    for (let i = 0; i < tokens.length; i++) {
      let s2 = tokens[i];
      let sz = this.MeasureString(s2, font, 0);
      let x = point.X;
      switch (format.Alignment) {
        case 0:
          break;
        case 1:
          x += -sz.width / 2;
          break;
        case 2:
          x += -sz.width;
          break;
      }
      this._SVGcontents.AppendLine('<text x="' + x.toString() + '" y="' + y.toString() + '" text-anchor="start" font-family="' + font.name.toString() + '" font-size="' + font.sizeInPoints.toString() + 'pt" font-weight="' + (font.bold ? "bold" : "normal") + '" font-style="' + (font.italic ? "italic" : "normal") + '" ' + this.BrushToSVG(brush, false) + 'style="stroke-width:0">\r\n' + YGraphicsSVG.escapeXml(s2) + "\r\n</text>");
      y += font.sizeInPoints * 1.75;
    }
  }
  DrawStringRect(s, font, brush, layoutRectangle, format) {
    if (YGraphics._debugDrawString) {
      let pen = new YPen(YColor.Red, 1);
      this.DrawRectangle(pen, layoutRectangle);
    }
    let totalsz = this.MeasureString(s, font, 0);
    let y = layoutRectangle.y + font.sizeInPoints * 1.1;
    switch (format.LineAlignment) {
      case 0:
        break;
      case 1:
        y += (layoutRectangle.h - totalsz.height) / 2;
        break;
      case 2:
        y += layoutRectangle.h - totalsz.height;
        break;
    }
    let tokens = s.split("\n");
    for (let i = 0; i < tokens.length; i++) {
      let s2 = tokens[i];
      let sz = this.MeasureString(s2, font, 0);
      let x = layoutRectangle.x;
      switch (format.Alignment) {
        case 0:
          break;
        case 1:
          x += (layoutRectangle.w - sz.width) / 2;
          break;
        case 2:
          x += layoutRectangle.w - sz.width;
          break;
      }
      this._SVGcontents.AppendLine('<text x="' + x.toString() + '" y="' + y.toString() + '" text-anchor="start" font-family="' + font.name.toString() + '" font-size="' + (font.sizeInPoints * 1.1).toString() + 'pt" font-weight="' + (font.bold ? "bold" : "normal") + '" font-style="' + (font.italic ? "italic" : "normal") + '" ' + this.BrushToSVG(brush, false) + 'style="stroke-width:0">\r\n' + YGraphicsSVG.escapeXml(s2) + "\r\n</text>");
      y += font.sizeInPoints * 1.75;
    }
  }
  Transform(dx, dy, angle) {
    this._SVGcontents.AppendLine('<g transform="translate(' + dx.toString() + " " + dy.toString() + ") rotate(" + (180 * angle / Math.PI).toString() + ')">');
    this._transformSectionsToClose++;
  }
  ResetTransform() {
    if (this._transformSectionsToClose > 0) {
      this._SVGcontents.AppendLine("</g>");
      this._transformSectionsToClose--;
    }
  }
  DrawPolygon(pen, points) {
    if (points.length < 2)
      return;
    this._SVGcontents.Append('<path  d="M ' + points[0].X.toString() + " " + points[0].Y.toString());
    for (let i = 1; i < points.length; i += 1) {
      this._SVGcontents.Append(" L " + points[i].X.toString() + " " + points[i].Y.toString());
    }
    this._SVGcontents.AppendLine(' z" fill="none" style="stroke:' + pen.color.svgCode + ";stroke-opacity:" + pen.color.alphaCode + "; stroke-width:" + pen.lineWidth.toString() + '"/>');
  }
  DrawLines(pen, points) {
    if (points.length < 2)
      return;
    this._SVGcontents.Append('<path  d="M ' + points[0].X.toString() + " " + points[0].Y.toString());
    for (let i = 1; i < points.length; i++) {
      this._SVGcontents.Append(" L " + points[i].X.toString() + " " + points[i].Y.toString());
    }
    this._SVGcontents.AppendLine('" fill="none" style="stroke:' + pen.color.svgCode + ";stroke-opacity:" + pen.color.alphaCode + "; stroke-linecap:round; stroke-linejoin:round;stroke-width:" + pen.lineWidth.toString() + '"/>');
  }
  FillPolygon(brush, points) {
    if (points.length < 2)
      return;
    this._SVGcontents.Append('<path  d="M ' + points[0].X.toString() + " " + points[0].Y.toString());
    for (let i = 1; i < points.length; i++) {
      this._SVGcontents.Append(" L " + points[i].X.toString() + " " + points[i].Y.toString());
    }
    this._SVGcontents.AppendLine(' z" ' + this.BrushToSVG(brush, false) + 'style="stroke-width:0"/>\r\n');
  }
  DrawImage(image, destRect, srcRect, srcUnit) {
    throw new Error("DrawImage not supported, find an other way.");
  }
  save(filename) {
    throw new Error("Direct save to file not supported.");
  }
  comment(s) {
    this._SVGcontents.AppendLine("<!--" + s + "-->");
  }
  get_svgContents() {
    let physicalWidth = (2.54 * (this._width / this._dpi)).toFixed(3);
    let physicalheight = (2.54 * (this._height / this._dpi)).toFixed(3);
    while (this._clipSectionsToClose > 0) {
      this._SVGcontents.AppendLine("</g>");
      this._clipSectionsToClose--;
    }
    while (this._transformSectionsToClose > 0) {
      this._SVGcontents.AppendLine("</g>");
      this._transformSectionsToClose--;
    }
    return '<?xml version = "1.0" standalone = "no" ?>\r\n<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">\r\n<svg width = "' + physicalWidth + 'cm" height = "' + physicalheight + 'cm" viewBox = "0 0 ' + this._width.toString() + " " + this._height.toString() + '" xmlns = "http://www.w3.org/2000/svg" version = "1.1" >\r\n<defs>\r\n' + this._SVGdefs.contents + '</defs>\r\n<g clip-path="url(#pageClip_' + YGraphicsSVG.SVGID.toString() + ')">\r\n' + this._SVGcontents.contents + "</g>\r\n</svg>\n";
  }
};
YGraphicsSVG.SVGID = 0;

// obj/full/Renderer/YAngularGauge.js
var YAngularZone = class extends Zone {
  get path() {
    return this._path;
  }
  setPathSize(count) {
    this._path = new Array(count).fill(null);
  }
  setPathPoint(index, p) {
    this._path[index] = p;
  }
  resetPath() {
    this._path = null;
  }
  resetCache() {
    this.resetPath();
  }
  get width() {
    return this._width;
  }
  set width(value) {
    if (value <= 0)
      throw new RangeError("Width must be a positive value");
    this._width = value;
    this._path = null;
    this._parentRenderer.redraw();
  }
  get outerRadius() {
    return this._outerRadius;
  }
  set outerRadius(value) {
    this._outerRadius = Math.max(0, Math.min(100, value));
    this._path = null;
    this._parentRenderer.redraw();
  }
  constructor(parentRenderer, directParent) {
    super(parentRenderer, directParent);
    this._path = null;
    this._width = 10;
    this._outerRadius = 98;
  }
};
var YAngularGauge = class extends YDataRenderer {
  get min() {
    return this._min;
  }
  set min(value) {
    if (value >= this._max && !YDataRenderer.minMaxCheckDisabled) {
      throw new RangeError("Min cannot be greater than max (" + this._max.toString() + ")");
    }
    this._min = value;
    for (let i = 0; i < this._zones.length; i++) {
      this._zones[i].resetPath();
    }
    if (this._needleValue < this._min) {
      this._needleValue = this._min;
    }
    this.redraw();
  }
  get max() {
    return this._max;
  }
  set max(value) {
    if (value <= this._min && !YDataRenderer.minMaxCheckDisabled) {
      throw new RangeError("Max cannot be less than min (" + this._min.toString() + ")");
    }
    this._max = value;
    for (let i = 0; i < this._zones.length; i++) {
      this._zones[i].resetPath();
    }
    if (this._needleValue > this._max) {
      this._needleValue = this._max;
    }
    this.redraw();
  }
  get borderpen() {
    if (this._borderpen == null) {
      this._borderpen = new YPen(this._borderColor, this._borderThickness);
      this._borderpen.startCap = 1;
      this._borderpen.endCap = 1;
    }
    return this._borderpen;
  }
  get borderColor() {
    return this._borderColor;
  }
  set borderColor(value) {
    this._borderColor = value;
    this._borderpen = null;
    this.redraw();
  }
  get backgroundColor1() {
    return this._backgroundColor1;
  }
  set backgroundColor1(value) {
    this._backgroundColor1 = value;
    this._bgBrush = null;
    this.redraw();
  }
  get backgroundColor2() {
    return this._backgroundColor2;
  }
  set backgroundColor2(value) {
    this._backgroundColor2 = value;
    this._bgBrush = null;
    this.redraw();
  }
  get borderThickness() {
    return this._borderThickness;
  }
  set borderThickness(value) {
    if (value < 0)
      throw new RangeError("thickness must be a positive value");
    this._borderThickness = value;
    this._borderpen = null;
    this.redraw();
  }
  get valueFormater() {
    return this._valueFormater;
  }
  set valueFormater(value) {
    this._valueFormater = value;
    this.redraw();
  }
  get minmaxFormater() {
    return this._minmaxFormater;
  }
  set minmaxFormater(value) {
    this._minmaxFormater = value;
    this.redraw();
  }
  get thickness() {
    return this._thickness;
  }
  set thickness(value) {
    if (value < 0)
      throw new RangeError("Thickness must be a positive value");
    this._thickness = Math.max(Math.min(value, 80), 1);
    this.redraw();
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value;
    this.redraw();
  }
  get color1() {
    return this._color1;
  }
  set color1(value) {
    this._color1 = value;
    this.redraw();
  }
  get color2() {
    return this._color2;
  }
  set color2(value) {
    this._color2 = value;
    this.redraw();
  }
  get graduationColor() {
    return this._graduationColor;
  }
  set graduationColor(value) {
    this._graduationColor = value;
    this._graduationPen = null;
    this.redraw();
  }
  get graduationThickness() {
    return this._graduationThickness;
  }
  set graduationThickness(value) {
    if (value < 0)
      throw new RangeError("Thickness must be a positive value");
    this._graduationThickness = value;
    this._graduationPen = null;
    this.redraw();
  }
  get graduationSize() {
    return this._graduationSize;
  }
  set graduationSize(value) {
    if (value <= 0)
      throw new RangeError("Graduation size must be a positive value");
    this._graduationSize = value;
    this.redraw();
  }
  get graduation() {
    return this._graduation;
  }
  set graduation(value) {
    this._graduation = value;
    this.redraw();
  }
  get unitFactor() {
    return this._unitFactor;
  }
  set unitFactor(value) {
    if (value == 0)
      throw new RangeError("Factor cannot be zero.");
    this._unitFactor = value;
    this.redraw();
  }
  get unit() {
    return this._unit;
  }
  set unit(value) {
    this._unit = value;
    this.redraw();
  }
  get unitFont() {
    return this._unitFont;
  }
  get subgraduationColor() {
    return this._subgraduationColor;
  }
  set subgraduationColor(value) {
    this._subgraduationColor = value;
    this._subgraduationPen = null;
    this.redraw();
  }
  get subgraduationThickness() {
    return this._subgraduationThickness;
  }
  set subgraduationThickness(value) {
    if (value < 0)
      throw new RangeError("Thickness must be a positive value");
    this._subgraduationThickness = value;
    this._subgraduationPen = null;
    this.redraw();
  }
  get subgraduationSize() {
    return this._subgraduationSize;
  }
  set subgraduationSize(value) {
    if (value <= 0)
      throw new RangeError("Size must be a positive value");
    this._subgraduationSize = value;
    this.redraw();
  }
  get graduationOuterRadiusSize() {
    return this._graduationOuterRadiusSize;
  }
  set graduationOuterRadiusSize(value) {
    this._graduationOuterRadiusSize = Math.max(0, Math.min(100, value));
    this.redraw();
  }
  get subgraduationCount() {
    return this._subgraduationCount;
  }
  set subgraduationCount(value) {
    if (value < 0)
      throw new RangeError("Count must be a positive value");
    this._subgraduationCount = value;
    this.redraw();
  }
  get statusColor() {
    return this._statusColor;
  }
  set statusColor(value) {
    this._statusColor = value;
    this.redraw();
  }
  get statusFont() {
    return this._unitFont;
  }
  get statusLine() {
    return this._statusLine;
  }
  set statusLine(value) {
    this._statusLine = value;
    this.redraw();
  }
  get showNeedle() {
    return this._showNeedle;
  }
  set showNeedle(value) {
    this._showNeedle = value;
    this.redraw();
  }
  get needleColor() {
    return this._needleColor;
  }
  set needleColor(value) {
    this._needleColor = value;
    this._needleBrush = null;
    this.redraw();
  }
  get needleMaxSpeed() {
    return this._needleMaxSpeed;
  }
  set needleMaxSpeed(value) {
    if (value <= 0)
      throw new RangeError("Speed must be a positive value");
    this._needleMaxSpeed = value;
    this.redraw();
  }
  get needleLength1() {
    return this._needleLength1;
  }
  set needleLength1(value) {
    this._needleLength1 = value;
    this.redraw();
  }
  get needleLength2() {
    return this._needleLength2;
  }
  set needleLength2(value) {
    this._needleLength2 = value;
    this.redraw();
  }
  get needleWidth() {
    return this._needleWidth;
  }
  set needleWidth(value) {
    if (value <= 0)
      throw new RangeError("Width must be a positive value");
    this._needleWidth = value;
    this.redraw();
  }
  get needleContourColor() {
    return this._needleContourColor;
  }
  set needleContourColor(value) {
    this._needleContourColor = value;
    this._needleContourPen = null;
    this.redraw();
  }
  get needleContourThickness() {
    return this._needleContourThickness;
  }
  set needleContourThickness(value) {
    if (value < 0)
      throw new RangeError("Thickness must be a positive value");
    this._needleContourThickness = value;
    this._needleContourPen = null;
    this.redraw();
  }
  get graduationFont() {
    return this._graduationFont;
  }
  get showMinMax() {
    return this._showMinMax;
  }
  set showMinMax(value) {
    this._showMinMax = value;
    this.redraw();
  }
  constructor(UIContainer, logFunction) {
    super(UIContainer, logFunction);
    this._min = 0;
    this._max = 100;
    this.SegmentMaxLength = 8;
    this._borderpen = null;
    this._borderColor = YColor.Black;
    this._bgBrush = null;
    this._backgroundColor1 = YColor.FromArgb(255, 240, 240, 240);
    this._backgroundColor2 = YColor.FromArgb(255, 200, 200, 200);
    this._borderThickness = 5;
    this._valueFormater = null;
    this._minmaxFormater = null;
    this._thickness = 20;
    this._value = 0;
    this._needleValue = 0;
    this._color1 = YColor.Green;
    this._color2 = YColor.Red;
    this._graduationPen = null;
    this._graduationColor = YColor.Black;
    this._graduationThickness = 2;
    this._graduationSize = 10;
    this._graduation = 10;
    this._unitFactor = 1;
    this._unit = "";
    this._subgraduationPen = null;
    this._subgraduationColor = YColor.Black;
    this._subgraduationThickness = 1;
    this._subgraduationSize = 5;
    this._graduationOuterRadiusSize = 98;
    this._subgraduationCount = 5;
    this._statusColor = YColor.Gray;
    this._statusLine = "";
    this._showNeedle = true;
    this._needleBrush = null;
    this._needleColor = YColor.Red;
    this._needleMaxSpeed = 5;
    this._needleLength1 = 90;
    this._needleLength2 = 5;
    this._needleWidth = 5;
    this._needleContourPen = null;
    this._needleContourColor = YColor.DarkRed;
    this._needleContourThickness = 1;
    this._showMinMax = true;
    this._path = null;
    this._graduationFont = new YFont(this, this, Math.min(this.getContainerInnerWidth(), this.getContainerInnerHeight()) / 15, null);
    this._unitFont = new YFont(this, this, Math.min(this.getContainerInnerWidth(), this.getContainerInnerHeight()) / 20, null);
    this._statusFont = new YFont(this, this, Math.min(this.getContainerInnerWidth(), this.getContainerInnerHeight()) / 15, null);
    this.unitFont.color = YColor.DarkGray;
    this._statusFont.color = YColor.DarkGray;
    this.resizeRule = Proportional.ResizeRule.RELATIVETOBOTH;
    this._zones = [];
  }
  clearCachedObjects() {
    if (this._zones != null) {
      for (let i = 0; i < this._zones.length; i++) {
        this._zones[i].resetPath();
      }
    }
    this._path = null;
    this._bgBrush = null;
  }
  get zones() {
    return this._zones;
  }
  AddZone() {
    let z = new YAngularZone(this, this);
    this._zones.push(z);
    return z;
  }
  Render(g, w, h) {
    let mainViewPort = new ViewPortSettings();
    mainViewPort.Lmargin = 0;
    mainViewPort.Rmargin = 0;
    mainViewPort.Tmargin = 0;
    mainViewPort.Bmargin = 0;
    g.SmoothingMode = YSmoothingMode.HighQuality;
    g.TextRenderingHint = YTextRenderingHint.AntiAlias;
    let stringFormat4Sizing = new YStringFormat(16384);
    let stringFormat = new YStringFormat(16384);
    stringFormat.Alignment = 1;
    stringFormat.LineAlignment = 1;
    this.drawAnnotationPanels(g, this._annotationPanels, w, h, false, mainViewPort);
    g.TextRenderingHint = YTextRenderingHint.AntiAlias;
    let xcenter = mainViewPort.Lmargin + (w - mainViewPort.Lmargin - mainViewPort.Rmargin) / 2;
    let ycenter = mainViewPort.Tmargin + (h - mainViewPort.Tmargin - mainViewPort.Bmargin) / 2;
    let radius = Math.min((w - mainViewPort.Lmargin - mainViewPort.Rmargin) / 2, (h - mainViewPort.Tmargin - mainViewPort.Bmargin) / 2) - this.borderThickness;
    let circonference = 2 * radius * 3.14 >> 0;
    let AngleAperture = 4 * 2 * Math.PI / 5;
    if (this._path == null) {
      let outterlength = 2 * radius * Math.PI;
      let stepCount = outterlength / this.SegmentMaxLength >> 0;
      let stepsize = 2 * Math.PI / stepCount;
      this._path = new Array(stepCount).fill(null);
      let n = 0;
      for (let i = 0; i < stepCount; i++) {
        let a = 2 * i * Math.PI / stepCount;
        this._path[n++] = new PointF(xcenter + radius * Math.cos(a), ycenter - radius * Math.sin(a));
      }
    }
    if (this._bgBrush == null)
      this._bgBrush = new YLinearGradientBrush(this._backgroundColor1, this._backgroundColor2);
    if (this._borderpen == null) {
      this._borderpen = new YPen(this._borderColor, this._borderThickness);
      this._borderpen.linejoin = YPen.LineJoin.Round;
    }
    if (this._path.length > 3)
      g.FillPolygon(this._bgBrush, this._path);
    if (this._graduationPen == null)
      this._graduationPen = new YPen(this._graduationColor, this._graduationThickness);
    if (this._subgraduationPen == null)
      this._subgraduationPen = new YPen(this._subgraduationColor, this._subgraduationThickness);
    let unitDesc = (this._unitFactor != 1 ? "x" + this._unitFactor.toString() + " " : "") + this._unit;
    let size = g.MeasureStringSF(unitDesc.toString(), this._unitFont, 1e4, stringFormat4Sizing);
    let unitPos = new YRectangle(xcenter - size.width / 2 >> 0, ycenter + radius / 2 - size.height / 2 >> 0, size.width + 1 >> 0, size.height + 1 >> 0);
    g.DrawStringRect(unitDesc, this._unitFont, this._unitFont.brush, unitPos, stringFormat);
    if (this._statusLine != "") {
      size = g.MeasureStringSF(this._statusLine, this._statusFont, 1e4, stringFormat4Sizing);
      let statusPos = new YRectangle(xcenter - size.width / 2 >> 0, ycenter - radius / 3 - size.height / 2 >> 0, size.width + 1, size.height + 1);
      g.DrawStringRect(this._statusLine, this._statusFont, this._statusFont.brush, statusPos, stringFormat);
    }
    let firstGraduation;
    let gratuationCount;
    let Angle, C, S, R1, R2;
    let outerCoef = this._graduationOuterRadiusSize / 100;
    for (let i = 0; i < this._zones.length; i++) {
      if (this._zones[i].visible) {
        if (this._zones[i].path == null) {
          let zmin = Math.max(this._min, Math.min(this._max, this._zones[i].min));
          let zmax = Math.max(this._min, Math.min(this._max, this._zones[i].max));
          if (zmax > zmin) {
            let zOuterCoef = this._zones[i].outerRadius / 100;
            let Angle1 = (Math.PI - AngleAperture) / 2 + AngleAperture * (zmin - this._min) / (this._max - this._min);
            let Angle2 = (Math.PI - AngleAperture) / 2 + AngleAperture * (zmax - this._min) / (this._max - this._min);
            let outterlength = (Angle2 - Angle1) * radius;
            let stepCount = outterlength / this.SegmentMaxLength >> 0;
            if (stepCount < 2)
              stepCount = 2;
            this._zones[i].setPathSize(2 * stepCount + 2);
            for (let j = 0; j <= stepCount; j++) {
              let A = Angle1 + (Angle2 - Angle1) * j / stepCount;
              this._zones[i].setPathPoint(j, new PointF(xcenter - radius * zOuterCoef * Math.cos(A), ycenter - radius * zOuterCoef * Math.sin(A)));
            }
            let innerRadiusCoef = zOuterCoef - this._zones[i].width / 100;
            for (let j = stepCount; j >= 0; j--) {
              let A = Angle1 + (Angle2 - Angle1) * j / stepCount;
              this._zones[i].setPathPoint(2 * stepCount + 1 - j, new PointF(xcenter - radius * innerRadiusCoef * Math.cos(A), ycenter - radius * innerRadiusCoef * Math.sin(A)));
            }
          }
        }
        if (this._zones[i].path != null)
          g.FillPolygon(this._zones[i].zoneBrush, this._zones[i].path);
      }
    }
    firstGraduation = this._graduation * (this._min / this._graduation) >> 0;
    if (this._min < 0)
      firstGraduation -= this._graduation;
    while (firstGraduation < this._min) {
      firstGraduation += this._graduation;
    }
    gratuationCount = 1 + (this._max - this._min) / this._graduation >> 0;
    if (this._subgraduationCount > 0 && this._subgraduationCount * gratuationCount < circonference) {
      let subgraduation = this._graduation / this._subgraduationCount;
      firstGraduation = subgraduation * (this._min / subgraduation >> 0);
      if (this._min < 0)
        firstGraduation -= subgraduation;
      while (firstGraduation < this._min) {
        firstGraduation += subgraduation;
      }
      gratuationCount = 1 + (this._max - this._min) / subgraduation >> 0;
      for (let i = 0; i < gratuationCount; i++) {
        let value = firstGraduation + i * subgraduation;
        if (value <= this._max) {
          Angle = (Math.PI - AngleAperture) / 2 + AngleAperture * (value - this._min) / (this._max - this._min);
          C = Math.cos(Angle);
          S = Math.sin(Angle);
          R1 = outerCoef * (radius - this._borderThickness / 2);
          R2 = (100 - this._subgraduationSize) * (outerCoef * (radius - this._borderThickness / 2)) / 100;
          g.DrawLineXY(this._subgraduationPen, xcenter - R1 * C, ycenter - R1 * S, xcenter - R2 * C, ycenter - R2 * S);
        }
      }
    }
    if (gratuationCount < circonference) {
      for (let i = 0; i < gratuationCount; i++) {
        let gvalue = firstGraduation + i * this._graduation;
        if (gvalue <= this._max) {
          Angle = (Math.PI - AngleAperture) / 2 + AngleAperture * (gvalue - this._min) / (this._max - this._min);
          C = Math.cos(Angle);
          S = Math.sin(Angle);
          R1 = outerCoef * (radius - this._borderThickness / 2);
          R2 = (100 - this._graduationSize) * (outerCoef * (radius - this._borderThickness / 2)) / 100;
          g.DrawLineXY(this._graduationPen, xcenter - R1 * C, ycenter - R1 * S, xcenter - R2 * C, ycenter - R2 * S);
          size = g.MeasureStringSF(gvalue.toString().trim(), this._graduationFont, 1e3, stringFormat4Sizing);
          let HalfDiagonal = 0.4 * Math.sqrt(size.width * size.width + size.height * size.height);
          let position = new YRectangle(xcenter - (R2 - HalfDiagonal) * C - size.width / 2 >> 0, ycenter - (R2 - HalfDiagonal) * S - size.height / 2 >> 0, (size.width >> 0) + 1, size.height >> 0);
          g.DrawStringRect(gvalue.toString(), this._graduationFont, this._graduationFont.brush, position, stringFormat);
        }
      }
    }
    if (this._borderThickness > 0 && this._path.length > 3)
      g.DrawPolygon(this._borderpen, this._path);
    this.drawAnnotationPanels(g, this._annotationPanels, w, h, true, mainViewPort);
    if (this._showNeedle) {
      if (this._needleValue != this._value) {
        let step = this._unitFactor * this._needleMaxSpeed * (this._max - this._min) / 100;
        if (Math.abs(this._value - this._needleValue) < step) {
          this._needleValue = this._value;
        } else if (this._needleValue < this.value) {
          this._needleValue += step;
        } else {
          this._needleValue -= step;
        }
      }
      let needlevalue = this._needleValue / this._unitFactor;
      let allowedOverflow = (this._max - this.min) * 0.05;
      if (needlevalue < this._min - allowedOverflow)
        needlevalue = this._min - allowedOverflow;
      if (needlevalue > this._max + allowedOverflow)
        needlevalue = this._max + allowedOverflow;
      Angle = (Math.PI - AngleAperture) / 2 + AngleAperture * (needlevalue - this._min) / (this._max - this._min);
      C = Math.cos(Angle);
      S = Math.sin(Angle);
      R1 = radius * this._needleLength1 / 100;
      R2 = radius * this._needleLength2 / 100;
      let R3 = radius * this._needleWidth / 200;
      let needlepath = new Array(4).fill(null);
      needlepath[0] = new PointF(xcenter - R1 * C, ycenter - R1 * S);
      needlepath[1] = new PointF(xcenter + R3 * S, ycenter - R3 * C);
      needlepath[2] = new PointF(xcenter + R2 * C, ycenter + R2 * S);
      needlepath[3] = new PointF(xcenter - R3 * S, ycenter + R3 * C);
      if (this._needleBrush == null)
        this._needleBrush = new YSolidBrush(this._needleColor);
      g.FillPolygon(this._needleBrush, needlepath);
      if (this._needleContourThickness > 0) {
        if (this._needleContourPen == null) {
          this._needleContourPen = new YPen(this._needleContourColor, this._needleContourThickness);
          this._needleContourPen.startCap = 2;
          this._needleContourPen.endCap = 2;
          this._needleContourPen.linejoin = YPen.LineJoin.Round;
        }
        let needlepath2 = new Array(5).fill(null);
        needlepath2[0] = needlepath[0];
        needlepath2[1] = needlepath[1];
        needlepath2[2] = needlepath[2];
        needlepath2[3] = needlepath[3];
        needlepath2[4] = needlepath[0];
        g.DrawLines(this._needleContourPen, needlepath2);
      }
    }
    this.DrawMessagePanels(g, w, h);
    return 0;
  }
  renderingPostProcessing() {
    if (this._needleValue != this._value)
      this.redraw();
  }
};

// obj/full/Renderer/YDigitalDisplay.js
var YDigitalDisplay = class extends YDataRenderer {
  get backgroundColor1() {
    return this._backgroundColor1;
  }
  set backgroundColor1(value) {
    this._backgroundColor1 = value;
    this._bgBrush = null;
    this.redraw();
  }
  get backgroundColor2() {
    return this._backgroundColor2;
  }
  set backgroundColor2(value) {
    this._backgroundColor2 = value;
    this._bgBrush = null;
    this.redraw();
  }
  get alternateValue() {
    return this._alternateValue;
  }
  set alternateValue(value) {
    this._alternateValue = value;
    this.redraw();
  }
  get valueFormater() {
    return this._valueFormater;
  }
  set valueFormater(value) {
    this._valueFormater = value;
    this.redraw();
  }
  get hrzAlignmentOfset() {
    return this._hrzAlignmentOfset;
  }
  set hrzAlignmentOfset(value) {
    this._hrzAlignmentOfset = value;
    this.redraw();
  }
  get hrzAlignment() {
    return this._hrzAlignment;
  }
  set hrzAlignment(value) {
    this._hrzAlignment = value;
    this.redraw();
  }
  get outOfRangeMin() {
    return this._outOfRangeMin;
  }
  set outOfRangeMin(value) {
    if (!Number.isNaN(value) && !Number.isNaN(this._outOfRangeMax) && !YDataRenderer.minMaxCheckDisabled) {
      if (value >= this._outOfRangeMax)
        throw new RangeError("Min cannot be greater than max (" + this._outOfRangeMax.toString() + ")");
    }
    this._outOfRangeMin = value;
    this.redraw();
  }
  get outOfRangeMax() {
    return this._outOfRangeMax;
  }
  set outOfRangeMax(value) {
    if (!Number.isNaN(value) && !Number.isNaN(this._outOfRangeMin) && !YDataRenderer.minMaxCheckDisabled) {
      if (value <= this._outOfRangeMin)
        throw new RangeError("Min cannot be less than max (" + this._outOfRangeMin.toString() + ")");
    }
    this._outOfRangeMax = value;
    this.redraw();
  }
  get outOfRangeColor() {
    return this._outOfRangeColor;
  }
  set outOfRangeColor(value) {
    this._outOfRangeColor = value;
    this.redraw();
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value;
    this.redraw();
  }
  get font() {
    return this._font;
  }
  constructor(UIContainer, logFunction) {
    super(UIContainer, logFunction);
    this._bgBrush = null;
    this._backgroundColor1 = YColor.Black;
    this._backgroundColor2 = YColor.FromArgb(255, 48, 48, 48);
    this._alternateValue = null;
    this._valueFormater = null;
    this._hrzAlignmentOfset = 5;
    this._hrzAlignment = YDigitalDisplay.HrzAlignment.DECIMAL;
    this._outOfRangeMin = Number.NaN;
    this._outOfRangeMax = Number.NaN;
    this._outOfRangeColor = YColor.Red;
    this._value = 0;
    this._font = new YFont(this, this, Math.min(UIContainer.width / 5, UIContainer.height / 2), null);
    this._font.color = YColor.LightGreen;
    this.resizeRule = Proportional.ResizeRule.RELATIVETOBOTH;
  }
  clearCachedObjects() {
    if (this.font != null)
      this.font.ResetFont(null);
    this._bgBrush = null;
  }
  Render(g, w, h) {
    let mainViewPort = new ViewPortSettings();
    mainViewPort.Lmargin = 0;
    mainViewPort.Rmargin = 0;
    mainViewPort.Tmargin = 0;
    mainViewPort.Bmargin = 0;
    g.SmoothingMode = YSmoothingMode.HighQuality;
    g.TextRenderingHint = YTextRenderingHint.AntiAlias;
    let stringFormat = new YStringFormat(16384);
    stringFormat.Alignment = 1;
    stringFormat.LineAlignment = 1;
    if (this._bgBrush == null) {
      this._bgBrush = new YLinearGradientBrush(this._backgroundColor1, this._backgroundColor2);
    }
    g.FillRectangleXYHW(this._bgBrush, 0, 0, w, h);
    this.drawAnnotationPanels(g, this._annotationPanels, w, h, false, mainViewPort);
    if (mainViewPort.Tmargin >= 20)
      mainViewPort.Tmargin -= 10;
    if (mainViewPort.Bmargin >= 20)
      mainViewPort.Bmargin -= 10;
    g.TextRenderingHint = YTextRenderingHint.AntiAlias;
    let availWidth = w - (mainViewPort.Lmargin + mainViewPort.Rmargin);
    let availHeight = h - (mainViewPort.Tmargin + mainViewPort.Bmargin);
    if (availWidth > 10 && availHeight > 10) {
      let svalue;
      if (this._alternateValue == null) {
        svalue = this._valueFormater == null ? this.value.toFixed(3) : this._valueFormater(this, this.value);
        if (!Number.isNaN(this._outOfRangeMin) && this.value < this._outOfRangeMin) {
          this.font.alternateColor = this._outOfRangeColor;
        } else if (!Number.isNaN(this._outOfRangeMax) && this.value > this._outOfRangeMax) {
          this.font.alternateColor = this._outOfRangeColor;
        } else {
          this.font.alternateColor = null;
        }
      } else {
        this._font.alternateColor = null;
        svalue = this._alternateValue;
      }
      let size = g.MeasureStringSF(svalue, this.font, 1e4, stringFormat);
      let pos;
      let align = this._hrzAlignment;
      if (this._alternateValue != null && align == YDigitalDisplay.HrzAlignment.DECIMAL)
        align = YDigitalDisplay.HrzAlignment.RIGHT;
      if (align == YDigitalDisplay.HrzAlignment.DECIMAL && svalue.indexOf(".") < 0)
        align = YDigitalDisplay.HrzAlignment.RIGHT;
      switch (align) {
        case YDigitalDisplay.HrzAlignment.LEFT:
          pos = new YRectangle(mainViewPort.Lmargin + (availWidth * this.hrzAlignmentOfset / 100 >> 0), mainViewPort.Tmargin + (availHeight - size.height) / 2 >> 0, size.width + 1 >> 0, size.height + 1 >> 0);
          g.DrawStringRect(svalue, this.font, this.font.brush, pos, stringFormat);
          break;
        case YDigitalDisplay.HrzAlignment.CENTER:
          pos = new YRectangle(mainViewPort.Lmargin + (availWidth - size.width) / 2 >> 0, mainViewPort.Tmargin + (availHeight - size.height) / 2 >> 0, size.width + 1 >> 0, size.height + 1 >> 0);
          g.DrawStringRect(svalue, this.font, this.font.brush, pos, stringFormat);
          break;
        case YDigitalDisplay.HrzAlignment.DECIMAL:
          let left = "";
          let p = svalue.lastIndexOf(",");
          if (p < 0)
            p = svalue.lastIndexOf(".");
          if (p >= 0) {
            left = svalue.substring(0, p + 1);
          } else {
            p = 0;
            while (p < svalue.length && (svalue[p] >= "0" && svalue[p] <= "9" || svalue[p] == "-" || svalue[p] == "'" || svalue[p] == " ")) {
              p++;
            }
            left = svalue.substring(0, p);
          }
          let lsize = g.MeasureStringSF(left, this.font, 1e4, stringFormat);
          pos = new YRectangle(mainViewPort.Lmargin + (availWidth - lsize.width - availWidth * this.hrzAlignmentOfset / 100) >> 0, mainViewPort.Tmargin + (availHeight - size.height) / 2 >> 0, size.width + 1 >> 0, size.height + 1 >> 0);
          g.DrawStringRect(svalue, this.font, this.font.brush, pos, stringFormat);
          break;
        case YDigitalDisplay.HrzAlignment.RIGHT:
          pos = new YRectangle(mainViewPort.Lmargin + (availWidth - size.width - availWidth * this.hrzAlignmentOfset / 100) >> 0, mainViewPort.Tmargin + (availHeight - size.height) / 2 >> 0, size.width + 1 >> 0, size.height + 1 >> 0);
          g.DrawStringRect(svalue, this.font, this.font.brush, pos, stringFormat);
          break;
      }
    }
    this.drawAnnotationPanels(g, this._annotationPanels, w, h, true, mainViewPort);
    this.DrawMessagePanels(g, w, h);
    return 0;
  }
};
(function(YDigitalDisplay2) {
  class HrzAlignmentEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, HrzAlignment);
    }
  }
  YDigitalDisplay2.HrzAlignmentEnumItem = HrzAlignmentEnumItem;
  class HrzAlignment extends YEnum {
  }
  HrzAlignment.LEFT = new HrzAlignmentEnumItem("LEFT", "Left");
  HrzAlignment.CENTER = new HrzAlignmentEnumItem("CENTER", "Center");
  HrzAlignment.DECIMAL = new HrzAlignmentEnumItem("DECIMAL", "Decimal");
  HrzAlignment.RIGHT = new HrzAlignmentEnumItem("RIGHT", "Right");
  YDigitalDisplay2.HrzAlignment = HrzAlignment;
})(YDigitalDisplay || (YDigitalDisplay = {}));

// obj/full/Renderer/YGraph.js
var SUMMARY_GRANULARITY = 100;
var pointXY = class {
  constructor(X, Y) {
    this.x = X === void 0 ? 0 : X;
    this.y = Y === void 0 ? 0 : Y;
  }
  clone() {
    return new pointXY(this.x, this.y);
  }
};
var pointsSummary = class {
  constructor(X1, X2, YMIN, YMAX) {
    this.x1 = X1;
    this.x2 = X2;
    this.ymin = YMIN;
    this.ymax = YMAX;
  }
  clone() {
    return new pointsSummary(this.x1, this.x2, this.ymin, this.ymin);
  }
};
var TimeConverterParseResult = class {
  constructor() {
    this.success = false;
    this.result = 0;
  }
};
var TimeResolution = class {
  constructor() {
    this.step = 0;
    this.format = 0;
  }
};
var YDate = class extends Date {
  ToString(format) {
    let res = "";
    let ampm = "";
    if (format & YDate.D)
      res = res + this.getDate() + " ";
    if (format & YDate.M)
      res = res + YDate.months[this.getMonth()] + " ";
    if (format & YDate.YY) {
      let y = this.getFullYear().toString();
      res = res + y.substr(y.length - 2) + " ";
    } else if (format & YDate.YYYY) {
      let y = this.getFullYear().toString();
      res = res + y + " ";
    }
    if (format & YDate.CR)
      res = res + "\n";
    if (format & YDate.h) {
      if (YDate.use24Hformat) {
        let h = "0" + this.getHours().toString();
        res = res + h.substring(h.length - 2);
        if (!(format & YDate.m))
          res = res + "H";
      } else {
        let hour = this.getHours();
        ampm = "AM";
        if (hour > 11)
          ampm = "PM";
        if (hour > 12)
          hour = hour - 12;
        if (hour == 0)
          hour = 12;
        res = res + hour.toString();
      }
    }
    if (format & YDate.m) {
      let m = "0" + this.getMinutes().toString();
      res = res + ":" + m.substring(m.length - 2);
    }
    if (format & YDate.s) {
      let s = "0" + this.getSeconds().toString();
      res = res + ":" + s.substring(s.length - 2);
    }
    if (format & YDate.ms1) {
      let ms = "00" + this.getMilliseconds().toString();
      res = res + "." + ms.substring(ms.length - 3).substring(1);
    } else if (format & YDate.ms01) {
      let ms = "00" + this.getMilliseconds().toString();
      res = res + "." + ms.substring(ms.length - 3).substring(2);
    } else if (format & YDate.ms001) {
      let ms = "00" + this.getMilliseconds().toString();
      res = res + "." + ms.substring(ms.length - 3).substring(3);
    }
    if (format & YDate.h && !YDate.use24Hformat) {
      res = res + ampm;
    }
    return res;
  }
};
YDate.D = 1;
YDate.DD = 2;
YDate.M = 4;
YDate.YY = 8;
YDate.h = 16;
YDate.m = 32;
YDate.s = 64;
YDate.ms1 = 128;
YDate.ms01 = 256;
YDate.ms001 = 512;
YDate.CR = 1024;
YDate.isRelative = 2048;
YDate.YYYY = 4096;
YDate.d = new Date().toLocaleTimeString().toUpperCase();
YDate.use24Hformat = YDate.d.indexOf("AM") < 0 && YDate.d.indexOf("PM") < 0;
YDate.months = ["jan", "feb", "mar", "apr", "may", "jun", "jul", "aug", "sep", "oct", "nov", "dec"];
var TimeConverter = class {
  static UTCNow() {
    return new YDate();
  }
  static ToUnixTime(datetime) {
    return datetime.getTime() / 1e3;
  }
  static FromUnixTime(unixtime) {
    let t = new YDate();
    t.setTime(unixtime * 1e3);
    return t;
  }
  static tryParseStringToAbsDateTime(str) {
    let res = new TimeConverterParseResult();
    res.success = false;
    let date = new Date();
    let year = date.getFullYear();
    let month = date.getMonth();
    let day = date.getDate();
    let hours = 0;
    let minutes = 0;
    let seconds = 0;
    str = str.trim();
    while (str.indexOf("  ") > 0) {
      str = str.replace("  ", " ");
    }
    let dateFound = false;
    let timeFound = false;
    let it = str.split(" ");
    if (it.length <= 0)
      return res;
    for (let i = 0; i < it.length && i < 2; i++) {
      if (it[i].indexOf("-") > 0) {
        let tokens = it[i].split("-");
        if (tokens.length == 1) {
          day = parseInt(tokens[0]);
        } else if (tokens.length == 2) {
          day = parseInt(tokens[1]);
          month = parseInt(tokens[0]) - 1;
        } else {
          day = parseInt(tokens[2]);
          month = parseInt(tokens[1]) - 1;
          year = parseInt(tokens[0]);
        }
        dateFound = true;
      } else if (it[i].indexOf(":") > 0) {
        let tokens = it[i].split(":");
        if (tokens.length == 1) {
          hours = parseInt(tokens[0]);
        } else if (tokens.length == 2) {
          hours = parseInt(tokens[0]);
          minutes = parseInt(tokens[1]);
        } else {
          hours = parseInt(tokens[0]);
          minutes = parseInt(tokens[1]);
          seconds = parseFloat(tokens[2]);
        }
        timeFound = true;
      }
    }
    if (!timeFound && !dateFound)
      return res;
    if (isNaN(year) || isNaN(month) || isNaN(day) || isNaN(hours) || isNaN(minutes) || isNaN(seconds))
      return res;
    date.setFullYear(year, month, day);
    date.setHours(hours, minutes, seconds >> 0, 1e3 * (seconds % 1) >> 0);
    res.result = date.getTime() / 1e3;
    res.success = true;
    return res;
  }
  static tryParseStringToSecTimeSpan(st) {
    let res = new TimeConverterParseResult();
    let d = 0;
    st = st.toUpperCase();
    let n = st.indexOf("D");
    if (n > 0) {
      d = parseFloat(st.substring(0, n));
      if (isNaN(d)) {
        return res;
      }
      res.result += +d * 86400;
      if (n == st.length - 1) {
        res.success = true;
        return res;
      }
      st = st.substring(n + 1);
    }
    n = st.indexOf("H");
    if (n > 0) {
      d = parseFloat(st.substring(0, n));
      if (isNaN(d)) {
        return res;
      }
      res.result += d * 3600;
      if (n == st.length - 1) {
        res.success = true;
        return res;
      }
      st = st.substring(n + 1);
    }
    n = st.indexOf("M");
    if (n > 0) {
      d = parseFloat(st.substring(0, n));
      if (isNaN(d)) {
        return res;
      }
      res.result += d * 60;
      if (n == st.length - 1) {
        res.success = true;
        return res;
      }
      st = st.substring(n + 1);
    }
    n = st.indexOf("S");
    if (n < 0)
      n = st.length;
    d = parseFloat(st.substring(0, n));
    if (isNaN(d)) {
      return res;
    }
    res.result += d;
    res.success = true;
    return res;
  }
  static secTimeSpanToString(timespan, resolution) {
    let started = false;
    let res = "";
    if (timespan < 0) {
      res = "-";
      timespan = -timespan;
    }
    if (timespan >= 86400) {
      let d = timespan / 86400 >> 0;
      res = res + d.toString() + "d";
      timespan -= 86400 * d;
      started = true;
    }
    if (resolution >= 86400)
      return res != "" ? res : "0d";
    if (timespan >= 3600) {
      let d = timespan / 3600 >> 0;
      let ds = d.toString();
      if (started && ds.length == 1)
        ds = "0" + ds;
      res = res + ds + "h";
      timespan -= 3600 * d;
      started = true;
    }
    if (resolution >= 3600)
      return res != "" ? res : "0h";
    if (timespan < resolution)
      return res != "" ? res : "0h";
    if (timespan >= 60) {
      let d = timespan / 60 >> 0;
      let ds = d.toString();
      if (started && ds.length == 1)
        ds = "0" + ds;
      res = res + ds + "m";
      timespan -= 60 * d;
      started = true;
    }
    if (resolution >= 60)
      return res != "" ? res : "0m";
    if (timespan < resolution)
      return res != "" ? res : "0m";
    timespan = Math.round(timespan * 100) / 100;
    let s;
    if (resolution > 0.1) {
      s = timespan.toFixed(0);
    } else if (resolution > 0.01) {
      s = timespan.toFixed(1);
    } else if (resolution > 1e-3) {
      s = timespan.toFixed(2);
    } else {
      s = timespan.toString();
    }
    if (started && timespan < 10)
      s = "0" + s;
    res = res + s + "s";
    return res;
  }
  static RelativeFormat(dataDeltaTime, viewportDeltaTime, resolution) {
    let ShowSecondsTenth = true;
    let ShowSecondsHundredth = true;
    let ShowSeconds = true;
    let ShowMinutes = false;
    let ShowHours = false;
    let ShowDays = false;
    if (dataDeltaTime <= 0.1) {
      ShowSecondsHundredth = true;
    }
    if (dataDeltaTime <= 1) {
      ShowSecondsTenth = true;
    }
    if (dataDeltaTime >= 60 || viewportDeltaTime >= 60) {
      ShowMinutes = true;
    }
    if (dataDeltaTime >= 3600 || viewportDeltaTime >= 3600) {
      ShowHours = true;
    }
    if (dataDeltaTime >= 86400 || viewportDeltaTime >= 86400) {
      ShowDays = true;
    }
    if (resolution >= 0.1)
      ShowSecondsHundredth = false;
    if (resolution >= 1)
      ShowSecondsTenth = false;
    if (resolution >= 60)
      ShowSeconds = false;
    if (resolution >= 3600)
      ShowMinutes = false;
    if (resolution >= 86400)
      ShowHours = false;
    let format = 0;
    format |= YDate.isRelative;
    if (ShowSecondsTenth)
      format |= YDate.ms1;
    if (ShowSecondsHundredth)
      format |= YDate.ms01;
    if (ShowSeconds)
      format |= YDate.s;
    if (ShowMinutes)
      format |= YDate.m;
    if (ShowHours)
      format |= YDate.h;
    if (ShowDays)
      format |= YDate.D;
    return format;
  }
  static BestTimeformat(dataDeltaTime, viewportDeltaTime, tref) {
    let res = new TimeResolution();
    let ShowSecondsTenth = true;
    let ShowSecondsHundredth = true;
    let ShowSeconds = true;
    let ShowMinutes = false;
    let ShowHours = false;
    let ShowDays = false;
    let ShowMonths = false;
    let ShowYears = false;
    if (viewportDeltaTime <= 0.1) {
      res.step = 0.01;
    } else if (viewportDeltaTime <= 1) {
      res.step = 0.1;
    } else if (viewportDeltaTime <= 2) {
      res.step = 0.2;
    } else if (viewportDeltaTime <= 5) {
      res.step = 0.5;
    } else if (viewportDeltaTime <= 10) {
      res.step = 1;
    } else if (viewportDeltaTime <= 20) {
      res.step = 2;
    } else if (viewportDeltaTime <= 30) {
      res.step = 3;
    } else if (viewportDeltaTime <= 40) {
      res.step = 4;
    } else if (viewportDeltaTime <= 60) {
      res.step = 5;
    } else if (viewportDeltaTime <= 120) {
      res.step = 10;
    } else if (viewportDeltaTime <= 300) {
      res.step = 30;
    } else if (viewportDeltaTime <= 900) {
      res.step = 60;
    } else if (viewportDeltaTime <= 1800) {
      res.step = 180;
    } else if (viewportDeltaTime <= 3600) {
      res.step = 300;
    } else if (viewportDeltaTime <= 7200) {
      res.step = 600;
    } else if (viewportDeltaTime <= 14e3) {
      res.step = 900;
    } else if (viewportDeltaTime <= 21600) {
      res.step = 1800;
    } else if (viewportDeltaTime <= 43200) {
      res.step = 3600;
    } else if (viewportDeltaTime <= 86400) {
      res.step = 7200;
    } else if (viewportDeltaTime <= 2 * 86400) {
      res.step = 2 * 7200;
    } else if (viewportDeltaTime <= 4 * 86400) {
      res.step = 4 * 7200;
    } else if (viewportDeltaTime <= 7 * 86400) {
      res.step = 86400;
    } else if (viewportDeltaTime <= 14 * 86400) {
      res.step = 2 * 86400;
    } else if (viewportDeltaTime <= 28 * 86400) {
      res.step = 4 * 86400;
    } else if (viewportDeltaTime <= 56 * 86400) {
      res.step = 7 * 86400;
    } else if (viewportDeltaTime <= 112 * 86400) {
      res.step = 14 * 86400;
    } else if (viewportDeltaTime <= 224 * 86400) {
      res.step = 31 * 86400;
    } else if (viewportDeltaTime <= 448 * 86400) {
      res.step = 62 * 86400;
    } else if (viewportDeltaTime <= 896 * 86400) {
      res.step = 93 * 86400;
    } else {
      res.step = 365 * 86400;
    }
    if (tref == TimeConverter.TimeReference.ABSOLUTE) {
      ShowSecondsHundredth = true;
      ShowSecondsTenth = true;
      ShowMinutes = true;
      ShowHours = true;
      ShowDays = dataDeltaTime > 86400;
      ShowMonths = dataDeltaTime > 86400;
      ShowYears = dataDeltaTime > 28 * 6 * 86400;
      if (res.step >= 0.1)
        ShowSecondsHundredth = false;
      if (res.step >= 1)
        ShowSecondsTenth = false;
      if (res.step >= 60)
        ShowSeconds = false;
      if (res.step >= 3600)
        ShowMinutes = false;
      if (res.step >= 86400)
        ShowHours = false;
      if (res.step >= 31 * 86400)
        ShowDays = false;
      if (res.step >= 365 * 86400)
        ShowMonths = false;
      res.format = 0;
      if (ShowSecondsHundredth)
        res.format |= YDate.ms01;
      if (ShowSecondsTenth)
        res.format |= YDate.ms1;
      if (ShowSeconds)
        res.format |= YDate.s;
      if (ShowMinutes)
        res.format = res.format |= YDate.m;
      if (ShowHours)
        res.format = res.format |= YDate.h;
      if (res.format != 0 && (ShowDays || ShowMonths))
        res.format |= YDate.CR;
      if (ShowDays)
        res.format |= YDate.D;
      if (ShowMonths)
        res.format |= YDate.M;
      if (ShowYears)
        res.format |= YDate.YY;
      if (res.format == YDate.YY)
        res.format = YDate.YYYY;
    } else {
      res.format = TimeConverter.RelativeFormat(dataDeltaTime, viewportDeltaTime, res.step);
    }
    return res;
  }
};
(function(TimeConverter2) {
  class TimeReferenceEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, TimeReference);
    }
  }
  TimeConverter2.TimeReferenceEnumItem = TimeReferenceEnumItem;
  class TimeReference extends YEnum {
  }
  TimeReference.ABSOLUTE = new TimeReferenceEnumItem("ABSOLUTE", "Absolute");
  TimeReference.RELATIVE = new TimeReferenceEnumItem("RELATIVE", "Relative to first data");
  TimeConverter2.TimeReference = TimeReference;
})(TimeConverter || (TimeConverter = {}));
var MinMax = class {
  constructor(minimum, maximum) {
    this.Min = 0;
    this.Max = 0;
    this.Min = minimum;
    this.Max = maximum;
  }
};
var MinMaxHandler = class {
  static extend(M, factor) {
    if (isNaN(M.Min))
      return M;
    let delta = M.Max - M.Min;
    return new MinMax(M.Min - delta * (factor - 1) / 2, M.Max + delta * (factor - 1) / 2);
  }
  static DefaultValue(value1, value2) {
    if (typeof value2 === "undefined") {
      if (typeof value1 === "undefined")
        return new MinMax(Number.NaN, Number.NaN);
      return new MinMax(value1, value1);
    }
    if (typeof value1 === "undefined")
      return new MinMax(value2, value2);
    if (value2 < value1)
      throw new RangeError("MinMax invalid parameters (" + value1.toString() + ">" + value2.toString());
    return new MinMax(value1, value2);
  }
  static isDefined(v) {
    return !isNaN(v.Min);
  }
  static Combine(M1, M2) {
    if (isNaN(M1.Min))
      return new MinMax(M2.Min, M2.Max);
    if (isNaN(M2.Min))
      return new MinMax(M1.Min, M1.Max);
    let res = new MinMax(M2.Min, M2.Max);
    if (M1.Min < res.Min)
      res.Min = M1.Min;
    if (M1.Max < res.Min)
      res.Min = M1.Max;
    if (M1.Min > res.Max)
      res.Max = M1.Min;
    if (M1.Max > res.Max)
      res.Max = M1.Max;
    return res;
  }
  static CombineWithNumber(M1, value) {
    if (isNaN(M1.Min))
      return new MinMax(value, value);
    if (value < M1.Min)
      return new MinMax(value, M1.Max);
    if (value > M1.Max)
      return new MinMax(M1.Min, value);
    return new MinMax(M1.Min, M1.Max);
  }
};
var DataSegment = class {
  static ArrayCopy(sourceArray, sourceIndex, destinationArray, destinationIndex, length) {
    for (let i = 0; i < length; i++) {
      destinationArray[destinationIndex + i] = sourceArray[sourceIndex + i].clone();
    }
  }
  constructor(p) {
    this.data = [];
    this.count = 0;
    if (p instanceof Array) {
      this.data = new Array(p.length);
      DataSegment.ArrayCopy(p, 0, this.data, 0, p.length);
      this.count = p.length;
    } else if (p instanceof pointXY) {
      this.data = new Array(DataSegment.SegmentGranularity);
      this.data[0] = p;
      this.count = 1;
    } else {
      throw new Error("invalid constructor paramter type");
    }
  }
  grow() {
    let targetCount = this.data.length + DataSegment.SegmentGranularity;
    while (this.data.length < targetCount) {
      this.data.push(null);
    }
  }
};
DataSegment.SegmentGranularity = 1e3;
var Summary = class {
  getBufferpoint() {
    if (this.vtlPtCount <= 0)
      return null;
    return new pointsSummary(this.Xmin, this.Xmax, this.Ymin, this.Ymax);
  }
  Dump() {
    var _a, _b, _c, _d;
    console.log("Summary level" + this.selfIndex + ", " + this.segments.length + " segments, " + this.totalpoints + " points");
    let lastx = 0;
    for (let s = 0; s < this.segments.length; s++) {
      console.log("  segment " + s);
      for (let i = 0; i < this.segments[s].ptCount; i++) {
        console.log(((_a = this.segments[s].data[i]) === null || _a === void 0 ? void 0 : _a.x1) + "," + ((_b = this.segments[s].data[i]) === null || _b === void 0 ? void 0 : _b.ymin) + " delataX=" + Math.round(this.segments[s].data[i].x1 - lastx));
        console.log(((_c = this.segments[s].data[i]) === null || _c === void 0 ? void 0 : _c.x2) + "," + ((_d = this.segments[s].data[i]) === null || _d === void 0 ? void 0 : _d.ymax) + " delataX=" + Math.round(this.segments[s].data[i].x2 - this.segments[s].data[i].x1));
        lastx = this.segments[s].data[i].x2;
      }
    }
  }
  constructor(index, array, pointSize) {
    this.segments = [];
    this.totalpoints = 0;
    this.Xmin = 0;
    this.Xmax = 0;
    this.Ymin = 0;
    this.Ymax = 0;
    this.vtlPtCount = 0;
    this.pointSize = 0;
    this.isLast = false;
    this.newSummaryLevelTrigger = 0;
    this.selfIndex = index;
    this.selfArray = array;
    this.pointSize = pointSize;
    this.isLast = true;
  }
  processSegments(segments) {
    if (segments.length <= 0)
      return;
    let last = segments.length - 1;
    this.Xmin = segments[last].data[0].x;
    this.Xmax = segments[last].data[0].x;
    this.Ymin = segments[last].data[0].y;
    this.Ymax = segments[last].data[0].y;
    this.totalpoints = 0;
    this.vtlPtCount = 0;
    for (let s = last; s >= 0; s--) {
      for (let i = 0; i < segments[s].data.length; i++) {
        let p = segments[s].data[i];
        if (p.x < this.Ymin)
          this.Ymin = p.y;
        if (p.x > this.Ymax)
          this.Ymax = p.y;
        this.Xmax = p.x;
        this.vtlPtCount++;
        if (this.vtlPtCount >= this.pointSize) {
          this.flush(false);
          this.Xmin = p.x;
          this.Ymin = p.y;
          this.Ymax = p.y;
        }
      }
      if (s > 0) {
        let len = segments[s].data.length;
        let p2 = segments[s - 1].data[0];
        let p1 = segments[s].data[len - 1];
        let lastDelta = 1;
        if (len > 1) {
          let p0 = segments[s].data[len - 2];
          lastDelta = p1.x - p0.x;
        }
        if (p2.x - p1.x > this.pointSize * lastDelta) {
          this.flush(false);
          this.Xmin = p2.x;
          this.Ymin = p2.y;
          this.Ymax = p2.y;
          this.addNewEmptySegment();
        }
      }
    }
    if (this.totalpoints > 1) {
      let it = new Summary(this.selfIndex + 1, this.selfArray, this.pointSize * SUMMARY_GRANULARITY);
      this.selfArray.push(it);
      this.isLast = false;
      it.processSegments(segments);
    }
  }
  addNewLevel() {
    let newIndex = this.selfArray.length;
    if (Summary.DBG)
      console.log("--- ADDING NEW LEVEL " + newIndex);
    let it = new Summary(newIndex, this.selfArray, this.pointSize * SUMMARY_GRANULARITY);
    this.selfArray.push(it);
    this.isLast = false;
    let _xmin = this.segments[0].data[0].x1;
    let _xmax = this.segments[0].data[0].x2;
    let _ymin = this.segments[0].data[0].ymin;
    let _ymax = this.segments[0].data[0].ymax;
    let _count = 0;
    for (let s = 0; s < this.segments.length; s++) {
      for (let i = 0; i < this.segments[s].ptCount; i++) {
        _xmax = this.segments[s].data[i].x2;
        if (this.segments[s].data[i].ymin < _ymin)
          _ymin = this.segments[s].data[i].ymin;
        if (this.segments[s].data[i].ymin > _ymax)
          _ymax = this.segments[s].data[i].ymin;
      }
      _count += this.segments[s].ptCount;
      if (s < this.segments.length - 1) {
        if (this.segments[s].ptCount > 2) {
          let lastIndex = this.segments[s].ptCount - 1;
          let lastDelta = this.segments[s].data[lastIndex].x1 - this.segments[s].data[lastIndex - 1].x2;
          if (this.segments[s + 1].data[0].x1 - this.segments[s].data[this.segments[s].ptCount - 1].x2 > lastDelta * SUMMARY_GRANULARITY) {
            it.addNewEmptySegment();
            _xmin = this.segments[s + 1].data[0].x1;
            _xmax = this.segments[s + 1].data[0].x2;
            _ymin = this.segments[s + 1].data[0].ymin;
            _ymax = this.segments[s + 1].data[0].ymax;
            _count = 0;
          }
        }
      }
    }
    if (_count != 0) {
      it.addNewSinglePointSegment(_xmin, _xmax, _ymin, _ymax, _count);
    }
  }
  addNewSinglePointSegment(xmin, xmax, ymin, ymax, _count) {
    if (Summary.DBG)
      console.log(" ===> level " + this.selfIndex + " new single point segment");
    this.segments.push(new DataSummarySegment(new pointsSummary(xmin, xmax, ymin, ymax), _count));
  }
  addNewEmptySegment() {
    if (Summary.DBG)
      console.log(" ===> level " + this.selfIndex + " new empty segment");
    this.segments.push(new DataSummarySegment(null, null));
  }
  addSequentialPoint(p, maxHoleSize) {
    if (Summary.DBG)
      console.log(" ADD Point, LEVEL " + this.selfIndex + " Vtl point = " + this.vtlPtCount + "/" + this.pointSize + " TOTAL Points= " + this.totalpoints);
    if (this.isLast && this.totalpoints >= SUMMARY_GRANULARITY)
      this.addNewLevel();
    if (this.vtlPtCount == 0) {
      this.Xmin = p.x;
      this.Xmax = p.x;
      this.Ymin = p.y;
      this.Ymax = p.y;
      this.vtlPtCount = 1;
      if (Summary.DBG) {
        if (this.selfIndex == 1)
          console.log(" --> added 1srt virtual pt vtlPtCount=" + this.vtlPtCount + "/" + this.pointSize);
      }
      if (!this.isLast)
        this.selfArray[this.selfIndex + 1].addSequentialPoint(p, maxHoleSize * SUMMARY_GRANULARITY);
      return;
    } else {
      if (Summary.DBG)
        console.log(" --> level " + this.selfIndex + " delta = " + (p.x - this.Xmax) + "/" + maxHoleSize);
      if (maxHoleSize > 0 && p.x - this.Xmax > maxHoleSize) {
        if (Summary.DBG)
          console.log(" --> level " + this.selfIndex + " hole detected");
        this.flush(false);
        this.addNewEmptySegment();
        this.Xmin = p.x;
        this.Xmax = p.x;
        this.Ymin = p.y;
        this.Ymax = p.y;
        this.vtlPtCount = 1;
        if (!this.isLast)
          this.selfArray[this.selfIndex + 1].addSequentialPoint(p, maxHoleSize * SUMMARY_GRANULARITY);
        return;
      }
      if (p.y < this.Ymin)
        this.Ymin = p.y;
      if (p.y > this.Ymax)
        this.Ymax = p.y;
      this.Xmax = p.x;
      this.vtlPtCount++;
      if (Summary.DBG) {
        if (this.selfIndex == 1)
          console.log(" --> level " + this.selfIndex + " added subsequent virtual pt vtlPtCount=" + this.vtlPtCount + "/" + this.pointSize);
      }
      if (this.vtlPtCount >= this.pointSize) {
        if (Summary.DBG) {
          if (this.selfIndex == 1)
            console.log(" --> level " + this.selfIndex + " flushing");
        }
        this.flush(false);
      }
    }
    if (!this.isLast)
      this.selfArray[this.selfIndex + 1].addSequentialPoint(p, maxHoleSize * SUMMARY_GRANULARITY);
  }
  flush(forceNewSegment) {
    if (this.segments.length == 0 || forceNewSegment)
      this.segments.push(new DataSummarySegment(null, null));
    let lastsegment = this.segments[this.segments.length - 1];
    lastsegment.data[lastsegment.ptCount] = new pointsSummary(this.Xmin, this.Xmax, this.Ymin, this.Ymax);
    this.totalpoints++;
    lastsegment.ptCount++;
    this.vtlPtCount = 0;
  }
};
Summary.DBG = false;
var DataSummarySegment = class {
  static ArrayCopy(sourceArray, sourceIndex, destinationArray, destinationIndex, length) {
    for (let i = 0; i < length; i++) {
      destinationArray[destinationIndex + i] = sourceArray[sourceIndex + i].clone();
    }
  }
  constructor(p, virtualPointCount) {
    this.data = [];
    this.ptCount = 0;
    if (p instanceof Array) {
      this.data = new Array(p.length);
      DataSummarySegment.ArrayCopy(p, 0, this.data, 0, p.length);
      this.ptCount = p.length;
    } else if (p instanceof pointsSummary) {
      this.data = new Array(DataSummarySegment.SegmentGranularity);
      this.data[0] = p;
      this.ptCount = 1;
    } else if (p == null) {
      this.data = new Array(DataSummarySegment.SegmentGranularity);
      this.ptCount = 0;
    }
  }
  grow() {
    let targetCount = this.data.length + DataSummarySegment.SegmentGranularity;
    while (this.data.length < targetCount) {
      this.data.push(null);
    }
  }
};
DataSummarySegment.SegmentGranularity = 1e3;
var DataSerie = class {
  get userData() {
    return this._userData;
  }
  set userData(value) {
    this._userData = value;
  }
  static get MaxPointsPerSeries() {
    return DataSerie._MaxPointsPerSeries;
  }
  static set MaxPointsPerSeries(value) {
    DataSerie._MaxPointsPerSeries = value;
  }
  get timeRange() {
    return this._timeRange;
  }
  get valueRange() {
    return this._valueRange;
  }
  constructor(parent) {
    this.totalPointCount = 0;
    this._userData = null;
    this._yAxisIndex = 0;
    this._pen = null;
    this._legendPen = null;
    this._brush = null;
    this._navigatorpen = null;
    this._visible = true;
    this._disabled = false;
    this._color = YColor.Black;
    this._thickness = 1;
    this._legend = "";
    this._unit = "";
    this.segments = [];
    this.summaries = null;
    if (parent.yAxes.length <= 0)
      throw new Error("Define at least one yAxis");
    this._timeRange = MinMaxHandler.DefaultValue();
    this._valueRange = MinMaxHandler.DefaultValue();
    this.parent = parent;
  }
  get yAxisIndex() {
    return this._yAxisIndex;
  }
  set yAxisIndex(value) {
    if (value >= this.parent.yAxes.length)
      throw new RangeError("No such yAxis (" + value.toString() + ")");
    this._yAxisIndex = value;
    this.parent.yAxes[this._yAxisIndex].AutoShow();
  }
  get pen() {
    if (this._pen == null) {
      this._pen = new YPen(this._color, this._thickness);
      this._pen.endCap = 2;
      this._pen.linejoin = YPen.LineJoin.Round;
    }
    return this._pen;
  }
  get legendPen() {
    if (this._legendPen == null) {
      this._legendPen = new YPen(this._color, this._thickness * this.parent.legendPanel.traceWidthFactor);
    }
    return this._legendPen;
  }
  resetlegendPen() {
    this._legendPen = null;
  }
  get brush() {
    if (this._brush == null)
      this._brush = new YSolidBrush(this._color);
    return this._brush;
  }
  get navigatorpen() {
    if (this._navigatorpen == null) {
      this._navigatorpen = new YPen(YColor.FromArgb(100, this._color.red, this._color.green, this._color.blue), 1);
    }
    return this._navigatorpen;
  }
  get visible() {
    return this._visible;
  }
  set visible(value) {
    this._visible = value;
    this.parent.redraw();
  }
  get disabled() {
    return this._disabled;
  }
  set disabled(value) {
    this._disabled = value;
    this.parent.redraw();
  }
  get color() {
    return this._color;
  }
  set color(value) {
    this._color = value;
    this._pen = null;
    this._legendPen = null;
    this._brush = null;
    this._navigatorpen = null;
    this.parent.redraw();
  }
  get thickness() {
    return this._thickness;
  }
  set thickness(value) {
    if (value < 0)
      throw new RangeError("Thickness must be a positive value");
    this._thickness = value;
    this._pen = null;
    this._legendPen = null;
    this.parent.redraw();
  }
  get legend() {
    return this._legend;
  }
  set legend(value) {
    this._legend = value;
    this.parent.redraw();
  }
  get unit() {
    return this._unit;
  }
  set unit(value) {
    this._unit = value;
    this.parent.redraw();
  }
  AddNewSegment(p) {
    this.segments.splice(0, 0, new DataSegment(p));
  }
  getlastPoint() {
    if (this.segments.length <= 0) {
      return new pointXY(NaN, NaN);
    }
    return this.segments[this.segments.length - 1].data[this.segments[this.segments.length - 1].count - 1];
  }
  handleSummary(p, delta) {
    if (this.summaries == null) {
      this.summaries = [];
      this.summaries.push(new Summary(0, this.summaries, SUMMARY_GRANULARITY));
    }
    if (this.summaries != null)
      this.summaries[0].addSequentialPoint(p, delta);
  }
  AddPoint(p) {
    this._timeRange = MinMaxHandler.CombineWithNumber(this._timeRange, p.x);
    this._valueRange = MinMaxHandler.CombineWithNumber(this._valueRange, p.y);
    let delta1 = -1;
    let delta2 = -1;
    if (this.segments.length <= 0) {
      this.AddNewSegment(p);
      this.totalPointCount++;
      if (SUMMARY_GRANULARITY > 0)
        this.handleSummary(p, delta1);
      return;
    } else if (this.segments[0].count > 1) {
      delta1 = this.segments[0].data[this.segments[0].count - 1].x - this.segments[0].data[this.segments[0].count - 2].x;
      delta2 = p.x - this.segments[0].data[this.segments[0].count - 1].x;
      if (delta2 > 0.1 && (delta2 < 0 || delta2 > 2 * delta1)) {
        this.AddNewSegment(p);
        if (SUMMARY_GRANULARITY > 0)
          this.handleSummary(p, delta1);
        return;
      }
    }
    if (SUMMARY_GRANULARITY > 0)
      this.handleSummary(p, delta1);
    this.segments[0].data[this.segments[0].count] = p;
    this.segments[0].count++;
    this.totalPointCount++;
    if (DataSerie._MaxPointsPerSeries > 0 && this.totalPointCount > DataSerie._MaxPointsPerSeries) {
      this.dataCleanUp();
      this.rebuildSummaries();
    }
    this.parent.adjustGlobalTimeRange(p.x);
    this.parent.redraw();
  }
  rebuildSummaries() {
    if (SUMMARY_GRANULARITY <= 0)
      return;
    this.summaries = [];
    this.summaries.push(new Summary(0, this.summaries, SUMMARY_GRANULARITY));
    this.summaries[0].processSegments(this.segments);
  }
  dumpSummaries() {
    if (this.summaries != null)
      for (let i = 0; i < this.summaries.length; i++)
        this.summaries[i].Dump();
    else
      console.log("****No summaries ****");
  }
  dataCleanUp() {
    if (this.segments.length <= 0)
      return;
    let newLimit = DataSerie._MaxPointsPerSeries * 90 / 100;
    while (this.segments[this.segments.length - 1].count <= this.totalPointCount - newLimit) {
      this.totalPointCount -= this.segments[this.segments.length - 1].count;
      this.segments.splice(this.segments.length - 1, 1);
    }
    if (this.totalPointCount > newLimit) {
      let delta = this.totalPointCount - newLimit;
      let newsize = this.segments[this.segments.length - 1].count - delta;
      let newdata = new Array(newsize);
      DataSegment.ArrayCopy(this.segments[this.segments.length - 1].data, delta, newdata, 0, this.segments[this.segments.length - 1].count - delta);
      this.segments[this.segments.length - 1].data = newdata;
      this.segments[this.segments.length - 1].count -= delta;
      this.totalPointCount -= delta;
    }
    let tmin = this.segments[0].data[0].x;
    let tmax = this.segments[0].data[0].x;
    let ymin = this.segments[0].data[0].y;
    let ymax = this.segments[0].data[0].y;
    for (let i = 0; i < this.segments.length; i++) {
      let count = this.segments[i].count;
      if (tmin > this.segments[i].data[0].x)
        tmin = this.segments[i].data[0].x;
      if (tmax < this.segments[i].data[count - 1].x)
        tmax = this.segments[i].data[count - 1].x;
      for (let j = 0; j < count; j++) {
        if (ymin > this.segments[i].data[j].y)
          ymin = this.segments[i].data[j].y;
        if (ymax < this.segments[i].data[j].y)
          ymax = this.segments[i].data[j].y;
      }
    }
    this._timeRange.Min = tmin;
    this._timeRange.Max = tmax;
    this._valueRange.Min = ymin;
    this._valueRange.Max = ymax;
  }
  InsertPoints(points) {
    if (points.length == 0)
      return;
    if (points.length == 1) {
      this._timeRange = MinMaxHandler.CombineWithNumber(this._timeRange, points[0].x);
      this._valueRange = MinMaxHandler.CombineWithNumber(this._valueRange, points[0].y);
      return;
    }
    let FirstStep = points[1].x - points[0].x;
    let LastStep = points[points.length - 1].x - points[points.length - 2].x;
    let InsertAtBegining = -1;
    let InsertAtEnd = -1;
    for (let i = 0; i < this.segments.length; i++) {
      if (this.segments[i].count > 1) {
        let DeltaInsertAtBegining = this.segments[i].data[0].x - points[points.length - 1].x;
        let DeltaInsertAtEnd = points[0].x - this.segments[i].data[this.segments[i].count - 1].x;
        if (DeltaInsertAtBegining > 0 && DeltaInsertAtBegining < 2 * FirstStep)
          InsertAtBegining = i;
        if (DeltaInsertAtEnd > 0 && DeltaInsertAtEnd < 2 * LastStep)
          InsertAtEnd = i;
      }
    }
    if (InsertAtBegining >= 0) {
      DataSegment.ArrayCopy(this.segments[InsertAtBegining].data, 0, this.segments[InsertAtBegining].data, points.length, this.segments[InsertAtBegining].count);
      DataSegment.ArrayCopy(points, 0, this.segments[InsertAtBegining].data, 0, points.length);
      this.segments[InsertAtBegining].count += points.length;
      this.totalPointCount += points.length;
    } else if (InsertAtEnd >= 0) {
      DataSegment.ArrayCopy(points, 0, this.segments[InsertAtEnd].data, this.segments[InsertAtEnd].count, points.length);
      this.segments[InsertAtEnd].count += points.length;
      this.totalPointCount += points.length;
    } else {
      let inserted = false;
      for (let i = 0; i < this.segments.length; i++) {
        if (this.segments[i].data[this.segments[i].data.length - 1].x < points[0].x && !inserted) {
          this.segments.splice(i, 0, new DataSegment(points));
          inserted = true;
        }
      }
      if (!inserted)
        this.segments.push(new DataSegment(points));
      this.totalPointCount += points.length;
    }
    this._timeRange = MinMaxHandler.CombineWithNumber(this._timeRange, points[0].x);
    this._timeRange = MinMaxHandler.CombineWithNumber(this._timeRange, points[points.length - 1].x);
    for (let i = 0; i < points.length; i++) {
      this._valueRange = MinMaxHandler.CombineWithNumber(this._valueRange, points[i].y);
    }
    if (DataSerie._MaxPointsPerSeries > 0 && this.totalPointCount > DataSerie._MaxPointsPerSeries)
      this.dataCleanUp();
    this.parent.redraw();
  }
  static CompareSegments(a, b) {
    if (a.data[0].x > b.data[0].x)
      return -1;
    if (a.data[0].x < b.data[0].x)
      return 1;
    return 0;
  }
  getData() {
    let res = [];
    this.segments.sort(DataSerie.CompareSegments);
    for (let i = this.segments.length - 1; i >= 0; i--) {
      for (let j = 0; j < this.segments[i].count; j++) {
        res.push(this.segments[i].data[j]);
      }
    }
    return res;
  }
  findClosestValue(x, AllowInterpolation) {
    let N1 = 0;
    let N2 = 0;
    let Pos = 0;
    if (this.segments.length <= 0)
      return null;
    for (let i = 0; i < this.segments.length; i++) {
      if (x >= this.segments[i].data[0].x && x <= this.segments[i].data[this.segments[i].count - 1].x) {
        let data = this.segments[i].data;
        N1 = 0;
        N2 = this.segments[i].count - 1;
        while (N2 - N1 > 1) {
          let N = N1 + N2 >> 1;
          if (data[N].x > x)
            N2 = N;
          else
            N1 = N;
        }
        Pos = N1 - 1;
        if (Pos < 0)
          Pos = 0;
        if (!AllowInterpolation) {
          if (x - data[Pos].x < data[Pos + 1].x - x)
            return data[Pos];
          else
            return data[Pos + 1];
        } else {
          Pos++;
          if (x == data[Pos].x)
            return data[Pos];
          if (x == data[Pos + 1].x)
            return data[Pos + 1];
          let p = new pointXY();
          p.x = x;
          p.y = data[Pos].y + (data[Pos + 1].y - data[Pos].y) * (x - data[Pos].x) / (data[Pos + 1].x - data[Pos].x);
          return p;
        }
      }
    }
    if (AllowInterpolation)
      return null;
    try {
      this.segments[0].data[0].clone();
    } catch (e) {
      debugger;
    }
    let match = this.segments[0].data[0];
    let delta = Math.abs(this.segments[0].data[0].x - x);
    for (let i = 0; i < this.segments.length; i++) {
      let d1 = Math.abs(this.segments[i].data[0].x - x);
      let d2 = Math.abs(this.segments[i].data[this.segments[i].count - 1].x - x);
      if (d1 < delta) {
        match = this.segments[i].data[0];
        delta = d1;
      }
      if (d2 < delta) {
        match = this.segments[i].data[this.segments[i].count - 1];
        delta = d2;
      }
    }
    return match.clone();
  }
  clear() {
    this.segments = [];
    this._timeRange = MinMaxHandler.DefaultValue();
    this._valueRange = MinMaxHandler.DefaultValue();
    this.parent.clearCachedObjects();
    this.totalPointCount = 0;
  }
};
DataSerie._MaxPointsPerSeries = 0;
var DataTracker = class {
  get directParent() {
    return this._directParent;
  }
  get userData() {
    return this._userData;
  }
  set userData(value) {
    this._userData = value;
  }
  constructor(parent, directParent) {
    this._userData = null;
    this._enabled = false;
    this._showSerieName = false;
    this._showTimeStamp = false;
    this._dataPrecisionString = "";
    this._dataPrecision = DataTracker.DataPrecision.PRECISION_NOLIMIT;
    this._diameter = 5;
    this._handleLength = 25;
    this._detectionDistance = 50;
    this._bgColor = YColor.FromArgb(200, 255, 255, 255);
    this._borderColor = YColor.Black;
    this._borderthickness = 1;
    this._padding = 10;
    this._verticalMargin = 10;
    this._horizontalMargin = 10;
    this._bgBrush = null;
    this._pen = null;
    this._font = null;
    this._directParent = directParent;
    this._parentRenderer = parent;
    this._font = new YFont(parent, this, 8, null);
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    this._enabled = value;
    this._parentRenderer.redraw();
  }
  get showSerieName() {
    return this._showSerieName;
  }
  set showSerieName(value) {
    this._showSerieName = value;
    this._parentRenderer.redraw();
  }
  get showTimeStamp() {
    return this._showTimeStamp;
  }
  set showTimeStamp(value) {
    this._showTimeStamp = value;
    this._parentRenderer.redraw();
  }
  get dataPrecisionString() {
    return this._dataPrecisionString;
  }
  get dataPrecision() {
    return this._dataPrecision;
  }
  set dataPrecision(value) {
    this._dataPrecision = value;
    this.compute_dataPrecisionString();
    this._parentRenderer.redraw();
  }
  compute_dataPrecisionString() {
    if (this._dataPrecision == DataTracker.DataPrecision.PRECISION_NOLIMIT) {
      this._dataPrecisionString = "";
      return;
    }
    this._dataPrecisionString = "0.";
  }
  get diameter() {
    return this._diameter;
  }
  set diameter(value) {
    if (value < 0)
      throw new RangeError("Diameter must be a positive value");
    this._diameter = value;
    this._parentRenderer.redraw();
  }
  get handleLength() {
    return this._handleLength;
  }
  set handleLength(value) {
    if (value < 0)
      throw new RangeError("Hanle length must be a positive value");
    this._handleLength = value;
    this._parentRenderer.redraw();
  }
  get detectionDistance() {
    return this._detectionDistance;
  }
  set detectionDistance(value) {
    if (value <= 0)
      throw new RangeError("Distance must be a positive value");
    this._detectionDistance = value;
  }
  get bgColor() {
    return this._bgColor;
  }
  set bgColor(value) {
    this._bgColor = value;
    this._bgBrush = null;
    this._parentRenderer.redraw();
  }
  get borderColor() {
    return this._borderColor;
  }
  set borderColor(value) {
    this._borderColor = value;
    this._pen = null;
    this._parentRenderer.redraw();
  }
  get borderthickness() {
    return this._borderthickness;
  }
  set borderthickness(value) {
    if (value < 0)
      throw new RangeError("Thickness must be a positive value");
    this._borderthickness = value;
    this._pen = null;
    this._parentRenderer.redraw();
  }
  get padding() {
    return this._padding;
  }
  set padding(value) {
    if (value < 0)
      throw new RangeError("Padding must be a positive value");
    this._padding = value;
    this._parentRenderer.redraw();
  }
  get verticalMargin() {
    return this._verticalMargin;
  }
  set verticalMargin(value) {
    if (value < 0)
      throw new RangeError("Margin must be a positive value");
    this._verticalMargin = value;
    this._parentRenderer.redraw();
  }
  get horizontalMargin() {
    return this._horizontalMargin;
  }
  set horizontalMargin(value) {
    if (value < 0)
      throw new RangeError("Margin must be a positive value");
    this._horizontalMargin = value;
    this._parentRenderer.redraw();
  }
  get bgBrush() {
    if (this._bgBrush == null) {
      this._bgBrush = new YSolidBrush(this._bgColor);
    }
    return this._bgBrush;
  }
  get pen() {
    if (this._pen == null)
      this._pen = new YPen(this._borderColor, this._borderthickness, true);
    return this._pen;
  }
  get font() {
    return this._font;
  }
};
(function(DataTracker2) {
  class DataPrecisionEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, DataPrecision);
    }
  }
  DataTracker2.DataPrecisionEnumItem = DataPrecisionEnumItem;
  class DataPrecision extends YEnum {
  }
  DataPrecision.PRECISION_NOLIMIT = new DataPrecisionEnumItem("PRECISION_NOLIMIT", "As is");
  DataPrecision.PRECISION_1 = new DataPrecisionEnumItem("PRECISION_1", "1");
  DataPrecision.PRECISION_01 = new DataPrecisionEnumItem("PRECISION_01", "0.1");
  DataPrecision.PRECISION_001 = new DataPrecisionEnumItem("PRECISION_001", "0.01");
  DataPrecision.PRECISION_0001 = new DataPrecisionEnumItem("PRECISION_0001", "0.001");
  DataPrecision.PRECISION_00001 = new DataPrecisionEnumItem("PRECISION_00001", "0.0001");
  DataPrecision.PRECISION_000001 = new DataPrecisionEnumItem("PRECISION_000001", "0.00001");
  DataPrecision.PRECISION_0000001 = new DataPrecisionEnumItem("PRECISION_0000001", "0.000001");
  DataPrecision.PRECISION_00000001 = new DataPrecisionEnumItem("PRECISION_00000001", "0.0000001");
  DataPrecision.PRECISION_000000001 = new DataPrecisionEnumItem("PRECISION_000000001", "0.00000001");
  DataPrecision.PRECISION_0000000001 = new DataPrecisionEnumItem("PRECISION_0000000001", "0.000000001");
  DataTracker2.DataPrecision = DataPrecision;
})(DataTracker || (DataTracker = {}));
var LegendPanel = class {
  get directParent() {
    return this._directParent;
  }
  get userData() {
    return this._userData;
  }
  set userData(value) {
    this._userData = value;
  }
  get traceWidthFactor() {
    return this._traceWidth;
  }
  set traceWidthFactor(value) {
    if (value <= 0)
      throw new RangeError("This has to be a strictly positive value");
    this._traceWidth = value;
    this._parentRenderer.resetlegendPens();
    this._parentRenderer.redraw();
  }
  constructor(parent, directParent) {
    this._userData = null;
    this._traceWidth = 1;
    this._enabled = false;
    this._position = LegendPanel.Position.BOTTOM;
    this._overlap = false;
    this._bgColor = YColor.FromArgb(200, 255, 255, 255);
    this._borderColor = YColor.Black;
    this._borderthickness = 1;
    this._padding = 10;
    this._verticalMargin = 10;
    this._horizontalMargin = 10;
    this._bgBrush = null;
    this._pen = null;
    this._font = null;
    this._directParent = directParent;
    this._parentRenderer = parent;
    this._font = new YFont(parent, this, 8, null);
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    this._enabled = value;
    this._parentRenderer.redraw();
  }
  get position() {
    return this._position;
  }
  set position(value) {
    this._position = value;
    this._parentRenderer.redraw();
  }
  get overlap() {
    return this._overlap;
  }
  set overlap(value) {
    this._overlap = value;
    this._parentRenderer.redraw();
  }
  get bgColor() {
    return this._bgColor;
  }
  set bgColor(value) {
    this._bgColor = value;
    this._bgBrush = null;
    this._parentRenderer.redraw();
  }
  get borderColor() {
    return this._borderColor;
  }
  set borderColor(value) {
    this._borderColor = value;
    this._pen = null;
    this._parentRenderer.redraw();
  }
  get borderthickness() {
    return this._borderthickness;
  }
  set borderthickness(value) {
    if (value < 0)
      throw new RangeError("Thickness must be a positive value");
    this._borderthickness = value;
    this._pen = null;
    this._parentRenderer.redraw();
  }
  get padding() {
    return this._padding;
  }
  set padding(value) {
    if (value < 0)
      throw new RangeError("Padding must be a positive value");
    this._padding = value;
    this._parentRenderer.redraw();
  }
  get verticalMargin() {
    return this._verticalMargin;
  }
  set verticalMargin(value) {
    if (value < 0)
      throw new RangeError("Margin must be a positive value");
    this._verticalMargin = value;
    this._parentRenderer.redraw();
  }
  get horizontalMargin() {
    return this._horizontalMargin;
  }
  set horizontalMargin(value) {
    if (value < 0)
      throw new RangeError("Margin must be a positive value");
    this._horizontalMargin = value;
    this._parentRenderer.redraw();
  }
  get bgBrush() {
    if (this._bgBrush == null) {
      this._bgBrush = new YSolidBrush(this._bgColor);
    }
    return this._bgBrush;
  }
  get pen() {
    if (this._pen == null)
      this._pen = new YPen(this._borderColor, this._borderthickness, true);
    return this._pen;
  }
  get font() {
    return this._font;
  }
};
(function(LegendPanel2) {
  class PositionEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, Position);
    }
  }
  LegendPanel2.PositionEnumItem = PositionEnumItem;
  class Position extends YEnum {
  }
  Position.LEFT = new PositionEnumItem("LEFT", "Left");
  Position.TOPLEFT = new PositionEnumItem("TOPLEFT", "Top-Left");
  Position.TOP = new PositionEnumItem("TOP", "Top");
  Position.TOPRIGHT = new PositionEnumItem("TOPRIGHT", "Top-Right");
  Position.RIGHT = new PositionEnumItem("RIGHT", "Right");
  Position.BOTTOMRIGHT = new PositionEnumItem("BOTTOMRIGHT", "Bottom-Right");
  Position.BOTTOM = new PositionEnumItem("BOTTOM", "Bottom");
  Position.BOTTOMLEFT = new PositionEnumItem("BOTTOMLEFT", "Bottom-Left");
  LegendPanel2.Position = Position;
})(LegendPanel || (LegendPanel = {}));
var Navigator = class {
  get directParent() {
    return this._directParent;
  }
  get userData() {
    return this._userData;
  }
  set userData(value) {
    this._userData = value;
  }
  get showXAxisZones() {
    return this._showXAxisZones;
  }
  set showXAxisZones(value) {
    this._showXAxisZones = value;
  }
  get relativeheight() {
    return this._relativeheight;
  }
  set relativeheight(value) {
    if (value < 10)
      value = 10;
    if (value > 50)
      value = 50;
    this._relativeheight = value;
    this._parentRenderer.redraw();
  }
  constructor(parent, directParent) {
    this._userData = null;
    this._viewport = new ViewPortSettings();
    this.Xrange = null;
    this._showXAxisZones = true;
    this._relativeheight = 10;
    this._enabled = false;
    this._bgColor1 = YColor.FromArgb(255, 225, 225, 225);
    this._cursorBorderColor = YColor.FromArgb(255, 40, 40, 40);
    this._yAxisHandling = Navigator.YAxisHandling.AUTO;
    this._bgColor2 = YColor.FromArgb(255, 225, 225, 225);
    this._cursorColor = YColor.FromArgb(100, 0, 255, 0);
    this._cursorBrush = null;
    this._pen = null;
    this._cursorBorderPen = null;
    this._xAxisColor = YColor.Black;
    this._xAxisThickness = 1;
    this._borderPen = null;
    this._borderColor = YColor.DimGray;
    this._borderThickness = 1;
    this._bgBrush = null;
    this._font = null;
    this._directParent = directParent;
    this._parentRenderer = parent;
    this._font = new YFont(parent, this, 8, null);
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    this._enabled = value;
    this._parentRenderer.redraw();
  }
  get bgColor1() {
    return this._bgColor1;
  }
  set bgColor1(value) {
    this._bgColor1 = value;
    this._bgBrush = null;
    this._parentRenderer.redraw();
  }
  get cursorBorderColor() {
    return this._cursorBorderColor;
  }
  set cursorBorderColor(value) {
    this._cursorBorderColor = value;
    this._cursorBorderPen = null;
    this._parentRenderer.redraw();
  }
  get yAxisHandling() {
    return this._yAxisHandling;
  }
  set yAxisHandling(value) {
    this._yAxisHandling = value;
    this._parentRenderer.redraw();
  }
  get bgColor2() {
    return this._bgColor2;
  }
  set bgColor2(value) {
    this._bgColor2 = value;
    this._bgBrush = null;
    this._parentRenderer.redraw();
  }
  get cursorColor() {
    return this._cursorColor;
  }
  set cursorColor(value) {
    this._cursorColor = value;
    this._cursorBrush = null;
    this._parentRenderer.redraw();
  }
  get cursorBrush() {
    if (this._cursorBrush == null) {
      this._cursorBrush = new YSolidBrush(this._cursorColor);
    }
    return this._cursorBrush;
  }
  get pen() {
    if (this._pen == null)
      this._pen = new YPen(this._xAxisColor, this._xAxisThickness, true);
    return this._pen;
  }
  get cursorBorderPen() {
    if (this._cursorBorderPen == null)
      this._cursorBorderPen = new YPen(this._cursorBorderColor, 1, true);
    return this._cursorBorderPen;
  }
  get xAxisColor() {
    return this._xAxisColor;
  }
  set xAxisColor(value) {
    this._xAxisColor = value;
    this._pen = null;
    this._parentRenderer.redraw();
  }
  get xAxisThickness() {
    return this._xAxisThickness;
  }
  set xAxisThickness(value) {
    if (value < 0)
      throw new RangeError("Thickness must be a positive value");
    this._xAxisThickness = value;
    this._pen = null;
    this._parentRenderer.redraw();
  }
  get borderPen() {
    if (this._borderPen == null)
      this._borderPen = new YPen(this._borderColor, this._borderThickness, true);
    return this._borderPen;
  }
  get borderColor() {
    return this._borderColor;
  }
  set borderColor(value) {
    this._borderColor = value;
    this._borderPen = null;
    this._parentRenderer.redraw();
  }
  get borderThickness() {
    return this._borderThickness;
  }
  set borderThickness(value) {
    if (value < 0)
      throw new RangeError("Thickness must be a positive value");
    this._borderThickness = value;
    this._borderPen = null;
    this._parentRenderer.redraw();
  }
  setPosition(ParentWidth, ParentHeight, Lmargin, Rmargin, Tmargin, Bmargin) {
    if (this._viewport.Lmargin != Lmargin || this._viewport.Rmargin != Rmargin || this._viewport.Tmargin != Tmargin || this._viewport.Bmargin != Bmargin) {
      this._bgBrush = null;
    }
    this._viewport.Lmargin = Lmargin;
    this._viewport.Rmargin = Rmargin;
    this._viewport.Bmargin = Bmargin;
    this._viewport.Tmargin = Tmargin;
    this._viewport.Width = ParentWidth;
    this._viewport.Height = ParentHeight;
  }
  setIRLPosition(IRLx, IRLy, xZoom, yZoom) {
    this._viewport.IRLx = IRLx;
    this._viewport.IRLy = IRLy;
    this._viewport.zoomx = xZoom;
    this._viewport.zoomy = yZoom;
  }
  startCapture(IRLStartPoint, xAxisMin, xAxisMax) {
    this._viewport.OriginalXAxisMin = xAxisMin;
    this._viewport.OriginalXAxisMax = xAxisMax;
    this._viewport.OriginalIRLx = this._viewport.IRLx;
    this._viewport.OriginalLmargin = this._viewport.Lmargin;
    this._viewport.OriginalZoomx = this._viewport.zoomx;
    this._viewport.IRLCaptureStartX = IRLStartPoint.x;
    this._viewport.Capture = true;
  }
  get Capture() {
    return this._viewport.Capture;
  }
  stopCapture() {
    this._viewport.Capture = false;
  }
  get viewport() {
    return this._viewport;
  }
  get bgBrush() {
    if (this._bgBrush == null) {
      this._bgBrush = new YLinearGradientBrush(this._bgColor1, this._bgColor2);
    }
    return this._bgBrush;
  }
  get font() {
    return this._font;
  }
};
(function(Navigator2) {
  class YAxisHandlingEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, YAxisHandling);
    }
  }
  Navigator2.YAxisHandlingEnumItem = YAxisHandlingEnumItem;
  class YAxisHandling extends YEnum {
  }
  YAxisHandling.AUTO = new YAxisHandlingEnumItem("AUTO", "Automatic");
  YAxisHandling.INHERIT = new YAxisHandlingEnumItem("INHERIT", "Inherit from main view");
  Navigator2.YAxisHandling = YAxisHandling;
})(Navigator || (Navigator = {}));
var Marker = class {
  get userData() {
    return this._userData;
  }
  set userData(value) {
    this._userData = value;
  }
  static _round100(v) {
    return Math.round(100 * v) / 100;
  }
  get stringFormat() {
    if (this._stringFormat != null)
      return this._stringFormat;
    this._stringFormat = new YStringFormat(16384);
    this._stringFormat.LineAlignment = 1;
    switch (this._textAlign) {
      case Marker.TextAlign.LEFT:
        this._stringFormat.Alignment = 0;
        break;
      case Marker.TextAlign.CENTER:
        this._stringFormat.Alignment = 1;
        break;
      case Marker.TextAlign.RIGHT:
        this._stringFormat.Alignment = 2;
        break;
    }
    return this._stringFormat;
  }
  get PatchTextCallback() {
    return this._MarkerTextCallback;
  }
  set PatchTextCallback(callback) {
    this._MarkerTextCallback = callback;
  }
  get directParent() {
    return this._directParent;
  }
  constructor(parent, directParent) {
    this._userData = null;
    this._stringFormat = null;
    this._MarkerTextCallback = null;
    this._enabled = false;
    this._xposition = 0;
    this._xpositionIsRelative = false;
    this._yposition = 92;
    this._text = "Marker";
    this._textAlign = Marker.TextAlign.CENTER;
    this._bgColor = YColor.FromArgb(255, 255, 255, 192);
    this._borderColor = YColor.DarkRed;
    this._borderthickness = 1;
    this._arrowSize = 5;
    this._padding = 5;
    this._verticalMargin = 5;
    this._horizontalMargin = 5;
    this._bgBrush = null;
    this._arrowBrush = null;
    this._pen = null;
    this._navigatorpen = null;
    this._font = null;
    this._directParent = directParent;
    this._parentRenderer = parent;
    this._font = new YFont(parent, this, 8, null);
  }
  startCapture() {
    this._parentRenderer.startMarkerCapture(this);
  }
  setCapturedPosition(position, axis) {
    this.enabled = true;
    this._xpositionIsRelative = axis.timeReference == TimeConverter.TimeReference.RELATIVE && axis.zeroTime > 0;
    this._xposition = Marker._round100(this._xpositionIsRelative ? position - axis.zeroTime : position);
    this._parentRenderer.clearCachedObjects();
    this._parentRenderer.redraw();
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    if (this._enabled != value) {
      this._enabled = value;
      this._parentRenderer.clearCachedObjects();
      this._parentRenderer.redraw();
    }
  }
  get xposition() {
    return this._xposition;
  }
  set xposition(value) {
    this._xposition = Marker._round100(value);
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get timereference() {
    return this._xpositionIsRelative ? TimeConverter.TimeReference.RELATIVE : TimeConverter.TimeReference.ABSOLUTE;
  }
  set timereference(value) {
    let v = value == TimeConverter.TimeReference.RELATIVE;
    if (this._xpositionIsRelative != v) {
      let ZeroPosition = this._directParent.zeroTime;
      if (isNaN(ZeroPosition))
        ZeroPosition = 0;
      if (v) {
        this._xpositionIsRelative = true;
        this._xposition -= ZeroPosition;
      } else {
        this._xpositionIsRelative = false;
        this._xposition += ZeroPosition;
      }
      this._xposition = Marker._round100(this._xposition);
      this._parentRenderer.redraw();
    }
  }
  get positionOnXAxis() {
    return new xAxisPosition(this._xposition, this._xpositionIsRelative);
  }
  set positionOnXAxis(value) {
    if (value.capture) {
      this.startCapture();
    } else {
      let v = Marker._round100(value.value);
      if (this._xpositionIsRelative != value.relative || this._xposition != v) {
        this._xposition = v;
        this._xpositionIsRelative = value.relative;
        if (this._enabled)
          this._parentRenderer.redraw();
      }
    }
  }
  get yposition() {
    return this._yposition;
  }
  set yposition(value) {
    this._yposition = Math.min(100, Math.max(0, value));
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get text() {
    return this._text;
  }
  set text(value) {
    this._text = value;
    this._parentRenderer.clearCachedObjects();
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get textAlign() {
    return this._textAlign;
  }
  set textAlign(value) {
    this._textAlign = value;
    this._stringFormat = null;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get shortText() {
    if (this._text.length <= 20)
      return this._text;
    return this._text.substring(0, 18) + "..";
  }
  get bgColor() {
    return this._bgColor;
  }
  set bgColor(value) {
    this._bgColor = value;
    this._bgBrush = null;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get borderColor() {
    return this._borderColor;
  }
  set borderColor(value) {
    this._borderColor = value;
    this._arrowBrush = null;
    this._pen = null;
    this._navigatorpen = null;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get borderthickness() {
    return this._borderthickness;
  }
  set borderthickness(value) {
    if (value < 0)
      throw new RangeError("thickness must be a positive value");
    this._borderthickness = value;
    this._parentRenderer.clearCachedObjects();
    this._pen = null;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get arrowSize() {
    return this._arrowSize;
  }
  set arrowSize(value) {
    this._arrowSize = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get padding() {
    return this._padding;
  }
  set padding(value) {
    if (value < 0)
      throw new RangeError("Padding must be a positive value");
    this._padding = value;
    this._parentRenderer.clearCachedObjects();
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get verticalMargin() {
    return this._verticalMargin;
  }
  set verticalMargin(value) {
    this._verticalMargin = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get horizontalMargin() {
    return this._horizontalMargin;
  }
  set horizontalMargin(value) {
    this._horizontalMargin = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get bgBrush() {
    if (this._bgBrush == null) {
      this._bgBrush = new YSolidBrush(this._bgColor);
    }
    return this._bgBrush;
  }
  get arrowBrush() {
    if (this._arrowBrush == null) {
      this._arrowBrush = new YSolidBrush(this._borderColor, true);
    }
    return this._arrowBrush;
  }
  get pen() {
    if (this._pen == null)
      this._pen = new YPen(this._borderColor, this._borderthickness, true);
    return this._pen;
  }
  get navigatorpen() {
    if (this._navigatorpen == null)
      this._navigatorpen = new YPen(this._borderColor, 1);
    return this._navigatorpen;
  }
  get font() {
    return this._font;
  }
};
(function(Marker2) {
  class TextAlignEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, TextAlign);
    }
  }
  Marker2.TextAlignEnumItem = TextAlignEnumItem;
  class TextAlign extends YEnum {
  }
  TextAlign.LEFT = new TextAlignEnumItem("LEFT", "Left");
  TextAlign.CENTER = new TextAlignEnumItem("CENTER", "Center");
  TextAlign.RIGHT = new TextAlignEnumItem("RIGHT", "Right");
  Marker2.TextAlign = TextAlign;
})(Marker || (Marker = {}));
var Legend = class {
  get directParent() {
    return this._directParent;
  }
  get userData() {
    return this._userData;
  }
  set userData(value) {
    this._userData = value;
  }
  constructor(parent, directParent) {
    this._userData = null;
    this._title = "";
    this._font = null;
    this._directParent = directParent;
    this._parentRenderer = parent;
    this._font = new YFont(parent, this, 12, null);
  }
  get title() {
    return this._title;
  }
  set title(value) {
    this._title = value;
    this._parentRenderer.redraw();
  }
  get font() {
    return this._font;
  }
};
var GenericAxis = class {
  get directParent() {
    return this._directParent;
  }
  get zones() {
    return this._zones;
  }
  AddZone() {
    let z = new Zone(this._parentRenderer, this);
    this._zones.push(z);
    return z;
  }
  get userData() {
    return this._userData;
  }
  set userData(value) {
    this._userData = value;
  }
  get AxisChanged() {
    return this._AxisChanged;
  }
  set AxisChanged(value) {
    this._AxisChanged = value;
  }
  constructor(parent, directParent) {
    this._userData = null;
    this._AxisChanged = null;
    this._pen = null;
    this._gridPen = null;
    this._visible = true;
    this._AllowAutoShow = false;
    this._min = Number.NaN;
    this._max = Number.NaN;
    this._step = Number.NaN;
    this._thickness = 1;
    this._color = YColor.Black;
    this._showGrid = false;
    this._gridColor = YColor.FromArgb(50, 0, 0, 0);
    this._gridThickness = 1;
    this._font = null;
    this._zones = [];
    this._directParent = directParent;
    this._parentRenderer = parent;
    this._legend = new Legend(parent, this);
    this._font = new YFont(parent, this);
  }
  get pen() {
    if (this._pen == null)
      this._pen = new YPen(this._color, this._thickness, true);
    return this._pen;
  }
  get gridPen() {
    if (this._gridPen == null)
      this._gridPen = new YPen(this._gridColor, this._gridThickness, true);
    return this._gridPen;
  }
  get visible() {
    return this._visible;
  }
  set visible(value) {
    this._visible = value;
    if (!value) {
      this._AllowAutoShow = false;
    }
    this._parentRenderer.redraw();
  }
  get AllowAutoShow() {
    return this._AllowAutoShow;
  }
  set AllowAutoShow(value) {
    this._AllowAutoShow = value;
  }
  AutoShow() {
    if (this._AllowAutoShow) {
      this.visible = true;
      if (this._AxisChanged != null)
        this._AxisChanged(this);
    }
  }
  set_minMax(value_min, value_max) {
    if (!isNaN(value_min) && !isNaN(value_max) && value_min >= value_max) {
      throw new RangeError("Min (" + value_min.toString() + ") cannot be greater than max (" + value_max.toString() + ")");
    }
    this._min = value_min;
    this._max = value_max;
    this._parentRenderer.redraw();
  }
  get min() {
    return this._min;
  }
  set min(value) {
    if (!isNaN(value) && !isNaN(this._max) && !YDataRenderer.minMaxCheckDisabled) {
      if (value >= this._max) {
        throw new RangeError("Min cannot be greater than max (" + this._max.toString() + ")");
      }
    }
    this._min = value;
    this._parentRenderer.redraw();
  }
  setMinMax(min, max) {
    if (min < max) {
      this._min = min;
      this._max = max;
      this._parentRenderer.redraw();
    }
  }
  get max() {
    return this._max;
  }
  set max(value) {
    if (!isNaN(value) && !isNaN(this._min) && !YDataRenderer.minMaxCheckDisabled) {
      if (value <= this._min)
        throw new RangeError("Max cannot be less than min (" + this._min.toString() + ")");
    }
    this._max = value;
    this._parentRenderer.redraw();
  }
  get step() {
    return this._step;
  }
  set step(value) {
    if (!isNaN(value) && value < 0)
      throw new RangeError("Steps must be a strictely positive value");
    this._step = value;
    this._parentRenderer.redraw();
  }
  get thickness() {
    return this._thickness;
  }
  set thickness(value) {
    if (value < 0)
      throw new RangeError("Thickness must be a positive value");
    this._thickness = value;
    this._pen = null;
    this._parentRenderer.redraw();
  }
  get color() {
    return this._color;
  }
  set color(value) {
    this._color = value;
    this._pen = null;
    this._parentRenderer.redraw();
  }
  get showGrid() {
    return this._showGrid;
  }
  set showGrid(value) {
    this._showGrid = value;
    this._parentRenderer.redraw();
  }
  get gridColor() {
    return this._gridColor;
  }
  set gridColor(value) {
    this._gridColor = value;
    this._gridPen = null;
    this._parentRenderer.redraw();
  }
  get gridThickness() {
    return this._gridThickness;
  }
  set gridThickness(value) {
    if (value < 0)
      throw new RangeError("Thickness must be a positive value");
    this._gridThickness = value;
    this._gridPen = null;
    this._parentRenderer.redraw();
  }
  get font() {
    return this._font;
  }
  get legend() {
    return this._legend;
  }
};
var StartStopStep = class {
  constructor() {
    this.dataMin = 0;
    this.dataMax = 0;
    this.absMin = 0;
    this.absMax = 0;
    this.step = 0;
    this.start = 0;
    this.stop = 0;
    this.precision = 0;
  }
};
var xAxisPosition = class {
  get relative() {
    return this._isRelative;
  }
  set relative(value) {
    this._isRelative = value;
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value;
  }
  constructor(v, rel, capture) {
    this._isRelative = false;
    this._value = 0;
    this._capture = false;
    this._isRelative = rel;
    this._value = v;
    this._capture = typeof capture == "undefined" ? false : capture;
  }
  clone() {
    return new xAxisPosition(this._value, this._isRelative, this._capture);
  }
  toString() {
    if (this._isRelative) {
      return TimeConverter.secTimeSpanToString(this._value, 0);
    } else {
      let date = TimeConverter.FromUnixTime(this._value);
      let res = date.getFullYear().toString() + "-" + (date.getMonth() + 1).toString() + "-" + date.getDate().toString() + " " + date.getHours().toString() + ":";
      let st = date.getMinutes().toString();
      if (st.length <= 1)
        st = "0" + st;
      res = res + st + ":";
      let s = date.getSeconds();
      let ms = date.getMilliseconds();
      s = s + ms / 1e3;
      if (s < 10)
        res = res + "0";
      if (ms == 0) {
        res = res + s.toString();
      } else {
        res = res + s.toFixed(3);
      }
      return res;
    }
  }
  TryParse(str) {
    if (this._isRelative)
      return TimeConverter.tryParseStringToSecTimeSpan(str);
    return TimeConverter.tryParseStringToAbsDateTime(str);
  }
  get capture() {
    return this._capture;
  }
  set capture(value) {
    this._capture = value;
  }
};
xAxisPosition.DTdisplayformat = "DD/MM/YY hh:mm:ss.ff";
xAxisPosition.TSdisplayformat = "dd.hh:mm:ss.ff";
var YNumberFormatInfo = class {
  constructor() {
    this.NumberDecimalSeparator = ".";
  }
};
var YAxis = class extends GenericAxis {
  constructor(parent, directParent, index) {
    super(parent, directParent);
    this._index = 0;
    this._highlightZero = false;
    this._position = YAxis.HrzPosition.LEFT;
    this.innerWidth = 0;
    this.zoom = 0;
    this.IRLy = 0;
    this._index = index;
    this.nfi = new YNumberFormatInfo();
    this.nfi.NumberDecimalSeparator = ".";
    this.startStopStep = new StartStopStep();
    this.startStopStep.start = 0;
    this.startStopStep.stop = 1;
    this.startStopStep.step = 0.1;
  }
  get index() {
    return this._index;
  }
  lockMinMax() {
    this._min = this.startStopStep.absMin;
    this._max = this.startStopStep.absMax;
    this._parentRenderer.redraw();
  }
  unlockMinMax() {
    this._min = Number.NaN;
    this._max = Number.NaN;
    this._parentRenderer.redraw();
  }
  get highlightZero() {
    return this._highlightZero;
  }
  set highlightZero(value) {
    this._highlightZero = value;
    this._parentRenderer.redraw();
  }
  get position() {
    return this._position;
  }
  set position(value) {
    this._position = value;
    this._parentRenderer.redraw();
  }
  computeStartAndStep(M) {
    let res = new StartStopStep();
    let min = this.min;
    let max = this.max;
    res.step = this.step;
    res.precision = 0;
    if (!MinMaxHandler.isDefined(M)) {
      M = MinMaxHandler.DefaultValue();
      M.Min = 0;
      M.Max = 100;
    }
    if (isNaN(min))
      min = M.Min;
    if (isNaN(max))
      max = M.Max;
    res.absMax = max;
    res.absMin = min;
    if (min == max) {
      min -= 0.5;
      max += 0.5;
    }
    if (min != 0)
      min -= (max - min) * 0.025;
    if (max != 0)
      max += (max - min) * 0.025;
    res.start = min;
    res.stop = max;
    res.dataMin = min;
    res.dataMax = max;
    let Delta = max - min;
    if (isNaN(res.step)) {
      let MagnitudePwr = Math.log10(Delta);
      if (MagnitudePwr - Math.floor(MagnitudePwr) != 0)
        MagnitudePwr = Math.floor(MagnitudePwr) + 1;
      res.precision = MagnitudePwr - 1 >> 0;
      let Magnitude = Math.pow(10, res.precision);
      let C = Delta / Magnitude;
      if (C <= 2) {
        res.step = Magnitude / 5;
        res.precision--;
      } else if (C <= 5) {
        res.step = Magnitude / 2;
        res.precision--;
      } else {
        res.step = Magnitude;
      }
      if (isNaN(this.min)) {
        let c = min / res.step;
        if (c - Math.floor(c) != 0)
          c = c > 0 ? Math.floor(c) + 1 : Math.floor(c) - 1;
        res.start = res.step * c;
      }
    } else {
      let v = res.step.toString();
      let p = v.indexOf(".");
      if (p >= 0) {
        res.precision = -(v.length - p - 1);
      } else {
        res.precision = 0;
      }
    }
    this.startStopStep = res;
    return res;
  }
};
(function(YAxis2) {
  class HrzPositionEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, HrzPosition);
    }
  }
  YAxis2.HrzPositionEnumItem = HrzPositionEnumItem;
  class HrzPosition extends YEnum {
  }
  HrzPosition.LEFT = new HrzPositionEnumItem("LEFT", "Left");
  HrzPosition.RIGHT = new HrzPositionEnumItem("RIGHT", "Right");
  YAxis2.HrzPosition = HrzPosition;
})(YAxis || (YAxis = {}));
var XAxis = class extends GenericAxis {
  get position() {
    return this._position;
  }
  set position(value) {
    this._position = value;
    this._parentRenderer.redraw();
  }
  get markers() {
    return this._markers;
  }
  AddMarker() {
    let m = new Marker(this._parentGraph, this);
    this._markers.push(m);
    this._parentGraph.clearCachedObjects();
    this._parentGraph.redraw();
    return m;
  }
  get initialZoom() {
    return this._initialZoom;
  }
  set initialZoom(value) {
    if (value <= 0)
      throw new RangeError("Zoom must be a positive value");
    this._initialZoom = value;
    this.min = this.min - this._initialZoom * this._initialOffset / 100;
    this.max = this.min + this.initialZoom;
    this._parentRenderer.redraw();
  }
  get initialOffset() {
    return this._initialOffset;
  }
  set initialOffset(value) {
    this._initialOffset = value;
    let p = this._parentGraph.getMostRecentPoint();
    if (isNaN(p.x)) {
      this._min = this._min - this._initialZoom * this._initialOffset / 100;
      this._max = this._min + this._initialZoom;
      this._parentRenderer.redraw();
    } else {
      let zoom = this._max - this._min;
      this._min = p.x - zoom * this._initialOffset / 100;
      this._max = this._min + zoom;
    }
    this._parentRenderer.redraw();
  }
  get labelFormat() {
    return this._format;
  }
  set labelFormat(value) {
    this._format = value;
    this._parentRenderer.redraw();
  }
  constructor(parent, directParent) {
    super(parent, directParent);
    this._position = XAxis.VrtPosition.BOTTOM;
    this._markers = [];
    this._initialZoom = 300;
    this._initialOffset = 0;
    this._format = XAxis.FORMATAUTO;
    this._timeReference = TimeConverter.TimeReference.ABSOLUTE;
    this._zeroTime = 0;
    this._fullSize = 0;
    this.innerHeight = 0;
    this._overflowHandling = XAxis.OverflowHandling.DONOTHING;
    this._parentGraph = parent;
    this._markers = [];
    this.min = TimeConverter.ToUnixTime(TimeConverter.UTCNow());
    this.max = this.min + this.initialZoom;
    this.step = 30;
  }
  get timeReference() {
    return this._timeReference;
  }
  set timeReference(value) {
    this._timeReference = value;
    this._parentRenderer.redraw();
  }
  get zeroTime() {
    return this._zeroTime;
  }
  set zeroTime(value) {
    this._zeroTime = value;
  }
  get fullSize() {
    return this._fullSize;
  }
  set fullSize(value) {
    this._fullSize = value;
  }
  bestFormat(dataTimedelta, viewportTimedelta) {
    return TimeConverter.BestTimeformat(dataTimedelta, viewportTimedelta, this._timeReference);
  }
  get overflowHandling() {
    return this._overflowHandling;
  }
  set overflowHandling(value) {
    this._overflowHandling = value;
  }
};
XAxis.FORMATAUTO = 0;
(function(XAxis2) {
  class VrtPositionEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, VrtPosition);
    }
  }
  XAxis2.VrtPositionEnumItem = VrtPositionEnumItem;
  class VrtPosition extends YEnum {
  }
  VrtPosition.TOP = new VrtPositionEnumItem("TOP", "Top");
  VrtPosition.BOTTOM = new VrtPositionEnumItem("BOTTOM", "Bottom");
  XAxis2.VrtPosition = VrtPosition;
  class OverflowHandlingEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, OverflowHandling);
    }
  }
  XAxis2.OverflowHandlingEnumItem = OverflowHandlingEnumItem;
  class OverflowHandling extends YEnum {
  }
  OverflowHandling.DONOTHING = new OverflowHandlingEnumItem("DONOTHING", "Do nothing");
  OverflowHandling.SCROLL = new OverflowHandlingEnumItem("SCROLL", "Scroll contents");
  OverflowHandling.CONTRACT = new OverflowHandlingEnumItem("CONTRACT", "Squeeze contents");
  XAxis2.OverflowHandling = OverflowHandling;
})(XAxis || (XAxis = {}));
var DataPanel = class extends GenericPanel {
  constructor(parent, directParent) {
    super(parent, directParent);
    this._panelHrzAlign = DataPanel.HorizontalAlign.CENTERED;
    this._panelVrtAlign = DataPanel.VerticalAlign.CENTERED;
    this._horizontalPosition = DataPanel.HorizontalPosition.ABSOLUTEX;
    this._verticalPosition = DataPanel.VerticalPosition.ABSOLUTEY;
    this._AbsoluteXposition = 0;
    this._AbsoluteYposition = 0;
    this._YScaleIndex = 0;
  }
  get panelHrzAlign() {
    return this._panelHrzAlign;
  }
  set panelHrzAlign(value) {
    this._panelHrzAlign = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get panelVrtAlign() {
    return this._panelVrtAlign;
  }
  set panelVrtAlign(value) {
    this._panelVrtAlign = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get horizontalPosition() {
    return this._horizontalPosition;
  }
  set horizontalPosition(value) {
    this._horizontalPosition = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get verticalPosition() {
    return this._verticalPosition;
  }
  set verticalPosition(value) {
    this._verticalPosition = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get AbsoluteXposition() {
    return this._AbsoluteXposition;
  }
  set AbsoluteXposition(value) {
    this._AbsoluteXposition = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get AbsoluteYposition() {
    return this._AbsoluteYposition;
  }
  set AbsoluteYposition(value) {
    this._AbsoluteYposition = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get yScaleIndex() {
    return this._YScaleIndex;
  }
  set yScaleIndex(value) {
    this._YScaleIndex = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
};
(function(DataPanel2) {
  class HorizontalAlignEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, HorizontalAlign);
    }
  }
  DataPanel2.HorizontalAlignEnumItem = HorizontalAlignEnumItem;
  class HorizontalAlign extends YEnum {
  }
  HorizontalAlign.LEFTOF = new HorizontalAlignEnumItem("LEFTOF", "Left");
  HorizontalAlign.CENTERED = new HorizontalAlignEnumItem("CENTERED", "Center");
  HorizontalAlign.RIGHTOF = new HorizontalAlignEnumItem("RIGHTOF", "Right");
  DataPanel2.HorizontalAlign = HorizontalAlign;
  class VerticalAlignEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, VerticalAlign);
    }
  }
  DataPanel2.VerticalAlignEnumItem = VerticalAlignEnumItem;
  class VerticalAlign extends YEnum {
  }
  VerticalAlign.ABOVE = new VerticalAlignEnumItem("ABOVE", "Top");
  VerticalAlign.CENTERED = new VerticalAlignEnumItem("CENTERED", "Center");
  VerticalAlign.BELOW = new VerticalAlignEnumItem("BELOW", "Bottom");
  DataPanel2.VerticalAlign = VerticalAlign;
  class HorizontalPositionEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, HorizontalPosition);
    }
  }
  DataPanel2.HorizontalPositionEnumItem = HorizontalPositionEnumItem;
  class HorizontalPosition extends YEnum {
  }
  HorizontalPosition.LEFTBORDER = new HorizontalPositionEnumItem("LEFTBORDER", "Left border");
  HorizontalPosition.ABSOLUTEX = new HorizontalPositionEnumItem("ABSOLUTEX", "Absolute X position");
  HorizontalPosition.RIGHTBORDER = new HorizontalPositionEnumItem("RIGHTBORDER", "Right borde");
  DataPanel2.HorizontalPosition = HorizontalPosition;
  class VerticalPositionEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, VerticalPosition);
    }
  }
  DataPanel2.VerticalPositionEnumItem = VerticalPositionEnumItem;
  class VerticalPosition extends YEnum {
  }
  VerticalPosition.TOPBORDER = new VerticalPositionEnumItem("TOPBORDER", "Top border");
  VerticalPosition.ABSOLUTEY = new VerticalPositionEnumItem("ABSOLUTEY", "Absolute Y position");
  VerticalPosition.BOTTOMBORDER = new VerticalPositionEnumItem("BOTTOMBORDER", "Bottom border");
  DataPanel2.VerticalPosition = VerticalPosition;
})(DataPanel || (DataPanel = {}));
var YCursor = class {
  constructor(pngImageData) {
  }
  get handle() {
    return "crosshair";
  }
};
var YTimeSpan = class {
  constructor(value) {
    this._value = 0;
    this._value = value;
  }
  toString(format) {
    let res = "";
    let v = Math.abs(this._value / 1e3);
    let dec = Math.floor(v);
    let frac = Math.round(1e3 * (v - Math.floor(v)));
    if (format & YDate.ms1) {
      let ms = "00" + frac.toString();
      res = "." + ms.substring(ms.length - 3).substring(0, 1);
    } else if (format & YDate.ms01) {
      let ms = "00" + frac.toString();
      res = "." + ms.substring(ms.length - 3).substring(0, 2);
    } else if (format & YDate.ms001) {
      let ms = "00" + frac.toString();
      res = "." + ms.substring(ms.length - 3).substring(0, 3);
    }
    if (format & YDate.s) {
      let sec = dec % 60;
      let s = "0" + sec.toString();
      res = s.substring(s.length - 2) + res + "s";
    }
    dec = Math.floor(dec / 60);
    if (format & YDate.m) {
      let min = dec % 60;
      let s = "0" + min.toString();
      res = s.substring(s.length - 2) + "m" + res;
    }
    dec = Math.floor(dec / 60);
    if (format & YDate.h) {
      let hrs = dec % 24;
      let s = "0" + hrs.toString();
      res = s.substring(s.length - 2) + "h" + res;
    }
    dec = Math.floor(dec / 24);
    if (format & YDate.D) {
      let s = dec.toString();
      res = s.substring(s.length - 2) + "d" + res;
    }
    return res;
  }
};
YTimeSpan.TicksPerSecond = 1e3;
var YGraph = class extends YDataRenderer {
  get legendPanel() {
    return this._legendPanel;
  }
  get dataTracker() {
    return this._dataTracker;
  }
  get borderColor() {
    return this._borderColor;
  }
  set borderColor(value) {
    this._borderColor = value;
    this._borderPen = null;
    this.redraw();
  }
  get borderThickness() {
    return this._borderThickness;
  }
  set borderThickness(value) {
    if (value < 0)
      throw new RangeError("thickness must be a positive value");
    this._borderThickness = value;
    this._borderPen = null;
    this.redraw();
  }
  static get verticalDragZoomEnabled() {
    return YGraph._defaultVerticalDragZoomEnabled;
  }
  static set verticalDragZoomEnabled(value) {
    YGraph._defaultVerticalDragZoomEnabled = value;
  }
  static createCaptureCursor() {
    if (YGraph.captureCursor != null)
      return;
    let base64png = "iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAALHRFWHRDcmVhdGlvbiBUaW1lAFRodSAyMCBBdWcgMjAyMCAxMjoxNTo1MCArMDEwMP38NhoAAAAHdElNRQfkCBQOJAvCrm0ZAAAACXBIWXMAAFxGAABcRgEUlENBAAAABGdBTUEAALGPC / xhBQAAAmVJREFUeNrtVrFuFDEQHd9eBImAIBFoAgVC0NJQUFDwL / QgRXzAfUz + Iy0pQwsIJAhCQMQBUS5c2DXv7T5fzN5qs / Fxdw0jPY3ttT3jt54ZmyXIYDDoQXnodWBV / SRJXZhJbwCXov65pZ + 4zklfBsZRf2EMxOuTjc / igIu0s0UygAvnonWZ0NP4fB2QkQz6yHvP / i76V4E1jZ / bic4LIuMnND7ZwDl + u4 / me + AnkKPvu + 7rFMNZBzZ64eRTm5w6sQ8cAcUZexVytOCpOnv7j + QdDD + CHgKjMg80nWpeQrYgd4A3wHjWPJAqN4BVoLcsB1ZMd25ZDkzkvwNLd6AMQ4XGIuXElKz6SAo3rYpLhsZKyyJmwu2WTLiF5g / g2NozIY1 / BkacRwaYkZgUPlr7L2EdeAhjLxpqwTOr0vAHOZG37FPIOO3mfXXG1qEWAGvM + TC6Rydk / KmMv7bmWlD / v95qtaCThGpo1TPsFvp7wBO0v4nBqWoYvR0yOeLFThHmdH4TcgGQy8i + hkn5V / WbSjGr7e9oD96372LJB1o7izbPtYHpPw7V / 8u4yvzFkvPTO3MXuMbx8JRPij8svgAcAw / EwCe0f8XGxZYFB6JQZzl + rHWj1Gf5WZLVTj5py5HbVoXjeF4OuMhYnQHKulW / x6U64CPtbfpVxQu7CX0PeicMov3cKup5EZmw / KwMFNb8pMtl5G3MhIyHkOX3PPUSMmXzOX7Fqsw35Gu5NidEwXWr / jnnD + XUFzLARJRaDXnCQ53o0BpSLzcXzQfAK + Cl9EEwXrKTyr1OWGa3sFnLvPDsn6Tg8P0PrBcSMR2NtfsAAAAASUVORK5CYII =";
    try {
      YGraph.captureCursor = new YCursor(atob(base64png));
    } catch (Exception) {
      console.log("Cannot create custom cursor");
    }
  }
  get dataPanels() {
    return this._dataPanels;
  }
  addDataPanel() {
    let p = new DataPanel(this, this);
    this._dataPanels.push(p);
    return p;
  }
  setMarkerCaptureCallbacks(start, stop) {
    this._markerCaptureStartedCallback = start;
    this._markerCaptureStoppedCallback = stop;
  }
  startMarkerCapture(m) {
    if (this._markerCaptureStartedCallback != null)
      this._markerCaptureStartedCallback(m);
    this.markerCapture = m;
    this.UIContainer.focus();
  }
  constructor(ChartContainer, logFunction) {
    super(ChartContainer, logFunction);
    this._markerCaptureStartedCallback = null;
    this._markerCaptureStoppedCallback = null;
    this.lastPointCount = -1;
    this.lastTopMargin = -1;
    this.lastBottomMargin = -1;
    this.navigatorCache = null;
    this.markerCapture = null;
    this._borderPen = null;
    this._borderColor = YColor.LightGray;
    this._borderThickness = 1;
    this._touchStartfct = null;
    this._touchMovefct = null;
    this._touchEndfct = null;
    this._mouseDownfct = null;
    this._mouseMovefct = null;
    this._mouseWheelfct = null;
    this._mouseKeyDownfct = null;
    this.mainViewPort = new ViewPortSettings();
    this._timeRange = null;
    this._bgBrush = null;
    this._bgColor1 = YColor.FromArgb(255, 200, 200, 200);
    this._bgColor2 = YColor.FromArgb(255, 255, 255, 255);
    this._touchStartPinchDistance = -1;
    this._touchStartPinchCenter = new Point(0, 0);
    this._touchStartPinchZoom = 1;
    this._touchStartPinchIRLx = 0;
    this._touchStartPinchRange = 0;
    this.dataTrackerRefreshtimeout = null;
    YGraph.createCaptureCursor();
    this._xAxis = new XAxis(this, this);
    this._yAxes = [];
    this._series = [];
    this._dataPanels = [];
    this._navigator = new Navigator(this, this);
    this._legendPanel = new LegendPanel(this, this);
    this._dataTracker = new DataTracker(this, this);
    this._touchStartfct = (e) => {
      this.TouchStart(this.UIContainer, e);
    };
    this._touchMovefct = (e) => {
      this.TouchMove(this.UIContainer, e);
    };
    this._touchEndfct = (e) => {
      this.TouchEnd(this.UIContainer, e);
    };
    this._mouseDownfct = (e) => {
      this.MouseDown(this.UIContainer, e);
    };
    this._mouseMovefct = (e) => {
      this.MouseMove(this.UIContainer, e);
    };
    this._mouseWheelfct = (e) => {
      this.mouseWheelEvent(this.UIContainer, e);
    };
    this._mouseKeyDownfct = (e) => {
      this.KeyDown(this.UIContainer, e);
    };
    this.UIContainer.addEventListener("touchstart", this._touchStartfct);
    this.UIContainer.addEventListener("touchmove", this._touchMovefct);
    this.UIContainer.addEventListener("touchend", this._touchEndfct);
    this.UIContainer.addEventListener("mousedown", this._mouseDownfct);
    this.UIContainer.addEventListener("mousemove", this._mouseMovefct);
    this.UIContainer.addEventListener("wheel", this._mouseWheelfct);
    this.UIContainer.addEventListener("keydown", this._mouseKeyDownfct);
    this._timeRange = MinMaxHandler.DefaultValue();
    let originalContainerWidth = ChartContainer.width;
    let originalContainerHeight = ChartContainer.height;
    let originalFormWidth = ChartContainer.width;
    let originalFormHeight = ChartContainer.height;
  }
  destroy() {
    if (this._touchStartfct != null)
      this.UIContainer.removeEventListener("touchstart", this._touchStartfct);
    if (this._touchMovefct != null)
      this.UIContainer.removeEventListener("touchstart", this._touchMovefct);
    if (this._touchEndfct != null)
      this.UIContainer.removeEventListener("touchstart", this._touchEndfct);
    if (this._mouseDownfct != null)
      this.UIContainer.removeEventListener("mousedown", this._mouseDownfct);
    if (this._mouseMovefct != null)
      this.UIContainer.removeEventListener("mousemove", this._mouseMovefct);
    if (this._mouseWheelfct != null)
      this.UIContainer.removeEventListener("wheel", this._mouseWheelfct);
    if (this._mouseKeyDownfct != null)
      this.UIContainer.removeEventListener("keydown", this._mouseKeyDownfct);
    super.destroy();
    Object.entries(this).forEach((pair) => {
      Reflect.set(this, pair[0], null);
    });
  }
  getMostRecentPoint() {
    let res = new pointXY(NaN, NaN);
    for (let i = 0; i < this._series.length; i++)
      if (!this.series[i].disabled) {
        let p = this.series[i].getlastPoint();
        if (!isNaN(p.x)) {
          if (isNaN(res.x))
            res = p;
          else if (p.x > res.x)
            res = p;
        }
      }
    return res;
  }
  adjustGlobalTimeRange(x) {
    let max = this._timeRange.Max;
    this._timeRange = MinMaxHandler.CombineWithNumber(this._timeRange, x);
    if (isNaN(max))
      return;
    let ofset = x - max;
    if (ofset > 0) {
      switch (this._xAxis.overflowHandling) {
        case XAxis.OverflowHandling.SCROLL:
          if (max > this._xAxis.min + (this._xAxis.max - this._xAxis.min) * 0.85 && max <= this._xAxis.max) {
            this.DisableRedraw();
            this._xAxis.set_minMax(this._xAxis.min + ofset, this._xAxis.max + ofset);
            this.AllowRedraw();
          }
          break;
        case XAxis.OverflowHandling.CONTRACT:
          if (max > this._xAxis.min + (this._xAxis.max - this._xAxis.min) * 0.95 && max <= this._xAxis.max) {
            this.DisableRedraw();
            this._xAxis.max += ofset;
            this.AllowRedraw();
          }
          break;
      }
    }
  }
  get bgColor1() {
    return this._bgColor1;
  }
  set bgColor1(value) {
    this._bgColor1 = value;
    this._bgBrush = null;
    this.redraw();
  }
  get bgColor2() {
    return this._bgColor2;
  }
  set bgColor2(value) {
    this._bgColor2 = value;
    this._bgBrush = null;
    this.redraw();
  }
  get xAxis() {
    return this._xAxis;
  }
  get navigator() {
    return this._navigator;
  }
  get yAxes() {
    return this._yAxes;
  }
  get series() {
    return this._series;
  }
  addYAxis() {
    let s = new YAxis(this, this, this._yAxes.length);
    this._yAxes.push(s);
    this.redraw();
    return s;
  }
  addSerie() {
    let s = new DataSerie(this);
    this._series.push(s);
    this.redraw();
    return s;
  }
  clearCachedObjects() {
    this._bgBrush = null;
    this.navigatorCache = null;
  }
  TouchStart(sender, e) {
    if (e.touches.length == 1) {
      this.HandleMouseDown(sender, e.touches[0].pageX, e.touches[0].pageY);
    } else if (e.touches.length == 2) {
      e.preventDefault();
      this.HandleEndOfMouseCapture();
      this._touchStartPinchDistance = Math.sqrt(Math.pow(e.touches[1].pageX - e.touches[0].pageX, 2) + Math.pow(e.touches[1].pageY - e.touches[0].pageY, 2));
      this._touchStartPinchCenter = new Point(e.touches[1].pageX + e.touches[0].pageX >> 2, e.touches[1].pageY + e.touches[0].pageY >> 2);
      this._touchStartPinchZoom = this.mainViewPort.zoomx;
      this._touchStartPinchIRLx = this.mainViewPort.IRLx;
      this._touchStartPinchRange = this._xAxis.max - this._xAxis.min;
    }
  }
  MouseDown(sender, e) {
    if (e.buttons == 2 && this.markerCapture != null) {
      this.markerCapture = null;
      if (this._markerCaptureStoppedCallback != null)
        this._markerCaptureStoppedCallback(null);
    }
    if (e.buttons != 1)
      return;
    this.HandleMouseDown(sender, e.pageX, e.pageY);
  }
  HandleMouseDown(sender, pageX, pageY) {
    let p = this.Scr2ElmMatrix.multiplyByV(Vector3.FromXYCoord(pageX, pageY)).toPoint();
    let eX = p.X;
    let eY = p.Y;
    if (eX >= this.mainViewPort.Lmargin && eX <= this.mainViewPort.Width - this.mainViewPort.Rmargin && eY >= this.mainViewPort.Tmargin && eY <= this.mainViewPort.Height - this.mainViewPort.Bmargin) {
      if (this.markerCapture != null) {
        let p22 = YGraph.ViewPortPointToIRL(this.mainViewPort, new Point(eX, eY));
        this.markerCapture.setCapturedPosition(p22.x, this.xAxis);
        if (this._markerCaptureStoppedCallback != null)
          this._markerCaptureStoppedCallback(this.markerCapture);
        this.markerCapture = null;
        return;
      }
      let p2 = YGraph.ViewPortPointToIRL(this.mainViewPort, new Point(eX, eY));
      this.mainViewPort.OriginalXAxisMin = this.xAxis.min;
      this.mainViewPort.OriginalXAxisMax = this.xAxis.max;
      this.mainViewPort.OriginalIRLx = this.mainViewPort.IRLx;
      this.mainViewPort.OriginalLmargin = this.mainViewPort.Lmargin;
      this.mainViewPort.OriginalZoomx = this.mainViewPort.zoomx;
      this.mainViewPort.CaptureStartY = eY;
      this.mainViewPort.IRLCaptureStartX = p2.x;
      this.mainViewPort.Capture = true;
    } else if (eX >= this._navigator.viewport.Lmargin && eX <= this._navigator.viewport.Width - this._navigator.viewport.Rmargin && eY >= this._navigator.viewport.Lmargin && eY <= this._navigator.viewport.Height - this._navigator.viewport.Bmargin) {
      let p2 = YGraph.ViewPortPointToIRL(this._navigator.viewport, new Point(eX, eY));
      let p22 = YGraph.ViewPortPointToIRL(this.mainViewPort, new Point(this.mainViewPort.Lmargin, 0));
      let p3 = YGraph.ViewPortPointToIRL(this.mainViewPort, new Point(this.mainViewPort.Width - this.mainViewPort.Rmargin, 0));
      if (p2.x >= p22.x && p2.x <= p3.x) {
        this._navigator.startCapture(p2, this._xAxis.min, this._xAxis.max);
      } else {
        this.DisableRedraw();
        let min = p2.x - (p3.x - p22.x) / 2;
        let max = min + (p3.x - p22.x);
        this._xAxis.set_minMax(min, max);
        this.AllowRedraw();
        this.Draw(0);
      }
    }
  }
  TouchMove(sender, e) {
    if (e.touches.length == 1) {
      e.preventDefault();
      this.HandleMouseMove(sender, e.touches[0].pageX, e.touches[0].pageY);
    } else if (e.touches.length == 2) {
      e.preventDefault();
      let newdistance = Math.sqrt(Math.pow(e.touches[1].pageX - e.touches[0].pageX, 2) + Math.pow(e.touches[1].pageY - e.touches[0].pageY, 2));
      let ZoomFactor = newdistance / this._touchStartPinchDistance;
      let NextZoomX = this._touchStartPinchZoom * ZoomFactor;
      if (NextZoomX > this.mainViewPort.zoomx && NextZoomX > 1e3)
        return;
      let currentRange = this._xAxis.max - this._xAxis.min;
      this.mainViewPort.IRLx = this._touchStartPinchIRLx + (this._touchStartPinchCenter.X - this.mainViewPort.Lmargin) / this._touchStartPinchZoom - (this._touchStartPinchCenter.X - this.mainViewPort.Lmargin) / NextZoomX;
      this._xAxis.set_minMax(this.mainViewPort.IRLx, this.mainViewPort.IRLx + this._touchStartPinchRange / ZoomFactor);
      this.mainViewPort.zoomx = NextZoomX;
      this.redraw();
    }
  }
  TouchEnd(sender, e) {
    this.HandleEndOfMouseCapture();
  }
  MouseMove(sender, e) {
    if (e.buttons != 1 && (this.mainViewPort.Capture || this._navigator.Capture))
      this.HandleEndOfMouseCapture();
    this.HandleMouseMove(sender, e.pageX, e.pageY);
    if (this.dataTracker.enabled) {
      if (this.dataTrackerRefreshtimeout != null)
        clearTimeout(this.dataTrackerRefreshtimeout);
      this.dataTrackerRefreshtimeout = setTimeout(() => {
        this.redraw();
      }, 100);
    }
  }
  HandleEndOfMouseCapture() {
    this.mainViewPort.Capture = false;
    this._navigator.stopCapture();
    if (this._dataTracker.enabled)
      this.redraw();
  }
  HandleMouseMove(sender, pageX, pageY) {
    let p = this.Scr2ElmMatrix.multiplyByV(Vector3.FromXYCoord(pageX, pageY)).toPoint();
    let eX = p.X;
    let eY = p.Y;
    if (this.markerCapture != null) {
      if (eX > this.mainViewPort.Lmargin && eX < this.mainViewPort.Width - this.mainViewPort.Rmargin && eY > this.mainViewPort.Tmargin && eY < this.mainViewPort.Height - this.mainViewPort.Bmargin) {
        if (this.UIContainer.style.cursor != YGraph.captureCursor.handle && this.UIContainer.style.cursor != "crosshair") {
          this.UIContainer.style.cursor = YGraph.captureCursor != null ? YGraph.captureCursor.handle : "crosshair";
        }
      } else if (this.UIContainer.style.cursor != "default")
        this.UIContainer.style.cursor = "default";
    } else if (this.UIContainer.style.cursor != "default")
      this.UIContainer.style.cursor = "default";
    if (this.mainViewPort.Capture) {
      let x1 = this.mainViewPort.OriginalIRLx + (eX - this.mainViewPort.OriginalLmargin) / this.mainViewPort.OriginalZoomx;
      let deltaX = x1 - this.mainViewPort.IRLCaptureStartX;
      let deltaY = eY - this.mainViewPort.CaptureStartY;
      this.DisableRedraw();
      let halfAxisDelta = (this.mainViewPort.OriginalXAxisMax - this.mainViewPort.OriginalXAxisMin) / 2;
      let Axismiddle = (this.mainViewPort.OriginalXAxisMax + this.mainViewPort.OriginalXAxisMin) / 2;
      let deltaCoef = YGraph._defaultVerticalDragZoomEnabled && Math.abs(deltaY) > 10 ? Math.pow(1.01, deltaY) : 1;
      this._xAxis.set_minMax(Axismiddle - halfAxisDelta * deltaCoef - deltaX, Axismiddle + halfAxisDelta * deltaCoef - deltaX);
      this.AllowRedraw();
      this.redraw();
      return;
    }
    if (this._navigator.viewport.Capture) {
      let x1 = this._navigator.viewport.OriginalIRLx + (eX - this._navigator.viewport.OriginalLmargin) / this._navigator.viewport.OriginalZoomx;
      let delta = x1 - this._navigator.viewport.IRLCaptureStartX;
      this.DisableRedraw();
      this._xAxis.set_minMax(this._navigator.viewport.OriginalXAxisMin + delta, this._navigator.viewport.OriginalXAxisMax + delta);
      this.AllowRedraw();
      this.redraw();
      return;
    }
  }
  cross(p) {
  }
  static IRLPointToViewPort(viewport, p, IRLy, zoomy) {
    if (IRLy === void 0) {
      let xx2 = viewport.Lmargin + Math.round((p.x - viewport.IRLx) * viewport.zoomx);
      let yy2 = viewport.Height - viewport.Bmargin - Math.round((p.y - viewport.IRLy) * viewport.zoomy);
      return new Point(xx2 >> 0, yy2 >> 0);
    }
    let xx = viewport.Lmargin + Math.round((p.x - viewport.IRLx) * viewport.zoomx);
    let yy = viewport.Height - viewport.Bmargin - Math.round((p.y - IRLy) * zoomy);
    return new Point(xx >> 0, yy >> 0);
  }
  static IRLPointSummaryToViewPort(viewport, p, IRLy, zoomy) {
    if (IRLy === void 0) {
      let x12 = viewport.Lmargin + Math.round((p.x1 - viewport.IRLx) * viewport.zoomx);
      let ymin2 = viewport.Height - viewport.Bmargin - Math.round((p.ymin - viewport.IRLy) * viewport.zoomy);
      let x22 = viewport.Lmargin + Math.round((p.x2 - viewport.IRLx) * viewport.zoomx);
      let ymax2 = viewport.Height - viewport.Bmargin - Math.round((p.ymax - viewport.IRLy) * viewport.zoomy);
      return new minMaxPoint(x12, ymin2, x22, ymax2);
    }
    let x1 = viewport.Lmargin + Math.round((p.x1 - viewport.IRLx) * viewport.zoomx);
    let ymin = viewport.Height - viewport.Bmargin - Math.round((p.ymin - IRLy) * zoomy);
    let x2 = viewport.Lmargin + Math.round((p.x2 - viewport.IRLx) * viewport.zoomx);
    let ymax = viewport.Height - viewport.Bmargin - Math.round((p.ymax - IRLy) * zoomy);
    return new minMaxPoint(x1, ymin, x2, ymax);
  }
  static ViewPortPointToIRL(viewport, p, IRLy, zoomy) {
    if (IRLy === void 0) {
      return new pointXY(viewport.IRLx + (p.X - viewport.Lmargin) / viewport.zoomx, viewport.IRLy + (+viewport.Height - p.Y - viewport.Bmargin) / viewport.zoomy);
    }
    return new pointXY(viewport.IRLx + (p.X - viewport.Lmargin) / viewport.zoomx, IRLy + (+viewport.Height - p.Y - viewport.Bmargin) / zoomy);
  }
  static FindMinMax(start, end, data, count) {
    let res = MinMaxHandler.DefaultValue();
    if (data[0].x > end)
      return res;
    if (data[count - 1].x < start)
      return res;
    let N1 = 0;
    let N2 = 0;
    let First = 0;
    if (data[0].x < start) {
      N1 = 0;
      N2 = count - 1;
      while (N2 - N1 > 1) {
        let N = N1 + N2 >> 1;
        if (data[N].x > start)
          N2 = N;
        else
          N1 = N;
      }
      First = N1 - 1;
      if (First < 0)
        First = 0;
    }
    let Last = count - 1;
    if (data[Last] === void 0) {
      debugger;
    }
    if (data[Last].x > end) {
      N1 = 0;
      N2 = count - 1;
      while (N2 - N1 > 1) {
        let N = N1 + N2 >> 1;
        if (data[N].x < end)
          N1 = N;
        else
          N2 = N;
      }
      Last = N2 + 1;
      if (Last > count - 1)
        Last = count - 1;
    }
    res.Min = data[First].y;
    res.Max = data[First].y;
    for (let i = First + 1; i <= Last; i++) {
      if (data[i].y < res.Min)
        res.Min = data[i].y;
      if (data[i].y > res.Max)
        res.Max = data[i].y;
    }
    return res;
  }
  resetlegendPens() {
    for (let i = 0; i < this._series.length; i++) {
      this._series[i].resetlegendPen();
    }
  }
  drawLegendPanel(g, viewPortWidth, viewPortHeight, mainViewPort) {
    let verticalRatio = 1.25;
    if (!this._legendPanel.enabled)
      return;
    let legendWidths = new Array(this._series.length);
    let legendHeight = new Array(this._series.length);
    let ofsetx = new Array(this._series.length);
    let ofsety = new Array(this._series.length);
    let legends = new Array(this._series.length);
    let totalHeight = 0;
    let totalWidth = 0;
    let maxWidth = 0;
    let maxHeight = 0;
    g.TextRenderingHint = YTextRenderingHint.SingleBitPerPixelGridFit;
    g.SetClip(new YRectangle(0, 0, viewPortWidth, viewPortHeight));
    for (let i = 0; i < this._series.length; i++) {
      if (this._series[i].legend != "")
        legends[i] = this._series[i].legend;
      else
        legends[i] = "Series " + (i + 1).toString();
    }
    if (this._legendPanel.position == LegendPanel.Position.TOP || this._legendPanel.position == LegendPanel.Position.BOTTOM) {
      let availableWidth = viewPortWidth - 2 * this._legendPanel.padding + this._legendPanel.borderthickness;
      if (this._legendPanel.overlap)
        availableWidth = availableWidth - mainViewPort.Lmargin - mainViewPort.Rmargin;
      totalHeight = 0;
      let xx = 0;
      let yy = 0;
      for (let i = 0; i < this._series.length; i++) {
        if (this._series[i].segments.length > 0 && this._series[i].visible && !this._series[i].disabled) {
          let ssize = g.MeasureString(legends[i], this._legendPanel.font, 1e5);
          legendHeight[i] = ssize.height + 1;
          let ww = ssize.width + 20;
          if (xx == 0)
            totalHeight += ssize.height;
          if (availableWidth - xx < ww) {
            if (xx == 0) {
              ofsetx[i] = xx;
              ofsety[i] = yy;
              yy += ssize.height;
              if (maxWidth < ww)
                maxWidth = ww;
            } else {
              yy += ssize.height;
              ofsetx[i] = 0;
              ofsety[i] = yy;
              xx = ww;
              totalHeight += ssize.height;
              if (maxWidth < xx)
                maxWidth = xx;
            }
          } else {
            ofsetx[i] = xx;
            ofsety[i] = yy;
            xx += ww;
            if (maxWidth < xx)
              maxWidth = xx;
          }
        }
      }
      if (totalWidth > availableWidth) {
        totalWidth = availableWidth;
      }
    } else {
      let ty = 0;
      for (let i = 0; i < this._series.length; i++) {
        if (this._series[i].segments.length > 0 && this._series[i].visible && !this._series[i].disabled) {
          let ssize = g.MeasureString(legends[i], this._legendPanel.font, 1e5);
          legendWidths[i] = ssize.width + 1;
          if (maxWidth < legendWidths[i] + 20)
            maxWidth = legendWidths[i] + 20;
          legendHeight[i] = ssize.height + 1;
          if (maxHeight < legendHeight[i])
            maxHeight = legendHeight[i];
          ofsetx[i] = 0;
          ofsety[i] = ty;
          ty += ssize.height * verticalRatio;
          totalHeight += i == 0 ? ssize.height : ssize.height * verticalRatio;
        }
      }
    }
    let w = maxWidth + 2 * this._legendPanel.padding + this._legendPanel.borderthickness;
    let h = totalHeight + 2 * this._legendPanel.padding + this._legendPanel.borderthickness;
    let x = 0;
    let y = 0;
    switch (this._legendPanel.position) {
      case LegendPanel.Position.LEFT:
        x = this._legendPanel.horizontalMargin;
        if (!this._legendPanel.overlap) {
          mainViewPort.Lmargin += w + 2 * this.legendPanel.horizontalMargin + this.legendPanel.borderthickness >> 0;
          y = (viewPortHeight - h) / 2;
        } else {
          x += mainViewPort.Lmargin;
          y = mainViewPort.Tmargin + (viewPortHeight - mainViewPort.Tmargin - mainViewPort.Bmargin - h) / 2;
        }
        break;
      case LegendPanel.Position.TOPLEFT:
        x = this._legendPanel.horizontalMargin;
        y = this._legendPanel.verticalMargin;
        if (!this._legendPanel.overlap) {
          mainViewPort.Lmargin += w + 2 * this.legendPanel.horizontalMargin + this.legendPanel.borderthickness >> 0;
        } else {
          x += mainViewPort.Lmargin;
          y += mainViewPort.Tmargin;
        }
        break;
      case LegendPanel.Position.TOP:
        if (!this._legendPanel.overlap) {
          x = (viewPortWidth - w) / 2 - this._legendPanel.horizontalMargin - this._legendPanel.borderthickness;
          y = this._legendPanel.verticalMargin + this._legendPanel.borderthickness;
          mainViewPort.Tmargin += totalHeight + this._legendPanel.verticalMargin + 2 * this._legendPanel.verticalMargin + this._legendPanel.borderthickness >> 0;
        } else {
          x = mainViewPort.Lmargin + (viewPortWidth - mainViewPort.Lmargin - mainViewPort.Rmargin - w) / 2 - this._legendPanel.horizontalMargin - this._legendPanel.borderthickness;
          y = mainViewPort.Tmargin + this._legendPanel.verticalMargin - this._legendPanel.borderthickness;
        }
        break;
      case LegendPanel.Position.TOPRIGHT:
        x = viewPortWidth - this._legendPanel.horizontalMargin - w;
        y = this._legendPanel.verticalMargin;
        if (!this._legendPanel.overlap) {
          mainViewPort.Rmargin += w + 2 * this._legendPanel.horizontalMargin + this._legendPanel.borderthickness >> 0;
        } else {
          x -= mainViewPort.Rmargin;
          y += mainViewPort.Tmargin;
        }
        break;
      case LegendPanel.Position.RIGHT:
        x = viewPortWidth - this._legendPanel.horizontalMargin - w;
        if (!this._legendPanel.overlap) {
          mainViewPort.Rmargin += w + 2 * this._legendPanel.horizontalMargin + this._legendPanel.borderthickness >> 0;
          y = (viewPortHeight - h) / 2;
        } else {
          x -= mainViewPort.Rmargin;
          y = mainViewPort.Tmargin + (viewPortHeight - mainViewPort.Tmargin - mainViewPort.Bmargin - h) / 2;
        }
        break;
      case LegendPanel.Position.BOTTOMRIGHT:
        x = viewPortWidth - this._legendPanel.horizontalMargin - w;
        if (!this._legendPanel.overlap) {
          mainViewPort.Rmargin += w + 2 * this._legendPanel.horizontalMargin + this._legendPanel.borderthickness >> 0;
          y = viewPortHeight - this._legendPanel.verticalMargin - h;
        } else {
          x -= mainViewPort.Rmargin;
          y = viewPortHeight - mainViewPort.Bmargin - h - this._legendPanel.verticalMargin;
        }
        break;
      case LegendPanel.Position.BOTTOM:
        if (!this._legendPanel.overlap) {
          x = (viewPortWidth - w) / 2 - this._legendPanel.horizontalMargin - this._legendPanel.borderthickness;
          y = viewPortHeight - this._legendPanel.verticalMargin - 2 * this._legendPanel.padding - this._legendPanel.borderthickness - totalHeight;
          mainViewPort.Bmargin += totalHeight + 2 * this._legendPanel.padding + 2 * this._legendPanel.verticalMargin + this._legendPanel.borderthickness;
        } else {
          x = mainViewPort.Lmargin + (viewPortWidth - mainViewPort.Lmargin - mainViewPort.Rmargin - w) / 2 - this._legendPanel.horizontalMargin - this._legendPanel.borderthickness;
          y = viewPortHeight - mainViewPort.Bmargin - totalHeight - 2 * this._legendPanel.padding - 2 * this._legendPanel.verticalMargin - this._legendPanel.borderthickness;
        }
        break;
      case LegendPanel.Position.BOTTOMLEFT:
        x = this._legendPanel.horizontalMargin;
        y = this._legendPanel.verticalMargin;
        if (!this._legendPanel.overlap) {
          mainViewPort.Lmargin += w + 2 * this._legendPanel.horizontalMargin + this._legendPanel.borderthickness;
          y = viewPortHeight - this._legendPanel.verticalMargin - h;
        } else {
          x += mainViewPort.Lmargin;
          y = viewPortHeight - mainViewPort.Bmargin - h - this._legendPanel.verticalMargin;
        }
        break;
    }
    let rect = new YRectangle(x >> 0, y >> 0, w >> 0, h >> 0);
    g.FillRectangle(this._legendPanel.bgBrush, rect);
    g.DrawRectangle(this._legendPanel.pen, rect);
    g.TextRenderingHint = YTextRenderingHint.AntiAlias;
    for (let i = 0; i < this._series.length; i++) {
      if (this._series[i].segments.length > 0 && this._series[i].visible && !this._series[i].disabled) {
        g.DrawStringXY(legends[i], this._legendPanel.font, this._legendPanel.font.brush, x + ofsetx[i] + 20 + this._legendPanel.padding >> 0, y + ofsety[i] + this._legendPanel.padding >> 0);
        let px = x + ofsetx[i] + this._legendPanel.borderthickness / 2 + this._legendPanel.padding + 6 >> 0;
        let py = y + ofsety[i] + this._legendPanel.padding + legendHeight[i] / 2 >> 0;
        g.DrawLine(this._series[i].legendPen, new PointF(px, py), new PointF(px + 12, py));
      }
    }
  }
  static DoSegmentRendering(w, g, p, data, count, xTimeStart, xTimeEnd) {
    if (data[0].x > xTimeEnd || data[count - 1].x < xTimeStart)
      return 0;
    let isSVG = g instanceof YGraphicsSVG;
    let N1 = 0;
    let N2 = 0;
    let First = 0;
    if (data[0].x < xTimeStart) {
      N1 = 0;
      N2 = count - 1;
      while (N2 - N1 > 1) {
        let N = N1 + N2 >> 1;
        if (data[N].x > xTimeStart)
          N2 = N;
        else
          N1 = N;
      }
      First = N1 - 1;
      if (First < 0)
        First = 0;
    }
    let Last = count - 1;
    if (data[Last].x > xTimeEnd) {
      N1 = 0;
      N2 = count - 1;
      while (N2 - N1 > 1) {
        let N = N1 + N2 >> 1;
        if (data[N].x < xTimeEnd)
          N1 = N;
        else
          N2 = N;
      }
      Last = N2 + 1;
      if (Last > count - 1)
        Last = count - 1;
    }
    if (Last - First > 2 * w.Width - w.Lmargin - w.Rmargin) {
      let ToDraw = new Array(3 * (Last - First + 1));
      let Current = YGraph.IRLPointToViewPort(w, data[First]);
      let New;
      let i = First + 1;
      let n = 0;
      let max;
      let min;
      let limit;
      while (i < Last) {
        ToDraw[n++] = new PointF(Current.X, Current.Y);
        min = data[i].y;
        max = min;
        limit = YGraph.ViewPortPointToIRL(w, new Point(Current.X + 1, Current.Y + 1)).x;
        do {
          if (data[i].y > max)
            max = data[i].y;
          if (data[i].y < min)
            min = data[i].y;
          i++;
        } while (i < Last && data[i].x < limit);
        let p1 = YGraph.IRLPointToViewPort(w, new pointXY(data[i].x, min));
        let p2 = YGraph.IRLPointToViewPort(w, new pointXY(data[i].x, max));
        if (Math.abs(p1.Y - p2.Y) > 2) {
          ToDraw[n++] = new PointF(p1.X, p1.Y);
          ToDraw[n++] = new PointF(p2.X, p2.Y);
        }
        Current = YGraph.IRLPointToViewPort(w, data[i]);
      }
      ToDraw[n++] = Current;
      ToDraw = ToDraw.slice(0, n);
      if (n > 1)
        g.DrawLines(p, ToDraw);
      return n;
    } else {
      if (isSVG) {
        let ToDraw = new Array(Last - First + 1);
        for (let i = First; i <= Last; i++) {
          ToDraw[i - First] = YGraph.IRLPointToViewPort(w, data[i]);
        }
        g.DrawLines(p, ToDraw);
      } else {
        for (let i = First; i < Last; i++) {
          g.DrawLine(p, YGraph.IRLPointToViewPort(w, data[i]), YGraph.IRLPointToViewPort(w, data[i + 1]));
        }
      }
    }
    return Last - First;
  }
  static DoSummarySegmentRendering(w, g, p, data, count, finalPoint, xTimeStart, xTimeEnd) {
    let ToDraw = new Array(2 * count + 1);
    let n = 0;
    if (count > 0) {
      if (data[0].x1 > xTimeEnd || data[count - 1].x2 < xTimeStart)
        return 0;
      let isSVG = g instanceof YGraphicsSVG;
      let N1 = 0;
      let N2 = 0;
      let First = 0;
      if (data[0].x1 < xTimeStart) {
        N1 = 0;
        N2 = count - 1;
        while (N2 - N1 > 1) {
          let N = N1 + N2 >> 1;
          if (data[N].x1 > xTimeStart)
            N2 = N;
          else
            N1 = N;
        }
        First = N1 - 1;
        if (First < 0)
          First = 0;
      }
      let Last = count - 1;
      if (data[Last].x2 > xTimeEnd) {
        N1 = 0;
        N2 = count - 1;
        while (N2 - N1 > 1) {
          let N = N1 + N2 >> 1;
          if (data[N].x2 < xTimeEnd)
            N1 = N;
          else
            N2 = N;
        }
        Last = N2 + 1;
        if (Last > count - 1)
          Last = count - 1;
      }
      let Current;
      let New;
      let i = First;
      let max;
      let min;
      let limit;
      Current = YGraph.IRLPointSummaryToViewPort(w, data[i]);
      ToDraw[n++] = new PointF(Current.X1, Current.YMIN);
      let ymin = Current.YMAX;
      let ymax = Current.YMIN;
      let x = Current.X1;
      let buffered = 0;
      while (i <= Last) {
        Current = YGraph.IRLPointSummaryToViewPort(w, data[i]);
        if (ymin > Current.YMAX)
          ymin = Current.YMAX;
        if (ymax < Current.YMIN)
          ymax = Current.YMIN;
        buffered++;
        if (Current.X2 > x) {
          ToDraw[n++] = new PointF(x, ymin);
          if (ymax - ymin > 2)
            ToDraw[n++] = new PointF(x + Current.X2 >> 1, ymax);
          x = Current.X2;
          ymin = Current.YMAX;
          ymax = Current.YMIN;
          buffered = 0;
        }
        i++;
      }
      if (buffered > 0) {
        ToDraw[n++] = new PointF(x, Current.YMIN);
        ToDraw[n++] = new PointF(x + Current.X2 >> 1, Current.YMAX);
      }
    }
    if (finalPoint) {
      let Current = YGraph.IRLPointSummaryToViewPort(w, finalPoint);
      ToDraw[n++] = new PointF(Current.X1, Current.YMIN);
      ToDraw[n++] = new PointF(Current.X2, Current.YMAX);
    }
    if (n > 1) {
      ToDraw = ToDraw.slice(0, n);
      g.DrawLines(p, ToDraw);
    }
    return n;
  }
  DrawYAxisZones(w, g, scale) {
    if (!scale.visible)
      return;
    let Delta = scale.startStopStep.dataMax - scale.startStopStep.dataMin;
    let YZoom = Delta / (w.Height - w.Bmargin - w.Tmargin);
    for (let i = 0; i < scale.zones.length; i++) {
      if (scale.zones[i].visible) {
        let max = scale.zones[i].max;
        let min = scale.zones[i].min;
        if (Number.isNaN(max)) {
          max = scale.startStopStep.dataMax;
        }
        if (Number.isNaN(min))
          min = scale.startStopStep.dataMin;
        if (max < min) {
          let t = max;
          max = min;
          min = t;
        }
        let y0 = w.Height - w.Bmargin - Math.round((max - scale.startStopStep.dataMin) / YZoom) >> 0;
        let h = Math.round((max - min) / YZoom) >> 0;
        g.FillRectangleXYHW(scale.zones[i].zoneBrush, this.mainViewPort.Lmargin, y0, this.mainViewPort.Width - this.mainViewPort.Rmargin - this.mainViewPort.Lmargin + 1, h);
      }
    }
  }
  DrawXAxisZones(w, g, scale) {
    if (!scale.visible)
      return;
    let delta = scale.max - scale.min;
    let XZoom = delta / (w.Width - w.Lmargin - w.Rmargin);
    for (let i = 0; i < scale.zones.length; i++) {
      if (scale.zones[i].visible) {
        let max = scale.zones[i].max;
        let min = scale.zones[i].min;
        if (Number.isNaN(max))
          max = scale.min;
        if (Number.isNaN(min))
          min = scale.max;
        if (max < min) {
          let t = max;
          max = min;
          min = t;
        }
        let x0 = w.Lmargin + Math.round((min - scale.min) / XZoom) >> 0;
        g.FillRectangleXYHW(scale.zones[i].zoneBrush, x0, this.mainViewPort.Tmargin, (max - min) / XZoom >> 0, this.mainViewPort.Height - this.mainViewPort.Tmargin - this.mainViewPort.Bmargin);
      }
    }
  }
  static DrawYAxis(w, g, axis, ofset, simulation) {
    if (!axis.visible) {
      axis.innerWidth = 0;
      return axis.innerWidth;
    }
    let Delta = axis.startStopStep.dataMax - axis.startStopStep.dataMin;
    let YZoom = Delta / (w.Height - w.Bmargin - w.Tmargin);
    let leftSide = axis.position == YAxis.HrzPosition.LEFT;
    let x = leftSide ? w.Lmargin - ofset : w.Width - w.Rmargin + ofset;
    if (!simulation)
      g.DrawLineXY(axis.pen, x, w.Tmargin, x, w.Height - w.Bmargin);
    let format = new YStringFormat(16384);
    format.LineAlignment = 1;
    format.Alignment = leftSide ? 2 : 0;
    let FirstStep = axis.startStopStep.step * Math.floor(axis.startStopStep.start / axis.startStopStep.step);
    if (FirstStep < 0) {
      FirstStep -= axis.startStopStep.step;
    }
    let stepCount = ((Delta - (FirstStep - axis.startStopStep.dataMin)) / axis.startStopStep.step >> 0) + 1;
    if (!simulation)
      g.TextRenderingHint = YTextRenderingHint.AntiAlias;
    let UnitWidth = 0;
    let labelPrecision = 0;
    if (axis.startStopStep.precision < 0)
      labelPrecision = -axis.startStopStep.precision;
    if (stepCount < w.Height) {
      for (let i = 0; i < stepCount; i++) {
        let y = Math.round((FirstStep + i * axis.startStopStep.step - axis.startStopStep.dataMin) / YZoom) >> 0;
        if (y >= 0) {
          y = w.Height - w.Bmargin - y;
          let v = FirstStep + i * axis.startStopStep.step;
          if (!simulation) {
            if (axis.showGrid && (i > 0 || axis.startStopStep.dataMin != 0))
              g.DrawLineXY(axis.gridPen, w.Lmargin, y, w.Width - w.Rmargin, y);
            if (Math.abs(v) < 1e-6 && axis.highlightZero) {
              g.DrawLineXY(axis.pen, w.Lmargin, y, w.Width - w.Rmargin, y);
            }
            g.DrawLineXY(axis.pen, x + (leftSide ? -2 : 2), y, x + (leftSide ? 5 : -5), y);
          }
          let label = v.toFixed(labelPrecision);
          let ssize = g.MeasureString(label, axis.font, 1e5);
          if (ssize.width > UnitWidth)
            UnitWidth = ssize.width;
          if (!simulation) {
            let p = new Point(x + (leftSide ? -3 : 3), y);
            g.DrawStringPF(label, axis.font, axis.font.brush, p, format);
          }
        }
      }
    }
    if (axis.legend.title != "") {
      let size = g.MeasureString(axis.legend.title, axis.legend.font, 1e5);
      if (!simulation) {
        let format2 = new YStringFormat(16384);
        format2.Alignment = 1;
        format2.LineAlignment = 1;
        format2.Trimming = 0;
        let legendX = x + (leftSide ? -UnitWidth - size.height : UnitWidth + size.height + 2) >> 0;
        let legendY = w.Tmargin + (w.Height - w.Tmargin - w.Bmargin) / 2 >> 0;
        g.Transform(legendX, legendY, leftSide ? -Math.PI / 2 : Math.PI / 2);
        g.DrawStringPF(axis.legend.title, axis.legend.font, axis.legend.font.brush, new Point(0, 0), format2);
        g.ResetTransform();
      }
      UnitWidth += size.height;
    }
    axis.innerWidth = (UnitWidth >> 0) + 10;
    return axis.innerWidth;
  }
  DrawMonitorXAxis(w, g, xRange, format) {
    let delta = xRange.Max - xRange.Min;
    let scale = TimeConverter.BestTimeformat(delta, delta, this.xAxis.timeReference);
    let XZoom = delta / (w.Width - w.Lmargin - w.Rmargin);
    let stepCount = (delta / scale.step >> 0) + 2;
    let FirstStep = scale.step * Math.floor(xRange.Min / scale.step);
    if (FirstStep < xRange.Min)
      FirstStep += scale.step;
    g.TextRenderingHint = YTextRenderingHint.AntiAlias;
    let y = w.Height - w.Bmargin;
    g.DrawLineXY(this._navigator.pen, w.Lmargin, w.Height - w.Bmargin - 1, w.Width - w.Rmargin, w.Height - w.Bmargin - 1);
    let label;
    let t = FirstStep;
    do {
      let d = TimeConverter.FromUnixTime(t);
      if (scale.step > 31.1 * 86400) {
        t = TimeConverter.ToUnixTime(new Date(d.getFullYear(), d.getMonth(), 1));
      }
      if (t >= xRange.Min) {
        let x = w.Lmargin + Math.round((t - xRange.Min) / XZoom);
        g.DrawLineXY(this._navigator.pen, x, y, x, y - 4);
        if (format == XAxis.FORMATAUTO) {
          label = TimeConverter.FromUnixTime(t).ToString(scale.format);
        } else {
          label = TimeConverter.FromUnixTime(t).ToString(format);
        }
        let ssize = g.MeasureString(label, this._navigator.font, 1e5);
        g.DrawString(label, this._navigator.font, this._navigator.font.brush, new Point(x - ssize.width / 2, y - ssize.height - 1));
      }
      t += scale.step;
    } while (t < xRange.Max);
  }
  static XLabel(t, scale, scaleFormat, timeRange) {
    let label;
    if (scale.timeReference == TimeConverter.TimeReference.ABSOLUTE) {
      if (scale.labelFormat == XAxis.FORMATAUTO) {
        label = TimeConverter.FromUnixTime(t).ToString(scaleFormat.format);
      } else {
        label = t.toString();
      }
    } else {
      let ticks = YTimeSpan.TicksPerSecond * (Math.round(1e3 * (t - scale.zeroTime)) / 1e3);
      label = ticks < 0 ? "-" + new YTimeSpan(-ticks).toString(scaleFormat.format) : new YTimeSpan(ticks).toString(scaleFormat.format);
    }
    return label;
  }
  DrawXAxis(w, g, scale, simulation) {
    if (w.Width - w.Rmargin - w.Lmargin < 10)
      return 1;
    let stringFormat = new YStringFormat(16384);
    stringFormat.Alignment = 1;
    let bottomSide = scale.position == XAxis.VrtPosition.BOTTOM;
    let y = bottomSide ? w.Height - w.Bmargin : w.Tmargin;
    if (!simulation)
      g.DrawLineXY(scale.pen, w.Lmargin, y, w.Width - w.Rmargin, y);
    let delta = scale.max - scale.min;
    let XZoom = delta / (w.Width - w.Lmargin - w.Rmargin);
    let stepCount = (delta / scale.step >> 0) + 1;
    let FirstStep = 0;
    let timeRange = MinMaxHandler.DefaultValue();
    for (let i = 0; i < this._series.length; i++) {
      if (!this._series[i].disabled) {
        timeRange = MinMaxHandler.Combine(timeRange, this._series[i].timeRange);
      }
    }
    scale.zeroTime = timeRange.Min;
    if (scale.timeReference == TimeConverter.TimeReference.ABSOLUTE) {
      FirstStep = scale.step * Math.floor(scale.min / scale.step);
      timeRange.Min = scale.min;
      timeRange.Max = scale.max;
    } else {
      if (Number.isNaN(timeRange.Min))
        return 0;
      FirstStep = timeRange.Min + scale.step * Math.floor((scale.min - scale.zeroTime) / scale.step);
    }
    if (FirstStep < scale.min)
      FirstStep += scale.step;
    let timeOffset = 0;
    if (scale.timeReference != TimeConverter.TimeReference.ABSOLUTE) {
      timeOffset = FirstStep;
    }
    scale.fullSize = timeRange.Max - timeRange.Min;
    let scaleFormat = scale.bestFormat(timeRange.Max - timeRange.Min, scale.max - scale.min);
    if (!simulation)
      g.TextRenderingHint = YTextRenderingHint.AntiAlias;
    let UnitHeight = 0;
    let label;
    scale.step = scaleFormat.step;
    let t = parseFloat(FirstStep.toString());
    label = YGraph.XLabel(t, scale, scaleFormat, timeRange);
    let ssize = g.MeasureString(label, scale.font, 1e5);
    let mod = 1;
    while (mod * (w.Width - w.Rmargin - w.Lmargin) / stepCount < ssize.width) {
      mod++;
    }
    let steps = Math.round((t - timeOffset) / scale.step) >> 0;
    let previousT = 0;
    do {
      let d = TimeConverter.FromUnixTime(t);
      if (scale.step > 32 * 86400 && scale.timeReference == TimeConverter.TimeReference.ABSOLUTE) {
        if (scale.step >= 365 * 86400) {
          let m = d.getMonth();
          t = TimeConverter.ToUnixTime(new Date(d.getFullYear() + (m > 5 ? 1 : 0), 0, 1));
        } else
          t = TimeConverter.ToUnixTime(new Date(d.getFullYear(), d.getMonth(), 1));
        if (t < previousT) {
          debugger;
        }
      }
      if (t >= scale.min) {
        let x = w.Lmargin + Math.round((t - scale.min) / XZoom) >> 0;
        if (x <= w.Width - w.Rmargin) {
          if (!simulation) {
            if (scale.showGrid)
              g.DrawLineXY(scale.gridPen, x, w.Tmargin, x, w.Height - w.Bmargin);
            g.DrawLineXY(scale.pen, x, y + (bottomSide ? 2 : -2), x, y + (bottomSide ? -5 : 5));
          }
          label = YGraph.XLabel(t, scale, scaleFormat, timeRange);
          ssize = g.MeasureString(label, scale.font, 1e5);
          if (ssize.height > UnitHeight)
            UnitHeight = ssize.height;
          if (!simulation) {
            if (steps % mod == 0) {
              g.DrawStringPF(label, scale.font, scale.font.brush, new PointF(x, y + (bottomSide ? 5 : -ssize.height >> 0) - 2), stringFormat);
            }
          }
        }
      }
      previousT = t;
      t += scale.step;
      if (t < previousT)
        debugger;
      steps++;
    } while (t <= scale.max);
    if (scale.legend.title != "") {
      let size = g.MeasureString(scale.legend.title, scale.legend.font, 1e5);
      if (!simulation) {
        let legendX = w.Lmargin + (w.Width - w.Lmargin - w.Rmargin - size.width) / 2 >> 0;
        let legendY = bottomSide ? w.Height - w.Bmargin + UnitHeight + 5 : w.Tmargin - UnitHeight - size.height * 1.5;
        g.DrawString(scale.legend.title, scale.legend.font, scale.legend.font.brush, new PointF(legendX, legendY));
      }
      UnitHeight += size.height >> 0;
    }
    scale.innerHeight = (UnitHeight >> 0) + 10;
    return scale.innerHeight;
  }
  pixelxSize(mainViewPort, scaleX) {
    let dtime = scaleX.max - scaleX.min;
    let dview = mainViewPort.Width - mainViewPort.Lmargin - mainViewPort.Rmargin;
    if (dview > 0)
      return dtime / dview;
    return 0;
  }
  TimeToAutoSting(t, mainViewPort, scaleX) {
    let strValue = "";
    let dtime = scaleX.max - scaleX.min;
    let months = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
    if (dtime > 0) {
      let pixelSize = this.pixelxSize(mainViewPort, scaleX);
      if (pixelSize > 0) {
        if (scaleX.timeReference == TimeConverter.TimeReference.ABSOLUTE) {
          let date = TimeConverter.FromUnixTime(t);
          let MMMM = months[date.getMonth()];
          let dd = date.getDate().toString();
          let HH = date.getHours().toString();
          if (HH.length < 2)
            HH = "0" + HH;
          let mm = date.getMinutes().toString();
          if (mm.length < 2)
            mm = "0" + mm;
          let ss = date.getSeconds().toString();
          if (ss.length < 2)
            ss = "0" + ss;
          let ff = Math.round(date.getMilliseconds() / 10).toString();
          if (ff.length < 2)
            ff = "0" + ss;
          let f = Math.round(date.getMilliseconds() / 100).toString();
          if (dtime >= 86400)
            strValue += MMMM + " " + dd;
          if (pixelSize < 0.1) {
            strValue += (strValue != "" ? " " : "") + HH + ":" + mm + ":" + ss + "." + ff;
          } else if (pixelSize < 1) {
            strValue += (strValue != "" ? " " : "") + HH + ":" + mm + ":" + ss + "." + f;
          } else if (pixelSize < 60) {
            strValue += (strValue != "" ? " " : "") + HH + ":" + mm + ":" + ss;
          } else if (pixelSize < 3600) {
            strValue += (strValue != "" ? " " : "") + HH + ":" + mm;
          } else if (pixelSize < 86400)
            strValue += (strValue != "" ? " " : "") + HH + "H";
        } else {
          let format = TimeConverter.RelativeFormat(scaleX.fullSize, dtime, pixelSize);
          let ticks = YTimeSpan.TicksPerSecond * (Math.round(100 * (t - scaleX.zeroTime)) / 100);
          strValue += ticks < 0 ? "-" + new YTimeSpan(-ticks).toString(format) : new YTimeSpan(ticks).toString(format);
        }
      }
    }
    return strValue;
  }
  DrawDataTracker(g, viewPortWidth, viewPortHeight, scaleX) {
    if (!this._dataTracker.enabled) {
      return;
    }
    let p = this.mouseLocalPosition();
    if (p == null) {
      return;
    }
    if (p.X <= this.mainViewPort.Lmargin) {
      return;
    }
    if (p.Y <= this.mainViewPort.Tmargin) {
      return;
    }
    if (p.X >= this.UIContainer.width - this.mainViewPort.Rmargin) {
      return;
    }
    if (p.Y >= this.UIContainer.height - this.mainViewPort.Bmargin) {
      return;
    }
    g.SetClip(new YRectangle(0, 0, viewPortWidth, viewPortHeight));
    let DataPoint = YGraph.ViewPortPointToIRL(this.mainViewPort, p);
    let delta = -1;
    let bestindex = -1;
    let bestmatch = new Array(this._series.length);
    let IRLmatch = new Array(this._series.length);
    for (let i = 0; i < this._series.length; i++) {
      if (this._series[i].visible && !this._series[i].disabled) {
        let p2 = this._series[i].findClosestValue(DataPoint.x, false);
        if (p2 != null) {
          IRLmatch[i] = p2;
          bestmatch[i] = YGraph.IRLPointToViewPort(this.mainViewPort, IRLmatch[i], this.yAxes[this._series[i].yAxisIndex].IRLy, this.yAxes[this._series[i].yAxisIndex].zoom);
          if (bestindex < 0 || delta > Math.abs(bestmatch[i].Y - p.Y)) {
            delta = Math.abs(bestmatch[i].Y - p.Y);
            if (this._dataTracker.detectionDistance == 0 || delta <= this._dataTracker.detectionDistance && Math.abs(bestmatch[i].X - p.X) < this._dataTracker.detectionDistance) {
              bestindex = i;
            }
          }
        }
      }
    }
    if (bestindex >= 0) {
      let xx = bestmatch[bestindex].X - this._dataTracker.diameter / 2 >> 0;
      let yy = bestmatch[bestindex].Y - this._dataTracker.diameter / 2 >> 0;
      let dd = this._dataTracker.diameter;
      g.FillEllipse(this._series[bestindex].brush, xx, yy, dd, dd);
      g.DrawEllipse(this._dataTracker.pen, xx, yy, dd, dd);
      let dx;
      let dy;
      if (p.X > this.mainViewPort.Lmargin + (viewPortWidth - this.mainViewPort.Lmargin - this.mainViewPort.Rmargin) / 2)
        dx = -1;
      else
        dx = 1;
      if (p.Y > this.mainViewPort.Tmargin + (viewPortHeight - this.mainViewPort.Tmargin - this.mainViewPort.Bmargin) / 2)
        dy = -1;
      else
        dy = 1;
      let xx2 = bestmatch[bestindex].X + dx * (this._dataTracker.handleLength * 1.5) >> 0;
      let yy2 = bestmatch[bestindex].Y + dy * this._dataTracker.handleLength >> 0;
      g.DrawLineXY(this._dataTracker.pen, bestmatch[bestindex].X + dx * 0.707 * this._dataTracker.diameter / 2 >> 0, bestmatch[bestindex].Y + dy * 0.707 * this._dataTracker.diameter / 2 >> 0, bestmatch[bestindex].X + dx * this._dataTracker.handleLength >> 0, bestmatch[bestindex].Y + dy * this._dataTracker.handleLength >> 0);
      g.DrawLineXY(this._dataTracker.pen, bestmatch[bestindex].X + dx * this._dataTracker.handleLength >> 0, bestmatch[bestindex].Y + dy * this._dataTracker.handleLength >> 0, xx2, yy2);
      let strValue = "";
      if (this._dataTracker.showSerieName)
        strValue += this._series[bestindex].legend + "\r\n";
      if (this._dataTracker.showTimeStamp) {
        let t = IRLmatch[bestindex].x;
        strValue += this.TimeToAutoSting(t, this.mainViewPort, scaleX) + "\r\n";
      }
      if (this._dataTracker.dataPrecision.toString == DataTracker.DataPrecision.PRECISION_NOLIMIT.toString) {
        strValue += IRLmatch[bestindex].y.toString() + this._series[bestindex].unit;
      } else {
        let strvalue = this._dataTracker.dataPrecision.description;
        let precision = -Math.log10(Number(strvalue));
        strValue += IRLmatch[bestindex].y.toFixed(precision) + this._series[bestindex].unit;
      }
      let ssize = g.MeasureString(strValue, this._dataTracker.font, 1e4);
      let labelwidth = ssize.width + 2 * this._dataTracker.padding + this._dataTracker.borderthickness;
      let labelHeight = ssize.height + 2 * this._dataTracker.padding + this._dataTracker.borderthickness;
      if (dx > 0) {
        g.FillRectangleXYHW(this._dataTracker.bgBrush, xx2, yy2 - (labelHeight >> 1), labelwidth, labelHeight);
        g.DrawRectangleXYHW(this._dataTracker.pen, xx2, yy2 - (labelHeight >> 1), labelwidth, labelHeight);
        g.DrawStringXY(strValue, this._dataTracker.font, this._dataTracker.font.brush, xx2 + this._dataTracker.padding >> 0, yy2 - (labelHeight >> 1) + this._dataTracker.padding >> 0);
      } else {
        g.FillRectangleXYHW(this._dataTracker.bgBrush, xx2 - labelwidth, yy2 - (labelHeight >> 1), labelwidth, labelHeight);
        g.DrawRectangleXYHW(this._dataTracker.pen, xx2 - labelwidth, yy2 - (labelHeight >> 1), labelwidth, labelHeight);
        g.DrawStringXY(strValue, this._dataTracker.font, this.dataTracker.font.brush, xx2 + this._dataTracker.padding - labelwidth >> 0, yy2 - (labelHeight >> 1) + this._dataTracker.padding >> 0);
      }
    }
  }
  DrawMarkers(w, g, scaleX, viewPortWidth, viewPortHeight) {
    if (this._xAxis.markers.length == 0)
      return;
    g.SetClip(new YRectangle(w.Lmargin, w.Tmargin, w.Width - w.Rmargin - w.Lmargin, w.Height - w.Bmargin - w.Tmargin));
    let Bottomleft = YGraph.ViewPortPointToIRL(w, new Point(w.Lmargin, w.Height - w.Bmargin));
    let TopRight = YGraph.ViewPortPointToIRL(w, new Point(w.Width - w.Rmargin, w.Tmargin));
    let dy = (w.Height - w.Bmargin - w.Tmargin) / 100;
    let pixelSize = -1;
    g.TextRenderingHint = YTextRenderingHint.AntiAlias;
    for (let i = 0; i < this._xAxis.markers.length; i++) {
      if (this._xAxis.markers[i].enabled) {
        if (pixelSize < 0)
          pixelSize = this.pixelxSize(this.mainViewPort, scaleX);
        let mustdraw = true;
        let xpos = 0;
        if (this._xAxis.markers[i].timereference == TimeConverter.TimeReference.RELATIVE) {
          if (this._xAxis.zeroTime > 0) {
            xpos = this._xAxis.markers[i].xposition + this._xAxis.zeroTime;
          } else {
            mustdraw = false;
          }
        } else {
          xpos = this._xAxis.markers[i].xposition;
        }
        if (xpos > Bottomleft.x - 100 * pixelSize && xpos < TopRight.x + 100 * pixelSize && mustdraw) {
          let p = YGraph.IRLPointToViewPort(w, new pointXY(xpos, 0));
          let xxCenter = p.X >> 0;
          let yyCenter = w.Height - w.Bmargin - this._xAxis.markers[i].yposition * dy >> 0;
          let strValue = this._xAxis.markers[i].text.replace("\\n", "\n");
          let now = new Date();
          if (strValue.indexOf("$") >= 0) {
            if (strValue.indexOf("$MARKERTIME$") >= 0) {
              let s = this._xAxis.markers[i].timereference == TimeConverter.TimeReference.RELATIVE ? TimeConverter.secTimeSpanToString(this._xAxis.markers[i].xposition, pixelSize) : this.TimeToAutoSting(this._xAxis.markers[i].xposition, this.mainViewPort, scaleX);
              strValue = strValue.replace("$MARKERTIME$", s);
            }
            if (strValue.indexOf("$VALUE") >= 0) {
              for (let j = 0; j < this._series.length; j++) {
                if (!this._series[j].disabled) {
                  let pt = this._series[j].findClosestValue(xpos, true);
                  let st = pt != null ? pt.y.toFixed(0) : "--";
                  strValue = strValue.replace("$VALUE" + (j + 1).toString() + "$", st);
                } else {
                  strValue = strValue.replace("$VALUE" + (j + 1).toString() + "$", "");
                }
              }
            }
            if (strValue.indexOf("$UNIT") >= 0) {
              for (let j = 0; j < this._series.length; j++) {
                if (!this._series[j].disabled) {
                  strValue = strValue.replace("$UNIT" + (j + 1).toString() + "$", this._series[j].unit);
                } else {
                  strValue = strValue.replace("$UNIT" + (j + 1).toString() + "$", "");
                }
              }
            }
            if (strValue.indexOf("$LEGEND") >= 0) {
              for (let j = 0; j < this._series.length; j++) {
                if (!this._series[j].disabled) {
                  strValue = strValue.replace("$LEGEND" + (j + 1).toString() + "$", this._series[j].legend);
                } else {
                  strValue = strValue.replace("$LEGEND" + (j + 1).toString() + "$", "");
                }
              }
            }
            if (this._xAxis.markers[i].PatchTextCallback != null) {
              strValue = this._xAxis.markers[i].PatchTextCallback(strValue);
            }
          }
          let ssize = g.MeasureString(strValue, this._xAxis.markers[i].font, 1e4);
          let labelWidth = ssize.width + 2 * this._xAxis.markers[i].padding + this._xAxis.markers[i].borderthickness;
          let labelHeight = ssize.height + 2 * this._xAxis.markers[i].padding + this._xAxis.markers[i].borderthickness;
          g.FillRectangleXYHW(this._xAxis.markers[i].bgBrush, xxCenter - (labelWidth >> 1), yyCenter - (labelHeight >> 1), labelWidth >> 0, labelHeight >> 0);
          g.DrawRectangleXYHW(this._xAxis.markers[i].pen, xxCenter - (labelWidth >> 1), yyCenter - (labelHeight >> 1), labelWidth >> 0, labelHeight >> 0);
          let xText;
          switch (this._xAxis.markers[i].textAlign) {
            case Marker.TextAlign.LEFT:
              xText = xxCenter - (labelWidth >> 1) + this._xAxis.markers[i].padding;
              break;
            case Marker.TextAlign.RIGHT:
              xText = xxCenter + (labelWidth >> 1) - this._xAxis.markers[i].padding;
              break;
            default:
              xText = xxCenter;
              break;
          }
          g.DrawStringPF(strValue, this._xAxis.markers[i].font, this._xAxis.markers[i].font.brush, new PointF(xText, yyCenter), this._xAxis.markers[i].stringFormat);
          g.DrawLineXY(this._xAxis.markers[i].pen, xxCenter, w.Tmargin >> 0, xxCenter, yyCenter - (labelHeight >> 1));
          g.DrawLineXY(this._xAxis.markers[i].pen, xxCenter, yyCenter + (labelHeight >> 1), xxCenter, w.Height - w.Bmargin >> 0);
          if (this._xAxis.markers[i].arrowSize > 0) {
            if (this._xAxis.markers[i].yposition > 25) {
              let triangle = [
                new PointF(xxCenter - this._xAxis.markers[i].arrowSize, yyCenter + (labelHeight >> 1)),
                new PointF(xxCenter + this._xAxis.markers[i].arrowSize, yyCenter + (labelHeight >> 1)),
                new PointF(xxCenter, yyCenter + (labelHeight >> 1) + this._xAxis.markers[i].arrowSize)
              ];
              g.FillPolygon(this._xAxis.markers[i].arrowBrush, triangle);
            }
            if (this._xAxis.markers[i].yposition < 75) {
              let triangle = [
                new PointF(xxCenter - this._xAxis.markers[i].arrowSize, yyCenter + (labelHeight >> 1)),
                new PointF(xxCenter + this._xAxis.markers[i].arrowSize, yyCenter + (labelHeight >> 1)),
                new PointF(xxCenter, yyCenter - (labelHeight >> 1) - this._xAxis.markers[i].arrowSize)
              ];
              g.FillPolygon(this._xAxis.markers[i].arrowBrush, triangle);
            }
          }
        }
      }
    }
    g.ResetClip();
  }
  DrawDataPanels(w, g, scaleX, scalesY, viewPortWidth, viewPortHeight) {
    if (this._dataPanels.length == 0)
      return;
    g.SetClip(new YRectangle(w.Lmargin, w.Tmargin, w.Width - w.Rmargin - w.Lmargin, w.Height - w.Bmargin - w.Tmargin));
    for (let i = 0; i < this._dataPanels.length; i++) {
      if (this._dataPanels[i].enabled) {
        let p = this._dataPanels[i];
        if (p.yScaleIndex < scalesY.length) {
          let AvailableWidth = w.Width - 2 * p.padding - p.borderthickness;
          if (AvailableWidth < 100)
            AvailableWidth = 100;
          let ssize = g.MeasureString(p.text, p.font, AvailableWidth >> 0);
          let panelWidth = ssize.width + 2 * p.padding + p.borderthickness;
          let panelHeight = ssize.height + 2 * p.padding + p.borderthickness;
          let x = 0;
          switch (p.horizontalPosition) {
            case DataPanel.HorizontalPosition.LEFTBORDER:
              x = w.Lmargin;
              break;
            case DataPanel.HorizontalPosition.RIGHTBORDER:
              x = w.Width - w.Rmargin;
              break;
            case DataPanel.HorizontalPosition.ABSOLUTEX:
              let delta = scaleX.max - scaleX.min;
              let XZoom = delta / (w.Width - w.Lmargin - w.Rmargin);
              x = w.Lmargin + Math.round((p.AbsoluteXposition - scaleX.min) / XZoom) >> 0;
              break;
          }
          let y = 0;
          switch (p.verticalPosition) {
            case DataPanel.VerticalPosition.TOPBORDER:
              y = w.Tmargin;
              break;
            case DataPanel.VerticalPosition.BOTTOMBORDER:
              y = w.Height - w.Bmargin;
              break;
            case DataPanel.VerticalPosition.ABSOLUTEY:
              y = w.Height - w.Bmargin - Math.round((p.AbsoluteYposition - scalesY[p.yScaleIndex].IRLy) * scalesY[p.yScaleIndex].zoom) >> 0;
              break;
          }
          switch (p.panelHrzAlign) {
            case DataPanel.HorizontalAlign.LEFTOF:
              x -= panelWidth + p.horizontalMargin;
              break;
            case DataPanel.HorizontalAlign.RIGHTOF:
              x += p.horizontalMargin;
              break;
            default:
              x -= panelWidth / 2;
              break;
          }
          switch (p.panelVrtAlign) {
            case DataPanel.VerticalAlign.ABOVE:
              y -= panelHeight + p.verticalMargin;
              break;
            case DataPanel.VerticalAlign.BELOW:
              y += p.verticalMargin;
              break;
            default:
              y -= panelHeight / 2;
              break;
          }
          g.FillRectangleXYHW(p.bgBrush, x >> 0, y >> 0, panelWidth >> 0, panelHeight >> 0);
          if (p.borderthickness > 0)
            g.DrawRectangleXYHW(p.pen, x >> 0, y >> 0, panelWidth >> 0, panelHeight >> 0);
          let sf = new YStringFormat(16384);
          switch (p.panelTextAlign) {
            case MessagePanel.TextAlign.LEFT:
              sf.LineAlignment = 0;
              sf.Alignment = 0;
              break;
            case MessagePanel.TextAlign.RIGHT:
              sf.LineAlignment = 2;
              sf.Alignment = 2;
              break;
            default:
              sf.LineAlignment = 1;
              sf.Alignment = 1;
              break;
          }
          let rect = new YRectangle(x + p.padding + p.borderthickness / 2 >> 0, y + p.padding + p.borderthickness / 2 >> 0, ssize.width >>= 1, (ssize.height >> 0) + 1);
          g.DrawStringRect(p.text, p.font, p.font.brush, rect, sf);
        } else {
          throw new RangeError("Cannot renderer data panel #" + i.toString() + ", no such Y axis");
        }
      }
    }
  }
  findSegmentIndex(serieIndex, timeStamp, debug) {
    let s = this._series[serieIndex];
    if (s.segments.length <= 0)
      return -1;
    let start = 0;
    let end = s.segments.length - 1;
    if (debug) {
      console.log("looking for " + timeStamp);
      for (let i = 0; i < s.segments.length; i++)
        console.log("seg " + i + " [" + s.segments[i].data[0].x + ".." + s.segments[i].data[s.segments[i].count - 1].x + "]");
      debugger;
    }
    while (true) {
      let startSeg = s.segments[start];
      let endSeg = s.segments[end];
      if (timeStamp > startSeg.data[startSeg.count - 1].x)
        return start - 0.5;
      if (timeStamp < endSeg.data[0].x)
        return end + 0.5;
      if (timeStamp >= startSeg.data[0].x)
        return start;
      if (timeStamp <= endSeg.data[endSeg.count - 1].x)
        return end;
      if (end == start) {
        debugger;
        return -99;
      }
      if (end - start == 1)
        return start + 0.5;
      let middle = start + end >> 1;
      let middleSeg = s.segments[middle];
      if (timeStamp <= middleSeg.data[middleSeg.count - 1].x) {
        end = end - 1;
        start = middle;
      } else {
        end = middle - 1;
        start = start + 1;
      }
    }
  }
  findTimestampIndexInSegment(serieIndex, segmentIndex, timeStamp) {
    let seg = this._series[serieIndex].segments[segmentIndex];
    if (!seg)
      debugger;
    if (timeStamp <= seg.data[0].x)
      return 0;
    let count = this._series[serieIndex].segments[segmentIndex].count;
    if (timeStamp >= seg.data[count - 1].x)
      return count - 1;
    let start = 0;
    let end = count - 1;
    let middle = 0;
    while (true) {
      if (end - start <= 1) {
        if (timeStamp <= seg.data[start].x)
          return start;
        return end;
      }
      middle = start + end >> 1;
      if (timeStamp <= seg.data[middle].x)
        end = middle;
      else
        start = middle;
    }
  }
  Render(g, UIw, UIh) {
    if (UIw < 50 || UIh < 50)
      return 0;
    let lastLmargin = this.mainViewPort.Lmargin;
    let lastRmargin = this.mainViewPort.Rmargin;
    this.mainViewPort.Width = UIw;
    this.mainViewPort.Height = UIh;
    this.mainViewPort.Lmargin = 0;
    this.mainViewPort.Rmargin = 0;
    g.SmoothingMode = YSmoothingMode.HighQuality;
    let yMarginOffset = 5;
    for (let i = 0; i < this._yAxes.length; i++) {
      if (this._yAxes[i].visible) {
        let s = g.MeasureString("8", this._yAxes[i].font, 1e5);
        let o = (s.height + 1) / 2 >> 0;
        if (yMarginOffset < o)
          yMarginOffset = o;
      }
    }
    this.mainViewPort.Tmargin = this._xAxis.position == XAxis.VrtPosition.TOP ? 0 : yMarginOffset;
    this.mainViewPort.Bmargin = this._xAxis.position == XAxis.VrtPosition.BOTTOM ? 0 : yMarginOffset;
    if (!this._legendPanel.overlap)
      this.drawLegendPanel(g, UIw, UIh, this.mainViewPort);
    this.drawAnnotationPanels(g, this._annotationPanels, UIw, UIh, false, this.mainViewPort);
    if (this.mainViewPort.Bmargin == 0)
      this.mainViewPort.Bmargin = 5;
    if (this.mainViewPort.Tmargin == 0)
      this.mainViewPort.Tmargin = 5;
    let h = this.DrawXAxis(this.mainViewPort, g, this._xAxis, true);
    if (this._xAxis.position == XAxis.VrtPosition.TOP)
      this.mainViewPort.Tmargin += h;
    else
      this.mainViewPort.Bmargin += h;
    this.mainViewPort.IRLx = this._xAxis.min;
    let M;
    for (let i = 0; i < this._yAxes.length; i++) {
      M = MinMaxHandler.DefaultValue();
      for (let k = 0; k < this._series.length; k++) {
        if (this._series[k].yAxisIndex == i && !this._series[k].disabled) {
          for (let j = 0; j < this._series[k].segments.length; j++) {
            M = MinMaxHandler.Combine(M, YGraph.FindMinMax(this._xAxis.min, this._xAxis.max, this._series[k].segments[j].data, this._series[k].segments[j].count));
          }
        }
      }
      this._yAxes[i].computeStartAndStep(M);
    }
    if (this.mainViewPort.Lmargin == 0)
      this.mainViewPort.Lmargin = 5;
    if (this.mainViewPort.Rmargin == 0)
      this.mainViewPort.Rmargin = 5;
    for (let i = 0; i < this._yAxes.length; i++) {
      let sw = YGraph.DrawYAxis(this.mainViewPort, g, this._yAxes[i], 0, true);
      this.mainViewPort.Lmargin += this._yAxes[i].position == YAxis.HrzPosition.LEFT ? sw : 0;
      this.mainViewPort.Rmargin += this._yAxes[i].position == YAxis.HrzPosition.RIGHT ? sw : 0;
    }
    if (this._navigator.enabled) {
      if (lastLmargin != this.mainViewPort.Lmargin || lastRmargin != this.mainViewPort.Rmargin) {
        this.navigatorCache = null;
      }
      let nh = this._navigator.relativeheight * this.UIContainer.height / 100 >> 0;
      let ofset = this.xAxis.position == XAxis.VrtPosition.BOTTOM ? h : 0;
      this._navigator.setPosition(UIw, UIh, this.mainViewPort.Lmargin, this.mainViewPort.Rmargin, this.mainViewPort.Height - nh - this.mainViewPort.Bmargin + ofset, this.mainViewPort.Bmargin - ofset);
      this.mainViewPort.Bmargin += nh;
    }
    if (this.lastTopMargin != this.mainViewPort.Tmargin || this.lastBottomMargin != this.mainViewPort.Bmargin) {
      this._bgBrush = null;
      this.lastTopMargin = this.mainViewPort.Tmargin;
      this.lastBottomMargin = this.mainViewPort.Bmargin;
    }
    if (this._bgBrush == null) {
      this._bgBrush = new YLinearGradientBrush(this._bgColor2, this._bgColor1);
    }
    g.FillRectangleXYHW(this._bgBrush, this.mainViewPort.Lmargin, this.mainViewPort.Tmargin, this.mainViewPort.Width - this.mainViewPort.Rmargin - this.mainViewPort.Lmargin, this.mainViewPort.Height - this.mainViewPort.Bmargin - this.mainViewPort.Tmargin);
    if (this._borderThickness > 0) {
      if (this._borderPen == null)
        this._borderPen = new YPen(this._borderColor, this._borderThickness);
      g.DrawRectangleXYHW(this._borderPen, this.mainViewPort.Lmargin, this.mainViewPort.Tmargin, this.mainViewPort.Width - this.mainViewPort.Rmargin - this.mainViewPort.Lmargin, this.mainViewPort.Height - this.mainViewPort.Bmargin - this.mainViewPort.Tmargin);
    }
    g.SetClip(new YRectangle(this.mainViewPort.Lmargin, this.mainViewPort.Tmargin, this.mainViewPort.Width - this.mainViewPort.Rmargin - this.mainViewPort.Lmargin, this.mainViewPort.Height - this.mainViewPort.Bmargin - this.mainViewPort.Tmargin));
    for (let i = 0; i < this._yAxes.length; i++) {
      this.DrawYAxisZones(this.mainViewPort, g, this._yAxes[i]);
    }
    this.DrawXAxisZones(this.mainViewPort, g, this.xAxis);
    g.ResetClip();
    this.DrawXAxis(this.mainViewPort, g, this._xAxis, false);
    let leftOffset = 0;
    let rightOffset = 0;
    for (let i = 0; i < this._yAxes.length; i++) {
      let ww = YGraph.DrawYAxis(this.mainViewPort, g, this._yAxes[i], this._yAxes[i].position == YAxis.HrzPosition.LEFT ? leftOffset : rightOffset, false);
      if (this._yAxes[i].position == YAxis.HrzPosition.LEFT)
        leftOffset += ww;
      if (this._yAxes[i].position == YAxis.HrzPosition.RIGHT)
        rightOffset += ww;
    }
    g.SetClip(new YRectangle(this.mainViewPort.Lmargin, this.mainViewPort.Tmargin, this.mainViewPort.Width - this.mainViewPort.Rmargin - this.mainViewPort.Lmargin, this.mainViewPort.Height - this.mainViewPort.Bmargin - this.mainViewPort.Tmargin));
    this.mainViewPort.zoomx = (this.mainViewPort.Width - this.mainViewPort.Lmargin - this.mainViewPort.Rmargin) / (this._xAxis.max - this._xAxis.min);
    let mypenb = null;
    let lineCount = 0;
    let pointCount = 0;
    let Bottomleft = YGraph.ViewPortPointToIRL(this.mainViewPort, new Point(this.mainViewPort.Lmargin, this.mainViewPort.Height - this.mainViewPort.Bmargin));
    let TopRight = YGraph.ViewPortPointToIRL(this.mainViewPort, new Point(this.mainViewPort.Width - this.mainViewPort.Rmargin, this.mainViewPort.Tmargin));
    let xTimeStart = Bottomleft.x;
    let xTimeEnd = TopRight.x;
    let availabelPixelWidth = this.mainViewPort.Width - this.mainViewPort.Rmargin - this.mainViewPort.Lmargin;
    for (let k = 0; k < this._series.length; k++) {
      if (this._series[k].visible && !this._series[k].disabled && this._series[k].segments.length > 0) {
        let scaleIndex = this._series[k].yAxisIndex;
        mypenb = this._series[k].pen;
        this.mainViewPort.IRLy = this._yAxes[scaleIndex].startStopStep.dataMin;
        this._yAxes[this._series[k].yAxisIndex].IRLy = this.mainViewPort.IRLy;
        let delta = this._yAxes[scaleIndex].startStopStep.dataMax - this._yAxes[scaleIndex].startStopStep.dataMin;
        if (delta == 0) {
          delta = 1;
          this.mainViewPort.IRLy -= delta / 2;
        }
        this.mainViewPort.zoomy = (this.mainViewPort.Height - this.mainViewPort.Tmargin - this.mainViewPort.Bmargin) / delta;
        this._yAxes[this._series[k].yAxisIndex].zoom = this.mainViewPort.zoomy;
        g.comment("** main view-port series " + k.toString());
        let FirstSegmentIndexTmp = this.findSegmentIndex(k, xTimeEnd, false);
        let LastSegmentIndexTmp = this.findSegmentIndex(k, xTimeStart, false);
        let inside = true;
        let maxIndex = this._series[k].segments.length - 1;
        if (FirstSegmentIndexTmp < 0 && LastSegmentIndexTmp < 0) {
          inside = false;
        }
        if (FirstSegmentIndexTmp > maxIndex && LastSegmentIndexTmp > maxIndex) {
          inside = false;
        }
        if (inside) {
          let FirstSegmentIndex = Math.floor(FirstSegmentIndexTmp + 0.5);
          let LastSegmentIndex = Math.floor(LastSegmentIndexTmp);
          if (LastSegmentIndex < 0) {
            throw new Error("findSegmentIndex return an invalid index (" + LastSegmentIndex + ")");
          }
          if (FirstSegmentIndex < 0) {
            throw new Error("findSegmentIndex return an invalid index (" + FirstSegmentIndex + ")!");
          }
          if (FirstSegmentIndex > this._series[k].segments.length - 1) {
            throw new Error("findSegmentIndex return an invalid index (" + FirstSegmentIndex + ")!!");
          }
          if (LastSegmentIndex > this._series[k].segments.length - 1) {
            throw new Error("findSegmentIndex return an invalid index (" + LastSegmentIndex + ")!!!");
          }
          let firstDataIndex = this.findTimestampIndexInSegment(k, FirstSegmentIndex, xTimeEnd);
          let lastDataIndex = this.findTimestampIndexInSegment(k, LastSegmentIndex, xTimeStart);
          let totalPointsToDraw = 0;
          if (FirstSegmentIndex == LastSegmentIndex)
            totalPointsToDraw = firstDataIndex - lastDataIndex;
          else if (FirstSegmentIndex < LastSegmentIndex) {
            totalPointsToDraw = this._series[k].segments[LastSegmentIndex].count - lastDataIndex + firstDataIndex;
            for (let i = FirstSegmentIndex + 1; i < LastSegmentIndex; i++)
              totalPointsToDraw += this._series[k].segments[i].count;
          }
          let density = Math.round(totalPointsToDraw / availabelPixelWidth);
          if (density < SUMMARY_GRANULARITY || SUMMARY_GRANULARITY <= 0) {
            for (let i = 0; i < this._series[k].segments.length; i++) {
              lineCount += YGraph.DoSegmentRendering(this.mainViewPort, g, mypenb, this._series[k].segments[i].data, this._series[k].segments[i].count, xTimeStart, xTimeEnd);
              pointCount += this._series[k].segments[i].count;
            }
          } else {
            let level = Math.floor(Math.log(density) / Math.log(SUMMARY_GRANULARITY)) - 1;
            let s = this._series[k].summaries[level];
            let finalpoint = null;
            for (let i = 0; i < s.segments.length; i++) {
              if (i == s.segments.length - 1) {
                finalpoint = s.getBufferpoint();
              }
              lineCount += YGraph.DoSummarySegmentRendering(this.mainViewPort, g, mypenb, s.segments[i].data, s.segments[i].ptCount, finalpoint, xTimeStart, xTimeEnd);
              pointCount += s.segments[i].ptCount;
            }
          }
        } else
          console.log("Data are ouside dataview");
      }
    }
    g.ResetClip();
    if (this._navigator.enabled) {
      g.comment("** navigator **");
      let v = this._navigator.viewport;
      let range = MinMaxHandler.DefaultValue();
      for (let i = 0; i < this._series.length; i++) {
        if (!this._series[i].disabled)
          range = MinMaxHandler.Combine(range, this._series[i].timeRange);
      }
      this._navigator.Xrange = MinMaxHandler.extend(range, 1.05);
      v.zoomx = (v.Width - v.Lmargin - v.Rmargin) / (this._navigator.Xrange.Max - this._navigator.Xrange.Min);
      if (this.lastPointCount != pointCount && !this.mainViewPort.Capture && !this._navigator.Capture || this.navigatorCache == null || g instanceof YGraphicsSVG) {
        g.comment("Redraw navigator");
        if (this.navigatorCache != null)
          this.navigatorCache = null;
        this.navigatorCache = document.createElement("canvas");
        this.navigatorCache.width = v.Width;
        this.navigatorCache.height = v.Height;
        this.lastPointCount = pointCount;
        let ng;
        if (g instanceof YGraphicsSVG) {
          ng = g;
        } else {
          ng = new YGraphics(this.navigatorCache, v.Width, v.Height, 90);
        }
        ng.SetClip(new YRectangle(v.Lmargin, v.Tmargin, v.Width - v.Rmargin - v.Lmargin, v.Height - v.Bmargin - v.Tmargin));
        ng.FillRectangleXYHW(this._navigator.bgBrush, v.Lmargin, v.Tmargin, v.Width - v.Rmargin - v.Lmargin, v.Height - v.Bmargin - v.Tmargin);
        if (this.xAxis.zones.length > 0 && this._navigator.showXAxisZones) {
          let delta = this._navigator.Xrange.Max - this._navigator.Xrange.Min;
          let XZoom = delta / (v.Width - v.Lmargin - v.Rmargin);
          for (let i = 0; i < this.xAxis.zones.length; i++) {
            if (this.xAxis.zones[i].visible) {
              let min = this.xAxis.zones[i].min;
              let max = this.xAxis.zones[i].max;
              if (isNaN(min))
                min = this._navigator.Xrange.Min;
              if (isNaN(max))
                max = this._navigator.Xrange.Max;
              ng.FillRectangleXYHW(this.xAxis.zones[i].zoneBrush, v.Lmargin + (min - this._navigator.Xrange.Min) / XZoom >> 0, v.Tmargin >> 0, (max - min) / XZoom >> 0, v.Height - v.Bmargin - v.Tmargin);
            }
          }
        }
        if (MinMaxHandler.isDefined(this._navigator.Xrange) && this._navigator.Xrange.Max - this._navigator.Xrange.Min > 0) {
          let Min;
          let Max;
          v.IRLx = this._navigator.Xrange.Min;
          let dontSticktoBorderZoom = 4 / (v.Height - v.Bmargin - v.Tmargin);
          let Bottomleft2 = YGraph.ViewPortPointToIRL(v, new Point(v.Lmargin, v.Height - v.Bmargin));
          let TopRight2 = YGraph.ViewPortPointToIRL(v, new Point(v.Width - v.Rmargin, v.Tmargin));
          let xTimeStart2 = Bottomleft2.x;
          let xTimeEnd2 = TopRight2.x;
          if (this._navigator.yAxisHandling == Navigator.YAxisHandling.AUTO) {
            for (let k = 0; k < this._series.length; k++) {
              if (!this._series[k].disabled) {
                ng.comment("** navigator series " + k.toString());
                v.IRLy = this._series[k].valueRange.Min;
                let yAxisIndex = this._series[k].yAxisIndex;
                mypenb = this._series[k].navigatorpen;
                Min = this._series[k].valueRange.Min;
                Max = this._series[k].valueRange.Max;
                if (Max - Min <= 0) {
                  v.IRLy = Min - 0.5;
                  Max = Min + 0.5;
                } else {
                  let delta = Max - Min;
                  Min -= delta * dontSticktoBorderZoom;
                  Max += delta * dontSticktoBorderZoom;
                }
                v.IRLy = Min;
                v.zoomy = (v.Height - v.Tmargin - v.Bmargin) / (Max - Min);
                let availableWidth = v.Width - v.Lmargin - v.Rmargin;
                let totalPoint = 0;
                for (let i = 0; i < this._series[k].segments.length; i++)
                  totalPoint += this._series[k].segments[i].count;
                let density = Math.round(totalPoint / availableWidth);
                if (density < SUMMARY_GRANULARITY || SUMMARY_GRANULARITY <= 0) {
                  for (let i = 0; i < this._series[k].segments.length; i++) {
                    lineCount += YGraph.DoSegmentRendering(v, ng, mypenb, this._series[k].segments[i].data, this._series[k].segments[i].count, xTimeStart2, xTimeEnd2);
                  }
                } else {
                  let level = Math.floor(Math.log(density) / Math.log(SUMMARY_GRANULARITY)) - 1;
                  let s = this._series[k].summaries[level];
                  let finalpoint = null;
                  for (let i = 0; i < s.segments.length; i++) {
                    if (i == s.segments.length - 1)
                      finalpoint = s.getBufferpoint();
                    lineCount += YGraph.DoSummarySegmentRendering(v, ng, mypenb, s.segments[i].data, s.segments[i].ptCount, finalpoint, xTimeStart2, xTimeEnd2);
                  }
                }
              }
            }
          } else {
            for (let i = 0; i < this._yAxes.length; i++) {
              let Yrange = MinMaxHandler.DefaultValue();
              for (let j = 0; j < this._series.length; j++) {
                if (this._series[j].yAxisIndex == i && !this._series[j].disabled) {
                  Yrange = MinMaxHandler.Combine(Yrange, this._series[j].valueRange);
                }
              }
              Yrange = MinMaxHandler.extend(Yrange, 1 + 2 * dontSticktoBorderZoom);
              Min = this._yAxes[i].min;
              if (isNaN(Min))
                Min = Yrange.Min;
              Max = this._yAxes[i].max;
              if (isNaN(Max))
                Max = Yrange.Max;
              if (Number.isNaN(Min)) {
                Min = 0;
                Max = 1;
              }
              if (Max - Min <= 0) {
                Min = Min - 0.5;
                Max = Min + 0.5;
              }
              v.IRLy = Min;
              v.zoomy = (v.Height - v.Tmargin - v.Bmargin) / (Max - Min);
              for (let j = 0; j < this._series.length; j++) {
                if (this._series[j].yAxisIndex == i && !this._series[j].disabled && this._series[j].visible) {
                  ng.comment("** navigator series " + j.toString());
                  mypenb = this._series[j].navigatorpen;
                  let availableWidth = v.Width - v.Lmargin - v.Rmargin;
                  let totalPoint = 0;
                  for (let i2 = 0; i2 < this._series[j].segments.length; i2++)
                    totalPoint += this._series[j].segments[i2].count;
                  let density = Math.round(totalPoint / availableWidth);
                  if (density < SUMMARY_GRANULARITY || SUMMARY_GRANULARITY <= 0) {
                    for (let i2 = 0; i2 < this._series[j].segments.length; i2++) {
                      lineCount += YGraph.DoSegmentRendering(v, ng, mypenb, this._series[j].segments[i2].data, this._series[j].segments[i2].count, xTimeStart2, xTimeEnd2);
                    }
                  } else {
                    let level = Math.floor(Math.log(density) / Math.log(SUMMARY_GRANULARITY)) - 1;
                    console.log("Navigator (YAXIS=INHERIT), Serie " + j + ", density is ~" + density + "pts/pixel drawing summarized data level " + level);
                    let s = this._series[j].summaries[level];
                    let finalpoint = null;
                    for (let i2 = 0; i2 < s.segments.length; i2++) {
                      if (i2 == s.segments.length - 1)
                        finalpoint = s.getBufferpoint();
                      lineCount += YGraph.DoSummarySegmentRendering(v, ng, mypenb, s.segments[i2].data, s.segments[i2].ptCount, finalpoint, xTimeStart2, xTimeEnd2);
                    }
                  }
                }
              }
            }
          }
          for (let i = 0; i < this._xAxis.markers.length; i++) {
            if (this._xAxis.markers[i].enabled) {
              let p = YGraph.IRLPointToViewPort(v, new pointXY(this._xAxis.markers[i].xposition + (this._xAxis.markers[i].timereference == TimeConverter.TimeReference.RELATIVE ? this._xAxis.zeroTime : 0), 0));
              ng.DrawLineXY(this._xAxis.markers[i].navigatorpen, p.X, v.Tmargin, p.X, v.Height - v.Bmargin);
            }
          }
          if (this._navigator.borderThickness > 0) {
            ng.DrawLineXY(this._navigator.borderPen, v.Lmargin, v.Tmargin, v.Width - v.Rmargin, v.Tmargin);
          }
          this.DrawMonitorXAxis(v, ng, this._navigator.Xrange, this.xAxis.labelFormat);
          this._navigator.setIRLPosition(v.IRLx, v.IRLy, v.zoomx, v.zoomy);
        }
        ng.ResetClip();
        if (!(g instanceof YGraphicsSVG))
          ng.Dispose();
      }
      let cacheW = v.Width - v.Rmargin - v.Lmargin + 1;
      let cacheH = v.Width - v.Rmargin - v.Lmargin + 1;
      let rectsrc = new YRectangle(v.Lmargin, v.Tmargin - 1, cacheW, cacheH);
      let rectdst = new YRectangle(v.Lmargin, v.Tmargin, cacheW, cacheH);
      g.SetClip(rectdst);
      if (!(g instanceof YGraphicsSVG)) {
        g.DrawImage(this.navigatorCache, rectsrc, rectdst, 2);
      }
      if (this._navigator.borderThickness > 0) {
        g.DrawLineXY(this._navigator.borderPen, v.Lmargin + 1, v.Tmargin, v.Lmargin + 1, v.Height - v.Bmargin - 1);
        g.DrawLineXY(this._navigator.borderPen, v.Width - v.Rmargin, v.Tmargin, v.Width - v.Rmargin, v.Height - v.Bmargin - 1);
        g.DrawLineXY(this._navigator.borderPen, v.Lmargin + 1, v.Tmargin, v.Width - v.Rmargin, v.Tmargin);
      }
      let IRLCursorStart = YGraph.ViewPortPointToIRL(this.mainViewPort, new Point(this.mainViewPort.Lmargin, 0));
      let IRLCursorEnd = YGraph.ViewPortPointToIRL(this.mainViewPort, new Point(this.mainViewPort.Width - this.mainViewPort.Rmargin, 0));
      let CursorStart = YGraph.IRLPointToViewPort(this._navigator.viewport, new pointXY(IRLCursorStart.x, 0));
      let CursorEnd = YGraph.IRLPointToViewPort(this._navigator.viewport, new pointXY(IRLCursorEnd.x, 0));
      g.FillRectangle(this._navigator.cursorBrush, new YRectangle(CursorStart.X - 1, v.Tmargin, CursorEnd.X - CursorStart.X + 2, v.Height - v.Bmargin - v.Tmargin - 1));
      g.DrawLineXY(this._navigator.cursorBorderPen, CursorStart.X - 1 >> 0, v.Tmargin >> 0, CursorStart.X - 1 >> 0, v.Height - v.Bmargin - 1);
      g.DrawLineXY(this._navigator.cursorBorderPen, CursorEnd.X + 1 >> 0, v.Tmargin >> 0, CursorEnd.X + 1 >> 0, v.Height - v.Bmargin - 1);
      g.ResetClip();
    }
    if (this._legendPanel.overlap)
      this.drawLegendPanel(g, UIw, UIh, this.mainViewPort);
    g.TextRenderingHint = YTextRenderingHint.SingleBitPerPixelGridFit;
    this.DrawMarkers(this.mainViewPort, g, this.xAxis, UIw, UIh);
    this.drawAnnotationPanels(g, this._annotationPanels, UIw, UIh, true, this.mainViewPort);
    this.DrawDataPanels(this.mainViewPort, g, this.xAxis, this._yAxes, UIw, UIh);
    this.DrawDataTracker(g, UIw, UIh, this.xAxis);
    this.DrawMessagePanels(g, UIw, UIh);
    return 0;
  }
  KeyDown(sender, e) {
    if (e.code == "ArrowLeft") {
      let delta = 0.2 * (this._xAxis.max - this._xAxis.min);
      this._xAxis.set_minMax(this._xAxis.min - delta, this._xAxis.max - delta);
      this.redraw();
    }
    if (e.code == "ArrowRight") {
      let delta = 0.2 * (this._xAxis.max - this._xAxis.min);
      this._xAxis.set_minMax(this._xAxis.min + delta, this._xAxis.max + delta);
      this.redraw();
    }
    if (e.code == "ArrowUp") {
      this.mouseWheel(new Point(this.UIContainer.width >> 1, this.UIContainer.height >> 1), 10);
    }
    if (e.code == "ArrowDown") {
      this.mouseWheel(new Point(this.UIContainer.width >> 1, this.UIContainer.height >> 1), -10);
    }
  }
  mouseWheel(pos, delta) {
    let ZoomFactor = Math.pow(1.25, delta / 120);
    let NextZoomX = this.mainViewPort.zoomx * ZoomFactor;
    if (NextZoomX > this.mainViewPort.zoomx && NextZoomX > 1e3)
      return;
    let currentRange = this._xAxis.max - this._xAxis.min;
    if (currentRange / ZoomFactor > 25 * 365 * 86400)
      return;
    this.mainViewPort.IRLx += (pos.X - this.mainViewPort.Lmargin) / this.mainViewPort.zoomx - (pos.X - this.mainViewPort.Lmargin) / NextZoomX;
    let range = this._xAxis.max - this._xAxis.min;
    this._xAxis.set_minMax(this.mainViewPort.IRLx, this.mainViewPort.IRLx + range / ZoomFactor);
    this.mainViewPort.zoomx = NextZoomX;
    this.redraw();
  }
  mouseWheelEvent(sender, e) {
    let p = this.Scr2ElmMatrix.multiplyByV(Vector3.FromXYCoord(e.pageX, e.pageY)).toPoint();
    let eX = p.X;
    let eY = p.Y;
    this.mouseWheel(new Point(eX, eY), e.deltaY > 0 ? -150 : 150);
    e.preventDefault();
  }
};
YGraph._defaultVerticalDragZoomEnabled = false;
YGraph.captureCursor = null;

// obj/full/Renderer/YSolidGauge.js
var DrawPrameters = class {
  constructor() {
    this.outerRadius = 0;
    this.innerRadius = 0;
    this.angleStart = 0;
    this.angleEnd = 0;
    this.ycenter = 0;
    this.xcenter = 0;
    this.heightTop = 0;
    this.heightBottom = 0;
    this.valueRectangle = new YRectangle(0, 0, 0, 0);
    this.valueFormat = new YStringFormat(16384);
    this.minValueRectangle = new YRectangle(0, 0, 0, 0);
    this.minValueFormat = new YStringFormat(16384);
    this.maxValueRectangle = new YRectangle(0, 0, 0, 0);
    this.maxValueFormat = new YStringFormat(16384);
    this.minValue = "";
    this.maxValue = "";
    this.value = "";
  }
};
var YSolidGauge = class extends YDataRenderer {
  get min() {
    return this._min;
  }
  set min(value) {
    if (value >= this._max && !YDataRenderer.minMaxCheckDisabled) {
      throw new RangeError("Min cannot be greater than max (" + this._max.toString() + ")");
    }
    this._min = value;
    if (this._shownValue < this._min)
      this._shownValue = this._min;
    this.redraw();
  }
  get max() {
    return this._max;
  }
  set max(value) {
    if (value <= this._min && !YDataRenderer.minMaxCheckDisabled) {
      throw new RangeError("Max cannot be less than min (" + this._min.toString() + ")");
    }
    this._max = value;
    if (this._shownValue > this._max)
      this._shownValue = this._max;
    this.redraw();
  }
  get borderpen() {
    if (this._borderpen == null) {
      this._borderpen = new YPen(this._borderColor, this._borderThickness);
      this._borderpen.startCap = 1;
      this._borderpen.endCap = 1;
    }
    return this._borderpen;
  }
  get borderColor() {
    return this._borderColor;
  }
  set borderColor(value) {
    this._borderColor = value;
    this._borderpen = null;
    this.redraw();
  }
  get backgroundColor1() {
    return this._backgroundColor1;
  }
  set backgroundColor1(value) {
    this._backgroundColor1 = value;
    this._bgBrush = null;
    this.redraw();
  }
  get backgroundColor2() {
    return this._backgroundColor2;
  }
  set backgroundColor2(value) {
    this._backgroundColor2 = value;
    this._bgBrush = null;
    this.redraw();
  }
  get borderThickness() {
    return this._borderThickness;
  }
  set borderThickness(value) {
    if (value < 0)
      throw new RangeError("Thickness must be a positive value");
    this._borderThickness = value;
    this._borderpen = null;
    this._path = null;
    this.redraw();
  }
  get valueFormater() {
    return this._valueFormater;
  }
  set valueFormater(value) {
    this._valueFormater = value;
    this.redraw();
  }
  get minmaxFormater() {
    return this._minmaxFormater;
  }
  set minmaxFormater(value) {
    this._minmaxFormater = value;
    this.redraw();
  }
  get thickness() {
    return this._thickness;
  }
  set thickness(value) {
    if (value < 0)
      throw new RangeError("Thickness must be a positive value");
    this._thickness = Math.max(Math.min(value, 80), 1);
    this._path = null;
    this.redraw();
  }
  get maxSpeed() {
    return this._maxSpeed;
  }
  set maxSpeed(value) {
    if (value <= 0)
      throw new RangeError("Speed must be a positive value");
    this._maxSpeed = value;
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value;
    this.redraw();
  }
  get color1() {
    return this._color1;
  }
  set color1(value) {
    this._color1 = value;
    this.redraw();
  }
  get color2() {
    return this._color2;
  }
  set color2(value) {
    this._color2 = value;
    this.redraw();
  }
  get font() {
    return this._font;
  }
  get minMaxFont() {
    return this._minMaxFont;
  }
  get showMinMax() {
    return this._showMinMax;
  }
  set showMinMax(value) {
    this._showMinMax = value;
    this._path = null;
    this.redraw();
  }
  get displayMode() {
    return this._displayMode;
  }
  set displayMode(value) {
    this._displayMode = value;
    this._path = null;
    this._bgBrush = null;
    this.redraw();
  }
  FontsizeChange(source) {
    this._path = null;
  }
  constructor(UIContainer, mode, logFunction) {
    super(UIContainer, logFunction);
    this._shownValue = 0;
    this._min = 0;
    this._max = 100;
    this.SegmentMaxLength = 8;
    this.mainViewPort = new ViewPortSettings();
    this._borderpen = null;
    this._borderColor = YColor.Black;
    this._bgBrush = null;
    this._backgroundColor1 = YColor.FromArgb(255, 240, 240, 240);
    this._backgroundColor2 = YColor.FromArgb(255, 200, 200, 200);
    this._borderThickness = 5;
    this._valueFormater = null;
    this._minmaxFormater = null;
    this._thickness = 25;
    this._maxSpeed = 0.1;
    this._value = 0;
    this._color1 = YColor.Green;
    this._color2 = YColor.Red;
    this._font = null;
    this._minMaxFont = null;
    this._showMinMax = true;
    this._path = null;
    this.lastDrawParameters = new DrawPrameters();
    this._displayMode = YSolidGauge.DisplayMode.DISPLAY90;
    this._minMaxFont = new YFont(this, this, Math.min(UIContainer.width, UIContainer.height) / 15, () => {
      this.FontsizeChange(this._minMaxFont);
    });
    this._displayMode = mode;
    this._font = new YFont(this, this, Math.min(UIContainer.width, UIContainer.height) / 5, null);
    this.resizeRule = Proportional.ResizeRule.RELATIVETOBOTH;
    let g = new YGraphics(UIContainer, UIContainer.width, UIContainer.height, 90);
    let p = this.ComputeDrawParameters(g, UIContainer.width, UIContainer.height, this.mainViewPort);
    g.Dispose();
  }
  clearCachedObjects() {
    this._bgBrush = null;
    this._path = null;
  }
  ComputeDrawParameters(g, UIw, UIh, mainViewPort) {
    UIw -= mainViewPort.Lmargin + mainViewPort.Rmargin;
    UIh -= mainViewPort.Tmargin + mainViewPort.Bmargin;
    let w = UIw - 5 - this._borderThickness;
    let h = UIh - 5 - this._borderThickness;
    let xcenter = UIw / 2;
    let outerRadius = 0;
    let angleStart = 0;
    let angleEnd = 0;
    let ycenter = 0;
    let ValueRectangle = new YRectangle(0, 0, 0, 0);
    let valueFormat = new YStringFormat(16384);
    let innerRadius = 0;
    let minMaxHeight = 0;
    let s1 = new YSizeF(null, "");
    let s2 = new YSizeF(null, "");
    this.lastDrawParameters.value = this._valueFormater == null ? this._value.toFixed(0) : this._valueFormater(this, this._value);
    if (this._showMinMax) {
      this.lastDrawParameters.minValue = this._minmaxFormater == null ? this._min.toFixed(0) : this._minmaxFormater(this, this._min);
      this.lastDrawParameters.maxValue = this._minmaxFormater == null ? this._max.toFixed(0) : this._minmaxFormater(this, this._max);
      s1 = g.MeasureString(this.lastDrawParameters.minValue, this._minMaxFont, 1e5);
      s2 = g.MeasureString(this.lastDrawParameters.maxValue, this._minMaxFont, 1e5);
      this.lastDrawParameters.minValueFormat = new YStringFormat(16384);
      this.lastDrawParameters.maxValueFormat = new YStringFormat(16384);
      minMaxHeight = s1.height;
      if (s2.height > minMaxHeight)
        minMaxHeight = s2.height;
    }
    switch (this._displayMode) {
      case YSolidGauge.DisplayMode.DISPLAY90:
        h = h - minMaxHeight;
        w = w - minMaxHeight;
        outerRadius = w;
        if (outerRadius > h - this._borderThickness)
          outerRadius = h - this.borderThickness;
        if (outerRadius > w - this.borderThickness)
          outerRadius = w - this.borderThickness;
        angleStart = Math.PI / 2;
        angleEnd = Math.PI;
        this.lastDrawParameters.heightTop = outerRadius;
        this.lastDrawParameters.heightBottom = 0;
        ycenter = mainViewPort.Tmargin + h;
        xcenter = mainViewPort.Lmargin + UIw / 2 + outerRadius / 2 - minMaxHeight + this._borderThickness;
        innerRadius = outerRadius * (100 - this._thickness) / 100;
        ValueRectangle = new YRectangle(xcenter - innerRadius >> 0, ycenter - innerRadius >> 0, innerRadius >> 0, innerRadius >> 0);
        valueFormat.Alignment = 2;
        valueFormat.LineAlignment = 2;
        if (this._showMinMax) {
          this.lastDrawParameters.minValueRectangle = new YRectangle(xcenter - (outerRadius + innerRadius + s1.width) / 2 >> 0, ycenter + this._borderThickness >> 0, s1.width + 1 >> 0, minMaxHeight + 1 >> 0);
          this.lastDrawParameters.minValueFormat.Alignment = 0;
          this.lastDrawParameters.minValueFormat.LineAlignment = 0;
          this.lastDrawParameters.maxValueRectangle = new YRectangle(xcenter + this._borderThickness >> 0, ycenter - outerRadius + (outerRadius - innerRadius - s2.width) / 2 >> 0, minMaxHeight + 1 >> 0, s2.width + 1 >> 0);
          this.lastDrawParameters.maxValueFormat.Alignment = 0;
          this.lastDrawParameters.maxValueFormat.LineAlignment = 0;
          this.lastDrawParameters.maxValueFormat.FormatFlags = 2;
        }
        break;
      case YSolidGauge.DisplayMode.DISPLAY180:
        h = h - minMaxHeight;
        let s0 = new YSizeF(null, "");
        s0 = g.MeasureString(this.lastDrawParameters.value, this._font, 1e5);
        outerRadius = w / 2 - this.borderThickness;
        if (outerRadius > h - this._borderThickness)
          outerRadius = h - this._borderThickness;
        if (outerRadius > w - this.borderThickness)
          outerRadius = w - this.borderThickness;
        angleStart = 0;
        angleEnd = Math.PI;
        ycenter = outerRadius + this._borderThickness / 2;
        innerRadius = outerRadius * (100 - this._thickness) / 100;
        this.lastDrawParameters.heightTop = outerRadius;
        this.lastDrawParameters.heightBottom = 0;
        ValueRectangle = new YRectangle(xcenter - innerRadius >> 0, ycenter + this._borderThickness + minMaxHeight - s0.height >> 0, 2 * innerRadius >> 0, s0.height + 1 >> 0);
        valueFormat.Alignment = 1;
        valueFormat.LineAlignment = 2;
        if (this._showMinMax) {
          this.lastDrawParameters.minValueRectangle = new YRectangle(xcenter - (outerRadius + innerRadius + s1.width) / 2 >> 0, ycenter + this._borderThickness >> 0, s1.width + 1 >> 0, minMaxHeight + 1 >> 0);
          this.lastDrawParameters.minValueFormat.Alignment = 0;
          this.lastDrawParameters.minValueFormat.LineAlignment = 0;
          this.lastDrawParameters.maxValueRectangle = new YRectangle(xcenter + (outerRadius + innerRadius - s2.width) / 2 >> 0, ycenter + this._borderThickness >> 0, s2.width + 1 >> 0, minMaxHeight + 1 >> 0);
          this.lastDrawParameters.maxValueFormat.Alignment = 0;
          this.lastDrawParameters.maxValueFormat.LineAlignment = 0;
        }
        break;
      case YSolidGauge.DisplayMode.DISPLAY270:
        outerRadius = w;
        if (outerRadius > h / 2)
          outerRadius = h / 2;
        if (outerRadius > w / 2)
          outerRadius = w / 2;
        this.lastDrawParameters.heightTop = outerRadius;
        this.lastDrawParameters.heightBottom = outerRadius;
        angleStart = 0;
        angleEnd = 3 * Math.PI / 2;
        ycenter = mainViewPort.Tmargin + UIh / 2;
        innerRadius = outerRadius * (100 - this._thickness) / 100;
        ValueRectangle = new YRectangle(xcenter - innerRadius >> 0, ycenter - innerRadius >> 0, 2 * innerRadius >> 0, 2 * innerRadius >> 0);
        valueFormat.Alignment = 1;
        valueFormat.LineAlignment = 1;
        if (this._showMinMax) {
          this.lastDrawParameters.minValueRectangle = new YRectangle(xcenter + this._borderThickness >> 0, ycenter + (innerRadius + innerRadius + s1.height) / 2 >> 0, s1.width + 1 >> 0, s1.height + 1 >> 0);
          this.lastDrawParameters.minValueFormat.Alignment = 0;
          this.lastDrawParameters.minValueFormat.LineAlignment = 0;
          this.lastDrawParameters.maxValueRectangle = new YRectangle(xcenter + (innerRadius + innerRadius + s1.height) / 2 >> 0, ycenter + this._borderThickness >> 0, s2.height + 1 >> 0, s2.width + 1 >> 0);
          this.lastDrawParameters.maxValueFormat.Alignment = 0;
          this.lastDrawParameters.maxValueFormat.LineAlignment = 0;
          this.lastDrawParameters.maxValueFormat.FormatFlags = 2;
        }
        break;
      case YSolidGauge.DisplayMode.DISPLAY360:
        outerRadius = w;
        if (outerRadius > h / 0.85 / 2)
          outerRadius = h / 0.85 / 2;
        if (outerRadius > w / 2)
          outerRadius = w / 2;
        this.lastDrawParameters.heightTop = outerRadius;
        this.lastDrawParameters.heightBottom = outerRadius * 0.7;
        ycenter = mainViewPort.Tmargin + outerRadius + this._borderThickness / 2;
        angleStart = -Math.PI / 4;
        angleEnd = 5 * Math.PI / 4;
        innerRadius = outerRadius * (100 - this._thickness) / 100;
        ValueRectangle = new YRectangle(xcenter - innerRadius >> 0, ycenter - innerRadius >> 0, 2 * innerRadius >> 0, 2 * innerRadius >> 0);
        valueFormat.Alignment = 1;
        valueFormat.LineAlignment = 1;
        if (this._showMinMax) {
          let dx = Math.abs(innerRadius * Math.cos(angleStart));
          let dy = innerRadius * Math.abs(Math.sin(angleStart)) + 2 * Math.abs((outerRadius - innerRadius) * Math.sin(angleStart) / 3);
          this.lastDrawParameters.minValueRectangle = new YRectangle(xcenter - dx >> 0, ycenter + dy - minMaxHeight / 2 >> 0, s1.width + 1 >> 0, minMaxHeight + 1 >> 0);
          this.lastDrawParameters.minValueFormat.Alignment = 0;
          this.lastDrawParameters.minValueFormat.LineAlignment = 1;
          this.lastDrawParameters.maxValueRectangle = new YRectangle(xcenter + dx - s2.width >> 0, ycenter + dy - minMaxHeight / 2 >> 0, s2.width + 1 >> 0, minMaxHeight + 1 >> 0);
          this.lastDrawParameters.maxValueFormat.Alignment = 0;
          this.lastDrawParameters.maxValueFormat.LineAlignment = 1;
        }
        break;
    }
    this.lastDrawParameters.outerRadius = outerRadius;
    this.lastDrawParameters.innerRadius = innerRadius;
    this.lastDrawParameters.angleStart = angleStart;
    this.lastDrawParameters.angleEnd = angleEnd;
    this.lastDrawParameters.ycenter = ycenter;
    this.lastDrawParameters.xcenter = xcenter;
    this.lastDrawParameters.valueRectangle = ValueRectangle;
    this.lastDrawParameters.valueFormat = valueFormat;
    return this.lastDrawParameters;
  }
  Render(g, w, h) {
    this.mainViewPort = new ViewPortSettings();
    g.SmoothingMode = YSmoothingMode.HighQuality;
    g.TextRenderingHint = YTextRenderingHint.AntiAlias;
    this.drawAnnotationPanels(g, this._annotationPanels, w, h, false, this.mainViewPort);
    let p = this.ComputeDrawParameters(g, w, h, this.mainViewPort);
    if (this._path == null) {
      let outterlength = 2 * p.outerRadius * Math.PI * (p.angleEnd - p.angleStart) / (2 * Math.PI);
      let stepCount = outterlength / this.SegmentMaxLength >> 0;
      let stepsize = (p.angleEnd - p.angleStart) / stepCount;
      this._path = new Array(2 * (stepCount + 1));
      let n = 0;
      for (let i = 0; i <= stepCount; i++) {
        let a = p.angleStart + i * stepsize;
        this._path[n++] = new PointF(p.xcenter + p.outerRadius * Math.cos(a), p.ycenter - p.outerRadius * Math.sin(a));
      }
      for (let i = stepCount; i >= 0; i--) {
        let a = p.angleStart + i * stepsize;
        this._path[n++] = new PointF(p.xcenter + p.innerRadius * Math.cos(a), p.ycenter - p.innerRadius * Math.sin(a));
      }
    }
    if (this._bgBrush == null) {
      this._bgBrush = new YLinearGradientBrush(this._backgroundColor1, this._backgroundColor2);
    }
    if (this._borderpen == null) {
      this._borderpen = new YPen(this._borderColor, this._borderThickness);
      this._borderpen.linejoin = YPen.LineJoin.Round;
    }
    g.FillPolygon(this._bgBrush, this._path);
    if (this._shownValue != this._value) {
      let step = this._maxSpeed * (this._max - this._min) / 100;
      if (Math.abs(this._value - this._shownValue) < step) {
        this._shownValue = this._value;
      } else if (this._shownValue < this._value) {
        this._shownValue += step;
      } else {
        this._shownValue -= step;
      }
    }
    let v = this._shownValue;
    if (v >= this._min) {
      if (v > this._max)
        v = this._max;
      let valueFactor = (v - this._min) / (this._max - this.min);
      let angleValue = p.angleStart + (p.angleEnd - p.angleStart) * valueFactor;
      let outterlength = 2 * p.outerRadius * Math.PI * (angleValue - p.angleStart) / (2 * Math.PI);
      let stepCount = outterlength / this.SegmentMaxLength >> 0;
      let stepsize = (angleValue - p.angleStart) / stepCount;
      let pt = new Array(2 * (stepCount + 1));
      let n = 0;
      for (let i = 0; i <= stepCount; i++) {
        let a = p.angleEnd - i * stepsize;
        pt[n++] = new PointF(p.xcenter + p.outerRadius * Math.cos(a), p.ycenter - p.outerRadius * Math.sin(a));
      }
      for (let i = stepCount; i >= 0; i--) {
        let a = p.angleEnd - i * stepsize;
        pt[n++] = new PointF(p.xcenter + p.innerRadius * Math.cos(a), p.ycenter - p.innerRadius * Math.sin(a));
      }
      let b;
      if (this._color1 == this._color2) {
        b = new YSolidBrush(this._color1);
      } else {
        let A1 = this._color1.alpha;
        let H1 = this._color1.hue;
        let S1 = this._color1.saturation;
        let L1 = this._color1.luminosity;
        let A2 = this._color2.alpha;
        let H2 = this._color2.hue;
        let S2 = this._color2.saturation;
        let L2 = this._color2.luminosity;
        let A = Math.round(A1 + (A2 - A1) * valueFactor) >> 0 & 255;
        let H;
        if (Math.abs(H2 - H1) <= 127) {
          H = H1 + (H2 - H1) * valueFactor >> 0;
        } else {
          H = H1 + 256 + (H2 - H1 + 256) * valueFactor >> 0;
          if (H > 256)
            H -= 256;
        }
        let S = S1 + (S2 - S1) * valueFactor >> 0;
        let L = L1 + (L2 - L1) * valueFactor >> 0;
        b = new YSolidBrush(new YColor(true, A, H, S, L));
      }
      g.FillPolygon(b, pt);
    }
    if (this._borderThickness > 0)
      g.DrawPolygon(this._borderpen, this._path);
    g.DrawStringRect(this.lastDrawParameters.value, this._font, this._font.brush, p.valueRectangle, p.valueFormat);
    if (this._showMinMax) {
      g.DrawStringRect(this.lastDrawParameters.minValue, this._minMaxFont, this._minMaxFont.brush, this.lastDrawParameters.minValueRectangle, this.lastDrawParameters.minValueFormat);
      g.DrawStringRect(this.lastDrawParameters.maxValue, this._minMaxFont, this._minMaxFont.brush, this.lastDrawParameters.maxValueRectangle, this.lastDrawParameters.maxValueFormat);
    }
    this.drawAnnotationPanels(g, this._annotationPanels, w, h, true, this.mainViewPort);
    this.DrawMessagePanels(g, w, h);
    return 0;
  }
  renderingPostProcessing() {
    if (this._shownValue != this._value)
      this.redraw();
  }
};
(function(YSolidGauge2) {
  class DisplayModeEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, DisplayMode);
    }
  }
  YSolidGauge2.DisplayModeEnumItem = DisplayModeEnumItem;
  class DisplayMode extends YEnum {
  }
  DisplayMode.DISPLAY90 = new DisplayModeEnumItem("DISPLAY90", "90\xB0");
  DisplayMode.DISPLAY180 = new DisplayModeEnumItem("DISPLAY180", "180\xB0");
  DisplayMode.DISPLAY270 = new DisplayModeEnumItem("DISPLAY270", "270\xB0");
  DisplayMode.DISPLAY360 = new DisplayModeEnumItem("DISPLAY360", "360\xB0");
  YSolidGauge2.DisplayMode = DisplayMode;
})(YSolidGauge || (YSolidGauge = {}));

// obj/full/Api/yocto_api.js
var YAPI_SUCCESS = 0;
var YAPI_INVALID_ARGUMENT = -2;
var YAPI_NOT_SUPPORTED = -3;
var YAPI_DEVICE_NOT_FOUND = -4;
var YAPI_VERSION_MISMATCH = -5;
var YAPI_DEVICE_BUSY = -6;
var YAPI_TIMEOUT = -7;
var YAPI_IO_ERROR = -8;
var YAPI_UNAUTHORIZED = -12;
var YAPI_SSL_UNK_CERT = -20;
var YAPI_INVALID_INT = 2147483647;
var YAPI_INVALID_UINT = -1;
var YAPI_INVALID_LONG = 9223372036854776e3;
var YAPI_INVALID_DOUBLE = -Number.MAX_VALUE;
var YAPI_INVALID_STRING = "!INVALID!";
var YAPI_MIN_DOUBLE = -Number.MAX_VALUE;
var YAPI_MAX_DOUBLE = Number.MAX_VALUE;
var Y_FUNCTIONDESCRIPTOR_INVALID = YAPI_INVALID_STRING;
var Y_DETECT_NONE = 0;
var Y_DETECT_USB = 1;
var Y_DETECT_NET = 2;
var Y_DETECT_ALL = Y_DETECT_USB | Y_DETECT_NET;
var DEFAULT_DEVICE_LIST_VALIDITY_MS = 1e4;
var DEFAULT_NETWORK_TIMEOUT_MS = 2e4;
var YOCTO_CALIB_TYPE_OFS = 30;
var NOTIFY_NETPKT_CONFCHGYDX = "s";
var NOTIFY_NETPKT_FLUSHV2YDX = "t";
var NOTIFY_NETPKT_FUNCV2YDX = "u";
var NOTIFY_NETPKT_TIMEV2YDX = "v";
var NOTIFY_NETPKT_DEVLOGYDX = "w";
var NOTIFY_NETPKT_TIMEVALYDX = "x";
var NOTIFY_NETPKT_FUNCVALYDX = "y";
var NOTIFY_NETPKT_TIMEAVGYDX = "z";
var NOTIFY_NETPKT_STOP = 10;
var NOTIFY_V2_6RAWBYTES = 1;
var NOTIFY_V2_TYPEDDATA = 2;
var PUBVAL_LEGACY = 0;
var PUBVAL_1RAWBYTE = 1;
var PUBVAL_2RAWBYTES = 2;
var PUBVAL_3RAWBYTES = 3;
var PUBVAL_4RAWBYTES = 4;
var PUBVAL_5RAWBYTES = 5;
var PUBVAL_6RAWBYTES = 6;
var PUBVAL_C_LONG = 7;
var PUBVAL_C_FLOAT = 8;
var PUBVAL_YOCTO_FLOAT_E3 = 9;
var YOCTO_PUBVAL_SIZE = 6;
var YOCTO_HASH_BUF_SIZE = 28;
var YOCTO_BASETYPE_FUNCTION = 0;
var YOCTO_BASETYPE_SENSOR = 1;
var Y_BASETYPES = {
  Function: YOCTO_BASETYPE_FUNCTION,
  Sensor: YOCTO_BASETYPE_SENSOR
};
var YErrorMsg = class {
  constructor(msg = "") {
    this.msg = msg;
  }
};
var YoctoError = class extends Error {
  constructor(...params) {
    super(...params);
    this.errorMsg = this.name;
    this.name = "YoctoError";
    if ("captureStackTrace" in Error) {
      Error.captureStackTrace(this, YoctoError);
    }
  }
};
var _YY_UrlInfo = class {
  constructor(str_url) {
    this.orgUrl = str_url;
    let proto = "auto";
    let user = "";
    let pass = "";
    let port = 4444;
    let host;
    let dom = "";
    if (str_url.slice(0, 7) == "http://") {
      proto = "http";
      str_url = str_url.slice(7);
    } else if (str_url.slice(0, 5) == "ws://") {
      proto = "ws";
      str_url = str_url.slice(5);
    } else if (str_url.slice(0, 8) == "https://") {
      proto = "https";
      port = 4443;
      str_url = str_url.slice(8);
    } else if (str_url.slice(0, 6) == "wss://") {
      proto = "wss";
      port = 4443;
      str_url = str_url.slice(6);
    } else if (str_url.slice(0, 7) == "auto://") {
      str_url = str_url.slice(7);
    } else if (str_url.slice(0, 9) == "secure://") {
      str_url = str_url.slice(9);
      port = 4443;
      proto = "secure";
    }
    str_url = str_url.replace("/not.byn", "");
    if (str_url[str_url.length - 1] == "/") {
      str_url = str_url.slice(0, str_url.length - 1);
    }
    let pos = str_url.indexOf("/");
    if (pos > 0) {
      dom = str_url.slice(pos);
      str_url = str_url.slice(0, pos);
    }
    let authpos = str_url.indexOf("@");
    if (authpos >= 0) {
      let auth = str_url.slice(0, authpos);
      let passpos = auth.indexOf(":");
      if (passpos >= 0) {
        user = auth.slice(0, passpos);
        pass = auth.slice(passpos + 1);
      } else {
        user = auth;
      }
      str_url = str_url.slice(authpos + 1);
    }
    let endv6 = str_url.indexOf("]");
    pos = str_url.indexOf(":");
    if (pos > 0 && endv6 > 0 && pos < endv6) {
      pos = str_url.indexOf(":", endv6);
    }
    if (pos < 0) {
      host = str_url;
      if (dom != "") {
        if (proto == "http") {
          port = 80;
        } else if (proto == "https") {
          port = 443;
        }
      }
    } else {
      host = str_url.slice(0, pos);
      port = YAPIContext.imm_atoi(str_url.slice(pos + 1));
    }
    if (host == "callback") {
      port = 4444;
    }
    this.proto = proto;
    this.user = user;
    this.pass = pass;
    this.host = host;
    this.port = port;
    this.domain = dom;
  }
  imm_getHost() {
    return this.host;
  }
  imm_getPass() {
    return this.pass;
  }
  imm_getPort() {
    return this.port;
  }
  imm_getUser() {
    return this.user;
  }
  imm_getUrl(withProto = false, withUserPass = true, withEndSlash = false) {
    if (this.proto == "usb") {
      return "usb";
    }
    let url = "";
    if (withProto) {
      url += this.proto + "://";
    }
    if (withUserPass && this.user != "") {
      url += this.user;
      if (this.pass != "") {
        url += ":";
        url += this.pass;
      }
      url += "@";
    }
    url += this.host;
    url += ":";
    url += this.port;
    url += this.domain;
    if (withEndSlash && url[url.length - 1] != "/") {
      url += "/";
    }
    return url;
  }
  imm_getRootUrl() {
    return this.imm_getUrl(true, false, true);
  }
  imm_getProto() {
    return this.proto;
  }
  imm_useWebSocket() {
    return this.proto.startsWith("ws") || this.proto == "auto" || this.proto == "secure";
  }
  imm_getSubDomain() {
    let dom = this.domain;
    return dom;
  }
  imm_hasAuthParam() {
    return this.user != "";
  }
  imm_useSecureSocket() {
    return this.proto == "wss" || this.proto == "https" || this.proto == "secure";
  }
  imm_testInfoJson() {
    return this.proto == "auto" || this.proto == "secure" || this.proto == "http" || this.proto == "https";
  }
  imm_updateBestProto(proto, port) {
    this.port = port;
    if (this.proto != "http" && this.proto != "https") {
      this.proto = proto;
    }
  }
  imm_updateForRedirect(host, port, is_secure) {
    this.host = host;
    this.port = port;
    if (this.imm_useWebSocket()) {
      this.proto = is_secure ? "wss" : "ws";
    } else {
      this.proto = is_secure ? "https" : "http";
    }
  }
  imm_updatePortInfo(proto, port) {
    this.proto = proto;
    this.port = port;
  }
  imm_getOriginalURL() {
    return this.orgUrl;
  }
  imm_updateFrom(urlInfo) {
    this.proto = urlInfo.proto;
    this.user = urlInfo.user;
    this.pass = urlInfo.pass;
    this.host = urlInfo.host;
    this.port = urlInfo.port;
    this.domain = urlInfo.domain;
    this.orgUrl = urlInfo.orgUrl;
  }
};
var Y_MD5Ctx = class {
  constructor() {
    this.buf = new Uint32Array(4);
    this.bits = new Uint32Array(2);
    this.inBuf = new ArrayBuffer(64);
    this.in8 = new Uint8Array(this.inBuf);
    this.in32 = new Uint32Array(this.inBuf);
    this.in32[0] = 1;
    this.bigEndian = this.in8[0] != 1;
    this.buf[0] = 1732584193 >>> 0;
    this.buf[1] = 4023233417 >>> 0;
    this.buf[2] = 2562383102 >>> 0;
    this.buf[3] = 271733878 >>> 0;
    this.bits[0] = 0;
    this.bits[1] = 0;
  }
  _byteReverseIn() {
    for (let i = 0; i < 16; i++) {
      let a = this.in32[i];
      this.in32[i] = (a >>> 24 | (a & 255) << 24 | (a & 16711680) >>> 8 | (a & 65280) << 8) >>> 0;
    }
  }
  _transform() {
    let F1 = (x, y, z) => (z ^ x & (y ^ z)) >>> 0;
    let F2 = (x, y, z) => F1(z, x, y);
    let F3 = (x, y, z) => (x ^ y ^ z) >>> 0;
    let F4 = (x, y, z) => (y ^ (x | ~z)) >>> 0;
    let MD5STEP = (f, w, x, y, z, data, s) => {
      w = w + f(x, y, z) + (data >>> 0) >>> 0;
      w = (w << s >>> 0 | w >>> 32 - s) >>> 0;
      return w + x >>> 0;
    };
    let a = this.buf[0];
    let b = this.buf[1];
    let c = this.buf[2];
    let d = this.buf[3];
    let dataIn = this.in32;
    a = MD5STEP(F1, a, b, c, d, dataIn[0] + 3614090360, 7);
    d = MD5STEP(F1, d, a, b, c, dataIn[1] + 3905402710, 12);
    c = MD5STEP(F1, c, d, a, b, dataIn[2] + 606105819, 17);
    b = MD5STEP(F1, b, c, d, a, dataIn[3] + 3250441966, 22);
    a = MD5STEP(F1, a, b, c, d, dataIn[4] + 4118548399, 7);
    d = MD5STEP(F1, d, a, b, c, dataIn[5] + 1200080426, 12);
    c = MD5STEP(F1, c, d, a, b, dataIn[6] + 2821735955, 17);
    b = MD5STEP(F1, b, c, d, a, dataIn[7] + 4249261313, 22);
    a = MD5STEP(F1, a, b, c, d, dataIn[8] + 1770035416, 7);
    d = MD5STEP(F1, d, a, b, c, dataIn[9] + 2336552879, 12);
    c = MD5STEP(F1, c, d, a, b, dataIn[10] + 4294925233, 17);
    b = MD5STEP(F1, b, c, d, a, dataIn[11] + 2304563134, 22);
    a = MD5STEP(F1, a, b, c, d, dataIn[12] + 1804603682, 7);
    d = MD5STEP(F1, d, a, b, c, dataIn[13] + 4254626195, 12);
    c = MD5STEP(F1, c, d, a, b, dataIn[14] + 2792965006, 17);
    b = MD5STEP(F1, b, c, d, a, dataIn[15] + 1236535329, 22);
    a = MD5STEP(F2, a, b, c, d, dataIn[1] + 4129170786, 5);
    d = MD5STEP(F2, d, a, b, c, dataIn[6] + 3225465664, 9);
    c = MD5STEP(F2, c, d, a, b, dataIn[11] + 643717713, 14);
    b = MD5STEP(F2, b, c, d, a, dataIn[0] + 3921069994, 20);
    a = MD5STEP(F2, a, b, c, d, dataIn[5] + 3593408605, 5);
    d = MD5STEP(F2, d, a, b, c, dataIn[10] + 38016083, 9);
    c = MD5STEP(F2, c, d, a, b, dataIn[15] + 3634488961, 14);
    b = MD5STEP(F2, b, c, d, a, dataIn[4] + 3889429448, 20);
    a = MD5STEP(F2, a, b, c, d, dataIn[9] + 568446438, 5);
    d = MD5STEP(F2, d, a, b, c, dataIn[14] + 3275163606, 9);
    c = MD5STEP(F2, c, d, a, b, dataIn[3] + 4107603335, 14);
    b = MD5STEP(F2, b, c, d, a, dataIn[8] + 1163531501, 20);
    a = MD5STEP(F2, a, b, c, d, dataIn[13] + 2850285829, 5);
    d = MD5STEP(F2, d, a, b, c, dataIn[2] + 4243563512, 9);
    c = MD5STEP(F2, c, d, a, b, dataIn[7] + 1735328473, 14);
    b = MD5STEP(F2, b, c, d, a, dataIn[12] + 2368359562, 20);
    a = MD5STEP(F3, a, b, c, d, dataIn[5] + 4294588738, 4);
    d = MD5STEP(F3, d, a, b, c, dataIn[8] + 2272392833, 11);
    c = MD5STEP(F3, c, d, a, b, dataIn[11] + 1839030562, 16);
    b = MD5STEP(F3, b, c, d, a, dataIn[14] + 4259657740, 23);
    a = MD5STEP(F3, a, b, c, d, dataIn[1] + 2763975236, 4);
    d = MD5STEP(F3, d, a, b, c, dataIn[4] + 1272893353, 11);
    c = MD5STEP(F3, c, d, a, b, dataIn[7] + 4139469664, 16);
    b = MD5STEP(F3, b, c, d, a, dataIn[10] + 3200236656, 23);
    a = MD5STEP(F3, a, b, c, d, dataIn[13] + 681279174, 4);
    d = MD5STEP(F3, d, a, b, c, dataIn[0] + 3936430074, 11);
    c = MD5STEP(F3, c, d, a, b, dataIn[3] + 3572445317, 16);
    b = MD5STEP(F3, b, c, d, a, dataIn[6] + 76029189, 23);
    a = MD5STEP(F3, a, b, c, d, dataIn[9] + 3654602809, 4);
    d = MD5STEP(F3, d, a, b, c, dataIn[12] + 3873151461, 11);
    c = MD5STEP(F3, c, d, a, b, dataIn[15] + 530742520, 16);
    b = MD5STEP(F3, b, c, d, a, dataIn[2] + 3299628645, 23);
    a = MD5STEP(F4, a, b, c, d, dataIn[0] + 4096336452, 6);
    d = MD5STEP(F4, d, a, b, c, dataIn[7] + 1126891415, 10);
    c = MD5STEP(F4, c, d, a, b, dataIn[14] + 2878612391, 15);
    b = MD5STEP(F4, b, c, d, a, dataIn[5] + 4237533241, 21);
    a = MD5STEP(F4, a, b, c, d, dataIn[12] + 1700485571, 6);
    d = MD5STEP(F4, d, a, b, c, dataIn[3] + 2399980690, 10);
    c = MD5STEP(F4, c, d, a, b, dataIn[10] + 4293915773, 15);
    b = MD5STEP(F4, b, c, d, a, dataIn[1] + 2240044497, 21);
    a = MD5STEP(F4, a, b, c, d, dataIn[8] + 1873313359, 6);
    d = MD5STEP(F4, d, a, b, c, dataIn[15] + 4264355552, 10);
    c = MD5STEP(F4, c, d, a, b, dataIn[6] + 2734768916, 15);
    b = MD5STEP(F4, b, c, d, a, dataIn[13] + 1309151649, 21);
    a = MD5STEP(F4, a, b, c, d, dataIn[4] + 4149444226, 6);
    d = MD5STEP(F4, d, a, b, c, dataIn[11] + 3174756917, 10);
    c = MD5STEP(F4, c, d, a, b, dataIn[2] + 718787259, 15);
    b = MD5STEP(F4, b, c, d, a, dataIn[9] + 3951481745, 21);
    this.buf[0] = (this.buf[0] + a & 4294967295) >>> 0;
    this.buf[1] = (this.buf[1] + b & 4294967295) >>> 0;
    this.buf[2] = (this.buf[2] + c & 4294967295) >>> 0;
    this.buf[3] = (this.buf[3] + d & 4294967295) >>> 0;
  }
  addData(buf) {
    let len = buf.length;
    let pos = 0;
    let t = this.bits[0];
    this.bits[0] = t + (len << 3) >>> 0;
    if (this.bits[0] < t) {
      this.bits[1]++;
    }
    this.bits[1] += len >>> 29;
    t = t >>> 3 & 63;
    while (pos < len) {
      while (pos < len && t < 64) {
        this.in8[t++] = buf[pos++];
      }
      if (t < 64)
        return;
      if (this.bigEndian)
        this._byteReverseIn();
      this._transform();
      t = 0;
    }
  }
  calculate() {
    let t = this.bits[0] >>> 3 & 63;
    this.in8[t++] = 128;
    if (t > 56) {
      while (t < 64) {
        this.in8[t++] = 0;
      }
      if (this.bigEndian)
        this._byteReverseIn();
      this._transform();
      for (t = 0; t < 14; t++) {
        this.in32[t] = 0;
      }
    } else {
      while (t < 56) {
        this.in8[t++] = 0;
      }
      if (this.bigEndian)
        this._byteReverseIn();
    }
    this.in32[14] = this.bits[0];
    this.in32[15] = this.bits[1];
    this._transform();
    let res = new Uint8Array(16);
    for (t = 0; t < 16; t++) {
      res[t] = this.buf[t >>> 2] >>> 8 * (t & 3) & 255;
    }
    return res;
  }
};
var YFunctionType = class {
  constructor(yapi, classname) {
    this._yapi = yapi;
    this._className = classname;
    this._connectedFns = {};
    this._requestedFns = {};
    this._hwIdByName = {};
    this._nameByHwId = {};
    this._valueByHwId = {};
    this._baseType = 0;
  }
  imm_reindexFunction(str_hwid, str_name, str_val, int_basetype) {
    let currname = this._nameByHwId[str_hwid];
    let res = false;
    if (currname == void 0 || currname == "") {
      if (str_name != "") {
        this._nameByHwId[str_hwid] = str_name;
        res = true;
      }
    } else if (currname != str_name) {
      if (this._hwIdByName[currname] == str_hwid) {
        delete this._hwIdByName[currname];
      }
      if (str_name != "") {
        this._nameByHwId[str_hwid] = str_name;
      } else {
        delete this._nameByHwId[str_hwid];
      }
      res = true;
    }
    if (str_name != "") {
      this._hwIdByName[str_name] = str_hwid;
    }
    if (str_val) {
      this._valueByHwId[str_hwid] = str_val;
    } else {
      if (this._valueByHwId[str_hwid] == void 0) {
        this._valueByHwId[str_hwid] = "";
      }
    }
    if (int_basetype) {
      if (this._baseType == 0) {
        this._baseType = int_basetype;
      }
    }
    return res;
  }
  imm_forgetFunction(str_hwid) {
    let currname = this._nameByHwId[str_hwid];
    if (currname != void 0) {
      if (currname != "" && this._hwIdByName[currname] == str_hwid) {
        delete this._hwIdByName[currname];
      }
      delete this._nameByHwId[str_hwid];
    }
    if (this._valueByHwId[str_hwid] != void 0) {
      delete this._valueByHwId[str_hwid];
    }
    let con_fn = this._connectedFns[str_hwid];
    if (con_fn) {
      this._requestedFns[str_hwid] = con_fn;
      delete this._connectedFns[str_hwid];
    }
  }
  imm_resolve(str_func) {
    let res;
    let dotpos = str_func.indexOf(".");
    if (dotpos < 0) {
      res = this._hwIdByName[str_func];
      if (res != void 0) {
        return {
          errorType: YAPI_SUCCESS,
          errorMsg: "no error",
          result: String(res)
        };
      }
      dotpos = str_func.length;
      str_func += "." + this._className.substr(0, 1).toLowerCase() + this._className.substr(1);
    }
    if (this._valueByHwId[str_func] != void 0) {
      return {
        errorType: YAPI_SUCCESS,
        errorMsg: "no error",
        result: String(str_func)
      };
    }
    let serial = "";
    let funcid;
    if (dotpos > 0) {
      let devid = str_func.substr(0, dotpos);
      funcid = str_func.substr(dotpos + 1);
      let dev = this._yapi.imm_getDevice(devid);
      if (!dev) {
        return {
          errorType: YAPI_DEVICE_NOT_FOUND,
          errorMsg: "Device [" + devid + "] not online",
          result: ""
        };
      }
      serial = dev.imm_getSerialNumber();
      res = serial + "." + funcid;
      if (this._valueByHwId[res] != void 0) {
        return {
          errorType: YAPI_SUCCESS,
          errorMsg: "no error",
          result: String(res)
        };
      }
      let i, nfun = dev.imm_functionCount();
      for (i = 0; i < nfun; i++) {
        res = serial + "." + dev.imm_functionId(i);
        let name = this._nameByHwId[res];
        if (name != void 0 && name == funcid) {
          return {
            errorType: YAPI_SUCCESS,
            errorMsg: "no error",
            result: String(res)
          };
        }
      }
    } else {
      funcid = str_func.substr(1);
      for (let hwid_str in this._connectedFns) {
        let pos = hwid_str.indexOf(".");
        let str_function = hwid_str.substr(pos + 1);
        if (str_function == funcid) {
          return {
            errorType: YAPI_SUCCESS,
            errorMsg: "no error",
            result: String(hwid_str)
          };
        }
      }
    }
    return {
      errorType: YAPI_DEVICE_NOT_FOUND,
      errorMsg: "No function [" + funcid + "] found on device [" + serial + "]",
      result: ""
    };
  }
  imm_getFriendlyName(str_func) {
    let resolved = this.imm_resolve(str_func);
    let name;
    if (resolved.errorType != YAPI_SUCCESS) {
      return resolved;
    }
    let hwId = resolved.result;
    if (this._className == "Module") {
      let friend = hwId;
      name = this._nameByHwId[friend];
      if (name != void 0 && name != "") {
        friend = this._nameByHwId[friend];
      }
      return {
        errorType: YAPI_SUCCESS,
        errorMsg: "no error",
        result: String(friend)
      };
    } else {
      let pos = hwId.indexOf(".");
      let str_serialMod = hwId.substr(0, pos);
      let str_friendModFull = this._yapi.imm_getFriendlyNameFunction("Module", str_serialMod).result;
      let int_friendModDot = str_friendModFull.indexOf(".");
      let str_friendMod = int_friendModDot > 0 ? str_friendModFull.substr(0, int_friendModDot) : str_friendModFull;
      let str_friendFunc = hwId.substr(pos + 1);
      name = this._nameByHwId[hwId];
      if (name != void 0 && name != "") {
        str_friendFunc = name;
      }
      return {
        errorType: YAPI_SUCCESS,
        errorMsg: "no error",
        result: String(str_friendMod + "." + str_friendFunc)
      };
    }
  }
  imm_setFunction(str_func, obj_func) {
    let funres = this.imm_resolve(str_func);
    if (funres.result) {
      this._connectedFns[funres.result] = obj_func;
    } else {
      this._requestedFns[str_func] = obj_func;
    }
  }
  imm_getFunction(str_func) {
    let funres = this.imm_resolve(str_func);
    if (funres.errorType == YAPI_SUCCESS) {
      let conn_fn = this._connectedFns[funres.result];
      if (conn_fn != void 0) {
        return conn_fn;
      }
      let req_fn = this._requestedFns[str_func];
      if (req_fn != void 0) {
        this._connectedFns[funres.result] = req_fn;
        delete this._requestedFns[str_func];
      }
      return req_fn;
    } else {
      return this._requestedFns[str_func];
    }
  }
  imm_setFunctionValue(str_hwid, str_pubval) {
    let currval = this._valueByHwId[str_hwid];
    if (!(currval == void 0) && currval == str_pubval) {
      return false;
    }
    this._valueByHwId[str_hwid] = str_pubval;
    return true;
  }
  imm_getFunctionValue(str_hwid) {
    return this._valueByHwId[str_hwid];
  }
  imm_getBaseType() {
    return this._baseType;
  }
  imm_matchBaseType(baseclass) {
    return baseclass == YOCTO_BASETYPE_FUNCTION || baseclass == this._baseType;
  }
  imm_getFirstHardwareId() {
    let res = null;
    for (res in this._valueByHwId) {
      break;
    }
    return res;
  }
  imm_getNextHardwareId(str_hwid) {
    for (let iter_hwid in this._valueByHwId) {
      if (str_hwid == "!") {
        return iter_hwid;
      }
      if (str_hwid == iter_hwid) {
        str_hwid = "!";
      }
    }
    return null;
  }
};
var YHTTPBody = class {
  constructor(str_fname, bin_data, fun_progressCb) {
    this.fname = str_fname;
    this.data = bin_data;
    this.progressCb = fun_progressCb;
  }
};
var YHTTPRequest = class {
  constructor(bin_res, int_errType = YAPI_SUCCESS, str_errMsg = "no error") {
    this.devUrl = null;
    this.obj_result = null;
    this.asyncId = 0;
    this.acceptor = null;
    this.toBeSent = null;
    this.sendPos = 0;
    this.progressCb = null;
    this.timeoutId = null;
    this.sendTimeoutId = null;
    this.next = null;
    this._creat = "";
    this._sent = "";
    this.bin_result = bin_res;
    this.errorType = int_errType;
    this.errorMsg = str_errMsg;
  }
};
var YFuncRequest = class {
  constructor(obj_res, int_errType = YAPI_SUCCESS, str_errMsg = "no error") {
    this.errorType = int_errType;
    this.errorMsg = str_errMsg;
    this.obj_result = obj_res;
  }
};
var YDataStream = class {
  constructor(obj_parent, obj_dataset, encoded) {
    this._cal = null;
    this._runNo = 0;
    this._utcStamp = 0;
    this._nCols = 0;
    this._nRows = 0;
    this._startTime = 0;
    this._duration = 0;
    this._dataSamplesInterval = 0;
    this._firstMeasureDuration = 0;
    this._columnNames = [];
    this._functionId = "";
    this._isClosed = false;
    this._isAvg = false;
    this._minVal = 0;
    this._avgVal = 0;
    this._maxVal = 0;
    this._values = [];
    this._isLoaded = false;
    this.DATA_INVALID = YAPI_INVALID_DOUBLE;
    this.DURATION_INVALID = YAPI_INVALID_DOUBLE;
    this._parent = obj_parent;
    this._yapi = this._parent._yapi;
    if (typeof obj_dataset != "undefined") {
      this.imm_initFromDataSet(obj_dataset, encoded);
    }
  }
  _parseCalibArr(iCalib) {
    let caltyp;
    let calhdl;
    let maxpos;
    let position;
    let calpar = [];
    let calraw = [];
    let calref = [];
    let fRaw;
    let fRef;
    caltyp = iCalib[0] / 1e3 >> 0;
    if (caltyp < YOCTO_CALIB_TYPE_OFS) {
      this._cal = null;
      return YAPI_SUCCESS;
    }
    calhdl = this._yapi.imm_getCalibrationHandler(caltyp);
    if (!(calhdl != null)) {
      this._cal = null;
      return YAPI_SUCCESS;
    }
    maxpos = iCalib.length;
    calpar.length = 0;
    position = 1;
    while (position < maxpos) {
      calpar.push(iCalib[position]);
      position = position + 1;
    }
    calraw.length = 0;
    calref.length = 0;
    position = 1;
    while (position + 1 < maxpos) {
      fRaw = iCalib[position];
      fRaw = fRaw / 1e3;
      fRef = iCalib[position + 1];
      fRef = fRef / 1e3;
      calraw.push(fRaw);
      calref.push(fRef);
      position = position + 2;
    }
    this._cal = {src: "", hdl: calhdl, typ: caltyp, par: calpar, raw: calraw, cal: calref};
    return YAPI_SUCCESS;
  }
  imm_initFromDataSet(dataset, encoded) {
    let val;
    let ms_offset;
    let samplesPerHour;
    let caltyp;
    let iCalib = [];
    this._runNo = encoded[0] + (encoded[1] << 16);
    this._utcStamp = encoded[2] + (encoded[3] << 16);
    val = encoded[4];
    this._isAvg = (val & 256) == 0;
    samplesPerHour = val & 255;
    if ((val & 256) != 0) {
      samplesPerHour = samplesPerHour * 3600;
    } else {
      if ((val & 512) != 0) {
        samplesPerHour = samplesPerHour * 60;
      }
    }
    this._dataSamplesInterval = 3600 / samplesPerHour;
    ms_offset = encoded[6];
    if (ms_offset < 1e3) {
      this._startTime = this._utcStamp + ms_offset / 1e3;
    } else {
      this._startTime = this._utcStamp - this._dataSamplesInterval;
    }
    this._firstMeasureDuration = encoded[5];
    if (!this._isAvg) {
      this._firstMeasureDuration = this._firstMeasureDuration / 1e3;
    }
    val = encoded[7];
    this._isClosed = val != 65535;
    if (val == 65535) {
      val = 0;
    }
    this._nRows = val;
    if (this._nRows > 0) {
      if (this._firstMeasureDuration > 0) {
        this._duration = this._firstMeasureDuration + (this._nRows - 1) * this._dataSamplesInterval;
      } else {
        this._duration = this._nRows * this._dataSamplesInterval;
      }
    } else {
      this._duration = 0;
    }
    iCalib = dataset.imm_get_calibration();
    caltyp = iCalib[0];
    if (caltyp == 0) {
      this._cal = null;
    } else {
      this._parseCalibArr(iCalib);
    }
    this._functionId = dataset.imm_get_functionId();
    if (this._isAvg) {
      this._columnNames.length = 0;
      this._columnNames.push(this._functionId + "_min");
      this._columnNames.push(this._functionId + "_avg");
      this._columnNames.push(this._functionId + "_max");
      this._nCols = 3;
    } else {
      this._columnNames.length = 0;
      this._columnNames.push(this._functionId);
      this._nCols = 1;
    }
    if (this._nRows > 0) {
      this._avgVal = this.imm_decodeAvg(encoded[8] + ((encoded[9] ^ 32768) << 16), 1);
      this._minVal = this.imm_decodeVal(encoded[10] + (encoded[11] << 16));
      this._maxVal = this.imm_decodeVal(encoded[12] + (encoded[13] << 16));
    }
    return 0;
  }
  imm_parseStream(sdata) {
    let idx;
    let udat = [];
    let dat = [];
    if (this._isLoaded && !this._isClosed) {
      return YAPI_SUCCESS;
    }
    if (sdata.length == 0) {
      this._nRows = 0;
      return YAPI_SUCCESS;
    }
    udat = this._yapi.imm_decodeWords(this._parent.imm_json_get_string(sdata));
    this._values.length = 0;
    idx = 0;
    if (this._isAvg) {
      while (idx + 3 < udat.length) {
        dat.length = 0;
        if (udat[idx] == 65535 && udat[idx + 1] == 65535) {
          dat.push(NaN);
          dat.push(NaN);
          dat.push(NaN);
        } else {
          dat.push(this.imm_decodeVal(udat[idx + 2] + (udat[idx + 3] << 16)));
          dat.push(this.imm_decodeAvg(udat[idx] + ((udat[idx + 1] ^ 32768) << 16), 1));
          dat.push(this.imm_decodeVal(udat[idx + 4] + (udat[idx + 5] << 16)));
        }
        idx = idx + 6;
        this._values.push(dat.slice());
      }
    } else {
      while (idx + 1 < udat.length) {
        dat.length = 0;
        if (udat[idx] == 65535 && udat[idx + 1] == 65535) {
          dat.push(NaN);
        } else {
          dat.push(this.imm_decodeAvg(udat[idx] + ((udat[idx + 1] ^ 32768) << 16), 1));
        }
        this._values.push(dat.slice());
        idx = idx + 2;
      }
    }
    this._nRows = this._values.length;
    this._isLoaded = true;
    return YAPI_SUCCESS;
  }
  imm_wasLoaded() {
    return this._isLoaded;
  }
  imm_get_url() {
    let url;
    url = "logger.json?id=" + this._functionId + "&run=" + String(Math.round(this._runNo)) + "&utc=" + String(Math.round(this._utcStamp));
    return url;
  }
  imm_get_baseurl() {
    let url;
    url = "logger.json?id=" + this._functionId + "&run=" + String(Math.round(this._runNo)) + "&utc=";
    return url;
  }
  imm_get_urlsuffix() {
    let url;
    url = String(Math.round(this._utcStamp));
    return url;
  }
  async loadStream() {
    return this.imm_parseStream(await this._parent._download(this.imm_get_url()));
  }
  imm_decodeVal(w) {
    let val;
    val = w / 1e3;
    if (!(this._cal == null)) {
      val = this._cal.hdl(val, this._cal.typ, this._cal.par, this._cal.raw, this._cal.cal);
    }
    return val;
  }
  imm_decodeAvg(dw, count) {
    let val;
    val = dw / 1e3;
    if (!(this._cal == null)) {
      val = this._cal.hdl(val, this._cal.typ, this._cal.par, this._cal.raw, this._cal.cal);
    }
    return val;
  }
  async isClosed() {
    return this._isClosed;
  }
  async get_runIndex() {
    return this._runNo;
  }
  async get_startTime() {
    return this._utcStamp - (Date.now() / 1e3 >> 0);
  }
  async get_startTimeUTC() {
    return Math.round(this._startTime);
  }
  async get_realStartTimeUTC() {
    return this._startTime;
  }
  async get_dataSamplesIntervalMs() {
    return Math.round(this._dataSamplesInterval * 1e3);
  }
  async get_dataSamplesInterval() {
    return this._dataSamplesInterval;
  }
  async get_firstDataSamplesInterval() {
    return this._firstMeasureDuration;
  }
  async get_rowCount() {
    if (this._nRows != 0 && this._isClosed) {
      return this._nRows;
    }
    await this.loadStream();
    return this._nRows;
  }
  async get_columnCount() {
    if (this._nCols != 0) {
      return this._nCols;
    }
    await this.loadStream();
    return this._nCols;
  }
  async get_columnNames() {
    if (this._columnNames.length != 0) {
      return this._columnNames;
    }
    await this.loadStream();
    return this._columnNames;
  }
  async get_minValue() {
    return this._minVal;
  }
  async get_averageValue() {
    return this._avgVal;
  }
  async get_maxValue() {
    return this._maxVal;
  }
  async get_realDuration() {
    if (this._isClosed) {
      return this._duration;
    }
    return (Date.now() / 1e3 >> 0) - this._utcStamp;
  }
  async get_dataRows() {
    if (this._values.length == 0 || !this._isClosed) {
      await this.loadStream();
    }
    return this._values;
  }
  async get_data(row, col) {
    if (this._values.length == 0 || !this._isClosed) {
      await this.loadStream();
    }
    if (row >= this._values.length) {
      return YDataStream.DATA_INVALID;
    }
    if (col >= this._values[row].length) {
      return YDataStream.DATA_INVALID;
    }
    return this._values[row][col];
  }
};
YDataStream.DATA_INVALID = YAPI_INVALID_DOUBLE;
YDataStream.DURATION_INVALID = YAPI_INVALID_DOUBLE;
var YDataSet = class {
  constructor(obj_parent, str_functionId = "", str_unit = "", double_startTime = 0, double_endTime = 0) {
    this._hardwareId = "";
    this._functionId = "";
    this._unit = "";
    this._bulkLoad = 0;
    this._startTimeMs = 0;
    this._endTimeMs = 0;
    this._progress = 0;
    this._calib = [];
    this._streams = [];
    this._preview = [];
    this._measures = [];
    this._summaryMinVal = 0;
    this._summaryMaxVal = 0;
    this._summaryTotalAvg = 0;
    this._summaryTotalTime = 0;
    this.DATA_INVALID = YAPI_INVALID_DOUBLE;
    this.DURATION_INVALID = YAPI_INVALID_DOUBLE;
    this.HARDWAREID_INVALID = YAPI_INVALID_STRING;
    this.FUNCTIONID_INVALID = YAPI_INVALID_STRING;
    this.UNIT_INVALID = YAPI_INVALID_STRING;
    this._summary = new YMeasure(0, 0, 0, 0, 0);
    if (str_functionId == "") {
      this._parent = obj_parent;
      this._yapi = obj_parent._yapi;
      this._startTimeMs = 0;
      this._endTimeMs = 0;
    } else {
      this._parent = obj_parent;
      this._yapi = obj_parent._yapi;
      this._functionId = str_functionId;
      this._unit = str_unit;
      this._startTimeMs = double_startTime * 1e3;
      this._endTimeMs = double_endTime * 1e3;
      this._progress = -1;
    }
  }
  imm_get_functionId() {
    return this._functionId;
  }
  imm_get_calibration() {
    return this._calib;
  }
  async loadSummary(data) {
    let dataRows = [];
    let tim;
    let mitv;
    let itv;
    let fitv;
    let end_;
    let nCols;
    let minCol;
    let avgCol;
    let maxCol;
    let res;
    let m_pos;
    let previewTotalTime;
    let previewTotalAvg;
    let previewMinVal;
    let previewMaxVal;
    let previewAvgVal;
    let previewStartMs;
    let previewStopMs;
    let previewDuration;
    let streamStartTimeMs;
    let streamDuration;
    let streamEndTimeMs;
    let minVal;
    let avgVal;
    let maxVal;
    let summaryStartMs;
    let summaryStopMs;
    let summaryTotalTime;
    let summaryTotalAvg;
    let summaryMinVal;
    let summaryMaxVal;
    let url;
    let strdata;
    let measure_data = [];
    if (this._progress < 0) {
      strdata = this._yapi.imm_bin2str(data);
      if (strdata == "{}") {
        this._parent._throw(YAPI_VERSION_MISMATCH, "device firmware is too old");
        return YAPI_VERSION_MISMATCH;
      }
      res = await this._parse(strdata);
      if (res < 0) {
        return res;
      }
    }
    summaryTotalTime = 0;
    summaryTotalAvg = 0;
    summaryMinVal = YAPI_MAX_DOUBLE;
    summaryMaxVal = YAPI_MIN_DOUBLE;
    summaryStartMs = YAPI_MAX_DOUBLE;
    summaryStopMs = YAPI_MIN_DOUBLE;
    for (let ii_0 of this._streams) {
      streamStartTimeMs = Math.round(await ii_0.get_realStartTimeUTC() * 1e3);
      streamDuration = await ii_0.get_realDuration();
      streamEndTimeMs = streamStartTimeMs + Math.round(streamDuration * 1e3);
      if (streamStartTimeMs >= this._startTimeMs && (this._endTimeMs == 0 || streamEndTimeMs <= this._endTimeMs)) {
        previewMinVal = await ii_0.get_minValue();
        previewAvgVal = await ii_0.get_averageValue();
        previewMaxVal = await ii_0.get_maxValue();
        previewStartMs = streamStartTimeMs;
        previewStopMs = streamEndTimeMs;
        previewDuration = streamDuration;
      } else {
        if (!ii_0.imm_wasLoaded()) {
          url = ii_0.imm_get_url();
          data = await this._parent._download(url);
          ii_0.imm_parseStream(data);
        }
        dataRows = await ii_0.get_dataRows();
        if (dataRows.length == 0) {
          return await this.get_progress();
        }
        tim = streamStartTimeMs;
        fitv = Math.round(await ii_0.get_firstDataSamplesInterval() * 1e3);
        itv = Math.round(await ii_0.get_dataSamplesInterval() * 1e3);
        nCols = dataRows[0].length;
        minCol = 0;
        if (nCols > 2) {
          avgCol = 1;
        } else {
          avgCol = 0;
        }
        if (nCols > 2) {
          maxCol = 2;
        } else {
          maxCol = 0;
        }
        previewTotalTime = 0;
        previewTotalAvg = 0;
        previewStartMs = streamEndTimeMs;
        previewStopMs = streamStartTimeMs;
        previewMinVal = YAPI_MAX_DOUBLE;
        previewMaxVal = YAPI_MIN_DOUBLE;
        m_pos = 0;
        while (m_pos < dataRows.length) {
          measure_data = dataRows[m_pos];
          if (m_pos == 0) {
            mitv = fitv;
          } else {
            mitv = itv;
          }
          end_ = tim + mitv;
          if (end_ > this._startTimeMs && (this._endTimeMs == 0 || tim < this._endTimeMs)) {
            minVal = measure_data[minCol];
            avgVal = measure_data[avgCol];
            maxVal = measure_data[maxCol];
            if (previewStartMs > tim) {
              previewStartMs = tim;
            }
            if (previewStopMs < end_) {
              previewStopMs = end_;
            }
            if (previewMinVal > minVal) {
              previewMinVal = minVal;
            }
            if (previewMaxVal < maxVal) {
              previewMaxVal = maxVal;
            }
            if (!isNaN(avgVal)) {
              previewTotalAvg = previewTotalAvg + avgVal * mitv;
              previewTotalTime = previewTotalTime + mitv;
            }
          }
          tim = end_;
          m_pos = m_pos + 1;
        }
        if (previewTotalTime > 0) {
          previewAvgVal = previewTotalAvg / previewTotalTime;
          previewDuration = (previewStopMs - previewStartMs) / 1e3;
        } else {
          previewAvgVal = 0;
          previewDuration = 0;
        }
      }
      this._preview.push(new YMeasure(previewStartMs / 1e3, previewStopMs / 1e3, previewMinVal, previewAvgVal, previewMaxVal));
      if (summaryMinVal > previewMinVal) {
        summaryMinVal = previewMinVal;
      }
      if (summaryMaxVal < previewMaxVal) {
        summaryMaxVal = previewMaxVal;
      }
      if (summaryStartMs > previewStartMs) {
        summaryStartMs = previewStartMs;
      }
      if (summaryStopMs < previewStopMs) {
        summaryStopMs = previewStopMs;
      }
      summaryTotalAvg = summaryTotalAvg + previewAvgVal * previewDuration;
      summaryTotalTime = summaryTotalTime + previewDuration;
    }
    if (this._startTimeMs == 0 || this._startTimeMs > summaryStartMs) {
      this._startTimeMs = summaryStartMs;
    }
    if (this._endTimeMs == 0 || this._endTimeMs < summaryStopMs) {
      this._endTimeMs = summaryStopMs;
    }
    if (summaryTotalTime > 0) {
      this._summary = new YMeasure(summaryStartMs / 1e3, summaryStopMs / 1e3, summaryMinVal, summaryTotalAvg / summaryTotalTime, summaryMaxVal);
    } else {
      this._summary = new YMeasure(0, 0, YAPI_INVALID_DOUBLE, YAPI_INVALID_DOUBLE, YAPI_INVALID_DOUBLE);
    }
    return await this.get_progress();
  }
  async processMore(progress, data) {
    let stream;
    let dataRows = [];
    let tim;
    let itv;
    let fitv;
    let avgv;
    let end_;
    let nCols;
    let minCol;
    let avgCol;
    let maxCol;
    let firstMeasure;
    let baseurl;
    let url;
    let suffix;
    let suffixes = [];
    let idx;
    let bulkFile;
    let urlIdx;
    let streamBin = [];
    if (progress != this._progress) {
      return this._progress;
    }
    if (this._progress < 0) {
      return await this.loadSummary(data);
    }
    stream = this._streams[this._progress];
    if (!stream.imm_wasLoaded()) {
      stream.imm_parseStream(data);
    }
    dataRows = await stream.get_dataRows();
    this._progress = this._progress + 1;
    if (dataRows.length == 0) {
      return await this.get_progress();
    }
    tim = Math.round(await stream.get_realStartTimeUTC() * 1e3);
    fitv = Math.round(await stream.get_firstDataSamplesInterval() * 1e3);
    itv = Math.round(await stream.get_dataSamplesInterval() * 1e3);
    if (fitv == 0) {
      fitv = itv;
    }
    if (tim < itv) {
      tim = itv;
    }
    nCols = dataRows[0].length;
    minCol = 0;
    if (nCols > 2) {
      avgCol = 1;
    } else {
      avgCol = 0;
    }
    if (nCols > 2) {
      maxCol = 2;
    } else {
      maxCol = 0;
    }
    firstMeasure = true;
    for (let ii_0 of dataRows) {
      if (firstMeasure) {
        end_ = tim + fitv;
        firstMeasure = false;
      } else {
        end_ = tim + itv;
      }
      avgv = ii_0[avgCol];
      if (end_ > this._startTimeMs && (this._endTimeMs == 0 || tim < this._endTimeMs) && !isNaN(avgv)) {
        this._measures.push(new YMeasure(tim / 1e3, end_ / 1e3, ii_0[minCol], avgv, ii_0[maxCol]));
      }
      tim = end_;
    }
    if (this._bulkLoad > 0 && this._progress < this._streams.length) {
      stream = this._streams[this._progress];
      if (stream.imm_wasLoaded()) {
        return await this.get_progress();
      }
      baseurl = stream.imm_get_baseurl();
      url = stream.imm_get_url();
      suffix = stream.imm_get_urlsuffix();
      suffixes.push(suffix);
      idx = this._progress + 1;
      while (idx < this._streams.length && suffixes.length < this._bulkLoad) {
        stream = this._streams[idx];
        if (!stream.imm_wasLoaded() && stream.imm_get_baseurl() == baseurl) {
          suffix = stream.imm_get_urlsuffix();
          suffixes.push(suffix);
          url = url + "," + suffix;
        }
        idx = idx + 1;
      }
      bulkFile = await this._parent._download(url);
      streamBin = this._parent.imm_json_get_array(bulkFile);
      urlIdx = 0;
      idx = this._progress;
      while (idx < this._streams.length && urlIdx < suffixes.length && urlIdx < streamBin.length) {
        stream = this._streams[idx];
        if (stream.imm_get_baseurl() == baseurl && stream.imm_get_urlsuffix() == suffixes[urlIdx]) {
          stream.imm_parseStream(streamBin[urlIdx]);
          urlIdx = urlIdx + 1;
        }
        idx = idx + 1;
      }
    }
    return await this.get_progress();
  }
  async get_privateDataStreams() {
    return this._streams;
  }
  async get_hardwareId() {
    let mo;
    if (!(this._hardwareId == "")) {
      return this._hardwareId;
    }
    mo = await this._parent.get_module();
    this._hardwareId = await mo.get_serialNumber() + "." + await this.get_functionId();
    return this._hardwareId;
  }
  async get_functionId() {
    return this._functionId;
  }
  async get_unit() {
    return this._unit;
  }
  async get_startTimeUTC() {
    return this.imm_get_startTimeUTC();
  }
  imm_get_startTimeUTC() {
    return this._startTimeMs / 1e3;
  }
  async get_endTimeUTC() {
    return this.imm_get_endTimeUTC();
  }
  imm_get_endTimeUTC() {
    return Math.round(this._endTimeMs / 1e3);
  }
  async get_progress() {
    if (this._progress < 0) {
      return 0;
    }
    if (this._progress >= this._streams.length) {
      return 100;
    }
    return (1 + (1 + this._progress) * 98) / (1 + this._streams.length) >> 0;
  }
  async loadMore() {
    let url;
    let stream;
    if (this._progress < 0) {
      url = "logger.json?id=" + this._functionId;
      if (this._startTimeMs != 0) {
        url = url + "&from=" + String(Math.round(this.imm_get_startTimeUTC()));
      }
      if (this._endTimeMs != 0) {
        url = url + "&to=" + String(Math.round(this.imm_get_endTimeUTC() + 1));
      }
    } else {
      if (this._progress >= this._streams.length) {
        return 100;
      } else {
        stream = this._streams[this._progress];
        if (stream.imm_wasLoaded()) {
          return await this.processMore(this._progress, this._yapi.imm_str2bin(""));
        }
        url = stream.imm_get_url();
      }
    }
    try {
      return await this.processMore(this._progress, await this._parent._download(url));
    } catch (e) {
      return await this.processMore(this._progress, await this._parent._download(url));
    }
  }
  async get_summary() {
    return this._summary;
  }
  async get_preview() {
    return this._preview;
  }
  async get_measuresAt(measure) {
    let startUtcMs;
    let stream;
    let dataRows = [];
    let measures = [];
    let tim;
    let itv;
    let end_;
    let nCols;
    let minCol;
    let avgCol;
    let maxCol;
    startUtcMs = measure.get_startTimeUTC() * 1e3;
    stream = null;
    for (let ii_0 of this._streams) {
      if (Math.round(await ii_0.get_realStartTimeUTC() * 1e3) == startUtcMs) {
        stream = ii_0;
      }
    }
    if (stream == null) {
      return measures;
    }
    dataRows = await stream.get_dataRows();
    if (dataRows.length == 0) {
      return measures;
    }
    tim = Math.round(await stream.get_realStartTimeUTC() * 1e3);
    itv = Math.round(await stream.get_dataSamplesInterval() * 1e3);
    if (tim < itv) {
      tim = itv;
    }
    nCols = dataRows[0].length;
    minCol = 0;
    if (nCols > 2) {
      avgCol = 1;
    } else {
      avgCol = 0;
    }
    if (nCols > 2) {
      maxCol = 2;
    } else {
      maxCol = 0;
    }
    for (let ii_1 of dataRows) {
      end_ = tim + itv;
      if (end_ > this._startTimeMs && (this._endTimeMs == 0 || tim < this._endTimeMs)) {
        measures.push(new YMeasure(tim / 1e3, end_ / 1e3, ii_1[minCol], ii_1[avgCol], ii_1[maxCol]));
      }
      tim = end_;
    }
    return measures;
  }
  async get_measures() {
    return this._measures;
  }
  async _parse(str_json) {
    let loadval = null;
    try {
      loadval = JSON.parse(str_json);
    } catch (err) {
    }
    if (!loadval) {
      this._progress = 0;
      return await this.get_progress();
    }
    this._functionId = loadval.id;
    this._unit = loadval.unit;
    this._bulkLoad = loadval.bulk ? parseInt(loadval.bulk) : 0;
    if (loadval.calib) {
      this._calib = this._yapi.imm_decodeFloats(loadval.calib);
      this._calib[0] = this._calib[0] / 1e3 >> 0;
    } else {
      this._calib = this._yapi.imm_decodeWords(loadval.cal);
    }
    this._summary = new YMeasure(0, 0, 0, 0, 0);
    this._streams = [];
    this._preview = [];
    this._measures = [];
    for (let i = 0; i < loadval.streams.length; i++) {
      let stream = this._parent.imm_findDataStream(this, loadval.streams[i]);
      if (!stream)
        continue;
      let streamStartTime = await stream.get_realStartTimeUTC() * 1e3;
      let streamEndTime = streamStartTime + await stream.get_realDuration() * 1e3;
      if (this._startTimeMs > 0 && streamEndTime <= this._startTimeMs) {
      } else if (this._endTimeMs > 0 && streamStartTime >= this._endTimeMs) {
      } else {
        this._streams.push(stream);
      }
    }
    this._progress = 0;
    return this.get_progress();
  }
};
YDataSet.DATA_INVALID = YAPI_INVALID_DOUBLE;
YDataSet.DURATION_INVALID = YAPI_INVALID_DOUBLE;
YDataSet.HARDWAREID_INVALID = YAPI_INVALID_STRING;
YDataSet.FUNCTIONID_INVALID = YAPI_INVALID_STRING;
YDataSet.UNIT_INVALID = YAPI_INVALID_STRING;
YDataSet.DATA_INVALID = YAPI_INVALID_DOUBLE;
YDataSet.DURATION_INVALID = YAPI_INVALID_DOUBLE;
YDataSet.HARDWAREID_INVALID = YAPI_INVALID_STRING;
YDataSet.FUNCTIONID_INVALID = YAPI_INVALID_STRING;
YDataSet.UNIT_INVALID = YAPI_INVALID_STRING;
var YDevice = class {
  constructor(obj_yapi, str_rooturl, obj_wpRec, obj_ypRecs) {
    this._yapi = obj_yapi;
    this._rootUrl = str_rooturl;
    this._serialNumber = "";
    this._logicalName = "";
    this._productName = "";
    this._productId = 0;
    this._beacon = 0;
    this._devYdx = -1;
    this._lastErrorType = YAPI_SUCCESS;
    this._lastErrorMsg = "no error";
    this._cache = {_expiration: 0, _json: new Uint8Array(0), _precooked: {}};
    this._functions = [];
    this._busy = 0;
    this._pendingQueries = Promise.resolve();
    this._lastTimeRef = 0;
    this._lastDuration = 0;
    this._logCallback = null;
    this._logIsPulling = false;
    this._logpos = 0;
    if (obj_wpRec && obj_ypRecs) {
      this._serialNumber = obj_wpRec.serialNumber;
      this._logicalName = obj_wpRec.logicalName;
      this._productName = obj_wpRec.productName;
      this._productId = obj_wpRec.productId;
      this._beacon = obj_wpRec.beacon;
      this._devYdx = obj_wpRec.index == void 0 ? -1 : obj_wpRec.index;
      this.imm_updateFromYP(obj_ypRecs);
      this._yapi.imm_reindexDevice(this);
    }
  }
  _throw(int_errType, str_errMsg, obj_retVal) {
    this._lastErrorType = int_errType;
    this._lastErrorMsg = str_errMsg;
    return this._yapi._throw(int_errType, str_errMsg, obj_retVal);
  }
  imm_getRootUrl() {
    return this._rootUrl;
  }
  imm_getSerialNumber() {
    return this._serialNumber;
  }
  imm_getLogicalName() {
    return this._logicalName;
  }
  async getLogicalName() {
    if (this._cache._expiration == 0) {
      await this.refresh();
    }
    return this._logicalName;
  }
  imm_getProductName() {
    return this._productName;
  }
  imm_getProductId() {
    return this._productId;
  }
  imm_getBeacon() {
    return this._beacon;
  }
  async getBeacon() {
    if (this._cache._expiration == 0) {
      await this.refresh();
    }
    return this._beacon;
  }
  imm_getLastTimeRef() {
    return this._lastTimeRef;
  }
  imm_getLastDuration() {
    return this._lastDuration;
  }
  imm_triggerLogPull() {
    if (this._logCallback == null || this._logIsPulling) {
      return;
    }
    this._logIsPulling = true;
    let request = "GET logs.txt?pos=" + this._logpos;
    let prom = this._yapi.devRequest(this._rootUrl, request, null, 0);
    prom.then(async (yreq) => {
      if (yreq.errorType != YAPI_SUCCESS) {
        this._logIsPulling = false;
        return;
      }
      if (this._logCallback == null) {
        this._logIsPulling = false;
        return;
      }
      let resultStr = YAPI.imm_bin2str(yreq.bin_result);
      let pos = resultStr.lastIndexOf("\n@");
      if (pos < 0) {
        this._logIsPulling = false;
        return;
      }
      let logs = resultStr.substring(0, pos);
      let posStr = resultStr.substring(pos + 2);
      this._logpos = parseInt(posStr);
      let module = YModule.FindModuleInContext(this._yapi, this._serialNumber);
      let lines = logs.trim().split("\n");
      try {
        for (let i = 0; i < lines.length; i++) {
          await this._logCallback(module, lines[i]);
        }
      } catch (e) {
        this._yapi.imm_log("Exception in device log callback:", e);
      }
      this._logIsPulling = false;
    });
  }
  imm_registerLogCallback(callback) {
    this._logCallback = callback;
    if (callback != null) {
      this.imm_triggerLogPull();
    } else {
      this._logpos = 0;
      this._logIsPulling = false;
    }
  }
  imm_setTimeRef(float_timestamp, float_duration) {
    this._lastTimeRef = float_timestamp;
    this._lastDuration = float_duration;
  }
  imm_getDevYdx() {
    return this._devYdx;
  }
  imm_describe() {
    let res = this._rootUrl;
    if (this._serialNumber != "") {
      res = this._serialNumber;
      if (this._logicalName != "") {
        res = res + " (" + this._logicalName + ")";
      }
    }
    return this._productName + " " + res;
  }
  imm_updateFromYP(obj_ypRecs) {
    let funidx = 0;
    for (let categ in obj_ypRecs) {
      for (let key in obj_ypRecs[categ]) {
        let rec = obj_ypRecs[categ][key];
        let hwid = rec["hardwareId"];
        let dotpos = hwid.indexOf(".");
        if (hwid.substr(0, dotpos) == this._serialNumber) {
          let funydx = rec["index"];
          if (funydx == void 0)
            funydx = funidx;
          this._functions[funydx] = [hwid.substr(dotpos + 1), rec["logicalName"]];
          funidx++;
        }
      }
    }
  }
  async updateFromReq(yreq, loadval) {
    this._cache._expiration = this._yapi.GetTickCount() + this._yapi.defaultCacheValidity;
    this._cache._json = yreq.bin_result;
    let func;
    let reindex = false;
    if (this._productName == "") {
      for (func in loadval) {
        if (func == "module") {
          this._serialNumber = loadval.module.serialNumber;
          this._logicalName = loadval.module.logicalName;
          this._productName = loadval.module.productName;
          this._productId = loadval.module.productId;
          this._beacon = loadval.module.beacon;
        } else if (func == "services") {
          this.imm_updateFromYP(loadval.services.yellowPages);
        }
      }
      reindex = true;
    } else {
      let renamed = false;
      for (func in loadval) {
        if (func == "module") {
          if (this._logicalName != loadval.module.logicalName) {
            this._logicalName = loadval.module.logicalName;
            reindex = true;
          }
          this._beacon = loadval.module.beacon;
        } else if (func != "services") {
          let name = loadval[func]["logicalName"];
          if (name == void 0)
            name = loadval.module.logicalName;
          let pubval = loadval[func]["advertisedValue"];
          if (pubval != void 0) {
            await this._yapi.setFunctionValue(loadval.module.serialNumber + "." + func, pubval);
          }
          let funydx;
          for (funydx in this._functions) {
            if (this._functions[funydx][0] == func) {
              if (this._functions[funydx][1] != name) {
                this._functions[funydx][1] = name;
                reindex = true;
              }
              break;
            }
          }
        }
      }
    }
    if (reindex) {
      this._yapi.imm_reindexDevice(this);
    }
  }
  imm_dropCache() {
    this._cache._expiration = 0;
    this._cache._precooked = {};
  }
  imm_functionCount() {
    let funcPos = 0;
    for (let key in this._functions) {
      funcPos++;
    }
    return funcPos;
  }
  imm_functionId(int_idx) {
    let funcPos = 0;
    for (let key in this._functions) {
      if (int_idx === funcPos) {
        return this._functions[key][0];
      }
      funcPos++;
    }
    return "";
  }
  imm_functionBaseType(int_idx) {
    let funid = this.imm_functionId(int_idx);
    if (funid !== "") {
      let ftype = this._yapi.imm_getFunctionBaseType(this._serialNumber + "." + funid);
      for (let baseType in Y_BASETYPES) {
        if (Y_BASETYPES[baseType] === ftype) {
          return baseType;
        }
      }
    }
    return "Function";
  }
  imm_functionType(int_idx) {
    let funid = this.imm_functionId(int_idx);
    if (funid !== "") {
      let i;
      for (i = funid.length; i > 0; i--) {
        if (funid[i - 1] > "9") {
          break;
        }
      }
      let functionType = funid[0].toUpperCase() + funid.substr(1, i - 1);
      return functionType;
    }
    return "";
  }
  imm_functionName(int_idx) {
    let funcPos = 0;
    for (let key in this._functions) {
      if (int_idx === funcPos) {
        return this._functions[key][1];
      }
      funcPos++;
    }
    return "";
  }
  imm_functionValue(int_idx) {
    let funid = this.imm_functionId(int_idx);
    if (funid !== "") {
      return this._yapi.imm_getFunctionValue(this._serialNumber + "." + funid);
    }
    return "";
  }
  imm_functionIdByFunYdx(int_funydx) {
    if (this._functions[int_funydx]) {
      return this._functions[int_funydx][0];
    }
    return "";
  }
  imm_jzon2json(jzon, json) {
    if (Array.isArray(jzon)) {
      let sz = jzon.length;
      if (Array.isArray(json)) {
        let defval = json.length > 0 ? json[0] : null;
        let res = [];
        for (let idx = 0; idx < sz; idx++) {
          res[idx] = this.imm_jzon2json(jzon[idx], defval);
        }
        return res;
      } else if (typeof json === "object") {
        let idx = 0;
        let res = {};
        for (let key in json) {
          if (json.hasOwnProperty(key)) {
            res[key] = this.imm_jzon2json(jzon[idx], json[key]);
            idx++;
          }
        }
        return res;
      } else {
        return jzon;
      }
    } else if (typeof jzon === "object") {
      if (Array.isArray(json)) {
        return jzon;
      } else if (typeof json === "object") {
        let defval = null;
        for (let key in json) {
          if (json.hasOwnProperty(key)) {
            defval = json[key];
            break;
          }
        }
        let res = {};
        for (let key in jzon) {
          if (jzon.hasOwnProperty(key)) {
            if (json.hasOwnProperty(key) && (!Array.isArray(json[key]) || json[key].length > 0)) {
              res[key] = this.imm_jzon2json(jzon[key], json[key]);
            } else {
              res[key] = this.imm_jzon2json(jzon[key], defval);
            }
          }
        }
        return res;
      } else {
        return jzon;
      }
    }
    return jzon;
  }
  async requestAPI(int_msValidity) {
    if (this._cache._expiration > this._yapi.GetTickCount()) {
      let res = new YHTTPRequest(this._cache._json);
      res.obj_result = JSON.parse(JSON.stringify(this._cache._precooked));
      return res;
    }
    let req = "GET /api.json";
    let precooked = this._cache._precooked;
    if (precooked.module && precooked.module.firmwareRelease) {
      req += "?fw=" + encodeURIComponent(precooked.module.firmwareRelease);
    }
    let yreq = await this._yapi.devRequest(this._rootUrl, req, null, 0);
    if (yreq.errorType != YAPI_SUCCESS)
      return yreq;
    if (!int_msValidity) {
      int_msValidity = this._yapi.defaultCacheValidity;
    }
    this._cache._json = yreq.bin_result;
    try {
      yreq.obj_result = JSON.parse(this._yapi.imm_bin2str(yreq.bin_result));
      if (Array.isArray(yreq.obj_result)) {
        if (precooked.module) {
          let objres = this.imm_jzon2json(yreq.obj_result, precooked);
          yreq.obj_result = objres;
          if (objres.module && objres.module.serialNumber === objres.module.serialNumber && objres.module.firmwareRelease === objres.module.firmwareRelease) {
            let jsonstr = JSON.stringify(yreq.obj_result);
            this._cache._json = yreq.bin_result = this._yapi.imm_str2bin(jsonstr);
            this._cache._precooked = JSON.parse(jsonstr);
          } else {
            this.imm_dropCache();
            yreq.errorType = YAPI_IO_ERROR;
            yreq.errorMsg = "Request failed, could not parse API JZON result for " + this._rootUrl;
          }
        } else {
          yreq.errorType = YAPI_IO_ERROR;
          yreq.errorMsg = "Request failed, could not parse API array result for " + this._rootUrl;
        }
      } else if (yreq.obj_result.module && yreq.obj_result.module.firmwareRelease) {
        this._cache._precooked = JSON.parse(JSON.stringify(yreq.obj_result));
      }
      this._cache._expiration = this._yapi.GetTickCount() + int_msValidity;
      this._logicalName = yreq.obj_result.module.logicalName;
      this._beacon = yreq.obj_result.module.beacon;
    } catch (err) {
      yreq.errorType = YAPI_IO_ERROR;
      yreq.errorMsg = "Request failed, could not parse API JSON result for " + this._rootUrl;
    }
    return yreq;
  }
  async refresh() {
    let yreq = await this.requestAPI(this._yapi.defaultCacheValidity);
    if (yreq.errorType != YAPI_SUCCESS) {
      return this._throw(yreq.errorType, yreq.errorMsg, yreq.errorType);
    }
    await this.updateFromReq(yreq, yreq.obj_result);
    return YAPI_SUCCESS;
  }
  async waitPendingQueries() {
    let newPromise = this._pendingQueries;
    if (newPromise != null) {
      try {
        await newPromise;
      } catch (e) {
        console.log(e);
      }
    }
  }
};
var YFirmwareFile = class {
  constructor(path, serial, pictype, product, firmware, prog_version, ROM_nb_zone, FLA_nb_zone, ROM_total_size, FLA_total_size, data, zone_ofs) {
    this._path = path;
    this._serial = serial;
    this._pictype = pictype;
    this._product = product;
    this._firmware = firmware;
    this._prog_version = prog_version;
    this._ROM_nb_zone = ROM_nb_zone;
    this._FLA_nb_zone = FLA_nb_zone;
    this._ROM_total_size = ROM_total_size;
    this._FLA_total_size = FLA_total_size;
    this._data = data;
    this._zone_ofs = zone_ofs;
  }
  static imm_Parse(path, data, force) {
    const BYN_REV_V4 = 4;
    const BYN_REV_V5 = 5;
    const BYN_REV_V6 = 6;
    const MAX_ROM_ZONES_PER_FILES = 16;
    const MAX_FLASH_ZONES_PER_FILES = 4;
    const BYN_HEAD_SIZE_V4 = 96 + 8;
    const BYN_HEAD_SIZE_V5 = 96 + 32;
    const BYN_HEAD_SIZE_V6 = 96 + 48;
    const BYN_MD5_OFS_V6 = 96 + 16;
    let pos = 0;
    let getShort = () => {
      let res = data[pos] + (data[pos + 1] << 8);
      pos += 2;
      return res;
    };
    let getInt = () => {
      let res = data[pos] + (data[pos + 1] << 8) + (data[pos + 2] << 16) + (data[pos + 3] << 24);
      pos += 4;
      return res;
    };
    let getString = (maxlen) => {
      let end = pos + maxlen;
      while (end > pos && data[end - 1] == 0) {
        end--;
      }
      let res = YAPI.imm_bin2str(data.subarray(pos, end));
      pos += maxlen;
      return res;
    };
    let sign = getString(4);
    if (sign != "BYN")
      return null;
    let rev = getShort();
    let serial = getString(20);
    let pictype = getString(20);
    let product = getString(28);
    let firmware = getString(22);
    if (serial.length >= 20)
      return null;
    if (product.length >= 28)
      return null;
    if (firmware.length >= 22)
      return null;
    let ROM_nb_zone = 0;
    let FLA_nb_zone = 0;
    let ROM_total_size = 0;
    let FLA_total_size = 0;
    let prog_buf;
    let prog_version = "";
    let zone_ofs;
    let datasize;
    switch (rev) {
      case BYN_REV_V4:
        zone_ofs = BYN_HEAD_SIZE_V4;
        ROM_nb_zone = getInt();
        datasize = getInt();
        if (ROM_nb_zone > MAX_ROM_ZONES_PER_FILES)
          return null;
        if (datasize != data.length - BYN_HEAD_SIZE_V4)
          return null;
        break;
      case BYN_REV_V5:
        zone_ofs = BYN_HEAD_SIZE_V5;
        prog_version = getString(22);
        if (!force && !YFirmwareFile.imm_progCompatible(prog_version))
          return null;
        getShort();
        ROM_nb_zone = getInt();
        datasize = getInt();
        if (ROM_nb_zone > MAX_ROM_ZONES_PER_FILES)
          return null;
        if (datasize != data.length - BYN_HEAD_SIZE_V5)
          return null;
        break;
      case BYN_REV_V6:
        zone_ofs = BYN_HEAD_SIZE_V6;
        let md5hdr = data.subarray(pos, pos + 16);
        pos += 16;
        let md5hdrstr = YAPI.imm_bin2hexstr(md5hdr);
        let md5ctx = new Y_MD5Ctx();
        md5ctx.addData(data.subarray(BYN_MD5_OFS_V6));
        let md5bynstr = YAPI.imm_bin2hexstr(md5ctx.calculate());
        if (md5hdrstr != md5bynstr) {
          YAPI.imm_log("Invalid firmware image signature, file is corrupt");
          if (YAPI._logLevel >= 2) {
            YAPI.imm_log("hdr MD5: " + md5hdrstr);
            YAPI.imm_log("byn MD5: " + md5bynstr);
            YAPI.imm_log("byn size: " + data.length);
          }
          return null;
        }
        prog_version = getString(22);
        if (!force && !YFirmwareFile.imm_progCompatible(prog_version))
          return null;
        ROM_nb_zone = data[pos++];
        FLA_nb_zone = data[pos++];
        ROM_total_size = getInt();
        FLA_total_size = getInt();
        if (ROM_nb_zone > MAX_ROM_ZONES_PER_FILES)
          return null;
        if (FLA_nb_zone > MAX_FLASH_ZONES_PER_FILES)
          return null;
        break;
      default:
        return null;
    }
    return new YFirmwareFile(path, serial, pictype, product, firmware, prog_version, ROM_nb_zone, FLA_nb_zone, ROM_total_size, FLA_total_size, data, zone_ofs);
  }
  static imm_progCompatible(prog_version) {
    if (prog_version == "")
      return true;
    let apiVer = YAPI.imm_GetAPIVersion();
    let dashpos = apiVer.indexOf("-");
    if (dashpos > 0) {
      apiVer = apiVer.slice(0, dashpos);
    }
    apiVer = apiVer.slice(apiVer.lastIndexOf(".") + 1);
    if (parseInt(prog_version) > parseInt(apiVer)) {
      YAPI.imm_log("checkProgField: byn=" + prog_version + " api=" + apiVer);
      return false;
    }
    return true;
  }
  imm_getSerial() {
    return this._serial;
  }
  imm_getPictype() {
    return this._pictype;
  }
  imm_getProduct() {
    return this._product;
  }
  imm_getFirmwareRelease() {
    return this._firmware;
  }
  imm_getFirmwareReleaseAsInt() {
    return parseInt(this._firmware);
  }
  imm_getProg_version() {
    return this._prog_version;
  }
  imm_getROM_nb_zone() {
    return this._ROM_nb_zone;
  }
  imm_getFLA_nb_zone() {
    return this._FLA_nb_zone;
  }
  imm_getROM_total_size() {
    return this._ROM_total_size;
  }
  imm_getFLA_total_size() {
    return this._FLA_total_size;
  }
  imm_getData() {
    return this._data;
  }
  imm_getPath() {
    return this._path;
  }
};
var YFirmwareUpdate = class {
  constructor(obj_yapi, str_serial, str_path, bin_settings, bool_force) {
    this._serial = "";
    this._settings = new Uint8Array(0);
    this._firmwarepath = "";
    this._progress_msg = "";
    this._progress_c = 0;
    this._progress = 0;
    this._restore_step = 0;
    this._force = false;
    this._yapi = obj_yapi;
    this._serial = str_serial;
    this._firmwarepath = str_path;
    this._settings = bin_settings;
    this._force = bool_force;
  }
  imm_progress(progress, msg) {
    this._progress = progress;
    this._progress_msg = msg;
  }
  async _processMore_internal(newupdate) {
    if (!newupdate)
      return YAPI_SUCCESS;
    let bytes;
    this.imm_progress(0, "Firmware update started");
    if (typeof this._firmwarepath == "string" && this._firmwarepath.indexOf("yoctopuce.com") >= 0) {
      this.imm_progress(1, "Downloading firmware");
      bytes = await this._yapi.system_env.downloadfile(this._firmwarepath, this._yapi);
    } else {
      this.imm_progress(1, "Loading firmware");
      bytes = await this._yapi.system_env.loadfile(this._firmwarepath);
    }
    let firmware = YFirmwareFile.imm_Parse(this._firmwarepath, bytes, this._force);
    if (!firmware) {
      return this._yapi._throw(YAPI_DEVICE_NOT_FOUND, "Device " + this._serial + " is not detected", YAPI_DEVICE_NOT_FOUND);
    }
    this.imm_progress(5, "Check if module is already in bootloader");
    let hub = null;
    let module = YModule.FindModuleInContext(this._yapi, this._serial + ".module");
    if (await module.isOnline()) {
      let dev = this._yapi.imm_getDevice(this._serial);
      let baseUrl = dev.imm_getRootUrl();
      let byPos = baseUrl.indexOf("/bySerial/");
      if (byPos >= 0) {
        baseUrl = baseUrl.slice(0, byPos + 1);
      } else if (baseUrl.slice(-1) != "/")
        baseUrl = baseUrl + "/";
      let urlInfo = new _YY_UrlInfo(baseUrl);
      hub = this._yapi.imm_getHub(urlInfo);
    } else {
      let hubs = this._yapi._connectedHubs;
      for (let i = 0; i < hubs.length; i++) {
        let ldrs = await hubs[i].getBootloaders();
        if (ldrs.indexOf(this._serial) >= 0) {
          hub = hubs[i];
          break;
        }
      }
    }
    if (hub == null) {
      this.imm_progress(-1, "Device " + this._serial + " is not detected");
      return this._yapi._throw(YAPI_DEVICE_NOT_FOUND, "Device " + this._serial + " is not detected", YAPI_DEVICE_NOT_FOUND);
    }
    try {
      await hub.firmwareUpdate(this._serial, firmware, this._settings, (percent, msg) => {
        this.imm_progress(5 + (percent * 80 + 50) / 100 >> 0, msg);
      });
    } catch (e) {
      this.imm_progress(-1, e.message);
      return this._yapi._throw(YAPI_IO_ERROR, e.message, YAPI_IO_ERROR);
    }
    if (module._cache.parentHub) {
      this.imm_progress(100, "Firmware update scheduled successfully");
    } else {
      this.imm_progress(80, "Wait for the device to restart");
      let timeout = this._yapi.GetTickCount() + 6e4;
      await module.clearCache();
      while (!await module.isOnline() && timeout > this._yapi.GetTickCount()) {
        await this._yapi.Sleep(500);
        await this._yapi.UpdateDeviceList();
      }
      if (await module.isOnline()) {
        if (this._settings != null) {
          this.imm_progress(95, "Restoring device settings");
          await module.set_allSettingsAndFiles(this._settings);
          await module.saveToFlash();
        }
        let real_fw = await module.get_firmwareRelease();
        if (real_fw == firmware.imm_getFirmwareRelease()) {
          this.imm_progress(100, "Success");
        } else {
          this.imm_progress(-1, "Unable to update firmware");
        }
      } else {
        this.imm_progress(-1, "Device did not reboot correctly");
      }
    }
    return YAPI_SUCCESS;
  }
  static async checkFirmware_r(file, serial_base, force) {
    if (file.substr(-4).toLowerCase() != ".byn")
      return null;
    let bynfile = await YAPI.system_env.loadfile(file);
    let firmware = YFirmwareFile.imm_Parse(file, bynfile, force);
    if (!firmware)
      return null;
    if (firmware.imm_getSerial().slice(0, serial_base.length) != serial_base)
      return null;
    return firmware;
  }
  static async CheckFirmwareEx(serial, path, minrelease, force) {
    let link = "";
    let best_rev = 0;
    let current_rev;
    if (typeof path == "string" && path.indexOf("yoctopuce.com") >= 0) {
      try {
        let data = await YAPI.system_env.downloadfile("http://www.yoctopuce.com/FR/common/getLastFirmwareLink.php?serial=" + serial, YAPI);
        let obj = JSON.parse(YAPI.imm_bin2str(data));
        link = obj["link"];
        best_rev = obj["version"];
      } catch (e) {
        YAPI.imm_log("failed to retrieve firmware information from www.yoctopuce.com", e);
        YAPI._throw(YAPI_IO_ERROR, "failed to retrieve firmware information from www.yoctopuce.com", "");
        return "";
      }
    } else {
      let firmware = await YFirmwareUpdate.checkFirmware_r(path, serial.substring(0, 8), force);
      if (firmware != null) {
        best_rev = firmware.imm_getFirmwareReleaseAsInt();
        link = firmware.imm_getPath();
      }
    }
    if (minrelease != 0) {
      if (minrelease < best_rev) {
        return link;
      } else {
        return "";
      }
    }
    return link;
  }
  static async CheckFirmware_internal(serial, path, minrelease) {
    return YFirmwareUpdate.CheckFirmwareEx(serial, path, minrelease, false);
  }
  static async GetAllBootLoadersInContext_internal(yctx) {
    let hubs = yctx._connectedHubs;
    let res = [];
    for (let i = 0; i < hubs.length; i++) {
      let ldrs = await hubs[i].getBootloaders();
      for (let j = 0; j < ldrs.length; j++) {
        res.push(ldrs[j]);
      }
    }
    return res;
  }
  static async GetAllBootLoaders_internal() {
    return YFirmwareUpdate.GetAllBootLoadersInContext(YAPI);
  }
  async _processMore(newupdate) {
    return await this._processMore_internal(newupdate);
  }
  static async GetAllBootLoaders() {
    return await this.GetAllBootLoaders_internal();
  }
  static async GetAllBootLoadersInContext(yctx) {
    return await this.GetAllBootLoadersInContext_internal(yctx);
  }
  static async CheckFirmware(serial, path, minrelease) {
    return await this.CheckFirmware_internal(serial, path, minrelease);
  }
  async get_progress() {
    if (this._progress >= 0) {
      await this._processMore(0);
    }
    return this._progress;
  }
  async get_progressMessage() {
    return this._progress_msg;
  }
  async startUpdate() {
    let err;
    let leng;
    err = this._yapi.imm_bin2str(this._settings);
    leng = err.length;
    if (leng >= 6 && err.substr(0, 6) == "error:") {
      this._progress = -1;
      this._progress_msg = err.substr(6, leng - 6);
    } else {
      this._progress = 0;
      this._progress_c = 0;
      await this._processMore(1);
    }
    return this._progress;
  }
};
var YFunction = class {
  constructor(obj_yapi, str_func) {
    this._logicalName = YFunction.LOGICALNAME_INVALID;
    this._advertisedValue = YFunction.ADVERTISEDVALUE_INVALID;
    this._valueCallbackFunction = null;
    this._cacheExpiration = 0;
    this._serial = "";
    this._funId = "";
    this._hwId = "";
    this.LOGICALNAME_INVALID = YAPI_INVALID_STRING;
    this.ADVERTISEDVALUE_INVALID = YAPI_INVALID_STRING;
    this._yapi = obj_yapi;
    this._className = "Function";
    this._func = str_func;
    this._lastErrorType = YAPI_SUCCESS;
    this._lastErrorMsg = "no error";
    this._dataStreams = {};
    this._userData = null;
    this._cache = {_expiration: -1, functionid: "", hwid: ""};
    this._valueCallbackFunction = null;
  }
  _throw(int_errType, str_errMsg, obj_retVal) {
    this._lastErrorType = int_errType;
    this._lastErrorMsg = str_errMsg;
    return this._yapi._throw(int_errType, str_errMsg, obj_retVal);
  }
  async isReadOnly_internal() {
    try {
      let serial = await this.get_serialNumber();
      return this._yapi.isReadOnly(serial);
    } catch (e) {
      return true;
    }
  }
  imm_parseAttr(name, val) {
    switch (name) {
      case "_expiration":
        this._cacheExpiration = val;
        return 1;
      case "logicalName":
        this._logicalName = val;
        return 1;
      case "advertisedValue":
        this._advertisedValue = val;
        return 1;
    }
    return 0;
  }
  async get_logicalName() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YFunction.LOGICALNAME_INVALID;
      }
    }
    res = this._logicalName;
    return res;
  }
  async set_logicalName(newval) {
    let rest_val;
    if (!await YAPI.CheckLogicalName(newval)) {
      return this._throw(YAPI.INVALID_ARGUMENT, "Invalid name :" + newval, YAPI.INVALID_ARGUMENT);
    }
    rest_val = String(newval);
    return await this._setAttr("logicalName", rest_val);
  }
  async get_advertisedValue() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YFunction.ADVERTISEDVALUE_INVALID;
      }
    }
    res = this._advertisedValue;
    return res;
  }
  async set_advertisedValue(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("advertisedValue", rest_val);
  }
  static FindFunction(func) {
    let obj;
    obj = YFunction._FindFromCache("Function", func);
    if (obj == null) {
      obj = new YFunction(YAPI, func);
      YFunction._AddToCache("Function", func, obj);
    }
    return obj;
  }
  static FindFunctionInContext(yctx, func) {
    let obj;
    obj = YFunction._FindFromCacheInContext(yctx, "Function", func);
    if (obj == null) {
      obj = new YFunction(yctx, func);
      YFunction._AddToCache("Function", func, obj);
    }
    return obj;
  }
  async registerValueCallback(callback) {
    let val;
    if (callback != null) {
      await YFunction._UpdateValueCallbackList(this, true);
    } else {
      await YFunction._UpdateValueCallbackList(this, false);
    }
    this._valueCallbackFunction = callback;
    if (callback != null && await this.isOnline()) {
      val = this._advertisedValue;
      if (!(val == "")) {
        await this._invokeValueCallback(val);
      }
    }
    return 0;
  }
  async _invokeValueCallback(value) {
    if (this._valueCallbackFunction != null) {
      try {
        await this._valueCallbackFunction(this, value);
      } catch (e) {
        this._yapi.imm_log("Exception in valueCallback:", e);
      }
    } else {
    }
    return 0;
  }
  async muteValueCallbacks() {
    return await this.set_advertisedValue("SILENT");
  }
  async unmuteValueCallbacks() {
    return await this.set_advertisedValue("");
  }
  async loadAttribute(attrName) {
    let url;
    let attrVal;
    url = "api/" + await this.get_functionId() + "/" + attrName;
    attrVal = await this._download(url);
    return this._yapi.imm_bin2str(attrVal);
  }
  async isReadOnly() {
    return await this.isReadOnly_internal();
  }
  async get_serialNumber() {
    let m;
    m = await this.get_module();
    return await m.get_serialNumber();
  }
  _parserHelper() {
    return 0;
  }
  nextFunction() {
    let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
    if (resolve.errorType != YAPI.SUCCESS)
      return null;
    let next_hwid = this._yapi.imm_getNextHardwareId(this._className, resolve.result);
    if (next_hwid == null)
      return null;
    return YFunction.FindFunctionInContext(this._yapi, next_hwid);
  }
  static FirstFunction() {
    let next_hwid = YAPI.imm_getFirstHardwareId("Function");
    if (next_hwid == null)
      return null;
    return YFunction.FindFunction(next_hwid);
  }
  static FirstFunctionInContext(yctx) {
    let next_hwid = yctx.imm_getFirstHardwareId("Function");
    if (next_hwid == null)
      return null;
    return YFunction.FindFunctionInContext(yctx, next_hwid);
  }
  static _FindFromCacheInContext(yctx, className, func) {
    return yctx.imm_getFunction(className, func);
  }
  static _FindFromCache(className, func) {
    return YAPI.imm_getFunction(className, func);
  }
  static _AddToCache(className, func, obj) {
    obj._yapi.imm_setFunction(className, func, obj);
  }
  static _ClearCache(obj_yapi = null) {
    if (!obj_yapi)
      obj_yapi = YAPI;
    obj_yapi.imm_ResetToDefaults();
  }
  static async _UpdateValueCallbackList(obj_func, bool_add) {
    await obj_func._yapi._UpdateValueCallbackList(obj_func, bool_add);
  }
  static async _UpdateTimedReportCallbackList(obj_func, bool_add) {
    await obj_func._yapi._UpdateTimedReportCallbackList(obj_func, bool_add);
  }
  async describe() {
    if (this._hwId != "") {
      return this._className + "(" + this._func + ")=" + this._hwId;
    }
    let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
    if (resolve.errorType != YAPI_SUCCESS && resolve.result != this._func) {
      return this._className + "(" + this._func + ")=unresolved";
    }
    return this._className + "(" + this._func + ")=" + resolve.result;
  }
  async get_hardwareId() {
    if (this._hwId != "") {
      return this._hwId;
    }
    let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
    if (resolve.errorType != YAPI_SUCCESS) {
      await this.isOnline();
      resolve = this._yapi.imm_resolveFunction(this._className, this._func);
      if (resolve.errorType != YAPI_SUCCESS) {
        return this._throw(resolve.errorType, resolve.errorMsg, YFunction.HARDWAREID_INVALID);
      }
    }
    return resolve.result;
  }
  async get_functionId() {
    if (this._funId != "") {
      return this._funId;
    }
    let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
    if (resolve.errorType != YAPI_SUCCESS) {
      await this.isOnline();
      resolve = this._yapi.imm_resolveFunction(this._className, this._func);
      if (resolve.errorType != YAPI_SUCCESS) {
        return this._throw(resolve.errorType, resolve.errorMsg, YFunction.FUNCTIONID_INVALID);
      }
    }
    let hardwareId = resolve.result;
    let pos = hardwareId.indexOf(".");
    return hardwareId.substr(pos + 1);
  }
  imm_get_functionId() {
    if (this._funId != "") {
      return this._funId;
    }
    let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
    if (resolve.errorType != YAPI_SUCCESS) {
      return this._throw(resolve.errorType, resolve.errorMsg, YFunction.FUNCTIONID_INVALID);
    }
    let hardwareId = resolve.result;
    let pos = hardwareId.indexOf(".");
    return hardwareId.substr(pos + 1);
  }
  async get_friendlyName() {
    let resolve = this._yapi.imm_getFriendlyNameFunction(this._className, this._func);
    if (resolve.errorType != YAPI_SUCCESS) {
      await this.isOnline();
      resolve = this._yapi.imm_getFriendlyNameFunction(this._className, this._func);
      if (resolve.errorType != YAPI_SUCCESS) {
        return this._throw(resolve.errorType, resolve.errorMsg, YFunction.FRIENDLYNAME_INVALID);
      }
    }
    return resolve.result;
  }
  async _parse(yreq, msValidity) {
    if (!yreq.obj_result)
      return;
    yreq.obj_result._expiration = this._yapi.GetTickCount() + msValidity;
    this._cache = yreq.obj_result;
    this._serial = yreq.obj_result.deviceid;
    this._funId = yreq.obj_result.functionid;
    this._hwId = yreq.obj_result.hwid;
    for (let key in yreq.obj_result) {
      this.imm_parseAttr(key, yreq.obj_result[key]);
    }
    await this._parserHelper();
  }
  isOnline_async(func, ctx) {
    this.isOnline().then((res) => {
      func(ctx, this, res);
    }).catch((e) => {
      func(ctx, this, false);
    });
  }
  load_async(ms_validiy, func, ctx) {
    this.load(ms_validiy).then((res) => {
      func(ctx, this, YAPI_SUCCESS);
    }).catch((e) => {
      func(ctx, this, this.get_errorType());
    });
  }
  async _getAttr(str_attr) {
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS)
        return null;
    }
    if (typeof this._cache[str_attr] == "undefined") {
      this._throw(YAPI_VERSION_MISMATCH, "No such attribute " + str_attr + " in function", null);
    }
    return this._cache[str_attr];
  }
  async _getFixedAttr(str_attr) {
    if (this._cacheExpiration == 0) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS)
        return null;
    }
    if (typeof this._cache[str_attr] == "undefined") {
      this._throw(YAPI_VERSION_MISMATCH, "No such attribute " + str_attr + " in function", null);
    }
    return this._cache[str_attr];
  }
  imm_escapeAttr(str_newval) {
    return escape(str_newval).replace(/[+]/g, "%2B").replace(/%20/g, "+").replace(/%21/g, "!").replace(/%24/g, "$").replace(/%27/g, "'").replace(/%28/g, "(").replace(/%29/g, ")").replace(/%2[cC]/g, ",").replace(/%2[fF]/g, "/").replace(/%3[aA]/g, ":").replace(/%3[bB]/g, ";").replace(/%3[fF]/g, "?").replace(/%5[bB]/g, "[").replace(/%5[dD]/g, "]");
  }
  async _setAttr(str_attr, str_newval) {
    if (str_newval == void 0) {
      return this._throw(YAPI_INVALID_ARGUMENT, "Undefined value to set for attribute " + str_attr, null);
    }
    let attrname = encodeURIComponent(str_attr);
    let attrval = this.imm_escapeAttr(str_newval);
    let extra = "/" + attrname + "?" + attrname + "=" + attrval + "&.";
    if (this._cacheExpiration != 0) {
      this._cacheExpiration = this._yapi.GetTickCount();
      this._cache._expiration = this._cacheExpiration;
    }
    let yreq = await this._yapi.funcRequest(this._className, this._func, extra);
    if (yreq.errorType != YAPI_SUCCESS) {
      return this._throw(yreq.errorType, yreq.errorMsg, yreq.errorType);
    }
    return YAPI_SUCCESS;
  }
  async _download(str_path) {
    let devid = this._serial;
    if (devid == "") {
      devid = await (await this.module()).get_serialNumber();
    }
    if (devid == YAPI_INVALID_STRING) {
      return new Uint8Array(0);
    }
    let yreq = await this._yapi.devRequest(devid, "GET /" + str_path, null, 0);
    if (yreq.errorType != YAPI_SUCCESS) {
      return this._throw(yreq.errorType, yreq.errorMsg, "");
    }
    return yreq.bin_result;
  }
  async _downloadOutOfBand(str_path) {
    let devid = this._serial;
    if (devid == "") {
      devid = await (await this.module()).get_serialNumber();
    }
    if (devid == YAPI_INVALID_STRING) {
      return new Uint8Array(0);
    }
    let yreq = await this._yapi.devRequest(devid, "GET /" + str_path, null, 1);
    if (yreq.errorType != YAPI_SUCCESS) {
      return this._throw(yreq.errorType, yreq.errorMsg, "");
    }
    return yreq.bin_result;
  }
  async _uploadWithProgress(str_path, bin_content, fun_progressCb) {
    let devid = this._serial;
    if (devid == "") {
      devid = await (await this.module()).get_serialNumber();
    }
    if (devid == YAPI_INVALID_STRING) {
      let res = new YHTTPRequest(null);
      res.errorType = this.get_errorType();
      res.errorMsg = this.get_errorMessage();
      return res;
    }
    let httpreq = "POST /upload.html";
    let len = bin_content.length;
    if (typeof bin_content == "string" || bin_content instanceof String) {
      bin_content = this._yapi.imm_str2bin(bin_content);
    } else if (bin_content instanceof Array) {
      bin_content = new Uint8Array(bin_content);
    }
    return this._yapi.devRequest(devid, httpreq, new YHTTPBody(str_path, bin_content, fun_progressCb), 0);
  }
  async _uploadEx(str_path, bin_content) {
    let yreq = await this._uploadWithProgress(str_path, bin_content, null);
    if (yreq.errorType != YAPI_SUCCESS) {
      return this._throw(yreq.errorType, yreq.errorMsg, null);
    }
    return yreq.bin_result;
  }
  async _upload(str_path, bin_content) {
    let yreq = await this._uploadWithProgress(str_path, bin_content, null);
    if (yreq.errorType != YAPI_SUCCESS) {
      return this._throw(yreq.errorType, yreq.errorMsg, null);
    }
    return yreq.errorType;
  }
  wait_async(callback, context) {
    let devid = this._serial;
    if (devid == "") {
      this.module().then((module) => module.get_serialNumber().then(() => this.wait_async(callback, context)));
      return YAPI_SUCCESS;
    }
    if (devid == YAPI_INVALID_STRING) {
      callback(context, this);
      return YAPI_SUCCESS;
    }
    let lockdev = this._yapi.imm_getDevice(devid);
    let delayedCode = () => {
      callback(context, this);
    };
    lockdev._pendingQueries = lockdev._pendingQueries.then(delayedCode, delayedCode);
    return YAPI_SUCCESS;
  }
  imm_json_get_key(bin_jsonbuff, str_key) {
    let loadval = JSON.parse(this._yapi.imm_bin2str(bin_jsonbuff));
    if (typeof loadval[str_key] != "undefined") {
      return loadval[str_key];
    }
    return "";
  }
  imm_json_get_string(bin_jsonbuff) {
    return JSON.parse(this._yapi.imm_bin2str(bin_jsonbuff));
  }
  imm_json_get_array(bin_jsonbuff) {
    let loadval = JSON.parse(this._yapi.imm_bin2str(bin_jsonbuff));
    let res = [];
    for (let idx in loadval) {
      res.push(this._yapi.imm_str2bin(JSON.stringify(loadval[idx])));
    }
    return res;
  }
  imm_get_json_path(bin_json, str_path) {
    let json = JSON.parse(this._yapi.imm_bin2str(bin_json));
    let paths = str_path.split("|");
    for (let i = 0; i < paths.length; i++) {
      let tmp = paths[i];
      json = json[tmp];
      if (json == void 0) {
        return new Uint8Array();
      }
    }
    return this._yapi.imm_str2bin(JSON.stringify(json));
  }
  imm_decode_json_string(bin_json) {
    if (bin_json.length == 0) {
      return "";
    }
    return JSON.parse(this._yapi.imm_bin2str(bin_json));
  }
  imm_decode_json_int(bin_json) {
    if (bin_json.length == 0) {
      return 0;
    }
    return JSON.parse(this._yapi.imm_bin2str(bin_json));
  }
  imm_findDataStream(obj_dataset, str_def) {
    let key = obj_dataset.imm_get_functionId() + ":" + str_def;
    if (this._dataStreams[key]) {
      return this._dataStreams[key];
    }
    let words = this._yapi.imm_decodeWords(str_def);
    if (words.length < 14) {
      this._throw(YAPI.VERSION_MISMATCH, "device firwmare is too old", null);
      return null;
    }
    let newDataStream = new YDataStream(this, obj_dataset, words);
    this._dataStreams[key] = newDataStream;
    return newDataStream;
  }
  async clearDataStreamCache() {
    this._dataStreams = {};
  }
  async isOnline() {
    if (this._cacheExpiration > this._yapi.GetTickCount())
      return true;
    let yreq = await this._yapi.funcRequest(this._className, this._func, "", this._yapi.defaultCacheValidity);
    if (yreq.errorType != YAPI_SUCCESS) {
      return yreq.errorType == YAPI_DEVICE_BUSY;
    }
    await this._parse(yreq, this._yapi.defaultCacheValidity);
    return true;
  }
  get_errorType() {
    return this._lastErrorType;
  }
  get_errorMessage() {
    return this._lastErrorMsg;
  }
  async load(msValidity) {
    let yreq = await this._yapi.funcRequest(this._className, this._func, "", msValidity);
    if (yreq.errorType != YAPI_SUCCESS) {
      return this._throw(yreq.errorType, yreq.errorMsg, yreq.errorType);
    }
    await this._parse(yreq, msValidity);
    return YAPI_SUCCESS;
  }
  async clearCache() {
    let devreq = await this._yapi._funcDev(this._className, this._func);
    if (devreq.errorType != YAPI_SUCCESS) {
      return;
    }
    devreq.obj_result.device.imm_dropCache();
    if (this._cacheExpiration > 0) {
      this._cacheExpiration = this._yapi.GetTickCount();
    }
  }
  async module() {
    if (this._serial != "") {
      return YModule.FindModuleInContext(this._yapi, this._serial + ".module");
    }
    let hwid = this._func;
    let resolve;
    if (hwid.indexOf(".") < 0) {
      resolve = this._yapi.imm_resolveFunction(this._className, this._func);
      if (resolve.errorType == YAPI_SUCCESS)
        hwid = resolve.result;
    }
    let dotidx = hwid.indexOf(".");
    if (dotidx >= 0) {
      return YModule.FindModuleInContext(this._yapi, hwid.substr(0, dotidx) + ".module");
    }
    if (await this.load(this._yapi.defaultCacheValidity) == YAPI_SUCCESS) {
      resolve = this._yapi.imm_resolveFunction(this._className, this._func);
      if (resolve.result)
        hwid = resolve.result;
    }
    dotidx = hwid.indexOf(".");
    if (dotidx >= 0) {
      return YModule.FindModuleInContext(this._yapi, hwid.substr(0, dotidx) + ".module");
    }
    return YModule.FindModuleInContext(this._yapi, "module_of_" + this._className + "_" + this._func);
  }
  async get_module() {
    return this.module();
  }
  async get_functionDescriptor() {
    if (this._hwId != "") {
      return this._hwId;
    }
    let hwid = this._func;
    if (hwid.indexOf(".") < 0) {
      let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
      if (resolve.errorType != YAPI_SUCCESS)
        hwid = resolve.result;
    }
    let dotidx = hwid.indexOf(".");
    if (dotidx >= 0) {
      return hwid;
    }
    return Y_FUNCTIONDESCRIPTOR_INVALID;
  }
  async get_userData() {
    return this._userData;
  }
  async set_userData(data) {
    this._userData = data;
  }
};
YFunction.LOGICALNAME_INVALID = YAPI_INVALID_STRING;
YFunction.ADVERTISEDVALUE_INVALID = YAPI_INVALID_STRING;
(function(YFunction2) {
  YFunction2.FUNCTIONDESCRIPTOR_INVALID = YAPI_INVALID_STRING;
  YFunction2.HARDWAREID_INVALID = YAPI_INVALID_STRING;
  YFunction2.FUNCTIONID_INVALID = YAPI_INVALID_STRING;
  YFunction2.FRIENDLYNAME_INVALID = YAPI_INVALID_STRING;
})(YFunction || (YFunction = {}));
var YModule = class extends YFunction {
  constructor(yapi, func) {
    super(yapi, func);
    this._productName = YModule.PRODUCTNAME_INVALID;
    this._serialNumber = YModule.SERIALNUMBER_INVALID;
    this._productId = YModule.PRODUCTID_INVALID;
    this._productRelease = YModule.PRODUCTRELEASE_INVALID;
    this._firmwareRelease = YModule.FIRMWARERELEASE_INVALID;
    this._persistentSettings = YModule.PERSISTENTSETTINGS_INVALID;
    this._luminosity = YModule.LUMINOSITY_INVALID;
    this._beacon = YModule.BEACON_INVALID;
    this._upTime = YModule.UPTIME_INVALID;
    this._usbCurrent = YModule.USBCURRENT_INVALID;
    this._rebootCountdown = YModule.REBOOTCOUNTDOWN_INVALID;
    this._userVar = YModule.USERVAR_INVALID;
    this._valueCallbackModule = null;
    this._logCallback = null;
    this._confChangeCallback = null;
    this._beaconCallback = null;
    this.PRODUCTNAME_INVALID = YAPI_INVALID_STRING;
    this.SERIALNUMBER_INVALID = YAPI_INVALID_STRING;
    this.PRODUCTID_INVALID = YAPI_INVALID_UINT;
    this.PRODUCTRELEASE_INVALID = YAPI_INVALID_UINT;
    this.FIRMWARERELEASE_INVALID = YAPI_INVALID_STRING;
    this.PERSISTENTSETTINGS_LOADED = 0;
    this.PERSISTENTSETTINGS_SAVED = 1;
    this.PERSISTENTSETTINGS_MODIFIED = 2;
    this.PERSISTENTSETTINGS_INVALID = -1;
    this.LUMINOSITY_INVALID = YAPI_INVALID_UINT;
    this.BEACON_OFF = 0;
    this.BEACON_ON = 1;
    this.BEACON_INVALID = -1;
    this.UPTIME_INVALID = YAPI_INVALID_LONG;
    this.USBCURRENT_INVALID = YAPI_INVALID_UINT;
    this.REBOOTCOUNTDOWN_INVALID = YAPI_INVALID_INT;
    this.USERVAR_INVALID = YAPI_INVALID_INT;
    this._className = "Module";
    let devid = this._func;
    let dotidx = devid.indexOf(".");
    if (dotidx > 0)
      devid = devid.substr(0, dotidx);
    let dev = this._yapi.imm_getDevice(devid);
    if (dev) {
      this._serial = dev.imm_getSerialNumber();
      this._funId = "module";
      this._hwId = this._serial + ".module";
    }
  }
  _throw(int_errType, str_errMsg, obj_retVal) {
    this._lastErrorType = int_errType;
    this._lastErrorMsg = str_errMsg;
    return this._yapi._throw(int_errType, str_errMsg, obj_retVal);
  }
  static async _updateModuleCallbackList(YModule_module, bool_add) {
  }
  imm_getDev() {
    let devid = this._func;
    let dotidx = devid.indexOf(".");
    if (dotidx > 0)
      devid = devid.substr(0, dotidx);
    let dev = this._yapi.imm_getDevice(devid);
    if (!dev) {
      this._throw(YAPI_DEVICE_NOT_FOUND, "Device [" + devid + "] is not online", null);
    }
    return dev;
  }
  async forceDeviceRefresh() {
    let dev = this.imm_getDev();
    if (!dev || !this._serial)
      return;
    await this._yapi.ForceDeviceRefresh(this._serial);
    if (this._cacheExpiration > 0) {
      this._cacheExpiration = this._yapi.GetTickCount();
    }
  }
  async functionCount() {
    let dev = this.imm_getDev();
    if (!dev)
      return YAPI_DEVICE_NOT_FOUND;
    return dev.imm_functionCount();
  }
  async functionId(functionIndex) {
    let dev = this.imm_getDev();
    if (!dev)
      return "";
    return dev.imm_functionId(functionIndex);
  }
  async functionType(functionIndex) {
    let dev = this.imm_getDev();
    if (!dev)
      return "";
    return dev.imm_functionType(functionIndex);
  }
  async functionBaseType(functionIndex) {
    let dev = this.imm_getDev();
    if (!dev)
      return "";
    return dev.imm_functionBaseType(functionIndex);
  }
  async functionName(functionIndex) {
    let dev = this.imm_getDev();
    if (!dev)
      return "";
    return dev.imm_functionName(functionIndex);
  }
  async functionValue(functionIndex) {
    let dev = this.imm_getDev();
    if (!dev)
      return "";
    return dev.imm_functionValue(functionIndex);
  }
  async get_logicalName() {
    let dev = this.imm_getDev();
    if (dev != null && this._cache._expiration <= this._yapi.GetTickCount()) {
      return dev.getLogicalName();
    }
    let json_val = await this._getAttr("logicalName");
    return json_val == null ? YModule.LOGICALNAME_INVALID : json_val;
  }
  async set_logicalName(newval) {
    let res = await super.set_logicalName(newval);
    let dev = this.imm_getDev();
    if (dev != null) {
      dev.imm_dropCache();
    }
    return res;
  }
  imm_flattenJsonStruct_internal(jsoncomplex) {
    let decoded = JSON.parse(this._yapi.imm_bin2str(jsoncomplex));
    let attrs = [];
    for (let function_name in decoded) {
      if (function_name == "services") {
        continue;
      }
      let function_attrs = decoded[function_name];
      for (let attr_name in function_attrs) {
        let attr_value = function_attrs[attr_name];
        if (attr_value === null || typeof attr_value === "object") {
          continue;
        }
        let flat = function_name + "/" + attr_name + "=" + attr_value;
        attrs.push(flat);
      }
    }
    return this._yapi.imm_str2bin(JSON.stringify(attrs));
  }
  async get_subDevices_internal() {
    let baseUrl = await this.get_url_internal();
    if (!baseUrl) {
      return [];
    }
    let hub = null;
    let hubUrl = "";
    for (let i = 0; i < this._yapi._connectedHubs.length; i++) {
      hubUrl = this._yapi._connectedHubs[i].imm_getRootUrl();
      if (baseUrl.slice(0, hubUrl.length) == hubUrl) {
        hub = this._yapi._connectedHubs[i];
        break;
      }
    }
    if (!hub || !hubUrl) {
      return [];
    }
    let hubSerial = hub.serialByYdx[0];
    if (hubSerial != this._serial) {
      return [];
    }
    let res = [];
    for (let serial in this._yapi._devs) {
      let rooturl = this._yapi._devs[serial].imm_getRootUrl();
      if (rooturl.substr(0, hubUrl.length) == hubUrl && serial != hubSerial) {
        res.push(serial);
      }
    }
    return res;
  }
  async get_parentHub_internal() {
    let baseUrl = await this.get_url_internal();
    if (!baseUrl) {
      return "";
    }
    let hub = null;
    for (let i = 0; i < this._yapi._connectedHubs.length; i++) {
      let hubUrl = this._yapi._connectedHubs[i].imm_getRootUrl();
      if (baseUrl.slice(0, hubUrl.length) == hubUrl) {
        hub = this._yapi._connectedHubs[i];
        break;
      }
    }
    if (!hub) {
      return "";
    }
    let hubSerial = hub.serialByYdx[0];
    if (hubSerial == this._serial) {
      return "";
    }
    return hubSerial;
  }
  async get_url_internal() {
    let devid = this._serial;
    if (devid == "") {
      devid = await this.get_serialNumber();
    }
    if (devid == YAPI_INVALID_STRING) {
      return "";
    }
    let lockdev = this._yapi.imm_getDevice(devid);
    if (!lockdev) {
      return "";
    }
    return lockdev.imm_getRootUrl();
  }
  async _startStopDevLog_internal(str_serial, bool_start) {
    let dev = this.imm_getDev();
    if (dev != null) {
      return dev.imm_registerLogCallback(this._logCallback);
    }
  }
  imm_parseAttr(name, val) {
    switch (name) {
      case "productName":
        this._productName = val;
        return 1;
      case "serialNumber":
        this._serialNumber = val;
        return 1;
      case "productId":
        this._productId = val;
        return 1;
      case "productRelease":
        this._productRelease = val;
        return 1;
      case "firmwareRelease":
        this._firmwareRelease = val;
        return 1;
      case "persistentSettings":
        this._persistentSettings = val;
        return 1;
      case "luminosity":
        this._luminosity = val;
        return 1;
      case "beacon":
        this._beacon = val;
        return 1;
      case "upTime":
        this._upTime = val;
        return 1;
      case "usbCurrent":
        this._usbCurrent = val;
        return 1;
      case "rebootCountdown":
        this._rebootCountdown = val;
        return 1;
      case "userVar":
        this._userVar = val;
        return 1;
    }
    return super.imm_parseAttr(name, val);
  }
  async get_productName() {
    let res;
    let dev;
    if (this._cacheExpiration == 0) {
      dev = this.imm_getDev();
      if (!(dev == null)) {
        return dev.imm_getProductName();
      }
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YModule.PRODUCTNAME_INVALID;
      }
    }
    res = this._productName;
    return res;
  }
  async get_serialNumber() {
    let res;
    let dev;
    if (this._cacheExpiration == 0) {
      dev = this.imm_getDev();
      if (!(dev == null)) {
        return dev.imm_getSerialNumber();
      }
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YModule.SERIALNUMBER_INVALID;
      }
    }
    res = this._serialNumber;
    return res;
  }
  async get_productId() {
    let res;
    let dev;
    if (this._cacheExpiration == 0) {
      dev = this.imm_getDev();
      if (!(dev == null)) {
        return dev.imm_getProductId();
      }
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YModule.PRODUCTID_INVALID;
      }
    }
    res = this._productId;
    return res;
  }
  async get_productRelease() {
    let res;
    if (this._cacheExpiration == 0) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YModule.PRODUCTRELEASE_INVALID;
      }
    }
    res = this._productRelease;
    return res;
  }
  async get_firmwareRelease() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YModule.FIRMWARERELEASE_INVALID;
      }
    }
    res = this._firmwareRelease;
    return res;
  }
  async get_persistentSettings() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YModule.PERSISTENTSETTINGS_INVALID;
      }
    }
    res = this._persistentSettings;
    return res;
  }
  async set_persistentSettings(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("persistentSettings", rest_val);
  }
  async get_luminosity() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YModule.LUMINOSITY_INVALID;
      }
    }
    res = this._luminosity;
    return res;
  }
  async set_luminosity(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("luminosity", rest_val);
  }
  async get_beacon() {
    let res;
    let dev;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      dev = this.imm_getDev();
      if (!(dev == null)) {
        return dev.imm_getBeacon();
      }
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YModule.BEACON_INVALID;
      }
    }
    res = this._beacon;
    return res;
  }
  async set_beacon(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("beacon", rest_val);
  }
  async get_upTime() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YModule.UPTIME_INVALID;
      }
    }
    res = this._upTime;
    return res;
  }
  async get_usbCurrent() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YModule.USBCURRENT_INVALID;
      }
    }
    res = this._usbCurrent;
    return res;
  }
  async get_rebootCountdown() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YModule.REBOOTCOUNTDOWN_INVALID;
      }
    }
    res = this._rebootCountdown;
    return res;
  }
  async set_rebootCountdown(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("rebootCountdown", rest_val);
  }
  async get_userVar() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YModule.USERVAR_INVALID;
      }
    }
    res = this._userVar;
    return res;
  }
  async set_userVar(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("userVar", rest_val);
  }
  static FindModule(func) {
    let obj;
    let cleanHwId;
    let modpos;
    cleanHwId = func;
    modpos = func.indexOf(".module");
    if (modpos != func.length - 7) {
      cleanHwId = func + ".module";
    }
    obj = YFunction._FindFromCache("Module", cleanHwId);
    if (obj == null) {
      obj = new YModule(YAPI, cleanHwId);
      YFunction._AddToCache("Module", cleanHwId, obj);
    }
    return obj;
  }
  static FindModuleInContext(yctx, func) {
    let obj;
    let cleanHwId;
    let modpos;
    cleanHwId = func;
    modpos = func.indexOf(".module");
    if (modpos != func.length - 7) {
      cleanHwId = func + ".module";
    }
    obj = YFunction._FindFromCacheInContext(yctx, "Module", cleanHwId);
    if (obj == null) {
      obj = new YModule(yctx, cleanHwId);
      YFunction._AddToCache("Module", cleanHwId, obj);
    }
    return obj;
  }
  async registerValueCallback(callback) {
    let val;
    if (callback != null) {
      await YFunction._UpdateValueCallbackList(this, true);
    } else {
      await YFunction._UpdateValueCallbackList(this, false);
    }
    this._valueCallbackModule = callback;
    if (callback != null && await this.isOnline()) {
      val = this._advertisedValue;
      if (!(val == "")) {
        await this._invokeValueCallback(val);
      }
    }
    return 0;
  }
  async _invokeValueCallback(value) {
    if (this._valueCallbackModule != null) {
      try {
        await this._valueCallbackModule(this, value);
      } catch (e) {
        this._yapi.imm_log("Exception in valueCallback:", e);
      }
    } else {
      await super._invokeValueCallback(value);
    }
    return 0;
  }
  async get_productNameAndRevision() {
    let prodname;
    let prodrel;
    let fullname;
    prodname = await this.get_productName();
    prodrel = await this.get_productRelease();
    if (prodrel > 1) {
      fullname = prodname + " rev. " + String.fromCharCode(64 + prodrel);
    } else {
      fullname = prodname;
    }
    return fullname;
  }
  async saveToFlash() {
    return await this.set_persistentSettings(1);
  }
  async revertFromFlash() {
    return await this.set_persistentSettings(0);
  }
  async reboot(secBeforeReboot) {
    return await this.set_rebootCountdown(secBeforeReboot);
  }
  async triggerFirmwareUpdate(secBeforeReboot) {
    return await this.set_rebootCountdown(-secBeforeReboot);
  }
  async _startStopDevLog(serial, start) {
    return await this._startStopDevLog_internal(serial, start);
  }
  async registerLogCallback(callback) {
    let serial;
    serial = await this.get_serialNumber();
    if (serial == YAPI_INVALID_STRING) {
      return YAPI_DEVICE_NOT_FOUND;
    }
    this._logCallback = callback;
    await this._startStopDevLog(serial, callback != null);
    return 0;
  }
  async get_logCallback() {
    return this._logCallback;
  }
  async registerConfigChangeCallback(callback) {
    if (callback != null) {
      await YModule._updateModuleCallbackList(this, true);
    } else {
      await YModule._updateModuleCallbackList(this, false);
    }
    this._confChangeCallback = callback;
    return 0;
  }
  async _invokeConfigChangeCallback() {
    if (this._confChangeCallback != null) {
      try {
        await this._confChangeCallback(this);
      } catch (e) {
        this._yapi.imm_log("Exception in configChangeCallback:", e);
      }
    }
    return 0;
  }
  async registerBeaconCallback(callback) {
    if (callback != null) {
      await YModule._updateModuleCallbackList(this, true);
    } else {
      await YModule._updateModuleCallbackList(this, false);
    }
    this._beaconCallback = callback;
    return 0;
  }
  async _invokeBeaconCallback(beaconState) {
    if (this._beaconCallback != null) {
      try {
        await this._beaconCallback(this, beaconState);
      } catch (e) {
        this._yapi.imm_log("Exception in beaconCallback:", e);
      }
    }
    return 0;
  }
  async triggerConfigChangeCallback() {
    await this._setAttr("persistentSettings", "2");
    return 0;
  }
  async checkFirmware(path, onlynew) {
    let serial;
    let release;
    let tmp_res;
    if (onlynew) {
      release = YAPIContext.imm_atoi(await this.get_firmwareRelease());
    } else {
      release = 0;
    }
    serial = await this.get_serialNumber();
    tmp_res = await YFirmwareUpdate.CheckFirmware(serial, path, release);
    if (tmp_res.indexOf("error:") == 0) {
      this._throw(YAPI_INVALID_ARGUMENT, tmp_res);
    }
    return tmp_res;
  }
  async updateFirmwareEx(path, force) {
    let serial;
    let settings;
    serial = await this.get_serialNumber();
    settings = await this.get_allSettings();
    if (settings.length == 0) {
      this._throw(YAPI_IO_ERROR, "Unable to get device settings");
      settings = this._yapi.imm_str2bin("error:Unable to get device settings");
    }
    return new YFirmwareUpdate(this._yapi, serial, path, settings, force);
  }
  async updateFirmware(path) {
    return await this.updateFirmwareEx(path, false);
  }
  async get_allSettings() {
    let settings;
    let json;
    let res;
    let sep;
    let name;
    let item;
    let t_type;
    let pageid;
    let url;
    let file_data;
    let file_data_bin;
    let temp_data_bin;
    let ext_settings;
    let filelist = [];
    let templist = [];
    settings = await this._download("api.json");
    if (settings.length == 0) {
      return settings;
    }
    ext_settings = ', "extras":[';
    templist = await this.get_functionIds("Temperature");
    sep = "";
    for (let ii_0 of templist) {
      if (YAPIContext.imm_atoi(await this.get_firmwareRelease()) > 9e3) {
        url = "api/" + ii_0 + "/sensorType";
        t_type = this._yapi.imm_bin2str(await this._download(url));
        if (t_type == "RES_NTC" || t_type == "RES_LINEAR") {
          pageid = ii_0.substr(11, ii_0.length - 11);
          if (pageid == "") {
            pageid = "1";
          }
          temp_data_bin = await this._download("extra.json?page=" + pageid);
          if (temp_data_bin.length > 0) {
            item = sep + '{"fid":"' + ii_0 + '", "json":' + this._yapi.imm_bin2str(temp_data_bin) + "}\n";
            ext_settings = ext_settings + item;
            sep = ",";
          }
        }
      }
    }
    ext_settings = ext_settings + '],\n"files":[';
    if (await this.hasFunction("files")) {
      json = await this._download("files.json?a=dir&d=1&f=");
      if (json.length == 0) {
        return json;
      }
      filelist = this.imm_json_get_array(json);
      sep = "";
      for (let ii_1 of filelist) {
        name = this.imm_json_get_key(ii_1, "name");
        if (name.length > 0 && !(name == "startupConf.json")) {
          if (name.substr(name.length - 1, 1) == "/") {
            file_data = "";
          } else {
            file_data_bin = await this._download(this.imm_escapeAttr(name));
            file_data = this._yapi.imm_bin2hexstr(file_data_bin);
          }
          item = sep + '{"name":"' + name + '", "data":"' + file_data + '"}\n';
          ext_settings = ext_settings + item;
          sep = ",";
        }
      }
    }
    res = this._yapi.imm_str2bin('{ "api":' + this._yapi.imm_bin2str(settings) + ext_settings + "]}");
    return res;
  }
  async loadThermistorExtra(funcId, jsonExtra) {
    let values = [];
    let url;
    let curr;
    let binCurr;
    let currTemp;
    let binCurrTemp;
    let ofs;
    let size;
    url = "api/" + funcId + ".json?command=Z";
    await this._download(url);
    values = this.imm_json_get_array(this._yapi.imm_str2bin(jsonExtra));
    ofs = 0;
    size = values.length;
    while (ofs + 1 < size) {
      binCurr = values[ofs];
      binCurrTemp = values[ofs + 1];
      curr = this.imm_json_get_string(binCurr);
      currTemp = this.imm_json_get_string(binCurrTemp);
      url = "api/" + funcId + ".json?command=m" + curr + ":" + currTemp;
      await this._download(url);
      ofs = ofs + 2;
    }
    return YAPI_SUCCESS;
  }
  async set_extraSettings(jsonExtra) {
    let extras = [];
    let tmp;
    let functionId;
    let data;
    extras = this.imm_json_get_array(this._yapi.imm_str2bin(jsonExtra));
    for (let ii_0 of extras) {
      tmp = this.imm_get_json_path(ii_0, "fid");
      functionId = this.imm_json_get_string(tmp);
      data = this.imm_get_json_path(ii_0, "json");
      if (await this.hasFunction(functionId)) {
        await this.loadThermistorExtra(functionId, this._yapi.imm_bin2str(data));
      }
    }
    return YAPI_SUCCESS;
  }
  async set_allSettingsAndFiles(settings) {
    let down;
    let json_api;
    let json_files;
    let json_extra;
    let fuperror;
    let globalres;
    fuperror = 0;
    json_api = this.imm_get_json_path(settings, "api");
    if (json_api.length == 0) {
      return await this.set_allSettings(settings);
    }
    json_extra = this.imm_get_json_path(settings, "extras");
    if (json_extra.length > 0) {
      await this.set_extraSettings(this._yapi.imm_bin2str(json_extra));
    }
    await this.set_allSettings(json_api);
    if (await this.hasFunction("files")) {
      let files = [];
      let res;
      let tmp;
      let name;
      let data;
      down = await this._download("files.json?a=format");
      down = this.imm_get_json_path(down, "res");
      res = this.imm_json_get_string(down);
      if (!(res == "ok")) {
        return this._throw(YAPI_IO_ERROR, "format failed", YAPI_IO_ERROR);
      }
      json_files = this.imm_get_json_path(settings, "files");
      files = this.imm_json_get_array(json_files);
      for (let ii_0 of files) {
        tmp = this.imm_get_json_path(ii_0, "name");
        name = this.imm_json_get_string(tmp);
        tmp = this.imm_get_json_path(ii_0, "data");
        data = this.imm_json_get_string(tmp);
        if (name == "") {
          fuperror = fuperror + 1;
        } else {
          await this._upload(name, this._yapi.imm_hexstr2bin(data));
        }
      }
    }
    globalres = await this.set_allSettings(json_api);
    if (!(fuperror == 0)) {
      return this._throw(YAPI_IO_ERROR, "Error during file upload", YAPI_IO_ERROR);
    }
    return globalres;
  }
  async hasFunction(funcId) {
    let count;
    let i;
    let fid;
    count = await this.functionCount();
    i = 0;
    while (i < count) {
      fid = await this.functionId(i);
      if (fid == funcId) {
        return true;
      }
      i = i + 1;
    }
    return false;
  }
  async get_functionIds(funType) {
    let count;
    let i;
    let ftype;
    let res = [];
    count = await this.functionCount();
    i = 0;
    while (i < count) {
      ftype = await this.functionType(i);
      if (ftype == funType) {
        res.push(await this.functionId(i));
      } else {
        ftype = await this.functionBaseType(i);
        if (ftype == funType) {
          res.push(await this.functionId(i));
        }
      }
      i = i + 1;
    }
    return res;
  }
  imm_flattenJsonStruct(jsoncomplex) {
    return this.imm_flattenJsonStruct_internal(jsoncomplex);
  }
  async calibVersion(cparams) {
    if (cparams == "0,") {
      return 3;
    }
    if (cparams.indexOf(",") >= 0) {
      if (cparams.indexOf(" ") > 0) {
        return 3;
      } else {
        return 1;
      }
    }
    if (cparams == "" || cparams == "0") {
      return 1;
    }
    if (cparams.length < 2 || cparams.indexOf(".") >= 0) {
      return 0;
    } else {
      return 2;
    }
  }
  async calibScale(unit_name, sensorType) {
    if (unit_name == "g" || unit_name == "gauss" || unit_name == "W") {
      return 1e3;
    }
    if (unit_name == "C") {
      if (sensorType == "") {
        return 16;
      }
      if (YAPIContext.imm_atoi(sensorType) < 8) {
        return 16;
      } else {
        return 100;
      }
    }
    if (unit_name == "m" || unit_name == "deg") {
      return 10;
    }
    return 1;
  }
  async calibOffset(unit_name) {
    if (unit_name == "% RH" || unit_name == "mbar" || unit_name == "lx") {
      return 0;
    }
    return 32767;
  }
  async calibConvert(param, currentFuncValue, unit_name, sensorType) {
    let paramVer;
    let funVer;
    let funScale;
    let funOffset;
    let paramScale;
    let paramOffset;
    let words = [];
    let words_str = [];
    let calibData = [];
    let iCalib = [];
    let calibType;
    let i;
    let maxSize;
    let ratio;
    let nPoints;
    let wordVal;
    paramVer = await this.calibVersion(param);
    funVer = await this.calibVersion(currentFuncValue);
    funScale = await this.calibScale(unit_name, sensorType);
    funOffset = await this.calibOffset(unit_name);
    paramScale = funScale;
    paramOffset = funOffset;
    if (funVer < 3) {
      if (funVer == 2) {
        words = this._yapi.imm_decodeWords(currentFuncValue);
        if (words[0] == 1366 && words[1] == 12500) {
          funScale = 1;
          funOffset = 0;
        } else {
          funScale = words[1];
          funOffset = words[0];
        }
      } else {
        if (funVer == 1) {
          if (currentFuncValue == "" || YAPIContext.imm_atoi(currentFuncValue) > 10) {
            funScale = 0;
          }
        }
      }
    }
    calibData.length = 0;
    calibType = 0;
    if (paramVer < 3) {
      if (paramVer == 2) {
        words = this._yapi.imm_decodeWords(param);
        if (words[0] == 1366 && words[1] == 12500) {
          paramScale = 1;
          paramOffset = 0;
        } else {
          paramScale = words[1];
          paramOffset = words[0];
        }
        if (words.length >= 3 && words[2] > 0) {
          maxSize = 3 + 2 * (words[2] % 10);
          if (maxSize > words.length) {
            maxSize = words.length;
          }
          i = 3;
          while (i < maxSize) {
            calibData.push(words[i]);
            i = i + 1;
          }
        }
      } else {
        if (paramVer == 1) {
          words_str = param.split(",");
          for (let ii_0 of words_str) {
            words.push(YAPIContext.imm_atoi(ii_0));
          }
          if (param == "" || words[0] > 10) {
            paramScale = 0;
          }
          if (words.length > 0 && words[0] > 0) {
            maxSize = 1 + 2 * (words[0] % 10);
            if (maxSize > words.length) {
              maxSize = words.length;
            }
            i = 1;
            while (i < maxSize) {
              calibData.push(words[i]);
              i = i + 1;
            }
          }
        } else {
          if (paramVer == 0) {
            ratio = YAPIContext.imm_atof(param);
            if (ratio > 0) {
              calibData.push(0);
              calibData.push(0);
              calibData.push(Math.round(65535 / ratio));
              calibData.push(65535);
            }
          }
        }
      }
      i = 0;
      while (i < calibData.length) {
        if (paramScale > 0) {
          calibData[i] = (calibData[i] - paramOffset) / paramScale;
        } else {
          calibData[i] = this._yapi.imm_decimalToDouble(Math.round(calibData[i]));
        }
        i = i + 1;
      }
    } else {
      iCalib = this._yapi.imm_decodeFloats(param);
      calibType = Math.round(iCalib[0] / 1e3);
      if (calibType >= 30) {
        calibType = calibType - 30;
      }
      i = 1;
      while (i < iCalib.length) {
        calibData.push(iCalib[i] / 1e3);
        i = i + 1;
      }
    }
    if (funVer >= 3) {
      if (calibData.length == 0) {
        param = "0,";
      } else {
        param = (30 + calibType).toString();
        i = 0;
        while (i < calibData.length) {
          if ((i & 1) > 0) {
            param = param + ":";
          } else {
            param = param + " ";
          }
          param = param + Math.round(calibData[i] * 1e3 / 1e3).toString();
          i = i + 1;
        }
        param = param + ",";
      }
    } else {
      if (funVer >= 1) {
        nPoints = calibData.length / 2 >> 0;
        param = nPoints.toString();
        i = 0;
        while (i < 2 * nPoints) {
          if (funScale == 0) {
            wordVal = this._yapi.imm_doubleToDecimal(Math.round(calibData[i]));
          } else {
            wordVal = calibData[i] * funScale + funOffset;
          }
          param = param + "," + Math.round(wordVal).toString();
          i = i + 1;
        }
      } else {
        if (calibData.length == 4) {
          param = Math.round(1e3 * (calibData[3] - calibData[1]) / calibData[2] - calibData[0]).toString();
        }
      }
    }
    return param;
  }
  async _tryExec(url) {
    let res;
    let done;
    res = YAPI_SUCCESS;
    done = 1;
    try {
      await this._download(url);
    } catch (e) {
      done = 0;
    }
    if (done == 0) {
      try {
        await YAPI.Sleep(500);
        await this._download(url);
      } catch (e) {
        res = await this.get_errorType();
      }
    }
    return res;
  }
  async set_allSettings(settings) {
    let restoreLast = [];
    let old_json_flat;
    let old_dslist = [];
    let old_jpath = [];
    let old_jpath_len = [];
    let old_val_arr = [];
    let actualSettings;
    let new_dslist = [];
    let new_jpath = [];
    let new_jpath_len = [];
    let new_val_arr = [];
    let cpos;
    let eqpos;
    let leng;
    let i;
    let j;
    let subres;
    let res;
    let njpath;
    let jpath;
    let fun;
    let attr;
    let value;
    let old_serial;
    let new_serial;
    let url;
    let tmp;
    let binTmp;
    let sensorType;
    let unit_name;
    let newval;
    let oldval;
    let old_calib;
    let each_str;
    let do_update;
    let found;
    res = YAPI_SUCCESS;
    binTmp = this.imm_get_json_path(settings, "api");
    if (binTmp.length > 0) {
      settings = binTmp;
    }
    old_serial = "";
    oldval = "";
    newval = "";
    old_json_flat = this.imm_flattenJsonStruct(settings);
    old_dslist = this.imm_json_get_array(old_json_flat);
    for (let ii_0 of old_dslist) {
      each_str = this.imm_json_get_string(ii_0);
      leng = each_str.length;
      eqpos = each_str.indexOf("=");
      if (eqpos < 0 || leng == 0) {
        this._throw(YAPI_INVALID_ARGUMENT, "Invalid settings");
        return YAPI_INVALID_ARGUMENT;
      }
      jpath = each_str.substr(0, eqpos);
      eqpos = eqpos + 1;
      value = each_str.substr(eqpos, leng - eqpos);
      old_jpath.push(jpath);
      old_jpath_len.push(jpath.length);
      old_val_arr.push(value);
      if (jpath == "module/serialNumber") {
        old_serial = value;
      }
    }
    try {
      actualSettings = await this._download("api.json");
    } catch (e) {
      await YAPI.Sleep(500);
      actualSettings = await this._download("api.json");
    }
    new_serial = await this.get_serialNumber();
    if (old_serial == new_serial || old_serial == "") {
      old_serial = "_NO_SERIAL_FILTER_";
    }
    actualSettings = this.imm_flattenJsonStruct(actualSettings);
    new_dslist = this.imm_json_get_array(actualSettings);
    for (let ii_1 of new_dslist) {
      each_str = this.imm_json_get_string(ii_1);
      leng = each_str.length;
      eqpos = each_str.indexOf("=");
      if (eqpos < 0 || leng == 0) {
        this._throw(YAPI_INVALID_ARGUMENT, "Invalid settings");
        return YAPI_INVALID_ARGUMENT;
      }
      jpath = each_str.substr(0, eqpos);
      eqpos = eqpos + 1;
      value = each_str.substr(eqpos, leng - eqpos);
      new_jpath.push(jpath);
      new_jpath_len.push(jpath.length);
      new_val_arr.push(value);
    }
    i = 0;
    while (i < new_jpath.length) {
      njpath = new_jpath[i];
      leng = njpath.length;
      cpos = njpath.indexOf("/");
      if (cpos < 0 || leng == 0) {
        continue;
      }
      fun = njpath.substr(0, cpos);
      cpos = cpos + 1;
      attr = njpath.substr(cpos, leng - cpos);
      do_update = true;
      if (fun == "services") {
        do_update = false;
      }
      if (do_update && attr == "firmwareRelease") {
        do_update = false;
      }
      if (do_update && attr == "usbCurrent") {
        do_update = false;
      }
      if (do_update && attr == "upTime") {
        do_update = false;
      }
      if (do_update && attr == "persistentSettings") {
        do_update = false;
      }
      if (do_update && attr == "adminPassword") {
        do_update = false;
      }
      if (do_update && attr == "userPassword") {
        do_update = false;
      }
      if (do_update && attr == "rebootCountdown") {
        do_update = false;
      }
      if (do_update && attr == "advertisedValue") {
        do_update = false;
      }
      if (do_update && attr == "poeCurrent") {
        do_update = false;
      }
      if (do_update && attr == "readiness") {
        do_update = false;
      }
      if (do_update && attr == "ipAddress") {
        do_update = false;
      }
      if (do_update && attr == "subnetMask") {
        do_update = false;
      }
      if (do_update && attr == "router") {
        do_update = false;
      }
      if (do_update && attr == "linkQuality") {
        do_update = false;
      }
      if (do_update && attr == "ssid") {
        do_update = false;
      }
      if (do_update && attr == "channel") {
        do_update = false;
      }
      if (do_update && attr == "security") {
        do_update = false;
      }
      if (do_update && attr == "message") {
        do_update = false;
      }
      if (do_update && attr == "signalValue") {
        do_update = false;
      }
      if (do_update && attr == "currentValue") {
        do_update = false;
      }
      if (do_update && attr == "currentRawValue") {
        do_update = false;
      }
      if (do_update && attr == "currentRunIndex") {
        do_update = false;
      }
      if (do_update && attr == "pulseTimer") {
        do_update = false;
      }
      if (do_update && attr == "lastTimePressed") {
        do_update = false;
      }
      if (do_update && attr == "lastTimeReleased") {
        do_update = false;
      }
      if (do_update && attr == "filesCount") {
        do_update = false;
      }
      if (do_update && attr == "freeSpace") {
        do_update = false;
      }
      if (do_update && attr == "timeUTC") {
        do_update = false;
      }
      if (do_update && attr == "rtcTime") {
        do_update = false;
      }
      if (do_update && attr == "unixTime") {
        do_update = false;
      }
      if (do_update && attr == "dateTime") {
        do_update = false;
      }
      if (do_update && attr == "rawValue") {
        do_update = false;
      }
      if (do_update && attr == "lastMsg") {
        do_update = false;
      }
      if (do_update && attr == "delayedPulseTimer") {
        do_update = false;
      }
      if (do_update && attr == "rxCount") {
        do_update = false;
      }
      if (do_update && attr == "txCount") {
        do_update = false;
      }
      if (do_update && attr == "msgCount") {
        do_update = false;
      }
      if (do_update && attr == "rxMsgCount") {
        do_update = false;
      }
      if (do_update && attr == "txMsgCount") {
        do_update = false;
      }
      if (do_update) {
        do_update = false;
        j = 0;
        found = false;
        newval = new_val_arr[i];
        while (j < old_jpath.length && !found) {
          if (new_jpath_len[i] == old_jpath_len[j] && new_jpath[i] == old_jpath[j]) {
            found = true;
            oldval = old_val_arr[j];
            if (!(newval == oldval) && !(oldval == old_serial)) {
              do_update = true;
            }
          }
          j = j + 1;
        }
      }
      if (do_update) {
        if (attr == "calibrationParam") {
          old_calib = "";
          unit_name = "";
          sensorType = "";
          j = 0;
          found = false;
          while (j < old_jpath.length && !found) {
            if (new_jpath_len[i] == old_jpath_len[j] && new_jpath[i] == old_jpath[j]) {
              found = true;
              old_calib = old_val_arr[j];
            }
            j = j + 1;
          }
          tmp = fun + "/unit";
          j = 0;
          found = false;
          while (j < new_jpath.length && !found) {
            if (tmp == new_jpath[j]) {
              found = true;
              unit_name = new_val_arr[j];
            }
            j = j + 1;
          }
          tmp = fun + "/sensorType";
          j = 0;
          found = false;
          while (j < new_jpath.length && !found) {
            if (tmp == new_jpath[j]) {
              found = true;
              sensorType = new_val_arr[j];
            }
            j = j + 1;
          }
          newval = await this.calibConvert(old_calib, new_val_arr[i], unit_name, sensorType);
          url = "api/" + fun + ".json?" + attr + "=" + this.imm_escapeAttr(newval);
          subres = await this._tryExec(url);
          if (res == YAPI_SUCCESS && subres != YAPI_SUCCESS) {
            res = subres;
          }
        } else {
          url = "api/" + fun + ".json?" + attr + "=" + this.imm_escapeAttr(oldval);
          if (attr == "resolution") {
            restoreLast.push(url);
          } else {
            subres = await this._tryExec(url);
            if (res == YAPI_SUCCESS && subres != YAPI_SUCCESS) {
              res = subres;
            }
          }
        }
      }
      i = i + 1;
    }
    for (let ii_2 of restoreLast) {
      subres = await this._tryExec(ii_2);
      if (res == YAPI_SUCCESS && subres != YAPI_SUCCESS) {
        res = subres;
      }
    }
    await this.clearCache();
    return res;
  }
  async addFileToHTTPCallback(filename) {
    let content;
    content = await this._download("@YCB+" + filename);
    if (content.length == 0) {
      return YAPI_NOT_SUPPORTED;
    }
    return YAPI_SUCCESS;
  }
  async get_hardwareId() {
    let serial;
    serial = await this.get_serialNumber();
    return serial + ".module";
  }
  async download(pathname) {
    return await this._download(pathname);
  }
  async get_icon2d() {
    return await this._download("icon2d.png");
  }
  async get_lastLogs() {
    let content;
    content = await this._download("logs.txt");
    if (content.length == 0) {
      return YAPI_INVALID_STRING;
    }
    return this._yapi.imm_bin2str(content);
  }
  async log(text) {
    return await this._upload("logs.txt", this._yapi.imm_str2bin(text));
  }
  async get_subDevices() {
    return await this.get_subDevices_internal();
  }
  async get_parentHub() {
    return await this.get_parentHub_internal();
  }
  async get_url() {
    return await this.get_url_internal();
  }
  nextModule() {
    let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
    if (resolve.errorType != YAPI.SUCCESS)
      return null;
    let next_hwid = this._yapi.imm_getNextHardwareId(this._className, resolve.result);
    if (next_hwid == null)
      return null;
    return YModule.FindModuleInContext(this._yapi, next_hwid);
  }
  static FirstModule() {
    let next_hwid = YAPI.imm_getFirstHardwareId("Module");
    if (next_hwid == null)
      return null;
    return YModule.FindModule(next_hwid);
  }
  static FirstModuleInContext(yctx) {
    let next_hwid = yctx.imm_getFirstHardwareId("Module");
    if (next_hwid == null)
      return null;
    return YModule.FindModuleInContext(yctx, next_hwid);
  }
};
YModule.PRODUCTNAME_INVALID = YAPI_INVALID_STRING;
YModule.SERIALNUMBER_INVALID = YAPI_INVALID_STRING;
YModule.PRODUCTID_INVALID = YAPI_INVALID_UINT;
YModule.PRODUCTRELEASE_INVALID = YAPI_INVALID_UINT;
YModule.FIRMWARERELEASE_INVALID = YAPI_INVALID_STRING;
YModule.PERSISTENTSETTINGS_LOADED = 0;
YModule.PERSISTENTSETTINGS_SAVED = 1;
YModule.PERSISTENTSETTINGS_MODIFIED = 2;
YModule.PERSISTENTSETTINGS_INVALID = -1;
YModule.LUMINOSITY_INVALID = YAPI_INVALID_UINT;
YModule.BEACON_OFF = 0;
YModule.BEACON_ON = 1;
YModule.BEACON_INVALID = -1;
YModule.UPTIME_INVALID = YAPI_INVALID_LONG;
YModule.USBCURRENT_INVALID = YAPI_INVALID_UINT;
YModule.REBOOTCOUNTDOWN_INVALID = YAPI_INVALID_INT;
YModule.USERVAR_INVALID = YAPI_INVALID_INT;
var YSensor = class extends YFunction {
  constructor(yapi, func) {
    super(yapi, func);
    this._cal = null;
    this._unit = YSensor.UNIT_INVALID;
    this._currentValue = YSensor.CURRENTVALUE_INVALID;
    this._lowestValue = YSensor.LOWESTVALUE_INVALID;
    this._highestValue = YSensor.HIGHESTVALUE_INVALID;
    this._currentRawValue = YSensor.CURRENTRAWVALUE_INVALID;
    this._logFrequency = YSensor.LOGFREQUENCY_INVALID;
    this._reportFrequency = YSensor.REPORTFREQUENCY_INVALID;
    this._advMode = YSensor.ADVMODE_INVALID;
    this._calibrationParam = YSensor.CALIBRATIONPARAM_INVALID;
    this._resolution = YSensor.RESOLUTION_INVALID;
    this._sensorState = YSensor.SENSORSTATE_INVALID;
    this._valueCallbackSensor = null;
    this._timedReportCallbackSensor = null;
    this._prevTR = 0;
    this._iresol = 0;
    this.UNIT_INVALID = YAPI_INVALID_STRING;
    this.CURRENTVALUE_INVALID = YAPI_INVALID_DOUBLE;
    this.LOWESTVALUE_INVALID = YAPI_INVALID_DOUBLE;
    this.HIGHESTVALUE_INVALID = YAPI_INVALID_DOUBLE;
    this.CURRENTRAWVALUE_INVALID = YAPI_INVALID_DOUBLE;
    this.LOGFREQUENCY_INVALID = YAPI_INVALID_STRING;
    this.REPORTFREQUENCY_INVALID = YAPI_INVALID_STRING;
    this.ADVMODE_IMMEDIATE = 0;
    this.ADVMODE_PERIOD_AVG = 1;
    this.ADVMODE_PERIOD_MIN = 2;
    this.ADVMODE_PERIOD_MAX = 3;
    this.ADVMODE_INVALID = -1;
    this.CALIBRATIONPARAM_INVALID = YAPI_INVALID_STRING;
    this.RESOLUTION_INVALID = YAPI_INVALID_DOUBLE;
    this.SENSORSTATE_INVALID = YAPI_INVALID_INT;
    this._className = "Sensor";
  }
  imm_parseAttr(name, val) {
    switch (name) {
      case "unit":
        this._unit = val;
        return 1;
      case "currentValue":
        this._currentValue = Math.round(val / 65.536) / 1e3;
        return 1;
      case "lowestValue":
        this._lowestValue = Math.round(val / 65.536) / 1e3;
        return 1;
      case "highestValue":
        this._highestValue = Math.round(val / 65.536) / 1e3;
        return 1;
      case "currentRawValue":
        this._currentRawValue = Math.round(val / 65.536) / 1e3;
        return 1;
      case "logFrequency":
        this._logFrequency = val;
        return 1;
      case "reportFrequency":
        this._reportFrequency = val;
        return 1;
      case "advMode":
        this._advMode = val;
        return 1;
      case "calibrationParam":
        this._calibrationParam = val;
        return 1;
      case "resolution":
        this._resolution = Math.round(val / 65.536) / 1e3;
        return 1;
      case "sensorState":
        this._sensorState = val;
        return 1;
    }
    return super.imm_parseAttr(name, val);
  }
  async get_unit() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YSensor.UNIT_INVALID;
      }
    }
    res = this._unit;
    return res;
  }
  async get_currentValue() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YSensor.CURRENTVALUE_INVALID;
      }
    }
    if (this._cal == null) {
      res = this._currentValue;
    } else {
      res = await this._applyCalibration(this._currentRawValue);
    }
    if (res == YSensor.CURRENTVALUE_INVALID) {
      return res;
    }
    res = Math.round(res * this._iresol) / this._iresol;
    return res;
  }
  async set_lowestValue(newval) {
    let rest_val;
    rest_val = String(Math.round(newval * 65536));
    return await this._setAttr("lowestValue", rest_val);
  }
  async get_lowestValue() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YSensor.LOWESTVALUE_INVALID;
      }
    }
    res = Math.round(this._lowestValue * this._iresol) / this._iresol;
    return res;
  }
  async set_highestValue(newval) {
    let rest_val;
    rest_val = String(Math.round(newval * 65536));
    return await this._setAttr("highestValue", rest_val);
  }
  async get_highestValue() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YSensor.HIGHESTVALUE_INVALID;
      }
    }
    res = Math.round(this._highestValue * this._iresol) / this._iresol;
    return res;
  }
  async get_currentRawValue() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YSensor.CURRENTRAWVALUE_INVALID;
      }
    }
    res = this._currentRawValue;
    return res;
  }
  async get_logFrequency() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YSensor.LOGFREQUENCY_INVALID;
      }
    }
    res = this._logFrequency;
    return res;
  }
  async set_logFrequency(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("logFrequency", rest_val);
  }
  async get_reportFrequency() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YSensor.REPORTFREQUENCY_INVALID;
      }
    }
    res = this._reportFrequency;
    return res;
  }
  async set_reportFrequency(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("reportFrequency", rest_val);
  }
  async get_advMode() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YSensor.ADVMODE_INVALID;
      }
    }
    res = this._advMode;
    return res;
  }
  async set_advMode(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("advMode", rest_val);
  }
  async get_calibrationParam() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YSensor.CALIBRATIONPARAM_INVALID;
      }
    }
    res = this._calibrationParam;
    return res;
  }
  async set_calibrationParam(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("calibrationParam", rest_val);
  }
  async set_resolution(newval) {
    let rest_val;
    rest_val = String(Math.round(newval * 65536));
    return await this._setAttr("resolution", rest_val);
  }
  async get_resolution() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YSensor.RESOLUTION_INVALID;
      }
    }
    res = this._resolution;
    return res;
  }
  async get_sensorState() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YSensor.SENSORSTATE_INVALID;
      }
    }
    res = this._sensorState;
    return res;
  }
  static FindSensor(func) {
    let obj;
    obj = YFunction._FindFromCache("Sensor", func);
    if (obj == null) {
      obj = new YSensor(YAPI, func);
      YFunction._AddToCache("Sensor", func, obj);
    }
    return obj;
  }
  static FindSensorInContext(yctx, func) {
    let obj;
    obj = YFunction._FindFromCacheInContext(yctx, "Sensor", func);
    if (obj == null) {
      obj = new YSensor(yctx, func);
      YFunction._AddToCache("Sensor", func, obj);
    }
    return obj;
  }
  async registerValueCallback(callback) {
    let val;
    if (callback != null) {
      await YFunction._UpdateValueCallbackList(this, true);
    } else {
      await YFunction._UpdateValueCallbackList(this, false);
    }
    this._valueCallbackSensor = callback;
    if (callback != null && await this.isOnline()) {
      val = this._advertisedValue;
      if (!(val == "")) {
        await this._invokeValueCallback(val);
      }
    }
    return 0;
  }
  async _invokeValueCallback(value) {
    if (this._valueCallbackSensor != null) {
      try {
        await this._valueCallbackSensor(this, value);
      } catch (e) {
        this._yapi.imm_log("Exception in valueCallback:", e);
      }
    } else {
      await super._invokeValueCallback(value);
    }
    return 0;
  }
  _parserHelper() {
    let calibStr;
    if (this._resolution > 0) {
      this._iresol = Math.round(1 / this._resolution);
    } else {
      this._iresol = 1e4;
    }
    calibStr = this._calibrationParam;
    if (calibStr == "0," || calibStr == "" || calibStr == "0") {
      this._cal = null;
      return 0;
    }
    if (this._cal == null || !(this._cal.src == calibStr)) {
      this._parseCalibStr(calibStr);
    }
    return 0;
  }
  async isSensorReady() {
    try {
      if (await this.get_sensorState() != 0) {
        return false;
      }
    } catch (e) {
      return false;
    }
    return true;
  }
  async get_dataLogger() {
    let logger;
    let modu;
    let serial;
    let hwid;
    modu = await this.get_module();
    serial = await modu.get_serialNumber();
    if (serial == YAPI_INVALID_STRING) {
      return null;
    }
    hwid = serial + ".dataLogger";
    logger = YDataLogger.FindDataLogger(hwid);
    return logger;
  }
  _parseCalibStr(calibStr) {
    let iCalib = [];
    let caltyp;
    let calhdl;
    let maxpos;
    let position;
    let calpar = [];
    let calraw = [];
    let calref = [];
    let fRaw;
    let fRef;
    let iRaw;
    let iRef;
    if (calibStr.indexOf(",") >= 0) {
      iCalib = this._yapi.imm_decodeFloats(calibStr);
      caltyp = iCalib[0] / 1e3 >> 0;
      if (caltyp < YOCTO_CALIB_TYPE_OFS) {
        this._cal = null;
        return YAPI_SUCCESS;
      }
      calhdl = this._yapi.imm_getCalibrationHandler(caltyp);
      if (!(calhdl != null)) {
        this._cal = null;
        return YAPI_SUCCESS;
      }
      maxpos = iCalib.length;
      calpar.length = 0;
      position = 1;
      while (position < maxpos) {
        calpar.push(iCalib[position]);
        position = position + 1;
      }
      calraw.length = 0;
      calref.length = 0;
      position = 1;
      while (position + 1 < maxpos) {
        fRaw = iCalib[position];
        fRaw = fRaw / 1e3;
        fRef = iCalib[position + 1];
        fRef = fRef / 1e3;
        calraw.push(fRaw);
        calref.push(fRef);
        position = position + 2;
      }
    } else {
      iCalib = this._yapi.imm_decodeWords(calibStr);
      if (iCalib.length <= 2) {
        this._cal = null;
        return YAPI_SUCCESS;
      }
      caltyp = iCalib[2];
      calhdl = this._yapi.imm_getCalibrationHandler(caltyp);
      if (!(calhdl != null)) {
        this._cal = null;
        return YAPI_SUCCESS;
      }
      if (caltyp <= 10) {
        maxpos = caltyp;
      } else {
        if (caltyp <= 20) {
          maxpos = caltyp - 10;
        } else {
          maxpos = 5;
        }
      }
      maxpos = 3 + 2 * maxpos;
      if (maxpos > iCalib.length) {
        maxpos = iCalib.length;
      }
      calpar.length = 0;
      calraw.length = 0;
      calref.length = 0;
      position = 3;
      while (position + 1 < maxpos) {
        iRaw = iCalib[position];
        iRef = iCalib[position + 1];
        calpar.push(iRaw);
        calpar.push(iRef);
        calraw.push(this._yapi.imm_decimalToDouble(iRaw));
        calref.push(this._yapi.imm_decimalToDouble(iRef));
        position = position + 2;
      }
    }
    this._cal = {src: calibStr, hdl: calhdl, typ: caltyp, par: calpar, raw: calraw, cal: calref};
    return YAPI_SUCCESS;
  }
  async startDataLogger() {
    let res;
    res = await this._download("api/dataLogger/recording?recording=1");
    if (!(res.length > 0)) {
      return this._throw(YAPI_IO_ERROR, "unable to start datalogger", YAPI_IO_ERROR);
    }
    return YAPI_SUCCESS;
  }
  async stopDataLogger() {
    let res;
    res = await this._download("api/dataLogger/recording?recording=0");
    if (!(res.length > 0)) {
      return this._throw(YAPI_IO_ERROR, "unable to stop datalogger", YAPI_IO_ERROR);
    }
    return YAPI_SUCCESS;
  }
  async get_recordedData(startTime, endTime) {
    let funcid;
    let funit;
    funcid = await this.get_functionId();
    funit = await this.get_unit();
    return new YDataSet(this, funcid, funit, startTime, endTime);
  }
  async registerTimedReportCallback(callback) {
    let sensor;
    sensor = this;
    if (callback != null) {
      await YFunction._UpdateTimedReportCallbackList(sensor, true);
    } else {
      await YFunction._UpdateTimedReportCallbackList(sensor, false);
    }
    this._timedReportCallbackSensor = callback;
    return 0;
  }
  async _invokeTimedReportCallback(value) {
    if (this._timedReportCallbackSensor != null) {
      try {
        await this._timedReportCallbackSensor(this, value);
      } catch (e) {
        this._yapi.imm_log("Exception in timedReportCallback:", e);
      }
    } else {
    }
    return 0;
  }
  async calibrateFromPoints(rawValues, refValues) {
    let rest_val;
    let res;
    rest_val = await this._encodeCalibrationPoints(rawValues, refValues);
    res = await this._setAttr("calibrationParam", rest_val);
    return res;
  }
  async loadCalibrationPoints(rawValues, refValues) {
    rawValues.length = 0;
    refValues.length = 0;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YAPI_DEVICE_NOT_FOUND;
      }
    }
    if (this._cal == null) {
      return YAPI_SUCCESS;
    }
    rawValues.length = 0;
    refValues.length = 0;
    for (let ii_0 of this._cal.raw) {
      rawValues.push(ii_0);
    }
    for (let ii_1 of this._cal.cal) {
      refValues.push(ii_1);
    }
    return YAPI_SUCCESS;
  }
  async _encodeCalibrationPoints(rawValues, refValues) {
    let res;
    let npt;
    let idx;
    npt = rawValues.length;
    if (npt != refValues.length) {
      this._throw(YAPI_INVALID_ARGUMENT, "Invalid calibration parameters (size mismatch)");
      return YAPI_INVALID_STRING;
    }
    if (npt == 0) {
      return "0";
    }
    res = String(Math.round(YOCTO_CALIB_TYPE_OFS));
    idx = 0;
    while (idx < npt) {
      res = res + "," + String(Math.round(rawValues[idx] * 1e3) / 1e3) + "," + String(Math.round(refValues[idx] * 1e3) / 1e3);
      idx = idx + 1;
    }
    return res;
  }
  async _applyCalibration(rawValue) {
    if (this._cal == null) {
      return rawValue;
    }
    if (rawValue == YSensor.CURRENTVALUE_INVALID) {
      return YSensor.CURRENTVALUE_INVALID;
    }
    return this._cal.hdl(rawValue, this._cal.typ, this._cal.par, this._cal.raw, this._cal.cal);
  }
  async _decodeTimedReport(timestamp, duration, report) {
    let i;
    let byteVal;
    let poww;
    let minRaw;
    let avgRaw;
    let maxRaw;
    let sublen;
    let difRaw;
    let startTime;
    let endTime;
    let minVal;
    let avgVal;
    let maxVal;
    if (duration > 0) {
      startTime = timestamp - duration;
    } else {
      startTime = this._prevTR;
    }
    endTime = timestamp;
    this._prevTR = endTime;
    if (startTime == 0) {
      startTime = endTime;
    }
    if (report.length <= 5) {
      poww = 1;
      avgRaw = 0;
      byteVal = 0;
      i = 1;
      while (i < report.length) {
        byteVal = report[i];
        avgRaw = avgRaw + poww * byteVal;
        poww = poww * 256;
        i = i + 1;
      }
      if ((byteVal & 128) != 0) {
        avgRaw = avgRaw - poww;
      }
      avgVal = avgRaw / 1e3;
      if (!(this._cal == null)) {
        avgVal = this._cal.hdl(avgVal, this._cal.typ, this._cal.par, this._cal.raw, this._cal.cal);
      }
      minVal = avgVal;
      maxVal = avgVal;
    } else {
      sublen = 1 + (report[1] & 3);
      poww = 1;
      avgRaw = 0;
      byteVal = 0;
      i = 2;
      while (sublen > 0 && i < report.length) {
        byteVal = report[i];
        avgRaw = avgRaw + poww * byteVal;
        poww = poww * 256;
        i = i + 1;
        sublen = sublen - 1;
      }
      if ((byteVal & 128) != 0) {
        avgRaw = avgRaw - poww;
      }
      sublen = 1 + (report[1] >> 2 & 3);
      poww = 1;
      difRaw = 0;
      while (sublen > 0 && i < report.length) {
        byteVal = report[i];
        difRaw = difRaw + poww * byteVal;
        poww = poww * 256;
        i = i + 1;
        sublen = sublen - 1;
      }
      minRaw = avgRaw - difRaw;
      sublen = 1 + (report[1] >> 4 & 3);
      poww = 1;
      difRaw = 0;
      while (sublen > 0 && i < report.length) {
        byteVal = report[i];
        difRaw = difRaw + poww * byteVal;
        poww = poww * 256;
        i = i + 1;
        sublen = sublen - 1;
      }
      maxRaw = avgRaw + difRaw;
      avgVal = avgRaw / 1e3;
      minVal = minRaw / 1e3;
      maxVal = maxRaw / 1e3;
      if (!(this._cal == null)) {
        avgVal = this._cal.hdl(avgVal, this._cal.typ, this._cal.par, this._cal.raw, this._cal.cal);
        minVal = this._cal.hdl(minVal, this._cal.typ, this._cal.par, this._cal.raw, this._cal.cal);
        maxVal = this._cal.hdl(maxVal, this._cal.typ, this._cal.par, this._cal.raw, this._cal.cal);
      }
    }
    return new YMeasure(startTime, endTime, minVal, avgVal, maxVal);
  }
  imm_decodeVal(w) {
    let val;
    val = w;
    if (!(this._cal == null)) {
      val = this._cal.hdl(val, this._cal.typ, this._cal.par, this._cal.raw, this._cal.cal);
    }
    return val;
  }
  imm_decodeAvg(dw) {
    let val;
    val = dw;
    if (!(this._cal == null)) {
      val = this._cal.hdl(val, this._cal.typ, this._cal.par, this._cal.raw, this._cal.cal);
    }
    return val;
  }
  nextSensor() {
    let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
    if (resolve.errorType != YAPI.SUCCESS)
      return null;
    let next_hwid = this._yapi.imm_getNextHardwareId(this._className, resolve.result);
    if (next_hwid == null)
      return null;
    return YSensor.FindSensorInContext(this._yapi, next_hwid);
  }
  static FirstSensor() {
    let next_hwid = YAPI.imm_getFirstHardwareId("Sensor");
    if (next_hwid == null)
      return null;
    return YSensor.FindSensor(next_hwid);
  }
  static FirstSensorInContext(yctx) {
    let next_hwid = yctx.imm_getFirstHardwareId("Sensor");
    if (next_hwid == null)
      return null;
    return YSensor.FindSensorInContext(yctx, next_hwid);
  }
};
YSensor.UNIT_INVALID = YAPI_INVALID_STRING;
YSensor.CURRENTVALUE_INVALID = YAPI_INVALID_DOUBLE;
YSensor.LOWESTVALUE_INVALID = YAPI_INVALID_DOUBLE;
YSensor.HIGHESTVALUE_INVALID = YAPI_INVALID_DOUBLE;
YSensor.CURRENTRAWVALUE_INVALID = YAPI_INVALID_DOUBLE;
YSensor.LOGFREQUENCY_INVALID = YAPI_INVALID_STRING;
YSensor.REPORTFREQUENCY_INVALID = YAPI_INVALID_STRING;
YSensor.ADVMODE_IMMEDIATE = 0;
YSensor.ADVMODE_PERIOD_AVG = 1;
YSensor.ADVMODE_PERIOD_MIN = 2;
YSensor.ADVMODE_PERIOD_MAX = 3;
YSensor.ADVMODE_INVALID = -1;
YSensor.CALIBRATIONPARAM_INVALID = YAPI_INVALID_STRING;
YSensor.RESOLUTION_INVALID = YAPI_INVALID_DOUBLE;
YSensor.SENSORSTATE_INVALID = YAPI_INVALID_INT;
var YMeasure = class {
  constructor(float_start, float_end, float_minVal, float_avgVal, float_maxVal) {
    this._start = 0;
    this._end = 0;
    this._minVal = 0;
    this._avgVal = 0;
    this._maxVal = 0;
    this._start = float_start;
    this._end = float_end;
    this._minVal = float_minVal;
    this._avgVal = float_avgVal;
    this._maxVal = float_maxVal;
  }
  get_startTimeUTC() {
    return this._start;
  }
  get_endTimeUTC() {
    return this._end;
  }
  get_minValue() {
    return this._minVal;
  }
  get_averageValue() {
    return this._avgVal;
  }
  get_maxValue() {
    return this._maxVal;
  }
  get_startTimeUTC_asDate() {
    return new Date(Math.round(this._start * 1e3));
  }
  get_endTimeUTC_asDate() {
    return new Date(Math.round(this._end * 1e3));
  }
};
var YDataLogger = class extends YFunction {
  constructor(yapi, func) {
    super(yapi, func);
    this._currentRunIndex = YDataLogger.CURRENTRUNINDEX_INVALID;
    this._timeUTC = YDataLogger.TIMEUTC_INVALID;
    this._recording = YDataLogger.RECORDING_INVALID;
    this._autoStart = YDataLogger.AUTOSTART_INVALID;
    this._beaconDriven = YDataLogger.BEACONDRIVEN_INVALID;
    this._usage = YDataLogger.USAGE_INVALID;
    this._clearHistory = YDataLogger.CLEARHISTORY_INVALID;
    this._valueCallbackDataLogger = null;
    this.CURRENTRUNINDEX_INVALID = YAPI_INVALID_UINT;
    this.TIMEUTC_INVALID = YAPI_INVALID_LONG;
    this.RECORDING_OFF = 0;
    this.RECORDING_ON = 1;
    this.RECORDING_PENDING = 2;
    this.RECORDING_INVALID = -1;
    this.AUTOSTART_OFF = 0;
    this.AUTOSTART_ON = 1;
    this.AUTOSTART_INVALID = -1;
    this.BEACONDRIVEN_OFF = 0;
    this.BEACONDRIVEN_ON = 1;
    this.BEACONDRIVEN_INVALID = -1;
    this.USAGE_INVALID = YAPI_INVALID_UINT;
    this.CLEARHISTORY_FALSE = 0;
    this.CLEARHISTORY_TRUE = 1;
    this.CLEARHISTORY_INVALID = -1;
    this._className = "DataLogger";
  }
  imm_parseAttr(name, val) {
    switch (name) {
      case "currentRunIndex":
        this._currentRunIndex = val;
        return 1;
      case "timeUTC":
        this._timeUTC = val;
        return 1;
      case "recording":
        this._recording = val;
        return 1;
      case "autoStart":
        this._autoStart = val;
        return 1;
      case "beaconDriven":
        this._beaconDriven = val;
        return 1;
      case "usage":
        this._usage = val;
        return 1;
      case "clearHistory":
        this._clearHistory = val;
        return 1;
    }
    return super.imm_parseAttr(name, val);
  }
  async get_currentRunIndex() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YDataLogger.CURRENTRUNINDEX_INVALID;
      }
    }
    res = this._currentRunIndex;
    return res;
  }
  async get_timeUTC() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YDataLogger.TIMEUTC_INVALID;
      }
    }
    res = this._timeUTC;
    return res;
  }
  async set_timeUTC(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("timeUTC", rest_val);
  }
  async get_recording() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YDataLogger.RECORDING_INVALID;
      }
    }
    res = this._recording;
    return res;
  }
  async set_recording(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("recording", rest_val);
  }
  async get_autoStart() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YDataLogger.AUTOSTART_INVALID;
      }
    }
    res = this._autoStart;
    return res;
  }
  async set_autoStart(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("autoStart", rest_val);
  }
  async get_beaconDriven() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YDataLogger.BEACONDRIVEN_INVALID;
      }
    }
    res = this._beaconDriven;
    return res;
  }
  async set_beaconDriven(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("beaconDriven", rest_val);
  }
  async get_usage() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YDataLogger.USAGE_INVALID;
      }
    }
    res = this._usage;
    return res;
  }
  async get_clearHistory() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YDataLogger.CLEARHISTORY_INVALID;
      }
    }
    res = this._clearHistory;
    return res;
  }
  async set_clearHistory(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("clearHistory", rest_val);
  }
  static FindDataLogger(func) {
    let obj;
    obj = YFunction._FindFromCache("DataLogger", func);
    if (obj == null) {
      obj = new YDataLogger(YAPI, func);
      YFunction._AddToCache("DataLogger", func, obj);
    }
    return obj;
  }
  static FindDataLoggerInContext(yctx, func) {
    let obj;
    obj = YFunction._FindFromCacheInContext(yctx, "DataLogger", func);
    if (obj == null) {
      obj = new YDataLogger(yctx, func);
      YFunction._AddToCache("DataLogger", func, obj);
    }
    return obj;
  }
  async registerValueCallback(callback) {
    let val;
    if (callback != null) {
      await YFunction._UpdateValueCallbackList(this, true);
    } else {
      await YFunction._UpdateValueCallbackList(this, false);
    }
    this._valueCallbackDataLogger = callback;
    if (callback != null && await this.isOnline()) {
      val = this._advertisedValue;
      if (!(val == "")) {
        await this._invokeValueCallback(val);
      }
    }
    return 0;
  }
  async _invokeValueCallback(value) {
    if (this._valueCallbackDataLogger != null) {
      try {
        await this._valueCallbackDataLogger(this, value);
      } catch (e) {
        this._yapi.imm_log("Exception in valueCallback:", e);
      }
    } else {
      await super._invokeValueCallback(value);
    }
    return 0;
  }
  async forgetAllDataStreams() {
    return await this.set_clearHistory(1);
  }
  async get_dataSets() {
    return await this.parse_dataSets(await this._download("logger.json"));
  }
  async parse_dataSets(jsonbuff) {
    let dslist = [];
    let dataset;
    let res = [];
    dslist = this.imm_json_get_array(jsonbuff);
    res.length = 0;
    for (let ii_0 of dslist) {
      dataset = new YDataSet(this);
      await dataset._parse(this._yapi.imm_bin2str(ii_0));
      res.push(dataset);
    }
    return res;
  }
  nextDataLogger() {
    let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
    if (resolve.errorType != YAPI.SUCCESS)
      return null;
    let next_hwid = this._yapi.imm_getNextHardwareId(this._className, resolve.result);
    if (next_hwid == null)
      return null;
    return YDataLogger.FindDataLoggerInContext(this._yapi, next_hwid);
  }
  static FirstDataLogger() {
    let next_hwid = YAPI.imm_getFirstHardwareId("DataLogger");
    if (next_hwid == null)
      return null;
    return YDataLogger.FindDataLogger(next_hwid);
  }
  static FirstDataLoggerInContext(yctx) {
    let next_hwid = yctx.imm_getFirstHardwareId("DataLogger");
    if (next_hwid == null)
      return null;
    return YDataLogger.FindDataLoggerInContext(yctx, next_hwid);
  }
};
YDataLogger.CURRENTRUNINDEX_INVALID = YAPI_INVALID_UINT;
YDataLogger.TIMEUTC_INVALID = YAPI_INVALID_LONG;
YDataLogger.RECORDING_OFF = 0;
YDataLogger.RECORDING_ON = 1;
YDataLogger.RECORDING_PENDING = 2;
YDataLogger.RECORDING_INVALID = -1;
YDataLogger.AUTOSTART_OFF = 0;
YDataLogger.AUTOSTART_ON = 1;
YDataLogger.AUTOSTART_INVALID = -1;
YDataLogger.BEACONDRIVEN_OFF = 0;
YDataLogger.BEACONDRIVEN_ON = 1;
YDataLogger.BEACONDRIVEN_INVALID = -1;
YDataLogger.USAGE_INVALID = YAPI_INVALID_UINT;
YDataLogger.CLEARHISTORY_FALSE = 0;
YDataLogger.CLEARHISTORY_TRUE = 1;
YDataLogger.CLEARHISTORY_INVALID = -1;
var YSystemEnv = class {
  constructor() {
    this.isNodeJS = false;
    this.hasSSDP = false;
  }
  unknownSystemEnvError() {
    return new YoctoError("Unspecified runtime environment, your project should include at least once either yocto_api_nodejs or yocto_api_html");
  }
  hookUnhandledRejection(handler) {
    throw this.unknownSystemEnvError();
  }
  getWebSocketEngine(hub, runtime_urlInfo) {
    throw this.unknownSystemEnvError();
  }
  getHttpEngine(hub, runtime_urlInfo, infojson) {
    throw this.unknownSystemEnvError();
  }
  getWebSocketCallbackEngine(hub, runtime_urlInfo, ws) {
    throw this.unknownSystemEnvError();
  }
  getHttpCallbackEngine(hub, runtime_urlInfo, incomingMessage, serverResponse) {
    throw this.unknownSystemEnvError();
  }
  getSSDPManager(obj_yapi) {
    throw this.unknownSystemEnvError();
  }
  async loadfile(file) {
    throw this.unknownSystemEnvError();
  }
  async downloadfile(url, yapi) {
    throw this.unknownSystemEnvError();
  }
  async downloadRemoteCertificate(urlinfo) {
    throw this.unknownSystemEnvError();
  }
};
var _UnspecifiedSystemEnv = new YSystemEnv();
var YHubEngine = class {
  constructor(hub, runtime_urlInfo) {
    this.lastPingStamp = 0;
    this._hub = hub;
    this._runtime_urlInfo = runtime_urlInfo;
  }
  async reconnectEngine(tryOpenID) {
  }
  imm_disconnectEngineNow(connID = "") {
  }
  async request(method, devUrl, obj_body, tcpchan) {
    let res = new YHTTPRequest(null);
    res.errorType = YAPI_NOT_SUPPORTED;
    res.errorMsg = "GenericHub subclass expected";
    return res;
  }
  async reportFailure(message) {
  }
  imm_updateLastPinfStamp() {
    this.lastPingStamp = Date.now();
  }
  imm_isConnected() {
    return Date.now() - this.lastPingStamp < this._hub.imm_getNetworkTimeout();
  }
  imm_isForwarded() {
    return false;
  }
  async waitForPendingQueries(ms_duration) {
  }
};
var HubMode;
(function(HubMode2) {
  HubMode2[HubMode2["LEGACY"] = 0] = "LEGACY";
  HubMode2[HubMode2["MIXED"] = 1] = "MIXED";
  HubMode2[HubMode2["SECURE"] = 2] = "SECURE";
  HubMode2[HubMode2["PROTO_UNKNOWN"] = 3] = "PROTO_UNKNOWN";
})(HubMode || (HubMode = {}));
var YGenericHub = class {
  constructor(yapi, urlInfo) {
    this._lastErrorType = YAPI_IO_ERROR;
    this._lastErrorMsg = "Hub attachment has not been triggered";
    this.hubSerial = "";
    this.serialByYdx = [];
    this._currentState = -6;
    this._targetState = -5;
    this.currentConnID = "";
    this.connResolvers = [];
    this.disconnResolvers = [];
    this.retryDelay = 15;
    this._reconnectionTimer = null;
    this._rwAccess = null;
    this.keepTryingExpiration = 0;
    this.keepTryingTimeoutId = null;
    this.timeoutId = null;
    this.isNotifWorking = false;
    this.devListExpires = 0;
    this.notifPos = -1;
    this.notifCarryOver = "";
    this._firstArrivalCallback = true;
    this._missing = {};
    this._knownUrls = [];
    this._portInfo = [];
    this._usePureHTTP = false;
    this._yapi = yapi;
    this.urlInfo = urlInfo;
    this.stalledTimeoutMs = yapi._networkTimeoutMs;
    this._hubRef = YGenericHub.globalHubRefCounter++;
    this._hubEngine = null;
    this._hubMode = HubMode.SECURE;
  }
  _throw(int_errType, str_errMsg, obj_retVal) {
    this._lastErrorType = int_errType;
    this._lastErrorMsg = str_errMsg;
    return this._yapi._throw(int_errType, str_errMsg, obj_retVal);
  }
  imm_isFirstArrivalCallback() {
    return this._firstArrivalCallback;
  }
  imm_setFirstArrivalCallback(isfirst) {
    this._firstArrivalCallback = isfirst;
  }
  imm_getNotifyPos() {
    return this.notifPos;
  }
  imm_getcurrentState() {
    return this._currentState;
  }
  imm_getCurrentConnID() {
    return this.currentConnID;
  }
  imm_setCurrentConnID(id) {
    this.currentConnID = id;
  }
  get_errorType() {
    return this._lastErrorType;
  }
  get_errorMessage() {
    if (this._lastErrorType == YAPI_SUCCESS) {
      return "";
    }
    return this._lastErrorMsg;
  }
  imm_forceUpdate() {
    this.devListExpires = this._yapi.GetTickCount();
  }
  imm_logrequest(method, devUrl, obj_body) {
    let msg = "Request: " + method + " " + devUrl;
    if (obj_body) {
      msg += " (file=" + obj_body.fname + ")";
    }
    this._yapi.imm_log(msg);
  }
  imm_setState(newState) {
    this._currentState = newState;
  }
  imm_setTargetState(newState) {
    this._targetState = newState;
  }
  imm_isDisconnecting() {
    return this._targetState <= -5;
  }
  imm_isDisconnected() {
    return this._targetState <= -5 && this._currentState <= -5;
  }
  imm_isPreOrRegistered() {
    return this._targetState >= 1;
  }
  imm_isOnline() {
    if (this._hubEngine) {
      return this._hubEngine.imm_isConnected();
    }
    return false;
  }
  imm_getConnectionState() {
    if (this.imm_isOnline()) {
      return YHub.CONNECTED;
    }
    if (this._targetState <= -5) {
      return YHub.ABORTED;
    }
    return YHub.TRYING;
  }
  imm_isForwarded() {
    if (this._hubEngine) {
      return this._hubEngine.imm_isForwarded();
    }
    return false;
  }
  imm_addKnownUrl(urlInfo) {
    if (!this._knownUrls.includes(urlInfo.imm_getOriginalURL())) {
      this._knownUrls.push(urlInfo.imm_getOriginalURL());
    }
  }
  imm_updateUrl(urlInfo) {
    if (!this._knownUrls.includes(urlInfo.imm_getOriginalURL())) {
      this._knownUrls.push(urlInfo.imm_getOriginalURL());
    }
    if (this.urlInfo.imm_getUrl(false, true, true) == urlInfo.imm_getUrl(false, true, true)) {
      this.urlInfo.imm_updateFrom(urlInfo);
      return;
    }
    this.urlInfo.imm_updateFrom(urlInfo);
    if (this._currentState < -1) {
      if (this._yapi._logLevel >= 4) {
        this._yapi.imm_log("Updating auth credentials for " + this.urlInfo.imm_getRootUrl());
      }
    }
  }
  imm_updateForRedirect(url) {
    let ofs = url.indexOf("://");
    if (ofs > 0) {
      ofs = url.indexOf("/", ofs + 3);
      if (ofs > 0) {
        url = url.substring(0, ofs);
      }
    }
    let new_url = new _YY_UrlInfo(url);
    this.urlInfo.imm_updateForRedirect(new_url.imm_getHost(), new_url.imm_getPort(), new_url.imm_useSecureSocket());
    if (this._yapi._logLevel >= 4) {
      this._yapi.imm_log("Updating URL after HTTP redirection : " + this.urlInfo.imm_getRootUrl());
    }
    let primaryHub = this._yapi._knownHubsByUrl[new_url.imm_getRootUrl()];
    if (primaryHub && primaryHub !== this) {
      if (primaryHub.urlInfo.imm_useSecureSocket()) {
        if (primaryHub._currentState >= this._currentState) {
          primaryHub.imm_inheritFrom(this);
          this._yapi.imm_updateRegisteredHubs(this, false);
          return;
        }
      }
      this._yapi._knownHubsByUrl[this.urlInfo.imm_getRootUrl()] = this;
      this.imm_inheritFrom(primaryHub);
      this._yapi.imm_updateRegisteredHubs(primaryHub, false);
    } else {
      this._yapi._knownHubsByUrl[new_url.imm_getRootUrl()] = this;
    }
  }
  imm_inheritFrom(otherHub) {
    if (this._targetState < otherHub._targetState) {
      this.imm_setTargetState(otherHub._targetState);
    }
    for (let j = 0; j < otherHub.serialByYdx.length; j++) {
      let serial = otherHub.serialByYdx[j];
      if (serial && !this.serialByYdx[j]) {
        this.serialByYdx[j] = serial;
      }
    }
    if (this._currentState >= 0 && otherHub._currentState < 0) {
      let res_struct = {errorType: YAPI_SUCCESS, errorMsg: "Hub " + this.hubSerial + " already connected"};
      let resolvers = otherHub.connResolvers;
      for (let resolveOne of resolvers) {
        resolveOne(res_struct);
      }
    } else {
      for (let resolver of otherHub.connResolvers) {
        this.connResolvers.push(resolver);
      }
    }
    otherHub.connResolvers = [];
    if (this._yapi._logLevel >= 3) {
      this._yapi.imm_log("Hub " + this.hubSerial + " is connected as " + this.urlInfo.imm_getRootUrl() + ", dropping connection to " + otherHub.urlInfo.imm_getRootUrl());
    }
    otherHub.imm_commonDisconnect("inherit", YAPI_SUCCESS, "Hub " + this.hubSerial + " is already connected via " + this.urlInfo.imm_getRootUrl());
    otherHub.imm_disconnectNow();
    for (const url of otherHub.get_knownUrls()) {
      if (!this._knownUrls.includes(url)) {
        this._knownUrls.push(url);
      }
    }
  }
  imm_getNewConnID() {
    let time = new Date();
    return (time.getHours() + "h" + time.getMinutes() + "m" + time.getTime() % 6e4 / 1e3).toString() + "_0";
  }
  imm_tryTestConnectFor(mstimeout) {
    let minimalExpiration = Date.now() + mstimeout;
    if (this.keepTryingExpiration < minimalExpiration) {
      this.keepTryingExpiration = minimalExpiration;
      if (this.keepTryingTimeoutId) {
        clearTimeout(this.keepTryingTimeoutId);
      }
      this.keepTryingTimeoutId = setTimeout(() => {
        this.keepTryingTimeoutId = null;
        if (this._targetState == 0) {
          if (this._yapi._logLevel >= 4) {
            this._yapi.imm_log("TestHub timeout reached, disconnecting");
          }
          this.detach(YAPI.IO_ERROR, "TestHub timeout reached");
        }
      }, mstimeout);
    }
  }
  async attach(targetConnType) {
    if (this._targetState <= 0 || targetConnType > 0) {
      this._lastErrorType = 0;
      this._lastErrorMsg = "Reconnecting";
      this.imm_setTargetState(targetConnType);
      if (this._currentState == 0 && targetConnType > 0) {
        try {
          await this._yapi._ensureUpdateDeviceListNotRunning();
          await this._yapi._addConnectedHub(this);
          this.imm_setState(targetConnType);
        } catch (e) {
          this.imm_disconnectNow();
        }
      }
      if (targetConnType == 0) {
        this.imm_tryTestConnectFor(100);
      }
    }
    if (this._currentState <= -5) {
      if (this._yapi._logLevel >= 4) {
        this._yapi.imm_log("New hub is detached connecting...");
      }
      this._hubEngine = null;
      this.stalledTimeoutMs = this._yapi._networkTimeoutMs;
      this.imm_setState(-1);
      this.reconnect(this.imm_getNewConnID());
    } else if (this._currentState == -3) {
      if (this._reconnectionTimer) {
        if (this._yapi._logLevel >= 4) {
          this._yapi.imm_log("New hub connection requested, retry now (drop [" + this.currentConnID + "])");
        }
        clearTimeout(this._reconnectionTimer);
        this._reconnectionTimer = null;
        this.currentConnID = "";
      } else {
        if (this._yapi._logLevel >= 4) {
          this._yapi.imm_log("New hub connection requested, retry now (no pending reconnection ?!?)");
        }
      }
      this.reconnect(this.imm_getNewConnID());
    } else if (this._currentState == -4 || this._currentState == -2) {
      if (this._yapi._logLevel >= 4) {
        this._yapi.imm_log("Hub is currently disconnecting, reconnection will be triggered soon [" + this.currentConnID + "]");
        this._yapi.imm_log("Current state: " + this._currentState);
        this._yapi.imm_log("Target state: " + this._targetState + " (" + targetConnType + ")");
      }
    }
  }
  async waitForConnection(mstimeout, errmsg) {
    if (this._targetState < 0) {
      errmsg.msg = this._lastErrorMsg;
      return this._lastErrorType;
    }
    if (this._currentState >= 0) {
      return YAPI_SUCCESS;
    }
    if (mstimeout <= 1) {
      errmsg.msg = "Hub not connected";
      return YAPI_TIMEOUT;
    }
    if (this._targetState == 0) {
      this.imm_tryTestConnectFor(mstimeout);
    }
    let connOpenPromise = null;
    let connOpenTimeoutObj = null;
    let addResolverPromise;
    addResolverPromise = new Promise((resolverReady, noResolver) => {
      connOpenPromise = new Promise((resolve, reject) => {
        this.connResolvers.push(resolve);
        resolverReady(resolve);
        connOpenTimeoutObj = setTimeout(() => {
          if (this._yapi._logLevel >= 4) {
            this._yapi.imm_log("Timeout waiting for hub connection");
          }
          resolve({errorType: YAPI_TIMEOUT, errorMsg: "Timeout waiting for hub connection"});
        }, mstimeout);
      });
    });
    let resolver = await addResolverPromise;
    if (this._targetState < 0) {
      clearTimeout(connOpenTimeoutObj);
      errmsg.msg = this._lastErrorMsg;
      return this._lastErrorType;
    }
    if (this._currentState >= 0) {
      clearTimeout(connOpenTimeoutObj);
      return YAPI_SUCCESS;
    }
    let openRes = await connOpenPromise;
    clearTimeout(connOpenTimeoutObj);
    if (openRes.errorType != YAPI_SUCCESS) {
      if (errmsg) {
        errmsg.msg = openRes.errorMsg;
      }
    }
    return openRes.errorType;
  }
  async reconnect(tryOpenID) {
    if (!this._hubEngine) {
      if (this._yapi._logLevel >= 4) {
        this._yapi.imm_log("look for suitable Hub engine [" + tryOpenID + "]");
      }
      this._usePureHTTP = false;
      this._portInfo = [];
      let infoJson = null;
      if (this.urlInfo.imm_testInfoJson()) {
        let https_req = this.urlInfo.imm_useSecureSocket();
        if (this.urlInfo.imm_getPort() == YAPI.YOCTO_DEFAULT_HTTPS_PORT) {
          https_req = true;
        }
        let url = (https_req ? "https://" : "http://") + this.urlInfo.imm_getUrl(false, false, true) + "info.json";
        if (this._yapi._logLevel >= 4) {
          this._yapi.imm_log("look for info.json at " + url + " [" + tryOpenID + "]");
        }
        try {
          let data = await this._yapi.system_env.downloadfile(url, this._yapi);
          infoJson = JSON.parse(YAPI.imm_bin2str(data));
          if (infoJson) {
            if (infoJson.serialNumber) {
              this.imm_setSerialNumber(infoJson.serialNumber);
            }
            if (infoJson.securityMode !== void 0 && infoJson.securityMode == 0) {
              this.imm_commonDisconnect(tryOpenID, YAPI.UNCONFIGURED, "Remote hub is not yet configured");
              this.imm_disconnectNow();
              return;
            }
            if (infoJson.protocol && infoJson.protocol == "HTTP/1.1") {
              this._usePureHTTP = true;
            }
            if (infoJson.port) {
              let i = 0;
              while (i < infoJson.port.length) {
                let proto_port = infoJson.port[i++];
                let split = proto_port.split(":");
                let proto = split[0];
                let port = YAPIContext.imm_atoi(split[1]);
                if (port == 0) {
                  break;
                }
                this._portInfo.push({proto, port});
              }
            }
          }
          if (this._yapi._logLevel >= 4) {
            this._yapi.imm_log("info.json successfully parsed " + url + " [" + tryOpenID + "]");
          }
        } catch (e) {
          if (e.errorType == YAPI.SSL_UNK_CERT) {
            this.imm_commonDisconnect(tryOpenID, YAPI.SSL_UNK_CERT, e.message);
            this.imm_disconnectNow();
            return;
          } else {
            if (this._yapi._logLevel >= 4) {
              this._yapi.imm_log("Unable to get info.json from " + url + " [" + tryOpenID + "]");
            }
            let serialurl = (https_req ? "https://" : "http://") + this.urlInfo.imm_getUrl(false, false, false) + "/api/module/serialNumber";
            try {
              let data = await this._yapi.system_env.downloadfile(serialurl, this._yapi);
              this.imm_setSerialNumber(YAPI.imm_bin2str(data));
            } catch (e2) {
              this.imm_commonDisconnect(tryOpenID, YAPI.IO_ERROR, e2.message);
              return;
            }
          }
        }
      }
      const runtimeUrl = this.imm_UseBestProto();
      if (runtimeUrl.imm_useWebSocket()) {
        if (this._yapi._logLevel >= 4) {
          this._yapi.imm_log("Use WebSocket hub engine [" + tryOpenID + "]");
        }
        this._hubEngine = this._yapi.system_env.getWebSocketEngine(this, runtimeUrl);
      } else {
        if (this._yapi._logLevel >= 4) {
          this._yapi.imm_log("Use HTTP hub engine [" + tryOpenID + "]");
        }
        this._hubEngine = this._yapi.system_env.getHttpEngine(this, runtimeUrl, infoJson);
      }
      if (!this._hubEngine) {
        this.imm_commonDisconnect(tryOpenID, YAPI_NOT_SUPPORTED, "Unsupported hub protocol: " + runtimeUrl.imm_getProto());
        return;
      }
    }
    await this._hubEngine.reconnectEngine(tryOpenID);
  }
  async signalHubConnected(tryOpenID, hubSerial) {
    this.imm_setState(0);
    this.hubSerial = hubSerial;
    if (this._yapi._logLevel >= 4) {
      this._yapi.imm_log("Hub " + hubSerial + " connected [" + tryOpenID + "]");
    }
    let primaryHub = this._yapi.imm_getPrimaryHub(this);
    if (primaryHub._targetState >= 1) {
      if (primaryHub._currentState < 1) {
        try {
          await primaryHub._yapi._ensureUpdateDeviceListNotRunning();
          await primaryHub._yapi._addConnectedHub(primaryHub);
        } catch (e) {
          primaryHub.imm_disconnectNow();
          return;
        }
      }
      if (primaryHub._currentState < primaryHub._targetState) {
        primaryHub.imm_setState(primaryHub._targetState);
      }
    } else {
      primaryHub.keepTryingExpiration = 0;
      primaryHub.imm_tryTestConnectFor(100);
    }
    let res_struct = {errorType: YAPI_SUCCESS, errorMsg: "Hub " + hubSerial + " connected"};
    let resolvers = primaryHub.connResolvers;
    primaryHub.connResolvers = [];
    primaryHub._lastErrorType = res_struct.errorType;
    primaryHub._lastErrorMsg = res_struct.errorMsg;
    for (let resolveOne of resolvers) {
      resolveOne(res_struct);
    }
  }
  imm_signalHubDisconnected(tryOpenID) {
    if (this._yapi._logLevel >= 4) {
      this._yapi.imm_log("imm_signalHubDisconnected  " + this.urlInfo.imm_getRootUrl());
    }
    if (this._currentState > -3) {
      this.imm_setState(-3);
    }
    this.isNotifWorking = false;
    this.devListExpires = 0;
    this._yapi.imm_dropConnectedHub(this);
    this._firstArrivalCallback = true;
    let resolvers = this.disconnResolvers;
    this.disconnResolvers = [];
    for (let resolveOne of resolvers) {
      resolveOne({errorType: YAPI_SUCCESS, errorMsg: "Hub disconnect completed"});
    }
    if (this.imm_isDisconnecting()) {
      this.imm_setState(-5);
      if (this._yapi._logLevel >= 4) {
        this._yapi.imm_log("Hub " + this.urlInfo.imm_getRootUrl() + " detached");
      }
      return false;
    }
    if (this._reconnectionTimer) {
      if (this._yapi._logLevel >= 4) {
        this._yapi.imm_log("Hub disconnected, reconnection is already scheduled [" + this.currentConnID + "]");
      }
      return true;
    }
    let openIDwords = tryOpenID.split("_");
    let nextOpenID = openIDwords[0] + "_" + (parseInt(openIDwords[1]) + 1).toString();
    if (this.retryDelay < 5e3)
      this.retryDelay *= 2;
    if (this._yapi._logLevel >= 4) {
      this._yapi.imm_log("Hub reconnection scheduled in " + this.retryDelay / 1e3 + "s [" + nextOpenID + "]");
    }
    this.currentConnID = nextOpenID;
    this._reconnectionTimer = setTimeout(() => {
      this._reconnectionTimer = null;
      this.currentConnID = "";
      if (this.imm_isDisconnecting()) {
        return;
      }
      if (this._yapi._logLevel >= 4) {
        this._yapi.imm_log("Retry hub connection now [" + nextOpenID + "]");
      }
      this.reconnect(nextOpenID);
    }, this.retryDelay);
    return true;
  }
  imm_commonDisconnect(tryOpenID, errType, errMsg) {
    this._lastErrorType = errType;
    this._lastErrorMsg = errMsg;
    if (this._currentState >= -2) {
      this.imm_setState(-4);
    } else if (this._currentState == -3) {
      this.imm_setState(-5);
    }
    this.imm_setTargetState(-5);
    if (this._reconnectionTimer) {
      clearTimeout(this._reconnectionTimer);
      this._reconnectionTimer = null;
    }
    if (this.timeoutId) {
      clearTimeout(this.timeoutId);
      this.timeoutId = null;
    }
    if (errType != YAPI_SUCCESS && this._yapi._logLevel >= 4 && tryOpenID != "detach") {
      this._yapi.imm_log("Hub connection failed: " + errMsg + " [" + tryOpenID + "]");
    }
    this._firstArrivalCallback = true;
    let res_struct = {errorType: errType, errorMsg: errMsg};
    let resolvers = this.connResolvers;
    this.connResolvers = [];
    for (let resolveOne of resolvers) {
      resolveOne(res_struct);
    }
  }
  imm_disconnectNow(connID = "") {
    if (connID && connID != this.currentConnID) {
      return false;
    }
    if (this._currentState > -2) {
      this.imm_setState(-2);
    }
    if (this.timeoutId) {
      clearTimeout(this.timeoutId);
      this.timeoutId = null;
    }
    if (this._hubEngine) {
      this._hubEngine.imm_disconnectEngineNow(connID);
    } else {
      this.imm_signalHubDisconnected(connID);
    }
    return true;
  }
  async detach(errType = YAPI.IO_ERROR, errMsg = "Hub has been forcibly detached") {
    this.imm_commonDisconnect("detach", errType, errMsg);
    this.imm_disconnectNow();
    this.stalledTimeoutMs = this._yapi._networkTimeoutMs;
    this._hubEngine = null;
  }
  async waitForDisconnection(mstimeout) {
    let disconnPromise = null;
    let disconnTimeoutObj = null;
    disconnPromise = new Promise((resolve, reject) => {
      this.disconnResolvers.push(resolve);
      disconnTimeoutObj = setTimeout(() => {
        if (this._yapi._logLevel >= 4) {
          this._yapi.imm_log("Timeout waiting for hub disconnection");
        }
        resolve({errorType: YAPI_TIMEOUT, errorMsg: "Timeout waiting for hub connection"});
      }, mstimeout);
    });
    await disconnPromise;
    clearTimeout(disconnTimeoutObj);
  }
  async hubUpdateDeviceList() {
    let hubDev = this._yapi.imm_getDevice(this.urlInfo.imm_getRootUrl());
    try {
      hubDev.imm_dropCache();
      let retcode = await hubDev.refresh();
      if (retcode != YAPI_SUCCESS) {
        if (this._currentState >= 1) {
          await this._yapi.updateDeviceList_process(this, hubDev, [], {});
        }
        this.imm_disconnectNow();
        return this._throw(retcode, hubDev._lastErrorMsg, retcode);
      }
      let yreq = await hubDev.requestAPI(this._yapi.defaultCacheValidity);
      if (yreq.errorType != YAPI_SUCCESS) {
        if (this._currentState >= 1) {
          await this._yapi.updateDeviceList_process(this, hubDev, [], {});
        }
        this.imm_disconnectNow();
        return yreq.errorType;
      }
      let whitePages = yreq.obj_result.services.whitePages;
      let yellowPages = yreq.obj_result.services.yellowPages;
      if (!whitePages) {
        this.imm_disconnectNow();
        return this._throw(YAPI_IO_ERROR, "Device " + hubDev.imm_describe() + " is not a hub", YAPI_IO_ERROR);
      }
      retcode = await this._yapi.updateDeviceList_process(this, hubDev, whitePages, yellowPages);
      if (retcode < 0) {
        this.imm_disconnectNow();
        return this._throw(this._yapi._lastErrorType, this._yapi._lastErrorMsg, this._yapi._lastErrorType);
      }
      if (this.isNotifWorking) {
        this.devListExpires = this._yapi.GetTickCount() + this._yapi._deviceListValidityMs;
      } else {
        this.devListExpires = this._yapi.GetTickCount() + 500;
      }
      return retcode;
    } catch (e) {
      if (this._yapi._logLevel >= 3) {
        this._yapi.imm_log("Exception during device enumeration: ", e);
      }
      if (this._currentState >= 1) {
        try {
          await this._yapi.updateDeviceList_process(this, hubDev, [], {});
        } catch (e2) {
        }
      }
      this.imm_disconnectNow();
      return YAPI_IO_ERROR;
    }
  }
  async request(method, devUrl, obj_body, tcpchan) {
    if (!this._hubEngine) {
      let res = new YHTTPRequest(null);
      res.errorType = YAPI_IO_ERROR;
      res.errorMsg = "HubEngine is not initialised";
      return res;
    }
    return await this._hubEngine.request(method, devUrl, obj_body, tcpchan);
  }
  imm_getBoundary() {
    return "Zz" + Math.floor(Math.random() * 16777215).toString(16) + "zZ";
  }
  imm_formEncodeBody(obj_body, str_boundary) {
    let hdr = this._yapi.imm_str2bin('Content-Disposition: form-data; name="' + obj_body.fname + '"; filename="api"\r\nContent-Type: application/octet-stream\r\nContent-Transfer-Encoding: binary\r\n\r\n');
    let boundary = this._yapi.imm_str2bin(str_boundary);
    let dash = this._yapi.imm_str2bin("--");
    let crlf = this._yapi.imm_str2bin("\r\n");
    let parts = [dash, boundary, crlf, hdr, obj_body.data, crlf, dash, boundary, dash, crlf];
    let i, len = 0;
    for (i = 0; i < parts.length; i++) {
      len += parts[i].length;
    }
    let res = new Uint8Array(len);
    len = 0;
    for (i = 0; i < parts.length; i++) {
      res.set(parts[i], len);
      len += parts[i].length;
    }
    return res;
  }
  async getBootloaders() {
    let yreq = await this.request("GET", "/flash.json?a=list", null, 1);
    if (yreq.errorType != YAPI_SUCCESS) {
      return this._throw(yreq.errorType, yreq.errorMsg, []);
    }
    let flashState = JSON.parse(YAPI.imm_bin2str(yreq.bin_result));
    return flashState["list"];
  }
  async firmwareUpdate(serial, firmware, settings, progress) {
    let use_self_flash = false;
    let baseUrl = "";
    let need_reboot = true;
    let _throw = (msg) => {
      return this._throw(YAPI.IO_ERROR, msg, [msg]);
    };
    progress(5, "Check bootloader type");
    let yreq = await this.request("GET", "/api/module.json", null, 0);
    if (yreq.errorType != YAPI_SUCCESS) {
      return _throw("Hub is not responding");
    }
    let json = JSON.parse(this._yapi.imm_bin2str(yreq.bin_result));
    let ownSerial = json.serialNumber;
    if (ownSerial.slice(0, 7) == "VIRTHUB") {
      use_self_flash = false;
    } else if (serial == ownSerial) {
      use_self_flash = true;
    } else {
      yreq = await this.request("GET", "/bySerial/" + serial + "/flash.json?a=state", null, 0);
      if (yreq.errorType == YAPI_SUCCESS && yreq.bin_result.length > 0) {
        use_self_flash = true;
        baseUrl = "/bySerial/" + serial;
      }
    }
    let bootloaders = await this.getBootloaders();
    let is_shield = serial.slice(0, 7) == "YHUBSHL";
    let i;
    for (i = 0; i < bootloaders.length; i++) {
      let bl = bootloaders[i];
      if (bl == serial) {
        need_reboot = false;
      } else if (is_shield) {
        if (bl.slice(0, 7) == "YHUBSHL") {
          return _throw("Only one YoctoHub-Shield is allowed in update mode");
        }
      }
    }
    if (!use_self_flash && need_reboot) {
      if (bootloaders.length >= 4) {
        return _throw("Too many devices in update mode");
      }
    }
    yreq = await this.request("GET", baseUrl + "/flash.json?a=state", null, 0);
    if (yreq.errorType != YAPI_SUCCESS) {
      return _throw("Cannot check state of firmware upload");
    }
    json = JSON.parse(this._yapi.imm_bin2str(yreq.bin_result));
    if (json["state"] == "uploading" || json["state"] == "flashing") {
      return _throw("Cannot start firmware update: busy (" + json["state"] + ")");
    }
    progress(10, "Send firmware file");
    let progressCb = function(curr, total) {
      curr >>= 10;
      total >>= 10;
      progress(10 + (28 * curr / total >> 0), "Send firmware file: " + curr + "KB / " + total + "KB");
    };
    yreq = await this.request("POST", baseUrl + "/upload.html", new YHTTPBody("firmware", firmware.imm_getData(), progressCb), 0);
    if (yreq.errorType != YAPI_SUCCESS) {
      return _throw("Firmware upload failed: " + yreq.errorMsg);
    }
    yreq = await this.request("GET", baseUrl + "/flash.json?a=state", null, 0);
    if (yreq.errorType != YAPI_SUCCESS) {
      return _throw("Cannot check state of firmware upload");
    }
    json = JSON.parse(this._yapi.imm_bin2str(yreq.bin_result));
    if (json["state"] != "valid") {
      return _throw("Upload of firmware failed: invalid firmware(" + json["state"] + ")");
    }
    if (json["progress"] != "100") {
      return _throw("Upload of firmware failed: incomplete upload");
    }
    if (use_self_flash) {
      let settingsStr = this._yapi.imm_bin2str(settings);
      let settingsAndFiles = JSON.parse(settingsStr);
      let settingsOnly = settingsAndFiles["api"];
      let startupApi = {};
      for (let key in settingsOnly) {
        if (key != "services") {
          startupApi[key] = settingsOnly[key];
        }
      }
      let startupConf = this._yapi.imm_str2bin(JSON.stringify(startupApi));
      progress(38, "Save current settings");
      yreq = await this.request("POST", baseUrl + "/upload.html", new YHTTPBody("startupConf.json", startupConf, null), 0);
      if (yreq.errorType != YAPI_SUCCESS) {
        return _throw("Failed to save settings on hub");
      }
      progress(39, "Save current settings");
      yreq = await this.request("POST", baseUrl + "/upload.html", new YHTTPBody("firmwareConf", startupConf, null), 0);
      if (yreq.errorType != YAPI_SUCCESS) {
        return _throw("Failed to save settings on hub");
      }
    }
    if (use_self_flash) {
      progress(40, "Flash firmware");
      await this.request("GET", baseUrl + "/api/module/rebootCountdown?rebootCountdown=-1003", null, 0);
      await this._yapi.Sleep(7e3);
    } else {
      if (need_reboot) {
        await this.request("GET", "/bySerial/" + serial + "/api/module/rebootCountdown?rebootCountdown=-2", null, 0);
      }
      let timeout = YAPI.GetTickCount() + 2e4;
      let res;
      let found = false;
      progress(40, "Wait for device to be in bootloader");
      do {
        bootloaders = await this.getBootloaders();
        for (i = 0; i < bootloaders.length; i++) {
          let bl = bootloaders[i];
          if (bl == serial) {
            found = true;
            break;
          }
        }
        if (!found) {
          await this._yapi.Sleep(500);
        }
      } while (!found && YAPI.GetTickCount() < timeout);
      progress(45, "Flash firmware");
      let fwsize = firmware.imm_getData().length + 512 >> 10;
      let checkTimer;
      let checkFlash = () => {
        this.request("GET", baseUrl + "/flash.json?a=state", null, 1).then((flashReq) => {
          if (flashReq.errorType == YAPI_SUCCESS) {
            let jsonState = YAPI.imm_bin2str(flashReq.bin_result);
            let res2 = JSON.parse(jsonState);
            if (res2.state == "flashing") {
              if (res2.progress < 20) {
                progress(45 + (res2.progress / 3 >> 0), "Erasing previous firmware: " + (fwsize * (res2.progress - 3) / 18 >> 0) + "KB / " + fwsize + "KB");
              } else {
                progress(45 + (res2.progress / 3 >> 0), "Flashing new firmware: " + (fwsize * (res2.progress - 20) / 76 >> 0) + "KB / " + fwsize + "KB");
              }
            }
          }
          checkTimer = setTimeout(checkFlash, 500);
        }).catch((e) => {
          this._yapi.imm_log("Exception during firmware flash: ", e);
          checkTimer = setTimeout(checkFlash, 500);
        });
      };
      checkTimer = setTimeout(checkFlash, 1e3);
      yreq = await this.request("GET", "/flash.json?a=flash&s=" + serial, null, 0);
      clearTimeout(checkTimer);
      if (yreq.errorType != YAPI_SUCCESS) {
        return _throw("Cannot check state of firmware flash");
      }
      return JSON.parse(this._yapi.imm_bin2str(yreq.bin_result));
    }
    return null;
  }
  async reportFailure(message) {
    if (this._hubEngine) {
      await this._hubEngine.reportFailure(message);
    }
  }
  async hasRwAccess() {
    if (this._rwAccess == null) {
      let yreq = await this.request("GET", "/api/module/serialNumber.json?serialNumber=rwTest", null, 0);
      this._rwAccess = yreq.errorType == YAPI_SUCCESS;
    }
    return this._rwAccess;
  }
  imm_isRwAccess() {
    if (this._rwAccess == null) {
      return false;
    }
    return this._rwAccess;
  }
  imm_setRwAccess(rwAccess) {
    this._rwAccess = rwAccess;
  }
  getHubRef() {
    return this._hubRef;
  }
  get_knownUrls() {
    let res = this._knownUrls.slice();
    return res;
  }
  imm_forgetUrls() {
    this._knownUrls = [];
  }
  imm_getOriginalURL() {
    return this.urlInfo.imm_getOriginalURL();
  }
  imm_getRootUrl() {
    return this.urlInfo.imm_getRootUrl();
  }
  imm_getSerialNumber() {
    return this.hubSerial;
  }
  imm_setSerialNumber(serial) {
    this.hubSerial = serial;
  }
  imm_getNetworkTimeout() {
    return this.stalledTimeoutMs;
  }
  imm_setNetworkTimeout(mstimeout) {
    this.stalledTimeoutMs = mstimeout;
  }
  imm_setHubEngine(engine) {
    this._hubEngine = engine;
  }
  imm_setRetryDelay(value) {
    this.retryDelay = value;
  }
  imm_SetErr(errorType, errorMsg) {
    this._lastErrorType = errorType;
    this._lastErrorMsg = errorMsg;
  }
  async WebSocketJoin(ws, arr_credentials, closeCallback) {
    return this._hubEngine.websocketJoin(ws, arr_credentials, closeCallback);
  }
  imm_UseBestProto() {
    let cur_proto = this.urlInfo.imm_getProto();
    let runtime_urlInfo = this.urlInfo;
    this._hubMode = HubMode.SECURE;
    if (this._portInfo.length > 0) {
      if (this._usePureHTTP) {
        if (cur_proto == "ws" || cur_proto == "wss") {
          this._yapi._throw(YAPI.NOT_SUPPORTED, "Websocket protocol is not supported by VirtualHub-4web.");
        }
        for (let i = 0; i < this._portInfo.length; i++) {
          let portInfo = this._portInfo[i];
          if (portInfo.proto.startsWith("http")) {
            if (this._yapi._logLevel >= 3) {
              this._yapi.imm_log("Hub " + this.urlInfo.imm_getHost() + " will use " + portInfo.proto + " proto on port " + portInfo.port);
            }
            runtime_urlInfo = this.urlInfo;
            runtime_urlInfo.imm_updateBestProto(portInfo.proto, portInfo.port);
            break;
          }
        }
      } else {
        let best_port = 0;
        let best_proto = "ws";
        if (this._portInfo[0].proto == "http" || this._portInfo[0].proto == "ws") {
          this._hubMode = HubMode.LEGACY;
        }
        for (let i = 0; i < this._portInfo.length; i++) {
          let portInfo = this._portInfo[i];
          if (this._hubMode == HubMode.SECURE && (portInfo.proto == "http" || portInfo.proto == "ws")) {
            if (this._yapi._logLevel >= 3) {
              this._yapi.imm_log("Hub " + this.urlInfo.imm_getHost() + " use mixed or legacy mode");
            }
            this._hubMode = HubMode.MIXED;
          }
          if (cur_proto == "auto" && best_port == 0) {
            if (portInfo.proto.startsWith("http") || portInfo.proto.startsWith("ws")) {
              best_proto = portInfo.proto;
              best_port = portInfo.port;
            }
          }
          if (cur_proto == "secure" && best_port == 0) {
            if (portInfo.proto == "https" || portInfo.proto == "wss") {
              best_proto = portInfo.proto;
              best_port = portInfo.port;
            }
          }
        }
        if (best_port != 0) {
          if (this._yapi._logLevel >= 3) {
            this._yapi.imm_log("Hub " + this.urlInfo.imm_getHost() + " will use " + best_proto + " proto on port " + best_port);
          }
          runtime_urlInfo = this.urlInfo;
          runtime_urlInfo.imm_updateBestProto(best_proto, best_port);
        }
      }
    }
    return runtime_urlInfo;
  }
  imm_useMixedMode() {
    return this._hubMode == HubMode.MIXED || this._hubMode == HubMode.LEGACY;
  }
  async waitForPendingQueries(ms_timeout) {
    if (this._hubEngine) {
      await this._hubEngine.waitForPendingQueries(ms_timeout);
    }
  }
};
YGenericHub.globalHubRefCounter = 0;
var YHttpEngine = class extends YHubEngine {
  constructor(hub, runtime_urlInfo, firstInfoJson) {
    super(hub, runtime_urlInfo);
    this.infoJson = null;
    this.ha1 = "";
    this.realm = "";
    this.nonce = "";
    this.opaque = "";
    this.nonceCount = 0;
    this.notbynRequest = null;
    this.infoJson = firstInfoJson;
  }
  imm_makeRequest(method, relUrl, contentType, body, onProgress, onSuccess, onError) {
  }
  imm_abortRequest(clientRequest) {
  }
  imm_sendRequest(method, relUrl, obj_body, onProgress, onSuccess, onError) {
    let body = null;
    let contentType = "text/plain; charset=x-user-defined";
    if (this.infoJson && this.infoJson.realm && this.infoJson.nonce) {
      if (this.realm != this.infoJson.realm || this.nonce != this.infoJson.nonce) {
        this.realm = this.infoJson.realm;
        this.nonce = this.infoJson.nonce;
        this.nonceCount = 0;
      }
      let shorturi = this._runtime_urlInfo.imm_getSubDomain() + relUrl;
      let jsonBody = {
        "x-yauth": {
          method,
          uri: shorturi,
          nonce: this.nonce
        }
      };
      if (this._runtime_urlInfo.imm_hasAuthParam()) {
        let cnonce = Math.floor(Math.random() * 2147483647).toString(16).toLowerCase();
        let nc = (++this.nonceCount).toString(16).toLowerCase();
        let ha1_str = this._runtime_urlInfo.imm_getUser() + ":" + this.realm + ":" + this._runtime_urlInfo.imm_getPass();
        let ha2_str = method + ":" + shorturi;
        let A1 = this._hub._yapi.imm_bin2hexstr(this._hub._yapi.imm_yMD5(ha1_str)).toLowerCase();
        let A2 = this._hub._yapi.imm_bin2hexstr(this._hub._yapi.imm_ySHA1(ha2_str)).toLowerCase();
        let signature = A1 + ":" + this.nonce + ":" + nc + ":" + cnonce + ":auth:" + A2;
        let response = this._hub._yapi.imm_bin2hexstr(this._hub._yapi.imm_ySHA1(signature)).toLowerCase();
        jsonBody["x-yauth"]["username"] = this._runtime_urlInfo.imm_getUser();
        jsonBody["x-yauth"]["cnonce"] = cnonce;
        jsonBody["x-yauth"]["nc"] = nc;
        jsonBody["x-yauth"]["qop"] = "auth";
        jsonBody["x-yauth"]["response"] = response;
      }
      if (obj_body) {
        let binstr = this._hub._yapi.imm_bin2str(obj_body.data);
        jsonBody["body"] = {
          filename: obj_body.fname,
          b64content: btoa(binstr)
        };
      }
      method = "POST";
      body = JSON.stringify(jsonBody);
      let qpos = relUrl.indexOf("?");
      if (qpos > 0) {
        relUrl = relUrl.slice(0, qpos);
      }
    } else if (obj_body != null) {
      let boundary = this._hub.imm_getBoundary();
      if (this.infoJson && this.infoJson.nonce) {
        contentType = "x-upload; boundary=" + boundary;
      } else {
        contentType = "multipart/form-data; boundary=" + boundary;
      }
      body = this._hub.imm_formEncodeBody(obj_body, boundary);
    }
    return this.imm_makeRequest(method, relUrl, contentType, body, onProgress, onSuccess, onError);
  }
  async tryFetch(relUrl) {
    return new Promise((resolve, reject) => {
      this.imm_sendRequest("GET", relUrl, null, null, (responseText) => {
        resolve({errorType: YAPI_SUCCESS, errorMsg: "", result: responseText});
      }, (errorType, errorMsg, can_be_retry) => {
        if (can_be_retry) {
          this.imm_sendRequest("GET", relUrl, null, null, (responseText2) => {
            resolve({errorType: YAPI_SUCCESS, errorMsg: "", result: responseText2});
          }, (errorType2, errorMsg2, can_be_retry2) => {
            resolve({errorType: errorType2, errorMsg: errorMsg2});
          });
        } else {
          resolve({errorType, errorMsg});
        }
      });
    });
  }
  async reconnectEngine(tryOpenID) {
    this._hub.imm_setCurrentConnID(tryOpenID);
    if (this.infoJson && this.infoJson.nonce && YAPI.GetTickCount() - this.infoJson.stamp > 12e3) {
      if (this._hub._yapi._logLevel >= 4) {
        this._hub._yapi.imm_log("Trying info.json [" + tryOpenID + "]");
      }
      let res_struct = await this.tryFetch("info.json");
      if (res_struct.errorType == YAPI_SUCCESS && res_struct.result) {
        this.infoJson = JSON.parse(res_struct.result);
        this.infoJson.stamp = YAPI.GetTickCount();
      }
    }
    let primaryHub = this._hub._yapi.imm_getPrimaryHub(this._hub);
    if (primaryHub !== this._hub) {
      this._hub.imm_commonDisconnect(tryOpenID, YAPI_SUCCESS, "Hub " + this._hub.imm_getSerialNumber() + " is already connected");
      this._hub.imm_setCurrentConnID("");
      this._hub.imm_signalHubDisconnected(tryOpenID);
      return;
    }
    let args = "";
    if (this._hub.imm_getNotifyPos() >= 0) {
      args = "?abs=" + this._hub.imm_getNotifyPos().toString();
    } else {
      this._hub.imm_setFirstArrivalCallback(true);
    }
    if (this._hub._yapi._logLevel >= 4) {
      this._hub._yapi.imm_log("Opening http connection to hub (" + args + ") [" + tryOpenID + "]");
    }
    this.notbynRequest = this.imm_sendRequest("GET", "/not.byn" + args, null, (moreText) => {
      if (tryOpenID != this._hub.imm_getCurrentConnID()) {
        if (this._hub._yapi._logLevel >= 3) {
          this._hub._yapi.imm_log("Previous request still sending data [" + tryOpenID + "]");
        }
        return;
      }
      if (this.infoJson) {
        this.infoJson.stamp = YAPI.GetTickCount();
      }
      if (this._hub.imm_getcurrentState() < 0) {
        this._hub.signalHubConnected(tryOpenID, this._hub.imm_getSerialNumber());
      }
      this.imm_updateLastPinfStamp();
      this._hub._yapi.parseEvents(this._hub, moreText);
    }, (resultText) => {
      if (tryOpenID != this._hub.imm_getCurrentConnID()) {
        if (this._hub._yapi._logLevel >= 3) {
          this._hub._yapi.imm_log("Previous request completed [" + tryOpenID + "]");
        }
        return;
      }
      this.reconnectEngine(tryOpenID);
    }, (errorType, errorMsg, can_be_retry) => {
      if (tryOpenID != this._hub.imm_getCurrentConnID()) {
        if (this._hub._yapi._logLevel >= 3) {
          this._hub._yapi.imm_log("Previous not.byn request says: " + errorMsg + " [" + tryOpenID + "]");
        }
        return;
      }
      if (!this._hub.imm_isDisconnecting()) {
        if (this._hub._yapi._logLevel >= 3) {
          this._hub._yapi.imm_log("Failed to load not.byn (" + args + "): " + errorMsg + " [" + tryOpenID + "]");
        }
      }
      this._hub.imm_SetErr(errorType, errorMsg);
      if ((errorType == YAPI_UNAUTHORIZED || errorType == YAPI_SSL_UNK_CERT) && !can_be_retry) {
        this._hub.imm_commonDisconnect(tryOpenID, errorType, errorMsg);
      }
      this._hub.imm_disconnectNow();
    });
  }
  imm_disconnectEngineNow(connID = "") {
    if (this._hub._yapi._logLevel >= 4) {
      this._hub._yapi.imm_log("YHTTPEngine.imm_disconnectEngineNow " + connID);
    }
    if (!this.notbynRequest) {
      return;
    }
    let closeConnID = connID ? connID : this._hub.imm_getCurrentConnID();
    this.imm_abortRequest(this.notbynRequest);
    this.notbynRequest = null;
    this._hub.imm_setCurrentConnID("");
    this._hub.imm_signalHubDisconnected(closeConnID);
  }
  async request(method, devUrl, obj_body, tcpchan) {
    if (this._hub._yapi._logLevel >= 3) {
      this._hub.imm_logrequest(method, devUrl, obj_body);
    }
    if (this._hub.imm_getcurrentState() < 0) {
      return new YHTTPRequest(null, YAPI.IO_ERROR, "Hub is currently unavailable");
    }
    return new Promise((resolve, reject) => {
      this.imm_sendRequest(method, devUrl, obj_body, null, (responseText) => {
        if (this._hub.imm_getcurrentState() < 0) {
          resolve(new YHTTPRequest(null, YAPI.IO_ERROR, "Hub is currently unavailable"));
        } else {
          if (this._hub._yapi._logLevel >= 4) {
            this._hub._yapi.imm_log(method + " " + devUrl + " succeeded");
          }
          resolve(new YHTTPRequest(this._hub._yapi.imm_str2bin(responseText)));
        }
      }, (errorType, errorMsg, can_be_retry) => {
        if (this._hub._yapi._logLevel >= 4) {
          this._hub._yapi.imm_log(method + " " + devUrl + " failed (" + errorMsg + ")");
        }
        resolve(new YHTTPRequest(null, errorType, errorMsg));
      });
    });
  }
};
var YWebSocketEngine = class extends YHubEngine {
  constructor(hub, runtime_urlInfo) {
    super(hub, runtime_urlInfo);
    this._DEFAULT_TCP_ROUND_TRIP_TIME = 30;
    this._DEFAULT_TCP_MAX_WINDOW_SIZE = 4 * 65536;
    this._YIO_DEFAULT_TCP_TIMEOUT = 2e4;
    this._YIO_1_MINUTE_TCP_TIMEOUT = 6e4;
    this._YIO_10_MINUTES_TCP_TIMEOUT = 6e5;
    this._USB_META_UTCTIME_SIZE = 5;
    this._USB_META_DLFLUSH_SIZE = 1;
    this._USB_META_ACK_D2H_PACKET_SIZE = 2;
    this._USB_META_WS_ANNOUNCE_SIZE = 8 + 20;
    this._USB_META_WS_AUTHENTICATION_SIZE = 28;
    this._USB_META_WS_ERROR_SIZE = 6;
    this._USB_META_ACK_UPLOAD_SIZE = 6;
    this._USB_META_WS_VALID_SHA1 = 1;
    this._USB_META_WS_RW = 2;
    this.websocket = null;
    this.tcpChan = [];
    this.nextAsyncId = 48;
    this._connectionTime = 0;
    this._remoteVersion = 0;
    this._remoteSerial = "";
    this._remoteNonce = -1;
    this._nonce = -1;
    this._session_error = null;
    this._session_errno = null;
    this._lastUploadAckBytes = [0];
    this._lastUploadAckTime = [0];
    this._lastUploadRateBytes = [0];
    this._lastUploadRateTime = [0];
    this._uploadRate = [0];
    this.fwd_nonce = -1;
    this.fwd_websocket = null;
    this.fwd_credentials = [];
    this.fwd_closeCallback = null;
    this._connectionState = 2;
    this._tcpRoundTripTime = this._DEFAULT_TCP_ROUND_TRIP_TIME;
    this._tcpMaxWindowSize = this._DEFAULT_TCP_MAX_WINDOW_SIZE;
    this.fwd_connectionState = 1;
  }
  imm_asyncWebSocketError(errorType, message) {
    if (this._hub._yapi._logLevel >= 3) {
      this._hub._yapi.imm_log("WS: " + message + " on " + this._runtime_urlInfo.imm_getRootUrl());
    }
  }
  async reconnectEngine(tryOpenID) {
    this._connectionState = 2;
    if (this._hub._yapi._logLevel >= 4) {
      this._hub._yapi.imm_log("Opening websocket connection [" + tryOpenID + "]");
    }
    this._hub.imm_setCurrentConnID(tryOpenID);
    let url = (this._runtime_urlInfo.imm_useSecureSocket() ? "wss://" : "ws://") + this._runtime_urlInfo.imm_getUrl(false, true, true);
    this.imm_webSocketOpen(url + "not.byn");
    this._hub.imm_setFirstArrivalCallback(true);
    if (!this.websocket) {
      this._hub.imm_commonDisconnect(tryOpenID, YAPI_IO_ERROR, "Failed to create WebSocket");
      return;
    }
    this.websocket.onmessage = (evt) => {
      if (this._hub.imm_getCurrentConnID() != tryOpenID) {
        if (this._hub._yapi._logLevel >= 4) {
          this._hub._yapi.imm_log("Incoming WebSocket data for previous connection [" + tryOpenID + "]");
        }
        return;
      }
      this._webSocketMsg(new Uint8Array(evt.data));
      if (this._connectionState == 4) {
        this._connectionState = 5;
        this._hub.signalHubConnected(tryOpenID, this._remoteSerial);
      } else if (this._connectionState == 0) {
        let errMsg = this._session_error ? "WebSocket error: " + this._session_error : "Websocket I/O error";
        if (this._session_errno == 401) {
          this._hub.imm_commonDisconnect(tryOpenID, YAPI_UNAUTHORIZED, errMsg);
        } else {
          this._hub.imm_SetErr(YAPI_IO_ERROR, errMsg);
        }
        this._hub.imm_disconnectNow();
      }
    };
    this.websocket.onclose = (evt) => {
      if (this._hub.imm_getCurrentConnID() != tryOpenID) {
        if (this._hub._yapi._logLevel >= 4) {
          this._hub._yapi.imm_log("WebSocket close received for previous connection [" + tryOpenID + "], now using [" + this._hub.imm_getCurrentConnID() + "]");
        }
        return;
      }
      if (this._hub._yapi._logLevel >= 4) {
        this._hub._yapi.imm_log("WebSocket connection closed [" + tryOpenID + "]");
      }
      this._connectionState = 1;
      this.websocket = null;
      if (this._hub.retryDelay < 0) {
        this._hub.imm_commonDisconnect(tryOpenID, YAPI_IO_ERROR, "Websocket callback connection closed");
      }
      this.imm_dropAllPendingConnection();
      this._hub.imm_signalHubDisconnected(tryOpenID);
    };
    this.websocket.onerror = (evt) => {
      if (this._hub.imm_getCurrentConnID() != tryOpenID) {
        if (this._hub._yapi._logLevel >= 4) {
          this._hub._yapi.imm_log("WebSocket error received for previous connection [" + tryOpenID + "]");
        }
        return;
      }
      if (evt.message && (!/ ETIMEDOUT /.test(evt.message) || this._hub._yapi._logLevel >= 4)) {
        if (this._hub._yapi._logLevel >= 3) {
          this._hub._yapi.imm_log("WebSocket error [" + tryOpenID + "]: ", evt);
        }
        if (evt.error.code == "DEPTH_ZERO_SELF_SIGNED_CERT") {
          this._hub.imm_commonDisconnect(tryOpenID, YAPI_SSL_UNK_CERT, evt.message);
        } else {
          this._hub.imm_SetErr(YAPI_IO_ERROR, evt.message);
        }
      }
      if (this._hub.retryDelay < 0) {
        this._hub.imm_commonDisconnect(tryOpenID, YAPI_IO_ERROR, "Websocket callback connection closed");
      }
      this._hub.imm_disconnectNow();
      this._hub.imm_signalHubDisconnected(tryOpenID);
    };
    if (this._hub.timeoutId) {
      clearTimeout(this._hub.timeoutId);
    }
    this._hub.timeoutId = setTimeout(() => {
      if (!this.imm_isForwarded()) {
        if (this._hub._yapi._logLevel >= 3) {
          this._hub._yapi.imm_log("WS: connection stalled during open [" + tryOpenID + "]");
        }
        this._hub.imm_disconnectNow();
      }
    }, this._hub.imm_getNetworkTimeout());
  }
  imm_computeAuth(user, pass, serial, nonce) {
    let ha1_str = user + ":" + serial + ":" + pass;
    let ha1 = this._hub._yapi.imm_bin2hexstr(this._hub._yapi.imm_yMD5(ha1_str)).toLowerCase();
    let nonce8 = new Uint8Array([(nonce & 255) >>> 0, (nonce & 65280) >>> 8, (nonce & 16711680) >>> 16, nonce >>> 24]);
    let sha1_raw = ha1 + this._hub._yapi.imm_bin2hexstr(nonce8).toLowerCase();
    return this._hub._yapi.imm_ySHA1(sha1_raw.toLowerCase());
  }
  imm_isForwarded() {
    return this.fwd_connectionState == 5 && this.fwd_websocket !== null;
  }
  async _webSocketMsg(arr_bytes) {
    try {
      if (this.imm_isForwarded()) {
        this.imm_updateLastPinfStamp();
        this.fwd_websocket.send(arr_bytes);
        return;
      }
      let reltime = (this._hub._yapi.GetTickCount() - this._connectionTime) / 1e3;
      let ystream = arr_bytes[0] >>> 3;
      let text = "";
      if (ystream == 8) {
        for (let i = 1; i < arr_bytes.length; i++) {
          text += String.fromCharCode(arr_bytes[i]);
        }
        this.imm_updateLastPinfStamp();
        await this._hub._yapi.parseEvents(this._hub, text);
        return;
      }
      let ws = this.websocket;
      let tcpchan = arr_bytes[0] & 7;
      if (ystream == 1 || ystream == 2 || ystream == 9) {
        if (tcpchan > 3) {
          this.imm_asyncWebSocketError(YAPI_IO_ERROR, "Unexpected frame for tcpChan " + tcpchan + " (" + ystream + ")");
          return;
        }
        let tcp_end = arr_bytes.length;
        let yreq = this.tcpChan[tcpchan];
        if (!yreq) {
          this.imm_asyncWebSocketError(YAPI_IO_ERROR, "Drop frame for closed tcpChan " + tcpchan + " (" + ystream + ")");
          return;
        }
        if (ystream == 9) {
          tcp_end--;
          let rcvId = arr_bytes[tcp_end];
          if (this._hub._yapi._logLevel >= 5) {
            this._hub._yapi.imm_log("async-" + rcvId + " close received");
          }
          if (yreq.asyncId == 0) {
            if (this._hub._yapi._logLevel >= 4) {
              this._hub._yapi.imm_log("async-" + rcvId + " close received while req @" + yreq._creat + " was pending");
            }
            this.imm_asyncWebSocketError(YAPI_IO_ERROR, "Asynchronous close received, sync reply request");
            return;
          } else if (yreq.asyncId != rcvId) {
            if (this._hub._yapi._logLevel >= 4) {
              this._hub._yapi.imm_log("async-" + rcvId + " close received instead of async-" + yreq.asyncId + " close");
            }
            this.imm_asyncWebSocketError(YAPI_IO_ERROR, "Incorrect async-close signature on tcpChan " + tcpchan);
            return;
          }
        }
        let oldArr = yreq.bin_result;
        let newArr = new Uint8Array(oldArr.length + tcp_end - 1);
        newArr.set(oldArr, 0);
        newArr.set(arr_bytes.subarray(1, tcp_end), oldArr.length);
        yreq.bin_result = newArr;
        if (ystream == 2 || ystream == 9) {
          this.tcpChan[tcpchan] = yreq.next;
          if (ystream == 2) {
            if (yreq.asyncId != 0) {
              if (this._hub._yapi._logLevel >= 4) {
                this._hub._yapi.imm_log("Synchronous close received instead of async-" + yreq.asyncId + " close");
              }
              this.imm_asyncWebSocketError(YAPI_IO_ERROR, "Synchronous close received, async ack expected");
              return;
            } else if (this.websocket) {
              if (yreq.toBeSent && yreq.sendPos < yreq.toBeSent.length) {
                if (this._hub._yapi._logLevel >= 3) {
                  this._hub._yapi.imm_log("WS: tcpclose at " + yreq.sendPos + " < " + yreq.toBeSent.length);
                }
                this._hub.imm_disconnectNow();
                if (yreq.timeoutId) {
                  clearTimeout(yreq.timeoutId);
                }
                if (yreq.asyncId == 0) {
                  yreq.errorType = YAPI_IO_ERROR;
                  yreq.errorMsg = "TCP closed during upload";
                  if (yreq.acceptor) {
                    try {
                      yreq.acceptor(yreq);
                    } catch (e) {
                    }
                  }
                }
                return;
              }
              if (yreq.timeoutId) {
                let frame = new Uint8Array(1);
                frame[0] = (2 << 3) + tcpchan;
                this.websocket.send(frame);
              }
            }
          }
          if (yreq.timeoutId) {
            clearTimeout(yreq.timeoutId);
            yreq.timeoutId = 0;
          }
          let pos = yreq.bin_result.indexOf(13);
          if (pos < 0) {
            yreq.errorType = YAPI_IO_ERROR;
            yreq.errorMsg = "Bad response header";
          } else {
            let header = this._hub._yapi.imm_bin2str(yreq.bin_result.subarray(0, pos));
            let words = header.split(" ");
            if (words[0] == "OK") {
              yreq.errorType = YAPI_SUCCESS;
              let nextpos = yreq.bin_result.indexOf(13, pos + 2);
              while (nextpos > pos + 2) {
                pos = nextpos;
                nextpos = yreq.bin_result.indexOf(13, pos + 2);
              }
              if (nextpos < 0) {
                nextpos = pos;
              }
              yreq.bin_result = yreq.bin_result.subarray(nextpos + 2);
            } else if (words[0] == "0K") {
              yreq.errorType = YAPI_IO_ERROR;
              yreq.errorMsg = "Unexpected persistent connection";
            } else {
              let status = parseInt(words[1]);
              yreq.errorType = status == 401 ? YAPI_UNAUTHORIZED : YAPI_IO_ERROR;
              yreq.errorMsg = "HTTP error " + header.slice(words[0].length + 1) + " on " + yreq.devUrl;
            }
          }
          if (yreq.asyncId == 0) {
            if (this._hub._yapi._logLevel >= 5) {
              this._hub._yapi.imm_log("request @" + yreq._creat + " done, status=" + yreq.errorType);
            }
            this.imm_sendPendingRequest(tcpchan);
            if (yreq.acceptor) {
              yreq.acceptor(yreq);
            }
          } else {
            if (yreq.errorType != YAPI_SUCCESS) {
              this.imm_asyncWebSocketError(YAPI_IO_ERROR, "Async request error: " + yreq.errorMsg);
            }
          }
        }
        return;
      }
      if (!this.websocket) {
        return;
      }
      if (ystream == 5) {
        let metatype = arr_bytes[1];
        switch (metatype) {
          case 4:
            if (arr_bytes.length < 1 + this._USB_META_WS_ANNOUNCE_SIZE) {
              return;
            }
            this._remoteVersion = arr_bytes[2];
            if (this._remoteVersion < 1) {
              return;
            }
            let maxtcpws = (arr_bytes[3] << 4) + (arr_bytes[4] << 12);
            if (maxtcpws > 0) {
              this._tcpMaxWindowSize = maxtcpws;
            }
            this._remoteNonce = arr_bytes[5] + (arr_bytes[6] << 8) + (arr_bytes[7] << 16) + (arr_bytes[8] << 24);
            for (let i = 9; i < 9 + 20; i++) {
              if (arr_bytes[i] == 0) {
                this._remoteSerial = this._hub._yapi.imm_bin2str(arr_bytes.subarray(9, i));
                break;
              }
            }
            let nonce = new Uint8Array(4);
            this.imm_getRandomValues(nonce);
            this._nonce = nonce[0] + (nonce[1] << 8) + (nonce[2] << 16) + (nonce[3] << 24);
            this._connectionTime = this._hub._yapi.GetTickCount();
            this._connectionState = 3;
            let frame = new Uint8Array(1 + this._USB_META_WS_AUTHENTICATION_SIZE);
            let version = this._remoteVersion < 2 ? this._remoteVersion : 2;
            let flags = 0;
            frame[0] = 5 << 3;
            frame[1] = 5;
            frame[2] = version;
            if (this._runtime_urlInfo.imm_getPass() != "") {
              flags = this._USB_META_WS_VALID_SHA1;
              let sha1 = this.imm_computeAuth(this._runtime_urlInfo.imm_getUser(), this._runtime_urlInfo.imm_getPass(), this._remoteSerial, this._remoteNonce);
              for (let i = 0; i < sha1.length; i++) {
                frame[9 + i] = sha1[i];
              }
            }
            frame[3] = flags & 255;
            frame[4] = flags >>> 8;
            frame[5] = this._nonce & 255;
            frame[6] = this._nonce >>> 8 & 255;
            frame[7] = this._nonce >>> 16 & 255;
            frame[8] = this._nonce >>> 24 & 255;
            this.websocket.send(frame);
            break;
          case 5:
            if (this._connectionState != 3) {
              return;
            }
            if (arr_bytes.length < 1 + this._USB_META_WS_AUTHENTICATION_SIZE) {
              return;
            }
            this._tcpRoundTripTime = this._hub._yapi.GetTickCount() - this._connectionTime + 1;
            if (this._tcpMaxWindowSize < 2048 && this._tcpRoundTripTime < 7) {
              this._tcpRoundTripTime = 7;
            }
            let uploadRate = this._tcpMaxWindowSize * 1e3 / this._tcpRoundTripTime >> 0;
            if (this._hub._yapi._logLevel >= 4) {
              this._hub._yapi.imm_log("RTT=" + this._tcpRoundTripTime + "ms, WS=" + this._tcpMaxWindowSize + ", uploadRate=" + uploadRate / 1e3 + " KB/s");
            }
            this._remoteVersion = arr_bytes[2];
            if (this._remoteVersion < 1) {
              return;
            }
            let inflags = arr_bytes[3] + (arr_bytes[4] << 8);
            if ((inflags & this._USB_META_WS_RW) != 0) {
              this._hub.imm_setRwAccess(true);
            } else {
              this._hub.imm_setRwAccess(false);
            }
            if ((inflags & this._USB_META_WS_VALID_SHA1) != 0) {
              let remote_sha1 = arr_bytes.subarray(9, 29);
              let sha1 = this.imm_computeAuth(this._runtime_urlInfo.imm_getUser(), this._runtime_urlInfo.imm_getPass(), this._remoteSerial, this._nonce);
              for (let i = 0; i < sha1.length; i++) {
                if (sha1[i] != remote_sha1[i]) {
                  this._session_errno = 401;
                  this._session_error = "Authentication failed";
                  this._connectionState = 0;
                  return;
                }
              }
              this._connectionState = 4;
            } else {
              if (this._runtime_urlInfo.imm_getPass() == "") {
                this._connectionState = 4;
              } else {
                this._session_errno = 401;
                if (this._runtime_urlInfo.imm_getUser() == "admin" && !this._hub.imm_isRwAccess()) {
                  this._session_error = "Authentication as admin failed";
                } else {
                  this._session_error = "Password not set on remote hub";
                }
                this._connectionState = 0;
                return;
              }
            }
            break;
          case 6:
            this._session_errno = arr_bytes[3] + (arr_bytes[4] << 8);
            if (this._session_errno == 401) {
              this._session_error = "Authentication failed";
            } else {
              this._session_error = "Remote hub closed connection with error " + this._session_errno;
            }
            this._connectionState = 0;
            break;
          case 7:
            tcpchan = arr_bytes[2];
            if (this.tcpChan[tcpchan]) {
              let yreq = this.tcpChan[tcpchan];
              let ackBytes = arr_bytes[3] + (arr_bytes[4] << 8) + (arr_bytes[5] << 16) + (arr_bytes[6] << 24);
              let ackTime = this._hub._yapi.GetTickCount();
              if (this._lastUploadAckTime[tcpchan] != 0 && ackBytes > this._lastUploadAckBytes[tcpchan]) {
                this._lastUploadAckBytes[tcpchan] = ackBytes;
                this._lastUploadAckTime[tcpchan] = ackTime;
                let deltaBytes = ackBytes - this._lastUploadRateBytes[tcpchan];
                let deltaTime = ackTime - this._lastUploadRateTime[tcpchan];
                if (deltaTime < 500)
                  break;
                if (deltaTime < 1e3 && deltaBytes < 65536)
                  break;
                this._lastUploadRateBytes[tcpchan] = ackBytes;
                this._lastUploadRateTime[tcpchan] = ackTime;
                if (yreq.progressCb && yreq.toBeSent) {
                  yreq.progressCb(ackBytes, yreq.toBeSent.length);
                }
                let newRate = deltaBytes * 1e3 / deltaTime;
                this._uploadRate[tcpchan] = 0.8 * this._uploadRate[tcpchan] + 0.3 * newRate >> 0;
                if (this._hub._yapi._logLevel >= 5) {
                  this._hub._yapi.imm_log("New rate: " + this._uploadRate[tcpchan] / 1e3 + " KB/s (last " + (deltaBytes / 1e3 >> 0) + "KB sent at " + (newRate >> 0) / 1e3 + " KB/s)");
                }
              } else {
                this._lastUploadAckBytes[tcpchan] = ackBytes;
                this._lastUploadAckTime[tcpchan] = ackTime;
                this._lastUploadRateBytes[tcpchan] = ackBytes;
                this._lastUploadRateTime[tcpchan] = ackTime;
                if (yreq.progressCb && yreq.toBeSent) {
                  yreq.progressCb(ackBytes, yreq.toBeSent.length);
                }
                this.imm_sendPendingRequest(tcpchan);
              }
            }
            break;
        }
        return;
      }
      this.imm_asyncWebSocketError(YAPI_IO_ERROR, "Unsupported message: " + this._hub._yapi.imm_bin2hexstr(arr_bytes));
    } catch (e) {
      this._hub._yapi.imm_log("Unhandled exception in _webSocketMsg:", e);
    }
  }
  imm_webSocketSend(arr_bytes) {
    if (this.websocket) {
      this.websocket.send(arr_bytes);
    }
  }
  imm_hasPendingRequest() {
    for (let tcpchan = 0; tcpchan < 4; tcpchan++) {
      let queue = this.tcpChan[tcpchan];
      if (queue) {
        return true;
      }
    }
    return false;
  }
  async waitForPendingQueries(ms_duration) {
    let end = this._hub._yapi.GetTickCount() + ms_duration;
    let remaining = ms_duration;
    while (this.imm_hasPendingRequest() && remaining > 0) {
      let waitTime = Math.min(remaining, 25);
      await new Promise((resolve, reject) => {
        setTimeout(resolve, waitTime);
      });
      remaining = end - this._hub._yapi.GetTickCount();
    }
  }
  async request(method, devUrl, obj_body, tcpchan) {
    if (this._hub._yapi._logLevel >= 3) {
      this._hub.imm_logrequest(method, devUrl, obj_body);
    }
    let httpPromise = new Promise((resolve, reject) => {
      let subReq = method + " " + devUrl + " \r\n\r\n";
      let ws = this.websocket;
      let isAsync = this._remoteVersion > 0 && devUrl.slice(-2) == "&.";
      let yreq = new YHTTPRequest(new Uint8Array(0));
      if (this._hub._yapi._logLevel >= 5) {
        yreq._creat = (Date.now() % 6e5).toString();
        this._hub._yapi.imm_log("request @" + yreq._creat + ": " + method + " " + devUrl);
      }
      yreq.acceptor = resolve;
      yreq.devUrl = devUrl;
      yreq.sendPos = 0;
      if (obj_body) {
        let boundary = this._hub.imm_getBoundary();
        let body = this._hub.imm_formEncodeBody(obj_body, boundary);
        subReq = subReq.slice(0, -2) + "Content-Type: x-upload, boundary=" + boundary + "\r\n\r\n";
        yreq.toBeSent = new Uint8Array(subReq.length + body.length);
        yreq.toBeSent.set(body, subReq.length);
        yreq.progressCb = obj_body.progressCb;
      } else {
        yreq.toBeSent = new Uint8Array(subReq.length);
      }
      for (let i = 0; i < subReq.length; i++) {
        yreq.toBeSent[i] = subReq.charCodeAt(i);
      }
      if (tcpchan > 3) {
        yreq.errorType = YAPI_IO_ERROR;
        yreq.errorMsg = "Unsupported tcpChan " + tcpchan;
        try {
          yreq.acceptor(yreq);
        } catch (e) {
        }
        return;
      }
      if (!ws || this._hub.imm_isDisconnecting() || this._connectionState != 5) {
        if (this._hub._yapi._logLevel >= 4) {
          let wsState = ws ? " websocket=NULL" : "";
          let dsState = this._hub.imm_isDisconnecting() ? " disconnecting" : "";
          let cnState = this._connectionState != 5 ? " connState=" + this._connectionState : "";
          this._hub._yapi.imm_log("request @" + yreq._creat + " failed, websocket is down:" + wsState + dsState + cnState);
        }
        yreq.errorType = YAPI_IO_ERROR;
        yreq.errorMsg = "WebSocket not connected";
        try {
          yreq.acceptor(yreq);
        } catch (e) {
        }
        return;
      }
      if (isAsync) {
        yreq.asyncId = this.nextAsyncId++;
        if (this.nextAsyncId >= 127) {
          this.nextAsyncId = 48;
        }
      }
      let queue = this.tcpChan[tcpchan];
      if (queue) {
        while (queue.next) {
          queue = queue.next;
        }
        queue.next = yreq;
      } else {
        this.tcpChan[tcpchan] = yreq;
      }
      this.imm_sendPendingRequest(tcpchan);
    });
    return httpPromise;
  }
  imm_sendPendingRequest(tcpchan) {
    let yreq = this.tcpChan[tcpchan];
    while (yreq) {
      if (!this.websocket || this._hub.imm_isDisconnecting() || this._connectionState != 5) {
        if (this._hub._yapi._logLevel >= 4) {
          this._hub._yapi.imm_log("request @" + yreq._creat + " failed, websocket is down");
        }
        yreq.errorType = YAPI_IO_ERROR;
        yreq.errorMsg = "WebSocket not connected";
        if (yreq.acceptor) {
          try {
            yreq.acceptor(yreq);
          } catch (e) {
          }
        }
        yreq = yreq.next;
        continue;
      }
      let pendingCount = 1;
      for (let yr = yreq; yr.next; yr = yr.next) {
        pendingCount++;
      }
      if (!yreq.toBeSent) {
        if (yreq.asyncId == 0) {
          if (this._hub._yapi._logLevel >= 5) {
            this._hub._yapi.imm_log(pendingCount.toString() + " req pending, @" + yreq._creat + " not completed");
          }
          return;
        }
        yreq = yreq.next;
        continue;
      }
      let isAsync = yreq.asyncId != 0;
      let asyncCloseSet = false;
      let pos = yreq.sendPos;
      let end = yreq.toBeSent.length;
      let i, frame;
      if (end > 2108 && this._remoteVersion >= 2 && tcpchan == 0) {
        if (pos == 0) {
          end = 2108;
          this._lastUploadAckBytes[tcpchan] = 0;
          this._lastUploadAckTime[tcpchan] = 0;
          this._uploadRate[tcpchan] = this._tcpMaxWindowSize * 1e3 / this._tcpRoundTripTime >> 0;
        } else if (this._lastUploadAckTime[tcpchan] == 0) {
          if (yreq.sendTimeoutId)
            clearTimeout(yreq.sendTimeoutId);
          yreq.sendTimeoutId = setTimeout(() => {
            this.imm_sendPendingRequest(tcpchan);
          }, this._tcpRoundTripTime);
          return;
        } else {
          let bytesOnTheAir = pos - this._lastUploadAckBytes[tcpchan];
          let uploadRate = this._uploadRate[tcpchan];
          let timeOnTheAir = this._hub._yapi.GetTickCount() - this._lastUploadAckTime[tcpchan];
          let toBeSent = 2 * uploadRate + 1024 - bytesOnTheAir + uploadRate * timeOnTheAir / 1e3 >> 0;
          if (toBeSent + bytesOnTheAir > this._DEFAULT_TCP_MAX_WINDOW_SIZE) {
            toBeSent = this._DEFAULT_TCP_MAX_WINDOW_SIZE - bytesOnTheAir;
          }
          if (toBeSent < 64) {
            let waitTime = 1e3 * (128 - toBeSent) / uploadRate >> 0;
            if (waitTime < 2)
              waitTime = 2;
            if (yreq.sendTimeoutId)
              clearTimeout(yreq.sendTimeoutId);
            yreq.sendTimeoutId = setTimeout(() => {
              this.imm_sendPendingRequest(tcpchan);
            }, waitTime);
            return;
          }
          if (end > pos + toBeSent) {
            if (toBeSent > 124) {
              toBeSent = (toBeSent / 124 >> 0) * 124;
            }
            end = pos + toBeSent;
          }
        }
      }
      while (pos < end) {
        let framelen = 1 + end - pos;
        if (framelen > 125)
          framelen = 125;
        let datalen = framelen - 1;
        if (pos < 180 && pos + datalen >= 192) {
          datalen = 191 - pos;
          framelen = datalen + 1;
        }
        if (isAsync && pos + datalen == yreq.toBeSent.length && framelen < 125) {
          frame = new Uint8Array(framelen + 1);
          frame[0] = 8 * 9 + tcpchan;
          frame[framelen] = yreq.asyncId;
          asyncCloseSet = true;
        } else {
          frame = new Uint8Array(framelen);
          frame[0] = 8 * 1 + tcpchan;
        }
        frame.set(yreq.toBeSent.subarray(pos, pos + datalen), 1);
        pos += datalen;
        this.imm_webSocketSend(frame);
      }
      let sent = pos - yreq.sendPos;
      yreq.sendPos = pos;
      if (yreq.sendPos < yreq.toBeSent.length) {
        let waitTime = 1e3 * sent / this._uploadRate[tcpchan] >> 0;
        if (waitTime < 2)
          waitTime = 2;
        if (yreq.sendTimeoutId)
          clearTimeout(yreq.sendTimeoutId);
        yreq.sendTimeoutId = setTimeout(() => {
          this.imm_sendPendingRequest(tcpchan);
        }, waitTime);
        return;
      }
      if (isAsync && !asyncCloseSet) {
        frame = new Uint8Array(2);
        frame[0] = 8 * 9 + tcpchan;
        frame[1] = yreq.asyncId;
        this.imm_webSocketSend(frame);
      }
      yreq.toBeSent = null;
      if (isAsync && yreq.acceptor) {
        try {
          yreq.acceptor(yreq);
        } catch (e) {
          this._hub._yapi.imm_log("WS: async acceptor exception: ", e);
        }
      }
      let mstimeout = this._hub._yapi._networkTimeoutMs;
      if (yreq.devUrl) {
        if (yreq.devUrl.indexOf("/testcb.txt") >= 0) {
          mstimeout = this._YIO_1_MINUTE_TCP_TIMEOUT;
        } else if (yreq.devUrl.indexOf("/logger.json") >= 0) {
          mstimeout = this._YIO_1_MINUTE_TCP_TIMEOUT;
        } else if (yreq.devUrl.indexOf("/rxmsg.json") >= 0) {
          mstimeout = this._YIO_1_MINUTE_TCP_TIMEOUT;
        } else if (yreq.devUrl.indexOf("/rxdata.bin") >= 0) {
          mstimeout = this._YIO_1_MINUTE_TCP_TIMEOUT;
        } else if (yreq.devUrl.indexOf("/at.txt") >= 0) {
          mstimeout = this._YIO_1_MINUTE_TCP_TIMEOUT;
        } else if (yreq.devUrl.indexOf("/files.json") >= 0) {
          mstimeout = this._YIO_1_MINUTE_TCP_TIMEOUT;
        } else if (yreq.devUrl.indexOf("/upload.html") >= 0) {
          mstimeout = this._YIO_10_MINUTES_TCP_TIMEOUT;
        } else if (yreq.devUrl.indexOf("/flash.json") >= 0) {
          mstimeout = this._YIO_10_MINUTES_TCP_TIMEOUT;
        } else if (yreq.devUrl.indexOf("/Yvw4I.js") >= 0) {
          mstimeout = this._YIO_10_MINUTES_TCP_TIMEOUT;
        }
      }
      yreq.timeoutId = setTimeout((chan, yr) => {
        this.imm_abortRequest(chan, yr);
      }, mstimeout, tcpchan, yreq);
      yreq._sent = (Date.now() % 6e5).toString();
      if (this._hub._yapi._logLevel >= 5) {
        this._hub._yapi.imm_log("req @" + yreq._creat + " sent (1/" + pendingCount.toString() + ")" + (isAsync ? " async-" + yreq.asyncId + ", continue" : ", waiting for reply"));
      }
      if (!isAsync) {
        return;
      }
      yreq = yreq.next;
    }
  }
  imm_abortRequest(tcpchan, yreq) {
    if (!yreq.timeoutId)
      return;
    yreq.timeoutId = null;
    if (yreq.asyncId == 0) {
      let frame = new Uint8Array(1);
      frame[0] = 8 * 2 + tcpchan;
      this.imm_webSocketSend(frame);
      if (this._hub._yapi._logLevel >= 4) {
        let pendingCount = 1;
        for (let yr = yreq; yr.next; yr = yr.next) {
          pendingCount++;
        }
        this._hub._yapi.imm_log(pendingCount.toString() + " req pending, @" + yreq._creat + " is in timeout");
      }
      setTimeout((chan, yr) => {
        this._hub._yapi.imm_log("Dropping synchronous request after timeout: " + yr.devUrl);
        this.imm_forgetRequest(chan, yr);
      }, 5e3, tcpchan, yreq);
    }
    this.imm_asyncWebSocketError(YAPI_IO_ERROR, "Timeout on " + yreq.devUrl + " (tcpchan " + tcpchan + ")");
  }
  imm_forgetRequest(tcpchan, yreq) {
    let queue = this.tcpChan[tcpchan];
    if (queue == yreq) {
      this.tcpChan[tcpchan] = yreq.next;
      if (yreq.asyncId == 0) {
        yreq.errorType = YAPI_IO_ERROR;
        yreq.errorMsg = "Timeout on " + yreq.devUrl + " (tcpchan " + tcpchan + ")";
        if (yreq.acceptor) {
          try {
            yreq.acceptor(yreq);
          } catch (e) {
          }
        }
      }
      this.imm_sendPendingRequest(tcpchan);
    }
  }
  imm_dropAllPendingConnection() {
    if (this.fwd_connectionState != 1 && this.fwd_websocket) {
      this.fwd_connectionState = 1;
      this.fwd_websocket.close();
      this.fwd_websocket = null;
    }
    for (let tcpchan = 0; tcpchan < this.tcpChan.length; tcpchan++) {
      for (let yreq = this.tcpChan[tcpchan]; yreq; yreq = yreq.next) {
        this.tcpChan[tcpchan] = yreq.next;
        if (yreq.timeoutId) {
          clearTimeout(yreq.timeoutId);
          yreq.timeoutId = 0;
        }
        if (yreq.asyncId == 0) {
          if (this._hub._yapi._logLevel >= 4) {
            this._hub._yapi.imm_log("drop @" + yreq._creat + " (websocket down)");
          }
          yreq.errorType = YAPI_IO_ERROR;
          yreq.errorMsg = "Request " + yreq.devUrl + " dropped (websocket down)";
          if (yreq.acceptor) {
            try {
              yreq.acceptor(yreq);
            } catch (e) {
            }
          }
        }
      }
    }
  }
  async websocketJoin(ws, arr_credentials, close_callback) {
    if (this._connectionState != 5) {
      this.imm_asyncWebSocketError(YAPI_IO_ERROR, "Hub is disconnected, cannot join");
      return false;
    }
    this.fwd_websocket = ws;
    this.fwd_credentials = arr_credentials;
    this.fwd_closeCallback = close_callback;
    this.fwd_connectionState = 2;
    ws.onmessage = (evt) => {
      if (this.fwd_connectionState == 5) {
        if (this._connectionState == 5) {
          this.imm_webSocketSend(evt.data);
        } else {
          this._hub._yapi.imm_log("WS: drop packet from fwd API (state=" + this._connectionState + ")");
        }
      } else if (this.fwd_connectionState == 3) {
        this.imm_handleAPIAuthPkt(evt.data);
      } else {
        this._hub._yapi.imm_log("WS: drop packet from fwd API (fwd_state=" + this.fwd_connectionState + ")");
      }
    };
    ws.onclose = (evt) => {
      this.fwd_connectionState = 1;
      this.fwd_websocket = null;
      if (this.fwd_closeCallback) {
        this.fwd_closeCallback();
      }
    };
    return this.imm_sendAPIAnnouncePkt();
  }
  imm_sendAPIAnnouncePkt() {
    if (!this.fwd_websocket) {
      return false;
    }
    let frame = new Uint8Array(1 + this._USB_META_WS_ANNOUNCE_SIZE);
    let nonce = new Uint8Array(4);
    this.imm_getRandomValues(nonce);
    frame[0] = 5 << 3;
    frame[1] = 4;
    frame[2] = 2;
    frame[3] = this._tcpMaxWindowSize >> 4 & 255;
    frame[4] = this._tcpMaxWindowSize >> 12 & 255;
    for (let i = 0; i < 4; i++) {
      frame[5 + i] = nonce[i];
    }
    for (let i = 0; i < this._remoteSerial.length && i < 20; i++) {
      frame[9 + i] = this._remoteSerial.charCodeAt(i);
    }
    this.fwd_nonce = frame[5] + (frame[6] << 8) + (frame[7] << 16) + (frame[8] << 24);
    this.fwd_connectionState = 3;
    this.fwd_websocket.send(frame);
    return true;
  }
  imm_handleAPIAuthPkt(msg) {
    if (msg.length < 1 + this._USB_META_WS_AUTHENTICATION_SIZE || msg[0] != 5 << 3) {
      if (this._hub._yapi._logLevel >= 3) {
        this._hub._yapi.imm_log("bad-apiauth1\n");
      }
      this.fwd_connectionState = 0;
      return;
    }
    if (msg[1] != 5 || msg[2] > 2) {
      if (this._hub._yapi._logLevel >= 3) {
        this._hub._yapi.imm_log("bad-apiauth2\n");
      }
      this.fwd_connectionState = 0;
      return;
    }
    this._remoteVersion = msg[2];
    let flags = msg[3] + (msg[4] << 8);
    if ((flags & this._USB_META_WS_VALID_SHA1) == 0) {
      if (this._hub._yapi._logLevel >= 3) {
        this._hub._yapi.imm_log("bad-apiauth3\n");
      }
      this.fwd_connectionState = 0;
      return;
    }
    if (!this.fwd_websocket) {
      if (this._hub._yapi._logLevel >= 3) {
        this._hub._yapi.imm_log("no-fwd-ws\n");
      }
      this.fwd_connectionState = 0;
      return;
    }
    let credIdx, remote_sha1 = msg.subarray(9, 29);
    let credentials = this.fwd_credentials;
    for (credIdx = 0; credIdx < credentials.length; credIdx++) {
      let j, sha12 = this.imm_computeAuth(credentials[credIdx].user, credentials[credIdx].pass, this._remoteSerial, this.fwd_nonce);
      for (j = 0; j < sha12.length; j++) {
        if (sha12[j] != remote_sha1[j])
          break;
      }
      if (j >= sha12.length)
        break;
    }
    if (credIdx >= credentials.length) {
      if (this._hub._yapi._logLevel >= 3) {
        this._hub._yapi.imm_log("bad-apiauth4\n");
      }
      msg.fill(0, 3);
      this.fwd_websocket.send(msg);
      this.fwd_connectionState = 0;
      return;
    }
    msg[3] |= this._USB_META_WS_RW;
    this.fwd_nonce = msg[5] + (msg[6] << 8) + (msg[7] << 16) + (msg[8] << 24);
    let sha1 = this.imm_computeAuth(credentials[credIdx].user, credentials[credIdx].pass, this._remoteSerial, this.fwd_nonce);
    for (let i = 0; i < sha1.length; i++) {
      msg[9 + i] = sha1[i];
    }
    this.fwd_websocket.send(msg);
    this.fwd_connectionState = 5;
  }
  async detach(errType = YAPI.IO_ERROR, errMsg = "Hub has been forcibly detached") {
    let tcpchan_busy;
    let timeout = this._hub._yapi.GetTickCount() + 3e3;
    do {
      tcpchan_busy = false;
      for (let tcpchan = 0; tcpchan < 4; tcpchan++) {
        if (this.tcpChan[tcpchan] != null) {
          tcpchan_busy = true;
          break;
        }
      }
      if (tcpchan_busy) {
        await this._hub._yapi._microSleep_internal();
      }
    } while (tcpchan_busy && timeout > this._hub._yapi.GetTickCount());
    this._hub.imm_commonDisconnect("detach", errType, errMsg);
    this._hub.imm_disconnectNow();
  }
  imm_disconnectEngineNow(connID = "") {
    if (!this.websocket) {
      return;
    }
    this._connectionState = 1;
    let prevOpenID = connID ? connID : this._hub.imm_getCurrentConnID();
    let websocket = this.websocket;
    this._hub.imm_setCurrentConnID("");
    this.websocket = null;
    websocket.onclose = null;
    websocket.onerror = null;
    try {
      websocket.close();
    } catch (e) {
    }
    if (websocket.terminate) {
      setTimeout(() => {
        try {
          if (websocket.terminate) {
            websocket.terminate();
          }
        } catch (e) {
        }
      }, 900);
    }
    this.imm_dropAllPendingConnection();
    this._hub.imm_signalHubDisconnected(prevOpenID);
  }
  imm_isConnected() {
    if (this._connectionState != 5) {
      return false;
    }
    return super.imm_isConnected();
  }
};
var YHub = class {
  constructor(obj_yapi, hubref) {
    this._hubref = 0;
    this.TRYING = 1;
    this.CONNECTED = 2;
    this.RECONNECTING = 3;
    this.ABORTED = 4;
    this.UNREGISTERED = 5;
    this._ctx = obj_yapi;
    this._hubref = hubref;
  }
  async _getStrAttr_internal(attrName) {
    let hub = this._ctx.getGenHub(this._hubref);
    if (hub == null) {
      return "";
    }
    switch (attrName) {
      case "registeredUrl":
        return hub.imm_getOriginalURL();
      case "connectionUrl":
        return hub.imm_getRootUrl();
      case "serialNumber":
        return hub.imm_getSerialNumber();
      case "errorMessage":
        return hub.get_errorMessage();
      default:
        return "";
    }
  }
  async _getIntAttr_internal(attrName) {
    let hub = this._ctx.getGenHub(this._hubref);
    if (attrName == "isInUse") {
      return hub != null ? 1 : 0;
    }
    if (attrName == "connectionState") {
      if (hub == null) {
        return YHub.UNREGISTERED;
      }
      return hub.imm_getConnectionState();
    }
    if (hub == null) {
      return -1;
    }
    switch (attrName) {
      case "isOnline":
        return hub.imm_isOnline() ? 1 : 0;
      case "isReadOnly":
        return await hub.hasRwAccess() ? 0 : 1;
      case "networkTimeout":
        return hub.imm_getNetworkTimeout();
      case "errorType":
        return hub.get_errorType();
      default:
        return -1;
    }
  }
  async _setIntAttr_internal(attrName, value) {
    let hub = this._ctx.getGenHub(this._hubref);
    if (hub != null && attrName == "networkTimeout") {
      hub.imm_setNetworkTimeout(value);
    }
  }
  get_knownUrls_internal() {
    let hub = this._ctx.getGenHub(this._hubref);
    if (hub != null) {
      return hub.get_knownUrls();
    }
    return [];
  }
  async _getStrAttr(attrName) {
    return await this._getStrAttr_internal(attrName);
  }
  async _getIntAttr(attrName) {
    return await this._getIntAttr_internal(attrName);
  }
  async _setIntAttr(attrName, value) {
    return await this._setIntAttr_internal(attrName, value);
  }
  async get_registeredUrl() {
    return await this._getStrAttr("registeredUrl");
  }
  async get_knownUrls() {
    return await this.get_knownUrls_internal();
  }
  async get_connectionUrl() {
    return await this._getStrAttr("connectionUrl");
  }
  async get_connectionState() {
    return await this._getIntAttr("connectionState");
  }
  async get_serialNumber() {
    return await this._getStrAttr("serialNumber");
  }
  async isInUse() {
    return await this._getIntAttr("isInUse") > 0;
  }
  async isOnline() {
    return await this._getIntAttr("isOnline") > 0;
  }
  async isReadOnly() {
    return await this._getIntAttr("isReadOnly") > 0;
  }
  async set_networkTimeout(networkMsTimeout) {
    await this._setIntAttr("networkTimeout", networkMsTimeout);
  }
  async get_networkTimeout() {
    return await this._getIntAttr("networkTimeout");
  }
  async get_errorType() {
    return await this._getIntAttr("errorType");
  }
  async get_errorMessage() {
    return await this._getStrAttr("errorMessage");
  }
  async get_userData() {
    return this._userData;
  }
  async set_userData(data) {
    this._userData = data;
  }
  static FirstHubInUse() {
    return YAPI.nextHubInUseInternal(-1);
  }
  static FirstHubInUseInContext(yctx) {
    return yctx.nextHubInUseInternal(-1);
  }
  static async FindHubInUse(url) {
    return await YAPI.findYHubFromID(url);
  }
  static async FindHubInUseInContext(yctx, url) {
    return await yctx.findYHubFromID(url);
  }
  nextHubInUse() {
    return this._ctx.nextHubInUseInternal(this._hubref);
  }
};
YHub.TRYING = 1;
YHub.CONNECTED = 2;
YHub.RECONNECTING = 3;
YHub.ABORTED = 4;
YHub.UNREGISTERED = 5;
var YAPIContext = class {
  constructor(system_env) {
    this._detectType = Y_DETECT_NONE;
    this._knownHubsBySerial = {};
    this._knownHubsByUrl = {};
    this._connectedHubs = [];
    this._registeredHubs = [];
    this._trustedCertificate = [];
    this._networkSecurityOptions = 0;
    this._yhub_cache = {};
    this._ssdpManager = null;
    this._devs = {};
    this._snByUrl = {};
    this._snByName = {};
    this._fnByType = {};
    this._lastErrorType = YAPI_SUCCESS;
    this._lastErrorMsg = "no error";
    this._updateDevListStarted = 0;
    this._pendingCallbacks = [];
    this._logLevel = 4;
    this._logCallback = null;
    this._arrivalCallback = null;
    this._namechgCallback = null;
    this._removalCallback = null;
    this._hubDiscoveryCallback = null;
    this._forwardValues = 0;
    this._calibHandlers = [];
    this._ValueCallbackList = [];
    this._TimedReportCallbackList = [];
    this._beacons = {};
    this._isNodeJS = false;
    this._networkTimeoutMs = DEFAULT_NETWORK_TIMEOUT_MS;
    this._deviceListValidityMs = DEFAULT_DEVICE_LIST_VALIDITY_MS;
    this._crcTable = null;
    this.defaultEncoding = "binary";
    this.exceptionsDisabled = false;
    this.SUCCESS = 0;
    this.NOT_INITIALIZED = -1;
    this.INVALID_ARGUMENT = -2;
    this.NOT_SUPPORTED = -3;
    this.DEVICE_NOT_FOUND = -4;
    this.VERSION_MISMATCH = -5;
    this.DEVICE_BUSY = -6;
    this.TIMEOUT = -7;
    this.IO_ERROR = -8;
    this.NO_MORE_DATA = -9;
    this.EXHAUSTED = -10;
    this.DOUBLE_ACCES = -11;
    this.UNAUTHORIZED = -12;
    this.RTC_NOT_READY = -13;
    this.FILE_NOT_FOUND = -14;
    this.SSL_ERROR = -15;
    this.RFID_SOFT_ERROR = -16;
    this.RFID_HARD_ERROR = -17;
    this.BUFFER_TOO_SMALL = -18;
    this.DNS_ERROR = -19;
    this.SSL_UNK_CERT = -20;
    this.UNCONFIGURED = -21;
    this.NO_TRUSTED_CA_CHECK = 1;
    this.NO_EXPIRATION_CHECK = 2;
    this.NO_HOSTNAME_CHECK = 4;
    this.LEGACY = 8;
    this.defaultCacheValidity = 5;
    this.INVALID_INT = YAPI_INVALID_INT;
    this.INVALID_UINT = YAPI_INVALID_UINT;
    this.INVALID_LONG = YAPI_INVALID_LONG;
    this.INVALID_DOUBLE = YAPI_INVALID_DOUBLE;
    this.MIN_DOUBLE = YAPI_MIN_DOUBLE;
    this.MAX_DOUBLE = YAPI_MAX_DOUBLE;
    this.INVALID_STRING = YAPI_INVALID_STRING;
    this.HASH_BUF_SIZE = YOCTO_HASH_BUF_SIZE;
    this.DETECT_NONE = Y_DETECT_NONE;
    this.DETECT_USB = Y_DETECT_USB;
    this.DETECT_NET = Y_DETECT_NET;
    this.DETECT_ALL = Y_DETECT_ALL;
    this.YOCTO_DEFAULT_HTTP_PORT = 4444;
    this.YOCTO_DEFAULT_HTTPS_PORT = 4443;
    this.system_env = system_env || YAPI && YAPI.system_env || _UnspecifiedSystemEnv;
    this._isNodeJS = this.system_env.isNodeJS;
    this._uniqueID = String.fromCharCode(Math.random() * 79 + 48, Math.random() * 79 + 48, Math.random() * 79 + 48);
    this.imm_ResetToDefaults();
  }
  imm_ResetToDefaults() {
    this._detectType = this.DETECT_NONE;
    this._knownHubsBySerial = {};
    this._knownHubsByUrl = {};
    this._connectedHubs = [];
    this._registeredHubs = [];
    this._trustedCertificate = [];
    this._networkSecurityOptions = 0;
    this._devs = {};
    this._snByUrl = {};
    this._snByName = {};
    this._fnByType = {};
    this._fnByType.Module = new YFunctionType(this, "Module");
    this._lastErrorType = YAPI_SUCCESS;
    this._lastErrorMsg = "no error";
    this._updateDevListStarted = 0;
    this._pendingCallbacks = [];
    this._logLevel = 2;
    this._logCallback = null;
    this._arrivalCallback = null;
    this._namechgCallback = null;
    this._removalCallback = null;
    this._hubDiscoveryCallback = null;
    this._forwardValues = 0;
    this._ValueCallbackList = [];
    this._TimedReportCallbackList = [];
    this._beacons = {};
    this._calibHandlers = [];
    for (let i = 1; i <= 20; i++) {
      this.RegisterCalibrationHandler(i, this.LinearCalibrationHandler);
    }
    this.RegisterCalibrationHandler(YOCTO_CALIB_TYPE_OFS, this.LinearCalibrationHandler);
    this.exceptionsDisabled = false;
  }
  _throw(int_errType, str_errMsg, obj_retVal) {
    this._lastErrorType = int_errType;
    this._lastErrorMsg = str_errMsg;
    if (!this.exceptionsDisabled) {
      let exc = new YoctoError(str_errMsg);
      exc.errorType = int_errType;
      throw exc;
    }
    return obj_retVal;
  }
  imm_setErr(errmsg, int_errType, str_errMsg, obj_retVal) {
    if (errmsg) {
      errmsg.msg = str_errMsg;
    }
    this._lastErrorType = int_errType;
    this._lastErrorMsg = str_errMsg;
    return obj_retVal;
  }
  imm_setSystemEnv(env) {
    this.system_env = env;
    this._isNodeJS = env.isNodeJS;
  }
  imm_log(msg, ...moreArgs) {
    let now = new Date();
    let day = now.getFullYear().toString() + "-" + ("0" + (now.getMonth() + 1)).slice(-2) + "-" + ("0" + now.getDate()).slice(-2);
    let time = ("0" + now.getHours().toString()).slice(-2) + ":" + ("0" + now.getMinutes()).slice(-2) + ":" + ("0" + now.getSeconds()).slice(-2);
    let prefix = day + " " + time + " [" + this._uniqueID + "] ";
    let isError = false;
    if (moreArgs.length > 0) {
      if (moreArgs[0].constructor && /Error/i.test(moreArgs[0].constructor.name)) {
        isError = true;
      }
    }
    if (this._logCallback) {
      try {
        if (moreArgs.length > 0) {
          if (moreArgs[0].message) {
            msg += moreArgs[0].message;
          } else {
            msg += moreArgs[0].toString();
          }
        }
        this._logCallback(prefix + msg);
      } catch (e) {
        console.error(prefix + "Exception in custom log callback: ", e);
        console.log("... while trying to log:");
        if (isError) {
          console.error(prefix + msg, ...moreArgs);
        } else {
          console.log(prefix + msg, ...moreArgs);
        }
      }
    } else {
      if (isError) {
        console.error(prefix + msg, ...moreArgs);
      } else {
        console.log(prefix + msg, ...moreArgs);
      }
    }
  }
  async RegisterLogFunction(logfun) {
    this._logCallback = logfun;
    return YAPI_SUCCESS;
  }
  imm_getHub(obj_urlInfo) {
    let hub = this._knownHubsByUrl[obj_urlInfo.imm_getRootUrl()];
    if (!hub) {
      for (const url in this._knownHubsByUrl) {
        if (this._knownHubsByUrl[url].imm_getOriginalURL() == obj_urlInfo.imm_getOriginalURL()) {
          return this._knownHubsByUrl[url];
        }
      }
    }
    return hub;
  }
  imm_getPrimaryHub(hub) {
    let primaryHub = this._knownHubsBySerial[hub.imm_getSerialNumber()];
    if (!primaryHub || primaryHub === hub) {
      this._knownHubsBySerial[hub.imm_getSerialNumber()] = hub;
      this._knownHubsByUrl[hub.imm_getRootUrl()] = hub;
      return hub;
    }
    if (primaryHub.urlInfo.imm_useSecureSocket() || !hub.urlInfo.imm_useSecureSocket()) {
      if (primaryHub.imm_getcurrentState() >= hub.imm_getcurrentState()) {
        primaryHub.imm_inheritFrom(hub);
        this.imm_updateRegisteredHubs(hub, false);
        return primaryHub;
      }
    }
    this._knownHubsBySerial[hub.imm_getSerialNumber()] = hub;
    hub.imm_inheritFrom(primaryHub);
    this.imm_updateRegisteredHubs(primaryHub, false);
    return hub;
  }
  async _addConnectedHub(newhub) {
    let serial = this._snByUrl[newhub.imm_getRootUrl()];
    if (!serial) {
      let newdev = new YDevice(this, newhub.imm_getRootUrl(), null, null);
      await newdev.refresh();
    }
    let hubFound = false;
    for (let i = 0; i < this._connectedHubs.length; i++) {
      let url = this._connectedHubs[i].imm_getRootUrl();
      if (newhub.imm_getRootUrl() == url) {
        hubFound = true;
        break;
      }
    }
    if (!hubFound) {
      this._connectedHubs.push(newhub);
    }
  }
  imm_isActiveHub(hubSerial) {
    for (let i = 0; i < this._connectedHubs.length; i++) {
      let hubSerials = this._connectedHubs[i].serialByYdx;
      if (hubSerials && hubSerials[0] == hubSerial) {
        return true;
      }
    }
    return false;
  }
  imm_dropConnectedHub(hub) {
    let idx = this._connectedHubs.indexOf(hub);
    if (idx < 0) {
      return;
    }
    for (let j = 0; j < hub.serialByYdx.length; j++) {
      let serial = hub.serialByYdx[j];
      if (serial && this._devs[serial]) {
        if (this._removalCallback) {
          let module = YModule.FindModuleInContext(this, serial + ".module");
          this._pendingCallbacks.push({event: "-", serial, module});
        }
        try {
          this.imm_forgetDevice(this._devs[serial]);
        } catch (e) {
        }
      }
    }
    idx = this._connectedHubs.indexOf(hub);
    if (idx >= 0) {
      this._connectedHubs.splice(idx, 1);
    }
    this.imm_updateRegisteredHubs(hub, false);
  }
  async _ensureUpdateDeviceListNotRunning() {
    while (this._updateDevListStarted && this.GetTickCount() - this._updateDevListStarted < 30 * 1e3) {
      await this.Sleep(25);
    }
  }
  async _updateDeviceList_internal(bool_forceupdate, bool_invokecallbacks) {
    if (this._updateDevListStarted && this.GetTickCount() - this._updateDevListStarted < 30 * 1e3) {
      return {
        errorType: YAPI_SUCCESS,
        errorMsg: "no error"
      };
    }
    for (let i = 0; i < this._connectedHubs.length; i++) {
      if (this._connectedHubs[i].imm_isFirstArrivalCallback() && bool_invokecallbacks && this._arrivalCallback) {
        bool_forceupdate = true;
        break;
      }
    }
    if (bool_forceupdate) {
      for (let i = 0; i < this._connectedHubs.length; i++) {
        this._connectedHubs[i].imm_forceUpdate();
      }
    }
    try {
      this._updateDevListStarted = this.GetTickCount();
      let hubs = [];
      for (let i = 0; i < this._connectedHubs.length; i++) {
        let hub = this._connectedHubs[i];
        let rootUrl = hub.imm_getRootUrl();
        let hubDev = this.imm_getDevice(rootUrl);
        if (!hubDev) {
          continue;
        }
        if (hub.imm_getcurrentState() < 1) {
          if (this._logLevel >= 4) {
            this.imm_log("Skip updateDeviceList for hub " + hub.urlInfo.imm_getHost() + ", currently offline");
          }
          continue;
        }
        if (hub.devListExpires <= this.GetTickCount()) {
          hub._missing = {};
          hubs.push(hub);
        }
      }
      for (let serial in this._devs) {
        let rooturl = this._devs[serial].imm_getRootUrl();
        for (let i = 0; i < hubs.length; i++) {
          let huburl = hubs[i].imm_getRootUrl();
          if (rooturl.substr(0, huburl.length) == huburl) {
            hubs[i]._missing[serial] = true;
          }
        }
      }
      let update_promises = [];
      for (let i = 0; i < hubs.length; i++) {
        let prom = hubs[i].hubUpdateDeviceList();
        update_promises.push(prom);
      }
      let newDeviceCounts = await Promise.all(update_promises);
      let newDeviceArrived = false;
      for (let res of newDeviceCounts) {
        newDeviceArrived = newDeviceArrived || res > 0;
      }
      if (bool_invokecallbacks) {
        let nbEvents = this._pendingCallbacks.length;
        for (let i = 0; i < nbEvents; i++) {
          let evt = this._pendingCallbacks[i];
          switch (evt.event) {
            case "+":
              if (this._logLevel >= 3) {
                this.imm_log("Device " + evt.serial + " plugged");
              }
              if (this._arrivalCallback) {
                try {
                  await evt.module.load(this.defaultCacheValidity);
                  await this._arrivalCallback(evt.module);
                } catch (e) {
                  this.imm_log("Exception in device arrival callback:", e);
                }
              }
              break;
            case "/":
              if (this._namechgCallback) {
                try {
                  await this._namechgCallback(evt.module);
                } catch (e) {
                  this.imm_log("Exception in device change callback:", e);
                }
              }
              break;
            case "-":
              if (this._logLevel >= 3) {
                this.imm_log("Device " + evt.serial + " unplugged");
              }
              if (this._removalCallback) {
                try {
                  await this._removalCallback(evt.module);
                } catch (e) {
                  this.imm_log("Exception in device removal callback:", e);
                }
              }
              break;
          }
        }
        this._pendingCallbacks = this._pendingCallbacks.slice(nbEvents);
      }
      if (newDeviceArrived) {
        for (let fun of this._ValueCallbackList) {
          if (!fun._hwId) {
            fun.isOnline();
          }
        }
        for (let fun of this._TimedReportCallbackList) {
          if (!fun._hwId) {
            fun.isOnline();
          }
        }
      }
    } finally {
      this._updateDevListStarted = 0;
    }
    return {
      errorType: YAPI_SUCCESS,
      errorMsg: "no error"
    };
  }
  async updateDeviceList_process(hub, hubDev, whitePages, yellowPages) {
    let newDevices = 0;
    let refresh = {};
    let serial = null;
    for (let classname in yellowPages) {
      let obj_yprecs = yellowPages[classname];
      let ftype = this._fnByType[classname];
      if (ftype == void 0) {
        ftype = new YFunctionType(this, classname);
        this._fnByType[classname] = ftype;
      }
      for (let i = 0; i < obj_yprecs.length; i++) {
        let yprec = obj_yprecs[i];
        let hwid = yprec.hardwareId;
        let basetype = yprec.baseType;
        if (ftype.imm_reindexFunction(hwid, yprec["logicalName"], yprec["advertisedValue"], basetype)) {
          serial = hwid.substr(0, hwid.indexOf("."));
          refresh[serial] = true;
        }
      }
    }
    for (let i = 0; i < whitePages.length; i++) {
      let devinfo = whitePages[i];
      serial = devinfo.serialNumber;
      let devydx = devinfo.index;
      let rooturl = devinfo.networkUrl.slice(0, -3);
      if (rooturl.charAt(0) == "/")
        rooturl = hubDev.imm_getRootUrl() + rooturl.substr(1);
      let currdev = this._devs[serial];
      if (this._logLevel >= 5) {
        this.imm_log("Device " + serial + " present, currdev " + (currdev ? "" : "NOT ") + "set" + (hub.imm_isFirstArrivalCallback() ? ", firstArrival" : ""));
      }
      if (currdev && hub.imm_isFirstArrivalCallback()) {
        newDevices++;
        if (this._arrivalCallback) {
          let module = YModule.FindModuleInContext(this, serial + ".module");
          this._pendingCallbacks.push({event: "+", serial, module});
        }
      }
      hub.serialByYdx[devydx] = serial;
      if (!currdev) {
        new YDevice(this, rooturl, devinfo, yellowPages);
        newDevices++;
        if (this._arrivalCallback) {
          let module = YModule.FindModuleInContext(this, serial + ".module");
          this._pendingCallbacks.push({event: "+", serial, module});
        }
      } else if (currdev.imm_getLogicalName() != devinfo["logicalName"]) {
        await currdev.refresh();
        if (this._namechgCallback) {
          let module = YModule.FindModuleInContext(this, serial + ".module");
          this._pendingCallbacks.push({event: "/", serial, module});
        }
      } else if (refresh[serial] || currdev.imm_getRootUrl() != rooturl || currdev.imm_getBeacon() != devinfo["beacon"]) {
        await currdev.refresh();
      }
      hub._missing[serial] = false;
    }
    if (this._arrivalCallback && hub.imm_isFirstArrivalCallback()) {
      hub.imm_setFirstArrivalCallback(false);
    }
    for (serial in hub._missing) {
      if (hub._missing[serial] && this._devs[serial]) {
        if (this._removalCallback) {
          let module = YModule.FindModuleInContext(this, serial + ".module");
          this._pendingCallbacks.push({event: "-", serial, module});
        }
        this.imm_forgetDevice(this._devs[serial]);
      }
    }
    return newDevices;
  }
  async parseEvents(hub, str_lines) {
    if (hub.imm_isDisconnecting()) {
      return;
    }
    hub.isNotifWorking = true;
    if (hub.timeoutId) {
      clearTimeout(hub.timeoutId);
    }
    hub.timeoutId = setTimeout(() => {
      if (!hub.imm_isForwarded()) {
        this.imm_log("Closing stalled connection after " + hub.imm_getNetworkTimeout() / 1e3 + "s");
        hub.imm_disconnectNow();
      }
    }, hub.imm_getNetworkTimeout());
    let rows = (hub.notifCarryOver + str_lines).split("\n");
    let nrows = rows.length;
    let value;
    if (str_lines.substr(-1) != "\n") {
      hub.notifCarryOver = rows[--nrows];
    } else {
      nrows--;
      hub.notifCarryOver = "";
    }
    for (let idx = 0; idx < nrows; idx++) {
      let ev = rows[idx];
      if (ev.length == 0)
        continue;
      let firstCode = ev.charAt(0);
      if (ev.length >= 3 && firstCode >= NOTIFY_NETPKT_CONFCHGYDX && firstCode <= NOTIFY_NETPKT_TIMEAVGYDX) {
        hub.retryDelay = 15;
        if (hub.notifPos >= 0)
          hub.notifPos += ev.length + 1;
        let devydx = ev.charCodeAt(1) - 65;
        let funydx = ev.charCodeAt(2) - 48;
        if (funydx >= 64) {
          funydx -= 64;
          devydx += 128;
        }
        let serial = hub.serialByYdx[devydx];
        if (serial && this._devs[serial]) {
          let funcid = funydx == 15 ? "time" : this._devs[serial].imm_functionIdByFunYdx(funydx);
          if (funcid != "") {
            let dev;
            value = ev.slice(3);
            switch (firstCode) {
              case NOTIFY_NETPKT_FUNCVALYDX:
                if (value != "")
                  value = value.split("\0")[0];
                await this.setFunctionValue(serial + "." + funcid, value);
                break;
              case NOTIFY_NETPKT_DEVLOGYDX:
                dev = this._devs[serial];
                if (dev != null) {
                  dev.imm_triggerLogPull();
                }
                break;
              case NOTIFY_NETPKT_CONFCHGYDX:
                await this.setConfChange(serial);
                break;
              case NOTIFY_NETPKT_TIMEVALYDX:
              case NOTIFY_NETPKT_TIMEAVGYDX:
              case NOTIFY_NETPKT_TIMEV2YDX:
                let pos, arr = [firstCode == "x" ? 0 : firstCode == "z" ? 1 : 2];
                for (pos = 0; pos < value.length; pos += 2) {
                  arr.push(parseInt(value.substr(pos, 2), 16));
                }
                dev = this._devs[serial];
                if (funcid == "time") {
                  let time = arr[1] + 256 * arr[2] + 65536 * arr[3] + 16777216 * arr[4];
                  let ms = arr[5] * 4;
                  let duration;
                  if (arr.length >= 7) {
                    ms += arr[6] >> 6;
                    let duration_ms = arr[7];
                    duration_ms += (arr[6] & 15) * 256;
                    if (arr[6] & 16) {
                      duration = duration_ms;
                    } else {
                      duration = duration_ms / 1e3;
                    }
                  } else {
                    duration = 0;
                  }
                  dev.imm_setTimeRef(time + ms / 1e3, duration);
                } else {
                  await this.setTimedReport(serial + "." + funcid, dev.imm_getLastTimeRef(), dev.imm_getLastDuration(), arr);
                }
                break;
              case NOTIFY_NETPKT_FUNCV2YDX:
                let rawval = this.imm_decodeNetFuncValV2(value);
                if (rawval != null) {
                  let decodedval = this.imm_decodePubVal(rawval[0], rawval, 1, 6);
                  await this.setFunctionValue(serial + "." + funcid, decodedval);
                }
                break;
              case NOTIFY_NETPKT_FLUSHV2YDX:
              default:
                break;
            }
          }
        }
      } else if (ev.length > 5 && ev.substr(0, 4) == "YN01") {
        hub.retryDelay = 15;
        if (hub.notifPos >= 0)
          hub.notifPos += ev.length + 1;
        let notype = ev.substr(4, 1);
        let parts;
        if (notype == "@") {
          hub.notifPos = parseInt(ev.slice(5));
        } else {
          switch (parseInt(notype)) {
            case 0:
              parts = ev.slice(5).split(",");
              if (parts.length > 2) {
                let int_beacon = parseInt(parts[2]);
                await this.setBeaconChange(parts[0], int_beacon);
              }
            case 2:
            case 4:
            case 8:
              hub.devListExpires = 0;
              break;
            case 5:
              parts = ev.slice(5).split(",");
              if (parts.length > 2) {
                value = parts[2].split("\0");
                await this.setFunctionValue(parts[0] + "." + parts[1], value[0]);
              }
              break;
          }
        }
      } else {
        hub.devListExpires = 0;
        this.imm_log("Bad event on received from server:", ev);
        hub.notifPos = -1;
      }
    }
    if (this._forwardValues > 0) {
      await this.HandleEvents(new YErrorMsg());
    }
  }
  imm_decodeNetFuncValV2(p) {
    let p_ofs = 0;
    let ch = p.charCodeAt(p_ofs) & 255;
    let len = 0;
    let funcVal = [0, 0, 0, 0, 0, 0, 0];
    if (ch < 32 || ch > 32 + 127) {
      return null;
    }
    ch -= 32;
    funcVal[0] = (ch & 64) != 0 ? NOTIFY_V2_6RAWBYTES : NOTIFY_V2_TYPEDDATA;
    ch &= 63;
    while (len < YOCTO_PUBVAL_SIZE) {
      p_ofs++;
      if (p_ofs >= p.length) {
        break;
      }
      let newCh = p.charCodeAt(p_ofs) & 255;
      if (newCh == NOTIFY_NETPKT_STOP) {
        break;
      }
      if (newCh < 32 || newCh > 32 + 127) {
        return null;
      }
      newCh -= 32;
      ch = (ch << 7) + newCh;
      funcVal[len + 1] = ch >>> 5 - len & 255;
      len++;
    }
    return funcVal;
  }
  imm_decodePubVal(int_typeV2, arr_funcval, int_ofs, int_funcvalen) {
    let buffer = "";
    let endp;
    if (int_typeV2 == NOTIFY_V2_6RAWBYTES || int_typeV2 == NOTIFY_V2_TYPEDDATA) {
      let funcValType;
      if (int_typeV2 == NOTIFY_V2_6RAWBYTES) {
        funcValType = PUBVAL_6RAWBYTES;
      } else {
        funcValType = arr_funcval[int_ofs++];
      }
      switch (funcValType) {
        case PUBVAL_LEGACY:
          break;
        case PUBVAL_1RAWBYTE:
        case PUBVAL_2RAWBYTES:
        case PUBVAL_3RAWBYTES:
        case PUBVAL_4RAWBYTES:
        case PUBVAL_5RAWBYTES:
        case PUBVAL_6RAWBYTES:
          for (let i = 0; i < funcValType; i++) {
            let c = arr_funcval[int_ofs++];
            let b = c >>> 4;
            buffer += b.toString(16);
            b = c & 15;
            buffer += b.toString(16);
          }
          return buffer;
        case PUBVAL_C_LONG:
        case PUBVAL_YOCTO_FLOAT_E3:
          let numVal = arr_funcval[int_ofs++];
          numVal += arr_funcval[int_ofs++] << 8;
          numVal += arr_funcval[int_ofs++] << 16;
          numVal += arr_funcval[int_ofs++] << 24;
          if (funcValType == PUBVAL_C_LONG) {
            return String(Math.round(numVal));
          } else {
            buffer = String(Math.round(numVal * 1e3) / 1e6);
            endp = buffer.length;
            while (endp > 0 && buffer[endp - 1] == "0") {
              --endp;
            }
            if (endp > 0 && buffer[endp - 1] == ".") {
              --endp;
              buffer = buffer.substr(0, endp);
            }
            return buffer;
          }
        case PUBVAL_C_FLOAT:
          let v = arr_funcval[int_ofs++];
          v += arr_funcval[int_ofs++] << 8;
          v += arr_funcval[int_ofs++] << 16;
          v += arr_funcval[int_ofs++] << 24;
          let fraction = (v & (1 << 23) - 1) + (1 << 23) * (v >>> 31 | 1);
          let exp = (v >>> 23 & 255) - 127;
          let floatVal = fraction * Math.pow(2, exp - 23);
          buffer = String(Math.round(floatVal * 1e6) / 1e6);
          endp = buffer.length;
          while (endp > 0 && buffer[endp - 1] == "0") {
            --endp;
          }
          if (endp > 0 && buffer[endp - 1] == ".") {
            --endp;
            buffer = buffer.substr(0, endp);
          }
          return buffer;
        default:
          return "?";
      }
      let len = 0;
      buffer = "";
      while (len < YOCTO_PUBVAL_SIZE && len < int_funcvalen) {
        if (arr_funcval[len] == 0) {
          break;
        }
        buffer += String.fromCharCode(arr_funcval[len]);
        len++;
      }
    }
    return buffer;
  }
  imm_decExp(int_pow) {
    const arr = [
      1e-6,
      1e-5,
      1e-4,
      1e-3,
      0.01,
      0.1,
      1,
      10,
      100,
      1e3,
      1e4,
      1e5,
      1e6,
      1e7,
      1e8,
      1e9
    ];
    return arr[int_pow];
  }
  imm_decimalToDouble(val) {
    let negate = false;
    let res;
    let mantis = val & 2047;
    if (mantis == 0)
      return 0;
    if (val > 32767) {
      negate = true;
      val = 65536 - val;
    } else if (val < 0) {
      negate = true;
      val = -val;
    }
    let decexp = this.imm_decExp(val >>> 11);
    if (decexp >= 1) {
      res = mantis * decexp;
    } else {
      res = mantis / Math.round(1 / decexp);
    }
    return negate ? -res : res;
  }
  imm_doubleToDecimal(val) {
    let negate = false;
    let comp, mant;
    let decpow;
    let res;
    if (val == 0) {
      return 0;
    }
    if (val < 0) {
      negate = true;
      val = -val;
    }
    comp = val / 1999;
    decpow = 0;
    while (comp > this.imm_decExp(decpow) && decpow < 15) {
      decpow++;
    }
    mant = val / this.imm_decExp(decpow);
    if (decpow == 15 && mant > 2047) {
      res = (15 << 11) + 2047;
    } else {
      res = (decpow << 11) + Math.round(mant);
    }
    return negate ? -res : res;
  }
  imm_getCalibrationHandler(calibType) {
    return this._calibHandlers[calibType];
  }
  imm_decodeWords(data) {
    let udata = [];
    for (let i = 0; i < data.length; ) {
      let c = data[i];
      let val = 0;
      if (c == "*") {
        i++;
      } else if (c == "X") {
        val = 65535;
        i++;
      } else if (c == "Y") {
        val = 32767;
        i++;
      } else if (c >= "a") {
        let srcpos = udata.length - 1 - (data.charCodeAt(i++) - 97);
        if (srcpos >= 0) {
          val = udata[srcpos];
        }
      } else {
        if (i + 3 > data.length) {
          return udata;
        }
        val = data.charCodeAt(i++) - 48;
        val += data.charCodeAt(i++) - 48 << 5;
        let lastcode = data.charCodeAt(i++);
        if (lastcode == 122)
          lastcode = 92;
        val += lastcode - 48 << 10;
      }
      udata.push(val);
    }
    return udata;
  }
  imm_decodeFloats(data) {
    let idata = [];
    let p = 0;
    let datalen = data.length;
    while (p < datalen) {
      let val = 0;
      let sign = 1;
      let dec = 0;
      let decInc = 0;
      let c = data[p++];
      while (c != "-" && (c < "0" || c > "9")) {
        if (p >= datalen) {
          return idata;
        }
        c = data[p++];
      }
      if (c == "-") {
        if (p >= datalen) {
          return idata;
        }
        sign = -sign;
        c = data[p++];
      }
      while (c >= "0" && c <= "9" || c == ".") {
        if (c == ".") {
          decInc = 1;
        } else if (dec < 3) {
          val = val * 10 + (c.charCodeAt(0) - 48);
          dec += decInc;
        }
        if (p < datalen) {
          c = data[p++];
        } else {
          c = "\0";
        }
      }
      if (dec < 3) {
        if (dec == 0) {
          val *= 1e3;
        } else if (dec == 1) {
          val *= 100;
        } else {
          val *= 10;
        }
      }
      idata.push(sign * val);
    }
    return idata;
  }
  static imm_atoi(str_data) {
    let num = parseInt(str_data);
    if (isNaN(num)) {
      return 0;
    }
    return Math.floor(num);
  }
  static imm_atof(str_data) {
    let num = parseFloat(str_data);
    if (isNaN(num)) {
      return 0;
    }
    return num;
  }
  imm_bin2str(bin_data) {
    let len = bin_data.length;
    let res = "";
    for (let i = 0; i < len; i += 20) {
      let subdata = bin_data.subarray(i, Math.min(i + 20, len));
      res += String.fromCharCode.apply(null, Array.from(subdata));
    }
    return res;
  }
  imm_str2bin(str_data) {
    let len = str_data.length;
    let res = new Uint8Array(len);
    for (let i = 0; i < len; i++) {
      res[i] = str_data.charCodeAt(i);
    }
    return res;
  }
  imm_bin2hexstr(bin_data) {
    let len = bin_data.length;
    let res = "";
    for (let i = 0; i < len; i++) {
      let n = bin_data[i].toString(16);
      res += n.length < 2 ? "0" + n : n;
    }
    return res.toUpperCase();
  }
  imm_bincrc(bin_data, ofs, size) {
    let table = this._crcTable;
    if (!table) {
      table = new Int32Array(256);
      for (let i = 0; i < 256; i++) {
        let crc2 = i;
        for (let bit = 0; bit < 8; bit++) {
          crc2 = crc2 & 1 ? 3988292384 ^ crc2 >>> 1 : crc2 >>> 1;
        }
        table[i] = crc2;
      }
      this._crcTable = table;
    }
    let end = ofs + size;
    let crc = -1;
    while (ofs < end) {
      crc = crc >>> 8 ^ table[(crc ^ bin_data[ofs]) & 255];
      ofs++;
    }
    return crc ^ -1;
  }
  imm_hexstr2bin(str_data) {
    let len = str_data.length >>> 1;
    let res = new Uint8Array(len);
    for (let i = 0; i < len; i++) {
      res[i] = parseInt(str_data.substr(2 * i, 2), 16);
    }
    return res;
  }
  imm_getDevice(str_device) {
    let dev = null;
    let serial;
    if (str_device.substr(0, 7) == "http://" || str_device.substr(0, 5) == "ws://" || str_device.substr(0, 8) == "https://" || str_device.substr(0, 6) == "wss://") {
      serial = this._snByUrl[str_device];
      if (serial != void 0)
        dev = this._devs[serial];
    } else {
      if (this._devs[str_device]) {
        dev = this._devs[str_device];
      } else {
        serial = this._snByName[str_device];
        if (serial) {
          dev = this._devs[serial];
        }
      }
    }
    return dev;
  }
  async _UpdateValueCallbackList(obj_func, bool_add) {
    let index = this._ValueCallbackList.indexOf(obj_func);
    if (bool_add) {
      await obj_func.isOnline();
      if (index < 0) {
        this._ValueCallbackList.push(obj_func);
      }
    } else if (index >= 0) {
      this._ValueCallbackList.splice(index, 1);
    }
  }
  async _UpdateTimedReportCallbackList(obj_func, bool_add) {
    let index = this._TimedReportCallbackList.indexOf(obj_func);
    if (bool_add) {
      await obj_func.isOnline();
      if (index < 0) {
        this._TimedReportCallbackList.push(obj_func);
      }
    } else if (index >= 0) {
      this._TimedReportCallbackList.splice(index, 1);
    }
  }
  imm_functionClass(str_funcid) {
    let dotpos = str_funcid.indexOf(".");
    if (dotpos >= 0)
      str_funcid = str_funcid.substr(dotpos + 1);
    let classlen = str_funcid.length;
    while (str_funcid.substr(classlen - 1, 1) <= "9") {
      classlen--;
    }
    let classname = str_funcid.substr(0, 1).toUpperCase() + str_funcid.substr(1, classlen - 1);
    if (this._fnByType[classname] == void 0) {
      this._fnByType[classname] = new YFunctionType(this, classname);
    }
    return classname;
  }
  imm_reindexDevice(obj_dev) {
    let rootUrl = obj_dev.imm_getRootUrl();
    let serial = obj_dev.imm_getSerialNumber();
    let lname = obj_dev.imm_getLogicalName();
    this._devs[serial] = obj_dev;
    this._snByUrl[rootUrl] = serial;
    if (lname != "")
      this._snByName[lname] = serial;
    this._fnByType["Module"].imm_reindexFunction(serial + ".module", lname, null, null);
    let i, count = obj_dev.imm_functionCount();
    for (i = 0; i < count; i++) {
      let funcid = obj_dev.imm_functionId(i);
      if (funcid != "") {
        let funcname = obj_dev.imm_functionName(i);
        let classname = this.imm_functionClass(funcid);
        this._fnByType[classname].imm_reindexFunction(serial + "." + funcid, funcname, null, null);
      }
    }
  }
  imm_forgetDevice(obj_dev) {
    let rootUrl = obj_dev.imm_getRootUrl();
    let serial = obj_dev.imm_getSerialNumber();
    let lname = obj_dev.imm_getLogicalName();
    delete this._devs[serial];
    delete this._snByUrl[rootUrl];
    if (this._snByName[lname] == serial) {
      delete this._snByName[lname];
    }
    this._fnByType["Module"].imm_forgetFunction(serial + ".module");
    let i, count = obj_dev.imm_functionCount();
    for (i = 0; i < count; i++) {
      let funcid = obj_dev.imm_functionId(i);
      if (funcid != "") {
        let classname = this.imm_functionClass(funcid);
        this._fnByType[classname].imm_forgetFunction(serial + "." + funcid);
      }
    }
  }
  imm_resolveFunction(str_className, str_func) {
    if (Y_BASETYPES[str_className] == void 0) {
      if (this._fnByType[str_className] == void 0) {
        this._fnByType[str_className] = new YFunctionType(this, str_className);
      }
      return this._fnByType[str_className].imm_resolve(str_func);
    }
    let baseType = Y_BASETYPES[str_className];
    let res;
    for (str_className in this._fnByType) {
      if (this._fnByType[str_className].imm_matchBaseType(baseType)) {
        res = this._fnByType[str_className].imm_resolve(str_func);
        if (res.errorType == YAPI_SUCCESS)
          return res;
      }
    }
    return {
      errorType: YAPI_DEVICE_NOT_FOUND,
      errorMsg: "No " + str_className + " [" + str_func + "] found (old firmware?)"
    };
  }
  imm_getFriendlyNameFunction(str_className, str_func) {
    if (Y_BASETYPES[str_className] == void 0) {
      if (this._fnByType[str_className] == void 0) {
        this._fnByType[str_className] = new YFunctionType(this, str_className);
      }
      return this._fnByType[str_className].imm_getFriendlyName(str_func);
    }
    let baseType = Y_BASETYPES[str_className];
    let res;
    for (str_className in this._fnByType) {
      if (this._fnByType[str_className].imm_matchBaseType(baseType)) {
        res = this._fnByType[str_className].imm_getFriendlyName(str_func);
        if (res.errorType == YAPI_SUCCESS)
          return res;
      }
    }
    return {
      errorType: YAPI_DEVICE_NOT_FOUND,
      errorMsg: "No " + str_className + " [" + str_func + "] found (old firmware?)"
    };
  }
  imm_setFunction(str_className, str_func, obj_func) {
    if (this._fnByType[str_className] == void 0) {
      this._fnByType[str_className] = new YFunctionType(this, str_className);
    }
    this._fnByType[str_className].imm_setFunction(str_func, obj_func);
  }
  imm_getFunction(str_className, str_func) {
    if (this._fnByType[str_className] == void 0) {
      this._fnByType[str_className] = new YFunctionType(this, str_className);
    }
    return this._fnByType[str_className].imm_getFunction(str_func);
  }
  async setFunctionValue(str_hwid, str_pubval) {
    let classname = this.imm_functionClass(str_hwid);
    if (this._fnByType[classname].imm_setFunctionValue(str_hwid, str_pubval)) {
      let receivers = this._ValueCallbackList;
      for (let i = 0; i < receivers.length; i++) {
        let fun = receivers[i];
        if (!fun._hwId)
          continue;
        if (fun._hwId == str_hwid) {
          await fun._invokeValueCallback(str_pubval);
        }
      }
    }
  }
  async setTimedReport(str_hwid, float_timestamp, float_duration, arr_report) {
    let classname = this.imm_functionClass(str_hwid);
    let receivers = this._TimedReportCallbackList;
    for (let i = 0; i < receivers.length; i++) {
      let fun = receivers[i];
      if (!fun._hwId)
        continue;
      if (fun._hwId == str_hwid) {
        let dev = this.imm_getDevice(fun._serial);
        if (dev) {
          let sensor = fun;
          let report = await sensor._decodeTimedReport(float_timestamp, float_duration, arr_report);
          await sensor._invokeTimedReportCallback(report);
        }
      }
    }
  }
  async setConfChange(str_serial) {
    let module = YModule.FindModuleInContext(this, str_serial + ".module");
    await module._invokeConfigChangeCallback();
  }
  async setBeaconChange(str_serial, int_beacon) {
    if (this._beacons[str_serial] === void 0 || this._beacons[str_serial] != int_beacon) {
      this._beacons[str_serial] = int_beacon;
      let dev = this.imm_getDevice(str_serial);
      if (dev) {
        dev._beacon = int_beacon;
      }
      let module = YModule.FindModuleInContext(this, str_serial + ".module");
      await module._invokeBeaconCallback(int_beacon);
    }
  }
  imm_getFunctionValue(str_hwid) {
    let classname = this.imm_functionClass(str_hwid);
    return this._fnByType[classname].imm_getFunctionValue(str_hwid);
  }
  imm_getFunctionBaseType(str_hwid) {
    let classname = this.imm_functionClass(str_hwid);
    return this._fnByType[classname].imm_getBaseType();
  }
  imm_getFirstHardwareId(str_className) {
    if (Y_BASETYPES[str_className] == void 0) {
      if (this._fnByType[str_className] == void 0) {
        this._fnByType[str_className] = new YFunctionType(this, str_className);
      }
      return this._fnByType[str_className].imm_getFirstHardwareId();
    }
    let baseType = Y_BASETYPES[str_className];
    let res;
    for (str_className in this._fnByType) {
      if (this._fnByType[str_className].imm_matchBaseType(baseType)) {
        res = this._fnByType[str_className].imm_getFirstHardwareId();
        if (res)
          return res;
      }
    }
    return null;
  }
  imm_getNextHardwareId(str_className, str_hwid) {
    if (Y_BASETYPES[str_className] == void 0) {
      return this._fnByType[str_className].imm_getNextHardwareId(str_hwid);
    }
    let baseType = Y_BASETYPES[str_className];
    let prevclass = this.imm_functionClass(str_hwid);
    let res = this._fnByType[prevclass].imm_getNextHardwareId(str_hwid);
    if (res)
      return res;
    for (str_className in this._fnByType) {
      if (prevclass != "") {
        if (str_className != prevclass)
          continue;
        prevclass = "";
        continue;
      }
      if (this._fnByType[str_className].imm_matchBaseType(baseType)) {
        res = this._fnByType[str_className].imm_getFirstHardwareId();
        if (res)
          return res;
      }
    }
    return null;
  }
  async devRequest(str_device, str_request, obj_body = null, int_tcpchan = 0) {
    let lines = str_request.split("\n");
    let res = new YHTTPRequest(null);
    let lockdev = null;
    let baseUrl;
    if (str_device.substr(0, 7) == "http://" || str_device.substr(0, 5) == "ws://" || str_device.substr(0, 8) == "https://" || str_device.substr(0, 6) == "wss://" || str_device.substr(0, 9) == "secure://" || str_device.substr(0, 7) == "auto://") {
      baseUrl = str_device;
      if (baseUrl.slice(-1) != "/")
        baseUrl = baseUrl + "/";
      if (lines[0].substr(0, 12) != "GET /not.byn") {
        let serial = this._snByUrl[baseUrl];
        if (serial) {
          lockdev = this._devs[serial];
        }
      }
    } else {
      lockdev = this.imm_getDevice(str_device);
      if (!lockdev) {
        res.errorType = YAPI_DEVICE_NOT_FOUND;
        res.errorMsg = "Device [" + str_device + "] not online";
        return res;
      }
      if (lines[0] == "GET /api.json") {
        return lockdev.requestAPI(this.defaultCacheValidity);
      }
      baseUrl = lockdev.imm_getRootUrl();
    }
    let words = lines[0].split(" ");
    if (words.length < 2) {
      res.errorType = YAPI_INVALID_ARGUMENT;
      res.errorMsg = "Invalid request, not enough words; expected a method name and a URL";
      return res;
    } else if (words.length > 2) {
      res.errorType = YAPI_INVALID_ARGUMENT;
      res.errorMsg = "Invalid request, too many words; make sure the URL is URI-encoded";
      return res;
    }
    let hub = null;
    for (let i = 0; i < this._connectedHubs.length; i++) {
      let hubUrl = this._connectedHubs[i].imm_getRootUrl();
      if (baseUrl.slice(0, hubUrl.length) == hubUrl) {
        hub = this._connectedHubs[i];
        break;
      }
    }
    if (!hub && this._knownHubsByUrl[str_device]) {
      hub = this._knownHubsByUrl[str_device];
    }
    if (!hub) {
      res.errorType = YAPI_DEVICE_NOT_FOUND;
      res.errorMsg = "No hub found for URL " + baseUrl;
      return res;
    }
    let method = words[0];
    let devUrl = words[1];
    if (devUrl.substr(0, 1) == "/")
      devUrl = devUrl.substr(1);
    if (baseUrl.substr(0, hub.imm_getRootUrl().length) == hub.imm_getRootUrl()) {
      devUrl = baseUrl.substr(hub.imm_getRootUrl().length - 1) + devUrl;
    } else {
      let pos = baseUrl.indexOf("//");
      pos = baseUrl.indexOf("/", pos + 3);
      devUrl = baseUrl.slice(pos) + devUrl;
    }
    if (devUrl.slice(-2) == "&." && !await hub.hasRwAccess()) {
      res.errorType = YAPI_UNAUTHORIZED;
      res.errorMsg = "Access denied: admin credentials required";
      return res;
    }
    let delayedCode = function delayedRequest() {
      return hub.request(method, devUrl, obj_body, int_tcpchan).catch((e) => {
        let res2 = new YHTTPRequest(null);
        res2.errorType = YAPI_IO_ERROR;
        res2.errorMsg = e.message;
        return res2;
      });
    };
    if (lockdev && int_tcpchan == 0) {
      let newPromise = lockdev._pendingQueries.then(delayedCode, delayedCode);
      lockdev._pendingQueries = newPromise;
      res = await newPromise;
    } else {
      res = await delayedCode();
    }
    return res;
  }
  async isReadOnly(str_device) {
    let lockdev = this.imm_getDevice(str_device);
    if (!lockdev) {
      return true;
    }
    let baseUrl = lockdev.imm_getRootUrl();
    let hub = null;
    for (let i = 0; i < this._connectedHubs.length; i++) {
      let hubUrl = this._connectedHubs[i].imm_getRootUrl();
      if (baseUrl.slice(0, hubUrl.length) == hubUrl) {
        hub = this._connectedHubs[i];
        break;
      }
    }
    if (!hub || !await hub.hasRwAccess()) {
      return true;
    }
    return false;
  }
  imm_funcDev_internal(str_className, str_func) {
    let res = new YFuncRequest(null);
    let resolve = this.imm_resolveFunction(str_className, str_func);
    if (resolve.errorType != YAPI_SUCCESS) {
      res.errorType = resolve.errorType;
      res.errorMsg = resolve.errorMsg;
    } else {
      str_func = resolve.result;
      let dotpos = str_func.indexOf(".");
      let devid = str_func.substr(0, dotpos);
      let funcid = str_func.substr(dotpos + 1);
      let dev = this.imm_getDevice(devid);
      if (dev == null) {
        res.errorType = YAPI_DEVICE_NOT_FOUND;
        res.errorMsg = "Device [" + devid + "] not found";
      } else {
        res.obj_result = {_expiration: -1, device: dev, deviceid: devid, functionid: funcid, hwid: str_func};
      }
    }
    return res;
  }
  async _funcDev(str_className, str_func) {
    let res = this.imm_funcDev_internal(str_className, str_func);
    if (res.errorType == YAPI_SUCCESS) {
      return res;
    } else if (res.errorType == YAPI_DEVICE_NOT_FOUND && this._connectedHubs.length == 0) {
      res.errorMsg = "Impossible to contact any device because no hub has been registered";
      return res;
    }
    let updRes = await this._updateDeviceList_internal(true, false);
    if (updRes.errorType != YAPI_SUCCESS) {
      res.errorType = updRes.errorType;
      res.errorMsg = updRes.errorMsg;
      return res;
    }
    return this.imm_funcDev_internal(str_className, str_func);
  }
  async funcRequest(str_className, str_func, str_extra, int_msValidity = 0) {
    let funcreq = this.imm_funcDev_internal(str_className, str_func);
    if (funcreq.errorType != YAPI_SUCCESS) {
      funcreq = await this._funcDev(str_className, str_func);
      if (funcreq.errorType != YAPI_SUCCESS) {
        return funcreq;
      }
    }
    let devreq = funcreq.obj_result;
    let loadval = null;
    if (str_extra == "") {
      let yreq = await devreq.device.requestAPI(int_msValidity);
      if (yreq != null) {
        if (yreq.errorType != YAPI_SUCCESS || !yreq.obj_result) {
          let res = new YFuncRequest(null);
          res.errorType = yreq.errorType;
          res.errorMsg = yreq.errorMsg;
          return res;
        }
        loadval = yreq.obj_result[devreq.functionid];
      }
    } else {
      devreq.device.imm_dropCache();
    }
    if (!loadval) {
      if (str_extra == "")
        str_extra = ".json";
      let httpreq = "GET /api/" + devreq.functionid + str_extra;
      let yreq = await this.devRequest(devreq.deviceid, httpreq, null, 0);
      if (yreq.errorType != YAPI_SUCCESS)
        return yreq;
      let replyBuff = yreq.bin_result;
      if (replyBuff.length == 0 && httpreq.indexOf("?") >= 0) {
        funcreq.obj_result = null;
        return funcreq;
      }
      try {
        loadval = JSON.parse(this.imm_bin2str(replyBuff));
      } catch (err) {
      }
    }
    if (!loadval) {
      funcreq.errorType = YAPI_IO_ERROR;
      funcreq.errorMsg = "Request failed, could not parse API value for function " + devreq.hwid;
    } else {
      for (let key in devreq) {
        loadval[key] = devreq[key];
      }
      funcreq.obj_result = loadval;
    }
    return funcreq;
  }
  async HTTPRequest(str_device, str_request) {
    let yreq = await this.devRequest(str_device, str_request, null, 0);
    if (yreq.errorType != YAPI_SUCCESS) {
      return this._throw(yreq.errorType, yreq.errorMsg, null);
    }
    return yreq.bin_result;
  }
  async ForceDeviceRefresh(str_device) {
    let dev = this.imm_getDevice(str_device);
    if (!dev)
      return YAPI_DEVICE_NOT_FOUND;
    let rootUrl = dev.imm_getRootUrl();
    for (let i = 0; i < this._connectedHubs.length; i++) {
      let hub = this._connectedHubs[i];
      let hubUrl = hub.urlInfo.imm_getRootUrl();
      if (rootUrl.substr(0, hubUrl.length) === hubUrl) {
        let hubDev = this.imm_getDevice(hubUrl);
        hubDev.imm_dropCache();
        let retcode = await hubDev.refresh();
        if (retcode != YAPI_SUCCESS) {
          return this._throw(retcode, hubDev._lastErrorMsg, retcode);
        }
        let yreq = await hubDev.requestAPI(this.defaultCacheValidity);
        if (yreq.errorType != YAPI_SUCCESS) {
          return yreq.errorType;
        }
        let yellowPages = yreq.obj_result["services"]["yellowPages"];
        dev.imm_updateFromYP(yellowPages);
      }
    }
    dev.imm_dropCache();
    return YAPI_SUCCESS;
  }
  async SetDeviceListValidity_internal(deviceListValidity) {
    this._deviceListValidityMs = deviceListValidity * 1e3;
  }
  async GetDeviceListValidity_internal() {
    return this._deviceListValidityMs / 1e3 >> 0;
  }
  async SetNetworkTimeout_internal(networkMsTimeout) {
    this._networkTimeoutMs = networkMsTimeout;
  }
  async GetNetworkTimeout_internal() {
    return this._networkTimeoutMs;
  }
  async GetYAPISharedLibraryPath_internal() {
    return "";
  }
  async AddUdevRule_internal(force) {
    return "error: Not supported in TypeScript";
  }
  async DownloadHostCertificate_internal(url, mstimeout) {
    return await this.system_env.downloadRemoteCertificate(new _YY_UrlInfo(url));
  }
  async SetTrustedCertificatesList_internal(certificatePath) {
    return "error: Not supported in TypeScript";
  }
  async SetNetworkSecurityOptions_internal(opts) {
    this._networkSecurityOptions = opts;
    return "";
  }
  async AddTrustedCertificates_internal(certificate) {
    this._trustedCertificate.push(certificate);
    return "";
  }
  imm_updateRegisteredHubs(hub, add) {
    let i;
    for (i = 0; i < this._registeredHubs.length; i++) {
      if (this._registeredHubs[i] === hub) {
        if (!add) {
          if (this._logLevel >= 4) {
            this.imm_log("Unlisting registered hub: " + hub.imm_getOriginalURL());
          }
          this._registeredHubs.splice(i, 1);
        }
        return;
      }
    }
    if (add) {
      if (this._logLevel >= 4) {
        this.imm_log("Adding registered hub: " + hub.imm_getOriginalURL());
      }
      this._registeredHubs.push(hub);
    } else {
      if (this._logLevel >= 4) {
        this.imm_log("Could not unlist registered hub: " + hub.imm_getOriginalURL());
        for (i = 0; i < this._registeredHubs.length; i++) {
          this.imm_log("- " + this._registeredHubs[i].imm_getOriginalURL());
        }
      }
    }
  }
  async SetDeviceListValidity(deviceListValidity) {
    return await this.SetDeviceListValidity_internal(deviceListValidity);
  }
  async GetDeviceListValidity() {
    return await this.GetDeviceListValidity_internal();
  }
  async GetYAPISharedLibraryPath() {
    return await this.GetYAPISharedLibraryPath_internal();
  }
  async AddUdevRule(force) {
    return await this.AddUdevRule_internal(force);
  }
  async DownloadHostCertificate(url, mstimeout) {
    return await this.DownloadHostCertificate_internal(url, mstimeout);
  }
  async AddTrustedCertificates(certificate) {
    return await this.AddTrustedCertificates_internal(certificate);
  }
  async SetTrustedCertificatesList(certificatePath) {
    return await this.SetTrustedCertificatesList_internal(certificatePath);
  }
  async SetNetworkSecurityOptions(opts) {
    return await this.SetNetworkSecurityOptions_internal(opts);
  }
  async SetNetworkTimeout(networkMsTimeout) {
    return await this.SetNetworkTimeout_internal(networkMsTimeout);
  }
  async GetNetworkTimeout() {
    return await this.GetNetworkTimeout_internal();
  }
  async SetCacheValidity(cacheValidityMs) {
    this.defaultCacheValidity = cacheValidityMs;
  }
  async GetCacheValidity() {
    return this.defaultCacheValidity;
  }
  nextHubInUseInternal(hubref) {
    return this.nextHubInUseInternal_internal(hubref);
  }
  getYHubObj(hubref) {
    let obj;
    obj = this._findYHubFromCache(hubref);
    if (obj == null) {
      obj = new YHub(this, hubref);
      this._addYHubToCache(hubref, obj);
    }
    return obj;
  }
  async findYHubFromID(id) {
    let rhub;
    rhub = this.nextHubInUseInternal(-1);
    while (!(rhub == null)) {
      if (await rhub.get_serialNumber() == id) {
        return rhub;
      }
      if (await rhub.get_registeredUrl() == id) {
        return rhub;
      }
      rhub = rhub.nextHubInUse();
    }
    return rhub;
  }
  async GetAPIVersion() {
    return this.imm_GetAPIVersion();
  }
  imm_GetAPIVersion() {
    return "2.1.10136";
  }
  async InitAPI(mode, errmsg) {
    this._detectType = mode;
    if (this.system_env.hasSSDP) {
      if ((mode & this.DETECT_NET) !== 0) {
        await this.TriggerHubDiscovery();
      }
    } else {
    }
    return YAPI_SUCCESS;
  }
  async FreeAPI() {
    for (let serial in this._devs) {
      await this._devs[serial].waitPendingQueries();
    }
    await this.KillAPI();
  }
  async KillAPI() {
    if (this._ssdpManager) {
      await this._ssdpManager.ySSDPStop();
      this._ssdpManager = null;
    }
    for (let hub of this._connectedHubs) {
      this.imm_dropConnectedHub(hub);
    }
    for (let serial in this._knownHubsBySerial) {
      let hub = this._knownHubsBySerial[serial];
      if (hub.imm_getcurrentState() > -5) {
        await hub.detach(YAPI.IO_ERROR, "Connection closed by FreeAPI");
      }
    }
    this.imm_ResetToDefaults();
  }
  async DisableExceptions() {
    this.exceptionsDisabled = true;
  }
  async EnableExceptions() {
    this.exceptionsDisabled = false;
  }
  async LogUnhandledPromiseRejections() {
    this.system_env.hookUnhandledRejection((reason, promise) => {
      this.imm_log("Unhandled Rejection at: Promise ", promise, " reason: ", reason);
    });
  }
  async RegisterHub(url, errmsg) {
    if (this._logLevel >= 4) {
      this.imm_log("Registering hub: " + url);
    }
    if (url === "net") {
      if (this.system_env.hasSSDP) {
        this._detectType |= this.DETECT_NET;
        return this.TriggerHubDiscovery();
      } else {
        return this.imm_setErr(errmsg, YAPI_NOT_SUPPORTED, "Network discovery is not possible in a browser", YAPI_NOT_SUPPORTED);
      }
    }
    if (url === "usb") {
      return this.imm_setErr(errmsg, YAPI_NOT_SUPPORTED, "Use the VirtualHub on 127.0.0.1 to access USB devices", YAPI_NOT_SUPPORTED);
    }
    let urlInfo = new _YY_UrlInfo(url);
    let hub = this.imm_getHub(urlInfo);
    if (!hub) {
      if (this._logLevel >= 3) {
        this.imm_log("Registering new hub: " + urlInfo.imm_getRootUrl());
      }
      hub = new YGenericHub(this, urlInfo);
      hub.imm_addKnownUrl(urlInfo);
      this._knownHubsByUrl[urlInfo.imm_getRootUrl()] = hub;
    } else {
      if (this._logLevel >= 3) {
        this.imm_log("Registering existing hub: " + urlInfo.imm_getRootUrl() + " old=" + hub.imm_getRootUrl());
      }
      hub.imm_updateUrl(urlInfo);
    }
    this.imm_updateRegisteredHubs(hub, true);
    await hub.attach(2);
    let sub_errmsg = new YErrorMsg();
    let retcode = await hub.waitForConnection(this._networkTimeoutMs, sub_errmsg);
    if (retcode != YAPI_SUCCESS) {
      this.imm_dropConnectedHub(hub);
      this.imm_updateRegisteredHubs(hub, false);
      await hub.detach(retcode, sub_errmsg.msg);
      hub.imm_forgetUrls();
      return this.imm_setErr(errmsg, retcode, sub_errmsg.msg, retcode);
    }
    let yreq = await this._updateDeviceList_internal(true, false);
    if (yreq.errorType != YAPI_SUCCESS) {
      if (this._logLevel >= 3) {
        this.imm_log("Registering failed with" + yreq.errorType + " (" + yreq.errorMsg + ")");
      }
      this.imm_dropConnectedHub(hub);
      this.imm_updateRegisteredHubs(hub, false);
      await hub.detach(yreq.errorType, yreq.errorMsg);
      hub.imm_forgetUrls();
      return this.imm_setErr(errmsg, yreq.errorType, yreq.errorMsg, yreq.errorType);
    }
    return YAPI_SUCCESS;
  }
  async PreregisterHub(url, errmsg) {
    let urlInfo = new _YY_UrlInfo(url);
    let hub = this.imm_getHub(urlInfo);
    if (!hub) {
      if (this._logLevel >= 3) {
        this.imm_log("Preregistering new hub: " + urlInfo.imm_getRootUrl());
      }
      hub = new YGenericHub(this, urlInfo);
      if (!hub) {
        return this.imm_setErr(errmsg, YAPI_NOT_SUPPORTED, "Unsupported hub protocol: " + urlInfo.imm_getProto(), YAPI_NOT_SUPPORTED);
      }
      hub.imm_addKnownUrl(urlInfo);
      this._knownHubsByUrl[urlInfo.imm_getRootUrl()] = hub;
    } else {
      if (this._logLevel >= 3) {
        this.imm_log("Preregistering existing hub: " + urlInfo.imm_getRootUrl());
      }
      hub.imm_updateUrl(urlInfo);
    }
    await hub.attach(1);
    this.imm_updateRegisteredHubs(hub, true);
    return YAPI_SUCCESS;
  }
  async RegisterHubHttpCallback(incomingMessage, serverResponse, errmsg) {
    let url = "http://callback:4444";
    let urlInfo = new _YY_UrlInfo(url);
    let hub = this.imm_getHub(urlInfo);
    if (!hub) {
      hub = new YGenericHub(this, urlInfo);
      let engine = this.system_env.getHttpCallbackEngine(hub, urlInfo, incomingMessage, serverResponse);
      if (!engine) {
        return this.imm_setErr(errmsg, YAPI_NOT_SUPPORTED, "HTTP Callback mode is not available in this environment", YAPI_NOT_SUPPORTED);
      }
      hub.imm_setHubEngine(engine);
    }
    await hub.attach(3);
    let sub_errmsg = new YErrorMsg();
    let retcode = await hub.waitForConnection(this._networkTimeoutMs, sub_errmsg);
    if (retcode != YAPI_SUCCESS) {
      this.imm_dropConnectedHub(hub);
      await hub.detach(retcode, sub_errmsg.msg);
      return this.imm_setErr(errmsg, retcode, sub_errmsg.msg, retcode);
    }
    let yreq = await this._updateDeviceList_internal(true, false);
    if (yreq.errorType != YAPI_SUCCESS) {
      await hub.reportFailure(yreq.errorMsg);
      return this.imm_setErr(errmsg, yreq.errorType, yreq.errorMsg, yreq.errorType);
    }
    this.imm_updateRegisteredHubs(hub, true);
    return YAPI_SUCCESS;
  }
  async RegisterHubWebSocketCallback(ws, errmsg, authpwd) {
    let authstr = authpwd ? "ws:" + authpwd + "@" : "";
    let url = "http://" + authstr + "callback:4444";
    let urlInfo = new _YY_UrlInfo(url);
    let hub = this.imm_getHub(urlInfo);
    if (!hub) {
      hub = new YGenericHub(this, urlInfo);
      let engine = this.system_env.getWebSocketCallbackEngine(hub, urlInfo, ws);
      if (!engine) {
        return this.imm_setErr(errmsg, YAPI_NOT_SUPPORTED, "WebSocket Callback mode is not available in this environment", YAPI_NOT_SUPPORTED);
      }
      hub.imm_setHubEngine(engine);
    }
    await hub.attach(3);
    let sub_errmsg = new YErrorMsg();
    let retcode = await hub.waitForConnection(this._networkTimeoutMs, sub_errmsg);
    if (retcode != YAPI_SUCCESS) {
      this.imm_dropConnectedHub(hub);
      await hub.detach(retcode, sub_errmsg.msg);
      return this.imm_setErr(errmsg, retcode, sub_errmsg.msg, retcode);
    }
    let yreq = await this._updateDeviceList_internal(true, false);
    if (yreq.errorType != YAPI_SUCCESS) {
      this.imm_dropConnectedHub(hub);
      await hub.detach(yreq.errorType, yreq.errorMsg);
      return this.imm_setErr(errmsg, yreq.errorType, yreq.errorMsg, yreq.errorType);
    }
    this.imm_updateRegisteredHubs(hub, true);
    return YAPI_SUCCESS;
  }
  async WebSocketJoin(ws, arr_credentials, closeCallback) {
    if (this._connectedHubs.length == 0) {
      return false;
    }
    let hub = this._connectedHubs[0];
    return await hub.WebSocketJoin(ws, arr_credentials, closeCallback);
  }
  async UnregisterHub(url) {
    let urlInfo = new _YY_UrlInfo(url);
    let hub = this.imm_getHub(urlInfo);
    if (hub) {
      for (let serial in this._devs) {
        await this._devs[serial].waitPendingQueries();
      }
      await hub.waitForPendingQueries(200);
      let serialNumber = hub.imm_getSerialNumber();
      if (serialNumber) {
        let activeHub = this._knownHubsBySerial[serialNumber];
        if (activeHub) {
          hub.imm_forgetUrls();
          hub = activeHub;
          urlInfo = hub.urlInfo;
        }
      }
      if (this._logLevel >= 3) {
        this.imm_log("Unregistering hub " + url + " (" + urlInfo.imm_getRootUrl() + ")");
      }
      this.imm_dropConnectedHub(hub);
      if (hub.imm_isDisconnected()) {
        if (this._logLevel >= 3) {
          this.imm_log("Hub " + urlInfo.imm_getRootUrl() + " is already disconnected");
        }
        this.imm_updateRegisteredHubs(hub, false);
        return;
      }
      let before = this.GetTickCount();
      let disconnected = hub.waitForDisconnection(500);
      if (hub.imm_isDisconnecting()) {
        if (this._logLevel >= 3) {
          this.imm_log("Hub " + urlInfo.imm_getRootUrl() + " is already disconnecting");
        }
      } else {
        await hub.detach(YAPI.IO_ERROR, "Hub has been unregistered");
      }
      await disconnected;
      hub.imm_forgetUrls();
      this.imm_updateRegisteredHubs(hub, false);
      if (this._logLevel >= 4) {
        this.imm_log("Disconnected after " + (this.GetTickCount() - before) + " ms");
      }
    } else {
      if (this._logLevel >= 4) {
        this.imm_log("No hub to Unregister with " + url + " (" + urlInfo.imm_getRootUrl() + ")");
      }
    }
  }
  async TestHub(url, mstimeout, errmsg) {
    if (url == "net") {
      return this.imm_setErr(errmsg, YAPI_INVALID_ARGUMENT, "Not supported", YAPI_INVALID_ARGUMENT);
    }
    let urlInfo = new _YY_UrlInfo(url);
    let hub = this.imm_getHub(urlInfo);
    if (!hub) {
      if (this._logLevel >= 4) {
        this.imm_log("Testing new hub: " + urlInfo.imm_getRootUrl());
      }
      hub = new YGenericHub(this, urlInfo);
      if (!hub) {
        return this.imm_setErr(errmsg, YAPI_NOT_SUPPORTED, "Unsupported hub protocol: " + urlInfo.imm_getProto(), YAPI_NOT_SUPPORTED);
      }
    } else {
      if (this._logLevel >= 4) {
        this.imm_log("Testing existing hub: " + hub.imm_getRootUrl());
      }
    }
    await hub.attach(0);
    let sub_errmsg = new YErrorMsg();
    let retcode = await hub.waitForConnection(mstimeout, sub_errmsg);
    if (retcode != YAPI_SUCCESS) {
      return this.imm_setErr(errmsg, retcode, sub_errmsg.msg, retcode);
    }
    return YAPI_SUCCESS;
  }
  async UpdateDeviceList(errmsg = null) {
    let yreq = await this._updateDeviceList_internal(false, true);
    if (yreq.errorType !== YAPI_SUCCESS) {
      return this.imm_setErr(errmsg, yreq.errorType, yreq.errorMsg, yreq.errorType);
    }
    return YAPI_SUCCESS;
  }
  async _hubDiscoveryCallback_internal(serial, urlToRegister, urlToUnregister) {
    if (this._hubDiscoveryCallback && urlToRegister) {
      try {
        await this._hubDiscoveryCallback(serial, urlToRegister);
      } catch (e) {
        this.imm_log("Exception in hub discovery callback:", e);
      }
    }
    if ((this._detectType & Y_DETECT_NET) !== 0) {
      if (urlToRegister) {
        if (urlToUnregister) {
          await this.UnregisterHub(urlToUnregister);
        }
        await this.PreregisterHub(urlToRegister, new YErrorMsg());
      }
    }
  }
  async TriggerHubDiscovery(errmsg = null) {
    if (!this._ssdpManager) {
      this._ssdpManager = this.system_env.getSSDPManager(this);
      if (!this._ssdpManager)
        return this._lastErrorType;
      await this._ssdpManager.ySSDPStart((serial, newUrl, oldUrl) => {
        this._hubDiscoveryCallback_internal(serial, newUrl, oldUrl);
      });
    } else {
      await this._ssdpManager.ySSDPDiscover();
    }
    return YAPI_SUCCESS;
  }
  async HandleEvents(errmsg = null) {
    return YAPI_SUCCESS;
  }
  async Sleep(ms_duration, errmsg = null) {
    let end = this.GetTickCount() + ms_duration;
    let remaining = ms_duration;
    while (remaining > 0) {
      let waitTime = Math.min(remaining, 25);
      await new Promise((resolve, reject) => {
        setTimeout(resolve, waitTime);
      });
      remaining = end - this.GetTickCount();
    }
    return YAPI_SUCCESS;
  }
  _microSleep_internal() {
    return new Promise(function(resolve, reject) {
      setTimeout(resolve, 3);
    });
  }
  SetTimeout(callback, ms_timeout, args) {
    let endtime = this.GetTickCount() + ms_timeout;
    let setTimeout_internal = async () => {
      let delay = endtime - this.GetTickCount();
      if (delay < 40) {
        if (delay > 3) {
          await new Promise((resolve, reject) => {
            setTimeout(resolve, delay);
          });
        }
        callback.apply(null, args);
      } else {
        if (delay >= 150) {
          await this.UpdateDeviceList();
          delay = Math.min(endtime - YAPI.GetTickCount(), 110);
        }
        await this.Sleep(delay - 20);
        setTimeout_internal();
      }
    };
    setTimeout_internal();
    return YAPI_SUCCESS;
  }
  GetTickCount() {
    return Date.now();
  }
  imm_CheckLogicalName(name) {
    if (name == "")
      return true;
    if (!name)
      return false;
    if (name.length > 19)
      return false;
    return /^[A-Za-z0-9_\-]*$/.test(name);
  }
  async CheckLogicalName(name) {
    return this.imm_CheckLogicalName(name);
  }
  async RegisterDeviceArrivalCallback(arrivalCallback) {
    this._arrivalCallback = arrivalCallback;
  }
  async RegisterDeviceChangeCallback(changeCallback) {
    this._namechgCallback = changeCallback;
  }
  async RegisterDeviceRemovalCallback(removalCallback) {
    this._removalCallback = removalCallback;
  }
  async RegisterHubDiscoveryCallback(hubDiscoveryCallback) {
    if (!this.system_env.hasSSDP) {
      return this._throw(YAPI_NOT_SUPPORTED, "Hub discovery is not supported in this environment", YAPI_NOT_SUPPORTED);
    }
    this._hubDiscoveryCallback = hubDiscoveryCallback;
    return this.TriggerHubDiscovery();
  }
  async RegisterCalibrationHandler(calibrationType, calibrationHandler) {
    this._calibHandlers[calibrationType] = calibrationHandler;
  }
  LinearCalibrationHandler(float_rawValue, int_calibType, arr_calibParams, arr_calibRawValues, arr_calibRefValues) {
    let npt;
    let x = arr_calibRawValues[0];
    let adj = arr_calibRefValues[0] - x;
    let i = 0;
    if (int_calibType < YOCTO_CALIB_TYPE_OFS) {
      npt = Math.min(int_calibType % 10, arr_calibRawValues.length, arr_calibRefValues.length);
    } else {
      npt = arr_calibRefValues.length;
    }
    while (float_rawValue > arr_calibRawValues[i] && ++i < npt) {
      let x2 = x;
      let adj2 = adj;
      x = arr_calibRawValues[i];
      adj = arr_calibRefValues[i] - x;
      if (float_rawValue < x && x > x2) {
        adj = adj2 + (adj - adj2) * (float_rawValue - x2) / (x - x2);
      }
    }
    return float_rawValue + adj;
  }
  imm_yMD5(text) {
    let ctx = new Y_MD5Ctx();
    ctx.addData(this.imm_str2bin(text));
    return ctx.calculate();
  }
  imm_initshaw(str_s, int_ofs, int_pad, int_xinit, _shaw) {
    let ii;
    let j = -1;
    let k = 0;
    let n = str_s.length;
    for (ii = 0; ii < 64; ii++) {
      let i = int_ofs + ii;
      let c = 0;
      if (i < n) {
        c = str_s.charCodeAt(i);
      } else if (int_pad != 0) {
        if ((int_pad & 128) != 0) {
          if (i == n)
            c = int_pad;
        } else {
          if (i == n + 3) {
            c = int_pad;
          } else if (i == n + 4)
            c = 128;
        }
      }
      if (k == 0) {
        j++;
        _shaw[j] = 0;
        k = 32;
      }
      k -= 8;
      _shaw[j] |= c << k;
    }
    if (int_pad != 0) {
      if (int_pad == 128) {
        if (n <= int_ofs + 55) {
          _shaw[15] = 8 * n;
        }
      } else {
        _shaw[15] = 8 * (64 + n + 4);
      }
    }
    if (int_xinit != 0) {
      let xdw = int_xinit << 16 | int_xinit;
      for (j = 0; j < 16; j++) {
        _shaw[j] ^= xdw;
      }
    }
  }
  imm_itershaw(s, _shaw) {
    let a, b, c, d, e, t, k;
    a = s[0];
    b = s[1];
    c = s[2];
    d = s[3];
    e = s[4];
    for (k = 16; k < 80; k++) {
      t = _shaw[k - 3] ^ _shaw[k - 8] ^ _shaw[k - 14] ^ _shaw[k - 16];
      _shaw[k] = t << 1 | t >>> 31;
    }
    for (k = 0; k < 20; k++) {
      t = (a << 5 | a >>> 27) + e + _shaw[k] + 1518500249 + (b & c | ~b & d);
      e = d;
      d = c;
      c = b << 30 | b >>> 2;
      b = a;
      a = t & 4294967295;
    }
    for (k = 20; k < 40; k++) {
      t = (a << 5 | a >>> 27) + e + _shaw[k] + 1859775393 + (b ^ c ^ d);
      e = d;
      d = c;
      c = b << 30 | b >>> 2;
      b = a;
      a = t & 4294967295;
    }
    for (k = 40; k < 60; k++) {
      t = (a << 5 | a >>> 27) + e + _shaw[k] + 2400959708 + (b & c | b & d | c & d);
      e = d;
      d = c;
      c = b << 30 | b >>> 2;
      b = a;
      a = t & 4294967295;
    }
    for (k = 60; k < 80; k++) {
      t = (a << 5 | a >>> 27) + e + _shaw[k] + 3395469782 + (b ^ c ^ d);
      e = d;
      d = c;
      c = b << 30 | b >>> 2;
      b = a;
      a = t & 4294967295;
    }
    _shaw[0] = s[0] + a & 4294967295;
    _shaw[1] = s[1] + b & 4294967295;
    _shaw[2] = s[2] + c & 4294967295;
    _shaw[3] = s[3] + d & 4294967295;
    _shaw[4] = s[4] + e & 4294967295;
  }
  imm_ySHA1(text) {
    let shau = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
    let i, ofs = 0;
    let n = text.length;
    let _shaw = new Uint32Array(80);
    do {
      this.imm_initshaw(text, ofs, 128, 0, _shaw);
      this.imm_itershaw(shau, _shaw);
      for (i = 0; i < 5; i++) {
        shau[i] = _shaw[i];
      }
      ofs += 64;
    } while (n > ofs - 9);
    let res = new Uint8Array(20);
    for (i = 0; i < 20; i++) {
      res[i] = shau[i >>> 2] >>> 24 - 8 * (i & 3) & 255;
    }
    return res;
  }
  async ComputePSK(ssid, pass) {
    let sha1_init = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
    let inner = [], outer = [], shau = [], res = [];
    let iter, pos, k, _shaw;
    _shaw = new Uint32Array(80);
    this.imm_initshaw(pass, 0, 0, 13878, _shaw);
    this.imm_itershaw(sha1_init, _shaw);
    for (k = 0; k < 5; k++) {
      inner[k] = _shaw[k];
    }
    _shaw = new Uint32Array(80);
    this.imm_initshaw(pass, 0, 0, 23644, _shaw);
    this.imm_itershaw(sha1_init, _shaw);
    for (k = 0; k < 5; k++) {
      outer[k] = _shaw[k];
    }
    pos = 0;
    for (k = 0; k < 5; k++) {
      shau[k] = 0;
    }
    _shaw = new Uint32Array(80);
    this.imm_initshaw(ssid, 0, 1, 0, _shaw);
    for (iter = 0; iter < 8192; ) {
      this.imm_itershaw(inner, _shaw);
      _shaw[5] = 2147483648;
      for (k = 6; k < 15; k++) {
        _shaw[k] = 0;
      }
      _shaw[15] = 8 * (64 + 20);
      this.imm_itershaw(outer, _shaw);
      shau[0] ^= _shaw[0];
      shau[1] ^= _shaw[1];
      shau[2] ^= _shaw[2];
      shau[3] ^= _shaw[3];
      shau[4] ^= _shaw[4];
      iter++;
      if ((iter & 4095) == 0) {
        for (k = 0; k < 5 && pos < 32; k++) {
          res[pos++] = shau[k] >>> 24 & 255;
          res[pos++] = shau[k] >>> 16 & 255;
          res[pos++] = shau[k] >>> 8 & 255;
          res[pos++] = shau[k] & 255;
        }
        if (iter == 4096) {
          for (k = 0; k < 5; k++) {
            shau[k] = 0;
          }
          _shaw = new Uint32Array(80);
          this.imm_initshaw(ssid, 0, 2, 0, _shaw);
        }
      }
    }
    let hex = "";
    for (k = 0; k < 32; k++) {
      hex += ("0" + Number(res[k]).toString(16)).slice(-2);
    }
    return hex;
  }
  nextHubInUseInternal_internal(hubref) {
    let nextref = hubref < 0 ? 0 : hubref + 1;
    let restart;
    let has_higher_hubref;
    do {
      has_higher_hubref = false;
      restart = false;
      for (let url in this._registeredHubs) {
        let hub = this._registeredHubs[url];
        let hubRef = hub.getHubRef();
        if (hubRef == nextref) {
          return this.getYHubObj(nextref);
        } else if (hubRef > nextref) {
          has_higher_hubref = true;
        }
      }
      if (has_higher_hubref) {
        nextref++;
        restart = true;
      }
    } while (restart);
    return null;
  }
  getGenHub(hubref) {
    for (let i = 0; i < this._registeredHubs.length; i++) {
      let hub = this._registeredHubs[i];
      if (hub.getHubRef() == hubref) {
        return hub;
      }
    }
    return null;
  }
  _findYHubFromCache(hubref) {
    return this._yhub_cache[hubref];
  }
  _addYHubToCache(hubref, obj) {
    this._yhub_cache[hubref] = obj;
  }
};
YAPIContext.SUCCESS = 0;
YAPIContext.NOT_INITIALIZED = -1;
YAPIContext.INVALID_ARGUMENT = -2;
YAPIContext.NOT_SUPPORTED = -3;
YAPIContext.DEVICE_NOT_FOUND = -4;
YAPIContext.VERSION_MISMATCH = -5;
YAPIContext.DEVICE_BUSY = -6;
YAPIContext.TIMEOUT = -7;
YAPIContext.IO_ERROR = -8;
YAPIContext.NO_MORE_DATA = -9;
YAPIContext.EXHAUSTED = -10;
YAPIContext.DOUBLE_ACCES = -11;
YAPIContext.UNAUTHORIZED = -12;
YAPIContext.RTC_NOT_READY = -13;
YAPIContext.FILE_NOT_FOUND = -14;
YAPIContext.SSL_ERROR = -15;
YAPIContext.RFID_SOFT_ERROR = -16;
YAPIContext.RFID_HARD_ERROR = -17;
YAPIContext.BUFFER_TOO_SMALL = -18;
YAPIContext.DNS_ERROR = -19;
YAPIContext.SSL_UNK_CERT = -20;
YAPIContext.UNCONFIGURED = -21;
YAPIContext.NO_TRUSTED_CA_CHECK = 1;
YAPIContext.NO_EXPIRATION_CHECK = 2;
YAPIContext.NO_HOSTNAME_CHECK = 4;
YAPIContext.LEGACY = 8;
var YAPI = new YAPIContext();

// obj/full/Api/yocto_api_html.js
var YSystemEnvHtml = class extends YSystemEnv {
  constructor() {
    super(...arguments);
    this.isNodeJS = false;
    this.hasSSDP = false;
  }
  hookUnhandledRejection(handler) {
    window.addEventListener("onunhandledrejection", (event) => {
      let promiseRejectionEvent = event;
      handler(promiseRejectionEvent.reason, promiseRejectionEvent.promise);
    });
  }
  getWebSocketEngine(hub, runtime_urlInfo) {
    return new YWebSocketHtmlEngine(hub, runtime_urlInfo);
  }
  getHttpEngine(hub, runtime_urlInfo, firstInfoJson) {
    return new YHttpHtmlEngine(hub, runtime_urlInfo, firstInfoJson);
  }
  getWebSocketCallbackHub(hub, ws) {
    return hub._yapi._throw(YAPI.NOT_SUPPORTED, "WebSocket Callback mode is not available in this environment", null);
  }
  getHttpCallbackHub(hub, incomingMessage, serverResponse) {
    return hub._yapi._throw(YAPI.NOT_SUPPORTED, "HTTP Callback mode is not available in this environment", null);
  }
  getSSDPManager(obj_yapi) {
    return obj_yapi._throw(YAPI.NOT_SUPPORTED, "Hub discovery is not available in this environment", null);
  }
  loadfile(file) {
    return new Promise((resolve, reject) => {
      let reader = new FileReader();
      reader.onerror = function(evt) {
        reject(evt.target.error);
      };
      reader.onload = function(evt) {
        resolve(new Uint8Array(evt.target.result));
      };
      reader.readAsArrayBuffer(file);
    });
  }
  downloadfile(url, yapi) {
    return new Promise((resolve, reject) => {
      let httpRequest = new XMLHttpRequest();
      httpRequest.open("GET", url, true);
      httpRequest.overrideMimeType("text/plain; charset=x-user-defined");
      httpRequest.onreadystatechange = () => {
        if (httpRequest.readyState == 4) {
          if (httpRequest.status != 200 && httpRequest.status != 304) {
            if (httpRequest.status) {
              reject(new Error("HTTP error " + httpRequest.status));
            } else {
              reject(new Error("Unable to complete HTTP request, network down?"));
            }
          } else {
            resolve(YAPI.imm_str2bin(httpRequest.responseText));
          }
        }
      };
      httpRequest.send("");
    });
  }
  async downloadRemoteCertificate(urlinfo) {
    return "error: Not supported in browser";
  }
};
var _HtmlSystemEnv = new YSystemEnvHtml();
YAPI.imm_setSystemEnv(_HtmlSystemEnv);
var YHttpHtmlEngine = class extends YHttpEngine {
  constructor(hub, runtime_urlInfo, firstInfoJson) {
    super(hub, runtime_urlInfo, firstInfoJson);
  }
  imm_makeRequest(method, relUrl, contentType, body, onProgress, onSuccess, onError) {
    let xhr = new XMLHttpRequest();
    let currPos = 0;
    xhr.open(method, this._runtime_urlInfo.imm_getUrl(true, true, false) + relUrl, true, "", "");
    xhr.setRequestHeader("Content-Type", contentType);
    xhr.overrideMimeType("text/plain; charset=x-user-defined");
    xhr.onreadystatechange = () => {
      if (xhr.readyState >= 3) {
        let httpStatus = xhr.status >> 0;
        if (xhr.readyState == 4 && httpStatus != 200 && httpStatus != 304) {
          if (httpStatus == 401 || httpStatus == 204) {
            this.infoJson.stamp = 0;
            onError(YAPI.UNAUTHORIZED, "Unauthorized access (" + xhr.status + ")", false);
          } else if (httpStatus == 404) {
            onError(YAPI.FILE_NOT_FOUND, "HTTP request return status 404 (not found)", false);
          } else if (this._hub.imm_isDisconnecting()) {
            onError(YAPI.IO_ERROR, "Hub is disconnecting", false);
          } else {
            onError(YAPI.IO_ERROR, "HTTP request failed with status " + xhr.status, false);
          }
          return;
        }
        if (this._hub.imm_isDisconnecting()) {
          if (this._hub._yapi._logLevel >= 4) {
            this._hub._yapi.imm_log("Dropping request " + relUrl + " because hub is disconnecting");
          }
          return;
        }
        if (onProgress && xhr.responseText) {
          let newlen = xhr.responseText.length;
          if (newlen > currPos) {
            onProgress(xhr.responseText.slice(currPos, newlen));
            currPos = newlen;
          }
        }
        if (onSuccess && xhr.readyState == 4) {
          onSuccess(xhr.responseText);
        }
      }
    };
    xhr.onerror = () => {
      onError(YAPI.IO_ERROR, "HTTP request failed without status", false);
    };
    xhr.send(body);
    return xhr;
  }
  imm_abortRequest(clientRequest) {
    clientRequest.abort();
  }
};
var YWebSocketHtmlEngine = class extends YWebSocketEngine {
  imm_webSocketOpen(str_url) {
    let websock = new WebSocket(str_url);
    websock.binaryType = "arraybuffer";
    this.websocket = websock;
  }
  imm_getRandomValues(arr) {
    return window.crypto.getRandomValues(arr);
  }
};

// obj/full/Api/yocto_network.js
var YNetwork = class extends YFunction {
  constructor(yapi, func) {
    super(yapi, func);
    this._readiness = YNetwork.READINESS_INVALID;
    this._macAddress = YNetwork.MACADDRESS_INVALID;
    this._ipAddress = YNetwork.IPADDRESS_INVALID;
    this._subnetMask = YNetwork.SUBNETMASK_INVALID;
    this._router = YNetwork.ROUTER_INVALID;
    this._currentDNS = YNetwork.CURRENTDNS_INVALID;
    this._ipConfig = YNetwork.IPCONFIG_INVALID;
    this._primaryDNS = YNetwork.PRIMARYDNS_INVALID;
    this._secondaryDNS = YNetwork.SECONDARYDNS_INVALID;
    this._ntpServer = YNetwork.NTPSERVER_INVALID;
    this._userPassword = YNetwork.USERPASSWORD_INVALID;
    this._adminPassword = YNetwork.ADMINPASSWORD_INVALID;
    this._httpPort = YNetwork.HTTPPORT_INVALID;
    this._httpsPort = YNetwork.HTTPSPORT_INVALID;
    this._securityMode = YNetwork.SECURITYMODE_INVALID;
    this._defaultPage = YNetwork.DEFAULTPAGE_INVALID;
    this._discoverable = YNetwork.DISCOVERABLE_INVALID;
    this._wwwWatchdogDelay = YNetwork.WWWWATCHDOGDELAY_INVALID;
    this._callbackUrl = YNetwork.CALLBACKURL_INVALID;
    this._callbackMethod = YNetwork.CALLBACKMETHOD_INVALID;
    this._callbackEncoding = YNetwork.CALLBACKENCODING_INVALID;
    this._callbackTemplate = YNetwork.CALLBACKTEMPLATE_INVALID;
    this._callbackCredentials = YNetwork.CALLBACKCREDENTIALS_INVALID;
    this._callbackInitialDelay = YNetwork.CALLBACKINITIALDELAY_INVALID;
    this._callbackSchedule = YNetwork.CALLBACKSCHEDULE_INVALID;
    this._callbackMinDelay = YNetwork.CALLBACKMINDELAY_INVALID;
    this._callbackMaxDelay = YNetwork.CALLBACKMAXDELAY_INVALID;
    this._poeCurrent = YNetwork.POECURRENT_INVALID;
    this._valueCallbackNetwork = null;
    this.READINESS_DOWN = 0;
    this.READINESS_EXISTS = 1;
    this.READINESS_LINKED = 2;
    this.READINESS_LAN_OK = 3;
    this.READINESS_WWW_OK = 4;
    this.READINESS_INVALID = -1;
    this.MACADDRESS_INVALID = YAPI.INVALID_STRING;
    this.IPADDRESS_INVALID = YAPI.INVALID_STRING;
    this.SUBNETMASK_INVALID = YAPI.INVALID_STRING;
    this.ROUTER_INVALID = YAPI.INVALID_STRING;
    this.CURRENTDNS_INVALID = YAPI.INVALID_STRING;
    this.IPCONFIG_INVALID = YAPI.INVALID_STRING;
    this.PRIMARYDNS_INVALID = YAPI.INVALID_STRING;
    this.SECONDARYDNS_INVALID = YAPI.INVALID_STRING;
    this.NTPSERVER_INVALID = YAPI.INVALID_STRING;
    this.USERPASSWORD_INVALID = YAPI.INVALID_STRING;
    this.ADMINPASSWORD_INVALID = YAPI.INVALID_STRING;
    this.HTTPPORT_INVALID = YAPI.INVALID_UINT;
    this.HTTPSPORT_INVALID = YAPI.INVALID_UINT;
    this.SECURITYMODE_UNDEFINED = 0;
    this.SECURITYMODE_LEGACY = 1;
    this.SECURITYMODE_MIXED = 2;
    this.SECURITYMODE_SECURE = 3;
    this.SECURITYMODE_INVALID = -1;
    this.DEFAULTPAGE_INVALID = YAPI.INVALID_STRING;
    this.DISCOVERABLE_FALSE = 0;
    this.DISCOVERABLE_TRUE = 1;
    this.DISCOVERABLE_INVALID = -1;
    this.WWWWATCHDOGDELAY_INVALID = YAPI.INVALID_UINT;
    this.CALLBACKURL_INVALID = YAPI.INVALID_STRING;
    this.CALLBACKMETHOD_POST = 0;
    this.CALLBACKMETHOD_GET = 1;
    this.CALLBACKMETHOD_PUT = 2;
    this.CALLBACKMETHOD_INVALID = -1;
    this.CALLBACKENCODING_FORM = 0;
    this.CALLBACKENCODING_JSON = 1;
    this.CALLBACKENCODING_JSON_ARRAY = 2;
    this.CALLBACKENCODING_CSV = 3;
    this.CALLBACKENCODING_YOCTO_API = 4;
    this.CALLBACKENCODING_JSON_NUM = 5;
    this.CALLBACKENCODING_EMONCMS = 6;
    this.CALLBACKENCODING_AZURE = 7;
    this.CALLBACKENCODING_INFLUXDB = 8;
    this.CALLBACKENCODING_MQTT = 9;
    this.CALLBACKENCODING_YOCTO_API_JZON = 10;
    this.CALLBACKENCODING_PRTG = 11;
    this.CALLBACKENCODING_INFLUXDB_V2 = 12;
    this.CALLBACKENCODING_INVALID = -1;
    this.CALLBACKTEMPLATE_OFF = 0;
    this.CALLBACKTEMPLATE_ON = 1;
    this.CALLBACKTEMPLATE_INVALID = -1;
    this.CALLBACKCREDENTIALS_INVALID = YAPI.INVALID_STRING;
    this.CALLBACKINITIALDELAY_INVALID = YAPI.INVALID_UINT;
    this.CALLBACKSCHEDULE_INVALID = YAPI.INVALID_STRING;
    this.CALLBACKMINDELAY_INVALID = YAPI.INVALID_UINT;
    this.CALLBACKMAXDELAY_INVALID = YAPI.INVALID_UINT;
    this.POECURRENT_INVALID = YAPI.INVALID_UINT;
    this._className = "Network";
  }
  imm_parseAttr(name, val) {
    switch (name) {
      case "readiness":
        this._readiness = val;
        return 1;
      case "macAddress":
        this._macAddress = val;
        return 1;
      case "ipAddress":
        this._ipAddress = val;
        return 1;
      case "subnetMask":
        this._subnetMask = val;
        return 1;
      case "router":
        this._router = val;
        return 1;
      case "currentDNS":
        this._currentDNS = val;
        return 1;
      case "ipConfig":
        this._ipConfig = val;
        return 1;
      case "primaryDNS":
        this._primaryDNS = val;
        return 1;
      case "secondaryDNS":
        this._secondaryDNS = val;
        return 1;
      case "ntpServer":
        this._ntpServer = val;
        return 1;
      case "userPassword":
        this._userPassword = val;
        return 1;
      case "adminPassword":
        this._adminPassword = val;
        return 1;
      case "httpPort":
        this._httpPort = val;
        return 1;
      case "httpsPort":
        this._httpsPort = val;
        return 1;
      case "securityMode":
        this._securityMode = val;
        return 1;
      case "defaultPage":
        this._defaultPage = val;
        return 1;
      case "discoverable":
        this._discoverable = val;
        return 1;
      case "wwwWatchdogDelay":
        this._wwwWatchdogDelay = val;
        return 1;
      case "callbackUrl":
        this._callbackUrl = val;
        return 1;
      case "callbackMethod":
        this._callbackMethod = val;
        return 1;
      case "callbackEncoding":
        this._callbackEncoding = val;
        return 1;
      case "callbackTemplate":
        this._callbackTemplate = val;
        return 1;
      case "callbackCredentials":
        this._callbackCredentials = val;
        return 1;
      case "callbackInitialDelay":
        this._callbackInitialDelay = val;
        return 1;
      case "callbackSchedule":
        this._callbackSchedule = val;
        return 1;
      case "callbackMinDelay":
        this._callbackMinDelay = val;
        return 1;
      case "callbackMaxDelay":
        this._callbackMaxDelay = val;
        return 1;
      case "poeCurrent":
        this._poeCurrent = val;
        return 1;
    }
    return super.imm_parseAttr(name, val);
  }
  async get_readiness() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.READINESS_INVALID;
      }
    }
    res = this._readiness;
    return res;
  }
  async get_macAddress() {
    let res;
    if (this._cacheExpiration == 0) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.MACADDRESS_INVALID;
      }
    }
    res = this._macAddress;
    return res;
  }
  async get_ipAddress() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.IPADDRESS_INVALID;
      }
    }
    res = this._ipAddress;
    return res;
  }
  async get_subnetMask() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.SUBNETMASK_INVALID;
      }
    }
    res = this._subnetMask;
    return res;
  }
  async get_router() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.ROUTER_INVALID;
      }
    }
    res = this._router;
    return res;
  }
  async get_currentDNS() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.CURRENTDNS_INVALID;
      }
    }
    res = this._currentDNS;
    return res;
  }
  async get_ipConfig() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.IPCONFIG_INVALID;
      }
    }
    res = this._ipConfig;
    return res;
  }
  async set_ipConfig(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("ipConfig", rest_val);
  }
  async get_primaryDNS() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.PRIMARYDNS_INVALID;
      }
    }
    res = this._primaryDNS;
    return res;
  }
  async set_primaryDNS(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("primaryDNS", rest_val);
  }
  async get_secondaryDNS() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.SECONDARYDNS_INVALID;
      }
    }
    res = this._secondaryDNS;
    return res;
  }
  async set_secondaryDNS(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("secondaryDNS", rest_val);
  }
  async get_ntpServer() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.NTPSERVER_INVALID;
      }
    }
    res = this._ntpServer;
    return res;
  }
  async set_ntpServer(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("ntpServer", rest_val);
  }
  async get_userPassword() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.USERPASSWORD_INVALID;
      }
    }
    res = this._userPassword;
    return res;
  }
  async set_userPassword(newval) {
    let rest_val;
    if (newval.length > YAPI.HASH_BUF_SIZE) {
      return this._throw(YAPI.INVALID_ARGUMENT, "Password too long :" + newval, YAPI.INVALID_ARGUMENT);
    }
    rest_val = String(newval);
    return await this._setAttr("userPassword", rest_val);
  }
  async get_adminPassword() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.ADMINPASSWORD_INVALID;
      }
    }
    res = this._adminPassword;
    return res;
  }
  async set_adminPassword(newval) {
    let rest_val;
    if (newval.length > YAPI.HASH_BUF_SIZE) {
      return this._throw(YAPI.INVALID_ARGUMENT, "Password too long :" + newval, YAPI.INVALID_ARGUMENT);
    }
    rest_val = String(newval);
    return await this._setAttr("adminPassword", rest_val);
  }
  async get_httpPort() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.HTTPPORT_INVALID;
      }
    }
    res = this._httpPort;
    return res;
  }
  async set_httpPort(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("httpPort", rest_val);
  }
  async get_httpsPort() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.HTTPSPORT_INVALID;
      }
    }
    res = this._httpsPort;
    return res;
  }
  async set_httpsPort(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("httpsPort", rest_val);
  }
  async get_securityMode() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.SECURITYMODE_INVALID;
      }
    }
    res = this._securityMode;
    return res;
  }
  async set_securityMode(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("securityMode", rest_val);
  }
  async get_defaultPage() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.DEFAULTPAGE_INVALID;
      }
    }
    res = this._defaultPage;
    return res;
  }
  async set_defaultPage(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("defaultPage", rest_val);
  }
  async get_discoverable() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.DISCOVERABLE_INVALID;
      }
    }
    res = this._discoverable;
    return res;
  }
  async set_discoverable(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("discoverable", rest_val);
  }
  async get_wwwWatchdogDelay() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.WWWWATCHDOGDELAY_INVALID;
      }
    }
    res = this._wwwWatchdogDelay;
    return res;
  }
  async set_wwwWatchdogDelay(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("wwwWatchdogDelay", rest_val);
  }
  async get_callbackUrl() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.CALLBACKURL_INVALID;
      }
    }
    res = this._callbackUrl;
    return res;
  }
  async set_callbackUrl(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("callbackUrl", rest_val);
  }
  async get_callbackMethod() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.CALLBACKMETHOD_INVALID;
      }
    }
    res = this._callbackMethod;
    return res;
  }
  async set_callbackMethod(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("callbackMethod", rest_val);
  }
  async get_callbackEncoding() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.CALLBACKENCODING_INVALID;
      }
    }
    res = this._callbackEncoding;
    return res;
  }
  async set_callbackEncoding(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("callbackEncoding", rest_val);
  }
  async get_callbackTemplate() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.CALLBACKTEMPLATE_INVALID;
      }
    }
    res = this._callbackTemplate;
    return res;
  }
  async set_callbackTemplate(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("callbackTemplate", rest_val);
  }
  async get_callbackCredentials() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.CALLBACKCREDENTIALS_INVALID;
      }
    }
    res = this._callbackCredentials;
    return res;
  }
  async set_callbackCredentials(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("callbackCredentials", rest_val);
  }
  async callbackLogin(username, password) {
    let rest_val;
    rest_val = username + ":" + password;
    return await this._setAttr("callbackCredentials", rest_val);
  }
  async get_callbackInitialDelay() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.CALLBACKINITIALDELAY_INVALID;
      }
    }
    res = this._callbackInitialDelay;
    return res;
  }
  async set_callbackInitialDelay(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("callbackInitialDelay", rest_val);
  }
  async get_callbackSchedule() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.CALLBACKSCHEDULE_INVALID;
      }
    }
    res = this._callbackSchedule;
    return res;
  }
  async set_callbackSchedule(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("callbackSchedule", rest_val);
  }
  async get_callbackMinDelay() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.CALLBACKMINDELAY_INVALID;
      }
    }
    res = this._callbackMinDelay;
    return res;
  }
  async set_callbackMinDelay(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("callbackMinDelay", rest_val);
  }
  async get_callbackMaxDelay() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.CALLBACKMAXDELAY_INVALID;
      }
    }
    res = this._callbackMaxDelay;
    return res;
  }
  async set_callbackMaxDelay(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("callbackMaxDelay", rest_val);
  }
  async get_poeCurrent() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.POECURRENT_INVALID;
      }
    }
    res = this._poeCurrent;
    return res;
  }
  static FindNetwork(func) {
    let obj;
    obj = YFunction._FindFromCache("Network", func);
    if (obj == null) {
      obj = new YNetwork(YAPI, func);
      YFunction._AddToCache("Network", func, obj);
    }
    return obj;
  }
  static FindNetworkInContext(yctx, func) {
    let obj;
    obj = YFunction._FindFromCacheInContext(yctx, "Network", func);
    if (obj == null) {
      obj = new YNetwork(yctx, func);
      YFunction._AddToCache("Network", func, obj);
    }
    return obj;
  }
  async registerValueCallback(callback) {
    let val;
    if (callback != null) {
      await YFunction._UpdateValueCallbackList(this, true);
    } else {
      await YFunction._UpdateValueCallbackList(this, false);
    }
    this._valueCallbackNetwork = callback;
    if (callback != null && await this.isOnline()) {
      val = this._advertisedValue;
      if (!(val == "")) {
        await this._invokeValueCallback(val);
      }
    }
    return 0;
  }
  async _invokeValueCallback(value) {
    if (this._valueCallbackNetwork != null) {
      try {
        await this._valueCallbackNetwork(this, value);
      } catch (e) {
        this._yapi.imm_log("Exception in valueCallback:", e);
      }
    } else {
      await super._invokeValueCallback(value);
    }
    return 0;
  }
  async useDHCP(fallbackIpAddr, fallbackSubnetMaskLen, fallbackRouter) {
    return await this.set_ipConfig("DHCP:" + fallbackIpAddr + "/" + String(Math.round(fallbackSubnetMaskLen)) + "/" + fallbackRouter);
  }
  async useDHCPauto() {
    return await this.set_ipConfig("DHCP:");
  }
  async useStaticIP(ipAddress, subnetMaskLen, router) {
    return await this.set_ipConfig("STATIC:" + ipAddress + "/" + String(Math.round(subnetMaskLen)) + "/" + router);
  }
  async ping(host) {
    let content;
    content = await this._download("ping.txt?host=" + host);
    return this._yapi.imm_bin2str(content);
  }
  async triggerCallback() {
    return await this.set_callbackMethod(await this.get_callbackMethod());
  }
  async set_periodicCallbackSchedule(interval, offset) {
    return await this.set_callbackSchedule("every " + interval + "+" + String(Math.round(offset)));
  }
  nextNetwork() {
    let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
    if (resolve.errorType != YAPI.SUCCESS)
      return null;
    let next_hwid = this._yapi.imm_getNextHardwareId(this._className, resolve.result);
    if (next_hwid == null)
      return null;
    return YNetwork.FindNetworkInContext(this._yapi, next_hwid);
  }
  static FirstNetwork() {
    let next_hwid = YAPI.imm_getFirstHardwareId("Network");
    if (next_hwid == null)
      return null;
    return YNetwork.FindNetwork(next_hwid);
  }
  static FirstNetworkInContext(yctx) {
    let next_hwid = yctx.imm_getFirstHardwareId("Network");
    if (next_hwid == null)
      return null;
    return YNetwork.FindNetworkInContext(yctx, next_hwid);
  }
};
YNetwork.READINESS_DOWN = 0;
YNetwork.READINESS_EXISTS = 1;
YNetwork.READINESS_LINKED = 2;
YNetwork.READINESS_LAN_OK = 3;
YNetwork.READINESS_WWW_OK = 4;
YNetwork.READINESS_INVALID = -1;
YNetwork.MACADDRESS_INVALID = YAPI.INVALID_STRING;
YNetwork.IPADDRESS_INVALID = YAPI.INVALID_STRING;
YNetwork.SUBNETMASK_INVALID = YAPI.INVALID_STRING;
YNetwork.ROUTER_INVALID = YAPI.INVALID_STRING;
YNetwork.CURRENTDNS_INVALID = YAPI.INVALID_STRING;
YNetwork.IPCONFIG_INVALID = YAPI.INVALID_STRING;
YNetwork.PRIMARYDNS_INVALID = YAPI.INVALID_STRING;
YNetwork.SECONDARYDNS_INVALID = YAPI.INVALID_STRING;
YNetwork.NTPSERVER_INVALID = YAPI.INVALID_STRING;
YNetwork.USERPASSWORD_INVALID = YAPI.INVALID_STRING;
YNetwork.ADMINPASSWORD_INVALID = YAPI.INVALID_STRING;
YNetwork.HTTPPORT_INVALID = YAPI.INVALID_UINT;
YNetwork.HTTPSPORT_INVALID = YAPI.INVALID_UINT;
YNetwork.SECURITYMODE_UNDEFINED = 0;
YNetwork.SECURITYMODE_LEGACY = 1;
YNetwork.SECURITYMODE_MIXED = 2;
YNetwork.SECURITYMODE_SECURE = 3;
YNetwork.SECURITYMODE_INVALID = -1;
YNetwork.DEFAULTPAGE_INVALID = YAPI.INVALID_STRING;
YNetwork.DISCOVERABLE_FALSE = 0;
YNetwork.DISCOVERABLE_TRUE = 1;
YNetwork.DISCOVERABLE_INVALID = -1;
YNetwork.WWWWATCHDOGDELAY_INVALID = YAPI.INVALID_UINT;
YNetwork.CALLBACKURL_INVALID = YAPI.INVALID_STRING;
YNetwork.CALLBACKMETHOD_POST = 0;
YNetwork.CALLBACKMETHOD_GET = 1;
YNetwork.CALLBACKMETHOD_PUT = 2;
YNetwork.CALLBACKMETHOD_INVALID = -1;
YNetwork.CALLBACKENCODING_FORM = 0;
YNetwork.CALLBACKENCODING_JSON = 1;
YNetwork.CALLBACKENCODING_JSON_ARRAY = 2;
YNetwork.CALLBACKENCODING_CSV = 3;
YNetwork.CALLBACKENCODING_YOCTO_API = 4;
YNetwork.CALLBACKENCODING_JSON_NUM = 5;
YNetwork.CALLBACKENCODING_EMONCMS = 6;
YNetwork.CALLBACKENCODING_AZURE = 7;
YNetwork.CALLBACKENCODING_INFLUXDB = 8;
YNetwork.CALLBACKENCODING_MQTT = 9;
YNetwork.CALLBACKENCODING_YOCTO_API_JZON = 10;
YNetwork.CALLBACKENCODING_PRTG = 11;
YNetwork.CALLBACKENCODING_INFLUXDB_V2 = 12;
YNetwork.CALLBACKENCODING_INVALID = -1;
YNetwork.CALLBACKTEMPLATE_OFF = 0;
YNetwork.CALLBACKTEMPLATE_ON = 1;
YNetwork.CALLBACKTEMPLATE_INVALID = -1;
YNetwork.CALLBACKCREDENTIALS_INVALID = YAPI.INVALID_STRING;
YNetwork.CALLBACKINITIALDELAY_INVALID = YAPI.INVALID_UINT;
YNetwork.CALLBACKSCHEDULE_INVALID = YAPI.INVALID_STRING;
YNetwork.CALLBACKMINDELAY_INVALID = YAPI.INVALID_UINT;
YNetwork.CALLBACKMAXDELAY_INVALID = YAPI.INVALID_UINT;
YNetwork.POECURRENT_INVALID = YAPI.INVALID_UINT;

// obj/full/Api/yocto_files.js
var YFileRecord = class {
  constructor(str_json) {
    this._name = "";
    this._size = 0;
    this._crc = 0;
    const loadval = JSON.parse(str_json);
    this._name = loadval.name;
    this._size = loadval.size;
    this._crc = loadval.crc;
  }
  get_name() {
    return this._name;
  }
  get_size() {
    return this._size;
  }
  get_crc() {
    return this._crc;
  }
};
var YFiles = class extends YFunction {
  constructor(yapi, func) {
    super(yapi, func);
    this._filesCount = YFiles.FILESCOUNT_INVALID;
    this._freeSpace = YFiles.FREESPACE_INVALID;
    this._valueCallbackFiles = null;
    this._ver = 0;
    this.FILESCOUNT_INVALID = YAPI.INVALID_UINT;
    this.FREESPACE_INVALID = YAPI.INVALID_UINT;
    this._className = "Files";
  }
  imm_parseAttr(name, val) {
    switch (name) {
      case "filesCount":
        this._filesCount = val;
        return 1;
      case "freeSpace":
        this._freeSpace = val;
        return 1;
    }
    return super.imm_parseAttr(name, val);
  }
  async get_filesCount() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YFiles.FILESCOUNT_INVALID;
      }
    }
    res = this._filesCount;
    return res;
  }
  async get_freeSpace() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YFiles.FREESPACE_INVALID;
      }
    }
    res = this._freeSpace;
    return res;
  }
  static FindFiles(func) {
    let obj;
    obj = YFunction._FindFromCache("Files", func);
    if (obj == null) {
      obj = new YFiles(YAPI, func);
      YFunction._AddToCache("Files", func, obj);
    }
    return obj;
  }
  static FindFilesInContext(yctx, func) {
    let obj;
    obj = YFunction._FindFromCacheInContext(yctx, "Files", func);
    if (obj == null) {
      obj = new YFiles(yctx, func);
      YFunction._AddToCache("Files", func, obj);
    }
    return obj;
  }
  async registerValueCallback(callback) {
    let val;
    if (callback != null) {
      await YFunction._UpdateValueCallbackList(this, true);
    } else {
      await YFunction._UpdateValueCallbackList(this, false);
    }
    this._valueCallbackFiles = callback;
    if (callback != null && await this.isOnline()) {
      val = this._advertisedValue;
      if (!(val == "")) {
        await this._invokeValueCallback(val);
      }
    }
    return 0;
  }
  async _invokeValueCallback(value) {
    if (this._valueCallbackFiles != null) {
      try {
        await this._valueCallbackFiles(this, value);
      } catch (e) {
        this._yapi.imm_log("Exception in valueCallback:", e);
      }
    } else {
      await super._invokeValueCallback(value);
    }
    return 0;
  }
  async sendCommand(command) {
    let url;
    url = "files.json?a=" + command;
    return await this._download(url);
  }
  async _getVersion() {
    let json;
    if (this._ver > 0) {
      return this._ver;
    }
    json = await this.sendCommand("info");
    if (json[0] != 123) {
      this._ver = 30;
    } else {
      this._ver = YAPIContext.imm_atoi(this.imm_json_get_key(json, "ver"));
    }
    return this._ver;
  }
  async format_fs() {
    let json;
    let res;
    json = await this.sendCommand("format");
    res = this.imm_json_get_key(json, "res");
    if (!(res == "ok")) {
      return this._throw(this._yapi.IO_ERROR, "format failed", this._yapi.IO_ERROR);
    }
    return this._yapi.SUCCESS;
  }
  async get_list(pattern) {
    let json;
    let filelist = [];
    let res = [];
    json = await this.sendCommand("dir&f=" + pattern);
    filelist = this.imm_json_get_array(json);
    res.length = 0;
    for (let ii_0 of filelist) {
      res.push(new YFileRecord(this._yapi.imm_bin2str(ii_0)));
    }
    return res;
  }
  async fileExist(filename) {
    let json;
    let filelist = [];
    if (filename.length == 0) {
      return false;
    }
    json = await this.sendCommand("dir&f=" + filename);
    filelist = this.imm_json_get_array(json);
    if (filelist.length > 0) {
      return true;
    }
    return false;
  }
  async download(pathname) {
    return await this._download(pathname);
  }
  async upload(pathname, content) {
    return await this._upload(pathname, content);
  }
  async remove(pathname) {
    let json;
    let res;
    json = await this.sendCommand("del&f=" + pathname);
    res = this.imm_json_get_key(json, "res");
    if (!(res == "ok")) {
      return this._throw(this._yapi.IO_ERROR, "unable to remove file", this._yapi.IO_ERROR);
    }
    return this._yapi.SUCCESS;
  }
  async get_content_crc(content) {
    let fsver;
    let sz;
    let blkcnt;
    let meta;
    let blkidx;
    let blksz;
    let part;
    let res;
    sz = content.length;
    if (sz == 0) {
      res = this._yapi.imm_bincrc(content, 0, 0);
      return res;
    }
    fsver = await this._getVersion();
    if (fsver < 40) {
      res = this._yapi.imm_bincrc(content, 0, sz);
      return res;
    }
    blkcnt = (sz + 255) / 256 >> 0;
    meta = new Uint8Array(4 * blkcnt);
    blkidx = 0;
    while (blkidx < blkcnt) {
      blksz = sz - blkidx * 256;
      if (blksz > 256) {
        blksz = 256;
      }
      part = this._yapi.imm_bincrc(content, blkidx * 256, blksz) ^ 4294967295;
      meta.set([part & 255], 4 * blkidx);
      meta.set([part >> 8 & 255], 4 * blkidx + 1);
      meta.set([part >> 16 & 255], 4 * blkidx + 2);
      meta.set([part >> 24 & 255], 4 * blkidx + 3);
      blkidx = blkidx + 1;
    }
    res = this._yapi.imm_bincrc(meta, 0, 4 * blkcnt) ^ 4294967295;
    return res;
  }
  nextFiles() {
    let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
    if (resolve.errorType != YAPI.SUCCESS)
      return null;
    let next_hwid = this._yapi.imm_getNextHardwareId(this._className, resolve.result);
    if (next_hwid == null)
      return null;
    return YFiles.FindFilesInContext(this._yapi, next_hwid);
  }
  static FirstFiles() {
    let next_hwid = YAPI.imm_getFirstHardwareId("Files");
    if (next_hwid == null)
      return null;
    return YFiles.FindFiles(next_hwid);
  }
  static FirstFilesInContext(yctx) {
    let next_hwid = yctx.imm_getFirstHardwareId("Files");
    if (next_hwid == null)
      return null;
    return YFiles.FindFilesInContext(yctx, next_hwid);
  }
};
YFiles.FILESCOUNT_INVALID = YAPI.INVALID_UINT;
YFiles.FREESPACE_INVALID = YAPI.INVALID_UINT;

// obj/full/constants.js
var constants = class {
  static get buildVersion() {
    return "1.11.10136";
  }
  static get deviceScreenWidth() {
    return screen.width * window.devicePixelRatio;
  }
  static get deviceScreenHeight() {
    return screen.height * window.devicePixelRatio;
  }
  static get isPhoneOrTablet() {
    return constants.ScreenDPI > 96 && Math.max(constants.deviceScreenWidth, constants.deviceScreenHeight) / constants.ScreenDPI < 12;
  }
  static get captureSizePolicy() {
    return constants._defaultCaptureSizePolicy;
  }
  static set captureSizePolicy(value) {
    constants._defaultCaptureSizePolicy = value;
  }
  static get dbleClickBringsUpContextMenu() {
    return constants._defaulDbleClickBringsUpContextMenu;
  }
  static set dbleClickBringsUpContextMenu(value) {
    constants._defaulDbleClickBringsUpContextMenu = value;
  }
  static get maxPointsPerGraphSerie() {
    return constants._defaultMaxPointsPerGraphSerie;
  }
  static set maxPointsPerGraphSerie(value) {
    if (value >= 0)
      constants._defaultMaxPointsPerGraphSerie = value >> 0;
  }
  static get maxPointsPerDataloggerSerie() {
    return constants._defaultMaxPointsPerDataloggerSerie;
  }
  static set maxPointsPerDataloggerSerie(value) {
    if (value >= -1)
      constants._defaultMaxPointsPerDataloggerSerie = value >> 0;
  }
  static get maxDataRecordsPerSensor() {
    return constants._defaultMaxDataRecordsPerSensor;
  }
  static set maxDataRecordsPerSensor(value) {
    if (value >= 0)
      constants._defaultMaxDataRecordsPerSensor = value >> 0;
  }
  static get captureWidth() {
    return constants._defaultCaptureWidth;
  }
  static set captureWidth(value) {
    if (value > 0)
      constants._defaultCaptureWidth = value;
  }
  static get captureHeight() {
    return constants._defaultCaptureHeight;
  }
  static set captureHeight(value) {
    if (value > 0)
      constants._defaultCaptureHeight = value;
  }
  static get captureDPI() {
    return constants._defaultCaptureDPI;
  }
  static set captureDPI(value) {
    if (value > 0)
      constants._defaultCaptureDPI = value;
  }
  static get captureType() {
    return constants._defaultCaptureType;
  }
  static set captureType(value) {
    constants._defaultCaptureType = value;
  }
  static get generalFontFamily() {
    return constants.FontFamily;
  }
  static get generalFontSize() {
    return constants.FontSize;
  }
  static get generalSizeCoef() {
    return constants.FontSize / 12;
  }
  static get screenDPI() {
    return constants.ScreenDPI;
  }
  static get guiDPIFactor() {
    return constants.DPIfactor;
  }
  static get guiDPIFactorWasOverriden() {
    return constants.DPIfactorOverriden;
  }
  static get guiDPIFactorIsOverriden() {
    let vs = constants.getCookie(constants.DPIFactorKey);
    if (vs == null)
      return false;
    let v = parseFloat(vs);
    if (v > 0)
      return true;
    return false;
  }
  static get guiDPIFactorOverrideValue() {
    let vs = constants.getCookie(constants.DPIFactorKey);
    if (vs == null)
      return constants.DPIfactor;
    let v = parseFloat(vs);
    if (v > 0)
      return v;
    return constants.DPIfactor;
  }
  static overrideGuiDPIFactor(override, value) {
    if (override && typeof value !== "undefined") {
      constants.setCookie(constants.DPIFactorKey, value.toString(), 3650);
    } else {
      constants.setCookie(constants.DPIFactorKey, "none", 3650);
    }
  }
  static get RunningOnAndroid() {
    return constants.isAndroid;
  }
  static get WindowBackgroundColor() {
    return "#f0f0f0";
  }
  static get WindowBorder() {
    return "1px solid #808080";
  }
  static get WindowPadding() {
    return 2;
  }
  static get WindowInnerBorderColor() {
    return " #A0A0A0";
  }
  static get WindowInnerBackgroundColor() {
    return "#fAfAfA";
  }
  static get WindowInnerBorder() {
    return "1px solid " + constants.WindowInnerBorderColor;
  }
  static get WindowHeaderBackgroundColor() {
    return "#0072ca";
  }
  static get WindowHeaderColor() {
    return "white";
  }
  static get WindowHeaderBorder() {
    return "1px solid #0072ca";
  }
  static get WindowHeaderHeight() {
    return 20;
  }
  static get WindowHeaderFontSize() {
    return 8 * constants.FontSize / 6;
  }
  static get WindowHeaderFontFamily() {
    return constants.FontFamily;
  }
  static get mustCheckForUpdate() {
    return constants._checkForUpdate;
  }
  static set mustCheckForUpdate(value) {
    if (value != constants._checkForUpdate) {
      constants._checkForUpdate = value;
      constants.edited = true;
    }
  }
  static get edited() {
    return constants._edited;
  }
  static set edited(value) {
    if (constants._edited != value) {
      constants._edited = value;
      YWebPage.ShowSaveReminder(value);
    }
  }
  static InitColorHistory(node) {
    let nodes = node.get_childsByIndex();
    for (let i = 0; i < nodes.length; i++) {
      let node2 = nodes[i];
      switch (nodes[i].Name) {
        case "Color":
          try {
            let colordef = node2.Attributes["value"];
            let color = YColor.FromString(colordef);
            if (color != null)
              colorEditor.AddColorToHistory(color);
          } catch (_a) {
          }
      }
    }
  }
  static findDPI() {
    let DPI = 1;
    while (!matchMedia("(max-resolution: " + DPI.toString() + "dpi)").matches) {
      DPI = DPI << 1;
    }
    let a = DPI >> 1;
    let b = DPI;
    while (b - a > 1) {
      let pivot = b + a >> 1;
      if (matchMedia("(max-resolution: " + pivot.toString() + "dpi)").matches) {
        b = pivot;
      } else {
        a = pivot;
      }
    }
    return b * (constants.isAndroid ? window.devicePixelRatio : 1);
  }
  static InitCaptureParams(node) {
    let nodes = node.get_childsByName();
    for (let nodeName in nodes) {
      let node2 = nodes[nodeName];
      let value;
      switch (nodeName) {
        case "Target":
          if ("value" in node2.Attributes) {
            constants._captureTarget = YDataRenderer.CaptureTarget.fromString(YDataRenderer.CaptureTarget, node2.Attributes["value"]);
          }
          break;
        case "Type":
          if ("value" in node2.Attributes) {
            constants._defaultCaptureType = YDataRenderer.CaptureType.fromString(YDataRenderer.CaptureType, node2.Attributes["value"]);
          }
          break;
        case "Size":
          if ("value" in node2.Attributes) {
            constants._defaultCaptureSizePolicy = YDataRenderer.CaptureFormats.fromString(YDataRenderer.CaptureFormats, node2.Attributes["value"]);
          }
          break;
        case "Resolution":
          if ("value" in node2.Attributes) {
            constants.captureDPI = parseInt(node2.Attributes["value"]);
          }
          break;
        case "Width":
          if ("value" in node2.Attributes) {
            constants.captureWidth = value = parseInt(node2.Attributes["value"]);
          }
          break;
        case "Height":
          if ("value" in node2.Attributes) {
            constants.captureHeight = parseInt(node2.Attributes["value"]);
          }
          break;
        case "Folder":
          if ("value" in node2.Attributes) {
            constants._captureFolder = node2.Attributes["value"];
          }
          break;
      }
    }
  }
  static InitUIParams(node) {
    let nodes = node.get_childsByName();
    for (let nodeName in nodes) {
      let node2 = nodes[nodeName];
      switch (nodeName) {
        case "VerticalDragZoom":
          if ("value" in node2.Attributes) {
            YGraph.verticalDragZoomEnabled = node2.Attributes["value"].toUpperCase() == "TRUE";
          }
          break;
        case "DbleClickContextMenu":
          if ("value" in node2.Attributes) {
            constants.dbleClickBringsUpContextMenu = node2.Attributes["value"].toUpperCase() == "TRUE";
          }
          break;
      }
    }
  }
  static InitCheckForUpdateParams(node) {
    let nodes = node.get_childsByName();
    for (let nodeName in nodes) {
      let node2 = nodes[nodeName];
      switch (nodeName) {
        case "checkForUpdate":
          if ("value" in node2.Attributes) {
            constants._checkForUpdate = node2.Attributes["value"].toUpperCase() == "TRUE";
          }
          break;
        case "ignoreBuild":
          if ("value" in node2.Attributes) {
            constants._ignoreBuild = parseInt(node2.Attributes["value"].toUpperCase());
          }
          break;
      }
    }
  }
  static InitMemoryUsageParams(node) {
    let nodes = node.get_childsByName();
    for (let nodeName in nodes) {
      let node2 = nodes[nodeName];
      switch (nodeName) {
        case "maxPointsPerGraphSerie":
          if ("value" in node2.Attributes) {
            let value = parseInt(node2.Attributes["value"]);
            constants.maxPointsPerGraphSerie = value;
            DataSerie.MaxPointsPerSeries = value;
          }
          break;
        case "maxDataRecordsPerSensor":
          if ("value" in node2.Attributes) {
            let value = parseInt(node2.Attributes["value"]);
            if (value >= 0) {
              constants.maxDataRecordsPerSensor = value;
              CustomYSensor.MaxDataRecords = value;
            }
          }
          break;
        case "maxPointsPerDataloggerSerie":
          if ("value" in node2.Attributes) {
            let value = parseInt(node2.Attributes["value"]);
            constants.maxPointsPerDataloggerSerie = value;
            CustomYSensor.MaxLoggerRecords = value;
          }
          break;
        case "deviceListValidity":
          if ("value" in node2.Attributes) {
            let value = parseInt(node2.Attributes["value"]);
            if (value > 0) {
              constants._deviceListValidity = value;
              YAPI.SetDeviceListValidity(value).then();
            }
          }
          break;
      }
    }
  }
  static Init(initData) {
    let nodes = initData.get_childsByName();
    for (let nodeName in nodes) {
      let node = nodes[nodeName];
      switch (nodeName) {
        case "UseUSB":
          if ("value" in node.Attributes) {
            constants._useUSB = node.Attributes["value"].toUpperCase() == "TRUE";
          }
          break;
        case "Colors":
          constants.InitColorHistory(node);
          break;
        case "Capture":
          constants.InitCaptureParams(node);
          break;
        case "UI":
          constants.InitUIParams(node);
          break;
        case "Updates":
          constants.InitCheckForUpdateParams(node);
          break;
        case "MemoryUsage":
          constants.InitMemoryUsageParams(node);
          break;
        case "UseVirtualHub":
          if ("value" in node.Attributes) {
            constants._useVirtualHub = node.Attributes["value"].toUpperCase() == "TRUE";
          }
          break;
        case "Hubs":
          sensorsManager.InitHubList(node);
          break;
      }
    }
  }
  static get CRCTable() {
    if (constants._crcTable != null)
      return constants._crcTable;
    constants._crcTable = [];
    let c;
    var crcTable = [];
    for (var n = 0; n < 256; n++) {
      c = n;
      for (var k = 0; k < 8; k++) {
        c = c & 1 ? 3988292384 ^ c >>> 1 : c >>> 1;
      }
      constants._crcTable[n] = c;
    }
    return constants._crcTable;
  }
  static crc32(str) {
    var crcTable = constants.CRCTable;
    var crc = 0 ^ -1;
    for (var i = 0; i < str.length; i++) {
      crc = crc >>> 8 ^ crcTable[(crc ^ str.charCodeAt(i)) & 255];
    }
    return (crc ^ -1) >>> 0;
  }
  static setCookie(cname, cvalue, exdays) {
    let d = new Date();
    d.setTime(d.getTime() + exdays * 24 * 60 * 60 * 1e3);
    let expires = "expires=" + d.toUTCString();
    document.cookie = cname + "=" + cvalue + ";" + expires + ";path=/";
  }
  static getCookie(cname) {
    let name = cname + "=";
    let decodedCookie = decodeURIComponent(document.cookie);
    let ca = decodedCookie.split(";");
    for (let i = 0; i < ca.length; i++) {
      let c = ca[i];
      while (c.charAt(0) == " ") {
        c = c.substring(1);
      }
      if (c.indexOf(name) == 0) {
        return c.substring(name.length, c.length);
      }
    }
    return null;
  }
  static XMLquote(st) {
    return st.replace("'", "&apos;").replace('"', "&quot;");
  }
  static GetXMLConfiguration() {
    let res = '<Config>\n  <UseUSB value="' + (constants._useUSB ? "TRUE" : "FALSE") + '"/>\n  <UseVirtualHub value="' + (constants._useVirtualHub ? "TRUE" : "FALSE") + '"/>\n  <Hubs>\n';
    res += sensorsManager.getXmlHublist();
    res += "  </Hubs>\n";
    res += "  <Colors>\n";
    for (let i = 0; i < colorEditor.colorHistory.length; i++) {
      res = res + '    <Color value="' + colorEditor.colorHistory[i].toString() + '"/>\n';
    }
    res += "  </Colors>\n";
    res += "  <MemoryUsage>\n";
    res += '    <maxPointsPerGraphSerie value= "' + constants.maxPointsPerGraphSerie.toString() + '"/>\n';
    res += '    <maxDataRecordsPerSensor value= "' + constants.maxDataRecordsPerSensor.toString() + '"/>\n';
    res += '    <maxPointsPerDataloggerSerie value= "' + constants.maxPointsPerDataloggerSerie.toString() + '"/>\n';
    res += '    <deviceListValidity value= "' + constants._deviceListValidity.toString() + '"/>\n';
    res += "  </MemoryUsage>\n";
    res += "  <Capture>\n";
    res += '    <Target value= "' + constants._captureTarget.toString + '"/>\n';
    res += '    <Type value= "' + constants.captureType.toString + '"/>\n';
    res += '    <Size value= "' + constants.captureSizePolicy.toString + '"/>\n';
    res += '    <Resolution value= "' + constants.captureDPI.toString() + '"/>\n';
    res += '    <Folder value= "' + constants.XMLquote(constants._captureFolder) + '"/>\n';
    res += '    <Width value= "' + constants.captureWidth.toString() + '"/>\n';
    res += '    <Height value= "' + constants.captureHeight.toString() + '"/>\n';
    res += "  </Capture>\n";
    res += "  <Updates>\n";
    res += '    <checkForUpdate  value = "' + (constants._checkForUpdate ? "True" : "False") + '"/>\n';
    res += '    <ignoreBuild  value = "' + constants._ignoreBuild.toString() + '"/>\n';
    res += "  </Updates>\n";
    res += "  <UI>\n";
    res += '    <VerticalDragZoom value= "' + (YGraph.verticalDragZoomEnabled ? "True" : "False") + '"/>\n';
    res += '    <DbleClickContextMenu value= "' + (constants.dbleClickBringsUpContextMenu ? "True" : "False") + '"/>\n';
    res += "  </UI>\n";
    res += "</Config>\n";
    return res;
  }
};
constants.DPIFactorKey = "YoctoVisualization4WebDPIFactor";
constants.isAndroid = navigator.userAgent.toLowerCase().indexOf("android") >= 0;
constants.ScreenDPI = constants.findDPI();
constants.FontFamily = "Arial, Helvetica, sans-serif";
constants.DPIfactorCookieValue = constants.getCookie(constants.DPIFactorKey);
constants.DPIfactorOverriden = constants.DPIfactorCookieValue != null;
constants.DPIfactor = constants.DPIfactorOverriden && parseFloat(constants.DPIfactorCookieValue) > 0 ? parseFloat(constants.DPIfactorCookieValue) : constants.isPhoneOrTablet ? Math.round(10 * constants.ScreenDPI / (96 * 1.2)) / 10 : 1;
constants.FontSize = 12 * constants.DPIfactor;
constants._defaultCaptureType = YDataRenderer.CaptureType.PNG;
constants._defaultCaptureWidth = 1024;
constants._defaultCaptureHeight = 1024;
constants._defaultCaptureDPI = 70;
constants._defaultCaptureSizePolicy = YDataRenderer.CaptureFormats.Keep;
constants._defaultMaxPointsPerGraphSerie = 0;
constants._defaultMaxPointsPerDataloggerSerie = 0;
constants._defaultMaxDataRecordsPerSensor = 0;
constants._defaulDbleClickBringsUpContextMenu = false;
constants._useUSB = true;
constants._useVirtualHub = false;
constants._captureTarget = YDataRenderer.CaptureTarget.ToFile;
constants._captureFolder = "";
constants._checkForUpdate = true;
constants._ignoreBuild = 0;
constants._deviceListValidity = 3600;
constants._edited = false;
constants._crcTable = null;

// obj/full/sensorManager.js
var Hub = class {
  static Decrypt(data, loginCypherPassword) {
    if (data == "")
      return "";
    if (data.length % 4)
      return "";
    let buffer = new Uint16Array(data.length >> 2);
    for (let i = 0; i < buffer.length; i++) {
      buffer[i] = parseInt(data.slice(i * 4, i * 4 + 4), 16);
    }
    let checksum = buffer[0];
    for (let i = 1; i < buffer.length - 1; i++) {
      checksum ^= buffer[i];
    }
    if (checksum != buffer[buffer.length - 1])
      return "";
    let res = "";
    for (let i = 0; i < buffer.length - 2; i++) {
      res += String.fromCharCode(buffer[i + 1] & 255 ^ loginCypherPassword.charCodeAt(i % loginCypherPassword.length) ^ buffer[0] + i & 255 ^ (buffer[i + 1] & 2048) >> 11 << ((buffer[i + 1] & 1792) >> 8) ^ (buffer[i + 1] & 32768) >> 15 << ((buffer[i + 1] & 28672) >> 12));
    }
    return res;
  }
  static Encrypt(data, loginCypherPassword) {
    if (data == "")
      return "";
    let buffer = crypto.getRandomValues(new Uint16Array(data.length + 2));
    for (let i = 0; i < data.length; i++) {
      buffer[i + 1] = buffer[i + 1] & 65280 | data.charCodeAt(i) ^ loginCypherPassword.charCodeAt(i % loginCypherPassword.length) ^ buffer[0] + i & 255 ^ (buffer[i + 1] & 2048) >> 11 << ((buffer[i + 1] & 1792) >> 8) ^ (buffer[i + 1] & 32768) >> 15 << ((buffer[i + 1] & 28672) >> 12);
    }
    buffer[buffer.length - 1] = buffer[0];
    for (let i = 1; i < buffer.length - 1; i++) {
      buffer[buffer.length - 1] ^= buffer[i];
    }
    let res = "";
    for (let i = 0; i < buffer.length; i++) {
      res += ("000" + buffer[i].toString(16)).slice(-4).toUpperCase();
    }
    return res;
  }
  static encryptPassword(clearPassword) {
    return clearPassword == "" ? "" : Hub.Encrypt(clearPassword, Hub.loginCypherPassword);
  }
  get hubType() {
    return this._hubType;
  }
  set hubType(value) {
    this._hubType = value;
  }
  get protocol() {
    return this._protocol;
  }
  set protocol(value) {
    this._protocol = value;
  }
  get user() {
    return this._user;
  }
  set user(value) {
    this._user = value;
  }
  get encryptedPassword() {
    return this._password;
  }
  set encryptedPassword(value) {
    this._password = value;
  }
  get clearPassword() {
    return this._password == "" ? "" : Hub.Decrypt(this._password, Hub.loginCypherPassword);
  }
  set clearPassword(value) {
    this._password = value == "" ? "" : Hub.encryptPassword(value);
  }
  get addr() {
    return this._addr;
  }
  set addr(value) {
    this._addr = value;
  }
  get port() {
    return this._port;
  }
  set port(value) {
    this._port = value;
  }
  get removable() {
    return this._removable;
  }
  set removable(value) {
    this._removable = value;
  }
  get path() {
    return this._path;
  }
  set path(value) {
    this._path = value;
  }
  async ConnectionState() {
    if (this._apiHub != null) {
      if (await this._apiHub.get_errorType() != YAPI_SUCCESS) {
        this._state = 3;
      }
    }
    return this._state;
  }
  async ConnectionDescription() {
    switch (this._state) {
      case 1:
        if (this._apiHub != null) {
          if (await this._apiHub.get_errorType() != YAPI_SUCCESS) {
            this._state = 3;
            return await this._apiHub.get_errorMessage();
          }
        }
        return "Connecting..";
        break;
      case 2:
        return (this._logicname != "" ? this._logicname : this._netname) + " OK";
      case 3:
        if (this._apiHub != null)
          return await this._apiHub.get_errorMessage();
        return "Connection failed ";
      default:
        return "Not connected.";
    }
  }
  constructor(hubType, protocol, user, password, clearPassword, addr, port, path, removeable) {
    this._netname = "";
    this._module = null;
    this._logicname = "";
    this._previousURL = "";
    this._previousobfuscatedURL = "";
    this._apiHub = null;
    this._hubType = 2;
    this._protocol = "";
    this._user = "";
    this._password = "";
    this._addr = "";
    this._port = "";
    this._removable = true;
    this._path = "";
    this._state = 0;
    while (/^\//.test(path)) {
      path = path.slice(1);
    }
    while (/\/$/.test(path)) {
      path = path.slice(0, -1);
    }
    this._hubType = hubType;
    this._protocol = protocol;
    this._user = user;
    this._port = port;
    this._password = clearPassword ? password != "" ? Hub.Encrypt(password, Hub.loginCypherPassword) : "" : password;
    this._addr = addr;
    this._path = path;
    this._removable = typeof removeable === "undefined" ? true : removeable;
  }
  static HubFromXml(subnode) {
    let hubType = 2;
    let protocol = "ws";
    let removable = true;
    if ("protocol" in subnode.Attributes)
      protocol = subnode.Attributes["protocol"];
    let user = "";
    if ("user" in subnode.Attributes)
      user = subnode.Attributes["user"];
    let password = "";
    if ("password" in subnode.Attributes)
      password = subnode.Attributes["password"];
    let port = "";
    if ("port" in subnode.Attributes)
      port = subnode.Attributes["port"];
    let path = "";
    if ("path" in subnode.Attributes)
      path = subnode.Attributes["path"];
    let addr = "";
    if ("addr" in subnode.Attributes)
      addr = subnode.Attributes["addr"];
    if ("removable" in subnode.Attributes)
      removable = subnode.Attributes["removable"].toUpperCase() == "TRUE";
    return new Hub(hubType, protocol, user, password, false, addr, port, path, removable);
  }
  async Connect() {
    let errmsg = new YErrorMsg();
    this._state = 1;
    logForm.log("preregistering  " + this.get_obfuscatedURL());
    if (!YWebPage.readonly)
      configForm.hubStateChanged(this);
    let url = this.get_fullUrl();
    if (await YAPI.PreregisterHub(url, errmsg) != YAPI_SUCCESS) {
      logForm.log("[!] preregistering  " + this.get_obfuscatedURL() + " failed (" + errmsg.msg + ")");
      this._state = 3;
      this._previousURL = "";
      this._previousobfuscatedURL = "";
    } else {
      let h = YHub.FirstHubInUse();
      while (h != null) {
        if (await this.matches(h))
          this._apiHub = h;
        h = h.nextHubInUse();
      }
      this._previousURL = url;
      this._previousobfuscatedURL = this.get_obfuscatedURL();
    }
    if (!YWebPage.readonly)
      configForm.hubStateChanged(this);
  }
  async Disconnect() {
    if (this._previousURL == "")
      return;
    logForm.log("Unregistering  " + this._previousobfuscatedURL);
    await YAPI.UnregisterHub(this._previousURL);
    this._previousURL = "";
    this._previousobfuscatedURL = "";
    this._state = 0;
    this._apiHub = null;
    if (!YWebPage.readonly)
      configForm.hubStateChanged(this);
  }
  arrival(ip, netname, module, logicname) {
    this._state = 2;
    this._netname = netname;
    this._module = module;
    this._logicname = logicname;
    this._state = 2;
    if (!YWebPage.readonly) {
      configForm.hubStateChanged(this);
    }
  }
  get address() {
    return this._addr;
  }
  get_consoleUrl() {
    let fullurl = this._protocol + "://" + this._addr;
    if (this._port != "")
      fullurl = fullurl + ":" + this._port;
    return fullurl;
  }
  toString() {
    return this.get_consoleUrl();
  }
  get_fullUrl() {
    let fullurl = "";
    if (this._protocol != "")
      fullurl = this._protocol + "://";
    if (this._user != "") {
      fullurl = fullurl + this._user;
      if (this._password != "")
        fullurl = fullurl + ":" + Hub.Decrypt(this._password, Hub.loginCypherPassword);
      fullurl = fullurl + "@";
    }
    fullurl = fullurl + this._addr;
    if (this._port != "")
      fullurl = fullurl + ":" + this._port;
    else
      fullurl = fullurl + ":4444";
    fullurl = fullurl + "/";
    if (this._path) {
      fullurl = fullurl + this._path + "/";
    }
    return fullurl;
  }
  get_connexionUrl() {
    let fullurl;
    if (this._protocol != "")
      fullurl = this._protocol + "://";
    else
      fullurl = "ws://";
    fullurl = fullurl + this._addr;
    if (this._port != "")
      fullurl = fullurl + ":" + this._port;
    else
      fullurl = fullurl + ":4444";
    fullurl = fullurl + "/";
    return fullurl.toLowerCase();
  }
  get_obfuscatedURL() {
    let fullurl = "";
    if (this._protocol != "")
      fullurl = this._protocol + "://";
    if (this._user != "") {
      fullurl = fullurl + this._user;
      if (this._password != "")
        fullurl = fullurl + ":#####";
      fullurl = fullurl + "@";
    }
    fullurl = fullurl + this._addr;
    if (this._port != "")
      fullurl = fullurl + ":" + this._port;
    if (this._path != "")
      fullurl = fullurl + "/" + this._path;
    return fullurl;
  }
  async matches(apihub) {
    let URL1 = this.get_connexionUrl() + this._path;
    let URL2 = await apihub.get_connectionUrl();
    if (URL1.slice(-1) == "/")
      URL1 = URL1.substr(0, URL1.length - 1);
    if (URL2.slice(-1) == "/")
      URL2 = URL2.substr(0, URL2.length - 1);
    return URL1 == URL2;
  }
  XmlCode() {
    let NodeLine = "<Hub ";
    if (this._protocol != "")
      NodeLine = NodeLine + 'protocol="' + constants.XMLquote(this._protocol) + '" ';
    if (this._user != "")
      NodeLine = NodeLine + 'user="' + constants.XMLquote(this._user) + '" ';
    if (this._password != "")
      NodeLine = NodeLine + 'password="' + constants.XMLquote(this._password) + '" ';
    NodeLine = NodeLine + 'addr="' + constants.XMLquote(this._addr) + '" ';
    if (this._port != "")
      NodeLine = NodeLine + 'port="' + constants.XMLquote(this.port) + '" ';
    if (this._path != "")
      NodeLine = NodeLine + 'path="' + constants.XMLquote(this._path) + '" ';
    if (!this._removable)
      NodeLine = NodeLine + 'removable="FALSE" ';
    return NodeLine + "/>";
  }
};
Hub.loginCypherPassword = "+>*X[?_ih$N7wA!}";
var TimedSensorValue = class {
  constructor(DateTime, value) {
    this._DateTime = DateTime;
    this._value = value;
  }
  get DateTime() {
    return this._DateTime;
  }
  get value() {
    return this._value;
  }
};
var AlarmSettings = class {
  static ExecuteCommand(source, command) {
  }
  constructor(index, owner, xmldata) {
    this.index = 0;
    this.Condition = 0;
    this.Source = 0;
    this.Value = 0;
    this.Delay = 15;
    this.Commandline = "";
    this.lastAlarm = new Date(0);
    this.index = index;
    this.parent = owner;
    if (typeof xmldata !== "undefined") {
      if ("Source" in xmldata.Attributes)
        this.Source = parseInt(xmldata.Attributes["Source"]);
      if ("Condition" in xmldata.Attributes)
        this.Condition = parseInt(xmldata.Attributes["Condition"]);
      if ("Value" in xmldata.Attributes)
        this.Value = parseFloat(xmldata.Attributes["Value"]);
      if ("Cmd" in xmldata.Attributes)
        this.Commandline = xmldata.Attributes["Cmd"];
      if ("Delay" in xmldata.Attributes)
        this.Delay = parseInt(xmldata.Attributes["Delay"]);
    }
  }
  getXmlData() {
    return '<Alarm Source="' + this.Source.toString() + '" Condition="' + this.Condition.toString() + '" Value="' + this.Value.toString() + '" Cmd="' + GenericProperties.escapeXml(this.Commandline) + '" Delay="' + this.Delay.toString() + '"/>\n';
  }
  setCondition(condition) {
    this.Condition = condition;
  }
  getCondition() {
    return this.Condition;
  }
  setSource(source) {
    this.Source = source;
  }
  getSource() {
    return this.Source;
  }
  setValue(value) {
    this.Value = value;
  }
  getValue() {
    return this.Value;
  }
  setDelay(value) {
    if (value < 0)
      throw "delay must be a positive value";
    this.Delay = value;
  }
  getDelay() {
    return this.Delay;
  }
  setCommandline(value) {
    this.Commandline = value;
  }
  getCommandline() {
    return this.Commandline;
  }
  check(m) {
    let alarm = false;
    let reason = "";
    let src;
    let SensorValue;
    switch (this.Source) {
      case 1:
        src = "MIN";
        SensorValue = m.get_minValue();
        break;
      case 2:
        src = "MAX";
        SensorValue = m.get_maxValue();
        break;
      default:
        src = "AVG";
        SensorValue = m.get_averageValue();
        break;
    }
    switch (this.Condition) {
      default:
        return;
      case 1:
        reason = ">";
        if (SensorValue > this.Value)
          alarm = true;
        break;
      case 2:
        reason = ">=";
        if (SensorValue >= this.Value)
          alarm = true;
        break;
      case 3:
        reason = "=";
        if (SensorValue == this.Value)
          alarm = true;
        break;
      case 4:
        reason = "<=";
        if (SensorValue <= this.Value)
          alarm = true;
        break;
      case 5:
        reason = "<";
        if (SensorValue < this.Value)
          alarm = true;
        break;
    }
    let now = new Date();
    if (!alarm)
      return;
    if (now.getTime() - this.lastAlarm.getTime() < 1e3 * this.Delay)
      return;
    let source = "ALARM " + (this.index + 1).toString();
    logForm.log(source + " on " + this.parent.get_hardwareId() + "/" + this.parent.get_friendlyName() + " (" + SensorValue.toString() + reason + this.Value.toString() + ")");
    let Execute = this.Commandline;
    Execute = Execute.replace("$SENSORVALUE$", SensorValue.toString());
    Execute = Execute.replace("$HWDID$", this.parent.get_hardwareId());
    Execute = Execute.replace("$NAME$", this.parent.get_friendlyName());
    Execute = Execute.replace("$UNIT$", this.parent.get_unit());
    Execute = Execute.replace("$CONDITION$", reason);
    Execute = Execute.replace("$DATATYPE$", src);
    Execute = Execute.replace("$TRIGGER$", this.Value.toString());
    Execute = Execute.replace("$NOW$", logForm.dateToString(now));
    try {
      Function(Execute)();
    } catch (e) {
      logForm.log("ALARM " + (this.index + 1) + " code (" + Execute + ") caused an exception :" + e.message);
    }
    this.lastAlarm = now;
  }
};
var DataLoggerBoundary = class {
  constructor(start, stop) {
    this._start = 0;
    this._stop = 0;
    this._start = start;
    this._stop = stop;
  }
  get start() {
    return this._start;
  }
  get stop() {
    return this._stop;
  }
};
var MergeSourceRange = class {
  constructor(start, stop) {
    this.MergeSourceStart = 0;
    this.MergeSourceStop = 0;
    this.MergeSourceStart = start;
    this.MergeSourceStop = stop;
  }
};
var CustomYSensor = class {
  get isReadOnly() {
    return this._readonly || !this._online;
  }
  get dataloggerLoadisRunning() {
    return this._dataloggerLoadisRunning;
  }
  get dataloggerLoadProgress() {
    return this._dataloggerLoadProgress;
  }
  setDataloggerLoadProgress(value) {
    this._dataloggerLoadProgress = value;
    for (let i = 0; i < this.FormsToNotify.length; i++) {
      if (this.FormsToNotify[i] instanceof graphWidget) {
        this.FormsToNotify[i].dataLoggerLoadprocessIsRunningNotification(this);
      }
    }
  }
  static get MaxDataRecords() {
    return CustomYSensor._MaxDataRecords;
  }
  static set MaxDataRecords(value) {
    CustomYSensor._MaxDataRecords = value;
  }
  static get MaxLoggerRecords() {
    return CustomYSensor._MaxLoggerRecords;
  }
  static set MaxLoggerRecords(value) {
    CustomYSensor._MaxLoggerRecords = value;
  }
  get_lastAvgValue() {
    if (this._online)
      return this._lastAvgValue;
    return Number.NaN;
  }
  get_lastMaxValue() {
    if (this._online)
      return this._lastMaxValue;
    return Number.NaN;
  }
  get_lastMinValue() {
    if (this._online)
      return this._lastMinValue;
    return Number.NaN;
  }
  async ConfigHasChanged() {
    this.cfgChgNotificationsSupported = true;
    this.mustReloadConfig = true;
    this._online = true;
    await this.reloadConfig();
    await this.forceUpdate();
  }
  constructor(s, name, SensorLocalConfig) {
    this.unit = "";
    this._frequency = "";
    this.resolution = 1;
    this._recording = false;
    this._online = false;
    this.preloadDone = false;
    this.loadDone = false;
    this.cfgChgNotificationsSupported = false;
    this.mustReloadConfig = false;
    this._readonly = false;
    this._plzCancelDataloggerLoading = false;
    this._predloadProcessIsBusy = false;
    this._loadProcessIsBusy = false;
    this.lastGetConfig = 0;
    this.recordedDataLoadProgress = 0;
    this.recordedData = null;
    this.dataLoggerFeature = false;
    this.dataLoggerLoadCompleted = false;
    this.loadFailed = false;
    this.loadCanceled = false;
    this.firstLiveDataTimeStamp = 0;
    this.firstDataloggerTimeStamp = 0;
    this.lastDataTimeStamp = 0;
    this.lastDataSource = "";
    this.consecutiveBadTimeStamp = 0;
    this.minData = [];
    this.curData = [];
    this.maxData = [];
    this.previewMinData = [];
    this.previewCurData = [];
    this.previewMaxData = [];
    this._lastAvgValue = Number.NaN;
    this._lastMinValue = Number.NaN;
    this._lastMaxValue = Number.NaN;
    this._dataloggerLoadisRunning = true;
    this._dataloggerLoadProgress = 0;
    this.dataLoggerStartReadTime = 0;
    this.Alarms = [];
    this.FormsToNotify = [];
    this.sensor = s;
    this.hwdName = name;
    this._friendlyname = name;
    if (s == null)
      return;
    if (SensorLocalConfig != null) {
      let index = 0;
      let childs = SensorLocalConfig.get_childsByIndex();
      for (let i = 0; i < childs.length; i++) {
        let n = childs[i];
        if (n.Name == "Alarm") {
          this.checkAlarmIndex(index);
          this.Alarms[index] = new AlarmSettings(index, this, n);
          index++;
        }
      }
    }
  }
  checkAlarmIndex(index) {
    while (this.Alarms.length < index + 1) {
      this.Alarms.push(new AlarmSettings(this.Alarms.length, this));
    }
  }
  getAlarmCount() {
    return this.Alarms.length;
  }
  setAlarmCondition(index, condition) {
    this.checkAlarmIndex(index);
    this.Alarms[index].setCondition(condition);
  }
  getAlarmCondition(index) {
    this.checkAlarmIndex(index);
    return this.Alarms[index].getCondition();
  }
  setAlarmSource(index, source) {
    this.checkAlarmIndex(index);
    this.Alarms[index].setSource(source);
  }
  getAlarmSource(index) {
    this.checkAlarmIndex(index);
    return this.Alarms[index].getSource();
  }
  setAlarmValue(index, value) {
    this.checkAlarmIndex(index);
    this.Alarms[index].setValue(value);
  }
  getAlarmValue(index) {
    this.checkAlarmIndex(index);
    return this.Alarms[index].getValue();
  }
  setAlarmDelay(index, value) {
    this.checkAlarmIndex(index);
    this.Alarms[index].setDelay(value);
  }
  getAlarmDelay(index) {
    this.checkAlarmIndex(index);
    return this.Alarms[index].getDelay();
  }
  setAlarmCommandline(index, value) {
    this.checkAlarmIndex(index);
    this.Alarms[index].setCommandline(value);
  }
  getAlarmCommandline(index) {
    this.checkAlarmIndex(index);
    return this.Alarms[index].getCommandline();
  }
  GetXmlData() {
    let res = '<Sensor ID="' + this.get_hardwareId() + '">\n';
    for (let i = 0; i < this.getAlarmCount(); i++) {
      res = res + this.Alarms[i].getXmlData();
    }
    res = res + "</Sensor>\n";
    return res;
  }
  get_firstLiveDataTimeStamp() {
    return this.firstLiveDataTimeStamp;
  }
  get_firstDataloggerTimeStamp() {
    return this.firstDataloggerTimeStamp;
  }
  get_lastDataTimeStamp() {
    return this.lastDataTimeStamp;
  }
  async preload_DoWork(arg) {
    if (this._predloadProcessIsBusy) {
      console.log("!!! multiple datalogger load attempt");
      return;
    }
    if (this.dataLoggerLoadCompleted) {
      console.log("!!!  datalogger load attempt although datalogger is already loaded.");
      return;
    }
    this._predloadProcessIsBusy = true;
    logForm.log(this.hwdName + ": preloading data from " + arg.start.toString() + " to " + arg.stop.toString() + "(delta= " + (arg.stop - arg.start).toFixed(3) + ")");
    this.setDataloggerLoadProgress(1);
    this.recordedData = await this.sensor.get_recordedData(arg.start, arg.stop);
    try {
      this.recordedDataLoadProgress = await this.recordedData.loadMore();
    } catch (e) {
      logForm.log(this.hwdName + ": load more caused an exception " + e.message);
    }
    let measures = await this.recordedData.get_preview();
    this.previewMinData = [];
    this.previewCurData = [];
    this.previewMaxData = [];
    let startIndex = 0;
    let errCount = 0;
    let maxErrorCount = 10;
    let lastT = -1;
    if (CustomYSensor._MaxDataRecords > 0 && measures.length > CustomYSensor._MaxDataRecords)
      startIndex = measures.length - CustomYSensor._MaxDataRecords;
    for (let i = startIndex; i < measures.length; i++) {
      let t = measures[i].get_endTimeUTC();
      if (t >= arg.start && t <= arg.stop) {
        this.previewMinData.push(new TimedSensorValue(t, measures[i].get_minValue()));
        this.previewCurData.push(new TimedSensorValue(t, measures[i].get_averageValue()));
        this.previewMaxData.push(new TimedSensorValue(t, measures[i].get_maxValue()));
        if (t < lastT && errCount < maxErrorCount) {
          logForm.log(this.hwdName + " preloading warning:  timestamp going back in time " + t + "<" + lastT + (errCount < maxErrorCount - 1 ? "" : ", further similar errors wont be logged."));
          errCount++;
        } else if (t == lastT && errCount < maxErrorCount) {
          logForm.log(this.hwdName + " preloading warning: duplicate timestamp  " + t + (errCount < maxErrorCount - 1 ? "" : ", further similar errors wont be logged."));
          errCount++;
        }
        lastT = t;
      }
    }
    if (this.previewCurData.length > 1) {
      let a = this.previewCurData[0].DateTime;
      let b = this.previewCurData[this.previewCurData.length - 1].DateTime;
      logForm.log(this.hwdName + ": preloaded data from " + a.toString() + " to " + b.toString() + " (delta=" + (b - a).toFixed(3) + ")");
      if (CustomYSensor._MaxLoggerRecords > 0 && arg.start == 0) {
        let list = await this.recordedData.get_privateDataStreams();
        let index = list.length - 1;
        let totalRecords = 0;
        while (index > 0 && totalRecords < CustomYSensor._MaxLoggerRecords) {
          totalRecords += await list[index].get_rowCount();
          this.dataLoggerStartReadTime = await list[index].get_startTimeUTC();
          index--;
        }
        let n = 0;
        while (n < this.previewMinData.length && this.previewMinData[n].DateTime < this.dataLoggerStartReadTime) {
          n++;
        }
        if (n > 1) {
          this.previewMinData.splice(0, n - 1);
          this.previewCurData.splice(0, n - 1);
          this.previewMaxData.splice(0, n - 1);
        }
      }
    }
    this.preload_Completed(arg);
  }
  findMergeBoundaries(previewMinData) {
    let MergeSourceStart = 0;
    let MergeSourceStop = 0;
    if (this.minData.length > 0) {
      while (MergeSourceStart < this.minData.length && previewMinData[0].DateTime > this.minData[MergeSourceStart].DateTime) {
        MergeSourceStart++;
      }
      MergeSourceStop = MergeSourceStart;
      while (MergeSourceStop < this.minData.length && previewMinData[previewMinData.length - 1].DateTime >= this.minData[MergeSourceStop].DateTime) {
        MergeSourceStop++;
      }
    }
    return new MergeSourceRange(MergeSourceStart, MergeSourceStop);
  }
  preload_Completed(arg) {
    if (this.previewMinData == null)
      return;
    logForm.log(this.hwdName + " : datalogger preloading completed (" + this.previewMinData.length + " rows)");
    if (this.previewMinData.length > 1) {
      let it = this.findMergeBoundaries(this.previewMinData);
      let insertIndex = it.MergeSourceStart;
      let deleteCount = it.MergeSourceStop - it.MergeSourceStart;
      this.minData = this.minData.slice(0, insertIndex).concat(this.previewMinData, this.minData.slice(insertIndex + deleteCount));
      this.curData = this.curData.slice(0, insertIndex).concat(this.previewCurData, this.curData.slice(insertIndex + deleteCount));
      this.maxData = this.maxData.slice(0, insertIndex).concat(this.previewMaxData, this.maxData.slice(insertIndex + deleteCount));
      for (let i = 0; i < this.FormsToNotify.length; i++) {
        if (this.FormsToNotify[i] instanceof graphWidget) {
          this.FormsToNotify[i].SensorNewDataBlock(this, it.MergeSourceStart, it.MergeSourceStart + this.previewMinData.length - 1, 0, true);
        }
      }
    }
    let count = this.curData.length;
    if (count > 0) {
      if (this.curData[count - 1].DateTime > this.lastDataTimeStamp) {
        this.lastDataTimeStamp = this.curData[count - 1].DateTime;
        this.lastDataSource = "last preload timestamp";
      }
    }
    logForm.log(this.hwdName + " : start datalogger loading");
    this._predloadProcessIsBusy = false;
    this.load_DoWork(arg).then();
  }
  get_frequency() {
    return this._frequency;
  }
  async updateFrequncy(frequencyToSet) {
    if (await this.sensor.isOnline()) {
      this._frequency = frequencyToSet;
      await this.sensor.set_reportFrequency(this._frequency);
      let lfreq = await this.sensor.get_logFrequency();
      try {
        if (lfreq != "OFF")
          await this.sensor.set_logFrequency(this._frequency);
        let m = await this.sensor.get_module();
        await m.saveToFlash();
      } catch (e) {
        logForm.log("failed to change " + this.hwdName + " log frequency (" + e.message + ")");
      }
    } else {
      this._online = false;
    }
  }
  set_frequency(frequencyToSet) {
    if (this._online) {
      this.updateFrequncy(frequencyToSet).then();
    }
  }
  get_recording() {
    return this._recording;
  }
  set_recording(recordingStatus) {
    this.updaterecording(recordingStatus).then();
  }
  async updaterecording(recordingStatus) {
    if (!this.dataLoggerFeature)
      return;
    if (await this.sensor.isOnline()) {
      this._recording = recordingStatus;
      try {
        await this.sensor.set_logFrequency(this._recording ? this._frequency : "OFF");
        let module = await this.sensor.get_module();
        let serial = await module.get_serialNumber();
        let dl = YDataLogger.FindDataLogger(serial + ".dataLogger");
        await dl.set_recording(this._recording ? YDataLogger.RECORDING_ON : YDataLogger.RECORDING_OFF);
        await dl.set_autoStart(this._recording ? YDataLogger.AUTOSTART_ON : YDataLogger.AUTOSTART_OFF);
        await module.saveToFlash();
      } catch (e) {
        logForm.log("failed to change " + this.hwdName + " recording (" + e.message + ")");
      }
    } else {
      this._online = false;
    }
  }
  reportDataloggerLoadProgress(progress) {
  }
  async load_DoWork(arg) {
    if (this._loadProcessIsBusy)
      return;
    this._loadProcessIsBusy = true;
    if (this.dataLoggerLoadCompleted)
      return;
    logForm.log(this.hwdName + " loading main data from datalogger");
    if (this.dataLoggerStartReadTime > 0) {
      this.recordedData = await this.sensor.get_recordedData(this.dataLoggerStartReadTime, 0);
    }
    let errCount = 0;
    let maxErrorCount = 10;
    let lastT = -1;
    let lastProgress = this.recordedDataLoadProgress;
    while (this.recordedDataLoadProgress < 100) {
      if (this._plzCancelDataloggerLoading) {
        this.loadDone = true;
        this.loadFailed = false;
        this.loadCanceled = true;
        this.setDataloggerLoadProgress(100);
        break;
      }
      try {
        this.recordedDataLoadProgress = await this.recordedData.loadMore();
      } catch (Exception) {
        this.loadFailed = true;
        return;
      }
      if (lastProgress != this.recordedDataLoadProgress) {
        lastProgress = this.recordedDataLoadProgress;
        let p = lastProgress;
        if (p < 1)
          p = 1;
        if (p > 99)
          p = 99;
        this.setDataloggerLoadProgress(p < 1 ? 1 : p > 99 ? 99 : p);
      }
      if (this.recordedDataLoadProgress - lastProgress >= 2) {
        lastProgress = this.recordedDataLoadProgress;
      }
    }
    let measures = await this.recordedData.get_measures();
    this.previewMinData = [];
    this.previewCurData = [];
    this.previewMaxData = [];
    for (let i = 0; i < measures.length; i++) {
      let t = measures[i].get_endTimeUTC();
      if (t >= arg.start && t <= arg.stop) {
        if (t < lastT && errCount < maxErrorCount) {
          logForm.log(this.hwdName + " loading warning:  timestamp going back in time " + t + "<" + lastT + (errCount < maxErrorCount - 1 ? "" : ", further similar errors wont be logged."));
          errCount++;
        } else if (t == lastT && errCount < maxErrorCount) {
          logForm.log(this.hwdName + " loading warning: duplicate timestamp  " + t + (errCount < maxErrorCount - 1 ? "" : ", further similar errors wont be logged."));
          errCount++;
        }
        lastT = t;
        if (this.previewMinData.length == 0 || t > this.previewMinData[this.previewMinData.length - 1].DateTime) {
          this.previewMinData.push(new TimedSensorValue(t, measures[i].get_minValue()));
          this.previewCurData.push(new TimedSensorValue(t, measures[i].get_averageValue()));
          this.previewMaxData.push(new TimedSensorValue(t, measures[i].get_maxValue()));
        }
      } else {
        let d = new Date(t * 1e3);
        let d1 = new Date(arg.start * 1e3);
        let d2 = new Date(arg.stop * 1e3);
        let dstr = d.toLocaleDateString() + " " + d.toLocaleTimeString();
        let d1str = d1.toLocaleDateString() + " " + d1.toLocaleTimeString();
        let d2str = d2.toLocaleDateString() + " " + d2.toLocaleTimeString();
        logForm.log(this.hwdName + " note: skipping measure at " + dstr + ", not in range " + d1str + " ... " + d2str);
      }
    }
    if (CustomYSensor._MaxDataRecords > 0)
      this.previewDataCleanUp();
    for (let i = 0; i < this.previewMinData.length - 1; i++) {
      if (this.previewMinData[i].DateTime >= this.previewMinData[i + 1].DateTime) {
        throw "Time-stamp inconsistency";
      }
    }
    if (this.previewCurData.length > 1) {
      logForm.log(this.hwdName + " loaded " + this.previewCurData.length.toString() + "/" + measures.length.toString() + " records over " + (this.previewCurData[this.previewCurData.length - 1].DateTime - this.previewCurData[0].DateTime).toFixed(3) + " sec, last timed stamp was " + this.previewCurData[this.previewCurData.length - 1].DateTime);
    } else {
      logForm.log(this.hwdName + " loaded " + this.previewCurData.length.toString() + " records");
    }
    if (this.previewMinData.length > 2) {
      let lastPreviewTimeStamp = this.previewMinData[this.previewMinData.length - 1].DateTime;
      let it = this.findMergeBoundaries(this.previewMinData);
      let deleteCount = it.MergeSourceStop - it.MergeSourceStart;
      this.minData = this.minData.slice(0, it.MergeSourceStart).concat(this.previewMinData, this.minData.slice(it.MergeSourceStart + deleteCount));
      this.curData = this.curData.slice(0, it.MergeSourceStart).concat(this.previewCurData, this.curData.slice(it.MergeSourceStart + deleteCount));
      this.maxData = this.maxData.slice(0, it.MergeSourceStart).concat(this.previewMaxData, this.maxData.slice(it.MergeSourceStart + deleteCount));
      this.firstDataloggerTimeStamp = this.curData[0].DateTime;
    }
    this.loadDone = true;
    this.loadFailed = false;
    let count = this.curData.length;
    if (count > 0) {
      if (this.curData[count - 1].DateTime > this.lastDataTimeStamp) {
        this.lastDataTimeStamp = this.curData[count - 1].DateTime;
        this.lastDataSource = "end of datalogger";
      }
    }
    this.load_Completed();
  }
  load_Completed() {
    logForm.log(this.hwdName + ".loadcompleted()");
    if (this.loadFailed) {
      logForm.log(this.hwdName + " : datalogger loading failed");
      this._loadProcessIsBusy = false;
      return;
    }
    if (this.loadCanceled) {
      logForm.log(this.hwdName + " : datalogger loading was canceled");
      this.previewMinData = [];
      this.previewCurData = [];
      this.previewMaxData = [];
      this.loadCanceled = false;
      this._loadProcessIsBusy = false;
      this.preloadDone = false;
      this.loadDone = false;
      return;
    }
    if (this.previewCurData.length <= 2) {
      this.preloadDone = false;
      this.loadDone = false;
    }
    logForm.log(this.hwdName + " : datalogger loading completed  (" + this.previewMinData.length + " rows)");
    this.resetDataloggerLoader();
    this.dataLoggerLoadCompleted = true;
    for (let i = 0; i < this.FormsToNotify.length; i++) {
      if (this.FormsToNotify[i] instanceof graphWidget) {
        this.FormsToNotify[i].DataloggerCompleted(this);
      }
    }
    this.setDataloggerLoadProgress(100);
  }
  get dataloggerWasUsed() {
    return this.dataLoggerLoadCompleted;
  }
  dataCleanUp() {
    if (CustomYSensor._MaxDataRecords <= 0)
      return;
    let newsize = CustomYSensor._MaxDataRecords * 90 / 100 >> 0;
    if (this.curData != null && CustomYSensor._MaxDataRecords < this.curData.length) {
      this.minData.splice(0, this.minData.length - newsize);
      this.curData.splice(0, this.curData.length - newsize);
      this.maxData.splice(0, this.maxData.length - newsize);
    }
  }
  previewDataCleanUp() {
    if (CustomYSensor._MaxDataRecords <= 0)
      return;
    let newsize = CustomYSensor._MaxDataRecords * 90 / 100 >> 0;
    if (this.previewMinData != null && CustomYSensor._MaxDataRecords < this.previewMinData.length) {
      this.previewMinData.splice(0, this.previewMinData.length - newsize);
      this.previewCurData.splice(0, this.previewCurData.length - newsize);
      this.previewMaxData.splice(0, this.previewMaxData.length - newsize);
    }
  }
  stopDataloggerloading() {
  }
  isOnline() {
    return this._online;
  }
  async reloadConfig() {
    if (this._online) {
      let ison = await this.sensor.isOnline();
      if (ison) {
        try {
          this.unit = await this.sensor.get_unit();
          this._friendlyname = await this.sensor.get_friendlyName();
          this.resolution = await this.sensor.get_resolution();
          this._frequency = await this.sensor.get_reportFrequency();
          this._readonly = await this.sensor.isReadOnly();
          if (this.dataLoggerFeature) {
            this._recording = await this.sensor.get_logFrequency() != "OFF";
          } else {
            this._recording = false;
          }
          this.lastGetConfig = YAPI.GetTickCount();
          this.mustReloadConfig = false;
        } catch (e) {
          logForm.log("reload configuration error: " + e.message);
        }
      } else {
        this._online = false;
      }
    }
  }
  get_unit() {
    if (this.cfgChgNotificationsSupported && !this.mustReloadConfig)
      return this.unit;
    if (this.lastGetConfig <= 0 || YAPI.GetTickCount() - this.lastGetConfig > 5e3)
      this.reloadConfig().then();
    return this.unit;
  }
  get_resolution() {
    if (this.cfgChgNotificationsSupported && !this.mustReloadConfig)
      return this.resolution;
    if (this.lastGetConfig <= 0 || YAPI.GetTickCount() - this.lastGetConfig > 5e3)
      this.reloadConfig().then();
    return this.resolution;
  }
  resetDataloggerLoader() {
    this._predloadProcessIsBusy = false;
    this._loadProcessIsBusy = false;
    this.dataLoggerLoadCompleted = false;
    this.preloadDone = false;
    this.loadDone = false;
    this._dataloggerLoadisRunning = false;
    this.previewMinData = [];
    this.previewCurData = [];
    this.previewMaxData = [];
  }
  loadDatalogger(start, stop) {
    if (!this.dataLoggerFeature)
      return;
    if (this._predloadProcessIsBusy)
      return;
    if (this._loadProcessIsBusy)
      return;
    if (constants.maxPointsPerDataloggerSerie < 0) {
      logForm.log(this.hwdName + " : datalogger access is disabled");
      return;
    }
    if (!this.preloadDone && this.dataLoggerFeature) {
      logForm.log(this.hwdName + " : start datalogger preloading");
      this.preload_DoWork(new DataLoggerBoundary(start, stop)).then();
    }
  }
  async arrival(dataloggerOn) {
    await this.configureSensor();
    this._online = true;
    await this.reloadConfig();
    let dt = await this.sensor.get_dataLogger();
    if (dt == null)
      return;
    let now = Math.floor(new Date().getTime() / 1e3);
    if (this.curData.length > 0 && this.dataLoggerLoadCompleted) {
      let end = await dt.get_timeUTC();
      let start = this.curData[this.curData.length - 1].DateTime;
      let duration = end - start;
      if (duration == 0) {
        start = this.curData[this.curData.length - 2].DateTime;
        duration = end - start;
      }
      if (duration > 1) {
        logForm.log(this.hwdName + " is back online trying to load " + duration.toFixed(3) + " sec of data from datalogger ");
        this.resetDataloggerLoader();
        this.loadDatalogger(start, end);
      }
    }
    if (this.isReadOnly)
      logForm.log(this.hwdName + " is read only");
    this.notifySensorStateChange();
    this.notifySensorArrival();
  }
  async startDataloggerload(source) {
    if (!this.dataLoggerFeature)
      return;
    if (this.sensor == null)
      return;
    if (this._loadProcessIsBusy)
      return;
    if (this._predloadProcessIsBusy)
      return;
    if (this.dataLoggerLoadCompleted) {
      source.DataloggerCompleted(this);
      return;
    }
    let dt = await this.sensor.get_dataLogger();
    if (dt == null)
      return;
    this.loadDatalogger(0, await dt.get_timeUTC());
  }
  notifySensorArrival() {
    for (let i = 0; i < this.FormsToNotify.length; i++) {
      this.FormsToNotify[i].SensorArrivalcallback(this);
    }
  }
  notifySensorStateChange() {
    for (let i = 0; i < this.FormsToNotify.length; i++) {
      this.FormsToNotify[i].SensorStateChangedcallback(this);
    }
  }
  removal() {
    this._online = false;
    this.forceUpdate();
    this.notifySensorStateChange();
  }
  async configureSensor() {
    logForm.log("Configuring  " + this.hwdName);
    if (!await this.sensor.isOnline())
      return;
    let mustSave = false;
    let olfreq = await this.sensor.get_logFrequency();
    let orfreq = await this.sensor.get_reportFrequency();
    let readOnly = await this.sensor.isReadOnly();
    let lfreq = olfreq;
    let rfreq = orfreq;
    let m = await this.sensor.get_module();
    for (let i = 0; i < await m.functionCount(); i++) {
      if (await m.functionType(i) == "DataLogger") {
        this.dataLoggerFeature = true;
      }
    }
    try {
      if (this.dataLoggerFeature) {
        let m2 = await this.sensor.get_module();
        let dl = YDataLogger.FindDataLogger(await m2.get_serialNumber() + ".dataLogger");
        let dataloggerOn = await dl.get_recording() != YDataLogger.RECORDING_OFF;
        let dataloggerAS = await dl.get_autoStart() != YDataLogger.AUTOSTART_OFF;
        if (!dataloggerOn) {
          lfreq = "OFF";
        }
        if (lfreq != "OFF") {
          rfreq = lfreq;
        } else if (rfreq == "OFF") {
          rfreq = "1/s";
        }
        if (lfreq != olfreq) {
          if (readOnly)
            throw new Error(this.hwdName + " is read only, cannot change its logFrequency from " + olfreq + " to " + lfreq);
          await this.sensor.set_logFrequency(lfreq);
          mustSave = true;
        }
        if (rfreq != orfreq) {
          if (readOnly)
            throw new Error(this.hwdName + " is read only, connot change its  reportFrequency from " + orfreq + " to " + rfreq);
          await this.sensor.set_reportFrequency(rfreq);
          mustSave = true;
        }
        if (lfreq != "OFF") {
          if (!dataloggerOn) {
            if (readOnly)
              throw new Error(this.hwdName + " is read only, cannot change set its  datalogger recording to ON");
            await dl.set_recording(YDataLogger.RECORDING_ON);
          }
          if (!dataloggerAS) {
            if (readOnly)
              throw new Error(this.hwdName + " is read only, cannot change set its datalogger autostart to ON");
            await dl.set_autoStart(YDataLogger.AUTOSTART_ON);
            mustSave = true;
          }
        }
      } else {
        lfreq = "OFF";
        if (rfreq == "OFF") {
          rfreq = "1/s";
          if (readOnly)
            throw new Error(this.hwdName + " is read only, connot change is reportFrequency from OFF to " + rfreq);
          await this.sensor.set_reportFrequency(rfreq);
          mustSave = true;
        }
      }
      if (mustSave)
        await m.saveToFlash();
    } catch (e) {
      logForm.log("failed to configure " + this.hwdName + "  (" + e.message + ")");
    }
    logForm.log("registering timed callback for  " + await this.sensor.get_hardwareId());
    await this.sensor.registerTimedReportCallback((callbacksource, M) => {
      this.TimedCallback(callbacksource, M);
    });
    this._recording = lfreq != "OFF";
    this._frequency = rfreq;
  }
  registerCallback(f) {
    if (this.FormsToNotify.indexOf(f) >= 0)
      return;
    this.FormsToNotify.push(f);
    return;
  }
  forceUpdate() {
    this.TimedCallback(this.sensor, null).then();
  }
  async TimedCallback(source, M) {
    this._online = true;
    if (M != null) {
      let t = M.get_endTimeUTC();
      if (this.firstLiveDataTimeStamp == 0)
        this.firstLiveDataTimeStamp = t;
      if (t > this.lastDataTimeStamp) {
        this.lastDataTimeStamp = t;
        this.lastDataSource = "last timedReport";
        this.consecutiveBadTimeStamp = 0;
      } else {
        this.consecutiveBadTimeStamp++;
        if (this.consecutiveBadTimeStamp < 10) {
          logForm.log(this.hwdName + ": ignoring bad timestamp " + t.toFixed(3) + " (previous " + this.lastDataSource + " at " + this.lastDataTimeStamp.toFixed(3) + ")");
        }
      }
      if (this.consecutiveBadTimeStamp == 0 || this.consecutiveBadTimeStamp >= 10) {
        this._lastAvgValue = M.get_averageValue();
        this._lastMinValue = M.get_minValue();
        this._lastMaxValue = M.get_maxValue();
        this.curData.push(new TimedSensorValue(t, this._lastAvgValue));
        this.minData.push(new TimedSensorValue(t, this._lastMinValue));
        this.maxData.push(new TimedSensorValue(t, this._lastMaxValue));
        if (CustomYSensor._MaxDataRecords > 0)
          this.dataCleanUp();
      }
      for (let i = 0; i < this.Alarms.length; i++) {
        this.Alarms[i].check(M);
      }
      for (let i = 0; i < this.FormsToNotify.length; i++) {
        this.FormsToNotify[i].SensorValuecallback(this, M);
      }
    }
  }
  forgetForm(source) {
    for (let i = this.FormsToNotify.length - 1; i >= 0; i--) {
      if (source == this.FormsToNotify[i]) {
        this.FormsToNotify.splice(i, 1);
      }
    }
  }
  get_sensor() {
    return this.sensor;
  }
  get_hardwareId() {
    return this.hwdName;
  }
  get_friendlyName() {
    return this._friendlyname;
  }
  toString() {
    let name = this._friendlyname;
    if (this._readonly)
      name += " (readonly)";
    if (this._online)
      return name;
    return name + " (OFFLINE)";
  }
};
CustomYSensor._MaxDataRecords = 0;
CustomYSensor._MaxLoggerRecords = 0;
var NullYSensor = class extends CustomYSensor {
  constructor() {
    super(null, "", null);
    this.hwdName = "NOTAREALSENSOR";
    this._friendlyname = "NOTAREALSENSOR";
    this.dataLoggerFeature = false;
  }
  async preload_DoWork(arg) {
    return;
  }
  get dataloggerLoadisRunning() {
    return false;
  }
  get_unit() {
    return "";
  }
  registerCallback(Form) {
  }
  forceUpdate() {
  }
  get_frequency() {
    return "";
  }
  set_frequency(frequencyToSet) {
  }
  get_sensor() {
    return null;
  }
  toString() {
    return "(none)";
  }
  setAlarmCondition(index, condition) {
  }
  getAlarmCondition(index) {
    return 0;
  }
  setAlarmValue(index, value) {
  }
  getAlarmValue(index) {
    return 0;
  }
  setAlarmDelay(index, value) {
  }
  getAlarmDelay(index) {
    return 0;
  }
  setAlarmCommandline(index, value) {
  }
  getAlarmCommandline(index) {
    return "";
  }
};
var sensorsManager = class {
  static async clearHublist() {
    for (let i = sensorsManager._hubList.length - 1; i >= 0; i--) {
      if (sensorsManager._hubList[i].removable) {
        await YAPI.UnregisterHub(sensorsManager._hubList[i].get_fullUrl());
        sensorsManager._hubList.splice(i, 1);
      }
    }
  }
  static registerChangeCallback(changeCallback) {
    this._changeCallback = changeCallback;
  }
  static registerChangeExternalCallback(changeCallback) {
    this._changeExternalCallback = changeCallback;
  }
  static forgetForm(source) {
    for (let i = 0; i < sensorsManager.sensorList.length; i++) {
      sensorsManager.sensorList[i].forgetForm(source);
    }
  }
  static InitHubList(node) {
    let nodes = node.get_childsByIndex();
    for (let i = 0; i < nodes.length; i++) {
      if (nodes[i].Name.toUpperCase() == "HUB") {
        let h = Hub.HubFromXml(nodes[i]);
        let alreadthere = false;
        for (let j = 0; j < sensorsManager._hubList.length; j++) {
          if (h.get_connexionUrl() == sensorsManager._hubList[j].get_connexionUrl())
            alreadthere = true;
        }
        if (!alreadthere) {
          sensorsManager._hubList.push(h);
          h.Connect().then();
        }
      }
    }
  }
  static get hubList() {
    return sensorsManager._hubList;
  }
  static hubWasremoved(h) {
    for (let i = sensorsManager._hubList.length - 1; i >= 0; i--) {
      if (sensorsManager._hubList[i] == h)
        sensorsManager._hubList.splice(i, 1);
    }
  }
  static newHubCreated(h) {
    let url = h.get_connexionUrl();
    for (let i = 0; i < sensorsManager._hubList.length; i++) {
      if (sensorsManager._hubList[i].get_connexionUrl() == url) {
        alert("This connection already exists");
        return false;
      }
    }
    sensorsManager._hubList.push(h);
    return true;
  }
  static removeExtraInfoFromUrl(url) {
    let it = new URL(url);
    let res = it.hostname + it.pathname;
    if (res.slice(0, 4).toLowerCase() === "www.") {
      res = res.slice(4);
    }
    return res;
  }
  static async NetworkArrival(net) {
    logForm.log("Network device detected: " + await net.get_hardwareId());
    let ip = await net.get_ipAddress();
    let netname = await net.get_logicalName();
    let module = await net.get_module();
    let loginame = await module.get_logicalName();
    let url = sensorsManager.removeExtraInfoFromUrl(await module.get_url());
    for (let i = 0; i < sensorsManager._hubList.length; i++) {
      let str = sensorsManager.removeExtraInfoFromUrl(sensorsManager.hubList[i].get_fullUrl());
      if (str == url) {
        sensorsManager.hubList[i].arrival(ip, netname, module, loginame);
      }
    }
  }
  static getXmlHublist() {
    let res = "";
    for (let i = 0; i < sensorsManager._hubList.length; i++) {
      res += "    " + sensorsManager._hubList[i].XmlCode() + "\n";
    }
    return res;
  }
  static getXMLSensorsConfig() {
    let res = "<Sensors>\n";
    sensorsManager.sensorList.forEach((s) => {
      if (!(s instanceof NullYSensor)) {
        res = res + s.GetXmlData();
      }
    });
    res = res + "</Sensors>\n";
    return res;
  }
  static setKnownSensors(sensorXMLList) {
    this.KnownSensors = sensorXMLList;
  }
  static FindSensorLastLocalConfig(hwdId) {
    let SensorConfig = null;
    if (sensorsManager.KnownSensors != null) {
      let childs = sensorsManager.KnownSensors.get_childsByIndex();
      for (let i = 0; i < childs.length; i++) {
        let node = childs[i];
        if (node.Name == "Sensor") {
          let id = node.get_attributes()["ID"];
          if (id == hwdId) {
            SensorConfig = node;
          }
        }
      }
    }
    return SensorConfig;
  }
  static async deviceConfigChanged(m) {
    logForm.log("Configuration change on device  " + await m.get_serialNumber());
    let serialprefix = (await m.get_serialNumber()).substring(0, 8);
    for (let i = 0; i < sensorsManager.sensorList.length; i++) {
      if (sensorsManager.sensorList[i].get_hardwareId().substring(0, 8) == serialprefix) {
        await sensorsManager.sensorList[i].ConfigHasChanged();
      }
    }
    if (sensorsManager._changeCallback != null)
      sensorsManager._changeCallback();
    if (sensorsManager._changeExternalCallback != null) {
      let data = await sensorsManager._changeExternalCallback(m);
      if (data != null)
        YWebPage.ConfigChanged(data);
    }
  }
  static async deviceArrival(m) {
    try {
      let count = await m.functionCount();
      let serial = await m.get_serialNumber();
      let luminosity = await m.get_luminosity();
      logForm.log("Device Arrival " + serial);
      let recording = false;
      for (let i = 0; i < count; i++) {
        let ftype = await m.functionType(i);
        let fid = await m.functionId(i);
        if (ftype == "Network") {
          let net = await YNetwork.FindNetwork(serial + "." + fid);
          await sensorsManager.NetworkArrival(net);
        } else if (ftype == "DataLogger") {
          let dlog = YDataLogger.FindDataLogger(serial + "." + fid);
          let state = await dlog.get_recording();
          if (state == YDataLogger.RECORDING_ON || state == YDataLogger.RECORDING_PENDING) {
            recording = true;
          }
        }
      }
      for (let i = 0; i < count; i++) {
        let fbasetype = await m.functionBaseType(i);
        let fid = await m.functionId(i);
        if (fbasetype == "Sensor") {
          let hwdID = serial + "." + fid;
          logForm.log("New sensor arrival: " + hwdID);
          let found = false;
          for (let j = 0; j < sensorsManager.sensorList.length && !found; j++) {
            if (sensorsManager.sensorList[j].get_hardwareId() == hwdID) {
              found = true;
              await sensorsManager.sensorList[j].arrival(recording);
            }
          }
          if (!found) {
            let s = YSensor.FindSensor(hwdID);
            let hwd = await s.get_hardwareId();
            let cs = new CustomYSensor(s, hwd, sensorsManager.FindSensorLastLocalConfig(hwd));
            sensorsManager.sensorList.push(cs);
            await cs.configureSensor();
            YWebPage.refreshEditor();
            cs.notifySensorStateChange();
          }
        }
      }
      await m.registerConfigChangeCallback(sensorsManager.deviceConfigChanged);
      setTimeout(() => {
        sensorsManager.deviceConfigChanged(m);
      }, 100);
      if (sensorsManager._changeCallback != null)
        sensorsManager._changeCallback();
    } catch (e) {
      logForm.log("Device Arrival Error: " + e.message);
    }
    if (sensorsManager._customArrivalCallback != null)
      sensorsManager._customArrivalCallback(m);
  }
  static async deviceRemoval(m) {
    let serial = await m.get_serialNumber();
    logForm.log("Device removal " + serial);
    sensorsManager.sensorList.forEach((alreadyThereSensor) => {
      if (!(alreadyThereSensor instanceof NullYSensor)) {
        let hwd = alreadyThereSensor.get_hardwareId();
        if (hwd.length >= serial.length) {
          if (hwd.substring(0, serial.length) == serial) {
            alreadyThereSensor.removal();
          }
        }
      }
    });
    if (sensorsManager._changeCallback != null)
      sensorsManager._changeCallback();
    if (sensorsManager._customRemovalCallback != null)
      sensorsManager._customRemovalCallback(m);
  }
  static RegisterDeviceArrivalCallback(arrivalCallback) {
    sensorsManager._customArrivalCallback = arrivalCallback;
  }
  static RegisterDeviceRemovalCallback(removalCallback) {
    sensorsManager._customRemovalCallback = removalCallback;
  }
  static AddNewSensor(hwdID) {
    for (let i = 0; i < sensorsManager.sensorList.length; i++) {
      if (sensorsManager.sensorList[i] != null) {
        if (sensorsManager.sensorList[i].get_hardwareId() == hwdID)
          return sensorsManager.sensorList[i];
      }
    }
    let s = YSensor.FindSensor(hwdID);
    let cs = new CustomYSensor(s, hwdID, sensorsManager.FindSensorLastLocalConfig(hwdID));
    sensorsManager.sensorList.push(cs);
    return cs;
  }
  static getNullSensor() {
    return sensorsManager.NullSensor;
  }
  static async UpdateDeviceList() {
    let err = new YErrorMsg();
    try {
      if (await YAPI.UpdateDeviceList(err) != YAPI_SUCCESS) {
        logForm.log("UpdateDeviceList failed :" + err.msg);
      }
    } catch (e) {
      logForm.log("UpdateDeviceList failed :" + e.message);
    }
    let hub = YHub.FirstHubInUse();
    while (hub != null) {
      let lastError = await hub.get_errorType();
      if (lastError != YAPI_SUCCESS) {
        let logline = "Cannot connect to " + await hub.get_connectionUrl() + " (" + await hub.get_errorMessage() + ")";
        if (lastError == YAPI_UNAUTHORIZED) {
          for (let i = 0; i < this._hubList.length; i++) {
            if (await this._hubList[i].matches(hub) && !this._hubList[i].removable) {
              logline += ". Update hub credentials in 'Global configuration' window.";
            }
          }
        }
        logForm.log(logline);
      }
      hub = hub.nextHubInUse();
    }
  }
  static async _runAsync() {
    let errmsg = new YErrorMsg();
    await YAPI.RegisterDeviceArrivalCallback((m) => {
      sensorsManager.deviceArrival(m);
    });
    await YAPI.RegisterDeviceRemovalCallback((m) => {
      sensorsManager.deviceRemoval(m);
    });
    await sensorsManager.UpdateDeviceList();
    setInterval(() => {
      sensorsManager.UpdateDeviceList();
    }, 2e3);
  }
  static run() {
    sensorsManager.NullSensor = new NullYSensor();
    sensorsManager.sensorList = [];
    sensorsManager.sensorList.push(sensorsManager.NullSensor);
    this._runAsync().then();
  }
};
sensorsManager.counter = 0;
sensorsManager.KnownSensors = null;
sensorsManager._hubList = [];
sensorsManager._customArrivalCallback = null;
sensorsManager._customRemovalCallback = null;
sensorsManager._changeCallback = null;
sensorsManager._changeExternalCallback = null;

// obj/full/formManager.js
var ResizeMoveHandle = class {
  constructor(container, index, mouseDownListener, touchStartlistener) {
    this.index = index;
    this.container = container;
    this.isactive = false;
    this.div = document.createElement("DIV");
    let size = ResizeMoveHandle.HANDLESIZE - 2;
    if (this.index == ResizeMoveHandle.RESIZEHANDLE_CENTER)
      size = size * 2;
    this.div.style.position = "absolute";
    this.div.style.border = "0px solid black";
    this.div.style.background = "transparent";
    this.div.style.pointerEvents = "auto";
    this.div.style.width = size.toString() + "px";
    this.div.style.height = size.toString() + "px";
    switch (index) {
      case ResizeMoveHandle.RESIZEHANDLE_TOPLEFT:
        this.div.style.cursor = "nw-resize";
        this.div.style.left = "0px";
        this.div.style.top = "0px";
        break;
      case ResizeMoveHandle.RESIZEHANDLE_TOPCENTER:
        this.div.style.cursor = "n-resize";
        this.div.style.top = "0px";
        this.div.style.left = "50%";
        this.div.style.transform = "translate(-50%,0)";
        break;
      case ResizeMoveHandle.RESIZEHANDLE_TOPRIGHT:
        this.div.style.cursor = "ne-resize";
        this.div.style.right = "0px";
        this.div.style.top = "0px";
        break;
      case ResizeMoveHandle.RESIZEHANDLE_CENTERRIGHT:
        this.div.style.cursor = "e-resize";
        this.div.style.right = "0px";
        this.div.style.top = "50%";
        this.div.style.transform = "translate(0,-50%)";
        break;
      case ResizeMoveHandle.RESIZEHANDLE_BOTTOMRIGHT:
        this.div.style.cursor = "se-resize";
        this.div.style.right = "0px";
        this.div.style.bottom = "0px";
        break;
      case ResizeMoveHandle.RESIZEHANDLE_BOTTOMCENTER:
        this.div.style.cursor = "s-resize";
        this.div.style.bottom = "0px";
        this.div.style.left = "50%";
        this.div.style.transform = "translate(-50%,0)";
        break;
      case ResizeMoveHandle.RESIZEHANDLE_BOTTOMLEFT:
        this.div.style.cursor = "sw-resize";
        this.div.style.left = "0px";
        this.div.style.bottom = "0px";
        break;
      case ResizeMoveHandle.RESIZEHANDLE_CENTERLEFT:
        this.div.style.cursor = "w-resize";
        this.div.style.left = "0px";
        this.div.style.top = "50%";
        this.div.style.transform = "translate(0,-50%)";
        break;
      case ResizeMoveHandle.RESIZEHANDLE_CENTER:
        this.div.style.cursor = "move";
        this.div.style.left = "50%";
        this.div.style.top = "50%";
        this.div.style.transform = "translate(-50%,-50%)";
        break;
    }
    this.container.appendChild(this.div);
    this.div.addEventListener("mousedown", mouseDownListener);
    this.div.addEventListener("touchstart", touchStartlistener);
    this.svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    this.svg.setAttribute("viewBox", "0 0 " + size + " " + size);
    this.svg.setAttribute("version", "1.1");
    this.svg.setAttribute("width", size.toString());
    this.svg.setAttribute("height", size.toString());
    let x = 0;
    let y = 0;
    let r = size;
    switch (this.index) {
      case ResizeMoveHandle.RESIZEHANDLE_TOPLEFT:
        break;
      case ResizeMoveHandle.RESIZEHANDLE_TOPCENTER:
        x = size / 2;
        break;
      case ResizeMoveHandle.RESIZEHANDLE_TOPRIGHT:
        x = size;
        break;
      case ResizeMoveHandle.RESIZEHANDLE_CENTERRIGHT:
        x = size;
        y = size / 2;
        break;
      case ResizeMoveHandle.RESIZEHANDLE_BOTTOMRIGHT:
        x = size;
        y = size;
        break;
      case ResizeMoveHandle.RESIZEHANDLE_BOTTOMCENTER:
        x = size / 2;
        y = size;
        break;
      case ResizeMoveHandle.RESIZEHANDLE_BOTTOMLEFT:
        y = size;
        break;
      case ResizeMoveHandle.RESIZEHANDLE_CENTERLEFT:
        y = size / 2;
        break;
      case ResizeMoveHandle.RESIZEHANDLE_CENTER:
        x = size / 2;
        y = size / 2;
        r = size / 2;
        break;
    }
    this.circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
    this.circle.setAttribute("cx", x.toString());
    this.circle.setAttribute("cy", y.toString());
    this.circle.setAttribute("r", r.toString());
    this.circle.setAttribute("style", "fill:white");
    this.circle.setAttribute("opacity", "0.75");
    this.svg.appendChild(this.circle);
    this.arrow = document.createElementNS("http://www.w3.org/2000/svg", "path");
    let d = "";
    for (let i = 0; i < ResizeMoveHandle.RESIZEHANDLE_data[index].length >> 1; i++) {
      let x2 = 1 + (size - 2) * ResizeMoveHandle.RESIZEHANDLE_data[index][i << 1] / 12;
      let y2 = 1 + (size - 2) * ResizeMoveHandle.RESIZEHANDLE_data[index][1 + (i << 1)] / 12;
      d += i == 0 ? "M " : "L ";
      d += Math.round(x2).toString() + " " + Math.round(y2).toString() + " ";
    }
    d += "z";
    this.arrow.setAttribute("d", d);
    this.arrow.setAttribute("fill", ResizeMoveHandle.inactiveColor);
    this.svg.appendChild(this.arrow);
    this.div.appendChild(this.svg);
    this.container.appendChild(this.div);
  }
  get active() {
    return this.isactive;
  }
  set active(value) {
    if (value != this.isactive) {
      this.isactive = value;
      this.arrow.setAttribute("fill", this.active ? ResizeMoveHandle.activeColor : ResizeMoveHandle.inactiveColor);
    }
  }
};
ResizeMoveHandle.HANDLESIZE = Math.round(20 * (1 + 2 * (constants.guiDPIFactor - 1)));
ResizeMoveHandle.activeColor = "lightgreen";
ResizeMoveHandle.inactiveColor = "grey";
ResizeMoveHandle.RESIZEHANDLE_TOPLEFT = 0;
ResizeMoveHandle.RESIZEHANDLE_TOPCENTER = 1;
ResizeMoveHandle.RESIZEHANDLE_TOPRIGHT = 2;
ResizeMoveHandle.RESIZEHANDLE_CENTERRIGHT = 3;
ResizeMoveHandle.RESIZEHANDLE_BOTTOMRIGHT = 4;
ResizeMoveHandle.RESIZEHANDLE_BOTTOMCENTER = 5;
ResizeMoveHandle.RESIZEHANDLE_BOTTOMLEFT = 6;
ResizeMoveHandle.RESIZEHANDLE_CENTERLEFT = 7;
ResizeMoveHandle.RESIZEHANDLE_CENTER = 8;
ResizeMoveHandle.RESIZEHANDLE_data = [
  [0, 0, 0, 7, 2, 5, 7, 10, 10, 7, 5, 2, 7, 0],
  [6, 0, 11, 5, 8, 5, 8, 12, 4, 12, 4, 5, 1, 5],
  [12, 0, 12, 7, 10, 5, 5, 10, 2, 7, 7, 2, 5, 0],
  [12, 6, 7, 11, 7, 8, 0, 8, 0, 4, 7, 4, 7, 1],
  [12, 12, 5, 12, 7, 10, 2, 5, 5, 2, 10, 7, 12, 5],
  [6, 12, 1, 7, 4, 7, 4, 0, 8, 0, 8, 7, 11, 7],
  [0, 12, 0, 5, 2, 7, 7, 2, 10, 5, 5, 10, 7, 12],
  [0, 6, 5, 1, 5, 4, 12, 4, 12, 8, 5, 8, 5, 11],
  [
    6,
    0,
    8,
    2,
    7,
    2,
    7,
    5,
    10,
    5,
    10,
    4,
    12,
    6,
    10,
    8,
    10,
    7,
    7,
    7,
    7,
    10,
    8,
    10,
    6,
    12,
    4,
    10,
    5,
    10,
    5,
    7,
    2,
    7,
    2,
    8,
    0,
    6,
    2,
    4,
    2,
    5,
    5,
    5,
    5,
    2,
    4,
    2
  ]
];
var YWidget = class {
  static log(st) {
    logForm.log(st);
  }
  SourceChanged(src, index) {
  }
  loadRecordedDataIfNeeded() {
  }
  removeDataloggerData() {
  }
  delete() {
    this.editStopped();
    sensorsManager.forgetForm(this);
    this.destroy();
  }
  get confirmDeleteString() {
    return "not defined";
  }
  snapshot() {
    let w = 1024;
    let h = 1024;
    let ratio = this.UIContainer.offsetHeight != 0 ? this.UIContainer.offsetWidth / this.UIContainer.offsetHeight : 1;
    switch (constants.captureSizePolicy) {
      case YDataRenderer.CaptureFormats.Keep:
        w = this.UIContainer.offsetWidth;
        h = this.UIContainer.offsetHeight;
        break;
      case YDataRenderer.CaptureFormats.FixedHeight:
        h = constants.captureHeight;
        w = h * ratio;
        break;
      case YDataRenderer.CaptureFormats.FixedWidth:
        w = constants.captureWidth;
        h = w / ratio;
        break;
      case YDataRenderer.CaptureFormats.Fixed:
        w = constants.captureWidth;
        h = constants.captureHeight;
        break;
    }
    this._genRenderer.captureAndDownloadImage(constants.captureType, "", w, h, constants.captureDPI);
  }
  get BackColor() {
    return this._BackColor;
  }
  set BackColor(value) {
    this._BackColor = value;
    this.UIContainer.style.backgroundColor = this._BackColor.htmlCode;
  }
  get BorderColor() {
    return this._BorderColor;
  }
  set BorderColor(value) {
    this._BorderColor = value;
    this.UIContainer.style.border = "1px solid " + this._BorderColor.htmlCode;
  }
  get parentWidth() {
    if (this.UIContainer.parentNode == document.body || this.UIContainer.parentNode == null)
      return window.innerWidth;
    return this.UIContainer.parentNode.clientWidth;
  }
  get parentHeight() {
    if (this.UIContainer.parentNode == document.body || this.UIContainer.parentNode == null)
      return window.innerHeight;
    return this.UIContainer.parentNode.clientHeight;
  }
  get relativePositionX() {
    if (this._SizeIsRelative)
      return this._relativePositionX;
    return this.sizeRound(100 * this.UIContainer.offsetLeft / this.parentWidth);
  }
  set relativePositionX(value) {
    this._relativePositionX = value;
    this._PositionX = Math.round(value * this.parentWidth / 100);
  }
  set relativePositionY(value) {
    this._relativePositionY = value;
    this._PositionY = Math.round(value * this.parentHeight / 100);
  }
  get relativePositionY() {
    if (this._SizeIsRelative)
      return this._relativePositionY;
    return this.sizeRound(100 * this.UIContainer.offsetTop / this.parentHeight);
  }
  get PositionX() {
    if (this._SizeIsRelative)
      return this.relativePositionX;
    return this.UIContainer.offsetLeft;
  }
  set PositionX(value) {
    if (this._SizeIsRelative)
      this.relativePositionX = value;
    else
      this._PositionX = value;
    this.UIContainer.style.left = this._PositionX.toString() + "px";
    if (this._genRenderer != null)
      this._genRenderer.clearTransformationMatrix();
    this.DrawHandles(this.UIContainer.offsetLeft, this.UIContainer.offsetTop, this.UIContainer.offsetWidth, this.UIContainer.offsetHeight);
  }
  get PositionY() {
    if (this._SizeIsRelative)
      return this.relativePositionY;
    return this.UIContainer.offsetTop;
  }
  set PositionY(value) {
    if (this._SizeIsRelative)
      this.relativePositionY = value;
    else
      this._PositionY = value;
    this.UIContainer.style.top = this._PositionY.toString() + "px";
    if (this._genRenderer != null)
      this._genRenderer.clearTransformationMatrix();
    this.DrawHandles(this.UIContainer.offsetLeft, this.UIContainer.offsetTop, this.UIContainer.offsetWidth, this.UIContainer.offsetHeight);
  }
  sizeRound(v) {
    return Math.round(100 * v) / 100;
  }
  get relativeWidth() {
    if (this._SizeIsRelative)
      return this._relativeWidth;
    return this.sizeRound(100 * this.UIContainer.offsetWidth / this.parentWidth);
  }
  set relativeWidth(value) {
    if (value <= 0)
      throw "Value must be strictly positive";
    this._relativeWidth = value;
    this._Width = Math.round(value * this.parentWidth / 100);
  }
  set relativeHeight(value) {
    if (value <= 0)
      throw "Value must be strictly positive";
    this._relativeHeight = value;
    this._Height = Math.round(value * this.parentHeight / 100);
  }
  get relativeHeight() {
    if (this._SizeIsRelative)
      return this._relativeHeight;
    return this.sizeRound(100 * this.UIContainer.offsetHeight / this.parentHeight);
  }
  updateRelativeSize() {
    if (Math.abs(this._relativeWidth * this.parentWidth / 100 - this.UIContainer.offsetWidth) > 1)
      this._relativeWidth = this.sizeRound(100 * this.UIContainer.offsetWidth / this.parentWidth);
    if (Math.abs(this._relativeHeight * this.parentHeight / 100 - this.UIContainer.offsetHeight) > 1)
      this._relativeHeight = this.sizeRound(100 * this.UIContainer.offsetHeight / this.parentHeight);
    if (Math.abs(this._relativePositionX * this.parentWidth / 100 - this.UIContainer.offsetLeft) > 1)
      this._relativePositionX = this.sizeRound(100 * this.UIContainer.offsetLeft / this.parentWidth);
    if (Math.abs(this._relativePositionY * this.parentHeight / 100 - this.UIContainer.offsetTop) > 1)
      this._relativePositionY = this.sizeRound(100 * this.UIContainer.offsetTop / this.parentHeight);
  }
  get Width() {
    if (this._SizeIsRelative)
      return this.relativeWidth;
    else
      return this.UIContainer.offsetWidth;
  }
  set Width(value) {
    if (value <= 0)
      throw "Value must be strictly positive";
    if (this._SizeIsRelative)
      this.relativeWidth = value;
    else
      this._Width = value;
    this.UIContainer.style.width = (this._Width - 2).toString() + "px";
    this.UIContainer.width = this._Width - 2;
    if (this._genRenderer != null)
      this._genRenderer.clearTransformationMatrix();
    this.DrawHandles(this.UIContainer.offsetLeft, this.UIContainer.offsetTop, this.UIContainer.offsetWidth, this.UIContainer.offsetHeight);
    this.containerResized();
  }
  get Height() {
    if (this._SizeIsRelative)
      return this.relativeHeight;
    else
      return this.UIContainer.offsetHeight;
  }
  set Height(value) {
    if (value <= 0)
      throw "Value must be strictly positive";
    if (this._SizeIsRelative)
      this.relativeHeight = value;
    else
      this._Height = value;
    this.UIContainer.style.height = (this._Height - 2).toString() + "px";
    this.UIContainer.height = this._Height - 2;
    if (this._genRenderer != null)
      this._genRenderer.clearTransformationMatrix();
    this.DrawHandles(this.UIContainer.offsetLeft, this.UIContainer.offsetTop, this.UIContainer.offsetWidth, this.UIContainer.offsetHeight);
    this.containerResized();
  }
  get SizeIsRelative() {
    return this._SizeIsRelative;
  }
  set SizeIsRelative(value) {
    if (this._SizeIsRelative != value) {
      this._SizeIsRelative = value;
      if (this._SizeIsRelative) {
        this._relativePositionX = this.sizeRound(100 * this.UIContainer.offsetLeft / this.parentWidth);
        this._relativePositionY = this.sizeRound(100 * this.UIContainer.offsetTop / this.parentHeight);
        this._relativeWidth = this.sizeRound(100 * this.UIContainer.offsetWidth / this.parentWidth);
        this._relativeHeight = this.sizeRound(100 * this.UIContainer.offsetHeight / this.parentHeight);
      }
      this.windowResized();
    }
  }
  get containerID() {
    return this._containerID;
  }
  set containerID(value) {
    if (this._containerID == value)
      return;
    let target = value != "" ? document.getElementById(value) : null;
    if (value != "" && target == null)
      throw "No HTMLElement on the page with such ID (" + value + ")";
    if (this.UIContainer.parentNode != null) {
      this.UIContainer.parentNode.removeChild(this.UIContainer);
    } else {
      document.body.removeChild(this.UIContainer);
    }
    if (target != null) {
      this.UIContainer.style.position = "relative";
      target.insertBefore(this.UIContainer, target.firstChild);
    } else {
      this.UIContainer.style.position = "absolute";
      document.body.insertBefore(this.UIContainer, document.body.firstChild);
    }
    this._genRenderer.clearTransformationMatrix();
    this.windowResized();
    this.DrawHandles(this.UIContainer.offsetLeft, this.UIContainer.offsetTop, this.UIContainer.offsetWidth, this.UIContainer.offsetHeight);
    this._containerID = value;
  }
  get Text() {
    return this._Text;
  }
  set Text(value) {
    this._Text = value;
    this.UIContainer.title = value;
  }
  set_name(name) {
    this.Text = name;
    this._genProp.Form_Text = name;
  }
  windowResized() {
    this._genRenderer.DisableRedraw();
    if (this._SizeIsRelative) {
      this.PositionX = this._relativePositionX;
      this.PositionY = this._relativePositionY;
      this.Height = this._relativeHeight;
      this.Width = this._relativeWidth;
    }
    this.containerResized();
    this._genRenderer.AllowRedraw();
  }
  ApplyRelativeSizeIfRequired() {
    if (this._initialContainerID != "") {
      if (document.getElementById(this._initialContainerID) != null) {
        this.containerID = this._initialContainerID;
      } else {
        logForm.log('Warning: cannot place widget in "' + this._initialContainerID + '" : no such HTML element.');
      }
    }
    this._SizeIsRelative = this._InitialSizeIsRelative;
    this.windowResized();
  }
  destroy() {
    window.removeEventListener("resize", this._windowResizeCallback);
    this._genRenderer.destroy();
    Object.entries(this).forEach((pair) => {
      Reflect.set(this, pair[0], null);
    });
  }
  getContainerOffset() {
    let it = this.UIContainer.offsetParent;
    let absx = 0;
    let absy = 0;
    while (it) {
      absy += it.offsetTop;
      absx += it.offsetLeft;
      it = it.offsetParent;
    }
    return new pointXY(absx, absy);
  }
  contextMenuCallBack(mouseX, mouseY) {
    let p = this._genRenderer.Scr2ElmMatrix.multiplyByV(Vector3.FromXYCoord(mouseX, mouseY)).toPoint();
    if (p.X >= 0 && p.X <= this.UIContainer.offsetWidth && p.Y >= 0 && p.Y <= this.UIContainer.offsetHeight) {
      this.contextMenuIsOpening();
    }
  }
  contextMenuIsOpening() {
  }
  constructor(node, editor, default_x, default_y, default_width, default_height) {
    this._genProp = null;
    this._genRenderer = null;
    this._BackColor = YColor.Transparent;
    this._BorderColor = YColor.Gray;
    this._relativePositionX = 0;
    this._relativePositionY = 0;
    this._PositionX = 0;
    this._PositionY = 0;
    this._relativeWidth = 100;
    this._relativeHeight = 100;
    this._Width = 300;
    this._Height = 0;
    this._InitialSizeIsRelative = false;
    this._SizeIsRelative = false;
    this._initialContainerID = "";
    this._containerID = "";
    this._Text = "";
    this.resizeCaptureRunning = false;
    this.resizeCaptureXOrigineMouse = 0;
    this.resizeCaptureYOrigineMouse = 0;
    this.resizeCaptureXOrigine = 0;
    this.resizeCaptureYOrigine = 0;
    this.resizeCaptureOriginalTop = 0;
    this.resizeCaptureOriginalLeft = 0;
    this.resizeCaptureOriginalWidth = 0;
    this.resizeCaptureOriginalHeight = 0;
    this.resizeCaptureHandleIndex = 0;
    this.resizeCaptureOriginalMatrix = null;
    this.resizeCaptureOriginalMatrixInv = null;
    this.previousTRansform = "";
    this.previousWidth = 0;
    this.previousHeight = 0;
    let left = typeof default_x != "undefined" ? default_x : 0;
    let top2 = typeof default_y != "undefined" ? default_y : 0;
    let width = typeof default_width != "undefined" ? default_width : 0;
    let height = typeof default_height != "undefined" ? default_height : 0;
    let bottom = Number.NaN;
    let right = Number.NaN;
    if (node != null) {
      let childnodes = node.get_childsByName();
      if ("location" in childnodes) {
        let it = childnodes["location"];
        let attributes = it.get_attributes();
        if ("x" in attributes)
          left = parseInt(attributes["x"]);
        if ("y" in attributes)
          top2 = parseInt(attributes["y"]);
      }
      if ("size" in childnodes) {
        let it = childnodes["size"];
        let attributes = it.get_attributes();
        if ("w" in attributes)
          width = parseInt(attributes["w"]);
        if ("h" in attributes)
          height = parseInt(attributes["h"]);
      }
      if ("relativeCoord" in childnodes) {
        let it = childnodes["relativeCoord"];
        let attributes = it.get_attributes();
        if ("x" in attributes)
          this._relativePositionX = this.sizeRound(parseFloat(attributes["x"]));
        if ("y" in attributes)
          this._relativePositionY = this.sizeRound(parseFloat(attributes["y"]));
        if ("w" in attributes)
          this._relativeWidth = this.sizeRound(parseFloat(attributes["w"]));
        if ("h" in attributes)
          this._relativeHeight = this.sizeRound(parseFloat(attributes["h"]));
        if ("active" in attributes)
          this._InitialSizeIsRelative = attributes["active"].toUpperCase() == "TRUE";
      }
      if ("container" in childnodes) {
        let it = childnodes["container"];
        let attributes = it.get_attributes();
        if ("id" in attributes)
          this._initialContainerID = attributes["id"];
      }
    }
    this.UIContainer = document.createElement("CANVAS");
    this.UIContainer.style.position = "absolute";
    YWidget.currentEdited = null;
    let h = window.innerHeight;
    let w = window.innerWidth;
    this.PositionX = this._InitialSizeIsRelative ? Math.round(w * (this._relativePositionX / 100)) : left;
    this.PositionY = this._InitialSizeIsRelative ? Math.round(h * (this._relativePositionY / 100)) : top2;
    this.Width = this._InitialSizeIsRelative ? Math.round(w * (this._relativeWidth / 100)) : width;
    this.Height = this._InitialSizeIsRelative ? Math.round(h * (this._relativeHeight / 100)) : height;
    this.UIContainer.style.border = "1px solid black";
    this.UIContainer.style.backgroundColor = this._BackColor.htmlCode;
    this.UIContainer.setAttribute("name", "YoctoVisualizationWidget");
    document.body.appendChild(this.UIContainer);
    this._windowResizeCallback = () => this.windowResized();
    window.addEventListener("resize", this._windowResizeCallback);
  }
  rearrangeZindexes() {
    let containers = document.getElementsByName("YoctoVisualizationWidget");
    let n = 0;
    for (let i = 0; i < containers.length; i++) {
      if (containers[i] != this.UIContainer) {
        containers[i].style.zIndex = n.toString();
        n++;
      }
    }
    this.UIContainer.style.zIndex = n.toString();
    n++;
    YWidget.HandlesDiv.style.zIndex = n.toString();
  }
  SensorArrivalcallback(source) {
  }
  SensorStateChangedcallback(source) {
    if (YWidget.currentEdited == this) {
      YWebPage.refreshEditor();
    }
  }
  SensorValuecallback(source, M) {
  }
  get isBeingEdited() {
    return YWidget.currentEdited == this;
  }
  static stopEdition() {
    if (YWidget.currentEdited != null) {
      YWidget.currentEdited.editStopped();
      YWidget.currentEdited = null;
    }
  }
  refreshProperties() {
  }
  edit() {
    YWidget.stopEdition();
    YWidget.currentEdited = this;
    if (YWidget.editHandles.length <= 0) {
      YWidget.HandlesDiv = document.createElement("DIV");
      YWidget.HandlesDiv.style.position = "absolute";
      YWidget.HandlesDiv.style.left = "0px";
      YWidget.HandlesDiv.style.top = "0px";
      YWidget.HandlesDiv.style.backgroundColor = "transparent";
      YWidget.HandlesDiv.style.transformOrigin = "top left";
      YWidget.HandlesDiv.style.pointerEvents = "none";
      for (let i = 0; i < 9; i++) {
        YWidget.editHandles.push(new ResizeMoveHandle(YWidget.HandlesDiv, i, (e) => {
          if (YWidget.currentEdited != null)
            YWidget.currentEdited.mouseStartCapture(e, i);
        }, (e) => {
          if (YWidget.currentEdited != null) {
            YWidget.currentEdited.touchStartCapture(e, i);
          }
        }));
      }
      document.body.appendChild(YWidget.HandlesDiv);
      document.addEventListener("touchmove", (e) => {
        if (YWidget.currentEdited != null)
          YWidget.currentEdited.touchCaptureRun(e);
      }, {passive: false});
      document.addEventListener("touchend", (e) => {
        if (YWidget.currentEdited != null)
          YWidget.currentEdited.touchCaptureStop(e);
      }, {passive: false});
      document.addEventListener("mousemove", (e) => {
        if (YWidget.currentEdited != null)
          YWidget.currentEdited.mouseCaptureRun(e);
      }, {passive: false});
      document.addEventListener("mouseup", (e) => {
        if (YWidget.currentEdited != null)
          YWidget.currentEdited.mouseCaptureStop(e);
      }, {passive: false});
    }
    this.DrawHandles(this.UIContainer.offsetLeft, this.UIContainer.offsetTop, this.UIContainer.offsetWidth, this.UIContainer.offsetHeight);
    YWidget.HandlesDiv.style.display = "";
    this.rearrangeZindexes();
  }
  DrawHandles(offsetLeft, offsetTop, offsetWidth, offsetHeight) {
    if (YWidget.currentEdited == null)
      return;
    if (YWidget.editHandles.length <= 0)
      return;
    YWidget.HandlesDiv.style.width = offsetWidth.toString() + "px";
    YWidget.HandlesDiv.style.height = offsetHeight.toString() + "px";
    if (this._genRenderer == null)
      debugger;
    let borderWidth = parseFloat(this.UIContainer.style.border);
    let borderMatrix = Matrix3x3.newTranslateMatrix(-borderWidth, -borderWidth);
    YWidget.HandlesDiv.style.transform = borderMatrix.multiplyByM(this._genRenderer.Elm2ScrMatrix).toCSS();
    YWidget.HandlesDiv.style.transform = "top left";
  }
  updateWindowPositionProperties(prop) {
    prop.Form_PositionX = this.PositionX;
    prop.Form_PositionY = this.PositionY;
    prop.Form_Width = this.Width;
    prop.Form_Height = this.Height;
  }
  touchStartCapture(e, handleIndex) {
    if (e.touches.length == 1) {
      this.handleMouseStartCapture(e.touches[0].pageX, e.touches[0].pageY, handleIndex);
      e.preventDefault();
    }
  }
  mouseStartCapture(e, handleIndex) {
    if (e.button != 0)
      return;
    this.handleMouseStartCapture(e.pageX, e.pageY, handleIndex);
  }
  handleMouseStartCapture(pageX, pageY, handleIndex) {
    this.resizeCaptureOriginalMatrix = this._genRenderer.Scr2ElmMatrix;
    this.resizeCaptureOriginalMatrixInv = this._genRenderer.Elm2ScrMatrix;
    let p = this.resizeCaptureOriginalMatrix.multiplyByV(Vector3.FromXYCoord(pageX, pageY)).toPoint();
    this.resizeCaptureRunning = true;
    this.resizeCaptureXOrigine = p.X;
    this.resizeCaptureYOrigine = p.Y;
    this.resizeCaptureOriginalLeft = this.UIContainer.offsetLeft;
    this.resizeCaptureOriginalTop = this.UIContainer.offsetTop;
    this.resizeCaptureOriginalWidth = this.UIContainer.offsetWidth;
    this.resizeCaptureOriginalHeight = this.UIContainer.offsetHeight;
    this.resizeCaptureHandleIndex = handleIndex;
    YWidget.editHandles[this.resizeCaptureHandleIndex].active = true;
    this.previousTRansform = YWidget.HandlesDiv.style.transform;
  }
  touchCaptureRun(e) {
    if (e.touches.length == 1) {
      this.handleCaptureRun(e.touches[0].pageX, e.touches[0].pageY);
      e.preventDefault();
    }
  }
  mouseCaptureRun(e) {
    this.handleCaptureRun(e.pageX, e.pageY);
  }
  handleCaptureRun(pageX, pageY) {
    if (!this.resizeCaptureRunning)
      return;
    let p = this.resizeCaptureOriginalMatrix.multiplyByV(Vector3.FromXYCoord(pageX, pageY)).toPoint();
    let dx = p.X - this.resizeCaptureXOrigine;
    let dy = p.Y - this.resizeCaptureYOrigine;
    let newLeft = this.resizeCaptureOriginalLeft;
    let newTop = this.resizeCaptureOriginalTop;
    let newWidth = this.resizeCaptureOriginalWidth;
    let newHeight = this.resizeCaptureOriginalHeight;
    switch (this.resizeCaptureHandleIndex) {
      case 0:
        newLeft += dx;
        newTop += dy;
        newWidth -= dx;
        newHeight -= dy;
        break;
      case 1:
        newTop += dy;
        newHeight -= dy;
        break;
      case 2:
        newTop += dy;
        newWidth += dx;
        newHeight -= dy;
        break;
      case 3:
        newWidth += dx;
        break;
      case 4:
        newWidth += dx;
        newHeight += dy;
        break;
      case 5:
        newHeight += dy;
        break;
      case 6:
        newLeft += dx;
        newWidth -= dx;
        newHeight += dy;
        break;
      case 7:
        newLeft += dx;
        newWidth -= dx;
        break;
      case 8:
        newLeft += dx;
        newTop += dy;
        break;
    }
    if (newWidth < 2 * YWidget.HANDLESIZE)
      newWidth = 2 * YWidget.HANDLESIZE;
    if (newHeight < 2 * YWidget.HANDLESIZE)
      newHeight = 2 * YWidget.HANDLESIZE;
    this.UIContainer.style.left = newLeft.toString() + "px";
    this.UIContainer.style.top = newTop.toString() + "px";
    if (this.resizeCaptureOriginalWidth != newWidth || this.resizeCaptureOriginalHeight != newHeight) {
      this.resize(newWidth - 2, newHeight - 2);
    }
    this._genRenderer.clearTransformationMatrix();
    YWidget.HandlesDiv.style.width = newWidth.toString() + "px";
    YWidget.HandlesDiv.style.height = newHeight.toString() + "px";
    YWidget.HandlesDiv.style.left = "0px";
    YWidget.HandlesDiv.style.top = "0px";
    let A = this.resizeCaptureOriginalMatrixInv;
    let B = Matrix3x3.newTranslateMatrix(newLeft - this.resizeCaptureOriginalLeft, newTop - this.resizeCaptureOriginalTop);
    let borderWidth = parseFloat(this.UIContainer.style.border);
    let borderMatrix = Matrix3x3.newTranslateMatrix(-borderWidth, -borderWidth);
    YWidget.HandlesDiv.style.transform = borderMatrix.multiplyByM(A.multiplyByM(B)).toCSS();
  }
  editStopped() {
    this.resizeCaptureRunning = false;
    if (YWidget.HandlesDiv != null)
      YWidget.HandlesDiv.style.display = "none";
  }
  touchCaptureStop(e) {
    this.mouseCaptureStop(null);
  }
  mouseCaptureStop(e) {
    if (!this.resizeCaptureRunning)
      return;
    this.resizeCaptureRunning = false;
    YWidget.editHandles[this.resizeCaptureHandleIndex].active = false;
    if (this.previousTRansform != YWidget.HandlesDiv.style.transform || this.resizeCaptureOriginalWidth != this.UIContainer.offsetWidth || this.resizeCaptureOriginalHeight != this.UIContainer.offsetHeight) {
      if (this._SizeIsRelative)
        this.updateRelativeSize();
      constants.edited = true;
    }
    this.refreshProperties();
  }
  resize(newWidth, newHeight) {
    this.UIContainer.style.width = newWidth.toString() + "px";
    this.UIContainer.style.height = newHeight.toString() + "px";
    this.containerResized();
  }
  containerResized() {
  }
  getContentsConfigData() {
    return "  <location x='" + this.UIContainer.offsetLeft.toString() + "' y='" + this.UIContainer.offsetTop.toString() + "'/>\n  <size     w='" + this.UIContainer.offsetWidth.toString() + "' h='" + this.UIContainer.offsetHeight.toString() + "'  state='Normal'/>\n  <relativeCoord x='" + this._relativePositionX.toString() + "' y='" + this._relativePositionY.toString() + "' w='" + this._relativeWidth.toString() + "' h='" + this._relativeHeight.toString() + "' active='" + (this._SizeIsRelative ? "True" : "False") + "'/>\n  <container id='" + constants.XMLquote(this._containerID) + "'/>\n" + this.getPropertiesXml();
  }
  getPropertiesXml() {
    return "";
  }
  PatchSensorAnnotationCallback(sensor, text) {
    let name = "None";
    let avgvalue = "N/A";
    let minvalue = "N/A";
    let maxvalue = "N/A";
    let unit = "";
    if (!(sensor instanceof NullYSensor)) {
      let resolution = -Math.round(Math.log10(sensor.get_resolution()));
      name = sensor.get_friendlyName();
      if (sensor.isOnline()) {
        avgvalue = sensor.get_lastAvgValue().toFixed(resolution);
        minvalue = sensor.get_lastMinValue().toFixed(resolution);
        maxvalue = sensor.get_lastMaxValue().toFixed(resolution);
      }
      unit = sensor.get_unit();
    }
    text = text.replace("$NAME$", name);
    text = text.replace("$AVGVALUE$", avgvalue);
    text = text.replace("$MAXVALUE$", maxvalue);
    text = text.replace("$MINVALUE$", minvalue);
    text = text.replace("$UNIT$", unit);
    return text;
  }
};
YWidget.HANDLESIZE = Math.round(20 * (1 + 2 * (constants.guiDPIFactor - 1)));
YWidget.editHandles = [];
YWidget.currentEdited = null;
var gaugeWidget = class extends YWidget {
  getPropertiesXml() {
    return this.prop.getXml(1);
  }
  containerResized() {
    if (this._gauge != null)
      this._gauge.containerResized();
  }
  destroy() {
    this.prop.destroy();
    super.destroy();
    Object.entries(this).forEach((pair) => {
      Reflect.set(this, pair[0], null);
    });
  }
  contextMenuIsOpening() {
    YWebPage.snapshotMenuItem.userdata = this;
    YWebPage.snapshotMenuItem.visible = true;
    YWebPage.resetDataViewMenuItem.visible = false;
    if (YWebPage.editMenuItem == null)
      return;
    YWebPage.clearDataloggerMenuItem.visible = true;
    YWebPage.editMenuItem.caption = "Configure this gauge";
    YWebPage.editMenuItem.visible = true;
    YWebPage.deleteMenuItem.caption = "Delete this gauge";
    YWebPage.deleteMenuItem.visible = true;
    YWebPage.addMarkerMenuItem.visible = false;
    YWebPage.disableMarkerMenuItem.visible = false;
    YWebPage.editMenuItem.userdata = this;
    YWebPage.deleteMenuItem.userdata = this;
  }
  get confirmDeleteString() {
    return "Do you really want to delete this gauge ?";
  }
  AnnotationCallback(text) {
    let sensor = this.prop.DataSource_source;
    return this.PatchSensorAnnotationCallback(sensor, text);
  }
  constructor(node, editor, x, y, width, height) {
    super(node, editor, x, y, width, height);
    this._gauge = new YSolidGauge(this.UIContainer, YSolidGauge.DisplayMode.DISPLAY90, YWidget.log);
    this._genRenderer = this._gauge;
    this.noDataSourcepanel = this._gauge.addMessagePanel();
    this.noDataSourcepanel.font.size = constants.generalFontSize;
    this.noDataSourcepanel.text = 'No data source configured\n 1 - Make sure you have a Yoctopuce sensor connected.\n 2 - Do a right-click or a long touch on this widget.\n 3 - Choose "Configure this gauge" to bring up the properties editor.\n 4 - Choose a data source\n';
    this.prop = new GaugeFormProperties(node, this);
    this._genProp = this.prop;
    let propDesc = GenericProperties.getAllProperties(this.prop);
    if (gaugeWidget.AnnotationPanelCount == 0) {
      for (let propname in propDesc.byName) {
        if (propname.startsWith("SolidGauge_annotationPanel"))
          gaugeWidget.AnnotationPanelCount++;
      }
    }
    for (let i = 0; i < gaugeWidget.AnnotationPanelCount; i++) {
      this._gauge.addAnnotationPanel();
    }
    this._gauge.setPatchAnnotationCallback((s) => {
      return this.AnnotationCallback(s);
    });
    this._gauge.valueFormater = (source, value) => {
      return this.valueFormater(source, value);
    };
    this.updateWindowPositionProperties(this.prop);
    this.prop.ApplyAllProperties(this);
    YDataRenderer.minMaxCheckDisabled = true;
    this.prop.ApplyAllProperties(this._gauge);
    YDataRenderer.minMaxCheckDisabled = false;
    this._gauge.resetRefrenceSize();
    this._gauge.resizeRule = Proportional.ResizeRule.RELATIVETOBOTH;
    this.ApplyRelativeSizeIfRequired();
    if (this.SizeIsRelative)
      this.refreshProperties();
    this._gauge.AllowRedraw();
  }
  valueFormater(source, value) {
    if (this.prop.DataSource_source instanceof NullYSensor) {
      return "N/A";
    } else if (!this.prop.DataSource_source.isOnline())
      return "OFFLINE";
    let format = this.prop.DataSource_precision;
    let p = format.indexOf(".");
    let n = 0;
    if (p >= 0)
      n = format.length - p - 1;
    let unit = this.prop.DataSource_source.get_unit();
    return value.toFixed(n) + unit;
  }
  PropertyChanged2(src) {
    let info = new PropPathinfo();
    let path = src.ExtractPropPath(info);
    switch (info.propType) {
      case "Form":
        GenericProperties.copyProperty_STT(this, this.prop, info.fullpropname, path);
        break;
      case "SolidGauge":
        GenericProperties.copyProperty_STT(this._gauge, this.prop, info.fullpropname, path);
        break;
      case "DataSource":
        break;
    }
  }
  Get_PropertyValue(src) {
    let info = new PropPathinfo();
    let path = src.ExtractPropPath(info);
    switch (info.propType) {
      case "Form":
        return GenericProperties.newGetProperty(this, this.prop, info.fullpropname, path, null);
      case "SolidGauge":
        return GenericProperties.newGetProperty(this._gauge, this.prop, info.fullpropname, path, null);
    }
    return null;
  }
  edit() {
    super.edit();
    YWebPage.EditObject(this, this.prop, (src) => {
      this.PropertyChanged2(src);
    }, (src) => {
      return this.Get_PropertyValue(src);
    }, () => {
      this.editStopped();
    });
  }
  refreshProperties() {
    this.prop.RefreshAllProperties(this);
    this.prop.RefreshAllProperties(this._gauge);
    YWebPage.refreshPropertiesForm();
  }
  SourceChanged(value, index) {
    this.noDataSourcepanel.enabled = value instanceof NullYSensor;
    if (value instanceof NullYSensor) {
      this._gauge.value = 0;
    } else {
      value.registerCallback(this);
    }
  }
  SensorValuecallback(source, M) {
    if (this.prop == null)
      return;
    if (source == this.prop.DataSource_source) {
      this._gauge.value = source.isOnline() ? M.get_averageValue() : 0;
    }
  }
  getConfigData() {
    return "<GaugeForm>\n" + this.getContentsConfigData() + "</GaugeForm>\n";
  }
};
gaugeWidget.AnnotationPanelCount = 0;
var angularGaugeWidget = class extends YWidget {
  getPropertiesXml() {
    return this.prop.getXml(1);
  }
  containerResized() {
    if (this._angularGauge != null)
      this._angularGauge.containerResized();
  }
  destroy() {
    this.prop.destroy();
    super.destroy();
    Object.entries(this).forEach((pair) => {
      Reflect.set(this, pair[0], null);
    });
  }
  AnnotationCallback(text) {
    let sensor = this.prop.DataSource_source;
    return this.PatchSensorAnnotationCallback(sensor, text);
  }
  contextMenuIsOpening() {
    YWebPage.snapshotMenuItem.userdata = this;
    YWebPage.snapshotMenuItem.visible = true;
    YWebPage.resetDataViewMenuItem.visible = false;
    if (YWebPage.editMenuItem == null)
      return;
    YWebPage.clearDataloggerMenuItem.visible = false;
    YWebPage.editMenuItem.caption = "Configure this gauge";
    YWebPage.editMenuItem.visible = true;
    YWebPage.deleteMenuItem.caption = "Delete this gauge";
    YWebPage.deleteMenuItem.visible = true;
    YWebPage.addMarkerMenuItem.visible = false;
    YWebPage.disableMarkerMenuItem.visible = false;
    YWebPage.editMenuItem.userdata = this;
    YWebPage.deleteMenuItem.userdata = this;
  }
  get confirmDeleteString() {
    return "Do you really want to delete this gauge ?";
  }
  constructor(node, editor, x, y, width, height) {
    super(node, editor, x, y, width, height);
    this._angularGauge = new YAngularGauge(this.UIContainer, YWidget.log);
    this._genRenderer = this._angularGauge;
    this.noDataSourcepanel = this._angularGauge.addMessagePanel();
    this.noDataSourcepanel.font.size = constants.generalFontSize;
    this.noDataSourcepanel.text = 'No data source configured\n 1 - Make sure you have a Yoctopuce sensor connected.\n 2 - Do a right-click  or a long touch on this widget.\n 3 - Choose "Configure this gauge" to bring up the properties editor.\n 4 - Choose a data source\n';
    this.prop = new AngularGaugeFormProperties(node, this);
    this._genProp = this.prop;
    let propDesc = GenericProperties.getAllProperties(this.prop);
    if (angularGaugeWidget.AnnotationPanelCount == 0) {
      for (let propname in propDesc.byName) {
        if (propname.startsWith("AngularGauge_annotationPanel"))
          angularGaugeWidget.AnnotationPanelCount++;
        if (propname.startsWith("AngularGauge_zone"))
          angularGaugeWidget.zonesCount++;
      }
    }
    for (let i = 0; i < angularGaugeWidget.zonesCount; i++) {
      this._angularGauge.AddZone();
    }
    for (let i = 0; i < angularGaugeWidget.AnnotationPanelCount; i++) {
      this._angularGauge.addAnnotationPanel();
    }
    this._angularGauge.setPatchAnnotationCallback((s) => {
      return this.AnnotationCallback(s);
    });
    this.initDataNode = node;
    this.updateWindowPositionProperties(this.prop);
    this.prop.ApplyAllProperties(this);
    YDataRenderer.minMaxCheckDisabled = true;
    this.prop.ApplyAllProperties(this._angularGauge);
    YDataRenderer.minMaxCheckDisabled = false;
    this._angularGauge.resetRefrenceSize();
    this._angularGauge.resizeRule = Proportional.ResizeRule.RELATIVETOBOTH;
    this.ApplyRelativeSizeIfRequired();
    if (this.SizeIsRelative)
      this.refreshProperties();
    this._angularGauge.AllowRedraw();
  }
  PropertyChanged2(src) {
    let info = new PropPathinfo();
    let path = src.ExtractPropPath(info);
    switch (info.propType) {
      case "Form":
        GenericProperties.copyProperty_STT(this, this.prop, info.fullpropname, path);
        break;
      case "AngularGauge":
        GenericProperties.copyProperty_STT(this._angularGauge, this.prop, info.fullpropname, path);
        break;
      case "DataSource":
        break;
    }
  }
  Get_PropertyValue(src) {
    let info = new PropPathinfo();
    let path = src.ExtractPropPath(info);
    switch (info.propType) {
      case "Form":
        return GenericProperties.newGetProperty(this, this.prop, info.fullpropname, path, null);
      case "AngularGauge":
        return GenericProperties.newGetProperty(this._angularGauge, this.prop, info.fullpropname, path, null);
    }
    return null;
  }
  edit() {
    super.edit();
    YWebPage.EditObject(this, this.prop, (src) => {
      this.PropertyChanged2(src);
    }, (src) => {
      return this.Get_PropertyValue(src);
    }, () => {
      this.editStopped();
    });
  }
  refreshProperties() {
    this.prop.RefreshAllProperties(this);
    this.prop.RefreshAllProperties(this._angularGauge);
    YWebPage.refreshPropertiesForm();
  }
  showStatus(status) {
    if (status != "")
      this._angularGauge.value = 0;
    this._angularGauge.showNeedle = status == "";
    this._angularGauge.statusLine = status;
  }
  SourceChanged(value, index) {
    this._angularGauge.DisableRedraw();
    this.noDataSourcepanel.enabled = value instanceof NullYSensor;
    if (value instanceof NullYSensor) {
      this.showStatus("N/A");
      this._angularGauge.unit = "";
    } else if (!value.isOnline()) {
      this.showStatus("OFFLINE");
    } else {
      this.showStatus("");
      this._angularGauge.unit = value.get_unit();
    }
    this._angularGauge.AllowRedraw();
    value.registerCallback(this);
  }
  SensorValuecallback(source, M) {
    if (this.prop == null)
      return;
    if (source == this.prop.DataSource_source) {
      this._angularGauge.DisableRedraw();
      if (this.prop.DataSource_source instanceof NullYSensor) {
        this.showStatus("N/A");
        this._angularGauge.unit = "";
      } else if (!this.prop.DataSource_source.isOnline()) {
        this.showStatus("OFFLINE");
      } else {
        this._angularGauge.DisableRedraw();
        this.showStatus("");
        this._angularGauge.unit = source.get_unit();
        this._angularGauge.value = M.get_averageValue();
        this._angularGauge.AllowRedraw();
      }
      this._angularGauge.AllowRedraw();
    }
  }
  getConfigData() {
    return "<angularGaugeForm>\n" + this.getContentsConfigData() + "</angularGaugeForm>\n";
  }
};
angularGaugeWidget.AnnotationPanelCount = 0;
angularGaugeWidget.zonesCount = 0;
var digitalDisplayWidget = class extends YWidget {
  getPropertiesXml() {
    return this.prop.getXml(1);
  }
  containerResized() {
    if (this._display != null)
      this._display.containerResized();
  }
  destroy() {
    this.prop.destroy();
    super.destroy();
    Object.entries(this).forEach((pair) => {
      Reflect.set(this, pair[0], null);
    });
  }
  AnnotationCallback(text) {
    let sensor = this.prop.DataSource_source;
    return this.PatchSensorAnnotationCallback(sensor, text);
  }
  contextMenuIsOpening() {
    YWebPage.snapshotMenuItem.userdata = this;
    YWebPage.snapshotMenuItem.visible = true;
    YWebPage.resetDataViewMenuItem.visible = false;
    if (YWebPage.editMenuItem == null)
      return;
    YWebPage.clearDataloggerMenuItem.visible = false;
    YWebPage.editMenuItem.caption = "Configure this digital display";
    YWebPage.editMenuItem.visible = true;
    YWebPage.deleteMenuItem.caption = "Delete this digital display";
    YWebPage.deleteMenuItem.visible = true;
    YWebPage.addMarkerMenuItem.visible = false;
    YWebPage.disableMarkerMenuItem.visible = false;
    YWebPage.editMenuItem.userdata = this;
    YWebPage.deleteMenuItem.userdata = this;
  }
  get confirmDeleteString() {
    return "Do you really want to delete this digital display ?";
  }
  constructor(node, editor, x, y, width, height) {
    super(node, editor, x, y, width, height);
    this._unit = "";
    this._display = new YDigitalDisplay(this.UIContainer, YWidget.log);
    this._genRenderer = this._display;
    this.noDataSourcepanel = this._display.addMessagePanel();
    this.noDataSourcepanel.font.size = constants.generalFontSize;
    this.noDataSourcepanel.text = 'No data source configured\n 1 - Make sure you have a Yoctopuce sensor connected.\n 2 - Do a right-click  or a long touch on this widget.\n 3 - Choose "Configure this digital display" to bring up the properties editor.\n 4 - Choose a data source\n';
    this.prop = new digitalDisplayFormProperties(node, this);
    this._genProp = this.prop;
    let propDesc = GenericProperties.getAllProperties(this.prop);
    if (digitalDisplayWidget.AnnotationPanelCount == 0) {
      for (let propname in propDesc.byName) {
        if (propname.startsWith("display_annotationPanel"))
          digitalDisplayWidget.AnnotationPanelCount++;
      }
    }
    for (let i = 0; i < digitalDisplayWidget.AnnotationPanelCount; i++) {
      this._display.addAnnotationPanel();
    }
    this._display.setPatchAnnotationCallback((s) => {
      return this.AnnotationCallback(s);
    });
    this._display.valueFormater = (source, value) => {
      return this.valueFormater(source, value);
    };
    this.updateWindowPositionProperties(this.prop);
    this.prop.ApplyAllProperties(this);
    YDataRenderer.minMaxCheckDisabled = true;
    this.prop.ApplyAllProperties(this._display);
    YDataRenderer.minMaxCheckDisabled = false;
    this._display.resetRefrenceSize();
    this._display.AllowPrintScreenCapture = true;
    this._display.resetRefrenceSize();
    this._display.resizeRule = Proportional.ResizeRule.RELATIVETOBOTH;
    this.ApplyRelativeSizeIfRequired();
    if (this.SizeIsRelative)
      this.refreshProperties();
    this._display.AllowRedraw();
  }
  valueFormater(source, value) {
    if (this.prop.DataSource_source instanceof NullYSensor) {
      return "N/A";
    } else if (!this.prop.DataSource_source.isOnline())
      return "OFFLINE";
    let format = this.prop.DataSource_precision;
    let p = format.indexOf(".");
    let n = 0;
    if (p >= 0)
      n = format.length - p - 1;
    let unit = this.prop.DataSource_source.get_unit();
    return value.toFixed(n) + unit;
  }
  PropertyChanged2(src) {
    let info = new PropPathinfo();
    let path = src.ExtractPropPath(info);
    switch (info.propType) {
      case "Form":
        GenericProperties.copyProperty_STT(this, this.prop, info.fullpropname, path);
        break;
      case "display":
        GenericProperties.copyProperty_STT(this._display, this.prop, info.fullpropname, path);
        break;
      case "DataSource":
        break;
    }
  }
  Get_PropertyValue(src) {
    let info = new PropPathinfo();
    let path = src.ExtractPropPath(info);
    switch (info.propType) {
      case "Form":
        return GenericProperties.newGetProperty(this, this.prop, info.fullpropname, path, null);
      case "display":
        return GenericProperties.newGetProperty(this._display, this.prop, info.fullpropname, path, null);
    }
    return null;
  }
  edit() {
    super.edit();
    YWebPage.EditObject(this, this.prop, (src) => {
      this.PropertyChanged2(src);
    }, (src) => {
      return this.Get_PropertyValue(src);
    }, () => {
      this.editStopped();
    });
  }
  refreshProperties() {
    this.prop.RefreshAllProperties(this);
    this.prop.RefreshAllProperties(this._display);
    YWebPage.refreshPropertiesForm();
  }
  SourceChanged(value, index) {
    this.noDataSourcepanel.enabled = value instanceof NullYSensor;
    this.SensorValuecallback(value, null);
    if (value instanceof NullYSensor) {
      this._display.alternateValue = "N/A";
    } else if (!value.isOnline())
      this._display.alternateValue = "OFFLINE";
    value.registerCallback(this);
  }
  SensorValuecallback(source, M) {
    if (this.prop == null)
      return;
    if (this.prop.DataSource_source instanceof NullYSensor) {
      this._display.alternateValue = "N/A";
    } else if (!this.prop.DataSource_source.isOnline()) {
      this._display.alternateValue = "OFFLINE";
    } else if (M == null) {
      this._display.alternateValue = "--" + this._unit;
    } else if (source == this.prop.DataSource_source) {
      this._display.DisableRedraw();
      this._display.alternateValue = null;
      this._display.value = M.get_averageValue();
      this._display.AllowRedraw();
    }
  }
  getConfigData() {
    return "<digitalDisplayForm>\n" + this.getContentsConfigData() + "</digitalDisplayForm>\n";
  }
};
digitalDisplayWidget.AnnotationPanelCount = 0;
var graphWidget = class extends YWidget {
  AnnotationCallback(text) {
    for (let i = 0; i < graphWidget.SeriesCount; i++) {
      let s = Reflect.get(this.prop, "Graph_series" + i.toString());
      let sensor = s.DataSource_source;
      let name = "None";
      let avgvalue = "N/A";
      let minvalue = "N/A";
      let maxvalue = "N/A";
      let unit = "";
      if (!(sensor instanceof NullYSensor)) {
        let resolution = -Math.round(Math.log10(sensor.get_resolution()));
        name = s.legend != "" ? s.legend : sensor.get_friendlyName();
        if (sensor.isOnline()) {
          avgvalue = sensor.get_lastAvgValue().toFixed(resolution);
          minvalue = sensor.get_lastMinValue().toFixed(resolution);
          maxvalue = sensor.get_lastMaxValue().toFixed(resolution);
        }
        unit = sensor.get_unit();
      }
      text = text.replace("$NAME" + (i + 1).toString() + "$", name);
      text = text.replace("$AVGVALUE" + (i + 1).toString() + "$", avgvalue);
      text = text.replace("$MAXVALUE" + (i + 1).toString() + "$", maxvalue);
      text = text.replace("$MINVALUE" + (i + 1).toString() + "$", minvalue);
      text = text.replace("$UNIT" + (i + 1).toString() + "$", unit);
    }
    return text;
  }
  destroy() {
    this.prop.destroy();
    super.destroy();
    Object.entries(this).forEach((pair) => {
      Reflect.set(this, pair[0], null);
    });
  }
  getPropertiesXml() {
    return this.prop.getXml(1);
  }
  containerResized() {
    if (this._graph != null)
      this._graph.containerResized();
  }
  contextMenuIsOpening() {
    YWebPage.snapshotMenuItem.userdata = this;
    YWebPage.snapshotMenuItem.visible = true;
    YWebPage.resetDataViewMenuItem.visible = true;
    YWebPage.resetDataViewMenuItem.userdata = this;
    if (YWebPage.editMenuItem == null)
      return;
    YWebPage.clearDataloggerMenuItem.visible = true;
    YWebPage.clearDataloggerMenuItem.userdata = this;
    YWebPage.editMenuItem.caption = "Configure this graph";
    YWebPage.editMenuItem.visible = true;
    YWebPage.deleteMenuItem.caption = "Delete this graph";
    YWebPage.deleteMenuItem.visible = true;
    YWebPage.addMarkerMenuItem.visible = true;
    YWebPage.disableMarkerMenuItem.visible = true;
    YWebPage.editMenuItem.userdata = this;
    YWebPage.deleteMenuItem.userdata = this;
    YWebPage.disableMarkerMenuItem.userdata = this;
    for (let i = 0; i < YWebPage.markersSubMenuItems.length; i++) {
      YWebPage.markersSubMenuItems[i].caption = "Place marker #" + (i + 1).toString();
      YWebPage.markersSubMenuItems[i].userdata = this;
    }
  }
  startMarkerCapture(markerIndex) {
    this.markers[markerIndex].startCapture();
  }
  AxisParamtersChangedAutomatically(source) {
    let yaxis = source.userData;
    yaxis.visible = source.visible;
    YWebPage.refreshPropertiesForm();
  }
  get confirmDeleteString() {
    return "Do you really want to delete this graph ?";
  }
  constructor(node, editor, x, y, width, height) {
    super(node, editor, x, y, width, height);
    this.editedMarkerWasEnabled = false;
    this.editedMarkerPosition = 0;
    this._graph = new YGraph(this.UIContainer, YWidget.log);
    this.noDataSourcepanel = this._graph.addMessagePanel();
    this.noDataSourcepanel.font.size = constants.generalFontSize;
    this.noDataSourcepanel.text = 'No data source configured\n 1 - Make sure you have a Yoctopuce sensor connected.\n 2 - Do a right-click  or a long touch on this widget.\n 3 - Choose "Configure this graph" to bring up the properties editor.\n 4 - Choose a data source\n';
    this.dataloggerProgress = this._graph.addMessagePanel();
    this.dataloggerProgress.font.size = 12 * constants.guiDPIFactor;
    this.dataloggerProgress.font.color = YColor.DarkGray;
    this.dataloggerProgress.borderColor = YColor.Gray;
    this.dataloggerProgress.panelHrzAlign = MessagePanel.HorizontalAlignPos.LEFT;
    this.dataloggerProgress.panelVrtAlign = MessagePanel.VerticalAlignPos.TOP;
    this.dataloggerProgress.text = graphWidget.DataLoggerLoadingMsg;
    this.dataloggerProgress.enabled = false;
    this.prop = new GraphFormProperties(node, this);
    this._genProp = this.prop;
    let propDesc = GenericProperties.getAllProperties(this.prop);
    if (graphWidget.YAxisCount == 0) {
      for (let propname in propDesc.byName) {
        if (propname.startsWith("Graph_annotationPanel"))
          graphWidget.AnnotationPanelCount++;
        if (propname.startsWith("Graph_series"))
          graphWidget.SeriesCount++;
        if (propname.startsWith("Graph_yAxes"))
          graphWidget.YAxisCount++;
      }
    }
    if (graphWidget.ZoneCountPerYaxis == 0) {
      let yAxisProp = new YaxisDescription(0, false);
      let propDesc2 = GenericProperties.getAllProperties(yAxisProp);
      for (let propname in propDesc2.byName) {
        if (propname.startsWith("zones"))
          graphWidget.ZoneCountPerYaxis++;
      }
    }
    if (graphWidget.MarkerCountPerXaxis == 0) {
      let xAxisProp = new XaxisDescription();
      let propDesc2 = GenericProperties.getAllProperties(xAxisProp);
      for (let propname in propDesc2.byName) {
        if (propname.startsWith("markers"))
          graphWidget.MarkerCountPerXaxis++;
      }
    }
    this.offLineSourcesPanel = this._graph.addMessagePanel();
    this.offLineSourcesPanel.bgColor = YColor.FromArgb(192, 255, 192, 192);
    this.offLineSourcesPanel.borderColor = YColor.DarkRed;
    this.offLineSourcesPanel.font.color = YColor.DarkRed;
    this.offLineSourcesPanel.panelHrzAlign = MessagePanel.HorizontalAlignPos.RIGHT;
    this.offLineSourcesPanel.panelVrtAlign = MessagePanel.VerticalAlignPos.TOP;
    this.captureRunningPanel = this._graph.addMessagePanel();
    this.captureRunningPanel.bgColor = YColor.FromArgb(240, 200, 255, 193);
    this.captureRunningPanel.borderColor = YColor.DarkGreen;
    this.captureRunningPanel.font.color = YColor.DarkGreen;
    this.captureRunningPanel.panelHrzAlign = MessagePanel.HorizontalAlignPos.LEFT;
    this.captureRunningPanel.panelVrtAlign = MessagePanel.VerticalAlignPos.TOP;
    for (let i = 0; i < graphWidget.YAxisCount; i++) {
      let axis = this._graph.addYAxis();
      for (let j = 0; j < graphWidget.ZoneCountPerYaxis; j++) {
        axis.AddZone();
      }
    }
    this.markers = [];
    for (let i = 0; i < graphWidget.MarkerCountPerXaxis; i++) {
      let m = this._graph.xAxis.AddMarker();
      m.xposition = TimeConverter.ToUnixTime(new Date()) + i * 60;
      this.markers.push(m);
    }
    for (let i = 0; i < graphWidget.AnnotationPanelCount; i++) {
      this._graph.addAnnotationPanel();
    }
    this.seriesProperties = [];
    for (let i = 0; i < graphWidget.SeriesCount; i++) {
      this.seriesProperties.push(Reflect.get(this.prop, "Graph_series" + i.toString()));
      this._graph.addSerie();
    }
    this._graph.yAxes[0].visible = true;
    this._graph.setPatchAnnotationCallback((s) => {
      return this.AnnotationCallback(s);
    });
    this._genRenderer = this._graph;
    this._graph.resetRefrenceSize();
    this._graph.AllowPrintScreenCapture = true;
    this._graph.setMarkerCaptureCallbacks((m) => {
      this.MarkedCaptureStarted(m);
    }, (m) => {
      this.MarkedCaptureStopped(m);
    });
    this.offlineMessages = new Array(graphWidget.SeriesCount);
    this.showOffline = new Array(graphWidget.SeriesCount);
    this.updateWindowPositionProperties(this.prop);
    this.prop.ApplyAllProperties(this);
    YDataRenderer.minMaxCheckDisabled = true;
    this.prop.ApplyAllProperties(this._graph);
    YDataRenderer.minMaxCheckDisabled = false;
    for (let i = 0; i < graphWidget.YAxisCount; i++) {
      this._graph.yAxes[i].AxisChanged = () => {
        this.AxisParamtersChangedAutomatically(this._graph.yAxes[i]);
      };
      this._graph.yAxes[i].AllowAutoShow = true;
    }
    for (let i = 0; i < graphWidget.SeriesCount; i++) {
      let s = Reflect.get(this.prop, "Graph_series" + i.toString());
      s.Init(this, i);
      if (s.DataSource_source != null) {
        this.SourceChanged(s.DataSource_source, i);
      }
    }
    this._graph.resetRefrenceSize();
    this._graph.resizeRule = Proportional.ResizeRule.FIXED;
    this.ApplyRelativeSizeIfRequired();
    if (this.SizeIsRelative)
      this.refreshProperties();
    this.loadRecordedDataIfNeeded();
    this._graph.AllowRedraw();
  }
  MarkedCaptureStarted(src) {
    let str = src.text != "" ? 'Click to place the "' + src.shortText + '" marker.' : "Click to place the marker.";
    str += "\nRight-click to cancel the operation.";
    this.editedMarkerWasEnabled = src.enabled;
    this.editedMarkerPosition = src.positionOnXAxis.value;
    this.captureRunningPanel.text = str;
    this.captureRunningPanel.enabled = true;
  }
  MarkedCaptureStopped(src) {
    if (src != null) {
      if (this.editedMarkerWasEnabled != src.enabled && this.editedMarkerPosition != src.positionOnXAxis.value) {
        constants.edited = true;
      }
    }
    this.captureRunningPanel.enabled = false;
    this.refreshProperties();
  }
  refreshProperties() {
    this.prop.RefreshAllProperties(this);
    this.prop.RefreshAllProperties(this._graph);
    YWebPage.refreshPropertiesForm();
  }
  decomposeToSegments(data, start, dataCount) {
    let n1 = start;
    let n2 = 0;
    let l = [];
    let deltaT = 0;
    while (n1 < start + dataCount - 1) {
      try {
        deltaT = data[n1 + 1].DateTime - data[n1].DateTime;
      } catch (Exception) {
        debugger;
      }
      n2 = n1 + 1;
      while (n2 < dataCount && data[n2].DateTime - data[n2 - 1].DateTime < 2 * deltaT) {
        n2++;
      }
      let count = n2 - n1;
      if (count > 0) {
        let p = new Array(count);
        for (let i = 0; i < count; i++) {
          p[i] = new pointXY(data[n1 + i].DateTime, data[n1 + i].value);
        }
        l.push(p);
      }
      n1 = n2;
    }
    return l;
  }
  SourceChanged(value, index) {
    this._graph.DisableRedraw();
    let s;
    let noDataSource = true;
    for (let i = 0; i < graphWidget.SeriesCount; i++) {
      s = Reflect.get(this.prop, "Graph_series" + i.toString());
      if (!(s.DataSource_source instanceof NullYSensor))
        noDataSource = false;
    }
    this.noDataSourcepanel.enabled = noDataSource;
    if (value != null) {
      if (!(value instanceof NullYSensor)) {
        if (value.isOnline()) {
          this.showOffline[index] = false;
        } else {
          this.offlineMessages[index] = value.get_friendlyName() + " is OFFLINE";
          this.showOffline[index] = true;
          logForm.log(value.get_friendlyName() + " is OFFLINE");
        }
      } else {
        this.showOffline[index] = false;
      }
    } else {
      this.showOffline[index] = false;
    }
    this.updateOfflinePanel();
    this.preLoadSensorData(value, index);
    this.loadRecordedDataIfNeeded();
    if (value)
      value.registerCallback(this);
    this._graph.AllowRedraw();
  }
  SensorArrivalcallback(source) {
    this.loadRecordedDataIfNeeded();
    for (let i = 0; i < graphWidget.SeriesCount; i++) {
      let s = this.seriesProperties[i];
      if (s.DataSource_source == source) {
        if (!s.DataSource_source.isOnline())
          this.showOffline[i] = true;
        else
          this.showOffline[i] = false;
      }
    }
    this.updateOfflinePanel();
  }
  preLoadSensorData(value, index) {
    if (value instanceof NullYSensor) {
      this._graph.series[index].clear();
      return;
    }
    let s = Reflect.get(this.prop, "Graph_series" + index.toString());
    let data;
    switch (s.DataSource_datatype) {
      case 1:
        data = value.minData;
        break;
      case 2:
        data = value.maxData;
        break;
      default:
        data = value.curData;
        break;
    }
    let l = this.decomposeToSegments(data, 0, data.length);
    this._graph.series[index].clear();
    for (let i = l.length - 1; i >= 0; i--) {
      this._graph.series[index].InsertPoints(l[i]);
    }
    this._graph.series[index].rebuildSummaries();
  }
  PropertyChanged2(src) {
    let info = new PropPathinfo();
    let path = src.ExtractPropPath(info);
    switch (info.propType) {
      case "Form":
        GenericProperties.copyProperty_STT(this, this.prop, info.fullpropname, path);
        break;
      case "Graph":
        GenericProperties.copyProperty_STT(this._graph, this.prop, info.fullpropname, path);
        break;
      case "DataSource":
        break;
    }
  }
  Get_PropertyValue(src) {
    let info = new PropPathinfo();
    let path = src.ExtractPropPath(info);
    switch (info.propType) {
      case "Form":
        return GenericProperties.newGetProperty(this, this.prop, info.fullpropname, path, null);
      case "Graph":
        return GenericProperties.newGetProperty(this._graph, this.prop, info.fullpropname, path, null);
      case "DataSource":
        return null;
    }
    return null;
  }
  edit() {
    super.edit();
    YWebPage.EditObject(this, this.prop, (src) => {
      this.PropertyChanged2(src);
    }, (src) => {
      return this.Get_PropertyValue(src);
    }, () => {
      this.editStopped();
    });
  }
  updateOfflinePanel() {
    let message = "";
    for (let i = 0; i < graphWidget.SeriesCount; i++) {
      if (this.showOffline[i])
        message = message + (message != "" ? "\n" : "") + this.offlineMessages[i];
    }
    if (message == "" && this.offLineSourcesPanel.enabled)
      this.offLineSourcesPanel.enabled = false;
    if (message != "" && (this.offLineSourcesPanel.text != message || !this.offLineSourcesPanel.enabled)) {
      this.offLineSourcesPanel.text = message;
      this.offLineSourcesPanel.enabled = true;
    }
  }
  SensorValuecallback(source, M) {
    if (this.prop == null)
      return;
    for (let i = 0; i < graphWidget.SeriesCount; i++) {
      let s = this.seriesProperties[i];
      if (s.DataSource_source == source) {
        if (!s.DataSource_source.isOnline()) {
          this.offlineMessages[i] = s.DataSource_source.get_friendlyName() + " is OFFLINE";
          this.showOffline[i] = true;
          this.updateOfflinePanel();
          return;
        }
        this.showOffline[i] = false;
        this.updateOfflinePanel();
        let index = s.DataSource_source.curData.length - 1;
        if (index >= 0)
          switch (s.DataSource_datatype) {
            case 1:
              this._graph.series[i].AddPoint(new pointXY(s.DataSource_source.minData[index].DateTime, s.DataSource_source.minData[index].value));
              break;
            case 2:
              this._graph.series[i].AddPoint(new pointXY(s.DataSource_source.maxData[index].DateTime, s.DataSource_source.maxData[index].value));
              break;
            default:
              this._graph.series[i].AddPoint(new pointXY(s.DataSource_source.curData[index].DateTime, s.DataSource_source.curData[index].value));
              break;
          }
        this._graph.series[i].unit = s.DataSource_source.get_unit();
      }
    }
  }
  disableAllMarkers() {
    confirm.ask("Do you really want to disable all markers?", () => {
      for (let i = 0; i < this.markers.length; i++) {
        this.markers[i].enabled = false;
      }
    }, () => {
    }, null);
  }
  clearDataLogger() {
    confirm.ask("Do you really want to erase contents of all dataloggers related to this graph?", () => {
      this.startToClearDataLoggers();
    }, () => {
    }, null);
  }
  truncateView() {
    for (let i = 0; i < graphWidget.SeriesCount; i++) {
      this._graph.series[i].clear();
    }
    let FirstLiveValue = Math.floor(new Date().getTime() / 1e3);
    this._graph.xAxis.set_minMax(FirstLiveValue, FirstLiveValue + this._graph.xAxis.initialZoom);
  }
  resetDataView() {
    this.prop.Graph_showRecordedData = false;
    this.truncateView();
  }
  async startToClearDataLoggers() {
    let loggers = [];
    for (let i = 0; i < graphWidget.SeriesCount; i++) {
      let s = Reflect.get(this.prop, "Graph_series" + i.toString());
      let sensor = s.DataSource_source;
      if (!(sensor instanceof NullYSensor)) {
        sensor.stopDataloggerloading();
        let serial = sensor.get_hardwareId();
        let n = serial.indexOf(".");
        serial = serial.substring(0, n);
        let d = await YDataLogger.FindDataLogger(serial + ".dataLogger");
        if (await d.isOnline()) {
          let found = false;
          for (let j = 0; j < loggers.length; j++) {
            if (loggers[j] == d)
              found = true;
          }
          if (!found)
            loggers.push(d);
        }
      }
    }
    for (let i = 0; i < loggers.length; i++) {
      await loggers[i].forgetAllDataStreams();
      await loggers[i].set_recording(YDataLogger.RECORDING_ON);
    }
    let tmp = this.prop.Graph_showRecordedData;
    this.prop.Graph_showRecordedData = false;
    this.truncateView();
    this.prop.Graph_showRecordedData = tmp;
  }
  dataLoggerLoadprocessIsRunningNotification(source) {
    let loadTotalPercent = 0;
    let sensorCount = 0;
    if (!this.prop.Graph_showRecordedData)
      return;
    for (let i = 0; i < graphWidget.SeriesCount; i++) {
      let s = Reflect.get(this.prop, "Graph_series" + i.toString());
      let sensor = s.DataSource_source;
      if (sensor.dataloggerLoadisRunning) {
        loadTotalPercent += sensor.dataloggerLoadProgress;
        sensorCount++;
      }
    }
    if (sensorCount > 0)
      this.dataloggerProgress.text = graphWidget.DataLoggerLoadingMsg + " (" + (loadTotalPercent / sensorCount).toFixed(0) + "%)";
    let showPanel = sensorCount > 0 && loadTotalPercent > 0 && loadTotalPercent < sensorCount * 100;
    this.dataloggerProgress.enabled = showPanel;
  }
  SensorNewDataBlock(source, sourceFromIndex, sourcetoIndex, targetIndex, fromDataLogger) {
    if (this.prop == null)
      return;
    if (fromDataLogger && !this.prop.Graph_showRecordedData)
      return;
    let l = null;
    for (let i = 0; i < graphWidget.SeriesCount; i++) {
      let s = Reflect.get(this.prop, "Graph_series" + i.toString());
      if (s.DataSource_source == source) {
        let count = sourcetoIndex - sourceFromIndex + 1;
        if (count > 1) {
          switch (s.DataSource_datatype) {
            case 1:
              l = this.decomposeToSegments(s.DataSource_source.minData, sourceFromIndex, count);
              for (let j = l.length - 1; j >= 0; j--) {
                this._graph.series[i].InsertPoints(l[j]);
              }
              break;
            case 2:
              l = this.decomposeToSegments(s.DataSource_source.maxData, sourceFromIndex, count);
              for (let j = l.length - 1; j >= 0; j--) {
                this._graph.series[i].InsertPoints(l[j]);
              }
              break;
            default:
              l = this.decomposeToSegments(s.DataSource_source.curData, sourceFromIndex, count);
              for (let j = l.length - 1; j >= 0; j--) {
                this._graph.series[i].InsertPoints(l[j]);
              }
              break;
          }
        }
        this._graph.series[i].unit = source.get_unit();
      }
    }
  }
  loadRecordedDataIfNeeded() {
    if (this.prop == null)
      return;
    if (!this.prop.Graph_showRecordedData)
      return;
    for (let i = 0; i < graphWidget.SeriesCount; i++) {
      let s = Reflect.get(this.prop, "Graph_series" + i.toString());
      s.DataSource_source.startDataloggerload(this);
    }
  }
  removeDataloggerData() {
  }
  DataloggerCompleted(Source) {
    if (!this.prop.Graph_showRecordedData)
      return;
    let props = GenericProperties.getAllProperties(this.prop);
    for (let i = 0; i < this.seriesProperties.length; i++) {
      if (this.seriesProperties[i].DataSource_source == Source) {
        if (!this.seriesProperties[i].dataloggerAlreadyLoaded) {
          this._graph.DisableRedraw();
          this.preLoadSensorData(Source, i);
          this._graph.AllowRedraw();
        }
      }
    }
  }
  getConfigData() {
    return "<GraphForm>\n" + this.getContentsConfigData() + "</GraphForm>\n";
  }
};
graphWidget.AnnotationPanelCount = 0;
graphWidget.SeriesCount = 0;
graphWidget.ZoneCountPerYaxis = 0;
graphWidget.MarkerCountPerXaxis = 0;
graphWidget.YAxisCount = 0;
graphWidget.DataLoggerLoadingMsg = "Loading from datalogger";

// obj/full/propertiesMngmt.js
var YXmlNode = class {
  constructor(node) {
    this.node = node;
  }
  get Name() {
    return this.node.nodeName;
  }
  get_childsByName() {
    let res = {};
    this.node.childNodes.forEach((child) => {
      res[child.nodeName] = new YXmlNode(child);
    });
    return res;
  }
  get_childsByIndex() {
    let res = [];
    this.node.childNodes.forEach((child) => {
      res.push(new YXmlNode(child));
    });
    return res;
  }
  get_attributes() {
    let el = this.node;
    let res = {};
    let keys = el.getAttributeNames();
    for (let i = 0; i < keys.length; i++) {
      res[keys[i]] = el.getAttribute(keys[i]);
    }
    return res;
  }
  get Attributes() {
    return this.get_attributes();
  }
};
var PropertyAccess = class {
  constructor() {
    this.ttype = "";
    this.stype = "";
    this.finalTarget = null;
    this.terminalSource = null;
    this.propertyName = null;
  }
};
var doubleNan = class {
  constructor(v) {
    this._value = Number.NaN;
    if (typeof v == "undefined") {
      return;
    } else if (typeof v == "number") {
      this._value = v;
    } else if (typeof v == "string") {
      if (v == "") {
        this._value = Number.NaN;
      } else {
        this._value = Number(v);
      }
    } else {
      debugger;
    }
  }
  toString() {
    if (Number.isNaN(this._value))
      return "";
    return this._value.toString();
  }
  clone() {
    return new doubleNan(this.value);
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value;
  }
};
var PropertyDescriptor = class {
  constructor(name) {
    this.isWritable = false;
    this.isEnum = false;
    this.type = "";
    this.Attributes = {};
    this.name = name;
  }
};
var PropertiesList = class {
  constructor() {
    this.byIndex = [];
    this.byName = {};
  }
};
var PropDescription = class {
  constructor(name, prop) {
    this.name = name;
    this.prop = prop;
  }
};
var GenericProperties = class {
  static NoFilter(propNname) {
    return true;
  }
  static escapeXml(unsafe) {
    return unsafe.replace(/[^ !#$%(-;=?-z]/g, (c) => "&#" + c.charCodeAt(0) + ";");
  }
  constructor(Owner) {
    this._Form_Text = "New window";
    this._Form_BackColor = YColor.FromArgb(255, 240, 240, 240);
    this._Form_BorderColor = YColor.LightGray;
    this._SizeIsRelative = false;
    this._Form_PositionX = 0;
    this._Form_PositionY = 0;
    this._Form_Width = 300;
    this._Form_Height = 200;
    this._containerID = "";
    this.ownerForm = Owner;
    this._Form_Text = "new window";
  }
  destroy() {
    Object.entries(this).forEach((pair) => {
      Reflect.set(this, pair[0], null);
    });
  }
  initFromXmlData(initData) {
    if (initData != null)
      this.loadProperties(initData, this.ownerForm, this);
  }
  loadProperties(initData, Owner, o) {
    let value;
    this.ownerForm = Owner;
    if (initData != null) {
      let properties = GenericProperties.getAllProperties(o);
      let childs = initData.get_childsByName();
      for (let propname in properties.byName) {
        let p = properties.byName[propname];
        if (p.isWritable) {
          for (let childName in childs) {
            if (childName == propname) {
              let target = Reflect.get(o, propname);
              let Mustload = true;
              if ("NotSavedInXMLAttribute" in p.Attributes) {
                Mustload = p.Attributes["NotSavedInXMLAttribute"];
              }
              if (Mustload) {
                if (GenericProperties.IsStructured(target)) {
                  this.loadProperties(childs[childName], Owner, target);
                } else {
                  let targetType = typeof target;
                  let attributes = childs[childName].get_attributes();
                  let value2 = attributes["value"];
                  if (target instanceof CustomYSensor) {
                    if (value2.toUpperCase() != "NULL" && value2 != "") {
                      let s = sensorsManager.AddNewSensor(value2);
                      Reflect.set(o, propname, s);
                    } else {
                      Reflect.set(o, propname, sensorsManager.getNullSensor());
                    }
                  } else if (target instanceof YEnumItem) {
                    Reflect.set(o, propname, target.fromString(value2));
                  } else if (target instanceof doubleNan) {
                    let d = new doubleNan(value2);
                    Reflect.set(o, propname, d);
                  } else if (target instanceof xAxisPosition) {
                    let xpos = Number(value2);
                    let rel = attributes["relative"].toUpperCase() == "TRUE";
                    Reflect.set(o, propname, new xAxisPosition(xpos, rel));
                  } else if (target instanceof YColor) {
                    let c = YColor.FromString(value2);
                    if (c == null)
                      c = YColor.Black;
                    Reflect.set(o, propname, c.clone());
                  } else if (target instanceof YFont) {
                    let size = attributes["size"];
                    let color = attributes["color"];
                    let italic = attributes["italic"];
                    let bold = attributes["bold"];
                    let f = Reflect.get(o, propname);
                    f.name = value2;
                    f.size = size !== "undefined" ? Number(size) : 10;
                    let c = YColor.FromString(color);
                    f.color = c != null ? c : YColor.Black.clone();
                    f.italic = italic.toUpperCase() == "TRUE";
                    f.bold = bold.toUpperCase() == "TRUE";
                  } else {
                    switch (targetType) {
                      case "string":
                        Reflect.set(o, propname, value2);
                        break;
                      case "number":
                        Reflect.set(o, propname, Number(value2));
                        break;
                      case "boolean":
                        let v = value2.toUpperCase() == "TRUE";
                        Reflect.set(o, propname, v);
                        break;
                      default:
                        debugger;
                        throw "unhandled target type : " + targetType + "(" + target.constructor.name + ")";
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  get ATTR_Form_Text__DisplayName() {
    return "Window title";
  }
  get ATTR_Form_Text__CategoryAttribute() {
    return "Window";
  }
  get ATTR_Form_Text__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_Form_Text__DescriptionAttribute() {
    return "Widget name. This name is not show on display, but it might help you to identify each widget. ";
  }
  get Form_Text() {
    return this._Form_Text;
  }
  set Form_Text(value) {
    this._Form_Text = value;
  }
  get ATTR_Form_BackColor__DisplayName() {
    return "Background color";
  }
  get ATTR_Form_BackColor__CategoryAttribute() {
    return "Window";
  }
  get ATTR_Form_BackColor__DescriptionAttribute() {
    return "Window background color.";
  }
  get Form_BackColor() {
    return this._Form_BackColor;
  }
  set Form_BackColor(value) {
    this._Form_BackColor = value;
  }
  get ATTR_Form_BorderColor__DisplayName() {
    return "Border color";
  }
  get ATTR_Form_BorderColor__CategoryAttribute() {
    return "Window";
  }
  get ATTR_Form_BorderColor__DescriptionAttribute() {
    return "Window border color, use transparent color to hide the border.";
  }
  get Form_BorderColor() {
    return this._Form_BorderColor;
  }
  set Form_BorderColor(value) {
    this._Form_BorderColor = value;
  }
  get ATTR_Form_SizeIsRelative__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_Form_SizeIsRelative__DisplayName() {
    return "Rel. size and pos.";
  }
  get ATTR_Form_SizeIsRelative__CategoryAttribute() {
    return "Window";
  }
  get ATTR_Form_SizeIsRelative__DescriptionAttribute() {
    return "Makes widget size and position relative to container size. This, for instance, allows to make a widget automatically occupy all of the browser viewport, no matter the browser window size. In relative mode, position and size value are expressed in %";
  }
  get ATTR_Form_SizeIsRelative__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get Form_SizeIsRelative() {
    return this._SizeIsRelative;
  }
  set Form_SizeIsRelative(value) {
    this._SizeIsRelative = value;
  }
  get ATTR_Form_PositionX__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_Form_PositionX__DisplayName() {
    return "Left";
  }
  get ATTR_Form_PositionX__CategoryAttribute() {
    return "Window";
  }
  get ATTR_Form_PositionX__DescriptionAttribute() {
    return "Widget left border X position";
  }
  get Form_PositionX() {
    return this._Form_PositionX;
  }
  set Form_PositionX(value) {
    this._Form_PositionX = value;
  }
  get ATTR_Form_PositionY__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_Form_PositionY__DisplayName() {
    return "Top";
  }
  get ATTR_Form_PositionY__CategoryAttribute() {
    return "Window";
  }
  get ATTR_Form_PositionY__DescriptionAttribute() {
    return "Widget top border Y position";
  }
  get Form_PositionY() {
    return this._Form_PositionY;
  }
  set Form_PositionY(value) {
    this._Form_PositionY = value;
  }
  get ATTR_Form_Width__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_Form_Width__DisplayName() {
    return "Width";
  }
  get ATTR_Form_Width__CategoryAttribute() {
    return "Window";
  }
  get ATTR_Form_Width__DescriptionAttribute() {
    return "Widget width";
  }
  get Form_Width() {
    return this._Form_Width;
  }
  set Form_Width(value) {
    this._Form_Width = value;
  }
  get ATTR_Form_Height__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_Form_Height__DisplayName() {
    return "Height";
  }
  get ATTR_Form_Height__CategoryAttribute() {
    return "Window";
  }
  get ATTR_Form_Height__DescriptionAttribute() {
    return "Widget height";
  }
  get Form_Height() {
    return this._Form_Height;
  }
  set Form_Height(value) {
    this._Form_Height = value;
  }
  get ATTR_Form_containerID__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_Form_containerID__DisplayName() {
    return "Container ID";
  }
  get ATTR_Form_containerID__CategoryAttribute() {
    return "Window";
  }
  get ATTR_Form_containerID__DescriptionAttribute() {
    return "Forces the widget to be shown inside an HTML element with a specific ID already present on the page. If ID is empty, the widget is inserted at root level. Be aware that X,Y offsets are kept, you may want to set them to Zero. ";
  }
  get Form_containerID() {
    return this._containerID;
  }
  set Form_containerID(value) {
    this._containerID = value;
  }
  indent(n) {
    return " ".repeat(n);
  }
  getXml(deep, o) {
    if (typeof o == "undefined")
      o = this;
    let res = "";
    let value = "";
    let properties = GenericProperties.getAllProperties(o);
    let propName = "";
    for (propName in properties.byName) {
      let p = properties.byName[propName];
      if (p.isWritable) {
        let Mustsave = true;
        if ("NotSavedInXMLAttribute" in p.Attributes)
          Mustsave = !p.Attributes["NotSavedInXMLAttribute"];
        let child = Reflect.get(o, p.name);
        if (GenericProperties.IsStructured(child)) {
          if (Mustsave) {
            res = res + this.indent(2 * deep) + "<" + p.name + ">\r\n" + this.getXml(deep + 1, child) + this.indent(2 * deep) + "</" + p.name + ">\r\n";
          }
        } else {
          if (Mustsave) {
            if (child instanceof YEnumItem) {
              value = child.toString;
            } else {
              let type = typeof child;
              if (type == "object")
                type = child.constructor.name;
              switch (type) {
                case "boolean":
                  value = child ? "TRUE" : "FALSE";
                  break;
                case "number":
                  value = child.toString();
                  break;
                case "string":
                  value = GenericProperties.escapeXml(child);
                  break;
                case YColor.name:
                  value = child.toString();
                  break;
                case doubleNan.name:
                  value = child.value.toString();
                  break;
                case xAxisPosition.name:
                  let it = child;
                  value = it.value.toString() + '" relative="' + (it.relative ? "True" : "False");
                  break;
                case NullYSensor.name:
                case CustomYSensor.name:
                  let s = child;
                  value = s == null || s instanceof NullYSensor ? "NULL" : s.get_hardwareId();
                  break;
                default:
                  throw "XML generation : unhandled type (" + p.type + ")";
              }
            }
            res = res + this.indent(2 * deep) + "<" + p.name + ' value="' + value + '"/>\n';
          }
        }
      }
    }
    return res;
  }
  static IsStructured(o) {
    if (o == null)
      return false;
    if (typeof o === "string" || o instanceof String)
      return false;
    if (typeof o === "number" || o instanceof Number)
      return false;
    if (typeof o === "boolean" || o instanceof Boolean)
      return false;
    if (o instanceof YEnumItem)
      return false;
    if (o instanceof CustomYSensor)
      return false;
    if (o instanceof YColor)
      return false;
    if (o instanceof doubleNan)
      return false;
    if (o instanceof xAxisPosition)
      return false;
    if (Object.getOwnPropertyNames(o).length > 0)
      return true;
    return false;
  }
  static getObjectFromPath(rootTarget, path) {
    let FinalTarget = rootTarget;
    for (let i = 0; i < path.length - 1; i++) {
      let name = path[i];
      let index = "";
      while (name.charCodeAt(name.length - 1) >= 48 && name.charCodeAt(name.length - 1) <= 57) {
        index = name.charAt(name.length - 1) + index;
        name = name.substring(0, name.length - 1);
      }
      if (index == "") {
        FinalTarget = Reflect.get(FinalTarget, name);
      } else {
        let arrayObject = Reflect.get(FinalTarget, name);
        FinalTarget = Reflect.get(arrayObject, parseInt(index));
      }
    }
    return FinalTarget;
  }
  static computePropertyAccess_SFT(WidgetObject, SettingObject, propertySourceName, path) {
    let res = new PropertyAccess();
    res.ttype = "";
    res.stype = "";
    res.finalTarget = null;
    res.terminalSource = null;
    res.terminalSource = GenericProperties.getObjectFromPath(WidgetObject, path);
    let props = GenericProperties.getAllProperties(res.terminalSource);
    if (!(path[path.length - 1] in props.byName))
      return res;
    res.stype = typeof res.terminalSource[path[path.length - 1]];
    if (res.stype == "object" && res.terminalSource[path[path.length - 1]] != null) {
      res.stype = res.terminalSource[path[path.length - 1]].constructor.name;
    }
    res.terminalSource = res.terminalSource[path[path.length - 1]];
    if (res.terminalSource == null)
      return res;
    res.propertyName = propertySourceName;
    res.finalTarget = SettingObject;
    let o = res.finalTarget[propertySourceName];
    res.ttype = typeof o;
    if (res.ttype == "object" && o != null)
      res.ttype = o.constructor.name;
    if (path.length <= 1)
      return res;
    for (let i = 1; i < path.length; i++) {
      res.finalTarget = res.finalTarget[res.propertyName];
      res.propertyName = path[i];
    }
    res.ttype = typeof res.finalTarget[res.propertyName];
    if (res.ttype == "object" && res.finalTarget[res.propertyName] != null)
      res.ttype = res.finalTarget[res.propertyName].constructor.name;
    return res;
  }
  static Reflect_getIndexed(o, indexedProp) {
    let res = Reflect.get(o, indexedProp);
    if (typeof res !== "undefined")
      return res;
    let name = indexedProp;
    let index = "";
    while (name.charCodeAt(name.length - 1) >= 48 && name.charCodeAt(name.length - 1) <= 57) {
      index = name.charAt(name.length - 1) + index;
      name = name.substring(0, name.length - 1);
    }
    if (index == "") {
      return null;
    }
    res = Reflect.get(o, name);
    return Reflect.get(res, parseInt(index));
  }
  static computePropertyAccess(rootTarget, source, propertySourceName, path) {
    let res = new PropertyAccess();
    res.ttype = "";
    res.finalTarget = GenericProperties.getObjectFromPath(rootTarget, path);
    res.terminalSource = source;
    res.terminalSource = Reflect.get(res.terminalSource, propertySourceName);
    for (let i = 1; i < path.length; i++) {
      res.terminalSource = Reflect.get(res.terminalSource, path[i]);
    }
    res.stype = typeof res.terminalSource;
    if (res.stype == "object")
      res.stype = res.terminalSource.constructor.name;
    if (path.length > 0) {
      res.propertyName = path[path.length - 1];
      let o = GenericProperties.Reflect_getIndexed(rootTarget, path[0]);
      if (o == null)
        return null;
      for (let i = 1; i < path.length; i++) {
        try {
          o = GenericProperties.Reflect_getIndexed(o, path[i]);
        } catch (e) {
          debugger;
        }
      }
      res.ttype = typeof o;
      if (res.ttype == "object")
        res.ttype = o.constructor.name;
    } else {
      let targetname = propertySourceName;
      let n = targetname.indexOf("__");
      res.propertyName = targetname.substring(n + 2);
      let o = Reflect.get(rootTarget, res.propertyName);
      res.ttype = typeof o;
      if (res.ttype == "object")
        res.ttype = o.constructor.name;
    }
    return res;
  }
  static newGetProperty(rootTarget, source, propertySourceName, path, filterAllow) {
    let access = GenericProperties.computePropertyAccess(rootTarget, source, propertySourceName, path);
    if (access == null)
      return null;
    return Reflect.get(access.finalTarget, access.propertyName);
  }
  static copyProperty_SFT(rootTarget, source, propertySourceName, path, filterAllow) {
    let ttype = "";
    let stype = "";
    let TerminalSource = null;
    let p = GenericProperties.computePropertyAccess_SFT(rootTarget, source, propertySourceName, path);
    if (p.finalTarget == null)
      return;
    ttype = p.ttype;
    stype = p.stype;
    if (stype == YColor.name && ttype == YColor.name) {
      Reflect.set(p.finalTarget, p.propertyName, p.terminalSource.clone());
    } else if (stype == xAxisPosition.name && ttype == xAxisPosition.name) {
      Reflect.set(p.finalTarget, p.propertyName, p.terminalSource.clone());
    } else if (p.stype == "number" && ttype == doubleNan.name) {
      Reflect.set(p.finalTarget, p.propertyName, new doubleNan(p.terminalSource));
    } else {
      Reflect.set(p.finalTarget, p.propertyName, p.terminalSource);
    }
  }
  static copyProperty_STT(rootTarget, source, propertySourceName, path, filterAllow) {
    let p = GenericProperties.computePropertyAccess(rootTarget, source, propertySourceName, path);
    if (p == null)
      return;
    if (p.stype == doubleNan.name && p.ttype == "number") {
      let v = p.terminalSource.value;
      if (Reflect.get(p.finalTarget, p.propertyName) != v) {
        Reflect.set(p.finalTarget, p.propertyName, v);
        constants.edited = true;
      }
    } else if (p.stype != p.ttype) {
      debugger;
    } else if (p.stype == YColor.name && p.ttype == YColor.name) {
      let color = p.terminalSource;
      if (!color.equal(Reflect.get(p.finalTarget, p.propertyName))) {
        Reflect.set(p.finalTarget, p.propertyName, color.clone());
        constants.edited = true;
      }
    } else if (p.stype == doubleNan.name && p.ttype == doubleNan.name) {
      let v = p.terminalSource;
      if (Reflect.get(p.finalTarget, p.propertyName) != v) {
        Reflect.set(p.finalTarget, p.propertyName, v.clone());
        constants.edited = true;
      }
    } else if (p.stype == xAxisPosition.name && p.ttype == xAxisPosition.name) {
      let x = p.terminalSource;
      let x2 = Reflect.get(p.finalTarget, p.propertyName);
      if (x.relative != x2.relative || x.value != x2.value) {
        Reflect.set(p.finalTarget, p.propertyName, x.clone());
        constants.edited = true;
      }
    } else if (Reflect.get(p.finalTarget, p.propertyName) != p.terminalSource) {
      Reflect.set(p.finalTarget, p.propertyName, p.terminalSource);
      constants.edited = true;
    }
  }
  ApplyAllProperties(target) {
    this.ApplyAllPropertiesEx(target, GenericProperties.NoFilter, 0);
  }
  RefreshAllProperties(target) {
    this.ApplyAllPropertiesEx(target, GenericProperties.NoFilter, 1);
  }
  ApplyProperties(rootSource, rootTarget, fullpropname, sourceValue, path, direction) {
    if (sourceValue instanceof AlarmSection)
      return;
    let sourceproperties = GenericProperties.getAllProperties(this);
    if ("CopyToTarget" in sourceproperties.byName[fullpropname].Attributes) {
      if (!sourceproperties.byName[fullpropname].Attributes["CopyToTarget"]) {
        return;
      }
    }
    if (!GenericProperties.IsStructured(sourceValue)) {
      if (direction == 0) {
        GenericProperties.copyProperty_STT(rootTarget, this, fullpropname, path);
      } else {
        GenericProperties.copyProperty_SFT(rootTarget, this, fullpropname, path);
      }
    } else {
      let path2 = path.slice();
      path2.push("");
      let target = GenericProperties.getObjectFromPath(rootTarget, path2);
      Reflect.set(target, "userData", sourceValue);
      let sourceproperties2 = GenericProperties.getAllProperties(sourceValue);
      for (let subpropname in sourceproperties2.byName) {
        let shouldcopy = true;
        if ("CopyToTarget" in sourceproperties2.byName[subpropname].Attributes) {
          shouldcopy = sourceproperties2.byName[subpropname].Attributes["CopyToTarget"];
        }
        if (sourceproperties2.byName[subpropname].isWritable && shouldcopy) {
          path.push(subpropname);
          this.ApplyProperties(rootSource, rootTarget, fullpropname, Reflect.get(sourceValue, subpropname), path, direction);
          path.splice(path.length - 1, 1);
        }
      }
    }
  }
  static isProperty(proto, propName) {
    let d = Reflect.getOwnPropertyDescriptor(proto, propName);
    let list = Object.getOwnPropertyNames(d);
    for (let i = 0; i < list.length; i++) {
      if (list[i] == "set")
        return true;
      if (list[i] == "get")
        return true;
    }
    return false;
  }
  static isWritable(proto, propName) {
    let d = Reflect.getOwnPropertyDescriptor(proto, propName);
    let list = Object.getOwnPropertyNames(d);
    for (let i = 0; i < list.length; i++) {
      if (list[i] == "set") {
        if (typeof d.set !== "undefined")
          return true;
      }
    }
    return false;
  }
  static getAllProperties(o) {
    if (typeof o === "undefined")
      debugger;
    if (o.hasOwnProperty("PropertiesDescriptionCache")) {
      return o["PropertiesDescriptionCache"];
    }
    let proto = Object.getPrototypeOf(o);
    let res = new PropertiesList();
    let p = proto;
    let entries = [];
    let genealogy = [];
    while (p != null) {
      genealogy.push(p);
      p = Object.getPrototypeOf(p);
    }
    for (let j = genealogy.length - 1; j >= 0; j--) {
      let names = Object.getOwnPropertyNames(genealogy[j]);
      let index = 0;
      for (let i = 0; i < names.length; i++) {
        if (names[i] != "constructor" && !names[i].startsWith("__")) {
          entries.splice(index, 0, new PropDescription(names[i], genealogy[j]));
          index++;
          for (let k = entries.length - 1; k >= index; k--) {
            if (entries[k].name == names[i])
              entries.splice(k, 1);
          }
        }
      }
    }
    for (let i = 0; i < entries.length; i++) {
      if (!entries[i].name.startsWith("ATTR") && entries[i].name != "constructor" && !entries[i].name.startsWith("__")) {
        if (GenericProperties.isProperty(entries[i].prop, entries[i].name)) {
          let d = new PropertyDescriptor(entries[i].name);
          res.byIndex.push(d);
          res.byName[d.name] = d;
          d.isWritable = GenericProperties.isWritable(entries[i].prop, entries[i].name);
          d.isEnum = o[entries[i].name] instanceof YEnumItem;
          d.type = typeof o[entries[i].name];
          if (d.type == "object" && o[entries[i].name] != null) {
            d.type = o[entries[i].name].constructor.name;
          }
        }
      }
    }
    for (let i = 0; i < entries.length; i++) {
      if (entries[i].name.startsWith("ATTR_")) {
        let p2 = entries[i].name.indexOf("__");
        if (p2 < 5)
          debugger;
        let name = entries[i].name.substring(5, p2);
        let attr = entries[i].name.substring(p2 + 2);
        if (typeof res.byName[name] === "undefined")
          debugger;
        try {
          res.byName[name].Attributes[attr] = Reflect.get(o, entries[i].name);
        } catch (e) {
          debugger;
        }
      }
    }
    o["PropertiesDescriptionCache"] = res;
    return res;
  }
  ApplyAllPropertiesEx(target, filter, direction) {
    let properties = GenericProperties.getAllProperties(this);
    for (let fullpropname in properties.byName) {
      if (properties.byName[fullpropname].isWritable) {
        let index = fullpropname.indexOf("_");
        if (index < 0)
          throw "invalid Property name";
        let propType = fullpropname.substring(0, index);
        let propname = fullpropname.substring(index + 1);
        let path = [];
        path.push(propname);
        if (target instanceof YWidget && propType == "Form") {
          this.ApplyProperties(this, target, fullpropname, Reflect.get(this, fullpropname), path, direction);
        }
        if (target instanceof YAngularGauge && propType == "AngularGauge") {
          this.ApplyProperties(this, target, fullpropname, Reflect.get(this, fullpropname), path, direction);
        }
        if (target instanceof YDigitalDisplay && propType == "display") {
          this.ApplyProperties(this, target, fullpropname, Reflect.get(this, fullpropname), path, direction);
        }
        if (target instanceof YSolidGauge && propType == "SolidGauge") {
          this.ApplyProperties(this, target, fullpropname, Reflect.get(this, fullpropname), path, direction);
        }
        if (target instanceof YGraph && propType == "Graph") {
          this.ApplyProperties(this, target, fullpropname, Reflect.get(this, fullpropname), path, direction);
        }
      }
    }
  }
};
GenericProperties.XmlFileVersion = -1;

// obj/full/properties.js
var GenericHints = class {
};
GenericHints.DevConfAffected = " Changing this value will affect the device configuration.";
GenericHints.CheckSensor = "If the sensor you want to use is connected, but not listed or listed as OFFLINE, check USB / Network configuration in the global configuration.";
GenericHints.AnnotationGraph = "Annotation text.  Use \\n for carriage returns. Some variables are available: $DAY$ $MONTH$ $YEAR$ for date, $HOUR$ $MINUTE$ $SECOND$ for time, $AVGVALUE1$ $MINVALUE1$ $MAXVALUE1$ $NAME1$ $UNIT1$  for first series data, $AVGVALUE2$ $MINVALUE2$ $MAXVALUE2$ $NAME2$ $UNIT2$  for second series data and so on";
GenericHints.Annotation = "Annotation text.  Use \\n for carriage returns. Some variables are available: $DAY$ $MONTH$ $YEAR$ for date, $HOUR$ $MINUTE$ $SECOND$ for time, $AVGVALUE$ $MINVALUE$ $MAXVALUE$ $NAME$ $UNIT$ for sensor related data.";
var sensorFreqTypeDescription = class {
  static get AllowedValues() {
    return this._AllowedValues;
  }
};
sensorFreqTypeDescription._AllowedValues = [
  "25/s",
  "10/s",
  "5/s",
  "4/s",
  "3/s",
  "2/s",
  "1/s",
  "60/m",
  "30/m",
  "12/m",
  "6/m",
  "4/m",
  "3/m",
  "2/m",
  "1/m",
  "30/h",
  "12/h",
  "6/h",
  "4/h",
  "3/h",
  "2/h",
  "1/h"
];
var yAxisDescription = class {
  static initialize() {
    let yaxiscount = 0;
    let obj = new GraphFormProperties(null, null);
    let names = Object.getOwnPropertyNames(obj);
    names.forEach((name) => {
      if (name.startsWith("_Graph_yAxes"))
        yaxiscount++;
    });
    for (let i = 0; i < yaxiscount; i++) {
      switch (i) {
        case 0:
          this._AllowedValues.push("1rst Y axis");
          break;
        case 1:
          this._AllowedValues.push("2nd Y axis");
          break;
        case 2:
          this._AllowedValues.push("3rd Y axis");
          break;
        default:
          this._AllowedValues.push((i + 1).toString() + "th Y axis");
          break;
      }
    }
    yAxisDescription.initialized = true;
  }
  static get AllowedValues() {
    if (!yAxisDescription.initialized)
      yAxisDescription.initialize();
    return this._AllowedValues;
  }
};
yAxisDescription._AllowedValues = [];
var AlarmTestTypeDescription = class {
  static get AllowedValues() {
    return this._AllowedValues;
  }
};
AlarmTestTypeDescription._AllowedValues = ["Disabled", ">", ">=", "=", "<=", "<"];
var fontNameTypeDescription = class {
  static fontNameTypeDescription() {
  }
  static get AllowedValues() {
    return this._AllowedValues;
  }
};
fontNameTypeDescription._AllowedValues = [
  "Arial",
  "Brush Script MT",
  "Comic Sans MS",
  "Courier New",
  "Garamond",
  "Georgia",
  "Helvetica",
  "Impact",
  "Tahoma",
  "Times New Roman",
  "Trebuchet MS",
  "Verdana"
];
var sensorPrecisionTypeDescription = class {
  static get AllowedValues() {
    return this._AllowedValues;
  }
};
sensorPrecisionTypeDescription._AllowedValues = ["0", "0.1", "0.12", "0.123"];
var sensorDataTypeDescription = class {
  static get AllowedValues() {
    return this._AllowedValues;
  }
};
sensorDataTypeDescription._AllowedValues = ["Avg values", "Min values", "Max values"];
var GaugeFormProperties = class extends GenericProperties {
  constructor(initData, owner) {
    super(owner);
    this._DataSource_source = sensorsManager.getNullSensor();
    this._DataSource_precision = "0.1";
    this._DataSource_AlarmSection0 = new AlarmSection(0);
    this._DataSource_AlarmSection1 = new AlarmSection(1);
    this._SolidGauge_min = 0;
    this._SolidGauge_max = 100;
    this._SolidGauge_showMinMax = true;
    this._SolidGauge_color1 = YColor.LightGreen;
    this._SolidGauge_color2 = YColor.Red;
    this._SolidGauge_font = new FontDescription("Arial", 20, YColor.Black, false, true);
    this._SolidGauge_minMaxFont = new FontDescription("Arial", 10, YColor.Black, false, true);
    this._SolidGauge_displayMode = YSolidGauge.DisplayMode.DISPLAY90;
    this._SolidGauge_borderColor = YColor.Black;
    this._SolidGauge_borderThickness = 2;
    this._SolidGauge_backgroundColor1 = YColor.FromArgb(255, 240, 240, 240);
    this._SolidGauge_backgroundColor2 = YColor.FromArgb(255, 200, 200, 200);
    this._SolidGauge_thickness = 25;
    this._SolidGauge_maxSpeed = 1;
    this._annotationPanels0 = new AnnotationPanelDescription(GenericPanel.HorizontalAlignPos.CENTER, GenericPanel.VerticalAlignPos.BOTTOM, 0, false, "$NAME$", YColor.FromArgb(0, 127, 127, 127), YColor.FromArgb(0, 127, 127, 127), 10, YColor.FromArgb(255, 0, 0, 0));
    this._annotationPanels1 = new AnnotationPanelDescription(GenericPanel.HorizontalAlignPos.CENTER, GenericPanel.VerticalAlignPos.BOTTOM, 0, false, "$NAME$", YColor.FromArgb(0, 127, 127, 127), YColor.FromArgb(0, 127, 127, 127), 10, YColor.FromArgb(255, 0, 0, 0));
    this.initFromXmlData(initData);
    this.PropagateDataSourceChange();
  }
  PropagateDataSourceChange() {
    this.ownerForm.SourceChanged(this._DataSource_source, 0);
    let props = GenericProperties.getAllProperties(this).byName;
    let name;
    for (name in props) {
      if (name.startsWith("DataSource_AlarmSection")) {
        this[name].setDataSource(this._DataSource_source);
      }
    }
  }
  get ATTR_DataSource_source__DisplayName() {
    return "Sensor";
  }
  get ATTR_DataSource_source__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_source__ParamCategorySummaryAttribute() {
    return "sensorDescription";
  }
  get ATTR_DataSource_source__PreExpandedCategoryAttribute() {
    return true;
  }
  get ATTR_DataSource_source__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_DataSource_source__DescriptionAttribute() {
    return "Yoctopuce sensor feeding the gauge. ";
  }
  get DataSource_source() {
    return this._DataSource_source;
  }
  set DataSource_source(value) {
    let prev = this._DataSource_source;
    this._DataSource_source = value;
    this.PropagateDataSourceChange();
    if (this._DataSource_source != prev)
      constants.edited = true;
  }
  get sensorDescription() {
    return this._DataSource_source instanceof NullYSensor ? "none" : this._DataSource_source.get_friendlyName();
  }
  get isSensorReadOnly() {
    return this._DataSource_source.isReadOnly;
  }
  get ATTR_DataSource_freq__DisplayName() {
    return "Sensor freq";
  }
  get ATTR_DataSource_freq__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_freq__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_DataSource_freq__IsReadonlyCallAttribute() {
    return this.isSensorReadOnly;
  }
  get ATTR_DataSource_freq__AllowedValues() {
    return sensorFreqTypeDescription.AllowedValues;
  }
  get ATTR_DataSource_freq__DescriptionAttribute() {
    return "Sensor data acquisition frequency." + GenericHints.DevConfAffected;
  }
  get DataSource_freq() {
    return this._DataSource_source.get_frequency();
  }
  set DataSource_freq(value) {
    this._DataSource_source.set_frequency(value);
  }
  get ATTR_DataSource_precision__DisplayName() {
    return "Precision";
  }
  get ATTR_DataSource_precision__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_precision__DescriptionAttribute() {
    return "How many digits shown after the decimal point";
  }
  get ATTR_DataSource_precision__AllowedValues() {
    return sensorPrecisionTypeDescription.AllowedValues;
  }
  get DataSource_precision() {
    return this._DataSource_precision;
  }
  set DataSource_precision(value) {
    this._DataSource_precision = value;
  }
  get ATTR_DataSource_AlarmSection0__DisplayName() {
    return "Sensor value alarm 1";
  }
  get ATTR_DataSource_AlarmSection0__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection0__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection0__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_AlarmSection0__DescriptionAttribute() {
    return "Alarm 1 for this data source, expand for more.";
  }
  get DataSource_AlarmSection0() {
    return this._DataSource_AlarmSection0;
  }
  set DataSource_AlarmSection0(value) {
    this._DataSource_AlarmSection0 = value;
  }
  get ATTR_DataSource_AlarmSection1__DisplayName() {
    return "Sensor value alarm 2";
  }
  get ATTR_DataSource_AlarmSection1__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection1__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection1__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_AlarmSection1__DescriptionAttribute() {
    return "Alarm 2 for this data source, expand for more.";
  }
  get DataSource_AlarmSection1() {
    return this._DataSource_AlarmSection1;
  }
  set DataSource_AlarmSection1(value) {
    this._DataSource_AlarmSection1 = value;
  }
  get ATTR_SolidGauge_min__DisplayName() {
    return "Minimum value";
  }
  get ATTR_SolidGauge_min__CategoryAttribute() {
    return "Values range";
  }
  get ATTR_SolidGauge_min__DescriptionAttribute() {
    return "Minimum value displayable by the gauge.";
  }
  get SolidGauge_min() {
    return this._SolidGauge_min;
  }
  set SolidGauge_min(value) {
    this._SolidGauge_min = value;
  }
  get ATTR_SolidGauge_max__DisplayName() {
    return "Maximum value";
  }
  get ATTR_SolidGauge_max__CategoryAttribute() {
    return "Values range";
  }
  get ATTR_SolidGauge_max__DescriptionAttribute() {
    return "Maximum value displayable by the gauge.";
  }
  get SolidGauge_max() {
    return this._SolidGauge_max;
  }
  set SolidGauge_max(value) {
    this._SolidGauge_max = value;
  }
  get ATTR_SolidGauge_showMinMax__DisplayName() {
    return "show  min/max";
  }
  get ATTR_SolidGauge_showMinMax__CategoryAttribute() {
    return "Values range";
  }
  get ATTR_SolidGauge_showMinMax__DescriptionAttribute() {
    return "Show the min / max values.";
  }
  get SolidGauge_showMinMax() {
    return this._SolidGauge_showMinMax;
  }
  set SolidGauge_showMinMax(value) {
    this._SolidGauge_showMinMax = value;
  }
  get ATTR_SolidGauge_color1__DisplayName() {
    return "Min Color";
  }
  get ATTR_SolidGauge_color1__CategoryAttribute() {
    return "Values range";
  }
  get ATTR_SolidGauge_color1__DescriptionAttribute() {
    return "Color for minimum value.";
  }
  get SolidGauge_color1() {
    return this._SolidGauge_color1;
  }
  set SolidGauge_color1(value) {
    this._SolidGauge_color1 = value;
  }
  get ATTR_SolidGauge_color2__DisplayName() {
    return "Max Color";
  }
  get ATTR_SolidGauge_color2__CategoryAttribute() {
    return "Values range";
  }
  get ATTR_SolidGauge_color2__DescriptionAttribute() {
    return "Color for maximum value.";
  }
  get SolidGauge_color2() {
    return this._SolidGauge_color2;
  }
  set SolidGauge_color2(value) {
    this._SolidGauge_color2 = value;
  }
  get ATTR_SolidGauge_font__DisplayName() {
    return "Unit  Font";
  }
  get ATTR_SolidGauge_font__CategoryAttribute() {
    return "Fonts";
  }
  get ATTR_SolidGauge_font__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_SolidGauge_font__DescriptionAttribute() {
    return "Font for displaying the value/status indicator";
  }
  get SolidGauge_font() {
    return this._SolidGauge_font;
  }
  set SolidGauge_font(value) {
    this._SolidGauge_font = value;
  }
  get ATTR_SolidGauge_minMaxFont__DisplayName() {
    return "Min Max  Font";
  }
  get ATTR_SolidGauge_minMaxFont__CategoryAttribute() {
    return "Fonts";
  }
  get ATTR_SolidGauge_minMaxFont__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_SolidGauge_minMaxFont__DescriptionAttribute() {
    return "Font for displaying min/max values";
  }
  get SolidGauge_minMaxFont() {
    return this._SolidGauge_minMaxFont;
  }
  set SolidGauge_minMaxFont(value) {
    this._SolidGauge_minMaxFont = value;
  }
  get ATTR_SolidGauge_displayMode__DisplayName() {
    return "Display mode";
  }
  get ATTR_SolidGauge_displayMode__CategoryAttribute() {
    return "Dial";
  }
  get ATTR_SolidGauge_displayMode__DescriptionAttribute() {
    return "Dial general shape";
  }
  get SolidGauge_displayMode() {
    return this._SolidGauge_displayMode;
  }
  set SolidGauge_displayMode(value) {
    this._SolidGauge_displayMode = value;
  }
  get ATTR_SolidGauge_borderColor__DisplayName() {
    return "Border color";
  }
  get ATTR_SolidGauge_borderColor__CategoryAttribute() {
    return "Dial";
  }
  get ATTR_SolidGauge_borderColor__DescriptionAttribute() {
    return "Dial border color.";
  }
  get SolidGauge_borderColor() {
    return this._SolidGauge_borderColor;
  }
  set SolidGauge_borderColor(value) {
    this._SolidGauge_borderColor = value;
  }
  get ATTR_SolidGauge_borderThickness__DisplayName() {
    return "Border thickness ";
  }
  get ATTR_SolidGauge_borderThickness__CategoryAttribute() {
    return "Dial";
  }
  get ATTR_SolidGauge_borderThickness__DescriptionAttribute() {
    return "Thickness of the dial border";
  }
  get SolidGauge_borderThickness() {
    return this._SolidGauge_borderThickness;
  }
  set SolidGauge_borderThickness(value) {
    this._SolidGauge_borderThickness = value;
  }
  get ATTR_SolidGauge_backgroundColor1__DisplayName() {
    return "Background color 1";
  }
  get ATTR_SolidGauge_backgroundColor1__CategoryAttribute() {
    return "Dial";
  }
  get ATTR_SolidGauge_backgroundColor1__DescriptionAttribute() {
    return "Dial background gradient color 1.";
  }
  get SolidGauge_backgroundColor1() {
    return this._SolidGauge_backgroundColor1;
  }
  set SolidGauge_backgroundColor1(value) {
    this._SolidGauge_backgroundColor1 = value;
  }
  get ATTR_SolidGauge_backgroundColor2__DisplayName() {
    return "Background color 2";
  }
  get ATTR_SolidGauge_backgroundColor2__CategoryAttribute() {
    return "Dial";
  }
  get ATTR_SolidGauge_backgroundColor2__DescriptionAttribute() {
    return "Dial background gradient color 2.";
  }
  get SolidGauge_backgroundColor2() {
    return this._SolidGauge_backgroundColor2;
  }
  set SolidGauge_backgroundColor2(value) {
    this._SolidGauge_backgroundColor2 = value;
  }
  get ATTR_SolidGauge_thickness__DisplayName() {
    return "Dial thickness (%) ";
  }
  get ATTR_SolidGauge_thickness__CategoryAttribute() {
    return "Dial";
  }
  get ATTR_SolidGauge_thickness__DescriptionAttribute() {
    return "Thickness of the dial, in percentage relative to radius";
  }
  get SolidGauge_thickness() {
    return this._SolidGauge_thickness;
  }
  set SolidGauge_thickness(value) {
    this._SolidGauge_thickness = value;
  }
  get ATTR_SolidGauge_maxSpeed__DisplayName() {
    return "Max speed (%) ";
  }
  get ATTR_SolidGauge_maxSpeed__CategoryAttribute() {
    return "Dial";
  }
  get ATTR_SolidGauge_maxSpeed__DescriptionAttribute() {
    return 'Maximum speed of the dial in percentage relative to Max-Min. This is meant to limit "teleporting" effects.';
  }
  get SolidGauge_maxSpeed() {
    return this._SolidGauge_maxSpeed;
  }
  set SolidGauge_maxSpeed(value) {
    this._SolidGauge_maxSpeed = value;
  }
  IsDataSourceAssigned() {
    return !(this._DataSource_source instanceof NullYSensor);
  }
  get ATTR_SolidGauge_annotationPanels0__DisplayName() {
    return "Annotation 1";
  }
  get ATTR_SolidGauge_annotationPanels0__CategoryAttribute() {
    return "Annotations";
  }
  get ATTR_SolidGauge_annotationPanels0__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_SolidGauge_annotationPanels0__DescriptionAttribute() {
    return "Customizable text panels";
  }
  get SolidGauge_annotationPanels0() {
    return this._annotationPanels0;
  }
  set SolidGauge_annotationPanels0(value) {
    this._annotationPanels0 = value;
  }
  get ATTR_SolidGauge_annotationPanels1__DisplayName() {
    return "Annotation 2";
  }
  get ATTR_SolidGauge_annotationPanels1__CategoryAttribute() {
    return "Annotations";
  }
  get ATTR_SolidGauge_annotationPanels1__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_SolidGauge_annotationPanels1__DescriptionAttribute() {
    return "Customizable text panels";
  }
  get SolidGauge_annotationPanels1() {
    return this._annotationPanels1;
  }
  set SolidGauge_annotationPanels1(value) {
    this._annotationPanels1 = value;
  }
};
var AngularGaugeFormProperties = class extends GenericProperties {
  constructor(initData, owner) {
    super(owner);
    this._DataSource_source = sensorsManager.getNullSensor();
    this._DataSource_AlarmSection0 = new AlarmSection(0);
    this._DataSource_AlarmSection1 = new AlarmSection(1);
    this._AngularGauge_min = 0;
    this._AngularGauge_max = 100;
    this._AngularGauge_unitFactor = 1;
    this._AngularGauge_graduation = 10;
    this._AngularGauge_graduationSize = 10;
    this._AngularGauge_graduationOuterRadiusSize = 98;
    this._AngularGauge_graduationThickness = 2;
    this._AngularGauge_graduationColor = YColor.Black;
    this._AngularGauge_graduationFont = new FontDescription("Arial", 20, YColor.Black, false, true);
    this._AngularGauge_subgraduationCount = 5;
    this._AngularGauge_subgraduationSize = 5;
    this._AngularGauge_subgraduationThickness = 1;
    this._AngularGauge_subgraduationColor = YColor.Black;
    this._AngularGauge_needleColor = YColor.Red;
    this._AngularGauge_needleContourColor = YColor.DarkRed;
    this._AngularGauge_needleContourThickness = 1;
    this._AngularGauge_needleLength1 = 90;
    this._AngularGauge_needleLength2 = 15;
    this._AngularGauge_needleWidth = 5;
    this._AngularGauge_needleMaxSpeed = 0.5;
    this._AngularGauge_unitFont = new FontDescription("Arial", 24, YColor.DarkGray, false, true);
    this._AngularGauge_statusFont = new FontDescription("Arial", 24, YColor.DarkGray, false, true);
    this._AngularGauge_borderColor = YColor.Black;
    this._AngularGauge_borderThickness = 5;
    this._AngularGauge_backgroundColor1 = YColor.FromArgb(255, 240, 240, 240);
    this._AngularGauge_backgroundColor2 = YColor.FromArgb(255, 200, 200, 200);
    this._AngularGauge_zones0 = new AngularZoneDescription(0, 50, YColor.LightGreen);
    this._AngularGauge_zones1 = new AngularZoneDescription(50, 80, YColor.Yellow);
    this._AngularGauge_zones2 = new AngularZoneDescription(80, 100, YColor.Red);
    this._annotationPanels0 = new AnnotationPanelDescription(GenericPanel.HorizontalAlignPos.CENTER, GenericPanel.VerticalAlignPos.CENTER, 0, false, "$NAME$", YColor.FromArgb(0, 127, 127, 127), YColor.FromArgb(0, 127, 127, 127), 10, YColor.FromArgb(255, 0, 0, 0));
    this._annotationPanels1 = new AnnotationPanelDescription(GenericPanel.HorizontalAlignPos.CENTER, GenericPanel.VerticalAlignPos.BOTTOM, 0, false, "$NAME$", YColor.FromArgb(0, 127, 127, 127), YColor.FromArgb(0, 127, 127, 127), 10, YColor.FromArgb(255, 0, 0, 0));
    this.initFromXmlData(initData);
    this.PropagateDataSourceChange();
  }
  PropagateDataSourceChange() {
    this.ownerForm.SourceChanged(this._DataSource_source, 0);
    let props = GenericProperties.getAllProperties(this).byName;
    let name;
    for (name in props) {
      if (name.startsWith("DataSource_AlarmSection")) {
        this[name].setDataSource(this._DataSource_source);
      }
    }
  }
  IsDataSourceAssigned() {
    return !(this._DataSource_source instanceof NullYSensor);
  }
  get ATTR_DataSource_source__DisplayName() {
    return "Sensor";
  }
  get ATTR_DataSource_source__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_source__ParamCategorySummaryAttribute() {
    return "sensorDescription";
  }
  get ATTR_DataSource_source__PreExpandedCategoryAttribute() {
    return true;
  }
  get ATTR_DataSource_source__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_DataSource_source__DescriptionAttribute() {
    return "Yoctopuce sensor feeding the gauge. " + GenericHints.CheckSensor;
  }
  get DataSource_source() {
    return this._DataSource_source;
  }
  set DataSource_source(value) {
    let prev = this._DataSource_source;
    this._DataSource_source = value;
    this.PropagateDataSourceChange();
    if (this._DataSource_source != prev)
      constants.edited = true;
  }
  get sensorDescription() {
    return this._DataSource_source instanceof NullYSensor ? "none" : this._DataSource_source.get_friendlyName();
  }
  get isSensorReadOnly() {
    return this._DataSource_source.isReadOnly;
  }
  get ATTR_DataSource_freq__DisplayName() {
    return "Sensor freq";
  }
  get ATTR_DataSource_freq__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_freq__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_DataSource_freq__IsReadonlyCallAttribute() {
    return "isSensorReadOnly";
  }
  get ATTR_DataSource_freq__DescriptionAttribute() {
    return "Sensor data acquisition frequency." + GenericHints.DevConfAffected;
  }
  get ATTR_DataSource_freq__AllowedValues() {
    return sensorFreqTypeDescription.AllowedValues;
  }
  get DataSource_freq() {
    return this._DataSource_source.get_frequency();
  }
  set DataSource_freq(value) {
    this._DataSource_source.set_frequency(value);
  }
  get ATTR_DataSource_AlarmSection0__DisplayName() {
    return "Sensor value alarm 1";
  }
  get ATTR_DataSource_AlarmSection0__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection0__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection0__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_AlarmSection0__DescriptionAttribute() {
    return "Alarm 1 for this data source, expand for more.";
  }
  get DataSource_AlarmSection0() {
    return this._DataSource_AlarmSection0;
  }
  set DataSource_AlarmSection0(value) {
    this._DataSource_AlarmSection0 = value;
  }
  get ATTR_DataSource_AlarmSection1__DisplayName() {
    return "Sensor value alarm 2";
  }
  get ATTR_DataSource_AlarmSection1__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection1__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection1__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_AlarmSection1__DescriptionAttribute() {
    return "Alarm 2 for this data source, expand for more.";
  }
  get DataSource_AlarmSection1() {
    return this._DataSource_AlarmSection1;
  }
  set DataSource_AlarmSection1(value) {
    this._DataSource_AlarmSection1 = value;
  }
  get ATTR_AngularGauge_min__DisplayName() {
    return "Minimum value";
  }
  get ATTR_AngularGauge_min__CategoryAttribute() {
    return "Gauge gradations";
  }
  get ATTR_AngularGauge_min__DescriptionAttribute() {
    return "Minimum value displayable by the gauge.";
  }
  get AngularGauge_min() {
    return this._AngularGauge_min;
  }
  set AngularGauge_min(value) {
    this._AngularGauge_min = value;
  }
  get ATTR_AngularGauge_max__DisplayName() {
    return "Maximum value";
  }
  get ATTR_AngularGauge_max__CategoryAttribute() {
    return "Gauge gradations";
  }
  get ATTR_AngularGauge_max__DescriptionAttribute() {
    return "Maximum value displayable by the gauge.";
  }
  get AngularGauge_max() {
    return this._AngularGauge_max;
  }
  set AngularGauge_max(value) {
    this._AngularGauge_max = value;
  }
  get ATTR_AngularGauge_unitFactor__DisplayName() {
    return "Unit factor";
  }
  get ATTR_AngularGauge_unitFactor__CategoryAttribute() {
    return "Gauge gradations";
  }
  get ATTR_AngularGauge_unitFactor__DescriptionAttribute() {
    return "Data  will be divided by this value before being displayed, this allows simpler gradation marks.";
  }
  get AngularGauge_unitFactor() {
    return this._AngularGauge_unitFactor;
  }
  set AngularGauge_unitFactor(value) {
    this._AngularGauge_unitFactor = value;
  }
  get ATTR_AngularGauge_graduation__DisplayName() {
    return "Main gradation steps";
  }
  get ATTR_AngularGauge_graduation__CategoryAttribute() {
    return "Gauge gradations";
  }
  get ATTR_AngularGauge_graduation__DescriptionAttribute() {
    return "Difference between two consecutive main gradation marks";
  }
  get AngularGauge_graduation() {
    return this._AngularGauge_graduation;
  }
  set AngularGauge_graduation(value) {
    this._AngularGauge_graduation = value;
  }
  get ATTR_AngularGauge_graduationSize__DisplayName() {
    return "Main gradation size (%)";
  }
  get ATTR_AngularGauge_graduationSize__CategoryAttribute() {
    return "Gauge gradations";
  }
  get ATTR_AngularGauge_graduationSize__DescriptionAttribute() {
    return "Main gradation marks size in percent, relative to dial radius";
  }
  get AngularGauge_graduationSize() {
    return this._AngularGauge_graduationSize;
  }
  set AngularGauge_graduationSize(value) {
    this._AngularGauge_graduationSize = value;
  }
  get ATTR_AngularGauge_graduationOuterRadiusSize__DisplayName() {
    return "Main gradation radius (%)";
  }
  get ATTR_AngularGauge_graduationOuterRadiusSize__CategoryAttribute() {
    return "Gauge gradations";
  }
  get ATTR_AngularGauge_graduationOuterRadiusSize__DescriptionAttribute() {
    return "Main gradation marks outer radius in percent, relative to dial radius";
  }
  get AngularGauge_graduationOuterRadiusSize() {
    return this._AngularGauge_graduationOuterRadiusSize;
  }
  set AngularGauge_graduationOuterRadiusSize(value) {
    this._AngularGauge_graduationOuterRadiusSize = value;
  }
  get ATTR_AngularGauge_graduationThickness__DisplayName() {
    return "Main gradation thickness";
  }
  get ATTR_AngularGauge_graduationThickness__CategoryAttribute() {
    return "Gauge gradations";
  }
  get ATTR_AngularGauge_graduationThickness__DescriptionAttribute() {
    return "Main gradation marks thickness";
  }
  get AngularGauge_graduationThickness() {
    return this._AngularGauge_graduationThickness;
  }
  set AngularGauge_graduationThickness(value) {
    this._AngularGauge_graduationThickness = value;
  }
  get ATTR_AngularGauge_graduationColor__DisplayName() {
    return "Main gradation color";
  }
  get ATTR_AngularGauge_graduationColor__CategoryAttribute() {
    return "Gauge gradations";
  }
  get ATTR_AngularGauge_graduationColor__DescriptionAttribute() {
    return "Main gradation marks color.";
  }
  get AngularGauge_graduationColor() {
    return this._AngularGauge_graduationColor;
  }
  set AngularGauge_graduationColor(value) {
    this._AngularGauge_graduationColor = value;
  }
  get ATTR_AngularGauge_graduationFont__DisplayName() {
    return "Main gradation font";
  }
  get ATTR_AngularGauge_graduationFont__CategoryAttribute() {
    return "Gauge gradations";
  }
  get ATTR_AngularGauge_graduationFont__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_AngularGauge_graduationFont__DescriptionAttribute() {
    return "Font used for gradation labels";
  }
  get AngularGauge_graduationFont() {
    return this._AngularGauge_graduationFont;
  }
  set AngularGauge_graduationFont(value) {
    this._AngularGauge_graduationFont = value;
  }
  get ATTR_AngularGauge_subgraduationCount__DisplayName() {
    return "Sub-gradation count";
  }
  get ATTR_AngularGauge_subgraduationCount__CategoryAttribute() {
    return "Gauge gradations";
  }
  get ATTR_AngularGauge_subgraduationCount__DescriptionAttribute() {
    return "How many sub-gradation (+1) marks between two consecutive main graduation marks";
  }
  get AngularGauge_subgraduationCount() {
    return this._AngularGauge_subgraduationCount;
  }
  set AngularGauge_subgraduationCount(value) {
    this._AngularGauge_subgraduationCount = value;
  }
  get ATTR_AngularGauge_subgraduationSize__DisplayName() {
    return "Sub-gradation size (%)";
  }
  get ATTR_AngularGauge_subgraduationSize__CategoryAttribute() {
    return "Gauge gradations";
  }
  get ATTR_AngularGauge_subgraduationSize__DescriptionAttribute() {
    return "Sub-gradation marks size in percent, relative to dial radius";
  }
  get AngularGauge_subgraduationSize() {
    return this._AngularGauge_subgraduationSize;
  }
  set AngularGauge_subgraduationSize(value) {
    this._AngularGauge_subgraduationSize = value;
  }
  get ATTR_AngularGauge_subgraduationThickness__DisplayName() {
    return "Sub-gradation thickness";
  }
  get ATTR_AngularGauge_subgraduationThickness__CategoryAttribute() {
    return "Gauge gradations";
  }
  get ATTR_AngularGauge_subgraduationThickness__DescriptionAttribute() {
    return "Sub-gradation marks thickness";
  }
  get AngularGauge_subgraduationThickness() {
    return this._AngularGauge_subgraduationThickness;
  }
  set AngularGauge_subgraduationThickness(value) {
    this._AngularGauge_subgraduationThickness = value;
  }
  get ATTR_AngularGauge_subgraduationColor__DisplayName() {
    return "Sub-gradation color";
  }
  get ATTR_AngularGauge_subgraduationColor__CategoryAttribute() {
    return "Gauge gradations";
  }
  get ATTR_AngularGauge_subgraduationColor__DescriptionAttribute() {
    return "Sub-gradation marks color.";
  }
  get AngularGauge_subgraduationColor() {
    return this._AngularGauge_subgraduationColor;
  }
  set AngularGauge_subgraduationColor(value) {
    this._AngularGauge_subgraduationColor = value;
  }
  get ATTR_AngularGauge_needleColor__DisplayName() {
    return "Needle color";
  }
  get ATTR_AngularGauge_needleColor__CategoryAttribute() {
    return "Needle";
  }
  get ATTR_AngularGauge_needleColor__DescriptionAttribute() {
    return "Needle filling color.";
  }
  get AngularGauge_needleColor() {
    return this._AngularGauge_needleColor;
  }
  set AngularGauge_needleColor(value) {
    this._AngularGauge_needleColor = value;
  }
  get ATTR_AngularGauge_needleContourColor__DisplayName() {
    return "Needle contour color";
  }
  get ATTR_AngularGauge_needleContourColor__CategoryAttribute() {
    return "Needle";
  }
  get ATTR_AngularGauge_needleContourColor__DescriptionAttribute() {
    return "Needle contour color.";
  }
  get AngularGauge_needleContourColor() {
    return this._AngularGauge_needleContourColor;
  }
  set AngularGauge_needleContourColor(value) {
    this._AngularGauge_needleContourColor = value;
  }
  get ATTR_AngularGauge_needleContourThickness__DisplayName() {
    return "Needle contour thickness";
  }
  get ATTR_AngularGauge_needleContourThickness__CategoryAttribute() {
    return "Needle";
  }
  get ATTR_AngularGauge_needleContourThickness__DescriptionAttribute() {
    return "Thickness of the needle contour";
  }
  get AngularGauge_needleContourThickness() {
    return this._AngularGauge_needleContourThickness;
  }
  set AngularGauge_needleContourThickness(value) {
    this._AngularGauge_needleContourThickness = value;
  }
  get ATTR_AngularGauge_needleLength1__DisplayName() {
    return "Needle main size (%)";
  }
  get ATTR_AngularGauge_needleLength1__CategoryAttribute() {
    return "Needle";
  }
  get ATTR_AngularGauge_needleLength1__DescriptionAttribute() {
    return "Length of the needle part pointing to gradations, in % relative to radius";
  }
  get AngularGauge_needleLength1() {
    return this._AngularGauge_needleLength1;
  }
  set AngularGauge_needleLength1(value) {
    this._AngularGauge_needleLength1 = value;
  }
  get ATTR_AngularGauge_needleLength2__DisplayName() {
    return "Needle foot size (%)";
  }
  get ATTR_AngularGauge_needleLength2__CategoryAttribute() {
    return "Needle";
  }
  get ATTR_AngularGauge_needleLength2__DescriptionAttribute() {
    return "Length of the needle part not pointing to gradations, in % relative to radius";
  }
  get AngularGauge_needleLength2() {
    return this._AngularGauge_needleLength2;
  }
  set AngularGauge_needleLength2(value) {
    this._AngularGauge_needleLength2 = value;
  }
  get ATTR_AngularGauge_needleWidth__DisplayName() {
    return "Needle width (%)";
  }
  get ATTR_AngularGauge_needleWidth__CategoryAttribute() {
    return "Needle";
  }
  get ATTR_AngularGauge_needleWidth__DescriptionAttribute() {
    return "Width of the needle, in % relative to radius";
  }
  get AngularGauge_needleWidth() {
    return this._AngularGauge_needleWidth;
  }
  set AngularGauge_needleWidth(value) {
    this._AngularGauge_needleWidth = value;
  }
  get ATTR_AngularGauge_needleMaxSpeed__DisplayName() {
    return "Needle max speed (%)";
  }
  get ATTR_AngularGauge_needleMaxSpeed__CategoryAttribute() {
    return "Needle";
  }
  get ATTR_AngularGauge_needleMaxSpeed__DescriptionAttribute() {
    return 'Needle Maximum speed, in % relative to (max-min). This is meant to limit "teleporting" effects.';
  }
  get AngularGauge_needleMaxSpeed() {
    return this._AngularGauge_needleMaxSpeed;
  }
  set AngularGauge_needleMaxSpeed(value) {
    this._AngularGauge_needleMaxSpeed = value;
  }
  get ATTR_AngularGauge_unitFont__DisplayName() {
    return "Unit Line Font";
  }
  get ATTR_AngularGauge_unitFont__CategoryAttribute() {
    return "Text lines";
  }
  get ATTR_AngularGauge_unitFont__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_AngularGauge_unitFont__DescriptionAttribute() {
    return "Font used in the text line describing unit";
  }
  get AngularGauge_unitFont() {
    return this._AngularGauge_unitFont;
  }
  set AngularGauge_unitFont(value) {
    this._AngularGauge_unitFont = value;
  }
  get ATTR_AngularGauge_statusFont__DisplayName() {
    return "Status Line Font";
  }
  get ATTR_AngularGauge_statusFont__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_AngularGauge_statusFont__CategoryAttribute() {
    return "Text lines";
  }
  get ATTR_AngularGauge_statusFont__DescriptionAttribute() {
    return "Font used in the text line gauge status";
  }
  get AngularGauge_statusFont() {
    return this._AngularGauge_statusFont;
  }
  set AngularGauge_statusFont(value) {
    this._AngularGauge_statusFont = value;
  }
  get ATTR_AngularGauge_borderColor__DisplayName() {
    return "Border color";
  }
  get ATTR_AngularGauge_borderColor__CategoryAttribute() {
    return "Dial";
  }
  get ATTR_AngularGauge_borderColor__DescriptionAttribute() {
    return "Dial border color.";
  }
  get AngularGauge_borderColor() {
    return this._AngularGauge_borderColor;
  }
  set AngularGauge_borderColor(value) {
    this._AngularGauge_borderColor = value;
  }
  get ATTR_AngularGauge_borderThickness__DisplayName() {
    return "Border thickness ";
  }
  get ATTR_AngularGauge_borderThickness__CategoryAttribute() {
    return "Dial";
  }
  get ATTR_AngularGauge_borderThickness__DescriptionAttribute() {
    return "Thickness of the dial border";
  }
  get AngularGauge_borderThickness() {
    return this._AngularGauge_borderThickness;
  }
  set AngularGauge_borderThickness(value) {
    this._AngularGauge_borderThickness = value;
  }
  get ATTR_AngularGauge_backgroundColor1__DisplayName() {
    return "Background color 1";
  }
  get ATTR_AngularGauge_backgroundColor1__CategoryAttribute() {
    return "Dial";
  }
  get ATTR_AngularGauge_backgroundColor1__DescriptionAttribute() {
    return "Dial background gradient color 1.";
  }
  get AngularGauge_backgroundColor1() {
    return this._AngularGauge_backgroundColor1;
  }
  set AngularGauge_backgroundColor1(value) {
    this._AngularGauge_backgroundColor1 = value;
  }
  get ATTR_AngularGauge_backgroundColor2__DisplayName() {
    return "Background color 2";
  }
  get ATTR_AngularGauge_backgroundColor2__CategoryAttribute() {
    return "Dial";
  }
  get ATTR_AngularGauge_backgroundColor2__DescriptionAttribute() {
    return "Dial background gradient color 2.";
  }
  get AngularGauge_backgroundColor2() {
    return this._AngularGauge_backgroundColor2;
  }
  set AngularGauge_backgroundColor2(value) {
    this._AngularGauge_backgroundColor2 = value;
  }
  get ATTR_AngularGauge_zones0__DisplayName() {
    return "Zone 1";
  }
  get ATTR_AngularGauge_zones0__CategoryAttribute() {
    return "Zones";
  }
  get ATTR_AngularGauge_zones0__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_AngularGauge_zones0__DescriptionAttribute() {
    return "Zone 1 parameters";
  }
  get AngularGauge_zones0() {
    return this._AngularGauge_zones0;
  }
  set AngularGauge_zones0(value) {
    this._AngularGauge_zones0 = value;
  }
  get ATTR_AngularGauge_zones1__DisplayName() {
    return "Zone 2";
  }
  get ATTR_AngularGauge_zones1__CategoryAttribute() {
    return "Zones";
  }
  get ATTR_AngularGauge_zones1__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_AngularGauge_zones1__DescriptionAttribute() {
    return "Zone 2 parameters";
  }
  get AngularGauge_zones1() {
    return this._AngularGauge_zones1;
  }
  set AngularGauge_zones1(value) {
    this._AngularGauge_zones1 = value;
  }
  get ATTR_AngularGauge_zones2__DisplayName() {
    return "Zone 2";
  }
  get ATTR_AngularGauge_zones2__CategoryAttribute() {
    return "Zones";
  }
  get ATTR_AngularGauge_zones2__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_AngularGauge_zones2__DescriptionAttribute() {
    return "Zone 2 parameters";
  }
  get AngularGauge_zones2() {
    return this._AngularGauge_zones2;
  }
  set AngularGauge_zones2(value) {
    this._AngularGauge_zones2 = value;
  }
  get ATTR_AngularGauge_annotationPanels0__DisplayName() {
    return "Annotation 1";
  }
  get ATTR_AngularGauge_annotationPanels0__CategoryAttribute() {
    return "Annotations";
  }
  get ATTR_AngularGauge_annotationPanels0__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_AngularGauge_annotationPanels0__DescriptionAttribute() {
    return "Customizable text panels";
  }
  get AngularGauge_annotationPanels0() {
    return this._annotationPanels0;
  }
  set AngularGauge_annotationPanels0(value) {
    this._annotationPanels0 = value;
  }
  get ATTR_AngularGauge_annotationPanels1__DisplayName() {
    return "Annotation 2";
  }
  get ATTR_AngularGauge_annotationPanels1__CategoryAttribute() {
    return "Annotations";
  }
  get ATTR_AngularGauge_annotationPanels1__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_AngularGauge_annotationPanels1__DescriptionAttribute() {
    return "Customizable text panels";
  }
  get AngularGauge_annotationPanels1() {
    return this._annotationPanels1;
  }
  set AngularGauge_annotationPanels1(value) {
    this._annotationPanels1 = value;
  }
};
var ZoneDescription = class {
  constructor(min, max, color) {
    this._visible = false;
    this._min = min;
    this._max = max;
    this._color = color;
  }
  get summary() {
    return this._visible ? this._min.toString() + ".." + this._max.toString() : "Disabled";
  }
  get ATTR_visible__DisplayName() {
    return "Visible";
  }
  get ATTR_visible__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_visible__DescriptionAttribute() {
    return "Zone visibility.";
  }
  get visible() {
    return this._visible;
  }
  set visible(value) {
    this._visible = value;
  }
  get ATTR_min__DisplayName() {
    return "Minimum value";
  }
  get ATTR_min__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_min__DescriptionAttribute() {
    return "Zone minimum value";
  }
  get min() {
    return this._min;
  }
  set min(value) {
    this._min = value;
  }
  get ATTR_max__DisplayName() {
    return "Maximum value";
  }
  get ATTR_max__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_max__DescriptionAttribute() {
    return "Zone maximum value";
  }
  get max() {
    return this._max;
  }
  set max(value) {
    this._max = value;
  }
  get ATTR_color__DisplayName() {
    return "Color";
  }
  get ATTR_color__DescriptionAttribute() {
    return "Zone color";
  }
  get color() {
    return this._color;
  }
  set color(value) {
    this._color = value;
  }
};
var AngularZoneDescription = class {
  constructor(min, max, color) {
    this._width = 5;
    this._outerRadius = 98;
    this._visible = false;
    this._min = min;
    this._max = max;
    this._color = color;
  }
  get summary() {
    return this._visible ? this._min.toString() + ".." + this._max.toString() : "Disabled";
  }
  get ATTR_visible__DisplayName() {
    return "Visible";
  }
  get ATTR_visible__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_visible__DescriptionAttribute() {
    return "Zone visibility.";
  }
  get visible() {
    return this._visible;
  }
  set visible(value) {
    this._visible = value;
  }
  get ATTR_min__DisplayName() {
    return "Minimum value";
  }
  get ATTR_min__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_min__DescriptionAttribute() {
    return "Zone minimum value";
  }
  get min() {
    return this._min;
  }
  set min(value) {
    this._min = value;
  }
  get ATTR_max__DisplayName() {
    return "Maximum value";
  }
  get ATTR_max__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_max__DescriptionAttribute() {
    return "Zone maximum value";
  }
  get max() {
    return this._max;
  }
  set max(value) {
    this._max = value;
  }
  get ATTR_color__DisplayName() {
    return "Color";
  }
  get ATTR_color__DescriptionAttribute() {
    return "Zone color";
  }
  get color() {
    return this._color;
  }
  set color(value) {
    this._color = value;
  }
  get ATTR_outerRadius__DisplayName() {
    return "Outer radius (%)";
  }
  get ATTR_outerRadius__DescriptionAttribute() {
    return "Zone outer radius, in percentage relative to dial radius ";
  }
  get outerRadius() {
    return this._outerRadius;
  }
  set outerRadius(value) {
    this._outerRadius = value;
  }
  get ATTR_width__DisplayName() {
    return "Width (%)";
  }
  get ATTR_width__DescriptionAttribute() {
    return "Zone  width, in percentage relative to dial radius ";
  }
  get width() {
    return this._width;
  }
  set width(value) {
    this._width = value;
  }
};
var FontDescription = class {
  constructor(name, size, color, italic, bold) {
    this._name = name;
    this._size = size;
    this._color = color;
    this._italic = italic;
    this._bold = bold;
  }
  ToString() {
    return this._name + " " + this._size.toString();
  }
  get summary() {
    return this._name + " " + this._size.toString();
  }
  get ATTR_name__DisplayName() {
    return "Font name";
  }
  get ATTR_name__AllowedValues() {
    return fontNameTypeDescription.AllowedValues;
  }
  get ATTR_name__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_name__DescriptionAttribute() {
    return "Name of the font";
  }
  get name() {
    return this._name;
  }
  set name(value) {
    this._name = value;
  }
  get ATTR_size__DisplayName() {
    return "Font size";
  }
  get ATTR_size__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_size__DescriptionAttribute() {
    return "Size of the font";
  }
  get size() {
    return this._size;
  }
  set size(value) {
    this._size = Math.round(100 * value) / 100;
  }
  get ATTR_color__DisplayName() {
    return "Font color";
  }
  get ATTR_color__DescriptionAttribute() {
    return "Color of the font.";
  }
  get color() {
    return this._color;
  }
  set color(value) {
    this._color = value;
  }
  get ATTR_italic__DisplayName() {
    return "Italic";
  }
  get ATTR_italic__DescriptionAttribute() {
    return "Is the font style italic?.";
  }
  get italic() {
    return this._italic;
  }
  set italic(value) {
    this._italic = value;
  }
  get ATTR_bold__DisplayName() {
    return "Bold";
  }
  get ATTR_bold__DescriptionAttribute() {
    return "Is the font style bold?.";
  }
  get bold() {
    return this._bold;
  }
  set bold(value) {
    this._bold = value;
  }
};
var digitalDisplayFormProperties = class extends GenericProperties {
  constructor(initData, owner) {
    super(owner);
    this._DataSource_source = sensorsManager.getNullSensor();
    this._DataSource_precision = "0.1";
    this._DataSource_AlarmSection0 = new AlarmSection(0);
    this._DataSource_AlarmSection1 = new AlarmSection(1);
    this._font = new FontDescription("Arial", 48, YColor.LightGreen, false, true);
    this._display_backgroundColor1 = YColor.Black;
    this._display_backgroundColor2 = YColor.Black;
    this._hrzAlignment = YDigitalDisplay.HrzAlignment.RIGHT;
    this._hrzAlignmentOfset = 5;
    this._outOfRangeMin = new doubleNan(Number.NaN);
    this._outOfRangeMax = new doubleNan(Number.NaN);
    this._outOfRangeColor = YColor.Red;
    this._annotationPanels0 = new AnnotationPanelDescription(GenericPanel.HorizontalAlignPos.CENTER, GenericPanel.VerticalAlignPos.CENTER, 0, false, "$NAME$", YColor.FromArgb(0, 127, 127, 127), YColor.FromArgb(0, 127, 127, 127), 10, YColor.FromArgb(255, 0, 0, 0));
    this._annotationPanels1 = new AnnotationPanelDescription(GenericPanel.HorizontalAlignPos.CENTER, GenericPanel.VerticalAlignPos.BOTTOM, 0, false, "$NAME$", YColor.FromArgb(0, 127, 127, 127), YColor.FromArgb(0, 127, 127, 127), 10, YColor.FromArgb(255, 0, 0, 0));
    this.initFromXmlData(initData);
    this.PropagateDataSourceChange();
  }
  PropagateDataSourceChange() {
    this.ownerForm.SourceChanged(this._DataSource_source, 0);
    let props = GenericProperties.getAllProperties(this).byName;
    let name;
    for (name in props) {
      if (name.startsWith("DataSource_AlarmSection")) {
        this[name].setDataSource(this._DataSource_source);
      }
    }
  }
  IsDataSourceAssigned() {
    return !(this._DataSource_source instanceof NullYSensor);
  }
  get ATTR_DataSource_source__DisplayName() {
    return "Sensor";
  }
  get ATTR_DataSource_source__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_source__ParamCategorySummaryAttribute() {
    return "sensorDescription";
  }
  get ATTR_DataSource_source__PreExpandedCategoryAttribute() {
    return true;
  }
  get ATTR_DataSource_source__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_DataSource_source__DescriptionAttribute() {
    return "Yoctopuce sensor feeding the display. " + GenericHints.CheckSensor;
  }
  get DataSource_source() {
    return this._DataSource_source;
  }
  set DataSource_source(value) {
    let prev = this._DataSource_source;
    this._DataSource_source = value;
    this.PropagateDataSourceChange();
    if (this._DataSource_source != prev)
      constants.edited = true;
  }
  get isSensorReadOnly() {
    return this._DataSource_source.isReadOnly;
  }
  get sensorDescription() {
    return this._DataSource_source instanceof NullYSensor ? "none" : this._DataSource_source.get_friendlyName();
  }
  get ATTR_DataSource_freq__DisplayName() {
    return "Sensor freq";
  }
  get ATTR_DataSource_freq__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_freq__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_DataSource_freq__IsReadonlyCallAttribute() {
    return "isSensorReadOnly";
  }
  get ATTR_DataSource_freq__DescriptionAttribute() {
    return "Sensor data acquisition frequency." + GenericHints.DevConfAffected;
  }
  get ATTR_DataSource_freq__AllowedValues() {
    return sensorFreqTypeDescription.AllowedValues;
  }
  get DataSource_freq() {
    return this._DataSource_source.get_frequency();
  }
  set DataSource_freq(value) {
    this._DataSource_source.set_frequency(value);
  }
  get ATTR_DataSource_precision__DisplayName() {
    return "Precision";
  }
  get ATTR_DataSource_precision__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_precision__DescriptionAttribute() {
    return "How many digits shown after the decimal point.";
  }
  get ATTR_DataSource_precision__AllowedValues() {
    return sensorPrecisionTypeDescription.AllowedValues;
  }
  get DataSource_precision() {
    return this._DataSource_precision;
  }
  set DataSource_precision(value) {
    this._DataSource_precision = value;
  }
  get ATTR_DataSource_AlarmSection0__DisplayName() {
    return "Sensor value alarm 1";
  }
  get ATTR_DataSource_AlarmSection0__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection0__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection0__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_AlarmSection0__DescriptionAttribute() {
    return "Alarm 1 for this data source, expand for more.";
  }
  get DataSource_AlarmSection0() {
    return this._DataSource_AlarmSection0;
  }
  set DataSource_AlarmSection0(value) {
    this._DataSource_AlarmSection0 = value;
  }
  get ATTR_DataSource_AlarmSection1__DisplayName() {
    return "Sensor value alarm 2";
  }
  get ATTR_DataSource_AlarmSection1__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection1__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection1__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_AlarmSection1__DescriptionAttribute() {
    return "Alarm 2 for this data source, expand for more.";
  }
  get DataSource_AlarmSection1() {
    return this._DataSource_AlarmSection1;
  }
  set DataSource_AlarmSection1(value) {
    this._DataSource_AlarmSection1 = value;
  }
  get ATTR_display_font__DisplayName() {
    return "Font";
  }
  get ATTR_display_font__CategoryAttribute() {
    return "Display";
  }
  get ATTR_display_font__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_display_font__DescriptionAttribute() {
    return "Display font";
  }
  get display_font() {
    return this._font;
  }
  set display_font(value) {
    this._font = value;
  }
  get ATTR_display_backgroundColor1__DisplayName() {
    return "Background color 1";
  }
  get ATTR_display_backgroundColor1__CategoryAttribute() {
    return "Display";
  }
  get ATTR_display_backgroundColor1__DescriptionAttribute() {
    return "Display background gradient color 1.";
  }
  get display_backgroundColor1() {
    return this._display_backgroundColor1;
  }
  set display_backgroundColor1(value) {
    this._display_backgroundColor1 = value;
  }
  get ATTR_display_backgroundColor2__DisplayName() {
    return "Background color 2";
  }
  get ATTR_display_backgroundColor2__CategoryAttribute() {
    return "Display";
  }
  get ATTR_display_backgroundColor2__DescriptionAttribute() {
    return "Display background gradient color 2.";
  }
  get display_backgroundColor2() {
    return this._display_backgroundColor2;
  }
  set display_backgroundColor2(value) {
    this._display_backgroundColor2 = value;
  }
  get ATTR_display_hrzAlignment__DisplayName() {
    return "Hrz alignment method";
  }
  get ATTR_display_hrzAlignment__CategoryAttribute() {
    return "Display";
  }
  get ATTR_display_hrzAlignment__DescriptionAttribute() {
    return "Horizontal alignment method";
  }
  get display_hrzAlignment() {
    return this._hrzAlignment;
  }
  set display_hrzAlignment(value) {
    this._hrzAlignment = value;
  }
  get ATTR_display_hrzAlignmentOfset__DisplayName() {
    return "Hrz alignment offset";
  }
  get ATTR_display_hrzAlignmentOfset__CategoryAttribute() {
    return "Display";
  }
  get ATTR_display_hrzAlignmentOfset__DescriptionAttribute() {
    return "Horizontal alignment offset in percentage. No effect when chosen horizontal alignment is CENTER";
  }
  get display_hrzAlignmentOfset() {
    return this._hrzAlignmentOfset;
  }
  set display_hrzAlignmentOfset(value) {
    this._hrzAlignmentOfset = value;
  }
  get ATTR_display_outOfRangeMin__DisplayName() {
    return "Minimum value";
  }
  get ATTR_display_outOfRangeMin__CategoryAttribute() {
    return "Range Control";
  }
  get ATTR_display_outOfRangeMin__DescriptionAttribute() {
    return `Regular range minimum value. if value goes  outside regular  range, color will turn to "Out of range Color".Leave blank if you don't want to define such a range. `;
  }
  get display_outOfRangeMin() {
    return this._outOfRangeMin;
  }
  set display_outOfRangeMin(value) {
    this._outOfRangeMin = value;
  }
  get ATTR_display_outOfRangeMax__DisplayName() {
    return "Maximum value";
  }
  get ATTR_display_outOfRangeMax__CategoryAttribute() {
    return "Range Control";
  }
  get ATTR_display_outOfRangeMax__DescriptionAttribute() {
    return `Regular range minimum value. if value goes  outside regular  range, color will turn to "Out of range Color".Leave blank if you don't want to define such a range. `;
  }
  get display_outOfRangeMax() {
    return this._outOfRangeMax;
  }
  set display_outOfRangeMax(value) {
    this._outOfRangeMax = value;
  }
  get ATTR_display_outOfRangeColor__DisplayName() {
    return "Out of range Color";
  }
  get ATTR_display_outOfRangeColor__CategoryAttribute() {
    return "Range Control";
  }
  get ATTR_display_outOfRangeColor__DescriptionAttribute() {
    return "Digits color when value is out of range.";
  }
  get display_outOfRangeColor() {
    return this._outOfRangeColor;
  }
  set display_outOfRangeColor(value) {
    this._outOfRangeColor = value;
  }
  get ATTR_display_annotationPanels0__DisplayName() {
    return "Annotation 1";
  }
  get ATTR_display_annotationPanels0__CategoryAttribute() {
    return "Annotations";
  }
  get ATTR_display_annotationPanels0__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_display_annotationPanels0__DescriptionAttribute() {
    return "Customizable text panels";
  }
  get display_annotationPanels0() {
    return this._annotationPanels0;
  }
  set display_annotationPanels0(value) {
    this._annotationPanels0 = value;
  }
  get ATTR_display_annotationPanels1__DisplayName() {
    return "Annotation 2";
  }
  get ATTR_display_annotationPanels1__CategoryAttribute() {
    return "Annotations";
  }
  get ATTR_display_annotationPanels1__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_display_annotationPanels1__DescriptionAttribute() {
    return "Customizable text panels";
  }
  get display_annotationPanels1() {
    return this._annotationPanels1;
  }
  set display_annotationPanels1(value) {
    this._annotationPanels1 = value;
  }
};
var AlarmSection = class {
  get summary() {
    let c = this._sensor.getAlarmCondition(this._index);
    if (c == 0)
      return "Disabled";
    return "Enabled";
  }
  constructor(index) {
    this._sensor = sensorsManager.getNullSensor();
    this._index = 0;
    this._index = index;
  }
  get ATTR_source__DisplayName() {
    return "Data source type";
  }
  get ATTR_source__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_source__AllowedValues() {
    return sensorDataTypeDescription.AllowedValues;
  }
  get ATTR_source__DescriptionAttribute() {
    return "Alarm sensor data source (Average, minimum or maximum value during last interval)";
  }
  get source() {
    return this._sensor.getAlarmSource(this._index);
  }
  set source(value) {
    this._sensor.setAlarmSource(this._index, value);
  }
  get ATTR_condition__DisplayName() {
    return "Test Condition";
  }
  get ATTR_condition__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_condition__AllowedValues() {
    return AlarmTestTypeDescription.AllowedValues;
  }
  get ATTR_condition__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_condition__DescriptionAttribute() {
    return "Alarm trigger condition";
  }
  get condition() {
    return this._sensor.getAlarmCondition(this._index);
  }
  set condition(value) {
    this._sensor.setAlarmCondition(this._index, value);
  }
  setDataSource(sensor) {
    this._sensor = sensor;
  }
  get ATTR_value__DisplayName() {
    return "Test Value";
  }
  get ATTR_value__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_value__DescriptionAttribute() {
    return "Value for the Alarm trigger";
  }
  get value() {
    return this._sensor.getAlarmValue(this._index);
  }
  set value(value) {
    this._sensor.setAlarmValue(this._index, value);
  }
  get ATTR_commandLine__DisplayName() {
    return "Trigger action";
  }
  get ATTR_commandLine__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_commandLine__DescriptionAttribute() {
    return "Javascript snippet executed in your browser each time the alarm is triggered, you can use the following variables: $SENSORVALUE$, $UNIT$, $HWDID$, $NAME$, $CONDITION$, $TRIGGER$, $DATATYPE$, $NOW$. Example : <tt>alarm('Warning $NAME$ = $SENSORVALUE$!');</tt>. You can check logs to find out if your alarm code works.";
  }
  get commandLine() {
    return this._sensor.getAlarmCommandline(this._index);
  }
  set commandLine(value) {
    this._sensor.setAlarmCommandline(this._index, value);
  }
  get ATTR_delay__DisplayName() {
    return "Trigger delay";
  }
  get ATTR_delay__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_delay__DescriptionAttribute() {
    return "Minimum delay, in seconds, between two alarms. Think carefully and make sure you won't create alarm storms.";
  }
  get delay() {
    return this._sensor.getAlarmDelay(this._index);
  }
  set delay(value) {
    this._sensor.setAlarmDelay(this._index, value);
  }
};
var ChartSerie = class {
  constructor(defaultColor) {
    this.ownerForm = null;
    this.index = -1;
    this.dataloggerAlreadyLoaded = false;
    this._DataSource_source = sensorsManager.getNullSensor();
    this._DataType = 0;
    this._thickness = 2;
    this._legend = "";
    this._color = YColor.Red;
    this._yAxisIndex = 0;
    this._DataSource_AlarmSection0 = new AlarmSection(0);
    this._DataSource_AlarmSection1 = new AlarmSection(1);
    this._color = defaultColor;
  }
  get summary() {
    return this._DataSource_source instanceof NullYSensor ? "none" : this._DataSource_source.get_friendlyName() + (this._DataSource_source.isOnline() ? "" : " - OFFLINE");
  }
  Init(owner, serieIndex) {
    this.ownerForm = owner;
    this.index = serieIndex;
    this.PropagateDataSourceChange(this._DataSource_source);
  }
  PropagateDataSourceChange(value) {
    this.ownerForm.SourceChanged(this._DataSource_source, this.index);
    let props = GenericProperties.getAllProperties(this).byName;
    let name;
    for (name in props) {
      if (name.startsWith("DataSource_AlarmSection")) {
        this[name].setDataSource(this._DataSource_source);
      }
    }
  }
  get ATTR_DataSource_source__DisplayName() {
    return "Sensor";
  }
  get ATTR_DataSource_source__CopyToTarget() {
    return false;
  }
  get ATTR_DataSource_source__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_DataSource_source__DescriptionAttribute() {
    return "Yoctopuce sensor feeding the graph. " + GenericHints.CheckSensor;
  }
  get DataSource_source() {
    return this._DataSource_source;
  }
  set DataSource_source(value) {
    let prev = this._DataSource_source;
    this._DataSource_source = value;
    if (this._DataSource_source != prev)
      constants.edited = true;
    if (this.ownerForm != null)
      this.PropagateDataSourceChange(this._DataSource_source);
  }
  get isSensorReadOnly() {
    return this._DataSource_source.isReadOnly;
  }
  get ATTR_DataSource_freq__DisplayName() {
    return "Sensor frequency";
  }
  get ATTR_DataSource_freq__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_DataSource_freq__CopyToTarget() {
    return false;
  }
  get ATTR_DataSource_freq__IsReadonlyCallAttribute() {
    return "isSensorReadOnly";
  }
  get ATTR_DataSource_freq__DescriptionAttribute() {
    return "Sensor data acquisition frequency." + GenericHints.DevConfAffected;
  }
  get ATTR_DataSource_freq__AllowedValues() {
    return sensorFreqTypeDescription.AllowedValues;
  }
  get DataSource_freq() {
    return this._DataSource_source.get_frequency();
  }
  set DataSource_freq(value) {
    this._DataSource_source.set_frequency(value);
  }
  get ATTR_DataSource_datatype__DisplayName() {
    return "Sensor data";
  }
  get ATTR_DataSource_datatype__AllowedValues() {
    return sensorDataTypeDescription.AllowedValues;
  }
  get ATTR_DataSource_datatype__CopyToTarget() {
    return false;
  }
  get ATTR_DataSource_datatype__DescriptionAttribute() {
    return "Which data for sensor are displayed on the graph. Min and Max are available only for frequencies <1Hz";
  }
  get DataSource_datatype() {
    return this._DataType;
  }
  set DataSource_datatype(value) {
    this._DataType = value;
    if (this.ownerForm != null) {
      this.ownerForm.SourceChanged(this._DataSource_source, this.index);
    }
  }
  get ATTR_DataSource_recording__DisplayName() {
    return "Sensor recording";
  }
  get ATTR_DataSource_recording__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_DataSource_recording__IsReadonlyCallAttribute() {
    return "isSensorReadOnly";
  }
  get ATTR_DataSource_recording__CopyToTarget() {
    return false;
  }
  get ATTR_DataSource_recording__DescriptionAttribute() {
    return "Enable/ disable sensor data recording in the device on-board datalogger." + GenericHints.DevConfAffected;
  }
  get DataSource_recording() {
    return this._DataSource_source.get_recording();
  }
  set DataSource_recording(value) {
    this._DataSource_source.set_recording(value);
  }
  get ATTR_thickness__DisplayName() {
    return "Thickness";
  }
  get ATTR_thickness__DescriptionAttribute() {
    return "Line thickness.";
  }
  get thickness() {
    return this._thickness;
  }
  set thickness(value) {
    this._thickness = value;
  }
  get ATTR_legend__DisplayName() {
    return "Legend";
  }
  get ATTR_legend__DescriptionAttribute() {
    return "Short description of the series.";
  }
  get legend() {
    return this._legend;
  }
  set legend(value) {
    this._legend = value;
  }
  get ATTR_color__DisplayName() {
    return "Color";
  }
  get ATTR_color__DescriptionAttribute() {
    return "Line color.";
  }
  get color() {
    return this._color;
  }
  set color(value) {
    this._color = value;
  }
  get ATTR_yAxisIndex__AllowedValues() {
    return yAxisDescription.AllowedValues;
  }
  get ATTR_yAxisIndex__DisplayName() {
    return "Y axis";
  }
  get ATTR_yAxisIndex__DescriptionAttribute() {
    return "Choose which Y axis the data with be scaled to.";
  }
  get yAxisIndex() {
    return this._yAxisIndex;
  }
  set yAxisIndex(value) {
    this._yAxisIndex = value;
  }
  get ATTR_DataSource_AlarmSection0__DisplayName() {
    return "Sensor value alarm 1";
  }
  get ATTR_DataSource_AlarmSection0__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection0__DescriptionAttribute() {
    return "Alarm 1 for this data source, expand for more.";
  }
  get DataSource_AlarmSection0() {
    return this._DataSource_AlarmSection0;
  }
  set DataSource_AlarmSection0(value) {
    this._DataSource_AlarmSection0 = value;
  }
  get ATTR_DataSource_AlarmSection1__DisplayName() {
    return "Sensor value alarm 2";
  }
  get ATTR_DataSource_AlarmSection1__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection1__DescriptionAttribute() {
    return "Alarm 2 for this data source, expand for more.";
  }
  get DataSource_AlarmSection1() {
    return this._DataSource_AlarmSection1;
  }
  set DataSource_AlarmSection1(value) {
    this._DataSource_AlarmSection1 = value;
  }
};
var LegendPanelDescription = class {
  constructor() {
    this._enabled = false;
    this._overlap = false;
    this._position = LegendPanel.Position.RIGHT;
    this._font = new FontDescription("Arial", 7, YColor.FromArgb(255, 32, 32, 32), false, true);
    this._bgColor = YColor.FromArgb(200, 255, 255, 255);
    this._borderColor = YColor.Black;
    this._borderthickness = 1;
    this._padding = 10;
    this._verticalMargin = 10;
    this._horizontalMargin = 10;
    this._traceWidthFactor = 1;
  }
  get summary() {
    return this._enabled ? "Enabled" : "Disabled";
  }
  get ATTR_enabled__DisplayName() {
    return "Enabled";
  }
  get ATTR_enabled__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_enabled__DescriptionAttribute() {
    return "Should the legend panel be shown or not";
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    this._enabled = value;
  }
  get ATTR_overlap__DisplayName() {
    return "Overlap";
  }
  get ATTR_overlap__DescriptionAttribute() {
    return "Can the panel overlap the graph data, or should we explicitly make space for it?";
  }
  get overlap() {
    return this._overlap;
  }
  set overlap(value) {
    this._overlap = value;
  }
  get ATTR_position__DisplayName() {
    return "Position";
  }
  get ATTR_position__DescriptionAttribute() {
    return "Position of the legend panel";
  }
  get position() {
    return this._position;
  }
  set position(value) {
    this._position = value;
  }
  get ATTR_font__DisplayName() {
    return "Font";
  }
  get ATTR_font__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_font__DescriptionAttribute() {
    return "Legend panel contents fonts";
  }
  get font() {
    return this._font;
  }
  set font(value) {
    this._font = value;
  }
  get ATTR_bgColor__DisplayName() {
    return "Background color ";
  }
  get ATTR_bgColor__DescriptionAttribute() {
    return "Legend panel background color.";
  }
  get bgColor() {
    return this._bgColor;
  }
  set bgColor(value) {
    this._bgColor = value;
  }
  get ATTR_borderColor__DisplayName() {
    return "Border color ";
  }
  get ATTR_borderColor__DescriptionAttribute() {
    return "Legend panel border color.";
  }
  get borderColor() {
    return this._borderColor;
  }
  set borderColor(value) {
    this._borderColor = value;
  }
  get ATTR_borderthickness__DisplayName() {
    return "Border thickness ";
  }
  get ATTR_borderthickness__DescriptionAttribute() {
    return "Legend panel border thickness";
  }
  get borderthickness() {
    return this._borderthickness;
  }
  set borderthickness(value) {
    this._borderthickness = value;
  }
  get ATTR_padding__DisplayName() {
    return "Padding ";
  }
  get ATTR_padding__DescriptionAttribute() {
    return "Distance between the panel border and the panel contents";
  }
  get padding() {
    return this._padding;
  }
  set padding(value) {
    this._padding = value;
  }
  get ATTR_verticalMargin__DisplayName() {
    return "Vertical margin ";
  }
  get ATTR_verticalMargin__DescriptionAttribute() {
    return "Vertical distance between the panel border and its surroundings";
  }
  get verticalMargin() {
    return this._verticalMargin;
  }
  set verticalMargin(value) {
    this._verticalMargin = value;
  }
  get ATTR_horizontalMargin__DisplayName() {
    return "Horizontal margin ";
  }
  get ATTR_horizontalMargin__DescriptionAttribute() {
    return "Distance between the panel border and its surroundings";
  }
  get horizontalMargin() {
    return this._horizontalMargin;
  }
  set horizontalMargin(value) {
    this._horizontalMargin = value;
  }
  get ATTR_traceWidthFactor__DisplayName() {
    return "Color Indicator Factor";
  }
  get ATTR_traceWidthFactor__DescriptionAttribute() {
    return "Factor used to enlarge series color indicators shown in the legend panel";
  }
  get traceWidthFactor() {
    return this._traceWidthFactor;
  }
  set traceWidthFactor(value) {
    this._traceWidthFactor = value;
  }
};
var AnnotationPanelDescription = class {
  get summary() {
    return this._enabled ? "Enabled" : "Disabled";
  }
  get ATTR_enabled__DisplayName() {
    return "Enabled";
  }
  get ATTR_enabled__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_enabled__DescriptionAttribute() {
    return "Should the annotation panel be shown or not";
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    this._enabled = value;
  }
  get ATTR_overlap__DisplayName() {
    return "Overlap";
  }
  get ATTR_overlap__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_overlap__DescriptionAttribute() {
    return "Can the annotation panel overlap the display zone, or should the display zone be squeezed to make space for the panel?";
  }
  get overlap() {
    return this._overlap;
  }
  set overlap(value) {
    this._overlap = value;
  }
  get ATTR_text__DisplayName() {
    return "Text ";
  }
  get ATTR_text__DescriptionAttribute() {
    return GenericHints.Annotation;
  }
  get text() {
    return this._text;
  }
  set text(value) {
    this._text = value;
  }
  get ATTR_panelTextAlign__DisplayName() {
    return "Text Alignment";
  }
  get ATTR_panelTextAlign__DescriptionAttribute() {
    return "How text is aligned, makes sense on multi-lines text only.";
  }
  get panelTextAlign() {
    return this._panelTextAlign;
  }
  set panelTextAlign(value) {
    this._panelTextAlign = value;
  }
  get ATTR_panelHrzAlign__DisplayName() {
    return "X Position";
  }
  get ATTR_panelHrzAlign__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_panelHrzAlign__DescriptionAttribute() {
    return "Annotation panel X position";
  }
  get panelHrzAlign() {
    return this._panelHrzAlign;
  }
  set panelHrzAlign(value) {
    this._panelHrzAlign = value;
  }
  get ATTR_positionOffsetX__DisplayName() {
    return "X Offset";
  }
  get ATTR_positionOffsetX__DescriptionAttribute() {
    return "X Position offset, in %  (overlap mode only)";
  }
  get positionOffsetX() {
    return this._positionOffsetX;
  }
  set positionOffsetX(value) {
    this._positionOffsetX = value;
  }
  get ATTR_panelVrtAlign__DisplayName() {
    return "Y Position";
  }
  get ATTR_panelVrtAlign__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_panelVrtAlign__DescriptionAttribute() {
    return "Annotation panel Y position";
  }
  get panelVrtAlign() {
    return this._panelVrtAlign;
  }
  set panelVrtAlign(value) {
    this._panelVrtAlign = value;
  }
  get ATTR_positionOffsetY__DisplayName() {
    return "Y Offset";
  }
  get ATTR_positionOffsetY__DescriptionAttribute() {
    return "Y Position offset, in %  (overlap mode only)";
  }
  get positionOffsetY() {
    return this._positionOffsetY;
  }
  set positionOffsetY(value) {
    this._positionOffsetY = value;
  }
  get ATTR_font__DisplayName() {
    return "Font";
  }
  get ATTR_font__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_font__DescriptionAttribute() {
    return "Panel font";
  }
  get font() {
    return this._font;
  }
  set font(value) {
    this._font = value;
  }
  get ATTR_bgColor__DisplayName() {
    return "Background color ";
  }
  get ATTR_bgColor__DescriptionAttribute() {
    return "Legend panel background color.";
  }
  get bgColor() {
    return this._bgColor;
  }
  set bgColor(value) {
    this._bgColor = value;
  }
  get ATTR_borderColor__DisplayName() {
    return "Border color ";
  }
  get ATTR_borderColor__DescriptionAttribute() {
    return "Legend panel border color.";
  }
  get borderColor() {
    return this._borderColor;
  }
  set borderColor(value) {
    this._borderColor = value;
  }
  get ATTR_borderthickness__DisplayName() {
    return "Border thickness ";
  }
  get ATTR_borderthickness__DescriptionAttribute() {
    return "Panel border thickness";
  }
  get borderthickness() {
    return this._borderthickness;
  }
  set borderthickness(value) {
    this._borderthickness = value;
  }
  get ATTR_padding__DisplayName() {
    return "Padding ";
  }
  get ATTR_padding__DescriptionAttribute() {
    return "Distance between the panel border and the panel contents";
  }
  get padding() {
    return this._padding;
  }
  set padding(value) {
    this._padding = value;
  }
  constructor(hrzAlignInit, vrtAlignInit, offsetY, overlap, textInit, BgColorInit, BorderColorInit, fontSizeInit, FontColorInit) {
    this._enabled = false;
    this._overlap = false;
    this._text = "Date: $DAY$/$MONTH$/$YEAR$";
    this._panelTextAlign = GenericPanel.TextAlign.CENTER;
    this._panelHrzAlign = GenericPanel.HorizontalAlignPos.CENTER;
    this._positionOffsetX = 0;
    this._panelVrtAlign = GenericPanel.VerticalAlignPos.TOP;
    this._positionOffsetY = 0;
    this._font = new FontDescription("Arial", 12, YColor.FromArgb(255, 32, 32, 32), false, false);
    this._bgColor = YColor.FromArgb(200, 255, 255, 255);
    this._borderColor = YColor.Black;
    this._borderthickness = 1;
    this._padding = 5;
    if (typeof textInit != "undefined")
      this._text = textInit;
    if (typeof offsetY != "undefined")
      this._positionOffsetY = offsetY;
    if (typeof overlap != "undefined")
      this._overlap = overlap;
    if (typeof BgColorInit != "undefined")
      this._bgColor = BgColorInit;
    if (typeof BorderColorInit != "undefined")
      this._borderColor = BorderColorInit;
    if (typeof fontSizeInit != "undefined")
      this._font.size = fontSizeInit;
    if (typeof FontColorInit != "undefined")
      this._font.color = FontColorInit;
    if (typeof vrtAlignInit != "undefined")
      this._panelVrtAlign = vrtAlignInit;
    if (typeof hrzAlignInit != "undefined")
      this._panelHrzAlign = hrzAlignInit;
  }
};
var AnnotationPanelDescriptionGraph = class extends AnnotationPanelDescription {
  get ATTR_enabled__DisplayName() {
    return "Enabled";
  }
  get ATTR_enabled__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_enabled__DescriptionAttribute() {
    return "Should the annotation panel be shown or not";
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    this._enabled = value;
  }
  get ATTR_overlap__DisplayName() {
    return "Overlap";
  }
  get ATTR_overlap__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_overlap__DescriptionAttribute() {
    return "Can the annotation panel overlap the graph, or should the graph be squeezed to make space for the panel?";
  }
  get overlap() {
    return this._overlap;
  }
  set overlap(value) {
    this._overlap = value;
  }
  get ATTR_text__DisplayName() {
    return "Text ";
  }
  get ATTR_text__DescriptionAttribute() {
    return GenericHints.AnnotationGraph;
  }
  get text() {
    return this._text;
  }
  set text(value) {
    this._text = value;
  }
};
var DataTrackerDescription = class {
  constructor() {
    this._enabled = false;
    this._showSerieName = false;
    this._showTimeStamp = false;
    this._dataPrecision = DataTrackerDescription.DataPrecision.PRECISION_NOLIMIT;
    this._diameter = 5;
    this._handleLength = 25;
    this._font = new FontDescription("Arial", 7, YColor.FromArgb(255, 32, 32, 32), false, false);
    this._bgColor = YColor.FromArgb(200, 255, 255, 255);
    this._borderColor = YColor.Black;
    this._borderthickness = 1;
    this._padding = 5;
    this._detectionDistance = 50;
  }
  get summary() {
    return this._enabled ? "Enabled" : "Disabled";
  }
  get ATTR_enabled__DisplayName() {
    return "Enabled";
  }
  get ATTR_enabled__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_enabled__DescriptionAttribute() {
    return "Should the data tracker be shown or not.";
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    this._enabled = value;
  }
  get ATTR_showSerieName__DisplayName() {
    return "Show Series legend";
  }
  get ATTR_showSerieName__DescriptionAttribute() {
    return "Should the data tracker show the value's series legend.";
  }
  get showSerieName() {
    return this._showSerieName;
  }
  set showSerieName(value) {
    this._showSerieName = value;
  }
  get ATTR_showTimeStamp__DisplayName() {
    return "Show Timestamp";
  }
  get ATTR_showTimeStamp__DescriptionAttribute() {
    return "Should the data tracker show the value's timestamp.";
  }
  get showTimeStamp() {
    return this._showTimeStamp;
  }
  set showTimeStamp(value) {
    this._showTimeStamp = value;
  }
  get ATTR_dataPrecision__DisplayName() {
    return "Precision";
  }
  get ATTR_dataPrecision__DescriptionAttribute() {
    return "A way to limit data precision to meaningful digits in the data tracker.";
  }
  get dataPrecision() {
    return this._dataPrecision;
  }
  set dataPrecision(value) {
    this._dataPrecision = value;
  }
  get ATTR_diameter__DisplayName() {
    return "Point Diameter";
  }
  get ATTR_diameter__DescriptionAttribute() {
    return "Data point diameter, in pixels";
  }
  get diameter() {
    return this._diameter;
  }
  set diameter(value) {
    this._diameter = value;
  }
  get ATTR_handleLength__DisplayName() {
    return "Handle size";
  }
  get ATTR_handleLength__DescriptionAttribute() {
    return "size of the handle between the data point and the value panel";
  }
  get handleLength() {
    return this._handleLength;
  }
  set handleLength(value) {
    this._handleLength = value;
  }
  get ATTR_font__DisplayName() {
    return "Font";
  }
  get ATTR_font__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_font__DescriptionAttribute() {
    return "Data tracker label fonts";
  }
  get font() {
    return this._font;
  }
  set font(value) {
    this._font = value;
  }
  get ATTR_bgColor__DisplayName() {
    return "Background color";
  }
  get ATTR_bgColor__DescriptionAttribute() {
    return "Value panel ground color.";
  }
  get bgColor() {
    return this._bgColor;
  }
  set bgColor(value) {
    this._bgColor = value;
  }
  get ATTR_borderColor__DisplayName() {
    return "Border color";
  }
  get ATTR_borderColor__DescriptionAttribute() {
    return "Value panel border and handle  color.";
  }
  get borderColor() {
    return this._borderColor;
  }
  set borderColor(value) {
    this._borderColor = value;
  }
  get ATTR_borderthickness__DisplayName() {
    return "Border thickness ";
  }
  get ATTR_borderthickness__DescriptionAttribute() {
    return "Value panel border and handle  thickness";
  }
  get borderthickness() {
    return this._borderthickness;
  }
  set borderthickness(value) {
    this._borderthickness = value;
  }
  get ATTR_padding__DisplayName() {
    return "Padding";
  }
  get ATTR_padding__DescriptionAttribute() {
    return "Distance between the panel border and its contents ";
  }
  get padding() {
    return this._padding;
  }
  set padding(value) {
    this._padding = value;
  }
  get ATTR_detectionDistance__DisplayName() {
    return "Detection distance";
  }
  get ATTR_detectionDistance__DescriptionAttribute() {
    return "Maximum distance, in pixels, between the mouse and a data point for data tracker to show. Use zero for infinite distance";
  }
  get detectionDistance() {
    return this._detectionDistance;
  }
  set detectionDistance(value) {
    this._detectionDistance = value;
  }
};
(function(DataTrackerDescription2) {
  class DataPrecisionEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, DataPrecision);
    }
  }
  DataTrackerDescription2.DataPrecisionEnumItem = DataPrecisionEnumItem;
  class DataPrecision extends YEnum {
  }
  DataPrecision.PRECISION_NOLIMIT = new DataPrecisionEnumItem("PRECISION_NOLIMIT", "As is");
  DataPrecision.PRECISION_1 = new DataPrecisionEnumItem("PRECISION_1", "1");
  DataPrecision.PRECISION_01 = new DataPrecisionEnumItem("PRECISION_01", "0.1");
  DataPrecision.PRECISION_001 = new DataPrecisionEnumItem("PRECISION_001", "0.01");
  DataPrecision.PRECISION_0001 = new DataPrecisionEnumItem("PRECISION_0001", "0.001");
  DataTrackerDescription2.DataPrecision = DataPrecision;
})(DataTrackerDescription || (DataTrackerDescription = {}));
var NavigatorDescription = class {
  get summary() {
    return this._enabled ? "Enabled" : "Disabled";
  }
  constructor() {
    this._enabled = false;
    this._bgColor1 = YColor.FromArgb(255, 225, 225, 225);
    this._bgColor2 = YColor.FromArgb(255, 225, 225, 225);
    this._borderThickness = 1;
    this._borderColor = YColor.Black;
    this._cursorColor = YColor.FromArgb(25, 0, 255, 0);
    this._cursorBorderColor = YColor.FromArgb(255, 96, 96, 96);
    this._yAxisHandling = Navigator.YAxisHandling.AUTO;
    this._xAxisThickness = 1;
    this._xAxisColor = YColor.Black;
    this._font = new FontDescription("Arial", 10, YColor.FromArgb(255, 32, 32, 32), false, false);
  }
  get ATTR_enabled__DisplayName() {
    return "Enabled";
  }
  get ATTR_enabled__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_enabled__DescriptionAttribute() {
    return "Should the navigator be shown or not.";
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    this._enabled = value;
  }
  get ATTR_bgColor1__DisplayName() {
    return "Background color 1";
  }
  get ATTR_bgColor1__DescriptionAttribute() {
    return "Navigator background gradient color 1.";
  }
  get bgColor1() {
    return this._bgColor1;
  }
  set bgColor1(value) {
    this._bgColor1 = value;
  }
  get ATTR_bgColor2__DisplayName() {
    return "Background color 2";
  }
  get ATTR_bgColor2__DescriptionAttribute() {
    return "Navigator background gradient color 2.";
  }
  get bgColor2() {
    return this._bgColor2;
  }
  set bgColor2(value) {
    this._bgColor2 = value;
  }
  get ATTR_borderThickness__DisplayName() {
    return "Border thickness";
  }
  get ATTR_borderThickness__DescriptionAttribute() {
    return "Navigator";
  }
  get borderThickness() {
    return this._borderThickness;
  }
  set borderThickness(value) {
    this._borderThickness = value;
  }
  get ATTR_borderColor__DisplayName() {
    return "Border color";
  }
  get ATTR_borderColor__DescriptionAttribute() {
    return "Navigator Border color.";
  }
  get borderColor() {
    return this._borderColor;
  }
  set borderColor(value) {
    this._borderColor = value;
  }
  get ATTR_cursorColor__DisplayName() {
    return "Navigator cursor fill color";
  }
  get ATTR_cursorColor__DescriptionAttribute() {
    return "Navigator";
  }
  get cursorColor() {
    return this._cursorColor;
  }
  set cursorColor(value) {
    this._cursorColor = value;
  }
  get ATTR_cursorBorderColor__DisplayName() {
    return "Navigator cursor left/right border color.";
  }
  get ATTR_cursorBorderColor__DescriptionAttribute() {
    return "Navigator";
  }
  get cursorBorderColor() {
    return this._cursorBorderColor;
  }
  set cursorBorderColor(value) {
    this._cursorBorderColor = value;
  }
  get ATTR_yAxisHandling__DisplayName() {
    return "Y axis range";
  }
  get ATTR_yAxisHandling__DescriptionAttribute() {
    return "Is navigator Y axis zoom automatic or inherited from main view settings?";
  }
  get yAxisHandling() {
    return this._yAxisHandling;
  }
  set yAxisHandling(value) {
    this._yAxisHandling = value;
  }
  get ATTR_xAxisThickness__DisplayName() {
    return "X axis thickness";
  }
  get ATTR_xAxisThickness__DescriptionAttribute() {
    return "Navigator";
  }
  get xAxisThickness() {
    return this._xAxisThickness;
  }
  set xAxisThickness(value) {
    this._xAxisThickness = value;
  }
  get ATTR_xAxisColor__DisplayName() {
    return "X axis color";
  }
  get ATTR_xAxisColor__DescriptionAttribute() {
    return "Navigator X axis color.";
  }
  get xAxisColor() {
    return this._xAxisColor;
  }
  set xAxisColor(value) {
    this._xAxisColor = value;
  }
  get ATTR_font__DisplayName() {
    return "X-Axis Font";
  }
  get ATTR_font__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_font__DescriptionAttribute() {
    return "Navigator X axis font";
  }
  get font() {
    return this._font;
  }
  set font(value) {
    this._font = value;
  }
};
var LegendDescription = class {
  constructor() {
    this._title = "";
    this._font = new FontDescription("Arial", 12, YColor.Black, false, true);
  }
  get ATTR_title__DisplayName() {
    return "Text";
  }
  get ATTR_title__DescriptionAttribute() {
    return "Legend text";
  }
  get title() {
    return this._title;
  }
  set title(value) {
    this._title = value;
  }
  get ATTR_font__DisplayName() {
    return "Font";
  }
  get ATTR_font__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_font__DescriptionAttribute() {
    return "Legend font";
  }
  get font() {
    return this._font;
  }
  set font(value) {
    this._font = value;
  }
};
var YaxisDescription = class {
  constructor(index, shown) {
    this._visible = false;
    this._position = YAxis.HrzPosition.LEFT;
    this._min = new doubleNan(Number.NaN);
    this._max = new doubleNan(Number.NaN);
    this._step = new doubleNan(Number.NaN);
    this._color = YColor.FromArgb(255, 127, 127, 127);
    this._thickness = 1;
    this._showGrid = false;
    this._gridColor = YColor.FromArgb(255, 210, 210, 210);
    this._gridThickness = 1;
    this._font = new FontDescription("Arial", 10, YColor.Black, false, false);
    this._legend = new LegendDescription();
    this._zones0 = new ZoneDescription(0, 50, YColor.LightGreen);
    this._zones1 = new ZoneDescription(50, 80, YColor.Yellow);
    this._zones2 = new ZoneDescription(80, 100, YColor.Red);
    this._visible = shown;
    this._showGrid = index == 0;
    this._position = index == 0 ? YAxis.HrzPosition.LEFT : YAxis.HrzPosition.RIGHT;
  }
  get summary() {
    return this._visible ? "Enabled" : "Disabled";
  }
  get ATTR_visible__DisplayName() {
    return "Visible";
  }
  get ATTR_visible__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_visible__DescriptionAttribute() {
    return "Should that YAxis be shown?.";
  }
  get visible() {
    return this._visible;
  }
  set visible(value) {
    this._visible = value;
  }
  get ATTR_position__DisplayName() {
    return "Position";
  }
  get ATTR_position__DescriptionAttribute() {
    return "Y Axis position (left / right)";
  }
  get position() {
    return this._position;
  }
  set position(value) {
    this._position = value;
  }
  get ATTR_min__DisplayName() {
    return "Minimum value";
  }
  get ATTR_min__DescriptionAttribute() {
    return "YAxis minimum value, leave blank for automatic behavior.";
  }
  get min() {
    return this._min;
  }
  set min(value) {
    this._min = value;
  }
  get ATTR_max__DisplayName() {
    return "Maximum value";
  }
  get ATTR_max__DescriptionAttribute() {
    return "YAxis maximum value, leave blank for automatic behavior.";
  }
  get max() {
    return this._max;
  }
  set max(value) {
    this._max = value;
  }
  get ATTR_step__DisplayName() {
    return "Steps";
  }
  get ATTR_step__DescriptionAttribute() {
    return "YAxis step size, leave blank for automatic behavior.";
  }
  get step() {
    return this._step;
  }
  set step(value) {
    this._step = value;
  }
  get ATTR_color__DisplayName() {
    return "Color";
  }
  get ATTR_color__DescriptionAttribute() {
    return "Y Axis Color.";
  }
  get color() {
    return this._color;
  }
  set color(value) {
    this._color = value;
  }
  get ATTR_thickness__DisplayName() {
    return "Thickness";
  }
  get ATTR_thickness__DescriptionAttribute() {
    return "Axis thickness";
  }
  get thickness() {
    return this._thickness;
  }
  set thickness(value) {
    this._thickness = value;
  }
  get ATTR_showGrid__DisplayName() {
    return "Show Grid";
  }
  get ATTR_showGrid__DescriptionAttribute() {
    return "Show grid horizontal lines, or not.";
  }
  get showGrid() {
    return this._showGrid;
  }
  set showGrid(value) {
    this._showGrid = value;
  }
  get ATTR_gridColor__DisplayName() {
    return "Grid Color";
  }
  get ATTR_gridColor__DescriptionAttribute() {
    return "Grid horizontal lines color.";
  }
  get gridColor() {
    return this._gridColor;
  }
  set gridColor(value) {
    this._gridColor = value;
  }
  get ATTR_gridThickness__DisplayName() {
    return "Grid thickness";
  }
  get ATTR_gridThickness__DescriptionAttribute() {
    return "Grid horizontal lines thickness";
  }
  get gridThickness() {
    return this._gridThickness;
  }
  set gridThickness(value) {
    this._gridThickness = value;
  }
  get ATTR_font__DisplayName() {
    return "Font";
  }
  get ATTR_font__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_font__DescriptionAttribute() {
    return "Axis font";
  }
  get font() {
    return this._font;
  }
  set font(value) {
    this._font = value;
  }
  get ATTR_legend__DisplayName() {
    return "Legend";
  }
  get ATTR_legend__DescriptionAttribute() {
    return "Axis legend";
  }
  get legend() {
    return this._legend;
  }
  set legend(value) {
    this._legend = value;
  }
  get ATTR_zones0__DisplayName() {
    return "Zone 1";
  }
  get ATTR_zones0__CategoryAttribute() {
    return "Zones";
  }
  get ATTR_zones0__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_zones0__DescriptionAttribute() {
    return "Zone 1 parameters";
  }
  get zones0() {
    return this._zones0;
  }
  set zones0(value) {
    this._zones0 = value;
  }
  get ATTR_zones1__DisplayName() {
    return "Zone 2";
  }
  get ATTR_zones1__CategoryAttribute() {
    return "Zones";
  }
  get ATTR_zones1__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_zones1__DescriptionAttribute() {
    return "Zone 2 parameters";
  }
  get zones1() {
    return this._zones1;
  }
  set zones1(value) {
    this._zones1 = value;
  }
  get ATTR_zones2__DisplayName() {
    return "Zone 3";
  }
  get ATTR_zones2__CategoryAttribute() {
    return "Zones";
  }
  get ATTR_zones2__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_zones2__DescriptionAttribute() {
    return "Zone 3 parameters";
  }
  get zones2() {
    return this._zones2;
  }
  set zones2(value) {
    this._zones2 = value;
  }
};
var MarkerDescription = class {
  constructor(defaultText) {
    this._enabled = false;
    this._text = "";
    this._textAlign = Marker.TextAlign.CENTER;
    this._timereference = TimeConverter.TimeReference.ABSOLUTE;
    this._positionOnXAxis = new xAxisPosition(TimeConverter.ToUnixTime(new Date()), false);
    this._yposition = 95;
    this._bgColor = YColor.FromArgb(200, 255, 255, 192);
    this._borderColor = YColor.DarkRed;
    this._borderthickness = 1;
    this._padding = 5;
    this._font = new FontDescription("Arial", 7, YColor.Black, false, false);
    this._text = defaultText;
  }
  get summary() {
    return this._enabled ? "Enabled" : "Disabled";
  }
  get ATTR_enabled__DisplayName() {
    return "Enabled";
  }
  get ATTR_enabled__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_enabled__DescriptionAttribute() {
    return "Should that marker be shown?.";
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    this._enabled = value;
  }
  get ATTR_text__DisplayName() {
    return "Text";
  }
  get ATTR_text__DescriptionAttribute() {
    return "Marker text. Use \\n for multi-line text. Some variables are allowed such as $MARKERTIME$, $LEGEND1$, $VALUE1$, $UNIT1$, $LEGEND1$, $VALUE2$ etc.. Extensive use of marker variables migh make the graph rendering significantly slower.";
  }
  get text() {
    return this._text;
  }
  set text(value) {
    this._text = value;
  }
  get ATTR_textAlign__DisplayName() {
    return "Text Alignment";
  }
  get ATTR_textAlign__DescriptionAttribute() {
    return "How text is aligned, makes sense on multi-lines text only.";
  }
  get textAlign() {
    return this._textAlign;
  }
  set textAlign(value) {
    this._textAlign = value;
  }
  get ATTR_timereference__DisplayName() {
    return "Time reference";
  }
  get ATTR_timereference__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_timereference__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_timereference__DescriptionAttribute() {
    return "Should the marker time position be absolute or relative to first data timestamp? Note: relative markers won't be drawn until there is actual data.";
  }
  get timereference() {
    return this._timereference;
  }
  set timereference(value) {
    this._timereference = value;
    this._positionOnXAxis.relative = value == TimeConverter.TimeReference.RELATIVE;
  }
  get ATTR_positionOnXAxis__DisplayName() {
    return "Time position";
  }
  get ATTR_positionOnXAxis__DescriptionAttribute() {
    return "Marker position on X axis.";
  }
  get positionOnXAxis() {
    return this._positionOnXAxis;
  }
  set positionOnXAxis(value) {
    this._positionOnXAxis = value;
    this.timereference = value.relative ? TimeConverter.TimeReference.RELATIVE : TimeConverter.TimeReference.ABSOLUTE;
  }
  get ATTR_yposition__DisplayName() {
    return "Vrt position (%)";
  }
  get ATTR_yposition__DescriptionAttribute() {
    return "Vertical position of the marker label in % of available space. Zero is bottom";
  }
  get yposition() {
    return this._yposition;
  }
  set yposition(value) {
    this._yposition = value;
  }
  get ATTR_bgColor__DisplayName() {
    return "Background color ";
  }
  get ATTR_bgColor__DescriptionAttribute() {
    return "Marker  background color.";
  }
  get bgColor() {
    return this._bgColor;
  }
  set bgColor(value) {
    this._bgColor = value;
  }
  get ATTR_borderColor__DisplayName() {
    return "Border color ";
  }
  get ATTR_borderColor__DescriptionAttribute() {
    return "Marker border color.";
  }
  get borderColor() {
    return this._borderColor;
  }
  set borderColor(value) {
    this._borderColor = value;
  }
  get ATTR_borderthickness__DisplayName() {
    return "Border thickness ";
  }
  get ATTR_borderthickness__DescriptionAttribute() {
    return "Marker border thickness, in pixels.";
  }
  get borderthickness() {
    return this._borderthickness;
  }
  set borderthickness(value) {
    this._borderthickness = value;
  }
  get ATTR_padding__DisplayName() {
    return "Padding ";
  }
  get ATTR_padding__DescriptionAttribute() {
    return "Distance between the marker border and the marker contents, in pixels.";
  }
  get padding() {
    return this._padding;
  }
  set padding(value) {
    this._padding = value;
  }
  get ATTR_font__DisplayName() {
    return "Font";
  }
  get ATTR_font__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_font__DescriptionAttribute() {
    return "Marker Font";
  }
  get font() {
    return this._font;
  }
  set font(value) {
    this._font = value;
  }
};
var XaxisDescription = class {
  constructor() {
    this._initialZoom = 60;
    this._initialOffset = 0;
    this._position = XAxis.VrtPosition.BOTTOM;
    this._timeReference = TimeConverter.TimeReference.ABSOLUTE;
    this._overflowHandling = XAxis.OverflowHandling.SCROLL;
    this._color = YColor.FromArgb(255, 127, 127, 127);
    this._thickness = 1;
    this._showGrid = false;
    this._gridColor = YColor.FromArgb(50, 0, 0, 0);
    this._gridThickness = 1;
    this._font = new FontDescription("Arial", 10, YColor.Black, false, false);
    this._legend = new LegendDescription();
    this._markers0 = new MarkerDescription("Marker 1");
    this._markers1 = new MarkerDescription("Marker 2");
    this._markers2 = new MarkerDescription("Marker 3");
    this._markers3 = new MarkerDescription("Marker 4");
    this._markers4 = new MarkerDescription("Marker 5");
    this._markers5 = new MarkerDescription("Marker 6");
    this._markers6 = new MarkerDescription("Marker 7");
    this._markers7 = new MarkerDescription("Marker 8");
  }
  get ATTR_initialZoom__DisplayName() {
    return "Initial Zoom";
  }
  get ATTR_initialZoom__DescriptionAttribute() {
    return "Zoom level at application startup, i.e. width of the view-port in seconds.";
  }
  get initialZoom() {
    return this._initialZoom;
  }
  set initialZoom(value) {
    this._initialZoom = value;
  }
  get ATTR_initialOffset__DisplayName() {
    return "Initial Offset";
  }
  get ATTR_initialOffset__DescriptionAttribute() {
    return "Offset of the first data point in percentage of the viewport width. For instance a 50% value will put the first point in the middle of the viewport. This can be used to give some room for datalogger contents.";
  }
  get initialOffset() {
    return this._initialOffset;
  }
  set initialOffset(value) {
    this._initialOffset = value;
  }
  get ATTR_position__DisplayName() {
    return "Position";
  }
  get ATTR_position__DescriptionAttribute() {
    return "X Axis position (top / bottom)";
  }
  get position() {
    return this._position;
  }
  set position(value) {
    this._position = value;
  }
  get ATTR_timeReference__DisplayName() {
    return "Time reference";
  }
  get ATTR_timeReference__DescriptionAttribute() {
    return "Are gradation timestamps absolute or relative to experiment start time? ";
  }
  get timeReference() {
    return this._timeReference;
  }
  set timeReference(value) {
    this._timeReference = value;
  }
  get ATTR_overflowHandling__DisplayName() {
    return "Overflow Handling";
  }
  get ATTR_overflowHandling__DescriptionAttribute() {
    return "What to do when new data are about to reach the graph right border";
  }
  get overflowHandling() {
    return this._overflowHandling;
  }
  set overflowHandling(value) {
    this._overflowHandling = value;
  }
  get ATTR_color__DisplayName() {
    return "Color";
  }
  get ATTR_color__DescriptionAttribute() {
    return "X Axis Color.";
  }
  get color() {
    return this._color;
  }
  set color(value) {
    this._color = value;
  }
  get ATTR_thickness__DisplayName() {
    return "Thickness";
  }
  get ATTR_thickness__DescriptionAttribute() {
    return "Axis thickness";
  }
  get thickness() {
    return this._thickness;
  }
  set thickness(value) {
    this._thickness = value;
  }
  get ATTR_showGrid__DisplayName() {
    return "Show Grid";
  }
  get ATTR_showGrid__DescriptionAttribute() {
    return "Show grid vertical lines, or not.";
  }
  get showGrid() {
    return this._showGrid;
  }
  set showGrid(value) {
    this._showGrid = value;
  }
  get ATTR_gridColor__DisplayName() {
    return "Grid Color";
  }
  get ATTR_gridColor__DescriptionAttribute() {
    return "Grid vertical lines color.";
  }
  get gridColor() {
    return this._gridColor;
  }
  set gridColor(value) {
    this._gridColor = value;
  }
  get ATTR_gridThickness__DisplayName() {
    return "Grid thickness";
  }
  get ATTR_gridThickness__DescriptionAttribute() {
    return "Grid vertical lines thickness";
  }
  get gridThickness() {
    return this._gridThickness;
  }
  set gridThickness(value) {
    this._gridThickness = value;
  }
  get ATTR_font__DisplayName() {
    return "Font";
  }
  get ATTR_font__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_font__DescriptionAttribute() {
    return "Axis font";
  }
  get font() {
    return this._font;
  }
  set font(value) {
    this._font = value;
  }
  get ATTR_legend__DisplayName() {
    return "Legend";
  }
  get ATTR_legend__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_legend__DescriptionAttribute() {
    return "X Axis legend";
  }
  get legend() {
    return this._legend;
  }
  set legend(value) {
    this._legend = value;
  }
  get ATTR_markers0__DisplayName() {
    return "Marker 1";
  }
  get ATTR_markers0__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_markers0__CategoryAttribute() {
    return "Markers";
  }
  get ATTR_markers0__DescriptionAttribute() {
    return "First marker parameters";
  }
  get markers0() {
    return this._markers0;
  }
  set markers0(value) {
    this._markers0 = value;
  }
  get ATTR_markers1__DisplayName() {
    return "Marker 2";
  }
  get ATTR_markers1__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_markers1__CategoryAttribute() {
    return "Markers";
  }
  get ATTR_markers1__DescriptionAttribute() {
    return "Second marker parameters";
  }
  get markers1() {
    return this._markers1;
  }
  set markers1(value) {
    this._markers1 = value;
  }
  get ATTR_markers2__DisplayName() {
    return "Marker 3";
  }
  get ATTR_markers2__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_markers2__CategoryAttribute() {
    return "Markers";
  }
  get ATTR_markers2__DescriptionAttribute() {
    return "Third marker parameters";
  }
  get markers2() {
    return this._markers2;
  }
  set markers2(value) {
    this._markers2 = value;
  }
  get ATTR_markers3__DisplayName() {
    return "Marker 4";
  }
  get ATTR_markers3__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_markers3__CategoryAttribute() {
    return "Markers";
  }
  get ATTR_markers3__DescriptionAttribute() {
    return "Fourth marker parameters";
  }
  get markers3() {
    return this._markers3;
  }
  set markers3(value) {
    this._markers3 = value;
  }
  get ATTR_markers4__DisplayName() {
    return "Marker 5";
  }
  get ATTR_markers4__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_markers4__CategoryAttribute() {
    return "Markers";
  }
  get ATTR_markers4__DescriptionAttribute() {
    return "Fith marker parameters";
  }
  get markers4() {
    return this._markers4;
  }
  set markers4(value) {
    this._markers4 = value;
  }
  get ATTR_markers5__DisplayName() {
    return "Marker 6";
  }
  get ATTR_markers5__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_markers5__CategoryAttribute() {
    return "Markers";
  }
  get ATTR_markers5__DescriptionAttribute() {
    return "Sixth marker parameters";
  }
  get markers5() {
    return this._markers5;
  }
  set markers5(value) {
    this._markers5 = value;
  }
  get ATTR_markers6__DisplayName() {
    return "Marker 7";
  }
  get ATTR_markers6__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_markers6__CategoryAttribute() {
    return "Markers";
  }
  get ATTR_markers6__DescriptionAttribute() {
    return "Seventh marker parameters";
  }
  get markers6() {
    return this._markers6;
  }
  set markers6(value) {
    this._markers6 = value;
  }
  get ATTR_markers7__DisplayName() {
    return "Marker 8";
  }
  get ATTR_markers7__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_markers7__CategoryAttribute() {
    return "Markers";
  }
  get ATTR_markers7__DescriptionAttribute() {
    return "Height marker parameters";
  }
  get markers7() {
    return this._markers7;
  }
  set markers7(value) {
    this._markers7 = value;
  }
};
var GraphFormProperties = class extends GenericProperties {
  constructor(initData, owner) {
    super(owner);
    this._Graph_series0 = new ChartSerie(YColor.Tomato);
    this._Graph_series1 = new ChartSerie(YColor.DodgerBlue);
    this._Graph_series2 = new ChartSerie(YColor.SeaGreen);
    this._Graph_series3 = new ChartSerie(YColor.Gold);
    this._Graph_showRecordedData = false;
    this._Graph_borderColor = YColor.LightGray;
    this._Graph_borderThickness = 1;
    this._Graph_bgColor1 = YColor.FromArgb(255, 220, 220, 220);
    this._Graph_bgColor2 = YColor.FromArgb(55, 240, 240, 240);
    this._Graph_resizeRule = Proportional.ResizeRule.FIXED;
    this._Graph_xAxis = new XaxisDescription();
    this._Graph_yAxes0 = new YaxisDescription(0, true);
    this._Graph_yAxes1 = new YaxisDescription(1, false);
    this._Graph_yAxes2 = new YaxisDescription(2, false);
    this._Graph_legendPanel = new LegendPanelDescription();
    this._Graph_dataTracker = new DataTrackerDescription();
    this._Graph_navigator = new NavigatorDescription();
    this._annotationPanels0 = new AnnotationPanelDescriptionGraph();
    this._annotationPanels1 = new AnnotationPanelDescriptionGraph();
    this.initFromXmlData(initData);
  }
  IsDataSourceAssigned() {
    let propList = Object.getOwnPropertyNames(this);
    propList.forEach((name) => {
      if (name.startsWith("Graphs_series")) {
        let s = this[name].GetValue(this, null);
        if (!(s.DataSource_source instanceof NullYSensor))
          return true;
      }
    });
    return false;
  }
  get ATTR_Graph_series0__DisplayName() {
    return "Series 1";
  }
  get ATTR_Graph_series0__CategoryAttribute() {
    return "Data Sources";
  }
  get ATTR_Graph_series0__PreExpandedCategoryAttribute() {
    return true;
  }
  get ATTR_Graph_series0__PreExpandedAttribute() {
    return true;
  }
  get ATTR_Graph_series0__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_Graph_series0__DescriptionAttribute() {
    return "First data series, expand for more.";
  }
  get Graph_series0() {
    return this._Graph_series0;
  }
  set Graph_series0(value) {
    this._Graph_series0 = value;
  }
  get ATTR_Graph_series1__DisplayName() {
    return "Series 2";
  }
  get ATTR_Graph_series1__CategoryAttribute() {
    return "Data Sources";
  }
  get ATTR_Graph_series1__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_Graph_series1__DescriptionAttribute() {
    return "Second data series, expand for more.";
  }
  get Graph_series1() {
    return this._Graph_series1;
  }
  set Graph_series1(value) {
    this._Graph_series1 = value;
  }
  get ATTR_Graph_series2__DisplayName() {
    return "Series 3";
  }
  get ATTR_Graph_series2__CategoryAttribute() {
    return "Data Sources";
  }
  get ATTR_Graph_series2__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_Graph_series2__DescriptionAttribute() {
    return "Third data series, expand for more.";
  }
  get Graph_series2() {
    return this._Graph_series2;
  }
  set Graph_series2(value) {
    this._Graph_series2 = value;
  }
  get ATTR_Graph_series3__DisplayName() {
    return "Series 4";
  }
  get ATTR_Graph_series3__CategoryAttribute() {
    return "Data Sources";
  }
  get ATTR_Graph_series3__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_Graph_series3__DescriptionAttribute() {
    return "Fourth data series, expand for more.";
  }
  get Graph_series3() {
    return this._Graph_series3;
  }
  set Graph_series3(value) {
    this._Graph_series3 = value;
  }
  get ATTR_Graph_showRecordedData__DisplayName() {
    return "Use datalogger data";
  }
  get ATTR_Graph_showRecordedData__CategoryAttribute() {
    return "Graph";
  }
  get ATTR_Graph_showRecordedData__CopyToTarget() {
    return false;
  }
  get ATTR_Graph_showRecordedData__DescriptionAttribute() {
    return "Makes the graph load the sensors datalogger contents. After disabling this feature, you may want to reset the dataview with the right-click context menu.";
  }
  get Graph_showRecordedData() {
    return this._Graph_showRecordedData;
  }
  set Graph_showRecordedData(value) {
    if (this._Graph_showRecordedData != value) {
      this._Graph_showRecordedData = value;
      if (this.ownerForm != null) {
        this._Graph_showRecordedData ? this.ownerForm.loadRecordedDataIfNeeded() : this.ownerForm.removeDataloggerData();
      }
    }
  }
  get ATTR_Graph_borderColor__DisplayName() {
    return "Border color";
  }
  get ATTR_Graph_borderColor__CategoryAttribute() {
    return "Graph";
  }
  get ATTR_Graph_borderColor__DescriptionAttribute() {
    return "Canvas borders color.";
  }
  get Graph_borderColor() {
    return this._Graph_borderColor;
  }
  set Graph_borderColor(value) {
    this._Graph_borderColor = value;
  }
  get ATTR_Graph_borderThickness__DisplayName() {
    return "Border thickness";
  }
  get ATTR_Graph_borderThickness__CategoryAttribute() {
    return "Graph";
  }
  get ATTR_Graph_borderThickness__DescriptionAttribute() {
    return "Canvas borders thickness.";
  }
  get Graph_borderThickness() {
    return this._Graph_borderThickness;
  }
  set Graph_borderThickness(value) {
    this._Graph_borderThickness = value;
  }
  get ATTR_Graph_bgColor1__DisplayName() {
    return "Background color 1";
  }
  get ATTR_Graph_bgColor1__CategoryAttribute() {
    return "Graph";
  }
  get ATTR_Graph_bgColor1__DescriptionAttribute() {
    return "Background gradient color 1.";
  }
  get Graph_bgColor1() {
    return this._Graph_bgColor1;
  }
  set Graph_bgColor1(value) {
    this._Graph_bgColor1 = value;
  }
  get ATTR_Graph_bgColor2__DisplayName() {
    return "Background color 2";
  }
  get ATTR_Graph_bgColor2__CategoryAttribute() {
    return "Graph";
  }
  get ATTR_Graph_bgColor2__DescriptionAttribute() {
    return "Background gradient color 2.";
  }
  get Graph_bgColor2() {
    return this._Graph_bgColor2;
  }
  set Graph_bgColor2(value) {
    this._Graph_bgColor2 = value;
  }
  get ATTR_Graph_resizeRule__DisplayName() {
    return "Font sizes";
  }
  get ATTR_Graph_resizeRule__CategoryAttribute() {
    return "Graph";
  }
  get ATTR_Graph_resizeRule__DescriptionAttribute() {
    return "Are font sizes fixed or do they change when window is resized?";
  }
  get Graph_resizeRule() {
    return this._Graph_resizeRule;
  }
  set Graph_resizeRule(value) {
    this._Graph_resizeRule = value;
  }
  get ATTR_Graph_xAxis__DisplayName() {
    return "X Axis";
  }
  get ATTR_Graph_xAxis__CategoryAttribute() {
    return "X/Y Axes";
  }
  get ATTR_Graph_xAxis__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_Graph_xAxis__DescriptionAttribute() {
    return "X-Axis, expand for more";
  }
  get Graph_xAxis() {
    return this._Graph_xAxis;
  }
  set Graph_xAxis(value) {
    this._Graph_xAxis = value;
  }
  get ATTR_Graph_yAxes0__DisplayName() {
    return "YAxis 1";
  }
  get ATTR_Graph_yAxes0__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_Graph_yAxes0__CategoryAttribute() {
    return "X/Y Axes";
  }
  get ATTR_Graph_yAxes0__DescriptionAttribute() {
    return "First Y Axis, expand for more.";
  }
  get Graph_yAxes0() {
    return this._Graph_yAxes0;
  }
  set Graph_yAxes0(value) {
    this._Graph_yAxes0 = value;
  }
  get ATTR_Graph_yAxes1__DisplayName() {
    return "YAxis 2";
  }
  get ATTR_Graph_yAxes1__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_Graph_yAxes1__CategoryAttribute() {
    return "X/Y Axes";
  }
  get ATTR_Graph_yAxes1__DescriptionAttribute() {
    return "Second Y Axis, expand for more.";
  }
  get Graph_yAxes1() {
    return this._Graph_yAxes1;
  }
  set Graph_yAxes1(value) {
    this._Graph_yAxes1 = value;
  }
  get ATTR_Graph_yAxes2__DisplayName() {
    return "YAxis 3";
  }
  get ATTR_Graph_yAxes2__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_Graph_yAxes2__CategoryAttribute() {
    return "X/Y Axes";
  }
  get ATTR_Graph_yAxes2__DescriptionAttribute() {
    return "Third Y Axis, expand for more.";
  }
  get Graph_yAxes2() {
    return this._Graph_yAxes2;
  }
  set Graph_yAxes2(value) {
    this._Graph_yAxes2 = value;
  }
  get ATTR_Graph_legendPanel__DisplayName() {
    return "Legend Panel";
  }
  get ATTR_Graph_legendPanel__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_Graph_legendPanel__CategoryAttribute() {
    return "Graph";
  }
  get ATTR_Graph_legendPanel__DescriptionAttribute() {
    return "Panel containing a description of all data series. Expand for more.";
  }
  get Graph_legendPanel() {
    return this._Graph_legendPanel;
  }
  set Graph_legendPanel(value) {
    this._Graph_legendPanel = value;
  }
  get ATTR_Graph_dataTracker__DisplayName() {
    return "Data tracker";
  }
  get ATTR_Graph_dataTracker__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_Graph_dataTracker__CategoryAttribute() {
    return "Graph";
  }
  get ATTR_Graph_dataTracker__DescriptionAttribute() {
    return "Show dynamic value labels while the mouse is moving over the graph. Expand for more.";
  }
  get Graph_dataTracker() {
    return this._Graph_dataTracker;
  }
  set Graph_dataTracker(value) {
    this._Graph_dataTracker = value;
  }
  get ATTR_Graph_navigator__DisplayName() {
    return "Navigator";
  }
  get ATTR_Graph_navigator__CategoryAttribute() {
    return "Graph";
  }
  get ATTR_Graph_navigator__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_Graph_navigator__DescriptionAttribute() {
    return "Small additional graph showing the whole data set and allowing to quickly navigate among data. Expand for more.";
  }
  get Graph_navigator() {
    return this._Graph_navigator;
  }
  set Graph_navigator(value) {
    this._Graph_navigator = value;
  }
  get ATTR_Graph_annotationPanels0__DisplayName() {
    return "Annotation 1";
  }
  get ATTR_Graph_annotationPanels0__CategoryAttribute() {
    return "Annotations";
  }
  get ATTR_Graph_annotationPanels0__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_Graph_annotationPanels0__DescriptionAttribute() {
    return "Customizable text panel 1";
  }
  get Graph_annotationPanels0() {
    return this._annotationPanels0;
  }
  set Graph_annotationPanels0(value) {
    this._annotationPanels0 = value;
  }
  get ATTR_Graph_annotationPanels1__DisplayName() {
    return "Annotation 2";
  }
  get ATTR_Graph_annotationPanels1__CategoryAttribute() {
    return "Annotations";
  }
  get ATTR_Graph_annotationPanels1__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_Graph_annotationPanels1__DescriptionAttribute() {
    return "Customizable text panel 2";
  }
  get Graph_annotationPanels1() {
    return this._annotationPanels1;
  }
  set Graph_annotationPanels1(value) {
    this._annotationPanels1 = value;
  }
};

// obj/full/contextMenu.js
var ContextMenuSeparator = class {
  constructor() {
    this.TR = document.createElement("TR");
    this.TR["objectData"] = this;
    this.TR.className = ContextMenu.SEPARATOR_MARKER;
    this.TD_caption = document.createElement("TD");
    this.TD_caption.style.backgroundColor = ContextMenu.iconBGColor;
    this.TD_caption.style.paddingLeft = "3px";
    this.TD_caption.style.paddingRight = "3px";
    let hr = document.createElement("HR");
    this.TD_caption.colSpan = 2;
    this.TD_caption.appendChild(hr);
    this.TD_icon = document.createElement("TD");
    this.TD_icon.style.backgroundColor = ContextMenu.captionBgColor;
    this.TR.appendChild(this.TD_icon);
    this.TR.appendChild(this.TD_caption);
  }
  toString() {
    return "Separator";
  }
  get focusable() {
    return false;
  }
  parentMenuisClosing() {
  }
  get domData() {
    return this.TR;
  }
};
var ContextMenuItemBase = class {
  get userdata() {
    return this._userdata;
  }
  set userdata(value) {
    this._userdata = value;
  }
  constructor(menu, icon, caption) {
    this._clickHidesMenu = true;
    this._userdata = null;
    this._menu = menu;
    this.TR = document.createElement("TR");
    this.TR["objectData"] = this;
    this.TD_caption = document.createElement("TD");
    this.TD_caption.style.backgroundColor = ContextMenu.iconBGColor;
    this.TD_caption.style.paddingLeft = "3px";
    this.TD_caption.style.paddingRight = "3px";
    this.TD_caption.style.whiteSpace = "nowrap";
    this.TD_icon = document.createElement("TD");
    if (icon != null)
      this.TD_icon.innerHTML = icon;
    this.TD_icon.style.backgroundColor = ContextMenu.captionBgColor;
    this.A_caption = document.createElement("A");
    this.A_caption.innerHTML = caption;
    this.TR.style.cursor = "pointer";
    this.TR.tabIndex = 0;
    this.TR.style.outline = "none";
    this._TR_keydown = (e) => {
      e.preventDefault();
      this.keydown(e);
    };
    this._TR_mouseover = (e) => {
      this.mouserOver(e);
    };
    this._TR_mouseout = (e) => {
      this.mouserOut(e);
    };
    this._A_mouseover = (e) => {
      this.mouserOver(e);
    };
    this._A_mouseout = (e) => {
      this.mouserOut(e);
    };
    this._A_click = (e) => {
      this.activate();
    };
    this._TR_focusin = () => {
      this.focusIn();
    };
    this._TR_focusout = () => {
      this.focusOut();
    };
    this.TR.addEventListener("mouseover", this._TR_mouseover);
    this.TR.addEventListener("mouseout", this._TR_mouseout);
    this.TR.addEventListener("click", this._A_click);
    this.TR.addEventListener("keydown", this._TR_keydown);
    this.A_caption.addEventListener("mouseover", this._A_mouseover);
    this.A_caption.addEventListener("mouseout", this._A_mouseout);
    this.TD_caption.appendChild(this.A_caption);
    this.TR.appendChild(this.TD_icon);
    this.TR.appendChild(this.TD_caption);
    this.TR.addEventListener("focusin", this._TR_focusin);
    this.TR.addEventListener("focusout", this._TR_focusout);
  }
  toString() {
    return this.TD_caption.innerText;
  }
  get focusable() {
    return this.visible;
  }
  activate() {
  }
  focus() {
    this.TR.focus();
    this._menu.closeSubmenus();
  }
  focusIn() {
    if (this.TD_caption.style.backgroundColor == ContextMenu.iconBGColor)
      this._menu.closeSubmenus();
    this.TD_caption.style.backgroundColor = ContextMenu.ActiveColor;
    this.TD_icon.style.backgroundColor = ContextMenu.ActiveColor;
  }
  focusOut() {
    this.TD_caption.style.backgroundColor = ContextMenu.iconBGColor;
    this.TD_icon.style.backgroundColor = ContextMenu.captionBgColor;
  }
  removeAndDestroy() {
    if (this.TR.parentNode != null)
      this.TR.parentNode.removeChild(this.TR);
    this.TR.removeEventListener("keydown", this._TR_keydown);
    this.TR.removeEventListener("mouseover", this._TR_mouseover);
    this.TR.removeEventListener("mouseout", this._TR_mouseout);
    this.A_caption.removeEventListener("mouseover", this._A_mouseover);
    this.A_caption.removeEventListener("mouseout", this._A_mouseout);
    this.A_caption.removeEventListener("click", this._A_click);
    this.TR.removeEventListener("focusin", this._TR_focusin);
    this.TR.removeEventListener("focusout", this._TR_focusout);
  }
  set caption(value) {
    this.A_caption.innerHTML = value;
  }
  get caption() {
    return this.A_caption.innerHTML;
  }
  keydown(e) {
    if (e.code == "ArrowDown")
      this._menu.activateNext(this);
    if (e.code == "ArrowUp")
      this._menu.activatePrevious(this);
    if (e.code == "Enter")
      this.activate();
    if (e.code == "Escape") {
      this._menu.close();
      if (this._menu.parentMenuItem != null)
        this._menu.parentMenuItem.focus();
    }
    if (e.code == "ArrowLeft") {
      if (this._menu.parentMenuItem != null) {
        this._menu.close();
        this._menu.parentMenuItem.focus();
      }
    }
  }
  mouserOver(e) {
    this.TD_caption.style.backgroundColor = ContextMenu.ActiveColor;
    this.TD_icon.style.backgroundColor = ContextMenu.ActiveColor;
    this._menu.closeSubmenus();
  }
  mouserOut(e) {
    this.TD_caption.style.backgroundColor = ContextMenu.iconBGColor;
    this.TD_icon.style.backgroundColor = ContextMenu.captionBgColor;
  }
  get domData() {
    return this.TR;
  }
  get visible() {
    return this.TR.style.display != "none";
  }
  set visible(value) {
    this.TR.style.display = value ? "" : "none";
  }
  parentMenuisClosing() {
  }
  closeMenu(all) {
    if (all)
      this._menu.closeAll();
    else
      this._menu.close();
  }
};
var ContextMenuItem = class extends ContextMenuItemBase {
  activate() {
    if (this._clickHidesMenu)
      this.closeMenu(true);
    if (this._callback != null)
      this._callback();
  }
  constructor(menu, icon, caption, callback) {
    super(menu, icon, caption);
    this._callback = callback;
    this.TD_caption.colSpan = 2;
  }
};
var ContextMenuItemSubMenuEntry = class extends ContextMenuItem {
  constructor(menu, icon, caption, submenu) {
    super(menu, icon, caption, null);
    this.TD_caption.colSpan = 1;
    this._submenu = submenu;
    this._submenu.parentMenuItem = this;
    this._parentmenu = menu;
    this._clickHidesMenu = false;
    this.TD_arrow = document.createElement("TD");
    this.TD_arrow.style.backgroundColor = ContextMenu.iconBGColor;
    this.TD_arrow.style.textAlign = "right";
    this.TD_arrow.style.paddingRight = "3px";
    this.TD_arrow.innerHTML = "&#9654;";
    this.TR.appendChild(this.TD_arrow);
    this.A_caption.addEventListener("click", (e) => {
      this.showSubmenu();
    });
    this.A_caption.addEventListener("touchstart", (e) => {
      if (e.touches.length == 1)
        this.activate();
    });
    this._submenu.zIndex = this._parentmenu.zIndex + 1;
  }
  keydown(e) {
    super.keydown(e);
    if (e.code == "ArrowRight") {
      this.activate();
      this._submenu.focusFirst();
    }
  }
  removeAndDestroy() {
    this._submenu.close();
    this._submenu.destroy();
    super.removeAndDestroy();
  }
  activate() {
    this.showSubmenu();
  }
  get submenu() {
    return this._submenu;
  }
  showSubmenu() {
    this._submenu.zIndex = this._parentmenu.zIndex + 1;
    let x = 0;
    let y = 0;
    let it = this.TR;
    do {
      x += it.offsetLeft || 0;
      y += it.offsetTop || 0;
      it = it.offsetParent;
    } while (it);
    this._submenu.showContextMenu(x + this._parentmenu.width - 15, y + 5);
  }
  focusIn() {
    super.focusIn();
    this.TD_arrow.style.backgroundColor = ContextMenu.ActiveColor;
  }
  focusOut() {
    super.focusOut();
    this.TD_arrow.style.backgroundColor = ContextMenu.iconBGColor;
  }
  parentMenuisClosing() {
    this._submenu.close();
  }
  mouserOver(e) {
    this.focusIn();
    this._parentmenu.setDelayedAction(() => {
      if (this.visible)
        this.showSubmenu();
    });
  }
  mouserOut(e) {
    this._parentmenu.cancelDelayedAction();
    this.focusOut();
  }
};
var ContextMenuBase = class {
  get parentMenuItem() {
    return this._parentMenuItem;
  }
  set parentMenuItem(value) {
    this._parentMenuItem = value;
  }
  get userdata() {
    return this._userdata;
  }
  set userdata(value) {
    this._userdata = value;
  }
  constructor(baseSize, openCallback, fontFamily) {
    this._visible = false;
    this._zIndex = 100002;
    this._parentmenu = null;
    this._parentMenuItem = null;
    this._userdata = null;
    this._openCallback = openCallback;
    this.Menutable = document.createElement("TABLE");
    this.Menutable.style.position = "absolute";
    this.Menutable.style.border = "1px solid #808080";
    if (typeof fontFamily !== "undefined")
      this.Menutable.style.fontFamily = fontFamily;
    this.Menutable.style.fontSize = (2 * baseSize / 3).toFixed(1) + "px";
    this.Menutable.style.borderSpacing = "0";
    this.Menutable.style.boxShadow = " 4px 4px 4px 1px rgba(0,0,0,0.05)";
    this.Menutable.style.zIndex = this._zIndex.toString();
    this._timer = null;
    this.visible = false;
  }
  closeAll() {
    this.close();
    if (this._parentmenu != null)
      this._parentmenu.closeAll();
  }
  cancelDelayedAction() {
    if (this._timer != null) {
      clearTimeout(this._timer);
      this._timer = null;
    }
  }
  setDelayedAction(action) {
    this.cancelDelayedAction();
    this._timer = setTimeout(() => {
      action();
    }, 500);
  }
  get parentMenu() {
    return this._parentmenu;
  }
  destroy() {
    for (let i = 0; i < this.Menutable.childNodes.length; i++) {
      let item = this.Menutable.childNodes[i]["objectData"];
      item.removeAndDestroy();
    }
    if (this.Menutable.parentNode != null)
      this.Menutable.parentNode.removeChild(this.Menutable);
  }
  focusFirst() {
    for (let i = 0; i < this.Menutable.childNodes.length; i++) {
      let item = this.Menutable.childNodes[i]["objectData"];
      if (item.focusable) {
        item.focus();
        return;
      }
    }
  }
  toString() {
    let res = "";
    for (let i = 0; i < this.Menutable.childNodes.length; i++) {
      let item = this.Menutable.childNodes[i]["objectData"];
      res = res + item.caption + "";
    }
    return res;
  }
  isXYOnMenu(x, y) {
    if (!this.visible)
      return false;
    if (x >= this.Menutable.offsetLeft && x <= this.Menutable.offsetLeft + this.Menutable.offsetWidth && y >= this.Menutable.offsetTop && y <= this.Menutable.offsetTop + this.Menutable.offsetHeight) {
      return true;
    }
    for (let i = 0; i < this.Menutable.childNodes.length; i++) {
      let item = this.Menutable.childNodes[i]["objectData"];
      if (item instanceof ContextMenuItemSubMenuEntry) {
        if (item.submenu.isXYOnMenu(x, y))
          return true;
      }
    }
    return false;
  }
  activateNext(source) {
    let found = false;
    for (let i = 0; i < this.Menutable.childNodes.length; i++) {
      let item = this.Menutable.childNodes[i]["objectData"];
      if (item == source) {
        found = true;
      } else if (found && item.focusable) {
        item.focus();
        return;
      }
    }
  }
  activatePrevious(source) {
    let previous = null;
    for (let i = 0; i < this.Menutable.childNodes.length; i++) {
      let item = this.Menutable.childNodes[i]["objectData"];
      if (item == source) {
        if (previous != null)
          previous.focus();
        return;
      }
      if (item.focusable)
        previous = item;
    }
  }
  get width() {
    return this.Menutable.offsetWidth;
  }
  closeSubmenus() {
    this.closeSubMenusExcept(null);
  }
  get zIndex() {
    return this._zIndex;
  }
  set zIndex(value) {
    this._zIndex = value;
    this.Menutable.style.zIndex = this._zIndex.toString();
  }
  get visible() {
    return this.Menutable.style.display != "none";
  }
  set visible(value) {
    this.Menutable.style.display = value ? "" : "none";
  }
  close() {
    this.cancelDelayedAction();
    for (let i = 0; i < this.Menutable.childNodes.length; i++) {
      let item = this.Menutable.childNodes[i]["objectData"];
      item.parentMenuisClosing();
    }
    this.visible = false;
    this.closeSubmenus();
  }
  refresh() {
    let showSeparation = false;
    for (let i = 0; i < this.Menutable.childNodes.length; i++) {
      let element = this.Menutable.childNodes[i];
      if (element.className == ContextMenu.SEPARATOR_MARKER) {
        element.style.display = showSeparation ? "" : "none";
        showSeparation = false;
      } else if (element.style.display == "")
        showSeparation = true;
    }
  }
  addMenuItem(icon, caption, callback) {
    let menuItem = new ContextMenuItem(this, icon, caption, callback);
    this.Menutable.appendChild(menuItem.domData);
    return menuItem;
  }
  get menuItemsCount() {
    return this.Menutable.childNodes.length;
  }
  closeSubMenusExcept(doNotClose) {
    for (let i = 0; i < this.Menutable.childNodes.length; i++) {
      let item = this.Menutable.childNodes[i]["objectData"];
      if (item instanceof ContextMenuItemSubMenuEntry) {
        if (item.submenu != doNotClose) {
          item.submenu.close();
        }
      }
    }
  }
  subMenuisOpening(source) {
    this.closeSubMenusExcept(source);
  }
  addSubMenuItem(icon, caption, submenu) {
    submenu.zIndex = this.zIndex + 1;
    let menuItem = new ContextMenuItemSubMenuEntry(this, icon, caption, submenu);
    this.Menutable.appendChild(menuItem.domData);
    return menuItem;
  }
  clearAllContents() {
    while (this.Menutable.childNodes.length > 0) {
      let item = this.Menutable.childNodes[0]["objectData"];
      item.removeAndDestroy();
    }
  }
  AddSeparator() {
    let separator = new ContextMenuSeparator();
    this.Menutable.appendChild(separator.domData);
    return separator;
  }
  showContextMenu(x, y) {
  }
};
ContextMenuBase.SEPARATOR_MARKER = "separator";
ContextMenuBase.iconBGColor = "#fdfdfd";
ContextMenuBase.captionBgColor = "#f1f1f1";
ContextMenuBase.ActiveColor = "#c4e1ff";
var ContextSubMenu = class extends ContextMenuBase {
  constructor(baseSize, parentMenu, openCallback, fontFamily) {
    super(baseSize, openCallback, fontFamily);
    this._parentmenu = parentMenu;
    document.body.appendChild(this.Menutable);
  }
  showContextMenu(x, y) {
    if (this._parentmenu != null)
      this._parentmenu.subMenuisOpening(this);
    if (this._openCallback != null)
      this._openCallback(x, y);
    this.Menutable.style.left = x.toString() + "px";
    this.Menutable.style.top = y.toString() + "px";
    this.visible = true;
    let right = this.Menutable.offsetLeft - this.Menutable.scrollLeft + this.Menutable.offsetWidth;
    let bottom = this.Menutable.offsetTop - this.Menutable.scrollTop + this.Menutable.offsetHeight;
    if (right > window.innerWidth)
      this.Menutable.style.left = (x - (right - window.innerWidth)).toString() + "px";
    if (bottom > window.innerHeight)
      this.Menutable.style.top = (y - (bottom - window.innerHeight)).toString() + "px";
  }
};
var ContextMenu = class extends ContextMenuBase {
  constructor(baseSize, openCallback, fontFamily) {
    super(baseSize, openCallback, fontFamily);
    document.addEventListener("contextmenu", (e) => {
      let tagname = "";
      if (e.target != null && constants.RunningOnAndroid)
        tagname = e.target.tagName;
      if (tagname != "INPUT") {
        e.preventDefault();
        this.showContextMenu(e.pageX, e.pageY);
      }
    });
    document.addEventListener("dblclick", (e) => {
      if (constants.dbleClickBringsUpContextMenu)
        this.showContextMenu(e.pageX, e.pageY);
    });
    document.addEventListener("click", (e) => {
      this.click(e);
    });
    document.body.appendChild(this.Menutable);
  }
  click(e) {
    if (!this.visible)
      return;
    if (!this.isXYOnMenu(e.pageX, e.pageY)) {
      this.close();
    }
  }
  showContextMenu(x, y) {
    let z = YWindow.ConTextMenuBestZindex;
    if (z < 0)
      return;
    this.zIndex = z;
    this.Menutable.style.left = x.toString() + "px";
    this.Menutable.style.top = y.toString() + "px";
    this.visible = true;
    let right = this.Menutable.offsetLeft - this.Menutable.scrollLeft + this.Menutable.offsetWidth;
    let bottom = this.Menutable.offsetTop - this.Menutable.scrollTop + this.Menutable.offsetHeight;
    if (right > window.innerWidth)
      this.Menutable.style.left = Math.max(0, x - (right - window.innerWidth)).toString() + "px";
    if (bottom > window.innerHeight)
      this.Menutable.style.top = Math.max(0, y - (bottom - window.innerHeight)).toString() + "px";
    if (this._openCallback != null)
      this._openCallback(x, y);
    if (x <= 5 && y <= 5)
      this.focusFirst();
  }
};

// obj/full/ressources.js
var ressources = class {
  static SVGheader(size, shadowDef, title) {
    let res = '<svg  xmlns="http://www.w3.org/2000/svg" width="' + size + '" height="' + size + '" viewBox="0 0 128  128">';
    if (typeof title != "undefined")
      res = res + "<title>" + title + "</title>";
    if (shadowDef)
      res = res + '<defs><filter id="f1" x="0" y="0"><feGaussianBlur in="SourceGraphic" stdDeviation="2" /></filter></defs>';
    res = res + '<g transform="translate(0,128)"><g transform="scale(1,-1)">';
    return res;
  }
  static SVGFooter() {
    return "</g></g></svg>";
  }
  static addIconTransparency() {
    return '<g opacity="0.5">';
  }
  static addIconSrcCode() {
    return '<path d="m 8 24 L 8 40 L 24 40 L 24 56 L 40 56 L 40 40 L 56 40 L 56 24 L 40 24 L 40 8 L 24 8 L 24 24   Z" fill="#40ff40" stroke="black" stroke-width="8" stroke-linecap="round"/>';
  }
  static deleteIconSrcCode() {
    return '<path d="m 15 4 L 4 15 L 19 29 L 4 43 L 15 55 L 29 40 L 43 55 L 55 43 L 40 29 L 55 15 L 44 4 L 29 18 Z" fill="#ff4040" stroke="black" stroke-width="8" stroke-linecap="round">';
  }
  static IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, shadowcode, activeCode, title) {
    let res = ressources.SVGheader(size, shadow, title);
    if (shadow)
      res = res + '<g transform="translate(6,-6)">' + shadowcode + "</g>";
    if (semitransparent)
      res = res + ressources.addIconTransparency();
    res = res + activeCode;
    if (semitransparent)
      res = res + "</g>";
    if (addIcon)
      res = res + ressources.addIconSrcCode();
    if (deleteIcon)
      res = res + ressources.deleteIconSrcCode();
    res = res + ressources.SVGFooter();
    return res;
  }
  static GraphIcon(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="m 12 24 L 103 24 L 103 107 L 12 107 z" fill="lightgray" filter="url(#f1)" /><path d="m 112 24 L 12 24 L 12 113"  style="fill:none; stroke:lightgray; stroke-width:4px; stroke-linejoin:round;stroke-linecap:round;" filter="url(#f1)"/>', '<path d="m 12 24 L 103 24 L 103 107 L 12 107 z" fill="#ffffe9" /><line x1="43" y1="24" x2="43" y2="107" stroke="#e3e3e3" stroke-width="2" stroke-linecap="round" /><line x1="43" y1="24" x2="43" y2="107" stroke="#e3e3e3" stroke-width="2" stroke-linecap="round" /><line x1="73" y1="24" x2="73" y2="107" stroke="#e3e3e3" stroke-width="2" stroke-linecap="round" /><line x1="12" y1="51" x2="103" y2="51" stroke="#e3e3e3" stroke-width="2" stroke-linecap="round" /><line x1="12" y1="79" x2="103" y2="79" stroke="#e3e3e3" stroke-width="2" stroke-linecap="round" /><line x1="12" y1="107" x2="103" y2="107" stroke="#e3e3e3" stroke-width="2" stroke-linecap="round" /><path d="m 12 77 L 34 65 L 55 85 L 70 77 L 100 93" fill="none" stroke="#FF0000" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" /><line x1="103" y1="24" x2="103" y2="107" stroke="#e3e3e3" stroke-width="2" stroke-linecap="round" /><path d="m 112 24 L 12 24 L 12 113"  style="fill:none; stroke:black; stroke-width:4px; stroke-linejoin:round;stroke-linecap:round;"/>');
  }
  static SolidGaugeIcon(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="M 34 40 L 14 40 14 52 A 50 50 0 0 0 114 52 L  114 40 L 94 40 L 94 52 A 30 30 0 1 1  34 52 Z" style="fill:lightgray;fill-opacity=0.4;" filter="url(#f1)"/><text x="43" y="-30" fill="black" transform="scale(1,-1)" style="font: bold 24px sans-serif;fill:lightgray;fill-opacity=0.4;" filter="url(#f1)">123</text>', '<path d="M 34 40 L 14 40 14 52 A 50 50 0 0 0 114 52 L  114 40 L 94 40 L 94 52 A 30 30 0 1 1  34 52 Z" style="fill:#ffffe9; stroke:none; "/><path d="M 34 40 L 14 40 14 52 A 50 50 0 0 0 29 88 L  43 72.5   A 30 30 0 0 1  34 52 Z" style="fill:red; stroke:none;"/><path d="M 34 40 L 14 40 14 52 A 50 50 0 0 0 114 52 L  114 40 L 94 40 L 94 52 A 30 30 0 1 1  34 52 Z" style="fill:none; stroke:black; stroke-width:4px; stroke-linejoin:round;stroke-linecap:round;"/><text x="43" y="-30" fill="black" transform="scale(1,-1)" style="font: bold 24px sans-serif;">123</text>');
  }
  static RawDataIcon(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="m 16 27 L 107 27 L 107 107 L 16 107 z" fill="lightgray" filter="url(#f1)" />', '<path d="m 16 27 L 107 27 L 107 107 L 16 107 z" style="fill:#ffffe9;" /><line x1="47" y1="27" x2="47" y2="107" stroke="#e3e3e3" stroke-width="2"  /><line x1="76" y1="27" x2="76" y2="107" stroke="#e3e3e3" stroke-width="2"  /><line x1="16" y1="44" x2="107" y2="44" stroke="#e3e3e3" stroke-width="2"  /><line x1="16" y1="60" x2="107" y2="60" stroke="#e3e3e3" stroke-width="2"  /><line x1="16" y1="76" x2="107" y2="76" stroke="#e3e3e3" stroke-width="2"  /><path d="m 16 27 L 107 27 L 107 107 L 16 107 z" style="fill:none;stroke:black; stroke-width:4px; stroke-linejoin:round;" /><path d="m 19 91 L 104 91 L 104 104 L 19 104 z" style="fill:#b2b2b2; stroke:#6f6f6f; stroke-width:4px; stroke-linejoin:round;" /><line x1="47" y1="91" x2="47" y2="104" stroke="#6f6f6f" stroke-width="2"  /><line x1="76" y1="91" x2="76" y2="104" stroke="#6f6f6f" stroke-width="2"  />');
  }
  static ConfigureIcon(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="M85 85 L 102 80 L 113 91 A  41 100 45 0 0  86 71 L 37 21 A  5 11 45 1 0  21 37 L 71 86  A  41 100 45 0 0  91 113 L 80 102 Z" style="fill:lightgray;fill-opacity=0.4;" filter="url(#f1)"/>', '<path d="M85 85 L 102 80 L 113 91 A  41 100 45 0 0  86 71 L 37 21 A  5 11 45 1 0  21 37 L 71 86  A  41 100 45 0 0  91 113 L 80 102 Z" style="fill:grey; stroke:black; stroke-width:4px; stroke-linejoin:round;stroke-linecap:round;"/>');
  }
  static DigitalDisplayIcon(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="m 12 45 L 111 45 L 111 89 L 12 89 z" fill="lightgray" filter="url(#f1)" />', '<path d="m 12 45 L 111 45 L 111 89 L 12 89 z" style="fill:#ffffe9; stroke:black; stroke-width:4px; stroke-linejoin:round;" /><text x="29" y="-52" fill="black" transform="scale(1,-1)" style="font: bold 40px sans-serif;">123</text> ');
  }
  static AngularGaugeIcon(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<circle  cx="64" cy="64" r="40" fill="lightgray" filter="url(#f1)" />', '<circle  cx="64" cy="64" r="40" stroke="black" stroke-width="4" fill="#ffffe9" /><line x1="64" y1="104" x2="64" y2="94" stroke="black" stroke-width="2"   stroke-linecap="round" /><line x1="29" y1="84" x2="38" y2="79" stroke="black" stroke-width="2"   stroke-linecap="round" /><line x1="29" y1="44" x2="38" y2="48" stroke="black" stroke-width="2"   stroke-linecap="round" /><line x1="98" y1="84" x2="91" y2="79" stroke="black" stroke-width="2"   stroke-linecap="round" /><line x1="98" y1="44" x2="91" y2="48" stroke="black" stroke-width="2"   stroke-linecap="round" /><g transform="translate(64,64)"><g transform="rotate(-70,0,0)"><path d="m 5 0 L 0 5 L -25 0 L 0 -5 z" style="fill:black;stroke:black; stroke-width:2px; stroke-linejoin:round;"/></g></g>');
  }
  static EditIcon(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="m 16 48 L 108 48 L 108 88 L 16 88 z" fill="lightgray" filter="url(#f1)" /><path d="m 87 24 L 75 40 L 67 31 L 62 64 L 93 50 L 82 44  L 94 29 z" fill="lightgray" filter="url(#f1)" />', '<path d="m 16 48 L 108 48 L 108 88 L 16 88 z" style="fill:#ffffe9; stroke:black; stroke-width:4px; stroke-linejoin:round;" /><path d="m 87 24 L 75 40 L 67 31 L 62 64 L 93 50 L 82 44  L 94 29 z" style="fill:white; stroke:black; stroke-width:2px; stroke-linejoin:round;" /> ');
  }
  static AllIcon(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="m 60 108 L 46 74 L 8 72 L 38 48 L 28 12 L 60 32 L 92 12  L 82 48 L 112 70  L 74 74  z" fill="lightgray" filter="url(#f1)" />', '<path d="m 60 108 L 46 74 L 8 72 L 38 48 L 28 12 L 60 32 L 92 12  L 82 48 L 112 70  L 74 74  z" style="fill:#fee403; stroke:#918201; stroke-width:4px; stroke-linejoin:round;" />');
  }
  static TrashIcon(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="m 33 12 L 24 94 L 104 94 L 95 12 z" fill="lightgray" filter="url(#f1)" /><g transform="translate(70,105)"><g transform="rotate(-10,0,0)"><path d="m -40 0 L -30 5 L 30 5 L 40 0 z" fill="lightgray" filter="url(#f1)" /><path d="m -9 5 L -9 12 L 9 12 L 9 5" stroke="lightgray" filter="url(#f1)"/> </g></g>', '<path d="m 33 12 L 24 94 L 104 94 L 95 12 z" style="fill:#f8f8f8; stroke:black; stroke-width:4px; stroke-linejoin:round;" /><Line x1="43" y1="82" x2="48" y2="21" style=" stroke:black; stroke-width:4px; stroke-linecap:round;" /><Line x1="64" y1="82" x2="64" y2="21" style=" stroke:black; stroke-width:4px; stroke-linecap:round;" /><Line x1="86" y1="82" x2="80" y2="21" style=" stroke:black; stroke-width:4px; stroke-linecap:round;" /><g transform="translate(70,105)"><g transform="rotate(-10,0,0)"><path d="m -40 0 L -30 5 L 30 5 L 40 0 z" style="fill:#f8f8f8; stroke:black; stroke-width:4px; stroke-linejoin:round;" /><path d="m -9 5 L -9 12 L 9 12 L 9 5" style="fill:none; stroke:black; stroke-width:4px; stroke-linejoin:round;" /></g></g>');
  }
  static SaveIcon(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="m 20 12 A 4 4 0 0 0 16 16 L 16 106  A 4 4 0 0 0 20 110 L 24 110 L 24 108 L 97 108 L 97 110 L 104 110  A 4 4 0 0 0 108 106 L 108 16   A 4 4 0 0 0 104 12  z" fill="lightgray" filter="url(#f1)" />', '<path d="m 20 12 A 4 4 0 0 0 16 16 L 16 106  A 4 4 0 0 0 20 110 L 24 110 L 24 108 L 97 108 L 97 110 L 104 110  A 4 4 0 0 0 108 106 L 108 16   A 4 4 0 0 0 104 12  z" style="fill:#3583dd; stroke:#226fc8; stroke-width:4px; stroke-linejoin:round;" /><path d="m 24 11 L 24 65  A 5 5 0 0 0 29 70 L 95 70  A 5 5 0 0 0 100 65 L 100 11  z" style="fill:#f7f7f7; stroke:#c6c6c6; stroke-width:2px; stroke-linejoin:round;"/><path d="m 36 111 L 90 111 L 90 80 A 4 4 0 0 0 86 76 L 40 76 A 4 4 0 0 0 36 80 z"  style="fill:#e5e5e5; stroke:#c6c6c6; stroke-width:2px; stroke-linejoin:round;" /><rect x="67" y="79" width="14" height ="28"     style="fill:#3583dd; stroke:#c6c6c6; stroke-width:2px; stroke-linejoin:round;"');
  }
  static SaveNeededIcon(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="m 8 16 L 64 110 L 120 16 z " style="fill:lightgray; stroke:lightgray; stroke-width:10px; stroke-linejoin:round;filter:url(#f1)" />', '<path d="m 8 16 L 64 110 L 120 16 z" style="fill:#FAE701; stroke:#FAE701; stroke-width:10px; stroke-linejoin:round;" /><path d="m 8 16 L 64 110 L 120 16 z" style="fill:none; stroke:black; stroke-width:2px; stroke-linejoin:round;" /><g transform="translate(-64,-64) scale(0.4 0.4) translate(260,215)"><path d="m 20 12 A 4 4 0 0 0 16 16 L 16 106  A 4 4 0 0 0 20 110 L 24 110 L 24 108 L 97 108 L 97 110 L 104 110  A 4 4 0 0 0 108 106 L 108 16   A 4 4 0 0 0 104 12  z" style="fill:black; stroke:black; stroke-width:4px; stroke-linejoin:round;" /><path d="m 24 11 L 24 65  A 5 5 0 0 0 29 70 L 95 70  A 5 5 0 0 0 100 65 L 100 11  z" style="fill:#FAE701; stroke:black; stroke-width:2px; stroke-linejoin:round;"/><path d="m 36 111 L 90 111 L 90 80 A 4 4 0 0 0 86 76 L 40 76 A 4 4 0 0 0 36 80 z"  style="fill:#FAE701; stroke:black; stroke-width:2px; stroke-linejoin:round;" /><rect x="67" y="79" width="14" height ="28"     style="fill:#FAE701; stroke:black; stroke-width:2px; stroke-linejoin:round;"</g>', "Don't forget to save.");
  }
  static snapshotIcon(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="m 16 32  L 16 78 A 6 6 0 0 0 22 84 L 46 84 L 48 94 A 5.75 3.25 30 0 0 54 100 L 78 100 A 3.25 5.75  30 0 0 84 94  L 86 84 L 104 84  A 6 6 0 0 0 110 78  L 110 32 A 6 6 0 0 0 104 26 L 22 26 A 6 6 0 0 0 16 32 z"  fill="lightgray" filter="url(#f1)" />', '<path d="m 16 32  L 16 78 A 6 6 0 0 0 22 84 L 46 84 L 48 94 A 5.75 3.25 30 0 0 54 100 L 78 100 A 3.25 5.75  30 0 0 84 94  L 86 84 L 104 84  A 6 6 0 0 0 110 78  L 110 32 A 6 6 0 0 0 104 26 L 22 26 A 6 6 0 0 0 16 32 z" style="fill:#707070; stroke:#464646; stroke-width:4px; stroke-linejoin:round;" /><Circle cx="65" cy="55" r="26"   style="fill:#895e96; stroke:#464646; stroke-width:6px; stroke-linejoin:round;" />');
  }
  static CloseIcon(size, shadow, semitransparent, addIcon, deleteIcon, title) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="m 21.6 38.6 L 47.1 64.3 L 22 89.5 L 38.4 106.2 L 64 81 L 89.3 106.2 L 105.8 89.5 L 80.6 64 L 105.8 38.9 L 89.3 22.2 L 64 47.5  L 38.3 22.1 z"  fill="lightgray" filter="url(#f1)" />', '<path d="m 21.6 38.6 L 47.1 64.3 L 22 89.5 L 38.4 106.2 L 64 81 L 89.3 106.2 L 105.8 89.5 L 80.6 64 L 105.8 38.9 L 89.3 22.2 L 64 47.5  L 38.3 22.1 z" style="fill:#ffffff; stroke:#004a82; stroke-width:4px; stroke-linejoin:round;" />', title);
  }
  static MoveToRightIcon(size, shadow, semitransparent, addIcon, deleteIcon, title) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<rect x="12" y="52" width="4"  height="24" fill="lightgray" filter="url(#f1)" /><rect x="20" y="52" width="8"  height="24" fill="lightgray" filter="url(#f1)" /><rect x="56" y="16" width="16"  height="96" fill="lightgray" filter="url(#f1)" /><path d="m  32 52 L 32 76 L 56 76 L 56 96 L 88 64 L 56 32 L 56 52 z" fill="lightgray" filter="url(#f1)" />', '<rect x="12" y="52" width="4"  height="24" style="fill:#ffffff; stroke:#004a82; stroke-width:4px; stroke-linejoin:round;" /><rect x="20" y="52" width="8"  height="24" style="fill:#ffffff; stroke:#004a82; stroke-width:4px; stroke-linejoin:round;" /><rect x="96" y="16" width="16"  height="96" style="fill:#ffffff; stroke:#004a82; stroke-width:4px; stroke-linejoin:round;" /><path d="m  32 52 L 32 76 L 56 76 L 56 96 L 88 64 L 56 32 L 56 52 z" style="fill:#ffffff; stroke:#004a82; stroke-width:4px; stroke-linejoin:round;" />', title);
  }
  static MoveToLeftIcon(size, shadow, semitransparent, addIcon, deleteIcon, title) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<rect x="112" y="52" width="4"  height="24" fill="lightgray" filter="url(#f1)" /><rect x="100" y="52" width="8"  height="24" fill="lightgray" filter="url(#f1)" /><rect x="16" y="16" width="16"  height="96" fill="lightgray" filter="url(#f1)" /><path d="m  96 52 L 96 76 L 72 76 L 72 96 L 40 64 L 72 32 L 72 52 z" fill="lightgray" filter="url(#f1)" />', '<rect x="112" y="52" width="4"  height="24" style="fill:#ffffff; stroke:#004a82; stroke-width:4px; stroke-linejoin:round;" /><rect x="100" y="52" width="8"  height="24" style="fill:#ffffff; stroke:#004a82; stroke-width:4px; stroke-linejoin:round;" /><rect x="16" y="16" width="16"  height="96" style="fill:#ffffff; stroke:#004a82; stroke-width:4px; stroke-linejoin:round;" /><path d="m  96 52 L 96 76 L 72 76 L 72 96 L 40 64 L 72 32 L 72 52 z" style="fill:#ffffff; stroke:#004a82; stroke-width:4px; stroke-linejoin:round;" />', title);
  }
  static ExpandIcon(size, shadow, semitransparent, addIcon, deleteIcon, title) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="m  24 56 L 24 72 L 56 72 L 56 104 L 72 104 L 72 72 L 104 72 L 104 56 L 72 56 L 72 24 L 56 24 L 56 56 z"  fill="lightgray" filter="url(#f1)" />', '<path d="m 24 56 L 24 72 L 56 72 L 56 104 L 72 104 L 72 72 L 104 72 L 104 56 L 72 56 L 72 24 L 56 24 L 56 56  z" style="fill:black; " />', title);
  }
  static OkIcon(size, shadow, semitransparent, addIcon, deleteIcon, title) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<circle cx="64" cy="64" r="56"   fill="lightgray" filter="url(#f1)" />', '<circle cx="64" cy="64" r="56" fill="#00b20f"/><path d="m 19 72 L 34 87 L 60 62 L 94 96 L 109 81 L 60 32  z" style="fill:white; " />', title);
  }
  static FailedIcon(size, shadow, semitransparent, addIcon, deleteIcon, title) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<circle cx="64" cy="64" r="56"   fill="lightgray" filter="url(#f1)" />', '<circle cx="64" cy="64" r="56" fill="#ff101e"/><path d="m 43 99 L 64 79 L 85 99 L 100 85 L 79 64 L 100 43 L 85 28 L 64 49 L 43 28 L 28  43 L 49 64 L  28 85   z" style="fill:white; " />', title);
  }
  static DontKnowIcon(size, shadow, semitransparent, addIcon, deleteIcon, title) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<circle cx="64" cy="64" r="56"   fill="lightgray" filter="url(#f1)" />', '<circle cx="64" cy="64" r="56" fill="#f1ba00"/><text x="35" y="-30" fill="white" transform="scale(1,-1)" style="font: bold 96px sans-serif;">?</text> ', title);
  }
  static infoIcon(size, shadow, semitransparent, addIcon, deleteIcon, title) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<circle cx="64" cy="64" r="56"   fill="lightgray" filter="url(#f1)" />', '<circle cx="64" cy="64" r="56" fill="DodgerBlue"/><text x="50" y="-30" fill="white" transform="scale(1,-1)" style="font: bold 96px sans-serif;">i</text> ', title);
  }
  static ColapseIcon(size, shadow, semitransparent, addIcon, deleteIcon, title) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="m 24 56 L 24 72 L 104 72 L 104 56 z"  fill="lightgray" filter="url(#f1)" />', '<path d="m 24 56 L 24 72 L 104 72 L 104 56 z" style="fill:black; " />', title);
  }
  static AddMarkerIcon(size, index) {
    return ressources.IconSourceCode(size, false, false, false, false, "", '<circle  cx="64" cy="64"  r="50"   style="fill:lightyellow;" stroke-width="8" stroke="darkred" /><text x="46" y="-40" fill="black" transform="scale(1,-1)" style="font: bold 64px sans-serif;">' + index.toString() + "</text>");
  }
  static AddMarker(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, "", '<line x1="80" y1="8" x2="80" y2="128" stroke="darkred" stroke-width="8" stroke-linecap="round" /><path d="m 60 64 L 100 64 L 80 20 z" style="fill:darkred; " /><rect x="40" y="56" width="80" height="32" style="fill:lightYellow" stroke="darkred" stroke-width="8" />');
  }
  static EraseDatalogger(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, "", '<g transform="rotate(-35,0,0)"><g transform="translate(-56,24)"><path d="m 108 24 L 108 46 L 60 46  A 22 22 0 1 0 60 90 L 108 90  L 108 112 L 60 112 A 44 44 0 1 1 60 24 z" style="fill:#808080; " /><rect x="88" y="24" width="20" height="22" style="fill:red" stroke="none"  /><rect x="88" y="90" width="20" height="22" style="fill:blue" stroke="none"  /><path d="m 108 24 L 108 46 L 60 46  A 22 22 0 1 0 60 90 L 108 90  L 108 112 L 60 112 A 44 44 0 1 1 60 24 z"  style="fill:none" stroke="black"  stroke-width="4" stroke-linejoin="round"/></g></g>');
  }
  static resetViewPort(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, "", '<line x1="116" y1="52" x2="116" y2="12"  stroke="black"  stroke-width="4"/><line x1="12" y1="52" x2="12" y2="12"  stroke="black"  stroke-width="4"/><path d="m 100 36 L 28 36 L 28 48 L 12 32  L 28 16 L 28 28 L 100 28 L 100 16 L 116 32 L 100 48z" style="fill:white" stroke="black"  stroke-width="4" stroke-linejoin="round" /><path d="m 7.3 97.7 L 20 107.4 L 51.6 114.7 L 78.5 112.2 L 101.6 103.3 L 114.4 91.7  L 117.7 81.7 L 104.3 66.9 L 80.9 61.2 L49.9 65 L 25 76.3 L 12.6 87.5 Z " style="fill:white" stroke="none" /><circle  cx="64" cy="88" r="27" style="fill:#6cc87b" stroke="none"  /> <path d="m 37.2 84.8 A 27 27 0 0 0 46.5 108.8 L 64 88 z" style="fill:#8ed698" stroke="none" /> <circle  cx="64" cy="88" r="16" style="fill:black" stroke="none"  /> <path d="m 6 97 A 59 34 -4 0 0 119 80" style="fill:none" stroke="black"  stroke-width="4"  stroke-linecap="round"/> <path d="m 113 79 A 56 31 -16 0 0 9 93 " style="fill:none" stroke="black"  stroke-width="4"  stroke-linecap="round" /> ');
  }
  static DeleteMarker(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, "", '<line x1="80" y1="8" x2="80" y2="128" stroke="darkred" stroke-width="8" stroke-linecap="round" /><path d="m 60 64 L 100 64 L 80 20 z" style="fill:darkred; " /><rect x="40" y="56" width="80" height="32" style="fill:lightYellow" stroke="darkred" stroke-width="8" />');
  }
  static targetIcon(size, shadow, semitransparent, addIcon, deleteIcon, title) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, "", '<circle  cx="64" cy="64"  r="42"   style="fill:none;" stroke-width="8" stroke="black" /><line  x1="0"   y1="64"  x2="42"  y2="64"  style="fill:none;" stroke-width="8" stroke="black" /><line  x1="128" y1="64"  x2="86"  y2="64"  style="fill:none;" stroke-width="8" stroke="black" /><line  y1="0"   x1="64"  y2="42"  x2="64"  style="fill:none;" stroke-width="8" stroke="black" /><line  y1="128" x1="64"  y2="86"  x2="64"  style="fill:none;" stroke-width="8" stroke="black" />', title);
  }
  static DotDotDotIcon(size, shadow, semitransparent, addIcon, deleteIcon, title) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, "", '<rect x="18" y="36" width="18" height="18" style="fill:black" /><rect x="54" y="36" width="18" height="18" style="fill:black" /><rect x="90" y="36" width="18" height="18" style="fill:black" />', title);
  }
  static LogFileIcon(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, "", '<line x1="4" y1="24" x2="30" y2="24"     style=" stroke:black; stroke-width:8px;" /><line x1="34" y1="24" x2="56" y2="24"    style=" stroke:black; stroke-width:8px; " /><line x1="64" y1="24" x2="74" y2="24"    style=" stroke:black; stroke-width:8px; " /><line x1="80" y1="24" x2="88" y2="24"    style=" stroke:black; stroke-width:8px; " /><line x1="4" y1="40" x2="30" y2="40"     style=" stroke:black; stroke-width:8px;" /><line x1="34" y1="40" x2="56" y2="40"    style=" stroke:black; stroke-width:8px; " /><line x1="61" y1="40" x2="90" y2="40"    style=" stroke:black; stroke-width:8px; " /><line x1="94" y1="40" x2="110" y2="40"    style=" stroke:black; stroke-width:8px; " /><line x1="4" y1="56" x2="30" y2="56"     style=" stroke:black; stroke-width:8px;" /><line x1="34" y1="56" x2="56" y2="56"    style=" stroke:black; stroke-width:8px; " /><line x1="61" y1="56" x2="86" y2="56"    style=" stroke:black; stroke-width:8px; " /><line x1="4" y1="72" x2="30" y2="72"     style=" stroke:black; stroke-width:8px;" /><line x1="34" y1="72" x2="50" y2="72"    style=" stroke:black; stroke-width:8px; " /><line x1="56" y1="72" x2="100" y2="72"    style=" stroke:black; stroke-width:8px; " /><line x1="4" y1="88" x2="30" y2="88"     style=" stroke:black; stroke-width:8px;" /><line x1="34" y1="88" x2="56" y2="88"    style=" stroke:black; stroke-width:8px; " /><line x1="61" y1="88" x2="72" y2="88"    style=" stroke:black; stroke-width:8px; " /><line x1="78" y1="88" x2="106" y2="88"    style=" stroke:black; stroke-width:8px; " />');
  }
};

// obj/full/Pako/utils/common.js
var utils_common = class {
  static flattenChunks(chunks) {
    let len = 0;
    for (let i = 0, l = chunks.length; i < l; i++) {
      len += chunks[i].length;
    }
    const result = new Uint8Array(len);
    for (let i = 0, pos = 0, l = chunks.length; i < l; i++) {
      let chunk = chunks[i];
      result.set(chunk, pos);
      pos += chunk.length;
    }
    return result;
  }
};

// obj/full/Pako/utils/strings.js
var Pako_strings = class {
  static _init() {
    try {
      String.fromCharCode.apply(null, new Uint8Array(1));
    } catch (__) {
      Pako_strings.STR_APPLY_UIA_OK = false;
    }
    for (let q = 0; q < 256; q++) {
      Pako_strings._utf8len[q] = q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1;
    }
    Pako_strings._utf8len[254] = Pako_strings._utf8len[254] = 1;
    return true;
  }
  static string2buf(str) {
    let buf;
    let c;
    let c2;
    let m_pos;
    let i;
    let str_len = str.length;
    let buf_len = 0;
    for (m_pos = 0; m_pos < str_len; m_pos++) {
      c = str.charCodeAt(m_pos);
      if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
        c2 = str.charCodeAt(m_pos + 1);
        if ((c2 & 64512) === 56320) {
          c = 65536 + (c - 55296 << 10) + (c2 - 56320);
          m_pos++;
        }
      }
      buf_len += c < 128 ? 1 : c < 2048 ? 2 : c < 65536 ? 3 : 4;
    }
    buf = new Uint8Array(buf_len);
    for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
      c = str.charCodeAt(m_pos);
      if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
        c2 = str.charCodeAt(m_pos + 1);
        if ((c2 & 64512) === 56320) {
          c = 65536 + (c - 55296 << 10) + (c2 - 56320);
          m_pos++;
        }
      }
      if (c < 128) {
        buf[i++] = c;
      } else if (c < 2048) {
        buf[i++] = 192 | c >>> 6;
        buf[i++] = 128 | c & 63;
      } else if (c < 65536) {
        buf[i++] = 224 | c >>> 12;
        buf[i++] = 128 | c >>> 6 & 63;
        buf[i++] = 128 | c & 63;
      } else {
        buf[i++] = 240 | c >>> 18;
        buf[i++] = 128 | c >>> 12 & 63;
        buf[i++] = 128 | c >>> 6 & 63;
        buf[i++] = 128 | c & 63;
      }
    }
    return buf;
  }
  static buf2binstring(buf, len) {
    let result = "";
    for (let i = 0; i < len; i++) {
      result += String.fromCharCode(buf[i]);
    }
    return result;
  }
  static buf2string(buf, max) {
    let i;
    let out;
    const len = max || buf.length;
    const utf16buf = new Array(len * 2);
    for (out = 0, i = 0; i < len; ) {
      let c = buf[i++];
      if (c < 128) {
        utf16buf[out++] = c;
        continue;
      }
      let c_len = Pako_strings._utf8len[c];
      if (c_len > 4) {
        utf16buf[out++] = 65533;
        i += c_len - 1;
        continue;
      }
      c &= c_len === 2 ? 31 : c_len === 3 ? 15 : 7;
      while (c_len > 1 && i < len) {
        c = c << 6 | buf[i++] & 63;
        c_len--;
      }
      if (c_len > 1) {
        utf16buf[out++] = 65533;
        continue;
      }
      if (c < 65536) {
        utf16buf[out++] = c;
      } else {
        c -= 65536;
        utf16buf[out++] = 55296 | c >> 10 & 1023;
        utf16buf[out++] = 56320 | c & 1023;
      }
    }
    return Pako_strings.buf2binstring(utf16buf, out);
  }
  static utf8border(buf, max) {
    max = max || buf.length;
    if (max > buf.length) {
      max = buf.length;
    }
    let pos = max - 1;
    while (pos >= 0 && (buf[pos] & 192) === 128) {
      pos--;
    }
    if (pos < 0) {
      return max;
    }
    if (pos === 0) {
      return max;
    }
    return pos + Pako_strings._utf8len[buf[pos]] > max ? pos : max;
  }
};
Pako_strings.STR_APPLY_UIA_OK = true;
Pako_strings._utf8len = new Uint8Array(256);
Pako_strings.initDone = Pako_strings._init();

// obj/full/Pako/deflate.js
var Pako_deflate_option = class {
  constructor(CustOption) {
    this.level = zlib_constants.Z_DEFAULT_COMPRESSION;
    this.method = zlib_constants.Z_DEFLATED;
    this.chunkSize = 16384;
    this.windowBits = 15;
    this.memLevel = 8;
    this.strategy = zlib_constants.Z_DEFAULT_STRATEGY;
    this.raw = false;
    this.gzip = false;
    this.header = null;
    this.dictionary = null;
    this.ignore_os = false;
    Pako_deflate_option.ApplyCustomOptions(this, CustOption);
  }
  static ApplyCustomOptions(StdOption, CustOption) {
    if (typeof CustOption != "undefined") {
      let stdKeys = Object.keys(StdOption);
      let custKeys = Object.keys(CustOption);
      for (let i = 0; i < custKeys.length; i++) {
        if (stdKeys.indexOf(custKeys[i]) < 0) {
          debugger;
          throw "Invalid Pako option name '" + custKeys[i] + "', check Pako_deflate_option class";
        }
        let srcType = typeof Reflect.get(CustOption, custKeys[i]);
        let trgtType = typeof Reflect.get(StdOption, custKeys[i]);
        if (srcType != trgtType)
          throw "Invalid Pako type for option '" + custKeys[i] + "' (expected '" + trgtType + "', got '" + srcType + "')";
        Reflect.set(StdOption, custKeys[i], Reflect.get(CustOption, custKeys[i]));
      }
    }
  }
};
var Pako_Deflate = class {
  constructor(options) {
    this._dict_set = false;
    this.result = null;
    this.options = new Pako_deflate_option(options);
    let opt = this.options;
    if (opt.raw && opt.windowBits > 0) {
      opt.windowBits = -opt.windowBits;
    } else if (opt.gzip && opt.windowBits > 0 && opt.windowBits < 16) {
      opt.windowBits += 16;
    }
    this.err = 0;
    this.msg = "";
    this.ended = false;
    this.chunks = [];
    this.strm = new zlib_ZStream();
    this.strm.avail_out = 0;
    let status = zlib_deflate.deflateInit2(this.strm, opt.level, opt.method, opt.windowBits, opt.memLevel, opt.strategy);
    if (status !== zlib_constants.Z_OK) {
      throw new Error(zlib_messages.msg(status));
    }
    if (opt.header) {
      zlib_deflate.deflateSetHeader(this.strm, opt.header);
    }
    if (opt.dictionary) {
      let dict;
      if (typeof opt.dictionary === "string") {
        dict = Pako_strings.string2buf(opt.dictionary);
      } else if (toString.call(opt.dictionary) === "[object ArrayBuffer]") {
        dict = new Uint8Array(opt.dictionary);
      } else {
        dict = opt.dictionary;
      }
      status = zlib_deflate.deflateSetDictionary(this.strm, dict);
      if (status !== zlib_constants.Z_OK) {
        throw new Error(zlib_messages.msg(status));
      }
      this._dict_set = true;
    }
  }
  push(data, flush_mode) {
    const strm = this.strm;
    const chunkSize = this.options.chunkSize;
    let status;
    let _flush_mode;
    if (this.ended) {
      return false;
    }
    if (flush_mode === ~~flush_mode) {
      _flush_mode = flush_mode;
    } else {
      _flush_mode = flush_mode === true ? zlib_constants.Z_FINISH : zlib_constants.Z_NO_FLUSH;
    }
    if (typeof data === "string") {
      strm.input = Pako_strings.string2buf(data);
    } else if (toString.call(data) === "[object ArrayBuffer]") {
      strm.input = new Uint8Array(data);
    } else {
      strm.input = data;
    }
    strm.next_in = 0;
    strm.avail_in = strm.input.length;
    for (; ; ) {
      if (strm.avail_out === 0) {
        strm.output = new Uint8Array(chunkSize);
        strm.next_out = 0;
        strm.avail_out = chunkSize;
      }
      if ((_flush_mode === zlib_constants.Z_SYNC_FLUSH || _flush_mode === zlib_constants.Z_FULL_FLUSH) && strm.avail_out <= 6) {
        this.onData(strm.output.subarray(0, strm.next_out));
        strm.avail_out = 0;
        continue;
      }
      status = zlib_deflate.deflate(strm, _flush_mode);
      if (status === zlib_constants.Z_STREAM_END) {
        if (strm.next_out > 0) {
          this.onData(strm.output.subarray(0, strm.next_out));
        }
        status = zlib_deflate.deflateEnd(this.strm);
        this.onEnd(status);
        this.ended = true;
        return status === zlib_constants.Z_OK;
      }
      if (strm.avail_out === 0) {
        this.onData(strm.output);
        continue;
      }
      if (_flush_mode > 0 && strm.next_out > 0) {
        this.onData(strm.output.subarray(0, strm.next_out));
        strm.avail_out = 0;
        continue;
      }
      if (strm.avail_in === 0)
        break;
    }
    return true;
  }
  onData(chunk) {
    this.chunks.push(chunk);
  }
  onEnd(status) {
    if (status === zlib_constants.Z_OK) {
      this.result = utils_common.flattenChunks(this.chunks);
    }
    this.chunks = [];
    this.err = status;
    this.msg = this.strm.msg;
  }
  static deflate(input, options) {
    const deflator = new Pako_Deflate(options);
    deflator.push(input, true);
    if (deflator.err) {
      throw deflator.msg || zlib_messages.msg(deflator.err);
    }
    return deflator.result;
  }
  static deflateRaw(input, options) {
    options.raw = true;
    return Pako_Deflate.deflate(input, options);
  }
  static gzip(input, options) {
    if (typeof options == "undefined")
      options = {};
    options.gzip = true;
    return Pako_Deflate.deflate(input, options);
  }
};

// obj/full/Pako/inflate.js
var Pako_inflate_option = class {
  constructor(CustOption) {
    this.chunkSize = 1024 * 64;
    this.windowBits = 15;
    this.to = "";
    this.raw = false;
    this.dictionary = null;
    Pako_inflate_option.ApplyCustomOptions(this, CustOption);
  }
  static ApplyCustomOptions(StdOption, CustOption) {
    if (typeof CustOption != "undefined") {
      let stdKeys = Object.keys(StdOption);
      let custKeys = Object.keys(CustOption);
      for (let i = 0; i < custKeys.length; i++) {
        if (stdKeys.indexOf(custKeys[i]) < 0)
          throw "Invalid Pako option name '" + custKeys[i] + "', check Pako_inflate_option class";
        let srcType = typeof Reflect.get(CustOption, custKeys[i]);
        let trgtType = typeof Reflect.get(StdOption, custKeys[i]);
        if (srcType != trgtType) {
          throw "Invalid Pako type for option '" + custKeys[i] + "' (expected '" + trgtType + "', got '" + srcType + "')";
        }
        Reflect.set(StdOption, custKeys[i], Reflect.get(CustOption, custKeys[i]));
      }
    }
  }
};
var Pako_Inflate = class {
  constructor(options) {
    this.err = 0;
    this.msg = "";
    this.ended = false;
    this.result = null;
    this.options = new Pako_inflate_option(options);
    const opt = this.options;
    if (opt.raw && opt.windowBits >= 0 && opt.windowBits < 16) {
      opt.windowBits = -opt.windowBits;
      if (opt.windowBits === 0) {
        opt.windowBits = -15;
      }
    }
    if (opt.windowBits >= 0 && opt.windowBits < 16 && !(options && options.windowBits)) {
      opt.windowBits += 32;
    }
    if (opt.windowBits > 15 && opt.windowBits < 48) {
      if ((opt.windowBits & 15) === 0) {
        opt.windowBits |= 15;
      }
    }
    this.err = 0;
    this.msg = "";
    this.ended = false;
    this.chunks = [];
    this.strm = new zlib_ZStream();
    this.strm.avail_out = 0;
    let status = zlib_inflate.inflateInit2(this.strm, opt.windowBits);
    if (status !== zlib_constants.Z_OK) {
      throw new Error(zlib_messages.msg(status));
    }
    this.header = new zlib_GZheader();
    zlib_inflate.inflateGetHeader(this.strm, this.header);
    if (opt.dictionary) {
      if (typeof opt.dictionary === "string") {
        opt.dictionary = Pako_strings.string2buf(opt.dictionary);
      } else if (toString.call(opt.dictionary) === "[object ArrayBuffer]") {
        opt.dictionary = new Uint8Array(opt.dictionary);
      }
      if (opt.raw) {
        status = zlib_inflate.inflateSetDictionary(this.strm, opt.dictionary);
        if (status !== zlib_constants.Z_OK) {
          throw new Error(zlib_messages.msg(status));
        }
      }
    }
  }
  push(data, flush_mode) {
    const strm = this.strm;
    const chunkSize = this.options.chunkSize;
    const dictionary = this.options.dictionary;
    let status;
    let _flush_mode;
    let last_avail_out;
    if (this.ended)
      return false;
    if (flush_mode === ~~flush_mode) {
      _flush_mode = flush_mode;
    } else {
      _flush_mode = flush_mode === true ? zlib_constants.Z_FINISH : zlib_constants.Z_NO_FLUSH;
    }
    if (toString.call(data) === "[object ArrayBuffer]") {
      strm.input = new Uint8Array(data);
    } else {
      strm.input = data;
    }
    strm.next_in = 0;
    strm.avail_in = strm.input.length;
    for (; ; ) {
      if (strm.avail_out === 0) {
        strm.output = new Uint8Array(chunkSize);
        strm.next_out = 0;
        strm.avail_out = chunkSize;
      }
      status = zlib_inflate.inflate(strm, _flush_mode);
      if (status === zlib_constants.Z_NEED_DICT && dictionary) {
        status = zlib_inflate.inflateSetDictionary(strm, dictionary);
        if (status === zlib_constants.Z_OK) {
          status = zlib_inflate.inflate(strm, _flush_mode);
        } else if (status === zlib_constants.Z_DATA_ERROR) {
          status = zlib_constants.Z_NEED_DICT;
        }
      }
      while (strm.avail_in > 0 && status === zlib_constants.Z_STREAM_END && strm.state.wrap > 0 && data[strm.next_in] !== 0) {
        zlib_inflate.inflateReset(strm);
        status = zlib_inflate.inflate(strm, _flush_mode);
      }
      switch (status) {
        case zlib_constants.Z_STREAM_ERROR:
        case zlib_constants.Z_DATA_ERROR:
        case zlib_constants.Z_NEED_DICT:
        case zlib_constants.Z_MEM_ERROR:
          this.onEnd(status);
          this.ended = true;
          return false;
      }
      last_avail_out = strm.avail_out;
      if (strm.next_out) {
        if (strm.avail_out === 0 || status === zlib_constants.Z_STREAM_END) {
          if (this.options.to === "string") {
            let next_out_utf8 = Pako_strings.utf8border(strm.output, strm.next_out);
            let tail = strm.next_out - next_out_utf8;
            let utf8str = Pako_strings.buf2string(strm.output, next_out_utf8);
            strm.next_out = tail;
            strm.avail_out = chunkSize - tail;
            if (tail)
              strm.output.set(strm.output.subarray(next_out_utf8, next_out_utf8 + tail), 0);
            this.onData(utf8str);
          } else {
            this.onData(strm.output.length === strm.next_out ? strm.output : strm.output.subarray(0, strm.next_out));
          }
        }
      }
      if (status === zlib_constants.Z_OK && last_avail_out === 0)
        continue;
      if (status === zlib_constants.Z_STREAM_END) {
        status = zlib_inflate.inflateEnd(this.strm);
        this.onEnd(status);
        this.ended = true;
        return true;
      }
      if (strm.avail_in === 0)
        break;
    }
    return true;
  }
  onData(chunk) {
    this.chunks[this.chunks.length] = chunk;
  }
  onEnd(status) {
    if (status === zlib_constants.Z_OK) {
      if (this.options.to === "string") {
        this.result = this.chunks.join("");
      } else {
        this.result = utils_common.flattenChunks(this.chunks);
      }
    }
    this.chunks = [];
    this.err = status;
    this.msg = this.strm.msg;
  }
  static inflate(input, options) {
    const inflator = new Pako_Inflate(options);
    inflator.push(input, false);
    if (inflator.err)
      throw inflator.msg || zlib_messages.msg(inflator.err);
    return inflator.result;
  }
  inflateRaw(input, options) {
    options.raw = true;
    return Pako_Inflate.inflate(input, options);
  }
  static ungzip(input, options) {
    return Pako_Inflate.inflate(input, options);
  }
};

// obj/full/Pako/zlib/adler32.js
"use strict";
var zlib_adler32 = class {
  static adler32(adler, buf, len, pos) {
    let s1 = adler & 65535 | 0, s2 = adler >>> 16 & 65535 | 0, n = 0;
    while (len !== 0) {
      n = len > 2e3 ? 2e3 : len;
      len -= n;
      do {
        s1 = s1 + buf[pos++] | 0;
        s2 = s2 + s1 | 0;
      } while (--n);
      s1 %= 65521;
      s2 %= 65521;
    }
    return s1 | s2 << 16 | 0;
  }
};

// obj/full/Pako/zlib/constants.js
"use strict";
var zlib_constants = class {
};
zlib_constants.Z_NO_FLUSH = 0;
zlib_constants.Z_PARTIAL_FLUSH = 1;
zlib_constants.Z_SYNC_FLUSH = 2;
zlib_constants.Z_FULL_FLUSH = 3;
zlib_constants.Z_FINISH = 4;
zlib_constants.Z_BLOCK = 5;
zlib_constants.Z_TREES = 6;
zlib_constants.Z_OK = 0;
zlib_constants.Z_STREAM_END = 1;
zlib_constants.Z_NEED_DICT = 2;
zlib_constants.Z_ERRNO = -1;
zlib_constants.Z_STREAM_ERROR = -2;
zlib_constants.Z_DATA_ERROR = -3;
zlib_constants.Z_MEM_ERROR = -4;
zlib_constants.Z_BUF_ERROR = -5;
zlib_constants.Z_NO_COMPRESSION = 0;
zlib_constants.Z_BEST_SPEED = 1;
zlib_constants.Z_BEST_COMPRESSION = 9;
zlib_constants.Z_DEFAULT_COMPRESSION = -1;
zlib_constants.Z_FILTERED = 1;
zlib_constants.Z_HUFFMAN_ONLY = 2;
zlib_constants.Z_RLE = 3;
zlib_constants.Z_FIXED = 4;
zlib_constants.Z_DEFAULT_STRATEGY = 0;
zlib_constants.Z_BINARY = 0;
zlib_constants.Z_TEXT = 1;
zlib_constants.Z_UNKNOWN = 2;
zlib_constants.Z_DEFLATED = 8;

// obj/full/Pako/zlib/crc32.js
"use strict";
var zlib_crc32 = class {
  static makeTable() {
    let c;
    let table = new Int32Array(256);
    for (let n = 0; n < 256; n++) {
      c = n;
      for (let k = 0; k < 8; k++) {
        c = c & 1 ? 3988292384 ^ c >>> 1 : c >>> 1;
      }
      table[n] = c;
    }
    return table;
  }
  static crc32(crc, buf, len, pos) {
    let t = zlib_crc32.crcTable;
    let end = pos + len;
    crc ^= -1;
    for (let i = pos; i < end; i++) {
      crc = crc >>> 8 ^ t[(crc ^ buf[i]) & 255];
    }
    return crc ^ -1;
  }
};
zlib_crc32.crcTable = zlib_crc32.makeTable();

// obj/full/Pako/zlib/deflate.js
"use strict";
var zlib_config = class {
  constructor(good_length, max_lazy, nice_length, max_chain, func) {
    this.good_length = good_length;
    this.max_lazy = max_lazy;
    this.nice_length = nice_length;
    this.max_chain = max_chain;
    this.func = func;
  }
};
var zlib_DeflateState = class {
  constructor() {
    this.strm = null;
    this.status = 0;
    this.pending_buf = null;
    this.pending_buf_size = 0;
    this.pending_out = 0;
    this.pending = 0;
    this.wrap = 0;
    this.gzhead = null;
    this.gzindex = 0;
    this.method = zlib_constants.Z_DEFLATED;
    this.last_flush = -1;
    this.w_size = 0;
    this.w_bits = 0;
    this.w_mask = 0;
    this.window = null;
    this.window_size = 0;
    this.prev = null;
    this.head = null;
    this.ins_h = 0;
    this.hash_size = 0;
    this.hash_bits = 0;
    this.hash_mask = 0;
    this.hash_shift = 0;
    this.block_start = 0;
    this.match_length = 0;
    this.prev_match = 0;
    this.match_available = 0;
    this.strstart = 0;
    this.match_start = 0;
    this.lookahead = 0;
    this.prev_length = 0;
    this.max_chain_length = 0;
    this.max_lazy_match = 0;
    this.level = 0;
    this.strategy = 0;
    this.good_match = 0;
    this.nice_match = 0;
    this.dyn_ltree = new Uint16Array(zlib_Pako_trees.HEAP_SIZE * 2);
    this.dyn_dtree = new Uint16Array((2 * zlib_Pako_trees.D_CODES + 1) * 2);
    this.bl_tree = new Uint16Array((2 * zlib_Pako_trees.BL_CODES + 1) * 2);
    this.l_desc = null;
    this.d_desc = null;
    this.bl_desc = null;
    this.bl_count = new Uint16Array(zlib_Pako_trees.MAX_BITS + 1);
    this.heap = new Uint16Array(2 * zlib_Pako_trees.L_CODES + 1);
    this.heap_len = 0;
    this.heap_max = 0;
    this.depth = new Uint16Array(2 * zlib_Pako_trees.L_CODES + 1);
    this.l_buf = 0;
    this.lit_bufsize = 0;
    this.last_lit = 0;
    this.d_buf = 0;
    this.opt_len = 0;
    this.static_len = 0;
    this.matches = 0;
    this.insert = 0;
    this.bi_buf = 0;
    this.bi_valid = 0;
    zlib_Pako_trees.zero(this.dyn_ltree);
    zlib_Pako_trees.zero(this.dyn_dtree);
    zlib_Pako_trees.zero(this.bl_tree);
    zlib_Pako_trees.zero(this.heap);
    zlib_Pako_trees.zero(this.depth);
  }
};
var zlib_deflate = class {
  static err(strm, errorCode) {
    strm.msg = zlib_messages.msg(errorCode);
    return errorCode;
  }
  static rank(f) {
    return (f << 1) - (f > 4 ? 9 : 0);
  }
  zero(buf) {
    let len = buf.length;
    while (--len >= 0) {
      buf[len] = 0;
    }
  }
  static HASH_ZLIB(s, prev, data) {
    return (prev << s.hash_shift ^ data) & s.hash_mask;
  }
  static HASH(s, prev, data) {
    return (prev << s.hash_shift ^ data) & s.hash_mask;
  }
  static flush_pending(strm) {
    const s = strm.state;
    let len = s.pending;
    if (len > strm.avail_out) {
      len = strm.avail_out;
    }
    if (len === 0) {
      return;
    }
    strm.output.set(s.pending_buf.subarray(s.pending_out, s.pending_out + len), strm.next_out);
    strm.next_out += len;
    s.pending_out += len;
    strm.total_out += len;
    strm.avail_out -= len;
    s.pending -= len;
    if (s.pending === 0) {
      s.pending_out = 0;
    }
  }
  static flush_block_only(s, last) {
    zlib_Pako_trees._tr_flush_block(s, s.block_start >= 0 ? s.block_start : -1, s.strstart - s.block_start, last);
    s.block_start = s.strstart;
    zlib_deflate.flush_pending(s.strm);
  }
  static put_byte(s, b) {
    s.pending_buf[s.pending++] = b;
  }
  static putShortMSB(s, b) {
    s.pending_buf[s.pending++] = b >>> 8 & 255;
    s.pending_buf[s.pending++] = b & 255;
  }
  static read_buf(strm, buf, start, size) {
    let len = strm.avail_in;
    if (len > size) {
      len = size;
    }
    if (len === 0) {
      return 0;
    }
    strm.avail_in -= len;
    buf.set(strm.input.subarray(strm.next_in, strm.next_in + len), start);
    if (strm.state.wrap === 1) {
      strm.adler = zlib_adler32.adler32(strm.adler, buf, len, start);
    } else if (strm.state.wrap === 2) {
      strm.adler = zlib_crc32.crc32(strm.adler, buf, len, start);
    }
    strm.next_in += len;
    strm.total_in += len;
    return len;
  }
  static longest_match(s, cur_match) {
    let chain_length = s.max_chain_length;
    let scan = s.strstart;
    let match;
    let len;
    let best_len = s.prev_length;
    let nice_match = s.nice_match;
    const limit = s.strstart > s.w_size - zlib_deflate.MIN_LOOKAHEAD ? s.strstart - (s.w_size - zlib_deflate.MIN_LOOKAHEAD) : 0;
    const _win = s.window;
    const wmask = s.w_mask;
    const prev = s.prev;
    const strend = s.strstart + zlib_Pako_trees.MAX_MATCH;
    let scan_end1 = _win[scan + best_len - 1];
    let scan_end = _win[scan + best_len];
    if (s.prev_length >= s.good_match) {
      chain_length >>= 2;
    }
    if (nice_match > s.lookahead) {
      nice_match = s.lookahead;
    }
    do {
      match = cur_match;
      if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1]) {
        continue;
      }
      scan += 2;
      match++;
      do {
      } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend);
      len = zlib_Pako_trees.MAX_MATCH - (strend - scan);
      scan = strend - zlib_Pako_trees.MAX_MATCH;
      if (len > best_len) {
        s.match_start = cur_match;
        best_len = len;
        if (len >= nice_match) {
          break;
        }
        scan_end1 = _win[scan + best_len - 1];
        scan_end = _win[scan + best_len];
      }
    } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);
    if (best_len <= s.lookahead) {
      return best_len;
    }
    return s.lookahead;
  }
  static fill_window(s) {
    const _w_size = s.w_size;
    let p;
    let n;
    let m;
    let more;
    let str;
    do {
      more = s.window_size - s.lookahead - s.strstart;
      if (s.strstart >= _w_size + (_w_size - zlib_deflate.MIN_LOOKAHEAD)) {
        s.window.set(s.window.subarray(_w_size, _w_size + _w_size), 0);
        s.match_start -= _w_size;
        s.strstart -= _w_size;
        s.block_start -= _w_size;
        n = s.hash_size;
        p = n;
        do {
          m = s.head[--p];
          s.head[p] = m >= _w_size ? m - _w_size : 0;
        } while (--n);
        n = _w_size;
        p = n;
        do {
          m = s.prev[--p];
          s.prev[p] = m >= _w_size ? m - _w_size : 0;
        } while (--n);
        more += _w_size;
      }
      if (s.strm.avail_in === 0) {
        break;
      }
      n = zlib_deflate.read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
      s.lookahead += n;
      if (s.lookahead + s.insert >= zlib_Pako_trees.MIN_MATCH) {
        str = s.strstart - s.insert;
        s.ins_h = s.window[str];
        s.ins_h = zlib_deflate.HASH(s, s.ins_h, s.window[str + 1]);
        while (s.insert) {
          s.ins_h = zlib_deflate.HASH(s, s.ins_h, s.window[str + zlib_Pako_trees.MIN_MATCH - 1]);
          s.prev[str & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = str;
          str++;
          s.insert--;
          if (s.lookahead + s.insert < zlib_Pako_trees.MIN_MATCH) {
            break;
          }
        }
      }
    } while (s.lookahead < zlib_deflate.MIN_LOOKAHEAD && s.strm.avail_in !== 0);
  }
  static deflate_stored(s, flush) {
    let max_block_size = 65535;
    if (max_block_size > s.pending_buf_size - 5) {
      max_block_size = s.pending_buf_size - 5;
    }
    for (; ; ) {
      if (s.lookahead <= 1) {
        zlib_deflate.fill_window(s);
        if (s.lookahead === 0 && flush === zlib_constants.Z_NO_FLUSH) {
          return zlib_deflate.BS_NEED_MORE;
        }
        if (s.lookahead === 0) {
          break;
        }
      }
      s.strstart += s.lookahead;
      s.lookahead = 0;
      const max_start = s.block_start + max_block_size;
      if (s.strstart === 0 || s.strstart >= max_start) {
        s.lookahead = s.strstart - max_start;
        s.strstart = max_start;
        zlib_deflate.flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return zlib_deflate.BS_NEED_MORE;
        }
      }
      if (s.strstart - s.block_start >= s.w_size - zlib_deflate.MIN_LOOKAHEAD) {
        zlib_deflate.flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return zlib_deflate.BS_NEED_MORE;
        }
      }
    }
    s.insert = 0;
    if (flush === zlib_constants.Z_FINISH) {
      zlib_deflate.flush_block_only(s, true);
      if (s.strm.avail_out === 0) {
        return zlib_deflate.BS_FINISH_STARTED;
      }
      return zlib_deflate.BS_FINISH_DONE;
    }
    if (s.strstart > s.block_start) {
      zlib_deflate.flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return zlib_deflate.BS_NEED_MORE;
      }
    }
    return zlib_deflate.BS_NEED_MORE;
  }
  static deflate_slow(s, flush) {
    let hash_head;
    let bflush;
    let max_insert;
    for (; ; ) {
      if (s.lookahead < zlib_deflate.MIN_LOOKAHEAD) {
        zlib_deflate.fill_window(s);
        if (s.lookahead < zlib_deflate.MIN_LOOKAHEAD && flush === zlib_constants.Z_NO_FLUSH) {
          return zlib_deflate.BS_NEED_MORE;
        }
        if (s.lookahead === 0) {
          break;
        }
      }
      hash_head = 0;
      if (s.lookahead >= zlib_Pako_trees.MIN_MATCH) {
        s.ins_h = zlib_deflate.HASH(s, s.ins_h, s.window[s.strstart + zlib_Pako_trees.MIN_MATCH - 1]);
        hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
        s.head[s.ins_h] = s.strstart;
      }
      s.prev_length = s.match_length;
      s.prev_match = s.match_start;
      s.match_length = zlib_Pako_trees.MIN_MATCH - 1;
      if (hash_head !== 0 && s.prev_length < s.max_lazy_match && s.strstart - hash_head <= s.w_size - zlib_deflate.MIN_LOOKAHEAD) {
        s.match_length = zlib_deflate.longest_match(s, hash_head);
        if (s.match_length <= 5 && (s.strategy === zlib_constants.Z_FILTERED || s.match_length === zlib_Pako_trees.MIN_MATCH && s.strstart - s.match_start > 4096)) {
          s.match_length = zlib_Pako_trees.MIN_MATCH - 1;
        }
      }
      if (s.prev_length >= zlib_Pako_trees.MIN_MATCH && s.match_length <= s.prev_length) {
        max_insert = s.strstart + s.lookahead - zlib_Pako_trees.MIN_MATCH;
        bflush = zlib_Pako_trees._tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - zlib_Pako_trees.MIN_MATCH);
        s.lookahead -= s.prev_length - 1;
        s.prev_length -= 2;
        do {
          if (++s.strstart <= max_insert) {
            s.ins_h = zlib_deflate.HASH(s, s.ins_h, s.window[s.strstart + zlib_Pako_trees.MIN_MATCH - 1]);
            hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
            s.head[s.ins_h] = s.strstart;
          }
        } while (--s.prev_length !== 0);
        s.match_available = 0;
        s.match_length = zlib_Pako_trees.MIN_MATCH - 1;
        s.strstart++;
        if (bflush) {
          zlib_deflate.flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return zlib_deflate.BS_NEED_MORE;
          }
        }
      } else if (s.match_available) {
        bflush = zlib_Pako_trees._tr_tally(s, 0, s.window[s.strstart - 1]);
        if (bflush) {
          zlib_deflate.flush_block_only(s, false);
        }
        s.strstart++;
        s.lookahead--;
        if (s.strm.avail_out === 0) {
          return zlib_deflate.BS_NEED_MORE;
        }
      } else {
        s.match_available = 1;
        s.strstart++;
        s.lookahead--;
      }
    }
    if (s.match_available) {
      bflush = zlib_Pako_trees._tr_tally(s, 0, s.window[s.strstart - 1]);
      s.match_available = 0;
    }
    s.insert = s.strstart < zlib_Pako_trees.MIN_MATCH - 1 ? s.strstart : zlib_Pako_trees.MIN_MATCH - 1;
    if (flush === zlib_constants.Z_FINISH) {
      zlib_deflate.flush_block_only(s, true);
      if (s.strm.avail_out === 0) {
        return zlib_deflate.BS_FINISH_STARTED;
      }
      return zlib_deflate.BS_FINISH_DONE;
    }
    if (s.last_lit) {
      zlib_deflate.flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return zlib_deflate.BS_NEED_MORE;
      }
    }
    return zlib_deflate.BS_BLOCK_DONE;
  }
  static deflate_rle(s, flush) {
    let bflush;
    let prev;
    let scan;
    let strend;
    const _win = s.window;
    for (; ; ) {
      if (s.lookahead <= zlib_Pako_trees.MAX_MATCH) {
        zlib_deflate.fill_window(s);
        if (s.lookahead <= zlib_Pako_trees.MAX_MATCH && flush === zlib_constants.Z_NO_FLUSH) {
          return zlib_deflate.BS_NEED_MORE;
        }
        if (s.lookahead === 0) {
          break;
        }
      }
      s.match_length = 0;
      if (s.lookahead >= zlib_Pako_trees.MIN_MATCH && s.strstart > 0) {
        scan = s.strstart - 1;
        prev = _win[scan];
        if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
          strend = s.strstart + zlib_Pako_trees.MAX_MATCH;
          do {
          } while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);
          s.match_length = zlib_Pako_trees.MAX_MATCH - (strend - scan);
          if (s.match_length > s.lookahead) {
            s.match_length = s.lookahead;
          }
        }
      }
      if (s.match_length >= zlib_Pako_trees.MIN_MATCH) {
        bflush = zlib_Pako_trees._tr_tally(s, 1, s.match_length - zlib_Pako_trees.MIN_MATCH);
        s.lookahead -= s.match_length;
        s.strstart += s.match_length;
        s.match_length = 0;
      } else {
        bflush = zlib_Pako_trees._tr_tally(s, 0, s.window[s.strstart]);
        s.lookahead--;
        s.strstart++;
      }
      if (bflush) {
        zlib_deflate.flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return zlib_deflate.BS_NEED_MORE;
        }
      }
    }
    s.insert = 0;
    if (flush === zlib_constants.Z_FINISH) {
      zlib_deflate.flush_block_only(s, true);
      if (s.strm.avail_out === 0) {
        return zlib_deflate.BS_FINISH_STARTED;
      }
      return zlib_deflate.BS_FINISH_DONE;
    }
    if (s.last_lit) {
      zlib_deflate.flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return zlib_deflate.BS_NEED_MORE;
      }
    }
    return zlib_deflate.BS_BLOCK_DONE;
  }
  static deflate_huff(s, flush) {
    let bflush;
    for (; ; ) {
      if (s.lookahead === 0) {
        zlib_deflate.fill_window(s);
        if (s.lookahead === 0) {
          if (flush === zlib_constants.Z_NO_FLUSH) {
            return zlib_deflate.BS_NEED_MORE;
          }
          break;
        }
      }
      s.match_length = 0;
      bflush = zlib_Pako_trees._tr_tally(s, 0, s.window[s.strstart]);
      s.lookahead--;
      s.strstart++;
      if (bflush) {
        zlib_deflate.flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return zlib_deflate.BS_NEED_MORE;
        }
      }
    }
    s.insert = 0;
    if (flush === zlib_constants.Z_FINISH) {
      zlib_deflate.flush_block_only(s, true);
      if (s.strm.avail_out === 0) {
        return zlib_deflate.BS_FINISH_STARTED;
      }
      return zlib_deflate.BS_FINISH_DONE;
    }
    if (s.last_lit) {
      zlib_deflate.flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return zlib_deflate.BS_NEED_MORE;
      }
    }
    return zlib_deflate.BS_BLOCK_DONE;
  }
  static lm_init(s) {
    s.window_size = 2 * s.w_size;
    zlib_Pako_trees.zero(s.head);
    s.max_lazy_match = zlib_deflate.configuration_table[s.level].max_lazy;
    s.good_match = zlib_deflate.configuration_table[s.level].good_length;
    s.nice_match = zlib_deflate.configuration_table[s.level].nice_length;
    s.max_chain_length = zlib_deflate.configuration_table[s.level].max_chain;
    s.strstart = 0;
    s.block_start = 0;
    s.lookahead = 0;
    s.insert = 0;
    s.match_length = s.prev_length = zlib_Pako_trees.MIN_MATCH - 1;
    s.match_available = 0;
    s.ins_h = 0;
  }
  static deflateResetKeep(strm) {
    if (!strm || !strm.state) {
      return zlib_deflate.err(strm, zlib_constants.Z_STREAM_ERROR);
    }
    strm.total_in = strm.total_out = 0;
    strm.data_type = zlib_constants.Z_UNKNOWN;
    let s = strm.state;
    s.pending = 0;
    s.pending_out = 0;
    if (s.wrap < 0) {
      s.wrap = -s.wrap;
    }
    s.status = s.wrap ? zlib_deflate.INIT_STATE : zlib_deflate.BUSY_STATE;
    strm.adler = s.wrap === 2 ? 0 : 1;
    s.last_flush = zlib_constants.Z_NO_FLUSH;
    zlib_Pako_trees._tr_init(s);
    return zlib_constants.Z_OK;
  }
  static deflateReset(strm) {
    const ret = zlib_deflate.deflateResetKeep(strm);
    if (ret === zlib_constants.Z_OK) {
      zlib_deflate.lm_init(strm.state);
    }
    return ret;
  }
  static deflateSetHeader(strm, head) {
    if (!strm || !strm.state) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    if (strm.state.wrap !== 2) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    strm.state.gzhead = head;
    return zlib_constants.Z_OK;
  }
  static deflateInit2(strm, level, method, windowBits, memLevel, strategy) {
    if (!strm) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    let wrap = 1;
    if (level === zlib_constants.Z_DEFAULT_COMPRESSION) {
      level = 6;
    }
    if (windowBits < 0) {
      wrap = 0;
      windowBits = -windowBits;
    } else if (windowBits > 15) {
      wrap = 2;
      windowBits -= 16;
    }
    if (memLevel < 1 || memLevel > zlib_deflate.MAX_MEM_LEVEL || method !== zlib_constants.Z_DEFLATED || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > zlib_constants.Z_FIXED) {
      return zlib_deflate.err(strm, zlib_constants.Z_STREAM_ERROR);
    }
    if (windowBits === 8) {
      windowBits = 9;
    }
    const s = new zlib_DeflateState();
    strm.state = s;
    s.strm = strm;
    s.wrap = wrap;
    s.gzhead = null;
    s.w_bits = windowBits;
    s.w_size = 1 << s.w_bits;
    s.w_mask = s.w_size - 1;
    s.hash_bits = memLevel + 7;
    s.hash_size = 1 << s.hash_bits;
    s.hash_mask = s.hash_size - 1;
    s.hash_shift = ~~((s.hash_bits + zlib_Pako_trees.MIN_MATCH - 1) / zlib_Pako_trees.MIN_MATCH);
    s.window = new Uint8Array(s.w_size * 2);
    s.head = new Uint16Array(s.hash_size);
    s.prev = new Uint16Array(s.w_size);
    s.lit_bufsize = 1 << memLevel + 6;
    s.pending_buf_size = s.lit_bufsize * 4;
    s.pending_buf = new Uint8Array(s.pending_buf_size);
    s.d_buf = 1 * s.lit_bufsize;
    s.l_buf = (1 + 2) * s.lit_bufsize;
    s.level = level;
    s.strategy = strategy;
    s.method = method;
    return zlib_deflate.deflateReset(strm);
  }
  static deflateInit(strm, level) {
    return zlib_deflate.deflateInit2(strm, level, zlib_constants.Z_DEFLATED, zlib_deflate.MAX_WBITS, zlib_deflate.DEF_MEM_LEVEL, zlib_constants.Z_DEFAULT_STRATEGY);
  }
  static deflate(strm, flush) {
    let beg, val;
    if (!strm || !strm.state || flush > zlib_constants.Z_BLOCK || flush < 0) {
      return strm ? zlib_deflate.err(strm, zlib_constants.Z_STREAM_ERROR) : zlib_constants.Z_STREAM_ERROR;
    }
    let s = strm.state;
    if (!strm.output || !strm.input && strm.avail_in !== 0 || s.status === zlib_deflate.FINISH_STATE && flush !== zlib_constants.Z_FINISH) {
      return zlib_deflate.err(strm, strm.avail_out === 0 ? zlib_constants.Z_BUF_ERROR : zlib_constants.Z_STREAM_ERROR);
    }
    s.strm = strm;
    const old_flush = s.last_flush;
    s.last_flush = flush;
    if (s.status === zlib_deflate.INIT_STATE) {
      if (s.wrap === 2) {
        strm.adler = 0;
        zlib_deflate.put_byte(s, 31);
        zlib_deflate.put_byte(s, 139);
        zlib_deflate.put_byte(s, 8);
        if (!s.gzhead) {
          zlib_deflate.put_byte(s, 0);
          zlib_deflate.put_byte(s, 0);
          zlib_deflate.put_byte(s, 0);
          zlib_deflate.put_byte(s, 0);
          zlib_deflate.put_byte(s, 0);
          zlib_deflate.put_byte(s, s.level === 9 ? 2 : s.strategy >= zlib_constants.Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
          zlib_deflate.put_byte(s, zlib_deflate.OS_CODE);
          s.status = zlib_deflate.BUSY_STATE;
        } else {
          zlib_deflate.put_byte(s, (s.gzhead.text ? 1 : 0) + (s.gzhead.hcrc ? 2 : 0) + (!s.gzhead.extra ? 0 : 4) + (!s.gzhead.name ? 0 : 8) + (!s.gzhead.comment ? 0 : 16));
          zlib_deflate.put_byte(s, s.gzhead.time & 255);
          zlib_deflate.put_byte(s, s.gzhead.time >> 8 & 255);
          zlib_deflate.put_byte(s, s.gzhead.time >> 16 & 255);
          zlib_deflate.put_byte(s, s.gzhead.time >> 24 & 255);
          zlib_deflate.put_byte(s, s.level === 9 ? 2 : s.strategy >= zlib_constants.Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
          zlib_deflate.put_byte(s, s.gzhead.os & 255);
          if (s.gzhead.extra && s.gzhead.extra.length) {
            zlib_deflate.put_byte(s, s.gzhead.extra.length & 255);
            zlib_deflate.put_byte(s, s.gzhead.extra.length >> 8 & 255);
          }
          if (s.gzhead.hcrc) {
            strm.adler = zlib_crc32.crc32(strm.adler, s.pending_buf, s.pending, 0);
          }
          s.gzindex = 0;
          s.status = zlib_deflate.EXTRA_STATE;
        }
      } else {
        let header = zlib_constants.Z_DEFLATED + (s.w_bits - 8 << 4) << 8;
        let level_flags = -1;
        if (s.strategy >= zlib_constants.Z_HUFFMAN_ONLY || s.level < 2) {
          level_flags = 0;
        } else if (s.level < 6) {
          level_flags = 1;
        } else if (s.level === 6) {
          level_flags = 2;
        } else {
          level_flags = 3;
        }
        header |= level_flags << 6;
        if (s.strstart !== 0) {
          header |= zlib_deflate.PRESET_DICT;
        }
        header += 31 - header % 31;
        s.status = zlib_deflate.BUSY_STATE;
        zlib_deflate.putShortMSB(s, header);
        if (s.strstart !== 0) {
          zlib_deflate.putShortMSB(s, strm.adler >>> 16);
          zlib_deflate.putShortMSB(s, strm.adler & 65535);
        }
        strm.adler = 1;
      }
    }
    if (s.status === zlib_deflate.EXTRA_STATE) {
      if (s.gzhead.extra) {
        beg = s.pending;
        while (s.gzindex < (s.gzhead.extra.length & 65535)) {
          if (s.pending === s.pending_buf_size) {
            if (s.gzhead.hcrc && s.pending > beg) {
              strm.adler = zlib_crc32.crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
            }
            zlib_deflate.flush_pending(strm);
            beg = s.pending;
            if (s.pending === s.pending_buf_size) {
              break;
            }
          }
          zlib_deflate.put_byte(s, s.gzhead.extra[s.gzindex] & 255);
          s.gzindex++;
        }
        if (s.gzhead.hcrc && s.pending > beg) {
          strm.adler = zlib_crc32.crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
        }
        if (s.gzindex === s.gzhead.extra.length) {
          s.gzindex = 0;
          s.status = zlib_deflate.NAME_STATE;
        }
      } else {
        s.status = zlib_deflate.NAME_STATE;
      }
    }
    if (s.status === zlib_deflate.NAME_STATE) {
      if (s.gzhead.name) {
        beg = s.pending;
        do {
          if (s.pending === s.pending_buf_size) {
            if (s.gzhead.hcrc && s.pending > beg) {
              strm.adler = zlib_crc32.crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
            }
            zlib_deflate.flush_pending(strm);
            beg = s.pending;
            if (s.pending === s.pending_buf_size) {
              val = 1;
              break;
            }
          }
          if (s.gzindex < s.gzhead.name.length) {
            val = s.gzhead.name.charCodeAt(s.gzindex++) & 255;
          } else {
            val = 0;
          }
          zlib_deflate.put_byte(s, val);
        } while (val !== 0);
        if (s.gzhead.hcrc && s.pending > beg) {
          strm.adler = zlib_crc32.crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
        }
        if (val === 0) {
          s.gzindex = 0;
          s.status = zlib_deflate.COMMENT_STATE;
        }
      } else {
        s.status = zlib_deflate.COMMENT_STATE;
      }
    }
    if (s.status === zlib_deflate.COMMENT_STATE) {
      if (s.gzhead.comment) {
        beg = s.pending;
        do {
          if (s.pending === s.pending_buf_size) {
            if (s.gzhead.hcrc && s.pending > beg) {
              strm.adler = zlib_crc32.crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
            }
            zlib_deflate.flush_pending(strm);
            beg = s.pending;
            if (s.pending === s.pending_buf_size) {
              val = 1;
              break;
            }
          }
          if (s.gzindex < s.gzhead.comment.length) {
            val = s.gzhead.comment.charCodeAt(s.gzindex++) & 255;
          } else {
            val = 0;
          }
          zlib_deflate.put_byte(s, val);
        } while (val !== 0);
        if (s.gzhead.hcrc && s.pending > beg) {
          strm.adler = zlib_crc32.crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
        }
        if (val === 0) {
          s.status = zlib_deflate.HCRC_STATE;
        }
      } else {
        s.status = zlib_deflate.HCRC_STATE;
      }
    }
    if (s.status === zlib_deflate.HCRC_STATE) {
      if (s.gzhead.hcrc) {
        if (s.pending + 2 > s.pending_buf_size) {
          zlib_deflate.flush_pending(strm);
        }
        if (s.pending + 2 <= s.pending_buf_size) {
          zlib_deflate.put_byte(s, strm.adler & 255);
          zlib_deflate.put_byte(s, strm.adler >> 8 & 255);
          strm.adler = 0;
          s.status = zlib_deflate.BUSY_STATE;
        }
      } else {
        s.status = zlib_deflate.BUSY_STATE;
      }
    }
    if (s.pending !== 0) {
      zlib_deflate.flush_pending(strm);
      if (strm.avail_out === 0) {
        s.last_flush = -1;
        return zlib_constants.Z_OK;
      }
    } else if (strm.avail_in === 0 && zlib_deflate.rank(flush) <= zlib_deflate.rank(old_flush) && flush !== zlib_constants.Z_FINISH) {
      return zlib_deflate.err(strm, zlib_constants.Z_BUF_ERROR);
    }
    if (s.status === zlib_deflate.FINISH_STATE && strm.avail_in !== 0) {
      return zlib_deflate.err(strm, zlib_constants.Z_BUF_ERROR);
    }
    if (strm.avail_in !== 0 || s.lookahead !== 0 || flush !== zlib_constants.Z_NO_FLUSH && s.status !== zlib_deflate.FINISH_STATE) {
      let bstate = s.strategy === zlib_constants.Z_HUFFMAN_ONLY ? zlib_deflate.deflate_huff(s, flush) : s.strategy === zlib_constants.Z_RLE ? zlib_deflate.deflate_rle(s, flush) : zlib_deflate.configuration_table[s.level].func(s, flush);
      if (bstate === zlib_deflate.BS_FINISH_STARTED || bstate === zlib_deflate.BS_FINISH_DONE) {
        s.status = zlib_deflate.FINISH_STATE;
      }
      if (bstate === zlib_deflate.BS_NEED_MORE || bstate === zlib_deflate.BS_FINISH_STARTED) {
        if (strm.avail_out === 0) {
          s.last_flush = -1;
        }
        return zlib_constants.Z_OK;
      }
      if (bstate === zlib_deflate.BS_BLOCK_DONE) {
        if (flush === zlib_constants.Z_PARTIAL_FLUSH) {
          zlib_Pako_trees._tr_align(s);
        } else if (flush !== zlib_constants.Z_BLOCK) {
          zlib_Pako_trees._tr_stored_block(s, 0, 0, false);
          if (flush === zlib_constants.Z_FULL_FLUSH) {
            zlib_Pako_trees.zero(s.head);
            if (s.lookahead === 0) {
              s.strstart = 0;
              s.block_start = 0;
              s.insert = 0;
            }
          }
        }
        zlib_deflate.flush_pending(strm);
        if (strm.avail_out === 0) {
          s.last_flush = -1;
          return zlib_constants.Z_OK;
        }
      }
    }
    if (flush !== zlib_constants.Z_FINISH) {
      return zlib_constants.Z_OK;
    }
    if (s.wrap <= 0) {
      return zlib_constants.Z_STREAM_END;
    }
    if (s.wrap === 2) {
      zlib_deflate.put_byte(s, strm.adler & 255);
      zlib_deflate.put_byte(s, strm.adler >> 8 & 255);
      zlib_deflate.put_byte(s, strm.adler >> 16 & 255);
      zlib_deflate.put_byte(s, strm.adler >> 24 & 255);
      zlib_deflate.put_byte(s, strm.total_in & 255);
      zlib_deflate.put_byte(s, strm.total_in >> 8 & 255);
      zlib_deflate.put_byte(s, strm.total_in >> 16 & 255);
      zlib_deflate.put_byte(s, strm.total_in >> 24 & 255);
    } else {
      zlib_deflate.putShortMSB(s, strm.adler >>> 16);
      zlib_deflate.putShortMSB(s, strm.adler & 65535);
    }
    zlib_deflate.flush_pending(strm);
    if (s.wrap > 0) {
      s.wrap = -s.wrap;
    }
    return s.pending !== 0 ? zlib_constants.Z_OK : zlib_constants.Z_STREAM_END;
  }
  static deflateEnd(strm) {
    if (!strm || !strm.state) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    let status = strm.state.status;
    if (status !== zlib_deflate.INIT_STATE && status !== zlib_deflate.EXTRA_STATE && status !== zlib_deflate.NAME_STATE && status !== zlib_deflate.COMMENT_STATE && status !== zlib_deflate.HCRC_STATE && status !== zlib_deflate.BUSY_STATE && status !== zlib_deflate.FINISH_STATE) {
      return zlib_deflate.err(strm, zlib_constants.Z_STREAM_ERROR);
    }
    strm.state = null;
    return status === zlib_deflate.BUSY_STATE ? zlib_deflate.err(strm, zlib_constants.Z_DATA_ERROR) : zlib_constants.Z_OK;
  }
  static deflateSetDictionary(strm, dictionary) {
    let dictLength = dictionary.length;
    if (!strm || !strm.state) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    const s = strm.state;
    const wrap = s.wrap;
    if (wrap === 2 || wrap === 1 && s.status !== zlib_deflate.INIT_STATE || s.lookahead) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    if (wrap === 1) {
      strm.adler = zlib_adler32.adler32(strm.adler, dictionary, dictLength, 0);
    }
    s.wrap = 0;
    if (dictLength >= s.w_size) {
      if (wrap === 0) {
        zlib_Pako_trees.zero(s.head);
        s.strstart = 0;
        s.block_start = 0;
        s.insert = 0;
      }
      let tmpDict = new Uint8Array(s.w_size);
      tmpDict.set(dictionary.subarray(dictLength - s.w_size, dictLength), 0);
      dictionary = tmpDict;
      dictLength = s.w_size;
    }
    const avail = strm.avail_in;
    const next = strm.next_in;
    const input = strm.input;
    strm.avail_in = dictLength;
    strm.next_in = 0;
    strm.input = dictionary;
    zlib_deflate.fill_window(s);
    while (s.lookahead >= zlib_Pako_trees.MIN_MATCH) {
      let str = s.strstart;
      let n = s.lookahead - (zlib_Pako_trees.MIN_MATCH - 1);
      do {
        s.ins_h = zlib_deflate.HASH(s, s.ins_h, s.window[str + zlib_Pako_trees.MIN_MATCH - 1]);
        s.prev[str & s.w_mask] = s.head[s.ins_h];
        s.head[s.ins_h] = str;
        str++;
      } while (--n);
      s.strstart = str;
      s.lookahead = zlib_Pako_trees.MIN_MATCH - 1;
      zlib_deflate.fill_window(s);
    }
    s.strstart += s.lookahead;
    s.block_start = s.strstart;
    s.insert = s.lookahead;
    s.lookahead = 0;
    s.match_length = s.prev_length = zlib_Pako_trees.MIN_MATCH - 1;
    s.match_available = 0;
    strm.next_in = next;
    strm.input = input;
    strm.avail_in = avail;
    s.wrap = wrap;
    return zlib_constants.Z_OK;
  }
};
zlib_deflate.MAX_MEM_LEVEL = 9;
zlib_deflate.MAX_WBITS = 15;
zlib_deflate.DEF_MEM_LEVEL = 8;
zlib_deflate.LENGTH_CODES = 29;
zlib_deflate.LITERALS = 256;
zlib_deflate.L_CODES = zlib_deflate.LITERALS + 1 + zlib_deflate.LENGTH_CODES;
zlib_deflate.D_CODES = 30;
zlib_deflate.BL_CODES = 19;
zlib_deflate.HEAP_SIZE = 2 * zlib_deflate.L_CODES + 1;
zlib_deflate.MAX_BITS = 15;
zlib_deflate.MIN_MATCH = 3;
zlib_deflate.MAX_MATCH = 258;
zlib_deflate.MIN_LOOKAHEAD = zlib_deflate.MAX_MATCH + zlib_deflate.MIN_MATCH + 1;
zlib_deflate.PRESET_DICT = 32;
zlib_deflate.INIT_STATE = 42;
zlib_deflate.EXTRA_STATE = 69;
zlib_deflate.NAME_STATE = 73;
zlib_deflate.COMMENT_STATE = 91;
zlib_deflate.HCRC_STATE = 103;
zlib_deflate.BUSY_STATE = 113;
zlib_deflate.FINISH_STATE = 666;
zlib_deflate.BS_NEED_MORE = 1;
zlib_deflate.BS_BLOCK_DONE = 2;
zlib_deflate.BS_FINISH_STARTED = 3;
zlib_deflate.BS_FINISH_DONE = 4;
zlib_deflate.OS_CODE = 3;
zlib_deflate.deflate_fast = (s, flush) => {
  let hash_head;
  let bflush;
  for (; ; ) {
    if (s.lookahead < zlib_deflate.MIN_LOOKAHEAD) {
      zlib_deflate.fill_window(s);
      if (s.lookahead < zlib_deflate.MIN_LOOKAHEAD && flush === zlib_constants.Z_NO_FLUSH) {
        return zlib_deflate.BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break;
      }
    }
    hash_head = 0;
    if (s.lookahead >= zlib_Pako_trees.MIN_MATCH) {
      s.ins_h = zlib_deflate.HASH(s, s.ins_h, s.window[s.strstart + zlib_Pako_trees.MIN_MATCH - 1]);
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
    }
    if (hash_head !== 0 && s.strstart - hash_head <= s.w_size - zlib_deflate.MIN_LOOKAHEAD) {
      s.match_length = zlib_deflate.longest_match(s, hash_head);
    }
    if (s.match_length >= zlib_Pako_trees.MIN_MATCH) {
      bflush = zlib_Pako_trees._tr_tally(s, s.strstart - s.match_start, s.match_length - zlib_Pako_trees.MIN_MATCH);
      s.lookahead -= s.match_length;
      if (s.match_length <= s.max_lazy_match && s.lookahead >= zlib_Pako_trees.MIN_MATCH) {
        s.match_length--;
        do {
          s.strstart++;
          s.ins_h = zlib_deflate.HASH(s, s.ins_h, s.window[s.strstart + zlib_Pako_trees.MIN_MATCH - 1]);
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
        } while (--s.match_length !== 0);
        s.strstart++;
      } else {
        s.strstart += s.match_length;
        s.match_length = 0;
        s.ins_h = s.window[s.strstart];
        s.ins_h = zlib_deflate.HASH(s, s.ins_h, s.window[s.strstart + 1]);
      }
    } else {
      bflush = zlib_Pako_trees._tr_tally(s, 0, s.window[s.strstart]);
      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      zlib_deflate.flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return zlib_deflate.BS_NEED_MORE;
      }
    }
  }
  s.insert = s.strstart < zlib_Pako_trees.MIN_MATCH - 1 ? s.strstart : zlib_Pako_trees.MIN_MATCH - 1;
  if (flush === zlib_constants.Z_FINISH) {
    zlib_deflate.flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return zlib_deflate.BS_FINISH_STARTED;
    }
    return zlib_deflate.BS_FINISH_DONE;
  }
  if (s.last_lit) {
    zlib_deflate.flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return zlib_deflate.BS_NEED_MORE;
    }
  }
  return zlib_deflate.BS_BLOCK_DONE;
};
zlib_deflate.configuration_table = [
  new zlib_config(0, 0, 0, 0, zlib_deflate.deflate_stored),
  new zlib_config(4, 4, 8, 4, zlib_deflate.deflate_fast),
  new zlib_config(4, 5, 16, 8, zlib_deflate.deflate_fast),
  new zlib_config(4, 6, 32, 32, zlib_deflate.deflate_fast),
  new zlib_config(4, 4, 16, 16, zlib_deflate.deflate_slow),
  new zlib_config(8, 16, 32, 32, zlib_deflate.deflate_slow),
  new zlib_config(8, 16, 128, 128, zlib_deflate.deflate_slow),
  new zlib_config(8, 32, 128, 256, zlib_deflate.deflate_slow),
  new zlib_config(32, 128, 258, 1024, zlib_deflate.deflate_slow),
  new zlib_config(32, 258, 258, 4096, zlib_deflate.deflate_slow)
];

// obj/full/Pako/zlib/trees.js
"use strict";
var zlib_StaticTreeDesc = class {
  constructor(static_tree, extra_bits, extra_base, elems, max_length) {
    this.static_tree = static_tree;
    this.extra_bits = extra_bits;
    this.extra_base = extra_base;
    this.elems = elems;
    this.max_length = max_length;
    this.has_stree = static_tree != null && static_tree.length > 0;
  }
};
var zlib_TreeDesc = class {
  constructor(dyn_tree, stat_desc) {
    this.max_code = 0;
    this.dyn_tree = dyn_tree;
    this.max_code = 0;
    this.stat_desc = stat_desc;
  }
};
var zlib_Pako_trees = class {
  static zero(buf) {
    let len = buf.length;
    while (--len >= 0) {
      buf[len] = 0;
    }
  }
  static Zeroinit() {
    zlib_Pako_trees.zero(zlib_Pako_trees.static_ltree);
    zlib_Pako_trees.zero(zlib_Pako_trees.base_dist);
    zlib_Pako_trees.zero(zlib_Pako_trees.base_length);
    zlib_Pako_trees.zero(zlib_Pako_trees._length_code);
    zlib_Pako_trees.zero(zlib_Pako_trees._dist_code);
    zlib_Pako_trees.zero(zlib_Pako_trees.static_dtree);
    return true;
  }
  static d_code(dist) {
    return dist < 256 ? zlib_Pako_trees._dist_code[dist] : zlib_Pako_trees._dist_code[256 + (dist >>> 7)];
  }
  static put_short(s, w) {
    s.pending_buf[s.pending++] = w & 255;
    s.pending_buf[s.pending++] = w >>> 8 & 255;
  }
  static send_code(s, c, tree) {
    zlib_Pako_trees.send_bits(s, tree[c * 2], tree[c * 2 + 1]);
  }
  static bi_reverse(code, len) {
    let res = 0;
    do {
      res |= code & 1;
      code >>>= 1;
      res <<= 1;
    } while (--len > 0);
    return res >>> 1;
  }
  static bi_flush(s) {
    if (s.bi_valid === 16) {
      zlib_Pako_trees.put_short(s, s.bi_buf);
      s.bi_buf = 0;
      s.bi_valid = 0;
    } else if (s.bi_valid >= 8) {
      s.pending_buf[s.pending++] = s.bi_buf & 255;
      s.bi_buf >>= 8;
      s.bi_valid -= 8;
    }
  }
  static gen_codes(tree, max_code, bl_count) {
    const next_code = new Array(zlib_Pako_trees.MAX_BITS + 1);
    let code = 0;
    let bits;
    let n;
    for (bits = 1; bits <= zlib_Pako_trees.MAX_BITS; bits++) {
      next_code[bits] = code = code + bl_count[bits - 1] << 1;
    }
    for (n = 0; n <= max_code; n++) {
      let len = tree[n * 2 + 1];
      if (len === 0) {
        continue;
      }
      tree[n * 2] = zlib_Pako_trees.bi_reverse(next_code[len]++, len);
    }
  }
  static tr_static_init() {
    let n;
    let bits;
    let length;
    let code;
    let dist;
    const bl_count = new Uint16Array(zlib_Pako_trees.MAX_BITS + 1);
    length = 0;
    for (code = 0; code < zlib_Pako_trees.LENGTH_CODES - 1; code++) {
      zlib_Pako_trees.base_length[code] = length;
      for (n = 0; n < 1 << zlib_Pako_trees.extra_lbits[code]; n++) {
        zlib_Pako_trees._length_code[length++] = code;
      }
    }
    zlib_Pako_trees._length_code[length - 1] = code;
    dist = 0;
    for (code = 0; code < 16; code++) {
      zlib_Pako_trees.base_dist[code] = dist;
      for (n = 0; n < 1 << zlib_Pako_trees.extra_dbits[code]; n++) {
        zlib_Pako_trees._dist_code[dist++] = code;
      }
    }
    dist >>= 7;
    for (; code < zlib_Pako_trees.D_CODES; code++) {
      zlib_Pako_trees.base_dist[code] = dist << 7;
      for (n = 0; n < 1 << zlib_Pako_trees.extra_dbits[code] - 7; n++) {
        zlib_Pako_trees._dist_code[256 + dist++] = code;
      }
    }
    for (bits = 0; bits <= zlib_Pako_trees.MAX_BITS; bits++) {
      bl_count[bits] = 0;
    }
    n = 0;
    while (n <= 143) {
      zlib_Pako_trees.static_ltree[n * 2 + 1] = 8;
      n++;
      bl_count[8]++;
    }
    while (n <= 255) {
      zlib_Pako_trees.static_ltree[n * 2 + 1] = 9;
      n++;
      bl_count[9]++;
    }
    while (n <= 279) {
      zlib_Pako_trees.static_ltree[n * 2 + 1] = 7;
      n++;
      bl_count[7]++;
    }
    while (n <= 287) {
      zlib_Pako_trees.static_ltree[n * 2 + 1] = 8;
      n++;
      bl_count[8]++;
    }
    zlib_Pako_trees.gen_codes(zlib_Pako_trees.static_ltree, zlib_Pako_trees.L_CODES + 1, bl_count);
    for (n = 0; n < zlib_Pako_trees.D_CODES; n++) {
      zlib_Pako_trees.static_dtree[n * 2 + 1] = 5;
      zlib_Pako_trees.static_dtree[n * 2] = zlib_Pako_trees.bi_reverse(n, 5);
    }
    zlib_Pako_trees.static_l_desc = new zlib_StaticTreeDesc(zlib_Pako_trees.static_ltree, zlib_Pako_trees.extra_lbits, zlib_Pako_trees.LITERALS + 1, zlib_Pako_trees.L_CODES, zlib_Pako_trees.MAX_BITS);
    zlib_Pako_trees.static_d_desc = new zlib_StaticTreeDesc(zlib_Pako_trees.static_dtree, zlib_Pako_trees.extra_dbits, 0, zlib_Pako_trees.D_CODES, zlib_Pako_trees.MAX_BITS);
    zlib_Pako_trees.static_bl_desc = new zlib_StaticTreeDesc(new Uint16Array(0), zlib_Pako_trees.extra_blbits, 0, zlib_Pako_trees.BL_CODES, zlib_Pako_trees.MAX_BL_BITS);
  }
  static init_block(s) {
    let n;
    for (n = 0; n < zlib_Pako_trees.L_CODES; n++) {
      s.dyn_ltree[n * 2] = 0;
    }
    for (n = 0; n < zlib_Pako_trees.D_CODES; n++) {
      s.dyn_dtree[n * 2] = 0;
    }
    for (n = 0; n < zlib_Pako_trees.BL_CODES; n++) {
      s.bl_tree[n * 2] = 0;
    }
    s.dyn_ltree[zlib_Pako_trees.END_BLOCK * 2] = 1;
    s.opt_len = s.static_len = 0;
    s.last_lit = s.matches = 0;
  }
  static bi_windup(s) {
    if (s.bi_valid > 8) {
      zlib_Pako_trees.put_short(s, s.bi_buf);
    } else if (s.bi_valid > 0) {
      s.pending_buf[s.pending++] = s.bi_buf;
    }
    s.bi_buf = 0;
    s.bi_valid = 0;
  }
  static copy_block(s, buf, len, header) {
    zlib_Pako_trees.bi_windup(s);
    if (header) {
      zlib_Pako_trees.put_short(s, len);
      zlib_Pako_trees.put_short(s, ~len);
    }
    s.pending_buf.set(s.window.subarray(buf, buf + len), s.pending);
    s.pending += len;
  }
  static smaller(tree, n, m, depth) {
    const _n2 = n * 2;
    const _m2 = m * 2;
    return tree[_n2] < tree[_m2] || tree[_n2] === tree[_m2] && depth[n] <= depth[m];
  }
  static pqdownheap(s, tree, k) {
    const v = s.heap[k];
    let j = k << 1;
    while (j <= s.heap_len) {
      if (j < s.heap_len && zlib_Pako_trees.smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
        j++;
      }
      if (zlib_Pako_trees.smaller(tree, v, s.heap[j], s.depth)) {
        break;
      }
      s.heap[k] = s.heap[j];
      k = j;
      j <<= 1;
    }
    s.heap[k] = v;
  }
  static compress_block(s, ltree, dtree) {
    let dist;
    let lc;
    let lx = 0;
    let code;
    let extra;
    if (s.last_lit !== 0) {
      do {
        dist = s.pending_buf[s.d_buf + lx * 2] << 8 | s.pending_buf[s.d_buf + lx * 2 + 1];
        lc = s.pending_buf[s.l_buf + lx];
        lx++;
        if (dist === 0) {
          zlib_Pako_trees.send_code(s, lc, ltree);
        } else {
          code = zlib_Pako_trees._length_code[lc];
          zlib_Pako_trees.send_code(s, code + zlib_Pako_trees.LITERALS + 1, ltree);
          extra = zlib_Pako_trees.extra_lbits[code];
          if (extra !== 0) {
            lc -= zlib_Pako_trees.base_length[code];
            zlib_Pako_trees.send_bits(s, lc, extra);
          }
          dist--;
          code = zlib_Pako_trees.d_code(dist);
          zlib_Pako_trees.send_code(s, code, dtree);
          extra = zlib_Pako_trees.extra_dbits[code];
          if (extra !== 0) {
            dist -= zlib_Pako_trees.base_dist[code];
            zlib_Pako_trees.send_bits(s, dist, extra);
          }
        }
      } while (lx < s.last_lit);
    }
    zlib_Pako_trees.send_code(s, zlib_Pako_trees.END_BLOCK, ltree);
  }
  static build_tree(s, desc) {
    const tree = desc.dyn_tree;
    const stree = desc.stat_desc.static_tree;
    const has_stree = desc.stat_desc.has_stree;
    const elems = desc.stat_desc.elems;
    let n, m;
    let max_code = -1;
    let node;
    s.heap_len = 0;
    s.heap_max = zlib_Pako_trees.HEAP_SIZE;
    for (n = 0; n < elems; n++) {
      if (tree[n * 2] !== 0) {
        s.heap[++s.heap_len] = max_code = n;
        s.depth[n] = 0;
      } else {
        tree[n * 2 + 1] = 0;
      }
    }
    while (s.heap_len < 2) {
      node = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0;
      tree[node * 2] = 1;
      s.depth[node] = 0;
      s.opt_len--;
      if (has_stree) {
        s.static_len -= stree[node * 2 + 1];
      }
    }
    desc.max_code = max_code;
    for (n = s.heap_len >> 1; n >= 1; n--) {
      zlib_Pako_trees.pqdownheap(s, tree, n);
    }
    node = elems;
    do {
      n = s.heap[1];
      s.heap[1] = s.heap[s.heap_len--];
      zlib_Pako_trees.pqdownheap(s, tree, 1);
      m = s.heap[1];
      s.heap[--s.heap_max] = n;
      s.heap[--s.heap_max] = m;
      tree[node * 2] = tree[n * 2] + tree[m * 2];
      s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
      tree[n * 2 + 1] = tree[m * 2 + 1] = node;
      s.heap[1] = node++;
      zlib_Pako_trees.pqdownheap(s, tree, 1);
    } while (s.heap_len >= 2);
    s.heap[--s.heap_max] = s.heap[1];
    zlib_Pako_trees.gen_bitlen(s, desc);
    zlib_Pako_trees.gen_codes(tree, max_code, s.bl_count);
  }
  static scan_tree(s, tree, max_code) {
    let n;
    let prevlen = -1;
    let curlen;
    let nextlen = tree[0 * 2 + 1];
    let count = 0;
    let max_count = 7;
    let min_count = 4;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    }
    tree[(max_code + 1) * 2 + 1] = 65535;
    for (n = 0; n <= max_code; n++) {
      curlen = nextlen;
      nextlen = tree[(n + 1) * 2 + 1];
      if (++count < max_count && curlen === nextlen) {
        continue;
      } else if (count < min_count) {
        s.bl_tree[curlen * 2] += count;
      } else if (curlen !== 0) {
        if (curlen !== prevlen) {
          s.bl_tree[curlen * 2]++;
        }
        s.bl_tree[zlib_Pako_trees.REP_3_6 * 2]++;
      } else if (count <= 10) {
        s.bl_tree[zlib_Pako_trees.REPZ_3_10 * 2]++;
      } else {
        s.bl_tree[zlib_Pako_trees.REPZ_11_138 * 2]++;
      }
      count = 0;
      prevlen = curlen;
      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      } else if (curlen === nextlen) {
        max_count = 6;
        min_count = 3;
      } else {
        max_count = 7;
        min_count = 4;
      }
    }
  }
  static send_tree(s, tree, max_code) {
    let n;
    let prevlen = -1;
    let curlen;
    let nextlen = tree[0 * 2 + 1];
    let count = 0;
    let max_count = 7;
    let min_count = 4;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    }
    for (n = 0; n <= max_code; n++) {
      curlen = nextlen;
      nextlen = tree[(n + 1) * 2 + 1];
      if (++count < max_count && curlen === nextlen) {
        continue;
      } else if (count < min_count) {
        do {
          zlib_Pako_trees.send_code(s, curlen, s.bl_tree);
        } while (--count !== 0);
      } else if (curlen !== 0) {
        if (curlen !== prevlen) {
          zlib_Pako_trees.send_code(s, curlen, s.bl_tree);
          count--;
        }
        zlib_Pako_trees.send_code(s, zlib_Pako_trees.REP_3_6, s.bl_tree);
        zlib_Pako_trees.send_bits(s, count - 3, 2);
      } else if (count <= 10) {
        zlib_Pako_trees.send_code(s, zlib_Pako_trees.REPZ_3_10, s.bl_tree);
        zlib_Pako_trees.send_bits(s, count - 3, 3);
      } else {
        zlib_Pako_trees.send_code(s, zlib_Pako_trees.REPZ_11_138, s.bl_tree);
        zlib_Pako_trees.send_bits(s, count - 11, 7);
      }
      count = 0;
      prevlen = curlen;
      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      } else if (curlen === nextlen) {
        max_count = 6;
        min_count = 3;
      } else {
        max_count = 7;
        min_count = 4;
      }
    }
  }
  static build_bl_tree(s) {
    let max_blindex;
    zlib_Pako_trees.scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
    zlib_Pako_trees.scan_tree(s, s.dyn_dtree, s.d_desc.max_code);
    zlib_Pako_trees.build_tree(s, s.bl_desc);
    for (max_blindex = zlib_Pako_trees.BL_CODES - 1; max_blindex >= 3; max_blindex--) {
      if (s.bl_tree[zlib_Pako_trees.bl_order[max_blindex] * 2 + 1] !== 0) {
        break;
      }
    }
    s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
    return max_blindex;
  }
  static send_all_trees(s, lcodes, dcodes, blcodes) {
    let rank;
    zlib_Pako_trees.send_bits(s, lcodes - 257, 5);
    zlib_Pako_trees.send_bits(s, dcodes - 1, 5);
    zlib_Pako_trees.send_bits(s, blcodes - 4, 4);
    for (rank = 0; rank < blcodes; rank++) {
      zlib_Pako_trees.send_bits(s, s.bl_tree[zlib_Pako_trees.bl_order[rank] * 2 + 1], 3);
    }
    zlib_Pako_trees.send_tree(s, s.dyn_ltree, lcodes - 1);
    zlib_Pako_trees.send_tree(s, s.dyn_dtree, dcodes - 1);
  }
  static detect_data_type(s) {
    let black_mask = 4093624447;
    let n;
    for (n = 0; n <= 31; n++, black_mask >>>= 1) {
      if (black_mask & 1 && s.dyn_ltree[n * 2] !== 0) {
        return zlib_constants.Z_BINARY;
      }
    }
    if (s.dyn_ltree[9 * 2] !== 0 || s.dyn_ltree[10 * 2] !== 0 || s.dyn_ltree[13 * 2] !== 0) {
      return zlib_constants.Z_TEXT;
    }
    for (n = 32; n < zlib_Pako_trees.LITERALS; n++) {
      if (s.dyn_ltree[n * 2] !== 0) {
        return zlib_constants.Z_TEXT;
      }
    }
    return zlib_constants.Z_BINARY;
  }
  static _tr_init(s) {
    if (!zlib_Pako_trees.static_init_done) {
      zlib_Pako_trees.tr_static_init();
      zlib_Pako_trees.static_init_done = true;
    }
    s.l_desc = new zlib_TreeDesc(s.dyn_ltree, zlib_Pako_trees.static_l_desc);
    s.d_desc = new zlib_TreeDesc(s.dyn_dtree, zlib_Pako_trees.static_d_desc);
    s.bl_desc = new zlib_TreeDesc(s.bl_tree, zlib_Pako_trees.static_bl_desc);
    s.bi_buf = 0;
    s.bi_valid = 0;
    zlib_Pako_trees.init_block(s);
  }
  static _tr_stored_block(s, buf, stored_len, last) {
    zlib_Pako_trees.send_bits(s, (zlib_Pako_trees.STORED_BLOCK << 1) + (last ? 1 : 0), 3);
    zlib_Pako_trees.copy_block(s, buf, stored_len, true);
  }
  static _tr_align(s) {
    zlib_Pako_trees.send_bits(s, zlib_Pako_trees.STATIC_TREES << 1, 3);
    zlib_Pako_trees.send_code(s, zlib_Pako_trees.END_BLOCK, zlib_Pako_trees.static_ltree);
    zlib_Pako_trees.bi_flush(s);
  }
  static _tr_flush_block(s, buf, stored_len, last) {
    let opt_lenb;
    let static_lenb;
    let max_blindex = 0;
    if (s.level > 0) {
      if (s.strm.data_type === zlib_constants.Z_UNKNOWN) {
        s.strm.data_type = zlib_Pako_trees.detect_data_type(s);
      }
      zlib_Pako_trees.build_tree(s, s.l_desc);
      zlib_Pako_trees.build_tree(s, s.d_desc);
      max_blindex = zlib_Pako_trees.build_bl_tree(s);
      opt_lenb = s.opt_len + 3 + 7 >>> 3;
      static_lenb = s.static_len + 3 + 7 >>> 3;
      if (static_lenb <= opt_lenb) {
        opt_lenb = static_lenb;
      }
    } else {
      opt_lenb = static_lenb = stored_len + 5;
    }
    if (stored_len + 4 <= opt_lenb && buf !== -1) {
      zlib_Pako_trees._tr_stored_block(s, buf, stored_len, last);
    } else if (s.strategy === zlib_constants.Z_FIXED || static_lenb === opt_lenb) {
      zlib_Pako_trees.send_bits(s, (zlib_Pako_trees.STATIC_TREES << 1) + (last ? 1 : 0), 3);
      zlib_Pako_trees.compress_block(s, zlib_Pako_trees.static_ltree, zlib_Pako_trees.static_dtree);
    } else {
      zlib_Pako_trees.send_bits(s, (zlib_Pako_trees.DYN_TREES << 1) + (last ? 1 : 0), 3);
      zlib_Pako_trees.send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
      zlib_Pako_trees.compress_block(s, s.dyn_ltree, s.dyn_dtree);
    }
    zlib_Pako_trees.init_block(s);
    if (last) {
      zlib_Pako_trees.bi_windup(s);
    }
  }
  static _tr_tally(s, dist, lc) {
    s.pending_buf[s.d_buf + s.last_lit * 2] = dist >>> 8 & 255;
    s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 255;
    s.pending_buf[s.l_buf + s.last_lit] = lc & 255;
    s.last_lit++;
    if (dist === 0) {
      s.dyn_ltree[lc * 2]++;
    } else {
      s.matches++;
      dist--;
      s.dyn_ltree[(zlib_Pako_trees._length_code[lc] + zlib_Pako_trees.LITERALS + 1) * 2]++;
      s.dyn_dtree[zlib_Pako_trees.d_code(dist) * 2]++;
    }
    return s.last_lit === s.lit_bufsize - 1;
  }
};
zlib_Pako_trees.Z_FIXED = 4;
zlib_Pako_trees.Z_BINARY = 0;
zlib_Pako_trees.Z_TEXT = 1;
zlib_Pako_trees.Z_UNKNOWN = 2;
zlib_Pako_trees.STORED_BLOCK = 0;
zlib_Pako_trees.STATIC_TREES = 1;
zlib_Pako_trees.DYN_TREES = 2;
zlib_Pako_trees.MIN_MATCH = 3;
zlib_Pako_trees.MAX_MATCH = 258;
zlib_Pako_trees.LENGTH_CODES = 29;
zlib_Pako_trees.LITERALS = 256;
zlib_Pako_trees.L_CODES = zlib_Pako_trees.LITERALS + 1 + zlib_Pako_trees.LENGTH_CODES;
zlib_Pako_trees.D_CODES = 30;
zlib_Pako_trees.BL_CODES = 19;
zlib_Pako_trees.HEAP_SIZE = 2 * zlib_Pako_trees.L_CODES + 1;
zlib_Pako_trees.MAX_BITS = 15;
zlib_Pako_trees.Buf_size = 16;
zlib_Pako_trees.MAX_BL_BITS = 7;
zlib_Pako_trees.END_BLOCK = 256;
zlib_Pako_trees.REP_3_6 = 16;
zlib_Pako_trees.REPZ_3_10 = 17;
zlib_Pako_trees.REPZ_11_138 = 18;
zlib_Pako_trees.extra_lbits = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0]);
zlib_Pako_trees.extra_dbits = new Uint8Array([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]);
zlib_Pako_trees.extra_blbits = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7]);
zlib_Pako_trees.bl_order = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
zlib_Pako_trees.DIST_CODE_LEN = 512;
zlib_Pako_trees.static_ltree = new Uint16Array((zlib_Pako_trees.L_CODES + 2) * 2);
zlib_Pako_trees.static_dtree = new Uint16Array(zlib_Pako_trees.D_CODES * 2);
zlib_Pako_trees._dist_code = new Uint16Array(zlib_Pako_trees.DIST_CODE_LEN);
zlib_Pako_trees._length_code = new Uint16Array(zlib_Pako_trees.MAX_MATCH - zlib_Pako_trees.MIN_MATCH + 1);
zlib_Pako_trees.base_length = new Uint16Array(zlib_Pako_trees.LENGTH_CODES);
zlib_Pako_trees.base_dist = new Uint16Array(zlib_Pako_trees.D_CODES);
zlib_Pako_trees.send_bits = (s, value, length) => {
  if (s.bi_valid > zlib_Pako_trees.Buf_size - length) {
    s.bi_buf |= value << s.bi_valid & 65535;
    zlib_Pako_trees.put_short(s, s.bi_buf);
    s.bi_buf = value >> zlib_Pako_trees.Buf_size - s.bi_valid;
    s.bi_valid += length - zlib_Pako_trees.Buf_size;
  } else {
    s.bi_buf |= value << s.bi_valid & 65535;
    s.bi_valid += length;
  }
};
zlib_Pako_trees.gen_bitlen = (s, desc) => {
  const tree = desc.dyn_tree;
  const max_code = desc.max_code;
  const stree = desc.stat_desc.static_tree;
  const has_stree = desc.stat_desc.has_stree;
  const extra = desc.stat_desc.extra_bits;
  const base = desc.stat_desc.extra_base;
  const max_length = desc.stat_desc.max_length;
  let h;
  let n, m;
  let bits;
  let xbits;
  let f;
  let overflow = 0;
  for (bits = 0; bits <= zlib_Pako_trees.MAX_BITS; bits++) {
    s.bl_count[bits] = 0;
  }
  tree[s.heap[s.heap_max] * 2 + 1] = 0;
  for (h = s.heap_max + 1; h < zlib_Pako_trees.HEAP_SIZE; h++) {
    n = s.heap[h];
    bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;
    if (bits > max_length) {
      bits = max_length;
      overflow++;
    }
    tree[n * 2 + 1] = bits;
    if (n > max_code) {
      continue;
    }
    s.bl_count[bits]++;
    xbits = 0;
    if (n >= base) {
      xbits = extra[n - base];
    }
    f = tree[n * 2];
    s.opt_len += f * (bits + xbits);
    if (has_stree) {
      s.static_len += f * (stree[n * 2 + 1] + xbits);
    }
  }
  if (overflow === 0) {
    return;
  }
  do {
    bits = max_length - 1;
    while (s.bl_count[bits] === 0) {
      bits--;
    }
    s.bl_count[bits]--;
    s.bl_count[bits + 1] += 2;
    s.bl_count[max_length]--;
    overflow -= 2;
  } while (overflow > 0);
  for (bits = max_length; bits !== 0; bits--) {
    n = s.bl_count[bits];
    while (n !== 0) {
      m = s.heap[--h];
      if (m > max_code) {
        continue;
      }
      if (tree[m * 2 + 1] !== bits) {
        s.opt_len += (bits - tree[m * 2 + 1]) * tree[m * 2];
        tree[m * 2 + 1] = bits;
      }
      n--;
    }
  }
};
zlib_Pako_trees.static_init_done = false;
zlib_Pako_trees.initDone = zlib_Pako_trees.Zeroinit();

// obj/full/Pako/zlib/gzheader.js
"use strict";
var zlib_GZheader = class {
  constructor() {
    this.text = 0;
    this.time = 0;
    this.xflags = 0;
    this.os = 0;
    this.extra = null;
    this.extra_len = 0;
    this.name = "";
    this.comment = "";
    this.hcrc = 0;
    this.done = false;
  }
};

// obj/full/Pako/zlib/inffast.js
"use strict";
var zlib_inffast = class {
  static inflate_fast(strm, start) {
    let _in;
    let last;
    let _out;
    let beg;
    let end;
    let wsize;
    let whave;
    let wnext;
    let s_window;
    let hold;
    let bits;
    let lcode;
    let dcode;
    let lmask;
    let dmask;
    let here;
    let op;
    let len;
    let dist;
    let from;
    let from_source;
    let input;
    let output;
    let state = strm.state;
    _in = strm.next_in;
    input = strm.input;
    last = _in + (strm.avail_in - 5);
    _out = strm.next_out;
    output = strm.output;
    beg = _out - (start - strm.avail_out);
    end = _out + (strm.avail_out - 257);
    wsize = state.wsize;
    whave = state.whave;
    wnext = state.wnext;
    s_window = state.window;
    hold = state.hold;
    bits = state.bits;
    lcode = state.lencode;
    dcode = state.distcode;
    lmask = (1 << state.lenbits) - 1;
    dmask = (1 << state.distbits) - 1;
    top:
      do {
        if (bits < 15) {
          hold += input[_in++] << bits;
          bits += 8;
          hold += input[_in++] << bits;
          bits += 8;
        }
        here = lcode[hold & lmask];
        dolen:
          for (; ; ) {
            op = here >>> 24;
            hold >>>= op;
            bits -= op;
            op = here >>> 16 & 255;
            if (op === 0) {
              output[_out++] = here & 65535;
            } else if (op & 16) {
              len = here & 65535;
              op &= 15;
              if (op) {
                if (bits < op) {
                  hold += input[_in++] << bits;
                  bits += 8;
                }
                len += hold & (1 << op) - 1;
                hold >>>= op;
                bits -= op;
              }
              if (bits < 15) {
                hold += input[_in++] << bits;
                bits += 8;
                hold += input[_in++] << bits;
                bits += 8;
              }
              here = dcode[hold & dmask];
              dodist:
                for (; ; ) {
                  op = here >>> 24;
                  hold >>>= op;
                  bits -= op;
                  op = here >>> 16 & 255;
                  if (op & 16) {
                    dist = here & 65535;
                    op &= 15;
                    if (bits < op) {
                      hold += input[_in++] << bits;
                      bits += 8;
                      if (bits < op) {
                        hold += input[_in++] << bits;
                        bits += 8;
                      }
                    }
                    dist += hold & (1 << op) - 1;
                    hold >>>= op;
                    bits -= op;
                    op = _out - beg;
                    if (dist > op) {
                      op = dist - op;
                      if (op > whave) {
                        if (state.sane) {
                          strm.msg = "invalid distance too far back";
                          state.mode = zlib_inffast.BAD;
                          break top;
                        }
                      }
                      from = 0;
                      from_source = s_window;
                      if (wnext === 0) {
                        from += wsize - op;
                        if (op < len) {
                          len -= op;
                          do {
                            output[_out++] = s_window[from++];
                          } while (--op);
                          from = _out - dist;
                          from_source = output;
                        }
                      } else if (wnext < op) {
                        from += wsize + wnext - op;
                        op -= wnext;
                        if (op < len) {
                          len -= op;
                          do {
                            output[_out++] = s_window[from++];
                          } while (--op);
                          from = 0;
                          if (wnext < len) {
                            op = wnext;
                            len -= op;
                            do {
                              output[_out++] = s_window[from++];
                            } while (--op);
                            from = _out - dist;
                            from_source = output;
                          }
                        }
                      } else {
                        from += wnext - op;
                        if (op < len) {
                          len -= op;
                          do {
                            output[_out++] = s_window[from++];
                          } while (--op);
                          from = _out - dist;
                          from_source = output;
                        }
                      }
                      while (len > 2) {
                        output[_out++] = from_source[from++];
                        output[_out++] = from_source[from++];
                        output[_out++] = from_source[from++];
                        len -= 3;
                      }
                      if (len) {
                        output[_out++] = from_source[from++];
                        if (len > 1) {
                          output[_out++] = from_source[from++];
                        }
                      }
                    } else {
                      from = _out - dist;
                      do {
                        output[_out++] = output[from++];
                        output[_out++] = output[from++];
                        output[_out++] = output[from++];
                        len -= 3;
                      } while (len > 2);
                      if (len) {
                        output[_out++] = output[from++];
                        if (len > 1) {
                          output[_out++] = output[from++];
                        }
                      }
                    }
                  } else if ((op & 64) === 0) {
                    here = dcode[(here & 65535) + (hold & (1 << op) - 1)];
                    continue dodist;
                  } else {
                    strm.msg = "invalid distance code";
                    state.mode = zlib_inffast.BAD;
                    break top;
                  }
                  break;
                }
            } else if ((op & 64) === 0) {
              here = lcode[(here & 65535) + (hold & (1 << op) - 1)];
              continue dolen;
            } else if (op & 32) {
              state.mode = zlib_inffast.TYPE;
              break top;
            } else {
              strm.msg = "invalid literal/length code";
              state.mode = zlib_inffast.BAD;
              break top;
            }
            break;
          }
      } while (_in < last && _out < end);
    len = bits >> 3;
    _in -= len;
    bits -= len << 3;
    hold &= (1 << bits) - 1;
    strm.next_in = _in;
    strm.next_out = _out;
    strm.avail_in = _in < last ? 5 + (last - _in) : 5 - (_in - last);
    strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);
    state.hold = hold;
    state.bits = bits;
    return;
  }
};
zlib_inffast.BAD = 30;
zlib_inffast.TYPE = 12;

// obj/full/Pako/zlib/inflate.js
"use strict";
var zlib_InflateState = class {
  constructor() {
    this.mode = 0;
    this.last = 0;
    this.wrap = 0;
    this.havedict = 0;
    this.flags = 0;
    this.dmax = 0;
    this.check = 0;
    this.total = 0;
    this.head = null;
    this.wbits = 0;
    this.wsize = 0;
    this.whave = 0;
    this.wnext = 0;
    this.window = null;
    this.hold = 0;
    this.bits = 0;
    this.length = 0;
    this.offset = 0;
    this.extra = 0;
    this.lencode = null;
    this.distcode = null;
    this.lenbits = 0;
    this.distbits = 0;
    this.ncode = 0;
    this.nlen = 0;
    this.ndist = 0;
    this.have = 0;
    this.next = null;
    this.lens = new Uint16Array(320);
    this.work = new Uint16Array(288);
    this.lendyn = null;
    this.distdyn = null;
    this.sane = 0;
    this.back = 0;
    this.was = 0;
  }
};
var zlib_inflate = class {
  static zswap32(q) {
    return (q >>> 24 & 255) + (q >>> 8 & 65280) + ((q & 65280) << 8) + ((q & 255) << 24);
  }
  static inflateResetKeep(strm) {
    if (!strm || !strm.state) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    let state = strm.state;
    strm.total_in = strm.total_out = state.total = 0;
    strm.msg = "";
    if (state.wrap) {
      strm.adler = state.wrap & 1;
    }
    state.mode = zlib_inflate.HEAD;
    state.last = 0;
    state.havedict = 0;
    state.dmax = 32768;
    state.head = null;
    state.hold = 0;
    state.bits = 0;
    state.lencode = state.lendyn = new Int32Array(zlib_inflate.ENOUGH_LENS);
    state.distcode = state.distdyn = new Int32Array(zlib_inflate.ENOUGH_DISTS);
    state.sane = 1;
    state.back = -1;
    return zlib_constants.Z_OK;
  }
  static inflateReset(strm) {
    if (!strm || !strm.state) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    const state = strm.state;
    state.wsize = 0;
    state.whave = 0;
    state.wnext = 0;
    return zlib_inflate.inflateResetKeep(strm);
  }
  static inflateReset2(strm, windowBits) {
    let wrap;
    if (!strm || !strm.state) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    let state = strm.state;
    if (windowBits < 0) {
      wrap = 0;
      windowBits = -windowBits;
    } else {
      wrap = (windowBits >> 4) + 1;
      if (windowBits < 48) {
        windowBits &= 15;
      }
    }
    if (windowBits && (windowBits < 8 || windowBits > 15)) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    if (state.window !== null && state.wbits !== windowBits) {
      state.window = null;
    }
    state.wrap = wrap;
    state.wbits = windowBits;
    return zlib_inflate.inflateReset(strm);
  }
  static inflateInit2(strm, windowBits) {
    if (!strm) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    let state = new zlib_InflateState();
    strm.state = state;
    state.window = null;
    const ret = zlib_inflate.inflateReset2(strm, windowBits);
    if (ret !== zlib_constants.Z_OK) {
      strm.state = null;
    }
    return ret;
  }
  static inflateInit(strm) {
    return zlib_inflate.inflateInit2(strm, zlib_inflate.DEF_WBITS);
  }
  static fixedtables(state) {
    if (zlib_inflate.virgin) {
      zlib_inflate.lenfix = new Int32Array(512);
      zlib_inflate.distfix = new Int32Array(32);
      let sym = 0;
      while (sym < 144) {
        state.lens[sym++] = 8;
      }
      while (sym < 256) {
        state.lens[sym++] = 9;
      }
      while (sym < 280) {
        state.lens[sym++] = 7;
      }
      while (sym < 288) {
        state.lens[sym++] = 8;
      }
      zlib_inftrees.inflate_table(zlib_inflate.LENS, state.lens, 0, 288, zlib_inflate.lenfix, 0, state.work, {bits: 9});
      sym = 0;
      while (sym < 32) {
        state.lens[sym++] = 5;
      }
      zlib_inftrees.inflate_table(zlib_inflate.DISTS, state.lens, 0, 32, zlib_inflate.distfix, 0, state.work, {bits: 5});
      zlib_inflate.virgin = false;
    }
    state.lencode = zlib_inflate.lenfix;
    state.lenbits = 9;
    state.distcode = zlib_inflate.distfix;
    state.distbits = 5;
  }
  static updatewindow(strm, src, end, copy) {
    let dist;
    const state = strm.state;
    if (state.window === null) {
      state.wsize = 1 << state.wbits;
      state.wnext = 0;
      state.whave = 0;
      state.window = new Uint8Array(state.wsize);
    }
    if (copy >= state.wsize) {
      state.window.set(src.subarray(end - state.wsize, end), 0);
      state.wnext = 0;
      state.whave = state.wsize;
    } else {
      dist = state.wsize - state.wnext;
      if (dist > copy) {
        dist = copy;
      }
      state.window.set(src.subarray(end - copy, end - copy + dist), state.wnext);
      copy -= dist;
      if (copy) {
        state.window.set(src.subarray(end - copy, end), 0);
        state.wnext = copy;
        state.whave = state.wsize;
      } else {
        state.wnext += dist;
        if (state.wnext === state.wsize) {
          state.wnext = 0;
        }
        if (state.whave < state.wsize) {
          state.whave += dist;
        }
      }
    }
    return 0;
  }
  static inflate(strm, flush) {
    let state;
    let input, output;
    let next;
    let put;
    let have, left;
    let hold;
    let bits;
    let _in;
    let _out;
    let copy;
    let from;
    let from_source;
    let here = 0;
    let here_bits;
    let here_op;
    let here_val;
    let last_bits;
    let last_op;
    let last_val;
    let len;
    let ret;
    const hbuf = new Uint8Array(4);
    let opts;
    let n;
    let order = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
    if (!strm || !strm.state || !strm.output || !strm.input && strm.avail_in !== 0) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    state = strm.state;
    if (state.mode === zlib_inflate.TYPE) {
      state.mode = zlib_inflate.TYPEDO;
    }
    put = strm.next_out;
    output = strm.output;
    left = strm.avail_out;
    next = strm.next_in;
    input = strm.input;
    have = strm.avail_in;
    hold = state.hold;
    bits = state.bits;
    _in = have;
    _out = left;
    ret = zlib_constants.Z_OK;
    inf_leave:
      for (; ; ) {
        switch (state.mode) {
          case zlib_inflate.HEAD:
            if (state.wrap === 0) {
              state.mode = zlib_inflate.TYPEDO;
              break;
            }
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (state.wrap & 2 && hold === 35615) {
              state.check = 0;
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              state.check = zlib_crc32.crc32(state.check, hbuf, 2, 0);
              hold = 0;
              bits = 0;
              state.mode = zlib_inflate.FLAGS;
              break;
            }
            state.flags = 0;
            if (state.head) {
              state.head.done = false;
            }
            if (!(state.wrap & 1) || (((hold & 255) << 8) + (hold >> 8)) % 31) {
              strm.msg = "incorrect header check";
              state.mode = zlib_inflate.BAD;
              break;
            }
            if ((hold & 15) !== zlib_constants.Z_DEFLATED) {
              strm.msg = "unknown compression method";
              state.mode = zlib_inflate.BAD;
              break;
            }
            hold >>>= 4;
            bits -= 4;
            len = (hold & 15) + 8;
            if (state.wbits === 0) {
              state.wbits = len;
            } else if (len > state.wbits) {
              strm.msg = "invalid window size";
              state.mode = zlib_inflate.BAD;
              break;
            }
            state.dmax = 1 << state.wbits;
            strm.adler = state.check = 1;
            state.mode = hold & 512 ? zlib_inflate.DICTID : zlib_inflate.TYPE;
            hold = 0;
            bits = 0;
            break;
          case zlib_inflate.FLAGS:
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.flags = hold;
            if ((state.flags & 255) !== zlib_constants.Z_DEFLATED) {
              strm.msg = "unknown compression method";
              state.mode = zlib_inflate.BAD;
              break;
            }
            if (state.flags & 57344) {
              strm.msg = "unknown header flags set";
              state.mode = zlib_inflate.BAD;
              break;
            }
            if (state.head) {
              state.head.text = hold >> 8 & 1;
            }
            if (state.flags & 512) {
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              state.check = zlib_crc32.crc32(state.check, hbuf, 2, 0);
            }
            hold = 0;
            bits = 0;
            state.mode = zlib_inflate.TIME;
          case zlib_inflate.TIME:
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (state.head) {
              state.head.time = hold;
            }
            if (state.flags & 512) {
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              hbuf[2] = hold >>> 16 & 255;
              hbuf[3] = hold >>> 24 & 255;
              state.check = zlib_crc32.crc32(state.check, hbuf, 4, 0);
            }
            hold = 0;
            bits = 0;
            state.mode = zlib_inflate.OS;
          case zlib_inflate.OS:
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (state.head) {
              state.head.xflags = hold & 255;
              state.head.os = hold >> 8;
            }
            if (state.flags & 512) {
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              state.check = zlib_crc32.crc32(state.check, hbuf, 2, 0);
            }
            hold = 0;
            bits = 0;
            state.mode = zlib_inflate.EXLEN;
          case zlib_inflate.EXLEN:
            if (state.flags & 1024) {
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.length = hold;
              if (state.head) {
                state.head.extra_len = hold;
              }
              if (state.flags & 512) {
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                state.check = zlib_crc32.crc32(state.check, hbuf, 2, 0);
              }
              hold = 0;
              bits = 0;
            } else if (state.head) {
              state.head.extra = null;
            }
            state.mode = zlib_inflate.EXTRA;
          case zlib_inflate.EXTRA:
            if (state.flags & 1024) {
              copy = state.length;
              if (copy > have) {
                copy = have;
              }
              if (copy) {
                if (state.head) {
                  len = state.head.extra_len - state.length;
                  if (!state.head.extra) {
                    state.head.extra = new Uint8Array(state.head.extra_len);
                  }
                  state.head.extra.set(input.subarray(next, next + copy), len);
                }
                if (state.flags & 512) {
                  state.check = zlib_crc32.crc32(state.check, input, copy, next);
                }
                have -= copy;
                next += copy;
                state.length -= copy;
              }
              if (state.length) {
                break inf_leave;
              }
            }
            state.length = 0;
            state.mode = zlib_inflate.NAME;
          case zlib_inflate.NAME:
            if (state.flags & 2048) {
              if (have === 0) {
                break inf_leave;
              }
              copy = 0;
              do {
                len = input[next + copy++];
                if (state.head && len && state.length < 65536) {
                  state.head.name += String.fromCharCode(len);
                }
              } while (len && copy < have);
              if (state.flags & 512) {
                state.check = zlib_crc32.crc32(state.check, input, copy, next);
              }
              have -= copy;
              next += copy;
              if (len) {
                break inf_leave;
              }
            } else if (state.head) {
              state.head.name = null;
            }
            state.length = 0;
            state.mode = zlib_inflate.COMMENT;
          case zlib_inflate.COMMENT:
            if (state.flags & 4096) {
              if (have === 0) {
                break inf_leave;
              }
              copy = 0;
              do {
                len = input[next + copy++];
                if (state.head && len && state.length < 65536) {
                  state.head.comment += String.fromCharCode(len);
                }
              } while (len && copy < have);
              if (state.flags & 512) {
                state.check = zlib_crc32.crc32(state.check, input, copy, next);
              }
              have -= copy;
              next += copy;
              if (len) {
                break inf_leave;
              }
            } else if (state.head) {
              state.head.comment = null;
            }
            state.mode = zlib_inflate.HCRC;
          case zlib_inflate.HCRC:
            if (state.flags & 512) {
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (hold !== (state.check & 65535)) {
                strm.msg = "header crc mismatch";
                state.mode = zlib_inflate.BAD;
                break;
              }
              hold = 0;
              bits = 0;
            }
            if (state.head) {
              state.head.hcrc = state.flags >> 9 & 1;
              state.head.done = true;
            }
            strm.adler = state.check = 0;
            state.mode = zlib_inflate.TYPE;
            break;
          case zlib_inflate.DICTID:
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            strm.adler = state.check = zlib_inflate.zswap32(hold);
            hold = 0;
            bits = 0;
            state.mode = zlib_inflate.DICT;
          case zlib_inflate.DICT:
            if (!state.havedict) {
              strm.next_out = put;
              strm.avail_out = left;
              strm.next_in = next;
              strm.avail_in = have;
              state.hold = hold;
              state.bits = bits;
              return zlib_constants.Z_NEED_DICT;
            }
            strm.adler = state.check = 1;
            state.mode = zlib_inflate.TYPE;
          case zlib_inflate.TYPE:
            if (flush === zlib_constants.Z_BLOCK || flush === zlib_constants.Z_TREES) {
              break inf_leave;
            }
          case zlib_inflate.TYPEDO:
            if (state.last) {
              hold >>>= bits & 7;
              bits -= bits & 7;
              state.mode = zlib_inflate.CHECK;
              break;
            }
            while (bits < 3) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.last = hold & 1;
            hold >>>= 1;
            bits -= 1;
            switch (hold & 3) {
              case 0:
                state.mode = zlib_inflate.STORED;
                break;
              case 1:
                zlib_inflate.fixedtables(state);
                state.mode = zlib_inflate.LEN_;
                if (flush === zlib_constants.Z_TREES) {
                  hold >>>= 2;
                  bits -= 2;
                  break inf_leave;
                }
                break;
              case 2:
                state.mode = zlib_inflate.TABLE;
                break;
              case 3:
                strm.msg = "invalid block type";
                state.mode = zlib_inflate.BAD;
            }
            hold >>>= 2;
            bits -= 2;
            break;
          case zlib_inflate.STORED:
            hold >>>= bits & 7;
            bits -= bits & 7;
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if ((hold & 65535) !== (hold >>> 16 ^ 65535)) {
              strm.msg = "invalid stored block lengths";
              state.mode = zlib_inflate.BAD;
              break;
            }
            state.length = hold & 65535;
            hold = 0;
            bits = 0;
            state.mode = zlib_inflate.COPY_;
            if (flush === zlib_constants.Z_TREES) {
              break inf_leave;
            }
          case zlib_inflate.COPY_:
            state.mode = zlib_inflate.COPY;
          case zlib_inflate.COPY:
            copy = state.length;
            if (copy) {
              if (copy > have) {
                copy = have;
              }
              if (copy > left) {
                copy = left;
              }
              if (copy === 0) {
                break inf_leave;
              }
              output.set(input.subarray(next, next + copy), put);
              have -= copy;
              next += copy;
              left -= copy;
              put += copy;
              state.length -= copy;
              break;
            }
            state.mode = zlib_inflate.TYPE;
            break;
          case zlib_inflate.TABLE:
            while (bits < 14) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.nlen = (hold & 31) + 257;
            hold >>>= 5;
            bits -= 5;
            state.ndist = (hold & 31) + 1;
            hold >>>= 5;
            bits -= 5;
            state.ncode = (hold & 15) + 4;
            hold >>>= 4;
            bits -= 4;
            if (state.nlen > 286 || state.ndist > 30) {
              strm.msg = "too many length or distance symbols";
              state.mode = zlib_inflate.BAD;
              break;
            }
            state.have = 0;
            state.mode = zlib_inflate.LENLENS;
          case zlib_inflate.LENLENS:
            while (state.have < state.ncode) {
              while (bits < 3) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.lens[order[state.have++]] = hold & 7;
              hold >>>= 3;
              bits -= 3;
            }
            while (state.have < 19) {
              state.lens[order[state.have++]] = 0;
            }
            state.lencode = state.lendyn;
            state.lenbits = 7;
            opts = {bits: state.lenbits};
            ret = zlib_inftrees.inflate_table(zlib_inflate.CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
            state.lenbits = opts.bits;
            if (ret) {
              strm.msg = "invalid code lengths set";
              state.mode = zlib_inflate.BAD;
              break;
            }
            state.have = 0;
            state.mode = zlib_inflate.CODELENS;
          case zlib_inflate.CODELENS:
            while (state.have < state.nlen + state.ndist) {
              for (; ; ) {
                here = state.lencode[hold & (1 << state.lenbits) - 1];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (here_val < 16) {
                hold >>>= here_bits;
                bits -= here_bits;
                state.lens[state.have++] = here_val;
              } else {
                if (here_val === 16) {
                  n = here_bits + 2;
                  while (bits < n) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  hold >>>= here_bits;
                  bits -= here_bits;
                  if (state.have === 0) {
                    strm.msg = "invalid bit length repeat";
                    state.mode = zlib_inflate.BAD;
                    break;
                  }
                  len = state.lens[state.have - 1];
                  copy = 3 + (hold & 3);
                  hold >>>= 2;
                  bits -= 2;
                } else if (here_val === 17) {
                  n = here_bits + 3;
                  while (bits < n) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  hold >>>= here_bits;
                  bits -= here_bits;
                  len = 0;
                  copy = 3 + (hold & 7);
                  hold >>>= 3;
                  bits -= 3;
                } else {
                  n = here_bits + 7;
                  while (bits < n) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  hold >>>= here_bits;
                  bits -= here_bits;
                  len = 0;
                  copy = 11 + (hold & 127);
                  hold >>>= 7;
                  bits -= 7;
                }
                if (state.have + copy > state.nlen + state.ndist) {
                  strm.msg = "invalid bit length repeat";
                  state.mode = zlib_inflate.BAD;
                  break;
                }
                while (copy--) {
                  state.lens[state.have++] = len;
                }
              }
            }
            if (state.mode === zlib_inflate.BAD) {
              break;
            }
            if (state.lens[256] === 0) {
              strm.msg = "invalid code -- missing end-of-block";
              state.mode = zlib_inflate.BAD;
              break;
            }
            state.lenbits = 9;
            opts = {bits: state.lenbits};
            ret = zlib_inftrees.inflate_table(zlib_inflate.LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
            state.lenbits = opts.bits;
            if (ret) {
              strm.msg = "invalid literal/lengths set";
              state.mode = zlib_inflate.BAD;
              break;
            }
            state.distbits = 6;
            state.distcode = state.distdyn;
            opts = {bits: state.distbits};
            ret = zlib_inftrees.inflate_table(zlib_inflate.DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
            state.distbits = opts.bits;
            if (ret) {
              strm.msg = "invalid distances set";
              state.mode = zlib_inflate.BAD;
              break;
            }
            state.mode = zlib_inflate.LEN_;
            if (flush === zlib_constants.Z_TREES) {
              break inf_leave;
            }
          case zlib_inflate.LEN_:
            state.mode = zlib_inflate.LEN;
          case zlib_inflate.LEN:
            if (have >= 6 && left >= 258) {
              strm.next_out = put;
              strm.avail_out = left;
              strm.next_in = next;
              strm.avail_in = have;
              state.hold = hold;
              state.bits = bits;
              zlib_inffast.inflate_fast(strm, _out);
              put = strm.next_out;
              output = strm.output;
              left = strm.avail_out;
              next = strm.next_in;
              input = strm.input;
              have = strm.avail_in;
              hold = state.hold;
              bits = state.bits;
              if (state.mode === zlib_inflate.TYPE) {
                state.back = -1;
              }
              break;
            }
            state.back = 0;
            for (; ; ) {
              here = state.lencode[hold & (1 << state.lenbits) - 1];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (here_op && (here_op & 240) === 0) {
              last_bits = here_bits;
              last_op = here_op;
              last_val = here_val;
              for (; ; ) {
                here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (last_bits + here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              hold >>>= last_bits;
              bits -= last_bits;
              state.back += last_bits;
            }
            hold >>>= here_bits;
            bits -= here_bits;
            state.back += here_bits;
            state.length = here_val;
            if (here_op === 0) {
              state.mode = zlib_inflate.LIT;
              break;
            }
            if (here_op & 32) {
              state.back = -1;
              state.mode = zlib_inflate.TYPE;
              break;
            }
            if (here_op & 64) {
              strm.msg = "invalid literal/length code";
              state.mode = zlib_inflate.BAD;
              break;
            }
            state.extra = here_op & 15;
            state.mode = zlib_inflate.LENEXT;
          case zlib_inflate.LENEXT:
            if (state.extra) {
              n = state.extra;
              while (bits < n) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.length += hold & (1 << state.extra) - 1;
              hold >>>= state.extra;
              bits -= state.extra;
              state.back += state.extra;
            }
            state.was = state.length;
            state.mode = zlib_inflate.DIST;
          case zlib_inflate.DIST:
            for (; ; ) {
              here = state.distcode[hold & (1 << state.distbits) - 1];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if ((here_op & 240) === 0) {
              last_bits = here_bits;
              last_op = here_op;
              last_val = here_val;
              for (; ; ) {
                here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (last_bits + here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              hold >>>= last_bits;
              bits -= last_bits;
              state.back += last_bits;
            }
            hold >>>= here_bits;
            bits -= here_bits;
            state.back += here_bits;
            if (here_op & 64) {
              strm.msg = "invalid distance code";
              state.mode = zlib_inflate.BAD;
              break;
            }
            state.offset = here_val;
            state.extra = here_op & 15;
            state.mode = zlib_inflate.DISTEXT;
          case zlib_inflate.DISTEXT:
            if (state.extra) {
              n = state.extra;
              while (bits < n) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.offset += hold & (1 << state.extra) - 1;
              hold >>>= state.extra;
              bits -= state.extra;
              state.back += state.extra;
            }
            state.mode = zlib_inflate.MATCH;
          case zlib_inflate.MATCH:
            if (left === 0) {
              break inf_leave;
            }
            copy = _out - left;
            if (state.offset > copy) {
              copy = state.offset - copy;
              if (copy > state.whave) {
                if (state.sane) {
                  strm.msg = "invalid distance too far back";
                  state.mode = zlib_inflate.BAD;
                  break;
                }
              }
              if (copy > state.wnext) {
                copy -= state.wnext;
                from = state.wsize - copy;
              } else {
                from = state.wnext - copy;
              }
              if (copy > state.length) {
                copy = state.length;
              }
              from_source = state.window;
            } else {
              from_source = output;
              from = put - state.offset;
              copy = state.length;
            }
            if (copy > left) {
              copy = left;
            }
            left -= copy;
            state.length -= copy;
            do {
              output[put++] = from_source[from++];
            } while (--copy);
            if (state.length === 0) {
              state.mode = zlib_inflate.LEN;
            }
            break;
          case zlib_inflate.LIT:
            if (left === 0) {
              break inf_leave;
            }
            output[put++] = state.length;
            left--;
            state.mode = zlib_inflate.LEN;
            break;
          case zlib_inflate.CHECK:
            if (state.wrap) {
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold |= input[next++] << bits;
                bits += 8;
              }
              _out -= left;
              strm.total_out += _out;
              state.total += _out;
              if (_out) {
                strm.adler = state.check = state.flags ? zlib_crc32.crc32(state.check, output, _out, put - _out) : zlib_adler32.adler32(state.check, output, _out, put - _out);
              }
              _out = left;
              if ((state.flags ? hold : zlib_inflate.zswap32(hold)) !== state.check) {
                strm.msg = "incorrect data check";
                state.mode = zlib_inflate.BAD;
                break;
              }
              hold = 0;
              bits = 0;
            }
            state.mode = zlib_inflate.LENGTH;
          case zlib_inflate.LENGTH:
            if (state.wrap && state.flags) {
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (hold !== (state.total & 4294967295)) {
                strm.msg = "incorrect length check";
                state.mode = zlib_inflate.BAD;
                break;
              }
              hold = 0;
              bits = 0;
            }
            state.mode = zlib_inflate.DONE;
          case zlib_inflate.DONE:
            ret = zlib_constants.Z_STREAM_END;
            break inf_leave;
          case zlib_inflate.BAD:
            ret = zlib_constants.Z_DATA_ERROR;
            break inf_leave;
          case zlib_inflate.MEM:
            return zlib_constants.Z_MEM_ERROR;
          case zlib_inflate.SYNC:
          default:
            return zlib_constants.Z_STREAM_ERROR;
        }
      }
    strm.next_out = put;
    strm.avail_out = left;
    strm.next_in = next;
    strm.avail_in = have;
    state.hold = hold;
    state.bits = bits;
    if (state.wsize || _out !== strm.avail_out && state.mode < zlib_inflate.BAD && (state.mode < zlib_inflate.CHECK || flush !== zlib_constants.Z_FINISH)) {
      if (zlib_inflate.updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) {
        state.mode = zlib_inflate.MEM;
        return zlib_constants.Z_MEM_ERROR;
      }
    }
    _in -= strm.avail_in;
    _out -= strm.avail_out;
    strm.total_in += _in;
    strm.total_out += _out;
    state.total += _out;
    if (state.wrap && _out) {
      strm.adler = state.check = state.flags ? zlib_crc32.crc32(state.check, output, _out, strm.next_out - _out) : zlib_adler32.adler32(state.check, output, _out, strm.next_out - _out);
    }
    strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === zlib_inflate.TYPE ? 128 : 0) + (state.mode === zlib_inflate.LEN_ || state.mode === zlib_inflate.COPY_ ? 256 : 0);
    if ((_in === 0 && _out === 0 || flush === zlib_constants.Z_FINISH) && ret === zlib_constants.Z_OK) {
      ret = zlib_constants.Z_BUF_ERROR;
    }
    return ret;
  }
  static inflateEnd(strm) {
    if (!strm || !strm.state) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    let state = strm.state;
    if (state.window) {
      state.window = null;
    }
    strm.state = null;
    return zlib_constants.Z_OK;
  }
  static inflateGetHeader(strm, head) {
    if (!strm || !strm.state) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    let state = strm.state;
    if ((state.wrap & 2) === 0) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    state.head = head;
    head.done = false;
    return zlib_constants.Z_OK;
  }
  static inflateSetDictionary(strm, dictionary) {
    const dictLength = dictionary.length;
    let state;
    let dictid;
    let ret;
    if (!strm || !strm.state) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    state = strm.state;
    if (state.wrap !== 0 && state.mode !== zlib_inflate.DICT) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    if (state.mode === zlib_inflate.DICT) {
      dictid = 1;
      dictid = zlib_adler32.adler32(dictid, dictionary, dictLength, 0);
      if (dictid !== state.check) {
        return zlib_constants.Z_DATA_ERROR;
      }
    }
    ret = zlib_inflate.updatewindow(strm, dictionary, dictLength, dictLength);
    if (ret) {
      state.mode = zlib_inflate.MEM;
      return zlib_constants.Z_MEM_ERROR;
    }
    state.havedict = 1;
    return zlib_constants.Z_OK;
  }
};
zlib_inflate.CODES = 0;
zlib_inflate.LENS = 1;
zlib_inflate.DISTS = 2;
zlib_inflate.HEAD = 1;
zlib_inflate.FLAGS = 2;
zlib_inflate.TIME = 3;
zlib_inflate.OS = 4;
zlib_inflate.EXLEN = 5;
zlib_inflate.EXTRA = 6;
zlib_inflate.NAME = 7;
zlib_inflate.COMMENT = 8;
zlib_inflate.HCRC = 9;
zlib_inflate.DICTID = 10;
zlib_inflate.DICT = 11;
zlib_inflate.TYPE = 12;
zlib_inflate.TYPEDO = 13;
zlib_inflate.STORED = 14;
zlib_inflate.COPY_ = 15;
zlib_inflate.COPY = 16;
zlib_inflate.TABLE = 17;
zlib_inflate.LENLENS = 18;
zlib_inflate.CODELENS = 19;
zlib_inflate.LEN_ = 20;
zlib_inflate.LEN = 21;
zlib_inflate.LENEXT = 22;
zlib_inflate.DIST = 23;
zlib_inflate.DISTEXT = 24;
zlib_inflate.MATCH = 25;
zlib_inflate.LIT = 26;
zlib_inflate.CHECK = 27;
zlib_inflate.LENGTH = 28;
zlib_inflate.DONE = 29;
zlib_inflate.BAD = 30;
zlib_inflate.MEM = 31;
zlib_inflate.SYNC = 32;
zlib_inflate.ENOUGH_LENS = 852;
zlib_inflate.ENOUGH_DISTS = 592;
zlib_inflate.MAX_WBITS = 15;
zlib_inflate.DEF_WBITS = zlib_inflate.MAX_WBITS;
zlib_inflate.virgin = true;

// obj/full/Pako/zlib/messages.js
"use strict";
var zlib_messages = class {
  static msg(index) {
    switch (index) {
      case 2:
        return "need dictionary";
      case 1:
        return "stream end";
      case 0:
        return "";
      case -1:
        return "file error";
      case -2:
        return "stream error";
      case -3:
        return "data error";
      case -4:
        return "insufficient memory";
      case -5:
        return "buffer error";
      case -6:
        return "incompatible version";
      default:
        return "unknowwn error";
    }
  }
};

// obj/full/Pako/zlib/inftrees.js
"use strict";
var zlib_inftrees = class {
  static inflate_table(type, lens, lens_index, codes, table, table_index, work, opts) {
    const bits = opts.bits;
    let len;
    let sym;
    let min = 0;
    let max;
    let root;
    let curr = 0;
    let drop = 0;
    let left = 0;
    let used = 0;
    let huff = 0;
    let incr;
    let fill;
    let low;
    let mask;
    let next;
    let base;
    let base_index = 0;
    let end;
    const count = new Uint16Array(zlib_inftrees.MAXBITS + 1);
    const offs = new Uint16Array(zlib_inftrees.MAXBITS + 1);
    let extra;
    let extra_index = 0;
    let here_bits;
    let here_op;
    let here_val;
    for (len = 0; len <= zlib_inftrees.MAXBITS; len++) {
      count[len] = 0;
    }
    for (sym = 0; sym < codes; sym++) {
      count[lens[lens_index + sym]]++;
    }
    root = bits;
    for (max = zlib_inftrees.MAXBITS; max >= 1; max--) {
      if (count[max] !== 0) {
        break;
      }
    }
    if (root > max) {
      root = max;
    }
    if (max === 0) {
      table[table_index++] = 1 << 24 | 64 << 16 | 0;
      table[table_index++] = 1 << 24 | 64 << 16 | 0;
      opts.bits = 1;
      return 0;
    }
    for (min = 1; min < max; min++) {
      if (count[min] !== 0) {
        break;
      }
    }
    if (root < min) {
      root = min;
    }
    left = 1;
    for (len = 1; len <= zlib_inftrees.MAXBITS; len++) {
      left <<= 1;
      left -= count[len];
      if (left < 0) {
        return -1;
      }
    }
    if (left > 0 && (type === zlib_inftrees.CODES || max !== 1)) {
      return -1;
    }
    offs[1] = 0;
    for (len = 1; len < zlib_inftrees.MAXBITS; len++) {
      offs[len + 1] = offs[len] + count[len];
    }
    for (sym = 0; sym < codes; sym++) {
      if (lens[lens_index + sym] !== 0) {
        work[offs[lens[lens_index + sym]]++] = sym;
      }
    }
    if (type === zlib_inftrees.CODES) {
      base = work;
      extra = new Uint8Array();
      end = 19;
    } else if (type === zlib_inftrees.LENS) {
      base = zlib_inftrees.lbase;
      base_index -= 257;
      extra = zlib_inftrees.lext;
      extra_index -= 257;
      end = 256;
    } else {
      base = zlib_inftrees.dbase;
      extra = zlib_inftrees.dext;
      end = -1;
    }
    huff = 0;
    sym = 0;
    len = min;
    next = table_index;
    curr = root;
    drop = 0;
    low = -1;
    used = 1 << root;
    mask = used - 1;
    if (type === zlib_inftrees.LENS && used > zlib_inftrees.ENOUGH_LENS || type === zlib_inftrees.DISTS && used > zlib_inftrees.ENOUGH_DISTS) {
      return 1;
    }
    for (; ; ) {
      here_bits = len - drop;
      if (work[sym] < end) {
        here_op = 0;
        here_val = work[sym];
      } else if (work[sym] > end) {
        here_op = extra[extra_index + work[sym]];
        here_val = base[base_index + work[sym]];
      } else {
        here_op = 32 + 64;
        here_val = 0;
      }
      incr = 1 << len - drop;
      fill = 1 << curr;
      min = fill;
      do {
        fill -= incr;
        table[next + (huff >> drop) + fill] = here_bits << 24 | here_op << 16 | here_val | 0;
      } while (fill !== 0);
      incr = 1 << len - 1;
      while (huff & incr) {
        incr >>= 1;
      }
      if (incr !== 0) {
        huff &= incr - 1;
        huff += incr;
      } else {
        huff = 0;
      }
      sym++;
      if (--count[len] === 0) {
        if (len === max) {
          break;
        }
        len = lens[lens_index + work[sym]];
      }
      if (len > root && (huff & mask) !== low) {
        if (drop === 0) {
          drop = root;
        }
        next += min;
        curr = len - drop;
        left = 1 << curr;
        while (curr + drop < max) {
          left -= count[curr + drop];
          if (left <= 0) {
            break;
          }
          curr++;
          left <<= 1;
        }
        used += 1 << curr;
        if (type === zlib_inftrees.LENS && used > zlib_inftrees.ENOUGH_LENS || type === zlib_inftrees.DISTS && used > zlib_inftrees.ENOUGH_DISTS) {
          return 1;
        }
        low = huff & mask;
        table[low] = root << 24 | curr << 16 | next - table_index | 0;
      }
    }
    if (huff !== 0) {
      table[next + huff] = len - drop << 24 | 64 << 16 | 0;
    }
    opts.bits = root;
    return 0;
  }
};
zlib_inftrees.MAXBITS = 15;
zlib_inftrees.ENOUGH_LENS = 852;
zlib_inftrees.ENOUGH_DISTS = 592;
zlib_inftrees.CODES = 0;
zlib_inftrees.LENS = 1;
zlib_inftrees.DISTS = 2;
zlib_inftrees.lbase = new Uint16Array([
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  13,
  15,
  17,
  19,
  23,
  27,
  31,
  35,
  43,
  51,
  59,
  67,
  83,
  99,
  115,
  131,
  163,
  195,
  227,
  258,
  0,
  0
]);
zlib_inftrees.lext = new Uint8Array([
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  17,
  17,
  17,
  17,
  18,
  18,
  18,
  18,
  19,
  19,
  19,
  19,
  20,
  20,
  20,
  20,
  21,
  21,
  21,
  21,
  16,
  72,
  78
]);
zlib_inftrees.dbase = new Uint16Array([
  1,
  2,
  3,
  4,
  5,
  7,
  9,
  13,
  17,
  25,
  33,
  49,
  65,
  97,
  129,
  193,
  257,
  385,
  513,
  769,
  1025,
  1537,
  2049,
  3073,
  4097,
  6145,
  8193,
  12289,
  16385,
  24577,
  0,
  0
]);
zlib_inftrees.dext = new Uint8Array([
  16,
  16,
  16,
  16,
  17,
  17,
  18,
  18,
  19,
  19,
  20,
  20,
  21,
  21,
  22,
  22,
  23,
  23,
  24,
  24,
  25,
  25,
  26,
  26,
  27,
  27,
  28,
  28,
  29,
  29,
  64,
  64
]);

// obj/full/Pako/zlib/zstream.js
"use strict";
var zlib_ZStream = class {
  constructor() {
    this.input = null;
    this.next_in = 0;
    this.avail_in = 0;
    this.total_in = 0;
    this.output = null;
    this.next_out = 0;
    this.avail_out = 0;
    this.total_out = 0;
    this.msg = "";
    this.state = null;
    this.data_type = 2;
    this.adler = 0;
  }
};

// obj/full/webPage.js
var YWebPage = class {
  edit(widgetIndex) {
    YWebPage.widgets[widgetIndex].edit();
  }
  static get editMenuItem() {
    return YWebPage._editMenuItem;
  }
  static get deleteMenuItem() {
    return YWebPage._deleteMenuItem;
  }
  static get disableMarkerMenuItem() {
    return YWebPage._disableMarkerMenuItem;
  }
  static get clearDataloggerMenuItem() {
    return YWebPage._clearDataloggerMenuItem;
  }
  static get addMarkerMenuItem() {
    return YWebPage._addMarkerMenuItem;
  }
  static get markersSubMenuItems() {
    return YWebPage._markersSubMenuItems;
  }
  static get contextMarkerSubMenu() {
    return YWebPage._contextMarkerSubMenu;
  }
  static get contextWidgetsSubMenu() {
    return YWebPage._contextWidgetsSubMenu;
  }
  static get resetDataViewMenuItem() {
    return YWebPage._resetDataViewMenuItem;
  }
  static get snapshotMenuItem() {
    return YWebPage._snapshotMenuItem;
  }
  static applicationGlobalinit() {
    if (YWebPage._MarkerCountPerXaxis == 0) {
      let xAxisProp = new XaxisDescription();
      let propDesc = GenericProperties.getAllProperties(xAxisProp);
      for (let propname in propDesc.byName) {
        if (propname.startsWith("markers"))
          YWebPage._MarkerCountPerXaxis++;
      }
    }
    if (YWebPage.manager == null)
      YWebPage.manager = new sensorsManager();
    if (!YWebPage.readonly && YWebPage._editor == null)
      YWebPage._editor = new PropertiesForm2();
    if (!YWebPage.readonly && YWebPage._mainform == null)
      YWebPage._mainform = new mainForm();
    if (YWebPage._contextMenu == null) {
      YWebPage._contextMenu = new ContextMenu(YWebPage.baseSize, (mouseX, mouseY) => {
        YWebPage.menuIsOpening(mouseX, mouseY);
      }, constants.generalFontFamily);
      YWebPage._contextMarkerSubMenu = new ContextSubMenu(YWebPage.baseSize, YWebPage._contextMenu, null, constants.generalFontFamily);
      for (let i = 0; i < YWebPage._MarkerCountPerXaxis; i++) {
        YWebPage._markersSubMenuItems.push(YWebPage._contextMarkerSubMenu.addMenuItem(ressources.AddMarkerIcon(YWebPage.baseSize.toString(), i + 1), "Place marker " + (i + 1).toString(), () => {
          let target = YWebPage._markersSubMenuItems[i].userdata;
          target.startMarkerCapture(i);
        }));
      }
      if (!YWebPage.readonly) {
        YWebPage._contextWidgetsSubMenu = new ContextSubMenu(YWebPage.baseSize, YWebPage._contextMenu, (mouseX, mouseY) => {
          YWebPage.WidgetsSubMenuIsOpening(mouseX, mouseY);
        }, constants.generalFontFamily);
        YWebPage._widgetsMenuItem = YWebPage._contextMenu.addSubMenuItem(ressources.AllIcon(YWebPage.baseSize.toString(), false, false, false, false), "All widgets", YWebPage._contextWidgetsSubMenu);
        YWebPage._editMenuItem = YWebPage._contextMenu.addMenuItem(ressources.EditIcon(YWebPage.baseSize.toString(), false, false, false, false), "Configure this widget", () => {
          YWebPage.editWidget();
        });
        YWebPage._deleteMenuItem = YWebPage._contextMenu.addMenuItem(ressources.TrashIcon(YWebPage.baseSize.toString(), false, false, false, false), "Delete this widget", () => {
          YWebPage.deleteWidget();
        });
        YWebPage._editMenuItem.visible = false;
        YWebPage._deleteMenuItem.visible = false;
      }
      YWebPage._resetDataViewMenuItem = YWebPage._contextMenu.addMenuItem(ressources.resetViewPort(YWebPage.baseSize.toString(), false, false, false, false), "Reset dataview", () => {
        YWebPage.resetDataView();
      });
      YWebPage._resetDataViewMenuItem.visible = false;
      if (!YWebPage.readonly) {
        YWebPage._clearDataloggerMenuItem = YWebPage._contextMenu.addMenuItem(ressources.EraseDatalogger(YWebPage.baseSize.toString(), false, false, false, false), "Clear datalogger", () => {
          YWebPage.clearDatalogger();
        });
        YWebPage._resetDataViewMenuItem.visible = false;
      }
      YWebPage._contextMenu.AddSeparator();
      if (!YWebPage.readonly) {
        YWebPage._addMarkerMenuItem = YWebPage._contextMenu.addSubMenuItem(ressources.AddMarker(YWebPage.baseSize.toString(), false, true, true, false), "Place markers", YWebPage._contextMarkerSubMenu);
        YWebPage._disableMarkerMenuItem = YWebPage._contextMenu.addMenuItem(ressources.DeleteMarker(YWebPage.baseSize.toString(), false, true, false, true), "Disable Allmarkers", () => {
          YWebPage.disableAllMarker();
        });
        YWebPage._addMarkerMenuItem.visible = false;
        YWebPage._disableMarkerMenuItem.visible = false;
        YWebPage._contextMenu.AddSeparator();
        YWebPage._contextMenu.addMenuItem(ressources.SolidGaugeIcon(YWebPage.baseSize.toString(), false, true, true, false), "Add a new Solid gauge", () => {
          YWebPage.newGaugeWidget();
        });
        YWebPage._contextMenu.addMenuItem(ressources.AngularGaugeIcon(YWebPage.baseSize.toString(), false, true, true, false), "Add a new Angular gauge", () => {
          YWebPage.newAngularGaugeWidget();
        });
        YWebPage._contextMenu.addMenuItem(ressources.DigitalDisplayIcon(YWebPage.baseSize.toString(), false, true, true, false), "Add a new Digital Display", () => {
          YWebPage.newDigitalDisplayWidget();
        });
        YWebPage._contextMenu.addMenuItem(ressources.GraphIcon(YWebPage.baseSize.toString(), false, true, true, false), "Add a new Graph", () => {
          YWebPage.newGraphWidget();
        });
      }
      YWebPage._contextMenu.addMenuItem(ressources.RawDataIcon(YWebPage.baseSize.toString(), false, false, false, false), "Show raw data", () => {
        rawDataForm.show();
      });
      YWebPage._snapshotMenuItem = YWebPage._contextMenu.addMenuItem(ressources.snapshotIcon(YWebPage.baseSize.toString(), false, false, false, false), "Snapshot", () => {
        YWebPage.snapShot();
      });
      if (!YWebPage.readonly) {
        YWebPage._contextMenu.AddSeparator();
        YWebPage._contextMenu.addMenuItem(ressources.ConfigureIcon(YWebPage.baseSize.toString(), false, false, false, false), "Global configuration", () => {
          configForm.show();
        });
        YWebPage._contextMenu.addMenuItem(ressources.SaveIcon(YWebPage.baseSize.toString(), false, false, false, false), "Save now", () => {
          YWebPage.save(true);
        });
      }
      YWebPage._contextMenu.addMenuItem(ressources.LogFileIcon(YWebPage.baseSize.toString(), false, false, false, false), "Show logs", () => {
        YWebPage.showLogsWindow();
      });
    }
  }
  static RegisterDeviceArrivalCallback(arrivalCallback) {
    sensorsManager.RegisterDeviceArrivalCallback(arrivalCallback);
  }
  static RegisterDeviceRemovalCallback(removalCallback) {
    sensorsManager.RegisterDeviceRemovalCallback(removalCallback);
  }
  static WidgetsSubMenuIsOpening(mouseX, mouseY) {
    YWebPage._contextWidgetsSubMenu.clearAllContents();
    for (let i = 0; i < YWebPage.widgets.length; i++) {
      let icon = "";
      let subMenu = new ContextSubMenu(YWebPage.baseSize, YWebPage._contextWidgetsSubMenu, (mouseX2, mouseY2) => {
        YWebPage.specificWidgetSubMenuIsOpening(subMenu, mouseX2, mouseY2);
      }, constants.generalFontFamily);
      subMenu.userdata = YWebPage.widgets[i];
      if (YWebPage.widgets[i] instanceof graphWidget)
        icon = ressources.GraphIcon(YWebPage.baseSize.toString(), false, false, false, false);
      if (YWebPage.widgets[i] instanceof digitalDisplayWidget)
        icon = ressources.DigitalDisplayIcon(YWebPage.baseSize.toString(), false, false, false, false);
      if (YWebPage.widgets[i] instanceof gaugeWidget)
        icon = ressources.SolidGaugeIcon(YWebPage.baseSize.toString(), false, false, false, false);
      if (YWebPage.widgets[i] instanceof angularGaugeWidget)
        icon = ressources.AngularGaugeIcon(YWebPage.baseSize.toString(), false, false, false, false);
      YWebPage._contextWidgetsSubMenu.addSubMenuItem(icon, YWebPage.widgets[i].Text, subMenu);
    }
  }
  static specificWidgetSubMenuIsOpening(source, mouseX, mouseY) {
    if (source.menuItemsCount > 0)
      return;
    let w = source.userdata;
    source.addMenuItem(ressources.EditIcon(YWebPage.baseSize.toString(), false, false, false, false), "Configure", () => {
      w.edit();
    });
    source.addMenuItem(ressources.TrashIcon(YWebPage.baseSize.toString(), false, false, false, false), "Delete", () => {
      YWebPage.deleteWidget(w);
    });
    if (w instanceof graphWidget) {
      source.addMenuItem(ressources.resetViewPort(YWebPage.baseSize.toString(), false, false, false, false), "Reset dataview", () => {
        w.resetDataView();
      });
      source.addMenuItem(ressources.EraseDatalogger(YWebPage.baseSize.toString(), false, false, false, false), "Clear datalogger", () => {
        w.clearDataLogger();
      });
    }
  }
  static showLogsWindow() {
    logForm.show();
  }
  static snapShot() {
    let w = YWebPage._snapshotMenuItem.userdata;
    w.snapshot();
  }
  static menuIsOpening(mouseX, mouseY) {
    if (YWebPage.disableMarkerMenuItem != null)
      YWebPage.disableMarkerMenuItem.visible = false;
    if (YWebPage.addMarkerMenuItem != null)
      YWebPage.addMarkerMenuItem.visible = false;
    if (YWebPage.clearDataloggerMenuItem != null)
      YWebPage.clearDataloggerMenuItem.visible = false;
    if (YWebPage.editMenuItem != null)
      YWebPage.editMenuItem.visible = false;
    if (YWebPage.deleteMenuItem != null)
      YWebPage.deleteMenuItem.visible = false;
    YWebPage.resetDataViewMenuItem.visible = false;
    YWebPage.snapshotMenuItem.visible = false;
    for (let i = 0; i < YWebPage.widgets.length; i++) {
      YWebPage.widgets[i].contextMenuCallBack(mouseX, mouseY);
    }
    YWebPage._widgetsMenuItem.visible = !YWebPage.readonly && YWebPage.widgets.length > 0 && !YWebPage._editMenuItem.visible;
    YWebPage._contextMenu.refresh();
  }
  static resetDataView() {
    YWebPage._resetDataViewMenuItem.userdata.resetDataView();
  }
  static editWidget() {
    let w = YWebPage._editMenuItem.userdata;
    w.edit();
  }
  static disableAllMarker() {
    YWebPage._disableMarkerMenuItem.userdata.disableAllMarkers();
  }
  static clearDatalogger() {
    YWebPage._clearDataloggerMenuItem.userdata.clearDataLogger();
  }
  static deleteWidget(widget) {
    let w = typeof widget == "undefined" ? YWebPage._deleteMenuItem.userdata : widget;
    confirm.ask(w.confirmDeleteString, () => {
      if (!YWebPage.readonly && w.isBeingEdited && YWebPage._editor != null)
        YWebPage._editor.hide();
      w.delete();
      constants.edited = true;
      for (let i = YWebPage.widgets.length - 1; i >= 0; i--) {
        if (YWebPage.widgets[i] == w) {
          YWebPage.widgets.splice(i, 1);
        }
      }
      if (YWebPage.widgets.length <= 0 && YWebPage._mainform != null)
        YWebPage._mainform.show();
    }, null, null);
  }
  static FindUniqueNewName(prefix) {
    let n = 1;
    for (let i = 0; i < YWebPage.widgets.length; i++) {
      if (YWebPage.widgets[i].Text.startsWith(prefix))
        n++;
    }
    if (n > 1)
      prefix = prefix + " " + n.toString();
    return prefix;
  }
  static newGraphWidget() {
    let w = window.innerWidth / 2 >> 0;
    let h = window.innerHeight / 2 >> 0;
    if (w < 350)
      w = 350;
    if (h < 200)
      w = 200;
    let x = (window.innerWidth - w) / 2 >> 0;
    let y = (window.innerHeight - h) / 2 >> 0;
    let index = YWebPage.widgets.length;
    if (index > 0) {
      x = index * 25;
      y = index * 25;
    }
    let wdg = new graphWidget(null, YWebPage._editor, x, y, 765, 470);
    wdg.set_name(YWebPage.FindUniqueNewName("New Graph"));
    YWebPage.widgets.push(wdg);
    wdg.resize(w, h);
    if (this._mainform != null)
      this._mainform.hide();
    if (!YWebPage.readonly) {
      if (YWebPage._editor != null && YWebPage._editor.visible)
        wdg.edit();
    }
  }
  static newAngularGaugeWidget() {
    let s = Math.min(window.innerWidth, window.innerHeight) / 2;
    if (s < 350)
      s = 350;
    let x = (window.innerWidth - s) / 2 >> 0;
    let y = (window.innerHeight - s) / 2 >> 0;
    let w = s >> 0;
    let h = s >> 0;
    let index = YWebPage.widgets.length;
    if (index > 0) {
      x = index * 25;
      y = index * 25;
    }
    let wdg = new angularGaugeWidget(null, YWebPage._editor, x, y, 375, 300);
    wdg.set_name(YWebPage.FindUniqueNewName("New Angular Gauge"));
    YWebPage.widgets.push(wdg);
    wdg.resize(w, h);
    if (this._mainform != null)
      this._mainform.hide();
    if (!YWebPage.readonly) {
      if (YWebPage._editor != null && YWebPage._editor.visible)
        wdg.edit();
    }
  }
  static newGaugeWidget() {
    let s = Math.min(window.innerWidth, window.innerHeight) / 2;
    if (s < 350)
      s = 350;
    let x = (window.innerWidth - s) / 2 >> 0;
    let y = (window.innerHeight - s) / 2 >> 0;
    let w = s >> 0;
    let h = s >> 0;
    let index = YWebPage.widgets.length;
    if (index > 0) {
      x = index * 25;
      y = index * 25;
    }
    let wdg = new gaugeWidget(null, YWebPage._editor, x, y, 355, 201);
    wdg.set_name(YWebPage.FindUniqueNewName("New Solid Gauge"));
    YWebPage.widgets.push(wdg);
    wdg.resize(w, h);
    if (this._mainform != null)
      this._mainform.hide();
    if (!YWebPage.readonly) {
      if (YWebPage._editor != null && YWebPage._editor.visible)
        wdg.edit();
    }
  }
  static newDigitalDisplayWidget() {
    let s = Math.min(window.innerWidth, window.innerHeight) / 8;
    if (s < 90)
      s = 90;
    let x = (window.innerWidth - 4 * s) / 2 >> 0;
    let y = (window.innerHeight - s) / 2 >> 0;
    let w = 4 * s >> 0;
    let h = s >> 0;
    let index = YWebPage.widgets.length;
    if (index > 0) {
      x = index * 25;
      y = index * 25;
    }
    let wdg = new digitalDisplayWidget(null, YWebPage._editor, x, y, 410, 125);
    wdg.set_name(YWebPage.FindUniqueNewName("New Digital Display"));
    let n = 1;
    for (let i = 0; i < YWebPage.widgets.length; i++) {
      if (YWebPage.widgets[i].Text.startsWith(wdg.Text))
        n++;
    }
    if (n > 1)
      wdg.Text = wdg.Text + " " + n.toString();
    YWebPage.widgets.push(wdg);
    wdg.resize(w, h);
    if (this._mainform != null)
      this._mainform.hide();
    if (!YWebPage.readonly) {
      if (YWebPage._editor != null && YWebPage._editor.visible)
        wdg.edit();
    }
  }
  static refreshPropertiesForm() {
    if (!YWebPage.readonly && YWebPage._editor != null)
      YWebPage._editor.refresh();
  }
  static sensorListHaschanged() {
    YWebPage.refreshPropertiesForm();
  }
  static EmptyReadonlyConfig() {
    alert2.show("Yocto-Visualization Error\n\nConfiguration is both empty and read only, check configuration file.");
  }
  static async ForceReloadConfig(newXMLdata) {
    if (!YWebPage.readonly) {
      if (YWebPage._editor != null)
        YWebPage._editor.visible = false;
      configForm.hide();
      rawDataForm.hide();
      HubEdit.hide();
    }
    logForm.log("Reloading the whole configuration.");
    await sensorsManager.clearHublist();
    for (let i = YWebPage.widgets.length - 1; i >= 0; i--) {
      YWebPage.widgets[i].destroy();
      YWebPage.widgets.splice(i, 1);
    }
    YWebPage.loadFromXML(newXMLdata);
    constants.edited = false;
  }
  static ConfigChanged(newXMLdata) {
    if (YWebPage.ConfigChangedConfirmWindows != null) {
      YWebPage.ConfigChangedConfirmWindows.hide();
    }
    let newCRC = constants.crc32(newXMLdata);
    if (newCRC == YWebPage.xmlDataCRC)
      return;
    logForm.log("Config file changed behind our back!");
    if (!this.readonly) {
      YWebPage.ConfigChangedConfirmWindows = confirm.ask("Configuration has changed on server\nWould you like to reload it?", () => {
        YWebPage.ForceReloadConfig(newXMLdata);
        YWebPage.ConfigChangedConfirmWindows = null;
      }, () => {
        YWebPage.ConfigChangedConfirmWindows = null;
      }, null);
    } else {
      YWebPage.ForceReloadConfig(newXMLdata);
    }
    YWebPage.xmlDataCRC = newCRC;
    constants.edited = false;
  }
  static ShowSaveReminder(visible) {
    if (YWebPage.saveIntDiv == null) {
      YWebPage.saveIntDiv = document.createElement("DIV");
      YWebPage.saveIntDiv.style.position = "fixed";
      YWebPage.saveIntDiv.style.left = "5px";
      YWebPage.saveIntDiv.style.top = "5px";
      YWebPage.saveIntDiv.style.zIndex = "200000";
      YWebPage.saveIntDiv.style.cursor = "pointer";
      YWebPage.saveIntDiv.innerHTML = ressources.SaveNeededIcon((48 * constants.guiDPIFactor).toString(), false, false, false, false);
      YWebPage.saveIntDiv.addEventListener("click", () => {
        YWebPage.saveIntDiv.style.display = "none";
        YWebPage.save(true);
      });
      document.body.appendChild(YWebPage.saveIntDiv);
    }
    YWebPage.saveIntDiv.style.display = visible ? "" : "none";
  }
  static loadFromXML(xmlData) {
    if (xmlData == "") {
      if (!YWebPage.readonly && YWebPage._mainform != null) {
        YWebPage._mainform.show();
      } else {
        YWebPage.EmptyReadonlyConfig();
      }
      return;
    }
    let parser = new DOMParser();
    let doc = parser.parseFromString(xmlData.replace("<!-->", "<!-- "), "application/xml");
    let root = null;
    doc.childNodes.forEach((node) => {
      if (node.nodeName.toUpperCase() == "ROOT" && root == null)
        root = node;
    });
    if (root == null)
      throw "No ROOT top node in XML data";
    root.childNodes.forEach((node) => {
      if (node.nodeName.toUpperCase() == "SENSORS") {
        sensorsManager.setKnownSensors(new YXmlNode(node));
      }
    });
    root.childNodes.forEach((node) => {
      let editor = null;
      editor = YWebPage._editor;
      switch (node.nodeName.toUpperCase()) {
        case "CONFIG":
          constants.Init(new YXmlNode(node));
          break;
        case "GRAPHFORM":
          YWebPage.widgets.push(new graphWidget(new YXmlNode(node), editor));
          break;
        case "ANGULARGAUGEFORM":
          YWebPage.widgets.push(new angularGaugeWidget(new YXmlNode(node), editor));
          break;
        case "GAUGEFORM":
          YWebPage.widgets.push(new gaugeWidget(new YXmlNode(node), editor));
          break;
        case "DIGITALDISPLAYFORM":
          YWebPage.widgets.push(new digitalDisplayWidget(new YXmlNode(node), editor));
          break;
      }
      sensorsManager.registerChangeCallback(() => {
        YWebPage.sensorListHaschanged();
      });
      if (node.nodeName.toUpperCase() == "ROOT" && root == null)
        root = node;
    });
    if (YWebPage.widgets.length <= 0) {
      constants.edited = false;
      if (!YWebPage.readonly && YWebPage._mainform != null) {
        YWebPage._mainform.show();
      } else {
        YWebPage.EmptyReadonlyConfig();
      }
    } else if (!YWebPage.readonly && YWebPage._mainform != null)
      YWebPage._mainform.hide();
  }
  static AnimateNewVerwsionMessage(step) {
    YWebPage.NewVersionmessageDiv.style.left = Math.round(100 - step) + "%";
    if (step < 100) {
      step += 2;
      if (step > 100)
        step = 100;
      setTimeout(() => {
        YWebPage.AnimateNewVerwsionMessage(step);
      });
    }
  }
  static StartInstaller(roothub) {
    let installerDiv = document.createElement("DIV");
    installerDiv.style.position = "absolute";
    installerDiv.style.top = "50%";
    installerDiv.style.left = "50%";
    installerDiv.style.transform = "translate(-50%,-50%)";
    installerDiv.style.width = "550px";
    installerDiv.style.height = "380px";
    installerDiv.style.zIndex = YWebPage.getTopZIndex().toString();
    installerDiv.style.border = "1px solid black";
    installerDiv.style.boxShadow = "rgba(0, 0, 0, 0.05) 4px 4px 4px 1px";
    document.body.appendChild(installerDiv);
    let options = {};
    if (roothub != null)
      options = {
        protocol: roothub.protocol,
        addr: roothub.addr,
        port: parseInt(roothub.port),
        path: roothub.path,
        cancelable: true
      };
    window.startYV4W_installer(installerDiv, options);
  }
  static DownloadAndStartInstaller(installerURL, roothub, deleteTimer) {
    clearTimeout(deleteTimer);
    console.log("Downloading installer (" + installerURL + ")...");
    let P = document.createElement("P");
    P.style.textAlign = "center";
    P.style.fontFamily = constants.generalFontFamily;
    P.style.fontSize = "16px";
    P.innerHTML = "Downloading Installer<br>Please wait...";
    YWebPage.NewVersionmessageDiv.removeChild(YWebPage.NewVersionmessageDiv.firstChild);
    YWebPage.NewVersionmessageDiv.appendChild(P);
    let script = document.createElement("script");
    script.async = false;
    script.type = "module";
    script.onerror = (err) => {
      console.log("Failed to donwload installer (" + Event.toString() + ")");
      P.innerHTML = "Failed to download installer,<br>Check conole logs";
    };
    script.onload = () => {
      P.innerHTML = "Starting installer...";
      YWebPage.DeleteNewVersionMessage(100);
      YWebPage.StartInstaller(roothub);
    };
    document.body.appendChild(script);
    script.src = installerURL;
  }
  static DeleteNewVersionMessage(opacity) {
    opacity -= 5;
    if (opacity > 0) {
      YWebPage.NewVersionmessageDiv.style.opacity = (opacity / 100).toString();
      setTimeout(() => {
        YWebPage.DeleteNewVersionMessage(opacity);
      }, 100);
      return;
    }
    document.body.removeChild(YWebPage.NewVersionmessageDiv.parentNode);
  }
  static getTopZIndex() {
    var elems = document.getElementsByTagName("DIV");
    var highestZ = 0;
    for (var i = 0; i < elems.length; i++) {
      var z = Number.parseInt(window.getComputedStyle(elems[i], null).getPropertyValue("z-index"));
      if (z > highestZ)
        highestZ = z;
    }
    return highestZ + 1;
  }
  static async CheckForNewVersion(force) {
    if (!constants.mustCheckForUpdate && !force)
      return;
    let checkurl = location.protocol + "//www.yoctopuce.com/FR/common/getLastFirmwareLink.php?app=yoctovisualization4web.installer&version=" + constants.buildVersion + "&platform=_";
    let response;
    try {
      response = await fetch(checkurl);
    } catch (e) {
      return;
    }
    if (!response.ok)
      return;
    let json;
    try {
      json = await response.json();
    } catch (e) {
      return;
    }
    if (!(json instanceof Array))
      return;
    if (json.length <= 0)
      return;
    if (!("version" in json[0]))
      return;
    if (!("link" in json[0]))
      return;
    let newVersionInstallerURL = json[0]["link"];
    let newVersionNumber = parseInt(json[0]["version"]);
    let currentVersionStr = constants.buildVersion;
    let currentVersionNumber = 0;
    if (currentVersionStr.indexOf("-") < 0) {
      let n = currentVersionStr.lastIndexOf(".");
      if (n >= 0)
        currentVersionStr = currentVersionStr.substr(n + 1);
      currentVersionNumber = parseInt(currentVersionStr);
    }
    if (currentVersionNumber >= newVersionNumber)
      return;
    let generalSize = constants.generalFontSize;
    let NewVersionSizeX = generalSize * 24;
    let NewVersionSizeY = generalSize * 5;
    let containerDiv = document.createElement("DIV");
    containerDiv.style.position = "absolute";
    containerDiv.style.width = NewVersionSizeX + "px";
    containerDiv.style.height = NewVersionSizeY + "px";
    containerDiv.style.zIndex = YWebPage.getTopZIndex().toString();
    containerDiv.style.top = "5px";
    containerDiv.style.right = "0px";
    containerDiv.style.overflow = "hidden";
    document.body.appendChild(containerDiv);
    YWebPage.NewVersionmessageDiv = document.createElement("DIV");
    YWebPage.NewVersionmessageDiv.style.position = "absolute";
    YWebPage.NewVersionmessageDiv.style.width = NewVersionSizeX - 7 + "px";
    YWebPage.NewVersionmessageDiv.style.height = NewVersionSizeY - 2 + "px";
    YWebPage.NewVersionmessageDiv.style.backgroundColor = "GhostWhite";
    YWebPage.NewVersionmessageDiv.style.border = "1px solid dimgray";
    YWebPage.NewVersionmessageDiv.style.top = "0px";
    YWebPage.NewVersionmessageDiv.style.left = NewVersionSizeX + "px";
    let table = document.createElement("TABLE");
    table.style.fontFamily = constants.generalFontFamily;
    table.style.fontSize = generalSize + "px";
    let TR = document.createElement("TR");
    let TD1 = document.createElement("TD");
    TD1.style.paddingLeft = "5px";
    TD1.style.paddingRight = "10px";
    TD1.rowSpan = 2;
    TD1.style.verticalAlign = "middle";
    TD1.innerHTML = ressources.infoIcon((generalSize * 4).toString(), false, false, false, false, "information");
    TR.appendChild(TD1);
    let TD2 = document.createElement("TD");
    TD2.innerHTML = "A new Yocto-Visualization (for web)<br>version is available";
    TR.appendChild(TD2);
    table.appendChild(TR);
    TR = document.createElement("TR");
    TD2 = document.createElement("TD");
    TD2.style.textAlign = "right";
    TD2.style.verticalAlign = "bottom";
    let hubList = sensorsManager.hubList;
    let rootHub = null;
    for (let i = 0; i < hubList.length; i++) {
      if (!hubList[i].removable)
        rootHub = hubList[i];
    }
    let a = document.createElement("A");
    let deleteTimer = setTimeout(() => {
      YWebPage.DeleteNewVersionMessage(100);
    }, 5e3);
    a.style.fontSize = "12px";
    a.style.color = " #0000EE";
    a.style.textDecoration = "underline";
    a.style.cursor = "pointer";
    a.style.fontFamily = constants.generalFontFamily;
    a.style.fontSize = generalSize + "px";
    if (rootHub != null) {
      a.innerText = "Download and start installer..";
      a.addEventListener("click", () => {
        YWebPage.DownloadAndStartInstaller(newVersionInstallerURL, rootHub, deleteTimer);
      });
    } else {
      a.innerText = "www.yoctopuce.com";
      a.addEventListener("click", () => {
        window.location.assign("http://www.yoctopuce.com/EN/tools.php");
      });
    }
    TD2.appendChild(a);
    TR.appendChild(TD2);
    table.appendChild(TR);
    YWebPage.NewVersionmessageDiv.appendChild(table);
    containerDiv.appendChild(YWebPage.NewVersionmessageDiv);
    YWebPage.AnimateNewVerwsionMessage(0);
  }
  static run(xmlData, ExternalConfigChange, saveFunction) {
    if (typeof ExternalConfigChange !== "undefined") {
      if (ExternalConfigChange != null) {
        sensorsManager.registerChangeExternalCallback(ExternalConfigChange);
      }
    }
    YWebPage.xmlDataCRC = constants.crc32(xmlData);
    if (typeof saveFunction !== "undefined")
      YWebPage._saveFunction = saveFunction;
    logForm.log("Application start, Welcome to Yocto-Visualization (for web).");
    logForm.log("This application contains code ported from the Pako library (www.github.com/nodeca/pako).");
    logForm.log("Yocto-Visualization version is " + constants.buildVersion);
    logForm.log("Yoctopuce API version is " + YAPI.imm_GetAPIVersion());
    if (constants.RunningOnAndroid)
      logForm.log("Browser is running on Android");
    let widthCm = Math.round(2.54 * constants.deviceScreenWidth / constants.screenDPI);
    let heightCm = Math.round(2.54 * constants.deviceScreenHeight / constants.screenDPI);
    logForm.log("Reported screen size is " + constants.deviceScreenWidth.toString() + "x" + constants.deviceScreenHeight.toString() + " at " + constants.screenDPI + " dpi, (~" + widthCm.toString() + "x" + heightCm.toString() + "cm) ");
    logForm.log("Reported pixel ratio is " + window.devicePixelRatio.toString());
    logForm.log(constants.isPhoneOrTablet ? "Probably running on a tablet or a phone." : "Probably running on a desktop.");
    logForm.log((constants.guiDPIFactorWasOverriden ? "DPI based zoom overridden  to " : "DPI based zoom factor set to ") + constants.guiDPIFactor.toFixed(1));
    logForm.log("Reported window inner size =" + window.innerWidth.toString() + "x" + window.innerHeight.toString() + "px");
    YWebPage.applicationGlobalinit();
    sensorsManager.run();
    YWebPage.loadFromXML(xmlData);
    constants.edited = false;
    YWebPage.CheckForNewVersion(false);
  }
  static async pageIsleaving(e) {
    if (!e.persistent) {
      if (constants.edited) {
        await YWebPage.save(false);
        await YAPI.FreeAPI();
      }
    }
  }
  static refreshEditor() {
    if (YWebPage.readonly)
      return;
    if (YWebPage._editor == null)
      return;
    YWebPage._editor.refresh();
  }
  static EditObject(widget, structData, setvalueCallBack, getvalueCallBack, EditStoppedCallBack) {
    if (YWebPage.readonly)
      return;
    if (YWebPage._editor == null)
      return;
    YWebPage._editor.showWindow(widget, structData, setvalueCallBack, getvalueCallBack, EditStoppedCallBack);
  }
  static get_XmlData() {
    let XmlConfigFile = `<?xml version="1.0" ?>
<!--
   **************************************************
   Yocto-Visualization (for web)  configuration file
   **************************************************
-->
<ROOT version='2.1'>
<!-- in 2.1 version, floating point values are saved in CultureInfo.InvariantCulture form -->
`;
    XmlConfigFile += constants.GetXMLConfiguration();
    for (let i = 0; i < YWebPage.widgets.length; i++) {
      if (YWebPage.widgets[i] instanceof graphWidget)
        XmlConfigFile += YWebPage.widgets[i].getConfigData();
      if (YWebPage.widgets[i] instanceof angularGaugeWidget)
        XmlConfigFile += YWebPage.widgets[i].getConfigData();
      if (YWebPage.widgets[i] instanceof gaugeWidget)
        XmlConfigFile += YWebPage.widgets[i].getConfigData();
      if (YWebPage.widgets[i] instanceof digitalDisplayWidget)
        XmlConfigFile += YWebPage.widgets[i].getConfigData();
    }
    XmlConfigFile += sensorsManager.getXMLSensorsConfig();
    XmlConfigFile += "</ROOT>\n";
    return XmlConfigFile;
  }
  static get readonly() {
    let res = true;
    res = YWebPage._saveFunction == null;
    return res;
  }
  static async runInternalTest() {
  }
  static async save(force) {
    if (YWebPage.readonly)
      return true;
    let xml = this.get_XmlData();
    let newCRC = constants.crc32(xml);
    if (!force && newCRC == YWebPage.xmlDataCRC)
      return true;
    let saveDoneCallback = (ok, message) => {
      let div = document.createElement("DIV");
      div.style.position = "Fixed";
      div.style.left = "5px";
      div.style.top = "5px";
      div.style.padding = "2px 5px 2px 5px";
      div.style.margin = "2px 2px 2px 2px";
      div.style.border = "1px solid darkgreen";
      div.style.fontFamily = "Arial";
      div.style.fontSize = (12 * constants.guiDPIFactor).toString();
      div.style.whiteSpace = "nowrap";
      div.style.zIndex = "200000";
      div.style.textAlign = "center";
      div.style.opacity = "1";
      let fgcolor = ok ? "darkgreen" : "darkred";
      let bgcolor = ok ? "#b9eea9" : "#eea9a9";
      div.style.opacity = "1";
      div.style.backgroundColor = bgcolor;
      div.style.border = "1px solid " + fgcolor;
      div.style.color = fgcolor;
      div.innerText = message;
      document.body.appendChild(div);
      setTimeout(() => {
        YWebPage.handleSavedNotification(div);
      }, 100);
    };
    try {
      if (YWebPage._saveFunction != null) {
        return await YWebPage._saveFunction(this.get_XmlData(), saveDoneCallback);
      }
    } catch (e) {
      saveDoneCallback(false, "Save failed");
      alert2.show("Configuration save failed, sorry\n" + e.message);
      return false;
    }
    YWebPage.xmlDataCRC = newCRC;
    logForm.log("Configuration saved.");
    constants.edited = false;
    return true;
  }
  static handleSavedNotification(div) {
    let opacity = parseFloat(div.style.opacity) - 0.05;
    if (opacity < 0) {
      document.body.removeChild(div);
      return;
    }
    div.style.opacity = opacity.toString();
    setTimeout(() => {
      YWebPage.handleSavedNotification(div);
    }, 100);
  }
  static Dummysave(xml) {
    let contents = document.createElement("PRE");
    contents.innerText = xml;
    document.body.appendChild(contents);
    return true;
  }
};
YWebPage.baseSize = 18 * constants.generalSizeCoef;
YWebPage.xmlDataCRC = 0;
YWebPage.widgets = [];
YWebPage._markersSubMenuItems = [];
YWebPage._editor = null;
YWebPage._mainform = null;
YWebPage._saveFunction = null;
YWebPage._MarkerCountPerXaxis = 0;
YWebPage.ConfigChangedConfirmWindows = null;
YWebPage.saveIntDiv = null;
var HTTPrequestResult = class {
  constructor(data, status, statusText) {
    this._data = data;
    this._status = status;
    this._statusText = statusText;
  }
  get data() {
    return this._data;
  }
  get status() {
    return this._status;
  }
  get statusText() {
    return this._statusText;
  }
};
var HubInfo = class {
  get protocol() {
    return this._protocol;
  }
  get addr() {
    return this._addr;
  }
  get port() {
    return this._port;
  }
  get path() {
    return this._path;
  }
  get userPassword() {
    return this._userPassword;
  }
  get adminPassword() {
    return this._adminPassword;
  }
  get serial() {
    return this._serial;
  }
  get srvUsername() {
    return this._srvusername != null ? this._srvusername : "";
  }
  get srvPassword() {
    return this._srvpassword != null ? this._srvpassword : "";
  }
  constructor(protocol, addr, port, path, srvusername, srvpassword) {
    this._userPassword = false;
    this._adminPassword = false;
    this._cred = "";
    this._serial = "";
    this._srvusername = null;
    this._srvpassword = null;
    if (protocol.slice(-1) == ":")
      protocol = protocol.slice(0, -1);
    this._protocol = protocol;
    this._addr = addr;
    this._port = port;
    this._protocol = protocol;
    this._path = path;
    if (srvusername !== void 0)
      this._srvusername = srvusername;
    if (srvpassword !== void 0)
      this._srvpassword = srvpassword;
    if (this._path != "") {
      if (this._path.charAt(0) == "/") {
        this._path = this._path.slice(1);
      }
    }
    if (this._path != "") {
      if (this._path.slice(-1) == "/") {
        this._path = this._path.slice(0, -1);
      }
    }
  }
  get_hubUrl(user, password) {
    let url = this.protocol + "://";
    if (typeof user != "undefined" && user != "") {
      if (user != "") {
        url += user + ":" + password + "@";
      }
    }
    url += this.addr + ":" + this.port.toString();
    if (this.path != "")
      url += "/" + this.path;
    return url;
  }
  async makeRequest() {
    let url = this._protocol + "://" + this._addr + ":" + this._port.toString();
    if (this._path != "")
      url += "/" + this._path;
    url += "/info.json";
    let response;
    try {
      response = await fetch(url, {mode: "cors"});
    } catch (e) {
      return -3;
    }
    if (response.ok) {
      let HubData;
      try {
        HubData = await response.json();
      } catch (e) {
        return -1;
      }
      if (HubData.port && HubData.port.length > 0) {
        let proto_port = HubData.port[0].split(":");
        this._protocol = proto_port[0];
        this._port = parseInt(proto_port[1]);
      }
      this._serial = HubData.serialNumber;
      this._path = HubData.dir;
      this._adminPassword = HubData.adminPassword.toUpperCase() == "TRUE";
      this._userPassword = HubData.userPassword.toUpperCase() == "TRUE";
      return true;
    }
    if (response.status == 404 && this._path != "")
      return -2;
    if (response.status == 0 && response.statusText == null)
      return -3;
    return response.status;
  }
  findChild(parent, name) {
    let res = null;
    parent.childNodes.forEach((node) => {
      if (node.nodeName == name) {
        res = node;
        return;
      }
    });
    return res;
  }
  findOutCredentialsFromConfigFile(xmlData) {
    if (xmlData == null)
      return;
    let parser = new DOMParser();
    let doc = parser.parseFromString(xmlData, "application/xml");
    let rootNode = this.findChild(doc, "ROOT");
    if (rootNode == null)
      return;
    let configNode = this.findChild(rootNode, "Config");
    if (configNode == null)
      return;
    let Hubs = this.findChild(configNode, "Hubs");
    if (Hubs == null)
      return;
    let HubSection;
    let list = Hubs.childNodes;
    let sourceHubFound = false;
    for (let i = 0; i < list.length; i++) {
      if (list[i].nodeName == "Hub") {
        let node = new YXmlNode(list[i]);
        let attributes = node.Attributes;
        let addr = attributes.hasOwnProperty("addr") ? attributes["addr"] : "";
        let port = attributes.hasOwnProperty("port") ? attributes["port"] : "80";
        let protocol = attributes.hasOwnProperty("protocol") ? attributes["protocol"] : "";
        let path = attributes.hasOwnProperty("path") ? attributes["path"] : "";
        let username = attributes.hasOwnProperty("user") ? attributes["user"] : "";
        let password = attributes.hasOwnProperty("password") ? attributes["password"] : "";
        let a1 = addr.toUpperCase();
        if (a1.substring(0, 4) == "WWW.")
          a1 = a1.substring(4);
        let a2 = this._addr.toUpperCase();
        if (a2.substring(0, 4) == "WWW.")
          a2 = a2.substring(4);
        if (a1 == a2 && path == this._path) {
          this._srvusername = username;
          this._srvpassword = Hub.Decrypt(password, Hub.loginCypherPassword);
        }
      }
    }
  }
};
var YoctoHubFileHandler = class {
  constructor(hubInfo) {
    this.filename = "";
    this.xmldata = "";
    this.htmlSrcCode = "";
    this.FileSystemAccessDenied = false;
    this._XMLConfigFileChanged = null;
    this.fileSystem = null;
    this.fileSystemReady = false;
    this.configFileCRC = -1;
    this.info = hubInfo;
  }
  async init(defaultXmlConfigFileContents) {
    let url = location.href;
    this.filename = url.substring(url.lastIndexOf("/") + 1);
    let p = this.filename.indexOf("?");
    if (p > 0)
      this.filename = this.filename.substring(0, p);
    this.htmlSrcCode = document.documentElement.outerHTML;
    if (typeof defaultXmlConfigFileContents === "undefined" || defaultXmlConfigFileContents == "") {
      this.xmldata = '<?xml version="1.0" ?>\n<ROOT version="2.1">\n<Config>\n<Hubs>\n<Hub protocol="' + this.info.protocol + '" addr="' + this.info.addr + '" port="' + this.info.port.toString() + '"' + (this.info.path != "" ? ' path="' + this.info.path + '"' : "") + ' removable="FALSE"/>\n</Hubs>\n</Config>\n</ROOT>\n';
    } else {
      this.xmldata = defaultXmlConfigFileContents;
    }
    this.fileSystem = null;
    this.fileSystemReady = false;
    await this.findSourceFileSystem(defaultXmlConfigFileContents);
  }
  static async start(defaultXmlConfigFileContents) {
    let dirpath = location.pathname;
    let defport = "80";
    let slashpos = dirpath.lastIndexOf("/");
    if (slashpos > 0) {
      dirpath = dirpath.slice(0, slashpos);
    } else {
      dirpath = "";
    }
    if (location.protocol == "https:") {
      defport = "443";
    }
    let hubinfo = new HubInfo(location.protocol, location.hostname, parseInt(location.port ? location.port : defport), dirpath);
    await hubinfo.makeRequest();
    let filehandler = new YoctoHubFileHandler(hubinfo);
    await filehandler.init(defaultXmlConfigFileContents);
    return filehandler;
  }
  get xmlConfigData() {
    return this.xmldata;
  }
  static makeRequest(method, url, username, password) {
    return new Promise(function(resolve, reject) {
      let xhr = new XMLHttpRequest();
      if (username !== void 0 && password !== void 0 && username != null && password !== null) {
        xhr.open(method, url, true, username, password);
        xhr.withCredentials = true;
      } else {
        xhr.open(method, url);
      }
      xhr.overrideMimeType("text/plain; charset=x-user-defined");
      xhr.onreadystatechange = function() {
        if (xhr.readyState == 4) {
          if (this.status >= 200 && this.status < 300) {
            resolve(new HTTPrequestResult(YAPI.imm_str2bin(xhr.response), this.status, xhr.statusText));
          } else {
            resolve(new HTTPrequestResult(null, this.status, xhr.statusText));
          }
        }
      };
      xhr.onerror = function() {
        resolve(new HTTPrequestResult(null, this.status, xhr.statusText));
      };
      xhr.send();
    });
  }
  async findSourceFileSystem(xmldata) {
    this.fileSystem = null;
    let errmsg = new YErrorMsg();
    this.info.findOutCredentialsFromConfigFile(xmldata);
    let url = this.info.get_hubUrl(this.info.srvUsername, this.info.srvPassword);
    let errorNo = YAPI.SUCCESS;
    let errorMsg = "";
    try {
      errorNo = await YAPI.RegisterHub(url, errmsg);
      errorMsg = errmsg.msg;
    } catch (e) {
      errorNo = e.errorType;
      errorMsg = e.message;
    }
    if (errorNo != YAPI.SUCCESS) {
      this.fileSystemReady = false;
      if (errorNo == YAPI.UNAUTHORIZED) {
        console.log("Access to hub " + url + " is denied, waiting for YV callback to save the situation.");
        this.FileSystemAccessDenied = true;
        return;
      }
      throw "YV4F ERROR: Unable to register Hub " + this.info.get_hubUrl() + "(" + errorMsg + "), save will not work.";
    }
    let fs = YFiles.FirstFiles();
    if (fs == null) {
      this.fileSystemReady = true;
      throw "YV4F ERROR: No file system found on Hub " + this.info.get_hubUrl() + ", save will not work.";
    }
    while (fs != null) {
      if (await fs.get_serialNumber() == this.info.serial) {
        await this.registerSourceFileSystem(fs);
        return;
      }
      fs = fs.nextFiles();
    }
    fs = YFiles.FirstFiles();
    while (fs != null) {
      let m = await fs.get_module();
      let url2 = await m.get_url();
      console.log("URL = (" + url2 + ")");
      let p = url2.indexOf("://");
      if (p >= 0)
        url2 = url2.slice(p + 3);
      p = url2.indexOf(":");
      if (p > 0)
        url2 = url2.slice(0, p);
      {
        if (url2 == this.info.addr) {
          await this.registerSourceFileSystem(fs);
          return;
        }
      }
      fs = fs.nextFiles();
    }
    this.fileSystemReady = true;
    throw "YV4F ERROR: No file system matching Hub " + this.info.get_hubUrl() + " found, save will not work.";
  }
  async registerSourceFileSystem(fs) {
    this.fileSystem = fs;
    this.fileSystemReady = true;
    this.FileSystemAccessDenied = false;
    let entries = await this.fileSystem.get_list(this.filename);
    if (entries.length > 0)
      this.configFileCRC = await entries[0].get_crc();
  }
  async configChangeCallback(m) {
    if (this.fileSystem == null) {
      let urlSignature = this.info.addr + ":" + this.info.port.toString() + "/" + this.info.path + (this.info.path != "" ? "/" : "");
      let sourceUrl = await m.get_url();
      console.log("urlSignature=" + urlSignature);
      console.log("sourceUrl=" + sourceUrl);
      if (sourceUrl.length > urlSignature.length && sourceUrl.substring(sourceUrl.length - urlSignature.length) == urlSignature) {
        let fs = YFiles.FindFiles(await m.get_serialNumber() + ".files");
        if (await fs.isOnline())
          await this.registerSourceFileSystem(fs);
      }
    }
    if (this.fileSystem == null)
      return null;
    if (await this.fileSystem.get_serialNumber() != await m.get_serialNumber())
      return null;
    let entries = await this.fileSystem.get_list(this.filename);
    if (entries.length <= 0)
      return null;
    if (this.configFileCRC == await entries[0].get_crc())
      return null;
    let data = await this.fileSystem.download(this.filename);
    let file = new TextDecoder("utf-8").decode(data);
    let indexStart = file.indexOf(YoctoHubFileHandler.signatureStart);
    if (indexStart < 0)
      return null;
    this.configFileCRC = await entries[0].get_crc();
    indexStart += YoctoHubFileHandler.signatureStart.length;
    let indexEnd = file.indexOf(YoctoHubFileHandler.signatureEnd);
    if (indexEnd < indexStart)
      return "";
    indexEnd += YoctoHubFileHandler.signatureEnd.length - 2;
    let configdata = file.substring(indexStart, indexEnd);
    try {
      return JSON.parse(configdata);
    } catch (e) {
    }
    return null;
  }
  get configChangeCallbackFct() {
    return async (module) => {
      return await this.configChangeCallback(module);
    };
  }
  get saveFct() {
    return async (xml, callback) => {
      return await this.saveFctinternal(xml, callback);
    };
  }
  async retryWithNewCredentials(xml, username, password, callback) {
    if (this.fileSystem == null) {
      debugger;
      return;
    }
    let m = await this.fileSystem.get_module();
    let url = await m.get_url();
    let err = new YErrorMsg();
    let p1 = url.indexOf("://");
    let p2 = url.indexOf("@", p1 + 3);
    let newurl = url.substring(0, p1 + 3) + username + ":" + password + "@";
    if (p2 < 0)
      newurl += url.substring(p1 + 3);
    else
      newurl += url.substring(p2 + 1);
    await YAPI.UnregisterHub(url);
    if (await YAPI.RegisterHub(newurl, err) != YAPI.SUCCESS) {
      await YAPI.RegisterHub(url, err);
    }
    try {
      if (!await this.saveFctinternal(xml, callback))
        return;
    } catch (e) {
      if (callback != null)
        callback(false, "Save failed (" + e.message) + ")";
      return;
    }
  }
  async saveFctinternal(xml, callback) {
    if (this.FileSystemAccessDenied) {
      throw "YV4F ERROR: Access to file system on " + this.info.get_hubUrl() + " is denied, it is probably password protected. Check network connections in the global configuration.";
    }
    if (this.fileSystem == null) {
      throw "YV4F ERROR: No file system, Save aborted";
    }
    if (!this.fileSystemReady) {
      throw "YV4F ERROR: File system is not ready yet, retry in a few seconds.";
    }
    if (!this.fileSystem.isOnline()) {
      throw "YV4F ERROR: File system is off line, Save aborted";
    }
    let tosave = "";
    let index = this.htmlSrcCode.indexOf(YoctoHubFileHandler.signatureStart + ")");
    if (index > 0) {
      tosave = this.htmlSrcCode.substring(0, index + YoctoHubFileHandler.signatureStart.length) + JSON.stringify(xml) + this.htmlSrcCode.substring(index + YoctoHubFileHandler.signatureStart.length);
    } else {
      let index1 = this.htmlSrcCode.indexOf(YoctoHubFileHandler.signatureStart);
      let index2 = this.htmlSrcCode.indexOf(YoctoHubFileHandler.signatureEnd);
      if (index1 > 0 && index2 && index2 > index1) {
        tosave = this.htmlSrcCode.substring(0, index1 + YoctoHubFileHandler.signatureStart.length) + JSON.stringify(xml) + ");" + this.htmlSrcCode.substring(index2 + YoctoHubFileHandler.signatureEnd.length);
      } else {
        throw "Unable to locate YoctoHubFileHandler constructor call in original HTML file.";
      }
    }
    tosave = "<!DOCTYPE html>\n" + tosave;
    let GZdata = Pako_Deflate.gzip(tosave, {level: 9});
    let askForRwCredentials = false;
    try {
      await this.fileSystem.upload(this.filename + ".gz", GZdata);
    } catch (e) {
      if (this.fileSystem.get_errorType() == YAPI_UNAUTHORIZED)
        askForRwCredentials = true;
      else
        throw e;
    }
    if (askForRwCredentials) {
      let m = await this.fileSystem.get_module();
      let url = await m.get_url();
      let err = new YErrorMsg();
      let p1 = url.indexOf("://");
      let p2 = url.indexOf("@", p1 + 3);
      if (p2 >= 0)
        url = url.substring(p2 + 1);
      else if (p1 >= 0)
        url = url.substring(p1 + 3);
      await CredentialsPrompt.show(url, async () => {
        await this.retryWithNewCredentials(xml, CredentialsPrompt.username, CredentialsPrompt.password, callback);
      });
      if (callback != null)
        callback(false, "Save failed, credentials required");
      return false;
    }
    let entries = await this.fileSystem.get_list(this.filename);
    if (entries.length > 0)
      this.configFileCRC = await entries[0].get_crc();
    if (callback != null)
      callback(true, "Save sucessfull");
    return true;
  }
};
YoctoHubFileHandler.signatureStart = "YoctoHubFileHandler.start(";
YoctoHubFileHandler.signatureEnd = '</ROOT>\\n");';

// obj/full/logForm.js
var logForm = class {
  static show() {
    if (logForm._window == null) {
      let params = new newWindowParam();
      params.positionType = 0;
      params.width = 8 * window.innerWidth / 10 >> 0;
      params.height = 6 * window.innerHeight / 10 >> 0;
      params.left = 1 * window.innerWidth / 10 >> 0;
      params.top = 2 * window.innerHeight / 10 >> 0;
      params.title = "LogFile";
      logForm._window = new YWindow(params);
      logForm._contents = logForm._window.innerContentDiv;
      logForm._contents.style.fontFamily = "courrier";
      logForm._contents.style.fontSize = (10 * constants.generalSizeCoef).toString() + "px";
      logForm._contents.style.overflow = "auto";
      for (let i = 0; i < logForm._lines.length; i++) {
        logForm.addLine(logForm._lines[i]);
      }
    }
    logForm._window.show();
  }
  static addLine(st) {
    let pre = document.createElement("PRE");
    pre.style.marginTop = "0";
    pre.style.marginBottom = "0";
    pre.innerText = st;
    logForm._contents.appendChild(pre);
    while (logForm._contents.childElementCount > 1e3) {
      logForm._contents.removeChild(logForm._contents.firstChild);
    }
  }
  static padStart(st, length) {
    while (st.length < length) {
      st = "0" + st;
    }
    return st;
  }
  static dateToString(d) {
    return d.getFullYear().toString() + "-" + logForm.padStart((d.getMonth() + 1).toString(), 2) + "-" + logForm.padStart(d.getDate().toString(), 2) + " " + logForm.padStart(d.getHours().toString(), 2) + ":" + logForm.padStart(d.getMinutes().toString(), 2) + ":" + logForm.padStart((d.getSeconds() + d.getMilliseconds() / 1e3).toFixed(3), 6);
  }
  static log(st) {
    logForm.logNOTS(logForm.dateToString(new Date()) + " " + st);
  }
  static logNOTS(st) {
    logForm._lines.push(st);
    if (logForm._lines.length > 1e3) {
      logForm._lines.splice(0, logForm._lines.length - 1e3);
    }
    if (logForm._window != null)
      logForm.addLine(st);
  }
};
logForm._lines = [];

// obj/full/rawDataForm.js
var rawDataForm = class {
  static hide() {
    if (rawDataForm._window == null)
      return;
    rawDataForm._window.visible = false;
  }
  static show() {
    if (rawDataForm._window == null) {
      let params = new newWindowParam();
      params.positionType = 1;
      params.width = 9 * window.innerWidth / 10 >> 0;
      params.height = 8 * window.innerHeight / 10 >> 0;
      params.title = "Raw data";
      rawDataForm._window = new YWindow(params);
      rawDataForm._contents = rawDataForm._window.innerContentDiv;
      rawDataForm._statusline = document.createElement("DIV");
      rawDataForm._statusline.style.position = "absolute";
      rawDataForm._statusline.style.left = constants.WindowPadding.toString() + "px";
      rawDataForm._statusline.style.right = constants.WindowPadding.toString() + "px";
      rawDataForm._statusline.style.height = (rawDataForm.STATUSLINEHEIGHT * constants.generalSizeCoef).toString() + "px";
      rawDataForm._statusline.style.bottom = constants.WindowPadding.toString() + "px";
      rawDataForm._statusline.style.paddingTop = Math.round(5 * constants.generalSizeCoef).toString() + "px";
      rawDataForm._statusline.style.paddingLeft = "5px";
      rawDataForm._statusline.style.paddingRight = "5px";
      rawDataForm._statusline.style.overflowX = "auto";
      rawDataForm._statusline.style.paddingRight = "5px";
      rawDataForm._contents.append(rawDataForm._statusline);
      rawDataForm._sensorsList = document.createElement("DIV");
      rawDataForm._sensorsList.style.position = "absolute";
      rawDataForm._sensorsList.style.left = constants.WindowPadding.toString() + "px";
      rawDataForm._sensorsList.style.right = (rawDataForm.sensorListWidth * constants.generalSizeCoef + 8 * constants.WindowPadding).toString() + "px";
      rawDataForm._sensorsList.style.top = "2px";
      rawDataForm._sensorsList.style.overflowY = "auto";
      rawDataForm._sensorsList.style.height = (rawDataForm.topMargin * constants.generalSizeCoef).toString() + "px";
      rawDataForm._sensorsList.style.paddingLeft = "5px";
      rawDataForm._sensorsList.style.paddingRight = "5px";
      rawDataForm._sensorsList.style.border = constants.WindowInnerBorder;
      rawDataForm._sensorsList.style.backgroundColor = constants.WindowInnerBackgroundColor;
      rawDataForm._contents.append(rawDataForm._sensorsList);
      rawDataForm._optionsList = document.createElement("DIV");
      rawDataForm._optionsList.style.position = "absolute";
      rawDataForm._optionsList.style.width = (rawDataForm.sensorListWidth * constants.generalSizeCoef).toString() + "px";
      rawDataForm._optionsList.style.right = constants.WindowPadding.toString() + "px";
      rawDataForm._optionsList.style.top = "0px";
      rawDataForm._optionsList.style.height = (rawDataForm.topMargin * constants.generalSizeCoef).toString() + "px";
      rawDataForm._optionsList.style.paddingLeft = "5px";
      rawDataForm._optionsList.style.paddingRight = "5px";
      rawDataForm._optionsList.style.border = "1px solid transparent";
      rawDataForm._contents.append(rawDataForm._optionsList);
      let br;
      rawDataForm._optionMIN = document.createElement("INPUT");
      rawDataForm._optionMIN.type = "input";
      rawDataForm._optionMIN.checked = false;
      rawDataForm._optionMIN.style.display = "inline";
      rawDataForm._optionMIN.type = "checkbox";
      rawDataForm._optionMIN.style.transform = "scale(" + constants.generalSizeCoef.toString() + ")";
      rawDataForm._optionMIN.style.marginRight = Math.round(5 * constants.generalSizeCoef).toString() + "px";
      rawDataForm._optionMIN.addEventListener("change", () => {
        rawDataForm.refresh();
      });
      rawDataForm._optionsList.append(rawDataForm._optionMIN);
      let span;
      span = document.createElement("SPAN");
      span.innerText = "Include minimum values";
      rawDataForm._optionsList.append(span);
      br = document.createElement("BR");
      rawDataForm._optionsList.append(br);
      rawDataForm._optionAVG = document.createElement("INPUT");
      rawDataForm._optionAVG.type = "input";
      rawDataForm._optionAVG.checked = true;
      rawDataForm._optionAVG.style.display = "inline";
      rawDataForm._optionAVG.type = "checkbox";
      rawDataForm._optionAVG.style.transform = "scale(" + constants.generalSizeCoef.toString() + ")";
      rawDataForm._optionAVG.style.marginRight = Math.round(5 * constants.generalSizeCoef).toString() + "px";
      rawDataForm._optionAVG.addEventListener("change", () => {
        rawDataForm.refresh();
      });
      rawDataForm._optionsList.append(rawDataForm._optionAVG);
      span = document.createElement("SPAN");
      span.innerText = "Include average values";
      rawDataForm._optionsList.append(span);
      br = document.createElement("BR");
      rawDataForm._optionsList.append(br);
      rawDataForm._optionMAX = document.createElement("INPUT");
      rawDataForm._optionMAX.type = "input";
      rawDataForm._optionMAX.checked = false;
      rawDataForm._optionMAX.style.display = "inline";
      rawDataForm._optionMAX.type = "checkbox";
      rawDataForm._optionMAX.style.transform = "scale(" + constants.generalSizeCoef.toString() + ")";
      rawDataForm._optionMAX.style.marginRight = Math.round(5 * constants.generalSizeCoef).toString() + "px";
      rawDataForm._optionMAX.addEventListener("change", () => {
        rawDataForm.refresh();
      });
      rawDataForm._optionsList.append(rawDataForm._optionMAX);
      span = document.createElement("SPAN");
      span.innerText = "Include maximum values";
      rawDataForm._optionsList.append(span);
      rawDataForm._optionsList.append(document.createElement("BR"));
      rawDataForm._optionsList.append(document.createElement("BR"));
      let p = document.createElement("P");
      p.style.textAlign = "center";
      let refreshBtn = new button("refresh", () => {
        rawDataForm.refresh();
      });
      p.appendChild(refreshBtn.Element);
      let ExportBtn = new button("export", () => {
        rawDataForm.export();
      });
      p.appendChild(ExportBtn.Element);
      rawDataForm._optionsList.append(p);
      rawDataForm._datacontents = document.createElement("DIV");
      rawDataForm._datacontents.style.position = "absolute";
      rawDataForm._datacontents.style.left = constants.WindowPadding.toString() + "px";
      rawDataForm._datacontents.style.right = constants.WindowPadding.toString() + "px";
      rawDataForm._datacontents.style.top = (rawDataForm.topMargin * constants.generalSizeCoef + 5 * constants.WindowPadding).toString() + "px";
      rawDataForm._datacontents.style.bottom = (4 * constants.WindowPadding + rawDataForm.STATUSLINEHEIGHT * constants.generalSizeCoef).toString() + "px";
      rawDataForm._datacontents.style.paddingLeft = "5px";
      rawDataForm._datacontents.style.paddingRight = "5px";
      rawDataForm._datacontents.style.overflowX = "auto";
      rawDataForm._datacontents.style.paddingRight = "5px";
      rawDataForm._contents.append(rawDataForm._datacontents);
      rawDataForm._dataTable = document.createElement("TABLE");
      rawDataForm._dataTable.style.position = "absolute";
      rawDataForm._dataTable.style.overflow = "auto";
      rawDataForm._dataTable.style.left = "0px";
      rawDataForm._dataTable.style.width = "100%";
      rawDataForm._dataTable.style.top = "0px";
      rawDataForm._dataTable.style.bottom = "0px";
      rawDataForm._dataTable.style.fontSize = constants.generalFontSize.toString() + "px";
      rawDataForm._dataTable.style.borderCollapse = "colapse";
      rawDataForm._dataTable.style.borderSpacing = "0px";
      rawDataForm._dataTable.style.fontFamily = "sans-serif";
      rawDataForm._datacontents.appendChild(rawDataForm._dataTable);
    }
    rawDataForm._window.show();
    rawDataForm.refresh();
  }
  static refresh() {
    let list = [];
    for (let i = 0; i < sensorsManager.sensorList.length; i++) {
      if (!(sensorsManager.sensorList[i] instanceof NullYSensor)) {
        list.push(sensorsManager.sensorList[i]);
      }
    }
    rawDataForm._selection = [];
    for (let i = 0; i < list.length; i++) {
      let spanNode;
      let spanText;
      let input;
      if (i >= rawDataForm._sensorsList.childNodes.length) {
        spanNode = document.createElement("SPAN");
        input = document.createElement("INPUT");
        input.type = "input";
        input.checked = false;
        input.style.display = "inline";
        input.type = "checkbox";
        input.style.transform = "scale(" + constants.generalSizeCoef.toString() + ")";
        input.style.marginRight = Math.round(5 * constants.generalSizeCoef).toString() + "px";
        input.addEventListener("change", () => {
          rawDataForm.refresh();
        });
        spanNode.appendChild(input);
        spanText = document.createElement("SPAN");
        spanNode.appendChild(spanText);
        rawDataForm._sensorsList.appendChild(spanNode);
        spanNode.appendChild(document.createElement("BR"));
      } else {
        spanNode = rawDataForm._sensorsList.childNodes[i];
        input = spanNode.childNodes[0];
        spanText = spanNode.childNodes[1];
      }
      if (input.checked)
        rawDataForm._selection.push(list[i]);
      input.id = list[i].get_hardwareId();
      spanText.innerText = list[i].get_friendlyName();
    }
    while (rawDataForm._sensorsList.childNodes.length > list.length) {
      rawDataForm._sensorsList.removeChild(rawDataForm._sensorsList.lastChild);
    }
    rawDataForm.RefreshContents(rawDataForm._selection);
  }
  static padStart(st, length) {
    while (st.length < length) {
      st = "0" + st;
    }
    return st;
  }
  static UnixTimeStampTostring(ts) {
    let d = new Date(Date.UTC(1970, 0, 1));
    d.setUTCSeconds(ts >> 0, 1e3 * (ts % 1));
    return d.getFullYear().toString() + "-" + rawDataForm.padStart((d.getMonth() + 1).toString(), 2) + "-" + rawDataForm.padStart(d.getDate().toString(), 2) + " " + rawDataForm.padStart(d.getHours().toString(), 2) + ":" + rawDataForm.padStart(d.getMinutes().toString(), 2) + ":" + rawDataForm.padStart((d.getSeconds() + d.getMilliseconds() / 1e3).toFixed(3), 6);
  }
  static RefreshContents(slist) {
    let TH = document.createElement("THEAD");
    let TB = document.createElement("TBODY");
    let HR1 = document.createElement("TR");
    let HR2 = document.createElement("TR");
    let indexes = [];
    for (let i = 0; i < slist.length; i++) {
      indexes.push(slist[i].curData.length - 1);
    }
    while (rawDataForm._dataTable.childNodes.length > 0) {
      rawDataForm._dataTable.removeChild(rawDataForm._dataTable.lastChild);
    }
    rawDataForm._dataTable.appendChild(TH);
    rawDataForm._dataTable.appendChild(TB);
    let sMin = false;
    let sMax = false;
    let sAvg = false;
    let toShow = 0;
    if (rawDataForm._optionMIN.checked) {
      sMin = true;
      toShow++;
    }
    if (rawDataForm._optionAVG.checked) {
      sAvg = true;
      toShow++;
    }
    if (rawDataForm._optionMAX.checked) {
      sMax = true;
      toShow++;
    }
    TH.appendChild(HR1);
    TH.appendChild(HR2);
    let cell = document.createElement("TH");
    HR1.appendChild(cell);
    cell = document.createElement("TH");
    HR2.appendChild(cell);
    for (let i = 0; i < slist.length; i++) {
      cell = document.createElement("TH");
      cell.innerText = slist[i].get_friendlyName();
      cell.colSpan = Math.max(1, toShow);
      cell.style.backgroundColor = "#f0f0f0";
      cell.style.borderLeft = constants.WindowInnerBorder;
      cell.style.borderRight = constants.WindowInnerBorder;
      cell.style.borderTop = constants.WindowInnerBorder;
      HR1.appendChild(cell);
      if (sMin) {
        cell = document.createElement("TH");
        cell.innerText = "Min";
        cell.style.borderLeft = constants.WindowInnerBorder;
        cell.style.borderRight = sAvg || sMax ? "" : constants.WindowInnerBorder;
        cell.style.backgroundColor = "#f0f0f0";
        cell.style.textAlign = "right";
        HR2.appendChild(cell);
      }
      if (sAvg) {
        cell = document.createElement("TH");
        cell.innerText = "Avg";
        cell.style.borderLeft = sMin ? "" : constants.WindowInnerBorder;
        cell.style.borderRight = sMax ? "" : constants.WindowInnerBorder;
        cell.style.backgroundColor = "#f0f0f0";
        cell.style.textAlign = "right";
        HR2.appendChild(cell);
      }
      if (sMax) {
        cell = document.createElement("TH");
        cell.innerText = "Max";
        cell.style.borderLeft = sAvg || sMin ? "" : constants.WindowInnerBorder;
        cell.style.borderRight = constants.WindowInnerBorder;
        cell.style.backgroundColor = "#f0f0f0";
        cell.style.textAlign = "right";
        HR2.appendChild(cell);
      }
    }
    let colcount = slist.length * toShow;
    let MaxTimeStamp = 0;
    for (let i = 0; i < slist.length; i++) {
      if (indexes[i] >= 0) {
        if (MaxTimeStamp < slist[i].curData[indexes[i]].DateTime) {
          MaxTimeStamp = slist[i].curData[indexes[i]].DateTime;
        }
      }
    }
    let rowcount = 0;
    let currentRow = null;
    while (MaxTimeStamp > 0 && rowcount < rawDataForm.MAXRAWDATAROWS) {
      let row = new Array(colcount);
      let nextTimeStamp = 0;
      for (let i = 0; i < slist.length; i++) {
        let Shown = false;
        if (indexes[i] >= 0) {
          if (slist[i].curData[indexes[i]].DateTime == MaxTimeStamp) {
            let n = 0;
            if (sMin) {
              row[n + i * toShow] = slist[i].minData[indexes[i]].value.toString();
              n++;
            }
            if (sAvg) {
              row[n + i * toShow] = slist[i].curData[indexes[i]].value.toString();
              n++;
            }
            if (sMax) {
              row[n + i * toShow] = slist[i].maxData[indexes[i]].value.toString();
              n++;
            }
            Shown = true;
            indexes[i]--;
          }
          if (indexes[i] >= 0) {
            if (slist[i].curData[indexes[i]].DateTime > nextTimeStamp) {
              nextTimeStamp = slist[i].curData[indexes[i]].DateTime;
            }
          }
        }
        if (!Shown) {
          let n = 0;
          if (sMin) {
            row[n + i * toShow] = "";
            n++;
          }
          if (sAvg) {
            row[n + i * toShow] = "";
            n++;
          }
          if (sMax) {
            row[n + i * toShow] = "";
            n++;
          }
        }
      }
      if (colcount > 0 && toShow > 0) {
        currentRow = document.createElement("TR");
        let cell2 = document.createElement("TD");
        cell2.innerText = rawDataForm.UnixTimeStampTostring(MaxTimeStamp).toLocaleString();
        cell2.style.borderLeft = constants.WindowInnerBorder;
        cell2.style.borderTop = rowcount == 0 ? constants.WindowInnerBorder : "";
        cell2.style.backgroundColor = "#f0f0f0";
        currentRow.style.backgroundColor = (rowcount & 1) == 0 ? "white" : "#f0f0f0";
        currentRow.appendChild(cell2);
        for (let j = 0; j < row.length; j++) {
          cell2 = document.createElement("TD");
          cell2.innerText = row[j];
          cell2.style.textAlign = "right";
          cell2.style.borderLeft = j % toShow == 0 ? constants.WindowInnerBorder : "";
          cell2.style.borderRight = (j + 1) % toShow == 0 ? constants.WindowInnerBorder : "";
          cell2.style.fontFamily = "monospace";
          currentRow.appendChild(cell2);
        }
        TB.appendChild(currentRow);
        rowcount++;
      }
      MaxTimeStamp = nextTimeStamp;
    }
    if (currentRow != null) {
      for (let i = 0; i < currentRow.childNodes.length; i++) {
        currentRow.childNodes[i].style.borderBottom = constants.WindowInnerBorder;
      }
    }
    if (toShow == 0) {
      rawDataForm._statusline.style.backgroundColor = "#FF8080";
      rawDataForm._statusline.innerText = "No data shown, select at least Min, Avg or Max options in the top-right checkboxes";
    } else if (rowcount == 0) {
      rawDataForm._statusline.style.backgroundColor = "#FF8080";
      rawDataForm._statusline.innerText = "No data shown, select at least one sensor in the list above.";
    } else {
      rawDataForm._statusline.style.backgroundColor = constants.WindowBackgroundColor;
      if (rowcount < rawDataForm.MAXRAWDATAROWS) {
        rawDataForm._statusline.innerText = "These are the last " + rowcount.toString() + " data rows.";
      } else {
        rawDataForm._statusline.innerText = "These are the last " + rowcount.toString() + " data rows.  Use the export feature to get the whole data set.";
      }
    }
  }
  static getCvsdata(slist, sMin, sAvg, sMax) {
    let toShow = 0;
    let indexes = [];
    for (let i = 0; i < slist.length; i++) {
      indexes.push(0);
    }
    if (sMin)
      toShow++;
    if (sAvg)
      toShow++;
    if (sMax)
      toShow++;
    let res;
    let ColumnHeader = "Timestamp";
    for (let i = 0; i < slist.length; i++) {
      let sName = slist[i].toString();
      if (sMin)
        ColumnHeader += ";" + sName + "(min)";
      if (sAvg)
        ColumnHeader += ";" + sName + "(avg)";
      if (sMax)
        ColumnHeader += ";" + sName + "(max)";
    }
    res = ColumnHeader + "\r\n";
    let colcount = slist.length * toShow;
    let MinTimeStamp = Number.POSITIVE_INFINITY;
    for (let i = 0; i < slist.length; i++) {
      if (indexes[i] < slist[i].curData.length) {
        if (MinTimeStamp > slist[i].curData[indexes[i]].DateTime) {
          MinTimeStamp = slist[i].curData[indexes[i]].DateTime;
        }
      }
    }
    while (MinTimeStamp < Number.POSITIVE_INFINITY) {
      let line = "";
      let nextTimeStamp = Number.POSITIVE_INFINITY;
      for (let i = 0; i < slist.length; i++) {
        let Shown = false;
        if (indexes[i] < slist[i].curData.length) {
          if (slist[i].curData[indexes[i]].DateTime == MinTimeStamp) {
            if (sMin)
              line += ";" + slist[i].minData[indexes[i]].value.toString();
            if (sAvg)
              line += ";" + slist[i].curData[indexes[i]].value.toString();
            if (sMax)
              line += ";" + slist[i].maxData[indexes[i]].value.toString();
            Shown = true;
            indexes[i]++;
          }
          if (indexes[i] < slist[i].curData.length) {
            if (slist[i].curData[indexes[i]].DateTime < nextTimeStamp) {
              nextTimeStamp = slist[i].curData[indexes[i]].DateTime;
            }
          }
        }
        if (!Shown) {
          if (sMin)
            line += " ; ";
          if (sAvg)
            line += " ; ";
          if (sMax)
            line += " ; ";
        }
      }
      if (colcount > 0)
        line = rawDataForm.UnixTimeStampTostring(MinTimeStamp) + line;
      res += line + "\r\n";
      MinTimeStamp = nextTimeStamp;
    }
    return res;
  }
  static export() {
    let element = document.createElement("a");
    let data = "data:text/csv;charset=utf-8," + encodeURI(rawDataForm.getCvsdata(rawDataForm._selection, rawDataForm._optionMIN.checked, rawDataForm._optionAVG.checked, rawDataForm._optionMAX.checked));
    element.setAttribute("href", data);
    element.setAttribute("download", "rawdata.csv");
    element.style.display = "none";
    document.body.appendChild(element);
    element.click();
    document.body.removeChild(element);
  }
};
rawDataForm._lines = [];
rawDataForm.topMargin = 100;
rawDataForm.sensorListWidth = 200;
rawDataForm.MAXRAWDATAROWS = 100;
rawDataForm.STATUSLINEHEIGHT = 20;
rawDataForm._selection = [];

// obj/full/windowManager.js
var button = class {
  constructor(caption, action, sizeCoefOverload) {
    this._enabled = true;
    this._visible = true;
    this._caption = "";
    this._caption = caption;
    this._action = action;
    let GUIcoef = constants.generalSizeCoef;
    if (typeof sizeCoefOverload !== "undefined")
      GUIcoef = sizeCoefOverload;
    this._link = document.createElement("A");
    this._link.innerText = this._caption;
    this._link.style.cursor = "pointer";
    this._link.style.display = "inlineblock";
    let padding = Math.round(5 * GUIcoef).toString() + "px";
    let margin = Math.round(3 * GUIcoef).toString() + "px";
    this._link.tabIndex = 0;
    this._link.style.padding = padding + " " + padding + " " + padding + " " + padding;
    this._link.style.margin = margin + " " + margin + " " + margin + " " + margin;
    this._link.style.borderColor = "#808080";
    this._link.style.backgroundColor = "#f0f0f0";
    this._link.style.fontFamily = constants.generalFontFamily;
    this._link.style.fontSize = (16 * GUIcoef).toString() + "px";
    this._link.style.cursor = "pointer";
    this._link.style.border = constants.WindowInnerBorder;
    this._link.addEventListener("mouseover", () => {
      if (this._enabled)
        this._link.style.backgroundColor = "white";
    });
    this._link.addEventListener("mouseout", () => {
      if (this._enabled)
        this._link.style.backgroundColor = "#f0f0f0";
    });
    this._link.addEventListener("click", () => {
      if (this._enabled)
        this._action(this);
    });
    this._link.addEventListener("keypress", (e) => {
      if (this._enabled && (e.key == "Enter" || e.key == " "))
        this._action(this);
    });
  }
  get Element() {
    return this._link;
  }
  set tabIndex(index) {
    this._link.tabIndex = index;
  }
  focus() {
    this._link.focus();
  }
  get visible() {
    return this._visible;
  }
  set visible(value) {
    this._visible = value;
    this._link.style.display = this._visible ? "" : "none";
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    this.enable(value);
  }
  performAction() {
    if (!this._enabled)
      return;
    this._action(this);
  }
  showShortcut(enable) {
    if (!this._enabled)
      enable = false;
    if (enable) {
      this._link.innerHTML = "<u>" + this._caption.substring(0, 1) + "</u>" + this._caption.substring(1);
    } else {
      this._link.innerText = this._caption;
    }
  }
  enable(state) {
    if (state == this._enabled)
      return;
    this._enabled = state;
    this._link.tabIndex = state ? 0 : -1;
    if (this._enabled) {
      this._link.style.cursor = "pointer";
      this._link.style.backgroundColor = "#f0f0f0";
      this._link.style.color = "black";
    } else {
      this._link.style.backgroundColor = "#e0e0e0";
      this._link.style.cursor = "default";
      this._link.style.color = "#A0A0A0";
    }
  }
};
var newWindowParam = class {
  get GUICoef() {
    return this._GUICoef;
  }
  constructor(sizeCoefOverload) {
    this.createNow = false;
    this.left = 100;
    this.top = 100;
    this.positionType = 0;
    this.width = 400;
    this.height = 300;
    this.isModal = false;
    this.showShadow = true;
    this.showContainerBorders = true;
    this.showHeader = true;
    this.title = "new Window";
    this.closeIcon = true;
    this.headerBgColor = "";
    this.bottomKeepClear = 0;
    this.contentsDefaultFontSize = constants.generalFontSize;
    this.contentsDefaultFontFamily = constants.generalFontFamily;
    this.closingCallBack = null;
    this.WindowBackgroundColor = "#f0f0f0";
    this.WindowBorder = "1px solid #808080";
    this.WindowPadding = 2;
    this.WindowInnerBorderColor = " #A0A0A0";
    this.WindowInnerBackgroundColor = "#fAfAfA";
    this.WindowInnerBorder = "1px solid " + this.WindowInnerBorderColor;
    this.WindowHeaderBackgroundColor = "#0072ca";
    this.WindowHeaderColor = "white";
    this.WindowHeaderBorder = "1px solid #0072ca";
    this._GUICoef = constants.generalSizeCoef;
    this.WindowHeaderHeight = Math.round(20 * constants.generalSizeCoef);
    this.WindowHeaderFontSize = 16 * constants.generalSizeCoef;
    this.WindowHeaderFontFamily = constants.generalFontFamily;
    this.buttons = [];
    if (typeof sizeCoefOverload !== "undefined") {
      this.WindowHeaderHeight = 20 * sizeCoefOverload;
      this.WindowHeaderFontSize = 16 * sizeCoefOverload;
      this._GUICoef = sizeCoefOverload;
    }
  }
  clone() {
    let it = new newWindowParam();
    let keys = Object.keys(this);
    for (let i = 0; i < keys.length; i++) {
      if (keys[i] != "buttons")
        it[keys[i]] = this[keys[i]];
    }
    for (let i = 0; i < this.buttons.length; i++) {
      it.buttons.push(this.buttons[i]);
    }
    return it;
  }
};
var YWindow = class {
  static get ConTextMenuBestZindex() {
    for (let i = 0; i < YWindow.windowList.length; i++) {
      if (YWindow.windowList[i].isModal())
        return -1;
    }
    return 1e5 + 2 * YWindow.windowList.length;
  }
  constructor(params) {
    this._div = null;
    this._titleSpan = null;
    this._ModalDivShield = null;
    this._switchSideDiv = null;
    this._buttonsContainer = null;
    this._params = params.clone();
    YWindow.windowList.push(this);
    this._contents = document.createElement("DIV");
    if (params.createNow)
      this.allocate();
  }
  get innerContentDiv() {
    return this._contents;
  }
  get bottomKeepClear() {
    return this._params.bottomKeepClear;
  }
  set bottomKeepClear(value) {
    this._params.bottomKeepClear = value;
    if (this._contents != null) {
      this._contents.style.bottom = (this._params.WindowPadding + this._params.bottomKeepClear).toString() + "px";
    }
  }
  get outterContentDiv() {
    return this._div;
  }
  isModal() {
    if (this._div == null)
      return false;
    return this._div.style.display == "" && this._params.isModal;
  }
  get visible() {
    if (this._div == null)
      return false;
    return this._div.style.display == "";
  }
  set visible(v) {
    v ? this.show() : this.hide();
  }
  show(width) {
    if (this._div == null)
      this.allocate();
    this._div.style.display = "";
    if (this._ModalDivShield != null)
      this._ModalDivShield.style.display = "";
    this.brintToFront();
    if (typeof width !== "undefined" && this._params.positionType == 2) {
      this._div.style.width = width.toString() + "px";
    }
  }
  allocate() {
    if (this._div != null)
      return;
    if (this._params.isModal) {
      this._ModalDivShield = document.createElement("DIV");
      this._ModalDivShield.style.position = "fixed";
      this._ModalDivShield.style.left = "0px";
      this._ModalDivShield.style.top = "0px";
      this._ModalDivShield.style.right = "0px";
      this._ModalDivShield.style.bottom = "0px";
      this._ModalDivShield.style.backgroundColor = "rgba(255,255,255,0.85) ";
      document.body.appendChild(this._ModalDivShield);
    }
    this._div = document.createElement("DIV");
    this._div.style.display = "none";
    switch (this._params.positionType) {
      case 0:
        this._div.style.position = "absolute";
        this._div.style.left = this._params.left.toString() + "px";
        this._div.style.top = this._params.top.toString() + "px";
        this._div.style.width = this._params.width.toString() + "px";
        this._div.style.height = this._params.height.toString() + "px";
        break;
      case 1:
        this._div.style.position = "absolute";
        this._div.style.left = "50%";
        this._div.style.top = "50%";
        this._div.style.transform = "translate(-50%, -50%)";
        this._div.style.width = this._params.width.toString() + "px";
        this._div.style.height = this._params.height.toString() + "px";
        break;
      case 2:
        this._div.style.position = "fixed";
        this._div.style.top = "5px";
        this._div.style.right = "5px";
        this._div.style.bottom = "5px";
        this._div.style.width = this._params.width.toString() + "px";
        break;
    }
    this._div.style.border = this._params.WindowBorder;
    this._div.style.backgroundColor = this._params.WindowBackgroundColor;
    if (this._params.showShadow)
      this._div.style.boxShadow = " 4px 4px 4px 1px rgba(0,0,0,0.05)";
    let containerTop = this._params.WindowPadding;
    if (this._params.showHeader) {
      containerTop = this._params.WindowHeaderHeight + 3 * this._params.WindowPadding;
      let title = document.createElement("DIV");
      title.style.position = "absolute";
      title.style.left = this._params.WindowPadding.toString() + "px";
      title.style.top = this._params.WindowPadding.toString() + "px";
      title.style.right = this._params.WindowPadding.toString() + "px";
      title.style.height = this._params.WindowHeaderHeight.toString() + "px";
      title.style.border = this._params.WindowHeaderBorder;
      title.style.backgroundColor = this._params.WindowHeaderBackgroundColor;
      title.style.fontFamily = this._params.WindowHeaderFontFamily;
      title.style.color = this._params.WindowHeaderColor;
      title.style.fontSize = this._params.WindowHeaderFontSize.toString() + "px";
      title.style.paddingLeft = "5px";
      title.style.whiteSpace = "nowrap";
      title.addEventListener("click", () => {
        this.brintToFront();
      });
      this._titleSpan = document.createElement("SPAN");
      this._titleSpan.innerText = this._params.title;
      title.appendChild(this._titleSpan);
      if (this._params.closeIcon) {
        let closeDiv = document.createElement("DIV");
        closeDiv.style.position = "absolute";
        closeDiv.style.right = "0px";
        closeDiv.style.top = "0px";
        closeDiv.style.width = Math.round(this._params.WindowHeaderHeight + 5).toString() + "px";
        closeDiv.style.height = this._params.WindowHeaderHeight.toString() + "px";
        closeDiv.style.overflow = "hide";
        closeDiv.style.paddingLeft = "5px";
        closeDiv.tabIndex = 0;
        closeDiv.style.cursor = "pointer";
        closeDiv.style.backgroundColor = this._params.WindowHeaderBackgroundColor;
        closeDiv.innerHTML = ressources.CloseIcon(this._params.WindowHeaderHeight.toString(), false, false, false, false, "Click to close this window");
        closeDiv.addEventListener("click", () => {
          this.hide();
        });
        closeDiv.addEventListener("keypress", (e) => {
          if (e.key == "Enter")
            this.hide();
        });
        title.appendChild(closeDiv);
      }
      if (this._params.positionType == 2) {
        this._switchSideDiv = document.createElement("DIV");
        this._switchSideDiv.style.position = "absolute";
        this._switchSideDiv.style.width = Math.round(this._params.WindowHeaderHeight + 5).toString() + "px";
        this._switchSideDiv.style.right = Math.round(this._params.WindowHeaderHeight + 5) + "px";
        this._switchSideDiv.style.height = this._params.WindowHeaderHeight.toString() + "px";
        this._switchSideDiv.style.overflow = "hide";
        this._switchSideDiv.style.paddingLeft = "5px";
        this._switchSideDiv.style.top = "0px";
        this._switchSideDiv.style.cursor = "pointer";
        this._switchSideDiv.style.backgroundColor = this._params.WindowHeaderBackgroundColor;
        this._switchSideDiv.innerHTML = ressources.MoveToLeftIcon(this._params.WindowHeaderHeight.toString(), false, false, false, false, "Click to move editor on left side");
        this._switchSideDiv.addEventListener("click", () => {
          this.switchSide();
        });
        title.appendChild(this._switchSideDiv);
      }
      this._div.appendChild(title);
    }
    if (this._params.buttons.length > 0) {
      this._buttonsContainer = document.createElement("DIV");
      this._buttonsContainer.style.position = "absolute";
      this._buttonsContainer.style.bottom = Math.round(this._params.WindowPadding).toString() + "px";
      this._buttonsContainer.style.right = Math.round(this._params.WindowPadding).toString() + "px";
      this._buttonsContainer.style.textAlign = "right";
      for (let i = 0; i < this._params.buttons.length; i++) {
        this._buttonsContainer.appendChild(this._params.buttons[i].Element);
      }
      this._div.appendChild(this._buttonsContainer);
      this._buttonsContainer.style.height = (25 * this._params.GUICoef).toString() + "px";
      this._params.bottomKeepClear += Math.round(35 * this._params.GUICoef);
    }
    this._contents.style.position = "absolute";
    this._contents.style.left = this._params.WindowPadding.toString() + "px";
    this._contents.style.right = this._params.WindowPadding.toString() + "px";
    this._contents.style.top = containerTop.toString() + "px";
    this._contents.style.bottom = (this._params.WindowPadding + this._params.bottomKeepClear).toString() + "px";
    this._contents.style.paddingLeft = "5px";
    this._contents.style.paddingRight = "5px";
    if (this._contents.style.fontSize == "") {
      this._contents.style.fontSize = this._params.contentsDefaultFontSize.toString() + "px";
    }
    if (this._contents.style.fontFamily == "") {
      this._contents.style.fontFamily = this._params.contentsDefaultFontFamily;
    }
    if (this._params.showContainerBorders) {
      this._contents.style.border = this._params.WindowInnerBorder;
      this._contents.style.backgroundColor = this._params.WindowInnerBackgroundColor;
    } else {
      this._contents.style.border = "1px solid rgba(0, 0, 0, 0)";
      this._contents.style.backgroundColor = "";
    }
    this._contents.style.overflow = "hide";
    this._div.append(this._contents);
    document.body.appendChild(this._div);
  }
  hide() {
    if (this._div == null)
      return;
    this._div.style.display = "none";
    if (this._ModalDivShield != null)
      this._ModalDivShield.style.display = "none";
    if (this._params.closingCallBack != null)
      this._params.closingCallBack(this);
  }
  set title(value) {
    this._params.title = value;
    if (this._titleSpan != null) {
      this._titleSpan.innerText = value;
    }
  }
  brintToFront() {
    let n = -1;
    for (let i = 0; i < YWindow.windowList.length; i++) {
      if (YWindow.windowList[i] == this)
        n = i;
    }
    if (n < 0)
      return;
    YWindow.windowList.splice(n, 1);
    YWindow.windowList.push(this);
    for (let i = 0; i < YWindow.windowList.length; i++) {
      YWindow.windowList[i].zIndex = i;
    }
  }
  set zIndex(index) {
    if (this._div == null)
      return;
    this._div.style.zIndex = (100001 + 2 * index).toString();
    if (this._params.isModal)
      this._ModalDivShield.style.zIndex = (1e5 + 2 * index).toString();
  }
  switchSide() {
    if (this._div.style.left == "") {
      this._div.style.left = "5px";
      this._div.style.right = "";
      this._switchSideDiv.innerHTML = ressources.MoveToRightIcon(Math.round(20 * this._params.GUICoef).toString(), false, false, false, false, "Click to move editor on right side");
    } else {
      this._div.style.left = "";
      this._div.style.right = "5px";
      this._switchSideDiv.innerHTML = ressources.MoveToLeftIcon(Math.round(20 * this._params.GUICoef).toString(), false, false, false, false, "Click to move editor on left side");
    }
  }
};
YWindow.windowList = [];
var confirm = class {
  static ask(message, yes, no, userdata) {
    let params = new newWindowParam();
    params.positionType = 1;
    params.width = Math.min(Math.round(400 * constants.generalSizeCoef), Math.round(screen.width * 0.9));
    params.height = Math.min(Math.round(160 * constants.generalSizeCoef), Math.round(screen.height * 0.7));
    params.isModal = true;
    params.showHeader = false;
    params.showContainerBorders = false;
    let YesButton = new button("Yes", () => {
      confirm._window.hide();
      if (yes != null)
        yes(userdata);
    });
    let NoButton = new button("No", () => {
      confirm._window.hide();
      if (no != null)
        no(userdata);
    });
    params.buttons.push(YesButton);
    params.buttons.push(NoButton);
    confirm._window = new YWindow(params);
    let contents = confirm._window.innerContentDiv;
    let table = document.createElement("TABLE");
    table.style.width = "100%";
    let TR = document.createElement("TR");
    let TD = document.createElement("TD");
    TD.style.width = "10";
    TD.innerHTML = ressources.DontKnowIcon(Math.round(80 * constants.generalSizeCoef).toString(), true, false, false, false, "");
    TR.appendChild(TD);
    TD = document.createElement("TD");
    TD.style.paddingLeft = "20px";
    TD.style.fontFamily = constants.generalFontFamily;
    TD.style.fontSize = constants.generalFontSize.toString() + "px";
    TD.style.textAlign = "justify";
    TD.innerText = message;
    TR.appendChild(TD);
    table.appendChild(TR);
    contents.appendChild(table);
    confirm._window.show();
    return confirm._window;
  }
};
var notififaction = class {
  static show(icon, message) {
    let params = new newWindowParam();
    params.positionType = 1;
    params.width = Math.min(Math.round(400 * constants.generalSizeCoef), screen.width);
    params.height = Math.min(Math.round(160 * constants.generalSizeCoef), screen.height);
    params.isModal = true;
    params.showHeader = false;
    params.showContainerBorders = false;
    let okButton = new button("OK", () => {
      alert2._window.hide();
    });
    params.buttons.push(okButton);
    alert2._window = new YWindow(params);
    let contents = alert2._window.innerContentDiv;
    let table = document.createElement("TABLE");
    table.style.width = "100%";
    let TR = document.createElement("TR");
    let TD = document.createElement("TD");
    TD.style.width = "10";
    TD.innerHTML = icon;
    TR.appendChild(TD);
    TD = document.createElement("TD");
    TD.style.paddingLeft = "20px";
    TD.style.fontFamily = constants.generalFontFamily;
    TD.style.fontSize = constants.generalFontSize.toString() + "px";
    TD.style.textAlign = "justify";
    TD.innerText = message;
    TR.appendChild(TD);
    table.appendChild(TR);
    contents.appendChild(table);
    alert2._window.show();
    return alert2._window;
  }
};
var alert2 = class extends notififaction {
  static show(message) {
    return super.show(ressources.FailedIcon(Math.round(80 * constants.generalSizeCoef).toString(), true, false, false, false, ""), message);
  }
};

// obj/full/mainForm_rw.js
var mainForm = class {
  constructor() {
    this.GUIcoef = 1;
    let params = new newWindowParam();
    params.positionType = 1;
    this.GUIcoef = constants.generalSizeCoef;
    if (mainForm.REFWIDH * this.GUIcoef > screen.width)
      this.GUIcoef = screen.width / mainForm.REFWIDH;
    if (mainForm.REFHEIGHT * this.GUIcoef > screen.height)
      this.GUIcoef = screen.height / mainForm.REFHEIGHT;
    params.width = Math.round(mainForm.REFWIDH * this.GUIcoef);
    params.height = Math.round(mainForm.REFHEIGHT * this.GUIcoef);
    params.showHeader = false;
    params.showContainerBorders = false;
    this._window = new YWindow(params);
    let contents = this._window.innerContentDiv;
    let title = document.createElement("p");
    title.style.paddingTop = "0px";
    title.style.marginTop = 4 * this.GUIcoef + "px";
    title.style.fontSize = 16 * this.GUIcoef + "px";
    title.innerText = "Hello, welcome to Yocto-Visualization, what would you like to do?";
    title.style.textAlign = "center";
    contents.appendChild(title);
    let table = document.createElement("TABLE");
    table.style.position = "absolute";
    table.style.top = "0px";
    table.style.fontFamily = constants.generalFontFamily;
    table.style.tableLayout = "fixed";
    table.style.paddingLeft = Math.round(10 * this.GUIcoef).toString() + "px";
    table.style.paddingRight = Math.round(10 * this.GUIcoef).toString() + "px";
    table.style.paddingTop = Math.round(30 * this.GUIcoef).toString() + "px";
    table.style.paddingBottom = Math.round(15 * this.GUIcoef).toString() + "px";
    table.style.width = "100%";
    table.style.height = "100%";
    table.style.borderSpacing = Math.round(5 * this.GUIcoef).toString() + "px";
    let tr1 = document.createElement("TR");
    table.appendChild(tr1);
    let td11 = document.createElement("TD");
    tr1.appendChild(td11);
    let td12 = document.createElement("TD");
    tr1.appendChild(td12);
    let td13 = document.createElement("TD");
    tr1.appendChild(td13);
    let tr2 = document.createElement("TR");
    table.appendChild(tr2);
    let td21 = document.createElement("TD");
    tr2.appendChild(td21);
    let td22 = document.createElement("TD");
    tr2.appendChild(td22);
    let td23 = document.createElement("TD");
    tr2.appendChild(td23);
    contents.appendChild(table);
    let version = document.createElement("p");
    version.style.position = "absolute";
    version.style.right = "0px";
    version.style.bottom = "0px";
    version.style.marginBottom = "0px";
    version.style.paddingBottom = "0px";
    version.style.marginRight = "2px";
    version.style.fontSize = (8 * this.GUIcoef).toString() + "px";
    version.innerText = constants.buildVersion;
    version.style.color = "grey";
    version.style.textAlign = "right";
    contents.appendChild(version);
    let size = (128 * this.GUIcoef).toString();
    this.createButton(td11, "Configure global parameters", ressources.ConfigureIcon(size, true, false, false, false), () => {
      this.openConfig();
    });
    this.createButton(td12, "Create a new solid gauge", ressources.SolidGaugeIcon(size, true, false, false, false), () => {
      YWebPage.newGaugeWidget();
    });
    this.createButton(td13, "Create a new graph", ressources.GraphIcon(size, true, false, false, false), () => {
      YWebPage.newGraphWidget();
    });
    this.createButton(td21, "Get Raw data", ressources.RawDataIcon(size, true, false, false, false), () => {
      this.openRawData();
    });
    this.createButton(td22, "Create a new digital display", ressources.DigitalDisplayIcon(size, true, false, false, false), () => {
      YWebPage.newDigitalDisplayWidget();
    });
    this.createButton(td23, "Create a new angular gauge", ressources.AngularGaugeIcon(size, true, false, false, false), () => {
      YWebPage.newAngularGaugeWidget();
    });
  }
  hide() {
    this._window.hide();
  }
  show() {
    this._window.show();
  }
  createButton(container, caption, icon, callback) {
    container.style.border = "1px solid black";
    container.style.textAlign = "center";
    container.style.fontSize = (10 * this.GUIcoef).toString() + "px";
    container.style.paddingBottom = "3px";
    container.style.borderColor = "#808080";
    container.style.backgroundColor = "#f0f0f0";
    container.style.cursor = "pointer";
    container.addEventListener("mouseover", function() {
      container.style.backgroundColor = "white";
    });
    container.addEventListener("mouseout", function() {
      container.style.backgroundColor = "#f0f0f0";
    });
    let a = document.createElement("a");
    a.style.outline = "none";
    a.innerHTML = icon + "<br>" + caption;
    a.addEventListener("click", callback);
    a.tabIndex = 0;
    a.addEventListener("focusin", () => {
      container.style.backgroundColor = "white";
    });
    a.addEventListener("focusout", () => {
      container.style.backgroundColor = "f0f0f0";
    });
    a.addEventListener("keypress", (e) => {
      if (e.key == "Enter")
        callback();
    });
    container.appendChild(a);
  }
  openConfig() {
    configForm.show();
  }
  openRawData() {
    rawDataForm.show();
  }
};
mainForm.REFWIDH = 500;
mainForm.REFHEIGHT = 360;

// obj/full/Editor_rw.js
var EditedDataSource = class {
  constructor(source, root) {
    this._htmlchilds = [];
    this._source = source;
    this._root = root;
    this._htmlchilds = [];
  }
  storeChilds(childsList) {
    this._htmlchilds = [];
    for (let i = 0; i < childsList.length; i++) {
      this._htmlchilds.push(childsList.item(i));
    }
  }
  getStoredChilds() {
    return this._htmlchilds;
  }
  get root() {
    return this._root;
  }
  refresh() {
    if (this._root != null)
      this._root.refresh();
  }
};
var keyDataObject = class {
  constructor(key, data) {
    this.key = key;
    this.data = data;
  }
};
var objectDictionnary = class {
  constructor() {
    this.list = [];
  }
  isInlist(key) {
    for (let i = 0; i < this.list.length; i++) {
      if (key == this.list[i].key)
        return true;
    }
    return false;
  }
  find(key) {
    for (let i = 0; i < this.list.length; i++) {
      if (key == this.list[i].key)
        return this.list[i].data;
    }
    return null;
  }
  insert(key, data) {
    for (let i = 0; i < this.list.length; i++) {
      if (key == this.list[i].key) {
        this.list[i].data = data;
        return;
      }
    }
    this.list.push(new keyDataObject(key, data));
  }
};
var EditorBaseDef = class {
  refresh() {
  }
  get panel() {
    return null;
  }
  get expanded() {
    return true;
  }
  AllocateControls() {
  }
};
var PropertiesForm2 = class extends EditorBaseDef {
  get visible() {
    return this._window.visible;
  }
  set visible(v) {
    v ? this.show() : this.hide();
  }
  get text() {
    return this._text;
  }
  set text(value) {
    this._text = value;
    this._window.title = this._text;
  }
  get help() {
    return this._helpText;
  }
  set help(value) {
    this._helpText = value;
    this._helpPanel.innerHTML = this._helpText;
  }
  addTest(parentDiv) {
    PropertiesForm2.testid++;
    let mainlabel = document.createElement("DIV");
    mainlabel.style.position = "relative";
    mainlabel.style.display = "inline-block;";
    mainlabel.style.left = "0px";
    mainlabel.style.padding = "2px 2px 2px 2px";
    mainlabel.style.right = "5px";
    mainlabel.style.border = "1px solid black";
    mainlabel.style.marginTop = "2px";
    mainlabel.style.backgroundColor = "yellow";
    if (parentDiv != null) {
      parentDiv.appendChild(mainlabel);
    } else {
      this._container.appendChild(mainlabel);
    }
    let expandCtrl = document.createElement("ANCHOR");
    expandCtrl.innerText = "[+]";
    mainlabel.appendChild(expandCtrl);
    let mainText = document.createElement("SPAN");
    mainText.innerText = "Pouet " + PropertiesForm2.testid.toString();
    mainlabel.appendChild(mainText);
    let subElementPanel = document.createElement("DIV");
    subElementPanel.style.position = "relative";
    subElementPanel.style.display = "inline-block;";
    subElementPanel.style.left = "5px";
    subElementPanel.style.padding = "2px 2px 2px 2px";
    subElementPanel.style.right = "5px";
    subElementPanel.style.marginTop = "2px";
    subElementPanel.style.backgroundColor = "lightgray";
    subElementPanel.innerText = "sub elements";
    if (parentDiv != null) {
      parentDiv.appendChild(subElementPanel);
    } else {
      this._container.appendChild(subElementPanel);
    }
    return subElementPanel;
  }
  editorIsClosing(source) {
    if (this._editorClosedCallback != null)
      this._editorClosedCallback();
  }
  bestWidth() {
    let w = window.innerWidth / 4 >> 0;
    let minWidth = 275 * constants.guiDPIFactor;
    if (w < minWidth)
      w = minWidth;
    if (w > window.innerWidth - 10)
      w = window.innerWidth - 10;
    return w;
  }
  constructor() {
    super();
    this._hostWindow = null;
    this._editorClosedCallback = null;
    this.currentEditedDataSource = null;
    this._changeCallback = null;
    this._getvalueCallback = null;
    this._text = "Properties editor";
    this._helpText = "Properties editor";
    this.EditedDataSourceList = new objectDictionnary();
    let params = new newWindowParam();
    params.positionType = 2;
    params.width = this.bestWidth();
    params.createNow = true;
    params.closingCallBack = (source) => {
      this.editorIsClosing(source);
    };
    params.bottomKeepClear = PropertiesForm2.HelpHeight + 3 * constants.WindowPadding;
    params.title = this._text;
    this._window = new YWindow(params);
    this._container = this._window.innerContentDiv;
    this._helpPanel = document.createElement("DIV");
    this._helpPanel.style.position = "absolute";
    this._helpPanel.style.left = constants.WindowPadding.toString() + "px";
    this._helpPanel.style.bottom = constants.WindowPadding.toString() + "px";
    this._helpPanel.style.right = constants.WindowPadding.toString() + "px";
    this._helpPanel.style.height = PropertiesForm2.HelpHeight.toString() + "px";
    this._helpPanel.style.paddingLeft = "5px";
    this._helpPanel.style.paddingTop = "5px";
    this._helpPanel.style.overflowY = "auto";
    this._helpPanel.style.border = constants.WindowInnerBorder;
    this._helpPanel.style.backgroundColor = constants.WindowInnerBackgroundColor;
    this._helpPanel.style.fontFamily = constants.generalFontFamily;
    this._helpPanel.style.fontSize = constants.generalFontSize.toString() + "px";
    this._helpPanel.style.color = "black";
    this._helpPanel.style.display = "";
    this._helpPanel.innerHTML = "Help panel. Editor is loading, please wait....";
    this._window.outterContentDiv.appendChild(this._helpPanel);
    this._container.style.overflowY = "scroll";
    this._container.style.overflowX = "hidden";
    this._container.style.backgroundColor = constants.WindowInnerBackgroundColor;
    window.addEventListener("resize", () => {
      this.windowResized();
    });
  }
  windowResized() {
    if (this._window.innerContentDiv == null)
      return;
    if (this._window.innerContentDiv.offsetHeight < PropertiesForm2.MinHeightforShowingHelp && this._helpPanel.style.display == "") {
      this._helpPanel.style.display = "none";
      this._window.bottomKeepClear = 0;
    } else if (this._window.innerContentDiv.offsetHeight >= PropertiesForm2.MinHeightforShowingHelp + PropertiesForm2.HelpHeight && this._helpPanel.style.display != "") {
      this._helpPanel.style.display = "";
      this._window.bottomKeepClear = PropertiesForm2.HelpHeight;
    }
  }
  show() {
    this._window.show(this.bestWidth());
    this.windowResized();
  }
  hide() {
    YWidget.stopEdition();
    this._window.hide();
  }
  get panel() {
    return this._container;
  }
  refresh() {
    if (!this.visible)
      return;
    if (this.currentEditedDataSource == null)
      return;
    this.currentEditedDataSource.refresh();
  }
  refreshBanner() {
    if (this._hostWindow != null) {
      this.text = "Properties of " + this._hostWindow.Text;
    }
  }
  showWindow(hostWindow, structData, setvalueCallBack, getvalueCallBack, EditStoppedCallBack) {
    this._hostWindow = hostWindow;
    this._changeCallback = setvalueCallBack;
    this._getvalueCallback = getvalueCallBack;
    this.text = "Properties editor";
    this.show();
    this.refreshBanner();
    this.EditObject(structData, setvalueCallBack, getvalueCallBack, EditStoppedCallBack);
  }
  EditObject(structData, setvalueCallBack, getvalueCallBack, EditStoppedCallBack) {
    this._editorClosedCallback = EditStoppedCallBack;
    let helpYourselfMsg = "This is the property editor. Change any parameter you want. All changes are applied in real time.";
    if (!this.visible)
      return;
    this.help = "Please wait....";
    if (this.EditedDataSourceList.isInlist(structData)) {
      if (this.EditedDataSourceList.find(structData) == this.currentEditedDataSource) {
        this.help = helpYourselfMsg;
        return;
      }
    }
    if (this.currentEditedDataSource != null) {
      this.currentEditedDataSource.root.stopEdit();
      this.currentEditedDataSource.storeChilds(this._container.childNodes);
      while (this._container.firstChild) {
        this._container.removeChild(this._container.lastChild);
      }
    }
    let it;
    if (!this.EditedDataSourceList.isInlist(structData)) {
      let rootparam = new UIElementBaseParams(this._helpPanel, this, null, "root", "Root", "root node", "");
      it = new UIElement(rootparam);
      it.rootEditor = this;
      this.currentEditedDataSource = new EditedDataSource(structData, it);
      this.EditedDataSourceList.insert(structData, this.currentEditedDataSource);
      it.showLabel = false;
      it.expandable = true;
      it.ProcessNewType(structData);
      it.expanded = true;
    } else {
      this.currentEditedDataSource = this.EditedDataSourceList.find(structData);
      let childNodes = this.currentEditedDataSource.getStoredChilds();
      for (let i = 0; i < childNodes.length; i++) {
        this._container.appendChild(childNodes[i]);
      }
      this.currentEditedDataSource.refresh();
    }
    this.currentEditedDataSource.root.startEdit(setvalueCallBack, getvalueCallBack);
    this.currentEditedDataSource.root.resizeAll();
    this.help = helpYourselfMsg;
  }
  getConfigData() {
    let p = this._window.outterContentDiv.getBoundingClientRect();
    return "<PropertiesForm>\n<location x='" + p.left.toString() + "' y='" + p.top.toString() + "'/>\n<size     w='" + p.width.toString() + "' h='" + p.width.toString() + "'/>\n</PropertiesForm>\n";
  }
  Form1_SizeChanged(sender) {
    if (this.currentEditedDataSource == null)
      return;
    if (this.currentEditedDataSource.root != null)
      this.currentEditedDataSource.root.resizeAll();
  }
  valuechange(src) {
    let OriginalPropName = "";
    let fullpropname = "";
    let propType = "";
    if (this._changeCallback != null)
      this._changeCallback(src);
  }
};
PropertiesForm2.HelpHeight = Math.round(75 * constants.generalSizeCoef);
PropertiesForm2.MinHeightforShowingHelp = 175;
PropertiesForm2.testid = 0;

// obj/full/UIElements_rw.js
var UIElementBaseParams = class {
  constructor(p_descriptionLabel, p_parentNode, p_RootNode, p_internalname, p_label, p_description, p_isReadonlyCall) {
    this.expandable = false;
    this.isReadonlyCall = "";
    this.summary = null;
    this.structRoot = null;
    this.HelpZoneLabel = p_descriptionLabel;
    this.parentNode = p_parentNode;
    this.RootNode = p_RootNode;
    this.internalname = p_internalname;
    this.label = p_label;
    this.description = p_description;
    this.changeCausesParentRefresh = false;
    this.preExpanded = false;
    this.isReadonlyCall = p_isReadonlyCall;
  }
};
var PropPathinfo = class {
  constructor() {
    this.OriginalPropName = "";
    this.fullpropname = "";
    this.propType = "";
  }
};
var CustomAttributesExtractor = class {
  constructor(ps) {
    this.available = true;
    this.displayName = "unknown";
    this.category = "";
    this.displayDescription = "Not documented";
    this.prefinedValues = null;
    this.changeCausesParentRefresh = false;
    this.PreExpandedCategory = false;
    this.PreExpanded = false;
    this.summaryPropertyName = "";
    this.isReadOnlyCall = "";
    this.NotSavedInXML = false;
    this.ReadOnly = false;
    this.ParamCategorySummary = "";
    if ("OnlyAvailableon" in ps.Attributes)
      this.available = ps.Attributes["OnlyAvailableon"];
    if ("DisplayName" in ps.Attributes)
      this.displayName = ps.Attributes["DisplayName"];
    if ("CategoryAttribute" in ps.Attributes)
      this.category = ps.Attributes["CategoryAttribute"];
    if ("DescriptionAttribute" in ps.Attributes)
      this.displayDescription = ps.Attributes["DescriptionAttribute"];
    if ("AllowedValues" in ps.Attributes)
      this.prefinedValues = ps.Attributes["AllowedValues"];
    if ("ChangeCausesParentRefreshAttribute" in ps.Attributes)
      this.changeCausesParentRefresh = ps.Attributes["ChangeCausesParentRefreshAttribute"];
    if ("PreExpandedCategoryAttribute" in ps.Attributes)
      this.PreExpandedCategory = ps.Attributes["PreExpandedCategoryAttribute"];
    if ("PreExpandedAttribute" in ps.Attributes)
      this.PreExpanded = ps.Attributes["PreExpandedAttribute"];
    if ("ParamCategorySummaryAttribute" in ps.Attributes)
      this.summaryPropertyName = ps.Attributes["ParamCategorySummaryAttribute"];
    if ("IsReadonlyCallAttribute" in ps.Attributes)
      this.isReadOnlyCall = ps.Attributes["IsReadonlyCallAttribute"];
    if ("NotSavedInXMLAttribute" in ps.Attributes)
      this.NotSavedInXML = ps.Attributes["NotSavedInXMLAttribute"];
    if ("ReadOnlyAttribute " in ps.Attributes)
      this.ReadOnly = ps.Attributes["ReadOnlyAttribute "];
    if ("ParamCategorySummaryAttribute " in ps.Attributes)
      this.ParamCategorySummary = ps.Attributes["ParamCategorySummaryAttribute "];
  }
};
var UIElement = class extends EditorBaseDef {
  get parentNode() {
    return this._parentNode;
  }
  get targetFullName() {
    return this._targetFullName;
  }
  get expandIcon() {
    return ressources.ExpandIcon(UIElement.defaultFontSize.toString(), false, false, false, false, "Click to expand");
  }
  get colapseIcon() {
    return ressources.ColapseIcon(UIElement.defaultFontSize.toString(), false, false, false, false, "Click to colapse");
  }
  removeFromEditor() {
  }
  get panel() {
    return this.subElementPanel;
  }
  get editorHelpText() {
    return "";
  }
  get isRootElement() {
    return this._rootNode == this;
  }
  addToEditor() {
    if (this.mainlabel != null) {
      for (let i = 0; i < this._parentPanel.children.length; i++) {
        if (this._parentPanel.children[i] == this.mainlabel)
          return;
      }
      this._parentPanel.appendChild(this.mainlabel);
      this._parentPanel.appendChild(this.subElementPanel);
    }
  }
  refresh() {
    if (this.mainText != null)
      this.mainText.innerText = this.name + this.getSummary();
    for (let i = 0; i < this.subElements.length; i++) {
      this.subElements[i].refresh();
    }
    if (this._rootNode != null && this._rootNode.rootEditor != null)
      this._rootNode.rootEditor.refreshBanner();
  }
  tabReOrder(index) {
    if (this._expandable && this.expandCtrl != null)
      this.expandCtrl.tabIndex = index++;
    this.subElements.forEach((e) => {
      index = e.tabReOrder(index);
    });
    return index;
  }
  triggerValueChangeCallback() {
    if (this._valueChangeCallback != null)
      this._valueChangeCallback(this);
  }
  scrollToMakeVisible() {
    if (this.mainlabel == null)
      return;
    if (this._parentPanel == null)
      return;
    this.mainlabel.scrollIntoView();
  }
  control_GotFocus(sender) {
    let extraHelp = this.editorHelpText;
    if (extraHelp != "")
      extraHelp = " " + extraHelp;
    this._helpZoneLabel.innerHTML = this._description + extraHelp;
  }
  control_LostFocus(sender) {
    this._helpZoneLabel.innerHTML = "";
  }
  preExpandIfNeeded() {
    if (this._parentNode != null && this._parentNode.expanded) {
      this.AllocateControls();
      if (this.expandable)
        this.initExpandButton();
      this.initMainLabel();
    }
    this.initExpandButton();
  }
  constructor(p) {
    super();
    this.name = "NoName";
    this._targetFullName = "unknowTargetName";
    this.ExpandableDepth = 0;
    this._expanded = false;
    this._expandButtonSide = 0;
    this._rootEditor = null;
    this._description = "";
    this.expandCtrl = null;
    this.mainlabel = null;
    this.mainText = null;
    this.subElementPanel = null;
    this._rootNode = null;
    this._parentNode = null;
    this._parentPanel = null;
    this._changeCausesParentRefresh = false;
    this._isReadOnlyCall = "";
    this._controlsAllocated = false;
    this.expandButtonInitDone = false;
    this.mainLabelInitDone = false;
    this.subElements = [];
    this._valueChangeCallback = null;
    this._getValueCallback = null;
    this._shown = true;
    this._summaryCallback = null;
    this._showLabel = false;
    this._expandable = false;
    this._preExpanded = false;
    this.name = p.label;
    this._targetFullName = p.internalname;
    this._helpZoneLabel = p.HelpZoneLabel;
    this._description = p.description;
    this._changeCausesParentRefresh = p.changeCausesParentRefresh;
    this._expandable = p.expandable;
    this._preExpanded = p.preExpanded;
    this._structRoot = p.structRoot;
    this._isReadOnlyCall = p.isReadonlyCall;
    this._summaryProperty = p.summary;
    if (UIElement.baseheight == 0) {
      UIElement.baseheight = 12;
      UIElement.expandableShift = UIElement.baseheight + 2;
      UIElement.scrollBarWidth = 20;
    }
    this._parentNode = p.parentNode;
    this._rootNode = p.RootNode == null ? this : p.RootNode;
  }
  set rootEditor(value) {
    this._rootEditor = value;
  }
  get rootEditor() {
    return this._rootEditor;
  }
  initMainLabel() {
    if (this.mainlabel == null)
      return;
    if (this.mainLabelInitDone)
      return;
    this.ExpandableDepth = 0;
    let p = this;
    while (p != null) {
      if (p.expandable)
        this.ExpandableDepth++;
      p = p.parentNode;
    }
    this.mainText.innerText = this.name + this.getSummary();
    if (this.expandable && this._expandButtonSide == 0) {
      switch (this.ExpandableDepth) {
        case 1:
          this.mainlabel.style.backgroundColor = "Blue";
          this.mainText.style.color = "black";
          break;
        case 2:
          this.mainlabel.style.backgroundColor = "rgb(7,141,255)";
          this.mainText.style.color = "white";
          break;
        case 3:
          this.mainlabel.style.backgroundColor = "rgb(120,196,255)";
          break;
        case 4:
          this.mainlabel.style.backgroundColor = "rgb(213,237,255)";
          break;
        case 5:
          this.mainlabel.style.backgroundColor = "rgb(237,246,253)";
          break;
        default:
          this.mainlabel.style.backgroundColor = "rgb(246,251,255)";
          break;
      }
    } else {
      this.mainlabel.style.backgroundColor = "rgba( 0, 0, 0,0)";
    }
    this.mainLabelInitDone = true;
  }
  AllocateControls() {
    if (this._controlsAllocated)
      return;
    if (!this.isRootElement)
      this.parentNode.AllocateControls();
    this._parentPanel = this.parentNode.panel;
    if (this.mainlabel == null) {
      this.mainlabel = document.createElement("DIV");
      this.mainlabel.style.position = "relative";
      this.mainlabel.style.display = "inline-block;";
      this.mainlabel.style.left = "0px";
      this.mainlabel.style.padding = "2px 2px 2px 2px";
      this.mainlabel.style.overflow = "hidden";
      this.mainlabel.style.fontFamily = UIElement.defaultFontFamily;
      this.mainlabel.style.fontSize = UIElement.defaultFontSize.toString() + "px";
      this.mainlabel.style.right = "5px";
      this.mainlabel.style.whiteSpace = "nowrap";
      this.mainlabel.style.marginTop = "2px";
      this.mainlabel.style.backgroundColor = "yellow";
      this.mainText = document.createElement("SPAN");
      this.mainText.innerText = "Pouet";
      this.mainlabel.appendChild(this.mainText);
      this.mainlabel.style.display = this.isRootElement ? "none" : "";
      this.initMainLabel();
      if (this._parentPanel == null) {
        debugger;
      }
      this._parentPanel.appendChild(this.mainlabel);
    }
    if (this._expandable && this.expandCtrl == null) {
      this.expandCtrl = document.createElement("ANCHOR");
      if (this._expandButtonSide == 0) {
        this.mainlabel.insertBefore(this.expandCtrl, this.mainText);
      }
      this.initExpandButton();
      this.subElementPanel = document.createElement("DIV");
      this.subElementPanel.style.position = "relative";
      this.subElementPanel.style.display = "inline-block;";
      this.subElementPanel.style.left = this.isRootElement ? "0px" : "5px";
      this.subElementPanel.style.padding = "2px 2px 2px 2px";
      this.subElementPanel.style.right = "5px";
      this.subElementPanel.style.display = "none";
      this.subElementPanel.style.marginTop = "2px";
      this.subElementPanel.style.marginRight = "2px";
      this._parentPanel.appendChild(this.subElementPanel);
    }
    this._controlsAllocated = true;
  }
  initExpandButton() {
    if (this.expandCtrl == null)
      return;
    if (this.expandButtonInitDone)
      return;
    this.expandCtrl.innerHTML = this.expandIcon;
    this.expandCtrl.style.top = "0px";
    this.expandCtrl.style.left = "0px";
    this.expandCtrl.style.cursor = "pointer";
    this.expandCtrl.style.backgroundColor = "white";
    this.expandCtrl.style.marginRight = "3px";
    this.expandCtrl.style.paddingLeft = "0px";
    this.expandCtrl.style.paddingRight = "0px";
    this.expandCtrl.style.paddingTop = "1px";
    this.expandCtrl.style.marginTop = "0px";
    this.expandCtrl.style.marginBottom = "0px";
    this.expandCtrl.style.paddingBottom = "0px";
    this.expandCtrl.style.paddingRight = "0px";
    this.expandCtrl.addEventListener("click", () => {
      this.ToggleExpand();
    });
    this.expandCtrl.addEventListener("keyup", (e) => {
      if (e.key === "Enter" || e.key === " ")
        this.ToggleExpand();
    });
    this.expandCtrl.addEventListener("focusin", () => {
      this.control_GotFocus(this);
    });
    this.expandCtrl.addEventListener("focusout", () => {
      this.control_LostFocus(this);
    });
    this.expandButtonInitDone = true;
  }
  get rowHeight() {
    return UIElement.baseheight;
  }
  ExtractPropPath(info) {
    let index = -1;
    let path = [];
    let p = this;
    info.OriginalPropName = p.targetFullName;
    do {
      info.fullpropname = p.targetFullName;
      index = info.fullpropname.indexOf("_");
      if (index < 0) {
        if (info.fullpropname != UIElement.ARTIFICIALSECTIONNAME)
          path.splice(0, 0, info.fullpropname);
        p = p.parentNode;
        if (p == null)
          throw "invalid Property name";
      }
    } while (index < 0);
    info.propType = info.fullpropname.substring(0, index);
    let propname = info.fullpropname.substring(index + 1);
    path.splice(0, 0, propname);
    return path;
  }
  startEdit(setcallback, getCallback) {
    this.addToEditor();
    this._valueChangeCallback = setcallback;
    this._getValueCallback = getCallback;
    this.subElements.forEach((item) => {
      item.startEdit(setcallback, getCallback);
    });
  }
  stopEdit() {
    this.removeFromEditor();
    this._valueChangeCallback = null;
    this._getValueCallback = null;
    this.subElements.forEach((item) => {
      item.stopEdit();
    });
  }
  expand() {
    this.subElements.forEach((e) => {
      e.AllocateControls();
      e.show();
    });
    this._rootNode.tabReOrder(0);
    this._expanded = true;
    this.subElementPanel.style.display = "";
    this.expandCtrl.innerHTML = this.colapseIcon;
  }
  colapse() {
    this.subElementPanel.style.display = "none";
    this.expandCtrl.innerHTML = this.expandIcon;
  }
  get expanded() {
    return this._expanded;
  }
  set expanded(value) {
    this._expanded = value;
    if (this._expanded) {
      this.expand();
    } else {
      this.colapse();
    }
    this._rootNode.resizeAll();
  }
  ToggleExpand() {
    this.expanded = !this.expanded;
  }
  getSummary() {
    if (this._summaryProperty != null) {
      return " (" + Reflect.get(this._structRoot, this._summaryProperty.name) + ")";
    }
    return "";
  }
  sensorList() {
    let res = [];
    sensorsManager.sensorList.forEach((s) => {
      res.push(s);
    });
    return res;
  }
  ProcessNewType(dataStucture) {
    let subsections = {};
    this._structRoot = dataStucture;
    let toExpand = [];
    let properties = GenericProperties.getAllProperties(dataStucture);
    for (let i = 0; i < properties.byIndex.length; i++) {
      let ps = properties.byIndex[i];
      if (ps.isWritable) {
        let attr = new CustomAttributesExtractor(ps);
        if (attr.available) {
          let section = this;
          if (attr.category != "") {
            if (attr.category in subsections) {
              section = subsections[attr.category];
            } else {
              let sectionparam = new UIElementBaseParams(this._helpZoneLabel, this, this._rootNode, UIElement.ARTIFICIALSECTIONNAME, attr.category, attr.category + " section, expand for more...", "");
              sectionparam.preExpanded = attr.PreExpandedCategory;
              sectionparam.expandable = true;
              sectionparam.structRoot = dataStucture;
              if (attr.summaryPropertyName != "") {
                sectionparam.summary = ps;
              }
              section = new UIElement(sectionparam);
              if (attr.PreExpandedCategory)
                toExpand.push(section);
              section.showLabel = true;
              subsections[attr.category] = section;
              this.addSubElement(section);
            }
          }
          let elParam = new UIElementBaseParams(this._helpZoneLabel, section, this._rootNode, ps.name, attr.displayName, attr.displayDescription, attr.isReadOnlyCall);
          elParam.preExpanded = attr.PreExpanded;
          elParam.changeCausesParentRefresh = attr.changeCausesParentRefresh;
          let targetName = this._targetFullName;
          let targetPrefix = "";
          let p = targetName.indexOf("_");
          if (p >= 0) {
            targetPrefix = targetName.substring(0, p);
            targetName = targetName.substring(p + 1);
          }
          if (ps.isEnum) {
            let s = new UIElementEnum(elParam, dataStucture, ps);
            section.addSubElement(s);
          } else {
            switch (ps.type) {
              case "number":
                if (attr.prefinedValues == null) {
                  let n = new UIElementNumber(elParam, dataStucture, ps);
                  section.addSubElement(n);
                } else {
                  let s2 = new UIElementList(elParam, dataStucture, ps, () => {
                    return attr.prefinedValues;
                  });
                  section.addSubElement(s2);
                }
                break;
              case "boolean":
                let b = new UIElementBoolean(elParam, dataStucture, ps);
                section.addSubElement(b);
                break;
              case doubleNan.name:
                let d = new UIElementDoubleNan(elParam, dataStucture, ps);
                section.addSubElement(d);
                break;
              case NullYSensor.name:
              case CustomYSensor.name:
                let s = new UIElementList(elParam, dataStucture, ps, () => {
                  return this.sensorList();
                });
                section.addSubElement(s);
                break;
              case YColor.name:
                let c = new UIElementColor(elParam, dataStucture, ps);
                section.addSubElement(c);
                break;
              case xAxisPosition.name:
                let p2 = new UIElementMarkerPos(elParam, dataStucture, ps);
                section.addSubElement(p2);
                break;
              case "string":
                if (attr.prefinedValues == null) {
                  let s2 = new UIElementString(elParam, dataStucture, ps);
                  section.addSubElement(s2);
                } else {
                  let s2 = new UIElementList(elParam, dataStucture, ps, () => {
                    return attr.prefinedValues;
                  });
                  section.addSubElement(s2);
                }
                break;
              default:
                {
                  elParam.expandable = true;
                  elParam.preExpanded = attr.PreExpanded;
                  let subobjectsection = new UIElement(elParam);
                  if (attr.PreExpanded)
                    toExpand.push(subobjectsection);
                  subobjectsection.showLabel = true;
                  section.addSubElement(subobjectsection);
                  subobjectsection.ProcessNewType(dataStucture[ps.name]);
                }
                break;
            }
          }
        }
      } else {
        if (ps.name == "summary") {
          this._summaryProperty = ps;
        }
      }
    }
    if (this._summaryProperty != null)
      this.refresh();
    toExpand.forEach((e) => {
      e.expand();
    });
  }
  show() {
    this._shown = true;
    if (this.mainlabel != null)
      this.mainlabel.style.display = "";
    if (this.expandCtrl != null)
      this.expandCtrl.style.display = this._expandable ? "" : "hidden";
    if (this.expanded) {
      this.subElements.forEach((e) => {
        e.show();
      });
    }
  }
  hide() {
    this._shown = false;
    if (this.mainlabel != null)
      this.mainlabel.style.display = "hidden";
    if (this.expandCtrl != null)
      this.expandCtrl.style.display = this._expandable ? "hidden" : "";
    this.subElements.forEach((e) => {
      e.hide();
    });
  }
  ExpandCtrl_Click_expand(sender) {
    this.expanded = !this._expanded;
  }
  resizeAll() {
    this.resize(0, 0, 0, 0);
    if (this.expanded) {
      this.subElements.forEach((e) => {
        e.resizeAll();
      });
    }
  }
  get showLabel() {
    return this._showLabel;
  }
  set showLabel(value) {
    this._showLabel = value;
    if (this.expandCtrl != null)
      this.expandCtrl.style.display = value && this._expandable ? "" : "hidden";
  }
  get expandable() {
    return this._expandable;
  }
  set expandable(value) {
    this._expandable = value;
    if (!value)
      return;
    if (this.expandCtrl == null) {
      this.AllocateControls();
      this.initExpandButton();
    }
    this.expandCtrl.style.display = value && this._showLabel ? "" : "hidden";
  }
  addSubElement(node) {
    this.subElements.push(node);
  }
  computeHeight() {
    return 0;
  }
  resize(top2, left1, left2, width) {
    return 0;
  }
};
UIElement.defaultFontFamily = constants.generalFontFamily;
UIElement.defaultFontSize = constants.generalFontSize;
UIElement.ARTIFICIALSECTIONNAME = "-ignore-";
UIElement.baseheight = 0;
UIElement.indentation = 16;
UIElement.expandableShift = 0;
UIElement.scrollBarWidth = 0;
UIElement.expandableVerticalOffset = 2;
var UIElementGeneric = class extends UIElement {
  constructor(p, dataContainer, prop) {
    super(p);
    this.input = null;
    this.select = null;
    this._prop = prop;
    this._dataContainer = dataContainer;
    this._showLabel = true;
    if (this._preExpanded)
      this.AllocateControls();
    if (this._expandable && this._preExpanded)
      this.expand();
  }
  removeFromEditor() {
    super.removeFromEditor();
  }
  tabReOrder(index) {
    if (this.input != null)
      this.input.tabIndex = index++;
    this.subElements.forEach((e) => {
      index = e.tabReOrder(index);
    });
    return index;
  }
  addToEditor() {
    super.addToEditor();
  }
  show() {
    super.show();
    if (this.input != null)
      this.input.style.visibility = "";
  }
  checkForReadOnly() {
    if (this.input == null && this.select == null)
      return;
    if (this._isReadOnlyCall != "") {
      let ro = Reflect.get(this._dataContainer, this._isReadOnlyCall);
      if (this.input != null)
        this.input.disabled = ro;
      if (this.select != null)
        this.select.disabled = ro;
    }
  }
  hide() {
    if (this.input != null)
      this.input.style.visibility = "hidden";
    super.hide();
  }
  resize(top2, left1, left2, width) {
    return 0;
  }
};
var UIElementString = class extends UIElementGeneric {
  constructor(p, dataContainer, prop) {
    super(p, dataContainer, prop);
    this._value = "";
    this.preExpandIfNeeded();
  }
  AllocateControls() {
    super.AllocateControls();
    if (this.input == null) {
      this.input = document.createElement("INPUT");
      this.input.type = "input";
      this.input.value = Reflect.get(this._dataContainer, this._prop.name);
      this.input.style.position = "absolute";
      this.input.style.marginTop = "0px";
      this.input.style.marginBottom = "0px";
      this.input.style.fontFamily = UIElement.defaultFontFamily;
      this.input.style.fontSize = UIElement.defaultFontSize.toString() + "px";
      this.input.style.border = "1px solid grey";
      this.input.style.borderRadius = "1px";
      this.input.style.top = "0px";
      this.input.style.right = "3px";
      this.input.style.width = "50%";
      this.mainlabel.appendChild(this.input);
      new InputFieldManager(this.input, 0, true, Number.NaN, Number.NaN, () => {
        this.Text_TextChanged(null);
      });
      this.input.addEventListener("focusin", () => {
        this.control_GotFocus(this);
      });
      this.input.addEventListener("focusout", () => {
        this.control_LostFocus(this);
      });
      this.checkForReadOnly();
    }
  }
  refresh() {
    if (this.input == null)
      return;
    if (this._getValueCallback == null)
      return;
    let value = this._getValueCallback(this);
    if (value == null)
      return;
    let s = value.toString();
    if (this.input != null) {
      if (s != this.input.value)
        this.input.value = s;
    }
    this.checkForReadOnly();
  }
  Text_TextChanged(sender) {
    if (this.input != null) {
      this._value = this.input.value;
      Reflect.set(this._dataContainer, this._prop.name, this._value);
      if (this._valueChangeCallback != null)
        this._valueChangeCallback(this);
      if (this._changeCausesParentRefresh)
        this.parentNode.refresh();
    }
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value;
    this.input.value = value;
  }
  resize(top2, left1, left2, width) {
    this.mainlabel.style.height = this.input.offsetHeight.toString() + "px";
    return 0;
  }
};
var UIElementNumber = class extends UIElementGeneric {
  constructor(p, dataContainer, prop) {
    super(p, dataContainer, prop);
    this._value = 0;
    this.preExpandIfNeeded();
  }
  AllocateControls() {
    super.AllocateControls();
    if (this.input == null) {
      this.input = document.createElement("INPUT");
      this.input.type = "input";
      this.input.value = Reflect.get(this._dataContainer, this._prop.name);
      this.input.style.textAlign = "right";
      this.input.style.position = "absolute";
      this.input.style.marginTop = "0px";
      this.input.style.marginBottom = "0px";
      this.input.style.fontFamily = UIElement.defaultFontFamily;
      this.input.style.fontSize = UIElement.defaultFontSize.toString() + "px";
      this.input.type = "number";
      this.input.style.border = "1px solid grey";
      this.input.style.borderRadius = "1px";
      this.input.style.top = "0px";
      this.input.style.right = "3px";
      this.input.style.width = "50%";
      this.mainlabel.appendChild(this.input);
      new InputFieldManager(this.input, 4, false, Number.NaN, Number.NaN, () => {
        this.Text_TextChanged(null);
      });
      this.input.addEventListener("focusin", () => {
        this.control_GotFocus(this);
      });
      this.input.addEventListener("focusout", () => {
        this.control_LostFocus(this);
      });
      this.checkForReadOnly();
    }
  }
  refresh() {
    if (this.input == null)
      return;
    if (this._getValueCallback == null)
      return;
    let s = this._getValueCallback(this);
    if (s == null)
      return;
    if (this.input != null) {
      if (s != parseFloat(this.input.value))
        this.input.value = s.toString();
    }
    this.checkForReadOnly();
  }
  Text_TextChanged(sender) {
    if (this.input != null) {
      this._value = parseFloat(this.input.value);
      Reflect.set(this._dataContainer, this._prop.name, this._value);
      if (this._valueChangeCallback != null)
        this._valueChangeCallback(this);
      if (this._changeCausesParentRefresh)
        this.parentNode.refresh();
    }
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value;
    this.input.value = value.toString();
  }
  resize(top2, left1, left2, width) {
    this.mainlabel.style.height = this.input.offsetHeight.toString() + "px";
    return 0;
  }
};
var UIElementBoolean = class extends UIElementGeneric {
  constructor(p, dataContainer, prop) {
    super(p, dataContainer, prop);
    this._text = null;
    this._value = false;
    this.preExpandIfNeeded();
  }
  AllocateControls() {
    super.AllocateControls();
    if (this.input == null) {
      let span = document.createElement("SPAN");
      span.style.position = "absolute";
      span.style.display = "inline-block";
      span.style.width = "50%";
      span.style.right = "0px";
      this.mainlabel.appendChild(span);
      this.input = document.createElement("INPUT");
      this.input.type = "input";
      this.input.checked = Reflect.get(this._dataContainer, this._prop.name);
      this.input.style.textAlign = "right";
      this.input.style.display = "inline";
      this.input.style.marginTop = "0px";
      this.input.style.marginBottom = "0px";
      this.input.type = "checkbox";
      this.input.style.transform = "scale(" + constants.generalSizeCoef.toString() + ")";
      this.input.style.marginRight = Math.round(5 * constants.generalSizeCoef).toString() + "px";
      this.input.style.top = "0px";
      this.input.style.border = "1px solid grey";
      this.input.style.borderRadius = "1px";
      span.appendChild(this.input);
      this.input.addEventListener("keyup", (e) => {
        if (e.key === " ")
          this.value_TextChanged(null);
      });
      this.input.addEventListener("change", () => {
        this.value_TextChanged(null);
      });
      this._text = document.createElement("SPAN");
      this._text.style.display = "inline";
      this._text.style.fontFamily = UIElement.defaultFontFamily;
      this._text.style.fontSize = UIElement.defaultFontSize.toString() + "px";
      span.appendChild(this._text);
      this.updateText();
      this.input.addEventListener("focusin", () => {
        this.control_GotFocus(this);
      });
      this.input.addEventListener("focusout", () => {
        this.control_LostFocus(this);
      });
      this.checkForReadOnly();
    }
  }
  updateText() {
    this._text.innerText = this.input.checked ? "Enabled" : "Disabled";
  }
  refresh() {
    if (this.input == null)
      return;
    this.checkForReadOnly();
    if (this._getValueCallback == null)
      return;
    let v = this._getValueCallback(this);
    if (v == null)
      return;
    let b = v;
    if (this.input != null) {
      this.input.checked = b.valueOf();
      this.updateText();
    }
  }
  value_TextChanged(sender) {
    if (this.input != null) {
      this._value = this.input.checked;
      this.updateText();
      Reflect.set(this._dataContainer, this._prop.name, this._value);
      if (this._valueChangeCallback != null)
        this._valueChangeCallback(this);
      if (this._changeCausesParentRefresh)
        this.parentNode.refresh();
    }
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value;
    this.input.checked = value;
    this.updateText();
  }
  resize(top2, left1, left2, width) {
    return 0;
  }
};
var UIElementDoubleNan = class extends UIElementGeneric {
  constructor(p, dataContainer, prop) {
    super(p, dataContainer, prop);
    this._value = 0;
    this.preExpandIfNeeded();
  }
  AllocateControls() {
    super.AllocateControls();
    if (this.input == null) {
      this.input = document.createElement("INPUT");
      this.input.type = "input";
      this.input.value = Reflect.get(this._dataContainer, this._prop.name).toString();
      this.input.style.textAlign = "right";
      this.input.style.position = "absolute";
      this.input.style.marginTop = "0px";
      this.input.style.marginBottom = "0px";
      this.input.style.fontFamily = UIElement.defaultFontFamily;
      this.input.style.fontSize = UIElement.defaultFontSize.toString() + "px";
      this.input.type = "number";
      this.input.style.border = "1px solid grey";
      this.input.style.borderRadius = "1px";
      this.input.style.top = "0px";
      this.input.style.right = "3px";
      this.input.style.width = "50%";
      this.mainlabel.appendChild(this.input);
      new InputFieldManager(this.input, 4, true, Number.NaN, Number.NaN, () => {
        this.Text_TextChanged(null);
      });
      this.input.addEventListener("focusin", () => {
        this.control_GotFocus(this);
      });
      this.input.addEventListener("focusout", () => {
        this.control_LostFocus(this);
      });
      this.checkForReadOnly();
    }
  }
  refresh() {
    if (this.input == null)
      return;
    if (this._getValueCallback == null)
      return;
    let s = this._getValueCallback(this).toString();
    if (this.input != null) {
      if (s != this.input.value)
        this.input.value = s;
    }
    this.checkForReadOnly();
  }
  Text_TextChanged(sender) {
    if (this.input != null) {
      this._value = this.input.value == "" ? Number.NaN : parseFloat(this.input.value);
      Reflect.set(this._dataContainer, this._prop.name, new doubleNan(this._value));
      if (this._valueChangeCallback != null)
        this._valueChangeCallback(this);
      if (this._changeCausesParentRefresh)
        this.parentNode.refresh();
    }
  }
  get value() {
    return new doubleNan(this._value);
  }
  set value(value) {
    this._value = value.value;
    this.input.value = value.toString();
  }
  resize(top2, left1, left2, width) {
    this.mainlabel.style.height = this.input.offsetHeight.toString() + "px";
    return 0;
  }
};
var UIElementEnum = class extends UIElementGeneric {
  constructor(p, dataContainer, prop) {
    super(p, dataContainer, prop);
    this.allValues = [];
    this._value = "";
    this.preExpandIfNeeded();
  }
  AllocateControls() {
    super.AllocateControls();
    if (this.select == null) {
      this.select = document.createElement("SELECT");
      let enumvalue = Reflect.get(this._dataContainer, this._prop.name);
      this.allValues = enumvalue.sibblings;
      for (let i = 0; i < this.allValues.length; i++) {
        let opt = document.createElement("OPTION");
        opt.text = this.allValues[i].description;
        opt.value = this.allValues[i].toString;
        this.select.add(opt, null);
      }
      this.select.value = enumvalue.toString;
      this.select.style.position = "absolute";
      this.select.style.marginTop = "0px";
      this.select.style.marginBottom = "0px";
      this.select.style.fontFamily = UIElement.defaultFontFamily;
      this.select.style.fontSize = UIElement.defaultFontSize.toString() + "px";
      this.select.style.top = "0px";
      this.select.style.right = "3px";
      this.select.style.width = "50%";
      this.mainlabel.appendChild(this.select);
      this.select.addEventListener("change", () => {
        this.valueChanged(null);
      });
      this.select.addEventListener("focusin", () => {
        this.control_GotFocus(this);
      });
      this.select.addEventListener("focusout", () => {
        this.control_LostFocus(this);
      });
      this.checkForReadOnly();
    }
  }
  refresh() {
    if (this.select == null)
      return;
    if (this._getValueCallback == null)
      return;
    let value = this._getValueCallback(this);
    let s = value.toString;
    if (this.select != null) {
      if (s != this.select.value)
        this.select.value = s;
    }
    this.checkForReadOnly();
  }
  valueChanged(sender) {
    if (this.select != null) {
      this._value = this.select.value;
      let it = null;
      for (let i = 0; i < this.allValues.length; i++) {
        if (this.allValues[i].toString == this._value)
          it = this.allValues[i];
      }
      if (it != null)
        Reflect.set(this._dataContainer, this._prop.name, it);
      if (this._valueChangeCallback != null)
        this._valueChangeCallback(this);
      if (this._changeCausesParentRefresh)
        this.parentNode.refresh();
    }
  }
  tabReOrder(index) {
    if (this.select != null)
      this.select.tabIndex = index++;
    return index;
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value;
    this.select.value = value;
  }
  resize(top2, left1, left2, width) {
    this.mainlabel.style.height = this.select.offsetHeight.toString() + "px";
    return 0;
  }
};
var UIElementList = class extends UIElementGeneric {
  constructor(p, dataContainer, prop, allowedValues) {
    super(p, dataContainer, prop);
    this._refreshCallback = null;
    this._indexedValue = true;
    this.allValues = [];
    this.valueType = "";
    this._value = "";
    this._refreshCallback = allowedValues;
    this.preExpandIfNeeded();
  }
  AllocateControls() {
    super.AllocateControls();
    if (this.select == null) {
      this.allValues = this._refreshCallback();
      this.select = document.createElement("SELECT");
      let value = Reflect.get(this._dataContainer, this._prop.name);
      this.valueType = typeof value;
      this._indexedValue = typeof value == "number" && typeof this.allValues[0] != "number";
      let found = false;
      let first = null;
      for (let i = 0; i < this.allValues.length; i++) {
        let opt = document.createElement("OPTION");
        if (i == 0)
          first = opt;
        opt.text = this.allValues[i].toString();
        opt.value = this._indexedValue ? i : this.allValues[i];
        this.select.add(opt, null);
        if (opt.value.toString() == value.toString())
          found = true;
      }
      if (!found && !this._indexedValue) {
        let opt = document.createElement("OPTION");
        opt.text = value.toString();
        opt.value = value;
        this.select.add(opt, first);
      }
      this.select.value = value;
      this.select.style.position = "absolute";
      this.select.style.marginTop = "0px";
      this.select.style.marginBottom = "0px";
      this.select.style.fontFamily = UIElement.defaultFontFamily;
      this.select.style.fontSize = UIElement.defaultFontSize.toString() + "px";
      this.select.style.top = "0px";
      this.select.style.right = "3px";
      this.select.style.width = "50%";
      this.mainlabel.appendChild(this.select);
      this.select.addEventListener("change", () => {
        this.valueChanged(null);
      });
      this.select.addEventListener("focusin", () => {
        this.control_GotFocus(this);
      });
      this.select.addEventListener("focusout", () => {
        this.control_LostFocus(this);
      });
      this.checkForReadOnly();
    }
  }
  refresh() {
    if (this.select == null)
      return;
    if (this._getValueCallback == null)
      return;
    this.allValues = this._refreshCallback();
    for (let i = 0; i < this.allValues.length; i++) {
      let opt = i < this.select.options.length ? this.select.options[i] : document.createElement("OPTION");
      opt.text = this.allValues[i].toString();
      opt.value = this._indexedValue ? i : this.allValues[i];
      if (i >= this.select.options.length)
        this.select.add(opt, null);
    }
    while (this.allValues.length < this.select.options.length) {
      this.select.options[this.select.options.length - 1].remove();
    }
    let v = Reflect.get(this._dataContainer, this._prop.name);
    if (v == null)
      return;
    if (this._indexedValue) {
      let it = Number(v).toString();
      if (this.select.value != it)
        this.select.value = it;
    } else {
      let it = v.toString();
      if (this.select.value != it)
        this.select.value = it;
    }
    this.checkForReadOnly();
  }
  valueChanged(sender) {
    if (this.select != null) {
      this._value = this.select.value;
      if (this.valueType == "number") {
        let it = parseInt(this._value);
        if (it >= 0)
          Reflect.set(this._dataContainer, this._prop.name, it);
      } else {
        let it = "";
        for (let i = 0; i < this.allValues.length; i++) {
          if (this.allValues[i] == this._value)
            it = this.allValues[i];
        }
        if (it != "")
          Reflect.set(this._dataContainer, this._prop.name, it);
      }
      if (this._valueChangeCallback != null)
        this._valueChangeCallback(this);
      if (this._changeCausesParentRefresh) {
        this.parentNode.refresh();
      }
    }
  }
  tabReOrder(index) {
    if (this.select != null)
      this.select.tabIndex = index++;
    return index;
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value;
    this.select.value = value;
  }
  resize(top2, left1, left2, width) {
    this.mainlabel.style.height = this.select.offsetHeight.toString() + "px";
    return 0;
  }
};
var UIElementColor = class extends UIElementGeneric {
  constructor(p, dataContainer, prop) {
    super(p, dataContainer, prop);
    this.colorSample = null;
    this.colorEditor = null;
    this.colorPreview = null;
    this.currentColor = null;
    this._value = "";
    this.preExpandIfNeeded();
  }
  get expandIcon() {
    return ressources.DotDotDotIcon(UIElement.defaultFontSize.toString(), false, false, false, false, "Click to open color chooser");
  }
  get colapseIcon() {
    return ressources.DotDotDotIcon(UIElement.defaultFontSize.toString(), false, false, false, false, "Click to close color chooser");
  }
  AllocateControls() {
    this._expandable = true;
    this._expandButtonSide = 1;
    super.AllocateControls();
    if (this.input == null) {
      let table = document.createElement("TABLE");
      table.style.position = "absolute";
      table.style.top = "0px";
      table.style.right = "3px";
      table.style.width = "50%";
      table.style.borderCollapse = "collapse";
      let tr = document.createElement("TR");
      table.appendChild(tr);
      let td1 = document.createElement("TD");
      tr.appendChild(td1);
      this.colorSample = document.createElement("Div");
      this.colorSample.style.display = "inline-block";
      this.colorSample.style.border = "1px solid black";
      this.colorSample.style.marginRight = "1px";
      this.colorSample.style.marginTop = "0px";
      this.colorSample.style.width = "16px";
      this.colorSample.style.height = "16px";
      this.colorSample.style.top = "0px";
      this.colorSample.style.bottom = "0px";
      this.colorPreview = new ColorSampler(this.colorSample, null);
      td1.appendChild(this.colorSample);
      let td2 = document.createElement("TD");
      td2.style.width = "100%";
      tr.appendChild(td2);
      this.input = document.createElement("INPUT");
      this.input.type = "input";
      this.currentColor = Reflect.get(this._dataContainer, this._prop.name);
      this.colorPreview.color = this.currentColor;
      this.input.value = this.currentColor.toString();
      this.input.style.marginTop = "0px";
      this.input.style.marginBottom = "0px";
      this.input.style.width = "100%";
      this.input.style.border = "1px solid grey";
      this.input.style.borderRadius = "1px";
      this.input.style.fontFamily = UIElement.defaultFontFamily;
      this.input.style.fontSize = UIElement.defaultFontSize.toString() + "px";
      td2.appendChild(this.input);
      let td3 = document.createElement("TD");
      td3.style.paddingLeft = "5px";
      tr.appendChild(td3);
      td3.appendChild(this.expandCtrl);
      this.mainlabel.appendChild(table);
      new InputFieldManager(this.input, 7, false, Number.NaN, Number.NaN, (sender, refreshInput) => {
        this.Text_TextChanged(sender, refreshInput);
      });
      this.input.addEventListener("focusin", () => {
        this.control_GotFocus(this);
      });
      this.input.addEventListener("focusout", () => {
        this.control_LostFocus(this);
      });
      this.checkForReadOnly();
    }
  }
  expand() {
    if (this.colorEditor == null) {
      this.subElementPanel.style.marginLeft = "20px";
      this.colorEditor = new colorEditor(this.subElementPanel, UIElement.defaultFontSize, this.currentColor, (c) => {
        this.coloredited(c);
      });
    }
    this._rootNode.tabReOrder(0);
    this._expanded = true;
    this.subElementPanel.style.display = "";
    this.expandCtrl.innerHTML = this.colapseIcon;
  }
  colapse() {
    this.subElementPanel.style.display = "none";
    this.expandCtrl.innerHTML = this.expandIcon;
  }
  coloredited(newColor) {
    this.currentColor = newColor.clone();
    this.colorPreview.color = this.currentColor;
    this.input.value = this.currentColor.toString();
    Reflect.set(this._dataContainer, this._prop.name, this.currentColor);
    if (this._valueChangeCallback != null)
      this._valueChangeCallback(this);
    if (this._changeCausesParentRefresh)
      this.parentNode.refresh();
  }
  refresh() {
    if (this.input == null)
      return;
    if (this._getValueCallback == null)
      return;
    let c = this._getValueCallback(this);
    if (c != null) {
      if (this.colorPreview != null)
        this.colorPreview.color = c;
      if (this.input != null) {
        let s = c.toString();
        if (s != this.input.value)
          this.input.value = s;
      }
    }
    this.checkForReadOnly();
  }
  Text_TextChanged(sender, refreshInput) {
    if (this.input != null) {
      this._value = this.input.value;
      let c = YColor.FromString(this._value);
      if (c != null) {
        this.colorPreview.color = c;
        this.currentColor = c;
        if (this.colorEditor != null)
          this.colorEditor.color = c;
        Reflect.set(this._dataContainer, this._prop.name, c);
        if (refreshInput)
          this.input.value = c.toString();
        if (this._valueChangeCallback != null)
          this._valueChangeCallback(this);
        if (this._changeCausesParentRefresh)
          this.parentNode.refresh();
      }
    }
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value;
    this.input.value = value;
  }
  resize(top2, left1, left2, width) {
    let h = this.input.offsetHeight;
    this.mainlabel.style.height = h.toString() + "px";
    return 0;
  }
};
var UIElementMarkerPos = class extends UIElementGeneric {
  constructor(p, dataContainer, prop) {
    super(p, dataContainer, prop);
    this._cachedValue = null;
    this._value = "";
    this.preExpandIfNeeded();
  }
  static expandIconSVG(size) {
    return ressources.targetIcon(size.toString(), false, false, false, false, "Click to place marker on graph");
  }
  get expandIcon() {
    return UIElementMarkerPos.expandIconSVG(UIElement.defaultFontSize);
  }
  get colapseIcon() {
    return UIElementMarkerPos.expandIconSVG(UIElement.defaultFontSize);
  }
  AllocateControls() {
    this._expandable = true;
    this._expandButtonSide = 1;
    super.AllocateControls();
    if (this.input == null) {
      let table = document.createElement("TABLE");
      table.style.position = "absolute";
      table.style.top = "0px";
      table.style.right = "3px";
      table.style.width = "50%";
      table.style.borderCollapse = "collapse";
      let tr = document.createElement("TR");
      table.appendChild(tr);
      let td2 = document.createElement("TD");
      td2.style.width = "100%";
      tr.appendChild(td2);
      this.input = document.createElement("INPUT");
      this.input.type = "input";
      this._cachedValue = Reflect.get(this._dataContainer, this._prop.name);
      this.input.value = this._cachedValue.toString();
      this.input.style.marginTop = "0px";
      this.input.style.marginBottom = "0px";
      this.input.style.textAlign = "right";
      this.input.style.width = "100%";
      this.input.style.border = "1px solid grey";
      this.input.style.borderRadius = "1px";
      this.input.style.fontFamily = UIElement.defaultFontFamily;
      this.input.style.fontSize = UIElement.defaultFontSize.toString() + "px";
      this.input.addEventListener("keyup", () => {
        this.Text_TextChanged(null, true);
      });
      this.input.addEventListener("change", () => {
        this.Text_TextChanged(null, false);
      });
      td2.appendChild(this.input);
      let td3 = document.createElement("TD");
      td3.style.paddingLeft = "5px";
      tr.appendChild(td3);
      td3.appendChild(this.expandCtrl);
      this.mainlabel.appendChild(table);
      this.input.addEventListener("focusin", () => {
        this.control_GotFocus(this);
      });
      this.input.addEventListener("focusout", () => {
        this.control_LostFocus(this);
      });
      this.checkForReadOnly();
    }
  }
  expand() {
    let value = Reflect.get(this._dataContainer, this._prop.name);
    this.expanded = false;
    value.capture = true;
    Reflect.set(this._dataContainer, this._prop.name, value);
    if (this._valueChangeCallback != null)
      this._valueChangeCallback(this);
  }
  colapse() {
  }
  refresh() {
    if (this.input == null)
      return;
    if (this._getValueCallback == null)
      return;
    this._cachedValue = this._getValueCallback(this);
    if (this.input != null) {
      this.input.value = this._cachedValue.toString();
    }
    this.checkForReadOnly();
  }
  Text_TextChanged(sender, refreshInput) {
    let parsedValue = this._cachedValue.TryParse(this.input.value);
    if (parsedValue.success) {
      this._cachedValue.value = parsedValue.result;
      Reflect.set(this._dataContainer, this._prop.name, this._cachedValue);
      if (this._valueChangeCallback != null)
        this._valueChangeCallback(this);
      if (this._changeCausesParentRefresh)
        this.parentNode.refresh();
    }
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value;
    this.input.value = value;
  }
  resize(top2, left1, left2, width) {
    let h = this.input.offsetHeight;
    this.mainlabel.style.height = h.toString() + "px";
    return 0;
  }
};
var InputFieldManager = class {
  static nullCallback(sender) {
  }
  constructor(input, type, allowEmpty, min, max, callback) {
    this._allowEmpty = false;
    this._min = Number.NaN;
    this._max = Number.NaN;
    this._callback = null;
    this._input = input;
    this._type = type;
    this._allowEmpty = allowEmpty;
    this._min = min;
    this._max = max;
    this._callback = callback;
    this.checkData();
    this._input.addEventListener("keyup", () => {
      this.InputChange(this._input, true);
    });
    this._input.addEventListener("change", () => {
      this.InputChange(this._input, false);
    });
  }
  showError(msg) {
    this._input.title = msg;
  }
  clearError() {
    this._input.title = "";
  }
  backGroundColorFeedback(ErrorMsg, state) {
    if (state)
      this.clearError();
    else
      this.showError(ErrorMsg);
    let c = this._input.style.backgroundColor;
    if (state && c != "white")
      this._input.style.backgroundColor = "white";
    if (!state && c != "pink")
      this._input.style.backgroundColor = "pink";
    return state;
  }
  checkData() {
    let intValue = 0;
    let doubleValue = 0;
    if (this._input.disabled)
      return true;
    let strValue = this._input.value;
    if (strValue == "")
      return this.backGroundColorFeedback("This field can't be empty", this._allowEmpty);
    switch (this._type) {
      case 0:
        break;
      case 1:
        intValue = parseInt(strValue);
        doubleValue = parseFloat(strValue);
        if (Number.isNaN(intValue) || intValue != doubleValue)
          return this.backGroundColorFeedback("Integer value expected", false);
        if (!Number.isNaN(this._min) && intValue < this._min)
          return this.backGroundColorFeedback("Integer value greater or equal to " + this._min.toString() + " expected", false);
        if (!Number.isNaN(this._max) && intValue > this._max)
          return this.backGroundColorFeedback("Integer value lower or equal to  " + this._min.toString() + " expected", false);
        break;
      case 2:
        intValue = parseInt(strValue);
        doubleValue = parseFloat(strValue);
        if (Number.isNaN(intValue) || intValue != doubleValue)
          return this.backGroundColorFeedback("Positive integer  expected", false);
        if (intValue < 0)
          return this.backGroundColorFeedback("Positive integer value  expected", false);
        if (!Number.isNaN(this._min) && intValue < this._min)
          return this.backGroundColorFeedback("Positive integer value greater or equal to " + this._min.toString() + " expected", false);
        if (!Number.isNaN(this._max) && intValue > this._max)
          return this.backGroundColorFeedback("Positive integer value lower or equal to  " + this._min.toString() + " expected", false);
        break;
      case 3:
        intValue = parseInt(strValue);
        doubleValue = parseFloat(strValue);
        if (Number.isNaN(intValue) || intValue != doubleValue)
          return this.backGroundColorFeedback("Strictly positive Integer value expected", false);
        if (intValue <= 0)
          return this.backGroundColorFeedback("Strictly positive integer value  expected", false);
        if (!Number.isNaN(this._min) && intValue < this._min)
          return this.backGroundColorFeedback("Positive integer value greater or equal to " + this._min.toString() + " expected", false);
        if (!Number.isNaN(this._max) && intValue > this._max)
          return this.backGroundColorFeedback("Positive integer value lower or equal to  " + this._min.toString() + " expected", false);
        break;
      case 4:
        doubleValue = parseFloat(strValue);
        if (Number.isNaN(intValue))
          return this.backGroundColorFeedback("Floating point value expected", false);
        if (!Number.isNaN(this._min) && doubleValue < this._min)
          return this.backGroundColorFeedback("Floating point value greater or equal to " + this._min.toString() + " expected", false);
        if (!Number.isNaN(this._max) && doubleValue > this._max)
          return this.backGroundColorFeedback("Floating point value lower or equal to  " + this._min.toString() + " expected", false);
        break;
      case 5:
        doubleValue = parseFloat(strValue);
        if (Number.isNaN(doubleValue))
          return this.backGroundColorFeedback("Positive floating point value expected", false);
        if (doubleValue < 0)
          return this.backGroundColorFeedback("Positive floating point value expected", false);
        if (!Number.isNaN(this._min) && doubleValue < this._min)
          return this.backGroundColorFeedback("Floating point value greater or equal to " + this._min.toString() + " expected", false);
        if (!Number.isNaN(this._max) && doubleValue > this._max)
          return this.backGroundColorFeedback("Floating point value lower or equal to  " + this._min.toString() + " expected", false);
        break;
      case 6:
        doubleValue = parseFloat(strValue);
        if (Number.isNaN(doubleValue))
          return this.backGroundColorFeedback("Strictly positive floating point value expected", false);
        if (doubleValue <= 0)
          return this.backGroundColorFeedback("Strictly positive floating point value expected", false);
        if (!Number.isNaN(this._min) && doubleValue < this._min)
          return this.backGroundColorFeedback("Floating point value greater or equal to " + this._min.toString() + " expected", false);
        if (!Number.isNaN(this._max) && doubleValue > this._max)
          return this.backGroundColorFeedback("Floating point value greater or equal to " + this._min.toString() + " expected", false);
        break;
      case 7:
        if (YColor.FromString(strValue) == null)
          return this.backGroundColorFeedback("Value color name/definition expected", false);
        break;
    }
    return this.backGroundColorFeedback("", true);
  }
  InputChange(sender, refreshInput) {
    if (this.checkData()) {
      try {
        if (this._callback != null)
          this._callback(sender, refreshInput);
      } catch (ex) {
        this.backGroundColorFeedback(ex.message, false);
      }
    }
  }
};

// obj/full/colorEditor_rw.js
var ColorEditorTab = class {
  constructor(editor, label, fontSize) {
    this._realTab = false;
    this._div = null;
    this._tabLabel = null;
    this._td = document.createElement("TD");
    this._editor = editor;
    if (label != "") {
      this._div = document.createElement("DIV");
      this._div.style.display = "none";
      this._td.style.paddingTop = "4px";
      this._td.style.fontSize = fontSize.toString() + "px";
      this._td.style.paddingBottom = "2px";
      this._td.style.borderLeft = "1px solid " + this._editor.inactiveBorderColor;
      this._td.style.borderRight = "1px solid " + this._editor.inactiveBorderColor;
      this._td.style.borderTop = "1px solid " + this._editor.inactiveBorderColor;
      this._td.style.borderBottom = "1px solid " + this._editor.activeBorderColor;
      this._td.style.color = this._editor.inactiveColor;
      this._td.style.backgroundColor = this._editor.inactiveBackgroundColor;
      this._td.style.borderTopLeftRadius = "3px";
      this._td.style.borderTopRightRadius = "3px";
      this._td.style.paddingLeft = "5px";
      this._td.style.paddingRight = "5px";
      this._realTab = true;
      this._tabLabel = document.createElement("ANCHOR");
      this._tabLabel.innerText = label;
      this._tabLabel.addEventListener("click", () => {
        this._editor.tabSelected(this);
      });
      this._tabLabel.addEventListener("keyup", (e) => {
        if (e.key === "Enter" || e.key === " ")
          this._editor.tabSelected(this);
      });
      this._tabLabel.style.cursor = "pointer";
      this._td.appendChild(this._tabLabel);
    } else {
      this._td.style.borderBottom = "1px solid " + this._editor.activeBorderColor;
      this._td.innerHTML = "<span>&nbsp;</span>";
    }
  }
  setTabIndex(index) {
    this._tabLabel.tabIndex = index++;
    return index;
  }
  set active(value) {
    if (!this._realTab)
      return;
    this._td.style.borderLeftColor = value ? this._editor.activeBorderColor : this._editor.inactiveBorderColor;
    this._td.style.borderTopColor = value ? this._editor.activeBorderColor : this._editor.inactiveBorderColor;
    this._td.style.borderRightColor = value ? this._editor.activeBorderColor : this._editor.inactiveBorderColor;
    this._td.style.borderBottomColor = value ? "rgba(0, 0, 0, 0)" : this._editor.activeBorderColor;
    this._td.style.color = value ? this._editor.activeColor : this._editor.inactiveColor;
    this._td.style.backgroundColor = value ? this._editor.activeBackgroundColor : this._editor.inactiveBackgroundColor;
    this._div.style.display = value ? "" : "none";
  }
  get active() {
    return this._div.style.display == "";
  }
  get tabElement() {
    return this._td;
  }
  get divElement() {
    return this._div;
  }
};
var ColorEditorSroll = class {
  setTabIndex(index) {
    this._anchor.tabIndex = index++;
    this._input.tabIndex = index++;
    return index;
  }
  constructor(div, anchor, input, colorCallback, changeCallBack, checkerBoardBg, value) {
    this._value = 0;
    this._colorCallback = colorCallback;
    this._changeCallBack = changeCallBack;
    this._value = value;
    this._div = div;
    let s = ColorEditorSroll.scrollHeight;
    if (checkerBoardBg)
      this._div.style.background = "url('data:image/svg+xml;utf8," + ColorSampler.checkerboardImage(s, s) + "')";
    this._anchor = anchor;
    this._input = input;
    this._input.size = 3;
    this._input.maxLength = 3;
    this._input.type = "number";
    this._input.min = "0";
    this._input.max = "255";
    this._input.style.fontSize = (12 * constants.guiDPIFactor).toString() + "px";
    this._input.style.textAlign = "right";
    this._input.value = this._value.toString();
    this._input.style.marginLeft = "10px";
    this._div.style.width = "100%";
    this._div.style.position = "relative";
    this._div.style.height = ColorEditorSroll.scrollHeight.toString() + "px";
    this._div.style.border = "1px solid black";
    this._canvasBg = document.createElement("CANVAS");
    this._div.appendChild(this._canvasBg);
    this._canvasBg.style.left = "0px";
    this._canvasBg.style.top = "0px";
    this._canvasBg.style.width = "100%";
    this._canvasBg.style.height = "100%";
    this._canvasBg.width = 256;
    this._canvasBg.height = ColorEditorSroll.scrollHeight;
    this._canvasCursor = document.createElement("CANVAS");
    this._div.appendChild(this._canvasCursor);
    this._canvasCursor.style.position = "absolute";
    this._canvasCursor.style.width = "100%";
    this._canvasCursor.style.height = "100%";
    this._canvasCursor.style.left = "0px";
    this._canvasCursor.style.top = "0px";
    this._canvasCursor.style.display = "block";
    this._div.addEventListener("mousedown", (e) => {
      this.MouseDown(this._div, e);
    });
    this._div.addEventListener("mousemove", (e) => {
      this.MouseMove(this._div, e);
    });
    this._anchor.addEventListener("wheel", (e) => {
      this.mouseWheelEvent(this._div, e);
    });
    this._anchor.addEventListener("keydown", (e) => {
      this.KeyDown(this._div, e);
    });
    this._input.addEventListener("keyup", (e) => {
      this.inputKeyUp();
    });
    this._input.addEventListener("change", (e) => {
      this.inputKeyUp();
    });
    this._anchor.tabIndex = 4;
  }
  get value() {
    return this._value;
  }
  set value(v) {
    if (v < 0)
      v = 0;
    if (v > 255)
      v = 255;
    this._value = v;
    this._input.value = this._value.toString();
  }
  inputKeyUp() {
    let value = parseInt(this._input.value);
    if (isNaN(value))
      return;
    if (value < 0)
      value = 0;
    if (value > 255)
      value = 255;
    this._value = value;
    this.refresh();
    this._changeCallBack(this);
  }
  TouchStart(div, e) {
    if (e.touches.length == 1)
      this.handleMouseStartCapture(div, e.touches[0].clientX, e.touches[0].clientY);
  }
  TouchCaptureRun(div, e) {
    if (e.touches.length == 1)
      this.handleMouseRun(div, e.touches[0].clientX, e.touches[0].clientY);
  }
  TouchCaptureEnd(div, e) {
  }
  MouseDown(sender, e) {
    if (e.buttons != 1)
      return;
    this.handleMouseStartCapture(sender, e.clientX, e.clientY);
  }
  handleMouseStartCapture(sender, x, y) {
    let SenderRect = sender.getBoundingClientRect();
    let eX = Math.round(x - SenderRect.left);
    let index = Math.round(256 * eX / this._div.offsetWidth) >> 0;
    if (index < 0)
      index = 0;
    if (index > 255)
      index = 255;
    this._value = index;
    this._input.value = index.toString();
    this.refresh();
    this._changeCallBack(this);
  }
  MouseMove(sender, e) {
    if (e.buttons != 1)
      return;
    this.handleMouseRun(sender, e.clientX, e.clientY);
  }
  handleMouseRun(sender, x, y) {
    let SenderRect = sender.getBoundingClientRect();
    let eX = Math.round(x - SenderRect.left);
    let index = Math.round(256 * eX / this._div.offsetWidth) >> 0;
    if (index < 0)
      index = 0;
    if (index > 255)
      index = 255;
    this._value = index;
    this._input.value = index.toString();
    this.refresh();
    this._changeCallBack(this);
  }
  mouseWheelEvent(sender, e) {
    this._value += e.deltaY > 0 ? -1 : 1;
    if (this._value < 0) {
      this._value = 0;
    } else if (this._value > 255) {
      this._value = 255;
    } else {
      e.preventDefault();
    }
    this._input.value = this._value.toString();
    this.refresh();
    this._changeCallBack(this);
  }
  KeyDown(sender, e) {
    if (e.code == "ArrowRight") {
      this._value++;
      if (this._value > 255)
        this._value = 255;
    }
    if (e.code == "ArrowLeft") {
      this._value--;
      if (this._value < 0)
        this._value = 0;
    }
    this._input.value = this._value.toString();
    this.refresh();
    this._changeCallBack(this);
  }
  refresh() {
    let color = this._colorCallback(this);
    let ctx = this._canvasBg.getContext("2d");
    ctx.clearRect(0, 0, this._canvasBg.width, this._canvasBg.height);
    for (let i = 0; i < 256; i++) {
      ctx.beginPath();
      ctx.moveTo(i + 0.5, 0);
      ctx.lineTo(i + 0.5, ColorEditorSroll.scrollHeight);
      ctx.strokeStyle = color[i];
      ctx.stroke();
    }
    this._canvasCursor.width = this._div.offsetWidth;
    this._canvasCursor.height = this._div.offsetHeight;
    ctx = this._canvasCursor.getContext("2d");
    let x = 0.5 + this._value / 255 * this._canvasCursor.width;
    ctx.beginPath();
    let y = 0.5;
    ctx.moveTo(x, y + 5);
    ctx.lineTo(x + 3, y);
    ctx.lineTo(x - 3, y);
    ctx.fillStyle = "black";
    ctx.strokeStyle = "white";
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
    y = this._canvasCursor.height - 0.5;
    ctx.beginPath();
    ctx.moveTo(x, y - 5);
    ctx.lineTo(x + 3, y);
    ctx.lineTo(x - 3, y);
    ctx.fillStyle = "black";
    ctx.strokeStyle = "white";
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
  }
};
ColorEditorSroll.scrollHeight = 26 * constants.guiDPIFactor;
var ColorSampler = class {
  setTabIndex(index) {
    this._colorDiv.tabIndex = index++;
    return index;
  }
  static checkerboardImage(width, height) {
    let halfWidth = width >> 1;
    let halfHeight = height >> 1;
    return '<svg xmlns="http://www.w3.org/2000/svg"   viewbox="0 0 ' + width + " " + height + '" width="' + width + 'px"  height="' + height + 'px" ><rect x="0" y="0" width="' + width + '" height="' + height + '" style="fill:white"/><rect x="0" y="0" width="' + halfWidth + '" height="' + halfHeight + '" style="fill:black"/><rect x="' + halfWidth + '" y="' + halfHeight + '" width="' + halfWidth + '" height="' + halfHeight + '" style="fill:black"/></svg>';
  }
  constructor(containerDiv, selectCallback) {
    this._containerDiv = containerDiv;
    this._selectCallback = selectCallback;
    this._containerDiv.style.border = "1px solid grey";
    this._containerDiv.style.background = "url('data:image/svg+xml;utf8," + ColorSampler.checkerboardImage(100, 100) + "')";
    this._containerDiv.style.backgroundSize = "cover";
    this._containerDiv.style.backgroundPosition = "center";
    this._containerDiv.style.backgroundRepeat = "no-repeat";
    this._color = YColor.Transparent;
    this._colorDiv = document.createElement("DIV");
    this._colorDiv.style.display = "display-block";
    this._colorDiv.style.position = "relative";
    this._colorDiv.style.width = "100%";
    this._colorDiv.style.height = "100%";
    this._colorDiv.style.backgroundColor = "rgba(0,0,0,0)";
    this._containerDiv.appendChild(this._colorDiv);
    if (this._selectCallback != null) {
      this._colorDiv.addEventListener("click", () => {
        this._selectCallback(this.color);
      });
      this._colorDiv.addEventListener("keyup", (e) => {
        if (e.key === "Enter" || e.key === " ")
          this._selectCallback(this.color);
      });
      this._colorDiv.style.cursor = "pointer";
    }
  }
  set color(value) {
    this._color = value.clone();
    this._colorDiv.style.backgroundColor = this._color.htmlCode;
  }
  get color() {
    return this._color.clone();
  }
};
var colorEditor = class {
  static AddColorToHistory(c) {
    for (let i = 0; i < colorEditor._colorHistory.length; i++) {
      if (c.equal(colorEditor._colorHistory[i]))
        return;
    }
    colorEditor._colorHistory.splice(colorEditor._colorHistory.length - 1, 1);
    colorEditor._colorHistory.splice(0, 0, c);
    for (let i = colorEditor._editorsList.length - 1; i >= 0; i--) {
      colorEditor._editorsList[i].refreshColorHistory();
    }
  }
  static get colorHistory() {
    return colorEditor._colorHistory;
  }
  get activeBorderColor() {
    return "#767676";
  }
  get inactiveBorderColor() {
    return "#b0b0b0";
  }
  get activeColor() {
    return "black";
  }
  get inactiveColor() {
    return "grey";
  }
  get activeBackgroundColor() {
    return "white";
  }
  get inactiveBackgroundColor() {
    return "#f8f8f8";
  }
  tabSelected(source) {
    if (source == this._tabRGB) {
      this._tabRGB.active = true;
      this._rgb_R_editor.refresh();
      this._rgb_G_editor.refresh();
      this._rgb_B_editor.refresh();
      this._rgb_T_editor.refresh();
    } else {
      this._tabRGB.active = false;
    }
    if (source == this._tabHSL) {
      this._tabHSL.active = true;
      this._hsl_H_editor.refresh();
      this._hsl_S_editor.refresh();
      this._hsl_L_editor.refresh();
      this._hsl_T_editor.refresh();
    } else {
      this._tabHSL.active = false;
    }
    this._tabPredef.active = source == this._tabPredef;
  }
  HueScrollBg() {
    let s = 100;
    let l = 50;
    let t = this._hsl_T_editor.value / 255;
    let res = new Array(256);
    for (let i = 0; i < 256; i++) {
      res[i] = "hsl(" + (360 * i / 256).toString() + "," + s.toString() + "%," + l.toString() + "%)";
    }
    return res;
  }
  SaturationScrollBg() {
    let h = 360 * this._hsl_H_editor.value / 256;
    let l = 100 * this._hsl_L_editor.value / 255;
    let t = this._hsl_T_editor.value / 255;
    let res = new Array(256);
    for (let i = 0; i < 256; i++) {
      res[i] = "hsl(" + h.toString() + "," + (100 * i / 255).toString() + "%," + l.toString() + "%)";
    }
    return res;
  }
  LuminosityScrollBg() {
    let h = 360 * this._hsl_H_editor.value / 256;
    let s = 100 * this._hsl_S_editor.value / 255;
    let t = this._hsl_T_editor.value / 255;
    let res = new Array(256);
    for (let i = 0; i < 256; i++) {
      res[i] = "hsl(" + h.toString() + "," + s.toString() + "%," + (100 * i / 255).toString() + "%)";
    }
    return res;
  }
  HSLTranspScrollBg() {
    let h = 360 * this._hsl_H_editor.value / 256;
    let s = 100 * this._hsl_S_editor.value / 255;
    let l = 100 * this._hsl_L_editor.value / 255;
    let res = new Array(256);
    for (let i = 0; i < 256; i++) {
      res[i] = "hsla(" + h.toString() + "," + l.toString() + "%," + s.toString() + "%," + (i / 255).toString() + ")";
    }
    return res;
  }
  RedScrollBg() {
    let g = this._rgb_G_editor.value;
    let b = this._rgb_B_editor.value;
    let t = this._rgb_T_editor.value / 255;
    let res = new Array(256);
    for (let i = 0; i < 256; i++) {
      res[i] = "rgb(" + i.toString() + "," + g.toString() + "," + b.toString() + ")";
    }
    return res;
  }
  GreenScrollBg() {
    let r = this._rgb_R_editor.value;
    let b = this._rgb_B_editor.value;
    let t = this._rgb_T_editor.value / 255;
    let res = new Array(256);
    for (let i = 0; i < 256; i++) {
      res[i] = "rgb(" + r.toString() + "," + i.toString() + "," + b.toString() + ")";
    }
    return res;
  }
  BlueScrollBg() {
    let r = this._rgb_R_editor.value;
    let g = this._rgb_G_editor.value;
    let t = this._rgb_T_editor.value / 255;
    let res = new Array(256);
    for (let i = 0; i < 256; i++) {
      res[i] = "rgb(" + r.toString() + "," + g.toString() + "," + i.toString() + ")";
    }
    return res;
  }
  RGBTranspScrollBg() {
    let r = this._rgb_R_editor.value;
    let g = this._rgb_G_editor.value;
    let b = this._rgb_B_editor.value;
    let res = new Array(256);
    for (let i = 0; i < 256; i++) {
      res[i] = "rgba(" + r.toString() + "," + g.toString() + "," + b.toString() + "," + (i / 255).toString() + ")";
    }
    return res;
  }
  static defaultColorHistory() {
    let defaultHistory = [];
    defaultHistory.push(YColor.FromAhsl(100, 0, 0, 0));
    defaultHistory.push(YColor.FromAhsl(100, 0, 0, 51));
    defaultHistory.push(YColor.FromAhsl(100, 0, 0, 102));
    defaultHistory.push(YColor.FromAhsl(100, 0, 0, 153));
    defaultHistory.push(YColor.FromAhsl(100, 0, 0, 204));
    defaultHistory.push(YColor.FromAhsl(100, 0, 0, 255));
    defaultHistory.push(YColor.FromAhsl(100, 0, 255, 127));
    defaultHistory.push(YColor.FromAhsl(100, 42, 255, 127));
    defaultHistory.push(YColor.FromAhsl(100, 85, 255, 127));
    defaultHistory.push(YColor.FromAhsl(100, 96, 255, 127));
    defaultHistory.push(YColor.FromAhsl(100, 127, 255, 127));
    defaultHistory.push(YColor.FromAhsl(100, 170, 255, 127));
    defaultHistory.push(YColor.FromAhsl(100, 192, 255, 127));
    defaultHistory.push(YColor.FromAhsl(100, 212, 255, 127));
    defaultHistory.push(YColor.FromAhsl(255, 226, 217, 214));
    return defaultHistory;
  }
  destroy() {
    for (let i = colorEditor._editorsList.length - 1; i >= 0; i--) {
      if (colorEditor._editorsList[i] == this) {
        colorEditor._editorsList.splice(i, 1);
      }
    }
  }
  refreshColorHistory() {
    for (let i = 0; i < this._samples.length; i++) {
      if (i < colorEditor._colorHistory.length) {
        this._samples[i].color = colorEditor._colorHistory[i].clone();
      }
    }
  }
  constructor(container, fontSize, initialColor, colorChangeCallback) {
    this._firstTabIndex = 0;
    this._memorizeTimer = null;
    colorEditor._editorsList.push(this);
    this._colorChangeCallback = colorChangeCallback;
    this._container = container;
    this._table = document.createElement("TABLE");
    this._table.style.width = "100%";
    this._table.style.borderSpacing = "0";
    this._table.style.paddingLeft = "5px";
    this._table.style.paddingTop = "5px";
    this._table.style.paddingRight = "5px";
    this._table.style.borderCollapse = "separate";
    this._tr1 = document.createElement("TR");
    this._tr2 = document.createElement("TR");
    this._tabRGB = new ColorEditorTab(this, "RGB", fontSize);
    this._tabHSL = new ColorEditorTab(this, "HSL", fontSize);
    this._tabPredef = new ColorEditorTab(this, "Predefined", fontSize);
    this._tabStub = new ColorEditorTab(this, "", fontSize);
    this._contents = document.createElement("TD");
    this._contents.colSpan = 4;
    this._contents.style.borderLeft = "1px solid " + this.activeBorderColor;
    this._contents.style.borderRight = "1px solid " + this.activeBorderColor;
    this._contents.style.borderBottom = "1px solid " + this.activeBorderColor;
    this._contents.style.backgroundColor = this.activeBackgroundColor;
    this._tr1.appendChild(this._tabRGB.tabElement);
    this._tr1.appendChild(this._tabHSL.tabElement);
    this._tr1.appendChild(this._tabPredef.tabElement);
    this._tr1.appendChild(this._tabStub.tabElement);
    this._tr2.appendChild(this._contents);
    this._table.appendChild(this._tr1);
    this._table.appendChild(this._tr2);
    this._contents.appendChild(this._tabRGB.divElement);
    this._contents.appendChild(this._tabHSL.divElement);
    this._contents.appendChild(this._tabPredef.divElement);
    let RGBtable = document.createElement("TABLE");
    RGBtable.style.width = "100%";
    RGBtable.style.borderSpacing = "1";
    this._tabRGB.divElement.appendChild(RGBtable);
    let HSLtable = document.createElement("TABLE");
    HSLtable.style.width = "100%";
    HSLtable.style.borderSpacing = "1";
    this._tabHSL.divElement.appendChild(HSLtable);
    let predefTable = document.createElement("TABLE");
    this._tabPredef.divElement.appendChild(predefTable);
    predefTable.style.width = "100%";
    predefTable.style.borderSpacing = "1";
    predefTable.style.tableLayout = "fixed";
    this._container.appendChild(this._table);
    this._rgb_R_editor = this.AddColorScroll(RGBtable, "R", () => {
      return this.RedScrollBg();
    }, (src) => {
      this.RgbColorChangeCallBack(src);
    }, false, 1);
    this._rgb_G_editor = this.AddColorScroll(RGBtable, "G", () => {
      return this.GreenScrollBg();
    }, (src) => {
      this.RgbColorChangeCallBack(src);
    }, false, 2);
    this._rgb_B_editor = this.AddColorScroll(RGBtable, "B", () => {
      return this.BlueScrollBg();
    }, (src) => {
      this.RgbColorChangeCallBack(src);
    }, false, 3);
    this._rgb_T_editor = this.AddColorScroll(RGBtable, "T", () => {
      return this.RGBTranspScrollBg();
    }, (src) => {
      this.RgbColorChangeCallBack(src);
    }, true, 3);
    this._rgb_R_editor.value = initialColor.red;
    this._rgb_G_editor.value = initialColor.green;
    this._rgb_B_editor.value = initialColor.blue;
    this._rgb_T_editor.value = initialColor.alpha;
    this._rgb_R_editor.refresh();
    this._rgb_G_editor.refresh();
    this._rgb_B_editor.refresh();
    this._rgb_T_editor.refresh();
    this._hsl_H_editor = this.AddColorScroll(HSLtable, "H", () => {
      return this.HueScrollBg();
    }, (src) => {
      this.HslColorChangeCallBack(src);
    }, false, 1);
    this._hsl_S_editor = this.AddColorScroll(HSLtable, "S", () => {
      return this.SaturationScrollBg();
    }, (src) => {
      this.HslColorChangeCallBack(src);
    }, false, 2);
    this._hsl_L_editor = this.AddColorScroll(HSLtable, "L", () => {
      return this.LuminosityScrollBg();
    }, (src) => {
      this.HslColorChangeCallBack(src);
    }, false, 3);
    this._hsl_T_editor = this.AddColorScroll(HSLtable, "T", () => {
      return this.HSLTranspScrollBg();
    }, (src) => {
      this.HslColorChangeCallBack(src);
    }, true, 3);
    this._hsl_H_editor.value = initialColor.hue;
    this._hsl_S_editor.value = initialColor.saturation;
    this._hsl_L_editor.value = initialColor.luminosity;
    this._hsl_T_editor.value = initialColor.alpha;
    this._hsl_H_editor.refresh();
    this._hsl_S_editor.refresh();
    this._hsl_L_editor.refresh();
    this._hsl_T_editor.refresh();
    let samplesTable = document.createElement("TABLE");
    samplesTable.style.position = "relative";
    samplesTable.style.width = "100%";
    samplesTable.style.paddingLeft = "3px";
    samplesTable.style.paddingRight = "3px";
    samplesTable.style.paddingTop = "10px";
    samplesTable.style.bottom = "3px";
    samplesTable.style.tableLayout = "fixed";
    let samplesTD = [];
    let previewTD = null;
    let sampleHeight = 30;
    let sampletr1 = document.createElement("TR");
    sampletr1.style.height = sampleHeight.toString() + "px";
    for (let i = 0; i < 6; i++) {
      let td = document.createElement("TD");
      if (i == 5) {
        td.colSpan = 2;
        td.rowSpan = 3;
        previewTD = td;
      } else {
        samplesTD.push(td);
      }
      sampletr1.appendChild(td);
    }
    samplesTable.appendChild(sampletr1);
    let sampletr2 = document.createElement("TR");
    sampletr2.style.height = sampleHeight.toString() + "px";
    for (let i = 0; i < 5; i++) {
      let td = document.createElement("TD");
      samplesTD.push(td);
      sampletr2.appendChild(td);
    }
    samplesTable.appendChild(sampletr2);
    let sampletr3 = document.createElement("TR");
    sampletr3.style.height = sampleHeight.toString() + "px";
    for (let i = 0; i < 5; i++) {
      let td = document.createElement("TD");
      samplesTD.push(td);
      sampletr3.appendChild(td);
    }
    samplesTable.appendChild(sampletr3);
    this._container.appendChild(samplesTable);
    this._samples = [];
    for (let i = 0; i < samplesTD.length; i++) {
      let div2 = document.createElement("DIV");
      div2.style.position = "relative";
      div2.style.width = "100%";
      div2.style.height = (sampleHeight - 4).toString() + "px";
      div2.style.display = "inline-block";
      div2.title = "Color history";
      samplesTD[i].appendChild(div2);
      let sampler = new ColorSampler(div2, (c) => {
        this.sampleWasSelectedCallback(c);
      });
      sampler.color = colorEditor._colorHistory[i];
      this._samples.push(sampler);
    }
    let prefinedColors = YColor.predefinedColors;
    let colors = [];
    let predefinedColorNames = Object.keys(prefinedColors);
    for (let i = 0; i < predefinedColorNames.length; i++) {
      colors.push(prefinedColors[predefinedColorNames[i]]);
    }
    colors.sort((c1, c2) => {
      if (c1.alpha < c2.alpha)
        return 1;
      if (c1.alpha > c2.alpha)
        return -1;
      if (c1.luminosity < c2.luminosity)
        return 1;
      if (c1.luminosity > c2.luminosity)
        return -1;
      if (c1.saturation < c2.saturation)
        return 1;
      if (c1.saturation > c2.saturation)
        return -1;
      if (c1.hue < c2.hue)
        return 1;
      if (c1.hue > c2.hue)
        return -1;
      return 0;
    });
    let currenTR = null;
    this._prefedDivs = [];
    for (let i = 0; i < colors.length; i++) {
      let c = colors[i];
      if (i % 16 == 0) {
        currenTR = document.createElement("TR");
        predefTable.appendChild(currenTR);
      }
      let td = document.createElement("TD");
      currenTR.appendChild(td);
      let div2 = document.createElement("DIV");
      this._prefedDivs.push(div2);
      div2.style.position = "relative";
      div2.style.width = "100%";
      div2.style.height = Math.round(10 * constants.guiDPIFactor).toString() + "px";
      div2.style.display = "inline-block";
      div2.title = c.name;
      td.appendChild(div2);
      let sampler = new ColorSampler(div2, (c2) => {
        this.sampleWasSelectedCallback(c2);
      });
      sampler.color = c;
    }
    let div = document.createElement("DIV");
    div.style.position = "relative";
    div.style.width = "100%";
    div.style.height = (3 * sampleHeight).toString() + "px";
    div.style.display = "inline-block";
    div.title = "Color preview";
    previewTD.appendChild(div);
    this._preview = new ColorSampler(div, null);
    this._preview.color = initialColor;
    this.selectApropriateTab(initialColor);
  }
  selectApropriateTab(color) {
    if (color.isPredefined) {
      this._tabPredef.active = true;
      this.tabSelected(this._tabPredef);
    } else {
      this._tabPredef.active = false;
      if (color.isRGB) {
        this._tabRGB.active = true;
        this._tabHSL.active = false;
        this.tabSelected(this._tabRGB);
      } else {
        this._tabRGB.active = false;
        this._tabHSL.active = true;
        this.tabSelected(this._tabHSL);
      }
    }
  }
  sampleWasSelectedCallback(color) {
    this._rgb_R_editor.value = color.red;
    this._rgb_G_editor.value = color.green;
    this._rgb_B_editor.value = color.blue;
    this._rgb_T_editor.value = color.alpha;
    this._hsl_H_editor.value = color.hue;
    this._hsl_S_editor.value = color.saturation;
    this._hsl_L_editor.value = color.luminosity;
    this._hsl_T_editor.value = color.alpha;
    this._preview.color = color;
    this._rgb_R_editor.refresh();
    this._rgb_G_editor.refresh();
    this._rgb_B_editor.refresh();
    this._rgb_T_editor.refresh();
    this._hsl_H_editor.refresh();
    this._hsl_S_editor.refresh();
    this._hsl_L_editor.refresh();
    this._hsl_T_editor.refresh();
    this.initColorMemorization(color);
    if (this._colorChangeCallback != null)
      this._colorChangeCallback(color);
  }
  initColorMemorization(color) {
    if (this._memorizeTimer != null)
      clearTimeout(this._memorizeTimer);
    this._memorizeTimer = setTimeout(() => {
      this._memorizeTimer = null;
      colorEditor.AddColorToHistory(color);
    }, 2e3);
  }
  RgbColorChangeCallBack(src) {
    if (src != this._rgb_R_editor)
      this._rgb_R_editor.refresh();
    if (src != this._rgb_G_editor)
      this._rgb_G_editor.refresh();
    if (src != this._rgb_B_editor)
      this._rgb_B_editor.refresh();
    if (src != this._rgb_T_editor)
      this._rgb_T_editor.refresh();
    let color = YColor.FromArgb(this._rgb_T_editor.value, this._rgb_R_editor.value, this._rgb_G_editor.value, this._rgb_B_editor.value);
    this._preview.color = color;
    this.initColorMemorization(color);
    if (this._colorChangeCallback != null)
      this._colorChangeCallback(color);
  }
  HslColorChangeCallBack(src) {
    if (src != this._hsl_H_editor)
      this._hsl_H_editor.refresh();
    if (src != this._hsl_S_editor)
      this._hsl_S_editor.refresh();
    if (src != this._hsl_L_editor)
      this._hsl_L_editor.refresh();
    if (src != this._hsl_T_editor)
      this._hsl_T_editor.refresh();
    let color = YColor.FromAhsl(this._hsl_T_editor.value, this._hsl_H_editor.value, this._hsl_S_editor.value, this._hsl_L_editor.value);
    this._preview.color = color;
    this.initColorMemorization(color);
    if (this._colorChangeCallback != null)
      this._colorChangeCallback(color);
  }
  set color(color) {
    this._preview.color = color;
    this._hsl_H_editor.value = color.hue;
    this._hsl_S_editor.value = color.saturation;
    this._hsl_L_editor.value = color.luminosity;
    this._hsl_T_editor.value = color.alpha;
    this._rgb_R_editor.value = color.red;
    this._rgb_G_editor.value = color.green;
    this._rgb_B_editor.value = color.blue;
    this._rgb_T_editor.value = color.alpha;
    this._hsl_H_editor.refresh();
    this._hsl_S_editor.refresh();
    this._hsl_L_editor.refresh();
    this._hsl_T_editor.refresh();
    this._rgb_R_editor.refresh();
    this._rgb_G_editor.refresh();
    this._rgb_B_editor.refresh();
    this._rgb_T_editor.refresh();
    this.selectApropriateTab(color);
  }
  AddColorScroll(container, label, colorCallback, changeCallBack, checkerBoardBg, value) {
    let RGB_R_Row = document.createElement("TR");
    let RGB_R_Col1 = document.createElement("TD");
    RGB_R_Col1.innerHTML = "&nbsp;" + label + "&nbsp;";
    let RGB_R_Col2 = document.createElement("TD");
    let RGB_R_Anchor = document.createElement("ANCHOR");
    RGB_R_Col2.appendChild(RGB_R_Anchor);
    let RGB_R_Div = document.createElement("DIV");
    RGB_R_Col2.style.width = "100%";
    RGB_R_Anchor.appendChild(RGB_R_Div);
    let RGB_R_Col3 = document.createElement("TD");
    let RGB_R_Input = document.createElement("INPUT");
    RGB_R_Col3.appendChild(RGB_R_Input);
    RGB_R_Row.appendChild(RGB_R_Col1);
    RGB_R_Row.appendChild(RGB_R_Col2);
    RGB_R_Row.appendChild(RGB_R_Col3);
    container.appendChild(RGB_R_Row);
    return new ColorEditorSroll(RGB_R_Div, RGB_R_Anchor, RGB_R_Input, colorCallback, changeCallBack, checkerBoardBg, value);
  }
  setTabIndex(index) {
    this._firstTabIndex = index;
    index = this._tabRGB.setTabIndex(index);
    index = this._tabHSL.setTabIndex(index);
    index = this._tabPredef.setTabIndex(index);
    if (this._tabRGB.active) {
      index = this._rgb_R_editor.setTabIndex(index);
      index = this._rgb_G_editor.setTabIndex(index);
      index = this._rgb_B_editor.setTabIndex(index);
      index = this._rgb_T_editor.setTabIndex(index);
    } else if (this._tabHSL.active) {
      index = this._hsl_H_editor.setTabIndex(index);
      index = this._hsl_S_editor.setTabIndex(index);
      index = this._hsl_L_editor.setTabIndex(index);
      index = this._hsl_T_editor.setTabIndex(index);
    } else {
      for (let i = 0; i < this._prefedDivs.length; i++) {
        this._prefedDivs[i].tabIndex = index++;
      }
    }
    for (let i = 0; i < this._samples.length; i++) {
      index = this._samples[i].setTabIndex(index);
    }
    return index;
  }
};
colorEditor._colorHistory = colorEditor.defaultColorHistory();
colorEditor._editorsList = [];

// obj/full/configForm_rw.js
var configEditorTab = class {
  constructor(editor, label, fontSize, GUIcoef) {
    this._realTab = false;
    this._div = null;
    this._tabLabel = null;
    this._td = document.createElement("TD");
    if (label != "") {
      this._div = document.createElement("DIV");
      this._div.style.display = "none";
      let sz = Math.round(5 * GUIcoef).toString() + "px";
      this._div.style.padding = sz + " " + sz + " " + sz + " " + sz;
      this._td.style.paddingTop = Math.round(4 * GUIcoef).toString() + "px";
      this._td.style.fontSize = fontSize.toString() + "px";
      this._td.style.paddingBottom = Math.round(2 * GUIcoef).toString() + "px";
      this._td.tabIndex = 0;
      this._td.style.borderLeft = "1px solid " + configForm.inactiveBorderColor;
      this._td.style.borderRight = "1px solid " + configForm.inactiveBorderColor;
      this._td.style.borderTop = "1px solid " + configForm.inactiveBorderColor;
      this._td.style.borderBottom = "1px solid " + configForm.activeBorderColor;
      this._td.style.color = configForm.inactiveColor;
      this._td.style.backgroundColor = configForm.inactiveBackgroundColor;
      this._td.style.borderTopLeftRadius = Math.round(3 * GUIcoef).toString() + "px";
      this._td.style.borderTopRightRadius = Math.round(3 * GUIcoef).toString() + "px";
      this._td.style.paddingLeft = "5px";
      this._td.style.paddingRight = "5px";
      this._realTab = true;
      this._tabLabel = document.createElement("ANCHOR");
      this._tabLabel.innerText = label;
      this._tabLabel.addEventListener("click", () => {
        configForm.tabSelected(this);
      });
      this._tabLabel.addEventListener("keyup", (e) => {
        if (e.key === "Enter" || e.key === " ")
          configForm.tabSelected(this);
      });
      this._tabLabel.style.cursor = "pointer";
      this._td.appendChild(this._tabLabel);
    } else {
      this._td.style.borderBottom = "1px solid " + configForm.activeBorderColor;
      this._td.innerHTML = "<span>&nbsp;</span>";
    }
  }
  setTabIndex(index) {
    this._tabLabel.tabIndex = index++;
    return index;
  }
  set active(value) {
    if (!this._realTab)
      return;
    this._td.style.borderLeftColor = value ? configForm.activeBorderColor : configForm.inactiveBorderColor;
    this._td.style.borderTopColor = value ? configForm.activeBorderColor : configForm.inactiveBorderColor;
    this._td.style.borderRightColor = value ? configForm.activeBorderColor : configForm.inactiveBorderColor;
    this._td.style.borderBottomColor = value ? "rgba(0, 0, 0, 0)" : configForm.activeBorderColor;
    this._td.style.color = value ? configForm.activeColor : configForm.inactiveColor;
    this._td.style.backgroundColor = value ? configForm.activeBackgroundColor : configForm.inactiveBackgroundColor;
    this._div.style.display = value ? "" : "none";
  }
  get tabElement() {
    return this._td;
  }
  get divElement() {
    return this._div;
  }
};
var configForm = class {
  static get activeBorderColor() {
    return constants.WindowInnerBorderColor;
  }
  static get inactiveBorderColor() {
    return "#b0b0b0";
  }
  static get activeColor() {
    return "black";
  }
  static get inactiveColor() {
    return "grey";
  }
  static get activeBackgroundColor() {
    return constants.WindowInnerBackgroundColor;
  }
  static get inactiveBackgroundColor() {
    return constants.WindowBackgroundColor;
  }
  static async hubStateChanged(source) {
    if (configForm._Hubtable == null)
      return;
    let srvNotification = source.removable ? "" : " (server)";
    for (let i = 1; i < configForm._Hubtable.childElementCount; i++) {
      if (configForm._Hubtable.childNodes[i]["YHUB"] == source) {
        configForm._Hubtable.childNodes[i].childNodes[2].innerText = await source.ConnectionDescription() + srvNotification;
        switch (await source.ConnectionState()) {
          case 2:
            configForm._Hubtable.childNodes[i].childNodes[0].innerHTML = ressources.OkIcon((1.2 * configForm.fontSize).toString(), true, false, false, false, " ");
            break;
          case 3:
            configForm._Hubtable.childNodes[i].childNodes[0].innerHTML = ressources.FailedIcon((1.2 * configForm.fontSize).toString(), true, false, false, false, " ");
            break;
          default:
            configForm._Hubtable.childNodes[i].childNodes[0].innerHTML = ressources.DontKnowIcon((1.2 * configForm.fontSize).toString(), true, false, false, false, " ");
            break;
        }
      }
    }
  }
  static RefreshUI(h) {
    for (let i = 1; i < configForm._Hubtable.childElementCount; i++) {
      if (configForm._Hubtable.childNodes[i]["YHUB"] == h) {
        configForm._Hubtable.childNodes[i].childNodes[1].innerText = h.toString();
        configForm._Hubtable.childNodes[i].childNodes[2].innerText = "...";
      }
    }
  }
  static HublineSelected(source) {
    configForm._selectedHub = null;
    for (let i = 1; i < configForm._Hubtable.childElementCount; i++) {
      if (configForm._Hubtable.childNodes[i] == source) {
        configForm._selectedHub = configForm._Hubtable.childNodes[i]["YHUB"];
        configForm._Hubtable.childNodes[i].style.backgroundColor = "#2fa5ff";
        configForm._Hubtable.childNodes[i].childNodes[0].style.color = "white";
        configForm._Hubtable.childNodes[i].childNodes[1].style.color = "white";
        configForm._Hubtable.childNodes[i].childNodes[2].style.color = "white";
      } else {
        configForm._Hubtable.childNodes[i].style.backgroundColor = "white";
        configForm._Hubtable.childNodes[i].childNodes[0].style.color = "black";
        configForm._Hubtable.childNodes[i].childNodes[1].style.color = "black";
        configForm._Hubtable.childNodes[i].childNodes[2].style.color = "black";
      }
    }
    configForm._editButton.enabled = configForm._selectedHub != null;
    configForm._deleteButton.enabled = configForm._selectedHub != null;
    this._editButton.showShortcut(configForm._selectedHub != null);
    this._deleteButton.showShortcut(configForm._selectedHub != null);
  }
  static newHub() {
    HubEdit.newHub(() => {
      configForm._window.show();
    });
  }
  static async AddHubToUI(hub) {
    let HubtableTR = document.createElement("TR");
    HubtableTR.style.fontSize = configForm.fontSize.toString() + "px";
    HubtableTR["YHUB"] = hub;
    HubtableTR.style.backgroundColor = "white";
    HubtableTR.style.cursor = "pointer";
    HubtableTR.tabIndex = 0;
    HubtableTR.addEventListener("keypress", (e) => {
      switch (e.key.toUpperCase()) {
        case "D":
          this._deleteButton.performAction();
          break;
        case "E":
          this._editButton.performAction();
          break;
      }
    });
    HubtableTR.style.outline = "none";
    HubtableTR.addEventListener("click", () => {
      configForm.HublineSelected(HubtableTR);
    });
    HubtableTR.addEventListener("focusin", () => {
      configForm.HublineSelected(HubtableTR);
    });
    let HubtableTD = document.createElement("TD");
    switch (await hub.ConnectionState()) {
      case 2:
        HubtableTD.innerHTML = ressources.OkIcon((1.2 * configForm.fontSize).toString(), true, false, false, false, " ");
        break;
      case 3:
        HubtableTD.innerHTML = ressources.FailedIcon((1.2 * configForm.fontSize).toString(), true, false, false, false, " ");
        break;
      case 1:
      default:
        HubtableTD.innerHTML = ressources.DontKnowIcon((1.2 * configForm.fontSize).toString(), true, false, false, false, " ");
    }
    HubtableTD.style.width = (2 * configForm.fontSize).toString() + "px";
    HubtableTD.style.verticalAlign = "center";
    HubtableTD.style.borderBottom = "1px solid " + configForm.inactiveBorderColor;
    HubtableTD.style.paddingLeft = "5px";
    HubtableTR.appendChild(HubtableTD);
    HubtableTD = document.createElement("TD");
    HubtableTD.innerText = hub.toString();
    HubtableTD.style.borderBottom = "1px solid " + configForm.inactiveBorderColor;
    HubtableTD.style.verticalAlign = "center";
    HubtableTD.style.height = (2 * configForm.fontSize).toString() + "px";
    HubtableTR.appendChild(HubtableTD);
    HubtableTD = document.createElement("TD");
    HubtableTD.style.verticalAlign = "center";
    HubtableTD.style.whiteSpace = "nowrap";
    HubtableTD.innerText = await hub.ConnectionDescription() + (hub.removable ? "" : " (server)");
    HubtableTD.style.borderBottom = "1px solid " + configForm.inactiveBorderColor;
    HubtableTR.appendChild(HubtableTD);
    configForm._Hubtable.appendChild(HubtableTR);
  }
  static editSelectedHub() {
    if (configForm._selectedHub == null)
      return;
    HubEdit.editHub(configForm._selectedHub, () => {
      configForm._window.show();
    });
  }
  static deleteSelectedHub() {
    if (configForm._selectedHub == null)
      return;
    let ExtraMessage = configForm._selectedHub.removable ? "" : "\n\nThis one is also the one serving the Yocto-Visualization software. If you remove it, you won't be able to save later on.";
    confirm.ask("Do you really want to remove connection " + configForm._selectedHub.toString() + " ?" + ExtraMessage, () => {
      if (configForm._selectedHub == null)
        return;
      configForm._selectedHub.Disconnect().then((r) => {
      });
      for (let i = configForm._Hubtable.childElementCount - 1; i > 0; i--) {
        if (configForm._Hubtable.childNodes[i]["YHUB"] == configForm._selectedHub) {
          configForm._Hubtable.removeChild(configForm._Hubtable.childNodes[i]);
        }
      }
      sensorsManager.hubWasremoved(configForm._selectedHub);
      configForm._selectedHub = null;
      configForm._editButton.enabled = false;
      configForm._deleteButton.enabled = false;
      constants.edited = true;
    }, null, null);
  }
  static hide() {
    if (configForm._window == null)
      return;
    configForm._window.visible = false;
  }
  static show() {
    if (configForm._window == null) {
      configForm.GUIcoef = constants.generalSizeCoef;
      if (configForm.REFWIDH * configForm.GUIcoef > screen.width)
        configForm.GUIcoef = screen.width / configForm.REFWIDH;
      if (configForm.REFHEIGHT * configForm.GUIcoef > screen.height)
        configForm.GUIcoef = screen.height / configForm.REFHEIGHT;
      configForm.fontSize *= configForm.GUIcoef / constants.generalSizeCoef;
      let params = new newWindowParam(configForm.GUIcoef);
      params.positionType = 1;
      params.width = Math.round(configForm.REFWIDH * this.GUIcoef);
      params.height = Math.round(configForm.REFHEIGHT * this.GUIcoef);
      params.showContainerBorders = false;
      params.title = "Global configuration";
      configForm._window = new YWindow(params);
      configForm._contents = configForm._window.innerContentDiv;
      configForm._table = document.createElement("TABLE");
      configForm._contents.appendChild(configForm._table);
      configForm._table.style.position = "absolute";
      configForm._table.style.left = "0px";
      configForm._table.style.right = "0px";
      configForm._table.style.width = "100%";
      configForm._table.style.height = "100%";
      configForm._table.style.borderSpacing = "0";
      configForm._table.style.paddingLeft = (5 * this.GUIcoef).toString() + "px";
      configForm._table.style.paddingTop = (5 * this.GUIcoef).toString() + "px";
      configForm._table.style.paddingRight = (5 * this.GUIcoef).toString() + "px";
      configForm._table.style.borderCollapse = "separate";
      configForm._tr1 = document.createElement("TR");
      configForm._tr2 = document.createElement("TR");
      configForm._tr1.style.height = (2 * configForm.fontSize).toString() + "px";
      configForm._tabNetwork = new configEditorTab(configForm, "Network", configForm.fontSize, configForm.GUIcoef);
      configForm._tabCapture = new configEditorTab(configForm, "Screen capture", configForm.fontSize, configForm.GUIcoef);
      configForm._tabResources = new configEditorTab(configForm, "Ressources", configForm.fontSize, configForm.GUIcoef);
      configForm._tabUI = new configEditorTab(configForm, "User interface", configForm.fontSize, configForm.GUIcoef);
      configForm._tabExport = new configEditorTab(configForm, "Updates & XML", configForm.fontSize, configForm.GUIcoef);
      configForm._tabStub = new configEditorTab(configForm, "", configForm.fontSize, configForm.GUIcoef);
      this._tabPanelContents = document.createElement("TD");
      this._tabPanelContents.colSpan = 6;
      this._tabPanelContents.style.borderLeft = "1px solid " + this.activeBorderColor;
      this._tabPanelContents.style.borderRight = "1px solid " + this.activeBorderColor;
      this._tabPanelContents.style.borderBottom = "1px solid " + this.activeBorderColor;
      this._tabPanelContents.style.backgroundColor = this.activeBackgroundColor;
      configForm._tr1.appendChild(this._tabNetwork.tabElement);
      configForm._tr1.appendChild(this._tabCapture.tabElement);
      configForm._tr1.appendChild(this._tabResources.tabElement);
      configForm._tr1.appendChild(this._tabUI.tabElement);
      configForm._tr1.appendChild(this._tabExport.tabElement);
      configForm._tr1.appendChild(this._tabStub.tabElement);
      configForm._tr2.appendChild(this._tabPanelContents);
      configForm._tr2.childNodes[0].style.verticalAlign = "top";
      configForm._table.appendChild(this._tr1);
      configForm._table.appendChild(this._tr2);
      let p = document.createElement("P");
      p.style.textAlign = "justify";
      p.style.fontSize = configForm.fontSize.toString() + "px";
      p.style.paddingTop = "0px";
      p.style.marginTop = Math.round(3 * this.GUIcoef).toString() + "px";
      p.innerText = "Enter the list of VirtualHub or YoctoHub this page can connect to";
      this._tabNetwork.divElement.appendChild(p);
      configForm._Hubtable = document.createElement("TABLE");
      configForm._Hubtable.style.position = "absolute";
      configForm._Hubtable.style.display = "block";
      configForm._Hubtable.style.left = Math.round(20 * this.GUIcoef).toString() + "px";
      configForm._Hubtable.style.right = Math.round(20 * this.GUIcoef).toString() + "px";
      configForm._Hubtable.style.tableLayout = "auto";
      configForm._Hubtable.style.top = Math.round(80 * this.GUIcoef).toString() + "px";
      configForm._Hubtable.style.bottom = Math.round(40 * this.GUIcoef).toString() + "px";
      configForm._Hubtable.style.borderCollapse = "colapse";
      configForm._Hubtable.style.borderSpacing = "0px";
      configForm._Hubtable.style.border = "1px solid " + configForm.activeBorderColor;
      let HubtableTR = document.createElement("TR");
      HubtableTR.style.fontSize = configForm.fontSize.toString() + "px";
      let HubtableTH = document.createElement("TH");
      HubtableTH.colSpan = 2;
      HubtableTH.innerText = "Address";
      HubtableTH.style.borderBottom = "1px solid " + configForm.activeBorderColor;
      HubtableTH.style.width = Math.round(400 * this.GUIcoef).toString() + "px";
      HubtableTR.appendChild(HubtableTH);
      HubtableTH = document.createElement("TH");
      HubtableTH.innerText = "Status";
      HubtableTH.style.width = "40%";
      HubtableTH.style.borderBottom = "1px solid " + configForm.activeBorderColor;
      HubtableTH.style.borderLeft = "1px solid " + configForm.activeBorderColor;
      HubtableTR.appendChild(HubtableTH);
      configForm._Hubtable.appendChild(HubtableTR);
      let hubList = sensorsManager.hubList;
      for (let i = 0; i < hubList.length; i++) {
        configForm.AddHubToUI(hubList[i]);
      }
      let div = document.createElement("DIV");
      div.style.position = "absolute";
      div.style.bottom = "0px";
      div.style.right = Math.round(20 * configForm.GUIcoef).toString() + "px";
      div.style.height = Math.round(30 * configForm.GUIcoef).toString() + "px";
      div.style.textAlign = "right";
      div.style.verticalAlign = "center";
      configForm._newButton = new button("New", () => {
        configForm._window.hide();
        configForm.newHub();
      }, configForm.GUIcoef);
      div.appendChild(configForm._newButton.Element);
      configForm._editButton = new button("Edit", () => {
        configForm._window.hide();
        configForm.editSelectedHub();
      }, configForm.GUIcoef);
      configForm._editButton.enabled = false;
      div.appendChild(configForm._editButton.Element);
      configForm._deleteButton = new button("Delete", () => {
        configForm.deleteSelectedHub();
      }, configForm.GUIcoef);
      configForm._deleteButton.enabled = false;
      div.appendChild(configForm._deleteButton.Element);
      this._tabNetwork.divElement.appendChild(div);
      this._tabNetwork.divElement.appendChild(configForm._Hubtable);
      p = document.createElement("P");
      p.innerHTML = "Widgets content can be captured at anytime thought the <i>Snapshop</i> option available in right-click contextual menu";
      p.style.textAlign = "justify";
      p.style.fontSize = configForm.fontSize.toString() + "px";
      this._tabCapture.divElement.appendChild(p);
      let tableSize = document.createElement("TABLE");
      tableSize.style.fontSize = configForm.fontSize.toString() + "px";
      let row = document.createElement("TR");
      let td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      td.innerText = "ImageType";
      row.appendChild(td);
      td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      td.style.verticalAlign = "center";
      configForm.inputPNG = document.createElement("INPUT");
      configForm.inputSVG = document.createElement("INPUT");
      configForm.inputPNG.checked = constants.captureType == YDataRenderer.CaptureType.PNG;
      configForm.inputPNG.style.display = "inline";
      configForm.inputPNG.type = "checkbox";
      configForm.inputPNG.style.transform = "scale(" + this.GUIcoef.toString() + ")";
      configForm.inputPNG.style.marginRight = Math.round(5 * this.GUIcoef).toString() + "px";
      configForm.inputPNG.style.marginLeft = Math.round(5 * this.GUIcoef).toString() + "px";
      configForm.inputPNG.addEventListener("change", () => {
        configForm.captureFormatChange(configForm.inputPNG);
      });
      td.append(configForm.inputPNG);
      let span;
      span = document.createElement("SPAN");
      span.innerText = YDataRenderer.CaptureType.PNG.description;
      td.append(span);
      configForm.inputSVG = document.createElement("INPUT");
      configForm.inputSVG.checked = constants.captureType == YDataRenderer.CaptureType.SVG;
      configForm.inputSVG.style.display = "inline";
      configForm.inputSVG.type = "checkbox";
      configForm.inputSVG.style.transform = "scale(" + this.GUIcoef.toString() + ")";
      configForm.inputSVG.style.marginRight = Math.round(5 * this.GUIcoef).toString() + "px";
      configForm.inputSVG.style.marginLeft = Math.round(5 * this.GUIcoef).toString() + "px";
      configForm.inputSVG.addEventListener("change", () => {
        configForm.captureFormatChange(configForm.inputSVG);
      });
      td.append(configForm.inputSVG);
      span = document.createElement("SPAN");
      span.innerText = YDataRenderer.CaptureType.SVG.description;
      td.append(span);
      row.appendChild(td);
      tableSize.appendChild(row);
      row = document.createElement("TR");
      td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      td.innerText = "Resolution:";
      row.appendChild(td);
      td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      configForm.inputResolution = document.createElement("INPUT");
      configForm.inputResolution.style.fontFamily = constants.generalFontFamily;
      configForm.inputResolution.style.fontSize = constants.generalFontSize.toString() + "px";
      configForm.inputResolution.style.border = "1px solid grey";
      configForm.inputResolution.type = "number";
      configForm.inputResolution.style.textAlign = "right";
      configForm.inputResolution.style.marginRight = "5px";
      configForm.inputResolution.style.width = "60px";
      configForm.inputResolution.value = constants.captureDPI.toString();
      configForm.inputResolution.style.display = "inline";
      new InputFieldManager(configForm.inputResolution, 6, false, Number.NaN, Number.NaN, (sender, refreshInput) => {
        configForm.captureDPIChange(configForm.inputResolution);
      });
      td.append(configForm.inputResolution);
      span = document.createElement("SPAN");
      span.innerText = "DPI";
      td.append(span);
      row.appendChild(td);
      tableSize.appendChild(row);
      row = document.createElement("TR");
      td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      td.innerText = "Size:";
      td.style.verticalAlign = "top";
      row.appendChild(td);
      td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      configForm.inputSizeSelect = document.createElement("SELECT");
      configForm.inputSizeSelect.style.border = "1px solid grey";
      configForm.inputSizeSelect.style.fontFamily = constants.generalFontFamily;
      configForm.inputSizeSelect.style.fontSize = constants.generalFontSize.toString() + "px";
      let sizingOptions = YDataRenderer.CaptureFormats.Keep.sibblings;
      for (let i = 0; i < sizingOptions.length; i++) {
        let option = document.createElement("OPTION");
        option.text = sizingOptions[i].description;
        option.value = sizingOptions[i].toString;
        configForm.inputSizeSelect.add(option, null);
      }
      configForm.inputSizeSelect.value = constants.captureSizePolicy.toString;
      configForm.inputSizeSelect.addEventListener("change", () => {
        configForm.captureSizeSelectChange(configForm.inputSizeSelect);
      });
      td.append(configForm.inputSizeSelect);
      row.appendChild(td);
      tableSize.appendChild(row);
      let subtable = document.createElement("TABLE");
      configForm.captureWidthTR = document.createElement("TR");
      let subTD = document.createElement("TD");
      subTD.style.fontSize = configForm.fontSize.toString() + "px";
      subTD.innerText = "Width:";
      configForm.captureWidthTR.appendChild(subTD);
      subTD = document.createElement("TD");
      subTD.style.fontSize = configForm.fontSize.toString() + "px";
      configForm.inputCaptureWidth = document.createElement("INPUT");
      configForm.inputCaptureWidth.style.border = "1px solid grey";
      configForm.inputCaptureWidth.style.fontFamily = constants.generalFontFamily;
      configForm.inputCaptureWidth.style.fontSize = constants.generalFontSize.toString() + "px";
      configForm.inputCaptureWidth.type = "number";
      configForm.inputCaptureWidth.style.textAlign = "right";
      configForm.inputCaptureWidth.style.marginRight = "5px";
      configForm.inputCaptureWidth.style.width = "60px";
      configForm.inputCaptureWidth.value = constants.captureWidth.toString();
      configForm.inputCaptureWidth.style.display = "inline";
      new InputFieldManager(configForm.inputCaptureWidth, 3, false, Number.NaN, Number.NaN, (sender, refreshInput) => {
        configForm.captureWidthChange(configForm.inputCaptureWidth);
      });
      subTD.append(configForm.inputCaptureWidth);
      configForm.inputCaptureWidthInfo = document.createElement("SPAN");
      configForm.inputCaptureWidthInfo.innerText = "pixels";
      subTD.append(configForm.inputCaptureWidthInfo);
      configForm.captureWidthTR.appendChild(subTD);
      subtable.appendChild(configForm.captureWidthTR);
      configForm.captureHeightTR = document.createElement("TR");
      subTD = document.createElement("TD");
      subTD.style.fontSize = configForm.fontSize.toString() + "px";
      subTD.innerText = "Height:";
      configForm.captureHeightTR.appendChild(subTD);
      subTD = document.createElement("TD");
      subTD.style.fontSize = configForm.fontSize.toString() + "px";
      configForm.inputCaptureHeight = document.createElement("INPUT");
      configForm.inputCaptureHeight.style.border = "1px solid grey";
      configForm.inputCaptureHeight.style.fontFamily = constants.generalFontFamily;
      configForm.inputCaptureHeight.style.fontSize = constants.generalFontSize.toString() + "px";
      configForm.inputCaptureHeight.type = "number";
      configForm.inputCaptureHeight.style.textAlign = "right";
      configForm.inputCaptureHeight.style.marginRight = "5px";
      configForm.inputCaptureHeight.style.width = "60px";
      configForm.inputCaptureHeight.value = constants.captureHeight.toString();
      configForm.inputCaptureHeight.style.display = "inline";
      new InputFieldManager(configForm.inputCaptureHeight, 3, false, Number.NaN, Number.NaN, (sender, refreshInput) => {
        configForm.captureHeightChange(configForm.inputCaptureHeight);
      });
      subTD.append(configForm.inputCaptureHeight);
      configForm.inputCaptureHeightInfo = document.createElement("SPAN");
      configForm.inputCaptureHeightInfo.innerText = "pixels";
      subTD.append(configForm.inputCaptureHeightInfo);
      configForm.captureHeightTR.appendChild(subTD);
      subtable.appendChild(configForm.captureHeightTR);
      td.appendChild(subtable);
      configForm._tabCapture.divElement.appendChild(tableSize);
      let tableRessources = document.createElement("TABLE");
      row = document.createElement("TR");
      td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      td.innerText = "If you plan to use YoctoVisualization continuously for an extended period of time (i.e. several weeks),  or if you are running it on a computer with limited resources, you may want to limit the application memory consumption.";
      td.colSpan = 2;
      td.style.textAlign = "justify";
      row.appendChild(td);
      tableRessources.appendChild(row);
      row = document.createElement("TR");
      td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      td.innerText = "Max count of sensors data records:";
      row.appendChild(td);
      td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      let maxSensorRecs = document.createElement("INPUT");
      maxSensorRecs.style.border = "1px solid grey";
      maxSensorRecs.style.fontFamily = constants.generalFontFamily;
      maxSensorRecs.style.fontSize = constants.generalFontSize.toString() + "px";
      maxSensorRecs.type = "number";
      maxSensorRecs.style.textAlign = "right";
      maxSensorRecs.style.marginRight = "5px";
      maxSensorRecs.style.marginLeft = "5px";
      maxSensorRecs.style.width = "60px";
      maxSensorRecs.value = constants.maxDataRecordsPerSensor.toString();
      maxSensorRecs.style.display = "inline";
      new InputFieldManager(maxSensorRecs, 2, false, Number.NaN, Number.NaN, (sender, refreshInput) => {
        configForm.maxSensorRecsChange(maxSensorRecs);
      });
      td.append(maxSensorRecs);
      span = document.createElement("SPAN");
      span.innerText = "(0 = unlimited)";
      td.append(span);
      row.appendChild(td);
      tableRessources.appendChild(row);
      row = document.createElement("TR");
      td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      td.innerText = "Max count of graph series data points:";
      row.appendChild(td);
      td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      let maxSeriesRecs = document.createElement("INPUT");
      maxSeriesRecs.style.border = "1px solid grey";
      maxSeriesRecs.style.fontFamily = constants.generalFontFamily;
      maxSeriesRecs.style.fontSize = constants.generalFontSize.toString() + "px";
      maxSeriesRecs.type = "number";
      maxSeriesRecs.style.textAlign = "right";
      maxSeriesRecs.style.marginRight = "5px";
      maxSeriesRecs.style.marginLeft = "5px";
      maxSeriesRecs.style.width = "60px";
      maxSeriesRecs.value = constants.maxPointsPerGraphSerie.toString();
      maxSeriesRecs.style.display = "inline";
      new InputFieldManager(maxSeriesRecs, 2, false, Number.NaN, Number.NaN, (sender, refreshInput) => {
        configForm.maxSeriesRecsChange(maxSeriesRecs);
      });
      td.append(maxSeriesRecs);
      span = document.createElement("SPAN");
      span.innerText = "(0 = unlimited)";
      td.append(span);
      row.appendChild(td);
      tableRessources.appendChild(row);
      row = document.createElement("TR");
      td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      td.innerText = "\nYocto-Visualization automatically loads datalogger contents for all connected devices.  If you are using networked devices featuring  billable data transfers (GSM) you may want to limit or even disable that feature.";
      td.colSpan = 2;
      td.style.textAlign = "justify";
      row.appendChild(td);
      tableRessources.appendChild(row);
      row = document.createElement("TR");
      td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      td.innerText = "Max data points/series loaded from dataloggers:";
      row.appendChild(td);
      td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      let maxDataLogRecs = document.createElement("INPUT");
      maxDataLogRecs.style.border = "1px solid grey";
      maxDataLogRecs.style.fontFamily = constants.generalFontFamily;
      maxDataLogRecs.style.fontSize = constants.generalFontSize.toString() + "px";
      maxDataLogRecs.type = "number";
      maxDataLogRecs.style.textAlign = "right";
      maxDataLogRecs.style.marginRight = "5px";
      maxDataLogRecs.style.marginLeft = "5px";
      maxDataLogRecs.style.width = "60px";
      maxDataLogRecs.value = constants.maxPointsPerDataloggerSerie.toString();
      maxDataLogRecs.style.display = "inline";
      new InputFieldManager(maxDataLogRecs, 1, false, -1, Number.NaN, (sender, refreshInput) => {
        configForm.maxDataLogRecsChange(maxDataLogRecs);
      });
      td.append(maxDataLogRecs);
      span = document.createElement("SPAN");
      span.innerText = "(0 = unlimited,\n-1 = disabled)";
      td.append(span);
      row.appendChild(td);
      tableRessources.appendChild(row);
      row = document.createElement("TR");
      td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      td.innerText = "After a  limit increase, you'll have to restart the application to get your old data back.";
      td.colSpan = 2;
      td.style.textAlign = "justify";
      row.appendChild(td);
      tableRessources.appendChild(row);
      configForm._tabResources.divElement.appendChild(tableRessources);
      p = document.createElement("P");
      p.style.fontSize = configForm.fontSize.toString() + "px";
      p.innerText = "You can alter user interface behavior according to your hardware capabilities.";
      this._tabUI.divElement.appendChild(p);
      let checkbox1 = document.createElement("INPUT");
      checkbox1.style.fontFamily = constants.generalFontFamily;
      checkbox1.style.fontSize = constants.generalFontSize.toString() + "px";
      checkbox1.style.display = "inline";
      checkbox1.type = "checkbox";
      checkbox1.style.transform = "scale(" + this.GUIcoef.toString() + ")";
      checkbox1.style.marginRight = Math.round(5 * this.GUIcoef).toString() + "px";
      checkbox1.checked = constants.dbleClickBringsUpContextMenu;
      checkbox1.addEventListener("change", () => {
        configForm.dbleClickBringsUpContextMenuChange(checkbox1);
      });
      this._tabUI.divElement.appendChild(checkbox1);
      span = document.createElement("SPAN");
      span.style.fontSize = configForm.fontSize.toString() + "px";
      span.innerText = "Double click/tap  brings up context menu\n";
      this._tabUI.divElement.appendChild(span);
      let checkbox2 = document.createElement("INPUT");
      checkbox2.style.display = "inline";
      checkbox2.type = "checkbox";
      checkbox2.style.transform = "scale(" + this.GUIcoef.toString() + ")";
      checkbox2.style.marginRight = Math.round(5 * this.GUIcoef).toString() + "px";
      checkbox2.checked = YGraph.verticalDragZoomEnabled;
      checkbox2.addEventListener("change", () => {
        configForm.verticalDragZoomChange(checkbox2);
      });
      this._tabUI.divElement.appendChild(checkbox2);
      span = document.createElement("SPAN");
      span.style.fontSize = configForm.fontSize.toString() + "px";
      span.innerText = "Graphs zoom can be driven by vertical drag\n";
      this._tabUI.divElement.appendChild(span);
      p = document.createElement("P");
      p.style.fontSize = configForm.fontSize.toString() + "px";
      p.innerText = "Yocto-Visualization tries to ajust UI size to screen resolution the best it can through a DPI based zoom factor. Unfortunately not all devices can properly report their screen resolution. That's why you can manually override that factor.";
      this._tabUI.divElement.appendChild(p);
      let DPIoverride = document.createElement("INPUT");
      let checkbox3 = document.createElement("INPUT");
      checkbox3.style.display = "inline";
      checkbox3.type = "checkbox";
      checkbox3.style.transform = "scale(" + this.GUIcoef.toString() + ")";
      checkbox3.style.marginRight = Math.round(5 * this.GUIcoef).toString() + "px";
      checkbox3.checked = constants.guiDPIFactorIsOverriden;
      checkbox3.addEventListener("change", () => {
        configForm.DPIoverrideChange(checkbox3, DPIoverride);
      });
      this._tabUI.divElement.appendChild(checkbox3);
      span = document.createElement("SPAN");
      span.style.fontSize = configForm.fontSize.toString() + "px";
      span.innerText = "Override zoom factor to ";
      this._tabUI.divElement.appendChild(span);
      DPIoverride.style.border = "1px solid grey";
      DPIoverride.style.fontFamily = constants.generalFontFamily;
      DPIoverride.style.fontSize = constants.generalFontSize.toString() + "px";
      DPIoverride.disabled = !constants.guiDPIFactorIsOverriden;
      DPIoverride.type = "number";
      DPIoverride.style.textAlign = "right";
      DPIoverride.style.marginRight = "5px";
      DPIoverride.style.marginLeft = "5px";
      DPIoverride.style.width = "60px";
      DPIoverride.value = constants.guiDPIFactorOverrideValue.toString();
      DPIoverride.style.display = "inline";
      new InputFieldManager(DPIoverride, 5, false, Number.NaN, Number.NaN, (sender, refreshInput) => {
        configForm.DPIoverrideChange(checkbox3, DPIoverride);
      });
      this._tabUI.divElement.appendChild(DPIoverride);
      p = document.createElement("P");
      p.style.fontSize = configForm.fontSize.toString() + "px";
      p.innerText = "This setting is stored in your browser cookies. So it is specific to this device, browser and server.You will have to reload this page for this setting to take effect";
      this._tabUI.divElement.appendChild(p);
      p = document.createElement("P");
      p.style.fontSize = configForm.fontSize.toString() + "px";
      p.style.textAlign = "justify";
      p.innerText = "As long as your web browser can reach www.yoctopuce.com, the read/write edition of Yocto-Visualization (for web) can automatically check for new version. If you find this feature anoying, feel free to disable it. ";
      this._tabExport.divElement.appendChild(p);
      let checkbox4 = document.createElement("INPUT");
      checkbox4.style.display = "inline";
      checkbox4.type = "checkbox";
      checkbox4.style.transform = "scale(" + this.GUIcoef.toString() + ")";
      checkbox4.style.marginLeft = Math.round(25 * this.GUIcoef).toString() + "px";
      checkbox4.checked = constants.mustCheckForUpdate;
      checkbox4.addEventListener("change", () => {
        configForm.mustCheckForUpdateChange(checkbox4);
      });
      this._tabExport.divElement.appendChild(checkbox4);
      span = document.createElement("SPAN");
      span.style.fontSize = configForm.fontSize.toString() + "px";
      span.innerText = "Automatically check for updates";
      let a2 = document.createElement("A");
      a2.innerText = "Check now";
      a2.style.paddingLeft = "25px";
      a2.style.cursor = "pointer";
      a2.style.color = "#0000EE";
      a2.style.textDecoration = "underline";
      a2.addEventListener("click", () => {
        YWebPage.CheckForNewVersion(true);
      });
      span.appendChild(a2);
      this._tabExport.divElement.appendChild(span);
      p = document.createElement("P");
      p.style.fontSize = configForm.fontSize.toString() + "px";
      p.style.textAlign = "justify";
      p.innerText = "Yocto-Visualization (for web) stores its configuration in a XML file. This file can be used to create a static web page running Yocto-Visualization (for web) or it can be used in the Yocto-Visualization (for web) installer to create a pre-configured install. Also, it is mostly compatible with the native version of Yocto-Visualization: you can use it instead of the original config.xml file. Just click on the link below to export/download your current configuration.";
      this._tabExport.divElement.appendChild(p);
      p = document.createElement("P");
      p.style.fontSize = configForm.fontSize.toString() + "px";
      p.style.textAlign = "right";
      let a = document.createElement("A");
      a.innerText = "Export current configuration";
      a.style.cursor = "pointer";
      a.style.color = "#0000EE";
      a.style.textDecoration = "underline";
      a.addEventListener("click", () => {
        configForm.downloadCurrentConfig();
      });
      p.appendChild(a);
      this._tabExport.divElement.appendChild(p);
      configForm._tabPanelContents.appendChild(this._tabNetwork.divElement);
      configForm._tabPanelContents.appendChild(this._tabCapture.divElement);
      configForm._tabPanelContents.appendChild(this._tabResources.divElement);
      configForm._tabPanelContents.appendChild(this._tabUI.divElement);
      configForm._tabPanelContents.appendChild(this._tabExport.divElement);
      configForm.tabSelected(this._tabNetwork);
      configForm.refreshSizeParams();
    }
    configForm._window.show();
  }
  static DPIoverrideChange(checkbox, input) {
    let value = parseFloat(input.value);
    input.disabled = !checkbox.checked;
    if (checkbox.checked && value > 0) {
      constants.overrideGuiDPIFactor(true, value);
    } else {
      constants.overrideGuiDPIFactor(false);
    }
  }
  static hubWasAdded(hub) {
    if (sensorsManager.newHubCreated(hub)) {
      configForm.AddHubToUI(hub);
      constants.edited = true;
      hub.Connect().then((r) => {
      });
    }
  }
  static hubGotEdited(hub) {
    configForm.RefreshUI(hub);
    constants.edited = true;
    hub.Disconnect().then((r) => {
      YAPI.Sleep(1);
      hub.Connect();
    });
  }
  static dbleClickBringsUpContextMenuChange(source) {
    let prev = constants.dbleClickBringsUpContextMenu;
    constants.dbleClickBringsUpContextMenu = source.checked;
    if (prev != constants.dbleClickBringsUpContextMenu)
      constants.edited = true;
  }
  static verticalDragZoomChange(source) {
    let prev = YGraph.verticalDragZoomEnabled;
    YGraph.verticalDragZoomEnabled = source.checked;
    if (prev != YGraph.verticalDragZoomEnabled)
      constants.edited = true;
  }
  static mustCheckForUpdateChange(source) {
    let prev = constants.mustCheckForUpdate;
    constants.mustCheckForUpdate = source.checked;
    if (prev != constants.mustCheckForUpdate)
      constants.edited = true;
  }
  static maxDataLogRecsChange(source) {
    let value = parseInt(source.value);
    if (value != constants.maxPointsPerDataloggerSerie || value != CustomYSensor.MaxLoggerRecords) {
      constants.maxPointsPerDataloggerSerie = value;
      CustomYSensor.MaxLoggerRecords = value;
      constants.edited = true;
    }
  }
  static maxSeriesRecsChange(source) {
    let value = parseInt(source.value);
    if (value != constants.maxPointsPerGraphSerie || value != DataSerie.MaxPointsPerSeries) {
      constants.maxPointsPerGraphSerie = value;
      DataSerie.MaxPointsPerSeries = value;
      constants.edited = true;
    }
  }
  static maxSensorRecsChange(source) {
    let value = parseInt(source.value);
    if (value != constants.maxDataRecordsPerSensor || value != CustomYSensor.MaxDataRecords) {
      constants.maxDataRecordsPerSensor = value;
      CustomYSensor.MaxDataRecords = value;
      constants.edited = true;
    }
  }
  static captureDPIChange(source) {
    let prev = constants.captureDPI;
    constants.captureDPI = parseInt(source.value);
    if (constants.captureDPI != prev)
      constants.edited = true;
    configForm.refreshSizeParams();
  }
  static captureWidthChange(source) {
    let prev = constants.captureWidth;
    constants.captureWidth = parseInt(source.value);
    if (constants.captureWidth != prev)
      constants.edited = true;
    configForm.refreshSizeParams();
  }
  static captureHeightChange(source) {
    let prev = constants.captureHeight;
    constants.captureHeight = parseInt(source.value);
    if (constants.captureHeight != prev)
      constants.edited = true;
    configForm.refreshSizeParams();
  }
  static captureSizeSelectChange(source) {
    let prev = constants.captureSizePolicy;
    constants.captureSizePolicy = YDataRenderer.CaptureFormats.fromString(YDataRenderer.CaptureFormats, source.value);
    if (constants.captureSizePolicy != prev)
      constants.edited = true;
    configForm.refreshSizeParams();
  }
  static refreshSizeParams() {
    let value = YDataRenderer.CaptureFormats.fromString(YDataRenderer.CaptureFormats, configForm.inputSizeSelect.value);
    if (value == YDataRenderer.CaptureFormats.Keep) {
      configForm.captureWidthTR.style.display = "none";
      configForm.captureHeightTR.style.display = "none";
    } else if (value == YDataRenderer.CaptureFormats.FixedWidth) {
      configForm.captureWidthTR.style.display = "";
      configForm.captureHeightTR.style.display = "none";
    } else if (value == YDataRenderer.CaptureFormats.FixedHeight) {
      configForm.captureWidthTR.style.display = "none";
      configForm.captureHeightTR.style.display = "";
    }
    if (value == YDataRenderer.CaptureFormats.Fixed) {
      configForm.captureWidthTR.style.display = "";
      configForm.captureHeightTR.style.display = "";
    }
    let sw = 25.4 * parseInt(configForm.inputCaptureWidth.value) / parseInt(configForm.inputResolution.value);
    configForm.inputCaptureWidthInfo.innerText = "Pixels  (" + sw.toFixed(1) + "mm)";
    let sh = 25.4 * parseInt(configForm.inputCaptureHeight.value) / parseInt(configForm.inputResolution.value);
    configForm.inputCaptureHeightInfo.innerText = "Pixels  (" + sh.toFixed(1) + "mm)";
  }
  static downloadCurrentConfig() {
    let element = document.createElement("a");
    let data = "data:text/xml;base64," + btoa(YWebPage.get_XmlData());
    element.setAttribute("href", data);
    element.setAttribute("download", "config.xml");
    element.style.display = "none";
    document.body.appendChild(element);
    element.click();
    document.body.removeChild(element);
  }
  static captureFormatChange(source) {
    if (source == configForm.inputPNG)
      configForm.inputSVG.checked = !source.checked;
    if (source == configForm.inputSVG)
      configForm.inputPNG.checked = !source.checked;
    let prev = constants.captureType;
    constants.captureType = configForm.inputPNG.checked ? YDataRenderer.CaptureType.PNG : YDataRenderer.CaptureType.SVG;
    if (constants.captureType != prev)
      constants.edited = true;
  }
  static tabSelected(source) {
    this._tabNetwork.active = source == this._tabNetwork;
    this._tabCapture.active = source == this._tabCapture;
    this._tabResources.active = source == this._tabResources;
    this._tabUI.active = source == this._tabUI;
    this._tabExport.active = source == this._tabExport;
  }
};
configForm.GUIcoef = 1;
configForm.REFWIDH = 520;
configForm.REFHEIGHT = 300;
configForm.fontSize = constants.generalFontSize;

// obj/full/HubEdit_rw.js
var HubEdit = class {
  static get activeBorderColor() {
    return constants.WindowInnerBorderColor;
  }
  static get inactiveBorderColor() {
    return "#b0b0b0";
  }
  static get activeColor() {
    return "black";
  }
  static get inactiveColor() {
    return "grey";
  }
  static get activeBackgroundColor() {
    return constants.WindowInnerBackgroundColor;
  }
  static get inactiveBackgroundColor() {
    return constants.WindowBackgroundColor;
  }
  static newHub(whenDone) {
    HubEdit._currenthub = new Hub(2, "ws", "", "", true, "", "", "");
    HubEdit.show(HubEdit._currenthub);
    HubEdit._window.title = "New Connection";
    HubEdit._thisIsEditing = false;
    HubEdit._whenDone = whenDone;
  }
  static editHub(hub, whenDone) {
    HubEdit._currenthub = hub;
    HubEdit.show(HubEdit._currenthub);
    HubEdit._window.title = "Edit Connection";
    HubEdit._thisIsEditing = true;
    HubEdit._whenDone = whenDone;
  }
  static show(hub) {
    if (HubEdit._window == null) {
      HubEdit._okButton = new button("Ok", () => {
        HubEdit.okClicked();
      });
      HubEdit._cancelButton = new button("Cancel", () => {
        HubEdit.hide();
      });
      let params = new newWindowParam();
      params.positionType = 1;
      params.width = Math.round(450 * constants.generalSizeCoef);
      params.height = Math.round(280 * constants.generalSizeCoef);
      params.isModal = true;
      params.closeIcon = false;
      params.title = "...";
      params.buttons.push(HubEdit._okButton);
      params.buttons.push(HubEdit._cancelButton);
      HubEdit._window = new YWindow(params);
      HubEdit._contents = HubEdit._window.innerContentDiv;
      let p = document.createElement("P");
      p.style.paddingTop = "0px";
      p.style.marginTop = Math.round(3 * constants.generalSizeCoef).toString() + "px";
      p.style.lineHeight = Math.round(12 * constants.generalSizeCoef).toString() + "px";
      p.innerText = "Enter the hub connection parameter, The only mandatory parameter is the address, just leave the other fields empty if you want to use default values";
      p.style.textAlign = "justify";
      HubEdit._contents.appendChild(p);
      p.appendChild(document.createElement("BR"));
      p.appendChild(document.createElement("BR"));
      let span = document.createElement("SPAN");
      span.innerText = "Protocol:";
      span.style.marginLeft = "20px";
      p.appendChild(span);
      HubEdit._protocolSelect = document.createElement("SELECT");
      HubEdit._protocolSelect.style.border = "1px solid grey";
      HubEdit._protocolSelect.style.fontFamily = constants.generalFontFamily;
      HubEdit._protocolSelect.style.fontSize = constants.generalFontSize.toString() + "px";
      let httpOption = document.createElement("OPTION");
      httpOption.text = "http";
      httpOption.value = "http";
      HubEdit._protocolSelect.appendChild(httpOption);
      let httpsOption = document.createElement("OPTION");
      httpsOption.text = "https";
      httpsOption.value = "https";
      HubEdit._protocolSelect.appendChild(httpsOption);
      let wsOption = document.createElement("OPTION");
      wsOption.text = "ws";
      wsOption.value = "ws";
      HubEdit._protocolSelect.appendChild(wsOption);
      let wssOption = document.createElement("OPTION");
      wssOption.text = "wss";
      wssOption.value = "wss";
      HubEdit._protocolSelect.appendChild(wssOption);
      p.appendChild(HubEdit._protocolSelect);
      span = document.createElement("SPAN");
      span.style.marginLeft = "20px";
      span.innerText = "Address:";
      p.appendChild(span);
      HubEdit._addressInput = document.createElement("INPUT");
      HubEdit._addressInput.style.border = "1px solid grey";
      HubEdit._addressInput.style.fontFamily = constants.generalFontFamily;
      HubEdit._addressInput.style.fontSize = constants.generalFontSize.toString() + "px";
      HubEdit._addressInput.maxLength = 512;
      HubEdit._addressInput.size = 15;
      HubEdit._addressInput.value = hub.addr;
      new InputFieldManager(HubEdit._addressInput, 0, false, Number.NaN, Number.NaN, null);
      p.appendChild(HubEdit._addressInput);
      span = document.createElement("SPAN");
      span.style.marginLeft = Math.round(20 * constants.generalSizeCoef).toString() + "px";
      span.innerText = "Port:";
      p.appendChild(span);
      HubEdit._portInput = document.createElement("INPUT");
      HubEdit._portInput.style.border = "1px solid grey";
      HubEdit._portInput.style.fontFamily = constants.generalFontFamily;
      HubEdit._portInput.style.fontSize = constants.generalFontSize.toString() + "px";
      HubEdit._portInput.style.textAlign = "right";
      HubEdit._portInput.maxLength = 5;
      HubEdit._portInput.size = 5;
      new InputFieldManager(HubEdit._portInput, 3, true, Number.NaN, Number.NaN, null);
      p.appendChild(HubEdit._portInput);
      p.appendChild(document.createElement("BR"));
      p.appendChild(document.createElement("BR"));
      span = document.createElement("SPAN");
      span.innerText = "Path:";
      span.style.marginLeft = Math.round(20 * constants.generalSizeCoef).toString() + "px";
      p.appendChild(span);
      HubEdit._pathInput = document.createElement("INPUT");
      HubEdit._pathInput.style.border = "1px solid grey";
      HubEdit._pathInput.style.fontFamily = constants.generalFontFamily;
      HubEdit._pathInput.style.fontSize = constants.generalFontSize.toString() + "px";
      HubEdit._pathInput.size = 45;
      p.appendChild(HubEdit._pathInput);
      p.appendChild(document.createElement("BR"));
      p.appendChild(document.createElement("BR"));
      span = document.createElement("SPAN");
      span.innerText = "Username:";
      span.style.marginLeft = Math.round(20 * constants.generalSizeCoef).toString() + "px";
      p.appendChild(span);
      HubEdit._usernameInput = document.createElement("INPUT");
      HubEdit._usernameInput.style.border = "1px solid grey";
      HubEdit._usernameInput.style.fontFamily = constants.generalFontFamily;
      HubEdit._usernameInput.style.fontSize = constants.generalFontSize.toString() + "px";
      HubEdit._usernameInput.size = 15;
      p.appendChild(HubEdit._usernameInput);
      span = document.createElement("SPAN");
      span.innerText = "Password:";
      span.style.marginLeft = Math.round(20 * constants.generalSizeCoef).toString() + "px";
      p.appendChild(span);
      HubEdit._passwordInput = document.createElement("INPUT");
      HubEdit._passwordInput.type = "password";
      HubEdit._passwordInput.style.border = "1px solid grey";
      HubEdit._passwordInput.style.fontFamily = constants.generalFontFamily;
      HubEdit._passwordInput.style.fontSize = constants.generalFontSize.toString() + "px";
      HubEdit._passwordInput.size = 15;
      p.appendChild(HubEdit._passwordInput);
      p = document.createElement("P");
      p.style.paddingTop = "0px";
      p.style.marginTop = Math.round(3 * constants.generalSizeCoef).toString() + "px";
      p.style.lineHeight = Math.round(12 * constants.generalSizeCoef).toString() + "px";
      p.innerText = "Important note: credentials are saved in the configuration file wich is easily accessible. Therefore, if hub is write-protected, it might be wise to use ReadOnly credentials here. When installed on a Yoctopuce hub, Yocto-Visualization (for web) will automatically ask for read/write credentials at save time if neccessary.";
      p.style.textAlign = "justify";
      HubEdit._contents.appendChild(p);
    }
    HubEdit._protocolSelect.value = hub.protocol;
    HubEdit._addressInput.value = hub.addr;
    HubEdit._portInput.value = hub.port;
    HubEdit._pathInput.value = hub.path;
    HubEdit._usernameInput.value = hub.user;
    HubEdit._passwordInput.value = hub.encryptedPassword != "" ? HubEdit.FakePassword : "";
    HubEdit._window.show();
  }
  static hide() {
    if (HubEdit._window == null)
      return;
    HubEdit._window.hide();
    HubEdit._passwordInput.value = "";
    if (HubEdit._whenDone != null)
      HubEdit._whenDone();
  }
  static okClicked() {
    HubEdit._currenthub.protocol = HubEdit._protocolSelect.value;
    HubEdit._currenthub.addr = HubEdit._addressInput.value;
    HubEdit._currenthub.port = HubEdit._portInput.value;
    HubEdit._currenthub.path = HubEdit._pathInput.value;
    HubEdit._currenthub.user = HubEdit._usernameInput.value;
    if (HubEdit._currenthub.user != "") {
      if (HubEdit._passwordInput.value != HubEdit.FakePassword) {
        HubEdit._currenthub.encryptedPassword = Hub.Encrypt(HubEdit._passwordInput.value, Hub.loginCypherPassword);
      }
    } else {
      HubEdit._currenthub.encryptedPassword = "";
    }
    if (HubEdit._thisIsEditing) {
      configForm.hubGotEdited(HubEdit._currenthub);
    } else {
      configForm.hubWasAdded(HubEdit._currenthub);
    }
    HubEdit.hide();
    if (HubEdit._whenDone != null)
      HubEdit._whenDone();
  }
};
HubEdit.FakePassword = "******";
HubEdit._thisIsEditing = false;
HubEdit._whenDone = null;
HubEdit.fontSize = constants.generalFontSize;

// obj/full/credPrompt_rw.js
var CredentialsPrompt = class {
  static get activeBorderColor() {
    return constants.WindowInnerBorderColor;
  }
  static get inactiveBorderColor() {
    return "#b0b0b0";
  }
  static get activeColor() {
    return "black";
  }
  static get inactiveColor() {
    return "grey";
  }
  static get activeBackgroundColor() {
    return constants.WindowInnerBackgroundColor;
  }
  static get inactiveBackgroundColor() {
    return constants.WindowBackgroundColor;
  }
  static get username() {
    return this._username;
  }
  static get password() {
    return this._password;
  }
  static show(targeturl, whenDone) {
    if (CredentialsPrompt._window == null) {
      CredentialsPrompt._okButton = new button("Ok", () => {
        CredentialsPrompt.okClicked();
      });
      CredentialsPrompt._cancelButton = new button("Cancel", () => {
        CredentialsPrompt.hide();
      });
      let params = new newWindowParam();
      params.positionType = 1;
      params.width = Math.round(450 * constants.generalSizeCoef);
      params.height = Math.round(175 * constants.generalSizeCoef);
      params.isModal = true;
      params.closeIcon = false;
      params.title = "Some credentials are required";
      params.buttons.push(CredentialsPrompt._okButton);
      params.buttons.push(CredentialsPrompt._cancelButton);
      CredentialsPrompt._window = new YWindow(params);
      CredentialsPrompt._contents = CredentialsPrompt._window.innerContentDiv;
      let p = document.createElement("P");
      p.style.paddingTop = "10px";
      p.style.marginTop = Math.round(5 * constants.generalSizeCoef).toString() + "px";
      p.style.lineHeight = Math.round(15 * constants.generalSizeCoef).toString() + "px";
      p.innerText = "Saving configuration on " + targeturl + " requires  read/write credentials.";
      p.style.textAlign = "justify";
      CredentialsPrompt._contents.appendChild(p);
      p.appendChild(document.createElement("BR"));
      p.appendChild(document.createElement("BR"));
      let span = document.createElement("SPAN");
      span = document.createElement("SPAN");
      span.innerText = "Username:";
      span.style.marginLeft = Math.round(20 * constants.generalSizeCoef).toString() + "px";
      p.appendChild(span);
      CredentialsPrompt._usernameInput = document.createElement("INPUT");
      CredentialsPrompt._usernameInput.style.border = "1px solid grey";
      CredentialsPrompt._usernameInput.style.fontFamily = constants.generalFontFamily;
      CredentialsPrompt._usernameInput.style.fontSize = constants.generalFontSize.toString() + "px";
      CredentialsPrompt._usernameInput.size = 15;
      p.appendChild(CredentialsPrompt._usernameInput);
      span = document.createElement("SPAN");
      span.innerText = "Password:";
      span.style.marginLeft = Math.round(20 * constants.generalSizeCoef).toString() + "px";
      p.appendChild(span);
      CredentialsPrompt._passwordInput = document.createElement("INPUT");
      CredentialsPrompt._passwordInput.type = "password";
      CredentialsPrompt._passwordInput.style.border = "1px solid grey";
      CredentialsPrompt._passwordInput.style.fontFamily = constants.generalFontFamily;
      CredentialsPrompt._passwordInput.style.fontSize = constants.generalFontSize.toString() + "px";
      CredentialsPrompt._passwordInput.size = 15;
      CredentialsPrompt._passwordInput.addEventListener("keypress", (e) => {
        if (e.key == "Enter")
          this.okClicked();
      });
      p.appendChild(CredentialsPrompt._passwordInput);
    }
    CredentialsPrompt._window.show();
    CredentialsPrompt._usernameInput.focus();
    CredentialsPrompt._whenDone = whenDone;
  }
  static hide() {
    if (CredentialsPrompt._window == null)
      return;
    CredentialsPrompt._window.hide();
    CredentialsPrompt._passwordInput.value = "";
  }
  static okClicked() {
    CredentialsPrompt._username = CredentialsPrompt._usernameInput.value;
    CredentialsPrompt._password = CredentialsPrompt._passwordInput.value;
    CredentialsPrompt.hide();
    if (CredentialsPrompt._whenDone != null)
      CredentialsPrompt._whenDone(CredentialsPrompt._usernameInput.value, CredentialsPrompt._passwordInput.value);
  }
};
CredentialsPrompt._whenDone = null;
CredentialsPrompt.fontSize = constants.generalFontSize;
CredentialsPrompt._username = "";
CredentialsPrompt._password = "";

// obj/full/YoctoVisualizationBinaries.js
var BinariesBlobs = class {
};
BinariesBlobs.ro_js = "H4sIAAAAAAACA+y9/XsbN64o/Hv/ionOua2UyLIkx/lynD6Ona9748TXdtv4ZvPmGUtjaVpJo52RbKu7+d9fgp8gCc6MHDftnt3znG2sIQCCIAiCIEhu3o3OssEi2/g5LZbxJP09XqTZbOP+VXIeNV+c9Lu9h1GexMONbDZZRb1Oj/1/t7f1oBVtRFdXV50VIM+Xg6QzyKbR3c3vNjej7PzXzXwICJvHyWyY5Em+eXYQL2L1az+bTrNZ59fiu8s4j35OGIl8K9qNBpO4KKJ/fBdFg2xWLPIlFDTjdnTejgYtXhBFi3FadGIGHe+Y3+fs9zn6PQBq8PsL+1+xYI0aRC/zbPrhbD/L8mHzuh2tFME8WSzzWTRLrhQrvLgd9VqKwnQ5WaTzyer56rA5LcGbMsbuKg7vRVPG113FIPwcqJ+DNvs1tGETG/bCgh3ZsGMbNtWwBMvvmrMSliXRu9GsrSiav4HfmSa5Nxz+3LyspnUvuuzEbcPfZedc04NfhsmT5Tnr5niwqEV3w6K7YdHdsOgusqMsnS1eNgmiskTQVNRczCAijfdlh2vyYbzI0+ut60pdbkfDdpS0o4t2NGpH43aUsr8n8ai4mZLL30P2e4h+J+x3gn5fsN8X6PeI/R6h32P2e4x+p+x3Kn6nF1GTVb8bdaPvv4+G+q8Y/urBX4n+K9V/jTTcmP+lWheJxkb/3DUi67xknz6fHu+9O3m7d/rm/bsdCQpVDzShC0FIloUJvTl48e70zemZoPIFNao4zeNZMeF2jjWwKSh8X8JJK7rD6sSCKd4Mk9kiXaxKCCgODDZwMZhks0Rr1yRZ8BZEmj601uezhcRWR2qIiuK0goQtL6T1Gs7R/LY2TkL35L+J/PdC/juS/47lv1LR9XgbMQkMk0WST9NZjMbdRHzfY5KRunxXKeWG0lb5Raq0xHiuMIYexojG2Pcwxh5GYslF20zO4b1oQxtOzsA9YzyBPG7qAvp0nhVGBUq6StZmeor1h4IRH5utuv01dPrj3OmvsdOfF6a/HE159/7dC2KWQRa8XIdD9n1gzRsXat7o+U30pq5LPunoTrjks47ug0ujpDZsYsNeWLAjG3Zsw6YCtuW4GIw72TFBQ09MLKbLSqaHsl4wtSt5J5KN7OKiSBYf2pH444wwPHVsiSSjrbCkZtnimxuWXjvqKg4/8L97mmH+U3yx7IZp8nG2MO3dm40myUEyUu1Uv0U7x52jN6zj9MfNqPeoW8IYRxlkhSHbjjb4xyKd4Y/ddkR93qAIdFGT6nXqySCeqAbuZ8lFqQoBAKrE+Vm7TtfOlFXZsysoqUwpQ/TPsunW+GL7Jydu1Y2p4KihhmLcWWQn7NNsxEDvRY22LhkGS86DJUmwZBAsuXBKWg3TAv3dbsQ/I4v/l+l1Mmz2OXZkcUmXDNySf0KRO49EP7KSN43oSdRocLC/zVC9wyD1JFhyUVovdqyg6tNQ1aNgBeGS1Kv6b7NG6fqsemZlCzLhjhlLNw1DC8m7CETbmYGcls591ozummw9GU7NZCwWhNWTPTNuU3suhFUmmgun2gEQsOc2bGLDji3YgQ17YcOmaI6d2nMs4uHC4mFo85DYPFxYPAxtHhKbhwuLh5HNw9jmIbV4GNk8jG0eUouHkc3D2OYhVTyUWVhwAtPZZZLftgtYy+kqVbwN5QCKP5S6SS9ZO8nGWTcV83LkCyzGeXalTHU0iGezbBGdJ6Lli2TY2Knp5OsgyJh28s89jAGNse9hXHgYiYVxEF5IaK5GFsYLhRGHubIxXnoYPldDC+NVeLGS0HW89urQGOc0xhsPI/EwhiW2iHfpJlBiusR7S/7g/YAKDlDBC1zwEhW8wgWvUcEb9XfZeJtkZvKFQEw2STrwjTfCTM8mjkMQE6vzkCuzG/W8QuTNsPK+iA6dvZgtp1ZkSLpbF3k2lYwwFhdxOkvydnQZT5YJ9tfnDPf9+a9s8dNhVuT91ewoz+ZsOK3exdOkMKhy3F5kedQEvJTzz/55Gs07k2Q2WozZr3v3TDQGhvD8Y/oJxrCoVsdXZAdr4h95+Sc7rMIHO28eTNccgk/RaRHBwI/5LK5J8CIO1HD8ziI9nzAp4Lag9udJwVry8dPON5KIaTPI5hMzXozN2SDJLkRXvlkkU4MBoio682UxdhFbKpL1BQlNypXhWBFETTgYQeSCY4vC5TSeQWA+Pp+wn57AuH5/Fl0hOxUFsD6bztg1uBjAog9xQfxbdRtSXEtbZeN4YzoIyKlb6bgVIAl4zKg9aNjaUaRikKdzmPVoZLIJgMnUTuod2QCtlQ77duz35zS5OsryxUmyWAB0sAOtHnpz/PY6soOL7NPK+fR7lk2viW8u3NtpnI/SmfP1mPx6Sn59Tn79JR0uxs6310k6Gi+cj/vxnAkO9OUinhSJ3SpZeLKIcwglUIi87Mwpe5+njKV48mHvOi0OPebs4vg6UExIWhXRYlOl/w8L3wzUl0wNrD4GTVoWSQ4bXbQCqlJt9TCGNYBseDyAtbanOTN7R3Ge+JsVAhtD6Ogz0sM5L1Fbcm2LYpuNid8hAMUauT+OZ6NkP55MzuPBb0EOZ8vJBBsQH5UAmjE7zT439vI0njRwSbqIJ+mAUKTP59lkSH0fZJMMzNnZPvzReT5hVeLyeMIc1xlzd/clIMUx8fk8ZzYdvjMf5+wkm6TD5/ClietpYQRbsAzT/oBBscxh88bpslJZEh9/pD4+8VoEfSsbBBMmM1rMZsaTJv/+I+96htXrtq3iznECJcdL5kG9fPPhxUE7clUIyMulEgNmbhzjRtto/aVZZMt84Oi6J3yYgQUg7J/Ad7O48KXcMZwyVn+G0SLEMFS14cEDakcPGijBw5NDEkNTKq47r5o2cobDWtHJk2EeX9kz2DguFNMkc0JGRkhm/vo90Bwo6Vi2o1DwVqNA2MJXeOqt4kBNjoGrF3nOzEbjBNRjuiz4gi6O5lmRLtLLRHp0ss3K8eAB0DxbzobNXrcLQXNR7SZTr66rk52Qu0KKVS94qeFBqowPxwms203CNNECF2VY2BLaE7dl5u7s2u6+ZwWRRMpkUqMVgjPVFjCmdEugBLeDQwZawU1yqA3SXv9RLeBmn24CL8JtELCBRoj5I9QKNbv4zTAThLZdazfCnpvo1tgwuFkOdqB9zvwXaqg3Tf4xLYaxKJZuYUPM5iL04wl2E7T+8qmY0EjBIWUFQvN5SEpAQXPiFD/B2tHaIUYRkHZt9ZsZTyUpqmw2M5fdzsNtF/1llu/Hs8u4Dn6v07Pwx4vpZD8betOFbY5+jBryLxPBx0OdlfN/TSkvtJhz9kTm1yaUj2ZZ5U3DpPIyuGQCZWEu6cKeg68ch/2zu0T5zJZtVswAfd1nc9KCgifXNZ8v0rxYUMWgcnxeVjOOM5wsHADkUuI909+2x45fh0fCKIR2kRadlA226/cXzcbfZqwvnuI0G08QxeLTDlWmxNHTsYooYf51kBCrtphP0oWotJQk+qRiLV48RKknh6LVmhftuLC8khIEXo6xuJDfaokGHC27J9xay1BprHEJhmUermClTcNdYZMv4AjH9MpdLBamegJ8bIOr4XiaXEsjzgbw69RZ6XrhKDroZA0gz7XjlfkVdU5WxSKZHiQX8XKyUGbaA2t2WzR2Chvtz9PFUZIfpdfJ5FWeDl+mJYR6NQmFKfRpCnuzRbo3SeOikoWtCgJhzPs05v4kifPT1TyprHq7pQzwNMtYT81Gh2x2+KN626qk84ZNE2z21VMxLmxu8H6xERylsBG6PvxrpvUn8yQJVNGjMf4vpEHzzD4Cp+/jvMtmCQ285QN7fWpj3NfdwafO58t0MhQx2upQ4mf2GWIp2j/am89ZX4OtaxY+5D1mxMXGvIMQAt6xnO7ZIgl7MIvcmd15a5hrMI39mBkTx2g2DYaxdDE2aAaH0EhdSMXNQBwVNVoguFYbl6jZAqBqFyKALaIitMTXALhmjEfUi7CoWk/zdDoNxtRVKa5PYxCVqTK3JqyYg0k6D3eKZSpcmdlul9UwqwixYX2HqsGRebD16D7xHf6xlVOtc2ytrB8imrNFTnJRN1CEdrtGGpmJYMjZKKyljIwwfnaB9LpGu2dhyOgfX5S7NZHNKsp3zQQt7dNRm2acCr1xhjn/yOG8vTNBH2GE+UcUVGDXfNpZi0DH9BPYXvnZ0PgS3qQLESfOl1C7YSA8/uEnZl/1ipqtj/jv/bjQ+UR8T5N1xrs1e4nc2FR0SrZ8FQgThM2O3gjm3wK9i9Ere9gSpY1a3gc6NCnbAaw9hBQr8bHgJ0iakG3Y8tvQ+K+GYYPvIYtwfMHW4NKCKwq9dtRvMSoPWni8jILwWyT8eRB+24NHuRNCLE2+p8HgthlwznN/z1s7FbLo9e1OdcVynxLL8avnTxq4gyY8jDQfx0H+73v8V0n0QQAjLNNHAYywVGGTwkMJCpa30BWtXuvWlt7rk7e3Jb3x2tIr1pbe5Gulx2Z1I7xxOyra0aQsqQHvT0jbOE6uzfkA1YxLEyPSHPCYhlLvp0y9nQy2RhfCSIUVaiuC6bYoKY51mmOWFEXenRDhknYeeBXpQfywBkQ0BysIYrnlY+pjQX2ctFqUvXeCLDc1/zeaAER1GYM/Ti4msh5Jtx1hA+2oE2xHZDvWhDDoSO1XeWP8F7PRA4gA68/wN/84ypNkpj+LX7zgnC8bVaaelYik+wuzVqKEwsbdpFtz6uOI+nhOdasO1V6OqEhrIx+dm+T13E0qt1OhA0XnwYTzkbJE4SAvbn60CZNNS6dWb7knAcbFpM8YBsuxSKZzNknCP33xz5Y1zOBD9IyN2IddZ8wKVMZor/+wJaqMnj2zTrwJ5Oi+M5mJ72AGGKZroXhpP0Q2EixGnCFIX4RfO76eSObucvR7iqiA77XY9+YDyHkUzb0XbfW3YcbdjB5sd/umPiApZWUdYeNUdqyfffvnFlqkMOz9jKfIptnsQMQVwPg6G56Fc5hS4KpQq70jM6I/n3ufhThcb0PAqB4wNXIhKRIgJCE9aQFJ66ZwFE0NLWW/YaiJAivHkHfSbrTd66ryiewkKU/V2zLD9V70aNvXL1B2RzvEvxtQhHvCJJJUDAGq9q+oeLRmxbqTxjD2Hm3bfYQEsqEFQvSLJTg2XrxTs+c3ZSt3Gq+Eq1utIUcE5IiEPCcgzw2kCEZM58tFwqZ2azgeq3bmZhDqjGqUBG3yy8231+bPE/PnW/PnlOeeHTPmXkU/sn+fRK9QIc8vO2bzMlE4yHJI/BEHkrsoFzu9TAsenMAhDtYBFVbiOeOBcaMEJBh7jsufAkO6nPMmy9/CEAWMe/w7UwduWx2DzUnuciK2GUJ7cPJL4X0Bh/Rt2O5Y0jCsUGy89SzTCeCAObkrUDcE6j1EFQhhsoakMzKCtIS5ciiCadrAhC3Kfsu2bLICzvR4nxUbeNPkYy531rmazddYwKDhr9SPV6Zb0RrnFUnh0TbGOsb0npPSeS2mVnfGOAY79ArTvmekeMwa+8rvDdXqYE9wIkLqitQr9vdxy+sGgpRm7bVtN15HG451ObEBTlzr89Yuf4vLtfa/Rr9B90/Qb635emNwaR8DukOPcMvUYdvmpxzY2QYxK4itlOjbqcXeiV0yBYY0sNUt12JlueUoLc6Q91wmi7x2yXzaOabNlyC3SX1kJalMyF6+MfFzz9snI9XY0SdClXtAHUVD/BO+TvDEDpy41Bi/TRQeCFKTwQQ7kKBT6wo8Y+PGmAW8Dc9WeS78nQBC8vdlPGkOasUGeC8NcJG7+kD5x2oRzAYzpIGI7iMO0RAoZoBqTPOpDgEz9jQB86kOAbFWv4NX7mVojmEWNNYTE4QB7piQQB0UESK4gwMGddB4OOEOGU64PYFYqpqj/TDrphdK274rD7h5g9i5qkOlWk/UVR3Fkd6g8I8K24M5RDsPXBPi0TYj0BQEUmIRBLVXyARSQBMsZvLPrJWjz6yJ559ZoVU93l+jfGH3ZAC1qnZhrKCI7W677re743juuufOb3fncuLuWKpDENb5B0jUG4hUDGuiPD18K0I7FQsCLlXryiKldkSh03p34oiInuRU8M9ddxHCKyFWB/nnsbc+YD3trRBYx++UTIjuKlZ1lUt+RJA/J8iXx16+rNs1eBGqC9BKNFbYfjjOrP9yYrk6Ipar585yFYUaYx5rzPWFFSP917n+K0bxPz+cGEoZtYVhknxElGBvkg6S5yILKLDD1b8P2w/3H8mfIOyWwZ8t0r8vk1/G6aKMxDaQ2IK/ej4JNt+HUbuaBIk4jfN0VlIzW3QqAr2+R+B3cQiutOGByp8n6agUV/+n3/Vw0+LvpRLn/+kzifceP/CQJ/KMVlBe4v89rNlgnAz3JtNsNqyqmvdU129zqZ50TWf5aD+n2SRZlPTTFmvtfdis7fstzrOrWQnqA/af+33xPwdzmU9Wv2RZWYP7DKv36D6w4HG+H8Ox+NJWPwYOtqGrHnhC3x/H+SJPlkUtBSXQs0EGFz+UcA9bgz3oqS0fPcvjSUVP89ofUaizi0l2leTlje91ofr7j0FlHlJEinTyW5WyccviD5L9PJ0W2ays50Dd2P8Iwa/i2Y1MykGc/1ZHy3tbjynUyno5XgD5VTYZJrO8TFmlnsJ/eiSJPF6VDZTH+D8UOt/vK+O/SxkXwP0/4/i3tIxzqPbRFpB4SOEfxqNktojLLMTjMtG/n6SXSUUDHm3L6u+TLLzP4cxZ1Yi5H5LA+3wwTss6b5u1nk+E3fsU/nEyrG49WfNJDFa9hPEtkDtU3ev3SQJJXCG6Htjm3qNH8i+CBBiq8qHzkNX9oBfsQU6hXIOh3x4+Fv/zCZwu878vs7QoH739LqRsdEkKlbMU2CqgQQy/JJkfpbNKa8cN5kMK++S3VaXp6T3u0XYrnVaM/a71Hwc7G46qTP0WZ/w+WfvLNE/O87TMLek9ZJIDw7Xl6f7LCUxUlR6kdiPve2PgZZYnxaJCg7nVBM0jOFgOxkUaV9ROOzev4nRWnGd5VjVR6f84+OOsWFQ1nk+RAQ/8lTi3WSq3HuVe1Jhv+r1H0r/a8uxGhb5x71X/x0WtnGf6jyiOAe8smTDPpEzTtpC1sAm8ZuvF1TC5quXz+3r2OlvUGOJilPlO1ZvZMI1npVae+9yP++J/PvaoRMkeKgfDr/cyy1eVI4tuccWsLqQlTIOH+za+5GdYyuYlhc5HNo3OzJI5Bxr0IbtyteXSuJpVTWx9btP6hLq9Tdisuj9OLy5KJ1djmXzL+hYOdFX40Fxfew+kJAj8Kkf+fjc81ASBUre0378fdog5vrYUVWNPiIH/p0e3pdxq8HnV/IfEr3BToC1bj+RfBIE6A/gRLAkfb5H4lb6W8LRpX0tQqHS2wNjyCbP3kJZipavQEyv4B/TI4iSqva1ejy9WHkjXlSKySJJJlXo/kGGMfkAe1Uq1jTXVpTBNqld6XQqtohP0iKYEOEtmVaNAm0Ybt3KdU+JrHMZ5ls0qJl1qkXCYDNPltFa8rNuXzSZ0T5CpFQXyTaFArlwkPXog1mmEARAUjpb5fFLWApj2exDs6/ce0ySqRyAfv7DK6PW2AjSq1zu9Pl/uKotEUplDdmi1P8RVqrd9n6ZSY+HzsC8XPcTiUxARa5/yRehjIMBXcL5U0uGserLry//1/GDsYTpb7OdJPK0Kquoh5uIXi9VxVtSKq/b7vn5mg0FcpLNaYdlHnnK+iy/jX7NaqxgecXy4RVBYVcad/Bn+/WT4Nh6UVrqlROebIx42qePG05gHeXxeZkxgKEJY1g+t1gu2PKCMt0Atd6T5IH5MIpcbILHkEebDGylH8SSps2yC4d4Xs3iXpFHhxYA72t/uyb98/BoDvvfQMPKIolFjvHMDymVBhCyO4nm8ipnCzyt3E7jV8PT9KIkH46PlxUXl6pWPuG0fP19WLKW4nXrg11zDB3zMDaaPOlmWGShuHB905V8OanY1rAyoP3ygHHJ/rFbOfHKcEkaierBQbgOzpquqzRcdEiTigsfZKq5wDx+oBTNhkU/i4XCSVDEA2sVj2o99/CpXXS+c/KF+Es+GVY3vwxqj94D9x9+mq/Yx7j+Q3D96SCCfjJlbXLns3SaH90mazGZloXTQUFjk+Cvmk3RyWbZk5+PC/MdBXmNZ4s8IdTwqQH1M+5e1FjR91eH+6vBkVmMRQocq6ntxasvNwa9eRj1UsR0isHRaurrvKSQiRHOalAUWSsIKp2PmbU1KNyYfqGh1zxsbp9k0XmQVwgZf86FnRE91GgYdpu96i0YHv3rmhPEsTHDXa3fVBoEIPYiwlof8yziJF1XerXAOH/u4dcLjdJs57sk0+61evoJvFOqv0Ls0aqW/cz+41qbuShAHV/mtEM/lLXH0xSvwQlNawD3SkKcSw4UuzrUPGb7pJXhX7QCdbFnN4ey8SxYSERvLmeS04V4vZtfjIvvX7iH4wO0WBmBn7VsW9X0v+lY9LcHkepHMhoUS7D80LMQ84pzZ1yGbXBYVSE4vsFE80CcGi+U8gW8tT9BwcGzQ8z7DYbRB32tlr6SZPQ+6XwLdt6VyxFU1oFDi2C1DHvw2S4qiSr80oLmzrd4tyBWKWcAF3Pvx3CXLuoH4Cped/ZrxpS20jsev/jf7zdbMC/uiY8yv/pvi2wA+i7rRj0LI0ZPIN9P/KkMHhPRL+Fo3Sxr63MYiZ1b1ZLGaJCX61VGpeTs3vA9V9TZ1cQ3SBO8+OaENFJbWEw9H6QqFhfTIvjGsebGc8aM9TdAvOdQn8iom0DSANEDqq7YJ+sNH81eDK2cDbpTpwn/k750wwvPkMplwhB5HEL9LEI7hwmOO0OcI4vdOBUv7k3Q+TwTeluFMfeZCaek2yjHX14Mu+uc/o6bzCa7/gbdNGB43PwpEF3DDdJwMFjFcdxc0T+I95Kt2NLY6Do4VXqNRDC4yzhiGqf2KemBWG0V+EWr5dXMf5DMRZ1bVH5SufEBHvXjJmSo5Q6ezZXXTdHYYX9eptKdqPXzzTv75oa+/7X2wmelpbnoeO4yA5gj+dso/9DVu38fd+2Bw9z74DRKPGX+dAEnZWbUMxOsMR3EeT+H5p+IkWdS7lE5iwl2EoLD4EXD15gOUdU5+frXjYb3M5O13jc2GX6oepeh1+/f9Un2HKl18cASPHD1+YDXzVTJL8nRwFM/4dY//6k872E861H64IZnBREg+sTAHycAlkvzCNjhpiiTW0QWdty9enlqzPyvxTjicj/RDDFXef+9xv2U/AZEP4RX5cldHQAU9pXk8HIr743r23ZVwBGAQTw7VoyB28TjL09/hCZgQwPnouXc9tqxRrFXqPTtR82mIwGMTVAUgZX7dulIP8VwDW07q+9eVCkodoLVPFtoOgYAPXD2uVCp057hROeKycedK8QHcbbofQ865uB+naN706nhbnenG2jDWvX82NjHIveGCWucJp1W3DfqlJEY44FKyEswphyT4k8PSexyqtsS/vhHSCASeIBh5V90reKI1xp54DaKG5C3wbqxQ6AkFDWC/pGDwqHZYxs3vHMeI3FY7tJ0sa4u3WCkI/NDLIt7zkM85IlryBV8VKTfrN1fgP0qkcm4JmRReaNsSAV9XdO6bLEdyLqt6lsWd+f7MoW/Ps4H33iwYLDEHm7qY2p3Hb9X6um5A4HScA2Vdyu5SoK5n952NW22FNIzUAxrKZJJPaBh7Sj6iIU0x+SCGQLUGi3P1AhqU9JsKcxPzZWvZpmc227Sl0BFg/9i2IrvjvFASfoeJCFFgZ1hGIMQS4rXuRe4IHGWFfuVRRzj1F/NU6ZovPqoIKA3u8+A4RBb3nRKWd0vas1PSZrutnGmo1wfkywfZweGqmg0Ag1vx3iYXC2HgCFr7L96dvjiuQU0AAr19NmqSPEjx+M2r13XY43BA7xhWooJclZBJ4Rqh/ixN2p+nRi4HpUoUZHc32JJwWwPq44J1Tt8fyc4J1dFsMBjomNNsLrrFI2JpTZgOrTMetefvT0/fH1ZSE2BA7Xm2WGRTSmU8qfiiNCLUS49vrye66lIF8Rnc9Zkm2hPQBTsAIeXt0aMMh8G0ep7Apbvc4GPrQKBXGwW8XkTrzi8ta37hkVwnXmUiuodstotHiR3IUjKzsP6xRuRI9DcJ4QWJXue/kzGioIX2KPyc01GmwFjdcdf1ioOSZb0C8Vb1Gje0qEfNu1V/zGp5CecKxONc44Y4R2K9Jc5l8HRvNssW/NqiP0ftMubvT/jWkx+25GuhbPb+4oIJCgLf291w+Zlf/o01mk1PWClky2h1kIVYERS8t5i8I1aT339Pt6tuwxwCpln1Rqrnzd9ENvaNLKbvvzoUUGOM2toUGKU2kDVOHXxqpHoK+2cu1J3hUafBZ+EGn1U3+OzPbvAfM3+Ym/+0wqpnLP6VB1/JhPjn9Nztz5/r9FxoLfG1VpfsuTUmJe55BnqPdgq+Ye9JH+L/iWu37I3Xm22Hfrst2xyeMeYSkfXQu7HmlfQb7cqy3kxC+4pOztex2JvTcdC0SM8n1KV3n8XFz5avI+6Kdh7n/rq9SPzwveoa3Rwi8oeaSgUfLUmQ4cfga7wadef2HpAOPg9d1m+6sbJz1g+eC7xA1FwUWuFyCU/FybV+VI19lxFG+LPIqGmyf9r4Tml+RzjTLusecnrv4pCBDWJYPcDOxShP4gXfFIpn/OJye+tCaOw0nfk6y/6Lb21Eo/KWZD4NRfmndmB/ms5CGznPdhHLbEa4Y2fECGHuj5PBbwciH3GIzf4NpGdeGoEqvWdDWv6EME2paeCPECdTG1qcoiO1OBlcaF9sFzF9O+JkMguJk9WBxZnOaomT6+YfKk6VCpZn84zfXhn/62UvjdQbeQGL5maTCthL+inaS3z7KrNReXLB8+R8T4X3g3662xI5L+JgLfsWcni/+3gZsr2mHLOLsHxxUiy6xIiMWoRjSYF9Vqlxh/Fi3IHx02vTirTko+KnVOYnO5Vf6CS62oTU09gupZ9l1xDdScSeTbvbUZn31FbO12TyPB785sqhSKjEKiSfXqi9vQD7+Dvn9WQhLs20X5i3+g2PS+abqZLOyzcfXhzs1PP+VFus5q7pegXfZia5tvV4PUcwrNCO1uwNh++SKyyg0+yEVcvFbY89vf8gJDg8Yi4Vw93PkovmgP3H6nvTNZ25cQvFyKNEwdU7hyTtJvN81QNDpuPhJQ6oYtM4xje1IV47srnvAiP+zUt4FSkg+/HsB4i1zNtRMp0vVpDcz/AbZIM9KQEXX9cw+RaA0BveLTkfv2q48b/EAGsD8/Ij+0t81OHeq3QxGEcc28zWg7hIgiPp+MXbvdM3P784ff/Lm4PT10+IpwzFiN/U3OysR/f1C1g9U4Slydg0rVuT9PP3BMfC3jI/kqyhTbWIymvohbSuWdIB6w4Nq4mo+12j0nbsb9u1u7Ra3Mqou8jyQbI/huEC1vOc6Tyx8FyHppX5gUVgZX6YHv/2W7CmbmcP1uK2Q7C4S/C9Q7QpsA3rznFyne7TbDZ4OWyH8uvHha0KD+wSQg4k32FNJjHPgFtkEdeqEvJifNeiL0DdCsaJ2c8NDvNa9AGQZD+KZ8PoNaon1I9W//GdY2tpADvHzloBnQXCCyhvFRHbe3yBVFEX6itCcuahdGIt59KwF3+f5Ym+Q4PokC0CZC0PvZIoGQ6cJCOGcpTMChQT5A8NgfvmHKahZUFB4iUFSYlYq1Fw1LptinIGAixZIG4fTbLzeHKYsS48zC6TZkCACAy2tZLOnBGUJ5CCkGca8sw8rpLEOT8Mykz7lCsbm6ny9NpZDJ0M8v6LyVSUEY41K+szGK+cTxrpbPhikkyZx7p3XmST5SI5kvtUzWRiPWbMZfASZkk7zMofcZADOVA8vHbe/EPvj1yNUzacWWV6UrLeCi7gfCgcsWOMZlfwfu++eHFiKE6OJuaVZr6DYXPy/feCQEdtvvG3rUVTGjyagpqF3w3mHCeTTsY36yCJJronHph+OcniRVNQFcmXUIrdE46/wvin2TyMzgpdbFvW5oUO83o8f0Lab5lqfQMsIFEeyz5uOG2997WNvfcVrXWVh2ovT7ZgNYjFldRYwhuEuUecF2wOr9lCemUFNqyRQDhHzkih9JEzwqF/erOvnJUdBLBnj6LCXT2XanxEo6MVXsWARWItEZkj17LmCFn4jSg1CZVGQQCwpiTX+GHHUsnwl8PVqjzUrrWNBjJQpOg/ciY/dT44CKsqhDP7+XDR1qeB/pUr4A14iPQf6DlwxtdGaT3wdqnFHB+NdXAQf1+spk3VPMGl+LGxUDNQ45PdJAkINxDMspltUzCpk0XOty7g7w77ZzBubspfd//WbHbutf7W2mx9ZDwV80m6aIJn2NohSfH1WGEpYuhp+AfeW/DimVhDRowqZKc0u/AgvMXBF4eb93k6SuVsLP77PGFMJNbsa8D1JK7nYPHH1vVWh1ksaY8wbx+7n9oWsx/77of77oee+2HL/bD9Sd+F6AnYb9LexULcZuW0yMw9WjUEsitsOWIXhVImF0F1uNPfkiGQ07vl9Jw5SqiTOEEmHgpjVYLRczFK+tDqHd55cD+W7KaN92xi2Xi/qiSn5FdKDYg5tL44sg4y6qzixf8hgy0UPITecvvU1dJ65B0sj2pILjdlnmO3KOMFtQ05211wf4b8tcgursAjX9o10oFwp1R8+JhXCzb13j13ZqV9b6vCN0NGKF2slD+iSFjmDPNspgmwcc+ErdvYwOOOrpb42pkuJ4t0Plk9Xx02USVg++y2EMeILErYw7LWIoSH5axV6LNP7oKGf7WZT+EVO/p5Sp+EYjAeDp0MXuu5OnUXpwsjjpDruFgUCAHI6aRlbYHiY9mSQZ3Huge3ex1LEGdbBz7y8mS4seHHBVFx9cHJ0yxj08BshSuMBvFkUjRa5aR3rYi80yCnCe+y4+QiT1C2y5/RFmBKBjmqJSsGLW9H6SbNpafHAciiw43B+wtAeerILojD9ebS7J7wdy4w687mq9tDKGJyBN6V0V8dBx7IP2xhBKAhJCb/VKTnNmQTTtVrWuKEPfzD9GM+iQdJs/G3v83AjWP/xSoGIEpCjf9uWDJSjZTn+sWQNNdKHjC7rPfZqBr/+2Dv7L9ZnTPh8B/Eq2YLJS+Uoh6+f3f6GiEfspXQuD762Yu9Y4T9kpm0syTO6xN4/f4nTOB1toSIWW3u37z76fQFZj+dMdd/DQonL/bfvztAFE6SQTYbkhTM0A2pj7u5IKsswxEKZWezoQsephAhe5sxrdRrXWy4L/kJMdhV2OrAO90fzvazLB82w2G5dkkgrmXUb6r49qYTM2NM0UT6MxvGTGJeIsa88wFUHbySeefM/PkheuYtvmUQRYTDJUIQSu4fOY8sa3/dnXF4CrA2Q8wOcQvk7BlRqesVOG6s9SgAP2wWTLUHxO0plTWQO1aVbZHVIQ9FS/DNjP0nfGddoEeClFRSSC1SZhOVz1dg6xfpNCkW8XTu52OjCcHpaRRSvdJP5gbaaEDHQVDVCKO5V7Arvw16yPfnt2kGODVn2jX1QZsHcInpfjy7FBcRZoMlRG06A558JmM4zcaAA6gpw8HrXMmMliu6eKwSW8b2Q8I8f/ZVHs/H6aBoOljiwje4FxkxzK8FBE8/yXnkfTZIOsww6uknX9kOqzAjzZG8PU693TyI+SY/2uEfJufL0cgE2MQ70Nmo2RAk4MKKBBydJxEk4SUduRth7XuLKGQ8L/hlQh6PbHXA+UfRdvAXmKCJSJ9SAbg8p9EfKskrDJEJD1fnNUXYALVPw8Afb6aMS1+2gGT7w8LenqZT1tRTNglMROSYtyYIuJ8tZwu1wuIPS1/qF6IpkptBIoLECHR1nhX2C+O0L+sxxUixSWjBTNyAdQ6fGS1j2zWbZAFwa7PsdnPtTNronV2PgLPMIsdreVZeKNZW7t+KVasXjitFYqvQjsUDJQ1vuW2tqHZCCxeTJZDbfjY3uU1tnHiWajphC3S2MIYLpGEHRaauNhxTXL6seea6uQ54cF56GvXXQ9TTUBVmnvydiXmxN0vFzuJL2Dd9c+AH3mUMfQAWZmKDl1Ly84RDVeo4PQnQxFPj7jOjw8gKK422J1KtIoQlFrko2SQR5ncQL3XKgaU1IY7tmKhYq9I6WYfGF+2hOMmqhEUom98xhRKHpHTe1/v7eGjCwJRHoXhGN2QmQn6Vl5VY5+gUGtd3KlJHTYd9O7NTloWpmuwHyOqJDSVC/o8Vl0mzXFs+Te/23f+BAmoiJ8qVkAdrC8MubYIBcS62dEEK7oS0o8SXKp1ZUuXQex6k8sqrVk0EqvbYK5dJ+EhJqQJxMMeIyiTMsvR9wnEg453WgpOrFs+ZtIR7+0yKqCDPb9qbDQ+yq9kki4fC50aXD7fZ+uIiXk4WL1Omq2yWaUf4GmH9S2WimmuCcTCFrz/QRbZ8cYkWjyjpBxSnatmpnPEaa018bbG92rcvNEZ5sk6DFR6sV9WF+T4EeV++Bxc1ZK2dBk4wsi57Lrvt+ejdKyvJxqPvfrkXNeazUYPK9Kld6cnP61daXLqVfnG7RJ4l8YTrFpOSrRmZsCpUh1RCNZpyssqodowDvMNkUiQOql2NubFctWcc3ZXqj8uk9GyCV4ackBPGuO0mX9F8rddEVwnKY0BVE8bN9ffKTs2/giT5ztZDk7owtgHGDoAJlxyYCEi90JNCcGNO+jsZbNqxDnegRjtnPEqNhjkn4QevVPUqaoUsuNHPcwbw2069+pi8S+pjpTeoUpqYJ87qyN3Jk4SiJ8vZbzN4KQ7UveF13Ux43u4ZM3QGo97xk7aanK2DGehcBvLKTFhORAIlq43WOq6IWiLtm/WCSIqDbsh+Ix+mmcXzYpwtxP0W9B31aNUL5LT3RMYgI1ydSaukFsRq2tcxx1CM0gpQwp/+Ql8uqUX/DrLpnHGaDNcUn31aS7XDTcbko7dkWMdmTc9DoeLo4Qimhc9D6UiBmEW+/o7OiuTocMhvb8H84vPlImk2xkxbGm1OowJSUW54LpmPyPOihmkxn/DX90QqnR5Lqlnn2XDViedzeHtmnE6GTYnv0RtMUjj3QxPIk2l2mVAEvtQLjFqn218y2kVghcFVYJTBDbMMyOzNj9hELPBMGHSSFTQtFSPlDBzl6WxxIsPLXLXogGkAGEdPQ/SIna8AqLvhhQ82oXVMm7Vt9FKeoCpJRCBO4651fJcKgtt3nhCxcPdWlHA2gHugADWKKHXzYryTw+EzwEpbfxaR18VKbOe9HBBnnN2lMgkUOhnigL2fHZxP9mHkUGX8GstAqX1exGvqTY9mVIQVvHpqbNASx63XP79dJ5hJzGUl5UwhnSTTqoGHZkMesA/u5MMZnZNkgdZ4yhjGw+GLS/bH27RYwJVSzQbPMADjyEw2TIso0FxyaEeeAtKOs/6riid7OiajIwzES8kvD76Ur68qoi8V6yRq4KNfCEikR77M8qndgg6bE9m4l12wlsEoHWPhKJWng/wr63t8dWwJRsd72wQjdtz7dMN01NNAUoeHcNyRzdPz8yzOh42K+tH1Z1b1te7kJOihe9AseiV3ztLUSt826vJ3huFlUnj8vPegVyJmuGq+AyYHZrUH6+zI0nNA094nqhE5ZWNQbmqHLYSwl412sGbPveUczwYJ2G2L7dJpzuaeB7nqbUi6Menc2Qf9UrOhppYBZ0s1Ocy19u6GCTzquNKOma5FOJ63U1EV2fKOCllDYbbeZcPE8pJduAC6P4FZZrCGi1TlV7jlX3Pok9DO0O06dScWyzWtt8kosh8uSp4NxRdZIIySnc3P1g0V4qC+mIRFSspn7sZR6wwH7iBbskEVhPYmESKN3AII5JBbvWwnkLu5exCIObTOL7O1/mWaXB0xx03GNNRP+7KL4FaXUz25wWW22Sxg2NhSV2C6Z/R0toaLYR+h27uM0wlQULpmNSbaiPrR3WjeUQ/5bLC/iQeaDJcOvadwowY+/OHVp2/c0HlfchKyN/d5CStwYzbowOIdUW6ff1LURp3DJC7YvC8TaefcH2iz5sDE13b48s7PNDkd6ek92w35gHDelwNKt46CHEu1+P57WbmYdZ9F2+7Jrbk1KaMYKy64Gz0WF5dYh5d4rNkipoWHD/a6B3ektPxDQTjKbA6VMY1S3Yjlc89RmntlSqMpacNlSXBtWtZRVhMHntt+nC1qHp+t8uvgLYcnlkihqnmHennJ/J8VlK1d17F9CZCqzB2bqAc21ufECxGraprhekDV+qV07WOsq9LeUF5wVW9Q10PbbK94V/iPeK3VEYHnVPyabAuvBGR+rccI2Q8r3A9UPev0xKjzMp1M9OPLH85e/8K6QD6Q1Y7Em8umk9tWPbZ990YfTquT0Us2R7p1zZNZ/Xq4rb/Ql+5yg/2Sp0g0ew+2Ht1vBRXKPAZToVH2Ay626IsL/qw1L5aB7e6OC1FSWkPTnFdcKuvvl9bfv4mCEbX0SmvprTHs9XpU60HzmpvuEjMO+sx3QJmWrAFrTzy9tjt94DPWQjeFQvF8atcLkBPruRgXzNssQllmPG7sXlLEfEF3UVHhHbbVGxpwRjyd/SwLsScbD/jlTJbXE3QmveOQ5e6kC44dSi01zYAbLOOBP1FK7UbfApMl/IH/RBXrFzp2lWgp15jA/Kv7xaCpp9mB3qMSulty2A8f+NOI9sk/OLxsm0q3Fhu5vDICWyzC/WOLGqgVMiEhx93CruG//8dTrempitFcMqLYgMM2qvN2Kl4KfYrlywxu113HRDTerotn8/PlL+pHry2nY1pO/So5HdNy6q8np38vL3/tzjm1O+e1HstVvXNq9w5C/Eo1/jarkLUF9fymgnp+O4L641dJIYeDcCNgBN0jvYiO+6IWv1OWTQxlww0zuKpH+MwnTLbfDWRd49P+xhh0XbiVD7ei4K7Z+q+kZWuYXp+DZ6Uq3lprQPxnWfyfZfG/7LK45or4KxfDAc+6/poY0s0K/1YBK1/BDi17ycsYuIluwLZTOdQfB3CS26yMbSB+7dgpXJwhjtfwnIVGF5Yt6D8d9Y/+1/zRhbv26lzLS9ZP5ptUQcJVtRu9EoAzCWCuBLdArTvBUY7xt78UHFXunPe1Ge5QXO5SvO9QDQvcDO6kc8txRxBtNlgxfwk7XUyZ29OEEyNiUeukaJfRYMVAQ1x/EjUhgV7QCLfVbqPfNuY0JYs/r9t49fU6zuZ0l25BoIEV3cdhOqfZ/iSdP4c8HacTrCrgXioNyN/N1j+s/lREIRu4ih7AiFvjJ0lpj4rWOI33Gi2m6+JP61ZZf61+dXndDTQi1MjyrpVAnf+TJHO7ExzyzQaAQB9w0IxfRRhP+H6m1a+KIr/gv4KkeARAvQZQQUsFjioJirv/NdUr4cz9Bmzz40CzKC7mzESEq9KRpcq65PX8urKxDCeHaivtY69v+V3+9g39cJm/e2c/us1fnVaxbvLHajxQN70IqSh+h/PUed+Qyh8mvqmkSyt7WmdT2o9KzlP3UwrHNqmk6rhYHCWzQEnoWUwoe5nNqNRnyDDkid5cYBYP4G/pG2depyR6Mc0y9tdsdJgNgd+zE/yhcyBc2B1HfkLWrgRleeC2GQnHg8rPmWc+SfkLqY1FNm9Qcr9yjhQb2Y/dA8OyA9h/UQ4RcfCDfBizs8ig9Kfjt80G77VNOJ9p5S+N1Mks+nkDfDNfMmtadzvxfQKr60P3dcz9SzmUyEBUykjMzS/7km5eBol5vyX8+usdhwgqokGd84NU5V3/VUCj0Pj+MfGG6TmWxLktCQ4RksV5lLKBDXeRZBf4VVRfNBdsga3adN7hb5d2xovpZJ9pr9Usnywsw+Kc2ZVhylZaDn2QKWs56/mh1uyRPHZkI8o7k7ptS03NeSRBBDIwee7sCdN3QJHM9jS35Rg9jdH3MShhSCqBrlVH9eQpvZQNZyZjtsZjAlrO4ZAAM/l8RUYc2PPt1TnqerBTzQvc8xd2z3NDBo8yXHTGcSGvjAsv2EZ8eQhLG6djPdN4gZPooJM+nDXn7eiayW7F/ncNy9y+NTg7s2xvtkjZcjsu7L4XVxPY4w2agX/C/jA0pIk/fg+XuzPAXvRj1O1sR09MmOK6Z2dZXffgsU1Rk4JZOTArAua679DpE3QcmJUH88V65U4YLlvu5wnzhI5iNwd01IHE2dOsKQTrlIEkoEwI2y4TJsfkhqp+gl6aM2Lzvvua5E3Ymvc6H4Be54xmbd7n5X2v3GWPrajBw2/Cy4DOSzSdIr5MmnUZAwKcSuca3o5j/67kv1fy37GDAbO6TQXN8+ZCW34vBefRj4pgx4B+c08d0WWAc4j68Gf2xGnPhteCgvlYSZAlceMvsORvprYjEee5Ejs/dgcLa5HpE4ri8Gyhg5DMcX7ZFPjo8tAJf8BanG7L4dIW1rMFuvqNn0YX5bve3bMMQeXeousE4cdFmhcLUEjpJt+Nep0+GzaSFn+34a6uEMd9xdsF7vs36TScqMBJOhkJDAFNNlMhSYhZNnUj8b3dokL9oCn7H7wpOhXhOecRPXOvon5c2haH13cnL/3eazMdMVFhyhuq6n5VlRUYb6rYnzvQjCfBZ+eaw+1C0l5vyAFWk+aPB9PPcdDeWmTcJssU+TI+raA/2FFKhrWs6J8wIVr2EU1Wot/MhNWO3MJVWeFVy/82brVKvdz6JvpL5ZTmbMKU6syf4YY43gPhPDi+gw9xhZ9llhd3WDuNY+u9ZXlzB1bnr3A/8noDheoaYZeYX1gos4SGNTVs0OGxiuEdmMwWcEy7+F3Zdds+ai7wvbT80SGJ5k00ZM4bgpWzoD2vYNPBpxMLg00psv2m/++x1fTKDuJh8b0k5Qef8LwAuq3jNmyRDpsphoqt6HMRE4E5H8Quzhl2jpMhfsRGX/+onHu+u8nm5W1eO2x1beN20PCw2cVRrsW217Z3G0lld/WS+8hqilbjTbtd/MITf9yJCftKjdaetzClKOiLPS18r1ZnM9GqeSUxx+rd3T66Aciv3iOlWbAJ4WO5lWPKH31HvvbMXdXxiBM43IvvnGlUvyYf59uqJlz9zjWNswm/7slflXgcSiHLX66q3pqd8uxDYWolxModFVe0k3iVLRd66vt2tgB5PyA7h48/RmB/gGFXaW4O/52Vfd0UNVSde6e6T0ouieqZQm7lm259kDOjeBxTKU4+zb5Ds5okSc3Y32vxHhQhjWvP/omlyMtJPCqY09N3Jj19+6XXzuu2L2rpNh69gRaj2XCD6BY2Gt1vV9rDkvxvBBvw5eaTOZ+g+o4m4fzy0hms7yqmSRWWXKvPjsYR2ubrm5ee4uqczGvzeuMK7rOXU5yXUkfR7Hs0y0gGqX0JeUggqHKfqFQL7XcD4LVUrYjaoJpP4gkyONsxMve3iwOpM+VCsz+b2KKJEEihitmfVnFZnEo/z9dkWG2opB1t8P/y386Lqi77TiDMigyplfOLySSdF8kfu2ZOZCXg9gnfSmcyGYenjYvwZxGyh4x6OeYrl9mqUSinrrRJfE2TzP4azXEXQ9BLR9lkNcpmqpfm8J5NUd0xfMnKYdVLdU936WvoS2MNnCS98nUCuvhgMq/3Y/dT5wMsStnK1lrqm+IzWUy/ttcTttZqBX3lswkb+9Wk5VykBBdfymIQKn5t2qg6RbTo1pqC+Nc1pLiGL0SkYzDJiiQUu7JHilIs4cySamUPDlKlemurFCNYJ5TCoOxgivXBhFOszzXCWJXqSgSsHI0VEN9CacO8pDQv/xNVN7QhVXxT1cVN3IeThVGDd0jDL/7fGfcIyPJ6fbBuD6wn/4rgqLp28hsm5KgcjlM3GYZO5vByZvCNkj4N4i5JKuvGukWSP6CKs2xoTqzMHMyFjUtw4Ob0WLUf6HecinzA813a/EIncJyZL5gP9B8/zVJv23NIYEscWFGpP1fmzyvz59jUBMD67xX6+wr9PUbvHUz5Ra+FupsHMraD0QSTBm1ljokUW5E8plMHdVrZ+ulkIh2yBM7dKx1Q93FCwUnCM60LSC9l48PL41LOdwXcSGakOPd+YgFAnvGbA/XIlrxj6udXw+SisM99PF+mE7hpuOVAQlooq6ImNNDt7PH7bPk+/w9Poblg+6J0uNuYM/2B3evPP7DpxmcTvUrJyn9oPHsKkf/oerfRbUQr/l8h9t3GD8ppdnFkhwgI8bcLsvns6aZi69kPWucKOB81iJJiEM+TD9NJczkr4ovEGavioz63vPnx/4vu/Nd//6/mxs7ujxu/f9octaPmgN/11vj+v+Ay5UFnMI5zyGLZWzS7wEFjx8o2q8xba8DVxE9EqlpxObp3PZ3snLM18YP7bajgfJHF+tmozwxgX3YZemaiToKM1+V2R/L0veueEOx1z5M7z2ThhSuiEFJYBGafwFSFK7+wkOlNDTG3PPmBn1UReV+8rUP+2sGOKN7I5vEgXayeNBBYPJmPYw0YSUiuPRJOe32+qvxQN3nFFrHJSeGZJzj/pDTTBCV4rDe0BnWHVeMztNkxUuGRByTFNqnXNStUuvJ7FY1Usa9aOlTFlmuNoVqpqCN+CefGPIbal/mk+V+3KptWw2FEA9pWlrDz9fN4XMP/DN+qUNr+xtPN0bOGkylIkFRPdqvdPr7sP83gbQCdnAHHfXF0ChZ+/L5l9I6MXtlXZnBi7B/gB1CBXhGBAXdIM/0AIDWidz1QPKwZ8A9+9qfHVmkGaMlIm1h4fLzB3Lu2TtkTNmcbLGr3fzH2Ie1IiJwtOH9Ysc+9rih4In7yH1wFr/s0jv78RPyQBDjOs7/lf5s9LRbZXK7zBKw0rw0o2OByfeLIueeYWQaHjawFaXfJJlGnYKm61n7tWvt0rZt2n+kxS+ihtBK306MtrYmkl6ZsRDBB9zi5SPgFnjJZb0nm53YaTroXdxR0y9ZLugqb0hqTAOxhVU8DUek8oJNHSmYCruycXd9SwTVCHIrr1W7DmuG71iR+4zQvUpTu0VuCxhqJW/8a/RCJIcPfs/iLeWfr5GFR28nrd+haWwTh/pVbAWxBKjvZ3hRo+Z0wUN3dtPcLCND8WoGWEcw1wVJilZ2fzGp2vwasVAAcli1TgRtsRP0P6JISu8iDIjUNY+1kOZEK8Vsyg5BA0Snmk3TRRPd20XvcAE/HGwu+sw3laEu7onP4zfuyX4LrEt4N+lrbN7MjEdz1wIHYBvMQx1m+K16GanC0jYt4mk4kMU4HXvrx0Dko1IAAcYUOwlxRv0KLn6a4ECGbDJkf14B/G8yHY8Msn8aThlWR6EiDlC7iSToANPEXgfgVGsJ9Kc8nMiGSgvtDwuECOaKVB98/96TBU+wfbocyDf8dErhKR1pJFhaREQcidROvbpaqxC/CAnKca3wZdK/T3/5jU5I27FyhdbOPNtZKNbpN04Uycxz7ddOUHNEFH75FSs6GzlC9UfbNxpqpNl9ny1f/sdq3abX7t2y2/2UTRG9uLKn8QFpsvX/DhM6/tpUN5Gj+W6ZA/rXtcjMwpFr/sc/V9rki37RyG0VvQ+82+J+TeMEKGGdDRx8a/NXYoaMMTFA53DmZNKG02XsEd0tyDpiyq6TFqs2V0Fa4s5Xip6ua/ZTgbvpXbqqE6Lo7KxUJckQ+UVlypc8h6yvY64qi4W7jkKslygiiOgrlCKHiNdKFQAV71aJj/f4WV5iW85OS/HypoavR7w0/MLX7VwlLleaY/Qv2vp8s9id2/TfreOhqZp+f8EQ86+uvrA3y89fFLkvTs/+jKF9vI74qVMrn7JafVbdGSp1zD4emEc2yRaS3+Rgz6WzIZsooW4yTPLqKVx2TMMTPd1yoZ8eDpFO+ZQTA8CopwNuVIIpOrl3lVHhnYwN6pIC+2dh4ZucyWelH+PW88aqAm8PVxVLNfmf7Ptw1jVM9N002Zws8A34RXXMLrbwUGZ0F6tDREaQyQvJ1tz8r28Jh4M90T/TO8Q9Pf7yeTqLLJC/EI8CNXqcL9jSeDeNJJi5um2WN6Eexu37n4P3+6dnRi4j1d3T00/O3b/aZMmxu/rK1v7l5cHoQQe4l89M3N1+8YwN4vFjMn2xuXl1dda62Olk+2lSO7yYD3ARAhgTJbb1eZ7gYNmTmACOukoC5c25rERusg2nD3DxggegbijkMXOT9PIO1X6MbdY0h+EzkEAqDg/XJW6UwWfHVLdGwfrfbhYY0bGH2GpFoEySXaP/fTjnRqZasjqebGpBIaFovj7LV8CvUaoQq5WokFh2sAc/Yin3Hy73VdYh00+82N6Ps/NfNfJjNJqtNdZPj5tnebLScxPmreDlKOr8WIjFXfvx/Qp/sxFz+8R8yW3oeh94OhRJ8/R77yV865QlYtgHjs52IGu3lebySMOL4ij4NjAjxpVSTP2eDNh4MsY+86BO++Y4/uXqEubXrdl9n3Y8HYycdHpHACeNX4fdTr/DjqYWGtRLDwV3gHwJXQR3DJWxyshCjabosFtF5EsWReBeAzRycgH0zlBqOOsU80GLzGd7L1fdO48eLVUuz5SLJj+Nhugzct4gAcKsxHpEUj4rxpUldeQJmms6aPXjOWqC2vr4tOJncBoVbmmA+PuJf7XTyUsgaTF3p1512go1//EgPZDwO+eD0M+StK1nViARxkZ0zFQeIVacAXEARn+n3Y+Nrfh2gfSX51FyALt9+H7ao/CikuIfpDG4mBceGKe6I39WYM1jmOkEdTWPH2U83OEFdcTjlh22Qboff2P2d2atSX5cDgMPqDHB8mFhAzpJkOEl+FqPVcOISxGC7tvStVlBjDDSf7j5xOZjuPgYXtiNGSLfTfayPTPdN4M0B0XesAtx36axW3/HL0f7MvntmOKnVd/F1rb4T7zIwZ4+Ibeky/Q6CUzECMPsnuIhvpbQt6FP1BITjUWpaHR7XFSfXeiEYphgWxBdf+TSw31zOFq2yCACrLsYjpgNUTE1flpxsE0v2STz4bcTX/JxiL8CpA2Wx61KgeHZgSMZHgTuka7Ddr8V2v4Ttfg22+1/Ptq2WZWpxil/Gs1XD4IcsXJWjZN5GqecsOfXegt5xfHH3RBIYHhYIloKNS/SbBUAwS04s6YzZsXKObBjHW8DYBE82RE2mFuWasqB0ZPHV2nG6pnYskF5o91T7pvLVhUfdltnjLleLEnXw1CDY/TUlPCixegPP1g2CFm4QsmvBSvsllfa9SvvBSvs1K4Xs/SV//aBkSnKAMBsuPsGPA0KZCQNyVNdUGJQKw0kA0g04/eZDhKj71qXDwwcVggEYWiYc+8Yr71eaDn8xZG2pnIgXbdfT46rG0g0tV9yaTCxn6eJlzFfIJBOmHDOBsAKS3q2UtMBHy43fkzzr2HI19azRnHBD3CZQEoTv68gum5VUCKUYo1ie17JePhxmnaBCXUHgQVED1YKqPVYtrApjRsMG2/PtTRpd/R8krLBt88CCIvo6C3dS36x5ta5t2d6bqFcdq+6A03bPpVlqBh3gNeOOld3JTxDWGsNL+x4TgspN9V0cdLxBj6pLKup0KVzFsCzKTJYBsNqJ8CgjZYrXYmRNs8tx+MZcCe9Q7rPOsYKcvxUvKNVifJxdveNBpwATutxiwmBRTOjSmkyIqFdJNyIAzAbGI/hAxZTdFMVrhBcEwmF8fTJnf5VxqmB8ZjX2zS0loNccWHada/XGWx717JW1UoL4jVS4wT6RADdgqF/NUD/EUL+Kof5aDP0S3nlDAD4zv3y7XThU4ZpDcbbIlnmNEWngqIGJqJSMTwMVHqYSqrZ7Y2FV+II0bLA9394XpKu/PWGZyTc8g9kw7hQiXiUOTyGi3J1CJFZgChGlNfQWb6j+9GZfvU/ajtCTzvZmahBqx9vks7ZLxd4Rc8vQx5NkBGlRjFVhRBjAo5qRW2ezQR5XeT6JB7/VioFTgX9J5GWeTffy0Xmzv73djvr3u+Y/rZ3yGDxNAVxR9Z+K4PX2Tkmw2G2CF7h1AXD4s9/dIQKRXX8E/EwVDRwZvcqTZLZDBfzMwaE1wkdEfC7Uo/TKrl8avOl1d0IhFbvICk/0dvwoQqOx3vKRXrSH2hZcuPaqFnHbOzUXS48fVa4eLFq2P697P17thFxnR0TYoYVLRGq7kY4PSuuV56Vt75R4TI+7OyXuy3Z4+t9eb6Kgp2fZgoM4/41sBTFJ9XZCht0VZSB1xZ561AY1n6oAQGxKo2WzuuNO2/g3M/Yf6a7JLWyvWDy50GzBCaseM3juMxB6CfcN6u93ifrNEvNPkoASgEh/t3WBHkw1ofMEgtrHSz68jvIMMo9ZZ8cTuOVOlnSOX7zdO33z84vT98/fn77GdfEkDIb58ZN2CCZJnPMUuuH781+TAcoxNikRAs17WvdG2SDV+SDU/cMBdfene+VpcfK0k8WLFOzecAhpklZi9e9Ka1ByJVKelifRzhzud/+9Zb0J+Ls5TQX5PM1RO7pqR2Nc0ZRp1M9pcnXEelHWqX6eJItFOhsVSigYtPN2Gucj7HJZpcelpaelpc/d0lHnpPx169dsJPzfZTxJFyuFcUrc3nvmfezoO8ZNLjp+GfE+m8HERbToklRR1Ow92Hp0v0XjVSJgYPxclLK+VrnznpNlocG13oPND+EPxLNkUkA3C82InRLR/fJYRNsSe+vrJXc9SOTz5aSmwLU40QZdtkGqDzo+y89n0/RPDf2xS+iUpv+cpJ/bWaXMMN+I4fbN+GjBYWzoNSLjRT4TkuZs7STvkQMHFB4xFTzfjbY6vfvoVTCA34NDmXtsAcVsAcDDgQr0sgSrdHvHsbLCxrlGdiLScpnsJ2rNZNUtCdrvmCdz5dxZqJuBZZhh3RAohP9o86wp2xlqXlq4hnNTw1UNyMLQ84ipyZ0+ADCWnKXl3FmZ5rN79z5JJnlW+sumGjP3HGnyd2DY3K90fsMp58/ItMjZCqURqqlJdqid0mfmLTBVxB2aTXrV2g6sRVs7f40sRnV4D+wWI8jNJ9y33znmh/lISUHvqAN4z6ItJalRBx/gs+TWRv3qtdxZoVHi9xZxdvudBVw7vBL1KvdXiFT91DrSZsFfRrZL14xoLgTf8yAp4EWAprfKvSMe32hcm1xgU+qf2XnCVnctCxLNucJAjDrui8eKAUSu7SwM+OuPbWq6dxpylOlb0tEVgnpcAg/mxh1ux8yw1cMaiiSs84pjG1O4x0SDPurTTuKrnqOdK1pUa/0m2r878lSkbJXzCrSnR2aFfWeXd4K+2y0kdhex7a0vKqWurD8gfI3kN4zkt2pK3hO6ZsmTeJ2GeksrKX3dNlL+X9C1zHmxeGXl74gCNvYWzo4wmvDb0X47OmlHx6w9x8i74WdH9rPkwjxNHozZbJqg6Y0WWM6yDZZYl2mRnptbKgJQtP+hF0VT844abL7rkKS7lv7M31B3aMPZi9aOR9J+fH1NkvG1TRKaxEk+48zaTZA1vvc6QtPD53tQH2B03scQWGoqp2PDdvS4M8m01/b+7gJf3AFFB1E2I9M2qyRQbf9m1TrE16nW8Tqbkg1Zd6+lvVAf9as8UNObhgw6mK/+D9fRt3GdnsWHGsFrNJj30BOVji/6qxhyv8I2I3JGf7WdUdRJDF7qxz1SVr/SHmoZx+L05K9tymlFTinSauTB7tEerA8M7uxeq+UI4ovXqSlEvsQAkSMI0dpwm6DmBm8gWRLGkoXTbCDxjY1vLWFXKXqMbKXUXXFUiz6AUS1/8/eXSgN+x3Y4Q560RoI/LKfaIkcucpzJkZjTzO0BYPc2vfIWGvCmIQCLNoTdajZ2ybxaffbfhSfP/blA90JERVOd6R4CQKB8tAklGkq2k9iFke/lBcvvepw8tUMSzt1umALVP5ulOW50J9tEnR62C5HDXNLBZBdbhBSJdXqY7GOSqhpM63ay39aySIbrMVLxDLU963HOIxwk8/Q5UnxMEv6PG8ebeA6C8Pquwz5+THcPXQ4p/u8EP8XrFx/3hMOgJ6imNJ4bgR30TWcCP+ZuEptzNIa3ewozRXPdOlr+TDbCNxbT6/p2ZOYN1rS7sDpY2V9OLJi+BwNfTlATvwSCTrXNw01VdFSuo7QR1dz9YXo6+h+jqN9MS/9oFS2JUYjeQoGhDvt3auJD9vY1xCu2yuMVSjtfx5OLgzQewVYo6HXnvvau/p4vmijWcNcOPOCow138y6tCZJ1ls7KoSPMYPFLMDPTjfnW8hEY8CQZPcIv4ZOvHUKw5mAykeL0R6gbqa0dfqSbEQgZUyiwWrcaWIxSMDOP7H50QNBEb/orNOki7IPfqkDenM16oGAzOsbqzi7OxXAMLCxDtqqGQ7V069eVuiYNi2QDghY+E+Lxo4mywDT8NrCV3XmzjHL5vAaUbOg+FBa/h8NpO0b8nVoYe5XKsDQ/LcfQmOj/10moGJrJJnpvTG0+TSXaVDN9fJvkF+8vE2FEv8E64y2xQdxu7wLhi5LgyLIeocY8pXkmUUD3o+gxmINarh0JR9dx4usY1rTdnl8zXJXM1n6f1ApzKErNGC5+VS8D7NjhoxPFWCOUXZe1tBFHobZnep7ZKDezHbmDzMjxtU1R6wS1Q1g4+1SMq8GWfotIPU3Hcg3uue4CobIVb5PByz+XFtTDkVmsg65Dnhui3FJte7iHaePDDJohWG7UlyJiX42fdQBiEP6L2bcszEu39Qz8hsV2ae2g5CnQl+Iaafg1wfVlNHeA6+8Z2/MseSn1rLG1TYwnrXl8NJzS8aLieA9cLwPUduH4AbsuB2wrA3S/hz/j0RUB5sG72w2l1QOaQ9X48SoxDxJPUrEy2rrlvT2YhHWXF4ijPBgxXbBf/47vabg/eCbePJ3wpufzwIB3BtfEHaTGfxCt9/aH9uebFa/+5aehb3jQUT5gJn8ULoQ000zYMZtnBJhi2IWqe3frLXfozzn/XaYbv4V1XmikPDDPm0yCY84BuwGA1byG2qjiqyUy2ZLzzY2KHoUsULRDnjkuE651Lu/NuOT1P8k5avIvfqWK4m8/67tUBAa01b/AjrnG0CSI/5uuuarTI1rn4z5LR+n0SOt5mgQT6hLot8YZ9AuuKG/fJ011KFuv1Cbp/Mdgh9W5itAS0doeUHE51gOhOCR5LdUDWMb7f8mqti+BRzQt0QPMPOht5kyOJ/rnGmmcP7z9S/7N48OZIl5Wqo4fUrLG9Ezbirr/2GhV3Dl7svznce7tTYnDkwGbDeqdkFFRBlZ8lI89EXtQ6NIQ6Xgd1mfTxZ/S+LHFC6YI47vMWENyDljc88FP3aA9v7h0iR5UzyN8B4lLwGkCfvPnPUZcbHXX5JkdWwqnpbmb4H5ScLjMqOv578U5yd5f/P1qH/iGnbUAepLo8g8PTajDQJ0nMOWKPyvNKKs99Kl+jSPFlnOo3QODMTDNwAog8NOPQea0efhh7hE5pQs8tQiAOxNAz1kJwwTBt+OZkq1jbCEZP3VnLD4gVl/52hJnFBHz0I9p4QA+XRE8oLGTv5VaFvZNSz+U06DrU7wB5QT1ucHWL1cwVdNK8DZd66xPE2DNyzXG7jNUkZrwNa9fGpYGmzgoSjl744QV3Vyi4Y13IS2M190QSvZU9P88Ke8OIGWLNiLtELtV3OS3z8SOo1POrzBpFVV6Kdfzm1etTzMxalQF3QkYd/pTH+4tmo9No2Wle6/OhXg3lmN5ToaV03r54eYpf9ZxTBxlChySR7ZKbOb7ny7eAxPZ6O3gaEls8axO/9RWHTwL7+ISOmsFmtumDO/T006ilQt5/8e70xfFtiBmnRmDZ/JsKVg6rJ07yySS5wNeRIHMDiZli/E3iYvFGjcF2wzsbMbcHJe+0AHaHwob0bP9QBedL0iiW50IScDXj3DrFE5gUBAtOhrjM9gR+FXMiB4TZGtknH+efgJ9Gt2EMEHx7yr49bkT//Cf6xixZY4P49gPxLWq0/OTzuXgZNZwbH5aB3X63U4OzDpCsOed83diboJGyEdW2fq1/70HKp6rbNn7/kT+9SXnLiVs32Pj8svNd80KG9pqOYvSFuRDbjlhJXsyW0zeLZGr2IvUXYV9wuFGKcLycxjMmjCFEpdsAIYJJ6PQnjzvS4Lj2lv1esst0h+R0l2zADtk8u1mcP6jI88TksKAINxsA0GhHjbfM3IkZh3AySikIEKCxz1NFCCrKUS0jI2GAzkEySPmT5B4hPupLyXAIIHIM40eQKBW9I/Kd7760XAWDOarp73P/4wscGApul/O3BdUu+clPh4d7x2efXx3vvfvp7d7xm9MzdTUfFPN3YD+c6c3zfzix8A/t6MyKvUPo9QObLnejyywdRl22wu6y1fQHNMCAxTMf5MzEJjP/Ll8QrGRGrIjUoc9Vy3psTTxce7KcMoO3CrPda0cf+oz3wzfv4L97H+xGQLj9A77O5Rqi6h/wzXIrceYVKFhfefAZKNZrjmJVNkrFya77bVMN+tNu7Gk6hcSOyyRn6n0U50VynBTLySLYbquVxXIwEFeL8UCYHVgWVLpedayCbLKUuc51KhGZqziOfqHimjZ12Inzn8fjH4HeqdoIE+g4fpzze6uU/8tX1tP5FH0CH1XW+r2op3Ng3nIGZPjvPX2hF0Coew6CFA4pCqJoyozzuPioyB3Cz2brUwXBszM79LVSoQFG4iVb7J8lcQ5Z8XpHcIdgYCWdzOZKOcYbcIUNqhnFhTwGbocFq7ZQa/ePKfk15CuoJMrY3osVH5dF0r//2lYKxT5/yLbbQD37OlvmBdkCm48x8tXHWJJOxM9lcdrCiyirZa/1+sxb63BeGWdI2pJRU51S6b3Dhs0DR3wW9Xq4ZgV9FIK2jkzLuvk/G6yMQMFPfiAUDGvJjxUTQv5SrhNTW/umXvcdprPlIikqVbDBX4Ofok6c+p0YZKNwQtAeGycJs3fDumwUiI1iDTamRc+Rh+DEkchkkhZ1+elwsWCGpoijrRYqUMvzsLmYFt0/k8F+HQb/VA63qnp4rFNQQnYMVw1jmnjbMVcXFsK70WJuExt78seBSLOVkxZcN6Z+nJ2JS5YVMwzrgfoFY29LowETDzQeU0w+9B+ZD1340t9+gL7wT9s9TWP/mDuWfU0mLY6TScwv64b9sPuPDF+cs/vdx5reUPrWYmZmffQ2G8STBDwSc1ws+2nOVkD7bIkOfeeLlUeZOTUTj2bmlAekoSe8wiNZqFvF53W4I7PxazwDZ/4iOYd/mAcH/8TzXPxawT+/LmfinwkvW47gnyKZwz/ZYAH/zLJL+GeYDBqfCJfOcrHgepp0EP10uv8uu6L8yTMhHJ0hI+BPs59m6TWQbQ5Z+YL94eCqzzAWOBw/JpRsOYQgmUSTWrI/MCkYW3qr2vDBPD64TcFCie4CcXsxvXDqWuQr7s6Kvj3N9s4LIMrpsMHlO39Qb8gbbuq6Aj4vkBkK59PoGLrekDk9rAggbD/IgHDFQDDS48PkV6jYrQFmy8J4yRPxVCPMdPZHaaTMRyYLflFGLs9KWncewGetylHEVNk6YGBw84QtHAcJB2rzOKd75REw/hI27X3BQZcGivgt2VABW5imi6YhDKYwXSirid9qsG0afSLZYLIxCx/6xC1H6QKuqdDN33BbL5nPfktmIE8BLvncaDhungBTtTJXqGcHgkXvzkHl3kBaEAf/2P3Uoo+/udT6daj1PllxMaVxRKXgwpXuttIV9OtV0HMriNQAKW//d6Z2o0vm5mpLQk7nPVmn856s23lq8N1W99WiF6EBXtrTRPfdbgURsioc8OUki2mlMH2IB73Vh46/c8cAgqejuz403Hnn8yQF0KkWxLfET66N6DdTYfSLSwRDi6ajL7KNrVDF3DIXyLhD/W0xCNowYFo2nFie8XrbStJtLUkRLmezHBxrVB//FygeCpnDdKQDLWpmcOdfd9Yywna9v+DcyRYr3E2axzM2Jdxs6uRzAJ52uGF3PS58gSsr1eP3ANv9mT2Uh7baMTRrkwzdDGd0Y2jtw7ldafQUSfjebnQPzkU/enDfnLgU7OxyZrUH37Np08Ivr1eJx7RkhvY7BZQro9d/CRmBiLYe/DUldPiXkdCDv6R8Tmz5oP18CSlvhPxuHYHR4nIZ//IdIagbmq/CmCsd8oVZpGAf2gAvw8/YkPHTpwnhgdqRYT57S1JcPs4ymzl++u5iBbYbbai/vRuKFcyzXWFX7FADnxsVyKaAsC6Ewmv7oXPQY+hzsiFrYQqoD72ahhvJGgaNsAyLXg+KO2SjH/nfT6JGd0hJi+GDXShtIQB414Vzv2JIBFXEHY6CfeYbDG0PzXiLJvo2LEjJ8ajMmJQX5+iG4uLNrZbWmNYtpKc3pMFYeFAu7wd/mrSnpLQf3FjWD+pIenoLklY00PDm5zZ4QrqhelfkUaD7HLiV2SHZj7odZPEL1Ec6objrhyodCt0qEr0KEr1kY6uChBMwDcDammN6DGkPkn5P95zRnEJbfq02XGuKRoXpV+FAeciB+cTxQTJZxDAftKPLNLmCEy7oEz0bnIyzKxmhP03EItaooAPwmvV7ngzLgciyQ728cuYcKHwtl2hE0UG8ckpAulZbeUQEK1Ulw1/ChGgyvmBCJPjwhIWUJ3/XRNlSqUWZG+gQbXvCwWKtRVtMliHizoSNeqbaXEHflPeM07s2OoWs+qMU0ZhJWzlLkfA8FtTbCm+hRKXtzfxI/f6nCrWbIL+pyW13y1w/aOFOix6JpCUdRuzSmCGEwoaWMgqSt6G5ZEKwYxsWdCwEemCZR1HqWMjnScFDBBd1LeQiTy7CS36TzIGX7/9q9lNTVLszRBnEdAid902Da3r5+kXmsHSUVqFJmKQQwq+J3g+g9+uhbwfQt2sy3yXx6/JOY9dkfYvG3qqHfZ/Gvl8P+wGNXVdqgYarU3zVLQ80vSb+4wD+g5r4vUcBAqygZgseBJtQk8LDfrARdVtxP9kiKTyuS6HfexAWRE0a97dCDdmq3RLHP0E0HvZrt0UFPOkhyUrr07pfSuv+WrQeltJCIdrq7q5s4RrU+o8q27gGte0HpdQerket1yvvzN6a3PX75aLb6q1H7/79cuE9WLMvHj0uF9/jLZIeOeS2HVATRcjhpYpde/ejIxwjeTd2Z+/5yfu3P52+WGMxVrHQCi+UQosca3nirHPsHQ3LDaqEVE6RC8gHwgNqt0TL1V4F1VkH+QRodGIl5KM+6JK4VWh4LVSyGvIRrdVQcD1EVKiHkY3sO7EUs9s0MuXnCpV3F2PVKycLj1g/lS/YQtgh5HK8wsVylmFOG8mqXRLW2qwGgbHbGxLgzq5IEdOLOAgsmM5olbds/9jlC68DaZwDTxqiplKkQxeJD/FynLOzQJt3DURAgiZdL2iFNaxtZG8S6uMjo1WRAWkOY1kVWkexLAv/7c9iWdU7h7Fspjs0p7t0C3boBgZOY9HTnBUccOg3GwoKssT2znnsIBG7jjY1dedQOTUFxQ9FqUzQRSYekeCTkqEdkokrC35Kys6hhDNSblalOCEF+ZaH/Ma34FmWaTpLp8spnBa8hj+ssy2H+IYg8YWTsr5wGEnGg5RUrXMwgqPX8Ww4oTNARX82D+ECG2ASX9wk9moPoVo31+UQpXLAuIK9D87GRsThd9x8UsGIIMaABNLdqClqFRvd/FllQeZeEMJNST1ILuLlZIFu7ey1xV1tfesSqtU8yS5kAT8v1mDTV3LBRtqw4dynj0B7Hqi74Y4aZ24Ja6Mbw1Dmt4tgsdvzdklqMRKg2tdCQAEq0finqr7vKi4YhI5IZww4HcL+fjxNmMIX4npBQcLZaH6mS/qopBVSBqe3nI5NiwPR1Oalk2N8R17PyBXTwdrPpucMqXnI6B72CW3uUeqMNbQPAIAMiuhlLojiMvyexO8hfDtaWlWTICG2IzvoLkj5E8ZazwwyhcE6qwJDXIVp1fFMgJg7QOXPcB0VGKqO4L6c7KBf0sVYjBHeVd5NnDV7S06K+AIldLOmbEMlutVX6LZUVVDZ2bj+WiqhDTTcGCofqaTMM79mfD+br5oFcz4HCf/djsQPfotGm1nKYpHO+NF0WYy+SBixQa8ETCVCk0+8uqQ/upThUSa4QBxx9xExx4s78tCq7ZzgiXFuzYQwWcOxiE9ohhvI99LQZWhzZpuYlNg8zWwkr9m5X07SMbe1z2WegrbISPgdI+k5vxVOk+C/PFSLq7mVDoXCERaP8sRxFZeYKfnvqzyeLSdxni5WNgOALG6Yn5OM9UhX2hh8aeuVkUd9Igw+v+eXzUINp/NGOTo1wtOn43yULNSrdpo3lRhyLypvlXXUwMN+iskT4uvM4apAdHPkFzXCymsFAUFmLD+6ThzyZlU+X14wZ5D3nH+n5eViciTbTBw7MBeFlR/T/mAOZX8wzw+fma9nU200mMoup3PNCTD+mSno53P2vwH7n0yYgX7MJklnko2aDdWySXKZTPRRtSKZXKghys9p6O9cSoXpuUakviGwRbaIJ6IxHET82UDTHVzzc21t5QqTIw6csH+ekhWyEmyArJZEihPOh3lKIvh6taL9sfjUmS/oJ+dwDc3m51ipL8blwyz91OI+GL8qja0DABRfOyD/eMIKOtc97g+1gU9G9Lw+0fMQ0XNxZJ9LewgLnPjDLpDHKUeBKuAKgg3RIfjxV6flg/pMDkJMDjrXfavlw/pEhyGiQ34Rwg1b3ldv/NBywfJQGltCzD+a4E5lqZhvYzER82EhXtnD1xhI2u4khweVvfD7MPVWhx+m3vLwzIc686GQ1bILNLPO97R4G/McYvdmB2bQpHF5C7blNE9HI77KxNjG0OxGXDhOGZ/0WBmXWIAb/TfFlQptQ0/MxVMh0tQXTSVpbLpdC+ebbtuIgXfjoOgjS7hztMYA0ic1NXeu/T6rAXlWSnPl93ANyLB6USphGWwgCjZbPJxd4IezKePrDp4O6Vyie+X8wWYfu5p3rpVNB8m03Ns+pbjmqr0Y7xmaRX08LjwLD/fUXHUKISp8VxvlEqi3FjwbgG8pnYDnwseV/zDSB9Wo65067S1pkvs8HR8G1Cm4STIjusPybnW/9S1IGBNa7RzIHtXFUBXg2LCgaAcyoNSz5QsIz9zzdpx+N0wfv44UWdTnvQ5Eq+ZdLF771fN5X4D0jBYZq3TXULtpx/ZLerZf0rVUWTwcvkuuXkzni5W0fs26T2Niu2AJWB+7Bc/V8lmx96huGdLGvO2LirgYyl7IaGThy6cLu5iagiI4uxs0+PZ6RUiHz1LWsoU1TM1NDhtY5fn+h2h+5+D5qxblm25sbER7Bwdv3r2K3r34JXr74ucXb7mbqqpoOUeZsUwVzFdJslSOQSkCP5+vhdLZjk8XzUw9Czi+LgXuI+BVBWUot8DLaUM5Ah+UTFn11xhftXygxUE6jWjIUYAr8Wg9FxmeqGgZOojr1PFMyNmpo7wVuA5lTKT47+2GpWXNN3RnuGfcSP7nak51z0erOcMZxT6mc8rcnWvohmvKcglVASXmwOu+e6OtgwY2E4+tIOGyxvClzTPUBto0OFfMMotZPlFIlaYUzmXbQ6I0yEHqO0irGjXZ6l2irS5afO2gOebCnfJDk6TEu2PdSqwleZLCHaz8ZVElTy7AthBJWzSyLZhuSybI6YmgJAgJOoKMRQWtaqrmJ1hcPxMxoIgOAvEZqeA8iAWX8qka9gQjR6+IuYkbTmJZu2Lbj3TRDWnpluj4FqWet9/MBOh/RfuWk4l8awczfpL8fcmK03jCOxECyayRrxlz2P2v1QzmSojXatvIlSAa8/NiIjtr14CgRQiD2dTfjR8BqKfvT/feikqKXTKy575ALv0H9bqD5TfukubnO89DlT7YTjCSumsNs8BCKLBGC6yNAusif+lrpxqhPqLnJx3YsNLP3K7c2HgGypEMo16RL6LLNF8sY9Zr7E9d9279vmvtEIu5O6h/nFeJtUf40ffcP3UqtbbCeccBE2eXIaDnlHhKx6vKL+ARxXlHP9r9QQUFuZDwQMO9iJvyTKRdOTTYZ2KUlrZg7TaMGSxryCIZLGDr3okp0IvFGsu6YJigPIZBRQ/KwyH0KCnTvW+ifbb+2UOCNYIOGQVEoHDIcFGZBQmYISpQdNtmpVTnhM2BmxiEiP8Yy7NW1Kuk/bUksLYM+MhiLk2DvngoNPj8m4d8Ff+D1Rsql6xl+SAB91CMf28X0l1PwQQKGyouns33Dbwcs2oqdMKC7YKH1ncyCIdQzcpJfZBrm08yNPJVG6V+wFuNQaJGVRSIhPN9ZKS0Jnyi0zcssf0bZ3G0lYnhum7t1gcTO+buvsNtpnZYHXOjDA/D3ho5Hkpta2V62DzeNOFj7s7OFoP0+4u3wY/XfV+ZIVJV+x+aKFJVOc4XEZkleZq4GSPRskhyKKXfAVal+OlhjUG8PqzK8APEKJsOKjyMr8Uq7ijJOUuFW7VmtvPZB/auTCIpWqyV0nM5Hcl7PXlyKS0UXew93lyCZMqpd5XncZ445odPB8Y0uQ/yIkm7jxKv9q7TQoUYLaQ53zBz4SfJKJkNj8iy88AbzbP4Mh3FjHWa5GVapOf8bV5zlEuUDOXb4sQG/Wfn4V/vtWf238FvM3GdVs9vAbruSspoli7cj6FshoIPJ6EQpjXcIPG+6TCpJuQuvJefJhKBoxg2KCECwSaiiPeJFboxagS5qDjxvWMlibe8t5nXRBL8i0vPEvOsNyit0RRaaU05NgAIy0uElamou7hqS3TladzvMrYEGIxFFSh1O/QWPKHw7sPnmIePLvynzt6SkR5nzsvoTKv9BDoxfOjHgeUwgCug2UBqIn1uu8prT0mA2WHKux+juwJw2YTp0q+ZeHCFkebPGP9v9rtzDLlExJEgjYobpMc40Sw0/unGWQaiThPVM11S9hIfXpTqLPJ4kPC3vF6KExzBFuhaVTtyeHbbb0jYiKnGcyNGNPzceu7ZfuwZP/V8kk3SIX7hmbfaucbboOGqsZ0kOLDNKC1919SqDnAfuu91lZco+OvkydD+MIJH1O1P5zB+2871ilaTcPXWhCdMfGC2E4XYaih4wmsws0Vg8LKW5LEzRNVEQjOgSjEHGoNgAU1La/DAZUgzMFAP/6raBSxRtZr13Hq/2Wxd0kA9ogOekCrGDTU4gdnhKTV34lngVNuR6ZLNn+dsLoWn8lJ+So7TcGZS5Bd8vRRLxCGwaFmIMiwICU10ufZX1tA1cGYCTjorsRx0gKScc+EO1axzT+zyyejKnEwJ5RePD5KmeJleB2Y0Dm4AxDKO6Mx0MsfRvXEVv4Imzqzpw2q+1aqO8VB71mHggd7IVi0ac7dLRXzmbRH495tm3ErSumO38+OnHbLIhL1UdcrQa5A2GZnzj+jZVd4hZj5dCrvSdEhQtBTpiSyxtS3s3vpnqhwMCG9c1/V7Q9QMCpBbtZwjoJDlt9FzPvbRx5rayUHcsWL1o7OQc+LrxBuEz/BzU+K5U1LZemX7Wn4mR1epsZU1p4VBZzEFSIiUDi8VpBKr/8nsO2iJz29CqYco8TsQBTV+JSm/rUB+eCrCy7oYLmOR0sMB/dJurNlVNTuL3gYyg7Sinhp1rCNKFJyjAayAc0CXge3yKIvczCQjG8/KIzREZGyfLaxnP82b9kDLk/NlOhmeKAtmX+SK57p4+CtzLF5NsvN4cqqDPY7RCcyLfi04U4Lou1DGftD+36719626m4Vq9btu53A5ndONLJ9FwvmJukU47O9s/2s+008dcXhMtAJsGpV6cpf9Hw8aKG7gQ8M0AitLLbcjcLSCyf9tOuX+U7mi340ed/HtyTj4W9vReLpLj5QNzYczKDzA2ntdosYdcrtNenchXHfZaKdoWwPcZxvfxVDRVnzLN/smX4df13XjlTmkvD0FSb7iyO06LqY0zW1VndnLWZf3FtlJFdWL1g1j0/Q16961BRfSNgRkns5aVCVqo6e0qtK00ZtkVUnaGLQiQTv80hadiW1tVE74qn5J7CynzrDiI0MkM3uAuoXIFFItTD1hKLrxtZcCroCxt4TpE2KhULwjq78KAf3KKhQNjH61E8yBo1VZS39lUscu06qsrb9+co9Ircpa69MuaSem/cX1E8xaRF5IsdBpvV65qEPn77qrD0lg5RDAAJyCygAGLt7MiiQXq+WiKbMb0ewlvuAMCmraIiF7bnTx65ZpnLzQXjty/bULNk14RS9y9BB/CTcmnYj7DiWWXJog5oxFgJwYG9oWkV7YBEr7FjXRT3uL58konaWzkbOmVMUveKxHldzQ2vgLupRc0ImqeZY9wV7YpoTbjC0BQV20DknbW8yl5AokpRdzcjVB8i9XEXThU7620/qADQEhiLSkPmgRVRV8F7UoNaIqEfJIQ8s7v1FWPKGOx+GS+NQJeBYhQKuHq5HwIYDgNSSc5Bo8dB02Au5NgBs4x2OhlzooNDCKlFg9X6M/KlvLCKmGlgDwpqwnB4N3iyKwjlDyitwN+hubrYDhou0Bzo6RlvipZVngJUXFIHGO1V25pHRcWkyo1jki1Gr7oTLqMLJh4Tu6ejtPMVDtOt303R82Yd8eUWraaIWnPLuZttLcpg+RGh/iyzcIVlWEqsoiS+bKMQDQ4RlmQs6x9xejOftZdO4vIORGCA5kY5ynJTg9a0+7i7ZvrBwxc0GcHbPSwy/LF0jGTosopQitQ0FXxDUOKXmNA1qQBJZg7golVyG10LKAzKv2L4i7SGfD/UlWJIXMubluR3uTSXb1ZraAO5gmsfs407ue/aT1u779+ygr7MTSmlEqtIH5Fb7ltc7aod1DNiCudWBqPdfOdU5lYIKkZCwvFhf/3Q+us+3zsjLk9g4u02FEyFsY3jFarOweUH32zD5tq55U+vhODLFrO6mf8/EOI6DgJGL9HZXEL/r4Xc/mGGqEkqf2doKlEHryCSsZ7swNLuWPjIQY8+qXyPWHcqdZUpc0VmkDHWBOtPThZgaEbyBRXO7uYjbrM+Rhy2a11uDSXOiCt5YtrwB2pnaja/uTfM1eMr2Cc142FytL+KsWXAvrdAjcDdv0uwRD4EplQ+bVV2QQyhGyFYt85exFExEyO40+GsSLwThqJnj/8HwJ9yi56/IphwzH3ogbeeGCrPi8aIaDgFxrvzpmN+yFa0vp2iRivxqx1BBaFLmZ6cHQdG9loWWXEhfWKNkNe9Rpp2F/feol/BPV9kvmSl4PViCe9DyBF8Zr3S/2jRNkO5y1/XgwTobvz39NBoui2dqpzMdGFzeGM8y7Jgv/NI8HvzmXW4t0tpxVecRZCaW0GQgrMeibZPD72epti+cgFTfzKpkF878L/lwCk9m7eJqEAPgLyYt4OqcAQIWPGFNpwSyfyBj2ssItGLmfJ3ulc4DLOkfHL/bfnLx5/+7zu/dv3xy+ObUT2cUN0+adLPFdbM2/lRHXqG8VikO1jPZBKg7hALaVon8+2rez4HV+Zx/yO/vb2+Y/luafZ/kwyfcrUugFVDCRfh4Ph0JmPYsruD0+HcSTwzgf8XC2XTzO8vR3eAkgBHA+eh5ITaTT8y4yPsLcz1jhwPw4I8K0Ar4cJzPWVN5Bcw9EVQDJtC8zWJ1LnYbidvRIniTE40wqLj3MZCEeZQqeGGRmDPjpihbvZCagNUxodiwQzJSNS7DmjsGbMqiHaZhBDeIyaHADDGIbcBMGCTMRsLk+YJBODQpWNrKFS6UkO3bKbeiAraqXi+Qz2Zg1BFJKx8tYd7hay3y6AZ5ya03t+JTidTsNO0FcGOjQbCpK7QRxiXHTxOUDNSfUy1tGU8hNtBjPNHQjMQRuqIV508Yyv4ots2VUol6DnbnxRkPXnUED3euCWf3s0QjJYLe6x+U8XrPHifnfO34oXQC6YbIQN0fBEzbEeBOerEum5OpeQM5GgE0DYLGK8Ch2LR+mZip/bXYrDjM4QD7b3/5gg++t3Z5MpKtHy0IWYhko+Ju2/Ui6lvVabhzRmxgJ210NHFGyYKyTSjb2TRssXeF67fUc7BtNCI4bHpgUHChrYnApfJPGE8uHmzRfWjTqoJ+ydfQJO2QKyeN+0oqGz8hJAuudIK0+P4rMYZu2CG2+W0mdRHRO68F6h1YHKCGekENunfWAnOXiffsH5Kzqnds9/n/23rStrVxZFP6eX7Hi99792I1xPGCGENLXTIFuphiTQPrk8hh7AU5sL2/bgJ2zc3/7q9JYmtYAJN17n+5zdoClUqlUKpVKpVIJk1xy07nhpn/d3T3P83EJVi4fR2dDRA2a4PRBuUkgbof7kFfSoq0Awko8snJqbGWKrlxKQpgBo0BZTsSZBanEmgJtJrwKcRrM2VAj3KmQZ8SO0afDn7UBrYWUTWRuQ28kbSvZmzHawQ251YqpTugLjNjJC+8v6k5f9frigboU/2/nDKZXg42L/J4bwhJKuyJs1n30/otY1BOynZ3A45nUziDLTa8z7c/jLwzL9lOZGjjtwCSjb+WZvOYaxZWU/nTGAiqnSNpKJ/xzafO41To+xDUiYof2207X+t+O6b8d00lbSi5Ynj0lL9U2laKGgxYkvY8hhouymxZeiEkR8A5K1Kx43Lbkb3fO3+6cv905f7tz/nbn/O3O+ZPcOcj+09w5whb8+Z4c0bLhxMGElizqNiyC162ueLw20uo92NkVPhoTWT4HhbALPAiv+UsLsl7r+CS2Ki+H2q1otOjGEFeb17QrNfff7cW2SwFEw83eza3ZcjwGWd1VlW0S4hEgGECzGU2n0WDRjy0BkcLhrB07CgoEUaLGwileSKzoFh5vzWELr2/V1Rb+SKTV+rfcwEMgxTlkQvwUDcOJP0xDwZhxGqi2J1BDQbgoGMPzqGQRuQ1BUtwU6DCYAqO2d2mryLWNfVFbQPx2et2C0uOy9NYesaQ9myvgvhc+jKKx2CV+IH+ekD9Pw+mUmFi6f+J8zEMhTSTW4Jh5Wq3+6vvmGK8DX14rLk8B9Q9U0T+a4dC5G0+i8abLX6CjWCqL/9l5QGm4J7M15fwsXeCSUuOsdeyguPpYin200oyMwjdSdnU1k+8Bs8ed/28G3UzytFCgls/RchWD3unJ2e4N3ulv4XI4fxPererf3pVkP0Il1pFQcXgSKjGuhMqz+xKsSezJj2mCabkyLRyuvJkObWF1JXnOpOiSpldiMiULECtZsqzr6IaptJ4gGtVY0ag6RKMaIxrVHyQaiULhEYcEQUgSgSdLtGczqqF3b0gNCtwphVUn/BtThOi5N6dq6Sg614nUW1Njxvk5puaki0jHxDUyT5vTv0jf9vUQaaDDBKueu4VSlWOZRLUcIqktxM/n5NOHJIbclsvtadT+WV5Py954bkewW8qu4uXryi9ZXj9Nislw5ZKwP8e9fvW0Rc/ochzhLb+TvfUnOdlj5e0JnCE9E66CPLNA6aFsMWB/7NHdUjE4GFDPZzFoil9a4pdN9ostsGJfV+KVIbGi+PVf/zI2f6WmAmp6gVoKqOUF2lRABm1xi/53x45UUi4Jd+1bJemScifUpoTajIFqSahWDJQ4OEcj5oTbE5tdPJpo6PebB3L0ye+zYkD+nReD2acoGhSDOfwwU9tz1ABOEMOPdU/5nJXPneXfCGp6GRna8EIAirmA4DklxtOt9ojM2RBIPoW/+VOtVDEf0pdu6W/tmYf243GPcLbdP+cVgAz+63oyPM1uJlqIhec8cnAutpqSOrc4xlb+xPnqYrdvoDg/KS/P2aApvpbc1Xgd5GkRilaMjuchBb2+GtdoZFb0tihdNOrtBgYT3+aPOIyB10va43fjdrdHJpjjVKZSNHYhmY5pMp+LSBeRdiqiuYt+/tGI1rxxPqIILrmp3HBTv+7unOewxPaXiQF04c7nAIIGst5NowFksWFrso5m/2hvpynjYz2YOBAg2x/ehuMeGdRxNAgGhH9UbhlmHxvM7lN/vvLTgzcfe+2VL/+wPXZdy/6pz6NdjuFJn0q5nL83mqNJB2gpOBWDX4L7gkoyLB369CbcbjQmI+CYqLjYTNqsO/0RoOYzxgjEPha3WVmurS4VfFXoy0WNfu9myB+e5E7ByUOPJpXggW5EICmQmiqd9iTk41NqiWJ6jPdaz7+lN4ebQjlUrsg8+7oei3pr56i100yNvJIJOT0lS4276sTtUIbmoAmhOIEsDND6Vrvfv2p3vrolmZGJ4bBM20g6/Bddvm0sMKEMhI8/H3u2IxRTko1iZzcy5DGYodC1srNgf9Lk5yuu+nNUf62qhYESmuCqK6MwZxZRyaE5SpwSnTKcE0dyFoPKWjU5nHObNNgMuxkCOttkd/dwylJ5192hQvXYiJp6QshJPZ3bktKR7Rwm4e3Dv9ohhrYFMEIs9c0uhWSyI+ABDm9++feu3AYJUS0GbbLsaujVDDEPF93zABCUaNKX8JrQQ2/Hkn0d+bAVDWH8QaRxcam5c9Bo7X/YgeRktPa3cBwBCKTw881IPjnUYuun6VcZoBosGg28lkVx8eAJOWXS+GGe5fxJWQFiUF5yE8S0151nVJl7l6J/6PFd8E3Gxw7PXMHDs7jo4dgRZ/DrbtYU0vYAPxc7FjKZQL8mXKlE+3UsWGPz9PjgrLWj3a7Q6NF4A1ms7sXYpp1dJp9cnQFx0rNsfSIzBQXY2EpQziWcEKs3OWof5XHdgsrpZqAs44r31ms+Hi2jp3c1hWVxQ2tFprcyM9qlXM9dTSx4mnjhBk9WWI+dc6L+8ZA6akzJhfWFum2krjfaLfq5UHAF+Yt23J7gUoctLeYDadrq5c1afO+d5iU82dOIMa0kwl+Uv1SNiC7rrhG7X08lKHpT63bGZFMlpRxknI5NnmHHK9i5S8HO4xTsXJNQsj0d9IYs4oX91Z7BQ0Ws4vOpWmLRei6akRJNCQKkg2xuQSedsvuXtufpBDXL/T2hxWZ3WB1Pn4Tpb3XMu9d5ekcmxOyetvCQKJxAE0pZWy07XQ1i1ByfS5O7K0Y7yFFllT78XNJT/Px5V2uezrw/51DwObc7z8WDP/8iz/QHXOTJuBF4dt7KDbabq7IY81PVcUgW3rGj7j6d0v+Uq0s/cs34cVegki8sPZ36H32TKc29o2fQVn+lC0lKkTvowVreTZK+Drip0sJgVLzLd48y+avfmcLrmIMufZlzEWguhDGUVlz04PpPOrRkGx3txFK6en/+aaVs2thicipLNmkbNrnrdk88R5P6CRAfBwuf6yaX6Q7312XlUHsrhFzqZn18G8pR3XWfyuIG5gI9peQnkHBEKQ8jzXQh/3PTRk97035o5XL+s33tlarjxgAl1bO3gyLdVwewrj0d7+9jwsFTKhQQq3chmee9DvhlnlG2vvlvlH3DF8ka3e4nmh4euSe/cXbTAleXGe81G40iZa+6fNM177c/524dDf+9BZvT47hHALg9XM/RJCr+YRNNbyPdFvFm3Ou6wynve5PeVT90nAHRlyogXuT0ltjojlNQ9jAoe96pdNQ+0spoUJm7bMKed3QXes8jOwm3puDC3DvSTRel0H3faWqdXQErmxfAoI73hpRHrX3jd/X0ZxKeT9n1xRoD848tOJq+K6TWjIXntgM72ALMbvtxAXWQIUXXRQqSa50cOeJF13D6yeII9Vg8OkN8oXi0UNvLcXjXJk5ONmPf89J51BczA79nW3A0TB6Fh0E0lafVdSk9g0xN7VmNqpHV6hl9d6klrS5SgkaolENP5tHk+K66BhrssD1jfYI/uDsctBcm9yU79JJgBfbMIf4IFchHCQJvdVm4vMk7CHw+Fyyo6iXCFJHgfSHIFYJOeziMqDPkhhj2kJJ8SroWgJrFNdszs2auYAvMQG29L41Xj5neltgy2jUDn+dgoDsLBq5MJ5ihmMOSMPbxApZFSQUbwa3bsPN1uzdhbgPt1TR+fXwjQGjwyZBvPJIYLtH5GO56tHrwqFwrhGPsoZw8FVFDOAHnm8CQMtWYHF99hOXYZj6UhHMj9xir57EnHC7rGIup9agxfrOhOl5IGmHCBDXCfVjh2fCKmSgxpZpPatJkfYiDmEKexA6kREvnAJDJ/EzpYYWnkbEvnSVlDBOyMnLD7TEdTThCcB4e/Pz8Xz8m81cn5j6tdZPWe4f22e8qCoPZn1gESs2UIrSGJ5kIN78fIx/SXnNTI4sxOaqOgx5s8lsE+bdDKUlNuHWngZgk//wbd+ZW5nn5kcaZwSDZ9sUNy8o01we9snM6jUanTO8o5wfeS2vDDg/PsPtPOLqQfqU6Gn9tX01sUPhoQXK9p39qj6fWt8gEG6FMxGWtc1rgjuXZESEnbl71ZIyKK92Oazb0rKgWbYfDXtxz7m+0WxAS1rW34Vl5vE6P+yKQWAyMMCIHgdb+XeDWQkY79vUpJzbSqAvXvRvXdD4Ko+tAftgIcndE+K97w7CbC35lbQWvBYB6NhG7yRICtLib3qS1qBMjJxmyQMwtlKqsLCLeuB44OAk79E2uUXvYEug0Ysr+0C0yfYAzOkLwn5wNezP4ijFp73GyJ6ihfonI2S7RLRf0dUnDqFrM8TdaKdgh0Rq3tKDiBBRwxEYMLVQBhtiL7sYTC+R1DpM4mSIKiT64m4Z6Fbz3nOCImYoyMimSXBnankzV41gTKn0T+tXRMmr4NCQzpYuic+kLrRONtH6/NzHBAALwE9BXQSWsacRqqbV0egitGBRagkze+ivcinoHO6yAS7PCbm9GNt61ghk+qT/UrfYWrfH8pD2ehITJ41hBjxPzKUfCqCWSrsSe4tU8PvFVG1cTkDAq36KqtOjiboQammGC4F12ndQ8SHGSNULTG6XtVrc3GfXb82sRJpbb3n51ePjq4iK4vX09GLyeTErX1zmzXuvUqtftlvQasBpdMGcsC0LbH15H6ZZbVmubrHGDdv80JMYCv7aXE2FgfLW70M4vxLkhPtv47xQu8mLQI6pYbnTZmafTl64tBlDHXDxueze3fTj8g0jfhNTslPjS3viblqESAfeGpB/iCjtuBi4pG5/4NfKyi0L6ExUMr3vCs2mOjxacROAShwLbLcimAuSanaUh1qA9No8OQS2gSgwAs6RKFTydaL89po5gCcD2o85X7gnRJ9FAXS7X22M2nu3g8oBmcnjdDRPoyX4ykiZSBwuuJ0wHg2gxOlpdV4COMSv+rXPM82czqXQ3hl0q3If4IJOtWN4Z0GeOSiEt0pHGHk+XUiQ9aQSdkG+5a1Al1k6AO3D0J7B7k21mahJK1Wp8mOqpbAJX0jY09AMllN9Dxu/QM8cRuMrEgsr6SnGsm2DtmQKjGClm1Tu5bRqYX3UnpHBYbmzoHkv4tgh6ob6OmllAX75r9V+id0d4XSAyWAyoD/EXUq8sHnamdUiZVodh99ZhY8nUnSSefaQaTuum2nRqoGrXKaFBdLb50+yyaZPZQo4K+nWdw/bNsDe964YnD2MR0d+PbirlPMWo2aka7CKDve5HZFnFJQWNJYGzBVetBXWh2pRso+FK8PatkkatF6KBUfSQr5SLOibNDN6CV3wo016p6ri3WzR+3TBexVRUDb4K6usahGxucdGwaiXWegqs1bRY4zGZdrISCKF+CpgY4EyHiRyhQSDUr6h09LHvmAMeUAwduItJdrY6JBlkssvVvy3im/R4isj+/BJ0jNMP900gUcGxsQAQ6mUu0bX/+DpPLBhNukdwnGNuVjQxXMzfi43aIkG2KMP9PGPhUM6O4xvTdpJbGH1LY8QCUutRCwVEluTPDwZEjRuHO4zQkou6DRfN664OeWICTeOZr7sOrK64QFwbR/Y5q7ti++yu6V2i4X1sjwLRfWK3ooL7zlPtX/5yT+wMaJjixHdeRwtRqBeLatSCvQac1bwIt/xu3B7dOuJOOF4W7TVw3KamFVPevGaw+mkk78VA30IQPrFkUb6NhATAzMf1Hv3GGdRO6YpH7TnGVDc3id6yK/2ifzu+voZuvFImnjBKMaIFsU/VeJBBkLTWYhnMQBws5nVdzmmtKxpXxGJgiwR1FE4I1R3yieb1wnc52MI5Ks0K7lNx9fujeOzYTF4iPl9ajE53ym6vldyBoFpb1AMqzH6RHhOQb0/sxDdJd8Ywo377Kuwb+Y2MEyGc/mZiVHHIhvRb/ahs/imdSEgR07Wg9GE8jXmmj+tAKxRQn/61cnk9Zh6U112MYM3vHjcPGy0zT76RmyN1YgIZvyiSZ5iN3/X7/GJZ2fR7yZSMZfOdQmI3PqC0X4zwY6OgtH18dNza2z9651H+zkBID3/ZJDB6HcljCr3grLV1BHFphUfqTW7A18pmqolmfKoJDcRMC9F0p4VwD+9jTAIxxJ7gb5TxQZAlazgoQgJjnSoKofFoAl6KW5I1XIpAiaDW0lU4mXL1ARtuIKYLm8WizKEoPxl06NKwSfDAl+t0uIquIbGeN8SC7n/nEEOZDx5qGDwvHxrzTD9HMNUFm6hqe3JubU+QZvv52xPUuLE9YYSWXNRtuGhed3XIsz3Byly9AeVAaj8DZa8DcbXdzyfZXdO7pLpias+fP0AmBe5R8tK54e2Cv5OeQfOvJHwEfC3lcxISRmI7CoYRmU3DGzYaFt7TrebxwUEiUgYGGE8746jfp5wl6njiQbt1fNRqNrZaiYgFIEX9z7swJFpQx+3huoPbdKd7Lne659ZOl76Xrb15bex2WeF//wATCxCTTbm4fCcpKe3Je8P4duDOtlWbzBm79gd+c9pfV91LRvPP1byc6cJ4OndlwHMi+WAUShQX2p2bq0nUv5uG574EhQLgwgdwcUoaCffxmae6xo8Y7LvMj0D0K/24rstTYYzeMycgQIMbQ7kAsSiXdX2UI8n5QRfrT2IdQzac+3L9SYyzyCnGz9obU8Lj0xy4emJhiEl18KN6YU0yz4UYE0y7FGPhcF2McczmH9KTi3Q9uYjryUWanlz8qJ7Mldpy9wHpNS0DFqrnoFvXhs9Esebelxped/HrK9af4ObXCTCsNEV0yUfphq8P675O+lz/xuIN7v3jXeHBd7fBDgGOd41jAI8ZkIRLwJnpAkx89OQgmTQOZhwx+FlqsxJtTbBt8ifstnDzfhlxU7nhpt7TOd/OSzPOGpvHH3bE/smFPJ+jIPoOzGnfxWPxiYSOa3Pn4PhjPCIKYu7nfKwzWeaaSn/iyaBFQxqt4Tor9BbGdThRfWgHiJvHzW2ZIMTfIFMkDFgoE56UzNQBtm2fAruEpW8r8EUyOJdnet5GqBJJ3QkELdUO60aM8sFHnU7rUp+lf6LPx6AgWRG5PECeIn9HEzQSdghpA+VrifqG1CAR/aRJmn8DmIhXQmpSdmFImdUAczalpB0DK32m9SBmIBwDQD0NypsA3gbsW1Aeh4st+vSfN+J4NLzZH7RvQqhdkMNEN1c0Gs60F3OdcTSZ3LZ7YyMGWUSCe1uKudVSXk+66iIjWZgH2Q40FIlxVDbc6S2EyOHbEyyKHwUgdsOOHop1jwqvx21Zyt8eCWvBL0H+Xg/8uS/gBK/8JOkfAdyyDUuDSUUPNKPXDnJlepsBWnDE6PAOlXL06gFKBEr+kHE3tYKRIVQ/5nSSUv5JtFTT0PKziKkVzBBHg5aJTseEygRIxv8OlsvmlRJ+DSX0k4fpQmRVIeiLXw+Z5DBJlhDCh1ek7RipMlhHD+biSdYvW6cnOTfIMcKfSPKtTvItPV5kJFeX3CQTmMeRfJue5OqSn+RtQzAYwY8jqesgyRHYJrVoqdXrfJ2chGN2dwmijOH+EdW04uBWdyBrt/plwBS7+EmXhbiboRRAe6EGTujILMQRS3ruKwXwl37r86/8tuf0p77taSW+YK9uYc/j9rh9A+fwO+5HN5jkkbHn8fHuWgb+SQx+jXHpsHveDuvQNCI8UT4zebQLnRx5BwO4XwFTBsBVexIuL43oSU+u94FYbw/l39/dRA3y39Hp2e3O2Q35bQv+bNxsNS7Ij81v4XBchg8He83dj3vN7c7gw233Xf/+qrd51v5Y6Td2m1H3tDE/3Nrc7H7s3Bx+gd8bs8Mv0eyoFVXI7+PD7Z2Hw5Pa6tEtbWuvu9M/ar6//rq1+f74t8b91nhQ/gQFW+eb+x/PDxuN3dk70nanebNz1t852oSyzXfdzdbZDiHk3ckWUXSz28335PPgw2/Nnd2z8Gg8/TDevdvd3nm/110LN/cHjf3N3ahx82GrfPTb+7Pd7YcDUuv9TfP8W+P67BvRXvvz8uj9w2T/t8bt1vvD95tnp/VOdfv8fqVVv/52VP8nXJLcnXUfyl9OLmrTaav2ZVpf+jSYn+9fbG9H78+HUffj5gcCdNr87fzT7W9XD1vn0f1yffSJIF/69rV/vTn51Lyu7hzOju9aX0A7927278qT8tn8pnE/jIYfP5WPTpauN6vvv77/tjzfuz8BmJXlD0s7lS+fyO9Xvc7Swf7d4fBoe+XTw3afIL5bIt8HIfmtMfz6+8n9HfltZbx7ePRp89un5aWw2RrUH5Yn71c7jc7Zp3D2YT493hodD+9XvhDI993tbfJja+/m9y+HN6vl4cdR+H58cdNdatQe9r58PPmt8c+jpc0P0UFnsln5dNit1j9tf/329f7h6KC73Dh8v3T+bv/ufKf/+7fl00ZUG1+MDm4nn36fz38bPNxVP7YOerv1G0LhTfUo+rZ/USG/bn5td5oP7Yuvn27OTvrjlYPqTjds3H45mI3++dA6HpfvG3vHn97VVnZP9o+Pa4Pr8/N3lX/ufGy8uz8ktLa2lpvz7leC6PfB4f3K1eBjf5v8cb9W/+e0vdW6fTeKKq2Tye79aOVh87h8vzTc/OfH6OK+WZ4fhwe7rdu9QXdvqdW5efd+vtqDZfjrsA7D9vHq9Mu78Uq4Fm2vLddWqge/bVaild63q5Ppxd7o5GEFgFbvlub333a/3p+0jmuH53eHV7PV35onvS+rk/ubRqfxQGB2HrbC8vXq+bvZp4vdzeXf3n/6BiM13vv4pfLuuv7x08GH1pf6aF7fu/oQnX8Jd5eO7w5vL4bv936/638EWV4+W17aOpleXY8+zN7frWydl0/CXucwuq91fr8b1Xc+DaCd3x8Od4+uVkeH0379Xe3wdn++9/X4vHZycnZ6ODj/dny+svvPyUOt/u6uftTr7jycfxyTWl+GQxjy87PdbweN5m/N9vb5cOt9vRaVN0enB98659/eXzd+B6Hor+2QSuPfW/Nx5fjju3Ztsjs8uD/ZngyXWzerJ+WT8Wbn9LBZPZpeT6iSOD37cNz8vb51sb8fbIh7g+O5tDKcSopfUeQ6rT2NrvJSMRWkod1p00cEd2adcER3+er5QLIFi/oh3GbJ57ZYVh6mLYMOWXXILpQ9Dp9zZCPqii3lxG8EsHKhjtvdrtyHaqHO4jqkKmUpRK0AZ4WTxTiP9LhknLZHe6tLvFU3ydObBEX6RqxxcRDD01tpYRc9cUfrrfvho9HIgI9G2itj+tthA/uedSwBL10p+OJq6OHfGiRcXUFlZ/tbwmlUuo7IsLsjObdu4bEZAVkMiMjs8pMYPdogDnA9PcPNdCgJ/DbAifXLQpO3yOYcQiQXK0ZpKxrJVOhWIXPBuMtlqmoaQW83bfLa7EjcC+vOBwQPwOdIZv883tzTsmROo7vOLWXqdceVLpOWE50YxhTvDLvu0kF0Nwm3o4dhTLEfNy3+eBuG/Zjy38O5twF47vZDL3w4icYiy6b48zScTskWy7jPQCMFwbR2cdz7+qF4dNn7DCS85yP+KThqVpMfkCT/FNzDdtIbdm63e0R1sIDTxUoMHDtH4bxgEflWUlWjCo+DjsPKnxwvx4AIrpopf/jmrxlekw3sLfA/utNHUixnLtNce52Qh0lBz9gTWZ6lYd6YORLATsJxz5UXVq4jVtEQPYEMjconkX0No02ylh42cSHjTEJrn9hUeyqZkzpPtkcbb/VbFi0Jkze1ezGQzxTEqAIvUgDJhFPqDy9KApEWo6FzXCgPBUgmnPE9PxQgmXAi7eZCqmB27iF/eBbUmmJ0IecAKZHixZ+YZ5SeA6J1IOAwn6PDSK2XXNElg4VsmAaEjzoizvyMeMjk0tEwSUuPhXKyS7gk0WDxyohH6xUWqfR4HkAWdBxChNIj+RrO7S4pcfGuiMnpDcBEj8Y9Ygu1+5ICkXRFN/dKD/A5ppq8s2LUu6Xf7YpwwSBbU1AjuRUwb7shsW6jueuFNk3TuoxvPBZjKgOPmztGm0IbPWuTujwaLXIt/awNavMR7XCwDn9Ug6kmrtHgk1iaaoYbDUrt/6gWk3WB0RxaER7VYDq9Qfd2JTlj2Ed2e7hE0IGVxVJ9kz3keIfsjPL5Ubs31tYnYg72AR4uozITB0D+KH9GD4WQmYnd8dZFU2cSmRGUnV/kj9pHRWKwHXFMhJIgD5A9aqKSH280s5Cfw5CChYUCynLwkl0yozB/9D6XulbqY+N6rAIlJMutpzoD0jIG61dj7QQkswJOEyEOkFB+iUCdnMKl07cBqxVf6buWWsE8XQLfzJe7yfRdP7pq91tidcjPtAvp6LaqXEBKRuYm/8qyFQ2uiBR+7E1vWQqmvFGjGMwKcelvTBd8xC9r0mQuggqoygre4kQVk4ce9YGhTUXJvMCFB6XTJhz2XJtkt01eGwMI3HmLNy38GqPWJL5HLIFYApzVOiSRBgCZTVvW0cWFs5on5G4az9tqT+tSBCjdvk0e5VXRbFAUuLDStwNcrX5Hv1+Rfd3X9VTsFHdsnpuhaz+MoTyFUSSu2z+ZQfaTxML5EPt8a8Xxfmsl5gHXStoXXP2Ho9yzEUtW1UFWNYas6pPJmrne6EYj5nzqzg0vi7UQefAteB6HhiIttzddCzyZvWkZcodfaISLQALq0zd8HUXcHl+4bP8H84prXgNnAg9MwykQ5aQBXBKs1HJF8AU0a3OuzCOGSHiG3et1pQlMldNjQoMcYLOLjPqwxPaNMvJiA3LI6vtmtkwpH4JEJOoSO6U0at+E545vF3ZQk6tNlCkrhMxHYIjxDVdef6meUUPs6ONrSpLxynuyv5AGs0z+STgic30pqiu8J0R1urpHo1L81S5c1S6gWjx1Di+lg6QFB0mQy6yK2S4pcUBfUOh4Uj6h5B7YnUzThs5iq3KvqF0VCmJrCrMocf0y3oq0RVKX7au76TQa0jzCVVjyHKcQL50vnfpPKmLOpfSDF88DQHF18tjWd3TjJcrvjE2+hFkqp6aajzSI3VOBgzNg4yiStnTaGVd3+gMyDca9WWlApmhv1J9vzj/kP4RwIFajTv3zi60oGsNTYAgd5LDWdgCAODynSWLO0ZcL+uVCGa4g6S7ROhiwkygyuATkjQuE+UgWHSVNVPnCjb+lgTjxc4+Kq4FNVlt/GCaNEHKOV+lBCTsPEEgp+1oRmVN5q8EiViAw5BcFZGbZDYMBzH/tysuPpNXSjC+qdOIZm7XHyH4q6bfpiyXemJb6lFAmJWPk8/HRHuVj7l6jVvyhSuVkaK3kqmoXKVVgctX0WtdZXUygmMmVjAQWjVnKVUMrxmfcMOfDCz8s6Q8Gp0qDSGoicu25NmyGKJWibNuSSKri0SwuSE3BuADceiap0YvYRnWt44KwlE/ameBAFjchnqypvIIHB7V6M7XnbCVxYdDap06lKniVQO7gFzJI9AMZplGtZDzhpvOReoKFpTqqFk27xnIz+FODxm/IVVw7JW2R0FyjPynJBT0zrHJdcf+BBmvoXttlIh9+MyA9u3xGOHwsF9zbe3WY+pi9Sqp9gzq1/NN2McB1Ipbdv8qOBOgBBb7b7sizfUncq/jtFMZxFM6mgOdcuUIdW4tfUFt4aqnab33LCEw4DAaXkjyLP01EfDem9+Wz7S08K8/M1ylatmCfjqF9XencqWQOhH5+FcOuxSdilvzS919u96fV6aKPGQtx+7hXaIhjzKZv3Ghwk+h+61HGRlgKItk3IHeMcRoGb7VA3vJ+s+Jf/7LUvDBbCxkcFgnKybF5Q2Y4CpYpiZwR9mbDH3dkGerUDdVipQmV9aGNi20iciZQ5rVjL+dYk5EqQkJQY+i9bMQC4LH/rIdU8MocjYwRUZscF3t9QmpsqbVh/EtuqdPsQ4WdnLzzfsrGO3nf/cRtN+owPvSdTOf9sNSRt1pcgeQldp9Xeo/i6qNLvvoxSnxNd8NiMIJfY+l6bV4tNg41lcGSTD6/QpQzfFYxhMsqlnmUvbWMbSERtue8vumZVZx7U20HvUAFfTF5pyzXa/9OGFshNDEnzEZCxGKKXa1Vl22LnXW13bOmjT37A3qFtN2/htVfPPmRT+GVWEzh9dD2FtAQfB/0ul36YHqaVhYe0wrl0VYUXqtplHQVjkxlec2dsbgA1qR8boK+/lEqV4qBKH2t3pjw2E+os4sGi39BNC5yeShi7iykqKAvts4dlnMpxWbxd2N1c/gMEqaPq4p/FsVBW8ZvDKx7TmlTylXdN7PiJkhscEAMidL1txBomXgTq1Cx72pv5TxxhOlhIqwI+ZFKTMGvexKWcHeJmGB55eEZFaF8XqSZ1ufYLGbPw5H97X3U6+LYESodM3pKbXqwFnAGiDxLAY+HZgahCPID3Qtoamo+19DK1d50b4mkErKhudHQ3GpobvAOOYmgM/A6UJG2D79pxzGsv8/bXdbZx/dVdBH3zNEv2S3VK4dgnN4NSFPzZ5WPSjr5qGQVEDI3Hysi7I2FtFJCe1FN14tq5l60Z4/uRXv2OFlnWo1LRqVaZLwsQieLjCJb6ivPPIhiCJ80gi7ZZ6P1zIMlhupJI5UwU/VRYYMCY8KGxJyxDvf3k6YqIkTEjGqsoe5h6m8y+QpruM60oi6UUHXBZhvZjDqYZ2GbFxzJP56JzEdRp4hCw7HbG3b5q5v8Hi3Z+hfpTWBIPXY3dOReSr5eACMGKMBxCyF/BGfB82KxBKWNwetiUOUNu2Hrq0TdthV1S43+XdX/3u2NJ1P9fUhFksAvxQhjCxguSZD4+nDbI1Zv/gimH4F/i534nAZwC1bIyBzRRbiiH0DT5o8YR7TuySaPVAXYkOLiCi4Wu2TRx6MKphPaYiVv8AN1BkOUjjxo0+9GfyXFUPzZOfe64dXdzU04Ns10VU2O/p/E6DdY9Gw+2myuutjMGUQKF3Qu04K3qgOqJTdPv8v3LNlxOyWUjsvn0lw9dskO1B2FWvg7G0+gCMLgN2iTLPBdc4NRND2CgjCDt6w9Y45J6cmWzLpvBWFGXUWpqusLSCe/hlN+tzIcqjjBTEH9xgtUKk5fx2464GHvgS9x3jBdDysRdfepP5kmhQNCtZ3HOlAkt2kS/QnP+lZK+G3Ul9YNUtMBa8a8M1BKhIjSbIzH7XnewYKCWU3eikpbjUY4z7JWmGcmLEtXptG03TdfPpIFxlPg/OzX/dVEclNqhTOeebo3vNnr0cQBF9bH0in5pR9u9qYn4fikNwv778a97m5vKtCchtOtfm+Up3G8zbAzbQM8vZKdIEiFx9xcsY9CkKAzBlNXJPJ4crYTAOn0MKuIma3pPK1e7pRdrobsZXlIBlMpWPnPTG8MFnWV0HwDX5kuae/ByPOnTDVZSk19i9a+b/f6MLmENGgjAcnY5MNtWlvtbhce9FhwlLEkDFOcBszfXbhu0m+P1CBYBBkfFgPnUYTxuWmEL7mmB9rTl3X3A/7yOKFzi90kvBnAIykibADeuRWHCwjsvjfpXbFzh5dmmevWFY9Pn7DXqG5Kh2F7Ql1fVOaUdBYdg3UdwRsolbCu3cnAmpGJNcXOb4riJVy0/vAggegNVAJTLa8bl1eA18aDv/rYLOgNmfUtUZiBefLwYF5cwW0ZRQFX36xXs9m6q3TOSudzs5SIRgyJ6I4OI5DSZgAEWPU+POj1rYiftM3iTpWz9YlOAJOQ1MPi6PNsFttnk+f4/o+z/3EDFte1Gb2PZPYskVgvqd891wb5XFcL7VtDZ2nRYXg91sESH6qe/q2YsKWHFZPQOZX1F96hNuuChtIHHw29C/jxGpJTwqfTG7O2RYVcqgxAjNM75fGcmGpzYmrpEXB6YWNcg9Y1QI/q0+BXvf7rlOi+Ox4xp+sGRCAKti88l7VBDzuh+7gLz4l8ptvNaGLqd2pd9hlKNAcXQJ2mGrwSoK5+qgg0jE89r3SoGTveXZSwtbQZ6rSmQG9ihsU1KxgXwzd67oBFC/iV1418ODs1YlQdqwFV6XGB6gK7M6JkwdGoE9D4rJy7FokvnFdX/QNLrPenje3cCS9m3b+ZJDx+hBfcQ/y0kXn9KL7NsDALy/SBCoo8o45l22L6TVRaCciyMbPGvqXGXlegKVp169jsxKURlA2PyNqjkWHL+OPHzqOaErmWqanHiD991UXXTCYjU3Hk4adrq6ZHW12mUVdPFcPFjVjfw4/SVz9gtP7y/H+S5ZBqnP66lgPz3v3PHXWL/ykU5u3ziET80KMxTkHVkyXg38dIecyIxe/RUhABMMpo8do4mz4bJ2mT+FwGzn+mbZN2pmCeJw96Kp7/WPOIzb1/663bk9Xyz9DIKbf3P1Ejf0ehOx1xTowOMGV4Jf/5wH/e4hjSm9Jur99XlRy8Zjl+irQVWQvuzMbVGoVDo0bK09rGcNpr9HvtyXMfrf4gVzJjBfMcn1+k8h27v5euGJtlNreZcO86p4BQQmKMF5B7NQneuJs9mtG0fHqzyesZqOuF2CVp2bCXaGMwS9KTu2A5tKFZHS0bgoPeMPScp5+AMMrA4938aFYkdBSMb+Abr9ICz1VwHla3HZ0yUZKCm38oBjc0whHF1pGRpC+Ascg7+vuOCpYyo+hEOZygu0LmFC4jbg45e3uT0w/v4Dwj6A3ZVejomt8/6XWg7NkC7BA1f1qUnc2Rf4NQO22s/7zAOUnBXyx6TtZc5Gx+S62EB3lt8wEZkg/CetQDR1oRaAMtRIk+9anhhegXLeZ9i13MVxe2HNdSHoo4bq+g5xl4wH/qIXw4x4IZ04HS6fA0GfjPfm/QmxoCACsg9AWPPuvzH8OFhc84YdtunnerdF4UPSxdIO0/cIcHBioDB1LeQEtsqpMHnNpEtgwsQK0z1pfQAXY3stLr4tjEQXtmHUO6ibZjIgc4HjK2wwEYENgENLgN9oCoBjOIcsNcRytJ4oNDxCW2IiXTxFV9LC5IwavPfHmxcFShAeSjaoneLqzqtrpXiEg1uNld0UQnDr5K4asavDJhs0y13ueCqXL0Zjmyda2QfGe/lCb9XoeG8g21nDlDqj4dBgThUZHXtS6prLvCH1juY7K2msrYoYYsDaS4Ywf/+gN/ERN6At3nrNzEAxLffWs35KHVRyqyzgjyVESmAgMOfi4U4k/y+dhhzq9b1hy7X5bSqLuGe5KUqHgDzyMDsJyxpU8JgLEwgEgxEC0ntmaDVZJMxqrTZjStxkx2o2052raj03q0aHcbkKYZ5DOEkkyhJGPIMIcqXlvStiYtq8g2m75bhqJuVXrtysBmG04X6DabbPuy6jQw/yTeVj22ps02F2erPs46rc4kuzPwsvC7bQemse0eacZ5lz/7nqtDbydbetjYOtw/su6nqkWTlDfOzYufWvH+kRaRjMrONbP26u76OhzTF33Ltrm6YdmrT+MBG2nal7daX/Bgx3RV1Idc8zqvtPpeXgSyv9hkBJySO3QWpjSvZuxaZcGcRfyGJu9nVZ8/fmzwnCki421QQZc1sYdYQa2n5VsCWwKnIOCZi4xsHKMqq73VA6PjeOYU8qyM0aRn3WFA0Lfk5ZKv7zSzSTHC8vTJnFyz6uyc6tRQV+0pDOc4M1G/CCtMLACgmfE/RVCJGVSTTruvJTh7Sb8Ix6vvKpVIDcOA6RVLyNV7Og1HNM8XSwnjLe0hVBc8nzhD+SrIP6grtg/IR/8gDs9jrvmwBr9B//yuaASEXMzmjoHNLAMWLSw4kaYJZZ7PsCdbSuhVFuNYZhbPSufctfDCtvWFublOHAL8YgjbolsGxpQF365bJA/0ExfW4tRFLV3PynCDwD24+Db8IEl24GySSk3B4dG+FdkyNWyDmFrGocv5xd5HU0bgF37uEpOKdl4uPirHWUyCRuauufW4wGFGnz/TjO5qMxqPwQDP1nM+W7tqtsZ7A/8DJqtnqibUjJmOGmU/Z/LN2ORzJ7pgqTJkr2CmnD99psyc06ElZos+M5lcseOzTJn8WjGTaFOTQd8BklgW+fxpz+DBGP6006Q3uOu3cTg+nVEAY8si/dobovcdy4bXyoAwzyzEqkrBfIuqr/A51lR2q/h6etrrhoIOfF+U8qm0N/6m3UDQ7zvI+r9qGoG9K/ZaOz2QkWH4OSimshTfLXvn/CLPCINzRGJ6PiiZon/ZPUW9I4po0JbH8+ygeJd+y1eWa6tLSl+RTyVortHv3QwHzLKsaKW4BPW6SnppHt7BMLkHdgIlv7DpeN2PonHeCUT+IuPoqY9ygajW3mDjXX1e9FJhSiN8Ey/A5/NMlBZxC3GyWCj4yWWn3spb4B3xxwUpAO1nw97UcXG9374K+yfjsEOmbmQ4+RzEjiQk8g1ZOBbjair8ip1vpJCqAXIukKKG5ccVl4mwElfjskBq/+Jlfuyo+WwkugOGvPbGTdm536Sbm3d/74WrJplIc/P90tbD2oVfiuU2eoBcAjQnc48GlPzrXzF9hWv95YJ5rdNWMzcEJw1ZeECWXtGlx8j3gn2LVJ733BfImFbCxWWgkKK+JWzrA+s+hePIvoLsUXmPoOP7ixR4aWYkpMcWQZFVC7QVs6xOihbrBbOl78aQ07kCcVilabTbm4XdvD57CutpL4FCNbY2e6580imGLnm+VTpAH2OsGlCFDCIn8jKj5Hkm62qEP7WCPRA4Pulk19Et+asIQCJ7e7bcFNJcMv6uqzMWcFOa9qb9kKex0HwmHm5bdTld/JM9ADEMU4tuNXHVVWtrteRYdnGxZ2XGIK1xbzCAqKUNc4/I+nHO46y0gVPSsRjoF1hVyUKg3+GtuvahrI0Lqh/R9QBNWbaQIYbSh9kRVa1xeziBfvGItvOiwF/Elsci1TUn+xTH6wD9VVh/4RHBVGNtfhHCqWYA5GcpCFHVm2tCuiDVA+sIGTF2I7DyBzAo27TOq2rSnChrGfMcxrbYNB9GpHI0Pkdm/4w/o8snGzo3lLlk5Zu9kFKC/4GtbroVAqddbxBuRUMIHyXbwc1wQnPbM8R5nvwV54BlyWTpU74hOF6HnbDw5B23ZcGJ+sKxguywqttaRZCagar6rqHzWKEKumAZowu4kaeFpgqTyGWN4DBZvuyZyXfNldVj1FQ8C64PvGDYnijjEraG2GcUekPlzhIlyPBPxJ6e4eWnmvbFoxrUKqUKGbLV5aWyZq9NLYytSOLjj5aG+S48xL171+9fhO1xnkxq+oFMmekt/FUpFFyHBlOwDtFYG0vALMb9MNXmk/I+uGJKfUM3Y2YKxN4uBkvG4ZTY9G3wZ5R3j5uHjVbjrHVs+Fu4uRLLdcIzvkwynlursyNgPSNiG+WLDEaSyR+XvYQXgfh6rq+2+qfeQmR9vYInR+fy462YHA7hmbq0gIz4miINYqc4PT8A0vNT7vXkP5hlQUgXj6NjbY6moZo3mu4FOTFmCS4uNTZPjw/OWjsuRyXFvptK3B4jbAyzKXKWwAnUUyulWFzamF7n64SqWoi+GLWHpNvky0k4Pg070bALUZto1lZCGsc5lY7Db2QPA1Xpzh8eXlp/YVBDG3hDk4PkFiHxGbUGRXP5RQqA0qA5ukysGr1SijqOMzEpBJoXHTvQfa4/l/sKL8Rkh1c2YsIreEFWlm+iNYyBXeYwPeqPptNowN11bBywv47J3weIC9UuKOlLJkLyq3sle62M1fROOk5Oxi3rjz+LyGIZVdyWEc6cKJRMqnS9j79Ak+r6i5+YrWhwRa9kCIiidddGqUvX0bs+yel05uDKCH42hZrGCpUC4TJCA50815kNAsCHOuKoxRFZqp3vaPgL/pA+3BWdpgVv11DfLO3q6u13p+GtznPS2N1Clo+vqaNec426xvRl1jHVkBuWLxaxa2J5njIDRx+iRZfIyX2XVKoMyxXZdXGdGoul6FYyhR/qmXZlYEV2CRKLDdw5c7Tgua72eBLu9iPSTclStOgLjcdXYB4Yk9ZqQhyOtziFIazbmfTINeqqBYubdPDtl8SVlAo6cpkj61LJFEElQpj0c4uJ4Ryf8nFnAmhMIuRuoa69cXjfi+4mLTVAz7czq4p9GTiBn0VX2q1sBLXlumv/x8cElky0pdOSuT1mhwh+rQHpXJ2YDxU4/CrQZL2VgrUpempLMXtRsQt9o8ZP77qeQt2bnxHYh07Cs+1ik4/Qac5RCMJ0iH/BunmTcO7BB50ffMQeZTBQeZaR5dg0Bp/ceoMIaGYk+B8X4fDAWboI5wf1gv/s4CkKi/33KJVlHiXwfetbpLXtwwSpzeNy0iaNJNVZ/5vpS2c+WvfJAe6G+t3an7OwVmsY6CmO3lNq9y7SYx+8/4g5T/LnO8WKVDLEud13Td4XvolLeSXVPnIUIBuuYBovjzwJsSsLPj/2LESdPWBFkrR1EacRfP2zzwj0I4fkHd0CFt0FKgn4PAIV6ucgvwSVUt3jR0rJLOuTQ1zNY46C89QA5R02ZNg2K+lBgJyqeVTdc3xgVRP+ghFkrZ+BiZrXX5KnNc61o4Mp2yuxEmxknutb2S5kqjCzuTw6kzm99UExvg1MbwQj6RVrUetwWXQQluBW1LgDOxLG1XiiwdVRoivoPhcy2+fWs/d/ACs6GG1/5H5rD3PFILcbXsGPw/YYfjRGY/bXHH78djdkP/q07O4GfpyGI/hx3JnCj6PoHn5sh53cZ8QUSs9b8wEyOqJizwG74qQhxnNdVTbC5aXyOX+6icfZSUyitKanqHNI/gPBogz+AzAgC+qzCd3tsgu5FIhaYAWHD1FA7+0h6L3objzxggMz9vZEto835gUKiilXBqfg3p7ZzGCAmiF7trtpGN/QYOBtiOJiDQ0GdvQBaoh5PeMbmky8DVFcrCE9JQ49EL/W9yeqc/1+byIaBj9qOa7562tv87QFb/OpW49tns+mDb7R0LsvFAJRzlQEF4Icfeyi2zXRqAn0JiiXKqbpgzHl5R90CQdHMvm/13Q1B8mBVl6zsZW/koEgv5bg1+vrdTuLvEnCDyUgRfvL5ecnIEWzteXyczWcorUEiUnT2F4u/sgNB3vqGrMZgml2zzcQQkcLv1ORrVpFtSpYei/rUQnZ7eOjknPjrKRc1ncuiBGZz0zSnpN4jxgd97UFQfjAZFu9e5/ihSfdYEDu7K5CI19vMh4cNN07I/lSN9kmhAdRB+5xsdMN/CjeCJZZ/al690vH8Bbgmw3/FYzk+hfu+q209c9Bh1pvmz8k3RtJQ5gL8a0/mH4zGfNzvNBEY93JyFNjPzaJiUUimZaOg6JFfCQWTojV2g1nju9E5Du3Gd7LIiRkqfJ86dGy5j2TSUpM4GvCiq1+NCGdZwdRku+QnuS6TdSm4UIjaF6aMwf+E7xgL0aMtGuqkres0J8vwjGeCC8/k5o3ZoR4sydzOMvch4H9XGJPl6YE/qbHkvA7rlJK3rBAYSZKb9W777hPLFFL6aJgrpBCAONr2UHBtvbrhlMylYgS2+6xrA/sHQ1JmVAxCZXwy/UaLeeUlvOCFMlYPLb/CU+rXnZvkFJLCpEeTi5f2VJkS1BGvoPuXntASB9bDhH5QJcT2UV2ZHRj5K+jbuXCDakdYkePJkb+O9S+yC0ITjkix114BrZr3OzVceA2mdPVXZeSqiU/6GrPTNLFJva6Yd6ZJ9rjgohZm17hHUkXK2MjuQQtq+hEXjiJjMuy/biLYQaV8xgq55hK9aq9R1gXoFu/uOb5LT2QP2DbNupNKzgkt+oX3QWg5ZcgATNG6Yies+Qpvh/l0kp5xdmoNWmKCXQ/HZWkKgULik/nYuH52PhzCAblANF386qmFhwuOt9aBCdK9H3KIzIian5oGxOPauNPZpL92X+N/2uYoh2e62cwMs0ZMAylbYBaQFdhLYIcnkuHxSF2IyaR32OJhd/lxRW5kYJVGu2FStsa1ElzZ2v/dP/46PLo+GD/cL8l6+He4m64ejxHPhiZntVm/d1QpbWxQwKZBNxzCUjqXjecdMa90VTeYEOH4+riG7U0+tFNpcxjY/KiCXy0l6Z77HKQRJ66my+So2JF80VHp8XpzZI2U+jZ2oN9RUjLkq1NfeNtMFzmSY4t23GeHj5nS9RTNzOd066r3A6UItu00ChwARSTDXlbCkXEsSLulRVwnNQeN22epS2ZBDpZANzflZlWdfLbyPnsITixqj+MN/sYEQowe37egD17w1lH77GDh+l+vpG0snQctscEWoswPk9yliBvGWuX3RMaMFTC849fysXeGq+fRrvk0lK/xkZjeW+4qAwCyG2ySY+f4WJa+gy1CU1h9K1o1ORKMzVy550dB+nUzk9Ol8DctihmDJ0gih3E8yfZdwmA15mkAYMHwPKvOo5fsEs+7lTUb1UZKVfuJtMuS2U1HTMPMtpBjaKJfjkzhnrwyY/THqE2dw4arf0PO3ZEFcYug5nf2gE3nDYPMTMZZL8QuDCuJz1WjPhCfXCeu72Opy/S0eXLGEWrv0UTtAQn8uyAQo33P/7B2nkjp1qJ5uO3wUQ/7LPqUZaMydAaXCC1Tlpms61wCHvCjYC6LowHn9hmWYJ4pq2HWXM5iL/AtHfhRnsmn1iS2Vwah6N+uxPmc//1XzQwgfxr9WQYidSz7FjdOkrmTZWomXt8nc/9r1zBkXHBC33YaP6+02ztH+74KvI+xXTmMXMs+NUAm4Qdcewkby8lySs+bQteezZziTjSaCVjT7Ihf1WjqLGSoIhNpuAZjQ+Ng7Md7zhIFf+FqfgvvoOCL2b+Zt+FkC++p7W1OTk1Twi+OE4I2GQEdW2xTc0LmJBTcVBARGA0Rfu4MoxhbnEx56ofz3rGN3DxfaE5mfWtb46Ox9RBl1PLPlODuZyrwRdxf6eSkbOj/dZfSUTiGUWpjeWT2Rrs1J9zqJIp+FEjdbDzbudo+99nrDi9mUaLee6ec7zSUPEsI+ZZGU7A0wTm9la7378i+zX3wabRkbTIpJykio3O5qOyWrcdVZoT6WOCs8rCZ/qRLICYN90yuK6etV2/O8TGonwi3DgUG3qZMQScEdJ0jPFVfESeAQNGD9vxO0xsLjCvyU8jjVrSILtamNFDDyIb8jGGLb10bE4W+vgh82fQDS4FKulPHvK9ChRD4pSYnvolgYuKqR20hxjjKDKewPWQtOAgafHpJHXZ3d+k5hMxfX/hvQGSUmfEFLquiQCBSvoK3vreyyGOU7J4+UeOGHl8JUpiZ8FTm5XIF5xTDNPn2FZakyxmIWqPx9GDK0Q8oZ7aob4NqnX3do6MA9U3EDtvLaR4ZNUkTKIygTWFYqp2Fn5OOwlIUpBh3pv7vG5dvYKF5yTqz2+iYewYixzRfEwSN46J4/4mWPl73JPG3emsX/xrjnt8fBRPlkbd9gUz3JY+xWkeIdCfk4vMZwldifCvepDgd4NbtHt94ArS4wDXAop1cCMqsjQ/BVbv85hBzncR/2m5Pxv37V4fmhOmueILmMcjdAA1ijN6oW0D1xsaMa5JmNWaPJxI3nuMqKlXJGQwg8HA5TQmR8Ak/6ZjhOz8UdJWguKK20pkwjbTDxSUmTtCb1mLeHGnaSunWmnPqkDN3M3j5vZO0zLt8I3OtEZrbFvUgI1rzJpoz9KsuH52/tqx6miZeXwX+vQqj8zS4+Gscel+VGpcTaL+3TQ8l2smJsh7Dz+FvS3SI3nESbwOnlKYPhjgpdbxiXtw5zhnaPYhtRpiKZ/i2vJlTHxSs0KOLtK2aTwDoob2whzaycUfmj5mAeEFois8xd8eJwFqsJmSGn/z74hdc0ptjY937Sm8uIH1KOg2paEOnzyf0SbY1fjCxuPa821sjd68CqpP4fSH8TQNp4XMsb42No8/7NjCJgiTd93V1D18oqyzdjd3Do4/2u1SDmduycNfqxtZGexyno2Qn0y+XM9+oqFEH3z+JWYgmS/Svw0MK8XlIRuJ3ONPaZ+aN9ep0ktbotaK93ORjrRvQjbs8d6uybWVlNrSNgQmttzr3HKT4XRxOeioJtBRfbxgOlqrJLRWybwKj4nIiNFV+48ZncsxtiEKJJ9ngNWyyL/dgJy/eUeSFP3JYN09B0RahvVIc7pBn0hb1/GJY6e3ZHdJO04z3OyQzeY4n9tqD4cRsAWiiMgGGPYtbIYE/x8ct/SMg5ZiMIyCyR2R+guaFTsXe+8T/geHwvwJXrqE5uk5Ef2VJdyhIdtFlptFSwRhnjCriigPw6Q0YcjV/Xlr96ld3mMPoGgJ0yDMnBiiFqZF/KyIRh+ZTNGQmBQhxCznc/0o+grSABtN4JrsluSO81EOs0G2+ZT81JogoBR1j15//4Nexpb16V0+8QwvvSJe8gDon/DDwlDtsxpOPVXOd5x1jZ7n6ylv6KsY4Y3GxT/o1884TDmkoqBDkW+ftdh+wTui9QVeTrv4C5NtpUtk47sYlFVyGR3tG06G4piFg9078GKAvF4aZWUvIR4SNjQa+O+x3SIwGBcVWU4GXm7s1GRiCqytuS4nAJ5FMSc28LO6Gjs1ZrAH0LrdPjusZeWACD8ZrICsEWefP3tZI6sx7qg/NQahTrP5y7pSwbcF2ExnCLyx0aw275ATgehjZd2r4SDCaAIdoPppf8g1nqbsJkgLItWn6TzKK5/WQ1MLofqME0yGNwXnBLaYPHHJrp5xFAjq8My2GUliQ+Vq+i1q2iXwnATjLedYxe2AleJZXvdrLlP+32zoGTv8PGOaDc9S96x3zV4x+xJnkL95PoFw+1iInbcOXZNBCDCLIYbkC2f7D/DPLfbykm9EZ9bpBWJSRH/3C0y/PZkKB0tMKgS9QjOmguaQ8r2JuQGU+0CkR5BQ74NRJJd9IE0T5KZ0OogiAji8OYxo2uwL7UNpj7T7/q7d703nKE0228DJ/LX1JB81vZae5J5md9f9z1pOHO7a3KqM3ZHVXWkMoX4EsewT5U2tuDLH0ae9tO69CSLt7W2j75ErPbT//q0eUROfnbx1fBL8GpSD13qjvsHdfEQTzBvmbwXFYrGIKLbpishOvt8eCb6wOydw4qxg8FR0xKIWUC+gZgNseJoikB/s3IhxbRslGC2NFvdjl7Ll5hMysuO4WY9D1kqFrGUiE2/zUlCVct8RsnujBR1okajmmWmiNCUTuLARcP2CNK+fOQrchtlvHszMADKsNA+foDQOU6WXR8i/MuRffaGIX/VQRCsJyVecRAP427OTkXz1RSkmBURCTWsb5QiOPPTmsT8sitsFu8SQYzB5g/Nm8Mqs6CWCBly25YtMHghqsxRSPcQWmDq6Ew1Gd1OwC8bTBtk6TMNR/tDK3x6zxsVOt4N0c7eZClnTRPYoiaUL2IO6BaLe2Y2b84JfNJmQFoMek7Riw2R28pu1ZAEgxL1WC6GfDVnRU6+cgd8YYfSejnUoDUDYHnsZY5CBdYdNsZcbadJF8c5KGrbanVswhCA01nWzeij1NqJ7zJOoybywvjxT9KacleIi4sYEegAt5bp9a40aoooglcnAYtZiFY3gZVfsM9TD27i0IuI942IMCH8QOUa60YozvHVKEYx8Kxodxox9S8mJrMIuf8XVstKAMTbz0wJDUhykxFBi1dKoiSHGPY8kSWZgt0Ux+I7BU90eE3XU7RGVTosknq2oH42rxUD7u1LQU5/5ApDlOUomSWv5iz4mJX+LS8yT8QX1zRiM+vPgiO/Ue97SznocGxwGdhIO5QDpKggDsCEiv2p16TAUA2erRmYW58AI/P/pQ5OQnO8/tfOFJxgocidCl/BPERGpVKaJxnF9O5OIhK50hXV3sF/wiM0RzuDHcsBfT80nfOgRGrDZLHi0XffwBLvuMaYa6tVr3BUzg6HDtZKMv4B8JrIZsuo+PDwaLTUBkVceMR8h/p89Z20AiNKBDXQ+Sx9SJqMzwndnZnyw9jrcYD4Kh1eanUPnFjEfxKNxOPcDBCY7vqfMguGYNSpxxTOPS+YsGhmJSxS1YrJcsMtKzIVOnd84WYEBskMd6CpJgSpusyjWsH8C98qFv/mZJ4ehRTO5XFwOF2/WV+RogcIEV4p5y0S+kcZ9OYHf0aNcG3IOmMDk87puxZlOsHmg75gnKBKPHcFOoxF9qQxcLoc9E9+lI6frVzsBrHM8oUB3gouQ1QwUIfWQuQcs6oA2ad0VFqRoETAeFi6qiNmqK5uHW33O3erz6WkyKS3Zx+kbi/31EIuTPnWiAT17zf3yC31thN5gWBwR2IChpoEUX+3H7fT3OdF5ZmsgI/utcJavRalA7CzIgO2gnR0ZVVhudL3hhL3RamfBIYuRb156Q1v05x4NMiGhMVESrh68MSVS0mVkofme3MxbRbmnNQXxmEYZlH2zwiJGpF9mb2c6aaWREFbIoEmzjsjRIyvo0cLwxr7fp0K4ePSWKT/iPLY9JJy5b/d73YDlR86DxFtNLAS5Qs77cppzuH4AWXYbQNfLrIS9TSPzP4f0BNqtcfgzSHcKw8s40ukzGNBhiF7W9ExcAAzRaBaXlMZ05CDIjt/sCtah9oMbEb2hQozOSSvaZnmzyuuJ0kVWYLMZPSLZhdfg1qLeO9yofNnENeGshk1JcDTtPXsykakgQJ31Cwb1eqSttt13zYIKcwGYrRkRjj76F2I60NOCi9xi2g2Jxp/O9beJ7GZeuWx7+20ijuxNcHp2eNhoXly+azaOzg4azf3WBbjDXZ/fOLK7JL3p4DzK7LnyvKjt44JynkSc0TIjoMeLwszxYiyHEw4wxRjo1opzUtP0f2pbm3VkjSuvrvwxzFd1T1/5RIuuyCgsxg9MT/nNMWSFgm4UecOQgeS7AbFn4Q/a8Ge7FlFZ7f6IP0qCzzgyhwNbg08tGhr8mWaZoK1hYibwPtfm3fV1OKaf8tZwfU8nbZQH84xCN3GImf5txCSliKh+lJg5saa6TW2+L6zFYYNCDNrjMIjuqOkJXYD9Rc751L3DMZvq5FbfxEjA4Jdfclp+6XvHcSpQA5sdDDeGkP+scR+Znp5xpZ7CL8zgSEknMSIcg5YWrddn7Kd5v3sObs/d+MPZlMioQF8plZUVf6/8hffSjXOP/IH3Dv+f2WAJ7/XtQnQbVTt1PVFC+3IDi7D03Gib3a32iBh12K+jmhJl4oTWPJXnGfZI8Q1snOjrLNE1n9G9zuT0wzs9r7eUwWZIM4xKhLmCI9Gq0dxL85guTayAD6Ybde6AlFJnHLan4U4/ZIR12sSy1S6hOOqXRAJ2PrjxwLciWvS+tGe8v+waNDxm+m4cZ/cBJqViehDAQwDBTexVHgpCXfwCi2sEiqK/RdmVYrBWLrh2yUPv0cG9chPfq6MBPE2aaJogWOkoukeu/HvTRcsb952GK+GW5+I/iiCHRPNMvHASh/yhym2KgkVuI3Rs53huVfMcZlYd5ibGugifpLbWX6QwQ+3uOi0QF3s8kcf4KshQD9GR1Tx3/eFgxVOhPVt3mUSTo/ZRHk5fCpYBhFpP5K+Brz1z4VPEOQfTxOeXcKNv8Isp55DZZoCyDzvXFpGcgF88vDfyYOXZOdXABZl6XiQnoGGc09fd3oSYGWRh73rWzYJrPqWcF3YSLBoca08YY0zu9QDbNFOuGw2np/D05TTapJEgfAousemXgYn6gV419tDsHh+SJWgzO+W1OM3K1IalR4turW0er1W187VqaeYEJXZ7FZ2zGWAu25ieAVBh4m/kHMmiC1xUapy1jr1b7owxzD6L9mt8MtWhz25PPnfQRHPu2HPSx3CaPo3F75agMOtUR3OJR3SyC9pZnQyqRno1PaWH7VlCrbaDRKpZqD6AVt84s+dqDDykcxDdW7RpOKTa1QkSk6oWL+iSImcjQIFYpX9xqxAfcQuZ631/EccKl6TJYz5NnbSQ/kLHdor5Bbfwtc3MUQlGiRuL8tK5sho8wYnm4DNqK7tfKqWvUTkZOWMKbtF+Ni/jc/saM3kcYS35cS7GqnL+VJ0J5b9nncY/yG/4FO9hah/i0z2JqfyJzjqZfYqP8SQawvRk1+FjxCd1+nCnoD0qKhKLwEUWx91z5pA3U7onXuBKTDN/Ee/2u3D5/b5gsyBzdndvm9wVKJqs8OyAznXWahXbPDKGcxC3hzx07kkZngvvHhRbSaqduL3voXOvyvBcePemUJ89uVhC5DqG8BDffbZbqCQdI6Qz4FgrMbZbguVmthpnAz2fBfRnTzkrlO9LjD8m7U7lS/xOxbdr+JK0a3guczGdwYi1cJWr4appDX1xWUNVt9UYazd+wSZM1Ws4Ppvp+EOMx6exzIPyWWxIk70OI9I5ApnMAJchEGtJ/gRb0jiFlD6QIH/RON8/3dg/2tshGArFgL62zOYvS9glhKM3Cf4ffBZ/k8LRdPKKvpYVwPkO+Fe4bfqNqBSaCox1CqrR33x2ncvS/ZLO0s1g6/rkcpJVEumaWc1s8z7S6n1Gu7fqMnyrT7d8PSL/FHs4zYlDmmcoE1PcO3Jx6xm5/W8H3utvB6Z4ojH/zO/dOR+RfE0Us/WGIV+1k9+mwIsvpAo81w7K+N8O93G6t4dcLtrYK5x+yk0E9G5l6uO9ose9/t08cKaP5kbDHmmI3YXj88vt+8e360o0NMzxMonjrjiVLn5dnB0vFLntWRTxBeKXue8I1ooVkU7omMPjwgudy70JEVe0K8TX7ztwLvzRsLUcx6U415mst5e9HmSmnIw7dsJN1yiD5i1yEvnPvYKJrTuZpsPmxaROujk+LS4jltNacASI1f6gfRO6z95514uC6mJQLbgS8GWcS5mnEQyJMZWMEufRVcV6RjtNm3GT1Fv+jO37+5xKfeCpQmbu1t14Eo3F3bHnv3aHFLzWIruK9jNv0hmUODvuWD59kWf6qqpzsjTzNKf1+umNEXRGU8YZvIWwQ+ttqoeskIbBHThnigqJl2oRynTYhaCafMhOBd7IQeCRd06lknqLNE8IgB8uYQI+hhzGi4UEYmyoRFKsJdJM4/FDMq2lfn/9tAfistmbnhB2wMbq3bjX3e1NjTv57IW55Ov9KCHjs6R8gytjCfnkjCeCkilEHko3uQJja9zufNXTTDpSGSgeoUTlEy03JQPEqSdBCH4P59vRwzA/oQNSDEKcwzIsdWiGxo0g14BXlg7C62lOT0QgTnTLJfAFp77kHWjfiXBeDpwZxAgC2oKVSUwU6PjGNOLSFnKzIzSK4if3ZMHXk4Wn9ORslDMSagyiu0n48TYks9RY33BuqAf53GLRmziKv8NXKSdSASL0w+lY1AiB/6Em6JPZjI8oMTAcRey2O+Dx4R6mUfSQr5Sq9aKMAqxUy+ji+xFRTlDr3HtpdkakQ+FV0emq5ltvzX/8I8BglbDmevCL7h3uxmNwb/CTmERpVHRoNV9hFsAbhoT42jL8u7q8VHY+N+ZJq7iwEQCT6SLotc7AU+fr+2LK+pJBKHdKNi7ETUirY0Vvh3mzmIWJmTMM4q2prEvtzj1Ldm2oXu1NtNPOuLrTHxDhHfdmpcFdf9ob9eeb8w/5DyGQVCvtjkl7F1sRsSbIxBwR7X9OkNFfLgrw5PMJdrPRBNAg3aMS4nB4Qb9c4P655i9FfVEA/HT+XNDQ3l/J3KxDOlfyL2+GtD8OoXv80FV0//v6C26sXvIHLcRbLmT1ugHW7TDHlLqdzOE7LE6f2UDS3fni1asguvryatyNhv35qyZ/keHVxWnU73Xfte9uwtKXyYv79pg+43cybg/CKTEiIAF2v012isBycBKTRR7YmReDQHkQ3RHYZrvbu5sYOY57w6GnhJq+p3rWbVXA7HX8ed5hjyjqX2fOr0whtqKR8zuLIzSK2EmwMMltL0CZJnqE/y+YtZgLJ/FVFyYtZDI8qiVRMVNj7dkjG+MVH9MzAp3LOXCZ3++1j1TiQfqQQErZYyfqk+ACDD0hulT+bljwt5RGbrYxzcYVHeiSCYejjWLTjVHxVuhM0JZwEqq1VGKKces27HzdtqIQ3C+fwAlyh71+chUGN/ReyZjAtoc0vJtekpZNGq+gyFvzKHPXJQsyp+SaN73gegDn/RsFre1LMMyGzh6P9r1hUfIezrKDfslZAufh7BvU2jNxlrBPcbYPXizGVtIAZmtvmIqt9Lw/ia1vFXQyW0UQhJetzKk0CpXYmokIRygRoZkpUgE8IRGhgYvlitlqj3CkhQlDxkyD+G7LhQS2u0vJcksTAsBShetp0mXV0kfQwSd54ucfE7J7vKFH5CyfpodSA0oj18TgotmAcRLuSF6aluxqKrKrMWRXU5BdfTrZuljGiUULP6Cqi4aq71M+OHm0S5coR/jgbkL1STtgx3H3IetirmALlaqVTe4uR+1pSgYhuyL0zBoNBDNHr+sYTg3A0QfnUtAbEsUWT5EOYyy9uLaDJh0iJVHTeAGaukRn+tOFZorEhe6tYblkvwiLpBiswplspfA4aSEIT0dh2PUu1rTUWLFZDf+yncAFWj0lB0RreFg1SY+RcEuyvRKdUmg6Mfq9Y2n1jleXd3wa3NtoNabRqtVo1dtoNWWj8NqKu0koMWb3Icw+H7wqx7XA+OEPGjhrqXLcOVTL0UFV6lKu6adEtzcZ9dtzeCjHTRwCwNTheg7yUHF6+tKvjcBheMBx6xZmWn4S3Y07BgVGE9+NbTlyCxaDASGzGPSjm927YQc//Ty5G4UGLIZaf+GxcMvr1o6kvG5Z0/JNd+aYYZFEZEQPWAjURrDqcQ9xk1b8eRpOp8R6n+QLaRdY3Sa8oL+UNvvEfEk1HC77jCMB51FjfHOVr9brxaC6VFb/FNbjTSU3hnJZ/ZNgY9TXYxZvswvWQmoC4OWoWveo6XKpsu7Qr9pgdwwWvRuH4XDdpaw4QDPs4mJQQu4OcF3jKNTUg0pRGDf7aOIpcGm1kU8LxEzzc+kypk9z7CPbViWl7f3Tk4PGxVrZTz5s0KhahUK2KSsGcu23HPxwAmW69cHXWyESQ9TYxlt9M2ioC5MAsd2N6dqAqz9zTJ6JbkI23cNqKg8obt5RZ9TJOIJDdqJz2n04fOUlMoStdbx53NpT7lc7M4Wmw1LRhbJUaA7kLfbujS4q7GQwFVb/6a4WNEUVdj9ss0ie7vHVFwjlyRsbLq+Gcqj/GMLFOahGFm8JHt5b3AjcD9UE/kfy4JE+s17LXW/TfI3vgT2lFywGdXko4djmqUe4aGNpgJUfGPDLVLT0BReXc5reEXB4oOV3zQFNbz+bnmb4mNm92tc3aImuVZaTdejuAJvq8gFCVDKpSMxkTu3mQV6KQS6HsE6qsSAe3Sndts7ViOcA+hWXlqbRbm9GthrlQvDaVQ3pGF5ScLnimNo33GEOApEf2r0iGkQyR6FForFlxTRah9ouKpTXOx0V1AuciQrCDEEFHW7zAcYkBhWtFUt/mpEKSGqkvL9JSJOISjktkhmfGpExiSYVrtFx3OakKs/YNXgVHWtiqWpYmKt08tCbdm6FTKOFGL373Z6EyfaGetsedOQtS70im1ehjaBuH7ylul580GOCceHb4NangHF4sI5PVnGqbHczD546/lYeElvRlDy1YE729VTlSN3zckdOLkPK8AEjoihtRfMEkr5eKtcXz9KKMovN3LBq+eaLIDzwhfgFX3RpkMcl/lHSFh+M7ZcgDw+mLZr7igJ7SU2hSFokRW8WtcZY0N48piz5CwrzRUtOqdHv3QxhUwpbIDcIBCR6wOKXpTRKLhUvtLmxoHVtAbQUNUXVO7mKVZ4h5VCiJgqMNASiYrIurdbW+Fp+RH2T6elwJB9yz1JxRomaznltIHQ5XARFbw2Ek59FCZqRxdp6Vno0e56DxRwH+7Hbb99M9JmhrptcjcP21/UMi1plNfWqRo3XcqzxSlfbcgbz5R7bLq5Xqs1lh6nSrAvcU9bRy7/SQlpOt3yqNU2fUu5pqK3Kz7Du/MTF+zmWOB9bFnSFQnROGUV8ggeRsMRGq6Ac+sa3Glb+Xg3/B62GMUx1r2wpmVp9Tqb+tPXvCatXdQWtXpn2VYS3cbr/lTnVTD0fW/9Br/+j9aGzboplo0b0l3NnlrglAvfgc68aP2q34tbSrq/Pp6crP1lPpzOwF+DNpGGcNlcnCFW/opZw/+laOjOzUqvp27/3KBm0fG358Vq+XFqtJyt7AfVvqfOJJiuXVjJo78x7Am0tWVRLxpJzWalry8rS34vEcywS9AagfICufTXRtBNneCea5NVY2Wmdu5CUylEP0NFfJr2hhoCn0JNAfpdMQYAZKMgA1jItD6kGl3DC1Likb4aLNXYR+8vuNirPvo51Z2hXkY1v/0YbikrCUvM99nRV1+WWYvZV0zUa+iu+mqZP1R8pKjENK36Nr6DWAf5bPLg625ilAbfubekCmaKyPClEf61bAYN2bRF/wS6zQMDFQzG41QI5MgS33ZROB1FEag1vZNgR/lDaI6L+/q7d703nGdMGNIbTHhHR9uQJt/yha/zFWH+oS7p4GobKh0MtQSzUxbwFwyM6CLK+CCeEpWFU0tdxsfCTFX2kRHYxGJX0RSFfVcBa2pDJNByJN3i09l55whpBAZkIIKAJ8n/GkiBb0i/eiEgfIjON8bg9p5TmFVkLOKkHfREIazBHUrQN1JKZBI2GvdCrrUgnkL0GaVL0w3xTGej7Y7iw8JkTSS++7pKuKo3vHBRqHBQgVZgyhJyAdAUvWOlztJ7hHsEtPujp4uLP6JnP7LF65gB09sxMNSJjwDz3wFSIGCy4sAy1x+/GpB3SNC3Ku2Nai55IVU/Gkz/pQhrkNPwSsSTGBCFdZn8jf5eaQPG69ggeJN45ifrzm2io866IBrQQc73vpRbOpOsaEBJ8t49FyMrEF/h6PX//Bm0UWFJibrTiUNpFK7q6AJkmSVtYdr13DFHguUwdGnsf1OiYA/UCm0wG0pgKi0YFNCT624GqjhqCe3TltjdUhPEy+7plgBCiNNUqnE5kryDVjfGwRwoHcMmAP8FhQ1HE6e5fcNvrj16gUPN/1gIVS4K1QNF1fvpnLU5sJNwKfDT991uSntifZ1+IGIFX1nuSMuB/Q4vvxz27kqfy4EjDqxCrW/CqF2iyUQk01JVSuz+6besn/3sW0O1dqIOcWiCTNjHkqT2rQx5YkP07ohzgKttch2xUdciqkzYLyKbNAvHSZkF6adNTfDfgxYF8A+ITGhVDSRWoFgj+EVTrdYN23QskV609wLNH8JApWqmu6N4gSNq5R5uTYFpzms5xJrmWGKr1ZYSHfYjHxgjdo+l6lvWkynuwOpGvrr04HQXS6iml+xTaO02gmw4HqXJAqxxAlYOEKq6ZQP9m99lZqrRGMdgrBqfF4MCeg7pZc0Um8zTWQtNzemrJ9QzbSNhYDuuIwbNYGdhCZ4mXUb+XrpjxNTI25/KLlvM23ueYmqK4qGbziyAwtQ+wmNKLZmQ1TEN2TNx0ZrJNb1wxpRPLzovxOPdAygSAVu496jdx590bC0/GSTSZnoyjDqnLMnr8d2p73pcvjuacyV/zW495dPrDFzWWfQadBO0M7wb703CgMtLIL4wcfBWTz5Hbu0F7OA7bXchuUgQIdnFIyTi7jekGR40bSd0wuSUXjRsuytdd3dK7Q+mCFpyx5+LynI06n5NAuWKQWyv/12yzzCLy3AF/KVARKMBFfsQiq66kQUagABn5EYustpwGGYECZOSHQuYbEn0o1l98L2Bhgxc08nrao//+DguCkbOrMeq9mkdEtC7bo55I1nXRONm/PD3b2to5PWUmtvx6dNy63D/ab+03DvY/7WzDkVkFFe8ffSAF25eN5ruzw52jFpRXjeqnZycnx80Wq1xDhds7H/a3dijM7vHZES1fQuUfdpqn+8dHl4f7p4eN1has8ot1u/7m2SkkVFtcRkWt/cOd4zNKzgom9/hyp9k8bsL3VY3My8Pj5s7ldqMFdtDiGirbOd9rnJ1y8iuYN9vHZ5sHO5cN4BstxJw5O2qctfaOm5JrmC3N1hbtdnOnsU1pr2C+7O4fGFypYLacnh6oXlQwQ5q7ZChOj3dbqHzZLN9rNLdROWbP5tnu7k7zsnV8fEk4fnBAATCfto9OUdU1g6izo98vt3aaTAjKGi+2jo9299+dNRkvqi4R2qfSU60srSyt1paXVhwgZwzGKYEHx0fvSNlatVqrrVTLteXV+tLKynJYc8CygQNM/FWpw8b5JSk623EAn7aa+xR17iX/9DKni06rSeXjcqtxubW3s/U7O8DBEDvnJ/vNRguEWUDos+Ry7/i0ddQ43JHleMQPdt41ti7YnXf58XD/KF1H4JsE9MBd7pIxAvq2d063mvsnreOmYAA4z2x+iHrbO62drRbpwdEO0hzi89npJmKGBN5pIQaIr0zetKr/0uow+O2d3cbZQUtM/oP909YlJWy/dXF5CPOwEi7poKTux+Pm70IpMKiqgLo43modk7E72N+8bF2c7Fwe70J5jfeFzMP93QvAcfJ76xLkeGvv3cU2JHXMTXIumN2Ds9O9D1UOM3XDEHZLkDsnCFArQe6dIIQHB8eCmAc/lsYBh5n5iZEwcy+exgfR1jcnzGnr+IRmbtAKP1Qvl5uNj5sXLaolK2Yh8HybK14uEydnm4QeJfZl7XOFY1PIeEEVNaNjqqGSmlayhEqWtJI6KqlrJbg7y1rJllBDK8bn3YPjRktNYP6diR4tu9ypgfbCIsmBTskKohpiRXuN0z3Q1qKwuopLNxunO1SSxaRGM1MHON05OqXKXE5RUQR9AxNOpPN47cNdJECn4XASjV+7scucjDTnz+HkxpsNdEDLcjn99JN+JP/qCR7BhKEIrfyO7KuJu1QqjWDnMtGzl6jPaHsRKkL5uxkDfAQMfwKdioac2oTmeObU02m78xXSiYe5oDdkRCljnf5ZskD51VyFWLPWedcvLy4uz8b9/eF15OUk+eXybtzX06uOb0g16lukhei0dRxNAVeufTeNcur73YSeoOfQp1GbpvzQPrFj6SXyH7p2TzZa6q8ujfLKITZxGkqTfq9DL7ivFGiC69vpdPT61SuU3loSB0U5ea2Y1Ve94ZhWBMfUcYbVVJ019TDxNPQwSWymnqKZVdWjSUyXVGOKkbWk9ldTtL8suunv56PaXk7RNh9NkCe98aeM2xpDOgk7ZNKkQ7tWiOmgZATDmNNuWVsIxyHZehGUuVfDaFq6mg9z6KoYovcPUUG91faZ0p2GXghTsqprjhU24yaoZg+e3zy+zkMDihqA0d7lYXNQb44AFdaTSVJgigYytLceOv4PpkPAvdVechQYXK3xGtrBD6gd1hqUqqZe57SXkQTYW+PZSK7IaF3VKwaMwr24ckNgAuFCEHPqgLCb/lcfUwVXFhyjSxax+2UXXz+Lznr4/tox/pAtlyHkf8D3N+wTUgk+hEUOafqMGRbEY9D35tLC3/0kcvcSr+oSB5t+QrPrZwJ8uq7afn+76sRdF810NSDfXziGUCfeJfcSKeyEIGsPMTZKvcHgsj2NenlrUuGTS8U01gwhutPu9yFwAitlcxFFblShp+hPZIdwuYMf6CsXYviBc5azLqplmcGyVuEHjuqKwO9KvpNfhAcV+noTTvdIfWcmPIEYwZ60PSk1BWkYFl5PcsJy0hDs2cSTOlQwAsOO+/mH3vT2hLOQh57BJ0BzwnjFPM7wcWfYPSUG1a0AtRzESvLuJldo/Dgd9Ks5oZkCwNaPJEkhACDxUC9rZCHIwSJnSpFGu3hSmYqCMcswRiUjuC+AwZqavBqZ/OvmN2308KwSdf6PRi2upQTPxK/hloKIvzJ51LknB4pwABZdc8F9aSy4olWdn3zUuMZCctOMIio7LjFDosUER8QzjnnOISzXMJJuwRaTWUDD+w/h1WnU+RpO/TVYju3JR8KCPBiqBfD7GpJJrXjHd2TmIBJP7662KYPz+EUMZi1Y7Of0GIrhtj1pkAWNngx5ZyaTNKPHp5SkpE4LO9bVKbYApOvtNJxMYdv02yQaJrSWwEMPIX4CtX6Puu1puBlOuHhQ2CLVwtqGzdLOhhZ6KVsVakD/PjEfCXIsJN8tunajcTPs9uBJSLpiMcKKQW9yyTqv0ZhyXZGU25LuoVE2F/zKx/412pkZC7i/JheP19r20e40rD8gGf6x8KzBRk/RvDoe927goeOz5oFT1th23JYLyPCZv2P7eycJvKzkMwd4sdsskJWd5oEodQ+nrOsxF0Q5Vhi650FA4L4Lh87l4XZ9azpL91TM1d01P1076w2ntSoLH9NeErnqTScOmGpBe1dmUyKixeyl7Pzykg61ihCtMjyqvg5aqzoa9QP/Uf6srntwum/I4tZrD4X+Jc0D1EsD7O6a112pVeurS5W1WvBWRY9IGNh8Bkvlaq1aqy1VVpww1c80i+tytbZaq5SrTpgahVkhrdVWV1ZtEMJtRo/1tSK/gqBfXs2nYTO8D8eTcF9pYdfz25VlI4hPhLwp7vU+a6G//BuNRaQkVpeCf8HvNFSpELx5g75UllcqleXVcoFCrorPy/UqfCOgqwXcTaE0Lqfj9nBC6B1oC+YuBIHlZ8VgXgy+0SSr+W/B/w1mBGN+Tn75VtCw0SpVs8puJf+tGMAXdBdit2ZhnhGEDKmFc8kCBkBS41/B/3PQQCbdaWsHvPb5axpCwasWA/6Gu5YvlqWCWwiuVQsLZIdHIBleDT0Dzz8AKyesgBDxQH+rQfTTxADn2hEamGmcR0k1xegz8VcFV7igggo6uKCKCrq4oIYLSHf2h1jMWBm0zdmV360UA8Kdq2LQIZwq8jowARaC2nJlqbxWri1TPxir2zXqdnF1VrdC666V62SyrlRI3YpQVR2jcgfV55WrUHm5vFwp11cra6SuaPjKqHuFqvO6NdpwtV5eIkpkebkYVEXDKXq8BJWXKpXV+tJqbW0tU4/rULdSLZfLq+Wl6nK2Hi9D5epqlSik+hrkws7S5RVKdXVprbpcqVVq2bq8SsleWSmXa/WlynKmLq9Rqmu15TrRMitr2bpcKTOy1wjddYIkW58rFdZ2eam+TPq8lK3TFSphFTJQy3C0Xs0m2jVGeH1pmTB8rZ6x21TGqitr1bXlerm8nLHbXMoIy2v1WnXN1+2qu9tMvKtrlZXyyuoynB04el119nqZzSvodX15eQn8144+V919pg0vL9XIgrsCAlpZcnW56uwy00Jr1Up5eW1tDQa6nL7HlF1kStWWyqvL5XqmHjMBra2WK8vl1Vq2DrN2l2tLS6ura8uVbD1eYu2ursHkWFrN1mM6J+vLq0tLhN+r2TrMGq6u1CvLRN8vZ+oymxSV8gqZUbVaPVuPmRIirdZrlXq5kq3HbD5WV+tl8r9VmBMZ+lzlurNG1Ei9Us3U5RWmOmEiri6tZBRrpoLIRF4Fjb9c9fW55pdrEI/66uoKDPOSq8s1Z5cps6vVlSqZVKtU71Zcfa7FTOUKWR3LtTIlu7Ls6nTN3eklrjqJ7ltZoW9F1NJ3mqn8leXa2gpZMJYzdXqJ6c2V6uoakc6MnWYLbKW2trS8RnVfpj4zNUIMA0Iz0Z0Z+0yFe3mVkE609lKmPnPNWSOKoFyGuln6zOyo+kp1aYlMypVsfaaLBdEEZKVZXcvW4TWmOckyQ6ZzeS1Th9mcIjs6okUqS1TtZhFtOqnqNcIqYpCUs/WYtVxdW1uuri4v1X19XvIb2sTKXiam1FK9Cofdjj4vOfvMlFClury6VlmCNzHkS9cdo7LfGCFb4GViU6wBw+quPi85+8yVUG2lXqtVl0BrV9L3mZtgxO5cWq3XVyqZOs00PrHQ11aJVVDO2GlheJIOEy1Uy9ZppoSqS4TupaW1lWydZusckU9ishK1n6nPFc5uMpvr5L9qtk6zDcZKbWkFBGU5Y58pvyu1MmFYZXlpLVun+aZqidgyS1XYGGXpNNtHEs23Ul9eo2ooQ6epiK0Qfq+uVIHbWfrM9NAa0SOrpPU66rLusMrjPxcC8LnQPc3ySnWtXvA7sfL4zwVCUXK9ql6P9q6Tol5Nr0cHs+urB06hdrcLL9LmCTR2CvXpfXbykZ9NrRshHMgRM5XuCOZJc/rW6FViQPrmTVDTSJcOdgH8JpgannXujFtYsA6YhZtuYYNSTB1na5wA2ip12YBvjJ+oP9z2+qGIAiBVVEtmCT2aIL8uL1n3xsGvOWXXUoHJpAr5wzxZpP1i9WVt5ieyjjOl47RgXDc3PI56sgDkzZMFamSE06/T7nfu+u1pqPn8zDGz+GT2s1JdRcMVvA3qyxbrkrlVdjLpWVlA3bGMD3T4Kkvkp36fWjlcpw6ijAMa1Dfc5R/Xt++Gmx3Wbe8EYxB1HaLyWXvvzOQRjP84nNgHA9IGsni4bPCQVGe8k4qGzbTqZ+6RhvwQRJrITEdXbbWTa4JCP0UR4bqt+Sj0HqXM26NekZVBLKv+ahQUQpYl8kN7hg2gj1jkq6ypv9M2HIadadjdHU7o5SNcOA7/eRdOPIW3D/vdzTnHrRdBI5vzPQJgFdGbbp6yq/Yk5Bwo4xO2cUhjmwSTaODO7UOvy6LuoDH2G8ENz0BMKaIpQYRnfeduPOYhwCaRfwiEn00hoTECau4rHBvBfdTrgmv8XwH+ioMyRHQhLbMCNvxE8JgmNVJc6rRX74wZq1H3UiHQqTEH7g9RhYY6CgIwld2QMCMM/BVdE/+ZOm1F7GnE+IdPEWMy7fuLJBKtjgpAQSC040JGZM/EgkTd6icpcx6Jq1Hy1BaCZ3PV11wu58s15Joq2uVyOR83XA2i6YoxuVoz9R6b10TV3oRTa1o/ctaaU8Dkk1meUwEYP3ZKpBRb82q/ezwdHdPwO2uZoW1E6V9eD1GKCbUGOLlKwU3xxouDJnAMfN1FXVxL3zWNP4n69yEVCbijjUWCC5EIeJqqKFiAVGGwJRxXy+G04FeuHVwzHjB9xqYqwL50zT0u2TiQld5DgYnxWruhWzRBDic3r4PcMGJ/5XA5ae6uP30d8JdLyJ/KfPpuyZfFA7xtCeRnGklXysl0u9I2KE3urggQxM5WCqVpdBA9hOOtNrxa6QeuFNKJLWWli3cW5xL5Fs81g2dSdF5obFOTYBKOe+2+cSsGaggFj+TmrRkF3w3ve13McsVCVkXZ5BSjA5SjxjHqHLOUSrDmRODiNmmxE+Zpw1r0/EvyKaNEmje4PaLJmgz+AJFhHV4Icp+DYTQNoiEkaXPKbC7nF1XJc4JOdOyUfmMXXNVWhk1ODr/A5RaPjk/mSMXPf9mpSkNlisGQdAQxQWShoJmjjN0cCqyBWlZ+LCefTMT73XyvoKe08S2qwD49G5C+nsKaKYxdNhx6FL+DyanYnMzoeFYjZidcG/BOyErBylEGy9MlKYO7gPYKZub1YlpY1HGsRCr72liODa7BCTHVgrIyVaU/nfuC6HRD8MJBXVqthEg7igLJgj+URmB66RoyYBHNRHWV0FtqZnyW/TE01XcjBHR33AuH3T61BnwWCFgnMhTJabGoNUXtabglQSuXZPdhcuGBsZZIUcVcwW7ZJlpiZP0yMyshFwBZ6w6j7l0/zOmr2TXtMZXEfalefRqCAWvWkUdFWNs/2U4S0u8/x0ZgrZoWgq4u8MTe7zontZjSTNYIhwWwMgrMm3FUTGjrBHwXHgN2rflYEuU2SQxhUW+zoA2/eDx6qlrZjsRtKa3h2B5JSL7H05BBZOCvDoSq12YVeNvYgne3Cd012GiqRZ+AQp1HiafVuuaN+Ilmq+S6WNB1yhwmrVBfE2M/DaqoCImELCVG/kYboBgVBhxkwFzCzI2gtqnTIGE3KNr23wCwd5Jsz2DVNdS02c+n9k4p5A2fQuabZ//uWe8+FkJRLc405TAuq5HwCDfqZpm+Y/2nt7k048bqr7vdHvHNfzeXL4XJGH98syIWqUfGaco3wx88urtCzjjhRLpv9/UMyn4n0su8rKCYR5QG+mq3I/uCXMbfX6RzBjJM+rMD3GfpkHe9z647Kv4OInSb3HvnvOUifXu40qA97dzKagBBTQujvvxOZ5Enscm//qXD+RuFjvfGk+lee9x9aI9DspUxTLGApSZHpzfwsefghRor600Ot4OSNH4UznDbJtvVBYhpyEoSWhaWPAUFg+xlzqEIJDafe11Ul4DmOsYAAH2MP1bwTR1E7bVaJ5sRfaPHn6Lkmh25XPWGl+y6AZmol6NxdEPYN9m60g6mrvkqLevhK0hwA2FD4lnXLk1xZMGGgd2mt8n0hpdkwE/qMnOEKHnus9YWa0ofKWPpY9Q6rfXl/2fv3d/buHWE4d/7V0z0fNtKjeLYzqU9cZy+ju00PpvYXl/aN+v150eWxrYaWfLRSHZ8uv7fX4JXAARnRr60ze45z25jcUiQBEEQBEBA3SvMg6hAb+ahlDqmDOOMv3WK62FXi+nYW6HT7eYXJmY5qz8Zvc13TTYZ9qVQp/829j+IMcVh9c/z0XSiexeA7aU/DxXVx6VHXbVtJkhjZoNvmuGSQotzgxL7g4fqQbYDuypyMJ+wNLHRtGrt7dLcfe3vMGKJSuwPOiHwRVFiYN45L53PhWJFECIW/oZ9o85DCPjQHfXyHjUKdzsCtR6Np8PNESOjo+mkuzvpnF/w8uHqaFBEhTujq6hQP3EGmuIfejbEdVQO01VdDvJiAwKVmyOaVDkB1m+zeK8lwHRHg+n5EK5IMKQDYv8PCrCIavvF6mBU6Es8OrLdt5XLU+mDifjLR9C5PBVKTZhdXqoPhXig/eLDqNMTRwMx1lJB/Ux8QFx538YrrNvAUpMlSfNjKfYrwHVNIVIzqH0wOsHkqK9WU3WvPOkP8x43r8LJ2h/2J/BkVpN8PmmKtMxe8Knei3y1M+gfr4zHzb7+i4h5nYEayhL+fdZD8bLUgqgrJHHm6ofQ67aF6gQtji0cd66EwvyEFZ7sdK7wr/zEevDpgQHj0GMGl6On2UL+LKOOYLbaazG0YXTpYlvbn+mYtWEJx2BDVDPoUZnN9b4z7A3ysR1LiwjFBsAjmwnmzgMyy+GxQoxWZiHmfBKNeR9Bp29ZwAJ3aTMfXluwYXQW1AUEYbf4d7UPUZgYD9j/+dj14fGnyCAakiGEW4wU8tbFowUSCoTiB7pEP+t/NAmFD5oaWTvo5JBV0f+QtnZmGkMAuYU/qLnZD/lJBboW41uPIYrfi3EXtK3tTBHQK0uJ7UwR2Cu7NyCs0/iVXat2pobzyg6rDf++skO5IXckTlhOaue8JXVG2vwxiEEUR6OTE1U1FBXmfNrOx+9H0/FSktcYxEds3R21tmfjOtt0vxYOwSPUe55FB7Grt0haPaOtzKnpPj4/lM4xiC+undFMcDlLo3RuJgcedlmDbY9bPiJeIFFrVvB99uylS4YkOLlYwC8WFjngOqBfzku3mjKxAgYD6WyE9fTLjvD4EukDwvfXsG0448NyD1vCxwg22nKiEqwEzJP0zOItlxCZ3MReYEUHohI+qwSYko94ggJl/nCYkL6gmqKAly9ePEOEZxUtujSMjYiIN4JE6lES7B/m0xvuClQykzeStqxXCwmPaa8QBlCRa8XyJTNuRX0aqHUApgktFsetC4djYZZfOukAmLgTD5xxOpZoIjGG+ozJMoI4PlHME+gci/Z8yMjwHWUaEckdXSKis1yqcxGyG6GBPM4acEVotG7TUN0ibtdQyRC8obu1lTGce5lyot8F2TdI2IrsBuUvCL0c2IZaKX/u6TdFTf/zb4fZ/w9veF/+2LLnYRvZhth1jYFVheEQZmeyP5Q5LHedK4NFT+qFZwzWjZjmBGBpojd3/2YB1IyFlH7vC4ru29MqmAMa+gKVYEq3l8pvv80eUb4bqa1TUrpWOMKAPI0I+5rpAyqB2jmwm4jB56+jca9okvsmfPytGA311i6snUwjqRVfrSNa7uuU5fMVbMCK51D5cfZMnfQwRguLeH/6UpozGgBDkwMF4dCfXDrOnS3Vwrhwpjmoen9tdjZJIutZPwhZtnxNgXDR2AzpooJAvHLHwlYNCICdSicubNZacNkwn/NhvpCGGTJ+mdU3VV8uSS7TlrNB/yYSaJScVXwUYyf2F6GUGdb9bgt1MyMK6QospsV2x0OEvZxQlAW//ooL4VXHNpJtXQ4ks/xAbFhia/IRcm1k0MHo9DQfzwFn+qnfWw6OtfR8/lZdAvVHa+FH2frQJbHV0nWVzF9a190JWjRlVhwKUxvT/rQZVA1OFRXTk5P+l7Lh3R4H2uiSDdSq2iM1FRAUH7udq05/whSdvdHVEMA0cQhRQxgtEjQ08KorUb1gLi5EaWO0akgwjhRr2Gatasyd9QZN/cYpFGndSfiptSfhp9afhJ/q/yVBxA6STgW4RA+0L+CTWjKl3l9+ToYYnOCTYgHmK20Da61IewMcpOR2mvDjRv4uL7dCF/vmWmeSzw1HV80W0gm3SkDu761yqNEO8ZUFQIrWB7slwBiEGIBw6/xYVA5J0sp8r9UptXqQR5m4AFNo+p6+VhekdKsXkDi6ss7aUSpCc46BSis8L0pK3agJJmLEijATW/om3ZSOz9zbkkPUtzSqdaNQocItB+SaSgPSF0lhQMJVtGR0qPbtxsgA0JG6pJ4yeZivcavOZT7unOYlLc0VV+jPZuNM9Ke/yrvYkaeA0AqC65Gkw4RxJhiS10E63iXvWqBGYTjsZrZs3s0mr6SlK3mTcHcq5BE11VaFU2zwR4xK+92NrkJ+e9JFfOcOBn9i5eUg1eg5yAPVzeFd4AoI1DAPVGeH3i0hBSllVib1a5qig+tDPqnl94AfQljDvs2/MuxP7M/eaHo8yKlPgi+1vi8ZYjH2FaB39IrcBUo8CXy35C37dPAZrhVJL4mPkQOFHVb8wfn4RJ4Pos2p0OiPXQwuxvllP7+Kys/NYRc3KKbn553x9UfR58F9FJ0c7Me90aQzMBao5GfBYeRhHR4gj+avKzvrOnVlaaZE38S5Lc7QZH9zY692ZYcQlzbcih/gQR/+j6UswvQoPWFPunUwx47wGbt1lFJrCb2mFPr3MBSyASkGaEW7HR1DKJtQxCW+x3bxeJaMfwi10VZ9siC6rRPbhCiBknnhlsQQIzXVFYRLsCGvJtcruxObqZMn/XNkE+9PLpGZG/84Ib8UUo7Qm6cgQRooUIACQl+ekt9KzCG/yRtvdU0nbjuGj3nuIX9RbCf68NELb7TYy1ikeMULbKRY350+FkL56EIoXiOiln3jovjzbiBE/inVZN1RIsErGWOHjfmcTc0ymmgOvpzOgTNq+QtBNTk04mI2HpLPUM0yuAHr0Rs+eGT9hGMDh99t5F2/hRMbGI77w0X98hr2wRL1qDYtFCf9/UaIWOLY0uRMyUhNMct1O2vYd4fqCnkOUkTWL7LJaJSNBj38ABQrKzkQOYAJ00wVuRtwi4coeC0+K/G7iepd08dw8vzmIgFLVEwrOdGApT0mlSwlVoAydJkCFXzw+0fz2eiEykGELujGg+B4QU9hsAww5hJ6kqCvCOCQb4QAIFzRaKt1dKjEw3qMh8W6oWOwxMva+7sCPu2+/dbtGnSi2TsPH9TrZX74tTBZEXYaTzzcoJd4kxVn52VN6PU5auZJiffk785Rk0BYCX5L6lryEvksqogWW2LVghlGK0T1eJkhglp1jMLb1/NKZmYg68TMgKqpIXksbuMhYkU34RzYooPkAYbocLendixXLhuHEQtCowZ4jnE3ZctS/7x83UDyKN28JTo/uoGyrApUrxYU5/jgEHIwf8iisGRWCIqNgabtm2yRYs7ISMGZImHm89XmRfNnGr6RuUzO7RL4vpoInwtjtB4TyMSPfKOmdx/bpmU7uvyAkjiLeLLo+R+RoJ/IAmy+vM7YJmBYpjKMpw/d+JDs1RMHMt5FmZbDwXvXy9zJBfN1eVUc1EQJ6yAfqY32GIn4YSC6wpsZjxEA97r05LDbwKAco+bAbA6CkCzzbkGkqqF4VtW751ComnhZVZOKlBDfGxg7H6hAov5qJCGVQdbEqnO2HpVAtiQdbk+VkC1tv7GITML2ewBfEqqhGzy+tghNQ/f4RiJ9GvqjfrHZ2WyaBW0loSJOwUseO2r4PiLYBCOKih4LLW8SO8ScQXxZHDMw/z4mrPkbAZuh7zd8S3OJiM/3aeKimxJIGOE9YcTboj7/IufgQ5ov73E+Fe2FaRyNcwjRbLGNpYfWZpuCFhpqbtMxtik1tqhcTO4qbygg4m7OLjWCtoA9wCUXnNdsEAJkt1cEhYMIObAlvogR7MCbJP1EArplTQTfImzLnQQVB4rpFV0WecljRlnfy8oR8UYaFT2WG3NXU6Loc+dT9OUNQ2PSt9/IHYL2hPcrnIqs/DVFL+8S6xsFtQzyyuSYEfxqE4plRjt2p9FVp4Vu+/GlfRotUJtSfavsyUOZ2lvQ4tcvlGyFpVeQoDBV5V1V/HGk2ZSpY4LlY9WpEUGXZlKllihP1dH2UKpU7NCAEu8Z77CUJk77ZvHfOZ8d8UsGg9c7JRcTkBu4hsHZW510FOvyvBbv0TLToifM1+6zvANlpWBMBJFmHIMr3DNsoks6oD3gpzSmRvqWj74n7uKm4+gObhtKt/DI5MAKvHxSfVWvd023/ppaNIpuzGigFbqz1PUdQah5ga8GVH191xGANCCCkRN2iUJkpq856gPitholrG6VToDrAxJ3da4HYKyU3/9vymDxOz+Dxe/6N3a5AgchbreR4tXNlL60wu2xlEEuofRiy7pET+IFwZXAQWBuAoYurXaN3x3v+aqrH1r4m85lKzYkOGO7IBMDSHvo6iHZv/Ww7e24refiyszdlnurx1cXziC9a8Ib7KOG2CbheZFWYxbWiDXUZRrQulpCN0V7fHld0Fzk9exaiLVIDXO4iZWcjzKt6lbP/Ap3Du3nnmLB5N2AjGJYC9+DLXrN3ElYmB9pIcCtnyoYE4eT7i+BPiB0+4NeW2fAViXGwvrAfx9njbaOdYeEj/RbjoWIJKz8MYuKHEsk6RdHHZ0gxMHHlLWBnxbJFDDT6luQryMyIN/coAV9Y22SqLHuAnlgt32IgmZHeWDGdsgoRZZ4/PB9K0YOBqn2j5SKJU0Jt5H5zbf+ZWeSBwe2IuUZrT/GAM7kCGXno9g1HvuZaeedhKAb6pHAGSOZxrVFTMcGpQIi8Woz7c5HunZBQm/7aJMMa/Fj2pJBMt/rmX1dQltw3kn4z1u3nvoe8uT5Bq3InWyK+r7x7pYcj8WKBFUjwdX4ONIgIt/6IJ48TXjUB8KPvGBLr0vzFVesN8sVwoKFszA/L/kaL8DzswX/6ihc+77P/vYjaCzRR94DyePmXZ30tV18U8Rv7VUYqP9EKo5HjymEB7cgB963J+PRednTKpkqY5lPUkCV9zwZ1emXUOFj/BTwpjx9TX0SiYlEkPFnEzrrip3SOYH1PxR8m/sTqQ4Wj/vDJjBw6ZSqlj3JM8jxdcl1vGxYlfKOV8J1IYSnuvK0HrqnmDtbTYvMUc1HiW9pVa/cyn4UnlTYS9bKpHlOr52GCaittD/pxo53leo8wVW6XMt3b5q8MOhg4pwTjivkkuq3DIuOWsNTCnbPLTyjTGRcN1BRLgUgqXRUrpJ9M8hJ1CH/ttqy2kowqaM767zuS1P1v075hEh2QdYxpfQ/D+jHcCs1zkJQ4+hfVhflvs2mzhFoVWaCiXdlYrvgXapvvyQnruLwlzycKDqxwve/725tzjFA/PwZjx3sQDGPLIjoJUP0+mVGdXX8fMD2NOfiK5OHA+5jeDwQvehxVaAo+ynTk1V7tonLIdcB2lvuUxdHreQPecSAKO9U00nBACzF7W2uYVrA40zKkYDKujfxWFDvAnJneL9yb2+UAmMIGZLcKKmoyXImhfNe0vqc9Ie9oAPQLKLN4R70D2kGLlMeMuF0R8NJfxhSdQpu/9KJlTpCYjDr/gUbB/tYBoveihKQ8p3FKoZpX68Fr+KAVZSHlLNVAi2M9E3sZMyhce25W1ejTDRIT0cUiRkHZoGSPsi/eMwnMzx3hMo1X6H5BvVfofkm9V+h+SZ1XqH9r5uwfm+6OhoWo0FfCRN5r+rtKX8lxt+RmkjcRa4gjj/0iwl9U6qbCU89o5jaBkAcVtsXU5ZoQ95JPNQQdfwForobzWlcbqQMUu5iqc6OAB6Ntamb6gisPXjAW4EqUzvGF7SWURMgJlDqHuOVRApSvU763WxDj1c31BEC2hmat50wFoyGu6YTdJn0gynzlwhdoLLwp8Ko+eHg+1niMAn2puc7LA9+RmwQDi4y7HnwtC9iPtCvcEzTuXfqrDR/IoQF40oYleHXzFJGtPeGb6tJOxlC2KDNeCEILZEVtvgLsi0Q+Y6SaMY9fQsc5yRfUFG6SugKn1/ZjRfKTgejY2rucUln5FK73QhQ/QK/UtFgW+ZRiFNP6EDpUXS+sA3IvmEPFChbSYaE9OwlWcOymdLvahbCdyLjW2oNBmk3D6JY0EV8ZgdYFRiWLMhchn6NcAQkYWgMS0LtwHlaPGycx5G7/dmCqGLAla45H1VwqCr5DJiKPmtukLJ9WfKO8OuoBz3ni3hDGbYR7YaAtOb3ATX4k5pMC42NpHb6ZLkQ6WNto8O5qjtHr7ehKd5ykSGWEgVihW+Ww3U+mFsJrNegm6aKY9ZXaqjBJsFfWLAOogcfrAOkHI9c1aN5gigTsZ87o5d6uJtThGEuxlEgGGt5tA30oTInGcHELRAmRbin5HvOCZB53mvllN8JVuPjC97gPuhs0PapNQ62R5FqDPdeZSpLbWZXblmQgWjxhw+k2252dLigFVj2WPiDtrQ7GkvoJ/V2lGHIwEmxWENf8wn+bL5ydwN+RyUd4vCcN9/MyJ/YApKfj8WtnSQ20pZshbJOnnLRIWiQRLB/+xumBwb5b38r8dDgwhPKhmRe05dFBAJVlQn9Mx6NFLiBuYlcXShBz/x5DX8W9JqBwo2EMCM2np8Cs++sdg4ovXIEj4ko5s9gdNrvqq9Ggqbf1Bx7auBl36IsYUfHeacr5E3KLz/pHecuNbb3TjFZR1mq4uDLrB7Pd0VDC3XPAMjvR/mXi77RHb0CPZ7W577SMvp+fzj5cUU7R8231JcLkKVGn/Peq+z3mxspeFJ8JT2eFtdRuCN1IvSHp/8xVbjWTGN7PDrvF/mcS+HZ4tOB88NkN5nnn1JZo9RarXYGg+NO97OQIkt93Si2VaEah5QHSn0nr0JhS3jKA/Ehpr0EBflWc/gDFZgpXYUWqDyS0RGxhQaoXGygKTCqzgPseKoMNU0Ru0k4Mg3VdKrhkFUz+0mRcPaKV1jiyaKmF3ANhJQun7abCLNxFCGb6VWDMfxDH2I8k5QJ44HSuOEccG2bnG2CHnPJO0zOA8c3GE8GR+wwetAzjId5Ce0YfpUITmo+sia71OdLssYzQkSNPwSKk9sykiQmKakxigEJHGcOsRsmHiHJYZyfKFZwVhIRUBiGncF22AIprwKyR+KmKV82sltwolW9NxJpVv2+IZhiTR4ISbRzt8KBnSZWOFQQmkYxKaO2PKgqNJ6M++BlpQgEeK4wb8KtDbsOT+sws+bidGyrYqw9vGawWZZtOsnGz+t7mapbzE2+TH5SzB65fhnuj0M9jc6p+UzxPpuZskn2Ytv10NZzCGYxADE3OcuHTUMEzWtVsZUtvyECORSiTJSPUmmqq48xjiHJk0xA+v10YSN8TQeT3cnYSiokQJOeZ0ghStLSm3PXN58DmtpwKez/a/h/GsQ0ZyI0zN/fuIEkSP8mOT340CnpCHK5scGaKUr1zRPyxVZ02JspequyAULgGjdfQN1H/ZdWxZo/N4aro+FE3VuagR7bAmcn8BQWtKRlCH7cP2+25oqLQX8CKEXJZZDBP2GBBUCy3ZXxJ0xeTTOftmmOzavoWi04r0VHv4LZbKx/geS6wBz7w8zG5FIfIGmR7u1Vo53lsZtFBVnckLN3nJ/2i4lmWX4SDj4TGoig6eqQdEnm4yO+xbz8w9ljiSmfC6Y15kUzqzvefwJeB0dw0y8g3G87MwUucnAsGAUZnDUtkcgpTHacrGn5MRH4W3+jUeuL7rh/nAvZwSNpiJi9sTj+iEbSxM0l6ZywSi+hMyAODPz3cdbImuQc8a3Up1ZZqu5YsAdgAIvlLE8Jywgt6jpG7EJ+I6sdlp/CrpGuL77W5/ya1jnQ7cjzD4P9rrtm42oHqj1SDkFNm6xcNThohOcEDVarN5oY2obq5qoAPH+uwYJS6c+GzTZ10N+JTrG5LC0lZU8WOdcaOXo0updGFKfHVXI3mRZR3XoQBtGxUtPfhw9MVdAuHeBh26mCw3XbDATRSuOQjMd08vhxShNJfXEDeSgBRR+03r2F546ORE3MbX8GVtH97ELMP6bSz0lHnXarAEFdWvq9/uR6KQYNmgQFlB32S5hMu1g0s7dHzLyIv3m48tIdqAkXgAHVRk5mfkG7up05iRqULsSbu3MKMi3E63vqCs+aCvf41F2etRQu9PKlXm4XbvbC7Z41oVd84vDjkadwAKdtIaEv4k3eqco2mrvOB4PR1XbnNC9aabV6oIMgurOj0JDLUCGlx0W7u9NCkumnF5Wbdm5PEvL0Uyah2y7lo/RSais0GTGwsO4hY1CcXw7ttpS45XAWBGihenpsPE3ZCNSPfDzpF3lP2wLiUdiGj/w42Lpg6VQzMiUPvbOs2pgXSva8fz0Ho2nbQbZSCxROGsLKLXXC6dHnb+QKPlyUxZSfJ9oXVJ8/3TjWVlm7hUMthwpEW3J6QSvTaClqkqbXOFBYlh2P887nOgG6bhJvCGx3XOlaXzeoZcnx6EIfXs3qI3FeONi8IhwU6DdYOHOoo5lZ3GG3jSV3Lm4licG2dAIAkRrtN2kIGz2tcFSiw/0MQ9uEDUBFessOkvDOi1MRyIM+g2xY2rJ5GfsJn9LbTpGDYiQxMS1j+rNIwAOKB6JrP2KChIYzMbpfRlengVP4UQhSA+IR/eBX4nF8bJsCoj8dvV3ZXd/7tL2+yw8o9OnANTk0SIfRiS/cXL2l0i3k0OvmIqL5oVHcJ3jpOzk6aBXAjqn+efJEOLn7vYM+pF0+VJUaf2OnF2MvN4J+B0/S9QxvZyaj/YuLfLyq0KjFXTMkK64vtDPdaYu9T8DAalOxVk3/lbbmwj1sTXN8PhDRxBYVtiVN7zX3Y43ZbPTeXivYoJ6AMZpjMNZaBzyGWoeJYYt1PVcsGdNv/xwNF+Eq1YS/2hl+uAND0QbauX5hDLVQp8XeQvxToR/KmT+g0Lggje2tPD8x0hh8dW4qb7RxD0pAEnmF7KtUNXOAZLSgTrS6icy4GBX/1H9xVaLzAcG0Q3GhP7ftAEU/JiE+PnrGoDbt6CQzt1SguNHxb3l30uAI6NMgIHh6v98I07O7Fa9TQLhG4lmn2LoabispRMmz103VIIqYCrOHzVk5e70GULPFguBSlYEkW5XgJ2Ic0KP4Mhxj8p9JTNagNamj2RfLUyulyPtdHLIlmLpLlHIl3Nekon+KA/1nvYGWTUq/kHwUL4ohJrC++V9o1wuhfWuQKnxOk6oY43oGuBEDqL5W3JH0vxE+BxWcNQGubG/o0+O8cDqyOvbeN2klXIspQArnS/9+b2+bmiORBg7JLMWc8TQANRx9yKn/NGar/sl1U77ttLj4w95QWwOrM64+hRnACBokaY6/Ocmd4LCRtsjexoFgedmcy8Wykw9yJbrhw/cf2WM1kp9OrrRlNx/CY8f9nY3V0fnFaJiD3a0KGJ/ctZldpEYotQZzS3ANOy/FMlRGIYZkksoyWs7N1SmF7c1saltsINQVUgSVyMzDDb+ttDDCwLf4XYCvXqzHUo2RhYeyDwa9HSiL8JF4jgYo1zyZUkSopIDqkeD4KvkcNWZUKbRPboKAC5h0oS3VbKtzNC8JmsxSwojvyi5siu2zDCTmB4h6pJbiKeFXFql0aHdsq7k3g1tH6zs7WzuputZ10u7q7KTTH+Q9nSx70MuGo4kx3mcKVPb3/9zatOZ/fXoH8x+xSEYnUTyd+kO91UB1mLuaI72JJTBGKIjW5S9lVFmHBiroNGHfn9WqRblmmVtmYpZJH02vnE80xEp6KXBCXXq4HdHu1iJaIui4cwgLOtYFDd334zMSiUMVR1L9E1K+Yxs3S9q0TRHUZlhtJTJMS2ZUmVWWvDg1WAKg28TlmSBMSXDW/zk8GSC1UfyWUDV2JiGuO2Ymof5SqZNNV7/F1LTczIUH98Fn/53d0zYQp+y5f9GZnMHDTTjU1MHa7070OlibZNvnz9NFp0eX+bjog2ZjZ+vj0fD4SJ3R6tO7DyvhB3yZQAD6o6L/T/sR/4aXGe0M6h6NTthrABiN9rZymg+sJtIPYeEP4p9uRgyNzF+CL79OmqD/In7wLjPgsp8kf7ntpmsA+J+4GsKDqoV+4UoIP6oS+sUhBTxZYKGAwyNVaQF/mW4jD+Fih371yf3Jnl7DQb2tmbshEbNsiv90PTlqOsrefto82ln/5eiX5wrY8yXpywv15YX45aX68hJ/gfRQMHF1UK/vHm2v7xy92/iwvguP7qJ6ata774Wa0SDer6+sHe1u/Oe6GeTfXioO+mNJpReu0rPFklovXa3nEayPay+Ott7tojpu9MFrch49Ws4nu2cj/dy+SfxMw91RZ1CCLFUQpdH9ALiH2evX2Y+eEehSlEYsuv2RXjeGd+mTFS/q4oWXvPyZLl98zsf4vN4YTVBEGOZ558sgH0aDNfEITF+mCnu1DBXe6ApKANIDgxJtl+APYtWHJ08SLrKScyxAA8ODCUusutCv4Vt8qnRYJfMt+qfAbfy0m89xqmn4CP4AisQa7OIZVGhmtJcWCpCVE7PNG3rLSkMXi/Poe+CnqQqep6IKP7ZIjgvHV1GNRTwPPQavqFLUOp+cjc1JAV3iBj+WNnBDwC0WSxFG2TjampR1z9MWhAezRqlv+iA5np6wknDSNJAKBvPmEAwx8Pjiqq8lBLXe6Gk4XDwDV37liRsxfc4Vw22CYsLwCP6S084q/gjIxwDepPh5KzaKUiWwCxCou3pkeJFbzifR8CvBES0vRdCLOgh6gZMVkuUSaNyrf/RpqfMQEGHMhOFWYEC9pQ7b44HJbuOgtiqnw3f217pwL+6ycC/rLNxLago67704643t2cYYtz3cXuL8tYZ9L4hQivi9xFn+BU4F870VNepOvjg1MIgIqxMSoN9UmOv0TPwLOkIqVbRi2MfXw9IBAWh19+1OB+qu1GyxtQ8zUkvmoVHllAesHfs3hpdwE0QJts87p7k+wDpqHXO4Ogx02u3uaDyeXkwaUdQFDRCgfcgv84Hm0lwdRvuEpVNIeKWvwH7ITIlEm6iJkCZ2YlVNgHpNG0S/SQcykXJv/lIcg3IHJ509foysYfSoE6tEh17MSaKz76GZDR72m/S9YDZOYzUer75JNiHqFr2l8YL9+fdq4TpXRkDI2kXJVXt3MAUOeabXuej/khPG83MOCqRfDAQsfPY6xZm5/JhG4d3AkwYJDGyqkQgJvhvbtBiA0yA8KTC1qXJIrGx/kEdqcw0TSh1Jm/6pF8HPm/AGzMBBRg7KP7pneffztmr8rp8Peq8yxU+0VYvgFR6MKDj6g4XH/ZXos6AI+9Ez4rIHxPz1rKHHxNvZoEiJH9yWPrdlTd5RpXIi6wTSvaTbrhQbw6hvvyAUUiseucd7cvhEuYMfdYf9KLdlKh88hbB75aZMEcR6DXs73THV+bC+qwDESiP84AtEEPm5l1UlYQwrZpfArNXkxVrJfa20rRlRxPFR+NtwVrBpFflkoo5RJbodj0aDI6KbYopDGuPDNbTCGImdIakIrVoyChSiA6UcnRtVvvyxGwXUiGIBWV1+Xqh5Q2DH/IJ/M1KBEPqiJHpK0Jl6/JVMzSE2gSWMbWlgAf+YMnxE15CzQOGKaXwDOmgYHRHJ5yZuAw6SHRIkHPUhUvtQMUK1qMYmgI+1R6GUMto4Not2/72e5AULwOknpI6dhiNk+4rLRKbMe/ggs45QEsbhVYcWAhsh6xuuEY7G65HaEBfTbj7XHZ2r0+rNcpRaloxtQY1tzaaBAMWZgxrkbz01yTeiuFbUd36UDy/nXCIJEOKb8fBw+o2SJ7DRwD7caVAlA4r8P5AaKhalt5HfA52WHkYbkzdaz0f+iClxd7WWLU1Va+u/bKyuH21u7R2929rfXIOlMW+ggxHPblQQCNRlCUx/vXySd4GUbDpdDiUO+k3w/EL1sgoyCIzZWn4V5M5ACbg97aimtusEcJmPG0g6O5seE1+8O79t1x697t1WwKLLeqXh9YutITw05x5TPa3BjL2I0WMR1w15PA+u9SZolIIwxyOzkJrXxoHbtggb7unxtRGontLwBabBG6YxDh06QF4yNQ0eI1d0ZKKntSFQKGh2nzZaaciAz6cNPAdIzDY8Gdlz7OjTp6N9U+LA+57N4sb4fD89blooreT7PdW4oK2P1Fk91ESqABTR2wkUhADapmIQ6GgHvXHY9lD5oK9Dyb31NFrwuyM08ctFKCFaHTdxC3ip7vuD8IhJt09GA/Cb7snCjHubi/t/IgdB1mi/DN4jxMhpBM349kpFhba6PuWKZw4n9qhHphqRVYGpyLbIvs9+nFe/X8xDsrGF+Xkd587A8funJHmSvCb53Ln6s3Oa18S389hALdvUl6PFo/pZTmbdWUz6ArUrSs/oeVGCUO0BVC8rpl2Qak4U0V036p6vPwLMX2H9YB9OznIXb2MyAlsTiCcNwgEhKsRoOqnwunmZe+sA4dxddTEbMzcua3B7lGDxWtSxndbynRWege4O8vyi+WIeR+CNKhmiNRsFwlE3xRxtlQcRjU1hpeFHcfQdaTX+BsfwjhbqQeCxS+GgUGUoGUgBYTQHg11bc2XYA7GlYMMoad+5zPdG79St6kwOGGsMhOrad3KFclDqtjbbN721U+brWwa3ibnUfb8KR2Yb7BpixygRHO4SLHd/2DkeaBK3myiWLCMPuTKOhPl4r29cscY5CExaj624atiRoot5STR7c2XR6iGHqqNxEwRapynUuV+Zl4UxaMLCmvdtT5635iajD6Mr/wAOBIe54+thuU1YVTjBKXm10koSrk9CYt2agrSZgu3ADV8Sm2sZbZlSK8hTCEc+xPGjZVyc7MDp1JiyiSzMKl6Y9S9Nr7zVF4Pz/nBs6Jqtjw3Z9JmZbo/V1j8ydvh5GnJeHQ/wIbomShfDma6CxKvMGYuT601ueI2zyeTi1dOnV1dXc6SXp+92nqp/zkfDpzaqnMPQBzXnuYuzi58MnrQm06EM+mImKpNOAPmMir4UxLBlkKoaHjTgbxxDAGFXf7fKu1BFdp6jilrjdGmOR4Xy/DJH1iwlEI/PjVcq5AXNIsyQwFUWtCxJ3L2jBuZm5OVhMvsn27qWBqj2bY7zImy1oMHUfmzRfU33rHQooiWqOCiscjdaed7MqBlTGQvDBmXJVtnH135kwos26LnqjVGjLDSUA1DOXYKqKsVkmDaVL9wMvAp0hi1xSGCnGQzgovXBXLT8lT6M77o7IU+E7VUQisVLYPycdLZL4cxXQg/+NwP+Nwh81wsJNbLf6J3TJwqESge/HZad5SiaVzniAr4q1i2N8qbnmbJ2M1Zqxnn3qrSh9SbTTHdQNvEZSYxQVo2eUrRZvdnq7jHU+6yb9XZJvt+kwsWSdZ9PB42lsdql7j+aK2za7OWU6xSESRxrbv549+djlH4HNpj5pYpj5ZI71sV7C7SFJFLjMXnorrU78Emh5iXIP1AhRI97qQPHNfSDgFeNktyUTxbkPDnWjICgvmybsTzJXpaFcpTyXqYtPenFXKi7mN5cZkMR1DSU4SBD0sMYD2/uw9bPG6srHzZXPq67rGzY8MLiN5GmK2u/rO/sbeyur6lm+2Jznd/BhdpEc+Cx3bXOZD0Zwydhv1Oz1IHUaOnZVVwozDKVis63SUyvsl2ZNU6vncs3QAK64EBO1hAXYu09QDKBns+niZ+z26SrCt9r5s4gLlSUgwBuyy5YRr/3SuG+rQNCwl83s9DD/5BI8IZ79oudvNPbGg6uY7mApOnF/tgsfW5BIsOndZehryaxhpSkl0eh+rCxFi5lKxPFEiF2WDtDsficlzGNRKadMRuIHBqvpDeDZHNfdgbRPWaBeHeS0HWvvimL0lcDGI9CxwHGXK4EKOHZ8/GZOxBC6ltxeEkKJYAw83q5jjY06Cx1ZRCFK1/plcUl9zJq5ZnApeNgDYqeVMaisxUpGIZMEiCGp8mRx79WHCHNhRbJPsQASp8X6paOYa/s/Lz/cX1zT12nnfOqDnf4CjQXBprRXEQt2KFthqlQYN047UiWUlK5mrreWIS22x6QID0yuvxKyalUTkiTFJt8NVlxbFWR1h1WkDMUYRXtRQQM5Q4TTSyWkYSiRisWUHakm41H58awEkQFc862SIab2C6Jcnb6vmG5SOsM97fS6+2N5M70CSfJqyidpzBZesNrZ7ecOwdzH6hAA7p/VLhn1iYW/S9Y4Imi0QMeCKdLB553ijs/THMtI/C1ictkR4fDXb7IzAgo6I1o4JGUJFcdTB/uc2hTSQY3sylL2IA9F5q6onZNThkL+8PL0Wc6uyaOPHRTeaanQEzz+E4vY6XWw+8SAHYpaLK8W+ZeIB1IWRcIuZTh5XzKqKZMYyTx58buxgd1qjbYwTcd3h0yhwmHGnDu/rEC3eyov3AMaOtCg3zZVYVf3L6cat+bhkLpU+2lTQV0FBqxZRxzoI7twACw0HimRWt3AbebVurugRUoFkzyklGCI/EmEosbhZSGSrt/mfGdx/cTYzBuSkfmeeICo+94+poxfp8PLuKMV57OINOj3wPsHIekc7GyyX4gGwfdutvoko0ODtsqjl0xJ0d3ogZVGOWRzZYQO1Ztqq/vffqEeECubxKfwmUktWAt+6gwagaWLh/D2D3PA4/FlXEh4xxP09vPjBGnwDMMZ+b9T6ZZb9yycplPQtsu/oRJcIkmOadyQQjREBatXOAXPDmHPd6ktL9meQeEBOp2gEQrVtVIVrYL9ScOTZXuIMhjuJfV4JHkdHAZPYG18OC+tYKk6OrC5LxwGkayk0MyntGauREVCVtHUqACWGbU2k++0+u58RiG6b47vdMMcMoGAkmAejv5xWg8uYfhzACNHjBRMqAgNWmN7aOS+MFBbapOWJSsRytLIUsPSgQHwOIIh3/MeeGuwyDiUsYONRCs205zOrRge42kAaEesujwYlkgpPy5zYL9FRZBNKmF2wYKsXlfw5p5YKKyKmofhIQQESscLe9XdtZ+XdlZ31hzipUKU3bpshNxVoidXbHuusa/Fv4PWfh3+5urextbmxULr701/GY2Sc8YCeBwRKGqkM3LDhrVsebTC/TAAT0I/B9GTg+4Zn/iWqHNP+7nw97gWjJdyCgH4Q81+qvt5NsP78/Z0Tsb65trHz5hw8ttmbm5YdsoiHI460c8OKKQpZcHwqwfpZNH6KT2YwZXNPbzvo3vfL8nuQDwusEaLbgG8Mpw+ZLTd3AMCc8uvL1UNYniTeLQ6VG8SqYE8bzT0veRXsimEarRPZZtApOhGEiNPLOBZk19UTTKw7FP4HbTmtOawyZoDktaEM2vHx2orOzIzosjbT7rX7vbGB+l1m+FanXHSnbYbIP2iim/5XyMmxvuVXdqrTlgzAflWiLU+59jUKuKOBK9K9ZjPXBz0SHtGlN1KpwoKulFTlLIQfmX9Z1ddSQdfdzY/biyt/q+nTU2R/D06ExrLrXKVL8yc7DNC7OQSadhwqWnXZrY0OJleNf/kvdmXIvlyLn3XzivxjmwLHUR71zkHt3UTGqBmDr4uzplLgadbt58evD48Kk6txr/tvi2gYr/bXFeFz+mhQu68BEtfK4L/z9a+IMu/I4W/qgLm7Twb7qwRQsPuqtmXG1WfvLOlD8l5c8OOium/BUrP35rypdYuYPzEyl/4esfsPLemik/5NYIb0d2y2MciuhC6AiJvhQlaqxydDgSHB32HVEa+w88QShy80BQpjeBvJxhxOaGFJIz+M1LLSnImpcmv9Ak/zIZg+tZMKUMrTLjJ16w7AouzbvXb+caVT4Rj+KwCYKDUpLLL9WMXM5A1s1KAdubZQWRhNS2QdKfHXu7Mox2MHK5wCL4VgHyXI8l80bRn8xXejt0TQziMMd3hqhW0m3uJgYtOHJGqEpEhpkpw4jusG1TrLhtZrzHZ040coel9M+HohjxLGmIsIJb08nWydvO8F9LWbGUC3/ZpZxewEL+2p+cbbtXCTSQUhcMTPBmX/EY74e+evwVLXRJkiV0npnXPzhLg3RtiOoah2Fa1T+sqE6zBE8rbaql7a1dRT1mPebOJueDBnlOYSMt2eWIXkZYERRVIc9F//u/yaf+sJh0hl1oYbzcArYIhFRGGFSJOhTp6CVyR3p/pfphu1CAn3CGiHehRWk7rPbbUe+6JlU7rhvtEHhHJ0EoT5kxw/ZCpPiwXCJ1RajDJ/5X4MA3cyiAuVj1hvNbg2ws2vB+Rz5IWJ7VhLg0WMtvcOgFygltVV1JwygdY5TwLX4lMitT7Xr3RdOHkUTr9qN52qj7uSKSkx4KjhGaDzrXeW9V3TGi1ASlA3JR9E2XPDGLzlAvfjFoRt228RiqE8foXGXFaKjtHp9zw9ig4Hh6cmIueDqFI4oWYBLX10rChoG14tByFtSB7UUnjBc1Ee55MqtfndHWzcw+BSfjoaqD20wm6qbjzwbey31grux1cu8L6FlsDxhx9r1w4phkqa8cgiHhq9+TqUfFzlqmZw+80g86hLrE07dJ3erPHc8bgBUo1ONccTHoT5qN/3YSpfRQWzdKv9SenF/YdD04upYdpk4hqmocYsuKTQob6TRSsnqZGaTeigQ8OJT3ctBgGKwzssZKGFfmotdTxSMLBnBzu52QHphCwe1HNX+Pg1KcRAekN48Gtb+Pju+fTwyRKl6DaRQMKOYNpK01J9qEH4P6zd6iFASuvUGvFG2OW1EQ4NX4+XM1GveK+PQxeP4VPjbdFMIIdCOH3tfZwvO0PndO0OfaSE8n/fHVuQ7wUWST0SgbDXpUd5vUNttEYwHn7laDVsEYPcha6GG3Ek89XXJeAneJhTCnX4JgqCN9hY825hd5gym9KsW+yj4CWJV2vywsWFkU8jsr1uDp6oOlvOPZAZdJWL63+7ufSk2F1ppbb3hCmHB2wZViAZBHtFG70jAC+GFt7H3fjG3Q97ZeCPRfJxthygBfMwMhDqtH7x0JjGl8KGG6pu+FAVQfQXiWtm1kmpezupZt8rur4m/omxR7vYr4i3UqkJ2N7imoLVL14NcA4Rk/cqUJqIG6xH1HnTXkJH9wL7XllBnUTkNyQgpz7Y0mIDMvZ9FEELGZOm8kGaUu8jX4EAPEgGwll+FWBuHl9B54oFWgnjc1UP4XRfeM0BsGxtHo5Cg4KBPH5SPquCx4q7G9jvk4fpUk+7euaW/0C4icck/uzYk9X2OL37NTY13XtT92mwcfK0owR84lcm19d3VnY3tvawc/EKer5wKTyAKI+xq/DPftdGxBIrGiWCcho4WSW0ujIaRiwFS+eU81bJ74Z9oOhM2BFX7PpTGVjkmDmseO4rWaxS6r9ZoJvoyphjetMG0wXzRxuKPfb+AeqoMgfXRR6E0IJMVU8qG614XaPCiSYTb4xUUxBV87VC7kCXYxkiwv297ZWttf3UtFSMLKWtRqd31nQxHN/se36ztSM9uX9kdkPQVMCw1srMS41c76h/WVXXGILJQvDuO/sfMRaKKk8QWE1CxAab8bEoH4vuHeu7u3vrm3u763pxZzVwIxmJ73h6NCHbGo6Yf9jxubW7sbe5+kJj4Tu6v+dn1lVV2wharTC3iThKrub+9tyGs1LY5XTeRVXH337er+zo6ag9TEBP3VIieYwlG7nfW3W1t7q1v7m3trW7/KQysgAsCYdLa+88vKTmWsLE/qPADTYHTq6kjhmUbDk9WzzvA0L6lkcJuuIBB8ZdAridwrG0X0zlvsb2zuxfUZsVY0SpB49eBi0v6wtbK2vsaCkwn1dld+0dUWyqt93FrbeLehay6W1wxjfoJhxluoAhd2E229e8cm4T5sslHTXcf7pxuN9/1hi+Az3mYVg03sL96KNmL7q7wyDcdmtlxjKWHjo9c4Lw7pShXyUObzGjuQplUkXpO+61rL7G2e36S9Gz1KgLIrRhNjwfTOMR6Y53zqBkzv4v8DIrjRh7QmbqohEPLq1bJ1exfhL2lxHrX8spm2H/+laeuRQFy1MpMc6LypelSKVA5dUpKR1gGXODD3TFD0IMLrgNMG6E5+ou4nZxyX2L/UYZvOAOTKRyRJjKDeipRq7+KehZRDf6SGy10U3EObGdEg5TzjK7jEFkODY/0uiYPa6PmLjM6sedfhOataYixRd/KotLb7jxyX0KE8srdKGv/DR5foVB6hfgr4R45O6FAemYn080cOTeqxfvjHygFBBRQiK+VhXu8NEpoC5GvAY+KaHW1mvoziE51K0Qqp9SK0tMP+KdzuBKXJK9/gFiEh/ej0DX4u0WbpVugmvqqyEaPMdeNk0Jmo+/Hf1eR2teYhBFmCCXdH5xcDTpxgeO7V8uHAINjDCtGBxdHnkX4k0R+6zuhbKVpLu4/mYzjmigZ2xgAHq/4wRF27wVklHAg3FNvRAYF9GAXoh+p+cBQITwqnq17akKy06oEHc0gTE+E2ji7V2W8dpdjXhhL98u6kQTMU8VnzrEmw4HhA7jmKf7ByFD1QMX2iVFUwB+NQBNDu7t5i8CcF9ZoeGwFGyE5AMyWy0F7T8YBFC7OM0+UU5MzmIPK7kFJJqjLTneO2kr9RMsWg7IPkYSbbQeqIVBbIOA2jkpoNSJ9faHnZlmBKiZIpRn0m0srznCWPABIIqLyPMszuugsepOkz8ujb60+9Lwfzh0s4beGuN33SHImVfSQ85Oztr0+vWIpzFsykofA8jVYF6h0YEOUrYpuji0xqSeC0DPZdP2Mx2wdLFVqe7APlUXDZ/B56D1E/MmkP3cN2IdvwK94y9bA34z5Zrtgnoqefby7YrAgJ3OdTmtIg8bd8IhVjcEbfbb02tk093Dl/bInW8JtZyEWyOxldqE6VPIuysaDE8Fr/omveVvQWRWhjiDURfT8EBXwzUsm37i2gPrJFReHqqZ2qRvx7TCARNGbAqgHO265SI9O6wvqArF0qBS2YrWqAZLauCGZsC6szzsgGFo9VMpPVyXPgbWNxmgNsNqsByth1IjDelFYDhLGlRSC8ia0OCG9ji8Fg81sNUMz2FsGLbXO1xqdtcsLgnK2ubu4HcxNN7XExGZPbtnIkf8urlmaKfFHK3FycbF3JMjjB2R6x3208yHS23PtNFVBlaU8nCUA4XaqU4pLxjf9SKyAbaf6gJUi7LaTXAKO1ehH8EfGX3wMwxD9nB3APkEr6d+5oNRDvszLPlkvkAcLtVKJB9EqpxIWdYDVCogzXX1N2lToOPGlUsanXIJ5IvPkq0VXlr1RCXBECqhPSCEh7wJw0gpBamlwoiJdf5VKm/MdKclT5CddIURWQ84BLhoT/0qUyIvydDsx6a3bPB+lbO+4/+BSVfAXTZGGQW00SdhEekBzsBa6UFMxV7KvcsZJfZnpZzESrT6Zwqfw6kZLwPi1BjJ9wNXLYDfmrxFCpn20aTWzq1fub4+oBNzpXbJTveKOY+EqpW3B3LiNtPdXqtXI4ecA1cnqi8tR+Zp7pxH7wA55yDt/7J0M6odKodzGyS+g/W5OyzbWka9gi5ANIH1/B8tmaj2xV+2D9SfYDUimzLmTXzeo0hNZFth0AzpB+z6LK5CHkAJIZ+OIuZ8xHyJ+hVWQj/J+0YFHuxPtYP5d96EHX739jEsXwuulfKRQZTm6bQNGS7J+WPjEjPmslWKiXWRopu1eGvZ38sl/wLG1QZeiV4a5knCMHnBOFyVDFNYityhexJcDCStb1mrRAuq7Jm2yhhaK2myFA0CDXPwS4Hqurow5DbA7ruRPgZGedMUTgar58rj5YcPKuFMAKiMXzR1JF5zLfG70bdJBzuZxsUtDq8GQaah5qwwEfviXA+QggCIzNIu++zU9GoLeD3+VguTzLG9MeFMJPT/PxO6sYNPzsbh0+Ke+RW/SbzohP7PeSiJb0BCAA5LMEm++lkwT7YfgnNDX8LXS4bu9BUsfVosT3/ib54I+eDSVY8ciITsOl6vz1HkNyoJdQQcaxkjpO+qf0HWKE7Fontb1GpB/g1Dyoa8JJndPis0q6FKUHn4gQIQhS3M0MJ1/cukniNN7yxOsKYxcPvhI0OMJ4S16eftUkET2inYEcGBoMqF11ZRHEIdbPDPRAW9rp4L7uSBgU/qwkYc+b0p1R38zRWGyU8jV1Fel+dmdb04SjHQ0H1+pik2L+RpmAzGM20OER0b0wIJlrYh+e2vuXxmBnMuo3efZoboKUSTYAJRH9Zjmf7Mh95U/0pJ9bJRhyh4fBlO0ev3Yz0MI1V4cZedVoMTtxjdwUFpQY+zlgG6UH1+N1I13/YldTvxEsW8uCmO1mQV0RHLpYbUWwwRyK5QBTJsdmjHGydbS+s7O1o/N0dI4HOj3HqfUQ7ea+/4bfXmhEidcBdkFqwbth8f84bZDIPZQyHCiH/7KlauIwprFYl1pXz3+plEJQT5YdL7N737Qk282K/ALl8SbXpv4kP0f7/mjiHyGbIKqnPhFZlD3+pD/Ij1wwGVYEz3oQ2FxReFwMCaHjeQCMgeJ8yCffwWDFMsGGZByQy34O0NKoTbTO5Y2MyhAOHq3q8TtFxjo7SdF4dfCdZT5hjJwB+qecRbOxp6rl447qyevL1AqJT0X6R/MZpGGygKlC+3acV11R/5Y/w0egeb0A2NIve3Sn8MynyIeFeaTeCI6ChkTiHenecYkroXoIAbsta7VwVMc767tHm3urOqQ/K/6wsbm+ssPeLRmqhIfzaqTu4cTCQtv89nrGhQXUpb2l25bU3ZxBbSw0cLsb9Dch5CTZabLQhPcTANWPowz0aEAEoBv6GxopWNdVFSEGgCKTx9l3vzdO+r3Gq8Z3YbW+A+lA0/qr73xEsWhxSHc6ytnNfw3JbCM6Jz8fI37h/mdJt51A2o0gKpV38d1hWw0K2ADaWsyAc9YpfKgwWxXp9WxEZnl1dG2zOp3lXn/8bW954duT5UaLx22WOQR5FcoN/oh3eecCFutbRxwOBxze9nTjL8DGdwBx/1b1E3cA0dihoaKEIXrF6uYEZYjEQLn6qBneRcK9enoBgqrlmZQGPQS73zA0tdcgIYyG8zTaWP5QIFMVxD9WvWyPSVm29POC1lKyb2FPnOVfYC6ky1Zq8/M9qHFsNqHV7OlNCHBscegdvqmt9h2GPdtGE7bZTYWZMZKWvvtdc/lSFuGGANyBDalxeMOuH5HUCouzd5aPzxXNjsbrwAi10RDMIUBVuoRZNKbk/V0kZnSn43H4pYa5SgrgMxyoURVaODrB8lD/n1bIYUefGaq2QmkG0R2dn3eGveX/bMSKKHK4mc9+MqnNn1iXgBkLSI02XIJgtMZdXwEnWXKuzhSBqcvZic50nL3WVUk+GkCEb3ugKvp3ZwhLpAJA8pW6pnk8nRBHHoC0cH0LsaoNVPPtai7DOXzUY3Lx1OnqVy6Qw6yZ5+JMSd5A9atPdi+PiwRtZEIuvGJSDLIg8mzzYrRvf1caioRIAxld0Og60cwM0KidaTnD4y4MvGx9J2hdMedN9oEl9NKDPvSfsuGl2I9p1U7xPB0us0ypU04V6I62Muy9A/kCsVH0Ps/75/h4FGokrESLJ6xMrxwmoAt97Q0lp4PRcWfg73yuQuAhrrP0YoQrrj4i0I3JtS29MTEbCb62elTg7RbmVWtI9qbFR2UkbUlsZuOhG7ckBIWp2UpFO+dzc7hp3UJKdZddzCzY5Z1xD36B57wjy+z7sBqSr2IP551J2He2ZWIp4GsbXqoh7cw4cdRZPgBNmEetbgHRKD43WhUp5bnGyAw3O+moOUBmCfI9crwNO6kWddmlWUJSfFEhwhvoLUlwn3eCO4nzUYfbcqk9KekLrLZeD1o4RW04gy7vwd0BpAs04jn+z8fhUaIo7Mcp1ezDQrZBjZiujznKqmUZ2HNDuhNq7N1HzTAN4HI1khAHEtWx+rLeFBCn1z8zc0pQKzlgCAMPpws//TZ6+DzpggkaqfKwDs3KFroKRYMQ4SyzQRawUAnxFnRr5M7AH+WjAGV9stVPjJKFDllMZoKc5UGhE0iG+jKAdjQd5Ry0aupvnaaiHn6ompNGALlfnFltmQBMBydjeHPKLzYbEtsjtQDI0MV2WskgfJS0PtvnZUOZZTB8i5YvdFXIKSnSFN6aM8SpYpazzqB//AvY3NRW6150xp3zgthrTZHmfPPtOGD+Mx6OwjYIpiNo9CZ6XRhVy6CaqHB6llxf/gL8Rh6LYdugZSWziSezkJqMzxK1iKDQkP9vyhJ0cXOf/rgoxX/U67Gr/ps3p8P+5MicC0EjjdfGV9DzMalhWVlnWhRC+a/C3PNoKWmb1QZdwTCm+Fh0MF9KL4NE9T2e4evsx3JgKTqYn09RAp3KuYCSXn4qIEXKsLYg7KCtkxN1zIZu0sv0b9nOe6H78+POWCgefGnUyvr2bPGHlz8I41J4Ble1pqbYtlYb5MMJnK3aTbGdlRKZMYWplr/kY3KP5781wZISg5AlCoZV02W8osvlhtUIugxEM1aup2izO+Dy/ip8kCrvkfMPnYznnS+7Xjumz0Z4ZoGsh9sjxU0LOqZfnAHaIYmeNYS36ipORaExWFKZr1Nop1EotCxjGb6xwbXQOiJfNC3XI11mtHbmG15HG4EQ5vg6exZFJtRzX84W8SavkcIvgRSSz+9g/hBALzx7+RL0/KZswZQtvpif57K7x+fCEi33U5svleQRBNdXCpAbnyAgcLgUTwuxQYKjIpxwInONMAfuupGtDc1lvr5Ny+9BryZxrf2GC0XGFmn3SkQaYRfNThx4e92BIgjFE5qgBF9OFQSKRBcUWJoyhEyVSs54FiayeBhbTS0ry6DiYyWxfO8woSr/G6w7N8a6Bm8y3BMnjwAW10oajaB7/BFdFSwk3kGgJC1hmzH3D5lli0nRSRKV9hQmMLar8BGjq7m8ue0GGUCk8PAN+XQMlvRUxE0JAFppo5sbbtjanpylzUtIbr4MKqUmYw9FoOfT675AyWleIKdZCKoOSdHhm9VfoBWqCasuaSWIi47hpmzjcyKLkKmlCtl58CTiYT5Upm4kLE00sfloRrNW+Agpo8fqLt9rvnzx4tmL7KkZc6uqoa7dqoU34V7sKRZrFNjJ0pJ2syH5CDe+rVplyC9Pfj/B/LelZsiF08TqMqDxadQ/7wz2Rmuj6bGSxRAmcUNJQyAQnvjayMu14kH4bjDqTPhJiA9hNCIDCbbwU7j5EWVMaAJnDUEshhb+fqJqSVqtBWFRTcfCijJysgPs8wGmUcUlTxg80zlEogrboZbhak1H8rLpKjWfgf+Rx0JrbjKyb5DZYBE3rkndZriq2rdwTAkb343B/KuNwpX+JVGbLOnuxasmSFkdBWpp7AKJ0xc56s03ySEhtIv0T1aXnOD2fuboEq/yU3VovXmDl8H1axvNuHJwBNqW8aIFIVrg/vbOKGxgzTIU6zA8pA7vSKxy6IKtlB/YY35bq15/tS6UCmwvt1h0US6TNuZzQTCnPAxo73vM2p8Baw8/Fw6Bt4ffi/Tz/KE8/Ju0OVwPgj35mIyv17/kXe1skYzfMxr6SCdFthyZ1TNdA+XmQo8+Kjw7pMcdFth8FClYl1NndeF5ic54vzvI84sm3I+WxNcnopOJ/NIkMkixPOWzBOtO2thZiIjROP/QiXypR4OesfSBqpwW9wrB91rXBzNiqvxI0avw7bIzAJMp+9LpTqadwW7k+D3Mr+Tu4YPUvS8XuodvcvddH+BAu+v8g/yEfSfqxVDYhGJ6TKia/BjqAaF29KdiOTS3xRL1hKP44287YFK8jPjKTZgf3B7+HTRhqLXTdJFOLnEHaiD895HmHgiJne4ZXP3wTrcPztDUgVmV734z4tv4qJiWoicIcrHEGLGBJTyWkXOqmTEqMCihNcIGwuONDVbM+4XssZSDAQGfcucKkMJc3UKUmfT1fTv4jwwht5xrx26eenPgz97Sw9ylTcXX6hKt7ucGJjv2a7yQamwMLyH2jvAQiDpi8aaR94flFX7YIbeCHmgrmp/+F53TLhcLh6Arts0MnzBgnhkawV3/GX8EVoUqOKEX17Nsy9Si0Ry045OZnc9g+JREPcc4J8RNErPgI4YcsoQ1135XI513pWfobftxu/Fo1ifrGBXLGIKiV/oNG/Aodzja3DoycYOP3m182FvfOSIxaqI5lTAFWrfluUw1axBbRs8GAqiZecPCv3jD/fMGL6lIvIGIMSW8AYk0MW+4KXFJCb3zK/bQocNXQZlJ7PoPcVOvTjHIsd/80j+lS9+tWvlU3i0lJgXoYYW6GKd2CF22PCBURW27eGkIFC+owLYY06BBehSplGG4oXdP4ib+UAkiGemRLce5G+4JLMpIcF8QTZqEe4ImvGi/J8id3nl/uN0pCriP3x868/F9w+QBEe9t/iTw1b0t2Ci/Z4Ia551ef5gX97by/YuVXm98jwAVwxjmk4+d4vO9zXk0nTDB7A7QBv3h5/9QEgDEUr6vKRf9eyPw7llnOMwH9za0vDsd3+NUzxWldE7vbYMU/dNhZ3Cve866KDwEzJ3O1YOAnZocsffGdaaqOpw797dnOsUEAG4Do8h79w3WHuO9+xMPBnmhz4h7gzjO892LTvfeln6ipr2/t3pvLHLSvU9BYzrsf7lPeFBwn/DG97wRgRA/Fqf3Nt180LnOe9v3vg/HX+6Vqif3C+68OL1XeOMvH+8Z4uQ+INZqqe7J1OynlbdxLa8YRXdTktvS3kJ/U7fAoB+zWlqIP6DhCoEG8JVYexksUxXawW+H0B5fW0kd9T1y67NTwLc8r+Yxs0DaNwUgdkB51HQTXraNWiaKgoOwjFRGrdhLJXXZLPMSMUvxW8KKWLXCLlO0ObBBa2/Cpm+DBY+94PKK/ShOA/LFZl+w8zv79Bt3wErQ0K2I5OHIpIxQKI7KqIV6awkryOLKaKsH6Bsg7g6g++6o5FqfclTqEWA90KyYwTSCucG9YkaMSPR14IfslHtEkGfB3JfdPXnwJNtmXDr16IHs/CgwQ4jK4HK++wTwYlAWnIfAYkLbT5nSH7sPcL9c+2wY2wt1LmwDpyRLQ7A1YpttDf/FO0/bng58JkgRUowGU+DEDWHAzmxv1LwcJaK/y0xIvQe0phE7i7tj9AwQWzIWwZKBsIFMumWThZY0w/pt5ynN8EaOCwBR/8cmFUBFhJxOT0eI2Bu939vb9qFA4c6H30uZ56vDic9+Y38kTWX/59Pq28cNG3MIPV3RanjTtjR+g8YBhGfe3d/e3trZW1+bKTgK2JDOOuMeqLVZysvbRpr2ofh0E5YYIvTsUQBcGaNQiKgd141n0VfYWuw160BpmLpzF8PThpR4TtHshxGL2zjTog5U67nJl0njNotJw3JLYUflKBi2gxYP7HTaBC/tErzYF/xh1O1UHCoNSMCY2mom1XpRgn9aEeWcFxIJdEBB9X56XAHO1yuFNh0PKuCoGgKEoZqtzdDA3LNGg0shkqL94B/+27DXipyKTRQdQad2CXRhW815hzLH2eYcZ6M0AuGVsdPPF7WBr/q9eDhqYpvq6/uwu6MBub7Vv9PBBA0KgbUBnVOD4Pk+hYw2ODyrBxwnKxoXErbxBDVW7NR0fTQ3l8jlfifRrDNemsYmNXj49scOnqfX4XO5WfqmJLN1tiyzo7JMzFVtovTBvMH+Blj+y9PslrdJJJytHFmcePXD1sra+pq5oZRU2135RddaKK31cWtt492GrrhYWjGM9wmCGCcTLceCzTC59e4dHb8r36QDpgkpWd80LSLv98MWRmOcLbB8nIncebwRacNytol1Lzvj7NOuvhqBqwFwPAijlg97RciKpDeqOjUL7dszGjcNi8Kpt3RiHFy+hLMuGA2a34j2NFV3MxiT6X1uf3ODZU60jZG9CFW32FPV99elZoPRlRKseasPW7+u76YbnfVPz4RW7zd+fl/WjJmf4lHurPxaMtDTd+P8H9N82L0mI/353c76f+yvb65+kpqN84sRZKaJW+6sg3hb2rjTu1Q0gge6svaL2nny7JhSDU9P1X27s7K3sbW5vbKz8lEeqLsIkjHubn3Yh3ZSE3NV17kNUJvd9c3drZ3dvZU9cZgkoZOnaE50YNfp7WjcVda9GOeXeztB82KTaOkJsVJMvCkO6itLpMsbrW3tv/2wjhoJlFvZRqLbykYJkq0xwJhgK1GRoNXKdp5cP35cX9tQFMHWw31X58bG1trRyi8/ozcXQgV1aJgDJ1lh5f+Gd850COQsCGhMbI0aKOFboxL1ws4QmT3a0060BSWQ2QANHJZI3ReKEHNYp1zznP6qrz1h8U0UHvUVubZLThqvmNuj5fPexV6K52OaE9cADoadA+h5EGgHn2YvX8y9ePayZR6pVfWEToeoI3py3K0ffKBEHbHT5m49cReIBPrQGXVXDIZjS0AhOdNqLD07ziKI8XFXA6g95iJg4firQ5TcphRhNj4fa03Y60fjuaIT826rhE7SqBt6ypYMmehUTAbEFI8QdApq939dGY+T8mhJumM1yeoc3piDfZUoScvc8dtsJPnzTFcYcxgniRBqXA3eubgYXK+GTdcUGVyLv4l0SvKSuURqRr8weMnRjoSC74lcCPsS/67OgI2Om1tkwUaDsXay7zMI0PCyVSMzNj4FSzOX4zF+jYSbvPZJWxqhNBYI7rra+Mz/o5ebCCOl601G+TUuePrGXmvFiWR2lyVHbN8xpq+Z88t6jPS5yKZejSssOH6lnCaltkljCU+6znmBUDQ7ByHuCuWHAxLwS7kFk82/ynUrVZqll45NvXr1OK4ecAH5lap0De2V6KtcO1F3mV4zO9XqtXI4ecA1cjfU0rXhF8yv8wQpVRWXHCFs8tXLFqHrAdcvUg4kF9Jsfnex/6NFP6RtqGDlfoRfJxeXzQplDNxNuFo4QQqTrxI7SQNKGj1oyin8eDP/sGf6aWK7oI6ncmxjy6g/QC/tzIpzR9Do3Xh0bvzKnCKaWBB1bANox7UIBpjOcmv7BTSQthnua6XX2xtJHbUBlJSywo5bnCR3GbjlnDmYu6IADea+UUATwP+CrW1R/ncb7WepfjL4MEiTqpjAnyUbfF1AqXTwshmR5oSXZqTfsYS92y+2hoP+MMfb+xIFhGMPmmkWoUsfqCORBcymn6eLgN1xq9O2p0BMhdT1Ek5myF8vNLeLQGO/3DJ9PQEvZq+XCMXosUuwsFSCQqP7Hr/PB+D1QLwfdYh2FygqoBDp9N/EOcS9TRkHvfOKhtBWpnwGYyF/vsTDdu+GqCgJicpH59u1DtzzbZNIA5fFJTi3huzsIWczEFXEAP1RKJ4rxl345Dps8a70Kqzar370pStniL9fGDLcyTu9cF/FFMyO4vj4fyTnzBWep0lkHdemjqv2eQWVPyAz1IfR6SkjuYEuQgkORr3pkuicDL/Brc38gnqxo/K59SwU3ZnhY2kUohBlSDByR9MPRGJmbx0AkUN0mLJ9DmMmCyfqmv+kPfnCz6b33PMdBRSF3RvTDcJpKq/E5PqC/D7rDUhmCRJqT/3oB8nStlB9x2DHnSuhMD9hhSc7nSv8Kz9BkfzIt77/hvd1aaqeOhGH2RbLLErgnQMNM0zCsNohQMXX2aet1b2tI30bPNr7tL1+tPVuN2b3MRNJuujjFxdmRUQPX2Qwet8Z9gb52I6JZfCzINzxdm9DM8ThMcWjDWnCiBIrZJ6GhCDL/tNrC5wFWQaAOMKyq4+DoSPw/s8o4HJmSVQYniHTW47bZPSNxw5kHkjKD3uJV9D/MDM4bIq4LUn56yvpf1h7O1ONN4Dfop/UXO2n/KQSjYt3CPFtE6Hw/QY0SggIbpaL97l/yHZePFz66+8szF6WWcIEv+sw707HJrYwFuM8GxgKZIMvTwviG7xIv2j2dVzuDnx8+OwKUOVNOpZ6OVe5qeIud9rXz2bd1/2qfd2vs3kJZ4t2KPpEdije1xXh/DXQxL6vbKo6nZkvRJ7SvyvB95UXe9uZ2jav7A5UN+Dri1eWENsQp/qVnXY7UxN8ZSfahn9f2aHfLNXM9DzpjCdrspDpdVyxPwaJZvk0SGxPx4qTjXv94elP/q/lhQZJRjrOcYKS2bKRTocdhfNsMjID15lejaBXJx9pGRpGFw+MhfmHwcLo4t6QYJTBMN5ci9ZNjWMIlqLu18Me/IERA0qkfo9EgXYeUeZTfNFAyTRD3rL+JK5oPMgIDWuVFwxrN/f6HN1N2wBpZ8JwZUXWXuwQLqqzzO3P3YqsWgi6voOSS+hba6gM/Fsou6oAppReZV7xVPVVqkyScJlQKaV7nEGxlARyn+oloZNKJVOZ7sGpX3JQApvkEk0XL6kA48yJ+TNtG+KcyBmKMGryIUiRSDQr6ynF02qbudJ2E2CJNUfhHp66b5H04atGX/6qhhf4vLb+y8bqun55/m5rf/N2DpMJIfjm1hiLgq0HrZsCh7r2sI1UFUKr38iBmQOcbodM4YTBWZjtQJqNolP5OYYXOF1274uNS30Bxw5HI3piqr6r1ebY5OrIevGd0V4yaUZydQoVWbOA/Gjn/eIcmFQrhBmu9+LdDVN8Ld+Yb8RurLFZWVTNOEGl9yWOvKzKXgPyuGsv/Nflkom78Xg+UABsaiHrzt4qa+awLzTzlyY9SvhvZfJtS1WRM7EbXXxklW3NMfFwQ07H/rnFjJ7H1S7XQqQD2HXqjuB7baNyfV0IP/WFgez5Ntu6DFFGLYFO+CYcjErMOldwe1ODPdiC8I2oUlG+jmttj8Ma0iuktDzvD4kSs3N5Sn6rGyX5XcCdC2lXe32qIPUyIMrjYWRB0icZkeqT/FZ9/oINmW6mLAOH6wlkQoeW7InHiyjDkUbowSFeXjteDFZ8oUjmpRXxAfhyaqSkEXaUhyVE+qUXoTksGFbpmSXCCgK7xrgolSGOdISPzwDDVCEB93yX9o/HZlDfU+pCg7WfF1+8rEwtZ9Oxuf6/zRYWf4xNPXwETxAdB0iGkkItomg0976Yr7BucAoxt7lN8Z23NlFF6U1ghoowaGifFXMi1nvQpgy1pANJd7/NAle+NdEsMqKxndlUpn81EkLIsH88eUj6SmH+zZtssRT9hk0KqTjvC72+A/vHH4hec4Rg1OFDoRRpz//3Ik2fq3g7UKSVcjLPOyzq6UfHQWwXf0EeiGZA+zDF99WHQwTrQxffIy+/ibRkH/NOMR3ngv6unbkpOnSa4bTwQ3Aj9qnS5pXo3GU0D1dYm1m2opcCEi7vBQNk5nZ4dBIrl6fNXtksen/haUBIIqvb+leIraoAT/buJHlr1g+xJWC7dogt61x5v5No1hnvPYTYepDB1wmxJTy8TkajKrkep8JllDwGrWoySyCViidz1aOrH0al4vFSVbNEEBX+mcdQSXz3IVRS310ElcSzHRdMq+K9SDUu6oZPKXGLT4fKssepj5XFI2OdgKPUkT5s25n5oY5b96c7cM0vd+zab+bwdb6IRgGvDZssAFGuIzCTIi/CkFIvPNG6ThQhpa4nNP64Tz8fsW88RXEYeNbiiDAiHIszufus7LK/t8oDVKLh4yZWxkk2sJNw1c2o0eNcUjnMydXvXObjzmle0iZM0/eh55Xso3TWR51iDT87QRKeLo9eMJv1NErSloyYmWECERCIN3ZTBGv5A8aQo7l4mAeoY7bq7NhcW/+/Unwwm9GFNYSIfYALMXCZNdezJjvrq1s7a4rpiJHVppBp3Owl3Ghlf29LsZgdMcTdcd5RmFkb9y/1TQ23MwEH13Y2flkXQ6VNIdsTa7O/u/KzHMkNYji/70O86WuOwA/rKzvvN3b3tnY+VUZXI+vNoqYlVkKObuhbsWWQYyeiEFluBXzcRunbJov5FT5tr2/CvyzkV7SwPKZXWMS4X/SN9xutPYdLFjkGTT9z6BKF8A4IRVQsBaGEdysfdnlsNVJBLfQ6G5BESnxANADZGvXyvmMQMp61KxUJK3CSGuGaXD4oDixwlVoxnyxHEUI+BV5TJ7CV4zJxaCvEf2oAwpwngsXYUg1wmhvFAeAsj6oTbAtxqHjhKPt6qIhVjD6+rqeedc/E6pgddvrVz2InTM762vAkigBp/NjpVr9Dd3h5wOfnjitVvOm2vOWrXaGExFX2qttOuU5ADoedBw3F4Rh/eRAOx7y/2pVKiLklwTjclGuE4/DYeciAHP5kLV0pfDR+tYuVvluk1wtPvHrJCJoecNWIGFO6cFoW+WpXTLjZlQSlhKnWCE+GpKqvV9ZJXl9LBB008RpRZTCaHjKiDJaABVJGkSjQI4Vbh9xAV6+ZY06g/uuH3og6nDH8Rmj/UCE47gkl9UNx3Aol/xvDcVA9479Ccgh4uW1YDkS4X3doDoPKk9FYnW0rg4F+JDQZ553zsoxbEYNfaMnhF3bzSRkcrWAIFZM5z+DIglSLDZ4jjAGAOsfTkxO8kXvFQA2SRQaAFmoS5H0IquLb+EyOAPlI3znG48516MifX9UvBgzQQA92DJgVuudZftUNRmxNG8CjmUjTpt8aIDd4+3TANm6Vu3eDfTn9iO9fPhORxT4ZTuM2vhMJzNf2n0An4sNMqll3/PfgT/Hgk6njW1GtF0zkn0oryhIJrkS9TcivJX92abbEr8RaU6oXcj4EokZCHENstilVZwgdyMabdA2hmxITTvL2V71cKUNOsk6w5VRdrezgTPKwayWAnq8PL5M+EcSnoV9sjnr533dp7mr96axT7O6ubeMvsDGnw89DdXj6ftaB0UpW608j1Z352tgfFhd5t3/Sz3vZWN1H4cVDPrzsj0fD83w4aWfXo+k4uxiPfsu7SuI4G00HPSWxdAfTXp51JmqHd9SBORp2VbP+5ExJVtcA/Ugxv6OhmsBvRTbCZWeT80FIkXo2Gn3eH57paBi9nRz6gAPFFIwDPsajKzP1xByR4f7X/Hh31P2cT9aHpyDEnk2P225mkJZzY3gyuhXg95PJRQnMtsLKyQjkg7sN24lwpV1dFbeeQi34aoFH5+o6/jEvQDkCScHHSujfyYsLRa/5rToHkv3YGXbgVFH3M30+zg4ovJaF9MY6W/JtgThJUwNSU1e0fochOWg7+flokq/CDemk3wX/EAW6fwuis04jR2iHYhZiolm6Amikucz76bFZ2SSXKd8QoHdSO3pbLf6ufpzF/J9Ua1Wk/ks8QCg0cNynJfwyrsYzVHvd0qC6em1d5EP3us97I/cLUm9zdAUpiYearTYaobKD+o9pru7J5/nkbNRrZ738ch8WFWjteNS7VmJp96KrWAuTcR0uIQv3joWh5Ywg4geRdTmZHtvX+1iAcbrxcz7Mx/2uWg94UeCcfdRKTvJeo1yNZgOSd/oDcEg/N3uQ4maqlQQfzEqd6JVqli4ieCrNKWJrEq/1frFqMJxHea5Dg+yJBPJ1IIgghU+uRuPP4DY1mk54T+9GYyXp9eKeyCFmMAC3H1V/Ox+CMeg/pgqTedE8L47cQ0GHDbtJFJZNqPKmi5bRtEU25pP7deD/aHxY/3ll9VPjECgc/uMKluTqHzf+7/qarr2ga5vficq760p4XNe1F3VtW5Covr2ztbd1tL/575tbv27qVs90K1q+9M1Ny00LIkD6v5ez329ajgEguktxAHMzkba+zlS+zqndRUZZkipacof+OpNJp3sGYkOmRJRsOJpkx3kOURr7ICF5ujdCzPR41wVNbOAPJqrh2+tP+o2yu5kTm7vLxfXkJXFc64Auw397gb7ZdquBe+CPqnTHXBDHBe/SMqHkd0XD4+u1fNABT4uFF9wvTm8uRY6wJ6TUmeOrlW5XbfD40+c8v9gbXyvyR3YEyoxDFbvlNnoxnEn6E4iY6pT6Ve1Z41HDBU3FQkH1qAegGSXufQhtt3VQLeKypMtXO2PF1C/1nAmyj07g2rcyHvcvOwMni8CdfjzNqbdsUZhB/X6Dy/WBqfh6tBBHwDPt6UM/TIt8WzFS4O/CHLUcAldT9Q8qDkcZOsIchU7UuPOeRfrHwraeOxoSBvixYAenidqFdujc6WB03Bm815+0OSgfP37MWvnjnNPOmd/+lhHMGS7jw3eaOAv94eRIHUywoSHczxh+qE1rDkZFvpEzNecBCEAJBwiQl2KnXYOe+uNhJ4dAMrJzsERcGFZh1Q4cWL/QLSkeEpRq62KwcPYB1V+r7SAOzO0V1gizM3lCuAZrvIp5mtiacD2GBtq63yNT5+yyT3zAvTQkD5mQT9TO3iiasaaekV3KrOlCdTSS0R0wYeJZn4zG3dxYV6isFLG5pK0WgxuMTqtETixpnptz0kqYrzII3mHaQSwP/dM0J0Y0AibTQB4rKJm++CxDI1dp7gR89QBWqxGbh4jtQUFpMXIwJKjkYP0H3Qfs0HWVGIS9cPom4NDzWQLTL9a8zI/9sGh4NwTmtTvnJQixpJkAAPYvYaoC8O1xvqVuwcaWWAf+G+vyG0A421pE/57VJ8La+e9zkeQubAUiVDuO4cURynH8GOgI41grcGStbm1urq/6aw+PyxQhV4ay8hZdnWhkI/i8t/PJxu0puz/cHncIVh3cdXq9f7dyR5OJzdrqyUSTOasfK1xld0HaUoJwf9gZ7O98UOjlYZFCe22/KW0bRk1vhH/FEaKFYi1gtBrZxkBuzeTA+2tVZMPDbQw2wHfBo4PGiYpYZK3WyMOHcAolAVM3Hiz2KJb7Ib/MB8AMnleZhfX5BIJvZzo5y7qKyahe1H2o0HZFYPgSIndGI42jlmBFpwTyDoL599Q5153A3IgfyElhxN0Q/vzV06fYFgM1SDwfocnTRlsXP0ZBIsS2GbSzrYvpcWH8f+Z1a9EZwBiTro5MM9DZHH36dLRvMKEns1S6nGjmFoxD3/uROsRb7YwVb0P0JlasLhO7uVr83GhrPcZrLnrpkquNk3VO1MmS6bvK2I4WLn6vai99wNXFuH/eGV8bTQAem97Gqrh4e61aHrBZe4CHYWYIlDor0a9HywY0pf5Qga5DhDsWWRq1oxvszbJwQNPY06it5vHDM3XJmug9TCzrwioY+gjHOqBGcLeJ2YcUrroE0aXLd0jCpGbBAwHPJEyytfRN/bmEZsyBSMqPMhuNkFFjdoOHPQLDEAw6Dm+KxYXM1SPlbPMI4qbcTIy++JtWYqh/UGdI4eQiGma/PX4c+g3pQVRrqdnBb4eY1dm6aqc84hotVTM6Aehnn9ejIv4l2x46qk5ABDue5ulk1C3nyGgDQb/i73OvyJWrnTl19iuj3vMcKKju4OYCobM7vevMS92NmyXal9ec+fERlZqr7RfJNtka5uA+4wFQ11ZXpRkmU+4zxcGPAbg8omiJyFcj/Dgo4lElg0WaqbLj4ln5cVGyFP0irELWKarPDB1GMuuNRxcXcAAFfSXEyda3SzeRWqeOrw21uqPz89EwXMeaDcsSXMBtT2cVU4oILLvsd2qfh2RMwaS06UwhljC0flxLJJgqQG3hhV7uql0qVAtpG2LpuURa0+aUK6bcAeqdmJiE/vU5dZXWwSbntEgzHRdmgc80qmz5x/5wOsntl3P8BbSWqvjfspf5cxsudA7eeIzNTVxVP5onz04n4+u9vHC3SiVeNc8Lq20mio/+EGL/Ey02Mi49znwrtjVEDfjrGB7bLgnFedRsiYvrgjqdZIoBv0dn20o2WJLEAVlRXxicAziFh+U3nGCq1Pvpk3SZBcqb4U6S4jqw0rBN7VIpegOfbNB5YY1Ng4hKN1zk6uVgINJO8HMoNH8CNgbmpax2IBd2CTaWQ2ODahpsAGnCwVYhd8Dp+d//ndE2Uvo5rhmfX5I/f3S6PoSZpQohho04ok6mhrMnftmYuU8z9Wo2dJAPIUqLUYqu5Zf9bg6a0M0RPGsd6o2/VNq+0+t5PZRawoSoTZSMiYmmfKcRCJF7SzK4RhrFDN8SHmjMxRbm51szCF9My3Wn279i+eBbAaee2SvqsAs0NDc315AZTMJOlLZX4RHKVitp6Z4s0GuHt3AG9SE9t+g9I03LT55JCIwMqPy+WJOjlWEaiTxWmw9MTVt1M3VAZU0QjrIDL21Q04g6FA9bEp+SjgthPktCeIO0ybjSnJ1I2PRHoGk4yi6Mt0aGJ5H99OgnEUE3D0NHzzUjl78t3tMmfW82qIU/uKZHYJvO/6o/GGTHefCByIqRKi4jqEZEFrR/a7rTjtg5UgxR5Ug5DHPyxCDwuQjid1N/oqxUm5gSoitx3wn2hiAZ6lslGKAqVAGIWZsGc8aAJpv4qo2QNW7QtfNI6JRjbkI6l1pisJpUwA0m3I2lbAXgL761v1dtUKGHWMkRJslINl+mqgTOdtvj0Xm/oMcF/m4515Z5skeqqDPfXWktFPMtLrf3FPur6e/MOp1sW2HG1SfirzBEAQjsM/AXliTn9HW9tcRVCDa3bfxdxESJzH4fQrYlKdg/wEnhZkq5b1rAthNoRuocS11EnVOjoxvMtGOpWxU62mot8SdDY58fJ0UrNbY9OUDjxfDj+OPZQ92RVbARbXNRLXdQPiFG+6Z6vf60kcWAi99YxX4UUJ2y4giZBBpCpfBCM+o44fHLfX2JJkWw4t7poB6MRp81aRfT/kRnfwN+nBs52ZzAbjTs4KXCddKBrMT1zOb0UIV/L7T+AYtxoj10olj4hq1PTSM6HfVkclEo+fAfjshLDSuCgoCpyYxty7nZzJmUNmvr71b2P+wdwUx3j8C7mXItMohxePqLOREM1ljomqH6T1lD/wB7Itiy4Ie2LSaUeMjei8y+WgkFKDVvQpfuS8j1dOJhw8sWoA+YCIhBpcSCZ89v3O7NKUsYpvsvtPO+uoJfzsVPEUI9wvERQf19d2vTPKRt+jeC7kkodNmiDSEhrm3MjyL8bQ5nLOcV2Z0Q5zaX2y+R5jdlvSry7U+utUMjGBUvR/2eTRUg1olVXGR4kfLZL55RPs/tb65ubb7b+Hl/Z10VNcyrDXf3BpHt2ghDJ/3T6ZjqoupqJWR7YQUiLsajyag7GpCZ+0J4WQ+b8+nC3EIjMX3Grug+reod5SSiRNzH6i73P5SjhoAQcjpgWHo6mmlq71LU8KD/+PHhktiouBjopJeh8ZwuajZexYuD+gGhDeodzCcA23EAVdjnoXpZO5NRv2laLhwKHWh7tW4qUqLOYzHOO5/jljdRCT1FjMD6ux59Ww/vJur/JrmiN/cpkAaGWEy1n/qJOsWuzev73iwcEo8rpefTEgl+a+Oeh+9+gDcQR6vr/DyaZcNjKEoWnnPPapa+mX1Xx3tayG09I/oTviE+a+2pFSfMcpwo+XA2/HOaCUbtBzitjZMBjOIpZPk9H/Wmg/wpPhoaDO/s3Lzt2elnlDxBS0+xGgcppt/Fu5xAwQCSLyaosfr0uEkq1oxB077D2x8PcFCL/SJ/q6TNbeAwTWJqCPWdYOkfpsbuOncQudQIMg9ZH7t1xHIiaUV6b5k8hCfBxrUnTLX1UNpTmKU+hh94guhpMp9b2x+wLSnFVvrmNQMp0+eQSpraHxbTCzi41CEBU3fyi9E0MhqDy4ghxBYPUytdODErCG696SelLEJZ/3SoH9wE72k0Ge96QF/iYxPIfCvxhs3/fWd/QOcNQR0hgvdDCQVVO/95jLvP2GTHffC4J3vSy4/7Gy1UWyFx69vbImMo3CIpuMylRRDmRFgiBFS5AVYgKIFlPBo2Fk+Bqaalzk+oUfnDwqjfMvvozTd39yhLULlzIuMuZGh0ghNZ6itSzGD0cXt+mAVVZCVaGTM/b+QVZfX92cq82bBTkOde5JGLqFK7Je9J9pLN6ICcUqQSU69gYX4Wx7a72zPVMEGw5KacFWq+TeXUKD4Rrvd6+FbUUXtnBc6lttT5heoHtpS8QuLLq9JFeiG4p9zSkFrLRdE7Q8QaWv5kJ6a/Ei+CO4++h3YIM/wix8UChq4uQL2aZl82t0B+1G6wsXY1Gvc0GToO4FQiR40WDZ1mZYVl3PBg/lB79cGYmvpKvzGcNHGFhUNA/wL2A2TSDXr+/jp7kT9rUbO+//i9zyByR8GI4Dggtj8MlIS61W6MMMnCoB6hIhabRNeK0KLqaX/SNFjPtaPCsaPubpVF5zuS+o7282B+IOD2UYbUpI9HqO/Q3+YLR51a3QZwx2DZfcS/LDevystftle/ascv2tO2QexaIrDL57dxgyphuzfflDkS+mq1WOBMbkp1KJmx30nsSht3OYncZ0tCV4QO7PJxG2d4ziuQuv7o706qZcOcLY1q1oNo/6TTV1zHXGcNiVQp4W5uIWbIEjWmcHvkmyHclMgoKQHlXqWTUtmV3qWiOE42MrEpVmtk/3q0LDDGyFGn5PTn0mf5Tl1s/eFEnFTASC+X0yGxSl50pW8OtGmK5dr4ZsZ32+255UiJOcahgCD+j479A0EX+sfgJOdFOK5biR+K2C0Zc/Olb6qV9Ld3eU270kaubej8xd5tJP6wqZJytLKfE35WceO6LlDivUP2gZKGUOLgdEdlaMrnqIdRKatCH863SXpPYP+1IZjJQgj+OBESmcZRdc1VWuQ9j/quvohKOtOiWefSjXVsBmK48urg+S36Jm/SNZGDzCRti3F+ojB9xiwCtm5Jnom0YLTQKn9/MGWYOboYj8DMaNXYZlxtdSq1IcRZUkteqqujsTl0CCI7J9cBlfraDj2RHAuouzbeLwxv2iNaYacyXQfGLICq46n1lSCYTkfC3dVZf5Jvd061jkZXNyGfICY3+I3AIIu5UAuT7HU+GIyuKhujaiQvQQAqWjhmIR4SEg/SYGjkOl2m33l50R33j3OrwLBOJR2o4t4/OhjSvZ9sz9nXM0y3jTEnbuzXiYcxs+CEHAv4ktXOxE96myUbtZKXV6oKjIZdP5CTd3g33fc8Qt1ODc9gIqPg7F29mJ9P6HbsIjjhLbZK1HwoXJVjojcF9U1m5pnlw6m6tmnN/6tMyDZRm+NUPjC7Nf+Rbezi65ESYsUeuDSK5c3dYseW207rRZZNxJal44wDy4YIv5ap9Id9iBADCVn48wKfmuomlU8Jm1Dr4oCFlXoLqa87KCmWC9H2n/8EpqjTY58MRqOxzZTdGfZG56ry99nCyx9++GFx4QVSMC681Azzn//ZYKHbzteHsFPeqpE0w5AgfuCx7Z9IVb1xLFKpyovH/WHzO+3nNZw8UVL8xajom30AfTwBf4+lDCKpLTe+k6KrfddYysDTxFRRkBv/Nf6voQNoRNPOxcUAQj8rsE9H6qI1eVLozCqkpkJDcZKPn+hpqZm/ytTQ1CygEvz/d0iD62aYnhLBA053UpylGzWePMF64u54cFJSGQaFq190xhOtMoBO2n6MbQ2nDSsQaGcO8Oq+8PrmN3xDiVr6bfXPkGVVMU6IGfgb6t59uI4+DdcxhCB5usZB/9BVii2Wdn/u94eTH1d0ehdV1c/wdp3DblV3qKbrXU8DCd9VQyvJQPdWyfzg6JSPC3KDICKpVaSardz4eX1PsffG0xN1vp5pz7GfOsuQjUaVAidqZwtIWVhXIBUEANq0jYRBfdQfHEYWYz0kFwywzJdZg1I/rKzXorrhAOagoSd2yBIc9cfnkGDExn00/mFtXwyR7SdwTVSHkTqaTlUfBcbttMiPinxwcqT7obZHvTM7hXWucqp6Y3HJe2q4x2rBIr2eQRg43OmnF+iGnZA1kY7lXONS/dej01mnzcibL9Rir57l3c/ZsSeWbKJWBG/cGvQSnPaMq72jlvnbU4udkXs9CQfXWKcT6KG4AYE8fouc3BPZjxLkoY1kV0PvnvMb901Hj2ZctbliAPft+Xb2g34Z0fhlY2fv/f5bpBsuowek3nfRgpbDGEpgIAMflTVrrNTxtQH/FI7awjtS0B2vn3lGiygu43KsS2cYdgmveDC39Ky0L3TYKNKYU/HeAhkXFBGcH6KTozgqzvr5oOcjKUXr+kkt6u77D2jH9mVGj7pPnTVqjDArVFMxdozgY00HBSOCjDEJ8qoIUZKfDdcHHKenRXUCbP9tDQfX2UhJjzoLjNqNT3YNtrTBWt0UjTXVCO6ZYgJ5+vl20GI/YsuvyAbNj15nYqRGGkQ25r3RKDvvDK/t/aVIDhAPq3LzOJKsuV3uwPNWO0P9ClhzZg0djCnuDFJTAXRQHnhX/gejBRgHDTObQ00hpidguPBOPv6u0aD5ccVUCkj9jGfQ0w/Jj6fFtXkzTmHjJ+M39MhaUPTb2M2HvQAN5Gsiadq6q+DL6BM8wMVU3UlGE7ytoDB7A9fUEJsFarAy1Ds4Pyz+qC4juulTX12tuzgwY/TTldWs/v2taqKtfrqZLmnQw7mEDre3djkhmhWa02mS2uH6qK89DTeQRhBgvK5YCdgQqzLgqnUvpPuOEimxfBIhj6zuv/YepX+wM1+CZim9sfYNfvHYHK77Q93Wf6i1wcIgHEnYcSzMz99yFM6TTEQa9EcPAR5A0cjZ6p4fXzIdQl0lYq1whSvD3js1lIIuDYIrttLn3XIE5EDf3cljXc3TphcrOh3E7zdRWMLP+TUcPBgwP5ShCuDY6aPZURx6OFA1D9GwAJguS3sUoyGujoYlN3WNHBNOt39y3QydBgd7z/+e/QhMrnOZu3AmfkThUL1HBobG7y4WqMjs+laFhFqd8NzzLk258HiqgBm6mSnpR6vhI6VnwMrf/lCsuK0GOPgrYaR6Y3uMPYdT/J0W/fwhxZLZVh0D6KGYkRq1/hxed/3Efi8/UTzsmXCfidTPu4M8v2j+kD+T3SNMflFBTM1udeeaZQaLwvDxTnfRZayfRWRSWMyfsyir+OcJKNf4rYIu1q8wP+Bt1iagaOI4B/4WxPOwgr0RQs2Md7Jb3atq3K2q7lemX4OH+BF09Db3RrB96puNhlFhZjV09gIFjkP82z2TNpDgaiQt6euMB1gJ6/WiZHPp5b4q+v8EPZosFbpb1uPsxcIiiLZBENZ6XxCNtCNfVPrO3uXF+JS3E+nAm/gsHzabus5O/g8xjI77mNZM8KV2SiOnUoz0iB4kEtiWIhDqwyIVMDxQVtvmtF6cK5z7pnR9imq7VVULvii+G0fLDncT2uhp9szfTdbHHZ0i62KsdvBoWvjVN9J501LF9xzGEzAcPs0WfjSQyDXGtiH3mIpXzjON+Z3FkD4Ca48XEPU0++Hl7AOu9Uw+bADqABW2QDtje7s1p+2TTTDVMvKtZYgN0jWAZ0bY247JnyPujzpAFvJndWQa0ZKgf3xbLIdzMD7UaPAiP6D7kWcqLnd6fMl3Fbe+3xFLTewiWJK+s8LlM2WYleBJZuyzTrFjEwoKSXJCrkGbSJ3cz2ayCpCn/IYacMny+AreDAoiTpT1sFz9nMzx5SDQFEG3mnzKh7iyP7WhfIfuO31vgObJAcCrbZ32T84hZbIF4uxpKAx5lL+Wxxc3iuFWKsustaibyA0FzYUmJFhEpn6S4kcYd1lGIAYqPPCqBOOrMhAkdIMEh7zJxtnOcMMifvGN33UXEQAh063QN/dAZkNgECIP4pQXMwmWjuB5r5BmTphK7NNsvnNC9k9vmpedwZQ2JzlO9WfcejcHz60mMv56lWDV45tRjec3JI2fYXM+nsPfR/1h86poZ53x+AjlSmqrU2dU5O5tRWqHWf56lR8XM4HDs6ehNNDO7E7HRy4AkRiADQff0Fs5SqKNm9VN/Il5ng8oJFnsQjUUL4rrs9AklHh7VWizAS/kWq445aeWxXmQiF8d2n14CGcXDsEjjq+zX/rjyVQ/XXjyXK3UnOwh7pV06JIpIiFxz0QR/Ggz4cIZ4jTBuOe0uqb4tT85a+pIOY1Wa4Y4QM/qxQEqeyprsldpN1MdbVitp65Lx6m/m7+UGKojV9FKEPqrLGBQHfpM1EWZicJmocNrl46kxm09upto9UEOLocmwBeKXhY+2Q0KpC2FE/RUMH84F0her3IINC1XupK3Rbx3TdrxP5uo2eg4awGtBVsxigrhG2Dgz9sKsAvO+18UE1FYHOSnne51ZM2OiTy1SDrb+1JJmDXKFDvTyagBOEMEKISJq8VNYuySShKWM0rdtPWSWNXsEbIHl2rHmKOT13Ea81tN39NUkSaqovHnTZeqBgOoRzMlXHlWJ/TebTg+QoPM7f2I02Gka3P5Ojw+DKgt9n2TjijMwGOZS033I+xs2JnJ6xPnY3oHB6Yt1AiMOHrut21SG/zHVF0G8kJJ60dMXL/Ftb4SNL7h3yx9U5E33pxwl51x9imEA1OFXSVSF1n+ZaL6KXR2XfsJRqeDxMGD3dG4eQbZARnWtZ9BCEvspqQEtFxuQF5oSsGPzf2qs4A8Ju0dozM454XD0bCb88LRRecf01ysqlHB4r8ogfL4emjd7+OhoEGSqWJ6O+98zneYd/w4H2jv+K7x5zYXH+OTPoLXglp1CX/vmsCZ8Ke+2Bgc+szCx2pDONjdQV+Bsr9ovUKtXmoIwRu+Ts/Or653LcX+d3MB9EIo1KcXg05/uJR1z0BPNln+8kRtvvGTXn6iSMg9NwjPcxwy3Qt8H9zVLG9UrFdNuJOY6u7xN4Pi9rChjqgSg8noSwDIMmU4ohOgSjUZzTF7/Zla3um47yUwiWmCJmN6vDY6V5jWXN0sLDbGgIbtrVmyMK/GlyfXkCW48YocJ5Y8UIkawCs/FPxBT+AVmkzMmONAP9IUzjrFihrJdmfcOY9jl3cdSkuegiwuPP/h+Y/PXj7/gT4GUT8+jK7y8WqnyLFFUbtZd8E09fgxW4z6ABQfAq+JqtVRd/yxOW5foSAzQE+kKNV8u1MUcc+LtmezXB6SWyZafWXBj/HMh7pzmuqz/Asoq6XP1x/XXjTtLFv/j71372sjSRJF/+9PUda5t4/UFrIkHsZg3EcGYTPN60jC3R6W0U9IBagNklYlgdlp7me/GZGvyFdVCWN3u3dnd8aoMjIyM/IRkZHxSCVFo/7IFtrvG7WiGE56ExiDgI0NVgIbkEE7vkLkJzax8s++LoG1jt8adRMxtyNP4i8ZgepceAxyE56qjXd2WoDjEHyBCmf5VlEGOj5cRNa3jhwv/KiPsKN+Btx/jicIWMAPGcCSnlhD/vB5CErOY294RnG6rdzpgLkwfIO8dIFS7AM93qTz1Yblm0XPtfO1FcHLNqLz2bhX5B0q6ePNHo3YhYxAaLwjiwWbtCyqZA+NN/j/nIxRz49nt06H/nPBeOlCKMtynlfRdZVZNwD7wzpS4gMHdJ9zHJexKxHP0XDYc6NLBTm4w1YtaYFJBmjjtKmaxmdB+SPoTWuhuZlfz4bgH/WC+OOlYzTnyhxt0HHQcpZzn3yeXvAzbxaz6f1uDE/IHKF1jVks3IctIYoXO9lV/gjH/7co93OHSXfW23UwzIYvyiDih1fRjYiiNEJr+B4FGOV6o+553MVXBU+IEbP43/5ckouPte481D/NgOtmcH5j1HWNoG6OO29vfKg2NFKrbcOB2jHVcPFrnL7YD2aCJ08yHyfWsv3mJKMrbdPoTVZs5vyHT8hyaskCTma9mwk7ZGv12JtWUrOjrCh4JuPiUWwwci6JxJ8rj5AT0IuoBNRBQFLbWIEa3Ki0Pj8tAifsFZywDt7sMW69TX81QVmvSWLIgcsTh9qkqhuMGiG8EakxM4wGcUNl5QtXHkg8Tlmk9bQcykResAwbgmu+EITMCOlrOvTbXpK96WVCNCHmGpdv1RAx4/54DA/9Zh4zWfvn3jm34Umr68QA9YUaowTY9US5K2Iap2AItFwxQT2bEmgFuxI0x1YSe4j8hP4SOFhwk8gZpc/WG6Uxn8ILBl1h4LIhxYFuxlOX0+KYaQxCh+7m4gkkXggQbDnw7GQT7ViaDQo7nyiZgS45EVlcMfNG7mQFGUFHfZmnHnm0BFY5DVOC1rRV/3GengAg4xzwRzbViu/9XjI7ZkNqw2CKnh3PpwCP3eYt626iB1KO1FpRUVGL/Dz+XhaQijT9pevGDBjrTenwGPnyL0Y2cWbo/de7T1RI0XGeoKJ59+Azc6Cp4YOfbJza1wRdyuRozcP48eN98PKdFGMkKlIVXUHq5LBx0nl/1Nr7J38m8ohaRh4qJnA9C11V8ssjaR31j9Ab6ejBsEkKRwl1Aq5+MetFN6b0CKXcYdYNNapXpsFrbctMJ4Mx2mLJ4Yhx/Sz/2Mjc1FYMUeMFxtOb/E9JOaS/PLIfGZ9z8XpElKq8e9ns2jXoMdJbSxHjcvBkoudw4mM5CbLclOvzUe+WnS+QHK3gtcr+Iv1JmMDZSpRHSCf6av4k5EjXAix2D07b+/rlAnc4Jxb+xGSB8cBOm/mQZ8S+1qRnq0H2ko8pPFLntAhBFicH96DmnI+yulJ6tNvAYvCxjEBSbrQbQJMAKwXal9oFLGYIoPIKd7aPu62jk8Odbqe1d4zRe1lPlqsh2IPGb91f9w53jn7tthlfjiB++0/R2urq8hqt8nHvyKgmogIzcOUlqQFr3YO9w5NO04Jc80BWBWjbgV2lsCftt92DZqfRPelsA5Dsqx9oZ393/6T9XgLVvECN7V+6O/X33WP2R7MjYete2F/b3cbhIaPqtmp5HRxEq0FoJuc0Dzt7243O3tGhQr4egsdTR4KtBft7crx/1NhJh2PYPjT29xjUe3zSrIWgWr9a41VG2i7fZUxvmzE9Er2ec2u2thvANzH0+ooxPDOBgZ0xaIrJgD/E08RIjUULlXuAYYQiCg/Fc/eSMbyR92sSJ9BKF7eyR6Yg5aOxpxwM5nnQhkb/09v7GfqDqFy3Hhgx4CBICwy4svAAkB/RXJU7ZRd3Az8RoCBlfqGYWOPb84zF1D7fQyU939I91NhLbAW14D2oMx1OxLAyDy6r/kHv86/D0WB81+aeuJmHmT0Cp4c1KtKjAKgPcVgslNGlOZnllvssyf7XNr+cCdzIycYkzU7onduXD2zhx4PghD2pvlAvOqI0zJnEI/fzBoYR5Cl2w3SbJ+xIAbNZmWsVkvDeJSoF711iJOAN2hjoTLygaeX/a9947uQygm4WRQJhqcAsBS40WdpcfZlTRH20fp5IulqJwE4AWAhqDxRSVONmPyrjkVzDbA7iW48uLePKiLoie6E+pexY2IPgOrAkdVJcVMCCC4Dy7863SHMr2PRCYCJk0YqEyshUMZMfk5DQ9ub0Pp65W3h185EKWcpzS54gecFuVW3LFJWlxMd9f0anJEF+/LRBjjsTdoM6MO29OOLwXicSi4UzYlVroWWRa39QVZWVGiVw6fMqyay95uIJ6LMCsbYfaNAzZwcih/7r7j8977yjjE3Fw1t28iywAcuYEm2OMRlOvc9p9rAe/Z7yZW/YZLB6QDjuQb7n7NAGrxkvHn6Rzh6FkUGw+jgtqs019M7sS5nQGWkh/JgDWVMa19fCMn9b5/n5ojfc0M6Qkv9ffmfwjj5mZyy6xoH5SJYNjmfPXkRNkLl34P79ojIDZQiBKRluHf7BfpUnDps2nqHz0B63My8F5FixdqUv/FEKO83jzvvuP5uto267ub/LrgvvDps7+O5Q+CLGQV8wsFcVM5rEl3APP7LUA+wvtvWzGNwXbHpz3LnSyVmQ/gsITS4XzNylRXP++Lc7nt71pgPW26+0K9jFkSZp5UEMZOQbyC+b/4xYRPLwPN/bcRpKVhrRyXwWg+MCBLiblqNJD+w1VSQbavFqugsAuDbZVxHg8Ccg2aR1vpbpPrpAQB/X3UQGp0VhMhfVV1dL0RsInFSO1Me11fp6lX9eJ59ray9rtTVZUlsTNMBf9ZUz0m4CPZv2II49jPB51gh5P73DsB33XNN80ZZZuWSGfiGL2uMQ6NWwsAuJsjQ0VVDPtnyp/8z7EsSIOAc9mVJckFw4VrbewI7LZz3iU5JV4LWKdGEzg6ly+8PrGddtOevNb1BpaUlLPJuykZSL5zUBe0bZFUgqDcvFgANPMiebsaq8Fa1Tqhhe7zXu9a7Qhx3esY3nWxE3UqtcTMc321e96Tb4iOreDc/Sk5xlzITlyZluzzPTtjzpM3OnYvioCTaoxx91bSr/GL0MkLMG8hD5Xbd+v3KOfdHCG+8ZH9I/2qz3ZBR/niAbjC6mkC0HZlIq5/HAF82AJhEfw2Sf7Lcwm1h0qgRFujEGdnQWhgEnYlrRV4JT0Ykz86b+DEC/YOw77MpARi0uU08+eGuiX1k95mRZWtq0AkFM+7d7BrVOBWg4DIRPAFjN+zJcQJItwSh50zBo82IdfhlWAeF68vEmEDpgsVfsL+qtCOEJy+n/qMjnXVRJci/8XhJNYiOVSUp8ibyLCl+vrqbjEd6wjA4xKUWEmru+l3Yhdsv2MjJUZgaF2SUSR/5nUxm8tGIeflxDGz1VlZ6QzKB7ZZfq/kw0yjulvRXBkNjdyNnEDhxe4+sBk9Fk6DsdXdDybY3vOJQl2PHaOqKrPAqXVCYnnlsEamMiKl6BxuAzivUBmszPe9hErSyxlsqR0R5BYXWed5RBbobOqlQmFPnPaEkkeMq1TyqK2rdu7QVe9cdkXXR5pyzwdnC3fsnCtpf2gou7nXKEcLEWrsiScbuNu+va1bx7XnycmZiN38ZtiKQuEwqBBHs8hjC4RrlcaR7CL3pBzXVRhaWGZOnNdE4L2TeYlNf6s93HTaexh5TVkppT1aWXqyOg/zH0BVaFPN3KxWTJTs/MUumvIVJWdraPpUgktAAig4Svtu5aH4Lm6rgVDmmt5KNOFyQCRFfa9IL6cq5mEc/3zf3i2zkuXL4JxyDfKF06DKHmGRiCwh2B3fXq0evXsDMU49r0r1HrbokoHhlPOXtM+ZevWWiGcTNb5RHPEpexKmfs2nLJjeWXuNaYi615Z7W/ZQe9CklwFWMkfY8U5oYv57AZbvP24BTbrkIIvaTkiWl+N54OgC4cfyWZXA9n7ApS8AQ0R1BcOWwgR794Qm35SWPE6zVbB+adNS/YdTBac1aciJ0vkbxRgL4o5GOe0hNB3WX+ZR3xbVyJ8bX/7NQNevrz4KOrIVAFZ1ridbtJOLMxk9X8Mxk62J1lTq77EzCVS8Adnih+C96u/duzQiBw9xzJBIqUvdFMdL52VtrM6rOsi6/q0c8eX46NBccFFrfiPQdzuotNg0EZJFG1/F0rUcMoRMYtfzcXOyq/6LK7usA1THobee+xg/EoLguabpkpvozE7Kl3LpSe+GVYGXV770w5OH0mH3/IOlgXiy//2Fu6cuIiZiO+9Gh5wwtm+XJ5Re5wJXJZWrVNYm5iNt18M2n9UI1ohpK7IUpIEtCkV7/HSL6y4dDc1syxQ1K/EwSNl9258F5APFoo22hXj6V+thnYTmad11HtMc0jDXuf2RJHPS5RNi+fgey1AicE+bqCX2t1z2ZQaN74GErQ1lRWy0skaZ+s+7R6ZvZxDfu4bvX8Je/5mvV5HT/XV6wBGXr8V1yP/4obprvae2fVnA7PgncSryF2mszkUXK8KkfDkkd0diINp4u95BXOFc1tiqhjBaxkMfTZBwimnvDXMR+wspfGf4GbPxevdWyH6iniX+p0evinZf/UBIzg05+F0lFIE6BlV/wMXVz8p4HrnOCRaG/VNvdv5DqTBHwlG1Hd07/rHsZBqFrrV1+iVvEO5SuunZl2jbqkDiWin8HzJy1gHCYS9IhtsrtprhU+OTwhT9H283eOwGXlPEHufAabZffscfadL9I19Df83EdJDafKELMpsipWbOus7csxLENtTlh8MfdN6IqGwXdzH8yqjgJH3t99kGs2JOIMw7/0wdfWwhXWfRXqK74Kee//ztmIvH91I7C67cPhmVdDl81gF5MmPOfHo2WKoF/Igk/ncE8InQEOP4e8YCvryjLB7cRryPcdFA7sDr/Mkl0Mj51An36Cl39IjuxvBaxLNr/ey1Gr0yHhaZzW2cXlJilHv7ZNIHMEz8EOTw8VQcnI0bQBr0C/vH2R5IkR/6fKm8OR5AKGtOmRM9c9YmZRVv/R63lXCjyXOD4hKvsR8QPJuO6HcaDbSinrHEjtuuZ/oSFwOxiYhK5gh37RsP6q9FdkoaMnZZ5AT8Ex8QVY0wXMZFKeUmyfxJVqbTMPMJo5F4Ba4MrX76F5IHeOLoQRuDJm1QfsV7e7ejbva5qnkZVc6zmvLLfll+VyN5+Se3GBOcnsrYh0jCksBjfDESZxcKLH6DRrOVeJd+J7SYRthFdAcMjBJoDaoKPjaYTgsX0k1jXmN87/YJdr0eV54XnIIUGtbfyQPaGPOejz+h994W5NPesdjC01H/JNkBgL3w2ZbKeVr54BZHPmzLnzz8JLaxY8VndBzm4bLvg5Tz5zNA3f0x7d2bNvfl31q2rW/PoA1dwjFAF0pTmO5tqSA/gxHCZqTG+CDuwpVIyyKwGxxLfNPLXNbm5JKmx632AH8fWsp+ZEDmUp7EQfnF+CTxBdkn8p6G2fggzmQCN7jalhPcemV7vl1gZZmM0VGe1rHnVjAZzZJFlophwapE2V0vnLHMLb58ruRBpxpBg76FpF2cHy4y1AhDWXuGARmspLlaJ8iAr6nkJHX62sMxRhiOcMYplByLbdS9pj35ZSL2uH8V00Ze1R11lf98wbFxNg2VTzPNCERByIZn1O4JFR2OoU6dBKFsZSIcfsZAhVf8Yx8z/75tHviQvJXrlc5PObvuuclcILbsMKLOx1i9EeHCqormuOFNxqJyNGgwH4VsUqvziTpw0/lQ2SWfyBeMwomLbpSWJHEAlFc8hwRaFNXfUSa/okLnVz1cIWu7/KH6/ZJUj+oDdYzLYwj+dxliyFCRcA0JNBHFQWm+HsYyobdI5UYIP5FIVj6irGvRMylIXPI1KbJIKNIRMQWMltuQDCHkatTh9xMRa4xGE8JaI1EBuHEDkwCc8NBlYT4OWovqp2Ffd2yR1KL6IuiApQNueEKIuMgXIb5jyC58P3EhMRTbpms4kgnngBy0VKVDZBdrf/NDIE2YHl/mP6HyP4b2EzvzfRMOEGC/6nszdcSudtCKOXpTrXCPxYMdoRtxk3Sp35zFf1RRDJI2tQ25StqLjDGFllBFaz0f8LEdjcgOSPNnuRcY48ZHY8hQ2DFJ4eB2ZxkxaLGdqKTEsgw7SYXEpTM+kslMbFyO32uEQoPKqfWHn8D52QBlYCo882T32yxFNUyMQvZX+aFqjgrNPIFAvcx2HRsjKzwjw/ficEJVuAOwMfk1HbhieyzZbOIaS/BjPVLNJlZ914lbS0hqOmNZo75e+bvEJf+DU2ZsWhPzq6358vr8Gfx9RPizceVxiy/SyT7FTzLb/pdS4bKHbGGSEfvFGtNYjnJXL1S4Jl8GNWapdYZ34GHzB52m4dnuzvY9Sugu2IN1CVsvoOGAf0mx9hf2Qi9I0UcUEBfiKPZDaw3cDjbAi5irBMgqsNk2gwvhuhd7wk23NFi+dyEF7P3EevWR2bA3TBOmPHN1+sguE6G1FZfDrhKp8/94SRouEs2Yqs1V96HKj8MS99kTi+TIgWUih+x0bNvkjEutw3tbpUGDsHT94057DgvS3z2vhgBiAgotqmlXk1gIbI+9mqXUEy08/YY9D5px5sT7zjC996S2dYFLseQxn2xSHvoIfAsPwOi5Aqbjiaxz7f/4kMMsWzyKpHOyUv3EtX0U32vxyx/ObsPIpMHyIG5wzqcnJYoj+dgzjtKJHjcTUBGUV52b/e+OyLXCNpIcZDbvSPmyp9c3J8S+m9CL9vw8tWG0OfKVWCx0lJ3AZoKdcc+LRmxi2uzM286CkNNd9E9VqVGA9Ztztww4UyqW6xplh6RLlTz3sFuF0BIV1LWs2oYCsnPfB+/fdTmCo5MSTTuubdD2oaO8qBLcPTzQTetAUQozgtrNPjtKQqSpJNmfQIFK6eHG+aMNlHo85V3BhOuZuT5/nKWRW2EOuxQPNMuV0L7BdI2zkN88IT7ODXN706W1Wkk8+jWrW+wlCa4zcMyn4y+6cfMpyIG7KZ5xa6N9kxpJ3jVnc5O5i+1f20cBwK7+tozTHcs3SKMM6fomKtvg40V4zmBSWO315QIXkd1e2HRtJAPeBElLIJF9uGj9uIj3mwePCoR7PDSdDTnrsBht5mjLmDhJg+q0u9ZjTsC4AVz2o/wd9pVhecN5g9SQ+EIf8VMjF3oYR4E5b2C1kcY36wrCB3BuqIDV9KGKGCghGu0pmn9eurppYMghvzIgW1RK10tXdwbR11onyAshpcwV5ZXqgaZe1Vze6p0RsJadgFm2F+pLThtLzllw4AULXwGilh5s32e2GoKs8j05OcuD/AO/MrvwM5h5JIzizZiELaYhF9gPEymIwOp3W25uusJi9Co7rQUiBKC1BG8LJJ9VLZIA+WqWncdOOImc9rpjE9lSkTvvM44/SJhJbSmCwp4+DLF0nDe1QnfMOHRS3ztE47qf2ndPYJnf90XvxkXuxU9p/ImcodNJM0VrgR0c6/kqkHYJ7dRjyO/JtsodXnaLOtCM1kZMEb9RNo0DLCs8gQNeK9Rb1z87C6pXT91k0iAkd4xMPuyAgNeuBuK/EA5Lsii+cxGTag8AIiEvfPK7PPs4KdZBf+43YklInIezXxt8lodBlPRb7ob9Xo9PNNcvnN24RzFiIhfLs2e7NvO5kXTBBKvjFd+VlfuZrdXC/SqDcr1iJDZVewq4WH+qWtfry9W9ljrT5lm94TNcCX4CgHYyiLP/nTUCrgTZ3XTvVRWTRw26qSISl0hUCR67l8MX1emm7Yr6fDvhRrLzAqcljjV0JbPslv4LEqHCOtrDR0+B7GuTVYkFxgaPrJ9X2h5H0SfeZ5hvGzdb9ykBo0mSlDjckgRibPrLhGnmw1zorRTDhDHZsrIJQlVNRdoSKXxLDYI0KaUvuRau2QYtsfKPwpNc3DBAzqxAy5YePzbnDfroGIsRNYuTTIp3xm6V3M4qlsV0YTqVgmKWT6GFkhpkDK8bEaL/sPjocfFrZ2FGP2BL3h0W2letkKeysscuUuMvvs3UY5HynVE6W8G1sWXHnCSmY+fzz61erR1PorPGs94lWVJqIOJlKxjfF8AdqfgdbHG6Ddmt+U/HkGjLZZRccjK7NDOAvhQy5jVbrUlE2Px3yVHIEpb8bqbDSZUSnnq7j1rJUVkS9vPL60aHwPT/qUmDsLcQEWmf/0LurphNfoUvipMH8oNGd7y3Tgvr0NXZtA5l+7I5s/LBAFyxfnMjsuVjCu5UOODW/a2Kre/2M8HBXvkjK6o5GUnGXuydeVKVdcW9t0Q4WFuI9Ifj0gaVcwvzO8Cv8+Ho7sxID0AfYhnHRUhk8KpBy1RpyRf9QkR2aqT6Esu0typioMpbPwm35kQQbFQJUDMGd2II/+BjfnpIc0hpQMEet6xCY0KiYZxmih/Nj2k22AFsveRBvcX4K1D26tx59m7hD9tkeLDw+6ZQ3R11NzlEYKPVwNwbR5j2N8oUxszhp2qOdABBL/0awrUl4AerPtOR/1Y6B5yTavssvpJSqN+Yf29+JBp4wQdFZ2nXBcr1zxvAJhpIgyd4V+wbBRdfplOcXY4c2byIjoQyIVhWvU6kYVj2HyimWMLIIbyTBLPLaYjLP0EETjBrIgb1VDDHTjbUjFc/Ig8Ng+P/hTTKuITM/FE6ER1U5FVdJu0ipuEnWRTtlny6EU1m4EJcvpSHtGWcfRTXJJVz/oWhePdwTmgawmrLlnctGVAlkFs6KoB0+/895giX3osY7X/mMUyKjmp1s1nLhXDBr2BXZdjIRtijc05O/Tj6H+dGPwhwfiw9BHi4zfA9+5Sz/8ZYZywIA3+cLdmBL209Nn+WnnOPVYf6Lej8ZLrIGlu+Tpuo4W90wI3Bt8LltxhGCreiMIyTpalPRJmOQsFg3wY1T+eE1xqNulKLWdI38vY/yfeihUEUF1KlCcVXgGPG8RT4sXDEukDt2SYbz6Ox/B7yIaUV31+nfTz0WGIaqf/u7EIfr9jD4TGx68VLn7O6wK2oiuRero5Sepymq5ZP2a22jFtxZh6VwMr6/Bw2o5RSfB2coNiSX8uFUsjpw/trzRvzb93BQqrapzinJS+G3wUfhgcdGs4FlfeUUuFiEL+u8PKfnwQ76ZSZmXVdOpeBDPev2rYjylioeKnZQbw5Kza+9VL4nO43gEA+oPz6/vRX2wgiYqU6EL6p7Pk3tN//BbuOOWvCzT/A3G+sJBkNpWzY/z406JnwPnAFxUnPxmtAumBVHQwd/jGIcYKG5/Xr/uzbA/Hbev43jSZdJ/PB31rp1rj/LIpp0DraUg95sMctMlE854W+ATXcAVAUvFyteemWZGqWRVUXN0ORzFANDHZNIRDVGWGmk8JPMEr6L4JjSNb0W6161ItPiz/GMjM1e6RkQvsz43ZyfEoImpUCj5EnEbN2Nf4np/qYxqpUupti6gcHZ1c5o16Spsvd0MR+AXp/ClGDrZSsJMXHYPFUgxoCVN94B7KEevqlX/m1JWPvU8iZX18rESv24rkEW1jiH1gfiezCfxtOI0wlt/2PzhtjeNPr6L2RIY9tvtneOD3qh3ielb+teMPWEzrAMJO6b6oKQFV2PY/ypfLI9tNuuhW61xoorea30iWV5YBO1tw8HPyv5NE8t3Z1dTSDTmVPkIVbrHR60OmqdWq07ZwXaj3ek2dnZa3XanBadBfflVpb66Kv5bLThVTlqH3Y9H252j45PtJtRgdNu4H7PhTub9eImdYhuD+HbYjzfY5G7UXAQ7e+3tow/N1sfuQfsdIDhYajcbre330U8RxBR4UavUwHH8/VG7s6EUad7+yvTL9mifR/8bMBw0DjcKSTKYbOAJeBtP0Sv94LeNVfiXof/fZmVzbK4TOyc3TKhwI4c/rYTBw9Ht+JPWmLGl0JXJpeHv3mCA0SPgb5BibmNicEZWsaOTMzc7ZV79xdrSWk/f3tZD1MJsk0aagRh+kpz3KuH6hmGa9+C8Cs7nw0FnzAU27Cd8oPJLgqwI0nEPSNZgJb+Vo7kWcFH0oForKH1u5ARMQmmBVboZ2Qm4wUFYnjm7v4HF71rJONDm0vSANLr2ZzS6/rUbRUSFJUH5OebZERWVSdXS9tHu7lKzWSDairmZCkmcpPZLKnZ73XCLVehBv9eYFeeg0oDERSRoqqKE5paJHAdbFOuiyoe9Vuf9yVtaUyykqvpPQTJiQ9lPwQoOOVipbE31VijnlqK5IAJCOkQ2tYCJeUrcw3Fzgnmn8UhX2PlmncOuZdIn29qs8EPvejgYzu7pKeEURq9NbZBTvgU+DVWDmA7MT1s62zfXhd+pq0MwNg8KegpMcalTOSRisDEh01Nh0i2yV2E8ztraVGU3vc8NfA9z+kifMQSpMHX7pDI3DXfpCWmdyZMKPSWR2Lw6MfaH33IL6HAuzkvRYq3g9ca+SxgYuX8ATW8SPj0NUmCZe5B7pgPEByLsiU6SL6yrG6rP1NWFTNgGzBct5DO24U6Ylho381AtF83cvXQMh90Bf0ZFChGtOtAU2Ttm+RLZvkDKiOrVanT0C+E1CHZ41Nnb/QiA4i8tlxDQa3aRSsQKQUUgz7CH0gLZGbf4OkRENpgtrMvztG2Rrv3xR+SW8D54TEmGeNdC3oC1QjFlcH8ygRM6wdEPz2RvN4yEgLhFAVKecVtuol0+nlMEg6RojPHcFEtnPJHbDJJIiU/pl3KBprB/xB8xCmdwf5ZfT9rWh+3G9vsmYz6HndbRvgdWcaiQMFey0yuhDyrbDpCwxcAkKVMoGQmxcMrHPCJynVTSA5A1X7Cadaum3BE0311gbCXvNnEYBmcWqkdl1UT2Xtm+ivufmp8nQx5jrkj3Sa4TnySywJuHpqthU2SAGOpL343FelLEuRmO7GPMVHr72A5hOUKlMSkFXf0xoSMb8pLNj94oJmTEWtCMqbq5GA+Agdps5sHRpii6BG/9ejU40yjoWAZVXskjb7Th2lm8mI/6KUY74m7qyHOoozQyfj74r60Gfg5pr2O403OTk8RQB2DhjrhbmIoCfWXWGkAbbYAggQE4xBlPPNqEJ1/gTqfRd8wkxp+wCXyrna5rPAtORtP4EnJ+Tt/Pz4uuyPSVN0dYAeJRqFjTq1eVHYZ0Gk+46hr+AFMN+INyUD4CvnxALVysVeGdg0FZQTP1pIIl1TFaCBVDio+yrbQoh/UchpWt1ELB20CW2qkMt/VpfGGqn/g3PU34tdP6uHf4Tqtv8SNjSofN7U5zR9un4PdWU5TwKtQoovGWjQUrrJCvJ4et5ru9dqfZwqJVQ+U1+2xpU5yO8j8sRctlPGPX3saMyV9KUd9jvw7BBIOwtCsklGqrwuq9i0ewgmkrhLVhBfstQpwiBfOOKLJk2s2K7AIFuV1i0MMUNux4tETzfTQdXg7ZCE5a+1p04ki0QjMLSWs8njEYGwHfZYfzm/N4mlq/TQBtJNz8lQvYfiQMQZdCaQyD+KI3v545tSgxzYll8tFXmFiJBCObDpO90UkSF5wpBrTiKSr6OapFG1HVVkEYiCyFc8F8S/YuJs2UWG+NzWG/E7uTtG02VyzZnUtbvku1RZbvMDkawY0hvGgkBAYvJKTSGFqMDTKYexcHPzQB01WPpJdhiKoMUc1EZHrupq7iQwPUu47hMS1jEQNI9gqm9CQrOElZwWV+dfjiE0ouUcivQZejRSk9p+R1zCIR75A5EiDEJyYaw6GTkJfQJ+q2b9dVjDbNhS2gTs+CTMBZxcYy4z1KZRmboVMoJ+bwmbUZWh2hReFpIM+SMtsBahoMqJiLMkWLa3mwkjkKYgytHxebwd/y9tFkiqlYxTGZZ+6K7mHuYk4MLpmvuwYLtnAKRpS3h5pviRAdFJM6jXOiEue7F5c8ufNjU2e9Bx9bv1b4haL4eZCID7Id/7Iv2icbuzbYCNzJsprMORT7DHXxEh6RD6XmOyFsSmzKt6QMgcyDEyypdnqzno1PxHwRpe4kqXroImFcHGSRCGYk64LLw7Af7Q6nyYyd/t7VjNcn8E+TAHvyRFiqldIQ7Y0w8vjnWfGe8RgLK3zKi5WPcHc4Gqg+khcDg9jY2QsGCeLZ7nR8s7dTlFfTVIxmZ8tRqAHsd0oDdEj++QsO3GG9eGNEOZNe8fCDdb3Db+7VDj8b1zpHauVXOryWMtIJGgRvp8k94y433Xh0ay4vroCTNnHdnWaHdaN7eHTYpJdCZCqsA8nbe5UH3tQGEAgekt8sVvYlAMJKT882DRtuyfy8xWwMrHSwHU9nwwtIkBc7IOLwaMf9+XQ4uz/Cl/PEum5379kU8YcSV5uRDCbasMQ2AxnEt4lbZeQfK3znkqFVcMEKBKXNAoiV2LSdIg29nwUnTBVHY57Cz7CUmKPCeie+3Wc0bSsljUEI6awvtEIuyZXxralSgO/bYWuZ3nQ6ZFJRCsSI0aV/lYYDbSZScVwJiyWwhUgBuxhP73rTwQf5FlS1TH6G5+/RK2Tqjh7rSNRARgcCuNSgFUOo/lS487jX5wvRnPFhcjgexP9o+8yR7IBJDEaGlzxsdn49av0iQ6R0D9rWKh32Y+iHfAc0Ku80P+xtN7v77PzgLg17nY8Whv603+mdX8cuOcVlDDNb8EQyhfPhqDe9p2tPRY2CQNqAx2duJda1NSOHR53u3uFeZ4917J94uC1RpdjeIXfCaLTenRw0D8G2aqluVW+fHB/LA3OJqsfEwAFm9+jkEMvpqv7QbLXBp+dgr33Q6Gy/h/JVt/7bkzY8UC6tUQ0enwj4/JJ2V9gVw/d1o5vdg6NWs7vT6DSg7BUpa/72vnHSFt2vUdrsHJ283W92G0A3LKwZWj7wTDpqKaoZOsPONg671WzsYN9rlC67e/sWVWqULO32vh5FjRKktQv+MEe7HVK+Zpe/b7R2SDklz9uT3d1mq9s5Ouoyiu/vIwCl085hm1R9ZXXq5PCX7nazxRdB1aAF46O7e+9OOHtcqtdM2ndaSODudqO7/b65/YuleWUQzd+O91rcw0tCmMusCxZyh42DpiqnJNtvvmtsA6HX3a2zbVmGrHqW9x6ubO6IrT95AE88kCd+0P0jFCoMUPjmAeULzQbmXwn4wd6hBaq/ULDGbzaY+uJpvN1p7bk95V8J+PtG+z3birvcA49Bw2tz1/hqbF0lz6TIN+LrSfstBWI/PZiaHQNRs+PC8BWtYNhPao+J/ZVnMpggSGPRFfafVMA2gaT7WMt28Iipf/zxB9IStFUoXZtF3ZNRMon7TKKKB20saY5uAzzKaqYiiwy5YzT8z3mMVuc+yzhMgTZF590ixLp9CZ4fK+vlaNEC2ye4FcO77XiH77LEtMJ3CsPCr71e/oby71cWY2VB5WA8mF9Lf+6Pu/MRKnfw5g6Q5ajAIQwPgb+2FFz/O0rBX1/ODcnZHoOqLddLnQsTYnNsAypuZSAQFofi/XZ/OIp7HgDXSyIFGT9vtxnXedvtfDxudo922/nw55B9oQtgnzC+QytS5VsEhmzcv4jnNpzGILubp5S9LwiClG2hMW9ajkZuT03bBlYuty54GPDgMBqdep9hcEYoH6df0DM2YgD0PCvo4ZphKmAQ4Kd3AzRZgFgYqx2r6eHw35UbL0UenpzGWSNTbLZo62EMFh4H+bDNeyVu8BhAelUqlZvxNG5MLxPXwgymdIc8X/Lo7PfcDhgeD3bZ4fGRrfRiyYrghyEii4UqTwbNgQ/Go9kVFtdKJZLB0gIX0LxdAmf6S0LkFQP+/Xg+TYx+WG1suG0cDEfzWZzkAWWMcjwaJIEeTabxxfAzalzvVZ5K7Cb8OCX5tqXMw76fRdR/ImkKhzVy/cWgC2J2pLXnGzucgAQAO0+iwAMh7gXifDGszDA1qh+wAsylZDh/qr6EcvGStCyas4W8YDJH4RuJCLZke8XBxny+FXkgzSh6nuThnqq+PKX+FFLOYItiyiFT8GWGtw4Qe3wd87NPVzQ9dvpMZBvfRKwJ7a5jh9KWiNDfh+1c4aPByA0altkYam/YtsJiNq2wcv4uOUdCanwp2p1cKNJs6gNdXbSjTjcX66TPHFeKAPvjSymZFhm2i/nIYruGkMchHOPGrmXcKMwh4D0euMB8er03uhiHHvDNS8MpqeFYFxGHjmcMhWWajvsfXj604aKJ2x+wzGqf1T/z2kaBjYOncwaMuSCNdxNPM5sp8fCoeYJF1+Pp8KY3vQfyEiLwI1uW+KjLL22nQbMrSl2Cid2SKd4tNIqzs1Yv0gw3q9sM1Qfq+EzLrHomeeghrntboXM1h0wJ7GYobF55YkNYRulQJmMiuEX/+tzfW771v9miFkFmoWHQbSIajq4YkWbwIoeT6om6yy9zLeOWDLBlzl2dBBKkibBl62Pn7crTb92erZ3wdl2DmyNw172wXukNBttEgwCpv631b/ovyUv9KQdMPU1sLyaUF+O7QXwrbwE7+K4gru4BjNKe2PAcUnntGbIKO6yncXJVdFO3z893IUGaKSyF45wZuhS/Aw7acU+v7Wy9vAq44oSMN9E3wT9COAQtdzfSczNGhieAzoNxfmM1+yQxBzaZM2KJiXYj/g6TBmNdt7E4CtvGJH4x7RTGJExCvm7e3n8cfN40bS9lVSay6l/cvypy+uqJ2hZgB8ZlWoY7MLaFtSeGGNzJN3DpuaRpi/IKxn+qpsXfUJQlQZdgsRBi+MMvGXvUqnH6+5nrVqhTS4LW7pR/PPPzcUtb5ObQvpEKuY9c8VYBAwr+pzaf4PtbtM7k2cqNoaSjK9XWnPHF+u/4lp34G3D/k3jKoukHb4JaO5aGFWadnDsWFfKmiza23iNWg5nBwlcX/M9YH4cQqKzmj8qRh3uRsz4eJYwHn0j9pXjRPRzPWvPRiN/I/009ulP0nXIJBVI0euu8jparPLen7Y3B39/QG6O+WvLa4M6tXmsbxPPx+BqmtR9zmHKEX7h3irwhJa4v0FcdlzhY9LpR6qwNQ7ovmwAHyeUGUTv/YLjaPnz5CezEVTH51jBBY62GqWZm42dk8RFVnySWZpruGHt+FmNpdu2A5+yihIjS2Dc2x7dJ0e/ARE6X1EcBz1raNJkhVV1/8ZgcM25rdKYX65TLH9FWqtOJwrqDYhsNmCtOUYHH0iY841UcbYLhq2aHnA9K+RA8NRR+PjvmvAp90v40nET2UYJUB7KB9s2+uqDCMOEx1SB1De/V9X00vrjgxrahgPR5xjrgCwa9HOMEXio8K8YcEgYhuxkmCbeV+ffDplkoOKZ537F9ttU6EzxZ3e2BF9orCuaXiryUX6YsG99avkpZvGqhzeWaTJWnJRlF70gUEY5ChYLkoqElX0tiQQuSmnJMnrh0D6lJ6viC6k7YfW2YxNk7+ipjCwMiQgH2r82zKRms1vn0wy9vtkom9nM0uLgwLD6y4GNevcIO8KKF0TiyVH1kErYZluGImbA9YrdHh+pB5Xz64w9ERNJX0rADaYxedfi8CbKjvm44EqaZmt0/ZRJLYNXGt7MgfuPc1V5aELYepVp7WXLHpufEoSntwFt20wHbhx6nKJ5u0KgWw6PJ9fzyEiJPblooHoJtpzD6tGQXWtaDLnDJvQK564pBQyanU7YzgdWVosbsqRpOpuEjmaFw58aPkWguECMrTDv7txXjUk/5i5Qpt971Fye7F83XJhlE07yMvx7Flr7FJpmPHrFNUu/N+efLQvO150s09/QTFn4p81jKBI5p/poqD2JvhkCbfRgZfOWpfjEfAWMK2Km4QuYzVqHSvbqzEy5FgKminbSyxuvvQMAM5mt1Q76oXcDrynXOW0zVY2NB7CDS7rXBW+2DqZtwrvdM+EAHYtRm8KtEGfQSs/i4dxkn5eg+vr4e3+EPwx5BLgFiksTFEdQRE4nZ0Jtp4yY1TejtAgcmbBBPaxwDBjqYTOM+tEegTlX1Myo+XcyISaAya/MAw5QL4K3odjwcmO/gEk/IDE4htB89fG2CDDcjtjUPKbKrHm+aBIsQMgwEQju3z6s7jNaEpZWr3nRw15vGNBU2AJ2zY16MlAPCB2oGRAiFR9s0RpWben6FVsq87mmBnXtDdrSB6WHhTH3tDW7B/DGJuSkblMhmrauX1rLe6ciAcOG4o0EVKyR9Kd8wuPKCtwufRtFHeb34w9p1OMfZzRVyYSloQnk1AAFXoY6smyaee1RqSkAcHYXQl0IJIgxFIWcvP6oZZZaWjfcPeVcTESKreDmDCFtaX6/Q8j3vvpU8j6wbX824n8AFfaA1FcZl1c2Gmp4p1yccUOmZTStjRWXVJhoDyR8/RwXMb3t41IkKqD1gawohdLSFgLbtZ9A0XJAyRBTIiivb408iqYi9l6+EJmPNKef/CYr/57kU/w8kOAJ9BuHrGZMB4FcjlpKgoEUd63FSLLqyXO4mA9r8u9NVZ2wT1JIbc1+fqWzlPlPHgXXauoGoJB7r8XaBa8+fQK0Xi1LLPvz/+COyCKhPNkicIo4/F+wtmkFbJOa20QtRl+4Qj+LLiaQeXLmLHTgkWokXlNoqEBao1ZO0v05IHnck/x2eOBd90vQ8fOvTyhTHMaolv2hxCRzskTHaKH1H09Ov4/xzg9qUd26slByOZ8OLX5m4wLXYWiKSeD1Zbo1gfSaM3QDNbxuMvShfKeQS5v4MkCAgLAlAfD/M+D1js8cuRzrAiEj4Ld8QAtGLohfwTojSAF0aKVk/yMyV0zATI+Pp+A5uI0ijERB6m+3d+yMm5oIAo2ZSxbg1ItyORG34x1CNqvC3eqIULimLLdXwgEKUxt63usHRny4tYWtn3lDeWLS0tJmGxYzfpqVmmXuL210gJvxhy8soKGJXWKEhH7KzU0XNZVevYLRFvNTBiQauaGBHf6ulWz8+0EfB+aRrsS88LDA4/R3/0umCr+n2+3cfd34zAV/bgOAk3PgAgJbxEDv4Z9P7nfgajfCliy3dYEjL43HCLRGsByZV+BxHJHr+XIfxsq4JYtQiq2MNHszXVk3Yi/nIB1sH2JV16z7HYVnP1qwHPVGyBCWbRjBr7Anrbq2+7jstU61khHhodiKvsYwaXh8vtHKcQHWQ5OEoKqjsOM7b2YW4qe4N3t6zWyvrjRi989AlWnhGc/xYk2Fq6nCzcoLzC9mypcqTTxFqgbl6Q9Szmmtu9+Rw+0Njn625DUcxqGJBi256tJCyV/ivOoKqhdJp9czVNBJlKIgOglh4US8SZgunLqcPDZ6VqUX2jm+n+WH/6J13eFkXS5MQAO1NgkXQ4RqYTYeXl2g2fsxgizkUrvlHo4+SjQziMknmYhsV9jL8/ONpCOeSf40EgPkhlhP4Q907HHw6HfPU5vAGS45lthg/F0QoQvPzfxVEqMO6ZxaRoTCUnJnAH6/FupUamAk/I+v+CWYdEc+xRpRwyS2xs2bujvRJX2z9ySNpSxxC/j4SPynWXUjb+jyqr65FP+HPOvxcW11dlh8w0Wlt7eXLl/Wa/LZythlAfCPyrkPewZ+ilRDYYM6dH33lGKCT0VFzz5f+gYDjDswFNLd2BlmS1za9YLTFrurhyzM/NIVk2IsC/Y/seAfXcUYqfz3RbwG7FuqzbgBUabotP1Kvv1IWKi5zBhD+sGAjpImqD+VDyjknJPFWfFEULm+yc2WF1/uuFeyPeYKRt5QQc6Cai16iulNySnbmMuw4nidPeiYjBw2fYdPe3a2ZMGQQ99l5dcgZIGN+H+rFEJdDpQNHkMp7uMQAaAfexo7n56whgYqx5rLoFjusytFa1tt8Xl6te/C0BN4/ab/3UtiJ/JqC+iH9JU0reYhsH62CwAgSl3odWOFa7o+H1VrhT5HSGRh/QtHdWtEmxUZOEbMDsiLr/f8puFZoqnmSBUPJmquldJdAKXuqmryxktcapmrPl0yAQpqTomTZfaZ3EqG88TNsvDqOZiLkAB0WT4ZSPytlSahcTSfEKJlVpUywZtgQ4HDrG+63Fc+3dZssHpNCzzEdMqdY/TZUlhcASVN6B1jsAiDpq44VmbNGXAJYUabJRg5TBWf1ZpHZVBm97Q0i1O1FbE1N436Mhm0QwQYupLfxFK0sbi1tENlcS7V0z2ozEIfhME2oxwNLCJ0evm/IcAPFkscLyMNyJoZXZHd8YT2x9+F1fUIv9whUYvJPfXWVpFqKR2bFC94EyOzsvLT/n3iUsRZeR8t1VI/D+mJ/stOu/jIzXR2DXtpi4OKJn7eHfkOI9EfUMzB+WWWXAcFKPtS7a63Gr28/dpptdj3QXyGCxw6EWduUqH/citaWjVx4MMTXIoDU8clbdhXC8FEkXxpQRr8Q4d5Bir4BEtpZzAN504W9w3YOuiv7mG1UaJnsst05Os5sTNeXU8B/+WbBMw8aEa9GpiPiKwdn9zVI9885jDIpFdMFRGUNwaTB7L8BZruEq8kYKPtgZhmUTl4czaazyIWoA2c0sKAPdZT4UDODAg8UMHryP8TXeEQ3w/n84sLQR6JucTSYbBoZ/jh2Qn9jjTGKhoDUkjO1l2JE1B4iV1OGIYnGwfov1qqCDDrLm9UIuU4FtZ4/P7MnXqmbdF3DgR94kOgAj3a3Ec4MToFrorcb3tK6HIu/eDm9eCW9eDW9eM0t9tt20Jl0LYzF8ZpJaGI3A3sEt4h15xYrlQmM5zqoRc2W53n1Hw2JNG/tB9dXn1fzT942Rgz0k4+fn7v7R41Ot7m8YWlcR/MbzjSyiSJAn4dg4dxZX7RCbW3RGvUVn05XbaMtkyb2GhDEFFTnIezA17fImzY1SN47szqmQjikFxvcye01AccZq8pxODbzhPchIJNC0GkMoU/x0xIe3VZCWPmfpSV9XPpFNbxoZaGu5ERNaCEGpO9rAF1K60lgVVMwc4XjCraX722ulXu7wKK9XWS93i6yVJHZTHt9ofgp3rKzoVhDuGV4v6kBz9YffgIIOHyWa9EfxkVThgGbcCwAU1/m7Bvx1F86zV6PezO+z1UPfuIBHCfjuyLj1YBtCdqlVVOWusL4E65yz2LPWuqPX+juWnz44YuXuG+BL7C8cxzYHq2JzPn0c8EnlRoifuTKR1mCMoyeF3llLqJfVeuXFZ/xt1qDPJbcoAereZkvpqiN2VCWjLTg7rGp0MQjYia7J6Jcxtas7B+PrCPeKgS6Wry0VtZ/r5K/V8jfy/LvaqVa03+rP/UfVf2X/jNe1n8StKQ10omX+s91/ecr/OvMCC4C2m4xxjNr+MMbxuTGO+P5+XUMqkvTYvuSewUT2yPhQKZ/3PRGs2HCnw3hvKiuvCSRz0QhUZGJLlU1EFSEu8rLNXJRUW1Tk1yuD+WPHkvwyzBPkLiMcA4peJY0gh+I4pWfgVTpCksEO8kOxVqNhAsQ0OxmWKMXXaCGGPlPAqPXjsKAfBGRk7DGfvKKvuRMYkw/R0uAYUPOh5pVnEwIgIuzm3dW++ObSRl7s0nJMZHpwo2Zl7Q2t7U5tw8G5GNnBbolVhfjB69eicDgvGf6KBOnFkK/cWaPQ6O3vKj4Gl+J/q3SjsFH83IKlFANBxAaSwH7g8YFrBms/Qa3g700igwCuD7yZr1fvItD4lXwZJFAE49YHpDazo2EikFb6cXPzIJCQ7qeKtgz98r+63g6SIyUNuiHO+DZbLyhYMVNC0DU6615ne6LRDjEYF7YPFFehnoo5MQ/GZx4SJgCsZZFyN8MSH2+UIV/SvWPnup4kGVXZ4dGoVew3TOSaZ+/as8JOUDEYP9FqlJlEl5Hl6JXLy0LXYHkjcNyeQcR9SkHOtvMVqqi5oItvWW2nkmvvMHf5jJfkc3UedOBEVAro1t+VwtCwlawDJggQmufG3n5qpnE0cBgkVSnLzcEz6u60yNVKntRczyf+aShXYF+ODP25pzmc9K7ZhckX3fbDK1tI7MQV2ks11mPy3R0/9AjcSL2liGlebYPLr/h5UgnSFA8wAZjn/ZGzle1SyfkqiTPZTQ7WirA0ch+vAYRHJXFbE0VXhVKtvyITNXpNSHkMLTQvL14cI6IpcLTNSmotgT/bubriCLLG7yNAFn6YETIaMHJ4l4odN/ti4aajprzsCdYE2iGfUfBLb9sVdE9hu6bKt9sJdOSr487E1sLxc7wrrYgOfwxSeE68h/VQtiJJDAq+XnLe/D9tGUaW1gU2tqy45jIStVqancVWEp/9bmAa+WnKHA8DD3p3uCU6M3GQ7TptU+I0fyGvoYqEKLeTg57h6BFKqXLaeIbyhfsIj6eYh1/Xy6y+oLn2RP0hgHSw/J8OKrDZZn967TOD0FZ4thHc3FK3nJ98gerAX+AzVjViuE2PxcHsULPPrFLVe8ewtEjyW6GI2SSdXaRh7Vf2iRynP8qW+lNJtf3RR5DsQHYsLgomiv5FoglyzFi1FmfvNPBCSJLAgSB58YTdjVcx/bh0l/KohDVgU/RiZE2Q3lvjgHAjF7Fn7/ypNrG5RQpxHHxaczFvI2kDPY6qoPRMA8ozqTqkX9wDNfJZALJBpLYTEvCGuxP+2qY5QhfrpLhfxkpimciFZeZm4uG84ffJD6dTN3FJpKdAMt1PpH1VT0SH13AOM7nHswarEMofE/MlfPhjNeHP0DBCX/YDyKiPv7zI5Naf46WX62v11/Vl9dXon/x73iNZhTUP7xONDAwvrgA0GagTu6ymabTA33pA1/niwTcKxilyW132icP+IIdA+BrqERcWxAO/hd6us7GwDtWhE//0quIVT0T77qKu5GHZGOZ8Kq8bbk6+CZYbDNT4j39lnaYilRV1hn/Girz2Ow9rl2gEBP+Sccmos6qB2ntEGD6s/CaRGH6kttvXc1mk40XL1Bw8sKtcri7JBVqXWNLB1yT6BBMUy4Qjlfj8EX8fKZiCPyQz5bYE3OdgurG6MZ0UbqdckQbz3jAZdRXlw7Jlk2zDKNTgoELxwkSbJKH23Jig2DgddAKixCTvcHAuEeBj7zqhlNbRQiQWIjAYqOTljsS1BPfg7/0Q4uvTTk01DwKhlbbVoh9jdMXntRFKUOUQhUzSKlDzECck4VIGsDxbQkb6sQXkzeEOJ3I1IdoGyJ64CHG7WuN42884yofXWyErCA6Rg5JDU51HROBOK1Ejeeqcyp8imYoooZHc+DiU1WXwNiY3Zf4lZV6gnIA6R34YLY64rnFXMRVwGbKTsIj0oSrlSPaB0KclBgqbpiWtIAreQO3mCxdFlLGJ0KeCOYHK5AEMzDjfIrCQExFw0XOAjWj1hNbPkFrC9yICmDniSPu5qKaJ2ncqei1HbMBlWvYqOFhZjGPa0lmWtWaDpkp7swbOMb15C7zwXrC0eNJxaYOIhxatFBbkwZ/RRGJiEdY0XOBUFvOh3FvoK4+6f6BEpNnpiQunKehZRBOt5L2NTeOGnHM5AgxlEVj6hQgO+sN/P/gnn7U/f0vu/wHMYOPgyKKUWxvAfv4cZa5XOf0qcnCR+DdHGWBPcEpm7Ilvpv1//RrOUwbvZRTFi27vIyvb2Ndn/EgbOEQF75kSTTawsfu20a7Caag7VMD3Mt7PMwqu5IzaLtKkG0ZgE6wEeOVL4C8QsiiZAIno4eM/4VZcEP08Lwk82giFErHPJYdWoB42NkbiLb4VnSoKHtWMs2gEzfYW/5xK4euOKH5EM0EpiX3DUEN23vfCYXus5OZe2L4HY55ECyDkCpznew9z1l3gflLiuPrAbjc3kB4t59LVvA/cV7uTofxaHCNh9T/bAlzaVjk+W+3NTLG/99iiySU0/i3RVldad1MFwss96dc7F4JwzPD9uis4dhnxQLnw19g+Avtc5sKVgIX16uWwfEIl/DXZH5uGWHlEHskijx3XHu2UjphCnLC622ahLVjac8IqnpayFGIqrulQY14o1b83NQkDUKU5KAoWksKGRpHrkZCQB6A3hhRkZAiTQdpzK3hvq6IiubKXfCXT2Y9sJ3jH6S/PPdVmmKtL5t6/0QFtFJhXX/GZKVPVWii7GnKNUla6+9JWoK1nTgnImyLG94niUcJT7o7H9km6pz4KpMCB60Imxs6qYtM5aaz1iRevtw881J0qmYsOBrxhdHPvEMuGvlOIfBcEPkARNR/MQBofHjJm9cRA50Dz3Co1o0YLtXOiS9yxp9q+DPMscmPe3hyCcM92/KgjlIqUHgrhq5/6RFab/4QXHdw39We6G4T1Nz+qebJP1NiCuQcOb7sD34GbXKHLzub/FzU4kzhtgMihBJQv20nVbNOvyAy0XsVCtuUcP473nssevx3uvL4h05uOwvfaeTTN1lwh+xcCK23ssNTF195i0y2py9kbz16zifT+Ba/LygHeWZKocrZZ2ui7ElafBHqsThKTmm9oHExEAWfLvFSEhUKm0Gh6+Hvux+4uMFYbiv+zzmTzoglCN8HU/6dX0vPx4N7YUvC5ZBZfwKpbiLyqouvAxAaVTxECgT+mKvapObj+07nWHbCemK6Hvc/+axYgLYn0+/CjCUI9oqDJZglPBVSjKM3n41NwxhBBmnAhPWofCXKRSgbGamWJh/QGORfzwGAIsEpPa2e0RflOsf0rtmJXozGs8r5/cj1uPBb7Yh2cli46MlfwMrFtLWxUASNpozLmKhkbVuqavNrxjZd8IMEQj3LZApKHSZyD6FCjJEvGqM9RsHJvO7sZnNGcFXgHPQmw8rvydicBIFEDKcitiPreY4EZA/OCpNo/C+JmlndgZ8SwKtlw7d/RA0uEIgYgBpWci6l9w4/NPb3drqN1ruTg+ZhZ/MHP533RrcwkEgdXUDceDSeX17xfm2C6zSmB4160U08uxoPIhR4eyP4ctLaL2wGeBcxaDF6/+br9X42HoO7273s+03vUxxBPmO2mmPobDRM2D97S/EIY8qF+07Tw/tT/3xBcvOTx+aGN48nnsbyxEljeeKkic+R7DUzZ7wOcvxpNL4bAQLHqtCI560aDcNvetrJWBuhM8ReG4dj7APXnsOkwezDcWJwwrSZF6t9iy8mFXlYXNv5HPKi2hn1vrw9MTKN1uwENqqyCUotiNQ803ylzsqwpt0ppy/9twbPkohTsMqIDbyq1+BTxNIlaJWxGDBdSeEQSKHMI+NGOiqD209c6AzM6YpDcM6x65zaP1bQkekZV1XAMK96Seuu0cd8YaWMNXZy2DjpvD9q7f2zGVxfHBXr02gYDzai3uBmCObUMfswY/w2wUNpOM11xgwguGM8ENHh5cVDfpaSnnNl4sEheSFfrGVBIy2CGrJnqYLJ/4qQ/I/kOFDyZT1DwBR0qHtO7KNus9U6avngOMHiyg2jV+8y9vFsbVMvuSMx5BISCZtOQ4w2rCNFlDORoJYwX5lI4//OmRgEPhFX8ahI6F2mxNdJovy1OXlEI5uGdzRfaHap15Gag5JmixmW6/ziMUxacW9wNLq+DxivLya6+QU3eRlXvvAP9g0iU7D5H6ZJmSa7oeQ5hLxUlzHpZHAEasrLprXLtkM8HfWus145rdsjqOMCt0dhYkKXUF4jJEOdATXIIfHMemkPnr5O1cDpa8CxT97dpp7RNTz7lwnwhgLeNnn2GDzrtHnUtJkwZ47EgHYsoYN20BkPAdis/QYAa9YO2/yENy4+VHXZQhmqEHTOAEzAbjhxIXlmN4aIp/hetREt1coidewG/Ct/DAcbvJ2yYnjwSdp3gopsQxHvIUVF4xyUcn/k3xaGzi/XzjJWe4pNib3FfZcjPwZ75rT47Tsynegn1kXphq25ZAjuabMx6ux6/VkEFyVxsT6P+70568+IS83snGKfYujv5TBhtMglxswnTFbRHM5KFyuTtirawnFXjmhSL6AGR/KYw8OuGTg7KJg6OkLDosrphReIXpIX5MgN2ubAX/Hn2bTHZbabROoYbJUhgDO57wsXrsCSh9K6QTqzWdvMtrvN2ZgRi5XV8W19cWLyPknc+gyi6tCeCF2vhRGp/URa422hYAob93SsvJmKUDESlZA5R8ZoEYEnsr4sC5MB5YV7czSuoUE2M/fvELNtLyTfIxqQ7BC/ms3In6SobQ3hVFBRn/Rnm2laSJPoGJxkOp6g4s0UloUUi82a7yD2DGtfQl0QFbgOkDJi0Fbz+VeKwheCJ5ojEJpJRLUZWj1Cb6ieDIyBIZ/jzUk3hqqzjlK2jL1h7sluETYn1/dv5xcXckLARdgUgTj/EWCUl2DmRt43LRH9zDaKHcrH3X3GZsvaz3aKe72E/tE+Oqyg529RHXMy6oLqMkl3qxLbT6e6fw+Za8U9mQJXWgNQ8FUxrYyJDa/jAXo3XA9QZsKORwyPCGUPNyB1sSfrCeQcr/Sqrkyf4nt48+PwJZdUpwzgjGuTGAD+cnJ0++ZIVA8EwRYTpVkYVQkEHr4oj0rdBcGHM3MT5NgC/lfk2dV0fGdVLZuHmuExZIzes1M0FXbH074QZloia2qaJ3nuizhcws2RpIjvpsNS+Cb+FLfuzEuwcTuHO+58er2H2cBTruSi96Z+07yT+y7loq2dEG1FDSNJgswP7jAQfUrKSFvqnr4TTjksoVPEF+9iFPXKEn0XYng11WIUxaVQVkJjO6keLvA8tdhusreDR2aw+qfzXHu4fwFyWEAC2cLZaYGAFs42f7DzP/H7wu50fPPxuOhLn02P9EFocukmEqMzN3JbLhq4k0hqafF54JRJ4qiXVav8IBFp7s3PPFq22fa79La9YQ+9DfI8sW/e8IBFxuDMzK8a+Yh/P0hEiTmskVHrgEuZZgVnKKGWvMOwG3CwwYy1r3rswrkPcSGn98e92VUQKbdE0Qgag8EJ8Jn5dazrXMCZbVfEFb0RHY4hptIETGLjAbBZWOTt/nQ4mVmod8Z3I2CZ78fJbDuezoYXQyZwkGYw8ftNMjPpKsPekgw19+xCfdONR7eVgcDZim/Gs5hgxdwr3Y8fuyf8MAXkpZIzyZ3pnOEakIqJecXu6xKg4xcTQS+sNhhhsFV4NAGJJtFNjiezxLuorBrgsTmRyaTC0+kZond4ZpMzpxYPvUArBFrWZ1BL6T6A5fEU13boCb+vqswZTuv7uSzNME6hMe4N54H2BfKZEanCRHI9vtyPb+NrkNJX7BDgZsahk9E1aw/SVOuWobkNOzv10XR4OWTUPmntF0vBoODeIcuoFGYisQfrYhDSnxvjzDFGc3xs7Tx6cGZkJ2tQuJBgXjKC4OTs57a6MsxxRh47HY9fg26flrDRwLrM6kiaP4GX66YwW/f0XJxv5+C9xXB7Wbw6HwNLbyCL5wV5nJe1Edwp7DAXc8vN0xZljnmOed/p7h1ibhaRl39msE1zNS7Mg3NyVIORelvOxYkzBMOgPJjWYrZQmSEkpm+HoEDpjMW46hT79NeBKYT47kYQTM+s4nTbbMAn0foQSzQjsPyen++NTjB6HR8FO8rZ1dKHygeuRy/qSdzsAP7IgI/Of7cwgljCrl78PGZ/aOPp4WgAVeBqxe9KBCVnXAhuq605Dm4WMj8X/htGVckoGcMGkM6YokdTFJ+eRXSSPJKQDu7tFE1PmynDJiQ2opXwUnhJChsidtSzIq8iBmbKFHzpAUCFkVR4PckYLlDHdBeU+m/VG9PO1MKmeSdqQBZCJ4aJuOgw/cYiAoGxeBlX+RBPE8xP7FluwMYtKCoDpyIo1Cu1Sq1aW16zJPa90RAVEjeo62D3i5vk0r45z+L+TChaAczyKSbXo6te0m7vHJsThqgj8Ra60+w0tzuQohDMqy3NNDlVOkxWuYynjIY7w6Q/vo2n98VSygvEQz4lwu40jmG0slWlcBOW3ENye0+8CTcNE+0KfD82LI7M2SYVfxleX2PTZo/UZ8fdMUkGk4PeqMfI4O8JAajcA93bs/GkaG1xAmSo+R/M8cPaHV/4NIeWs6RS3hAYKlynk5UYlrYtc3hbfemA2nbxMpmykG4ZT53Go1l7BmJQKXoTLa26a4vneJ2x064Ii6QinwzKUUEMCLT9/etxwoT583u5XgpeXZaiRysGP+/xDucsiT3FbAVD2Nfm534sJAVjg8XquwAckNwmGktztDASww6JY9kfX56MrjAZx0AYvrXi3/m4LZR0X4/Hn1Q1BV8sTuNeAh7OE47JsFG0L6+idqSqR73ZRiTt/woKCZuKiOPdgK/8T7m6LMrKCz+sQRRYzfMr82pn9lFig1uousjNp9fO++UcVOfwSMnEqILnxpt2InpO1T+27LPReYnLcSa6Rj4m52BLtDmdFjmFyvyMhGeK9snx8VGr09xhhBeCXDSQ+MH6Hh/HpDEK28m96Hw6vmObseDDUgopBxTR5sl5wf8MlLebjKmie8CH4XQ2712/h7NrBGnmKlX2fzWwmOlxY9+T9luh4k3SekssYrj6TshPtkLPtpekLxpiDQIsfScy9EH+Bbkc1jXQJQkdosvS+2bjaESEYScIg+/iEcPU1zKh2d1IKS2YWPgLnL6A0YbxOgiEenPGX5gW0LvkpEX8WajCMgmCQXrG14MtSyuTSjHyruHSwDr8w6pHOMONUAmAuTdD7lOn4Qnn512+3uVM6Rze1NLTefVC8WN3PNWsq+hX2pdJG4YlXMbTWB6On4sU1GbMw4vVW5vuZkV3VU8JD8/HpiQpljbzHSAB1PYD3kPKO/jCFnF5H+2+aAtwC4bobji7gqVttQmrvmh+BwsI9rlU8GtNv8E0p77vP8VkZxgQmMW+a1n45nA8jafp0sZfkH2QTn8bDuL2+ZEcfqSft6B9JhvOxv3xtbfrx1BYLOWQRv7qLM6ar/xc7pFMzGFLNRrWOTd3y9w8RE5/P5tNSNCZPpP5R5cH3NGoDPdFJnay+9SEXUfiwA6LtMN7X2DaWGH/KWx+o324yI7gmUQuhyPlo0FuB9AeoUcT4Th5BR6wLE6lkbn1eEtfuvvAciySnUKVj7wH9G4Z1+mJiwDgZGO7HU7Hoxt29S4stAMTpLUYsuh36tpc/huJTAtLQN+xlKPHyiOZ7bIlNJ/GRT/3/2oc/usdab/G5+1x/1OsQ7bdJfLoKke9+exqcmeoxuFTMgN9nCiE5FB3yQac8PILk9T+TyHaUKFb3LNPQgMmBv39H4UOHb3n4V3yNY481fb/nHv/c+49zbn3SIrkuyR9L8ek2lf/GA9HeC5CNEzidV/m2na561zVbS7nOdPt1o0G4rOIrlp57tVELNxnc8gnI+ui+DUviMZhnPM161HvWfogc84Uq0K9WjWOfPpCGxlxL3z5N2isJF5i25P32PF1G7/P8VTE61thmFR1054qTeugGZ2qTIv0nBJr+vQEtAvdCvWCEndBeRXUWp407eejFT70gW2Y4JuDgCw6OZczBmQP6b0eRFhry7hs73oa9wb3/EFCNF7wWiYurJ3yGzOKyAkxWwZKSnkHQZz7n4xkJ8JnhHRLTL/YE5pawGpXq9VMqkIK0T+PrKx1H12dV6XMZ9T31Bl5PiLuyIGDhNIwjwpw4Yle2MCTrvSod8GQI1GLnsUQLYm1wkl7kxRKqW6SC/dFBEWajQlbQZ3vF54BppVnJ05mSqupjP58z6n8Fc9++cwjcdshwuC5kZqxFwJwf4knupQZAtr9j3L1CZa6JKSr9czxbBe4O1W/0t2J7JHHXZee8l6TKYSfWDecoiYDMRxc+HqEx6xxHfBejx5Jgq/4ltO9IiYUUoonkRhELHq2EzpjyV/ET30KuzcVH1bwyjbwkPuh4UZNSe5D5O+Vx5k6vMGU7RBcDGDjazMPpTxip3AcNOEoOqYrP0YfuykmfYJj+EZPCl2aOiRx7lRGLZ88SCq7T3d0Wq2TIJ1PeixwvHuJZ1sPm/H5bPM8GjEwHRIASHuTFbj4vWxBO65Sf9AMQ8LedFZUS46RiIeoux6gf68RiS68ZN0dZSFyYsiZHCS1i7K14mJb/z1aoTVv2U0+8U9dtiPqdRxPGAcgGT6C5ynPIe8THJ9HBANlPze94Qi435YLIMyjNcwbO6IeUAxUeaz2QW92VbkZjjR4OaqvWnonWPzCBK8ow4ABkwETPWueRSobcAZQgLI5ZyYjYyBAhaXwXSpz6ro3w/50jHQPOpbSkciwDe6IdLp1dzDLjpFhW0PJAxLE467i/b3pZWJN92x4E6dN+Uw75Ur1yMx2nAAOjEutaMyBCjzJSYotLaVdUXnsMajwOlqp2mcvL3lj3ygXXhgheiJ+0/3Qe1JL0lZ6k8n1fZFHlEDKBm0bSfe3otpqNcw3bMnH6I8kptoqmqp4rTWpWo5qtWoWr+GHA0e8FNUpvGeiHZN2/jMFMmWXWKvN2B074FA7Gt+ZHgPbV3H/E81qO7IykvBEKTQajxP4EDkR1gsqYyUmHU669ioMLb68+NdpY+mfvaX/qi696v7H0tlP/8+LygxjJsn8I/pETh2HLWb6gf2Pe3zhNKbT4W3vWkliPfO36S1hFcJWNr+ktWTlTeobPy0fbdbr/tUlaceETmsGvNfpgKbmb7MhqxBjMxpfgu+irgzrkxJckSnNfNoTqMNvwmCIt+IVz3CZX+QVj+Y89Er5qPtzPrsJhIIm3C4BGRLwLQU+xoWWKTAh+YnfifoOjDl3WC5KklOr+hm609kIZGf2h6O45+sEz2427d1hNiYe+Q7R8C7hUwn8PO5NezcJ+dASVYxv8QX/RrnoaELY42e+gywURmzv3uB3A0jihPQBS9Fnks0ana3VajN6zljkx6PtzlF3u7G/97YL6We6R7vkusp6RVmFWfn/jWpV31DFkecbsYyc4xV9eWPBSnRVCqHQnBZ2xnqINjyD6+jz5+BtzlowRcfPEEv6M9VuM7rCN/aP/BqYDB1bKDgVQzIVIsCg2eHXDDnr3GfW8891462Ko4S+PIcQA78zRPCrFP3kIFnCui+i4mf+Z0oQUqvmczlMyRvvD3ZWi5BhzcgeNvssdUddVr49+yz5Miup9AYDxmd7OvhZMpvWz9laQTQmAwd4RqL+/BrdlWjLTGqeJVe9O55Rjm+w8YX4Y9Ib8D8+A1g56gKkEeBiqNc7EG6ppn9/0usf95kIdmuuKh6WQMYlgKWytgJ/2KGmhiJ/Hesao55sVtBJNyS2Gqw4Oqt91TZjW1OIqd2YkczvJNiqGDWo0hwRVhX+GNXq6yUHRjYOnqQlQ2Dti96zykSis+VMWh/D3ltirxeL2XtZd8Vtn3U5/ZXwU2R7SP7+/LmugnN/+vsZJXaEk7xct/XMn6KlrUg1p2r+wVhA9Pp19Ml2cfJTnZZsbXGamzMyil7TZbG6apKMN1xbhT6vsw08yvHkZNcprq0wzJymIU2V2iHWAPCgG9yJaeMQbPi1tegP/cVIWvs73wi/RwC1CRNQcvrGCPmvLcDr1x3hpmYcnW9qz57tlaNzxszZlakcgUK1LOcDIl5qXneOv2TqCtxBp3XxCwNXny6LXzH+WjkjOxqWBQzgExvIOhvQJzoQYDZ8KGydRMtsOOTnuvmztmL9Xjszl9UnmChOVkbVWfTmDbtj1hz3UH4YYX/qvv4Ue4BilaHoIYr6S7hBw0mtmnnO7n619dVqtb7yCpjDOTsH+qzC/wd/6BDcQA21P4FQffkDaHgOzSxXWbVz3o4sxPd+xdhwTD9GK/VXK6/WXtZfrXoHVBcjWnn8iNZXX718ubr8apmP6F+sk//6cwazIgaz9ujB1Feq1VdsPNV1Oj04O+zf/p81S2vVlH2Qa2DLy69WV9ZevVyv/1mzxDsDCbLwhAABxgMrzs4zcXJAMp0gVP1MnCgMqh+EWj4TJw1ERA1CrZyJEwhJZ0MpGav9vlFzhCyGYM5qn9ZeLtdX11dqr5bLbCnWl+vLyyu1l6DEXKsvry/XqnX290sGtbz+cr3MeN766jLbOXV6NRiWI2BEjtgDbRpSDxRg14V8d8K4wXKd3fx798V1qcUZjF3jPiWtAUpsDXLHsf5U5UHvGC5oXsBGakPZUaFWndhPUAujjQlaD53osch7t0BuE3cLcUcYMeEaypaiV940hTDodT5mpbmy+wMnnNGhKZfut0S/+II+4/+sAPsAlj1ka4BJTz+yyVvNkzple3wzmc/i4/YvxSSBqMsTyHdpLpIa0v7JVspohK8wp2dsEucz9bdcjWdlQahTWglfkCZjNuefxESSXZC2lNz1AyPEVQMZqHhH6crwrh5OAhPQZq6r1hmHA+VMWh5ozrny+J7Xl9dWVr5Sz3Fawj3nWUGq+XDhYv1EROdHj56vT5g0Z8/zvcPXEmwb+Itxndqr+mbksRNW9MEpsg8GPmSUguu1lZcr64zS68apgayND7dmj9cQzqr2geEXsYn22u0jTobdR6RqFaVhyZ+MohopqplFdVJUN4uWSdGyWbRCilZ0ZBDWNX1R4hdFoD3jQ0wcKTm3KmexgCYCltNruEnZhORHHit+/lwde5/UgUeOuAxgdunID7yeE9aCejAuZ3wpgmD3as0cUdZ2CWwaN6pk5gYKsU+1jeoe1umLUSiMvOLPJL+xPQxn9gCcccZioQp2RcLyGAj56axUmY3bMzCxLdbWSiWdns7DrxiatJBhTgwwqtyE9APxBdcYwx+vo2r0M/vvhvzA7gAGc4a3eGLV1ku6V8PLq3ja5fCOaOJA0EgwYuEATvuzsh4HGz9lOm5Gk/TE9lZW2FbcybmRAFcAt+TIK9wcj/2243VLqC1JqnCkbhJSTcI6yhyC8o0fo49e+n0rpJtxalGkoh2qrNFEp7gfTAFNAJmqQprRmo34XTwShtqk0XDg+DzxRDNmcuiEXCKTJ5KxWQTQ+Q5zpuoOB7vzBaW+Z2VdDAV4yqHOFJ6UkHbG04iLAuIbywh3D5s/wGPQ9niENwWZ6wUPPloAj0V7h3udvcY+pJ4U+lYKYZuzAkjdRaJenKB82Sx3EksxkBUT5EOz1d47Ouwe7LUPGp3t9wCy6sXy9qT9EUrXzNLO3kHz6AR799IagLDthqJ1u+Pdg6NWs7vT6DSg+JVZ3PztfeOkLcZUsyi3c3Tydr/ZbQBhsdyiG83oieUW0VqdbaRIq9nYwQHVLKrt7u1bNKtZRGu39/XQaha5Wrts0tpHux0CsuYBed9o7RAQi3hvT3Z3m61u5+ioyyZmfx9hLCruHLYJglduH08Of+luN1t86VRtMm0fHe7uvTtpcTLVa84UdVo4Cd3tRnf7fXP7F1AEOkDN3473Wo0OrCEJ5KzS7vujduewcdBUIBZB95vvGtswGWyEt70pvqfK9xINBgf+Dy9ewGZ7MR2MR9f3LxqT4Yv7cX827vYmw+7V7Oa68nvCUbTxMbg5un3PvoIiBfJWRQxNPBokpBg3d388StjxyhBNlQVEMp8wHl+pVHrTyzk89CaGKJ8cjgfxP9omM8Qi8fZsx1ELxEK7Mt9f79hxNr6DJyG0NQPbEzDvLhbGo7msPJWVC+WoGAOYY+4zsUK0ITIw/4F/lbeEeJn1AlesGG1WqYzcZps+UXdc6oY7nY/AQqYrbdNdI6yPqh7MWFpd0hZEQUgBLUcXw2kygz//AdHgPK0ChowGbSy+scqne8Fi0d3YbA34X/cestET+4PKE/sTq1Q3hD5O17IiQzym348P/WB3mdquQmYRaNrqkvyc3iOfJcdCnYE41xdDCL7N/ifFbDDVzo0L470BD6PJau0yZC38QMMTwe/KeISG6SQzNNveM1M+ggbga4UJfIxa3JRdv2c5GGEQqQix60VLjUcaEKnpgk3AP40Eq0GeLrD0AHLZB4PMgIEERX8hz8QuRFUIZyDTcnHS/naw/15/1OQlkJXxJB4VIeFbAU3iDTcEC5ItnOlwEB+wowCMNYoF4EIvJte94WgTrKamSTzb+rw0Z9tnaRAzQZQ6qxmYRug2l0CIUW5tBe8FljkkysikElbBqKR49XafpykwoJ4n8GhZr6qMbm7hctXJFeHHZEOplQdkRpvwIt/yfMGis42LxLi6e5/J/ZhPMGQpT2B6M2FzHWNSskhnD5PxJtmi+rngtPNDRpty0eO5QQ0uTPrz47BDjDBs/A/2njCIwCSNYqEQCEEazgjDVuXQZZHBFC4yqKa6gID40wWWpmUcIUsZMhFsD00Adu7KwqJZuSRkMpNRuhKVZsWOSLUAa+ZS1yJcGLp/0/sUy11/E8+uxgM4Na7RZwBy4LLDnVuZnY8H9+xSN2KHzCWb4AT+bs8x5if8ieuPal0+X01TzxY0WplPp8dUh8wq8WNGdkXcjs3xSM808ErjASNo2Ai2oeQA+OdCAf5b0i2wKROdec+5SWGbj3QJhlowBk6qfcmphvWzzzI4UgCUnGC2A7I8v9v8aNriI+I/ZJarIDI4DuUZ1/YdfO3wgSePO9kwKDVrkIvV/FivBpLqiNUHfb2Z2ArNSC4hfrLQqyi6T0LUnfF0+F/gHszjzKIDLhk7uty6HuemVsrqvtNToxPmdVZKauIklYeLaJ3hiooqD3hmR5Rda7ZPutMty/ObCWKmT3lK0zmx0mGSmJdyrCbhvc052sOQfnwhQpgVhBybnc6JQGuH8+l4MuG5j/g4C+rYQPdumev7ykfhR45Vn51odok7kzBKJ4MxOzuv45HY4RTUeEYnhmAc/o08Vt1VJNsvOhi56l1ULIumbelAH9e8PJ2zy0ELJqHHnCKcKWinh+GHCXrAykuAeaouutDH85lY69ZmeqA8hIkowBNNzTEroty1d86EDcn4+tdDxlRaZh5Y42MF4aVtqhBIfLd7V4awVAeIHXpwJ78fAVsF+08rPA4DSMZoTw+8WqFRoMIPjkNBztfe9F5kpij04OpyjleXAlHjCOAYLhfib0oU8CnvjQbjG26oDM4dlsQmVDn96f1kNq744BWFgmotIegqrZYMtO5QbldmHLZlLzgxynj9M0Us8n3T8NroDRjlE9gfsrUK6Er3DpvttgyyQGvc9PqNwWBqVTlobDd2dlqBOsOJp8recUqNZH7OaHHQSz7RKu2Tt4fNzkGj/YuvzlTaY+iBHJ10mi0frMgCsXPYpvDbJ61W87ADmlbvKJjEdTG8NAfB9ao++Ml0eMPWndXGcWvvoNH6GGgjidlkDtxa7SZrZydcb8RkBNTq0EqHneN2s/XBTwEQ+I7ZmmKQA1rphFU5brTbvx61dnz1eoOb4chXsbFzsHeYVhMEmeMxvm2pSnCagQonBJ/4KrRDNRKRMeuAR2ag1Dtp7XU+HhztNH31RK4nSEdLq+00dxsn+53jxjt/LaFtwssrrbbX3j5iVG/Aw4Wn3t3d3a/ghD8YX+4Iz0JV91f2H3iY2Tl6t9Pcb3z0rl2hduOZmfXibezvv21s/3LS2k+rdYCXFF/FgyaTXnfS6jZH/fGA++o6tZuH20fs1HiXVr8Ts+s9MlG3fqd5cLzf6DTT6m/r2Go+FNut5g7bvnuN/XYaFkhlxFA4tJdoxENdJv3b/at4ML/2jqa9/b65c7KfOpqD4SjYB7aVMts/6H0O12/8Fqw/Gcfb/PgzzqWjpjj+fHUw173U92qupPMEIZhmHDtHvx7q65JV2Pxtr91p8/clT/H+3uEv+EpV9xc3DrtH8Kq07C1mG4gXr3iLxdiIxwsCuPwr4vFI1MNsu9Niq5tUcfhXZg2XfWVWMTlYJrjLwHIMw+RgmRVcBpY9cA/3yqzkcK/MGj7WlVnJy7Yya9l8y65wsnfYscDbC8AbDIvd45u7bPXuWBvKAFJvqrUQxMHeb86uMgDwR9PaWD7WaW8eD5/MJKDBJHfZid20RmcAdFonTWtsPi5rdyzETTOo7+Gk2TvPZKLHR+2ONSAL4l2zY43IRoFmFvUwQGDQDkPePWodBPqiYP7RPjoMdMeA6TZarcbHQL8U5Hb7g7WMHBDuRMsf/lcyWz08gRGspsE1D44Otw/aaNuaAtb4J1/jL9OA9g53909+23kbKV84P9zB/+3AHL3KNdDuP/7JaZw6EcetzjsAquXpX/dDHf0D02FTV4kSu452dwOLRIOElogtu4Ua8whouTeWTyrLuY9tYSz/ZraksJzt2cJXRjVX8sqo0EVlwCEG3VDJ2Iw89xNQ6zdmsylGrShHtzqDYnI3xABgNPYFBFeB5HpKG1DY+MHO/671BAyZk3iutmkg0koCB5OhP8iBSukOHExUq5ADkVYpOJgMbUMOVFzT4BJJKiByoNAKCAeNoZvIRSGul/AQSCkscqDR6goHkaHJyENqosVwiW2qOHKgU8oNBxdVe+RARHUeDi5LIZIDnaEKcfDZipIcCKWGxMFFVCc50SRBPEl+RFSf4ptHqmzJgY6oWRxspgomDzKifXGxmaqZHOhspYyD0qO1ybPNta7G3eeGHmcBZFyFE8SnNDwLoJSanSBSovpZAK1U+ATREo3QAmiJHiiI2dQVLYCcqoeC2C0d0gLopdYoiJqolRZZE0KZFF4VWtu0CFqhYwqj1UqoPDxGqZ5cHkO1UimoDNcAfNuohCQe0wKH520XYkzRSEHP3UqNbBJg8d/8PBnyoEYQrUL4A8CLrBlCzZd3HoHB3qdIqokzDj0OPvSuhwN2emIwEgLjhL/Vsdwynmds34mE+GmIUW+mOtMCgbR0tiiF3IiuX58SoVenMCn0+LJpoeTL73mxBF7ZwhRSo84mkBabv2cKhR4VwyTS486mEb8TfNfHjecRNeWswfFm00Vfcr5n2oQejMP00ePOcwDx+9v3ff74HsjTjh8+5nTqJJQ6o/iO6DekN2xXyRDyF2tDOO6KGp68TvJqM0NRQl+tywqLR6rQ1+PveaZChgnhudLjzp4tQqOvOF9Eh5E6Y1QH8V3zrqBZSAr3ImPPnjeDUl9x5gyVUercKZ3P9zxxAdOc8KypUWdPmSbQV5wvrZNLnSyqVPue5ytsFRWeMjr27FkzKJU1ccJylv3WwbLxxeB9o/2++/Zkt9ve+2czMxxyxZNsSWksZ+NxdD0eXUaYb5a3Vo681azYF49eVIZ+NnVdGcrV73lhpVjNhVeWMfrspWUS67/p2jKV9amLS2rbv+d15TesDC8pOebs1aSo8xW5i3oIyZyn5O8wUe1FZyrJP1XJt5irJHuy6HPRdy5yB2yJU0VuNfZcIrem1NcVufXrXurckce573nqgvbc4ZkjI8+eOEqmrzhv9Bk1fdrIK+h3PW9Bg/qUiSNjzzFzlFJfc+roo3Xq3NnPzd/z/KU7NYTn0KZB9jw6VPuKc+lYDKTOJ3ns/64V3iEnkxSNtx559gRSMn3FuaNmGbmmjdtU/B1mzuflkz15fPz550/Q6xtMoTCGyTWL0ojl7zCPfn+r7JmUNMg/l4pq32A2lR1SrvmU1kN/h/n0+79lz6ekQf75VFT7BvOpDMByzSex2fo7TGnQHzF7Vgkl8k8sJd83mFtqhRecXgkMmRRHRVDwcvusidDE5eqhrAZRLlBjOPHpPr+8s3QtUgu/v8NiDHu1Zq9GSov8y9Gg4DdYj4bhZq45lqaWf4f59XscZ8+tpEH+eVVU+wZzqqxl80npwsb1byGnez3Ac0jqggYLyOqSat9CWpdmyvnmUxgX/y3m0+uRn2M+BQ0WmE9JtW8xn9I+PN1AStl2f9cGUoEICSkGUmrcodmDiE3DfrQ7HA1EM0UauweoJILNR/AHOAbK0D+VLtTScfCVI6AR5gfDWUFFHqyBZMlBbBgnUrYM769G5Yi21hgMZLR8qykeNt9jnq/i5PsGujeSgb7v+7PPZsyiBcZto/lyMpDuPDkZ+J6QiRM+0Kgaxb6V6RqIYLzKSwBYuuYo+OInveQJ7Q38mNce1qURA9cKsrcgIiPOWHa4kL6R8No3JAi4RnbyMDkaXUOcbrLZ+YElDSFuIZJqEg+whzT/xLMiAmJSeiNPMDnOhqPb8SdzcEV9/nmTUVTNmQyhmMc0X3kKUZypnE3vA7311RfzwFvUWXH7PfTxjenAyWGnIgo2P/fjCR60w1Fk4N9gizq2CeFbK9wFJ4UOm5lEZNe7nffbx8ULKcijCwKuLi4EKnv7/XikP7fQ1NyKwkYIZhgJF6AFvDuarcCV8gV8FhwQE3dPIR5m0dt8qaRqWP3wjqk3n42Li3XRRdTGs3PvuKh8M8pRYtJkuhAt2p1GZ28bqaGdqMOESAIEmPoGDgEqi1fjxEyIzWPTioy0/AfksCSrWwZILhYAQ2X2efYzYNnCWNOAbtOT30Uu5vPhqJ4wuUSgtrrEBnR5GU/Vukwnk6XCJqW+B4GSx9Q5ng7Hg2F/274vYbontHQaX1wwyHz9UNULMYa2x1kTmGAqnvsnTTShOwjJhuSpYUlhEB072rKJKgokLyhasQdknGOLy4paPFA9xlx8JqIZSBHLtBvTIaRk2qvu1d1w4HaHUf8Qkmj1poO73jTeG7gdkm2LGPbUnk2hFedtqBO20OcVWHTPyrrHJUfUmSZegtMxqojcbHRYgQxPiRdPPZBirj6bglVoAFD2zQdgy3z2eCAtk+stqWOSeQppTDJPMY1J5ismMck8xTQmWdiNU2aFCns3hgKXhL39Mmvkj0kWcAjLBM8fkyzoNJRZIX9MslTXicxKuWOSpRqOZ1ZaKCZZ0OTTH0UmbHiYAZ8Wk8wPRGOS+SFITDI/AI1JlmqCZ2+eBWKS+e2MSEwyP4COSZZqqGR3bLGYZGmGF9k7LxSTLAShYpIFUciYZBlmBfagU2KShWF0TLJ0GBqTLAypYpKFQayYZBmtqphkYTgjJlkYjMQkS3vmpzHJwnA6JlmOgdKYZGFwEpMsu386JlmmyUJolbgxyVJAQkskEJMszyNt7o2VPyZZ5nNN/s2cKyZZpvo5o1remGRWJHOMRN4bzRIZwVx9UCHM/62lTSYyRufz4fXgQzxN4IZh58CpVWrs/6u15bWCJahC1UF8O+zH7f40jke/DgezK7t+gkWVOyiLfpIB2nm14+Hn+LoFSuYMzO/j4eXVLID6CgsXwj1Mjq/Go/ho2gEjUAexpiBvfoedRm+iV2ugGMPb3U3vc1EDOTQoR/5CPoxS9MLbwmsRRNDqa783YZ2K28P/io/H18P+fbi3XaVkt6pYaBMvWkNjlgMpDxEzj31zx6i6zWA+vYUbcXIyEVeFg3g0z+z+Tkplz0BS20ofU1pLKaNjs388Zrf/5Dievpv2JlfteDqMs6flwFvPM6RAA45KEz9A+pKqvMDlbVSOTiX+SRniTm/Wux6D8uYR47QqZwzWbio84qVaviFbGHOMG2q04v54OoD67XiUkASlaWP2VfSP19vEY2fXhyxrmGLzew/s4M5H6PBJwpGFRpE2CIo/ZduJdvy8IIiVg4e7LdB9Qb85huyOszM+d68ZbLjLgOgL+ruDsnVGZzFNWd7eAnC4u4gqH3MR6WFCfbuEtLy96112Su/2bobXKaxQw6TjAXaWjgUgwjigdHuMydUzcDCu7+XviRQAckghvn7Mh6xgt2fkUXYwMJALBMnA8GsvORLJ6kY5sCnYDLR7Hqz4sooiqcLLqm2Px5/YwW+0xXH8Et8TFeZtEtBdkszQ2AJrAMPS7V6Pe2ybJxQH3S7yTWM6N62wjHzSgeHJweHL29ceYGBSHzfc283F1ovMZPiOrjr5UT6BklNJFoHkPGObe3whGNMzeBSej1SyQx0EWfUhySCWaK4yG4uHl1I5Wl5brfof1RfBWxixy0HBxOaugNZ8NGLNHo0ao8F0PByE98swESCedfQrXlre9vqfLvHNaHt87W7kwv+6qML/FcIIGP+P3Xq1yecoYdL6IPpf61X4vzCG497AcMsQKOrBCnsjdgLydv2djv5Xowr/V8hAkTn2BvxfIU9HUggAL3R6SvxDCDbB031m9rRafVnv9woZaPyV766GsziravY05+uCX4iqVzOqhTjmOrt9ezneWg6EX8TKb+bJbPsq7n/aHU+5mUyK1NI3AH2yuYuNHGkEmJ1aA8qy4ezlcpWIkMpm8zqOis9uwAjkIB4Me8VCkYn+S/g8Ooe33A1ckqwWOcHgLXkwGZYKpQrWjEkuRo4fNQWvzUCs0HpPlDGJv6b5wTn/avTpPFpi0AysZKT2ngxvxyDFnrM+9AgafpBnjgOr5xxJhP3CGtpcxsoz2nMgXBOWc7bsip5jNvo5pAuKNtiwrYkHk3Uhfx73pr2bpDgaD2LjrZX9xuSV7F9ugMAoOUje3sOLt0xLfMGuXUUJjXkBhiNe06QzfKoLZMmpBD7bJCC31I5K5QoQkJSMPKBvB5PGk2C+fMoKiKYgu1GvgNXo8Hw+i50En3SPCEkccYK+kd8vGaeextPKNi2tXEzHN2K+U8DKTvOnomtnwXyo59O492nTHifkWH6aUXqvHf4xsLLsgWKi6ycaJhydX2WYhurOOw527LHNmmSOV8A92ZBb6jB5moH36U0X5eG90az4RJ1FPcWT9tPQfHyFHnNu/6RdVkqPp+7r7vh6YCSZeILDjOMUZ663j7m6+OC7CQD3ONn7CzCObD7xAcx0+73rnWnv8p/j8c2XEPkj6pIrtxbK5ggeVAZppGYywslkApaACchqcA+EV/zCQqtEae6Jxv5p1swg/U3g6wwruLJMYfS7WGWmkP1UG9lA+tWX1/ByNJ7Gb+FZ9IkGQDDmOjTNYZS+bBUdxDfj6f1J0rv8PpaQ//3rS2ZCSdWLcyw6jTepj2lmLZCbsLhC36PwS+KrkbkoAw9HfxpZrDcqC7VFtrRXqk2r4ja7hY9vPnKgivnE5a/zsCAdQ8+Df7ElFni8NKs61NrHGin0yqQQvzWDi5H01PsrLLL0NdZ1Ox1aX9wQPp7tODWEtqcyu4KHikesseARXByy/4H59J26suxJTt4vOXhPkvik/TZrsvNxvDnikjzla3FqcSE1uqw7EVDtbGZhPdlLQWhK+9m4UGRJ0noYFPIykRPOntJAgP9ndz2JPwyns3nv+v38/MlWhUb5tRcHa8Kke4KHZHLQGzFSTJE2DAZ9KdMp8hB6BNpubXeM0I7oUEkE12kfy5WPYegxT0Fu2k/kCsVWdHqmVbt9/ica+LkQeGJA2QiNN9k/r6P66hr74/lz8tgGMyDHqKp84lU+sSrr7B9agVfpRz9GtejnaPnV+nr9VX15fSX6F/v4BpTG0Yb8y6Sdd0inozNA5/FODBCGUJ99Xq4Xk5lyuLMooTHIOTIIBmNkvZYpctXgh3zwQzZ4hltE32a/DbJhdfhfGOg6DF4OqAhf/4VV+1e96TZbVQ12+JdKjGT11dUzz1BFlaVaCdFV3XcJ+VzJo/b0cYuUo/jzoHefUH4yEF7UO/gMwpsawHtnZ8h4yQDYC/4FynleO/opqq+w/1mryv+pxcslvchiiAKAPKog/kRfwAFsz8621PWLlsb9+U08mlX62F2gkIwXhJV4v+HnZgE7wFHD70lvdrX1wvNoRUducE6ed5c0oPv8/7P37v1t3MbC8P/5FGuetCVrmhaZpG0sO3lkyRe9x5L8k2QnquvHz4pcSRuTXHaXlKy0+u4vBtfBdbEk5Tit+jsntrnAAJgZDAaDuYyI5jPKRttiFuzfbw53t4vJrJhCAgRjqmjBw1T24BB61WxMzm8yafMwRqwyTN2cQkHSoOt3uTyH+TvMkHII4Y4NJt+SlrXPehWRYAzJ/Y65n6ik6eXTUfbp4IyXEn5iaOJiNyFA0JBPlvAS/1so2lpEg9GQLveTOfDHSUH+8TaviGjPf6WJI779KTuVrVq4r3qpIQybXubnKWnRgwxTW+dAlnnxqrgSwl8usZWyTgRPP1CPdJcXLd748pUON1XPiTDrrTKHWNCX2fgyA0tWN6nSafWAzCQ/axnLZR4RjCvecoW2kW9HyINGg+UcjJ8gTjDu3gr4H/+I3ULCA3VA1SbSvUGHR5qzg+ZbTQChgNj+hvZSrMj2MGl//xcQP71BBxykScNHcIQ4XpUhsEGDgpxVln/ieQ2O/rW+if2NwbeBZtIqXtOOMepfNwJN4h9r/jfLZi5AXs/fjbrW9r3T18VzrXc1r3G25n5WrgsE88kKKJF23yavmMfF83zs7C7fDVot/bNpjbRmqJv7THQ4Lqrf/GVDb4U0GbbrjSgPpsoKTZZHejB0WDEeO9mwvJ6RY48goZuMIQvg9vXsQtV5wcorNOIpO3RdtdXa1BqJyiR/SL71tKQeCIuzM/b2QhSTN4TB+n/ZKsv0WgNB1J5B4HRlMNwnLPtGTldsXaCwK8JsWTsnouLbbkL/IJrCt51u0v9Lx/SeoBStFhPwf2AAN9475tN3zCd5QH/W9EMB7f8+UfPDQ9KjWzS6JxtZcN8HEMvVslYk2gi4gTFNqn2JtFP0zXebq6xtMWuCsf57proSFdXBOZqWS1jB1YSrGASAxC2kT5Bg7dE2vv1bh7qg9MHXpW016P/1+wFt8LeOq/83g7/+hQP4zg1g8Le//JVB6A86ruwodnqoZ9N1biJta1DABWgQh0TFKSb0VKXpQ7075n4i5+0iPWrq2S8ME08SEzN/+W7wt43k3wyCdoX5z2UATH/vVlyPaPCD98mKJfa6e5+3WxsbG3DzksMody0iEjtcYD74tqMbX6J2R8Z2hyxwNRxnqbUzxG0Ef2O7hGiJ5D+P4ADriY2mNevST65dJyYCB/3F4tQVuMBr9rCPcuKovea3rLU2oxFglFlZzIthMXYPI77icWQPx0Dim2skuBG5R4EveATa0gEdfndB5vTKRlb9Nn0xKMevGMru6lqVJK89tkbY8Lg2dwhdRm9Xzx6VNXDErO3hTT5X6bXE6tLRyEMz+IKnQ1s6ZgG/O/kOV9nS0cUrUUl+g5au9ZHfXZDLbFJcamZMDbz8jMdQfRwDyY/OdaR21JnAP4owEy2ddLIjxVjuJ3KpmGY0VRIk7NLNshy7sxzUZCvnm5G/krejTzIyjVK7IxIpfXDkquTpOefsTvBNwKSCWvqmv5NVwzKneeHkIsQDDuqOlE4wefeVtbt+xetZdWDlmuYTGmUvqypa18pt3r8x7VktgSeit/bQm4Bms6cIGTwy+3KkgKxg5sN7fI+bvz8SVV+zOTOu3U9aycH/tjT430Qg/KtVcWGuuoCwpBz8rORk+JXcWm1rv6CZ36BfNhK4Eg8Z9L5ZLmgUDz/wuvKw6tJDRWWJ7ybGiZzSBIEgU7p0p3aZTMhg3+v7laMQ6TDs90kBSdXkFVd9UFQwu8xKcn0uFtWbw1feb8Xp2aIaEmYcuVpx6tiDqiN/sOk+oHVA/Gw15qCOEGNYJtWN1kwg6z9i4ani0TTJp3cQG29D8/N/+H//8fBhb55V8zb0Qgk4ORD4gyt9fU3LEwD+8fDrWAAbXXjAsJOQKpwi9cuBWaw1GfgVqo6Bs5msvmghXlcwf5QcLLc6VjPrVQgiCej5rxc80KgqjnaDTOI8c1KWhcOpLUOUDS0mDkQSoT4ZWLUxtG4yY8jB+/NkTPNDGk5dFj+PkSoKTHRVafYEF9fRh17Rh7718oHwc6/gCgXabvROQUGPmMYWoqPBbzUj8W6uUWhvNIJjP7I1iSq0NWtS3Z1rElDwiPqeZqNBac6akVg35yjQW1uTJgT4euYXtWuh3dzrIL3RCIawoiPAbzUj8G6uEWjv9wic5LcamJgvXYAVnBqnAfGclV3Bvok576hd2XvO0WPOqb5pYWHkUJ9U5yK/9TN6xFfy0VQX4CJyqzgH436Ppgcmh5pIVU3UnYQGW8lMqNpJJ/1E6c4qZYZmaHhGzjpa9k5RgKeZBmeo12oMQA3p2+XzDqh+2izf3XufNJkpVaa4EtOmz8F0uB6ginzqtKT649EtQ9pArD5gBJ1RmQmPBXAQsDyai9Pd6ZsKKWP8aLxwadOGLs3D3trk4PzKVJWlDnKhtDwY+qIHaTTtYW8Cq16Imn51y/bRQtcJGSfvQJFMnZmVfquNbxs5HUz8ZurmDPdc+YwQg6r+wJ/WLDrr1RANfcqjNlJklWVObqHtfAYJUOfMQYNptcxGrHku6NA1JVNpyPxvTjWZ/cWnKMu/b/pGwzYKcs2oN1NQh0RySSjGmVk0EyQKEjJKmYP6UA8fKhIr3QhxEBx29zDrKHDib6LOlG7iUIkZWDMxUxR5aq/JXAZenpSMzrXhE9BYp2f6bmyYUKgGwyBICeJCgW7tM2aiqbVKyPhRuawBzQv1/7Swyu9fwLp5AOR2sNO35H/CXO5qYFOEXnEiaEG1KAThJsCUnO+ITCd3dg+TrZO/nGghar5q8TskkY5a3TcII9rUMP6zt/P/wP9aX+Tm1PdUBBR0WKgbs3tHMe1EqFbkTCZqPCY1IX0fqzrG7rOH4Z0GshICg6k6U3uboTrDKOK5rM8uGg/lEvkUWBvqdgfWEfpP9d6nAxuEgA0YsIEObGAD4xhj47M+0m/PI91hS9z/4c8/v/vxQ37x9f5fr7bu3RCuAV8S8BQdMY8e6ewmHUuw4RC8TaGxkf6HIVp8hDwU/K+bZo0a1xuBaOxWUTAo0eNSS76kNUfQb9jitsZpOTnK5mBBdqZFffYpG5L75XYxmaRQfaNYlEPwvWX/VvlAMCKon2I3Ka6mcI38NBmPULwHK6UDLQzFktwZRzm16eq/H9EhjR8FJfBvtPYXXB6/06DSiULdHlO9JUud0/Vjb+ENrEKLadI/0e+ztGQ1Q+gS0WZnpiy+Yn9uJ3rvZ+uil37ewXHpN3EgPXvsLu8ERBU6RMeReI0bCpMhOJqCawz4VoZD1A72FodDMRdL11BvjZAotq7JKHZFmAWcS5mMVOg7Bc7qyEWBF2wXRBaD995MogWushyL4FvK/qbtFEwO2QJtd9XfteO3zR5kRMYlfCdrY0kuY9/QKLyPa4gjrS2Bz5K/2SLwrUfEvfXKq7da+kOIU4NCgp6Mj49VTrf5RVlcQfQeEAZSGSWnWZIms6IiuLjM2AxaDslhTk2v94inJqsgSjJKHnMsXedAcxTc101E+V30oj5z7Qk+8FMuyYy8f2WWVpR5sMNVVQ7VP9DRtmm/rh5pbGK/rlY0BKS1t7uPnh/103JCdYhJPuWUjnymFJC3fq6DnH4KQ7beBDnorbcvakCnl1mZnmch8Dc2zrbNnex9ltz0YFVR7Qc0Q2B2PMsf0DbBpjXBCur1IuJNWA74JDTikxWH/MY1ZGjEJ6uO+K1rxMehIR+vOuR3ziFDIy474A0Kob1yBD3R2oMUissySUsgFVcoHOqBoRmhT48hIir5MxJ/TmMnSBdxjLS2Xm0d7lEjZxvpU/eJoo4SpNlWUg4ALOPFVNlImdZF9+WFquvU0S9OqNFZmWdEbPIAYgqOWtgR5vU8bZxY9xE1jERu0hwP6+SqsbhlGWI6Qd/533plNhun5BxtfX30bP/o4PDt1qs3z75udT1T6tTDefnTzu4OQAhhKALO/tbeMxcYHYcRgN7s7x67AC0g9jsGABRC2j3ePdj/mpbxBYpE9NrZOt46PnlN10Cke0SP48PdFy+eHcq5LoH8/YOfoLtgXYiBOBb9yb4SIHARTVm/jkPryFcHR5lM7eXAv5coZ0OgHmNvMWNgVwJ0UWWjJJ0mmayuSW0VWW/C/GtsXwXtXlRcafdFCB9heRWeQhxTWl57r8PkAgkPhdW8mFl2f/rCu6Gb54uZ/RtrSP90NIY/8M2XtnPffCUI1baY+ZoKqHzNe1l5njE96DCdnmeNV4wAHDnWrn22sODobOLDBmCtQUuOoS2AlQE5zNLRwXR87fN7TGmwTfLvfyf32E/FFOujtNaFDJZ6VaQjApKlBXZD9DT2w3tdFuf+pxp3W3x1cANzGGrcoPQUGi7Hc9obtmt1XOwX8/zs2u2ELo2CWluI28lpzNMQLAjnEKb2Uz46V3U55QzNfiB3+J6EGc/KYkgmvCtQStvlw1RWzezUxvLr8WwmxvU8Kx/0xo5csgY0DeVBWIEE+GZ2l/o5as3ds9Qh1szTm1xGWOGpFL0812+3yiLM9o+ZdJ09ZaKemkFzfzE5zcrefrpvDrQnr0BNBxI9YweSt7jGA/GeNQNJ/5Gz/PxlWm1fgMRVzvEU3vDsfPtCY+zqaDEDuzvNuGe4CoIB4DCDar4MqsOZkE1d+4D8F0rUud2xPhNhMMxEyuVNhzkU0oPS93DGPq+KYTpm0LRVgYZkvcCfldk/F9mUBr9qX1TaYeUuI4Q18CS4F2jGAGOl5pcZW+VO4fwa+FRDDLO5gxrWJOVx4/g2G/+6DUJyrEt0z3LJqkZjJsaZUHy6qJxgYxoBF7+gFjc27w2NHID0bMT0I+3c8DWzHW+VIH+epRB365iELuwhkwM5h5yYhiU9Z45F7o8Mj87PZ+D08yq/zGCicAEkqsfE1ExoI0UGXzNAWwiM+C6tjxqfw0YCfZbM5Wk68sGY5FOOUpH3hXVelK6feRo282fqE5Nd7blh8a/bbpCirxuyJtLJR13sJQ4pGW7EZba3kUe7ckg+r7az4eQ5qoGCrsifsnAremWozKVr2or5sRLqaIV+vLga7XMPIMOFR1xGp+ZnOIQ8ZUJUA0v62q5rVKXTn6ZEWDTkIiO/WkC0VGW70FfZCZ0JUmhTt2rILTmgntNWKFUKN9b0GGbAtALYbunxJ4znwTRMv7LZ0PVo8SSIWu/o1/fccqQ9BopXPGhNDjANAv10//6mFZiiq5TuqfApcwdCNBnxkPs4QXfbf31lTbo3W1QXbXvCNig2+47x6kIoRlttkxus+7qoAUG3CN5NvLhwDLkfbkJ0sCnQ8zwFbVpz1gaPHtFenRhYf0MyF8sffvhKHW9GzZepvz+ZC8QDrmd14u3KXBrTY/nK7Itg84Xhhy9zWWiw9awKPUngRbEXqzUuCr+5mYtCg61nUfy9zd5x6oFsjUuz3+zs3WYMvK79hh78NBdMp9rlFFHuphYwh3rmB+dobN7/6idmtdJvdvye8WGn+KkoP7bT8tzpVm1r7XplrGKcMbPovXv3ksliPM+JHoxMRgn0T9L5PJvM5sqHHusEN/qoHsU6MKxvuCQdzy+KxfkFbpBX5Ge42FzTthCCGJhV+PailDhsIdaUJ3BJE7gGzY/6o0BmE2pBJljvUSOi8byRzAv0vZgZn9ujbDxPnzAjtGgDRXQEOHjWeZ5/Ivf1b/TnEq7t+cxw/Y7/joRu2kxdpBoXbtSW43flzB2m97p7mnbjV63oVWmvKLNYS71NB8ocEwLCaY73W+NBG5xkabVgaS98EwR88PuHFk1zK/eZsbCz7+p6Mo/woTqV/iu5bdFgH/Gpj76BsDjmxdDFbgzbBCEl2x//KNEiEyeFTYniTqDN3ITxoN60aej0ChxT7g2IjhyIczQu2G5ptPOUXqfeHG+3NQ+nOTy3S96mlQPhbVqyuGkY1umttGTTgbFN9ok5B+WdgXPsOxilGVjdf8IHmuO54YylyRODZXh7zBmLoEzy5GOdEfWbU2j/YjF6lZZwkX5E5k+mWFFLxHkBX07T4UdwF4Pf2ZM19H0Mf2NzISLTNxdwXRW5NVrd5GxRzi/IkVHlk5yoDgmNhq+Sq2JKHZmo/ITjQ7uSCdjarYyFdTGckEvjbSNltJiNwQaYIexIXHz+1atbNZcyzhJqUgEw+FwKFqM8XCre+/X27zbe93THXlV4ztU8MCRkQbJhxZz05GgxDnrPAX9q/s6Pdnqy07p43qPcJ6T1BxEuppX0MhOyUumfV/Pacy2/JJig9sE5UZ8mFXbDwvYaAIbTTWmN5gXRO9RjzYb6ys0QDAqftdb6cd3jj2GDwX3vi8XB5NAF4ENZXHHrg2WY8Rvb3KAoeq3zQ1ppHjxw7ghuZ7IRMRVPmcZpwjEL2LG/vpsqhhX9PevQsTV1b1hq69K3nu+Ug6TELO3CFEUA+I+v2PbiTPK3v3EIE/yU8kHeIegtR1yDIBcvfbDnDhR5VrX1NWGvTr/rgPUVew5IoTbRyafVjuAUt4Z4nLi6QuZcnehI4glXRN7nnQlTtcQUNVspZhC4tRdo9tkMLIZ0iF2Lm9s1SSydH52LLGYRayxm5hJvzIh809nEIk/XBCk5y8135u3avBX4jebB8/8RvtwiZWAoX6TayifPiVyAQuRgJU8WzxS9JzF9LuXWC3tPOSB1NjU7f5Wpu0A+7/k4i6VShzWJG4zZmF6CAxCMJyqNI2XWGDSfDrx6ET3KtYauqztey3082Y6ePUC9h+F/xs+BC9Guq3vsHNTjG/5nAzywDl1X94g5rOK6s5rzjs99h+kV+9kVLOTpuBh+bLM3FwdHOX8MbzMiw7oJwSsYjWpOL/rSxXlco7B6CBF1PaCRdphIzPA+74ZCt7dPCctEaF1lXW/GddA33SDUszL8IkSVuqG0XAK5RvQxldYw/xHp1+os43xg2kNR1SVpyxVuIG73N/lZt7UuqFPKc/gIXWWr4+JIsaaRrIPb2PLqYMrs08YTnOaRokMUiLShVdRiBz4hz+VCDGiabB7Dz17bHxBH4UMKF2TqY6tiUCDq9uD585bmV++coQbXNz1u0/JOjmWmwIo4azfpVelldlw8J1x4gfKZOIyJhuMvTw5Dbm5D6gylHOIxU5Kmihw8k4wwKhr3txtXzhe/exAKVkN86GcmzRtMhx9mSK3aGHqsVR5NPu9U/hm9G6E+8m+QCHNR6T5XdEL+tsZWxNuqdgAae+H26/G5KDTZh9jNy5iBe0tEM72C/KO15x/xzWRsB5GXJXZPUCtyBiVHZCfWiF1p6Rfm2mL2Go1FFQOG0d5zqG0i/9nmUAnHI7S3rO04Gvd0LrGXjgc5fLZ9cLizu//iw8E+wYHn0/PnvnHSBdhbwDs9PM7Wm+ODo+Otw2N7HPTJMQ7H3u3KGDXr25Av7IDwvBDN+F9UwDnbi7VvifY7omPv+X0A9QSAwYfCpjcocWOapPkUme2UVmHdi3ymIU0RW/INLTQA0R+td6nV33rEb+gJLvhEt2m5DXkf8x6TgV26acB71FZBlcurHn4XdK70OVg6QASeQzc2fKGsN07Rvq6nTSQrnon3SSdi5NL1delBrbg+l0boezWU1sRUYw6RySGTJ1pv/ZEITEN9rBPOlB+1avND8v33ZqPvv48mJB2EiHgoBsiAkX+Q/5B/OauYhen4QEfGD0+SwaqYulnutVk0u/3nZtd1/Td7Zb2Nx8W7l8VajPxunhVrTZjwCAYxdHNhCTGs0GEzjtvAfGuP/7f6/H9rDgDSrqWrn466oHOtyKds0sdtlFxwth3YbYuZu2k1Bz/3Ec3aNkzH8KKZaS+wopwo+8wMXzhAXk2Qg+rXwOrHABtwYIMaYIM6YKEdPS3m2aOk+pjPZlThZYRM0jmDDVO4D3uUtANBV8obCFsrgOj1enwiUOjW945f6zrU+cpmPmiyPc7S6ZtZu1MT3+ndm74gT2OD547nJLMJrczk3Oo8rw38/ICJwXwKXomQD5ZczlsruzfUiWUotGBYm3V4hlsBTctgHNem50HJqVMQWYHC25d0lxAZLPzOGaZjQ1Jlwy6V5fR4GSUMs1dp5Vtr9GQ67uzK68ayQGGrsxkgvPWaNtB1JqY+0qaW1X3JY2pzbY91n+P9ze7f/B3O+Tizwntc5JyC73IN51T7PheLp9A7XcM5BSINtVchywfr5qvwfT54l/8Pfw4jF6KkOMP2pk2fR4vhViDt4ebvwnElIOEorKHqYhm5FDUiD6ZHjoc4nlHfTJ5f8xoXjA/ABp1VZgYHy5DDMebnvUHX3aHrbtG1Qb/RCArHigejxYPYdZ+mjzUTxwpj33y1HLGUN0tzdxYRpm9ah9SbRk1AtxJTX1a+EbUctfU9iUWiTZ120pef0upNlbnLInpwJgCNsEaPXgTC14PHT9T9wExpRi55FSu5Hobx5+T7DVq0fQMqqprOeOK453HHYC+pmZLr3DE2xMRyhHR5vD0QS3AqIGbnoanUOjtPLBdJ7WdP5xvlrWbdvr4gWhmyuCnJnDLCFmVuT9agfu0khdfJNXhVCYHacxPX+FpDYzCHqI3PhWpbveGp123Xu76eYoq99+m5WGq9DqjMZAkYQ2/r2B4MzTUZqL206Lla3O9qLNWdZesy0xe4O+sJ9ywgWtoX37OeaOKehHLf8fXXHXUcQFCCFhdaVTKxTaPCpscdwllFEzs4xDgCSU8frXamaQaszZNjWnk9yV9oNZ4XkB1z+NHnyh/OdeN/mjce57nH2pDCWJQ0xw6zXz9yBg8GzaD+d3gze4NiZXObBVP+EAl5z7l6V2YogG/q/xqiH3OLuQPdOFmp6vBD8l32TUd/C8ciQ3Myck1FOR2pbXR7CFCjfCFo0CfE/DKcKqxRu3uNeZbiUxwtnbQqkCHHMca6nzXF1Vkh1ZU6cgn/sVD4fLBLdHOa1yydzqma97rIyd9eZ6VayFFGzi+ai32JK3I6hAlAqDyhCFQVHNVF7t+z2EAEKAUOmabOvSq6wb6vY/8j/hJk5EfVSOv2cWSqjSihpkY+kIoIOv/EMZAxBVSvn9g8kR21rvp1GYVGnFJ6NA/Gjch01HtQF/dsXJBpqszUKKf0Q/RSZt6SUMiSg6ieHA3UM2k6kssZseTDc/PhX0axm4Y09/XHY9MeicP4CR30AU7MyhElWxjhjw0GH7hseuGhb1xTMMLpgruAbEHqdsD5iejAIBznBUtlQB/iOFjHa4qwKpr+bEnLjP8OWkd0OW6JSrLsTvDBS+mhna/ilgxqLSz5WjPhTKnhg+028K/NWE7Ktq/NFt/HhtcwnbZ+GTJqcCwr8EUWtXD6s4aCftmjpHaLsjXXG5FsgX8LosrFX+Sq6xYekqBOavMFrmKqC8UH8XGG6XgMOxPj6sYxLY1Rb3lqaKxRaH6sWPDYUB29GUmtvKox+1HtN+ucdDxOtLZ5I70YKxcLWg2FkGe+5wwE/f8ovczsV6WieYAL7VYGu3ku7rwKDJWEkRd2HIPD5opAid9L/ffYkBgXF4oQmTOeHV9cqG1LttkSKle3c1Ysbgf5+5s3XldqVey7qpmskcUnzmhB1z9oGP9QF8nAlzpwhEQEwhvGmhH9QJmJRuOeGUtz74k/ksEHcevIhKhiGyyIWsyC7iV3z6Xm8gE5hxnGnJtQcJcGQLAo4lzDaZG3CPZu9R9W9cOz7aFDoCMYugf24AFdmDoqhrWQLrwTgk8Uj8nI51WCRYNK88HlCUrwwWa12Szmze6ERJju6a1jo5TYKG8TG4WJjcQQeQgjpYmRMhIjphQtl0VKiENrdkAIaSsyUUV9cSoteZ2yhBJcHey3tNV6I6Z88VEdnx3VWPTW0WdfNLY1EKnFLmH1a1YSzherZfT2cghGiN9T1S3/lpRbt7cBK/f2IzP7DfYcvvKKxp2YGNzawjsoNk6olO7wuFBUnO2A0Cqzc3DcpLon8zwUyjPVkVj+Jqc+4ajtZDcU4Kkr9SFF8LZQzttiJFHOdY9oUD/oyj7tJ3vYHfi6Or7SA7r489U0kEokuyCwKctRzyzLu35VoRmODs6g3Q+eF2FHL+plfqbZvmVyHnznwNcUHRsIz112t3QGCuudEK7/FTbZwWr33NnJ4fq7F45nCeXvR0iqy/Q/N4JkVvJVi8vNMFes2jJ61JYB8D11eTriiA5lefQMAuGE8QEsj5L8fFqULHQHJZpgQsO0l7HcT8UCeRsb2IFW3FXejWB/pja3eAwjVISohBr98MTAiLPKwV6whKaz5sGet1Sos/rBnrf+p2ZKDYaV2FO30lROYoJq7PXYcGLCXOyFmvkto6MctNuvEeKgWMJrFtKz4JupcLTU1u9ZMuz2Xjz0qHw7IbMTxY1mb1LHkvmWTWZBOAUAGTZXbXreefEID3rIkD8fPNCNEqLg5RP3fMMLEh42eRdll7Nf4ivdioWfbNkn/Hatlce0O3BhpSeY0WplOnPMKO8V0RPFIaiUddy9xd0LG5eFF4lgV9rxPqSXbstPrc2YKlMKOvqBiVeifLza3X/GANFyeHU1xzZcTcxyXxusrN4+OaDNonrZpzlZcmWU3DNrBQqMVYtZVrbhoO8mrRbXJpzVUFr7B+S28WzrFasd2gpURgk0DdYYiknTritMDQr/aaNYziW8UavlVQZh1yjXMVtTq82VpGDXp7IJbztRt8m5B8Ro7WlBGLXVtHxIRLUPPsJGbEWLmkIUPnC+WhI1JSB84MJVHKLKLhiE5LUtGY2qvXSaws0eF7fkBf74iwA5AcuXi1PIoOp+FNEh9T5cLE5fGWllA6eAuzMcWOzl43SsGY3ZlY169LyZCm4n0wsBovxNmO9NOW5jtcA38fqzhWNI7jZ6t1fXPu2f+sVF/0aLFuEfNkMDPCMyspym4wYDmV3qBow78rlGYuCP/ROR3lBMvM2BRvbAmy6M7xLp95KRiUiKUaYdoeTfFa2+O8r8BaZcC6E9/YEA9DNMEs4Ucm94M5uBhK1AhoJV6eWbpy3zYeOCQCcT7ZH/f14Wk58nYwnGeHdgBS4gzD6zXR3lbH9hs/3FRrux30gbXRtka7hgGCmm0+wTEY10K8Dkfdvml/eODrodTJ94yKh7DzXVp+ZbC1X2LzRj1kVvGyYznBt+eP5KWqj0KYdrHjee4Y1NQX79Ka2oOCL3xYvPKQSBRBedJSSWgQNybyKcuE2oMMdLgNkvSnhSc/HHZuzOt1jQ2kI10tnmSzIrTeyPs3Lebh0T0UYNqhl9x5TFYUjfal7hK7ypPpnPlVGMJ1T50iqny5iBSNcy3Z2eFbDFYepo1jJ8F66sbw5f0W/4bbliMbkXRTXnijf51yydX+haP8SAyzDSbzs0o8AVEj9E/lxdXfWQAGKgVb9vNWsqXxP5bCyJHff72fyK6K7CQWOqQps0MyxvloyySzIE+WNOKJKNHiH7K+nqs7tS3Mzkk6homc+2RiNWrhoHpsw113/RmEwjJ/dY7PHvSKonWuuPyfSlnvTXAKNUeh7YbKcYnOPhBAvmAikfK28p5olXRs/GaFWrG9EtOy8dG9EPSXhi5rOuIFqXI6ArsR3Wp4jS+7/T4mrKbn8Vn/bPe69gDE29wc0kFnhDg6/BQYAXoEyrOSpC2Sa3xN0R3q+smQw7UIVmHSJMm4HT6izLXwZ63kIhTKJlBGphgm4ky2GySRgvYnTEEdaj0jm5q50u5pC66l1rd6f13nwog/bkDMH4FP8zcUqA1rzs2cIKw3BKLSaGWANR/HoS9F1i3p38UY78jQsyJL8mDhcSJAzYB3LjP8shFXo70KlXLU4rdt0lMvxv8UKgTqN2sKWuVZvy15wJ0wDVQuybVhC8XXDc51tqSjfjGnRPdzYMt8aOiu6W1q3HuT9HOM1jHCDCVJqjMgpyVErayU/Z6WsCpafz40il57jx87A4eCX3Yr8qnFvB5/31lT9XbCBNLD0RF5N8WlT5/Nrooj6gDnhT7bDNw+dO9xAbRoPvDR1zCjpYjlPAnc2vZ5kDAdypTb9cneUjR1OyFXLjeYBDBSsgU20cUpGcahLYCW9G/c/433EaXcABGdzxjG9wmkPhcjpfqQl6PPaEf1xxHp3r1zVJ7uQ/z5DHWnFuesGZBwDv8cSf//ff/05qGr1+tg9/mgcIZpsIv5DleOqUqNMevnpKPq3IWwp66NCF43MnEQIZE2jTF+S4T+4W3JGdq19MA6egLLKeQXCNK24zwspgHUU0Yo9CdFgc6o6mX+yjSSgQOyakRM7bpH7MKfWLUkwlIxl+Rzchzys6tjklukdgl/G3DqVitm3MS+Kqs8ZavN1+WPGro/Yg0q66AKlrLjio43YM8H7K0svvsHJ6dQ29QVTif8PaqI+6TSv2kjR7ogNUeYTo03eofnK0isVMFYt5u6356lhIcCuQUpvpJji7cHOFJlalqXWrMk7aZ/545oDuRTmKg4hWwVydOIo8qswhj1yY4CtWtE7iWjaPhbAVDD9LE9H2LB1etNvcVHQMNkjGoBpH0M3uaITzvaB3y45l72X72+of2OrULHs1kiF7QvJbeS9wY02BN9pLZd6UV45pybCSqMtYrcZ9C5o8ZTjOQ8241Ohkc+khly87WOWWzVP93/LNOWobPUmM7sGhzZmW+r/DQ5u4eZIY3Y2ht0ZEUb3Szqn1Pe7UXUXtK9gS11elI2APXqcpXwPkS9wdcYbXnsW7O81OYwK5Vmjp5zBf4NA02BLsgEQ6cj62m7cM2dApsJlLAONJ7Z2EFy3g6z+h581eJS8AZtAPfp01QRIwLNSFfP1w9GZ7+9nRkbe0htmbp6ZLHtGjrix7k+rcKp1Rc3aGYXpriV8soBrtCTzmPQe3T/KX3embSio1vLYCNHOaGcApjeJNHnqkKXNGhV/p1UJTLVSHELaYCZt7wba2uec+exqRFem14dS7CXtloZ4+djM6qz2GjDb3jdQPLbQiPsE3+1tvjl8eHO7+/Zmhv3s92cIGbpOltC4gGiZA66wCtHdU8pBa9wHJFhRx4DbVS44JExOElQtw2sqSk2I4Lx68zatFOs5/ZXbCNizjKiNDUXVgPIZYiHMoQUI6sspGybDMRtl0To5fPZDAd8G4cXI+n5rlEci4EGg0zT5ZPOg0KH0gK9qCv5m7mewd34ZGGzh8SIJWh9QnpzqtbFm627t3EPM4jBlEaZmuQYwutpwToni+OyXTAEDt0Jg+AOSGMOBJGfAr4UKlwfEKZE4KpFy26w4IlDGl5hDxjqpHIEhG0Tzybza/MvpTCwr1FtqwvhlPMuzxxPOqxRcQq1K5Yfm0IE9r0/Em1MzhNsOaf/XwYVKc/vKwpI6WD4lYmIiuv1TUr+qEJYR0OVTB/q6c76nVXLIO818Xd9CqHHYT5M0lkuAcouIiu2f7GRE9I+TRx54BVXg+LVakPlfTdFZdFPoxf0UrDw2+VXrPhfULfTYRbqpvdolWMydCkCy+ODsje+hllp9fzOHY2hBV0OxGBD/ktvOwBsYjUVamusrpqa5y6AzTGbhgHuW/Zq+LcT68VgJ+mFYZsy4eZgRpJYG6zVoDqlPS+X+zbPZIle/2r4VOU8nxi7pVe0oP1c+IRiEwGI+04awVmwPB7C+SPzOqrDY+Xa2OF2t4B0auCB3XMHrzgWtxg6aBUqp+OM+mcia859Z0tEMkF+yq3QnoPBZsUNGYn/EVUfm79uA7r3e1fKxPU0g0NvZ4nn+Qn5GzJ+qD/DsTswdZOv2MpDdmyGp+Pc56ILHOSzBcij4GlN7FfEKuJKNMmzQIlDI0bdVAmzjq55q6+hw3edqeRmTOPiUV2eAosT+G5lzEjNwUp2zv2gno8GCs4T59LH+SjIrhYkL+TUYfXctAHn97OzNKckWkdHHVy4mOXSKGxRh0w+sNx7mYs70Uxte/4VrwxopejOokVlNm4xQiol7DOyJRqX925CEFib5bHfKWrsR/Hyww9sQgo+ohMD+kSSbS0SO1X2Vnc3EKIa7pYNa2J+1gcKuRg80/4I80vxfdngycmCOaBcuwG5zLScxcTkJzOamdCz+L9cmcOyezFmqeLE3N42KmE5NNXZv0aqwXwXluJsNE9DBS3TzcE9BpCw/FWlb6ED/aYncM2+GJ2dWomTL7ZEUWoQPVNM46TlyIJTgu02l1Ro9/MgRhwDL/1HYS6mQthDqJIRThHxedTtZAp5NIOp1E0QnKtphkOvn8ZFLb8tLQFZBEYTv2ssMEiEt+eA7qJrLDc9ZGyg3tMlJ3DLDZWhzBBCdOrs5LTrGAW8irAMXy4NlmOB9fJzNKtsustemQ3GxCDqktPqx2enB14nbXwI8NxyLklxXPHZ9W1IRxfIpNJOfIOfoPHWYYFJOBqWkzpjhIT6u2iwN8VBWJiz2s3KEJK42S5zpnrW17BFfB0eMlq38dHIn+hUgmWiO5gmtRJ2lzqoAGEFgLPqTXpb1GreVkGdIcQ57l2rWcNFxLjO62/EHhOCfQERzWCrQ7WSWnsW7p2UitcBwQlkrhO0RsdeKKt2zjjg+SQcenUlhwrrBYUQBuUwFRSUrYHA4z4LSRrkSucES4TohontGvvpWayW/KNa4j2WIb77lt882FaNrWujbinAtNjiMQvznv6Ah1W8P0NpjeRu+oGwSsS2uYOIfRaRPgASvLzO0eOJ/nMPhMWs3n0jjU4y5twYxuGj9qyUwSybO7O26WRA0wP+J+HmZETcAkyFp5EvTO05K9bzH5BbnKWsmPyuxIPj4bZ/DXp9e7IzHiIyOaCneGRPUcqLm7qTzcL5KXx3uvOFSI1oF3+hlki7vKCSWrxfAiITOnzgwMMPJaqDOZWk4bIfMme1jbhuAqC6i7cK1mjo3qr2bNkFI/QSaTZ3zLge1ccK70RGCwevm0ysr504zIxsyaQFe0ounN6CTda4qYANE8oSKKmoCOh5p56I3t6Xy1iux3bjTHPlCiVuzA4+zT3L314Avec7Slw0ALv9ccsPN8Ps7M0SH3CsRPtmkQpZZjj0FUQcMSLa/LYkazJn0w2gBAAwnaJDFKd1hNkcNsVKZX7U6N6qFziHXW+Mz3RvsTb/sTrb0ulp0Xe95SOyVcpqObOtXAhZut8RhQqDADULZms/E1vvPvnh1m/1zkJUKzwl8+zcFjaBvxHZWJumOlT7b6YHRc3pb64iiD+/p7kwNin4U//ZSWkLHokUgbOxunQ5DI1P0hnyatP8lnO8cy7yd/grox04KJbxDwZDS6tt6f/EUxbYWI/bzLRrC1Mv+mp0UvM6JeFyrpEX/54mHUl2Qyr2id+KyE1KPQuSWSzWGI0mHXxypyHNbg4PSXbDjvEfCykHdHuarP0lx3Tj/MzsbQnkgBnrINmrzbeK9lvrrBOqxE9QFVRtpWWgKP1vKannXqtCdy/JPKF8l/uVa/cO/HHFVApQ3u0+QGmnGdf/ukfRMvJJTVeZlyeyZaNDB4S82giNLPJ22A16UjysUDixN5t5dNF0CWp9QDvFhU2c8Qjk7+PMG4UNZ0TK6jYTl4Np6ww6M3WYznOdnVT6/ftt9mkIjsmx5N6nKyXRTlyIQONyBa5AmLy1nvZ5r9A5Qd+PvjsOMJa3aCupwEugiTmSZ9ER52q4NZNkWBezc2rlAb6SeEU69B4HY3yUb5HNK3jrKzlGDlwyf112v1V2oTUP+80KannU9alL1927O/Yk+IE+YHQA/8GeIWl+MBb/uiTK83ax5vNzZrXlQ3fC+7G75n1o2QqZ+/jXgvHcZ30e0b/WfZXPvVKRZdpd3qWzhk+BOeVMytPunfuA4ifqT+y/zN8XoG0TWSpegJSK5X2RkBNaJ3C/npEZZE/C1M737t736td5eWKx0A+9kLhH3WAClDhg7pQrrDuUFdCFc3BOu0mM8LqArCoqF6++k+cr/j45jfRGaHQB4Kb3IsvWQqQGqNC1aesQWnuOptup9Tca0+v1P93hsZrmT+CCbfzZwSund56xMdVzXoaGGslGXIbq+yXSJhVat3pN97E9R1ABTjHiekawQJ5wBuUQWgIVZon9UwchVYhuBi50KubJRcBGBJRnYCu/BhRUgseho2RY/e+fY4J9oMRtf+fFykNnc1Yq9Yc5hnvGvHeFfR43nMYp6xrhxjXUSP5bOOeQa7cAyWDqmxom5E32mGwXNQ7x15+o4P3zxrOTlYHlxNuVd1XI1z81Ht4p3nL155jraPdW9CSmOCfASHNCMcv1O2W9tb+2+3jrRCfo3MPMJr3OdAKPzMPc6SHquBm+w/YieCq+TPiffVlvkRgA1yLG8bHoNDxFAX/qFO0FBzcelxGCCWWxD27YARrgzEGeaQ5ZaiuV7AKBeIfA1cdk/HRFFvrdFN2QUmm28J/m+3wLpFLuctGr+lhW+xiAzB1bptMSUygkwgZJD1X/fh/Yte1P12Rc7p6Wi0pDWBhXOkZQkBIX+noSAgP9AVVsqgCu9sZSoSSl4tZmiOG3WDcKdQEWP5w4BVGx73a+EVSVWtMWeMX2kiNFBW0VuiEphTVYYiJObqgNFgG2eVSJz5VrVyFmx0N9WT7BslTJRn0E+U5kJ4wHU4K+dgD5qVqqD1TFpxLcFoWFHtlidmyxOzpSaXkCRWLXSpor9uMx6Gogw/sRs/pBm1L/t+twPRM/rN2Hh9luMFAfgfe+0vOK22ogik7/XmRX8Noaick8AQSneWka6EbHNy/3Uk/G/tF1N8eqaX55e8Tkdr/+EW+jLJp74v6SfPF0gWjy7dLMlFFZnYgqcp5YXtCZgH6Oigfx0X5/2NtlZMUzRvd5SSx5eK2umFE+y8KrhOKE5Jp5CDC3+iKiQQwcjruqi5INmBkGhA2JPlU2ogKGSbEGRFlRAEoXdy0iAYLLO/9h7BbCbwR6/MqH293fp6f2vv2ddQ9EDl03Q33Hr74u3Wqze0sUBdsMPe1s+yg1hnuMPuvurAURvs8GZ/9xgaw1qNJLvyBY0nqD9PF+eZEUwpqkSIIMt/+few5kACoDyuI/ApICHMBwJewp5IR8OkT0tSfGY7f8B8i9IQimhP2myeTXqLKit58kMYZbOm+WVe5adjPce3bC2Lkb/NsytHF7N+BSsHR0sgZPPMUwRip0iuiwWoPePxdXKVTmlGgxHtQqfMmCP5Ucpgh+A1Ba4o+I1IqOpFfWCHtO0N3EC4b9ZazT91k+tuwq3julWcVzSpba5ZyikSeCT/EajdL+AXx3s6+govumQ3Xu+BIXBn9+j1q62T7ze6YkuBTO/4zfFoYK24tMLkLJ1mY70laL88ocRr+GoUpjb6kv1B1FfYhlqc5zmozen4OfkIV5ogBC57wHGE8jkvNSTzl43+McX6wYw/RBA0UhSB3oO0MUYUVJrbfMGQQNTBC//ayaoh+foCJp4PFcAerdgxRiNIAOjBCIm/nuI8ir9tlgIUHAel6JDKOoChB24+lbPondKT1sy9I5r2aEnP6qd8ftFuKU75kOrDtrT8/3XzcyvprjtFHSRXUXXFWEaPtstFhLalT4pkMzu2cbvSxDDe/65N76ziyAahJyCLbab7RSr/3BfEM4rWzejDB0Nj1dweTG5S8o76Jtisx9vpcdrkOCcKzTYUKOM+IHoKxlqoHCUNgFtPTgyn9IghR2OZEW2VRVE4G4HhkeV+h5kUJaAlHfcO5Zfe4bNXW8e7b58dHzw9OH6JgASdNuzBnI4fIRqaGon79PGp5CbLICUfJYi9F4CM9WkDFi/1hS4NzHfKd1DOymxITvcCeQSCDGSdZG3RVs9jVKByR6s7OlW9ZbGMGS2YYV5jQgs0FWi+PIp+qY5P4XIIrdzJNmhjLd2G94TJpoJp2WXATTnT3bGOvpYkUXgzXHHYuqxqX2g338RbJAzGdAeFo0x9euE+N0HCi7K4EuySjsKX6m30RlwN6s9FUWaOEHUxTssX67tHYIju6wRu8Xu9VXxhuvTdDefz3io0JueXiy30m+t60eDugMFHXSG0LfX7uUlglH0RFwpbHH7WewXGR/hmETlRsxh1/ai/gqm1bihoVDW8wQTBOK8vGlNvjUZ/L6aZfnWJHCf6wmRuo4h7k9bldq9P8LgNe48lpUFVYn5XFx6MsFXuPRria64/ZtvPcQvSudd1GSLH6xU8mC0qWhpiUWFliv3CHd39TGpowC6eJKNA7ju6XA71iel4qPegjV6xrKnsHw3vAjo8Z3jE578zIHTTy2Fn049W400I3yDZrcL19mKNIq6NgQAh3DxmRmx0z0tIBN/V34q+oPtQPRetbi6oY44Y9ljKxBCagcE4jiCTeAQFGS20Oo/RoEYQuW6owY4OFjWCPmvby3tvtPoG8jKokKgb8ig/z+fpmL8IrOeOPGLA3Ndj/vHuZnx3M17+Zsy5NhGc9hvckQ0hqXM+vzPvaJtrxVszhx11YRab7PdzV9bl0BdxW3aJxs96X+ZUDF+Vo2cZf5eNBum8ZSLei7hgita3/DQnhrl7nEN3VY6UVa6pAq81N1TRjGo3r4nQnx8Nyyyb8kzQ9sSbAv5Mt15tHXevf3evf1E3eQrCdenk4yFFs+lDoRS2Y1qtYM7uJLoXaPB6HwlNZ5Lf5pK9ysZZDltN77rNsIhG2pNrj4b14IFKiS44WoO5lE1CjOe5bddMSkVqO8/dmvtzjYhFF+EGmpm4556X6ewi4npbc79zOi8p0GSXw63TpRyJYmPiwnnOL5yUMN2k9QKg0DKIWQWUzZE/u1HSmV8vK9+10utdHvIvD3mYh3zMnV7mTf3M1+hprnzNyWlCbggjmZ5K/vCo3g89whN9Hb7o6/BGX90fHReiCvukI9OV1y8dmLedk//0zTyAhsd6nc96GJDhzV7nzx4GZni61/m61wDTveBDfvBhQMhD/sbtJ/87cE6v88sHsefxy4dPNZE7X7j5K7qLY1K8iFhJNnH5EbQselVqT+i/di0Vlf1evUPf3zNrguipbJif8up1WqYTcnxXXPfdWswLSJcGutp1W1cOQDZfp6STMpvDfGERbHH0I1o2b8R/+PxO8ZSnuA2OnqvxpreAHztlxy/cojaS9b7IJfic8FrVYP52Z20B/UHyZ7yKRb7zevd5CvSMADLUs/DsEDY1MvE4ep5GJPBxdKOoe1n+ujXOz0GXwCvuvSzK/FfggzH9/Lqoeq+ePT+OgPi2nDshvgWryhDBOz54HQbHqYo1RyD8K9rqVZFCifq96jwMRF1BTbMMjmaAIb6MaAa02BMQQbdqO2XqdDh8AU1oae8iTW33gkfXggZQr7c+hYAqJLpNuybSwcGINn+dlSdMnGu4p2Keng2KfWg7wH2Zz6imvdFl3KZdSQSBBnHcIQeRQIJkHzShO33j9OPMwkEc6vgRzDv+7EHeJwN5P5vIWwVpn24RaVx38KPNsf5ABH5xdgbuNewYq143PEUdvXun58YZALn3tsrz03b/+0E3GXz3XTehfyP/qYXlOlPgODrMRjVdfQdZfc+mJ9Lh7ouXxzEwlzyTeNXCw8UUtOamJHL0DpBo8C0RGoONDUmnb2ph+Uj0Ah4Najr7tY36visqDl6QzalUZ2hSwt9hZ+K6ukFO2qVti49f2Ai/GCNYopI00etzU63f8Fx1iAMuXVDF4rrFOcSNY5UTY4lUQsJ8WHc1o0nvE0pYdJxPyLqmlwT15EJ8XLyZ5p/gN8hhkRAtjJp57pM5/Tn5y4Zmm+QLYWWVJ7WuunX6hTuoUVCr/u2UKR3qiGiAYL+Z0gmZrXgpy6Vh3ZXLozNwRmrSFlT1ebfx3nmXxg1vO6TTFfoMA9szqYtRpI2iH0CJwAeTI5cWlYgoKMndp+2hJB4O/OEOGIimXX83oaWwlOXerpcWrjaL5u97tDGzoshsUIYrY73FxQVZidTN4PjAUwDtiBBdw+LNl/BmUfUgDRm3F+Z6phfHS54vbblRFN3uiYHfeMRK1B6N8iV4vvvzs50lXAj8lds9wsL0MhiRzhNynGXHxVF2TpN7tcE40GXGwi41E7FNjVMN9Zmze4my8E0HelbvMTpA4N+jbDxPj6083wTUYwaKUFwOBu/1aJ+U14h+EhC0fkf630/674GAGZy7pCf/Xf2mHIOHKS39/uzTMKN3qI4G93QBFhHzbYIujA0jPom5D8C9Sc75j3/kQw8c0xnAktDvjxOwf7G14FlMB+ZVSORkYw+QFNC0v6mlR4NPP+D7o3KkUMJ6iESzPxubvW1p9i5IvPZES5SusJ+rZXUT7Wf94QI/DI2ZEjCzXoIoa00HjneKcdO4Csb2zrdnKooQ7yJDqSbylhd2Kws6/uQZ752gbtvGctBRdRPnhIK/OSrs6BKVTTToZmKaDfxhIS6V4x2l7Xt9JU5Hf7e2o/qrgBD9nRaeyBJyydE9Kupmo9jErmURO5Jjc7jDF+rxcROMmwn1vTHVNd7YvqrPygzsyYyswCP69mtwMkk26EQnIKg9zOqTL0ZObnUdx3nxIUK0Tl95Ip67zC1zr4pyw3PT3OZWVKrP38XFXvWsAk1q+MSqWRiZx4Lf0cpcbmpWoUldzrGX181XS2mdANcWyFSFkU+U1VVOFQmNKPAZEvaraQ9TshX7j5SKwd5kGauTe4V684T/nZZZ+nETdx34uqafAl15NQBP3+Gi9Pa90bQ39lLkVRA32GHPvSw7rsu0l1DaBhsrR80+7LUf2J578CCG/ru07hetjlK1x+qac1MznZJoe/l4dLSYTFLqrWAUWdb5Gum+E3aqIPek5aWFdFzQt57azGow8bf7SVv8VXgitf4xhcJHUOPpvucAfG9WgpOAZb08n12YawWaM0WgnS428FCyNF/bC4M+ZN5Ti/33v5N7tRMzuMQLV4LdjF+KfvldvyPq7/CgiVC33rvdCVdWvFxKV43WYqNcv4dEHHxRY1Aa8rzQrqVzqYslnYZ11hf7sTc4ZtyHjV9yvgezNisohW90rnnzQ0pITXXPi2jM1DuNENZZ5T7s1jN1dkhGTl1vHD9167Bdy9w5u8TN3WgcO3djE1iTFb6bEdERWDukViV25yZKOns8UenlecBmL60+tn2RmaxzQn5M+BvJj62uYQl1CU7tVcWZTN5wbiOLdJ5acjn6qDfIL5F6oIFGoxxtmqwxK4Hjqcsh0VsSovbCapVXTpXQ8glkYqQxy94E1LHxwOQXmM+Oi219PvJxrmYZRKJOh+B2n2dX7dU9093MpGl/Ss18DoVYX+WX0uef+mafjQtw6pMPaMBv9E2tA2Uksm8cuiZ7rYOipsxc39Yhd82R7jt683oofy+KCSqUgPwrHW6x/PZwAZdRdZ90OFHpWBbg0+p6Oky89ENqp+CLdbzKfdbggaau+9xXvJoXsx25H8bMic08cWGK6Vh3ML9Iy9FVWma7I7P1lDaEHo64Mja0BEdbVYvTii2b3HWmBjSQGelVSmTkiaJZ7zmBjEQCh0i0HOpyx35tGXEBDMrIq2SxILrFdGRrJu53d84rUgb+Yppz2bi82btf3oM2OOoYB4YY0tS4br7SwdyjDfXeYgbUyDtyGblqXpTMJWj8yxAmpk+kC4HAPJwoF86JsJ0g1wSreUXDPWC7Am0x+Q6fbR8c7uzuv/hwsG8Jq/lE82b07P3N9UmIKDBkVvIxR3P6JN3IjabarbgDyX4xz89yVlDP4ZINW+y4IBvudUa+TOf6aw7bYCgKSlK/boq3c+35bKKLSxZ1NFN/WoFT7cXFROB9KZf03sLldtOQeTXOl5gEP6h7wopOwfQGRuvct60FPMQTUzE/G/Ta9ocOivEFogu3L2OecOO3IPt+f6z1/rNRqTTotSynoFuD97MrWPbTcYEu6uxPcCmjkQ3ih3nB/8mq1vN/nJFmCnNLxZrqIGDlS20bYZhTgZG/8UZqZFzAr5gavslt2CAIfmvV3zj7+kG2hgty0NIZuOU6uMh8YXWc0Lqt8xdu6/wF2zrrLpGGxfOX99aIN8veuJvjgl2bf9+48FzhGyOD38N/z8i4+aqpdSDOIOB/cFtGnP4edQ4Xw9B7n37JcSVcL7NJcZmpdvQ9TdUVUx+2CZtCVqtR+0iTvkvjTIQDVMvF6XiNNJZHqLf0n8+87T50jtwWbS8QpVBsjclWGF2DXpSNHDbukDMJama/ex5Z3mS1T9m+mxLLVl/jBsy0cw9j2x8dUTxmE2e0itkIh2CZ35xq55Okxf9FFSxk+yJq5VcPHybF6S8Py1ExHV8/nEmi7U3PJ/PeLxVNwnDy82TM0/uyDAz/coSFGolXtGTAIoscf4v4l5VFj9Y2h/9AC9TDqHWOblElda79182mPmiPdoDJViogmv5mOBVX7+ivclDhdSXWyjvpzsV8yqS3a470DHJMUtiRlpgku9c75hU1MVy1GM1KxYyoZM02SuGXj9k1/JSNqQgS0ABdVciDA7q5JQ3gHb4SmfDeBtzmn1zB8/rSki17aZifXDWbZXk6Lpqut4ZDFmjrZmqNoeeg55p5AyvXj2f5NB0f03uNdoNgYLJyAt+ly5jxnW9Ayu7oq5z6qFgQqbifTr2zvtRd80SCif3F5DQre/vpPkrMQ2ZfnCWX9G16QZiXTD0btcy0VVaGGq3flAJumWZpMe5luDez+rX0o4h9almvCd7FeDPR6h0IboIuXLpfqlAKUH4HdcjzGeQVmUMbjWVl6WrZGUM/iNxWZknb4ZgG5OjsTJMsCqq3VVa7Dt4Nl7zmyr88g8m8BLKtlt7MIJnqYWwYERNJzTmekwDFLrL08NVPZT5PjbSi8uMzwj8uE51jY23huuy64Oe7RZ4d+rzJcQbFm+M2+um1qDqsie1TsSXZwNoQKFQ0iJdugqsDu2aux4GLSG45mKUZasNBTvR8mOwXz3NI8ERDRvcxPQRflIghWB+ygHSWQancxbRKz8we7EeZA+Xhu/+b3Pufr//QfrD55McHv75/eN5N2kN6dLX++D+gmA/JCZeWUP97a86tWJstZ5XFgytUVZrxIa1dfCzyJxD2ZwW2tYSttI2sNu4KXoSQRRbByP/Tsfu7whVfQVoKI1XBB6MSuyOholXmecP79cT5VZRz/mbD/iYLOQ/0jzLHyu6OuVkKwCt0Jh8ojjd9GJ7qGHYlp7nldDPwHAiEI/xHNXlRUQILXPGbM+XMmNl6xe1ItO0aqEC5E8RV2dmL4qubFFhnkkIxjF/nVLX77Qxv3oirXqEZ05mqSXqKQXq2klwbZ86HsgPNRSiD1eidAPHeSIKAxLt+l5ODM1WXj84m6noiU82ePJETti0y9HVI6FbYTFB0Va9NR6e9RTUHgjue2cQUWvvF/Ci9zEa705/3XsnTpkXRhk4fl50IgcdN3/lgvq8zGNHsghyoa0D4bnPPbnVEBSskmGkzPHVcvd37hlHnnSTFe7kVOKhNC5AjMMAm1TE7zLnix37b9PRI8SFvTcip17vA0O0K4UQpogX90Ua9VIcZX6GX821CgGLiKM5gdmXDEZXuzWwGLvUVKGPghrn/5tUr6orJJ3TPVGztqVfyZafaS6cpPJZujUbkHGTT4GM5V24KX7Qpuknl6RIgYRiePkeCOnA04JPs+Ab7yjsBNwlOQEGEVFs+pHnnx2D1wObBFW2OOefUgpOQ+rdvEsJNQVfWg5TyznvUfH4sxwhXL0JzhHh6dB0KzY8ZBMbGFiq5CtR6bzA73NiOD9/ojqURqwWMadNvwxy7MPQShGI6XAgDQ11X1Dlj07vBh6al3PwfgvuUKMkfG6KBKMzs8rfEmiEfWWjJPA0YJiP85BaE4vWQ6cS4D/0t1AlSu+ZDoxf7MdTttBiPjE7wU6jLWYPDn6sj4qbFKO1rxFFF/7inW0WSH8W2ga9Q3rS/sdmQzSgKvTMUSB8KxZEMOSTjYLYSbOKDIWnA/tJsk571OC3gjyZdg0eIeDlWuoD//KOPpcIo9MjTKLCNas5G56OkOTo3aC0xui5WV5vFaVGMs3QamAZVcyRHN6N0GInLztzzvIsb6IHfLrW0LK5g212k0xG4m3B5R+1BjxKaOlvplPeTVlv91EN2BbbdyfdOq4Ei8lXdL/q/b4Lvufq7LLVZHx8fqrv3hw88D7brUaTF8ngk83w+zlqbASDb6Tw7L8prZUR3gwoDoSHe2+migsicklz0abKF6sILFRuRnGtTNrHQzGj+bprXLDkG52t2TSV/FszVKSmmolhQNyEwiFxLJtQYcpGNZ9The14k+YjMOD+7TrKUSJor9hiWaCuWU3NbSeVnbClVfRzWUmxD0WysOjakjSpMbmh2TpNms7O3VQttRbrjecWRivLjqTHPno1kCTmAadnGQrfq7cM5tvqFEK+MezWopw3DaMewVkW8Nq8mqEfz7CZkp5I9mE6rGd2uXGMje+GCbAaCroy3dxFIzSBEItXKJhKC4CWTZlwNEEq3rX744LaYxMsfE16I9qRVj2l75LhJyMWj14oDuiITWHOM4YO99GNWcemmTZplSBNXM2ACaRim7Zhs7VKbnLg4dCEOpriqoPWEAE5SATnF+Y2SYjhczK5p0AzYboCvyAldEciXeXYFKXbIHQ5AzKEwE/7ObMp8ArtofhOaxlbOGxZBV8Penwg7J9mnGfickuM/nyZ/iCXJymeYA6x7g+htrO1hgHDsEOs9IbA/5KPC6lsDgQrtilfZ2bxVC2HFLYDn0kBXGJO5CVH4s2QiW8hJ8AERJ9tYFFS9feINP/VEEO9kfcQ7CRPvuJi1agGsiXYnzWg3L2aCdCcRpDuJIN2Jl3QntaQ7CZOOPsitTjYOJqzrkyatYPcVCSYm0YBYV9akFKQAYeh3iyisl48g4ukzQAz2Aro6NQScEDlYm1YYwIoEkfNoQJELe14IVoAmrIFFFN7PRxX56BwgC3qAXp02GrAQgWQ1iGR3pxUBa0Va6fOKIRjpNiSqGmhDV0L0JacZvdFOQQUDHT2dJi+P914l2TgDT3fSkmyCNKlm2RCix8jaiNZFfWUhyU8FTYophTmDeiTJ7hk0IXflbDKbX3fxaOTHnLqoEw0qnSdlUcDBeQnK7tMMovRKuCKQLz93T4had0ZYoqKK18dsRvQ5uFVPUhVDDRxDoE/g73/PysJ1tUZIcnMiamBxIu7sYEfdzUFjRwgvhSh/kwJJC7xVshQ+Gb4u2htpgX0MCrc7vJlmhb9jQmvlwQYZVApslmcm3yaQuOHRgsTMik0gCeOhBeop+xCGVbjf3+L76M+mDcZirzfxHdS7XHwf/a0s2I+7vRAeP7gSqXSvmfNr0RFRJChA0JBwNljEhQCUgofngdcpOR1hlzK3UfCXmV9g75Pnmk+paul3wZ3R0ms425MZaMEfRKAhymKD06uoqnAiDScY6pBnF/23GqQDsTTf/g2eu2tbPn6SfPdXLX6ADyp7unrxpGFWzThWGUELIje6mtkvVSoYy9dURzZ+Z0JfjIpo1gsI9WWAbKCMytGAQsMjeMAiZZXtEtnHEr05U+hy/kMQDS6EcCtygOkO0R+Onh+3mc4hBjvK5nOCWDk2b8+8mPeZa6PBsqVMfq1DV3Vebadq+K1y/OZzqaYw/B7Vzs9OlytjK+qLpytbKkzHngDKyXivTbeesVHfCyct6Z9lSBfuB68ji4t/e7x3zjHeq1kgKATnBV0ydViJhmW7ueGZRYOxXm/0GAAHJZdcrQnHeeRrWDac8m3u93Gqtm0UBxV88qjxOxvoe3ufiFPeWJCLfIXpKInhFB5kU5c+hD0ipPs+xGiHTt86dOy4DwM3JgJMRL/fxFEwBgXwmXXjQ1PkCEE01sIIobm2s4cMdsQLF9f8MPggQuZBgeWZPjPqyGcLYMNNAre1tEfoYXg9+KiPFAgEUn0zVYhbVyCWUR8aKg83XwUVBxGvIY8fyZg2GdCRz7vhBqSL+3yvO7k1HVKkYLjNw1rf0jFHq6XlBo5qnCPE2cBAmtHAtfTOssKr+dhMRnVMIVV7ZNeczZ2oQzZSwGup7H2C1jxP8VWhcJLdIadMur/beK8ltyhsBztrQzWlm1nPIImfbmESUKtqYHgw2W4tN8Ztw3+IB84fjIn6s9u4gSjv62lYa1EZu1RzlbXrw4dWJ3AQoy5KgE6JnB10TC7R9gtiBhOqNtxt4yx83BJ5+CKbC4nYSLh2kzMahEVDzrGkTUXMqc2GaxDpapeLcZzaLb4iWacP64lFe5fP2qaTdiDNrsXU6Q1yLegyDx3qz+r47dh/CxRBLZEIbzx3hPSZfiD6c2uIZc0Yi/JU5/LHSv1IE/8ILueeoHRHQyZpx+8dZxTWTCfnTKMk/Ns8PTRnZOR+LKeimdHsGdmfb3liM3RSCkMqnpA0FS4/Gd2535yaMac1LNZITuLcZ8dr2mez25dItclmEAl1agEhZ0jWWyHnwhXWYhcUtcfGwIIuSA4avnOJz/kGlPTEmeNF3pObv+OLP3cytyECEFqcQgA788+ciiY3RjFvvuyfi3TcAEmdJRHERjNDHm4C6w5yhG9z+/jiN+CIRot1C1e04JB4pXE+gUXT7wNDIwuvHOPrU086chF8fBqof/7738mnnixdRL5oT3kNEfapHmHNKGdJ11sQ0a6ahyxyEr9n2q2efeLtug4hLOL5u8mG1LmEZ9utDdWXQ1EQ2KZNpL+44+KT4IxIdhQcSFvwjNDs5BnlJcEyClCj+oRqhx/ptsZpOTnizT3psljXpuHUKOsXjfndJsfpccEWQSN9TbAiAhqv770zGpjVdGjY/Z0+g/d4u+jFFMwspfdqwn8Rajv6JCUljFroiVMFCKgbLLhfpzw69R3PYnUDPG86gO/uC60G3ILRq8b5EAVN0W8ss1KrpV1U56uYstSdV0uAwFu0FhVLKNfSdoeeKtdgnsgS8y5w0lJC7uU4/t8awpMGoLooFuMREMeKmI/bNwLwOzSB994oem24pqDMPeQqP6KETR1clLCGHLpqYkadRuArykKos515bjnpiU82TZLisWy5umnOr5pRxjcMeF30HO4LV+KXjbyS1g8y7pyHiWF+EZHPaMrIWUIlDLL6o0S7LDdPwNtiFMg1Br39WQ3hK600A546mW4fMpw17A7n4Q43dT4eipP+U7Bn5HvkZrkRCDrfy5EH1zdxKHSkQ8F5TDWvJ3ts/UJFzcy9i7RCGGq3FGzk2redDi+yVsd63Cnehdq/N/PYU6ppxHkNv8C0D85kZhfnAwzPWYXLqPLMLPNC/cQz8hgFgM/JkQEpHq/R7/wBbma/1svWZqHYmXfms46zTjVk11XQarPsijfEKsy+EiLOs4vfGDc2A6Vq6AC+5wHgCNoAmBxScyAzMTUf3RNfWQbZ6qecnPvUKK6fBpwOQuDmLBnxRldSFPGKHLGbaEvTxDeFoDLUa6v7CIkT+YAYyR8ByeyBM/lopzOGxfJu7z6+5/Hw7PWz0krhOZf0UT81wgGvblLoc3aIm3tiejmbnoZ08MclAogQxWjlJlwIlEk/dy4ddPYhYCwTsQHdUUZkZLynIlludtbrp8kMdHZJD/GZ6iwj2hmSaI5wi5GecM+1LHko1S7LBMyT9RXvjIbvnR6jem/jJccCsWkUOxE9DLcWe2hH4XltRLuL5zXo1vi6jq0NdqSyfqA2ueznfJXjtlMokP5dJ/goiXw2rBnJx7vviJIxMArwQGqOYCcyOn7yM51KBMtyhvXrCfaczQdcExq+BcA039u+Fn6mXvY9l/23Rhdgz/I+h56gYeaMG2Esi8ky+eOQwUMyL75t1CSFo8xVY81w54DDRzRuj9jY5GLW/LFempGnhMinl+k4H0mBSlm5pTMqDMGTjWkjas49uIA27si3hqdjLqplmD1TGrr0DskvdTV03As9OXx4iA9YeeUantBAkknLkSTdvFYyO8m89jJp21OC18ibumlvTc8X47R8kS7OM2vy+OOXvIid/Byy5fCII2sZPP3El7yCo4LsDDcR1KcveQG0UII1d/rrFzBtozCALXR/noyfk+vV26ysWA7gB/1Aan2RVZ/DeQlVRFAiXzUC/dLbyS63i+nZ1tkZmSAtwNRKaKw7ZPSnFSvZm8tVPh4nKW1FY8FG2SVR3FmNzPNFSasXQHoDDfj2RTb8eCQqdLV2WYg/L9kFcWAiBgzyTZChCLQpnQbLxgJpWsBIQKZF2vO/pbLKcDcZAvzkzdHT5GGyn82vivKjPiM4fmDI83Fxmo5rZqvKMDCGoUJG/JRAHa5ekrwhM/3HP6b0tBumZZlDfWt2Ale95KiYQKYB8is5rljQW3qZ5mP456Pk652tk6+Tr/cO9o9fkj9Pnm0dfk0BQUXibvL1y4M3h/B9d//N8TPyl6Nn2wf7O6zJnJaN/Xrr7Yu3W6/ePOuzdurvWz/Lv+9v7dE/3+zvHpM/afczKJuZsNoZCav7LmENEKwBgjXgsAYc1oDDqjKCxxEGxrIsFAmNt/bg9ItGJ8IAQgBfP1/+13zxlHlFWVdYPTAS7DiQLL5k3crglFDviGxEba5WeQF20suU3Gy052X2z3UAZ/GOWhM5mnckowNoI6RPa/Ddw6rVhb/1N8Tf5E/fir98I/4ykK3FX/6y8XDCG8m/9Qfib38Rf/lWthJ/kW36CMCFBHAhAFwIABcCwIUAIFqTv3z1nmH6Gt68axDMC8vmv+q1Qq6hlMpQL6lI/RJPf+HXdCpPQNtCpwrcKrWM1ZEGKwKVd2DGJ5kom73To0TZwv6kWydY1SCy3KxqdZQmrBYh7EI3AcOuam1cSEU6vhyfqzTn3MYjq26Oxlj8xawPcuokAfgtzUJg5Iazi8D5YQ6IdIoFOYgD+U0ZBdKRs84Ls53TCwCq3AAZ5oj+XzsOvjeafNxTTIuzU9/EiA1qNQsBFOwTaNPubMaKIAuKLXn4ZqUP+MdZNb9tqegbyDG1Fq8pNWp1k9YP9D9P4L/0P4/Zf1t8/mfFdA67OWL6nqaobtg61ukZxSP7t6AYMhOhT0vCuskR7ZDsHbMft4sJmdBROq2SvSPx04JoCyXR0q7YDy/SMp0QNYL/KyvK8zxl/3iZjS8zyBDF/rk7maXDOfv7cXpRTPjvUEm8AoDJIfltyn8ss9MFUQvncmSiNo/SaSoFPTvoXhN9PAd1+vOcq77hXHy0Aayy0evzPwbiz29a2grgsf/zTN4xkmveW5fn7K5QwYz3iOaN/pV+Ev/ii6CXRv1IlNMnqmE2HVWOgiRm3RNVVaHAlT6qBenQZj/hyhSOYnM1icY9vWeCnqDVAq087bCn0QZXBvBv7Y1ORM++q2df66ku4h8m+dQsAYK/pmAx0+vx4u+QRITQbo82U0+qVjvqY9m3Cptk2TTUYaA6HGYjT0sQRnzFkHwaSz0hepLBRlfLXNxl77tdOuUAZsi6nkeA7y8Dnpty9lhxOmQ26e2oL72d3aPXr7ZOvvcR4NRVNgYl/fZ0OL7Ihx+nLPhj4Gsp02tuG9SLLWzjBzbwAtvYUP/xAZvj2X/nZ92jWUbVmD5ukurlEyu50fTfMaGFZIHfey+LMv8VksCMt8b5+fR1UfW2n+0fPztUToy03VsQQkPU6unB8fHBHn2J5ezRYhfGVtfCBWnTH/xV/acT1QTxoY7VDfZ/nU4IEf3/UkR4K/6gNnCopOfkDq9kLkvxqAqmBZpgL1hZq6eH24zaniNHONouVZW1w59I9BsjuqfhNxfDedS6CnpOG/25EEblj2FVNlddfMvzFA6WOa+sDuFkXOwctlNnOcDU5+GiZZNY8yiIr0FHFWCPFpNJGoLOlSW1ueLGKLNnn2bpdJSNahfgTG7mwsR68m27SBWTn+ykILrZbDGUlt4zIrSZOTlLzumBqKf4sgZy66hWM5zpy4ahxQewvZZditKkbmAhPdEs0RUhQGgmXZMrItemp+gaj3m+q+THpDUtplkreeTrSasYnZHb1nQ0RjW7xITyikE6zNLRwXR8HTmfXl6JHiFGIWz2z5gdnUDDVj2k9W1qBm+FLIIWrF2KEXh+2U7HYz8wVopSx3o99OClzW+tdVzkgpSK2dCcZMzSP/znIue5lQHEIpsOr3tQJiH0rOTZ7QAglv8YV/MBFUtXDoiOJH+Oou0aPLvoqYkveeULs7e86bciga2Pw/EMY8j6srhKJun0OhnBE3XF80emZyLV9oiAm6TjZFYQksaOHMG2XmOIl3ddQ9XyjWzpYRUFKcwv+K7vTlbqu/BHCUKelxz6Jf1WA9jrEWUGUCGf1gVvfdxtYjaGw7cYVtmLH7xlj9RgXcgDD++W8HFSlFnPp5NoI9eyndbaw3o6xDD7mSakRizYb8yCg1YD2Otnwf6aWbB/WyzYb8SCgzWyYL8RC/YjWLDfgAX7XhbUDW1hxtsjV/LJYsIgtWpB1ZOQ26FLUMDr4cUVxMBzFGWCqOPz6TW6ymij6QN5yjtobTB5jN6uyg6mmbeeFOmnGlKkn2JJAaDWSQo6tbjaJJ9WIkX6qZ4U6ScfKUjvGlJQY3ktKZRpPUwRWpkqIfR9SAC3YiGukTDaRKMuCDBjoAMw5cNkIl97vCRRQ9RSRjX1EAjBCtNJe9uoJRd74aiVY8m2u7STA9IaSSQnF0Me9phADxks07zEYcBrCcOaeYjCYYQJIh+R4ogxqJVkscQYrJ8Yg+bEwFItTIxBHDEGIWIMYogxiCEGPNCFSfFmms8T+rzWqgdUTwkAVEVAWk51tFcWV4VhOmfehgwPwsBJsfcQXt8XUCdhlA/TucGSxoC1tIVGHsrS/mG68ufUGKWNv47WyzzYavXkxRDXQWQMb2VSa8tdluD8kBa+DX5VkA8VoxHypn7FUMCq1Q/VY3ct8dHbdZj6Io4Byqy1oiFG3MHg4T1+hjEEA5A0CLYkf1YX6SzzEQjBrqUQaushEYYWppHuMVBLpNP1FJ30QVwDkU4bl5+kRMLFJ70H4WldYUl3Ww+RTsNFJr0OGZFEku4YUYRS7g+tRqDXRjE83RiqKW8TXrZxpMgYpp/sGUlD2T5IRwU1hpbYV6aenobTTLNKuy6TbhD4Okhqzzh+J6r5n5fpKFfFX/v+jWmMV09Zo4OPtCbcGtra3k1NiTtoSNxBqxnw9RN3sB7iDmKJO2hK3EEccQfNiBt1TZnHyWCKGiWB23/ohKXwfK3yd74OydulLj9ZOSQUZQFUqlgvEHrhVU3n0eJ4XiOI55EieN5E+AqXv/qLf0U9A2uJpwCugXZodhGk+5OwYrKp4oPTTz3S5wG5cPH69eT/JhkPmRznE3LHbs2zcQZ1kmmVuIw+t1e9P/kNoXTCMdZQ2tBvEmVwau2iwmFTo/RupR4XtqoqP5/aU7rXbuYY0wkRyvIQDfMTClMMH98OuPVspaBXTYGvfOl1ISLKaEVr7uW/Ups7hG4mM9rfJ1ascdwcZzXz8JsNzsF4LjfgWgFjucxGc8ag1RDu7XFG/xY4o/+ZOKMfxxn9SM7ox3CGoRryWFucUOJ3G5jy2QJOMLZcISf6d1fQidZiAS7bKaDO9O7XmoHauhDh5P2NiHZH+a9ZbNsDwuDlIdWXeLfv/xbRzRt64WlfF9vh6fZ8rWEx2iDV4hRPj0UyfxfXnGMqsjXGVT92Pg3QNSXqxjgzuhihRs4O0znZBka/nbT8GN03bmWsyyuaywt22fcbUU3hvtP/rqapKHRe125PqWUbve/CWzKG577tYoS9KNPrWLajjyS3O0ZcOJWjC6anH0mrh1SFwC0RVKWB+7UgC1DhUPTL38lvGMcExndKaqgwvhqo/TBUAPk3BfYkoyVBwiAHYZAArr+hYJKd2fkiwsBEq7swsLswsLswsGAY2Oe5+d/FmN3FmEGMmRmUgtKR3YWf3YWf/XeEn7VMjLe+yKiwzxME9zuNPbuLKrqLKrqLKrqLKvovjCoy7cwrxRXZwOrJyBIfgznS9zLjmOJtxReZQ3mSeRmtMLEsCA4iOWz7McRZMdLIBrZ+4txqxJE5VAxx9KAWC0ItcQKhLJ73lQjH/TPasBUPce2E0qYb5d8E8o8lqT4Fel3m5LLLaCVTWJ9mRCLCH3BP5CSFVNO0SQoqY5VU+WQ2zko104RcyD9WAUKrqUbQWzX2kh3Bq6O+9mgWwQTqTaVuo5I9rzBQzbNZHcEw6LVzgzbvOG83csMoiXIN1J5fZRkhxlVBH2iz4YL61kz0NVIq+4msZhBBZNXYS2QEr47I2pNnIyLDy1wzQsNTXvsPnVazEW6R3nwJcRLbJihbkfKu6mq+VdT1yuEeF5hLI+pDhwgOoHDjuYC/tzbiBONhuxFTMAQ1YgtruFvkEHtpSzNLAaDEetfENMb0GvGP0TeClczR4rnKdn1oxGCR4Q4G2qUraGuJcW6Rp5pGQzi5ybO4mhEbMYgzNqJ2hHimqI+TCHm4NGIFT6hSGP4tskCTECYn+R2xTKGhGtHdimsKQo6ndzjGKeCW1IjUZ86w0SD0WyT0KtGkYYxEx5QuqowZaxSOxump6UMZGKwR85ixpSG48awTjDOt8TWrsSYuTh9gObGo5R7XCGvnIOcyGmVdq7SFte/3O1x01F5ZFlF3FnuGEXxid/LyigN+Hb84/Qyb8ky9BquzTOStxjHG7TJNA3VVX9C6rjbWbJryR1ArtaE34o54LdTtX9qEQ2L1UN9It8snTbVRF7NEKKPuMZuyRL1K6hmnEXM0VExtd+JmR069auoa4baPnHgF1cURdfqpPVjz0yOkpTrgNzw9onVV5BMepvs+bRhFcA1mPaUZ5CYwowjLJ3yWj8dg066jKRoggpiotZeKGGId+XTX/AZ0U675keSjHRqREQ+xZmpqs29AVG0ZEURV4zSgrepUS2IEP5bSWkxFU4JHnuQGtmKPct9Qt0H8lZNrTLU1RrJCkyPc3TGOJeKPcG+4TDRr8LiZKI6gt6VI3d+AvlYmUHOOoT1rbRB+lpZzloWbergWSGWgkf9/qAv4908rmjl4+xqeEFDjWEGFQTXkgEEUB5wVxXwZDhjcCgcMVuYAKId8K1wwaMgFgyguGDTigkETLqCRblE8cEVj4mLpz+GulfpirjG0ZxF8GumXJi2FFU1Y2rqGrAxiHFFFLGI0SfeiMn1I2Y4SfrSagV8rcfeaZQDh09cSgTgI3CbrezDJp51V0n4EZhvNFXuONCAhuHG8sedJCxJwBYpLOPoqn2aerJQekPXMcAwpDcjtKquiga7hMQEtutkzAq93PxezTka0/ykcGQC0xo8p7jFBNA37MMU8IKAY4xg7jowXrrHfsOSrseyAwa6BdhjcGvlLW/yKTEGdFxMGMWACkiPGmH5kY7/JR8GrNfXgyPAIzlhTZkw/zGWzRQVmuYbsmD7oEfTyZMj0QqyjWEyWzFCU/cp5MsPA10i/W8uVGRormqL1t/eIjJk16RBiqLv2rJk14NdD4M+ROTM4YgydA9kzw7BrKR2bQTOYs2L1HJo14G+D1LeTRzM4YnNSD2JJPWhK6sjbN8snEiYwpO2o3b8CUD0pAVwVCW0NyptcYQwzsKWCcYYgYp6VAV2KwY0gOWvoJTSHU0demfgllqj9CKIOWnGA1kjU/vqI2m9C1EE8UfuxRO2HidqPI2q/AVEH6yLqYK1EHayPqINbIuoglqiDMFEHcUSNFL9rTWNaB3nFdJV14NfAAbeazDQ80hLpTGsArpTQNAh7pZSmdZBvk0v6t8Il/c/GJcukNq0BuHRyUyOZmsxoauYtneTTLpjXu0yh1Ye6zKscsPGEpffCKWtYlDCPNZY/0uhUHuMqfhxyE8EQmx5oqhqW/MiNNDH0j2q83rw4IsSbnpMe95NWj6YbkQPjr49o2Rog5MhmQQ45vEneskaB3mvKh6RmE32s0S75OJ9f65cPDiqIT8x6or2DxxTh3fJn1bh8Foq/HgzGB+BT7E28M/OG1xsR9Z4g+lDc/Kqh8iw6fk34io6JZ/jyzswb8W4EuXvi2kOh7MN6w66n8N+wgbGVrs+2DA/9FtWhaT4d+mylQ9swqqedXouAvnJlgC1UaJ+V0fhOot9J9DuJfifR7yT6OiQ6miUSuuFVHuCgc6c3iw4qetk4mj1UHwiFCumvamhcN65QA4wx3M+BN/04cmPvqt6/6ye/Y9dVA48riirmJbYUkq78XlZXpkvVlc9/6sp2luLKgZEQ3asVQGbeLvV15HoBWcw8HefDbnJajEf6cDQ58BOUMpj9XLGIq4oHdXlPd/GBDUC+sL/gTzAm+QB/CAQcq8PbgSs6JXLkJ+rEh3mgIz9ar2gGijIMdAlzG/VEgGYtT+dgokqIeAaw0WkqEeA1nQl8iVHxB4BA/lRtxWpPHdhReMfcTls6mJ1zn3vjV7WxnZQS0Kzl6bwmhFUNojNh4/gQVnnjKisjerLyxEjyfbmXzi969MWu3d/YSP6c8KYPRV2VpucrxeRw9UOW+Xyg9fc+92HLBFB4tbu0TcvfN2apu5VcZFLNr4n+zLr/qC+Z/ehesxKWYtG8tWPVUsK6lw3itc5tZuy4H/F+yy0YOhvLhZ/ci8UHQCVaOhbKzwv7/Bvl54AEvsbfbVWmWZkNyYWLHuCtjR57jfktqzedRdRc+fZvjqog/qorPKFeoCKKVXXF02UQ6HJR/krLTUwyuoCTHY1Bei/R597h7ouXx77OB2fAkLap5ODsEM6PPXrXA/yMigW5KO+n0/b+YnJKSL6f7nc8neiFp2GncK2iu6Imd0VN7oqa3BU1uStq8t9e1IQflndlTdZfReSLK5JyV9bkrqzJf0FZE3ktCvP2a9GsFQlsfeyNZ9gouRu9uFZJdUE0qCQ9m9PgFYjGG+aTdMzCuHuxQ0ewi8TRMjwjh6plHNnSwysKUphh8IW4UemRu+o3d9Vv7qrf3FW/+S+pfiMsZGe1Mc/uOGe9f0zgFG1fB2g5djIWExduRbvYzyoYlpt2Z0YostbDQZuzULCxz7i5elijH/IaqLV0PCPDenRIo288N2V8rV3UiolhDFieG1FzDZGLfsjrp+ZgbdQcRFFz0IiagwhqDhpQc1BLTWzdD1PyZfkrOZnFK8Ikm18Uo1Yk3DXQ0Zho3L1CWK/DE3cN4SYbbuEilQbBQSbjISaeNPThpQl9ijPo0WoCfM1EElNemlJsCbp/US/ZL3jmnuTqIpsmw4uC3OWSCxcAouOw14paatO51pOcNqujO4NVQ3zxkBbmAO1lbSXPUg/EepLTtgmkHyyLcTTcGKL/v8OM+nAnJR1Cc0DtwfsEuwycF1mVgHtclY/AvYz1YZ242xarYMZoVlDnQHCsKPnMwVWj9yojt4PkdJxOPwLo62KRjIrpnwgT8QxRo+wMcrxUi+FFkrK+veT/ufhGW6rXx081cfGLDsPt76e9qUbzyYoetR6It8Ensf62/wF84vMI1prU8InbW9h8Ro/lk4ikPw70xAO+BYZplgGIGhI51eGcYEyS03pVclluDc4Yso50VjYgH5wg+cI5gATItcYyB4CuGKAagLzaJfhWg5e9gywRt+yHtVLIsg/sStHKAaC3xAf9dfNB/3PwwTKRyX5YSwclYxuY5trucvKGt+ahfGhmrx7MkYQAIcJ3RJ/puJtFPh1ln7i7BviHkI5Pko0Od99AlwAVQqZ+fjbVA8t0D0IArPvnMoNvE9dACoX02HD9SP+0/ZEjfD6QzTWZX89cLtIcygpGZgEi4lEK5tPM572RuwQzA1fovZavvb11mZUpKEtCxQJbsF7ReQGxAAnhOLiWzbOS/KyHkoR8Jgzu07yGFOtJx26H54QGp/LC6SaeV9ShYPgwRxxnZH1yc7RCYFZgCQQlyBV0kTClZkyBwK/JQQdjL57TyNfzc5qI0YVP+WsUy/gFlvKFFy3qGccJzeQd3cWNQQhKMjuUFeBFMNxb942Md1+B0cQEYmhGJ8GfiLJEo6AeVAvtomhGIXrpxeDU08qCEtjj5AScjiCNbQ3SOWOmQ98uR4BW2ud4QjFE+P/Sy5Q1S6ppPpsRSNknqGfHstJeQ8mO07K4qsjss5RcROf5JKMEYy+n5JbDaQaJsuEOO0ynkNSWhyWA3AA5TrSJHA7t6lHy9dGz/aODw7dbr948+7qbfP1mf/cY/nz5087uDvyFOu+SP7cP9nd2j3cP9uEfx4e7L148O4S/7mwdbx2fvKZt9g9++rqXPPuUQlX45FHyeD7/gc6s/aef0nIKQzN4ZNNoA9/7U2fz8UPSupec8FkPwU0vGRfnFdy+yd17RG9w7G5e8gUPC3LlvyqskvMI9ZHyhbaHbL8BCaNgxsgYJ0Qv944y0Baj+JY2bfkgrMCwYg5RVVy5qkD70FjQKgMZXHW1goyUTBVNzD79SOhaZmdEybtO4Ml5kn4Ee0qZUU69otaWYZmRmwenLlHZobOuo8N4UTTdoS191GRw6uloQdEpyFVzctCW86OszDNvzOkoO0sX4/m2lYZCOo2Diz5Bjua9znTcB330I6huZFsQTtgaE2yNrl8V6Yimh7eSUqwekQOqh6l5z1Fu2wH+MM7OsylMpNVyhcS6Qzautz7l1a5Lw/8tIn3EXDG1omNpb9fjNbmftP2OuuRKzYQdgQ1wW8mD5OD581e7+89akvF3p/mcBW51CR8Q6LvW/QxzI/27gx1V1yhX5FB4QDi4wt6ejSMs1MT/C0MtPkc0RDG7Pi6O0/LcfkeT8uj3HEhwXqazi//cMALgUWPj32PnkDD/rLi71x9/sJK7P3W2/sw++ivtkTs3//8yN3/AMZgjo1gaGrfioN2KBdI50kr8jpYfVQOMKKMXjC/hKOYCnJwhwgJPNONiiiU5vKvD9QPeTaEduXPnY/ouANuLQhHkgqD4x/2Xv/p8YsVc/awF2PRwkOzs4SKuesfJaqk7rElLCmkQJbnolXA+RnGobB1kUwRzPZIXAbwV2Yngr8TuGJkx/M5eWx4Cd1OexfZ8CUuUMBpll/kQ+PrBaZGWo0RdHRuJa9d0m0hT1MmzF1SLaJFqdrGQPI+rlXPsL4E7b1i6hlbQkp10u8U8XJpm7qpDMw8VnZnXVphh1/Hw6l/RNi1/3yjl4KIo57x0Gku8xdPb0IuigQgG2Y0F9g2jgLd2rF8aG37LjHmU4o5KU58hi4+ym9Qc7bRh/ImO4Yawd5KkpGEr3D/qaf6iKKosuaIHOYPKhBeItCtyZ05OCScN0zE5yeeFjmc1mBvZ6jvGOOrlQLtmkPqPj7a7C2L7Tw1iu4sNk+Z5dsqZGW+8pnp9pIz5t7js68VlVo7TmevTrOA35Cd49N5r/rOdbSkmx9RfPZlvvhmI/+/4M06dnhu5kxSMjY1uQgGJ/+gdtVqFvlRTrBXWSvoaPtIR1UzJz5qR/5InENoj6jN1eNY/K/d+T4N5mQ5Z+eTnKRBPjBtlsBek/VF5MYVzZfMOYWlgOkTZvddk71SzidTSFuMRPVq57kRd4OjpSuPuCfKmhR45wkcIYg/vYNHesWHVNvKkAGZ7qcY1mTVqBXpHqRwpux8xBIhdLG0EVAh2AR8Vw9lVBqJwnA/z+fiav1vOCN9RyZjPf9QTATNwHu9h9lFLAMzbu7yEpXxx40wImZqEELxVK9Q/Bm0CkFDvMRtpwAVcNw7EV4wE2cOBBSRK3WhYNtx3lejcBlG5r/BuI+fMnOz3isbo6upzfHDuUkG5XP43jNpsBeA0XvypAd1IjHkecLvnH7X0mOde93p11vlygS5RANmFi8YlinV8eEsV11Yn9hQkrqlBHFN22DjIV640bMNbFk9zp6nGgB9Cl9PKYvb3oq3e4sKVnBpxzDWhVqB7ZKAy9S1Q/jbyROP4At1d/Sgkjy6p2ZAeQc0+anKat3eJaanhuZGja3o15UZ4W3LWUq2vVQ8tyslRgB1F4Y6mJFqUVGCRlemY0yfgKTKitdHcH/XerpIjpmLsxqqpINeECqtoWS9mHRDXx45BlJoje+JyjVYYrRYEVzSufaVwo9a8WkRYE5NdsqxhCvcQ1qcVAzUGvfx2Q24MYAUjivYY3hu4hZWfT7kYXGTS4s8AXj3NnIvHNm200kzUJgSXpdq+ornqOvkS09aGutxd6cABWEV6/Sde69aE3uWuiRZu8Y2RPzMnUJkW3xnNb5Qg/1xk2a9sBxu3SCktf7PLJETF1UUrfJo7DgzeMQKj2oOj2vGaSCLAPGKIfNFED7R0iRuYpV9DIyiGddCEDBHLlYkbWvWwYlMe0hnmFUtYAZ76wAsVfcqFx9pkshjP8wfgz1mxtvB23TP0Njy2T33DbXQtTuvtVOZwizA6RRb5MDZ/TgJ2CB3Mmja7Obkoe7i51X+Wpgkb/wJ2AP2iiYV92deHfNGg1vhzQLOl/FyH/QNPXhgbTAyeFDV5thYaAvCHJGkLMTOB0Axg3I7TNMSHC1uIeCOXoUj0D9iLeJMw874tY0TBSR3zKjDrZF40uaWY9yTAvAJ2gHlFE4t5ZV8f84oGkcx7Uof9OOY9ifX3XQ/znsQw74mfeU/qmffk92rzpEq8nYfwzsR5Z+K8M3Fqe+TOtvn7tW1ipwGR5A1irLrJJT8A2b/YKXPSFdezLlXr2benbB/zfyjmZT+AuIOCeexfINLlx3V4KfC7EgQlZY8glvfk64df7x3sH78kf5482zr8urUZuhVotYDkB14qaDOg0sYVG9oManUbmwG1I1yl6Pjg9Wbw0N1o6prRHzTwzaB/fJHOGd8hT/PrGcQtCk4FV/MWOdZoGrRRS4sOEnwk2lpA+AYIwrCJUCgNSofGGToETTE9spJoUNDGC0JSpEE9bGj6zg1D1Ghm9LQgYxEQBEuLSfLyl7iTBVETI/UghR+q1s0CiiVemM7mBQF1tKBiqVoPFQkY3DHS0PyC+n6YZRIDhul/3dmR7+zI67IjU88j04DM3JHuLMc+yzHdsrdtPuaCg8ZkleRgzcq1OpHC7qKpI/ZZqWdng+N8kh3N04lTiwN3tdeoRIx7pr0d3Kz3+vDZ9u7R7sH+h/2DV7t7u8d6qVEyF6jCY1T8vICUJtmrbHpOK7APvrtND9YvXkviuCKIor7H8tJCGmzc+aDWHDTU0XzOuNQ8ZHq/1Smj7cUan3/SNDliz+9jTxSVCW4VFAEs+iud+Z8q8fTPxtYxpo3rSZaDm2jp97S+rgQ5hrzyY1IKrQhMQtsK2rZqQa0Vi3Mxro1BOaYfg7KJiUHV14NBLNA9KV+xuF665JsJJeodIblKr0HTGOcTonZTBKoSZKCBZCkk8zpbjEXlNhFwinBt5G3C8/CUxsBNtFxNWl9XEQzjAPTl0GWHWp23NNExkh3ethWCEmXJosijMEVP+towyz/Z6WfZd1/hEPZVTzLLezgLg8gj3OM5hs7yGq8x2jKBq2WrDkwMTugdlfuQs+6anW+kUCasfCyyynZgwoN7vMVQC81TDPd0eYnpms7v8hFmB0u+cXrKX2S+fK/zVV9k3ip2SX6/jzHreIvBmECWc77r7p5lmqPsP+qh5vO807CKDDzu5bdyP7euaTXJwUVz6SveigIZlTuT59YWkJFC0NUwOSkgdyugMMWn4plI+CFkO1HJQKfsJW9I81+zsmCBadOzfJrPM/cKrMl71A6zmZ5E04ThUkQc92PdutI+W0xZMka35WLAADI7i2bFeDZdTHbn2URaa0/kL2wK2CJDB+0mF4tJOoXEmXAV7FLGTPNpVqocOtVilvmaa8MbyXI8s++5p/zEvZRN90r1FdKpiiEDNh1ujnEO1G5ZzVtdovwTZb5iKSN9wPuxYPsAsB8GthENbYOC2+jVAWwAUYDcqIXZBKiEisHWMobJEJtf3XQ8GyL597+Tttce+a+bToeZLPfTy/wcAgJu3Z1+Kcsn15r6LnseteIN0H9chsDBEj3psXTss/HFGQqHi7IqSq8tkgwrrJF6XlrW76lrDH3+3/9F/H/HypX7kqWVhpNO0rd3gr/0tt4cH+B+n+Crd830a92So97AN5ay7v4nWjengjJfjGlTbLbVa/AiSDFY2VeoiC2QK0YIXs36jrtZP3A569ehZg0FbRGkdaFm4ETNIIiagQM1gwBqBjVXsuPlrmStCHCN0OS4ch3HXLmO/Veu4/or13Htles3u94rBnr6JfpZonMyjBe1DtYlOYOCjR406VCXZyAEx5OqTTXQErahfq60bZpyEELM01i2sdAzzs7mD8v8/GIecLD1jrQqyp7WcZTVzEbf0zB3uTSlQB48ofnEpKxjFSBbtYBisLRboZOeg/+1KCZJupgXk3SeDxN6Eb/IyhyKuJwRtSiZkOtmcpkTTYqgYw5R0D/aSe3ERAJ57UQTK7Wd7OvLbodUSDdSdYWxLrSIp+zzSn0L2vIMqINyI0dvg7Fj9Hagx9KUA/iJ2LgcNx5BpkFpJu4x4J6NocDeVN8tzHh3o3ZDWPYp5OcHACX5TV9ELAR+lggVLQtdc9+heT4fZ1ZVlYZOyfRCZyeH092xYKB6R66Wt2OD6JC5CYjC8LhuwSfNd4u2dTlvcVT9nvNEfU6WPEn13LBejuSlj+hN1shTklf56TiryYFI7RO9l+WvMgHiq2fPNZezCc3EAew8KhYE4H46be8vJqdZ2dtP9zUzyIRWvI5qWs2zWWzbYcgi0x/8Vf2n4yuH1Df99l6UudP0dU5+D1qABmBMEf/pmF29tpyGZhpdKtgOdzLJMgC05JdeLgqSHFSiONPfyT9wSzLk/9/el3a3bSSLfs+vQJA7E2oi0SREUpRtOY/WYuuMFh+KSuzJ5PhAJCQhJgleANSSO36//VX1AvQKgIsd5d3EjkkC3dXdVdXVVdXV1e282RPUXN/EQTDVITQtELB6NwfxIcAsxnp1z1IdqzYbef1+MJIq52xMeNxCR3YDknr2JOfzvIDzo4XpneeGF1k60Eoxg7yzlWMGWYWSpEu0UEHtNXnV8t4s5FXzU4q4zKX2o6z5MLCFKJNyMLHypuRLGTc8icSLHxwy7ozPamj/Oc8cYgFu/JGpFydlGaf4PYF35ktOJ5XzS1HST0Rwm2AH+3eBczX2p5/Ilmdudl0Ft6DrqcrxxJZUaiLnkZqYU0dNCrJFwaJUggnxRmXXUn8BTIjglsCEb0mZDi8kTPjGJOl0CbaEfsKaWxLxCSUMdiKrWB0HZHXHaLLFx49VLXGd8EYK58SSpihOqlr8kdcPMLmw/4dcQPD179fo2f0Mf8D1GlwtqBDcjMXcIgAV18F7B5U/IcudQ5IEbRr3ljh4e/QyvlUDl0kNS8wyU4LM6Mg02mJ8EBgW1hdBVMHIGxMyTD6RDLAZF9lrERl5HQM2RPXdjo6KDjQyjAL3mQpqedSYG5Hg2zFk9KjJdS2YKvenPXHLvPfVXEV/xPU9ZHSGIyxf6aYeajcWjxOtOdNWNK+776fBTRTbOYBASOwAlmOhrOtV0EzH4Mz8mAbmy72hoMzIpu9EZLPSBmRnVngBspsVkO251rqrIbu5ErKbiyDbK0R2swDZTQ3ZTSuym8XI9ioge9u11l0N2d5KyPYWQfZ2IbK9AmR7GrI9K7I9oxvz1I8rnspl93qjG7tymBpPkuKqD3muAdp8Yf4TPGYWB9fwPw2AxeNf+9EUkzxjTfjV52/rvdcX5yeXg0NjhpLpeyKuqZOL7MtwL0NNgRldTsMHfFZjYYtAuA2Tk+9RsPJ320udt23ueuXnbQ8ATcrl78uduF3soHGZj5ORV+CMv87ulvnhJoTjbY64rxjVVi31wCqZB1w6u8mGFQ2w//e/p/RKrCxNK3t5EU3wqBpwIPQ5oZfL0rv2gI2Gt46fOP912uv/87A/OD49/K9N579ODt8cnh008etPvZPLQ/Lt8ux40DS99f7LCdJhve4cYix4Et4FmA8cT9IxeuRtT8KbW5ooIk8jAXwCkw3nUwJCKrwOh/4U77NJsIuKxfSF0/Cm68nAm/4xyXfT4ry7qSnlblqUbTctTbQrrR8lSIOiTlbWLQO1JlmiQF3hRjt1qAtG3rKpgFByhzkIKv8qicZQ1yF3Eo/9FKdPGjnXYZywM87ZWfAfHeh/8DwvR4Emzn00/T5FaKPYv58682kajrFVmOnIUsN0jpdLACyFYcQh2fa4hSLyXrdY17jnLasWwoXRRt2hno2KlcXtqiJ9pH940hsc/3Roz75KAVdgy1npjkgOawHZnNEZ/tLAjro5bysFXpK3lRYy5m1l9YvytmYKmkoHI51yYvxYiQagXlRVHeXgtmo7Vj/FqbDL9LcNtxDQQleuzJTLw9g8pceSSfpdeJHfxU7yG9Wdf+FhNtzyi9I0mshhcsVbXY+mva7Hos2ux9Ldrj8mvyxj8r9Sy2ao+CupbEUMZbWFI6b1vzLM2k4uTyTk8eQT7Ck/wWxF5Vc8zPzE/eWMCY++YiTb+6qRbDI8PCAd+uN/Ycz2ntORwnrYO5qP1LHH/FCtCpbOLJrn9flgcH6q+n/6K/h/MAXfNdhpQuQ2bfZceVG/2O+fn5w8xbg2jOBif/8UAW1M6echbZqTscb5nJ3yVeo1S+t5xnpeab1tY73t0notY71Wab22sV67tF7HWK9TWm/HWG+ntF7X1WOahQleLDCPaUEHS7olYKo5xUGkjIM70G791PFneH0wzf0JC0+czmewjtRBw73Hi9G4UoynQrZmEWjhsMYkAcitkbLICB0xS1KhgChQxXoGuSrLQfOiI8nDasi03duhgqqCUCaHGaYEs50mxcBFOYiHsEL7N4GIT4JOguU6iBA8jcNWft9pN/7GTOB7PG82m6cC7Aws0QHCEWZ/UcDWHZBbiTP0iYeB3813g+Zcgr7AGNHJs3WMo5sbQY0wkpWOsZCwtIiBtKyunbjZQvYkYhrfqzGNaTRznjFD7w+NaZTW6tV9bf0FfVm9mDhsR1RYZD6pxOrBCh6A8UP0kFLRQur86GgeqH65B6pv80D1yzxQfZMHSsuZLGoq5amcsbTDi7tVAFbB78+4gQFoG0XO/S0o/uRsAMoR4q+/iubkbRz4w1vReS4cttTyLIu9sCdcFkupmZclCJYUzIr+90cGHr7/K/Dwf2PgIb+T+K+wQwUVfwUd2hDzV8jh/7KQw+Uws1DAIlt9/riQRe4ZKDvwwbwDBfWXw1Zevzw8jPYiKepEtQvIiVHEfKGWUC8O0nayhL6Vj5ewGsYzJpn/pZAMzUpk8NyC+iuRobkOMlQNbLwgToFqdGgW0qFpoEOzgA7NMjp4leiw7RbUX4kO3jroUDXmERaYuCIZvEIyeAYyeAVk8MrIsF2JDC23oP5KZNheBxm2q0qlaB6nt9XosF1Ih20DHbYL6LBdRodWJTq03YL6K9GhtQ46tCqvDlWp0CqkQstAhVYBFVplVGhXokLHLai/EhXa66BCu+riED5UJUO7kAxtAxnaBWRol5GhU4kMO25B/ZXI0FkHGTqV1+i7YFqVEJ1CQnQMhOgUEKJTRoidSoTougX1VyLEzjoIsVM13jMgXrtKdNgppMOOgQ47BXTYMW5Sk+vKjqJ48i6OZmgnB4l23yC/uDQvoediCVNM/rvpRPdC3mqatZo+ErfPSKMf6W1BfC9z/9aPU3KJT41tnA7wtHRkrdi0VjyIRjdB/Ho8D6yVPWvli8DX04CIVbetVd9E45Gp2m103wcdOR4FI3L/hWGTmpY0nlFgmUn8R1t560Y1K1Sa0riR/7NhrW9KbEyqtxr5P4bqcYCn4ftzkroCWSiKcYb443o/e1M/On5/eKDXfRAOlqjRFDVDW4+9h5yh1ERCmPAlSzJlqNe01Wuadu2Fip6tomevSK15et22uPOvXuhpGuUoz7ItJADX826b6uapAWlNUzpuuZ4vXzaaobfk0tJiIM0lgKCMQc57PxnjeDOZk22wHyf48wLU72HQSxISS59J0DFuwQH3nYQJOpvOr34LhmkdhO35/ZQJNrL8JDVsjLXLK9Svo/jQH97WalMosuHsvcoS8+PFsPiwTva5kp9B6ay5pPMJkxfuRp7Gn/YDWRpb+QUr/lp/E6Tkgg/S8qYznY/HrH3ewLe1pJ6P7WNCPrJd4+jaOYM6Hy6CaRLFGxtZVW314zcDwL+sBVYgk0fS0iaJ6RLXPr35zeBYUoCUr7RERNKRJqXg3sXB4cPMn4JoLYVs1AHs8FaCs5xCoiK8uhOM7BbSipu4++qTrG2xM4niQN4DkNowKxhSEVHLkOsaVA11YTfrfdIqXomvPLcMyDr5qrkO+i3oPVuOgM1yAjZtBGyWEbBZiYBeJQJuu2VA1klAbx0EXMztthz9vHL6eTb6eWX08yrRb7sS/VpuGZB10m97HfRb0F+3HAG3ywm4bSPgdhkBt8sIqBgWxZTEc6JC0Bd+dSsDLqcuqbkAwGj2OIgGfnyjB5cVaiP6mKuFf38iO788dmYc+TSSPiFKU2IMh3N613hb5YicncYIFySRcx34ADPYdB6jOdjdj869P2XxOTSSgqKZZNO+Rx8kPiGxOlvDMVhqFP4D2OzBdG7kLGWIhSymlDXwmgpNYjrULgtt1W8ZC+Y6bIlpK5wxE8ATHwC6GRAg0XAFnbgQ4o+ODKCOpBNLHF+fBcGIqPrP1bJxMInugoOMthSdiipsZrQ1XaBgALbiXFr8iNK+P73zExYpZgwM0SAX8ZzlvJIOwyreqpxdMno4Vr3swwJ0LRRZNDRFoUrWaztlSsJTjEVtFCoMV7F5lwoptbbLfFR4q1JnsbuBXle9EUiGXkgSw+1ASm07EcpuCpKddKvfF6TCWw/2vZWx7xVg36uAfc+Kfa8U+2WadO7jLA/fIslBraJJhLQi5qVOVY3yvs566FyHD8EI4ylHEaowj86QpGWgEcr34XQU3eMxaNrM6EcDdfIeFNEnL6VTSIBgpZHkYC6i0kN5RgAaxuUWAyiny/tnmAY1KAO0io3zsEBKAnrNhWbVGCj2YM9FIBTQ6fRgy0Eg+/GLqEN99yW35RA41iWDg1gFrxzG6kTOBlTdi0eT51YyPyn0IlLREjqtWE0rsbJNlFJqNatQy3NLQKxMrebaqLWgz25RcjVLydW0kKtZQq5mFXJ5Vci17ZaAWJlc3trItZiHblFqeaXU8izU8kqoVaZOCJuDVQKfHVLSrQJsFeJJgFbUTeQRVqEh3SplN2OjL8Z3RsLRekzUMh6LTjxMSVZKaKEfRdQWiukkF2FY6S7v9xYRX9jdLbkOXrhu3a0CbBXiS4BWJL48wsrHfUaPU38SDtnpWJKkJwFlNBwHwsX0eAtBdIf8gcfTcodfJW4QOlbEDUIxnRtEGFZukHfwi7gh26+veBujWw5nReoJkFZhKHFglVhggvMbc5DQ6BHmx0V3IfXMomESjQMuAlKSK4XkOiTvI+e/5+Hw0/iR344YOP4kgjckNVoV7sh6XMQbWSGdM/L6Vr4QozOKuEKLySjmjjzKwq47G0CWM0oOOFkA7ipsYxp5JWfbPEmjSfg7SeRFvO8zIoubBkJrbZgJrhXTSa5DMpDeFGCzCPGblYnvudVBfhHiN9dL/OaKxPcqEL9ZjfjNcuI3qxC/qQVpfvPsmRNd/fYsHmHWz2ds8+gU945+S0gI537+6CLAiFIqQCrkGhr0MctwNJzjSf36MA6A6IfjAH/V3EFfynky6P/iRiRqChUP91cWwySVqJM2kQ3hrdCt+sXhu16/Nzjvf6TJZsVaBx+HPs+PZO3LgdyXrE49SR/HQT3PQ8c3FcTWQ0DA6zfZhoUNCMtwdYIXWe057vbswa1QvE/ieaXyGON1GxcM523fNpxhNL4A5oS6nrmAP5uBIrkPas+odhsrUHCgC2ERK1RCIWv+9Y2Gxb7UJRHwRnkxBjYL4UujizQ2ZCxwM8ZWzp4O5ySvdeEO8oykkMVhhMn+OEpy+BzOKJpYN1oHfSleWkDKcRpMXvtJIM01BAeKaDyybtzyt6LEyGoYRAR/py4L4qzGreRNB5G+6XCcyukLcOf5bQgmE/Yc524sZ2QVWsHtWSnZEa2BHy++mOz4/08KmMuDwZIGF5hJFEtPo3tYK9wlZzHurpPCfE9d3KHnszucToP47eD0BK+CHEbTdQuAXgXC9SS6ZTWkvrFnssygPWM3zAO+SAIkZu7mpVL/6pheciklxMvqR/OUpEQnCJ8G0qUJoFx8Ch5H0T32vybH9gJ1Y3Ju5oAm4s8jB0hdVq/G47s/K3CJRUrMUA0yKUPex5hVpgTEPC2GME/NAHord6G3cg9oyIu5sj9MwztyCYR59ES8k/sNa3pl8vJ4WliX9dtSGXttqI1L1Wh0iHTH2G88+1JzM0S6mwYCb1SrPk/12vO0tDJBYVaTobS0FuNOsUX2yDwXq4y5Zx5yORBh5D3zwM0ajgx+44voHUVIZBwoIpE9qlZVITl/VqrvqDghglK9B8Sq/ZDayu2y+VzLNB9SXzUI6uypqgCAah8lwcX8Cn+w9xmQ4zwPWhbxVb46W5dnaR2ztr6cFtBDPAQGLaDySqhAyJBAxImEzDXpJyus0dg5GgPXI1lF0zh6NJCqX6c68lk0CszKhFiCRdWJM6qvTAdaYimJZKu9kAQugFAuhHNxVrEjpWKxWnd6y/SmyuJgrFhZtNlrl0k3klCNdt5g2JjVQM3zxQGYZJwBBK+aK2cCt4MqiRwOksftxXF0f4DsaJA2XFie4UUywnkwE4zLWRGEd6BAhkDVAiiHRKPdKFKM1BoJDDtw1ZDcXFDmimoe30ve5qYwGq/qVJcAyUXlZeGzFRtoNgkdq9a8FgpsGknlzqlxvZKOu4J8XvvKUWV5FfXrJ7i2VHWe0JL8dntzSdaNEfVlI3Pk1hqXJhyCLk20+vwmmR8dl9yAJsEqdgkRWuDLmp9zJ7KyryyLAul64zFnwGCcBIUT0+ZM0g7em5xN/6Mrc+I8kx09Um/zYQnHoIWaMDrkAaMCkL3NWbPE/4RfaBU5G4DJVSWlhufd2MsAVHKV2pAKcwq/gpSNH8sQrHnLjeNK6CwtHZZ0lNfeezmRPYUNj9k3w0tVjGrOtI+0gNlvp7sC1WQE0EsfZflCnjhSYzVZJIIQrx9zyeEZ11643AdHS4t6hvv373Y77dYLt9xYJJWr2rtcHzP5O3Czmon4bCWtCjeN5sNbcsZcB04XYlIiSOrjYHqT3uKS3FQWds3fsmHirt+5L03lJf7mB6dp1bLIZNA8YyZNgVBL1WHUHqp9Iws9iZUUVZFCK0cGICkV8qsRr/hCGIkO1mJQ20icX9rJHhpT0OZznax0IhDjMKrSiO5FCY5R/Pko/wxTDmfA9uVGUUYVgLQHJeoRSdROnOL/+Q+v7QAo8fUgmklvCeTsLb3Jj1GNBe7UwtRIC8SAIDNqOCBtqPSagi2n2d7Ejjhtq1OC0lLxGC4uuapY/kJTgn9xZSlZrLQUcHmhBmzCiIhhoNpBAMpUMMKhgxFW0+SO6GtSxI1V3BUptmLzQ8xuMZZ7IHZVxrJJATBuz8nLp+1uJLGMfEWSVNt4U5KyPGs27dffILwCRFyEvwebTgQL3D5TrDbJeY8jfxKOH2WYjKKmVEWZ7Gk24D/Pqneo24gaWtQCBVuQYqfhtfhTKIawU59226q59F6fHErKS1aLaxP5ZQwuv9/ALSjPruaC0s3ZgwPlw5HzXbeBf1xBx36cYaKWHN+gZkMVmP3BdTgNRrIDQG1DqLYnwCjoFRZCguP+h+f8w+EM4DxztjdAVzjC0z215gbITVdWl8zjwy1LmuTfbRSXfri49UdEe3SdFmCE/4/YiW+u/Fpjk/ypN9obRZCUNY7+rOcec+0uc51vDFyc2XfEYBN5XlINcrNI4GmjYSTKK8kQJC2ZJJhms9Hea96Q4TjwY7zOI5qnYklFN9LH/jkXHHLT/lCLDCiTsRl4XN9ZX+RVwJcqfd502o3GhnwJHZ/4RbJWVIBGig6HYZk1oqsQ1QU+Xqo8M0SVHb3TXAGGUj/8kCOTajqZtWSs+Uv4qxynkCsywcSiCorOMAVwiU/dVFB3rWelZOWG6cBPBT8YiJA54khvBZ9eaHDRcRYwu+y0bTHsXUwyE7pMZPzRQ6a9wX9/oAPkURA/ZF38LLI6lOQEDJP3H86nVK8FzVWUB9+a1Ck1pokWfXBeaf0WtPS//x1095dFJX4wv/uZaNVQ/dHaAOr5pMDLggIW8DT/ZU4ELUPZ5yfF0WKStQLHksTufDJwbVyld7UEbdZwNmlzgqaCE6fJNTk8LeltTwaZoPHIHaa9ox2WcECcqKQifQ3stk4Bo23P6HicsVfSyvq0MYlvs25reztONqRquDKK9W9UWMTCpxaSnEqFWOfGBd8ocSTdLN8H0RQ0NuuSw4dhMEtrmYeVN0vVRLOiQd+JZhUrbTCqMu1TvTN9GTW1ygaICnfJfRAbmMLtEKb6VtQLn4Q2ZnSGiCuIzQBQmEnZb4uDa1ipbyXFg/gxaPwxNQvXL1oDap6WoEOUAqyGGHFfHHIvCgpeWWURZaQar9D/ivAhiW5LM6jEbdihyaoAkdajUeZvKdljQmROBBcD5mmWl22WZdUGxzjTxV0BDr3O9j3lRKoTxWN0I/Qn2YelLC2Z/Dq3KIJRlH6j6CxKkfuDp2YJrEFvQsmnD1AQAUafvrh+yWt+QtsNk3MgJooLeQG1LjGs2IucGVkBEz9qe4Mmf73JR1/MtCLOzAzMG14z/xIfRG883mc58TLuZf77Mt5yXjmNBVmrsawRjv/3gDr8qIgsxIWTUQqChQql2MvAmNGXvRa3cqSNjMzgI+5qxVWtCW00eBPh6ItaXtglwKLfXY/wj6GgHL5Byzbxj6GssM1BCg5bQfP62pWc64whizbUs2gFsx86X8DLfdJ0i72CD9vqjM5b41tczD18FY0e9V1f3etiJ+SSzkJNHCkRYgbHtxGkWIL2qkBZHdNTLaJ+Wu4AxluQ95zHwjq5opUv38Rpw/bk7W6ILa3RYRyNx6UuirwNej+zU+CLsLRR6qbIqUHH8YrlvaKRBKQbhW57hu7aA/SAgdgygNiwoRZbZqOTm2ZelKK2KdVqj9g0g7FlgmFp3LSbtsJsX/MMz6avIQCD9gnnmB4pgeyS+jdTekLVdV/IERQkGy2fZuhzIIPxMRdsfz7FWXo+hbUnjsKRsNeZweMQ4OMGVXIpCJOVQnPu+Ozd5cCVFHLrSSNhL1UUP+g0vgnebzr0y4cNc3r/AjyNrsaWWBXsbj5wKBfsY8HXyCPJ5UzoxsZSnazQuaIoGvIuP260saRA52CqeV9fKIUEn542yg21v4J6+rnCcoJM+jvetvIzna1QbsBnGWg9/wq5F4N26HdQ8Rum3oq65p7z+1/LwhNbFk799LY+8R/wYpo/boUQe7HsYrEejYXuarzcc9rZ7kJ7Qzu1J0R/mfIjxEFCDbaEp0fIn0iRIAmmXRg6Fz+9uQ38EQidhCw8Cdm8BjG86aRhOg70HajvXyZ3N47zMBlPkz33Nk1nz589u7+/r99v16P45pnXaDSeQRGXukD33O8BUwgcPr53nVuCSfUpZgt/HT3suQ2n4TS9roP/uK++1wIISKfIKqKHDoh7Uu5LUvKVi6xM6uCzZ+xhDjYbrwnI9y+hieTVy+twjInQw9GeCxaDg910nUf8F94Fb/x5koT+9PV4DmWmey7N8U+yYIRDFzAN1tpdSPw7e67nOs9evXxGQcIX0sL33IoS277B7FbT5DqKJ3su+TrGeLvGJqBmA1qW3idDfxzUmptbzQ03B6duveVEP4qiVE/zBBi6eUX/Bwq+cpV6sFAdw8o4wGaJKj98VCFgtyOMlUgRP/U264wO5CIe7oO9q9ef+XgbwZ47cbqO13JO4KPVgA/4zj/bHfiEH/yTPIcf/JNUgx/8s0ursQ/46zj/ch0gwXjP/a7VuL5uNZBMcfQp2HOvxjAv+c8txsPd7AGepAZrcs8loWvuM218owDmSlBxiM22Q/qIX06c5q7j7ZKfrW382Xba+BiekZHBQ/Ib/iHvcYS79Dep3moRYPCs2RUGiMNbfoDa+MjICIeTwYliAz6DSZhm7JFucmpvCmjhpTEedpNuRRFQVokjyDSzuOI11WltntOWedXZ3Org3EG5lPWPSo0bSWLIQzS1IXTYOGX02Z5jYaGG1L6x1qr1KWPPvH5OpBIQBibXByXTjUucEtlExCYCXoKzlIkmtL8GppWmrUdlS7OxnX9pNnbwm0e+/M6n3xiXu5vYfyQPAAN77jwe1767BkGNK4EANIOafzab2y6iBvQVWHsA4HPcjHjB5urzDPgLaTo/b80eXojz+bconD4n8/mFPMvZQ0PfQLAtPWYQOdfXwS4ZH8k88dDcc1swkkf49FqwgnrsN3xCzVw2fRds4x9VOnk26fSVW9hRWthZewtNj7bQbtIWAMm0CXyw1hZ2dpUW8MFaWyBYkZpYGU8SO+4g7223nA5bFLv4udOgz5uNhrO7zTmSbOHlLR8dYexu9ZaVqWQedUNhji8y6sVlBFnuV5UPIA02VCUSI31B970Jnra0PkUWIfpTk3zCv23P6TntBv6lf5r04YlDvpHCu/knKb7dwL9QFP4gRHj4L1fCei6M8ecW14Ib9ZZZvr4kqfgemJzac7e2G5xdmYpm0e+zVqNp+hzs/PEIeAFjr6H0Fmb/vX6xRIdeNb1tMJCgT7Lk/2r4Y6tGxriUi12B/6t0BbTfLir6qCLvePU2MFjeeMPaeByM5IYXbXctKPgSE/dLspnENKqA6Pv35H6qp67Lgb1IF4yd/AvTazoL6XLfLwHYNAEUrWaHLStsMSW/q68qsv7SkWGR30vCajJYrWy5Yx3DB0vC6jQUWJ3G0rBwbBIsfFAN1go0JDN4uQmsLvW7zm6TtNjKv+D/xE+AX1T2ufLwTyY/vutc458FO6Dx3W5T5TuRvrSNqnzHYeV8VxWWJl32o+l1eDOPn7r20WV6abPhOV2yhDS3kZ49WKGaREtttckC4nQ7zg7SeRtYjbxvQ1l828S38Ggb2Q6KQEFDdYCJoE+wFWxsRe3k+yc5ips4ePzimu1BeBOm/phllf4T+CJahDQUzfRLd5faBvC57OpVDrZIeVtG9nFFxdulikrbW1pRaTXsioqjEbw3vZmP/fgJGzPDMB6OA8cZAno6IDOHj/QTaNhqLELgEkCFPuJWoX8HoVCrnykE5AF87rZK4KKEr+JXIHwBn13WwHZXd1yspYGW0kCru6YGdrvyCHA9XOsIeAMtpYFVR2Dzmbc2Oy1tLyrGlO5BbWuHnHPF17lYQTF/Av+jRNny+K+ttipPqPwoECZegTB59orvY2lT/XAUpn8Ci6TVJYttN/9CjFp4A59L+Ja7O9RdtNOmJmlnx9nGVbrjOR18vruNliysuh7uIlGb1dtdwfIpG8C61451DFXsE8lTXdgjr7hHhlVmPH7qnNdpEFKdOC3Q4uje6w76NLYZHb0urv4nWG4bP3c9/M2QSeiLbtkGPoHq8HdZDvoiHZF5Lghaje3cWNptdr1GczGu00g8iP3kyW9ebW9T3MEs2W1xA5PMjDa+qCxdLGsCSP0mpjawLApNw6Kw1WqQhWBrmy4M7IM8XULYbe3S5WWXjjP7aOdrYBEwmLvZ8rEo5mQW6+KflcTaibq31fWYNc5UE6+ZNbpIO+LWn9gMV+J4M1yHW3Mz3Y7cTLexzma+GmOum9oVWXg9/mIah2RRky78u+CpyzEPI8WcHkbLcB98B/8y1xxxL+TvsHSTxQ/lX8gas7sjfCGviKsNvsnQoQyCpeoMtKG+bpE1aMkV7+mORuLy7XZ3e5RvlXzneZ3rYXdpPifdp73vtLEHbaedb+TsNKhs3WnIr9Bh1GmzTV6or8/FHfyT93LYwT+LWRCC2O8Q5wd0pZF/6TYkfKHbi0Wjwaf4Bmp3ibSQuxi08c8KXURExsGQeEw6O8RjgmYks+eaLR5q6YBY7br0rGkRJRfugFFonAXBKBg9ddHRpTOrwydP0yPT7XfH5jMtC7hpNuyIopP/ecHct3VH4eqj3uFOrqKqvyv0RLWUKjVbusaUMallOd7qtDbh/w2HuvIadZgwdfiZl/A6jU2v2ZaX5D+HnJTwtKIu8IVkpMJNS/hYvrCEXLGDq8rHFZtn5oN7EE2/x6w05GhVGjkJCMm6q4rOZOrPktvoz+Ca2iZ2NnzZ6QIVO/CH8aLndFvUYqefXbSNgCXrO21nu+61eQhGu0V48gQB4JcefUvK8TJdYlihPc+g4TyDL1KLOFcBBrH2iR9AegkVPOQ36JfXkV+RQSC/Lenc+v8IBRLL7zTwT77AtDr4Z0HBtU93GMgGQ5tuMLTbZIPB67jqJOvutoPdTkmLnQW9MCRhwpIzSQlC//JGTLMOpOjWiWTcqTdhNa5vU5J1d+vE5uzWkVs6dY+u1V0Ur/BuO3sIVm29y4t3GwCr08oeQ/VdXsHzOBBoqu1Q4ORxc+np8JQGoDmVr69z1mo0Wn7XW9DBJ54sEDjsNLoLBhFJ4f2k+YyvfyQiF+ahl61/sPxlR7G8VlUfG4fnNVR43ZXgtTsEHobu8PW5IwDc7SzuBET5RuLx4JPoHe1O9rmLn90u5bJ2h7qQ4bPtLWa9V0fv2jlzAVJ8ubZ3y8m2/sbXQeKvLCjw1O6fQ06sW1A0G2uWFM0vICl2O5SNdhn77HjZ5y6zWAgbwW/CRjve8pLijxQVFYjxBRv/g2XF0kT+arLi8GHmT0d/Er01O4YLnztMtvJPGqS64+Vfdjxmv2Rf2gz3/NNrCUd3UU53ltdIv3jPLN6eIuKef3rShB0KRpscFdYmRtvCAWYWSCx+rNG48hrXrhrvTLf4WxjCQbb2Ox4Nz9il7rddajrQPX9LwEYRDY78cByM/qJDR4jjazaagUyH1razu0uNrB1ieLXpb/RT0BN2u9w8a9Bz6PDU6zKzbJeeU/dYkAY7qM5q4JMunshZnHYH0TT95zS6/4t6AvWaVz4s6ULk7HZbPeJDULtI5OxuR42c/TGLm7XQJpxeR3/RJaPLQTS6CeLX43kgkqbd+AKkCctIsx+N/dmfxxmmrNzqurwujcAAd8HlvDcanfrxpyAWMEvyUi2IK5I62PLhukUB24TnGqpDleDlMRiPo/sX1hQfe+4I+h4HIynqvkUV9K3W8scDO9rxQMymESoZwVkmHuRb14rXp7YJQomRxVmTgKUmwakYv4RJi3QkV8y0IhssnUa+ypIvXbKbqbAqa4Mya2ZrtZidl9ta2EFuam17hl3uD4RnqnTe4HA/jP0kwLOe4+jm5qnSzhj0td3mQV+2Xep2Z9NryVvQuBHMMmB0ca+HqKQtsvOMOy0eOeLbwIe7DVZql4Sikh1kHrfapNvYLfxLzwR3SMYi1eSkV2kpFO52CYXRZOcB/AKFPU873JxTlqZCMADbbVQCdoULmwHaV8SPFp+gHW7QT65YUjgUxMABEwbpT2Fw/y6K0ycuj5r81GubRVTSBx71TZdix5iBhEPyFgMk8gHZ2yeGAP+kwdke20L1WAgKfHpdJuyyLzSoo8l8t8Ta6JoMh+WJL7PtTh0sn5062p4YNtLYqROLH/e3ms0Web7TreNxRo/tWpFXjW2y34VF8KAulCO/EFC3WadnhnFLrNOh+1gN+Og0EUJrF7+SDF9tZ6dDwXgAs4ubW/9yCsdK2R4GYFIQcEbH9Ji3JEs6w2F358owex0xmGOnjvvYddzb9sixZ7pn3Org4BvdOrP1DAc5usGos9vVO+kU9bLZMahfJX3sYNROz2nvortgq8X2wnedbsNdRjhYk7s5Uu6VbbR9e2Q7oelsNelm+i6eKFlnq8bDIwdk7v+lG/3pdCOaEvkJG2DlZkbLU80MmiHFbl8wlufLCmELYqs8sjMG9AwDwn1kpwxWhk/4S4KPpwzWA/+R95+fkaCHKj3W0Frgk/5L8En/V4Nvd6el9O+TZ8xs/4gqqdvC/lE3n7fNrnENEUMMWqvV320sVd9GgJPo5igcP8kzFoo4b8lZzbb5UZ2WFDNZFCbZnT0ouUW2FaDtjgS0IkzHfAA9S87XWgNQvphxoN3uGoCyjrYaMkpbjTWglAPlKGVAl0RpUwa621gD0F2lp83mOqAyoO2OjFPq4F0RpxwoxykDuhpOOdDuOoCyju548uh3vDWMngNty0CX62i7IwOlMQmrQuWnFrvy8LvdNQyfA+XEZ0BXIz4HuuOtAehOVwbabCzf1e+tmeXHsGJF8YSnlWc/TTnl8XIH6ZpvXvUjTamPV+DJV32P6TXZ/iRh11PB//T2h3f4NL8OhBbK7qgfPM4CctGb/JqMCZ53nX/olwk4z8BucF690mrx4wBgXP7DkPzfWo9dZ9BcqDF6+YC3WEs0kf2e4zLtIbu/RUMwQSK7QKNGa29ohYfsUjMorgCgvWGXnh2Ed9aq7CqF/IIa7N0Q9I84DGK3SjW87wYv6oER/0O4b+YGL0Lxx/h2PwqurRcv2IFHd0F8PSbIcP15GmUVTHcEZkBwUlkuBsybArUJjzLX5Fq/hL9umC4xVnFLp4eeFZ+ATFLlEl5nL7/bZRgHfhoc0msla+67/qHLWoSCbNgTsDfD6YCwF9gs5tev+d0gUglCdLxqBa/CZLd86NgV75aBWqwD7D48vTi52Y51mVwA6bxymsG2MPe1KuIl8Prba7wAg7xU75ShmJz5owswulNA5aZDCalc2pek/Ha+l0oBBEKxglngU8M95vShmO4fKDLgvDlSFPMR8HF6BKLuQ+DHNZWJt7AVPsCs2zVS6RSGe0uKNcVqm45XUJXUPMBtC1Mdx17nLczYxFjpub3SaTidp8Ei1Wi9iwBoOUrI4Big8ThMsqfPCH8A0KPwIRjVtgFoR50uAFqcKqwh+Dw7H1xkTCPRBiUixU2ODQChAyYgdOBMNMzmyW2N1VNWN1F2WLmcFkpm43CId3mYJY+zRWqL/GdaR5XrZVTxlI0OFnO5GeDxX37V746hCVvFVV54ZFrpb0PhegtyIZAAQl3tDVc0GYqb7iz+XKBbFLW4Lv2iadEvdpfTL7pLrvp9/x7FjZ+tZMaxFy39UgVh+TfRwaICSEWRKPOEKKL2Zerg+Cd3o6Q6W5043smafZVEYxAwbrWqTAvLNQhO39EIZr9dfSiGyi/qWjPYjBUk9r0Y9AaXFyfHZ4dvD4/fvB0sqRAVN51dC7bmIc1o9UF+qRbx3NfaX2QUrLUTSnS3vWjFPsP/AjW5PvleUyjX1KKiYdUsYC1TKZgmUZzgFYLLTcW8/uJzUau7nsmogY1Ns4YWw1JU/BawG7TWld5L3dpYul/UmHO96jU4M30oYSatollyQAdOiWK/lsmms0LV2WarWWG6aVWvongUxAYuOsaF6TV5WxWUP/x0Q8QRv9XZDFMutsQkzVs2z7KI3EK9/CwV6i88S/W6XI1ZdjpVZSi95fUsqzpcNhEb1Wt8hflkIFrF+WStWT6f9KrZfHKbGKWJt7c4wmbQEmuS0EbuXMKbR+OCLp0enxWwPrsauLh+PaVquRtOZ/PULSk8vA2Gn4KRaE8UlKa4GtHU37QNXHTdij0ijV1FD26lZrKIQ3LPPYmtRavUynEKw21Ua4W6fDjLrFs1y1szXGN8609vArzHWLrGWIYQB9dxADZ17jsrl312boSOSLwI3D3lv/F7Ae9dvOud5ayHhSWPmHs8HY7no8CZhNNwMp84d/54HiRu1c4iwAz6VVzQkdd9tzIKruKior2f3qw02aB+9cmGhfPJll94bC28xFwTO1RlruXNfMm5lrfyNeYatvYk5hp0ZGPNc8sHvdi/Cf4Mc+u09361haz3foGFDAovsJBB6WUWMqFHlRayrJkvupBlrXyVhQxaexoLWe/9uifXxH9YeeEqK1w079YLhPh0i3bHcpTMOJsCQnrj8IZYS0MoJe5RkuuGCQVfp1PmRr2ap2k0rbnsxfIMMJO2zfJ26qy70qgOH2ZRnOq9CMjzkk7QQuV9yBrRulBGnZm5JHqmBZfy4satCGBh69ZQeS1OKAPc9RivBsDUel3cEIVm2qu7tQwdynzFtZYdPl70/IWd2CbOqGhC26uW29CGuhWdwKu0Wmhyi4Dts2jg0w002xwc9F6fHLol9ZeagmJNawBGYS02a+0+HLUC92JhKNnfqlUpcxOp5a/ycImqVYTQFo39j9i7Bbhf7g06cvajMTnaTQNuyNdFql/g/W8weRcdUx7lk5/zrTAHpNXP2Ia02W3aj8zDZgpWXen4HnsuxNOMqeMV975tkUDMh3vqT8EOiQV3qDkoCLegv61ZK/0S/uqEhPzDILp2zjAU5IK83ZACixA+jSwogGSMLlIc0ONgyGZr0SDH1vFwn8lZNApUPwrqk+IzYrW8EBAROq/27L54EgmEcHmUg4gB3mZlNdehzVc3wVgFi83F31qMLP66zKpSG9HMKBnQ2uwmGezaDSUOfgHLqEQ1FhXTnPqSnCBNKoWYSVOVRYxwORyhnJVn1XoIrAx+JevlsxMAe5knQIUZBNJAnwhZb4RyjV+NCDQVbf4qyxc2p8VpsWHDGBM7VIaNFXFFQYQ4qdgrjPr6eOvHo3s/Do5HNcl4xS5KBqxY6ToOAdHjxzN/EtSkNYMF91UXP84rUQ7mwsgKQYxLtBYa+3p0ogyzT+cCC61JamZUqsvZVw5rvJyGD4NwEkCbk9kgSqhcAKVTWE1HzD4lUXX4T/1ysF9r7u40Nh342+TcPoJlLIVXPPAP7EMMc9rEGDcQSPj7b3np6qGTIuKWCJ80Vq8QQmmvVxJGaa9YGkpZMNR1hFOqLJngxBBJPXhbZE68PewdcLFLSr8uKv36/OCDWPptv1lUvC+X9SqXJXlnslhHq75n14UYAKaYcSk0nMdICiFSs1QM5Yq0SQg1LKInr2UVPHmRcrEjFBZXq8Fbg05tK/taQG8CTCurSfSp/2B42ru70Z8Cr98S87DxwhzOqW3iCgKNti7uMlFwP/ygRs0Wb1UJIGknlwQpeOjFXhJslIEcvJXQDBOC4Vl74QkEGAbjceGs5JMB4ElgsCJ7tQAMzwZjwVlVuUlaVD6VUKYKsDpgEF9QnzlRfif+Q625yVAvl7QFCLnfXTfwj2sqTSzoE7N70RCdpFXtWzyIVerSAMsKNQuoTpkYp5Bogi1AGANpXIDmKu+XQ1cBwsgU/c9/6Lz60XFd5/niEMtpLZWXNg2I71coVzAtZDUae75GZAO0CsgmQnJZNMmI//MhHHq8Tu72H6ogPOPPdSH+qSP7c74cReMhOd+1J0l/UPCp3M0XLsBlZlrkq/+iyhmxTYmChk62V3uiHkVfS+28dFQN7pe8+q91VPmx8IbkwlB6WgmC4OGwYCqO7jmmGsJyPo8xDq9Pz3CA4SMdrJN6Ajqj8/e/53BeSsobaCL93s8HvUGvf/7zhezai7MTIr049h9rnGjS/uMUeMJAoIVJRKEh7acGf1ox/dgkroJwPO4jokcGw4YkDsO+BDItPLr/ZYqJKzPe/VUk/iScan0hW+qC8fZCATnlCp/KG/YVolJfTHhZR18U4VkNL/7DuvvCeUdUoCXbDBrZ2hLffFY4qJDFFmGyV/K00LGjzpoFhYXa+c/f6N/IZgPBidy8kcNt/G2mouvKXVEIo6LVxKzrAWzgvBUBfzZoB9lixUQpM0VfyRwiieRyp4NomBW6KQ5UXcOTlA1RmJv9cJK4g+l1EuHegT7JKOxV1HDPYHzk6xewHKg5BcBA/3FdC8RKmkpGAWutWtadvzvNDd4nnl37eQlUVb3xBOxly91vdLn7DRdaqMMXu9/kxc5ZkPBG0gOr//arXqaCslZA7d+cv2XOlkVJZgLLldPab8TBujbo8gbzJJpGycwfBnL5arTLp//gtVwwqy/u/zAWykUIr69ogJKQV71Cgrj4Vj2BbFKdhKFofkFNlTIWxuVFJMxr2+FOw/z+rPReIKFtL0Q7S2qYwkdHmK649GykZFydReRcMzncPcU0ZbgH4vgpSFM/AXshhIdoWUETaIeymDTQAZz0NgDem23RmCy+25oFN7JdNuKyE4XWExtgNA1Y3AEfEwlU8K8ivCtWGsqy/VYZwnLWTcJUNbOiIgoGtwF0348DOj4cNtnYYI0p+zsUXfAyqbvWLdMv267jXCa0Eg2pdK5Bls8RTuSQu3zhzf1tBMYZJW2QCl01JSaBSvt3CRamKucmcRNsEqfBpiMqPibn+Pp3NBpafgmiLhr91JnOZ3+L/Te+pZG1Sf4DOG4+mb4NfHYeDQVqggLVXWpQZIMBncCi0q2bHOoAHbkfP0BHXpD9UQIKeKEGhl4eYaFioLy6D4Xl6gKKKrQOhV15qxYpL1dz3H/H/+Z+1wW9MOFUXNnO5pOrIK6/O784Hhz/dPjx+Ozo+Ox48GEdzhnd92KIACIeG7FPr5by2MijWoPHhjtgRMAvreiS2ZJlxnDdIvdKMea/qNelEmEWdcUIiDKa29Ic5PFvgKd8DizvadFnaWEDi7tP9HlcPIKFfSJVXB7FJvTi9F2Ewi+fsB/EzF4ZaZwXjvvimzJmKS6ukd5SvMzpsPGNBKCS0S9NrB9IxUwLhbXhhz3WGWlR0ESi1YTJkwkr0SH8SImgnQTUpC2wdX0xFINoSIAj/HyOVuyzYXL3Ynjrx6A27c3T663uJs6bYDoEs+ayfyztsAuKkzlWarPk7PdmyXHVzZIjdzw0iY0aw5l6KRDlap4GNfc2Dq7dTTLGwnKgdU/HkT+Csi60h+XrgAZXraSGmJLbBFgkFUf2VTR6lMzaQDrEw2ENx+HwE5cwcmUxpkSsTLKFSegQM4aZz6bsYSZ++aWaRmLP8dQiskFhAqKdJUEoSu/UkGclpxkNHufh1CyrGT1QJSU0I/ZRPB+mUVwb+jPKVT7jroRFyJ7fBTFSkM+E9DZM6h+DKQbKyGee6Zs8lZn6hjUh6Abqc/ZNfOnzcdIv+fR6c3k8xHNAe/bg3lxRx9Dk6Fobk/MtrN0u2IPBNdB75HIBlcNWa4hdAx75VCAMepzJ89KSlSYNXitJZwQsHwk1wWdRKBzd0wpq0dlX42j4SdCR2VEcPTSajdUaCI2VJ5zlhbrbFeoK3Uz9q2NcA3PjThtD3sVZdsqKRh9W/G2Bm/WefeG1qvy0gMyOozD/CL2vykacUq+vVkNyChrP0tC3BdWzHLOdxQi1IONVz1gkVNVD6ifRPAnw8JQWVU+mryhzci2iCqKpS5wt+RuVezJP190RmeKVukJWssX7QSUlKbOxQGufgscZXqqADQbFLeLuUS2oQw00ftxDwiAYA5I/c9yNqv1CrQudS1xyKvlk805nKhq6ipg8qUk3UJoFDinCK1+DuE5qhgrshdgjtpaZe8Reip3i5Ym1IzeRL4vkZakYl2uxsJpcLeI9ZAQx95C9FHvIy+s9pG/YC15lFsR4UqdHKSemIP3WyIJinlMz0UlHwIoBSyZOh/O0RiGUg6Y/ZeseS8v19dX27eD0BOffy/krFOvSqltP5lfM0CCx+/SWzuKCWeSz7JmtvshzDylDONob0vDJA5xDFTGcq2KkZtHKS0H/6DSAl7aagnoktWQaU/GqsIwENIHnJelNMmV4tjcUNPBPQUPZOEDz8+fjtEKfvus18I8rEhGsBlSt5cS6kop9QzVVVCHNc5S95FNDVMkLNXCqbJ4Rb7kwI8g7npy/IWpa9Pyv/Mx8pQB5xU8Yt6QKWea4belxmJxGI39s6Aqd6j5N0qsYBPgOT1/4YaYpJOZSmdtceZdlCcbgLkoCUU8ZjiN6DbRe85ZAfH2T8YxYjx59/mcQzPbHgR8rmOHnew8o6xxVOPRcXHtBRQ9HBYJo3x+PcUNLCpwjBYybXRalk5U1pMkz6LRyCgSwS7V3gtKXterIM0crbepnD/+4ReDlzmYC29wNDRBlKFPTjcaON/RdSw2jWqnDNaFTB8znfrkJq7XwNtDPuXrFl0lYIAnsSyyFRXuyBANTT4S4o7eIiS6vBEakEEyYLfcKGCisKNDMXI6v7jBLp4HkPgzTwjzsWASUZ0TL+dVvwTBFVToRtWXTngiWsW9H4Vt0iX+LayrFuptr5WH6CyvwK9NUst+ii9TUrEhHS/Np9p5svIo18nOykhM2TF+IqypL525KwX9DNlTJodnTYDp/HSTpv4iSnyHc1GkGsE7dY8XpDfSy6M1n61xNMG1Y37k2JQ2oGbRBLuF9N/amDes+y18vmQ+j8E4X9B/J+scO/ajvSE8PwruL2zAYjwwFkvswHd5ehKPgwAicEStboQ1FsusFWNZ+xvS0iGHMGSdI9uhiCZSQOrw5rgNtiFMU1sVoSA6zioaSktnfrIzxnogVFWXAXJF1SCkrGl4qGIOJaAYiW4y5tp5hTQu7kt9raY2kxtSsRkU9sXqPPgvoioBryhE9oncrYKVsTgkmkMDzpns0RC1TBasa0qjakWBXcWCszSJT/wt0w+gp4O3dgVmW6bvQi+dMTyWXjYiGc41o5pW6aZgOjr2LmQ6cw1RkyLcG8EoZK1Aq/4F50kF0FEfTLFubsPZTm0NZ8DXiyUbLHp4Ylzk/Hxs3YshnGffmiDLi9lv7jS55QZm/1I5pIrlSvrgCNIt5qq7xpLtboZIp2VRBcUPeqILSPE9c1fLmLFNFFXSdPb658mteu73J/2/Uu+2NfGPavoFoakfSTMTFtwKxCuaWsKFJF16FZUSuFs4N+0ngNJ4rjtS8gcJEZXpxRnqpYXxWlARHhUH5QQIBjxaBwGelBKNwipqgZK4ICQx9WgTnCqj36YWI3+a68eu2haRsNgyWFRKzJJEfY5RNW1Br08F/N/5EGPaqYVgWYXbEFfY6NiUb1Ivlgqf9BZhVQMHnb8zNMxeBQRvTN82Eepr4MwEwxTlri1Tumtv4xoajh8x35zqt2UP2P/o1iNhtbJI/9UZ7QwrIZDbDQBcWksZZ0DVqnAuisBSm5AX4wcEN6rKWWdgxcyNWW46xcBXxIBY0Cd6KCVRFMGkJOqtBiU3Tegk4Zvmg06IatKIZIbrVjHWrzAqjz88ETdp8twJSXVsyjGFZPwpbZ+6owraLk2lKXGpPGysWIy5NTJFJPerRfezPlIJVt6gL1H0xB57uxKiW406pZ9hwE28RVIagqX8ZHClqXoKTbSSoEcfkxUFV9ZCIMVajmoKhlDZq11opg8auleHLmuA/Lpeo7cJsiUoLq0sHDaSYXBcNY3vJApYXyuoxSQZQ9j1PrejqYkgAKW5eY1hGNI+HQVLf56xYq47XTeqpsHy4+ziH8YQPaZv0mV3VaWTc6kLAUX0YehLMAqj2eJRs61+JQJGDlEvb1gUC740xuUpVJ4TNv1pRQBgqL2KMmCp+gclubyzWd6aqNLZAC+uQLHboBUKmgDRF8sZezSip7cWLRJG91jqkkgm6RUCdAgIHEWLiC0kpDOF2glGYwlhgMhDVOkFClUyiheVWXr26BDE0rAmT3MySaiIs7XSi7I+XNtzkxA3WPZsFfIxq7UpWTlHNzMguFgbllzYUtlJN4qzYSEEaAusGqZlu2tE1S7s6W8ngcENSvcakhMWMDVVjgvzOSK+tGtZsT7wUtZYNrh/kuHIreN2fUv3mFGP5pa1yI7TlzWojuJTnPMy8HgtV/5L7fWbk25bAotKGm0H0HU7NMMZdpZLtTpsVbQneKtobKukS9xRU7JTZsWCNCitcD0wBdKXbwHYviyFfhhlGFYXCfrmwMaDT1k0hgor5Gx32d8NdsJOuWypALLqfKk0VZtgoO6eW1c82cqlZUn2reZHtpfVu3xoBC24RMRLR2IC5rBIQzp2wBWER3ElrDIbIfUiWaAizs0iAxXeBZZ+VEL6FqwqP8vki0UU85Du3YrHJUJUAU2irYeIOQweAiuEwqE03s3zdFYJyVhmcOWzq9+wghoxrJPvvhlMcS0+IrKFaswH/NVn0FQWunT63btuXTxChoSzGy9gKGaZgR5hGKGkjpmXEsMGo6VaGDTClxALWG1mWifmmxpeW6X1LGnG0z6IVZ1wldESUY0FH1TJm7FfCg2bMZucM9JnF4mcxVBJ6eB3GE1OopJ98qk1gWP4NtPsYJJvONNp05kkQk7PbgoDLgvnsMapG55fTlF5KzqZJKKGu1SiOUd4UDYEEDNZgyuD9w2nUdzfkbtxKQdBKU83O4k0xgNjWjtJWfsIhP0igbVbK5x8KlDT9WoAPQfKaH9AWr7+E55qDglE7uyRM9nGiaAE6q4uxg8SvZXSXzwViD84iYwfOoiXan0Z689PI1rpiJZP1KMNHQRneY57WX+4WGwebNzyoVt6jZlGn6oCUWFHh8oZF7hhMS+7rI5eG9Cvf7DE4qJRkcXCgN+lmryzC7gDG+s8pKO2KqOs2qt6dtUnmhU3cZZ3ry1drHGSdXmxsiq3p5Q7UrMhiJ6ilasteYZgBkXxFv82TNLx+VGjAFFAmmYuxk+p3kvRzntfvGkyFqwVV1pYuFKQxq0oRKQZ/GkHfw+ssCYO2vBB44RATRrCxPLklRVxH1rqASKvG110uok9GYX3+T01Y++MgTj2jrC6Sv7wBVkSGsoBoVZr/3yFZcT78JfD+GIGnMJxB3sklJHFHX2VyDroMbSSKFFSlnyL3+OVy8xn6zrGAsNAe+eE4GH25ZTaXwtK4wul19AVHdf7pq45IzXYUXL2D9zzP0Yef6W/buTHoN7nszv8pDO7x9NhxGkzUUyocSP2jsfgLLcmpk0z9GeAlLYeollSAAWODcegjUd6Moyt/HE7DVHIc5KBO/fgTytP5NH0XxO/9hzBRUv2ifHvowfN3cTRjcpuUOwhg+QpnNK+DGAw5g4L4Egq/QbKFQ6wK8yIMkJAwz8f5g1oGe0PbDUNAU0zsGU4zoPUrcnOVmgKTFwVx4sdp8nOY3tbcCRlcIuYRcZzCsauZrD/rKJvQpFiqU0l/TzAlX0ws+o3yfhCJRM8hZlAFf5ixGAG+nz/JwV35SYDTBJZxkojmPfA/fn5QtqjzDiMXJecgDHE6KXUydGwWrQhZsRKuh34bx4M76xnbC2KBAEEA7zCTnjbEit4SeOn2ERJJNncH4Aw79hlwqeOmmMOSMdbzPC1SFlHzwHuj0UWA6g8e29woLmtBUp/mdSMCdBUUkcTJsX9PsGTAkJSnTlgUzbhRZdSipOf1Vx8WA1REc2wMhp8WD6lCr0+imyNYn9dDi3F0kxT2GgpBgwlTorW+f1ZvK73BuJX4ILgLh0EvjsM7f4y7KbjRVfPl31wAKRerLwbjRVEH+phJUagcy78rdaAMhtIBFWHczgSiyUwt1slYQ7BK7yVuVlm9zr1U7CqqjJc14IWil7VnFkzF0kZibKlrxuLm/RoGAmwVWLMT226NXIokrM2nSbZXZ1xVPn9jn1/SzecCxhTprOLIIpI5QUzCXaR1ln3zrZ/QK9p5Xiyh1OFklj72wf5G3XEfXR83WUeYZUA4yf0QDdNo66cwmYMK9jvRx5zDOI7if0//PaUV5zF9DFrXVQQmYYCwHX86goH6Iwdb2KT3M1AnS1bhGqRM3VUH4CeP06EDzIxTAzNKsO6BsvD+9ERy1zOeh8+aS8tiOEeenV9qrs7NSf/eD1N1Tg4x1OPt/AozFtdMW4AWXsJLgJHZXlGm29oq5qtRkKRx9GhYJTlYtlkZbiqXC2cFcZhHcTQBZIg4UbBIkbbP6K/jTtLepML71BFG5YvhXH2VWrKDJd88Du73+/uSjT2Mh9ueOg7mPmelBdw/TMbI+PDYtA8q8QPtHeExh00D5yq4hf45sM45KFq/FZMp0HRrMZsSiw1XcJ7jRpMrz4tbP8l6AD9hGt8FMH1+jubjkfMYzZ1x+IlcLRETFnbC9MeiFbNwZrzQyxf3O89lQfRja6sLQSEMY9zAXGQUCt/ntKeWA3xReF6cGay0yO7skbq5bBisUTqqwYUi530Wfb1JZjgdnJ++I7/F7DajaEhThcDzOvnAPjOlivUR+HA29kEMuC+/3dp6hWmj8YuDjgBXMI2fQXnRhxdHUSqRAxoTLxgCiXboD29rtSn81JJb4sM6/oPGKSh6lzOwb/dB8auRu7Xc/vn5wKW3T0apajs6WeMAQPas0ptl9CrpLd5JiTfkIGS8zIdURksZSEhVeOazgtrrG8fF4dnFef/CFe1vZTmAFRZ3gqYX9HGNOHrfT8bYPG1UvQx1Y9GeklzqdMtbnkD8YHzBMKTbofBosbt/fnZ0/MZ9Ll6XlQnZY/SdFAxBO67Mob7p9969PTrvn0qAtTWL+MoR/k3sz25/Jk8N7W2y8VZouHf25vKk13/Tu3xzuED7IJ3mYz9+489vgnV0Y9H2b9bV8MHxm+NB7+Tg+OLdSe/DAj0YhTdhipE6JHRtla5wOafMjJgZL3QpyKwWu4Fn1Ed1E/VLCyCb/vZSchQutxgoRmo8n3JBvukcPgCypmDPCQvoppP4d8HRfEqczlI0FE0BY6pkTwGHFS01FN2thJoZEE5VE1TjLdDmVVpV8/iibFDXevmi5hD356bzczAeRhOiGZmskBqq5/fB1Uam2EsATVVA70qYpYKpEvPuXc1BYP9E31qBzebDwOm9O1bBfIBn9XAy+fgmSOErA1PbEJgvb6k/n6KdfD7tTUdxFGYJbaXmXuMtZKBFQAMxLY+KI6shrvdkD25fOVri1dstad9hRPwMF2Sfll7J8Ex4S/dvD94dC3DpZu5CgNkhtkLIsr2GN4uASkxLkTyCOmG0riubcA/24sbTb3jxnlwl6yS9A24Ghlft/2IRhltTgxw9yrvhZMNxC8c6Cx+CsUPsAj5WtkNHe/4O3/fxtQDaADHvfpi8u42mwXk8wN2/FFNkv4ujK/jxKPKOT3cTU7xH0XdmWKVOUmmbC4Pm8gnT2ZhGIzR+Mw8BcUc+5uv72U8wBWQMht8Ue4EYRafhyPk9iiZORN/hS5zQpG2lyDWBQ6OgocSGRCaxKcDNEeZIqTU3CrHNtunJxivlrz0B4+SxlafEQrZzlBuKo8qyZ/XC5APENUKtb7JfjM6RGZQ+TsaBf4fdCTTvDt3goyuW5POj98jlwRjWe39oO7hKoZgdqhugHIJQA9aG0Ti4gBqg+eKWKkVEDeP9hR5EM38Ypo/cAjqCMae1PF6Vvd5wthzMppJLUF7vpbha26+1GQkHDnVDTWsPusO+aeHRwI54ZVI0TxUdJyNb0chZq5uYcTrfutW86hjr0y1OO2teYRvCC6bYsIDY3J3IdhAv5lfcl6iXMW6hStCrOABw4/ntYPAuDv57HiRpP0jm49R6186I6Ef08k7+ifERSspPen9U7opm0cukOEvmPk/0VyzSIv8hpjkkF0qZUzKydnhJWt9cNm9aLo2tFdXIe8MCE97Or47F2ASeMn0WR2k0jMaWbJvsrdgBfzSy5ObEN2JJ6V4vGS68kUqCBmDL95mnbsWS6KJ+BwO4j2LLXQxiCbnfk3BaXFUqIiE9iEPfgiP6Tiod310mqNROLBdaQIE5K8AVaJ6UUnr3XMhlyQAXDwAKzFgBE+DsnQhYSojL6L1JqLxJKLhJqLPpCB0jPzgweS6J2DdkqZdRbCoAutJIu7iK4lh/LODKkHZXGLD4lsVBkIHWE+IK36JXu7vPs8wWvACuInLZxqaz1ZTSEBrKykMeof+Fzw5HmANYg02FisCQFmRlo9OCXWQh8dOecwc6fH50yYQr4ZcERuAeKxgBqcIv/aQPyTAq+UHlt3W8oa+X1hoU989c/ag2G61Qh9KguWG9Z7xq4zLhF2lcZADVPIdZ+vF2fnUZj0kMPs4deZaggjKPxxxuRm1Q954/e+ZqmVoRChmJnKc1e6wM0PTcIQ3+sEcrYUP0Ji9GRXjwf1wTOlktmtsWeZhXZTdaxKn9oJdAgG+kPgCmMwgZDzMZBkW4UKLK4cT/FPTpQl+zIPCjisHsqLXe5Y/Fff5YpdMf815nLzHor/5bEok3JYO+OwPBykVb/Jjfrc7eoEgg24TXQTq8rQG0Ted/JtEoAOE8BDXezeITHND20FsrRHPxZOjb6qFFDr0efZJj00ABOMgUHLlHDn+ZdSmDgqMSXFGGnmiJ2eVcPgwyYRdkXPG3Mb1GFhuXRlxEinV+afxK9i/TGgprNQ+JKjw/sipaOSZ70T44nqY1oXDzV0uOh2wN4t2hD+j9ymr6BSI5eMFRqLxXF0FeUHpucE4O+peHyhE7Zb3lkMTHZYAUg8vITVwXxmtqWmKiaHXGcGbwXhQBaRAPq/ycatPG9N+czXNbUqyY3TcW8jBloCuYbJvOVIiAzG3TXBOg5Zbc9SF9VUIsWQOZd1i1DbWtHM04xkGcz9N90IKga8BfCZrr1DLCkKmSXUfb+d317RuW7w4iJrl4zmkCsDeZe13Zs6Pli/tOwyzMkDkMPO1JirmyWzSrWNwETJ1EB57XB/BYRAROq5SCvQiUG1XH9FApVheYL39Pw+Tg9RE6RcuDkMaFZ+D5Ddki4+JQXFXoTil6pa0cVlmQtFjS5/cOc3avZzcRJ0pJpvxmr+u3fnJ+P2WRzY81F0tAV34UyvxCH/6a2SnCwkAldwE8LKHBIw8JvG5DhZivGUVQWSkdMn9h7C1dCIrgQgkdJj40wRM0+AKYWEqDSR6a+5itHoX9pKUMfWUvTLD9JjN85DXohRST7jfl2wFbdI36+eef61KiQQpMLNxS2dLL1MLSRr2KjSJIqXBL6z7WhHKwpFF6izbDhp7tTDHFZDvMbmvBjK0fBMP4cQb6Cnu8SZ6Oo5twuv84u83X/A3bXfHSdXpkzwnFDCwsb4mLMba60m6pA0my9jHyiY1CMsxhUeB3souPb9PJ+CIe7lMxI73CHlw8Jmkw6Q2HQZIcBNMwMPoH3p+e5Ksh8xXqxj87h8M6LVsVxGXOriMEMSdA42lmNFOD3FeBAX54G/sLIwKgoMAk+AvQmJLsFefXNWJg/pDF25F5ly82FEg95IV/lK7gIfqxqPQJrcoAJI6ebVhRnzm1+Rd2Iq4ewZwmZ+s0O7QIX8DxsoH6n/+Ulddzb+Q88/3LH+EH3wLdc5v1huv8+Orf05ckhid77tWbLj6lDeA3XFDZZybW99zvue1G7DTBXvzeJbJJLcEMR3iLq4ZWX7YhSUEsUROKZFoxyMrviVDQoGARWvU5wQV8d2hY9tU42HOPeicXh+4zHMwzPqpn+UCfISbgy/f2FB45PotIYYyAZzszuEVeeZ6AjcMWu2yu4O9csJFCwTVbv/NlmOg7MFVuZxG5l4rC0SaP4KXihSWzMW+fQ8icNbyCOVwwr+hqqcjyoWQ6AuarStNZ8lzgX2FYrda2q8brgRBi4gg1K+aI12FvClImSlLqZ80s1Lw4tvSjI/9+zvuwsckHJEUisy7UJYdKjn8UILeZ/Cf6n74y1BgQCbBQs14uVyWjR6gq+rgfeM0D2wYK42z1jIAwtEmQ3kawOBKfSu60Vn1xDCiOFxSdSQhawjULmEGjNRrfQaU4wCsClXN+txxPsBq9BXZQcJr74hSXLNURNBcr9+hJGwJqUTXMBjpRB+1sKo+WnvE0jPmFVPE+TG8FG1PasdWmiLktzU1CCrH9+dNwEmCGgZqLRxWezcZ+OH2BIcrAzunewxZ2cCsLM3ohQpjitvIjuUCZxnKhFsDJop5nxBqk/AW/y7m1oWWvpjlmqfPhFV5a2cg8GOzpS7xmV65IjHlkARLapm051rKQHFhxPZgYrCvUM4GHbXPwm2Rgwu6jFBGnIbu8bWSFRVrQdUEZ4wGetrCheW1dkRpNMLufcjk9blvrcqeehDdTgBYHF7gioZQ1liLLlVsC4pCY09/zBfTfU2A+WESDByJGcdC9sR9PmMW+mf9OU1juk+zBADCA/C0c7iXvhOBQjBbJz+8Kb/8FCNfqTaOUyPN3/jQYGx4VVxDevsH4WCwCunGcXgRxGJBf+aEh5Sfu1hsevQajyfCYbfEfTtP4UXmdHdAUnrPi5Mk8SaPJBxrujA9QwGfDxR8XwQ1qoflP1nfyYz6Z+PGjUmQQ+8NPQaz8VHCF52+VRxYCsWPYeNJa+Jn1UTulTR4ivnVQ2kwhD+dX7ANVAPx6EtzARMi/Kf2kD7MOCD+VgjS4Iv+mvQZ19WH7YZv8oMf8M6in4fTUf8i/sUmDD878u/CGkzT7oQA/AxEgkPUdZkzPvhyRbxlqMEhXePLIQbGq8BTmIcD1Sc/IhL9Io9lFGszIA8oF+BUjZoDJYL1JaV+lB8S3mSMe341oF3/CTJTkmT59fwrQ1CVI4qepxZn/njOGeq4fn+F6wD8Z8/OfH19fHh0d9j8Ozs8/Xpz2Tk6yFweHPx3vH8L7iw/qs7Pzwcej88uzg/zF2cXHw37/vJ8/Ob98fXL4sbe/f3iRPTx8/7Z3eTE4zCseHZ+Y4B2f/dQ7OT742Ou/uTw9PBtoLyh47fGxoejJ+dkb7eHFoH9seHwpAThXxnRy+Ka3n2PjtPde7cfp8Zn6CAd3fHY8OIYG/iWMHJ9fXL57d94fSE8BSe+O+73B8fnZx/23h/v/FN+9Pb8YnPVOD/U3p+f9w48HvUFPfDjoE2x/3O8pFfpHMNi3vf6BMkLy/OL8aKA+H+yTDvcPewc5Ai4uTpRy+OTy7J8f9w/7OR4vLpEJci4YHJ8enl/m7y/PepeDt+d9CT2XZ/RMx2VfePjTYf8C8XJ6DLw62H9LXwgLm/gA1zL6m02ND6/jeULWnw8kHTD7NiWZhUFFG1HJTucGfj+Jbm7oBCY/+yDgglh4IJYFozvwJ/wnbfhAOo1AHh1O55PsC1/ePpAjpafJDflxFMaTez8OUEmQHlzORhwyrhv0C1OLyA+2CDBRzn9eXBy8Y3GX9DFfhem3cJhIPy5+otMCV4nX0egx+8EMCfobDIvD6U3IMMxbhE/h6Ql8AbrE/iiEdTFH/mngJ6Dv0O/RaM6GeRakYA18It/fBXREfZB6oGezErkg/4CRgUf02ySKQMeb3pziRgh5gvTMmyM/c+6g3hFcFX06FurbO5zeyb/ephMi6D+gpkhJD/XesgWEBwby7xcRrO6pMHh69oR9xThB8pVtXZDvIE0Hh/uDj1zo8t9nhwP59/nZofTg8uI1/X0EkwTlxMHhxX7/+N3gvM8FGXlvWglQASXclv2S1VF8zCeOQRn8+OHDx8t4zFUElirJT+g38kg7g4RPaVox/Db0Z6jskvRvQYqBmbQEO0G6+Y1wcgt/yCd6dGXGdOKHPI/mV+PgzCeNYn4r3F4yrKs3ckeFI1z4M2QDZRHW+HVCFJFMk5AT2uETci3L+w/Z10TQDIQEHORnlnZi8xseI02URb2f9OUR6G3Wl6DUDcOE5c8zlkgEOUCT9rCMe/jgsSfzC9o8z559x3b8Tv3ZDPj/sn+y93jXug+utniIdf23pD7xZ9/8P4LYUMNIKA8A";
BinariesBlobs.rw_js = "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";
BinariesBlobs.ro_minjs = "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";
BinariesBlobs.rw_minjs = "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";

// obj/full/installer_rw.js
var codeInstance = class {
  constructor(filename, EStarget, version, readonly) {
    this._compressed = filename.slice(-3) == ".gz";
    this._filename = this._compressed ? filename.slice(0, -3) : filename;
    this._version = version == "" ? "Unknown" : version;
    this._EStarget = EStarget == "" ? "Unknown" : EStarget;
    this._minified = filename.indexOf(".min.") > 0;
    this._readonly = readonly;
  }
  get compressed() {
    return this._compressed;
  }
  get version() {
    return this._version;
  }
  get readonly() {
    return this._readonly;
  }
  get EStarget() {
    return this._EStarget;
  }
  get minified() {
    return this._minified;
  }
  get filename() {
    return this._filename + (this.compressed ? ".gz" : "");
  }
};
var pageInstance = class {
  constructor(filename, contents) {
    let strContents = YAPI.imm_bin2str(contents);
    this._compressed = filename.slice(-3) == ".gz";
    this._filename = this._compressed ? filename.slice(0, -3) : filename;
    this._readonly = strContents.indexOf("yv4web-readonly") > 0;
    this._useMinified = strContents.indexOf("yv4web-readonly.min.js") > 0 || strContents.indexOf("yv4web-full.min.js") > 0;
    this._action = 0;
    this._contents = contents;
  }
  get compressed() {
    return this._compressed;
  }
  get readonly() {
    return this._readonly;
  }
  set readonly(value) {
    this._readonly = value;
  }
  get fs_filename() {
    return this._filename + (this.compressed ? ".gz" : "");
  }
  get http_filename() {
    return this._filename;
  }
  set action(value) {
    this._action = value;
  }
  get action() {
    return this._action;
  }
  get contents() {
    return this._contents;
  }
  get useMinified() {
    return this._useMinified;
  }
  set useMinified(value) {
    this._useMinified = value;
  }
};
var YV4W_installer = class {
  constructor(container, options) {
    this.CALLERISHTTPS = location.protocol.toLowerCase().substr(0, 5) == "HTTPS";
    this.DEFAULT_PROTOCOL = this.CALLERISHTTPS ? YV4W_installer.HTTPS : YV4W_installer.HTTP;
    this.FIRMWAREMINVERSION = 43805;
    this.DEFAULTADDR = "";
    this.DEFAULTPORT = "80";
    this.DEFAULTPATH = "";
    this.DEFAULTCANCELABLE = false;
    this.DEFAULTINTIALFOCUS = true;
    this.DEFAULTUSER = "";
    this.DEFAULTPWD = "";
    this.DEFAULTFILEPREFIX = "default";
    this.DEFAULTSRVUSERNAME = "";
    this.DEFAULTSRVPASSORD = "";
    this._currentStep = 0;
    this._warningRow = null;
    this._welcomeText = null;
    this._hubAddr = null;
    this._connectingText = null;
    this._ipAddrInput = null;
    this._protocolInput = null;
    this._ipPortInput = null;
    this._pathInput = null;
    this._configFileInput = null;
    this._webPageInput = null;
    this._connectiongError = null;
    this._pwdPanel = null;
    this._descPanel = null;
    this._customFilesPanel = null;
    this._doneMsgContainer = null;
    this._confirmUninstallPanel = null;
    this._modInstancesPanel = null;
    this._donePanel = null;
    this._runPanel = null;
    this._modifyInstallPanel = null;
    this._adminNameInput = null;
    this._adminPasswordInput = null;
    this._userNameInput = null;
    this._userPasswordInput = null;
    this._useReadOnlyInput = null;
    this._fileprefixInput = null;
    this._useFullVersionInput = null;
    this._removeUnusedJs = null;
    this._makeDefaultInput = null;
    this._userCredTable = null;
    this._optionsPanel = null;
    this._connectionErrorMsg = null;
    this._instancesFiles = [];
    this._jsCodeinstances = [];
    this._webPageinstances = [];
    this._uninstallOpt = null;
    this._updateOpt = null;
    this._addInstanceOpt = null;
    this._modInstanceOpt = null;
    this._confirmUninstall = null;
    this._history = [];
    this._ErrMsgContainer = null;
    this._currentHub = null;
    this._currentfs = null;
    this._currentHub_RW_username = "";
    this._currentHub_RW_password = "";
    this._currentHub_RO_username = "";
    this._currentHub_RO_password = "";
    this._currentHub_protocol = "";
    this._currentHubLink_protocol = "";
    this._currentHub_Addr = "";
    this._currentHub_port = "";
    this._currentHub_path = "";
    this._currentHub_ReadOnlyProtected = false;
    this._warning = "";
    this._finalURL = "";
    this._plannedaction = 0;
    this._alreadyInstalled = false;
    this._applicationURL = "";
    this.ESVersion = "es2017";
    this.WELCOMEPANEL = 0;
    this.ENTERHUBADDR = 1;
    this.CONNECTINGPANEL = 2;
    this.CONNECTIONERROR = 3;
    this.PASSWORDPANEL = 4;
    this.DESCRIPTIONPANEL = 5;
    this.CUSTOMFILESPANEL = 6;
    this.OPTIONSPANEL = 7;
    this.RUNPANEL = 8;
    this.DONEPANEL = 9;
    this.MODIFYINSTALLPANEL = 10;
    this.CONFIRMUNINSTALLPANEL = 11;
    this.MODINSTANCESPANEL = 12;
    this.ACTIONINSTALL = 1;
    this.ACTIONUNINSTALL = 2;
    this.ACTIONADDINSTANCE = 3;
    this.ACTIONMODINSTANCE = 4;
    this.ACTIONUPDATE = 5;
    this._MODIFYNOTHING = 0;
    this._MODIFYCOMPRESS = 1;
    this._MODIFYUNCOMPRESS = 2;
    this._MODIFYMAKEREADONLY = 3;
    this._MODIFYMAKEREADWRITE = 4;
    this._MODIFYUSEMINIFIED = 5;
    this._MODIFYUSEPLAIN = 6;
    this._MODIFYDELETE = 7;
    this._MODIFYUPDATE = 8;
    this.TARGETEXTENSION = ".html";
    this.icon = '<link rel="icon" type="image/svg+xml" href="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNjQiIGhlaWdodD0iNjQiIHZlcnNpb249IjEuMSIgdmlld0JveD0iMCAwIDE3IDE3IiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPjxyZWN0IHg9IjAiIHk9IjAiIHdpZHRoPSIxNyIgaGVpZ2h0PSIxNyIgcng9IjEuMSIgcnk9IjEuMSIgZmlsbD0iI2ZmZiIgZmlsbC1vcGFjaXR5PSIuOSIvPjxwYXRoIGQ9Im0xMC43IDEuMy0wLjI5IDAuMjljLTAuMDQ3IDAuMDQ3LTAuMDczIDAuMTEtMC4wNzIgMC4xOHYxLjFjLTEuMS0wLjktMi43LTAuODMtMy43IDAuMTRsLTAuNC0wLjR2LTAuOTdjMC4zNS0wLjI1IDAuMi0wLjgyLTAuMjMtMC44My0wLjQzLTAuMDE0LTAuNjMgMC41My0wLjI3IDAuODJ2MS4xYzAgMC4wNjcgMC4wMjcgMC4xMyAwLjA3NCAwLjE4bDAuNDkgMC40OWMtMC40MyAwLjU5LTAuNjMgMS4zLTAuNTQgMi4xdjAuMDA3MmwtMC44My0wLjgzYy0wLjA0Ny0wLjA0Ny0wLjExLTAuMDczLTAuMTgtMC4wNzJoLTJjLTAuMjctMC4zNi0wLjgzLTAuMTktMC44MyAwLjI1IDAuMDAxMiAwLjQ0IDAuNTYgMC42MiAwLjgyIDAuMjVoMS45bDEuMyAxLjNjMC40MyAwLjM4IDAuNzQgMS4yIDAuNTkgMS42aC0yLjVjLTAuMDY2IDAgLTAuMTMgMC4wMjctMC4xOCAwLjA3NGwtMS40IDEuNGMtMC4zOS0wLjA4OS0wLjcyIDAuMzQtMC40OCAwLjY5czAuODYgMC4yIDAuODItMC4zM2wxLjMtMS4zaDIuNmMwLjI2IDAuMTUgMC41MSAwLjQgMC42NyAwLjY1djEuOWwtMS41IDEuNWMtMC4wNDcgMC4wNDctMC4wNzMgMC4xMS0wLjA3NCAwLjE4djAuMjhjLTAuNDUgMC4zLTAuMTUgMC44MyAwLjIzIDAuODMgMC4zOCAwIDAuNjMtMC40NyAwLjI3LTAuODF2LTAuMjFsMS41LTEuNWMwLjA0Ny0wLjA0NiAwLjA3NC0wLjExIDAuMDc0LTAuMTh2LTEuN2MwLjI0LTAuMzIgMS4xLTAuNCAxLjQtMC4wM3YxLjJjIDAgMC4wNjYgMC4wMjcgMC4xMyAwLjA3NCAwLjE4bDEuNSAxLjV2MC42OWMtMC4zNiAwLjI0LTAuMjMgMC44MSAwLjI3IDAuODIgMC40OSAwLjAwMjEgMC41NC0wLjY0IDAuMjMtMC44MnYtMC43OWMgMCAtMC4wNjYtMC4wMjctMC4xMy0wLjA3NC0wLjE4bC0xLjUtMS41di0xLjRjMC4xNS0wLjIgMC4zLTAuMjUgMC41My0wLjI0aDMuMmwwLjkxIDAuOTFjLTAuMDk5IDAuNDQgMC40OCAwLjcyIDAuNzcgMC40IDAuMjgtMC4zMiAwLjA3Mi0wLjc5LTAuNDItMC43NmwtMC45OC0wLjk4Yy0wLjA0Ny0wLjA0Ny0wLjExLTAuMDcyLTAuMTgtMC4wNzJoLTNjLTAuMjEtMC4zMiAwLjI0LTEuNSAwLjY3LTEuOWwyLjIgMC4wMDU5YzAuMDY3IDAgMC4xMy0wLjAyNiAwLjE4LTAuMDcybDEuMS0xLjFjMC4zOSAwLjA5NiAwLjczLTAuNCAwLjQ0LTAuNzNzLTAuODctMC4xLTAuNzggMC4zNmwtMS4xIDEuMWgtMmMwLjI3LTAuOTUgMC4wMDY3LTEuOS0wLjQzLTIuNXYtMS41bDAuMjEtMC4yMWMwLjM4IDAuMDgyIDAuNzEtMC4zMyAwLjQ2LTAuNjlzLTAuODctMC4xOS0wLjggMC4zM3ptLTMuMiA0LjljMC44NC0wLjAyOSAwLjk2IDEuNSAwLjIgMS41LTAuNzYtMC4wMTQtMS0xLjQtMC4yLTEuNXptMi4xIDBjMC43NSAwLjA4NCAwLjYxIDEuNS0wLjIgMS41LTAuODEgMC4wMDMzLTAuNTUtMS41IDAuMi0xLjV6IiBmaWxsLW9wYWNpdHk9Ii4xIi8+PHJlY3QgeD0iMCIgeT0iMCIgd2lkdGg9IjE3IiBoZWlnaHQ9IjE2IiByeT0iMS44IiBvcGFjaXR5PSIwIiBzdHJva2Utd2lkdGg9Ii4yNiIvPjxlbGxpcHNlIGN4PSI5LjQiIGN5PSI3LjQiIHJ4PSIuMzQiIHJ5PSIuMzMiIG9wYWNpdHk9Ii4xIi8+PGVsbGlwc2UgY3g9IjcuNyIgY3k9IjcuNCIgcng9Ii4zNCIgcnk9Ii4zMyIgb3BhY2l0eT0iLjEiLz48ZyBmaWxsPSJub25lIj48cGF0aCBkPSJtMS4xIDEuOSAwLjA2NiAxNCIgc3Ryb2tlPSIjN2U3ZTdlIiBzdHJva2Utd2lkdGg9Ii4yIi8+PHBhdGggZD0ibTE1IDEzaC0xNSIgc3Ryb2tlPSIjN2U3ZTdlIiBzdHJva2Utd2lkdGg9Ii4yIi8+PHBhdGggZD0ibTEuMiAxM2M1LjQtMS4xIDEwLTIuNyAxNS02LjkiIHN0cm9rZT0ibGltZSIgIHN0cm9rZS13aWR0aD0iLjQiLz48cGF0aCBkPSJtMS4yIDEzYzAuMS0wLjA1MyAwLjQ1LTEuNCAxLjItMS40IDAuNzggMCAxLjQgMi44IDIuMyAyLjggMC44Ni0wLjAwMTUgMS42LTIuOCAyLjQtMi44IDAuODQgMCAxLjUgMi44IDIuNCAyLjggMC45IDAuMDEzIDEuNi0yLjggMi40LTIuOCAwLjgyIDAuMDI4IDEuNSAyLjcgMi4zIDIuOCAwLjI2IDAuMDQzIDAuNjgtMC4zNCAwLjY3LTAuNDIiICBzdHJva2U9InJlZCIgIHN0cm9rZS13aWR0aD0iLjQiLz48L2c+PHBhdGggZD0ibTE1IDEyLjQgMS4xIDAuNi0xLjEgMC41N3oiIGZpbGw9IiM3ZTdlN2UiLz48cGF0aCBkPSJtMC41MiAyIDAuNjItMSAwLjU5IDF6IiBmaWxsPSIjN2U3ZTdlIi8+PHBhdGggZD0ibTkuOCAwIDcuMiA3LjJ2LTRsLTMuMi0zLjJ6IiBmaWxsPSJncmVlbiIvPjxnIGZpbGw9IiNmZmYiIHN0cm9rZS13aWR0aD0iMSI+PHBhdGggZD0ibTEyLjcgMS42MyAwLjQ5LTEuMSAwLjE5IDAuMTktMC4zMyAwLjc0IDAuNzUtMC4zMiAwLjEyIDAuMTItMC4zMiAwLjc1IDAuNzMtMC4zNCAwLjE3IDAuMTctMS4xIDAuNDktMC4xMi0wLjEyIDAuMzMtMC43Ny0wLjc3IDAuMzN6Ii8+PHBhdGggZD0ibTEzLjggMi43OSAwLjc5LTAuNzkgMC44MiAwLjgyLTAuMTQgMC4xNC0wLjY0LTAuNjQtMC4xOCAwLjE4IDAuMzYgMC4zNi0wLjE0IDAuMTQtMC4zNi0wLjM2LTAuMTkgMC4xOSAwLjY0IDAuNjQtMC4xNSAwLjE1eiIvPjxwYXRoIGQ9Im0xNi4xIDMuOC0wLjQyLTAuNDItMC4xOSAwLjE5IDAuNDIgMC40MnEwLjA0OSAwLjA0OSAwLjA3OSAwLjA1MyAwLjAzMiAwIDAuMDY0LTAuMDI2bDAuMDc1LTAuMDc1cTAuMDMxLTAuMDMxIDAuMDI1LTAuMDYyLTAuMDA0NS0wLjAzMi0wLjA1Mi0wLjA3OXptLTAuMzIgMC4zMi0wLjQyLTAuNDItMC4yIDAuMiAwLjQyIDAuNDJxMC4wNTIgMC4wNTMgMC4wODYgMC4wNTQgMC4wMzUgMC4wMDMxIDAuMDc1LTAuMDM3bDAuMDYtMC4wNnEwLjA0LTAuMDQgMC4wMzYtMC4wNzQtMC4wMDIzLTAuMDM0LTAuMDU0LTAuMDg2em0tMC45NS0wLjI2IDAuNzktMC43OSAwLjY4IDAuNjhxMC4wOTQgMC4wOTQgMC4xIDAuMTcgMC4wMDUzIDAuMDc5LTAuMDc1IDAuMTZsLTAuMDk4IDAuMDk4cS0wLjA1NyAwLjA1Ny0wLjEyIDAuMDU3LTAuMDY5LTAuMDAxNS0wLjE1LTAuMDU5IDAuMDU5IDAuMDc3IDAuMDU3IDAuMTYtMC4wMDIzIDAuMDc3LTAuMDY2IDAuMTRsLTAuMSAwLjFxLTAuMDc5IDAuMDc5LTAuMTcgMC4wNTktMC4wOTYtMC4wMTktMC4yMi0wLjE0eiIvPjwvZz48L3N2Zz4=">';
    if (typeof options !== "undefined") {
      if (options != null) {
        if (typeof options["protocol"] === "string")
          this.DEFAULT_PROTOCOL = options["protocol"].toUpperCase() == YV4W_installer.HTTPS.toUpperCase() ? YV4W_installer.HTTPS : YV4W_installer.HTTP;
        if (typeof options["addr"] === "string") {
          this.DEFAULTADDR = options["addr"];
          let n = this.DEFAULTADDR.indexOf(":");
          if (n > 0) {
            this.DEFAULTPORT = this.DEFAULTADDR.substring(n + 1);
            this.DEFAULTADDR = this.DEFAULTADDR.substring(0, n);
          }
        }
        if (typeof options["port"] === "number")
          this.DEFAULTPORT = options["port"].toString();
        if (typeof options["path"] === "string")
          this.DEFAULTPATH = options["path"];
        if (typeof options["cancelable"] === "boolean")
          this.DEFAULTCANCELABLE = options["cancelable"];
        if (typeof options["initialFocus"] === "boolean")
          this.DEFAULTINTIALFOCUS = options["initialFocus"];
      }
    }
    this._container = container;
    this._container.innerHTML = "";
    this._container.style.backgroundColor = constants.WindowBackgroundColor;
    this._container.style.fontFamily = constants.WindowHeaderFontFamily;
    let bottomdiv = document.createElement("DIV");
    bottomdiv.style.position = "absolute";
    bottomdiv.style.bottom = "0px";
    bottomdiv.style.right = "5px";
    bottomdiv.style.height = "30px";
    bottomdiv.style.textAlign = "right";
    bottomdiv.style.verticalAlign = "center";
    this._prevButton = new button("< Prev", () => {
      this.gotoPrevious();
    }, 1);
    this._cancelButton = new button("Cancel", async () => {
      this.closeWindow();
    }, 1);
    this._nextButton = new button("Next >", () => {
      this.gotoNext();
    }, 1);
    this._okButton = new button("Ok", async () => {
      this.DEFAULTCANCELABLE ? this.closeWindow() : await this.resetAll();
    }, 1);
    this._prevButton.tabIndex = 100;
    this._cancelButton.tabIndex = 101;
    this._nextButton.tabIndex = 102;
    this._okButton.tabIndex = 103;
    bottomdiv.appendChild(this._prevButton.Element);
    bottomdiv.appendChild(this._cancelButton.Element);
    bottomdiv.appendChild(this._nextButton.Element);
    bottomdiv.appendChild(this._okButton.Element);
    this._prevButton.visible = false;
    this._cancelButton.visible = this.DEFAULTCANCELABLE;
    this._container.appendChild(bottomdiv);
    let topDiv = document.createElement("DIV");
    topDiv.style.position = "absolute";
    topDiv.style.top = "5px";
    topDiv.style.paddingLeft = "10px";
    topDiv.style.paddingTop = "5px";
    topDiv.style.paddingBottom = "5px";
    topDiv.style.left = "5px";
    topDiv.style.right = "5px";
    topDiv.style.backgroundColor = constants.WindowHeaderBackgroundColor;
    topDiv.style.color = constants.WindowHeaderColor;
    topDiv.style.fontSize = "x-large";
    topDiv.style.whiteSpace = "nowrap";
    topDiv.style.overflow = "hidden";
    topDiv.innerText = "Yocto-Visualization (for web) installer";
    this._container.appendChild(topDiv);
    this.gotoPanel(this.WELCOMEPANEL);
  }
  closeWindow() {
    var _a;
    (_a = this._container.parentElement) === null || _a === void 0 ? void 0 : _a.removeChild(this._container);
  }
  createNewContentDiv() {
    let div = document.createElement("DIV");
    div.style.position = "absolute";
    div.style.textAlign = "justify";
    div.style.top = "50px";
    div.style.left = "15px";
    div.style.right = "15px";
    return div;
  }
  loadLocalFile(fileChooser) {
    return new Promise(function(resolve, reject) {
      if (fileChooser.files && fileChooser.files[0]) {
        let reader = new FileReader();
        reader.onload = function(e) {
          resolve(e.target.result);
        };
        reader.readAsText(fileChooser.files[0]);
      } else {
        resolve(null);
      }
    });
  }
  showWelcomePanel(visible, goingback) {
    if (!visible) {
      if (this._welcomeText != null)
        this._welcomeText.style.display = "none";
      return;
    }
    this._okButton.visible = false;
    this._prevButton.visible = false;
    this._nextButton.visible = true;
    this._nextButton.enabled = true;
    this._cancelButton.visible = this.DEFAULTCANCELABLE;
    if (this._welcomeText == null) {
      this._welcomeText = this.createNewContentDiv();
      this._welcomeText.innerText = "Yoctopuce is proud to offer you  Yocto-Visualization (for web), an application that  allows to view Yoctopuce sensors data with a simple web browser.\n\nThis wizard will help you to install Yocto-Visualization (for web) version " + constants.buildVersion + " (" + this.ESVersion + ') on a YoctoHub such as YoctoHub-Ethernet, YoctoHub-Wireless, VirtualHub etc..\n\n Click on "next" to start';
      this._container.appendChild(this._welcomeText);
    }
    this._currentHub = null;
    this._currentfs = null;
    this._currentHub_RW_username = "";
    this._currentHub_RW_password = "";
    this._currentHub_RO_username = "";
    this._currentHub_RO_password = "";
    this._currentHub_protocol = "";
    this._currentHub_Addr = "";
    this._currentHub_port = "";
    this._currentHub_path = "";
    let tabIndex = 1;
    this._nextButton.tabIndex = tabIndex++;
    if (this.DEFAULTINTIALFOCUS)
      this._nextButton.focus();
    this._welcomeText.style.display = "";
  }
  showEnterHubAddr(visible, goingback) {
    if (!visible) {
      if (this._hubAddr != null)
        this._hubAddr.style.display = "none";
      return;
    }
    if (this._hubAddr == null) {
      this._hubAddr = this.createNewContentDiv();
      let p = document.createElement("P");
      p.innerText = "Enter the address of the hub you want to install Yocto-Visualization on. This address must be reacheable from your web browser.";
      this._hubAddr.appendChild(p);
      let Table = document.createElement("TABLE");
      Table.style.fontSize = "smaller";
      let Row = document.createElement("TR");
      let TD1 = document.createElement("TD");
      TD1.innerText = "Hub address:";
      TD1.style.whiteSpace = "normal";
      Row.appendChild(TD1);
      let TD2 = document.createElement("TD");
      TD2.style.whiteSpace = "normal";
      this._protocolInput = document.createElement("SELECT");
      let httpopt1 = document.createElement("OPTION");
      httpopt1.text = "http://";
      httpopt1.value = YV4W_installer.HTTP;
      this._protocolInput.add(httpopt1);
      let httpopt2 = document.createElement("OPTION");
      httpopt2.text = "https://";
      httpopt2.value = YV4W_installer.HTTPS;
      this._protocolInput.add(httpopt2);
      this._protocolInput.value = this.DEFAULT_PROTOCOL;
      this._protocolInput.addEventListener("change", () => {
        if (this._protocolInput != null && this._ipPortInput != null) {
          if (this._protocolInput.value == YV4W_installer.HTTPS && parseInt(this._ipPortInput.value) == 80)
            this._ipPortInput.value = "443";
          if (this._protocolInput.value == YV4W_installer.HTTP && parseInt(this._ipPortInput.value) == 443)
            this._ipPortInput.value = "80";
          if (this._warningRow != null)
            this._warningRow.style.display = this._protocolInput.value == YV4W_installer.HTTP && this.CALLERISHTTPS ? "" : "none";
        }
      });
      TD2.appendChild(this._protocolInput);
      this._ipAddrInput = document.createElement("INPUT");
      this._ipAddrInput.value = this.DEFAULTADDR;
      this._ipAddrInput.size = 34;
      this._ipAddrInput.addEventListener("input", () => {
        this._nextButton.enabled = this._ipAddrInput.value != "" && this._ipPortInput.value != "";
      });
      TD2.appendChild(this._ipAddrInput);
      let span = document.createElement("SPAN");
      span.innerText = ":";
      TD2.appendChild(span);
      this._ipPortInput = document.createElement("INPUT");
      this._ipPortInput.value = this.DEFAULTPORT != "" ? this.DEFAULTPORT : "4444";
      this._ipPortInput.type = "number";
      this._ipPortInput.min = "1";
      this._ipPortInput.max = "65535";
      this._ipPortInput.maxLength = 6;
      this._ipPortInput.style.width = "60px";
      this._ipPortInput.addEventListener("input", () => {
        this._nextButton.enabled = this._ipAddrInput.value != "" && this._ipPortInput.value != "";
      });
      TD2.appendChild(this._ipPortInput);
      Row.appendChild(TD2);
      Table.appendChild(Row);
      this._warningRow = document.createElement("TR");
      TD1 = document.createElement("TD");
      TD1.style.whiteSpace = "normal";
      TD1.style.fontSize = "smaller";
      TD1.innerText = "WARNING: Unless your web browser is configured to accept 'mixed content', trying to establish an HTTP connection from an HTTPS page is likely to fail.";
      TD1.colSpan = 2;
      this._warningRow.style.display = "none";
      this._warningRow.appendChild(TD1);
      Table.appendChild(this._warningRow);
      Row = document.createElement("TR");
      TD1 = document.createElement("TD");
      TD1.style.whiteSpace = "normal";
      TD1.style.paddingTop = "20px";
      TD1.style.paddingBottom = "20px";
      TD1.style.textAlign = "justify";
      TD1.innerText = "On YoctoHubs, protocol is HTTP and port is likely to be 80. On native Virtualhub, protocol is HTTP and port is likely to be 4444. On VirtualHub (for web), the  hub path is mandatory and should be set to your VirtualHub (for web) instance path, protocol and  port can be either HTTP and 80 or HTTPS and 433.";
      TD1.colSpan = 2;
      Row.appendChild(TD1);
      Table.appendChild(Row);
      Row = document.createElement("TR");
      TD1 = document.createElement("TD");
      TD1.style.whiteSpace = "normal";
      TD1.innerText = "Hub path:";
      Row.appendChild(TD1);
      TD2 = document.createElement("TD");
      TD2.style.whiteSpace = "normal";
      this._pathInput = document.createElement("INPUT");
      this._pathInput.value = this.DEFAULTPATH;
      this._pathInput.size = 48;
      TD2.appendChild(this._pathInput);
      Row.appendChild(TD2);
      Table.appendChild(Row);
      this._hubAddr.appendChild(Table);
      this._container.appendChild(this._hubAddr);
    }
    this._hubAddr.style.display = "";
    let tabIndex = 1;
    this._protocolInput.tabIndex = tabIndex++;
    this._ipAddrInput.tabIndex = tabIndex++;
    this._ipPortInput.tabIndex = tabIndex++;
    this._pathInput.tabIndex = tabIndex++;
    this._prevButton.tabIndex = tabIndex++;
    this._nextButton.tabIndex = tabIndex++;
    this._protocolInput.focus();
    this._nextButton.visible = true;
    this._nextButton.enabled = this._ipAddrInput.value != "";
  }
  async showConnectingPanel(visible, goingback) {
    if (!visible) {
      if (this._connectingText != null)
        this._connectingText.style.display = "none";
      return;
    }
    if (this._connectingText == null) {
      this._connectingText = this.createNewContentDiv();
      this._container.appendChild(this._connectingText);
    }
    this.removeCurrentPanelFromHistory();
    this._connectingText.innerText = "Connecting to hub " + this._ipAddrInput.value + ". Please wait...";
    this._connectingText.style.display = "";
    this._nextButton.visible = false;
    this._prevButton.visible = false;
    this._cancelButton.visible = false;
    let IP = this._ipAddrInput.value;
    let port = parseInt(this._ipPortInput.value);
    let protocol = this._protocolInput.value;
    this._currentHubLink_protocol = this._protocolInput.value;
    let RW_username = "";
    let RW_password = "";
    let RO_username = "";
    let RO_password = "";
    if (this._adminNameInput != null)
      RW_username = this._adminNameInput.value;
    if (this._adminPasswordInput != null)
      RW_password = this._adminPasswordInput.value;
    if (this._userNameInput != null)
      RO_username = this._userNameInput.value;
    if (this._userPasswordInput != null)
      RO_password = this._userPasswordInput.value;
    let url = protocol + "://" + IP + ":" + port.toString();
    let HubData = null;
    let serial = "";
    let path = this._pathInput.value;
    if (path != "") {
      if (path.charAt(0) == "/")
        path = path.slice(1);
      url += "/" + path;
    }
    let info = new HubInfo(protocol, IP, port, path, null, null);
    let infoRes = await info.makeRequest();
    if (infoRes !== true) {
      let err = "Failed to connect to the Hub while using the url\n\n" + url + "\n\n";
      let prvmsg = 'Click on the "prev" button,';
      switch (infoRes) {
        case 0:
          err += prvmsg + " and make sure that protocol, address, port and path are correct, and try again.\n\n";
          break;
        case -1:
          err += "(invalid server answer), contact yoctopuce support.";
          break;
        case -2:
          err += prvmsg + " then check path. If path is correct check hub firmware version. This installer doesn't work with versions older that " + this.FIRMWAREMINVERSION + ".";
          break;
        case -3:
          err += "An network error occured, make sure hub address is correct.\n\nAlso connexion migh have been  blocked by your web browser, most likely due to CORS policy.\n\nCheck your browser console (Shift-Control-I on most browsers), if you find an error message about a Cross-Origin Request Blocked over a 404 error, Press '<Prev' and check path carefuly.";
          break;
        case 404:
          err += prvmsg + " make sure the path is correct, and try again.";
          break;
        case 500:
          err += " the hub encountered an interal error (Error 500)";
          break;
        case 503:
          err += " the hub is  not available (Error 503)";
          break;
        case 401:
          err += " Unauthorized access, check server configuration(Error 401)";
          break;
        default:
          err += "server responded with an HTTP error " + infoRes;
          break;
      }
      this.gotoPanel(this.CONNECTIONERROR, err);
      return;
    }
    if (info.serial != "") {
      port = info.port;
      serial = info.serial;
      path = info.path;
      this._currentHub_ReadOnlyProtected = info.userPassword;
    }
    protocol = info.protocol;
    if (info.adminPassword && RW_username == "" && RW_password == "") {
      this.gotoPanel(this.PASSWORDPANEL);
      return;
    }
    await YAPI.DisableExceptions();
    let errmsg = new YErrorMsg();
    if (info.userPassword) {
      let RO_addr = info.get_hubUrl(RO_username, RO_password);
      let RO_res = await YAPI.TestHub(RO_addr, 5e3, errmsg);
      if (RO_res != YAPI.SUCCESS) {
        if (RO_res == YAPI.UNAUTHORIZED) {
          this.gotoPanel(this.PASSWORDPANEL, "ReadOnly test failed, check credentials for read only operations.");
          return;
        } else {
          let err = "Cannot connect to " + url + " : " + errmsg.msg + '.\n\nMake sure the Hub is Up and address is correct, then click the "prev" to try again';
          this.gotoPanel(this.CONNECTIONERROR, err);
          return;
        }
      }
    }
    await YAPI.FreeAPI();
    await YAPI.DisableExceptions();
    let addr = info.get_hubUrl(RW_username, RW_password);
    this._applicationURL = IP + ":" + port.toString() + (path != "" ? "/" + path : "");
    let res = await YAPI.TestHub(addr, 5e3, errmsg);
    if (res != YAPI.SUCCESS) {
      if (res == YAPI.UNAUTHORIZED) {
        this.gotoPanel(this.PASSWORDPANEL);
        return;
      } else {
        let err = "Cannot connect to " + url + " : " + errmsg.msg + '.\n\nMake sure the Hub is Up and address is correct, then click the "prev" to try again';
        this.gotoPanel(this.CONNECTIONERROR, err);
        return;
      }
    }
    await YAPI.FreeAPI();
    await YAPI.DisableExceptions();
    if (await YAPI.RegisterHub(addr, errmsg) != YAPI.SUCCESS) {
      let err = "Cannot connect to " + IP + " : " + errmsg.msg + '.\nMake sure the Hub is Up and address is correct, then click the "prev" to try again';
      this.gotoPanel(this.CONNECTIONERROR, err);
      return;
    }
    let m = YModule.FirstModule();
    while (m != null) {
      if (await m.get_parentHub() == "") {
        let urlMatch = false;
        let serialMatch = await m.get_serialNumber() == serial;
        if (!serialMatch)
          urlMatch = (await m.get_url()).indexOf(IP + ":" + port.toString()) > 0;
        if (serialMatch || urlMatch) {
          this._currentHub = m;
          this._currentHub_RW_username = RW_username;
          this._currentHub_RW_password = RW_password;
          this._currentHub_protocol = protocol;
          this._currentHub_Addr = IP;
          this._currentHub_port = port.toString();
          this._currentHub_path = path;
          if (await m.isReadOnly()) {
            await YAPI.UnregisterHub(await m.get_url());
            this._currentHub = null;
            this.gotoPanel(this.PASSWORDPANEL, "Write test failed, check credentials for read/write operations.");
          } else {
            this.gotoPanel(this.DESCRIPTIONPANEL);
          }
          return;
        }
      }
      m = m.nextModule();
    }
    this.gotoPanel(this.CONNECTIONERROR, "Internal Error, cannot find Hub after RegisterHub call");
  }
  removeCurrentPanelFromHistory() {
    this._history.pop();
  }
  async showConnectionError(visible, goingback, message) {
    if (!visible) {
      if (this._connectiongError != null)
        this._connectiongError.style.display = "none";
      return;
    }
    if (this._connectiongError == null) {
      this._connectiongError = this.createNewContentDiv();
      this._container.appendChild(this._connectiongError);
    }
    this.removeAllChilds(this._connectiongError);
    let Table = document.createElement("TABLE");
    let Row = document.createElement("TR");
    let TD1 = document.createElement("TD");
    TD1.style.whiteSpace = "normal";
    TD1.innerHTML = ressources.FailedIcon("64", true, false, false, false, "oops");
    Row.appendChild(TD1);
    this._ErrMsgContainer = document.createElement("TD");
    this._ErrMsgContainer.style.whiteSpace = "normal";
    this._ErrMsgContainer.style.textAlign = "justify";
    Row.appendChild(this._ErrMsgContainer);
    Table.appendChild(Row);
    this._connectiongError.appendChild(Table);
    this._ErrMsgContainer.innerText = message;
    this._nextButton.visible = false;
    this._prevButton.visible = true;
    this._cancelButton.visible = this.DEFAULTCANCELABLE;
    this._connectiongError.style.display = "";
    let tabIndex = 1;
    this._prevButton.tabIndex = tabIndex++;
    this._prevButton.focus();
  }
  MakeSureCredentialsAreNotEmpty() {
    if (this._currentHub_ReadOnlyProtected) {
      this._nextButton.enabled = this._userPasswordInput.value != "" && this._userNameInput.value != "";
    } else {
      this._nextButton.enabled = true;
    }
    if (this._adminPasswordInput.value == "" || this._adminNameInput.value == "") {
      this._nextButton.enabled = false;
    }
  }
  showPasswordPanel(visible, goingback, err) {
    if (!visible) {
      if (this._pwdPanel != null)
        this._pwdPanel.style.display = "none";
      return;
    }
    let errmsg = typeof err != "undefined" ? err : "Well, looks like this hub requires some authentication.";
    if (this._history[this._history.length - 2] == this.PASSWORDPANEL) {
      errmsg = "Invalid credentials. " + errmsg;
      this.removeCurrentPanelFromHistory();
    }
    if (this._pwdPanel == null) {
      this._pwdPanel = this.createNewContentDiv();
      this._connectionErrorMsg = document.createElement("P");
      this._connectionErrorMsg.style.marginTop = "0px";
      this._pwdPanel.appendChild(this._connectionErrorMsg);
      let Table = document.createElement("TABLE");
      let Row = document.createElement("TR");
      let TD1 = document.createElement("TD");
      TD1.style.whiteSpace = "normal";
      TD1.innerText = "Enter read/write credentials below, these are required for the installation but won't be saved in Yocto-Visualization's configuration.";
      TD1.style.fontSize = "smaller";
      TD1.colSpan = 4;
      Row.appendChild(TD1);
      Table.appendChild(Row);
      Row = document.createElement("TR");
      TD1 = document.createElement("TD");
      TD1.style.whiteSpace = "normal";
      TD1.innerText = "Username:";
      TD1.style.borderLeft = "20px solid transparent";
      TD1.style.fontSize = "smaller";
      Row.appendChild(TD1);
      let TD2 = document.createElement("TD");
      TD2.style.whiteSpace = "normal";
      TD2.style.fontSize = "smaller";
      this._adminNameInput = document.createElement("INPUT");
      this._adminNameInput.size = 12;
      this._adminNameInput.addEventListener("input", () => {
        this.MakeSureCredentialsAreNotEmpty();
      });
      TD2.appendChild(this._adminNameInput);
      Row.appendChild(TD2);
      let TD3 = document.createElement("TD");
      TD3.style.whiteSpace = "normal";
      TD3.innerText = "Password:";
      TD3.style.fontSize = "smaller";
      Row.appendChild(TD3);
      let TD4 = document.createElement("TD");
      TD4.style.whiteSpace = "normal";
      this._adminPasswordInput = document.createElement("INPUT");
      this._adminPasswordInput.type = "password";
      this._adminPasswordInput.size = 12;
      this._adminPasswordInput.addEventListener("input", () => {
        this.MakeSureCredentialsAreNotEmpty();
      });
      TD4.appendChild(this._adminPasswordInput);
      TD4.style.fontSize = "smaller";
      Row.appendChild(TD4);
      this._adminNameInput.value = this.DEFAULTSRVUSERNAME;
      this._adminPasswordInput.value = this.DEFAULTSRVPASSORD;
      Table.appendChild(Row);
      let userRow1 = document.createElement("TR");
      TD1 = document.createElement("TD");
      TD1.style.whiteSpace = "normal";
      TD1.innerText = "\n\nEnter read-only credentials below, these will be saved in the configuration";
      TD1.style.fontSize = "smaller";
      TD1.colSpan = 4;
      userRow1.appendChild(TD1);
      Table.appendChild(userRow1);
      let userRow2 = document.createElement("TR");
      TD1 = document.createElement("TD");
      TD1.style.whiteSpace = "normal";
      TD1.innerText = "Username:";
      TD1.style.borderLeft = "20px solid transparent";
      TD1.style.fontSize = "smaller";
      userRow2.appendChild(TD1);
      TD2 = document.createElement("TD");
      TD2.style.whiteSpace = "normal";
      TD2.style.fontSize = "smaller";
      this._userNameInput = document.createElement("INPUT");
      this._userNameInput.size = 12;
      this._userNameInput.addEventListener("input", () => {
        this.MakeSureCredentialsAreNotEmpty();
      });
      TD2.appendChild(this._userNameInput);
      userRow2.appendChild(TD2);
      TD3 = document.createElement("TD");
      TD3.style.whiteSpace = "normal";
      TD3.innerText = "Password:";
      TD3.style.fontSize = "smaller";
      userRow2.appendChild(TD3);
      TD4 = document.createElement("TD");
      TD4.style.whiteSpace = "normal";
      this._userPasswordInput = document.createElement("INPUT");
      this._userPasswordInput.type = "password";
      this._userPasswordInput.size = 12;
      this._userPasswordInput.addEventListener("input", () => {
        this.MakeSureCredentialsAreNotEmpty();
      });
      TD4.appendChild(this._userPasswordInput);
      TD4.style.fontSize = "smaller";
      userRow2.appendChild(TD4);
      this._userNameInput.value = this.DEFAULTUSER;
      this._userPasswordInput.value = this.DEFAULTPWD;
      Table.appendChild(userRow2);
      Table.style.marginTop = "0px";
      Table.style.marginBottom = "20px";
      this._pwdPanel.appendChild(Table);
      let userCredVisible = "";
      if (!this._currentHub_ReadOnlyProtected) {
        userCredVisible = "none";
        this._userPasswordInput.value = "";
        this._userNameInput.value = "";
      }
      userRow1.style.display = userCredVisible;
      userRow2.style.display = userCredVisible;
      let p = document.createElement("P");
      p.innerText = 'Note: On YoctoHubs and VirtualHub, username is either "user" for readonly or "admin" for read/write. Only ready-only credentials (if any) will saved in the configuration as Yocto-Visualization will ask for read/write credentials when saving, if needed.';
      p.style.fontSize = "smaller";
      this._pwdPanel.appendChild(p);
      this._container.appendChild(this._pwdPanel);
    }
    this._connectionErrorMsg.innerText = errmsg;
    this._nextButton.visible = true;
    this._prevButton.visible = true;
    this._cancelButton.visible = this.DEFAULTCANCELABLE;
    this._pwdPanel.style.display = "";
    let tabIndex = 1;
    this._adminNameInput.tabIndex = tabIndex++;
    this._adminPasswordInput.tabIndex = tabIndex++;
    this._userNameInput.tabIndex = tabIndex++;
    this._userPasswordInput.tabIndex = tabIndex++;
    this._prevButton.tabIndex = tabIndex++;
    this._nextButton.tabIndex = tabIndex++;
    this._adminNameInput.focus();
    this.MakeSureCredentialsAreNotEmpty();
  }
  createTextRow(caption, value) {
    let Row = document.createElement("TR");
    let TD1 = document.createElement("TD");
    TD1.style.whiteSpace = "normal";
    TD1.style.whiteSpace = "nowrap";
    TD1.innerText = caption;
    Row.appendChild(TD1);
    let TD2 = document.createElement("TD");
    TD2.style.whiteSpace = "normal";
    TD2.innerText = value;
    Row.appendChild(TD2);
    return Row;
  }
  async showHubDescription(visible, goingback) {
    if (!visible) {
      if (this._descPanel != null)
        this._descPanel.style.display = "none";
      return;
    }
    if (this._descPanel == null) {
      this._descPanel = this.createNewContentDiv();
      this._container.appendChild(this._descPanel);
    }
    if (!goingback) {
      this.removeAllChilds(this._descPanel);
      this._alreadyInstalled = false;
      let p = document.createElement("P");
      p.innerText = "Sucessfully connected to Hub " + this._ipAddrInput.value;
      this._descPanel.appendChild(p);
      let m = this._currentHub;
      let Table = document.createElement("TABLE");
      Table.style.marginTop = "20px";
      Table.style.marginBottom = "20px";
      let serial = await m.get_serialNumber();
      let firmware = "" + await m.get_firmwareRelease();
      Table.appendChild(this.createTextRow("Model:", await m.get_productName()));
      Table.appendChild(this.createTextRow("Serial:", serial));
      Table.appendChild(this.createTextRow("Firmware:", firmware));
      let tmp = firmware.lastIndexOf(".");
      if (tmp >= 0)
        firmware = firmware.substr(tmp + 1);
      this._instancesFiles = [];
      let freespace = 0;
      this._instancesFiles = [];
      this._currentfs = null;
      let error = "";
      if (firmware.indexOf("-") < 0 && parseInt(firmware) < this.FIRMWAREMINVERSION) {
        error = "Hub firmware is too old for Yocto-Visualization to run properly. You need at least version " + this.FIRMWAREMINVERSION;
        this._nextButton.enabled = false;
      }
      if (error == "") {
        let ids = await m.get_functionIds("Files");
        if (ids.length > 0) {
          this._currentfs = await YFiles.FindFiles(serial + "." + ids[0]);
          freespace = Math.floor(await this._currentfs.get_freeSpace() / 1024);
          this._instancesFiles = await this._currentfs.get_list("yv4web*");
          Table.appendChild(this.createTextRow("Free space:", freespace.toString() + "K"));
          this._nextButton.enabled = true;
          if (freespace < 200) {
            error = "Not enough free space on device, please make sure there is at least 200K available.";
            this._nextButton.enabled = false;
          }
        } else {
          error = "No filesystem found on hub. On VirtualHub, the filesystem feature needs to be explicitely enabled at startup with the -F flag.";
        }
      }
      if (error != "") {
        Table.appendChild(this.createTextRow(" ", " "));
        let Row = document.createElement("TR");
        let TD1 = document.createElement("TD");
        TD1.style.whiteSpace = "normal";
        TD1.innerHTML = ressources.FailedIcon("32", true, false, false, false, "oops");
        TD1.style.textAlign = "right";
        Row.appendChild(TD1);
        let TD2 = document.createElement("TD");
        TD2.style.whiteSpace = "normal";
        TD2.style.fontSize = "smaller";
        TD2.innerText = error;
        Row.appendChild(TD2);
        Table.appendChild(Row);
        this._nextButton.enabled = false;
      }
      this._descPanel.appendChild(Table);
      if (this._instancesFiles.length > 0) {
        let p2 = document.createElement("P");
        p2.innerText = "Yocto-Visualization (for web) appears to be already installed on this hub. Click on next to modify this installation.";
        this._descPanel.appendChild(p2);
        this._alreadyInstalled = true;
      }
    }
    this._descPanel.style.display = "";
    this._nextButton.visible = true;
    this._prevButton.visible = true;
    this._cancelButton.visible = this.DEFAULTCANCELABLE;
    let tabIndex = 1;
    this._prevButton.tabIndex = tabIndex++;
    this._nextButton.tabIndex = tabIndex++;
    this._nextButton.focus();
  }
  async loadWebPagesList(filenameDesc) {
    this._webPageinstances = [];
    let webFiles = await this._currentfs.get_list("*");
    for (let i = 0; i < webFiles.length; i++) {
      let filename = await webFiles[i].get_name();
      if (filename.indexOf(".html") >= 0) {
        if (filenameDesc != null) {
          filenameDesc.innerText = "Now downloading " + filename + "...";
        }
        let contents = await this._currentfs.download(filename);
        if (filename.slice(-3) == ".gz") {
          contents = Pako_Inflate.ungzip(contents, {});
        }
        let contentsStr = YAPI.imm_bin2str(contents);
        if (contentsStr.indexOf("window.runYV()") > 0) {
          this._webPageinstances.push(new pageInstance(filename, contents));
        }
      }
    }
  }
  async showModifyInstallPanel(visible, goingback) {
    if (!visible) {
      if (this._modifyInstallPanel != null)
        this._modifyInstallPanel.style.display = "none";
      return;
    }
    this._nextButton.visible = false;
    this._prevButton.visible = false;
    this._cancelButton.visible = false;
    if (this._modifyInstallPanel == null) {
      this._modifyInstallPanel = this.createNewContentDiv();
      this._container.appendChild(this._modifyInstallPanel);
    }
    if (!goingback) {
      this.removeAllChilds(this._modifyInstallPanel);
      this._jsCodeinstances = [];
      this._webPageinstances = [];
      let p = document.createElement("P");
      p.innerText = "Please wait, downloading and parsing files from the hub ";
      this._modifyInstallPanel.appendChild(p);
      this._modifyInstallPanel.style.display = "";
      let files = document.createElement("P");
      files.innerText = "";
      let filenameDesc = document.createElement("P");
      filenameDesc.style.fontSize = "smaller";
      this._modifyInstallPanel.appendChild(filenameDesc);
      for (let i = 0; i < this._instancesFiles.length; i++) {
        let filename = await this._instancesFiles[i].get_name();
        filenameDesc.innerText = "Now downloading " + filename + "...";
        files.innerText = filename;
        let contentsStr = "";
        let contents = await this._currentfs.download(filename);
        if (filename.slice(-3) == ".gz") {
          contents = Pako_Inflate.ungzip(contents, {});
        }
        contentsStr = YAPI.imm_bin2str(contents);
        let esTarget = "";
        let version = "";
        let readonlyVersion = true;
        let p2 = contentsStr.indexOf("*/");
        if (p2 > 0) {
          let firstLine = contentsStr.slice(0, p2);
          let p1 = firstLine.indexOf("(");
          let p22 = firstLine.indexOf(")");
          if (p1 > 0 && p22 > p1) {
            let tokens = firstLine.slice(p1 + 1, p22).split(" ");
            if (tokens.length > 0)
              esTarget = tokens[0];
            if (tokens.length > 1)
              readonlyVersion = tokens[1] != "full";
            if (tokens.length > 2)
              version = tokens[2];
          }
        }
        this._jsCodeinstances.push(new codeInstance(filename, esTarget, version, readonlyVersion));
      }
      await this.loadWebPagesList(filenameDesc);
      filenameDesc.style.display = "none";
      p.innerText = "What would you like to do ?";
      let uninstallLegend = document.createElement("span");
      uninstallLegend.innerText = "Uninstall / delete all Yocto-Visualization (for web) related files\n\n";
      this._uninstallOpt = document.createElement("input");
      this._uninstallOpt.setAttribute("type", "radio");
      this._uninstallOpt.setAttribute("name", "installType");
      this._modifyInstallPanel.appendChild(this._uninstallOpt);
      this._modifyInstallPanel.appendChild(uninstallLegend);
      let BuildsFound = {};
      for (let i = 0; i < this._jsCodeinstances.length; i++) {
        BuildsFound[this._jsCodeinstances[i].version] = 1;
      }
      let BuildsFoundList = "";
      for (let key in BuildsFound) {
        if (BuildsFound.hasOwnProperty(key)) {
          BuildsFoundList += (BuildsFoundList != "" ? ", " : "") + key;
        }
      }
      let updateLegend = document.createElement("span");
      updateLegend.innerText = "Update all from " + BuildsFoundList + " to " + constants.buildVersion + "\n\n";
      this._updateOpt = document.createElement("input");
      this._updateOpt.setAttribute("type", "radio");
      this._updateOpt.setAttribute("name", "installType");
      this._modifyInstallPanel.appendChild(this._updateOpt);
      this._modifyInstallPanel.appendChild(updateLegend);
      let addInstanceLegend = document.createElement("span");
      addInstanceLegend.innerText = "Add a new instance \n\n";
      this._addInstanceOpt = document.createElement("input");
      this._addInstanceOpt.setAttribute("type", "radio");
      this._addInstanceOpt.setAttribute("name", "installType");
      this._modifyInstallPanel.appendChild(this._addInstanceOpt);
      this._modifyInstallPanel.appendChild(addInstanceLegend);
      let modInstanceLegend = document.createElement("span");
      modInstanceLegend.innerText = "Modify or delete existing instances \n\n";
      this._modInstanceOpt = document.createElement("input");
      this._modInstanceOpt.setAttribute("type", "radio");
      this._modInstanceOpt.setAttribute("name", "installType");
      this._modifyInstallPanel.appendChild(this._modInstanceOpt);
      this._modifyInstallPanel.appendChild(modInstanceLegend);
      if (!this._uninstallOpt.checked && !this._updateOpt.checked && !this._addInstanceOpt.checked && !this._modInstanceOpt.checked) {
        this._updateOpt.checked = true;
      }
    }
    this._modifyInstallPanel.style.display = "";
    this._nextButton.enabled = true;
    this._prevButton.enabled = true;
    this._nextButton.visible = true;
    this._prevButton.visible = true;
    this._cancelButton.visible = this.DEFAULTCANCELABLE;
    let tabIndex = 1;
    this._uninstallOpt.tabIndex = tabIndex++;
    this._updateOpt.tabIndex = tabIndex++;
    this._addInstanceOpt.tabIndex = tabIndex++;
    this._modInstanceOpt.tabIndex = tabIndex++;
    this._prevButton.tabIndex = tabIndex++;
    this._nextButton.tabIndex = tabIndex++;
    this._nextButton.focus();
  }
  async showModInstancesPanel(visible, goingback) {
    if (!visible) {
      if (this._modInstancesPanel != null)
        this._modInstancesPanel.style.display = "none";
      return;
    }
    if (this._modInstancesPanel == null) {
      this._modInstancesPanel = this.createNewContentDiv();
      this._container.appendChild(this._modInstancesPanel);
    }
    let tabIndex = 1;
    if (!goingback) {
      this.removeAllChilds(this._modInstancesPanel);
      let p = document.createElement("P");
      this._modInstancesPanel.appendChild(p);
      p.innerText = "Here is a list of installed instances. Select an action for each one, then click on next to have them applied.";
      let table = document.createElement("Table");
      table.style.marginLeft = "20px";
      for (let i = 0; i < this._webPageinstances.length; i++) {
        let tr = document.createElement("TR");
        let td = document.createElement("TD");
        td.style.whiteSpace = "normal";
        td.innerText = this._webPageinstances[i].http_filename + (this._webPageinstances[i].compressed ? "[.gz]" : "");
        tr.appendChild(td);
        let td2 = document.createElement("TD");
        td2.style.whiteSpace = "normal";
        td2.style.paddingLeft = "10px";
        let chooser = document.createElement("SELECT");
        chooser.tabIndex = tabIndex++;
        let opt = document.createElement("OPTION");
        opt.tabIndex = tabIndex++;
        opt.text = "Do Nothing";
        opt.value = this._MODIFYNOTHING.toString();
        chooser.add(opt);
        let opt2 = document.createElement("OPTION");
        if (this._webPageinstances[i].compressed) {
          opt2.text = "Uncompress instance file";
          opt2.value = this._MODIFYUNCOMPRESS.toString();
        } else {
          opt2.text = "Compress instance file";
          opt2.value = this._MODIFYCOMPRESS.toString();
        }
        chooser.add(opt2);
        let opt3 = document.createElement("OPTION");
        if (this._webPageinstances[i].readonly) {
          opt3.text = "Allow read/write";
          opt3.value = this._MODIFYMAKEREADWRITE.toString();
        } else {
          opt3.text = "Make read only";
          opt3.value = this._MODIFYMAKEREADONLY.toString();
        }
        chooser.add(opt3);
        let opt4 = document.createElement("OPTION");
        if (this._webPageinstances[i].useMinified) {
          opt4.text = "Use human readable JS module";
          opt4.value = this._MODIFYUSEPLAIN.toString();
        } else {
          opt4.text = "Use minified JS module";
          opt4.value = this._MODIFYUSEMINIFIED.toString();
        }
        chooser.add(opt4);
        let opt5 = document.createElement("OPTION");
        opt5.text = "Update credentials";
        opt5.value = this._MODIFYUPDATE.toString();
        chooser.add(opt5);
        let opt6 = document.createElement("OPTION");
        opt6.text = "Delete (cannot be reverted)";
        opt6.value = this._MODIFYDELETE.toString();
        chooser.add(opt6);
        let index = i;
        chooser.addEventListener("change", () => {
          this._webPageinstances[index].action = Number(chooser.value);
        });
        td2.appendChild(chooser);
        tr.appendChild(td2);
        table.appendChild(tr);
      }
      this._modInstancesPanel.appendChild(table);
      let p2 = document.createElement("P");
      this._removeUnusedJs = document.createElement("INPUT");
      this._removeUnusedJs.tabIndex = tabIndex++;
      this._removeUnusedJs.type = "checkbox";
      this._removeUnusedJs.checked = true;
      p2.appendChild(this._removeUnusedJs);
      let span = document.createElement("SPAN");
      span.innerText = "Remove unused Yocto-Visualization (for web) JS module files";
      p2.appendChild(span);
      this._modInstancesPanel.appendChild(p2);
      this._prevButton.tabIndex = tabIndex++;
      this._nextButton.tabIndex = tabIndex++;
      this._nextButton.focus();
    }
    this._modInstancesPanel.style.display = "";
  }
  async showCustomFilesPanel(visible, goingback) {
    if (!visible) {
      if (this._customFilesPanel != null)
        this._customFilesPanel.style.display = "none";
      return;
    }
    if (this._customFilesPanel == null) {
      this._customFilesPanel = this.createNewContentDiv();
      this._container.appendChild(this._customFilesPanel);
    }
    if (!goingback) {
      this.removeAllChilds(this._customFilesPanel);
      let p = document.createElement("P");
      p.innerText = this._plannedaction == this.ACTIONINSTALL ? "Optionnaly, you can customize your Yocto-Visualization (for web) installation by providing some files" : "Optionnaly, you can customize your new instance by providing some files";
      this._customFilesPanel.appendChild(p);
      let Table = document.createElement("TABLE");
      Table.style.fontSize = "smaller";
      Table.style.marginTop = "20px";
      Table.style.marginBottom = "20px";
      let Row;
      let TD1;
      let TD2;
      Row = document.createElement("TR");
      TD1 = document.createElement("TD");
      TD1.style.whiteSpace = "normal";
      TD1.colSpan = 2;
      TD1.style.textAlign = "justify";
      TD1.innerText = 'You can choose an initial XML configuration file. You can get a XML configuration file from a Yocto-Visualization (for web) instance in the  "Global configulation" panel. You can also use a config.xml file from the Yocto-Visualization native version.';
      Row.appendChild(TD1);
      Table.appendChild(Row);
      Row = document.createElement("TR");
      TD1 = document.createElement("TD");
      TD1.style.whiteSpace = "normal";
      TD1.innerText = "Config file:";
      Row.appendChild(TD1);
      TD2 = document.createElement("TD");
      TD2.style.whiteSpace = "normal";
      this._configFileInput = document.createElement("INPUT");
      this._configFileInput.type = "file";
      this._configFileInput.accept = ".xml";
      TD2.appendChild(this._configFileInput);
      Row.style.marginBottom = "10px";
      Row.appendChild(TD2);
      Table.appendChild(Row);
      Row = document.createElement("TR");
      TD1 = document.createElement("TD");
      TD1.style.whiteSpace = "normal";
      TD1.colSpan = 2;
      TD1.style.textAlign = "justify";
      TD1.innerText = "\nYou can choose a container HTML file. Note: if this file relies on local dependencies such as images or CSS files, you'll have to upload them on the hub yourself.";
      Row.appendChild(TD1);
      Table.appendChild(Row);
      this._customFilesPanel.appendChild(Table);
      Row = document.createElement("TR");
      TD1 = document.createElement("TD");
      TD1.style.whiteSpace = "normal";
      TD1.innerText = "HTML file:";
      Row.appendChild(TD1);
      TD2 = document.createElement("TD");
      TD2.style.whiteSpace = "normal";
      this._webPageInput = document.createElement("INPUT");
      this._webPageInput.type = "file";
      this._webPageInput.accept = ".html";
      TD2.appendChild(this._webPageInput);
      Row.appendChild(TD2);
      Table.appendChild(Row);
    }
    this._customFilesPanel.style.display = "";
    this._nextButton.enabled = true;
    this._prevButton.enabled = true;
    this._nextButton.visible = true;
    this._prevButton.visible = true;
    this._cancelButton.visible = this.DEFAULTCANCELABLE;
    let tabIndex = 1;
    this._webPageInput.tabIndex = tabIndex++;
    this._configFileInput.tabIndex = tabIndex++;
    this._prevButton.tabIndex = tabIndex++;
    this._nextButton.tabIndex = tabIndex++;
    this._nextButton.focus();
  }
  async showOptionsPanel(visible, goingback) {
    if (!visible) {
      if (this._optionsPanel != null)
        this._optionsPanel.style.display = "none";
      return;
    }
    if (this._optionsPanel == null) {
      this._optionsPanel = this.createNewContentDiv();
      let p = document.createElement("P");
      p.innerText = this._plannedaction == this.ACTIONINSTALL ? "You can also customize the installation behavior" : "You can also customize this new instance behavior";
      this._optionsPanel.appendChild(p);
      p = document.createElement("P");
      p.style.fontSize = "smaller";
      p.style.marginBottom = "0px";
      p.style.marginTop = "0px";
      this._fileprefixInput = document.createElement("INPUT");
      let presetname = this.DEFAULTFILEPREFIX;
      let n = 1;
      let checkgain = false;
      do {
        checkgain = false;
        for (let i = 0; i < this._webPageinstances.length; i++) {
          if (presetname + this.TARGETEXTENSION == this._webPageinstances[i].http_filename) {
            n++;
            presetname = this.DEFAULTFILEPREFIX + "(" + n.toString() + ")";
            checkgain = true;
          }
        }
      } while (checkgain);
      this._fileprefixInput.value = presetname;
      this._fileprefixInput.maxLength = 10;
      this._fileprefixInput.size = 10;
      let span = document.createElement("SPAN");
      span.innerText = "Set the instance name to : ";
      p.appendChild(span);
      p.appendChild(this._fileprefixInput);
      this._optionsPanel.appendChild(p);
      p = document.createElement("P");
      p.style.fontSize = "smaller";
      p.style.marginBottom = "0px";
      p.style.marginTop = "0px";
      this._useFullVersionInput = document.createElement("INPUT");
      this._useFullVersionInput.type = "checkbox";
      p.appendChild(this._useFullVersionInput);
      span = document.createElement("SPAN");
      span.innerText = this._plannedaction == this.ACTIONINSTALL ? "Install the non-minified version (easier to debug)" : "Use the non-minified version (easier to debug)";
      p.appendChild(span);
      this._optionsPanel.appendChild(p);
      p = document.createElement("P");
      p.style.fontSize = "smaller";
      p.style.marginBottom = "0px";
      p.style.marginTop = "0px";
      this._makeDefaultInput = document.createElement("INPUT");
      this._makeDefaultInput.type = "checkbox";
      p.appendChild(this._makeDefaultInput);
      span = document.createElement("SPAN");
      span.innerText = this._plannedaction == this.ACTIONINSTALL ? "Make Yocto-Visualization (for web) the hub's default page" : "Make this instance the hub's default page";
      p.appendChild(span);
      this._optionsPanel.appendChild(p);
      p = document.createElement("P");
      p.style.fontSize = "smaller";
      p.style.marginBottom = "0px";
      p.style.marginTop = "0px";
      this._useReadOnlyInput = document.createElement("INPUT");
      this._useReadOnlyInput.type = "checkbox";
      p.appendChild(this._useReadOnlyInput);
      span = document.createElement("SPAN");
      span.innerText = this._plannedaction == this.ACTIONINSTALL ? "Make the install read-only" : "Make this instance read-only";
      p.appendChild(span);
      this._optionsPanel.appendChild(p);
      if (this._jsCodeinstances.length > 0) {
        this._useReadOnlyInput.checked = this._jsCodeinstances[0].readonly;
        this._useFullVersionInput.checked = !this._jsCodeinstances[0].minified;
      }
      p = document.createElement("P");
      p.innerText = 'Click on "Next" button to start the installation';
      this._optionsPanel.appendChild(p);
      this._container.appendChild(this._optionsPanel);
    }
    this._nextButton.visible = true;
    this._prevButton.visible = true;
    this._cancelButton.visible = this.DEFAULTCANCELABLE;
    this._optionsPanel.style.display = "";
    let tabIndex = 1;
    this._fileprefixInput.tabIndex = tabIndex++;
    this._useFullVersionInput.tabIndex = tabIndex++;
    this._makeDefaultInput.tabIndex = tabIndex++;
    this._useReadOnlyInput.tabIndex = tabIndex++;
    this._prevButton.tabIndex = tabIndex++;
    this._nextButton.tabIndex = tabIndex++;
    this._nextButton.focus();
  }
  logLine(line) {
    let p = document.createElement("P");
    p.innerText = line + " ";
    p.style.fontSize = "smaller";
    p.style.marginLeft = "10px";
    p.style.marginTop = "0px;";
    p.style.marginBottom = "0px;";
    p.style.paddingTop = "0px;";
    p.style.paddingBottom = "0px;";
    let span = document.createElement("SPAN");
    p.appendChild(span);
    this._runPanel.appendChild(p);
    return span;
  }
  async showRunPanel(visible, goingback) {
    if (!visible) {
      if (this._runPanel != null)
        this._runPanel.style.display = "none";
      return;
    }
    if (this._runPanel == null) {
      this._runPanel = this.createNewContentDiv();
    }
    this.removeAllChilds(this._runPanel);
    this._runPanel.style.display = "";
    let desc = document.createElement("P");
    this._runPanel.appendChild(desc);
    this._container.appendChild(this._runPanel);
    this._nextButton.visible = false;
    this._prevButton.visible = false;
    this._cancelButton.visible = false;
    switch (this._plannedaction) {
      case this.ACTIONINSTALL:
        desc.innerText = "Installing on " + this._currentHub_Addr + "... please wait.";
        try {
          await this.install((line) => {
            return this.logLine(line);
          });
        } catch (e) {
          this.gotoPanel(this.CONNECTIONERROR, "Installation failed with an internal error : " + e.toString() + "\n\nFeel free to contact Yoctopuce support.");
        }
        break;
      case this.ACTIONADDINSTANCE:
        desc.innerText = "Creating new instance  on " + this._currentHub_Addr + "... please wait.";
        try {
          await this.install((line) => {
            return this.logLine(line);
          });
        } catch (e) {
          this.gotoPanel(this.CONNECTIONERROR, "Instance creation failed with an internal error : " + e.toString() + "\n\nFeel free to contact Yoctopuce support.");
        }
        break;
      case this.ACTIONUNINSTALL:
        desc.innerText = "Uninstalling everything from " + this._currentHub_Addr + "... please wait.";
        try {
          await this.uninstall((line) => {
            return this.logLine(line);
          });
        } catch (e) {
          this.gotoPanel(this.CONNECTIONERROR, "Installation failed with an internal error : " + e.toString() + "\n\nFeel free to contact Yoctopuce support.");
        }
        break;
      case this.ACTIONUPDATE:
        desc.innerText = "Updating js files on " + this._currentHub_Addr + "... please wait.";
        try {
          await this.upgrade((line) => {
            return this.logLine(line);
          });
        } catch (e) {
          this.gotoPanel(this.CONNECTIONERROR, "Update failed with an internal error : " + e.toString() + "\n\nFeel free to contact Yoctopuce support.");
        }
        break;
      case this.ACTIONMODINSTANCE:
        desc.innerText = "Modifying instances on " + this._currentHub_Addr + "... please wait.";
        try {
          await this.modifyInstances((line) => {
            return this.logLine(line);
          });
        } catch (e) {
          this.gotoPanel(this.CONNECTIONERROR, "Instances modification failed with an internal error : " + e.toString() + "\n\nFeel free to contact Yoctopuce support.");
        }
        break;
    }
  }
  checkHTMLfile(htmlData, errmsg) {
    let upper = htmlData.toUpperCase();
    if (upper.indexOf("<HTML") < 0) {
      errmsg.msg = "Provided web page is not a proper HTML file: no HTML tag";
      return false;
    }
    if (upper.indexOf("</BODY>") < 0) {
      errmsg.msg = "Provided web page has an unexpected structure: no closing BODY tag";
      return false;
    }
    return true;
  }
  checkConfigfile(xmlData, errmsg) {
    let parser = new DOMParser();
    let doc = parser.parseFromString(xmlData, "application/xml");
    let root = null;
    doc.childNodes.forEach((node) => {
      if (node.nodeName.toUpperCase() == "ROOT" && root == null)
        root = node;
    });
    if (root == null) {
      errmsg.msg = "Provided config XML file is not a proper YoctoVisualization 2 config file. Unable to find ROOT node, either the root node does not exists or the file caused an XML parse error.";
      return false;
    }
    let rootNode = new YXmlNode(root);
    let attributes = rootNode.Attributes;
    if (!attributes.hasOwnProperty("version")) {
      errmsg.msg = "Provided  XML config file is not a proper Yocto-Visualization 2 config file (No ROOT Version attribute)";
      return false;
    }
    if (parseFloat(attributes["version"]) < 2) {
      errmsg.msg = "Provided XML config file is not a proper Yocto-Visualization 2 config file (at least Version 2.0 is required)";
      return false;
    }
    return true;
  }
  findChild(parent, name) {
    let res = null;
    parent.childNodes.forEach((node) => {
      if (node.nodeName == name) {
        res = node;
        return;
      }
    });
    return res;
  }
  patchConfigFile(xmlData) {
    let startTag = "<Hubs>";
    let endTag = "</Hubs>";
    let parser = new DOMParser();
    let doc = parser.parseFromString(xmlData, "application/xml");
    let rootNode = this.findChild(doc, "ROOT");
    if (rootNode == null)
      throw "No root node in config file.";
    let configNode = this.findChild(rootNode, "Config");
    if (configNode == null)
      throw "No config node in config file.";
    let Hubs = this.findChild(configNode, "Hubs");
    let HubSection;
    if (Hubs == null) {
      HubSection = startTag + "\n" + this.getHubConfig() + "\n" + endTag + "\n";
      xmlData = xmlData.replace("<Config>", "<Config>\n" + HubSection);
    } else {
      let list = Hubs.childNodes;
      let sourceHubFound = false;
      HubSection = startTag + "\n";
      for (let i = 0; i < list.length; i++) {
        if (list[i].nodeName == "Hub") {
          let node = new YXmlNode(list[i]);
          let attributes = node.Attributes;
          let addr = attributes.hasOwnProperty("addr") ? attributes["addr"] : "";
          let port = attributes.hasOwnProperty("port") ? attributes["port"] : "80";
          let protocol = attributes.hasOwnProperty("protocol") ? attributes["protocol"] : "";
          let path = attributes.hasOwnProperty("path") ? attributes["path"] : "";
          let username = attributes.hasOwnProperty("user") ? attributes["user"] : "";
          let password = attributes.hasOwnProperty("password") ? attributes["password"] : "";
          if (!sourceHubFound && addr == this._currentHub_Addr && port == this._currentHub_port && path == this._currentHub_path) {
            sourceHubFound = true;
            HubSection += "    " + this.getHubConfig() + "\n";
          } else {
            HubSection += "    " + this.createHubRecord(protocol, addr, port, path, username, password, true) + "\n";
          }
        }
      }
      if (!sourceHubFound)
        HubSection += "    " + this.getHubConfig() + "\n";
      HubSection += "  ";
      let indexStart = xmlData.indexOf(startTag);
      let indexStop = xmlData.indexOf(endTag);
      if (indexStart < 0)
        throw "Cannot locate Hubs start tag in provided  config file";
      if (indexStop < 0)
        throw "Cannot locate Hubs end tag in provided  config file";
      xmlData = xmlData.substr(0, indexStart) + HubSection + xmlData.substr(indexStop);
    }
    return xmlData;
  }
  createHubRecord(protocol, addr, port, path, username, password, removable) {
    let res = '<Hub protocol="' + constants.XMLquote(protocol) + '" addr="' + constants.XMLquote(addr) + '" port="' + constants.XMLquote(port) + '"';
    if (path != "")
      res += ' path="' + constants.XMLquote(path) + '"';
    if (username != "")
      res += ' user="' + constants.XMLquote(username) + '"';
    if (password != "")
      res += ' password="' + constants.XMLquote(password) + '"';
    if (!removable)
      res += ' removable="FALSE"';
    res += "/>";
    return res;
  }
  getHubConfig() {
    let username = "";
    let password = "";
    if (this._currentHub_ReadOnlyProtected) {
      username = this._userNameInput.value;
      password = Hub.encryptPassword(this._userPasswordInput.value);
    }
    return this.createHubRecord(this._currentHub_protocol, this._currentHub_Addr, this._currentHub_port, this._currentHub_path, username, password, false);
  }
  getSeedCode(configfile, readonly, minified) {
    let res = '\n<script type="module">\n';
    if (configfile == null)
      configfile = '<?xml version="1.0" ?><ROOT version="2.1"><Config><Hubs>' + this.getHubConfig() + "</Hubs></Config></ROOT>\n";
    let filename = "yv4web-" + (readonly ? "readonly" : "full") + (minified ? ".min" : "") + ".js";
    res += ' import { YWebPage, YoctoHubFileHandler }  from "./' + filename + '";\n';
    res += " window.runYV= async ()=>{";
    res += " let filehandler = await YoctoHubFileHandler.start(";
    if (configfile != null)
      res += JSON.stringify(configfile);
    res += ");\n";
    res += "  YWebPage.run(filehandler.xmlConfigData, filehandler.configChangeCallbackFct";
    if (!readonly)
      res += ",filehandler.saveFct";
    res += ");\n";
    res += "};\n window.runYV();</script>\n";
    res += '<script nomodule="">\n';
    res += `document.write("<p style='font-family: sans-serif; text-align:center'>Yocto-Visualization (for web) cannot run on this browser. Sorry.<br>Consider using a more recent browser, or <a href='https://www.yoctopuce.com/EN/tools.php'>the native version</a>. </p>")
`;
    res += "</script>\n";
    return res;
  }
  defaultHTMLfile(configfile, readonly, minified) {
    return "<!DOCTYPE HTML>\n<HTML lang='en-US'><HEAD>\n<title>\nYocto-Visualization</title>\n" + this.icon + "\n<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no'/></HEAD>\n<BODY>\n</BODY>" + this.getSeedCode(configfile, readonly, minified) + "\n</HTML>\n";
  }
  async uploadWidthProgress(str_path, bin_content, progress) {
    let yreq = await this._currentfs._uploadWithProgress(str_path, bin_content, progress);
    return yreq.errorType;
  }
  async upgrade(log) {
    let install_minified_readonly = false;
    let install_plain_readonly = false;
    let install_minified_readwrite = false;
    let install_plain_readwrite = false;
    for (let i = 0; i < this._jsCodeinstances.length; i++) {
      if (this._jsCodeinstances[i].minified) {
        if (this._jsCodeinstances[i].readonly) {
          install_minified_readonly = true;
        } else {
          install_minified_readwrite = true;
        }
      } else {
        if (this._jsCodeinstances[i].readonly) {
          install_plain_readonly = true;
        } else {
          install_plain_readwrite = true;
        }
      }
    }
    if (install_minified_readonly)
      await this.copyJsCode(log, true, true);
    if (install_plain_readonly)
      await this.copyJsCode(log, true, false);
    if (install_minified_readwrite)
      await this.copyJsCode(log, false, true);
    if (install_plain_readwrite)
      await this.copyJsCode(log, false, false);
    log("Done.");
    setTimeout(() => {
      this.gotoPanel(this.DONEPANEL);
    }, 2e3);
  }
  async syncJsFile(log, required, readonly, minified, removeunused) {
    let jsfile = this.get_js_filename(readonly, minified) + ".gz";
    let exists = await this._currentfs.fileExist(jsfile);
    if (required && !exists)
      await this.copyJsCode(log, readonly, minified);
    if (!required && exists && removeunused) {
      let span = log("Deleting " + jsfile);
      await this._currentfs.remove(jsfile);
      span.innerText = "done.";
    }
  }
  async syncJsFileVersions(log, removeunused) {
    let require_minified_readonly = false;
    let require_plain_readonly = false;
    let require_minified_readwrite = false;
    let require_plain_readwrite = false;
    for (let i = 0; i < this._webPageinstances.length; i++) {
      if (this._webPageinstances[i].useMinified) {
        if (this._webPageinstances[i].readonly) {
          require_minified_readonly = true;
        } else {
          require_minified_readwrite = true;
        }
      } else {
        if (this._webPageinstances[i].readonly) {
          require_plain_readonly = true;
        } else {
          require_plain_readwrite = true;
        }
      }
    }
    await this.syncJsFile(log, require_minified_readonly, true, true, removeunused);
    await this.syncJsFile(log, require_plain_readonly, true, false, removeunused);
    await this.syncJsFile(log, require_minified_readwrite, false, true, removeunused);
    await this.syncJsFile(log, require_plain_readwrite, false, false, removeunused);
  }
  async setInstanceCredentials(log, page, hubaddr, hubpath, newusername, newpwd) {
    let contents = YAPI.imm_bin2str(page.contents);
    let start = contents.indexOf("<Hub ");
    let mustupload = false;
    let end;
    while (start > 0) {
      let end2 = contents.indexOf("/>", start);
      if (end2 > start) {
        let hubline = contents.substring(start, end2 + 2);
        while (hubline.indexOf('\\"') > 0)
          hubline = hubline.replace('\\"', '"');
        let state = 0;
        let key = "";
        let value = "";
        let data = [];
        let parseError = false;
        for (let i = 4; i < hubline.length - 1 && !parseError; i++) {
          let c = hubline.charAt(i);
          switch (state) {
            case 0:
              if (c >= "A" && c <= "Z" || c >= "a" && c <= "z") {
                key = c;
                state = 1;
              } else if (c != " ")
                parseError = true;
              break;
            case 1:
              if (c >= "A" && c <= "Z" || c >= "a" && c <= "z" || c >= "0" && c <= "9" || c == "_")
                key = key + c;
              else if (c == " ")
                state = 2;
              else if (c == "=")
                state = 3;
              else
                parseError = true;
              break;
            case 2:
              if (c == "=")
                state = 3;
              else if (c != " ")
                parseError = true;
              break;
            case 3:
              if (c == '"')
                state = 4;
              else if (c == "'")
                state = 5;
              else if (c != " ")
                parseError = true;
              break;
            case 4:
              if (c == '"')
                state = 6;
              else
                value = value + c;
              break;
            case 5:
              if (c == "'")
                state = 6;
              else
                value = value + c;
              break;
            case 6:
              data.push([key, value]);
              key = "";
              value = "";
              state = 0;
              break;
          }
        }
        if (state != 0 || parseError)
          log("hub definition parse error");
        else {
          let addrok = false;
          let pathok = false;
          for (let i = 0; i < data.length; i++) {
            if (data[i][0] == "addr" && data[i][1].toUpperCase() == hubaddr.toUpperCase())
              addrok = true;
            if (data[i][0] == "path" && data[i][1] == hubpath)
              pathok = true;
          }
          if (addrok && pathok) {
            {
              for (let i = data.length - 1; i >= 0; i--)
                if (data[i][0] == "user" || data[i][0] == "password")
                  data.splice(i, 1);
            }
            if (newusername != "" && newpwd != "") {
              let p = Hub.Encrypt(newpwd, Hub.loginCypherPassword);
              data.splice(1, 0, ["user", "user"]);
              data.splice(2, 0, ["password", p]);
            }
            let newhubline = "<Hub ";
            for (let i = 0; i < data.length; i++) {
              newhubline += data[i][0] + '=\\"' + data[i][1] + '\\"' + (i < data.length - 1 ? " " : "");
            }
            contents = contents.substring(0, start) + newhubline + contents.substring(end2);
            mustupload = true;
          }
        }
        start = contents.indexOf("<Hub ", start + 4);
      }
    }
    if (mustupload)
      this.uploadpage(log, page, contents);
  }
  async patchPageInstance(log, page, signature1, replace1, altsignature1, altreplace1, signature2, replace2) {
    let contents = YAPI.imm_bin2str(page.contents);
    let p = contents.indexOf(signature1);
    if (p < 0 && altsignature1 != "") {
      signature1 = altsignature1;
      replace1 = altreplace1;
      p = contents.indexOf(signature1);
    }
    if (p < 0)
      throw "Operation failed: cannot find the [" + signature1 + "] import signature in " + page.fs_filename;
    contents = contents.substr(0, p) + replace1 + contents.substr(p + signature1.length);
    if (signature2 != "") {
      p = contents.indexOf(signature2);
      if (p < 0)
        throw "Operation failed: cannot find the [" + signature2 + "] signature parameter in " + page.fs_filename;
      contents = contents.substr(0, p) + replace2 + contents.substr(p + signature2.length);
    }
    this.uploadpage(log, page, contents);
  }
  async uploadpage(log, page, contents) {
    let bincontents = YAPI.imm_str2bin(contents);
    let filename = page.fs_filename;
    if (page.compressed) {
      let status2 = log("Compressing  " + filename);
      bincontents = Pako_Deflate.gzip(bincontents, {level: 9});
      status2.innerText = "done";
    }
    let status = log("Uploading  " + filename + " to hub");
    status.innerText = "0%";
    let success = await this.uploadWidthProgress(filename, bincontents, (curr, total) => {
      status.innerText = Math.round(100 * curr / total).toString() + "%";
    });
    status.innerText = "done";
    if (success != YAPI_SUCCESS)
      throw "Upload failed (Error" + success.toString() + ").";
  }
  async modifyInstances(log) {
    for (let i = 0; i < this._webPageinstances.length; i++) {
      switch (this._webPageinstances[i].action) {
        case this._MODIFYNOTHING:
          break;
        case this._MODIFYDELETE:
          let span = log("Deleting " + this._webPageinstances[i].fs_filename);
          await this._currentfs.remove(this._webPageinstances[i].fs_filename);
          span.innerText = "done.";
          break;
        case this._MODIFYUNCOMPRESS:
          {
            let filename = this._webPageinstances[i].http_filename;
            let status = log("Uploading  " + filename + " to hub");
            status.innerText = "0%";
            let success = await this.uploadWidthProgress(filename, this._webPageinstances[i].contents, (curr, total) => {
              status.innerText = Math.round(100 * curr / total).toString() + "%";
            });
            status.innerText = "done";
            if (success != YAPI_SUCCESS)
              throw "Upload failed! (Error" + success.toString() + ")";
            status = log("Deleting " + this._webPageinstances[i].fs_filename);
            await this._currentfs.remove(this._webPageinstances[i].fs_filename);
            status.innerText = "done.";
          }
          break;
        case this._MODIFYCOMPRESS:
          {
            let filename = this._webPageinstances[i].http_filename + ".gz";
            let status = log("Compressing  " + filename);
            let GZ_data = Pako_Deflate.gzip(this._webPageinstances[i].contents, {level: 9});
            status.innerText = "done";
            status = log("Uploading  " + filename + " to hub");
            status.innerText = "0%";
            let success = await this.uploadWidthProgress(filename, GZ_data, (curr, total) => {
              status.innerText = Math.round(100 * curr / total).toString() + "%";
            });
            status.innerText = "done";
            if (success != YAPI_SUCCESS)
              throw "Upload failed!! (Error" + success.toString() + ")";
            status = log("Deleting " + this._webPageinstances[i].http_filename);
            await this._currentfs.remove(this._webPageinstances[i].http_filename);
            status.innerText = "done.";
          }
          break;
        case this._MODIFYMAKEREADONLY:
          await this.patchPageInstance(log, this._webPageinstances[i], 'from "./yv4web-full', 'from "./yv4web-readonly', "", "", ",filehandler.saveFct);", ");");
          this._webPageinstances[i].readonly = true;
          break;
        case this._MODIFYMAKEREADWRITE:
          await this.patchPageInstance(log, this._webPageinstances[i], 'from "./yv4web-readonly', 'from "./yv4web-full', "", "", "filehandler.configChangeCallbackFct);", "filehandler.configChangeCallbackFct,filehandler.saveFct);");
          this._webPageinstances[i].readonly = false;
          break;
        case this._MODIFYUSEPLAIN:
          await this.patchPageInstance(log, this._webPageinstances[i], '"./yv4web-full.min.js"', '"./yv4web-full.js"', '"./yv4web-readonly.min.js"', '"./yv4web-readonly.js"', "", "");
          this._webPageinstances[i].useMinified = false;
          break;
        case this._MODIFYUPDATE:
          let RO_username = "";
          let RO_password = "";
          let HUBaddr = "";
          let HUBpath = "";
          if (this._userNameInput != null)
            RO_username = this._userNameInput.value;
          if (this._userPasswordInput != null)
            RO_password = this._userPasswordInput.value;
          if (this._ipAddrInput != null)
            HUBaddr = this._ipAddrInput.value;
          if (this._pathInput != null)
            HUBpath = this._pathInput.value;
          await this.setInstanceCredentials(log, this._webPageinstances[i], HUBaddr, HUBpath, RO_username, RO_password);
          break;
        case this._MODIFYUSEMINIFIED:
          await this.patchPageInstance(log, this._webPageinstances[i], '"./yv4web-full.js"', '"./yv4web-full.min.js"', '"./yv4web-readonly.js"', '"./yv4web-readonly.min.js"', "", "");
          this._webPageinstances[i].useMinified = true;
          break;
      }
    }
    await this.syncJsFileVersions(log, this._removeUnusedJs.checked);
    log("Done.");
    setTimeout(() => {
      this.gotoPanel(this.DONEPANEL);
    }, 2e3);
  }
  async uninstall(log) {
    for (let i = 0; i < this._jsCodeinstances.length; i++) {
      let filename = this._jsCodeinstances[i].filename;
      log("Deleteting " + filename);
      await this._currentfs.remove(filename);
    }
    let network = await YNetwork.FindNetwork(await this._currentHub.get_serialNumber() + ".network");
    let startPage = await network.get_defaultPage();
    let mustResetStartPage = false;
    for (let i = 0; i < this._webPageinstances.length; i++) {
      let filename = this._webPageinstances[i].fs_filename;
      if (startPage == this._webPageinstances[i].http_filename)
        mustResetStartPage = true;
      log("Deleteting " + filename);
      await this._currentfs.remove(filename);
    }
    if (mustResetStartPage) {
      log("Setting default page to index.html");
      await network.set_defaultPage("");
      await this._currentHub.saveToFlash();
    }
    log("Done.");
    setTimeout(() => {
      this.gotoPanel(this.DONEPANEL);
    }, 2e3);
  }
  get_js_filename(readonly, minified) {
    return "yv4web-" + (readonly ? "readonly" : "full") + (minified ? ".min" : "") + ".js";
  }
  get_js_blob(readonly, minified) {
    let data;
    if (readonly) {
      data = minified ? BinariesBlobs.ro_minjs : BinariesBlobs.ro_js;
    } else {
      data = minified ? BinariesBlobs.rw_minjs : BinariesBlobs.rw_js;
    }
    if (data == "")
      return null;
    return YAPI.imm_str2bin(atob(data));
  }
  async copyJsCode(log, readonly, minified) {
    let currentURL = window.location.href;
    let filename = currentURL.split("/").pop().split("#")[0].split("?")[0];
    let jsfile = this.get_js_filename(readonly, minified);
    let GZ_data = this.get_js_blob(readonly, minified);
    let status;
    if (GZ_data == null) {
      status = log("Downloading " + jsfile + " module from server..");
      let jsfileURL = currentURL.replace(filename, "../../dist/" + this.ESVersion + "/" + jsfile);
      let result;
      result = await YoctoHubFileHandler.makeRequest("GET", jsfileURL);
      if (result.data == null) {
        let err = "Installation Failed: cannot download the Yocto-Visualization file from the serveur serving this installer.\n\nError was : " + result.statusText + "\n\nURL was: " + jsfileURL;
        this.gotoPanel(this.CONNECTIONERROR, err);
        return;
      }
      status.innerText = "done.";
      status = log("Compressing JS Module..");
      GZ_data = Pako_Deflate.gzip(result.data, {level: 9});
      status.innerText = "done.";
    }
    status = log("Copying JS Module to hub..");
    status.innerText = "0%";
    let success = await this.uploadWidthProgress(jsfile + ".gz", GZ_data, (curr, total) => {
      status.innerText = Math.round(100 * curr / total).toString() + "%";
    });
    if (success != YAPI_SUCCESS)
      throw "Upload failed. (Error" + success.toString() + ").";
    status.innerText = "done.";
  }
  async install(log) {
    let configFile = await this.loadLocalFile(this._configFileInput);
    if (configFile != null) {
      configFile = configFile.replace("<!-->", "<!-- ");
      let err = new YErrorMsg();
      if (!this.checkConfigfile(configFile, err)) {
        this.gotoPanel(this.CONNECTIONERROR, "Installation failed\n\n" + err.msg);
        return;
      }
      let index = configFile.toUpperCase().indexOf("</ROOT");
      if (index < 0)
        this.gotoPanel(this.CONNECTIONERROR, "Installation failed\n\nunable to find ROOT closing tag in provided config file");
      configFile = configFile.substring(0, index) + "</ROOT>\n";
      configFile = this.patchConfigFile(configFile);
    }
    let htmlFile = await this.loadLocalFile(this._webPageInput);
    if (htmlFile != null) {
      let err = new YErrorMsg();
      if (!this.checkHTMLfile(htmlFile, err)) {
        this.gotoPanel(this.CONNECTIONERROR, "Installation failed\n\n" + err.msg);
        return;
      }
    }
    let status;
    let GZ_data;
    let success;
    let readonly = this._useReadOnlyInput.checked;
    let minified = !this._useFullVersionInput.checked;
    let mustInstallJsCode = this._plannedaction == this.ACTIONINSTALL;
    if (this._plannedaction == this.ACTIONADDINSTANCE) {
      mustInstallJsCode = true;
      for (let i = 0; i < this._jsCodeinstances.length; i++) {
        if (this._jsCodeinstances[i].minified == minified && this._jsCodeinstances[i].readonly == readonly) {
          mustInstallJsCode = false;
        }
      }
    }
    if (mustInstallJsCode)
      await this.copyJsCode(log, readonly, minified);
    status = log("Creating HTML file..");
    let targetHTMLfile;
    if (htmlFile != null) {
      let index = htmlFile.toUpperCase().indexOf("</BODY>");
      let tag = htmlFile.substr(index, 7);
      targetHTMLfile = htmlFile.replace(tag, tag + this.getSeedCode(configFile, readonly, minified));
    } else {
      targetHTMLfile = this.defaultHTMLfile(configFile, readonly, minified);
    }
    status = log("Compressing  HTML file..");
    GZ_data = Pako_Deflate.gzip(YAPI.imm_str2bin(targetHTMLfile), {level: 9});
    status.innerText = "done.";
    status = log("Saving HTML file on hub");
    let targetFile = this._fileprefixInput.value + this.TARGETEXTENSION;
    status.innerText = "0%";
    success = await this.uploadWidthProgress(targetFile + ".gz", GZ_data, (curr, total) => {
      status.innerText = Math.round(100 * curr / total).toString() + "%";
    });
    if (success != YAPI_SUCCESS)
      throw "Upload failed (Error" + success.toString() + ")";
    status.innerText = "done.";
    status = log("Configuring hub");
    let url = this._currentHubLink_protocol + "://" + this._applicationURL;
    let network = await YNetwork.FindNetwork(await this._currentHub.get_serialNumber() + ".network");
    if (this._makeDefaultInput.checked) {
      await network.set_defaultPage(targetFile);
    } else {
      if (await network.get_defaultPage() == targetFile)
        await network.set_defaultPage("");
      url += "/" + targetFile;
    }
    let warning = "";
    if (readonly && configFile == null)
      warning = "However, since you chose to install the read-only version without any configuration file, your install is probably useless.";
    await YAPI.UnregisterHub(await this._currentHub.get_url());
    status.innerText = "done.";
    this._warning = warning;
    this._finalURL = url;
    setTimeout(() => {
      this.gotoPanel(this.DONEPANEL);
    }, 2e3);
  }
  removeAllChilds(element) {
    while (element.firstChild) {
      element.removeChild(element.firstChild);
    }
  }
  async showConfirmUninstallPanel(visible, goingback) {
    if (!visible) {
      if (this._confirmUninstallPanel != null)
        this._confirmUninstallPanel.style.display = "none";
      return;
    }
    if (this._confirmUninstallPanel == null) {
      this._confirmUninstallPanel = this.createNewContentDiv();
      this._container.appendChild(this._confirmUninstallPanel);
    }
    if (!goingback) {
      this.removeAllChilds(this._confirmUninstallPanel);
      let p = document.createElement("P");
      p.innerText = "You are about to remove all files related to Yocto-Visualization (for web)  from hub " + this._currentHub_Addr + ", including instances that probably took you quite some time to configure. Are you sure you want to click on Next and start uninstallation? You will not be able to revert this operation.\n\n";
      this._confirmUninstallPanel.appendChild(p);
      this._confirmUninstall = document.createElement("input");
      this._confirmUninstall.type = "checkbox";
      let bt = this._nextButton;
      this._confirmUninstall.addEventListener("change", function() {
        bt.enabled = this.checked;
      });
      this._confirmUninstallPanel.appendChild(this._confirmUninstall);
      let txt = document.createElement("span");
      txt.innerText = "Yes, I know what I am doing.";
      this._confirmUninstallPanel.appendChild(txt);
    }
    this._confirmUninstallPanel.style.display = "";
    this._nextButton.visible = true;
    this._nextButton.enabled = this._confirmUninstall.checked;
    this._prevButton.visible = true;
    this._cancelButton.visible = this.DEFAULTCANCELABLE;
    let tabIndex = 1;
    this._confirmUninstall.tabIndex = tabIndex++;
    this._prevButton.tabIndex = tabIndex++;
    this._nextButton.tabIndex = tabIndex++;
    this._confirmUninstall.focus();
  }
  async showDonePanel(visible, goingback) {
    if (!visible) {
      if (this._donePanel != null)
        this._donePanel.style.display = "none";
      return;
    }
    if (this._donePanel == null) {
      this._donePanel = this.createNewContentDiv();
      let Table = document.createElement("TABLE");
      let Row = document.createElement("TR");
      let TD1 = document.createElement("TD");
      TD1.style.whiteSpace = "normal";
      TD1.innerHTML = ressources.OkIcon("64", true, false, false, false, "youpi!");
      Row.appendChild(TD1);
      this._doneMsgContainer = document.createElement("TD");
      Row.appendChild(this._doneMsgContainer);
      Table.appendChild(Row);
      this._donePanel.appendChild(Table);
      this._container.appendChild(this._donePanel);
    }
    this.removeAllChilds(this._doneMsgContainer);
    let p = document.createElement("P");
    p.style.whiteSpace = "normal";
    switch (this._plannedaction) {
      case this.ACTIONADDINSTANCE:
      case this.ACTIONINSTALL:
        p.innerText = this._plannedaction == this.ACTIONINSTALL ? "Installation sucessfully completed. Application can be accessed through the following URL:" : "New instance sucessfully completed, it can be accessed through the following URL:";
        this._doneMsgContainer.appendChild(p);
        let url = document.createElement("A");
        url.innerText = this._finalURL;
        url.style.cursor = "pointer";
        url.style.color = "#0000EE";
        url.style.textDecoration = "underline";
        url.addEventListener("click", () => {
          if (top)
            top.location.assign(this._finalURL);
        });
        this._doneMsgContainer.appendChild(url);
        if (this._warning != "") {
          p = document.createElement("P");
          p.innerText = this._warning;
          this._doneMsgContainer.appendChild(p);
        }
        break;
      case this.ACTIONUNINSTALL:
        p.innerText = "Files sucessfully removed.";
        this._doneMsgContainer.appendChild(p);
        break;
      case this.ACTIONUPDATE:
        p.innerText = "JS Files sucessfully updated.";
        this._doneMsgContainer.appendChild(p);
        break;
      case this.ACTIONMODINSTANCE:
        p.innerText = "Instances modifications done";
        this._doneMsgContainer.appendChild(p);
        break;
    }
    p = document.createElement("P");
    this._cancelButton.visible = this.DEFAULTCANCELABLE;
    p.innerText = this.DEFAULTCANCELABLE ? 'Click on the "Ok" button to close the wizard' : 'Click on the "Ok" button to restart the wizard';
    this._doneMsgContainer.appendChild(p);
    this.removeCurrentPanelFromHistory();
    this._nextButton.visible = false;
    this._prevButton.visible = false;
    this._cancelButton.visible = false;
    this._okButton.visible = true;
    this._donePanel.style.display = "";
    let tabIndex = 1;
    this._okButton.tabIndex = tabIndex++;
    this._okButton.focus();
  }
  showCurrentStep(back, msg) {
    this.showWelcomePanel(this._currentStep == this.WELCOMEPANEL, back);
    this.showEnterHubAddr(this._currentStep == this.ENTERHUBADDR, back);
    this.showConnectingPanel(this._currentStep == this.CONNECTINGPANEL, back);
    this.showConnectionError(this._currentStep == this.CONNECTIONERROR, back, msg);
    this.showPasswordPanel(this._currentStep == this.PASSWORDPANEL, back, msg);
    this.showHubDescription(this._currentStep == this.DESCRIPTIONPANEL, back);
    this.showCustomFilesPanel(this._currentStep == this.CUSTOMFILESPANEL, back);
    this.showOptionsPanel(this._currentStep == this.OPTIONSPANEL, back);
    this.showRunPanel(this._currentStep == this.RUNPANEL, back);
    this.showDonePanel(this._currentStep == this.DONEPANEL, back);
    this.showModifyInstallPanel(this._currentStep == this.MODIFYINSTALLPANEL, back);
    this.showConfirmUninstallPanel(this._currentStep == this.CONFIRMUNINSTALLPANEL, back);
    this.showModInstancesPanel(this._currentStep == this.MODINSTANCESPANEL, back);
  }
  gotoPrevious() {
    if (this._history.length > 1) {
      this._history.pop();
      this._currentStep = this._history[this._history.length - 1];
    }
    this.showCurrentStep(true);
  }
  gotoPanel(step, errmsg) {
    this._currentStep = step;
    this._prevButton.visible = step > 0;
    this._history.push(step);
    this.showCurrentStep(false, errmsg);
  }
  async resetAll() {
    this._currentStep = this.WELCOMEPANEL;
    this._history = [this.WELCOMEPANEL];
    this._alreadyInstalled = false;
    this._prevButton.visible = false;
    this._nextButton.visible = true;
    this._okButton.visible = false;
    this._cancelButton.visible = this.DEFAULTCANCELABLE;
    this._jsCodeinstances = [];
    this._webPageinstances = [];
    await YAPI.UnregisterHub(await this._currentHub.get_url());
    await YAPI.FreeAPI();
    this._currentHub = null;
    this.showCurrentStep(false);
  }
  gotoNext() {
    switch (this._currentStep) {
      case this.WELCOMEPANEL:
        this.gotoPanel(this.ENTERHUBADDR);
        break;
      case this.ENTERHUBADDR:
        this.gotoPanel(this.CONNECTINGPANEL);
        break;
      case this.PASSWORDPANEL:
        this.gotoPanel(this.CONNECTINGPANEL);
        break;
      case this.DESCRIPTIONPANEL:
        if (this._alreadyInstalled) {
          this.gotoPanel(this.MODIFYINSTALLPANEL);
        } else {
          this._plannedaction = this.ACTIONINSTALL;
          this.gotoPanel(this.CUSTOMFILESPANEL);
        }
        break;
      case this.CUSTOMFILESPANEL:
        this.gotoPanel(this.OPTIONSPANEL);
        break;
      case this.OPTIONSPANEL:
        this.gotoPanel(this.RUNPANEL);
        break;
      case this.MODIFYINSTALLPANEL:
        if (this._uninstallOpt.checked)
          this.gotoPanel(this.CONFIRMUNINSTALLPANEL);
        if (this._addInstanceOpt.checked) {
          this._plannedaction = this.ACTIONADDINSTANCE;
          this.gotoPanel(this.CUSTOMFILESPANEL);
        }
        if (this._updateOpt.checked) {
          this._plannedaction = this.ACTIONUPDATE;
          this.gotoPanel(this.RUNPANEL);
        }
        if (this._modInstanceOpt.checked) {
          this._plannedaction = this.ACTIONMODINSTANCE;
          this.gotoPanel(this.MODINSTANCESPANEL);
        }
        break;
      case this.MODINSTANCESPANEL:
        this.gotoPanel(this.RUNPANEL);
        break;
      case this.CONFIRMUNINSTALLPANEL:
        this._plannedaction = this.ACTIONUNINSTALL;
        this.gotoPanel(this.RUNPANEL);
        break;
    }
  }
};
YV4W_installer.HTTP = "http";
YV4W_installer.HTTPS = "https";
window.startYV4W_installer = (div, options) => {
  new YV4W_installer(div, options);
};
export {
  YV4W_installer
};
//# sourceMappingURL=yv4w-installer.js.map
