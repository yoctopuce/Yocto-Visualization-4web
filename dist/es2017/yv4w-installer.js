/* Yocto-Visualization-4web installer (version 1.10.63744) - www.yoctopuce.com */
// obj/full/Renderer/YDataRendererCommon.js
var Vector3 = class {
  constructor(a, b, c) {
    this.a = a;
    this.b = b;
    this.c = c;
  }
  static FromXYCoord(x, y) {
    return new Vector3(x, y, 1);
  }
  multiplyByM(m) {
    return new Vector3(m.a * this.a + m.b * this.b + m.c * this.c, m.d * this.a + m.e * this.b + m.f * this.c, m.g * this.a + m.h * this.b + m.i * this.c);
  }
  multiplyByN(n) {
    return new Vector3(this.a * n, this.b * n, this.c * n);
  }
  AddV(v) {
    return new Vector3(this.a + v.a, this.b + v.b, this.c + v.c);
  }
  SubstractV(v) {
    return new Vector3(this.a - v.a, this.b - v.b, this.c - v.c);
  }
  toPointF() {
    return new PointF(this.a, this.b);
  }
  toPoint() {
    return new Point(this.a, this.b);
  }
};
var Matrix3x3 = class {
  constructor(a, b, c, d, e, f, g, h, i, flags) {
    this.a = a;
    this.b = b;
    this.c = c;
    this.d = d;
    this.e = e;
    this.f = f;
    this.g = g;
    this.h = h;
    this.i = i;
    if (b == 0 && d == 0 && a == 1 && e == 1 && i == 1 && g == 0 && h == 0) {
      flags |= Matrix3x3.Flag_TRANSLATION;
      if (c == 0 && f == 0)
        flags |= Matrix3x3.Flag_IDENTITY;
    }
    this.isTranslation = (flags & Matrix3x3.Flag_TRANSLATION) != 0;
    this.isIdentity = (flags & Matrix3x3.Flag_IDENTITY) != 0;
  }
  clone() {
    let flag = 0;
    if (this.isTranslation)
      flag |= Matrix3x3.Flag_TRANSLATION;
    if (this.isIdentity)
      flag |= Matrix3x3.Flag_IDENTITY;
    return new Matrix3x3(this.a, this.b, this.c, this.d, this.e, this.f, this.g, this.h, this.i, flag);
  }
  get determinant() {
    let detA = this.e * this.i - this.h * this.f;
    let detB = this.d * this.i - this.g * this.f;
    let detC = this.d * this.h - this.g * this.e;
    return this.a * detA + -this.b * detB + this.c * detC;
  }
  get transpose() {
    if (this.isIdentity)
      return Matrix3x3.newIdentityMatrix();
    return new Matrix3x3(this.a, this.d, this.g, this.b, this.e, this.h, this.c, this.f, this.i, Matrix3x3.Flag_NONE);
  }
  multiplyByV(v) {
    if (this.isTranslation)
      return new Vector3(this.c + v.a, this.f + v.b, 1);
    return new Vector3(this.a * v.a + this.b * v.b + this.c * v.c, this.d * v.a + this.e * v.b + this.f * v.c, this.g * v.a + this.h * v.b + this.i * v.c);
  }
  static newMatrix(a, b, c, d, e, f, g, h, i) {
    return new Matrix3x3(a, b, c, d, e, f, g, h, i, Matrix3x3.Flag_NONE);
  }
  static newTranslateMatrix(offsetX, offsetY) {
    let flag = Matrix3x3.Flag_TRANSLATION;
    if (offsetX == 0 && offsetY == 0)
      flag |= Matrix3x3.Flag_IDENTITY;
    return new Matrix3x3(1, 0, offsetX, 0, 1, offsetY, 0, 0, 1, flag);
  }
  static newRotateMatrix(AngleDeg) {
    AngleDeg = Math.PI * AngleDeg / 180;
    return new Matrix3x3(Math.cos(AngleDeg), -Math.sin(AngleDeg), 0, Math.sin(AngleDeg), -Math.cos(AngleDeg), 0, 0, 0, 1, Matrix3x3.Flag_NONE);
  }
  static newScaleMatrix(Coef) {
    return new Matrix3x3(Coef, 0, 0, 0, Coef, 0, 0, 0, 1, Matrix3x3.Flag_NONE);
  }
  static newIdentityMatrix() {
    return new Matrix3x3(1, 0, 0, 0, 1, 0, 0, 0, 1, Matrix3x3.Flag_IDENTITY | Matrix3x3.Flag_TRANSLATION);
  }
  toCSS() {
    return "matrix(" + this.a.toString() + "," + this.d.toString() + "," + this.b.toString() + "," + this.e.toString() + "," + this.c.toString() + "," + this.f.toString() + ")";
  }
  toString() {
    return "| " + this.a.toFixed(2) + " " + this.b.toFixed(2) + " " + this.c.toFixed(2) + " |" + (this.isIdentity ? " I" : "") + "\n| " + this.d.toFixed(2) + " " + this.e.toFixed(2) + " " + this.f.toFixed(2) + " |" + (this.isTranslation ? " T" : "") + "\n| " + this.g.toFixed(2) + " " + this.g.toFixed(2) + " " + this.i.toFixed(2) + " |\n";
  }
  multiplyByM(m) {
    if (this.isIdentity)
      return m.clone();
    if (m.isIdentity)
      return this.clone();
    if (this.isTranslation && m.isTranslation)
      return Matrix3x3.newTranslateMatrix(this.c + m.c, this.f + m.f);
    return new Matrix3x3(this.a * m.a + this.b * m.d + this.c * m.g, this.a * m.b + this.b * m.e + this.c * m.h, this.a * m.c + this.b * m.f + this.c * m.i, this.d * m.a + this.e * m.d + this.f * m.g, this.d * m.b + this.e * m.e + this.f * m.h, this.d * m.c + this.e * m.f + this.f * m.i, this.g * m.a + this.h * m.d + this.i * m.g, this.g * m.b + this.h * m.e + this.i * m.h, this.g * m.c + this.h * m.f + this.i * m.i, Matrix3x3.Flag_NONE);
  }
  get inverse() {
    if (this.isIdentity)
      return Matrix3x3.newIdentityMatrix();
    if (this.isTranslation)
      return Matrix3x3.newTranslateMatrix(-this.c, -this.f);
    let det = this.determinant;
    if (det == 0)
      throw "matrix cannot be inverted";
    let detA = this.e * this.i - this.f * this.h;
    let detB = this.b * this.i - this.c * this.h;
    let detC = this.b * this.f - this.c * this.e;
    let detD = this.d * this.i - this.f * this.g;
    let detE = this.a * this.i - this.c * this.g;
    let detF = this.a * this.f - this.c * this.d;
    let detG = this.d * this.h - this.e * this.g;
    let detH = this.a * this.h - this.b * this.g;
    let detI = this.a * this.e - this.b * this.d;
    return new Matrix3x3(detA / det, -detB / det, detC / det, -detD / det, detE / det, -detF / det, detG / det, -detH / det, detI / det, Matrix3x3.Flag_NONE);
  }
  log() {
    console.log(this.toString());
  }
};
Matrix3x3.Flag_NONE = 0;
Matrix3x3.Flag_IDENTITY = 1;
Matrix3x3.Flag_TRANSLATION = 2;
var YEnum = class {
  static fromString(container, value) {
    let p = Object.getOwnPropertyNames(container);
    for (let i = 0; i < p.length; i++) {
      if (p[i] == value)
        return container[value];
    }
    throw "YEnum" + value + " is not a " + container + " value";
  }
  static siblings(container) {
    let res = [];
    let p = Object.getOwnPropertyNames(container);
    for (let i = 0; i < p.length; i++) {
      if (container[p[i]] instanceof YEnumItem) {
        res.push(container[p[i]]);
      }
    }
    return res;
  }
};
var YEnumItem = class {
  constructor(value, humanreadable, container) {
    this._value = value;
    this._container = container;
    this._humanreadable = humanreadable;
  }
  fromString(value) {
    return YEnum.fromString(this._container, value);
  }
  get toString() {
    return this._value.toString();
  }
  get description() {
    return this._humanreadable;
  }
  get sibblings() {
    return YEnum.siblings(this._container);
  }
};
var ViewPortSettings = class {
  constructor() {
    this.IRLx = 0;
    this.IRLy = 0;
    this.zoomx = 0;
    this.zoomy = 0;
    this.Lmargin = 0;
    this.Rmargin = 0;
    this.Tmargin = 0;
    this.Bmargin = 0;
    this.Width = 0;
    this.Height = 0;
    this.Capture = false;
    this.IRLCaptureStartX = 0;
    this.CaptureStartY = 0;
    this.OriginalXAxisMin = 0;
    this.OriginalXAxisMax = 0;
    this.OriginalIRLx = 0;
    this.OriginalLmargin = 0;
    this.OriginalZoomx = 0;
  }
};
var YFont = class {
  get userData() {
    return this._userData;
  }
  set userData(value) {
    this._userData = value;
  }
  get directParent() {
    return this._directParent;
  }
  constructor(parentRenderer, directParent, size, fontChangeCallback) {
    this._userData = null;
    this._fontChangeCallback = null;
    this._name = "Arial";
    this._italic = false;
    this._bold = false;
    this._color = YColor.Black;
    this._alternateColor = null;
    this._font = null;
    this._brush = new YSolidBrush(YColor.Black);
    this._parentRenderer = parentRenderer;
    this._directParent = directParent;
    this._fontChangeCallback = fontChangeCallback ? fontChangeCallback : null;
    this._size = new Proportional(size ? size : 10, Proportional.ResizeRule.FIXED, parentRenderer, this, this.ResetFont);
  }
  ResetFont(source) {
    this._font = null;
    if (source != null)
      this._parentRenderer.ProportionnalValueChanged(source);
  }
  get name() {
    return this._name;
  }
  set name(value) {
    this._name = value;
    this.ResetFont(null);
    this._parentRenderer.redraw();
  }
  get hasChanged() {
    return this._font == null;
  }
  get size() {
    return this._size.value;
  }
  set size(value) {
    if (value <= 0)
      throw new RangeError("Size must be a positive value");
    value = Math.round(100 * value) / 100;
    this._size.value = value;
    this.ResetFont(null);
    if (this._fontChangeCallback != null)
      this._fontChangeCallback(this);
    this._parentRenderer.redraw();
  }
  get italic() {
    return this._italic;
  }
  set italic(value) {
    if (this._italic != value) {
      this._italic = value;
      this.ResetFont(null);
      this._parentRenderer.redraw();
    }
  }
  get bold() {
    return this._bold;
  }
  set bold(value) {
    if (this._bold != value) {
      this._bold = value;
      this.ResetFont(null);
      this._parentRenderer.redraw();
    }
  }
  get color() {
    return this._color;
  }
  set color(value) {
    if (this._color != value) {
      this._color = value;
      this._brush = null;
      this._parentRenderer.redraw();
    }
  }
  get alternateColor() {
    return this._alternateColor;
  }
  set alternateColor(value) {
    if (this._alternateColor != value) {
      this._alternateColor = value;
      this._brush = null;
      this._parentRenderer.redraw();
    }
  }
  get fontObject() {
    return this._name ? this._name : "Arial";
  }
  get brush() {
    if (this._brush == null)
      this._brush = new YSolidBrush(this._alternateColor != null ? this._alternateColor : this._color);
    return this._brush;
  }
  get sizeInPoints() {
    return this._size.value * 0.75;
  }
  get sizeForCanvas() {
    return this._size.value * 1.15;
  }
  get htmlCode() {
    return (this._italic ? "italic " : "") + (this._bold ? "bold " : "") + this.sizeForCanvas.toString() + "px " + this._name;
  }
};
var YSizeF = class {
  constructor(font, st) {
    this._w = 0;
    this._h = 0;
    this._lines = [];
    this._linesCount = 0;
    this._lineHeight = 0;
    this._firstlineHeight = 0;
    if (font != null) {
      this._lineHeight = font.size * 1.25;
      this._firstlineHeight = this._lineHeight * 0.75;
      if (st.indexOf("\n") < 0) {
        this._lines = [st];
        this._linesCount = 1;
      } else {
        this._lines = st.split("\n");
        this._linesCount = this._lines.length;
      }
    }
  }
  get lines() {
    return this._lines;
  }
  get linesCount() {
    return this._linesCount;
  }
  get firstLineHeight() {
    return this._firstlineHeight;
  }
  get lineHeight() {
    return this._lineHeight;
  }
  get height() {
    return this._h;
  }
  get width() {
    return this._w;
  }
  set width(value) {
    this._w = value;
  }
  set height(value) {
    this._h = value;
  }
};
var YTextRenderingHint = class {
  constructor(value) {
    this._value = 0;
    this._value = value;
  }
};
YTextRenderingHint.SystemDefault = new YTextRenderingHint(0);
YTextRenderingHint.SingleBitPerPixelGridFit = new YTextRenderingHint(1);
YTextRenderingHint.SingleBitPerPixel = new YTextRenderingHint(2);
YTextRenderingHint.AntiAliasGridFit = new YTextRenderingHint(3);
YTextRenderingHint.AntiAlias = new YTextRenderingHint(4);
YTextRenderingHint.ClearTypeGridFit = new YTextRenderingHint(5);
var YSmoothingMode = class {
  constructor(value) {
    this._value = 0;
    this._value = value;
  }
};
YSmoothingMode.Invalid = new YSmoothingMode(-1);
YSmoothingMode.Default = new YSmoothingMode(0);
YSmoothingMode.HighSpeed = new YSmoothingMode(1);
YSmoothingMode.HighQuality = new YSmoothingMode(2);
YSmoothingMode.None = new YSmoothingMode(3);
YSmoothingMode.AntiAlias = new YSmoothingMode(4);
var YStringBuilder = class {
  constructor() {
    this._str = "";
  }
  AppendLine(s) {
    this._str += s + "\n";
  }
  Append(s) {
    this._str += s;
  }
  get contents() {
    return this._str;
  }
};
var YStringFormat = class {
  get Alignment() {
    return this._Alignment;
  }
  set Alignment(value) {
    this._Alignment = value;
  }
  get LineAlignment() {
    return this._LineAlignment;
  }
  set LineAlignment(value) {
    this._LineAlignment = value;
  }
  get FormatFlags() {
    return this._formatFlags;
  }
  set FormatFlags(value) {
    this._formatFlags = value;
  }
  get Trimming() {
    return this._Trimming;
  }
  set Trimming(value) {
    this._Trimming = value;
  }
  constructor(clip) {
    this._Alignment = 0;
    this._LineAlignment = 0;
    this._formatFlags = 0;
    this._Trimming = 0;
    this._clip = 16384;
    this._clip = clip;
  }
};
var YColor = class {
  get name() {
    return this._name;
  }
  set predefname(value) {
    this._name = value;
  }
  static get predefinedColors() {
    if (YColor._predefinedColors == null) {
      YColor._predefinedColors = {};
      let names = Object.getOwnPropertyNames(YColor);
      for (let i = 0; i < names.length; i++) {
        if (YColor[names[i]] instanceof YColor) {
          YColor._predefinedColors[names[i]] = YColor[names[i]];
          YColor._predefinedColors[names[i]].predefname = names[i];
        }
      }
    }
    return YColor._predefinedColors;
  }
  static FromString(value) {
    let valueUpper = value.toUpperCase();
    let propNames = Object.getOwnPropertyNames(YColor);
    for (let i = 0; i < propNames.length; i++) {
      if (propNames[i].toUpperCase() == valueUpper) {
        if (YColor[propNames[i]] instanceof YColor) {
          return YColor[propNames[i]];
        }
      }
    }
    if (value.length == 7 && value.substr(0, 1).toUpperCase() == "#") {
      let r = parseInt(value.substr(1, 2), 16);
      let g = parseInt(value.substr(3, 2), 16);
      let b = parseInt(value.substr(5, 2), 16);
      return new YColor(false, 255, r, g, b);
    }
    if (value.length == 12) {
      if (value.substr(0, 4).toUpperCase() == "RGB:") {
        let alpha = parseInt(value.substr(4, 2), 16);
        let r = parseInt(value.substr(6, 2), 16);
        let g = parseInt(value.substr(8, 2), 16);
        let b = parseInt(value.substr(10, 2), 16);
        return new YColor(false, alpha, r, g, b);
      } else if (value.substr(0, 4).toUpperCase() == "HSL:") {
        let alpha = parseInt(value.substr(4, 2), 16);
        let h = parseInt(value.substr(6, 2), 16);
        let s = parseInt(value.substr(8, 2), 16);
        let l = parseInt(value.substr(10, 2), 16);
        return new YColor(true, alpha, h, s, l);
      }
    }
    return null;
  }
  static hex(v) {
    let s = v.toString(16);
    if (s.length <= 1)
      return "0" + s;
    return s;
  }
  toString() {
    if (this.isHSLColor) {
      return "HSL:" + (YColor.hex(this.transparency) + YColor.hex(this.h) + YColor.hex(this.s) + YColor.hex(this.l)).toUpperCase();
    } else {
      let propNames = Object.getOwnPropertyNames(YColor);
      for (let i = 0; i < propNames.length; i++) {
        let o = Reflect.get(YColor, propNames[i]);
        let c = o;
        if (c.alpha == this.alpha && c.red == this.red && c.green == this.green && c.blue == this.blue)
          return propNames[i];
      }
    }
    return "RGB:" + (YColor.hex(this.transparency) + YColor.hex(this.r) + YColor.hex(this.g) + YColor.hex(this.b)).toUpperCase();
  }
  get svgCode() {
    return "rgb(" + this.r.toString() + ", " + this.g.toString() + ", " + this.b.toString() + ")";
  }
  get alphaCode() {
    return (this.transparency / 255).toFixed(3);
  }
  static hsl2rgbInt(temp1, temp2, temp3) {
    if (temp3 >= 170)
      return (temp1 + 127) / 255 >> 0;
    if (temp3 > 42) {
      if (temp3 <= 127)
        return (temp2 + 127) / 255 >> 0;
      temp3 = 170 - temp3;
    }
    return (temp1 * 255 + (temp2 - temp1) * (6 * temp3) + 32512) / 65025 >> 0;
  }
  hsl2rgb() {
    let temp1;
    let temp2;
    let temp3;
    this.rgbConvertionDone = true;
    if (this.s == 0) {
      this.r = this.l;
      this.g = this.l;
      this.b = this.l;
      return;
    }
    if (this.l <= 127) {
      temp2 = this.l * (255 + this.s);
    } else {
      temp2 = (this.l + this.s) * 255 - this.l * this.s;
    }
    temp1 = 510 * this.l - temp2;
    temp3 = this.h + 85;
    if (temp3 > 255)
      temp3 = temp3 - 255;
    this.r = YColor.hsl2rgbInt(temp1, temp2, temp3);
    temp3 = this.h;
    if (temp3 > 255)
      temp3 = temp3 - 255;
    this.g = YColor.hsl2rgbInt(temp1, temp2, temp3);
    if (this.h >= 85) {
      temp3 = this.h - 85;
    } else {
      temp3 = this.h + 170;
    }
    this.b = YColor.hsl2rgbInt(temp1, temp2, temp3);
    if (this.r > 255)
      this.r = 255;
    if (this.g > 255)
      this.g = 255;
    if (this.b > 255)
      this.b = 255;
  }
  computeHSL() {
    let R = this.r;
    let G = this.g;
    let B = this.b;
    let H;
    let S;
    let L;
    let max = R > G ? R : G;
    let min = R < G ? R : G;
    let correction = 0;
    let divisor = 0;
    this.hslConvertionDone = true;
    if (B > max)
      max = B;
    if (B < min)
      min = B;
    L = (max + min + 1) / 2 >> 0;
    if (max == min) {
      this.h = 0;
      this.s = 0;
      this.l = L;
      return;
    }
    correction = (max + min) / 2 >> 0;
    if (L <= 127) {
      S = (255 * (max - min) + correction) / (max + min) >> 0;
    } else {
      S = (255 * (max - min) + 255 - correction) / (510 - (max + min)) >> 0;
    }
    correction = 3 * (max - min);
    divisor = 2 * correction;
    if (R == max) {
      H = 0;
      R = G;
      G = B;
    } else if (G == max) {
      H = 85;
      G = R;
      R = B;
    } else {
      H = 170;
    }
    if (R >= G) {
      H += (255 * (R - G) + correction) / divisor >> 0;
    } else {
      H += 255 - (255 * (G - R) - correction) / divisor >> 0;
    }
    if (H > 255)
      H -= 255;
    if (S > 255)
      S = 255;
    if (L > 255)
      L = 255;
    this.h = H;
    this.s = S;
    this.l = L;
  }
  get hue() {
    if (!this.hslConvertionDone)
      this.computeHSL();
    return this.h;
  }
  get saturation() {
    if (!this.hslConvertionDone)
      this.computeHSL();
    return this.s;
  }
  get luminosity() {
    if (!this.hslConvertionDone)
      this.computeHSL();
    return this.l;
  }
  get red() {
    if (!this.rgbConvertionDone)
      this.hsl2rgb();
    return this.r;
  }
  get green() {
    if (!this.rgbConvertionDone)
      this.hsl2rgb();
    return this.g;
  }
  get blue() {
    if (!this.rgbConvertionDone)
      this.hsl2rgb();
    return this.b;
  }
  get alpha() {
    return this.transparency;
  }
  static FromArgb(a, r, g, b) {
    return new YColor(false, a, r, g, b);
  }
  static FromAhsl(a, h, s, l) {
    return new YColor(true, a, h, s, l);
  }
  get isHSL() {
    return this.isHSLColor;
  }
  get isRGB() {
    return !this.isHSLColor;
  }
  equal(c) {
    if (this.isHSLColor) {
      if (!c.isHSLColor)
        return false;
      if (c.hue != this.hue)
        return false;
      if (c.saturation != this.saturation)
        return false;
      if (c.luminosity != this.luminosity)
        return false;
      if (c.alpha != this.alpha)
        return false;
    } else {
      if (c.isHSLColor)
        return false;
      if (c.red != this.red)
        return false;
      if (c.green != this.green)
        return false;
      if (c.blue != this.blue)
        return false;
      if (c.alpha != this.alpha)
        return false;
    }
    return true;
  }
  clone() {
    if (this.isHSLColor)
      return new YColor(true, this.transparency, this.h, this.s, this.l, this.isPredefined);
    return new YColor(false, this.transparency, this.r, this.g, this.b, this.isPredefined);
  }
  get isPredefined() {
    return this._isPredefined;
  }
  constructor(isHsl, transparency, r_h, g_s, b_l, isPredefined) {
    this.hslConvertionDone = false;
    this.rgbConvertionDone = false;
    this.transparency = 0;
    this.r = 0;
    this.g = 0;
    this.b = 0;
    this.h = 0;
    this.s = 0;
    this.l = 0;
    this._name = "";
    this._htmlcode = this.computeHTMLCode();
    this.hslConvertionDone = isHsl;
    this.isHSLColor = isHsl;
    this.transparency = transparency;
    this._isPredefined = isPredefined === true;
    if (isHsl) {
      this.h = r_h;
      this.s = g_s;
      this.l = b_l;
      this.hsl2rgb();
    } else {
      this.r = r_h;
      this.g = g_s;
      this.b = b_l;
      this.rgbConvertionDone = true;
    }
    this._htmlcode = this.computeHTMLCode();
  }
  computeHTMLCode() {
    let a = this.transparency / 255;
    let r = this.r;
    let g = this.g;
    let b = this.b;
    return "rgba(" + r + "," + g + "," + b + "," + a.toFixed(3) + ")";
  }
  get htmlCode() {
    return this._htmlcode;
  }
};
YColor.AliceBlue = new YColor(false, 255, 240, 248, 255, true);
YColor.AntiqueWhite = new YColor(false, 255, 250, 235, 215, true);
YColor.Aqua = new YColor(false, 255, 0, 255, 255, true);
YColor.Aquamarine = new YColor(false, 255, 127, 255, 212, true);
YColor.Azure = new YColor(false, 255, 240, 255, 255, true);
YColor.Beige = new YColor(false, 255, 245, 245, 220, true);
YColor.Bisque = new YColor(false, 255, 255, 228, 196, true);
YColor.Black = new YColor(false, 255, 0, 0, 0, true);
YColor.BlanchedAlmond = new YColor(false, 255, 255, 235, 205, true);
YColor.Blue = new YColor(false, 255, 0, 0, 255, true);
YColor.BlueViolet = new YColor(false, 255, 138, 43, 226, true);
YColor.Brown = new YColor(false, 255, 165, 42, 42, true);
YColor.BurlyWood = new YColor(false, 255, 222, 184, 135, true);
YColor.CadetBlue = new YColor(false, 255, 95, 158, 160, true);
YColor.Chartreuse = new YColor(false, 255, 127, 255, 0, true);
YColor.Chocolate = new YColor(false, 255, 210, 105, 30, true);
YColor.Coral = new YColor(false, 255, 255, 127, 80, true);
YColor.CornflowerBlue = new YColor(false, 255, 100, 149, 237, true);
YColor.Cornsilk = new YColor(false, 255, 255, 248, 220, true);
YColor.Crimson = new YColor(false, 255, 220, 20, 60, true);
YColor.Cyan = new YColor(false, 255, 0, 255, 255, true);
YColor.DarkBlue = new YColor(false, 255, 0, 0, 139, true);
YColor.DarkCyan = new YColor(false, 255, 0, 139, 139, true);
YColor.DarkGoldenrod = new YColor(false, 255, 184, 134, 11, true);
YColor.DarkGray = new YColor(false, 255, 169, 169, 169, true);
YColor.DarkGreen = new YColor(false, 255, 0, 100, 0, true);
YColor.DarkKhaki = new YColor(false, 255, 189, 183, 107, true);
YColor.DarkMagenta = new YColor(false, 255, 139, 0, 139, true);
YColor.DarkOliveGreen = new YColor(false, 255, 85, 107, 47, true);
YColor.DarkOrange = new YColor(false, 255, 255, 140, 0, true);
YColor.DarkOrchid = new YColor(false, 255, 153, 50, 204, true);
YColor.DarkRed = new YColor(false, 255, 139, 0, 0, true);
YColor.DarkSalmon = new YColor(false, 255, 233, 150, 122, true);
YColor.DarkSeaGreen = new YColor(false, 255, 143, 188, 143, true);
YColor.DarkSlateBlue = new YColor(false, 255, 72, 61, 139, true);
YColor.DarkSlateGray = new YColor(false, 255, 47, 79, 79, true);
YColor.DarkTurquoise = new YColor(false, 255, 0, 206, 209, true);
YColor.DarkViolet = new YColor(false, 255, 148, 0, 211, true);
YColor.DeepPink = new YColor(false, 255, 255, 20, 147, true);
YColor.DeepSkyBlue = new YColor(false, 255, 0, 191, 255, true);
YColor.DimGray = new YColor(false, 255, 105, 105, 105, true);
YColor.DodgerBlue = new YColor(false, 255, 30, 144, 255, true);
YColor.Firebrick = new YColor(false, 255, 178, 34, 34, true);
YColor.FloralWhite = new YColor(false, 255, 255, 250, 240, true);
YColor.ForestGreen = new YColor(false, 255, 34, 139, 34, true);
YColor.Fuchsia = new YColor(false, 255, 255, 0, 255, true);
YColor.Gainsboro = new YColor(false, 255, 220, 220, 220, true);
YColor.GhostWhite = new YColor(false, 255, 248, 248, 255, true);
YColor.Gold = new YColor(false, 255, 255, 215, 0, true);
YColor.Goldenrod = new YColor(false, 255, 218, 165, 32, true);
YColor.Gray = new YColor(false, 255, 128, 128, 128, true);
YColor.Green = new YColor(false, 255, 0, 128, 0, true);
YColor.GreenYellow = new YColor(false, 255, 173, 255, 47, true);
YColor.Honeydew = new YColor(false, 255, 240, 255, 240, true);
YColor.HotPink = new YColor(false, 255, 255, 105, 180, true);
YColor.IndianRed = new YColor(false, 255, 205, 92, 92, true);
YColor.Indigo = new YColor(false, 255, 75, 0, 130, true);
YColor.Ivory = new YColor(false, 255, 255, 255, 240, true);
YColor.Khaki = new YColor(false, 255, 240, 230, 140, true);
YColor.Lavender = new YColor(false, 255, 230, 230, 250, true);
YColor.LavenderBlush = new YColor(false, 255, 255, 240, 245, true);
YColor.LawnGreen = new YColor(false, 255, 124, 252, 0, true);
YColor.LemonChiffon = new YColor(false, 255, 255, 250, 205, true);
YColor.LightBlue = new YColor(false, 255, 173, 216, 230, true);
YColor.LightCoral = new YColor(false, 255, 240, 128, 128, true);
YColor.LightCyan = new YColor(false, 255, 224, 255, 255, true);
YColor.LightGoldenrodYellow = new YColor(false, 255, 250, 250, 210, true);
YColor.LightGray = new YColor(false, 255, 211, 211, 211, true);
YColor.LightGreen = new YColor(false, 255, 144, 238, 144, true);
YColor.LightPink = new YColor(false, 255, 255, 182, 193, true);
YColor.LightSalmon = new YColor(false, 255, 255, 160, 122, true);
YColor.LightSeaGreen = new YColor(false, 255, 32, 178, 170, true);
YColor.LightSkyBlue = new YColor(false, 255, 135, 206, 250, true);
YColor.LightSlateGray = new YColor(false, 255, 119, 136, 153, true);
YColor.LightSteelBlue = new YColor(false, 255, 176, 196, 222, true);
YColor.LightYellow = new YColor(false, 255, 255, 255, 224, true);
YColor.Lime = new YColor(false, 255, 0, 255, 0, true);
YColor.LimeGreen = new YColor(false, 255, 50, 205, 50, true);
YColor.Linen = new YColor(false, 255, 250, 240, 230, true);
YColor.Magenta = new YColor(false, 255, 255, 0, 255, true);
YColor.Maroon = new YColor(false, 255, 128, 0, 0, true);
YColor.MediumAquamarine = new YColor(false, 255, 102, 205, 170, true);
YColor.MediumBlue = new YColor(false, 255, 0, 0, 205, true);
YColor.MediumOrchid = new YColor(false, 255, 186, 85, 211, true);
YColor.MediumPurple = new YColor(false, 255, 147, 112, 219, true);
YColor.MediumSeaGreen = new YColor(false, 255, 60, 179, 113, true);
YColor.MediumSlateBlue = new YColor(false, 255, 123, 104, 238, true);
YColor.MediumSpringGreen = new YColor(false, 255, 0, 250, 154, true);
YColor.MediumTurquoise = new YColor(false, 255, 72, 209, 204, true);
YColor.MediumVioletRed = new YColor(false, 255, 199, 21, 133, true);
YColor.MidnightBlue = new YColor(false, 255, 25, 25, 112, true);
YColor.MintCream = new YColor(false, 255, 245, 255, 250, true);
YColor.MistyRose = new YColor(false, 255, 255, 228, 225, true);
YColor.Moccasin = new YColor(false, 255, 255, 228, 181, true);
YColor.NavajoWhite = new YColor(false, 255, 255, 222, 173, true);
YColor.Navy = new YColor(false, 255, 0, 0, 128, true);
YColor.OldLace = new YColor(false, 255, 253, 245, 230, true);
YColor.Olive = new YColor(false, 255, 128, 128, 0, true);
YColor.OliveDrab = new YColor(false, 255, 107, 142, 35, true);
YColor.Orange = new YColor(false, 255, 255, 165, 0, true);
YColor.OrangeRed = new YColor(false, 255, 255, 69, 0, true);
YColor.Orchid = new YColor(false, 255, 218, 112, 214, true);
YColor.PaleGoldenrod = new YColor(false, 255, 238, 232, 170, true);
YColor.PaleGreen = new YColor(false, 255, 152, 251, 152, true);
YColor.PaleTurquoise = new YColor(false, 255, 175, 238, 238, true);
YColor.PaleVioletRed = new YColor(false, 255, 219, 112, 147, true);
YColor.PapayaWhip = new YColor(false, 255, 255, 239, 213, true);
YColor.PeachPuff = new YColor(false, 255, 255, 218, 185, true);
YColor.Peru = new YColor(false, 255, 205, 133, 63, true);
YColor.Pink = new YColor(false, 255, 255, 192, 203, true);
YColor.Plum = new YColor(false, 255, 221, 160, 221, true);
YColor.PowderBlue = new YColor(false, 255, 176, 224, 230, true);
YColor.Purple = new YColor(false, 255, 128, 0, 128, true);
YColor.Red = new YColor(false, 255, 255, 0, 0, true);
YColor.RosyBrown = new YColor(false, 255, 188, 143, 143, true);
YColor.RoyalBlue = new YColor(false, 255, 65, 105, 225, true);
YColor.SaddleBrown = new YColor(false, 255, 139, 69, 19, true);
YColor.Salmon = new YColor(false, 255, 250, 128, 114, true);
YColor.SandyBrown = new YColor(false, 255, 244, 164, 96, true);
YColor.SeaGreen = new YColor(false, 255, 46, 139, 87, true);
YColor.SeaShell = new YColor(false, 255, 255, 245, 238, true);
YColor.Sienna = new YColor(false, 255, 160, 82, 45, true);
YColor.Silver = new YColor(false, 255, 192, 192, 192, true);
YColor.SkyBlue = new YColor(false, 255, 135, 206, 235, true);
YColor.SlateBlue = new YColor(false, 255, 106, 90, 205, true);
YColor.SlateGray = new YColor(false, 255, 112, 128, 144, true);
YColor.Snow = new YColor(false, 255, 255, 250, 250, true);
YColor.SpringGreen = new YColor(false, 255, 0, 255, 127, true);
YColor.SteelBlue = new YColor(false, 255, 70, 130, 180, true);
YColor.Tan = new YColor(false, 255, 210, 180, 140, true);
YColor.Teal = new YColor(false, 255, 0, 128, 128, true);
YColor.Thistle = new YColor(false, 255, 216, 191, 216, true);
YColor.Tomato = new YColor(false, 255, 255, 99, 71, true);
YColor.Transparent = new YColor(false, 0, 255, 255, 255, true);
YColor.Turquoise = new YColor(false, 255, 64, 224, 208, true);
YColor.Violet = new YColor(false, 255, 238, 130, 238, true);
YColor.Wheat = new YColor(false, 255, 245, 222, 179, true);
YColor.White = new YColor(false, 255, 255, 255, 255, true);
YColor.WhiteSmoke = new YColor(false, 255, 245, 245, 245, true);
YColor.Yellow = new YColor(false, 255, 255, 255, 0, true);
YColor.YellowGreen = new YColor(false, 255, 154, 205, 50, true);
YColor._predefinedColors = null;
var YBrush = class {
  constructor(c, disableAntialias) {
    this._noAntiAlias = false;
    this._color = c;
    if (typeof disableAntialias != "undefined") {
      this._noAntiAlias = disableAntialias;
    }
  }
  get noAntiAlias() {
    return this._noAntiAlias;
  }
  get color() {
    return this._color;
  }
};
var YSolidBrush = class extends YBrush {
};
var YLinearGradientBrush = class extends YBrush {
  constructor(c1, c2) {
    super(c1);
    this._color1 = c1;
    this._color2 = c2;
  }
  get color1() {
    return this._color1;
  }
  get color2() {
    return this._color2;
  }
};
var YPen = class {
  constructor(color, thickness, disableAntialias) {
    this._thickness = 1;
    this._color = YColor.Black;
    this._noAntiAlias = false;
    this._startCap = 1;
    this._endCap = 1;
    this._linejoin = YPen.LineJoin.Miter;
    this._thickness = thickness;
    this._color = thickness > 0 ? color : YColor.Transparent;
    if (typeof disableAntialias != "undefined") {
      this._noAntiAlias = disableAntialias;
    }
  }
  get noAntiAlias() {
    return this._noAntiAlias;
  }
  get lineWidth() {
    return this._thickness;
  }
  get strokeStyle() {
    return this._color.htmlCode;
  }
  get color() {
    return this._color;
  }
  set startCap(value) {
    this._startCap = value;
  }
  set endCap(value) {
    this._endCap = value;
  }
  set linejoin(value) {
    this._linejoin = value;
  }
};
(function(YPen2) {
  let LineJoin;
  (function(LineJoin2) {
    LineJoin2[LineJoin2["Miter"] = 0] = "Miter";
    LineJoin2[LineJoin2["Bevel"] = 1] = "Bevel";
    LineJoin2[LineJoin2["Round"] = 2] = "Round";
    LineJoin2[LineJoin2["MiterClipped"] = 3] = "MiterClipped";
  })(LineJoin = YPen2.LineJoin || (YPen2.LineJoin = {}));
})(YPen || (YPen = {}));
var YRectangle = class {
  constructor(x, y, w, h) {
    this.x = x;
    this.y = y;
    this.w = w;
    this.h = h;
  }
};
var Point = class {
  constructor(valueX, valueY) {
    this.X = valueX >> 0;
    this.Y = valueY >> 0;
  }
};
var minMaxPoint = class {
  constructor(valueX1, valueYMIN, valueX2, valueYMAX) {
    this.X1 = valueX1 >> 0;
    this.YMIN = valueYMIN >> 0;
    this.X2 = valueX2 >> 0;
    this.YMAX = valueYMAX >> 0;
  }
};
var PointF = class {
  constructor(valueX, valueY) {
    this.X = valueX;
    this.Y = valueY;
  }
};
var GenericPanel = class {
  get userData() {
    return this._userData;
  }
  set userData(value) {
    this._userData = value;
  }
  get directParent() {
    return this._directParent;
  }
  constructor(parent, directParent) {
    this._userData = null;
    this._enabled = false;
    this._panelTextAlign = GenericPanel.TextAlign.LEFT;
    this._text = "";
    this._bgColor = new YColor(false, 255, 255, 255, 192);
    this._borderColor = YColor.Black;
    this._borderthickness = 1;
    this._padding = 10;
    this._verticalMargin = 10;
    this._horizontalMargin = 10;
    this._bgBrush = null;
    this._pen = null;
    this._font = null;
    this._directParent = directParent;
    this._parentRenderer = parent;
    this._font = new YFont(parent, this, 8, null);
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    if (this._enabled != value) {
      this._enabled = value;
      this._parentRenderer.clearCachedObjects();
      this._parentRenderer.redraw();
    }
  }
  get panelTextAlign() {
    return this._panelTextAlign;
  }
  set panelTextAlign(value) {
    this._panelTextAlign = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get text() {
    return this._text;
  }
  set text(value) {
    this._text = value;
    this._parentRenderer.clearCachedObjects();
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get bgColor() {
    return this._bgColor;
  }
  set bgColor(value) {
    this._bgColor = value;
    this._bgBrush = null;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get borderColor() {
    return this._borderColor;
  }
  set borderColor(value) {
    this._borderColor = value;
    this._pen = null;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get borderthickness() {
    return this._borderthickness;
  }
  set borderthickness(value) {
    if (value < 0)
      throw "Border thickness must be a positive value";
    this._borderthickness = value;
    this._parentRenderer.clearCachedObjects();
    this._pen = null;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get padding() {
    return this._padding;
  }
  set padding(value) {
    if (value < 0)
      throw new RangeError("Padding must be a positive value");
    this._padding = value;
    this._parentRenderer.clearCachedObjects();
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get verticalMargin() {
    return this._verticalMargin;
  }
  set verticalMargin(value) {
    this._verticalMargin = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get horizontalMargin() {
    return this._horizontalMargin;
  }
  set horizontalMargin(value) {
    this._horizontalMargin = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get bgBrush() {
    if (this._bgBrush == null)
      this._bgBrush = new YSolidBrush(this._bgColor);
    return this._bgBrush;
  }
  get pen() {
    if (this._pen == null) {
      this._pen = new YPen(this._borderColor, this._borderthickness, true);
    }
    return this._pen;
  }
  get font() {
    return this._font;
  }
};
(function(GenericPanel2) {
  class HorizontalAlignPosEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, HorizontalAlignPos);
    }
  }
  GenericPanel2.HorizontalAlignPosEnumItem = HorizontalAlignPosEnumItem;
  class HorizontalAlignPos extends YEnum {
  }
  HorizontalAlignPos.LEFT = new HorizontalAlignPosEnumItem("LEFT", "Left");
  HorizontalAlignPos.CENTER = new HorizontalAlignPosEnumItem("CENTER", "Center");
  HorizontalAlignPos.RIGHT = new HorizontalAlignPosEnumItem("RIGHT", "Right");
  GenericPanel2.HorizontalAlignPos = HorizontalAlignPos;
  class VerticalAlignPosEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, VerticalAlignPos);
    }
  }
  GenericPanel2.VerticalAlignPosEnumItem = VerticalAlignPosEnumItem;
  class VerticalAlignPos extends YEnum {
  }
  VerticalAlignPos.TOP = new VerticalAlignPosEnumItem("TOP", "Top");
  VerticalAlignPos.CENTER = new VerticalAlignPosEnumItem("CENTER", "Center");
  VerticalAlignPos.BOTTOM = new VerticalAlignPosEnumItem("BOTTOM", "Bottom");
  GenericPanel2.VerticalAlignPos = VerticalAlignPos;
  class TextAlignEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, TextAlign);
    }
  }
  GenericPanel2.TextAlignEnumItem = TextAlignEnumItem;
  class TextAlign extends YEnum {
  }
  TextAlign.LEFT = new TextAlignEnumItem("LEFT", "Left");
  TextAlign.CENTER = new TextAlignEnumItem("CENTER", "Center");
  TextAlign.RIGHT = new TextAlignEnumItem("RIGHT", "Right");
  GenericPanel2.TextAlign = TextAlign;
})(GenericPanel || (GenericPanel = {}));
var MessagePanel = class extends GenericPanel {
  constructor(parent, directParent) {
    super(parent, directParent);
    this._panelHrzAlign = GenericPanel.HorizontalAlignPos.CENTER;
    this._panelVrtAlign = GenericPanel.VerticalAlignPos.CENTER;
  }
  get panelHrzAlign() {
    return this._panelHrzAlign;
  }
  set panelHrzAlign(value) {
    this._panelHrzAlign = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get panelVrtAlign() {
    return this._panelVrtAlign;
  }
  set panelVrtAlign(value) {
    this._panelVrtAlign = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
};
var AnnotationPanel = class extends GenericPanel {
  constructor(parent, directParent) {
    super(parent, directParent);
    this._overlap = false;
    this._positionOffsetX = 50;
    this._positionOffsetY = 50;
    this._panelHrzAlign = GenericPanel.HorizontalAlignPos.CENTER;
    this._panelVrtAlign = GenericPanel.VerticalAlignPos.TOP;
  }
  get overlap() {
    return this._overlap;
  }
  set overlap(value) {
    if (!value && this._panelHrzAlign == GenericPanel.HorizontalAlignPos.CENTER && this._panelVrtAlign == GenericPanel.VerticalAlignPos.CENTER) {
      this._panelVrtAlign = GenericPanel.VerticalAlignPos.TOP;
    }
    this._overlap = value;
    this._parentRenderer.clearCachedObjects();
    this._parentRenderer.redraw();
  }
  get positionOffsetX() {
    return this._positionOffsetX;
  }
  set positionOffsetX(value) {
    this._positionOffsetX = value;
    this._parentRenderer.clearCachedObjects();
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get positionOffsetY() {
    return this._positionOffsetY;
  }
  set positionOffsetY(value) {
    this._positionOffsetY = value;
    this._parentRenderer.clearCachedObjects();
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get panelHrzAlign() {
    return this._panelHrzAlign;
  }
  set panelHrzAlign(value) {
    if (!this._overlap && value == GenericPanel.HorizontalAlignPos.CENTER && this._panelVrtAlign == GenericPanel.VerticalAlignPos.CENTER) {
      this._panelVrtAlign = GenericPanel.VerticalAlignPos.TOP;
    }
    this._panelHrzAlign = value;
    this._parentRenderer.clearCachedObjects();
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get panelVrtAlign() {
    return this._panelVrtAlign;
  }
  set panelVrtAlign(value) {
    if (!this._overlap && value == GenericPanel.VerticalAlignPos.CENTER && this._panelHrzAlign == GenericPanel.HorizontalAlignPos.CENTER) {
      this._panelHrzAlign = GenericPanel.HorizontalAlignPos.RIGHT;
    }
    this._panelVrtAlign = value;
    this._parentRenderer.clearCachedObjects();
    if (this._enabled)
      this._parentRenderer.redraw();
  }
};
var Zone = class {
  get directParent() {
    return this._directParent;
  }
  get userData() {
    return this._userData;
  }
  set userData(value) {
    this._userData = value;
  }
  resetCache() {
  }
  constructor(parentRenderer, directParent) {
    this._userData = null;
    this._zoneBrush = null;
    this._color = YColor.Red;
    this._visible = false;
    this._min = 0;
    this._max = 100;
    this._directParent = directParent;
    this._parentRenderer = parentRenderer;
  }
  get zoneBrush() {
    if (this._zoneBrush == null)
      this._zoneBrush = new YSolidBrush(this._color);
    return this._zoneBrush;
  }
  get color() {
    return this._color;
  }
  set color(value) {
    this._color = value;
    this._zoneBrush = null;
    if (this.visible)
      this._parentRenderer.redraw();
  }
  get visible() {
    return this._visible;
  }
  set visible(value) {
    this._visible = value;
    this._parentRenderer.redraw();
  }
  set_minMax(min, max) {
    if (min > max)
      throw new RangeError("Min cannot be greater than max ");
    this._min = min;
    this._max = max;
    this.resetCache();
    if (this.visible)
      this._parentRenderer.redraw();
  }
  get min() {
    return this._min;
  }
  set min(value) {
    if (value >= this._max && !YDataRenderer.minMaxCheckDisabled) {
      throw new RangeError("Min cannot be greater than max (" + this._max.toString() + ")");
    }
    this._min = value;
    this.resetCache();
    if (this.visible)
      this._parentRenderer.redraw();
  }
  get max() {
    return this._max;
  }
  set max(value) {
    if (value <= this._min && !YDataRenderer.minMaxCheckDisabled) {
      throw new RangeError("Max cannot be greater than min (" + this._min.toString() + ")");
    }
    this._max = value;
    this.resetCache();
    if (this.visible)
      this._parentRenderer.redraw();
  }
};
var Proportional = class {
  get userData() {
    return this._userData;
  }
  set userData(value) {
    this._userData = value;
  }
  get directParent() {
    return this._directParent;
  }
  get value() {
    return this._value;
  }
  set value(v) {
    this._value = v;
    this.set_refPoint();
    if (this._reset != null)
      this._reset(this);
  }
  get resizeRule() {
    return this._resizeRule;
  }
  set resizeRule(value) {
    this.set_refPoint();
    this._resizeRule = value;
  }
  set_refPoint() {
    this._refWidth = Math.max(1, this._parentRenderer.usableUiWidth());
    this._refHeight = Math.max(1, this._parentRenderer.usableUiHeight());
    this._refValue = this._value;
  }
  constructor(value, resizeRule, parentRenderer, directParent, resetCallBack) {
    this._reset = null;
    this._refWidth = 1;
    this._refHeight = 1;
    this._refValue = 1;
    this.valueStack = [];
    this._resizeRule = Proportional.ResizeRule.FIXED;
    this._userData = null;
    this._reset = resetCallBack;
    this._parentRenderer = parentRenderer;
    this._value = value;
    this._resizeRule = resizeRule;
    this._directParent = directParent;
    this.set_refPoint();
    this._parentRenderer.AddNewProportionalToSizeValue(this);
  }
  containerResizedPushNewCoef(coef) {
    this.valueStack.push(this._value);
    this._value = Math.round(100 * this._refValue * coef) / 100;
    if (this._reset != null)
      this._reset(this);
  }
  containerResizedPop() {
    if (this.valueStack.length <= 0)
      throw new RangeError("Can't pop, empty stack.");
    this._value = this.valueStack.pop();
    if (this._reset != null)
      this._reset(this);
  }
  static resizeCoef(rule, refWidth, refHeight, newWidth, newHeight) {
    switch (rule) {
      case Proportional.ResizeRule.RELATIVETOWIDTH:
        return newWidth / refWidth;
      case Proportional.ResizeRule.RELATIVETOHEIGHT:
        return newHeight / refHeight;
      case Proportional.ResizeRule.RELATIVETOBOTH:
        return Math.min(newHeight / refHeight, newWidth / refWidth);
    }
    return 1;
  }
  containerResized(newWidth, newHeight) {
    this._value = Math.round(100 * this._refValue * Proportional.resizeCoef(this._resizeRule, this._refWidth, this._refHeight, newWidth, newHeight)) / 100;
    if (this._reset != null)
      this._reset(this);
  }
  forceChangeCallback() {
    if (this._reset != null)
      this._reset(this);
  }
};
(function(Proportional2) {
  class ResizeRuleEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, ResizeRule);
    }
  }
  Proportional2.ResizeRuleEnumItem = ResizeRuleEnumItem;
  class ResizeRule extends YEnum {
  }
  ResizeRule.FIXED = new ResizeRuleEnumItem("FIXED", "Fixed");
  ResizeRule.RELATIVETOWIDTH = new ResizeRuleEnumItem("RELATIVETOWIDTH", "Relative to Width");
  ResizeRule.RELATIVETOHEIGHT = new ResizeRuleEnumItem("RELATIVETOHEIGHT", "Relative to height");
  ResizeRule.RELATIVETOBOTH = new ResizeRuleEnumItem("RELATIVETOBOTH", "Relative to Width and Height");
  Proportional2.ResizeRule = ResizeRule;
})(Proportional || (Proportional = {}));
var YDataRenderer = class {
  get annotationPanels() {
    return this._annotationPanels;
  }
  get userData() {
    return this._userData;
  }
  static get minMaxCheckDisabled() {
    return YDataRenderer._disableMinMaxCheck;
  }
  static set minMaxCheckDisabled(value) {
    YDataRenderer._disableMinMaxCheck = value;
  }
  resetlegendPens() {
  }
  get getCaptureParameters() {
    return this._getCaptureParameters;
  }
  set getCaptureParameters(value) {
    this._getCaptureParameters = value;
  }
  get messagePanels() {
    return this._messagePanels;
  }
  static globalMouseMove(e) {
    YDataRenderer.globalMouseX = e.pageX;
    YDataRenderer.globalMouseY = e.pageY;
  }
  clearTransformationMatrix() {
    this._Scr2ElmMatrix = null;
    this._Elm2ScrMatrix = null;
  }
  findElementAbsolutePosition(el) {
    let staticFound = false;
    let relativeFound = false;
    let dx = 0;
    let dy = 0;
    while (el != null) {
      let style = window.getComputedStyle(el);
      if (!relativeFound && style.position == "static" && !staticFound) {
        dx = el.offsetLeft + parseFloat(style.borderLeftWidth);
        dy = el.offsetTop + parseFloat(style.borderTopWidth);
        staticFound = true;
      }
      if (style.position == "relative" || style.position == "absolute") {
        dx += el.offsetLeft + parseFloat(style.borderLeftWidth);
        dy += el.offsetTop + parseFloat(style.borderTopWidth);
        relativeFound = true;
      }
      el = el.parentElement;
    }
    return new PointF(dx, dy);
  }
  get Elm2ScrMatrix() {
    if (this._Elm2ScrMatrix == null) {
      let el = this.UIContainer;
      let AsolutePositionsStack = [];
      while (el != null) {
        AsolutePositionsStack.push(this.findElementAbsolutePosition(el));
        el = el.parentElement;
      }
      el = this.UIContainer;
      let MatrixStack = [];
      let staticFound = false;
      let relativeFound = false;
      let index = 0;
      while (el != null) {
        let parent = el.parentElement;
        let style = window.getComputedStyle(el);
        let dx = AsolutePositionsStack[index].X;
        let dy = AsolutePositionsStack[index].Y;
        if (index < AsolutePositionsStack.length - 1) {
          dx -= AsolutePositionsStack[index + 1].X;
          dy -= AsolutePositionsStack[index + 1].Y;
        }
        let matrix = style["transform"];
        if (matrix != "none") {
          let matrixStr = matrix.match(/matrix.*\((.+)\)/)[1].split(", ");
          let matrixValues = [];
          for (let i = 0; i < 6; i++) {
            matrixValues.push(parseFloat(matrixStr[i]));
          }
          let OriginMatrixMatrixBefore = null;
          let TransformMatrix = Matrix3x3.newMatrix(matrixValues[0], matrixValues[2], matrixValues[4], matrixValues[1], matrixValues[3], matrixValues[5], 0, 0, 1);
          let OriginMatrixMatrixAfter = null;
          if (style.transformOrigin) {
            let parts = style.transformOrigin.split(" ");
            let Ox = Number.parseFloat(parts[0]);
            let Oy = Number.parseFloat(parts[1]);
            OriginMatrixMatrixBefore = Matrix3x3.newTranslateMatrix(-Ox, -Oy);
            OriginMatrixMatrixAfter = Matrix3x3.newTranslateMatrix(Ox, Oy);
          }
          if (OriginMatrixMatrixBefore != null)
            MatrixStack.push(OriginMatrixMatrixBefore);
          if (TransformMatrix != null)
            MatrixStack.push(TransformMatrix);
          if (OriginMatrixMatrixAfter != null)
            MatrixStack.push(OriginMatrixMatrixAfter);
        }
        if (dx != 0 || dy != 0)
          MatrixStack.push(Matrix3x3.newTranslateMatrix(dx, dy));
        el = parent;
        index++;
      }
      this._Elm2ScrMatrix = Matrix3x3.newIdentityMatrix();
      for (let i = MatrixStack.length - 1; i >= 0; i--) {
        this._Elm2ScrMatrix = this._Elm2ScrMatrix.multiplyByM(MatrixStack[i]);
      }
    }
    return this._Elm2ScrMatrix;
  }
  get Scr2ElmMatrix() {
    if (this._Scr2ElmMatrix == null) {
      this._Scr2ElmMatrix = this.Elm2ScrMatrix.inverse;
    }
    return this._Scr2ElmMatrix;
  }
  addAnnotationPanel() {
    let p = new AnnotationPanel(this, this);
    this._annotationPanels.push(p);
    this.redraw();
    return p;
  }
  AllowRedraw() {
    this._redrawAllowed--;
    if (this._redrawAllowed < 0)
      throw new RangeError("Too many AllowRedraw calls");
    if (this._redrawAllowed == 0)
      this.redraw();
  }
  AllowRedrawNoRefresh() {
    this._redrawAllowed--;
    if (this._redrawAllowed < 0)
      throw new RangeError("Too many AllowRedraw calls");
  }
  DisableRedraw() {
    this._redrawAllowed++;
  }
  AddNewProportionalToSizeValue(v) {
    if (this.ProportionalToSizeValues.indexOf(v) < 0)
      this.ProportionalToSizeValues.push(v);
  }
  canRedraw() {
    return this._redrawAllowed == 0;
  }
  setPatchAnnotationCallback(callback) {
    this._PatchAnnotationCallback = callback;
  }
  patchAnnotation(text) {
    text = text.replace("\\n", "\n");
    if (text.indexOf("$") < 0)
      return text;
    let now = new Date();
    text = text.replace("$DAY$", now.getDay().toString());
    text = text.replace("$MONTH$", now.getMonth().toString());
    text = text.replace("$YEAR$", now.getFullYear().toString());
    text = text.replace("$HOUR$", now.getHours().toString());
    text = text.replace("$MINUTE$", now.getMinutes().toString());
    text = text.replace("$SECOND$", now.getSeconds().toString());
    if (this._PatchAnnotationCallback != null)
      text = this._PatchAnnotationCallback(text);
    return text;
  }
  mouseLocalPosition() {
    let v = Vector3.FromXYCoord(YDataRenderer.globalMouseX, YDataRenderer.globalMouseY);
    let m = this.Scr2ElmMatrix;
    let p = m.multiplyByV(v).toPoint();
    if (p.X < 0 || p.Y < 0 || p.X > this.UIContainer.offsetWidth || p.Y > this.UIContainer.offsetHeight)
      return null;
    return p;
  }
  set proportionnalValueChangeCallback(value) {
    this._proportionnalValueChangeCallback = value;
  }
  ProportionnalValueChanged(source) {
    if (this._proportionnalValueChangeCallback != null)
      this._proportionnalValueChangeCallback(source);
  }
  getContainerInnerWidth() {
    return this.UIContainer.offsetWidth;
  }
  getContainerInnerHeight() {
    return this.UIContainer.offsetHeight;
  }
  Draw(timestamp) {
    if (!this.canRedraw())
      return 0;
    let w = this.getContainerInnerWidth();
    let h = this.getContainerInnerHeight();
    if (w <= 5 || h <= 5)
      return 0;
    this.DisableRedraw();
    let offscreenCanvas = document.createElement("canvas");
    offscreenCanvas.width = w;
    offscreenCanvas.height = h;
    let g = new YGraphics(offscreenCanvas, w, h, 90);
    let start = performance.now();
    try {
      this.Render(g, w, h);
    } catch (e) {
      debugger;
      this.log("Rendering error: " + e.message);
    }
    let elapsed = performance.now() - start;
    let drawArea = this.UIContainer.getContext("2d");
    drawArea.clearRect(0, 0, w, h);
    drawArea.drawImage(offscreenCanvas, 0, 0);
    this.rendererTimingTotal += elapsed;
    this.rendererTimingCount++;
    let avg = this.rendererTimingTotal / this.rendererTimingCount;
    g.Dispose();
    this.AllowRedrawNoRefresh();
    this.renderingPostProcessing();
    return 0;
  }
  renderingPostProcessing() {
  }
  get resizeRule() {
    return this._resizeRule;
  }
  set resizeRule(value) {
    if (value != this._resizeRule) {
      this.DisableRedraw();
      this._resizeRule = value;
      for (let i = 0; i < this.ProportionalToSizeValues.length; i++) {
        this.ProportionalToSizeValues[i].resizeRule = this._resizeRule;
      }
      this.AllowRedraw();
      this.redraw();
    }
  }
  redraw() {
    if (!(document.visibilityState === "visible"))
      return;
    if (this._redrawAllowed > 0)
      return;
    if (this.getContainerInnerWidth() < 2)
      return;
    if (this.getContainerInnerHeight() < 2)
      return;
    if (this.requestAnimationFrameID != null) {
      window.cancelAnimationFrame(this.requestAnimationFrameID);
    }
    this.requestAnimationFrameID = window.requestAnimationFrame((timestamp) => {
      try {
        this.Draw(timestamp);
      } catch (e) {
        console.log("caught");
        this.requestAnimationFrameID = null;
        throw e;
      }
      this.requestAnimationFrameID = null;
    });
  }
  usableUiWidth() {
    return this.getContainerInnerWidth();
  }
  usableUiHeight() {
    return this.getContainerInnerHeight();
  }
  resetProportionalSizeObjectsCachePush(newcoef) {
    this.clearCachedObjects();
    if (this._resizeRule != Proportional.ResizeRule.FIXED) {
      for (let i = 0; i < this.ProportionalToSizeValues.length; i++) {
        this.ProportionalToSizeValues[i].containerResizedPushNewCoef(newcoef);
      }
    }
  }
  resetProportionalSizeObjectsCachePop() {
    this.clearCachedObjects();
    if (this._resizeRule != Proportional.ResizeRule.FIXED) {
      for (let i = 0; i < this.ProportionalToSizeValues.length; i++) {
        this.ProportionalToSizeValues[i].containerResizedPop();
      }
    }
  }
  resetProportionalSizeObjectsCache(w, h) {
    this.clearCachedObjects();
    if (this._resizeRule != Proportional.ResizeRule.FIXED) {
      for (let i = 0; i < this.ProportionalToSizeValues.length; i++) {
        this.ProportionalToSizeValues[i].containerResized(w, h);
      }
    }
  }
  containerResized() {
    this.containerResize(null, null);
  }
  containerResize(sender, e) {
    this.clearTransformationMatrix();
    this.DisableRedraw();
    this.UIContainer.width = this.UIContainer.offsetWidth;
    this.UIContainer.height = this.UIContainer.offsetHeight;
    this.resetProportionalSizeObjectsCache(this.usableUiWidth(), this.usableUiHeight());
    this.AllowRedraw();
    this.redraw();
  }
  proportionnalsizeReset() {
    this.resetProportionalSizeObjectsCache(this.usableUiWidth(), this.usableUiHeight());
  }
  captureAndDownloadImage(captureType, defaultFilename, captureWidth, captureHeight, captureDPI) {
    let error = "";
    let w;
    let h;
    let ratio = this.getContainerInnerWidth() / this.getContainerInnerHeight();
    if (captureDPI == null)
      captureDPI = 90;
    if (defaultFilename == null || typeof defaultFilename == "undefined") {
      defaultFilename = "capture.";
      if (captureType == YDataRenderer.CaptureType.PNG) {
        defaultFilename = defaultFilename + "png";
      }
      if (captureType == YDataRenderer.CaptureType.SVG) {
        defaultFilename = defaultFilename + "svg";
      }
    }
    if (captureWidth == null || typeof captureWidth == "undefined") {
      w = this.getContainerInnerWidth();
      if (captureHeight == null || typeof captureHeight == "undefined") {
        h = this.getContainerInnerHeight();
      } else {
        h = captureHeight >> 0;
        w = h * ratio >> 0;
      }
    } else {
      w = captureWidth >> 0;
      if (captureHeight == null || typeof captureHeight == "undefined") {
        h = w * ratio >> 0;
      } else {
        h = captureHeight >> 0;
      }
    }
    if (w <= 5 || h <= 5)
      return;
    this.DisableRedraw();
    let DrawArea = document.createElement("canvas");
    DrawArea.width = w;
    DrawArea.height = h;
    let g;
    switch (captureType) {
      case YDataRenderer.CaptureType.PNG:
        g = new YGraphics(DrawArea, w, h, captureDPI);
        break;
      case YDataRenderer.CaptureType.SVG:
        g = new YGraphicsSVG(DrawArea, w, h, captureDPI);
        break;
      default:
        throw new RangeError("capture :unknown type");
    }
    let newCoef = Proportional.resizeCoef(Proportional.ResizeRule.RELATIVETOBOTH, this.refWidth, this.refHeight, w, h);
    this.log("start capture");
    this.resetProportionalSizeObjectsCachePush(newCoef);
    let renderok = false;
    this._snapshotPanel.enabled = false;
    try {
      let t = this.Render(g, w, h);
      renderok = true;
    } catch (e) {
      error = e.message;
      this.log("Render error: " + error);
    }
    this.log("capture completed");
    this.resetProportionalSizeObjectsCachePop();
    if (renderok) {
      let element = document.createElement("a");
      let data = g.get_downloadableData();
      element.setAttribute("href", data);
      element.setAttribute("download", defaultFilename);
      element.style.display = "none";
      document.body.appendChild(element);
      element.click();
      document.body.removeChild(element);
    }
    g.Dispose();
    this.AllowRedraw();
  }
  getFocus(sender, e) {
    this.log("got focus");
  }
  gainFocus() {
  }
  lostFocus(sender, e) {
  }
  get AllowPrintScreenCapture() {
    return this._AllowPrintScreenCapture;
  }
  set AllowPrintScreenCapture(value) {
    this._AllowPrintScreenCapture = value;
  }
  constructor(UIContainer, logFunction) {
    this._redrawAllowed = 1;
    this._refWidth = 1;
    this._refHeight = 1;
    this.rendererTimingTotal = 0;
    this.rendererTimingCount = 0;
    this._PatchAnnotationCallback = null;
    this._logFunction = null;
    this._annotationPanels = [];
    this._userData = null;
    this.documentVisibiltyChangeFct = null;
    this.containerResizedFct = null;
    this._getCaptureParameters = null;
    this.OnDblClick = null;
    this.OnRightClick = null;
    this._messagePanels = [];
    this._Scr2ElmMatrix = null;
    this._Elm2ScrMatrix = null;
    this.ProportionalToSizeValues = [];
    this._proportionnalValueChangeCallback = null;
    this._resizeRule = Proportional.ResizeRule.FIXED;
    this.requestAnimationFrameID = null;
    this._snapshotPanel = null;
    this._snapshotTimer = null;
    this._AllowPrintScreenCapture = false;
    if (!YDataRenderer.globalMouseMoveSet) {
      document.addEventListener("mousemove", (e) => {
        YDataRenderer.globalMouseMove(e);
      });
      YDataRenderer.globalMouseMoveSet = true;
    }
    this.UIContainer = UIContainer;
    this.UIContainer.width = this.getContainerInnerWidth();
    this.UIContainer.height = this.getContainerInnerHeight();
    this._logFunction = logFunction;
    this.parentForm = UIContainer.ownerDocument;
    this._annotationPanels = [];
    this._messagePanels = [];
    this.DisableRedraw();
    this._snapshotPanel = this.addMessagePanel();
    this._snapshotPanel.panelTextAlign = MessagePanel.TextAlign.CENTER;
    this._snapshotPanel.text = "Captured to clipboard";
    this._snapshotPanel.panelHrzAlign = MessagePanel.HorizontalAlignPos.CENTER;
    this._snapshotPanel.panelVrtAlign = MessagePanel.VerticalAlignPos.CENTER;
    this._snapshotPanel.bgColor = new YColor(false, 200, 204, 247, 161);
    this._snapshotPanel.font.size = 16;
    this.AllowRedrawNoRefresh();
    this.containerResizedFct = () => {
      this.containerResize(null, null);
    };
    document.addEventListener("resize", this.containerResizedFct);
    this.resetRefrenceSize();
    this.documentVisibiltyChangeFct = () => {
      if (document.visibilityState === "visible") {
        this.redraw();
      }
    };
    document.addEventListener("visibilitychange", this.documentVisibiltyChangeFct);
  }
  destroy() {
    document.removeEventListener("visibilitychange", this.documentVisibiltyChangeFct);
    document.removeEventListener("resize", this.containerResized);
    this.UIContainer.parentNode.removeChild(this.UIContainer);
    this.UIContainer = null;
    this.parentForm = null;
    this._annotationPanels = null;
    this._messagePanels = null;
    this._Scr2ElmMatrix = null;
    this._Elm2ScrMatrix = null;
  }
  resetRefrenceSize() {
    this._refWidth = this.getContainerInnerWidth();
    this._refHeight = this.getContainerInnerHeight();
  }
  get refWidth() {
    return this._refWidth;
  }
  get refHeight() {
    return this._refHeight;
  }
  RendererCanvas_Click(sender, e) {
  }
  RendererCanvas_DoubleClick(sender, e) {
  }
  addMessagePanel() {
    let p = new MessagePanel(this, this);
    this._messagePanels.push(p);
    return p;
  }
  DrawMessagePanels(g, viewPortWidth, viewPortHeight) {
    for (let i = 0; i < this._messagePanels.length; i++) {
      if (this._messagePanels[i].enabled) {
        let p = this._messagePanels[i];
        let AvailableWidth = viewPortWidth - 2 * p.padding - p.borderthickness;
        if (AvailableWidth < 100)
          AvailableWidth = 100;
        let ssize = null;
        let sizeok = false;
        while (!sizeok) {
          ssize = g.MeasureString(p.text, p.font, AvailableWidth);
          if ((ssize.width >= this.UIContainer.width || ssize.height >= this.UIContainer.height) && p.font.size > 5) {
            p.font.size = Math.round(p.font.size * 9) / 10;
          } else
            sizeok = true;
        }
        if (ssize == null)
          return;
        let panelWidth = ssize.width + 2 * p.padding + p.borderthickness;
        let panelHeight = ssize.height + 2 * p.padding + p.borderthickness;
        let x = 0;
        switch (p.panelHrzAlign) {
          case MessagePanel.HorizontalAlignPos.LEFT:
            x = p.horizontalMargin;
            break;
          case MessagePanel.HorizontalAlignPos.RIGHT:
            x = viewPortWidth - panelWidth - p.horizontalMargin;
            break;
          default:
            x = (viewPortWidth - panelWidth) / 2;
            break;
        }
        let y = 0;
        switch (p.panelVrtAlign) {
          case MessagePanel.VerticalAlignPos.TOP:
            y = p.verticalMargin;
            break;
          case MessagePanel.VerticalAlignPos.BOTTOM:
            y = viewPortHeight - panelHeight - p.verticalMargin;
            break;
          default:
            y = (viewPortHeight - panelHeight) / 2;
            break;
        }
        g.FillRectangleXYHW(p.bgBrush, x, y, panelWidth, panelHeight);
        if (p.borderthickness > 0)
          g.DrawRectangleXYHW(p.pen, x, y, panelWidth, panelHeight);
        let sf = new YStringFormat(16384);
        switch (p.panelTextAlign) {
          case MessagePanel.TextAlign.LEFT:
            sf.LineAlignment = 0;
            sf.Alignment = 0;
            break;
          case MessagePanel.TextAlign.RIGHT:
            sf.LineAlignment = 2;
            sf.Alignment = 2;
            break;
          default:
            sf.LineAlignment = 1;
            sf.Alignment = 1;
            break;
        }
        let r = new YRectangle(x + p.padding + p.borderthickness / 2 >> 0, y + p.padding + p.borderthickness / 2 >> 0, ssize.width + 1, ssize.height + 1);
        g.DrawStringRect(p.text, p.font, p.font.brush, r, sf);
      }
    }
  }
  drawAnnotationPanels(g, annotationPanels, viewPortWidth, viewPortHeight, overlap, mainViewPort) {
    let active = false;
    for (let i = 0; i < this.annotationPanels.length; i++) {
      if (this.annotationPanels[i].enabled)
        active = true;
    }
    if (!active)
      return;
    for (let i = 0; i < this.annotationPanels.length; i++) {
      if (annotationPanels[i].enabled && annotationPanels[i].overlap == overlap) {
        let p = annotationPanels[i];
        let AvailableWidth = viewPortWidth - 2 * p.padding - p.borderthickness;
        if (AvailableWidth < 100)
          AvailableWidth = 100;
        let textToDisplay = p.text.replace("\\n", "\n");
        if (textToDisplay.indexOf("$") >= 0) {
          textToDisplay = textToDisplay.replace("\\n", "\n");
          textToDisplay = this.patchAnnotation(textToDisplay);
        }
        let ssize = g.MeasureString(textToDisplay, p.font, AvailableWidth);
        let panelWidth = ssize.width + 2 * p.padding + p.borderthickness;
        let panelHeight = ssize.height + 2 * p.padding + p.borderthickness;
        let x = 0;
        switch (p.panelHrzAlign) {
          case MessagePanel.HorizontalAlignPos.LEFT:
            x = p.horizontalMargin;
            if (!annotationPanels[i].overlap && mainViewPort.Lmargin < panelWidth + 10) {
              mainViewPort.Lmargin = panelWidth + 10;
            }
            break;
          case MessagePanel.HorizontalAlignPos.RIGHT:
            x = viewPortWidth - panelWidth - p.horizontalMargin;
            if (!annotationPanels[i].overlap && mainViewPort.Rmargin < panelWidth + 20) {
              mainViewPort.Rmargin = panelWidth + 20;
            }
            break;
          default:
            x = (viewPortWidth - panelWidth) / 2;
            break;
        }
        let y = 0;
        switch (p.panelVrtAlign) {
          case MessagePanel.VerticalAlignPos.TOP:
            y = p.verticalMargin;
            if (!annotationPanels[i].overlap && mainViewPort.Tmargin < panelHeight + 20) {
              mainViewPort.Tmargin = panelHeight + 20;
            }
            break;
          case MessagePanel.VerticalAlignPos.BOTTOM:
            y = viewPortHeight - panelHeight - p.verticalMargin;
            if (!annotationPanels[i].overlap && mainViewPort.Bmargin < panelHeight + 20) {
              mainViewPort.Bmargin = panelHeight + 20;
            }
            break;
          default:
            y = (viewPortHeight - panelHeight) / 2;
            break;
        }
        if (annotationPanels[i].overlap) {
          x += annotationPanels[i].positionOffsetX / 100 * (viewPortWidth - panelWidth);
          y += annotationPanels[i].positionOffsetY / 100 * (viewPortHeight - panelHeight);
          if (x < 0)
            x = 0;
          if (y < 0)
            y = 0;
          if (x > viewPortWidth - panelWidth)
            x = viewPortWidth - panelWidth;
          if (y > viewPortHeight - panelHeight)
            y = viewPortHeight - panelHeight;
        }
        g.FillRectangleXYHW(p.bgBrush, x, y, panelWidth, panelHeight);
        if (p.borderthickness > 0)
          g.DrawRectangleXYHW(p.pen, x, y, panelWidth, panelHeight);
        let sf = new YStringFormat(16384);
        switch (p.panelTextAlign) {
          case MessagePanel.TextAlign.LEFT:
            sf.LineAlignment = 0;
            sf.Alignment = 0;
            break;
          case MessagePanel.TextAlign.RIGHT:
            sf.LineAlignment = 2;
            sf.Alignment = 2;
            break;
          default:
            sf.LineAlignment = 1;
            sf.Alignment = 1;
            break;
        }
        let r = new YRectangle(x + p.padding + p.borderthickness / 2, y + p.padding + p.borderthickness / 2, ssize.width + 1, ssize.height + 1);
        g.DrawStringRect(textToDisplay, p.font, p.font.brush, r, sf);
      }
    }
  }
  log(s) {
    if (this._logFunction == null)
      return;
    this._logFunction(s);
  }
};
YDataRenderer.RendererDebug = false;
YDataRenderer.FloatToStrformats = ["0", "0", "0", "0.0", "0.00", "0.000", "0.0000"];
YDataRenderer._disableMinMaxCheck = false;
YDataRenderer.globalMouseMoveSet = false;
YDataRenderer.globalMouseX = -1;
YDataRenderer.globalMouseY = -1;
(function(YDataRenderer2) {
  class CaptureTypeEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, CaptureType);
    }
  }
  YDataRenderer2.CaptureTypeEnumItem = CaptureTypeEnumItem;
  class CaptureType extends YEnum {
  }
  CaptureType.PNG = new CaptureTypeEnumItem("PNG", "Bitmap (PNG)");
  CaptureType.SVG = new CaptureTypeEnumItem("SVG", "Vector (SVG)");
  YDataRenderer2.CaptureType = CaptureType;
  class CaptureTargetEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, CaptureTarget);
    }
  }
  YDataRenderer2.CaptureTargetEnumItem = CaptureTargetEnumItem;
  class CaptureTarget extends YEnum {
  }
  CaptureTarget.ToClipBoard = new CaptureTargetEnumItem("ToClipBoard", "ClipBoard");
  CaptureTarget.ToFile = new CaptureTargetEnumItem("ToFile", "File");
  YDataRenderer2.CaptureTarget = CaptureTarget;
  class CaptureFormatsEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, CaptureFormats);
    }
  }
  YDataRenderer2.CaptureFormatsEnumItem = CaptureFormatsEnumItem;
  class CaptureFormats extends YEnum {
  }
  CaptureFormats.Keep = new CaptureFormatsEnumItem("Keep", "Keep original size");
  CaptureFormats.Fixed = new CaptureFormatsEnumItem("Fixed", "Fixed size");
  CaptureFormats.FixedWidth = new CaptureFormatsEnumItem("FixedWidth", "Fixed width, keep ration aspect");
  CaptureFormats.FixedHeight = new CaptureFormatsEnumItem("FixedHeight", "Fixed height, keep ration aspect");
  YDataRenderer2.CaptureFormats = CaptureFormats;
})(YDataRenderer || (YDataRenderer = {}));
var YGraphics = class {
  constructor(canvas, width, height, dpi) {
    this._c = null;
    this._g = null;
    this._width = 0;
    this._height = 0;
    this._dpi = 0;
    this._image = null;
    this._lastPen = null;
    this._lastBrush = null;
    this._lastFont = null;
    this._clipCounter = 0;
    this._textRenderingHint = null;
    this._smoothingMode = YSmoothingMode.Default;
    this._c = canvas;
    this._g = this._c.getContext("2d");
    this._g.textBaseline = "top";
    this._width = width;
    this._height = height;
    this._dpi = dpi;
  }
  get_downloadableData() {
    return this._c.toDataURL("image/png");
  }
  get graphics() {
    return this._g;
  }
  setPen(p) {
    if (p == this._lastPen)
      return;
    if (p != null) {
      this._g.lineWidth = p.lineWidth;
      let st = p.strokeStyle;
      this._g.strokeStyle = p.strokeStyle;
    } else {
      this._g.lineWidth = 0;
    }
    this._lastPen = p;
  }
  setBrush(b) {
    if (b == this._lastBrush)
      return;
    if (b instanceof YSolidBrush) {
      this._g.fillStyle = b.color.htmlCode;
    } else if (b instanceof YLinearGradientBrush) {
      let lingrad = this._g.createLinearGradient(0, 0, 0, this._height);
      lingrad.addColorStop(0, b.color1.htmlCode);
      lingrad.addColorStop(1, b.color2.htmlCode);
      this._g.fillStyle = lingrad;
    } else {
      throw new Error("invalid / insupported brush type");
    }
    this._lastBrush = b;
  }
  setFont(f) {
    if (f == this._lastFont && !f.hasChanged)
      return;
    this._g.font = f.htmlCode;
    this._lastFont = f;
  }
  DrawLineXY(p, x1, y1, x2, y2) {
    if (p.noAntiAlias) {
      let offset = p.lineWidth == p.lineWidth >> 0 && (p.lineWidth & 1) == 1 ? 0.5 : 0;
      x1 = Math.round(x1) + offset;
      y1 = Math.round(y1) + offset;
      x2 = Math.round(x2) + offset;
      y2 = Math.round(y2) + offset;
    }
    this.setPen(p);
    this._g.beginPath();
    this._g.moveTo(x1, y1);
    this._g.lineTo(x2, y2);
    this._g.stroke();
  }
  DrawLine(p, p1, p2) {
    this.setPen(p);
    this._g.beginPath();
    this._g.moveTo(p1.X, p1.Y);
    this._g.lineTo(p2.X, p2.Y);
    this._g.stroke();
  }
  SetClip(rect) {
    this._g.save();
    this._g.beginPath();
    this._g.rect(rect.x, rect.y, rect.w, rect.h);
    this._g.clip();
    this._clipCounter++;
  }
  ResetClip() {
    if (this._clipCounter <= 0)
      throw new Error("clipping stack error");
    this._g.restore();
    this._clipCounter--;
  }
  MeasureString(text, font, width) {
    this.setFont(font);
    let res = new YSizeF(font, text);
    let count = res.linesCount;
    if (count == 0)
      return res;
    res.height = res.firstLineHeight * 1.2 + (count - 1) * res.lineHeight;
    let max = 0;
    let dim;
    for (let i = 0; i < count; i++) {
      dim = this._g.measureText(res.lines[i]);
      max = Math.max(max, dim.width);
    }
    res.width = max;
    return res;
  }
  MeasureStringSF(text, font, width, stringFormat) {
    return this.MeasureString(text, font, width);
  }
  FillRectangle(brush, rect) {
    this.setBrush(brush);
    this._g.beginPath();
    this._g.fillRect(rect.x, rect.y, rect.w, rect.h);
    this._g.fill();
  }
  FillRectangleXYHW(brush, x, y, width, height) {
    this.setBrush(brush);
    this._g.beginPath();
    this._g.fillRect(x, y, width, height);
    this._g.fill();
  }
  DrawRectangle(p, rect) {
    this.setPen(p);
    this._g.beginPath();
    if (p.noAntiAlias) {
      let offset = p.lineWidth == p.lineWidth >> 0 && (p.lineWidth & 1) == 1 ? 0.5 : 0;
      this._g.rect(Math.round(rect.x) + offset, Math.round(rect.y) + offset, Math.round(rect.w), Math.round(rect.h));
    } else {
      this._g.rect(rect.x, rect.y, rect.w, rect.h);
    }
    this._g.stroke();
  }
  DrawRectangleXYHW(p, x, y, width, height) {
    if (p.noAntiAlias) {
      let offset = p.lineWidth == p.lineWidth >> 0 && (p.lineWidth & 1) == 1 ? 0.5 : 0;
      x = Math.round(x) + offset;
      y = Math.round(y) + offset;
      width = Math.round(width);
      height = Math.round(height);
    }
    this.setPen(p);
    this._g.beginPath();
    this._g.rect(x, y, width, height);
    this._g.stroke();
  }
  DrawStringXY(s, font, brush, x, y) {
    this.setPen(null);
    this.setBrush(brush);
    this.setFont(font);
    let totalsz = this.MeasureString(s, font, 0);
    let dy = totalsz.lineHeight;
    for (let i = 0; i < totalsz.linesCount; i++) {
      this._g.fillText(totalsz.lines[i], x, y);
      y += dy;
    }
  }
  DrawStringXYF(s, font, brush, x, y, format) {
    if (YGraphics._debugDrawString) {
      let pen = new YPen(YColor.Red, 1);
      this.DrawLineXY(pen, x - 5, y, x + 5, y);
      this.DrawLineXY(pen, x, y - 5, x, y + 5);
    }
    let sz = this.MeasureString(s, font, 1e4);
    if (format.Alignment == 1) {
      x -= sz.width >> 1;
    } else if (format.Alignment == 2)
      x -= sz.width;
    if (format.LineAlignment == 1) {
      y -= sz.height / 2 >> 0;
    } else if (format.LineAlignment == 2)
      y -= sz.height;
    this.DrawStringXY(s, font, brush, x, y);
  }
  DrawStringPF(s, font, brush, p, format) {
    this.DrawStringXYF(s, font, brush, p.X, p.Y, format);
  }
  DrawString(s, font, brush, p) {
    if (YGraphics._debugDrawString) {
      let pen = new YPen(YColor.Red, 1);
      this.DrawLineXY(pen, p.X - 5, p.Y, p.X + 5, p.Y);
      this.DrawLineXY(pen, p.X, p.Y - 5, p.X, p.Y + 5);
    }
    this.setPen(null);
    this.setBrush(brush);
    this.setFont(font);
    this._g.fillText(s, p.X, p.Y);
  }
  DrawStringRect(s, font, brush, layoutRectangle, format) {
    if (YGraphics._debugDrawString) {
      let pen = new YPen(YColor.Red, 1);
      this.DrawRectangle(pen, layoutRectangle);
    }
    this.setPen(null);
    this.setBrush(brush);
    this.setFont(font);
    let totalsz = this.MeasureString(s, font, 0);
    let dy = totalsz.lineHeight;
    let y = layoutRectangle.y;
    switch (format.LineAlignment) {
      case 0:
        break;
      case 1:
        y += (layoutRectangle.h - totalsz.height) / 2;
        break;
      case 2:
        y += layoutRectangle.h - totalsz.height;
        break;
    }
    let xOrigin = layoutRectangle.x;
    if (format.FormatFlags & 2) {
      this.Transform(layoutRectangle.x, layoutRectangle.y, Math.PI / 2);
      y -= layoutRectangle.y + layoutRectangle.w;
      xOrigin -= layoutRectangle.x;
    }
    for (let i = 0; i < totalsz.linesCount; i++) {
      let s2 = totalsz.lines[i];
      let sz = this.MeasureString(s2, font, 0);
      let x = xOrigin;
      switch (format.Alignment) {
        case 0:
          break;
        case 1:
          x += (layoutRectangle.w - sz.width) / 2;
          break;
        case 2:
          x += layoutRectangle.w - sz.width;
          break;
      }
      this._g.fillText(s2, x, y);
      y += dy;
    }
    if (format.FormatFlags & 2)
      this.ResetTransform();
  }
  Transform(dx, dy, angle) {
    let sin = Math.sin(angle);
    let cos = Math.cos(angle);
    this._g.save();
    this._g.transform(cos, sin, -sin, cos, dx, dy);
  }
  ResetTransform() {
    this._g.restore();
  }
  FillEllipse(brush, x, y, width, height) {
    this.setBrush(brush);
    this._g.beginPath();
    this._g.ellipse(x + width / 2, y + height / 2, width / 2, height / 2, 0, 0, 2 * Math.PI);
    this._g.fill();
  }
  DrawEllipse(pen, x, y, width, height) {
    this.setPen(pen);
    this._g.beginPath();
    this._g.ellipse(x + width / 2, y + height / 2, width / 2, height / 2, 0, 0, 2 * Math.PI);
    this._g.stroke();
  }
  FillPolygon(brush, points) {
    this.setBrush(brush);
    if (points.length <= 2)
      return;
    this._g.beginPath();
    if (brush.noAntiAlias) {
      this._g.moveTo(Math.round(points[0].X) + 0.5, Math.round(points[0].Y) + 0.5);
      for (let i = 1; i < points.length; i++) {
        this._g.lineTo(Math.round(points[i].X) + 0.5, Math.round(points[i].Y) + 0.5);
      }
    } else {
      this._g.moveTo(points[0].X, points[0].Y);
      for (let i = 1; i < points.length; i++) {
        this._g.lineTo(points[i].X, points[i].Y);
      }
    }
    this._g.closePath();
    this._g.fill();
  }
  DrawPolygon(pen, points) {
    this.setPen(pen);
    if (points.length <= 1)
      return;
    this._g.beginPath();
    if (pen.noAntiAlias) {
      let offset = pen.lineWidth == pen.lineWidth >> 0 && (pen.lineWidth & 1) == 1 ? 0.5 : 0;
      this._g.moveTo(Math.round(points[0].X) + offset, Math.round(points[0].Y) + offset);
      for (let i = 1; i < points.length; i++) {
        this._g.lineTo(Math.round(points[i].X) + offset, Math.round(points[i].Y) + offset);
      }
    } else {
      this._g.moveTo(points[0].X, points[0].Y);
      for (let i = 1; i < points.length; i++) {
        this._g.lineTo(points[i].X, points[i].Y);
      }
    }
    this._g.closePath();
    this._g.stroke();
  }
  DrawLines(pen, points) {
    this.setPen(pen);
    if (points.length <= 1)
      return;
    this._g.beginPath();
    this._g.lineCap = "round";
    this._g.lineJoin = "round";
    this._g.moveTo(points[0].X, points[0].Y);
    for (let i = 1; i < points.length; i++) {
      this._g.lineTo(points[i].X, points[i].Y);
    }
    this._g.stroke();
  }
  Dispose() {
    this._c = null;
    this._g = null;
    this._width = 0;
    this._height = 0;
    this._dpi = 0;
  }
  get TextRenderingHint() {
    return this._textRenderingHint;
  }
  set TextRenderingHint(value) {
    this._textRenderingHint = value;
  }
  get SmoothingMode() {
    return this._smoothingMode;
  }
  set SmoothingMode(value) {
    this._smoothingMode = value;
  }
  DrawImage(srcimage, destRect, srcRect, srcUnit) {
    this._g.drawImage(srcimage, srcRect.x, srcRect.y, srcRect.w, srcRect.h, destRect.x, destRect.y, destRect.w, destRect.h);
  }
  comment(s) {
  }
};
YGraphics._debugDrawString = false;
var YGraphicsSVG = class extends YGraphics {
  constructor(canvas, width, height, dpi) {
    super(canvas, width, height, dpi);
    this._clipcount = 0;
    this._clipSectionsToClose = 0;
    this._transformSectionsToClose = 0;
    this._gradientCount = 0;
    YGraphicsSVG.SVGID++;
    this._SVGdefs = new YStringBuilder();
    this._SVGcontents = new YStringBuilder();
    this._SVGdefs.AppendLine('<clipPath id="pageClip_' + YGraphicsSVG.SVGID.toString() + '"><rect x="0" y="0"  width="' + width.toString() + '" height="' + height.toString() + '"/></clipPath>');
  }
  static escapeXml(unsafe) {
    return unsafe.replace(/[^ !#$%(-;=?-z]/g, (c) => "&#" + c.charCodeAt(0) + ";");
  }
  get_downloadableData() {
    return "data:image/svg+xml;base64," + btoa(this.get_svgContents());
  }
  DrawLineXY(p, x1, y1, x2, y2) {
    this._SVGcontents.AppendLine('<line x1="' + x1.toString() + '"  y1 ="' + y1.toString() + '"  x2 ="' + x2.toString() + '"  y2 ="' + y2.toString() + '" style = "stroke:' + p.color.svgCode + ";stroke-opacity:" + p.color.alphaCode + "; stroke-width:" + p.lineWidth.toString() + '"/>');
  }
  DrawLine(p, p1, p2) {
    this.DrawLineXY(p, p1.X, p1.Y, p2.X, p2.Y);
  }
  SetClip(rect) {
    this.ResetClip();
    this._SVGdefs.AppendLine('<clipPath id="clip_' + YGraphicsSVG.SVGID.toString() + "_" + this._clipcount.toString() + '"><rect x="' + rect.x.toString() + '" y="' + rect.y.toString() + '"  width="' + rect.w.toString() + '" height="' + rect.h.toString() + '"/></clipPath>');
    this._SVGcontents.AppendLine('<g clip-path="url(#clip_' + YGraphicsSVG.SVGID.toString() + "_" + this._clipcount.toString() + ')">');
    this._clipcount++;
    this._clipSectionsToClose++;
  }
  ResetClip() {
    if (this._clipSectionsToClose > 0) {
      this._SVGcontents.AppendLine("</g>");
      this._clipSectionsToClose--;
    }
  }
  BrushToSVG(brush, revert) {
    let fillParam = "";
    if (brush instanceof YSolidBrush) {
      fillParam = 'fill = "' + brush.color.svgCode + '" fill-opacity="' + brush.color.alphaCode + '" ';
    } else if (brush instanceof YLinearGradientBrush) {
      this._SVGdefs.AppendLine('<linearGradient id="grad_' + YGraphicsSVG.SVGID.toString() + "_" + this._gradientCount + '" x1="0%" ' + (revert ? 'y1="100%" ' : 'y1="0%" ') + 'x2="0%" ' + (revert ? 'y2="0%" ' : 'y2="100%" ') + '>\r\n<stop offset="0%" style ="stop-color:' + brush.color1.svgCode + ";stop-opacity:" + brush.color1.alphaCode + '"/>\r\n<stop offset="100%" style ="stop-color:' + brush.color2.svgCode + ";stop-opacity:" + brush.color2.alphaCode + '"/>\r\n</linearGradient>');
      fillParam = 'fill="url(#grad_' + YGraphicsSVG.SVGID.toString() + "_" + this._gradientCount + ')" ';
      this._gradientCount++;
    } else {
      throw new ReferenceError("unsupported brush type.");
    }
    return fillParam;
  }
  FillRectangle(brush, rect) {
    this._SVGcontents.AppendLine('<rect x="' + rect.x.toString() + '"  y ="' + rect.y.toString() + '"  width ="' + rect.w.toString() + '"  height ="' + rect.h.toString() + '" ' + this.BrushToSVG(brush, true) + 'style="stroke-width:0"/>');
  }
  FillRectangleXYHW(brush, x, y, width, height) {
    this.FillRectangle(brush, new YRectangle(x, y, width, height));
  }
  DrawRectangle(p, rect) {
    this._SVGcontents.AppendLine('<rect x="' + rect.x.toString() + '"  y ="' + rect.y.toString() + '"  width ="' + rect.w.toString() + '"  height ="' + rect.h.toString() + '"  fill="none" style = "stroke:' + p.color.svgCode + ";stroke-opacity:" + p.color.alphaCode + "; stroke-width:" + p.lineWidth.toString() + '"/>');
  }
  DrawRectangleXYHW(p, x, y, width, height) {
    this.DrawRectangle(p, new YRectangle(x, y, width, height));
  }
  DrawEllipse(pen, x, y, width, height) {
    this._SVGcontents.AppendLine('<ellipse  cx="' + (x + width / 2).toString() + '"  cy ="' + (y + height / 2).toString() + '"  rx ="' + (width / 2).toString() + '"  ry ="' + (height / 2).toString() + '"  fill="none" style = "stroke:' + pen.color.svgCode + ";stroke-opacity:" + pen.color.alphaCode + "; stroke-width:" + pen.lineWidth.toString() + '"/>');
  }
  FillEllipse(brush, x, y, width, height) {
    this._SVGcontents.AppendLine('<ellipse  cx="' + (x + width / 2).toString() + '"  cy ="' + (y + height / 2).toString() + '"  rx ="' + (width / 2).toString() + '"  ry ="' + (height / 2).toString() + '" ' + this.BrushToSVG(brush, false) + 'style="stroke-width:0"/>');
  }
  DrawStringXY(s, font, brush, x, y) {
    let tokens = s.split("\n");
    for (let i = 0; i < tokens.length; i++) {
      s = tokens[i];
      this._SVGcontents.AppendLine('<text x="' + x.toString() + '" y="' + (y + font.sizeInPoints).toString() + '" text-anchor="start" font-family="' + font.name.toString() + '" font-size="' + font.sizeInPoints.toString() + 'pt" font-weight="' + (font.bold ? "bold" : "normal") + '" font-style="' + (font.italic ? "italic" : "normal") + '" ' + this.BrushToSVG(brush, false) + 'style="stroke-width:0">\r\n' + YGraphicsSVG.escapeXml(s) + "\r\n</text>");
      y += font.sizeInPoints * 1.75;
    }
  }
  DrawString(s, font, brush, p) {
    if (YGraphics._debugDrawString) {
      let pen = new YPen(YColor.Red, 1);
      this.DrawLineXY(pen, p.X - 5, p.Y, p.X + 5, p.Y);
      this.DrawLineXY(pen, p.X, p.Y - 5, p.X, p.Y + 5);
    }
    this.DrawStringXY(s, font, brush, p.X, p.Y);
  }
  DrawStringF(s, font, brush, point, format) {
    let totalsz = this.MeasureString(s, font, 0);
    let y = point.Y + font.size * 1.25;
    switch (format.LineAlignment) {
      case 0:
        break;
      case 1:
        y += -totalsz.height / 2;
        break;
      case 2:
        y += -totalsz.height;
        break;
    }
    let tokens = s.split("\n");
    for (let i = 0; i < tokens.length; i++) {
      let s2 = tokens[i];
      let sz = this.MeasureString(s2, font, 0);
      let x = point.X;
      switch (format.Alignment) {
        case 0:
          break;
        case 1:
          x += -sz.width / 2;
          break;
        case 2:
          x += -sz.width;
          break;
      }
      this._SVGcontents.AppendLine('<text x="' + x.toString() + '" y="' + y.toString() + '" text-anchor="start" font-family="' + font.name.toString() + '" font-size="' + font.sizeInPoints.toString() + 'pt" font-weight="' + (font.bold ? "bold" : "normal") + '" font-style="' + (font.italic ? "italic" : "normal") + '" ' + this.BrushToSVG(brush, false) + 'style="stroke-width:0">\r\n' + YGraphicsSVG.escapeXml(s2) + "\r\n</text>");
      y += font.sizeInPoints * 1.75;
    }
  }
  DrawStringRect(s, font, brush, layoutRectangle, format) {
    if (YGraphics._debugDrawString) {
      let pen = new YPen(YColor.Red, 1);
      this.DrawRectangle(pen, layoutRectangle);
    }
    let totalsz = this.MeasureString(s, font, 0);
    let y = layoutRectangle.y + font.sizeInPoints * 1.1;
    switch (format.LineAlignment) {
      case 0:
        break;
      case 1:
        y += (layoutRectangle.h - totalsz.height) / 2;
        break;
      case 2:
        y += layoutRectangle.h - totalsz.height;
        break;
    }
    let tokens = s.split("\n");
    for (let i = 0; i < tokens.length; i++) {
      let s2 = tokens[i];
      let sz = this.MeasureString(s2, font, 0);
      let x = layoutRectangle.x;
      switch (format.Alignment) {
        case 0:
          break;
        case 1:
          x += (layoutRectangle.w - sz.width) / 2;
          break;
        case 2:
          x += layoutRectangle.w - sz.width;
          break;
      }
      this._SVGcontents.AppendLine('<text x="' + x.toString() + '" y="' + y.toString() + '" text-anchor="start" font-family="' + font.name.toString() + '" font-size="' + (font.sizeInPoints * 1.1).toString() + 'pt" font-weight="' + (font.bold ? "bold" : "normal") + '" font-style="' + (font.italic ? "italic" : "normal") + '" ' + this.BrushToSVG(brush, false) + 'style="stroke-width:0">\r\n' + YGraphicsSVG.escapeXml(s2) + "\r\n</text>");
      y += font.sizeInPoints * 1.75;
    }
  }
  Transform(dx, dy, angle) {
    this._SVGcontents.AppendLine('<g transform="translate(' + dx.toString() + " " + dy.toString() + ") rotate(" + (180 * angle / Math.PI).toString() + ')">');
    this._transformSectionsToClose++;
  }
  ResetTransform() {
    if (this._transformSectionsToClose > 0) {
      this._SVGcontents.AppendLine("</g>");
      this._transformSectionsToClose--;
    }
  }
  DrawPolygon(pen, points) {
    if (points.length < 2)
      return;
    this._SVGcontents.Append('<path  d="M ' + points[0].X.toString() + " " + points[0].Y.toString());
    for (let i = 1; i < points.length; i += 1) {
      this._SVGcontents.Append(" L " + points[i].X.toString() + " " + points[i].Y.toString());
    }
    this._SVGcontents.AppendLine(' z" fill="none" style="stroke:' + pen.color.svgCode + ";stroke-opacity:" + pen.color.alphaCode + "; stroke-width:" + pen.lineWidth.toString() + '"/>');
  }
  DrawLines(pen, points) {
    if (points.length < 2)
      return;
    this._SVGcontents.Append('<path  d="M ' + points[0].X.toString() + " " + points[0].Y.toString());
    for (let i = 1; i < points.length; i++) {
      this._SVGcontents.Append(" L " + points[i].X.toString() + " " + points[i].Y.toString());
    }
    this._SVGcontents.AppendLine('" fill="none" style="stroke:' + pen.color.svgCode + ";stroke-opacity:" + pen.color.alphaCode + "; stroke-linecap:round; stroke-linejoin:round;stroke-width:" + pen.lineWidth.toString() + '"/>');
  }
  FillPolygon(brush, points) {
    if (points.length < 2)
      return;
    this._SVGcontents.Append('<path  d="M ' + points[0].X.toString() + " " + points[0].Y.toString());
    for (let i = 1; i < points.length; i++) {
      this._SVGcontents.Append(" L " + points[i].X.toString() + " " + points[i].Y.toString());
    }
    this._SVGcontents.AppendLine(' z" ' + this.BrushToSVG(brush, false) + 'style="stroke-width:0"/>\r\n');
  }
  DrawImage(image, destRect, srcRect, srcUnit) {
    throw new Error("DrawImage not supported, find an other way.");
  }
  save(filename) {
    throw new Error("Direct save to file not supported.");
  }
  comment(s) {
    this._SVGcontents.AppendLine("<!--" + s + "-->");
  }
  get_svgContents() {
    let physicalWidth = (2.54 * (this._width / this._dpi)).toFixed(3);
    let physicalheight = (2.54 * (this._height / this._dpi)).toFixed(3);
    while (this._clipSectionsToClose > 0) {
      this._SVGcontents.AppendLine("</g>");
      this._clipSectionsToClose--;
    }
    while (this._transformSectionsToClose > 0) {
      this._SVGcontents.AppendLine("</g>");
      this._transformSectionsToClose--;
    }
    return '<?xml version = "1.0" standalone = "no" ?>\r\n<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">\r\n<svg width = "' + physicalWidth + 'cm" height = "' + physicalheight + 'cm" viewBox = "0 0 ' + this._width.toString() + " " + this._height.toString() + '" xmlns = "http://www.w3.org/2000/svg" version = "1.1" >\r\n<defs>\r\n' + this._SVGdefs.contents + '</defs>\r\n<g clip-path="url(#pageClip_' + YGraphicsSVG.SVGID.toString() + ')">\r\n' + this._SVGcontents.contents + "</g>\r\n</svg>\n";
  }
};
YGraphicsSVG.SVGID = 0;

// obj/full/Renderer/YAngularGauge.js
var YAngularZone = class extends Zone {
  get path() {
    return this._path;
  }
  setPathSize(count) {
    this._path = new Array(count).fill(null);
  }
  setPathPoint(index, p) {
    this._path[index] = p;
  }
  resetPath() {
    this._path = null;
  }
  resetCache() {
    this.resetPath();
  }
  get width() {
    return this._width;
  }
  set width(value) {
    if (value <= 0)
      throw new RangeError("Width must be a positive value");
    this._width = value;
    this._path = null;
    this._parentRenderer.redraw();
  }
  get outerRadius() {
    return this._outerRadius;
  }
  set outerRadius(value) {
    this._outerRadius = Math.max(0, Math.min(100, value));
    this._path = null;
    this._parentRenderer.redraw();
  }
  constructor(parentRenderer, directParent) {
    super(parentRenderer, directParent);
    this._path = null;
    this._width = 10;
    this._outerRadius = 98;
  }
};
var YAngularGauge = class extends YDataRenderer {
  get min() {
    return this._min;
  }
  set min(value) {
    if (value >= this._max && !YDataRenderer.minMaxCheckDisabled) {
      throw new RangeError("Min cannot be greater than max (" + this._max.toString() + ")");
    }
    this._min = value;
    for (let i = 0; i < this._zones.length; i++) {
      this._zones[i].resetPath();
    }
    if (this._needleValue < this._min) {
      this._needleValue = this._min;
    }
    this.redraw();
  }
  get max() {
    return this._max;
  }
  set max(value) {
    if (value <= this._min && !YDataRenderer.minMaxCheckDisabled) {
      throw new RangeError("Max cannot be less than min (" + this._min.toString() + ")");
    }
    this._max = value;
    for (let i = 0; i < this._zones.length; i++) {
      this._zones[i].resetPath();
    }
    if (this._needleValue > this._max) {
      this._needleValue = this._max;
    }
    this.redraw();
  }
  get borderpen() {
    if (this._borderpen == null) {
      this._borderpen = new YPen(this._borderColor, this._borderThickness);
      this._borderpen.startCap = 1;
      this._borderpen.endCap = 1;
    }
    return this._borderpen;
  }
  get borderColor() {
    return this._borderColor;
  }
  set borderColor(value) {
    this._borderColor = value;
    this._borderpen = null;
    this.redraw();
  }
  get backgroundColor1() {
    return this._backgroundColor1;
  }
  set backgroundColor1(value) {
    this._backgroundColor1 = value;
    this._bgBrush = null;
    this.redraw();
  }
  get backgroundColor2() {
    return this._backgroundColor2;
  }
  set backgroundColor2(value) {
    this._backgroundColor2 = value;
    this._bgBrush = null;
    this.redraw();
  }
  get borderThickness() {
    return this._borderThickness;
  }
  set borderThickness(value) {
    if (value < 0)
      throw new RangeError("thickness must be a positive value");
    this._borderThickness = value;
    this._borderpen = null;
    this.redraw();
  }
  get valueFormater() {
    return this._valueFormater;
  }
  set valueFormater(value) {
    this._valueFormater = value;
    this.redraw();
  }
  get minmaxFormater() {
    return this._minmaxFormater;
  }
  set minmaxFormater(value) {
    this._minmaxFormater = value;
    this.redraw();
  }
  get thickness() {
    return this._thickness;
  }
  set thickness(value) {
    if (value < 0)
      throw new RangeError("Thickness must be a positive value");
    this._thickness = Math.max(Math.min(value, 80), 1);
    this.redraw();
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value;
    this.redraw();
  }
  get color1() {
    return this._color1;
  }
  set color1(value) {
    this._color1 = value;
    this.redraw();
  }
  get color2() {
    return this._color2;
  }
  set color2(value) {
    this._color2 = value;
    this.redraw();
  }
  get graduationColor() {
    return this._graduationColor;
  }
  set graduationColor(value) {
    this._graduationColor = value;
    this._graduationPen = null;
    this.redraw();
  }
  get graduationThickness() {
    return this._graduationThickness;
  }
  set graduationThickness(value) {
    if (value < 0)
      throw new RangeError("Thickness must be a positive value");
    this._graduationThickness = value;
    this._graduationPen = null;
    this.redraw();
  }
  get graduationSize() {
    return this._graduationSize;
  }
  set graduationSize(value) {
    if (value <= 0)
      throw new RangeError("Graduation size must be a positive value");
    this._graduationSize = value;
    this.redraw();
  }
  get graduation() {
    return this._graduation;
  }
  set graduation(value) {
    this._graduation = value;
    this.redraw();
  }
  get unitFactor() {
    return this._unitFactor;
  }
  set unitFactor(value) {
    if (value == 0)
      throw new RangeError("Factor cannot be zero.");
    this._unitFactor = value;
    this.redraw();
  }
  get unit() {
    return this._unit;
  }
  set unit(value) {
    this._unit = value;
    this.redraw();
  }
  get unitFont() {
    return this._unitFont;
  }
  get subgraduationColor() {
    return this._subgraduationColor;
  }
  set subgraduationColor(value) {
    this._subgraduationColor = value;
    this._subgraduationPen = null;
    this.redraw();
  }
  get subgraduationThickness() {
    return this._subgraduationThickness;
  }
  set subgraduationThickness(value) {
    if (value < 0)
      throw new RangeError("Thickness must be a positive value");
    this._subgraduationThickness = value;
    this._subgraduationPen = null;
    this.redraw();
  }
  get subgraduationSize() {
    return this._subgraduationSize;
  }
  set subgraduationSize(value) {
    if (value <= 0)
      throw new RangeError("Size must be a positive value");
    this._subgraduationSize = value;
    this.redraw();
  }
  get graduationOuterRadiusSize() {
    return this._graduationOuterRadiusSize;
  }
  set graduationOuterRadiusSize(value) {
    this._graduationOuterRadiusSize = Math.max(0, Math.min(100, value));
    this.redraw();
  }
  get subgraduationCount() {
    return this._subgraduationCount;
  }
  set subgraduationCount(value) {
    if (value < 0)
      throw new RangeError("Count must be a positive value");
    this._subgraduationCount = value;
    this.redraw();
  }
  get statusColor() {
    return this._statusColor;
  }
  set statusColor(value) {
    this._statusColor = value;
    this.redraw();
  }
  get statusFont() {
    return this._unitFont;
  }
  get statusLine() {
    return this._statusLine;
  }
  set statusLine(value) {
    this._statusLine = value;
    this.redraw();
  }
  get showNeedle() {
    return this._showNeedle;
  }
  set showNeedle(value) {
    this._showNeedle = value;
    this.redraw();
  }
  get needleColor() {
    return this._needleColor;
  }
  set needleColor(value) {
    this._needleColor = value;
    this._needleBrush = null;
    this.redraw();
  }
  get needleMaxSpeed() {
    return this._needleMaxSpeed;
  }
  set needleMaxSpeed(value) {
    if (value <= 0)
      throw new RangeError("Speed must be a positive value");
    this._needleMaxSpeed = value;
    this.redraw();
  }
  get needleLength1() {
    return this._needleLength1;
  }
  set needleLength1(value) {
    this._needleLength1 = value;
    this.redraw();
  }
  get needleLength2() {
    return this._needleLength2;
  }
  set needleLength2(value) {
    this._needleLength2 = value;
    this.redraw();
  }
  get needleWidth() {
    return this._needleWidth;
  }
  set needleWidth(value) {
    if (value <= 0)
      throw new RangeError("Width must be a positive value");
    this._needleWidth = value;
    this.redraw();
  }
  get needleContourColor() {
    return this._needleContourColor;
  }
  set needleContourColor(value) {
    this._needleContourColor = value;
    this._needleContourPen = null;
    this.redraw();
  }
  get needleContourThickness() {
    return this._needleContourThickness;
  }
  set needleContourThickness(value) {
    if (value < 0)
      throw new RangeError("Thickness must be a positive value");
    this._needleContourThickness = value;
    this._needleContourPen = null;
    this.redraw();
  }
  get graduationFont() {
    return this._graduationFont;
  }
  get showMinMax() {
    return this._showMinMax;
  }
  set showMinMax(value) {
    this._showMinMax = value;
    this.redraw();
  }
  constructor(UIContainer, logFunction) {
    super(UIContainer, logFunction);
    this._min = 0;
    this._max = 100;
    this.SegmentMaxLength = 8;
    this._borderpen = null;
    this._borderColor = YColor.Black;
    this._bgBrush = null;
    this._backgroundColor1 = YColor.FromArgb(255, 240, 240, 240);
    this._backgroundColor2 = YColor.FromArgb(255, 200, 200, 200);
    this._borderThickness = 5;
    this._valueFormater = null;
    this._minmaxFormater = null;
    this._thickness = 20;
    this._value = 0;
    this._needleValue = 0;
    this._color1 = YColor.Green;
    this._color2 = YColor.Red;
    this._graduationPen = null;
    this._graduationColor = YColor.Black;
    this._graduationThickness = 2;
    this._graduationSize = 10;
    this._graduation = 10;
    this._unitFactor = 1;
    this._unit = "";
    this._subgraduationPen = null;
    this._subgraduationColor = YColor.Black;
    this._subgraduationThickness = 1;
    this._subgraduationSize = 5;
    this._graduationOuterRadiusSize = 98;
    this._subgraduationCount = 5;
    this._statusColor = YColor.Gray;
    this._statusLine = "";
    this._showNeedle = true;
    this._needleBrush = null;
    this._needleColor = YColor.Red;
    this._needleMaxSpeed = 5;
    this._needleLength1 = 90;
    this._needleLength2 = 5;
    this._needleWidth = 5;
    this._needleContourPen = null;
    this._needleContourColor = YColor.DarkRed;
    this._needleContourThickness = 1;
    this._showMinMax = true;
    this._path = null;
    this._graduationFont = new YFont(this, this, Math.min(this.getContainerInnerWidth(), this.getContainerInnerHeight()) / 15, null);
    this._unitFont = new YFont(this, this, Math.min(this.getContainerInnerWidth(), this.getContainerInnerHeight()) / 20, null);
    this._statusFont = new YFont(this, this, Math.min(this.getContainerInnerWidth(), this.getContainerInnerHeight()) / 15, null);
    this.unitFont.color = YColor.DarkGray;
    this._statusFont.color = YColor.DarkGray;
    this.resizeRule = Proportional.ResizeRule.RELATIVETOBOTH;
    this._zones = [];
  }
  clearCachedObjects() {
    if (this._zones != null) {
      for (let i = 0; i < this._zones.length; i++) {
        this._zones[i].resetPath();
      }
    }
    this._path = null;
    this._bgBrush = null;
  }
  get zones() {
    return this._zones;
  }
  AddZone() {
    let z = new YAngularZone(this, this);
    this._zones.push(z);
    return z;
  }
  Render(g, w, h) {
    let mainViewPort = new ViewPortSettings();
    mainViewPort.Lmargin = 0;
    mainViewPort.Rmargin = 0;
    mainViewPort.Tmargin = 0;
    mainViewPort.Bmargin = 0;
    g.SmoothingMode = YSmoothingMode.HighQuality;
    g.TextRenderingHint = YTextRenderingHint.AntiAlias;
    let stringFormat4Sizing = new YStringFormat(16384);
    let stringFormat = new YStringFormat(16384);
    stringFormat.Alignment = 1;
    stringFormat.LineAlignment = 1;
    this.drawAnnotationPanels(g, this._annotationPanels, w, h, false, mainViewPort);
    g.TextRenderingHint = YTextRenderingHint.AntiAlias;
    let xcenter = mainViewPort.Lmargin + (w - mainViewPort.Lmargin - mainViewPort.Rmargin) / 2;
    let ycenter = mainViewPort.Tmargin + (h - mainViewPort.Tmargin - mainViewPort.Bmargin) / 2;
    let radius = Math.min((w - mainViewPort.Lmargin - mainViewPort.Rmargin) / 2, (h - mainViewPort.Tmargin - mainViewPort.Bmargin) / 2) - this.borderThickness;
    let circonference = 2 * radius * 3.14 >> 0;
    let AngleAperture = 4 * 2 * Math.PI / 5;
    if (this._path == null) {
      let outterlength = 2 * radius * Math.PI;
      let stepCount = outterlength / this.SegmentMaxLength >> 0;
      let stepsize = 2 * Math.PI / stepCount;
      this._path = new Array(stepCount).fill(null);
      let n = 0;
      for (let i = 0; i < stepCount; i++) {
        let a = 2 * i * Math.PI / stepCount;
        this._path[n++] = new PointF(xcenter + radius * Math.cos(a), ycenter - radius * Math.sin(a));
      }
    }
    if (this._bgBrush == null)
      this._bgBrush = new YLinearGradientBrush(this._backgroundColor1, this._backgroundColor2);
    if (this._borderpen == null) {
      this._borderpen = new YPen(this._borderColor, this._borderThickness);
      this._borderpen.linejoin = YPen.LineJoin.Round;
    }
    if (this._path.length > 3)
      g.FillPolygon(this._bgBrush, this._path);
    if (this._graduationPen == null)
      this._graduationPen = new YPen(this._graduationColor, this._graduationThickness);
    if (this._subgraduationPen == null)
      this._subgraduationPen = new YPen(this._subgraduationColor, this._subgraduationThickness);
    let unitDesc = (this._unitFactor != 1 ? "x" + this._unitFactor.toString() + " " : "") + this._unit;
    let size = g.MeasureStringSF(unitDesc.toString(), this._unitFont, 1e4, stringFormat4Sizing);
    let unitPos = new YRectangle(xcenter - size.width / 2 >> 0, ycenter + radius / 2 - size.height / 2 >> 0, size.width + 1 >> 0, size.height + 1 >> 0);
    g.DrawStringRect(unitDesc, this._unitFont, this._unitFont.brush, unitPos, stringFormat);
    if (this._statusLine != "") {
      size = g.MeasureStringSF(this._statusLine, this._statusFont, 1e4, stringFormat4Sizing);
      let statusPos = new YRectangle(xcenter - size.width / 2 >> 0, ycenter - radius / 3 - size.height / 2 >> 0, size.width + 1, size.height + 1);
      g.DrawStringRect(this._statusLine, this._statusFont, this._statusFont.brush, statusPos, stringFormat);
    }
    let firstGraduation;
    let gratuationCount;
    let Angle, C, S, R1, R2;
    let outerCoef = this._graduationOuterRadiusSize / 100;
    for (let i = 0; i < this._zones.length; i++) {
      if (this._zones[i].visible) {
        if (this._zones[i].path == null) {
          let zmin = Math.max(this._min, Math.min(this._max, this._zones[i].min));
          let zmax = Math.max(this._min, Math.min(this._max, this._zones[i].max));
          if (zmax > zmin) {
            let zOuterCoef = this._zones[i].outerRadius / 100;
            let Angle1 = (Math.PI - AngleAperture) / 2 + AngleAperture * (zmin - this._min) / (this._max - this._min);
            let Angle2 = (Math.PI - AngleAperture) / 2 + AngleAperture * (zmax - this._min) / (this._max - this._min);
            let outterlength = (Angle2 - Angle1) * radius;
            let stepCount = outterlength / this.SegmentMaxLength >> 0;
            if (stepCount < 2)
              stepCount = 2;
            this._zones[i].setPathSize(2 * stepCount + 2);
            for (let j = 0; j <= stepCount; j++) {
              let A = Angle1 + (Angle2 - Angle1) * j / stepCount;
              this._zones[i].setPathPoint(j, new PointF(xcenter - radius * zOuterCoef * Math.cos(A), ycenter - radius * zOuterCoef * Math.sin(A)));
            }
            let innerRadiusCoef = zOuterCoef - this._zones[i].width / 100;
            for (let j = stepCount; j >= 0; j--) {
              let A = Angle1 + (Angle2 - Angle1) * j / stepCount;
              this._zones[i].setPathPoint(2 * stepCount + 1 - j, new PointF(xcenter - radius * innerRadiusCoef * Math.cos(A), ycenter - radius * innerRadiusCoef * Math.sin(A)));
            }
          }
        }
        if (this._zones[i].path != null)
          g.FillPolygon(this._zones[i].zoneBrush, this._zones[i].path);
      }
    }
    firstGraduation = this._graduation * (this._min / this._graduation) >> 0;
    if (this._min < 0)
      firstGraduation -= this._graduation;
    while (firstGraduation < this._min) {
      firstGraduation += this._graduation;
    }
    gratuationCount = 1 + (this._max - this._min) / this._graduation >> 0;
    if (this._subgraduationCount > 0 && this._subgraduationCount * gratuationCount < circonference) {
      let subgraduation = this._graduation / this._subgraduationCount;
      firstGraduation = subgraduation * (this._min / subgraduation >> 0);
      if (this._min < 0)
        firstGraduation -= subgraduation;
      while (firstGraduation < this._min) {
        firstGraduation += subgraduation;
      }
      gratuationCount = 1 + (this._max - this._min) / subgraduation >> 0;
      for (let i = 0; i < gratuationCount; i++) {
        let value = firstGraduation + i * subgraduation;
        if (value <= this._max) {
          Angle = (Math.PI - AngleAperture) / 2 + AngleAperture * (value - this._min) / (this._max - this._min);
          C = Math.cos(Angle);
          S = Math.sin(Angle);
          R1 = outerCoef * (radius - this._borderThickness / 2);
          R2 = (100 - this._subgraduationSize) * (outerCoef * (radius - this._borderThickness / 2)) / 100;
          g.DrawLineXY(this._subgraduationPen, xcenter - R1 * C, ycenter - R1 * S, xcenter - R2 * C, ycenter - R2 * S);
        }
      }
    }
    if (gratuationCount < circonference) {
      for (let i = 0; i < gratuationCount; i++) {
        let gvalue = firstGraduation + i * this._graduation;
        if (gvalue <= this._max) {
          Angle = (Math.PI - AngleAperture) / 2 + AngleAperture * (gvalue - this._min) / (this._max - this._min);
          C = Math.cos(Angle);
          S = Math.sin(Angle);
          R1 = outerCoef * (radius - this._borderThickness / 2);
          R2 = (100 - this._graduationSize) * (outerCoef * (radius - this._borderThickness / 2)) / 100;
          g.DrawLineXY(this._graduationPen, xcenter - R1 * C, ycenter - R1 * S, xcenter - R2 * C, ycenter - R2 * S);
          size = g.MeasureStringSF(gvalue.toString().trim(), this._graduationFont, 1e3, stringFormat4Sizing);
          let HalfDiagonal = 0.4 * Math.sqrt(size.width * size.width + size.height * size.height);
          let position = new YRectangle(xcenter - (R2 - HalfDiagonal) * C - size.width / 2 >> 0, ycenter - (R2 - HalfDiagonal) * S - size.height / 2 >> 0, (size.width >> 0) + 1, size.height >> 0);
          g.DrawStringRect(gvalue.toString(), this._graduationFont, this._graduationFont.brush, position, stringFormat);
        }
      }
    }
    if (this._borderThickness > 0 && this._path.length > 3)
      g.DrawPolygon(this._borderpen, this._path);
    this.drawAnnotationPanels(g, this._annotationPanels, w, h, true, mainViewPort);
    if (this._showNeedle) {
      if (this._needleValue != this._value) {
        let step = this._unitFactor * this._needleMaxSpeed * (this._max - this._min) / 100;
        if (Math.abs(this._value - this._needleValue) < step) {
          this._needleValue = this._value;
        } else if (this._needleValue < this.value) {
          this._needleValue += step;
        } else {
          this._needleValue -= step;
        }
      }
      let needlevalue = this._needleValue / this._unitFactor;
      let allowedOverflow = (this._max - this.min) * 0.05;
      if (needlevalue < this._min - allowedOverflow)
        needlevalue = this._min - allowedOverflow;
      if (needlevalue > this._max + allowedOverflow)
        needlevalue = this._max + allowedOverflow;
      Angle = (Math.PI - AngleAperture) / 2 + AngleAperture * (needlevalue - this._min) / (this._max - this._min);
      C = Math.cos(Angle);
      S = Math.sin(Angle);
      R1 = radius * this._needleLength1 / 100;
      R2 = radius * this._needleLength2 / 100;
      let R3 = radius * this._needleWidth / 200;
      let needlepath = new Array(4).fill(null);
      needlepath[0] = new PointF(xcenter - R1 * C, ycenter - R1 * S);
      needlepath[1] = new PointF(xcenter + R3 * S, ycenter - R3 * C);
      needlepath[2] = new PointF(xcenter + R2 * C, ycenter + R2 * S);
      needlepath[3] = new PointF(xcenter - R3 * S, ycenter + R3 * C);
      if (this._needleBrush == null)
        this._needleBrush = new YSolidBrush(this._needleColor);
      g.FillPolygon(this._needleBrush, needlepath);
      if (this._needleContourThickness > 0) {
        if (this._needleContourPen == null) {
          this._needleContourPen = new YPen(this._needleContourColor, this._needleContourThickness);
          this._needleContourPen.startCap = 2;
          this._needleContourPen.endCap = 2;
          this._needleContourPen.linejoin = YPen.LineJoin.Round;
        }
        let needlepath2 = new Array(5).fill(null);
        needlepath2[0] = needlepath[0];
        needlepath2[1] = needlepath[1];
        needlepath2[2] = needlepath[2];
        needlepath2[3] = needlepath[3];
        needlepath2[4] = needlepath[0];
        g.DrawLines(this._needleContourPen, needlepath2);
      }
    }
    this.DrawMessagePanels(g, w, h);
    return 0;
  }
  renderingPostProcessing() {
    if (this._needleValue != this._value)
      this.redraw();
  }
};

// obj/full/Renderer/YDigitalDisplay.js
var YDigitalDisplay = class extends YDataRenderer {
  get backgroundColor1() {
    return this._backgroundColor1;
  }
  set backgroundColor1(value) {
    this._backgroundColor1 = value;
    this._bgBrush = null;
    this.redraw();
  }
  get backgroundColor2() {
    return this._backgroundColor2;
  }
  set backgroundColor2(value) {
    this._backgroundColor2 = value;
    this._bgBrush = null;
    this.redraw();
  }
  get alternateValue() {
    return this._alternateValue;
  }
  set alternateValue(value) {
    this._alternateValue = value;
    this.redraw();
  }
  get valueFormater() {
    return this._valueFormater;
  }
  set valueFormater(value) {
    this._valueFormater = value;
    this.redraw();
  }
  get hrzAlignmentOfset() {
    return this._hrzAlignmentOfset;
  }
  set hrzAlignmentOfset(value) {
    this._hrzAlignmentOfset = value;
    this.redraw();
  }
  get hrzAlignment() {
    return this._hrzAlignment;
  }
  set hrzAlignment(value) {
    this._hrzAlignment = value;
    this.redraw();
  }
  get outOfRangeMin() {
    return this._outOfRangeMin;
  }
  set outOfRangeMin(value) {
    if (!Number.isNaN(value) && !Number.isNaN(this._outOfRangeMax) && !YDataRenderer.minMaxCheckDisabled) {
      if (value >= this._outOfRangeMax)
        throw new RangeError("Min cannot be greater than max (" + this._outOfRangeMax.toString() + ")");
    }
    this._outOfRangeMin = value;
    this.redraw();
  }
  get outOfRangeMax() {
    return this._outOfRangeMax;
  }
  set outOfRangeMax(value) {
    if (!Number.isNaN(value) && !Number.isNaN(this._outOfRangeMin) && !YDataRenderer.minMaxCheckDisabled) {
      if (value <= this._outOfRangeMin)
        throw new RangeError("Min cannot be less than max (" + this._outOfRangeMin.toString() + ")");
    }
    this._outOfRangeMax = value;
    this.redraw();
  }
  get outOfRangeColor() {
    return this._outOfRangeColor;
  }
  set outOfRangeColor(value) {
    this._outOfRangeColor = value;
    this.redraw();
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value;
    this.redraw();
  }
  get font() {
    return this._font;
  }
  constructor(UIContainer, logFunction) {
    super(UIContainer, logFunction);
    this._bgBrush = null;
    this._backgroundColor1 = YColor.Black;
    this._backgroundColor2 = YColor.FromArgb(255, 48, 48, 48);
    this._alternateValue = null;
    this._valueFormater = null;
    this._hrzAlignmentOfset = 5;
    this._hrzAlignment = YDigitalDisplay.HrzAlignment.DECIMAL;
    this._outOfRangeMin = Number.NaN;
    this._outOfRangeMax = Number.NaN;
    this._outOfRangeColor = YColor.Red;
    this._value = 0;
    this._font = new YFont(this, this, Math.min(UIContainer.width / 5, UIContainer.height / 2), null);
    this._font.color = YColor.LightGreen;
    this.resizeRule = Proportional.ResizeRule.RELATIVETOBOTH;
  }
  clearCachedObjects() {
    if (this.font != null)
      this.font.ResetFont(null);
    this._bgBrush = null;
  }
  Render(g, w, h) {
    let mainViewPort = new ViewPortSettings();
    mainViewPort.Lmargin = 0;
    mainViewPort.Rmargin = 0;
    mainViewPort.Tmargin = 0;
    mainViewPort.Bmargin = 0;
    g.SmoothingMode = YSmoothingMode.HighQuality;
    g.TextRenderingHint = YTextRenderingHint.AntiAlias;
    let stringFormat = new YStringFormat(16384);
    stringFormat.Alignment = 1;
    stringFormat.LineAlignment = 1;
    if (this._bgBrush == null) {
      this._bgBrush = new YLinearGradientBrush(this._backgroundColor1, this._backgroundColor2);
    }
    g.FillRectangleXYHW(this._bgBrush, 0, 0, w, h);
    this.drawAnnotationPanels(g, this._annotationPanels, w, h, false, mainViewPort);
    if (mainViewPort.Tmargin >= 20)
      mainViewPort.Tmargin -= 10;
    if (mainViewPort.Bmargin >= 20)
      mainViewPort.Bmargin -= 10;
    g.TextRenderingHint = YTextRenderingHint.AntiAlias;
    let availWidth = w - (mainViewPort.Lmargin + mainViewPort.Rmargin);
    let availHeight = h - (mainViewPort.Tmargin + mainViewPort.Bmargin);
    if (availWidth > 10 && availHeight > 10) {
      let svalue;
      if (this._alternateValue == null) {
        svalue = this._valueFormater == null ? this.value.toFixed(3) : this._valueFormater(this, this.value);
        if (!Number.isNaN(this._outOfRangeMin) && this.value < this._outOfRangeMin) {
          this.font.alternateColor = this._outOfRangeColor;
        } else if (!Number.isNaN(this._outOfRangeMax) && this.value > this._outOfRangeMax) {
          this.font.alternateColor = this._outOfRangeColor;
        } else {
          this.font.alternateColor = null;
        }
      } else {
        this._font.alternateColor = null;
        svalue = this._alternateValue;
      }
      let size = g.MeasureStringSF(svalue, this.font, 1e4, stringFormat);
      let pos;
      let align = this._hrzAlignment;
      if (this._alternateValue != null && align == YDigitalDisplay.HrzAlignment.DECIMAL)
        align = YDigitalDisplay.HrzAlignment.RIGHT;
      if (align == YDigitalDisplay.HrzAlignment.DECIMAL && svalue.indexOf(".") < 0)
        align = YDigitalDisplay.HrzAlignment.RIGHT;
      switch (align) {
        case YDigitalDisplay.HrzAlignment.LEFT:
          pos = new YRectangle(mainViewPort.Lmargin + (availWidth * this.hrzAlignmentOfset / 100 >> 0), mainViewPort.Tmargin + (availHeight - size.height) / 2 >> 0, size.width + 1 >> 0, size.height + 1 >> 0);
          g.DrawStringRect(svalue, this.font, this.font.brush, pos, stringFormat);
          break;
        case YDigitalDisplay.HrzAlignment.CENTER:
          pos = new YRectangle(mainViewPort.Lmargin + (availWidth - size.width) / 2 >> 0, mainViewPort.Tmargin + (availHeight - size.height) / 2 >> 0, size.width + 1 >> 0, size.height + 1 >> 0);
          g.DrawStringRect(svalue, this.font, this.font.brush, pos, stringFormat);
          break;
        case YDigitalDisplay.HrzAlignment.DECIMAL:
          let left = "";
          let p = svalue.lastIndexOf(",");
          if (p < 0)
            p = svalue.lastIndexOf(".");
          if (p >= 0) {
            left = svalue.substring(0, p + 1);
          } else {
            p = 0;
            while (p < svalue.length && (svalue[p] >= "0" && svalue[p] <= "9" || svalue[p] == "-" || svalue[p] == "'" || svalue[p] == " ")) {
              p++;
            }
            left = svalue.substring(0, p);
          }
          let lsize = g.MeasureStringSF(left, this.font, 1e4, stringFormat);
          pos = new YRectangle(mainViewPort.Lmargin + (availWidth - lsize.width - availWidth * this.hrzAlignmentOfset / 100) >> 0, mainViewPort.Tmargin + (availHeight - size.height) / 2 >> 0, size.width + 1 >> 0, size.height + 1 >> 0);
          g.DrawStringRect(svalue, this.font, this.font.brush, pos, stringFormat);
          break;
        case YDigitalDisplay.HrzAlignment.RIGHT:
          pos = new YRectangle(mainViewPort.Lmargin + (availWidth - size.width - availWidth * this.hrzAlignmentOfset / 100) >> 0, mainViewPort.Tmargin + (availHeight - size.height) / 2 >> 0, size.width + 1 >> 0, size.height + 1 >> 0);
          g.DrawStringRect(svalue, this.font, this.font.brush, pos, stringFormat);
          break;
      }
    }
    this.drawAnnotationPanels(g, this._annotationPanels, w, h, true, mainViewPort);
    this.DrawMessagePanels(g, w, h);
    return 0;
  }
};
(function(YDigitalDisplay2) {
  class HrzAlignmentEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, HrzAlignment);
    }
  }
  YDigitalDisplay2.HrzAlignmentEnumItem = HrzAlignmentEnumItem;
  class HrzAlignment extends YEnum {
  }
  HrzAlignment.LEFT = new HrzAlignmentEnumItem("LEFT", "Left");
  HrzAlignment.CENTER = new HrzAlignmentEnumItem("CENTER", "Center");
  HrzAlignment.DECIMAL = new HrzAlignmentEnumItem("DECIMAL", "Decimal");
  HrzAlignment.RIGHT = new HrzAlignmentEnumItem("RIGHT", "Right");
  YDigitalDisplay2.HrzAlignment = HrzAlignment;
})(YDigitalDisplay || (YDigitalDisplay = {}));

// obj/full/Renderer/YGraph.js
var SUMMARY_GRANULARITY = 100;
var pointXY = class {
  constructor(X, Y) {
    this.x = X === void 0 ? 0 : X;
    this.y = Y === void 0 ? 0 : Y;
  }
  clone() {
    return new pointXY(this.x, this.y);
  }
};
var pointsSummary = class {
  constructor(X1, X2, YMIN, YMAX) {
    this.x1 = X1;
    this.x2 = X2;
    this.ymin = YMIN;
    this.ymax = YMAX;
  }
  clone() {
    return new pointsSummary(this.x1, this.x2, this.ymin, this.ymin);
  }
};
var TimeConverterParseResult = class {
  constructor() {
    this.success = false;
    this.result = 0;
  }
};
var TimeResolution = class {
  constructor() {
    this.step = 0;
    this.format = 0;
  }
};
var YDate = class extends Date {
  ToString(format) {
    let res = "";
    let ampm = "";
    if (format & YDate.D)
      res = res + this.getDate() + " ";
    if (format & YDate.M)
      res = res + YDate.months[this.getMonth()] + " ";
    if (format & YDate.YY) {
      let y = this.getFullYear().toString();
      res = res + y.substr(y.length - 2) + " ";
    } else if (format & YDate.YYYY) {
      let y = this.getFullYear().toString();
      res = res + y + " ";
    }
    if (format & YDate.CR)
      res = res + "\n";
    if (format & YDate.h) {
      if (YDate.use24Hformat) {
        let h = "0" + this.getHours().toString();
        res = res + h.substring(h.length - 2);
        if (!(format & YDate.m))
          res = res + "H";
      } else {
        let hour = this.getHours();
        ampm = "AM";
        if (hour > 11)
          ampm = "PM";
        if (hour > 12)
          hour = hour - 12;
        if (hour == 0)
          hour = 12;
        res = res + hour.toString();
      }
    }
    if (format & YDate.m) {
      let m = "0" + this.getMinutes().toString();
      res = res + ":" + m.substring(m.length - 2);
    }
    if (format & YDate.s) {
      let s = "0" + this.getSeconds().toString();
      res = res + ":" + s.substring(s.length - 2);
    }
    if (format & YDate.ms1) {
      let ms = "00" + this.getMilliseconds().toString();
      res = res + "." + ms.substring(ms.length - 3).substring(1);
    } else if (format & YDate.ms01) {
      let ms = "00" + this.getMilliseconds().toString();
      res = res + "." + ms.substring(ms.length - 3).substring(2);
    } else if (format & YDate.ms001) {
      let ms = "00" + this.getMilliseconds().toString();
      res = res + "." + ms.substring(ms.length - 3).substring(3);
    }
    if (format & YDate.h && !YDate.use24Hformat) {
      res = res + ampm;
    }
    return res;
  }
};
YDate.D = 1;
YDate.DD = 2;
YDate.M = 4;
YDate.YY = 8;
YDate.h = 16;
YDate.m = 32;
YDate.s = 64;
YDate.ms1 = 128;
YDate.ms01 = 256;
YDate.ms001 = 512;
YDate.CR = 1024;
YDate.isRelative = 2048;
YDate.YYYY = 4096;
YDate.d = new Date().toLocaleTimeString().toUpperCase();
YDate.use24Hformat = YDate.d.indexOf("AM") < 0 && YDate.d.indexOf("PM") < 0;
YDate.months = ["jan", "feb", "mar", "apr", "may", "jun", "jul", "aug", "sep", "oct", "nov", "dec"];
var TimeConverter = class {
  static UTCNow() {
    return new YDate();
  }
  static ToUnixTime(datetime) {
    return datetime.getTime() / 1e3;
  }
  static FromUnixTime(unixtime) {
    let t = new YDate();
    t.setTime(unixtime * 1e3);
    return t;
  }
  static tryParseStringToAbsDateTime(str) {
    let res = new TimeConverterParseResult();
    res.success = false;
    let date = new Date();
    let year = date.getFullYear();
    let month = date.getMonth();
    let day = date.getDate();
    let hours = 0;
    let minutes = 0;
    let seconds = 0;
    str = str.trim();
    while (str.indexOf("  ") > 0) {
      str = str.replace("  ", " ");
    }
    let dateFound = false;
    let timeFound = false;
    let it = str.split(" ");
    if (it.length <= 0)
      return res;
    for (let i = 0; i < it.length && i < 2; i++) {
      if (it[i].indexOf("-") > 0) {
        let tokens = it[i].split("-");
        if (tokens.length == 1) {
          day = parseInt(tokens[0]);
        } else if (tokens.length == 2) {
          day = parseInt(tokens[1]);
          month = parseInt(tokens[0]) - 1;
        } else {
          day = parseInt(tokens[2]);
          month = parseInt(tokens[1]) - 1;
          year = parseInt(tokens[0]);
        }
        dateFound = true;
      } else if (it[i].indexOf(":") > 0) {
        let tokens = it[i].split(":");
        if (tokens.length == 1) {
          hours = parseInt(tokens[0]);
        } else if (tokens.length == 2) {
          hours = parseInt(tokens[0]);
          minutes = parseInt(tokens[1]);
        } else {
          hours = parseInt(tokens[0]);
          minutes = parseInt(tokens[1]);
          seconds = parseFloat(tokens[2]);
        }
        timeFound = true;
      }
    }
    if (!timeFound && !dateFound)
      return res;
    if (isNaN(year) || isNaN(month) || isNaN(day) || isNaN(hours) || isNaN(minutes) || isNaN(seconds))
      return res;
    date.setFullYear(year, month, day);
    date.setHours(hours, minutes, seconds >> 0, 1e3 * (seconds % 1) >> 0);
    res.result = date.getTime() / 1e3;
    res.success = true;
    return res;
  }
  static tryParseStringToSecTimeSpan(st) {
    let res = new TimeConverterParseResult();
    let d = 0;
    st = st.toUpperCase();
    let n = st.indexOf("D");
    if (n > 0) {
      d = parseFloat(st.substring(0, n));
      if (isNaN(d)) {
        return res;
      }
      res.result += +d * 86400;
      if (n == st.length - 1) {
        res.success = true;
        return res;
      }
      st = st.substring(n + 1);
    }
    n = st.indexOf("H");
    if (n > 0) {
      d = parseFloat(st.substring(0, n));
      if (isNaN(d)) {
        return res;
      }
      res.result += d * 3600;
      if (n == st.length - 1) {
        res.success = true;
        return res;
      }
      st = st.substring(n + 1);
    }
    n = st.indexOf("M");
    if (n > 0) {
      d = parseFloat(st.substring(0, n));
      if (isNaN(d)) {
        return res;
      }
      res.result += d * 60;
      if (n == st.length - 1) {
        res.success = true;
        return res;
      }
      st = st.substring(n + 1);
    }
    n = st.indexOf("S");
    if (n < 0)
      n = st.length;
    d = parseFloat(st.substring(0, n));
    if (isNaN(d)) {
      return res;
    }
    res.result += d;
    res.success = true;
    return res;
  }
  static secTimeSpanToString(timespan, resolution) {
    let started = false;
    let res = "";
    if (timespan < 0) {
      res = "-";
      timespan = -timespan;
    }
    if (timespan >= 86400) {
      let d = timespan / 86400 >> 0;
      res = res + d.toString() + "d";
      timespan -= 86400 * d;
      started = true;
    }
    if (resolution >= 86400)
      return res != "" ? res : "0d";
    if (timespan >= 3600) {
      let d = timespan / 3600 >> 0;
      let ds = d.toString();
      if (started && ds.length == 1)
        ds = "0" + ds;
      res = res + ds + "h";
      timespan -= 3600 * d;
      started = true;
    }
    if (resolution >= 3600)
      return res != "" ? res : "0h";
    if (timespan < resolution)
      return res != "" ? res : "0h";
    if (timespan >= 60) {
      let d = timespan / 60 >> 0;
      let ds = d.toString();
      if (started && ds.length == 1)
        ds = "0" + ds;
      res = res + ds + "m";
      timespan -= 60 * d;
      started = true;
    }
    if (resolution >= 60)
      return res != "" ? res : "0m";
    if (timespan < resolution)
      return res != "" ? res : "0m";
    timespan = Math.round(timespan * 100) / 100;
    let s;
    if (resolution > 0.1) {
      s = timespan.toFixed(0);
    } else if (resolution > 0.01) {
      s = timespan.toFixed(1);
    } else if (resolution > 1e-3) {
      s = timespan.toFixed(2);
    } else {
      s = timespan.toString();
    }
    if (started && timespan < 10)
      s = "0" + s;
    res = res + s + "s";
    return res;
  }
  static RelativeFormat(dataDeltaTime, viewportDeltaTime, resolution) {
    let ShowSecondsTenth = true;
    let ShowSecondsHundredth = true;
    let ShowSeconds = true;
    let ShowMinutes = false;
    let ShowHours = false;
    let ShowDays = false;
    if (dataDeltaTime <= 0.1) {
      ShowSecondsHundredth = true;
    }
    if (dataDeltaTime <= 1) {
      ShowSecondsTenth = true;
    }
    if (dataDeltaTime >= 60 || viewportDeltaTime >= 60) {
      ShowMinutes = true;
    }
    if (dataDeltaTime >= 3600 || viewportDeltaTime >= 3600) {
      ShowHours = true;
    }
    if (dataDeltaTime >= 86400 || viewportDeltaTime >= 86400) {
      ShowDays = true;
    }
    if (resolution >= 0.1)
      ShowSecondsHundredth = false;
    if (resolution >= 1)
      ShowSecondsTenth = false;
    if (resolution >= 60)
      ShowSeconds = false;
    if (resolution >= 3600)
      ShowMinutes = false;
    if (resolution >= 86400)
      ShowHours = false;
    let format = 0;
    format |= YDate.isRelative;
    if (ShowSecondsTenth)
      format |= YDate.ms1;
    if (ShowSecondsHundredth)
      format |= YDate.ms01;
    if (ShowSeconds)
      format |= YDate.s;
    if (ShowMinutes)
      format |= YDate.m;
    if (ShowHours)
      format |= YDate.h;
    if (ShowDays)
      format |= YDate.D;
    return format;
  }
  static BestTimeformat(dataDeltaTime, viewportDeltaTime, tref) {
    let res = new TimeResolution();
    let ShowSecondsTenth = true;
    let ShowSecondsHundredth = true;
    let ShowSeconds = true;
    let ShowMinutes = false;
    let ShowHours = false;
    let ShowDays = false;
    let ShowMonths = false;
    let ShowYears = false;
    if (viewportDeltaTime <= 0.1) {
      res.step = 0.01;
    } else if (viewportDeltaTime <= 1) {
      res.step = 0.1;
    } else if (viewportDeltaTime <= 2) {
      res.step = 0.2;
    } else if (viewportDeltaTime <= 5) {
      res.step = 0.5;
    } else if (viewportDeltaTime <= 10) {
      res.step = 1;
    } else if (viewportDeltaTime <= 20) {
      res.step = 2;
    } else if (viewportDeltaTime <= 30) {
      res.step = 3;
    } else if (viewportDeltaTime <= 40) {
      res.step = 4;
    } else if (viewportDeltaTime <= 60) {
      res.step = 5;
    } else if (viewportDeltaTime <= 120) {
      res.step = 10;
    } else if (viewportDeltaTime <= 300) {
      res.step = 30;
    } else if (viewportDeltaTime <= 900) {
      res.step = 60;
    } else if (viewportDeltaTime <= 1800) {
      res.step = 180;
    } else if (viewportDeltaTime <= 3600) {
      res.step = 300;
    } else if (viewportDeltaTime <= 7200) {
      res.step = 600;
    } else if (viewportDeltaTime <= 14e3) {
      res.step = 900;
    } else if (viewportDeltaTime <= 21600) {
      res.step = 1800;
    } else if (viewportDeltaTime <= 43200) {
      res.step = 3600;
    } else if (viewportDeltaTime <= 86400) {
      res.step = 7200;
    } else if (viewportDeltaTime <= 2 * 86400) {
      res.step = 2 * 7200;
    } else if (viewportDeltaTime <= 4 * 86400) {
      res.step = 4 * 7200;
    } else if (viewportDeltaTime <= 7 * 86400) {
      res.step = 86400;
    } else if (viewportDeltaTime <= 14 * 86400) {
      res.step = 2 * 86400;
    } else if (viewportDeltaTime <= 28 * 86400) {
      res.step = 4 * 86400;
    } else if (viewportDeltaTime <= 56 * 86400) {
      res.step = 7 * 86400;
    } else if (viewportDeltaTime <= 112 * 86400) {
      res.step = 14 * 86400;
    } else if (viewportDeltaTime <= 224 * 86400) {
      res.step = 31 * 86400;
    } else if (viewportDeltaTime <= 448 * 86400) {
      res.step = 62 * 86400;
    } else if (viewportDeltaTime <= 896 * 86400) {
      res.step = 93 * 86400;
    } else {
      res.step = 365 * 86400;
    }
    if (tref == TimeConverter.TimeReference.ABSOLUTE) {
      ShowSecondsHundredth = true;
      ShowSecondsTenth = true;
      ShowMinutes = true;
      ShowHours = true;
      ShowDays = dataDeltaTime > 86400;
      ShowMonths = dataDeltaTime > 86400;
      ShowYears = dataDeltaTime > 28 * 6 * 86400;
      if (res.step >= 0.1)
        ShowSecondsHundredth = false;
      if (res.step >= 1)
        ShowSecondsTenth = false;
      if (res.step >= 60)
        ShowSeconds = false;
      if (res.step >= 3600)
        ShowMinutes = false;
      if (res.step >= 86400)
        ShowHours = false;
      if (res.step >= 31 * 86400)
        ShowDays = false;
      if (res.step >= 365 * 86400)
        ShowMonths = false;
      res.format = 0;
      if (ShowSecondsHundredth)
        res.format |= YDate.ms01;
      if (ShowSecondsTenth)
        res.format |= YDate.ms1;
      if (ShowSeconds)
        res.format |= YDate.s;
      if (ShowMinutes)
        res.format = res.format |= YDate.m;
      if (ShowHours)
        res.format = res.format |= YDate.h;
      if (res.format != 0 && (ShowDays || ShowMonths))
        res.format |= YDate.CR;
      if (ShowDays)
        res.format |= YDate.D;
      if (ShowMonths)
        res.format |= YDate.M;
      if (ShowYears)
        res.format |= YDate.YY;
      if (res.format == YDate.YY)
        res.format = YDate.YYYY;
    } else {
      res.format = TimeConverter.RelativeFormat(dataDeltaTime, viewportDeltaTime, res.step);
    }
    return res;
  }
};
(function(TimeConverter2) {
  class TimeReferenceEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, TimeReference);
    }
  }
  TimeConverter2.TimeReferenceEnumItem = TimeReferenceEnumItem;
  class TimeReference extends YEnum {
  }
  TimeReference.ABSOLUTE = new TimeReferenceEnumItem("ABSOLUTE", "Absolute");
  TimeReference.RELATIVE = new TimeReferenceEnumItem("RELATIVE", "Relative to first data");
  TimeConverter2.TimeReference = TimeReference;
})(TimeConverter || (TimeConverter = {}));
var MinMax = class {
  constructor(minimum, maximum) {
    this.Min = 0;
    this.Max = 0;
    this.Min = minimum;
    this.Max = maximum;
  }
};
var MinMaxHandler = class {
  static extend(M, factor) {
    if (isNaN(M.Min))
      return M;
    let delta = M.Max - M.Min;
    return new MinMax(M.Min - delta * (factor - 1) / 2, M.Max + delta * (factor - 1) / 2);
  }
  static DefaultValue(value1, value2) {
    if (typeof value2 === "undefined") {
      if (typeof value1 === "undefined")
        return new MinMax(Number.NaN, Number.NaN);
      return new MinMax(value1, value1);
    }
    if (typeof value1 === "undefined")
      return new MinMax(value2, value2);
    if (value2 < value1)
      throw new RangeError("MinMax invalid parameters (" + value1.toString() + ">" + value2.toString());
    return new MinMax(value1, value2);
  }
  static isDefined(v) {
    return !isNaN(v.Min);
  }
  static Combine(M1, M2) {
    if (isNaN(M1.Min))
      return new MinMax(M2.Min, M2.Max);
    if (isNaN(M2.Min))
      return new MinMax(M1.Min, M1.Max);
    let res = new MinMax(M2.Min, M2.Max);
    if (M1.Min < res.Min)
      res.Min = M1.Min;
    if (M1.Max < res.Min)
      res.Min = M1.Max;
    if (M1.Min > res.Max)
      res.Max = M1.Min;
    if (M1.Max > res.Max)
      res.Max = M1.Max;
    return res;
  }
  static CombineWithNumber(M1, value) {
    if (isNaN(M1.Min))
      return new MinMax(value, value);
    if (value < M1.Min)
      return new MinMax(value, M1.Max);
    if (value > M1.Max)
      return new MinMax(M1.Min, value);
    return new MinMax(M1.Min, M1.Max);
  }
};
var DataSegment = class {
  static ArrayCopy(sourceArray, sourceIndex, destinationArray, destinationIndex, length) {
    for (let i = 0; i < length; i++) {
      destinationArray[destinationIndex + i] = sourceArray[sourceIndex + i].clone();
    }
  }
  constructor(p) {
    this.data = [];
    this.count = 0;
    if (p instanceof Array) {
      this.data = new Array(p.length);
      DataSegment.ArrayCopy(p, 0, this.data, 0, p.length);
      this.count = p.length;
    } else if (p instanceof pointXY) {
      this.data = new Array(DataSegment.SegmentGranularity);
      this.data[0] = p;
      this.count = 1;
    } else {
      throw new Error("invalid constructor paramter type");
    }
  }
  grow() {
    let targetCount = this.data.length + DataSegment.SegmentGranularity;
    while (this.data.length < targetCount) {
      this.data.push(null);
    }
  }
};
DataSegment.SegmentGranularity = 1e3;
var Summary = class {
  getBufferpoint() {
    if (this.vtlPtCount <= 0)
      return null;
    return new pointsSummary(this.Xmin, this.Xmax, this.Ymin, this.Ymax);
  }
  Dump() {
    var _a, _b, _c, _d;
    console.log("Summary level" + this.selfIndex + ", " + this.segments.length + " segments, " + this.totalpoints + " points");
    let lastx = 0;
    for (let s = 0; s < this.segments.length; s++) {
      console.log("  segment " + s);
      for (let i = 0; i < this.segments[s].ptCount; i++) {
        console.log(((_a = this.segments[s].data[i]) === null || _a === void 0 ? void 0 : _a.x1) + "," + ((_b = this.segments[s].data[i]) === null || _b === void 0 ? void 0 : _b.ymin) + " delataX=" + Math.round(this.segments[s].data[i].x1 - lastx));
        console.log(((_c = this.segments[s].data[i]) === null || _c === void 0 ? void 0 : _c.x2) + "," + ((_d = this.segments[s].data[i]) === null || _d === void 0 ? void 0 : _d.ymax) + " delataX=" + Math.round(this.segments[s].data[i].x2 - this.segments[s].data[i].x1));
        lastx = this.segments[s].data[i].x2;
      }
    }
  }
  constructor(index, array, pointSize) {
    this.segments = [];
    this.totalpoints = 0;
    this.Xmin = 0;
    this.Xmax = 0;
    this.Ymin = 0;
    this.Ymax = 0;
    this.vtlPtCount = 0;
    this.pointSize = 0;
    this.isLast = false;
    this.newSummaryLevelTrigger = 0;
    this.selfIndex = index;
    this.selfArray = array;
    this.pointSize = pointSize;
    this.isLast = true;
  }
  processSegments(segments) {
    if (segments.length <= 0)
      return;
    let last = segments.length - 1;
    this.Xmin = segments[last].data[0].x;
    this.Xmax = segments[last].data[0].x;
    this.Ymin = segments[last].data[0].y;
    this.Ymax = segments[last].data[0].y;
    this.totalpoints = 0;
    this.vtlPtCount = 0;
    for (let s = last; s >= 0; s--) {
      for (let i = 0; i < segments[s].data.length; i++) {
        let p = segments[s].data[i];
        if (p.x < this.Ymin)
          this.Ymin = p.y;
        if (p.x > this.Ymax)
          this.Ymax = p.y;
        this.Xmax = p.x;
        this.vtlPtCount++;
        if (this.vtlPtCount >= this.pointSize) {
          this.flush(false);
          this.Xmin = p.x;
          this.Ymin = p.y;
          this.Ymax = p.y;
        }
      }
      if (s > 0) {
        let len = segments[s].data.length;
        let p2 = segments[s - 1].data[0];
        let p1 = segments[s].data[len - 1];
        let lastDelta = 1;
        if (len > 1) {
          let p0 = segments[s].data[len - 2];
          lastDelta = p1.x - p0.x;
        }
        if (p2.x - p1.x > this.pointSize * lastDelta) {
          this.flush(false);
          this.Xmin = p2.x;
          this.Ymin = p2.y;
          this.Ymax = p2.y;
          this.addNewEmptySegment();
        }
      }
    }
    if (this.totalpoints > 1) {
      let it = new Summary(this.selfIndex + 1, this.selfArray, this.pointSize * SUMMARY_GRANULARITY);
      this.selfArray.push(it);
      this.isLast = false;
      it.processSegments(segments);
    }
  }
  addNewLevel() {
    let newIndex = this.selfArray.length;
    if (Summary.DBG)
      console.log("--- ADDING NEW LEVEL " + newIndex);
    let it = new Summary(newIndex, this.selfArray, this.pointSize * SUMMARY_GRANULARITY);
    this.selfArray.push(it);
    this.isLast = false;
    let _xmin = this.segments[0].data[0].x1;
    let _xmax = this.segments[0].data[0].x2;
    let _ymin = this.segments[0].data[0].ymin;
    let _ymax = this.segments[0].data[0].ymax;
    let _count = 0;
    for (let s = 0; s < this.segments.length; s++) {
      for (let i = 0; i < this.segments[s].ptCount; i++) {
        _xmax = this.segments[s].data[i].x2;
        if (this.segments[s].data[i].ymin < _ymin)
          _ymin = this.segments[s].data[i].ymin;
        if (this.segments[s].data[i].ymin > _ymax)
          _ymax = this.segments[s].data[i].ymin;
      }
      _count += this.segments[s].ptCount;
      if (s < this.segments.length - 1) {
        if (this.segments[s].ptCount > 2) {
          let lastIndex = this.segments[s].ptCount - 1;
          let lastDelta = this.segments[s].data[lastIndex].x1 - this.segments[s].data[lastIndex - 1].x2;
          if (this.segments[s + 1].data[0].x1 - this.segments[s].data[this.segments[s].ptCount - 1].x2 > lastDelta * SUMMARY_GRANULARITY) {
            it.addNewEmptySegment();
            _xmin = this.segments[s + 1].data[0].x1;
            _xmax = this.segments[s + 1].data[0].x2;
            _ymin = this.segments[s + 1].data[0].ymin;
            _ymax = this.segments[s + 1].data[0].ymax;
            _count = 0;
          }
        }
      }
    }
    if (_count != 0) {
      it.addNewSinglePointSegment(_xmin, _xmax, _ymin, _ymax, _count);
    }
  }
  addNewSinglePointSegment(xmin, xmax, ymin, ymax, _count) {
    if (Summary.DBG)
      console.log(" ===> level " + this.selfIndex + " new single point segment");
    this.segments.push(new DataSummarySegment(new pointsSummary(xmin, xmax, ymin, ymax), _count));
  }
  addNewEmptySegment() {
    if (Summary.DBG)
      console.log(" ===> level " + this.selfIndex + " new empty segment");
    this.segments.push(new DataSummarySegment(null, null));
  }
  addSequentialPoint(p, maxHoleSize) {
    if (Summary.DBG)
      console.log(" ADD Point, LEVEL " + this.selfIndex + " Vtl point = " + this.vtlPtCount + "/" + this.pointSize + " TOTAL Points= " + this.totalpoints);
    if (this.isLast && this.totalpoints >= SUMMARY_GRANULARITY)
      this.addNewLevel();
    if (this.vtlPtCount == 0) {
      this.Xmin = p.x;
      this.Xmax = p.x;
      this.Ymin = p.y;
      this.Ymax = p.y;
      this.vtlPtCount = 1;
      if (Summary.DBG) {
        if (this.selfIndex == 1)
          console.log(" --> added 1srt virtual pt vtlPtCount=" + this.vtlPtCount + "/" + this.pointSize);
      }
      if (!this.isLast)
        this.selfArray[this.selfIndex + 1].addSequentialPoint(p, maxHoleSize * SUMMARY_GRANULARITY);
      return;
    } else {
      if (Summary.DBG)
        console.log(" --> level " + this.selfIndex + " delta = " + (p.x - this.Xmax) + "/" + maxHoleSize);
      if (maxHoleSize > 0 && p.x - this.Xmax > maxHoleSize) {
        if (Summary.DBG)
          console.log(" --> level " + this.selfIndex + " hole detected");
        this.flush(false);
        this.addNewEmptySegment();
        this.Xmin = p.x;
        this.Xmax = p.x;
        this.Ymin = p.y;
        this.Ymax = p.y;
        this.vtlPtCount = 1;
        if (!this.isLast)
          this.selfArray[this.selfIndex + 1].addSequentialPoint(p, maxHoleSize * SUMMARY_GRANULARITY);
        return;
      }
      if (p.y < this.Ymin)
        this.Ymin = p.y;
      if (p.y > this.Ymax)
        this.Ymax = p.y;
      this.Xmax = p.x;
      this.vtlPtCount++;
      if (Summary.DBG) {
        if (this.selfIndex == 1)
          console.log(" --> level " + this.selfIndex + " added subsequent virtual pt vtlPtCount=" + this.vtlPtCount + "/" + this.pointSize);
      }
      if (this.vtlPtCount >= this.pointSize) {
        if (Summary.DBG) {
          if (this.selfIndex == 1)
            console.log(" --> level " + this.selfIndex + " flushing");
        }
        this.flush(false);
      }
    }
    if (!this.isLast)
      this.selfArray[this.selfIndex + 1].addSequentialPoint(p, maxHoleSize * SUMMARY_GRANULARITY);
  }
  flush(forceNewSegment) {
    if (this.segments.length == 0 || forceNewSegment)
      this.segments.push(new DataSummarySegment(null, null));
    let lastsegment = this.segments[this.segments.length - 1];
    lastsegment.data[lastsegment.ptCount] = new pointsSummary(this.Xmin, this.Xmax, this.Ymin, this.Ymax);
    this.totalpoints++;
    lastsegment.ptCount++;
    this.vtlPtCount = 0;
  }
};
Summary.DBG = false;
var DataSummarySegment = class {
  static ArrayCopy(sourceArray, sourceIndex, destinationArray, destinationIndex, length) {
    for (let i = 0; i < length; i++) {
      destinationArray[destinationIndex + i] = sourceArray[sourceIndex + i].clone();
    }
  }
  constructor(p, virtualPointCount) {
    this.data = [];
    this.ptCount = 0;
    if (p instanceof Array) {
      this.data = new Array(p.length);
      DataSummarySegment.ArrayCopy(p, 0, this.data, 0, p.length);
      this.ptCount = p.length;
    } else if (p instanceof pointsSummary) {
      this.data = new Array(DataSummarySegment.SegmentGranularity);
      this.data[0] = p;
      this.ptCount = 1;
    } else if (p == null) {
      this.data = new Array(DataSummarySegment.SegmentGranularity);
      this.ptCount = 0;
    }
  }
  grow() {
    let targetCount = this.data.length + DataSummarySegment.SegmentGranularity;
    while (this.data.length < targetCount) {
      this.data.push(null);
    }
  }
};
DataSummarySegment.SegmentGranularity = 1e3;
var DataSerie = class {
  get userData() {
    return this._userData;
  }
  set userData(value) {
    this._userData = value;
  }
  static get MaxPointsPerSeries() {
    return DataSerie._MaxPointsPerSeries;
  }
  static set MaxPointsPerSeries(value) {
    DataSerie._MaxPointsPerSeries = value;
  }
  get timeRange() {
    return this._timeRange;
  }
  get valueRange() {
    return this._valueRange;
  }
  constructor(parent) {
    this.totalPointCount = 0;
    this._userData = null;
    this._yAxisIndex = 0;
    this._pen = null;
    this._legendPen = null;
    this._brush = null;
    this._navigatorpen = null;
    this._visible = true;
    this._disabled = false;
    this._color = YColor.Black;
    this._thickness = 1;
    this._legend = "";
    this._unit = "";
    this.segments = [];
    this.summaries = null;
    if (parent.yAxes.length <= 0)
      throw new Error("Define at least one yAxis");
    this._timeRange = MinMaxHandler.DefaultValue();
    this._valueRange = MinMaxHandler.DefaultValue();
    this.parent = parent;
  }
  get yAxisIndex() {
    return this._yAxisIndex;
  }
  set yAxisIndex(value) {
    if (value >= this.parent.yAxes.length)
      throw new RangeError("No such yAxis (" + value.toString() + ")");
    this._yAxisIndex = value;
    this.parent.yAxes[this._yAxisIndex].AutoShow();
  }
  get pen() {
    if (this._pen == null) {
      this._pen = new YPen(this._color, this._thickness);
      this._pen.endCap = 2;
      this._pen.linejoin = YPen.LineJoin.Round;
    }
    return this._pen;
  }
  get legendPen() {
    if (this._legendPen == null) {
      this._legendPen = new YPen(this._color, this._thickness * this.parent.legendPanel.traceWidthFactor);
    }
    return this._legendPen;
  }
  resetlegendPen() {
    this._legendPen = null;
  }
  get brush() {
    if (this._brush == null)
      this._brush = new YSolidBrush(this._color);
    return this._brush;
  }
  get navigatorpen() {
    if (this._navigatorpen == null) {
      this._navigatorpen = new YPen(YColor.FromArgb(100, this._color.red, this._color.green, this._color.blue), 1);
    }
    return this._navigatorpen;
  }
  get visible() {
    return this._visible;
  }
  set visible(value) {
    this._visible = value;
    this.parent.redraw();
  }
  get disabled() {
    return this._disabled;
  }
  set disabled(value) {
    this._disabled = value;
    this.parent.redraw();
  }
  get color() {
    return this._color;
  }
  set color(value) {
    this._color = value;
    this._pen = null;
    this._legendPen = null;
    this._brush = null;
    this._navigatorpen = null;
    this.parent.redraw();
  }
  get thickness() {
    return this._thickness;
  }
  set thickness(value) {
    if (value < 0)
      throw new RangeError("Thickness must be a positive value");
    this._thickness = value;
    this._pen = null;
    this._legendPen = null;
    this.parent.redraw();
  }
  get legend() {
    return this._legend;
  }
  set legend(value) {
    this._legend = value;
    this.parent.redraw();
  }
  get unit() {
    return this._unit;
  }
  set unit(value) {
    this._unit = value;
    this.parent.redraw();
  }
  AddNewSegment(p) {
    this.segments.splice(0, 0, new DataSegment(p));
  }
  getlastPoint() {
    if (this.segments.length <= 0) {
      return new pointXY(NaN, NaN);
    }
    return this.segments[this.segments.length - 1].data[this.segments[this.segments.length - 1].count - 1];
  }
  handleSummary(p, delta) {
    if (this.summaries == null) {
      this.summaries = [];
      this.summaries.push(new Summary(0, this.summaries, SUMMARY_GRANULARITY));
    }
    if (this.summaries != null)
      this.summaries[0].addSequentialPoint(p, delta);
  }
  AddPoint(p) {
    this._timeRange = MinMaxHandler.CombineWithNumber(this._timeRange, p.x);
    this._valueRange = MinMaxHandler.CombineWithNumber(this._valueRange, p.y);
    let delta1 = -1;
    let delta2 = -1;
    if (this.segments.length <= 0) {
      this.AddNewSegment(p);
      this.totalPointCount++;
      if (SUMMARY_GRANULARITY > 0)
        this.handleSummary(p, delta1);
      return;
    } else if (this.segments[0].count > 1) {
      delta1 = this.segments[0].data[this.segments[0].count - 1].x - this.segments[0].data[this.segments[0].count - 2].x;
      delta2 = p.x - this.segments[0].data[this.segments[0].count - 1].x;
      if (delta2 > 0.1 && (delta2 < 0 || delta2 > 2 * delta1)) {
        this.AddNewSegment(p);
        if (SUMMARY_GRANULARITY > 0)
          this.handleSummary(p, delta1);
        return;
      }
    }
    if (SUMMARY_GRANULARITY > 0)
      this.handleSummary(p, delta1);
    this.segments[0].data[this.segments[0].count] = p;
    this.segments[0].count++;
    this.totalPointCount++;
    if (DataSerie._MaxPointsPerSeries > 0 && this.totalPointCount > DataSerie._MaxPointsPerSeries) {
      this.dataCleanUp();
      this.rebuildSummaries();
    }
    this.parent.adjustGlobalTimeRange(p.x);
    this.parent.redraw();
  }
  rebuildSummaries() {
    if (SUMMARY_GRANULARITY <= 0)
      return;
    this.summaries = [];
    this.summaries.push(new Summary(0, this.summaries, SUMMARY_GRANULARITY));
    this.summaries[0].processSegments(this.segments);
  }
  dumpSummaries() {
    if (this.summaries != null)
      for (let i = 0; i < this.summaries.length; i++)
        this.summaries[i].Dump();
    else
      console.log("****No summaries ****");
  }
  dataCleanUp() {
    if (this.segments.length <= 0)
      return;
    let newLimit = DataSerie._MaxPointsPerSeries * 90 / 100;
    while (this.segments[this.segments.length - 1].count <= this.totalPointCount - newLimit) {
      this.totalPointCount -= this.segments[this.segments.length - 1].count;
      this.segments.splice(this.segments.length - 1, 1);
    }
    if (this.totalPointCount > newLimit) {
      let delta = this.totalPointCount - newLimit;
      let newsize = this.segments[this.segments.length - 1].count - delta;
      let newdata = new Array(newsize);
      DataSegment.ArrayCopy(this.segments[this.segments.length - 1].data, delta, newdata, 0, this.segments[this.segments.length - 1].count - delta);
      this.segments[this.segments.length - 1].data = newdata;
      this.segments[this.segments.length - 1].count -= delta;
      this.totalPointCount -= delta;
    }
    let tmin = this.segments[0].data[0].x;
    let tmax = this.segments[0].data[0].x;
    let ymin = this.segments[0].data[0].y;
    let ymax = this.segments[0].data[0].y;
    for (let i = 0; i < this.segments.length; i++) {
      let count = this.segments[i].count;
      if (tmin > this.segments[i].data[0].x)
        tmin = this.segments[i].data[0].x;
      if (tmax < this.segments[i].data[count - 1].x)
        tmax = this.segments[i].data[count - 1].x;
      for (let j = 0; j < count; j++) {
        if (ymin > this.segments[i].data[j].y)
          ymin = this.segments[i].data[j].y;
        if (ymax < this.segments[i].data[j].y)
          ymax = this.segments[i].data[j].y;
      }
    }
    this._timeRange.Min = tmin;
    this._timeRange.Max = tmax;
    this._valueRange.Min = ymin;
    this._valueRange.Max = ymax;
  }
  InsertPoints(points) {
    if (points.length == 0)
      return;
    if (points.length == 1) {
      this._timeRange = MinMaxHandler.CombineWithNumber(this._timeRange, points[0].x);
      this._valueRange = MinMaxHandler.CombineWithNumber(this._valueRange, points[0].y);
      return;
    }
    let FirstStep = points[1].x - points[0].x;
    let LastStep = points[points.length - 1].x - points[points.length - 2].x;
    let InsertAtBegining = -1;
    let InsertAtEnd = -1;
    for (let i = 0; i < this.segments.length; i++) {
      if (this.segments[i].count > 1) {
        let DeltaInsertAtBegining = this.segments[i].data[0].x - points[points.length - 1].x;
        let DeltaInsertAtEnd = points[0].x - this.segments[i].data[this.segments[i].count - 1].x;
        if (DeltaInsertAtBegining > 0 && DeltaInsertAtBegining < 2 * FirstStep)
          InsertAtBegining = i;
        if (DeltaInsertAtEnd > 0 && DeltaInsertAtEnd < 2 * LastStep)
          InsertAtEnd = i;
      }
    }
    if (InsertAtBegining >= 0) {
      DataSegment.ArrayCopy(this.segments[InsertAtBegining].data, 0, this.segments[InsertAtBegining].data, points.length, this.segments[InsertAtBegining].count);
      DataSegment.ArrayCopy(points, 0, this.segments[InsertAtBegining].data, 0, points.length);
      this.segments[InsertAtBegining].count += points.length;
      this.totalPointCount += points.length;
    } else if (InsertAtEnd >= 0) {
      DataSegment.ArrayCopy(points, 0, this.segments[InsertAtEnd].data, this.segments[InsertAtEnd].count, points.length);
      this.segments[InsertAtEnd].count += points.length;
      this.totalPointCount += points.length;
    } else {
      let inserted = false;
      for (let i = 0; i < this.segments.length; i++) {
        if (this.segments[i].data[this.segments[i].data.length - 1].x < points[0].x && !inserted) {
          this.segments.splice(i, 0, new DataSegment(points));
          inserted = true;
        }
      }
      if (!inserted)
        this.segments.push(new DataSegment(points));
      this.totalPointCount += points.length;
    }
    this._timeRange = MinMaxHandler.CombineWithNumber(this._timeRange, points[0].x);
    this._timeRange = MinMaxHandler.CombineWithNumber(this._timeRange, points[points.length - 1].x);
    for (let i = 0; i < points.length; i++) {
      this._valueRange = MinMaxHandler.CombineWithNumber(this._valueRange, points[i].y);
    }
    if (DataSerie._MaxPointsPerSeries > 0 && this.totalPointCount > DataSerie._MaxPointsPerSeries)
      this.dataCleanUp();
    this.parent.redraw();
  }
  static CompareSegments(a, b) {
    if (a.data[0].x > b.data[0].x)
      return -1;
    if (a.data[0].x < b.data[0].x)
      return 1;
    return 0;
  }
  getData() {
    let res = [];
    this.segments.sort(DataSerie.CompareSegments);
    for (let i = this.segments.length - 1; i >= 0; i--) {
      for (let j = 0; j < this.segments[i].count; j++) {
        res.push(this.segments[i].data[j]);
      }
    }
    return res;
  }
  findClosestValue(x, AllowInterpolation) {
    let N1 = 0;
    let N2 = 0;
    let Pos = 0;
    if (this.segments.length <= 0)
      return null;
    for (let i = 0; i < this.segments.length; i++) {
      if (x >= this.segments[i].data[0].x && x <= this.segments[i].data[this.segments[i].count - 1].x) {
        let data = this.segments[i].data;
        N1 = 0;
        N2 = this.segments[i].count - 1;
        while (N2 - N1 > 1) {
          let N = N1 + N2 >> 1;
          if (data[N].x > x)
            N2 = N;
          else
            N1 = N;
        }
        Pos = N1 - 1;
        if (Pos < 0)
          Pos = 0;
        if (!AllowInterpolation) {
          if (x - data[Pos].x < data[Pos + 1].x - x)
            return data[Pos];
          else
            return data[Pos + 1];
        } else {
          Pos++;
          if (x == data[Pos].x)
            return data[Pos];
          if (x == data[Pos + 1].x)
            return data[Pos + 1];
          let p = new pointXY();
          p.x = x;
          p.y = data[Pos].y + (data[Pos + 1].y - data[Pos].y) * (x - data[Pos].x) / (data[Pos + 1].x - data[Pos].x);
          return p;
        }
      }
    }
    if (AllowInterpolation)
      return null;
    try {
      this.segments[0].data[0].clone();
    } catch (e) {
      debugger;
    }
    let match = this.segments[0].data[0];
    let delta = Math.abs(this.segments[0].data[0].x - x);
    for (let i = 0; i < this.segments.length; i++) {
      let d1 = Math.abs(this.segments[i].data[0].x - x);
      let d2 = Math.abs(this.segments[i].data[this.segments[i].count - 1].x - x);
      if (d1 < delta) {
        match = this.segments[i].data[0];
        delta = d1;
      }
      if (d2 < delta) {
        match = this.segments[i].data[this.segments[i].count - 1];
        delta = d2;
      }
    }
    return match.clone();
  }
  clear() {
    this.segments = [];
    this._timeRange = MinMaxHandler.DefaultValue();
    this._valueRange = MinMaxHandler.DefaultValue();
    this.parent.clearCachedObjects();
    this.totalPointCount = 0;
  }
};
DataSerie._MaxPointsPerSeries = 0;
var DataTracker = class {
  get directParent() {
    return this._directParent;
  }
  get userData() {
    return this._userData;
  }
  set userData(value) {
    this._userData = value;
  }
  constructor(parent, directParent) {
    this._userData = null;
    this._enabled = false;
    this._showSerieName = false;
    this._showTimeStamp = false;
    this._dataPrecisionString = "";
    this._dataPrecision = DataTracker.DataPrecision.PRECISION_NOLIMIT;
    this._diameter = 5;
    this._handleLength = 25;
    this._detectionDistance = 50;
    this._bgColor = YColor.FromArgb(200, 255, 255, 255);
    this._borderColor = YColor.Black;
    this._borderthickness = 1;
    this._padding = 10;
    this._verticalMargin = 10;
    this._horizontalMargin = 10;
    this._bgBrush = null;
    this._pen = null;
    this._font = null;
    this._directParent = directParent;
    this._parentRenderer = parent;
    this._font = new YFont(parent, this, 8, null);
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    this._enabled = value;
    this._parentRenderer.redraw();
  }
  get showSerieName() {
    return this._showSerieName;
  }
  set showSerieName(value) {
    this._showSerieName = value;
    this._parentRenderer.redraw();
  }
  get showTimeStamp() {
    return this._showTimeStamp;
  }
  set showTimeStamp(value) {
    this._showTimeStamp = value;
    this._parentRenderer.redraw();
  }
  get dataPrecisionString() {
    return this._dataPrecisionString;
  }
  get dataPrecision() {
    return this._dataPrecision;
  }
  set dataPrecision(value) {
    this._dataPrecision = value;
    this.compute_dataPrecisionString();
    this._parentRenderer.redraw();
  }
  compute_dataPrecisionString() {
    if (this._dataPrecision == DataTracker.DataPrecision.PRECISION_NOLIMIT) {
      this._dataPrecisionString = "";
      return;
    }
    this._dataPrecisionString = "0.";
  }
  get diameter() {
    return this._diameter;
  }
  set diameter(value) {
    if (value < 0)
      throw new RangeError("Diameter must be a positive value");
    this._diameter = value;
    this._parentRenderer.redraw();
  }
  get handleLength() {
    return this._handleLength;
  }
  set handleLength(value) {
    if (value < 0)
      throw new RangeError("Hanle length must be a positive value");
    this._handleLength = value;
    this._parentRenderer.redraw();
  }
  get detectionDistance() {
    return this._detectionDistance;
  }
  set detectionDistance(value) {
    if (value <= 0)
      throw new RangeError("Distance must be a positive value");
    this._detectionDistance = value;
  }
  get bgColor() {
    return this._bgColor;
  }
  set bgColor(value) {
    this._bgColor = value;
    this._bgBrush = null;
    this._parentRenderer.redraw();
  }
  get borderColor() {
    return this._borderColor;
  }
  set borderColor(value) {
    this._borderColor = value;
    this._pen = null;
    this._parentRenderer.redraw();
  }
  get borderthickness() {
    return this._borderthickness;
  }
  set borderthickness(value) {
    if (value < 0)
      throw new RangeError("Thickness must be a positive value");
    this._borderthickness = value;
    this._pen = null;
    this._parentRenderer.redraw();
  }
  get padding() {
    return this._padding;
  }
  set padding(value) {
    if (value < 0)
      throw new RangeError("Padding must be a positive value");
    this._padding = value;
    this._parentRenderer.redraw();
  }
  get verticalMargin() {
    return this._verticalMargin;
  }
  set verticalMargin(value) {
    if (value < 0)
      throw new RangeError("Margin must be a positive value");
    this._verticalMargin = value;
    this._parentRenderer.redraw();
  }
  get horizontalMargin() {
    return this._horizontalMargin;
  }
  set horizontalMargin(value) {
    if (value < 0)
      throw new RangeError("Margin must be a positive value");
    this._horizontalMargin = value;
    this._parentRenderer.redraw();
  }
  get bgBrush() {
    if (this._bgBrush == null) {
      this._bgBrush = new YSolidBrush(this._bgColor);
    }
    return this._bgBrush;
  }
  get pen() {
    if (this._pen == null)
      this._pen = new YPen(this._borderColor, this._borderthickness, true);
    return this._pen;
  }
  get font() {
    return this._font;
  }
};
(function(DataTracker2) {
  class DataPrecisionEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, DataPrecision);
    }
  }
  DataTracker2.DataPrecisionEnumItem = DataPrecisionEnumItem;
  class DataPrecision extends YEnum {
  }
  DataPrecision.PRECISION_NOLIMIT = new DataPrecisionEnumItem("PRECISION_NOLIMIT", "As is");
  DataPrecision.PRECISION_1 = new DataPrecisionEnumItem("PRECISION_1", "1");
  DataPrecision.PRECISION_01 = new DataPrecisionEnumItem("PRECISION_01", "0.1");
  DataPrecision.PRECISION_001 = new DataPrecisionEnumItem("PRECISION_001", "0.01");
  DataPrecision.PRECISION_0001 = new DataPrecisionEnumItem("PRECISION_0001", "0.001");
  DataPrecision.PRECISION_00001 = new DataPrecisionEnumItem("PRECISION_00001", "0.0001");
  DataPrecision.PRECISION_000001 = new DataPrecisionEnumItem("PRECISION_000001", "0.00001");
  DataPrecision.PRECISION_0000001 = new DataPrecisionEnumItem("PRECISION_0000001", "0.000001");
  DataPrecision.PRECISION_00000001 = new DataPrecisionEnumItem("PRECISION_00000001", "0.0000001");
  DataPrecision.PRECISION_000000001 = new DataPrecisionEnumItem("PRECISION_000000001", "0.00000001");
  DataPrecision.PRECISION_0000000001 = new DataPrecisionEnumItem("PRECISION_0000000001", "0.000000001");
  DataTracker2.DataPrecision = DataPrecision;
})(DataTracker || (DataTracker = {}));
var LegendPanel = class {
  get directParent() {
    return this._directParent;
  }
  get userData() {
    return this._userData;
  }
  set userData(value) {
    this._userData = value;
  }
  get traceWidthFactor() {
    return this._traceWidth;
  }
  set traceWidthFactor(value) {
    if (value <= 0)
      throw new RangeError("This has to be a strictly positive value");
    this._traceWidth = value;
    this._parentRenderer.resetlegendPens();
    this._parentRenderer.redraw();
  }
  constructor(parent, directParent) {
    this._userData = null;
    this._traceWidth = 1;
    this._enabled = false;
    this._position = LegendPanel.Position.BOTTOM;
    this._overlap = false;
    this._bgColor = YColor.FromArgb(200, 255, 255, 255);
    this._borderColor = YColor.Black;
    this._borderthickness = 1;
    this._padding = 10;
    this._verticalMargin = 10;
    this._horizontalMargin = 10;
    this._bgBrush = null;
    this._pen = null;
    this._font = null;
    this._directParent = directParent;
    this._parentRenderer = parent;
    this._font = new YFont(parent, this, 8, null);
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    this._enabled = value;
    this._parentRenderer.redraw();
  }
  get position() {
    return this._position;
  }
  set position(value) {
    this._position = value;
    this._parentRenderer.redraw();
  }
  get overlap() {
    return this._overlap;
  }
  set overlap(value) {
    this._overlap = value;
    this._parentRenderer.redraw();
  }
  get bgColor() {
    return this._bgColor;
  }
  set bgColor(value) {
    this._bgColor = value;
    this._bgBrush = null;
    this._parentRenderer.redraw();
  }
  get borderColor() {
    return this._borderColor;
  }
  set borderColor(value) {
    this._borderColor = value;
    this._pen = null;
    this._parentRenderer.redraw();
  }
  get borderthickness() {
    return this._borderthickness;
  }
  set borderthickness(value) {
    if (value < 0)
      throw new RangeError("Thickness must be a positive value");
    this._borderthickness = value;
    this._pen = null;
    this._parentRenderer.redraw();
  }
  get padding() {
    return this._padding;
  }
  set padding(value) {
    if (value < 0)
      throw new RangeError("Padding must be a positive value");
    this._padding = value;
    this._parentRenderer.redraw();
  }
  get verticalMargin() {
    return this._verticalMargin;
  }
  set verticalMargin(value) {
    if (value < 0)
      throw new RangeError("Margin must be a positive value");
    this._verticalMargin = value;
    this._parentRenderer.redraw();
  }
  get horizontalMargin() {
    return this._horizontalMargin;
  }
  set horizontalMargin(value) {
    if (value < 0)
      throw new RangeError("Margin must be a positive value");
    this._horizontalMargin = value;
    this._parentRenderer.redraw();
  }
  get bgBrush() {
    if (this._bgBrush == null) {
      this._bgBrush = new YSolidBrush(this._bgColor);
    }
    return this._bgBrush;
  }
  get pen() {
    if (this._pen == null)
      this._pen = new YPen(this._borderColor, this._borderthickness, true);
    return this._pen;
  }
  get font() {
    return this._font;
  }
};
(function(LegendPanel2) {
  class PositionEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, Position);
    }
  }
  LegendPanel2.PositionEnumItem = PositionEnumItem;
  class Position extends YEnum {
  }
  Position.LEFT = new PositionEnumItem("LEFT", "Left");
  Position.TOPLEFT = new PositionEnumItem("TOPLEFT", "Top-Left");
  Position.TOP = new PositionEnumItem("TOP", "Top");
  Position.TOPRIGHT = new PositionEnumItem("TOPRIGHT", "Top-Right");
  Position.RIGHT = new PositionEnumItem("RIGHT", "Right");
  Position.BOTTOMRIGHT = new PositionEnumItem("BOTTOMRIGHT", "Bottom-Right");
  Position.BOTTOM = new PositionEnumItem("BOTTOM", "Bottom");
  Position.BOTTOMLEFT = new PositionEnumItem("BOTTOMLEFT", "Bottom-Left");
  LegendPanel2.Position = Position;
})(LegendPanel || (LegendPanel = {}));
var Navigator = class {
  get directParent() {
    return this._directParent;
  }
  get userData() {
    return this._userData;
  }
  set userData(value) {
    this._userData = value;
  }
  get showXAxisZones() {
    return this._showXAxisZones;
  }
  set showXAxisZones(value) {
    this._showXAxisZones = value;
  }
  get relativeheight() {
    return this._relativeheight;
  }
  set relativeheight(value) {
    if (value < 10)
      value = 10;
    if (value > 50)
      value = 50;
    this._relativeheight = value;
    this._parentRenderer.redraw();
  }
  constructor(parent, directParent) {
    this._userData = null;
    this._viewport = new ViewPortSettings();
    this.Xrange = null;
    this._showXAxisZones = true;
    this._relativeheight = 10;
    this._enabled = false;
    this._bgColor1 = YColor.FromArgb(255, 225, 225, 225);
    this._cursorBorderColor = YColor.FromArgb(255, 40, 40, 40);
    this._yAxisHandling = Navigator.YAxisHandling.AUTO;
    this._bgColor2 = YColor.FromArgb(255, 225, 225, 225);
    this._cursorColor = YColor.FromArgb(100, 0, 255, 0);
    this._cursorBrush = null;
    this._pen = null;
    this._cursorBorderPen = null;
    this._xAxisColor = YColor.Black;
    this._xAxisThickness = 1;
    this._borderPen = null;
    this._borderColor = YColor.DimGray;
    this._borderThickness = 1;
    this._bgBrush = null;
    this._font = null;
    this._directParent = directParent;
    this._parentRenderer = parent;
    this._font = new YFont(parent, this, 8, null);
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    this._enabled = value;
    this._parentRenderer.redraw();
  }
  get bgColor1() {
    return this._bgColor1;
  }
  set bgColor1(value) {
    this._bgColor1 = value;
    this._bgBrush = null;
    this._parentRenderer.redraw();
  }
  get cursorBorderColor() {
    return this._cursorBorderColor;
  }
  set cursorBorderColor(value) {
    this._cursorBorderColor = value;
    this._cursorBorderPen = null;
    this._parentRenderer.redraw();
  }
  get yAxisHandling() {
    return this._yAxisHandling;
  }
  set yAxisHandling(value) {
    this._yAxisHandling = value;
    this._parentRenderer.redraw();
  }
  get bgColor2() {
    return this._bgColor2;
  }
  set bgColor2(value) {
    this._bgColor2 = value;
    this._bgBrush = null;
    this._parentRenderer.redraw();
  }
  get cursorColor() {
    return this._cursorColor;
  }
  set cursorColor(value) {
    this._cursorColor = value;
    this._cursorBrush = null;
    this._parentRenderer.redraw();
  }
  get cursorBrush() {
    if (this._cursorBrush == null) {
      this._cursorBrush = new YSolidBrush(this._cursorColor);
    }
    return this._cursorBrush;
  }
  get pen() {
    if (this._pen == null)
      this._pen = new YPen(this._xAxisColor, this._xAxisThickness, true);
    return this._pen;
  }
  get cursorBorderPen() {
    if (this._cursorBorderPen == null)
      this._cursorBorderPen = new YPen(this._cursorBorderColor, 1, true);
    return this._cursorBorderPen;
  }
  get xAxisColor() {
    return this._xAxisColor;
  }
  set xAxisColor(value) {
    this._xAxisColor = value;
    this._pen = null;
    this._parentRenderer.redraw();
  }
  get xAxisThickness() {
    return this._xAxisThickness;
  }
  set xAxisThickness(value) {
    if (value < 0)
      throw new RangeError("Thickness must be a positive value");
    this._xAxisThickness = value;
    this._pen = null;
    this._parentRenderer.redraw();
  }
  get borderPen() {
    if (this._borderPen == null)
      this._borderPen = new YPen(this._borderColor, this._borderThickness, true);
    return this._borderPen;
  }
  get borderColor() {
    return this._borderColor;
  }
  set borderColor(value) {
    this._borderColor = value;
    this._borderPen = null;
    this._parentRenderer.redraw();
  }
  get borderThickness() {
    return this._borderThickness;
  }
  set borderThickness(value) {
    if (value < 0)
      throw new RangeError("Thickness must be a positive value");
    this._borderThickness = value;
    this._borderPen = null;
    this._parentRenderer.redraw();
  }
  setPosition(ParentWidth, ParentHeight, Lmargin, Rmargin, Tmargin, Bmargin) {
    if (this._viewport.Lmargin != Lmargin || this._viewport.Rmargin != Rmargin || this._viewport.Tmargin != Tmargin || this._viewport.Bmargin != Bmargin) {
      this._bgBrush = null;
    }
    this._viewport.Lmargin = Lmargin;
    this._viewport.Rmargin = Rmargin;
    this._viewport.Bmargin = Bmargin;
    this._viewport.Tmargin = Tmargin;
    this._viewport.Width = ParentWidth;
    this._viewport.Height = ParentHeight;
  }
  setIRLPosition(IRLx, IRLy, xZoom, yZoom) {
    this._viewport.IRLx = IRLx;
    this._viewport.IRLy = IRLy;
    this._viewport.zoomx = xZoom;
    this._viewport.zoomy = yZoom;
  }
  startCapture(IRLStartPoint, xAxisMin, xAxisMax) {
    this._viewport.OriginalXAxisMin = xAxisMin;
    this._viewport.OriginalXAxisMax = xAxisMax;
    this._viewport.OriginalIRLx = this._viewport.IRLx;
    this._viewport.OriginalLmargin = this._viewport.Lmargin;
    this._viewport.OriginalZoomx = this._viewport.zoomx;
    this._viewport.IRLCaptureStartX = IRLStartPoint.x;
    this._viewport.Capture = true;
  }
  get Capture() {
    return this._viewport.Capture;
  }
  stopCapture() {
    this._viewport.Capture = false;
  }
  get viewport() {
    return this._viewport;
  }
  get bgBrush() {
    if (this._bgBrush == null) {
      this._bgBrush = new YLinearGradientBrush(this._bgColor1, this._bgColor2);
    }
    return this._bgBrush;
  }
  get font() {
    return this._font;
  }
};
(function(Navigator2) {
  class YAxisHandlingEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, YAxisHandling);
    }
  }
  Navigator2.YAxisHandlingEnumItem = YAxisHandlingEnumItem;
  class YAxisHandling extends YEnum {
  }
  YAxisHandling.AUTO = new YAxisHandlingEnumItem("AUTO", "Automatic");
  YAxisHandling.INHERIT = new YAxisHandlingEnumItem("INHERIT", "Inherit from main view");
  Navigator2.YAxisHandling = YAxisHandling;
})(Navigator || (Navigator = {}));
var Marker = class {
  get userData() {
    return this._userData;
  }
  set userData(value) {
    this._userData = value;
  }
  static _round100(v) {
    return Math.round(100 * v) / 100;
  }
  get stringFormat() {
    if (this._stringFormat != null)
      return this._stringFormat;
    this._stringFormat = new YStringFormat(16384);
    this._stringFormat.LineAlignment = 1;
    switch (this._textAlign) {
      case Marker.TextAlign.LEFT:
        this._stringFormat.Alignment = 0;
        break;
      case Marker.TextAlign.CENTER:
        this._stringFormat.Alignment = 1;
        break;
      case Marker.TextAlign.RIGHT:
        this._stringFormat.Alignment = 2;
        break;
    }
    return this._stringFormat;
  }
  get PatchTextCallback() {
    return this._MarkerTextCallback;
  }
  set PatchTextCallback(callback) {
    this._MarkerTextCallback = callback;
  }
  get directParent() {
    return this._directParent;
  }
  constructor(parent, directParent) {
    this._userData = null;
    this._stringFormat = null;
    this._MarkerTextCallback = null;
    this._enabled = false;
    this._xposition = 0;
    this._xpositionIsRelative = false;
    this._yposition = 92;
    this._text = "Marker";
    this._textAlign = Marker.TextAlign.CENTER;
    this._bgColor = YColor.FromArgb(255, 255, 255, 192);
    this._borderColor = YColor.DarkRed;
    this._borderthickness = 1;
    this._arrowSize = 5;
    this._padding = 5;
    this._verticalMargin = 5;
    this._horizontalMargin = 5;
    this._bgBrush = null;
    this._arrowBrush = null;
    this._pen = null;
    this._navigatorpen = null;
    this._font = null;
    this._directParent = directParent;
    this._parentRenderer = parent;
    this._font = new YFont(parent, this, 8, null);
  }
  startCapture() {
    this._parentRenderer.startMarkerCapture(this);
  }
  setCapturedPosition(position, axis) {
    this.enabled = true;
    this._xpositionIsRelative = axis.timeReference == TimeConverter.TimeReference.RELATIVE && axis.zeroTime > 0;
    this._xposition = Marker._round100(this._xpositionIsRelative ? position - axis.zeroTime : position);
    this._parentRenderer.clearCachedObjects();
    this._parentRenderer.redraw();
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    if (this._enabled != value) {
      this._enabled = value;
      this._parentRenderer.clearCachedObjects();
      this._parentRenderer.redraw();
    }
  }
  get xposition() {
    return this._xposition;
  }
  set xposition(value) {
    this._xposition = Marker._round100(value);
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get timereference() {
    return this._xpositionIsRelative ? TimeConverter.TimeReference.RELATIVE : TimeConverter.TimeReference.ABSOLUTE;
  }
  set timereference(value) {
    let v = value == TimeConverter.TimeReference.RELATIVE;
    if (this._xpositionIsRelative != v) {
      let ZeroPosition = this._directParent.zeroTime;
      if (isNaN(ZeroPosition))
        ZeroPosition = 0;
      if (v) {
        this._xpositionIsRelative = true;
        this._xposition -= ZeroPosition;
      } else {
        this._xpositionIsRelative = false;
        this._xposition += ZeroPosition;
      }
      this._xposition = Marker._round100(this._xposition);
      this._parentRenderer.redraw();
    }
  }
  get positionOnXAxis() {
    return new xAxisPosition(this._xposition, this._xpositionIsRelative);
  }
  set positionOnXAxis(value) {
    if (value.capture) {
      this.startCapture();
    } else {
      let v = Marker._round100(value.value);
      if (this._xpositionIsRelative != value.relative || this._xposition != v) {
        this._xposition = v;
        this._xpositionIsRelative = value.relative;
        if (this._enabled)
          this._parentRenderer.redraw();
      }
    }
  }
  get yposition() {
    return this._yposition;
  }
  set yposition(value) {
    this._yposition = Math.min(100, Math.max(0, value));
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get text() {
    return this._text;
  }
  set text(value) {
    this._text = value;
    this._parentRenderer.clearCachedObjects();
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get textAlign() {
    return this._textAlign;
  }
  set textAlign(value) {
    this._textAlign = value;
    this._stringFormat = null;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get shortText() {
    if (this._text.length <= 20)
      return this._text;
    return this._text.substring(0, 18) + "..";
  }
  get bgColor() {
    return this._bgColor;
  }
  set bgColor(value) {
    this._bgColor = value;
    this._bgBrush = null;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get borderColor() {
    return this._borderColor;
  }
  set borderColor(value) {
    this._borderColor = value;
    this._arrowBrush = null;
    this._pen = null;
    this._navigatorpen = null;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get borderthickness() {
    return this._borderthickness;
  }
  set borderthickness(value) {
    if (value < 0)
      throw new RangeError("thickness must be a positive value");
    this._borderthickness = value;
    this._parentRenderer.clearCachedObjects();
    this._pen = null;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get arrowSize() {
    return this._arrowSize;
  }
  set arrowSize(value) {
    this._arrowSize = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get padding() {
    return this._padding;
  }
  set padding(value) {
    if (value < 0)
      throw new RangeError("Padding must be a positive value");
    this._padding = value;
    this._parentRenderer.clearCachedObjects();
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get verticalMargin() {
    return this._verticalMargin;
  }
  set verticalMargin(value) {
    this._verticalMargin = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get horizontalMargin() {
    return this._horizontalMargin;
  }
  set horizontalMargin(value) {
    this._horizontalMargin = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get bgBrush() {
    if (this._bgBrush == null) {
      this._bgBrush = new YSolidBrush(this._bgColor);
    }
    return this._bgBrush;
  }
  get arrowBrush() {
    if (this._arrowBrush == null) {
      this._arrowBrush = new YSolidBrush(this._borderColor, true);
    }
    return this._arrowBrush;
  }
  get pen() {
    if (this._pen == null)
      this._pen = new YPen(this._borderColor, this._borderthickness, true);
    return this._pen;
  }
  get navigatorpen() {
    if (this._navigatorpen == null)
      this._navigatorpen = new YPen(this._borderColor, 1);
    return this._navigatorpen;
  }
  get font() {
    return this._font;
  }
};
(function(Marker2) {
  class TextAlignEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, TextAlign);
    }
  }
  Marker2.TextAlignEnumItem = TextAlignEnumItem;
  class TextAlign extends YEnum {
  }
  TextAlign.LEFT = new TextAlignEnumItem("LEFT", "Left");
  TextAlign.CENTER = new TextAlignEnumItem("CENTER", "Center");
  TextAlign.RIGHT = new TextAlignEnumItem("RIGHT", "Right");
  Marker2.TextAlign = TextAlign;
})(Marker || (Marker = {}));
var Legend = class {
  get directParent() {
    return this._directParent;
  }
  get userData() {
    return this._userData;
  }
  set userData(value) {
    this._userData = value;
  }
  constructor(parent, directParent) {
    this._userData = null;
    this._title = "";
    this._font = null;
    this._directParent = directParent;
    this._parentRenderer = parent;
    this._font = new YFont(parent, this, 12, null);
  }
  get title() {
    return this._title;
  }
  set title(value) {
    this._title = value;
    this._parentRenderer.redraw();
  }
  get font() {
    return this._font;
  }
};
var GenericAxis = class {
  get directParent() {
    return this._directParent;
  }
  get zones() {
    return this._zones;
  }
  AddZone() {
    let z = new Zone(this._parentRenderer, this);
    this._zones.push(z);
    return z;
  }
  get userData() {
    return this._userData;
  }
  set userData(value) {
    this._userData = value;
  }
  get AxisChanged() {
    return this._AxisChanged;
  }
  set AxisChanged(value) {
    this._AxisChanged = value;
  }
  constructor(parent, directParent) {
    this._userData = null;
    this._AxisChanged = null;
    this._pen = null;
    this._gridPen = null;
    this._visible = true;
    this._AllowAutoShow = false;
    this._min = Number.NaN;
    this._max = Number.NaN;
    this._step = Number.NaN;
    this._thickness = 1;
    this._color = YColor.Black;
    this._showGrid = false;
    this._gridColor = YColor.FromArgb(50, 0, 0, 0);
    this._gridThickness = 1;
    this._font = null;
    this._zones = [];
    this._directParent = directParent;
    this._parentRenderer = parent;
    this._legend = new Legend(parent, this);
    this._font = new YFont(parent, this);
  }
  get pen() {
    if (this._pen == null)
      this._pen = new YPen(this._color, this._thickness, true);
    return this._pen;
  }
  get gridPen() {
    if (this._gridPen == null)
      this._gridPen = new YPen(this._gridColor, this._gridThickness, true);
    return this._gridPen;
  }
  get visible() {
    return this._visible;
  }
  set visible(value) {
    this._visible = value;
    if (!value) {
      this._AllowAutoShow = false;
    }
    this._parentRenderer.redraw();
  }
  get AllowAutoShow() {
    return this._AllowAutoShow;
  }
  set AllowAutoShow(value) {
    this._AllowAutoShow = value;
  }
  AutoShow() {
    if (this._AllowAutoShow) {
      this.visible = true;
      if (this._AxisChanged != null)
        this._AxisChanged(this);
    }
  }
  set_minMax(value_min, value_max) {
    if (!isNaN(value_min) && !isNaN(value_max) && value_min >= value_max) {
      throw new RangeError("Min (" + value_min.toString() + ") cannot be greater than max (" + value_max.toString() + ")");
    }
    this._min = value_min;
    this._max = value_max;
    this._parentRenderer.redraw();
  }
  get min() {
    return this._min;
  }
  set min(value) {
    if (!isNaN(value) && !isNaN(this._max) && !YDataRenderer.minMaxCheckDisabled) {
      if (value >= this._max) {
        throw new RangeError("Min cannot be greater than max (" + this._max.toString() + ")");
      }
    }
    this._min = value;
    this._parentRenderer.redraw();
  }
  setMinMax(min, max) {
    if (min < max) {
      this._min = min;
      this._max = max;
      this._parentRenderer.redraw();
    }
  }
  get max() {
    return this._max;
  }
  set max(value) {
    if (!isNaN(value) && !isNaN(this._min) && !YDataRenderer.minMaxCheckDisabled) {
      if (value <= this._min)
        throw new RangeError("Max cannot be less than min (" + this._min.toString() + ")");
    }
    this._max = value;
    this._parentRenderer.redraw();
  }
  get step() {
    return this._step;
  }
  set step(value) {
    if (!isNaN(value) && value < 0)
      throw new RangeError("Steps must be a strictely positive value");
    this._step = value;
    this._parentRenderer.redraw();
  }
  get thickness() {
    return this._thickness;
  }
  set thickness(value) {
    if (value < 0)
      throw new RangeError("Thickness must be a positive value");
    this._thickness = value;
    this._pen = null;
    this._parentRenderer.redraw();
  }
  get color() {
    return this._color;
  }
  set color(value) {
    this._color = value;
    this._pen = null;
    this._parentRenderer.redraw();
  }
  get showGrid() {
    return this._showGrid;
  }
  set showGrid(value) {
    this._showGrid = value;
    this._parentRenderer.redraw();
  }
  get gridColor() {
    return this._gridColor;
  }
  set gridColor(value) {
    this._gridColor = value;
    this._gridPen = null;
    this._parentRenderer.redraw();
  }
  get gridThickness() {
    return this._gridThickness;
  }
  set gridThickness(value) {
    if (value < 0)
      throw new RangeError("Thickness must be a positive value");
    this._gridThickness = value;
    this._gridPen = null;
    this._parentRenderer.redraw();
  }
  get font() {
    return this._font;
  }
  get legend() {
    return this._legend;
  }
};
var StartStopStep = class {
  constructor() {
    this.dataMin = 0;
    this.dataMax = 0;
    this.absMin = 0;
    this.absMax = 0;
    this.step = 0;
    this.start = 0;
    this.stop = 0;
    this.precision = 0;
  }
};
var xAxisPosition = class {
  get relative() {
    return this._isRelative;
  }
  set relative(value) {
    this._isRelative = value;
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value;
  }
  constructor(v, rel, capture) {
    this._isRelative = false;
    this._value = 0;
    this._capture = false;
    this._isRelative = rel;
    this._value = v;
    this._capture = typeof capture == "undefined" ? false : capture;
  }
  clone() {
    return new xAxisPosition(this._value, this._isRelative, this._capture);
  }
  toString() {
    if (this._isRelative) {
      return TimeConverter.secTimeSpanToString(this._value, 0);
    } else {
      let date = TimeConverter.FromUnixTime(this._value);
      let res = date.getFullYear().toString() + "-" + (date.getMonth() + 1).toString() + "-" + date.getDate().toString() + " " + date.getHours().toString() + ":";
      let st = date.getMinutes().toString();
      if (st.length <= 1)
        st = "0" + st;
      res = res + st + ":";
      let s = date.getSeconds();
      let ms = date.getMilliseconds();
      s = s + ms / 1e3;
      if (s < 10)
        res = res + "0";
      if (ms == 0) {
        res = res + s.toString();
      } else {
        res = res + s.toFixed(3);
      }
      return res;
    }
  }
  TryParse(str) {
    if (this._isRelative)
      return TimeConverter.tryParseStringToSecTimeSpan(str);
    return TimeConverter.tryParseStringToAbsDateTime(str);
  }
  get capture() {
    return this._capture;
  }
  set capture(value) {
    this._capture = value;
  }
};
xAxisPosition.DTdisplayformat = "DD/MM/YY hh:mm:ss.ff";
xAxisPosition.TSdisplayformat = "dd.hh:mm:ss.ff";
var YNumberFormatInfo = class {
  constructor() {
    this.NumberDecimalSeparator = ".";
  }
};
var YAxis = class extends GenericAxis {
  constructor(parent, directParent, index) {
    super(parent, directParent);
    this._index = 0;
    this._highlightZero = false;
    this._position = YAxis.HrzPosition.LEFT;
    this.innerWidth = 0;
    this.zoom = 0;
    this.IRLy = 0;
    this._index = index;
    this.nfi = new YNumberFormatInfo();
    this.nfi.NumberDecimalSeparator = ".";
    this.startStopStep = new StartStopStep();
    this.startStopStep.start = 0;
    this.startStopStep.stop = 1;
    this.startStopStep.step = 0.1;
  }
  get index() {
    return this._index;
  }
  lockMinMax() {
    this._min = this.startStopStep.absMin;
    this._max = this.startStopStep.absMax;
    this._parentRenderer.redraw();
  }
  unlockMinMax() {
    this._min = Number.NaN;
    this._max = Number.NaN;
    this._parentRenderer.redraw();
  }
  get highlightZero() {
    return this._highlightZero;
  }
  set highlightZero(value) {
    this._highlightZero = value;
    this._parentRenderer.redraw();
  }
  get position() {
    return this._position;
  }
  set position(value) {
    this._position = value;
    this._parentRenderer.redraw();
  }
  computeStartAndStep(M) {
    let res = new StartStopStep();
    let min = this.min;
    let max = this.max;
    res.step = this.step;
    res.precision = 0;
    if (!MinMaxHandler.isDefined(M)) {
      M = MinMaxHandler.DefaultValue();
      M.Min = 0;
      M.Max = 100;
    }
    if (isNaN(min))
      min = M.Min;
    if (isNaN(max))
      max = M.Max;
    res.absMax = max;
    res.absMin = min;
    if (min == max) {
      min -= 0.5;
      max += 0.5;
    }
    if (min != 0)
      min -= (max - min) * 0.025;
    if (max != 0)
      max += (max - min) * 0.025;
    res.start = min;
    res.stop = max;
    res.dataMin = min;
    res.dataMax = max;
    let Delta = max - min;
    if (isNaN(res.step)) {
      let MagnitudePwr = Math.log10(Delta);
      if (MagnitudePwr - Math.floor(MagnitudePwr) != 0)
        MagnitudePwr = Math.floor(MagnitudePwr) + 1;
      res.precision = MagnitudePwr - 1 >> 0;
      let Magnitude = Math.pow(10, res.precision);
      let C = Delta / Magnitude;
      if (C <= 2) {
        res.step = Magnitude / 5;
        res.precision--;
      } else if (C <= 5) {
        res.step = Magnitude / 2;
        res.precision--;
      } else {
        res.step = Magnitude;
      }
      if (isNaN(this.min)) {
        let c = min / res.step;
        if (c - Math.floor(c) != 0)
          c = c > 0 ? Math.floor(c) + 1 : Math.floor(c) - 1;
        res.start = res.step * c;
      }
    } else {
      let v = res.step.toString();
      let p = v.indexOf(".");
      if (p >= 0) {
        res.precision = -(v.length - p - 1);
      } else {
        res.precision = 0;
      }
    }
    this.startStopStep = res;
    return res;
  }
};
(function(YAxis2) {
  class HrzPositionEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, HrzPosition);
    }
  }
  YAxis2.HrzPositionEnumItem = HrzPositionEnumItem;
  class HrzPosition extends YEnum {
  }
  HrzPosition.LEFT = new HrzPositionEnumItem("LEFT", "Left");
  HrzPosition.RIGHT = new HrzPositionEnumItem("RIGHT", "Right");
  YAxis2.HrzPosition = HrzPosition;
})(YAxis || (YAxis = {}));
var XAxis = class extends GenericAxis {
  get position() {
    return this._position;
  }
  set position(value) {
    this._position = value;
    this._parentRenderer.redraw();
  }
  get markers() {
    return this._markers;
  }
  AddMarker() {
    let m = new Marker(this._parentGraph, this);
    this._markers.push(m);
    this._parentGraph.clearCachedObjects();
    this._parentGraph.redraw();
    return m;
  }
  get initialZoom() {
    return this._initialZoom;
  }
  set initialZoom(value) {
    if (value <= 0)
      throw new RangeError("Zoom must be a positive value");
    this._initialZoom = value;
    this.min = this.min - this._initialZoom * this._initialOffset / 100;
    this.max = this.min + this.initialZoom;
    this._parentRenderer.redraw();
  }
  get initialOffset() {
    return this._initialOffset;
  }
  set initialOffset(value) {
    this._initialOffset = value;
    let p = this._parentGraph.getMostRecentPoint();
    if (isNaN(p.x)) {
      this._min = this._min - this._initialZoom * this._initialOffset / 100;
      this._max = this._min + this._initialZoom;
      this._parentRenderer.redraw();
    } else {
      let zoom = this._max - this._min;
      this._min = p.x - zoom * this._initialOffset / 100;
      this._max = this._min + zoom;
    }
    this._parentRenderer.redraw();
  }
  get labelFormat() {
    return this._format;
  }
  set labelFormat(value) {
    this._format = value;
    this._parentRenderer.redraw();
  }
  constructor(parent, directParent) {
    super(parent, directParent);
    this._position = XAxis.VrtPosition.BOTTOM;
    this._markers = [];
    this._initialZoom = 300;
    this._initialOffset = 0;
    this._format = XAxis.FORMATAUTO;
    this._timeReference = TimeConverter.TimeReference.ABSOLUTE;
    this._zeroTime = 0;
    this._fullSize = 0;
    this.innerHeight = 0;
    this._overflowHandling = XAxis.OverflowHandling.DONOTHING;
    this._parentGraph = parent;
    this._markers = [];
    this.min = TimeConverter.ToUnixTime(TimeConverter.UTCNow());
    this.max = this.min + this.initialZoom;
    this.step = 30;
  }
  get timeReference() {
    return this._timeReference;
  }
  set timeReference(value) {
    this._timeReference = value;
    this._parentRenderer.redraw();
  }
  get zeroTime() {
    return this._zeroTime;
  }
  set zeroTime(value) {
    this._zeroTime = value;
  }
  get fullSize() {
    return this._fullSize;
  }
  set fullSize(value) {
    this._fullSize = value;
  }
  bestFormat(dataTimedelta, viewportTimedelta) {
    return TimeConverter.BestTimeformat(dataTimedelta, viewportTimedelta, this._timeReference);
  }
  get overflowHandling() {
    return this._overflowHandling;
  }
  set overflowHandling(value) {
    this._overflowHandling = value;
  }
};
XAxis.FORMATAUTO = 0;
(function(XAxis2) {
  class VrtPositionEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, VrtPosition);
    }
  }
  XAxis2.VrtPositionEnumItem = VrtPositionEnumItem;
  class VrtPosition extends YEnum {
  }
  VrtPosition.TOP = new VrtPositionEnumItem("TOP", "Top");
  VrtPosition.BOTTOM = new VrtPositionEnumItem("BOTTOM", "Bottom");
  XAxis2.VrtPosition = VrtPosition;
  class OverflowHandlingEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, OverflowHandling);
    }
  }
  XAxis2.OverflowHandlingEnumItem = OverflowHandlingEnumItem;
  class OverflowHandling extends YEnum {
  }
  OverflowHandling.DONOTHING = new OverflowHandlingEnumItem("DONOTHING", "Do nothing");
  OverflowHandling.SCROLL = new OverflowHandlingEnumItem("SCROLL", "Scroll contents");
  OverflowHandling.CONTRACT = new OverflowHandlingEnumItem("CONTRACT", "Squeeze contents");
  XAxis2.OverflowHandling = OverflowHandling;
})(XAxis || (XAxis = {}));
var DataPanel = class extends GenericPanel {
  constructor(parent, directParent) {
    super(parent, directParent);
    this._panelHrzAlign = DataPanel.HorizontalAlign.CENTERED;
    this._panelVrtAlign = DataPanel.VerticalAlign.CENTERED;
    this._horizontalPosition = DataPanel.HorizontalPosition.ABSOLUTEX;
    this._verticalPosition = DataPanel.VerticalPosition.ABSOLUTEY;
    this._AbsoluteXposition = 0;
    this._AbsoluteYposition = 0;
    this._YScaleIndex = 0;
  }
  get panelHrzAlign() {
    return this._panelHrzAlign;
  }
  set panelHrzAlign(value) {
    this._panelHrzAlign = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get panelVrtAlign() {
    return this._panelVrtAlign;
  }
  set panelVrtAlign(value) {
    this._panelVrtAlign = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get horizontalPosition() {
    return this._horizontalPosition;
  }
  set horizontalPosition(value) {
    this._horizontalPosition = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get verticalPosition() {
    return this._verticalPosition;
  }
  set verticalPosition(value) {
    this._verticalPosition = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get AbsoluteXposition() {
    return this._AbsoluteXposition;
  }
  set AbsoluteXposition(value) {
    this._AbsoluteXposition = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get AbsoluteYposition() {
    return this._AbsoluteYposition;
  }
  set AbsoluteYposition(value) {
    this._AbsoluteYposition = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get yScaleIndex() {
    return this._YScaleIndex;
  }
  set yScaleIndex(value) {
    this._YScaleIndex = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
};
(function(DataPanel2) {
  class HorizontalAlignEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, HorizontalAlign);
    }
  }
  DataPanel2.HorizontalAlignEnumItem = HorizontalAlignEnumItem;
  class HorizontalAlign extends YEnum {
  }
  HorizontalAlign.LEFTOF = new HorizontalAlignEnumItem("LEFTOF", "Left");
  HorizontalAlign.CENTERED = new HorizontalAlignEnumItem("CENTERED", "Center");
  HorizontalAlign.RIGHTOF = new HorizontalAlignEnumItem("RIGHTOF", "Right");
  DataPanel2.HorizontalAlign = HorizontalAlign;
  class VerticalAlignEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, VerticalAlign);
    }
  }
  DataPanel2.VerticalAlignEnumItem = VerticalAlignEnumItem;
  class VerticalAlign extends YEnum {
  }
  VerticalAlign.ABOVE = new VerticalAlignEnumItem("ABOVE", "Top");
  VerticalAlign.CENTERED = new VerticalAlignEnumItem("CENTERED", "Center");
  VerticalAlign.BELOW = new VerticalAlignEnumItem("BELOW", "Bottom");
  DataPanel2.VerticalAlign = VerticalAlign;
  class HorizontalPositionEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, HorizontalPosition);
    }
  }
  DataPanel2.HorizontalPositionEnumItem = HorizontalPositionEnumItem;
  class HorizontalPosition extends YEnum {
  }
  HorizontalPosition.LEFTBORDER = new HorizontalPositionEnumItem("LEFTBORDER", "Left border");
  HorizontalPosition.ABSOLUTEX = new HorizontalPositionEnumItem("ABSOLUTEX", "Absolute X position");
  HorizontalPosition.RIGHTBORDER = new HorizontalPositionEnumItem("RIGHTBORDER", "Right borde");
  DataPanel2.HorizontalPosition = HorizontalPosition;
  class VerticalPositionEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, VerticalPosition);
    }
  }
  DataPanel2.VerticalPositionEnumItem = VerticalPositionEnumItem;
  class VerticalPosition extends YEnum {
  }
  VerticalPosition.TOPBORDER = new VerticalPositionEnumItem("TOPBORDER", "Top border");
  VerticalPosition.ABSOLUTEY = new VerticalPositionEnumItem("ABSOLUTEY", "Absolute Y position");
  VerticalPosition.BOTTOMBORDER = new VerticalPositionEnumItem("BOTTOMBORDER", "Bottom border");
  DataPanel2.VerticalPosition = VerticalPosition;
})(DataPanel || (DataPanel = {}));
var YCursor = class {
  constructor(pngImageData) {
  }
  get handle() {
    return "crosshair";
  }
};
var YTimeSpan = class {
  constructor(value) {
    this._value = 0;
    this._value = value;
  }
  toString(format) {
    let res = "";
    let v = Math.abs(this._value / 1e3);
    let dec = Math.floor(v);
    let frac = Math.round(1e3 * (v - Math.floor(v)));
    if (format & YDate.ms1) {
      let ms = "00" + frac.toString();
      res = "." + ms.substring(ms.length - 3).substring(0, 1);
    } else if (format & YDate.ms01) {
      let ms = "00" + frac.toString();
      res = "." + ms.substring(ms.length - 3).substring(0, 2);
    } else if (format & YDate.ms001) {
      let ms = "00" + frac.toString();
      res = "." + ms.substring(ms.length - 3).substring(0, 3);
    }
    if (format & YDate.s) {
      let sec = dec % 60;
      let s = "0" + sec.toString();
      res = s.substring(s.length - 2) + res + "s";
    }
    dec = Math.floor(dec / 60);
    if (format & YDate.m) {
      let min = dec % 60;
      let s = "0" + min.toString();
      res = s.substring(s.length - 2) + "m" + res;
    }
    dec = Math.floor(dec / 60);
    if (format & YDate.h) {
      let hrs = dec % 24;
      let s = "0" + hrs.toString();
      res = s.substring(s.length - 2) + "h" + res;
    }
    dec = Math.floor(dec / 24);
    if (format & YDate.D) {
      let s = dec.toString();
      res = s.substring(s.length - 2) + "d" + res;
    }
    return res;
  }
};
YTimeSpan.TicksPerSecond = 1e3;
var YGraph = class extends YDataRenderer {
  get legendPanel() {
    return this._legendPanel;
  }
  get dataTracker() {
    return this._dataTracker;
  }
  get borderColor() {
    return this._borderColor;
  }
  set borderColor(value) {
    this._borderColor = value;
    this._borderPen = null;
    this.redraw();
  }
  get borderThickness() {
    return this._borderThickness;
  }
  set borderThickness(value) {
    if (value < 0)
      throw new RangeError("thickness must be a positive value");
    this._borderThickness = value;
    this._borderPen = null;
    this.redraw();
  }
  static get verticalDragZoomEnabled() {
    return YGraph._defaultVerticalDragZoomEnabled;
  }
  static set verticalDragZoomEnabled(value) {
    YGraph._defaultVerticalDragZoomEnabled = value;
  }
  static createCaptureCursor() {
    if (YGraph.captureCursor != null)
      return;
    let base64png = "iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAALHRFWHRDcmVhdGlvbiBUaW1lAFRodSAyMCBBdWcgMjAyMCAxMjoxNTo1MCArMDEwMP38NhoAAAAHdElNRQfkCBQOJAvCrm0ZAAAACXBIWXMAAFxGAABcRgEUlENBAAAABGdBTUEAALGPC / xhBQAAAmVJREFUeNrtVrFuFDEQHd9eBImAIBFoAgVC0NJQUFDwL / QgRXzAfUz + Iy0pQwsIJAhCQMQBUS5c2DXv7T5fzN5qs / Fxdw0jPY3ttT3jt54ZmyXIYDDoQXnodWBV / SRJXZhJbwCXov65pZ + 4zklfBsZRf2EMxOuTjc / igIu0s0UygAvnonWZ0NP4fB2QkQz6yHvP / i76V4E1jZ / bic4LIuMnND7ZwDl + u4 / me + AnkKPvu + 7rFMNZBzZ64eRTm5w6sQ8cAcUZexVytOCpOnv7j + QdDD + CHgKjMg80nWpeQrYgd4A3wHjWPJAqN4BVoLcsB1ZMd25ZDkzkvwNLd6AMQ4XGIuXElKz6SAo3rYpLhsZKyyJmwu2WTLiF5g / g2NozIY1 / BkacRwaYkZgUPlr7L2EdeAhjLxpqwTOr0vAHOZG37FPIOO3mfXXG1qEWAGvM + TC6Rydk / KmMv7bmWlD / v95qtaCThGpo1TPsFvp7wBO0v4nBqWoYvR0yOeLFThHmdH4TcgGQy8i + hkn5V / WbSjGr7e9oD96372LJB1o7izbPtYHpPw7V / 8u4yvzFkvPTO3MXuMbx8JRPij8svgAcAw / EwCe0f8XGxZYFB6JQZzl + rHWj1Gf5WZLVTj5py5HbVoXjeF4OuMhYnQHKulW / x6U64CPtbfpVxQu7CX0PeicMov3cKup5EZmw / KwMFNb8pMtl5G3MhIyHkOX3PPUSMmXzOX7Fqsw35Gu5NidEwXWr / jnnD + XUFzLARJRaDXnCQ53o0BpSLzcXzQfAK + Cl9EEwXrKTyr1OWGa3sFnLvPDsn6Tg8P0PrBcSMR2NtfsAAAAASUVORK5CYII =";
    try {
      YGraph.captureCursor = new YCursor(atob(base64png));
    } catch (Exception) {
      console.log("Cannot create custom cursor");
    }
  }
  get dataPanels() {
    return this._dataPanels;
  }
  addDataPanel() {
    let p = new DataPanel(this, this);
    this._dataPanels.push(p);
    return p;
  }
  setMarkerCaptureCallbacks(start, stop) {
    this._markerCaptureStartedCallback = start;
    this._markerCaptureStoppedCallback = stop;
  }
  startMarkerCapture(m) {
    if (this._markerCaptureStartedCallback != null)
      this._markerCaptureStartedCallback(m);
    this.markerCapture = m;
    this.UIContainer.focus();
  }
  constructor(ChartContainer, logFunction) {
    super(ChartContainer, logFunction);
    this._markerCaptureStartedCallback = null;
    this._markerCaptureStoppedCallback = null;
    this.lastPointCount = -1;
    this.lastTopMargin = -1;
    this.lastBottomMargin = -1;
    this.navigatorCache = null;
    this.markerCapture = null;
    this._borderPen = null;
    this._borderColor = YColor.LightGray;
    this._borderThickness = 1;
    this._touchStartfct = null;
    this._touchMovefct = null;
    this._touchEndfct = null;
    this._mouseDownfct = null;
    this._mouseMovefct = null;
    this._mouseWheelfct = null;
    this._mouseKeyDownfct = null;
    this.mainViewPort = new ViewPortSettings();
    this._timeRange = null;
    this._bgBrush = null;
    this._bgColor1 = YColor.FromArgb(255, 200, 200, 200);
    this._bgColor2 = YColor.FromArgb(255, 255, 255, 255);
    this._touchStartPinchDistance = -1;
    this._touchStartPinchCenter = new Point(0, 0);
    this._touchStartPinchZoom = 1;
    this._touchStartPinchIRLx = 0;
    this._touchStartPinchRange = 0;
    this.dataTrackerRefreshtimeout = null;
    YGraph.createCaptureCursor();
    this._xAxis = new XAxis(this, this);
    this._yAxes = [];
    this._series = [];
    this._dataPanels = [];
    this._navigator = new Navigator(this, this);
    this._legendPanel = new LegendPanel(this, this);
    this._dataTracker = new DataTracker(this, this);
    this._touchStartfct = (e) => {
      this.TouchStart(this.UIContainer, e);
    };
    this._touchMovefct = (e) => {
      this.TouchMove(this.UIContainer, e);
    };
    this._touchEndfct = (e) => {
      this.TouchEnd(this.UIContainer, e);
    };
    this._mouseDownfct = (e) => {
      this.MouseDown(this.UIContainer, e);
    };
    this._mouseMovefct = (e) => {
      this.MouseMove(this.UIContainer, e);
    };
    this._mouseWheelfct = (e) => {
      this.mouseWheelEvent(this.UIContainer, e);
    };
    this._mouseKeyDownfct = (e) => {
      this.KeyDown(this.UIContainer, e);
    };
    this.UIContainer.addEventListener("touchstart", this._touchStartfct);
    this.UIContainer.addEventListener("touchmove", this._touchMovefct);
    this.UIContainer.addEventListener("touchend", this._touchEndfct);
    this.UIContainer.addEventListener("mousedown", this._mouseDownfct);
    this.UIContainer.addEventListener("mousemove", this._mouseMovefct);
    this.UIContainer.addEventListener("wheel", this._mouseWheelfct);
    this.UIContainer.addEventListener("keydown", this._mouseKeyDownfct);
    this._timeRange = MinMaxHandler.DefaultValue();
    let originalContainerWidth = ChartContainer.width;
    let originalContainerHeight = ChartContainer.height;
    let originalFormWidth = ChartContainer.width;
    let originalFormHeight = ChartContainer.height;
  }
  destroy() {
    if (this._touchStartfct != null)
      this.UIContainer.removeEventListener("touchstart", this._touchStartfct);
    if (this._touchMovefct != null)
      this.UIContainer.removeEventListener("touchstart", this._touchMovefct);
    if (this._touchEndfct != null)
      this.UIContainer.removeEventListener("touchstart", this._touchEndfct);
    if (this._mouseDownfct != null)
      this.UIContainer.removeEventListener("mousedown", this._mouseDownfct);
    if (this._mouseMovefct != null)
      this.UIContainer.removeEventListener("mousemove", this._mouseMovefct);
    if (this._mouseWheelfct != null)
      this.UIContainer.removeEventListener("wheel", this._mouseWheelfct);
    if (this._mouseKeyDownfct != null)
      this.UIContainer.removeEventListener("keydown", this._mouseKeyDownfct);
    super.destroy();
    Object.entries(this).forEach((pair) => {
      Reflect.set(this, pair[0], null);
    });
  }
  getMostRecentPoint() {
    let res = new pointXY(NaN, NaN);
    for (let i = 0; i < this._series.length; i++)
      if (!this.series[i].disabled) {
        let p = this.series[i].getlastPoint();
        if (!isNaN(p.x)) {
          if (isNaN(res.x))
            res = p;
          else if (p.x > res.x)
            res = p;
        }
      }
    return res;
  }
  adjustGlobalTimeRange(x) {
    let max = this._timeRange.Max;
    this._timeRange = MinMaxHandler.CombineWithNumber(this._timeRange, x);
    if (isNaN(max))
      return;
    let ofset = x - max;
    if (ofset > 0) {
      switch (this._xAxis.overflowHandling) {
        case XAxis.OverflowHandling.SCROLL:
          if (max > this._xAxis.min + (this._xAxis.max - this._xAxis.min) * 0.85 && max <= this._xAxis.max) {
            this.DisableRedraw();
            this._xAxis.set_minMax(this._xAxis.min + ofset, this._xAxis.max + ofset);
            this.AllowRedraw();
          }
          break;
        case XAxis.OverflowHandling.CONTRACT:
          if (max > this._xAxis.min + (this._xAxis.max - this._xAxis.min) * 0.95 && max <= this._xAxis.max) {
            this.DisableRedraw();
            this._xAxis.max += ofset;
            this.AllowRedraw();
          }
          break;
      }
    }
  }
  get bgColor1() {
    return this._bgColor1;
  }
  set bgColor1(value) {
    this._bgColor1 = value;
    this._bgBrush = null;
    this.redraw();
  }
  get bgColor2() {
    return this._bgColor2;
  }
  set bgColor2(value) {
    this._bgColor2 = value;
    this._bgBrush = null;
    this.redraw();
  }
  get xAxis() {
    return this._xAxis;
  }
  get navigator() {
    return this._navigator;
  }
  get yAxes() {
    return this._yAxes;
  }
  get series() {
    return this._series;
  }
  addYAxis() {
    let s = new YAxis(this, this, this._yAxes.length);
    this._yAxes.push(s);
    this.redraw();
    return s;
  }
  addSerie() {
    let s = new DataSerie(this);
    this._series.push(s);
    this.redraw();
    return s;
  }
  clearCachedObjects() {
    this._bgBrush = null;
    this.navigatorCache = null;
  }
  TouchStart(sender, e) {
    if (e.touches.length == 1) {
      this.HandleMouseDown(sender, e.touches[0].pageX, e.touches[0].pageY);
    } else if (e.touches.length == 2) {
      e.preventDefault();
      this.HandleEndOfMouseCapture();
      this._touchStartPinchDistance = Math.sqrt(Math.pow(e.touches[1].pageX - e.touches[0].pageX, 2) + Math.pow(e.touches[1].pageY - e.touches[0].pageY, 2));
      this._touchStartPinchCenter = new Point(e.touches[1].pageX + e.touches[0].pageX >> 2, e.touches[1].pageY + e.touches[0].pageY >> 2);
      this._touchStartPinchZoom = this.mainViewPort.zoomx;
      this._touchStartPinchIRLx = this.mainViewPort.IRLx;
      this._touchStartPinchRange = this._xAxis.max - this._xAxis.min;
    }
  }
  MouseDown(sender, e) {
    if (e.buttons == 2 && this.markerCapture != null) {
      this.markerCapture = null;
      if (this._markerCaptureStoppedCallback != null)
        this._markerCaptureStoppedCallback(null);
    }
    if (e.buttons != 1)
      return;
    this.HandleMouseDown(sender, e.pageX, e.pageY);
  }
  HandleMouseDown(sender, pageX, pageY) {
    let p = this.Scr2ElmMatrix.multiplyByV(Vector3.FromXYCoord(pageX, pageY)).toPoint();
    let eX = p.X;
    let eY = p.Y;
    if (eX >= this.mainViewPort.Lmargin && eX <= this.mainViewPort.Width - this.mainViewPort.Rmargin && eY >= this.mainViewPort.Tmargin && eY <= this.mainViewPort.Height - this.mainViewPort.Bmargin) {
      if (this.markerCapture != null) {
        let p22 = YGraph.ViewPortPointToIRL(this.mainViewPort, new Point(eX, eY));
        this.markerCapture.setCapturedPosition(p22.x, this.xAxis);
        if (this._markerCaptureStoppedCallback != null)
          this._markerCaptureStoppedCallback(this.markerCapture);
        this.markerCapture = null;
        return;
      }
      let p2 = YGraph.ViewPortPointToIRL(this.mainViewPort, new Point(eX, eY));
      this.mainViewPort.OriginalXAxisMin = this.xAxis.min;
      this.mainViewPort.OriginalXAxisMax = this.xAxis.max;
      this.mainViewPort.OriginalIRLx = this.mainViewPort.IRLx;
      this.mainViewPort.OriginalLmargin = this.mainViewPort.Lmargin;
      this.mainViewPort.OriginalZoomx = this.mainViewPort.zoomx;
      this.mainViewPort.CaptureStartY = eY;
      this.mainViewPort.IRLCaptureStartX = p2.x;
      this.mainViewPort.Capture = true;
    } else if (eX >= this._navigator.viewport.Lmargin && eX <= this._navigator.viewport.Width - this._navigator.viewport.Rmargin && eY >= this._navigator.viewport.Lmargin && eY <= this._navigator.viewport.Height - this._navigator.viewport.Bmargin) {
      let p2 = YGraph.ViewPortPointToIRL(this._navigator.viewport, new Point(eX, eY));
      let p22 = YGraph.ViewPortPointToIRL(this.mainViewPort, new Point(this.mainViewPort.Lmargin, 0));
      let p3 = YGraph.ViewPortPointToIRL(this.mainViewPort, new Point(this.mainViewPort.Width - this.mainViewPort.Rmargin, 0));
      if (p2.x >= p22.x && p2.x <= p3.x) {
        this._navigator.startCapture(p2, this._xAxis.min, this._xAxis.max);
      } else {
        this.DisableRedraw();
        let min = p2.x - (p3.x - p22.x) / 2;
        let max = min + (p3.x - p22.x);
        this._xAxis.set_minMax(min, max);
        this.AllowRedraw();
        this.Draw(0);
      }
    }
  }
  TouchMove(sender, e) {
    if (e.touches.length == 1) {
      e.preventDefault();
      this.HandleMouseMove(sender, e.touches[0].pageX, e.touches[0].pageY);
    } else if (e.touches.length == 2) {
      e.preventDefault();
      let newdistance = Math.sqrt(Math.pow(e.touches[1].pageX - e.touches[0].pageX, 2) + Math.pow(e.touches[1].pageY - e.touches[0].pageY, 2));
      let ZoomFactor = newdistance / this._touchStartPinchDistance;
      let NextZoomX = this._touchStartPinchZoom * ZoomFactor;
      if (NextZoomX > this.mainViewPort.zoomx && NextZoomX > 1e3)
        return;
      let currentRange = this._xAxis.max - this._xAxis.min;
      this.mainViewPort.IRLx = this._touchStartPinchIRLx + (this._touchStartPinchCenter.X - this.mainViewPort.Lmargin) / this._touchStartPinchZoom - (this._touchStartPinchCenter.X - this.mainViewPort.Lmargin) / NextZoomX;
      this._xAxis.set_minMax(this.mainViewPort.IRLx, this.mainViewPort.IRLx + this._touchStartPinchRange / ZoomFactor);
      this.mainViewPort.zoomx = NextZoomX;
      this.redraw();
    }
  }
  TouchEnd(sender, e) {
    this.HandleEndOfMouseCapture();
  }
  MouseMove(sender, e) {
    if (e.buttons != 1 && (this.mainViewPort.Capture || this._navigator.Capture))
      this.HandleEndOfMouseCapture();
    this.HandleMouseMove(sender, e.pageX, e.pageY);
    if (this.dataTracker.enabled) {
      if (this.dataTrackerRefreshtimeout != null)
        clearTimeout(this.dataTrackerRefreshtimeout);
      this.dataTrackerRefreshtimeout = setTimeout(() => {
        this.redraw();
      }, 100);
    }
  }
  HandleEndOfMouseCapture() {
    this.mainViewPort.Capture = false;
    this._navigator.stopCapture();
    if (this._dataTracker.enabled)
      this.redraw();
  }
  HandleMouseMove(sender, pageX, pageY) {
    let p = this.Scr2ElmMatrix.multiplyByV(Vector3.FromXYCoord(pageX, pageY)).toPoint();
    let eX = p.X;
    let eY = p.Y;
    if (this.markerCapture != null) {
      if (eX > this.mainViewPort.Lmargin && eX < this.mainViewPort.Width - this.mainViewPort.Rmargin && eY > this.mainViewPort.Tmargin && eY < this.mainViewPort.Height - this.mainViewPort.Bmargin) {
        if (this.UIContainer.style.cursor != YGraph.captureCursor.handle && this.UIContainer.style.cursor != "crosshair") {
          this.UIContainer.style.cursor = YGraph.captureCursor != null ? YGraph.captureCursor.handle : "crosshair";
        }
      } else if (this.UIContainer.style.cursor != "default")
        this.UIContainer.style.cursor = "default";
    } else if (this.UIContainer.style.cursor != "default")
      this.UIContainer.style.cursor = "default";
    if (this.mainViewPort.Capture) {
      let x1 = this.mainViewPort.OriginalIRLx + (eX - this.mainViewPort.OriginalLmargin) / this.mainViewPort.OriginalZoomx;
      let deltaX = x1 - this.mainViewPort.IRLCaptureStartX;
      let deltaY = eY - this.mainViewPort.CaptureStartY;
      this.DisableRedraw();
      let halfAxisDelta = (this.mainViewPort.OriginalXAxisMax - this.mainViewPort.OriginalXAxisMin) / 2;
      let Axismiddle = (this.mainViewPort.OriginalXAxisMax + this.mainViewPort.OriginalXAxisMin) / 2;
      let deltaCoef = YGraph._defaultVerticalDragZoomEnabled && Math.abs(deltaY) > 10 ? Math.pow(1.01, deltaY) : 1;
      this._xAxis.set_minMax(Axismiddle - halfAxisDelta * deltaCoef - deltaX, Axismiddle + halfAxisDelta * deltaCoef - deltaX);
      this.AllowRedraw();
      this.redraw();
      return;
    }
    if (this._navigator.viewport.Capture) {
      let x1 = this._navigator.viewport.OriginalIRLx + (eX - this._navigator.viewport.OriginalLmargin) / this._navigator.viewport.OriginalZoomx;
      let delta = x1 - this._navigator.viewport.IRLCaptureStartX;
      this.DisableRedraw();
      this._xAxis.set_minMax(this._navigator.viewport.OriginalXAxisMin + delta, this._navigator.viewport.OriginalXAxisMax + delta);
      this.AllowRedraw();
      this.redraw();
      return;
    }
  }
  cross(p) {
  }
  static IRLPointToViewPort(viewport, p, IRLy, zoomy) {
    if (IRLy === void 0) {
      let xx2 = viewport.Lmargin + Math.round((p.x - viewport.IRLx) * viewport.zoomx);
      let yy2 = viewport.Height - viewport.Bmargin - Math.round((p.y - viewport.IRLy) * viewport.zoomy);
      return new Point(xx2 >> 0, yy2 >> 0);
    }
    let xx = viewport.Lmargin + Math.round((p.x - viewport.IRLx) * viewport.zoomx);
    let yy = viewport.Height - viewport.Bmargin - Math.round((p.y - IRLy) * zoomy);
    return new Point(xx >> 0, yy >> 0);
  }
  static IRLPointSummaryToViewPort(viewport, p, IRLy, zoomy) {
    if (IRLy === void 0) {
      let x12 = viewport.Lmargin + Math.round((p.x1 - viewport.IRLx) * viewport.zoomx);
      let ymin2 = viewport.Height - viewport.Bmargin - Math.round((p.ymin - viewport.IRLy) * viewport.zoomy);
      let x22 = viewport.Lmargin + Math.round((p.x2 - viewport.IRLx) * viewport.zoomx);
      let ymax2 = viewport.Height - viewport.Bmargin - Math.round((p.ymax - viewport.IRLy) * viewport.zoomy);
      return new minMaxPoint(x12, ymin2, x22, ymax2);
    }
    let x1 = viewport.Lmargin + Math.round((p.x1 - viewport.IRLx) * viewport.zoomx);
    let ymin = viewport.Height - viewport.Bmargin - Math.round((p.ymin - IRLy) * zoomy);
    let x2 = viewport.Lmargin + Math.round((p.x2 - viewport.IRLx) * viewport.zoomx);
    let ymax = viewport.Height - viewport.Bmargin - Math.round((p.ymax - IRLy) * zoomy);
    return new minMaxPoint(x1, ymin, x2, ymax);
  }
  static ViewPortPointToIRL(viewport, p, IRLy, zoomy) {
    if (IRLy === void 0) {
      return new pointXY(viewport.IRLx + (p.X - viewport.Lmargin) / viewport.zoomx, viewport.IRLy + (+viewport.Height - p.Y - viewport.Bmargin) / viewport.zoomy);
    }
    return new pointXY(viewport.IRLx + (p.X - viewport.Lmargin) / viewport.zoomx, IRLy + (+viewport.Height - p.Y - viewport.Bmargin) / zoomy);
  }
  static FindMinMax(start, end, data, count) {
    let res = MinMaxHandler.DefaultValue();
    if (data[0].x > end)
      return res;
    if (data[count - 1].x < start)
      return res;
    let N1 = 0;
    let N2 = 0;
    let First = 0;
    if (data[0].x < start) {
      N1 = 0;
      N2 = count - 1;
      while (N2 - N1 > 1) {
        let N = N1 + N2 >> 1;
        if (data[N].x > start)
          N2 = N;
        else
          N1 = N;
      }
      First = N1 - 1;
      if (First < 0)
        First = 0;
    }
    let Last = count - 1;
    if (data[Last] === void 0) {
      debugger;
    }
    if (data[Last].x > end) {
      N1 = 0;
      N2 = count - 1;
      while (N2 - N1 > 1) {
        let N = N1 + N2 >> 1;
        if (data[N].x < end)
          N1 = N;
        else
          N2 = N;
      }
      Last = N2 + 1;
      if (Last > count - 1)
        Last = count - 1;
    }
    res.Min = data[First].y;
    res.Max = data[First].y;
    for (let i = First + 1; i <= Last; i++) {
      if (data[i].y < res.Min)
        res.Min = data[i].y;
      if (data[i].y > res.Max)
        res.Max = data[i].y;
    }
    return res;
  }
  resetlegendPens() {
    for (let i = 0; i < this._series.length; i++) {
      this._series[i].resetlegendPen();
    }
  }
  drawLegendPanel(g, viewPortWidth, viewPortHeight, mainViewPort) {
    let verticalRatio = 1.25;
    if (!this._legendPanel.enabled)
      return;
    let legendWidths = new Array(this._series.length);
    let legendHeight = new Array(this._series.length);
    let ofsetx = new Array(this._series.length);
    let ofsety = new Array(this._series.length);
    let legends = new Array(this._series.length);
    let totalHeight = 0;
    let totalWidth = 0;
    let maxWidth = 0;
    let maxHeight = 0;
    g.TextRenderingHint = YTextRenderingHint.SingleBitPerPixelGridFit;
    g.SetClip(new YRectangle(0, 0, viewPortWidth, viewPortHeight));
    for (let i = 0; i < this._series.length; i++) {
      if (this._series[i].legend != "")
        legends[i] = this._series[i].legend;
      else
        legends[i] = "Series " + (i + 1).toString();
    }
    if (this._legendPanel.position == LegendPanel.Position.TOP || this._legendPanel.position == LegendPanel.Position.BOTTOM) {
      let availableWidth = viewPortWidth - 2 * this._legendPanel.padding + this._legendPanel.borderthickness;
      if (this._legendPanel.overlap)
        availableWidth = availableWidth - mainViewPort.Lmargin - mainViewPort.Rmargin;
      totalHeight = 0;
      let xx = 0;
      let yy = 0;
      for (let i = 0; i < this._series.length; i++) {
        if (this._series[i].segments.length > 0 && this._series[i].visible && !this._series[i].disabled) {
          let ssize = g.MeasureString(legends[i], this._legendPanel.font, 1e5);
          legendHeight[i] = ssize.height + 1;
          let ww = ssize.width + 20;
          if (xx == 0)
            totalHeight += ssize.height;
          if (availableWidth - xx < ww) {
            if (xx == 0) {
              ofsetx[i] = xx;
              ofsety[i] = yy;
              yy += ssize.height;
              if (maxWidth < ww)
                maxWidth = ww;
            } else {
              yy += ssize.height;
              ofsetx[i] = 0;
              ofsety[i] = yy;
              xx = ww;
              totalHeight += ssize.height;
              if (maxWidth < xx)
                maxWidth = xx;
            }
          } else {
            ofsetx[i] = xx;
            ofsety[i] = yy;
            xx += ww;
            if (maxWidth < xx)
              maxWidth = xx;
          }
        }
      }
      if (totalWidth > availableWidth) {
        totalWidth = availableWidth;
      }
    } else {
      let ty = 0;
      for (let i = 0; i < this._series.length; i++) {
        if (this._series[i].segments.length > 0 && this._series[i].visible && !this._series[i].disabled) {
          let ssize = g.MeasureString(legends[i], this._legendPanel.font, 1e5);
          legendWidths[i] = ssize.width + 1;
          if (maxWidth < legendWidths[i] + 20)
            maxWidth = legendWidths[i] + 20;
          legendHeight[i] = ssize.height + 1;
          if (maxHeight < legendHeight[i])
            maxHeight = legendHeight[i];
          ofsetx[i] = 0;
          ofsety[i] = ty;
          ty += ssize.height * verticalRatio;
          totalHeight += i == 0 ? ssize.height : ssize.height * verticalRatio;
        }
      }
    }
    let w = maxWidth + 2 * this._legendPanel.padding + this._legendPanel.borderthickness;
    let h = totalHeight + 2 * this._legendPanel.padding + this._legendPanel.borderthickness;
    let x = 0;
    let y = 0;
    switch (this._legendPanel.position) {
      case LegendPanel.Position.LEFT:
        x = this._legendPanel.horizontalMargin;
        if (!this._legendPanel.overlap) {
          mainViewPort.Lmargin += w + 2 * this.legendPanel.horizontalMargin + this.legendPanel.borderthickness >> 0;
          y = (viewPortHeight - h) / 2;
        } else {
          x += mainViewPort.Lmargin;
          y = mainViewPort.Tmargin + (viewPortHeight - mainViewPort.Tmargin - mainViewPort.Bmargin - h) / 2;
        }
        break;
      case LegendPanel.Position.TOPLEFT:
        x = this._legendPanel.horizontalMargin;
        y = this._legendPanel.verticalMargin;
        if (!this._legendPanel.overlap) {
          mainViewPort.Lmargin += w + 2 * this.legendPanel.horizontalMargin + this.legendPanel.borderthickness >> 0;
        } else {
          x += mainViewPort.Lmargin;
          y += mainViewPort.Tmargin;
        }
        break;
      case LegendPanel.Position.TOP:
        if (!this._legendPanel.overlap) {
          x = (viewPortWidth - w) / 2 - this._legendPanel.horizontalMargin - this._legendPanel.borderthickness;
          y = this._legendPanel.verticalMargin + this._legendPanel.borderthickness;
          mainViewPort.Tmargin += totalHeight + this._legendPanel.verticalMargin + 2 * this._legendPanel.verticalMargin + this._legendPanel.borderthickness >> 0;
        } else {
          x = mainViewPort.Lmargin + (viewPortWidth - mainViewPort.Lmargin - mainViewPort.Rmargin - w) / 2 - this._legendPanel.horizontalMargin - this._legendPanel.borderthickness;
          y = mainViewPort.Tmargin + this._legendPanel.verticalMargin - this._legendPanel.borderthickness;
        }
        break;
      case LegendPanel.Position.TOPRIGHT:
        x = viewPortWidth - this._legendPanel.horizontalMargin - w;
        y = this._legendPanel.verticalMargin;
        if (!this._legendPanel.overlap) {
          mainViewPort.Rmargin += w + 2 * this._legendPanel.horizontalMargin + this._legendPanel.borderthickness >> 0;
        } else {
          x -= mainViewPort.Rmargin;
          y += mainViewPort.Tmargin;
        }
        break;
      case LegendPanel.Position.RIGHT:
        x = viewPortWidth - this._legendPanel.horizontalMargin - w;
        if (!this._legendPanel.overlap) {
          mainViewPort.Rmargin += w + 2 * this._legendPanel.horizontalMargin + this._legendPanel.borderthickness >> 0;
          y = (viewPortHeight - h) / 2;
        } else {
          x -= mainViewPort.Rmargin;
          y = mainViewPort.Tmargin + (viewPortHeight - mainViewPort.Tmargin - mainViewPort.Bmargin - h) / 2;
        }
        break;
      case LegendPanel.Position.BOTTOMRIGHT:
        x = viewPortWidth - this._legendPanel.horizontalMargin - w;
        if (!this._legendPanel.overlap) {
          mainViewPort.Rmargin += w + 2 * this._legendPanel.horizontalMargin + this._legendPanel.borderthickness >> 0;
          y = viewPortHeight - this._legendPanel.verticalMargin - h;
        } else {
          x -= mainViewPort.Rmargin;
          y = viewPortHeight - mainViewPort.Bmargin - h - this._legendPanel.verticalMargin;
        }
        break;
      case LegendPanel.Position.BOTTOM:
        if (!this._legendPanel.overlap) {
          x = (viewPortWidth - w) / 2 - this._legendPanel.horizontalMargin - this._legendPanel.borderthickness;
          y = viewPortHeight - this._legendPanel.verticalMargin - 2 * this._legendPanel.padding - this._legendPanel.borderthickness - totalHeight;
          mainViewPort.Bmargin += totalHeight + 2 * this._legendPanel.padding + 2 * this._legendPanel.verticalMargin + this._legendPanel.borderthickness;
        } else {
          x = mainViewPort.Lmargin + (viewPortWidth - mainViewPort.Lmargin - mainViewPort.Rmargin - w) / 2 - this._legendPanel.horizontalMargin - this._legendPanel.borderthickness;
          y = viewPortHeight - mainViewPort.Bmargin - totalHeight - 2 * this._legendPanel.padding - 2 * this._legendPanel.verticalMargin - this._legendPanel.borderthickness;
        }
        break;
      case LegendPanel.Position.BOTTOMLEFT:
        x = this._legendPanel.horizontalMargin;
        y = this._legendPanel.verticalMargin;
        if (!this._legendPanel.overlap) {
          mainViewPort.Lmargin += w + 2 * this._legendPanel.horizontalMargin + this._legendPanel.borderthickness;
          y = viewPortHeight - this._legendPanel.verticalMargin - h;
        } else {
          x += mainViewPort.Lmargin;
          y = viewPortHeight - mainViewPort.Bmargin - h - this._legendPanel.verticalMargin;
        }
        break;
    }
    let rect = new YRectangle(x >> 0, y >> 0, w >> 0, h >> 0);
    g.FillRectangle(this._legendPanel.bgBrush, rect);
    g.DrawRectangle(this._legendPanel.pen, rect);
    g.TextRenderingHint = YTextRenderingHint.AntiAlias;
    for (let i = 0; i < this._series.length; i++) {
      if (this._series[i].segments.length > 0 && this._series[i].visible && !this._series[i].disabled) {
        g.DrawStringXY(legends[i], this._legendPanel.font, this._legendPanel.font.brush, x + ofsetx[i] + 20 + this._legendPanel.padding >> 0, y + ofsety[i] + this._legendPanel.padding >> 0);
        let px = x + ofsetx[i] + this._legendPanel.borderthickness / 2 + this._legendPanel.padding + 6 >> 0;
        let py = y + ofsety[i] + this._legendPanel.padding + legendHeight[i] / 2 >> 0;
        g.DrawLine(this._series[i].legendPen, new PointF(px, py), new PointF(px + 12, py));
      }
    }
  }
  static DoSegmentRendering(w, g, p, data, count, xTimeStart, xTimeEnd) {
    if (data[0].x > xTimeEnd || data[count - 1].x < xTimeStart)
      return 0;
    let isSVG = g instanceof YGraphicsSVG;
    let N1 = 0;
    let N2 = 0;
    let First = 0;
    if (data[0].x < xTimeStart) {
      N1 = 0;
      N2 = count - 1;
      while (N2 - N1 > 1) {
        let N = N1 + N2 >> 1;
        if (data[N].x > xTimeStart)
          N2 = N;
        else
          N1 = N;
      }
      First = N1 - 1;
      if (First < 0)
        First = 0;
    }
    let Last = count - 1;
    if (data[Last].x > xTimeEnd) {
      N1 = 0;
      N2 = count - 1;
      while (N2 - N1 > 1) {
        let N = N1 + N2 >> 1;
        if (data[N].x < xTimeEnd)
          N1 = N;
        else
          N2 = N;
      }
      Last = N2 + 1;
      if (Last > count - 1)
        Last = count - 1;
    }
    if (Last - First > 2 * w.Width - w.Lmargin - w.Rmargin) {
      let ToDraw = new Array(3 * (Last - First + 1));
      let Current = YGraph.IRLPointToViewPort(w, data[First]);
      let New;
      let i = First + 1;
      let n = 0;
      let max;
      let min;
      let limit;
      while (i < Last) {
        ToDraw[n++] = new PointF(Current.X, Current.Y);
        min = data[i].y;
        max = min;
        limit = YGraph.ViewPortPointToIRL(w, new Point(Current.X + 1, Current.Y + 1)).x;
        do {
          if (data[i].y > max)
            max = data[i].y;
          if (data[i].y < min)
            min = data[i].y;
          i++;
        } while (i < Last && data[i].x < limit);
        let p1 = YGraph.IRLPointToViewPort(w, new pointXY(data[i].x, min));
        let p2 = YGraph.IRLPointToViewPort(w, new pointXY(data[i].x, max));
        if (Math.abs(p1.Y - p2.Y) > 2) {
          ToDraw[n++] = new PointF(p1.X, p1.Y);
          ToDraw[n++] = new PointF(p2.X, p2.Y);
        }
        Current = YGraph.IRLPointToViewPort(w, data[i]);
      }
      ToDraw[n++] = Current;
      ToDraw = ToDraw.slice(0, n);
      if (n > 1)
        g.DrawLines(p, ToDraw);
      return n;
    } else {
      if (isSVG) {
        let ToDraw = new Array(Last - First + 1);
        for (let i = First; i <= Last; i++) {
          ToDraw[i - First] = YGraph.IRLPointToViewPort(w, data[i]);
        }
        g.DrawLines(p, ToDraw);
      } else {
        for (let i = First; i < Last; i++) {
          g.DrawLine(p, YGraph.IRLPointToViewPort(w, data[i]), YGraph.IRLPointToViewPort(w, data[i + 1]));
        }
      }
    }
    return Last - First;
  }
  static DoSummarySegmentRendering(w, g, p, data, count, finalPoint, xTimeStart, xTimeEnd) {
    let ToDraw = new Array(2 * count + 1);
    let n = 0;
    if (count > 0) {
      if (data[0].x1 > xTimeEnd || data[count - 1].x2 < xTimeStart)
        return 0;
      let isSVG = g instanceof YGraphicsSVG;
      let N1 = 0;
      let N2 = 0;
      let First = 0;
      if (data[0].x1 < xTimeStart) {
        N1 = 0;
        N2 = count - 1;
        while (N2 - N1 > 1) {
          let N = N1 + N2 >> 1;
          if (data[N].x1 > xTimeStart)
            N2 = N;
          else
            N1 = N;
        }
        First = N1 - 1;
        if (First < 0)
          First = 0;
      }
      let Last = count - 1;
      if (data[Last].x2 > xTimeEnd) {
        N1 = 0;
        N2 = count - 1;
        while (N2 - N1 > 1) {
          let N = N1 + N2 >> 1;
          if (data[N].x2 < xTimeEnd)
            N1 = N;
          else
            N2 = N;
        }
        Last = N2 + 1;
        if (Last > count - 1)
          Last = count - 1;
      }
      let Current;
      let New;
      let i = First;
      let max;
      let min;
      let limit;
      Current = YGraph.IRLPointSummaryToViewPort(w, data[i]);
      ToDraw[n++] = new PointF(Current.X1, Current.YMIN);
      let ymin = Current.YMAX;
      let ymax = Current.YMIN;
      let x = Current.X1;
      let buffered = 0;
      while (i <= Last) {
        Current = YGraph.IRLPointSummaryToViewPort(w, data[i]);
        if (ymin > Current.YMAX)
          ymin = Current.YMAX;
        if (ymax < Current.YMIN)
          ymax = Current.YMIN;
        buffered++;
        if (Current.X2 > x) {
          ToDraw[n++] = new PointF(x, ymin);
          if (ymax - ymin > 2)
            ToDraw[n++] = new PointF(x + Current.X2 >> 1, ymax);
          x = Current.X2;
          ymin = Current.YMAX;
          ymax = Current.YMIN;
          buffered = 0;
        }
        i++;
      }
      if (buffered > 0) {
        ToDraw[n++] = new PointF(x, Current.YMIN);
        ToDraw[n++] = new PointF(x + Current.X2 >> 1, Current.YMAX);
      }
    }
    if (finalPoint) {
      let Current = YGraph.IRLPointSummaryToViewPort(w, finalPoint);
      ToDraw[n++] = new PointF(Current.X1, Current.YMIN);
      ToDraw[n++] = new PointF(Current.X2, Current.YMAX);
    }
    if (n > 1) {
      ToDraw = ToDraw.slice(0, n);
      g.DrawLines(p, ToDraw);
    }
    return n;
  }
  DrawYAxisZones(w, g, scale) {
    if (!scale.visible)
      return;
    let Delta = scale.startStopStep.dataMax - scale.startStopStep.dataMin;
    let YZoom = Delta / (w.Height - w.Bmargin - w.Tmargin);
    for (let i = 0; i < scale.zones.length; i++) {
      if (scale.zones[i].visible) {
        let max = scale.zones[i].max;
        let min = scale.zones[i].min;
        if (Number.isNaN(max)) {
          max = scale.startStopStep.dataMax;
        }
        if (Number.isNaN(min))
          min = scale.startStopStep.dataMin;
        if (max < min) {
          let t = max;
          max = min;
          min = t;
        }
        let y0 = w.Height - w.Bmargin - Math.round((max - scale.startStopStep.dataMin) / YZoom) >> 0;
        let h = Math.round((max - min) / YZoom) >> 0;
        g.FillRectangleXYHW(scale.zones[i].zoneBrush, this.mainViewPort.Lmargin, y0, this.mainViewPort.Width - this.mainViewPort.Rmargin - this.mainViewPort.Lmargin + 1, h);
      }
    }
  }
  DrawXAxisZones(w, g, scale) {
    if (!scale.visible)
      return;
    let delta = scale.max - scale.min;
    let XZoom = delta / (w.Width - w.Lmargin - w.Rmargin);
    for (let i = 0; i < scale.zones.length; i++) {
      if (scale.zones[i].visible) {
        let max = scale.zones[i].max;
        let min = scale.zones[i].min;
        if (Number.isNaN(max))
          max = scale.min;
        if (Number.isNaN(min))
          min = scale.max;
        if (max < min) {
          let t = max;
          max = min;
          min = t;
        }
        let x0 = w.Lmargin + Math.round((min - scale.min) / XZoom) >> 0;
        g.FillRectangleXYHW(scale.zones[i].zoneBrush, x0, this.mainViewPort.Tmargin, (max - min) / XZoom >> 0, this.mainViewPort.Height - this.mainViewPort.Tmargin - this.mainViewPort.Bmargin);
      }
    }
  }
  static DrawYAxis(w, g, axis, ofset, simulation) {
    if (!axis.visible) {
      axis.innerWidth = 0;
      return axis.innerWidth;
    }
    let Delta = axis.startStopStep.dataMax - axis.startStopStep.dataMin;
    let YZoom = Delta / (w.Height - w.Bmargin - w.Tmargin);
    let leftSide = axis.position == YAxis.HrzPosition.LEFT;
    let x = leftSide ? w.Lmargin - ofset : w.Width - w.Rmargin + ofset;
    if (!simulation)
      g.DrawLineXY(axis.pen, x, w.Tmargin, x, w.Height - w.Bmargin);
    let format = new YStringFormat(16384);
    format.LineAlignment = 1;
    format.Alignment = leftSide ? 2 : 0;
    let FirstStep = axis.startStopStep.step * Math.floor(axis.startStopStep.start / axis.startStopStep.step);
    if (FirstStep < 0) {
      FirstStep -= axis.startStopStep.step;
    }
    let stepCount = ((Delta - (FirstStep - axis.startStopStep.dataMin)) / axis.startStopStep.step >> 0) + 1;
    if (!simulation)
      g.TextRenderingHint = YTextRenderingHint.AntiAlias;
    let UnitWidth = 0;
    let labelPrecision = 0;
    if (axis.startStopStep.precision < 0)
      labelPrecision = -axis.startStopStep.precision;
    if (stepCount < w.Height) {
      for (let i = 0; i < stepCount; i++) {
        let y = Math.round((FirstStep + i * axis.startStopStep.step - axis.startStopStep.dataMin) / YZoom) >> 0;
        if (y >= 0) {
          y = w.Height - w.Bmargin - y;
          let v = FirstStep + i * axis.startStopStep.step;
          if (!simulation) {
            if (axis.showGrid && (i > 0 || axis.startStopStep.dataMin != 0))
              g.DrawLineXY(axis.gridPen, w.Lmargin, y, w.Width - w.Rmargin, y);
            if (Math.abs(v) < 1e-6 && axis.highlightZero) {
              g.DrawLineXY(axis.pen, w.Lmargin, y, w.Width - w.Rmargin, y);
            }
            g.DrawLineXY(axis.pen, x + (leftSide ? -2 : 2), y, x + (leftSide ? 5 : -5), y);
          }
          let label = v.toFixed(labelPrecision);
          let ssize = g.MeasureString(label, axis.font, 1e5);
          if (ssize.width > UnitWidth)
            UnitWidth = ssize.width;
          if (!simulation) {
            let p = new Point(x + (leftSide ? -3 : 3), y);
            g.DrawStringPF(label, axis.font, axis.font.brush, p, format);
          }
        }
      }
    }
    if (axis.legend.title != "") {
      let size = g.MeasureString(axis.legend.title, axis.legend.font, 1e5);
      if (!simulation) {
        let format2 = new YStringFormat(16384);
        format2.Alignment = 1;
        format2.LineAlignment = 1;
        format2.Trimming = 0;
        let legendX = x + (leftSide ? -UnitWidth - size.height : UnitWidth + size.height + 2) >> 0;
        let legendY = w.Tmargin + (w.Height - w.Tmargin - w.Bmargin) / 2 >> 0;
        g.Transform(legendX, legendY, leftSide ? -Math.PI / 2 : Math.PI / 2);
        g.DrawStringPF(axis.legend.title, axis.legend.font, axis.legend.font.brush, new Point(0, 0), format2);
        g.ResetTransform();
      }
      UnitWidth += size.height;
    }
    axis.innerWidth = (UnitWidth >> 0) + 10;
    return axis.innerWidth;
  }
  DrawMonitorXAxis(w, g, xRange, format) {
    let delta = xRange.Max - xRange.Min;
    let scale = TimeConverter.BestTimeformat(delta, delta, this.xAxis.timeReference);
    let XZoom = delta / (w.Width - w.Lmargin - w.Rmargin);
    let stepCount = (delta / scale.step >> 0) + 2;
    let FirstStep = scale.step * Math.floor(xRange.Min / scale.step);
    if (FirstStep < xRange.Min)
      FirstStep += scale.step;
    g.TextRenderingHint = YTextRenderingHint.AntiAlias;
    let y = w.Height - w.Bmargin;
    g.DrawLineXY(this._navigator.pen, w.Lmargin, w.Height - w.Bmargin - 1, w.Width - w.Rmargin, w.Height - w.Bmargin - 1);
    let label;
    let t = FirstStep;
    do {
      let d = TimeConverter.FromUnixTime(t);
      if (scale.step > 31.1 * 86400) {
        t = TimeConverter.ToUnixTime(new Date(d.getFullYear(), d.getMonth(), 1));
      }
      if (t >= xRange.Min) {
        let x = w.Lmargin + Math.round((t - xRange.Min) / XZoom);
        g.DrawLineXY(this._navigator.pen, x, y, x, y - 4);
        if (format == XAxis.FORMATAUTO) {
          label = TimeConverter.FromUnixTime(t).ToString(scale.format);
        } else {
          label = TimeConverter.FromUnixTime(t).ToString(format);
        }
        let ssize = g.MeasureString(label, this._navigator.font, 1e5);
        g.DrawString(label, this._navigator.font, this._navigator.font.brush, new Point(x - ssize.width / 2, y - ssize.height - 1));
      }
      t += scale.step;
    } while (t < xRange.Max);
  }
  static XLabel(t, scale, scaleFormat, timeRange) {
    let label;
    if (scale.timeReference == TimeConverter.TimeReference.ABSOLUTE) {
      if (scale.labelFormat == XAxis.FORMATAUTO) {
        label = TimeConverter.FromUnixTime(t).ToString(scaleFormat.format);
      } else {
        label = t.toString();
      }
    } else {
      let ticks = YTimeSpan.TicksPerSecond * (Math.round(1e3 * (t - scale.zeroTime)) / 1e3);
      label = ticks < 0 ? "-" + new YTimeSpan(-ticks).toString(scaleFormat.format) : new YTimeSpan(ticks).toString(scaleFormat.format);
    }
    return label;
  }
  DrawXAxis(w, g, scale, simulation) {
    if (w.Width - w.Rmargin - w.Lmargin < 10)
      return 1;
    let stringFormat = new YStringFormat(16384);
    stringFormat.Alignment = 1;
    let bottomSide = scale.position == XAxis.VrtPosition.BOTTOM;
    let y = bottomSide ? w.Height - w.Bmargin : w.Tmargin;
    if (!simulation)
      g.DrawLineXY(scale.pen, w.Lmargin, y, w.Width - w.Rmargin, y);
    let delta = scale.max - scale.min;
    let XZoom = delta / (w.Width - w.Lmargin - w.Rmargin);
    let stepCount = (delta / scale.step >> 0) + 1;
    let FirstStep = 0;
    let timeRange = MinMaxHandler.DefaultValue();
    for (let i = 0; i < this._series.length; i++) {
      if (!this._series[i].disabled) {
        timeRange = MinMaxHandler.Combine(timeRange, this._series[i].timeRange);
      }
    }
    scale.zeroTime = timeRange.Min;
    if (scale.timeReference == TimeConverter.TimeReference.ABSOLUTE) {
      FirstStep = scale.step * Math.floor(scale.min / scale.step);
      timeRange.Min = scale.min;
      timeRange.Max = scale.max;
    } else {
      if (Number.isNaN(timeRange.Min))
        return 0;
      FirstStep = timeRange.Min + scale.step * Math.floor((scale.min - scale.zeroTime) / scale.step);
    }
    if (FirstStep < scale.min)
      FirstStep += scale.step;
    let timeOffset = 0;
    if (scale.timeReference != TimeConverter.TimeReference.ABSOLUTE) {
      timeOffset = FirstStep;
    }
    scale.fullSize = timeRange.Max - timeRange.Min;
    let scaleFormat = scale.bestFormat(timeRange.Max - timeRange.Min, scale.max - scale.min);
    if (!simulation)
      g.TextRenderingHint = YTextRenderingHint.AntiAlias;
    let UnitHeight = 0;
    let label;
    scale.step = scaleFormat.step;
    let t = parseFloat(FirstStep.toString());
    label = YGraph.XLabel(t, scale, scaleFormat, timeRange);
    let ssize = g.MeasureString(label, scale.font, 1e5);
    let mod = 1;
    while (mod * (w.Width - w.Rmargin - w.Lmargin) / stepCount < ssize.width) {
      mod++;
    }
    let steps = Math.round((t - timeOffset) / scale.step) >> 0;
    let previousT = 0;
    do {
      let d = TimeConverter.FromUnixTime(t);
      if (scale.step > 32 * 86400 && scale.timeReference == TimeConverter.TimeReference.ABSOLUTE) {
        if (scale.step >= 365 * 86400) {
          let m = d.getMonth();
          t = TimeConverter.ToUnixTime(new Date(d.getFullYear() + (m > 5 ? 1 : 0), 0, 1));
        } else
          t = TimeConverter.ToUnixTime(new Date(d.getFullYear(), d.getMonth(), 1));
        if (t < previousT) {
          debugger;
        }
      }
      if (t >= scale.min) {
        let x = w.Lmargin + Math.round((t - scale.min) / XZoom) >> 0;
        if (x <= w.Width - w.Rmargin) {
          if (!simulation) {
            if (scale.showGrid)
              g.DrawLineXY(scale.gridPen, x, w.Tmargin, x, w.Height - w.Bmargin);
            g.DrawLineXY(scale.pen, x, y + (bottomSide ? 2 : -2), x, y + (bottomSide ? -5 : 5));
          }
          label = YGraph.XLabel(t, scale, scaleFormat, timeRange);
          ssize = g.MeasureString(label, scale.font, 1e5);
          if (ssize.height > UnitHeight)
            UnitHeight = ssize.height;
          if (!simulation) {
            if (steps % mod == 0) {
              g.DrawStringPF(label, scale.font, scale.font.brush, new PointF(x, y + (bottomSide ? 5 : -ssize.height >> 0) - 2), stringFormat);
            }
          }
        }
      }
      previousT = t;
      t += scale.step;
      if (t < previousT)
        debugger;
      steps++;
    } while (t <= scale.max);
    if (scale.legend.title != "") {
      let size = g.MeasureString(scale.legend.title, scale.legend.font, 1e5);
      if (!simulation) {
        let legendX = w.Lmargin + (w.Width - w.Lmargin - w.Rmargin - size.width) / 2 >> 0;
        let legendY = bottomSide ? w.Height - w.Bmargin + UnitHeight + 5 : w.Tmargin - UnitHeight - size.height * 1.5;
        g.DrawString(scale.legend.title, scale.legend.font, scale.legend.font.brush, new PointF(legendX, legendY));
      }
      UnitHeight += size.height >> 0;
    }
    scale.innerHeight = (UnitHeight >> 0) + 10;
    return scale.innerHeight;
  }
  pixelxSize(mainViewPort, scaleX) {
    let dtime = scaleX.max - scaleX.min;
    let dview = mainViewPort.Width - mainViewPort.Lmargin - mainViewPort.Rmargin;
    if (dview > 0)
      return dtime / dview;
    return 0;
  }
  TimeToAutoSting(t, mainViewPort, scaleX) {
    let strValue = "";
    let dtime = scaleX.max - scaleX.min;
    let months = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
    if (dtime > 0) {
      let pixelSize = this.pixelxSize(mainViewPort, scaleX);
      if (pixelSize > 0) {
        if (scaleX.timeReference == TimeConverter.TimeReference.ABSOLUTE) {
          let date = TimeConverter.FromUnixTime(t);
          let MMMM = months[date.getMonth()];
          let dd = date.getDate().toString();
          let HH = date.getHours().toString();
          if (HH.length < 2)
            HH = "0" + HH;
          let mm = date.getMinutes().toString();
          if (mm.length < 2)
            mm = "0" + mm;
          let ss = date.getSeconds().toString();
          if (ss.length < 2)
            ss = "0" + ss;
          let ff = Math.round(date.getMilliseconds() / 10).toString();
          if (ff.length < 2)
            ff = "0" + ss;
          let f = Math.round(date.getMilliseconds() / 100).toString();
          if (dtime >= 86400)
            strValue += MMMM + " " + dd;
          if (pixelSize < 0.1) {
            strValue += (strValue != "" ? " " : "") + HH + ":" + mm + ":" + ss + "." + ff;
          } else if (pixelSize < 1) {
            strValue += (strValue != "" ? " " : "") + HH + ":" + mm + ":" + ss + "." + f;
          } else if (pixelSize < 60) {
            strValue += (strValue != "" ? " " : "") + HH + ":" + mm + ":" + ss;
          } else if (pixelSize < 3600) {
            strValue += (strValue != "" ? " " : "") + HH + ":" + mm;
          } else if (pixelSize < 86400)
            strValue += (strValue != "" ? " " : "") + HH + "H";
        } else {
          let format = TimeConverter.RelativeFormat(scaleX.fullSize, dtime, pixelSize);
          let ticks = YTimeSpan.TicksPerSecond * (Math.round(100 * (t - scaleX.zeroTime)) / 100);
          strValue += ticks < 0 ? "-" + new YTimeSpan(-ticks).toString(format) : new YTimeSpan(ticks).toString(format);
        }
      }
    }
    return strValue;
  }
  DrawDataTracker(g, viewPortWidth, viewPortHeight, scaleX) {
    if (!this._dataTracker.enabled) {
      return;
    }
    let p = this.mouseLocalPosition();
    if (p == null) {
      return;
    }
    if (p.X <= this.mainViewPort.Lmargin) {
      return;
    }
    if (p.Y <= this.mainViewPort.Tmargin) {
      return;
    }
    if (p.X >= this.UIContainer.width - this.mainViewPort.Rmargin) {
      return;
    }
    if (p.Y >= this.UIContainer.height - this.mainViewPort.Bmargin) {
      return;
    }
    g.SetClip(new YRectangle(0, 0, viewPortWidth, viewPortHeight));
    let DataPoint = YGraph.ViewPortPointToIRL(this.mainViewPort, p);
    let delta = -1;
    let bestindex = -1;
    let bestmatch = new Array(this._series.length);
    let IRLmatch = new Array(this._series.length);
    for (let i = 0; i < this._series.length; i++) {
      if (this._series[i].visible && !this._series[i].disabled) {
        let p2 = this._series[i].findClosestValue(DataPoint.x, false);
        if (p2 != null) {
          IRLmatch[i] = p2;
          bestmatch[i] = YGraph.IRLPointToViewPort(this.mainViewPort, IRLmatch[i], this.yAxes[this._series[i].yAxisIndex].IRLy, this.yAxes[this._series[i].yAxisIndex].zoom);
          if (bestindex < 0 || delta > Math.abs(bestmatch[i].Y - p.Y)) {
            delta = Math.abs(bestmatch[i].Y - p.Y);
            if (this._dataTracker.detectionDistance == 0 || delta <= this._dataTracker.detectionDistance && Math.abs(bestmatch[i].X - p.X) < this._dataTracker.detectionDistance) {
              bestindex = i;
            }
          }
        }
      }
    }
    if (bestindex >= 0) {
      let xx = bestmatch[bestindex].X - this._dataTracker.diameter / 2 >> 0;
      let yy = bestmatch[bestindex].Y - this._dataTracker.diameter / 2 >> 0;
      let dd = this._dataTracker.diameter;
      g.FillEllipse(this._series[bestindex].brush, xx, yy, dd, dd);
      g.DrawEllipse(this._dataTracker.pen, xx, yy, dd, dd);
      let dx;
      let dy;
      if (p.X > this.mainViewPort.Lmargin + (viewPortWidth - this.mainViewPort.Lmargin - this.mainViewPort.Rmargin) / 2)
        dx = -1;
      else
        dx = 1;
      if (p.Y > this.mainViewPort.Tmargin + (viewPortHeight - this.mainViewPort.Tmargin - this.mainViewPort.Bmargin) / 2)
        dy = -1;
      else
        dy = 1;
      let xx2 = bestmatch[bestindex].X + dx * (this._dataTracker.handleLength * 1.5) >> 0;
      let yy2 = bestmatch[bestindex].Y + dy * this._dataTracker.handleLength >> 0;
      g.DrawLineXY(this._dataTracker.pen, bestmatch[bestindex].X + dx * 0.707 * this._dataTracker.diameter / 2 >> 0, bestmatch[bestindex].Y + dy * 0.707 * this._dataTracker.diameter / 2 >> 0, bestmatch[bestindex].X + dx * this._dataTracker.handleLength >> 0, bestmatch[bestindex].Y + dy * this._dataTracker.handleLength >> 0);
      g.DrawLineXY(this._dataTracker.pen, bestmatch[bestindex].X + dx * this._dataTracker.handleLength >> 0, bestmatch[bestindex].Y + dy * this._dataTracker.handleLength >> 0, xx2, yy2);
      let strValue = "";
      if (this._dataTracker.showSerieName)
        strValue += this._series[bestindex].legend + "\r\n";
      if (this._dataTracker.showTimeStamp) {
        let t = IRLmatch[bestindex].x;
        strValue += this.TimeToAutoSting(t, this.mainViewPort, scaleX) + "\r\n";
      }
      if (this._dataTracker.dataPrecision.toString == DataTracker.DataPrecision.PRECISION_NOLIMIT.toString) {
        strValue += IRLmatch[bestindex].y.toString() + this._series[bestindex].unit;
      } else {
        let strvalue = this._dataTracker.dataPrecision.description;
        let precision = -Math.log10(Number(strvalue));
        strValue += IRLmatch[bestindex].y.toFixed(precision) + this._series[bestindex].unit;
      }
      let ssize = g.MeasureString(strValue, this._dataTracker.font, 1e4);
      let labelwidth = ssize.width + 2 * this._dataTracker.padding + this._dataTracker.borderthickness;
      let labelHeight = ssize.height + 2 * this._dataTracker.padding + this._dataTracker.borderthickness;
      if (dx > 0) {
        g.FillRectangleXYHW(this._dataTracker.bgBrush, xx2, yy2 - (labelHeight >> 1), labelwidth, labelHeight);
        g.DrawRectangleXYHW(this._dataTracker.pen, xx2, yy2 - (labelHeight >> 1), labelwidth, labelHeight);
        g.DrawStringXY(strValue, this._dataTracker.font, this._dataTracker.font.brush, xx2 + this._dataTracker.padding >> 0, yy2 - (labelHeight >> 1) + this._dataTracker.padding >> 0);
      } else {
        g.FillRectangleXYHW(this._dataTracker.bgBrush, xx2 - labelwidth, yy2 - (labelHeight >> 1), labelwidth, labelHeight);
        g.DrawRectangleXYHW(this._dataTracker.pen, xx2 - labelwidth, yy2 - (labelHeight >> 1), labelwidth, labelHeight);
        g.DrawStringXY(strValue, this._dataTracker.font, this.dataTracker.font.brush, xx2 + this._dataTracker.padding - labelwidth >> 0, yy2 - (labelHeight >> 1) + this._dataTracker.padding >> 0);
      }
    }
  }
  DrawMarkers(w, g, scaleX, viewPortWidth, viewPortHeight) {
    if (this._xAxis.markers.length == 0)
      return;
    g.SetClip(new YRectangle(w.Lmargin, w.Tmargin, w.Width - w.Rmargin - w.Lmargin, w.Height - w.Bmargin - w.Tmargin));
    let Bottomleft = YGraph.ViewPortPointToIRL(w, new Point(w.Lmargin, w.Height - w.Bmargin));
    let TopRight = YGraph.ViewPortPointToIRL(w, new Point(w.Width - w.Rmargin, w.Tmargin));
    let dy = (w.Height - w.Bmargin - w.Tmargin) / 100;
    let pixelSize = -1;
    g.TextRenderingHint = YTextRenderingHint.AntiAlias;
    for (let i = 0; i < this._xAxis.markers.length; i++) {
      if (this._xAxis.markers[i].enabled) {
        if (pixelSize < 0)
          pixelSize = this.pixelxSize(this.mainViewPort, scaleX);
        let mustdraw = true;
        let xpos = 0;
        if (this._xAxis.markers[i].timereference == TimeConverter.TimeReference.RELATIVE) {
          if (this._xAxis.zeroTime > 0) {
            xpos = this._xAxis.markers[i].xposition + this._xAxis.zeroTime;
          } else {
            mustdraw = false;
          }
        } else {
          xpos = this._xAxis.markers[i].xposition;
        }
        if (xpos > Bottomleft.x - 100 * pixelSize && xpos < TopRight.x + 100 * pixelSize && mustdraw) {
          let p = YGraph.IRLPointToViewPort(w, new pointXY(xpos, 0));
          let xxCenter = p.X >> 0;
          let yyCenter = w.Height - w.Bmargin - this._xAxis.markers[i].yposition * dy >> 0;
          let strValue = this._xAxis.markers[i].text.replace("\\n", "\n");
          let now = new Date();
          if (strValue.indexOf("$") >= 0) {
            if (strValue.indexOf("$MARKERTIME$") >= 0) {
              let s = this._xAxis.markers[i].timereference == TimeConverter.TimeReference.RELATIVE ? TimeConverter.secTimeSpanToString(this._xAxis.markers[i].xposition, pixelSize) : this.TimeToAutoSting(this._xAxis.markers[i].xposition, this.mainViewPort, scaleX);
              strValue = strValue.replace("$MARKERTIME$", s);
            }
            if (strValue.indexOf("$VALUE") >= 0) {
              for (let j = 0; j < this._series.length; j++) {
                if (!this._series[j].disabled) {
                  let pt = this._series[j].findClosestValue(xpos, true);
                  let st = pt != null ? pt.y.toFixed(0) : "--";
                  strValue = strValue.replace("$VALUE" + (j + 1).toString() + "$", st);
                } else {
                  strValue = strValue.replace("$VALUE" + (j + 1).toString() + "$", "");
                }
              }
            }
            if (strValue.indexOf("$UNIT") >= 0) {
              for (let j = 0; j < this._series.length; j++) {
                if (!this._series[j].disabled) {
                  strValue = strValue.replace("$UNIT" + (j + 1).toString() + "$", this._series[j].unit);
                } else {
                  strValue = strValue.replace("$UNIT" + (j + 1).toString() + "$", "");
                }
              }
            }
            if (strValue.indexOf("$LEGEND") >= 0) {
              for (let j = 0; j < this._series.length; j++) {
                if (!this._series[j].disabled) {
                  strValue = strValue.replace("$LEGEND" + (j + 1).toString() + "$", this._series[j].legend);
                } else {
                  strValue = strValue.replace("$LEGEND" + (j + 1).toString() + "$", "");
                }
              }
            }
            if (this._xAxis.markers[i].PatchTextCallback != null) {
              strValue = this._xAxis.markers[i].PatchTextCallback(strValue);
            }
          }
          let ssize = g.MeasureString(strValue, this._xAxis.markers[i].font, 1e4);
          let labelWidth = ssize.width + 2 * this._xAxis.markers[i].padding + this._xAxis.markers[i].borderthickness;
          let labelHeight = ssize.height + 2 * this._xAxis.markers[i].padding + this._xAxis.markers[i].borderthickness;
          g.FillRectangleXYHW(this._xAxis.markers[i].bgBrush, xxCenter - (labelWidth >> 1), yyCenter - (labelHeight >> 1), labelWidth >> 0, labelHeight >> 0);
          g.DrawRectangleXYHW(this._xAxis.markers[i].pen, xxCenter - (labelWidth >> 1), yyCenter - (labelHeight >> 1), labelWidth >> 0, labelHeight >> 0);
          let xText;
          switch (this._xAxis.markers[i].textAlign) {
            case Marker.TextAlign.LEFT:
              xText = xxCenter - (labelWidth >> 1) + this._xAxis.markers[i].padding;
              break;
            case Marker.TextAlign.RIGHT:
              xText = xxCenter + (labelWidth >> 1) - this._xAxis.markers[i].padding;
              break;
            default:
              xText = xxCenter;
              break;
          }
          g.DrawStringPF(strValue, this._xAxis.markers[i].font, this._xAxis.markers[i].font.brush, new PointF(xText, yyCenter), this._xAxis.markers[i].stringFormat);
          g.DrawLineXY(this._xAxis.markers[i].pen, xxCenter, w.Tmargin >> 0, xxCenter, yyCenter - (labelHeight >> 1));
          g.DrawLineXY(this._xAxis.markers[i].pen, xxCenter, yyCenter + (labelHeight >> 1), xxCenter, w.Height - w.Bmargin >> 0);
          if (this._xAxis.markers[i].arrowSize > 0) {
            if (this._xAxis.markers[i].yposition > 25) {
              let triangle = [
                new PointF(xxCenter - this._xAxis.markers[i].arrowSize, yyCenter + (labelHeight >> 1)),
                new PointF(xxCenter + this._xAxis.markers[i].arrowSize, yyCenter + (labelHeight >> 1)),
                new PointF(xxCenter, yyCenter + (labelHeight >> 1) + this._xAxis.markers[i].arrowSize)
              ];
              g.FillPolygon(this._xAxis.markers[i].arrowBrush, triangle);
            }
            if (this._xAxis.markers[i].yposition < 75) {
              let triangle = [
                new PointF(xxCenter - this._xAxis.markers[i].arrowSize, yyCenter + (labelHeight >> 1)),
                new PointF(xxCenter + this._xAxis.markers[i].arrowSize, yyCenter + (labelHeight >> 1)),
                new PointF(xxCenter, yyCenter - (labelHeight >> 1) - this._xAxis.markers[i].arrowSize)
              ];
              g.FillPolygon(this._xAxis.markers[i].arrowBrush, triangle);
            }
          }
        }
      }
    }
    g.ResetClip();
  }
  DrawDataPanels(w, g, scaleX, scalesY, viewPortWidth, viewPortHeight) {
    if (this._dataPanels.length == 0)
      return;
    g.SetClip(new YRectangle(w.Lmargin, w.Tmargin, w.Width - w.Rmargin - w.Lmargin, w.Height - w.Bmargin - w.Tmargin));
    for (let i = 0; i < this._dataPanels.length; i++) {
      if (this._dataPanels[i].enabled) {
        let p = this._dataPanels[i];
        if (p.yScaleIndex < scalesY.length) {
          let AvailableWidth = w.Width - 2 * p.padding - p.borderthickness;
          if (AvailableWidth < 100)
            AvailableWidth = 100;
          let ssize = g.MeasureString(p.text, p.font, AvailableWidth >> 0);
          let panelWidth = ssize.width + 2 * p.padding + p.borderthickness;
          let panelHeight = ssize.height + 2 * p.padding + p.borderthickness;
          let x = 0;
          switch (p.horizontalPosition) {
            case DataPanel.HorizontalPosition.LEFTBORDER:
              x = w.Lmargin;
              break;
            case DataPanel.HorizontalPosition.RIGHTBORDER:
              x = w.Width - w.Rmargin;
              break;
            case DataPanel.HorizontalPosition.ABSOLUTEX:
              let delta = scaleX.max - scaleX.min;
              let XZoom = delta / (w.Width - w.Lmargin - w.Rmargin);
              x = w.Lmargin + Math.round((p.AbsoluteXposition - scaleX.min) / XZoom) >> 0;
              break;
          }
          let y = 0;
          switch (p.verticalPosition) {
            case DataPanel.VerticalPosition.TOPBORDER:
              y = w.Tmargin;
              break;
            case DataPanel.VerticalPosition.BOTTOMBORDER:
              y = w.Height - w.Bmargin;
              break;
            case DataPanel.VerticalPosition.ABSOLUTEY:
              y = w.Height - w.Bmargin - Math.round((p.AbsoluteYposition - scalesY[p.yScaleIndex].IRLy) * scalesY[p.yScaleIndex].zoom) >> 0;
              break;
          }
          switch (p.panelHrzAlign) {
            case DataPanel.HorizontalAlign.LEFTOF:
              x -= panelWidth + p.horizontalMargin;
              break;
            case DataPanel.HorizontalAlign.RIGHTOF:
              x += p.horizontalMargin;
              break;
            default:
              x -= panelWidth / 2;
              break;
          }
          switch (p.panelVrtAlign) {
            case DataPanel.VerticalAlign.ABOVE:
              y -= panelHeight + p.verticalMargin;
              break;
            case DataPanel.VerticalAlign.BELOW:
              y += p.verticalMargin;
              break;
            default:
              y -= panelHeight / 2;
              break;
          }
          g.FillRectangleXYHW(p.bgBrush, x >> 0, y >> 0, panelWidth >> 0, panelHeight >> 0);
          if (p.borderthickness > 0)
            g.DrawRectangleXYHW(p.pen, x >> 0, y >> 0, panelWidth >> 0, panelHeight >> 0);
          let sf = new YStringFormat(16384);
          switch (p.panelTextAlign) {
            case MessagePanel.TextAlign.LEFT:
              sf.LineAlignment = 0;
              sf.Alignment = 0;
              break;
            case MessagePanel.TextAlign.RIGHT:
              sf.LineAlignment = 2;
              sf.Alignment = 2;
              break;
            default:
              sf.LineAlignment = 1;
              sf.Alignment = 1;
              break;
          }
          let rect = new YRectangle(x + p.padding + p.borderthickness / 2 >> 0, y + p.padding + p.borderthickness / 2 >> 0, ssize.width >>= 1, (ssize.height >> 0) + 1);
          g.DrawStringRect(p.text, p.font, p.font.brush, rect, sf);
        } else {
          throw new RangeError("Cannot renderer data panel #" + i.toString() + ", no such Y axis");
        }
      }
    }
  }
  findSegmentIndex(serieIndex, timeStamp, debug) {
    let s = this._series[serieIndex];
    if (s.segments.length <= 0)
      return -1;
    let start = 0;
    let end = s.segments.length - 1;
    if (debug) {
      console.log("looking for " + timeStamp);
      for (let i = 0; i < s.segments.length; i++)
        console.log("seg " + i + " [" + s.segments[i].data[0].x + ".." + s.segments[i].data[s.segments[i].count - 1].x + "]");
      debugger;
    }
    while (true) {
      let startSeg = s.segments[start];
      let endSeg = s.segments[end];
      if (timeStamp > startSeg.data[startSeg.count - 1].x)
        return start - 0.5;
      if (timeStamp < endSeg.data[0].x)
        return end + 0.5;
      if (timeStamp >= startSeg.data[0].x)
        return start;
      if (timeStamp <= endSeg.data[endSeg.count - 1].x)
        return end;
      if (end == start) {
        debugger;
        return -99;
      }
      if (end - start == 1)
        return start + 0.5;
      let middle = start + end >> 1;
      let middleSeg = s.segments[middle];
      if (timeStamp <= middleSeg.data[middleSeg.count - 1].x) {
        end = end - 1;
        start = middle;
      } else {
        end = middle - 1;
        start = start + 1;
      }
    }
  }
  findTimestampIndexInSegment(serieIndex, segmentIndex, timeStamp) {
    let seg = this._series[serieIndex].segments[segmentIndex];
    if (!seg)
      debugger;
    if (timeStamp <= seg.data[0].x)
      return 0;
    let count = this._series[serieIndex].segments[segmentIndex].count;
    if (timeStamp >= seg.data[count - 1].x)
      return count - 1;
    let start = 0;
    let end = count - 1;
    let middle = 0;
    while (true) {
      if (end - start <= 1) {
        if (timeStamp <= seg.data[start].x)
          return start;
        return end;
      }
      middle = start + end >> 1;
      if (timeStamp <= seg.data[middle].x)
        end = middle;
      else
        start = middle;
    }
  }
  Render(g, UIw, UIh) {
    if (UIw < 50 || UIh < 50)
      return 0;
    let lastLmargin = this.mainViewPort.Lmargin;
    let lastRmargin = this.mainViewPort.Rmargin;
    this.mainViewPort.Width = UIw;
    this.mainViewPort.Height = UIh;
    this.mainViewPort.Lmargin = 0;
    this.mainViewPort.Rmargin = 0;
    g.SmoothingMode = YSmoothingMode.HighQuality;
    let yMarginOffset = 5;
    for (let i = 0; i < this._yAxes.length; i++) {
      if (this._yAxes[i].visible) {
        let s = g.MeasureString("8", this._yAxes[i].font, 1e5);
        let o = (s.height + 1) / 2 >> 0;
        if (yMarginOffset < o)
          yMarginOffset = o;
      }
    }
    this.mainViewPort.Tmargin = this._xAxis.position == XAxis.VrtPosition.TOP ? 0 : yMarginOffset;
    this.mainViewPort.Bmargin = this._xAxis.position == XAxis.VrtPosition.BOTTOM ? 0 : yMarginOffset;
    if (!this._legendPanel.overlap)
      this.drawLegendPanel(g, UIw, UIh, this.mainViewPort);
    this.drawAnnotationPanels(g, this._annotationPanels, UIw, UIh, false, this.mainViewPort);
    if (this.mainViewPort.Bmargin == 0)
      this.mainViewPort.Bmargin = 5;
    if (this.mainViewPort.Tmargin == 0)
      this.mainViewPort.Tmargin = 5;
    let h = this.DrawXAxis(this.mainViewPort, g, this._xAxis, true);
    if (this._xAxis.position == XAxis.VrtPosition.TOP)
      this.mainViewPort.Tmargin += h;
    else
      this.mainViewPort.Bmargin += h;
    this.mainViewPort.IRLx = this._xAxis.min;
    let M;
    for (let i = 0; i < this._yAxes.length; i++) {
      M = MinMaxHandler.DefaultValue();
      for (let k = 0; k < this._series.length; k++) {
        if (this._series[k].yAxisIndex == i && !this._series[k].disabled) {
          for (let j = 0; j < this._series[k].segments.length; j++) {
            M = MinMaxHandler.Combine(M, YGraph.FindMinMax(this._xAxis.min, this._xAxis.max, this._series[k].segments[j].data, this._series[k].segments[j].count));
          }
        }
      }
      this._yAxes[i].computeStartAndStep(M);
    }
    if (this.mainViewPort.Lmargin == 0)
      this.mainViewPort.Lmargin = 5;
    if (this.mainViewPort.Rmargin == 0)
      this.mainViewPort.Rmargin = 5;
    for (let i = 0; i < this._yAxes.length; i++) {
      let sw = YGraph.DrawYAxis(this.mainViewPort, g, this._yAxes[i], 0, true);
      this.mainViewPort.Lmargin += this._yAxes[i].position == YAxis.HrzPosition.LEFT ? sw : 0;
      this.mainViewPort.Rmargin += this._yAxes[i].position == YAxis.HrzPosition.RIGHT ? sw : 0;
    }
    if (this._navigator.enabled) {
      if (lastLmargin != this.mainViewPort.Lmargin || lastRmargin != this.mainViewPort.Rmargin) {
        this.navigatorCache = null;
      }
      let nh = this._navigator.relativeheight * this.UIContainer.height / 100 >> 0;
      let ofset = this.xAxis.position == XAxis.VrtPosition.BOTTOM ? h : 0;
      this._navigator.setPosition(UIw, UIh, this.mainViewPort.Lmargin, this.mainViewPort.Rmargin, this.mainViewPort.Height - nh - this.mainViewPort.Bmargin + ofset, this.mainViewPort.Bmargin - ofset);
      this.mainViewPort.Bmargin += nh;
    }
    if (this.lastTopMargin != this.mainViewPort.Tmargin || this.lastBottomMargin != this.mainViewPort.Bmargin) {
      this._bgBrush = null;
      this.lastTopMargin = this.mainViewPort.Tmargin;
      this.lastBottomMargin = this.mainViewPort.Bmargin;
    }
    if (this._bgBrush == null) {
      this._bgBrush = new YLinearGradientBrush(this._bgColor2, this._bgColor1);
    }
    g.FillRectangleXYHW(this._bgBrush, this.mainViewPort.Lmargin, this.mainViewPort.Tmargin, this.mainViewPort.Width - this.mainViewPort.Rmargin - this.mainViewPort.Lmargin, this.mainViewPort.Height - this.mainViewPort.Bmargin - this.mainViewPort.Tmargin);
    if (this._borderThickness > 0) {
      if (this._borderPen == null)
        this._borderPen = new YPen(this._borderColor, this._borderThickness);
      g.DrawRectangleXYHW(this._borderPen, this.mainViewPort.Lmargin, this.mainViewPort.Tmargin, this.mainViewPort.Width - this.mainViewPort.Rmargin - this.mainViewPort.Lmargin, this.mainViewPort.Height - this.mainViewPort.Bmargin - this.mainViewPort.Tmargin);
    }
    g.SetClip(new YRectangle(this.mainViewPort.Lmargin, this.mainViewPort.Tmargin, this.mainViewPort.Width - this.mainViewPort.Rmargin - this.mainViewPort.Lmargin, this.mainViewPort.Height - this.mainViewPort.Bmargin - this.mainViewPort.Tmargin));
    for (let i = 0; i < this._yAxes.length; i++) {
      this.DrawYAxisZones(this.mainViewPort, g, this._yAxes[i]);
    }
    this.DrawXAxisZones(this.mainViewPort, g, this.xAxis);
    g.ResetClip();
    this.DrawXAxis(this.mainViewPort, g, this._xAxis, false);
    let leftOffset = 0;
    let rightOffset = 0;
    for (let i = 0; i < this._yAxes.length; i++) {
      let ww = YGraph.DrawYAxis(this.mainViewPort, g, this._yAxes[i], this._yAxes[i].position == YAxis.HrzPosition.LEFT ? leftOffset : rightOffset, false);
      if (this._yAxes[i].position == YAxis.HrzPosition.LEFT)
        leftOffset += ww;
      if (this._yAxes[i].position == YAxis.HrzPosition.RIGHT)
        rightOffset += ww;
    }
    g.SetClip(new YRectangle(this.mainViewPort.Lmargin, this.mainViewPort.Tmargin, this.mainViewPort.Width - this.mainViewPort.Rmargin - this.mainViewPort.Lmargin, this.mainViewPort.Height - this.mainViewPort.Bmargin - this.mainViewPort.Tmargin));
    this.mainViewPort.zoomx = (this.mainViewPort.Width - this.mainViewPort.Lmargin - this.mainViewPort.Rmargin) / (this._xAxis.max - this._xAxis.min);
    let mypenb = null;
    let lineCount = 0;
    let pointCount = 0;
    let Bottomleft = YGraph.ViewPortPointToIRL(this.mainViewPort, new Point(this.mainViewPort.Lmargin, this.mainViewPort.Height - this.mainViewPort.Bmargin));
    let TopRight = YGraph.ViewPortPointToIRL(this.mainViewPort, new Point(this.mainViewPort.Width - this.mainViewPort.Rmargin, this.mainViewPort.Tmargin));
    let xTimeStart = Bottomleft.x;
    let xTimeEnd = TopRight.x;
    let availabelPixelWidth = this.mainViewPort.Width - this.mainViewPort.Rmargin - this.mainViewPort.Lmargin;
    for (let k = 0; k < this._series.length; k++) {
      if (this._series[k].visible && !this._series[k].disabled && this._series[k].segments.length > 0) {
        let scaleIndex = this._series[k].yAxisIndex;
        mypenb = this._series[k].pen;
        this.mainViewPort.IRLy = this._yAxes[scaleIndex].startStopStep.dataMin;
        this._yAxes[this._series[k].yAxisIndex].IRLy = this.mainViewPort.IRLy;
        let delta = this._yAxes[scaleIndex].startStopStep.dataMax - this._yAxes[scaleIndex].startStopStep.dataMin;
        if (delta == 0) {
          delta = 1;
          this.mainViewPort.IRLy -= delta / 2;
        }
        this.mainViewPort.zoomy = (this.mainViewPort.Height - this.mainViewPort.Tmargin - this.mainViewPort.Bmargin) / delta;
        this._yAxes[this._series[k].yAxisIndex].zoom = this.mainViewPort.zoomy;
        g.comment("** main view-port series " + k.toString());
        let FirstSegmentIndexTmp = this.findSegmentIndex(k, xTimeEnd, false);
        let LastSegmentIndexTmp = this.findSegmentIndex(k, xTimeStart, false);
        let inside = true;
        let maxIndex = this._series[k].segments.length - 1;
        if (FirstSegmentIndexTmp < 0 && LastSegmentIndexTmp < 0) {
          inside = false;
        }
        if (FirstSegmentIndexTmp > maxIndex && LastSegmentIndexTmp > maxIndex) {
          inside = false;
        }
        if (inside) {
          let FirstSegmentIndex = Math.floor(FirstSegmentIndexTmp + 0.5);
          let LastSegmentIndex = Math.floor(LastSegmentIndexTmp);
          if (LastSegmentIndex < 0) {
            throw new Error("findSegmentIndex return an invalid index (" + LastSegmentIndex + ")");
          }
          if (FirstSegmentIndex < 0) {
            throw new Error("findSegmentIndex return an invalid index (" + FirstSegmentIndex + ")!");
          }
          if (FirstSegmentIndex > this._series[k].segments.length - 1) {
            throw new Error("findSegmentIndex return an invalid index (" + FirstSegmentIndex + ")!!");
          }
          if (LastSegmentIndex > this._series[k].segments.length - 1) {
            throw new Error("findSegmentIndex return an invalid index (" + LastSegmentIndex + ")!!!");
          }
          let firstDataIndex = this.findTimestampIndexInSegment(k, FirstSegmentIndex, xTimeEnd);
          let lastDataIndex = this.findTimestampIndexInSegment(k, LastSegmentIndex, xTimeStart);
          let totalPointsToDraw = 0;
          if (FirstSegmentIndex == LastSegmentIndex)
            totalPointsToDraw = firstDataIndex - lastDataIndex;
          else if (FirstSegmentIndex < LastSegmentIndex) {
            totalPointsToDraw = this._series[k].segments[LastSegmentIndex].count - lastDataIndex + firstDataIndex;
            for (let i = FirstSegmentIndex + 1; i < LastSegmentIndex; i++)
              totalPointsToDraw += this._series[k].segments[i].count;
          }
          let density = Math.round(totalPointsToDraw / availabelPixelWidth);
          if (density < SUMMARY_GRANULARITY || SUMMARY_GRANULARITY <= 0) {
            for (let i = 0; i < this._series[k].segments.length; i++) {
              lineCount += YGraph.DoSegmentRendering(this.mainViewPort, g, mypenb, this._series[k].segments[i].data, this._series[k].segments[i].count, xTimeStart, xTimeEnd);
              pointCount += this._series[k].segments[i].count;
            }
          } else {
            let level = Math.floor(Math.log(density) / Math.log(SUMMARY_GRANULARITY)) - 1;
            let s = this._series[k].summaries[level];
            let finalpoint = null;
            for (let i = 0; i < s.segments.length; i++) {
              if (i == s.segments.length - 1) {
                finalpoint = s.getBufferpoint();
              }
              lineCount += YGraph.DoSummarySegmentRendering(this.mainViewPort, g, mypenb, s.segments[i].data, s.segments[i].ptCount, finalpoint, xTimeStart, xTimeEnd);
              pointCount += s.segments[i].ptCount;
            }
          }
        } else
          console.log("Data are ouside dataview");
      }
    }
    g.ResetClip();
    if (this._navigator.enabled) {
      g.comment("** navigator **");
      let v = this._navigator.viewport;
      let range = MinMaxHandler.DefaultValue();
      for (let i = 0; i < this._series.length; i++) {
        if (!this._series[i].disabled)
          range = MinMaxHandler.Combine(range, this._series[i].timeRange);
      }
      this._navigator.Xrange = MinMaxHandler.extend(range, 1.05);
      v.zoomx = (v.Width - v.Lmargin - v.Rmargin) / (this._navigator.Xrange.Max - this._navigator.Xrange.Min);
      if (this.lastPointCount != pointCount && !this.mainViewPort.Capture && !this._navigator.Capture || this.navigatorCache == null || g instanceof YGraphicsSVG) {
        g.comment("Redraw navigator");
        if (this.navigatorCache != null)
          this.navigatorCache = null;
        this.navigatorCache = document.createElement("canvas");
        this.navigatorCache.width = v.Width;
        this.navigatorCache.height = v.Height;
        this.lastPointCount = pointCount;
        let ng;
        if (g instanceof YGraphicsSVG) {
          ng = g;
        } else {
          ng = new YGraphics(this.navigatorCache, v.Width, v.Height, 90);
        }
        ng.SetClip(new YRectangle(v.Lmargin, v.Tmargin, v.Width - v.Rmargin - v.Lmargin, v.Height - v.Bmargin - v.Tmargin));
        ng.FillRectangleXYHW(this._navigator.bgBrush, v.Lmargin, v.Tmargin, v.Width - v.Rmargin - v.Lmargin, v.Height - v.Bmargin - v.Tmargin);
        if (this.xAxis.zones.length > 0 && this._navigator.showXAxisZones) {
          let delta = this._navigator.Xrange.Max - this._navigator.Xrange.Min;
          let XZoom = delta / (v.Width - v.Lmargin - v.Rmargin);
          for (let i = 0; i < this.xAxis.zones.length; i++) {
            if (this.xAxis.zones[i].visible) {
              let min = this.xAxis.zones[i].min;
              let max = this.xAxis.zones[i].max;
              if (isNaN(min))
                min = this._navigator.Xrange.Min;
              if (isNaN(max))
                max = this._navigator.Xrange.Max;
              ng.FillRectangleXYHW(this.xAxis.zones[i].zoneBrush, v.Lmargin + (min - this._navigator.Xrange.Min) / XZoom >> 0, v.Tmargin >> 0, (max - min) / XZoom >> 0, v.Height - v.Bmargin - v.Tmargin);
            }
          }
        }
        if (MinMaxHandler.isDefined(this._navigator.Xrange) && this._navigator.Xrange.Max - this._navigator.Xrange.Min > 0) {
          let Min;
          let Max;
          v.IRLx = this._navigator.Xrange.Min;
          let dontSticktoBorderZoom = 4 / (v.Height - v.Bmargin - v.Tmargin);
          let Bottomleft2 = YGraph.ViewPortPointToIRL(v, new Point(v.Lmargin, v.Height - v.Bmargin));
          let TopRight2 = YGraph.ViewPortPointToIRL(v, new Point(v.Width - v.Rmargin, v.Tmargin));
          let xTimeStart2 = Bottomleft2.x;
          let xTimeEnd2 = TopRight2.x;
          if (this._navigator.yAxisHandling == Navigator.YAxisHandling.AUTO) {
            for (let k = 0; k < this._series.length; k++) {
              if (!this._series[k].disabled) {
                ng.comment("** navigator series " + k.toString());
                v.IRLy = this._series[k].valueRange.Min;
                let yAxisIndex = this._series[k].yAxisIndex;
                mypenb = this._series[k].navigatorpen;
                Min = this._series[k].valueRange.Min;
                Max = this._series[k].valueRange.Max;
                if (Max - Min <= 0) {
                  v.IRLy = Min - 0.5;
                  Max = Min + 0.5;
                } else {
                  let delta = Max - Min;
                  Min -= delta * dontSticktoBorderZoom;
                  Max += delta * dontSticktoBorderZoom;
                }
                v.IRLy = Min;
                v.zoomy = (v.Height - v.Tmargin - v.Bmargin) / (Max - Min);
                let availableWidth = v.Width - v.Lmargin - v.Rmargin;
                let totalPoint = 0;
                for (let i = 0; i < this._series[k].segments.length; i++)
                  totalPoint += this._series[k].segments[i].count;
                let density = Math.round(totalPoint / availableWidth);
                if (density < SUMMARY_GRANULARITY || SUMMARY_GRANULARITY <= 0) {
                  for (let i = 0; i < this._series[k].segments.length; i++) {
                    lineCount += YGraph.DoSegmentRendering(v, ng, mypenb, this._series[k].segments[i].data, this._series[k].segments[i].count, xTimeStart2, xTimeEnd2);
                  }
                } else {
                  let level = Math.floor(Math.log(density) / Math.log(SUMMARY_GRANULARITY)) - 1;
                  let s = this._series[k].summaries[level];
                  let finalpoint = null;
                  for (let i = 0; i < s.segments.length; i++) {
                    if (i == s.segments.length - 1)
                      finalpoint = s.getBufferpoint();
                    lineCount += YGraph.DoSummarySegmentRendering(v, ng, mypenb, s.segments[i].data, s.segments[i].ptCount, finalpoint, xTimeStart2, xTimeEnd2);
                  }
                }
              }
            }
          } else {
            for (let i = 0; i < this._yAxes.length; i++) {
              let Yrange = MinMaxHandler.DefaultValue();
              for (let j = 0; j < this._series.length; j++) {
                if (this._series[j].yAxisIndex == i && !this._series[j].disabled) {
                  Yrange = MinMaxHandler.Combine(Yrange, this._series[j].valueRange);
                }
              }
              Yrange = MinMaxHandler.extend(Yrange, 1 + 2 * dontSticktoBorderZoom);
              Min = this._yAxes[i].min;
              if (isNaN(Min))
                Min = Yrange.Min;
              Max = this._yAxes[i].max;
              if (isNaN(Max))
                Max = Yrange.Max;
              if (Number.isNaN(Min)) {
                Min = 0;
                Max = 1;
              }
              if (Max - Min <= 0) {
                Min = Min - 0.5;
                Max = Min + 0.5;
              }
              v.IRLy = Min;
              v.zoomy = (v.Height - v.Tmargin - v.Bmargin) / (Max - Min);
              for (let j = 0; j < this._series.length; j++) {
                if (this._series[j].yAxisIndex == i && !this._series[j].disabled && this._series[j].visible) {
                  ng.comment("** navigator series " + j.toString());
                  mypenb = this._series[j].navigatorpen;
                  let availableWidth = v.Width - v.Lmargin - v.Rmargin;
                  let totalPoint = 0;
                  for (let i2 = 0; i2 < this._series[j].segments.length; i2++)
                    totalPoint += this._series[j].segments[i2].count;
                  let density = Math.round(totalPoint / availableWidth);
                  if (density < SUMMARY_GRANULARITY || SUMMARY_GRANULARITY <= 0) {
                    for (let i2 = 0; i2 < this._series[j].segments.length; i2++) {
                      lineCount += YGraph.DoSegmentRendering(v, ng, mypenb, this._series[j].segments[i2].data, this._series[j].segments[i2].count, xTimeStart2, xTimeEnd2);
                    }
                  } else {
                    let level = Math.floor(Math.log(density) / Math.log(SUMMARY_GRANULARITY)) - 1;
                    console.log("Navigator (YAXIS=INHERIT), Serie " + j + ", density is ~" + density + "pts/pixel drawing summarized data level " + level);
                    let s = this._series[j].summaries[level];
                    let finalpoint = null;
                    for (let i2 = 0; i2 < s.segments.length; i2++) {
                      if (i2 == s.segments.length - 1)
                        finalpoint = s.getBufferpoint();
                      lineCount += YGraph.DoSummarySegmentRendering(v, ng, mypenb, s.segments[i2].data, s.segments[i2].ptCount, finalpoint, xTimeStart2, xTimeEnd2);
                    }
                  }
                }
              }
            }
          }
          for (let i = 0; i < this._xAxis.markers.length; i++) {
            if (this._xAxis.markers[i].enabled) {
              let p = YGraph.IRLPointToViewPort(v, new pointXY(this._xAxis.markers[i].xposition + (this._xAxis.markers[i].timereference == TimeConverter.TimeReference.RELATIVE ? this._xAxis.zeroTime : 0), 0));
              ng.DrawLineXY(this._xAxis.markers[i].navigatorpen, p.X, v.Tmargin, p.X, v.Height - v.Bmargin);
            }
          }
          if (this._navigator.borderThickness > 0) {
            ng.DrawLineXY(this._navigator.borderPen, v.Lmargin, v.Tmargin, v.Width - v.Rmargin, v.Tmargin);
          }
          this.DrawMonitorXAxis(v, ng, this._navigator.Xrange, this.xAxis.labelFormat);
          this._navigator.setIRLPosition(v.IRLx, v.IRLy, v.zoomx, v.zoomy);
        }
        ng.ResetClip();
        if (!(g instanceof YGraphicsSVG))
          ng.Dispose();
      }
      let cacheW = v.Width - v.Rmargin - v.Lmargin + 1;
      let cacheH = v.Width - v.Rmargin - v.Lmargin + 1;
      let rectsrc = new YRectangle(v.Lmargin, v.Tmargin - 1, cacheW, cacheH);
      let rectdst = new YRectangle(v.Lmargin, v.Tmargin, cacheW, cacheH);
      g.SetClip(rectdst);
      if (!(g instanceof YGraphicsSVG)) {
        g.DrawImage(this.navigatorCache, rectsrc, rectdst, 2);
      }
      if (this._navigator.borderThickness > 0) {
        g.DrawLineXY(this._navigator.borderPen, v.Lmargin + 1, v.Tmargin, v.Lmargin + 1, v.Height - v.Bmargin - 1);
        g.DrawLineXY(this._navigator.borderPen, v.Width - v.Rmargin, v.Tmargin, v.Width - v.Rmargin, v.Height - v.Bmargin - 1);
        g.DrawLineXY(this._navigator.borderPen, v.Lmargin + 1, v.Tmargin, v.Width - v.Rmargin, v.Tmargin);
      }
      let IRLCursorStart = YGraph.ViewPortPointToIRL(this.mainViewPort, new Point(this.mainViewPort.Lmargin, 0));
      let IRLCursorEnd = YGraph.ViewPortPointToIRL(this.mainViewPort, new Point(this.mainViewPort.Width - this.mainViewPort.Rmargin, 0));
      let CursorStart = YGraph.IRLPointToViewPort(this._navigator.viewport, new pointXY(IRLCursorStart.x, 0));
      let CursorEnd = YGraph.IRLPointToViewPort(this._navigator.viewport, new pointXY(IRLCursorEnd.x, 0));
      g.FillRectangle(this._navigator.cursorBrush, new YRectangle(CursorStart.X - 1, v.Tmargin, CursorEnd.X - CursorStart.X + 2, v.Height - v.Bmargin - v.Tmargin - 1));
      g.DrawLineXY(this._navigator.cursorBorderPen, CursorStart.X - 1 >> 0, v.Tmargin >> 0, CursorStart.X - 1 >> 0, v.Height - v.Bmargin - 1);
      g.DrawLineXY(this._navigator.cursorBorderPen, CursorEnd.X + 1 >> 0, v.Tmargin >> 0, CursorEnd.X + 1 >> 0, v.Height - v.Bmargin - 1);
      g.ResetClip();
    }
    if (this._legendPanel.overlap)
      this.drawLegendPanel(g, UIw, UIh, this.mainViewPort);
    g.TextRenderingHint = YTextRenderingHint.SingleBitPerPixelGridFit;
    this.DrawMarkers(this.mainViewPort, g, this.xAxis, UIw, UIh);
    this.drawAnnotationPanels(g, this._annotationPanels, UIw, UIh, true, this.mainViewPort);
    this.DrawDataPanels(this.mainViewPort, g, this.xAxis, this._yAxes, UIw, UIh);
    this.DrawDataTracker(g, UIw, UIh, this.xAxis);
    this.DrawMessagePanels(g, UIw, UIh);
    return 0;
  }
  KeyDown(sender, e) {
    if (e.code == "ArrowLeft") {
      let delta = 0.2 * (this._xAxis.max - this._xAxis.min);
      this._xAxis.set_minMax(this._xAxis.min - delta, this._xAxis.max - delta);
      this.redraw();
    }
    if (e.code == "ArrowRight") {
      let delta = 0.2 * (this._xAxis.max - this._xAxis.min);
      this._xAxis.set_minMax(this._xAxis.min + delta, this._xAxis.max + delta);
      this.redraw();
    }
    if (e.code == "ArrowUp") {
      this.mouseWheel(new Point(this.UIContainer.width >> 1, this.UIContainer.height >> 1), 10);
    }
    if (e.code == "ArrowDown") {
      this.mouseWheel(new Point(this.UIContainer.width >> 1, this.UIContainer.height >> 1), -10);
    }
  }
  mouseWheel(pos, delta) {
    let ZoomFactor = Math.pow(1.25, delta / 120);
    let NextZoomX = this.mainViewPort.zoomx * ZoomFactor;
    if (NextZoomX > this.mainViewPort.zoomx && NextZoomX > 1e3)
      return;
    let currentRange = this._xAxis.max - this._xAxis.min;
    if (currentRange / ZoomFactor > 25 * 365 * 86400)
      return;
    this.mainViewPort.IRLx += (pos.X - this.mainViewPort.Lmargin) / this.mainViewPort.zoomx - (pos.X - this.mainViewPort.Lmargin) / NextZoomX;
    let range = this._xAxis.max - this._xAxis.min;
    this._xAxis.set_minMax(this.mainViewPort.IRLx, this.mainViewPort.IRLx + range / ZoomFactor);
    this.mainViewPort.zoomx = NextZoomX;
    this.redraw();
  }
  mouseWheelEvent(sender, e) {
    let p = this.Scr2ElmMatrix.multiplyByV(Vector3.FromXYCoord(e.pageX, e.pageY)).toPoint();
    let eX = p.X;
    let eY = p.Y;
    this.mouseWheel(new Point(eX, eY), e.deltaY > 0 ? -150 : 150);
    e.preventDefault();
  }
};
YGraph._defaultVerticalDragZoomEnabled = false;
YGraph.captureCursor = null;

// obj/full/Renderer/YSolidGauge.js
var DrawPrameters = class {
  constructor() {
    this.outerRadius = 0;
    this.innerRadius = 0;
    this.angleStart = 0;
    this.angleEnd = 0;
    this.ycenter = 0;
    this.xcenter = 0;
    this.heightTop = 0;
    this.heightBottom = 0;
    this.valueRectangle = new YRectangle(0, 0, 0, 0);
    this.valueFormat = new YStringFormat(16384);
    this.minValueRectangle = new YRectangle(0, 0, 0, 0);
    this.minValueFormat = new YStringFormat(16384);
    this.maxValueRectangle = new YRectangle(0, 0, 0, 0);
    this.maxValueFormat = new YStringFormat(16384);
    this.minValue = "";
    this.maxValue = "";
    this.value = "";
  }
};
var YSolidGauge = class extends YDataRenderer {
  get min() {
    return this._min;
  }
  set min(value) {
    if (value >= this._max && !YDataRenderer.minMaxCheckDisabled) {
      throw new RangeError("Min cannot be greater than max (" + this._max.toString() + ")");
    }
    this._min = value;
    if (this._shownValue < this._min)
      this._shownValue = this._min;
    this.redraw();
  }
  get max() {
    return this._max;
  }
  set max(value) {
    if (value <= this._min && !YDataRenderer.minMaxCheckDisabled) {
      throw new RangeError("Max cannot be less than min (" + this._min.toString() + ")");
    }
    this._max = value;
    if (this._shownValue > this._max)
      this._shownValue = this._max;
    this.redraw();
  }
  get borderpen() {
    if (this._borderpen == null) {
      this._borderpen = new YPen(this._borderColor, this._borderThickness);
      this._borderpen.startCap = 1;
      this._borderpen.endCap = 1;
    }
    return this._borderpen;
  }
  get borderColor() {
    return this._borderColor;
  }
  set borderColor(value) {
    this._borderColor = value;
    this._borderpen = null;
    this.redraw();
  }
  get backgroundColor1() {
    return this._backgroundColor1;
  }
  set backgroundColor1(value) {
    this._backgroundColor1 = value;
    this._bgBrush = null;
    this.redraw();
  }
  get backgroundColor2() {
    return this._backgroundColor2;
  }
  set backgroundColor2(value) {
    this._backgroundColor2 = value;
    this._bgBrush = null;
    this.redraw();
  }
  get borderThickness() {
    return this._borderThickness;
  }
  set borderThickness(value) {
    if (value < 0)
      throw new RangeError("Thickness must be a positive value");
    this._borderThickness = value;
    this._borderpen = null;
    this._path = null;
    this.redraw();
  }
  get valueFormater() {
    return this._valueFormater;
  }
  set valueFormater(value) {
    this._valueFormater = value;
    this.redraw();
  }
  get minmaxFormater() {
    return this._minmaxFormater;
  }
  set minmaxFormater(value) {
    this._minmaxFormater = value;
    this.redraw();
  }
  get thickness() {
    return this._thickness;
  }
  set thickness(value) {
    if (value < 0)
      throw new RangeError("Thickness must be a positive value");
    this._thickness = Math.max(Math.min(value, 80), 1);
    this._path = null;
    this.redraw();
  }
  get maxSpeed() {
    return this._maxSpeed;
  }
  set maxSpeed(value) {
    if (value <= 0)
      throw new RangeError("Speed must be a positive value");
    this._maxSpeed = value;
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value;
    this.redraw();
  }
  get color1() {
    return this._color1;
  }
  set color1(value) {
    this._color1 = value;
    this.redraw();
  }
  get color2() {
    return this._color2;
  }
  set color2(value) {
    this._color2 = value;
    this.redraw();
  }
  get font() {
    return this._font;
  }
  get minMaxFont() {
    return this._minMaxFont;
  }
  get showMinMax() {
    return this._showMinMax;
  }
  set showMinMax(value) {
    this._showMinMax = value;
    this._path = null;
    this.redraw();
  }
  get displayMode() {
    return this._displayMode;
  }
  set displayMode(value) {
    this._displayMode = value;
    this._path = null;
    this._bgBrush = null;
    this.redraw();
  }
  FontsizeChange(source) {
    this._path = null;
  }
  constructor(UIContainer, mode, logFunction) {
    super(UIContainer, logFunction);
    this._shownValue = 0;
    this._min = 0;
    this._max = 100;
    this.SegmentMaxLength = 8;
    this.mainViewPort = new ViewPortSettings();
    this._borderpen = null;
    this._borderColor = YColor.Black;
    this._bgBrush = null;
    this._backgroundColor1 = YColor.FromArgb(255, 240, 240, 240);
    this._backgroundColor2 = YColor.FromArgb(255, 200, 200, 200);
    this._borderThickness = 5;
    this._valueFormater = null;
    this._minmaxFormater = null;
    this._thickness = 25;
    this._maxSpeed = 0.1;
    this._value = 0;
    this._color1 = YColor.Green;
    this._color2 = YColor.Red;
    this._font = null;
    this._minMaxFont = null;
    this._showMinMax = true;
    this._path = null;
    this.lastDrawParameters = new DrawPrameters();
    this._displayMode = YSolidGauge.DisplayMode.DISPLAY90;
    this._minMaxFont = new YFont(this, this, Math.min(UIContainer.width, UIContainer.height) / 15, () => {
      this.FontsizeChange(this._minMaxFont);
    });
    this._displayMode = mode;
    this._font = new YFont(this, this, Math.min(UIContainer.width, UIContainer.height) / 5, null);
    this.resizeRule = Proportional.ResizeRule.RELATIVETOBOTH;
    let g = new YGraphics(UIContainer, UIContainer.width, UIContainer.height, 90);
    let p = this.ComputeDrawParameters(g, UIContainer.width, UIContainer.height, this.mainViewPort);
    g.Dispose();
  }
  clearCachedObjects() {
    this._bgBrush = null;
    this._path = null;
  }
  ComputeDrawParameters(g, UIw, UIh, mainViewPort) {
    UIw -= mainViewPort.Lmargin + mainViewPort.Rmargin;
    UIh -= mainViewPort.Tmargin + mainViewPort.Bmargin;
    let w = UIw - 5 - this._borderThickness;
    let h = UIh - 5 - this._borderThickness;
    let xcenter = UIw / 2;
    let outerRadius = 0;
    let angleStart = 0;
    let angleEnd = 0;
    let ycenter = 0;
    let ValueRectangle = new YRectangle(0, 0, 0, 0);
    let valueFormat = new YStringFormat(16384);
    let innerRadius = 0;
    let minMaxHeight = 0;
    let s1 = new YSizeF(null, "");
    let s2 = new YSizeF(null, "");
    this.lastDrawParameters.value = this._valueFormater == null ? this._value.toFixed(0) : this._valueFormater(this, this._value);
    if (this._showMinMax) {
      this.lastDrawParameters.minValue = this._minmaxFormater == null ? this._min.toFixed(0) : this._minmaxFormater(this, this._min);
      this.lastDrawParameters.maxValue = this._minmaxFormater == null ? this._max.toFixed(0) : this._minmaxFormater(this, this._max);
      s1 = g.MeasureString(this.lastDrawParameters.minValue, this._minMaxFont, 1e5);
      s2 = g.MeasureString(this.lastDrawParameters.maxValue, this._minMaxFont, 1e5);
      this.lastDrawParameters.minValueFormat = new YStringFormat(16384);
      this.lastDrawParameters.maxValueFormat = new YStringFormat(16384);
      minMaxHeight = s1.height;
      if (s2.height > minMaxHeight)
        minMaxHeight = s2.height;
    }
    switch (this._displayMode) {
      case YSolidGauge.DisplayMode.DISPLAY90:
        h = h - minMaxHeight;
        w = w - minMaxHeight;
        outerRadius = w;
        if (outerRadius > h - this._borderThickness)
          outerRadius = h - this.borderThickness;
        if (outerRadius > w - this.borderThickness)
          outerRadius = w - this.borderThickness;
        angleStart = Math.PI / 2;
        angleEnd = Math.PI;
        this.lastDrawParameters.heightTop = outerRadius;
        this.lastDrawParameters.heightBottom = 0;
        ycenter = mainViewPort.Tmargin + h;
        xcenter = mainViewPort.Lmargin + UIw / 2 + outerRadius / 2 - minMaxHeight + this._borderThickness;
        innerRadius = outerRadius * (100 - this._thickness) / 100;
        ValueRectangle = new YRectangle(xcenter - innerRadius >> 0, ycenter - innerRadius >> 0, innerRadius >> 0, innerRadius >> 0);
        valueFormat.Alignment = 2;
        valueFormat.LineAlignment = 2;
        if (this._showMinMax) {
          this.lastDrawParameters.minValueRectangle = new YRectangle(xcenter - (outerRadius + innerRadius + s1.width) / 2 >> 0, ycenter + this._borderThickness >> 0, s1.width + 1 >> 0, minMaxHeight + 1 >> 0);
          this.lastDrawParameters.minValueFormat.Alignment = 0;
          this.lastDrawParameters.minValueFormat.LineAlignment = 0;
          this.lastDrawParameters.maxValueRectangle = new YRectangle(xcenter + this._borderThickness >> 0, ycenter - outerRadius + (outerRadius - innerRadius - s2.width) / 2 >> 0, minMaxHeight + 1 >> 0, s2.width + 1 >> 0);
          this.lastDrawParameters.maxValueFormat.Alignment = 0;
          this.lastDrawParameters.maxValueFormat.LineAlignment = 0;
          this.lastDrawParameters.maxValueFormat.FormatFlags = 2;
        }
        break;
      case YSolidGauge.DisplayMode.DISPLAY180:
        h = h - minMaxHeight;
        let s0 = new YSizeF(null, "");
        s0 = g.MeasureString(this.lastDrawParameters.value, this._font, 1e5);
        outerRadius = w / 2 - this.borderThickness;
        if (outerRadius > h - this._borderThickness)
          outerRadius = h - this._borderThickness;
        if (outerRadius > w - this.borderThickness)
          outerRadius = w - this.borderThickness;
        angleStart = 0;
        angleEnd = Math.PI;
        ycenter = outerRadius + this._borderThickness / 2;
        innerRadius = outerRadius * (100 - this._thickness) / 100;
        this.lastDrawParameters.heightTop = outerRadius;
        this.lastDrawParameters.heightBottom = 0;
        ValueRectangle = new YRectangle(xcenter - innerRadius >> 0, ycenter + this._borderThickness + minMaxHeight - s0.height >> 0, 2 * innerRadius >> 0, s0.height + 1 >> 0);
        valueFormat.Alignment = 1;
        valueFormat.LineAlignment = 2;
        if (this._showMinMax) {
          this.lastDrawParameters.minValueRectangle = new YRectangle(xcenter - (outerRadius + innerRadius + s1.width) / 2 >> 0, ycenter + this._borderThickness >> 0, s1.width + 1 >> 0, minMaxHeight + 1 >> 0);
          this.lastDrawParameters.minValueFormat.Alignment = 0;
          this.lastDrawParameters.minValueFormat.LineAlignment = 0;
          this.lastDrawParameters.maxValueRectangle = new YRectangle(xcenter + (outerRadius + innerRadius - s2.width) / 2 >> 0, ycenter + this._borderThickness >> 0, s2.width + 1 >> 0, minMaxHeight + 1 >> 0);
          this.lastDrawParameters.maxValueFormat.Alignment = 0;
          this.lastDrawParameters.maxValueFormat.LineAlignment = 0;
        }
        break;
      case YSolidGauge.DisplayMode.DISPLAY270:
        outerRadius = w;
        if (outerRadius > h / 2)
          outerRadius = h / 2;
        if (outerRadius > w / 2)
          outerRadius = w / 2;
        this.lastDrawParameters.heightTop = outerRadius;
        this.lastDrawParameters.heightBottom = outerRadius;
        angleStart = 0;
        angleEnd = 3 * Math.PI / 2;
        ycenter = mainViewPort.Tmargin + UIh / 2;
        innerRadius = outerRadius * (100 - this._thickness) / 100;
        ValueRectangle = new YRectangle(xcenter - innerRadius >> 0, ycenter - innerRadius >> 0, 2 * innerRadius >> 0, 2 * innerRadius >> 0);
        valueFormat.Alignment = 1;
        valueFormat.LineAlignment = 1;
        if (this._showMinMax) {
          this.lastDrawParameters.minValueRectangle = new YRectangle(xcenter + this._borderThickness >> 0, ycenter + (innerRadius + innerRadius + s1.height) / 2 >> 0, s1.width + 1 >> 0, s1.height + 1 >> 0);
          this.lastDrawParameters.minValueFormat.Alignment = 0;
          this.lastDrawParameters.minValueFormat.LineAlignment = 0;
          this.lastDrawParameters.maxValueRectangle = new YRectangle(xcenter + (innerRadius + innerRadius + s1.height) / 2 >> 0, ycenter + this._borderThickness >> 0, s2.height + 1 >> 0, s2.width + 1 >> 0);
          this.lastDrawParameters.maxValueFormat.Alignment = 0;
          this.lastDrawParameters.maxValueFormat.LineAlignment = 0;
          this.lastDrawParameters.maxValueFormat.FormatFlags = 2;
        }
        break;
      case YSolidGauge.DisplayMode.DISPLAY360:
        outerRadius = w;
        if (outerRadius > h / 0.85 / 2)
          outerRadius = h / 0.85 / 2;
        if (outerRadius > w / 2)
          outerRadius = w / 2;
        this.lastDrawParameters.heightTop = outerRadius;
        this.lastDrawParameters.heightBottom = outerRadius * 0.7;
        ycenter = mainViewPort.Tmargin + outerRadius + this._borderThickness / 2;
        angleStart = -Math.PI / 4;
        angleEnd = 5 * Math.PI / 4;
        innerRadius = outerRadius * (100 - this._thickness) / 100;
        ValueRectangle = new YRectangle(xcenter - innerRadius >> 0, ycenter - innerRadius >> 0, 2 * innerRadius >> 0, 2 * innerRadius >> 0);
        valueFormat.Alignment = 1;
        valueFormat.LineAlignment = 1;
        if (this._showMinMax) {
          let dx = Math.abs(innerRadius * Math.cos(angleStart));
          let dy = innerRadius * Math.abs(Math.sin(angleStart)) + 2 * Math.abs((outerRadius - innerRadius) * Math.sin(angleStart) / 3);
          this.lastDrawParameters.minValueRectangle = new YRectangle(xcenter - dx >> 0, ycenter + dy - minMaxHeight / 2 >> 0, s1.width + 1 >> 0, minMaxHeight + 1 >> 0);
          this.lastDrawParameters.minValueFormat.Alignment = 0;
          this.lastDrawParameters.minValueFormat.LineAlignment = 1;
          this.lastDrawParameters.maxValueRectangle = new YRectangle(xcenter + dx - s2.width >> 0, ycenter + dy - minMaxHeight / 2 >> 0, s2.width + 1 >> 0, minMaxHeight + 1 >> 0);
          this.lastDrawParameters.maxValueFormat.Alignment = 0;
          this.lastDrawParameters.maxValueFormat.LineAlignment = 1;
        }
        break;
    }
    this.lastDrawParameters.outerRadius = outerRadius;
    this.lastDrawParameters.innerRadius = innerRadius;
    this.lastDrawParameters.angleStart = angleStart;
    this.lastDrawParameters.angleEnd = angleEnd;
    this.lastDrawParameters.ycenter = ycenter;
    this.lastDrawParameters.xcenter = xcenter;
    this.lastDrawParameters.valueRectangle = ValueRectangle;
    this.lastDrawParameters.valueFormat = valueFormat;
    return this.lastDrawParameters;
  }
  Render(g, w, h) {
    this.mainViewPort = new ViewPortSettings();
    g.SmoothingMode = YSmoothingMode.HighQuality;
    g.TextRenderingHint = YTextRenderingHint.AntiAlias;
    this.drawAnnotationPanels(g, this._annotationPanels, w, h, false, this.mainViewPort);
    let p = this.ComputeDrawParameters(g, w, h, this.mainViewPort);
    if (this._path == null) {
      let outterlength = 2 * p.outerRadius * Math.PI * (p.angleEnd - p.angleStart) / (2 * Math.PI);
      let stepCount = outterlength / this.SegmentMaxLength >> 0;
      let stepsize = (p.angleEnd - p.angleStart) / stepCount;
      this._path = new Array(2 * (stepCount + 1));
      let n = 0;
      for (let i = 0; i <= stepCount; i++) {
        let a = p.angleStart + i * stepsize;
        this._path[n++] = new PointF(p.xcenter + p.outerRadius * Math.cos(a), p.ycenter - p.outerRadius * Math.sin(a));
      }
      for (let i = stepCount; i >= 0; i--) {
        let a = p.angleStart + i * stepsize;
        this._path[n++] = new PointF(p.xcenter + p.innerRadius * Math.cos(a), p.ycenter - p.innerRadius * Math.sin(a));
      }
    }
    if (this._bgBrush == null) {
      this._bgBrush = new YLinearGradientBrush(this._backgroundColor1, this._backgroundColor2);
    }
    if (this._borderpen == null) {
      this._borderpen = new YPen(this._borderColor, this._borderThickness);
      this._borderpen.linejoin = YPen.LineJoin.Round;
    }
    g.FillPolygon(this._bgBrush, this._path);
    if (this._shownValue != this._value) {
      let step = this._maxSpeed * (this._max - this._min) / 100;
      if (Math.abs(this._value - this._shownValue) < step) {
        this._shownValue = this._value;
      } else if (this._shownValue < this._value) {
        this._shownValue += step;
      } else {
        this._shownValue -= step;
      }
    }
    let v = this._shownValue;
    if (v >= this._min) {
      if (v > this._max)
        v = this._max;
      let valueFactor = (v - this._min) / (this._max - this.min);
      let angleValue = p.angleStart + (p.angleEnd - p.angleStart) * valueFactor;
      let outterlength = 2 * p.outerRadius * Math.PI * (angleValue - p.angleStart) / (2 * Math.PI);
      let stepCount = outterlength / this.SegmentMaxLength >> 0;
      let stepsize = (angleValue - p.angleStart) / stepCount;
      let pt = new Array(2 * (stepCount + 1));
      let n = 0;
      for (let i = 0; i <= stepCount; i++) {
        let a = p.angleEnd - i * stepsize;
        pt[n++] = new PointF(p.xcenter + p.outerRadius * Math.cos(a), p.ycenter - p.outerRadius * Math.sin(a));
      }
      for (let i = stepCount; i >= 0; i--) {
        let a = p.angleEnd - i * stepsize;
        pt[n++] = new PointF(p.xcenter + p.innerRadius * Math.cos(a), p.ycenter - p.innerRadius * Math.sin(a));
      }
      let b;
      if (this._color1 == this._color2) {
        b = new YSolidBrush(this._color1);
      } else {
        let A1 = this._color1.alpha;
        let H1 = this._color1.hue;
        let S1 = this._color1.saturation;
        let L1 = this._color1.luminosity;
        let A2 = this._color2.alpha;
        let H2 = this._color2.hue;
        let S2 = this._color2.saturation;
        let L2 = this._color2.luminosity;
        let A = Math.round(A1 + (A2 - A1) * valueFactor) >> 0 & 255;
        let H;
        if (Math.abs(H2 - H1) <= 127) {
          H = H1 + (H2 - H1) * valueFactor >> 0;
        } else {
          H = H1 + 256 + (H2 - H1 + 256) * valueFactor >> 0;
          if (H > 256)
            H -= 256;
        }
        let S = S1 + (S2 - S1) * valueFactor >> 0;
        let L = L1 + (L2 - L1) * valueFactor >> 0;
        b = new YSolidBrush(new YColor(true, A, H, S, L));
      }
      g.FillPolygon(b, pt);
    }
    if (this._borderThickness > 0)
      g.DrawPolygon(this._borderpen, this._path);
    g.DrawStringRect(this.lastDrawParameters.value, this._font, this._font.brush, p.valueRectangle, p.valueFormat);
    if (this._showMinMax) {
      g.DrawStringRect(this.lastDrawParameters.minValue, this._minMaxFont, this._minMaxFont.brush, this.lastDrawParameters.minValueRectangle, this.lastDrawParameters.minValueFormat);
      g.DrawStringRect(this.lastDrawParameters.maxValue, this._minMaxFont, this._minMaxFont.brush, this.lastDrawParameters.maxValueRectangle, this.lastDrawParameters.maxValueFormat);
    }
    this.drawAnnotationPanels(g, this._annotationPanels, w, h, true, this.mainViewPort);
    this.DrawMessagePanels(g, w, h);
    return 0;
  }
  renderingPostProcessing() {
    if (this._shownValue != this._value)
      this.redraw();
  }
};
(function(YSolidGauge2) {
  class DisplayModeEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, DisplayMode);
    }
  }
  YSolidGauge2.DisplayModeEnumItem = DisplayModeEnumItem;
  class DisplayMode extends YEnum {
  }
  DisplayMode.DISPLAY90 = new DisplayModeEnumItem("DISPLAY90", "90\xB0");
  DisplayMode.DISPLAY180 = new DisplayModeEnumItem("DISPLAY180", "180\xB0");
  DisplayMode.DISPLAY270 = new DisplayModeEnumItem("DISPLAY270", "270\xB0");
  DisplayMode.DISPLAY360 = new DisplayModeEnumItem("DISPLAY360", "360\xB0");
  YSolidGauge2.DisplayMode = DisplayMode;
})(YSolidGauge || (YSolidGauge = {}));

// obj/full/Api/yocto_api.js
var YAPI_SUCCESS = 0;
var YAPI_INVALID_ARGUMENT = -2;
var YAPI_NOT_SUPPORTED = -3;
var YAPI_DEVICE_NOT_FOUND = -4;
var YAPI_VERSION_MISMATCH = -5;
var YAPI_DEVICE_BUSY = -6;
var YAPI_TIMEOUT = -7;
var YAPI_IO_ERROR = -8;
var YAPI_UNAUTHORIZED = -12;
var YAPI_SSL_UNK_CERT = -20;
var YAPI_INVALID_INT = 2147483647;
var YAPI_INVALID_UINT = -1;
var YAPI_INVALID_LONG = 9223372036854776e3;
var YAPI_INVALID_DOUBLE = -Number.MAX_VALUE;
var YAPI_INVALID_STRING = "!INVALID!";
var YAPI_MIN_DOUBLE = -Number.MAX_VALUE;
var YAPI_MAX_DOUBLE = Number.MAX_VALUE;
var Y_FUNCTIONDESCRIPTOR_INVALID = YAPI_INVALID_STRING;
var Y_DETECT_NONE = 0;
var Y_DETECT_USB = 1;
var Y_DETECT_NET = 2;
var Y_DETECT_ALL = Y_DETECT_USB | Y_DETECT_NET;
var DEFAULT_DEVICE_LIST_VALIDITY_MS = 1e4;
var DEFAULT_NETWORK_TIMEOUT_MS = 2e4;
var YOCTO_CALIB_TYPE_OFS = 30;
var NOTIFY_NETPKT_CONFCHGYDX = "s";
var NOTIFY_NETPKT_FLUSHV2YDX = "t";
var NOTIFY_NETPKT_FUNCV2YDX = "u";
var NOTIFY_NETPKT_TIMEV2YDX = "v";
var NOTIFY_NETPKT_DEVLOGYDX = "w";
var NOTIFY_NETPKT_TIMEVALYDX = "x";
var NOTIFY_NETPKT_FUNCVALYDX = "y";
var NOTIFY_NETPKT_TIMEAVGYDX = "z";
var NOTIFY_NETPKT_STOP = 10;
var NOTIFY_V2_6RAWBYTES = 1;
var NOTIFY_V2_TYPEDDATA = 2;
var PUBVAL_LEGACY = 0;
var PUBVAL_1RAWBYTE = 1;
var PUBVAL_2RAWBYTES = 2;
var PUBVAL_3RAWBYTES = 3;
var PUBVAL_4RAWBYTES = 4;
var PUBVAL_5RAWBYTES = 5;
var PUBVAL_6RAWBYTES = 6;
var PUBVAL_C_LONG = 7;
var PUBVAL_C_FLOAT = 8;
var PUBVAL_YOCTO_FLOAT_E3 = 9;
var YOCTO_PUBVAL_SIZE = 6;
var YOCTO_HASH_BUF_SIZE = 28;
var YOCTO_BASETYPE_FUNCTION = 0;
var YOCTO_BASETYPE_SENSOR = 1;
var Y_BASETYPES = {
  Function: YOCTO_BASETYPE_FUNCTION,
  Sensor: YOCTO_BASETYPE_SENSOR
};
var YErrorMsg = class {
  constructor(msg = "") {
    this.msg = msg;
  }
};
var YoctoError = class extends Error {
  constructor(...params) {
    super(...params);
    this.errorMsg = this.name;
    this.name = "YoctoError";
    if ("captureStackTrace" in Error) {
      Error.captureStackTrace(this, YoctoError);
    }
  }
};
var _YY_UrlInfo = class {
  constructor(str_url) {
    this.orgUrl = str_url;
    let proto = "auto";
    let user = "";
    let pass = "";
    let port = 4444;
    let host;
    let dom = "";
    if (str_url.slice(0, 7) == "http://") {
      proto = "http";
      str_url = str_url.slice(7);
    } else if (str_url.slice(0, 5) == "ws://") {
      proto = "ws";
      str_url = str_url.slice(5);
    } else if (str_url.slice(0, 8) == "https://") {
      proto = "https";
      port = 4443;
      str_url = str_url.slice(8);
    } else if (str_url.slice(0, 6) == "wss://") {
      proto = "wss";
      port = 4443;
      str_url = str_url.slice(6);
    } else if (str_url.slice(0, 7) == "auto://") {
      str_url = str_url.slice(7);
    } else if (str_url.slice(0, 9) == "secure://") {
      str_url = str_url.slice(9);
      port = 4443;
      proto = "secure";
    }
    str_url = str_url.replace("/not.byn", "");
    if (str_url[str_url.length - 1] == "/") {
      str_url = str_url.slice(0, str_url.length - 1);
    }
    let pos = str_url.indexOf("/");
    if (pos > 0) {
      dom = str_url.slice(pos);
      str_url = str_url.slice(0, pos);
    }
    let authpos = str_url.indexOf("@");
    if (authpos >= 0) {
      let auth = str_url.slice(0, authpos);
      let passpos = auth.indexOf(":");
      if (passpos >= 0) {
        user = auth.slice(0, passpos);
        pass = auth.slice(passpos + 1);
      } else {
        user = auth;
      }
      str_url = str_url.slice(authpos + 1);
    }
    let endv6 = str_url.indexOf("]");
    pos = str_url.indexOf(":");
    if (pos > 0 && endv6 > 0 && pos < endv6) {
      pos = str_url.indexOf(":", endv6);
    }
    if (pos < 0) {
      host = str_url;
      if (dom != "") {
        if (proto == "http") {
          port = 80;
        } else if (proto == "https") {
          port = 443;
        }
      }
    } else {
      host = str_url.slice(0, pos);
      port = YAPIContext.imm_atoi(str_url.slice(pos + 1));
    }
    if (host == "callback") {
      port = 4444;
    }
    this.proto = proto;
    this.user = user;
    this.pass = pass;
    this.host = host;
    this.port = port;
    this.domain = dom;
  }
  imm_getHost() {
    return this.host;
  }
  imm_getPass() {
    return this.pass;
  }
  imm_getPort() {
    return this.port;
  }
  imm_getUser() {
    return this.user;
  }
  imm_getUrl(withProto = false, withUserPass = true, withEndSlash = false) {
    if (this.proto == "usb") {
      return "usb";
    }
    let url = "";
    if (withProto) {
      url += this.proto + "://";
    }
    if (withUserPass && this.user != "") {
      url += this.user;
      if (this.pass != "") {
        url += ":";
        url += this.pass;
      }
      url += "@";
    }
    url += this.host;
    url += ":";
    url += this.port;
    url += this.domain;
    if (withEndSlash && url[url.length - 1] != "/") {
      url += "/";
    }
    return url;
  }
  imm_getRootUrl() {
    return this.imm_getUrl(true, false, true);
  }
  imm_getProto() {
    return this.proto;
  }
  imm_useWebSocket() {
    return this.proto.startsWith("ws") || this.proto == "auto" || this.proto == "secure";
  }
  imm_getSubDomain() {
    let dom = this.domain;
    return dom;
  }
  imm_hasAuthParam() {
    return this.user != "";
  }
  imm_useSecureSocket() {
    return this.proto == "wss" || this.proto == "https" || this.proto == "secure";
  }
  imm_testInfoJson() {
    return this.proto == "auto" || this.proto == "secure" || this.proto == "http" || this.proto == "https";
  }
  imm_updateBestProto(proto, port) {
    this.port = port;
    if (this.proto != "http" && this.proto != "https") {
      this.proto = proto;
    }
  }
  imm_updateForRedirect(host, port, is_secure) {
    this.host = host;
    this.port = port;
    if (this.imm_useWebSocket()) {
      this.proto = is_secure ? "wss" : "ws";
    } else {
      this.proto = is_secure ? "https" : "http";
    }
  }
  imm_updatePortInfo(proto, port) {
    this.proto = proto;
    this.port = port;
  }
  imm_getOriginalURL() {
    return this.orgUrl;
  }
  imm_updateFrom(urlInfo) {
    this.proto = urlInfo.proto;
    this.user = urlInfo.user;
    this.pass = urlInfo.pass;
    this.host = urlInfo.host;
    this.port = urlInfo.port;
    this.domain = urlInfo.domain;
    this.orgUrl = urlInfo.orgUrl;
  }
};
var Y_MD5Ctx = class {
  constructor() {
    this.buf = new Uint32Array(4);
    this.bits = new Uint32Array(2);
    this.inBuf = new ArrayBuffer(64);
    this.in8 = new Uint8Array(this.inBuf);
    this.in32 = new Uint32Array(this.inBuf);
    this.in32[0] = 1;
    this.bigEndian = this.in8[0] != 1;
    this.buf[0] = 1732584193 >>> 0;
    this.buf[1] = 4023233417 >>> 0;
    this.buf[2] = 2562383102 >>> 0;
    this.buf[3] = 271733878 >>> 0;
    this.bits[0] = 0;
    this.bits[1] = 0;
  }
  _byteReverseIn() {
    for (let i = 0; i < 16; i++) {
      let a = this.in32[i];
      this.in32[i] = (a >>> 24 | (a & 255) << 24 | (a & 16711680) >>> 8 | (a & 65280) << 8) >>> 0;
    }
  }
  _transform() {
    let F1 = (x, y, z) => (z ^ x & (y ^ z)) >>> 0;
    let F2 = (x, y, z) => F1(z, x, y);
    let F3 = (x, y, z) => (x ^ y ^ z) >>> 0;
    let F4 = (x, y, z) => (y ^ (x | ~z)) >>> 0;
    let MD5STEP = (f, w, x, y, z, data, s) => {
      w = w + f(x, y, z) + (data >>> 0) >>> 0;
      w = (w << s >>> 0 | w >>> 32 - s) >>> 0;
      return w + x >>> 0;
    };
    let a = this.buf[0];
    let b = this.buf[1];
    let c = this.buf[2];
    let d = this.buf[3];
    let dataIn = this.in32;
    a = MD5STEP(F1, a, b, c, d, dataIn[0] + 3614090360, 7);
    d = MD5STEP(F1, d, a, b, c, dataIn[1] + 3905402710, 12);
    c = MD5STEP(F1, c, d, a, b, dataIn[2] + 606105819, 17);
    b = MD5STEP(F1, b, c, d, a, dataIn[3] + 3250441966, 22);
    a = MD5STEP(F1, a, b, c, d, dataIn[4] + 4118548399, 7);
    d = MD5STEP(F1, d, a, b, c, dataIn[5] + 1200080426, 12);
    c = MD5STEP(F1, c, d, a, b, dataIn[6] + 2821735955, 17);
    b = MD5STEP(F1, b, c, d, a, dataIn[7] + 4249261313, 22);
    a = MD5STEP(F1, a, b, c, d, dataIn[8] + 1770035416, 7);
    d = MD5STEP(F1, d, a, b, c, dataIn[9] + 2336552879, 12);
    c = MD5STEP(F1, c, d, a, b, dataIn[10] + 4294925233, 17);
    b = MD5STEP(F1, b, c, d, a, dataIn[11] + 2304563134, 22);
    a = MD5STEP(F1, a, b, c, d, dataIn[12] + 1804603682, 7);
    d = MD5STEP(F1, d, a, b, c, dataIn[13] + 4254626195, 12);
    c = MD5STEP(F1, c, d, a, b, dataIn[14] + 2792965006, 17);
    b = MD5STEP(F1, b, c, d, a, dataIn[15] + 1236535329, 22);
    a = MD5STEP(F2, a, b, c, d, dataIn[1] + 4129170786, 5);
    d = MD5STEP(F2, d, a, b, c, dataIn[6] + 3225465664, 9);
    c = MD5STEP(F2, c, d, a, b, dataIn[11] + 643717713, 14);
    b = MD5STEP(F2, b, c, d, a, dataIn[0] + 3921069994, 20);
    a = MD5STEP(F2, a, b, c, d, dataIn[5] + 3593408605, 5);
    d = MD5STEP(F2, d, a, b, c, dataIn[10] + 38016083, 9);
    c = MD5STEP(F2, c, d, a, b, dataIn[15] + 3634488961, 14);
    b = MD5STEP(F2, b, c, d, a, dataIn[4] + 3889429448, 20);
    a = MD5STEP(F2, a, b, c, d, dataIn[9] + 568446438, 5);
    d = MD5STEP(F2, d, a, b, c, dataIn[14] + 3275163606, 9);
    c = MD5STEP(F2, c, d, a, b, dataIn[3] + 4107603335, 14);
    b = MD5STEP(F2, b, c, d, a, dataIn[8] + 1163531501, 20);
    a = MD5STEP(F2, a, b, c, d, dataIn[13] + 2850285829, 5);
    d = MD5STEP(F2, d, a, b, c, dataIn[2] + 4243563512, 9);
    c = MD5STEP(F2, c, d, a, b, dataIn[7] + 1735328473, 14);
    b = MD5STEP(F2, b, c, d, a, dataIn[12] + 2368359562, 20);
    a = MD5STEP(F3, a, b, c, d, dataIn[5] + 4294588738, 4);
    d = MD5STEP(F3, d, a, b, c, dataIn[8] + 2272392833, 11);
    c = MD5STEP(F3, c, d, a, b, dataIn[11] + 1839030562, 16);
    b = MD5STEP(F3, b, c, d, a, dataIn[14] + 4259657740, 23);
    a = MD5STEP(F3, a, b, c, d, dataIn[1] + 2763975236, 4);
    d = MD5STEP(F3, d, a, b, c, dataIn[4] + 1272893353, 11);
    c = MD5STEP(F3, c, d, a, b, dataIn[7] + 4139469664, 16);
    b = MD5STEP(F3, b, c, d, a, dataIn[10] + 3200236656, 23);
    a = MD5STEP(F3, a, b, c, d, dataIn[13] + 681279174, 4);
    d = MD5STEP(F3, d, a, b, c, dataIn[0] + 3936430074, 11);
    c = MD5STEP(F3, c, d, a, b, dataIn[3] + 3572445317, 16);
    b = MD5STEP(F3, b, c, d, a, dataIn[6] + 76029189, 23);
    a = MD5STEP(F3, a, b, c, d, dataIn[9] + 3654602809, 4);
    d = MD5STEP(F3, d, a, b, c, dataIn[12] + 3873151461, 11);
    c = MD5STEP(F3, c, d, a, b, dataIn[15] + 530742520, 16);
    b = MD5STEP(F3, b, c, d, a, dataIn[2] + 3299628645, 23);
    a = MD5STEP(F4, a, b, c, d, dataIn[0] + 4096336452, 6);
    d = MD5STEP(F4, d, a, b, c, dataIn[7] + 1126891415, 10);
    c = MD5STEP(F4, c, d, a, b, dataIn[14] + 2878612391, 15);
    b = MD5STEP(F4, b, c, d, a, dataIn[5] + 4237533241, 21);
    a = MD5STEP(F4, a, b, c, d, dataIn[12] + 1700485571, 6);
    d = MD5STEP(F4, d, a, b, c, dataIn[3] + 2399980690, 10);
    c = MD5STEP(F4, c, d, a, b, dataIn[10] + 4293915773, 15);
    b = MD5STEP(F4, b, c, d, a, dataIn[1] + 2240044497, 21);
    a = MD5STEP(F4, a, b, c, d, dataIn[8] + 1873313359, 6);
    d = MD5STEP(F4, d, a, b, c, dataIn[15] + 4264355552, 10);
    c = MD5STEP(F4, c, d, a, b, dataIn[6] + 2734768916, 15);
    b = MD5STEP(F4, b, c, d, a, dataIn[13] + 1309151649, 21);
    a = MD5STEP(F4, a, b, c, d, dataIn[4] + 4149444226, 6);
    d = MD5STEP(F4, d, a, b, c, dataIn[11] + 3174756917, 10);
    c = MD5STEP(F4, c, d, a, b, dataIn[2] + 718787259, 15);
    b = MD5STEP(F4, b, c, d, a, dataIn[9] + 3951481745, 21);
    this.buf[0] = (this.buf[0] + a & 4294967295) >>> 0;
    this.buf[1] = (this.buf[1] + b & 4294967295) >>> 0;
    this.buf[2] = (this.buf[2] + c & 4294967295) >>> 0;
    this.buf[3] = (this.buf[3] + d & 4294967295) >>> 0;
  }
  addData(buf) {
    let len = buf.length;
    let pos = 0;
    let t = this.bits[0];
    this.bits[0] = t + (len << 3) >>> 0;
    if (this.bits[0] < t) {
      this.bits[1]++;
    }
    this.bits[1] += len >>> 29;
    t = t >>> 3 & 63;
    while (pos < len) {
      while (pos < len && t < 64) {
        this.in8[t++] = buf[pos++];
      }
      if (t < 64)
        return;
      if (this.bigEndian)
        this._byteReverseIn();
      this._transform();
      t = 0;
    }
  }
  calculate() {
    let t = this.bits[0] >>> 3 & 63;
    this.in8[t++] = 128;
    if (t > 56) {
      while (t < 64) {
        this.in8[t++] = 0;
      }
      if (this.bigEndian)
        this._byteReverseIn();
      this._transform();
      for (t = 0; t < 14; t++) {
        this.in32[t] = 0;
      }
    } else {
      while (t < 56) {
        this.in8[t++] = 0;
      }
      if (this.bigEndian)
        this._byteReverseIn();
    }
    this.in32[14] = this.bits[0];
    this.in32[15] = this.bits[1];
    this._transform();
    let res = new Uint8Array(16);
    for (t = 0; t < 16; t++) {
      res[t] = this.buf[t >>> 2] >>> 8 * (t & 3) & 255;
    }
    return res;
  }
};
var YFunctionType = class {
  constructor(yapi, classname) {
    this._yapi = yapi;
    this._className = classname;
    this._connectedFns = {};
    this._requestedFns = {};
    this._hwIdByName = {};
    this._nameByHwId = {};
    this._valueByHwId = {};
    this._baseType = 0;
  }
  imm_reindexFunction(str_hwid, str_name, str_val, int_basetype) {
    let currname = this._nameByHwId[str_hwid];
    let res = false;
    if (currname == void 0 || currname == "") {
      if (str_name != "") {
        this._nameByHwId[str_hwid] = str_name;
        res = true;
      }
    } else if (currname != str_name) {
      if (this._hwIdByName[currname] == str_hwid) {
        delete this._hwIdByName[currname];
      }
      if (str_name != "") {
        this._nameByHwId[str_hwid] = str_name;
      } else {
        delete this._nameByHwId[str_hwid];
      }
      res = true;
    }
    if (str_name != "") {
      this._hwIdByName[str_name] = str_hwid;
    }
    if (str_val) {
      this._valueByHwId[str_hwid] = str_val;
    } else {
      if (this._valueByHwId[str_hwid] == void 0) {
        this._valueByHwId[str_hwid] = "";
      }
    }
    if (int_basetype) {
      if (this._baseType == 0) {
        this._baseType = int_basetype;
      }
    }
    return res;
  }
  imm_forgetFunction(str_hwid) {
    let currname = this._nameByHwId[str_hwid];
    if (currname != void 0) {
      if (currname != "" && this._hwIdByName[currname] == str_hwid) {
        delete this._hwIdByName[currname];
      }
      delete this._nameByHwId[str_hwid];
    }
    if (this._valueByHwId[str_hwid] != void 0) {
      delete this._valueByHwId[str_hwid];
    }
    let con_fn = this._connectedFns[str_hwid];
    if (con_fn) {
      this._requestedFns[str_hwid] = con_fn;
      delete this._connectedFns[str_hwid];
    }
  }
  imm_resolve(str_func) {
    let res;
    let dotpos = str_func.indexOf(".");
    if (dotpos < 0) {
      res = this._hwIdByName[str_func];
      if (res != void 0) {
        return {
          errorType: YAPI_SUCCESS,
          errorMsg: "no error",
          result: String(res)
        };
      }
      dotpos = str_func.length;
      str_func += "." + this._className.substr(0, 1).toLowerCase() + this._className.substr(1);
    }
    if (this._valueByHwId[str_func] != void 0) {
      return {
        errorType: YAPI_SUCCESS,
        errorMsg: "no error",
        result: String(str_func)
      };
    }
    let serial = "";
    let funcid;
    if (dotpos > 0) {
      let devid = str_func.substr(0, dotpos);
      funcid = str_func.substr(dotpos + 1);
      let dev = this._yapi.imm_getDevice(devid);
      if (!dev) {
        return {
          errorType: YAPI_DEVICE_NOT_FOUND,
          errorMsg: "Device [" + devid + "] not online",
          result: ""
        };
      }
      serial = dev.imm_getSerialNumber();
      res = serial + "." + funcid;
      if (this._valueByHwId[res] != void 0) {
        return {
          errorType: YAPI_SUCCESS,
          errorMsg: "no error",
          result: String(res)
        };
      }
      let i, nfun = dev.imm_functionCount();
      for (i = 0; i < nfun; i++) {
        res = serial + "." + dev.imm_functionId(i);
        let name = this._nameByHwId[res];
        if (name != void 0 && name == funcid) {
          return {
            errorType: YAPI_SUCCESS,
            errorMsg: "no error",
            result: String(res)
          };
        }
      }
    } else {
      funcid = str_func.substr(1);
      for (let hwid_str in this._connectedFns) {
        let pos = hwid_str.indexOf(".");
        let str_function = hwid_str.substr(pos + 1);
        if (str_function == funcid) {
          return {
            errorType: YAPI_SUCCESS,
            errorMsg: "no error",
            result: String(hwid_str)
          };
        }
      }
    }
    return {
      errorType: YAPI_DEVICE_NOT_FOUND,
      errorMsg: "No function [" + funcid + "] found on device [" + serial + "]",
      result: ""
    };
  }
  imm_getFriendlyName(str_func) {
    let resolved = this.imm_resolve(str_func);
    let name;
    if (resolved.errorType != YAPI_SUCCESS) {
      return resolved;
    }
    let hwId = resolved.result;
    if (this._className == "Module") {
      let friend = hwId;
      name = this._nameByHwId[friend];
      if (name != void 0 && name != "") {
        friend = this._nameByHwId[friend];
      }
      return {
        errorType: YAPI_SUCCESS,
        errorMsg: "no error",
        result: String(friend)
      };
    } else {
      let pos = hwId.indexOf(".");
      let str_serialMod = hwId.substr(0, pos);
      let str_friendModFull = this._yapi.imm_getFriendlyNameFunction("Module", str_serialMod).result;
      let int_friendModDot = str_friendModFull.indexOf(".");
      let str_friendMod = int_friendModDot > 0 ? str_friendModFull.substr(0, int_friendModDot) : str_friendModFull;
      let str_friendFunc = hwId.substr(pos + 1);
      name = this._nameByHwId[hwId];
      if (name != void 0 && name != "") {
        str_friendFunc = name;
      }
      return {
        errorType: YAPI_SUCCESS,
        errorMsg: "no error",
        result: String(str_friendMod + "." + str_friendFunc)
      };
    }
  }
  imm_setFunction(str_func, obj_func) {
    let funres = this.imm_resolve(str_func);
    if (funres.result) {
      this._connectedFns[funres.result] = obj_func;
    } else {
      this._requestedFns[str_func] = obj_func;
    }
  }
  imm_getFunction(str_func) {
    let funres = this.imm_resolve(str_func);
    if (funres.errorType == YAPI_SUCCESS) {
      let conn_fn = this._connectedFns[funres.result];
      if (conn_fn != void 0) {
        return conn_fn;
      }
      let req_fn = this._requestedFns[str_func];
      if (req_fn != void 0) {
        this._connectedFns[funres.result] = req_fn;
        delete this._requestedFns[str_func];
      }
      return req_fn;
    } else {
      return this._requestedFns[str_func];
    }
  }
  imm_setFunctionValue(str_hwid, str_pubval) {
    let currval = this._valueByHwId[str_hwid];
    if (!(currval == void 0) && currval == str_pubval) {
      return false;
    }
    this._valueByHwId[str_hwid] = str_pubval;
    return true;
  }
  imm_getFunctionValue(str_hwid) {
    return this._valueByHwId[str_hwid];
  }
  imm_getBaseType() {
    return this._baseType;
  }
  imm_matchBaseType(baseclass) {
    return baseclass == YOCTO_BASETYPE_FUNCTION || baseclass == this._baseType;
  }
  imm_getFirstHardwareId() {
    let res = null;
    for (res in this._valueByHwId) {
      break;
    }
    return res;
  }
  imm_getNextHardwareId(str_hwid) {
    for (let iter_hwid in this._valueByHwId) {
      if (str_hwid == "!") {
        return iter_hwid;
      }
      if (str_hwid == iter_hwid) {
        str_hwid = "!";
      }
    }
    return null;
  }
};
var YHTTPBody = class {
  constructor(str_fname, bin_data, fun_progressCb) {
    this.fname = str_fname;
    this.data = bin_data;
    this.progressCb = fun_progressCb;
  }
};
var YHTTPRequest = class {
  constructor(bin_res, int_errType = YAPI_SUCCESS, str_errMsg = "no error") {
    this.devUrl = null;
    this.obj_result = null;
    this.asyncId = 0;
    this.acceptor = null;
    this.toBeSent = null;
    this.sendPos = 0;
    this.progressCb = null;
    this.timeoutId = null;
    this.sendTimeoutId = null;
    this.next = null;
    this._creat = "";
    this._sent = "";
    this.bin_result = bin_res;
    this.errorType = int_errType;
    this.errorMsg = str_errMsg;
  }
};
var YFuncRequest = class {
  constructor(obj_res, int_errType = YAPI_SUCCESS, str_errMsg = "no error") {
    this.errorType = int_errType;
    this.errorMsg = str_errMsg;
    this.obj_result = obj_res;
  }
};
var YDataStream = class {
  constructor(obj_parent, obj_dataset, encoded) {
    this._runNo = 0;
    this._utcStamp = 0;
    this._nCols = 0;
    this._nRows = 0;
    this._startTime = 0;
    this._duration = 0;
    this._dataSamplesInterval = 0;
    this._firstMeasureDuration = 0;
    this._columnNames = [];
    this._functionId = "";
    this._isClosed = false;
    this._isAvg = false;
    this._minVal = 0;
    this._avgVal = 0;
    this._maxVal = 0;
    this._caltyp = 0;
    this._calpar = [];
    this._calraw = [];
    this._calref = [];
    this._values = [];
    this._isLoaded = false;
    this.DATA_INVALID = YAPI_INVALID_DOUBLE;
    this.DURATION_INVALID = YAPI_INVALID_DOUBLE;
    this._parent = obj_parent;
    this._yapi = this._parent._yapi;
    this.imm_calhdl = null;
    if (typeof obj_dataset != "undefined") {
      this.imm_initFromDataSet(obj_dataset, encoded);
    }
  }
  imm_initFromDataSet(dataset, encoded) {
    let val;
    let i;
    let maxpos;
    let ms_offset;
    let samplesPerHour;
    let fRaw;
    let fRef;
    let iCalib = [];
    this._runNo = encoded[0] + (encoded[1] << 16);
    this._utcStamp = encoded[2] + (encoded[3] << 16);
    val = encoded[4];
    this._isAvg = (val & 256) == 0;
    samplesPerHour = val & 255;
    if ((val & 256) != 0) {
      samplesPerHour = samplesPerHour * 3600;
    } else {
      if ((val & 512) != 0) {
        samplesPerHour = samplesPerHour * 60;
      }
    }
    this._dataSamplesInterval = 3600 / samplesPerHour;
    ms_offset = encoded[6];
    if (ms_offset < 1e3) {
      this._startTime = this._utcStamp + ms_offset / 1e3;
    } else {
      this._startTime = this._utcStamp - this._dataSamplesInterval;
    }
    this._firstMeasureDuration = encoded[5];
    if (!this._isAvg) {
      this._firstMeasureDuration = this._firstMeasureDuration / 1e3;
    }
    val = encoded[7];
    this._isClosed = val != 65535;
    if (val == 65535) {
      val = 0;
    }
    this._nRows = val;
    if (this._nRows > 0) {
      if (this._firstMeasureDuration > 0) {
        this._duration = this._firstMeasureDuration + (this._nRows - 1) * this._dataSamplesInterval;
      } else {
        this._duration = this._nRows * this._dataSamplesInterval;
      }
    } else {
      this._duration = 0;
    }
    iCalib = dataset.imm_get_calibration();
    this._caltyp = iCalib[0];
    if (this._caltyp != 0) {
      this.imm_calhdl = this._yapi.imm_getCalibrationHandler(this._caltyp);
      maxpos = iCalib.length;
      this._calpar.length = 0;
      this._calraw.length = 0;
      this._calref.length = 0;
      i = 1;
      while (i < maxpos) {
        this._calpar.push(iCalib[i]);
        i = i + 1;
      }
      i = 1;
      while (i + 1 < maxpos) {
        fRaw = iCalib[i];
        fRaw = fRaw / 1e3;
        fRef = iCalib[i + 1];
        fRef = fRef / 1e3;
        this._calraw.push(fRaw);
        this._calref.push(fRef);
        i = i + 2;
      }
    }
    this._functionId = dataset.imm_get_functionId();
    if (this._isAvg) {
      this._columnNames.length = 0;
      this._columnNames.push(this._functionId + "_min");
      this._columnNames.push(this._functionId + "_avg");
      this._columnNames.push(this._functionId + "_max");
      this._nCols = 3;
    } else {
      this._columnNames.length = 0;
      this._columnNames.push(this._functionId);
      this._nCols = 1;
    }
    if (this._nRows > 0) {
      this._avgVal = this.imm_decodeAvg(encoded[8] + ((encoded[9] ^ 32768) << 16), 1);
      this._minVal = this.imm_decodeVal(encoded[10] + (encoded[11] << 16));
      this._maxVal = this.imm_decodeVal(encoded[12] + (encoded[13] << 16));
    }
    return 0;
  }
  imm_parseStream(sdata) {
    let idx;
    let udat = [];
    let dat = [];
    if (this._isLoaded && !this._isClosed) {
      return YAPI_SUCCESS;
    }
    if (sdata.length == 0) {
      this._nRows = 0;
      return YAPI_SUCCESS;
    }
    udat = this._yapi.imm_decodeWords(this._parent.imm_json_get_string(sdata));
    this._values.length = 0;
    idx = 0;
    if (this._isAvg) {
      while (idx + 3 < udat.length) {
        dat.length = 0;
        if (udat[idx] == 65535 && udat[idx + 1] == 65535) {
          dat.push(NaN);
          dat.push(NaN);
          dat.push(NaN);
        } else {
          dat.push(this.imm_decodeVal(udat[idx + 2] + (udat[idx + 3] << 16)));
          dat.push(this.imm_decodeAvg(udat[idx] + ((udat[idx + 1] ^ 32768) << 16), 1));
          dat.push(this.imm_decodeVal(udat[idx + 4] + (udat[idx + 5] << 16)));
        }
        idx = idx + 6;
        this._values.push(dat.slice());
      }
    } else {
      while (idx + 1 < udat.length) {
        dat.length = 0;
        if (udat[idx] == 65535 && udat[idx + 1] == 65535) {
          dat.push(NaN);
        } else {
          dat.push(this.imm_decodeAvg(udat[idx] + ((udat[idx + 1] ^ 32768) << 16), 1));
        }
        this._values.push(dat.slice());
        idx = idx + 2;
      }
    }
    this._nRows = this._values.length;
    this._isLoaded = true;
    return YAPI_SUCCESS;
  }
  imm_wasLoaded() {
    return this._isLoaded;
  }
  imm_get_url() {
    let url;
    url = "logger.json?id=" + this._functionId + "&run=" + String(Math.round(this._runNo)) + "&utc=" + String(Math.round(this._utcStamp));
    return url;
  }
  imm_get_baseurl() {
    let url;
    url = "logger.json?id=" + this._functionId + "&run=" + String(Math.round(this._runNo)) + "&utc=";
    return url;
  }
  imm_get_urlsuffix() {
    let url;
    url = String(Math.round(this._utcStamp));
    return url;
  }
  async loadStream() {
    return this.imm_parseStream(await this._parent._download(this.imm_get_url()));
  }
  imm_decodeVal(w) {
    let val;
    val = w;
    val = val / 1e3;
    if (this._caltyp != 0) {
      if (this.imm_calhdl != null) {
        val = this.imm_calhdl(val, this._caltyp, this._calpar, this._calraw, this._calref);
      }
    }
    return val;
  }
  imm_decodeAvg(dw, count) {
    let val;
    val = dw;
    val = val / 1e3;
    if (this._caltyp != 0) {
      if (this.imm_calhdl != null) {
        val = this.imm_calhdl(val, this._caltyp, this._calpar, this._calraw, this._calref);
      }
    }
    return val;
  }
  async isClosed() {
    return this._isClosed;
  }
  async get_runIndex() {
    return this._runNo;
  }
  async get_startTime() {
    return this._utcStamp - (Date.now() / 1e3 >> 0);
  }
  async get_startTimeUTC() {
    return Math.round(this._startTime);
  }
  async get_realStartTimeUTC() {
    return this._startTime;
  }
  async get_dataSamplesIntervalMs() {
    return Math.round(this._dataSamplesInterval * 1e3);
  }
  async get_dataSamplesInterval() {
    return this._dataSamplesInterval;
  }
  async get_firstDataSamplesInterval() {
    return this._firstMeasureDuration;
  }
  async get_rowCount() {
    if (this._nRows != 0 && this._isClosed) {
      return this._nRows;
    }
    await this.loadStream();
    return this._nRows;
  }
  async get_columnCount() {
    if (this._nCols != 0) {
      return this._nCols;
    }
    await this.loadStream();
    return this._nCols;
  }
  async get_columnNames() {
    if (this._columnNames.length != 0) {
      return this._columnNames;
    }
    await this.loadStream();
    return this._columnNames;
  }
  async get_minValue() {
    return this._minVal;
  }
  async get_averageValue() {
    return this._avgVal;
  }
  async get_maxValue() {
    return this._maxVal;
  }
  async get_realDuration() {
    if (this._isClosed) {
      return this._duration;
    }
    return (Date.now() / 1e3 >> 0) - this._utcStamp;
  }
  async get_dataRows() {
    if (this._values.length == 0 || !this._isClosed) {
      await this.loadStream();
    }
    return this._values;
  }
  async get_data(row, col) {
    if (this._values.length == 0 || !this._isClosed) {
      await this.loadStream();
    }
    if (row >= this._values.length) {
      return YDataStream.DATA_INVALID;
    }
    if (col >= this._values[row].length) {
      return YDataStream.DATA_INVALID;
    }
    return this._values[row][col];
  }
};
YDataStream.DATA_INVALID = YAPI_INVALID_DOUBLE;
YDataStream.DURATION_INVALID = YAPI_INVALID_DOUBLE;
var YDataSet = class {
  constructor(obj_parent, str_functionId = "", str_unit = "", double_startTime = 0, double_endTime = 0) {
    this._hardwareId = "";
    this._functionId = "";
    this._unit = "";
    this._bulkLoad = 0;
    this._startTimeMs = 0;
    this._endTimeMs = 0;
    this._progress = 0;
    this._calib = [];
    this._streams = [];
    this._preview = [];
    this._measures = [];
    this._summaryMinVal = 0;
    this._summaryMaxVal = 0;
    this._summaryTotalAvg = 0;
    this._summaryTotalTime = 0;
    this.DATA_INVALID = YAPI_INVALID_DOUBLE;
    this.DURATION_INVALID = YAPI_INVALID_DOUBLE;
    this.HARDWAREID_INVALID = YAPI_INVALID_STRING;
    this.FUNCTIONID_INVALID = YAPI_INVALID_STRING;
    this.UNIT_INVALID = YAPI_INVALID_STRING;
    this._summary = new YMeasure(0, 0, 0, 0, 0);
    if (str_functionId == "") {
      this._parent = obj_parent;
      this._yapi = obj_parent._yapi;
      this._startTimeMs = 0;
      this._endTimeMs = 0;
    } else {
      this._parent = obj_parent;
      this._yapi = obj_parent._yapi;
      this._functionId = str_functionId;
      this._unit = str_unit;
      this._startTimeMs = double_startTime * 1e3;
      this._endTimeMs = double_endTime * 1e3;
      this._progress = -1;
    }
  }
  imm_get_functionId() {
    return this._functionId;
  }
  imm_get_calibration() {
    return this._calib;
  }
  async loadSummary(data) {
    let dataRows = [];
    let tim;
    let mitv;
    let itv;
    let fitv;
    let end_;
    let nCols;
    let minCol;
    let avgCol;
    let maxCol;
    let res;
    let m_pos;
    let previewTotalTime;
    let previewTotalAvg;
    let previewMinVal;
    let previewMaxVal;
    let previewAvgVal;
    let previewStartMs;
    let previewStopMs;
    let previewDuration;
    let streamStartTimeMs;
    let streamDuration;
    let streamEndTimeMs;
    let minVal;
    let avgVal;
    let maxVal;
    let summaryStartMs;
    let summaryStopMs;
    let summaryTotalTime;
    let summaryTotalAvg;
    let summaryMinVal;
    let summaryMaxVal;
    let url;
    let strdata;
    let measure_data = [];
    if (this._progress < 0) {
      strdata = this._yapi.imm_bin2str(data);
      if (strdata == "{}") {
        this._parent._throw(YAPI_VERSION_MISMATCH, "device firmware is too old");
        return YAPI_VERSION_MISMATCH;
      }
      res = await this._parse(strdata);
      if (res < 0) {
        return res;
      }
    }
    summaryTotalTime = 0;
    summaryTotalAvg = 0;
    summaryMinVal = YAPI_MAX_DOUBLE;
    summaryMaxVal = YAPI_MIN_DOUBLE;
    summaryStartMs = YAPI_MAX_DOUBLE;
    summaryStopMs = YAPI_MIN_DOUBLE;
    for (let ii in this._streams) {
      streamStartTimeMs = Math.round(await this._streams[ii].get_realStartTimeUTC() * 1e3);
      streamDuration = await this._streams[ii].get_realDuration();
      streamEndTimeMs = streamStartTimeMs + Math.round(streamDuration * 1e3);
      if (streamStartTimeMs >= this._startTimeMs && (this._endTimeMs == 0 || streamEndTimeMs <= this._endTimeMs)) {
        previewMinVal = await this._streams[ii].get_minValue();
        previewAvgVal = await this._streams[ii].get_averageValue();
        previewMaxVal = await this._streams[ii].get_maxValue();
        previewStartMs = streamStartTimeMs;
        previewStopMs = streamEndTimeMs;
        previewDuration = streamDuration;
      } else {
        if (!this._streams[ii].imm_wasLoaded()) {
          url = this._streams[ii].imm_get_url();
          data = await this._parent._download(url);
          this._streams[ii].imm_parseStream(data);
        }
        dataRows = await this._streams[ii].get_dataRows();
        if (dataRows.length == 0) {
          return await this.get_progress();
        }
        tim = streamStartTimeMs;
        fitv = Math.round(await this._streams[ii].get_firstDataSamplesInterval() * 1e3);
        itv = Math.round(await this._streams[ii].get_dataSamplesInterval() * 1e3);
        nCols = dataRows[0].length;
        minCol = 0;
        if (nCols > 2) {
          avgCol = 1;
        } else {
          avgCol = 0;
        }
        if (nCols > 2) {
          maxCol = 2;
        } else {
          maxCol = 0;
        }
        previewTotalTime = 0;
        previewTotalAvg = 0;
        previewStartMs = streamEndTimeMs;
        previewStopMs = streamStartTimeMs;
        previewMinVal = YAPI_MAX_DOUBLE;
        previewMaxVal = YAPI_MIN_DOUBLE;
        m_pos = 0;
        while (m_pos < dataRows.length) {
          measure_data = dataRows[m_pos];
          if (m_pos == 0) {
            mitv = fitv;
          } else {
            mitv = itv;
          }
          end_ = tim + mitv;
          if (end_ > this._startTimeMs && (this._endTimeMs == 0 || tim < this._endTimeMs)) {
            minVal = measure_data[minCol];
            avgVal = measure_data[avgCol];
            maxVal = measure_data[maxCol];
            if (previewStartMs > tim) {
              previewStartMs = tim;
            }
            if (previewStopMs < end_) {
              previewStopMs = end_;
            }
            if (previewMinVal > minVal) {
              previewMinVal = minVal;
            }
            if (previewMaxVal < maxVal) {
              previewMaxVal = maxVal;
            }
            if (!isNaN(avgVal)) {
              previewTotalAvg = previewTotalAvg + avgVal * mitv;
              previewTotalTime = previewTotalTime + mitv;
            }
          }
          tim = end_;
          m_pos = m_pos + 1;
        }
        if (previewTotalTime > 0) {
          previewAvgVal = previewTotalAvg / previewTotalTime;
          previewDuration = (previewStopMs - previewStartMs) / 1e3;
        } else {
          previewAvgVal = 0;
          previewDuration = 0;
        }
      }
      this._preview.push(new YMeasure(previewStartMs / 1e3, previewStopMs / 1e3, previewMinVal, previewAvgVal, previewMaxVal));
      if (summaryMinVal > previewMinVal) {
        summaryMinVal = previewMinVal;
      }
      if (summaryMaxVal < previewMaxVal) {
        summaryMaxVal = previewMaxVal;
      }
      if (summaryStartMs > previewStartMs) {
        summaryStartMs = previewStartMs;
      }
      if (summaryStopMs < previewStopMs) {
        summaryStopMs = previewStopMs;
      }
      summaryTotalAvg = summaryTotalAvg + previewAvgVal * previewDuration;
      summaryTotalTime = summaryTotalTime + previewDuration;
    }
    if (this._startTimeMs == 0 || this._startTimeMs > summaryStartMs) {
      this._startTimeMs = summaryStartMs;
    }
    if (this._endTimeMs == 0 || this._endTimeMs < summaryStopMs) {
      this._endTimeMs = summaryStopMs;
    }
    if (summaryTotalTime > 0) {
      this._summary = new YMeasure(summaryStartMs / 1e3, summaryStopMs / 1e3, summaryMinVal, summaryTotalAvg / summaryTotalTime, summaryMaxVal);
    } else {
      this._summary = new YMeasure(0, 0, YAPI_INVALID_DOUBLE, YAPI_INVALID_DOUBLE, YAPI_INVALID_DOUBLE);
    }
    return await this.get_progress();
  }
  async processMore(progress, data) {
    let stream;
    let dataRows = [];
    let tim;
    let itv;
    let fitv;
    let avgv;
    let end_;
    let nCols;
    let minCol;
    let avgCol;
    let maxCol;
    let firstMeasure;
    let baseurl;
    let url;
    let suffix;
    let suffixes = [];
    let idx;
    let bulkFile;
    let urlIdx;
    let streamBin = [];
    if (progress != this._progress) {
      return this._progress;
    }
    if (this._progress < 0) {
      return await this.loadSummary(data);
    }
    stream = this._streams[this._progress];
    if (!stream.imm_wasLoaded()) {
      stream.imm_parseStream(data);
    }
    dataRows = await stream.get_dataRows();
    this._progress = this._progress + 1;
    if (dataRows.length == 0) {
      return await this.get_progress();
    }
    tim = Math.round(await stream.get_realStartTimeUTC() * 1e3);
    fitv = Math.round(await stream.get_firstDataSamplesInterval() * 1e3);
    itv = Math.round(await stream.get_dataSamplesInterval() * 1e3);
    if (fitv == 0) {
      fitv = itv;
    }
    if (tim < itv) {
      tim = itv;
    }
    nCols = dataRows[0].length;
    minCol = 0;
    if (nCols > 2) {
      avgCol = 1;
    } else {
      avgCol = 0;
    }
    if (nCols > 2) {
      maxCol = 2;
    } else {
      maxCol = 0;
    }
    firstMeasure = true;
    for (let ii in dataRows) {
      if (firstMeasure) {
        end_ = tim + fitv;
        firstMeasure = false;
      } else {
        end_ = tim + itv;
      }
      avgv = dataRows[ii][avgCol];
      if (end_ > this._startTimeMs && (this._endTimeMs == 0 || tim < this._endTimeMs) && !isNaN(avgv)) {
        this._measures.push(new YMeasure(tim / 1e3, end_ / 1e3, dataRows[ii][minCol], avgv, dataRows[ii][maxCol]));
      }
      tim = end_;
    }
    if (this._bulkLoad > 0 && this._progress < this._streams.length) {
      stream = this._streams[this._progress];
      if (stream.imm_wasLoaded()) {
        return await this.get_progress();
      }
      baseurl = stream.imm_get_baseurl();
      url = stream.imm_get_url();
      suffix = stream.imm_get_urlsuffix();
      suffixes.push(suffix);
      idx = this._progress + 1;
      while (idx < this._streams.length && suffixes.length < this._bulkLoad) {
        stream = this._streams[idx];
        if (!stream.imm_wasLoaded() && stream.imm_get_baseurl() == baseurl) {
          suffix = stream.imm_get_urlsuffix();
          suffixes.push(suffix);
          url = url + "," + suffix;
        }
        idx = idx + 1;
      }
      bulkFile = await this._parent._download(url);
      streamBin = this._parent.imm_json_get_array(bulkFile);
      urlIdx = 0;
      idx = this._progress;
      while (idx < this._streams.length && urlIdx < suffixes.length && urlIdx < streamBin.length) {
        stream = this._streams[idx];
        if (stream.imm_get_baseurl() == baseurl && stream.imm_get_urlsuffix() == suffixes[urlIdx]) {
          stream.imm_parseStream(streamBin[urlIdx]);
          urlIdx = urlIdx + 1;
        }
        idx = idx + 1;
      }
    }
    return await this.get_progress();
  }
  async get_privateDataStreams() {
    return this._streams;
  }
  async get_hardwareId() {
    let mo;
    if (!(this._hardwareId == "")) {
      return this._hardwareId;
    }
    mo = await this._parent.get_module();
    this._hardwareId = await mo.get_serialNumber() + "." + await this.get_functionId();
    return this._hardwareId;
  }
  async get_functionId() {
    return this._functionId;
  }
  async get_unit() {
    return this._unit;
  }
  async get_startTimeUTC() {
    return this.imm_get_startTimeUTC();
  }
  imm_get_startTimeUTC() {
    return this._startTimeMs / 1e3;
  }
  async get_endTimeUTC() {
    return this.imm_get_endTimeUTC();
  }
  imm_get_endTimeUTC() {
    return Math.round(this._endTimeMs / 1e3);
  }
  async get_progress() {
    if (this._progress < 0) {
      return 0;
    }
    if (this._progress >= this._streams.length) {
      return 100;
    }
    return (1 + (1 + this._progress) * 98) / (1 + this._streams.length) >> 0;
  }
  async loadMore() {
    let url;
    let stream;
    if (this._progress < 0) {
      url = "logger.json?id=" + this._functionId;
      if (this._startTimeMs != 0) {
        url = url + "&from=" + String(Math.round(this.imm_get_startTimeUTC()));
      }
      if (this._endTimeMs != 0) {
        url = url + "&to=" + String(Math.round(this.imm_get_endTimeUTC() + 1));
      }
    } else {
      if (this._progress >= this._streams.length) {
        return 100;
      } else {
        stream = this._streams[this._progress];
        if (stream.imm_wasLoaded()) {
          return await this.processMore(this._progress, this._yapi.imm_str2bin(""));
        }
        url = stream.imm_get_url();
      }
    }
    try {
      return await this.processMore(this._progress, await this._parent._download(url));
    } catch (e) {
      return await this.processMore(this._progress, await this._parent._download(url));
    }
  }
  async get_summary() {
    return this._summary;
  }
  async get_preview() {
    return this._preview;
  }
  async get_measuresAt(measure) {
    let startUtcMs;
    let stream;
    let dataRows = [];
    let measures = [];
    let tim;
    let itv;
    let end_;
    let nCols;
    let minCol;
    let avgCol;
    let maxCol;
    startUtcMs = measure.get_startTimeUTC() * 1e3;
    stream = null;
    for (let ii in this._streams) {
      if (Math.round(await this._streams[ii].get_realStartTimeUTC() * 1e3) == startUtcMs) {
        stream = this._streams[ii];
      }
    }
    if (stream == null) {
      return measures;
    }
    dataRows = await stream.get_dataRows();
    if (dataRows.length == 0) {
      return measures;
    }
    tim = Math.round(await stream.get_realStartTimeUTC() * 1e3);
    itv = Math.round(await stream.get_dataSamplesInterval() * 1e3);
    if (tim < itv) {
      tim = itv;
    }
    nCols = dataRows[0].length;
    minCol = 0;
    if (nCols > 2) {
      avgCol = 1;
    } else {
      avgCol = 0;
    }
    if (nCols > 2) {
      maxCol = 2;
    } else {
      maxCol = 0;
    }
    for (let ii in dataRows) {
      end_ = tim + itv;
      if (end_ > this._startTimeMs && (this._endTimeMs == 0 || tim < this._endTimeMs)) {
        measures.push(new YMeasure(tim / 1e3, end_ / 1e3, dataRows[ii][minCol], dataRows[ii][avgCol], dataRows[ii][maxCol]));
      }
      tim = end_;
    }
    return measures;
  }
  async get_measures() {
    return this._measures;
  }
  async _parse(str_json) {
    let loadval = null;
    try {
      loadval = JSON.parse(str_json);
    } catch (err) {
    }
    if (!loadval) {
      this._progress = 0;
      return await this.get_progress();
    }
    this._functionId = loadval.id;
    this._unit = loadval.unit;
    this._bulkLoad = loadval.bulk ? parseInt(loadval.bulk) : 0;
    if (loadval.calib) {
      this._calib = this._yapi.imm_decodeFloats(loadval.calib);
      this._calib[0] = this._calib[0] / 1e3 >> 0;
    } else {
      this._calib = this._yapi.imm_decodeWords(loadval.cal);
    }
    this._summary = new YMeasure(0, 0, 0, 0, 0);
    this._streams = [];
    this._preview = [];
    this._measures = [];
    for (let i = 0; i < loadval.streams.length; i++) {
      let stream = this._parent.imm_findDataStream(this, loadval.streams[i]);
      if (!stream)
        continue;
      let streamStartTime = await stream.get_realStartTimeUTC() * 1e3;
      let streamEndTime = streamStartTime + await stream.get_realDuration() * 1e3;
      if (this._startTimeMs > 0 && streamEndTime <= this._startTimeMs) {
      } else if (this._endTimeMs > 0 && streamStartTime >= this._endTimeMs) {
      } else {
        this._streams.push(stream);
      }
    }
    this._progress = 0;
    return this.get_progress();
  }
};
YDataSet.DATA_INVALID = YAPI_INVALID_DOUBLE;
YDataSet.DURATION_INVALID = YAPI_INVALID_DOUBLE;
YDataSet.HARDWAREID_INVALID = YAPI_INVALID_STRING;
YDataSet.FUNCTIONID_INVALID = YAPI_INVALID_STRING;
YDataSet.UNIT_INVALID = YAPI_INVALID_STRING;
YDataSet.DATA_INVALID = YAPI_INVALID_DOUBLE;
YDataSet.DURATION_INVALID = YAPI_INVALID_DOUBLE;
YDataSet.HARDWAREID_INVALID = YAPI_INVALID_STRING;
YDataSet.FUNCTIONID_INVALID = YAPI_INVALID_STRING;
YDataSet.UNIT_INVALID = YAPI_INVALID_STRING;
var YDevice = class {
  constructor(obj_yapi, str_rooturl, obj_wpRec, obj_ypRecs) {
    this._yapi = obj_yapi;
    this._rootUrl = str_rooturl;
    this._serialNumber = "";
    this._logicalName = "";
    this._productName = "";
    this._productId = 0;
    this._beacon = 0;
    this._devYdx = -1;
    this._lastErrorType = YAPI_SUCCESS;
    this._lastErrorMsg = "no error";
    this._cache = {_expiration: 0, _json: new Uint8Array(0), _precooked: {}};
    this._functions = [];
    this._busy = 0;
    this._pendingQueries = Promise.resolve();
    this._lastTimeRef = 0;
    this._lastDuration = 0;
    this._logCallback = null;
    this._logIsPulling = false;
    this._logpos = 0;
    if (obj_wpRec && obj_ypRecs) {
      this._serialNumber = obj_wpRec.serialNumber;
      this._logicalName = obj_wpRec.logicalName;
      this._productName = obj_wpRec.productName;
      this._productId = obj_wpRec.productId;
      this._beacon = obj_wpRec.beacon;
      this._devYdx = obj_wpRec.index == void 0 ? -1 : obj_wpRec.index;
      this.imm_updateFromYP(obj_ypRecs);
      this._yapi.imm_reindexDevice(this);
    }
  }
  _throw(int_errType, str_errMsg, obj_retVal) {
    this._lastErrorType = int_errType;
    this._lastErrorMsg = str_errMsg;
    return this._yapi._throw(int_errType, str_errMsg, obj_retVal);
  }
  imm_getRootUrl() {
    return this._rootUrl;
  }
  imm_getSerialNumber() {
    return this._serialNumber;
  }
  imm_getLogicalName() {
    return this._logicalName;
  }
  async getLogicalName() {
    if (this._cache._expiration == 0) {
      await this.refresh();
    }
    return this._logicalName;
  }
  imm_getProductName() {
    return this._productName;
  }
  imm_getProductId() {
    return this._productId;
  }
  imm_getBeacon() {
    return this._beacon;
  }
  async getBeacon() {
    if (this._cache._expiration == 0) {
      await this.refresh();
    }
    return this._beacon;
  }
  imm_getLastTimeRef() {
    return this._lastTimeRef;
  }
  imm_getLastDuration() {
    return this._lastDuration;
  }
  imm_triggerLogPull() {
    if (this._logCallback == null || this._logIsPulling) {
      return;
    }
    this._logIsPulling = true;
    let request = "GET logs.txt?pos=" + this._logpos;
    let prom = this._yapi.devRequest(this._rootUrl, request, null, 0);
    prom.then(async (yreq) => {
      if (yreq.errorType != YAPI_SUCCESS) {
        this._logIsPulling = false;
        return;
      }
      if (this._logCallback == null) {
        this._logIsPulling = false;
        return;
      }
      let resultStr = YAPI.imm_bin2str(yreq.bin_result);
      let pos = resultStr.lastIndexOf("\n@");
      if (pos < 0) {
        this._logIsPulling = false;
        return;
      }
      let logs = resultStr.substring(0, pos);
      let posStr = resultStr.substring(pos + 2);
      this._logpos = parseInt(posStr);
      let module = YModule.FindModuleInContext(this._yapi, this._serialNumber);
      let lines = logs.trim().split("\n");
      try {
        for (let i = 0; i < lines.length; i++) {
          await this._logCallback(module, lines[i]);
        }
      } catch (e) {
        this._yapi.imm_log("Exception in device log callback:", e);
      }
      this._logIsPulling = false;
    });
  }
  imm_registerLogCallback(callback) {
    this._logCallback = callback;
    if (callback != null) {
      this.imm_triggerLogPull();
    } else {
      this._logpos = 0;
      this._logIsPulling = false;
    }
  }
  imm_setTimeRef(float_timestamp, float_duration) {
    this._lastTimeRef = float_timestamp;
    this._lastDuration = float_duration;
  }
  imm_getDevYdx() {
    return this._devYdx;
  }
  imm_describe() {
    let res = this._rootUrl;
    if (this._serialNumber != "") {
      res = this._serialNumber;
      if (this._logicalName != "") {
        res = res + " (" + this._logicalName + ")";
      }
    }
    return this._productName + " " + res;
  }
  imm_updateFromYP(obj_ypRecs) {
    let funidx = 0;
    for (let categ in obj_ypRecs) {
      for (let key in obj_ypRecs[categ]) {
        let rec = obj_ypRecs[categ][key];
        let hwid = rec["hardwareId"];
        let dotpos = hwid.indexOf(".");
        if (hwid.substr(0, dotpos) == this._serialNumber) {
          let funydx = rec["index"];
          if (funydx == void 0)
            funydx = funidx;
          this._functions[funydx] = [hwid.substr(dotpos + 1), rec["logicalName"]];
          funidx++;
        }
      }
    }
  }
  async updateFromReq(yreq, loadval) {
    this._cache._expiration = this._yapi.GetTickCount() + this._yapi.defaultCacheValidity;
    this._cache._json = yreq.bin_result;
    let func;
    let reindex = false;
    if (this._productName == "") {
      for (func in loadval) {
        if (func == "module") {
          this._serialNumber = loadval.module.serialNumber;
          this._logicalName = loadval.module.logicalName;
          this._productName = loadval.module.productName;
          this._productId = loadval.module.productId;
          this._beacon = loadval.module.beacon;
        } else if (func == "services") {
          this.imm_updateFromYP(loadval.services.yellowPages);
        }
      }
      reindex = true;
    } else {
      let renamed = false;
      for (func in loadval) {
        if (func == "module") {
          if (this._logicalName != loadval.module.logicalName) {
            this._logicalName = loadval.module.logicalName;
            reindex = true;
          }
          this._beacon = loadval.module.beacon;
        } else if (func != "services") {
          let name = loadval[func]["logicalName"];
          if (name == void 0)
            name = loadval.module.logicalName;
          let pubval = loadval[func]["advertisedValue"];
          if (pubval != void 0) {
            await this._yapi.setFunctionValue(loadval.module.serialNumber + "." + func, pubval);
          }
          let funydx;
          for (funydx in this._functions) {
            if (this._functions[funydx][0] == func) {
              if (this._functions[funydx][1] != name) {
                this._functions[funydx][1] = name;
                reindex = true;
              }
              break;
            }
          }
        }
      }
    }
    if (reindex) {
      this._yapi.imm_reindexDevice(this);
    }
  }
  imm_dropCache() {
    this._cache._expiration = 0;
    this._cache._precooked = {};
  }
  imm_functionCount() {
    let funcPos = 0;
    for (let key in this._functions) {
      funcPos++;
    }
    return funcPos;
  }
  imm_functionId(int_idx) {
    let funcPos = 0;
    for (let key in this._functions) {
      if (int_idx === funcPos) {
        return this._functions[key][0];
      }
      funcPos++;
    }
    return "";
  }
  imm_functionBaseType(int_idx) {
    let funid = this.imm_functionId(int_idx);
    if (funid !== "") {
      let ftype = this._yapi.imm_getFunctionBaseType(this._serialNumber + "." + funid);
      for (let baseType in Y_BASETYPES) {
        if (Y_BASETYPES[baseType] === ftype) {
          return baseType;
        }
      }
    }
    return "Function";
  }
  imm_functionType(int_idx) {
    let funid = this.imm_functionId(int_idx);
    if (funid !== "") {
      let i;
      for (i = funid.length; i > 0; i--) {
        if (funid[i - 1] > "9") {
          break;
        }
      }
      let functionType = funid[0].toUpperCase() + funid.substr(1, i - 1);
      return functionType;
    }
    return "";
  }
  imm_functionName(int_idx) {
    let funcPos = 0;
    for (let key in this._functions) {
      if (int_idx === funcPos) {
        return this._functions[key][1];
      }
      funcPos++;
    }
    return "";
  }
  imm_functionValue(int_idx) {
    let funid = this.imm_functionId(int_idx);
    if (funid !== "") {
      return this._yapi.imm_getFunctionValue(this._serialNumber + "." + funid);
    }
    return "";
  }
  imm_functionIdByFunYdx(int_funydx) {
    if (this._functions[int_funydx]) {
      return this._functions[int_funydx][0];
    }
    return "";
  }
  imm_jzon2json(jzon, json) {
    if (Array.isArray(jzon)) {
      let sz = jzon.length;
      if (Array.isArray(json)) {
        let defval = json.length > 0 ? json[0] : null;
        let res = [];
        for (let idx = 0; idx < sz; idx++) {
          res[idx] = this.imm_jzon2json(jzon[idx], defval);
        }
        return res;
      } else if (typeof json === "object") {
        let idx = 0;
        let res = {};
        for (let key in json) {
          if (json.hasOwnProperty(key)) {
            res[key] = this.imm_jzon2json(jzon[idx], json[key]);
            idx++;
          }
        }
        return res;
      } else {
        return jzon;
      }
    } else if (typeof jzon === "object") {
      if (Array.isArray(json)) {
        return jzon;
      } else if (typeof json === "object") {
        let defval = null;
        for (let key in json) {
          if (json.hasOwnProperty(key)) {
            defval = json[key];
            break;
          }
        }
        let res = {};
        for (let key in jzon) {
          if (jzon.hasOwnProperty(key)) {
            if (json.hasOwnProperty(key) && (!Array.isArray(json[key]) || json[key].length > 0)) {
              res[key] = this.imm_jzon2json(jzon[key], json[key]);
            } else {
              res[key] = this.imm_jzon2json(jzon[key], defval);
            }
          }
        }
        return res;
      } else {
        return jzon;
      }
    }
    return jzon;
  }
  async requestAPI(int_msValidity) {
    if (this._cache._expiration > this._yapi.GetTickCount()) {
      let res = new YHTTPRequest(this._cache._json);
      res.obj_result = JSON.parse(JSON.stringify(this._cache._precooked));
      return res;
    }
    let req = "GET /api.json";
    let precooked = this._cache._precooked;
    if (precooked.module && precooked.module.firmwareRelease) {
      req += "?fw=" + encodeURIComponent(precooked.module.firmwareRelease);
    }
    let yreq = await this._yapi.devRequest(this._rootUrl, req, null, 0);
    if (yreq.errorType != YAPI_SUCCESS)
      return yreq;
    if (!int_msValidity) {
      int_msValidity = this._yapi.defaultCacheValidity;
    }
    this._cache._json = yreq.bin_result;
    try {
      yreq.obj_result = JSON.parse(this._yapi.imm_bin2str(yreq.bin_result));
      if (Array.isArray(yreq.obj_result)) {
        if (precooked.module) {
          let objres = this.imm_jzon2json(yreq.obj_result, precooked);
          yreq.obj_result = objres;
          if (objres.module && objres.module.serialNumber === objres.module.serialNumber && objres.module.firmwareRelease === objres.module.firmwareRelease) {
            let jsonstr = JSON.stringify(yreq.obj_result);
            this._cache._json = yreq.bin_result = this._yapi.imm_str2bin(jsonstr);
            this._cache._precooked = JSON.parse(jsonstr);
          } else {
            this.imm_dropCache();
            yreq.errorType = YAPI_IO_ERROR;
            yreq.errorMsg = "Request failed, could not parse API JZON result for " + this._rootUrl;
          }
        } else {
          yreq.errorType = YAPI_IO_ERROR;
          yreq.errorMsg = "Request failed, could not parse API array result for " + this._rootUrl;
        }
      } else if (yreq.obj_result.module && yreq.obj_result.module.firmwareRelease) {
        this._cache._precooked = JSON.parse(JSON.stringify(yreq.obj_result));
      }
      this._cache._expiration = this._yapi.GetTickCount() + int_msValidity;
      this._logicalName = yreq.obj_result.module.logicalName;
      this._beacon = yreq.obj_result.module.beacon;
    } catch (err) {
      yreq.errorType = YAPI_IO_ERROR;
      yreq.errorMsg = "Request failed, could not parse API JSON result for " + this._rootUrl;
    }
    return yreq;
  }
  async refresh() {
    let yreq = await this.requestAPI(this._yapi.defaultCacheValidity);
    if (yreq.errorType != YAPI_SUCCESS) {
      return this._throw(yreq.errorType, yreq.errorMsg, yreq.errorType);
    }
    await this.updateFromReq(yreq, yreq.obj_result);
    return YAPI_SUCCESS;
  }
  async waitPendingQueries() {
    let newPromise = this._pendingQueries;
    if (newPromise != null) {
      try {
        await newPromise;
      } catch (e) {
        console.log(e);
      }
    }
  }
};
var YFirmwareFile = class {
  constructor(path, serial, pictype, product, firmware, prog_version, ROM_nb_zone, FLA_nb_zone, ROM_total_size, FLA_total_size, data, zone_ofs) {
    this._path = path;
    this._serial = serial;
    this._pictype = pictype;
    this._product = product;
    this._firmware = firmware;
    this._prog_version = prog_version;
    this._ROM_nb_zone = ROM_nb_zone;
    this._FLA_nb_zone = FLA_nb_zone;
    this._ROM_total_size = ROM_total_size;
    this._FLA_total_size = FLA_total_size;
    this._data = data;
    this._zone_ofs = zone_ofs;
  }
  static imm_Parse(path, data, force) {
    const BYN_REV_V4 = 4;
    const BYN_REV_V5 = 5;
    const BYN_REV_V6 = 6;
    const MAX_ROM_ZONES_PER_FILES = 16;
    const MAX_FLASH_ZONES_PER_FILES = 4;
    const BYN_HEAD_SIZE_V4 = 96 + 8;
    const BYN_HEAD_SIZE_V5 = 96 + 32;
    const BYN_HEAD_SIZE_V6 = 96 + 48;
    const BYN_MD5_OFS_V6 = 96 + 16;
    let pos = 0;
    let getShort = () => {
      let res = data[pos] + (data[pos + 1] << 8);
      pos += 2;
      return res;
    };
    let getInt = () => {
      let res = data[pos] + (data[pos + 1] << 8) + (data[pos + 2] << 16) + (data[pos + 3] << 24);
      pos += 4;
      return res;
    };
    let getString = (maxlen) => {
      let end = pos + maxlen;
      while (end > pos && data[end - 1] == 0) {
        end--;
      }
      let res = YAPI.imm_bin2str(data.subarray(pos, end));
      pos += maxlen;
      return res;
    };
    let sign = getString(4);
    if (sign != "BYN")
      return null;
    let rev = getShort();
    let serial = getString(20);
    let pictype = getString(20);
    let product = getString(28);
    let firmware = getString(22);
    if (serial.length >= 20)
      return null;
    if (product.length >= 28)
      return null;
    if (firmware.length >= 22)
      return null;
    let ROM_nb_zone = 0;
    let FLA_nb_zone = 0;
    let ROM_total_size = 0;
    let FLA_total_size = 0;
    let prog_buf;
    let prog_version = "";
    let zone_ofs;
    let datasize;
    switch (rev) {
      case BYN_REV_V4:
        zone_ofs = BYN_HEAD_SIZE_V4;
        ROM_nb_zone = getInt();
        datasize = getInt();
        if (ROM_nb_zone > MAX_ROM_ZONES_PER_FILES)
          return null;
        if (datasize != data.length - BYN_HEAD_SIZE_V4)
          return null;
        break;
      case BYN_REV_V5:
        zone_ofs = BYN_HEAD_SIZE_V5;
        prog_version = getString(22);
        if (!force && !YFirmwareFile.imm_progCompatible(prog_version))
          return null;
        getShort();
        ROM_nb_zone = getInt();
        datasize = getInt();
        if (ROM_nb_zone > MAX_ROM_ZONES_PER_FILES)
          return null;
        if (datasize != data.length - BYN_HEAD_SIZE_V5)
          return null;
        break;
      case BYN_REV_V6:
        zone_ofs = BYN_HEAD_SIZE_V6;
        let md5hdr = data.subarray(pos, pos + 16);
        pos += 16;
        let md5hdrstr = YAPI.imm_bin2hexstr(md5hdr);
        let md5ctx = new Y_MD5Ctx();
        md5ctx.addData(data.subarray(BYN_MD5_OFS_V6));
        let md5bynstr = YAPI.imm_bin2hexstr(md5ctx.calculate());
        if (md5hdrstr != md5bynstr) {
          YAPI.imm_log("Invalid firmware image signature, file is corrupt");
          if (YAPI._logLevel >= 2) {
            YAPI.imm_log("hdr MD5: " + md5hdrstr);
            YAPI.imm_log("byn MD5: " + md5bynstr);
            YAPI.imm_log("byn size: " + data.length);
          }
          return null;
        }
        prog_version = getString(22);
        if (!force && !YFirmwareFile.imm_progCompatible(prog_version))
          return null;
        ROM_nb_zone = data[pos++];
        FLA_nb_zone = data[pos++];
        ROM_total_size = getInt();
        FLA_total_size = getInt();
        if (ROM_nb_zone > MAX_ROM_ZONES_PER_FILES)
          return null;
        if (FLA_nb_zone > MAX_FLASH_ZONES_PER_FILES)
          return null;
        break;
      default:
        return null;
    }
    return new YFirmwareFile(path, serial, pictype, product, firmware, prog_version, ROM_nb_zone, FLA_nb_zone, ROM_total_size, FLA_total_size, data, zone_ofs);
  }
  static imm_progCompatible(prog_version) {
    if (prog_version == "")
      return true;
    let apiVer = YAPI.imm_GetAPIVersion();
    let dashpos = apiVer.indexOf("-");
    if (dashpos > 0) {
      apiVer = apiVer.slice(0, dashpos);
    }
    apiVer = apiVer.slice(apiVer.lastIndexOf(".") + 1);
    if (parseInt(prog_version) > parseInt(apiVer)) {
      YAPI.imm_log("checkProgField: byn=" + prog_version + " api=" + apiVer);
      return false;
    }
    return true;
  }
  imm_getSerial() {
    return this._serial;
  }
  imm_getPictype() {
    return this._pictype;
  }
  imm_getProduct() {
    return this._product;
  }
  imm_getFirmwareRelease() {
    return this._firmware;
  }
  imm_getFirmwareReleaseAsInt() {
    return parseInt(this._firmware);
  }
  imm_getProg_version() {
    return this._prog_version;
  }
  imm_getROM_nb_zone() {
    return this._ROM_nb_zone;
  }
  imm_getFLA_nb_zone() {
    return this._FLA_nb_zone;
  }
  imm_getROM_total_size() {
    return this._ROM_total_size;
  }
  imm_getFLA_total_size() {
    return this._FLA_total_size;
  }
  imm_getData() {
    return this._data;
  }
  imm_getPath() {
    return this._path;
  }
};
var YFirmwareUpdate = class {
  constructor(obj_yapi, str_serial, str_path, bin_settings, bool_force) {
    this._serial = "";
    this._settings = new Uint8Array(0);
    this._firmwarepath = "";
    this._progress_msg = "";
    this._progress_c = 0;
    this._progress = 0;
    this._restore_step = 0;
    this._force = false;
    this._yapi = obj_yapi;
    this._serial = str_serial;
    this._firmwarepath = str_path;
    this._settings = bin_settings;
    this._force = bool_force;
  }
  imm_progress(progress, msg) {
    this._progress = progress;
    this._progress_msg = msg;
  }
  async _processMore_internal(newupdate) {
    if (!newupdate)
      return YAPI_SUCCESS;
    let bytes;
    this.imm_progress(0, "Firmware update started");
    if (typeof this._firmwarepath == "string" && this._firmwarepath.indexOf("yoctopuce.com") >= 0) {
      this.imm_progress(1, "Downloading firmware");
      bytes = await this._yapi.system_env.downloadfile(this._firmwarepath, this._yapi);
    } else {
      this.imm_progress(1, "Loading firmware");
      bytes = await this._yapi.system_env.loadfile(this._firmwarepath);
    }
    let firmware = YFirmwareFile.imm_Parse(this._firmwarepath, bytes, this._force);
    if (!firmware) {
      return this._yapi._throw(YAPI_DEVICE_NOT_FOUND, "Device " + this._serial + " is not detected", YAPI_DEVICE_NOT_FOUND);
    }
    this.imm_progress(5, "Check if module is already in bootloader");
    let hub = null;
    let module = YModule.FindModuleInContext(this._yapi, this._serial + ".module");
    if (await module.isOnline()) {
      let dev = this._yapi.imm_getDevice(this._serial);
      let baseUrl = dev.imm_getRootUrl();
      let byPos = baseUrl.indexOf("/bySerial/");
      if (byPos >= 0) {
        baseUrl = baseUrl.slice(0, byPos + 1);
      } else if (baseUrl.slice(-1) != "/")
        baseUrl = baseUrl + "/";
      let urlInfo = new _YY_UrlInfo(baseUrl);
      hub = this._yapi.imm_getHub(urlInfo);
    } else {
      let hubs = this._yapi._connectedHubs;
      for (let i = 0; i < hubs.length; i++) {
        let ldrs = await hubs[i].getBootloaders();
        if (ldrs.indexOf(this._serial) >= 0) {
          hub = hubs[i];
          break;
        }
      }
    }
    if (hub == null) {
      this.imm_progress(-1, "Device " + this._serial + " is not detected");
      return this._yapi._throw(YAPI_DEVICE_NOT_FOUND, "Device " + this._serial + " is not detected", YAPI_DEVICE_NOT_FOUND);
    }
    try {
      await hub.firmwareUpdate(this._serial, firmware, this._settings, (percent, msg) => {
        this.imm_progress(5 + (percent * 80 + 50) / 100 >> 0, msg);
      });
    } catch (e) {
      this.imm_progress(-1, e.message);
      return this._yapi._throw(YAPI_IO_ERROR, e.message, YAPI_IO_ERROR);
    }
    if (module._cache.parentHub) {
      this.imm_progress(100, "Firmware update scheduled successfully");
    } else {
      this.imm_progress(80, "Wait for the device to restart");
      let timeout = this._yapi.GetTickCount() + 6e4;
      await module.clearCache();
      while (!await module.isOnline() && timeout > this._yapi.GetTickCount()) {
        await this._yapi.Sleep(500);
        await this._yapi.UpdateDeviceList();
      }
      if (await module.isOnline()) {
        if (this._settings != null) {
          this.imm_progress(95, "Restoring device settings");
          await module.set_allSettingsAndFiles(this._settings);
          await module.saveToFlash();
        }
        let real_fw = await module.get_firmwareRelease();
        if (real_fw == firmware.imm_getFirmwareRelease()) {
          this.imm_progress(100, "Success");
        } else {
          this.imm_progress(-1, "Unable to update firmware");
        }
      } else {
        this.imm_progress(-1, "Device did not reboot correctly");
      }
    }
    return YAPI_SUCCESS;
  }
  static async checkFirmware_r(file, serial_base, force) {
    if (file.substr(-4).toLowerCase() != ".byn")
      return null;
    let bynfile = await YAPI.system_env.loadfile(file);
    let firmware = YFirmwareFile.imm_Parse(file, bynfile, force);
    if (!firmware)
      return null;
    if (firmware.imm_getSerial().slice(0, serial_base.length) != serial_base)
      return null;
    return firmware;
  }
  static async CheckFirmwareEx(serial, path, minrelease, force) {
    let link = "";
    let best_rev = 0;
    let current_rev;
    if (typeof path == "string" && path.indexOf("yoctopuce.com") >= 0) {
      try {
        let data = await YAPI.system_env.downloadfile("http://www.yoctopuce.com/FR/common/getLastFirmwareLink.php?serial=" + serial, YAPI);
        let obj = JSON.parse(YAPI.imm_bin2str(data));
        link = obj["link"];
        best_rev = obj["version"];
      } catch (e) {
        YAPI.imm_log("failed to retrieve firmware information from www.yoctopuce.com", e);
        YAPI._throw(YAPI_IO_ERROR, "failed to retrieve firmware information from www.yoctopuce.com", "");
        return "";
      }
    } else {
      let firmware = await YFirmwareUpdate.checkFirmware_r(path, serial.substring(0, 8), force);
      if (firmware != null) {
        best_rev = firmware.imm_getFirmwareReleaseAsInt();
        link = firmware.imm_getPath();
      }
    }
    if (minrelease != 0) {
      if (minrelease < best_rev) {
        return link;
      } else {
        return "";
      }
    }
    return link;
  }
  static async CheckFirmware_internal(serial, path, minrelease) {
    return YFirmwareUpdate.CheckFirmwareEx(serial, path, minrelease, false);
  }
  static async GetAllBootLoadersInContext_internal(yctx) {
    let hubs = yctx._connectedHubs;
    let res = [];
    for (let i = 0; i < hubs.length; i++) {
      let ldrs = await hubs[i].getBootloaders();
      for (let j = 0; j < ldrs.length; j++) {
        res.push(ldrs[j]);
      }
    }
    return res;
  }
  static async GetAllBootLoaders_internal() {
    return YFirmwareUpdate.GetAllBootLoadersInContext(YAPI);
  }
  async _processMore(newupdate) {
    return await this._processMore_internal(newupdate);
  }
  static async GetAllBootLoaders() {
    return await this.GetAllBootLoaders_internal();
  }
  static async GetAllBootLoadersInContext(yctx) {
    return await this.GetAllBootLoadersInContext_internal(yctx);
  }
  static async CheckFirmware(serial, path, minrelease) {
    return await this.CheckFirmware_internal(serial, path, minrelease);
  }
  async get_progress() {
    if (this._progress >= 0) {
      await this._processMore(0);
    }
    return this._progress;
  }
  async get_progressMessage() {
    return this._progress_msg;
  }
  async startUpdate() {
    let err;
    let leng;
    err = this._yapi.imm_bin2str(this._settings);
    leng = err.length;
    if (leng >= 6 && err.substr(0, 6) == "error:") {
      this._progress = -1;
      this._progress_msg = err.substr(6, leng - 6);
    } else {
      this._progress = 0;
      this._progress_c = 0;
      await this._processMore(1);
    }
    return this._progress;
  }
};
var YFunction = class {
  constructor(obj_yapi, str_func) {
    this._logicalName = YFunction.LOGICALNAME_INVALID;
    this._advertisedValue = YFunction.ADVERTISEDVALUE_INVALID;
    this._valueCallbackFunction = null;
    this._cacheExpiration = 0;
    this._serial = "";
    this._funId = "";
    this._hwId = "";
    this.LOGICALNAME_INVALID = YAPI_INVALID_STRING;
    this.ADVERTISEDVALUE_INVALID = YAPI_INVALID_STRING;
    this._yapi = obj_yapi;
    this._className = "Function";
    this._func = str_func;
    this._lastErrorType = YAPI_SUCCESS;
    this._lastErrorMsg = "no error";
    this._dataStreams = {};
    this._userData = null;
    this._cache = {_expiration: -1, functionid: "", hwid: ""};
    this._valueCallbackFunction = null;
  }
  _throw(int_errType, str_errMsg, obj_retVal) {
    this._lastErrorType = int_errType;
    this._lastErrorMsg = str_errMsg;
    return this._yapi._throw(int_errType, str_errMsg, obj_retVal);
  }
  async isReadOnly_internal() {
    try {
      let serial = await this.get_serialNumber();
      return this._yapi.isReadOnly(serial);
    } catch (e) {
      return true;
    }
  }
  imm_parseAttr(name, val) {
    switch (name) {
      case "_expiration":
        this._cacheExpiration = val;
        return 1;
      case "logicalName":
        this._logicalName = val;
        return 1;
      case "advertisedValue":
        this._advertisedValue = val;
        return 1;
    }
    return 0;
  }
  async get_logicalName() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YFunction.LOGICALNAME_INVALID;
      }
    }
    res = this._logicalName;
    return res;
  }
  async set_logicalName(newval) {
    let rest_val;
    if (!await YAPI.CheckLogicalName(newval)) {
      return this._throw(YAPI.INVALID_ARGUMENT, "Invalid name :" + newval, YAPI.INVALID_ARGUMENT);
    }
    rest_val = String(newval);
    return await this._setAttr("logicalName", rest_val);
  }
  async get_advertisedValue() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YFunction.ADVERTISEDVALUE_INVALID;
      }
    }
    res = this._advertisedValue;
    return res;
  }
  async set_advertisedValue(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("advertisedValue", rest_val);
  }
  static FindFunction(func) {
    let obj;
    obj = YFunction._FindFromCache("Function", func);
    if (obj == null) {
      obj = new YFunction(YAPI, func);
      YFunction._AddToCache("Function", func, obj);
    }
    return obj;
  }
  static FindFunctionInContext(yctx, func) {
    let obj;
    obj = YFunction._FindFromCacheInContext(yctx, "Function", func);
    if (obj == null) {
      obj = new YFunction(yctx, func);
      YFunction._AddToCache("Function", func, obj);
    }
    return obj;
  }
  async registerValueCallback(callback) {
    let val;
    if (callback != null) {
      await YFunction._UpdateValueCallbackList(this, true);
    } else {
      await YFunction._UpdateValueCallbackList(this, false);
    }
    this._valueCallbackFunction = callback;
    if (callback != null && await this.isOnline()) {
      val = this._advertisedValue;
      if (!(val == "")) {
        await this._invokeValueCallback(val);
      }
    }
    return 0;
  }
  async _invokeValueCallback(value) {
    if (this._valueCallbackFunction != null) {
      try {
        await this._valueCallbackFunction(this, value);
      } catch (e) {
        this._yapi.imm_log("Exception in valueCallback:", e);
      }
    } else {
    }
    return 0;
  }
  async muteValueCallbacks() {
    return await this.set_advertisedValue("SILENT");
  }
  async unmuteValueCallbacks() {
    return await this.set_advertisedValue("");
  }
  async loadAttribute(attrName) {
    let url;
    let attrVal;
    url = "api/" + await this.get_functionId() + "/" + attrName;
    attrVal = await this._download(url);
    return this._yapi.imm_bin2str(attrVal);
  }
  async isReadOnly() {
    return await this.isReadOnly_internal();
  }
  async get_serialNumber() {
    let m;
    m = await this.get_module();
    return await m.get_serialNumber();
  }
  async _parserHelper() {
    return 0;
  }
  nextFunction() {
    let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
    if (resolve.errorType != YAPI.SUCCESS)
      return null;
    let next_hwid = this._yapi.imm_getNextHardwareId(this._className, resolve.result);
    if (next_hwid == null)
      return null;
    return YFunction.FindFunctionInContext(this._yapi, next_hwid);
  }
  static FirstFunction() {
    let next_hwid = YAPI.imm_getFirstHardwareId("Function");
    if (next_hwid == null)
      return null;
    return YFunction.FindFunction(next_hwid);
  }
  static FirstFunctionInContext(yctx) {
    let next_hwid = yctx.imm_getFirstHardwareId("Function");
    if (next_hwid == null)
      return null;
    return YFunction.FindFunctionInContext(yctx, next_hwid);
  }
  static _FindFromCacheInContext(yctx, className, func) {
    return yctx.imm_getFunction(className, func);
  }
  static _FindFromCache(className, func) {
    return YAPI.imm_getFunction(className, func);
  }
  static _AddToCache(className, func, obj) {
    obj._yapi.imm_setFunction(className, func, obj);
  }
  static _ClearCache(obj_yapi = null) {
    if (!obj_yapi)
      obj_yapi = YAPI;
    obj_yapi.imm_ResetToDefaults();
  }
  static async _UpdateValueCallbackList(obj_func, bool_add) {
    await obj_func._yapi._UpdateValueCallbackList(obj_func, bool_add);
  }
  static async _UpdateTimedReportCallbackList(obj_func, bool_add) {
    await obj_func._yapi._UpdateTimedReportCallbackList(obj_func, bool_add);
  }
  async describe() {
    if (this._hwId != "") {
      return this._className + "(" + this._func + ")=" + this._hwId;
    }
    let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
    if (resolve.errorType != YAPI_SUCCESS && resolve.result != this._func) {
      return this._className + "(" + this._func + ")=unresolved";
    }
    return this._className + "(" + this._func + ")=" + resolve.result;
  }
  async get_hardwareId() {
    if (this._hwId != "") {
      return this._hwId;
    }
    let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
    if (resolve.errorType != YAPI_SUCCESS) {
      await this.isOnline();
      resolve = this._yapi.imm_resolveFunction(this._className, this._func);
      if (resolve.errorType != YAPI_SUCCESS) {
        return this._throw(resolve.errorType, resolve.errorMsg, YFunction.HARDWAREID_INVALID);
      }
    }
    return resolve.result;
  }
  async get_functionId() {
    if (this._funId != "") {
      return this._funId;
    }
    let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
    if (resolve.errorType != YAPI_SUCCESS) {
      await this.isOnline();
      resolve = this._yapi.imm_resolveFunction(this._className, this._func);
      if (resolve.errorType != YAPI_SUCCESS) {
        return this._throw(resolve.errorType, resolve.errorMsg, YFunction.FUNCTIONID_INVALID);
      }
    }
    let hardwareId = resolve.result;
    let pos = hardwareId.indexOf(".");
    return hardwareId.substr(pos + 1);
  }
  imm_get_functionId() {
    if (this._funId != "") {
      return this._funId;
    }
    let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
    if (resolve.errorType != YAPI_SUCCESS) {
      return this._throw(resolve.errorType, resolve.errorMsg, YFunction.FUNCTIONID_INVALID);
    }
    let hardwareId = resolve.result;
    let pos = hardwareId.indexOf(".");
    return hardwareId.substr(pos + 1);
  }
  async get_friendlyName() {
    let resolve = this._yapi.imm_getFriendlyNameFunction(this._className, this._func);
    if (resolve.errorType != YAPI_SUCCESS) {
      await this.isOnline();
      resolve = this._yapi.imm_getFriendlyNameFunction(this._className, this._func);
      if (resolve.errorType != YAPI_SUCCESS) {
        return this._throw(resolve.errorType, resolve.errorMsg, YFunction.FRIENDLYNAME_INVALID);
      }
    }
    return resolve.result;
  }
  async _parse(yreq, msValidity) {
    if (!yreq.obj_result)
      return;
    yreq.obj_result._expiration = this._yapi.GetTickCount() + msValidity;
    this._cache = yreq.obj_result;
    this._serial = yreq.obj_result.deviceid;
    this._funId = yreq.obj_result.functionid;
    this._hwId = yreq.obj_result.hwid;
    for (let key in yreq.obj_result) {
      this.imm_parseAttr(key, yreq.obj_result[key]);
    }
    await this._parserHelper();
  }
  isOnline_async(func, ctx) {
    this.isOnline().then((res) => {
      func(ctx, this, res);
    }).catch((e) => {
      func(ctx, this, false);
    });
  }
  load_async(ms_validiy, func, ctx) {
    this.load(ms_validiy).then((res) => {
      func(ctx, this, YAPI_SUCCESS);
    }).catch((e) => {
      func(ctx, this, this.get_errorType());
    });
  }
  async _getAttr(str_attr) {
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS)
        return null;
    }
    if (typeof this._cache[str_attr] == "undefined") {
      this._throw(YAPI_VERSION_MISMATCH, "No such attribute " + str_attr + " in function", null);
    }
    return this._cache[str_attr];
  }
  async _getFixedAttr(str_attr) {
    if (this._cacheExpiration == 0) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS)
        return null;
    }
    if (typeof this._cache[str_attr] == "undefined") {
      this._throw(YAPI_VERSION_MISMATCH, "No such attribute " + str_attr + " in function", null);
    }
    return this._cache[str_attr];
  }
  imm_escapeAttr(str_newval) {
    return escape(str_newval).replace(/[+]/g, "%2B").replace(/%20/g, "+").replace(/%21/g, "!").replace(/%24/g, "$").replace(/%27/g, "'").replace(/%28/g, "(").replace(/%29/g, ")").replace(/%2[cC]/g, ",").replace(/%2[fF]/g, "/").replace(/%3[aA]/g, ":").replace(/%3[bB]/g, ";").replace(/%3[fF]/g, "?").replace(/%5[bB]/g, "[").replace(/%5[dD]/g, "]");
  }
  async _setAttr(str_attr, str_newval) {
    if (str_newval == void 0) {
      return this._throw(YAPI_INVALID_ARGUMENT, "Undefined value to set for attribute " + str_attr, null);
    }
    let attrname = encodeURIComponent(str_attr);
    let attrval = this.imm_escapeAttr(str_newval);
    let extra = "/" + attrname + "?" + attrname + "=" + attrval + "&.";
    if (this._cacheExpiration != 0) {
      this._cacheExpiration = this._yapi.GetTickCount();
      this._cache._expiration = this._cacheExpiration;
    }
    let yreq = await this._yapi.funcRequest(this._className, this._func, extra);
    if (yreq.errorType != YAPI_SUCCESS) {
      return this._throw(yreq.errorType, yreq.errorMsg, yreq.errorType);
    }
    return YAPI_SUCCESS;
  }
  async _download(str_path) {
    let devid = this._serial;
    if (devid == "") {
      devid = await (await this.module()).get_serialNumber();
    }
    if (devid == YAPI_INVALID_STRING) {
      return new Uint8Array(0);
    }
    let yreq = await this._yapi.devRequest(devid, "GET /" + str_path, null, 0);
    if (yreq.errorType != YAPI_SUCCESS) {
      return this._throw(yreq.errorType, yreq.errorMsg, "");
    }
    return yreq.bin_result;
  }
  async _downloadOutOfBand(str_path) {
    let devid = this._serial;
    if (devid == "") {
      devid = await (await this.module()).get_serialNumber();
    }
    if (devid == YAPI_INVALID_STRING) {
      return new Uint8Array(0);
    }
    let yreq = await this._yapi.devRequest(devid, "GET /" + str_path, null, 1);
    if (yreq.errorType != YAPI_SUCCESS) {
      return this._throw(yreq.errorType, yreq.errorMsg, "");
    }
    return yreq.bin_result;
  }
  async _uploadWithProgress(str_path, bin_content, fun_progressCb) {
    let devid = this._serial;
    if (devid == "") {
      devid = await (await this.module()).get_serialNumber();
    }
    if (devid == YAPI_INVALID_STRING) {
      let res = new YHTTPRequest(null);
      res.errorType = this.get_errorType();
      res.errorMsg = this.get_errorMessage();
      return res;
    }
    let httpreq = "POST /upload.html";
    let len = bin_content.length;
    if (typeof bin_content == "string" || bin_content instanceof String) {
      bin_content = this._yapi.imm_str2bin(bin_content);
    } else if (bin_content instanceof Array) {
      bin_content = new Uint8Array(bin_content);
    }
    return this._yapi.devRequest(devid, httpreq, new YHTTPBody(str_path, bin_content, fun_progressCb), 0);
  }
  async _uploadEx(str_path, bin_content) {
    let yreq = await this._uploadWithProgress(str_path, bin_content, null);
    if (yreq.errorType != YAPI_SUCCESS) {
      return this._throw(yreq.errorType, yreq.errorMsg, null);
    }
    return yreq.bin_result;
  }
  async _upload(str_path, bin_content) {
    let yreq = await this._uploadWithProgress(str_path, bin_content, null);
    if (yreq.errorType != YAPI_SUCCESS) {
      return this._throw(yreq.errorType, yreq.errorMsg, null);
    }
    return yreq.errorType;
  }
  wait_async(callback, context) {
    let devid = this._serial;
    if (devid == "") {
      this.module().then((module) => module.get_serialNumber().then(() => this.wait_async(callback, context)));
      return YAPI_SUCCESS;
    }
    if (devid == YAPI_INVALID_STRING) {
      callback(context, this);
      return YAPI_SUCCESS;
    }
    let lockdev = this._yapi.imm_getDevice(devid);
    let delayedCode = () => {
      callback(context, this);
    };
    lockdev._pendingQueries = lockdev._pendingQueries.then(delayedCode, delayedCode);
    return YAPI_SUCCESS;
  }
  imm_json_get_key(bin_jsonbuff, str_key) {
    let loadval = JSON.parse(this._yapi.imm_bin2str(bin_jsonbuff));
    if (typeof loadval[str_key] != "undefined") {
      return loadval[str_key];
    }
    return "";
  }
  imm_json_get_string(bin_jsonbuff) {
    return JSON.parse(this._yapi.imm_bin2str(bin_jsonbuff));
  }
  imm_json_get_array(bin_jsonbuff) {
    let loadval = JSON.parse(this._yapi.imm_bin2str(bin_jsonbuff));
    let res = [];
    for (let idx in loadval) {
      res.push(this._yapi.imm_str2bin(JSON.stringify(loadval[idx])));
    }
    return res;
  }
  imm_get_json_path(bin_json, str_path) {
    let json = JSON.parse(this._yapi.imm_bin2str(bin_json));
    let paths = str_path.split("|");
    for (let i = 0; i < paths.length; i++) {
      let tmp = paths[i];
      json = json[tmp];
      if (json == void 0) {
        return new Uint8Array();
      }
    }
    return this._yapi.imm_str2bin(JSON.stringify(json));
  }
  imm_decode_json_string(bin_json) {
    if (bin_json.length == 0) {
      return "";
    }
    return JSON.parse(this._yapi.imm_bin2str(bin_json));
  }
  imm_decode_json_int(bin_json) {
    if (bin_json.length == 0) {
      return 0;
    }
    return JSON.parse(this._yapi.imm_bin2str(bin_json));
  }
  imm_findDataStream(obj_dataset, str_def) {
    let key = obj_dataset.imm_get_functionId() + ":" + str_def;
    if (this._dataStreams[key]) {
      return this._dataStreams[key];
    }
    let words = this._yapi.imm_decodeWords(str_def);
    if (words.length < 14) {
      this._throw(YAPI.VERSION_MISMATCH, "device firwmare is too old", null);
      return null;
    }
    let newDataStream = new YDataStream(this, obj_dataset, words);
    this._dataStreams[key] = newDataStream;
    return newDataStream;
  }
  async clearDataStreamCache() {
    this._dataStreams = {};
  }
  async isOnline() {
    if (this._cacheExpiration > this._yapi.GetTickCount())
      return true;
    let yreq = await this._yapi.funcRequest(this._className, this._func, "", this._yapi.defaultCacheValidity);
    if (yreq.errorType != YAPI_SUCCESS) {
      return yreq.errorType == YAPI_DEVICE_BUSY;
    }
    await this._parse(yreq, this._yapi.defaultCacheValidity);
    return true;
  }
  get_errorType() {
    return this._lastErrorType;
  }
  get_errorMessage() {
    return this._lastErrorMsg;
  }
  async load(msValidity) {
    let yreq = await this._yapi.funcRequest(this._className, this._func, "", msValidity);
    if (yreq.errorType != YAPI_SUCCESS) {
      return this._throw(yreq.errorType, yreq.errorMsg, yreq.errorType);
    }
    await this._parse(yreq, msValidity);
    return YAPI_SUCCESS;
  }
  async clearCache() {
    let devreq = await this._yapi._funcDev(this._className, this._func);
    if (devreq.errorType != YAPI_SUCCESS) {
      return;
    }
    devreq.obj_result.device.imm_dropCache();
    if (this._cacheExpiration > 0) {
      this._cacheExpiration = this._yapi.GetTickCount();
    }
  }
  async module() {
    if (this._serial != "") {
      return YModule.FindModuleInContext(this._yapi, this._serial + ".module");
    }
    let hwid = this._func;
    let resolve;
    if (hwid.indexOf(".") < 0) {
      resolve = this._yapi.imm_resolveFunction(this._className, this._func);
      if (resolve.errorType == YAPI_SUCCESS)
        hwid = resolve.result;
    }
    let dotidx = hwid.indexOf(".");
    if (dotidx >= 0) {
      return YModule.FindModuleInContext(this._yapi, hwid.substr(0, dotidx) + ".module");
    }
    if (await this.load(this._yapi.defaultCacheValidity) == YAPI_SUCCESS) {
      resolve = this._yapi.imm_resolveFunction(this._className, this._func);
      if (resolve.result)
        hwid = resolve.result;
    }
    dotidx = hwid.indexOf(".");
    if (dotidx >= 0) {
      return YModule.FindModuleInContext(this._yapi, hwid.substr(0, dotidx) + ".module");
    }
    return YModule.FindModuleInContext(this._yapi, "module_of_" + this._className + "_" + this._func);
  }
  async get_module() {
    return this.module();
  }
  async get_functionDescriptor() {
    if (this._hwId != "") {
      return this._hwId;
    }
    let hwid = this._func;
    if (hwid.indexOf(".") < 0) {
      let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
      if (resolve.errorType != YAPI_SUCCESS)
        hwid = resolve.result;
    }
    let dotidx = hwid.indexOf(".");
    if (dotidx >= 0) {
      return hwid;
    }
    return Y_FUNCTIONDESCRIPTOR_INVALID;
  }
  async get_userData() {
    return this._userData;
  }
  async set_userData(data) {
    this._userData = data;
  }
};
YFunction.LOGICALNAME_INVALID = YAPI_INVALID_STRING;
YFunction.ADVERTISEDVALUE_INVALID = YAPI_INVALID_STRING;
(function(YFunction2) {
  YFunction2.FUNCTIONDESCRIPTOR_INVALID = YAPI_INVALID_STRING;
  YFunction2.HARDWAREID_INVALID = YAPI_INVALID_STRING;
  YFunction2.FUNCTIONID_INVALID = YAPI_INVALID_STRING;
  YFunction2.FRIENDLYNAME_INVALID = YAPI_INVALID_STRING;
})(YFunction || (YFunction = {}));
var YModule = class extends YFunction {
  constructor(yapi, func) {
    super(yapi, func);
    this._productName = YModule.PRODUCTNAME_INVALID;
    this._serialNumber = YModule.SERIALNUMBER_INVALID;
    this._productId = YModule.PRODUCTID_INVALID;
    this._productRelease = YModule.PRODUCTRELEASE_INVALID;
    this._firmwareRelease = YModule.FIRMWARERELEASE_INVALID;
    this._persistentSettings = YModule.PERSISTENTSETTINGS_INVALID;
    this._luminosity = YModule.LUMINOSITY_INVALID;
    this._beacon = YModule.BEACON_INVALID;
    this._upTime = YModule.UPTIME_INVALID;
    this._usbCurrent = YModule.USBCURRENT_INVALID;
    this._rebootCountdown = YModule.REBOOTCOUNTDOWN_INVALID;
    this._userVar = YModule.USERVAR_INVALID;
    this._valueCallbackModule = null;
    this._logCallback = null;
    this._confChangeCallback = null;
    this._beaconCallback = null;
    this.PRODUCTNAME_INVALID = YAPI_INVALID_STRING;
    this.SERIALNUMBER_INVALID = YAPI_INVALID_STRING;
    this.PRODUCTID_INVALID = YAPI_INVALID_UINT;
    this.PRODUCTRELEASE_INVALID = YAPI_INVALID_UINT;
    this.FIRMWARERELEASE_INVALID = YAPI_INVALID_STRING;
    this.PERSISTENTSETTINGS_LOADED = 0;
    this.PERSISTENTSETTINGS_SAVED = 1;
    this.PERSISTENTSETTINGS_MODIFIED = 2;
    this.PERSISTENTSETTINGS_INVALID = -1;
    this.LUMINOSITY_INVALID = YAPI_INVALID_UINT;
    this.BEACON_OFF = 0;
    this.BEACON_ON = 1;
    this.BEACON_INVALID = -1;
    this.UPTIME_INVALID = YAPI_INVALID_LONG;
    this.USBCURRENT_INVALID = YAPI_INVALID_UINT;
    this.REBOOTCOUNTDOWN_INVALID = YAPI_INVALID_INT;
    this.USERVAR_INVALID = YAPI_INVALID_INT;
    this._className = "Module";
    let devid = this._func;
    let dotidx = devid.indexOf(".");
    if (dotidx > 0)
      devid = devid.substr(0, dotidx);
    let dev = this._yapi.imm_getDevice(devid);
    if (dev) {
      this._serial = dev.imm_getSerialNumber();
      this._funId = "module";
      this._hwId = this._serial + ".module";
    }
  }
  _throw(int_errType, str_errMsg, obj_retVal) {
    this._lastErrorType = int_errType;
    this._lastErrorMsg = str_errMsg;
    return this._yapi._throw(int_errType, str_errMsg, obj_retVal);
  }
  static async _updateModuleCallbackList(YModule_module, bool_add) {
  }
  imm_getDev() {
    let devid = this._func;
    let dotidx = devid.indexOf(".");
    if (dotidx > 0)
      devid = devid.substr(0, dotidx);
    let dev = this._yapi.imm_getDevice(devid);
    if (!dev) {
      this._throw(YAPI_DEVICE_NOT_FOUND, "Device [" + devid + "] is not online", null);
    }
    return dev;
  }
  async forceDeviceRefresh() {
    let dev = this.imm_getDev();
    if (!dev || !this._serial)
      return;
    await this._yapi.ForceDeviceRefresh(this._serial);
    if (this._cacheExpiration > 0) {
      this._cacheExpiration = this._yapi.GetTickCount();
    }
  }
  async functionCount() {
    let dev = this.imm_getDev();
    if (!dev)
      return YAPI_DEVICE_NOT_FOUND;
    return dev.imm_functionCount();
  }
  async functionId(functionIndex) {
    let dev = this.imm_getDev();
    if (!dev)
      return "";
    return dev.imm_functionId(functionIndex);
  }
  async functionType(functionIndex) {
    let dev = this.imm_getDev();
    if (!dev)
      return "";
    return dev.imm_functionType(functionIndex);
  }
  async functionBaseType(functionIndex) {
    let dev = this.imm_getDev();
    if (!dev)
      return "";
    return dev.imm_functionBaseType(functionIndex);
  }
  async functionName(functionIndex) {
    let dev = this.imm_getDev();
    if (!dev)
      return "";
    return dev.imm_functionName(functionIndex);
  }
  async functionValue(functionIndex) {
    let dev = this.imm_getDev();
    if (!dev)
      return "";
    return dev.imm_functionValue(functionIndex);
  }
  async get_logicalName() {
    let dev = this.imm_getDev();
    if (dev != null && this._cache._expiration <= this._yapi.GetTickCount()) {
      return dev.getLogicalName();
    }
    let json_val = await this._getAttr("logicalName");
    return json_val == null ? YModule.LOGICALNAME_INVALID : json_val;
  }
  async set_logicalName(newval) {
    let res = await super.set_logicalName(newval);
    let dev = this.imm_getDev();
    if (dev != null) {
      dev.imm_dropCache();
    }
    return res;
  }
  imm_flattenJsonStruct_internal(jsoncomplex) {
    let decoded = JSON.parse(this._yapi.imm_bin2str(jsoncomplex));
    let attrs = [];
    for (let function_name in decoded) {
      if (function_name == "services") {
        continue;
      }
      let function_attrs = decoded[function_name];
      for (let attr_name in function_attrs) {
        let attr_value = function_attrs[attr_name];
        if (attr_value === null || typeof attr_value === "object") {
          continue;
        }
        let flat = function_name + "/" + attr_name + "=" + attr_value;
        attrs.push(flat);
      }
    }
    return this._yapi.imm_str2bin(JSON.stringify(attrs));
  }
  async get_subDevices_internal() {
    let baseUrl = await this.get_url_internal();
    if (!baseUrl) {
      return [];
    }
    let hub = null;
    let hubUrl = "";
    for (let i = 0; i < this._yapi._connectedHubs.length; i++) {
      hubUrl = this._yapi._connectedHubs[i].imm_getRootUrl();
      if (baseUrl.slice(0, hubUrl.length) == hubUrl) {
        hub = this._yapi._connectedHubs[i];
        break;
      }
    }
    if (!hub || !hubUrl) {
      return [];
    }
    let hubSerial = hub.serialByYdx[0];
    if (hubSerial != this._serial) {
      return [];
    }
    let res = [];
    for (let serial in this._yapi._devs) {
      let rooturl = this._yapi._devs[serial].imm_getRootUrl();
      if (rooturl.substr(0, hubUrl.length) == hubUrl && serial != hubSerial) {
        res.push(serial);
      }
    }
    return res;
  }
  async get_parentHub_internal() {
    let baseUrl = await this.get_url_internal();
    if (!baseUrl) {
      return "";
    }
    let hub = null;
    for (let i = 0; i < this._yapi._connectedHubs.length; i++) {
      let hubUrl = this._yapi._connectedHubs[i].imm_getRootUrl();
      if (baseUrl.slice(0, hubUrl.length) == hubUrl) {
        hub = this._yapi._connectedHubs[i];
        break;
      }
    }
    if (!hub) {
      return "";
    }
    let hubSerial = hub.serialByYdx[0];
    if (hubSerial == this._serial) {
      return "";
    }
    return hubSerial;
  }
  async get_url_internal() {
    let devid = this._serial;
    if (devid == "") {
      devid = await this.get_serialNumber();
    }
    if (devid == YAPI_INVALID_STRING) {
      return "";
    }
    let lockdev = this._yapi.imm_getDevice(devid);
    if (!lockdev) {
      return "";
    }
    return lockdev.imm_getRootUrl();
  }
  async _startStopDevLog_internal(str_serial, bool_start) {
    let dev = this.imm_getDev();
    if (dev != null) {
      return dev.imm_registerLogCallback(this._logCallback);
    }
  }
  imm_parseAttr(name, val) {
    switch (name) {
      case "productName":
        this._productName = val;
        return 1;
      case "serialNumber":
        this._serialNumber = val;
        return 1;
      case "productId":
        this._productId = val;
        return 1;
      case "productRelease":
        this._productRelease = val;
        return 1;
      case "firmwareRelease":
        this._firmwareRelease = val;
        return 1;
      case "persistentSettings":
        this._persistentSettings = val;
        return 1;
      case "luminosity":
        this._luminosity = val;
        return 1;
      case "beacon":
        this._beacon = val;
        return 1;
      case "upTime":
        this._upTime = val;
        return 1;
      case "usbCurrent":
        this._usbCurrent = val;
        return 1;
      case "rebootCountdown":
        this._rebootCountdown = val;
        return 1;
      case "userVar":
        this._userVar = val;
        return 1;
    }
    return super.imm_parseAttr(name, val);
  }
  async get_productName() {
    let res;
    let dev;
    if (this._cacheExpiration == 0) {
      dev = this.imm_getDev();
      if (!(dev == null)) {
        return dev.imm_getProductName();
      }
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YModule.PRODUCTNAME_INVALID;
      }
    }
    res = this._productName;
    return res;
  }
  async get_serialNumber() {
    let res;
    let dev;
    if (this._cacheExpiration == 0) {
      dev = this.imm_getDev();
      if (!(dev == null)) {
        return dev.imm_getSerialNumber();
      }
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YModule.SERIALNUMBER_INVALID;
      }
    }
    res = this._serialNumber;
    return res;
  }
  async get_productId() {
    let res;
    let dev;
    if (this._cacheExpiration == 0) {
      dev = this.imm_getDev();
      if (!(dev == null)) {
        return dev.imm_getProductId();
      }
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YModule.PRODUCTID_INVALID;
      }
    }
    res = this._productId;
    return res;
  }
  async get_productRelease() {
    let res;
    if (this._cacheExpiration == 0) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YModule.PRODUCTRELEASE_INVALID;
      }
    }
    res = this._productRelease;
    return res;
  }
  async get_firmwareRelease() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YModule.FIRMWARERELEASE_INVALID;
      }
    }
    res = this._firmwareRelease;
    return res;
  }
  async get_persistentSettings() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YModule.PERSISTENTSETTINGS_INVALID;
      }
    }
    res = this._persistentSettings;
    return res;
  }
  async set_persistentSettings(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("persistentSettings", rest_val);
  }
  async get_luminosity() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YModule.LUMINOSITY_INVALID;
      }
    }
    res = this._luminosity;
    return res;
  }
  async set_luminosity(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("luminosity", rest_val);
  }
  async get_beacon() {
    let res;
    let dev;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      dev = this.imm_getDev();
      if (!(dev == null)) {
        return dev.imm_getBeacon();
      }
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YModule.BEACON_INVALID;
      }
    }
    res = this._beacon;
    return res;
  }
  async set_beacon(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("beacon", rest_val);
  }
  async get_upTime() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YModule.UPTIME_INVALID;
      }
    }
    res = this._upTime;
    return res;
  }
  async get_usbCurrent() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YModule.USBCURRENT_INVALID;
      }
    }
    res = this._usbCurrent;
    return res;
  }
  async get_rebootCountdown() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YModule.REBOOTCOUNTDOWN_INVALID;
      }
    }
    res = this._rebootCountdown;
    return res;
  }
  async set_rebootCountdown(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("rebootCountdown", rest_val);
  }
  async get_userVar() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YModule.USERVAR_INVALID;
      }
    }
    res = this._userVar;
    return res;
  }
  async set_userVar(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("userVar", rest_val);
  }
  static FindModule(func) {
    let obj;
    let cleanHwId;
    let modpos;
    cleanHwId = func;
    modpos = func.indexOf(".module");
    if (modpos != func.length - 7) {
      cleanHwId = func + ".module";
    }
    obj = YFunction._FindFromCache("Module", cleanHwId);
    if (obj == null) {
      obj = new YModule(YAPI, cleanHwId);
      YFunction._AddToCache("Module", cleanHwId, obj);
    }
    return obj;
  }
  static FindModuleInContext(yctx, func) {
    let obj;
    let cleanHwId;
    let modpos;
    cleanHwId = func;
    modpos = func.indexOf(".module");
    if (modpos != func.length - 7) {
      cleanHwId = func + ".module";
    }
    obj = YFunction._FindFromCacheInContext(yctx, "Module", cleanHwId);
    if (obj == null) {
      obj = new YModule(yctx, cleanHwId);
      YFunction._AddToCache("Module", cleanHwId, obj);
    }
    return obj;
  }
  async registerValueCallback(callback) {
    let val;
    if (callback != null) {
      await YFunction._UpdateValueCallbackList(this, true);
    } else {
      await YFunction._UpdateValueCallbackList(this, false);
    }
    this._valueCallbackModule = callback;
    if (callback != null && await this.isOnline()) {
      val = this._advertisedValue;
      if (!(val == "")) {
        await this._invokeValueCallback(val);
      }
    }
    return 0;
  }
  async _invokeValueCallback(value) {
    if (this._valueCallbackModule != null) {
      try {
        await this._valueCallbackModule(this, value);
      } catch (e) {
        this._yapi.imm_log("Exception in valueCallback:", e);
      }
    } else {
      await super._invokeValueCallback(value);
    }
    return 0;
  }
  async get_productNameAndRevision() {
    let prodname;
    let prodrel;
    let fullname;
    prodname = await this.get_productName();
    prodrel = await this.get_productRelease();
    if (prodrel > 1) {
      fullname = prodname + " rev. " + String.fromCharCode(64 + prodrel);
    } else {
      fullname = prodname;
    }
    return fullname;
  }
  async saveToFlash() {
    return await this.set_persistentSettings(1);
  }
  async revertFromFlash() {
    return await this.set_persistentSettings(0);
  }
  async reboot(secBeforeReboot) {
    return await this.set_rebootCountdown(secBeforeReboot);
  }
  async triggerFirmwareUpdate(secBeforeReboot) {
    return await this.set_rebootCountdown(-secBeforeReboot);
  }
  async _startStopDevLog(serial, start) {
    return await this._startStopDevLog_internal(serial, start);
  }
  async registerLogCallback(callback) {
    let serial;
    serial = await this.get_serialNumber();
    if (serial == YAPI_INVALID_STRING) {
      return YAPI_DEVICE_NOT_FOUND;
    }
    this._logCallback = callback;
    await this._startStopDevLog(serial, callback != null);
    return 0;
  }
  async get_logCallback() {
    return this._logCallback;
  }
  async registerConfigChangeCallback(callback) {
    if (callback != null) {
      await YModule._updateModuleCallbackList(this, true);
    } else {
      await YModule._updateModuleCallbackList(this, false);
    }
    this._confChangeCallback = callback;
    return 0;
  }
  async _invokeConfigChangeCallback() {
    if (this._confChangeCallback != null) {
      try {
        await this._confChangeCallback(this);
      } catch (e) {
        this._yapi.imm_log("Exception in configChangeCallback:", e);
      }
    }
    return 0;
  }
  async registerBeaconCallback(callback) {
    if (callback != null) {
      await YModule._updateModuleCallbackList(this, true);
    } else {
      await YModule._updateModuleCallbackList(this, false);
    }
    this._beaconCallback = callback;
    return 0;
  }
  async _invokeBeaconCallback(beaconState) {
    if (this._beaconCallback != null) {
      try {
        await this._beaconCallback(this, beaconState);
      } catch (e) {
        this._yapi.imm_log("Exception in beaconCallback:", e);
      }
    }
    return 0;
  }
  async triggerConfigChangeCallback() {
    await this._setAttr("persistentSettings", "2");
    return 0;
  }
  async checkFirmware(path, onlynew) {
    let serial;
    let release;
    let tmp_res;
    if (onlynew) {
      release = YAPIContext.imm_atoi(await this.get_firmwareRelease());
    } else {
      release = 0;
    }
    serial = await this.get_serialNumber();
    tmp_res = await YFirmwareUpdate.CheckFirmware(serial, path, release);
    if (tmp_res.indexOf("error:") == 0) {
      this._throw(YAPI_INVALID_ARGUMENT, tmp_res);
    }
    return tmp_res;
  }
  async updateFirmwareEx(path, force) {
    let serial;
    let settings;
    serial = await this.get_serialNumber();
    settings = await this.get_allSettings();
    if (settings.length == 0) {
      this._throw(YAPI_IO_ERROR, "Unable to get device settings");
      settings = this._yapi.imm_str2bin("error:Unable to get device settings");
    }
    return new YFirmwareUpdate(this._yapi, serial, path, settings, force);
  }
  async updateFirmware(path) {
    return await this.updateFirmwareEx(path, false);
  }
  async get_allSettings() {
    let settings;
    let json;
    let res;
    let sep;
    let name;
    let item;
    let t_type;
    let pageid;
    let url;
    let file_data;
    let file_data_bin;
    let temp_data_bin;
    let ext_settings;
    let filelist = [];
    let templist = [];
    settings = await this._download("api.json");
    if (settings.length == 0) {
      return settings;
    }
    ext_settings = ', "extras":[';
    templist = await this.get_functionIds("Temperature");
    sep = "";
    for (let ii in templist) {
      if (YAPIContext.imm_atoi(await this.get_firmwareRelease()) > 9e3) {
        url = "api/" + templist[ii] + "/sensorType";
        t_type = this._yapi.imm_bin2str(await this._download(url));
        if (t_type == "RES_NTC" || t_type == "RES_LINEAR") {
          pageid = templist[ii].substr(11, templist[ii].length - 11);
          if (pageid == "") {
            pageid = "1";
          }
          temp_data_bin = await this._download("extra.json?page=" + pageid);
          if (temp_data_bin.length > 0) {
            item = sep + '{"fid":"' + templist[ii] + '", "json":' + this._yapi.imm_bin2str(temp_data_bin) + "}\n";
            ext_settings = ext_settings + item;
            sep = ",";
          }
        }
      }
    }
    ext_settings = ext_settings + '],\n"files":[';
    if (await this.hasFunction("files")) {
      json = await this._download("files.json?a=dir&f=");
      if (json.length == 0) {
        return json;
      }
      filelist = this.imm_json_get_array(json);
      sep = "";
      for (let ii in filelist) {
        name = this.imm_json_get_key(filelist[ii], "name");
        if (name.length > 0 && !(name == "startupConf.json")) {
          file_data_bin = await this._download(this.imm_escapeAttr(name));
          file_data = this._yapi.imm_bin2hexstr(file_data_bin);
          item = sep + '{"name":"' + name + '", "data":"' + file_data + '"}\n';
          ext_settings = ext_settings + item;
          sep = ",";
        }
      }
    }
    res = this._yapi.imm_str2bin('{ "api":' + this._yapi.imm_bin2str(settings) + ext_settings + "]}");
    return res;
  }
  async loadThermistorExtra(funcId, jsonExtra) {
    let values = [];
    let url;
    let curr;
    let binCurr;
    let currTemp;
    let binCurrTemp;
    let ofs;
    let size;
    url = "api/" + funcId + ".json?command=Z";
    await this._download(url);
    values = this.imm_json_get_array(this._yapi.imm_str2bin(jsonExtra));
    ofs = 0;
    size = values.length;
    while (ofs + 1 < size) {
      binCurr = values[ofs];
      binCurrTemp = values[ofs + 1];
      curr = this.imm_json_get_string(binCurr);
      currTemp = this.imm_json_get_string(binCurrTemp);
      url = "api/" + funcId + ".json?command=m" + curr + ":" + currTemp;
      await this._download(url);
      ofs = ofs + 2;
    }
    return YAPI_SUCCESS;
  }
  async set_extraSettings(jsonExtra) {
    let extras = [];
    let tmp;
    let functionId;
    let data;
    extras = this.imm_json_get_array(this._yapi.imm_str2bin(jsonExtra));
    for (let ii in extras) {
      tmp = this.imm_get_json_path(extras[ii], "fid");
      functionId = this.imm_json_get_string(tmp);
      data = this.imm_get_json_path(extras[ii], "json");
      if (await this.hasFunction(functionId)) {
        await this.loadThermistorExtra(functionId, this._yapi.imm_bin2str(data));
      }
    }
    return YAPI_SUCCESS;
  }
  async set_allSettingsAndFiles(settings) {
    let down;
    let json_bin;
    let json_api;
    let json_files;
    let json_extra;
    let fuperror;
    let globalres;
    fuperror = 0;
    json_api = this.imm_get_json_path(settings, "api");
    if (json_api.length == 0) {
      return await this.set_allSettings(settings);
    }
    json_extra = this.imm_get_json_path(settings, "extras");
    if (json_extra.length > 0) {
      await this.set_extraSettings(this._yapi.imm_bin2str(json_extra));
    }
    await this.set_allSettings(json_api);
    if (await this.hasFunction("files")) {
      let files = [];
      let res;
      let tmp;
      let name;
      let data;
      down = await this._download("files.json?a=format");
      down = this.imm_get_json_path(down, "res");
      res = this.imm_json_get_string(down);
      if (!(res == "ok")) {
        return this._throw(YAPI_IO_ERROR, "format failed", YAPI_IO_ERROR);
      }
      json_files = this.imm_get_json_path(settings, "files");
      files = this.imm_json_get_array(json_files);
      for (let ii in files) {
        tmp = this.imm_get_json_path(files[ii], "name");
        name = this.imm_json_get_string(tmp);
        tmp = this.imm_get_json_path(files[ii], "data");
        data = this.imm_json_get_string(tmp);
        if (name == "") {
          fuperror = fuperror + 1;
        } else {
          await this._upload(name, this._yapi.imm_hexstr2bin(data));
        }
      }
    }
    globalres = await this.set_allSettings(json_api);
    if (!(fuperror == 0)) {
      return this._throw(YAPI_IO_ERROR, "Error during file upload", YAPI_IO_ERROR);
    }
    return globalres;
  }
  async hasFunction(funcId) {
    let count;
    let i;
    let fid;
    count = await this.functionCount();
    i = 0;
    while (i < count) {
      fid = await this.functionId(i);
      if (fid == funcId) {
        return true;
      }
      i = i + 1;
    }
    return false;
  }
  async get_functionIds(funType) {
    let count;
    let i;
    let ftype;
    let res = [];
    count = await this.functionCount();
    i = 0;
    while (i < count) {
      ftype = await this.functionType(i);
      if (ftype == funType) {
        res.push(await this.functionId(i));
      } else {
        ftype = await this.functionBaseType(i);
        if (ftype == funType) {
          res.push(await this.functionId(i));
        }
      }
      i = i + 1;
    }
    return res;
  }
  imm_flattenJsonStruct(jsoncomplex) {
    return this.imm_flattenJsonStruct_internal(jsoncomplex);
  }
  async calibVersion(cparams) {
    if (cparams == "0,") {
      return 3;
    }
    if (cparams.indexOf(",") >= 0) {
      if (cparams.indexOf(" ") > 0) {
        return 3;
      } else {
        return 1;
      }
    }
    if (cparams == "" || cparams == "0") {
      return 1;
    }
    if (cparams.length < 2 || cparams.indexOf(".") >= 0) {
      return 0;
    } else {
      return 2;
    }
  }
  async calibScale(unit_name, sensorType) {
    if (unit_name == "g" || unit_name == "gauss" || unit_name == "W") {
      return 1e3;
    }
    if (unit_name == "C") {
      if (sensorType == "") {
        return 16;
      }
      if (YAPIContext.imm_atoi(sensorType) < 8) {
        return 16;
      } else {
        return 100;
      }
    }
    if (unit_name == "m" || unit_name == "deg") {
      return 10;
    }
    return 1;
  }
  async calibOffset(unit_name) {
    if (unit_name == "% RH" || unit_name == "mbar" || unit_name == "lx") {
      return 0;
    }
    return 32767;
  }
  async calibConvert(param, currentFuncValue, unit_name, sensorType) {
    let paramVer;
    let funVer;
    let funScale;
    let funOffset;
    let paramScale;
    let paramOffset;
    let words = [];
    let words_str = [];
    let calibData = [];
    let iCalib = [];
    let calibType;
    let i;
    let maxSize;
    let ratio;
    let nPoints;
    let wordVal;
    paramVer = await this.calibVersion(param);
    funVer = await this.calibVersion(currentFuncValue);
    funScale = await this.calibScale(unit_name, sensorType);
    funOffset = await this.calibOffset(unit_name);
    paramScale = funScale;
    paramOffset = funOffset;
    if (funVer < 3) {
      if (funVer == 2) {
        words = this._yapi.imm_decodeWords(currentFuncValue);
        if (words[0] == 1366 && words[1] == 12500) {
          funScale = 1;
          funOffset = 0;
        } else {
          funScale = words[1];
          funOffset = words[0];
        }
      } else {
        if (funVer == 1) {
          if (currentFuncValue == "" || YAPIContext.imm_atoi(currentFuncValue) > 10) {
            funScale = 0;
          }
        }
      }
    }
    calibData.length = 0;
    calibType = 0;
    if (paramVer < 3) {
      if (paramVer == 2) {
        words = this._yapi.imm_decodeWords(param);
        if (words[0] == 1366 && words[1] == 12500) {
          paramScale = 1;
          paramOffset = 0;
        } else {
          paramScale = words[1];
          paramOffset = words[0];
        }
        if (words.length >= 3 && words[2] > 0) {
          maxSize = 3 + 2 * (words[2] % 10);
          if (maxSize > words.length) {
            maxSize = words.length;
          }
          i = 3;
          while (i < maxSize) {
            calibData.push(words[i]);
            i = i + 1;
          }
        }
      } else {
        if (paramVer == 1) {
          words_str = param.split(",");
          for (let ii in words_str) {
            words.push(YAPIContext.imm_atoi(words_str[ii]));
          }
          if (param == "" || words[0] > 10) {
            paramScale = 0;
          }
          if (words.length > 0 && words[0] > 0) {
            maxSize = 1 + 2 * (words[0] % 10);
            if (maxSize > words.length) {
              maxSize = words.length;
            }
            i = 1;
            while (i < maxSize) {
              calibData.push(words[i]);
              i = i + 1;
            }
          }
        } else {
          if (paramVer == 0) {
            ratio = YAPIContext.imm_atof(param);
            if (ratio > 0) {
              calibData.push(0);
              calibData.push(0);
              calibData.push(Math.round(65535 / ratio));
              calibData.push(65535);
            }
          }
        }
      }
      i = 0;
      while (i < calibData.length) {
        if (paramScale > 0) {
          calibData[i] = (calibData[i] - paramOffset) / paramScale;
        } else {
          calibData[i] = this._yapi.imm_decimalToDouble(Math.round(calibData[i]));
        }
        i = i + 1;
      }
    } else {
      iCalib = this._yapi.imm_decodeFloats(param);
      calibType = Math.round(iCalib[0] / 1e3);
      if (calibType >= 30) {
        calibType = calibType - 30;
      }
      i = 1;
      while (i < iCalib.length) {
        calibData.push(iCalib[i] / 1e3);
        i = i + 1;
      }
    }
    if (funVer >= 3) {
      if (calibData.length == 0) {
        param = "0,";
      } else {
        param = (30 + calibType).toString();
        i = 0;
        while (i < calibData.length) {
          if ((i & 1) > 0) {
            param = param + ":";
          } else {
            param = param + " ";
          }
          param = param + Math.round(calibData[i] * 1e3 / 1e3).toString();
          i = i + 1;
        }
        param = param + ",";
      }
    } else {
      if (funVer >= 1) {
        nPoints = calibData.length / 2 >> 0;
        param = nPoints.toString();
        i = 0;
        while (i < 2 * nPoints) {
          if (funScale == 0) {
            wordVal = this._yapi.imm_doubleToDecimal(Math.round(calibData[i]));
          } else {
            wordVal = calibData[i] * funScale + funOffset;
          }
          param = param + "," + Math.round(wordVal).toString();
          i = i + 1;
        }
      } else {
        if (calibData.length == 4) {
          param = Math.round(1e3 * (calibData[3] - calibData[1]) / calibData[2] - calibData[0]).toString();
        }
      }
    }
    return param;
  }
  async _tryExec(url) {
    let res;
    let done;
    res = YAPI_SUCCESS;
    done = 1;
    try {
      await this._download(url);
    } catch (e) {
      done = 0;
    }
    if (done == 0) {
      try {
        await YAPI.Sleep(500);
        await this._download(url);
      } catch (e) {
        res = await this.get_errorType();
      }
    }
    return res;
  }
  async set_allSettings(settings) {
    let restoreLast = [];
    let old_json_flat;
    let old_dslist = [];
    let old_jpath = [];
    let old_jpath_len = [];
    let old_val_arr = [];
    let actualSettings;
    let new_dslist = [];
    let new_jpath = [];
    let new_jpath_len = [];
    let new_val_arr = [];
    let cpos;
    let eqpos;
    let leng;
    let i;
    let j;
    let subres;
    let res;
    let njpath;
    let jpath;
    let fun;
    let attr;
    let value;
    let old_serial;
    let new_serial;
    let url;
    let tmp;
    let binTmp;
    let sensorType;
    let unit_name;
    let newval;
    let oldval;
    let old_calib;
    let each_str;
    let do_update;
    let found;
    res = YAPI_SUCCESS;
    binTmp = this.imm_get_json_path(settings, "api");
    if (binTmp.length > 0) {
      settings = binTmp;
    }
    old_serial = "";
    oldval = "";
    newval = "";
    old_json_flat = this.imm_flattenJsonStruct(settings);
    old_dslist = this.imm_json_get_array(old_json_flat);
    for (let ii in old_dslist) {
      each_str = this.imm_json_get_string(old_dslist[ii]);
      leng = each_str.length;
      eqpos = each_str.indexOf("=");
      if (eqpos < 0 || leng == 0) {
        this._throw(YAPI_INVALID_ARGUMENT, "Invalid settings");
        return YAPI_INVALID_ARGUMENT;
      }
      jpath = each_str.substr(0, eqpos);
      eqpos = eqpos + 1;
      value = each_str.substr(eqpos, leng - eqpos);
      old_jpath.push(jpath);
      old_jpath_len.push(jpath.length);
      old_val_arr.push(value);
      if (jpath == "module/serialNumber") {
        old_serial = value;
      }
    }
    try {
      actualSettings = await this._download("api.json");
    } catch (e) {
      await YAPI.Sleep(500);
      actualSettings = await this._download("api.json");
    }
    new_serial = await this.get_serialNumber();
    if (old_serial == new_serial || old_serial == "") {
      old_serial = "_NO_SERIAL_FILTER_";
    }
    actualSettings = this.imm_flattenJsonStruct(actualSettings);
    new_dslist = this.imm_json_get_array(actualSettings);
    for (let ii in new_dslist) {
      each_str = this.imm_json_get_string(new_dslist[ii]);
      leng = each_str.length;
      eqpos = each_str.indexOf("=");
      if (eqpos < 0 || leng == 0) {
        this._throw(YAPI_INVALID_ARGUMENT, "Invalid settings");
        return YAPI_INVALID_ARGUMENT;
      }
      jpath = each_str.substr(0, eqpos);
      eqpos = eqpos + 1;
      value = each_str.substr(eqpos, leng - eqpos);
      new_jpath.push(jpath);
      new_jpath_len.push(jpath.length);
      new_val_arr.push(value);
    }
    i = 0;
    while (i < new_jpath.length) {
      njpath = new_jpath[i];
      leng = njpath.length;
      cpos = njpath.indexOf("/");
      if (cpos < 0 || leng == 0) {
        continue;
      }
      fun = njpath.substr(0, cpos);
      cpos = cpos + 1;
      attr = njpath.substr(cpos, leng - cpos);
      do_update = true;
      if (fun == "services") {
        do_update = false;
      }
      if (do_update && attr == "firmwareRelease") {
        do_update = false;
      }
      if (do_update && attr == "usbCurrent") {
        do_update = false;
      }
      if (do_update && attr == "upTime") {
        do_update = false;
      }
      if (do_update && attr == "persistentSettings") {
        do_update = false;
      }
      if (do_update && attr == "adminPassword") {
        do_update = false;
      }
      if (do_update && attr == "userPassword") {
        do_update = false;
      }
      if (do_update && attr == "rebootCountdown") {
        do_update = false;
      }
      if (do_update && attr == "advertisedValue") {
        do_update = false;
      }
      if (do_update && attr == "poeCurrent") {
        do_update = false;
      }
      if (do_update && attr == "readiness") {
        do_update = false;
      }
      if (do_update && attr == "ipAddress") {
        do_update = false;
      }
      if (do_update && attr == "subnetMask") {
        do_update = false;
      }
      if (do_update && attr == "router") {
        do_update = false;
      }
      if (do_update && attr == "linkQuality") {
        do_update = false;
      }
      if (do_update && attr == "ssid") {
        do_update = false;
      }
      if (do_update && attr == "channel") {
        do_update = false;
      }
      if (do_update && attr == "security") {
        do_update = false;
      }
      if (do_update && attr == "message") {
        do_update = false;
      }
      if (do_update && attr == "signalValue") {
        do_update = false;
      }
      if (do_update && attr == "currentValue") {
        do_update = false;
      }
      if (do_update && attr == "currentRawValue") {
        do_update = false;
      }
      if (do_update && attr == "currentRunIndex") {
        do_update = false;
      }
      if (do_update && attr == "pulseTimer") {
        do_update = false;
      }
      if (do_update && attr == "lastTimePressed") {
        do_update = false;
      }
      if (do_update && attr == "lastTimeReleased") {
        do_update = false;
      }
      if (do_update && attr == "filesCount") {
        do_update = false;
      }
      if (do_update && attr == "freeSpace") {
        do_update = false;
      }
      if (do_update && attr == "timeUTC") {
        do_update = false;
      }
      if (do_update && attr == "rtcTime") {
        do_update = false;
      }
      if (do_update && attr == "unixTime") {
        do_update = false;
      }
      if (do_update && attr == "dateTime") {
        do_update = false;
      }
      if (do_update && attr == "rawValue") {
        do_update = false;
      }
      if (do_update && attr == "lastMsg") {
        do_update = false;
      }
      if (do_update && attr == "delayedPulseTimer") {
        do_update = false;
      }
      if (do_update && attr == "rxCount") {
        do_update = false;
      }
      if (do_update && attr == "txCount") {
        do_update = false;
      }
      if (do_update && attr == "msgCount") {
        do_update = false;
      }
      if (do_update && attr == "rxMsgCount") {
        do_update = false;
      }
      if (do_update && attr == "txMsgCount") {
        do_update = false;
      }
      if (do_update) {
        do_update = false;
        j = 0;
        found = false;
        newval = new_val_arr[i];
        while (j < old_jpath.length && !found) {
          if (new_jpath_len[i] == old_jpath_len[j] && new_jpath[i] == old_jpath[j]) {
            found = true;
            oldval = old_val_arr[j];
            if (!(newval == oldval) && !(oldval == old_serial)) {
              do_update = true;
            }
          }
          j = j + 1;
        }
      }
      if (do_update) {
        if (attr == "calibrationParam") {
          old_calib = "";
          unit_name = "";
          sensorType = "";
          j = 0;
          found = false;
          while (j < old_jpath.length && !found) {
            if (new_jpath_len[i] == old_jpath_len[j] && new_jpath[i] == old_jpath[j]) {
              found = true;
              old_calib = old_val_arr[j];
            }
            j = j + 1;
          }
          tmp = fun + "/unit";
          j = 0;
          found = false;
          while (j < new_jpath.length && !found) {
            if (tmp == new_jpath[j]) {
              found = true;
              unit_name = new_val_arr[j];
            }
            j = j + 1;
          }
          tmp = fun + "/sensorType";
          j = 0;
          found = false;
          while (j < new_jpath.length && !found) {
            if (tmp == new_jpath[j]) {
              found = true;
              sensorType = new_val_arr[j];
            }
            j = j + 1;
          }
          newval = await this.calibConvert(old_calib, new_val_arr[i], unit_name, sensorType);
          url = "api/" + fun + ".json?" + attr + "=" + this.imm_escapeAttr(newval);
          subres = await this._tryExec(url);
          if (res == YAPI_SUCCESS && subres != YAPI_SUCCESS) {
            res = subres;
          }
        } else {
          url = "api/" + fun + ".json?" + attr + "=" + this.imm_escapeAttr(oldval);
          if (attr == "resolution") {
            restoreLast.push(url);
          } else {
            subres = await this._tryExec(url);
            if (res == YAPI_SUCCESS && subres != YAPI_SUCCESS) {
              res = subres;
            }
          }
        }
      }
      i = i + 1;
    }
    for (let ii in restoreLast) {
      subres = await this._tryExec(restoreLast[ii]);
      if (res == YAPI_SUCCESS && subres != YAPI_SUCCESS) {
        res = subres;
      }
    }
    await this.clearCache();
    return res;
  }
  async addFileToHTTPCallback(filename) {
    let content;
    content = await this._download("@YCB+" + filename);
    if (content.length == 0) {
      return YAPI_NOT_SUPPORTED;
    }
    return YAPI_SUCCESS;
  }
  async get_hardwareId() {
    let serial;
    serial = await this.get_serialNumber();
    return serial + ".module";
  }
  async download(pathname) {
    return await this._download(pathname);
  }
  async get_icon2d() {
    return await this._download("icon2d.png");
  }
  async get_lastLogs() {
    let content;
    content = await this._download("logs.txt");
    return this._yapi.imm_bin2str(content);
  }
  async log(text) {
    return await this._upload("logs.txt", this._yapi.imm_str2bin(text));
  }
  async get_subDevices() {
    return await this.get_subDevices_internal();
  }
  async get_parentHub() {
    return await this.get_parentHub_internal();
  }
  async get_url() {
    return await this.get_url_internal();
  }
  nextModule() {
    let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
    if (resolve.errorType != YAPI.SUCCESS)
      return null;
    let next_hwid = this._yapi.imm_getNextHardwareId(this._className, resolve.result);
    if (next_hwid == null)
      return null;
    return YModule.FindModuleInContext(this._yapi, next_hwid);
  }
  static FirstModule() {
    let next_hwid = YAPI.imm_getFirstHardwareId("Module");
    if (next_hwid == null)
      return null;
    return YModule.FindModule(next_hwid);
  }
  static FirstModuleInContext(yctx) {
    let next_hwid = yctx.imm_getFirstHardwareId("Module");
    if (next_hwid == null)
      return null;
    return YModule.FindModuleInContext(yctx, next_hwid);
  }
};
YModule.PRODUCTNAME_INVALID = YAPI_INVALID_STRING;
YModule.SERIALNUMBER_INVALID = YAPI_INVALID_STRING;
YModule.PRODUCTID_INVALID = YAPI_INVALID_UINT;
YModule.PRODUCTRELEASE_INVALID = YAPI_INVALID_UINT;
YModule.FIRMWARERELEASE_INVALID = YAPI_INVALID_STRING;
YModule.PERSISTENTSETTINGS_LOADED = 0;
YModule.PERSISTENTSETTINGS_SAVED = 1;
YModule.PERSISTENTSETTINGS_MODIFIED = 2;
YModule.PERSISTENTSETTINGS_INVALID = -1;
YModule.LUMINOSITY_INVALID = YAPI_INVALID_UINT;
YModule.BEACON_OFF = 0;
YModule.BEACON_ON = 1;
YModule.BEACON_INVALID = -1;
YModule.UPTIME_INVALID = YAPI_INVALID_LONG;
YModule.USBCURRENT_INVALID = YAPI_INVALID_UINT;
YModule.REBOOTCOUNTDOWN_INVALID = YAPI_INVALID_INT;
YModule.USERVAR_INVALID = YAPI_INVALID_INT;
var YSensor = class extends YFunction {
  constructor(yapi, func) {
    super(yapi, func);
    this._unit = YSensor.UNIT_INVALID;
    this._currentValue = YSensor.CURRENTVALUE_INVALID;
    this._lowestValue = YSensor.LOWESTVALUE_INVALID;
    this._highestValue = YSensor.HIGHESTVALUE_INVALID;
    this._currentRawValue = YSensor.CURRENTRAWVALUE_INVALID;
    this._logFrequency = YSensor.LOGFREQUENCY_INVALID;
    this._reportFrequency = YSensor.REPORTFREQUENCY_INVALID;
    this._advMode = YSensor.ADVMODE_INVALID;
    this._calibrationParam = YSensor.CALIBRATIONPARAM_INVALID;
    this._resolution = YSensor.RESOLUTION_INVALID;
    this._sensorState = YSensor.SENSORSTATE_INVALID;
    this._valueCallbackSensor = null;
    this._timedReportCallbackSensor = null;
    this._prevTimedReport = 0;
    this._iresol = 0;
    this._offset = 0;
    this._scale = 0;
    this._decexp = 0;
    this._caltyp = 0;
    this._calpar = [];
    this._calraw = [];
    this._calref = [];
    this.imm_calhdl = null;
    this.UNIT_INVALID = YAPI_INVALID_STRING;
    this.CURRENTVALUE_INVALID = YAPI_INVALID_DOUBLE;
    this.LOWESTVALUE_INVALID = YAPI_INVALID_DOUBLE;
    this.HIGHESTVALUE_INVALID = YAPI_INVALID_DOUBLE;
    this.CURRENTRAWVALUE_INVALID = YAPI_INVALID_DOUBLE;
    this.LOGFREQUENCY_INVALID = YAPI_INVALID_STRING;
    this.REPORTFREQUENCY_INVALID = YAPI_INVALID_STRING;
    this.ADVMODE_IMMEDIATE = 0;
    this.ADVMODE_PERIOD_AVG = 1;
    this.ADVMODE_PERIOD_MIN = 2;
    this.ADVMODE_PERIOD_MAX = 3;
    this.ADVMODE_INVALID = -1;
    this.CALIBRATIONPARAM_INVALID = YAPI_INVALID_STRING;
    this.RESOLUTION_INVALID = YAPI_INVALID_DOUBLE;
    this.SENSORSTATE_INVALID = YAPI_INVALID_INT;
    this._className = "Sensor";
  }
  imm_parseAttr(name, val) {
    switch (name) {
      case "unit":
        this._unit = val;
        return 1;
      case "currentValue":
        this._currentValue = Math.round(val / 65.536) / 1e3;
        return 1;
      case "lowestValue":
        this._lowestValue = Math.round(val / 65.536) / 1e3;
        return 1;
      case "highestValue":
        this._highestValue = Math.round(val / 65.536) / 1e3;
        return 1;
      case "currentRawValue":
        this._currentRawValue = Math.round(val / 65.536) / 1e3;
        return 1;
      case "logFrequency":
        this._logFrequency = val;
        return 1;
      case "reportFrequency":
        this._reportFrequency = val;
        return 1;
      case "advMode":
        this._advMode = val;
        return 1;
      case "calibrationParam":
        this._calibrationParam = val;
        return 1;
      case "resolution":
        this._resolution = Math.round(val / 65.536) / 1e3;
        return 1;
      case "sensorState":
        this._sensorState = val;
        return 1;
    }
    return super.imm_parseAttr(name, val);
  }
  async get_unit() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YSensor.UNIT_INVALID;
      }
    }
    res = this._unit;
    return res;
  }
  async get_currentValue() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YSensor.CURRENTVALUE_INVALID;
      }
    }
    res = await this._applyCalibration(this._currentRawValue);
    if (res == YSensor.CURRENTVALUE_INVALID) {
      res = this._currentValue;
    }
    res = res * this._iresol;
    res = Math.round(res) / this._iresol;
    return res;
  }
  async set_lowestValue(newval) {
    let rest_val;
    rest_val = String(Math.round(newval * 65536));
    return await this._setAttr("lowestValue", rest_val);
  }
  async get_lowestValue() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YSensor.LOWESTVALUE_INVALID;
      }
    }
    res = this._lowestValue * this._iresol;
    res = Math.round(res) / this._iresol;
    return res;
  }
  async set_highestValue(newval) {
    let rest_val;
    rest_val = String(Math.round(newval * 65536));
    return await this._setAttr("highestValue", rest_val);
  }
  async get_highestValue() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YSensor.HIGHESTVALUE_INVALID;
      }
    }
    res = this._highestValue * this._iresol;
    res = Math.round(res) / this._iresol;
    return res;
  }
  async get_currentRawValue() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YSensor.CURRENTRAWVALUE_INVALID;
      }
    }
    res = this._currentRawValue;
    return res;
  }
  async get_logFrequency() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YSensor.LOGFREQUENCY_INVALID;
      }
    }
    res = this._logFrequency;
    return res;
  }
  async set_logFrequency(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("logFrequency", rest_val);
  }
  async get_reportFrequency() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YSensor.REPORTFREQUENCY_INVALID;
      }
    }
    res = this._reportFrequency;
    return res;
  }
  async set_reportFrequency(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("reportFrequency", rest_val);
  }
  async get_advMode() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YSensor.ADVMODE_INVALID;
      }
    }
    res = this._advMode;
    return res;
  }
  async set_advMode(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("advMode", rest_val);
  }
  async get_calibrationParam() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YSensor.CALIBRATIONPARAM_INVALID;
      }
    }
    res = this._calibrationParam;
    return res;
  }
  async set_calibrationParam(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("calibrationParam", rest_val);
  }
  async set_resolution(newval) {
    let rest_val;
    rest_val = String(Math.round(newval * 65536));
    return await this._setAttr("resolution", rest_val);
  }
  async get_resolution() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YSensor.RESOLUTION_INVALID;
      }
    }
    res = this._resolution;
    return res;
  }
  async get_sensorState() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YSensor.SENSORSTATE_INVALID;
      }
    }
    res = this._sensorState;
    return res;
  }
  static FindSensor(func) {
    let obj;
    obj = YFunction._FindFromCache("Sensor", func);
    if (obj == null) {
      obj = new YSensor(YAPI, func);
      YFunction._AddToCache("Sensor", func, obj);
    }
    return obj;
  }
  static FindSensorInContext(yctx, func) {
    let obj;
    obj = YFunction._FindFromCacheInContext(yctx, "Sensor", func);
    if (obj == null) {
      obj = new YSensor(yctx, func);
      YFunction._AddToCache("Sensor", func, obj);
    }
    return obj;
  }
  async registerValueCallback(callback) {
    let val;
    if (callback != null) {
      await YFunction._UpdateValueCallbackList(this, true);
    } else {
      await YFunction._UpdateValueCallbackList(this, false);
    }
    this._valueCallbackSensor = callback;
    if (callback != null && await this.isOnline()) {
      val = this._advertisedValue;
      if (!(val == "")) {
        await this._invokeValueCallback(val);
      }
    }
    return 0;
  }
  async _invokeValueCallback(value) {
    if (this._valueCallbackSensor != null) {
      try {
        await this._valueCallbackSensor(this, value);
      } catch (e) {
        this._yapi.imm_log("Exception in valueCallback:", e);
      }
    } else {
      await super._invokeValueCallback(value);
    }
    return 0;
  }
  async _parserHelper() {
    let position;
    let maxpos;
    let iCalib = [];
    let iRaw;
    let iRef;
    let fRaw;
    let fRef;
    this._caltyp = -1;
    this._scale = -1;
    this._calpar.length = 0;
    this._calraw.length = 0;
    this._calref.length = 0;
    if (this._resolution > 0) {
      this._iresol = Math.round(1 / this._resolution);
    } else {
      this._iresol = 1e4;
      this._resolution = 1e-4;
    }
    if (this._calibrationParam == "" || this._calibrationParam == "0") {
      this._caltyp = 0;
      return 0;
    }
    if (this._calibrationParam.indexOf(",") >= 0) {
      iCalib = this._yapi.imm_decodeFloats(this._calibrationParam);
      this._caltyp = iCalib[0] / 1e3 >> 0;
      if (this._caltyp > 0) {
        if (this._caltyp < YOCTO_CALIB_TYPE_OFS) {
          this._caltyp = -1;
          return 0;
        }
        this.imm_calhdl = this._yapi.imm_getCalibrationHandler(this._caltyp);
        if (!(this.imm_calhdl != null)) {
          this._caltyp = -1;
          return 0;
        }
      }
      this._offset = 0;
      this._scale = 1e3;
      maxpos = iCalib.length;
      this._calpar.length = 0;
      position = 1;
      while (position < maxpos) {
        this._calpar.push(iCalib[position]);
        position = position + 1;
      }
      this._calraw.length = 0;
      this._calref.length = 0;
      position = 1;
      while (position + 1 < maxpos) {
        fRaw = iCalib[position];
        fRaw = fRaw / 1e3;
        fRef = iCalib[position + 1];
        fRef = fRef / 1e3;
        this._calraw.push(fRaw);
        this._calref.push(fRef);
        position = position + 2;
      }
    } else {
      iCalib = this._yapi.imm_decodeWords(this._calibrationParam);
      if (iCalib.length < 2) {
        this._caltyp = -1;
        return 0;
      }
      this._offset = 0;
      this._scale = 1;
      this._decexp = 1;
      position = iCalib[0];
      while (position > 0) {
        this._decexp = this._decexp * 10;
        position = position - 1;
      }
      if (iCalib.length == 2) {
        this._caltyp = 0;
        return 0;
      }
      this._caltyp = iCalib[2];
      this.imm_calhdl = this._yapi.imm_getCalibrationHandler(this._caltyp);
      if (this._caltyp <= 10) {
        maxpos = this._caltyp;
      } else {
        if (this._caltyp <= 20) {
          maxpos = this._caltyp - 10;
        } else {
          maxpos = 5;
        }
      }
      maxpos = 3 + 2 * maxpos;
      if (maxpos > iCalib.length) {
        maxpos = iCalib.length;
      }
      this._calpar.length = 0;
      this._calraw.length = 0;
      this._calref.length = 0;
      position = 3;
      while (position + 1 < maxpos) {
        iRaw = iCalib[position];
        iRef = iCalib[position + 1];
        this._calpar.push(iRaw);
        this._calpar.push(iRef);
        this._calraw.push(this._yapi.imm_decimalToDouble(iRaw));
        this._calref.push(this._yapi.imm_decimalToDouble(iRef));
        position = position + 2;
      }
    }
    return 0;
  }
  async isSensorReady() {
    if (!await this.isOnline()) {
      return false;
    }
    if (!(this._sensorState == 0)) {
      return false;
    }
    return true;
  }
  async get_dataLogger() {
    let logger;
    let modu;
    let serial;
    let hwid;
    modu = await this.get_module();
    serial = await modu.get_serialNumber();
    if (serial == YAPI_INVALID_STRING) {
      return null;
    }
    hwid = serial + ".dataLogger";
    logger = YDataLogger.FindDataLogger(hwid);
    return logger;
  }
  async startDataLogger() {
    let res;
    res = await this._download("api/dataLogger/recording?recording=1");
    if (!(res.length > 0)) {
      return this._throw(YAPI_IO_ERROR, "unable to start datalogger", YAPI_IO_ERROR);
    }
    return YAPI_SUCCESS;
  }
  async stopDataLogger() {
    let res;
    res = await this._download("api/dataLogger/recording?recording=0");
    if (!(res.length > 0)) {
      return this._throw(YAPI_IO_ERROR, "unable to stop datalogger", YAPI_IO_ERROR);
    }
    return YAPI_SUCCESS;
  }
  async get_recordedData(startTime, endTime) {
    let funcid;
    let funit;
    funcid = await this.get_functionId();
    funit = await this.get_unit();
    return new YDataSet(this, funcid, funit, startTime, endTime);
  }
  async registerTimedReportCallback(callback) {
    let sensor;
    sensor = this;
    if (callback != null) {
      await YFunction._UpdateTimedReportCallbackList(sensor, true);
    } else {
      await YFunction._UpdateTimedReportCallbackList(sensor, false);
    }
    this._timedReportCallbackSensor = callback;
    return 0;
  }
  async _invokeTimedReportCallback(value) {
    if (this._timedReportCallbackSensor != null) {
      try {
        await this._timedReportCallbackSensor(this, value);
      } catch (e) {
        this._yapi.imm_log("Exception in timedReportCallback:", e);
      }
    } else {
    }
    return 0;
  }
  async calibrateFromPoints(rawValues, refValues) {
    let rest_val;
    let res;
    rest_val = await this._encodeCalibrationPoints(rawValues, refValues);
    res = await this._setAttr("calibrationParam", rest_val);
    return res;
  }
  async loadCalibrationPoints(rawValues, refValues) {
    rawValues.length = 0;
    refValues.length = 0;
    if (this._scale == 0 || this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YAPI_DEVICE_NOT_FOUND;
      }
    }
    if (this._caltyp < 0) {
      this._throw(YAPI_NOT_SUPPORTED, "Calibration parameters format mismatch. Please upgrade your library or firmware.");
      return YAPI_NOT_SUPPORTED;
    }
    rawValues.length = 0;
    refValues.length = 0;
    for (let ii in this._calraw) {
      rawValues.push(this._calraw[ii]);
    }
    for (let ii in this._calref) {
      refValues.push(this._calref[ii]);
    }
    return YAPI_SUCCESS;
  }
  async _encodeCalibrationPoints(rawValues, refValues) {
    let res;
    let npt;
    let idx;
    npt = rawValues.length;
    if (npt != refValues.length) {
      this._throw(YAPI_INVALID_ARGUMENT, "Invalid calibration parameters (size mismatch)");
      return YAPI_INVALID_STRING;
    }
    if (npt == 0) {
      return "0";
    }
    if (this._scale == 0) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YAPI_INVALID_STRING;
      }
    }
    if (this._caltyp < 0 || this._scale < 0) {
      this._throw(YAPI_NOT_SUPPORTED, "Calibration parameters format mismatch. Please upgrade your library or firmware.");
      return "0";
    }
    res = String(Math.round(YOCTO_CALIB_TYPE_OFS));
    idx = 0;
    while (idx < npt) {
      res = res + "," + String(Math.round(rawValues[idx] * 1e3) / 1e3) + "," + String(Math.round(refValues[idx] * 1e3) / 1e3);
      idx = idx + 1;
    }
    return res;
  }
  async _applyCalibration(rawValue) {
    if (rawValue == YSensor.CURRENTVALUE_INVALID) {
      return YSensor.CURRENTVALUE_INVALID;
    }
    if (this._caltyp == 0) {
      return rawValue;
    }
    if (this._caltyp < 0) {
      return YSensor.CURRENTVALUE_INVALID;
    }
    if (!(this.imm_calhdl != null)) {
      return YSensor.CURRENTVALUE_INVALID;
    }
    return this.imm_calhdl(rawValue, this._caltyp, this._calpar, this._calraw, this._calref);
  }
  async _decodeTimedReport(timestamp, duration, report) {
    let i;
    let byteVal;
    let poww;
    let minRaw;
    let avgRaw;
    let maxRaw;
    let sublen;
    let difRaw;
    let startTime;
    let endTime;
    let minVal;
    let avgVal;
    let maxVal;
    if (duration > 0) {
      startTime = timestamp - duration;
    } else {
      startTime = this._prevTimedReport;
    }
    endTime = timestamp;
    this._prevTimedReport = endTime;
    if (startTime == 0) {
      startTime = endTime;
    }
    if (report.length <= 5) {
      poww = 1;
      avgRaw = 0;
      byteVal = 0;
      i = 1;
      while (i < report.length) {
        byteVal = report[i];
        avgRaw = avgRaw + poww * byteVal;
        poww = poww * 256;
        i = i + 1;
      }
      if ((byteVal & 128) != 0) {
        avgRaw = avgRaw - poww;
      }
      avgVal = avgRaw / 1e3;
      if (this._caltyp != 0) {
        if (this.imm_calhdl != null) {
          avgVal = this.imm_calhdl(avgVal, this._caltyp, this._calpar, this._calraw, this._calref);
        }
      }
      minVal = avgVal;
      maxVal = avgVal;
    } else {
      sublen = 1 + (report[1] & 3);
      poww = 1;
      avgRaw = 0;
      byteVal = 0;
      i = 2;
      while (sublen > 0 && i < report.length) {
        byteVal = report[i];
        avgRaw = avgRaw + poww * byteVal;
        poww = poww * 256;
        i = i + 1;
        sublen = sublen - 1;
      }
      if ((byteVal & 128) != 0) {
        avgRaw = avgRaw - poww;
      }
      sublen = 1 + (report[1] >> 2 & 3);
      poww = 1;
      difRaw = 0;
      while (sublen > 0 && i < report.length) {
        byteVal = report[i];
        difRaw = difRaw + poww * byteVal;
        poww = poww * 256;
        i = i + 1;
        sublen = sublen - 1;
      }
      minRaw = avgRaw - difRaw;
      sublen = 1 + (report[1] >> 4 & 3);
      poww = 1;
      difRaw = 0;
      while (sublen > 0 && i < report.length) {
        byteVal = report[i];
        difRaw = difRaw + poww * byteVal;
        poww = poww * 256;
        i = i + 1;
        sublen = sublen - 1;
      }
      maxRaw = avgRaw + difRaw;
      avgVal = avgRaw / 1e3;
      minVal = minRaw / 1e3;
      maxVal = maxRaw / 1e3;
      if (this._caltyp != 0) {
        if (this.imm_calhdl != null) {
          avgVal = this.imm_calhdl(avgVal, this._caltyp, this._calpar, this._calraw, this._calref);
          minVal = this.imm_calhdl(minVal, this._caltyp, this._calpar, this._calraw, this._calref);
          maxVal = this.imm_calhdl(maxVal, this._caltyp, this._calpar, this._calraw, this._calref);
        }
      }
    }
    return new YMeasure(startTime, endTime, minVal, avgVal, maxVal);
  }
  imm_decodeVal(w) {
    let val;
    val = w;
    if (this._caltyp != 0) {
      if (this.imm_calhdl != null) {
        val = this.imm_calhdl(val, this._caltyp, this._calpar, this._calraw, this._calref);
      }
    }
    return val;
  }
  imm_decodeAvg(dw) {
    let val;
    val = dw;
    if (this._caltyp != 0) {
      if (this.imm_calhdl != null) {
        val = this.imm_calhdl(val, this._caltyp, this._calpar, this._calraw, this._calref);
      }
    }
    return val;
  }
  nextSensor() {
    let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
    if (resolve.errorType != YAPI.SUCCESS)
      return null;
    let next_hwid = this._yapi.imm_getNextHardwareId(this._className, resolve.result);
    if (next_hwid == null)
      return null;
    return YSensor.FindSensorInContext(this._yapi, next_hwid);
  }
  static FirstSensor() {
    let next_hwid = YAPI.imm_getFirstHardwareId("Sensor");
    if (next_hwid == null)
      return null;
    return YSensor.FindSensor(next_hwid);
  }
  static FirstSensorInContext(yctx) {
    let next_hwid = yctx.imm_getFirstHardwareId("Sensor");
    if (next_hwid == null)
      return null;
    return YSensor.FindSensorInContext(yctx, next_hwid);
  }
};
YSensor.UNIT_INVALID = YAPI_INVALID_STRING;
YSensor.CURRENTVALUE_INVALID = YAPI_INVALID_DOUBLE;
YSensor.LOWESTVALUE_INVALID = YAPI_INVALID_DOUBLE;
YSensor.HIGHESTVALUE_INVALID = YAPI_INVALID_DOUBLE;
YSensor.CURRENTRAWVALUE_INVALID = YAPI_INVALID_DOUBLE;
YSensor.LOGFREQUENCY_INVALID = YAPI_INVALID_STRING;
YSensor.REPORTFREQUENCY_INVALID = YAPI_INVALID_STRING;
YSensor.ADVMODE_IMMEDIATE = 0;
YSensor.ADVMODE_PERIOD_AVG = 1;
YSensor.ADVMODE_PERIOD_MIN = 2;
YSensor.ADVMODE_PERIOD_MAX = 3;
YSensor.ADVMODE_INVALID = -1;
YSensor.CALIBRATIONPARAM_INVALID = YAPI_INVALID_STRING;
YSensor.RESOLUTION_INVALID = YAPI_INVALID_DOUBLE;
YSensor.SENSORSTATE_INVALID = YAPI_INVALID_INT;
var YMeasure = class {
  constructor(float_start, float_end, float_minVal, float_avgVal, float_maxVal) {
    this._start = 0;
    this._end = 0;
    this._minVal = 0;
    this._avgVal = 0;
    this._maxVal = 0;
    this._start = float_start;
    this._end = float_end;
    this._minVal = float_minVal;
    this._avgVal = float_avgVal;
    this._maxVal = float_maxVal;
  }
  get_startTimeUTC() {
    return this._start;
  }
  get_endTimeUTC() {
    return this._end;
  }
  get_minValue() {
    return this._minVal;
  }
  get_averageValue() {
    return this._avgVal;
  }
  get_maxValue() {
    return this._maxVal;
  }
  get_startTimeUTC_asDate() {
    return new Date(Math.round(this._start * 1e3));
  }
  get_endTimeUTC_asDate() {
    return new Date(Math.round(this._end * 1e3));
  }
};
var YDataLogger = class extends YFunction {
  constructor(yapi, func) {
    super(yapi, func);
    this._currentRunIndex = YDataLogger.CURRENTRUNINDEX_INVALID;
    this._timeUTC = YDataLogger.TIMEUTC_INVALID;
    this._recording = YDataLogger.RECORDING_INVALID;
    this._autoStart = YDataLogger.AUTOSTART_INVALID;
    this._beaconDriven = YDataLogger.BEACONDRIVEN_INVALID;
    this._usage = YDataLogger.USAGE_INVALID;
    this._clearHistory = YDataLogger.CLEARHISTORY_INVALID;
    this._valueCallbackDataLogger = null;
    this.CURRENTRUNINDEX_INVALID = YAPI_INVALID_UINT;
    this.TIMEUTC_INVALID = YAPI_INVALID_LONG;
    this.RECORDING_OFF = 0;
    this.RECORDING_ON = 1;
    this.RECORDING_PENDING = 2;
    this.RECORDING_INVALID = -1;
    this.AUTOSTART_OFF = 0;
    this.AUTOSTART_ON = 1;
    this.AUTOSTART_INVALID = -1;
    this.BEACONDRIVEN_OFF = 0;
    this.BEACONDRIVEN_ON = 1;
    this.BEACONDRIVEN_INVALID = -1;
    this.USAGE_INVALID = YAPI_INVALID_UINT;
    this.CLEARHISTORY_FALSE = 0;
    this.CLEARHISTORY_TRUE = 1;
    this.CLEARHISTORY_INVALID = -1;
    this._className = "DataLogger";
  }
  imm_parseAttr(name, val) {
    switch (name) {
      case "currentRunIndex":
        this._currentRunIndex = val;
        return 1;
      case "timeUTC":
        this._timeUTC = val;
        return 1;
      case "recording":
        this._recording = val;
        return 1;
      case "autoStart":
        this._autoStart = val;
        return 1;
      case "beaconDriven":
        this._beaconDriven = val;
        return 1;
      case "usage":
        this._usage = val;
        return 1;
      case "clearHistory":
        this._clearHistory = val;
        return 1;
    }
    return super.imm_parseAttr(name, val);
  }
  async get_currentRunIndex() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YDataLogger.CURRENTRUNINDEX_INVALID;
      }
    }
    res = this._currentRunIndex;
    return res;
  }
  async get_timeUTC() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YDataLogger.TIMEUTC_INVALID;
      }
    }
    res = this._timeUTC;
    return res;
  }
  async set_timeUTC(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("timeUTC", rest_val);
  }
  async get_recording() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YDataLogger.RECORDING_INVALID;
      }
    }
    res = this._recording;
    return res;
  }
  async set_recording(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("recording", rest_val);
  }
  async get_autoStart() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YDataLogger.AUTOSTART_INVALID;
      }
    }
    res = this._autoStart;
    return res;
  }
  async set_autoStart(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("autoStart", rest_val);
  }
  async get_beaconDriven() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YDataLogger.BEACONDRIVEN_INVALID;
      }
    }
    res = this._beaconDriven;
    return res;
  }
  async set_beaconDriven(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("beaconDriven", rest_val);
  }
  async get_usage() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YDataLogger.USAGE_INVALID;
      }
    }
    res = this._usage;
    return res;
  }
  async get_clearHistory() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YDataLogger.CLEARHISTORY_INVALID;
      }
    }
    res = this._clearHistory;
    return res;
  }
  async set_clearHistory(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("clearHistory", rest_val);
  }
  static FindDataLogger(func) {
    let obj;
    obj = YFunction._FindFromCache("DataLogger", func);
    if (obj == null) {
      obj = new YDataLogger(YAPI, func);
      YFunction._AddToCache("DataLogger", func, obj);
    }
    return obj;
  }
  static FindDataLoggerInContext(yctx, func) {
    let obj;
    obj = YFunction._FindFromCacheInContext(yctx, "DataLogger", func);
    if (obj == null) {
      obj = new YDataLogger(yctx, func);
      YFunction._AddToCache("DataLogger", func, obj);
    }
    return obj;
  }
  async registerValueCallback(callback) {
    let val;
    if (callback != null) {
      await YFunction._UpdateValueCallbackList(this, true);
    } else {
      await YFunction._UpdateValueCallbackList(this, false);
    }
    this._valueCallbackDataLogger = callback;
    if (callback != null && await this.isOnline()) {
      val = this._advertisedValue;
      if (!(val == "")) {
        await this._invokeValueCallback(val);
      }
    }
    return 0;
  }
  async _invokeValueCallback(value) {
    if (this._valueCallbackDataLogger != null) {
      try {
        await this._valueCallbackDataLogger(this, value);
      } catch (e) {
        this._yapi.imm_log("Exception in valueCallback:", e);
      }
    } else {
      await super._invokeValueCallback(value);
    }
    return 0;
  }
  async forgetAllDataStreams() {
    return await this.set_clearHistory(1);
  }
  async get_dataSets() {
    return await this.parse_dataSets(await this._download("logger.json"));
  }
  async parse_dataSets(jsonbuff) {
    let dslist = [];
    let dataset;
    let res = [];
    dslist = this.imm_json_get_array(jsonbuff);
    res.length = 0;
    for (let ii in dslist) {
      dataset = new YDataSet(this);
      await dataset._parse(this._yapi.imm_bin2str(dslist[ii]));
      res.push(dataset);
    }
    return res;
  }
  nextDataLogger() {
    let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
    if (resolve.errorType != YAPI.SUCCESS)
      return null;
    let next_hwid = this._yapi.imm_getNextHardwareId(this._className, resolve.result);
    if (next_hwid == null)
      return null;
    return YDataLogger.FindDataLoggerInContext(this._yapi, next_hwid);
  }
  static FirstDataLogger() {
    let next_hwid = YAPI.imm_getFirstHardwareId("DataLogger");
    if (next_hwid == null)
      return null;
    return YDataLogger.FindDataLogger(next_hwid);
  }
  static FirstDataLoggerInContext(yctx) {
    let next_hwid = yctx.imm_getFirstHardwareId("DataLogger");
    if (next_hwid == null)
      return null;
    return YDataLogger.FindDataLoggerInContext(yctx, next_hwid);
  }
};
YDataLogger.CURRENTRUNINDEX_INVALID = YAPI_INVALID_UINT;
YDataLogger.TIMEUTC_INVALID = YAPI_INVALID_LONG;
YDataLogger.RECORDING_OFF = 0;
YDataLogger.RECORDING_ON = 1;
YDataLogger.RECORDING_PENDING = 2;
YDataLogger.RECORDING_INVALID = -1;
YDataLogger.AUTOSTART_OFF = 0;
YDataLogger.AUTOSTART_ON = 1;
YDataLogger.AUTOSTART_INVALID = -1;
YDataLogger.BEACONDRIVEN_OFF = 0;
YDataLogger.BEACONDRIVEN_ON = 1;
YDataLogger.BEACONDRIVEN_INVALID = -1;
YDataLogger.USAGE_INVALID = YAPI_INVALID_UINT;
YDataLogger.CLEARHISTORY_FALSE = 0;
YDataLogger.CLEARHISTORY_TRUE = 1;
YDataLogger.CLEARHISTORY_INVALID = -1;
var YSystemEnv = class {
  constructor() {
    this.isNodeJS = false;
    this.hasSSDP = false;
  }
  unknownSystemEnvError() {
    return new YoctoError("Unspecified runtime environment, your project should include at least once either yocto_api_nodejs or yocto_api_html");
  }
  hookUnhandledRejection(handler) {
    throw this.unknownSystemEnvError();
  }
  getWebSocketEngine(hub, runtime_urlInfo) {
    throw this.unknownSystemEnvError();
  }
  getHttpEngine(hub, runtime_urlInfo, infojson) {
    throw this.unknownSystemEnvError();
  }
  getWebSocketCallbackEngine(hub, runtime_urlInfo, ws) {
    throw this.unknownSystemEnvError();
  }
  getHttpCallbackEngine(hub, runtime_urlInfo, incomingMessage, serverResponse) {
    throw this.unknownSystemEnvError();
  }
  getSSDPManager(obj_yapi) {
    throw this.unknownSystemEnvError();
  }
  async loadfile(file) {
    throw this.unknownSystemEnvError();
  }
  async downloadfile(url, yapi) {
    throw this.unknownSystemEnvError();
  }
  async downloadRemoteCertificate(urlinfo) {
    throw this.unknownSystemEnvError();
  }
};
var _UnspecifiedSystemEnv = new YSystemEnv();
var YHubEngine = class {
  constructor(hub, runtime_urlInfo) {
    this.lastPingStamp = 0;
    this._hub = hub;
    this._runtime_urlInfo = runtime_urlInfo;
  }
  async reconnectEngine(tryOpenID) {
  }
  imm_disconnectEngineNow(connID = "") {
  }
  async request(method, devUrl, obj_body, tcpchan) {
    let res = new YHTTPRequest(null);
    res.errorType = YAPI_NOT_SUPPORTED;
    res.errorMsg = "GenericHub subclass expected";
    return res;
  }
  async reportFailure(message) {
  }
  imm_updateLastPinfStamp() {
    this.lastPingStamp = Date.now();
  }
  imm_isConnected() {
    return Date.now() - this.lastPingStamp < this._hub.imm_getNetworkTimeout();
  }
  imm_isForwarded() {
    return false;
  }
  async waitForPendingQueries(ms_duration) {
  }
};
var HubMode;
(function(HubMode2) {
  HubMode2[HubMode2["LEGACY"] = 0] = "LEGACY";
  HubMode2[HubMode2["MIXED"] = 1] = "MIXED";
  HubMode2[HubMode2["SECURE"] = 2] = "SECURE";
  HubMode2[HubMode2["PROTO_UNKNOWN"] = 3] = "PROTO_UNKNOWN";
})(HubMode || (HubMode = {}));
var YGenericHub = class {
  constructor(yapi, urlInfo) {
    this._lastErrorType = YAPI_IO_ERROR;
    this._lastErrorMsg = "Hub attachment has not been triggered";
    this.hubSerial = "";
    this.serialByYdx = [];
    this._currentState = -6;
    this._targetState = -5;
    this.currentConnID = "";
    this.connResolvers = [];
    this.disconnResolvers = [];
    this.retryDelay = 15;
    this._reconnectionTimer = null;
    this._rwAccess = null;
    this.keepTryingExpiration = 0;
    this.keepTryingTimeoutId = null;
    this.timeoutId = null;
    this.isNotifWorking = false;
    this.devListExpires = 0;
    this.notifPos = -1;
    this.notifCarryOver = "";
    this._firstArrivalCallback = true;
    this._missing = {};
    this._knownUrls = [];
    this._portInfo = [];
    this._usePureHTTP = false;
    this._yapi = yapi;
    this.urlInfo = urlInfo;
    this.stalledTimeoutMs = yapi._networkTimeoutMs;
    this._hubRef = YGenericHub.globalHubRefCounter++;
    this._hubEngine = null;
    this._hubMode = HubMode.SECURE;
  }
  _throw(int_errType, str_errMsg, obj_retVal) {
    this._lastErrorType = int_errType;
    this._lastErrorMsg = str_errMsg;
    return this._yapi._throw(int_errType, str_errMsg, obj_retVal);
  }
  imm_isFirstArrivalCallback() {
    return this._firstArrivalCallback;
  }
  imm_setFirstArrivalCallback(isfirst) {
    this._firstArrivalCallback = isfirst;
  }
  imm_getNotifyPos() {
    return this.notifPos;
  }
  imm_getcurrentState() {
    return this._currentState;
  }
  imm_getCurrentConnID() {
    return this.currentConnID;
  }
  imm_setCurrentConnID(id) {
    this.currentConnID = id;
  }
  get_errorType() {
    return this._lastErrorType;
  }
  get_errorMessage() {
    return this._lastErrorMsg;
  }
  imm_forceUpdate() {
    this.devListExpires = this._yapi.GetTickCount();
  }
  imm_logrequest(method, devUrl, obj_body) {
    let msg = "Request: " + method + " " + devUrl;
    if (obj_body) {
      msg += " (file=" + obj_body.fname + ")";
    }
    this._yapi.imm_log(msg);
  }
  imm_setState(newState) {
    this._currentState = newState;
  }
  imm_setTargetState(newState) {
    this._targetState = newState;
  }
  imm_isDisconnecting() {
    return this._targetState <= -5;
  }
  imm_isDisconnected() {
    return this._targetState <= -5 && this._currentState <= -5;
  }
  imm_isPreOrRegistered() {
    return this._targetState >= 1;
  }
  imm_isOnline() {
    if (this._hubEngine) {
      return this._hubEngine.imm_isConnected();
    }
    return false;
  }
  imm_isForwarded() {
    if (this._hubEngine) {
      return this._hubEngine.imm_isForwarded();
    }
    return false;
  }
  imm_addKnownUrl(urlInfo) {
    if (!this._knownUrls.includes(urlInfo.imm_getOriginalURL())) {
      this._knownUrls.push(urlInfo.imm_getOriginalURL());
    }
  }
  imm_updateUrl(urlInfo) {
    if (!this._knownUrls.includes(urlInfo.imm_getOriginalURL())) {
      this._knownUrls.push(urlInfo.imm_getOriginalURL());
    }
    if (this.urlInfo.imm_getUrl(false, true, true) == urlInfo.imm_getUrl(false, true, true)) {
      this.urlInfo.imm_updateFrom(urlInfo);
      return;
    }
    this.urlInfo.imm_updateFrom(urlInfo);
    if (this._currentState < -1) {
      if (this._yapi._logLevel >= 4) {
        this._yapi.imm_log("Updating auth credentials for " + this.urlInfo.imm_getRootUrl());
      }
    }
  }
  imm_updateForRedirect(url) {
    let ofs = url.indexOf("://");
    if (ofs > 0) {
      ofs = url.indexOf("/", ofs + 3);
      if (ofs > 0) {
        url = url.substring(0, ofs);
      }
    }
    let new_url = new _YY_UrlInfo(url);
    this.urlInfo.imm_updateForRedirect(new_url.imm_getHost(), new_url.imm_getPort(), new_url.imm_useSecureSocket());
    if (this._yapi._logLevel >= 4) {
      this._yapi.imm_log("Updating URL after HTTP redirection : " + this.urlInfo.imm_getRootUrl());
    }
    let primaryHub = this._yapi._knownHubsByUrl[new_url.imm_getRootUrl()];
    if (primaryHub && primaryHub !== this) {
      if (primaryHub.urlInfo.imm_useSecureSocket()) {
        if (primaryHub._currentState >= this._currentState) {
          primaryHub.imm_inheritFrom(this);
          return;
        }
      }
      this._yapi._knownHubsByUrl[this.urlInfo.imm_getRootUrl()] = this;
      this.imm_inheritFrom(primaryHub);
    } else {
      this._yapi._knownHubsByUrl[new_url.imm_getRootUrl()] = this;
    }
  }
  imm_inheritFrom(otherHub) {
    if (this._targetState < otherHub._targetState) {
      this.imm_setTargetState(otherHub._targetState);
    }
    for (let j = 0; j < otherHub.serialByYdx.length; j++) {
      let serial = otherHub.serialByYdx[j];
      if (serial && !this.serialByYdx[j]) {
        this.serialByYdx[j] = serial;
      }
    }
    if (this._currentState >= 0 && otherHub._currentState < 0) {
      let res_struct = {errorType: YAPI_SUCCESS, errorMsg: "Hub " + this.hubSerial + " already connected"};
      let resolvers = otherHub.connResolvers;
      for (let resolveOne of resolvers) {
        resolveOne(res_struct);
      }
    } else {
      for (let resolver of otherHub.connResolvers) {
        this.connResolvers.push(resolver);
      }
    }
    otherHub.connResolvers = [];
    if (this._yapi._logLevel >= 3) {
      this._yapi.imm_log("Hub " + this.hubSerial + " is connected as " + this.urlInfo.imm_getRootUrl() + ", dropping connection to " + otherHub.urlInfo.imm_getRootUrl());
    }
    otherHub.imm_commonDisconnect("inherit", YAPI_SUCCESS, "Hub " + this.hubSerial + " is already connected via " + this.urlInfo.imm_getRootUrl());
    otherHub.imm_disconnectNow();
    for (const url of otherHub.get_knownUrls()) {
      if (!this._knownUrls.includes(url)) {
        this._knownUrls.push(url);
      }
    }
  }
  imm_getNewConnID() {
    let time = new Date();
    return (time.getHours() + "h" + time.getMinutes() + "m" + time.getTime() % 6e4 / 1e3).toString() + "_0";
  }
  imm_tryTestConnectFor(mstimeout) {
    let minimalExpiration = Date.now() + mstimeout;
    if (this.keepTryingExpiration < minimalExpiration) {
      this.keepTryingExpiration = minimalExpiration;
      if (this.keepTryingTimeoutId) {
        clearTimeout(this.keepTryingTimeoutId);
      }
      this.keepTryingTimeoutId = setTimeout(() => {
        this.keepTryingTimeoutId = null;
        if (this._targetState == 0) {
          if (this._yapi._logLevel >= 4) {
            this._yapi.imm_log("TestHub timeout reached, disconnecting");
          }
          this.detach(YAPI.IO_ERROR, "TestHub timeout reached");
        }
      }, mstimeout);
    }
  }
  async attach(targetConnType) {
    if (this._targetState <= 0 || targetConnType > 0) {
      this.imm_setTargetState(targetConnType);
      if (this._currentState == 0 && targetConnType > 0) {
        try {
          await this._yapi._ensureUpdateDeviceListNotRunning();
          await this._yapi._addConnectedHub(this);
          this.imm_setState(targetConnType);
        } catch (e) {
          this.imm_disconnectNow();
        }
      }
      if (targetConnType == 0) {
        this.imm_tryTestConnectFor(100);
      }
    }
    if (this._currentState <= -5) {
      if (this._yapi._logLevel >= 4) {
        this._yapi.imm_log("New hub is detached connecting...");
      }
      this._hubEngine = null;
      this.stalledTimeoutMs = this._yapi._networkTimeoutMs;
      this.imm_setState(-1);
      this.reconnect(this.imm_getNewConnID());
    } else if (this._currentState == -3) {
      if (this._reconnectionTimer) {
        if (this._yapi._logLevel >= 4) {
          this._yapi.imm_log("New hub connection requested, retry now (drop [" + this.currentConnID + "])");
        }
        clearTimeout(this._reconnectionTimer);
        this._reconnectionTimer = null;
        this.currentConnID = "";
      } else {
        if (this._yapi._logLevel >= 4) {
          this._yapi.imm_log("New hub connection requested, retry now (no pending reconnection ?!?)");
        }
      }
      this.reconnect(this.imm_getNewConnID());
    } else if (this._currentState == -4 || this._currentState == -2) {
      if (this._yapi._logLevel >= 4) {
        this._yapi.imm_log("Hub is currently disconnecting, reconnection will be triggered soon [" + this.currentConnID + "]");
        this._yapi.imm_log("Current state: " + this._currentState);
        this._yapi.imm_log("Target state: " + this._targetState + " (" + targetConnType + ")");
      }
    }
  }
  async waitForConnection(mstimeout, errmsg) {
    if (this._targetState < 0) {
      errmsg.msg = this._lastErrorMsg;
      return this._lastErrorType;
    }
    if (this._currentState >= 0) {
      return YAPI_SUCCESS;
    }
    if (mstimeout <= 1) {
      errmsg.msg = "Hub not connected";
      return YAPI_TIMEOUT;
    }
    if (this._targetState == 0) {
      this.imm_tryTestConnectFor(mstimeout);
    }
    let connOpenPromise = null;
    let connOpenTimeoutObj = null;
    let addResolverPromise;
    addResolverPromise = new Promise((resolverReady, noResolver) => {
      connOpenPromise = new Promise((resolve, reject) => {
        this.connResolvers.push(resolve);
        resolverReady(resolve);
        connOpenTimeoutObj = setTimeout(() => {
          if (this._yapi._logLevel >= 4) {
            this._yapi.imm_log("Timeout waiting for hub connection");
          }
          resolve({errorType: YAPI_TIMEOUT, errorMsg: "Timeout waiting for hub connection"});
        }, mstimeout);
      });
    });
    let resolver = await addResolverPromise;
    if (this._targetState < 0) {
      clearTimeout(connOpenTimeoutObj);
      errmsg.msg = this._lastErrorMsg;
      return this._lastErrorType;
    }
    if (this._currentState >= 0) {
      clearTimeout(connOpenTimeoutObj);
      return YAPI_SUCCESS;
    }
    let openRes = await connOpenPromise;
    clearTimeout(connOpenTimeoutObj);
    if (openRes.errorType != YAPI_SUCCESS) {
      if (errmsg) {
        errmsg.msg = openRes.errorMsg;
      }
    }
    return openRes.errorType;
  }
  async reconnect(tryOpenID) {
    if (!this._hubEngine) {
      if (this._yapi._logLevel >= 4) {
        this._yapi.imm_log("look for suitable Hub engine [" + tryOpenID + "]");
      }
      this._usePureHTTP = false;
      this._portInfo = [];
      let infoJson = null;
      if (this.urlInfo.imm_testInfoJson()) {
        let https_req = this.urlInfo.imm_useSecureSocket();
        if (this.urlInfo.imm_getPort() == YAPI.YOCTO_DEFAULT_HTTPS_PORT) {
          https_req = true;
        }
        let url = (https_req ? "https://" : "http://") + this.urlInfo.imm_getUrl(false, false, true) + "info.json";
        if (this._yapi._logLevel >= 4) {
          this._yapi.imm_log("look for info.json at " + url + " [" + tryOpenID + "]");
        }
        try {
          let data = await this._yapi.system_env.downloadfile(url, this._yapi);
          infoJson = JSON.parse(YAPI.imm_bin2str(data));
          if (infoJson) {
            if (infoJson.serialNumber) {
              this.imm_setSerialNumber(infoJson.serialNumber);
            }
            if (infoJson.protocol && infoJson.protocol == "HTTP/1.1") {
              this._usePureHTTP = true;
            }
            if (infoJson.port) {
              let i = 0;
              while (i < infoJson.port.length) {
                let proto_port = infoJson.port[i++];
                let split = proto_port.split(":");
                let proto = split[0];
                let port = YAPIContext.imm_atoi(split[1]);
                if (port == 0) {
                  break;
                }
                this._portInfo.push({proto, port});
              }
            }
          }
          if (this._yapi._logLevel >= 4) {
            this._yapi.imm_log("info.json successfully parsed " + url + " [" + tryOpenID + "]");
          }
        } catch (e) {
          if (e.errorType == YAPI.SSL_UNK_CERT) {
            this.imm_commonDisconnect(tryOpenID, YAPI.SSL_UNK_CERT, e.message);
            this.imm_disconnectNow();
            return;
          } else {
            if (this._yapi._logLevel >= 4) {
              this._yapi.imm_log("Unable to get info.json from " + url + " [" + tryOpenID + "]");
            }
            let serialurl = (https_req ? "https://" : "http://") + this.urlInfo.imm_getUrl(false, false, false) + "/api/module/serialNumber";
            try {
              let data = await this._yapi.system_env.downloadfile(serialurl, this._yapi);
              this.imm_setSerialNumber(YAPI.imm_bin2str(data));
            } catch (e2) {
              this.imm_commonDisconnect(tryOpenID, YAPI.IO_ERROR, e2.message);
              return;
            }
          }
        }
      }
      const runtimeUrl = this.imm_UseBestProto();
      if (runtimeUrl.imm_useWebSocket()) {
        if (this._yapi._logLevel >= 4) {
          this._yapi.imm_log("Use WebSocket hub engine [" + tryOpenID + "]");
        }
        this._hubEngine = this._yapi.system_env.getWebSocketEngine(this, runtimeUrl);
      } else {
        if (this._yapi._logLevel >= 4) {
          this._yapi.imm_log("Use HTTP hub engine [" + tryOpenID + "]");
        }
        this._hubEngine = this._yapi.system_env.getHttpEngine(this, runtimeUrl, infoJson);
      }
      if (!this._hubEngine) {
        this.imm_commonDisconnect(tryOpenID, YAPI_NOT_SUPPORTED, "Unsupported hub protocol: " + runtimeUrl.imm_getProto());
        return;
      }
    }
    await this._hubEngine.reconnectEngine(tryOpenID);
  }
  async signalHubConnected(tryOpenID, hubSerial) {
    this.imm_setState(0);
    this.hubSerial = hubSerial;
    if (this._yapi._logLevel >= 4) {
      this._yapi.imm_log("Hub " + hubSerial + " connected [" + tryOpenID + "]");
    }
    let primaryHub = this._yapi.imm_getPrimaryHub(this);
    if (primaryHub._targetState >= 1) {
      if (primaryHub._currentState < 1) {
        try {
          await primaryHub._yapi._ensureUpdateDeviceListNotRunning();
          await primaryHub._yapi._addConnectedHub(primaryHub);
        } catch (e) {
          primaryHub.imm_disconnectNow();
          return;
        }
      }
      if (primaryHub._currentState < primaryHub._targetState) {
        primaryHub.imm_setState(primaryHub._targetState);
      }
    } else {
      primaryHub.keepTryingExpiration = 0;
      primaryHub.imm_tryTestConnectFor(100);
    }
    let res_struct = {errorType: YAPI_SUCCESS, errorMsg: "Hub " + hubSerial + " connected"};
    let resolvers = primaryHub.connResolvers;
    primaryHub.connResolvers = [];
    primaryHub._lastErrorType = res_struct.errorType;
    primaryHub._lastErrorMsg = res_struct.errorMsg;
    for (let resolveOne of resolvers) {
      resolveOne(res_struct);
    }
  }
  imm_signalHubDisconnected(tryOpenID) {
    if (this._yapi._logLevel >= 4) {
      this._yapi.imm_log("imm_signalHubDisconnected  " + this.urlInfo.imm_getRootUrl());
    }
    if (this._currentState > -3) {
      this.imm_setState(-3);
    }
    this.isNotifWorking = false;
    this.devListExpires = 0;
    this._yapi.imm_dropConnectedHub(this);
    this._firstArrivalCallback = true;
    let resolvers = this.disconnResolvers;
    this.disconnResolvers = [];
    for (let resolveOne of resolvers) {
      resolveOne({errorType: YAPI_SUCCESS, errorMsg: "Hub disconnect completed"});
    }
    if (this.imm_isDisconnecting()) {
      this.imm_setState(-5);
      if (this._yapi._logLevel >= 4) {
        this._yapi.imm_log("Hub " + this.urlInfo.imm_getRootUrl() + " detached");
      }
      return false;
    }
    if (this._reconnectionTimer) {
      if (this._yapi._logLevel >= 4) {
        this._yapi.imm_log("Hub disconnected, reconnection is already scheduled [" + this.currentConnID + "]");
      }
      return true;
    }
    let openIDwords = tryOpenID.split("_");
    let nextOpenID = openIDwords[0] + "_" + (parseInt(openIDwords[1]) + 1).toString();
    if (this.retryDelay < 5e3)
      this.retryDelay *= 2;
    if (this._yapi._logLevel >= 4) {
      this._yapi.imm_log("Hub reconnection scheduled in " + this.retryDelay / 1e3 + "s [" + nextOpenID + "]");
    }
    this.currentConnID = nextOpenID;
    this._reconnectionTimer = setTimeout(() => {
      this._reconnectionTimer = null;
      this.currentConnID = "";
      if (this.imm_isDisconnecting()) {
        return;
      }
      if (this._yapi._logLevel >= 4) {
        this._yapi.imm_log("Retry hub connection now [" + nextOpenID + "]");
      }
      this.reconnect(nextOpenID);
    }, this.retryDelay);
    return true;
  }
  imm_commonDisconnect(tryOpenID, errType, errMsg) {
    this._lastErrorType = errType;
    this._lastErrorMsg = errMsg;
    if (this._currentState >= -2) {
      this.imm_setState(-4);
    } else if (this._currentState == -3) {
      this.imm_setState(-5);
    }
    this.imm_setTargetState(-5);
    if (this._reconnectionTimer) {
      clearTimeout(this._reconnectionTimer);
      this._reconnectionTimer = null;
    }
    if (this.timeoutId) {
      clearTimeout(this.timeoutId);
      this.timeoutId = null;
    }
    if (errType != YAPI_SUCCESS && this._yapi._logLevel >= 4 && tryOpenID != "detach") {
      this._yapi.imm_log("Hub connection failed: " + errMsg + " [" + tryOpenID + "]");
    }
    this._firstArrivalCallback = true;
    let res_struct = {errorType: errType, errorMsg: errMsg};
    let resolvers = this.connResolvers;
    this.connResolvers = [];
    for (let resolveOne of resolvers) {
      resolveOne(res_struct);
    }
  }
  imm_disconnectNow(connID = "") {
    if (connID && connID != this.currentConnID) {
      return false;
    }
    if (this._currentState > -2) {
      this.imm_setState(-2);
    }
    if (this.timeoutId) {
      clearTimeout(this.timeoutId);
      this.timeoutId = null;
    }
    if (this._hubEngine) {
      this._hubEngine.imm_disconnectEngineNow(connID);
    } else {
      this.imm_signalHubDisconnected(connID);
    }
    return true;
  }
  async detach(errType = YAPI.IO_ERROR, errMsg = "Hub has been forcibly detached") {
    this.imm_commonDisconnect("detach", errType, errMsg);
    this.imm_disconnectNow();
    this.stalledTimeoutMs = this._yapi._networkTimeoutMs;
    this._hubEngine = null;
  }
  async waitForDisconnection(mstimeout) {
    let disconnPromise = null;
    let disconnTimeoutObj = null;
    disconnPromise = new Promise((resolve, reject) => {
      this.disconnResolvers.push(resolve);
      disconnTimeoutObj = setTimeout(() => {
        if (this._yapi._logLevel >= 4) {
          this._yapi.imm_log("Timeout waiting for hub disconnection");
        }
        resolve({errorType: YAPI_TIMEOUT, errorMsg: "Timeout waiting for hub connection"});
      }, mstimeout);
    });
    await disconnPromise;
    clearTimeout(disconnTimeoutObj);
  }
  async hubUpdateDeviceList() {
    let hubDev = this._yapi.imm_getDevice(this.urlInfo.imm_getRootUrl());
    try {
      hubDev.imm_dropCache();
      let retcode = await hubDev.refresh();
      if (retcode != YAPI_SUCCESS) {
        if (this._currentState >= 1) {
          await this._yapi.updateDeviceList_process(this, hubDev, [], {});
        }
        this.imm_disconnectNow();
        return this._throw(retcode, hubDev._lastErrorMsg, retcode);
      }
      let yreq = await hubDev.requestAPI(this._yapi.defaultCacheValidity);
      if (yreq.errorType != YAPI_SUCCESS) {
        if (this._currentState >= 1) {
          await this._yapi.updateDeviceList_process(this, hubDev, [], {});
        }
        this.imm_disconnectNow();
        return yreq.errorType;
      }
      let whitePages = yreq.obj_result.services.whitePages;
      let yellowPages = yreq.obj_result.services.yellowPages;
      if (!whitePages) {
        this.imm_disconnectNow();
        return this._throw(YAPI_IO_ERROR, "Device " + hubDev.imm_describe() + " is not a hub", YAPI_IO_ERROR);
      }
      retcode = await this._yapi.updateDeviceList_process(this, hubDev, whitePages, yellowPages);
      if (retcode < 0) {
        this.imm_disconnectNow();
        return this._throw(this._yapi._lastErrorType, this._yapi._lastErrorMsg, this._yapi._lastErrorType);
      }
      if (this.isNotifWorking) {
        this.devListExpires = this._yapi.GetTickCount() + this._yapi._deviceListValidityMs;
      } else {
        this.devListExpires = this._yapi.GetTickCount() + 500;
      }
      return retcode;
    } catch (e) {
      if (this._yapi._logLevel >= 3) {
        this._yapi.imm_log("Exception during device enumeration: ", e);
      }
      if (this._currentState >= 1) {
        try {
          await this._yapi.updateDeviceList_process(this, hubDev, [], {});
        } catch (e2) {
        }
      }
      this.imm_disconnectNow();
      return YAPI_IO_ERROR;
    }
  }
  async request(method, devUrl, obj_body, tcpchan) {
    if (!this._hubEngine) {
      let res = new YHTTPRequest(null);
      res.errorType = YAPI_IO_ERROR;
      res.errorMsg = "HubEngine is not initialised";
      return res;
    }
    return await this._hubEngine.request(method, devUrl, obj_body, tcpchan);
  }
  imm_getBoundary() {
    return "Zz" + Math.floor(Math.random() * 16777215).toString(16) + "zZ";
  }
  imm_formEncodeBody(obj_body, str_boundary) {
    let hdr = this._yapi.imm_str2bin('Content-Disposition: form-data; name="' + obj_body.fname + '"; filename="api"\r\nContent-Type: application/octet-stream\r\nContent-Transfer-Encoding: binary\r\n\r\n');
    let boundary = this._yapi.imm_str2bin(str_boundary);
    let dash = this._yapi.imm_str2bin("--");
    let crlf = this._yapi.imm_str2bin("\r\n");
    let parts = [dash, boundary, crlf, hdr, obj_body.data, crlf, dash, boundary, dash, crlf];
    let i, len = 0;
    for (i = 0; i < parts.length; i++) {
      len += parts[i].length;
    }
    let res = new Uint8Array(len);
    len = 0;
    for (i = 0; i < parts.length; i++) {
      res.set(parts[i], len);
      len += parts[i].length;
    }
    return res;
  }
  async getBootloaders() {
    let yreq = await this.request("GET", "/flash.json?a=list", null, 1);
    if (yreq.errorType != YAPI_SUCCESS) {
      return this._throw(yreq.errorType, yreq.errorMsg, []);
    }
    let flashState = JSON.parse(YAPI.imm_bin2str(yreq.bin_result));
    return flashState["list"];
  }
  async firmwareUpdate(serial, firmware, settings, progress) {
    let use_self_flash = false;
    let baseUrl = "";
    let need_reboot = true;
    let _throw = (msg) => {
      return this._throw(YAPI.IO_ERROR, msg, [msg]);
    };
    progress(5, "Check bootloader type");
    let yreq = await this.request("GET", "/api/module.json", null, 0);
    if (yreq.errorType != YAPI_SUCCESS) {
      return _throw("Hub is not responding");
    }
    let json = JSON.parse(this._yapi.imm_bin2str(yreq.bin_result));
    let ownSerial = json.serialNumber;
    if (ownSerial.slice(0, 7) == "VIRTHUB") {
      use_self_flash = false;
    } else if (serial == ownSerial) {
      use_self_flash = true;
    } else {
      yreq = await this.request("GET", "/bySerial/" + serial + "/flash.json?a=state", null, 0);
      if (yreq.errorType == YAPI_SUCCESS && yreq.bin_result.length > 0) {
        use_self_flash = true;
        baseUrl = "/bySerial/" + serial;
      }
    }
    let bootloaders = await this.getBootloaders();
    let is_shield = serial.slice(0, 7) == "YHUBSHL";
    let i;
    for (i = 0; i < bootloaders.length; i++) {
      let bl = bootloaders[i];
      if (bl == serial) {
        need_reboot = false;
      } else if (is_shield) {
        if (bl.slice(0, 7) == "YHUBSHL") {
          return _throw("Only one YoctoHub-Shield is allowed in update mode");
        }
      }
    }
    if (!use_self_flash && need_reboot) {
      if (bootloaders.length >= 4) {
        return _throw("Too many devices in update mode");
      }
    }
    yreq = await this.request("GET", baseUrl + "/flash.json?a=state", null, 0);
    if (yreq.errorType != YAPI_SUCCESS) {
      return _throw("Cannot check state of firmware upload");
    }
    json = JSON.parse(this._yapi.imm_bin2str(yreq.bin_result));
    if (json["state"] == "uploading" || json["state"] == "flashing") {
      return _throw("Cannot start firmware update: busy (" + json["state"] + ")");
    }
    progress(10, "Send firmware file");
    let progressCb = function(curr, total) {
      curr >>= 10;
      total >>= 10;
      progress(10 + (28 * curr / total >> 0), "Send firmware file: " + curr + "KB / " + total + "KB");
    };
    yreq = await this.request("POST", baseUrl + "/upload.html", new YHTTPBody("firmware", firmware.imm_getData(), progressCb), 0);
    if (yreq.errorType != YAPI_SUCCESS) {
      return _throw("Firmware upload failed: " + yreq.errorMsg);
    }
    yreq = await this.request("GET", baseUrl + "/flash.json?a=state", null, 0);
    if (yreq.errorType != YAPI_SUCCESS) {
      return _throw("Cannot check state of firmware upload");
    }
    json = JSON.parse(this._yapi.imm_bin2str(yreq.bin_result));
    if (json["state"] != "valid") {
      return _throw("Upload of firmware failed: invalid firmware(" + json["state"] + ")");
    }
    if (json["progress"] != "100") {
      return _throw("Upload of firmware failed: incomplete upload");
    }
    if (use_self_flash) {
      let settingsStr = this._yapi.imm_bin2str(settings);
      let settingsAndFiles = JSON.parse(settingsStr);
      let settingsOnly = settingsAndFiles["api"];
      let startupApi = {};
      for (let key in settingsOnly) {
        if (key != "services") {
          startupApi[key] = settingsOnly[key];
        }
      }
      let startupConf = this._yapi.imm_str2bin(JSON.stringify(startupApi));
      progress(38, "Save current settings");
      yreq = await this.request("POST", baseUrl + "/upload.html", new YHTTPBody("startupConf.json", startupConf, null), 0);
      if (yreq.errorType != YAPI_SUCCESS) {
        return _throw("Failed to save settings on hub");
      }
      progress(39, "Save current settings");
      yreq = await this.request("POST", baseUrl + "/upload.html", new YHTTPBody("firmwareConf", startupConf, null), 0);
      if (yreq.errorType != YAPI_SUCCESS) {
        return _throw("Failed to save settings on hub");
      }
    }
    if (use_self_flash) {
      progress(40, "Flash firmware");
      await this.request("GET", baseUrl + "/api/module/rebootCountdown?rebootCountdown=-1003", null, 0);
      await this._yapi.Sleep(7e3);
    } else {
      if (need_reboot) {
        await this.request("GET", "/bySerial/" + serial + "/api/module/rebootCountdown?rebootCountdown=-2", null, 0);
      }
      let timeout = YAPI.GetTickCount() + 2e4;
      let res;
      let found = false;
      progress(40, "Wait for device to be in bootloader");
      do {
        bootloaders = await this.getBootloaders();
        for (i = 0; i < bootloaders.length; i++) {
          let bl = bootloaders[i];
          if (bl == serial) {
            found = true;
            break;
          }
        }
        if (!found) {
          await this._yapi.Sleep(500);
        }
      } while (!found && YAPI.GetTickCount() < timeout);
      progress(45, "Flash firmware");
      let fwsize = firmware.imm_getData().length + 512 >> 10;
      let checkTimer;
      let checkFlash = () => {
        this.request("GET", baseUrl + "/flash.json?a=state", null, 1).then((flashReq) => {
          if (flashReq.errorType == YAPI_SUCCESS) {
            let jsonState = YAPI.imm_bin2str(flashReq.bin_result);
            let res2 = JSON.parse(jsonState);
            if (res2.state == "flashing") {
              if (res2.progress < 20) {
                progress(45 + (res2.progress / 3 >> 0), "Erasing previous firmware: " + (fwsize * (res2.progress - 3) / 18 >> 0) + "KB / " + fwsize + "KB");
              } else {
                progress(45 + (res2.progress / 3 >> 0), "Flashing new firmware: " + (fwsize * (res2.progress - 20) / 76 >> 0) + "KB / " + fwsize + "KB");
              }
            }
          }
          checkTimer = setTimeout(checkFlash, 500);
        }).catch((e) => {
          this._yapi.imm_log("Exception during firmware flash: ", e);
          checkTimer = setTimeout(checkFlash, 500);
        });
      };
      checkTimer = setTimeout(checkFlash, 1e3);
      yreq = await this.request("GET", "/flash.json?a=flash&s=" + serial, null, 0);
      clearTimeout(checkTimer);
      if (yreq.errorType != YAPI_SUCCESS) {
        return _throw("Cannot check state of firmware flash");
      }
      return JSON.parse(this._yapi.imm_bin2str(yreq.bin_result));
    }
    return null;
  }
  async reportFailure(message) {
    if (this._hubEngine) {
      await this._hubEngine.reportFailure(message);
    }
  }
  async hasRwAccess() {
    if (this._rwAccess == null) {
      let yreq = await this.request("GET", "/api/module/serialNumber.json?serialNumber=rwTest", null, 0);
      this._rwAccess = yreq.errorType == YAPI_SUCCESS;
    }
    return this._rwAccess;
  }
  imm_isRwAccess() {
    if (this._rwAccess == null) {
      return false;
    }
    return this._rwAccess;
  }
  imm_setRwAccess(rwAccess) {
    this._rwAccess = rwAccess;
  }
  getHubRef() {
    return this._hubRef;
  }
  get_knownUrls() {
    let res = this._knownUrls.slice();
    return res;
  }
  imm_forgetUrls() {
    this._knownUrls = [];
  }
  imm_getOriginalURL() {
    return this.urlInfo.imm_getOriginalURL();
  }
  imm_getRootUrl() {
    return this.urlInfo.imm_getRootUrl();
  }
  imm_getSerialNumber() {
    return this.hubSerial;
  }
  imm_setSerialNumber(serial) {
    this.hubSerial = serial;
  }
  imm_getNetworkTimeout() {
    return this.stalledTimeoutMs;
  }
  imm_setNetworkTimeout(mstimeout) {
    this.stalledTimeoutMs = mstimeout;
  }
  imm_setHubEngine(engine) {
    this._hubEngine = engine;
  }
  imm_setRetryDelay(value) {
    this.retryDelay = value;
  }
  imm_SetErr(errorType, errorMsg) {
    this._lastErrorType = errorType;
    this._lastErrorMsg = errorMsg;
  }
  async WebSocketJoin(ws, arr_credentials, closeCallback) {
    return this._hubEngine.websocketJoin(ws, arr_credentials, closeCallback);
  }
  imm_UseBestProto() {
    let cur_proto = this.urlInfo.imm_getProto();
    let runtime_urlInfo = this.urlInfo;
    this._hubMode = HubMode.SECURE;
    if (this._portInfo.length > 0) {
      if (this._usePureHTTP) {
        if (cur_proto == "ws" || cur_proto == "wss") {
          this._yapi._throw(YAPI.NOT_SUPPORTED, "Websocket protocol is not supported by VirtualHub-4web.");
        }
        for (let i = 0; i < this._portInfo.length; i++) {
          let portInfo = this._portInfo[i];
          if (portInfo.proto.startsWith("http")) {
            if (this._yapi._logLevel >= 3) {
              this._yapi.imm_log("Hub " + this.urlInfo.imm_getHost() + " will use " + portInfo.proto + " proto on port " + portInfo.port);
            }
            runtime_urlInfo = this.urlInfo;
            runtime_urlInfo.imm_updateBestProto(portInfo.proto, portInfo.port);
            break;
          }
        }
      } else {
        let best_port = 0;
        let best_proto = "ws";
        if (this._portInfo[0].proto == "http" || this._portInfo[0].proto == "ws") {
          this._hubMode = HubMode.LEGACY;
        }
        for (let i = 0; i < this._portInfo.length; i++) {
          let portInfo = this._portInfo[i];
          if (this._hubMode == HubMode.SECURE && (portInfo.proto == "http" || portInfo.proto == "ws")) {
            if (this._yapi._logLevel >= 3) {
              this._yapi.imm_log("Hub " + this.urlInfo.imm_getHost() + " use mixed or legacy mode");
            }
            this._hubMode = HubMode.MIXED;
          }
          if (cur_proto == "auto" && best_port == 0) {
            if (portInfo.proto.startsWith("http") || portInfo.proto.startsWith("ws")) {
              best_proto = portInfo.proto;
              best_port = portInfo.port;
            }
          }
          if (cur_proto == "secure" && best_port == 0) {
            if (portInfo.proto == "https" || portInfo.proto == "wss") {
              best_proto = portInfo.proto;
              best_port = portInfo.port;
            }
          }
        }
        if (best_port != 0) {
          if (this._yapi._logLevel >= 3) {
            this._yapi.imm_log("Hub " + this.urlInfo.imm_getHost() + " will use " + best_proto + " proto on port " + best_port);
          }
          runtime_urlInfo = this.urlInfo;
          runtime_urlInfo.imm_updateBestProto(best_proto, best_port);
        }
      }
    }
    return runtime_urlInfo;
  }
  imm_useMixedMode() {
    return this._hubMode == HubMode.MIXED || this._hubMode == HubMode.LEGACY;
  }
  async waitForPendingQueries(ms_timeout) {
    if (this._hubEngine) {
      await this._hubEngine.waitForPendingQueries(ms_timeout);
    }
  }
};
YGenericHub.globalHubRefCounter = 0;
var YHttpEngine = class extends YHubEngine {
  constructor(hub, runtime_urlInfo, firstInfoJson) {
    super(hub, runtime_urlInfo);
    this.infoJson = null;
    this.ha1 = "";
    this.realm = "";
    this.nonce = "";
    this.opaque = "";
    this.nonceCount = 0;
    this.notbynRequest = null;
    this.infoJson = firstInfoJson;
  }
  imm_makeRequest(method, relUrl, contentType, body, onProgress, onSuccess, onError) {
  }
  imm_abortRequest(clientRequest) {
  }
  imm_sendRequest(method, relUrl, obj_body, onProgress, onSuccess, onError) {
    let body = null;
    let contentType = "text/plain; charset=x-user-defined";
    if (this.infoJson && this.infoJson.realm && this.infoJson.nonce) {
      if (this.realm != this.infoJson.realm || this.nonce != this.infoJson.nonce) {
        this.realm = this.infoJson.realm;
        this.nonce = this.infoJson.nonce;
        this.nonceCount = 0;
      }
      let shorturi = this._runtime_urlInfo.imm_getSubDomain() + relUrl;
      let jsonBody = {
        "x-yauth": {
          method,
          uri: shorturi
        }
      };
      if (this._runtime_urlInfo.imm_hasAuthParam()) {
        let cnonce = Math.floor(Math.random() * 2147483647).toString(16).toLowerCase();
        let nc = (++this.nonceCount).toString(16).toLowerCase();
        let ha1_str = this._runtime_urlInfo.imm_getUser() + ":" + this.realm + ":" + this._runtime_urlInfo.imm_getPass();
        let ha2_str = method + ":" + shorturi;
        let A1 = this._hub._yapi.imm_bin2hexstr(this._hub._yapi.imm_yMD5(ha1_str)).toLowerCase();
        let A2 = this._hub._yapi.imm_bin2hexstr(this._hub._yapi.imm_ySHA1(ha2_str)).toLowerCase();
        let signature = A1 + ":" + this.nonce + ":" + nc + ":" + cnonce + ":auth:" + A2;
        let response = this._hub._yapi.imm_bin2hexstr(this._hub._yapi.imm_ySHA1(signature)).toLowerCase();
        jsonBody["x-yauth"]["username"] = this._runtime_urlInfo.imm_getUser();
        jsonBody["x-yauth"]["cnonce"] = cnonce;
        jsonBody["x-yauth"]["nonce"] = this.nonce;
        jsonBody["x-yauth"]["nc"] = nc;
        jsonBody["x-yauth"]["qop"] = "auth";
        jsonBody["x-yauth"]["response"] = response;
      }
      if (obj_body) {
        let binstr = this._hub._yapi.imm_bin2str(obj_body.data);
        jsonBody["body"] = {
          filename: obj_body.fname,
          b64content: btoa(binstr)
        };
      }
      method = "POST";
      body = JSON.stringify(jsonBody);
      let qpos = relUrl.indexOf("?");
      if (qpos > 0) {
        relUrl = relUrl.slice(0, qpos);
      }
    } else if (obj_body != null) {
      let boundary = this._hub.imm_getBoundary();
      if (this.infoJson && this.infoJson.nonce) {
        contentType = "x-upload; boundary=" + boundary;
      } else {
        contentType = "multipart/form-data; boundary=" + boundary;
      }
      body = this._hub.imm_formEncodeBody(obj_body, boundary);
    }
    return this.imm_makeRequest(method, relUrl, contentType, body, onProgress, onSuccess, onError);
  }
  async tryFetch(relUrl) {
    return new Promise((resolve, reject) => {
      this.imm_sendRequest("GET", relUrl, null, null, (responseText) => {
        resolve({errorType: YAPI_SUCCESS, errorMsg: "", result: responseText});
      }, (errorType, errorMsg, can_be_retry) => {
        if (can_be_retry) {
          this.imm_sendRequest("GET", relUrl, null, null, (responseText2) => {
            resolve({errorType: YAPI_SUCCESS, errorMsg: "", result: responseText2});
          }, (errorType2, errorMsg2, can_be_retry2) => {
            resolve({errorType: errorType2, errorMsg: errorMsg2});
          });
        } else {
          resolve({errorType, errorMsg});
        }
      });
    });
  }
  async reconnectEngine(tryOpenID) {
    this._hub.imm_setCurrentConnID(tryOpenID);
    if (this.infoJson && this.infoJson.nonce && YAPI.GetTickCount() - this.infoJson.stamp > 12e3) {
      if (this._hub._yapi._logLevel >= 4) {
        this._hub._yapi.imm_log("Trying info.json [" + tryOpenID + "]");
      }
      let res_struct = await this.tryFetch("info.json");
      if (res_struct.errorType == YAPI_SUCCESS && res_struct.result) {
        this.infoJson = JSON.parse(res_struct.result);
        this.infoJson.stamp = YAPI.GetTickCount();
      }
    }
    let primaryHub = this._hub._yapi.imm_getPrimaryHub(this._hub);
    if (primaryHub !== this._hub) {
      this._hub.imm_commonDisconnect(tryOpenID, YAPI_SUCCESS, "Hub " + this._hub.imm_getSerialNumber() + " is already connected");
      this._hub.imm_setCurrentConnID("");
      this._hub.imm_signalHubDisconnected(tryOpenID);
      return;
    }
    let args = "";
    if (this._hub.imm_getNotifyPos() >= 0) {
      args = "?abs=" + this._hub.imm_getNotifyPos().toString();
    } else {
      this._hub.imm_setFirstArrivalCallback(true);
    }
    if (this._hub._yapi._logLevel >= 4) {
      this._hub._yapi.imm_log("Opening http connection to hub (" + args + ") [" + tryOpenID + "]");
    }
    this.notbynRequest = this.imm_sendRequest("GET", "/not.byn" + args, null, (moreText) => {
      if (tryOpenID != this._hub.imm_getCurrentConnID()) {
        if (this._hub._yapi._logLevel >= 3) {
          this._hub._yapi.imm_log("Previous request still sending data [" + tryOpenID + "]");
        }
        return;
      }
      if (this.infoJson) {
        this.infoJson.stamp = YAPI.GetTickCount();
      }
      if (this._hub.imm_getcurrentState() < 0) {
        this._hub.signalHubConnected(tryOpenID, this._hub.imm_getSerialNumber());
      }
      this.imm_updateLastPinfStamp();
      this._hub._yapi.parseEvents(this._hub, moreText);
    }, (resultText) => {
      if (tryOpenID != this._hub.imm_getCurrentConnID()) {
        if (this._hub._yapi._logLevel >= 3) {
          this._hub._yapi.imm_log("Previous request completed [" + tryOpenID + "]");
        }
        return;
      }
      this.reconnectEngine(tryOpenID);
    }, (errorType, errorMsg, can_be_retry) => {
      if (tryOpenID != this._hub.imm_getCurrentConnID()) {
        if (this._hub._yapi._logLevel >= 3) {
          this._hub._yapi.imm_log("Previous not.byn request says: " + errorMsg + " [" + tryOpenID + "]");
        }
        return;
      }
      if (!this._hub.imm_isDisconnecting()) {
        if (this._hub._yapi._logLevel >= 3) {
          this._hub._yapi.imm_log("Failed to load not.byn (" + args + "): " + errorMsg + " [" + tryOpenID + "]");
        }
      }
      this._hub.imm_SetErr(errorType, errorMsg);
      if ((errorType == YAPI_UNAUTHORIZED || errorType == YAPI_SSL_UNK_CERT) && !can_be_retry) {
        this._hub.imm_commonDisconnect(tryOpenID, errorType, errorMsg);
      }
      this._hub.imm_disconnectNow();
    });
  }
  imm_disconnectEngineNow(connID = "") {
    if (this._hub._yapi._logLevel >= 4) {
      this._hub._yapi.imm_log("YHTTPEngine.imm_disconnectEngineNow " + connID);
    }
    if (!this.notbynRequest) {
      return;
    }
    let closeConnID = connID ? connID : this._hub.imm_getCurrentConnID();
    this.imm_abortRequest(this.notbynRequest);
    this.notbynRequest = null;
    this._hub.imm_setCurrentConnID("");
    this._hub.imm_signalHubDisconnected(closeConnID);
  }
  async request(method, devUrl, obj_body, tcpchan) {
    if (this._hub._yapi._logLevel >= 3) {
      this._hub.imm_logrequest(method, devUrl, obj_body);
    }
    if (this._hub.imm_getcurrentState() < 0) {
      return new YHTTPRequest(null, YAPI.IO_ERROR, "Hub is currently unavailable");
    }
    return new Promise((resolve, reject) => {
      this.imm_sendRequest(method, devUrl, obj_body, null, (responseText) => {
        if (this._hub.imm_getcurrentState() < 0) {
          resolve(new YHTTPRequest(null, YAPI.IO_ERROR, "Hub is currently unavailable"));
        } else {
          if (this._hub._yapi._logLevel >= 4) {
            this._hub._yapi.imm_log(method + " " + devUrl + " succeeded");
          }
          resolve(new YHTTPRequest(this._hub._yapi.imm_str2bin(responseText)));
        }
      }, (errorType, errorMsg, can_be_retry) => {
        if (this._hub._yapi._logLevel >= 4) {
          this._hub._yapi.imm_log(method + " " + devUrl + " failed (" + errorMsg + ")");
        }
        resolve(new YHTTPRequest(null, errorType, errorMsg));
      });
    });
  }
};
var YWebSocketEngine = class extends YHubEngine {
  constructor(hub, runtime_urlInfo) {
    super(hub, runtime_urlInfo);
    this._DEFAULT_TCP_ROUND_TRIP_TIME = 30;
    this._DEFAULT_TCP_MAX_WINDOW_SIZE = 4 * 65536;
    this._YIO_DEFAULT_TCP_TIMEOUT = 2e4;
    this._YIO_1_MINUTE_TCP_TIMEOUT = 6e4;
    this._YIO_10_MINUTES_TCP_TIMEOUT = 6e5;
    this._USB_META_UTCTIME_SIZE = 5;
    this._USB_META_DLFLUSH_SIZE = 1;
    this._USB_META_ACK_D2H_PACKET_SIZE = 2;
    this._USB_META_WS_ANNOUNCE_SIZE = 8 + 20;
    this._USB_META_WS_AUTHENTICATION_SIZE = 28;
    this._USB_META_WS_ERROR_SIZE = 6;
    this._USB_META_ACK_UPLOAD_SIZE = 6;
    this._USB_META_WS_VALID_SHA1 = 1;
    this._USB_META_WS_RW = 2;
    this.websocket = null;
    this.tcpChan = [];
    this.nextAsyncId = 48;
    this._connectionTime = 0;
    this._remoteVersion = 0;
    this._remoteSerial = "";
    this._remoteNonce = -1;
    this._nonce = -1;
    this._session_error = null;
    this._session_errno = null;
    this._lastUploadAckBytes = [0];
    this._lastUploadAckTime = [0];
    this._lastUploadRateBytes = [0];
    this._lastUploadRateTime = [0];
    this._uploadRate = [0];
    this.fwd_nonce = -1;
    this.fwd_websocket = null;
    this.fwd_credentials = [];
    this.fwd_closeCallback = null;
    this._connectionState = 2;
    this._tcpRoundTripTime = this._DEFAULT_TCP_ROUND_TRIP_TIME;
    this._tcpMaxWindowSize = this._DEFAULT_TCP_MAX_WINDOW_SIZE;
    this.fwd_connectionState = 1;
  }
  imm_asyncWebSocketError(errorType, message) {
    if (this._hub._yapi._logLevel >= 3) {
      this._hub._yapi.imm_log("WS: " + message + " on " + this._runtime_urlInfo.imm_getRootUrl());
    }
  }
  async reconnectEngine(tryOpenID) {
    this._connectionState = 2;
    if (this._hub._yapi._logLevel >= 4) {
      this._hub._yapi.imm_log("Opening websocket connection [" + tryOpenID + "]");
    }
    this._hub.imm_setCurrentConnID(tryOpenID);
    let url = (this._runtime_urlInfo.imm_useSecureSocket() ? "wss://" : "ws://") + this._runtime_urlInfo.imm_getUrl(false, true, true);
    this.imm_webSocketOpen(url + "not.byn");
    this._hub.imm_setFirstArrivalCallback(true);
    if (!this.websocket) {
      this._hub.imm_commonDisconnect(tryOpenID, YAPI_IO_ERROR, "Failed to create WebSocket");
      return;
    }
    this.websocket.onmessage = (evt) => {
      if (this._hub.imm_getCurrentConnID() != tryOpenID) {
        if (this._hub._yapi._logLevel >= 4) {
          this._hub._yapi.imm_log("Incoming WebSocket data for previous connection [" + tryOpenID + "]");
        }
        return;
      }
      this._webSocketMsg(new Uint8Array(evt.data));
      if (this._connectionState == 4) {
        this._connectionState = 5;
        this._hub.signalHubConnected(tryOpenID, this._remoteSerial);
      } else if (this._connectionState == 0) {
        let errMsg = this._session_error ? "WebSocket error: " + this._session_error : "Websocket I/O error";
        if (this._session_errno == 401) {
          this._hub.imm_commonDisconnect(tryOpenID, YAPI_UNAUTHORIZED, errMsg);
        } else {
          this._hub.imm_SetErr(YAPI_IO_ERROR, errMsg);
        }
        this._hub.imm_disconnectNow();
      }
    };
    this.websocket.onclose = (evt) => {
      if (this._hub.imm_getCurrentConnID() != tryOpenID) {
        if (this._hub._yapi._logLevel >= 4) {
          this._hub._yapi.imm_log("WebSocket close received for previous connection [" + tryOpenID + "], now using [" + this._hub.imm_getCurrentConnID() + "]");
        }
        return;
      }
      if (this._hub._yapi._logLevel >= 4) {
        this._hub._yapi.imm_log("WebSocket connection closed [" + tryOpenID + "]");
      }
      this._connectionState = 1;
      this.websocket = null;
      if (this._hub.retryDelay < 0) {
        this._hub.imm_commonDisconnect(tryOpenID, YAPI_IO_ERROR, "Websocket callback connection closed");
      }
      this.imm_dropAllPendingConnection();
      this._hub.imm_signalHubDisconnected(tryOpenID);
    };
    this.websocket.onerror = (evt) => {
      if (this._hub.imm_getCurrentConnID() != tryOpenID) {
        if (this._hub._yapi._logLevel >= 4) {
          this._hub._yapi.imm_log("WebSocket error received for previous connection [" + tryOpenID + "]");
        }
        return;
      }
      if (evt.message && (!/ ETIMEDOUT /.test(evt.message) || this._hub._yapi._logLevel >= 4)) {
        if (this._hub._yapi._logLevel >= 3) {
          this._hub._yapi.imm_log("WebSocket error [" + tryOpenID + "]: ", evt);
        }
        if (evt.error.code == "DEPTH_ZERO_SELF_SIGNED_CERT") {
          this._hub.imm_commonDisconnect(tryOpenID, YAPI_SSL_UNK_CERT, evt.message);
        } else {
          this._hub.imm_SetErr(YAPI_IO_ERROR, evt.message);
        }
      }
      if (this._hub.retryDelay < 0) {
        this._hub.imm_commonDisconnect(tryOpenID, YAPI_IO_ERROR, "Websocket callback connection closed");
      }
      this._hub.imm_disconnectNow();
      this._hub.imm_signalHubDisconnected(tryOpenID);
    };
    if (this._hub.timeoutId) {
      clearTimeout(this._hub.timeoutId);
    }
    this._hub.timeoutId = setTimeout(() => {
      if (!this.imm_isForwarded()) {
        if (this._hub._yapi._logLevel >= 3) {
          this._hub._yapi.imm_log("WS: connection stalled during open [" + tryOpenID + "]");
        }
        this._hub.imm_disconnectNow();
      }
    }, this._hub.imm_getNetworkTimeout());
  }
  imm_computeAuth(user, pass, serial, nonce) {
    let ha1_str = user + ":" + serial + ":" + pass;
    let ha1 = this._hub._yapi.imm_bin2hexstr(this._hub._yapi.imm_yMD5(ha1_str)).toLowerCase();
    let nonce8 = new Uint8Array([(nonce & 255) >>> 0, (nonce & 65280) >>> 8, (nonce & 16711680) >>> 16, nonce >>> 24]);
    let sha1_raw = ha1 + this._hub._yapi.imm_bin2hexstr(nonce8).toLowerCase();
    return this._hub._yapi.imm_ySHA1(sha1_raw.toLowerCase());
  }
  imm_isForwarded() {
    return this.fwd_connectionState == 5 && this.fwd_websocket !== null;
  }
  async _webSocketMsg(arr_bytes) {
    try {
      if (this.imm_isForwarded()) {
        this.imm_updateLastPinfStamp();
        this.fwd_websocket.send(arr_bytes);
        return;
      }
      let reltime = (this._hub._yapi.GetTickCount() - this._connectionTime) / 1e3;
      let ystream = arr_bytes[0] >>> 3;
      let text = "";
      if (ystream == 8) {
        for (let i = 1; i < arr_bytes.length; i++) {
          text += String.fromCharCode(arr_bytes[i]);
        }
        this.imm_updateLastPinfStamp();
        await this._hub._yapi.parseEvents(this._hub, text);
        return;
      }
      let ws = this.websocket;
      let tcpchan = arr_bytes[0] & 7;
      if (ystream == 1 || ystream == 2 || ystream == 9) {
        if (tcpchan > 3) {
          this.imm_asyncWebSocketError(YAPI_IO_ERROR, "Unexpected frame for tcpChan " + tcpchan + " (" + ystream + ")");
          return;
        }
        let tcp_end = arr_bytes.length;
        let yreq = this.tcpChan[tcpchan];
        if (!yreq) {
          this.imm_asyncWebSocketError(YAPI_IO_ERROR, "Drop frame for closed tcpChan " + tcpchan + " (" + ystream + ")");
          return;
        }
        if (ystream == 9) {
          tcp_end--;
          let rcvId = arr_bytes[tcp_end];
          if (this._hub._yapi._logLevel >= 5) {
            this._hub._yapi.imm_log("async-" + rcvId + " close received");
          }
          if (yreq.asyncId == 0) {
            if (this._hub._yapi._logLevel >= 4) {
              this._hub._yapi.imm_log("async-" + rcvId + " close received while req @" + yreq._creat + " was pending");
            }
            this.imm_asyncWebSocketError(YAPI_IO_ERROR, "Asynchronous close received, sync reply request");
            return;
          } else if (yreq.asyncId != rcvId) {
            if (this._hub._yapi._logLevel >= 4) {
              this._hub._yapi.imm_log("async-" + rcvId + " close received instead of async-" + yreq.asyncId + " close");
            }
            this.imm_asyncWebSocketError(YAPI_IO_ERROR, "Incorrect async-close signature on tcpChan " + tcpchan);
            return;
          }
        }
        let oldArr = yreq.bin_result;
        let newArr = new Uint8Array(oldArr.length + tcp_end - 1);
        newArr.set(oldArr, 0);
        newArr.set(arr_bytes.subarray(1, tcp_end), oldArr.length);
        yreq.bin_result = newArr;
        if (ystream == 2 || ystream == 9) {
          this.tcpChan[tcpchan] = yreq.next;
          if (ystream == 2) {
            if (yreq.asyncId != 0) {
              if (this._hub._yapi._logLevel >= 4) {
                this._hub._yapi.imm_log("Synchronous close received instead of async-" + yreq.asyncId + " close");
              }
              this.imm_asyncWebSocketError(YAPI_IO_ERROR, "Synchronous close received, async ack expected");
              return;
            } else if (this.websocket) {
              if (yreq.toBeSent && yreq.sendPos < yreq.toBeSent.length) {
                if (this._hub._yapi._logLevel >= 3) {
                  this._hub._yapi.imm_log("WS: tcpclose at " + yreq.sendPos + " < " + yreq.toBeSent.length);
                }
                this._hub.imm_disconnectNow();
                if (yreq.timeoutId) {
                  clearTimeout(yreq.timeoutId);
                }
                if (yreq.asyncId == 0) {
                  yreq.errorType = YAPI_IO_ERROR;
                  yreq.errorMsg = "TCP closed during upload";
                  if (yreq.acceptor) {
                    try {
                      yreq.acceptor(yreq);
                    } catch (e) {
                    }
                  }
                }
                return;
              }
              if (yreq.timeoutId) {
                let frame = new Uint8Array(1);
                frame[0] = (2 << 3) + tcpchan;
                this.websocket.send(frame);
              }
            }
          }
          if (yreq.timeoutId) {
            clearTimeout(yreq.timeoutId);
            yreq.timeoutId = 0;
          }
          let pos = yreq.bin_result.indexOf(13);
          if (pos < 0) {
            yreq.errorType = YAPI_IO_ERROR;
            yreq.errorMsg = "Bad response header";
          } else {
            let header = this._hub._yapi.imm_bin2str(yreq.bin_result.subarray(0, pos));
            let words = header.split(" ");
            if (words[0] == "OK") {
              yreq.errorType = YAPI_SUCCESS;
              let nextpos = yreq.bin_result.indexOf(13, pos + 2);
              while (nextpos > pos + 2) {
                pos = nextpos;
                nextpos = yreq.bin_result.indexOf(13, pos + 2);
              }
              if (nextpos < 0) {
                nextpos = pos;
              }
              yreq.bin_result = yreq.bin_result.subarray(nextpos + 2);
            } else if (words[0] == "0K") {
              yreq.errorType = YAPI_IO_ERROR;
              yreq.errorMsg = "Unexpected persistent connection";
            } else {
              let status = parseInt(words[1]);
              yreq.errorType = status == 401 ? YAPI_UNAUTHORIZED : YAPI_IO_ERROR;
              yreq.errorMsg = "HTTP error " + header.slice(words[0].length + 1) + " on " + yreq.devUrl;
            }
          }
          if (yreq.asyncId == 0) {
            if (this._hub._yapi._logLevel >= 5) {
              this._hub._yapi.imm_log("request @" + yreq._creat + " done, status=" + yreq.errorType);
            }
            this.imm_sendPendingRequest(tcpchan);
            if (yreq.acceptor) {
              yreq.acceptor(yreq);
            }
          } else {
            if (yreq.errorType != YAPI_SUCCESS) {
              this.imm_asyncWebSocketError(YAPI_IO_ERROR, "Async request error: " + yreq.errorMsg);
            }
          }
        }
        return;
      }
      if (!this.websocket) {
        return;
      }
      if (ystream == 5) {
        let metatype = arr_bytes[1];
        switch (metatype) {
          case 4:
            if (arr_bytes.length < 1 + this._USB_META_WS_ANNOUNCE_SIZE) {
              return;
            }
            this._remoteVersion = arr_bytes[2];
            if (this._remoteVersion < 1) {
              return;
            }
            let maxtcpws = (arr_bytes[3] << 4) + (arr_bytes[4] << 12);
            if (maxtcpws > 0) {
              this._tcpMaxWindowSize = maxtcpws;
            }
            this._remoteNonce = arr_bytes[5] + (arr_bytes[6] << 8) + (arr_bytes[7] << 16) + (arr_bytes[8] << 24);
            for (let i = 9; i < 9 + 20; i++) {
              if (arr_bytes[i] == 0) {
                this._remoteSerial = this._hub._yapi.imm_bin2str(arr_bytes.subarray(9, i));
                break;
              }
            }
            let nonce = new Uint8Array(4);
            this.imm_getRandomValues(nonce);
            this._nonce = nonce[0] + (nonce[1] << 8) + (nonce[2] << 16) + (nonce[3] << 24);
            this._connectionTime = this._hub._yapi.GetTickCount();
            this._connectionState = 3;
            let frame = new Uint8Array(1 + this._USB_META_WS_AUTHENTICATION_SIZE);
            let version = this._remoteVersion < 2 ? this._remoteVersion : 2;
            let flags = 0;
            frame[0] = 5 << 3;
            frame[1] = 5;
            frame[2] = version;
            if (this._runtime_urlInfo.imm_getPass() != "") {
              flags = this._USB_META_WS_VALID_SHA1;
              let sha1 = this.imm_computeAuth(this._runtime_urlInfo.imm_getUser(), this._runtime_urlInfo.imm_getPass(), this._remoteSerial, this._remoteNonce);
              for (let i = 0; i < sha1.length; i++) {
                frame[9 + i] = sha1[i];
              }
            }
            frame[3] = flags & 255;
            frame[4] = flags >>> 8;
            frame[5] = this._nonce & 255;
            frame[6] = this._nonce >>> 8 & 255;
            frame[7] = this._nonce >>> 16 & 255;
            frame[8] = this._nonce >>> 24 & 255;
            this.websocket.send(frame);
            break;
          case 5:
            if (this._connectionState != 3) {
              return;
            }
            if (arr_bytes.length < 1 + this._USB_META_WS_AUTHENTICATION_SIZE) {
              return;
            }
            this._tcpRoundTripTime = this._hub._yapi.GetTickCount() - this._connectionTime + 1;
            if (this._tcpMaxWindowSize < 2048 && this._tcpRoundTripTime < 7) {
              this._tcpRoundTripTime = 7;
            }
            let uploadRate = this._tcpMaxWindowSize * 1e3 / this._tcpRoundTripTime >> 0;
            if (this._hub._yapi._logLevel >= 4) {
              this._hub._yapi.imm_log("RTT=" + this._tcpRoundTripTime + "ms, WS=" + this._tcpMaxWindowSize + ", uploadRate=" + uploadRate / 1e3 + " KB/s");
            }
            this._remoteVersion = arr_bytes[2];
            if (this._remoteVersion < 1) {
              return;
            }
            let inflags = arr_bytes[3] + (arr_bytes[4] << 8);
            if ((inflags & this._USB_META_WS_RW) != 0) {
              this._hub.imm_setRwAccess(true);
            } else {
              this._hub.imm_setRwAccess(false);
            }
            if ((inflags & this._USB_META_WS_VALID_SHA1) != 0) {
              let remote_sha1 = arr_bytes.subarray(9, 29);
              let sha1 = this.imm_computeAuth(this._runtime_urlInfo.imm_getUser(), this._runtime_urlInfo.imm_getPass(), this._remoteSerial, this._nonce);
              for (let i = 0; i < sha1.length; i++) {
                if (sha1[i] != remote_sha1[i]) {
                  this._session_errno = 401;
                  this._session_error = "Authentication failed";
                  this._connectionState = 0;
                  return;
                }
              }
              this._connectionState = 4;
            } else {
              if (this._runtime_urlInfo.imm_getPass() == "") {
                this._connectionState = 4;
              } else {
                this._session_errno = 401;
                if (this._runtime_urlInfo.imm_getUser() == "admin" && !this._hub.imm_isRwAccess()) {
                  this._session_error = "Authentication as admin failed";
                } else {
                  this._session_error = "Password not set on remote hub";
                }
                this._connectionState = 0;
                return;
              }
            }
            break;
          case 6:
            this._session_errno = arr_bytes[3] + (arr_bytes[4] << 8);
            if (this._session_errno == 401) {
              this._session_error = "Authentication failed";
            } else {
              this._session_error = "Remote hub closed connection with error " + this._session_errno;
            }
            this._connectionState = 0;
            break;
          case 7:
            tcpchan = arr_bytes[2];
            if (this.tcpChan[tcpchan]) {
              let yreq = this.tcpChan[tcpchan];
              let ackBytes = arr_bytes[3] + (arr_bytes[4] << 8) + (arr_bytes[5] << 16) + (arr_bytes[6] << 24);
              let ackTime = this._hub._yapi.GetTickCount();
              if (this._lastUploadAckTime[tcpchan] != 0 && ackBytes > this._lastUploadAckBytes[tcpchan]) {
                this._lastUploadAckBytes[tcpchan] = ackBytes;
                this._lastUploadAckTime[tcpchan] = ackTime;
                let deltaBytes = ackBytes - this._lastUploadRateBytes[tcpchan];
                let deltaTime = ackTime - this._lastUploadRateTime[tcpchan];
                if (deltaTime < 500)
                  break;
                if (deltaTime < 1e3 && deltaBytes < 65536)
                  break;
                this._lastUploadRateBytes[tcpchan] = ackBytes;
                this._lastUploadRateTime[tcpchan] = ackTime;
                if (yreq.progressCb && yreq.toBeSent) {
                  yreq.progressCb(ackBytes, yreq.toBeSent.length);
                }
                let newRate = deltaBytes * 1e3 / deltaTime;
                this._uploadRate[tcpchan] = 0.8 * this._uploadRate[tcpchan] + 0.3 * newRate >> 0;
                if (this._hub._yapi._logLevel >= 5) {
                  this._hub._yapi.imm_log("New rate: " + this._uploadRate[tcpchan] / 1e3 + " KB/s (last " + (deltaBytes / 1e3 >> 0) + "KB sent at " + (newRate >> 0) / 1e3 + " KB/s)");
                }
              } else {
                this._lastUploadAckBytes[tcpchan] = ackBytes;
                this._lastUploadAckTime[tcpchan] = ackTime;
                this._lastUploadRateBytes[tcpchan] = ackBytes;
                this._lastUploadRateTime[tcpchan] = ackTime;
                if (yreq.progressCb && yreq.toBeSent) {
                  yreq.progressCb(ackBytes, yreq.toBeSent.length);
                }
                this.imm_sendPendingRequest(tcpchan);
              }
            }
            break;
        }
        return;
      }
      this.imm_asyncWebSocketError(YAPI_IO_ERROR, "Unsupported message: " + this._hub._yapi.imm_bin2hexstr(arr_bytes));
    } catch (e) {
      this._hub._yapi.imm_log("Unhandled exception in _webSocketMsg:", e);
    }
  }
  imm_webSocketSend(arr_bytes) {
    if (this.websocket) {
      this.websocket.send(arr_bytes);
    }
  }
  imm_hasPendingRequest() {
    for (let tcpchan = 0; tcpchan < 4; tcpchan++) {
      let queue = this.tcpChan[tcpchan];
      if (queue) {
        return true;
      }
    }
    return false;
  }
  async waitForPendingQueries(ms_duration) {
    let end = this._hub._yapi.GetTickCount() + ms_duration;
    let remaining = ms_duration;
    while (this.imm_hasPendingRequest() && remaining > 0) {
      let waitTime = Math.min(remaining, 25);
      await new Promise((resolve, reject) => {
        setTimeout(resolve, waitTime);
      });
      remaining = end - this._hub._yapi.GetTickCount();
    }
  }
  async request(method, devUrl, obj_body, tcpchan) {
    if (this._hub._yapi._logLevel >= 3) {
      this._hub.imm_logrequest(method, devUrl, obj_body);
    }
    let httpPromise = new Promise((resolve, reject) => {
      let subReq = method + " " + devUrl + " \r\n\r\n";
      let ws = this.websocket;
      let isAsync = this._remoteVersion > 0 && devUrl.slice(-2) == "&.";
      let yreq = new YHTTPRequest(new Uint8Array(0));
      if (this._hub._yapi._logLevel >= 5) {
        yreq._creat = (Date.now() % 6e5).toString();
        this._hub._yapi.imm_log("request @" + yreq._creat + ": " + method + " " + devUrl);
      }
      yreq.acceptor = resolve;
      yreq.devUrl = devUrl;
      yreq.sendPos = 0;
      if (obj_body) {
        let boundary = this._hub.imm_getBoundary();
        let body = this._hub.imm_formEncodeBody(obj_body, boundary);
        subReq = subReq.slice(0, -2) + "Content-Type: x-upload, boundary=" + boundary + "\r\n\r\n";
        yreq.toBeSent = new Uint8Array(subReq.length + body.length);
        yreq.toBeSent.set(body, subReq.length);
        yreq.progressCb = obj_body.progressCb;
      } else {
        yreq.toBeSent = new Uint8Array(subReq.length);
      }
      for (let i = 0; i < subReq.length; i++) {
        yreq.toBeSent[i] = subReq.charCodeAt(i);
      }
      if (tcpchan > 3) {
        yreq.errorType = YAPI_IO_ERROR;
        yreq.errorMsg = "Unsupported tcpChan " + tcpchan;
        try {
          yreq.acceptor(yreq);
        } catch (e) {
        }
        return;
      }
      if (!ws || this._hub.imm_isDisconnecting() || this._connectionState != 5) {
        if (this._hub._yapi._logLevel >= 4) {
          let wsState = ws ? " websocket=NULL" : "";
          let dsState = this._hub.imm_isDisconnecting() ? " disconnecting" : "";
          let cnState = this._connectionState != 5 ? " connState=" + this._connectionState : "";
          this._hub._yapi.imm_log("request @" + yreq._creat + " failed, websocket is down:" + wsState + dsState + cnState);
        }
        yreq.errorType = YAPI_IO_ERROR;
        yreq.errorMsg = "WebSocket not connected";
        try {
          yreq.acceptor(yreq);
        } catch (e) {
        }
        return;
      }
      if (isAsync) {
        yreq.asyncId = this.nextAsyncId++;
        if (this.nextAsyncId >= 127) {
          this.nextAsyncId = 48;
        }
      }
      let queue = this.tcpChan[tcpchan];
      if (queue) {
        while (queue.next) {
          queue = queue.next;
        }
        queue.next = yreq;
      } else {
        this.tcpChan[tcpchan] = yreq;
      }
      this.imm_sendPendingRequest(tcpchan);
    });
    return httpPromise;
  }
  imm_sendPendingRequest(tcpchan) {
    let yreq = this.tcpChan[tcpchan];
    while (yreq) {
      if (!this.websocket || this._hub.imm_isDisconnecting() || this._connectionState != 5) {
        if (this._hub._yapi._logLevel >= 4) {
          this._hub._yapi.imm_log("request @" + yreq._creat + " failed, websocket is down");
        }
        yreq.errorType = YAPI_IO_ERROR;
        yreq.errorMsg = "WebSocket not connected";
        if (yreq.acceptor) {
          try {
            yreq.acceptor(yreq);
          } catch (e) {
          }
        }
        yreq = yreq.next;
        continue;
      }
      let pendingCount = 1;
      for (let yr = yreq; yr.next; yr = yr.next) {
        pendingCount++;
      }
      if (!yreq.toBeSent) {
        if (yreq.asyncId == 0) {
          if (this._hub._yapi._logLevel >= 5) {
            this._hub._yapi.imm_log(pendingCount.toString() + " req pending, @" + yreq._creat + " not completed");
          }
          return;
        }
        yreq = yreq.next;
        continue;
      }
      let isAsync = yreq.asyncId != 0;
      let asyncCloseSet = false;
      let pos = yreq.sendPos;
      let end = yreq.toBeSent.length;
      let i, frame;
      if (end > 2108 && this._remoteVersion >= 2 && tcpchan == 0) {
        if (pos == 0) {
          end = 2108;
          this._lastUploadAckBytes[tcpchan] = 0;
          this._lastUploadAckTime[tcpchan] = 0;
          this._uploadRate[tcpchan] = this._tcpMaxWindowSize * 1e3 / this._tcpRoundTripTime >> 0;
        } else if (this._lastUploadAckTime[tcpchan] == 0) {
          if (yreq.sendTimeoutId)
            clearTimeout(yreq.sendTimeoutId);
          yreq.sendTimeoutId = setTimeout(() => {
            this.imm_sendPendingRequest(tcpchan);
          }, this._tcpRoundTripTime);
          return;
        } else {
          let bytesOnTheAir = pos - this._lastUploadAckBytes[tcpchan];
          let uploadRate = this._uploadRate[tcpchan];
          let timeOnTheAir = this._hub._yapi.GetTickCount() - this._lastUploadAckTime[tcpchan];
          let toBeSent = 2 * uploadRate + 1024 - bytesOnTheAir + uploadRate * timeOnTheAir / 1e3 >> 0;
          if (toBeSent + bytesOnTheAir > this._DEFAULT_TCP_MAX_WINDOW_SIZE) {
            toBeSent = this._DEFAULT_TCP_MAX_WINDOW_SIZE - bytesOnTheAir;
          }
          if (toBeSent < 64) {
            let waitTime = 1e3 * (128 - toBeSent) / uploadRate >> 0;
            if (waitTime < 2)
              waitTime = 2;
            if (yreq.sendTimeoutId)
              clearTimeout(yreq.sendTimeoutId);
            yreq.sendTimeoutId = setTimeout(() => {
              this.imm_sendPendingRequest(tcpchan);
            }, waitTime);
            return;
          }
          if (end > pos + toBeSent) {
            if (toBeSent > 124) {
              toBeSent = (toBeSent / 124 >> 0) * 124;
            }
            end = pos + toBeSent;
          }
        }
      }
      while (pos < end) {
        let framelen = 1 + end - pos;
        if (framelen > 125)
          framelen = 125;
        let datalen = framelen - 1;
        if (pos < 180 && pos + datalen >= 192) {
          datalen = 191 - pos;
          framelen = datalen + 1;
        }
        if (isAsync && pos + datalen == yreq.toBeSent.length && framelen < 125) {
          frame = new Uint8Array(framelen + 1);
          frame[0] = 8 * 9 + tcpchan;
          frame[framelen] = yreq.asyncId;
          asyncCloseSet = true;
        } else {
          frame = new Uint8Array(framelen);
          frame[0] = 8 * 1 + tcpchan;
        }
        frame.set(yreq.toBeSent.subarray(pos, pos + datalen), 1);
        pos += datalen;
        this.imm_webSocketSend(frame);
      }
      let sent = pos - yreq.sendPos;
      yreq.sendPos = pos;
      if (yreq.sendPos < yreq.toBeSent.length) {
        let waitTime = 1e3 * sent / this._uploadRate[tcpchan] >> 0;
        if (waitTime < 2)
          waitTime = 2;
        if (yreq.sendTimeoutId)
          clearTimeout(yreq.sendTimeoutId);
        yreq.sendTimeoutId = setTimeout(() => {
          this.imm_sendPendingRequest(tcpchan);
        }, waitTime);
        return;
      }
      if (isAsync && !asyncCloseSet) {
        frame = new Uint8Array(2);
        frame[0] = 8 * 9 + tcpchan;
        frame[1] = yreq.asyncId;
        this.imm_webSocketSend(frame);
      }
      yreq.toBeSent = null;
      if (isAsync && yreq.acceptor) {
        try {
          yreq.acceptor(yreq);
        } catch (e) {
          this._hub._yapi.imm_log("WS: async acceptor exception: ", e);
        }
      }
      let mstimeout = this._hub._yapi._networkTimeoutMs;
      if (yreq.devUrl) {
        if (yreq.devUrl.indexOf("/testcb.txt") >= 0) {
          mstimeout = this._YIO_1_MINUTE_TCP_TIMEOUT;
        } else if (yreq.devUrl.indexOf("/logger.json") >= 0) {
          mstimeout = this._YIO_1_MINUTE_TCP_TIMEOUT;
        } else if (yreq.devUrl.indexOf("/rxmsg.json") >= 0) {
          mstimeout = this._YIO_1_MINUTE_TCP_TIMEOUT;
        } else if (yreq.devUrl.indexOf("/rxdata.bin") >= 0) {
          mstimeout = this._YIO_1_MINUTE_TCP_TIMEOUT;
        } else if (yreq.devUrl.indexOf("/at.txt") >= 0) {
          mstimeout = this._YIO_1_MINUTE_TCP_TIMEOUT;
        } else if (yreq.devUrl.indexOf("/files.json") >= 0) {
          mstimeout = this._YIO_1_MINUTE_TCP_TIMEOUT;
        } else if (yreq.devUrl.indexOf("/upload.html") >= 0) {
          mstimeout = this._YIO_10_MINUTES_TCP_TIMEOUT;
        } else if (yreq.devUrl.indexOf("/flash.json") >= 0) {
          mstimeout = this._YIO_10_MINUTES_TCP_TIMEOUT;
        } else if (yreq.devUrl.indexOf("/Yvw4I.js") >= 0) {
          mstimeout = this._YIO_10_MINUTES_TCP_TIMEOUT;
        }
      }
      yreq.timeoutId = setTimeout((chan, yr) => {
        this.imm_abortRequest(chan, yr);
      }, mstimeout, tcpchan, yreq);
      yreq._sent = (Date.now() % 6e5).toString();
      if (this._hub._yapi._logLevel >= 5) {
        this._hub._yapi.imm_log("req @" + yreq._creat + " sent (1/" + pendingCount.toString() + ")" + (isAsync ? " async-" + yreq.asyncId + ", continue" : ", waiting for reply"));
      }
      if (!isAsync) {
        return;
      }
      yreq = yreq.next;
    }
  }
  imm_abortRequest(tcpchan, yreq) {
    if (!yreq.timeoutId)
      return;
    yreq.timeoutId = null;
    if (yreq.asyncId == 0) {
      let frame = new Uint8Array(1);
      frame[0] = 8 * 2 + tcpchan;
      this.imm_webSocketSend(frame);
      if (this._hub._yapi._logLevel >= 4) {
        let pendingCount = 1;
        for (let yr = yreq; yr.next; yr = yr.next) {
          pendingCount++;
        }
        this._hub._yapi.imm_log(pendingCount.toString() + " req pending, @" + yreq._creat + " is in timeout");
      }
      setTimeout((chan, yr) => {
        this._hub._yapi.imm_log("Dropping synchronous request after timeout: " + yr.devUrl);
        this.imm_forgetRequest(chan, yr);
      }, 5e3, tcpchan, yreq);
    }
    this.imm_asyncWebSocketError(YAPI_IO_ERROR, "Timeout on " + yreq.devUrl + " (tcpchan " + tcpchan + ")");
  }
  imm_forgetRequest(tcpchan, yreq) {
    let queue = this.tcpChan[tcpchan];
    if (queue == yreq) {
      this.tcpChan[tcpchan] = yreq.next;
      if (yreq.asyncId == 0) {
        yreq.errorType = YAPI_IO_ERROR;
        yreq.errorMsg = "Timeout on " + yreq.devUrl + " (tcpchan " + tcpchan + ")";
        if (yreq.acceptor) {
          try {
            yreq.acceptor(yreq);
          } catch (e) {
          }
        }
      }
      this.imm_sendPendingRequest(tcpchan);
    }
  }
  imm_dropAllPendingConnection() {
    if (this.fwd_connectionState != 1 && this.fwd_websocket) {
      this.fwd_connectionState = 1;
      this.fwd_websocket.close();
      this.fwd_websocket = null;
    }
    for (let tcpchan = 0; tcpchan < this.tcpChan.length; tcpchan++) {
      for (let yreq = this.tcpChan[tcpchan]; yreq; yreq = yreq.next) {
        this.tcpChan[tcpchan] = yreq.next;
        if (yreq.timeoutId) {
          clearTimeout(yreq.timeoutId);
          yreq.timeoutId = 0;
        }
        if (yreq.asyncId == 0) {
          if (this._hub._yapi._logLevel >= 4) {
            this._hub._yapi.imm_log("drop @" + yreq._creat + " (websocket down)");
          }
          yreq.errorType = YAPI_IO_ERROR;
          yreq.errorMsg = "Request " + yreq.devUrl + " dropped (websocket down)";
          if (yreq.acceptor) {
            try {
              yreq.acceptor(yreq);
            } catch (e) {
            }
          }
        }
      }
    }
  }
  async websocketJoin(ws, arr_credentials, close_callback) {
    if (this._connectionState != 5) {
      this.imm_asyncWebSocketError(YAPI_IO_ERROR, "Hub is disconnected, cannot join");
      return false;
    }
    this.fwd_websocket = ws;
    this.fwd_credentials = arr_credentials;
    this.fwd_closeCallback = close_callback;
    this.fwd_connectionState = 2;
    ws.onmessage = (evt) => {
      if (this.fwd_connectionState == 5) {
        if (this._connectionState == 5) {
          this.imm_webSocketSend(evt.data);
        } else {
          this._hub._yapi.imm_log("WS: drop packet from fwd API (state=" + this._connectionState + ")");
        }
      } else if (this.fwd_connectionState == 3) {
        this.imm_handleAPIAuthPkt(evt.data);
      } else {
        this._hub._yapi.imm_log("WS: drop packet from fwd API (fwd_state=" + this.fwd_connectionState + ")");
      }
    };
    ws.onclose = (evt) => {
      this.fwd_connectionState = 1;
      this.fwd_websocket = null;
      if (this.fwd_closeCallback) {
        this.fwd_closeCallback();
      }
    };
    return this.imm_sendAPIAnnouncePkt();
  }
  imm_sendAPIAnnouncePkt() {
    if (!this.fwd_websocket) {
      return false;
    }
    let frame = new Uint8Array(1 + this._USB_META_WS_ANNOUNCE_SIZE);
    let nonce = new Uint8Array(4);
    this.imm_getRandomValues(nonce);
    frame[0] = 5 << 3;
    frame[1] = 4;
    frame[2] = 2;
    frame[3] = this._tcpMaxWindowSize >> 4 & 255;
    frame[4] = this._tcpMaxWindowSize >> 12 & 255;
    for (let i = 0; i < 4; i++) {
      frame[5 + i] = nonce[i];
    }
    for (let i = 0; i < this._remoteSerial.length && i < 20; i++) {
      frame[9 + i] = this._remoteSerial.charCodeAt(i);
    }
    this.fwd_nonce = frame[5] + (frame[6] << 8) + (frame[7] << 16) + (frame[8] << 24);
    this.fwd_connectionState = 3;
    this.fwd_websocket.send(frame);
    return true;
  }
  imm_handleAPIAuthPkt(msg) {
    if (msg.length < 1 + this._USB_META_WS_AUTHENTICATION_SIZE || msg[0] != 5 << 3) {
      if (this._hub._yapi._logLevel >= 3) {
        this._hub._yapi.imm_log("bad-apiauth1\n");
      }
      this.fwd_connectionState = 0;
      return;
    }
    if (msg[1] != 5 || msg[2] > 2) {
      if (this._hub._yapi._logLevel >= 3) {
        this._hub._yapi.imm_log("bad-apiauth2\n");
      }
      this.fwd_connectionState = 0;
      return;
    }
    this._remoteVersion = msg[2];
    let flags = msg[3] + (msg[4] << 8);
    if ((flags & this._USB_META_WS_VALID_SHA1) == 0) {
      if (this._hub._yapi._logLevel >= 3) {
        this._hub._yapi.imm_log("bad-apiauth3\n");
      }
      this.fwd_connectionState = 0;
      return;
    }
    if (!this.fwd_websocket) {
      if (this._hub._yapi._logLevel >= 3) {
        this._hub._yapi.imm_log("no-fwd-ws\n");
      }
      this.fwd_connectionState = 0;
      return;
    }
    let credIdx, remote_sha1 = msg.subarray(9, 29);
    let credentials = this.fwd_credentials;
    for (credIdx = 0; credIdx < credentials.length; credIdx++) {
      let j, sha12 = this.imm_computeAuth(credentials[credIdx].user, credentials[credIdx].pass, this._remoteSerial, this.fwd_nonce);
      for (j = 0; j < sha12.length; j++) {
        if (sha12[j] != remote_sha1[j])
          break;
      }
      if (j >= sha12.length)
        break;
    }
    if (credIdx >= credentials.length) {
      if (this._hub._yapi._logLevel >= 3) {
        this._hub._yapi.imm_log("bad-apiauth4\n");
      }
      msg.fill(0, 3);
      this.fwd_websocket.send(msg);
      this.fwd_connectionState = 0;
      return;
    }
    msg[3] |= this._USB_META_WS_RW;
    this.fwd_nonce = msg[5] + (msg[6] << 8) + (msg[7] << 16) + (msg[8] << 24);
    let sha1 = this.imm_computeAuth(credentials[credIdx].user, credentials[credIdx].pass, this._remoteSerial, this.fwd_nonce);
    for (let i = 0; i < sha1.length; i++) {
      msg[9 + i] = sha1[i];
    }
    this.fwd_websocket.send(msg);
    this.fwd_connectionState = 5;
  }
  async detach(errType = YAPI.IO_ERROR, errMsg = "Hub has been forcibly detached") {
    let tcpchan_busy;
    let timeout = this._hub._yapi.GetTickCount() + 3e3;
    do {
      tcpchan_busy = false;
      for (let tcpchan = 0; tcpchan < 4; tcpchan++) {
        if (this.tcpChan[tcpchan] != null) {
          tcpchan_busy = true;
          break;
        }
      }
      if (tcpchan_busy) {
        await this._hub._yapi._microSleep_internal();
      }
    } while (tcpchan_busy && timeout > this._hub._yapi.GetTickCount());
    this._hub.imm_commonDisconnect("detach", errType, errMsg);
    this._hub.imm_disconnectNow();
  }
  imm_disconnectEngineNow(connID = "") {
    if (!this.websocket) {
      return;
    }
    this._connectionState = 1;
    let prevOpenID = connID ? connID : this._hub.imm_getCurrentConnID();
    let websocket = this.websocket;
    this._hub.imm_setCurrentConnID("");
    this.websocket = null;
    websocket.onclose = null;
    websocket.onerror = null;
    try {
      websocket.close();
    } catch (e) {
    }
    if (websocket.terminate) {
      setTimeout(() => {
        try {
          if (websocket.terminate) {
            websocket.terminate();
          }
        } catch (e) {
        }
      }, 900);
    }
    this.imm_dropAllPendingConnection();
    this._hub.imm_signalHubDisconnected(prevOpenID);
  }
  imm_isConnected() {
    if (this._connectionState != 5) {
      return false;
    }
    return super.imm_isConnected();
  }
};
var YHub = class {
  constructor(obj_yapi, hubref) {
    this._hubref = 0;
    this._ctx = obj_yapi;
    this._hubref = hubref;
  }
  async _getStrAttr_internal(attrName) {
    let hub = this._ctx.getGenHub(this._hubref);
    if (hub == null) {
      return "";
    }
    switch (attrName) {
      case "registeredUrl":
        return hub.imm_getOriginalURL();
      case "connectionUrl":
        return hub.imm_getRootUrl();
      case "serialNumber":
        return hub.imm_getSerialNumber();
      case "errorMessage":
        return hub.get_errorMessage();
      default:
        return "";
    }
  }
  async _getIntAttr_internal(attrName) {
    let hub = this._ctx.getGenHub(this._hubref);
    if (attrName == "isInUse") {
      return hub != null ? 1 : 0;
    }
    if (hub == null) {
      return -1;
    }
    switch (attrName) {
      case "isOnline":
        return hub.imm_isOnline() ? 1 : 0;
      case "isReadOnly":
        return await hub.hasRwAccess() ? 0 : 1;
      case "networkTimeout":
        return hub.imm_getNetworkTimeout();
      case "errorType":
        return hub.get_errorType();
      default:
        return -1;
    }
  }
  async _setIntAttr_internal(attrName, value) {
    let hub = this._ctx.getGenHub(this._hubref);
    if (hub != null && attrName == "networkTimeout") {
      hub.imm_setNetworkTimeout(value);
    }
  }
  get_knownUrls_internal() {
    let hub = this._ctx.getGenHub(this._hubref);
    if (hub != null) {
      return hub.get_knownUrls();
    }
    return [];
  }
  async _getStrAttr(attrName) {
    return await this._getStrAttr_internal(attrName);
  }
  async _getIntAttr(attrName) {
    return await this._getIntAttr_internal(attrName);
  }
  async _setIntAttr(attrName, value) {
    return await this._setIntAttr_internal(attrName, value);
  }
  async get_registeredUrl() {
    return await this._getStrAttr("registeredUrl");
  }
  async get_knownUrls() {
    return await this.get_knownUrls_internal();
  }
  async get_connectionUrl() {
    return await this._getStrAttr("connectionUrl");
  }
  async get_serialNumber() {
    return await this._getStrAttr("serialNumber");
  }
  async isInUse() {
    return await this._getIntAttr("isInUse") > 0;
  }
  async isOnline() {
    return await this._getIntAttr("isOnline") > 0;
  }
  async isReadOnly() {
    return await this._getIntAttr("isReadOnly") > 0;
  }
  async set_networkTimeout(networkMsTimeout) {
    await this._setIntAttr("networkTimeout", networkMsTimeout);
  }
  async get_networkTimeout() {
    return await this._getIntAttr("networkTimeout");
  }
  async get_errorType() {
    return await this._getIntAttr("errorType");
  }
  async get_errorMessage() {
    return await this._getStrAttr("errorMessage");
  }
  async get_userData() {
    return this._userData;
  }
  async set_userData(data) {
    this._userData = data;
  }
  static FirstHubInUse() {
    return YAPI.nextHubInUseInternal(-1);
  }
  static FirstHubInUseInContext(yctx) {
    return yctx.nextHubInUseInternal(-1);
  }
  nextHubInUse() {
    return this._ctx.nextHubInUseInternal(this._hubref);
  }
};
var YAPIContext = class {
  constructor(system_env) {
    this._detectType = Y_DETECT_NONE;
    this._knownHubsBySerial = {};
    this._knownHubsByUrl = {};
    this._connectedHubs = [];
    this._trustedCertificate = [];
    this._networkSecurityOptions = 0;
    this._yhub_cache = {};
    this._ssdpManager = null;
    this._devs = {};
    this._snByUrl = {};
    this._snByName = {};
    this._fnByType = {};
    this._lastErrorType = YAPI_SUCCESS;
    this._lastErrorMsg = "no error";
    this._updateDevListStarted = 0;
    this._pendingCallbacks = [];
    this._logLevel = 4;
    this._logCallback = null;
    this._arrivalCallback = null;
    this._namechgCallback = null;
    this._removalCallback = null;
    this._hubDiscoveryCallback = null;
    this._forwardValues = 0;
    this._calibHandlers = [];
    this._ValueCallbackList = [];
    this._TimedReportCallbackList = [];
    this._beacons = {};
    this._isNodeJS = false;
    this._networkTimeoutMs = DEFAULT_NETWORK_TIMEOUT_MS;
    this._deviceListValidityMs = DEFAULT_DEVICE_LIST_VALIDITY_MS;
    this.defaultEncoding = "binary";
    this.exceptionsDisabled = false;
    this.SUCCESS = 0;
    this.NOT_INITIALIZED = -1;
    this.INVALID_ARGUMENT = -2;
    this.NOT_SUPPORTED = -3;
    this.DEVICE_NOT_FOUND = -4;
    this.VERSION_MISMATCH = -5;
    this.DEVICE_BUSY = -6;
    this.TIMEOUT = -7;
    this.IO_ERROR = -8;
    this.NO_MORE_DATA = -9;
    this.EXHAUSTED = -10;
    this.DOUBLE_ACCES = -11;
    this.UNAUTHORIZED = -12;
    this.RTC_NOT_READY = -13;
    this.FILE_NOT_FOUND = -14;
    this.SSL_ERROR = -15;
    this.RFID_SOFT_ERROR = -16;
    this.RFID_HARD_ERROR = -17;
    this.BUFFER_TOO_SMALL = -18;
    this.DNS_ERROR = -19;
    this.SSL_UNK_CERT = -20;
    this.NO_TRUSTED_CA_CHECK = 1;
    this.NO_EXPIRATION_CHECK = 2;
    this.NO_HOSTNAME_CHECK = 4;
    this.LEGACY = 8;
    this.defaultCacheValidity = 5;
    this.INVALID_INT = YAPI_INVALID_INT;
    this.INVALID_UINT = YAPI_INVALID_UINT;
    this.INVALID_LONG = YAPI_INVALID_LONG;
    this.INVALID_DOUBLE = YAPI_INVALID_DOUBLE;
    this.MIN_DOUBLE = YAPI_MIN_DOUBLE;
    this.MAX_DOUBLE = YAPI_MAX_DOUBLE;
    this.INVALID_STRING = YAPI_INVALID_STRING;
    this.HASH_BUF_SIZE = YOCTO_HASH_BUF_SIZE;
    this.DETECT_NONE = Y_DETECT_NONE;
    this.DETECT_USB = Y_DETECT_USB;
    this.DETECT_NET = Y_DETECT_NET;
    this.DETECT_ALL = Y_DETECT_ALL;
    this.YOCTO_DEFAULT_HTTP_PORT = 4444;
    this.YOCTO_DEFAULT_HTTPS_PORT = 4443;
    this.system_env = system_env || YAPI && YAPI.system_env || _UnspecifiedSystemEnv;
    this._isNodeJS = this.system_env.isNodeJS;
    this._uniqueID = String.fromCharCode(Math.random() * 79 + 48, Math.random() * 79 + 48, Math.random() * 79 + 48);
    this.imm_ResetToDefaults();
  }
  imm_ResetToDefaults() {
    this._detectType = this.DETECT_NONE;
    this._knownHubsBySerial = {};
    this._knownHubsByUrl = {};
    this._connectedHubs = [];
    this._trustedCertificate = [];
    this._networkSecurityOptions = 0;
    this._devs = {};
    this._snByUrl = {};
    this._snByName = {};
    this._fnByType = {};
    this._fnByType.Module = new YFunctionType(this, "Module");
    this._lastErrorType = YAPI_SUCCESS;
    this._lastErrorMsg = "no error";
    this._updateDevListStarted = 0;
    this._pendingCallbacks = [];
    this._logLevel = 2;
    this._logCallback = null;
    this._arrivalCallback = null;
    this._namechgCallback = null;
    this._removalCallback = null;
    this._hubDiscoveryCallback = null;
    this._forwardValues = 0;
    this._ValueCallbackList = [];
    this._TimedReportCallbackList = [];
    this._beacons = {};
    this._calibHandlers = [];
    for (let i = 1; i <= 20; i++) {
      this.RegisterCalibrationHandler(i, this.LinearCalibrationHandler);
    }
    this.RegisterCalibrationHandler(YOCTO_CALIB_TYPE_OFS, this.LinearCalibrationHandler);
    this.exceptionsDisabled = false;
  }
  _throw(int_errType, str_errMsg, obj_retVal) {
    this._lastErrorType = int_errType;
    this._lastErrorMsg = str_errMsg;
    if (!this.exceptionsDisabled) {
      let exc = new YoctoError(str_errMsg);
      exc.errorType = int_errType;
      throw exc;
    }
    return obj_retVal;
  }
  imm_setErr(errmsg, int_errType, str_errMsg, obj_retVal) {
    if (errmsg) {
      errmsg.msg = str_errMsg;
    }
    this._lastErrorType = int_errType;
    this._lastErrorMsg = str_errMsg;
    return obj_retVal;
  }
  imm_setSystemEnv(env) {
    this.system_env = env;
    this._isNodeJS = env.isNodeJS;
  }
  imm_log(msg, ...moreArgs) {
    let now = new Date();
    let day = now.getFullYear().toString() + "-" + ("0" + (now.getMonth() + 1)).slice(-2) + "-" + ("0" + now.getDate()).slice(-2);
    let time = ("0" + now.getHours().toString()).slice(-2) + ":" + ("0" + now.getMinutes()).slice(-2) + ":" + ("0" + now.getSeconds()).slice(-2);
    let prefix = day + " " + time + " [" + this._uniqueID + "] ";
    let isError = false;
    if (moreArgs.length > 0) {
      if (moreArgs[0].constructor && /Error/i.test(moreArgs[0].constructor.name)) {
        isError = true;
      }
    }
    if (this._logCallback) {
      try {
        if (moreArgs.length > 0) {
          if (moreArgs[0].message) {
            msg += moreArgs[0].message;
          } else {
            msg += moreArgs[0].toString();
          }
        }
        this._logCallback(prefix + msg);
      } catch (e) {
        console.error(prefix + "Exception in custom log callback: ", e);
        console.log("... while trying to log:");
        if (isError) {
          console.error(prefix + msg, ...moreArgs);
        } else {
          console.log(prefix + msg, ...moreArgs);
        }
      }
    } else {
      if (isError) {
        console.error(prefix + msg, ...moreArgs);
      } else {
        console.log(prefix + msg, ...moreArgs);
      }
    }
  }
  async RegisterLogFunction(logfun) {
    this._logCallback = logfun;
    return YAPI_SUCCESS;
  }
  imm_getHub(obj_urlInfo) {
    let hub = this._knownHubsByUrl[obj_urlInfo.imm_getRootUrl()];
    if (!hub) {
      for (const url in this._knownHubsByUrl) {
        if (this._knownHubsByUrl[url].imm_getOriginalURL() == obj_urlInfo.imm_getOriginalURL()) {
          return this._knownHubsByUrl[url];
        }
      }
    }
    return hub;
  }
  imm_getPrimaryHub(hub) {
    let primaryHub = this._knownHubsBySerial[hub.imm_getSerialNumber()];
    if (!primaryHub || primaryHub === hub) {
      this._knownHubsBySerial[hub.imm_getSerialNumber()] = hub;
      this._knownHubsByUrl[hub.imm_getRootUrl()] = hub;
      return hub;
    }
    if (!hub.urlInfo.imm_useSecureSocket() || hub.urlInfo.imm_useSecureSocket() && primaryHub.urlInfo.imm_useSecureSocket()) {
      if (primaryHub.imm_getcurrentState() >= hub.imm_getcurrentState()) {
        primaryHub.imm_inheritFrom(hub);
        return primaryHub;
      }
    }
    this._knownHubsBySerial[hub.imm_getSerialNumber()] = hub;
    hub.imm_inheritFrom(primaryHub);
    return hub;
  }
  async _addConnectedHub(newhub) {
    let serial = this._snByUrl[newhub.imm_getRootUrl()];
    if (!serial) {
      let newdev = new YDevice(this, newhub.imm_getRootUrl(), null, null);
      await newdev.refresh();
    }
    let hubFound = false;
    for (let i = 0; i < this._connectedHubs.length; i++) {
      let url = this._connectedHubs[i].imm_getRootUrl();
      if (newhub.imm_getRootUrl() == url) {
        hubFound = true;
        break;
      }
    }
    if (!hubFound) {
      this._connectedHubs.push(newhub);
    }
  }
  imm_isActiveHub(hubSerial) {
    for (let i = 0; i < this._connectedHubs.length; i++) {
      let hubSerials = this._connectedHubs[i].serialByYdx;
      if (hubSerials && hubSerials[0] == hubSerial) {
        return true;
      }
    }
    return false;
  }
  imm_dropConnectedHub(hub) {
    let idx = this._connectedHubs.indexOf(hub);
    if (idx < 0) {
      return;
    }
    for (let j = 0; j < hub.serialByYdx.length; j++) {
      let serial = hub.serialByYdx[j];
      if (serial && this._devs[serial]) {
        if (this._removalCallback) {
          let module = YModule.FindModuleInContext(this, serial + ".module");
          this._pendingCallbacks.push({event: "-", serial, module});
        }
        try {
          this.imm_forgetDevice(this._devs[serial]);
        } catch (e) {
        }
      }
    }
    idx = this._connectedHubs.indexOf(hub);
    if (idx >= 0) {
      this._connectedHubs.splice(idx, 1);
    }
  }
  async _ensureUpdateDeviceListNotRunning() {
    while (this._updateDevListStarted && this.GetTickCount() - this._updateDevListStarted < 30 * 1e3) {
      await this.Sleep(25);
    }
  }
  async _updateDeviceList_internal(bool_forceupdate, bool_invokecallbacks) {
    if (this._updateDevListStarted && this.GetTickCount() - this._updateDevListStarted < 30 * 1e3) {
      return {
        errorType: YAPI_SUCCESS,
        errorMsg: "no error"
      };
    }
    for (let i = 0; i < this._connectedHubs.length; i++) {
      if (this._connectedHubs[i].imm_isFirstArrivalCallback() && bool_invokecallbacks && this._arrivalCallback) {
        bool_forceupdate = true;
        break;
      }
    }
    if (bool_forceupdate) {
      for (let i = 0; i < this._connectedHubs.length; i++) {
        this._connectedHubs[i].imm_forceUpdate();
      }
    }
    try {
      this._updateDevListStarted = this.GetTickCount();
      let hubs = [];
      for (let i = 0; i < this._connectedHubs.length; i++) {
        let hub = this._connectedHubs[i];
        let rootUrl = hub.imm_getRootUrl();
        let hubDev = this.imm_getDevice(rootUrl);
        if (!hubDev) {
          continue;
        }
        if (hub.imm_getcurrentState() < 1) {
          if (this._logLevel >= 4) {
            this.imm_log("Skip updateDeviceList for hub " + hub.urlInfo.imm_getHost() + ", currently offline");
          }
          continue;
        }
        if (hub.devListExpires <= this.GetTickCount()) {
          hub._missing = {};
          hubs.push(hub);
        }
      }
      for (let serial in this._devs) {
        let rooturl = this._devs[serial].imm_getRootUrl();
        for (let i = 0; i < hubs.length; i++) {
          let huburl = hubs[i].imm_getRootUrl();
          if (rooturl.substr(0, huburl.length) == huburl) {
            hubs[i]._missing[serial] = true;
          }
        }
      }
      let update_promises = [];
      for (let i = 0; i < hubs.length; i++) {
        let prom = hubs[i].hubUpdateDeviceList();
        update_promises.push(prom);
      }
      let newDeviceCounts = await Promise.all(update_promises);
      let newDeviceArrived = false;
      for (let res of newDeviceCounts) {
        newDeviceArrived = newDeviceArrived || res > 0;
      }
      if (bool_invokecallbacks) {
        let nbEvents = this._pendingCallbacks.length;
        for (let i = 0; i < nbEvents; i++) {
          let evt = this._pendingCallbacks[i];
          switch (evt.event) {
            case "+":
              if (this._logLevel >= 3) {
                this.imm_log("Device " + evt.serial + " plugged");
              }
              if (this._arrivalCallback) {
                try {
                  await evt.module.load(this.defaultCacheValidity);
                  await this._arrivalCallback(evt.module);
                } catch (e) {
                  this.imm_log("Exception in device arrival callback:", e);
                }
              }
              break;
            case "/":
              if (this._namechgCallback) {
                try {
                  await this._namechgCallback(evt.module);
                } catch (e) {
                  this.imm_log("Exception in device change callback:", e);
                }
              }
              break;
            case "-":
              if (this._logLevel >= 3) {
                this.imm_log("Device " + evt.serial + " unplugged");
              }
              if (this._removalCallback) {
                try {
                  await this._removalCallback(evt.module);
                } catch (e) {
                  this.imm_log("Exception in device removal callback:", e);
                }
              }
              break;
          }
        }
        this._pendingCallbacks = this._pendingCallbacks.slice(nbEvents);
      }
      if (newDeviceArrived) {
        for (let fun of this._ValueCallbackList) {
          if (!fun._hwId) {
            fun.isOnline();
          }
        }
        for (let fun of this._TimedReportCallbackList) {
          if (!fun._hwId) {
            fun.isOnline();
          }
        }
      }
    } finally {
      this._updateDevListStarted = 0;
    }
    return {
      errorType: YAPI_SUCCESS,
      errorMsg: "no error"
    };
  }
  async updateDeviceList_process(hub, hubDev, whitePages, yellowPages) {
    let newDevices = 0;
    let refresh = {};
    let serial = null;
    for (let classname in yellowPages) {
      let obj_yprecs = yellowPages[classname];
      let ftype = this._fnByType[classname];
      if (ftype == void 0) {
        ftype = new YFunctionType(this, classname);
        this._fnByType[classname] = ftype;
      }
      for (let i = 0; i < obj_yprecs.length; i++) {
        let yprec = obj_yprecs[i];
        let hwid = yprec.hardwareId;
        let basetype = yprec.baseType;
        if (ftype.imm_reindexFunction(hwid, yprec["logicalName"], yprec["advertisedValue"], basetype)) {
          serial = hwid.substr(0, hwid.indexOf("."));
          refresh[serial] = true;
        }
      }
    }
    for (let i = 0; i < whitePages.length; i++) {
      let devinfo = whitePages[i];
      serial = devinfo.serialNumber;
      let devydx = devinfo.index;
      let rooturl = devinfo.networkUrl.slice(0, -3);
      if (rooturl.charAt(0) == "/")
        rooturl = hubDev.imm_getRootUrl() + rooturl.substr(1);
      let currdev = this._devs[serial];
      if (this._logLevel >= 5) {
        this.imm_log("Device " + serial + " present, currdev " + (currdev ? "" : "NOT ") + "set" + (hub.imm_isFirstArrivalCallback() ? ", firstArrival" : ""));
      }
      if (currdev && hub.imm_isFirstArrivalCallback()) {
        newDevices++;
        if (this._arrivalCallback) {
          let module = YModule.FindModuleInContext(this, serial + ".module");
          this._pendingCallbacks.push({event: "+", serial, module});
        }
      }
      hub.serialByYdx[devydx] = serial;
      if (!currdev) {
        new YDevice(this, rooturl, devinfo, yellowPages);
        newDevices++;
        if (this._arrivalCallback) {
          let module = YModule.FindModuleInContext(this, serial + ".module");
          this._pendingCallbacks.push({event: "+", serial, module});
        }
      } else if (currdev.imm_getLogicalName() != devinfo["logicalName"]) {
        await currdev.refresh();
        if (this._namechgCallback) {
          let module = YModule.FindModuleInContext(this, serial + ".module");
          this._pendingCallbacks.push({event: "/", serial, module});
        }
      } else if (refresh[serial] || currdev.imm_getRootUrl() != rooturl || currdev.imm_getBeacon() != devinfo["beacon"]) {
        await currdev.refresh();
      }
      hub._missing[serial] = false;
    }
    if (this._arrivalCallback && hub.imm_isFirstArrivalCallback()) {
      hub.imm_setFirstArrivalCallback(false);
    }
    for (serial in hub._missing) {
      if (hub._missing[serial] && this._devs[serial]) {
        if (this._removalCallback) {
          let module = YModule.FindModuleInContext(this, serial + ".module");
          this._pendingCallbacks.push({event: "-", serial, module});
        }
        this.imm_forgetDevice(this._devs[serial]);
      }
    }
    return newDevices;
  }
  async parseEvents(hub, str_lines) {
    if (hub.imm_isDisconnecting()) {
      return;
    }
    hub.isNotifWorking = true;
    if (hub.timeoutId) {
      clearTimeout(hub.timeoutId);
    }
    hub.timeoutId = setTimeout(() => {
      if (!hub.imm_isForwarded()) {
        this.imm_log("Closing stalled connection after " + hub.imm_getNetworkTimeout() / 1e3 + "s");
        hub.imm_disconnectNow();
      }
    }, hub.imm_getNetworkTimeout());
    let rows = (hub.notifCarryOver + str_lines).split("\n");
    let nrows = rows.length;
    let value;
    if (str_lines.substr(-1) != "\n") {
      hub.notifCarryOver = rows[--nrows];
    } else {
      nrows--;
      hub.notifCarryOver = "";
    }
    for (let idx = 0; idx < nrows; idx++) {
      let ev = rows[idx];
      if (ev.length == 0)
        continue;
      let firstCode = ev.charAt(0);
      if (ev.length >= 3 && firstCode >= NOTIFY_NETPKT_CONFCHGYDX && firstCode <= NOTIFY_NETPKT_TIMEAVGYDX) {
        hub.retryDelay = 15;
        if (hub.notifPos >= 0)
          hub.notifPos += ev.length + 1;
        let devydx = ev.charCodeAt(1) - 65;
        let funydx = ev.charCodeAt(2) - 48;
        if (funydx >= 64) {
          funydx -= 64;
          devydx += 128;
        }
        let serial = hub.serialByYdx[devydx];
        if (serial && this._devs[serial]) {
          let funcid = funydx == 15 ? "time" : this._devs[serial].imm_functionIdByFunYdx(funydx);
          if (funcid != "") {
            let dev;
            value = ev.slice(3);
            switch (firstCode) {
              case NOTIFY_NETPKT_FUNCVALYDX:
                if (value != "")
                  value = value.split("\0")[0];
                await this.setFunctionValue(serial + "." + funcid, value);
                break;
              case NOTIFY_NETPKT_DEVLOGYDX:
                dev = this._devs[serial];
                if (dev != null) {
                  dev.imm_triggerLogPull();
                }
                break;
              case NOTIFY_NETPKT_CONFCHGYDX:
                await this.setConfChange(serial);
                break;
              case NOTIFY_NETPKT_TIMEVALYDX:
              case NOTIFY_NETPKT_TIMEAVGYDX:
              case NOTIFY_NETPKT_TIMEV2YDX:
                let pos, arr = [firstCode == "x" ? 0 : firstCode == "z" ? 1 : 2];
                for (pos = 0; pos < value.length; pos += 2) {
                  arr.push(parseInt(value.substr(pos, 2), 16));
                }
                dev = this._devs[serial];
                if (funcid == "time") {
                  let time = arr[1] + 256 * arr[2] + 65536 * arr[3] + 16777216 * arr[4];
                  let ms = arr[5] * 4;
                  let duration;
                  if (arr.length >= 7) {
                    ms += arr[6] >> 6;
                    let duration_ms = arr[7];
                    duration_ms += (arr[6] & 15) * 256;
                    if (arr[6] & 16) {
                      duration = duration_ms;
                    } else {
                      duration = duration_ms / 1e3;
                    }
                  } else {
                    duration = 0;
                  }
                  dev.imm_setTimeRef(time + ms / 1e3, duration);
                } else {
                  await this.setTimedReport(serial + "." + funcid, dev.imm_getLastTimeRef(), dev.imm_getLastDuration(), arr);
                }
                break;
              case NOTIFY_NETPKT_FUNCV2YDX:
                let rawval = this.imm_decodeNetFuncValV2(value);
                if (rawval != null) {
                  let decodedval = this.imm_decodePubVal(rawval[0], rawval, 1, 6);
                  await this.setFunctionValue(serial + "." + funcid, decodedval);
                }
                break;
              case NOTIFY_NETPKT_FLUSHV2YDX:
              default:
                break;
            }
          }
        }
      } else if (ev.length > 5 && ev.substr(0, 4) == "YN01") {
        hub.retryDelay = 15;
        if (hub.notifPos >= 0)
          hub.notifPos += ev.length + 1;
        let notype = ev.substr(4, 1);
        let parts;
        if (notype == "@") {
          hub.notifPos = parseInt(ev.slice(5));
        } else {
          switch (parseInt(notype)) {
            case 0:
              parts = ev.slice(5).split(",");
              if (parts.length > 2) {
                let int_beacon = parseInt(parts[2]);
                await this.setBeaconChange(parts[0], int_beacon);
              }
            case 2:
            case 4:
            case 8:
              hub.devListExpires = 0;
              break;
            case 5:
              parts = ev.slice(5).split(",");
              if (parts.length > 2) {
                value = parts[2].split("\0");
                await this.setFunctionValue(parts[0] + "." + parts[1], value[0]);
              }
              break;
          }
        }
      } else {
        hub.devListExpires = 0;
        this.imm_log("Bad event on received from server:", ev);
        hub.notifPos = -1;
      }
    }
    if (this._forwardValues > 0) {
      await this.HandleEvents(new YErrorMsg());
    }
  }
  imm_decodeNetFuncValV2(p) {
    let p_ofs = 0;
    let ch = p.charCodeAt(p_ofs) & 255;
    let len = 0;
    let funcVal = [0, 0, 0, 0, 0, 0, 0];
    if (ch < 32 || ch > 32 + 127) {
      return null;
    }
    ch -= 32;
    funcVal[0] = (ch & 64) != 0 ? NOTIFY_V2_6RAWBYTES : NOTIFY_V2_TYPEDDATA;
    ch &= 63;
    while (len < YOCTO_PUBVAL_SIZE) {
      p_ofs++;
      if (p_ofs >= p.length) {
        break;
      }
      let newCh = p.charCodeAt(p_ofs) & 255;
      if (newCh == NOTIFY_NETPKT_STOP) {
        break;
      }
      if (newCh < 32 || newCh > 32 + 127) {
        return null;
      }
      newCh -= 32;
      ch = (ch << 7) + newCh;
      funcVal[len + 1] = ch >>> 5 - len & 255;
      len++;
    }
    return funcVal;
  }
  imm_decodePubVal(int_typeV2, arr_funcval, int_ofs, int_funcvalen) {
    let buffer = "";
    let endp;
    if (int_typeV2 == NOTIFY_V2_6RAWBYTES || int_typeV2 == NOTIFY_V2_TYPEDDATA) {
      let funcValType;
      if (int_typeV2 == NOTIFY_V2_6RAWBYTES) {
        funcValType = PUBVAL_6RAWBYTES;
      } else {
        funcValType = arr_funcval[int_ofs++];
      }
      switch (funcValType) {
        case PUBVAL_LEGACY:
          break;
        case PUBVAL_1RAWBYTE:
        case PUBVAL_2RAWBYTES:
        case PUBVAL_3RAWBYTES:
        case PUBVAL_4RAWBYTES:
        case PUBVAL_5RAWBYTES:
        case PUBVAL_6RAWBYTES:
          for (let i = 0; i < funcValType; i++) {
            let c = arr_funcval[int_ofs++];
            let b = c >>> 4;
            buffer += b.toString(16);
            b = c & 15;
            buffer += b.toString(16);
          }
          return buffer;
        case PUBVAL_C_LONG:
        case PUBVAL_YOCTO_FLOAT_E3:
          let numVal = arr_funcval[int_ofs++];
          numVal += arr_funcval[int_ofs++] << 8;
          numVal += arr_funcval[int_ofs++] << 16;
          numVal += arr_funcval[int_ofs++] << 24;
          if (funcValType == PUBVAL_C_LONG) {
            return String(Math.round(numVal));
          } else {
            buffer = String(Math.round(numVal * 1e3) / 1e6);
            endp = buffer.length;
            while (endp > 0 && buffer[endp - 1] == "0") {
              --endp;
            }
            if (endp > 0 && buffer[endp - 1] == ".") {
              --endp;
              buffer = buffer.substr(0, endp);
            }
            return buffer;
          }
        case PUBVAL_C_FLOAT:
          let v = arr_funcval[int_ofs++];
          v += arr_funcval[int_ofs++] << 8;
          v += arr_funcval[int_ofs++] << 16;
          v += arr_funcval[int_ofs++] << 24;
          let fraction = (v & (1 << 23) - 1) + (1 << 23) * (v >>> 31 | 1);
          let exp = (v >>> 23 & 255) - 127;
          let floatVal = fraction * Math.pow(2, exp - 23);
          buffer = String(Math.round(floatVal * 1e6) / 1e6);
          endp = buffer.length;
          while (endp > 0 && buffer[endp - 1] == "0") {
            --endp;
          }
          if (endp > 0 && buffer[endp - 1] == ".") {
            --endp;
            buffer = buffer.substr(0, endp);
          }
          return buffer;
        default:
          return "?";
      }
      let len = 0;
      buffer = "";
      while (len < YOCTO_PUBVAL_SIZE && len < int_funcvalen) {
        if (arr_funcval[len] == 0) {
          break;
        }
        buffer += String.fromCharCode(arr_funcval[len]);
        len++;
      }
    }
    return buffer;
  }
  imm_decExp(int_pow) {
    const arr = [
      1e-6,
      1e-5,
      1e-4,
      1e-3,
      0.01,
      0.1,
      1,
      10,
      100,
      1e3,
      1e4,
      1e5,
      1e6,
      1e7,
      1e8,
      1e9
    ];
    return arr[int_pow];
  }
  imm_decimalToDouble(val) {
    let negate = false;
    let res;
    let mantis = val & 2047;
    if (mantis == 0)
      return 0;
    if (val > 32767) {
      negate = true;
      val = 65536 - val;
    } else if (val < 0) {
      negate = true;
      val = -val;
    }
    let decexp = this.imm_decExp(val >>> 11);
    if (decexp >= 1) {
      res = mantis * decexp;
    } else {
      res = mantis / Math.round(1 / decexp);
    }
    return negate ? -res : res;
  }
  imm_doubleToDecimal(val) {
    let negate = false;
    let comp, mant;
    let decpow;
    let res;
    if (val == 0) {
      return 0;
    }
    if (val < 0) {
      negate = true;
      val = -val;
    }
    comp = val / 1999;
    decpow = 0;
    while (comp > this.imm_decExp(decpow) && decpow < 15) {
      decpow++;
    }
    mant = val / this.imm_decExp(decpow);
    if (decpow == 15 && mant > 2047) {
      res = (15 << 11) + 2047;
    } else {
      res = (decpow << 11) + Math.round(mant);
    }
    return negate ? -res : res;
  }
  imm_getCalibrationHandler(calibType) {
    return this._calibHandlers[calibType];
  }
  imm_decodeWords(data) {
    let udata = [];
    for (let i = 0; i < data.length; ) {
      let c = data[i];
      let val = 0;
      if (c == "*") {
        i++;
      } else if (c == "X") {
        val = 65535;
        i++;
      } else if (c == "Y") {
        val = 32767;
        i++;
      } else if (c >= "a") {
        let srcpos = udata.length - 1 - (data.charCodeAt(i++) - 97);
        if (srcpos >= 0) {
          val = udata[srcpos];
        }
      } else {
        if (i + 3 > data.length) {
          return udata;
        }
        val = data.charCodeAt(i++) - 48;
        val += data.charCodeAt(i++) - 48 << 5;
        let lastcode = data.charCodeAt(i++);
        if (lastcode == 122)
          lastcode = 92;
        val += lastcode - 48 << 10;
      }
      udata.push(val);
    }
    return udata;
  }
  imm_decodeFloats(data) {
    let idata = [];
    let p = 0;
    let datalen = data.length;
    while (p < datalen) {
      let val = 0;
      let sign = 1;
      let dec = 0;
      let decInc = 0;
      let c = data[p++];
      while (c != "-" && (c < "0" || c > "9")) {
        if (p >= datalen) {
          return idata;
        }
        c = data[p++];
      }
      if (c == "-") {
        if (p >= datalen) {
          return idata;
        }
        sign = -sign;
        c = data[p++];
      }
      while (c >= "0" && c <= "9" || c == ".") {
        if (c == ".") {
          decInc = 1;
        } else if (dec < 3) {
          val = val * 10 + (c.charCodeAt(0) - 48);
          dec += decInc;
        }
        if (p < datalen) {
          c = data[p++];
        } else {
          c = "\0";
        }
      }
      if (dec < 3) {
        if (dec == 0) {
          val *= 1e3;
        } else if (dec == 1) {
          val *= 100;
        } else {
          val *= 10;
        }
      }
      idata.push(sign * val);
    }
    return idata;
  }
  static imm_atoi(str_data) {
    let num = parseInt(str_data);
    if (isNaN(num)) {
      return 0;
    }
    return Math.floor(num);
  }
  static imm_atof(str_data) {
    let num = parseFloat(str_data);
    if (isNaN(num)) {
      return 0;
    }
    return num;
  }
  imm_bin2str(bin_data) {
    let len = bin_data.length;
    let res = "";
    for (let i = 0; i < len; i += 20) {
      let subdata = bin_data.subarray(i, Math.min(i + 20, len));
      res += String.fromCharCode.apply(null, Array.from(subdata));
    }
    return res;
  }
  imm_str2bin(str_data) {
    let len = str_data.length;
    let res = new Uint8Array(len);
    for (let i = 0; i < len; i++) {
      res[i] = str_data.charCodeAt(i);
    }
    return res;
  }
  imm_bin2hexstr(bin_data) {
    let len = bin_data.length;
    let res = "";
    for (let i = 0; i < len; i++) {
      let n = bin_data[i].toString(16);
      res += n.length < 2 ? "0" + n : n;
    }
    return res.toUpperCase();
  }
  imm_hexstr2bin(str_data) {
    let len = str_data.length >>> 1;
    let res = new Uint8Array(len);
    for (let i = 0; i < len; i++) {
      res[i] = parseInt(str_data.substr(2 * i, 2), 16);
    }
    return res;
  }
  imm_getDevice(str_device) {
    let dev = null;
    let serial;
    if (str_device.substr(0, 7) == "http://" || str_device.substr(0, 5) == "ws://" || str_device.substr(0, 8) == "https://" || str_device.substr(0, 6) == "wss://") {
      serial = this._snByUrl[str_device];
      if (serial != void 0)
        dev = this._devs[serial];
    } else {
      if (this._devs[str_device]) {
        dev = this._devs[str_device];
      } else {
        serial = this._snByName[str_device];
        if (serial) {
          dev = this._devs[serial];
        }
      }
    }
    return dev;
  }
  async _UpdateValueCallbackList(obj_func, bool_add) {
    let index = this._ValueCallbackList.indexOf(obj_func);
    if (bool_add) {
      await obj_func.isOnline();
      if (index < 0) {
        this._ValueCallbackList.push(obj_func);
      }
    } else if (index >= 0) {
      this._ValueCallbackList.splice(index, 1);
    }
  }
  async _UpdateTimedReportCallbackList(obj_func, bool_add) {
    let index = this._TimedReportCallbackList.indexOf(obj_func);
    if (bool_add) {
      await obj_func.isOnline();
      if (index < 0) {
        this._TimedReportCallbackList.push(obj_func);
      }
    } else if (index >= 0) {
      this._TimedReportCallbackList.splice(index, 1);
    }
  }
  imm_functionClass(str_funcid) {
    let dotpos = str_funcid.indexOf(".");
    if (dotpos >= 0)
      str_funcid = str_funcid.substr(dotpos + 1);
    let classlen = str_funcid.length;
    while (str_funcid.substr(classlen - 1, 1) <= "9") {
      classlen--;
    }
    let classname = str_funcid.substr(0, 1).toUpperCase() + str_funcid.substr(1, classlen - 1);
    if (this._fnByType[classname] == void 0) {
      this._fnByType[classname] = new YFunctionType(this, classname);
    }
    return classname;
  }
  imm_reindexDevice(obj_dev) {
    let rootUrl = obj_dev.imm_getRootUrl();
    let serial = obj_dev.imm_getSerialNumber();
    let lname = obj_dev.imm_getLogicalName();
    this._devs[serial] = obj_dev;
    this._snByUrl[rootUrl] = serial;
    if (lname != "")
      this._snByName[lname] = serial;
    this._fnByType["Module"].imm_reindexFunction(serial + ".module", lname, null, null);
    let i, count = obj_dev.imm_functionCount();
    for (i = 0; i < count; i++) {
      let funcid = obj_dev.imm_functionId(i);
      if (funcid != "") {
        let funcname = obj_dev.imm_functionName(i);
        let classname = this.imm_functionClass(funcid);
        this._fnByType[classname].imm_reindexFunction(serial + "." + funcid, funcname, null, null);
      }
    }
  }
  imm_forgetDevice(obj_dev) {
    let rootUrl = obj_dev.imm_getRootUrl();
    let serial = obj_dev.imm_getSerialNumber();
    let lname = obj_dev.imm_getLogicalName();
    delete this._devs[serial];
    delete this._snByUrl[rootUrl];
    if (this._snByName[lname] == serial) {
      delete this._snByName[lname];
    }
    this._fnByType["Module"].imm_forgetFunction(serial + ".module");
    let i, count = obj_dev.imm_functionCount();
    for (i = 0; i < count; i++) {
      let funcid = obj_dev.imm_functionId(i);
      if (funcid != "") {
        let classname = this.imm_functionClass(funcid);
        this._fnByType[classname].imm_forgetFunction(serial + "." + funcid);
      }
    }
  }
  imm_resolveFunction(str_className, str_func) {
    if (Y_BASETYPES[str_className] == void 0) {
      if (this._fnByType[str_className] == void 0) {
        this._fnByType[str_className] = new YFunctionType(this, str_className);
      }
      return this._fnByType[str_className].imm_resolve(str_func);
    }
    let baseType = Y_BASETYPES[str_className];
    let res;
    for (str_className in this._fnByType) {
      if (this._fnByType[str_className].imm_matchBaseType(baseType)) {
        res = this._fnByType[str_className].imm_resolve(str_func);
        if (res.errorType == YAPI_SUCCESS)
          return res;
      }
    }
    return {
      errorType: YAPI_DEVICE_NOT_FOUND,
      errorMsg: "No " + str_className + " [" + str_func + "] found (old firmware?)"
    };
  }
  imm_getFriendlyNameFunction(str_className, str_func) {
    if (Y_BASETYPES[str_className] == void 0) {
      if (this._fnByType[str_className] == void 0) {
        this._fnByType[str_className] = new YFunctionType(this, str_className);
      }
      return this._fnByType[str_className].imm_getFriendlyName(str_func);
    }
    let baseType = Y_BASETYPES[str_className];
    let res;
    for (str_className in this._fnByType) {
      if (this._fnByType[str_className].imm_matchBaseType(baseType)) {
        res = this._fnByType[str_className].imm_getFriendlyName(str_func);
        if (res.errorType == YAPI_SUCCESS)
          return res;
      }
    }
    return {
      errorType: YAPI_DEVICE_NOT_FOUND,
      errorMsg: "No " + str_className + " [" + str_func + "] found (old firmware?)"
    };
  }
  imm_setFunction(str_className, str_func, obj_func) {
    if (this._fnByType[str_className] == void 0) {
      this._fnByType[str_className] = new YFunctionType(this, str_className);
    }
    this._fnByType[str_className].imm_setFunction(str_func, obj_func);
  }
  imm_getFunction(str_className, str_func) {
    if (this._fnByType[str_className] == void 0) {
      this._fnByType[str_className] = new YFunctionType(this, str_className);
    }
    return this._fnByType[str_className].imm_getFunction(str_func);
  }
  async setFunctionValue(str_hwid, str_pubval) {
    let classname = this.imm_functionClass(str_hwid);
    if (this._fnByType[classname].imm_setFunctionValue(str_hwid, str_pubval)) {
      let receivers = this._ValueCallbackList;
      for (let i = 0; i < receivers.length; i++) {
        let fun = receivers[i];
        if (!fun._hwId)
          continue;
        if (fun._hwId == str_hwid) {
          await fun._invokeValueCallback(str_pubval);
        }
      }
    }
  }
  async setTimedReport(str_hwid, float_timestamp, float_duration, arr_report) {
    let classname = this.imm_functionClass(str_hwid);
    let receivers = this._TimedReportCallbackList;
    for (let i = 0; i < receivers.length; i++) {
      let fun = receivers[i];
      if (!fun._hwId)
        continue;
      if (fun._hwId == str_hwid) {
        let dev = this.imm_getDevice(fun._serial);
        if (dev) {
          let sensor = fun;
          let report = await sensor._decodeTimedReport(float_timestamp, float_duration, arr_report);
          await sensor._invokeTimedReportCallback(report);
        }
      }
    }
  }
  async setConfChange(str_serial) {
    let module = YModule.FindModuleInContext(this, str_serial + ".module");
    await module._invokeConfigChangeCallback();
  }
  async setBeaconChange(str_serial, int_beacon) {
    if (this._beacons[str_serial] === void 0 || this._beacons[str_serial] != int_beacon) {
      this._beacons[str_serial] = int_beacon;
      let dev = this.imm_getDevice(str_serial);
      if (dev) {
        dev._beacon = int_beacon;
      }
      let module = YModule.FindModuleInContext(this, str_serial + ".module");
      await module._invokeBeaconCallback(int_beacon);
    }
  }
  imm_getFunctionValue(str_hwid) {
    let classname = this.imm_functionClass(str_hwid);
    return this._fnByType[classname].imm_getFunctionValue(str_hwid);
  }
  imm_getFunctionBaseType(str_hwid) {
    let classname = this.imm_functionClass(str_hwid);
    return this._fnByType[classname].imm_getBaseType();
  }
  imm_getFirstHardwareId(str_className) {
    if (Y_BASETYPES[str_className] == void 0) {
      if (this._fnByType[str_className] == void 0) {
        this._fnByType[str_className] = new YFunctionType(this, str_className);
      }
      return this._fnByType[str_className].imm_getFirstHardwareId();
    }
    let baseType = Y_BASETYPES[str_className];
    let res;
    for (str_className in this._fnByType) {
      if (this._fnByType[str_className].imm_matchBaseType(baseType)) {
        res = this._fnByType[str_className].imm_getFirstHardwareId();
        if (res)
          return res;
      }
    }
    return null;
  }
  imm_getNextHardwareId(str_className, str_hwid) {
    if (Y_BASETYPES[str_className] == void 0) {
      return this._fnByType[str_className].imm_getNextHardwareId(str_hwid);
    }
    let baseType = Y_BASETYPES[str_className];
    let prevclass = this.imm_functionClass(str_hwid);
    let res = this._fnByType[prevclass].imm_getNextHardwareId(str_hwid);
    if (res)
      return res;
    for (str_className in this._fnByType) {
      if (prevclass != "") {
        if (str_className != prevclass)
          continue;
        prevclass = "";
        continue;
      }
      if (this._fnByType[str_className].imm_matchBaseType(baseType)) {
        res = this._fnByType[str_className].imm_getFirstHardwareId();
        if (res)
          return res;
      }
    }
    return null;
  }
  async devRequest(str_device, str_request, obj_body = null, int_tcpchan = 0) {
    let lines = str_request.split("\n");
    let res = new YHTTPRequest(null);
    let lockdev = null;
    let baseUrl;
    if (str_device.substr(0, 7) == "http://" || str_device.substr(0, 5) == "ws://" || str_device.substr(0, 8) == "https://" || str_device.substr(0, 6) == "wss://" || str_device.substr(0, 9) == "secure://" || str_device.substr(0, 7) == "auto://") {
      baseUrl = str_device;
      if (baseUrl.slice(-1) != "/")
        baseUrl = baseUrl + "/";
      if (lines[0].substr(0, 12) != "GET /not.byn") {
        let serial = this._snByUrl[baseUrl];
        if (serial) {
          lockdev = this._devs[serial];
        }
      }
    } else {
      lockdev = this.imm_getDevice(str_device);
      if (!lockdev) {
        res.errorType = YAPI_DEVICE_NOT_FOUND;
        res.errorMsg = "Device [" + str_device + "] not online";
        return res;
      }
      if (lines[0] == "GET /api.json") {
        return lockdev.requestAPI(this.defaultCacheValidity);
      }
      baseUrl = lockdev.imm_getRootUrl();
    }
    let words = lines[0].split(" ");
    if (words.length < 2) {
      res.errorType = YAPI_INVALID_ARGUMENT;
      res.errorMsg = "Invalid request, not enough words; expected a method name and a URL";
      return res;
    } else if (words.length > 2) {
      res.errorType = YAPI_INVALID_ARGUMENT;
      res.errorMsg = "Invalid request, too many words; make sure the URL is URI-encoded";
      return res;
    }
    let hub = null;
    for (let i = 0; i < this._connectedHubs.length; i++) {
      let hubUrl = this._connectedHubs[i].imm_getRootUrl();
      if (baseUrl.slice(0, hubUrl.length) == hubUrl) {
        hub = this._connectedHubs[i];
        break;
      }
    }
    if (!hub && this._knownHubsByUrl[str_device]) {
      hub = this._knownHubsByUrl[str_device];
    }
    if (!hub) {
      res.errorType = YAPI_DEVICE_NOT_FOUND;
      res.errorMsg = "No hub found for URL " + baseUrl;
      return res;
    }
    let method = words[0];
    let devUrl = words[1];
    if (devUrl.substr(0, 1) == "/")
      devUrl = devUrl.substr(1);
    if (baseUrl.substr(0, hub.imm_getRootUrl().length) == hub.imm_getRootUrl()) {
      devUrl = baseUrl.substr(hub.imm_getRootUrl().length - 1) + devUrl;
    } else {
      let pos = baseUrl.indexOf("//");
      pos = baseUrl.indexOf("/", pos + 3);
      devUrl = baseUrl.slice(pos) + devUrl;
    }
    if (devUrl.slice(-2) == "&." && !await hub.hasRwAccess()) {
      res.errorType = YAPI_UNAUTHORIZED;
      res.errorMsg = "Access denied: admin credentials required";
      return res;
    }
    let delayedCode = function delayedRequest() {
      return hub.request(method, devUrl, obj_body, int_tcpchan).catch((e) => {
        let res2 = new YHTTPRequest(null);
        res2.errorType = YAPI_IO_ERROR;
        res2.errorMsg = e.message;
        return res2;
      });
    };
    if (lockdev && int_tcpchan == 0) {
      let newPromise = lockdev._pendingQueries.then(delayedCode, delayedCode);
      lockdev._pendingQueries = newPromise;
      res = await newPromise;
    } else {
      res = await delayedCode();
    }
    return res;
  }
  async isReadOnly(str_device) {
    let lockdev = this.imm_getDevice(str_device);
    if (!lockdev) {
      return true;
    }
    let baseUrl = lockdev.imm_getRootUrl();
    let hub = null;
    for (let i = 0; i < this._connectedHubs.length; i++) {
      let hubUrl = this._connectedHubs[i].imm_getRootUrl();
      if (baseUrl.slice(0, hubUrl.length) == hubUrl) {
        hub = this._connectedHubs[i];
        break;
      }
    }
    if (!hub || !await hub.hasRwAccess()) {
      return true;
    }
    return false;
  }
  imm_funcDev_internal(str_className, str_func) {
    let res = new YFuncRequest(null);
    let resolve = this.imm_resolveFunction(str_className, str_func);
    if (resolve.errorType != YAPI_SUCCESS) {
      res.errorType = resolve.errorType;
      res.errorMsg = resolve.errorMsg;
    } else {
      str_func = resolve.result;
      let dotpos = str_func.indexOf(".");
      let devid = str_func.substr(0, dotpos);
      let funcid = str_func.substr(dotpos + 1);
      let dev = this.imm_getDevice(devid);
      if (dev == null) {
        res.errorType = YAPI_DEVICE_NOT_FOUND;
        res.errorMsg = "Device [" + devid + "] not found";
      } else {
        res.obj_result = {_expiration: -1, device: dev, deviceid: devid, functionid: funcid, hwid: str_func};
      }
    }
    return res;
  }
  async _funcDev(str_className, str_func) {
    let res = this.imm_funcDev_internal(str_className, str_func);
    if (res.errorType == YAPI_SUCCESS) {
      return res;
    } else if (res.errorType == YAPI_DEVICE_NOT_FOUND && this._connectedHubs.length == 0) {
      res.errorMsg = "Impossible to contact any device because no hub has been registered";
      return res;
    }
    let updRes = await this._updateDeviceList_internal(true, false);
    if (updRes.errorType != YAPI_SUCCESS) {
      res.errorType = updRes.errorType;
      res.errorMsg = updRes.errorMsg;
      return res;
    }
    return this.imm_funcDev_internal(str_className, str_func);
  }
  async funcRequest(str_className, str_func, str_extra, int_msValidity = 0) {
    let funcreq = this.imm_funcDev_internal(str_className, str_func);
    if (funcreq.errorType != YAPI_SUCCESS) {
      funcreq = await this._funcDev(str_className, str_func);
      if (funcreq.errorType != YAPI_SUCCESS) {
        return funcreq;
      }
    }
    let devreq = funcreq.obj_result;
    let loadval = null;
    if (str_extra == "") {
      let yreq = await devreq.device.requestAPI(int_msValidity);
      if (yreq != null) {
        if (yreq.errorType != YAPI_SUCCESS || !yreq.obj_result) {
          let res = new YFuncRequest(null);
          res.errorType = yreq.errorType;
          res.errorMsg = yreq.errorMsg;
          return res;
        }
        loadval = yreq.obj_result[devreq.functionid];
      }
    } else {
      devreq.device.imm_dropCache();
    }
    if (!loadval) {
      if (str_extra == "")
        str_extra = ".json";
      let httpreq = "GET /api/" + devreq.functionid + str_extra;
      let yreq = await this.devRequest(devreq.deviceid, httpreq, null, 0);
      if (yreq.errorType != YAPI_SUCCESS)
        return yreq;
      let replyBuff = yreq.bin_result;
      if (replyBuff.length == 0 && httpreq.indexOf("?") >= 0) {
        funcreq.obj_result = null;
        return funcreq;
      }
      try {
        loadval = JSON.parse(this.imm_bin2str(replyBuff));
      } catch (err) {
      }
    }
    if (!loadval) {
      funcreq.errorType = YAPI_IO_ERROR;
      funcreq.errorMsg = "Request failed, could not parse API value for function " + devreq.hwid;
    } else {
      for (let key in devreq) {
        loadval[key] = devreq[key];
      }
      funcreq.obj_result = loadval;
    }
    return funcreq;
  }
  async HTTPRequest(str_device, str_request) {
    let yreq = await this.devRequest(str_device, str_request, null, 0);
    if (yreq.errorType != YAPI_SUCCESS) {
      return this._throw(yreq.errorType, yreq.errorMsg, null);
    }
    return yreq.bin_result;
  }
  async ForceDeviceRefresh(str_device) {
    let dev = this.imm_getDevice(str_device);
    if (!dev)
      return YAPI_DEVICE_NOT_FOUND;
    let rootUrl = dev.imm_getRootUrl();
    for (let i = 0; i < this._connectedHubs.length; i++) {
      let hub = this._connectedHubs[i];
      let hubUrl = hub.urlInfo.imm_getRootUrl();
      if (rootUrl.substr(0, hubUrl.length) === hubUrl) {
        let hubDev = this.imm_getDevice(hubUrl);
        hubDev.imm_dropCache();
        let retcode = await hubDev.refresh();
        if (retcode != YAPI_SUCCESS) {
          return this._throw(retcode, hubDev._lastErrorMsg, retcode);
        }
        let yreq = await hubDev.requestAPI(this.defaultCacheValidity);
        if (yreq.errorType != YAPI_SUCCESS) {
          return yreq.errorType;
        }
        let yellowPages = yreq.obj_result["services"]["yellowPages"];
        dev.imm_updateFromYP(yellowPages);
      }
    }
    dev.imm_dropCache();
    return YAPI_SUCCESS;
  }
  async SetDeviceListValidity_internal(deviceListValidity) {
    this._deviceListValidityMs = deviceListValidity * 1e3;
  }
  async GetDeviceListValidity_internal() {
    return this._deviceListValidityMs / 1e3 >> 0;
  }
  async SetNetworkTimeout_internal(networkMsTimeout) {
    this._networkTimeoutMs = networkMsTimeout;
  }
  async GetNetworkTimeout_internal() {
    return this._networkTimeoutMs;
  }
  async AddUdevRule_internal(force) {
    return "error: Not supported in TypeScript";
  }
  async DownloadHostCertificate_internal(url, mstimeout) {
    return await this.system_env.downloadRemoteCertificate(new _YY_UrlInfo(url));
  }
  async SetTrustedCertificatesList_internal(certificatePath) {
    return "error: Not supported in TypeScript";
  }
  async SetNetworkSecurityOptions_internal(opts) {
    this._networkSecurityOptions = opts;
    return "";
  }
  async AddTrustedCertificates_internal(certificate) {
    this._trustedCertificate.push(certificate);
    return "";
  }
  async SetDeviceListValidity(deviceListValidity) {
    return await this.SetDeviceListValidity_internal(deviceListValidity);
  }
  async GetDeviceListValidity() {
    return await this.GetDeviceListValidity_internal();
  }
  async AddUdevRule(force) {
    return await this.AddUdevRule_internal(force);
  }
  async DownloadHostCertificate(url, mstimeout) {
    return await this.DownloadHostCertificate_internal(url, mstimeout);
  }
  async AddTrustedCertificates(certificate) {
    return await this.AddTrustedCertificates_internal(certificate);
  }
  async SetTrustedCertificatesList(certificatePath) {
    return await this.SetTrustedCertificatesList_internal(certificatePath);
  }
  async SetNetworkSecurityOptions(opts) {
    return await this.SetNetworkSecurityOptions_internal(opts);
  }
  async SetNetworkTimeout(networkMsTimeout) {
    return await this.SetNetworkTimeout_internal(networkMsTimeout);
  }
  async GetNetworkTimeout() {
    return await this.GetNetworkTimeout_internal();
  }
  async SetCacheValidity(cacheValidityMs) {
    this.defaultCacheValidity = cacheValidityMs;
  }
  async GetCacheValidity() {
    return this.defaultCacheValidity;
  }
  nextHubInUseInternal(hubref) {
    return this.nextHubInUseInternal_internal(hubref);
  }
  getYHubObj(hubref) {
    let obj;
    obj = this._findYHubFromCache(hubref);
    if (obj == null) {
      obj = new YHub(this, hubref);
      this._addYHubToCache(hubref, obj);
    }
    return obj;
  }
  async GetAPIVersion() {
    return this.imm_GetAPIVersion();
  }
  imm_GetAPIVersion() {
    return "2.0.63744";
  }
  async InitAPI(mode, errmsg) {
    this._detectType = mode;
    if (this.system_env.hasSSDP) {
      if ((mode & this.DETECT_NET) !== 0) {
        await this.TriggerHubDiscovery();
      }
    } else {
    }
    return YAPI_SUCCESS;
  }
  async FreeAPI() {
    for (let serial in this._devs) {
      await this._devs[serial].waitPendingQueries();
    }
    await this.KillAPI();
  }
  async KillAPI() {
    if (this._ssdpManager) {
      await this._ssdpManager.ySSDPStop();
      this._ssdpManager = null;
    }
    for (let hub of this._connectedHubs) {
      this.imm_dropConnectedHub(hub);
    }
    for (let serial in this._knownHubsBySerial) {
      let hub = this._knownHubsBySerial[serial];
      if (hub.imm_getcurrentState() > -5) {
        await hub.detach(YAPI.IO_ERROR, "Connection closed by FreeAPI");
      }
    }
    this.imm_ResetToDefaults();
  }
  async DisableExceptions() {
    this.exceptionsDisabled = true;
  }
  async EnableExceptions() {
    this.exceptionsDisabled = false;
  }
  async LogUnhandledPromiseRejections() {
    this.system_env.hookUnhandledRejection((reason, promise) => {
      this.imm_log("Unhandled Rejection at: Promise ", promise, " reason: ", reason);
    });
  }
  async RegisterHub(url, errmsg) {
    if (this._logLevel >= 4) {
      this.imm_log("Registering  hub: " + url);
    }
    if (url === "net") {
      if (this.system_env.hasSSDP) {
        this._detectType |= this.DETECT_NET;
        return this.TriggerHubDiscovery();
      } else {
        return this.imm_setErr(errmsg, YAPI_NOT_SUPPORTED, "Network discovery is not possible in a browser", YAPI_NOT_SUPPORTED);
      }
    }
    if (url === "usb") {
      return this.imm_setErr(errmsg, YAPI_NOT_SUPPORTED, "Use the VirtualHub on 127.0.0.1 to access USB devices", YAPI_NOT_SUPPORTED);
    }
    let urlInfo = new _YY_UrlInfo(url);
    let hub = this.imm_getHub(urlInfo);
    if (!hub) {
      if (this._logLevel >= 3) {
        this.imm_log("Registering new hub: " + urlInfo.imm_getRootUrl());
      }
      hub = new YGenericHub(this, urlInfo);
      hub.imm_addKnownUrl(urlInfo);
      this._knownHubsByUrl[urlInfo.imm_getRootUrl()] = hub;
    } else {
      if (this._logLevel >= 3) {
        this.imm_log("Registering existing hub: " + urlInfo.imm_getRootUrl() + " old=" + hub.imm_getRootUrl());
      }
      hub.imm_updateUrl(urlInfo);
    }
    await hub.attach(2);
    let sub_errmsg = new YErrorMsg();
    let retcode = await hub.waitForConnection(this._networkTimeoutMs, sub_errmsg);
    if (retcode != YAPI_SUCCESS) {
      this.imm_dropConnectedHub(hub);
      await hub.detach(retcode, sub_errmsg.msg);
      hub.imm_forgetUrls();
      return this.imm_setErr(errmsg, retcode, sub_errmsg.msg, retcode);
    }
    let yreq = await this._updateDeviceList_internal(true, false);
    if (yreq.errorType != YAPI_SUCCESS) {
      if (this._logLevel >= 3) {
        this.imm_log("Registering failed with" + yreq.errorType + " (" + yreq.errorMsg + ")");
      }
      this.imm_dropConnectedHub(hub);
      await hub.detach(yreq.errorType, yreq.errorMsg);
      hub.imm_forgetUrls();
      return this.imm_setErr(errmsg, yreq.errorType, yreq.errorMsg, yreq.errorType);
    }
    return YAPI_SUCCESS;
  }
  async PreregisterHub(url, errmsg) {
    let urlInfo = new _YY_UrlInfo(url);
    let hub = this.imm_getHub(urlInfo);
    if (!hub) {
      if (this._logLevel >= 3) {
        this.imm_log("Preregistering new hub: " + urlInfo.imm_getRootUrl());
      }
      hub = new YGenericHub(this, urlInfo);
      if (!hub) {
        return this.imm_setErr(errmsg, YAPI_NOT_SUPPORTED, "Unsupported hub protocol: " + urlInfo.imm_getProto(), YAPI_NOT_SUPPORTED);
      }
      hub.imm_addKnownUrl(urlInfo);
      this._knownHubsByUrl[urlInfo.imm_getRootUrl()] = hub;
    } else {
      if (this._logLevel >= 3) {
        this.imm_log("Preregistering existing hub: " + urlInfo.imm_getRootUrl());
      }
      hub.imm_updateUrl(urlInfo);
    }
    await hub.attach(1);
    return YAPI_SUCCESS;
  }
  async RegisterHubHttpCallback(incomingMessage, serverResponse, errmsg) {
    let url = "http://callback:4444";
    let urlInfo = new _YY_UrlInfo(url);
    let hub = this.imm_getHub(urlInfo);
    if (!hub) {
      hub = new YGenericHub(this, urlInfo);
      let engine = this.system_env.getHttpCallbackEngine(hub, urlInfo, incomingMessage, serverResponse);
      if (!engine) {
        return this.imm_setErr(errmsg, YAPI_NOT_SUPPORTED, "HTTP Callback mode is not available in this environment", YAPI_NOT_SUPPORTED);
      }
      hub.imm_setHubEngine(engine);
    }
    await hub.attach(3);
    let sub_errmsg = new YErrorMsg();
    let retcode = await hub.waitForConnection(this._networkTimeoutMs, sub_errmsg);
    if (retcode != YAPI_SUCCESS) {
      this.imm_dropConnectedHub(hub);
      await hub.detach(retcode, sub_errmsg.msg);
      return this.imm_setErr(errmsg, retcode, sub_errmsg.msg, retcode);
    }
    let yreq = await this._updateDeviceList_internal(true, false);
    if (yreq.errorType != YAPI_SUCCESS) {
      await hub.reportFailure(yreq.errorMsg);
      return this.imm_setErr(errmsg, yreq.errorType, yreq.errorMsg, yreq.errorType);
    }
    return YAPI_SUCCESS;
  }
  async RegisterHubWebSocketCallback(ws, errmsg, authpwd) {
    let authstr = authpwd ? "ws:" + authpwd + "@" : "";
    let url = "http://" + authstr + "callback:4444";
    let urlInfo = new _YY_UrlInfo(url);
    let hub = this.imm_getHub(urlInfo);
    if (!hub) {
      hub = new YGenericHub(this, urlInfo);
      let engine = this.system_env.getWebSocketCallbackEngine(hub, urlInfo, ws);
      if (!engine) {
        return this.imm_setErr(errmsg, YAPI_NOT_SUPPORTED, "WebSocket Callback mode is not available in this environment", YAPI_NOT_SUPPORTED);
      }
      hub.imm_setHubEngine(engine);
    }
    await hub.attach(3);
    let sub_errmsg = new YErrorMsg();
    let retcode = await hub.waitForConnection(this._networkTimeoutMs, sub_errmsg);
    if (retcode != YAPI_SUCCESS) {
      this.imm_dropConnectedHub(hub);
      await hub.detach(retcode, sub_errmsg.msg);
      return this.imm_setErr(errmsg, retcode, sub_errmsg.msg, retcode);
    }
    let yreq = await this._updateDeviceList_internal(true, false);
    if (yreq.errorType != YAPI_SUCCESS) {
      this.imm_dropConnectedHub(hub);
      await hub.detach(yreq.errorType, yreq.errorMsg);
      return this.imm_setErr(errmsg, yreq.errorType, yreq.errorMsg, yreq.errorType);
    }
    return YAPI_SUCCESS;
  }
  async WebSocketJoin(ws, arr_credentials, closeCallback) {
    if (this._connectedHubs.length == 0) {
      return false;
    }
    let hub = this._connectedHubs[0];
    return await hub.WebSocketJoin(ws, arr_credentials, closeCallback);
  }
  async UnregisterHub(url) {
    let urlInfo = new _YY_UrlInfo(url);
    let hub = this.imm_getHub(urlInfo);
    if (hub) {
      for (let serial in this._devs) {
        await this._devs[serial].waitPendingQueries();
      }
      await hub.waitForPendingQueries(200);
      let serialNumber = hub.imm_getSerialNumber();
      if (serialNumber) {
        let activeHub = this._knownHubsBySerial[serialNumber];
        if (activeHub) {
          hub.imm_forgetUrls();
          hub = activeHub;
          urlInfo = hub.urlInfo;
        }
      }
      if (this._logLevel >= 3) {
        this.imm_log("Unregistering hub " + url + " (" + urlInfo.imm_getRootUrl() + ")");
      }
      this.imm_dropConnectedHub(hub);
      if (hub.imm_isDisconnected()) {
        if (this._logLevel >= 3) {
          this.imm_log("Hub " + urlInfo.imm_getRootUrl() + " is already disconnected");
        }
        return;
      }
      let before = this.GetTickCount();
      let disconnected = hub.waitForDisconnection(500);
      if (hub.imm_isDisconnecting()) {
        if (this._logLevel >= 3) {
          this.imm_log("Hub " + urlInfo.imm_getRootUrl() + " is already disconnecting");
        }
      } else {
        await hub.detach(YAPI.IO_ERROR, "Hub has been unregistered");
      }
      await disconnected;
      hub.imm_forgetUrls();
      if (this._logLevel >= 4) {
        this.imm_log("Disconnected after " + (this.GetTickCount() - before) + " ms");
      }
    } else {
      if (this._logLevel >= 4) {
        this.imm_log("No hub to Unregister with " + url + " (" + urlInfo.imm_getRootUrl() + ")");
      }
    }
  }
  async TestHub(url, mstimeout, errmsg) {
    if (url == "net") {
      return this.imm_setErr(errmsg, YAPI_INVALID_ARGUMENT, "Not supported", YAPI_INVALID_ARGUMENT);
    }
    let urlInfo = new _YY_UrlInfo(url);
    let hub = this.imm_getHub(urlInfo);
    if (!hub) {
      if (this._logLevel >= 4) {
        this.imm_log("Testing new hub: " + urlInfo.imm_getRootUrl());
      }
      hub = new YGenericHub(this, urlInfo);
      if (!hub) {
        return this.imm_setErr(errmsg, YAPI_NOT_SUPPORTED, "Unsupported hub protocol: " + urlInfo.imm_getProto(), YAPI_NOT_SUPPORTED);
      }
    } else {
      if (this._logLevel >= 4) {
        this.imm_log("Testing existing hub: " + hub.imm_getRootUrl());
      }
    }
    await hub.attach(0);
    let sub_errmsg = new YErrorMsg();
    let retcode = await hub.waitForConnection(mstimeout, sub_errmsg);
    if (retcode != YAPI_SUCCESS) {
      return this.imm_setErr(errmsg, retcode, sub_errmsg.msg, retcode);
    }
    return YAPI_SUCCESS;
  }
  async UpdateDeviceList(errmsg = null) {
    let yreq = await this._updateDeviceList_internal(false, true);
    if (yreq.errorType !== YAPI_SUCCESS) {
      return this.imm_setErr(errmsg, yreq.errorType, yreq.errorMsg, yreq.errorType);
    }
    return YAPI_SUCCESS;
  }
  async _hubDiscoveryCallback_internal(serial, urlToRegister, urlToUnregister) {
    if (this._hubDiscoveryCallback && urlToRegister) {
      try {
        await this._hubDiscoveryCallback(serial, urlToRegister);
      } catch (e) {
        this.imm_log("Exception in hub discovery callback:", e);
      }
    }
    if ((this._detectType & Y_DETECT_NET) !== 0) {
      if (urlToRegister) {
        if (urlToUnregister) {
          await this.UnregisterHub(urlToUnregister);
        }
        await this.PreregisterHub(urlToRegister, new YErrorMsg());
      }
    }
  }
  async TriggerHubDiscovery(errmsg = null) {
    if (!this._ssdpManager) {
      this._ssdpManager = this.system_env.getSSDPManager(this);
      if (!this._ssdpManager)
        return this._lastErrorType;
      await this._ssdpManager.ySSDPStart((serial, newUrl, oldUrl) => {
        this._hubDiscoveryCallback_internal(serial, newUrl, oldUrl);
      });
    } else {
      await this._ssdpManager.ySSDPDiscover();
    }
    return YAPI_SUCCESS;
  }
  async HandleEvents(errmsg = null) {
    return YAPI_SUCCESS;
  }
  async Sleep(ms_duration, errmsg = null) {
    let end = this.GetTickCount() + ms_duration;
    let remaining = ms_duration;
    while (remaining > 0) {
      let waitTime = Math.min(remaining, 25);
      await new Promise((resolve, reject) => {
        setTimeout(resolve, waitTime);
      });
      remaining = end - this.GetTickCount();
    }
    return YAPI_SUCCESS;
  }
  _microSleep_internal() {
    return new Promise(function(resolve, reject) {
      setTimeout(resolve, 3);
    });
  }
  SetTimeout(callback, ms_timeout, args) {
    let endtime = this.GetTickCount() + ms_timeout;
    let setTimeout_internal = async () => {
      let delay = endtime - this.GetTickCount();
      if (delay < 40) {
        if (delay > 3) {
          await new Promise((resolve, reject) => {
            setTimeout(resolve, delay);
          });
        }
        callback.apply(null, args);
      } else {
        if (delay >= 150) {
          await this.UpdateDeviceList();
          delay = Math.min(endtime - YAPI.GetTickCount(), 110);
        }
        await this.Sleep(delay - 20);
        setTimeout_internal();
      }
    };
    setTimeout_internal();
    return YAPI_SUCCESS;
  }
  GetTickCount() {
    return Date.now();
  }
  imm_CheckLogicalName(name) {
    if (name == "")
      return true;
    if (!name)
      return false;
    if (name.length > 19)
      return false;
    return /^[A-Za-z0-9_\-]*$/.test(name);
  }
  async CheckLogicalName(name) {
    return this.imm_CheckLogicalName(name);
  }
  async RegisterDeviceArrivalCallback(arrivalCallback) {
    this._arrivalCallback = arrivalCallback;
  }
  async RegisterDeviceChangeCallback(changeCallback) {
    this._namechgCallback = changeCallback;
  }
  async RegisterDeviceRemovalCallback(removalCallback) {
    this._removalCallback = removalCallback;
  }
  async RegisterHubDiscoveryCallback(hubDiscoveryCallback) {
    if (!this.system_env.hasSSDP) {
      return this._throw(YAPI_NOT_SUPPORTED, "Hub discovery is not supported in this environment", YAPI_NOT_SUPPORTED);
    }
    this._hubDiscoveryCallback = hubDiscoveryCallback;
    return this.TriggerHubDiscovery();
  }
  async RegisterCalibrationHandler(calibrationType, calibrationHandler) {
    this._calibHandlers[calibrationType] = calibrationHandler;
  }
  LinearCalibrationHandler(float_rawValue, int_calibType, arr_calibParams, arr_calibRawValues, arr_calibRefValues) {
    let npt;
    let x = arr_calibRawValues[0];
    let adj = arr_calibRefValues[0] - x;
    let i = 0;
    if (int_calibType < YOCTO_CALIB_TYPE_OFS) {
      npt = Math.min(int_calibType % 10, arr_calibRawValues.length, arr_calibRefValues.length);
    } else {
      npt = arr_calibRefValues.length;
    }
    while (float_rawValue > arr_calibRawValues[i] && ++i < npt) {
      let x2 = x;
      let adj2 = adj;
      x = arr_calibRawValues[i];
      adj = arr_calibRefValues[i] - x;
      if (float_rawValue < x && x > x2) {
        adj = adj2 + (adj - adj2) * (float_rawValue - x2) / (x - x2);
      }
    }
    return float_rawValue + adj;
  }
  imm_yMD5(text) {
    let ctx = new Y_MD5Ctx();
    ctx.addData(this.imm_str2bin(text));
    return ctx.calculate();
  }
  imm_initshaw(str_s, int_ofs, int_pad, int_xinit, _shaw) {
    let ii;
    let j = -1;
    let k = 0;
    let n = str_s.length;
    for (ii = 0; ii < 64; ii++) {
      let i = int_ofs + ii;
      let c = 0;
      if (i < n) {
        c = str_s.charCodeAt(i);
      } else if (int_pad != 0) {
        if ((int_pad & 128) != 0) {
          if (i == n)
            c = int_pad;
        } else {
          if (i == n + 3) {
            c = int_pad;
          } else if (i == n + 4)
            c = 128;
        }
      }
      if (k == 0) {
        j++;
        _shaw[j] = 0;
        k = 32;
      }
      k -= 8;
      _shaw[j] |= c << k;
    }
    if (int_pad != 0) {
      if (int_pad == 128) {
        if (n <= int_ofs + 55) {
          _shaw[15] = 8 * n;
        }
      } else {
        _shaw[15] = 8 * (64 + n + 4);
      }
    }
    if (int_xinit != 0) {
      let xdw = int_xinit << 16 | int_xinit;
      for (j = 0; j < 16; j++) {
        _shaw[j] ^= xdw;
      }
    }
  }
  imm_itershaw(s, _shaw) {
    let a, b, c, d, e, t, k;
    a = s[0];
    b = s[1];
    c = s[2];
    d = s[3];
    e = s[4];
    for (k = 16; k < 80; k++) {
      t = _shaw[k - 3] ^ _shaw[k - 8] ^ _shaw[k - 14] ^ _shaw[k - 16];
      _shaw[k] = t << 1 | t >>> 31;
    }
    for (k = 0; k < 20; k++) {
      t = (a << 5 | a >>> 27) + e + _shaw[k] + 1518500249 + (b & c | ~b & d);
      e = d;
      d = c;
      c = b << 30 | b >>> 2;
      b = a;
      a = t & 4294967295;
    }
    for (k = 20; k < 40; k++) {
      t = (a << 5 | a >>> 27) + e + _shaw[k] + 1859775393 + (b ^ c ^ d);
      e = d;
      d = c;
      c = b << 30 | b >>> 2;
      b = a;
      a = t & 4294967295;
    }
    for (k = 40; k < 60; k++) {
      t = (a << 5 | a >>> 27) + e + _shaw[k] + 2400959708 + (b & c | b & d | c & d);
      e = d;
      d = c;
      c = b << 30 | b >>> 2;
      b = a;
      a = t & 4294967295;
    }
    for (k = 60; k < 80; k++) {
      t = (a << 5 | a >>> 27) + e + _shaw[k] + 3395469782 + (b ^ c ^ d);
      e = d;
      d = c;
      c = b << 30 | b >>> 2;
      b = a;
      a = t & 4294967295;
    }
    _shaw[0] = s[0] + a & 4294967295;
    _shaw[1] = s[1] + b & 4294967295;
    _shaw[2] = s[2] + c & 4294967295;
    _shaw[3] = s[3] + d & 4294967295;
    _shaw[4] = s[4] + e & 4294967295;
  }
  imm_ySHA1(text) {
    let shau = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
    let i, ofs = 0;
    let n = text.length;
    let _shaw = new Uint32Array(80);
    do {
      this.imm_initshaw(text, ofs, 128, 0, _shaw);
      this.imm_itershaw(shau, _shaw);
      for (i = 0; i < 5; i++) {
        shau[i] = _shaw[i];
      }
      ofs += 64;
    } while (n > ofs - 9);
    let res = new Uint8Array(20);
    for (i = 0; i < 20; i++) {
      res[i] = shau[i >>> 2] >>> 24 - 8 * (i & 3) & 255;
    }
    return res;
  }
  async ComputePSK(ssid, pass) {
    let sha1_init = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
    let inner = [], outer = [], shau = [], res = [];
    let iter, pos, k, _shaw;
    _shaw = new Uint32Array(80);
    this.imm_initshaw(pass, 0, 0, 13878, _shaw);
    this.imm_itershaw(sha1_init, _shaw);
    for (k = 0; k < 5; k++) {
      inner[k] = _shaw[k];
    }
    _shaw = new Uint32Array(80);
    this.imm_initshaw(pass, 0, 0, 23644, _shaw);
    this.imm_itershaw(sha1_init, _shaw);
    for (k = 0; k < 5; k++) {
      outer[k] = _shaw[k];
    }
    pos = 0;
    for (k = 0; k < 5; k++) {
      shau[k] = 0;
    }
    _shaw = new Uint32Array(80);
    this.imm_initshaw(ssid, 0, 1, 0, _shaw);
    for (iter = 0; iter < 8192; ) {
      this.imm_itershaw(inner, _shaw);
      _shaw[5] = 2147483648;
      for (k = 6; k < 15; k++) {
        _shaw[k] = 0;
      }
      _shaw[15] = 8 * (64 + 20);
      this.imm_itershaw(outer, _shaw);
      shau[0] ^= _shaw[0];
      shau[1] ^= _shaw[1];
      shau[2] ^= _shaw[2];
      shau[3] ^= _shaw[3];
      shau[4] ^= _shaw[4];
      iter++;
      if ((iter & 4095) == 0) {
        for (k = 0; k < 5 && pos < 32; k++) {
          res[pos++] = shau[k] >>> 24 & 255;
          res[pos++] = shau[k] >>> 16 & 255;
          res[pos++] = shau[k] >>> 8 & 255;
          res[pos++] = shau[k] & 255;
        }
        if (iter == 4096) {
          for (k = 0; k < 5; k++) {
            shau[k] = 0;
          }
          _shaw = new Uint32Array(80);
          this.imm_initshaw(ssid, 0, 2, 0, _shaw);
        }
      }
    }
    let hex = "";
    for (k = 0; k < 32; k++) {
      hex += ("0" + Number(res[k]).toString(16)).slice(-2);
    }
    return hex;
  }
  nextHubInUseInternal_internal(hubref) {
    let nextref = hubref < 0 ? 0 : hubref + 1;
    let restart;
    let has_higher_hubref;
    do {
      has_higher_hubref = false;
      restart = false;
      for (let url in this._knownHubsByUrl) {
        let hub = this._knownHubsByUrl[url];
        let hubRef = hub.getHubRef();
        if (hubRef == nextref) {
          if (hub.imm_isPreOrRegistered()) {
            return this.getYHubObj(nextref);
          } else {
            has_higher_hubref = true;
            break;
          }
        } else if (hubRef > nextref) {
          has_higher_hubref = true;
        }
      }
      if (has_higher_hubref) {
        nextref++;
        restart = true;
      }
    } while (restart);
    return null;
  }
  getGenHub(hubref) {
    for (let url in this._knownHubsByUrl) {
      let hub = this._knownHubsByUrl[url];
      if (hub.getHubRef() == hubref && hub.imm_isPreOrRegistered()) {
        return hub;
      }
    }
    return null;
  }
  _findYHubFromCache(hubref) {
    return this._yhub_cache[hubref];
  }
  _addYHubToCache(hubref, obj) {
    this._yhub_cache[hubref] = obj;
  }
};
YAPIContext.SUCCESS = 0;
YAPIContext.NOT_INITIALIZED = -1;
YAPIContext.INVALID_ARGUMENT = -2;
YAPIContext.NOT_SUPPORTED = -3;
YAPIContext.DEVICE_NOT_FOUND = -4;
YAPIContext.VERSION_MISMATCH = -5;
YAPIContext.DEVICE_BUSY = -6;
YAPIContext.TIMEOUT = -7;
YAPIContext.IO_ERROR = -8;
YAPIContext.NO_MORE_DATA = -9;
YAPIContext.EXHAUSTED = -10;
YAPIContext.DOUBLE_ACCES = -11;
YAPIContext.UNAUTHORIZED = -12;
YAPIContext.RTC_NOT_READY = -13;
YAPIContext.FILE_NOT_FOUND = -14;
YAPIContext.SSL_ERROR = -15;
YAPIContext.RFID_SOFT_ERROR = -16;
YAPIContext.RFID_HARD_ERROR = -17;
YAPIContext.BUFFER_TOO_SMALL = -18;
YAPIContext.DNS_ERROR = -19;
YAPIContext.SSL_UNK_CERT = -20;
YAPIContext.NO_TRUSTED_CA_CHECK = 1;
YAPIContext.NO_EXPIRATION_CHECK = 2;
YAPIContext.NO_HOSTNAME_CHECK = 4;
YAPIContext.LEGACY = 8;
var YAPI = new YAPIContext();

// obj/full/Api/yocto_api_html.js
var YSystemEnvHtml = class extends YSystemEnv {
  constructor() {
    super(...arguments);
    this.isNodeJS = false;
    this.hasSSDP = false;
  }
  hookUnhandledRejection(handler) {
    window.addEventListener("onunhandledrejection", (event) => {
      let promiseRejectionEvent = event;
      handler(promiseRejectionEvent.reason, promiseRejectionEvent.promise);
    });
  }
  getWebSocketEngine(hub, runtime_urlInfo) {
    return new YWebSocketHtmlEngine(hub, runtime_urlInfo);
  }
  getHttpEngine(hub, runtime_urlInfo, firstInfoJson) {
    return new YHttpHtmlEngine(hub, runtime_urlInfo, firstInfoJson);
  }
  getWebSocketCallbackHub(hub, ws) {
    return hub._yapi._throw(YAPI.NOT_SUPPORTED, "WebSocket Callback mode is not available in this environment", null);
  }
  getHttpCallbackHub(hub, incomingMessage, serverResponse) {
    return hub._yapi._throw(YAPI.NOT_SUPPORTED, "HTTP Callback mode is not available in this environment", null);
  }
  getSSDPManager(obj_yapi) {
    return obj_yapi._throw(YAPI.NOT_SUPPORTED, "Hub discovery is not available in this environment", null);
  }
  loadfile(file) {
    return new Promise((resolve, reject) => {
      let reader = new FileReader();
      reader.onerror = function(evt) {
        reject(evt.target.error);
      };
      reader.onload = function(evt) {
        resolve(new Uint8Array(evt.target.result));
      };
      reader.readAsArrayBuffer(file);
    });
  }
  downloadfile(url, yapi) {
    return new Promise((resolve, reject) => {
      let httpRequest = new XMLHttpRequest();
      httpRequest.open("GET", url, true);
      httpRequest.overrideMimeType("text/plain; charset=x-user-defined");
      httpRequest.onreadystatechange = () => {
        if (httpRequest.readyState == 4) {
          if (httpRequest.status != 200 && httpRequest.status != 304) {
            if (httpRequest.status) {
              reject(new Error("HTTP error " + httpRequest.status));
            } else {
              reject(new Error("Unable to complete HTTP request, network down?"));
            }
          } else {
            resolve(YAPI.imm_str2bin(httpRequest.responseText));
          }
        }
      };
      httpRequest.send("");
    });
  }
  async downloadRemoteCertificate(urlinfo) {
    return "error: Not supported in browser";
  }
};
var _HtmlSystemEnv = new YSystemEnvHtml();
YAPI.imm_setSystemEnv(_HtmlSystemEnv);
var YHttpHtmlEngine = class extends YHttpEngine {
  constructor(hub, runtime_urlInfo, firstInfoJson) {
    super(hub, runtime_urlInfo, firstInfoJson);
  }
  imm_makeRequest(method, relUrl, contentType, body, onProgress, onSuccess, onError) {
    let xhr = new XMLHttpRequest();
    let currPos = 0;
    xhr.open(method, this._runtime_urlInfo.imm_getUrl(true, true, false) + relUrl, true, "", "");
    xhr.setRequestHeader("Content-Type", contentType);
    xhr.overrideMimeType("text/plain; charset=x-user-defined");
    xhr.onreadystatechange = () => {
      if (xhr.readyState >= 3) {
        let httpStatus = xhr.status >> 0;
        if (xhr.readyState == 4 && httpStatus != 200 && httpStatus != 304) {
          if (httpStatus == 401 || httpStatus == 204) {
            this.infoJson.stamp = 0;
            onError(YAPI.UNAUTHORIZED, "Unauthorized access (" + xhr.status + ")", false);
          } else if (httpStatus == 404) {
            onError(YAPI.FILE_NOT_FOUND, "HTTP request return status 404 (not found)", false);
          } else if (this._hub.imm_isDisconnecting()) {
            onError(YAPI.IO_ERROR, "Hub is disconnecting", false);
          } else {
            onError(YAPI.IO_ERROR, "HTTP request failed with status " + xhr.status, false);
          }
          return;
        }
        if (this._hub.imm_isDisconnecting()) {
          if (this._hub._yapi._logLevel >= 4) {
            this._hub._yapi.imm_log("Dropping request " + relUrl + " because hub is disconnecting");
          }
          return;
        }
        if (onProgress && xhr.responseText) {
          let newlen = xhr.responseText.length;
          if (newlen > currPos) {
            onProgress(xhr.responseText.slice(currPos, newlen));
            currPos = newlen;
          }
        }
        if (onSuccess && xhr.readyState == 4) {
          onSuccess(xhr.responseText);
        }
      }
    };
    xhr.onerror = () => {
      onError(YAPI.IO_ERROR, "HTTP request failed without status", false);
    };
    xhr.send(body);
    return xhr;
  }
  imm_abortRequest(clientRequest) {
    clientRequest.abort();
  }
};
var YWebSocketHtmlEngine = class extends YWebSocketEngine {
  imm_webSocketOpen(str_url) {
    let websock = new WebSocket(str_url);
    websock.binaryType = "arraybuffer";
    this.websocket = websock;
  }
  imm_getRandomValues(arr) {
    return window.crypto.getRandomValues(arr);
  }
};

// obj/full/Api/yocto_network.js
var YNetwork = class extends YFunction {
  constructor(yapi, func) {
    super(yapi, func);
    this._readiness = YNetwork.READINESS_INVALID;
    this._macAddress = YNetwork.MACADDRESS_INVALID;
    this._ipAddress = YNetwork.IPADDRESS_INVALID;
    this._subnetMask = YNetwork.SUBNETMASK_INVALID;
    this._router = YNetwork.ROUTER_INVALID;
    this._currentDNS = YNetwork.CURRENTDNS_INVALID;
    this._ipConfig = YNetwork.IPCONFIG_INVALID;
    this._primaryDNS = YNetwork.PRIMARYDNS_INVALID;
    this._secondaryDNS = YNetwork.SECONDARYDNS_INVALID;
    this._ntpServer = YNetwork.NTPSERVER_INVALID;
    this._userPassword = YNetwork.USERPASSWORD_INVALID;
    this._adminPassword = YNetwork.ADMINPASSWORD_INVALID;
    this._httpPort = YNetwork.HTTPPORT_INVALID;
    this._httpsPort = YNetwork.HTTPSPORT_INVALID;
    this._securityMode = YNetwork.SECURITYMODE_INVALID;
    this._defaultPage = YNetwork.DEFAULTPAGE_INVALID;
    this._discoverable = YNetwork.DISCOVERABLE_INVALID;
    this._wwwWatchdogDelay = YNetwork.WWWWATCHDOGDELAY_INVALID;
    this._callbackUrl = YNetwork.CALLBACKURL_INVALID;
    this._callbackMethod = YNetwork.CALLBACKMETHOD_INVALID;
    this._callbackEncoding = YNetwork.CALLBACKENCODING_INVALID;
    this._callbackTemplate = YNetwork.CALLBACKTEMPLATE_INVALID;
    this._callbackCredentials = YNetwork.CALLBACKCREDENTIALS_INVALID;
    this._callbackInitialDelay = YNetwork.CALLBACKINITIALDELAY_INVALID;
    this._callbackSchedule = YNetwork.CALLBACKSCHEDULE_INVALID;
    this._callbackMinDelay = YNetwork.CALLBACKMINDELAY_INVALID;
    this._callbackMaxDelay = YNetwork.CALLBACKMAXDELAY_INVALID;
    this._poeCurrent = YNetwork.POECURRENT_INVALID;
    this._valueCallbackNetwork = null;
    this.READINESS_DOWN = 0;
    this.READINESS_EXISTS = 1;
    this.READINESS_LINKED = 2;
    this.READINESS_LAN_OK = 3;
    this.READINESS_WWW_OK = 4;
    this.READINESS_INVALID = -1;
    this.MACADDRESS_INVALID = YAPI.INVALID_STRING;
    this.IPADDRESS_INVALID = YAPI.INVALID_STRING;
    this.SUBNETMASK_INVALID = YAPI.INVALID_STRING;
    this.ROUTER_INVALID = YAPI.INVALID_STRING;
    this.CURRENTDNS_INVALID = YAPI.INVALID_STRING;
    this.IPCONFIG_INVALID = YAPI.INVALID_STRING;
    this.PRIMARYDNS_INVALID = YAPI.INVALID_STRING;
    this.SECONDARYDNS_INVALID = YAPI.INVALID_STRING;
    this.NTPSERVER_INVALID = YAPI.INVALID_STRING;
    this.USERPASSWORD_INVALID = YAPI.INVALID_STRING;
    this.ADMINPASSWORD_INVALID = YAPI.INVALID_STRING;
    this.HTTPPORT_INVALID = YAPI.INVALID_UINT;
    this.HTTPSPORT_INVALID = YAPI.INVALID_UINT;
    this.SECURITYMODE_UNDEFINED = 0;
    this.SECURITYMODE_LEGACY = 1;
    this.SECURITYMODE_MIXED = 2;
    this.SECURITYMODE_SECURE = 3;
    this.SECURITYMODE_INVALID = -1;
    this.DEFAULTPAGE_INVALID = YAPI.INVALID_STRING;
    this.DISCOVERABLE_FALSE = 0;
    this.DISCOVERABLE_TRUE = 1;
    this.DISCOVERABLE_INVALID = -1;
    this.WWWWATCHDOGDELAY_INVALID = YAPI.INVALID_UINT;
    this.CALLBACKURL_INVALID = YAPI.INVALID_STRING;
    this.CALLBACKMETHOD_POST = 0;
    this.CALLBACKMETHOD_GET = 1;
    this.CALLBACKMETHOD_PUT = 2;
    this.CALLBACKMETHOD_INVALID = -1;
    this.CALLBACKENCODING_FORM = 0;
    this.CALLBACKENCODING_JSON = 1;
    this.CALLBACKENCODING_JSON_ARRAY = 2;
    this.CALLBACKENCODING_CSV = 3;
    this.CALLBACKENCODING_YOCTO_API = 4;
    this.CALLBACKENCODING_JSON_NUM = 5;
    this.CALLBACKENCODING_EMONCMS = 6;
    this.CALLBACKENCODING_AZURE = 7;
    this.CALLBACKENCODING_INFLUXDB = 8;
    this.CALLBACKENCODING_MQTT = 9;
    this.CALLBACKENCODING_YOCTO_API_JZON = 10;
    this.CALLBACKENCODING_PRTG = 11;
    this.CALLBACKENCODING_INFLUXDB_V2 = 12;
    this.CALLBACKENCODING_INVALID = -1;
    this.CALLBACKTEMPLATE_OFF = 0;
    this.CALLBACKTEMPLATE_ON = 1;
    this.CALLBACKTEMPLATE_INVALID = -1;
    this.CALLBACKCREDENTIALS_INVALID = YAPI.INVALID_STRING;
    this.CALLBACKINITIALDELAY_INVALID = YAPI.INVALID_UINT;
    this.CALLBACKSCHEDULE_INVALID = YAPI.INVALID_STRING;
    this.CALLBACKMINDELAY_INVALID = YAPI.INVALID_UINT;
    this.CALLBACKMAXDELAY_INVALID = YAPI.INVALID_UINT;
    this.POECURRENT_INVALID = YAPI.INVALID_UINT;
    this._className = "Network";
  }
  imm_parseAttr(name, val) {
    switch (name) {
      case "readiness":
        this._readiness = val;
        return 1;
      case "macAddress":
        this._macAddress = val;
        return 1;
      case "ipAddress":
        this._ipAddress = val;
        return 1;
      case "subnetMask":
        this._subnetMask = val;
        return 1;
      case "router":
        this._router = val;
        return 1;
      case "currentDNS":
        this._currentDNS = val;
        return 1;
      case "ipConfig":
        this._ipConfig = val;
        return 1;
      case "primaryDNS":
        this._primaryDNS = val;
        return 1;
      case "secondaryDNS":
        this._secondaryDNS = val;
        return 1;
      case "ntpServer":
        this._ntpServer = val;
        return 1;
      case "userPassword":
        this._userPassword = val;
        return 1;
      case "adminPassword":
        this._adminPassword = val;
        return 1;
      case "httpPort":
        this._httpPort = val;
        return 1;
      case "httpsPort":
        this._httpsPort = val;
        return 1;
      case "securityMode":
        this._securityMode = val;
        return 1;
      case "defaultPage":
        this._defaultPage = val;
        return 1;
      case "discoverable":
        this._discoverable = val;
        return 1;
      case "wwwWatchdogDelay":
        this._wwwWatchdogDelay = val;
        return 1;
      case "callbackUrl":
        this._callbackUrl = val;
        return 1;
      case "callbackMethod":
        this._callbackMethod = val;
        return 1;
      case "callbackEncoding":
        this._callbackEncoding = val;
        return 1;
      case "callbackTemplate":
        this._callbackTemplate = val;
        return 1;
      case "callbackCredentials":
        this._callbackCredentials = val;
        return 1;
      case "callbackInitialDelay":
        this._callbackInitialDelay = val;
        return 1;
      case "callbackSchedule":
        this._callbackSchedule = val;
        return 1;
      case "callbackMinDelay":
        this._callbackMinDelay = val;
        return 1;
      case "callbackMaxDelay":
        this._callbackMaxDelay = val;
        return 1;
      case "poeCurrent":
        this._poeCurrent = val;
        return 1;
    }
    return super.imm_parseAttr(name, val);
  }
  async get_readiness() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.READINESS_INVALID;
      }
    }
    res = this._readiness;
    return res;
  }
  async get_macAddress() {
    let res;
    if (this._cacheExpiration == 0) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.MACADDRESS_INVALID;
      }
    }
    res = this._macAddress;
    return res;
  }
  async get_ipAddress() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.IPADDRESS_INVALID;
      }
    }
    res = this._ipAddress;
    return res;
  }
  async get_subnetMask() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.SUBNETMASK_INVALID;
      }
    }
    res = this._subnetMask;
    return res;
  }
  async get_router() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.ROUTER_INVALID;
      }
    }
    res = this._router;
    return res;
  }
  async get_currentDNS() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.CURRENTDNS_INVALID;
      }
    }
    res = this._currentDNS;
    return res;
  }
  async get_ipConfig() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.IPCONFIG_INVALID;
      }
    }
    res = this._ipConfig;
    return res;
  }
  async set_ipConfig(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("ipConfig", rest_val);
  }
  async get_primaryDNS() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.PRIMARYDNS_INVALID;
      }
    }
    res = this._primaryDNS;
    return res;
  }
  async set_primaryDNS(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("primaryDNS", rest_val);
  }
  async get_secondaryDNS() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.SECONDARYDNS_INVALID;
      }
    }
    res = this._secondaryDNS;
    return res;
  }
  async set_secondaryDNS(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("secondaryDNS", rest_val);
  }
  async get_ntpServer() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.NTPSERVER_INVALID;
      }
    }
    res = this._ntpServer;
    return res;
  }
  async set_ntpServer(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("ntpServer", rest_val);
  }
  async get_userPassword() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.USERPASSWORD_INVALID;
      }
    }
    res = this._userPassword;
    return res;
  }
  async set_userPassword(newval) {
    let rest_val;
    if (newval.length > YAPI.HASH_BUF_SIZE) {
      return this._throw(YAPI.INVALID_ARGUMENT, "Password too long :" + newval, YAPI.INVALID_ARGUMENT);
    }
    rest_val = String(newval);
    return await this._setAttr("userPassword", rest_val);
  }
  async get_adminPassword() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.ADMINPASSWORD_INVALID;
      }
    }
    res = this._adminPassword;
    return res;
  }
  async set_adminPassword(newval) {
    let rest_val;
    if (newval.length > YAPI.HASH_BUF_SIZE) {
      return this._throw(YAPI.INVALID_ARGUMENT, "Password too long :" + newval, YAPI.INVALID_ARGUMENT);
    }
    rest_val = String(newval);
    return await this._setAttr("adminPassword", rest_val);
  }
  async get_httpPort() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.HTTPPORT_INVALID;
      }
    }
    res = this._httpPort;
    return res;
  }
  async set_httpPort(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("httpPort", rest_val);
  }
  async get_httpsPort() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.HTTPSPORT_INVALID;
      }
    }
    res = this._httpsPort;
    return res;
  }
  async set_httpsPort(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("httpsPort", rest_val);
  }
  async get_securityMode() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.SECURITYMODE_INVALID;
      }
    }
    res = this._securityMode;
    return res;
  }
  async set_securityMode(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("securityMode", rest_val);
  }
  async get_defaultPage() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.DEFAULTPAGE_INVALID;
      }
    }
    res = this._defaultPage;
    return res;
  }
  async set_defaultPage(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("defaultPage", rest_val);
  }
  async get_discoverable() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.DISCOVERABLE_INVALID;
      }
    }
    res = this._discoverable;
    return res;
  }
  async set_discoverable(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("discoverable", rest_val);
  }
  async get_wwwWatchdogDelay() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.WWWWATCHDOGDELAY_INVALID;
      }
    }
    res = this._wwwWatchdogDelay;
    return res;
  }
  async set_wwwWatchdogDelay(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("wwwWatchdogDelay", rest_val);
  }
  async get_callbackUrl() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.CALLBACKURL_INVALID;
      }
    }
    res = this._callbackUrl;
    return res;
  }
  async set_callbackUrl(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("callbackUrl", rest_val);
  }
  async get_callbackMethod() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.CALLBACKMETHOD_INVALID;
      }
    }
    res = this._callbackMethod;
    return res;
  }
  async set_callbackMethod(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("callbackMethod", rest_val);
  }
  async get_callbackEncoding() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.CALLBACKENCODING_INVALID;
      }
    }
    res = this._callbackEncoding;
    return res;
  }
  async set_callbackEncoding(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("callbackEncoding", rest_val);
  }
  async get_callbackTemplate() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.CALLBACKTEMPLATE_INVALID;
      }
    }
    res = this._callbackTemplate;
    return res;
  }
  async set_callbackTemplate(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("callbackTemplate", rest_val);
  }
  async get_callbackCredentials() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.CALLBACKCREDENTIALS_INVALID;
      }
    }
    res = this._callbackCredentials;
    return res;
  }
  async set_callbackCredentials(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("callbackCredentials", rest_val);
  }
  async callbackLogin(username, password) {
    let rest_val;
    rest_val = username + ":" + password;
    return await this._setAttr("callbackCredentials", rest_val);
  }
  async get_callbackInitialDelay() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.CALLBACKINITIALDELAY_INVALID;
      }
    }
    res = this._callbackInitialDelay;
    return res;
  }
  async set_callbackInitialDelay(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("callbackInitialDelay", rest_val);
  }
  async get_callbackSchedule() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.CALLBACKSCHEDULE_INVALID;
      }
    }
    res = this._callbackSchedule;
    return res;
  }
  async set_callbackSchedule(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("callbackSchedule", rest_val);
  }
  async get_callbackMinDelay() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.CALLBACKMINDELAY_INVALID;
      }
    }
    res = this._callbackMinDelay;
    return res;
  }
  async set_callbackMinDelay(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("callbackMinDelay", rest_val);
  }
  async get_callbackMaxDelay() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.CALLBACKMAXDELAY_INVALID;
      }
    }
    res = this._callbackMaxDelay;
    return res;
  }
  async set_callbackMaxDelay(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("callbackMaxDelay", rest_val);
  }
  async get_poeCurrent() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.POECURRENT_INVALID;
      }
    }
    res = this._poeCurrent;
    return res;
  }
  static FindNetwork(func) {
    let obj;
    obj = YFunction._FindFromCache("Network", func);
    if (obj == null) {
      obj = new YNetwork(YAPI, func);
      YFunction._AddToCache("Network", func, obj);
    }
    return obj;
  }
  static FindNetworkInContext(yctx, func) {
    let obj;
    obj = YFunction._FindFromCacheInContext(yctx, "Network", func);
    if (obj == null) {
      obj = new YNetwork(yctx, func);
      YFunction._AddToCache("Network", func, obj);
    }
    return obj;
  }
  async registerValueCallback(callback) {
    let val;
    if (callback != null) {
      await YFunction._UpdateValueCallbackList(this, true);
    } else {
      await YFunction._UpdateValueCallbackList(this, false);
    }
    this._valueCallbackNetwork = callback;
    if (callback != null && await this.isOnline()) {
      val = this._advertisedValue;
      if (!(val == "")) {
        await this._invokeValueCallback(val);
      }
    }
    return 0;
  }
  async _invokeValueCallback(value) {
    if (this._valueCallbackNetwork != null) {
      try {
        await this._valueCallbackNetwork(this, value);
      } catch (e) {
        this._yapi.imm_log("Exception in valueCallback:", e);
      }
    } else {
      await super._invokeValueCallback(value);
    }
    return 0;
  }
  async useDHCP(fallbackIpAddr, fallbackSubnetMaskLen, fallbackRouter) {
    return await this.set_ipConfig("DHCP:" + fallbackIpAddr + "/" + String(Math.round(fallbackSubnetMaskLen)) + "/" + fallbackRouter);
  }
  async useDHCPauto() {
    return await this.set_ipConfig("DHCP:");
  }
  async useStaticIP(ipAddress, subnetMaskLen, router) {
    return await this.set_ipConfig("STATIC:" + ipAddress + "/" + String(Math.round(subnetMaskLen)) + "/" + router);
  }
  async ping(host) {
    let content;
    content = await this._download("ping.txt?host=" + host);
    return this._yapi.imm_bin2str(content);
  }
  async triggerCallback() {
    return await this.set_callbackMethod(await this.get_callbackMethod());
  }
  async set_periodicCallbackSchedule(interval, offset) {
    return await this.set_callbackSchedule("every " + interval + "+" + String(Math.round(offset)));
  }
  nextNetwork() {
    let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
    if (resolve.errorType != YAPI.SUCCESS)
      return null;
    let next_hwid = this._yapi.imm_getNextHardwareId(this._className, resolve.result);
    if (next_hwid == null)
      return null;
    return YNetwork.FindNetworkInContext(this._yapi, next_hwid);
  }
  static FirstNetwork() {
    let next_hwid = YAPI.imm_getFirstHardwareId("Network");
    if (next_hwid == null)
      return null;
    return YNetwork.FindNetwork(next_hwid);
  }
  static FirstNetworkInContext(yctx) {
    let next_hwid = yctx.imm_getFirstHardwareId("Network");
    if (next_hwid == null)
      return null;
    return YNetwork.FindNetworkInContext(yctx, next_hwid);
  }
};
YNetwork.READINESS_DOWN = 0;
YNetwork.READINESS_EXISTS = 1;
YNetwork.READINESS_LINKED = 2;
YNetwork.READINESS_LAN_OK = 3;
YNetwork.READINESS_WWW_OK = 4;
YNetwork.READINESS_INVALID = -1;
YNetwork.MACADDRESS_INVALID = YAPI.INVALID_STRING;
YNetwork.IPADDRESS_INVALID = YAPI.INVALID_STRING;
YNetwork.SUBNETMASK_INVALID = YAPI.INVALID_STRING;
YNetwork.ROUTER_INVALID = YAPI.INVALID_STRING;
YNetwork.CURRENTDNS_INVALID = YAPI.INVALID_STRING;
YNetwork.IPCONFIG_INVALID = YAPI.INVALID_STRING;
YNetwork.PRIMARYDNS_INVALID = YAPI.INVALID_STRING;
YNetwork.SECONDARYDNS_INVALID = YAPI.INVALID_STRING;
YNetwork.NTPSERVER_INVALID = YAPI.INVALID_STRING;
YNetwork.USERPASSWORD_INVALID = YAPI.INVALID_STRING;
YNetwork.ADMINPASSWORD_INVALID = YAPI.INVALID_STRING;
YNetwork.HTTPPORT_INVALID = YAPI.INVALID_UINT;
YNetwork.HTTPSPORT_INVALID = YAPI.INVALID_UINT;
YNetwork.SECURITYMODE_UNDEFINED = 0;
YNetwork.SECURITYMODE_LEGACY = 1;
YNetwork.SECURITYMODE_MIXED = 2;
YNetwork.SECURITYMODE_SECURE = 3;
YNetwork.SECURITYMODE_INVALID = -1;
YNetwork.DEFAULTPAGE_INVALID = YAPI.INVALID_STRING;
YNetwork.DISCOVERABLE_FALSE = 0;
YNetwork.DISCOVERABLE_TRUE = 1;
YNetwork.DISCOVERABLE_INVALID = -1;
YNetwork.WWWWATCHDOGDELAY_INVALID = YAPI.INVALID_UINT;
YNetwork.CALLBACKURL_INVALID = YAPI.INVALID_STRING;
YNetwork.CALLBACKMETHOD_POST = 0;
YNetwork.CALLBACKMETHOD_GET = 1;
YNetwork.CALLBACKMETHOD_PUT = 2;
YNetwork.CALLBACKMETHOD_INVALID = -1;
YNetwork.CALLBACKENCODING_FORM = 0;
YNetwork.CALLBACKENCODING_JSON = 1;
YNetwork.CALLBACKENCODING_JSON_ARRAY = 2;
YNetwork.CALLBACKENCODING_CSV = 3;
YNetwork.CALLBACKENCODING_YOCTO_API = 4;
YNetwork.CALLBACKENCODING_JSON_NUM = 5;
YNetwork.CALLBACKENCODING_EMONCMS = 6;
YNetwork.CALLBACKENCODING_AZURE = 7;
YNetwork.CALLBACKENCODING_INFLUXDB = 8;
YNetwork.CALLBACKENCODING_MQTT = 9;
YNetwork.CALLBACKENCODING_YOCTO_API_JZON = 10;
YNetwork.CALLBACKENCODING_PRTG = 11;
YNetwork.CALLBACKENCODING_INFLUXDB_V2 = 12;
YNetwork.CALLBACKENCODING_INVALID = -1;
YNetwork.CALLBACKTEMPLATE_OFF = 0;
YNetwork.CALLBACKTEMPLATE_ON = 1;
YNetwork.CALLBACKTEMPLATE_INVALID = -1;
YNetwork.CALLBACKCREDENTIALS_INVALID = YAPI.INVALID_STRING;
YNetwork.CALLBACKINITIALDELAY_INVALID = YAPI.INVALID_UINT;
YNetwork.CALLBACKSCHEDULE_INVALID = YAPI.INVALID_STRING;
YNetwork.CALLBACKMINDELAY_INVALID = YAPI.INVALID_UINT;
YNetwork.CALLBACKMAXDELAY_INVALID = YAPI.INVALID_UINT;
YNetwork.POECURRENT_INVALID = YAPI.INVALID_UINT;

// obj/full/Api/yocto_files.js
var YFileRecord = class {
  constructor(str_json) {
    this._name = "";
    this._size = 0;
    this._crc = 0;
    const loadval = JSON.parse(str_json);
    this._name = loadval.name;
    this._size = loadval.size;
    this._crc = loadval.crc;
  }
  get_name() {
    return this._name;
  }
  get_size() {
    return this._size;
  }
  get_crc() {
    return this._crc;
  }
};
var YFiles = class extends YFunction {
  constructor(yapi, func) {
    super(yapi, func);
    this._filesCount = YFiles.FILESCOUNT_INVALID;
    this._freeSpace = YFiles.FREESPACE_INVALID;
    this._valueCallbackFiles = null;
    this.FILESCOUNT_INVALID = YAPI.INVALID_UINT;
    this.FREESPACE_INVALID = YAPI.INVALID_UINT;
    this._className = "Files";
  }
  imm_parseAttr(name, val) {
    switch (name) {
      case "filesCount":
        this._filesCount = val;
        return 1;
      case "freeSpace":
        this._freeSpace = val;
        return 1;
    }
    return super.imm_parseAttr(name, val);
  }
  async get_filesCount() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YFiles.FILESCOUNT_INVALID;
      }
    }
    res = this._filesCount;
    return res;
  }
  async get_freeSpace() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YFiles.FREESPACE_INVALID;
      }
    }
    res = this._freeSpace;
    return res;
  }
  static FindFiles(func) {
    let obj;
    obj = YFunction._FindFromCache("Files", func);
    if (obj == null) {
      obj = new YFiles(YAPI, func);
      YFunction._AddToCache("Files", func, obj);
    }
    return obj;
  }
  static FindFilesInContext(yctx, func) {
    let obj;
    obj = YFunction._FindFromCacheInContext(yctx, "Files", func);
    if (obj == null) {
      obj = new YFiles(yctx, func);
      YFunction._AddToCache("Files", func, obj);
    }
    return obj;
  }
  async registerValueCallback(callback) {
    let val;
    if (callback != null) {
      await YFunction._UpdateValueCallbackList(this, true);
    } else {
      await YFunction._UpdateValueCallbackList(this, false);
    }
    this._valueCallbackFiles = callback;
    if (callback != null && await this.isOnline()) {
      val = this._advertisedValue;
      if (!(val == "")) {
        await this._invokeValueCallback(val);
      }
    }
    return 0;
  }
  async _invokeValueCallback(value) {
    if (this._valueCallbackFiles != null) {
      try {
        await this._valueCallbackFiles(this, value);
      } catch (e) {
        this._yapi.imm_log("Exception in valueCallback:", e);
      }
    } else {
      await super._invokeValueCallback(value);
    }
    return 0;
  }
  async sendCommand(command) {
    let url;
    url = "files.json?a=" + command;
    return await this._download(url);
  }
  async format_fs() {
    let json;
    let res;
    json = await this.sendCommand("format");
    res = this.imm_json_get_key(json, "res");
    if (!(res == "ok")) {
      return this._throw(this._yapi.IO_ERROR, "format failed", this._yapi.IO_ERROR);
    }
    return this._yapi.SUCCESS;
  }
  async get_list(pattern) {
    let json;
    let filelist = [];
    let res = [];
    json = await this.sendCommand("dir&f=" + pattern);
    filelist = this.imm_json_get_array(json);
    res.length = 0;
    for (let ii in filelist) {
      res.push(new YFileRecord(this._yapi.imm_bin2str(filelist[ii])));
    }
    return res;
  }
  async fileExist(filename) {
    let json;
    let filelist = [];
    if (filename.length == 0) {
      return false;
    }
    json = await this.sendCommand("dir&f=" + filename);
    filelist = this.imm_json_get_array(json);
    if (filelist.length > 0) {
      return true;
    }
    return false;
  }
  async download(pathname) {
    return await this._download(pathname);
  }
  async upload(pathname, content) {
    return await this._upload(pathname, content);
  }
  async remove(pathname) {
    let json;
    let res;
    json = await this.sendCommand("del&f=" + pathname);
    res = this.imm_json_get_key(json, "res");
    if (!(res == "ok")) {
      return this._throw(this._yapi.IO_ERROR, "unable to remove file", this._yapi.IO_ERROR);
    }
    return this._yapi.SUCCESS;
  }
  nextFiles() {
    let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
    if (resolve.errorType != YAPI.SUCCESS)
      return null;
    let next_hwid = this._yapi.imm_getNextHardwareId(this._className, resolve.result);
    if (next_hwid == null)
      return null;
    return YFiles.FindFilesInContext(this._yapi, next_hwid);
  }
  static FirstFiles() {
    let next_hwid = YAPI.imm_getFirstHardwareId("Files");
    if (next_hwid == null)
      return null;
    return YFiles.FindFiles(next_hwid);
  }
  static FirstFilesInContext(yctx) {
    let next_hwid = yctx.imm_getFirstHardwareId("Files");
    if (next_hwid == null)
      return null;
    return YFiles.FindFilesInContext(yctx, next_hwid);
  }
};
YFiles.FILESCOUNT_INVALID = YAPI.INVALID_UINT;
YFiles.FREESPACE_INVALID = YAPI.INVALID_UINT;

// obj/full/constants.js
var constants = class {
  static get buildVersion() {
    return "1.10.63744";
  }
  static get deviceScreenWidth() {
    return screen.width * window.devicePixelRatio;
  }
  static get deviceScreenHeight() {
    return screen.height * window.devicePixelRatio;
  }
  static get isPhoneOrTablet() {
    return constants.ScreenDPI > 96 && Math.max(constants.deviceScreenWidth, constants.deviceScreenHeight) / constants.ScreenDPI < 12;
  }
  static get captureSizePolicy() {
    return constants._defaultCaptureSizePolicy;
  }
  static set captureSizePolicy(value) {
    constants._defaultCaptureSizePolicy = value;
  }
  static get dbleClickBringsUpContextMenu() {
    return constants._defaulDbleClickBringsUpContextMenu;
  }
  static set dbleClickBringsUpContextMenu(value) {
    constants._defaulDbleClickBringsUpContextMenu = value;
  }
  static get maxPointsPerGraphSerie() {
    return constants._defaultMaxPointsPerGraphSerie;
  }
  static set maxPointsPerGraphSerie(value) {
    if (value >= 0)
      constants._defaultMaxPointsPerGraphSerie = value >> 0;
  }
  static get maxPointsPerDataloggerSerie() {
    return constants._defaultMaxPointsPerDataloggerSerie;
  }
  static set maxPointsPerDataloggerSerie(value) {
    if (value >= -1)
      constants._defaultMaxPointsPerDataloggerSerie = value >> 0;
  }
  static get maxDataRecordsPerSensor() {
    return constants._defaultMaxDataRecordsPerSensor;
  }
  static set maxDataRecordsPerSensor(value) {
    if (value >= 0)
      constants._defaultMaxDataRecordsPerSensor = value >> 0;
  }
  static get captureWidth() {
    return constants._defaultCaptureWidth;
  }
  static set captureWidth(value) {
    if (value > 0)
      constants._defaultCaptureWidth = value;
  }
  static get captureHeight() {
    return constants._defaultCaptureHeight;
  }
  static set captureHeight(value) {
    if (value > 0)
      constants._defaultCaptureHeight = value;
  }
  static get captureDPI() {
    return constants._defaultCaptureDPI;
  }
  static set captureDPI(value) {
    if (value > 0)
      constants._defaultCaptureDPI = value;
  }
  static get captureType() {
    return constants._defaultCaptureType;
  }
  static set captureType(value) {
    constants._defaultCaptureType = value;
  }
  static get generalFontFamily() {
    return constants.FontFamily;
  }
  static get generalFontSize() {
    return constants.FontSize;
  }
  static get generalSizeCoef() {
    return constants.FontSize / 12;
  }
  static get screenDPI() {
    return constants.ScreenDPI;
  }
  static get guiDPIFactor() {
    return constants.DPIfactor;
  }
  static get guiDPIFactorWasOverriden() {
    return constants.DPIfactorOverriden;
  }
  static get guiDPIFactorIsOverriden() {
    let vs = constants.getCookie(constants.DPIFactorKey);
    if (vs == null)
      return false;
    let v = parseFloat(vs);
    if (v > 0)
      return true;
    return false;
  }
  static get guiDPIFactorOverrideValue() {
    let vs = constants.getCookie(constants.DPIFactorKey);
    if (vs == null)
      return constants.DPIfactor;
    let v = parseFloat(vs);
    if (v > 0)
      return v;
    return constants.DPIfactor;
  }
  static overrideGuiDPIFactor(override, value) {
    if (override && typeof value !== "undefined") {
      constants.setCookie(constants.DPIFactorKey, value.toString(), 3650);
    } else {
      constants.setCookie(constants.DPIFactorKey, "none", 3650);
    }
  }
  static get RunningOnAndroid() {
    return constants.isAndroid;
  }
  static get WindowBackgroundColor() {
    return "#f0f0f0";
  }
  static get WindowBorder() {
    return "1px solid #808080";
  }
  static get WindowPadding() {
    return 2;
  }
  static get WindowInnerBorderColor() {
    return " #A0A0A0";
  }
  static get WindowInnerBackgroundColor() {
    return "#fAfAfA";
  }
  static get WindowInnerBorder() {
    return "1px solid " + constants.WindowInnerBorderColor;
  }
  static get WindowHeaderBackgroundColor() {
    return "#0072ca";
  }
  static get WindowHeaderColor() {
    return "white";
  }
  static get WindowHeaderBorder() {
    return "1px solid #0072ca";
  }
  static get WindowHeaderHeight() {
    return 20;
  }
  static get WindowHeaderFontSize() {
    return 8 * constants.FontSize / 6;
  }
  static get WindowHeaderFontFamily() {
    return constants.FontFamily;
  }
  static get mustCheckForUpdate() {
    return constants._checkForUpdate;
  }
  static set mustCheckForUpdate(value) {
    if (value != constants._checkForUpdate) {
      constants._checkForUpdate = value;
      constants.edited = true;
    }
  }
  static get edited() {
    return constants._edited;
  }
  static set edited(value) {
    if (constants._edited != value) {
      constants._edited = value;
      YWebPage.ShowSaveReminder(value);
    }
  }
  static InitColorHistory(node) {
    let nodes = node.get_childsByIndex();
    for (let i = 0; i < nodes.length; i++) {
      let node2 = nodes[i];
      switch (nodes[i].Name) {
        case "Color":
          try {
            let colordef = node2.Attributes["value"];
            let color = YColor.FromString(colordef);
            if (color != null)
              colorEditor.AddColorToHistory(color);
          } catch (_a) {
          }
      }
    }
  }
  static findDPI() {
    let DPI = 1;
    while (!matchMedia("(max-resolution: " + DPI.toString() + "dpi)").matches) {
      DPI = DPI << 1;
    }
    let a = DPI >> 1;
    let b = DPI;
    while (b - a > 1) {
      let pivot = b + a >> 1;
      if (matchMedia("(max-resolution: " + pivot.toString() + "dpi)").matches) {
        b = pivot;
      } else {
        a = pivot;
      }
    }
    return b * (constants.isAndroid ? window.devicePixelRatio : 1);
  }
  static InitCaptureParams(node) {
    let nodes = node.get_childsByName();
    for (let nodeName in nodes) {
      let node2 = nodes[nodeName];
      let value;
      switch (nodeName) {
        case "Target":
          if ("value" in node2.Attributes) {
            constants._captureTarget = YDataRenderer.CaptureTarget.fromString(YDataRenderer.CaptureTarget, node2.Attributes["value"]);
          }
          break;
        case "Type":
          if ("value" in node2.Attributes) {
            constants._defaultCaptureType = YDataRenderer.CaptureType.fromString(YDataRenderer.CaptureType, node2.Attributes["value"]);
          }
          break;
        case "Size":
          if ("value" in node2.Attributes) {
            constants._defaultCaptureSizePolicy = YDataRenderer.CaptureFormats.fromString(YDataRenderer.CaptureFormats, node2.Attributes["value"]);
          }
          break;
        case "Resolution":
          if ("value" in node2.Attributes) {
            constants.captureDPI = parseInt(node2.Attributes["value"]);
          }
          break;
        case "Width":
          if ("value" in node2.Attributes) {
            constants.captureWidth = value = parseInt(node2.Attributes["value"]);
          }
          break;
        case "Height":
          if ("value" in node2.Attributes) {
            constants.captureHeight = parseInt(node2.Attributes["value"]);
          }
          break;
        case "Folder":
          if ("value" in node2.Attributes) {
            constants._captureFolder = node2.Attributes["value"];
          }
          break;
      }
    }
  }
  static InitUIParams(node) {
    let nodes = node.get_childsByName();
    for (let nodeName in nodes) {
      let node2 = nodes[nodeName];
      switch (nodeName) {
        case "VerticalDragZoom":
          if ("value" in node2.Attributes) {
            YGraph.verticalDragZoomEnabled = node2.Attributes["value"].toUpperCase() == "TRUE";
          }
          break;
        case "DbleClickContextMenu":
          if ("value" in node2.Attributes) {
            constants.dbleClickBringsUpContextMenu = node2.Attributes["value"].toUpperCase() == "TRUE";
          }
          break;
      }
    }
  }
  static InitCheckForUpdateParams(node) {
    let nodes = node.get_childsByName();
    for (let nodeName in nodes) {
      let node2 = nodes[nodeName];
      switch (nodeName) {
        case "checkForUpdate":
          if ("value" in node2.Attributes) {
            constants._checkForUpdate = node2.Attributes["value"].toUpperCase() == "TRUE";
          }
          break;
        case "ignoreBuild":
          if ("value" in node2.Attributes) {
            constants._ignoreBuild = parseInt(node2.Attributes["value"].toUpperCase());
          }
          break;
      }
    }
  }
  static InitMemoryUsageParams(node) {
    let nodes = node.get_childsByName();
    for (let nodeName in nodes) {
      let node2 = nodes[nodeName];
      switch (nodeName) {
        case "maxPointsPerGraphSerie":
          if ("value" in node2.Attributes) {
            let value = parseInt(node2.Attributes["value"]);
            constants.maxPointsPerGraphSerie = value;
            DataSerie.MaxPointsPerSeries = value;
          }
          break;
        case "maxDataRecordsPerSensor":
          if ("value" in node2.Attributes) {
            let value = parseInt(node2.Attributes["value"]);
            if (value >= 0) {
              constants.maxDataRecordsPerSensor = value;
              CustomYSensor.MaxDataRecords = value;
            }
          }
          break;
        case "maxPointsPerDataloggerSerie":
          if ("value" in node2.Attributes) {
            let value = parseInt(node2.Attributes["value"]);
            constants.maxPointsPerDataloggerSerie = value;
            CustomYSensor.MaxLoggerRecords = value;
          }
          break;
        case "deviceListValidity":
          if ("value" in node2.Attributes) {
            let value = parseInt(node2.Attributes["value"]);
            if (value > 0) {
              constants._deviceListValidity = value;
              YAPI.SetDeviceListValidity(value).then();
            }
          }
          break;
      }
    }
  }
  static Init(initData) {
    let nodes = initData.get_childsByName();
    for (let nodeName in nodes) {
      let node = nodes[nodeName];
      switch (nodeName) {
        case "UseUSB":
          if ("value" in node.Attributes) {
            constants._useUSB = node.Attributes["value"].toUpperCase() == "TRUE";
          }
          break;
        case "Colors":
          constants.InitColorHistory(node);
          break;
        case "Capture":
          constants.InitCaptureParams(node);
          break;
        case "UI":
          constants.InitUIParams(node);
          break;
        case "Updates":
          constants.InitCheckForUpdateParams(node);
          break;
        case "MemoryUsage":
          constants.InitMemoryUsageParams(node);
          break;
        case "UseVirtualHub":
          if ("value" in node.Attributes) {
            constants._useVirtualHub = node.Attributes["value"].toUpperCase() == "TRUE";
          }
          break;
        case "Hubs":
          sensorsManager.InitHubList(node);
          break;
      }
    }
  }
  static get CRCTable() {
    if (constants._crcTable != null)
      return constants._crcTable;
    constants._crcTable = [];
    let c;
    var crcTable = [];
    for (var n = 0; n < 256; n++) {
      c = n;
      for (var k = 0; k < 8; k++) {
        c = c & 1 ? 3988292384 ^ c >>> 1 : c >>> 1;
      }
      constants._crcTable[n] = c;
    }
    return constants._crcTable;
  }
  static crc32(str) {
    var crcTable = constants.CRCTable;
    var crc = 0 ^ -1;
    for (var i = 0; i < str.length; i++) {
      crc = crc >>> 8 ^ crcTable[(crc ^ str.charCodeAt(i)) & 255];
    }
    return (crc ^ -1) >>> 0;
  }
  static setCookie(cname, cvalue, exdays) {
    let d = new Date();
    d.setTime(d.getTime() + exdays * 24 * 60 * 60 * 1e3);
    let expires = "expires=" + d.toUTCString();
    document.cookie = cname + "=" + cvalue + ";" + expires + ";path=/";
  }
  static getCookie(cname) {
    let name = cname + "=";
    let decodedCookie = decodeURIComponent(document.cookie);
    let ca = decodedCookie.split(";");
    for (let i = 0; i < ca.length; i++) {
      let c = ca[i];
      while (c.charAt(0) == " ") {
        c = c.substring(1);
      }
      if (c.indexOf(name) == 0) {
        return c.substring(name.length, c.length);
      }
    }
    return null;
  }
  static XMLquote(st) {
    return st.replace("'", "&apos;").replace('"', "&quot;");
  }
  static GetXMLConfiguration() {
    let res = '<Config>\n  <UseUSB value="' + (constants._useUSB ? "TRUE" : "FALSE") + '"/>\n  <UseVirtualHub value="' + (constants._useVirtualHub ? "TRUE" : "FALSE") + '"/>\n  <Hubs>\n';
    res += sensorsManager.getXmlHublist();
    res += "  </Hubs>\n";
    res += "  <Colors>\n";
    for (let i = 0; i < colorEditor.colorHistory.length; i++) {
      res = res + '    <Color value="' + colorEditor.colorHistory[i].toString() + '"/>\n';
    }
    res += "  </Colors>\n";
    res += "  <MemoryUsage>\n";
    res += '    <maxPointsPerGraphSerie value= "' + constants.maxPointsPerGraphSerie.toString() + '"/>\n';
    res += '    <maxDataRecordsPerSensor value= "' + constants.maxDataRecordsPerSensor.toString() + '"/>\n';
    res += '    <maxPointsPerDataloggerSerie value= "' + constants.maxPointsPerDataloggerSerie.toString() + '"/>\n';
    res += '    <deviceListValidity value= "' + constants._deviceListValidity.toString() + '"/>\n';
    res += "  </MemoryUsage>\n";
    res += "  <Capture>\n";
    res += '    <Target value= "' + constants._captureTarget.toString + '"/>\n';
    res += '    <Type value= "' + constants.captureType.toString + '"/>\n';
    res += '    <Size value= "' + constants.captureSizePolicy.toString + '"/>\n';
    res += '    <Resolution value= "' + constants.captureDPI.toString() + '"/>\n';
    res += '    <Folder value= "' + constants.XMLquote(constants._captureFolder) + '"/>\n';
    res += '    <Width value= "' + constants.captureWidth.toString() + '"/>\n';
    res += '    <Height value= "' + constants.captureHeight.toString() + '"/>\n';
    res += "  </Capture>\n";
    res += "  <Updates>\n";
    res += '    <checkForUpdate  value = "' + (constants._checkForUpdate ? "True" : "False") + '"/>\n';
    res += '    <ignoreBuild  value = "' + constants._ignoreBuild.toString() + '"/>\n';
    res += "  </Updates>\n";
    res += "  <UI>\n";
    res += '    <VerticalDragZoom value= "' + (YGraph.verticalDragZoomEnabled ? "True" : "False") + '"/>\n';
    res += '    <DbleClickContextMenu value= "' + (constants.dbleClickBringsUpContextMenu ? "True" : "False") + '"/>\n';
    res += "  </UI>\n";
    res += "</Config>\n";
    return res;
  }
};
constants.DPIFactorKey = "YoctoVisualization4WebDPIFactor";
constants.isAndroid = navigator.userAgent.toLowerCase().indexOf("android") >= 0;
constants.ScreenDPI = constants.findDPI();
constants.FontFamily = "Arial, Helvetica, sans-serif";
constants.DPIfactorCookieValue = constants.getCookie(constants.DPIFactorKey);
constants.DPIfactorOverriden = constants.DPIfactorCookieValue != null;
constants.DPIfactor = constants.DPIfactorOverriden && parseFloat(constants.DPIfactorCookieValue) > 0 ? parseFloat(constants.DPIfactorCookieValue) : constants.isPhoneOrTablet ? Math.round(10 * constants.ScreenDPI / (96 * 1.2)) / 10 : 1;
constants.FontSize = 12 * constants.DPIfactor;
constants._defaultCaptureType = YDataRenderer.CaptureType.PNG;
constants._defaultCaptureWidth = 1024;
constants._defaultCaptureHeight = 1024;
constants._defaultCaptureDPI = 70;
constants._defaultCaptureSizePolicy = YDataRenderer.CaptureFormats.Keep;
constants._defaultMaxPointsPerGraphSerie = 0;
constants._defaultMaxPointsPerDataloggerSerie = 0;
constants._defaultMaxDataRecordsPerSensor = 0;
constants._defaulDbleClickBringsUpContextMenu = false;
constants._useUSB = true;
constants._useVirtualHub = false;
constants._captureTarget = YDataRenderer.CaptureTarget.ToFile;
constants._captureFolder = "";
constants._checkForUpdate = true;
constants._ignoreBuild = 0;
constants._deviceListValidity = 3600;
constants._edited = false;
constants._crcTable = null;

// obj/full/sensorManager.js
var Hub = class {
  static Decrypt(data, loginCypherPassword) {
    if (data == "")
      return "";
    if (data.length % 4)
      return "";
    let buffer = new Uint16Array(data.length >> 2);
    for (let i = 0; i < buffer.length; i++) {
      buffer[i] = parseInt(data.slice(i * 4, i * 4 + 4), 16);
    }
    let checksum = buffer[0];
    for (let i = 1; i < buffer.length - 1; i++) {
      checksum ^= buffer[i];
    }
    if (checksum != buffer[buffer.length - 1])
      return "";
    let res = "";
    for (let i = 0; i < buffer.length - 2; i++) {
      res += String.fromCharCode(buffer[i + 1] & 255 ^ loginCypherPassword.charCodeAt(i % loginCypherPassword.length) ^ buffer[0] + i & 255 ^ (buffer[i + 1] & 2048) >> 11 << ((buffer[i + 1] & 1792) >> 8) ^ (buffer[i + 1] & 32768) >> 15 << ((buffer[i + 1] & 28672) >> 12));
    }
    return res;
  }
  static Encrypt(data, loginCypherPassword) {
    if (data == "")
      return "";
    let buffer = crypto.getRandomValues(new Uint16Array(data.length + 2));
    for (let i = 0; i < data.length; i++) {
      buffer[i + 1] = buffer[i + 1] & 65280 | data.charCodeAt(i) ^ loginCypherPassword.charCodeAt(i % loginCypherPassword.length) ^ buffer[0] + i & 255 ^ (buffer[i + 1] & 2048) >> 11 << ((buffer[i + 1] & 1792) >> 8) ^ (buffer[i + 1] & 32768) >> 15 << ((buffer[i + 1] & 28672) >> 12);
    }
    buffer[buffer.length - 1] = buffer[0];
    for (let i = 1; i < buffer.length - 1; i++) {
      buffer[buffer.length - 1] ^= buffer[i];
    }
    let res = "";
    for (let i = 0; i < buffer.length; i++) {
      res += ("000" + buffer[i].toString(16)).slice(-4).toUpperCase();
    }
    return res;
  }
  static encryptPassword(clearPassword) {
    return clearPassword == "" ? "" : Hub.Encrypt(clearPassword, Hub.loginCypherPassword);
  }
  get hubType() {
    return this._hubType;
  }
  set hubType(value) {
    this._hubType = value;
  }
  get protocol() {
    return this._protocol;
  }
  set protocol(value) {
    this._protocol = value;
  }
  get user() {
    return this._user;
  }
  set user(value) {
    this._user = value;
  }
  get encryptedPassword() {
    return this._password;
  }
  set encryptedPassword(value) {
    this._password = value;
  }
  get clearPassword() {
    return this._password == "" ? "" : Hub.Decrypt(this._password, Hub.loginCypherPassword);
  }
  set clearPassword(value) {
    this._password = value == "" ? "" : Hub.encryptPassword(value);
  }
  get addr() {
    return this._addr;
  }
  set addr(value) {
    this._addr = value;
  }
  get port() {
    return this._port;
  }
  set port(value) {
    this._port = value;
  }
  get removable() {
    return this._removable;
  }
  set removable(value) {
    this._removable = value;
  }
  get path() {
    return this._path;
  }
  set path(value) {
    this._path = value;
  }
  get ConnectionState() {
    return this._state;
  }
  get ConnectionDescription() {
    switch (this._state) {
      case 1:
        return "Connecting..";
      case 2:
        return (this._logicname != "" ? this._logicname : this._netname) + " OK";
      case 3:
        return "Connection failed ";
      default:
        return "Not connected.";
    }
  }
  constructor(hubType, protocol, user, password, clearPassword, addr, port, path, removeable) {
    this._netname = "";
    this._module = null;
    this._logicname = "";
    this._previousURL = "";
    this._previousobfuscatedURL = "";
    this._hubType = 2;
    this._protocol = "";
    this._user = "";
    this._password = "";
    this._addr = "";
    this._port = "";
    this._removable = true;
    this._path = "";
    this._state = 0;
    while (/^\//.test(path)) {
      path = path.slice(1);
    }
    while (/\/$/.test(path)) {
      path = path.slice(0, -1);
    }
    this._hubType = hubType;
    this._protocol = protocol;
    this._user = user;
    this._port = port;
    this._password = clearPassword ? password != "" ? Hub.Encrypt(password, Hub.loginCypherPassword) : "" : password;
    this._addr = addr;
    this._path = path;
    this._removable = typeof removeable === "undefined" ? true : removeable;
  }
  static HubFromXml(subnode) {
    let hubType = 2;
    let protocol = "ws";
    let removable = true;
    if ("protocol" in subnode.Attributes)
      protocol = subnode.Attributes["protocol"];
    let user = "";
    if ("user" in subnode.Attributes)
      user = subnode.Attributes["user"];
    let password = "";
    if ("password" in subnode.Attributes)
      password = subnode.Attributes["password"];
    let port = "";
    if ("port" in subnode.Attributes)
      port = subnode.Attributes["port"];
    let path = "";
    if ("path" in subnode.Attributes)
      path = subnode.Attributes["path"];
    let addr = "";
    if ("addr" in subnode.Attributes)
      addr = subnode.Attributes["addr"];
    if ("removable" in subnode.Attributes)
      removable = subnode.Attributes["removable"].toUpperCase() == "TRUE";
    return new Hub(hubType, protocol, user, password, false, addr, port, path, removable);
  }
  async Connect() {
    let errmsg = new YErrorMsg();
    this._state = 1;
    logForm.log("preregistering  " + this.get_obfuscatedURL());
    if (!YWebPage.readonly)
      configForm.hubStateChanged(this);
    let url = this.get_fullUrl();
    if (await YAPI.PreregisterHub(url, errmsg) != YAPI_SUCCESS) {
      logForm.log("[!] preregistering  " + this.get_obfuscatedURL() + " failed (" + errmsg.msg + ")");
      this._state = 3;
      this._previousURL = "";
      this._previousobfuscatedURL = "";
    } else {
      this._previousURL = url;
      this._previousobfuscatedURL = this.get_obfuscatedURL();
    }
    if (!YWebPage.readonly)
      configForm.hubStateChanged(this);
  }
  async Disconnect() {
    if (this._previousURL == "")
      return;
    logForm.log("Unregistering  " + this._previousobfuscatedURL);
    await YAPI.UnregisterHub(this._previousURL);
    this._previousURL = "";
    this._previousobfuscatedURL = "";
    this._state = 0;
    if (!YWebPage.readonly)
      configForm.hubStateChanged(this);
  }
  arrival(ip, netname, module, logicname) {
    this._state = 2;
    this._netname = netname;
    this._module = module;
    this._logicname = logicname;
    this._state = 2;
    if (!YWebPage.readonly) {
      configForm.hubStateChanged(this);
    }
  }
  get address() {
    return this._addr;
  }
  get_consoleUrl() {
    let fullurl = this._protocol + "://" + this._addr;
    if (this._port != "")
      fullurl = fullurl + ":" + this._port;
    return fullurl;
  }
  toString() {
    return this.get_consoleUrl();
  }
  get_fullUrl() {
    let fullurl = "";
    if (this._protocol != "")
      fullurl = this._protocol + "://";
    if (this._user != "") {
      fullurl = fullurl + this._user;
      if (this._password != "")
        fullurl = fullurl + ":" + Hub.Decrypt(this._password, Hub.loginCypherPassword);
      fullurl = fullurl + "@";
    }
    fullurl = fullurl + this._addr;
    if (this._port != "")
      fullurl = fullurl + ":" + this._port;
    else
      fullurl = fullurl + ":4444";
    fullurl = fullurl + "/";
    if (this._path) {
      fullurl = fullurl + this._path + "/";
    }
    return fullurl;
  }
  get_connexionUrl() {
    let fullurl;
    if (this._protocol != "")
      fullurl = this._protocol + "://";
    else
      fullurl = "ws://";
    fullurl = fullurl + this._addr;
    if (this._port != "")
      fullurl = fullurl + ":" + this._port;
    else
      fullurl = fullurl + ":4444";
    fullurl = fullurl + "/";
    return fullurl.toLowerCase();
  }
  get_obfuscatedURL() {
    let fullurl = "";
    if (this._protocol != "")
      fullurl = this._protocol + "://";
    if (this._user != "") {
      fullurl = fullurl + this._user;
      if (this._password != "")
        fullurl = fullurl + ":#####";
      fullurl = fullurl + "@";
    }
    fullurl = fullurl + this._addr;
    if (this._port != "")
      fullurl = fullurl + ":" + this._port;
    if (this._path != "")
      fullurl = fullurl + "/" + this._path;
    return fullurl;
  }
  XmlCode() {
    let NodeLine = "<Hub ";
    if (this._protocol != "")
      NodeLine = NodeLine + 'protocol="' + constants.XMLquote(this._protocol) + '" ';
    if (this._user != "")
      NodeLine = NodeLine + 'user="' + constants.XMLquote(this._user) + '" ';
    if (this._password != "")
      NodeLine = NodeLine + 'password="' + constants.XMLquote(this._password) + '" ';
    NodeLine = NodeLine + 'addr="' + constants.XMLquote(this._addr) + '" ';
    if (this._port != "")
      NodeLine = NodeLine + 'port="' + constants.XMLquote(this.port) + '" ';
    if (this._path != "")
      NodeLine = NodeLine + 'path="' + constants.XMLquote(this._path) + '" ';
    if (!this._removable)
      NodeLine = NodeLine + 'removable="FALSE" ';
    return NodeLine + "/>";
  }
};
Hub.loginCypherPassword = "+>*X[?_ih$N7wA!}";
var TimedSensorValue = class {
  constructor(DateTime, value) {
    this._DateTime = DateTime;
    this._value = value;
  }
  get DateTime() {
    return this._DateTime;
  }
  get value() {
    return this._value;
  }
};
var AlarmSettings = class {
  static ExecuteCommand(source, command) {
  }
  constructor(index, owner, xmldata) {
    this.index = 0;
    this.Condition = 0;
    this.Source = 0;
    this.Value = 0;
    this.Delay = 15;
    this.Commandline = "";
    this.lastAlarm = new Date(0);
    this.index = index;
    this.parent = owner;
    if (typeof xmldata !== "undefined") {
      if ("Source" in xmldata.Attributes)
        this.Source = parseInt(xmldata.Attributes["Source"]);
      if ("Condition" in xmldata.Attributes)
        this.Condition = parseInt(xmldata.Attributes["Condition"]);
      if ("Value" in xmldata.Attributes)
        this.Value = parseFloat(xmldata.Attributes["Value"]);
      if ("Cmd" in xmldata.Attributes)
        this.Commandline = xmldata.Attributes["Cmd"];
      if ("Delay" in xmldata.Attributes)
        this.Delay = parseInt(xmldata.Attributes["Delay"]);
    }
  }
  getXmlData() {
    return '<Alarm Source="' + this.Source.toString() + '" Condition="' + this.Condition.toString() + '" Value="' + this.Value.toString() + '" Cmd="' + GenericProperties.escapeXml(this.Commandline) + '" Delay="' + this.Delay.toString() + '"/>\n';
  }
  setCondition(condition) {
    this.Condition = condition;
  }
  getCondition() {
    return this.Condition;
  }
  setSource(source) {
    this.Source = source;
  }
  getSource() {
    return this.Source;
  }
  setValue(value) {
    this.Value = value;
  }
  getValue() {
    return this.Value;
  }
  setDelay(value) {
    if (value < 0)
      throw "delay must be a positive value";
    this.Delay = value;
  }
  getDelay() {
    return this.Delay;
  }
  setCommandline(value) {
    this.Commandline = value;
  }
  getCommandline() {
    return this.Commandline;
  }
  check(m) {
    let alarm = false;
    let reason = "";
    let src;
    let SensorValue;
    switch (this.Source) {
      case 1:
        src = "MIN";
        SensorValue = m.get_minValue();
        break;
      case 2:
        src = "MAX";
        SensorValue = m.get_maxValue();
        break;
      default:
        src = "AVG";
        SensorValue = m.get_averageValue();
        break;
    }
    switch (this.Condition) {
      default:
        return;
      case 1:
        reason = ">";
        if (SensorValue > this.Value)
          alarm = true;
        break;
      case 2:
        reason = ">=";
        if (SensorValue >= this.Value)
          alarm = true;
        break;
      case 3:
        reason = "=";
        if (SensorValue == this.Value)
          alarm = true;
        break;
      case 4:
        reason = "<=";
        if (SensorValue <= this.Value)
          alarm = true;
        break;
      case 5:
        reason = "<";
        if (SensorValue < this.Value)
          alarm = true;
        break;
    }
    let now = new Date();
    if (!alarm)
      return;
    if (now.getTime() - this.lastAlarm.getTime() < 1e3 * this.Delay)
      return;
    let source = "ALARM " + (this.index + 1).toString();
    logForm.log(source + " on " + this.parent.get_hardwareId() + "/" + this.parent.get_friendlyName() + " (" + SensorValue.toString() + reason + this.Value.toString() + ")");
    let Execute = this.Commandline;
    Execute = Execute.replace("$SENSORVALUE$", SensorValue.toString());
    Execute = Execute.replace("$HWDID$", this.parent.get_hardwareId());
    Execute = Execute.replace("$NAME$", this.parent.get_friendlyName());
    Execute = Execute.replace("$UNIT$", this.parent.get_unit());
    Execute = Execute.replace("$CONDITION$", reason);
    Execute = Execute.replace("$DATATYPE$", src);
    Execute = Execute.replace("$TRIGGER$", this.Value.toString());
    Execute = Execute.replace("$NOW$", logForm.dateToString(now));
    try {
      Function(Execute)();
    } catch (e) {
      logForm.log("ALARM " + (this.index + 1) + " code (" + Execute + ") caused an exception :" + e.message);
    }
    this.lastAlarm = now;
  }
};
var DataLoggerBoundary = class {
  constructor(start, stop) {
    this._start = 0;
    this._stop = 0;
    this._start = start;
    this._stop = stop;
  }
  get start() {
    return this._start;
  }
  get stop() {
    return this._stop;
  }
};
var MergeSourceRange = class {
  constructor(start, stop) {
    this.MergeSourceStart = 0;
    this.MergeSourceStop = 0;
    this.MergeSourceStart = start;
    this.MergeSourceStop = stop;
  }
};
var CustomYSensor = class {
  get isReadOnly() {
    return this._readonly || !this._online;
  }
  get dataloggerLoadisRunning() {
    return this._dataloggerLoadisRunning;
  }
  get dataloggerLoadProgress() {
    return this._dataloggerLoadProgress;
  }
  setDataloggerLoadProgress(value) {
    this._dataloggerLoadProgress = value;
    for (let i = 0; i < this.FormsToNotify.length; i++) {
      if (this.FormsToNotify[i] instanceof graphWidget) {
        this.FormsToNotify[i].dataLoggerLoadprocessIsRunningNotification(this);
      }
    }
  }
  static get MaxDataRecords() {
    return CustomYSensor._MaxDataRecords;
  }
  static set MaxDataRecords(value) {
    CustomYSensor._MaxDataRecords = value;
  }
  static get MaxLoggerRecords() {
    return CustomYSensor._MaxLoggerRecords;
  }
  static set MaxLoggerRecords(value) {
    CustomYSensor._MaxLoggerRecords = value;
  }
  get_lastAvgValue() {
    if (this._online)
      return this._lastAvgValue;
    return Number.NaN;
  }
  get_lastMaxValue() {
    if (this._online)
      return this._lastMaxValue;
    return Number.NaN;
  }
  get_lastMinValue() {
    if (this._online)
      return this._lastMinValue;
    return Number.NaN;
  }
  async ConfigHasChanged() {
    this.cfgChgNotificationsSupported = true;
    this.mustReloadConfig = true;
    this._online = true;
    await this.reloadConfig();
    await this.forceUpdate();
  }
  constructor(s, name, SensorLocalConfig) {
    this.unit = "";
    this._frequency = "";
    this.resolution = 1;
    this._recording = false;
    this._online = false;
    this.preloadDone = false;
    this.loadDone = false;
    this.cfgChgNotificationsSupported = false;
    this.mustReloadConfig = false;
    this._readonly = false;
    this._plzCancelDataloggerLoading = false;
    this._predloadProcessIsBusy = false;
    this._loadProcessIsBusy = false;
    this.lastGetConfig = 0;
    this.recordedDataLoadProgress = 0;
    this.recordedData = null;
    this.dataLoggerFeature = false;
    this.dataLoggerLoadCompleted = false;
    this.loadFailed = false;
    this.loadCanceled = false;
    this.firstLiveDataTimeStamp = 0;
    this.firstDataloggerTimeStamp = 0;
    this.lastDataTimeStamp = 0;
    this.lastDataSource = "";
    this.consecutiveBadTimeStamp = 0;
    this.minData = [];
    this.curData = [];
    this.maxData = [];
    this.previewMinData = [];
    this.previewCurData = [];
    this.previewMaxData = [];
    this._lastAvgValue = Number.NaN;
    this._lastMinValue = Number.NaN;
    this._lastMaxValue = Number.NaN;
    this._dataloggerLoadisRunning = true;
    this._dataloggerLoadProgress = 0;
    this.dataLoggerStartReadTime = 0;
    this.Alarms = [];
    this.FormsToNotify = [];
    this.sensor = s;
    this.hwdName = name;
    this._friendlyname = name;
    if (s == null)
      return;
    if (SensorLocalConfig != null) {
      let index = 0;
      let childs = SensorLocalConfig.get_childsByIndex();
      for (let i = 0; i < childs.length; i++) {
        let n = childs[i];
        if (n.Name == "Alarm") {
          this.checkAlarmIndex(index);
          this.Alarms[index] = new AlarmSettings(index, this, n);
          index++;
        }
      }
    }
  }
  checkAlarmIndex(index) {
    while (this.Alarms.length < index + 1) {
      this.Alarms.push(new AlarmSettings(this.Alarms.length, this));
    }
  }
  getAlarmCount() {
    return this.Alarms.length;
  }
  setAlarmCondition(index, condition) {
    this.checkAlarmIndex(index);
    this.Alarms[index].setCondition(condition);
  }
  getAlarmCondition(index) {
    this.checkAlarmIndex(index);
    return this.Alarms[index].getCondition();
  }
  setAlarmSource(index, source) {
    this.checkAlarmIndex(index);
    this.Alarms[index].setSource(source);
  }
  getAlarmSource(index) {
    this.checkAlarmIndex(index);
    return this.Alarms[index].getSource();
  }
  setAlarmValue(index, value) {
    this.checkAlarmIndex(index);
    this.Alarms[index].setValue(value);
  }
  getAlarmValue(index) {
    this.checkAlarmIndex(index);
    return this.Alarms[index].getValue();
  }
  setAlarmDelay(index, value) {
    this.checkAlarmIndex(index);
    this.Alarms[index].setDelay(value);
  }
  getAlarmDelay(index) {
    this.checkAlarmIndex(index);
    return this.Alarms[index].getDelay();
  }
  setAlarmCommandline(index, value) {
    this.checkAlarmIndex(index);
    this.Alarms[index].setCommandline(value);
  }
  getAlarmCommandline(index) {
    this.checkAlarmIndex(index);
    return this.Alarms[index].getCommandline();
  }
  GetXmlData() {
    let res = '<Sensor ID="' + this.get_hardwareId() + '">\n';
    for (let i = 0; i < this.getAlarmCount(); i++) {
      res = res + this.Alarms[i].getXmlData();
    }
    res = res + "</Sensor>\n";
    return res;
  }
  get_firstLiveDataTimeStamp() {
    return this.firstLiveDataTimeStamp;
  }
  get_firstDataloggerTimeStamp() {
    return this.firstDataloggerTimeStamp;
  }
  get_lastDataTimeStamp() {
    return this.lastDataTimeStamp;
  }
  async preload_DoWork(arg) {
    if (this._predloadProcessIsBusy) {
      console.log("!!! multiple datalogger load attempt");
      return;
    }
    if (this.dataLoggerLoadCompleted) {
      console.log("!!!  datalogger load attempt although datalogger is already loaded.");
      return;
    }
    this._predloadProcessIsBusy = true;
    logForm.log(this.hwdName + ": preloading data from " + arg.start.toString() + " to " + arg.stop.toString() + "(delta= " + (arg.stop - arg.start).toFixed(3) + ")");
    this.setDataloggerLoadProgress(1);
    this.recordedData = await this.sensor.get_recordedData(arg.start, arg.stop);
    try {
      this.recordedDataLoadProgress = await this.recordedData.loadMore();
    } catch (e) {
      logForm.log(this.hwdName + ": load more caused an exception " + e.message);
    }
    let measures = await this.recordedData.get_preview();
    this.previewMinData = [];
    this.previewCurData = [];
    this.previewMaxData = [];
    let startIndex = 0;
    let errCount = 0;
    let maxErrorCount = 10;
    let lastT = -1;
    if (CustomYSensor._MaxDataRecords > 0 && measures.length > CustomYSensor._MaxDataRecords)
      startIndex = measures.length - CustomYSensor._MaxDataRecords;
    for (let i = startIndex; i < measures.length; i++) {
      let t = measures[i].get_endTimeUTC();
      if (t >= arg.start && t <= arg.stop) {
        this.previewMinData.push(new TimedSensorValue(t, measures[i].get_minValue()));
        this.previewCurData.push(new TimedSensorValue(t, measures[i].get_averageValue()));
        this.previewMaxData.push(new TimedSensorValue(t, measures[i].get_maxValue()));
        if (t < lastT && errCount < maxErrorCount) {
          logForm.log(this.hwdName + " preloading warning:  timestamp going back in time " + t + "<" + lastT + (errCount < maxErrorCount - 1 ? "" : ", further similar errors wont be logged."));
          errCount++;
        } else if (t == lastT && errCount < maxErrorCount) {
          logForm.log(this.hwdName + " preloading warning: duplicate timestamp  " + t + (errCount < maxErrorCount - 1 ? "" : ", further similar errors wont be logged."));
          errCount++;
        }
        lastT = t;
      }
    }
    if (this.previewCurData.length > 1) {
      let a = this.previewCurData[0].DateTime;
      let b = this.previewCurData[this.previewCurData.length - 1].DateTime;
      logForm.log(this.hwdName + ": preloaded data from " + a.toString() + " to " + b.toString() + " (delta=" + (b - a).toFixed(3) + ")");
      if (CustomYSensor._MaxLoggerRecords > 0 && arg.start == 0) {
        let list = await this.recordedData.get_privateDataStreams();
        let index = list.length - 1;
        let totalRecords = 0;
        while (index > 0 && totalRecords < CustomYSensor._MaxLoggerRecords) {
          totalRecords += await list[index].get_rowCount();
          this.dataLoggerStartReadTime = await list[index].get_startTimeUTC();
          index--;
        }
        let n = 0;
        while (n < this.previewMinData.length && this.previewMinData[n].DateTime < this.dataLoggerStartReadTime) {
          n++;
        }
        if (n > 1) {
          this.previewMinData.splice(0, n - 1);
          this.previewCurData.splice(0, n - 1);
          this.previewMaxData.splice(0, n - 1);
        }
      }
    }
    this.preload_Completed(arg);
  }
  findMergeBoundaries(previewMinData) {
    let MergeSourceStart = 0;
    let MergeSourceStop = 0;
    if (this.minData.length > 0) {
      while (MergeSourceStart < this.minData.length && previewMinData[0].DateTime > this.minData[MergeSourceStart].DateTime) {
        MergeSourceStart++;
      }
      MergeSourceStop = MergeSourceStart;
      while (MergeSourceStop < this.minData.length && previewMinData[previewMinData.length - 1].DateTime >= this.minData[MergeSourceStop].DateTime) {
        MergeSourceStop++;
      }
    }
    return new MergeSourceRange(MergeSourceStart, MergeSourceStop);
  }
  preload_Completed(arg) {
    if (this.previewMinData == null)
      return;
    logForm.log(this.hwdName + " : datalogger preloading completed (" + this.previewMinData.length + " rows)");
    if (this.previewMinData.length > 1) {
      let it = this.findMergeBoundaries(this.previewMinData);
      let insertIndex = it.MergeSourceStart;
      let deleteCount = it.MergeSourceStop - it.MergeSourceStart;
      this.minData = this.minData.slice(0, insertIndex).concat(this.previewMinData, this.minData.slice(insertIndex + deleteCount));
      this.curData = this.curData.slice(0, insertIndex).concat(this.previewCurData, this.curData.slice(insertIndex + deleteCount));
      this.maxData = this.maxData.slice(0, insertIndex).concat(this.previewMaxData, this.maxData.slice(insertIndex + deleteCount));
      for (let i = 0; i < this.FormsToNotify.length; i++) {
        if (this.FormsToNotify[i] instanceof graphWidget) {
          this.FormsToNotify[i].SensorNewDataBlock(this, it.MergeSourceStart, it.MergeSourceStart + this.previewMinData.length - 1, 0, true);
        }
      }
    }
    let count = this.curData.length;
    if (count > 0) {
      if (this.curData[count - 1].DateTime > this.lastDataTimeStamp) {
        this.lastDataTimeStamp = this.curData[count - 1].DateTime;
        this.lastDataSource = "last preload timestamp";
      }
    }
    logForm.log(this.hwdName + " : start datalogger loading");
    this._predloadProcessIsBusy = false;
    this.load_DoWork(arg).then();
  }
  get_frequency() {
    return this._frequency;
  }
  async updateFrequncy(frequencyToSet) {
    if (await this.sensor.isOnline()) {
      this._frequency = frequencyToSet;
      await this.sensor.set_reportFrequency(this._frequency);
      let lfreq = await this.sensor.get_logFrequency();
      try {
        if (lfreq != "OFF")
          await this.sensor.set_logFrequency(this._frequency);
        let m = await this.sensor.get_module();
        await m.saveToFlash();
      } catch (e) {
        logForm.log("failed to change " + this.hwdName + " log frequency (" + e.message + ")");
      }
    } else {
      this._online = false;
    }
  }
  set_frequency(frequencyToSet) {
    if (this._online) {
      this.updateFrequncy(frequencyToSet).then();
    }
  }
  get_recording() {
    return this._recording;
  }
  set_recording(recordingStatus) {
    this.updaterecording(recordingStatus).then();
  }
  async updaterecording(recordingStatus) {
    if (!this.dataLoggerFeature)
      return;
    if (await this.sensor.isOnline()) {
      this._recording = recordingStatus;
      try {
        await this.sensor.set_logFrequency(this._recording ? this._frequency : "OFF");
        let module = await this.sensor.get_module();
        let serial = await module.get_serialNumber();
        let dl = YDataLogger.FindDataLogger(serial + ".dataLogger");
        await dl.set_recording(this._recording ? YDataLogger.RECORDING_ON : YDataLogger.RECORDING_OFF);
        await dl.set_autoStart(this._recording ? YDataLogger.AUTOSTART_ON : YDataLogger.AUTOSTART_OFF);
        await module.saveToFlash();
      } catch (e) {
        logForm.log("failed to change " + this.hwdName + " recording (" + e.message + ")");
      }
    } else {
      this._online = false;
    }
  }
  reportDataloggerLoadProgress(progress) {
  }
  async load_DoWork(arg) {
    if (this._loadProcessIsBusy)
      return;
    this._loadProcessIsBusy = true;
    if (this.dataLoggerLoadCompleted)
      return;
    logForm.log(this.hwdName + " loading main data from datalogger");
    if (this.dataLoggerStartReadTime > 0) {
      this.recordedData = await this.sensor.get_recordedData(this.dataLoggerStartReadTime, 0);
    }
    let errCount = 0;
    let maxErrorCount = 10;
    let lastT = -1;
    let lastProgress = this.recordedDataLoadProgress;
    while (this.recordedDataLoadProgress < 100) {
      if (this._plzCancelDataloggerLoading) {
        this.loadDone = true;
        this.loadFailed = false;
        this.loadCanceled = true;
        this.setDataloggerLoadProgress(100);
        break;
      }
      try {
        this.recordedDataLoadProgress = await this.recordedData.loadMore();
      } catch (Exception) {
        this.loadFailed = true;
        return;
      }
      if (lastProgress != this.recordedDataLoadProgress) {
        lastProgress = this.recordedDataLoadProgress;
        let p = lastProgress;
        if (p < 1)
          p = 1;
        if (p > 99)
          p = 99;
        this.setDataloggerLoadProgress(p < 1 ? 1 : p > 99 ? 99 : p);
      }
      if (this.recordedDataLoadProgress - lastProgress >= 2) {
        lastProgress = this.recordedDataLoadProgress;
      }
    }
    let measures = await this.recordedData.get_measures();
    this.previewMinData = [];
    this.previewCurData = [];
    this.previewMaxData = [];
    for (let i = 0; i < measures.length; i++) {
      let t = measures[i].get_endTimeUTC();
      if (t >= arg.start && t <= arg.stop) {
        if (t < lastT && errCount < maxErrorCount) {
          logForm.log(this.hwdName + " loading warning:  timestamp going back in time " + t + "<" + lastT + (errCount < maxErrorCount - 1 ? "" : ", further similar errors wont be logged."));
          errCount++;
        } else if (t == lastT && errCount < maxErrorCount) {
          logForm.log(this.hwdName + " loading warning: duplicate timestamp  " + t + (errCount < maxErrorCount - 1 ? "" : ", further similar errors wont be logged."));
          errCount++;
        }
        lastT = t;
        if (this.previewMinData.length == 0 || t > this.previewMinData[this.previewMinData.length - 1].DateTime) {
          this.previewMinData.push(new TimedSensorValue(t, measures[i].get_minValue()));
          this.previewCurData.push(new TimedSensorValue(t, measures[i].get_averageValue()));
          this.previewMaxData.push(new TimedSensorValue(t, measures[i].get_maxValue()));
        }
      } else {
        let d = new Date(t * 1e3);
        let d1 = new Date(arg.start * 1e3);
        let d2 = new Date(arg.stop * 1e3);
        let dstr = d.toLocaleDateString() + " " + d.toLocaleTimeString();
        let d1str = d1.toLocaleDateString() + " " + d1.toLocaleTimeString();
        let d2str = d2.toLocaleDateString() + " " + d2.toLocaleTimeString();
        logForm.log(this.hwdName + " note: skipping measure at " + dstr + ", not in range " + d1str + " ... " + d2str);
      }
    }
    if (CustomYSensor._MaxDataRecords > 0)
      this.previewDataCleanUp();
    for (let i = 0; i < this.previewMinData.length - 1; i++) {
      if (this.previewMinData[i].DateTime >= this.previewMinData[i + 1].DateTime) {
        throw "Time-stamp inconsistency";
      }
    }
    if (this.previewCurData.length > 1) {
      logForm.log(this.hwdName + " loaded " + this.previewCurData.length.toString() + "/" + measures.length.toString() + " records over " + (this.previewCurData[this.previewCurData.length - 1].DateTime - this.previewCurData[0].DateTime).toFixed(3) + " sec, last timed stamp was " + this.previewCurData[this.previewCurData.length - 1].DateTime);
    } else {
      logForm.log(this.hwdName + " loaded " + this.previewCurData.length.toString() + " records");
    }
    if (this.previewMinData.length > 2) {
      let lastPreviewTimeStamp = this.previewMinData[this.previewMinData.length - 1].DateTime;
      let it = this.findMergeBoundaries(this.previewMinData);
      let deleteCount = it.MergeSourceStop - it.MergeSourceStart;
      this.minData = this.minData.slice(0, it.MergeSourceStart).concat(this.previewMinData, this.minData.slice(it.MergeSourceStart + deleteCount));
      this.curData = this.curData.slice(0, it.MergeSourceStart).concat(this.previewCurData, this.curData.slice(it.MergeSourceStart + deleteCount));
      this.maxData = this.maxData.slice(0, it.MergeSourceStart).concat(this.previewMaxData, this.maxData.slice(it.MergeSourceStart + deleteCount));
      this.firstDataloggerTimeStamp = this.curData[0].DateTime;
    }
    this.loadDone = true;
    this.loadFailed = false;
    let count = this.curData.length;
    if (count > 0) {
      if (this.curData[count - 1].DateTime > this.lastDataTimeStamp) {
        this.lastDataTimeStamp = this.curData[count - 1].DateTime;
        this.lastDataSource = "end of datalogger";
      }
    }
    this.load_Completed();
  }
  load_Completed() {
    logForm.log(this.hwdName + ".loadcompleted()");
    if (this.loadFailed) {
      logForm.log(this.hwdName + " : datalogger loading failed");
      this._loadProcessIsBusy = false;
      return;
    }
    if (this.loadCanceled) {
      logForm.log(this.hwdName + " : datalogger loading was canceled");
      this.previewMinData = [];
      this.previewCurData = [];
      this.previewMaxData = [];
      this.loadCanceled = false;
      this._loadProcessIsBusy = false;
      this.preloadDone = false;
      this.loadDone = false;
      return;
    }
    if (this.previewCurData.length <= 2) {
      this.preloadDone = false;
      this.loadDone = false;
    }
    logForm.log(this.hwdName + " : datalogger loading completed  (" + this.previewMinData.length + " rows)");
    this.resetDataloggerLoader();
    this.dataLoggerLoadCompleted = true;
    for (let i = 0; i < this.FormsToNotify.length; i++) {
      if (this.FormsToNotify[i] instanceof graphWidget) {
        this.FormsToNotify[i].DataloggerCompleted(this);
      }
    }
    this.setDataloggerLoadProgress(100);
  }
  get dataloggerWasUsed() {
    return this.dataLoggerLoadCompleted;
  }
  dataCleanUp() {
    if (CustomYSensor._MaxDataRecords <= 0)
      return;
    let newsize = CustomYSensor._MaxDataRecords * 90 / 100 >> 0;
    if (this.curData != null && CustomYSensor._MaxDataRecords < this.curData.length) {
      this.minData.splice(0, this.minData.length - newsize);
      this.curData.splice(0, this.curData.length - newsize);
      this.maxData.splice(0, this.maxData.length - newsize);
    }
  }
  previewDataCleanUp() {
    if (CustomYSensor._MaxDataRecords <= 0)
      return;
    let newsize = CustomYSensor._MaxDataRecords * 90 / 100 >> 0;
    if (this.previewMinData != null && CustomYSensor._MaxDataRecords < this.previewMinData.length) {
      this.previewMinData.splice(0, this.previewMinData.length - newsize);
      this.previewCurData.splice(0, this.previewCurData.length - newsize);
      this.previewMaxData.splice(0, this.previewMaxData.length - newsize);
    }
  }
  stopDataloggerloading() {
  }
  isOnline() {
    return this._online;
  }
  async reloadConfig() {
    if (this._online) {
      let ison = await this.sensor.isOnline();
      if (ison) {
        try {
          this.unit = await this.sensor.get_unit();
          this._friendlyname = await this.sensor.get_friendlyName();
          this.resolution = await this.sensor.get_resolution();
          this._frequency = await this.sensor.get_reportFrequency();
          this._readonly = await this.sensor.isReadOnly();
          if (this.dataLoggerFeature) {
            this._recording = await this.sensor.get_logFrequency() != "OFF";
          } else {
            this._recording = false;
          }
          this.lastGetConfig = YAPI.GetTickCount();
          this.mustReloadConfig = false;
        } catch (e) {
          logForm.log("reload configuration error: " + e.message);
        }
      } else {
        this._online = false;
      }
    }
  }
  get_unit() {
    if (this.cfgChgNotificationsSupported && !this.mustReloadConfig)
      return this.unit;
    if (this.lastGetConfig <= 0 || YAPI.GetTickCount() - this.lastGetConfig > 5e3)
      this.reloadConfig().then();
    return this.unit;
  }
  get_resolution() {
    if (this.cfgChgNotificationsSupported && !this.mustReloadConfig)
      return this.resolution;
    if (this.lastGetConfig <= 0 || YAPI.GetTickCount() - this.lastGetConfig > 5e3)
      this.reloadConfig().then();
    return this.resolution;
  }
  resetDataloggerLoader() {
    this._predloadProcessIsBusy = false;
    this._loadProcessIsBusy = false;
    this.dataLoggerLoadCompleted = false;
    this.preloadDone = false;
    this.loadDone = false;
    this._dataloggerLoadisRunning = false;
    this.previewMinData = [];
    this.previewCurData = [];
    this.previewMaxData = [];
  }
  loadDatalogger(start, stop) {
    if (!this.dataLoggerFeature)
      return;
    if (this._predloadProcessIsBusy)
      return;
    if (this._loadProcessIsBusy)
      return;
    if (constants.maxPointsPerDataloggerSerie < 0) {
      logForm.log(this.hwdName + " : datalogger access is disabled");
      return;
    }
    if (!this.preloadDone && this.dataLoggerFeature) {
      logForm.log(this.hwdName + " : start datalogger preloading");
      this.preload_DoWork(new DataLoggerBoundary(start, stop)).then();
    }
  }
  async arrival(dataloggerOn) {
    await this.configureSensor();
    this._online = true;
    await this.reloadConfig();
    let dt = await this.sensor.get_dataLogger();
    if (dt == null)
      return;
    let now = Math.floor(new Date().getTime() / 1e3);
    if (this.curData.length > 0 && this.dataLoggerLoadCompleted) {
      let end = await dt.get_timeUTC();
      let start = this.curData[this.curData.length - 1].DateTime;
      let duration = end - start;
      if (duration == 0) {
        start = this.curData[this.curData.length - 2].DateTime;
        duration = end - start;
      }
      if (duration > 1) {
        logForm.log(this.hwdName + " is back online trying to load " + duration.toFixed(3) + " sec of data from datalogger ");
        this.resetDataloggerLoader();
        this.loadDatalogger(start, end);
      }
    }
    if (this.isReadOnly)
      logForm.log(this.hwdName + " is read only");
    this.notifySensorStateChange();
    this.notifySensorArrival();
  }
  async startDataloggerload(source) {
    if (!this.dataLoggerFeature)
      return;
    if (this.sensor == null)
      return;
    if (this._loadProcessIsBusy)
      return;
    if (this._predloadProcessIsBusy)
      return;
    if (this.dataLoggerLoadCompleted) {
      source.DataloggerCompleted(this);
      return;
    }
    let dt = await this.sensor.get_dataLogger();
    if (dt == null)
      return;
    this.loadDatalogger(0, await dt.get_timeUTC());
  }
  notifySensorArrival() {
    for (let i = 0; i < this.FormsToNotify.length; i++) {
      this.FormsToNotify[i].SensorArrivalcallback(this);
    }
  }
  notifySensorStateChange() {
    for (let i = 0; i < this.FormsToNotify.length; i++) {
      this.FormsToNotify[i].SensorStateChangedcallback(this);
    }
  }
  removal() {
    this._online = false;
    this.forceUpdate();
    this.notifySensorStateChange();
  }
  async configureSensor() {
    logForm.log("Configuring  " + this.hwdName);
    if (!await this.sensor.isOnline())
      return;
    let mustSave = false;
    let olfreq = await this.sensor.get_logFrequency();
    let orfreq = await this.sensor.get_reportFrequency();
    let readOnly = await this.sensor.isReadOnly();
    let lfreq = olfreq;
    let rfreq = orfreq;
    let m = await this.sensor.get_module();
    for (let i = 0; i < await m.functionCount(); i++) {
      if (await m.functionType(i) == "DataLogger") {
        this.dataLoggerFeature = true;
      }
    }
    try {
      if (this.dataLoggerFeature) {
        let m2 = await this.sensor.get_module();
        let dl = YDataLogger.FindDataLogger(await m2.get_serialNumber() + ".dataLogger");
        let dataloggerOn = await dl.get_recording() != YDataLogger.RECORDING_OFF;
        let dataloggerAS = await dl.get_autoStart() != YDataLogger.AUTOSTART_OFF;
        if (!dataloggerOn) {
          lfreq = "OFF";
        }
        if (lfreq != "OFF") {
          rfreq = lfreq;
        } else if (rfreq == "OFF") {
          rfreq = "1/s";
        }
        if (lfreq != olfreq) {
          if (readOnly)
            throw new Error(this.hwdName + " is read only, cannot change its logFrequency from " + olfreq + " to " + lfreq);
          await this.sensor.set_logFrequency(lfreq);
          mustSave = true;
        }
        if (rfreq != orfreq) {
          if (readOnly)
            throw new Error(this.hwdName + " is read only, connot change its  reportFrequency from " + orfreq + " to " + rfreq);
          await this.sensor.set_reportFrequency(rfreq);
          mustSave = true;
        }
        if (lfreq != "OFF") {
          if (!dataloggerOn) {
            if (readOnly)
              throw new Error(this.hwdName + " is read only, cannot change set its  datalogger recording to ON");
            await dl.set_recording(YDataLogger.RECORDING_ON);
          }
          if (!dataloggerAS) {
            if (readOnly)
              throw new Error(this.hwdName + " is read only, cannot change set its datalogger autostart to ON");
            await dl.set_autoStart(YDataLogger.AUTOSTART_ON);
            mustSave = true;
          }
        }
      } else {
        lfreq = "OFF";
        if (rfreq == "OFF") {
          rfreq = "1/s";
          if (readOnly)
            throw new Error(this.hwdName + " is read only, connot change is reportFrequency from OFF to " + rfreq);
          await this.sensor.set_reportFrequency(rfreq);
          mustSave = true;
        }
      }
      if (mustSave)
        await m.saveToFlash();
    } catch (e) {
      logForm.log("failed to configure " + this.hwdName + "  (" + e.message + ")");
    }
    logForm.log("registering timed callback for  " + await this.sensor.get_hardwareId());
    await this.sensor.registerTimedReportCallback((callbacksource, M) => {
      this.TimedCallback(callbacksource, M);
    });
    this._recording = lfreq != "OFF";
    this._frequency = rfreq;
  }
  registerCallback(f) {
    if (this.FormsToNotify.indexOf(f) >= 0)
      return;
    this.FormsToNotify.push(f);
    return;
  }
  forceUpdate() {
    this.TimedCallback(this.sensor, null).then();
  }
  async TimedCallback(source, M) {
    this._online = true;
    if (M != null) {
      let t = M.get_endTimeUTC();
      if (this.firstLiveDataTimeStamp == 0)
        this.firstLiveDataTimeStamp = t;
      if (t > this.lastDataTimeStamp) {
        this.lastDataTimeStamp = t;
        this.lastDataSource = "last timedReport";
        this.consecutiveBadTimeStamp = 0;
      } else {
        this.consecutiveBadTimeStamp++;
        if (this.consecutiveBadTimeStamp < 10) {
          logForm.log(this.hwdName + ": ignoring bad timestamp " + t.toFixed(3) + " (previous " + this.lastDataSource + " at " + this.lastDataTimeStamp.toFixed(3) + ")");
        }
      }
      if (this.consecutiveBadTimeStamp == 0 || this.consecutiveBadTimeStamp >= 10) {
        this._lastAvgValue = M.get_averageValue();
        this._lastMinValue = M.get_minValue();
        this._lastMaxValue = M.get_maxValue();
        this.curData.push(new TimedSensorValue(t, this._lastAvgValue));
        this.minData.push(new TimedSensorValue(t, this._lastMinValue));
        this.maxData.push(new TimedSensorValue(t, this._lastMaxValue));
        if (CustomYSensor._MaxDataRecords > 0)
          this.dataCleanUp();
      }
      for (let i = 0; i < this.Alarms.length; i++) {
        this.Alarms[i].check(M);
      }
      for (let i = 0; i < this.FormsToNotify.length; i++) {
        this.FormsToNotify[i].SensorValuecallback(this, M);
      }
    }
  }
  forgetForm(source) {
    for (let i = this.FormsToNotify.length - 1; i >= 0; i--) {
      if (source == this.FormsToNotify[i]) {
        this.FormsToNotify.splice(i, 1);
      }
    }
  }
  get_sensor() {
    return this.sensor;
  }
  get_hardwareId() {
    return this.hwdName;
  }
  get_friendlyName() {
    return this._friendlyname;
  }
  toString() {
    let name = this._friendlyname;
    if (this._readonly)
      name += " (readonly)";
    if (this._online)
      return name;
    return name + " (OFFLINE)";
  }
};
CustomYSensor._MaxDataRecords = 0;
CustomYSensor._MaxLoggerRecords = 0;
var NullYSensor = class extends CustomYSensor {
  constructor() {
    super(null, "", null);
    this.hwdName = "NOTAREALSENSOR";
    this._friendlyname = "NOTAREALSENSOR";
    this.dataLoggerFeature = false;
  }
  async preload_DoWork(arg) {
    return;
  }
  get dataloggerLoadisRunning() {
    return false;
  }
  get_unit() {
    return "";
  }
  registerCallback(Form) {
  }
  forceUpdate() {
  }
  get_frequency() {
    return "";
  }
  set_frequency(frequencyToSet) {
  }
  get_sensor() {
    return null;
  }
  toString() {
    return "(none)";
  }
  setAlarmCondition(index, condition) {
  }
  getAlarmCondition(index) {
    return 0;
  }
  setAlarmValue(index, value) {
  }
  getAlarmValue(index) {
    return 0;
  }
  setAlarmDelay(index, value) {
  }
  getAlarmDelay(index) {
    return 0;
  }
  setAlarmCommandline(index, value) {
  }
  getAlarmCommandline(index) {
    return "";
  }
};
var sensorsManager = class {
  static async clearHublist() {
    for (let i = sensorsManager._hubList.length - 1; i >= 0; i--) {
      if (sensorsManager._hubList[i].removable) {
        await YAPI.UnregisterHub(sensorsManager._hubList[i].get_fullUrl());
        sensorsManager._hubList.splice(i, 1);
      }
    }
  }
  static registerChangeCallback(changeCallback) {
    this._changeCallback = changeCallback;
  }
  static registerChangeExternalCallback(changeCallback) {
    this._changeExternalCallback = changeCallback;
  }
  static forgetForm(source) {
    for (let i = 0; i < sensorsManager.sensorList.length; i++) {
      sensorsManager.sensorList[i].forgetForm(source);
    }
  }
  static InitHubList(node) {
    let nodes = node.get_childsByIndex();
    for (let i = 0; i < nodes.length; i++) {
      if (nodes[i].Name.toUpperCase() == "HUB") {
        let h = Hub.HubFromXml(nodes[i]);
        let alreadthere = false;
        for (let j = 0; j < sensorsManager._hubList.length; j++) {
          if (h.get_connexionUrl() == sensorsManager._hubList[j].get_connexionUrl())
            alreadthere = true;
        }
        if (!alreadthere) {
          sensorsManager._hubList.push(h);
          h.Connect().then();
        }
      }
    }
  }
  static get hubList() {
    return sensorsManager._hubList;
  }
  static hubWasremoved(h) {
    for (let i = sensorsManager._hubList.length - 1; i >= 0; i--) {
      if (sensorsManager._hubList[i] == h)
        sensorsManager._hubList.splice(i, 1);
    }
  }
  static newHubCreated(h) {
    let url = h.get_connexionUrl();
    for (let i = 0; i < sensorsManager._hubList.length; i++) {
      if (sensorsManager._hubList[i].get_connexionUrl() == url) {
        alert("This connection already exists");
        return false;
      }
    }
    sensorsManager._hubList.push(h);
    return true;
  }
  static removeExtraInfoFromUrl(url) {
    let it = new URL(url);
    let res = it.hostname + it.pathname;
    if (res.slice(0, 4).toLowerCase() === "www.") {
      res = res.slice(4);
    }
    return res;
  }
  static async NetworkArrival(net) {
    logForm.log("Network device detected: " + await net.get_hardwareId());
    let ip = await net.get_ipAddress();
    let netname = await net.get_logicalName();
    let module = await net.get_module();
    let loginame = await module.get_logicalName();
    let url = sensorsManager.removeExtraInfoFromUrl(await module.get_url());
    for (let i = 0; i < sensorsManager._hubList.length; i++) {
      let str = sensorsManager.removeExtraInfoFromUrl(sensorsManager.hubList[i].get_fullUrl());
      if (str == url) {
        sensorsManager.hubList[i].arrival(ip, netname, module, loginame);
      }
    }
  }
  static getXmlHublist() {
    let res = "";
    for (let i = 0; i < sensorsManager._hubList.length; i++) {
      res += "    " + sensorsManager._hubList[i].XmlCode() + "\n";
    }
    return res;
  }
  static getXMLSensorsConfig() {
    let res = "<Sensors>\n";
    sensorsManager.sensorList.forEach((s) => {
      if (!(s instanceof NullYSensor)) {
        res = res + s.GetXmlData();
      }
    });
    res = res + "</Sensors>\n";
    return res;
  }
  static setKnownSensors(sensorXMLList) {
    this.KnownSensors = sensorXMLList;
  }
  static FindSensorLastLocalConfig(hwdId) {
    let SensorConfig = null;
    if (sensorsManager.KnownSensors != null) {
      let childs = sensorsManager.KnownSensors.get_childsByIndex();
      for (let i = 0; i < childs.length; i++) {
        let node = childs[i];
        if (node.Name == "Sensor") {
          let id = node.get_attributes()["ID"];
          if (id == hwdId) {
            SensorConfig = node;
          }
        }
      }
    }
    return SensorConfig;
  }
  static async deviceConfigChanged(m) {
    logForm.log("Configuration change on device  " + await m.get_serialNumber());
    let serialprefix = (await m.get_serialNumber()).substring(0, 8);
    for (let i = 0; i < sensorsManager.sensorList.length; i++) {
      if (sensorsManager.sensorList[i].get_hardwareId().substring(0, 8) == serialprefix) {
        await sensorsManager.sensorList[i].ConfigHasChanged();
      }
    }
    if (sensorsManager._changeCallback != null)
      sensorsManager._changeCallback();
    if (sensorsManager._changeExternalCallback != null) {
      let data = await sensorsManager._changeExternalCallback(m);
      if (data != null)
        YWebPage.ConfigChanged(data);
    }
  }
  static async deviceArrival(m) {
    try {
      let count = await m.functionCount();
      let serial = await m.get_serialNumber();
      let luminosity = await m.get_luminosity();
      logForm.log("Device Arrival " + serial);
      let recording = false;
      for (let i = 0; i < count; i++) {
        let ftype = await m.functionType(i);
        let fid = await m.functionId(i);
        if (ftype == "Network") {
          let net = await YNetwork.FindNetwork(serial + "." + fid);
          await sensorsManager.NetworkArrival(net);
        } else if (ftype == "DataLogger") {
          let dlog = YDataLogger.FindDataLogger(serial + "." + fid);
          let state = await dlog.get_recording();
          if (state == YDataLogger.RECORDING_ON || state == YDataLogger.RECORDING_PENDING) {
            recording = true;
          }
        }
      }
      for (let i = 0; i < count; i++) {
        let fbasetype = await m.functionBaseType(i);
        let fid = await m.functionId(i);
        if (fbasetype == "Sensor") {
          let hwdID = serial + "." + fid;
          logForm.log("New sensor arrival: " + hwdID);
          let found = false;
          for (let j = 0; j < sensorsManager.sensorList.length && !found; j++) {
            if (sensorsManager.sensorList[j].get_hardwareId() == hwdID) {
              found = true;
              await sensorsManager.sensorList[j].arrival(recording);
            }
          }
          if (!found) {
            let s = YSensor.FindSensor(hwdID);
            let hwd = await s.get_hardwareId();
            let cs = new CustomYSensor(s, hwd, sensorsManager.FindSensorLastLocalConfig(hwd));
            sensorsManager.sensorList.push(cs);
            await cs.configureSensor();
            YWebPage.refreshEditor();
            cs.notifySensorStateChange();
          }
        }
      }
      await m.registerConfigChangeCallback(sensorsManager.deviceConfigChanged);
      setTimeout(() => {
        sensorsManager.deviceConfigChanged(m);
      }, 100);
      if (sensorsManager._changeCallback != null)
        sensorsManager._changeCallback();
    } catch (e) {
      logForm.log("Device Arrival Error: " + e.message);
    }
    if (sensorsManager._customArrivalCallback != null)
      sensorsManager._customArrivalCallback(m);
  }
  static async deviceRemoval(m) {
    let serial = await m.get_serialNumber();
    logForm.log("Device removal " + serial);
    sensorsManager.sensorList.forEach((alreadyThereSensor) => {
      if (!(alreadyThereSensor instanceof NullYSensor)) {
        let hwd = alreadyThereSensor.get_hardwareId();
        if (hwd.length >= serial.length) {
          if (hwd.substring(0, serial.length) == serial) {
            alreadyThereSensor.removal();
          }
        }
      }
    });
    if (sensorsManager._changeCallback != null)
      sensorsManager._changeCallback();
    if (sensorsManager._customRemovalCallback != null)
      sensorsManager._customRemovalCallback(m);
  }
  static RegisterDeviceArrivalCallback(arrivalCallback) {
    sensorsManager._customArrivalCallback = arrivalCallback;
  }
  static RegisterDeviceRemovalCallback(removalCallback) {
    sensorsManager._customRemovalCallback = removalCallback;
  }
  static AddNewSensor(hwdID) {
    for (let i = 0; i < sensorsManager.sensorList.length; i++) {
      if (sensorsManager.sensorList[i] != null) {
        if (sensorsManager.sensorList[i].get_hardwareId() == hwdID)
          return sensorsManager.sensorList[i];
      }
    }
    let s = YSensor.FindSensor(hwdID);
    let cs = new CustomYSensor(s, hwdID, sensorsManager.FindSensorLastLocalConfig(hwdID));
    sensorsManager.sensorList.push(cs);
    return cs;
  }
  static getNullSensor() {
    return sensorsManager.NullSensor;
  }
  static async UpdateDeviceList() {
    let err = new YErrorMsg();
    try {
      if (await YAPI.UpdateDeviceList(err) != YAPI_SUCCESS) {
        logForm.log("UpdateDeviceList failed :" + err.msg);
      }
    } catch (e) {
      logForm.log("UpdateDeviceList failed :" + e.message);
    }
  }
  static async _runAsync() {
    let errmsg = new YErrorMsg();
    await YAPI.RegisterDeviceArrivalCallback((m) => {
      sensorsManager.deviceArrival(m);
    });
    await YAPI.RegisterDeviceRemovalCallback((m) => {
      sensorsManager.deviceRemoval(m);
    });
    await sensorsManager.UpdateDeviceList();
    setInterval(() => {
      sensorsManager.UpdateDeviceList();
    }, 2e3);
  }
  static run() {
    sensorsManager.NullSensor = new NullYSensor();
    sensorsManager.sensorList = [];
    sensorsManager.sensorList.push(sensorsManager.NullSensor);
    this._runAsync().then();
  }
};
sensorsManager.counter = 0;
sensorsManager.KnownSensors = null;
sensorsManager._hubList = [];
sensorsManager._customArrivalCallback = null;
sensorsManager._customRemovalCallback = null;
sensorsManager._changeCallback = null;
sensorsManager._changeExternalCallback = null;

// obj/full/formManager.js
var ResizeMoveHandle = class {
  constructor(container, index, mouseDownListener, touchStartlistener) {
    this.index = index;
    this.container = container;
    this.isactive = false;
    this.div = document.createElement("DIV");
    let size = ResizeMoveHandle.HANDLESIZE - 2;
    if (this.index == ResizeMoveHandle.RESIZEHANDLE_CENTER)
      size = size * 2;
    this.div.style.position = "absolute";
    this.div.style.border = "0px solid black";
    this.div.style.background = "transparent";
    this.div.style.pointerEvents = "auto";
    this.div.style.width = size.toString() + "px";
    this.div.style.height = size.toString() + "px";
    switch (index) {
      case ResizeMoveHandle.RESIZEHANDLE_TOPLEFT:
        this.div.style.cursor = "nw-resize";
        this.div.style.left = "0px";
        this.div.style.top = "0px";
        break;
      case ResizeMoveHandle.RESIZEHANDLE_TOPCENTER:
        this.div.style.cursor = "n-resize";
        this.div.style.top = "0px";
        this.div.style.left = "50%";
        this.div.style.transform = "translate(-50%,0)";
        break;
      case ResizeMoveHandle.RESIZEHANDLE_TOPRIGHT:
        this.div.style.cursor = "ne-resize";
        this.div.style.right = "0px";
        this.div.style.top = "0px";
        break;
      case ResizeMoveHandle.RESIZEHANDLE_CENTERRIGHT:
        this.div.style.cursor = "e-resize";
        this.div.style.right = "0px";
        this.div.style.top = "50%";
        this.div.style.transform = "translate(0,-50%)";
        break;
      case ResizeMoveHandle.RESIZEHANDLE_BOTTOMRIGHT:
        this.div.style.cursor = "se-resize";
        this.div.style.right = "0px";
        this.div.style.bottom = "0px";
        break;
      case ResizeMoveHandle.RESIZEHANDLE_BOTTOMCENTER:
        this.div.style.cursor = "s-resize";
        this.div.style.bottom = "0px";
        this.div.style.left = "50%";
        this.div.style.transform = "translate(-50%,0)";
        break;
      case ResizeMoveHandle.RESIZEHANDLE_BOTTOMLEFT:
        this.div.style.cursor = "sw-resize";
        this.div.style.left = "0px";
        this.div.style.bottom = "0px";
        break;
      case ResizeMoveHandle.RESIZEHANDLE_CENTERLEFT:
        this.div.style.cursor = "w-resize";
        this.div.style.left = "0px";
        this.div.style.top = "50%";
        this.div.style.transform = "translate(0,-50%)";
        break;
      case ResizeMoveHandle.RESIZEHANDLE_CENTER:
        this.div.style.cursor = "move";
        this.div.style.left = "50%";
        this.div.style.top = "50%";
        this.div.style.transform = "translate(-50%,-50%)";
        break;
    }
    this.container.appendChild(this.div);
    this.div.addEventListener("mousedown", mouseDownListener);
    this.div.addEventListener("touchstart", touchStartlistener);
    this.svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    this.svg.setAttribute("viewBox", "0 0 " + size + " " + size);
    this.svg.setAttribute("version", "1.1");
    this.svg.setAttribute("width", size.toString());
    this.svg.setAttribute("height", size.toString());
    let x = 0;
    let y = 0;
    let r = size;
    switch (this.index) {
      case ResizeMoveHandle.RESIZEHANDLE_TOPLEFT:
        break;
      case ResizeMoveHandle.RESIZEHANDLE_TOPCENTER:
        x = size / 2;
        break;
      case ResizeMoveHandle.RESIZEHANDLE_TOPRIGHT:
        x = size;
        break;
      case ResizeMoveHandle.RESIZEHANDLE_CENTERRIGHT:
        x = size;
        y = size / 2;
        break;
      case ResizeMoveHandle.RESIZEHANDLE_BOTTOMRIGHT:
        x = size;
        y = size;
        break;
      case ResizeMoveHandle.RESIZEHANDLE_BOTTOMCENTER:
        x = size / 2;
        y = size;
        break;
      case ResizeMoveHandle.RESIZEHANDLE_BOTTOMLEFT:
        y = size;
        break;
      case ResizeMoveHandle.RESIZEHANDLE_CENTERLEFT:
        y = size / 2;
        break;
      case ResizeMoveHandle.RESIZEHANDLE_CENTER:
        x = size / 2;
        y = size / 2;
        r = size / 2;
        break;
    }
    this.circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
    this.circle.setAttribute("cx", x.toString());
    this.circle.setAttribute("cy", y.toString());
    this.circle.setAttribute("r", r.toString());
    this.circle.setAttribute("style", "fill:white");
    this.circle.setAttribute("opacity", "0.75");
    this.svg.appendChild(this.circle);
    this.arrow = document.createElementNS("http://www.w3.org/2000/svg", "path");
    let d = "";
    for (let i = 0; i < ResizeMoveHandle.RESIZEHANDLE_data[index].length >> 1; i++) {
      let x2 = 1 + (size - 2) * ResizeMoveHandle.RESIZEHANDLE_data[index][i << 1] / 12;
      let y2 = 1 + (size - 2) * ResizeMoveHandle.RESIZEHANDLE_data[index][1 + (i << 1)] / 12;
      d += i == 0 ? "M " : "L ";
      d += Math.round(x2).toString() + " " + Math.round(y2).toString() + " ";
    }
    d += "z";
    this.arrow.setAttribute("d", d);
    this.arrow.setAttribute("fill", ResizeMoveHandle.inactiveColor);
    this.svg.appendChild(this.arrow);
    this.div.appendChild(this.svg);
    this.container.appendChild(this.div);
  }
  get active() {
    return this.isactive;
  }
  set active(value) {
    if (value != this.isactive) {
      this.isactive = value;
      this.arrow.setAttribute("fill", this.active ? ResizeMoveHandle.activeColor : ResizeMoveHandle.inactiveColor);
    }
  }
};
ResizeMoveHandle.HANDLESIZE = Math.round(20 * (1 + 2 * (constants.guiDPIFactor - 1)));
ResizeMoveHandle.activeColor = "lightgreen";
ResizeMoveHandle.inactiveColor = "grey";
ResizeMoveHandle.RESIZEHANDLE_TOPLEFT = 0;
ResizeMoveHandle.RESIZEHANDLE_TOPCENTER = 1;
ResizeMoveHandle.RESIZEHANDLE_TOPRIGHT = 2;
ResizeMoveHandle.RESIZEHANDLE_CENTERRIGHT = 3;
ResizeMoveHandle.RESIZEHANDLE_BOTTOMRIGHT = 4;
ResizeMoveHandle.RESIZEHANDLE_BOTTOMCENTER = 5;
ResizeMoveHandle.RESIZEHANDLE_BOTTOMLEFT = 6;
ResizeMoveHandle.RESIZEHANDLE_CENTERLEFT = 7;
ResizeMoveHandle.RESIZEHANDLE_CENTER = 8;
ResizeMoveHandle.RESIZEHANDLE_data = [
  [0, 0, 0, 7, 2, 5, 7, 10, 10, 7, 5, 2, 7, 0],
  [6, 0, 11, 5, 8, 5, 8, 12, 4, 12, 4, 5, 1, 5],
  [12, 0, 12, 7, 10, 5, 5, 10, 2, 7, 7, 2, 5, 0],
  [12, 6, 7, 11, 7, 8, 0, 8, 0, 4, 7, 4, 7, 1],
  [12, 12, 5, 12, 7, 10, 2, 5, 5, 2, 10, 7, 12, 5],
  [6, 12, 1, 7, 4, 7, 4, 0, 8, 0, 8, 7, 11, 7],
  [0, 12, 0, 5, 2, 7, 7, 2, 10, 5, 5, 10, 7, 12],
  [0, 6, 5, 1, 5, 4, 12, 4, 12, 8, 5, 8, 5, 11],
  [
    6,
    0,
    8,
    2,
    7,
    2,
    7,
    5,
    10,
    5,
    10,
    4,
    12,
    6,
    10,
    8,
    10,
    7,
    7,
    7,
    7,
    10,
    8,
    10,
    6,
    12,
    4,
    10,
    5,
    10,
    5,
    7,
    2,
    7,
    2,
    8,
    0,
    6,
    2,
    4,
    2,
    5,
    5,
    5,
    5,
    2,
    4,
    2
  ]
];
var YWidget = class {
  static log(st) {
    logForm.log(st);
  }
  SourceChanged(src, index) {
  }
  loadRecordedDataIfNeeded() {
  }
  removeDataloggerData() {
  }
  delete() {
    this.editStopped();
    sensorsManager.forgetForm(this);
    this.destroy();
  }
  get confirmDeleteString() {
    return "not defined";
  }
  snapshot() {
    let w = 1024;
    let h = 1024;
    let ratio = this.UIContainer.offsetHeight != 0 ? this.UIContainer.offsetWidth / this.UIContainer.offsetHeight : 1;
    switch (constants.captureSizePolicy) {
      case YDataRenderer.CaptureFormats.Keep:
        w = this.UIContainer.offsetWidth;
        h = this.UIContainer.offsetHeight;
        break;
      case YDataRenderer.CaptureFormats.FixedHeight:
        h = constants.captureHeight;
        w = h * ratio;
        break;
      case YDataRenderer.CaptureFormats.FixedWidth:
        w = constants.captureWidth;
        h = w / ratio;
        break;
      case YDataRenderer.CaptureFormats.Fixed:
        w = constants.captureWidth;
        h = constants.captureHeight;
        break;
    }
    this._genRenderer.captureAndDownloadImage(constants.captureType, "", w, h, constants.captureDPI);
  }
  get BackColor() {
    return this._BackColor;
  }
  set BackColor(value) {
    this._BackColor = value;
    this.UIContainer.style.backgroundColor = this._BackColor.htmlCode;
  }
  get BorderColor() {
    return this._BorderColor;
  }
  set BorderColor(value) {
    this._BorderColor = value;
    this.UIContainer.style.border = "1px solid " + this._BorderColor.htmlCode;
  }
  get parentWidth() {
    if (this.UIContainer.parentNode == document.body || this.UIContainer.parentNode == null)
      return window.innerWidth;
    return this.UIContainer.parentNode.clientWidth;
  }
  get parentHeight() {
    if (this.UIContainer.parentNode == document.body || this.UIContainer.parentNode == null)
      return window.innerHeight;
    return this.UIContainer.parentNode.clientHeight;
  }
  get relativePositionX() {
    if (this._SizeIsRelative)
      return this._relativePositionX;
    return this.sizeRound(100 * this.UIContainer.offsetLeft / this.parentWidth);
  }
  set relativePositionX(value) {
    this._relativePositionX = value;
    this._PositionX = Math.round(value * this.parentWidth / 100);
  }
  set relativePositionY(value) {
    this._relativePositionY = value;
    this._PositionY = Math.round(value * this.parentHeight / 100);
  }
  get relativePositionY() {
    if (this._SizeIsRelative)
      return this._relativePositionY;
    return this.sizeRound(100 * this.UIContainer.offsetTop / this.parentHeight);
  }
  get PositionX() {
    if (this._SizeIsRelative)
      return this.relativePositionX;
    return this.UIContainer.offsetLeft;
  }
  set PositionX(value) {
    if (this._SizeIsRelative)
      this.relativePositionX = value;
    else
      this._PositionX = value;
    this.UIContainer.style.left = this._PositionX.toString() + "px";
    if (this._genRenderer != null)
      this._genRenderer.clearTransformationMatrix();
    this.DrawHandles(this.UIContainer.offsetLeft, this.UIContainer.offsetTop, this.UIContainer.offsetWidth, this.UIContainer.offsetHeight);
  }
  get PositionY() {
    if (this._SizeIsRelative)
      return this.relativePositionY;
    return this.UIContainer.offsetTop;
  }
  set PositionY(value) {
    if (this._SizeIsRelative)
      this.relativePositionY = value;
    else
      this._PositionY = value;
    this.UIContainer.style.top = this._PositionY.toString() + "px";
    if (this._genRenderer != null)
      this._genRenderer.clearTransformationMatrix();
    this.DrawHandles(this.UIContainer.offsetLeft, this.UIContainer.offsetTop, this.UIContainer.offsetWidth, this.UIContainer.offsetHeight);
  }
  sizeRound(v) {
    return Math.round(100 * v) / 100;
  }
  get relativeWidth() {
    if (this._SizeIsRelative)
      return this._relativeWidth;
    return this.sizeRound(100 * this.UIContainer.offsetWidth / this.parentWidth);
  }
  set relativeWidth(value) {
    if (value <= 0)
      throw "Value must be strictly positive";
    this._relativeWidth = value;
    this._Width = Math.round(value * this.parentWidth / 100);
  }
  set relativeHeight(value) {
    if (value <= 0)
      throw "Value must be strictly positive";
    this._relativeHeight = value;
    this._Height = Math.round(value * this.parentHeight / 100);
  }
  get relativeHeight() {
    if (this._SizeIsRelative)
      return this._relativeHeight;
    return this.sizeRound(100 * this.UIContainer.offsetHeight / this.parentHeight);
  }
  updateRelativeSize() {
    if (Math.abs(this._relativeWidth * this.parentWidth / 100 - this.UIContainer.offsetWidth) > 1)
      this._relativeWidth = this.sizeRound(100 * this.UIContainer.offsetWidth / this.parentWidth);
    if (Math.abs(this._relativeHeight * this.parentHeight / 100 - this.UIContainer.offsetHeight) > 1)
      this._relativeHeight = this.sizeRound(100 * this.UIContainer.offsetHeight / this.parentHeight);
    if (Math.abs(this._relativePositionX * this.parentWidth / 100 - this.UIContainer.offsetLeft) > 1)
      this._relativePositionX = this.sizeRound(100 * this.UIContainer.offsetLeft / this.parentWidth);
    if (Math.abs(this._relativePositionY * this.parentHeight / 100 - this.UIContainer.offsetTop) > 1)
      this._relativePositionY = this.sizeRound(100 * this.UIContainer.offsetTop / this.parentHeight);
  }
  get Width() {
    if (this._SizeIsRelative)
      return this.relativeWidth;
    else
      return this.UIContainer.offsetWidth;
  }
  set Width(value) {
    if (value <= 0)
      throw "Value must be strictly positive";
    if (this._SizeIsRelative)
      this.relativeWidth = value;
    else
      this._Width = value;
    this.UIContainer.style.width = (this._Width - 2).toString() + "px";
    this.UIContainer.width = this._Width - 2;
    if (this._genRenderer != null)
      this._genRenderer.clearTransformationMatrix();
    this.DrawHandles(this.UIContainer.offsetLeft, this.UIContainer.offsetTop, this.UIContainer.offsetWidth, this.UIContainer.offsetHeight);
    this.containerResized();
  }
  get Height() {
    if (this._SizeIsRelative)
      return this.relativeHeight;
    else
      return this.UIContainer.offsetHeight;
  }
  set Height(value) {
    if (value <= 0)
      throw "Value must be strictly positive";
    if (this._SizeIsRelative)
      this.relativeHeight = value;
    else
      this._Height = value;
    this.UIContainer.style.height = (this._Height - 2).toString() + "px";
    this.UIContainer.height = this._Height - 2;
    if (this._genRenderer != null)
      this._genRenderer.clearTransformationMatrix();
    this.DrawHandles(this.UIContainer.offsetLeft, this.UIContainer.offsetTop, this.UIContainer.offsetWidth, this.UIContainer.offsetHeight);
    this.containerResized();
  }
  get SizeIsRelative() {
    return this._SizeIsRelative;
  }
  set SizeIsRelative(value) {
    if (this._SizeIsRelative != value) {
      this._SizeIsRelative = value;
      if (this._SizeIsRelative) {
        this._relativePositionX = this.sizeRound(100 * this.UIContainer.offsetLeft / this.parentWidth);
        this._relativePositionY = this.sizeRound(100 * this.UIContainer.offsetTop / this.parentHeight);
        this._relativeWidth = this.sizeRound(100 * this.UIContainer.offsetWidth / this.parentWidth);
        this._relativeHeight = this.sizeRound(100 * this.UIContainer.offsetHeight / this.parentHeight);
      }
      this.windowResized();
    }
  }
  get containerID() {
    return this._containerID;
  }
  set containerID(value) {
    if (this._containerID == value)
      return;
    let target = value != "" ? document.getElementById(value) : null;
    if (value != "" && target == null)
      throw "No HTMLElement on the page with such ID (" + value + ")";
    if (this.UIContainer.parentNode != null) {
      this.UIContainer.parentNode.removeChild(this.UIContainer);
    } else {
      document.body.removeChild(this.UIContainer);
    }
    if (target != null) {
      this.UIContainer.style.position = "relative";
      target.insertBefore(this.UIContainer, target.firstChild);
    } else {
      this.UIContainer.style.position = "absolute";
      document.body.insertBefore(this.UIContainer, document.body.firstChild);
    }
    this._genRenderer.clearTransformationMatrix();
    this.windowResized();
    this.DrawHandles(this.UIContainer.offsetLeft, this.UIContainer.offsetTop, this.UIContainer.offsetWidth, this.UIContainer.offsetHeight);
    this._containerID = value;
  }
  get Text() {
    return this._Text;
  }
  set Text(value) {
    this._Text = value;
    this.UIContainer.title = value;
  }
  set_name(name) {
    this.Text = name;
    this._genProp.Form_Text = name;
  }
  windowResized() {
    this._genRenderer.DisableRedraw();
    if (this._SizeIsRelative) {
      this.PositionX = this._relativePositionX;
      this.PositionY = this._relativePositionY;
      this.Height = this._relativeHeight;
      this.Width = this._relativeWidth;
    }
    this.containerResized();
    this._genRenderer.AllowRedraw();
  }
  ApplyRelativeSizeIfRequired() {
    if (this._initialContainerID != "") {
      if (document.getElementById(this._initialContainerID) != null) {
        this.containerID = this._initialContainerID;
      } else {
        logForm.log('Warning: cannot place widget in "' + this._initialContainerID + '" : no such HTML element.');
      }
    }
    this._SizeIsRelative = this._InitialSizeIsRelative;
    this.windowResized();
  }
  destroy() {
    window.removeEventListener("resize", this._windowResizeCallback);
    this._genRenderer.destroy();
    Object.entries(this).forEach((pair) => {
      Reflect.set(this, pair[0], null);
    });
  }
  getContainerOffset() {
    let it = this.UIContainer.offsetParent;
    let absx = 0;
    let absy = 0;
    while (it) {
      absy += it.offsetTop;
      absx += it.offsetLeft;
      it = it.offsetParent;
    }
    return new pointXY(absx, absy);
  }
  contextMenuCallBack(mouseX, mouseY) {
    let p = this._genRenderer.Scr2ElmMatrix.multiplyByV(Vector3.FromXYCoord(mouseX, mouseY)).toPoint();
    if (p.X >= 0 && p.X <= this.UIContainer.offsetWidth && p.Y >= 0 && p.Y <= this.UIContainer.offsetHeight) {
      this.contextMenuIsOpening();
    }
  }
  contextMenuIsOpening() {
  }
  constructor(node, editor, default_x, default_y, default_width, default_height) {
    this._genProp = null;
    this._genRenderer = null;
    this._BackColor = YColor.Transparent;
    this._BorderColor = YColor.Gray;
    this._relativePositionX = 0;
    this._relativePositionY = 0;
    this._PositionX = 0;
    this._PositionY = 0;
    this._relativeWidth = 100;
    this._relativeHeight = 100;
    this._Width = 300;
    this._Height = 0;
    this._InitialSizeIsRelative = false;
    this._SizeIsRelative = false;
    this._initialContainerID = "";
    this._containerID = "";
    this._Text = "";
    this.resizeCaptureRunning = false;
    this.resizeCaptureXOrigineMouse = 0;
    this.resizeCaptureYOrigineMouse = 0;
    this.resizeCaptureXOrigine = 0;
    this.resizeCaptureYOrigine = 0;
    this.resizeCaptureOriginalTop = 0;
    this.resizeCaptureOriginalLeft = 0;
    this.resizeCaptureOriginalWidth = 0;
    this.resizeCaptureOriginalHeight = 0;
    this.resizeCaptureHandleIndex = 0;
    this.resizeCaptureOriginalMatrix = null;
    this.resizeCaptureOriginalMatrixInv = null;
    this.previousTRansform = "";
    this.previousWidth = 0;
    this.previousHeight = 0;
    let left = typeof default_x != "undefined" ? default_x : 0;
    let top2 = typeof default_y != "undefined" ? default_y : 0;
    let width = typeof default_width != "undefined" ? default_width : 0;
    let height = typeof default_height != "undefined" ? default_height : 0;
    let bottom = Number.NaN;
    let right = Number.NaN;
    if (node != null) {
      let childnodes = node.get_childsByName();
      if ("location" in childnodes) {
        let it = childnodes["location"];
        let attributes = it.get_attributes();
        if ("x" in attributes)
          left = parseInt(attributes["x"]);
        if ("y" in attributes)
          top2 = parseInt(attributes["y"]);
      }
      if ("size" in childnodes) {
        let it = childnodes["size"];
        let attributes = it.get_attributes();
        if ("w" in attributes)
          width = parseInt(attributes["w"]);
        if ("h" in attributes)
          height = parseInt(attributes["h"]);
      }
      if ("relativeCoord" in childnodes) {
        let it = childnodes["relativeCoord"];
        let attributes = it.get_attributes();
        if ("x" in attributes)
          this._relativePositionX = this.sizeRound(parseFloat(attributes["x"]));
        if ("y" in attributes)
          this._relativePositionY = this.sizeRound(parseFloat(attributes["y"]));
        if ("w" in attributes)
          this._relativeWidth = this.sizeRound(parseFloat(attributes["w"]));
        if ("h" in attributes)
          this._relativeHeight = this.sizeRound(parseFloat(attributes["h"]));
        if ("active" in attributes)
          this._InitialSizeIsRelative = attributes["active"].toUpperCase() == "TRUE";
      }
      if ("container" in childnodes) {
        let it = childnodes["container"];
        let attributes = it.get_attributes();
        if ("id" in attributes)
          this._initialContainerID = attributes["id"];
      }
    }
    this.UIContainer = document.createElement("CANVAS");
    this.UIContainer.style.position = "absolute";
    YWidget.currentEdited = null;
    let h = window.innerHeight;
    let w = window.innerWidth;
    this.PositionX = this._InitialSizeIsRelative ? Math.round(w * (this._relativePositionX / 100)) : left;
    this.PositionY = this._InitialSizeIsRelative ? Math.round(h * (this._relativePositionY / 100)) : top2;
    this.Width = this._InitialSizeIsRelative ? Math.round(w * (this._relativeWidth / 100)) : width;
    this.Height = this._InitialSizeIsRelative ? Math.round(h * (this._relativeHeight / 100)) : height;
    this.UIContainer.style.border = "1px solid black";
    this.UIContainer.style.backgroundColor = this._BackColor.htmlCode;
    this.UIContainer.setAttribute("name", "YoctoVisualizationWidget");
    document.body.appendChild(this.UIContainer);
    this._windowResizeCallback = () => this.windowResized();
    window.addEventListener("resize", this._windowResizeCallback);
  }
  rearrangeZindexes() {
    let containers = document.getElementsByName("YoctoVisualizationWidget");
    let n = 0;
    for (let i = 0; i < containers.length; i++) {
      if (containers[i] != this.UIContainer) {
        containers[i].style.zIndex = n.toString();
        n++;
      }
    }
    this.UIContainer.style.zIndex = n.toString();
    n++;
    YWidget.HandlesDiv.style.zIndex = n.toString();
  }
  SensorArrivalcallback(source) {
  }
  SensorStateChangedcallback(source) {
    if (YWidget.currentEdited == this) {
      YWebPage.refreshEditor();
    }
  }
  SensorValuecallback(source, M) {
  }
  get isBeingEdited() {
    return YWidget.currentEdited == this;
  }
  static stopEdition() {
    if (YWidget.currentEdited != null) {
      YWidget.currentEdited.editStopped();
      YWidget.currentEdited = null;
    }
  }
  refreshProperties() {
  }
  edit() {
    YWidget.stopEdition();
    YWidget.currentEdited = this;
    if (YWidget.editHandles.length <= 0) {
      YWidget.HandlesDiv = document.createElement("DIV");
      YWidget.HandlesDiv.style.position = "absolute";
      YWidget.HandlesDiv.style.left = "0px";
      YWidget.HandlesDiv.style.top = "0px";
      YWidget.HandlesDiv.style.backgroundColor = "transparent";
      YWidget.HandlesDiv.style.transformOrigin = "top left";
      YWidget.HandlesDiv.style.pointerEvents = "none";
      for (let i = 0; i < 9; i++) {
        YWidget.editHandles.push(new ResizeMoveHandle(YWidget.HandlesDiv, i, (e) => {
          if (YWidget.currentEdited != null)
            YWidget.currentEdited.mouseStartCapture(e, i);
        }, (e) => {
          if (YWidget.currentEdited != null) {
            YWidget.currentEdited.touchStartCapture(e, i);
          }
        }));
      }
      document.body.appendChild(YWidget.HandlesDiv);
      document.addEventListener("touchmove", (e) => {
        if (YWidget.currentEdited != null)
          YWidget.currentEdited.touchCaptureRun(e);
      }, {passive: false});
      document.addEventListener("touchend", (e) => {
        if (YWidget.currentEdited != null)
          YWidget.currentEdited.touchCaptureStop(e);
      }, {passive: false});
      document.addEventListener("mousemove", (e) => {
        if (YWidget.currentEdited != null)
          YWidget.currentEdited.mouseCaptureRun(e);
      }, {passive: false});
      document.addEventListener("mouseup", (e) => {
        if (YWidget.currentEdited != null)
          YWidget.currentEdited.mouseCaptureStop(e);
      }, {passive: false});
    }
    this.DrawHandles(this.UIContainer.offsetLeft, this.UIContainer.offsetTop, this.UIContainer.offsetWidth, this.UIContainer.offsetHeight);
    YWidget.HandlesDiv.style.display = "";
    this.rearrangeZindexes();
  }
  DrawHandles(offsetLeft, offsetTop, offsetWidth, offsetHeight) {
    if (YWidget.currentEdited == null)
      return;
    if (YWidget.editHandles.length <= 0)
      return;
    YWidget.HandlesDiv.style.width = offsetWidth.toString() + "px";
    YWidget.HandlesDiv.style.height = offsetHeight.toString() + "px";
    if (this._genRenderer == null)
      debugger;
    let borderWidth = parseFloat(this.UIContainer.style.border);
    let borderMatrix = Matrix3x3.newTranslateMatrix(-borderWidth, -borderWidth);
    YWidget.HandlesDiv.style.transform = borderMatrix.multiplyByM(this._genRenderer.Elm2ScrMatrix).toCSS();
    YWidget.HandlesDiv.style.transform = "top left";
  }
  updateWindowPositionProperties(prop) {
    prop.Form_PositionX = this.PositionX;
    prop.Form_PositionY = this.PositionY;
    prop.Form_Width = this.Width;
    prop.Form_Height = this.Height;
  }
  touchStartCapture(e, handleIndex) {
    if (e.touches.length == 1) {
      this.handleMouseStartCapture(e.touches[0].pageX, e.touches[0].pageY, handleIndex);
      e.preventDefault();
    }
  }
  mouseStartCapture(e, handleIndex) {
    if (e.button != 0)
      return;
    this.handleMouseStartCapture(e.pageX, e.pageY, handleIndex);
  }
  handleMouseStartCapture(pageX, pageY, handleIndex) {
    this.resizeCaptureOriginalMatrix = this._genRenderer.Scr2ElmMatrix;
    this.resizeCaptureOriginalMatrixInv = this._genRenderer.Elm2ScrMatrix;
    let p = this.resizeCaptureOriginalMatrix.multiplyByV(Vector3.FromXYCoord(pageX, pageY)).toPoint();
    this.resizeCaptureRunning = true;
    this.resizeCaptureXOrigine = p.X;
    this.resizeCaptureYOrigine = p.Y;
    this.resizeCaptureOriginalLeft = this.UIContainer.offsetLeft;
    this.resizeCaptureOriginalTop = this.UIContainer.offsetTop;
    this.resizeCaptureOriginalWidth = this.UIContainer.offsetWidth;
    this.resizeCaptureOriginalHeight = this.UIContainer.offsetHeight;
    this.resizeCaptureHandleIndex = handleIndex;
    YWidget.editHandles[this.resizeCaptureHandleIndex].active = true;
    this.previousTRansform = YWidget.HandlesDiv.style.transform;
  }
  touchCaptureRun(e) {
    if (e.touches.length == 1) {
      this.handleCaptureRun(e.touches[0].pageX, e.touches[0].pageY);
      e.preventDefault();
    }
  }
  mouseCaptureRun(e) {
    this.handleCaptureRun(e.pageX, e.pageY);
  }
  handleCaptureRun(pageX, pageY) {
    if (!this.resizeCaptureRunning)
      return;
    let p = this.resizeCaptureOriginalMatrix.multiplyByV(Vector3.FromXYCoord(pageX, pageY)).toPoint();
    let dx = p.X - this.resizeCaptureXOrigine;
    let dy = p.Y - this.resizeCaptureYOrigine;
    let newLeft = this.resizeCaptureOriginalLeft;
    let newTop = this.resizeCaptureOriginalTop;
    let newWidth = this.resizeCaptureOriginalWidth;
    let newHeight = this.resizeCaptureOriginalHeight;
    switch (this.resizeCaptureHandleIndex) {
      case 0:
        newLeft += dx;
        newTop += dy;
        newWidth -= dx;
        newHeight -= dy;
        break;
      case 1:
        newTop += dy;
        newHeight -= dy;
        break;
      case 2:
        newTop += dy;
        newWidth += dx;
        newHeight -= dy;
        break;
      case 3:
        newWidth += dx;
        break;
      case 4:
        newWidth += dx;
        newHeight += dy;
        break;
      case 5:
        newHeight += dy;
        break;
      case 6:
        newLeft += dx;
        newWidth -= dx;
        newHeight += dy;
        break;
      case 7:
        newLeft += dx;
        newWidth -= dx;
        break;
      case 8:
        newLeft += dx;
        newTop += dy;
        break;
    }
    if (newWidth < 2 * YWidget.HANDLESIZE)
      newWidth = 2 * YWidget.HANDLESIZE;
    if (newHeight < 2 * YWidget.HANDLESIZE)
      newHeight = 2 * YWidget.HANDLESIZE;
    this.UIContainer.style.left = newLeft.toString() + "px";
    this.UIContainer.style.top = newTop.toString() + "px";
    if (this.resizeCaptureOriginalWidth != newWidth || this.resizeCaptureOriginalHeight != newHeight) {
      this.resize(newWidth - 2, newHeight - 2);
    }
    this._genRenderer.clearTransformationMatrix();
    YWidget.HandlesDiv.style.width = newWidth.toString() + "px";
    YWidget.HandlesDiv.style.height = newHeight.toString() + "px";
    YWidget.HandlesDiv.style.left = "0px";
    YWidget.HandlesDiv.style.top = "0px";
    let A = this.resizeCaptureOriginalMatrixInv;
    let B = Matrix3x3.newTranslateMatrix(newLeft - this.resizeCaptureOriginalLeft, newTop - this.resizeCaptureOriginalTop);
    let borderWidth = parseFloat(this.UIContainer.style.border);
    let borderMatrix = Matrix3x3.newTranslateMatrix(-borderWidth, -borderWidth);
    YWidget.HandlesDiv.style.transform = borderMatrix.multiplyByM(A.multiplyByM(B)).toCSS();
  }
  editStopped() {
    this.resizeCaptureRunning = false;
    if (YWidget.HandlesDiv != null)
      YWidget.HandlesDiv.style.display = "none";
  }
  touchCaptureStop(e) {
    this.mouseCaptureStop(null);
  }
  mouseCaptureStop(e) {
    if (!this.resizeCaptureRunning)
      return;
    this.resizeCaptureRunning = false;
    YWidget.editHandles[this.resizeCaptureHandleIndex].active = false;
    if (this.previousTRansform != YWidget.HandlesDiv.style.transform || this.resizeCaptureOriginalWidth != this.UIContainer.offsetWidth || this.resizeCaptureOriginalHeight != this.UIContainer.offsetHeight) {
      if (this._SizeIsRelative)
        this.updateRelativeSize();
      constants.edited = true;
    }
    this.refreshProperties();
  }
  resize(newWidth, newHeight) {
    this.UIContainer.style.width = newWidth.toString() + "px";
    this.UIContainer.style.height = newHeight.toString() + "px";
    this.containerResized();
  }
  containerResized() {
  }
  getContentsConfigData() {
    return "  <location x='" + this.UIContainer.offsetLeft.toString() + "' y='" + this.UIContainer.offsetTop.toString() + "'/>\n  <size     w='" + this.UIContainer.offsetWidth.toString() + "' h='" + this.UIContainer.offsetHeight.toString() + "'  state='Normal'/>\n  <relativeCoord x='" + this._relativePositionX.toString() + "' y='" + this._relativePositionY.toString() + "' w='" + this._relativeWidth.toString() + "' h='" + this._relativeHeight.toString() + "' active='" + (this._SizeIsRelative ? "True" : "False") + "'/>\n  <container id='" + constants.XMLquote(this._containerID) + "'/>\n" + this.getPropertiesXml();
  }
  getPropertiesXml() {
    return "";
  }
  PatchSensorAnnotationCallback(sensor, text) {
    let name = "None";
    let avgvalue = "N/A";
    let minvalue = "N/A";
    let maxvalue = "N/A";
    let unit = "";
    if (!(sensor instanceof NullYSensor)) {
      let resolution = -Math.round(Math.log10(sensor.get_resolution()));
      name = sensor.get_friendlyName();
      if (sensor.isOnline()) {
        avgvalue = sensor.get_lastAvgValue().toFixed(resolution);
        minvalue = sensor.get_lastMinValue().toFixed(resolution);
        maxvalue = sensor.get_lastMaxValue().toFixed(resolution);
      }
      unit = sensor.get_unit();
    }
    text = text.replace("$NAME$", name);
    text = text.replace("$AVGVALUE$", avgvalue);
    text = text.replace("$MAXVALUE$", maxvalue);
    text = text.replace("$MINVALUE$", minvalue);
    text = text.replace("$UNIT$", unit);
    return text;
  }
};
YWidget.HANDLESIZE = Math.round(20 * (1 + 2 * (constants.guiDPIFactor - 1)));
YWidget.editHandles = [];
YWidget.currentEdited = null;
var gaugeWidget = class extends YWidget {
  getPropertiesXml() {
    return this.prop.getXml(1);
  }
  containerResized() {
    if (this._gauge != null)
      this._gauge.containerResized();
  }
  destroy() {
    this.prop.destroy();
    super.destroy();
    Object.entries(this).forEach((pair) => {
      Reflect.set(this, pair[0], null);
    });
  }
  contextMenuIsOpening() {
    YWebPage.snapshotMenuItem.userdata = this;
    YWebPage.snapshotMenuItem.visible = true;
    YWebPage.resetDataViewMenuItem.visible = false;
    if (YWebPage.editMenuItem == null)
      return;
    YWebPage.clearDataloggerMenuItem.visible = true;
    YWebPage.editMenuItem.caption = "Configure this gauge";
    YWebPage.editMenuItem.visible = true;
    YWebPage.deleteMenuItem.caption = "Delete this gauge";
    YWebPage.deleteMenuItem.visible = true;
    YWebPage.addMarkerMenuItem.visible = false;
    YWebPage.disableMarkerMenuItem.visible = false;
    YWebPage.editMenuItem.userdata = this;
    YWebPage.deleteMenuItem.userdata = this;
  }
  get confirmDeleteString() {
    return "Do you really want to delete this gauge ?";
  }
  AnnotationCallback(text) {
    let sensor = this.prop.DataSource_source;
    return this.PatchSensorAnnotationCallback(sensor, text);
  }
  constructor(node, editor, x, y, width, height) {
    super(node, editor, x, y, width, height);
    this._gauge = new YSolidGauge(this.UIContainer, YSolidGauge.DisplayMode.DISPLAY90, YWidget.log);
    this._genRenderer = this._gauge;
    this.noDataSourcepanel = this._gauge.addMessagePanel();
    this.noDataSourcepanel.font.size = constants.generalFontSize;
    this.noDataSourcepanel.text = 'No data source configured\n 1 - Make sure you have a Yoctopuce sensor connected.\n 2 - Do a right-click or a long touch on this widget.\n 3 - Choose "Configure this gauge" to bring up the properties editor.\n 4 - Choose a data source\n';
    this.prop = new GaugeFormProperties(node, this);
    this._genProp = this.prop;
    let propDesc = GenericProperties.getAllProperties(this.prop);
    if (gaugeWidget.AnnotationPanelCount == 0) {
      for (let propname in propDesc.byName) {
        if (propname.startsWith("SolidGauge_annotationPanel"))
          gaugeWidget.AnnotationPanelCount++;
      }
    }
    for (let i = 0; i < gaugeWidget.AnnotationPanelCount; i++) {
      this._gauge.addAnnotationPanel();
    }
    this._gauge.setPatchAnnotationCallback((s) => {
      return this.AnnotationCallback(s);
    });
    this._gauge.valueFormater = (source, value) => {
      return this.valueFormater(source, value);
    };
    this.updateWindowPositionProperties(this.prop);
    this.prop.ApplyAllProperties(this);
    YDataRenderer.minMaxCheckDisabled = true;
    this.prop.ApplyAllProperties(this._gauge);
    YDataRenderer.minMaxCheckDisabled = false;
    this._gauge.resetRefrenceSize();
    this._gauge.resizeRule = Proportional.ResizeRule.RELATIVETOBOTH;
    this.ApplyRelativeSizeIfRequired();
    if (this.SizeIsRelative)
      this.refreshProperties();
    this._gauge.AllowRedraw();
  }
  valueFormater(source, value) {
    if (this.prop.DataSource_source instanceof NullYSensor) {
      return "N/A";
    } else if (!this.prop.DataSource_source.isOnline())
      return "OFFLINE";
    let format = this.prop.DataSource_precision;
    let p = format.indexOf(".");
    let n = 0;
    if (p >= 0)
      n = format.length - p - 1;
    let unit = this.prop.DataSource_source.get_unit();
    return value.toFixed(n) + unit;
  }
  PropertyChanged2(src) {
    let info = new PropPathinfo();
    let path = src.ExtractPropPath(info);
    switch (info.propType) {
      case "Form":
        GenericProperties.copyProperty_STT(this, this.prop, info.fullpropname, path);
        break;
      case "SolidGauge":
        GenericProperties.copyProperty_STT(this._gauge, this.prop, info.fullpropname, path);
        break;
      case "DataSource":
        break;
    }
  }
  Get_PropertyValue(src) {
    let info = new PropPathinfo();
    let path = src.ExtractPropPath(info);
    switch (info.propType) {
      case "Form":
        return GenericProperties.newGetProperty(this, this.prop, info.fullpropname, path, null);
      case "SolidGauge":
        return GenericProperties.newGetProperty(this._gauge, this.prop, info.fullpropname, path, null);
    }
    return null;
  }
  edit() {
    super.edit();
    YWebPage.EditObject(this, this.prop, (src) => {
      this.PropertyChanged2(src);
    }, (src) => {
      return this.Get_PropertyValue(src);
    }, () => {
      this.editStopped();
    });
  }
  refreshProperties() {
    this.prop.RefreshAllProperties(this);
    this.prop.RefreshAllProperties(this._gauge);
    YWebPage.refreshPropertiesForm();
  }
  SourceChanged(value, index) {
    this.noDataSourcepanel.enabled = value instanceof NullYSensor;
    if (value instanceof NullYSensor) {
      this._gauge.value = 0;
    } else {
      value.registerCallback(this);
    }
  }
  SensorValuecallback(source, M) {
    if (this.prop == null)
      return;
    if (source == this.prop.DataSource_source) {
      this._gauge.value = source.isOnline() ? M.get_averageValue() : 0;
    }
  }
  getConfigData() {
    return "<GaugeForm>\n" + this.getContentsConfigData() + "</GaugeForm>\n";
  }
};
gaugeWidget.AnnotationPanelCount = 0;
var angularGaugeWidget = class extends YWidget {
  getPropertiesXml() {
    return this.prop.getXml(1);
  }
  containerResized() {
    if (this._angularGauge != null)
      this._angularGauge.containerResized();
  }
  destroy() {
    this.prop.destroy();
    super.destroy();
    Object.entries(this).forEach((pair) => {
      Reflect.set(this, pair[0], null);
    });
  }
  AnnotationCallback(text) {
    let sensor = this.prop.DataSource_source;
    return this.PatchSensorAnnotationCallback(sensor, text);
  }
  contextMenuIsOpening() {
    YWebPage.snapshotMenuItem.userdata = this;
    YWebPage.snapshotMenuItem.visible = true;
    YWebPage.resetDataViewMenuItem.visible = false;
    if (YWebPage.editMenuItem == null)
      return;
    YWebPage.clearDataloggerMenuItem.visible = false;
    YWebPage.editMenuItem.caption = "Configure this gauge";
    YWebPage.editMenuItem.visible = true;
    YWebPage.deleteMenuItem.caption = "Delete this gauge";
    YWebPage.deleteMenuItem.visible = true;
    YWebPage.addMarkerMenuItem.visible = false;
    YWebPage.disableMarkerMenuItem.visible = false;
    YWebPage.editMenuItem.userdata = this;
    YWebPage.deleteMenuItem.userdata = this;
  }
  get confirmDeleteString() {
    return "Do you really want to delete this gauge ?";
  }
  constructor(node, editor, x, y, width, height) {
    super(node, editor, x, y, width, height);
    this._angularGauge = new YAngularGauge(this.UIContainer, YWidget.log);
    this._genRenderer = this._angularGauge;
    this.noDataSourcepanel = this._angularGauge.addMessagePanel();
    this.noDataSourcepanel.font.size = constants.generalFontSize;
    this.noDataSourcepanel.text = 'No data source configured\n 1 - Make sure you have a Yoctopuce sensor connected.\n 2 - Do a right-click  or a long touch on this widget.\n 3 - Choose "Configure this gauge" to bring up the properties editor.\n 4 - Choose a data source\n';
    this.prop = new AngularGaugeFormProperties(node, this);
    this._genProp = this.prop;
    let propDesc = GenericProperties.getAllProperties(this.prop);
    if (angularGaugeWidget.AnnotationPanelCount == 0) {
      for (let propname in propDesc.byName) {
        if (propname.startsWith("AngularGauge_annotationPanel"))
          angularGaugeWidget.AnnotationPanelCount++;
        if (propname.startsWith("AngularGauge_zone"))
          angularGaugeWidget.zonesCount++;
      }
    }
    for (let i = 0; i < angularGaugeWidget.zonesCount; i++) {
      this._angularGauge.AddZone();
    }
    for (let i = 0; i < angularGaugeWidget.AnnotationPanelCount; i++) {
      this._angularGauge.addAnnotationPanel();
    }
    this._angularGauge.setPatchAnnotationCallback((s) => {
      return this.AnnotationCallback(s);
    });
    this.initDataNode = node;
    this.updateWindowPositionProperties(this.prop);
    this.prop.ApplyAllProperties(this);
    YDataRenderer.minMaxCheckDisabled = true;
    this.prop.ApplyAllProperties(this._angularGauge);
    YDataRenderer.minMaxCheckDisabled = false;
    this._angularGauge.resetRefrenceSize();
    this._angularGauge.resizeRule = Proportional.ResizeRule.RELATIVETOBOTH;
    this.ApplyRelativeSizeIfRequired();
    if (this.SizeIsRelative)
      this.refreshProperties();
    this._angularGauge.AllowRedraw();
  }
  PropertyChanged2(src) {
    let info = new PropPathinfo();
    let path = src.ExtractPropPath(info);
    switch (info.propType) {
      case "Form":
        GenericProperties.copyProperty_STT(this, this.prop, info.fullpropname, path);
        break;
      case "AngularGauge":
        GenericProperties.copyProperty_STT(this._angularGauge, this.prop, info.fullpropname, path);
        break;
      case "DataSource":
        break;
    }
  }
  Get_PropertyValue(src) {
    let info = new PropPathinfo();
    let path = src.ExtractPropPath(info);
    switch (info.propType) {
      case "Form":
        return GenericProperties.newGetProperty(this, this.prop, info.fullpropname, path, null);
      case "AngularGauge":
        return GenericProperties.newGetProperty(this._angularGauge, this.prop, info.fullpropname, path, null);
    }
    return null;
  }
  edit() {
    super.edit();
    YWebPage.EditObject(this, this.prop, (src) => {
      this.PropertyChanged2(src);
    }, (src) => {
      return this.Get_PropertyValue(src);
    }, () => {
      this.editStopped();
    });
  }
  refreshProperties() {
    this.prop.RefreshAllProperties(this);
    this.prop.RefreshAllProperties(this._angularGauge);
    YWebPage.refreshPropertiesForm();
  }
  showStatus(status) {
    if (status != "")
      this._angularGauge.value = 0;
    this._angularGauge.showNeedle = status == "";
    this._angularGauge.statusLine = status;
  }
  SourceChanged(value, index) {
    this._angularGauge.DisableRedraw();
    this.noDataSourcepanel.enabled = value instanceof NullYSensor;
    if (value instanceof NullYSensor) {
      this.showStatus("N/A");
      this._angularGauge.unit = "";
    } else if (!value.isOnline()) {
      this.showStatus("OFFLINE");
    } else {
      this.showStatus("");
      this._angularGauge.unit = value.get_unit();
    }
    this._angularGauge.AllowRedraw();
    value.registerCallback(this);
  }
  SensorValuecallback(source, M) {
    if (this.prop == null)
      return;
    if (source == this.prop.DataSource_source) {
      this._angularGauge.DisableRedraw();
      if (this.prop.DataSource_source instanceof NullYSensor) {
        this.showStatus("N/A");
        this._angularGauge.unit = "";
      } else if (!this.prop.DataSource_source.isOnline()) {
        this.showStatus("OFFLINE");
      } else {
        this._angularGauge.DisableRedraw();
        this.showStatus("");
        this._angularGauge.unit = source.get_unit();
        this._angularGauge.value = M.get_averageValue();
        this._angularGauge.AllowRedraw();
      }
      this._angularGauge.AllowRedraw();
    }
  }
  getConfigData() {
    return "<angularGaugeForm>\n" + this.getContentsConfigData() + "</angularGaugeForm>\n";
  }
};
angularGaugeWidget.AnnotationPanelCount = 0;
angularGaugeWidget.zonesCount = 0;
var digitalDisplayWidget = class extends YWidget {
  getPropertiesXml() {
    return this.prop.getXml(1);
  }
  containerResized() {
    if (this._display != null)
      this._display.containerResized();
  }
  destroy() {
    this.prop.destroy();
    super.destroy();
    Object.entries(this).forEach((pair) => {
      Reflect.set(this, pair[0], null);
    });
  }
  AnnotationCallback(text) {
    let sensor = this.prop.DataSource_source;
    return this.PatchSensorAnnotationCallback(sensor, text);
  }
  contextMenuIsOpening() {
    YWebPage.snapshotMenuItem.userdata = this;
    YWebPage.snapshotMenuItem.visible = true;
    YWebPage.resetDataViewMenuItem.visible = false;
    if (YWebPage.editMenuItem == null)
      return;
    YWebPage.clearDataloggerMenuItem.visible = false;
    YWebPage.editMenuItem.caption = "Configure this digital display";
    YWebPage.editMenuItem.visible = true;
    YWebPage.deleteMenuItem.caption = "Delete this digital display";
    YWebPage.deleteMenuItem.visible = true;
    YWebPage.addMarkerMenuItem.visible = false;
    YWebPage.disableMarkerMenuItem.visible = false;
    YWebPage.editMenuItem.userdata = this;
    YWebPage.deleteMenuItem.userdata = this;
  }
  get confirmDeleteString() {
    return "Do you really want to delete this digital display ?";
  }
  constructor(node, editor, x, y, width, height) {
    super(node, editor, x, y, width, height);
    this._unit = "";
    this._display = new YDigitalDisplay(this.UIContainer, YWidget.log);
    this._genRenderer = this._display;
    this.noDataSourcepanel = this._display.addMessagePanel();
    this.noDataSourcepanel.font.size = constants.generalFontSize;
    this.noDataSourcepanel.text = 'No data source configured\n 1 - Make sure you have a Yoctopuce sensor connected.\n 2 - Do a right-click  or a long touch on this widget.\n 3 - Choose "Configure this digital display" to bring up the properties editor.\n 4 - Choose a data source\n';
    this.prop = new digitalDisplayFormProperties(node, this);
    this._genProp = this.prop;
    let propDesc = GenericProperties.getAllProperties(this.prop);
    if (digitalDisplayWidget.AnnotationPanelCount == 0) {
      for (let propname in propDesc.byName) {
        if (propname.startsWith("display_annotationPanel"))
          digitalDisplayWidget.AnnotationPanelCount++;
      }
    }
    for (let i = 0; i < digitalDisplayWidget.AnnotationPanelCount; i++) {
      this._display.addAnnotationPanel();
    }
    this._display.setPatchAnnotationCallback((s) => {
      return this.AnnotationCallback(s);
    });
    this._display.valueFormater = (source, value) => {
      return this.valueFormater(source, value);
    };
    this.updateWindowPositionProperties(this.prop);
    this.prop.ApplyAllProperties(this);
    YDataRenderer.minMaxCheckDisabled = true;
    this.prop.ApplyAllProperties(this._display);
    YDataRenderer.minMaxCheckDisabled = false;
    this._display.resetRefrenceSize();
    this._display.AllowPrintScreenCapture = true;
    this._display.resetRefrenceSize();
    this._display.resizeRule = Proportional.ResizeRule.RELATIVETOBOTH;
    this.ApplyRelativeSizeIfRequired();
    if (this.SizeIsRelative)
      this.refreshProperties();
    this._display.AllowRedraw();
  }
  valueFormater(source, value) {
    if (this.prop.DataSource_source instanceof NullYSensor) {
      return "N/A";
    } else if (!this.prop.DataSource_source.isOnline())
      return "OFFLINE";
    let format = this.prop.DataSource_precision;
    let p = format.indexOf(".");
    let n = 0;
    if (p >= 0)
      n = format.length - p - 1;
    let unit = this.prop.DataSource_source.get_unit();
    return value.toFixed(n) + unit;
  }
  PropertyChanged2(src) {
    let info = new PropPathinfo();
    let path = src.ExtractPropPath(info);
    switch (info.propType) {
      case "Form":
        GenericProperties.copyProperty_STT(this, this.prop, info.fullpropname, path);
        break;
      case "display":
        GenericProperties.copyProperty_STT(this._display, this.prop, info.fullpropname, path);
        break;
      case "DataSource":
        break;
    }
  }
  Get_PropertyValue(src) {
    let info = new PropPathinfo();
    let path = src.ExtractPropPath(info);
    switch (info.propType) {
      case "Form":
        return GenericProperties.newGetProperty(this, this.prop, info.fullpropname, path, null);
      case "display":
        return GenericProperties.newGetProperty(this._display, this.prop, info.fullpropname, path, null);
    }
    return null;
  }
  edit() {
    super.edit();
    YWebPage.EditObject(this, this.prop, (src) => {
      this.PropertyChanged2(src);
    }, (src) => {
      return this.Get_PropertyValue(src);
    }, () => {
      this.editStopped();
    });
  }
  refreshProperties() {
    this.prop.RefreshAllProperties(this);
    this.prop.RefreshAllProperties(this._display);
    YWebPage.refreshPropertiesForm();
  }
  SourceChanged(value, index) {
    this.noDataSourcepanel.enabled = value instanceof NullYSensor;
    this.SensorValuecallback(value, null);
    if (value instanceof NullYSensor) {
      this._display.alternateValue = "N/A";
    } else if (!value.isOnline())
      this._display.alternateValue = "OFFLINE";
    value.registerCallback(this);
  }
  SensorValuecallback(source, M) {
    if (this.prop == null)
      return;
    if (this.prop.DataSource_source instanceof NullYSensor) {
      this._display.alternateValue = "N/A";
    } else if (!this.prop.DataSource_source.isOnline()) {
      this._display.alternateValue = "OFFLINE";
    } else if (M == null) {
      this._display.alternateValue = "--" + this._unit;
    } else if (source == this.prop.DataSource_source) {
      this._display.DisableRedraw();
      this._display.alternateValue = null;
      this._display.value = M.get_averageValue();
      this._display.AllowRedraw();
    }
  }
  getConfigData() {
    return "<digitalDisplayForm>\n" + this.getContentsConfigData() + "</digitalDisplayForm>\n";
  }
};
digitalDisplayWidget.AnnotationPanelCount = 0;
var graphWidget = class extends YWidget {
  AnnotationCallback(text) {
    for (let i = 0; i < graphWidget.SeriesCount; i++) {
      let s = Reflect.get(this.prop, "Graph_series" + i.toString());
      let sensor = s.DataSource_source;
      let name = "None";
      let avgvalue = "N/A";
      let minvalue = "N/A";
      let maxvalue = "N/A";
      let unit = "";
      if (!(sensor instanceof NullYSensor)) {
        let resolution = -Math.round(Math.log10(sensor.get_resolution()));
        name = s.legend != "" ? s.legend : sensor.get_friendlyName();
        if (sensor.isOnline()) {
          avgvalue = sensor.get_lastAvgValue().toFixed(resolution);
          minvalue = sensor.get_lastMinValue().toFixed(resolution);
          maxvalue = sensor.get_lastMaxValue().toFixed(resolution);
        }
        unit = sensor.get_unit();
      }
      text = text.replace("$NAME" + (i + 1).toString() + "$", name);
      text = text.replace("$AVGVALUE" + (i + 1).toString() + "$", avgvalue);
      text = text.replace("$MAXVALUE" + (i + 1).toString() + "$", maxvalue);
      text = text.replace("$MINVALUE" + (i + 1).toString() + "$", minvalue);
      text = text.replace("$UNIT" + (i + 1).toString() + "$", unit);
    }
    return text;
  }
  destroy() {
    this.prop.destroy();
    super.destroy();
    Object.entries(this).forEach((pair) => {
      Reflect.set(this, pair[0], null);
    });
  }
  getPropertiesXml() {
    return this.prop.getXml(1);
  }
  containerResized() {
    if (this._graph != null)
      this._graph.containerResized();
  }
  contextMenuIsOpening() {
    YWebPage.snapshotMenuItem.userdata = this;
    YWebPage.snapshotMenuItem.visible = true;
    YWebPage.resetDataViewMenuItem.visible = true;
    YWebPage.resetDataViewMenuItem.userdata = this;
    if (YWebPage.editMenuItem == null)
      return;
    YWebPage.clearDataloggerMenuItem.visible = true;
    YWebPage.clearDataloggerMenuItem.userdata = this;
    YWebPage.editMenuItem.caption = "Configure this graph";
    YWebPage.editMenuItem.visible = true;
    YWebPage.deleteMenuItem.caption = "Delete this graph";
    YWebPage.deleteMenuItem.visible = true;
    YWebPage.addMarkerMenuItem.visible = true;
    YWebPage.disableMarkerMenuItem.visible = true;
    YWebPage.editMenuItem.userdata = this;
    YWebPage.deleteMenuItem.userdata = this;
    YWebPage.disableMarkerMenuItem.userdata = this;
    for (let i = 0; i < YWebPage.markersSubMenuItems.length; i++) {
      YWebPage.markersSubMenuItems[i].caption = "Place marker #" + (i + 1).toString();
      YWebPage.markersSubMenuItems[i].userdata = this;
    }
  }
  startMarkerCapture(markerIndex) {
    this.markers[markerIndex].startCapture();
  }
  AxisParamtersChangedAutomatically(source) {
    let yaxis = source.userData;
    yaxis.visible = source.visible;
    YWebPage.refreshPropertiesForm();
  }
  get confirmDeleteString() {
    return "Do you really want to delete this graph ?";
  }
  constructor(node, editor, x, y, width, height) {
    super(node, editor, x, y, width, height);
    this.editedMarkerWasEnabled = false;
    this.editedMarkerPosition = 0;
    this._graph = new YGraph(this.UIContainer, YWidget.log);
    this.noDataSourcepanel = this._graph.addMessagePanel();
    this.noDataSourcepanel.font.size = constants.generalFontSize;
    this.noDataSourcepanel.text = 'No data source configured\n 1 - Make sure you have a Yoctopuce sensor connected.\n 2 - Do a right-click  or a long touch on this widget.\n 3 - Choose "Configure this graph" to bring up the properties editor.\n 4 - Choose a data source\n';
    this.dataloggerProgress = this._graph.addMessagePanel();
    this.dataloggerProgress.font.size = 12 * constants.guiDPIFactor;
    this.dataloggerProgress.font.color = YColor.DarkGray;
    this.dataloggerProgress.borderColor = YColor.Gray;
    this.dataloggerProgress.panelHrzAlign = MessagePanel.HorizontalAlignPos.LEFT;
    this.dataloggerProgress.panelVrtAlign = MessagePanel.VerticalAlignPos.TOP;
    this.dataloggerProgress.text = graphWidget.DataLoggerLoadingMsg;
    this.dataloggerProgress.enabled = false;
    this.prop = new GraphFormProperties(node, this);
    this._genProp = this.prop;
    let propDesc = GenericProperties.getAllProperties(this.prop);
    if (graphWidget.YAxisCount == 0) {
      for (let propname in propDesc.byName) {
        if (propname.startsWith("Graph_annotationPanel"))
          graphWidget.AnnotationPanelCount++;
        if (propname.startsWith("Graph_series"))
          graphWidget.SeriesCount++;
        if (propname.startsWith("Graph_yAxes"))
          graphWidget.YAxisCount++;
      }
    }
    if (graphWidget.ZoneCountPerYaxis == 0) {
      let yAxisProp = new YaxisDescription(0, false);
      let propDesc2 = GenericProperties.getAllProperties(yAxisProp);
      for (let propname in propDesc2.byName) {
        if (propname.startsWith("zones"))
          graphWidget.ZoneCountPerYaxis++;
      }
    }
    if (graphWidget.MarkerCountPerXaxis == 0) {
      let xAxisProp = new XaxisDescription();
      let propDesc2 = GenericProperties.getAllProperties(xAxisProp);
      for (let propname in propDesc2.byName) {
        if (propname.startsWith("markers"))
          graphWidget.MarkerCountPerXaxis++;
      }
    }
    this.offLineSourcesPanel = this._graph.addMessagePanel();
    this.offLineSourcesPanel.bgColor = YColor.FromArgb(192, 255, 192, 192);
    this.offLineSourcesPanel.borderColor = YColor.DarkRed;
    this.offLineSourcesPanel.font.color = YColor.DarkRed;
    this.offLineSourcesPanel.panelHrzAlign = MessagePanel.HorizontalAlignPos.RIGHT;
    this.offLineSourcesPanel.panelVrtAlign = MessagePanel.VerticalAlignPos.TOP;
    this.captureRunningPanel = this._graph.addMessagePanel();
    this.captureRunningPanel.bgColor = YColor.FromArgb(240, 200, 255, 193);
    this.captureRunningPanel.borderColor = YColor.DarkGreen;
    this.captureRunningPanel.font.color = YColor.DarkGreen;
    this.captureRunningPanel.panelHrzAlign = MessagePanel.HorizontalAlignPos.LEFT;
    this.captureRunningPanel.panelVrtAlign = MessagePanel.VerticalAlignPos.TOP;
    for (let i = 0; i < graphWidget.YAxisCount; i++) {
      let axis = this._graph.addYAxis();
      for (let j = 0; j < graphWidget.ZoneCountPerYaxis; j++) {
        axis.AddZone();
      }
    }
    this.markers = [];
    for (let i = 0; i < graphWidget.MarkerCountPerXaxis; i++) {
      let m = this._graph.xAxis.AddMarker();
      m.xposition = TimeConverter.ToUnixTime(new Date()) + i * 60;
      this.markers.push(m);
    }
    for (let i = 0; i < graphWidget.AnnotationPanelCount; i++) {
      this._graph.addAnnotationPanel();
    }
    this.seriesProperties = [];
    for (let i = 0; i < graphWidget.SeriesCount; i++) {
      this.seriesProperties.push(Reflect.get(this.prop, "Graph_series" + i.toString()));
      this._graph.addSerie();
    }
    this._graph.yAxes[0].visible = true;
    this._graph.setPatchAnnotationCallback((s) => {
      return this.AnnotationCallback(s);
    });
    this._genRenderer = this._graph;
    this._graph.resetRefrenceSize();
    this._graph.AllowPrintScreenCapture = true;
    this._graph.setMarkerCaptureCallbacks((m) => {
      this.MarkedCaptureStarted(m);
    }, (m) => {
      this.MarkedCaptureStopped(m);
    });
    this.offlineMessages = new Array(graphWidget.SeriesCount);
    this.showOffline = new Array(graphWidget.SeriesCount);
    this.updateWindowPositionProperties(this.prop);
    this.prop.ApplyAllProperties(this);
    YDataRenderer.minMaxCheckDisabled = true;
    this.prop.ApplyAllProperties(this._graph);
    YDataRenderer.minMaxCheckDisabled = false;
    for (let i = 0; i < graphWidget.YAxisCount; i++) {
      this._graph.yAxes[i].AxisChanged = () => {
        this.AxisParamtersChangedAutomatically(this._graph.yAxes[i]);
      };
      this._graph.yAxes[i].AllowAutoShow = true;
    }
    for (let i = 0; i < graphWidget.SeriesCount; i++) {
      let s = Reflect.get(this.prop, "Graph_series" + i.toString());
      s.Init(this, i);
      if (s.DataSource_source != null) {
        this.SourceChanged(s.DataSource_source, i);
      }
    }
    this._graph.resetRefrenceSize();
    this._graph.resizeRule = Proportional.ResizeRule.FIXED;
    this.ApplyRelativeSizeIfRequired();
    if (this.SizeIsRelative)
      this.refreshProperties();
    this.loadRecordedDataIfNeeded();
    this._graph.AllowRedraw();
  }
  MarkedCaptureStarted(src) {
    let str = src.text != "" ? 'Click to place the "' + src.shortText + '" marker.' : "Click to place the marker.";
    str += "\nRight-click to cancel the operation.";
    this.editedMarkerWasEnabled = src.enabled;
    this.editedMarkerPosition = src.positionOnXAxis.value;
    this.captureRunningPanel.text = str;
    this.captureRunningPanel.enabled = true;
  }
  MarkedCaptureStopped(src) {
    if (src != null) {
      if (this.editedMarkerWasEnabled != src.enabled && this.editedMarkerPosition != src.positionOnXAxis.value) {
        constants.edited = true;
      }
    }
    this.captureRunningPanel.enabled = false;
    this.refreshProperties();
  }
  refreshProperties() {
    this.prop.RefreshAllProperties(this);
    this.prop.RefreshAllProperties(this._graph);
    YWebPage.refreshPropertiesForm();
  }
  decomposeToSegments(data, start, dataCount) {
    let n1 = start;
    let n2 = 0;
    let l = [];
    let deltaT = 0;
    while (n1 < start + dataCount - 1) {
      try {
        deltaT = data[n1 + 1].DateTime - data[n1].DateTime;
      } catch (Exception) {
        debugger;
      }
      n2 = n1 + 1;
      while (n2 < dataCount && data[n2].DateTime - data[n2 - 1].DateTime < 2 * deltaT) {
        n2++;
      }
      let count = n2 - n1;
      if (count > 0) {
        let p = new Array(count);
        for (let i = 0; i < count; i++) {
          p[i] = new pointXY(data[n1 + i].DateTime, data[n1 + i].value);
        }
        l.push(p);
      }
      n1 = n2;
    }
    return l;
  }
  SourceChanged(value, index) {
    this._graph.DisableRedraw();
    let s;
    let noDataSource = true;
    for (let i = 0; i < graphWidget.SeriesCount; i++) {
      s = Reflect.get(this.prop, "Graph_series" + i.toString());
      if (!(s.DataSource_source instanceof NullYSensor))
        noDataSource = false;
    }
    this.noDataSourcepanel.enabled = noDataSource;
    if (value != null) {
      if (!(value instanceof NullYSensor)) {
        if (value.isOnline()) {
          this.showOffline[index] = false;
        } else {
          this.offlineMessages[index] = value.get_friendlyName() + " is OFFLINE";
          this.showOffline[index] = true;
          logForm.log(value.get_friendlyName() + " is OFFLINE");
        }
      } else {
        this.showOffline[index] = false;
      }
    } else {
      this.showOffline[index] = false;
    }
    this.updateOfflinePanel();
    this.preLoadSensorData(value, index);
    this.loadRecordedDataIfNeeded();
    if (value)
      value.registerCallback(this);
    this._graph.AllowRedraw();
  }
  SensorArrivalcallback(source) {
    this.loadRecordedDataIfNeeded();
  }
  preLoadSensorData(value, index) {
    if (value instanceof NullYSensor) {
      this._graph.series[index].clear();
      return;
    }
    let s = Reflect.get(this.prop, "Graph_series" + index.toString());
    let data;
    switch (s.DataSource_datatype) {
      case 1:
        data = value.minData;
        break;
      case 2:
        data = value.maxData;
        break;
      default:
        data = value.curData;
        break;
    }
    let l = this.decomposeToSegments(data, 0, data.length);
    this._graph.series[index].clear();
    for (let i = l.length - 1; i >= 0; i--) {
      this._graph.series[index].InsertPoints(l[i]);
    }
    this._graph.series[index].rebuildSummaries();
  }
  PropertyChanged2(src) {
    let info = new PropPathinfo();
    let path = src.ExtractPropPath(info);
    switch (info.propType) {
      case "Form":
        GenericProperties.copyProperty_STT(this, this.prop, info.fullpropname, path);
        break;
      case "Graph":
        GenericProperties.copyProperty_STT(this._graph, this.prop, info.fullpropname, path);
        break;
      case "DataSource":
        break;
    }
  }
  Get_PropertyValue(src) {
    let info = new PropPathinfo();
    let path = src.ExtractPropPath(info);
    switch (info.propType) {
      case "Form":
        return GenericProperties.newGetProperty(this, this.prop, info.fullpropname, path, null);
      case "Graph":
        return GenericProperties.newGetProperty(this._graph, this.prop, info.fullpropname, path, null);
      case "DataSource":
        return null;
    }
    return null;
  }
  edit() {
    super.edit();
    YWebPage.EditObject(this, this.prop, (src) => {
      this.PropertyChanged2(src);
    }, (src) => {
      return this.Get_PropertyValue(src);
    }, () => {
      this.editStopped();
    });
  }
  updateOfflinePanel() {
    let message = "";
    for (let i = 0; i < graphWidget.SeriesCount; i++) {
      if (this.showOffline[i])
        message = message + (message != "" ? "\n" : "") + this.offlineMessages[i];
    }
    if (message == "" && this.offLineSourcesPanel.enabled)
      this.offLineSourcesPanel.enabled = false;
    if (message != "" && (this.offLineSourcesPanel.text != message || !this.offLineSourcesPanel.enabled)) {
      this.offLineSourcesPanel.text = message;
      this.offLineSourcesPanel.enabled = true;
    }
  }
  SensorValuecallback(source, M) {
    if (this.prop == null)
      return;
    for (let i = 0; i < graphWidget.SeriesCount; i++) {
      let s = this.seriesProperties[i];
      if (s.DataSource_source == source) {
        if (!s.DataSource_source.isOnline()) {
          this.offlineMessages[i] = s.DataSource_source.get_friendlyName() + " is OFFLINE";
          this.showOffline[i] = true;
          this.updateOfflinePanel();
          return;
        }
        this.showOffline[i] = false;
        this.updateOfflinePanel();
        let index = s.DataSource_source.curData.length - 1;
        if (index >= 0)
          switch (s.DataSource_datatype) {
            case 1:
              this._graph.series[i].AddPoint(new pointXY(s.DataSource_source.minData[index].DateTime, s.DataSource_source.minData[index].value));
              break;
            case 2:
              this._graph.series[i].AddPoint(new pointXY(s.DataSource_source.maxData[index].DateTime, s.DataSource_source.maxData[index].value));
              break;
            default:
              this._graph.series[i].AddPoint(new pointXY(s.DataSource_source.curData[index].DateTime, s.DataSource_source.curData[index].value));
              break;
          }
        this._graph.series[i].unit = s.DataSource_source.get_unit();
      }
    }
  }
  disableAllMarkers() {
    confirm.ask("Do you really want to disable all markers?", () => {
      for (let i = 0; i < this.markers.length; i++) {
        this.markers[i].enabled = false;
      }
    }, () => {
    }, null);
  }
  clearDataLogger() {
    confirm.ask("Do you really want to erase contents of all dataloggers related to this graph?", () => {
      this.startToClearDataLoggers();
    }, () => {
    }, null);
  }
  truncateView() {
    for (let i = 0; i < graphWidget.SeriesCount; i++) {
      this._graph.series[i].clear();
    }
    let FirstLiveValue = Math.floor(new Date().getTime() / 1e3);
    this._graph.xAxis.set_minMax(FirstLiveValue, FirstLiveValue + this._graph.xAxis.initialZoom);
  }
  resetDataView() {
    this.prop.Graph_showRecordedData = false;
    this.truncateView();
  }
  async startToClearDataLoggers() {
    let loggers = [];
    for (let i = 0; i < graphWidget.SeriesCount; i++) {
      let s = Reflect.get(this.prop, "Graph_series" + i.toString());
      let sensor = s.DataSource_source;
      if (!(sensor instanceof NullYSensor)) {
        sensor.stopDataloggerloading();
        let serial = sensor.get_hardwareId();
        let n = serial.indexOf(".");
        serial = serial.substring(0, n);
        let d = await YDataLogger.FindDataLogger(serial + ".dataLogger");
        if (await d.isOnline()) {
          let found = false;
          for (let j = 0; j < loggers.length; j++) {
            if (loggers[j] == d)
              found = true;
          }
          if (!found)
            loggers.push(d);
        }
      }
    }
    for (let i = 0; i < loggers.length; i++) {
      await loggers[i].forgetAllDataStreams();
      await loggers[i].set_recording(YDataLogger.RECORDING_ON);
    }
    let tmp = this.prop.Graph_showRecordedData;
    this.prop.Graph_showRecordedData = false;
    this.truncateView();
    this.prop.Graph_showRecordedData = tmp;
  }
  dataLoggerLoadprocessIsRunningNotification(source) {
    let loadTotalPercent = 0;
    let sensorCount = 0;
    if (!this.prop.Graph_showRecordedData)
      return;
    for (let i = 0; i < graphWidget.SeriesCount; i++) {
      let s = Reflect.get(this.prop, "Graph_series" + i.toString());
      let sensor = s.DataSource_source;
      if (sensor.dataloggerLoadisRunning) {
        loadTotalPercent += sensor.dataloggerLoadProgress;
        sensorCount++;
      }
    }
    if (sensorCount > 0)
      this.dataloggerProgress.text = graphWidget.DataLoggerLoadingMsg + " (" + (loadTotalPercent / sensorCount).toFixed(0) + "%)";
    let showPanel = sensorCount > 0 && loadTotalPercent > 0 && loadTotalPercent < sensorCount * 100;
    this.dataloggerProgress.enabled = showPanel;
  }
  SensorNewDataBlock(source, sourceFromIndex, sourcetoIndex, targetIndex, fromDataLogger) {
    if (this.prop == null)
      return;
    if (fromDataLogger && !this.prop.Graph_showRecordedData)
      return;
    let l = null;
    for (let i = 0; i < graphWidget.SeriesCount; i++) {
      let s = Reflect.get(this.prop, "Graph_series" + i.toString());
      if (s.DataSource_source == source) {
        let count = sourcetoIndex - sourceFromIndex + 1;
        if (count > 1) {
          switch (s.DataSource_datatype) {
            case 1:
              l = this.decomposeToSegments(s.DataSource_source.minData, sourceFromIndex, count);
              for (let j = l.length - 1; j >= 0; j--) {
                this._graph.series[i].InsertPoints(l[j]);
              }
              break;
            case 2:
              l = this.decomposeToSegments(s.DataSource_source.maxData, sourceFromIndex, count);
              for (let j = l.length - 1; j >= 0; j--) {
                this._graph.series[i].InsertPoints(l[j]);
              }
              break;
            default:
              l = this.decomposeToSegments(s.DataSource_source.curData, sourceFromIndex, count);
              for (let j = l.length - 1; j >= 0; j--) {
                this._graph.series[i].InsertPoints(l[j]);
              }
              break;
          }
        }
      }
    }
  }
  loadRecordedDataIfNeeded() {
    if (this.prop == null)
      return;
    if (!this.prop.Graph_showRecordedData)
      return;
    for (let i = 0; i < graphWidget.SeriesCount; i++) {
      let s = Reflect.get(this.prop, "Graph_series" + i.toString());
      s.DataSource_source.startDataloggerload(this);
    }
  }
  removeDataloggerData() {
  }
  DataloggerCompleted(Source) {
    if (!this.prop.Graph_showRecordedData)
      return;
    let props = GenericProperties.getAllProperties(this.prop);
    for (let i = 0; i < this.seriesProperties.length; i++) {
      if (this.seriesProperties[i].DataSource_source == Source) {
        if (!this.seriesProperties[i].dataloggerAlreadyLoaded) {
          this._graph.DisableRedraw();
          this.preLoadSensorData(Source, i);
          this._graph.AllowRedraw();
        }
      }
    }
  }
  getConfigData() {
    return "<GraphForm>\n" + this.getContentsConfigData() + "</GraphForm>\n";
  }
};
graphWidget.AnnotationPanelCount = 0;
graphWidget.SeriesCount = 0;
graphWidget.ZoneCountPerYaxis = 0;
graphWidget.MarkerCountPerXaxis = 0;
graphWidget.YAxisCount = 0;
graphWidget.DataLoggerLoadingMsg = "Loading from datalogger";

// obj/full/propertiesMngmt.js
var YXmlNode = class {
  constructor(node) {
    this.node = node;
  }
  get Name() {
    return this.node.nodeName;
  }
  get_childsByName() {
    let res = {};
    this.node.childNodes.forEach((child) => {
      res[child.nodeName] = new YXmlNode(child);
    });
    return res;
  }
  get_childsByIndex() {
    let res = [];
    this.node.childNodes.forEach((child) => {
      res.push(new YXmlNode(child));
    });
    return res;
  }
  get_attributes() {
    let el = this.node;
    let res = {};
    let keys = el.getAttributeNames();
    for (let i = 0; i < keys.length; i++) {
      res[keys[i]] = el.getAttribute(keys[i]);
    }
    return res;
  }
  get Attributes() {
    return this.get_attributes();
  }
};
var PropertyAccess = class {
  constructor() {
    this.ttype = "";
    this.stype = "";
    this.finalTarget = null;
    this.terminalSource = null;
    this.propertyName = null;
  }
};
var doubleNan = class {
  constructor(v) {
    this._value = Number.NaN;
    if (typeof v == "undefined") {
      return;
    } else if (typeof v == "number") {
      this._value = v;
    } else if (typeof v == "string") {
      if (v == "") {
        this._value = Number.NaN;
      } else {
        this._value = Number(v);
      }
    } else {
      debugger;
    }
  }
  toString() {
    if (Number.isNaN(this._value))
      return "";
    return this._value.toString();
  }
  clone() {
    return new doubleNan(this.value);
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value;
  }
};
var PropertyDescriptor = class {
  constructor(name) {
    this.isWritable = false;
    this.isEnum = false;
    this.type = "";
    this.Attributes = {};
    this.name = name;
  }
};
var PropertiesList = class {
  constructor() {
    this.byIndex = [];
    this.byName = {};
  }
};
var PropDescription = class {
  constructor(name, prop) {
    this.name = name;
    this.prop = prop;
  }
};
var GenericProperties = class {
  static NoFilter(propNname) {
    return true;
  }
  static escapeXml(unsafe) {
    return unsafe.replace(/[^ !#$%(-;=?-z]/g, (c) => "&#" + c.charCodeAt(0) + ";");
  }
  constructor(Owner) {
    this._Form_Text = "New window";
    this._Form_BackColor = YColor.FromArgb(255, 240, 240, 240);
    this._Form_BorderColor = YColor.LightGray;
    this._SizeIsRelative = false;
    this._Form_PositionX = 0;
    this._Form_PositionY = 0;
    this._Form_Width = 300;
    this._Form_Height = 200;
    this._containerID = "";
    this.ownerForm = Owner;
    this._Form_Text = "new window";
  }
  destroy() {
    Object.entries(this).forEach((pair) => {
      Reflect.set(this, pair[0], null);
    });
  }
  initFromXmlData(initData) {
    if (initData != null)
      this.loadProperties(initData, this.ownerForm, this);
  }
  loadProperties(initData, Owner, o) {
    let value;
    this.ownerForm = Owner;
    if (initData != null) {
      let properties = GenericProperties.getAllProperties(o);
      let childs = initData.get_childsByName();
      for (let propname in properties.byName) {
        let p = properties.byName[propname];
        if (p.isWritable) {
          for (let childName in childs) {
            if (childName == propname) {
              let target = Reflect.get(o, propname);
              let Mustload = true;
              if ("NotSavedInXMLAttribute" in p.Attributes) {
                Mustload = p.Attributes["NotSavedInXMLAttribute"];
              }
              if (Mustload) {
                if (GenericProperties.IsStructured(target)) {
                  this.loadProperties(childs[childName], Owner, target);
                } else {
                  let targetType = typeof target;
                  let attributes = childs[childName].get_attributes();
                  let value2 = attributes["value"];
                  if (target instanceof CustomYSensor) {
                    if (value2.toUpperCase() != "NULL" && value2 != "") {
                      let s = sensorsManager.AddNewSensor(value2);
                      Reflect.set(o, propname, s);
                    } else {
                      Reflect.set(o, propname, sensorsManager.getNullSensor());
                    }
                  } else if (target instanceof YEnumItem) {
                    Reflect.set(o, propname, target.fromString(value2));
                  } else if (target instanceof doubleNan) {
                    let d = new doubleNan(value2);
                    Reflect.set(o, propname, d);
                  } else if (target instanceof xAxisPosition) {
                    let xpos = Number(value2);
                    let rel = attributes["relative"].toUpperCase() == "TRUE";
                    Reflect.set(o, propname, new xAxisPosition(xpos, rel));
                  } else if (target instanceof YColor) {
                    let c = YColor.FromString(value2);
                    if (c == null)
                      c = YColor.Black;
                    Reflect.set(o, propname, c.clone());
                  } else if (target instanceof YFont) {
                    let size = attributes["size"];
                    let color = attributes["color"];
                    let italic = attributes["italic"];
                    let bold = attributes["bold"];
                    let f = Reflect.get(o, propname);
                    f.name = value2;
                    f.size = size !== "undefined" ? Number(size) : 10;
                    let c = YColor.FromString(color);
                    f.color = c != null ? c : YColor.Black.clone();
                    f.italic = italic.toUpperCase() == "TRUE";
                    f.bold = bold.toUpperCase() == "TRUE";
                  } else {
                    switch (targetType) {
                      case "string":
                        Reflect.set(o, propname, value2);
                        break;
                      case "number":
                        Reflect.set(o, propname, Number(value2));
                        break;
                      case "boolean":
                        let v = value2.toUpperCase() == "TRUE";
                        Reflect.set(o, propname, v);
                        break;
                      default:
                        debugger;
                        throw "unhandled target type : " + targetType + "(" + target.constructor.name + ")";
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  get ATTR_Form_Text__DisplayName() {
    return "Window title";
  }
  get ATTR_Form_Text__CategoryAttribute() {
    return "Window";
  }
  get ATTR_Form_Text__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_Form_Text__DescriptionAttribute() {
    return "Widget name. This name is not show on display, but it might help you to identify each widget. ";
  }
  get Form_Text() {
    return this._Form_Text;
  }
  set Form_Text(value) {
    this._Form_Text = value;
  }
  get ATTR_Form_BackColor__DisplayName() {
    return "Background color";
  }
  get ATTR_Form_BackColor__CategoryAttribute() {
    return "Window";
  }
  get ATTR_Form_BackColor__DescriptionAttribute() {
    return "Window background color.";
  }
  get Form_BackColor() {
    return this._Form_BackColor;
  }
  set Form_BackColor(value) {
    this._Form_BackColor = value;
  }
  get ATTR_Form_BorderColor__DisplayName() {
    return "Border color";
  }
  get ATTR_Form_BorderColor__CategoryAttribute() {
    return "Window";
  }
  get ATTR_Form_BorderColor__DescriptionAttribute() {
    return "Window border color, use transparent color to hide the border.";
  }
  get Form_BorderColor() {
    return this._Form_BorderColor;
  }
  set Form_BorderColor(value) {
    this._Form_BorderColor = value;
  }
  get ATTR_Form_SizeIsRelative__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_Form_SizeIsRelative__DisplayName() {
    return "Rel. size and pos.";
  }
  get ATTR_Form_SizeIsRelative__CategoryAttribute() {
    return "Window";
  }
  get ATTR_Form_SizeIsRelative__DescriptionAttribute() {
    return "Makes widget size and position relative to container size. This, for instance, allows to make a widget automatically occupy all of the browser viewport, no matter the browser window size. In relative mode, position and size value are expressed in %";
  }
  get ATTR_Form_SizeIsRelative__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get Form_SizeIsRelative() {
    return this._SizeIsRelative;
  }
  set Form_SizeIsRelative(value) {
    this._SizeIsRelative = value;
  }
  get ATTR_Form_PositionX__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_Form_PositionX__DisplayName() {
    return "Left";
  }
  get ATTR_Form_PositionX__CategoryAttribute() {
    return "Window";
  }
  get ATTR_Form_PositionX__DescriptionAttribute() {
    return "Widget left border X position";
  }
  get Form_PositionX() {
    return this._Form_PositionX;
  }
  set Form_PositionX(value) {
    this._Form_PositionX = value;
  }
  get ATTR_Form_PositionY__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_Form_PositionY__DisplayName() {
    return "Top";
  }
  get ATTR_Form_PositionY__CategoryAttribute() {
    return "Window";
  }
  get ATTR_Form_PositionY__DescriptionAttribute() {
    return "Widget top border Y position";
  }
  get Form_PositionY() {
    return this._Form_PositionY;
  }
  set Form_PositionY(value) {
    this._Form_PositionY = value;
  }
  get ATTR_Form_Width__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_Form_Width__DisplayName() {
    return "Width";
  }
  get ATTR_Form_Width__CategoryAttribute() {
    return "Window";
  }
  get ATTR_Form_Width__DescriptionAttribute() {
    return "Widget width";
  }
  get Form_Width() {
    return this._Form_Width;
  }
  set Form_Width(value) {
    this._Form_Width = value;
  }
  get ATTR_Form_Height__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_Form_Height__DisplayName() {
    return "Height";
  }
  get ATTR_Form_Height__CategoryAttribute() {
    return "Window";
  }
  get ATTR_Form_Height__DescriptionAttribute() {
    return "Widget height";
  }
  get Form_Height() {
    return this._Form_Height;
  }
  set Form_Height(value) {
    this._Form_Height = value;
  }
  get ATTR_Form_containerID__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_Form_containerID__DisplayName() {
    return "Container ID";
  }
  get ATTR_Form_containerID__CategoryAttribute() {
    return "Window";
  }
  get ATTR_Form_containerID__DescriptionAttribute() {
    return "Forces the widget to be shown inside an HTML element with a specific ID already present on the page. If ID is empty, the widget is inserted at root level. Be aware that X,Y offsets are kept, you may want to set them to Zero. ";
  }
  get Form_containerID() {
    return this._containerID;
  }
  set Form_containerID(value) {
    this._containerID = value;
  }
  indent(n) {
    return " ".repeat(n);
  }
  getXml(deep, o) {
    if (typeof o == "undefined")
      o = this;
    let res = "";
    let value = "";
    let properties = GenericProperties.getAllProperties(o);
    let propName = "";
    for (propName in properties.byName) {
      let p = properties.byName[propName];
      if (p.isWritable) {
        let Mustsave = true;
        if ("NotSavedInXMLAttribute" in p.Attributes)
          Mustsave = !p.Attributes["NotSavedInXMLAttribute"];
        let child = Reflect.get(o, p.name);
        if (GenericProperties.IsStructured(child)) {
          if (Mustsave) {
            res = res + this.indent(2 * deep) + "<" + p.name + ">\r\n" + this.getXml(deep + 1, child) + this.indent(2 * deep) + "</" + p.name + ">\r\n";
          }
        } else {
          if (Mustsave) {
            if (child instanceof YEnumItem) {
              value = child.toString;
            } else {
              let type = typeof child;
              if (type == "object")
                type = child.constructor.name;
              switch (type) {
                case "boolean":
                  value = child ? "TRUE" : "FALSE";
                  break;
                case "number":
                  value = child.toString();
                  break;
                case "string":
                  value = GenericProperties.escapeXml(child);
                  break;
                case YColor.name:
                  value = child.toString();
                  break;
                case doubleNan.name:
                  value = child.value.toString();
                  break;
                case xAxisPosition.name:
                  let it = child;
                  value = it.value.toString() + '" relative="' + (it.relative ? "True" : "False");
                  break;
                case NullYSensor.name:
                case CustomYSensor.name:
                  let s = child;
                  value = s == null || s instanceof NullYSensor ? "NULL" : s.get_hardwareId();
                  break;
                default:
                  throw "XML generation : unhandled type (" + p.type + ")";
              }
            }
            res = res + this.indent(2 * deep) + "<" + p.name + ' value="' + value + '"/>\n';
          }
        }
      }
    }
    return res;
  }
  static IsStructured(o) {
    if (o == null)
      return false;
    if (typeof o === "string" || o instanceof String)
      return false;
    if (typeof o === "number" || o instanceof Number)
      return false;
    if (typeof o === "boolean" || o instanceof Boolean)
      return false;
    if (o instanceof YEnumItem)
      return false;
    if (o instanceof CustomYSensor)
      return false;
    if (o instanceof YColor)
      return false;
    if (o instanceof doubleNan)
      return false;
    if (o instanceof xAxisPosition)
      return false;
    if (Object.getOwnPropertyNames(o).length > 0)
      return true;
    return false;
  }
  static getObjectFromPath(rootTarget, path) {
    let FinalTarget = rootTarget;
    for (let i = 0; i < path.length - 1; i++) {
      let name = path[i];
      let index = "";
      while (name.charCodeAt(name.length - 1) >= 48 && name.charCodeAt(name.length - 1) <= 57) {
        index = name.charAt(name.length - 1) + index;
        name = name.substring(0, name.length - 1);
      }
      if (index == "") {
        FinalTarget = Reflect.get(FinalTarget, name);
      } else {
        let arrayObject = Reflect.get(FinalTarget, name);
        FinalTarget = Reflect.get(arrayObject, parseInt(index));
      }
    }
    return FinalTarget;
  }
  static computePropertyAccess_SFT(WidgetObject, SettingObject, propertySourceName, path) {
    let res = new PropertyAccess();
    res.ttype = "";
    res.stype = "";
    res.finalTarget = null;
    res.terminalSource = null;
    res.terminalSource = GenericProperties.getObjectFromPath(WidgetObject, path);
    let props = GenericProperties.getAllProperties(res.terminalSource);
    if (!(path[path.length - 1] in props.byName))
      return res;
    res.stype = typeof res.terminalSource[path[path.length - 1]];
    if (res.stype == "object" && res.terminalSource[path[path.length - 1]] != null) {
      res.stype = res.terminalSource[path[path.length - 1]].constructor.name;
    }
    res.terminalSource = res.terminalSource[path[path.length - 1]];
    if (res.terminalSource == null)
      return res;
    res.propertyName = propertySourceName;
    res.finalTarget = SettingObject;
    let o = res.finalTarget[propertySourceName];
    res.ttype = typeof o;
    if (res.ttype == "object" && o != null)
      res.ttype = o.constructor.name;
    if (path.length <= 1)
      return res;
    for (let i = 1; i < path.length; i++) {
      res.finalTarget = res.finalTarget[res.propertyName];
      res.propertyName = path[i];
    }
    res.ttype = typeof res.finalTarget[res.propertyName];
    if (res.ttype == "object" && res.finalTarget[res.propertyName] != null)
      res.ttype = res.finalTarget[res.propertyName].constructor.name;
    return res;
  }
  static Reflect_getIndexed(o, indexedProp) {
    let res = Reflect.get(o, indexedProp);
    if (typeof res !== "undefined")
      return res;
    let name = indexedProp;
    let index = "";
    while (name.charCodeAt(name.length - 1) >= 48 && name.charCodeAt(name.length - 1) <= 57) {
      index = name.charAt(name.length - 1) + index;
      name = name.substring(0, name.length - 1);
    }
    if (index == "") {
      return null;
    }
    res = Reflect.get(o, name);
    return Reflect.get(res, parseInt(index));
  }
  static computePropertyAccess(rootTarget, source, propertySourceName, path) {
    let res = new PropertyAccess();
    res.ttype = "";
    res.finalTarget = GenericProperties.getObjectFromPath(rootTarget, path);
    res.terminalSource = source;
    res.terminalSource = Reflect.get(res.terminalSource, propertySourceName);
    for (let i = 1; i < path.length; i++) {
      res.terminalSource = Reflect.get(res.terminalSource, path[i]);
    }
    res.stype = typeof res.terminalSource;
    if (res.stype == "object")
      res.stype = res.terminalSource.constructor.name;
    if (path.length > 0) {
      res.propertyName = path[path.length - 1];
      let o = GenericProperties.Reflect_getIndexed(rootTarget, path[0]);
      if (o == null)
        return null;
      for (let i = 1; i < path.length; i++) {
        try {
          o = GenericProperties.Reflect_getIndexed(o, path[i]);
        } catch (e) {
          debugger;
        }
      }
      res.ttype = typeof o;
      if (res.ttype == "object")
        res.ttype = o.constructor.name;
    } else {
      let targetname = propertySourceName;
      let n = targetname.indexOf("__");
      res.propertyName = targetname.substring(n + 2);
      let o = Reflect.get(rootTarget, res.propertyName);
      res.ttype = typeof o;
      if (res.ttype == "object")
        res.ttype = o.constructor.name;
    }
    return res;
  }
  static newGetProperty(rootTarget, source, propertySourceName, path, filterAllow) {
    let access = GenericProperties.computePropertyAccess(rootTarget, source, propertySourceName, path);
    if (access == null)
      return null;
    return Reflect.get(access.finalTarget, access.propertyName);
  }
  static copyProperty_SFT(rootTarget, source, propertySourceName, path, filterAllow) {
    let ttype = "";
    let stype = "";
    let TerminalSource = null;
    let p = GenericProperties.computePropertyAccess_SFT(rootTarget, source, propertySourceName, path);
    if (p.finalTarget == null)
      return;
    ttype = p.ttype;
    stype = p.stype;
    if (stype == YColor.name && ttype == YColor.name) {
      Reflect.set(p.finalTarget, p.propertyName, p.terminalSource.clone());
    } else if (stype == xAxisPosition.name && ttype == xAxisPosition.name) {
      Reflect.set(p.finalTarget, p.propertyName, p.terminalSource.clone());
    } else if (p.stype == "number" && ttype == doubleNan.name) {
      Reflect.set(p.finalTarget, p.propertyName, new doubleNan(p.terminalSource));
    } else {
      Reflect.set(p.finalTarget, p.propertyName, p.terminalSource);
    }
  }
  static copyProperty_STT(rootTarget, source, propertySourceName, path, filterAllow) {
    let p = GenericProperties.computePropertyAccess(rootTarget, source, propertySourceName, path);
    if (p == null)
      return;
    if (p.stype == doubleNan.name && p.ttype == "number") {
      let v = p.terminalSource.value;
      if (Reflect.get(p.finalTarget, p.propertyName) != v) {
        Reflect.set(p.finalTarget, p.propertyName, v);
        constants.edited = true;
      }
    } else if (p.stype != p.ttype) {
      debugger;
    } else if (p.stype == YColor.name && p.ttype == YColor.name) {
      let color = p.terminalSource;
      if (!color.equal(Reflect.get(p.finalTarget, p.propertyName))) {
        Reflect.set(p.finalTarget, p.propertyName, color.clone());
        constants.edited = true;
      }
    } else if (p.stype == doubleNan.name && p.ttype == doubleNan.name) {
      let v = p.terminalSource;
      if (Reflect.get(p.finalTarget, p.propertyName) != v) {
        Reflect.set(p.finalTarget, p.propertyName, v.clone());
        constants.edited = true;
      }
    } else if (p.stype == xAxisPosition.name && p.ttype == xAxisPosition.name) {
      let x = p.terminalSource;
      let x2 = Reflect.get(p.finalTarget, p.propertyName);
      if (x.relative != x2.relative || x.value != x2.value) {
        Reflect.set(p.finalTarget, p.propertyName, x.clone());
        constants.edited = true;
      }
    } else if (Reflect.get(p.finalTarget, p.propertyName) != p.terminalSource) {
      Reflect.set(p.finalTarget, p.propertyName, p.terminalSource);
      constants.edited = true;
    }
  }
  ApplyAllProperties(target) {
    this.ApplyAllPropertiesEx(target, GenericProperties.NoFilter, 0);
  }
  RefreshAllProperties(target) {
    this.ApplyAllPropertiesEx(target, GenericProperties.NoFilter, 1);
  }
  ApplyProperties(rootSource, rootTarget, fullpropname, sourceValue, path, direction) {
    if (sourceValue instanceof AlarmSection)
      return;
    let sourceproperties = GenericProperties.getAllProperties(this);
    if ("CopyToTarget" in sourceproperties.byName[fullpropname].Attributes) {
      if (!sourceproperties.byName[fullpropname].Attributes["CopyToTarget"]) {
        return;
      }
    }
    if (!GenericProperties.IsStructured(sourceValue)) {
      if (direction == 0) {
        GenericProperties.copyProperty_STT(rootTarget, this, fullpropname, path);
      } else {
        GenericProperties.copyProperty_SFT(rootTarget, this, fullpropname, path);
      }
    } else {
      let path2 = path.slice();
      path2.push("");
      let target = GenericProperties.getObjectFromPath(rootTarget, path2);
      Reflect.set(target, "userData", sourceValue);
      let sourceproperties2 = GenericProperties.getAllProperties(sourceValue);
      for (let subpropname in sourceproperties2.byName) {
        let shouldcopy = true;
        if ("CopyToTarget" in sourceproperties2.byName[subpropname].Attributes) {
          shouldcopy = sourceproperties2.byName[subpropname].Attributes["CopyToTarget"];
        }
        if (sourceproperties2.byName[subpropname].isWritable && shouldcopy) {
          path.push(subpropname);
          this.ApplyProperties(rootSource, rootTarget, fullpropname, Reflect.get(sourceValue, subpropname), path, direction);
          path.splice(path.length - 1, 1);
        }
      }
    }
  }
  static isProperty(proto, propName) {
    let d = Reflect.getOwnPropertyDescriptor(proto, propName);
    let list = Object.getOwnPropertyNames(d);
    for (let i = 0; i < list.length; i++) {
      if (list[i] == "set")
        return true;
      if (list[i] == "get")
        return true;
    }
    return false;
  }
  static isWritable(proto, propName) {
    let d = Reflect.getOwnPropertyDescriptor(proto, propName);
    let list = Object.getOwnPropertyNames(d);
    for (let i = 0; i < list.length; i++) {
      if (list[i] == "set") {
        if (typeof d.set !== "undefined")
          return true;
      }
    }
    return false;
  }
  static getAllProperties(o) {
    if (typeof o === "undefined")
      debugger;
    if (o.hasOwnProperty("PropertiesDescriptionCache")) {
      return o["PropertiesDescriptionCache"];
    }
    let proto = Object.getPrototypeOf(o);
    let res = new PropertiesList();
    let p = proto;
    let entries = [];
    let genealogy = [];
    while (p != null) {
      genealogy.push(p);
      p = Object.getPrototypeOf(p);
    }
    for (let j = genealogy.length - 1; j >= 0; j--) {
      let names = Object.getOwnPropertyNames(genealogy[j]);
      let index = 0;
      for (let i = 0; i < names.length; i++) {
        if (names[i] != "constructor" && !names[i].startsWith("__")) {
          entries.splice(index, 0, new PropDescription(names[i], genealogy[j]));
          index++;
          for (let k = entries.length - 1; k >= index; k--) {
            if (entries[k].name == names[i])
              entries.splice(k, 1);
          }
        }
      }
    }
    for (let i = 0; i < entries.length; i++) {
      if (!entries[i].name.startsWith("ATTR") && entries[i].name != "constructor" && !entries[i].name.startsWith("__")) {
        if (GenericProperties.isProperty(entries[i].prop, entries[i].name)) {
          let d = new PropertyDescriptor(entries[i].name);
          res.byIndex.push(d);
          res.byName[d.name] = d;
          d.isWritable = GenericProperties.isWritable(entries[i].prop, entries[i].name);
          d.isEnum = o[entries[i].name] instanceof YEnumItem;
          d.type = typeof o[entries[i].name];
          if (d.type == "object" && o[entries[i].name] != null) {
            d.type = o[entries[i].name].constructor.name;
          }
        }
      }
    }
    for (let i = 0; i < entries.length; i++) {
      if (entries[i].name.startsWith("ATTR_")) {
        let p2 = entries[i].name.indexOf("__");
        if (p2 < 5)
          debugger;
        let name = entries[i].name.substring(5, p2);
        let attr = entries[i].name.substring(p2 + 2);
        if (typeof res.byName[name] === "undefined")
          debugger;
        try {
          res.byName[name].Attributes[attr] = Reflect.get(o, entries[i].name);
        } catch (e) {
          debugger;
        }
      }
    }
    o["PropertiesDescriptionCache"] = res;
    return res;
  }
  ApplyAllPropertiesEx(target, filter, direction) {
    let properties = GenericProperties.getAllProperties(this);
    for (let fullpropname in properties.byName) {
      if (properties.byName[fullpropname].isWritable) {
        let index = fullpropname.indexOf("_");
        if (index < 0)
          throw "invalid Property name";
        let propType = fullpropname.substring(0, index);
        let propname = fullpropname.substring(index + 1);
        let path = [];
        path.push(propname);
        if (target instanceof YWidget && propType == "Form") {
          this.ApplyProperties(this, target, fullpropname, Reflect.get(this, fullpropname), path, direction);
        }
        if (target instanceof YAngularGauge && propType == "AngularGauge") {
          this.ApplyProperties(this, target, fullpropname, Reflect.get(this, fullpropname), path, direction);
        }
        if (target instanceof YDigitalDisplay && propType == "display") {
          this.ApplyProperties(this, target, fullpropname, Reflect.get(this, fullpropname), path, direction);
        }
        if (target instanceof YSolidGauge && propType == "SolidGauge") {
          this.ApplyProperties(this, target, fullpropname, Reflect.get(this, fullpropname), path, direction);
        }
        if (target instanceof YGraph && propType == "Graph") {
          this.ApplyProperties(this, target, fullpropname, Reflect.get(this, fullpropname), path, direction);
        }
      }
    }
  }
};
GenericProperties.XmlFileVersion = -1;

// obj/full/properties.js
var GenericHints = class {
};
GenericHints.DevConfAffected = " Changing this value will affect the device configuration.";
GenericHints.CheckSensor = "If the sensor you want to use is connected, but not listed or listed as OFFLINE, check USB / Network configuration in the global configuration.";
GenericHints.AnnotationGraph = "Annotation text.  Use \\n for carriage returns. Some variables are available: $DAY$ $MONTH$ $YEAR$ for date, $HOUR$ $MINUTE$ $SECOND$ for time, $AVGVALUE1$ $MINVALUE1$ $MAXVALUE1$ $NAME1$ $UNIT1$  for first series data, $AVGVALUE2$ $MINVALUE2$ $MAXVALUE2$ $NAME2$ $UNIT2$  for second series data and so on";
GenericHints.Annotation = "Annotation text.  Use \\n for carriage returns. Some variables are available: $DAY$ $MONTH$ $YEAR$ for date, $HOUR$ $MINUTE$ $SECOND$ for time, $AVGVALUE$ $MINVALUE$ $MAXVALUE$ $NAME$ $UNIT$ for sensor related data.";
var sensorFreqTypeDescription = class {
  static get AllowedValues() {
    return this._AllowedValues;
  }
};
sensorFreqTypeDescription._AllowedValues = [
  "25/s",
  "10/s",
  "5/s",
  "4/s",
  "3/s",
  "2/s",
  "1/s",
  "60/m",
  "30/m",
  "12/m",
  "6/m",
  "4/m",
  "3/m",
  "2/m",
  "1/m",
  "30/h",
  "12/h",
  "6/h",
  "4/h",
  "3/h",
  "2/h",
  "1/h"
];
var yAxisDescription = class {
  static initialize() {
    let yaxiscount = 0;
    let obj = new GraphFormProperties(null, null);
    let names = Object.getOwnPropertyNames(obj);
    names.forEach((name) => {
      if (name.startsWith("_Graph_yAxes"))
        yaxiscount++;
    });
    for (let i = 0; i < yaxiscount; i++) {
      switch (i) {
        case 0:
          this._AllowedValues.push("1rst Y axis");
          break;
        case 1:
          this._AllowedValues.push("2nd Y axis");
          break;
        case 2:
          this._AllowedValues.push("3rd Y axis");
          break;
        default:
          this._AllowedValues.push((i + 1).toString() + "th Y axis");
          break;
      }
    }
    yAxisDescription.initialized = true;
  }
  static get AllowedValues() {
    if (!yAxisDescription.initialized)
      yAxisDescription.initialize();
    return this._AllowedValues;
  }
};
yAxisDescription._AllowedValues = [];
var AlarmTestTypeDescription = class {
  static get AllowedValues() {
    return this._AllowedValues;
  }
};
AlarmTestTypeDescription._AllowedValues = ["Disabled", ">", ">=", "=", "<=", "<"];
var fontNameTypeDescription = class {
  static fontNameTypeDescription() {
  }
  static get AllowedValues() {
    return this._AllowedValues;
  }
};
fontNameTypeDescription._AllowedValues = [
  "Arial",
  "Brush Script MT",
  "Comic Sans MS",
  "Courier New",
  "Garamond",
  "Georgia",
  "Helvetica",
  "Impact",
  "Tahoma",
  "Times New Roman",
  "Trebuchet MS",
  "Verdana"
];
var sensorPrecisionTypeDescription = class {
  static get AllowedValues() {
    return this._AllowedValues;
  }
};
sensorPrecisionTypeDescription._AllowedValues = ["0", "0.1", "0.12", "0.123"];
var sensorDataTypeDescription = class {
  static get AllowedValues() {
    return this._AllowedValues;
  }
};
sensorDataTypeDescription._AllowedValues = ["Avg values", "Min values", "Max values"];
var GaugeFormProperties = class extends GenericProperties {
  constructor(initData, owner) {
    super(owner);
    this._DataSource_source = sensorsManager.getNullSensor();
    this._DataSource_precision = "0.1";
    this._DataSource_AlarmSection0 = new AlarmSection(0);
    this._DataSource_AlarmSection1 = new AlarmSection(1);
    this._SolidGauge_min = 0;
    this._SolidGauge_max = 100;
    this._SolidGauge_showMinMax = true;
    this._SolidGauge_color1 = YColor.LightGreen;
    this._SolidGauge_color2 = YColor.Red;
    this._SolidGauge_font = new FontDescription("Arial", 20, YColor.Black, false, true);
    this._SolidGauge_minMaxFont = new FontDescription("Arial", 10, YColor.Black, false, true);
    this._SolidGauge_displayMode = YSolidGauge.DisplayMode.DISPLAY90;
    this._SolidGauge_borderColor = YColor.Black;
    this._SolidGauge_borderThickness = 2;
    this._SolidGauge_backgroundColor1 = YColor.FromArgb(255, 240, 240, 240);
    this._SolidGauge_backgroundColor2 = YColor.FromArgb(255, 200, 200, 200);
    this._SolidGauge_thickness = 25;
    this._SolidGauge_maxSpeed = 1;
    this._annotationPanels0 = new AnnotationPanelDescription(GenericPanel.HorizontalAlignPos.CENTER, GenericPanel.VerticalAlignPos.BOTTOM, 0, false, "$NAME$", YColor.FromArgb(0, 127, 127, 127), YColor.FromArgb(0, 127, 127, 127), 10, YColor.FromArgb(255, 0, 0, 0));
    this._annotationPanels1 = new AnnotationPanelDescription(GenericPanel.HorizontalAlignPos.CENTER, GenericPanel.VerticalAlignPos.BOTTOM, 0, false, "$NAME$", YColor.FromArgb(0, 127, 127, 127), YColor.FromArgb(0, 127, 127, 127), 10, YColor.FromArgb(255, 0, 0, 0));
    this.initFromXmlData(initData);
    this.PropagateDataSourceChange();
  }
  PropagateDataSourceChange() {
    this.ownerForm.SourceChanged(this._DataSource_source, 0);
    let props = GenericProperties.getAllProperties(this).byName;
    let name;
    for (name in props) {
      if (name.startsWith("DataSource_AlarmSection")) {
        this[name].setDataSource(this._DataSource_source);
      }
    }
  }
  get ATTR_DataSource_source__DisplayName() {
    return "Sensor";
  }
  get ATTR_DataSource_source__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_source__ParamCategorySummaryAttribute() {
    return "sensorDescription";
  }
  get ATTR_DataSource_source__PreExpandedCategoryAttribute() {
    return true;
  }
  get ATTR_DataSource_source__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_DataSource_source__DescriptionAttribute() {
    return "Yoctopuce sensor feeding the gauge. ";
  }
  get DataSource_source() {
    return this._DataSource_source;
  }
  set DataSource_source(value) {
    let prev = this._DataSource_source;
    this._DataSource_source = value;
    this.PropagateDataSourceChange();
    if (this._DataSource_source != prev)
      constants.edited = true;
  }
  get sensorDescription() {
    return this._DataSource_source instanceof NullYSensor ? "none" : this._DataSource_source.get_friendlyName();
  }
  get isSensorReadOnly() {
    return this._DataSource_source.isReadOnly;
  }
  get ATTR_DataSource_freq__DisplayName() {
    return "Sensor freq";
  }
  get ATTR_DataSource_freq__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_freq__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_DataSource_freq__IsReadonlyCallAttribute() {
    return this.isSensorReadOnly;
  }
  get ATTR_DataSource_freq__AllowedValues() {
    return sensorFreqTypeDescription.AllowedValues;
  }
  get ATTR_DataSource_freq__DescriptionAttribute() {
    return "Sensor data acquisition frequency." + GenericHints.DevConfAffected;
  }
  get DataSource_freq() {
    return this._DataSource_source.get_frequency();
  }
  set DataSource_freq(value) {
    this._DataSource_source.set_frequency(value);
  }
  get ATTR_DataSource_precision__DisplayName() {
    return "Precision";
  }
  get ATTR_DataSource_precision__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_precision__DescriptionAttribute() {
    return "How many digits shown after the decimal point";
  }
  get ATTR_DataSource_precision__AllowedValues() {
    return sensorPrecisionTypeDescription.AllowedValues;
  }
  get DataSource_precision() {
    return this._DataSource_precision;
  }
  set DataSource_precision(value) {
    this._DataSource_precision = value;
  }
  get ATTR_DataSource_AlarmSection0__DisplayName() {
    return "Sensor value alarm 1";
  }
  get ATTR_DataSource_AlarmSection0__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection0__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection0__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_AlarmSection0__DescriptionAttribute() {
    return "Alarm 1 for this data source, expand for more.";
  }
  get DataSource_AlarmSection0() {
    return this._DataSource_AlarmSection0;
  }
  set DataSource_AlarmSection0(value) {
    this._DataSource_AlarmSection0 = value;
  }
  get ATTR_DataSource_AlarmSection1__DisplayName() {
    return "Sensor value alarm 2";
  }
  get ATTR_DataSource_AlarmSection1__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection1__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection1__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_AlarmSection1__DescriptionAttribute() {
    return "Alarm 2 for this data source, expand for more.";
  }
  get DataSource_AlarmSection1() {
    return this._DataSource_AlarmSection1;
  }
  set DataSource_AlarmSection1(value) {
    this._DataSource_AlarmSection1 = value;
  }
  get ATTR_SolidGauge_min__DisplayName() {
    return "Minimum value";
  }
  get ATTR_SolidGauge_min__CategoryAttribute() {
    return "Values range";
  }
  get ATTR_SolidGauge_min__DescriptionAttribute() {
    return "Minimum value displayable by the gauge.";
  }
  get SolidGauge_min() {
    return this._SolidGauge_min;
  }
  set SolidGauge_min(value) {
    this._SolidGauge_min = value;
  }
  get ATTR_SolidGauge_max__DisplayName() {
    return "Maximum value";
  }
  get ATTR_SolidGauge_max__CategoryAttribute() {
    return "Values range";
  }
  get ATTR_SolidGauge_max__DescriptionAttribute() {
    return "Maximum value displayable by the gauge.";
  }
  get SolidGauge_max() {
    return this._SolidGauge_max;
  }
  set SolidGauge_max(value) {
    this._SolidGauge_max = value;
  }
  get ATTR_SolidGauge_showMinMax__DisplayName() {
    return "show  min/max";
  }
  get ATTR_SolidGauge_showMinMax__CategoryAttribute() {
    return "Values range";
  }
  get ATTR_SolidGauge_showMinMax__DescriptionAttribute() {
    return "Show the min / max values.";
  }
  get SolidGauge_showMinMax() {
    return this._SolidGauge_showMinMax;
  }
  set SolidGauge_showMinMax(value) {
    this._SolidGauge_showMinMax = value;
  }
  get ATTR_SolidGauge_color1__DisplayName() {
    return "Min Color";
  }
  get ATTR_SolidGauge_color1__CategoryAttribute() {
    return "Values range";
  }
  get ATTR_SolidGauge_color1__DescriptionAttribute() {
    return "Color for minimum value.";
  }
  get SolidGauge_color1() {
    return this._SolidGauge_color1;
  }
  set SolidGauge_color1(value) {
    this._SolidGauge_color1 = value;
  }
  get ATTR_SolidGauge_color2__DisplayName() {
    return "Max Color";
  }
  get ATTR_SolidGauge_color2__CategoryAttribute() {
    return "Values range";
  }
  get ATTR_SolidGauge_color2__DescriptionAttribute() {
    return "Color for maximum value.";
  }
  get SolidGauge_color2() {
    return this._SolidGauge_color2;
  }
  set SolidGauge_color2(value) {
    this._SolidGauge_color2 = value;
  }
  get ATTR_SolidGauge_font__DisplayName() {
    return "Unit  Font";
  }
  get ATTR_SolidGauge_font__CategoryAttribute() {
    return "Fonts";
  }
  get ATTR_SolidGauge_font__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_SolidGauge_font__DescriptionAttribute() {
    return "Font for displaying the value/status indicator";
  }
  get SolidGauge_font() {
    return this._SolidGauge_font;
  }
  set SolidGauge_font(value) {
    this._SolidGauge_font = value;
  }
  get ATTR_SolidGauge_minMaxFont__DisplayName() {
    return "Min Max  Font";
  }
  get ATTR_SolidGauge_minMaxFont__CategoryAttribute() {
    return "Fonts";
  }
  get ATTR_SolidGauge_minMaxFont__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_SolidGauge_minMaxFont__DescriptionAttribute() {
    return "Font for displaying min/max values";
  }
  get SolidGauge_minMaxFont() {
    return this._SolidGauge_minMaxFont;
  }
  set SolidGauge_minMaxFont(value) {
    this._SolidGauge_minMaxFont = value;
  }
  get ATTR_SolidGauge_displayMode__DisplayName() {
    return "Display mode";
  }
  get ATTR_SolidGauge_displayMode__CategoryAttribute() {
    return "Dial";
  }
  get ATTR_SolidGauge_displayMode__DescriptionAttribute() {
    return "Dial general shape";
  }
  get SolidGauge_displayMode() {
    return this._SolidGauge_displayMode;
  }
  set SolidGauge_displayMode(value) {
    this._SolidGauge_displayMode = value;
  }
  get ATTR_SolidGauge_borderColor__DisplayName() {
    return "Border color";
  }
  get ATTR_SolidGauge_borderColor__CategoryAttribute() {
    return "Dial";
  }
  get ATTR_SolidGauge_borderColor__DescriptionAttribute() {
    return "Dial border color.";
  }
  get SolidGauge_borderColor() {
    return this._SolidGauge_borderColor;
  }
  set SolidGauge_borderColor(value) {
    this._SolidGauge_borderColor = value;
  }
  get ATTR_SolidGauge_borderThickness__DisplayName() {
    return "Border thickness ";
  }
  get ATTR_SolidGauge_borderThickness__CategoryAttribute() {
    return "Dial";
  }
  get ATTR_SolidGauge_borderThickness__DescriptionAttribute() {
    return "Thickness of the dial border";
  }
  get SolidGauge_borderThickness() {
    return this._SolidGauge_borderThickness;
  }
  set SolidGauge_borderThickness(value) {
    this._SolidGauge_borderThickness = value;
  }
  get ATTR_SolidGauge_backgroundColor1__DisplayName() {
    return "Background color 1";
  }
  get ATTR_SolidGauge_backgroundColor1__CategoryAttribute() {
    return "Dial";
  }
  get ATTR_SolidGauge_backgroundColor1__DescriptionAttribute() {
    return "Dial background gradient color 1.";
  }
  get SolidGauge_backgroundColor1() {
    return this._SolidGauge_backgroundColor1;
  }
  set SolidGauge_backgroundColor1(value) {
    this._SolidGauge_backgroundColor1 = value;
  }
  get ATTR_SolidGauge_backgroundColor2__DisplayName() {
    return "Background color 2";
  }
  get ATTR_SolidGauge_backgroundColor2__CategoryAttribute() {
    return "Dial";
  }
  get ATTR_SolidGauge_backgroundColor2__DescriptionAttribute() {
    return "Dial background gradient color 2.";
  }
  get SolidGauge_backgroundColor2() {
    return this._SolidGauge_backgroundColor2;
  }
  set SolidGauge_backgroundColor2(value) {
    this._SolidGauge_backgroundColor2 = value;
  }
  get ATTR_SolidGauge_thickness__DisplayName() {
    return "Dial thickness (%) ";
  }
  get ATTR_SolidGauge_thickness__CategoryAttribute() {
    return "Dial";
  }
  get ATTR_SolidGauge_thickness__DescriptionAttribute() {
    return "Thickness of the dial, in percentage relative to radius";
  }
  get SolidGauge_thickness() {
    return this._SolidGauge_thickness;
  }
  set SolidGauge_thickness(value) {
    this._SolidGauge_thickness = value;
  }
  get ATTR_SolidGauge_maxSpeed__DisplayName() {
    return "Max speed (%) ";
  }
  get ATTR_SolidGauge_maxSpeed__CategoryAttribute() {
    return "Dial";
  }
  get ATTR_SolidGauge_maxSpeed__DescriptionAttribute() {
    return 'Maximum speed of the dial in percentage relative to Max-Min. This is meant to limit "teleporting" effects.';
  }
  get SolidGauge_maxSpeed() {
    return this._SolidGauge_maxSpeed;
  }
  set SolidGauge_maxSpeed(value) {
    this._SolidGauge_maxSpeed = value;
  }
  IsDataSourceAssigned() {
    return !(this._DataSource_source instanceof NullYSensor);
  }
  get ATTR_SolidGauge_annotationPanels0__DisplayName() {
    return "Annotation 1";
  }
  get ATTR_SolidGauge_annotationPanels0__CategoryAttribute() {
    return "Annotations";
  }
  get ATTR_SolidGauge_annotationPanels0__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_SolidGauge_annotationPanels0__DescriptionAttribute() {
    return "Customizable text panels";
  }
  get SolidGauge_annotationPanels0() {
    return this._annotationPanels0;
  }
  set SolidGauge_annotationPanels0(value) {
    this._annotationPanels0 = value;
  }
  get ATTR_SolidGauge_annotationPanels1__DisplayName() {
    return "Annotation 2";
  }
  get ATTR_SolidGauge_annotationPanels1__CategoryAttribute() {
    return "Annotations";
  }
  get ATTR_SolidGauge_annotationPanels1__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_SolidGauge_annotationPanels1__DescriptionAttribute() {
    return "Customizable text panels";
  }
  get SolidGauge_annotationPanels1() {
    return this._annotationPanels1;
  }
  set SolidGauge_annotationPanels1(value) {
    this._annotationPanels1 = value;
  }
};
var AngularGaugeFormProperties = class extends GenericProperties {
  constructor(initData, owner) {
    super(owner);
    this._DataSource_source = sensorsManager.getNullSensor();
    this._DataSource_AlarmSection0 = new AlarmSection(0);
    this._DataSource_AlarmSection1 = new AlarmSection(1);
    this._AngularGauge_min = 0;
    this._AngularGauge_max = 100;
    this._AngularGauge_unitFactor = 1;
    this._AngularGauge_graduation = 10;
    this._AngularGauge_graduationSize = 10;
    this._AngularGauge_graduationOuterRadiusSize = 98;
    this._AngularGauge_graduationThickness = 2;
    this._AngularGauge_graduationColor = YColor.Black;
    this._AngularGauge_graduationFont = new FontDescription("Arial", 20, YColor.Black, false, true);
    this._AngularGauge_subgraduationCount = 5;
    this._AngularGauge_subgraduationSize = 5;
    this._AngularGauge_subgraduationThickness = 1;
    this._AngularGauge_subgraduationColor = YColor.Black;
    this._AngularGauge_needleColor = YColor.Red;
    this._AngularGauge_needleContourColor = YColor.DarkRed;
    this._AngularGauge_needleContourThickness = 1;
    this._AngularGauge_needleLength1 = 90;
    this._AngularGauge_needleLength2 = 15;
    this._AngularGauge_needleWidth = 5;
    this._AngularGauge_needleMaxSpeed = 0.5;
    this._AngularGauge_unitFont = new FontDescription("Arial", 24, YColor.DarkGray, false, true);
    this._AngularGauge_statusFont = new FontDescription("Arial", 24, YColor.DarkGray, false, true);
    this._AngularGauge_borderColor = YColor.Black;
    this._AngularGauge_borderThickness = 5;
    this._AngularGauge_backgroundColor1 = YColor.FromArgb(255, 240, 240, 240);
    this._AngularGauge_backgroundColor2 = YColor.FromArgb(255, 200, 200, 200);
    this._AngularGauge_zones0 = new AngularZoneDescription(0, 50, YColor.LightGreen);
    this._AngularGauge_zones1 = new AngularZoneDescription(50, 80, YColor.Yellow);
    this._AngularGauge_zones2 = new AngularZoneDescription(80, 100, YColor.Red);
    this._annotationPanels0 = new AnnotationPanelDescription(GenericPanel.HorizontalAlignPos.CENTER, GenericPanel.VerticalAlignPos.CENTER, 0, false, "$NAME$", YColor.FromArgb(0, 127, 127, 127), YColor.FromArgb(0, 127, 127, 127), 10, YColor.FromArgb(255, 0, 0, 0));
    this._annotationPanels1 = new AnnotationPanelDescription(GenericPanel.HorizontalAlignPos.CENTER, GenericPanel.VerticalAlignPos.BOTTOM, 0, false, "$NAME$", YColor.FromArgb(0, 127, 127, 127), YColor.FromArgb(0, 127, 127, 127), 10, YColor.FromArgb(255, 0, 0, 0));
    this.initFromXmlData(initData);
    this.PropagateDataSourceChange();
  }
  PropagateDataSourceChange() {
    this.ownerForm.SourceChanged(this._DataSource_source, 0);
    let props = GenericProperties.getAllProperties(this).byName;
    let name;
    for (name in props) {
      if (name.startsWith("DataSource_AlarmSection")) {
        this[name].setDataSource(this._DataSource_source);
      }
    }
  }
  IsDataSourceAssigned() {
    return !(this._DataSource_source instanceof NullYSensor);
  }
  get ATTR_DataSource_source__DisplayName() {
    return "Sensor";
  }
  get ATTR_DataSource_source__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_source__ParamCategorySummaryAttribute() {
    return "sensorDescription";
  }
  get ATTR_DataSource_source__PreExpandedCategoryAttribute() {
    return true;
  }
  get ATTR_DataSource_source__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_DataSource_source__DescriptionAttribute() {
    return "Yoctopuce sensor feeding the gauge. " + GenericHints.CheckSensor;
  }
  get DataSource_source() {
    return this._DataSource_source;
  }
  set DataSource_source(value) {
    let prev = this._DataSource_source;
    this._DataSource_source = value;
    this.PropagateDataSourceChange();
    if (this._DataSource_source != prev)
      constants.edited = true;
  }
  get sensorDescription() {
    return this._DataSource_source instanceof NullYSensor ? "none" : this._DataSource_source.get_friendlyName();
  }
  get isSensorReadOnly() {
    return this._DataSource_source.isReadOnly;
  }
  get ATTR_DataSource_freq__DisplayName() {
    return "Sensor freq";
  }
  get ATTR_DataSource_freq__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_freq__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_DataSource_freq__IsReadonlyCallAttribute() {
    return "isSensorReadOnly";
  }
  get ATTR_DataSource_freq__DescriptionAttribute() {
    return "Sensor data acquisition frequency." + GenericHints.DevConfAffected;
  }
  get ATTR_DataSource_freq__AllowedValues() {
    return sensorFreqTypeDescription.AllowedValues;
  }
  get DataSource_freq() {
    return this._DataSource_source.get_frequency();
  }
  set DataSource_freq(value) {
    this._DataSource_source.set_frequency(value);
  }
  get ATTR_DataSource_AlarmSection0__DisplayName() {
    return "Sensor value alarm 1";
  }
  get ATTR_DataSource_AlarmSection0__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection0__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection0__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_AlarmSection0__DescriptionAttribute() {
    return "Alarm 1 for this data source, expand for more.";
  }
  get DataSource_AlarmSection0() {
    return this._DataSource_AlarmSection0;
  }
  set DataSource_AlarmSection0(value) {
    this._DataSource_AlarmSection0 = value;
  }
  get ATTR_DataSource_AlarmSection1__DisplayName() {
    return "Sensor value alarm 2";
  }
  get ATTR_DataSource_AlarmSection1__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection1__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection1__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_AlarmSection1__DescriptionAttribute() {
    return "Alarm 2 for this data source, expand for more.";
  }
  get DataSource_AlarmSection1() {
    return this._DataSource_AlarmSection1;
  }
  set DataSource_AlarmSection1(value) {
    this._DataSource_AlarmSection1 = value;
  }
  get ATTR_AngularGauge_min__DisplayName() {
    return "Minimum value";
  }
  get ATTR_AngularGauge_min__CategoryAttribute() {
    return "Gauge gradations";
  }
  get ATTR_AngularGauge_min__DescriptionAttribute() {
    return "Minimum value displayable by the gauge.";
  }
  get AngularGauge_min() {
    return this._AngularGauge_min;
  }
  set AngularGauge_min(value) {
    this._AngularGauge_min = value;
  }
  get ATTR_AngularGauge_max__DisplayName() {
    return "Maximum value";
  }
  get ATTR_AngularGauge_max__CategoryAttribute() {
    return "Gauge gradations";
  }
  get ATTR_AngularGauge_max__DescriptionAttribute() {
    return "Maximum value displayable by the gauge.";
  }
  get AngularGauge_max() {
    return this._AngularGauge_max;
  }
  set AngularGauge_max(value) {
    this._AngularGauge_max = value;
  }
  get ATTR_AngularGauge_unitFactor__DisplayName() {
    return "Unit factor";
  }
  get ATTR_AngularGauge_unitFactor__CategoryAttribute() {
    return "Gauge gradations";
  }
  get ATTR_AngularGauge_unitFactor__DescriptionAttribute() {
    return "Data  will be divided by this value before being displayed, this allows simpler gradation marks.";
  }
  get AngularGauge_unitFactor() {
    return this._AngularGauge_unitFactor;
  }
  set AngularGauge_unitFactor(value) {
    this._AngularGauge_unitFactor = value;
  }
  get ATTR_AngularGauge_graduation__DisplayName() {
    return "Main gradation steps";
  }
  get ATTR_AngularGauge_graduation__CategoryAttribute() {
    return "Gauge gradations";
  }
  get ATTR_AngularGauge_graduation__DescriptionAttribute() {
    return "Difference between two consecutive main gradation marks";
  }
  get AngularGauge_graduation() {
    return this._AngularGauge_graduation;
  }
  set AngularGauge_graduation(value) {
    this._AngularGauge_graduation = value;
  }
  get ATTR_AngularGauge_graduationSize__DisplayName() {
    return "Main gradation size (%)";
  }
  get ATTR_AngularGauge_graduationSize__CategoryAttribute() {
    return "Gauge gradations";
  }
  get ATTR_AngularGauge_graduationSize__DescriptionAttribute() {
    return "Main gradation marks size in percent, relative to dial radius";
  }
  get AngularGauge_graduationSize() {
    return this._AngularGauge_graduationSize;
  }
  set AngularGauge_graduationSize(value) {
    this._AngularGauge_graduationSize = value;
  }
  get ATTR_AngularGauge_graduationOuterRadiusSize__DisplayName() {
    return "Main gradation radius (%)";
  }
  get ATTR_AngularGauge_graduationOuterRadiusSize__CategoryAttribute() {
    return "Gauge gradations";
  }
  get ATTR_AngularGauge_graduationOuterRadiusSize__DescriptionAttribute() {
    return "Main gradation marks outer radius in percent, relative to dial radius";
  }
  get AngularGauge_graduationOuterRadiusSize() {
    return this._AngularGauge_graduationOuterRadiusSize;
  }
  set AngularGauge_graduationOuterRadiusSize(value) {
    this._AngularGauge_graduationOuterRadiusSize = value;
  }
  get ATTR_AngularGauge_graduationThickness__DisplayName() {
    return "Main gradation thickness";
  }
  get ATTR_AngularGauge_graduationThickness__CategoryAttribute() {
    return "Gauge gradations";
  }
  get ATTR_AngularGauge_graduationThickness__DescriptionAttribute() {
    return "Main gradation marks thickness";
  }
  get AngularGauge_graduationThickness() {
    return this._AngularGauge_graduationThickness;
  }
  set AngularGauge_graduationThickness(value) {
    this._AngularGauge_graduationThickness = value;
  }
  get ATTR_AngularGauge_graduationColor__DisplayName() {
    return "Main gradation color";
  }
  get ATTR_AngularGauge_graduationColor__CategoryAttribute() {
    return "Gauge gradations";
  }
  get ATTR_AngularGauge_graduationColor__DescriptionAttribute() {
    return "Main gradation marks color.";
  }
  get AngularGauge_graduationColor() {
    return this._AngularGauge_graduationColor;
  }
  set AngularGauge_graduationColor(value) {
    this._AngularGauge_graduationColor = value;
  }
  get ATTR_AngularGauge_graduationFont__DisplayName() {
    return "Main gradation font";
  }
  get ATTR_AngularGauge_graduationFont__CategoryAttribute() {
    return "Gauge gradations";
  }
  get ATTR_AngularGauge_graduationFont__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_AngularGauge_graduationFont__DescriptionAttribute() {
    return "Font used for gradation labels";
  }
  get AngularGauge_graduationFont() {
    return this._AngularGauge_graduationFont;
  }
  set AngularGauge_graduationFont(value) {
    this._AngularGauge_graduationFont = value;
  }
  get ATTR_AngularGauge_subgraduationCount__DisplayName() {
    return "Sub-gradation count";
  }
  get ATTR_AngularGauge_subgraduationCount__CategoryAttribute() {
    return "Gauge gradations";
  }
  get ATTR_AngularGauge_subgraduationCount__DescriptionAttribute() {
    return "How many sub-gradation (+1) marks between two consecutive main graduation marks";
  }
  get AngularGauge_subgraduationCount() {
    return this._AngularGauge_subgraduationCount;
  }
  set AngularGauge_subgraduationCount(value) {
    this._AngularGauge_subgraduationCount = value;
  }
  get ATTR_AngularGauge_subgraduationSize__DisplayName() {
    return "Sub-gradation size (%)";
  }
  get ATTR_AngularGauge_subgraduationSize__CategoryAttribute() {
    return "Gauge gradations";
  }
  get ATTR_AngularGauge_subgraduationSize__DescriptionAttribute() {
    return "Sub-gradation marks size in percent, relative to dial radius";
  }
  get AngularGauge_subgraduationSize() {
    return this._AngularGauge_subgraduationSize;
  }
  set AngularGauge_subgraduationSize(value) {
    this._AngularGauge_subgraduationSize = value;
  }
  get ATTR_AngularGauge_subgraduationThickness__DisplayName() {
    return "Sub-gradation thickness";
  }
  get ATTR_AngularGauge_subgraduationThickness__CategoryAttribute() {
    return "Gauge gradations";
  }
  get ATTR_AngularGauge_subgraduationThickness__DescriptionAttribute() {
    return "Sub-gradation marks thickness";
  }
  get AngularGauge_subgraduationThickness() {
    return this._AngularGauge_subgraduationThickness;
  }
  set AngularGauge_subgraduationThickness(value) {
    this._AngularGauge_subgraduationThickness = value;
  }
  get ATTR_AngularGauge_subgraduationColor__DisplayName() {
    return "Sub-gradation color";
  }
  get ATTR_AngularGauge_subgraduationColor__CategoryAttribute() {
    return "Gauge gradations";
  }
  get ATTR_AngularGauge_subgraduationColor__DescriptionAttribute() {
    return "Sub-gradation marks color.";
  }
  get AngularGauge_subgraduationColor() {
    return this._AngularGauge_subgraduationColor;
  }
  set AngularGauge_subgraduationColor(value) {
    this._AngularGauge_subgraduationColor = value;
  }
  get ATTR_AngularGauge_needleColor__DisplayName() {
    return "Needle color";
  }
  get ATTR_AngularGauge_needleColor__CategoryAttribute() {
    return "Needle";
  }
  get ATTR_AngularGauge_needleColor__DescriptionAttribute() {
    return "Needle filling color.";
  }
  get AngularGauge_needleColor() {
    return this._AngularGauge_needleColor;
  }
  set AngularGauge_needleColor(value) {
    this._AngularGauge_needleColor = value;
  }
  get ATTR_AngularGauge_needleContourColor__DisplayName() {
    return "Needle contour color";
  }
  get ATTR_AngularGauge_needleContourColor__CategoryAttribute() {
    return "Needle";
  }
  get ATTR_AngularGauge_needleContourColor__DescriptionAttribute() {
    return "Needle contour color.";
  }
  get AngularGauge_needleContourColor() {
    return this._AngularGauge_needleContourColor;
  }
  set AngularGauge_needleContourColor(value) {
    this._AngularGauge_needleContourColor = value;
  }
  get ATTR_AngularGauge_needleContourThickness__DisplayName() {
    return "Needle contour thickness";
  }
  get ATTR_AngularGauge_needleContourThickness__CategoryAttribute() {
    return "Needle";
  }
  get ATTR_AngularGauge_needleContourThickness__DescriptionAttribute() {
    return "Thickness of the needle contour";
  }
  get AngularGauge_needleContourThickness() {
    return this._AngularGauge_needleContourThickness;
  }
  set AngularGauge_needleContourThickness(value) {
    this._AngularGauge_needleContourThickness = value;
  }
  get ATTR_AngularGauge_needleLength1__DisplayName() {
    return "Needle main size (%)";
  }
  get ATTR_AngularGauge_needleLength1__CategoryAttribute() {
    return "Needle";
  }
  get ATTR_AngularGauge_needleLength1__DescriptionAttribute() {
    return "Length of the needle part pointing to gradations, in % relative to radius";
  }
  get AngularGauge_needleLength1() {
    return this._AngularGauge_needleLength1;
  }
  set AngularGauge_needleLength1(value) {
    this._AngularGauge_needleLength1 = value;
  }
  get ATTR_AngularGauge_needleLength2__DisplayName() {
    return "Needle foot size (%)";
  }
  get ATTR_AngularGauge_needleLength2__CategoryAttribute() {
    return "Needle";
  }
  get ATTR_AngularGauge_needleLength2__DescriptionAttribute() {
    return "Length of the needle part not pointing to gradations, in % relative to radius";
  }
  get AngularGauge_needleLength2() {
    return this._AngularGauge_needleLength2;
  }
  set AngularGauge_needleLength2(value) {
    this._AngularGauge_needleLength2 = value;
  }
  get ATTR_AngularGauge_needleWidth__DisplayName() {
    return "Needle width (%)";
  }
  get ATTR_AngularGauge_needleWidth__CategoryAttribute() {
    return "Needle";
  }
  get ATTR_AngularGauge_needleWidth__DescriptionAttribute() {
    return "Width of the needle, in % relative to radius";
  }
  get AngularGauge_needleWidth() {
    return this._AngularGauge_needleWidth;
  }
  set AngularGauge_needleWidth(value) {
    this._AngularGauge_needleWidth = value;
  }
  get ATTR_AngularGauge_needleMaxSpeed__DisplayName() {
    return "Needle max speed (%)";
  }
  get ATTR_AngularGauge_needleMaxSpeed__CategoryAttribute() {
    return "Needle";
  }
  get ATTR_AngularGauge_needleMaxSpeed__DescriptionAttribute() {
    return 'Needle Maximum speed, in % relative to (max-min). This is meant to limit "teleporting" effects.';
  }
  get AngularGauge_needleMaxSpeed() {
    return this._AngularGauge_needleMaxSpeed;
  }
  set AngularGauge_needleMaxSpeed(value) {
    this._AngularGauge_needleMaxSpeed = value;
  }
  get ATTR_AngularGauge_unitFont__DisplayName() {
    return "Unit Line Font";
  }
  get ATTR_AngularGauge_unitFont__CategoryAttribute() {
    return "Text lines";
  }
  get ATTR_AngularGauge_unitFont__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_AngularGauge_unitFont__DescriptionAttribute() {
    return "Font used in the text line describing unit";
  }
  get AngularGauge_unitFont() {
    return this._AngularGauge_unitFont;
  }
  set AngularGauge_unitFont(value) {
    this._AngularGauge_unitFont = value;
  }
  get ATTR_AngularGauge_statusFont__DisplayName() {
    return "Status Line Font";
  }
  get ATTR_AngularGauge_statusFont__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_AngularGauge_statusFont__CategoryAttribute() {
    return "Text lines";
  }
  get ATTR_AngularGauge_statusFont__DescriptionAttribute() {
    return "Font used in the text line gauge status";
  }
  get AngularGauge_statusFont() {
    return this._AngularGauge_statusFont;
  }
  set AngularGauge_statusFont(value) {
    this._AngularGauge_statusFont = value;
  }
  get ATTR_AngularGauge_borderColor__DisplayName() {
    return "Border color";
  }
  get ATTR_AngularGauge_borderColor__CategoryAttribute() {
    return "Dial";
  }
  get ATTR_AngularGauge_borderColor__DescriptionAttribute() {
    return "Dial border color.";
  }
  get AngularGauge_borderColor() {
    return this._AngularGauge_borderColor;
  }
  set AngularGauge_borderColor(value) {
    this._AngularGauge_borderColor = value;
  }
  get ATTR_AngularGauge_borderThickness__DisplayName() {
    return "Border thickness ";
  }
  get ATTR_AngularGauge_borderThickness__CategoryAttribute() {
    return "Dial";
  }
  get ATTR_AngularGauge_borderThickness__DescriptionAttribute() {
    return "Thickness of the dial border";
  }
  get AngularGauge_borderThickness() {
    return this._AngularGauge_borderThickness;
  }
  set AngularGauge_borderThickness(value) {
    this._AngularGauge_borderThickness = value;
  }
  get ATTR_AngularGauge_backgroundColor1__DisplayName() {
    return "Background color 1";
  }
  get ATTR_AngularGauge_backgroundColor1__CategoryAttribute() {
    return "Dial";
  }
  get ATTR_AngularGauge_backgroundColor1__DescriptionAttribute() {
    return "Dial background gradient color 1.";
  }
  get AngularGauge_backgroundColor1() {
    return this._AngularGauge_backgroundColor1;
  }
  set AngularGauge_backgroundColor1(value) {
    this._AngularGauge_backgroundColor1 = value;
  }
  get ATTR_AngularGauge_backgroundColor2__DisplayName() {
    return "Background color 2";
  }
  get ATTR_AngularGauge_backgroundColor2__CategoryAttribute() {
    return "Dial";
  }
  get ATTR_AngularGauge_backgroundColor2__DescriptionAttribute() {
    return "Dial background gradient color 2.";
  }
  get AngularGauge_backgroundColor2() {
    return this._AngularGauge_backgroundColor2;
  }
  set AngularGauge_backgroundColor2(value) {
    this._AngularGauge_backgroundColor2 = value;
  }
  get ATTR_AngularGauge_zones0__DisplayName() {
    return "Zone 1";
  }
  get ATTR_AngularGauge_zones0__CategoryAttribute() {
    return "Zones";
  }
  get ATTR_AngularGauge_zones0__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_AngularGauge_zones0__DescriptionAttribute() {
    return "Zone 1 parameters";
  }
  get AngularGauge_zones0() {
    return this._AngularGauge_zones0;
  }
  set AngularGauge_zones0(value) {
    this._AngularGauge_zones0 = value;
  }
  get ATTR_AngularGauge_zones1__DisplayName() {
    return "Zone 2";
  }
  get ATTR_AngularGauge_zones1__CategoryAttribute() {
    return "Zones";
  }
  get ATTR_AngularGauge_zones1__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_AngularGauge_zones1__DescriptionAttribute() {
    return "Zone 2 parameters";
  }
  get AngularGauge_zones1() {
    return this._AngularGauge_zones1;
  }
  set AngularGauge_zones1(value) {
    this._AngularGauge_zones1 = value;
  }
  get ATTR_AngularGauge_zones2__DisplayName() {
    return "Zone 2";
  }
  get ATTR_AngularGauge_zones2__CategoryAttribute() {
    return "Zones";
  }
  get ATTR_AngularGauge_zones2__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_AngularGauge_zones2__DescriptionAttribute() {
    return "Zone 2 parameters";
  }
  get AngularGauge_zones2() {
    return this._AngularGauge_zones2;
  }
  set AngularGauge_zones2(value) {
    this._AngularGauge_zones2 = value;
  }
  get ATTR_AngularGauge_annotationPanels0__DisplayName() {
    return "Annotation 1";
  }
  get ATTR_AngularGauge_annotationPanels0__CategoryAttribute() {
    return "Annotations";
  }
  get ATTR_AngularGauge_annotationPanels0__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_AngularGauge_annotationPanels0__DescriptionAttribute() {
    return "Customizable text panels";
  }
  get AngularGauge_annotationPanels0() {
    return this._annotationPanels0;
  }
  set AngularGauge_annotationPanels0(value) {
    this._annotationPanels0 = value;
  }
  get ATTR_AngularGauge_annotationPanels1__DisplayName() {
    return "Annotation 2";
  }
  get ATTR_AngularGauge_annotationPanels1__CategoryAttribute() {
    return "Annotations";
  }
  get ATTR_AngularGauge_annotationPanels1__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_AngularGauge_annotationPanels1__DescriptionAttribute() {
    return "Customizable text panels";
  }
  get AngularGauge_annotationPanels1() {
    return this._annotationPanels1;
  }
  set AngularGauge_annotationPanels1(value) {
    this._annotationPanels1 = value;
  }
};
var ZoneDescription = class {
  constructor(min, max, color) {
    this._visible = false;
    this._min = min;
    this._max = max;
    this._color = color;
  }
  get summary() {
    return this._visible ? this._min.toString() + ".." + this._max.toString() : "Disabled";
  }
  get ATTR_visible__DisplayName() {
    return "Visible";
  }
  get ATTR_visible__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_visible__DescriptionAttribute() {
    return "Zone visibility.";
  }
  get visible() {
    return this._visible;
  }
  set visible(value) {
    this._visible = value;
  }
  get ATTR_min__DisplayName() {
    return "Minimum value";
  }
  get ATTR_min__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_min__DescriptionAttribute() {
    return "Zone minimum value";
  }
  get min() {
    return this._min;
  }
  set min(value) {
    this._min = value;
  }
  get ATTR_max__DisplayName() {
    return "Maximum value";
  }
  get ATTR_max__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_max__DescriptionAttribute() {
    return "Zone maximum value";
  }
  get max() {
    return this._max;
  }
  set max(value) {
    this._max = value;
  }
  get ATTR_color__DisplayName() {
    return "Color";
  }
  get ATTR_color__DescriptionAttribute() {
    return "Zone color";
  }
  get color() {
    return this._color;
  }
  set color(value) {
    this._color = value;
  }
};
var AngularZoneDescription = class {
  constructor(min, max, color) {
    this._width = 5;
    this._outerRadius = 98;
    this._visible = false;
    this._min = min;
    this._max = max;
    this._color = color;
  }
  get summary() {
    return this._visible ? this._min.toString() + ".." + this._max.toString() : "Disabled";
  }
  get ATTR_visible__DisplayName() {
    return "Visible";
  }
  get ATTR_visible__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_visible__DescriptionAttribute() {
    return "Zone visibility.";
  }
  get visible() {
    return this._visible;
  }
  set visible(value) {
    this._visible = value;
  }
  get ATTR_min__DisplayName() {
    return "Minimum value";
  }
  get ATTR_min__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_min__DescriptionAttribute() {
    return "Zone minimum value";
  }
  get min() {
    return this._min;
  }
  set min(value) {
    this._min = value;
  }
  get ATTR_max__DisplayName() {
    return "Maximum value";
  }
  get ATTR_max__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_max__DescriptionAttribute() {
    return "Zone maximum value";
  }
  get max() {
    return this._max;
  }
  set max(value) {
    this._max = value;
  }
  get ATTR_color__DisplayName() {
    return "Color";
  }
  get ATTR_color__DescriptionAttribute() {
    return "Zone color";
  }
  get color() {
    return this._color;
  }
  set color(value) {
    this._color = value;
  }
  get ATTR_outerRadius__DisplayName() {
    return "Outer radius (%)";
  }
  get ATTR_outerRadius__DescriptionAttribute() {
    return "Zone outer radius, in percentage relative to dial radius ";
  }
  get outerRadius() {
    return this._outerRadius;
  }
  set outerRadius(value) {
    this._outerRadius = value;
  }
  get ATTR_width__DisplayName() {
    return "Width (%)";
  }
  get ATTR_width__DescriptionAttribute() {
    return "Zone  width, in percentage relative to dial radius ";
  }
  get width() {
    return this._width;
  }
  set width(value) {
    this._width = value;
  }
};
var FontDescription = class {
  constructor(name, size, color, italic, bold) {
    this._name = name;
    this._size = size;
    this._color = color;
    this._italic = italic;
    this._bold = bold;
  }
  ToString() {
    return this._name + " " + this._size.toString();
  }
  get summary() {
    return this._name + " " + this._size.toString();
  }
  get ATTR_name__DisplayName() {
    return "Font name";
  }
  get ATTR_name__AllowedValues() {
    return fontNameTypeDescription.AllowedValues;
  }
  get ATTR_name__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_name__DescriptionAttribute() {
    return "Name of the font";
  }
  get name() {
    return this._name;
  }
  set name(value) {
    this._name = value;
  }
  get ATTR_size__DisplayName() {
    return "Font size";
  }
  get ATTR_size__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_size__DescriptionAttribute() {
    return "Size of the font";
  }
  get size() {
    return this._size;
  }
  set size(value) {
    this._size = Math.round(100 * value) / 100;
  }
  get ATTR_color__DisplayName() {
    return "Font color";
  }
  get ATTR_color__DescriptionAttribute() {
    return "Color of the font.";
  }
  get color() {
    return this._color;
  }
  set color(value) {
    this._color = value;
  }
  get ATTR_italic__DisplayName() {
    return "Italic";
  }
  get ATTR_italic__DescriptionAttribute() {
    return "Is the font style italic?.";
  }
  get italic() {
    return this._italic;
  }
  set italic(value) {
    this._italic = value;
  }
  get ATTR_bold__DisplayName() {
    return "Bold";
  }
  get ATTR_bold__DescriptionAttribute() {
    return "Is the font style bold?.";
  }
  get bold() {
    return this._bold;
  }
  set bold(value) {
    this._bold = value;
  }
};
var digitalDisplayFormProperties = class extends GenericProperties {
  constructor(initData, owner) {
    super(owner);
    this._DataSource_source = sensorsManager.getNullSensor();
    this._DataSource_precision = "0.1";
    this._DataSource_AlarmSection0 = new AlarmSection(0);
    this._DataSource_AlarmSection1 = new AlarmSection(1);
    this._font = new FontDescription("Arial", 48, YColor.LightGreen, false, true);
    this._display_backgroundColor1 = YColor.Black;
    this._display_backgroundColor2 = YColor.Black;
    this._hrzAlignment = YDigitalDisplay.HrzAlignment.RIGHT;
    this._hrzAlignmentOfset = 5;
    this._outOfRangeMin = new doubleNan(Number.NaN);
    this._outOfRangeMax = new doubleNan(Number.NaN);
    this._outOfRangeColor = YColor.Red;
    this._annotationPanels0 = new AnnotationPanelDescription(GenericPanel.HorizontalAlignPos.CENTER, GenericPanel.VerticalAlignPos.CENTER, 0, false, "$NAME$", YColor.FromArgb(0, 127, 127, 127), YColor.FromArgb(0, 127, 127, 127), 10, YColor.FromArgb(255, 0, 0, 0));
    this._annotationPanels1 = new AnnotationPanelDescription(GenericPanel.HorizontalAlignPos.CENTER, GenericPanel.VerticalAlignPos.BOTTOM, 0, false, "$NAME$", YColor.FromArgb(0, 127, 127, 127), YColor.FromArgb(0, 127, 127, 127), 10, YColor.FromArgb(255, 0, 0, 0));
    this.initFromXmlData(initData);
    this.PropagateDataSourceChange();
  }
  PropagateDataSourceChange() {
    this.ownerForm.SourceChanged(this._DataSource_source, 0);
    let props = GenericProperties.getAllProperties(this).byName;
    let name;
    for (name in props) {
      if (name.startsWith("DataSource_AlarmSection")) {
        this[name].setDataSource(this._DataSource_source);
      }
    }
  }
  IsDataSourceAssigned() {
    return !(this._DataSource_source instanceof NullYSensor);
  }
  get ATTR_DataSource_source__DisplayName() {
    return "Sensor";
  }
  get ATTR_DataSource_source__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_source__ParamCategorySummaryAttribute() {
    return "sensorDescription";
  }
  get ATTR_DataSource_source__PreExpandedCategoryAttribute() {
    return true;
  }
  get ATTR_DataSource_source__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_DataSource_source__DescriptionAttribute() {
    return "Yoctopuce sensor feeding the display. " + GenericHints.CheckSensor;
  }
  get DataSource_source() {
    return this._DataSource_source;
  }
  set DataSource_source(value) {
    let prev = this._DataSource_source;
    this._DataSource_source = value;
    this.PropagateDataSourceChange();
    if (this._DataSource_source != prev)
      constants.edited = true;
  }
  get isSensorReadOnly() {
    return this._DataSource_source.isReadOnly;
  }
  get sensorDescription() {
    return this._DataSource_source instanceof NullYSensor ? "none" : this._DataSource_source.get_friendlyName();
  }
  get ATTR_DataSource_freq__DisplayName() {
    return "Sensor freq";
  }
  get ATTR_DataSource_freq__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_freq__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_DataSource_freq__IsReadonlyCallAttribute() {
    return "isSensorReadOnly";
  }
  get ATTR_DataSource_freq__DescriptionAttribute() {
    return "Sensor data acquisition frequency." + GenericHints.DevConfAffected;
  }
  get ATTR_DataSource_freq__AllowedValues() {
    return sensorFreqTypeDescription.AllowedValues;
  }
  get DataSource_freq() {
    return this._DataSource_source.get_frequency();
  }
  set DataSource_freq(value) {
    this._DataSource_source.set_frequency(value);
  }
  get ATTR_DataSource_precision__DisplayName() {
    return "Precision";
  }
  get ATTR_DataSource_precision__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_precision__DescriptionAttribute() {
    return "How many digits shown after the decimal point.";
  }
  get ATTR_DataSource_precision__AllowedValues() {
    return sensorPrecisionTypeDescription.AllowedValues;
  }
  get DataSource_precision() {
    return this._DataSource_precision;
  }
  set DataSource_precision(value) {
    this._DataSource_precision = value;
  }
  get ATTR_DataSource_AlarmSection0__DisplayName() {
    return "Sensor value alarm 1";
  }
  get ATTR_DataSource_AlarmSection0__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection0__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection0__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_AlarmSection0__DescriptionAttribute() {
    return "Alarm 1 for this data source, expand for more.";
  }
  get DataSource_AlarmSection0() {
    return this._DataSource_AlarmSection0;
  }
  set DataSource_AlarmSection0(value) {
    this._DataSource_AlarmSection0 = value;
  }
  get ATTR_DataSource_AlarmSection1__DisplayName() {
    return "Sensor value alarm 2";
  }
  get ATTR_DataSource_AlarmSection1__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection1__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection1__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_AlarmSection1__DescriptionAttribute() {
    return "Alarm 2 for this data source, expand for more.";
  }
  get DataSource_AlarmSection1() {
    return this._DataSource_AlarmSection1;
  }
  set DataSource_AlarmSection1(value) {
    this._DataSource_AlarmSection1 = value;
  }
  get ATTR_display_font__DisplayName() {
    return "Font";
  }
  get ATTR_display_font__CategoryAttribute() {
    return "Display";
  }
  get ATTR_display_font__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_display_font__DescriptionAttribute() {
    return "Display font";
  }
  get display_font() {
    return this._font;
  }
  set display_font(value) {
    this._font = value;
  }
  get ATTR_display_backgroundColor1__DisplayName() {
    return "Background color 1";
  }
  get ATTR_display_backgroundColor1__CategoryAttribute() {
    return "Display";
  }
  get ATTR_display_backgroundColor1__DescriptionAttribute() {
    return "Display background gradient color 1.";
  }
  get display_backgroundColor1() {
    return this._display_backgroundColor1;
  }
  set display_backgroundColor1(value) {
    this._display_backgroundColor1 = value;
  }
  get ATTR_display_backgroundColor2__DisplayName() {
    return "Background color 2";
  }
  get ATTR_display_backgroundColor2__CategoryAttribute() {
    return "Display";
  }
  get ATTR_display_backgroundColor2__DescriptionAttribute() {
    return "Display background gradient color 2.";
  }
  get display_backgroundColor2() {
    return this._display_backgroundColor2;
  }
  set display_backgroundColor2(value) {
    this._display_backgroundColor2 = value;
  }
  get ATTR_display_hrzAlignment__DisplayName() {
    return "Hrz alignment method";
  }
  get ATTR_display_hrzAlignment__CategoryAttribute() {
    return "Display";
  }
  get ATTR_display_hrzAlignment__DescriptionAttribute() {
    return "Horizontal alignment method";
  }
  get display_hrzAlignment() {
    return this._hrzAlignment;
  }
  set display_hrzAlignment(value) {
    this._hrzAlignment = value;
  }
  get ATTR_display_hrzAlignmentOfset__DisplayName() {
    return "Hrz alignment offset";
  }
  get ATTR_display_hrzAlignmentOfset__CategoryAttribute() {
    return "Display";
  }
  get ATTR_display_hrzAlignmentOfset__DescriptionAttribute() {
    return "Horizontal alignment offset in percentage. No effect when chosen horizontal alignment is CENTER";
  }
  get display_hrzAlignmentOfset() {
    return this._hrzAlignmentOfset;
  }
  set display_hrzAlignmentOfset(value) {
    this._hrzAlignmentOfset = value;
  }
  get ATTR_display_outOfRangeMin__DisplayName() {
    return "Minimum value";
  }
  get ATTR_display_outOfRangeMin__CategoryAttribute() {
    return "Range Control";
  }
  get ATTR_display_outOfRangeMin__DescriptionAttribute() {
    return `Regular range minimum value. if value goes  outside regular  range, color will turn to "Out of range Color".Leave blank if you don't want to define such a range. `;
  }
  get display_outOfRangeMin() {
    return this._outOfRangeMin;
  }
  set display_outOfRangeMin(value) {
    this._outOfRangeMin = value;
  }
  get ATTR_display_outOfRangeMax__DisplayName() {
    return "Maximum value";
  }
  get ATTR_display_outOfRangeMax__CategoryAttribute() {
    return "Range Control";
  }
  get ATTR_display_outOfRangeMax__DescriptionAttribute() {
    return `Regular range minimum value. if value goes  outside regular  range, color will turn to "Out of range Color".Leave blank if you don't want to define such a range. `;
  }
  get display_outOfRangeMax() {
    return this._outOfRangeMax;
  }
  set display_outOfRangeMax(value) {
    this._outOfRangeMax = value;
  }
  get ATTR_display_outOfRangeColor__DisplayName() {
    return "Out of range Color";
  }
  get ATTR_display_outOfRangeColor__CategoryAttribute() {
    return "Range Control";
  }
  get ATTR_display_outOfRangeColor__DescriptionAttribute() {
    return "Digits color when value is out of range.";
  }
  get display_outOfRangeColor() {
    return this._outOfRangeColor;
  }
  set display_outOfRangeColor(value) {
    this._outOfRangeColor = value;
  }
  get ATTR_display_annotationPanels0__DisplayName() {
    return "Annotation 1";
  }
  get ATTR_display_annotationPanels0__CategoryAttribute() {
    return "Annotations";
  }
  get ATTR_display_annotationPanels0__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_display_annotationPanels0__DescriptionAttribute() {
    return "Customizable text panels";
  }
  get display_annotationPanels0() {
    return this._annotationPanels0;
  }
  set display_annotationPanels0(value) {
    this._annotationPanels0 = value;
  }
  get ATTR_display_annotationPanels1__DisplayName() {
    return "Annotation 2";
  }
  get ATTR_display_annotationPanels1__CategoryAttribute() {
    return "Annotations";
  }
  get ATTR_display_annotationPanels1__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_display_annotationPanels1__DescriptionAttribute() {
    return "Customizable text panels";
  }
  get display_annotationPanels1() {
    return this._annotationPanels1;
  }
  set display_annotationPanels1(value) {
    this._annotationPanels1 = value;
  }
};
var AlarmSection = class {
  get summary() {
    let c = this._sensor.getAlarmCondition(this._index);
    if (c == 0)
      return "Disabled";
    return "Enabled";
  }
  constructor(index) {
    this._sensor = sensorsManager.getNullSensor();
    this._index = 0;
    this._index = index;
  }
  get ATTR_source__DisplayName() {
    return "Data source type";
  }
  get ATTR_source__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_source__AllowedValues() {
    return sensorDataTypeDescription.AllowedValues;
  }
  get ATTR_source__DescriptionAttribute() {
    return "Alarm sensor data source (Average, minimum or maximum value during last interval)";
  }
  get source() {
    return this._sensor.getAlarmSource(this._index);
  }
  set source(value) {
    this._sensor.setAlarmSource(this._index, value);
  }
  get ATTR_condition__DisplayName() {
    return "Test Condition";
  }
  get ATTR_condition__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_condition__AllowedValues() {
    return AlarmTestTypeDescription.AllowedValues;
  }
  get ATTR_condition__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_condition__DescriptionAttribute() {
    return "Alarm trigger condition";
  }
  get condition() {
    return this._sensor.getAlarmCondition(this._index);
  }
  set condition(value) {
    this._sensor.setAlarmCondition(this._index, value);
  }
  setDataSource(sensor) {
    this._sensor = sensor;
  }
  get ATTR_value__DisplayName() {
    return "Test Value";
  }
  get ATTR_value__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_value__DescriptionAttribute() {
    return "Value for the Alarm trigger";
  }
  get value() {
    return this._sensor.getAlarmValue(this._index);
  }
  set value(value) {
    this._sensor.setAlarmValue(this._index, value);
  }
  get ATTR_commandLine__DisplayName() {
    return "Trigger action";
  }
  get ATTR_commandLine__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_commandLine__DescriptionAttribute() {
    return "Javascript snippet executed in your browser each time the alarm is triggered, you can use the following variables: $SENSORVALUE$, $UNIT$, $HWDID$, $NAME$, $CONDITION$, $TRIGGER$, $DATATYPE$, $NOW$. Example : <tt>alarm('Warning $NAME$ = $SENSORVALUE$!');</tt>. You can check logs to find out if your alarm code works.";
  }
  get commandLine() {
    return this._sensor.getAlarmCommandline(this._index);
  }
  set commandLine(value) {
    this._sensor.setAlarmCommandline(this._index, value);
  }
  get ATTR_delay__DisplayName() {
    return "Trigger delay";
  }
  get ATTR_delay__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_delay__DescriptionAttribute() {
    return "Minimum delay, in seconds, between two alarms. Think carefully and make sure you won't create alarm storms.";
  }
  get delay() {
    return this._sensor.getAlarmDelay(this._index);
  }
  set delay(value) {
    this._sensor.setAlarmDelay(this._index, value);
  }
};
var ChartSerie = class {
  constructor(defaultColor) {
    this.ownerForm = null;
    this.index = -1;
    this.dataloggerAlreadyLoaded = false;
    this._DataSource_source = sensorsManager.getNullSensor();
    this._DataType = 0;
    this._thickness = 2;
    this._legend = "";
    this._color = YColor.Red;
    this._yAxisIndex = 0;
    this._DataSource_AlarmSection0 = new AlarmSection(0);
    this._DataSource_AlarmSection1 = new AlarmSection(1);
    this._color = defaultColor;
  }
  get summary() {
    return this._DataSource_source instanceof NullYSensor ? "none" : this._DataSource_source.get_friendlyName() + (this._DataSource_source.isOnline() ? "" : " - OFFLINE");
  }
  Init(owner, serieIndex) {
    this.ownerForm = owner;
    this.index = serieIndex;
    this.PropagateDataSourceChange(this._DataSource_source);
  }
  PropagateDataSourceChange(value) {
    this.ownerForm.SourceChanged(this._DataSource_source, this.index);
    let props = GenericProperties.getAllProperties(this).byName;
    let name;
    for (name in props) {
      if (name.startsWith("DataSource_AlarmSection")) {
        this[name].setDataSource(this._DataSource_source);
      }
    }
  }
  get ATTR_DataSource_source__DisplayName() {
    return "Sensor";
  }
  get ATTR_DataSource_source__CopyToTarget() {
    return false;
  }
  get ATTR_DataSource_source__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_DataSource_source__DescriptionAttribute() {
    return "Yoctopuce sensor feeding the graph. " + GenericHints.CheckSensor;
  }
  get DataSource_source() {
    return this._DataSource_source;
  }
  set DataSource_source(value) {
    let prev = this._DataSource_source;
    this._DataSource_source = value;
    if (this._DataSource_source != prev)
      constants.edited = true;
    if (this.ownerForm != null)
      this.PropagateDataSourceChange(this._DataSource_source);
  }
  get isSensorReadOnly() {
    return this._DataSource_source.isReadOnly;
  }
  get ATTR_DataSource_freq__DisplayName() {
    return "Sensor frequency";
  }
  get ATTR_DataSource_freq__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_DataSource_freq__CopyToTarget() {
    return false;
  }
  get ATTR_DataSource_freq__IsReadonlyCallAttribute() {
    return "isSensorReadOnly";
  }
  get ATTR_DataSource_freq__DescriptionAttribute() {
    return "Sensor data acquisition frequency." + GenericHints.DevConfAffected;
  }
  get ATTR_DataSource_freq__AllowedValues() {
    return sensorFreqTypeDescription.AllowedValues;
  }
  get DataSource_freq() {
    return this._DataSource_source.get_frequency();
  }
  set DataSource_freq(value) {
    this._DataSource_source.set_frequency(value);
  }
  get ATTR_DataSource_datatype__DisplayName() {
    return "Sensor data";
  }
  get ATTR_DataSource_datatype__AllowedValues() {
    return sensorDataTypeDescription.AllowedValues;
  }
  get ATTR_DataSource_datatype__CopyToTarget() {
    return false;
  }
  get ATTR_DataSource_datatype__DescriptionAttribute() {
    return "Which data for sensor are displayed on the graph. Min and Max are available only for frequencies <1Hz";
  }
  get DataSource_datatype() {
    return this._DataType;
  }
  set DataSource_datatype(value) {
    this._DataType = value;
    if (this.ownerForm != null) {
      this.ownerForm.SourceChanged(this._DataSource_source, this.index);
    }
  }
  get ATTR_DataSource_recording__DisplayName() {
    return "Sensor recording";
  }
  get ATTR_DataSource_recording__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_DataSource_recording__IsReadonlyCallAttribute() {
    return "isSensorReadOnly";
  }
  get ATTR_DataSource_recording__CopyToTarget() {
    return false;
  }
  get ATTR_DataSource_recording__DescriptionAttribute() {
    return "Enable/ disable sensor data recording in the device on-board datalogger." + GenericHints.DevConfAffected;
  }
  get DataSource_recording() {
    return this._DataSource_source.get_recording();
  }
  set DataSource_recording(value) {
    this._DataSource_source.set_recording(value);
  }
  get ATTR_thickness__DisplayName() {
    return "Thickness";
  }
  get ATTR_thickness__DescriptionAttribute() {
    return "Line thickness.";
  }
  get thickness() {
    return this._thickness;
  }
  set thickness(value) {
    this._thickness = value;
  }
  get ATTR_legend__DisplayName() {
    return "Legend";
  }
  get ATTR_legend__DescriptionAttribute() {
    return "Short description of the series.";
  }
  get legend() {
    return this._legend;
  }
  set legend(value) {
    this._legend = value;
  }
  get ATTR_color__DisplayName() {
    return "Color";
  }
  get ATTR_color__DescriptionAttribute() {
    return "Line color.";
  }
  get color() {
    return this._color;
  }
  set color(value) {
    this._color = value;
  }
  get ATTR_yAxisIndex__AllowedValues() {
    return yAxisDescription.AllowedValues;
  }
  get ATTR_yAxisIndex__DisplayName() {
    return "Y axis";
  }
  get ATTR_yAxisIndex__DescriptionAttribute() {
    return "Choose which Y axis the data with be scaled to.";
  }
  get yAxisIndex() {
    return this._yAxisIndex;
  }
  set yAxisIndex(value) {
    this._yAxisIndex = value;
  }
  get ATTR_DataSource_AlarmSection0__DisplayName() {
    return "Sensor value alarm 1";
  }
  get ATTR_DataSource_AlarmSection0__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection0__DescriptionAttribute() {
    return "Alarm 1 for this data source, expand for more.";
  }
  get DataSource_AlarmSection0() {
    return this._DataSource_AlarmSection0;
  }
  set DataSource_AlarmSection0(value) {
    this._DataSource_AlarmSection0 = value;
  }
  get ATTR_DataSource_AlarmSection1__DisplayName() {
    return "Sensor value alarm 2";
  }
  get ATTR_DataSource_AlarmSection1__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection1__DescriptionAttribute() {
    return "Alarm 2 for this data source, expand for more.";
  }
  get DataSource_AlarmSection1() {
    return this._DataSource_AlarmSection1;
  }
  set DataSource_AlarmSection1(value) {
    this._DataSource_AlarmSection1 = value;
  }
};
var LegendPanelDescription = class {
  constructor() {
    this._enabled = false;
    this._overlap = false;
    this._position = LegendPanel.Position.RIGHT;
    this._font = new FontDescription("Arial", 7, YColor.FromArgb(255, 32, 32, 32), false, true);
    this._bgColor = YColor.FromArgb(200, 255, 255, 255);
    this._borderColor = YColor.Black;
    this._borderthickness = 1;
    this._padding = 10;
    this._verticalMargin = 10;
    this._horizontalMargin = 10;
    this._traceWidthFactor = 1;
  }
  get summary() {
    return this._enabled ? "Enabled" : "Disabled";
  }
  get ATTR_enabled__DisplayName() {
    return "Enabled";
  }
  get ATTR_enabled__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_enabled__DescriptionAttribute() {
    return "Should the legend panel be shown or not";
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    this._enabled = value;
  }
  get ATTR_overlap__DisplayName() {
    return "Overlap";
  }
  get ATTR_overlap__DescriptionAttribute() {
    return "Can the panel overlap the graph data, or should we explicitly make space for it?";
  }
  get overlap() {
    return this._overlap;
  }
  set overlap(value) {
    this._overlap = value;
  }
  get ATTR_position__DisplayName() {
    return "Position";
  }
  get ATTR_position__DescriptionAttribute() {
    return "Position of the legend panel";
  }
  get position() {
    return this._position;
  }
  set position(value) {
    this._position = value;
  }
  get ATTR_font__DisplayName() {
    return "Font";
  }
  get ATTR_font__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_font__DescriptionAttribute() {
    return "Legend panel contents fonts";
  }
  get font() {
    return this._font;
  }
  set font(value) {
    this._font = value;
  }
  get ATTR_bgColor__DisplayName() {
    return "Background color ";
  }
  get ATTR_bgColor__DescriptionAttribute() {
    return "Legend panel background color.";
  }
  get bgColor() {
    return this._bgColor;
  }
  set bgColor(value) {
    this._bgColor = value;
  }
  get ATTR_borderColor__DisplayName() {
    return "Border color ";
  }
  get ATTR_borderColor__DescriptionAttribute() {
    return "Legend panel border color.";
  }
  get borderColor() {
    return this._borderColor;
  }
  set borderColor(value) {
    this._borderColor = value;
  }
  get ATTR_borderthickness__DisplayName() {
    return "Border thickness ";
  }
  get ATTR_borderthickness__DescriptionAttribute() {
    return "Legend panel border thickness";
  }
  get borderthickness() {
    return this._borderthickness;
  }
  set borderthickness(value) {
    this._borderthickness = value;
  }
  get ATTR_padding__DisplayName() {
    return "Padding ";
  }
  get ATTR_padding__DescriptionAttribute() {
    return "Distance between the panel border and the panel contents";
  }
  get padding() {
    return this._padding;
  }
  set padding(value) {
    this._padding = value;
  }
  get ATTR_verticalMargin__DisplayName() {
    return "Vertical margin ";
  }
  get ATTR_verticalMargin__DescriptionAttribute() {
    return "Vertical distance between the panel border and its surroundings";
  }
  get verticalMargin() {
    return this._verticalMargin;
  }
  set verticalMargin(value) {
    this._verticalMargin = value;
  }
  get ATTR_horizontalMargin__DisplayName() {
    return "Horizontal margin ";
  }
  get ATTR_horizontalMargin__DescriptionAttribute() {
    return "Distance between the panel border and its surroundings";
  }
  get horizontalMargin() {
    return this._horizontalMargin;
  }
  set horizontalMargin(value) {
    this._horizontalMargin = value;
  }
  get ATTR_traceWidthFactor__DisplayName() {
    return "Color Indicator Factor";
  }
  get ATTR_traceWidthFactor__DescriptionAttribute() {
    return "Factor used to enlarge series color indicators shown in the legend panel";
  }
  get traceWidthFactor() {
    return this._traceWidthFactor;
  }
  set traceWidthFactor(value) {
    this._traceWidthFactor = value;
  }
};
var AnnotationPanelDescription = class {
  get summary() {
    return this._enabled ? "Enabled" : "Disabled";
  }
  get ATTR_enabled__DisplayName() {
    return "Enabled";
  }
  get ATTR_enabled__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_enabled__DescriptionAttribute() {
    return "Should the annotation panel be shown or not";
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    this._enabled = value;
  }
  get ATTR_overlap__DisplayName() {
    return "Overlap";
  }
  get ATTR_overlap__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_overlap__DescriptionAttribute() {
    return "Can the annotation panel overlap the display zone, or should the display zone be squeezed to make space for the panel?";
  }
  get overlap() {
    return this._overlap;
  }
  set overlap(value) {
    this._overlap = value;
  }
  get ATTR_text__DisplayName() {
    return "Text ";
  }
  get ATTR_text__DescriptionAttribute() {
    return GenericHints.Annotation;
  }
  get text() {
    return this._text;
  }
  set text(value) {
    this._text = value;
  }
  get ATTR_panelTextAlign__DisplayName() {
    return "Text Alignment";
  }
  get ATTR_panelTextAlign__DescriptionAttribute() {
    return "How text is aligned, makes sense on multi-lines text only.";
  }
  get panelTextAlign() {
    return this._panelTextAlign;
  }
  set panelTextAlign(value) {
    this._panelTextAlign = value;
  }
  get ATTR_panelHrzAlign__DisplayName() {
    return "X Position";
  }
  get ATTR_panelHrzAlign__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_panelHrzAlign__DescriptionAttribute() {
    return "Annotation panel X position";
  }
  get panelHrzAlign() {
    return this._panelHrzAlign;
  }
  set panelHrzAlign(value) {
    this._panelHrzAlign = value;
  }
  get ATTR_positionOffsetX__DisplayName() {
    return "X Offset";
  }
  get ATTR_positionOffsetX__DescriptionAttribute() {
    return "X Position offset, in %  (overlap mode only)";
  }
  get positionOffsetX() {
    return this._positionOffsetX;
  }
  set positionOffsetX(value) {
    this._positionOffsetX = value;
  }
  get ATTR_panelVrtAlign__DisplayName() {
    return "Y Position";
  }
  get ATTR_panelVrtAlign__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_panelVrtAlign__DescriptionAttribute() {
    return "Annotation panel Y position";
  }
  get panelVrtAlign() {
    return this._panelVrtAlign;
  }
  set panelVrtAlign(value) {
    this._panelVrtAlign = value;
  }
  get ATTR_positionOffsetY__DisplayName() {
    return "Y Offset";
  }
  get ATTR_positionOffsetY__DescriptionAttribute() {
    return "Y Position offset, in %  (overlap mode only)";
  }
  get positionOffsetY() {
    return this._positionOffsetY;
  }
  set positionOffsetY(value) {
    this._positionOffsetY = value;
  }
  get ATTR_font__DisplayName() {
    return "Font";
  }
  get ATTR_font__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_font__DescriptionAttribute() {
    return "Panel font";
  }
  get font() {
    return this._font;
  }
  set font(value) {
    this._font = value;
  }
  get ATTR_bgColor__DisplayName() {
    return "Background color ";
  }
  get ATTR_bgColor__DescriptionAttribute() {
    return "Legend panel background color.";
  }
  get bgColor() {
    return this._bgColor;
  }
  set bgColor(value) {
    this._bgColor = value;
  }
  get ATTR_borderColor__DisplayName() {
    return "Border color ";
  }
  get ATTR_borderColor__DescriptionAttribute() {
    return "Legend panel border color.";
  }
  get borderColor() {
    return this._borderColor;
  }
  set borderColor(value) {
    this._borderColor = value;
  }
  get ATTR_borderthickness__DisplayName() {
    return "Border thickness ";
  }
  get ATTR_borderthickness__DescriptionAttribute() {
    return "Panel border thickness";
  }
  get borderthickness() {
    return this._borderthickness;
  }
  set borderthickness(value) {
    this._borderthickness = value;
  }
  get ATTR_padding__DisplayName() {
    return "Padding ";
  }
  get ATTR_padding__DescriptionAttribute() {
    return "Distance between the panel border and the panel contents";
  }
  get padding() {
    return this._padding;
  }
  set padding(value) {
    this._padding = value;
  }
  constructor(hrzAlignInit, vrtAlignInit, offsetY, overlap, textInit, BgColorInit, BorderColorInit, fontSizeInit, FontColorInit) {
    this._enabled = false;
    this._overlap = false;
    this._text = "Date: $DAY$/$MONTH$/$YEAR$";
    this._panelTextAlign = GenericPanel.TextAlign.CENTER;
    this._panelHrzAlign = GenericPanel.HorizontalAlignPos.CENTER;
    this._positionOffsetX = 0;
    this._panelVrtAlign = GenericPanel.VerticalAlignPos.TOP;
    this._positionOffsetY = 0;
    this._font = new FontDescription("Arial", 12, YColor.FromArgb(255, 32, 32, 32), false, false);
    this._bgColor = YColor.FromArgb(200, 255, 255, 255);
    this._borderColor = YColor.Black;
    this._borderthickness = 1;
    this._padding = 5;
    if (typeof textInit != "undefined")
      this._text = textInit;
    if (typeof offsetY != "undefined")
      this._positionOffsetY = offsetY;
    if (typeof overlap != "undefined")
      this._overlap = overlap;
    if (typeof BgColorInit != "undefined")
      this._bgColor = BgColorInit;
    if (typeof BorderColorInit != "undefined")
      this._borderColor = BorderColorInit;
    if (typeof fontSizeInit != "undefined")
      this._font.size = fontSizeInit;
    if (typeof FontColorInit != "undefined")
      this._font.color = FontColorInit;
    if (typeof vrtAlignInit != "undefined")
      this._panelVrtAlign = vrtAlignInit;
    if (typeof hrzAlignInit != "undefined")
      this._panelHrzAlign = hrzAlignInit;
  }
};
var AnnotationPanelDescriptionGraph = class extends AnnotationPanelDescription {
  get ATTR_enabled__DisplayName() {
    return "Enabled";
  }
  get ATTR_enabled__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_enabled__DescriptionAttribute() {
    return "Should the annotation panel be shown or not";
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    this._enabled = value;
  }
  get ATTR_overlap__DisplayName() {
    return "Overlap";
  }
  get ATTR_overlap__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_overlap__DescriptionAttribute() {
    return "Can the annotation panel overlap the graph, or should the graph be squeezed to make space for the panel?";
  }
  get overlap() {
    return this._overlap;
  }
  set overlap(value) {
    this._overlap = value;
  }
  get ATTR_text__DisplayName() {
    return "Text ";
  }
  get ATTR_text__DescriptionAttribute() {
    return GenericHints.AnnotationGraph;
  }
  get text() {
    return this._text;
  }
  set text(value) {
    this._text = value;
  }
};
var DataTrackerDescription = class {
  constructor() {
    this._enabled = false;
    this._showSerieName = false;
    this._showTimeStamp = false;
    this._dataPrecision = DataTrackerDescription.DataPrecision.PRECISION_NOLIMIT;
    this._diameter = 5;
    this._handleLength = 25;
    this._font = new FontDescription("Arial", 7, YColor.FromArgb(255, 32, 32, 32), false, false);
    this._bgColor = YColor.FromArgb(200, 255, 255, 255);
    this._borderColor = YColor.Black;
    this._borderthickness = 1;
    this._padding = 5;
    this._detectionDistance = 50;
  }
  get summary() {
    return this._enabled ? "Enabled" : "Disabled";
  }
  get ATTR_enabled__DisplayName() {
    return "Enabled";
  }
  get ATTR_enabled__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_enabled__DescriptionAttribute() {
    return "Should the data tracker be shown or not.";
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    this._enabled = value;
  }
  get ATTR_showSerieName__DisplayName() {
    return "Show Series legend";
  }
  get ATTR_showSerieName__DescriptionAttribute() {
    return "Should the data tracker show the value's series legend.";
  }
  get showSerieName() {
    return this._showSerieName;
  }
  set showSerieName(value) {
    this._showSerieName = value;
  }
  get ATTR_showTimeStamp__DisplayName() {
    return "Show Timestamp";
  }
  get ATTR_showTimeStamp__DescriptionAttribute() {
    return "Should the data tracker show the value's timestamp.";
  }
  get showTimeStamp() {
    return this._showTimeStamp;
  }
  set showTimeStamp(value) {
    this._showTimeStamp = value;
  }
  get ATTR_dataPrecision__DisplayName() {
    return "Precision";
  }
  get ATTR_dataPrecision__DescriptionAttribute() {
    return "A way to limit data precision to meaningful digits in the data tracker.";
  }
  get dataPrecision() {
    return this._dataPrecision;
  }
  set dataPrecision(value) {
    this._dataPrecision = value;
  }
  get ATTR_diameter__DisplayName() {
    return "Point Diameter";
  }
  get ATTR_diameter__DescriptionAttribute() {
    return "Data point diameter, in pixels";
  }
  get diameter() {
    return this._diameter;
  }
  set diameter(value) {
    this._diameter = value;
  }
  get ATTR_handleLength__DisplayName() {
    return "Handle size";
  }
  get ATTR_handleLength__DescriptionAttribute() {
    return "size of the handle between the data point and the value panel";
  }
  get handleLength() {
    return this._handleLength;
  }
  set handleLength(value) {
    this._handleLength = value;
  }
  get ATTR_font__DisplayName() {
    return "Font";
  }
  get ATTR_font__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_font__DescriptionAttribute() {
    return "Data tracker label fonts";
  }
  get font() {
    return this._font;
  }
  set font(value) {
    this._font = value;
  }
  get ATTR_bgColor__DisplayName() {
    return "Background color";
  }
  get ATTR_bgColor__DescriptionAttribute() {
    return "Value panel ground color.";
  }
  get bgColor() {
    return this._bgColor;
  }
  set bgColor(value) {
    this._bgColor = value;
  }
  get ATTR_borderColor__DisplayName() {
    return "Border color";
  }
  get ATTR_borderColor__DescriptionAttribute() {
    return "Value panel border and handle  color.";
  }
  get borderColor() {
    return this._borderColor;
  }
  set borderColor(value) {
    this._borderColor = value;
  }
  get ATTR_borderthickness__DisplayName() {
    return "Border thickness ";
  }
  get ATTR_borderthickness__DescriptionAttribute() {
    return "Value panel border and handle  thickness";
  }
  get borderthickness() {
    return this._borderthickness;
  }
  set borderthickness(value) {
    this._borderthickness = value;
  }
  get ATTR_padding__DisplayName() {
    return "Padding";
  }
  get ATTR_padding__DescriptionAttribute() {
    return "Distance between the panel border and its contents ";
  }
  get padding() {
    return this._padding;
  }
  set padding(value) {
    this._padding = value;
  }
  get ATTR_detectionDistance__DisplayName() {
    return "Detection distance";
  }
  get ATTR_detectionDistance__DescriptionAttribute() {
    return "Maximum distance, in pixels, between the mouse and a data point for data tracker to show. Use zero for infinite distance";
  }
  get detectionDistance() {
    return this._detectionDistance;
  }
  set detectionDistance(value) {
    this._detectionDistance = value;
  }
};
(function(DataTrackerDescription2) {
  class DataPrecisionEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, DataPrecision);
    }
  }
  DataTrackerDescription2.DataPrecisionEnumItem = DataPrecisionEnumItem;
  class DataPrecision extends YEnum {
  }
  DataPrecision.PRECISION_NOLIMIT = new DataPrecisionEnumItem("PRECISION_NOLIMIT", "As is");
  DataPrecision.PRECISION_1 = new DataPrecisionEnumItem("PRECISION_1", "1");
  DataPrecision.PRECISION_01 = new DataPrecisionEnumItem("PRECISION_01", "0.1");
  DataPrecision.PRECISION_001 = new DataPrecisionEnumItem("PRECISION_001", "0.01");
  DataPrecision.PRECISION_0001 = new DataPrecisionEnumItem("PRECISION_0001", "0.001");
  DataTrackerDescription2.DataPrecision = DataPrecision;
})(DataTrackerDescription || (DataTrackerDescription = {}));
var NavigatorDescription = class {
  get summary() {
    return this._enabled ? "Enabled" : "Disabled";
  }
  constructor() {
    this._enabled = false;
    this._bgColor1 = YColor.FromArgb(255, 225, 225, 225);
    this._bgColor2 = YColor.FromArgb(255, 225, 225, 225);
    this._borderThickness = 1;
    this._borderColor = YColor.Black;
    this._cursorColor = YColor.FromArgb(25, 0, 255, 0);
    this._cursorBorderColor = YColor.FromArgb(255, 96, 96, 96);
    this._yAxisHandling = Navigator.YAxisHandling.AUTO;
    this._xAxisThickness = 1;
    this._xAxisColor = YColor.Black;
    this._font = new FontDescription("Arial", 10, YColor.FromArgb(255, 32, 32, 32), false, false);
  }
  get ATTR_enabled__DisplayName() {
    return "Enabled";
  }
  get ATTR_enabled__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_enabled__DescriptionAttribute() {
    return "Should the navigator be shown or not.";
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    this._enabled = value;
  }
  get ATTR_bgColor1__DisplayName() {
    return "Background color 1";
  }
  get ATTR_bgColor1__DescriptionAttribute() {
    return "Navigator background gradient color 1.";
  }
  get bgColor1() {
    return this._bgColor1;
  }
  set bgColor1(value) {
    this._bgColor1 = value;
  }
  get ATTR_bgColor2__DisplayName() {
    return "Background color 2";
  }
  get ATTR_bgColor2__DescriptionAttribute() {
    return "Navigator background gradient color 2.";
  }
  get bgColor2() {
    return this._bgColor2;
  }
  set bgColor2(value) {
    this._bgColor2 = value;
  }
  get ATTR_borderThickness__DisplayName() {
    return "Border thickness";
  }
  get ATTR_borderThickness__DescriptionAttribute() {
    return "Navigator";
  }
  get borderThickness() {
    return this._borderThickness;
  }
  set borderThickness(value) {
    this._borderThickness = value;
  }
  get ATTR_borderColor__DisplayName() {
    return "Border color";
  }
  get ATTR_borderColor__DescriptionAttribute() {
    return "Navigator Border color.";
  }
  get borderColor() {
    return this._borderColor;
  }
  set borderColor(value) {
    this._borderColor = value;
  }
  get ATTR_cursorColor__DisplayName() {
    return "Navigator cursor fill color";
  }
  get ATTR_cursorColor__DescriptionAttribute() {
    return "Navigator";
  }
  get cursorColor() {
    return this._cursorColor;
  }
  set cursorColor(value) {
    this._cursorColor = value;
  }
  get ATTR_cursorBorderColor__DisplayName() {
    return "Navigator cursor left/right border color.";
  }
  get ATTR_cursorBorderColor__DescriptionAttribute() {
    return "Navigator";
  }
  get cursorBorderColor() {
    return this._cursorBorderColor;
  }
  set cursorBorderColor(value) {
    this._cursorBorderColor = value;
  }
  get ATTR_yAxisHandling__DisplayName() {
    return "Y axis range";
  }
  get ATTR_yAxisHandling__DescriptionAttribute() {
    return "Is navigator Y axis zoom automatic or inherited from main view settings?";
  }
  get yAxisHandling() {
    return this._yAxisHandling;
  }
  set yAxisHandling(value) {
    this._yAxisHandling = value;
  }
  get ATTR_xAxisThickness__DisplayName() {
    return "X axis thickness";
  }
  get ATTR_xAxisThickness__DescriptionAttribute() {
    return "Navigator";
  }
  get xAxisThickness() {
    return this._xAxisThickness;
  }
  set xAxisThickness(value) {
    this._xAxisThickness = value;
  }
  get ATTR_xAxisColor__DisplayName() {
    return "X axis color";
  }
  get ATTR_xAxisColor__DescriptionAttribute() {
    return "Navigator X axis color.";
  }
  get xAxisColor() {
    return this._xAxisColor;
  }
  set xAxisColor(value) {
    this._xAxisColor = value;
  }
  get ATTR_font__DisplayName() {
    return "X-Axis Font";
  }
  get ATTR_font__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_font__DescriptionAttribute() {
    return "Navigator X axis font";
  }
  get font() {
    return this._font;
  }
  set font(value) {
    this._font = value;
  }
};
var LegendDescription = class {
  constructor() {
    this._title = "";
    this._font = new FontDescription("Arial", 12, YColor.Black, false, true);
  }
  get ATTR_title__DisplayName() {
    return "Text";
  }
  get ATTR_title__DescriptionAttribute() {
    return "Legend text";
  }
  get title() {
    return this._title;
  }
  set title(value) {
    this._title = value;
  }
  get ATTR_font__DisplayName() {
    return "Font";
  }
  get ATTR_font__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_font__DescriptionAttribute() {
    return "Legend font";
  }
  get font() {
    return this._font;
  }
  set font(value) {
    this._font = value;
  }
};
var YaxisDescription = class {
  constructor(index, shown) {
    this._visible = false;
    this._position = YAxis.HrzPosition.LEFT;
    this._min = new doubleNan(Number.NaN);
    this._max = new doubleNan(Number.NaN);
    this._step = new doubleNan(Number.NaN);
    this._color = YColor.FromArgb(255, 127, 127, 127);
    this._thickness = 1;
    this._showGrid = false;
    this._gridColor = YColor.FromArgb(255, 210, 210, 210);
    this._gridThickness = 1;
    this._font = new FontDescription("Arial", 10, YColor.Black, false, false);
    this._legend = new LegendDescription();
    this._zones0 = new ZoneDescription(0, 50, YColor.LightGreen);
    this._zones1 = new ZoneDescription(50, 80, YColor.Yellow);
    this._zones2 = new ZoneDescription(80, 100, YColor.Red);
    this._visible = shown;
    this._showGrid = index == 0;
    this._position = index == 0 ? YAxis.HrzPosition.LEFT : YAxis.HrzPosition.RIGHT;
  }
  get summary() {
    return this._visible ? "Enabled" : "Disabled";
  }
  get ATTR_visible__DisplayName() {
    return "Visible";
  }
  get ATTR_visible__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_visible__DescriptionAttribute() {
    return "Should that YAxis be shown?.";
  }
  get visible() {
    return this._visible;
  }
  set visible(value) {
    this._visible = value;
  }
  get ATTR_position__DisplayName() {
    return "Position";
  }
  get ATTR_position__DescriptionAttribute() {
    return "Y Axis position (left / right)";
  }
  get position() {
    return this._position;
  }
  set position(value) {
    this._position = value;
  }
  get ATTR_min__DisplayName() {
    return "Minimum value";
  }
  get ATTR_min__DescriptionAttribute() {
    return "YAxis minimum value, leave blank for automatic behavior.";
  }
  get min() {
    return this._min;
  }
  set min(value) {
    this._min = value;
  }
  get ATTR_max__DisplayName() {
    return "Maximum value";
  }
  get ATTR_max__DescriptionAttribute() {
    return "YAxis maximum value, leave blank for automatic behavior.";
  }
  get max() {
    return this._max;
  }
  set max(value) {
    this._max = value;
  }
  get ATTR_step__DisplayName() {
    return "Steps";
  }
  get ATTR_step__DescriptionAttribute() {
    return "YAxis step size, leave blank for automatic behavior.";
  }
  get step() {
    return this._step;
  }
  set step(value) {
    this._step = value;
  }
  get ATTR_color__DisplayName() {
    return "Color";
  }
  get ATTR_color__DescriptionAttribute() {
    return "Y Axis Color.";
  }
  get color() {
    return this._color;
  }
  set color(value) {
    this._color = value;
  }
  get ATTR_thickness__DisplayName() {
    return "Thickness";
  }
  get ATTR_thickness__DescriptionAttribute() {
    return "Axis thickness";
  }
  get thickness() {
    return this._thickness;
  }
  set thickness(value) {
    this._thickness = value;
  }
  get ATTR_showGrid__DisplayName() {
    return "Show Grid";
  }
  get ATTR_showGrid__DescriptionAttribute() {
    return "Show grid horizontal lines, or not.";
  }
  get showGrid() {
    return this._showGrid;
  }
  set showGrid(value) {
    this._showGrid = value;
  }
  get ATTR_gridColor__DisplayName() {
    return "Grid Color";
  }
  get ATTR_gridColor__DescriptionAttribute() {
    return "Grid horizontal lines color.";
  }
  get gridColor() {
    return this._gridColor;
  }
  set gridColor(value) {
    this._gridColor = value;
  }
  get ATTR_gridThickness__DisplayName() {
    return "Grid thickness";
  }
  get ATTR_gridThickness__DescriptionAttribute() {
    return "Grid horizontal lines thickness";
  }
  get gridThickness() {
    return this._gridThickness;
  }
  set gridThickness(value) {
    this._gridThickness = value;
  }
  get ATTR_font__DisplayName() {
    return "Font";
  }
  get ATTR_font__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_font__DescriptionAttribute() {
    return "Axis font";
  }
  get font() {
    return this._font;
  }
  set font(value) {
    this._font = value;
  }
  get ATTR_legend__DisplayName() {
    return "Legend";
  }
  get ATTR_legend__DescriptionAttribute() {
    return "Axis legend";
  }
  get legend() {
    return this._legend;
  }
  set legend(value) {
    this._legend = value;
  }
  get ATTR_zones0__DisplayName() {
    return "Zone 1";
  }
  get ATTR_zones0__CategoryAttribute() {
    return "Zones";
  }
  get ATTR_zones0__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_zones0__DescriptionAttribute() {
    return "Zone 1 parameters";
  }
  get zones0() {
    return this._zones0;
  }
  set zones0(value) {
    this._zones0 = value;
  }
  get ATTR_zones1__DisplayName() {
    return "Zone 2";
  }
  get ATTR_zones1__CategoryAttribute() {
    return "Zones";
  }
  get ATTR_zones1__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_zones1__DescriptionAttribute() {
    return "Zone 2 parameters";
  }
  get zones1() {
    return this._zones1;
  }
  set zones1(value) {
    this._zones1 = value;
  }
  get ATTR_zones2__DisplayName() {
    return "Zone 3";
  }
  get ATTR_zones2__CategoryAttribute() {
    return "Zones";
  }
  get ATTR_zones2__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_zones2__DescriptionAttribute() {
    return "Zone 3 parameters";
  }
  get zones2() {
    return this._zones2;
  }
  set zones2(value) {
    this._zones2 = value;
  }
};
var MarkerDescription = class {
  constructor(defaultText) {
    this._enabled = false;
    this._text = "";
    this._textAlign = Marker.TextAlign.CENTER;
    this._timereference = TimeConverter.TimeReference.ABSOLUTE;
    this._positionOnXAxis = new xAxisPosition(TimeConverter.ToUnixTime(new Date()), false);
    this._yposition = 95;
    this._bgColor = YColor.FromArgb(200, 255, 255, 192);
    this._borderColor = YColor.DarkRed;
    this._borderthickness = 1;
    this._padding = 5;
    this._font = new FontDescription("Arial", 7, YColor.Black, false, false);
    this._text = defaultText;
  }
  get summary() {
    return this._enabled ? "Enabled" : "Disabled";
  }
  get ATTR_enabled__DisplayName() {
    return "Enabled";
  }
  get ATTR_enabled__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_enabled__DescriptionAttribute() {
    return "Should that marker be shown?.";
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    this._enabled = value;
  }
  get ATTR_text__DisplayName() {
    return "Text";
  }
  get ATTR_text__DescriptionAttribute() {
    return "Marker text. Use \\n for multi-line text. Some variables are allowed such as $MARKERTIME$, $LEGEND1$, $VALUE1$, $UNIT1$, $LEGEND1$, $VALUE2$ etc.. Extensive use of marker variables migh make the graph rendering significantly slower.";
  }
  get text() {
    return this._text;
  }
  set text(value) {
    this._text = value;
  }
  get ATTR_textAlign__DisplayName() {
    return "Text Alignment";
  }
  get ATTR_textAlign__DescriptionAttribute() {
    return "How text is aligned, makes sense on multi-lines text only.";
  }
  get textAlign() {
    return this._textAlign;
  }
  set textAlign(value) {
    this._textAlign = value;
  }
  get ATTR_timereference__DisplayName() {
    return "Time reference";
  }
  get ATTR_timereference__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_timereference__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_timereference__DescriptionAttribute() {
    return "Should the marker time position be absolute or relative to first data timestamp? Note: relative markers won't be drawn until there is actual data.";
  }
  get timereference() {
    return this._timereference;
  }
  set timereference(value) {
    this._timereference = value;
    this._positionOnXAxis.relative = value == TimeConverter.TimeReference.RELATIVE;
  }
  get ATTR_positionOnXAxis__DisplayName() {
    return "Time position";
  }
  get ATTR_positionOnXAxis__DescriptionAttribute() {
    return "Marker position on X axis.";
  }
  get positionOnXAxis() {
    return this._positionOnXAxis;
  }
  set positionOnXAxis(value) {
    this._positionOnXAxis = value;
    this.timereference = value.relative ? TimeConverter.TimeReference.RELATIVE : TimeConverter.TimeReference.ABSOLUTE;
  }
  get ATTR_yposition__DisplayName() {
    return "Vrt position (%)";
  }
  get ATTR_yposition__DescriptionAttribute() {
    return "Vertical position of the marker label in % of available space. Zero is bottom";
  }
  get yposition() {
    return this._yposition;
  }
  set yposition(value) {
    this._yposition = value;
  }
  get ATTR_bgColor__DisplayName() {
    return "Background color ";
  }
  get ATTR_bgColor__DescriptionAttribute() {
    return "Marker  background color.";
  }
  get bgColor() {
    return this._bgColor;
  }
  set bgColor(value) {
    this._bgColor = value;
  }
  get ATTR_borderColor__DisplayName() {
    return "Border color ";
  }
  get ATTR_borderColor__DescriptionAttribute() {
    return "Marker border color.";
  }
  get borderColor() {
    return this._borderColor;
  }
  set borderColor(value) {
    this._borderColor = value;
  }
  get ATTR_borderthickness__DisplayName() {
    return "Border thickness ";
  }
  get ATTR_borderthickness__DescriptionAttribute() {
    return "Marker border thickness, in pixels.";
  }
  get borderthickness() {
    return this._borderthickness;
  }
  set borderthickness(value) {
    this._borderthickness = value;
  }
  get ATTR_padding__DisplayName() {
    return "Padding ";
  }
  get ATTR_padding__DescriptionAttribute() {
    return "Distance between the marker border and the marker contents, in pixels.";
  }
  get padding() {
    return this._padding;
  }
  set padding(value) {
    this._padding = value;
  }
  get ATTR_font__DisplayName() {
    return "Font";
  }
  get ATTR_font__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_font__DescriptionAttribute() {
    return "Marker Font";
  }
  get font() {
    return this._font;
  }
  set font(value) {
    this._font = value;
  }
};
var XaxisDescription = class {
  constructor() {
    this._initialZoom = 60;
    this._initialOffset = 0;
    this._position = XAxis.VrtPosition.BOTTOM;
    this._timeReference = TimeConverter.TimeReference.ABSOLUTE;
    this._overflowHandling = XAxis.OverflowHandling.SCROLL;
    this._color = YColor.FromArgb(255, 127, 127, 127);
    this._thickness = 1;
    this._showGrid = false;
    this._gridColor = YColor.FromArgb(50, 0, 0, 0);
    this._gridThickness = 1;
    this._font = new FontDescription("Arial", 10, YColor.Black, false, false);
    this._legend = new LegendDescription();
    this._markers0 = new MarkerDescription("Marker 1");
    this._markers1 = new MarkerDescription("Marker 2");
    this._markers2 = new MarkerDescription("Marker 3");
    this._markers3 = new MarkerDescription("Marker 4");
    this._markers4 = new MarkerDescription("Marker 5");
    this._markers5 = new MarkerDescription("Marker 6");
    this._markers6 = new MarkerDescription("Marker 7");
    this._markers7 = new MarkerDescription("Marker 8");
  }
  get ATTR_initialZoom__DisplayName() {
    return "Initial Zoom";
  }
  get ATTR_initialZoom__DescriptionAttribute() {
    return "Zoom level at application startup, i.e. width of the view-port in seconds.";
  }
  get initialZoom() {
    return this._initialZoom;
  }
  set initialZoom(value) {
    this._initialZoom = value;
  }
  get ATTR_initialOffset__DisplayName() {
    return "Initial Offset";
  }
  get ATTR_initialOffset__DescriptionAttribute() {
    return "Offset of the first data point in percentage of the viewport width. For instance a 50% value will put the first point in the middle of the viewport. This can be used to give some room for datalogger contents.";
  }
  get initialOffset() {
    return this._initialOffset;
  }
  set initialOffset(value) {
    this._initialOffset = value;
  }
  get ATTR_position__DisplayName() {
    return "Position";
  }
  get ATTR_position__DescriptionAttribute() {
    return "X Axis position (top / bottom)";
  }
  get position() {
    return this._position;
  }
  set position(value) {
    this._position = value;
  }
  get ATTR_timeReference__DisplayName() {
    return "Time reference";
  }
  get ATTR_timeReference__DescriptionAttribute() {
    return "Are gradation timestamps absolute or relative to experiment start time? ";
  }
  get timeReference() {
    return this._timeReference;
  }
  set timeReference(value) {
    this._timeReference = value;
  }
  get ATTR_overflowHandling__DisplayName() {
    return "Overflow Handling";
  }
  get ATTR_overflowHandling__DescriptionAttribute() {
    return "What to do when new data are about to reach the graph right border";
  }
  get overflowHandling() {
    return this._overflowHandling;
  }
  set overflowHandling(value) {
    this._overflowHandling = value;
  }
  get ATTR_color__DisplayName() {
    return "Color";
  }
  get ATTR_color__DescriptionAttribute() {
    return "X Axis Color.";
  }
  get color() {
    return this._color;
  }
  set color(value) {
    this._color = value;
  }
  get ATTR_thickness__DisplayName() {
    return "Thickness";
  }
  get ATTR_thickness__DescriptionAttribute() {
    return "Axis thickness";
  }
  get thickness() {
    return this._thickness;
  }
  set thickness(value) {
    this._thickness = value;
  }
  get ATTR_showGrid__DisplayName() {
    return "Show Grid";
  }
  get ATTR_showGrid__DescriptionAttribute() {
    return "Show grid vertical lines, or not.";
  }
  get showGrid() {
    return this._showGrid;
  }
  set showGrid(value) {
    this._showGrid = value;
  }
  get ATTR_gridColor__DisplayName() {
    return "Grid Color";
  }
  get ATTR_gridColor__DescriptionAttribute() {
    return "Grid vertical lines color.";
  }
  get gridColor() {
    return this._gridColor;
  }
  set gridColor(value) {
    this._gridColor = value;
  }
  get ATTR_gridThickness__DisplayName() {
    return "Grid thickness";
  }
  get ATTR_gridThickness__DescriptionAttribute() {
    return "Grid vertical lines thickness";
  }
  get gridThickness() {
    return this._gridThickness;
  }
  set gridThickness(value) {
    this._gridThickness = value;
  }
  get ATTR_font__DisplayName() {
    return "Font";
  }
  get ATTR_font__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_font__DescriptionAttribute() {
    return "Axis font";
  }
  get font() {
    return this._font;
  }
  set font(value) {
    this._font = value;
  }
  get ATTR_legend__DisplayName() {
    return "Legend";
  }
  get ATTR_legend__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_legend__DescriptionAttribute() {
    return "X Axis legend";
  }
  get legend() {
    return this._legend;
  }
  set legend(value) {
    this._legend = value;
  }
  get ATTR_markers0__DisplayName() {
    return "Marker 1";
  }
  get ATTR_markers0__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_markers0__CategoryAttribute() {
    return "Markers";
  }
  get ATTR_markers0__DescriptionAttribute() {
    return "First marker parameters";
  }
  get markers0() {
    return this._markers0;
  }
  set markers0(value) {
    this._markers0 = value;
  }
  get ATTR_markers1__DisplayName() {
    return "Marker 2";
  }
  get ATTR_markers1__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_markers1__CategoryAttribute() {
    return "Markers";
  }
  get ATTR_markers1__DescriptionAttribute() {
    return "Second marker parameters";
  }
  get markers1() {
    return this._markers1;
  }
  set markers1(value) {
    this._markers1 = value;
  }
  get ATTR_markers2__DisplayName() {
    return "Marker 3";
  }
  get ATTR_markers2__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_markers2__CategoryAttribute() {
    return "Markers";
  }
  get ATTR_markers2__DescriptionAttribute() {
    return "Third marker parameters";
  }
  get markers2() {
    return this._markers2;
  }
  set markers2(value) {
    this._markers2 = value;
  }
  get ATTR_markers3__DisplayName() {
    return "Marker 4";
  }
  get ATTR_markers3__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_markers3__CategoryAttribute() {
    return "Markers";
  }
  get ATTR_markers3__DescriptionAttribute() {
    return "Fourth marker parameters";
  }
  get markers3() {
    return this._markers3;
  }
  set markers3(value) {
    this._markers3 = value;
  }
  get ATTR_markers4__DisplayName() {
    return "Marker 5";
  }
  get ATTR_markers4__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_markers4__CategoryAttribute() {
    return "Markers";
  }
  get ATTR_markers4__DescriptionAttribute() {
    return "Fith marker parameters";
  }
  get markers4() {
    return this._markers4;
  }
  set markers4(value) {
    this._markers4 = value;
  }
  get ATTR_markers5__DisplayName() {
    return "Marker 6";
  }
  get ATTR_markers5__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_markers5__CategoryAttribute() {
    return "Markers";
  }
  get ATTR_markers5__DescriptionAttribute() {
    return "Sixth marker parameters";
  }
  get markers5() {
    return this._markers5;
  }
  set markers5(value) {
    this._markers5 = value;
  }
  get ATTR_markers6__DisplayName() {
    return "Marker 7";
  }
  get ATTR_markers6__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_markers6__CategoryAttribute() {
    return "Markers";
  }
  get ATTR_markers6__DescriptionAttribute() {
    return "Seventh marker parameters";
  }
  get markers6() {
    return this._markers6;
  }
  set markers6(value) {
    this._markers6 = value;
  }
  get ATTR_markers7__DisplayName() {
    return "Marker 8";
  }
  get ATTR_markers7__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_markers7__CategoryAttribute() {
    return "Markers";
  }
  get ATTR_markers7__DescriptionAttribute() {
    return "Height marker parameters";
  }
  get markers7() {
    return this._markers7;
  }
  set markers7(value) {
    this._markers7 = value;
  }
};
var GraphFormProperties = class extends GenericProperties {
  constructor(initData, owner) {
    super(owner);
    this._Graph_series0 = new ChartSerie(YColor.Tomato);
    this._Graph_series1 = new ChartSerie(YColor.DodgerBlue);
    this._Graph_series2 = new ChartSerie(YColor.SeaGreen);
    this._Graph_series3 = new ChartSerie(YColor.Gold);
    this._Graph_showRecordedData = false;
    this._Graph_borderColor = YColor.LightGray;
    this._Graph_borderThickness = 1;
    this._Graph_bgColor1 = YColor.FromArgb(255, 220, 220, 220);
    this._Graph_bgColor2 = YColor.FromArgb(55, 240, 240, 240);
    this._Graph_resizeRule = Proportional.ResizeRule.FIXED;
    this._Graph_xAxis = new XaxisDescription();
    this._Graph_yAxes0 = new YaxisDescription(0, true);
    this._Graph_yAxes1 = new YaxisDescription(1, false);
    this._Graph_yAxes2 = new YaxisDescription(2, false);
    this._Graph_legendPanel = new LegendPanelDescription();
    this._Graph_dataTracker = new DataTrackerDescription();
    this._Graph_navigator = new NavigatorDescription();
    this._annotationPanels0 = new AnnotationPanelDescriptionGraph();
    this._annotationPanels1 = new AnnotationPanelDescriptionGraph();
    this.initFromXmlData(initData);
  }
  IsDataSourceAssigned() {
    let propList = Object.getOwnPropertyNames(this);
    propList.forEach((name) => {
      if (name.startsWith("Graphs_series")) {
        let s = this[name].GetValue(this, null);
        if (!(s.DataSource_source instanceof NullYSensor))
          return true;
      }
    });
    return false;
  }
  get ATTR_Graph_series0__DisplayName() {
    return "Series 1";
  }
  get ATTR_Graph_series0__CategoryAttribute() {
    return "Data Sources";
  }
  get ATTR_Graph_series0__PreExpandedCategoryAttribute() {
    return true;
  }
  get ATTR_Graph_series0__PreExpandedAttribute() {
    return true;
  }
  get ATTR_Graph_series0__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_Graph_series0__DescriptionAttribute() {
    return "First data series, expand for more.";
  }
  get Graph_series0() {
    return this._Graph_series0;
  }
  set Graph_series0(value) {
    this._Graph_series0 = value;
  }
  get ATTR_Graph_series1__DisplayName() {
    return "Series 2";
  }
  get ATTR_Graph_series1__CategoryAttribute() {
    return "Data Sources";
  }
  get ATTR_Graph_series1__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_Graph_series1__DescriptionAttribute() {
    return "Second data series, expand for more.";
  }
  get Graph_series1() {
    return this._Graph_series1;
  }
  set Graph_series1(value) {
    this._Graph_series1 = value;
  }
  get ATTR_Graph_series2__DisplayName() {
    return "Series 3";
  }
  get ATTR_Graph_series2__CategoryAttribute() {
    return "Data Sources";
  }
  get ATTR_Graph_series2__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_Graph_series2__DescriptionAttribute() {
    return "Third data series, expand for more.";
  }
  get Graph_series2() {
    return this._Graph_series2;
  }
  set Graph_series2(value) {
    this._Graph_series2 = value;
  }
  get ATTR_Graph_series3__DisplayName() {
    return "Series 4";
  }
  get ATTR_Graph_series3__CategoryAttribute() {
    return "Data Sources";
  }
  get ATTR_Graph_series3__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_Graph_series3__DescriptionAttribute() {
    return "Fourth data series, expand for more.";
  }
  get Graph_series3() {
    return this._Graph_series3;
  }
  set Graph_series3(value) {
    this._Graph_series3 = value;
  }
  get ATTR_Graph_showRecordedData__DisplayName() {
    return "Use datalogger data";
  }
  get ATTR_Graph_showRecordedData__CategoryAttribute() {
    return "Graph";
  }
  get ATTR_Graph_showRecordedData__CopyToTarget() {
    return false;
  }
  get ATTR_Graph_showRecordedData__DescriptionAttribute() {
    return "Makes the graph load the sensors datalogger contents. After disabling this feature, you may want to reset the dataview with the right-click context menu.";
  }
  get Graph_showRecordedData() {
    return this._Graph_showRecordedData;
  }
  set Graph_showRecordedData(value) {
    if (this._Graph_showRecordedData != value) {
      this._Graph_showRecordedData = value;
      if (this.ownerForm != null) {
        this._Graph_showRecordedData ? this.ownerForm.loadRecordedDataIfNeeded() : this.ownerForm.removeDataloggerData();
      }
    }
  }
  get ATTR_Graph_borderColor__DisplayName() {
    return "Border color";
  }
  get ATTR_Graph_borderColor__CategoryAttribute() {
    return "Graph";
  }
  get ATTR_Graph_borderColor__DescriptionAttribute() {
    return "Canvas borders color.";
  }
  get Graph_borderColor() {
    return this._Graph_borderColor;
  }
  set Graph_borderColor(value) {
    this._Graph_borderColor = value;
  }
  get ATTR_Graph_borderThickness__DisplayName() {
    return "Border thickness";
  }
  get ATTR_Graph_borderThickness__CategoryAttribute() {
    return "Graph";
  }
  get ATTR_Graph_borderThickness__DescriptionAttribute() {
    return "Canvas borders thickness.";
  }
  get Graph_borderThickness() {
    return this._Graph_borderThickness;
  }
  set Graph_borderThickness(value) {
    this._Graph_borderThickness = value;
  }
  get ATTR_Graph_bgColor1__DisplayName() {
    return "Background color 1";
  }
  get ATTR_Graph_bgColor1__CategoryAttribute() {
    return "Graph";
  }
  get ATTR_Graph_bgColor1__DescriptionAttribute() {
    return "Background gradient color 1.";
  }
  get Graph_bgColor1() {
    return this._Graph_bgColor1;
  }
  set Graph_bgColor1(value) {
    this._Graph_bgColor1 = value;
  }
  get ATTR_Graph_bgColor2__DisplayName() {
    return "Background color 2";
  }
  get ATTR_Graph_bgColor2__CategoryAttribute() {
    return "Graph";
  }
  get ATTR_Graph_bgColor2__DescriptionAttribute() {
    return "Background gradient color 2.";
  }
  get Graph_bgColor2() {
    return this._Graph_bgColor2;
  }
  set Graph_bgColor2(value) {
    this._Graph_bgColor2 = value;
  }
  get ATTR_Graph_resizeRule__DisplayName() {
    return "Font sizes";
  }
  get ATTR_Graph_resizeRule__CategoryAttribute() {
    return "Graph";
  }
  get ATTR_Graph_resizeRule__DescriptionAttribute() {
    return "Are font sizes fixed or do they change when window is resized?";
  }
  get Graph_resizeRule() {
    return this._Graph_resizeRule;
  }
  set Graph_resizeRule(value) {
    this._Graph_resizeRule = value;
  }
  get ATTR_Graph_xAxis__DisplayName() {
    return "X Axis";
  }
  get ATTR_Graph_xAxis__CategoryAttribute() {
    return "X/Y Axes";
  }
  get ATTR_Graph_xAxis__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_Graph_xAxis__DescriptionAttribute() {
    return "X-Axis, expand for more";
  }
  get Graph_xAxis() {
    return this._Graph_xAxis;
  }
  set Graph_xAxis(value) {
    this._Graph_xAxis = value;
  }
  get ATTR_Graph_yAxes0__DisplayName() {
    return "YAxis 1";
  }
  get ATTR_Graph_yAxes0__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_Graph_yAxes0__CategoryAttribute() {
    return "X/Y Axes";
  }
  get ATTR_Graph_yAxes0__DescriptionAttribute() {
    return "First Y Axis, expand for more.";
  }
  get Graph_yAxes0() {
    return this._Graph_yAxes0;
  }
  set Graph_yAxes0(value) {
    this._Graph_yAxes0 = value;
  }
  get ATTR_Graph_yAxes1__DisplayName() {
    return "YAxis 2";
  }
  get ATTR_Graph_yAxes1__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_Graph_yAxes1__CategoryAttribute() {
    return "X/Y Axes";
  }
  get ATTR_Graph_yAxes1__DescriptionAttribute() {
    return "Second Y Axis, expand for more.";
  }
  get Graph_yAxes1() {
    return this._Graph_yAxes1;
  }
  set Graph_yAxes1(value) {
    this._Graph_yAxes1 = value;
  }
  get ATTR_Graph_yAxes2__DisplayName() {
    return "YAxis 3";
  }
  get ATTR_Graph_yAxes2__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_Graph_yAxes2__CategoryAttribute() {
    return "X/Y Axes";
  }
  get ATTR_Graph_yAxes2__DescriptionAttribute() {
    return "Third Y Axis, expand for more.";
  }
  get Graph_yAxes2() {
    return this._Graph_yAxes2;
  }
  set Graph_yAxes2(value) {
    this._Graph_yAxes2 = value;
  }
  get ATTR_Graph_legendPanel__DisplayName() {
    return "Legend Panel";
  }
  get ATTR_Graph_legendPanel__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_Graph_legendPanel__CategoryAttribute() {
    return "Graph";
  }
  get ATTR_Graph_legendPanel__DescriptionAttribute() {
    return "Panel containing a description of all data series. Expand for more.";
  }
  get Graph_legendPanel() {
    return this._Graph_legendPanel;
  }
  set Graph_legendPanel(value) {
    this._Graph_legendPanel = value;
  }
  get ATTR_Graph_dataTracker__DisplayName() {
    return "Data tracker";
  }
  get ATTR_Graph_dataTracker__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_Graph_dataTracker__CategoryAttribute() {
    return "Graph";
  }
  get ATTR_Graph_dataTracker__DescriptionAttribute() {
    return "Show dynamic value labels while the mouse is moving over the graph. Expand for more.";
  }
  get Graph_dataTracker() {
    return this._Graph_dataTracker;
  }
  set Graph_dataTracker(value) {
    this._Graph_dataTracker = value;
  }
  get ATTR_Graph_navigator__DisplayName() {
    return "Navigator";
  }
  get ATTR_Graph_navigator__CategoryAttribute() {
    return "Graph";
  }
  get ATTR_Graph_navigator__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_Graph_navigator__DescriptionAttribute() {
    return "Small additional graph showing the whole data set and allowing to quickly navigate among data. Expand for more.";
  }
  get Graph_navigator() {
    return this._Graph_navigator;
  }
  set Graph_navigator(value) {
    this._Graph_navigator = value;
  }
  get ATTR_Graph_annotationPanels0__DisplayName() {
    return "Annotation 1";
  }
  get ATTR_Graph_annotationPanels0__CategoryAttribute() {
    return "Annotations";
  }
  get ATTR_Graph_annotationPanels0__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_Graph_annotationPanels0__DescriptionAttribute() {
    return "Customizable text panel 1";
  }
  get Graph_annotationPanels0() {
    return this._annotationPanels0;
  }
  set Graph_annotationPanels0(value) {
    this._annotationPanels0 = value;
  }
  get ATTR_Graph_annotationPanels1__DisplayName() {
    return "Annotation 2";
  }
  get ATTR_Graph_annotationPanels1__CategoryAttribute() {
    return "Annotations";
  }
  get ATTR_Graph_annotationPanels1__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_Graph_annotationPanels1__DescriptionAttribute() {
    return "Customizable text panel 2";
  }
  get Graph_annotationPanels1() {
    return this._annotationPanels1;
  }
  set Graph_annotationPanels1(value) {
    this._annotationPanels1 = value;
  }
};

// obj/full/contextMenu.js
var ContextMenuSeparator = class {
  constructor() {
    this.TR = document.createElement("TR");
    this.TR["objectData"] = this;
    this.TR.className = ContextMenu.SEPARATOR_MARKER;
    this.TD_caption = document.createElement("TD");
    this.TD_caption.style.backgroundColor = ContextMenu.iconBGColor;
    this.TD_caption.style.paddingLeft = "3px";
    this.TD_caption.style.paddingRight = "3px";
    let hr = document.createElement("HR");
    this.TD_caption.colSpan = 2;
    this.TD_caption.appendChild(hr);
    this.TD_icon = document.createElement("TD");
    this.TD_icon.style.backgroundColor = ContextMenu.captionBgColor;
    this.TR.appendChild(this.TD_icon);
    this.TR.appendChild(this.TD_caption);
  }
  toString() {
    return "Separator";
  }
  get focusable() {
    return false;
  }
  parentMenuisClosing() {
  }
  get domData() {
    return this.TR;
  }
};
var ContextMenuItemBase = class {
  get userdata() {
    return this._userdata;
  }
  set userdata(value) {
    this._userdata = value;
  }
  constructor(menu, icon, caption) {
    this._clickHidesMenu = true;
    this._userdata = null;
    this._menu = menu;
    this.TR = document.createElement("TR");
    this.TR["objectData"] = this;
    this.TD_caption = document.createElement("TD");
    this.TD_caption.style.backgroundColor = ContextMenu.iconBGColor;
    this.TD_caption.style.paddingLeft = "3px";
    this.TD_caption.style.paddingRight = "3px";
    this.TD_caption.style.whiteSpace = "nowrap";
    this.TD_icon = document.createElement("TD");
    if (icon != null)
      this.TD_icon.innerHTML = icon;
    this.TD_icon.style.backgroundColor = ContextMenu.captionBgColor;
    this.A_caption = document.createElement("A");
    this.A_caption.innerHTML = caption;
    this.TR.style.cursor = "pointer";
    this.TR.tabIndex = 0;
    this.TR.style.outline = "none";
    this._TR_keydown = (e) => {
      e.preventDefault();
      this.keydown(e);
    };
    this._TR_mouseover = (e) => {
      this.mouserOver(e);
    };
    this._TR_mouseout = (e) => {
      this.mouserOut(e);
    };
    this._A_mouseover = (e) => {
      this.mouserOver(e);
    };
    this._A_mouseout = (e) => {
      this.mouserOut(e);
    };
    this._A_click = (e) => {
      this.activate();
    };
    this._TR_focusin = () => {
      this.focusIn();
    };
    this._TR_focusout = () => {
      this.focusOut();
    };
    this.TR.addEventListener("mouseover", this._TR_mouseover);
    this.TR.addEventListener("mouseout", this._TR_mouseout);
    this.TR.addEventListener("click", this._A_click);
    this.TR.addEventListener("keydown", this._TR_keydown);
    this.A_caption.addEventListener("mouseover", this._A_mouseover);
    this.A_caption.addEventListener("mouseout", this._A_mouseout);
    this.TD_caption.appendChild(this.A_caption);
    this.TR.appendChild(this.TD_icon);
    this.TR.appendChild(this.TD_caption);
    this.TR.addEventListener("focusin", this._TR_focusin);
    this.TR.addEventListener("focusout", this._TR_focusout);
  }
  toString() {
    return this.TD_caption.innerText;
  }
  get focusable() {
    return this.visible;
  }
  activate() {
  }
  focus() {
    this.TR.focus();
    this._menu.closeSubmenus();
  }
  focusIn() {
    if (this.TD_caption.style.backgroundColor == ContextMenu.iconBGColor)
      this._menu.closeSubmenus();
    this.TD_caption.style.backgroundColor = ContextMenu.ActiveColor;
    this.TD_icon.style.backgroundColor = ContextMenu.ActiveColor;
  }
  focusOut() {
    this.TD_caption.style.backgroundColor = ContextMenu.iconBGColor;
    this.TD_icon.style.backgroundColor = ContextMenu.captionBgColor;
  }
  removeAndDestroy() {
    if (this.TR.parentNode != null)
      this.TR.parentNode.removeChild(this.TR);
    this.TR.removeEventListener("keydown", this._TR_keydown);
    this.TR.removeEventListener("mouseover", this._TR_mouseover);
    this.TR.removeEventListener("mouseout", this._TR_mouseout);
    this.A_caption.removeEventListener("mouseover", this._A_mouseover);
    this.A_caption.removeEventListener("mouseout", this._A_mouseout);
    this.A_caption.removeEventListener("click", this._A_click);
    this.TR.removeEventListener("focusin", this._TR_focusin);
    this.TR.removeEventListener("focusout", this._TR_focusout);
  }
  set caption(value) {
    this.A_caption.innerHTML = value;
  }
  get caption() {
    return this.A_caption.innerHTML;
  }
  keydown(e) {
    if (e.code == "ArrowDown")
      this._menu.activateNext(this);
    if (e.code == "ArrowUp")
      this._menu.activatePrevious(this);
    if (e.code == "Enter")
      this.activate();
    if (e.code == "Escape") {
      this._menu.close();
      if (this._menu.parentMenuItem != null)
        this._menu.parentMenuItem.focus();
    }
    if (e.code == "ArrowLeft") {
      if (this._menu.parentMenuItem != null) {
        this._menu.close();
        this._menu.parentMenuItem.focus();
      }
    }
  }
  mouserOver(e) {
    this.TD_caption.style.backgroundColor = ContextMenu.ActiveColor;
    this.TD_icon.style.backgroundColor = ContextMenu.ActiveColor;
    this._menu.closeSubmenus();
  }
  mouserOut(e) {
    this.TD_caption.style.backgroundColor = ContextMenu.iconBGColor;
    this.TD_icon.style.backgroundColor = ContextMenu.captionBgColor;
  }
  get domData() {
    return this.TR;
  }
  get visible() {
    return this.TR.style.display != "none";
  }
  set visible(value) {
    this.TR.style.display = value ? "" : "none";
  }
  parentMenuisClosing() {
  }
  closeMenu(all) {
    if (all)
      this._menu.closeAll();
    else
      this._menu.close();
  }
};
var ContextMenuItem = class extends ContextMenuItemBase {
  activate() {
    if (this._clickHidesMenu)
      this.closeMenu(true);
    if (this._callback != null)
      this._callback();
  }
  constructor(menu, icon, caption, callback) {
    super(menu, icon, caption);
    this._callback = callback;
    this.TD_caption.colSpan = 2;
  }
};
var ContextMenuItemSubMenuEntry = class extends ContextMenuItem {
  constructor(menu, icon, caption, submenu) {
    super(menu, icon, caption, null);
    this.TD_caption.colSpan = 1;
    this._submenu = submenu;
    this._submenu.parentMenuItem = this;
    this._parentmenu = menu;
    this._clickHidesMenu = false;
    this.TD_arrow = document.createElement("TD");
    this.TD_arrow.style.backgroundColor = ContextMenu.iconBGColor;
    this.TD_arrow.style.textAlign = "right";
    this.TD_arrow.style.paddingRight = "3px";
    this.TD_arrow.innerHTML = "&#9654;";
    this.TR.appendChild(this.TD_arrow);
    this.A_caption.addEventListener("click", (e) => {
      this.showSubmenu();
    });
    this.A_caption.addEventListener("touchstart", (e) => {
      if (e.touches.length == 1)
        this.activate();
    });
    this._submenu.zIndex = this._parentmenu.zIndex + 1;
  }
  keydown(e) {
    super.keydown(e);
    if (e.code == "ArrowRight") {
      this.activate();
      this._submenu.focusFirst();
    }
  }
  removeAndDestroy() {
    this._submenu.close();
    this._submenu.destroy();
    super.removeAndDestroy();
  }
  activate() {
    this.showSubmenu();
  }
  get submenu() {
    return this._submenu;
  }
  showSubmenu() {
    this._submenu.zIndex = this._parentmenu.zIndex + 1;
    let x = 0;
    let y = 0;
    let it = this.TR;
    do {
      x += it.offsetLeft || 0;
      y += it.offsetTop || 0;
      it = it.offsetParent;
    } while (it);
    this._submenu.showContextMenu(x + this._parentmenu.width - 15, y + 5);
  }
  focusIn() {
    super.focusIn();
    this.TD_arrow.style.backgroundColor = ContextMenu.ActiveColor;
  }
  focusOut() {
    super.focusOut();
    this.TD_arrow.style.backgroundColor = ContextMenu.iconBGColor;
  }
  parentMenuisClosing() {
    this._submenu.close();
  }
  mouserOver(e) {
    this.focusIn();
    this._parentmenu.setDelayedAction(() => {
      if (this.visible)
        this.showSubmenu();
    });
  }
  mouserOut(e) {
    this._parentmenu.cancelDelayedAction();
    this.focusOut();
  }
};
var ContextMenuBase = class {
  get parentMenuItem() {
    return this._parentMenuItem;
  }
  set parentMenuItem(value) {
    this._parentMenuItem = value;
  }
  get userdata() {
    return this._userdata;
  }
  set userdata(value) {
    this._userdata = value;
  }
  constructor(baseSize, openCallback, fontFamily) {
    this._visible = false;
    this._zIndex = 100002;
    this._parentmenu = null;
    this._parentMenuItem = null;
    this._userdata = null;
    this._openCallback = openCallback;
    this.Menutable = document.createElement("TABLE");
    this.Menutable.style.position = "absolute";
    this.Menutable.style.border = "1px solid #808080";
    if (typeof fontFamily !== "undefined")
      this.Menutable.style.fontFamily = fontFamily;
    this.Menutable.style.fontSize = (2 * baseSize / 3).toFixed(1) + "px";
    this.Menutable.style.borderSpacing = "0";
    this.Menutable.style.boxShadow = " 4px 4px 4px 1px rgba(0,0,0,0.05)";
    this.Menutable.style.zIndex = this._zIndex.toString();
    this._timer = null;
    this.visible = false;
  }
  closeAll() {
    this.close();
    if (this._parentmenu != null)
      this._parentmenu.closeAll();
  }
  cancelDelayedAction() {
    if (this._timer != null) {
      clearTimeout(this._timer);
      this._timer = null;
    }
  }
  setDelayedAction(action) {
    this.cancelDelayedAction();
    this._timer = setTimeout(() => {
      action();
    }, 500);
  }
  get parentMenu() {
    return this._parentmenu;
  }
  destroy() {
    for (let i = 0; i < this.Menutable.childNodes.length; i++) {
      let item = this.Menutable.childNodes[i]["objectData"];
      item.removeAndDestroy();
    }
    if (this.Menutable.parentNode != null)
      this.Menutable.parentNode.removeChild(this.Menutable);
  }
  focusFirst() {
    for (let i = 0; i < this.Menutable.childNodes.length; i++) {
      let item = this.Menutable.childNodes[i]["objectData"];
      if (item.focusable) {
        item.focus();
        return;
      }
    }
  }
  toString() {
    let res = "";
    for (let i = 0; i < this.Menutable.childNodes.length; i++) {
      let item = this.Menutable.childNodes[i]["objectData"];
      res = res + item.caption + "";
    }
    return res;
  }
  isXYOnMenu(x, y) {
    if (!this.visible)
      return false;
    if (x >= this.Menutable.offsetLeft && x <= this.Menutable.offsetLeft + this.Menutable.offsetWidth && y >= this.Menutable.offsetTop && y <= this.Menutable.offsetTop + this.Menutable.offsetHeight) {
      return true;
    }
    for (let i = 0; i < this.Menutable.childNodes.length; i++) {
      let item = this.Menutable.childNodes[i]["objectData"];
      if (item instanceof ContextMenuItemSubMenuEntry) {
        if (item.submenu.isXYOnMenu(x, y))
          return true;
      }
    }
    return false;
  }
  activateNext(source) {
    let found = false;
    for (let i = 0; i < this.Menutable.childNodes.length; i++) {
      let item = this.Menutable.childNodes[i]["objectData"];
      if (item == source) {
        found = true;
      } else if (found && item.focusable) {
        item.focus();
        return;
      }
    }
  }
  activatePrevious(source) {
    let previous = null;
    for (let i = 0; i < this.Menutable.childNodes.length; i++) {
      let item = this.Menutable.childNodes[i]["objectData"];
      if (item == source) {
        if (previous != null)
          previous.focus();
        return;
      }
      if (item.focusable)
        previous = item;
    }
  }
  get width() {
    return this.Menutable.offsetWidth;
  }
  closeSubmenus() {
    this.closeSubMenusExcept(null);
  }
  get zIndex() {
    return this._zIndex;
  }
  set zIndex(value) {
    this._zIndex = value;
    this.Menutable.style.zIndex = this._zIndex.toString();
  }
  get visible() {
    return this.Menutable.style.display != "none";
  }
  set visible(value) {
    this.Menutable.style.display = value ? "" : "none";
  }
  close() {
    this.cancelDelayedAction();
    for (let i = 0; i < this.Menutable.childNodes.length; i++) {
      let item = this.Menutable.childNodes[i]["objectData"];
      item.parentMenuisClosing();
    }
    this.visible = false;
    this.closeSubmenus();
  }
  refresh() {
    let showSeparation = false;
    for (let i = 0; i < this.Menutable.childNodes.length; i++) {
      let element = this.Menutable.childNodes[i];
      if (element.className == ContextMenu.SEPARATOR_MARKER) {
        element.style.display = showSeparation ? "" : "none";
        showSeparation = false;
      } else if (element.style.display == "")
        showSeparation = true;
    }
  }
  addMenuItem(icon, caption, callback) {
    let menuItem = new ContextMenuItem(this, icon, caption, callback);
    this.Menutable.appendChild(menuItem.domData);
    return menuItem;
  }
  get menuItemsCount() {
    return this.Menutable.childNodes.length;
  }
  closeSubMenusExcept(doNotClose) {
    for (let i = 0; i < this.Menutable.childNodes.length; i++) {
      let item = this.Menutable.childNodes[i]["objectData"];
      if (item instanceof ContextMenuItemSubMenuEntry) {
        if (item.submenu != doNotClose) {
          item.submenu.close();
        }
      }
    }
  }
  subMenuisOpening(source) {
    this.closeSubMenusExcept(source);
  }
  addSubMenuItem(icon, caption, submenu) {
    submenu.zIndex = this.zIndex + 1;
    let menuItem = new ContextMenuItemSubMenuEntry(this, icon, caption, submenu);
    this.Menutable.appendChild(menuItem.domData);
    return menuItem;
  }
  clearAllContents() {
    while (this.Menutable.childNodes.length > 0) {
      let item = this.Menutable.childNodes[0]["objectData"];
      item.removeAndDestroy();
    }
  }
  AddSeparator() {
    let separator = new ContextMenuSeparator();
    this.Menutable.appendChild(separator.domData);
    return separator;
  }
  showContextMenu(x, y) {
  }
};
ContextMenuBase.SEPARATOR_MARKER = "separator";
ContextMenuBase.iconBGColor = "#fdfdfd";
ContextMenuBase.captionBgColor = "#f1f1f1";
ContextMenuBase.ActiveColor = "#c4e1ff";
var ContextSubMenu = class extends ContextMenuBase {
  constructor(baseSize, parentMenu, openCallback, fontFamily) {
    super(baseSize, openCallback, fontFamily);
    this._parentmenu = parentMenu;
    document.body.appendChild(this.Menutable);
  }
  showContextMenu(x, y) {
    if (this._parentmenu != null)
      this._parentmenu.subMenuisOpening(this);
    if (this._openCallback != null)
      this._openCallback(x, y);
    this.Menutable.style.left = x.toString() + "px";
    this.Menutable.style.top = y.toString() + "px";
    this.visible = true;
    let right = this.Menutable.offsetLeft - this.Menutable.scrollLeft + this.Menutable.offsetWidth;
    let bottom = this.Menutable.offsetTop - this.Menutable.scrollTop + this.Menutable.offsetHeight;
    if (right > window.innerWidth)
      this.Menutable.style.left = (x - (right - window.innerWidth)).toString() + "px";
    if (bottom > window.innerHeight)
      this.Menutable.style.top = (y - (bottom - window.innerHeight)).toString() + "px";
  }
};
var ContextMenu = class extends ContextMenuBase {
  constructor(baseSize, openCallback, fontFamily) {
    super(baseSize, openCallback, fontFamily);
    document.addEventListener("contextmenu", (e) => {
      let tagname = "";
      if (e.target != null && constants.RunningOnAndroid)
        tagname = e.target.tagName;
      if (tagname != "INPUT") {
        e.preventDefault();
        this.showContextMenu(e.pageX, e.pageY);
      }
    });
    document.addEventListener("dblclick", (e) => {
      if (constants.dbleClickBringsUpContextMenu)
        this.showContextMenu(e.pageX, e.pageY);
    });
    document.addEventListener("click", (e) => {
      this.click(e);
    });
    document.body.appendChild(this.Menutable);
  }
  click(e) {
    if (!this.visible)
      return;
    if (!this.isXYOnMenu(e.pageX, e.pageY)) {
      this.close();
    }
  }
  showContextMenu(x, y) {
    let z = YWindow.ConTextMenuBestZindex;
    if (z < 0)
      return;
    this.zIndex = z;
    this.Menutable.style.left = x.toString() + "px";
    this.Menutable.style.top = y.toString() + "px";
    this.visible = true;
    let right = this.Menutable.offsetLeft - this.Menutable.scrollLeft + this.Menutable.offsetWidth;
    let bottom = this.Menutable.offsetTop - this.Menutable.scrollTop + this.Menutable.offsetHeight;
    if (right > window.innerWidth)
      this.Menutable.style.left = Math.max(0, x - (right - window.innerWidth)).toString() + "px";
    if (bottom > window.innerHeight)
      this.Menutable.style.top = Math.max(0, y - (bottom - window.innerHeight)).toString() + "px";
    if (this._openCallback != null)
      this._openCallback(x, y);
    if (x <= 5 && y <= 5)
      this.focusFirst();
  }
};

// obj/full/ressources.js
var ressources = class {
  static SVGheader(size, shadowDef, title) {
    let res = '<svg  xmlns="http://www.w3.org/2000/svg" width="' + size + '" height="' + size + '" viewBox="0 0 128  128">';
    if (typeof title != "undefined")
      res = res + "<title>" + title + "</title>";
    if (shadowDef)
      res = res + '<defs><filter id="f1" x="0" y="0"><feGaussianBlur in="SourceGraphic" stdDeviation="2" /></filter></defs>';
    res = res + '<g transform="translate(0,128)"><g transform="scale(1,-1)">';
    return res;
  }
  static SVGFooter() {
    return "</g></g></svg>";
  }
  static addIconTransparency() {
    return '<g opacity="0.5">';
  }
  static addIconSrcCode() {
    return '<path d="m 8 24 L 8 40 L 24 40 L 24 56 L 40 56 L 40 40 L 56 40 L 56 24 L 40 24 L 40 8 L 24 8 L 24 24   Z" fill="#40ff40" stroke="black" stroke-width="8" stroke-linecap="round"/>';
  }
  static deleteIconSrcCode() {
    return '<path d="m 15 4 L 4 15 L 19 29 L 4 43 L 15 55 L 29 40 L 43 55 L 55 43 L 40 29 L 55 15 L 44 4 L 29 18 Z" fill="#ff4040" stroke="black" stroke-width="8" stroke-linecap="round">';
  }
  static IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, shadowcode, activeCode, title) {
    let res = ressources.SVGheader(size, shadow, title);
    if (shadow)
      res = res + '<g transform="translate(6,-6)">' + shadowcode + "</g>";
    if (semitransparent)
      res = res + ressources.addIconTransparency();
    res = res + activeCode;
    if (semitransparent)
      res = res + "</g>";
    if (addIcon)
      res = res + ressources.addIconSrcCode();
    if (deleteIcon)
      res = res + ressources.deleteIconSrcCode();
    res = res + ressources.SVGFooter();
    return res;
  }
  static GraphIcon(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="m 12 24 L 103 24 L 103 107 L 12 107 z" fill="lightgray" filter="url(#f1)" /><path d="m 112 24 L 12 24 L 12 113"  style="fill:none; stroke:lightgray; stroke-width:4px; stroke-linejoin:round;stroke-linecap:round;" filter="url(#f1)"/>', '<path d="m 12 24 L 103 24 L 103 107 L 12 107 z" fill="#ffffe9" /><line x1="43" y1="24" x2="43" y2="107" stroke="#e3e3e3" stroke-width="2" stroke-linecap="round" /><line x1="43" y1="24" x2="43" y2="107" stroke="#e3e3e3" stroke-width="2" stroke-linecap="round" /><line x1="73" y1="24" x2="73" y2="107" stroke="#e3e3e3" stroke-width="2" stroke-linecap="round" /><line x1="12" y1="51" x2="103" y2="51" stroke="#e3e3e3" stroke-width="2" stroke-linecap="round" /><line x1="12" y1="79" x2="103" y2="79" stroke="#e3e3e3" stroke-width="2" stroke-linecap="round" /><line x1="12" y1="107" x2="103" y2="107" stroke="#e3e3e3" stroke-width="2" stroke-linecap="round" /><path d="m 12 77 L 34 65 L 55 85 L 70 77 L 100 93" fill="none" stroke="#FF0000" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" /><line x1="103" y1="24" x2="103" y2="107" stroke="#e3e3e3" stroke-width="2" stroke-linecap="round" /><path d="m 112 24 L 12 24 L 12 113"  style="fill:none; stroke:black; stroke-width:4px; stroke-linejoin:round;stroke-linecap:round;"/>');
  }
  static SolidGaugeIcon(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="M 34 40 L 14 40 14 52 A 50 50 0 0 0 114 52 L  114 40 L 94 40 L 94 52 A 30 30 0 1 1  34 52 Z" style="fill:lightgray;fill-opacity=0.4;" filter="url(#f1)"/><text x="43" y="-30" fill="black" transform="scale(1,-1)" style="font: bold 24px sans-serif;fill:lightgray;fill-opacity=0.4;" filter="url(#f1)">123</text>', '<path d="M 34 40 L 14 40 14 52 A 50 50 0 0 0 114 52 L  114 40 L 94 40 L 94 52 A 30 30 0 1 1  34 52 Z" style="fill:#ffffe9; stroke:none; "/><path d="M 34 40 L 14 40 14 52 A 50 50 0 0 0 29 88 L  43 72.5   A 30 30 0 0 1  34 52 Z" style="fill:red; stroke:none;"/><path d="M 34 40 L 14 40 14 52 A 50 50 0 0 0 114 52 L  114 40 L 94 40 L 94 52 A 30 30 0 1 1  34 52 Z" style="fill:none; stroke:black; stroke-width:4px; stroke-linejoin:round;stroke-linecap:round;"/><text x="43" y="-30" fill="black" transform="scale(1,-1)" style="font: bold 24px sans-serif;">123</text>');
  }
  static RawDataIcon(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="m 16 27 L 107 27 L 107 107 L 16 107 z" fill="lightgray" filter="url(#f1)" />', '<path d="m 16 27 L 107 27 L 107 107 L 16 107 z" style="fill:#ffffe9;" /><line x1="47" y1="27" x2="47" y2="107" stroke="#e3e3e3" stroke-width="2"  /><line x1="76" y1="27" x2="76" y2="107" stroke="#e3e3e3" stroke-width="2"  /><line x1="16" y1="44" x2="107" y2="44" stroke="#e3e3e3" stroke-width="2"  /><line x1="16" y1="60" x2="107" y2="60" stroke="#e3e3e3" stroke-width="2"  /><line x1="16" y1="76" x2="107" y2="76" stroke="#e3e3e3" stroke-width="2"  /><path d="m 16 27 L 107 27 L 107 107 L 16 107 z" style="fill:none;stroke:black; stroke-width:4px; stroke-linejoin:round;" /><path d="m 19 91 L 104 91 L 104 104 L 19 104 z" style="fill:#b2b2b2; stroke:#6f6f6f; stroke-width:4px; stroke-linejoin:round;" /><line x1="47" y1="91" x2="47" y2="104" stroke="#6f6f6f" stroke-width="2"  /><line x1="76" y1="91" x2="76" y2="104" stroke="#6f6f6f" stroke-width="2"  />');
  }
  static ConfigureIcon(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="M85 85 L 102 80 L 113 91 A  41 100 45 0 0  86 71 L 37 21 A  5 11 45 1 0  21 37 L 71 86  A  41 100 45 0 0  91 113 L 80 102 Z" style="fill:lightgray;fill-opacity=0.4;" filter="url(#f1)"/>', '<path d="M85 85 L 102 80 L 113 91 A  41 100 45 0 0  86 71 L 37 21 A  5 11 45 1 0  21 37 L 71 86  A  41 100 45 0 0  91 113 L 80 102 Z" style="fill:grey; stroke:black; stroke-width:4px; stroke-linejoin:round;stroke-linecap:round;"/>');
  }
  static DigitalDisplayIcon(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="m 12 45 L 111 45 L 111 89 L 12 89 z" fill="lightgray" filter="url(#f1)" />', '<path d="m 12 45 L 111 45 L 111 89 L 12 89 z" style="fill:#ffffe9; stroke:black; stroke-width:4px; stroke-linejoin:round;" /><text x="29" y="-52" fill="black" transform="scale(1,-1)" style="font: bold 40px sans-serif;">123</text> ');
  }
  static AngularGaugeIcon(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<circle  cx="64" cy="64" r="40" fill="lightgray" filter="url(#f1)" />', '<circle  cx="64" cy="64" r="40" stroke="black" stroke-width="4" fill="#ffffe9" /><line x1="64" y1="104" x2="64" y2="94" stroke="black" stroke-width="2"   stroke-linecap="round" /><line x1="29" y1="84" x2="38" y2="79" stroke="black" stroke-width="2"   stroke-linecap="round" /><line x1="29" y1="44" x2="38" y2="48" stroke="black" stroke-width="2"   stroke-linecap="round" /><line x1="98" y1="84" x2="91" y2="79" stroke="black" stroke-width="2"   stroke-linecap="round" /><line x1="98" y1="44" x2="91" y2="48" stroke="black" stroke-width="2"   stroke-linecap="round" /><g transform="translate(64,64)"><g transform="rotate(-70,0,0)"><path d="m 5 0 L 0 5 L -25 0 L 0 -5 z" style="fill:black;stroke:black; stroke-width:2px; stroke-linejoin:round;"/></g></g>');
  }
  static EditIcon(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="m 16 48 L 108 48 L 108 88 L 16 88 z" fill="lightgray" filter="url(#f1)" /><path d="m 87 24 L 75 40 L 67 31 L 62 64 L 93 50 L 82 44  L 94 29 z" fill="lightgray" filter="url(#f1)" />', '<path d="m 16 48 L 108 48 L 108 88 L 16 88 z" style="fill:#ffffe9; stroke:black; stroke-width:4px; stroke-linejoin:round;" /><path d="m 87 24 L 75 40 L 67 31 L 62 64 L 93 50 L 82 44  L 94 29 z" style="fill:white; stroke:black; stroke-width:2px; stroke-linejoin:round;" /> ');
  }
  static AllIcon(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="m 60 108 L 46 74 L 8 72 L 38 48 L 28 12 L 60 32 L 92 12  L 82 48 L 112 70  L 74 74  z" fill="lightgray" filter="url(#f1)" />', '<path d="m 60 108 L 46 74 L 8 72 L 38 48 L 28 12 L 60 32 L 92 12  L 82 48 L 112 70  L 74 74  z" style="fill:#fee403; stroke:#918201; stroke-width:4px; stroke-linejoin:round;" />');
  }
  static TrashIcon(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="m 33 12 L 24 94 L 104 94 L 95 12 z" fill="lightgray" filter="url(#f1)" /><g transform="translate(70,105)"><g transform="rotate(-10,0,0)"><path d="m -40 0 L -30 5 L 30 5 L 40 0 z" fill="lightgray" filter="url(#f1)" /><path d="m -9 5 L -9 12 L 9 12 L 9 5" stroke="lightgray" filter="url(#f1)"/> </g></g>', '<path d="m 33 12 L 24 94 L 104 94 L 95 12 z" style="fill:#f8f8f8; stroke:black; stroke-width:4px; stroke-linejoin:round;" /><Line x1="43" y1="82" x2="48" y2="21" style=" stroke:black; stroke-width:4px; stroke-linecap:round;" /><Line x1="64" y1="82" x2="64" y2="21" style=" stroke:black; stroke-width:4px; stroke-linecap:round;" /><Line x1="86" y1="82" x2="80" y2="21" style=" stroke:black; stroke-width:4px; stroke-linecap:round;" /><g transform="translate(70,105)"><g transform="rotate(-10,0,0)"><path d="m -40 0 L -30 5 L 30 5 L 40 0 z" style="fill:#f8f8f8; stroke:black; stroke-width:4px; stroke-linejoin:round;" /><path d="m -9 5 L -9 12 L 9 12 L 9 5" style="fill:none; stroke:black; stroke-width:4px; stroke-linejoin:round;" /></g></g>');
  }
  static SaveIcon(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="m 20 12 A 4 4 0 0 0 16 16 L 16 106  A 4 4 0 0 0 20 110 L 24 110 L 24 108 L 97 108 L 97 110 L 104 110  A 4 4 0 0 0 108 106 L 108 16   A 4 4 0 0 0 104 12  z" fill="lightgray" filter="url(#f1)" />', '<path d="m 20 12 A 4 4 0 0 0 16 16 L 16 106  A 4 4 0 0 0 20 110 L 24 110 L 24 108 L 97 108 L 97 110 L 104 110  A 4 4 0 0 0 108 106 L 108 16   A 4 4 0 0 0 104 12  z" style="fill:#3583dd; stroke:#226fc8; stroke-width:4px; stroke-linejoin:round;" /><path d="m 24 11 L 24 65  A 5 5 0 0 0 29 70 L 95 70  A 5 5 0 0 0 100 65 L 100 11  z" style="fill:#f7f7f7; stroke:#c6c6c6; stroke-width:2px; stroke-linejoin:round;"/><path d="m 36 111 L 90 111 L 90 80 A 4 4 0 0 0 86 76 L 40 76 A 4 4 0 0 0 36 80 z"  style="fill:#e5e5e5; stroke:#c6c6c6; stroke-width:2px; stroke-linejoin:round;" /><rect x="67" y="79" width="14" height ="28"     style="fill:#3583dd; stroke:#c6c6c6; stroke-width:2px; stroke-linejoin:round;"');
  }
  static SaveNeededIcon(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="m 8 16 L 64 110 L 120 16 z " style="fill:lightgray; stroke:lightgray; stroke-width:10px; stroke-linejoin:round;filter:url(#f1)" />', '<path d="m 8 16 L 64 110 L 120 16 z" style="fill:#FAE701; stroke:#FAE701; stroke-width:10px; stroke-linejoin:round;" /><path d="m 8 16 L 64 110 L 120 16 z" style="fill:none; stroke:black; stroke-width:2px; stroke-linejoin:round;" /><g transform="translate(-64,-64) scale(0.4 0.4) translate(260,215)"><path d="m 20 12 A 4 4 0 0 0 16 16 L 16 106  A 4 4 0 0 0 20 110 L 24 110 L 24 108 L 97 108 L 97 110 L 104 110  A 4 4 0 0 0 108 106 L 108 16   A 4 4 0 0 0 104 12  z" style="fill:black; stroke:black; stroke-width:4px; stroke-linejoin:round;" /><path d="m 24 11 L 24 65  A 5 5 0 0 0 29 70 L 95 70  A 5 5 0 0 0 100 65 L 100 11  z" style="fill:#FAE701; stroke:black; stroke-width:2px; stroke-linejoin:round;"/><path d="m 36 111 L 90 111 L 90 80 A 4 4 0 0 0 86 76 L 40 76 A 4 4 0 0 0 36 80 z"  style="fill:#FAE701; stroke:black; stroke-width:2px; stroke-linejoin:round;" /><rect x="67" y="79" width="14" height ="28"     style="fill:#FAE701; stroke:black; stroke-width:2px; stroke-linejoin:round;"</g>', "Don't forget to save.");
  }
  static snapshotIcon(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="m 16 32  L 16 78 A 6 6 0 0 0 22 84 L 46 84 L 48 94 A 5.75 3.25 30 0 0 54 100 L 78 100 A 3.25 5.75  30 0 0 84 94  L 86 84 L 104 84  A 6 6 0 0 0 110 78  L 110 32 A 6 6 0 0 0 104 26 L 22 26 A 6 6 0 0 0 16 32 z"  fill="lightgray" filter="url(#f1)" />', '<path d="m 16 32  L 16 78 A 6 6 0 0 0 22 84 L 46 84 L 48 94 A 5.75 3.25 30 0 0 54 100 L 78 100 A 3.25 5.75  30 0 0 84 94  L 86 84 L 104 84  A 6 6 0 0 0 110 78  L 110 32 A 6 6 0 0 0 104 26 L 22 26 A 6 6 0 0 0 16 32 z" style="fill:#707070; stroke:#464646; stroke-width:4px; stroke-linejoin:round;" /><Circle cx="65" cy="55" r="26"   style="fill:#895e96; stroke:#464646; stroke-width:6px; stroke-linejoin:round;" />');
  }
  static CloseIcon(size, shadow, semitransparent, addIcon, deleteIcon, title) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="m 21.6 38.6 L 47.1 64.3 L 22 89.5 L 38.4 106.2 L 64 81 L 89.3 106.2 L 105.8 89.5 L 80.6 64 L 105.8 38.9 L 89.3 22.2 L 64 47.5  L 38.3 22.1 z"  fill="lightgray" filter="url(#f1)" />', '<path d="m 21.6 38.6 L 47.1 64.3 L 22 89.5 L 38.4 106.2 L 64 81 L 89.3 106.2 L 105.8 89.5 L 80.6 64 L 105.8 38.9 L 89.3 22.2 L 64 47.5  L 38.3 22.1 z" style="fill:#ffffff; stroke:#004a82; stroke-width:4px; stroke-linejoin:round;" />', title);
  }
  static MoveToRightIcon(size, shadow, semitransparent, addIcon, deleteIcon, title) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<rect x="12" y="52" width="4"  height="24" fill="lightgray" filter="url(#f1)" /><rect x="20" y="52" width="8"  height="24" fill="lightgray" filter="url(#f1)" /><rect x="56" y="16" width="16"  height="96" fill="lightgray" filter="url(#f1)" /><path d="m  32 52 L 32 76 L 56 76 L 56 96 L 88 64 L 56 32 L 56 52 z" fill="lightgray" filter="url(#f1)" />', '<rect x="12" y="52" width="4"  height="24" style="fill:#ffffff; stroke:#004a82; stroke-width:4px; stroke-linejoin:round;" /><rect x="20" y="52" width="8"  height="24" style="fill:#ffffff; stroke:#004a82; stroke-width:4px; stroke-linejoin:round;" /><rect x="96" y="16" width="16"  height="96" style="fill:#ffffff; stroke:#004a82; stroke-width:4px; stroke-linejoin:round;" /><path d="m  32 52 L 32 76 L 56 76 L 56 96 L 88 64 L 56 32 L 56 52 z" style="fill:#ffffff; stroke:#004a82; stroke-width:4px; stroke-linejoin:round;" />', title);
  }
  static MoveToLeftIcon(size, shadow, semitransparent, addIcon, deleteIcon, title) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<rect x="112" y="52" width="4"  height="24" fill="lightgray" filter="url(#f1)" /><rect x="100" y="52" width="8"  height="24" fill="lightgray" filter="url(#f1)" /><rect x="16" y="16" width="16"  height="96" fill="lightgray" filter="url(#f1)" /><path d="m  96 52 L 96 76 L 72 76 L 72 96 L 40 64 L 72 32 L 72 52 z" fill="lightgray" filter="url(#f1)" />', '<rect x="112" y="52" width="4"  height="24" style="fill:#ffffff; stroke:#004a82; stroke-width:4px; stroke-linejoin:round;" /><rect x="100" y="52" width="8"  height="24" style="fill:#ffffff; stroke:#004a82; stroke-width:4px; stroke-linejoin:round;" /><rect x="16" y="16" width="16"  height="96" style="fill:#ffffff; stroke:#004a82; stroke-width:4px; stroke-linejoin:round;" /><path d="m  96 52 L 96 76 L 72 76 L 72 96 L 40 64 L 72 32 L 72 52 z" style="fill:#ffffff; stroke:#004a82; stroke-width:4px; stroke-linejoin:round;" />', title);
  }
  static ExpandIcon(size, shadow, semitransparent, addIcon, deleteIcon, title) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="m  24 56 L 24 72 L 56 72 L 56 104 L 72 104 L 72 72 L 104 72 L 104 56 L 72 56 L 72 24 L 56 24 L 56 56 z"  fill="lightgray" filter="url(#f1)" />', '<path d="m 24 56 L 24 72 L 56 72 L 56 104 L 72 104 L 72 72 L 104 72 L 104 56 L 72 56 L 72 24 L 56 24 L 56 56  z" style="fill:black; " />', title);
  }
  static OkIcon(size, shadow, semitransparent, addIcon, deleteIcon, title) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<circle cx="64" cy="64" r="56"   fill="lightgray" filter="url(#f1)" />', '<circle cx="64" cy="64" r="56" fill="#00b20f"/><path d="m 19 72 L 34 87 L 60 62 L 94 96 L 109 81 L 60 32  z" style="fill:white; " />', title);
  }
  static FailedIcon(size, shadow, semitransparent, addIcon, deleteIcon, title) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<circle cx="64" cy="64" r="56"   fill="lightgray" filter="url(#f1)" />', '<circle cx="64" cy="64" r="56" fill="#ff101e"/><path d="m 43 99 L 64 79 L 85 99 L 100 85 L 79 64 L 100 43 L 85 28 L 64 49 L 43 28 L 28  43 L 49 64 L  28 85   z" style="fill:white; " />', title);
  }
  static DontKnowIcon(size, shadow, semitransparent, addIcon, deleteIcon, title) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<circle cx="64" cy="64" r="56"   fill="lightgray" filter="url(#f1)" />', '<circle cx="64" cy="64" r="56" fill="#f1ba00"/><text x="35" y="-30" fill="white" transform="scale(1,-1)" style="font: bold 96px sans-serif;">?</text> ', title);
  }
  static infoIcon(size, shadow, semitransparent, addIcon, deleteIcon, title) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<circle cx="64" cy="64" r="56"   fill="lightgray" filter="url(#f1)" />', '<circle cx="64" cy="64" r="56" fill="DodgerBlue"/><text x="50" y="-30" fill="white" transform="scale(1,-1)" style="font: bold 96px sans-serif;">i</text> ', title);
  }
  static ColapseIcon(size, shadow, semitransparent, addIcon, deleteIcon, title) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="m 24 56 L 24 72 L 104 72 L 104 56 z"  fill="lightgray" filter="url(#f1)" />', '<path d="m 24 56 L 24 72 L 104 72 L 104 56 z" style="fill:black; " />', title);
  }
  static AddMarkerIcon(size, index) {
    return ressources.IconSourceCode(size, false, false, false, false, "", '<circle  cx="64" cy="64"  r="50"   style="fill:lightyellow;" stroke-width="8" stroke="darkred" /><text x="46" y="-40" fill="black" transform="scale(1,-1)" style="font: bold 64px sans-serif;">' + index.toString() + "</text>");
  }
  static AddMarker(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, "", '<line x1="80" y1="8" x2="80" y2="128" stroke="darkred" stroke-width="8" stroke-linecap="round" /><path d="m 60 64 L 100 64 L 80 20 z" style="fill:darkred; " /><rect x="40" y="56" width="80" height="32" style="fill:lightYellow" stroke="darkred" stroke-width="8" />');
  }
  static EraseDatalogger(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, "", '<g transform="rotate(-35,0,0)"><g transform="translate(-56,24)"><path d="m 108 24 L 108 46 L 60 46  A 22 22 0 1 0 60 90 L 108 90  L 108 112 L 60 112 A 44 44 0 1 1 60 24 z" style="fill:#808080; " /><rect x="88" y="24" width="20" height="22" style="fill:red" stroke="none"  /><rect x="88" y="90" width="20" height="22" style="fill:blue" stroke="none"  /><path d="m 108 24 L 108 46 L 60 46  A 22 22 0 1 0 60 90 L 108 90  L 108 112 L 60 112 A 44 44 0 1 1 60 24 z"  style="fill:none" stroke="black"  stroke-width="4" stroke-linejoin="round"/></g></g>');
  }
  static resetViewPort(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, "", '<line x1="116" y1="52" x2="116" y2="12"  stroke="black"  stroke-width="4"/><line x1="12" y1="52" x2="12" y2="12"  stroke="black"  stroke-width="4"/><path d="m 100 36 L 28 36 L 28 48 L 12 32  L 28 16 L 28 28 L 100 28 L 100 16 L 116 32 L 100 48z" style="fill:white" stroke="black"  stroke-width="4" stroke-linejoin="round" /><path d="m 7.3 97.7 L 20 107.4 L 51.6 114.7 L 78.5 112.2 L 101.6 103.3 L 114.4 91.7  L 117.7 81.7 L 104.3 66.9 L 80.9 61.2 L49.9 65 L 25 76.3 L 12.6 87.5 Z " style="fill:white" stroke="none" /><circle  cx="64" cy="88" r="27" style="fill:#6cc87b" stroke="none"  /> <path d="m 37.2 84.8 A 27 27 0 0 0 46.5 108.8 L 64 88 z" style="fill:#8ed698" stroke="none" /> <circle  cx="64" cy="88" r="16" style="fill:black" stroke="none"  /> <path d="m 6 97 A 59 34 -4 0 0 119 80" style="fill:none" stroke="black"  stroke-width="4"  stroke-linecap="round"/> <path d="m 113 79 A 56 31 -16 0 0 9 93 " style="fill:none" stroke="black"  stroke-width="4"  stroke-linecap="round" /> ');
  }
  static DeleteMarker(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, "", '<line x1="80" y1="8" x2="80" y2="128" stroke="darkred" stroke-width="8" stroke-linecap="round" /><path d="m 60 64 L 100 64 L 80 20 z" style="fill:darkred; " /><rect x="40" y="56" width="80" height="32" style="fill:lightYellow" stroke="darkred" stroke-width="8" />');
  }
  static targetIcon(size, shadow, semitransparent, addIcon, deleteIcon, title) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, "", '<circle  cx="64" cy="64"  r="42"   style="fill:none;" stroke-width="8" stroke="black" /><line  x1="0"   y1="64"  x2="42"  y2="64"  style="fill:none;" stroke-width="8" stroke="black" /><line  x1="128" y1="64"  x2="86"  y2="64"  style="fill:none;" stroke-width="8" stroke="black" /><line  y1="0"   x1="64"  y2="42"  x2="64"  style="fill:none;" stroke-width="8" stroke="black" /><line  y1="128" x1="64"  y2="86"  x2="64"  style="fill:none;" stroke-width="8" stroke="black" />', title);
  }
  static DotDotDotIcon(size, shadow, semitransparent, addIcon, deleteIcon, title) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, "", '<rect x="18" y="36" width="18" height="18" style="fill:black" /><rect x="54" y="36" width="18" height="18" style="fill:black" /><rect x="90" y="36" width="18" height="18" style="fill:black" />', title);
  }
  static LogFileIcon(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, "", '<line x1="4" y1="24" x2="30" y2="24"     style=" stroke:black; stroke-width:8px;" /><line x1="34" y1="24" x2="56" y2="24"    style=" stroke:black; stroke-width:8px; " /><line x1="64" y1="24" x2="74" y2="24"    style=" stroke:black; stroke-width:8px; " /><line x1="80" y1="24" x2="88" y2="24"    style=" stroke:black; stroke-width:8px; " /><line x1="4" y1="40" x2="30" y2="40"     style=" stroke:black; stroke-width:8px;" /><line x1="34" y1="40" x2="56" y2="40"    style=" stroke:black; stroke-width:8px; " /><line x1="61" y1="40" x2="90" y2="40"    style=" stroke:black; stroke-width:8px; " /><line x1="94" y1="40" x2="110" y2="40"    style=" stroke:black; stroke-width:8px; " /><line x1="4" y1="56" x2="30" y2="56"     style=" stroke:black; stroke-width:8px;" /><line x1="34" y1="56" x2="56" y2="56"    style=" stroke:black; stroke-width:8px; " /><line x1="61" y1="56" x2="86" y2="56"    style=" stroke:black; stroke-width:8px; " /><line x1="4" y1="72" x2="30" y2="72"     style=" stroke:black; stroke-width:8px;" /><line x1="34" y1="72" x2="50" y2="72"    style=" stroke:black; stroke-width:8px; " /><line x1="56" y1="72" x2="100" y2="72"    style=" stroke:black; stroke-width:8px; " /><line x1="4" y1="88" x2="30" y2="88"     style=" stroke:black; stroke-width:8px;" /><line x1="34" y1="88" x2="56" y2="88"    style=" stroke:black; stroke-width:8px; " /><line x1="61" y1="88" x2="72" y2="88"    style=" stroke:black; stroke-width:8px; " /><line x1="78" y1="88" x2="106" y2="88"    style=" stroke:black; stroke-width:8px; " />');
  }
};

// obj/full/Pako/utils/common.js
var utils_common = class {
  static flattenChunks(chunks) {
    let len = 0;
    for (let i = 0, l = chunks.length; i < l; i++) {
      len += chunks[i].length;
    }
    const result = new Uint8Array(len);
    for (let i = 0, pos = 0, l = chunks.length; i < l; i++) {
      let chunk = chunks[i];
      result.set(chunk, pos);
      pos += chunk.length;
    }
    return result;
  }
};

// obj/full/Pako/utils/strings.js
var Pako_strings = class {
  static _init() {
    try {
      String.fromCharCode.apply(null, new Uint8Array(1));
    } catch (__) {
      Pako_strings.STR_APPLY_UIA_OK = false;
    }
    for (let q = 0; q < 256; q++) {
      Pako_strings._utf8len[q] = q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1;
    }
    Pako_strings._utf8len[254] = Pako_strings._utf8len[254] = 1;
    return true;
  }
  static string2buf(str) {
    let buf;
    let c;
    let c2;
    let m_pos;
    let i;
    let str_len = str.length;
    let buf_len = 0;
    for (m_pos = 0; m_pos < str_len; m_pos++) {
      c = str.charCodeAt(m_pos);
      if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
        c2 = str.charCodeAt(m_pos + 1);
        if ((c2 & 64512) === 56320) {
          c = 65536 + (c - 55296 << 10) + (c2 - 56320);
          m_pos++;
        }
      }
      buf_len += c < 128 ? 1 : c < 2048 ? 2 : c < 65536 ? 3 : 4;
    }
    buf = new Uint8Array(buf_len);
    for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
      c = str.charCodeAt(m_pos);
      if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
        c2 = str.charCodeAt(m_pos + 1);
        if ((c2 & 64512) === 56320) {
          c = 65536 + (c - 55296 << 10) + (c2 - 56320);
          m_pos++;
        }
      }
      if (c < 128) {
        buf[i++] = c;
      } else if (c < 2048) {
        buf[i++] = 192 | c >>> 6;
        buf[i++] = 128 | c & 63;
      } else if (c < 65536) {
        buf[i++] = 224 | c >>> 12;
        buf[i++] = 128 | c >>> 6 & 63;
        buf[i++] = 128 | c & 63;
      } else {
        buf[i++] = 240 | c >>> 18;
        buf[i++] = 128 | c >>> 12 & 63;
        buf[i++] = 128 | c >>> 6 & 63;
        buf[i++] = 128 | c & 63;
      }
    }
    return buf;
  }
  static buf2binstring(buf, len) {
    let result = "";
    for (let i = 0; i < len; i++) {
      result += String.fromCharCode(buf[i]);
    }
    return result;
  }
  static buf2string(buf, max) {
    let i;
    let out;
    const len = max || buf.length;
    const utf16buf = new Array(len * 2);
    for (out = 0, i = 0; i < len; ) {
      let c = buf[i++];
      if (c < 128) {
        utf16buf[out++] = c;
        continue;
      }
      let c_len = Pako_strings._utf8len[c];
      if (c_len > 4) {
        utf16buf[out++] = 65533;
        i += c_len - 1;
        continue;
      }
      c &= c_len === 2 ? 31 : c_len === 3 ? 15 : 7;
      while (c_len > 1 && i < len) {
        c = c << 6 | buf[i++] & 63;
        c_len--;
      }
      if (c_len > 1) {
        utf16buf[out++] = 65533;
        continue;
      }
      if (c < 65536) {
        utf16buf[out++] = c;
      } else {
        c -= 65536;
        utf16buf[out++] = 55296 | c >> 10 & 1023;
        utf16buf[out++] = 56320 | c & 1023;
      }
    }
    return Pako_strings.buf2binstring(utf16buf, out);
  }
  static utf8border(buf, max) {
    max = max || buf.length;
    if (max > buf.length) {
      max = buf.length;
    }
    let pos = max - 1;
    while (pos >= 0 && (buf[pos] & 192) === 128) {
      pos--;
    }
    if (pos < 0) {
      return max;
    }
    if (pos === 0) {
      return max;
    }
    return pos + Pako_strings._utf8len[buf[pos]] > max ? pos : max;
  }
};
Pako_strings.STR_APPLY_UIA_OK = true;
Pako_strings._utf8len = new Uint8Array(256);
Pako_strings.initDone = Pako_strings._init();

// obj/full/Pako/deflate.js
var Pako_deflate_option = class {
  constructor(CustOption) {
    this.level = zlib_constants.Z_DEFAULT_COMPRESSION;
    this.method = zlib_constants.Z_DEFLATED;
    this.chunkSize = 16384;
    this.windowBits = 15;
    this.memLevel = 8;
    this.strategy = zlib_constants.Z_DEFAULT_STRATEGY;
    this.raw = false;
    this.gzip = false;
    this.header = null;
    this.dictionary = null;
    this.ignore_os = false;
    Pako_deflate_option.ApplyCustomOptions(this, CustOption);
  }
  static ApplyCustomOptions(StdOption, CustOption) {
    if (typeof CustOption != "undefined") {
      let stdKeys = Object.keys(StdOption);
      let custKeys = Object.keys(CustOption);
      for (let i = 0; i < custKeys.length; i++) {
        if (stdKeys.indexOf(custKeys[i]) < 0) {
          debugger;
          throw "Invalid Pako option name '" + custKeys[i] + "', check Pako_deflate_option class";
        }
        let srcType = typeof Reflect.get(CustOption, custKeys[i]);
        let trgtType = typeof Reflect.get(StdOption, custKeys[i]);
        if (srcType != trgtType)
          throw "Invalid Pako type for option '" + custKeys[i] + "' (expected '" + trgtType + "', got '" + srcType + "')";
        Reflect.set(StdOption, custKeys[i], Reflect.get(CustOption, custKeys[i]));
      }
    }
  }
};
var Pako_Deflate = class {
  constructor(options) {
    this._dict_set = false;
    this.result = null;
    this.options = new Pako_deflate_option(options);
    let opt = this.options;
    if (opt.raw && opt.windowBits > 0) {
      opt.windowBits = -opt.windowBits;
    } else if (opt.gzip && opt.windowBits > 0 && opt.windowBits < 16) {
      opt.windowBits += 16;
    }
    this.err = 0;
    this.msg = "";
    this.ended = false;
    this.chunks = [];
    this.strm = new zlib_ZStream();
    this.strm.avail_out = 0;
    let status = zlib_deflate.deflateInit2(this.strm, opt.level, opt.method, opt.windowBits, opt.memLevel, opt.strategy);
    if (status !== zlib_constants.Z_OK) {
      throw new Error(zlib_messages.msg(status));
    }
    if (opt.header) {
      zlib_deflate.deflateSetHeader(this.strm, opt.header);
    }
    if (opt.dictionary) {
      let dict;
      if (typeof opt.dictionary === "string") {
        dict = Pako_strings.string2buf(opt.dictionary);
      } else if (toString.call(opt.dictionary) === "[object ArrayBuffer]") {
        dict = new Uint8Array(opt.dictionary);
      } else {
        dict = opt.dictionary;
      }
      status = zlib_deflate.deflateSetDictionary(this.strm, dict);
      if (status !== zlib_constants.Z_OK) {
        throw new Error(zlib_messages.msg(status));
      }
      this._dict_set = true;
    }
  }
  push(data, flush_mode) {
    const strm = this.strm;
    const chunkSize = this.options.chunkSize;
    let status;
    let _flush_mode;
    if (this.ended) {
      return false;
    }
    if (flush_mode === ~~flush_mode) {
      _flush_mode = flush_mode;
    } else {
      _flush_mode = flush_mode === true ? zlib_constants.Z_FINISH : zlib_constants.Z_NO_FLUSH;
    }
    if (typeof data === "string") {
      strm.input = Pako_strings.string2buf(data);
    } else if (toString.call(data) === "[object ArrayBuffer]") {
      strm.input = new Uint8Array(data);
    } else {
      strm.input = data;
    }
    strm.next_in = 0;
    strm.avail_in = strm.input.length;
    for (; ; ) {
      if (strm.avail_out === 0) {
        strm.output = new Uint8Array(chunkSize);
        strm.next_out = 0;
        strm.avail_out = chunkSize;
      }
      if ((_flush_mode === zlib_constants.Z_SYNC_FLUSH || _flush_mode === zlib_constants.Z_FULL_FLUSH) && strm.avail_out <= 6) {
        this.onData(strm.output.subarray(0, strm.next_out));
        strm.avail_out = 0;
        continue;
      }
      status = zlib_deflate.deflate(strm, _flush_mode);
      if (status === zlib_constants.Z_STREAM_END) {
        if (strm.next_out > 0) {
          this.onData(strm.output.subarray(0, strm.next_out));
        }
        status = zlib_deflate.deflateEnd(this.strm);
        this.onEnd(status);
        this.ended = true;
        return status === zlib_constants.Z_OK;
      }
      if (strm.avail_out === 0) {
        this.onData(strm.output);
        continue;
      }
      if (_flush_mode > 0 && strm.next_out > 0) {
        this.onData(strm.output.subarray(0, strm.next_out));
        strm.avail_out = 0;
        continue;
      }
      if (strm.avail_in === 0)
        break;
    }
    return true;
  }
  onData(chunk) {
    this.chunks.push(chunk);
  }
  onEnd(status) {
    if (status === zlib_constants.Z_OK) {
      this.result = utils_common.flattenChunks(this.chunks);
    }
    this.chunks = [];
    this.err = status;
    this.msg = this.strm.msg;
  }
  static deflate(input, options) {
    const deflator = new Pako_Deflate(options);
    deflator.push(input, true);
    if (deflator.err) {
      throw deflator.msg || zlib_messages.msg(deflator.err);
    }
    return deflator.result;
  }
  static deflateRaw(input, options) {
    options.raw = true;
    return Pako_Deflate.deflate(input, options);
  }
  static gzip(input, options) {
    if (typeof options == "undefined")
      options = {};
    options.gzip = true;
    return Pako_Deflate.deflate(input, options);
  }
};

// obj/full/Pako/inflate.js
var Pako_inflate_option = class {
  constructor(CustOption) {
    this.chunkSize = 1024 * 64;
    this.windowBits = 15;
    this.to = "";
    this.raw = false;
    this.dictionary = null;
    Pako_inflate_option.ApplyCustomOptions(this, CustOption);
  }
  static ApplyCustomOptions(StdOption, CustOption) {
    if (typeof CustOption != "undefined") {
      let stdKeys = Object.keys(StdOption);
      let custKeys = Object.keys(CustOption);
      for (let i = 0; i < custKeys.length; i++) {
        if (stdKeys.indexOf(custKeys[i]) < 0)
          throw "Invalid Pako option name '" + custKeys[i] + "', check Pako_inflate_option class";
        let srcType = typeof Reflect.get(CustOption, custKeys[i]);
        let trgtType = typeof Reflect.get(StdOption, custKeys[i]);
        if (srcType != trgtType) {
          throw "Invalid Pako type for option '" + custKeys[i] + "' (expected '" + trgtType + "', got '" + srcType + "')";
        }
        Reflect.set(StdOption, custKeys[i], Reflect.get(CustOption, custKeys[i]));
      }
    }
  }
};
var Pako_Inflate = class {
  constructor(options) {
    this.err = 0;
    this.msg = "";
    this.ended = false;
    this.result = null;
    this.options = new Pako_inflate_option(options);
    const opt = this.options;
    if (opt.raw && opt.windowBits >= 0 && opt.windowBits < 16) {
      opt.windowBits = -opt.windowBits;
      if (opt.windowBits === 0) {
        opt.windowBits = -15;
      }
    }
    if (opt.windowBits >= 0 && opt.windowBits < 16 && !(options && options.windowBits)) {
      opt.windowBits += 32;
    }
    if (opt.windowBits > 15 && opt.windowBits < 48) {
      if ((opt.windowBits & 15) === 0) {
        opt.windowBits |= 15;
      }
    }
    this.err = 0;
    this.msg = "";
    this.ended = false;
    this.chunks = [];
    this.strm = new zlib_ZStream();
    this.strm.avail_out = 0;
    let status = zlib_inflate.inflateInit2(this.strm, opt.windowBits);
    if (status !== zlib_constants.Z_OK) {
      throw new Error(zlib_messages.msg(status));
    }
    this.header = new zlib_GZheader();
    zlib_inflate.inflateGetHeader(this.strm, this.header);
    if (opt.dictionary) {
      if (typeof opt.dictionary === "string") {
        opt.dictionary = Pako_strings.string2buf(opt.dictionary);
      } else if (toString.call(opt.dictionary) === "[object ArrayBuffer]") {
        opt.dictionary = new Uint8Array(opt.dictionary);
      }
      if (opt.raw) {
        status = zlib_inflate.inflateSetDictionary(this.strm, opt.dictionary);
        if (status !== zlib_constants.Z_OK) {
          throw new Error(zlib_messages.msg(status));
        }
      }
    }
  }
  push(data, flush_mode) {
    const strm = this.strm;
    const chunkSize = this.options.chunkSize;
    const dictionary = this.options.dictionary;
    let status;
    let _flush_mode;
    let last_avail_out;
    if (this.ended)
      return false;
    if (flush_mode === ~~flush_mode) {
      _flush_mode = flush_mode;
    } else {
      _flush_mode = flush_mode === true ? zlib_constants.Z_FINISH : zlib_constants.Z_NO_FLUSH;
    }
    if (toString.call(data) === "[object ArrayBuffer]") {
      strm.input = new Uint8Array(data);
    } else {
      strm.input = data;
    }
    strm.next_in = 0;
    strm.avail_in = strm.input.length;
    for (; ; ) {
      if (strm.avail_out === 0) {
        strm.output = new Uint8Array(chunkSize);
        strm.next_out = 0;
        strm.avail_out = chunkSize;
      }
      status = zlib_inflate.inflate(strm, _flush_mode);
      if (status === zlib_constants.Z_NEED_DICT && dictionary) {
        status = zlib_inflate.inflateSetDictionary(strm, dictionary);
        if (status === zlib_constants.Z_OK) {
          status = zlib_inflate.inflate(strm, _flush_mode);
        } else if (status === zlib_constants.Z_DATA_ERROR) {
          status = zlib_constants.Z_NEED_DICT;
        }
      }
      while (strm.avail_in > 0 && status === zlib_constants.Z_STREAM_END && strm.state.wrap > 0 && data[strm.next_in] !== 0) {
        zlib_inflate.inflateReset(strm);
        status = zlib_inflate.inflate(strm, _flush_mode);
      }
      switch (status) {
        case zlib_constants.Z_STREAM_ERROR:
        case zlib_constants.Z_DATA_ERROR:
        case zlib_constants.Z_NEED_DICT:
        case zlib_constants.Z_MEM_ERROR:
          this.onEnd(status);
          this.ended = true;
          return false;
      }
      last_avail_out = strm.avail_out;
      if (strm.next_out) {
        if (strm.avail_out === 0 || status === zlib_constants.Z_STREAM_END) {
          if (this.options.to === "string") {
            let next_out_utf8 = Pako_strings.utf8border(strm.output, strm.next_out);
            let tail = strm.next_out - next_out_utf8;
            let utf8str = Pako_strings.buf2string(strm.output, next_out_utf8);
            strm.next_out = tail;
            strm.avail_out = chunkSize - tail;
            if (tail)
              strm.output.set(strm.output.subarray(next_out_utf8, next_out_utf8 + tail), 0);
            this.onData(utf8str);
          } else {
            this.onData(strm.output.length === strm.next_out ? strm.output : strm.output.subarray(0, strm.next_out));
          }
        }
      }
      if (status === zlib_constants.Z_OK && last_avail_out === 0)
        continue;
      if (status === zlib_constants.Z_STREAM_END) {
        status = zlib_inflate.inflateEnd(this.strm);
        this.onEnd(status);
        this.ended = true;
        return true;
      }
      if (strm.avail_in === 0)
        break;
    }
    return true;
  }
  onData(chunk) {
    this.chunks[this.chunks.length] = chunk;
  }
  onEnd(status) {
    if (status === zlib_constants.Z_OK) {
      if (this.options.to === "string") {
        this.result = this.chunks.join("");
      } else {
        this.result = utils_common.flattenChunks(this.chunks);
      }
    }
    this.chunks = [];
    this.err = status;
    this.msg = this.strm.msg;
  }
  static inflate(input, options) {
    const inflator = new Pako_Inflate(options);
    inflator.push(input, false);
    if (inflator.err)
      throw inflator.msg || zlib_messages.msg(inflator.err);
    return inflator.result;
  }
  inflateRaw(input, options) {
    options.raw = true;
    return Pako_Inflate.inflate(input, options);
  }
  static ungzip(input, options) {
    return Pako_Inflate.inflate(input, options);
  }
};

// obj/full/Pako/zlib/adler32.js
"use strict";
var zlib_adler32 = class {
  static adler32(adler, buf, len, pos) {
    let s1 = adler & 65535 | 0, s2 = adler >>> 16 & 65535 | 0, n = 0;
    while (len !== 0) {
      n = len > 2e3 ? 2e3 : len;
      len -= n;
      do {
        s1 = s1 + buf[pos++] | 0;
        s2 = s2 + s1 | 0;
      } while (--n);
      s1 %= 65521;
      s2 %= 65521;
    }
    return s1 | s2 << 16 | 0;
  }
};

// obj/full/Pako/zlib/constants.js
"use strict";
var zlib_constants = class {
};
zlib_constants.Z_NO_FLUSH = 0;
zlib_constants.Z_PARTIAL_FLUSH = 1;
zlib_constants.Z_SYNC_FLUSH = 2;
zlib_constants.Z_FULL_FLUSH = 3;
zlib_constants.Z_FINISH = 4;
zlib_constants.Z_BLOCK = 5;
zlib_constants.Z_TREES = 6;
zlib_constants.Z_OK = 0;
zlib_constants.Z_STREAM_END = 1;
zlib_constants.Z_NEED_DICT = 2;
zlib_constants.Z_ERRNO = -1;
zlib_constants.Z_STREAM_ERROR = -2;
zlib_constants.Z_DATA_ERROR = -3;
zlib_constants.Z_MEM_ERROR = -4;
zlib_constants.Z_BUF_ERROR = -5;
zlib_constants.Z_NO_COMPRESSION = 0;
zlib_constants.Z_BEST_SPEED = 1;
zlib_constants.Z_BEST_COMPRESSION = 9;
zlib_constants.Z_DEFAULT_COMPRESSION = -1;
zlib_constants.Z_FILTERED = 1;
zlib_constants.Z_HUFFMAN_ONLY = 2;
zlib_constants.Z_RLE = 3;
zlib_constants.Z_FIXED = 4;
zlib_constants.Z_DEFAULT_STRATEGY = 0;
zlib_constants.Z_BINARY = 0;
zlib_constants.Z_TEXT = 1;
zlib_constants.Z_UNKNOWN = 2;
zlib_constants.Z_DEFLATED = 8;

// obj/full/Pako/zlib/crc32.js
"use strict";
var zlib_crc32 = class {
  static makeTable() {
    let c;
    let table = new Int32Array(256);
    for (let n = 0; n < 256; n++) {
      c = n;
      for (let k = 0; k < 8; k++) {
        c = c & 1 ? 3988292384 ^ c >>> 1 : c >>> 1;
      }
      table[n] = c;
    }
    return table;
  }
  static crc32(crc, buf, len, pos) {
    let t = zlib_crc32.crcTable;
    let end = pos + len;
    crc ^= -1;
    for (let i = pos; i < end; i++) {
      crc = crc >>> 8 ^ t[(crc ^ buf[i]) & 255];
    }
    return crc ^ -1;
  }
};
zlib_crc32.crcTable = zlib_crc32.makeTable();

// obj/full/Pako/zlib/deflate.js
"use strict";
var zlib_config = class {
  constructor(good_length, max_lazy, nice_length, max_chain, func) {
    this.good_length = good_length;
    this.max_lazy = max_lazy;
    this.nice_length = nice_length;
    this.max_chain = max_chain;
    this.func = func;
  }
};
var zlib_DeflateState = class {
  constructor() {
    this.strm = null;
    this.status = 0;
    this.pending_buf = null;
    this.pending_buf_size = 0;
    this.pending_out = 0;
    this.pending = 0;
    this.wrap = 0;
    this.gzhead = null;
    this.gzindex = 0;
    this.method = zlib_constants.Z_DEFLATED;
    this.last_flush = -1;
    this.w_size = 0;
    this.w_bits = 0;
    this.w_mask = 0;
    this.window = null;
    this.window_size = 0;
    this.prev = null;
    this.head = null;
    this.ins_h = 0;
    this.hash_size = 0;
    this.hash_bits = 0;
    this.hash_mask = 0;
    this.hash_shift = 0;
    this.block_start = 0;
    this.match_length = 0;
    this.prev_match = 0;
    this.match_available = 0;
    this.strstart = 0;
    this.match_start = 0;
    this.lookahead = 0;
    this.prev_length = 0;
    this.max_chain_length = 0;
    this.max_lazy_match = 0;
    this.level = 0;
    this.strategy = 0;
    this.good_match = 0;
    this.nice_match = 0;
    this.dyn_ltree = new Uint16Array(zlib_Pako_trees.HEAP_SIZE * 2);
    this.dyn_dtree = new Uint16Array((2 * zlib_Pako_trees.D_CODES + 1) * 2);
    this.bl_tree = new Uint16Array((2 * zlib_Pako_trees.BL_CODES + 1) * 2);
    this.l_desc = null;
    this.d_desc = null;
    this.bl_desc = null;
    this.bl_count = new Uint16Array(zlib_Pako_trees.MAX_BITS + 1);
    this.heap = new Uint16Array(2 * zlib_Pako_trees.L_CODES + 1);
    this.heap_len = 0;
    this.heap_max = 0;
    this.depth = new Uint16Array(2 * zlib_Pako_trees.L_CODES + 1);
    this.l_buf = 0;
    this.lit_bufsize = 0;
    this.last_lit = 0;
    this.d_buf = 0;
    this.opt_len = 0;
    this.static_len = 0;
    this.matches = 0;
    this.insert = 0;
    this.bi_buf = 0;
    this.bi_valid = 0;
    zlib_Pako_trees.zero(this.dyn_ltree);
    zlib_Pako_trees.zero(this.dyn_dtree);
    zlib_Pako_trees.zero(this.bl_tree);
    zlib_Pako_trees.zero(this.heap);
    zlib_Pako_trees.zero(this.depth);
  }
};
var zlib_deflate = class {
  static err(strm, errorCode) {
    strm.msg = zlib_messages.msg(errorCode);
    return errorCode;
  }
  static rank(f) {
    return (f << 1) - (f > 4 ? 9 : 0);
  }
  zero(buf) {
    let len = buf.length;
    while (--len >= 0) {
      buf[len] = 0;
    }
  }
  static HASH_ZLIB(s, prev, data) {
    return (prev << s.hash_shift ^ data) & s.hash_mask;
  }
  static HASH(s, prev, data) {
    return (prev << s.hash_shift ^ data) & s.hash_mask;
  }
  static flush_pending(strm) {
    const s = strm.state;
    let len = s.pending;
    if (len > strm.avail_out) {
      len = strm.avail_out;
    }
    if (len === 0) {
      return;
    }
    strm.output.set(s.pending_buf.subarray(s.pending_out, s.pending_out + len), strm.next_out);
    strm.next_out += len;
    s.pending_out += len;
    strm.total_out += len;
    strm.avail_out -= len;
    s.pending -= len;
    if (s.pending === 0) {
      s.pending_out = 0;
    }
  }
  static flush_block_only(s, last) {
    zlib_Pako_trees._tr_flush_block(s, s.block_start >= 0 ? s.block_start : -1, s.strstart - s.block_start, last);
    s.block_start = s.strstart;
    zlib_deflate.flush_pending(s.strm);
  }
  static put_byte(s, b) {
    s.pending_buf[s.pending++] = b;
  }
  static putShortMSB(s, b) {
    s.pending_buf[s.pending++] = b >>> 8 & 255;
    s.pending_buf[s.pending++] = b & 255;
  }
  static read_buf(strm, buf, start, size) {
    let len = strm.avail_in;
    if (len > size) {
      len = size;
    }
    if (len === 0) {
      return 0;
    }
    strm.avail_in -= len;
    buf.set(strm.input.subarray(strm.next_in, strm.next_in + len), start);
    if (strm.state.wrap === 1) {
      strm.adler = zlib_adler32.adler32(strm.adler, buf, len, start);
    } else if (strm.state.wrap === 2) {
      strm.adler = zlib_crc32.crc32(strm.adler, buf, len, start);
    }
    strm.next_in += len;
    strm.total_in += len;
    return len;
  }
  static longest_match(s, cur_match) {
    let chain_length = s.max_chain_length;
    let scan = s.strstart;
    let match;
    let len;
    let best_len = s.prev_length;
    let nice_match = s.nice_match;
    const limit = s.strstart > s.w_size - zlib_deflate.MIN_LOOKAHEAD ? s.strstart - (s.w_size - zlib_deflate.MIN_LOOKAHEAD) : 0;
    const _win = s.window;
    const wmask = s.w_mask;
    const prev = s.prev;
    const strend = s.strstart + zlib_Pako_trees.MAX_MATCH;
    let scan_end1 = _win[scan + best_len - 1];
    let scan_end = _win[scan + best_len];
    if (s.prev_length >= s.good_match) {
      chain_length >>= 2;
    }
    if (nice_match > s.lookahead) {
      nice_match = s.lookahead;
    }
    do {
      match = cur_match;
      if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1]) {
        continue;
      }
      scan += 2;
      match++;
      do {
      } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend);
      len = zlib_Pako_trees.MAX_MATCH - (strend - scan);
      scan = strend - zlib_Pako_trees.MAX_MATCH;
      if (len > best_len) {
        s.match_start = cur_match;
        best_len = len;
        if (len >= nice_match) {
          break;
        }
        scan_end1 = _win[scan + best_len - 1];
        scan_end = _win[scan + best_len];
      }
    } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);
    if (best_len <= s.lookahead) {
      return best_len;
    }
    return s.lookahead;
  }
  static fill_window(s) {
    const _w_size = s.w_size;
    let p;
    let n;
    let m;
    let more;
    let str;
    do {
      more = s.window_size - s.lookahead - s.strstart;
      if (s.strstart >= _w_size + (_w_size - zlib_deflate.MIN_LOOKAHEAD)) {
        s.window.set(s.window.subarray(_w_size, _w_size + _w_size), 0);
        s.match_start -= _w_size;
        s.strstart -= _w_size;
        s.block_start -= _w_size;
        n = s.hash_size;
        p = n;
        do {
          m = s.head[--p];
          s.head[p] = m >= _w_size ? m - _w_size : 0;
        } while (--n);
        n = _w_size;
        p = n;
        do {
          m = s.prev[--p];
          s.prev[p] = m >= _w_size ? m - _w_size : 0;
        } while (--n);
        more += _w_size;
      }
      if (s.strm.avail_in === 0) {
        break;
      }
      n = zlib_deflate.read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
      s.lookahead += n;
      if (s.lookahead + s.insert >= zlib_Pako_trees.MIN_MATCH) {
        str = s.strstart - s.insert;
        s.ins_h = s.window[str];
        s.ins_h = zlib_deflate.HASH(s, s.ins_h, s.window[str + 1]);
        while (s.insert) {
          s.ins_h = zlib_deflate.HASH(s, s.ins_h, s.window[str + zlib_Pako_trees.MIN_MATCH - 1]);
          s.prev[str & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = str;
          str++;
          s.insert--;
          if (s.lookahead + s.insert < zlib_Pako_trees.MIN_MATCH) {
            break;
          }
        }
      }
    } while (s.lookahead < zlib_deflate.MIN_LOOKAHEAD && s.strm.avail_in !== 0);
  }
  static deflate_stored(s, flush) {
    let max_block_size = 65535;
    if (max_block_size > s.pending_buf_size - 5) {
      max_block_size = s.pending_buf_size - 5;
    }
    for (; ; ) {
      if (s.lookahead <= 1) {
        zlib_deflate.fill_window(s);
        if (s.lookahead === 0 && flush === zlib_constants.Z_NO_FLUSH) {
          return zlib_deflate.BS_NEED_MORE;
        }
        if (s.lookahead === 0) {
          break;
        }
      }
      s.strstart += s.lookahead;
      s.lookahead = 0;
      const max_start = s.block_start + max_block_size;
      if (s.strstart === 0 || s.strstart >= max_start) {
        s.lookahead = s.strstart - max_start;
        s.strstart = max_start;
        zlib_deflate.flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return zlib_deflate.BS_NEED_MORE;
        }
      }
      if (s.strstart - s.block_start >= s.w_size - zlib_deflate.MIN_LOOKAHEAD) {
        zlib_deflate.flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return zlib_deflate.BS_NEED_MORE;
        }
      }
    }
    s.insert = 0;
    if (flush === zlib_constants.Z_FINISH) {
      zlib_deflate.flush_block_only(s, true);
      if (s.strm.avail_out === 0) {
        return zlib_deflate.BS_FINISH_STARTED;
      }
      return zlib_deflate.BS_FINISH_DONE;
    }
    if (s.strstart > s.block_start) {
      zlib_deflate.flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return zlib_deflate.BS_NEED_MORE;
      }
    }
    return zlib_deflate.BS_NEED_MORE;
  }
  static deflate_slow(s, flush) {
    let hash_head;
    let bflush;
    let max_insert;
    for (; ; ) {
      if (s.lookahead < zlib_deflate.MIN_LOOKAHEAD) {
        zlib_deflate.fill_window(s);
        if (s.lookahead < zlib_deflate.MIN_LOOKAHEAD && flush === zlib_constants.Z_NO_FLUSH) {
          return zlib_deflate.BS_NEED_MORE;
        }
        if (s.lookahead === 0) {
          break;
        }
      }
      hash_head = 0;
      if (s.lookahead >= zlib_Pako_trees.MIN_MATCH) {
        s.ins_h = zlib_deflate.HASH(s, s.ins_h, s.window[s.strstart + zlib_Pako_trees.MIN_MATCH - 1]);
        hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
        s.head[s.ins_h] = s.strstart;
      }
      s.prev_length = s.match_length;
      s.prev_match = s.match_start;
      s.match_length = zlib_Pako_trees.MIN_MATCH - 1;
      if (hash_head !== 0 && s.prev_length < s.max_lazy_match && s.strstart - hash_head <= s.w_size - zlib_deflate.MIN_LOOKAHEAD) {
        s.match_length = zlib_deflate.longest_match(s, hash_head);
        if (s.match_length <= 5 && (s.strategy === zlib_constants.Z_FILTERED || s.match_length === zlib_Pako_trees.MIN_MATCH && s.strstart - s.match_start > 4096)) {
          s.match_length = zlib_Pako_trees.MIN_MATCH - 1;
        }
      }
      if (s.prev_length >= zlib_Pako_trees.MIN_MATCH && s.match_length <= s.prev_length) {
        max_insert = s.strstart + s.lookahead - zlib_Pako_trees.MIN_MATCH;
        bflush = zlib_Pako_trees._tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - zlib_Pako_trees.MIN_MATCH);
        s.lookahead -= s.prev_length - 1;
        s.prev_length -= 2;
        do {
          if (++s.strstart <= max_insert) {
            s.ins_h = zlib_deflate.HASH(s, s.ins_h, s.window[s.strstart + zlib_Pako_trees.MIN_MATCH - 1]);
            hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
            s.head[s.ins_h] = s.strstart;
          }
        } while (--s.prev_length !== 0);
        s.match_available = 0;
        s.match_length = zlib_Pako_trees.MIN_MATCH - 1;
        s.strstart++;
        if (bflush) {
          zlib_deflate.flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return zlib_deflate.BS_NEED_MORE;
          }
        }
      } else if (s.match_available) {
        bflush = zlib_Pako_trees._tr_tally(s, 0, s.window[s.strstart - 1]);
        if (bflush) {
          zlib_deflate.flush_block_only(s, false);
        }
        s.strstart++;
        s.lookahead--;
        if (s.strm.avail_out === 0) {
          return zlib_deflate.BS_NEED_MORE;
        }
      } else {
        s.match_available = 1;
        s.strstart++;
        s.lookahead--;
      }
    }
    if (s.match_available) {
      bflush = zlib_Pako_trees._tr_tally(s, 0, s.window[s.strstart - 1]);
      s.match_available = 0;
    }
    s.insert = s.strstart < zlib_Pako_trees.MIN_MATCH - 1 ? s.strstart : zlib_Pako_trees.MIN_MATCH - 1;
    if (flush === zlib_constants.Z_FINISH) {
      zlib_deflate.flush_block_only(s, true);
      if (s.strm.avail_out === 0) {
        return zlib_deflate.BS_FINISH_STARTED;
      }
      return zlib_deflate.BS_FINISH_DONE;
    }
    if (s.last_lit) {
      zlib_deflate.flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return zlib_deflate.BS_NEED_MORE;
      }
    }
    return zlib_deflate.BS_BLOCK_DONE;
  }
  static deflate_rle(s, flush) {
    let bflush;
    let prev;
    let scan;
    let strend;
    const _win = s.window;
    for (; ; ) {
      if (s.lookahead <= zlib_Pako_trees.MAX_MATCH) {
        zlib_deflate.fill_window(s);
        if (s.lookahead <= zlib_Pako_trees.MAX_MATCH && flush === zlib_constants.Z_NO_FLUSH) {
          return zlib_deflate.BS_NEED_MORE;
        }
        if (s.lookahead === 0) {
          break;
        }
      }
      s.match_length = 0;
      if (s.lookahead >= zlib_Pako_trees.MIN_MATCH && s.strstart > 0) {
        scan = s.strstart - 1;
        prev = _win[scan];
        if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
          strend = s.strstart + zlib_Pako_trees.MAX_MATCH;
          do {
          } while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);
          s.match_length = zlib_Pako_trees.MAX_MATCH - (strend - scan);
          if (s.match_length > s.lookahead) {
            s.match_length = s.lookahead;
          }
        }
      }
      if (s.match_length >= zlib_Pako_trees.MIN_MATCH) {
        bflush = zlib_Pako_trees._tr_tally(s, 1, s.match_length - zlib_Pako_trees.MIN_MATCH);
        s.lookahead -= s.match_length;
        s.strstart += s.match_length;
        s.match_length = 0;
      } else {
        bflush = zlib_Pako_trees._tr_tally(s, 0, s.window[s.strstart]);
        s.lookahead--;
        s.strstart++;
      }
      if (bflush) {
        zlib_deflate.flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return zlib_deflate.BS_NEED_MORE;
        }
      }
    }
    s.insert = 0;
    if (flush === zlib_constants.Z_FINISH) {
      zlib_deflate.flush_block_only(s, true);
      if (s.strm.avail_out === 0) {
        return zlib_deflate.BS_FINISH_STARTED;
      }
      return zlib_deflate.BS_FINISH_DONE;
    }
    if (s.last_lit) {
      zlib_deflate.flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return zlib_deflate.BS_NEED_MORE;
      }
    }
    return zlib_deflate.BS_BLOCK_DONE;
  }
  static deflate_huff(s, flush) {
    let bflush;
    for (; ; ) {
      if (s.lookahead === 0) {
        zlib_deflate.fill_window(s);
        if (s.lookahead === 0) {
          if (flush === zlib_constants.Z_NO_FLUSH) {
            return zlib_deflate.BS_NEED_MORE;
          }
          break;
        }
      }
      s.match_length = 0;
      bflush = zlib_Pako_trees._tr_tally(s, 0, s.window[s.strstart]);
      s.lookahead--;
      s.strstart++;
      if (bflush) {
        zlib_deflate.flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return zlib_deflate.BS_NEED_MORE;
        }
      }
    }
    s.insert = 0;
    if (flush === zlib_constants.Z_FINISH) {
      zlib_deflate.flush_block_only(s, true);
      if (s.strm.avail_out === 0) {
        return zlib_deflate.BS_FINISH_STARTED;
      }
      return zlib_deflate.BS_FINISH_DONE;
    }
    if (s.last_lit) {
      zlib_deflate.flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return zlib_deflate.BS_NEED_MORE;
      }
    }
    return zlib_deflate.BS_BLOCK_DONE;
  }
  static lm_init(s) {
    s.window_size = 2 * s.w_size;
    zlib_Pako_trees.zero(s.head);
    s.max_lazy_match = zlib_deflate.configuration_table[s.level].max_lazy;
    s.good_match = zlib_deflate.configuration_table[s.level].good_length;
    s.nice_match = zlib_deflate.configuration_table[s.level].nice_length;
    s.max_chain_length = zlib_deflate.configuration_table[s.level].max_chain;
    s.strstart = 0;
    s.block_start = 0;
    s.lookahead = 0;
    s.insert = 0;
    s.match_length = s.prev_length = zlib_Pako_trees.MIN_MATCH - 1;
    s.match_available = 0;
    s.ins_h = 0;
  }
  static deflateResetKeep(strm) {
    if (!strm || !strm.state) {
      return zlib_deflate.err(strm, zlib_constants.Z_STREAM_ERROR);
    }
    strm.total_in = strm.total_out = 0;
    strm.data_type = zlib_constants.Z_UNKNOWN;
    let s = strm.state;
    s.pending = 0;
    s.pending_out = 0;
    if (s.wrap < 0) {
      s.wrap = -s.wrap;
    }
    s.status = s.wrap ? zlib_deflate.INIT_STATE : zlib_deflate.BUSY_STATE;
    strm.adler = s.wrap === 2 ? 0 : 1;
    s.last_flush = zlib_constants.Z_NO_FLUSH;
    zlib_Pako_trees._tr_init(s);
    return zlib_constants.Z_OK;
  }
  static deflateReset(strm) {
    const ret = zlib_deflate.deflateResetKeep(strm);
    if (ret === zlib_constants.Z_OK) {
      zlib_deflate.lm_init(strm.state);
    }
    return ret;
  }
  static deflateSetHeader(strm, head) {
    if (!strm || !strm.state) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    if (strm.state.wrap !== 2) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    strm.state.gzhead = head;
    return zlib_constants.Z_OK;
  }
  static deflateInit2(strm, level, method, windowBits, memLevel, strategy) {
    if (!strm) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    let wrap = 1;
    if (level === zlib_constants.Z_DEFAULT_COMPRESSION) {
      level = 6;
    }
    if (windowBits < 0) {
      wrap = 0;
      windowBits = -windowBits;
    } else if (windowBits > 15) {
      wrap = 2;
      windowBits -= 16;
    }
    if (memLevel < 1 || memLevel > zlib_deflate.MAX_MEM_LEVEL || method !== zlib_constants.Z_DEFLATED || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > zlib_constants.Z_FIXED) {
      return zlib_deflate.err(strm, zlib_constants.Z_STREAM_ERROR);
    }
    if (windowBits === 8) {
      windowBits = 9;
    }
    const s = new zlib_DeflateState();
    strm.state = s;
    s.strm = strm;
    s.wrap = wrap;
    s.gzhead = null;
    s.w_bits = windowBits;
    s.w_size = 1 << s.w_bits;
    s.w_mask = s.w_size - 1;
    s.hash_bits = memLevel + 7;
    s.hash_size = 1 << s.hash_bits;
    s.hash_mask = s.hash_size - 1;
    s.hash_shift = ~~((s.hash_bits + zlib_Pako_trees.MIN_MATCH - 1) / zlib_Pako_trees.MIN_MATCH);
    s.window = new Uint8Array(s.w_size * 2);
    s.head = new Uint16Array(s.hash_size);
    s.prev = new Uint16Array(s.w_size);
    s.lit_bufsize = 1 << memLevel + 6;
    s.pending_buf_size = s.lit_bufsize * 4;
    s.pending_buf = new Uint8Array(s.pending_buf_size);
    s.d_buf = 1 * s.lit_bufsize;
    s.l_buf = (1 + 2) * s.lit_bufsize;
    s.level = level;
    s.strategy = strategy;
    s.method = method;
    return zlib_deflate.deflateReset(strm);
  }
  static deflateInit(strm, level) {
    return zlib_deflate.deflateInit2(strm, level, zlib_constants.Z_DEFLATED, zlib_deflate.MAX_WBITS, zlib_deflate.DEF_MEM_LEVEL, zlib_constants.Z_DEFAULT_STRATEGY);
  }
  static deflate(strm, flush) {
    let beg, val;
    if (!strm || !strm.state || flush > zlib_constants.Z_BLOCK || flush < 0) {
      return strm ? zlib_deflate.err(strm, zlib_constants.Z_STREAM_ERROR) : zlib_constants.Z_STREAM_ERROR;
    }
    let s = strm.state;
    if (!strm.output || !strm.input && strm.avail_in !== 0 || s.status === zlib_deflate.FINISH_STATE && flush !== zlib_constants.Z_FINISH) {
      return zlib_deflate.err(strm, strm.avail_out === 0 ? zlib_constants.Z_BUF_ERROR : zlib_constants.Z_STREAM_ERROR);
    }
    s.strm = strm;
    const old_flush = s.last_flush;
    s.last_flush = flush;
    if (s.status === zlib_deflate.INIT_STATE) {
      if (s.wrap === 2) {
        strm.adler = 0;
        zlib_deflate.put_byte(s, 31);
        zlib_deflate.put_byte(s, 139);
        zlib_deflate.put_byte(s, 8);
        if (!s.gzhead) {
          zlib_deflate.put_byte(s, 0);
          zlib_deflate.put_byte(s, 0);
          zlib_deflate.put_byte(s, 0);
          zlib_deflate.put_byte(s, 0);
          zlib_deflate.put_byte(s, 0);
          zlib_deflate.put_byte(s, s.level === 9 ? 2 : s.strategy >= zlib_constants.Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
          zlib_deflate.put_byte(s, zlib_deflate.OS_CODE);
          s.status = zlib_deflate.BUSY_STATE;
        } else {
          zlib_deflate.put_byte(s, (s.gzhead.text ? 1 : 0) + (s.gzhead.hcrc ? 2 : 0) + (!s.gzhead.extra ? 0 : 4) + (!s.gzhead.name ? 0 : 8) + (!s.gzhead.comment ? 0 : 16));
          zlib_deflate.put_byte(s, s.gzhead.time & 255);
          zlib_deflate.put_byte(s, s.gzhead.time >> 8 & 255);
          zlib_deflate.put_byte(s, s.gzhead.time >> 16 & 255);
          zlib_deflate.put_byte(s, s.gzhead.time >> 24 & 255);
          zlib_deflate.put_byte(s, s.level === 9 ? 2 : s.strategy >= zlib_constants.Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
          zlib_deflate.put_byte(s, s.gzhead.os & 255);
          if (s.gzhead.extra && s.gzhead.extra.length) {
            zlib_deflate.put_byte(s, s.gzhead.extra.length & 255);
            zlib_deflate.put_byte(s, s.gzhead.extra.length >> 8 & 255);
          }
          if (s.gzhead.hcrc) {
            strm.adler = zlib_crc32.crc32(strm.adler, s.pending_buf, s.pending, 0);
          }
          s.gzindex = 0;
          s.status = zlib_deflate.EXTRA_STATE;
        }
      } else {
        let header = zlib_constants.Z_DEFLATED + (s.w_bits - 8 << 4) << 8;
        let level_flags = -1;
        if (s.strategy >= zlib_constants.Z_HUFFMAN_ONLY || s.level < 2) {
          level_flags = 0;
        } else if (s.level < 6) {
          level_flags = 1;
        } else if (s.level === 6) {
          level_flags = 2;
        } else {
          level_flags = 3;
        }
        header |= level_flags << 6;
        if (s.strstart !== 0) {
          header |= zlib_deflate.PRESET_DICT;
        }
        header += 31 - header % 31;
        s.status = zlib_deflate.BUSY_STATE;
        zlib_deflate.putShortMSB(s, header);
        if (s.strstart !== 0) {
          zlib_deflate.putShortMSB(s, strm.adler >>> 16);
          zlib_deflate.putShortMSB(s, strm.adler & 65535);
        }
        strm.adler = 1;
      }
    }
    if (s.status === zlib_deflate.EXTRA_STATE) {
      if (s.gzhead.extra) {
        beg = s.pending;
        while (s.gzindex < (s.gzhead.extra.length & 65535)) {
          if (s.pending === s.pending_buf_size) {
            if (s.gzhead.hcrc && s.pending > beg) {
              strm.adler = zlib_crc32.crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
            }
            zlib_deflate.flush_pending(strm);
            beg = s.pending;
            if (s.pending === s.pending_buf_size) {
              break;
            }
          }
          zlib_deflate.put_byte(s, s.gzhead.extra[s.gzindex] & 255);
          s.gzindex++;
        }
        if (s.gzhead.hcrc && s.pending > beg) {
          strm.adler = zlib_crc32.crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
        }
        if (s.gzindex === s.gzhead.extra.length) {
          s.gzindex = 0;
          s.status = zlib_deflate.NAME_STATE;
        }
      } else {
        s.status = zlib_deflate.NAME_STATE;
      }
    }
    if (s.status === zlib_deflate.NAME_STATE) {
      if (s.gzhead.name) {
        beg = s.pending;
        do {
          if (s.pending === s.pending_buf_size) {
            if (s.gzhead.hcrc && s.pending > beg) {
              strm.adler = zlib_crc32.crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
            }
            zlib_deflate.flush_pending(strm);
            beg = s.pending;
            if (s.pending === s.pending_buf_size) {
              val = 1;
              break;
            }
          }
          if (s.gzindex < s.gzhead.name.length) {
            val = s.gzhead.name.charCodeAt(s.gzindex++) & 255;
          } else {
            val = 0;
          }
          zlib_deflate.put_byte(s, val);
        } while (val !== 0);
        if (s.gzhead.hcrc && s.pending > beg) {
          strm.adler = zlib_crc32.crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
        }
        if (val === 0) {
          s.gzindex = 0;
          s.status = zlib_deflate.COMMENT_STATE;
        }
      } else {
        s.status = zlib_deflate.COMMENT_STATE;
      }
    }
    if (s.status === zlib_deflate.COMMENT_STATE) {
      if (s.gzhead.comment) {
        beg = s.pending;
        do {
          if (s.pending === s.pending_buf_size) {
            if (s.gzhead.hcrc && s.pending > beg) {
              strm.adler = zlib_crc32.crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
            }
            zlib_deflate.flush_pending(strm);
            beg = s.pending;
            if (s.pending === s.pending_buf_size) {
              val = 1;
              break;
            }
          }
          if (s.gzindex < s.gzhead.comment.length) {
            val = s.gzhead.comment.charCodeAt(s.gzindex++) & 255;
          } else {
            val = 0;
          }
          zlib_deflate.put_byte(s, val);
        } while (val !== 0);
        if (s.gzhead.hcrc && s.pending > beg) {
          strm.adler = zlib_crc32.crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
        }
        if (val === 0) {
          s.status = zlib_deflate.HCRC_STATE;
        }
      } else {
        s.status = zlib_deflate.HCRC_STATE;
      }
    }
    if (s.status === zlib_deflate.HCRC_STATE) {
      if (s.gzhead.hcrc) {
        if (s.pending + 2 > s.pending_buf_size) {
          zlib_deflate.flush_pending(strm);
        }
        if (s.pending + 2 <= s.pending_buf_size) {
          zlib_deflate.put_byte(s, strm.adler & 255);
          zlib_deflate.put_byte(s, strm.adler >> 8 & 255);
          strm.adler = 0;
          s.status = zlib_deflate.BUSY_STATE;
        }
      } else {
        s.status = zlib_deflate.BUSY_STATE;
      }
    }
    if (s.pending !== 0) {
      zlib_deflate.flush_pending(strm);
      if (strm.avail_out === 0) {
        s.last_flush = -1;
        return zlib_constants.Z_OK;
      }
    } else if (strm.avail_in === 0 && zlib_deflate.rank(flush) <= zlib_deflate.rank(old_flush) && flush !== zlib_constants.Z_FINISH) {
      return zlib_deflate.err(strm, zlib_constants.Z_BUF_ERROR);
    }
    if (s.status === zlib_deflate.FINISH_STATE && strm.avail_in !== 0) {
      return zlib_deflate.err(strm, zlib_constants.Z_BUF_ERROR);
    }
    if (strm.avail_in !== 0 || s.lookahead !== 0 || flush !== zlib_constants.Z_NO_FLUSH && s.status !== zlib_deflate.FINISH_STATE) {
      let bstate = s.strategy === zlib_constants.Z_HUFFMAN_ONLY ? zlib_deflate.deflate_huff(s, flush) : s.strategy === zlib_constants.Z_RLE ? zlib_deflate.deflate_rle(s, flush) : zlib_deflate.configuration_table[s.level].func(s, flush);
      if (bstate === zlib_deflate.BS_FINISH_STARTED || bstate === zlib_deflate.BS_FINISH_DONE) {
        s.status = zlib_deflate.FINISH_STATE;
      }
      if (bstate === zlib_deflate.BS_NEED_MORE || bstate === zlib_deflate.BS_FINISH_STARTED) {
        if (strm.avail_out === 0) {
          s.last_flush = -1;
        }
        return zlib_constants.Z_OK;
      }
      if (bstate === zlib_deflate.BS_BLOCK_DONE) {
        if (flush === zlib_constants.Z_PARTIAL_FLUSH) {
          zlib_Pako_trees._tr_align(s);
        } else if (flush !== zlib_constants.Z_BLOCK) {
          zlib_Pako_trees._tr_stored_block(s, 0, 0, false);
          if (flush === zlib_constants.Z_FULL_FLUSH) {
            zlib_Pako_trees.zero(s.head);
            if (s.lookahead === 0) {
              s.strstart = 0;
              s.block_start = 0;
              s.insert = 0;
            }
          }
        }
        zlib_deflate.flush_pending(strm);
        if (strm.avail_out === 0) {
          s.last_flush = -1;
          return zlib_constants.Z_OK;
        }
      }
    }
    if (flush !== zlib_constants.Z_FINISH) {
      return zlib_constants.Z_OK;
    }
    if (s.wrap <= 0) {
      return zlib_constants.Z_STREAM_END;
    }
    if (s.wrap === 2) {
      zlib_deflate.put_byte(s, strm.adler & 255);
      zlib_deflate.put_byte(s, strm.adler >> 8 & 255);
      zlib_deflate.put_byte(s, strm.adler >> 16 & 255);
      zlib_deflate.put_byte(s, strm.adler >> 24 & 255);
      zlib_deflate.put_byte(s, strm.total_in & 255);
      zlib_deflate.put_byte(s, strm.total_in >> 8 & 255);
      zlib_deflate.put_byte(s, strm.total_in >> 16 & 255);
      zlib_deflate.put_byte(s, strm.total_in >> 24 & 255);
    } else {
      zlib_deflate.putShortMSB(s, strm.adler >>> 16);
      zlib_deflate.putShortMSB(s, strm.adler & 65535);
    }
    zlib_deflate.flush_pending(strm);
    if (s.wrap > 0) {
      s.wrap = -s.wrap;
    }
    return s.pending !== 0 ? zlib_constants.Z_OK : zlib_constants.Z_STREAM_END;
  }
  static deflateEnd(strm) {
    if (!strm || !strm.state) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    let status = strm.state.status;
    if (status !== zlib_deflate.INIT_STATE && status !== zlib_deflate.EXTRA_STATE && status !== zlib_deflate.NAME_STATE && status !== zlib_deflate.COMMENT_STATE && status !== zlib_deflate.HCRC_STATE && status !== zlib_deflate.BUSY_STATE && status !== zlib_deflate.FINISH_STATE) {
      return zlib_deflate.err(strm, zlib_constants.Z_STREAM_ERROR);
    }
    strm.state = null;
    return status === zlib_deflate.BUSY_STATE ? zlib_deflate.err(strm, zlib_constants.Z_DATA_ERROR) : zlib_constants.Z_OK;
  }
  static deflateSetDictionary(strm, dictionary) {
    let dictLength = dictionary.length;
    if (!strm || !strm.state) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    const s = strm.state;
    const wrap = s.wrap;
    if (wrap === 2 || wrap === 1 && s.status !== zlib_deflate.INIT_STATE || s.lookahead) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    if (wrap === 1) {
      strm.adler = zlib_adler32.adler32(strm.adler, dictionary, dictLength, 0);
    }
    s.wrap = 0;
    if (dictLength >= s.w_size) {
      if (wrap === 0) {
        zlib_Pako_trees.zero(s.head);
        s.strstart = 0;
        s.block_start = 0;
        s.insert = 0;
      }
      let tmpDict = new Uint8Array(s.w_size);
      tmpDict.set(dictionary.subarray(dictLength - s.w_size, dictLength), 0);
      dictionary = tmpDict;
      dictLength = s.w_size;
    }
    const avail = strm.avail_in;
    const next = strm.next_in;
    const input = strm.input;
    strm.avail_in = dictLength;
    strm.next_in = 0;
    strm.input = dictionary;
    zlib_deflate.fill_window(s);
    while (s.lookahead >= zlib_Pako_trees.MIN_MATCH) {
      let str = s.strstart;
      let n = s.lookahead - (zlib_Pako_trees.MIN_MATCH - 1);
      do {
        s.ins_h = zlib_deflate.HASH(s, s.ins_h, s.window[str + zlib_Pako_trees.MIN_MATCH - 1]);
        s.prev[str & s.w_mask] = s.head[s.ins_h];
        s.head[s.ins_h] = str;
        str++;
      } while (--n);
      s.strstart = str;
      s.lookahead = zlib_Pako_trees.MIN_MATCH - 1;
      zlib_deflate.fill_window(s);
    }
    s.strstart += s.lookahead;
    s.block_start = s.strstart;
    s.insert = s.lookahead;
    s.lookahead = 0;
    s.match_length = s.prev_length = zlib_Pako_trees.MIN_MATCH - 1;
    s.match_available = 0;
    strm.next_in = next;
    strm.input = input;
    strm.avail_in = avail;
    s.wrap = wrap;
    return zlib_constants.Z_OK;
  }
};
zlib_deflate.MAX_MEM_LEVEL = 9;
zlib_deflate.MAX_WBITS = 15;
zlib_deflate.DEF_MEM_LEVEL = 8;
zlib_deflate.LENGTH_CODES = 29;
zlib_deflate.LITERALS = 256;
zlib_deflate.L_CODES = zlib_deflate.LITERALS + 1 + zlib_deflate.LENGTH_CODES;
zlib_deflate.D_CODES = 30;
zlib_deflate.BL_CODES = 19;
zlib_deflate.HEAP_SIZE = 2 * zlib_deflate.L_CODES + 1;
zlib_deflate.MAX_BITS = 15;
zlib_deflate.MIN_MATCH = 3;
zlib_deflate.MAX_MATCH = 258;
zlib_deflate.MIN_LOOKAHEAD = zlib_deflate.MAX_MATCH + zlib_deflate.MIN_MATCH + 1;
zlib_deflate.PRESET_DICT = 32;
zlib_deflate.INIT_STATE = 42;
zlib_deflate.EXTRA_STATE = 69;
zlib_deflate.NAME_STATE = 73;
zlib_deflate.COMMENT_STATE = 91;
zlib_deflate.HCRC_STATE = 103;
zlib_deflate.BUSY_STATE = 113;
zlib_deflate.FINISH_STATE = 666;
zlib_deflate.BS_NEED_MORE = 1;
zlib_deflate.BS_BLOCK_DONE = 2;
zlib_deflate.BS_FINISH_STARTED = 3;
zlib_deflate.BS_FINISH_DONE = 4;
zlib_deflate.OS_CODE = 3;
zlib_deflate.deflate_fast = (s, flush) => {
  let hash_head;
  let bflush;
  for (; ; ) {
    if (s.lookahead < zlib_deflate.MIN_LOOKAHEAD) {
      zlib_deflate.fill_window(s);
      if (s.lookahead < zlib_deflate.MIN_LOOKAHEAD && flush === zlib_constants.Z_NO_FLUSH) {
        return zlib_deflate.BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break;
      }
    }
    hash_head = 0;
    if (s.lookahead >= zlib_Pako_trees.MIN_MATCH) {
      s.ins_h = zlib_deflate.HASH(s, s.ins_h, s.window[s.strstart + zlib_Pako_trees.MIN_MATCH - 1]);
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
    }
    if (hash_head !== 0 && s.strstart - hash_head <= s.w_size - zlib_deflate.MIN_LOOKAHEAD) {
      s.match_length = zlib_deflate.longest_match(s, hash_head);
    }
    if (s.match_length >= zlib_Pako_trees.MIN_MATCH) {
      bflush = zlib_Pako_trees._tr_tally(s, s.strstart - s.match_start, s.match_length - zlib_Pako_trees.MIN_MATCH);
      s.lookahead -= s.match_length;
      if (s.match_length <= s.max_lazy_match && s.lookahead >= zlib_Pako_trees.MIN_MATCH) {
        s.match_length--;
        do {
          s.strstart++;
          s.ins_h = zlib_deflate.HASH(s, s.ins_h, s.window[s.strstart + zlib_Pako_trees.MIN_MATCH - 1]);
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
        } while (--s.match_length !== 0);
        s.strstart++;
      } else {
        s.strstart += s.match_length;
        s.match_length = 0;
        s.ins_h = s.window[s.strstart];
        s.ins_h = zlib_deflate.HASH(s, s.ins_h, s.window[s.strstart + 1]);
      }
    } else {
      bflush = zlib_Pako_trees._tr_tally(s, 0, s.window[s.strstart]);
      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      zlib_deflate.flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return zlib_deflate.BS_NEED_MORE;
      }
    }
  }
  s.insert = s.strstart < zlib_Pako_trees.MIN_MATCH - 1 ? s.strstart : zlib_Pako_trees.MIN_MATCH - 1;
  if (flush === zlib_constants.Z_FINISH) {
    zlib_deflate.flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return zlib_deflate.BS_FINISH_STARTED;
    }
    return zlib_deflate.BS_FINISH_DONE;
  }
  if (s.last_lit) {
    zlib_deflate.flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return zlib_deflate.BS_NEED_MORE;
    }
  }
  return zlib_deflate.BS_BLOCK_DONE;
};
zlib_deflate.configuration_table = [
  new zlib_config(0, 0, 0, 0, zlib_deflate.deflate_stored),
  new zlib_config(4, 4, 8, 4, zlib_deflate.deflate_fast),
  new zlib_config(4, 5, 16, 8, zlib_deflate.deflate_fast),
  new zlib_config(4, 6, 32, 32, zlib_deflate.deflate_fast),
  new zlib_config(4, 4, 16, 16, zlib_deflate.deflate_slow),
  new zlib_config(8, 16, 32, 32, zlib_deflate.deflate_slow),
  new zlib_config(8, 16, 128, 128, zlib_deflate.deflate_slow),
  new zlib_config(8, 32, 128, 256, zlib_deflate.deflate_slow),
  new zlib_config(32, 128, 258, 1024, zlib_deflate.deflate_slow),
  new zlib_config(32, 258, 258, 4096, zlib_deflate.deflate_slow)
];

// obj/full/Pako/zlib/trees.js
"use strict";
var zlib_StaticTreeDesc = class {
  constructor(static_tree, extra_bits, extra_base, elems, max_length) {
    this.static_tree = static_tree;
    this.extra_bits = extra_bits;
    this.extra_base = extra_base;
    this.elems = elems;
    this.max_length = max_length;
    this.has_stree = static_tree != null && static_tree.length > 0;
  }
};
var zlib_TreeDesc = class {
  constructor(dyn_tree, stat_desc) {
    this.max_code = 0;
    this.dyn_tree = dyn_tree;
    this.max_code = 0;
    this.stat_desc = stat_desc;
  }
};
var zlib_Pako_trees = class {
  static zero(buf) {
    let len = buf.length;
    while (--len >= 0) {
      buf[len] = 0;
    }
  }
  static Zeroinit() {
    zlib_Pako_trees.zero(zlib_Pako_trees.static_ltree);
    zlib_Pako_trees.zero(zlib_Pako_trees.base_dist);
    zlib_Pako_trees.zero(zlib_Pako_trees.base_length);
    zlib_Pako_trees.zero(zlib_Pako_trees._length_code);
    zlib_Pako_trees.zero(zlib_Pako_trees._dist_code);
    zlib_Pako_trees.zero(zlib_Pako_trees.static_dtree);
    return true;
  }
  static d_code(dist) {
    return dist < 256 ? zlib_Pako_trees._dist_code[dist] : zlib_Pako_trees._dist_code[256 + (dist >>> 7)];
  }
  static put_short(s, w) {
    s.pending_buf[s.pending++] = w & 255;
    s.pending_buf[s.pending++] = w >>> 8 & 255;
  }
  static send_code(s, c, tree) {
    zlib_Pako_trees.send_bits(s, tree[c * 2], tree[c * 2 + 1]);
  }
  static bi_reverse(code, len) {
    let res = 0;
    do {
      res |= code & 1;
      code >>>= 1;
      res <<= 1;
    } while (--len > 0);
    return res >>> 1;
  }
  static bi_flush(s) {
    if (s.bi_valid === 16) {
      zlib_Pako_trees.put_short(s, s.bi_buf);
      s.bi_buf = 0;
      s.bi_valid = 0;
    } else if (s.bi_valid >= 8) {
      s.pending_buf[s.pending++] = s.bi_buf & 255;
      s.bi_buf >>= 8;
      s.bi_valid -= 8;
    }
  }
  static gen_codes(tree, max_code, bl_count) {
    const next_code = new Array(zlib_Pako_trees.MAX_BITS + 1);
    let code = 0;
    let bits;
    let n;
    for (bits = 1; bits <= zlib_Pako_trees.MAX_BITS; bits++) {
      next_code[bits] = code = code + bl_count[bits - 1] << 1;
    }
    for (n = 0; n <= max_code; n++) {
      let len = tree[n * 2 + 1];
      if (len === 0) {
        continue;
      }
      tree[n * 2] = zlib_Pako_trees.bi_reverse(next_code[len]++, len);
    }
  }
  static tr_static_init() {
    let n;
    let bits;
    let length;
    let code;
    let dist;
    const bl_count = new Uint16Array(zlib_Pako_trees.MAX_BITS + 1);
    length = 0;
    for (code = 0; code < zlib_Pako_trees.LENGTH_CODES - 1; code++) {
      zlib_Pako_trees.base_length[code] = length;
      for (n = 0; n < 1 << zlib_Pako_trees.extra_lbits[code]; n++) {
        zlib_Pako_trees._length_code[length++] = code;
      }
    }
    zlib_Pako_trees._length_code[length - 1] = code;
    dist = 0;
    for (code = 0; code < 16; code++) {
      zlib_Pako_trees.base_dist[code] = dist;
      for (n = 0; n < 1 << zlib_Pako_trees.extra_dbits[code]; n++) {
        zlib_Pako_trees._dist_code[dist++] = code;
      }
    }
    dist >>= 7;
    for (; code < zlib_Pako_trees.D_CODES; code++) {
      zlib_Pako_trees.base_dist[code] = dist << 7;
      for (n = 0; n < 1 << zlib_Pako_trees.extra_dbits[code] - 7; n++) {
        zlib_Pako_trees._dist_code[256 + dist++] = code;
      }
    }
    for (bits = 0; bits <= zlib_Pako_trees.MAX_BITS; bits++) {
      bl_count[bits] = 0;
    }
    n = 0;
    while (n <= 143) {
      zlib_Pako_trees.static_ltree[n * 2 + 1] = 8;
      n++;
      bl_count[8]++;
    }
    while (n <= 255) {
      zlib_Pako_trees.static_ltree[n * 2 + 1] = 9;
      n++;
      bl_count[9]++;
    }
    while (n <= 279) {
      zlib_Pako_trees.static_ltree[n * 2 + 1] = 7;
      n++;
      bl_count[7]++;
    }
    while (n <= 287) {
      zlib_Pako_trees.static_ltree[n * 2 + 1] = 8;
      n++;
      bl_count[8]++;
    }
    zlib_Pako_trees.gen_codes(zlib_Pako_trees.static_ltree, zlib_Pako_trees.L_CODES + 1, bl_count);
    for (n = 0; n < zlib_Pako_trees.D_CODES; n++) {
      zlib_Pako_trees.static_dtree[n * 2 + 1] = 5;
      zlib_Pako_trees.static_dtree[n * 2] = zlib_Pako_trees.bi_reverse(n, 5);
    }
    zlib_Pako_trees.static_l_desc = new zlib_StaticTreeDesc(zlib_Pako_trees.static_ltree, zlib_Pako_trees.extra_lbits, zlib_Pako_trees.LITERALS + 1, zlib_Pako_trees.L_CODES, zlib_Pako_trees.MAX_BITS);
    zlib_Pako_trees.static_d_desc = new zlib_StaticTreeDesc(zlib_Pako_trees.static_dtree, zlib_Pako_trees.extra_dbits, 0, zlib_Pako_trees.D_CODES, zlib_Pako_trees.MAX_BITS);
    zlib_Pako_trees.static_bl_desc = new zlib_StaticTreeDesc(new Uint16Array(0), zlib_Pako_trees.extra_blbits, 0, zlib_Pako_trees.BL_CODES, zlib_Pako_trees.MAX_BL_BITS);
  }
  static init_block(s) {
    let n;
    for (n = 0; n < zlib_Pako_trees.L_CODES; n++) {
      s.dyn_ltree[n * 2] = 0;
    }
    for (n = 0; n < zlib_Pako_trees.D_CODES; n++) {
      s.dyn_dtree[n * 2] = 0;
    }
    for (n = 0; n < zlib_Pako_trees.BL_CODES; n++) {
      s.bl_tree[n * 2] = 0;
    }
    s.dyn_ltree[zlib_Pako_trees.END_BLOCK * 2] = 1;
    s.opt_len = s.static_len = 0;
    s.last_lit = s.matches = 0;
  }
  static bi_windup(s) {
    if (s.bi_valid > 8) {
      zlib_Pako_trees.put_short(s, s.bi_buf);
    } else if (s.bi_valid > 0) {
      s.pending_buf[s.pending++] = s.bi_buf;
    }
    s.bi_buf = 0;
    s.bi_valid = 0;
  }
  static copy_block(s, buf, len, header) {
    zlib_Pako_trees.bi_windup(s);
    if (header) {
      zlib_Pako_trees.put_short(s, len);
      zlib_Pako_trees.put_short(s, ~len);
    }
    s.pending_buf.set(s.window.subarray(buf, buf + len), s.pending);
    s.pending += len;
  }
  static smaller(tree, n, m, depth) {
    const _n2 = n * 2;
    const _m2 = m * 2;
    return tree[_n2] < tree[_m2] || tree[_n2] === tree[_m2] && depth[n] <= depth[m];
  }
  static pqdownheap(s, tree, k) {
    const v = s.heap[k];
    let j = k << 1;
    while (j <= s.heap_len) {
      if (j < s.heap_len && zlib_Pako_trees.smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
        j++;
      }
      if (zlib_Pako_trees.smaller(tree, v, s.heap[j], s.depth)) {
        break;
      }
      s.heap[k] = s.heap[j];
      k = j;
      j <<= 1;
    }
    s.heap[k] = v;
  }
  static compress_block(s, ltree, dtree) {
    let dist;
    let lc;
    let lx = 0;
    let code;
    let extra;
    if (s.last_lit !== 0) {
      do {
        dist = s.pending_buf[s.d_buf + lx * 2] << 8 | s.pending_buf[s.d_buf + lx * 2 + 1];
        lc = s.pending_buf[s.l_buf + lx];
        lx++;
        if (dist === 0) {
          zlib_Pako_trees.send_code(s, lc, ltree);
        } else {
          code = zlib_Pako_trees._length_code[lc];
          zlib_Pako_trees.send_code(s, code + zlib_Pako_trees.LITERALS + 1, ltree);
          extra = zlib_Pako_trees.extra_lbits[code];
          if (extra !== 0) {
            lc -= zlib_Pako_trees.base_length[code];
            zlib_Pako_trees.send_bits(s, lc, extra);
          }
          dist--;
          code = zlib_Pako_trees.d_code(dist);
          zlib_Pako_trees.send_code(s, code, dtree);
          extra = zlib_Pako_trees.extra_dbits[code];
          if (extra !== 0) {
            dist -= zlib_Pako_trees.base_dist[code];
            zlib_Pako_trees.send_bits(s, dist, extra);
          }
        }
      } while (lx < s.last_lit);
    }
    zlib_Pako_trees.send_code(s, zlib_Pako_trees.END_BLOCK, ltree);
  }
  static build_tree(s, desc) {
    const tree = desc.dyn_tree;
    const stree = desc.stat_desc.static_tree;
    const has_stree = desc.stat_desc.has_stree;
    const elems = desc.stat_desc.elems;
    let n, m;
    let max_code = -1;
    let node;
    s.heap_len = 0;
    s.heap_max = zlib_Pako_trees.HEAP_SIZE;
    for (n = 0; n < elems; n++) {
      if (tree[n * 2] !== 0) {
        s.heap[++s.heap_len] = max_code = n;
        s.depth[n] = 0;
      } else {
        tree[n * 2 + 1] = 0;
      }
    }
    while (s.heap_len < 2) {
      node = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0;
      tree[node * 2] = 1;
      s.depth[node] = 0;
      s.opt_len--;
      if (has_stree) {
        s.static_len -= stree[node * 2 + 1];
      }
    }
    desc.max_code = max_code;
    for (n = s.heap_len >> 1; n >= 1; n--) {
      zlib_Pako_trees.pqdownheap(s, tree, n);
    }
    node = elems;
    do {
      n = s.heap[1];
      s.heap[1] = s.heap[s.heap_len--];
      zlib_Pako_trees.pqdownheap(s, tree, 1);
      m = s.heap[1];
      s.heap[--s.heap_max] = n;
      s.heap[--s.heap_max] = m;
      tree[node * 2] = tree[n * 2] + tree[m * 2];
      s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
      tree[n * 2 + 1] = tree[m * 2 + 1] = node;
      s.heap[1] = node++;
      zlib_Pako_trees.pqdownheap(s, tree, 1);
    } while (s.heap_len >= 2);
    s.heap[--s.heap_max] = s.heap[1];
    zlib_Pako_trees.gen_bitlen(s, desc);
    zlib_Pako_trees.gen_codes(tree, max_code, s.bl_count);
  }
  static scan_tree(s, tree, max_code) {
    let n;
    let prevlen = -1;
    let curlen;
    let nextlen = tree[0 * 2 + 1];
    let count = 0;
    let max_count = 7;
    let min_count = 4;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    }
    tree[(max_code + 1) * 2 + 1] = 65535;
    for (n = 0; n <= max_code; n++) {
      curlen = nextlen;
      nextlen = tree[(n + 1) * 2 + 1];
      if (++count < max_count && curlen === nextlen) {
        continue;
      } else if (count < min_count) {
        s.bl_tree[curlen * 2] += count;
      } else if (curlen !== 0) {
        if (curlen !== prevlen) {
          s.bl_tree[curlen * 2]++;
        }
        s.bl_tree[zlib_Pako_trees.REP_3_6 * 2]++;
      } else if (count <= 10) {
        s.bl_tree[zlib_Pako_trees.REPZ_3_10 * 2]++;
      } else {
        s.bl_tree[zlib_Pako_trees.REPZ_11_138 * 2]++;
      }
      count = 0;
      prevlen = curlen;
      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      } else if (curlen === nextlen) {
        max_count = 6;
        min_count = 3;
      } else {
        max_count = 7;
        min_count = 4;
      }
    }
  }
  static send_tree(s, tree, max_code) {
    let n;
    let prevlen = -1;
    let curlen;
    let nextlen = tree[0 * 2 + 1];
    let count = 0;
    let max_count = 7;
    let min_count = 4;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    }
    for (n = 0; n <= max_code; n++) {
      curlen = nextlen;
      nextlen = tree[(n + 1) * 2 + 1];
      if (++count < max_count && curlen === nextlen) {
        continue;
      } else if (count < min_count) {
        do {
          zlib_Pako_trees.send_code(s, curlen, s.bl_tree);
        } while (--count !== 0);
      } else if (curlen !== 0) {
        if (curlen !== prevlen) {
          zlib_Pako_trees.send_code(s, curlen, s.bl_tree);
          count--;
        }
        zlib_Pako_trees.send_code(s, zlib_Pako_trees.REP_3_6, s.bl_tree);
        zlib_Pako_trees.send_bits(s, count - 3, 2);
      } else if (count <= 10) {
        zlib_Pako_trees.send_code(s, zlib_Pako_trees.REPZ_3_10, s.bl_tree);
        zlib_Pako_trees.send_bits(s, count - 3, 3);
      } else {
        zlib_Pako_trees.send_code(s, zlib_Pako_trees.REPZ_11_138, s.bl_tree);
        zlib_Pako_trees.send_bits(s, count - 11, 7);
      }
      count = 0;
      prevlen = curlen;
      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      } else if (curlen === nextlen) {
        max_count = 6;
        min_count = 3;
      } else {
        max_count = 7;
        min_count = 4;
      }
    }
  }
  static build_bl_tree(s) {
    let max_blindex;
    zlib_Pako_trees.scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
    zlib_Pako_trees.scan_tree(s, s.dyn_dtree, s.d_desc.max_code);
    zlib_Pako_trees.build_tree(s, s.bl_desc);
    for (max_blindex = zlib_Pako_trees.BL_CODES - 1; max_blindex >= 3; max_blindex--) {
      if (s.bl_tree[zlib_Pako_trees.bl_order[max_blindex] * 2 + 1] !== 0) {
        break;
      }
    }
    s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
    return max_blindex;
  }
  static send_all_trees(s, lcodes, dcodes, blcodes) {
    let rank;
    zlib_Pako_trees.send_bits(s, lcodes - 257, 5);
    zlib_Pako_trees.send_bits(s, dcodes - 1, 5);
    zlib_Pako_trees.send_bits(s, blcodes - 4, 4);
    for (rank = 0; rank < blcodes; rank++) {
      zlib_Pako_trees.send_bits(s, s.bl_tree[zlib_Pako_trees.bl_order[rank] * 2 + 1], 3);
    }
    zlib_Pako_trees.send_tree(s, s.dyn_ltree, lcodes - 1);
    zlib_Pako_trees.send_tree(s, s.dyn_dtree, dcodes - 1);
  }
  static detect_data_type(s) {
    let black_mask = 4093624447;
    let n;
    for (n = 0; n <= 31; n++, black_mask >>>= 1) {
      if (black_mask & 1 && s.dyn_ltree[n * 2] !== 0) {
        return zlib_constants.Z_BINARY;
      }
    }
    if (s.dyn_ltree[9 * 2] !== 0 || s.dyn_ltree[10 * 2] !== 0 || s.dyn_ltree[13 * 2] !== 0) {
      return zlib_constants.Z_TEXT;
    }
    for (n = 32; n < zlib_Pako_trees.LITERALS; n++) {
      if (s.dyn_ltree[n * 2] !== 0) {
        return zlib_constants.Z_TEXT;
      }
    }
    return zlib_constants.Z_BINARY;
  }
  static _tr_init(s) {
    if (!zlib_Pako_trees.static_init_done) {
      zlib_Pako_trees.tr_static_init();
      zlib_Pako_trees.static_init_done = true;
    }
    s.l_desc = new zlib_TreeDesc(s.dyn_ltree, zlib_Pako_trees.static_l_desc);
    s.d_desc = new zlib_TreeDesc(s.dyn_dtree, zlib_Pako_trees.static_d_desc);
    s.bl_desc = new zlib_TreeDesc(s.bl_tree, zlib_Pako_trees.static_bl_desc);
    s.bi_buf = 0;
    s.bi_valid = 0;
    zlib_Pako_trees.init_block(s);
  }
  static _tr_stored_block(s, buf, stored_len, last) {
    zlib_Pako_trees.send_bits(s, (zlib_Pako_trees.STORED_BLOCK << 1) + (last ? 1 : 0), 3);
    zlib_Pako_trees.copy_block(s, buf, stored_len, true);
  }
  static _tr_align(s) {
    zlib_Pako_trees.send_bits(s, zlib_Pako_trees.STATIC_TREES << 1, 3);
    zlib_Pako_trees.send_code(s, zlib_Pako_trees.END_BLOCK, zlib_Pako_trees.static_ltree);
    zlib_Pako_trees.bi_flush(s);
  }
  static _tr_flush_block(s, buf, stored_len, last) {
    let opt_lenb;
    let static_lenb;
    let max_blindex = 0;
    if (s.level > 0) {
      if (s.strm.data_type === zlib_constants.Z_UNKNOWN) {
        s.strm.data_type = zlib_Pako_trees.detect_data_type(s);
      }
      zlib_Pako_trees.build_tree(s, s.l_desc);
      zlib_Pako_trees.build_tree(s, s.d_desc);
      max_blindex = zlib_Pako_trees.build_bl_tree(s);
      opt_lenb = s.opt_len + 3 + 7 >>> 3;
      static_lenb = s.static_len + 3 + 7 >>> 3;
      if (static_lenb <= opt_lenb) {
        opt_lenb = static_lenb;
      }
    } else {
      opt_lenb = static_lenb = stored_len + 5;
    }
    if (stored_len + 4 <= opt_lenb && buf !== -1) {
      zlib_Pako_trees._tr_stored_block(s, buf, stored_len, last);
    } else if (s.strategy === zlib_constants.Z_FIXED || static_lenb === opt_lenb) {
      zlib_Pako_trees.send_bits(s, (zlib_Pako_trees.STATIC_TREES << 1) + (last ? 1 : 0), 3);
      zlib_Pako_trees.compress_block(s, zlib_Pako_trees.static_ltree, zlib_Pako_trees.static_dtree);
    } else {
      zlib_Pako_trees.send_bits(s, (zlib_Pako_trees.DYN_TREES << 1) + (last ? 1 : 0), 3);
      zlib_Pako_trees.send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
      zlib_Pako_trees.compress_block(s, s.dyn_ltree, s.dyn_dtree);
    }
    zlib_Pako_trees.init_block(s);
    if (last) {
      zlib_Pako_trees.bi_windup(s);
    }
  }
  static _tr_tally(s, dist, lc) {
    s.pending_buf[s.d_buf + s.last_lit * 2] = dist >>> 8 & 255;
    s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 255;
    s.pending_buf[s.l_buf + s.last_lit] = lc & 255;
    s.last_lit++;
    if (dist === 0) {
      s.dyn_ltree[lc * 2]++;
    } else {
      s.matches++;
      dist--;
      s.dyn_ltree[(zlib_Pako_trees._length_code[lc] + zlib_Pako_trees.LITERALS + 1) * 2]++;
      s.dyn_dtree[zlib_Pako_trees.d_code(dist) * 2]++;
    }
    return s.last_lit === s.lit_bufsize - 1;
  }
};
zlib_Pako_trees.Z_FIXED = 4;
zlib_Pako_trees.Z_BINARY = 0;
zlib_Pako_trees.Z_TEXT = 1;
zlib_Pako_trees.Z_UNKNOWN = 2;
zlib_Pako_trees.STORED_BLOCK = 0;
zlib_Pako_trees.STATIC_TREES = 1;
zlib_Pako_trees.DYN_TREES = 2;
zlib_Pako_trees.MIN_MATCH = 3;
zlib_Pako_trees.MAX_MATCH = 258;
zlib_Pako_trees.LENGTH_CODES = 29;
zlib_Pako_trees.LITERALS = 256;
zlib_Pako_trees.L_CODES = zlib_Pako_trees.LITERALS + 1 + zlib_Pako_trees.LENGTH_CODES;
zlib_Pako_trees.D_CODES = 30;
zlib_Pako_trees.BL_CODES = 19;
zlib_Pako_trees.HEAP_SIZE = 2 * zlib_Pako_trees.L_CODES + 1;
zlib_Pako_trees.MAX_BITS = 15;
zlib_Pako_trees.Buf_size = 16;
zlib_Pako_trees.MAX_BL_BITS = 7;
zlib_Pako_trees.END_BLOCK = 256;
zlib_Pako_trees.REP_3_6 = 16;
zlib_Pako_trees.REPZ_3_10 = 17;
zlib_Pako_trees.REPZ_11_138 = 18;
zlib_Pako_trees.extra_lbits = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0]);
zlib_Pako_trees.extra_dbits = new Uint8Array([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]);
zlib_Pako_trees.extra_blbits = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7]);
zlib_Pako_trees.bl_order = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
zlib_Pako_trees.DIST_CODE_LEN = 512;
zlib_Pako_trees.static_ltree = new Uint16Array((zlib_Pako_trees.L_CODES + 2) * 2);
zlib_Pako_trees.static_dtree = new Uint16Array(zlib_Pako_trees.D_CODES * 2);
zlib_Pako_trees._dist_code = new Uint16Array(zlib_Pako_trees.DIST_CODE_LEN);
zlib_Pako_trees._length_code = new Uint16Array(zlib_Pako_trees.MAX_MATCH - zlib_Pako_trees.MIN_MATCH + 1);
zlib_Pako_trees.base_length = new Uint16Array(zlib_Pako_trees.LENGTH_CODES);
zlib_Pako_trees.base_dist = new Uint16Array(zlib_Pako_trees.D_CODES);
zlib_Pako_trees.send_bits = (s, value, length) => {
  if (s.bi_valid > zlib_Pako_trees.Buf_size - length) {
    s.bi_buf |= value << s.bi_valid & 65535;
    zlib_Pako_trees.put_short(s, s.bi_buf);
    s.bi_buf = value >> zlib_Pako_trees.Buf_size - s.bi_valid;
    s.bi_valid += length - zlib_Pako_trees.Buf_size;
  } else {
    s.bi_buf |= value << s.bi_valid & 65535;
    s.bi_valid += length;
  }
};
zlib_Pako_trees.gen_bitlen = (s, desc) => {
  const tree = desc.dyn_tree;
  const max_code = desc.max_code;
  const stree = desc.stat_desc.static_tree;
  const has_stree = desc.stat_desc.has_stree;
  const extra = desc.stat_desc.extra_bits;
  const base = desc.stat_desc.extra_base;
  const max_length = desc.stat_desc.max_length;
  let h;
  let n, m;
  let bits;
  let xbits;
  let f;
  let overflow = 0;
  for (bits = 0; bits <= zlib_Pako_trees.MAX_BITS; bits++) {
    s.bl_count[bits] = 0;
  }
  tree[s.heap[s.heap_max] * 2 + 1] = 0;
  for (h = s.heap_max + 1; h < zlib_Pako_trees.HEAP_SIZE; h++) {
    n = s.heap[h];
    bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;
    if (bits > max_length) {
      bits = max_length;
      overflow++;
    }
    tree[n * 2 + 1] = bits;
    if (n > max_code) {
      continue;
    }
    s.bl_count[bits]++;
    xbits = 0;
    if (n >= base) {
      xbits = extra[n - base];
    }
    f = tree[n * 2];
    s.opt_len += f * (bits + xbits);
    if (has_stree) {
      s.static_len += f * (stree[n * 2 + 1] + xbits);
    }
  }
  if (overflow === 0) {
    return;
  }
  do {
    bits = max_length - 1;
    while (s.bl_count[bits] === 0) {
      bits--;
    }
    s.bl_count[bits]--;
    s.bl_count[bits + 1] += 2;
    s.bl_count[max_length]--;
    overflow -= 2;
  } while (overflow > 0);
  for (bits = max_length; bits !== 0; bits--) {
    n = s.bl_count[bits];
    while (n !== 0) {
      m = s.heap[--h];
      if (m > max_code) {
        continue;
      }
      if (tree[m * 2 + 1] !== bits) {
        s.opt_len += (bits - tree[m * 2 + 1]) * tree[m * 2];
        tree[m * 2 + 1] = bits;
      }
      n--;
    }
  }
};
zlib_Pako_trees.static_init_done = false;
zlib_Pako_trees.initDone = zlib_Pako_trees.Zeroinit();

// obj/full/Pako/zlib/gzheader.js
"use strict";
var zlib_GZheader = class {
  constructor() {
    this.text = 0;
    this.time = 0;
    this.xflags = 0;
    this.os = 0;
    this.extra = null;
    this.extra_len = 0;
    this.name = "";
    this.comment = "";
    this.hcrc = 0;
    this.done = false;
  }
};

// obj/full/Pako/zlib/inffast.js
"use strict";
var zlib_inffast = class {
  static inflate_fast(strm, start) {
    let _in;
    let last;
    let _out;
    let beg;
    let end;
    let wsize;
    let whave;
    let wnext;
    let s_window;
    let hold;
    let bits;
    let lcode;
    let dcode;
    let lmask;
    let dmask;
    let here;
    let op;
    let len;
    let dist;
    let from;
    let from_source;
    let input;
    let output;
    let state = strm.state;
    _in = strm.next_in;
    input = strm.input;
    last = _in + (strm.avail_in - 5);
    _out = strm.next_out;
    output = strm.output;
    beg = _out - (start - strm.avail_out);
    end = _out + (strm.avail_out - 257);
    wsize = state.wsize;
    whave = state.whave;
    wnext = state.wnext;
    s_window = state.window;
    hold = state.hold;
    bits = state.bits;
    lcode = state.lencode;
    dcode = state.distcode;
    lmask = (1 << state.lenbits) - 1;
    dmask = (1 << state.distbits) - 1;
    top:
      do {
        if (bits < 15) {
          hold += input[_in++] << bits;
          bits += 8;
          hold += input[_in++] << bits;
          bits += 8;
        }
        here = lcode[hold & lmask];
        dolen:
          for (; ; ) {
            op = here >>> 24;
            hold >>>= op;
            bits -= op;
            op = here >>> 16 & 255;
            if (op === 0) {
              output[_out++] = here & 65535;
            } else if (op & 16) {
              len = here & 65535;
              op &= 15;
              if (op) {
                if (bits < op) {
                  hold += input[_in++] << bits;
                  bits += 8;
                }
                len += hold & (1 << op) - 1;
                hold >>>= op;
                bits -= op;
              }
              if (bits < 15) {
                hold += input[_in++] << bits;
                bits += 8;
                hold += input[_in++] << bits;
                bits += 8;
              }
              here = dcode[hold & dmask];
              dodist:
                for (; ; ) {
                  op = here >>> 24;
                  hold >>>= op;
                  bits -= op;
                  op = here >>> 16 & 255;
                  if (op & 16) {
                    dist = here & 65535;
                    op &= 15;
                    if (bits < op) {
                      hold += input[_in++] << bits;
                      bits += 8;
                      if (bits < op) {
                        hold += input[_in++] << bits;
                        bits += 8;
                      }
                    }
                    dist += hold & (1 << op) - 1;
                    hold >>>= op;
                    bits -= op;
                    op = _out - beg;
                    if (dist > op) {
                      op = dist - op;
                      if (op > whave) {
                        if (state.sane) {
                          strm.msg = "invalid distance too far back";
                          state.mode = zlib_inffast.BAD;
                          break top;
                        }
                      }
                      from = 0;
                      from_source = s_window;
                      if (wnext === 0) {
                        from += wsize - op;
                        if (op < len) {
                          len -= op;
                          do {
                            output[_out++] = s_window[from++];
                          } while (--op);
                          from = _out - dist;
                          from_source = output;
                        }
                      } else if (wnext < op) {
                        from += wsize + wnext - op;
                        op -= wnext;
                        if (op < len) {
                          len -= op;
                          do {
                            output[_out++] = s_window[from++];
                          } while (--op);
                          from = 0;
                          if (wnext < len) {
                            op = wnext;
                            len -= op;
                            do {
                              output[_out++] = s_window[from++];
                            } while (--op);
                            from = _out - dist;
                            from_source = output;
                          }
                        }
                      } else {
                        from += wnext - op;
                        if (op < len) {
                          len -= op;
                          do {
                            output[_out++] = s_window[from++];
                          } while (--op);
                          from = _out - dist;
                          from_source = output;
                        }
                      }
                      while (len > 2) {
                        output[_out++] = from_source[from++];
                        output[_out++] = from_source[from++];
                        output[_out++] = from_source[from++];
                        len -= 3;
                      }
                      if (len) {
                        output[_out++] = from_source[from++];
                        if (len > 1) {
                          output[_out++] = from_source[from++];
                        }
                      }
                    } else {
                      from = _out - dist;
                      do {
                        output[_out++] = output[from++];
                        output[_out++] = output[from++];
                        output[_out++] = output[from++];
                        len -= 3;
                      } while (len > 2);
                      if (len) {
                        output[_out++] = output[from++];
                        if (len > 1) {
                          output[_out++] = output[from++];
                        }
                      }
                    }
                  } else if ((op & 64) === 0) {
                    here = dcode[(here & 65535) + (hold & (1 << op) - 1)];
                    continue dodist;
                  } else {
                    strm.msg = "invalid distance code";
                    state.mode = zlib_inffast.BAD;
                    break top;
                  }
                  break;
                }
            } else if ((op & 64) === 0) {
              here = lcode[(here & 65535) + (hold & (1 << op) - 1)];
              continue dolen;
            } else if (op & 32) {
              state.mode = zlib_inffast.TYPE;
              break top;
            } else {
              strm.msg = "invalid literal/length code";
              state.mode = zlib_inffast.BAD;
              break top;
            }
            break;
          }
      } while (_in < last && _out < end);
    len = bits >> 3;
    _in -= len;
    bits -= len << 3;
    hold &= (1 << bits) - 1;
    strm.next_in = _in;
    strm.next_out = _out;
    strm.avail_in = _in < last ? 5 + (last - _in) : 5 - (_in - last);
    strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);
    state.hold = hold;
    state.bits = bits;
    return;
  }
};
zlib_inffast.BAD = 30;
zlib_inffast.TYPE = 12;

// obj/full/Pako/zlib/inflate.js
"use strict";
var zlib_InflateState = class {
  constructor() {
    this.mode = 0;
    this.last = 0;
    this.wrap = 0;
    this.havedict = 0;
    this.flags = 0;
    this.dmax = 0;
    this.check = 0;
    this.total = 0;
    this.head = null;
    this.wbits = 0;
    this.wsize = 0;
    this.whave = 0;
    this.wnext = 0;
    this.window = null;
    this.hold = 0;
    this.bits = 0;
    this.length = 0;
    this.offset = 0;
    this.extra = 0;
    this.lencode = null;
    this.distcode = null;
    this.lenbits = 0;
    this.distbits = 0;
    this.ncode = 0;
    this.nlen = 0;
    this.ndist = 0;
    this.have = 0;
    this.next = null;
    this.lens = new Uint16Array(320);
    this.work = new Uint16Array(288);
    this.lendyn = null;
    this.distdyn = null;
    this.sane = 0;
    this.back = 0;
    this.was = 0;
  }
};
var zlib_inflate = class {
  static zswap32(q) {
    return (q >>> 24 & 255) + (q >>> 8 & 65280) + ((q & 65280) << 8) + ((q & 255) << 24);
  }
  static inflateResetKeep(strm) {
    if (!strm || !strm.state) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    let state = strm.state;
    strm.total_in = strm.total_out = state.total = 0;
    strm.msg = "";
    if (state.wrap) {
      strm.adler = state.wrap & 1;
    }
    state.mode = zlib_inflate.HEAD;
    state.last = 0;
    state.havedict = 0;
    state.dmax = 32768;
    state.head = null;
    state.hold = 0;
    state.bits = 0;
    state.lencode = state.lendyn = new Int32Array(zlib_inflate.ENOUGH_LENS);
    state.distcode = state.distdyn = new Int32Array(zlib_inflate.ENOUGH_DISTS);
    state.sane = 1;
    state.back = -1;
    return zlib_constants.Z_OK;
  }
  static inflateReset(strm) {
    if (!strm || !strm.state) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    const state = strm.state;
    state.wsize = 0;
    state.whave = 0;
    state.wnext = 0;
    return zlib_inflate.inflateResetKeep(strm);
  }
  static inflateReset2(strm, windowBits) {
    let wrap;
    if (!strm || !strm.state) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    let state = strm.state;
    if (windowBits < 0) {
      wrap = 0;
      windowBits = -windowBits;
    } else {
      wrap = (windowBits >> 4) + 1;
      if (windowBits < 48) {
        windowBits &= 15;
      }
    }
    if (windowBits && (windowBits < 8 || windowBits > 15)) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    if (state.window !== null && state.wbits !== windowBits) {
      state.window = null;
    }
    state.wrap = wrap;
    state.wbits = windowBits;
    return zlib_inflate.inflateReset(strm);
  }
  static inflateInit2(strm, windowBits) {
    if (!strm) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    let state = new zlib_InflateState();
    strm.state = state;
    state.window = null;
    const ret = zlib_inflate.inflateReset2(strm, windowBits);
    if (ret !== zlib_constants.Z_OK) {
      strm.state = null;
    }
    return ret;
  }
  static inflateInit(strm) {
    return zlib_inflate.inflateInit2(strm, zlib_inflate.DEF_WBITS);
  }
  static fixedtables(state) {
    if (zlib_inflate.virgin) {
      zlib_inflate.lenfix = new Int32Array(512);
      zlib_inflate.distfix = new Int32Array(32);
      let sym = 0;
      while (sym < 144) {
        state.lens[sym++] = 8;
      }
      while (sym < 256) {
        state.lens[sym++] = 9;
      }
      while (sym < 280) {
        state.lens[sym++] = 7;
      }
      while (sym < 288) {
        state.lens[sym++] = 8;
      }
      zlib_inftrees.inflate_table(zlib_inflate.LENS, state.lens, 0, 288, zlib_inflate.lenfix, 0, state.work, {bits: 9});
      sym = 0;
      while (sym < 32) {
        state.lens[sym++] = 5;
      }
      zlib_inftrees.inflate_table(zlib_inflate.DISTS, state.lens, 0, 32, zlib_inflate.distfix, 0, state.work, {bits: 5});
      zlib_inflate.virgin = false;
    }
    state.lencode = zlib_inflate.lenfix;
    state.lenbits = 9;
    state.distcode = zlib_inflate.distfix;
    state.distbits = 5;
  }
  static updatewindow(strm, src, end, copy) {
    let dist;
    const state = strm.state;
    if (state.window === null) {
      state.wsize = 1 << state.wbits;
      state.wnext = 0;
      state.whave = 0;
      state.window = new Uint8Array(state.wsize);
    }
    if (copy >= state.wsize) {
      state.window.set(src.subarray(end - state.wsize, end), 0);
      state.wnext = 0;
      state.whave = state.wsize;
    } else {
      dist = state.wsize - state.wnext;
      if (dist > copy) {
        dist = copy;
      }
      state.window.set(src.subarray(end - copy, end - copy + dist), state.wnext);
      copy -= dist;
      if (copy) {
        state.window.set(src.subarray(end - copy, end), 0);
        state.wnext = copy;
        state.whave = state.wsize;
      } else {
        state.wnext += dist;
        if (state.wnext === state.wsize) {
          state.wnext = 0;
        }
        if (state.whave < state.wsize) {
          state.whave += dist;
        }
      }
    }
    return 0;
  }
  static inflate(strm, flush) {
    let state;
    let input, output;
    let next;
    let put;
    let have, left;
    let hold;
    let bits;
    let _in;
    let _out;
    let copy;
    let from;
    let from_source;
    let here = 0;
    let here_bits;
    let here_op;
    let here_val;
    let last_bits;
    let last_op;
    let last_val;
    let len;
    let ret;
    const hbuf = new Uint8Array(4);
    let opts;
    let n;
    let order = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
    if (!strm || !strm.state || !strm.output || !strm.input && strm.avail_in !== 0) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    state = strm.state;
    if (state.mode === zlib_inflate.TYPE) {
      state.mode = zlib_inflate.TYPEDO;
    }
    put = strm.next_out;
    output = strm.output;
    left = strm.avail_out;
    next = strm.next_in;
    input = strm.input;
    have = strm.avail_in;
    hold = state.hold;
    bits = state.bits;
    _in = have;
    _out = left;
    ret = zlib_constants.Z_OK;
    inf_leave:
      for (; ; ) {
        switch (state.mode) {
          case zlib_inflate.HEAD:
            if (state.wrap === 0) {
              state.mode = zlib_inflate.TYPEDO;
              break;
            }
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (state.wrap & 2 && hold === 35615) {
              state.check = 0;
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              state.check = zlib_crc32.crc32(state.check, hbuf, 2, 0);
              hold = 0;
              bits = 0;
              state.mode = zlib_inflate.FLAGS;
              break;
            }
            state.flags = 0;
            if (state.head) {
              state.head.done = false;
            }
            if (!(state.wrap & 1) || (((hold & 255) << 8) + (hold >> 8)) % 31) {
              strm.msg = "incorrect header check";
              state.mode = zlib_inflate.BAD;
              break;
            }
            if ((hold & 15) !== zlib_constants.Z_DEFLATED) {
              strm.msg = "unknown compression method";
              state.mode = zlib_inflate.BAD;
              break;
            }
            hold >>>= 4;
            bits -= 4;
            len = (hold & 15) + 8;
            if (state.wbits === 0) {
              state.wbits = len;
            } else if (len > state.wbits) {
              strm.msg = "invalid window size";
              state.mode = zlib_inflate.BAD;
              break;
            }
            state.dmax = 1 << state.wbits;
            strm.adler = state.check = 1;
            state.mode = hold & 512 ? zlib_inflate.DICTID : zlib_inflate.TYPE;
            hold = 0;
            bits = 0;
            break;
          case zlib_inflate.FLAGS:
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.flags = hold;
            if ((state.flags & 255) !== zlib_constants.Z_DEFLATED) {
              strm.msg = "unknown compression method";
              state.mode = zlib_inflate.BAD;
              break;
            }
            if (state.flags & 57344) {
              strm.msg = "unknown header flags set";
              state.mode = zlib_inflate.BAD;
              break;
            }
            if (state.head) {
              state.head.text = hold >> 8 & 1;
            }
            if (state.flags & 512) {
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              state.check = zlib_crc32.crc32(state.check, hbuf, 2, 0);
            }
            hold = 0;
            bits = 0;
            state.mode = zlib_inflate.TIME;
          case zlib_inflate.TIME:
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (state.head) {
              state.head.time = hold;
            }
            if (state.flags & 512) {
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              hbuf[2] = hold >>> 16 & 255;
              hbuf[3] = hold >>> 24 & 255;
              state.check = zlib_crc32.crc32(state.check, hbuf, 4, 0);
            }
            hold = 0;
            bits = 0;
            state.mode = zlib_inflate.OS;
          case zlib_inflate.OS:
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (state.head) {
              state.head.xflags = hold & 255;
              state.head.os = hold >> 8;
            }
            if (state.flags & 512) {
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              state.check = zlib_crc32.crc32(state.check, hbuf, 2, 0);
            }
            hold = 0;
            bits = 0;
            state.mode = zlib_inflate.EXLEN;
          case zlib_inflate.EXLEN:
            if (state.flags & 1024) {
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.length = hold;
              if (state.head) {
                state.head.extra_len = hold;
              }
              if (state.flags & 512) {
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                state.check = zlib_crc32.crc32(state.check, hbuf, 2, 0);
              }
              hold = 0;
              bits = 0;
            } else if (state.head) {
              state.head.extra = null;
            }
            state.mode = zlib_inflate.EXTRA;
          case zlib_inflate.EXTRA:
            if (state.flags & 1024) {
              copy = state.length;
              if (copy > have) {
                copy = have;
              }
              if (copy) {
                if (state.head) {
                  len = state.head.extra_len - state.length;
                  if (!state.head.extra) {
                    state.head.extra = new Uint8Array(state.head.extra_len);
                  }
                  state.head.extra.set(input.subarray(next, next + copy), len);
                }
                if (state.flags & 512) {
                  state.check = zlib_crc32.crc32(state.check, input, copy, next);
                }
                have -= copy;
                next += copy;
                state.length -= copy;
              }
              if (state.length) {
                break inf_leave;
              }
            }
            state.length = 0;
            state.mode = zlib_inflate.NAME;
          case zlib_inflate.NAME:
            if (state.flags & 2048) {
              if (have === 0) {
                break inf_leave;
              }
              copy = 0;
              do {
                len = input[next + copy++];
                if (state.head && len && state.length < 65536) {
                  state.head.name += String.fromCharCode(len);
                }
              } while (len && copy < have);
              if (state.flags & 512) {
                state.check = zlib_crc32.crc32(state.check, input, copy, next);
              }
              have -= copy;
              next += copy;
              if (len) {
                break inf_leave;
              }
            } else if (state.head) {
              state.head.name = null;
            }
            state.length = 0;
            state.mode = zlib_inflate.COMMENT;
          case zlib_inflate.COMMENT:
            if (state.flags & 4096) {
              if (have === 0) {
                break inf_leave;
              }
              copy = 0;
              do {
                len = input[next + copy++];
                if (state.head && len && state.length < 65536) {
                  state.head.comment += String.fromCharCode(len);
                }
              } while (len && copy < have);
              if (state.flags & 512) {
                state.check = zlib_crc32.crc32(state.check, input, copy, next);
              }
              have -= copy;
              next += copy;
              if (len) {
                break inf_leave;
              }
            } else if (state.head) {
              state.head.comment = null;
            }
            state.mode = zlib_inflate.HCRC;
          case zlib_inflate.HCRC:
            if (state.flags & 512) {
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (hold !== (state.check & 65535)) {
                strm.msg = "header crc mismatch";
                state.mode = zlib_inflate.BAD;
                break;
              }
              hold = 0;
              bits = 0;
            }
            if (state.head) {
              state.head.hcrc = state.flags >> 9 & 1;
              state.head.done = true;
            }
            strm.adler = state.check = 0;
            state.mode = zlib_inflate.TYPE;
            break;
          case zlib_inflate.DICTID:
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            strm.adler = state.check = zlib_inflate.zswap32(hold);
            hold = 0;
            bits = 0;
            state.mode = zlib_inflate.DICT;
          case zlib_inflate.DICT:
            if (!state.havedict) {
              strm.next_out = put;
              strm.avail_out = left;
              strm.next_in = next;
              strm.avail_in = have;
              state.hold = hold;
              state.bits = bits;
              return zlib_constants.Z_NEED_DICT;
            }
            strm.adler = state.check = 1;
            state.mode = zlib_inflate.TYPE;
          case zlib_inflate.TYPE:
            if (flush === zlib_constants.Z_BLOCK || flush === zlib_constants.Z_TREES) {
              break inf_leave;
            }
          case zlib_inflate.TYPEDO:
            if (state.last) {
              hold >>>= bits & 7;
              bits -= bits & 7;
              state.mode = zlib_inflate.CHECK;
              break;
            }
            while (bits < 3) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.last = hold & 1;
            hold >>>= 1;
            bits -= 1;
            switch (hold & 3) {
              case 0:
                state.mode = zlib_inflate.STORED;
                break;
              case 1:
                zlib_inflate.fixedtables(state);
                state.mode = zlib_inflate.LEN_;
                if (flush === zlib_constants.Z_TREES) {
                  hold >>>= 2;
                  bits -= 2;
                  break inf_leave;
                }
                break;
              case 2:
                state.mode = zlib_inflate.TABLE;
                break;
              case 3:
                strm.msg = "invalid block type";
                state.mode = zlib_inflate.BAD;
            }
            hold >>>= 2;
            bits -= 2;
            break;
          case zlib_inflate.STORED:
            hold >>>= bits & 7;
            bits -= bits & 7;
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if ((hold & 65535) !== (hold >>> 16 ^ 65535)) {
              strm.msg = "invalid stored block lengths";
              state.mode = zlib_inflate.BAD;
              break;
            }
            state.length = hold & 65535;
            hold = 0;
            bits = 0;
            state.mode = zlib_inflate.COPY_;
            if (flush === zlib_constants.Z_TREES) {
              break inf_leave;
            }
          case zlib_inflate.COPY_:
            state.mode = zlib_inflate.COPY;
          case zlib_inflate.COPY:
            copy = state.length;
            if (copy) {
              if (copy > have) {
                copy = have;
              }
              if (copy > left) {
                copy = left;
              }
              if (copy === 0) {
                break inf_leave;
              }
              output.set(input.subarray(next, next + copy), put);
              have -= copy;
              next += copy;
              left -= copy;
              put += copy;
              state.length -= copy;
              break;
            }
            state.mode = zlib_inflate.TYPE;
            break;
          case zlib_inflate.TABLE:
            while (bits < 14) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.nlen = (hold & 31) + 257;
            hold >>>= 5;
            bits -= 5;
            state.ndist = (hold & 31) + 1;
            hold >>>= 5;
            bits -= 5;
            state.ncode = (hold & 15) + 4;
            hold >>>= 4;
            bits -= 4;
            if (state.nlen > 286 || state.ndist > 30) {
              strm.msg = "too many length or distance symbols";
              state.mode = zlib_inflate.BAD;
              break;
            }
            state.have = 0;
            state.mode = zlib_inflate.LENLENS;
          case zlib_inflate.LENLENS:
            while (state.have < state.ncode) {
              while (bits < 3) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.lens[order[state.have++]] = hold & 7;
              hold >>>= 3;
              bits -= 3;
            }
            while (state.have < 19) {
              state.lens[order[state.have++]] = 0;
            }
            state.lencode = state.lendyn;
            state.lenbits = 7;
            opts = {bits: state.lenbits};
            ret = zlib_inftrees.inflate_table(zlib_inflate.CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
            state.lenbits = opts.bits;
            if (ret) {
              strm.msg = "invalid code lengths set";
              state.mode = zlib_inflate.BAD;
              break;
            }
            state.have = 0;
            state.mode = zlib_inflate.CODELENS;
          case zlib_inflate.CODELENS:
            while (state.have < state.nlen + state.ndist) {
              for (; ; ) {
                here = state.lencode[hold & (1 << state.lenbits) - 1];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (here_val < 16) {
                hold >>>= here_bits;
                bits -= here_bits;
                state.lens[state.have++] = here_val;
              } else {
                if (here_val === 16) {
                  n = here_bits + 2;
                  while (bits < n) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  hold >>>= here_bits;
                  bits -= here_bits;
                  if (state.have === 0) {
                    strm.msg = "invalid bit length repeat";
                    state.mode = zlib_inflate.BAD;
                    break;
                  }
                  len = state.lens[state.have - 1];
                  copy = 3 + (hold & 3);
                  hold >>>= 2;
                  bits -= 2;
                } else if (here_val === 17) {
                  n = here_bits + 3;
                  while (bits < n) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  hold >>>= here_bits;
                  bits -= here_bits;
                  len = 0;
                  copy = 3 + (hold & 7);
                  hold >>>= 3;
                  bits -= 3;
                } else {
                  n = here_bits + 7;
                  while (bits < n) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  hold >>>= here_bits;
                  bits -= here_bits;
                  len = 0;
                  copy = 11 + (hold & 127);
                  hold >>>= 7;
                  bits -= 7;
                }
                if (state.have + copy > state.nlen + state.ndist) {
                  strm.msg = "invalid bit length repeat";
                  state.mode = zlib_inflate.BAD;
                  break;
                }
                while (copy--) {
                  state.lens[state.have++] = len;
                }
              }
            }
            if (state.mode === zlib_inflate.BAD) {
              break;
            }
            if (state.lens[256] === 0) {
              strm.msg = "invalid code -- missing end-of-block";
              state.mode = zlib_inflate.BAD;
              break;
            }
            state.lenbits = 9;
            opts = {bits: state.lenbits};
            ret = zlib_inftrees.inflate_table(zlib_inflate.LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
            state.lenbits = opts.bits;
            if (ret) {
              strm.msg = "invalid literal/lengths set";
              state.mode = zlib_inflate.BAD;
              break;
            }
            state.distbits = 6;
            state.distcode = state.distdyn;
            opts = {bits: state.distbits};
            ret = zlib_inftrees.inflate_table(zlib_inflate.DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
            state.distbits = opts.bits;
            if (ret) {
              strm.msg = "invalid distances set";
              state.mode = zlib_inflate.BAD;
              break;
            }
            state.mode = zlib_inflate.LEN_;
            if (flush === zlib_constants.Z_TREES) {
              break inf_leave;
            }
          case zlib_inflate.LEN_:
            state.mode = zlib_inflate.LEN;
          case zlib_inflate.LEN:
            if (have >= 6 && left >= 258) {
              strm.next_out = put;
              strm.avail_out = left;
              strm.next_in = next;
              strm.avail_in = have;
              state.hold = hold;
              state.bits = bits;
              zlib_inffast.inflate_fast(strm, _out);
              put = strm.next_out;
              output = strm.output;
              left = strm.avail_out;
              next = strm.next_in;
              input = strm.input;
              have = strm.avail_in;
              hold = state.hold;
              bits = state.bits;
              if (state.mode === zlib_inflate.TYPE) {
                state.back = -1;
              }
              break;
            }
            state.back = 0;
            for (; ; ) {
              here = state.lencode[hold & (1 << state.lenbits) - 1];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (here_op && (here_op & 240) === 0) {
              last_bits = here_bits;
              last_op = here_op;
              last_val = here_val;
              for (; ; ) {
                here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (last_bits + here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              hold >>>= last_bits;
              bits -= last_bits;
              state.back += last_bits;
            }
            hold >>>= here_bits;
            bits -= here_bits;
            state.back += here_bits;
            state.length = here_val;
            if (here_op === 0) {
              state.mode = zlib_inflate.LIT;
              break;
            }
            if (here_op & 32) {
              state.back = -1;
              state.mode = zlib_inflate.TYPE;
              break;
            }
            if (here_op & 64) {
              strm.msg = "invalid literal/length code";
              state.mode = zlib_inflate.BAD;
              break;
            }
            state.extra = here_op & 15;
            state.mode = zlib_inflate.LENEXT;
          case zlib_inflate.LENEXT:
            if (state.extra) {
              n = state.extra;
              while (bits < n) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.length += hold & (1 << state.extra) - 1;
              hold >>>= state.extra;
              bits -= state.extra;
              state.back += state.extra;
            }
            state.was = state.length;
            state.mode = zlib_inflate.DIST;
          case zlib_inflate.DIST:
            for (; ; ) {
              here = state.distcode[hold & (1 << state.distbits) - 1];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if ((here_op & 240) === 0) {
              last_bits = here_bits;
              last_op = here_op;
              last_val = here_val;
              for (; ; ) {
                here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (last_bits + here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              hold >>>= last_bits;
              bits -= last_bits;
              state.back += last_bits;
            }
            hold >>>= here_bits;
            bits -= here_bits;
            state.back += here_bits;
            if (here_op & 64) {
              strm.msg = "invalid distance code";
              state.mode = zlib_inflate.BAD;
              break;
            }
            state.offset = here_val;
            state.extra = here_op & 15;
            state.mode = zlib_inflate.DISTEXT;
          case zlib_inflate.DISTEXT:
            if (state.extra) {
              n = state.extra;
              while (bits < n) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.offset += hold & (1 << state.extra) - 1;
              hold >>>= state.extra;
              bits -= state.extra;
              state.back += state.extra;
            }
            state.mode = zlib_inflate.MATCH;
          case zlib_inflate.MATCH:
            if (left === 0) {
              break inf_leave;
            }
            copy = _out - left;
            if (state.offset > copy) {
              copy = state.offset - copy;
              if (copy > state.whave) {
                if (state.sane) {
                  strm.msg = "invalid distance too far back";
                  state.mode = zlib_inflate.BAD;
                  break;
                }
              }
              if (copy > state.wnext) {
                copy -= state.wnext;
                from = state.wsize - copy;
              } else {
                from = state.wnext - copy;
              }
              if (copy > state.length) {
                copy = state.length;
              }
              from_source = state.window;
            } else {
              from_source = output;
              from = put - state.offset;
              copy = state.length;
            }
            if (copy > left) {
              copy = left;
            }
            left -= copy;
            state.length -= copy;
            do {
              output[put++] = from_source[from++];
            } while (--copy);
            if (state.length === 0) {
              state.mode = zlib_inflate.LEN;
            }
            break;
          case zlib_inflate.LIT:
            if (left === 0) {
              break inf_leave;
            }
            output[put++] = state.length;
            left--;
            state.mode = zlib_inflate.LEN;
            break;
          case zlib_inflate.CHECK:
            if (state.wrap) {
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold |= input[next++] << bits;
                bits += 8;
              }
              _out -= left;
              strm.total_out += _out;
              state.total += _out;
              if (_out) {
                strm.adler = state.check = state.flags ? zlib_crc32.crc32(state.check, output, _out, put - _out) : zlib_adler32.adler32(state.check, output, _out, put - _out);
              }
              _out = left;
              if ((state.flags ? hold : zlib_inflate.zswap32(hold)) !== state.check) {
                strm.msg = "incorrect data check";
                state.mode = zlib_inflate.BAD;
                break;
              }
              hold = 0;
              bits = 0;
            }
            state.mode = zlib_inflate.LENGTH;
          case zlib_inflate.LENGTH:
            if (state.wrap && state.flags) {
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (hold !== (state.total & 4294967295)) {
                strm.msg = "incorrect length check";
                state.mode = zlib_inflate.BAD;
                break;
              }
              hold = 0;
              bits = 0;
            }
            state.mode = zlib_inflate.DONE;
          case zlib_inflate.DONE:
            ret = zlib_constants.Z_STREAM_END;
            break inf_leave;
          case zlib_inflate.BAD:
            ret = zlib_constants.Z_DATA_ERROR;
            break inf_leave;
          case zlib_inflate.MEM:
            return zlib_constants.Z_MEM_ERROR;
          case zlib_inflate.SYNC:
          default:
            return zlib_constants.Z_STREAM_ERROR;
        }
      }
    strm.next_out = put;
    strm.avail_out = left;
    strm.next_in = next;
    strm.avail_in = have;
    state.hold = hold;
    state.bits = bits;
    if (state.wsize || _out !== strm.avail_out && state.mode < zlib_inflate.BAD && (state.mode < zlib_inflate.CHECK || flush !== zlib_constants.Z_FINISH)) {
      if (zlib_inflate.updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) {
        state.mode = zlib_inflate.MEM;
        return zlib_constants.Z_MEM_ERROR;
      }
    }
    _in -= strm.avail_in;
    _out -= strm.avail_out;
    strm.total_in += _in;
    strm.total_out += _out;
    state.total += _out;
    if (state.wrap && _out) {
      strm.adler = state.check = state.flags ? zlib_crc32.crc32(state.check, output, _out, strm.next_out - _out) : zlib_adler32.adler32(state.check, output, _out, strm.next_out - _out);
    }
    strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === zlib_inflate.TYPE ? 128 : 0) + (state.mode === zlib_inflate.LEN_ || state.mode === zlib_inflate.COPY_ ? 256 : 0);
    if ((_in === 0 && _out === 0 || flush === zlib_constants.Z_FINISH) && ret === zlib_constants.Z_OK) {
      ret = zlib_constants.Z_BUF_ERROR;
    }
    return ret;
  }
  static inflateEnd(strm) {
    if (!strm || !strm.state) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    let state = strm.state;
    if (state.window) {
      state.window = null;
    }
    strm.state = null;
    return zlib_constants.Z_OK;
  }
  static inflateGetHeader(strm, head) {
    if (!strm || !strm.state) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    let state = strm.state;
    if ((state.wrap & 2) === 0) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    state.head = head;
    head.done = false;
    return zlib_constants.Z_OK;
  }
  static inflateSetDictionary(strm, dictionary) {
    const dictLength = dictionary.length;
    let state;
    let dictid;
    let ret;
    if (!strm || !strm.state) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    state = strm.state;
    if (state.wrap !== 0 && state.mode !== zlib_inflate.DICT) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    if (state.mode === zlib_inflate.DICT) {
      dictid = 1;
      dictid = zlib_adler32.adler32(dictid, dictionary, dictLength, 0);
      if (dictid !== state.check) {
        return zlib_constants.Z_DATA_ERROR;
      }
    }
    ret = zlib_inflate.updatewindow(strm, dictionary, dictLength, dictLength);
    if (ret) {
      state.mode = zlib_inflate.MEM;
      return zlib_constants.Z_MEM_ERROR;
    }
    state.havedict = 1;
    return zlib_constants.Z_OK;
  }
};
zlib_inflate.CODES = 0;
zlib_inflate.LENS = 1;
zlib_inflate.DISTS = 2;
zlib_inflate.HEAD = 1;
zlib_inflate.FLAGS = 2;
zlib_inflate.TIME = 3;
zlib_inflate.OS = 4;
zlib_inflate.EXLEN = 5;
zlib_inflate.EXTRA = 6;
zlib_inflate.NAME = 7;
zlib_inflate.COMMENT = 8;
zlib_inflate.HCRC = 9;
zlib_inflate.DICTID = 10;
zlib_inflate.DICT = 11;
zlib_inflate.TYPE = 12;
zlib_inflate.TYPEDO = 13;
zlib_inflate.STORED = 14;
zlib_inflate.COPY_ = 15;
zlib_inflate.COPY = 16;
zlib_inflate.TABLE = 17;
zlib_inflate.LENLENS = 18;
zlib_inflate.CODELENS = 19;
zlib_inflate.LEN_ = 20;
zlib_inflate.LEN = 21;
zlib_inflate.LENEXT = 22;
zlib_inflate.DIST = 23;
zlib_inflate.DISTEXT = 24;
zlib_inflate.MATCH = 25;
zlib_inflate.LIT = 26;
zlib_inflate.CHECK = 27;
zlib_inflate.LENGTH = 28;
zlib_inflate.DONE = 29;
zlib_inflate.BAD = 30;
zlib_inflate.MEM = 31;
zlib_inflate.SYNC = 32;
zlib_inflate.ENOUGH_LENS = 852;
zlib_inflate.ENOUGH_DISTS = 592;
zlib_inflate.MAX_WBITS = 15;
zlib_inflate.DEF_WBITS = zlib_inflate.MAX_WBITS;
zlib_inflate.virgin = true;

// obj/full/Pako/zlib/messages.js
"use strict";
var zlib_messages = class {
  static msg(index) {
    switch (index) {
      case 2:
        return "need dictionary";
      case 1:
        return "stream end";
      case 0:
        return "";
      case -1:
        return "file error";
      case -2:
        return "stream error";
      case -3:
        return "data error";
      case -4:
        return "insufficient memory";
      case -5:
        return "buffer error";
      case -6:
        return "incompatible version";
      default:
        return "unknowwn error";
    }
  }
};

// obj/full/Pako/zlib/inftrees.js
"use strict";
var zlib_inftrees = class {
  static inflate_table(type, lens, lens_index, codes, table, table_index, work, opts) {
    const bits = opts.bits;
    let len;
    let sym;
    let min = 0;
    let max;
    let root;
    let curr = 0;
    let drop = 0;
    let left = 0;
    let used = 0;
    let huff = 0;
    let incr;
    let fill;
    let low;
    let mask;
    let next;
    let base;
    let base_index = 0;
    let end;
    const count = new Uint16Array(zlib_inftrees.MAXBITS + 1);
    const offs = new Uint16Array(zlib_inftrees.MAXBITS + 1);
    let extra;
    let extra_index = 0;
    let here_bits;
    let here_op;
    let here_val;
    for (len = 0; len <= zlib_inftrees.MAXBITS; len++) {
      count[len] = 0;
    }
    for (sym = 0; sym < codes; sym++) {
      count[lens[lens_index + sym]]++;
    }
    root = bits;
    for (max = zlib_inftrees.MAXBITS; max >= 1; max--) {
      if (count[max] !== 0) {
        break;
      }
    }
    if (root > max) {
      root = max;
    }
    if (max === 0) {
      table[table_index++] = 1 << 24 | 64 << 16 | 0;
      table[table_index++] = 1 << 24 | 64 << 16 | 0;
      opts.bits = 1;
      return 0;
    }
    for (min = 1; min < max; min++) {
      if (count[min] !== 0) {
        break;
      }
    }
    if (root < min) {
      root = min;
    }
    left = 1;
    for (len = 1; len <= zlib_inftrees.MAXBITS; len++) {
      left <<= 1;
      left -= count[len];
      if (left < 0) {
        return -1;
      }
    }
    if (left > 0 && (type === zlib_inftrees.CODES || max !== 1)) {
      return -1;
    }
    offs[1] = 0;
    for (len = 1; len < zlib_inftrees.MAXBITS; len++) {
      offs[len + 1] = offs[len] + count[len];
    }
    for (sym = 0; sym < codes; sym++) {
      if (lens[lens_index + sym] !== 0) {
        work[offs[lens[lens_index + sym]]++] = sym;
      }
    }
    if (type === zlib_inftrees.CODES) {
      base = work;
      extra = new Uint8Array();
      end = 19;
    } else if (type === zlib_inftrees.LENS) {
      base = zlib_inftrees.lbase;
      base_index -= 257;
      extra = zlib_inftrees.lext;
      extra_index -= 257;
      end = 256;
    } else {
      base = zlib_inftrees.dbase;
      extra = zlib_inftrees.dext;
      end = -1;
    }
    huff = 0;
    sym = 0;
    len = min;
    next = table_index;
    curr = root;
    drop = 0;
    low = -1;
    used = 1 << root;
    mask = used - 1;
    if (type === zlib_inftrees.LENS && used > zlib_inftrees.ENOUGH_LENS || type === zlib_inftrees.DISTS && used > zlib_inftrees.ENOUGH_DISTS) {
      return 1;
    }
    for (; ; ) {
      here_bits = len - drop;
      if (work[sym] < end) {
        here_op = 0;
        here_val = work[sym];
      } else if (work[sym] > end) {
        here_op = extra[extra_index + work[sym]];
        here_val = base[base_index + work[sym]];
      } else {
        here_op = 32 + 64;
        here_val = 0;
      }
      incr = 1 << len - drop;
      fill = 1 << curr;
      min = fill;
      do {
        fill -= incr;
        table[next + (huff >> drop) + fill] = here_bits << 24 | here_op << 16 | here_val | 0;
      } while (fill !== 0);
      incr = 1 << len - 1;
      while (huff & incr) {
        incr >>= 1;
      }
      if (incr !== 0) {
        huff &= incr - 1;
        huff += incr;
      } else {
        huff = 0;
      }
      sym++;
      if (--count[len] === 0) {
        if (len === max) {
          break;
        }
        len = lens[lens_index + work[sym]];
      }
      if (len > root && (huff & mask) !== low) {
        if (drop === 0) {
          drop = root;
        }
        next += min;
        curr = len - drop;
        left = 1 << curr;
        while (curr + drop < max) {
          left -= count[curr + drop];
          if (left <= 0) {
            break;
          }
          curr++;
          left <<= 1;
        }
        used += 1 << curr;
        if (type === zlib_inftrees.LENS && used > zlib_inftrees.ENOUGH_LENS || type === zlib_inftrees.DISTS && used > zlib_inftrees.ENOUGH_DISTS) {
          return 1;
        }
        low = huff & mask;
        table[low] = root << 24 | curr << 16 | next - table_index | 0;
      }
    }
    if (huff !== 0) {
      table[next + huff] = len - drop << 24 | 64 << 16 | 0;
    }
    opts.bits = root;
    return 0;
  }
};
zlib_inftrees.MAXBITS = 15;
zlib_inftrees.ENOUGH_LENS = 852;
zlib_inftrees.ENOUGH_DISTS = 592;
zlib_inftrees.CODES = 0;
zlib_inftrees.LENS = 1;
zlib_inftrees.DISTS = 2;
zlib_inftrees.lbase = new Uint16Array([
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  13,
  15,
  17,
  19,
  23,
  27,
  31,
  35,
  43,
  51,
  59,
  67,
  83,
  99,
  115,
  131,
  163,
  195,
  227,
  258,
  0,
  0
]);
zlib_inftrees.lext = new Uint8Array([
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  17,
  17,
  17,
  17,
  18,
  18,
  18,
  18,
  19,
  19,
  19,
  19,
  20,
  20,
  20,
  20,
  21,
  21,
  21,
  21,
  16,
  72,
  78
]);
zlib_inftrees.dbase = new Uint16Array([
  1,
  2,
  3,
  4,
  5,
  7,
  9,
  13,
  17,
  25,
  33,
  49,
  65,
  97,
  129,
  193,
  257,
  385,
  513,
  769,
  1025,
  1537,
  2049,
  3073,
  4097,
  6145,
  8193,
  12289,
  16385,
  24577,
  0,
  0
]);
zlib_inftrees.dext = new Uint8Array([
  16,
  16,
  16,
  16,
  17,
  17,
  18,
  18,
  19,
  19,
  20,
  20,
  21,
  21,
  22,
  22,
  23,
  23,
  24,
  24,
  25,
  25,
  26,
  26,
  27,
  27,
  28,
  28,
  29,
  29,
  64,
  64
]);

// obj/full/Pako/zlib/zstream.js
"use strict";
var zlib_ZStream = class {
  constructor() {
    this.input = null;
    this.next_in = 0;
    this.avail_in = 0;
    this.total_in = 0;
    this.output = null;
    this.next_out = 0;
    this.avail_out = 0;
    this.total_out = 0;
    this.msg = "";
    this.state = null;
    this.data_type = 2;
    this.adler = 0;
  }
};

// obj/full/webPage.js
var YWebPage = class {
  edit(widgetIndex) {
    YWebPage.widgets[widgetIndex].edit();
  }
  static get editMenuItem() {
    return YWebPage._editMenuItem;
  }
  static get deleteMenuItem() {
    return YWebPage._deleteMenuItem;
  }
  static get disableMarkerMenuItem() {
    return YWebPage._disableMarkerMenuItem;
  }
  static get clearDataloggerMenuItem() {
    return YWebPage._clearDataloggerMenuItem;
  }
  static get addMarkerMenuItem() {
    return YWebPage._addMarkerMenuItem;
  }
  static get markersSubMenuItems() {
    return YWebPage._markersSubMenuItems;
  }
  static get contextMarkerSubMenu() {
    return YWebPage._contextMarkerSubMenu;
  }
  static get contextWidgetsSubMenu() {
    return YWebPage._contextWidgetsSubMenu;
  }
  static get resetDataViewMenuItem() {
    return YWebPage._resetDataViewMenuItem;
  }
  static get snapshotMenuItem() {
    return YWebPage._snapshotMenuItem;
  }
  static applicationGlobalinit() {
    if (YWebPage._MarkerCountPerXaxis == 0) {
      let xAxisProp = new XaxisDescription();
      let propDesc = GenericProperties.getAllProperties(xAxisProp);
      for (let propname in propDesc.byName) {
        if (propname.startsWith("markers"))
          YWebPage._MarkerCountPerXaxis++;
      }
    }
    if (YWebPage.manager == null)
      YWebPage.manager = new sensorsManager();
    if (!YWebPage.readonly && YWebPage._editor == null)
      YWebPage._editor = new PropertiesForm2();
    if (!YWebPage.readonly && YWebPage._mainform == null)
      YWebPage._mainform = new mainForm();
    if (YWebPage._contextMenu == null) {
      YWebPage._contextMenu = new ContextMenu(YWebPage.baseSize, (mouseX, mouseY) => {
        YWebPage.menuIsOpening(mouseX, mouseY);
      }, constants.generalFontFamily);
      YWebPage._contextMarkerSubMenu = new ContextSubMenu(YWebPage.baseSize, YWebPage._contextMenu, null, constants.generalFontFamily);
      for (let i = 0; i < YWebPage._MarkerCountPerXaxis; i++) {
        YWebPage._markersSubMenuItems.push(YWebPage._contextMarkerSubMenu.addMenuItem(ressources.AddMarkerIcon(YWebPage.baseSize.toString(), i + 1), "Place marker " + (i + 1).toString(), () => {
          let target = YWebPage._markersSubMenuItems[i].userdata;
          target.startMarkerCapture(i);
        }));
      }
      if (!YWebPage.readonly) {
        YWebPage._contextWidgetsSubMenu = new ContextSubMenu(YWebPage.baseSize, YWebPage._contextMenu, (mouseX, mouseY) => {
          YWebPage.WidgetsSubMenuIsOpening(mouseX, mouseY);
        }, constants.generalFontFamily);
        YWebPage._widgetsMenuItem = YWebPage._contextMenu.addSubMenuItem(ressources.AllIcon(YWebPage.baseSize.toString(), false, false, false, false), "All widgets", YWebPage._contextWidgetsSubMenu);
        YWebPage._editMenuItem = YWebPage._contextMenu.addMenuItem(ressources.EditIcon(YWebPage.baseSize.toString(), false, false, false, false), "Configure this widget", () => {
          YWebPage.editWidget();
        });
        YWebPage._deleteMenuItem = YWebPage._contextMenu.addMenuItem(ressources.TrashIcon(YWebPage.baseSize.toString(), false, false, false, false), "Delete this widget", () => {
          YWebPage.deleteWidget();
        });
        YWebPage._editMenuItem.visible = false;
        YWebPage._deleteMenuItem.visible = false;
      }
      YWebPage._resetDataViewMenuItem = YWebPage._contextMenu.addMenuItem(ressources.resetViewPort(YWebPage.baseSize.toString(), false, false, false, false), "Reset dataview", () => {
        YWebPage.resetDataView();
      });
      YWebPage._resetDataViewMenuItem.visible = false;
      if (!YWebPage.readonly) {
        YWebPage._clearDataloggerMenuItem = YWebPage._contextMenu.addMenuItem(ressources.EraseDatalogger(YWebPage.baseSize.toString(), false, false, false, false), "Clear datalogger", () => {
          YWebPage.clearDatalogger();
        });
        YWebPage._resetDataViewMenuItem.visible = false;
      }
      YWebPage._contextMenu.AddSeparator();
      if (!YWebPage.readonly) {
        YWebPage._addMarkerMenuItem = YWebPage._contextMenu.addSubMenuItem(ressources.AddMarker(YWebPage.baseSize.toString(), false, true, true, false), "Place markers", YWebPage._contextMarkerSubMenu);
        YWebPage._disableMarkerMenuItem = YWebPage._contextMenu.addMenuItem(ressources.DeleteMarker(YWebPage.baseSize.toString(), false, true, false, true), "Disable Allmarkers", () => {
          YWebPage.disableAllMarker();
        });
        YWebPage._addMarkerMenuItem.visible = false;
        YWebPage._disableMarkerMenuItem.visible = false;
        YWebPage._contextMenu.AddSeparator();
        YWebPage._contextMenu.addMenuItem(ressources.SolidGaugeIcon(YWebPage.baseSize.toString(), false, true, true, false), "Add a new Solid gauge", () => {
          YWebPage.newGaugeWidget();
        });
        YWebPage._contextMenu.addMenuItem(ressources.AngularGaugeIcon(YWebPage.baseSize.toString(), false, true, true, false), "Add a new Angular gauge", () => {
          YWebPage.newAngularGaugeWidget();
        });
        YWebPage._contextMenu.addMenuItem(ressources.DigitalDisplayIcon(YWebPage.baseSize.toString(), false, true, true, false), "Add a new Digital Display", () => {
          YWebPage.newDigitalDisplayWidget();
        });
        YWebPage._contextMenu.addMenuItem(ressources.GraphIcon(YWebPage.baseSize.toString(), false, true, true, false), "Add a new Graph", () => {
          YWebPage.newGraphWidget();
        });
      }
      YWebPage._contextMenu.addMenuItem(ressources.RawDataIcon(YWebPage.baseSize.toString(), false, false, false, false), "Show raw data", () => {
        rawDataForm.show();
      });
      YWebPage._snapshotMenuItem = YWebPage._contextMenu.addMenuItem(ressources.snapshotIcon(YWebPage.baseSize.toString(), false, false, false, false), "Snapshot", () => {
        YWebPage.snapShot();
      });
      if (!YWebPage.readonly) {
        YWebPage._contextMenu.AddSeparator();
        YWebPage._contextMenu.addMenuItem(ressources.ConfigureIcon(YWebPage.baseSize.toString(), false, false, false, false), "Global configuration", () => {
          configForm.show();
        });
        YWebPage._contextMenu.addMenuItem(ressources.SaveIcon(YWebPage.baseSize.toString(), false, false, false, false), "Save now", () => {
          YWebPage.save(true);
        });
      }
      YWebPage._contextMenu.addMenuItem(ressources.LogFileIcon(YWebPage.baseSize.toString(), false, false, false, false), "Show logs", () => {
        YWebPage.showLogsWindow();
      });
    }
  }
  static RegisterDeviceArrivalCallback(arrivalCallback) {
    sensorsManager.RegisterDeviceArrivalCallback(arrivalCallback);
  }
  static RegisterDeviceRemovalCallback(removalCallback) {
    sensorsManager.RegisterDeviceRemovalCallback(removalCallback);
  }
  static WidgetsSubMenuIsOpening(mouseX, mouseY) {
    YWebPage._contextWidgetsSubMenu.clearAllContents();
    for (let i = 0; i < YWebPage.widgets.length; i++) {
      let icon = "";
      let subMenu = new ContextSubMenu(YWebPage.baseSize, YWebPage._contextWidgetsSubMenu, (mouseX2, mouseY2) => {
        YWebPage.specificWidgetSubMenuIsOpening(subMenu, mouseX2, mouseY2);
      }, constants.generalFontFamily);
      subMenu.userdata = YWebPage.widgets[i];
      if (YWebPage.widgets[i] instanceof graphWidget)
        icon = ressources.GraphIcon(YWebPage.baseSize.toString(), false, false, false, false);
      if (YWebPage.widgets[i] instanceof digitalDisplayWidget)
        icon = ressources.DigitalDisplayIcon(YWebPage.baseSize.toString(), false, false, false, false);
      if (YWebPage.widgets[i] instanceof gaugeWidget)
        icon = ressources.SolidGaugeIcon(YWebPage.baseSize.toString(), false, false, false, false);
      if (YWebPage.widgets[i] instanceof angularGaugeWidget)
        icon = ressources.AngularGaugeIcon(YWebPage.baseSize.toString(), false, false, false, false);
      YWebPage._contextWidgetsSubMenu.addSubMenuItem(icon, YWebPage.widgets[i].Text, subMenu);
    }
  }
  static specificWidgetSubMenuIsOpening(source, mouseX, mouseY) {
    if (source.menuItemsCount > 0)
      return;
    let w = source.userdata;
    source.addMenuItem(ressources.EditIcon(YWebPage.baseSize.toString(), false, false, false, false), "Configure", () => {
      w.edit();
    });
    source.addMenuItem(ressources.TrashIcon(YWebPage.baseSize.toString(), false, false, false, false), "Delete", () => {
      YWebPage.deleteWidget(w);
    });
    if (w instanceof graphWidget) {
      source.addMenuItem(ressources.resetViewPort(YWebPage.baseSize.toString(), false, false, false, false), "Reset dataview", () => {
        w.resetDataView();
      });
      source.addMenuItem(ressources.EraseDatalogger(YWebPage.baseSize.toString(), false, false, false, false), "Clear datalogger", () => {
        w.clearDataLogger();
      });
    }
  }
  static showLogsWindow() {
    logForm.show();
  }
  static snapShot() {
    let w = YWebPage._snapshotMenuItem.userdata;
    w.snapshot();
  }
  static menuIsOpening(mouseX, mouseY) {
    if (YWebPage.disableMarkerMenuItem != null)
      YWebPage.disableMarkerMenuItem.visible = false;
    if (YWebPage.addMarkerMenuItem != null)
      YWebPage.addMarkerMenuItem.visible = false;
    if (YWebPage.clearDataloggerMenuItem != null)
      YWebPage.clearDataloggerMenuItem.visible = false;
    if (YWebPage.editMenuItem != null)
      YWebPage.editMenuItem.visible = false;
    if (YWebPage.deleteMenuItem != null)
      YWebPage.deleteMenuItem.visible = false;
    YWebPage.resetDataViewMenuItem.visible = false;
    YWebPage.snapshotMenuItem.visible = false;
    for (let i = 0; i < YWebPage.widgets.length; i++) {
      YWebPage.widgets[i].contextMenuCallBack(mouseX, mouseY);
    }
    YWebPage._widgetsMenuItem.visible = !YWebPage.readonly && YWebPage.widgets.length > 0 && !YWebPage._editMenuItem.visible;
    YWebPage._contextMenu.refresh();
  }
  static resetDataView() {
    YWebPage._resetDataViewMenuItem.userdata.resetDataView();
  }
  static editWidget() {
    let w = YWebPage._editMenuItem.userdata;
    w.edit();
  }
  static disableAllMarker() {
    YWebPage._disableMarkerMenuItem.userdata.disableAllMarkers();
  }
  static clearDatalogger() {
    YWebPage._clearDataloggerMenuItem.userdata.clearDataLogger();
  }
  static deleteWidget(widget) {
    let w = typeof widget == "undefined" ? YWebPage._deleteMenuItem.userdata : widget;
    confirm.ask(w.confirmDeleteString, () => {
      if (!YWebPage.readonly && w.isBeingEdited && YWebPage._editor != null)
        YWebPage._editor.hide();
      w.delete();
      constants.edited = true;
      for (let i = YWebPage.widgets.length - 1; i >= 0; i--) {
        if (YWebPage.widgets[i] == w) {
          YWebPage.widgets.splice(i, 1);
        }
      }
      if (YWebPage.widgets.length <= 0 && YWebPage._mainform != null)
        YWebPage._mainform.show();
    }, null, null);
  }
  static FindUniqueNewName(prefix) {
    let n = 1;
    for (let i = 0; i < YWebPage.widgets.length; i++) {
      if (YWebPage.widgets[i].Text.startsWith(prefix))
        n++;
    }
    if (n > 1)
      prefix = prefix + " " + n.toString();
    return prefix;
  }
  static newGraphWidget() {
    let w = window.innerWidth / 2 >> 0;
    let h = window.innerHeight / 2 >> 0;
    if (w < 350)
      w = 350;
    if (h < 200)
      w = 200;
    let x = (window.innerWidth - w) / 2 >> 0;
    let y = (window.innerHeight - h) / 2 >> 0;
    let index = YWebPage.widgets.length;
    if (index > 0) {
      x = index * 25;
      y = index * 25;
    }
    let wdg = new graphWidget(null, YWebPage._editor, x, y, 765, 470);
    wdg.set_name(YWebPage.FindUniqueNewName("New Graph"));
    YWebPage.widgets.push(wdg);
    wdg.resize(w, h);
    if (this._mainform != null)
      this._mainform.hide();
    if (!YWebPage.readonly) {
      if (YWebPage._editor != null && YWebPage._editor.visible)
        wdg.edit();
    }
  }
  static newAngularGaugeWidget() {
    let s = Math.min(window.innerWidth, window.innerHeight) / 2;
    if (s < 350)
      s = 350;
    let x = (window.innerWidth - s) / 2 >> 0;
    let y = (window.innerHeight - s) / 2 >> 0;
    let w = s >> 0;
    let h = s >> 0;
    let index = YWebPage.widgets.length;
    if (index > 0) {
      x = index * 25;
      y = index * 25;
    }
    let wdg = new angularGaugeWidget(null, YWebPage._editor, x, y, 375, 300);
    wdg.set_name(YWebPage.FindUniqueNewName("New Angular Gauge"));
    YWebPage.widgets.push(wdg);
    wdg.resize(w, h);
    if (this._mainform != null)
      this._mainform.hide();
    if (!YWebPage.readonly) {
      if (YWebPage._editor != null && YWebPage._editor.visible)
        wdg.edit();
    }
  }
  static newGaugeWidget() {
    let s = Math.min(window.innerWidth, window.innerHeight) / 2;
    if (s < 350)
      s = 350;
    let x = (window.innerWidth - s) / 2 >> 0;
    let y = (window.innerHeight - s) / 2 >> 0;
    let w = s >> 0;
    let h = s >> 0;
    let index = YWebPage.widgets.length;
    if (index > 0) {
      x = index * 25;
      y = index * 25;
    }
    let wdg = new gaugeWidget(null, YWebPage._editor, x, y, 355, 201);
    wdg.set_name(YWebPage.FindUniqueNewName("New Solid Gauge"));
    YWebPage.widgets.push(wdg);
    wdg.resize(w, h);
    if (this._mainform != null)
      this._mainform.hide();
    if (!YWebPage.readonly) {
      if (YWebPage._editor != null && YWebPage._editor.visible)
        wdg.edit();
    }
  }
  static newDigitalDisplayWidget() {
    let s = Math.min(window.innerWidth, window.innerHeight) / 8;
    if (s < 90)
      s = 90;
    let x = (window.innerWidth - 4 * s) / 2 >> 0;
    let y = (window.innerHeight - s) / 2 >> 0;
    let w = 4 * s >> 0;
    let h = s >> 0;
    let index = YWebPage.widgets.length;
    if (index > 0) {
      x = index * 25;
      y = index * 25;
    }
    let wdg = new digitalDisplayWidget(null, YWebPage._editor, x, y, 410, 125);
    wdg.set_name(YWebPage.FindUniqueNewName("New Digital Display"));
    let n = 1;
    for (let i = 0; i < YWebPage.widgets.length; i++) {
      if (YWebPage.widgets[i].Text.startsWith(wdg.Text))
        n++;
    }
    if (n > 1)
      wdg.Text = wdg.Text + " " + n.toString();
    YWebPage.widgets.push(wdg);
    wdg.resize(w, h);
    if (this._mainform != null)
      this._mainform.hide();
    if (!YWebPage.readonly) {
      if (YWebPage._editor != null && YWebPage._editor.visible)
        wdg.edit();
    }
  }
  static refreshPropertiesForm() {
    if (!YWebPage.readonly && YWebPage._editor != null)
      YWebPage._editor.refresh();
  }
  static sensorListHaschanged() {
    YWebPage.refreshPropertiesForm();
  }
  static EmptyReadonlyConfig() {
    alert2.show("Yocto-Visualization Error\n\nConfiguration is both empty and read only, check configuration file.");
  }
  static async ForceReloadConfig(newXMLdata) {
    if (!YWebPage.readonly) {
      if (YWebPage._editor != null)
        YWebPage._editor.visible = false;
      configForm.hide();
      rawDataForm.hide();
      HubEdit.hide();
    }
    logForm.log("Reloading the whole configuration.");
    await sensorsManager.clearHublist();
    for (let i = YWebPage.widgets.length - 1; i >= 0; i--) {
      YWebPage.widgets[i].destroy();
      YWebPage.widgets.splice(i, 1);
    }
    YWebPage.loadFromXML(newXMLdata);
    constants.edited = false;
  }
  static ConfigChanged(newXMLdata) {
    if (YWebPage.ConfigChangedConfirmWindows != null) {
      YWebPage.ConfigChangedConfirmWindows.hide();
    }
    let newCRC = constants.crc32(newXMLdata);
    if (newCRC == YWebPage.xmlDataCRC)
      return;
    logForm.log("Config file changed behind our back!");
    if (!this.readonly) {
      YWebPage.ConfigChangedConfirmWindows = confirm.ask("Configuration has changed on server\nWould you like to reload it?", () => {
        YWebPage.ForceReloadConfig(newXMLdata);
        YWebPage.ConfigChangedConfirmWindows = null;
      }, () => {
        YWebPage.ConfigChangedConfirmWindows = null;
      }, null);
    } else {
      YWebPage.ForceReloadConfig(newXMLdata);
    }
    YWebPage.xmlDataCRC = newCRC;
    constants.edited = false;
  }
  static ShowSaveReminder(visible) {
    if (YWebPage.saveIntDiv == null) {
      YWebPage.saveIntDiv = document.createElement("DIV");
      YWebPage.saveIntDiv.style.position = "fixed";
      YWebPage.saveIntDiv.style.left = "5px";
      YWebPage.saveIntDiv.style.top = "5px";
      YWebPage.saveIntDiv.style.zIndex = "200000";
      YWebPage.saveIntDiv.style.cursor = "pointer";
      YWebPage.saveIntDiv.innerHTML = ressources.SaveNeededIcon((48 * constants.guiDPIFactor).toString(), false, false, false, false);
      YWebPage.saveIntDiv.addEventListener("click", () => {
        YWebPage.saveIntDiv.style.display = "none";
        YWebPage.save(true);
      });
      document.body.appendChild(YWebPage.saveIntDiv);
    }
    YWebPage.saveIntDiv.style.display = visible ? "" : "none";
  }
  static loadFromXML(xmlData) {
    if (xmlData == "") {
      if (!YWebPage.readonly && YWebPage._mainform != null) {
        YWebPage._mainform.show();
      } else {
        YWebPage.EmptyReadonlyConfig();
      }
      return;
    }
    let parser = new DOMParser();
    let doc = parser.parseFromString(xmlData.replace("<!-->", "<!-- "), "application/xml");
    let root = null;
    doc.childNodes.forEach((node) => {
      if (node.nodeName.toUpperCase() == "ROOT" && root == null)
        root = node;
    });
    if (root == null)
      throw "No ROOT top node in XML data";
    root.childNodes.forEach((node) => {
      if (node.nodeName.toUpperCase() == "SENSORS") {
        sensorsManager.setKnownSensors(new YXmlNode(node));
      }
    });
    root.childNodes.forEach((node) => {
      let editor = null;
      editor = YWebPage._editor;
      switch (node.nodeName.toUpperCase()) {
        case "CONFIG":
          constants.Init(new YXmlNode(node));
          break;
        case "GRAPHFORM":
          YWebPage.widgets.push(new graphWidget(new YXmlNode(node), editor));
          break;
        case "ANGULARGAUGEFORM":
          YWebPage.widgets.push(new angularGaugeWidget(new YXmlNode(node), editor));
          break;
        case "GAUGEFORM":
          YWebPage.widgets.push(new gaugeWidget(new YXmlNode(node), editor));
          break;
        case "DIGITALDISPLAYFORM":
          YWebPage.widgets.push(new digitalDisplayWidget(new YXmlNode(node), editor));
          break;
      }
      sensorsManager.registerChangeCallback(() => {
        YWebPage.sensorListHaschanged();
      });
      if (node.nodeName.toUpperCase() == "ROOT" && root == null)
        root = node;
    });
    if (YWebPage.widgets.length <= 0) {
      constants.edited = false;
      if (!YWebPage.readonly && YWebPage._mainform != null) {
        YWebPage._mainform.show();
      } else {
        YWebPage.EmptyReadonlyConfig();
      }
    } else if (!YWebPage.readonly && YWebPage._mainform != null)
      YWebPage._mainform.hide();
  }
  static AnimateNewVerwsionMessage(step) {
    YWebPage.NewVersionmessageDiv.style.left = Math.round(100 - step) + "%";
    if (step < 100) {
      step += 2;
      if (step > 100)
        step = 100;
      setTimeout(() => {
        YWebPage.AnimateNewVerwsionMessage(step);
      });
    }
  }
  static StartInstaller(roothub) {
    let installerDiv = document.createElement("DIV");
    installerDiv.style.position = "absolute";
    installerDiv.style.top = "50%";
    installerDiv.style.left = "50%";
    installerDiv.style.transform = "translate(-50%,-50%)";
    installerDiv.style.width = "550px";
    installerDiv.style.height = "380px";
    installerDiv.style.zIndex = YWebPage.getTopZIndex().toString();
    installerDiv.style.border = "1px solid black";
    installerDiv.style.boxShadow = "rgba(0, 0, 0, 0.05) 4px 4px 4px 1px";
    document.body.appendChild(installerDiv);
    let options = {};
    if (roothub != null)
      options = {
        protocol: roothub.protocol,
        addr: roothub.addr,
        port: parseInt(roothub.port),
        path: roothub.path,
        cancelable: true
      };
    window.startYV4W_installer(installerDiv, options);
  }
  static DownloadAndStartInstaller(installerURL, roothub, deleteTimer) {
    clearTimeout(deleteTimer);
    console.log("Downloading installer (" + installerURL + ")...");
    let P = document.createElement("P");
    P.style.textAlign = "center";
    P.style.fontFamily = constants.generalFontFamily;
    P.style.fontSize = "16px";
    P.innerHTML = "Downloading Installer<br>Please wait...";
    YWebPage.NewVersionmessageDiv.removeChild(YWebPage.NewVersionmessageDiv.firstChild);
    YWebPage.NewVersionmessageDiv.appendChild(P);
    let script = document.createElement("script");
    script.async = false;
    script.type = "module";
    script.onerror = (err) => {
      console.log("Failed to donwload installer (" + Event.toString() + ")");
      P.innerHTML = "Failed to download installer,<br>Check conole logs";
    };
    script.onload = () => {
      P.innerHTML = "Starting installer...";
      YWebPage.DeleteNewVersionMessage(100);
      YWebPage.StartInstaller(roothub);
    };
    document.body.appendChild(script);
    script.src = installerURL;
  }
  static DeleteNewVersionMessage(opacity) {
    opacity -= 5;
    if (opacity > 0) {
      YWebPage.NewVersionmessageDiv.style.opacity = (opacity / 100).toString();
      setTimeout(() => {
        YWebPage.DeleteNewVersionMessage(opacity);
      }, 100);
      return;
    }
    document.body.removeChild(YWebPage.NewVersionmessageDiv.parentNode);
  }
  static getTopZIndex() {
    var elems = document.getElementsByTagName("DIV");
    var highestZ = 0;
    for (var i = 0; i < elems.length; i++) {
      var z = Number.parseInt(window.getComputedStyle(elems[i], null).getPropertyValue("z-index"));
      if (z > highestZ)
        highestZ = z;
    }
    return highestZ + 1;
  }
  static async CheckForNewVersion(force) {
    if (!constants.mustCheckForUpdate && !force)
      return;
    let checkurl = location.protocol + "//www.yoctopuce.com/FR/common/getLastFirmwareLink.php?app=yoctovisualization4web.installer&version=" + constants.buildVersion + "&platform=_";
    let response;
    try {
      response = await fetch(checkurl);
    } catch (e) {
      return;
    }
    if (!response.ok)
      return;
    let json;
    try {
      json = await response.json();
    } catch (e) {
      return;
    }
    if (!(json instanceof Array))
      return;
    if (json.length <= 0)
      return;
    if (!("version" in json[0]))
      return;
    if (!("link" in json[0]))
      return;
    let newVersionInstallerURL = json[0]["link"];
    let newVersionNumber = parseInt(json[0]["version"]);
    let currentVersionStr = constants.buildVersion;
    let currentVersionNumber = 0;
    if (currentVersionStr.indexOf("-") < 0) {
      let n = currentVersionStr.lastIndexOf(".");
      if (n >= 0)
        currentVersionStr = currentVersionStr.substr(n + 1);
      currentVersionNumber = parseInt(currentVersionStr);
    }
    if (currentVersionNumber >= newVersionNumber)
      return;
    let generalSize = constants.generalFontSize;
    let NewVersionSizeX = generalSize * 24;
    let NewVersionSizeY = generalSize * 5;
    let containerDiv = document.createElement("DIV");
    containerDiv.style.position = "absolute";
    containerDiv.style.width = NewVersionSizeX + "px";
    containerDiv.style.height = NewVersionSizeY + "px";
    containerDiv.style.zIndex = YWebPage.getTopZIndex().toString();
    containerDiv.style.top = "5px";
    containerDiv.style.right = "0px";
    containerDiv.style.overflow = "hidden";
    document.body.appendChild(containerDiv);
    YWebPage.NewVersionmessageDiv = document.createElement("DIV");
    YWebPage.NewVersionmessageDiv.style.position = "absolute";
    YWebPage.NewVersionmessageDiv.style.width = NewVersionSizeX - 7 + "px";
    YWebPage.NewVersionmessageDiv.style.height = NewVersionSizeY - 2 + "px";
    YWebPage.NewVersionmessageDiv.style.backgroundColor = "GhostWhite";
    YWebPage.NewVersionmessageDiv.style.border = "1px solid dimgray";
    YWebPage.NewVersionmessageDiv.style.top = "0px";
    YWebPage.NewVersionmessageDiv.style.left = NewVersionSizeX + "px";
    let table = document.createElement("TABLE");
    table.style.fontFamily = constants.generalFontFamily;
    table.style.fontSize = generalSize + "px";
    let TR = document.createElement("TR");
    let TD1 = document.createElement("TD");
    TD1.style.paddingLeft = "5px";
    TD1.style.paddingRight = "10px";
    TD1.rowSpan = 2;
    TD1.style.verticalAlign = "middle";
    TD1.innerHTML = ressources.infoIcon((generalSize * 4).toString(), false, false, false, false, "information");
    TR.appendChild(TD1);
    let TD2 = document.createElement("TD");
    TD2.innerHTML = "A new Yocto-Visualization (for web)<br>version is available";
    TR.appendChild(TD2);
    table.appendChild(TR);
    TR = document.createElement("TR");
    TD2 = document.createElement("TD");
    TD2.style.textAlign = "right";
    TD2.style.verticalAlign = "bottom";
    let hubList = sensorsManager.hubList;
    let rootHub = null;
    for (let i = 0; i < hubList.length; i++) {
      if (!hubList[i].removable)
        rootHub = hubList[i];
    }
    let a = document.createElement("A");
    let deleteTimer = setTimeout(() => {
      YWebPage.DeleteNewVersionMessage(100);
    }, 5e3);
    a.style.fontSize = "12px";
    a.style.color = " #0000EE";
    a.style.textDecoration = "underline";
    a.style.cursor = "pointer";
    a.style.fontFamily = constants.generalFontFamily;
    a.style.fontSize = generalSize + "px";
    if (rootHub != null) {
      a.innerText = "Download and start installer..";
      a.addEventListener("click", () => {
        YWebPage.DownloadAndStartInstaller(newVersionInstallerURL, rootHub, deleteTimer);
      });
    } else {
      a.innerText = "www.yoctopuce.com";
      a.addEventListener("click", () => {
        window.location.assign("http://www.yoctopuce.com/EN/tools.php");
      });
    }
    TD2.appendChild(a);
    TR.appendChild(TD2);
    table.appendChild(TR);
    YWebPage.NewVersionmessageDiv.appendChild(table);
    containerDiv.appendChild(YWebPage.NewVersionmessageDiv);
    YWebPage.AnimateNewVerwsionMessage(0);
  }
  static run(xmlData, ExternalConfigChange, saveFunction) {
    if (typeof ExternalConfigChange !== "undefined") {
      if (ExternalConfigChange != null) {
        sensorsManager.registerChangeExternalCallback(ExternalConfigChange);
      }
    }
    YWebPage.xmlDataCRC = constants.crc32(xmlData);
    if (typeof saveFunction !== "undefined")
      YWebPage._saveFunction = saveFunction;
    logForm.log("Application start, Welcome to Yocto-Visualization (for web).");
    logForm.log("This application contains code ported from the Pako library (www.github.com/nodeca/pako).");
    logForm.log("Yocto-Visualization version is " + constants.buildVersion);
    logForm.log("Yoctopuce API version is " + YAPI.imm_GetAPIVersion());
    if (constants.RunningOnAndroid)
      logForm.log("Browser is running on Android");
    let widthCm = Math.round(2.54 * constants.deviceScreenWidth / constants.screenDPI);
    let heightCm = Math.round(2.54 * constants.deviceScreenHeight / constants.screenDPI);
    logForm.log("Reported screen size is " + constants.deviceScreenWidth.toString() + "x" + constants.deviceScreenHeight.toString() + " at " + constants.screenDPI + " dpi, (~" + widthCm.toString() + "x" + heightCm.toString() + "cm) ");
    logForm.log("Reported pixel ratio is " + window.devicePixelRatio.toString());
    logForm.log(constants.isPhoneOrTablet ? "Probably running on a tablet or a phone." : "Probably running on a desktop.");
    logForm.log((constants.guiDPIFactorWasOverriden ? "DPI based zoom overridden  to " : "DPI based zoom factor set to ") + constants.guiDPIFactor.toFixed(1));
    logForm.log("Reported window inner size =" + window.innerWidth.toString() + "x" + window.innerHeight.toString() + "px");
    YWebPage.applicationGlobalinit();
    sensorsManager.run();
    YWebPage.loadFromXML(xmlData);
    constants.edited = false;
    YWebPage.CheckForNewVersion(false);
  }
  static async pageIsleaving(e) {
    if (!e.persistent) {
      if (constants.edited) {
        await YWebPage.save(false);
        await YAPI.FreeAPI();
      }
    }
  }
  static refreshEditor() {
    if (YWebPage.readonly)
      return;
    if (YWebPage._editor == null)
      return;
    YWebPage._editor.refresh();
  }
  static EditObject(widget, structData, setvalueCallBack, getvalueCallBack, EditStoppedCallBack) {
    if (YWebPage.readonly)
      return;
    if (YWebPage._editor == null)
      return;
    YWebPage._editor.showWindow(widget, structData, setvalueCallBack, getvalueCallBack, EditStoppedCallBack);
  }
  static get_XmlData() {
    let XmlConfigFile = `<?xml version="1.0" ?>
<!--
   **************************************************
   Yocto-Visualization (for web)  configuration file
   **************************************************
-->
<ROOT version='2.1'>
<!-- in 2.1 version, floating point values are saved in CultureInfo.InvariantCulture form -->
`;
    XmlConfigFile += constants.GetXMLConfiguration();
    for (let i = 0; i < YWebPage.widgets.length; i++) {
      if (YWebPage.widgets[i] instanceof graphWidget)
        XmlConfigFile += YWebPage.widgets[i].getConfigData();
      if (YWebPage.widgets[i] instanceof angularGaugeWidget)
        XmlConfigFile += YWebPage.widgets[i].getConfigData();
      if (YWebPage.widgets[i] instanceof gaugeWidget)
        XmlConfigFile += YWebPage.widgets[i].getConfigData();
      if (YWebPage.widgets[i] instanceof digitalDisplayWidget)
        XmlConfigFile += YWebPage.widgets[i].getConfigData();
    }
    XmlConfigFile += sensorsManager.getXMLSensorsConfig();
    XmlConfigFile += "</ROOT>\n";
    return XmlConfigFile;
  }
  static get readonly() {
    let res = true;
    res = YWebPage._saveFunction == null;
    return res;
  }
  static async runInternalTest() {
  }
  static async save(force) {
    if (YWebPage.readonly)
      return true;
    let xml = this.get_XmlData();
    let newCRC = constants.crc32(xml);
    if (!force && newCRC == YWebPage.xmlDataCRC)
      return true;
    let saveDoneCallback = (ok, message) => {
      let div = document.createElement("DIV");
      div.style.position = "Fixed";
      div.style.left = "5px";
      div.style.top = "5px";
      div.style.padding = "2px 5px 2px 5px";
      div.style.margin = "2px 2px 2px 2px";
      div.style.border = "1px solid darkgreen";
      div.style.fontFamily = "Arial";
      div.style.fontSize = (12 * constants.guiDPIFactor).toString();
      div.style.whiteSpace = "nowrap";
      div.style.zIndex = "200000";
      div.style.textAlign = "center";
      div.style.opacity = "1";
      let fgcolor = ok ? "darkgreen" : "darkred";
      let bgcolor = ok ? "#b9eea9" : "#eea9a9";
      div.style.opacity = "1";
      div.style.backgroundColor = bgcolor;
      div.style.border = "1px solid " + fgcolor;
      div.style.color = fgcolor;
      div.innerText = message;
      document.body.appendChild(div);
      setTimeout(() => {
        YWebPage.handleSavedNotification(div);
      }, 100);
    };
    try {
      if (YWebPage._saveFunction != null) {
        return await YWebPage._saveFunction(this.get_XmlData(), saveDoneCallback);
      }
    } catch (e) {
      saveDoneCallback(false, "Save failed");
      alert2.show("Configuration save failed, sorry\n" + e.message);
      return false;
    }
    YWebPage.xmlDataCRC = newCRC;
    logForm.log("Configuration saved.");
    constants.edited = false;
    return true;
  }
  static handleSavedNotification(div) {
    let opacity = parseFloat(div.style.opacity) - 0.05;
    if (opacity < 0) {
      document.body.removeChild(div);
      return;
    }
    div.style.opacity = opacity.toString();
    setTimeout(() => {
      YWebPage.handleSavedNotification(div);
    }, 100);
  }
  static Dummysave(xml) {
    let contents = document.createElement("PRE");
    contents.innerText = xml;
    document.body.appendChild(contents);
    return true;
  }
};
YWebPage.baseSize = 18 * constants.generalSizeCoef;
YWebPage.xmlDataCRC = 0;
YWebPage.widgets = [];
YWebPage._markersSubMenuItems = [];
YWebPage._editor = null;
YWebPage._mainform = null;
YWebPage._saveFunction = null;
YWebPage._MarkerCountPerXaxis = 0;
YWebPage.ConfigChangedConfirmWindows = null;
YWebPage.saveIntDiv = null;
var HTTPrequestResult = class {
  constructor(data, status, statusText) {
    this._data = data;
    this._status = status;
    this._statusText = statusText;
  }
  get data() {
    return this._data;
  }
  get status() {
    return this._status;
  }
  get statusText() {
    return this._statusText;
  }
};
var HubInfo = class {
  get protocol() {
    return this._protocol;
  }
  get addr() {
    return this._addr;
  }
  get port() {
    return this._port;
  }
  get path() {
    return this._path;
  }
  get userPassword() {
    return this._userPassword;
  }
  get adminPassword() {
    return this._adminPassword;
  }
  get serial() {
    return this._serial;
  }
  get srvUsername() {
    return this._srvusername != null ? this._srvusername : "";
  }
  get srvPassword() {
    return this._srvpassword != null ? this._srvpassword : "";
  }
  constructor(protocol, addr, port, path, srvusername, srvpassword) {
    this._userPassword = false;
    this._adminPassword = false;
    this._cred = "";
    this._serial = "";
    this._srvusername = null;
    this._srvpassword = null;
    if (protocol.slice(-1) == ":")
      protocol = protocol.slice(0, -1);
    this._protocol = protocol;
    this._addr = addr;
    this._port = port;
    this._protocol = protocol;
    this._path = path;
    if (srvusername !== void 0)
      this._srvusername = srvusername;
    if (srvpassword !== void 0)
      this._srvpassword = srvpassword;
    if (this._path != "") {
      if (this._path.charAt(0) == "/") {
        this._path = this._path.slice(1);
      }
    }
    if (this._path != "") {
      if (this._path.slice(-1) == "/") {
        this._path = this._path.slice(0, -1);
      }
    }
  }
  get_hubUrl(user, password) {
    let url = this.protocol + "://";
    if (typeof user != "undefined" && user != "") {
      if (user != "") {
        url += user + ":" + password + "@";
      }
    }
    url += this.addr + ":" + this.port.toString();
    if (this.path != "")
      url += "/" + this.path;
    return url;
  }
  async makeRequest() {
    let url = this._protocol + "://" + this._addr + ":" + this._port.toString();
    if (this._path != "")
      url += "/" + this._path;
    url += "/info.json";
    let response;
    try {
      response = await fetch(url, {mode: "cors"});
    } catch (e) {
      return -3;
    }
    if (response.ok) {
      let HubData;
      try {
        HubData = await response.json();
      } catch (e) {
        return -1;
      }
      if (HubData.port && HubData.port.length > 0) {
        let proto_port = HubData.port[0].split(":");
        this._protocol = proto_port[0];
        this._port = parseInt(proto_port[1]);
      }
      this._serial = HubData.serialNumber;
      this._path = HubData.dir;
      this._adminPassword = HubData.adminPassword.toUpperCase() == "TRUE";
      this._userPassword = HubData.userPassword.toUpperCase() == "TRUE";
      return true;
    }
    if (response.status == 404 && this._path != "")
      return -2;
    if (response.status == 0 && response.statusText == null)
      return -3;
    return response.status;
  }
  findChild(parent, name) {
    let res = null;
    parent.childNodes.forEach((node) => {
      if (node.nodeName == name) {
        res = node;
        return;
      }
    });
    return res;
  }
  findOutCredentialsFromConfigFile(xmlData) {
    if (xmlData == null)
      return;
    let parser = new DOMParser();
    let doc = parser.parseFromString(xmlData, "application/xml");
    let rootNode = this.findChild(doc, "ROOT");
    if (rootNode == null)
      return;
    let configNode = this.findChild(rootNode, "Config");
    if (configNode == null)
      return;
    let Hubs = this.findChild(configNode, "Hubs");
    if (Hubs == null)
      return;
    let HubSection;
    let list = Hubs.childNodes;
    let sourceHubFound = false;
    for (let i = 0; i < list.length; i++) {
      if (list[i].nodeName == "Hub") {
        let node = new YXmlNode(list[i]);
        let attributes = node.Attributes;
        let addr = attributes.hasOwnProperty("addr") ? attributes["addr"] : "";
        let port = attributes.hasOwnProperty("port") ? attributes["port"] : "80";
        let protocol = attributes.hasOwnProperty("protocol") ? attributes["protocol"] : "";
        let path = attributes.hasOwnProperty("path") ? attributes["path"] : "";
        let username = attributes.hasOwnProperty("user") ? attributes["user"] : "";
        let password = attributes.hasOwnProperty("password") ? attributes["password"] : "";
        let a1 = addr.toUpperCase();
        if (a1.substring(0, 4) == "WWW.")
          a1 = a1.substring(4);
        let a2 = this._addr.toUpperCase();
        if (a2.substring(0, 4) == "WWW.")
          a2 = a2.substring(4);
        if (a1 == a2 && path == this._path) {
          this._srvusername = username;
          this._srvpassword = Hub.Decrypt(password, Hub.loginCypherPassword);
        }
      }
    }
  }
};
var YoctoHubFileHandler = class {
  constructor(hubInfo) {
    this.filename = "";
    this.xmldata = "";
    this.htmlSrcCode = "";
    this.FileSystemAccessDenied = false;
    this._XMLConfigFileChanged = null;
    this.fileSystem = null;
    this.fileSystemReady = false;
    this.configFileCRC = -1;
    this.info = hubInfo;
  }
  async init(defaultXmlConfigFileContents) {
    let url = location.href;
    this.filename = url.substring(url.lastIndexOf("/") + 1);
    let p = this.filename.indexOf("?");
    if (p > 0)
      this.filename = this.filename.substring(0, p);
    this.htmlSrcCode = document.documentElement.outerHTML;
    if (typeof defaultXmlConfigFileContents === "undefined" || defaultXmlConfigFileContents == "") {
      this.xmldata = '<?xml version="1.0" ?>\n<ROOT version="2.1">\n<Config>\n<Hubs>\n<Hub protocol="' + this.info.protocol + '" addr="' + this.info.addr + '" port="' + this.info.port.toString() + '"' + (this.info.path != "" ? ' path="' + this.info.path + '"' : "") + ' removable="FALSE"/>\n</Hubs>\n</Config>\n</ROOT>\n';
    } else {
      this.xmldata = defaultXmlConfigFileContents;
    }
    this.fileSystem = null;
    this.fileSystemReady = false;
    await this.findSourceFileSystem(defaultXmlConfigFileContents);
  }
  static async start(defaultXmlConfigFileContents) {
    let dirpath = location.pathname;
    let defport = "80";
    let slashpos = dirpath.lastIndexOf("/");
    if (slashpos > 0) {
      dirpath = dirpath.slice(0, slashpos);
    } else {
      dirpath = "";
    }
    if (location.protocol == "https:") {
      defport = "443";
    }
    let hubinfo = new HubInfo(location.protocol, location.hostname, parseInt(location.port ? location.port : defport), dirpath);
    await hubinfo.makeRequest();
    let filehandler = new YoctoHubFileHandler(hubinfo);
    await filehandler.init(defaultXmlConfigFileContents);
    return filehandler;
  }
  get xmlConfigData() {
    return this.xmldata;
  }
  static makeRequest(method, url, username, password) {
    return new Promise(function(resolve, reject) {
      let xhr = new XMLHttpRequest();
      if (username !== void 0 && password !== void 0 && username != null && password !== null) {
        xhr.open(method, url, true, username, password);
        xhr.withCredentials = true;
      } else {
        xhr.open(method, url);
      }
      xhr.overrideMimeType("text/plain; charset=x-user-defined");
      xhr.onreadystatechange = function() {
        if (xhr.readyState == 4) {
          if (this.status >= 200 && this.status < 300) {
            resolve(new HTTPrequestResult(YAPI.imm_str2bin(xhr.response), this.status, xhr.statusText));
          } else {
            resolve(new HTTPrequestResult(null, this.status, xhr.statusText));
          }
        }
      };
      xhr.onerror = function() {
        resolve(new HTTPrequestResult(null, this.status, xhr.statusText));
      };
      xhr.send();
    });
  }
  async findSourceFileSystem(xmldata) {
    this.fileSystem = null;
    let errmsg = new YErrorMsg();
    this.info.findOutCredentialsFromConfigFile(xmldata);
    let url = this.info.get_hubUrl(this.info.srvUsername, this.info.srvPassword);
    try {
      await YAPI.RegisterHub(url, errmsg);
    } catch (e) {
      this.fileSystemReady = false;
      if (e.errorType == YAPI.UNAUTHORIZED) {
        console.log("Access to hub " + url + " is denied, waiting for YV callback to save the situation.");
        this.FileSystemAccessDenied = true;
        return;
      }
      throw "YV4F ERROR: Unable to register Hub " + this.info.get_hubUrl() + "(" + e.message + "), save will not work.";
    }
    let fs = YFiles.FirstFiles();
    if (fs == null) {
      this.fileSystemReady = true;
      throw "YV4F ERROR: No file system found on Hub " + this.info.get_hubUrl() + ", save will not work.";
    }
    while (fs != null) {
      if (await fs.get_serialNumber() == this.info.serial) {
        await this.registerSourceFileSystem(fs);
        return;
      }
      fs = fs.nextFiles();
    }
    fs = YFiles.FirstFiles();
    while (fs != null) {
      let m = await fs.get_module();
      let url2 = await m.get_url();
      console.log("URL = (" + url2 + ")");
      let p = url2.indexOf("://");
      if (p >= 0)
        url2 = url2.slice(p + 3);
      p = url2.indexOf(":");
      if (p > 0)
        url2 = url2.slice(0, p);
      {
        if (url2 == this.info.addr) {
          await this.registerSourceFileSystem(fs);
          return;
        }
      }
      fs = fs.nextFiles();
    }
    this.fileSystemReady = true;
    throw "YV4F ERROR: No file system matching Hub " + this.info.get_hubUrl() + " found, save will not work.";
  }
  async registerSourceFileSystem(fs) {
    this.fileSystem = fs;
    this.fileSystemReady = true;
    this.FileSystemAccessDenied = false;
    let entries = await this.fileSystem.get_list(this.filename);
    if (entries.length > 0)
      this.configFileCRC = await entries[0].get_crc();
  }
  async configChangeCallback(m) {
    if (this.fileSystem == null) {
      let urlSignature = this.info.addr + ":" + this.info.port.toString() + "/" + this.info.path + (this.info.path != "" ? "/" : "");
      let sourceUrl = await m.get_url();
      console.log("urlSignature=" + urlSignature);
      console.log("sourceUrl=" + sourceUrl);
      if (sourceUrl.length > urlSignature.length && sourceUrl.substring(sourceUrl.length - urlSignature.length) == urlSignature) {
        let fs = YFiles.FindFiles(await m.get_serialNumber() + ".files");
        if (await fs.isOnline())
          await this.registerSourceFileSystem(fs);
      }
    }
    if (this.fileSystem == null)
      return null;
    if (await this.fileSystem.get_serialNumber() != await m.get_serialNumber())
      return null;
    let entries = await this.fileSystem.get_list(this.filename);
    if (entries.length <= 0)
      return null;
    if (this.configFileCRC == await entries[0].get_crc())
      return null;
    let data = await this.fileSystem.download(this.filename);
    let file = new TextDecoder("utf-8").decode(data);
    let indexStart = file.indexOf(YoctoHubFileHandler.signatureStart);
    if (indexStart < 0)
      return null;
    this.configFileCRC = await entries[0].get_crc();
    indexStart += YoctoHubFileHandler.signatureStart.length;
    let indexEnd = file.indexOf(YoctoHubFileHandler.signatureEnd);
    if (indexEnd < indexStart)
      return "";
    indexEnd += YoctoHubFileHandler.signatureEnd.length - 2;
    let configdata = file.substring(indexStart, indexEnd);
    try {
      return JSON.parse(configdata);
    } catch (e) {
    }
    return null;
  }
  get configChangeCallbackFct() {
    return async (module) => {
      return await this.configChangeCallback(module);
    };
  }
  get saveFct() {
    return async (xml, callback) => {
      return await this.saveFctinternal(xml, callback);
    };
  }
  async retryWithNewCredentials(xml, username, password, callback) {
    if (this.fileSystem == null) {
      debugger;
      return;
    }
    let m = await this.fileSystem.get_module();
    let url = await m.get_url();
    let err = new YErrorMsg();
    let p1 = url.indexOf("://");
    let p2 = url.indexOf("@", p1 + 3);
    let newurl = url.substring(0, p1 + 3) + username + ":" + password + "@";
    if (p2 < 0)
      newurl += url.substring(p1 + 3);
    else
      newurl += url.substring(p2 + 1);
    await YAPI.UnregisterHub(url);
    if (await YAPI.RegisterHub(newurl, err) != YAPI.SUCCESS) {
      await YAPI.RegisterHub(url, err);
    }
    try {
      if (!await this.saveFctinternal(xml, callback))
        return;
    } catch (e) {
      if (callback != null)
        callback(false, "Save failed (" + e.message) + ")";
      return;
    }
  }
  async saveFctinternal(xml, callback) {
    if (this.FileSystemAccessDenied) {
      throw "YV4F ERROR: Access to file system on " + this.info.get_hubUrl() + " is denied, it is probably password protected. Check network connections in the global configuration.";
    }
    if (this.fileSystem == null) {
      throw "YV4F ERROR: No file system, Save aborted";
    }
    if (!this.fileSystemReady) {
      throw "YV4F ERROR: File system is not ready yet, retry in a few seconds.";
    }
    if (!this.fileSystem.isOnline()) {
      throw "YV4F ERROR: File system is off line, Save aborted";
    }
    let tosave = "";
    let index = this.htmlSrcCode.indexOf(YoctoHubFileHandler.signatureStart + ")");
    if (index > 0) {
      tosave = this.htmlSrcCode.substring(0, index + YoctoHubFileHandler.signatureStart.length) + JSON.stringify(xml) + this.htmlSrcCode.substring(index + YoctoHubFileHandler.signatureStart.length);
    } else {
      let index1 = this.htmlSrcCode.indexOf(YoctoHubFileHandler.signatureStart);
      let index2 = this.htmlSrcCode.indexOf(YoctoHubFileHandler.signatureEnd);
      if (index1 > 0 && index2 && index2 > index1) {
        tosave = this.htmlSrcCode.substring(0, index1 + YoctoHubFileHandler.signatureStart.length) + JSON.stringify(xml) + ");" + this.htmlSrcCode.substring(index2 + YoctoHubFileHandler.signatureEnd.length);
      } else {
        throw "Unable to locate YoctoHubFileHandler constructor call in original HTML file.";
      }
    }
    tosave = "<!DOCTYPE html>\n" + tosave;
    let GZdata = Pako_Deflate.gzip(tosave, {level: 9});
    let askForRwCredentials = false;
    try {
      await this.fileSystem.upload(this.filename + ".gz", GZdata);
    } catch (e) {
      if (this.fileSystem.get_errorType() == YAPI_UNAUTHORIZED)
        askForRwCredentials = true;
      else
        throw e;
    }
    if (askForRwCredentials) {
      let m = await this.fileSystem.get_module();
      let url = await m.get_url();
      let err = new YErrorMsg();
      let p1 = url.indexOf("://");
      let p2 = url.indexOf("@", p1 + 3);
      if (p2 >= 0)
        url = url.substring(p2 + 1);
      else if (p1 >= 0)
        url = url.substring(p1 + 3);
      await CredentialsPrompt.show(url, async () => {
        await this.retryWithNewCredentials(xml, CredentialsPrompt.username, CredentialsPrompt.password, callback);
      });
      if (callback != null)
        callback(false, "Save failed, credentials required");
      return false;
    }
    let entries = await this.fileSystem.get_list(this.filename);
    if (entries.length > 0)
      this.configFileCRC = await entries[0].get_crc();
    if (callback != null)
      callback(true, "Save sucessfull");
    return true;
  }
};
YoctoHubFileHandler.signatureStart = "YoctoHubFileHandler.start(";
YoctoHubFileHandler.signatureEnd = '</ROOT>\\n");';

// obj/full/logForm.js
var logForm = class {
  static show() {
    if (logForm._window == null) {
      let params = new newWindowParam();
      params.positionType = 0;
      params.width = 8 * window.innerWidth / 10 >> 0;
      params.height = 6 * window.innerHeight / 10 >> 0;
      params.left = 1 * window.innerWidth / 10 >> 0;
      params.top = 2 * window.innerHeight / 10 >> 0;
      params.title = "LogFile";
      logForm._window = new YWindow(params);
      logForm._contents = logForm._window.innerContentDiv;
      logForm._contents.style.fontFamily = "courrier";
      logForm._contents.style.fontSize = (10 * constants.generalSizeCoef).toString() + "px";
      logForm._contents.style.overflow = "auto";
      for (let i = 0; i < logForm._lines.length; i++) {
        logForm.addLine(logForm._lines[i]);
      }
    }
    logForm._window.show();
  }
  static addLine(st) {
    let pre = document.createElement("PRE");
    pre.style.marginTop = "0";
    pre.style.marginBottom = "0";
    pre.innerText = st;
    logForm._contents.appendChild(pre);
    while (logForm._contents.childElementCount > 1e3) {
      logForm._contents.removeChild(logForm._contents.firstChild);
    }
  }
  static padStart(st, length) {
    while (st.length < length) {
      st = "0" + st;
    }
    return st;
  }
  static dateToString(d) {
    return d.getFullYear().toString() + "-" + logForm.padStart((d.getMonth() + 1).toString(), 2) + "-" + logForm.padStart(d.getDate().toString(), 2) + " " + logForm.padStart(d.getHours().toString(), 2) + ":" + logForm.padStart(d.getMinutes().toString(), 2) + ":" + logForm.padStart((d.getSeconds() + d.getMilliseconds() / 1e3).toFixed(3), 6);
  }
  static log(st) {
    logForm.logNOTS(logForm.dateToString(new Date()) + " " + st);
  }
  static logNOTS(st) {
    logForm._lines.push(st);
    if (logForm._lines.length > 1e3) {
      logForm._lines.splice(0, logForm._lines.length - 1e3);
    }
    if (logForm._window != null)
      logForm.addLine(st);
  }
};
logForm._lines = [];

// obj/full/rawDataForm.js
var rawDataForm = class {
  static hide() {
    if (rawDataForm._window == null)
      return;
    rawDataForm._window.visible = false;
  }
  static show() {
    if (rawDataForm._window == null) {
      let params = new newWindowParam();
      params.positionType = 1;
      params.width = 9 * window.innerWidth / 10 >> 0;
      params.height = 8 * window.innerHeight / 10 >> 0;
      params.title = "Raw data";
      rawDataForm._window = new YWindow(params);
      rawDataForm._contents = rawDataForm._window.innerContentDiv;
      rawDataForm._statusline = document.createElement("DIV");
      rawDataForm._statusline.style.position = "absolute";
      rawDataForm._statusline.style.left = constants.WindowPadding.toString() + "px";
      rawDataForm._statusline.style.right = constants.WindowPadding.toString() + "px";
      rawDataForm._statusline.style.height = (rawDataForm.STATUSLINEHEIGHT * constants.generalSizeCoef).toString() + "px";
      rawDataForm._statusline.style.bottom = constants.WindowPadding.toString() + "px";
      rawDataForm._statusline.style.paddingTop = Math.round(5 * constants.generalSizeCoef).toString() + "px";
      rawDataForm._statusline.style.paddingLeft = "5px";
      rawDataForm._statusline.style.paddingRight = "5px";
      rawDataForm._statusline.style.overflowX = "auto";
      rawDataForm._statusline.style.paddingRight = "5px";
      rawDataForm._contents.append(rawDataForm._statusline);
      rawDataForm._sensorsList = document.createElement("DIV");
      rawDataForm._sensorsList.style.position = "absolute";
      rawDataForm._sensorsList.style.left = constants.WindowPadding.toString() + "px";
      rawDataForm._sensorsList.style.right = (rawDataForm.sensorListWidth * constants.generalSizeCoef + 8 * constants.WindowPadding).toString() + "px";
      rawDataForm._sensorsList.style.top = "2px";
      rawDataForm._sensorsList.style.overflowY = "auto";
      rawDataForm._sensorsList.style.height = (rawDataForm.topMargin * constants.generalSizeCoef).toString() + "px";
      rawDataForm._sensorsList.style.paddingLeft = "5px";
      rawDataForm._sensorsList.style.paddingRight = "5px";
      rawDataForm._sensorsList.style.border = constants.WindowInnerBorder;
      rawDataForm._sensorsList.style.backgroundColor = constants.WindowInnerBackgroundColor;
      rawDataForm._contents.append(rawDataForm._sensorsList);
      rawDataForm._optionsList = document.createElement("DIV");
      rawDataForm._optionsList.style.position = "absolute";
      rawDataForm._optionsList.style.width = (rawDataForm.sensorListWidth * constants.generalSizeCoef).toString() + "px";
      rawDataForm._optionsList.style.right = constants.WindowPadding.toString() + "px";
      rawDataForm._optionsList.style.top = "0px";
      rawDataForm._optionsList.style.height = (rawDataForm.topMargin * constants.generalSizeCoef).toString() + "px";
      rawDataForm._optionsList.style.paddingLeft = "5px";
      rawDataForm._optionsList.style.paddingRight = "5px";
      rawDataForm._optionsList.style.border = "1px solid transparent";
      rawDataForm._contents.append(rawDataForm._optionsList);
      let br;
      rawDataForm._optionMIN = document.createElement("INPUT");
      rawDataForm._optionMIN.type = "input";
      rawDataForm._optionMIN.checked = false;
      rawDataForm._optionMIN.style.display = "inline";
      rawDataForm._optionMIN.type = "checkbox";
      rawDataForm._optionMIN.style.transform = "scale(" + constants.generalSizeCoef.toString() + ")";
      rawDataForm._optionMIN.style.marginRight = Math.round(5 * constants.generalSizeCoef).toString() + "px";
      rawDataForm._optionMIN.addEventListener("change", () => {
        rawDataForm.refresh();
      });
      rawDataForm._optionsList.append(rawDataForm._optionMIN);
      let span;
      span = document.createElement("SPAN");
      span.innerText = "Include minimum values";
      rawDataForm._optionsList.append(span);
      br = document.createElement("BR");
      rawDataForm._optionsList.append(br);
      rawDataForm._optionAVG = document.createElement("INPUT");
      rawDataForm._optionAVG.type = "input";
      rawDataForm._optionAVG.checked = true;
      rawDataForm._optionAVG.style.display = "inline";
      rawDataForm._optionAVG.type = "checkbox";
      rawDataForm._optionAVG.style.transform = "scale(" + constants.generalSizeCoef.toString() + ")";
      rawDataForm._optionAVG.style.marginRight = Math.round(5 * constants.generalSizeCoef).toString() + "px";
      rawDataForm._optionAVG.addEventListener("change", () => {
        rawDataForm.refresh();
      });
      rawDataForm._optionsList.append(rawDataForm._optionAVG);
      span = document.createElement("SPAN");
      span.innerText = "Include average values";
      rawDataForm._optionsList.append(span);
      br = document.createElement("BR");
      rawDataForm._optionsList.append(br);
      rawDataForm._optionMAX = document.createElement("INPUT");
      rawDataForm._optionMAX.type = "input";
      rawDataForm._optionMAX.checked = false;
      rawDataForm._optionMAX.style.display = "inline";
      rawDataForm._optionMAX.type = "checkbox";
      rawDataForm._optionMAX.style.transform = "scale(" + constants.generalSizeCoef.toString() + ")";
      rawDataForm._optionMAX.style.marginRight = Math.round(5 * constants.generalSizeCoef).toString() + "px";
      rawDataForm._optionMAX.addEventListener("change", () => {
        rawDataForm.refresh();
      });
      rawDataForm._optionsList.append(rawDataForm._optionMAX);
      span = document.createElement("SPAN");
      span.innerText = "Include maximum values";
      rawDataForm._optionsList.append(span);
      rawDataForm._optionsList.append(document.createElement("BR"));
      rawDataForm._optionsList.append(document.createElement("BR"));
      let p = document.createElement("P");
      p.style.textAlign = "center";
      let refreshBtn = new button("refresh", () => {
        rawDataForm.refresh();
      });
      p.appendChild(refreshBtn.Element);
      let ExportBtn = new button("export", () => {
        rawDataForm.export();
      });
      p.appendChild(ExportBtn.Element);
      rawDataForm._optionsList.append(p);
      rawDataForm._datacontents = document.createElement("DIV");
      rawDataForm._datacontents.style.position = "absolute";
      rawDataForm._datacontents.style.left = constants.WindowPadding.toString() + "px";
      rawDataForm._datacontents.style.right = constants.WindowPadding.toString() + "px";
      rawDataForm._datacontents.style.top = (rawDataForm.topMargin * constants.generalSizeCoef + 5 * constants.WindowPadding).toString() + "px";
      rawDataForm._datacontents.style.bottom = (4 * constants.WindowPadding + rawDataForm.STATUSLINEHEIGHT * constants.generalSizeCoef).toString() + "px";
      rawDataForm._datacontents.style.paddingLeft = "5px";
      rawDataForm._datacontents.style.paddingRight = "5px";
      rawDataForm._datacontents.style.overflowX = "auto";
      rawDataForm._datacontents.style.paddingRight = "5px";
      rawDataForm._contents.append(rawDataForm._datacontents);
      rawDataForm._dataTable = document.createElement("TABLE");
      rawDataForm._dataTable.style.position = "absolute";
      rawDataForm._dataTable.style.overflow = "auto";
      rawDataForm._dataTable.style.left = "0px";
      rawDataForm._dataTable.style.width = "100%";
      rawDataForm._dataTable.style.top = "0px";
      rawDataForm._dataTable.style.bottom = "0px";
      rawDataForm._dataTable.style.fontSize = constants.generalFontSize.toString() + "px";
      rawDataForm._dataTable.style.borderCollapse = "colapse";
      rawDataForm._dataTable.style.borderSpacing = "0px";
      rawDataForm._dataTable.style.fontFamily = "sans-serif";
      rawDataForm._datacontents.appendChild(rawDataForm._dataTable);
    }
    rawDataForm._window.show();
    rawDataForm.refresh();
  }
  static refresh() {
    let list = [];
    for (let i = 0; i < sensorsManager.sensorList.length; i++) {
      if (!(sensorsManager.sensorList[i] instanceof NullYSensor)) {
        list.push(sensorsManager.sensorList[i]);
      }
    }
    rawDataForm._selection = [];
    for (let i = 0; i < list.length; i++) {
      let spanNode;
      let spanText;
      let input;
      if (i >= rawDataForm._sensorsList.childNodes.length) {
        spanNode = document.createElement("SPAN");
        input = document.createElement("INPUT");
        input.type = "input";
        input.checked = false;
        input.style.display = "inline";
        input.type = "checkbox";
        input.style.transform = "scale(" + constants.generalSizeCoef.toString() + ")";
        input.style.marginRight = Math.round(5 * constants.generalSizeCoef).toString() + "px";
        input.addEventListener("change", () => {
          rawDataForm.refresh();
        });
        spanNode.appendChild(input);
        spanText = document.createElement("SPAN");
        spanNode.appendChild(spanText);
        rawDataForm._sensorsList.appendChild(spanNode);
        spanNode.appendChild(document.createElement("BR"));
      } else {
        spanNode = rawDataForm._sensorsList.childNodes[i];
        input = spanNode.childNodes[0];
        spanText = spanNode.childNodes[1];
      }
      if (input.checked)
        rawDataForm._selection.push(list[i]);
      input.id = list[i].get_hardwareId();
      spanText.innerText = list[i].get_friendlyName();
    }
    while (rawDataForm._sensorsList.childNodes.length > list.length) {
      rawDataForm._sensorsList.removeChild(rawDataForm._sensorsList.lastChild);
    }
    rawDataForm.RefreshContents(rawDataForm._selection);
  }
  static padStart(st, length) {
    while (st.length < length) {
      st = "0" + st;
    }
    return st;
  }
  static UnixTimeStampTostring(ts) {
    let d = new Date(Date.UTC(1970, 0, 1));
    d.setUTCSeconds(ts >> 0, 1e3 * (ts % 1));
    return d.getFullYear().toString() + "-" + rawDataForm.padStart((d.getMonth() + 1).toString(), 2) + "-" + rawDataForm.padStart(d.getDate().toString(), 2) + " " + rawDataForm.padStart(d.getHours().toString(), 2) + ":" + rawDataForm.padStart(d.getMinutes().toString(), 2) + ":" + rawDataForm.padStart((d.getSeconds() + d.getMilliseconds() / 1e3).toFixed(3), 6);
  }
  static RefreshContents(slist) {
    let TH = document.createElement("THEAD");
    let TB = document.createElement("TBODY");
    let HR1 = document.createElement("TR");
    let HR2 = document.createElement("TR");
    let indexes = [];
    for (let i = 0; i < slist.length; i++) {
      indexes.push(slist[i].curData.length - 1);
    }
    while (rawDataForm._dataTable.childNodes.length > 0) {
      rawDataForm._dataTable.removeChild(rawDataForm._dataTable.lastChild);
    }
    rawDataForm._dataTable.appendChild(TH);
    rawDataForm._dataTable.appendChild(TB);
    let sMin = false;
    let sMax = false;
    let sAvg = false;
    let toShow = 0;
    if (rawDataForm._optionMIN.checked) {
      sMin = true;
      toShow++;
    }
    if (rawDataForm._optionAVG.checked) {
      sAvg = true;
      toShow++;
    }
    if (rawDataForm._optionMAX.checked) {
      sMax = true;
      toShow++;
    }
    TH.appendChild(HR1);
    TH.appendChild(HR2);
    let cell = document.createElement("TH");
    HR1.appendChild(cell);
    cell = document.createElement("TH");
    HR2.appendChild(cell);
    for (let i = 0; i < slist.length; i++) {
      cell = document.createElement("TH");
      cell.innerText = slist[i].get_friendlyName();
      cell.colSpan = Math.max(1, toShow);
      cell.style.backgroundColor = "#f0f0f0";
      cell.style.borderLeft = constants.WindowInnerBorder;
      cell.style.borderRight = constants.WindowInnerBorder;
      cell.style.borderTop = constants.WindowInnerBorder;
      HR1.appendChild(cell);
      if (sMin) {
        cell = document.createElement("TH");
        cell.innerText = "Min";
        cell.style.borderLeft = constants.WindowInnerBorder;
        cell.style.borderRight = sAvg || sMax ? "" : constants.WindowInnerBorder;
        cell.style.backgroundColor = "#f0f0f0";
        cell.style.textAlign = "right";
        HR2.appendChild(cell);
      }
      if (sAvg) {
        cell = document.createElement("TH");
        cell.innerText = "Avg";
        cell.style.borderLeft = sMin ? "" : constants.WindowInnerBorder;
        cell.style.borderRight = sMax ? "" : constants.WindowInnerBorder;
        cell.style.backgroundColor = "#f0f0f0";
        cell.style.textAlign = "right";
        HR2.appendChild(cell);
      }
      if (sMax) {
        cell = document.createElement("TH");
        cell.innerText = "Max";
        cell.style.borderLeft = sAvg || sMin ? "" : constants.WindowInnerBorder;
        cell.style.borderRight = constants.WindowInnerBorder;
        cell.style.backgroundColor = "#f0f0f0";
        cell.style.textAlign = "right";
        HR2.appendChild(cell);
      }
    }
    let colcount = slist.length * toShow;
    let MaxTimeStamp = 0;
    for (let i = 0; i < slist.length; i++) {
      if (indexes[i] >= 0) {
        if (MaxTimeStamp < slist[i].curData[indexes[i]].DateTime) {
          MaxTimeStamp = slist[i].curData[indexes[i]].DateTime;
        }
      }
    }
    let rowcount = 0;
    let currentRow = null;
    while (MaxTimeStamp > 0 && rowcount < rawDataForm.MAXRAWDATAROWS) {
      let row = new Array(colcount);
      let nextTimeStamp = 0;
      for (let i = 0; i < slist.length; i++) {
        let Shown = false;
        if (indexes[i] >= 0) {
          if (slist[i].curData[indexes[i]].DateTime == MaxTimeStamp) {
            let n = 0;
            if (sMin) {
              row[n + i * toShow] = slist[i].minData[indexes[i]].value.toString();
              n++;
            }
            if (sAvg) {
              row[n + i * toShow] = slist[i].curData[indexes[i]].value.toString();
              n++;
            }
            if (sMax) {
              row[n + i * toShow] = slist[i].maxData[indexes[i]].value.toString();
              n++;
            }
            Shown = true;
            indexes[i]--;
          }
          if (indexes[i] >= 0) {
            if (slist[i].curData[indexes[i]].DateTime > nextTimeStamp) {
              nextTimeStamp = slist[i].curData[indexes[i]].DateTime;
            }
          }
        }
        if (!Shown) {
          let n = 0;
          if (sMin) {
            row[n + i * toShow] = "";
            n++;
          }
          if (sAvg) {
            row[n + i * toShow] = "";
            n++;
          }
          if (sMax) {
            row[n + i * toShow] = "";
            n++;
          }
        }
      }
      if (colcount > 0 && toShow > 0) {
        currentRow = document.createElement("TR");
        let cell2 = document.createElement("TD");
        cell2.innerText = rawDataForm.UnixTimeStampTostring(MaxTimeStamp).toLocaleString();
        cell2.style.borderLeft = constants.WindowInnerBorder;
        cell2.style.borderTop = rowcount == 0 ? constants.WindowInnerBorder : "";
        cell2.style.backgroundColor = "#f0f0f0";
        currentRow.style.backgroundColor = (rowcount & 1) == 0 ? "white" : "#f0f0f0";
        currentRow.appendChild(cell2);
        for (let j = 0; j < row.length; j++) {
          cell2 = document.createElement("TD");
          cell2.innerText = row[j];
          cell2.style.textAlign = "right";
          cell2.style.borderLeft = j % toShow == 0 ? constants.WindowInnerBorder : "";
          cell2.style.borderRight = (j + 1) % toShow == 0 ? constants.WindowInnerBorder : "";
          cell2.style.fontFamily = "monospace";
          currentRow.appendChild(cell2);
        }
        TB.appendChild(currentRow);
        rowcount++;
      }
      MaxTimeStamp = nextTimeStamp;
    }
    if (currentRow != null) {
      for (let i = 0; i < currentRow.childNodes.length; i++) {
        currentRow.childNodes[i].style.borderBottom = constants.WindowInnerBorder;
      }
    }
    if (toShow == 0) {
      rawDataForm._statusline.style.backgroundColor = "#FF8080";
      rawDataForm._statusline.innerText = "No data shown, select at least Min, Avg or Max options in the top-right checkboxes";
    } else if (rowcount == 0) {
      rawDataForm._statusline.style.backgroundColor = "#FF8080";
      rawDataForm._statusline.innerText = "No data shown, select at least one sensor in the list above.";
    } else {
      rawDataForm._statusline.style.backgroundColor = constants.WindowBackgroundColor;
      if (rowcount < rawDataForm.MAXRAWDATAROWS) {
        rawDataForm._statusline.innerText = "These are the last " + rowcount.toString() + " data rows.";
      } else {
        rawDataForm._statusline.innerText = "These are the last " + rowcount.toString() + " data rows.  Use the export feature to get the whole data set.";
      }
    }
  }
  static getCvsdata(slist, sMin, sAvg, sMax) {
    let toShow = 0;
    let indexes = [];
    for (let i = 0; i < slist.length; i++) {
      indexes.push(0);
    }
    if (sMin)
      toShow++;
    if (sAvg)
      toShow++;
    if (sMax)
      toShow++;
    let res;
    let ColumnHeader = "Timestamp";
    for (let i = 0; i < slist.length; i++) {
      let sName = slist[i].toString();
      if (sMin)
        ColumnHeader += ";" + sName + "(min)";
      if (sAvg)
        ColumnHeader += ";" + sName + "(avg)";
      if (sMax)
        ColumnHeader += ";" + sName + "(max)";
    }
    res = ColumnHeader + "\r\n";
    let colcount = slist.length * toShow;
    let MinTimeStamp = Number.POSITIVE_INFINITY;
    for (let i = 0; i < slist.length; i++) {
      if (indexes[i] < slist[i].curData.length) {
        if (MinTimeStamp > slist[i].curData[indexes[i]].DateTime) {
          MinTimeStamp = slist[i].curData[indexes[i]].DateTime;
        }
      }
    }
    while (MinTimeStamp < Number.POSITIVE_INFINITY) {
      let line = "";
      let nextTimeStamp = Number.POSITIVE_INFINITY;
      for (let i = 0; i < slist.length; i++) {
        let Shown = false;
        if (indexes[i] < slist[i].curData.length) {
          if (slist[i].curData[indexes[i]].DateTime == MinTimeStamp) {
            if (sMin)
              line += ";" + slist[i].minData[indexes[i]].value.toString();
            if (sAvg)
              line += ";" + slist[i].curData[indexes[i]].value.toString();
            if (sMax)
              line += ";" + slist[i].maxData[indexes[i]].value.toString();
            Shown = true;
            indexes[i]++;
          }
          if (indexes[i] < slist[i].curData.length) {
            if (slist[i].curData[indexes[i]].DateTime < nextTimeStamp) {
              nextTimeStamp = slist[i].curData[indexes[i]].DateTime;
            }
          }
        }
        if (!Shown) {
          if (sMin)
            line += " ; ";
          if (sAvg)
            line += " ; ";
          if (sMax)
            line += " ; ";
        }
      }
      if (colcount > 0)
        line = rawDataForm.UnixTimeStampTostring(MinTimeStamp) + line;
      res += line + "\r\n";
      MinTimeStamp = nextTimeStamp;
    }
    return res;
  }
  static export() {
    let element = document.createElement("a");
    let data = "data:text/csv;charset=utf-8," + encodeURI(rawDataForm.getCvsdata(rawDataForm._selection, rawDataForm._optionMIN.checked, rawDataForm._optionAVG.checked, rawDataForm._optionMAX.checked));
    element.setAttribute("href", data);
    element.setAttribute("download", "rawdata.csv");
    element.style.display = "none";
    document.body.appendChild(element);
    element.click();
    document.body.removeChild(element);
  }
};
rawDataForm._lines = [];
rawDataForm.topMargin = 100;
rawDataForm.sensorListWidth = 200;
rawDataForm.MAXRAWDATAROWS = 100;
rawDataForm.STATUSLINEHEIGHT = 20;
rawDataForm._selection = [];

// obj/full/windowManager.js
var button = class {
  constructor(caption, action, sizeCoefOverload) {
    this._enabled = true;
    this._visible = true;
    this._caption = "";
    this._caption = caption;
    this._action = action;
    let GUIcoef = constants.generalSizeCoef;
    if (typeof sizeCoefOverload !== "undefined")
      GUIcoef = sizeCoefOverload;
    this._link = document.createElement("A");
    this._link.innerText = this._caption;
    this._link.style.cursor = "pointer";
    this._link.style.display = "inlineblock";
    let padding = Math.round(5 * GUIcoef).toString() + "px";
    let margin = Math.round(3 * GUIcoef).toString() + "px";
    this._link.tabIndex = 0;
    this._link.style.padding = padding + " " + padding + " " + padding + " " + padding;
    this._link.style.margin = margin + " " + margin + " " + margin + " " + margin;
    this._link.style.borderColor = "#808080";
    this._link.style.backgroundColor = "#f0f0f0";
    this._link.style.fontFamily = constants.generalFontFamily;
    this._link.style.fontSize = (16 * GUIcoef).toString() + "px";
    this._link.style.cursor = "pointer";
    this._link.style.border = constants.WindowInnerBorder;
    this._link.addEventListener("mouseover", () => {
      if (this._enabled)
        this._link.style.backgroundColor = "white";
    });
    this._link.addEventListener("mouseout", () => {
      if (this._enabled)
        this._link.style.backgroundColor = "#f0f0f0";
    });
    this._link.addEventListener("click", () => {
      if (this._enabled)
        this._action(this);
    });
    this._link.addEventListener("keypress", (e) => {
      if (this._enabled && (e.key == "Enter" || e.key == " "))
        this._action(this);
    });
  }
  get Element() {
    return this._link;
  }
  set tabIndex(index) {
    this._link.tabIndex = index;
  }
  focus() {
    this._link.focus();
  }
  get visible() {
    return this._visible;
  }
  set visible(value) {
    this._visible = value;
    this._link.style.display = this._visible ? "" : "none";
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    this.enable(value);
  }
  performAction() {
    if (!this._enabled)
      return;
    this._action(this);
  }
  showShortcut(enable) {
    if (!this._enabled)
      enable = false;
    if (enable) {
      this._link.innerHTML = "<u>" + this._caption.substring(0, 1) + "</u>" + this._caption.substring(1);
    } else {
      this._link.innerText = this._caption;
    }
  }
  enable(state) {
    if (state == this._enabled)
      return;
    this._enabled = state;
    this._link.tabIndex = state ? 0 : -1;
    if (this._enabled) {
      this._link.style.cursor = "pointer";
      this._link.style.backgroundColor = "#f0f0f0";
      this._link.style.color = "black";
    } else {
      this._link.style.backgroundColor = "#e0e0e0";
      this._link.style.cursor = "default";
      this._link.style.color = "#A0A0A0";
    }
  }
};
var newWindowParam = class {
  get GUICoef() {
    return this._GUICoef;
  }
  constructor(sizeCoefOverload) {
    this.createNow = false;
    this.left = 100;
    this.top = 100;
    this.positionType = 0;
    this.width = 400;
    this.height = 300;
    this.isModal = false;
    this.showShadow = true;
    this.showContainerBorders = true;
    this.showHeader = true;
    this.title = "new Window";
    this.closeIcon = true;
    this.headerBgColor = "";
    this.bottomKeepClear = 0;
    this.contentsDefaultFontSize = constants.generalFontSize;
    this.contentsDefaultFontFamily = constants.generalFontFamily;
    this.closingCallBack = null;
    this.WindowBackgroundColor = "#f0f0f0";
    this.WindowBorder = "1px solid #808080";
    this.WindowPadding = 2;
    this.WindowInnerBorderColor = " #A0A0A0";
    this.WindowInnerBackgroundColor = "#fAfAfA";
    this.WindowInnerBorder = "1px solid " + this.WindowInnerBorderColor;
    this.WindowHeaderBackgroundColor = "#0072ca";
    this.WindowHeaderColor = "white";
    this.WindowHeaderBorder = "1px solid #0072ca";
    this._GUICoef = constants.generalSizeCoef;
    this.WindowHeaderHeight = Math.round(20 * constants.generalSizeCoef);
    this.WindowHeaderFontSize = 16 * constants.generalSizeCoef;
    this.WindowHeaderFontFamily = constants.generalFontFamily;
    this.buttons = [];
    if (typeof sizeCoefOverload !== "undefined") {
      this.WindowHeaderHeight = 20 * sizeCoefOverload;
      this.WindowHeaderFontSize = 16 * sizeCoefOverload;
      this._GUICoef = sizeCoefOverload;
    }
  }
  clone() {
    let it = new newWindowParam();
    let keys = Object.keys(this);
    for (let i = 0; i < keys.length; i++) {
      if (keys[i] != "buttons")
        it[keys[i]] = this[keys[i]];
    }
    for (let i = 0; i < this.buttons.length; i++) {
      it.buttons.push(this.buttons[i]);
    }
    return it;
  }
};
var YWindow = class {
  static get ConTextMenuBestZindex() {
    for (let i = 0; i < YWindow.windowList.length; i++) {
      if (YWindow.windowList[i].isModal())
        return -1;
    }
    return 1e5 + 2 * YWindow.windowList.length;
  }
  constructor(params) {
    this._div = null;
    this._titleSpan = null;
    this._ModalDivShield = null;
    this._switchSideDiv = null;
    this._buttonsContainer = null;
    this._params = params.clone();
    YWindow.windowList.push(this);
    this._contents = document.createElement("DIV");
    if (params.createNow)
      this.allocate();
  }
  get innerContentDiv() {
    return this._contents;
  }
  get bottomKeepClear() {
    return this._params.bottomKeepClear;
  }
  set bottomKeepClear(value) {
    this._params.bottomKeepClear = value;
    if (this._contents != null) {
      this._contents.style.bottom = (this._params.WindowPadding + this._params.bottomKeepClear).toString() + "px";
    }
  }
  get outterContentDiv() {
    return this._div;
  }
  isModal() {
    if (this._div == null)
      return false;
    return this._div.style.display == "" && this._params.isModal;
  }
  get visible() {
    if (this._div == null)
      return false;
    return this._div.style.display == "";
  }
  set visible(v) {
    v ? this.show() : this.hide();
  }
  show(width) {
    if (this._div == null)
      this.allocate();
    this._div.style.display = "";
    if (this._ModalDivShield != null)
      this._ModalDivShield.style.display = "";
    this.brintToFront();
    if (typeof width !== "undefined" && this._params.positionType == 2) {
      this._div.style.width = width.toString() + "px";
    }
  }
  allocate() {
    if (this._div != null)
      return;
    if (this._params.isModal) {
      this._ModalDivShield = document.createElement("DIV");
      this._ModalDivShield.style.position = "fixed";
      this._ModalDivShield.style.left = "0px";
      this._ModalDivShield.style.top = "0px";
      this._ModalDivShield.style.right = "0px";
      this._ModalDivShield.style.bottom = "0px";
      this._ModalDivShield.style.backgroundColor = "rgba(255,255,255,0.85) ";
      document.body.appendChild(this._ModalDivShield);
    }
    this._div = document.createElement("DIV");
    this._div.style.display = "none";
    switch (this._params.positionType) {
      case 0:
        this._div.style.position = "absolute";
        this._div.style.left = this._params.left.toString() + "px";
        this._div.style.top = this._params.top.toString() + "px";
        this._div.style.width = this._params.width.toString() + "px";
        this._div.style.height = this._params.height.toString() + "px";
        break;
      case 1:
        this._div.style.position = "absolute";
        this._div.style.left = "50%";
        this._div.style.top = "50%";
        this._div.style.transform = "translate(-50%, -50%)";
        this._div.style.width = this._params.width.toString() + "px";
        this._div.style.height = this._params.height.toString() + "px";
        break;
      case 2:
        this._div.style.position = "fixed";
        this._div.style.top = "5px";
        this._div.style.right = "5px";
        this._div.style.bottom = "5px";
        this._div.style.width = this._params.width.toString() + "px";
        break;
    }
    this._div.style.border = this._params.WindowBorder;
    this._div.style.backgroundColor = this._params.WindowBackgroundColor;
    if (this._params.showShadow)
      this._div.style.boxShadow = " 4px 4px 4px 1px rgba(0,0,0,0.05)";
    let containerTop = this._params.WindowPadding;
    if (this._params.showHeader) {
      containerTop = this._params.WindowHeaderHeight + 3 * this._params.WindowPadding;
      let title = document.createElement("DIV");
      title.style.position = "absolute";
      title.style.left = this._params.WindowPadding.toString() + "px";
      title.style.top = this._params.WindowPadding.toString() + "px";
      title.style.right = this._params.WindowPadding.toString() + "px";
      title.style.height = this._params.WindowHeaderHeight.toString() + "px";
      title.style.border = this._params.WindowHeaderBorder;
      title.style.backgroundColor = this._params.WindowHeaderBackgroundColor;
      title.style.fontFamily = this._params.WindowHeaderFontFamily;
      title.style.color = this._params.WindowHeaderColor;
      title.style.fontSize = this._params.WindowHeaderFontSize.toString() + "px";
      title.style.paddingLeft = "5px";
      title.style.whiteSpace = "nowrap";
      title.addEventListener("click", () => {
        this.brintToFront();
      });
      this._titleSpan = document.createElement("SPAN");
      this._titleSpan.innerText = this._params.title;
      title.appendChild(this._titleSpan);
      if (this._params.closeIcon) {
        let closeDiv = document.createElement("DIV");
        closeDiv.style.position = "absolute";
        closeDiv.style.right = "0px";
        closeDiv.style.top = "0px";
        closeDiv.style.width = Math.round(this._params.WindowHeaderHeight + 5).toString() + "px";
        closeDiv.style.height = this._params.WindowHeaderHeight.toString() + "px";
        closeDiv.style.overflow = "hide";
        closeDiv.style.paddingLeft = "5px";
        closeDiv.tabIndex = 0;
        closeDiv.style.cursor = "pointer";
        closeDiv.style.backgroundColor = this._params.WindowHeaderBackgroundColor;
        closeDiv.innerHTML = ressources.CloseIcon(this._params.WindowHeaderHeight.toString(), false, false, false, false, "Click to close this window");
        closeDiv.addEventListener("click", () => {
          this.hide();
        });
        closeDiv.addEventListener("keypress", (e) => {
          if (e.key == "Enter")
            this.hide();
        });
        title.appendChild(closeDiv);
      }
      if (this._params.positionType == 2) {
        this._switchSideDiv = document.createElement("DIV");
        this._switchSideDiv.style.position = "absolute";
        this._switchSideDiv.style.width = Math.round(this._params.WindowHeaderHeight + 5).toString() + "px";
        this._switchSideDiv.style.right = Math.round(this._params.WindowHeaderHeight + 5) + "px";
        this._switchSideDiv.style.height = this._params.WindowHeaderHeight.toString() + "px";
        this._switchSideDiv.style.overflow = "hide";
        this._switchSideDiv.style.paddingLeft = "5px";
        this._switchSideDiv.style.top = "0px";
        this._switchSideDiv.style.cursor = "pointer";
        this._switchSideDiv.style.backgroundColor = this._params.WindowHeaderBackgroundColor;
        this._switchSideDiv.innerHTML = ressources.MoveToLeftIcon(this._params.WindowHeaderHeight.toString(), false, false, false, false, "Click to move editor on left side");
        this._switchSideDiv.addEventListener("click", () => {
          this.switchSide();
        });
        title.appendChild(this._switchSideDiv);
      }
      this._div.appendChild(title);
    }
    if (this._params.buttons.length > 0) {
      this._buttonsContainer = document.createElement("DIV");
      this._buttonsContainer.style.position = "absolute";
      this._buttonsContainer.style.bottom = Math.round(this._params.WindowPadding).toString() + "px";
      this._buttonsContainer.style.right = Math.round(this._params.WindowPadding).toString() + "px";
      this._buttonsContainer.style.textAlign = "right";
      for (let i = 0; i < this._params.buttons.length; i++) {
        this._buttonsContainer.appendChild(this._params.buttons[i].Element);
      }
      this._div.appendChild(this._buttonsContainer);
      this._buttonsContainer.style.height = (25 * this._params.GUICoef).toString() + "px";
      this._params.bottomKeepClear += Math.round(35 * this._params.GUICoef);
    }
    this._contents.style.position = "absolute";
    this._contents.style.left = this._params.WindowPadding.toString() + "px";
    this._contents.style.right = this._params.WindowPadding.toString() + "px";
    this._contents.style.top = containerTop.toString() + "px";
    this._contents.style.bottom = (this._params.WindowPadding + this._params.bottomKeepClear).toString() + "px";
    this._contents.style.paddingLeft = "5px";
    this._contents.style.paddingRight = "5px";
    if (this._contents.style.fontSize == "") {
      this._contents.style.fontSize = this._params.contentsDefaultFontSize.toString() + "px";
    }
    if (this._contents.style.fontFamily == "") {
      this._contents.style.fontFamily = this._params.contentsDefaultFontFamily;
    }
    if (this._params.showContainerBorders) {
      this._contents.style.border = this._params.WindowInnerBorder;
      this._contents.style.backgroundColor = this._params.WindowInnerBackgroundColor;
    } else {
      this._contents.style.border = "1px solid rgba(0, 0, 0, 0)";
      this._contents.style.backgroundColor = "";
    }
    this._contents.style.overflow = "hide";
    this._div.append(this._contents);
    document.body.appendChild(this._div);
  }
  hide() {
    if (this._div == null)
      return;
    this._div.style.display = "none";
    if (this._ModalDivShield != null)
      this._ModalDivShield.style.display = "none";
    if (this._params.closingCallBack != null)
      this._params.closingCallBack(this);
  }
  set title(value) {
    this._params.title = value;
    if (this._titleSpan != null) {
      this._titleSpan.innerText = value;
    }
  }
  brintToFront() {
    let n = -1;
    for (let i = 0; i < YWindow.windowList.length; i++) {
      if (YWindow.windowList[i] == this)
        n = i;
    }
    if (n < 0)
      return;
    YWindow.windowList.splice(n, 1);
    YWindow.windowList.push(this);
    for (let i = 0; i < YWindow.windowList.length; i++) {
      YWindow.windowList[i].zIndex = i;
    }
  }
  set zIndex(index) {
    if (this._div == null)
      return;
    this._div.style.zIndex = (100001 + 2 * index).toString();
    if (this._params.isModal)
      this._ModalDivShield.style.zIndex = (1e5 + 2 * index).toString();
  }
  switchSide() {
    if (this._div.style.left == "") {
      this._div.style.left = "5px";
      this._div.style.right = "";
      this._switchSideDiv.innerHTML = ressources.MoveToRightIcon(Math.round(20 * this._params.GUICoef).toString(), false, false, false, false, "Click to move editor on right side");
    } else {
      this._div.style.left = "";
      this._div.style.right = "5px";
      this._switchSideDiv.innerHTML = ressources.MoveToLeftIcon(Math.round(20 * this._params.GUICoef).toString(), false, false, false, false, "Click to move editor on left side");
    }
  }
};
YWindow.windowList = [];
var confirm = class {
  static ask(message, yes, no, userdata) {
    let params = new newWindowParam();
    params.positionType = 1;
    params.width = Math.min(Math.round(400 * constants.generalSizeCoef), Math.round(screen.width * 0.9));
    params.height = Math.min(Math.round(160 * constants.generalSizeCoef), Math.round(screen.height * 0.7));
    params.isModal = true;
    params.showHeader = false;
    params.showContainerBorders = false;
    let YesButton = new button("Yes", () => {
      confirm._window.hide();
      if (yes != null)
        yes(userdata);
    });
    let NoButton = new button("No", () => {
      confirm._window.hide();
      if (no != null)
        no(userdata);
    });
    params.buttons.push(YesButton);
    params.buttons.push(NoButton);
    confirm._window = new YWindow(params);
    let contents = confirm._window.innerContentDiv;
    let table = document.createElement("TABLE");
    table.style.width = "100%";
    let TR = document.createElement("TR");
    let TD = document.createElement("TD");
    TD.style.width = "10";
    TD.innerHTML = ressources.DontKnowIcon(Math.round(80 * constants.generalSizeCoef).toString(), true, false, false, false, "");
    TR.appendChild(TD);
    TD = document.createElement("TD");
    TD.style.paddingLeft = "20px";
    TD.style.fontFamily = constants.generalFontFamily;
    TD.style.fontSize = constants.generalFontSize.toString() + "px";
    TD.style.textAlign = "justify";
    TD.innerText = message;
    TR.appendChild(TD);
    table.appendChild(TR);
    contents.appendChild(table);
    confirm._window.show();
    return confirm._window;
  }
};
var notififaction = class {
  static show(icon, message) {
    let params = new newWindowParam();
    params.positionType = 1;
    params.width = Math.min(Math.round(400 * constants.generalSizeCoef), screen.width);
    params.height = Math.min(Math.round(160 * constants.generalSizeCoef), screen.height);
    params.isModal = true;
    params.showHeader = false;
    params.showContainerBorders = false;
    let okButton = new button("OK", () => {
      alert2._window.hide();
    });
    params.buttons.push(okButton);
    alert2._window = new YWindow(params);
    let contents = alert2._window.innerContentDiv;
    let table = document.createElement("TABLE");
    table.style.width = "100%";
    let TR = document.createElement("TR");
    let TD = document.createElement("TD");
    TD.style.width = "10";
    TD.innerHTML = icon;
    TR.appendChild(TD);
    TD = document.createElement("TD");
    TD.style.paddingLeft = "20px";
    TD.style.fontFamily = constants.generalFontFamily;
    TD.style.fontSize = constants.generalFontSize.toString() + "px";
    TD.style.textAlign = "justify";
    TD.innerText = message;
    TR.appendChild(TD);
    table.appendChild(TR);
    contents.appendChild(table);
    alert2._window.show();
    return alert2._window;
  }
};
var alert2 = class extends notififaction {
  static show(message) {
    return super.show(ressources.FailedIcon(Math.round(80 * constants.generalSizeCoef).toString(), true, false, false, false, ""), message);
  }
};

// obj/full/mainForm_rw.js
var mainForm = class {
  constructor() {
    this.GUIcoef = 1;
    let params = new newWindowParam();
    params.positionType = 1;
    this.GUIcoef = constants.generalSizeCoef;
    if (mainForm.REFWIDH * this.GUIcoef > screen.width)
      this.GUIcoef = screen.width / mainForm.REFWIDH;
    if (mainForm.REFHEIGHT * this.GUIcoef > screen.height)
      this.GUIcoef = screen.height / mainForm.REFHEIGHT;
    params.width = Math.round(mainForm.REFWIDH * this.GUIcoef);
    params.height = Math.round(mainForm.REFHEIGHT * this.GUIcoef);
    params.showHeader = false;
    params.showContainerBorders = false;
    this._window = new YWindow(params);
    let contents = this._window.innerContentDiv;
    let title = document.createElement("p");
    title.style.paddingTop = "0px";
    title.style.marginTop = 4 * this.GUIcoef + "px";
    title.style.fontSize = 16 * this.GUIcoef + "px";
    title.innerText = "Hello, welcome to Yocto-Visualization, what would you like to do?";
    title.style.textAlign = "center";
    contents.appendChild(title);
    let table = document.createElement("TABLE");
    table.style.position = "absolute";
    table.style.top = "0px";
    table.style.fontFamily = constants.generalFontFamily;
    table.style.tableLayout = "fixed";
    table.style.paddingLeft = Math.round(10 * this.GUIcoef).toString() + "px";
    table.style.paddingRight = Math.round(10 * this.GUIcoef).toString() + "px";
    table.style.paddingTop = Math.round(30 * this.GUIcoef).toString() + "px";
    table.style.paddingBottom = Math.round(15 * this.GUIcoef).toString() + "px";
    table.style.width = "100%";
    table.style.height = "100%";
    table.style.borderSpacing = Math.round(5 * this.GUIcoef).toString() + "px";
    let tr1 = document.createElement("TR");
    table.appendChild(tr1);
    let td11 = document.createElement("TD");
    tr1.appendChild(td11);
    let td12 = document.createElement("TD");
    tr1.appendChild(td12);
    let td13 = document.createElement("TD");
    tr1.appendChild(td13);
    let tr2 = document.createElement("TR");
    table.appendChild(tr2);
    let td21 = document.createElement("TD");
    tr2.appendChild(td21);
    let td22 = document.createElement("TD");
    tr2.appendChild(td22);
    let td23 = document.createElement("TD");
    tr2.appendChild(td23);
    contents.appendChild(table);
    let version = document.createElement("p");
    version.style.position = "absolute";
    version.style.right = "0px";
    version.style.bottom = "0px";
    version.style.marginBottom = "0px";
    version.style.paddingBottom = "0px";
    version.style.marginRight = "2px";
    version.style.fontSize = (8 * this.GUIcoef).toString() + "px";
    version.innerText = constants.buildVersion;
    version.style.color = "grey";
    version.style.textAlign = "right";
    contents.appendChild(version);
    let size = (128 * this.GUIcoef).toString();
    this.createButton(td11, "Configure global parameters", ressources.ConfigureIcon(size, true, false, false, false), () => {
      this.openConfig();
    });
    this.createButton(td12, "Create a new solid gauge", ressources.SolidGaugeIcon(size, true, false, false, false), () => {
      YWebPage.newGaugeWidget();
    });
    this.createButton(td13, "Create a new graph", ressources.GraphIcon(size, true, false, false, false), () => {
      YWebPage.newGraphWidget();
    });
    this.createButton(td21, "Get Raw data", ressources.RawDataIcon(size, true, false, false, false), () => {
      this.openRawData();
    });
    this.createButton(td22, "Create a new digital display", ressources.DigitalDisplayIcon(size, true, false, false, false), () => {
      YWebPage.newDigitalDisplayWidget();
    });
    this.createButton(td23, "Create a new angular gauge", ressources.AngularGaugeIcon(size, true, false, false, false), () => {
      YWebPage.newAngularGaugeWidget();
    });
  }
  hide() {
    this._window.hide();
  }
  show() {
    this._window.show();
  }
  createButton(container, caption, icon, callback) {
    container.style.border = "1px solid black";
    container.style.textAlign = "center";
    container.style.fontSize = (10 * this.GUIcoef).toString() + "px";
    container.style.paddingBottom = "3px";
    container.style.borderColor = "#808080";
    container.style.backgroundColor = "#f0f0f0";
    container.style.cursor = "pointer";
    container.addEventListener("mouseover", function() {
      container.style.backgroundColor = "white";
    });
    container.addEventListener("mouseout", function() {
      container.style.backgroundColor = "#f0f0f0";
    });
    let a = document.createElement("a");
    a.style.outline = "none";
    a.innerHTML = icon + "<br>" + caption;
    a.addEventListener("click", callback);
    a.tabIndex = 0;
    a.addEventListener("focusin", () => {
      container.style.backgroundColor = "white";
    });
    a.addEventListener("focusout", () => {
      container.style.backgroundColor = "f0f0f0";
    });
    a.addEventListener("keypress", (e) => {
      if (e.key == "Enter")
        callback();
    });
    container.appendChild(a);
  }
  openConfig() {
    configForm.show();
  }
  openRawData() {
    rawDataForm.show();
  }
};
mainForm.REFWIDH = 500;
mainForm.REFHEIGHT = 360;

// obj/full/Editor_rw.js
var EditedDataSource = class {
  constructor(source, root) {
    this._htmlchilds = [];
    this._source = source;
    this._root = root;
    this._htmlchilds = [];
  }
  storeChilds(childsList) {
    this._htmlchilds = [];
    for (let i = 0; i < childsList.length; i++) {
      this._htmlchilds.push(childsList.item(i));
    }
  }
  getStoredChilds() {
    return this._htmlchilds;
  }
  get root() {
    return this._root;
  }
  refresh() {
    if (this._root != null)
      this._root.refresh();
  }
};
var keyDataObject = class {
  constructor(key, data) {
    this.key = key;
    this.data = data;
  }
};
var objectDictionnary = class {
  constructor() {
    this.list = [];
  }
  isInlist(key) {
    for (let i = 0; i < this.list.length; i++) {
      if (key == this.list[i].key)
        return true;
    }
    return false;
  }
  find(key) {
    for (let i = 0; i < this.list.length; i++) {
      if (key == this.list[i].key)
        return this.list[i].data;
    }
    return null;
  }
  insert(key, data) {
    for (let i = 0; i < this.list.length; i++) {
      if (key == this.list[i].key) {
        this.list[i].data = data;
        return;
      }
    }
    this.list.push(new keyDataObject(key, data));
  }
};
var EditorBaseDef = class {
  refresh() {
  }
  get panel() {
    return null;
  }
  get expanded() {
    return true;
  }
  AllocateControls() {
  }
};
var PropertiesForm2 = class extends EditorBaseDef {
  get visible() {
    return this._window.visible;
  }
  set visible(v) {
    v ? this.show() : this.hide();
  }
  get text() {
    return this._text;
  }
  set text(value) {
    this._text = value;
    this._window.title = this._text;
  }
  get help() {
    return this._helpText;
  }
  set help(value) {
    this._helpText = value;
    this._helpPanel.innerHTML = this._helpText;
  }
  addTest(parentDiv) {
    PropertiesForm2.testid++;
    let mainlabel = document.createElement("DIV");
    mainlabel.style.position = "relative";
    mainlabel.style.display = "inline-block;";
    mainlabel.style.left = "0px";
    mainlabel.style.padding = "2px 2px 2px 2px";
    mainlabel.style.right = "5px";
    mainlabel.style.border = "1px solid black";
    mainlabel.style.marginTop = "2px";
    mainlabel.style.backgroundColor = "yellow";
    if (parentDiv != null) {
      parentDiv.appendChild(mainlabel);
    } else {
      this._container.appendChild(mainlabel);
    }
    let expandCtrl = document.createElement("ANCHOR");
    expandCtrl.innerText = "[+]";
    mainlabel.appendChild(expandCtrl);
    let mainText = document.createElement("SPAN");
    mainText.innerText = "Pouet " + PropertiesForm2.testid.toString();
    mainlabel.appendChild(mainText);
    let subElementPanel = document.createElement("DIV");
    subElementPanel.style.position = "relative";
    subElementPanel.style.display = "inline-block;";
    subElementPanel.style.left = "5px";
    subElementPanel.style.padding = "2px 2px 2px 2px";
    subElementPanel.style.right = "5px";
    subElementPanel.style.marginTop = "2px";
    subElementPanel.style.backgroundColor = "lightgray";
    subElementPanel.innerText = "sub elements";
    if (parentDiv != null) {
      parentDiv.appendChild(subElementPanel);
    } else {
      this._container.appendChild(subElementPanel);
    }
    return subElementPanel;
  }
  editorIsClosing(source) {
    if (this._editorClosedCallback != null)
      this._editorClosedCallback();
  }
  bestWidth() {
    let w = window.innerWidth / 4 >> 0;
    let minWidth = 275 * constants.guiDPIFactor;
    if (w < minWidth)
      w = minWidth;
    if (w > window.innerWidth - 10)
      w = window.innerWidth - 10;
    return w;
  }
  constructor() {
    super();
    this._hostWindow = null;
    this._editorClosedCallback = null;
    this.currentEditedDataSource = null;
    this._changeCallback = null;
    this._getvalueCallback = null;
    this._text = "Properties editor";
    this._helpText = "Properties editor";
    this.EditedDataSourceList = new objectDictionnary();
    let params = new newWindowParam();
    params.positionType = 2;
    params.width = this.bestWidth();
    params.createNow = true;
    params.closingCallBack = (source) => {
      this.editorIsClosing(source);
    };
    params.bottomKeepClear = PropertiesForm2.HelpHeight + 3 * constants.WindowPadding;
    params.title = this._text;
    this._window = new YWindow(params);
    this._container = this._window.innerContentDiv;
    this._helpPanel = document.createElement("DIV");
    this._helpPanel.style.position = "absolute";
    this._helpPanel.style.left = constants.WindowPadding.toString() + "px";
    this._helpPanel.style.bottom = constants.WindowPadding.toString() + "px";
    this._helpPanel.style.right = constants.WindowPadding.toString() + "px";
    this._helpPanel.style.height = PropertiesForm2.HelpHeight.toString() + "px";
    this._helpPanel.style.paddingLeft = "5px";
    this._helpPanel.style.paddingTop = "5px";
    this._helpPanel.style.overflowY = "auto";
    this._helpPanel.style.border = constants.WindowInnerBorder;
    this._helpPanel.style.backgroundColor = constants.WindowInnerBackgroundColor;
    this._helpPanel.style.fontFamily = constants.generalFontFamily;
    this._helpPanel.style.fontSize = constants.generalFontSize.toString() + "px";
    this._helpPanel.style.color = "black";
    this._helpPanel.style.display = "";
    this._helpPanel.innerHTML = "Help panel. Editor is loading, please wait....";
    this._window.outterContentDiv.appendChild(this._helpPanel);
    this._container.style.overflowY = "scroll";
    this._container.style.overflowX = "hidden";
    this._container.style.backgroundColor = constants.WindowInnerBackgroundColor;
    window.addEventListener("resize", () => {
      this.windowResized();
    });
  }
  windowResized() {
    if (this._window.innerContentDiv == null)
      return;
    if (this._window.innerContentDiv.offsetHeight < PropertiesForm2.MinHeightforShowingHelp && this._helpPanel.style.display == "") {
      this._helpPanel.style.display = "none";
      this._window.bottomKeepClear = 0;
    } else if (this._window.innerContentDiv.offsetHeight >= PropertiesForm2.MinHeightforShowingHelp + PropertiesForm2.HelpHeight && this._helpPanel.style.display != "") {
      this._helpPanel.style.display = "";
      this._window.bottomKeepClear = PropertiesForm2.HelpHeight;
    }
  }
  show() {
    this._window.show(this.bestWidth());
    this.windowResized();
  }
  hide() {
    YWidget.stopEdition();
    this._window.hide();
  }
  get panel() {
    return this._container;
  }
  refresh() {
    if (!this.visible)
      return;
    if (this.currentEditedDataSource == null)
      return;
    this.currentEditedDataSource.refresh();
  }
  refreshBanner() {
    if (this._hostWindow != null) {
      this.text = "Properties of " + this._hostWindow.Text;
    }
  }
  showWindow(hostWindow, structData, setvalueCallBack, getvalueCallBack, EditStoppedCallBack) {
    this._hostWindow = hostWindow;
    this._changeCallback = setvalueCallBack;
    this._getvalueCallback = getvalueCallBack;
    this.text = "Properties editor";
    this.show();
    this.refreshBanner();
    this.EditObject(structData, setvalueCallBack, getvalueCallBack, EditStoppedCallBack);
  }
  EditObject(structData, setvalueCallBack, getvalueCallBack, EditStoppedCallBack) {
    this._editorClosedCallback = EditStoppedCallBack;
    let helpYourselfMsg = "This is the property editor. Change any parameter you want. All changes are applied in real time.";
    if (!this.visible)
      return;
    this.help = "Please wait....";
    if (this.EditedDataSourceList.isInlist(structData)) {
      if (this.EditedDataSourceList.find(structData) == this.currentEditedDataSource) {
        this.help = helpYourselfMsg;
        return;
      }
    }
    if (this.currentEditedDataSource != null) {
      this.currentEditedDataSource.root.stopEdit();
      this.currentEditedDataSource.storeChilds(this._container.childNodes);
      while (this._container.firstChild) {
        this._container.removeChild(this._container.lastChild);
      }
    }
    let it;
    if (!this.EditedDataSourceList.isInlist(structData)) {
      let rootparam = new UIElementBaseParams(this._helpPanel, this, null, "root", "Root", "root node", "");
      it = new UIElement(rootparam);
      it.rootEditor = this;
      this.currentEditedDataSource = new EditedDataSource(structData, it);
      this.EditedDataSourceList.insert(structData, this.currentEditedDataSource);
      it.showLabel = false;
      it.expandable = true;
      it.ProcessNewType(structData);
      it.expanded = true;
    } else {
      this.currentEditedDataSource = this.EditedDataSourceList.find(structData);
      let childNodes = this.currentEditedDataSource.getStoredChilds();
      for (let i = 0; i < childNodes.length; i++) {
        this._container.appendChild(childNodes[i]);
      }
      this.currentEditedDataSource.refresh();
    }
    this.currentEditedDataSource.root.startEdit(setvalueCallBack, getvalueCallBack);
    this.currentEditedDataSource.root.resizeAll();
    this.help = helpYourselfMsg;
  }
  getConfigData() {
    let p = this._window.outterContentDiv.getBoundingClientRect();
    return "<PropertiesForm>\n<location x='" + p.left.toString() + "' y='" + p.top.toString() + "'/>\n<size     w='" + p.width.toString() + "' h='" + p.width.toString() + "'/>\n</PropertiesForm>\n";
  }
  Form1_SizeChanged(sender) {
    if (this.currentEditedDataSource == null)
      return;
    if (this.currentEditedDataSource.root != null)
      this.currentEditedDataSource.root.resizeAll();
  }
  valuechange(src) {
    let OriginalPropName = "";
    let fullpropname = "";
    let propType = "";
    if (this._changeCallback != null)
      this._changeCallback(src);
  }
};
PropertiesForm2.HelpHeight = Math.round(75 * constants.generalSizeCoef);
PropertiesForm2.MinHeightforShowingHelp = 175;
PropertiesForm2.testid = 0;

// obj/full/UIElements_rw.js
var UIElementBaseParams = class {
  constructor(p_descriptionLabel, p_parentNode, p_RootNode, p_internalname, p_label, p_description, p_isReadonlyCall) {
    this.expandable = false;
    this.isReadonlyCall = "";
    this.summary = null;
    this.structRoot = null;
    this.HelpZoneLabel = p_descriptionLabel;
    this.parentNode = p_parentNode;
    this.RootNode = p_RootNode;
    this.internalname = p_internalname;
    this.label = p_label;
    this.description = p_description;
    this.changeCausesParentRefresh = false;
    this.preExpanded = false;
    this.isReadonlyCall = p_isReadonlyCall;
  }
};
var PropPathinfo = class {
  constructor() {
    this.OriginalPropName = "";
    this.fullpropname = "";
    this.propType = "";
  }
};
var CustomAttributesExtractor = class {
  constructor(ps) {
    this.available = true;
    this.displayName = "unknown";
    this.category = "";
    this.displayDescription = "Not documented";
    this.prefinedValues = null;
    this.changeCausesParentRefresh = false;
    this.PreExpandedCategory = false;
    this.PreExpanded = false;
    this.summaryPropertyName = "";
    this.isReadOnlyCall = "";
    this.NotSavedInXML = false;
    this.ReadOnly = false;
    this.ParamCategorySummary = "";
    if ("OnlyAvailableon" in ps.Attributes)
      this.available = ps.Attributes["OnlyAvailableon"];
    if ("DisplayName" in ps.Attributes)
      this.displayName = ps.Attributes["DisplayName"];
    if ("CategoryAttribute" in ps.Attributes)
      this.category = ps.Attributes["CategoryAttribute"];
    if ("DescriptionAttribute" in ps.Attributes)
      this.displayDescription = ps.Attributes["DescriptionAttribute"];
    if ("AllowedValues" in ps.Attributes)
      this.prefinedValues = ps.Attributes["AllowedValues"];
    if ("ChangeCausesParentRefreshAttribute" in ps.Attributes)
      this.changeCausesParentRefresh = ps.Attributes["ChangeCausesParentRefreshAttribute"];
    if ("PreExpandedCategoryAttribute" in ps.Attributes)
      this.PreExpandedCategory = ps.Attributes["PreExpandedCategoryAttribute"];
    if ("PreExpandedAttribute" in ps.Attributes)
      this.PreExpanded = ps.Attributes["PreExpandedAttribute"];
    if ("ParamCategorySummaryAttribute" in ps.Attributes)
      this.summaryPropertyName = ps.Attributes["ParamCategorySummaryAttribute"];
    if ("IsReadonlyCallAttribute" in ps.Attributes)
      this.isReadOnlyCall = ps.Attributes["IsReadonlyCallAttribute"];
    if ("NotSavedInXMLAttribute" in ps.Attributes)
      this.NotSavedInXML = ps.Attributes["NotSavedInXMLAttribute"];
    if ("ReadOnlyAttribute " in ps.Attributes)
      this.ReadOnly = ps.Attributes["ReadOnlyAttribute "];
    if ("ParamCategorySummaryAttribute " in ps.Attributes)
      this.ParamCategorySummary = ps.Attributes["ParamCategorySummaryAttribute "];
  }
};
var UIElement = class extends EditorBaseDef {
  get parentNode() {
    return this._parentNode;
  }
  get targetFullName() {
    return this._targetFullName;
  }
  get expandIcon() {
    return ressources.ExpandIcon(UIElement.defaultFontSize.toString(), false, false, false, false, "Click to expand");
  }
  get colapseIcon() {
    return ressources.ColapseIcon(UIElement.defaultFontSize.toString(), false, false, false, false, "Click to colapse");
  }
  removeFromEditor() {
  }
  get panel() {
    return this.subElementPanel;
  }
  get editorHelpText() {
    return "";
  }
  get isRootElement() {
    return this._rootNode == this;
  }
  addToEditor() {
    if (this.mainlabel != null) {
      for (let i = 0; i < this._parentPanel.children.length; i++) {
        if (this._parentPanel.children[i] == this.mainlabel)
          return;
      }
      this._parentPanel.appendChild(this.mainlabel);
      this._parentPanel.appendChild(this.subElementPanel);
    }
  }
  refresh() {
    if (this.mainText != null)
      this.mainText.innerText = this.name + this.getSummary();
    for (let i = 0; i < this.subElements.length; i++) {
      this.subElements[i].refresh();
    }
    if (this._rootNode != null && this._rootNode.rootEditor != null)
      this._rootNode.rootEditor.refreshBanner();
  }
  tabReOrder(index) {
    if (this._expandable && this.expandCtrl != null)
      this.expandCtrl.tabIndex = index++;
    this.subElements.forEach((e) => {
      index = e.tabReOrder(index);
    });
    return index;
  }
  triggerValueChangeCallback() {
    if (this._valueChangeCallback != null)
      this._valueChangeCallback(this);
  }
  scrollToMakeVisible() {
    if (this.mainlabel == null)
      return;
    if (this._parentPanel == null)
      return;
    this.mainlabel.scrollIntoView();
  }
  control_GotFocus(sender) {
    let extraHelp = this.editorHelpText;
    if (extraHelp != "")
      extraHelp = " " + extraHelp;
    this._helpZoneLabel.innerHTML = this._description + extraHelp;
  }
  control_LostFocus(sender) {
    this._helpZoneLabel.innerHTML = "";
  }
  preExpandIfNeeded() {
    if (this._parentNode != null && this._parentNode.expanded) {
      this.AllocateControls();
      if (this.expandable)
        this.initExpandButton();
      this.initMainLabel();
    }
    this.initExpandButton();
  }
  constructor(p) {
    super();
    this.name = "NoName";
    this._targetFullName = "unknowTargetName";
    this.ExpandableDepth = 0;
    this._expanded = false;
    this._expandButtonSide = 0;
    this._rootEditor = null;
    this._description = "";
    this.expandCtrl = null;
    this.mainlabel = null;
    this.mainText = null;
    this.subElementPanel = null;
    this._rootNode = null;
    this._parentNode = null;
    this._parentPanel = null;
    this._changeCausesParentRefresh = false;
    this._isReadOnlyCall = "";
    this._controlsAllocated = false;
    this.expandButtonInitDone = false;
    this.mainLabelInitDone = false;
    this.subElements = [];
    this._valueChangeCallback = null;
    this._getValueCallback = null;
    this._shown = true;
    this._summaryCallback = null;
    this._showLabel = false;
    this._expandable = false;
    this._preExpanded = false;
    this.name = p.label;
    this._targetFullName = p.internalname;
    this._helpZoneLabel = p.HelpZoneLabel;
    this._description = p.description;
    this._changeCausesParentRefresh = p.changeCausesParentRefresh;
    this._expandable = p.expandable;
    this._preExpanded = p.preExpanded;
    this._structRoot = p.structRoot;
    this._isReadOnlyCall = p.isReadonlyCall;
    this._summaryProperty = p.summary;
    if (UIElement.baseheight == 0) {
      UIElement.baseheight = 12;
      UIElement.expandableShift = UIElement.baseheight + 2;
      UIElement.scrollBarWidth = 20;
    }
    this._parentNode = p.parentNode;
    this._rootNode = p.RootNode == null ? this : p.RootNode;
  }
  set rootEditor(value) {
    this._rootEditor = value;
  }
  get rootEditor() {
    return this._rootEditor;
  }
  initMainLabel() {
    if (this.mainlabel == null)
      return;
    if (this.mainLabelInitDone)
      return;
    this.ExpandableDepth = 0;
    let p = this;
    while (p != null) {
      if (p.expandable)
        this.ExpandableDepth++;
      p = p.parentNode;
    }
    this.mainText.innerText = this.name + this.getSummary();
    if (this.expandable && this._expandButtonSide == 0) {
      switch (this.ExpandableDepth) {
        case 1:
          this.mainlabel.style.backgroundColor = "Blue";
          this.mainText.style.color = "black";
          break;
        case 2:
          this.mainlabel.style.backgroundColor = "rgb(7,141,255)";
          this.mainText.style.color = "white";
          break;
        case 3:
          this.mainlabel.style.backgroundColor = "rgb(120,196,255)";
          break;
        case 4:
          this.mainlabel.style.backgroundColor = "rgb(213,237,255)";
          break;
        case 5:
          this.mainlabel.style.backgroundColor = "rgb(237,246,253)";
          break;
        default:
          this.mainlabel.style.backgroundColor = "rgb(246,251,255)";
          break;
      }
    } else {
      this.mainlabel.style.backgroundColor = "rgba( 0, 0, 0,0)";
    }
    this.mainLabelInitDone = true;
  }
  AllocateControls() {
    if (this._controlsAllocated)
      return;
    if (!this.isRootElement)
      this.parentNode.AllocateControls();
    this._parentPanel = this.parentNode.panel;
    if (this.mainlabel == null) {
      this.mainlabel = document.createElement("DIV");
      this.mainlabel.style.position = "relative";
      this.mainlabel.style.display = "inline-block;";
      this.mainlabel.style.left = "0px";
      this.mainlabel.style.padding = "2px 2px 2px 2px";
      this.mainlabel.style.overflow = "hidden";
      this.mainlabel.style.fontFamily = UIElement.defaultFontFamily;
      this.mainlabel.style.fontSize = UIElement.defaultFontSize.toString() + "px";
      this.mainlabel.style.right = "5px";
      this.mainlabel.style.whiteSpace = "nowrap";
      this.mainlabel.style.marginTop = "2px";
      this.mainlabel.style.backgroundColor = "yellow";
      this.mainText = document.createElement("SPAN");
      this.mainText.innerText = "Pouet";
      this.mainlabel.appendChild(this.mainText);
      this.mainlabel.style.display = this.isRootElement ? "none" : "";
      this.initMainLabel();
      if (this._parentPanel == null) {
        debugger;
      }
      this._parentPanel.appendChild(this.mainlabel);
    }
    if (this._expandable && this.expandCtrl == null) {
      this.expandCtrl = document.createElement("ANCHOR");
      if (this._expandButtonSide == 0) {
        this.mainlabel.insertBefore(this.expandCtrl, this.mainText);
      }
      this.initExpandButton();
      this.subElementPanel = document.createElement("DIV");
      this.subElementPanel.style.position = "relative";
      this.subElementPanel.style.display = "inline-block;";
      this.subElementPanel.style.left = this.isRootElement ? "0px" : "5px";
      this.subElementPanel.style.padding = "2px 2px 2px 2px";
      this.subElementPanel.style.right = "5px";
      this.subElementPanel.style.display = "none";
      this.subElementPanel.style.marginTop = "2px";
      this.subElementPanel.style.marginRight = "2px";
      this._parentPanel.appendChild(this.subElementPanel);
    }
    this._controlsAllocated = true;
  }
  initExpandButton() {
    if (this.expandCtrl == null)
      return;
    if (this.expandButtonInitDone)
      return;
    this.expandCtrl.innerHTML = this.expandIcon;
    this.expandCtrl.style.top = "0px";
    this.expandCtrl.style.left = "0px";
    this.expandCtrl.style.cursor = "pointer";
    this.expandCtrl.style.backgroundColor = "white";
    this.expandCtrl.style.marginRight = "3px";
    this.expandCtrl.style.paddingLeft = "0px";
    this.expandCtrl.style.paddingRight = "0px";
    this.expandCtrl.style.paddingTop = "1px";
    this.expandCtrl.style.marginTop = "0px";
    this.expandCtrl.style.marginBottom = "0px";
    this.expandCtrl.style.paddingBottom = "0px";
    this.expandCtrl.style.paddingRight = "0px";
    this.expandCtrl.addEventListener("click", () => {
      this.ToggleExpand();
    });
    this.expandCtrl.addEventListener("keyup", (e) => {
      if (e.key === "Enter" || e.key === " ")
        this.ToggleExpand();
    });
    this.expandCtrl.addEventListener("focusin", () => {
      this.control_GotFocus(this);
    });
    this.expandCtrl.addEventListener("focusout", () => {
      this.control_LostFocus(this);
    });
    this.expandButtonInitDone = true;
  }
  get rowHeight() {
    return UIElement.baseheight;
  }
  ExtractPropPath(info) {
    let index = -1;
    let path = [];
    let p = this;
    info.OriginalPropName = p.targetFullName;
    do {
      info.fullpropname = p.targetFullName;
      index = info.fullpropname.indexOf("_");
      if (index < 0) {
        if (info.fullpropname != UIElement.ARTIFICIALSECTIONNAME)
          path.splice(0, 0, info.fullpropname);
        p = p.parentNode;
        if (p == null)
          throw "invalid Property name";
      }
    } while (index < 0);
    info.propType = info.fullpropname.substring(0, index);
    let propname = info.fullpropname.substring(index + 1);
    path.splice(0, 0, propname);
    return path;
  }
  startEdit(setcallback, getCallback) {
    this.addToEditor();
    this._valueChangeCallback = setcallback;
    this._getValueCallback = getCallback;
    this.subElements.forEach((item) => {
      item.startEdit(setcallback, getCallback);
    });
  }
  stopEdit() {
    this.removeFromEditor();
    this._valueChangeCallback = null;
    this._getValueCallback = null;
    this.subElements.forEach((item) => {
      item.stopEdit();
    });
  }
  expand() {
    this.subElements.forEach((e) => {
      e.AllocateControls();
      e.show();
    });
    this._rootNode.tabReOrder(0);
    this._expanded = true;
    this.subElementPanel.style.display = "";
    this.expandCtrl.innerHTML = this.colapseIcon;
  }
  colapse() {
    this.subElementPanel.style.display = "none";
    this.expandCtrl.innerHTML = this.expandIcon;
  }
  get expanded() {
    return this._expanded;
  }
  set expanded(value) {
    this._expanded = value;
    if (this._expanded) {
      this.expand();
    } else {
      this.colapse();
    }
    this._rootNode.resizeAll();
  }
  ToggleExpand() {
    this.expanded = !this.expanded;
  }
  getSummary() {
    if (this._summaryProperty != null) {
      return " (" + Reflect.get(this._structRoot, this._summaryProperty.name) + ")";
    }
    return "";
  }
  sensorList() {
    let res = [];
    sensorsManager.sensorList.forEach((s) => {
      res.push(s);
    });
    return res;
  }
  ProcessNewType(dataStucture) {
    let subsections = {};
    this._structRoot = dataStucture;
    let toExpand = [];
    let properties = GenericProperties.getAllProperties(dataStucture);
    for (let i = 0; i < properties.byIndex.length; i++) {
      let ps = properties.byIndex[i];
      if (ps.isWritable) {
        let attr = new CustomAttributesExtractor(ps);
        if (attr.available) {
          let section = this;
          if (attr.category != "") {
            if (attr.category in subsections) {
              section = subsections[attr.category];
            } else {
              let sectionparam = new UIElementBaseParams(this._helpZoneLabel, this, this._rootNode, UIElement.ARTIFICIALSECTIONNAME, attr.category, attr.category + " section, expand for more...", "");
              sectionparam.preExpanded = attr.PreExpandedCategory;
              sectionparam.expandable = true;
              sectionparam.structRoot = dataStucture;
              if (attr.summaryPropertyName != "") {
                sectionparam.summary = ps;
              }
              section = new UIElement(sectionparam);
              if (attr.PreExpandedCategory)
                toExpand.push(section);
              section.showLabel = true;
              subsections[attr.category] = section;
              this.addSubElement(section);
            }
          }
          let elParam = new UIElementBaseParams(this._helpZoneLabel, section, this._rootNode, ps.name, attr.displayName, attr.displayDescription, attr.isReadOnlyCall);
          elParam.preExpanded = attr.PreExpanded;
          elParam.changeCausesParentRefresh = attr.changeCausesParentRefresh;
          let targetName = this._targetFullName;
          let targetPrefix = "";
          let p = targetName.indexOf("_");
          if (p >= 0) {
            targetPrefix = targetName.substring(0, p);
            targetName = targetName.substring(p + 1);
          }
          if (ps.isEnum) {
            let s = new UIElementEnum(elParam, dataStucture, ps);
            section.addSubElement(s);
          } else {
            switch (ps.type) {
              case "number":
                if (attr.prefinedValues == null) {
                  let n = new UIElementNumber(elParam, dataStucture, ps);
                  section.addSubElement(n);
                } else {
                  let s2 = new UIElementList(elParam, dataStucture, ps, () => {
                    return attr.prefinedValues;
                  });
                  section.addSubElement(s2);
                }
                break;
              case "boolean":
                let b = new UIElementBoolean(elParam, dataStucture, ps);
                section.addSubElement(b);
                break;
              case doubleNan.name:
                let d = new UIElementDoubleNan(elParam, dataStucture, ps);
                section.addSubElement(d);
                break;
              case NullYSensor.name:
              case CustomYSensor.name:
                let s = new UIElementList(elParam, dataStucture, ps, () => {
                  return this.sensorList();
                });
                section.addSubElement(s);
                break;
              case YColor.name:
                let c = new UIElementColor(elParam, dataStucture, ps);
                section.addSubElement(c);
                break;
              case xAxisPosition.name:
                let p2 = new UIElementMarkerPos(elParam, dataStucture, ps);
                section.addSubElement(p2);
                break;
              case "string":
                if (attr.prefinedValues == null) {
                  let s2 = new UIElementString(elParam, dataStucture, ps);
                  section.addSubElement(s2);
                } else {
                  let s2 = new UIElementList(elParam, dataStucture, ps, () => {
                    return attr.prefinedValues;
                  });
                  section.addSubElement(s2);
                }
                break;
              default:
                {
                  elParam.expandable = true;
                  elParam.preExpanded = attr.PreExpanded;
                  let subobjectsection = new UIElement(elParam);
                  if (attr.PreExpanded)
                    toExpand.push(subobjectsection);
                  subobjectsection.showLabel = true;
                  section.addSubElement(subobjectsection);
                  subobjectsection.ProcessNewType(dataStucture[ps.name]);
                }
                break;
            }
          }
        }
      } else {
        if (ps.name == "summary") {
          this._summaryProperty = ps;
        }
      }
    }
    if (this._summaryProperty != null)
      this.refresh();
    toExpand.forEach((e) => {
      e.expand();
    });
  }
  show() {
    this._shown = true;
    if (this.mainlabel != null)
      this.mainlabel.style.display = "";
    if (this.expandCtrl != null)
      this.expandCtrl.style.display = this._expandable ? "" : "hidden";
    if (this.expanded) {
      this.subElements.forEach((e) => {
        e.show();
      });
    }
  }
  hide() {
    this._shown = false;
    if (this.mainlabel != null)
      this.mainlabel.style.display = "hidden";
    if (this.expandCtrl != null)
      this.expandCtrl.style.display = this._expandable ? "hidden" : "";
    this.subElements.forEach((e) => {
      e.hide();
    });
  }
  ExpandCtrl_Click_expand(sender) {
    this.expanded = !this._expanded;
  }
  resizeAll() {
    this.resize(0, 0, 0, 0);
    if (this.expanded) {
      this.subElements.forEach((e) => {
        e.resizeAll();
      });
    }
  }
  get showLabel() {
    return this._showLabel;
  }
  set showLabel(value) {
    this._showLabel = value;
    if (this.expandCtrl != null)
      this.expandCtrl.style.display = value && this._expandable ? "" : "hidden";
  }
  get expandable() {
    return this._expandable;
  }
  set expandable(value) {
    this._expandable = value;
    if (!value)
      return;
    if (this.expandCtrl == null) {
      this.AllocateControls();
      this.initExpandButton();
    }
    this.expandCtrl.style.display = value && this._showLabel ? "" : "hidden";
  }
  addSubElement(node) {
    this.subElements.push(node);
  }
  computeHeight() {
    return 0;
  }
  resize(top2, left1, left2, width) {
    return 0;
  }
};
UIElement.defaultFontFamily = constants.generalFontFamily;
UIElement.defaultFontSize = constants.generalFontSize;
UIElement.ARTIFICIALSECTIONNAME = "-ignore-";
UIElement.baseheight = 0;
UIElement.indentation = 16;
UIElement.expandableShift = 0;
UIElement.scrollBarWidth = 0;
UIElement.expandableVerticalOffset = 2;
var UIElementGeneric = class extends UIElement {
  constructor(p, dataContainer, prop) {
    super(p);
    this.input = null;
    this.select = null;
    this._prop = prop;
    this._dataContainer = dataContainer;
    this._showLabel = true;
    if (this._preExpanded)
      this.AllocateControls();
    if (this._expandable && this._preExpanded)
      this.expand();
  }
  removeFromEditor() {
    super.removeFromEditor();
  }
  tabReOrder(index) {
    if (this.input != null)
      this.input.tabIndex = index++;
    this.subElements.forEach((e) => {
      index = e.tabReOrder(index);
    });
    return index;
  }
  addToEditor() {
    super.addToEditor();
  }
  show() {
    super.show();
    if (this.input != null)
      this.input.style.visibility = "";
  }
  checkForReadOnly() {
    if (this.input == null && this.select == null)
      return;
    if (this._isReadOnlyCall != "") {
      let ro = Reflect.get(this._dataContainer, this._isReadOnlyCall);
      if (this.input != null)
        this.input.disabled = ro;
      if (this.select != null)
        this.select.disabled = ro;
    }
  }
  hide() {
    if (this.input != null)
      this.input.style.visibility = "hidden";
    super.hide();
  }
  resize(top2, left1, left2, width) {
    return 0;
  }
};
var UIElementString = class extends UIElementGeneric {
  constructor(p, dataContainer, prop) {
    super(p, dataContainer, prop);
    this._value = "";
    this.preExpandIfNeeded();
  }
  AllocateControls() {
    super.AllocateControls();
    if (this.input == null) {
      this.input = document.createElement("INPUT");
      this.input.type = "input";
      this.input.value = Reflect.get(this._dataContainer, this._prop.name);
      this.input.style.position = "absolute";
      this.input.style.marginTop = "0px";
      this.input.style.marginBottom = "0px";
      this.input.style.fontFamily = UIElement.defaultFontFamily;
      this.input.style.fontSize = UIElement.defaultFontSize.toString() + "px";
      this.input.style.border = "1px solid grey";
      this.input.style.borderRadius = "1px";
      this.input.style.top = "0px";
      this.input.style.right = "3px";
      this.input.style.width = "50%";
      this.mainlabel.appendChild(this.input);
      new InputFieldManager(this.input, 0, true, Number.NaN, Number.NaN, () => {
        this.Text_TextChanged(null);
      });
      this.input.addEventListener("focusin", () => {
        this.control_GotFocus(this);
      });
      this.input.addEventListener("focusout", () => {
        this.control_LostFocus(this);
      });
      this.checkForReadOnly();
    }
  }
  refresh() {
    if (this.input == null)
      return;
    if (this._getValueCallback == null)
      return;
    let value = this._getValueCallback(this);
    if (value == null)
      return;
    let s = value.toString();
    if (this.input != null) {
      if (s != this.input.value)
        this.input.value = s;
    }
    this.checkForReadOnly();
  }
  Text_TextChanged(sender) {
    if (this.input != null) {
      this._value = this.input.value;
      Reflect.set(this._dataContainer, this._prop.name, this._value);
      if (this._valueChangeCallback != null)
        this._valueChangeCallback(this);
      if (this._changeCausesParentRefresh)
        this.parentNode.refresh();
    }
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value;
    this.input.value = value;
  }
  resize(top2, left1, left2, width) {
    this.mainlabel.style.height = this.input.offsetHeight.toString() + "px";
    return 0;
  }
};
var UIElementNumber = class extends UIElementGeneric {
  constructor(p, dataContainer, prop) {
    super(p, dataContainer, prop);
    this._value = 0;
    this.preExpandIfNeeded();
  }
  AllocateControls() {
    super.AllocateControls();
    if (this.input == null) {
      this.input = document.createElement("INPUT");
      this.input.type = "input";
      this.input.value = Reflect.get(this._dataContainer, this._prop.name);
      this.input.style.textAlign = "right";
      this.input.style.position = "absolute";
      this.input.style.marginTop = "0px";
      this.input.style.marginBottom = "0px";
      this.input.style.fontFamily = UIElement.defaultFontFamily;
      this.input.style.fontSize = UIElement.defaultFontSize.toString() + "px";
      this.input.type = "number";
      this.input.style.border = "1px solid grey";
      this.input.style.borderRadius = "1px";
      this.input.style.top = "0px";
      this.input.style.right = "3px";
      this.input.style.width = "50%";
      this.mainlabel.appendChild(this.input);
      new InputFieldManager(this.input, 4, false, Number.NaN, Number.NaN, () => {
        this.Text_TextChanged(null);
      });
      this.input.addEventListener("focusin", () => {
        this.control_GotFocus(this);
      });
      this.input.addEventListener("focusout", () => {
        this.control_LostFocus(this);
      });
      this.checkForReadOnly();
    }
  }
  refresh() {
    if (this.input == null)
      return;
    if (this._getValueCallback == null)
      return;
    let s = this._getValueCallback(this);
    if (s == null)
      return;
    if (this.input != null) {
      if (s != parseFloat(this.input.value))
        this.input.value = s.toString();
    }
    this.checkForReadOnly();
  }
  Text_TextChanged(sender) {
    if (this.input != null) {
      this._value = parseFloat(this.input.value);
      Reflect.set(this._dataContainer, this._prop.name, this._value);
      if (this._valueChangeCallback != null)
        this._valueChangeCallback(this);
      if (this._changeCausesParentRefresh)
        this.parentNode.refresh();
    }
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value;
    this.input.value = value.toString();
  }
  resize(top2, left1, left2, width) {
    this.mainlabel.style.height = this.input.offsetHeight.toString() + "px";
    return 0;
  }
};
var UIElementBoolean = class extends UIElementGeneric {
  constructor(p, dataContainer, prop) {
    super(p, dataContainer, prop);
    this._text = null;
    this._value = false;
    this.preExpandIfNeeded();
  }
  AllocateControls() {
    super.AllocateControls();
    if (this.input == null) {
      let span = document.createElement("SPAN");
      span.style.position = "absolute";
      span.style.display = "inline-block";
      span.style.width = "50%";
      span.style.right = "0px";
      this.mainlabel.appendChild(span);
      this.input = document.createElement("INPUT");
      this.input.type = "input";
      this.input.checked = Reflect.get(this._dataContainer, this._prop.name);
      this.input.style.textAlign = "right";
      this.input.style.display = "inline";
      this.input.style.marginTop = "0px";
      this.input.style.marginBottom = "0px";
      this.input.type = "checkbox";
      this.input.style.transform = "scale(" + constants.generalSizeCoef.toString() + ")";
      this.input.style.marginRight = Math.round(5 * constants.generalSizeCoef).toString() + "px";
      this.input.style.top = "0px";
      this.input.style.border = "1px solid grey";
      this.input.style.borderRadius = "1px";
      span.appendChild(this.input);
      this.input.addEventListener("keyup", (e) => {
        if (e.key === " ")
          this.value_TextChanged(null);
      });
      this.input.addEventListener("change", () => {
        this.value_TextChanged(null);
      });
      this._text = document.createElement("SPAN");
      this._text.style.display = "inline";
      this._text.style.fontFamily = UIElement.defaultFontFamily;
      this._text.style.fontSize = UIElement.defaultFontSize.toString() + "px";
      span.appendChild(this._text);
      this.updateText();
      this.input.addEventListener("focusin", () => {
        this.control_GotFocus(this);
      });
      this.input.addEventListener("focusout", () => {
        this.control_LostFocus(this);
      });
      this.checkForReadOnly();
    }
  }
  updateText() {
    this._text.innerText = this.input.checked ? "Enabled" : "Disabled";
  }
  refresh() {
    if (this.input == null)
      return;
    this.checkForReadOnly();
    if (this._getValueCallback == null)
      return;
    let v = this._getValueCallback(this);
    if (v == null)
      return;
    let b = v;
    if (this.input != null) {
      this.input.checked = b.valueOf();
      this.updateText();
    }
  }
  value_TextChanged(sender) {
    if (this.input != null) {
      this._value = this.input.checked;
      this.updateText();
      Reflect.set(this._dataContainer, this._prop.name, this._value);
      if (this._valueChangeCallback != null)
        this._valueChangeCallback(this);
      if (this._changeCausesParentRefresh)
        this.parentNode.refresh();
    }
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value;
    this.input.checked = value;
    this.updateText();
  }
  resize(top2, left1, left2, width) {
    return 0;
  }
};
var UIElementDoubleNan = class extends UIElementGeneric {
  constructor(p, dataContainer, prop) {
    super(p, dataContainer, prop);
    this._value = 0;
    this.preExpandIfNeeded();
  }
  AllocateControls() {
    super.AllocateControls();
    if (this.input == null) {
      this.input = document.createElement("INPUT");
      this.input.type = "input";
      this.input.value = Reflect.get(this._dataContainer, this._prop.name).toString();
      this.input.style.textAlign = "right";
      this.input.style.position = "absolute";
      this.input.style.marginTop = "0px";
      this.input.style.marginBottom = "0px";
      this.input.style.fontFamily = UIElement.defaultFontFamily;
      this.input.style.fontSize = UIElement.defaultFontSize.toString() + "px";
      this.input.type = "number";
      this.input.style.border = "1px solid grey";
      this.input.style.borderRadius = "1px";
      this.input.style.top = "0px";
      this.input.style.right = "3px";
      this.input.style.width = "50%";
      this.mainlabel.appendChild(this.input);
      new InputFieldManager(this.input, 4, true, Number.NaN, Number.NaN, () => {
        this.Text_TextChanged(null);
      });
      this.input.addEventListener("focusin", () => {
        this.control_GotFocus(this);
      });
      this.input.addEventListener("focusout", () => {
        this.control_LostFocus(this);
      });
      this.checkForReadOnly();
    }
  }
  refresh() {
    if (this.input == null)
      return;
    if (this._getValueCallback == null)
      return;
    let s = this._getValueCallback(this).toString();
    if (this.input != null) {
      if (s != this.input.value)
        this.input.value = s;
    }
    this.checkForReadOnly();
  }
  Text_TextChanged(sender) {
    if (this.input != null) {
      this._value = this.input.value == "" ? Number.NaN : parseFloat(this.input.value);
      Reflect.set(this._dataContainer, this._prop.name, new doubleNan(this._value));
      if (this._valueChangeCallback != null)
        this._valueChangeCallback(this);
      if (this._changeCausesParentRefresh)
        this.parentNode.refresh();
    }
  }
  get value() {
    return new doubleNan(this._value);
  }
  set value(value) {
    this._value = value.value;
    this.input.value = value.toString();
  }
  resize(top2, left1, left2, width) {
    this.mainlabel.style.height = this.input.offsetHeight.toString() + "px";
    return 0;
  }
};
var UIElementEnum = class extends UIElementGeneric {
  constructor(p, dataContainer, prop) {
    super(p, dataContainer, prop);
    this.allValues = [];
    this._value = "";
    this.preExpandIfNeeded();
  }
  AllocateControls() {
    super.AllocateControls();
    if (this.select == null) {
      this.select = document.createElement("SELECT");
      let enumvalue = Reflect.get(this._dataContainer, this._prop.name);
      this.allValues = enumvalue.sibblings;
      for (let i = 0; i < this.allValues.length; i++) {
        let opt = document.createElement("OPTION");
        opt.text = this.allValues[i].description;
        opt.value = this.allValues[i].toString;
        this.select.add(opt, null);
      }
      this.select.value = enumvalue.toString;
      this.select.style.position = "absolute";
      this.select.style.marginTop = "0px";
      this.select.style.marginBottom = "0px";
      this.select.style.fontFamily = UIElement.defaultFontFamily;
      this.select.style.fontSize = UIElement.defaultFontSize.toString() + "px";
      this.select.style.top = "0px";
      this.select.style.right = "3px";
      this.select.style.width = "50%";
      this.mainlabel.appendChild(this.select);
      this.select.addEventListener("change", () => {
        this.valueChanged(null);
      });
      this.select.addEventListener("focusin", () => {
        this.control_GotFocus(this);
      });
      this.select.addEventListener("focusout", () => {
        this.control_LostFocus(this);
      });
      this.checkForReadOnly();
    }
  }
  refresh() {
    if (this.select == null)
      return;
    if (this._getValueCallback == null)
      return;
    let value = this._getValueCallback(this);
    let s = value.toString;
    if (this.select != null) {
      if (s != this.select.value)
        this.select.value = s;
    }
    this.checkForReadOnly();
  }
  valueChanged(sender) {
    if (this.select != null) {
      this._value = this.select.value;
      let it = null;
      for (let i = 0; i < this.allValues.length; i++) {
        if (this.allValues[i].toString == this._value)
          it = this.allValues[i];
      }
      if (it != null)
        Reflect.set(this._dataContainer, this._prop.name, it);
      if (this._valueChangeCallback != null)
        this._valueChangeCallback(this);
      if (this._changeCausesParentRefresh)
        this.parentNode.refresh();
    }
  }
  tabReOrder(index) {
    if (this.select != null)
      this.select.tabIndex = index++;
    return index;
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value;
    this.select.value = value;
  }
  resize(top2, left1, left2, width) {
    this.mainlabel.style.height = this.select.offsetHeight.toString() + "px";
    return 0;
  }
};
var UIElementList = class extends UIElementGeneric {
  constructor(p, dataContainer, prop, allowedValues) {
    super(p, dataContainer, prop);
    this._refreshCallback = null;
    this._indexedValue = true;
    this.allValues = [];
    this.valueType = "";
    this._value = "";
    this._refreshCallback = allowedValues;
    this.preExpandIfNeeded();
  }
  AllocateControls() {
    super.AllocateControls();
    if (this.select == null) {
      this.allValues = this._refreshCallback();
      this.select = document.createElement("SELECT");
      let value = Reflect.get(this._dataContainer, this._prop.name);
      this.valueType = typeof value;
      this._indexedValue = typeof value == "number" && typeof this.allValues[0] != "number";
      let found = false;
      let first = null;
      for (let i = 0; i < this.allValues.length; i++) {
        let opt = document.createElement("OPTION");
        if (i == 0)
          first = opt;
        opt.text = this.allValues[i].toString();
        opt.value = this._indexedValue ? i : this.allValues[i];
        this.select.add(opt, null);
        if (opt.value.toString() == value.toString())
          found = true;
      }
      if (!found && !this._indexedValue) {
        let opt = document.createElement("OPTION");
        opt.text = value.toString();
        opt.value = value;
        this.select.add(opt, first);
      }
      this.select.value = value;
      this.select.style.position = "absolute";
      this.select.style.marginTop = "0px";
      this.select.style.marginBottom = "0px";
      this.select.style.fontFamily = UIElement.defaultFontFamily;
      this.select.style.fontSize = UIElement.defaultFontSize.toString() + "px";
      this.select.style.top = "0px";
      this.select.style.right = "3px";
      this.select.style.width = "50%";
      this.mainlabel.appendChild(this.select);
      this.select.addEventListener("change", () => {
        this.valueChanged(null);
      });
      this.select.addEventListener("focusin", () => {
        this.control_GotFocus(this);
      });
      this.select.addEventListener("focusout", () => {
        this.control_LostFocus(this);
      });
      this.checkForReadOnly();
    }
  }
  refresh() {
    if (this.select == null)
      return;
    if (this._getValueCallback == null)
      return;
    this.allValues = this._refreshCallback();
    for (let i = 0; i < this.allValues.length; i++) {
      let opt = i < this.select.options.length ? this.select.options[i] : document.createElement("OPTION");
      opt.text = this.allValues[i].toString();
      opt.value = this._indexedValue ? i : this.allValues[i];
      if (i >= this.select.options.length)
        this.select.add(opt, null);
    }
    while (this.allValues.length < this.select.options.length) {
      this.select.options[this.select.options.length - 1].remove();
    }
    let v = Reflect.get(this._dataContainer, this._prop.name);
    if (v == null)
      return;
    if (this._indexedValue) {
      let it = Number(v).toString();
      if (this.select.value != it)
        this.select.value = it;
    } else {
      let it = v.toString();
      if (this.select.value != it)
        this.select.value = it;
    }
    this.checkForReadOnly();
  }
  valueChanged(sender) {
    if (this.select != null) {
      this._value = this.select.value;
      if (this.valueType == "number") {
        let it = parseInt(this._value);
        if (it >= 0)
          Reflect.set(this._dataContainer, this._prop.name, it);
      } else {
        let it = "";
        for (let i = 0; i < this.allValues.length; i++) {
          if (this.allValues[i] == this._value)
            it = this.allValues[i];
        }
        if (it != "")
          Reflect.set(this._dataContainer, this._prop.name, it);
      }
      if (this._valueChangeCallback != null)
        this._valueChangeCallback(this);
      if (this._changeCausesParentRefresh) {
        this.parentNode.refresh();
      }
    }
  }
  tabReOrder(index) {
    if (this.select != null)
      this.select.tabIndex = index++;
    return index;
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value;
    this.select.value = value;
  }
  resize(top2, left1, left2, width) {
    this.mainlabel.style.height = this.select.offsetHeight.toString() + "px";
    return 0;
  }
};
var UIElementColor = class extends UIElementGeneric {
  constructor(p, dataContainer, prop) {
    super(p, dataContainer, prop);
    this.colorSample = null;
    this.colorEditor = null;
    this.colorPreview = null;
    this.currentColor = null;
    this._value = "";
    this.preExpandIfNeeded();
  }
  get expandIcon() {
    return ressources.DotDotDotIcon(UIElement.defaultFontSize.toString(), false, false, false, false, "Click to open color chooser");
  }
  get colapseIcon() {
    return ressources.DotDotDotIcon(UIElement.defaultFontSize.toString(), false, false, false, false, "Click to close color chooser");
  }
  AllocateControls() {
    this._expandable = true;
    this._expandButtonSide = 1;
    super.AllocateControls();
    if (this.input == null) {
      let table = document.createElement("TABLE");
      table.style.position = "absolute";
      table.style.top = "0px";
      table.style.right = "3px";
      table.style.width = "50%";
      table.style.borderCollapse = "collapse";
      let tr = document.createElement("TR");
      table.appendChild(tr);
      let td1 = document.createElement("TD");
      tr.appendChild(td1);
      this.colorSample = document.createElement("Div");
      this.colorSample.style.display = "inline-block";
      this.colorSample.style.border = "1px solid black";
      this.colorSample.style.marginRight = "1px";
      this.colorSample.style.marginTop = "0px";
      this.colorSample.style.width = "16px";
      this.colorSample.style.height = "16px";
      this.colorSample.style.top = "0px";
      this.colorSample.style.bottom = "0px";
      this.colorPreview = new ColorSampler(this.colorSample, null);
      td1.appendChild(this.colorSample);
      let td2 = document.createElement("TD");
      td2.style.width = "100%";
      tr.appendChild(td2);
      this.input = document.createElement("INPUT");
      this.input.type = "input";
      this.currentColor = Reflect.get(this._dataContainer, this._prop.name);
      this.colorPreview.color = this.currentColor;
      this.input.value = this.currentColor.toString();
      this.input.style.marginTop = "0px";
      this.input.style.marginBottom = "0px";
      this.input.style.width = "100%";
      this.input.style.border = "1px solid grey";
      this.input.style.borderRadius = "1px";
      this.input.style.fontFamily = UIElement.defaultFontFamily;
      this.input.style.fontSize = UIElement.defaultFontSize.toString() + "px";
      td2.appendChild(this.input);
      let td3 = document.createElement("TD");
      td3.style.paddingLeft = "5px";
      tr.appendChild(td3);
      td3.appendChild(this.expandCtrl);
      this.mainlabel.appendChild(table);
      new InputFieldManager(this.input, 7, false, Number.NaN, Number.NaN, (sender, refreshInput) => {
        this.Text_TextChanged(sender, refreshInput);
      });
      this.input.addEventListener("focusin", () => {
        this.control_GotFocus(this);
      });
      this.input.addEventListener("focusout", () => {
        this.control_LostFocus(this);
      });
      this.checkForReadOnly();
    }
  }
  expand() {
    if (this.colorEditor == null) {
      this.subElementPanel.style.marginLeft = "20px";
      this.colorEditor = new colorEditor(this.subElementPanel, UIElement.defaultFontSize, this.currentColor, (c) => {
        this.coloredited(c);
      });
    }
    this._rootNode.tabReOrder(0);
    this._expanded = true;
    this.subElementPanel.style.display = "";
    this.expandCtrl.innerHTML = this.colapseIcon;
  }
  colapse() {
    this.subElementPanel.style.display = "none";
    this.expandCtrl.innerHTML = this.expandIcon;
  }
  coloredited(newColor) {
    this.currentColor = newColor.clone();
    this.colorPreview.color = this.currentColor;
    this.input.value = this.currentColor.toString();
    Reflect.set(this._dataContainer, this._prop.name, this.currentColor);
    if (this._valueChangeCallback != null)
      this._valueChangeCallback(this);
    if (this._changeCausesParentRefresh)
      this.parentNode.refresh();
  }
  refresh() {
    if (this.input == null)
      return;
    if (this._getValueCallback == null)
      return;
    let c = this._getValueCallback(this);
    if (c != null) {
      if (this.colorPreview != null)
        this.colorPreview.color = c;
      if (this.input != null) {
        let s = c.toString();
        if (s != this.input.value)
          this.input.value = s;
      }
    }
    this.checkForReadOnly();
  }
  Text_TextChanged(sender, refreshInput) {
    if (this.input != null) {
      this._value = this.input.value;
      let c = YColor.FromString(this._value);
      if (c != null) {
        this.colorPreview.color = c;
        this.currentColor = c;
        if (this.colorEditor != null)
          this.colorEditor.color = c;
        Reflect.set(this._dataContainer, this._prop.name, c);
        if (refreshInput)
          this.input.value = c.toString();
        if (this._valueChangeCallback != null)
          this._valueChangeCallback(this);
        if (this._changeCausesParentRefresh)
          this.parentNode.refresh();
      }
    }
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value;
    this.input.value = value;
  }
  resize(top2, left1, left2, width) {
    let h = this.input.offsetHeight;
    this.mainlabel.style.height = h.toString() + "px";
    return 0;
  }
};
var UIElementMarkerPos = class extends UIElementGeneric {
  constructor(p, dataContainer, prop) {
    super(p, dataContainer, prop);
    this._cachedValue = null;
    this._value = "";
    this.preExpandIfNeeded();
  }
  static expandIconSVG(size) {
    return ressources.targetIcon(size.toString(), false, false, false, false, "Click to place marker on graph");
  }
  get expandIcon() {
    return UIElementMarkerPos.expandIconSVG(UIElement.defaultFontSize);
  }
  get colapseIcon() {
    return UIElementMarkerPos.expandIconSVG(UIElement.defaultFontSize);
  }
  AllocateControls() {
    this._expandable = true;
    this._expandButtonSide = 1;
    super.AllocateControls();
    if (this.input == null) {
      let table = document.createElement("TABLE");
      table.style.position = "absolute";
      table.style.top = "0px";
      table.style.right = "3px";
      table.style.width = "50%";
      table.style.borderCollapse = "collapse";
      let tr = document.createElement("TR");
      table.appendChild(tr);
      let td2 = document.createElement("TD");
      td2.style.width = "100%";
      tr.appendChild(td2);
      this.input = document.createElement("INPUT");
      this.input.type = "input";
      this._cachedValue = Reflect.get(this._dataContainer, this._prop.name);
      this.input.value = this._cachedValue.toString();
      this.input.style.marginTop = "0px";
      this.input.style.marginBottom = "0px";
      this.input.style.textAlign = "right";
      this.input.style.width = "100%";
      this.input.style.border = "1px solid grey";
      this.input.style.borderRadius = "1px";
      this.input.style.fontFamily = UIElement.defaultFontFamily;
      this.input.style.fontSize = UIElement.defaultFontSize.toString() + "px";
      this.input.addEventListener("keyup", () => {
        this.Text_TextChanged(null, true);
      });
      this.input.addEventListener("change", () => {
        this.Text_TextChanged(null, false);
      });
      td2.appendChild(this.input);
      let td3 = document.createElement("TD");
      td3.style.paddingLeft = "5px";
      tr.appendChild(td3);
      td3.appendChild(this.expandCtrl);
      this.mainlabel.appendChild(table);
      this.input.addEventListener("focusin", () => {
        this.control_GotFocus(this);
      });
      this.input.addEventListener("focusout", () => {
        this.control_LostFocus(this);
      });
      this.checkForReadOnly();
    }
  }
  expand() {
    let value = Reflect.get(this._dataContainer, this._prop.name);
    this.expanded = false;
    value.capture = true;
    Reflect.set(this._dataContainer, this._prop.name, value);
    if (this._valueChangeCallback != null)
      this._valueChangeCallback(this);
  }
  colapse() {
  }
  refresh() {
    if (this.input == null)
      return;
    if (this._getValueCallback == null)
      return;
    this._cachedValue = this._getValueCallback(this);
    if (this.input != null) {
      this.input.value = this._cachedValue.toString();
    }
    this.checkForReadOnly();
  }
  Text_TextChanged(sender, refreshInput) {
    let parsedValue = this._cachedValue.TryParse(this.input.value);
    if (parsedValue.success) {
      this._cachedValue.value = parsedValue.result;
      Reflect.set(this._dataContainer, this._prop.name, this._cachedValue);
      if (this._valueChangeCallback != null)
        this._valueChangeCallback(this);
      if (this._changeCausesParentRefresh)
        this.parentNode.refresh();
    }
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value;
    this.input.value = value;
  }
  resize(top2, left1, left2, width) {
    let h = this.input.offsetHeight;
    this.mainlabel.style.height = h.toString() + "px";
    return 0;
  }
};
var InputFieldManager = class {
  static nullCallback(sender) {
  }
  constructor(input, type, allowEmpty, min, max, callback) {
    this._allowEmpty = false;
    this._min = Number.NaN;
    this._max = Number.NaN;
    this._callback = null;
    this._input = input;
    this._type = type;
    this._allowEmpty = allowEmpty;
    this._min = min;
    this._max = max;
    this._callback = callback;
    this.checkData();
    this._input.addEventListener("keyup", () => {
      this.InputChange(this._input, true);
    });
    this._input.addEventListener("change", () => {
      this.InputChange(this._input, false);
    });
  }
  showError(msg) {
    this._input.title = msg;
  }
  clearError() {
    this._input.title = "";
  }
  backGroundColorFeedback(ErrorMsg, state) {
    if (state)
      this.clearError();
    else
      this.showError(ErrorMsg);
    let c = this._input.style.backgroundColor;
    if (state && c != "white")
      this._input.style.backgroundColor = "white";
    if (!state && c != "pink")
      this._input.style.backgroundColor = "pink";
    return state;
  }
  checkData() {
    let intValue = 0;
    let doubleValue = 0;
    if (this._input.disabled)
      return true;
    let strValue = this._input.value;
    if (strValue == "")
      return this.backGroundColorFeedback("This field can't be empty", this._allowEmpty);
    switch (this._type) {
      case 0:
        break;
      case 1:
        intValue = parseInt(strValue);
        doubleValue = parseFloat(strValue);
        if (Number.isNaN(intValue) || intValue != doubleValue)
          return this.backGroundColorFeedback("Integer value expected", false);
        if (!Number.isNaN(this._min) && intValue < this._min)
          return this.backGroundColorFeedback("Integer value greater or equal to " + this._min.toString() + " expected", false);
        if (!Number.isNaN(this._max) && intValue > this._max)
          return this.backGroundColorFeedback("Integer value lower or equal to  " + this._min.toString() + " expected", false);
        break;
      case 2:
        intValue = parseInt(strValue);
        doubleValue = parseFloat(strValue);
        if (Number.isNaN(intValue) || intValue != doubleValue)
          return this.backGroundColorFeedback("Positive integer  expected", false);
        if (intValue < 0)
          return this.backGroundColorFeedback("Positive integer value  expected", false);
        if (!Number.isNaN(this._min) && intValue < this._min)
          return this.backGroundColorFeedback("Positive integer value greater or equal to " + this._min.toString() + " expected", false);
        if (!Number.isNaN(this._max) && intValue > this._max)
          return this.backGroundColorFeedback("Positive integer value lower or equal to  " + this._min.toString() + " expected", false);
        break;
      case 3:
        intValue = parseInt(strValue);
        doubleValue = parseFloat(strValue);
        if (Number.isNaN(intValue) || intValue != doubleValue)
          return this.backGroundColorFeedback("Strictly positive Integer value expected", false);
        if (intValue <= 0)
          return this.backGroundColorFeedback("Strictly positive integer value  expected", false);
        if (!Number.isNaN(this._min) && intValue < this._min)
          return this.backGroundColorFeedback("Positive integer value greater or equal to " + this._min.toString() + " expected", false);
        if (!Number.isNaN(this._max) && intValue > this._max)
          return this.backGroundColorFeedback("Positive integer value lower or equal to  " + this._min.toString() + " expected", false);
        break;
      case 4:
        doubleValue = parseFloat(strValue);
        if (Number.isNaN(intValue))
          return this.backGroundColorFeedback("Floating point value expected", false);
        if (!Number.isNaN(this._min) && doubleValue < this._min)
          return this.backGroundColorFeedback("Floating point value greater or equal to " + this._min.toString() + " expected", false);
        if (!Number.isNaN(this._max) && doubleValue > this._max)
          return this.backGroundColorFeedback("Floating point value lower or equal to  " + this._min.toString() + " expected", false);
        break;
      case 5:
        doubleValue = parseFloat(strValue);
        if (Number.isNaN(doubleValue))
          return this.backGroundColorFeedback("Positive floating point value expected", false);
        if (doubleValue < 0)
          return this.backGroundColorFeedback("Positive floating point value expected", false);
        if (!Number.isNaN(this._min) && doubleValue < this._min)
          return this.backGroundColorFeedback("Floating point value greater or equal to " + this._min.toString() + " expected", false);
        if (!Number.isNaN(this._max) && doubleValue > this._max)
          return this.backGroundColorFeedback("Floating point value lower or equal to  " + this._min.toString() + " expected", false);
        break;
      case 6:
        doubleValue = parseFloat(strValue);
        if (Number.isNaN(doubleValue))
          return this.backGroundColorFeedback("Strictly positive floating point value expected", false);
        if (doubleValue <= 0)
          return this.backGroundColorFeedback("Strictly positive floating point value expected", false);
        if (!Number.isNaN(this._min) && doubleValue < this._min)
          return this.backGroundColorFeedback("Floating point value greater or equal to " + this._min.toString() + " expected", false);
        if (!Number.isNaN(this._max) && doubleValue > this._max)
          return this.backGroundColorFeedback("Floating point value greater or equal to " + this._min.toString() + " expected", false);
        break;
      case 7:
        if (YColor.FromString(strValue) == null)
          return this.backGroundColorFeedback("Value color name/definition expected", false);
        break;
    }
    return this.backGroundColorFeedback("", true);
  }
  InputChange(sender, refreshInput) {
    if (this.checkData()) {
      try {
        if (this._callback != null)
          this._callback(sender, refreshInput);
      } catch (ex) {
        this.backGroundColorFeedback(ex.message, false);
      }
    }
  }
};

// obj/full/colorEditor_rw.js
var ColorEditorTab = class {
  constructor(editor, label, fontSize) {
    this._realTab = false;
    this._div = null;
    this._tabLabel = null;
    this._td = document.createElement("TD");
    this._editor = editor;
    if (label != "") {
      this._div = document.createElement("DIV");
      this._div.style.display = "none";
      this._td.style.paddingTop = "4px";
      this._td.style.fontSize = fontSize.toString() + "px";
      this._td.style.paddingBottom = "2px";
      this._td.style.borderLeft = "1px solid " + this._editor.inactiveBorderColor;
      this._td.style.borderRight = "1px solid " + this._editor.inactiveBorderColor;
      this._td.style.borderTop = "1px solid " + this._editor.inactiveBorderColor;
      this._td.style.borderBottom = "1px solid " + this._editor.activeBorderColor;
      this._td.style.color = this._editor.inactiveColor;
      this._td.style.backgroundColor = this._editor.inactiveBackgroundColor;
      this._td.style.borderTopLeftRadius = "3px";
      this._td.style.borderTopRightRadius = "3px";
      this._td.style.paddingLeft = "5px";
      this._td.style.paddingRight = "5px";
      this._realTab = true;
      this._tabLabel = document.createElement("ANCHOR");
      this._tabLabel.innerText = label;
      this._tabLabel.addEventListener("click", () => {
        this._editor.tabSelected(this);
      });
      this._tabLabel.addEventListener("keyup", (e) => {
        if (e.key === "Enter" || e.key === " ")
          this._editor.tabSelected(this);
      });
      this._tabLabel.style.cursor = "pointer";
      this._td.appendChild(this._tabLabel);
    } else {
      this._td.style.borderBottom = "1px solid " + this._editor.activeBorderColor;
      this._td.innerHTML = "<span>&nbsp;</span>";
    }
  }
  setTabIndex(index) {
    this._tabLabel.tabIndex = index++;
    return index;
  }
  set active(value) {
    if (!this._realTab)
      return;
    this._td.style.borderLeftColor = value ? this._editor.activeBorderColor : this._editor.inactiveBorderColor;
    this._td.style.borderTopColor = value ? this._editor.activeBorderColor : this._editor.inactiveBorderColor;
    this._td.style.borderRightColor = value ? this._editor.activeBorderColor : this._editor.inactiveBorderColor;
    this._td.style.borderBottomColor = value ? "rgba(0, 0, 0, 0)" : this._editor.activeBorderColor;
    this._td.style.color = value ? this._editor.activeColor : this._editor.inactiveColor;
    this._td.style.backgroundColor = value ? this._editor.activeBackgroundColor : this._editor.inactiveBackgroundColor;
    this._div.style.display = value ? "" : "none";
  }
  get active() {
    return this._div.style.display == "";
  }
  get tabElement() {
    return this._td;
  }
  get divElement() {
    return this._div;
  }
};
var ColorEditorSroll = class {
  setTabIndex(index) {
    this._anchor.tabIndex = index++;
    this._input.tabIndex = index++;
    return index;
  }
  constructor(div, anchor, input, colorCallback, changeCallBack, checkerBoardBg, value) {
    this._value = 0;
    this._colorCallback = colorCallback;
    this._changeCallBack = changeCallBack;
    this._value = value;
    this._div = div;
    let s = ColorEditorSroll.scrollHeight;
    if (checkerBoardBg)
      this._div.style.background = "url('data:image/svg+xml;utf8," + ColorSampler.checkerboardImage(s, s) + "')";
    this._anchor = anchor;
    this._input = input;
    this._input.size = 3;
    this._input.maxLength = 3;
    this._input.type = "number";
    this._input.min = "0";
    this._input.max = "255";
    this._input.style.fontSize = (12 * constants.guiDPIFactor).toString() + "px";
    this._input.style.textAlign = "right";
    this._input.value = this._value.toString();
    this._input.style.marginLeft = "10px";
    this._div.style.width = "100%";
    this._div.style.position = "relative";
    this._div.style.height = ColorEditorSroll.scrollHeight.toString() + "px";
    this._div.style.border = "1px solid black";
    this._canvasBg = document.createElement("CANVAS");
    this._div.appendChild(this._canvasBg);
    this._canvasBg.style.left = "0px";
    this._canvasBg.style.top = "0px";
    this._canvasBg.style.width = "100%";
    this._canvasBg.style.height = "100%";
    this._canvasBg.width = 256;
    this._canvasBg.height = ColorEditorSroll.scrollHeight;
    this._canvasCursor = document.createElement("CANVAS");
    this._div.appendChild(this._canvasCursor);
    this._canvasCursor.style.position = "absolute";
    this._canvasCursor.style.width = "100%";
    this._canvasCursor.style.height = "100%";
    this._canvasCursor.style.left = "0px";
    this._canvasCursor.style.top = "0px";
    this._canvasCursor.style.display = "block";
    this._div.addEventListener("mousedown", (e) => {
      this.MouseDown(this._div, e);
    });
    this._div.addEventListener("mousemove", (e) => {
      this.MouseMove(this._div, e);
    });
    this._anchor.addEventListener("wheel", (e) => {
      this.mouseWheelEvent(this._div, e);
    });
    this._anchor.addEventListener("keydown", (e) => {
      this.KeyDown(this._div, e);
    });
    this._input.addEventListener("keyup", (e) => {
      this.inputKeyUp();
    });
    this._input.addEventListener("change", (e) => {
      this.inputKeyUp();
    });
    this._anchor.tabIndex = 4;
  }
  get value() {
    return this._value;
  }
  set value(v) {
    if (v < 0)
      v = 0;
    if (v > 255)
      v = 255;
    this._value = v;
    this._input.value = this._value.toString();
  }
  inputKeyUp() {
    let value = parseInt(this._input.value);
    if (isNaN(value))
      return;
    if (value < 0)
      value = 0;
    if (value > 255)
      value = 255;
    this._value = value;
    this.refresh();
    this._changeCallBack(this);
  }
  TouchStart(div, e) {
    if (e.touches.length == 1)
      this.handleMouseStartCapture(div, e.touches[0].clientX, e.touches[0].clientY);
  }
  TouchCaptureRun(div, e) {
    if (e.touches.length == 1)
      this.handleMouseRun(div, e.touches[0].clientX, e.touches[0].clientY);
  }
  TouchCaptureEnd(div, e) {
  }
  MouseDown(sender, e) {
    if (e.buttons != 1)
      return;
    this.handleMouseStartCapture(sender, e.clientX, e.clientY);
  }
  handleMouseStartCapture(sender, x, y) {
    let SenderRect = sender.getBoundingClientRect();
    let eX = Math.round(x - SenderRect.left);
    let index = Math.round(256 * eX / this._div.offsetWidth) >> 0;
    if (index < 0)
      index = 0;
    if (index > 255)
      index = 255;
    this._value = index;
    this._input.value = index.toString();
    this.refresh();
    this._changeCallBack(this);
  }
  MouseMove(sender, e) {
    if (e.buttons != 1)
      return;
    this.handleMouseRun(sender, e.clientX, e.clientY);
  }
  handleMouseRun(sender, x, y) {
    let SenderRect = sender.getBoundingClientRect();
    let eX = Math.round(x - SenderRect.left);
    let index = Math.round(256 * eX / this._div.offsetWidth) >> 0;
    if (index < 0)
      index = 0;
    if (index > 255)
      index = 255;
    this._value = index;
    this._input.value = index.toString();
    this.refresh();
    this._changeCallBack(this);
  }
  mouseWheelEvent(sender, e) {
    this._value += e.deltaY > 0 ? -1 : 1;
    if (this._value < 0) {
      this._value = 0;
    } else if (this._value > 255) {
      this._value = 255;
    } else {
      e.preventDefault();
    }
    this._input.value = this._value.toString();
    this.refresh();
    this._changeCallBack(this);
  }
  KeyDown(sender, e) {
    if (e.code == "ArrowRight") {
      this._value++;
      if (this._value > 255)
        this._value = 255;
    }
    if (e.code == "ArrowLeft") {
      this._value--;
      if (this._value < 0)
        this._value = 0;
    }
    this._input.value = this._value.toString();
    this.refresh();
    this._changeCallBack(this);
  }
  refresh() {
    let color = this._colorCallback(this);
    let ctx = this._canvasBg.getContext("2d");
    ctx.clearRect(0, 0, this._canvasBg.width, this._canvasBg.height);
    for (let i = 0; i < 256; i++) {
      ctx.beginPath();
      ctx.moveTo(i + 0.5, 0);
      ctx.lineTo(i + 0.5, ColorEditorSroll.scrollHeight);
      ctx.strokeStyle = color[i];
      ctx.stroke();
    }
    this._canvasCursor.width = this._div.offsetWidth;
    this._canvasCursor.height = this._div.offsetHeight;
    ctx = this._canvasCursor.getContext("2d");
    let x = 0.5 + this._value / 255 * this._canvasCursor.width;
    ctx.beginPath();
    let y = 0.5;
    ctx.moveTo(x, y + 5);
    ctx.lineTo(x + 3, y);
    ctx.lineTo(x - 3, y);
    ctx.fillStyle = "black";
    ctx.strokeStyle = "white";
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
    y = this._canvasCursor.height - 0.5;
    ctx.beginPath();
    ctx.moveTo(x, y - 5);
    ctx.lineTo(x + 3, y);
    ctx.lineTo(x - 3, y);
    ctx.fillStyle = "black";
    ctx.strokeStyle = "white";
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
  }
};
ColorEditorSroll.scrollHeight = 26 * constants.guiDPIFactor;
var ColorSampler = class {
  setTabIndex(index) {
    this._colorDiv.tabIndex = index++;
    return index;
  }
  static checkerboardImage(width, height) {
    let halfWidth = width >> 1;
    let halfHeight = height >> 1;
    return '<svg xmlns="http://www.w3.org/2000/svg"   viewbox="0 0 ' + width + " " + height + '" width="' + width + 'px"  height="' + height + 'px" ><rect x="0" y="0" width="' + width + '" height="' + height + '" style="fill:white"/><rect x="0" y="0" width="' + halfWidth + '" height="' + halfHeight + '" style="fill:black"/><rect x="' + halfWidth + '" y="' + halfHeight + '" width="' + halfWidth + '" height="' + halfHeight + '" style="fill:black"/></svg>';
  }
  constructor(containerDiv, selectCallback) {
    this._containerDiv = containerDiv;
    this._selectCallback = selectCallback;
    this._containerDiv.style.border = "1px solid grey";
    this._containerDiv.style.background = "url('data:image/svg+xml;utf8," + ColorSampler.checkerboardImage(100, 100) + "')";
    this._containerDiv.style.backgroundSize = "cover";
    this._containerDiv.style.backgroundPosition = "center";
    this._containerDiv.style.backgroundRepeat = "no-repeat";
    this._color = YColor.Transparent;
    this._colorDiv = document.createElement("DIV");
    this._colorDiv.style.display = "display-block";
    this._colorDiv.style.position = "relative";
    this._colorDiv.style.width = "100%";
    this._colorDiv.style.height = "100%";
    this._colorDiv.style.backgroundColor = "rgba(0,0,0,0)";
    this._containerDiv.appendChild(this._colorDiv);
    if (this._selectCallback != null) {
      this._colorDiv.addEventListener("click", () => {
        this._selectCallback(this.color);
      });
      this._colorDiv.addEventListener("keyup", (e) => {
        if (e.key === "Enter" || e.key === " ")
          this._selectCallback(this.color);
      });
      this._colorDiv.style.cursor = "pointer";
    }
  }
  set color(value) {
    this._color = value.clone();
    this._colorDiv.style.backgroundColor = this._color.htmlCode;
  }
  get color() {
    return this._color.clone();
  }
};
var colorEditor = class {
  static AddColorToHistory(c) {
    for (let i = 0; i < colorEditor._colorHistory.length; i++) {
      if (c.equal(colorEditor._colorHistory[i]))
        return;
    }
    colorEditor._colorHistory.splice(colorEditor._colorHistory.length - 1, 1);
    colorEditor._colorHistory.splice(0, 0, c);
    for (let i = colorEditor._editorsList.length - 1; i >= 0; i--) {
      colorEditor._editorsList[i].refreshColorHistory();
    }
  }
  static get colorHistory() {
    return colorEditor._colorHistory;
  }
  get activeBorderColor() {
    return "#767676";
  }
  get inactiveBorderColor() {
    return "#b0b0b0";
  }
  get activeColor() {
    return "black";
  }
  get inactiveColor() {
    return "grey";
  }
  get activeBackgroundColor() {
    return "white";
  }
  get inactiveBackgroundColor() {
    return "#f8f8f8";
  }
  tabSelected(source) {
    if (source == this._tabRGB) {
      this._tabRGB.active = true;
      this._rgb_R_editor.refresh();
      this._rgb_G_editor.refresh();
      this._rgb_B_editor.refresh();
      this._rgb_T_editor.refresh();
    } else {
      this._tabRGB.active = false;
    }
    if (source == this._tabHSL) {
      this._tabHSL.active = true;
      this._hsl_H_editor.refresh();
      this._hsl_S_editor.refresh();
      this._hsl_L_editor.refresh();
      this._hsl_T_editor.refresh();
    } else {
      this._tabHSL.active = false;
    }
    this._tabPredef.active = source == this._tabPredef;
  }
  HueScrollBg() {
    let s = 100;
    let l = 50;
    let t = this._hsl_T_editor.value / 255;
    let res = new Array(256);
    for (let i = 0; i < 256; i++) {
      res[i] = "hsl(" + (360 * i / 256).toString() + "," + s.toString() + "%," + l.toString() + "%)";
    }
    return res;
  }
  SaturationScrollBg() {
    let h = 360 * this._hsl_H_editor.value / 256;
    let l = 100 * this._hsl_L_editor.value / 255;
    let t = this._hsl_T_editor.value / 255;
    let res = new Array(256);
    for (let i = 0; i < 256; i++) {
      res[i] = "hsl(" + h.toString() + "," + (100 * i / 255).toString() + "%," + l.toString() + "%)";
    }
    return res;
  }
  LuminosityScrollBg() {
    let h = 360 * this._hsl_H_editor.value / 256;
    let s = 100 * this._hsl_S_editor.value / 255;
    let t = this._hsl_T_editor.value / 255;
    let res = new Array(256);
    for (let i = 0; i < 256; i++) {
      res[i] = "hsl(" + h.toString() + "," + s.toString() + "%," + (100 * i / 255).toString() + "%)";
    }
    return res;
  }
  HSLTranspScrollBg() {
    let h = 360 * this._hsl_H_editor.value / 256;
    let s = 100 * this._hsl_S_editor.value / 255;
    let l = 100 * this._hsl_L_editor.value / 255;
    let res = new Array(256);
    for (let i = 0; i < 256; i++) {
      res[i] = "hsla(" + h.toString() + "," + l.toString() + "%," + s.toString() + "%," + (i / 255).toString() + ")";
    }
    return res;
  }
  RedScrollBg() {
    let g = this._rgb_G_editor.value;
    let b = this._rgb_B_editor.value;
    let t = this._rgb_T_editor.value / 255;
    let res = new Array(256);
    for (let i = 0; i < 256; i++) {
      res[i] = "rgb(" + i.toString() + "," + g.toString() + "," + b.toString() + ")";
    }
    return res;
  }
  GreenScrollBg() {
    let r = this._rgb_R_editor.value;
    let b = this._rgb_B_editor.value;
    let t = this._rgb_T_editor.value / 255;
    let res = new Array(256);
    for (let i = 0; i < 256; i++) {
      res[i] = "rgb(" + r.toString() + "," + i.toString() + "," + b.toString() + ")";
    }
    return res;
  }
  BlueScrollBg() {
    let r = this._rgb_R_editor.value;
    let g = this._rgb_G_editor.value;
    let t = this._rgb_T_editor.value / 255;
    let res = new Array(256);
    for (let i = 0; i < 256; i++) {
      res[i] = "rgb(" + r.toString() + "," + g.toString() + "," + i.toString() + ")";
    }
    return res;
  }
  RGBTranspScrollBg() {
    let r = this._rgb_R_editor.value;
    let g = this._rgb_G_editor.value;
    let b = this._rgb_B_editor.value;
    let res = new Array(256);
    for (let i = 0; i < 256; i++) {
      res[i] = "rgba(" + r.toString() + "," + g.toString() + "," + b.toString() + "," + (i / 255).toString() + ")";
    }
    return res;
  }
  static defaultColorHistory() {
    let defaultHistory = [];
    defaultHistory.push(YColor.FromAhsl(100, 0, 0, 0));
    defaultHistory.push(YColor.FromAhsl(100, 0, 0, 51));
    defaultHistory.push(YColor.FromAhsl(100, 0, 0, 102));
    defaultHistory.push(YColor.FromAhsl(100, 0, 0, 153));
    defaultHistory.push(YColor.FromAhsl(100, 0, 0, 204));
    defaultHistory.push(YColor.FromAhsl(100, 0, 0, 255));
    defaultHistory.push(YColor.FromAhsl(100, 0, 255, 127));
    defaultHistory.push(YColor.FromAhsl(100, 42, 255, 127));
    defaultHistory.push(YColor.FromAhsl(100, 85, 255, 127));
    defaultHistory.push(YColor.FromAhsl(100, 96, 255, 127));
    defaultHistory.push(YColor.FromAhsl(100, 127, 255, 127));
    defaultHistory.push(YColor.FromAhsl(100, 170, 255, 127));
    defaultHistory.push(YColor.FromAhsl(100, 192, 255, 127));
    defaultHistory.push(YColor.FromAhsl(100, 212, 255, 127));
    defaultHistory.push(YColor.FromAhsl(255, 226, 217, 214));
    return defaultHistory;
  }
  destroy() {
    for (let i = colorEditor._editorsList.length - 1; i >= 0; i--) {
      if (colorEditor._editorsList[i] == this) {
        colorEditor._editorsList.splice(i, 1);
      }
    }
  }
  refreshColorHistory() {
    for (let i = 0; i < this._samples.length; i++) {
      if (i < colorEditor._colorHistory.length) {
        this._samples[i].color = colorEditor._colorHistory[i].clone();
      }
    }
  }
  constructor(container, fontSize, initialColor, colorChangeCallback) {
    this._firstTabIndex = 0;
    this._memorizeTimer = null;
    colorEditor._editorsList.push(this);
    this._colorChangeCallback = colorChangeCallback;
    this._container = container;
    this._table = document.createElement("TABLE");
    this._table.style.width = "100%";
    this._table.style.borderSpacing = "0";
    this._table.style.paddingLeft = "5px";
    this._table.style.paddingTop = "5px";
    this._table.style.paddingRight = "5px";
    this._table.style.borderCollapse = "separate";
    this._tr1 = document.createElement("TR");
    this._tr2 = document.createElement("TR");
    this._tabRGB = new ColorEditorTab(this, "RGB", fontSize);
    this._tabHSL = new ColorEditorTab(this, "HSL", fontSize);
    this._tabPredef = new ColorEditorTab(this, "Predefined", fontSize);
    this._tabStub = new ColorEditorTab(this, "", fontSize);
    this._contents = document.createElement("TD");
    this._contents.colSpan = 4;
    this._contents.style.borderLeft = "1px solid " + this.activeBorderColor;
    this._contents.style.borderRight = "1px solid " + this.activeBorderColor;
    this._contents.style.borderBottom = "1px solid " + this.activeBorderColor;
    this._contents.style.backgroundColor = this.activeBackgroundColor;
    this._tr1.appendChild(this._tabRGB.tabElement);
    this._tr1.appendChild(this._tabHSL.tabElement);
    this._tr1.appendChild(this._tabPredef.tabElement);
    this._tr1.appendChild(this._tabStub.tabElement);
    this._tr2.appendChild(this._contents);
    this._table.appendChild(this._tr1);
    this._table.appendChild(this._tr2);
    this._contents.appendChild(this._tabRGB.divElement);
    this._contents.appendChild(this._tabHSL.divElement);
    this._contents.appendChild(this._tabPredef.divElement);
    let RGBtable = document.createElement("TABLE");
    RGBtable.style.width = "100%";
    RGBtable.style.borderSpacing = "1";
    this._tabRGB.divElement.appendChild(RGBtable);
    let HSLtable = document.createElement("TABLE");
    HSLtable.style.width = "100%";
    HSLtable.style.borderSpacing = "1";
    this._tabHSL.divElement.appendChild(HSLtable);
    let predefTable = document.createElement("TABLE");
    this._tabPredef.divElement.appendChild(predefTable);
    predefTable.style.width = "100%";
    predefTable.style.borderSpacing = "1";
    predefTable.style.tableLayout = "fixed";
    this._container.appendChild(this._table);
    this._rgb_R_editor = this.AddColorScroll(RGBtable, "R", () => {
      return this.RedScrollBg();
    }, (src) => {
      this.RgbColorChangeCallBack(src);
    }, false, 1);
    this._rgb_G_editor = this.AddColorScroll(RGBtable, "G", () => {
      return this.GreenScrollBg();
    }, (src) => {
      this.RgbColorChangeCallBack(src);
    }, false, 2);
    this._rgb_B_editor = this.AddColorScroll(RGBtable, "B", () => {
      return this.BlueScrollBg();
    }, (src) => {
      this.RgbColorChangeCallBack(src);
    }, false, 3);
    this._rgb_T_editor = this.AddColorScroll(RGBtable, "T", () => {
      return this.RGBTranspScrollBg();
    }, (src) => {
      this.RgbColorChangeCallBack(src);
    }, true, 3);
    this._rgb_R_editor.value = initialColor.red;
    this._rgb_G_editor.value = initialColor.green;
    this._rgb_B_editor.value = initialColor.blue;
    this._rgb_T_editor.value = initialColor.alpha;
    this._rgb_R_editor.refresh();
    this._rgb_G_editor.refresh();
    this._rgb_B_editor.refresh();
    this._rgb_T_editor.refresh();
    this._hsl_H_editor = this.AddColorScroll(HSLtable, "H", () => {
      return this.HueScrollBg();
    }, (src) => {
      this.HslColorChangeCallBack(src);
    }, false, 1);
    this._hsl_S_editor = this.AddColorScroll(HSLtable, "S", () => {
      return this.SaturationScrollBg();
    }, (src) => {
      this.HslColorChangeCallBack(src);
    }, false, 2);
    this._hsl_L_editor = this.AddColorScroll(HSLtable, "L", () => {
      return this.LuminosityScrollBg();
    }, (src) => {
      this.HslColorChangeCallBack(src);
    }, false, 3);
    this._hsl_T_editor = this.AddColorScroll(HSLtable, "T", () => {
      return this.HSLTranspScrollBg();
    }, (src) => {
      this.HslColorChangeCallBack(src);
    }, true, 3);
    this._hsl_H_editor.value = initialColor.hue;
    this._hsl_S_editor.value = initialColor.saturation;
    this._hsl_L_editor.value = initialColor.luminosity;
    this._hsl_T_editor.value = initialColor.alpha;
    this._hsl_H_editor.refresh();
    this._hsl_S_editor.refresh();
    this._hsl_L_editor.refresh();
    this._hsl_T_editor.refresh();
    let samplesTable = document.createElement("TABLE");
    samplesTable.style.position = "relative";
    samplesTable.style.width = "100%";
    samplesTable.style.paddingLeft = "3px";
    samplesTable.style.paddingRight = "3px";
    samplesTable.style.paddingTop = "10px";
    samplesTable.style.bottom = "3px";
    samplesTable.style.tableLayout = "fixed";
    let samplesTD = [];
    let previewTD = null;
    let sampleHeight = 30;
    let sampletr1 = document.createElement("TR");
    sampletr1.style.height = sampleHeight.toString() + "px";
    for (let i = 0; i < 6; i++) {
      let td = document.createElement("TD");
      if (i == 5) {
        td.colSpan = 2;
        td.rowSpan = 3;
        previewTD = td;
      } else {
        samplesTD.push(td);
      }
      sampletr1.appendChild(td);
    }
    samplesTable.appendChild(sampletr1);
    let sampletr2 = document.createElement("TR");
    sampletr2.style.height = sampleHeight.toString() + "px";
    for (let i = 0; i < 5; i++) {
      let td = document.createElement("TD");
      samplesTD.push(td);
      sampletr2.appendChild(td);
    }
    samplesTable.appendChild(sampletr2);
    let sampletr3 = document.createElement("TR");
    sampletr3.style.height = sampleHeight.toString() + "px";
    for (let i = 0; i < 5; i++) {
      let td = document.createElement("TD");
      samplesTD.push(td);
      sampletr3.appendChild(td);
    }
    samplesTable.appendChild(sampletr3);
    this._container.appendChild(samplesTable);
    this._samples = [];
    for (let i = 0; i < samplesTD.length; i++) {
      let div2 = document.createElement("DIV");
      div2.style.position = "relative";
      div2.style.width = "100%";
      div2.style.height = (sampleHeight - 4).toString() + "px";
      div2.style.display = "inline-block";
      div2.title = "Color history";
      samplesTD[i].appendChild(div2);
      let sampler = new ColorSampler(div2, (c) => {
        this.sampleWasSelectedCallback(c);
      });
      sampler.color = colorEditor._colorHistory[i];
      this._samples.push(sampler);
    }
    let prefinedColors = YColor.predefinedColors;
    let colors = [];
    let predefinedColorNames = Object.keys(prefinedColors);
    for (let i = 0; i < predefinedColorNames.length; i++) {
      colors.push(prefinedColors[predefinedColorNames[i]]);
    }
    colors.sort((c1, c2) => {
      if (c1.alpha < c2.alpha)
        return 1;
      if (c1.alpha > c2.alpha)
        return -1;
      if (c1.luminosity < c2.luminosity)
        return 1;
      if (c1.luminosity > c2.luminosity)
        return -1;
      if (c1.saturation < c2.saturation)
        return 1;
      if (c1.saturation > c2.saturation)
        return -1;
      if (c1.hue < c2.hue)
        return 1;
      if (c1.hue > c2.hue)
        return -1;
      return 0;
    });
    let currenTR = null;
    this._prefedDivs = [];
    for (let i = 0; i < colors.length; i++) {
      let c = colors[i];
      if (i % 16 == 0) {
        currenTR = document.createElement("TR");
        predefTable.appendChild(currenTR);
      }
      let td = document.createElement("TD");
      currenTR.appendChild(td);
      let div2 = document.createElement("DIV");
      this._prefedDivs.push(div2);
      div2.style.position = "relative";
      div2.style.width = "100%";
      div2.style.height = Math.round(10 * constants.guiDPIFactor).toString() + "px";
      div2.style.display = "inline-block";
      div2.title = c.name;
      td.appendChild(div2);
      let sampler = new ColorSampler(div2, (c2) => {
        this.sampleWasSelectedCallback(c2);
      });
      sampler.color = c;
    }
    let div = document.createElement("DIV");
    div.style.position = "relative";
    div.style.width = "100%";
    div.style.height = (3 * sampleHeight).toString() + "px";
    div.style.display = "inline-block";
    div.title = "Color preview";
    previewTD.appendChild(div);
    this._preview = new ColorSampler(div, null);
    this._preview.color = initialColor;
    this.selectApropriateTab(initialColor);
  }
  selectApropriateTab(color) {
    if (color.isPredefined) {
      this._tabPredef.active = true;
      this.tabSelected(this._tabPredef);
    } else {
      this._tabPredef.active = false;
      if (color.isRGB) {
        this._tabRGB.active = true;
        this._tabHSL.active = false;
        this.tabSelected(this._tabRGB);
      } else {
        this._tabRGB.active = false;
        this._tabHSL.active = true;
        this.tabSelected(this._tabHSL);
      }
    }
  }
  sampleWasSelectedCallback(color) {
    this._rgb_R_editor.value = color.red;
    this._rgb_G_editor.value = color.green;
    this._rgb_B_editor.value = color.blue;
    this._rgb_T_editor.value = color.alpha;
    this._hsl_H_editor.value = color.hue;
    this._hsl_S_editor.value = color.saturation;
    this._hsl_L_editor.value = color.luminosity;
    this._hsl_T_editor.value = color.alpha;
    this._preview.color = color;
    this._rgb_R_editor.refresh();
    this._rgb_G_editor.refresh();
    this._rgb_B_editor.refresh();
    this._rgb_T_editor.refresh();
    this._hsl_H_editor.refresh();
    this._hsl_S_editor.refresh();
    this._hsl_L_editor.refresh();
    this._hsl_T_editor.refresh();
    this.initColorMemorization(color);
    if (this._colorChangeCallback != null)
      this._colorChangeCallback(color);
  }
  initColorMemorization(color) {
    if (this._memorizeTimer != null)
      clearTimeout(this._memorizeTimer);
    this._memorizeTimer = setTimeout(() => {
      this._memorizeTimer = null;
      colorEditor.AddColorToHistory(color);
    }, 2e3);
  }
  RgbColorChangeCallBack(src) {
    if (src != this._rgb_R_editor)
      this._rgb_R_editor.refresh();
    if (src != this._rgb_G_editor)
      this._rgb_G_editor.refresh();
    if (src != this._rgb_B_editor)
      this._rgb_B_editor.refresh();
    if (src != this._rgb_T_editor)
      this._rgb_T_editor.refresh();
    let color = YColor.FromArgb(this._rgb_T_editor.value, this._rgb_R_editor.value, this._rgb_G_editor.value, this._rgb_B_editor.value);
    this._preview.color = color;
    this.initColorMemorization(color);
    if (this._colorChangeCallback != null)
      this._colorChangeCallback(color);
  }
  HslColorChangeCallBack(src) {
    if (src != this._hsl_H_editor)
      this._hsl_H_editor.refresh();
    if (src != this._hsl_S_editor)
      this._hsl_S_editor.refresh();
    if (src != this._hsl_L_editor)
      this._hsl_L_editor.refresh();
    if (src != this._hsl_T_editor)
      this._hsl_T_editor.refresh();
    let color = YColor.FromAhsl(this._hsl_T_editor.value, this._hsl_H_editor.value, this._hsl_S_editor.value, this._hsl_L_editor.value);
    this._preview.color = color;
    this.initColorMemorization(color);
    if (this._colorChangeCallback != null)
      this._colorChangeCallback(color);
  }
  set color(color) {
    this._preview.color = color;
    this._hsl_H_editor.value = color.hue;
    this._hsl_S_editor.value = color.saturation;
    this._hsl_L_editor.value = color.luminosity;
    this._hsl_T_editor.value = color.alpha;
    this._rgb_R_editor.value = color.red;
    this._rgb_G_editor.value = color.green;
    this._rgb_B_editor.value = color.blue;
    this._rgb_T_editor.value = color.alpha;
    this._hsl_H_editor.refresh();
    this._hsl_S_editor.refresh();
    this._hsl_L_editor.refresh();
    this._hsl_T_editor.refresh();
    this._rgb_R_editor.refresh();
    this._rgb_G_editor.refresh();
    this._rgb_B_editor.refresh();
    this._rgb_T_editor.refresh();
    this.selectApropriateTab(color);
  }
  AddColorScroll(container, label, colorCallback, changeCallBack, checkerBoardBg, value) {
    let RGB_R_Row = document.createElement("TR");
    let RGB_R_Col1 = document.createElement("TD");
    RGB_R_Col1.innerHTML = "&nbsp;" + label + "&nbsp;";
    let RGB_R_Col2 = document.createElement("TD");
    let RGB_R_Anchor = document.createElement("ANCHOR");
    RGB_R_Col2.appendChild(RGB_R_Anchor);
    let RGB_R_Div = document.createElement("DIV");
    RGB_R_Col2.style.width = "100%";
    RGB_R_Anchor.appendChild(RGB_R_Div);
    let RGB_R_Col3 = document.createElement("TD");
    let RGB_R_Input = document.createElement("INPUT");
    RGB_R_Col3.appendChild(RGB_R_Input);
    RGB_R_Row.appendChild(RGB_R_Col1);
    RGB_R_Row.appendChild(RGB_R_Col2);
    RGB_R_Row.appendChild(RGB_R_Col3);
    container.appendChild(RGB_R_Row);
    return new ColorEditorSroll(RGB_R_Div, RGB_R_Anchor, RGB_R_Input, colorCallback, changeCallBack, checkerBoardBg, value);
  }
  setTabIndex(index) {
    this._firstTabIndex = index;
    index = this._tabRGB.setTabIndex(index);
    index = this._tabHSL.setTabIndex(index);
    index = this._tabPredef.setTabIndex(index);
    if (this._tabRGB.active) {
      index = this._rgb_R_editor.setTabIndex(index);
      index = this._rgb_G_editor.setTabIndex(index);
      index = this._rgb_B_editor.setTabIndex(index);
      index = this._rgb_T_editor.setTabIndex(index);
    } else if (this._tabHSL.active) {
      index = this._hsl_H_editor.setTabIndex(index);
      index = this._hsl_S_editor.setTabIndex(index);
      index = this._hsl_L_editor.setTabIndex(index);
      index = this._hsl_T_editor.setTabIndex(index);
    } else {
      for (let i = 0; i < this._prefedDivs.length; i++) {
        this._prefedDivs[i].tabIndex = index++;
      }
    }
    for (let i = 0; i < this._samples.length; i++) {
      index = this._samples[i].setTabIndex(index);
    }
    return index;
  }
};
colorEditor._colorHistory = colorEditor.defaultColorHistory();
colorEditor._editorsList = [];

// obj/full/configForm_rw.js
var configEditorTab = class {
  constructor(editor, label, fontSize, GUIcoef) {
    this._realTab = false;
    this._div = null;
    this._tabLabel = null;
    this._td = document.createElement("TD");
    if (label != "") {
      this._div = document.createElement("DIV");
      this._div.style.display = "none";
      let sz = Math.round(5 * GUIcoef).toString() + "px";
      this._div.style.padding = sz + " " + sz + " " + sz + " " + sz;
      this._td.style.paddingTop = Math.round(4 * GUIcoef).toString() + "px";
      this._td.style.fontSize = fontSize.toString() + "px";
      this._td.style.paddingBottom = Math.round(2 * GUIcoef).toString() + "px";
      this._td.tabIndex = 0;
      this._td.style.borderLeft = "1px solid " + configForm.inactiveBorderColor;
      this._td.style.borderRight = "1px solid " + configForm.inactiveBorderColor;
      this._td.style.borderTop = "1px solid " + configForm.inactiveBorderColor;
      this._td.style.borderBottom = "1px solid " + configForm.activeBorderColor;
      this._td.style.color = configForm.inactiveColor;
      this._td.style.backgroundColor = configForm.inactiveBackgroundColor;
      this._td.style.borderTopLeftRadius = Math.round(3 * GUIcoef).toString() + "px";
      this._td.style.borderTopRightRadius = Math.round(3 * GUIcoef).toString() + "px";
      this._td.style.paddingLeft = "5px";
      this._td.style.paddingRight = "5px";
      this._realTab = true;
      this._tabLabel = document.createElement("ANCHOR");
      this._tabLabel.innerText = label;
      this._tabLabel.addEventListener("click", () => {
        configForm.tabSelected(this);
      });
      this._tabLabel.addEventListener("keyup", (e) => {
        if (e.key === "Enter" || e.key === " ")
          configForm.tabSelected(this);
      });
      this._tabLabel.style.cursor = "pointer";
      this._td.appendChild(this._tabLabel);
    } else {
      this._td.style.borderBottom = "1px solid " + configForm.activeBorderColor;
      this._td.innerHTML = "<span>&nbsp;</span>";
    }
  }
  setTabIndex(index) {
    this._tabLabel.tabIndex = index++;
    return index;
  }
  set active(value) {
    if (!this._realTab)
      return;
    this._td.style.borderLeftColor = value ? configForm.activeBorderColor : configForm.inactiveBorderColor;
    this._td.style.borderTopColor = value ? configForm.activeBorderColor : configForm.inactiveBorderColor;
    this._td.style.borderRightColor = value ? configForm.activeBorderColor : configForm.inactiveBorderColor;
    this._td.style.borderBottomColor = value ? "rgba(0, 0, 0, 0)" : configForm.activeBorderColor;
    this._td.style.color = value ? configForm.activeColor : configForm.inactiveColor;
    this._td.style.backgroundColor = value ? configForm.activeBackgroundColor : configForm.inactiveBackgroundColor;
    this._div.style.display = value ? "" : "none";
  }
  get tabElement() {
    return this._td;
  }
  get divElement() {
    return this._div;
  }
};
var configForm = class {
  static get activeBorderColor() {
    return constants.WindowInnerBorderColor;
  }
  static get inactiveBorderColor() {
    return "#b0b0b0";
  }
  static get activeColor() {
    return "black";
  }
  static get inactiveColor() {
    return "grey";
  }
  static get activeBackgroundColor() {
    return constants.WindowInnerBackgroundColor;
  }
  static get inactiveBackgroundColor() {
    return constants.WindowBackgroundColor;
  }
  static hubStateChanged(source) {
    if (configForm._Hubtable == null)
      return;
    let srvNotification = source.removable ? "" : " (server)";
    for (let i = 1; i < configForm._Hubtable.childElementCount; i++) {
      if (configForm._Hubtable.childNodes[i]["YHUB"] == source) {
        configForm._Hubtable.childNodes[i].childNodes[2].innerText = source.ConnectionDescription + srvNotification;
        switch (source.ConnectionState) {
          case 2:
            configForm._Hubtable.childNodes[i].childNodes[0].innerHTML = ressources.OkIcon((1.2 * configForm.fontSize).toString(), true, false, false, false, " ");
            break;
          case 3:
            configForm._Hubtable.childNodes[i].childNodes[0].innerHTML = ressources.FailedIcon((1.2 * configForm.fontSize).toString(), true, false, false, false, " ");
            break;
          default:
            configForm._Hubtable.childNodes[i].childNodes[0].innerHTML = ressources.DontKnowIcon((1.2 * configForm.fontSize).toString(), true, false, false, false, " ");
            break;
        }
      }
    }
  }
  static RefreshUI(h) {
    for (let i = 1; i < configForm._Hubtable.childElementCount; i++) {
      if (configForm._Hubtable.childNodes[i]["YHUB"] == h) {
        configForm._Hubtable.childNodes[i].childNodes[1].innerText = h.toString();
        configForm._Hubtable.childNodes[i].childNodes[2].innerText = "...";
      }
    }
  }
  static HublineSelected(source) {
    configForm._selectedHub = null;
    for (let i = 1; i < configForm._Hubtable.childElementCount; i++) {
      if (configForm._Hubtable.childNodes[i] == source) {
        configForm._selectedHub = configForm._Hubtable.childNodes[i]["YHUB"];
        configForm._Hubtable.childNodes[i].style.backgroundColor = "#2fa5ff";
        configForm._Hubtable.childNodes[i].childNodes[0].style.color = "white";
        configForm._Hubtable.childNodes[i].childNodes[1].style.color = "white";
        configForm._Hubtable.childNodes[i].childNodes[2].style.color = "white";
      } else {
        configForm._Hubtable.childNodes[i].style.backgroundColor = "white";
        configForm._Hubtable.childNodes[i].childNodes[0].style.color = "black";
        configForm._Hubtable.childNodes[i].childNodes[1].style.color = "black";
        configForm._Hubtable.childNodes[i].childNodes[2].style.color = "black";
      }
    }
    configForm._editButton.enabled = configForm._selectedHub != null;
    configForm._deleteButton.enabled = configForm._selectedHub != null;
    this._editButton.showShortcut(configForm._selectedHub != null);
    this._deleteButton.showShortcut(configForm._selectedHub != null);
  }
  static newHub() {
    HubEdit.newHub(() => {
      configForm._window.show();
    });
  }
  static AddHubToUI(hub) {
    let HubtableTR = document.createElement("TR");
    HubtableTR.style.fontSize = configForm.fontSize.toString() + "px";
    HubtableTR["YHUB"] = hub;
    HubtableTR.style.backgroundColor = "white";
    HubtableTR.style.cursor = "pointer";
    HubtableTR.tabIndex = 0;
    HubtableTR.addEventListener("keypress", (e) => {
      switch (e.key.toUpperCase()) {
        case "D":
          this._deleteButton.performAction();
          break;
        case "E":
          this._editButton.performAction();
          break;
      }
    });
    HubtableTR.style.outline = "none";
    HubtableTR.addEventListener("click", () => {
      configForm.HublineSelected(HubtableTR);
    });
    HubtableTR.addEventListener("focusin", () => {
      configForm.HublineSelected(HubtableTR);
    });
    let HubtableTD = document.createElement("TD");
    switch (hub.ConnectionState) {
      case 2:
        HubtableTD.innerHTML = ressources.OkIcon((1.2 * configForm.fontSize).toString(), true, false, false, false, " ");
        break;
      case 3:
        HubtableTD.innerHTML = ressources.FailedIcon((1.2 * configForm.fontSize).toString(), true, false, false, false, " ");
        break;
      case 1:
      default:
        HubtableTD.innerHTML = ressources.DontKnowIcon((1.2 * configForm.fontSize).toString(), true, false, false, false, " ");
    }
    HubtableTD.style.width = (2 * configForm.fontSize).toString() + "px";
    HubtableTD.style.verticalAlign = "center";
    HubtableTD.style.borderBottom = "1px solid " + configForm.inactiveBorderColor;
    HubtableTD.style.paddingLeft = "5px";
    HubtableTR.appendChild(HubtableTD);
    HubtableTD = document.createElement("TD");
    HubtableTD.innerText = hub.toString();
    HubtableTD.style.borderBottom = "1px solid " + configForm.inactiveBorderColor;
    HubtableTD.style.verticalAlign = "center";
    HubtableTD.style.height = (2 * configForm.fontSize).toString() + "px";
    HubtableTR.appendChild(HubtableTD);
    HubtableTD = document.createElement("TD");
    HubtableTD.style.verticalAlign = "center";
    HubtableTD.innerText = hub.ConnectionDescription + (hub.removable ? "" : " (server)");
    HubtableTD.style.borderBottom = "1px solid " + configForm.inactiveBorderColor;
    HubtableTR.appendChild(HubtableTD);
    configForm._Hubtable.appendChild(HubtableTR);
  }
  static editSelectedHub() {
    if (configForm._selectedHub == null)
      return;
    HubEdit.editHub(configForm._selectedHub, () => {
      configForm._window.show();
    });
  }
  static deleteSelectedHub() {
    if (configForm._selectedHub == null)
      return;
    let ExtraMessage = configForm._selectedHub.removable ? "" : "\n\nThis one is also the one serving the Yocto-Visualization software. If you remove it, you won't be able to save later on.";
    confirm.ask("Do you really want to remove connection " + configForm._selectedHub.toString() + " ?" + ExtraMessage, () => {
      if (configForm._selectedHub == null)
        return;
      configForm._selectedHub.Disconnect().then((r) => {
      });
      for (let i = configForm._Hubtable.childElementCount - 1; i > 0; i--) {
        if (configForm._Hubtable.childNodes[i]["YHUB"] == configForm._selectedHub) {
          configForm._Hubtable.removeChild(configForm._Hubtable.childNodes[i]);
        }
      }
      sensorsManager.hubWasremoved(configForm._selectedHub);
      configForm._selectedHub = null;
      configForm._editButton.enabled = false;
      configForm._deleteButton.enabled = false;
      constants.edited = true;
    }, null, null);
  }
  static hide() {
    if (configForm._window == null)
      return;
    configForm._window.visible = false;
  }
  static show() {
    if (configForm._window == null) {
      configForm.GUIcoef = constants.generalSizeCoef;
      if (configForm.REFWIDH * configForm.GUIcoef > screen.width)
        configForm.GUIcoef = screen.width / configForm.REFWIDH;
      if (configForm.REFHEIGHT * configForm.GUIcoef > screen.height)
        configForm.GUIcoef = screen.height / configForm.REFHEIGHT;
      configForm.fontSize *= configForm.GUIcoef / constants.generalSizeCoef;
      let params = new newWindowParam(configForm.GUIcoef);
      params.positionType = 1;
      params.width = Math.round(configForm.REFWIDH * this.GUIcoef);
      params.height = Math.round(configForm.REFHEIGHT * this.GUIcoef);
      params.showContainerBorders = false;
      params.title = "Global configuration";
      configForm._window = new YWindow(params);
      configForm._contents = configForm._window.innerContentDiv;
      configForm._table = document.createElement("TABLE");
      configForm._contents.appendChild(configForm._table);
      configForm._table.style.position = "absolute";
      configForm._table.style.left = "0px";
      configForm._table.style.right = "0px";
      configForm._table.style.width = "100%";
      configForm._table.style.height = "100%";
      configForm._table.style.borderSpacing = "0";
      configForm._table.style.paddingLeft = (5 * this.GUIcoef).toString() + "px";
      configForm._table.style.paddingTop = (5 * this.GUIcoef).toString() + "px";
      configForm._table.style.paddingRight = (5 * this.GUIcoef).toString() + "px";
      configForm._table.style.borderCollapse = "separate";
      configForm._tr1 = document.createElement("TR");
      configForm._tr2 = document.createElement("TR");
      configForm._tr1.style.height = (2 * configForm.fontSize).toString() + "px";
      configForm._tabNetwork = new configEditorTab(configForm, "Network", configForm.fontSize, configForm.GUIcoef);
      configForm._tabCapture = new configEditorTab(configForm, "Screen capture", configForm.fontSize, configForm.GUIcoef);
      configForm._tabResources = new configEditorTab(configForm, "Ressources", configForm.fontSize, configForm.GUIcoef);
      configForm._tabUI = new configEditorTab(configForm, "User interface", configForm.fontSize, configForm.GUIcoef);
      configForm._tabExport = new configEditorTab(configForm, "Updates & XML", configForm.fontSize, configForm.GUIcoef);
      configForm._tabStub = new configEditorTab(configForm, "", configForm.fontSize, configForm.GUIcoef);
      this._tabPanelContents = document.createElement("TD");
      this._tabPanelContents.colSpan = 6;
      this._tabPanelContents.style.borderLeft = "1px solid " + this.activeBorderColor;
      this._tabPanelContents.style.borderRight = "1px solid " + this.activeBorderColor;
      this._tabPanelContents.style.borderBottom = "1px solid " + this.activeBorderColor;
      this._tabPanelContents.style.backgroundColor = this.activeBackgroundColor;
      configForm._tr1.appendChild(this._tabNetwork.tabElement);
      configForm._tr1.appendChild(this._tabCapture.tabElement);
      configForm._tr1.appendChild(this._tabResources.tabElement);
      configForm._tr1.appendChild(this._tabUI.tabElement);
      configForm._tr1.appendChild(this._tabExport.tabElement);
      configForm._tr1.appendChild(this._tabStub.tabElement);
      configForm._tr2.appendChild(this._tabPanelContents);
      configForm._tr2.childNodes[0].style.verticalAlign = "top";
      configForm._table.appendChild(this._tr1);
      configForm._table.appendChild(this._tr2);
      let p = document.createElement("P");
      p.style.textAlign = "justify";
      p.style.fontSize = configForm.fontSize.toString() + "px";
      p.style.paddingTop = "0px";
      p.style.marginTop = Math.round(3 * this.GUIcoef).toString() + "px";
      p.innerText = "Enter the list of VirtualHub or YoctoHub this page can connect to";
      this._tabNetwork.divElement.appendChild(p);
      configForm._Hubtable = document.createElement("TABLE");
      configForm._Hubtable.style.position = "absolute";
      configForm._Hubtable.style.display = "block";
      configForm._Hubtable.style.left = Math.round(20 * this.GUIcoef).toString() + "px";
      configForm._Hubtable.style.right = Math.round(20 * this.GUIcoef).toString() + "px";
      configForm._Hubtable.style.tableLayout = "auto";
      configForm._Hubtable.style.top = Math.round(80 * this.GUIcoef).toString() + "px";
      configForm._Hubtable.style.bottom = Math.round(40 * this.GUIcoef).toString() + "px";
      configForm._Hubtable.style.borderCollapse = "colapse";
      configForm._Hubtable.style.borderSpacing = "0px";
      configForm._Hubtable.style.border = "1px solid " + configForm.activeBorderColor;
      let HubtableTR = document.createElement("TR");
      HubtableTR.style.fontSize = configForm.fontSize.toString() + "px";
      let HubtableTH = document.createElement("TH");
      HubtableTH.colSpan = 2;
      HubtableTH.innerText = "Address";
      HubtableTH.style.borderBottom = "1px solid " + configForm.activeBorderColor;
      HubtableTH.style.width = Math.round(400 * this.GUIcoef).toString() + "px";
      HubtableTR.appendChild(HubtableTH);
      HubtableTH = document.createElement("TH");
      HubtableTH.innerText = "Status";
      HubtableTH.style.width = "40%";
      HubtableTH.style.borderBottom = "1px solid " + configForm.activeBorderColor;
      HubtableTH.style.borderLeft = "1px solid " + configForm.activeBorderColor;
      HubtableTR.appendChild(HubtableTH);
      configForm._Hubtable.appendChild(HubtableTR);
      let hubList = sensorsManager.hubList;
      for (let i = 0; i < hubList.length; i++) {
        configForm.AddHubToUI(hubList[i]);
      }
      let div = document.createElement("DIV");
      div.style.position = "absolute";
      div.style.bottom = "0px";
      div.style.right = Math.round(20 * configForm.GUIcoef).toString() + "px";
      div.style.height = Math.round(30 * configForm.GUIcoef).toString() + "px";
      div.style.textAlign = "right";
      div.style.verticalAlign = "center";
      configForm._newButton = new button("New", () => {
        configForm._window.hide();
        configForm.newHub();
      }, configForm.GUIcoef);
      div.appendChild(configForm._newButton.Element);
      configForm._editButton = new button("Edit", () => {
        configForm._window.hide();
        configForm.editSelectedHub();
      }, configForm.GUIcoef);
      configForm._editButton.enabled = false;
      div.appendChild(configForm._editButton.Element);
      configForm._deleteButton = new button("Delete", () => {
        configForm.deleteSelectedHub();
      }, configForm.GUIcoef);
      configForm._deleteButton.enabled = false;
      div.appendChild(configForm._deleteButton.Element);
      this._tabNetwork.divElement.appendChild(div);
      this._tabNetwork.divElement.appendChild(configForm._Hubtable);
      p = document.createElement("P");
      p.innerHTML = "Widgets content can be captured at anytime thought the <i>Snapshop</i> option available in right-click contextual menu";
      p.style.textAlign = "justify";
      p.style.fontSize = configForm.fontSize.toString() + "px";
      this._tabCapture.divElement.appendChild(p);
      let tableSize = document.createElement("TABLE");
      tableSize.style.fontSize = configForm.fontSize.toString() + "px";
      let row = document.createElement("TR");
      let td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      td.innerText = "ImageType";
      row.appendChild(td);
      td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      td.style.verticalAlign = "center";
      configForm.inputPNG = document.createElement("INPUT");
      configForm.inputSVG = document.createElement("INPUT");
      configForm.inputPNG.checked = constants.captureType == YDataRenderer.CaptureType.PNG;
      configForm.inputPNG.style.display = "inline";
      configForm.inputPNG.type = "checkbox";
      configForm.inputPNG.style.transform = "scale(" + this.GUIcoef.toString() + ")";
      configForm.inputPNG.style.marginRight = Math.round(5 * this.GUIcoef).toString() + "px";
      configForm.inputPNG.style.marginLeft = Math.round(5 * this.GUIcoef).toString() + "px";
      configForm.inputPNG.addEventListener("change", () => {
        configForm.captureFormatChange(configForm.inputPNG);
      });
      td.append(configForm.inputPNG);
      let span;
      span = document.createElement("SPAN");
      span.innerText = YDataRenderer.CaptureType.PNG.description;
      td.append(span);
      configForm.inputSVG = document.createElement("INPUT");
      configForm.inputSVG.checked = constants.captureType == YDataRenderer.CaptureType.SVG;
      configForm.inputSVG.style.display = "inline";
      configForm.inputSVG.type = "checkbox";
      configForm.inputSVG.style.transform = "scale(" + this.GUIcoef.toString() + ")";
      configForm.inputSVG.style.marginRight = Math.round(5 * this.GUIcoef).toString() + "px";
      configForm.inputSVG.style.marginLeft = Math.round(5 * this.GUIcoef).toString() + "px";
      configForm.inputSVG.addEventListener("change", () => {
        configForm.captureFormatChange(configForm.inputSVG);
      });
      td.append(configForm.inputSVG);
      span = document.createElement("SPAN");
      span.innerText = YDataRenderer.CaptureType.SVG.description;
      td.append(span);
      row.appendChild(td);
      tableSize.appendChild(row);
      row = document.createElement("TR");
      td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      td.innerText = "Resolution:";
      row.appendChild(td);
      td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      configForm.inputResolution = document.createElement("INPUT");
      configForm.inputResolution.style.fontFamily = constants.generalFontFamily;
      configForm.inputResolution.style.fontSize = constants.generalFontSize.toString() + "px";
      configForm.inputResolution.style.border = "1px solid grey";
      configForm.inputResolution.type = "number";
      configForm.inputResolution.style.textAlign = "right";
      configForm.inputResolution.style.marginRight = "5px";
      configForm.inputResolution.style.width = "60px";
      configForm.inputResolution.value = constants.captureDPI.toString();
      configForm.inputResolution.style.display = "inline";
      new InputFieldManager(configForm.inputResolution, 6, false, Number.NaN, Number.NaN, (sender, refreshInput) => {
        configForm.captureDPIChange(configForm.inputResolution);
      });
      td.append(configForm.inputResolution);
      span = document.createElement("SPAN");
      span.innerText = "DPI";
      td.append(span);
      row.appendChild(td);
      tableSize.appendChild(row);
      row = document.createElement("TR");
      td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      td.innerText = "Size:";
      td.style.verticalAlign = "top";
      row.appendChild(td);
      td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      configForm.inputSizeSelect = document.createElement("SELECT");
      configForm.inputSizeSelect.style.border = "1px solid grey";
      configForm.inputSizeSelect.style.fontFamily = constants.generalFontFamily;
      configForm.inputSizeSelect.style.fontSize = constants.generalFontSize.toString() + "px";
      let sizingOptions = YDataRenderer.CaptureFormats.Keep.sibblings;
      for (let i = 0; i < sizingOptions.length; i++) {
        let option = document.createElement("OPTION");
        option.text = sizingOptions[i].description;
        option.value = sizingOptions[i].toString;
        configForm.inputSizeSelect.add(option, null);
      }
      configForm.inputSizeSelect.value = constants.captureSizePolicy.toString;
      configForm.inputSizeSelect.addEventListener("change", () => {
        configForm.captureSizeSelectChange(configForm.inputSizeSelect);
      });
      td.append(configForm.inputSizeSelect);
      row.appendChild(td);
      tableSize.appendChild(row);
      let subtable = document.createElement("TABLE");
      configForm.captureWidthTR = document.createElement("TR");
      let subTD = document.createElement("TD");
      subTD.style.fontSize = configForm.fontSize.toString() + "px";
      subTD.innerText = "Width:";
      configForm.captureWidthTR.appendChild(subTD);
      subTD = document.createElement("TD");
      subTD.style.fontSize = configForm.fontSize.toString() + "px";
      configForm.inputCaptureWidth = document.createElement("INPUT");
      configForm.inputCaptureWidth.style.border = "1px solid grey";
      configForm.inputCaptureWidth.style.fontFamily = constants.generalFontFamily;
      configForm.inputCaptureWidth.style.fontSize = constants.generalFontSize.toString() + "px";
      configForm.inputCaptureWidth.type = "number";
      configForm.inputCaptureWidth.style.textAlign = "right";
      configForm.inputCaptureWidth.style.marginRight = "5px";
      configForm.inputCaptureWidth.style.width = "60px";
      configForm.inputCaptureWidth.value = constants.captureWidth.toString();
      configForm.inputCaptureWidth.style.display = "inline";
      new InputFieldManager(configForm.inputCaptureWidth, 3, false, Number.NaN, Number.NaN, (sender, refreshInput) => {
        configForm.captureWidthChange(configForm.inputCaptureWidth);
      });
      subTD.append(configForm.inputCaptureWidth);
      configForm.inputCaptureWidthInfo = document.createElement("SPAN");
      configForm.inputCaptureWidthInfo.innerText = "pixels";
      subTD.append(configForm.inputCaptureWidthInfo);
      configForm.captureWidthTR.appendChild(subTD);
      subtable.appendChild(configForm.captureWidthTR);
      configForm.captureHeightTR = document.createElement("TR");
      subTD = document.createElement("TD");
      subTD.style.fontSize = configForm.fontSize.toString() + "px";
      subTD.innerText = "Height:";
      configForm.captureHeightTR.appendChild(subTD);
      subTD = document.createElement("TD");
      subTD.style.fontSize = configForm.fontSize.toString() + "px";
      configForm.inputCaptureHeight = document.createElement("INPUT");
      configForm.inputCaptureHeight.style.border = "1px solid grey";
      configForm.inputCaptureHeight.style.fontFamily = constants.generalFontFamily;
      configForm.inputCaptureHeight.style.fontSize = constants.generalFontSize.toString() + "px";
      configForm.inputCaptureHeight.type = "number";
      configForm.inputCaptureHeight.style.textAlign = "right";
      configForm.inputCaptureHeight.style.marginRight = "5px";
      configForm.inputCaptureHeight.style.width = "60px";
      configForm.inputCaptureHeight.value = constants.captureHeight.toString();
      configForm.inputCaptureHeight.style.display = "inline";
      new InputFieldManager(configForm.inputCaptureHeight, 3, false, Number.NaN, Number.NaN, (sender, refreshInput) => {
        configForm.captureHeightChange(configForm.inputCaptureHeight);
      });
      subTD.append(configForm.inputCaptureHeight);
      configForm.inputCaptureHeightInfo = document.createElement("SPAN");
      configForm.inputCaptureHeightInfo.innerText = "pixels";
      subTD.append(configForm.inputCaptureHeightInfo);
      configForm.captureHeightTR.appendChild(subTD);
      subtable.appendChild(configForm.captureHeightTR);
      td.appendChild(subtable);
      configForm._tabCapture.divElement.appendChild(tableSize);
      let tableRessources = document.createElement("TABLE");
      row = document.createElement("TR");
      td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      td.innerText = "If you plan to use YoctoVisualization continuously for an extended period of time (i.e. several weeks),  or if you are running it on a computer with limited resources, you may want to limit the application memory consumption.";
      td.colSpan = 2;
      td.style.textAlign = "justify";
      row.appendChild(td);
      tableRessources.appendChild(row);
      row = document.createElement("TR");
      td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      td.innerText = "Max count of sensors data records:";
      row.appendChild(td);
      td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      let maxSensorRecs = document.createElement("INPUT");
      maxSensorRecs.style.border = "1px solid grey";
      maxSensorRecs.style.fontFamily = constants.generalFontFamily;
      maxSensorRecs.style.fontSize = constants.generalFontSize.toString() + "px";
      maxSensorRecs.type = "number";
      maxSensorRecs.style.textAlign = "right";
      maxSensorRecs.style.marginRight = "5px";
      maxSensorRecs.style.marginLeft = "5px";
      maxSensorRecs.style.width = "60px";
      maxSensorRecs.value = constants.maxDataRecordsPerSensor.toString();
      maxSensorRecs.style.display = "inline";
      new InputFieldManager(maxSensorRecs, 2, false, Number.NaN, Number.NaN, (sender, refreshInput) => {
        configForm.maxSensorRecsChange(maxSensorRecs);
      });
      td.append(maxSensorRecs);
      span = document.createElement("SPAN");
      span.innerText = "(0 = unlimited)";
      td.append(span);
      row.appendChild(td);
      tableRessources.appendChild(row);
      row = document.createElement("TR");
      td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      td.innerText = "Max count of graph series data points:";
      row.appendChild(td);
      td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      let maxSeriesRecs = document.createElement("INPUT");
      maxSeriesRecs.style.border = "1px solid grey";
      maxSeriesRecs.style.fontFamily = constants.generalFontFamily;
      maxSeriesRecs.style.fontSize = constants.generalFontSize.toString() + "px";
      maxSeriesRecs.type = "number";
      maxSeriesRecs.style.textAlign = "right";
      maxSeriesRecs.style.marginRight = "5px";
      maxSeriesRecs.style.marginLeft = "5px";
      maxSeriesRecs.style.width = "60px";
      maxSeriesRecs.value = constants.maxPointsPerGraphSerie.toString();
      maxSeriesRecs.style.display = "inline";
      new InputFieldManager(maxSeriesRecs, 2, false, Number.NaN, Number.NaN, (sender, refreshInput) => {
        configForm.maxSeriesRecsChange(maxSeriesRecs);
      });
      td.append(maxSeriesRecs);
      span = document.createElement("SPAN");
      span.innerText = "(0 = unlimited)";
      td.append(span);
      row.appendChild(td);
      tableRessources.appendChild(row);
      row = document.createElement("TR");
      td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      td.innerText = "\nYocto-Visualization automatically loads datalogger contents for all connected devices.  If you are using networked devices featuring  billable data transfers (GSM) you may want to limit or even disable that feature.";
      td.colSpan = 2;
      td.style.textAlign = "justify";
      row.appendChild(td);
      tableRessources.appendChild(row);
      row = document.createElement("TR");
      td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      td.innerText = "Max data points/series loaded from dataloggers:";
      row.appendChild(td);
      td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      let maxDataLogRecs = document.createElement("INPUT");
      maxDataLogRecs.style.border = "1px solid grey";
      maxDataLogRecs.style.fontFamily = constants.generalFontFamily;
      maxDataLogRecs.style.fontSize = constants.generalFontSize.toString() + "px";
      maxDataLogRecs.type = "number";
      maxDataLogRecs.style.textAlign = "right";
      maxDataLogRecs.style.marginRight = "5px";
      maxDataLogRecs.style.marginLeft = "5px";
      maxDataLogRecs.style.width = "60px";
      maxDataLogRecs.value = constants.maxPointsPerDataloggerSerie.toString();
      maxDataLogRecs.style.display = "inline";
      new InputFieldManager(maxDataLogRecs, 1, false, -1, Number.NaN, (sender, refreshInput) => {
        configForm.maxDataLogRecsChange(maxDataLogRecs);
      });
      td.append(maxDataLogRecs);
      span = document.createElement("SPAN");
      span.innerText = "(0 = unlimited,\n-1 = disabled)";
      td.append(span);
      row.appendChild(td);
      tableRessources.appendChild(row);
      row = document.createElement("TR");
      td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      td.innerText = "After a  limit increase, you'll have to restart the application to get your old data back.";
      td.colSpan = 2;
      td.style.textAlign = "justify";
      row.appendChild(td);
      tableRessources.appendChild(row);
      configForm._tabResources.divElement.appendChild(tableRessources);
      p = document.createElement("P");
      p.style.fontSize = configForm.fontSize.toString() + "px";
      p.innerText = "You can alter user interface behavior according to your hardware capabilities.";
      this._tabUI.divElement.appendChild(p);
      let checkbox1 = document.createElement("INPUT");
      checkbox1.style.fontFamily = constants.generalFontFamily;
      checkbox1.style.fontSize = constants.generalFontSize.toString() + "px";
      checkbox1.style.display = "inline";
      checkbox1.type = "checkbox";
      checkbox1.style.transform = "scale(" + this.GUIcoef.toString() + ")";
      checkbox1.style.marginRight = Math.round(5 * this.GUIcoef).toString() + "px";
      checkbox1.checked = constants.dbleClickBringsUpContextMenu;
      checkbox1.addEventListener("change", () => {
        configForm.dbleClickBringsUpContextMenuChange(checkbox1);
      });
      this._tabUI.divElement.appendChild(checkbox1);
      span = document.createElement("SPAN");
      span.style.fontSize = configForm.fontSize.toString() + "px";
      span.innerText = "Double click/tap  brings up context menu\n";
      this._tabUI.divElement.appendChild(span);
      let checkbox2 = document.createElement("INPUT");
      checkbox2.style.display = "inline";
      checkbox2.type = "checkbox";
      checkbox2.style.transform = "scale(" + this.GUIcoef.toString() + ")";
      checkbox2.style.marginRight = Math.round(5 * this.GUIcoef).toString() + "px";
      checkbox2.checked = YGraph.verticalDragZoomEnabled;
      checkbox2.addEventListener("change", () => {
        configForm.verticalDragZoomChange(checkbox2);
      });
      this._tabUI.divElement.appendChild(checkbox2);
      span = document.createElement("SPAN");
      span.style.fontSize = configForm.fontSize.toString() + "px";
      span.innerText = "Graphs zoom can be driven by vertical drag\n";
      this._tabUI.divElement.appendChild(span);
      p = document.createElement("P");
      p.style.fontSize = configForm.fontSize.toString() + "px";
      p.innerText = "Yocto-Visualization tries to ajust UI size to screen resolution the best it can through a DPI based zoom factor. Unfortunately not all devices can properly report their screen resolution. That's why you can manually override that factor.";
      this._tabUI.divElement.appendChild(p);
      let DPIoverride = document.createElement("INPUT");
      let checkbox3 = document.createElement("INPUT");
      checkbox3.style.display = "inline";
      checkbox3.type = "checkbox";
      checkbox3.style.transform = "scale(" + this.GUIcoef.toString() + ")";
      checkbox3.style.marginRight = Math.round(5 * this.GUIcoef).toString() + "px";
      checkbox3.checked = constants.guiDPIFactorIsOverriden;
      checkbox3.addEventListener("change", () => {
        configForm.DPIoverrideChange(checkbox3, DPIoverride);
      });
      this._tabUI.divElement.appendChild(checkbox3);
      span = document.createElement("SPAN");
      span.style.fontSize = configForm.fontSize.toString() + "px";
      span.innerText = "Override zoom factor to ";
      this._tabUI.divElement.appendChild(span);
      DPIoverride.style.border = "1px solid grey";
      DPIoverride.style.fontFamily = constants.generalFontFamily;
      DPIoverride.style.fontSize = constants.generalFontSize.toString() + "px";
      DPIoverride.disabled = !constants.guiDPIFactorIsOverriden;
      DPIoverride.type = "number";
      DPIoverride.style.textAlign = "right";
      DPIoverride.style.marginRight = "5px";
      DPIoverride.style.marginLeft = "5px";
      DPIoverride.style.width = "60px";
      DPIoverride.value = constants.guiDPIFactorOverrideValue.toString();
      DPIoverride.style.display = "inline";
      new InputFieldManager(DPIoverride, 5, false, Number.NaN, Number.NaN, (sender, refreshInput) => {
        configForm.DPIoverrideChange(checkbox3, DPIoverride);
      });
      this._tabUI.divElement.appendChild(DPIoverride);
      p = document.createElement("P");
      p.style.fontSize = configForm.fontSize.toString() + "px";
      p.innerText = "This setting is stored in your browser cookies. So it is specific to this device, browser and server.You will have to reload this page for this setting to take effect";
      this._tabUI.divElement.appendChild(p);
      p = document.createElement("P");
      p.style.fontSize = configForm.fontSize.toString() + "px";
      p.style.textAlign = "justify";
      p.innerText = "As long as your web browser can reach www.yoctopuce.com, the read/write edition of Yocto-Visualization (for web) can automatically check for new version. If you find this feature anoying, feel free to disable it. ";
      this._tabExport.divElement.appendChild(p);
      let checkbox4 = document.createElement("INPUT");
      checkbox4.style.display = "inline";
      checkbox4.type = "checkbox";
      checkbox4.style.transform = "scale(" + this.GUIcoef.toString() + ")";
      checkbox4.style.marginLeft = Math.round(25 * this.GUIcoef).toString() + "px";
      checkbox4.checked = constants.mustCheckForUpdate;
      checkbox4.addEventListener("change", () => {
        configForm.mustCheckForUpdateChange(checkbox4);
      });
      this._tabExport.divElement.appendChild(checkbox4);
      span = document.createElement("SPAN");
      span.style.fontSize = configForm.fontSize.toString() + "px";
      span.innerText = "Automatically check for updates";
      let a2 = document.createElement("A");
      a2.innerText = "Check now";
      a2.style.paddingLeft = "25px";
      a2.style.cursor = "pointer";
      a2.style.color = "#0000EE";
      a2.style.textDecoration = "underline";
      a2.addEventListener("click", () => {
        YWebPage.CheckForNewVersion(true);
      });
      span.appendChild(a2);
      this._tabExport.divElement.appendChild(span);
      p = document.createElement("P");
      p.style.fontSize = configForm.fontSize.toString() + "px";
      p.style.textAlign = "justify";
      p.innerText = "Yocto-Visualization (for web) stores its configuration in a XML file. This file can be used to create a static web page running Yocto-Visualization (for web) or it can be used in the Yocto-Visualization (for web) installer to create a pre-configured install. Also, it is mostly compatible with the native version of Yocto-Visualization: you can use it instead of the original config.xml file. Just click on the link below to export/download your current configuration.";
      this._tabExport.divElement.appendChild(p);
      p = document.createElement("P");
      p.style.fontSize = configForm.fontSize.toString() + "px";
      p.style.textAlign = "right";
      let a = document.createElement("A");
      a.innerText = "Export current configuration";
      a.style.cursor = "pointer";
      a.style.color = "#0000EE";
      a.style.textDecoration = "underline";
      a.addEventListener("click", () => {
        configForm.downloadCurrentConfig();
      });
      p.appendChild(a);
      this._tabExport.divElement.appendChild(p);
      configForm._tabPanelContents.appendChild(this._tabNetwork.divElement);
      configForm._tabPanelContents.appendChild(this._tabCapture.divElement);
      configForm._tabPanelContents.appendChild(this._tabResources.divElement);
      configForm._tabPanelContents.appendChild(this._tabUI.divElement);
      configForm._tabPanelContents.appendChild(this._tabExport.divElement);
      configForm.tabSelected(this._tabNetwork);
      configForm.refreshSizeParams();
    }
    configForm._window.show();
  }
  static DPIoverrideChange(checkbox, input) {
    let value = parseFloat(input.value);
    input.disabled = !checkbox.checked;
    if (checkbox.checked && value > 0) {
      constants.overrideGuiDPIFactor(true, value);
    } else {
      constants.overrideGuiDPIFactor(false);
    }
  }
  static hubWasAdded(hub) {
    if (sensorsManager.newHubCreated(hub)) {
      configForm.AddHubToUI(hub);
      constants.edited = true;
      hub.Connect().then((r) => {
      });
    }
  }
  static hubGotEdited(hub) {
    configForm.RefreshUI(hub);
    constants.edited = true;
    hub.Disconnect().then((r) => {
    });
    hub.Connect().then((r) => {
    });
  }
  static dbleClickBringsUpContextMenuChange(source) {
    let prev = constants.dbleClickBringsUpContextMenu;
    constants.dbleClickBringsUpContextMenu = source.checked;
    if (prev != constants.dbleClickBringsUpContextMenu)
      constants.edited = true;
  }
  static verticalDragZoomChange(source) {
    let prev = YGraph.verticalDragZoomEnabled;
    YGraph.verticalDragZoomEnabled = source.checked;
    if (prev != YGraph.verticalDragZoomEnabled)
      constants.edited = true;
  }
  static mustCheckForUpdateChange(source) {
    let prev = constants.mustCheckForUpdate;
    constants.mustCheckForUpdate = source.checked;
    if (prev != constants.mustCheckForUpdate)
      constants.edited = true;
  }
  static maxDataLogRecsChange(source) {
    let value = parseInt(source.value);
    if (value != constants.maxPointsPerDataloggerSerie || value != CustomYSensor.MaxLoggerRecords) {
      constants.maxPointsPerDataloggerSerie = value;
      CustomYSensor.MaxLoggerRecords = value;
      constants.edited = true;
    }
  }
  static maxSeriesRecsChange(source) {
    let value = parseInt(source.value);
    if (value != constants.maxPointsPerGraphSerie || value != DataSerie.MaxPointsPerSeries) {
      constants.maxPointsPerGraphSerie = value;
      DataSerie.MaxPointsPerSeries = value;
      constants.edited = true;
    }
  }
  static maxSensorRecsChange(source) {
    let value = parseInt(source.value);
    if (value != constants.maxDataRecordsPerSensor || value != CustomYSensor.MaxDataRecords) {
      constants.maxDataRecordsPerSensor = value;
      CustomYSensor.MaxDataRecords = value;
      constants.edited = true;
    }
  }
  static captureDPIChange(source) {
    let prev = constants.captureDPI;
    constants.captureDPI = parseInt(source.value);
    if (constants.captureDPI != prev)
      constants.edited = true;
    configForm.refreshSizeParams();
  }
  static captureWidthChange(source) {
    let prev = constants.captureWidth;
    constants.captureWidth = parseInt(source.value);
    if (constants.captureWidth != prev)
      constants.edited = true;
    configForm.refreshSizeParams();
  }
  static captureHeightChange(source) {
    let prev = constants.captureHeight;
    constants.captureHeight = parseInt(source.value);
    if (constants.captureHeight != prev)
      constants.edited = true;
    configForm.refreshSizeParams();
  }
  static captureSizeSelectChange(source) {
    let prev = constants.captureSizePolicy;
    constants.captureSizePolicy = YDataRenderer.CaptureFormats.fromString(YDataRenderer.CaptureFormats, source.value);
    if (constants.captureSizePolicy != prev)
      constants.edited = true;
    configForm.refreshSizeParams();
  }
  static refreshSizeParams() {
    let value = YDataRenderer.CaptureFormats.fromString(YDataRenderer.CaptureFormats, configForm.inputSizeSelect.value);
    if (value == YDataRenderer.CaptureFormats.Keep) {
      configForm.captureWidthTR.style.display = "none";
      configForm.captureHeightTR.style.display = "none";
    } else if (value == YDataRenderer.CaptureFormats.FixedWidth) {
      configForm.captureWidthTR.style.display = "";
      configForm.captureHeightTR.style.display = "none";
    } else if (value == YDataRenderer.CaptureFormats.FixedHeight) {
      configForm.captureWidthTR.style.display = "none";
      configForm.captureHeightTR.style.display = "";
    }
    if (value == YDataRenderer.CaptureFormats.Fixed) {
      configForm.captureWidthTR.style.display = "";
      configForm.captureHeightTR.style.display = "";
    }
    let sw = 25.4 * parseInt(configForm.inputCaptureWidth.value) / parseInt(configForm.inputResolution.value);
    configForm.inputCaptureWidthInfo.innerText = "Pixels  (" + sw.toFixed(1) + "mm)";
    let sh = 25.4 * parseInt(configForm.inputCaptureHeight.value) / parseInt(configForm.inputResolution.value);
    configForm.inputCaptureHeightInfo.innerText = "Pixels  (" + sh.toFixed(1) + "mm)";
  }
  static downloadCurrentConfig() {
    let element = document.createElement("a");
    let data = "data:text/xml;base64," + btoa(YWebPage.get_XmlData());
    element.setAttribute("href", data);
    element.setAttribute("download", "config.xml");
    element.style.display = "none";
    document.body.appendChild(element);
    element.click();
    document.body.removeChild(element);
  }
  static captureFormatChange(source) {
    if (source == configForm.inputPNG)
      configForm.inputSVG.checked = !source.checked;
    if (source == configForm.inputSVG)
      configForm.inputPNG.checked = !source.checked;
    let prev = constants.captureType;
    constants.captureType = configForm.inputPNG.checked ? YDataRenderer.CaptureType.PNG : YDataRenderer.CaptureType.SVG;
    if (constants.captureType != prev)
      constants.edited = true;
  }
  static tabSelected(source) {
    this._tabNetwork.active = source == this._tabNetwork;
    this._tabCapture.active = source == this._tabCapture;
    this._tabResources.active = source == this._tabResources;
    this._tabUI.active = source == this._tabUI;
    this._tabExport.active = source == this._tabExport;
  }
};
configForm.GUIcoef = 1;
configForm.REFWIDH = 520;
configForm.REFHEIGHT = 300;
configForm.fontSize = constants.generalFontSize;

// obj/full/HubEdit_rw.js
var HubEdit = class {
  static get activeBorderColor() {
    return constants.WindowInnerBorderColor;
  }
  static get inactiveBorderColor() {
    return "#b0b0b0";
  }
  static get activeColor() {
    return "black";
  }
  static get inactiveColor() {
    return "grey";
  }
  static get activeBackgroundColor() {
    return constants.WindowInnerBackgroundColor;
  }
  static get inactiveBackgroundColor() {
    return constants.WindowBackgroundColor;
  }
  static newHub(whenDone) {
    HubEdit._currenthub = new Hub(2, "ws", "", "", true, "", "", "");
    HubEdit.show(HubEdit._currenthub);
    HubEdit._window.title = "New Connection";
    HubEdit._thisIsEditing = false;
    HubEdit._whenDone = whenDone;
  }
  static editHub(hub, whenDone) {
    HubEdit._currenthub = hub;
    HubEdit.show(HubEdit._currenthub);
    HubEdit._window.title = "Edit Connection";
    HubEdit._thisIsEditing = true;
    HubEdit._whenDone = whenDone;
  }
  static show(hub) {
    if (HubEdit._window == null) {
      HubEdit._okButton = new button("Ok", () => {
        HubEdit.okClicked();
      });
      HubEdit._cancelButton = new button("Cancel", () => {
        HubEdit.hide();
      });
      let params = new newWindowParam();
      params.positionType = 1;
      params.width = Math.round(450 * constants.generalSizeCoef);
      params.height = Math.round(280 * constants.generalSizeCoef);
      params.isModal = true;
      params.closeIcon = false;
      params.title = "...";
      params.buttons.push(HubEdit._okButton);
      params.buttons.push(HubEdit._cancelButton);
      HubEdit._window = new YWindow(params);
      HubEdit._contents = HubEdit._window.innerContentDiv;
      let p = document.createElement("P");
      p.style.paddingTop = "0px";
      p.style.marginTop = Math.round(3 * constants.generalSizeCoef).toString() + "px";
      p.style.lineHeight = Math.round(12 * constants.generalSizeCoef).toString() + "px";
      p.innerText = "Enter the hub connection parameter, The only mandatory parameter is the address, just leave the other fields empty if you want to use default values";
      p.style.textAlign = "justify";
      HubEdit._contents.appendChild(p);
      p.appendChild(document.createElement("BR"));
      p.appendChild(document.createElement("BR"));
      let span = document.createElement("SPAN");
      span.innerText = "Protocol:";
      span.style.marginLeft = "20px";
      p.appendChild(span);
      HubEdit._protocolSelect = document.createElement("SELECT");
      HubEdit._protocolSelect.style.border = "1px solid grey";
      HubEdit._protocolSelect.style.fontFamily = constants.generalFontFamily;
      HubEdit._protocolSelect.style.fontSize = constants.generalFontSize.toString() + "px";
      let httpOption = document.createElement("OPTION");
      httpOption.text = "http";
      httpOption.value = "http";
      HubEdit._protocolSelect.appendChild(httpOption);
      let httpsOption = document.createElement("OPTION");
      httpsOption.text = "https";
      httpsOption.value = "https";
      HubEdit._protocolSelect.appendChild(httpsOption);
      let wsOption = document.createElement("OPTION");
      wsOption.text = "ws";
      wsOption.value = "ws";
      HubEdit._protocolSelect.appendChild(wsOption);
      let wssOption = document.createElement("OPTION");
      wssOption.text = "wss";
      wssOption.value = "wss";
      HubEdit._protocolSelect.appendChild(wssOption);
      p.appendChild(HubEdit._protocolSelect);
      span = document.createElement("SPAN");
      span.style.marginLeft = "20px";
      span.innerText = "Address:";
      p.appendChild(span);
      HubEdit._addressInput = document.createElement("INPUT");
      HubEdit._addressInput.style.border = "1px solid grey";
      HubEdit._addressInput.style.fontFamily = constants.generalFontFamily;
      HubEdit._addressInput.style.fontSize = constants.generalFontSize.toString() + "px";
      HubEdit._addressInput.maxLength = 512;
      HubEdit._addressInput.size = 15;
      HubEdit._addressInput.value = hub.addr;
      new InputFieldManager(HubEdit._addressInput, 0, false, Number.NaN, Number.NaN, null);
      p.appendChild(HubEdit._addressInput);
      span = document.createElement("SPAN");
      span.style.marginLeft = Math.round(20 * constants.generalSizeCoef).toString() + "px";
      span.innerText = "Port:";
      p.appendChild(span);
      HubEdit._portInput = document.createElement("INPUT");
      HubEdit._portInput.style.border = "1px solid grey";
      HubEdit._portInput.style.fontFamily = constants.generalFontFamily;
      HubEdit._portInput.style.fontSize = constants.generalFontSize.toString() + "px";
      HubEdit._portInput.style.textAlign = "right";
      HubEdit._portInput.maxLength = 5;
      HubEdit._portInput.size = 5;
      new InputFieldManager(HubEdit._portInput, 3, true, Number.NaN, Number.NaN, null);
      p.appendChild(HubEdit._portInput);
      p.appendChild(document.createElement("BR"));
      p.appendChild(document.createElement("BR"));
      span = document.createElement("SPAN");
      span.innerText = "Path:";
      span.style.marginLeft = Math.round(20 * constants.generalSizeCoef).toString() + "px";
      p.appendChild(span);
      HubEdit._pathInput = document.createElement("INPUT");
      HubEdit._pathInput.style.border = "1px solid grey";
      HubEdit._pathInput.style.fontFamily = constants.generalFontFamily;
      HubEdit._pathInput.style.fontSize = constants.generalFontSize.toString() + "px";
      HubEdit._pathInput.size = 45;
      p.appendChild(HubEdit._pathInput);
      p.appendChild(document.createElement("BR"));
      p.appendChild(document.createElement("BR"));
      span = document.createElement("SPAN");
      span.innerText = "Username:";
      span.style.marginLeft = Math.round(20 * constants.generalSizeCoef).toString() + "px";
      p.appendChild(span);
      HubEdit._usernameInput = document.createElement("INPUT");
      HubEdit._usernameInput.style.border = "1px solid grey";
      HubEdit._usernameInput.style.fontFamily = constants.generalFontFamily;
      HubEdit._usernameInput.style.fontSize = constants.generalFontSize.toString() + "px";
      HubEdit._usernameInput.size = 15;
      p.appendChild(HubEdit._usernameInput);
      span = document.createElement("SPAN");
      span.innerText = "Password:";
      span.style.marginLeft = Math.round(20 * constants.generalSizeCoef).toString() + "px";
      p.appendChild(span);
      HubEdit._passwordInput = document.createElement("INPUT");
      HubEdit._passwordInput.type = "password";
      HubEdit._passwordInput.style.border = "1px solid grey";
      HubEdit._passwordInput.style.fontFamily = constants.generalFontFamily;
      HubEdit._passwordInput.style.fontSize = constants.generalFontSize.toString() + "px";
      HubEdit._passwordInput.size = 15;
      p.appendChild(HubEdit._passwordInput);
      p = document.createElement("P");
      p.style.paddingTop = "0px";
      p.style.marginTop = Math.round(3 * constants.generalSizeCoef).toString() + "px";
      p.style.lineHeight = Math.round(12 * constants.generalSizeCoef).toString() + "px";
      p.innerText = "Important note: credentials are saved in the configuration file wich is easily accessible. Therefore, if hub is write-protected, it might be wise to use ReadOnly credentials here. When installed on a Yoctopuce hub, Yocto-Visualization (for web) will automatically ask for read/write credentials at save time if neccessary.";
      p.style.textAlign = "justify";
      HubEdit._contents.appendChild(p);
    }
    HubEdit._protocolSelect.value = hub.protocol;
    HubEdit._addressInput.value = hub.addr;
    HubEdit._portInput.value = hub.port;
    HubEdit._pathInput.value = hub.path;
    HubEdit._usernameInput.value = hub.user;
    HubEdit._passwordInput.value = hub.encryptedPassword != "" ? HubEdit.FakePassword : "";
    HubEdit._window.show();
  }
  static hide() {
    if (HubEdit._window == null)
      return;
    HubEdit._window.hide();
    HubEdit._passwordInput.value = "";
    if (HubEdit._whenDone != null)
      HubEdit._whenDone();
  }
  static okClicked() {
    HubEdit._currenthub.protocol = HubEdit._protocolSelect.value;
    HubEdit._currenthub.addr = HubEdit._addressInput.value;
    HubEdit._currenthub.port = HubEdit._portInput.value;
    HubEdit._currenthub.path = HubEdit._pathInput.value;
    HubEdit._currenthub.user = HubEdit._usernameInput.value;
    if (HubEdit._currenthub.user != "") {
      if (HubEdit._passwordInput.value != HubEdit.FakePassword) {
        HubEdit._currenthub.encryptedPassword = Hub.Encrypt(HubEdit._passwordInput.value, Hub.loginCypherPassword);
      }
    } else {
      HubEdit._currenthub.encryptedPassword = "";
    }
    if (HubEdit._thisIsEditing) {
      configForm.hubGotEdited(HubEdit._currenthub);
    } else {
      configForm.hubWasAdded(HubEdit._currenthub);
    }
    HubEdit.hide();
    if (HubEdit._whenDone != null)
      HubEdit._whenDone();
  }
};
HubEdit.FakePassword = "******";
HubEdit._thisIsEditing = false;
HubEdit._whenDone = null;
HubEdit.fontSize = constants.generalFontSize;

// obj/full/credPrompt_rw.js
var CredentialsPrompt = class {
  static get activeBorderColor() {
    return constants.WindowInnerBorderColor;
  }
  static get inactiveBorderColor() {
    return "#b0b0b0";
  }
  static get activeColor() {
    return "black";
  }
  static get inactiveColor() {
    return "grey";
  }
  static get activeBackgroundColor() {
    return constants.WindowInnerBackgroundColor;
  }
  static get inactiveBackgroundColor() {
    return constants.WindowBackgroundColor;
  }
  static get username() {
    return this._username;
  }
  static get password() {
    return this._password;
  }
  static show(targeturl, whenDone) {
    if (CredentialsPrompt._window == null) {
      CredentialsPrompt._okButton = new button("Ok", () => {
        CredentialsPrompt.okClicked();
      });
      CredentialsPrompt._cancelButton = new button("Cancel", () => {
        CredentialsPrompt.hide();
      });
      let params = new newWindowParam();
      params.positionType = 1;
      params.width = Math.round(450 * constants.generalSizeCoef);
      params.height = Math.round(175 * constants.generalSizeCoef);
      params.isModal = true;
      params.closeIcon = false;
      params.title = "Some credentials are required";
      params.buttons.push(CredentialsPrompt._okButton);
      params.buttons.push(CredentialsPrompt._cancelButton);
      CredentialsPrompt._window = new YWindow(params);
      CredentialsPrompt._contents = CredentialsPrompt._window.innerContentDiv;
      let p = document.createElement("P");
      p.style.paddingTop = "10px";
      p.style.marginTop = Math.round(5 * constants.generalSizeCoef).toString() + "px";
      p.style.lineHeight = Math.round(15 * constants.generalSizeCoef).toString() + "px";
      p.innerText = "Saving configuration on " + targeturl + " requires  read/write credentials.";
      p.style.textAlign = "justify";
      CredentialsPrompt._contents.appendChild(p);
      p.appendChild(document.createElement("BR"));
      p.appendChild(document.createElement("BR"));
      let span = document.createElement("SPAN");
      span = document.createElement("SPAN");
      span.innerText = "Username:";
      span.style.marginLeft = Math.round(20 * constants.generalSizeCoef).toString() + "px";
      p.appendChild(span);
      CredentialsPrompt._usernameInput = document.createElement("INPUT");
      CredentialsPrompt._usernameInput.style.border = "1px solid grey";
      CredentialsPrompt._usernameInput.style.fontFamily = constants.generalFontFamily;
      CredentialsPrompt._usernameInput.style.fontSize = constants.generalFontSize.toString() + "px";
      CredentialsPrompt._usernameInput.size = 15;
      p.appendChild(CredentialsPrompt._usernameInput);
      span = document.createElement("SPAN");
      span.innerText = "Password:";
      span.style.marginLeft = Math.round(20 * constants.generalSizeCoef).toString() + "px";
      p.appendChild(span);
      CredentialsPrompt._passwordInput = document.createElement("INPUT");
      CredentialsPrompt._passwordInput.type = "password";
      CredentialsPrompt._passwordInput.style.border = "1px solid grey";
      CredentialsPrompt._passwordInput.style.fontFamily = constants.generalFontFamily;
      CredentialsPrompt._passwordInput.style.fontSize = constants.generalFontSize.toString() + "px";
      CredentialsPrompt._passwordInput.size = 15;
      CredentialsPrompt._passwordInput.addEventListener("keypress", (e) => {
        if (e.key == "Enter")
          this.okClicked();
      });
      p.appendChild(CredentialsPrompt._passwordInput);
    }
    CredentialsPrompt._window.show();
    CredentialsPrompt._usernameInput.focus();
    CredentialsPrompt._whenDone = whenDone;
  }
  static hide() {
    if (CredentialsPrompt._window == null)
      return;
    CredentialsPrompt._window.hide();
    CredentialsPrompt._passwordInput.value = "";
  }
  static okClicked() {
    CredentialsPrompt._username = CredentialsPrompt._usernameInput.value;
    CredentialsPrompt._password = CredentialsPrompt._passwordInput.value;
    CredentialsPrompt.hide();
    if (CredentialsPrompt._whenDone != null)
      CredentialsPrompt._whenDone(CredentialsPrompt._usernameInput.value, CredentialsPrompt._passwordInput.value);
  }
};
CredentialsPrompt._whenDone = null;
CredentialsPrompt.fontSize = constants.generalFontSize;
CredentialsPrompt._username = "";
CredentialsPrompt._password = "";

// obj/full/YoctoVisualizationBinaries.js
var BinariesBlobs = class {
};
BinariesBlobs.ro_js = "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";
BinariesBlobs.rw_js = "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";
BinariesBlobs.ro_minjs = "H4sIAAAAAAACA+y9fX/btpIw+v9+Cll7nlS0KFmUX5JYpv1L7KTJ3Tjxxm6TNJub0hIssaVIlaQSu4m++53BO0BQkt3knO5zz+6pIwIDYDAYDAYDYGZrs/EuG5ZZ5+e4mEdJ/GdUxlna2flMLhutJ+f9XnC/kZNo1MnS5KYRdINed2/7/s6O1+g0Pn/+3L3BwrP5kHSH2bSxufUfn6K88awMh0lUFF+GWVqU+RxA8lbpEz/2vpSTuOhGYenTH5chYT+GYbwoSmh82HiaZ9O3746zLB9hIe9LTsp5njZS8hlqpvUE3mI6T8p4ltw8vjltlRWYbrTJGmqX3Uv28xJ+DtnPoV92RwqAKIArBTBWABMFEHMAHYGXDgRo0U3RS/ED2vcWj0ajn+tKQAuRLxu75KUQc29xPr8EYkbDsrZ0R5XuqNIdWrrMzrI4LZ+2jKKFKMqLSTgTbFYBW/h57SD7uV/4qZ/5kZ/4k2VDzn6Mwpz9IGHBflyFKfsxDjP2YxLytuMw8UkY9u7dy+nfMgyDe/cK+jehfzOaHtG/rcnXMC+7T5No/PHi9aOX5y8eXTx/9dKPaW5agXl+8uTlxfOLd57HWysu8igtEjorwtbknqMybyPsCejnI5KWcXmjg8o6AW4xTLKUAHETUjbKsDfgRK42BniVTtw9uy0TUrbm48Dl1sD5gr0p3TnVOc05xTm9eSs+MOwYcB2RkuTTOI0oazDsWWk2IeIOK7bJ6yIsd2TkjkVubOROjFxi0ATmULvDJxFp80kUU5RKJNYsK4jiVYsyR0AUoIL4PI3KPL5uefsOyoyM3l8alJkYVLsSlBEUf/nq5RNdHOjTszquR/qMHar5fkXne8CQ0yQIygQuQ1AmcCkih1ABEAVwpQDGCmCiAOJNKhO4wIUWOWkq09eQAnnpmN8mFVSNostEVc34JnYxtRxzOiPZ/G7FS7g68GHOwX8BINSj/8Z666+zUmtaDUcISZPu2fPNcit40BOV0cRhVgCk36EfRZziR8/Xvzo6XI83W9f/82GUVBGQZGTFy5XV2LxrVRTICuyKBMW+ukQISPnj83NZW3PKam8y7oi6ZXYOCem45bWbPk8dOVMvnanEmTp0pl4ZqV5zoT4Fel8bGmZP42syavUBtqHhUE0dmqlfm+2WLR6ajefN/WbTa//6H18bv6puVisjztSr2ib0Cd9sXFRaGTvrc6fGeuqvja//8WuN8mN3D+Y4W232SyOZUkfkOBae0uoAk6KVCS1VEyXArizZaoqvkRJfXM5GSiQhAFEAEwUwVABXCiB2CsCREoBjBXCpAIgCmCiAoQK4UgCxU4SOlAgdK4BLBUAUwEQBDBXAlQKwVxFc1+L0E8npqhZf2Szr8aF2L2wDVUAbP7OMPYwdvraxf6+8gba2a4s+rRrEsldO8uwzFxiNYZSmWdm4JAzpkoyatDxx6QZct56I1f/SyB2K3NzIvTJyiV+49Ape89hPQ8E11ZrHfmbkmjWP/MilkxBRNjHKTjo6jmN/YuQSI3c0MEU22Sr9Tgx/cvxRwJ8Uf2TwJ8IfCfyZYLbBGEmG8hBV7SwhXfyilStZCSr5QC+CuqW1FITBwLEYhP0B7tmGQp3na88V7MJ43drS/eryNzIExiflq8/pWZ7NYNBvXkZTgmvi4Ap2AAiXY+MHcTch6bicDPJ22wP2id/nH8KQCHYs35MPA8ZN756k82mzTUDmxUUDOSpC4Qefn6JkTppiPSziywQQwra+MDZ7/8H/C0iV7xGnDzHsX6J0SLKrxqQE7aM7mxeTFs/0xPAR2PNMVm1sP1KExVbnI4CVUZySXGx1Pk7m0yjFDXV0mZCQLHQyS0EOndHTzaqERl5ZJhsaBhpjcPW9GObxDMWBDW9gRIGBzJzOOkaK+CY+uBfMiIMunCTPX7+4Fhsk+H0jfv+ZZdNr/UPmvJhG+ThOxedr8/PC/Hxsfr6JR+VEfDwj8RiGjH8dRzPoCwk3AokMTzovo7x8a8HRxHci8VUeQytR8vbRdVycqvbM9OjaTtd7L9Ks/onkXxhBgJwvBJvhaMwLkp9EZWSPm0hfFDpQKRhRpIQlY4A4hzlyFuVE39szUD1v4djNV6pM50nC+fkK2OB4EqVjchwlyWU0/F3PTWEShs1HeRwlTZ4Ul1ESD+UgfLzMkpH6GmZJlocfu48TqImnRQmsQimsWMc002pc/77MYeKGKGfPyhavhG+XP85o916TdERymI9ihup9F4YJV6fyr1+1hor4T0LbGZWwS/ka9PxR2X1NMPn1HOTz0+dvn5z4rA3OxASG6SnU6y3kTzVYWkc26L+ghDmw7qJwy3KcxcAvP+NEZ2iOWlwoIMHt4cU0yiQ0U7ZJx6a0sGth426SdXMyyqPPXKBMokI0bTVH+0I7wYXJnxWMMK1L5RTFi4KUTN05ECoGXS5fYwtP8hx4sXkOUI3pvKDqRtSAjX9cxp8IXyK8Ad/b5dk8HbWCXm+z9LbgH99ucnmfq0NvDkg1n8rDdUjGON+mBUuldOAAcoTY90ZYooVHnzx3GTWGA842GwNMo+3TTNk6fult04l695bpzLabpom0bZYtG6efeutMMJTmRFcTcmnTpgCxcTBzKTJWAYmVma6jZ8mou+GJvMV0GdcUPlI/97lIZUOKbVTGlDbMObflkI7uDiH8kStrXxsFYRtlFcpJ/jylhuOifrJvdu/vSvCnWX4cpZ+iZfBBN2AFJuU0Oc5GSpAY8+Goyf5tsG22xq9HTfzL02my0bRheZhdiw03k5gL/xVxa3uCHT6LFfyj1Dg+gopEClRLtc9jEEmlAWEqJh+v4rwozfQNc+y0zJL2AWjT360pbhdBuvukGwPTXb+6av36H796B72jloEwcWAcePsGEOkWsyQuaQVVaC2B69icrWmSPco0UWXTKpwwNIdND+zmC9mryrpjUkHW7Ya2ACdOIMbcn1GltLM+U0HBskrFECVN5rXJdNgeAjtNnZsHc+MgOIKvVLCnm5bd85uiJNMTchXNk5JO4GnZ6nk0C5g3IY/j8ozkZ/E1SX7M49HTWEIFbiiR3afZj9IyfpTEUWEV3jZzRfIOTT5OSJRf3MyIVWjXo9vJmzt19qbsPoeJmcQjWt1N2epADyBV7/wN7TwkPgMqn88IkcCBTP5vPMssb0RGn2a8zFIiUrZpitm3G9o3xP5TXL+f+QgJYbO5eDSbgRhHflT9gqx2WLZhgvBsO4svhWlJXJKyzIFNjnXlH5Abp1OHzi4zKMMpMNmeTOKNIqK1tRmZtEYTXNZqJPOaQZxOoxLNCkVVF5RZtFYdVFN+ZSKv8SKPp1PH1lak07okkKxIpITWLqZKEsF5ZnekONYQEmmybpEwTOJZGOxtP9jRE3Cef9TGb6k+PoPln1y5tHJh8BhLKEB0RFfigtkFP4IuYWWw5d774sr6suB2vSW2ko/KVgJzc0AOSmErIe229/E9Gmx0W8lHWJ0cbTG4kMP7tRBd1f0QE7wFp5KjhH41QFlLuKURVvGfYLLBmo5G0+X2oI/rGKnMCsOQ3Lv3sWIp+ijsWDyLGkh5ZWF4H63oBT2wb/X8wLOrbP5nk+Gfh6ASFqA84aUFXiDw+54f7Hl+4cjcFpmpI3OXZ+omx48t2F33d3fZqZ23MPAM+mzbpXDdqeL6+sfH+0vQ3VmG7t4ydB+IzMxFhV5dZ/jxo7cgSUEaK9F/dv7ib4R+T6EvGJ7ulTmHT8i1ydqc3bWKCB+9gzA4avaabbJP9DMzdQYAHafTh3MqI0Qb5ixthJqP6RE67kmGN15by5gYX4XxlXgWjQdf/qJs4WPzmlwlvILWR5/KBJxVeTdKZpMo5DZ2/H3vHt078ST4hQnjnJCUJ9HfmHiJqgU/UYCfuvFZ0J/x93p0yY2vsfF1adOF7XU+jY2dSzMfX4qD1tw8ENWPAR3Jl/ZBKdvbAjkcWyO9B1sw+z15iLgtj5cnRdIHbCjbMhs2CsDDMLjf80Rd7aB/38MKDg97A5q9w0RGDOwHWRyOmHBYRSdeiEo2Ib3dIp3S22ztbcZee7u/C5Jna2+318cCC46JuFmCyMizLEg/zujpUpylJ6jCbfA1uMDzKLZu8kOjRNwa0r8u+RefPwv2RdE/4gdVyWYLUeTMvk9CzukiBTvQ4ZAsyS/D3aDHPpIOEWdak/aDXT8+BHC8vxDGHSS9z1EEXrEpLsvVFBo7C7Eih+GD3SNRvvNgd1/iANQXXa8tnvP2OG5ak3rGWMu41DMuaQboWdPZvCQgWcxbQbm4ADSWp31C7oXlITkq9wkeuB2wXwloVbCFlkMOKFeHPD7MoPEsRKIdgARoRfgzDVtZO2oHwHvASFB7GHGWkHtyqcTBtkfwQEKL8UIp44UiRCbYbGWdyGsn3haFgPx9IwM5ATNh9DsUAkGgB9ssH/rR3wTGC8PsqJVjyyEBWsTIVCwJGITaIDEtD+lQHYbkCHYHrJWyQ2jzE2waUrFBloMTqMNzfDF+eYcNUcG/C/aZ8s9UG8CJuGdXiHt2QBG2/Z3bWmplCL5+Zcel2oDzWpmYi6Bs5DhfWr8ibg6Yg5qNtt2bO1fEDM95xTRdkSS8Bil9+MygxekKcrcKxswul1SIumb5SyXZrQp0qa7rxI+wtDytsfUlkWGUgDbrSvRUCWq3Ltj0Nm+ZCOWCg8AaKkE2bBDyB2zHhYXf0k0wbaPUUoAmXeDHDS7M5kikrmIvnq4SMFsxDc9WCZhNSbmh6Q982doINBXSxAC4Z0NqF5hA+WFD0y4wEcd4Q2kXy9vismdDXQJ1U/RIDYM95sZ9RDGHxX3QM7lpYrdw2Ni7q8hd1x2NKvi4qpTKwYWWt6i5AyxEcVWec8wci7sDZyHAc/FDbsMvxQ+XtO8Zp5DiABJtyUNQmEJDelycvmBalF+DcelbwyRSDETFCaJOnBCUUqqzcJPrRFwGKIQ8ToQ8loJAWF7lxYGxgL0UsC69yFuvj4tKir5226qjWMpzsZSP5R2dgdJpoxa9wOE32zH9m7MbfpraKXXWijW/YWK9WAw+dh8l8ZA8Ru3d2MT2d2BftfOA/ob+ImBaxn/MyZtJXNqwuwC7Df8GEhYEkQnT45A6xDQCJduqCxQEBhn0BeSfeJmgipxR3WMSjytA/L9+TwDFxR+VfuJ//Qd+8HBPQCX0cN1EHv9fZqfDCRk9SqZZOnJUhoToSbwqhO1xUqj8n+MMuMIiw/YDf2cbMJNY5dnn1ILZ2/V3+vg/DjLPk5s3WWYj1e/7wYMdqFI0ehyNSFnF7CFUuQuU2BNdPZ5EeZmTeVEzRgouG2Z41c1qGLbmAVBiW8JleZRUKYbVPdBg0qsk+0zyKoJ4yhzsPAQS39egizj53TEMyLty5I/zeFpkqU0YGImer7p7E6XLmfYkyn93j2iw/VCDcdWEECbUj1kyImlujxcbK/gv0GHz6MYe/YfyPx0O9+Z20z3Fvgj0X5Po99huFGp6sA2g9zXA02hM0jKyWfNhpcOvkvgTcbT9YJfWuKNX+irHU30HG+yYWL7Kh5PYps3uto/CprejAb4mIxeGel3nEc5Wq81t6C5UFvT7OiSJHP0IYC4GDx7QfzVY5PkqP9zv+3uBRSAKWh1EIMz9h/g/BXkxz/+YZ3FRYbJ+bw/+00GdggP4HmAV8xAyO4tT1wzByXRfAzv//cbF3MHDQJ8C8dTBiz31HwfLRmPXFN7GRne0+p7GObnMY1viBvcf+DAHtsU4P01QdjjXHr7+7IjxfprlpCgdg4hzCgZF1TkfToo4qtanC+gfozgtLrM8c8gO/h8HnGRF6UIQBZGxkOK8d3QiUAK1RjL0gwdU6G8LhnWMBC5l/D8B45II/QeqMQR4RxIQuvYYbAsmZZDPQPm5GZHPNYuxHIFnWelmOcojUtQ/T0dxlFZmLy6eD/v4PwU2tsh/n0lUWdOnLL9x8YWOlUPqUdQpSwqgF9EnemfEFhUMDhnNhAMO53c9rNWnR3UPAfw5dQmVPk6EvhyIFwRk1PEkvrqqiCrB5HJ+vcCDb8cKiUMW7FFkNUDXwrvTsxiFQVZWrn5/x1oFKaBkURfnUFzxv8BAo8quKKfEfwagQwIDGtsP6L8aZA2fPQCV5+G2DuhcAegyqq8ADNS5BMCkQ6GEdiQd1iUzA6oC7unsQmHda0AQoGKwR9c2HbokJHGN8B7VVfsmzu5R2JUjKECnxKXh9LR8R9c552m9SUnqGHE+mxiQU3ewpetplGdZWhVhavU+JaN4Pq3dLfT6FDU1Kgy+Ru2W04dBOTWMB3uotSiGZKBn83yW2I2DYAxgm9IPHhqwbv5BPoOFPgi2TWC3DhH0URdjLG+Az/BcwinTcQiC3R0DvEaZuN+nmoRSoxg00yeq6tRDAEWFRmIej1K3/OnT/wVy73Yap+VxTqKpY2vGuUYAFuXN66yo2Z31+3LksuEwKuK0Zhf3QAzby+hT9FtWpzDgluj+tgK9cWj0UjC+SkYvomGlmm3WDcnwVAd2r8YGyEkeXdpcDIwE2zi5QatVkffUXGUw1dUTWe2hBlVlcapGUL4Vw38WJaRO5wAG7FPZ19OBHQIaVrL+bkD/VYA1DBjcFzU/0IBr+A/nF+KrtNWzaBbdRDC4M9f+G7lVjO0ZiYaTs/nVlUvhQn7ZlYD5vKqHIM/vybrca81DnEwSJpnbvI5TZ69H/+Uw2eeRc3t7f4+ttpKlnFKH8pPiTicHKPkJc+rGZTvgmxm1oXmd3USO9WaPaW1qAp5Ho1FCXFUC4XE/+lACulZcrnVI1juP0pELwT6s88Heji/NMm6purNH231wX0GdT2AtdKlkuxq7ncckTe2NLYwSKA5SbTuPk0+2JoijLf7jUEs1ADml6+Q8AD3UV6ZaJaHPCCfVn/PUvd7rWurS1YIZXjigW9m4z5RspbJfVLTDgGUrDfqC2KqmrWheTEDYJxVj0R7baQZiwC+yaVRm1S7CanRfTKULaULVtsE9Q/vhgG45BAxGZ1xP4ObaUlO1k+4ABNSbCYlKx5JGl5WHEqhms6rjRYHOp9nvdcZLyY3LNLyeAeMUzjumCle9uYaXY9gDxXj5bew0U7c5rfdEpV/ezPDSFtkIm/OUN9CUt6v1ooQ/pFFJlft7KmvVy4aFf8ZvczbIdQk7swK68WXhF6SaWulWMZ8RvL040GoMtKeF8NkPiUIhcOIQKIC+E6APWKYr3zXC3+HvKSmKcNlTLecYFPiQ7jiayZLQY/0Tr2L/lqHqVFIV/v+B36B4lYSfeGhtE6Ntctg7KveN2SYGOl490PGtBxoRfeO6DC4RZEfhZQ7z5ry8SYiT4F1x/rHOuxhBPP0iMScnu6jLiKmyOXFZpiCtypbExuvWrat5OqRn9pf8BEhLAg4k7wkbiLD3IWzSX00fEx+TTyQJA0ikv1jia3x5FfYhkf5iibTQcRLPZqAPbItaeEJz4bXK8FKO+tevLfURfll4HgCkJSQDg+InFQT/qPc7xHt5LWaJPJD7LM7RJiHOylm5VJa8DUu8YkF/vwM2O8RHmWW8st23gV7w9PlLWpZ9vu2HsZb36G2Ys3qLlbhIRAA6zutvpg/Zw1W8lB8+Fc9Y8at7/vOPvg7yFJXqPGxuNY1k9ngWNq87RjJ/VlJJPzl7Hj7cA6Siv8971WVvVUmKT5y116azKCXJBchgegc8jMqu/Oi+ePL0QsgfSFTnx5dj/g7VteKB/iVfR2U50PjYISVZTlWizkCFxSvmgXwYgYe7wyg5Ze+FZfoky+M/8f11Jedy/Ljy5AwX3fo3s84HsDWPZVlZ6PcLvEtGH7c+8OmlczpmnL72cPFkLq0YiCauaIL+lk4MU+l+MzfEhyfHEZ51sgunRWutB4jmYNtImrnser5ZQKJscU1pclfNy13jJSgyVGUNgTTaLM2UjVHeuz0lboEM5+fKC8Kxeg8pQNTb0LH1zrHKdrfBQM2U6ttUmcWfqCpQ7aWqmmmlm+tvjY2cnW6M1IpfOIqIt8zCW8pjmt+QAPXPmAduCXGHqXDn/nMpVJ0gNJnPDAZi9bPyZPuMwS19tW1Ivu/K6KY0rbjNMHJpN60C6vWaKZbvIABsAV65CWPls1eFdiH1vtBeD8q7iIHHzofEfGZbT4nFfNcfE3OhoJ4HMyDGVKQqcfGyvlHrjG8PU1mjmtjupRN3jRrHy1fULp8Etr7LNmCl3IJNSkOn4r4r2SYMP2BjuLjsPpOkptL/LCvQd83zkkzDcsD3dGpXV35ZEKpJ0H6VrSb+bvrNF+SqbHo+6R4/eXnx5LXIZV+QfwzDBLo2Qrx+/uMzWZx+QP5rVMgg24VPSDge8dpdy2nXfuZsXelYzCvMjY7l3YtXZxSxuNWEn4DWRTYDpHK9V7GrV3n38auLi1enAoJ9AcTjrCyzKe2YjU2YcyyKtbuV0m7JlVr2p+A1pUZ/UjVQhT1Qqd6lwtWlVBuowjVQSmFIYVMT4aYm0jY1j2w7QVTWWgTg50BTRZ7lf0r9tcoOHHNd4/05VwqvTWYOrjQmUbtTYRKZSl+S4Ka6JHEs77IgaTg70RCZCg0JbqIhe35LNBb+aXyX8clgqUhgN652HHT9y9JXV1eA69twt+fMeKdlfPshhslKCcuxs0nKkykxBQiQcaNUVNJRWoqTUUQitYTx1GKwTjeE7Bd0/mZbBsZ45mBVWM/MZsxnFVHsZw38d9V0LGZajvg7B+Lv6hB/950R/4sSZ8NgB+oc+m/AnW4J+P0I+BdkpZuAtdS4gzxorS/W6CLq+cvk9zcn4sJ/QzRj1tpmqG9j+crRrxLFH+q4jWkLKEcqW3BhoX9NRsKgFKMXP/XI4uNUuaH7OI2uQ+Uway27EO22bNvut0LK1PM1ZPX9g+lcSALd1XuU5BEXbTgh1to2MtDKfpEls40iB1E7RE7ncsUqA4VxCE4j7h8bd9OHpGY3fRqnmsPVcU6ikhoVorQBQ9eQm+mptgHEMeWDp/PWrYkwre5Rp3xbOmU7UYp6KFu9d2/jaZd17XhChr+fxAWdf3frm3gwjTVbr6Advf5rPY2uKz2NrllPo2vlpk62etueRte1PQUiqJ7GaV1Po+u/3NOFP/oX2uzptIqq7yM/Kp+ALLt0ulXFWZOTKx6ngnM6JYXpq48mMfd8/EWocNBot6tyaOMaoMCgrk0Ox87bNIgvAuKKHapQ34TIQIFbJMwp0/wU8/NF1cIVP31ZtwLh7kqr4WdGPI3Czud6CueCGEcEshNBBavAboUn0GbOS3yxJH2hadRyesusXdwYQoV7DYp9l+NdrS3iWtDyJZxkEfbRaPSSfFaeN6PkIkNflD8zDqXcJZ3hsl6NzmC1gULHGbmSHKRIwv0LK7Q9ow+2G0uDwKZXyxVMX0Erm2kOQjSEhEOROkPucZT+gHuEmd8g01l5g8fSUEyKpE+Kw/RuYnPrYcpfJrNhY2RTbFl8jsshdbM2jArSMJnn9RN0Y/3zk4tXb56fXDzbF87Ot8hgKfSzJ6hdCvBiK14O/viVqptNRVj2oJQPDUnPRUGF4rrets7ojvDlsaKBxcvWfLRnIz7b9m7BHldZPiSWM1NDCNQXvZ0tlb8FZuYR/GC2VEXolTZUKiKEFZR+NP0mfVjKjKQmE0hzqZmM9jiCPvE/kUaZNSgNreKMK6rlWbpVAXPzZ9WAjFItj6mu5htROmo8I9JK+FqTWwuvNUIz4UgzEz7VFm2qRNAn8Ge4N6qcVNn5a+5RlOcxh1Kjij1FiUoTTxWYdNReUxqmsLOc2PokZAyDfkZS7Axzw4D6Db1tAJI7mmJAgkpHXTB0HXcWljqFK5drMlNSFNGYuOlqZEp6JdlllJxmQMdT2D2znmqJb8OyO4NSb30j+R1PfregW1d6k4m5n4NhkzFfWLvnw7z/JJmyVH19hMQ+ZGoZi6s4HT1JCLq1e3RZZMm8JGfckKPcS8EuMMY/+Ky+CHvUQ9OAT/oBA0rDz1BT9hl9Mh2zR+MjdrOp9AYb8b17aVcYiMKwyWjRBI2YoGcS6FtGrUZoRW9TF1lPkywqW2mXneNgOp0G6HxLAF9kMxcsJHNQ9tC9ZbSc84nV/PrVSI9455seItS+FUbt9VGK2dt7OpioPHDSL8xIa7iYUfYyBkxbka2R5P78tKf5Pz0/lmEAMPiBNWRE0yyWc4AD2UG1jQEL+gAaXI58Qu/0pW5Gyezq/GgJ6/hJSN6nH7pv/Qn78W6QHgi/Zp0AxirpYEY7oDDy9zsWnmQeRsxLAU4V9Bo03wibKWzzuZu3cTgHVRl1hi0WqKS7+T+tVrft/Y+35b2HepgfW3St5fkjQUcseQG9uzjYG1y0296IUVMb+PH7iw8eQ+GKTcBZyKKq8KEcve998Efv+/hnB/8E+Gcb/+x+YM83PH/I6AZoa71gQQAY+hdhJUNgjAgfhy/n00vQTDXMLqBhz586c4IP3uAqrIn+cux3poiSO/vYn4KaINSAmBHkyvNnVtIMqrCSht6ilWyEva9fJ/DXk+nuhvDkDnky89N2e+GaDDURb8TAZWEs2WeQHcIwZp2O56rIkdbV4ynF7zPli9IBTGewIYvtBcIU1Kbty8yjaSYqPPqP0JsN+EU0Gj0yV3XpugNlzGnckhEHvMFSZYBLCuHyiNsF/HLxCK9qv+bfSjIxCJpJRp2O70itvQZykWWNaZTeNLS6G0PQOAu5gTAqYnEddbx0rF5mr8kVaAuTfwZ6C666SII4KgaGXbFH5MVq8gvpmbv0DkTPa2H5uC2G9IkyQ8qyZZikRE3oDIWh4hwVukB0qAYA1KGZmSMMYCFuVGZJNCSt5v/8T9r0mVNw2ZXmP5rQGelukUeFQtKDlqlCPOrV/OPk0bt/NEGZhgl2Et20PD26kW+Cnr56efFMAJ/CejVZCv7uyaPXAvopTMd3oGstLfDs1U+ywLNsjjrnMmyev/zp4olEJ05hrVte4vzJ8auXJ6LEOYHd0qhSYtnIKP/w4VI4ttYvpqhsvsiAq6USIATHs7KrR9w1tVZLW5X+Cg2x1DVjX3ZlCFkxzHH37QEsBHH3Hfvn7aGtaXBFi6pTFLAOgu2VjrDz+zH3ouyOiVJl8lWQwO3LAqysWYsVwGU1dguqIPFuPk/hj+uRQQ2xqoWd/u7rCLk4QQlSci9s7G63lCti9vb0mG51yErnUHX4oMJDDsJdGF74q+qmpSwxO2AOYUfZcI66ZHdIzeRcs2w1hzR6AyweeZd64A+Jn3fZbjyMaVnm0P2/UOdGM9LDHvXgS3K6t0qHpJtm2EyZ33zhAU3Q2tcq6JMXkK2oO068LyNyOR+PQRFmbrqyMezpKSTeaiS4fOw3mu1Jl28JvQVTRSoNdVIRXk4fCE4qvO/b7I+gOxE7wHyNEUBQWaTeOqMu0uT5FOqH3kCyXLOZgfIiRr/kFzDvk7aIlmzm0RAK7TYlTBLWFd6qKylmMR0lFm+XteJelHUMoAqQNyXMqiFQiMo1v7eozfvyV8z0uCpxv3saIJ+1Fn857Pe2f+Kli7Dmu3gp4Hvyoas3YrU6sMnYsvQxdFHM13g5F+gJT4zRDc4xxm0Iu1x+6KPeORk6wGGPu5msm7oH/ToAMXcRgjukI39Av8pHacxsFE/RcvL8RAg9vuUbIusnJtDS8rLfzlyxk3Rmwwp4+EVOZC7P+BSmw486nx44EcTHnNnblrZJ93dksRJm4Xnewjq+Mdi2juwL+8hmeSkBxSxlOschv/HrDvQs8IypiFI7XnIrQvHihutQxvtek2L5gckaXTROMr5BBzEWe7leB8uVHSwdHUSEV/dLXQP4Rv2K0a3yev2KV/YrrvaLIlw99hAv0sx0Gi2MPxiys9RByRJLqF8vzPWFlSkFy9SmapmJFjupTlvSDt2XDyKCWSLBNxKtU9plS4ChQdJRpucwwvH5t0RmwR/2PUpHJ9nnNMmiEdM7tMM4ZhVuNln49+U64dZqjbCQ9pEiRC2tRVgCrEj8yXaov+RFMy4JmxzPbhMdbZtPHc9e/khhSLs5S8co5MPqY0gBUXwCCFRdzTZjo82jVrZC9c2t8rlZPlqhGe+3IvoY1M/CaDOBH+j+NWPPRVdWndES+6wGz8+ohh0pDbtev56s1q8nfCpl/kRMkIhZYAfWoWxlEPbnQgWfUFYpvMEltPL7wAEOI8LBX1fARyzy077bdsMZobE/T38HTRvWTqivyfTwcWiepi472hVzTj9YVeeqgJCnbQHoC+wGb1qpEeusymNGenyDyi1fRRrNiklWUrNcVz1RpXsTZmnWdyhzhgxA9LiOc+V9ScMrsQXx7Z2K2qbw2C8yX9AOnQFDQ/Qodc2u0IP9kcfxq2OjCCqchXNk/I8jLk+we+z8cXCF1y8elSDZL+claTUnQPCmP/N8O0OUbcISgZl4iNAdwV4kiW643d+XOFxmo5tuRINvHU/iZITm6itYU2I83LbAcjLNPhEBtpgv2eCw22FPoXihLVWUjuMMHx1BBvDdGGY3A4LNTALbG63EggX0girPYPNTng/RHwafBtXwXk4wHuzLXYUW58oJENY+ljZNhsHa134cu0jpqru6j5QXTeuMjdqRJhD2Kb9foCfbVmx1uchxb0iM9c9sw1TeMMvL06F+ucnWXMxc9xmxyn+Vnlwmx0lsIP8qpa9+7GTz3FhhfotjXX+peqaqXGnoMi9XrbyVtXSL5BBjrgxgBGIEb67j0o3ANDricfo5oRchxOSNRqMnn+DHi7goCYxdq0ntmziZm7CYH36pVNCKvYXnrFd5Tde0PnGPrEaprFUElmqVteu/g+e5HGcnqhg1D8+iP0OZE06DlRPCzW1uO4g5eCx0wWh0qtXgBu1aT+Ef6Q4UjEdJZjHmUIEP+Agvw2DwvMssykfN+nbka4FHqx9BOYrLtwOPah80OAtX/T30mKfnPvpZ3AvclMEXpzRQaxjsrbaWuaRQy0O7xopdlL9kTrCZ3axtQV/tKT7pkJzTaN0r5SfFbT2LlLmZWYavqmZIG2quQsNbjAg627nRzWNsTf/LVfvLK1xKW4ccYBP5ZTYihtJhwzkkkZKYmjBYtiTWrjhaxm2uEjn4w77cvIZQ1JSHFeYtZgK+cjpaEukCyB3bV2YsxCVeFu75I12SuTJmZZ1kc+BXHaAiAbWD9kdl7UG7QXN1yk4PWk6Na2Xcv5YZj9JViRmh0gGBMSv5zoFhWYRuKB9Wlk5/E3mJOlzoFF3rRf0gPQh6PRo4Cv5lu5WMcUiEuxJ69WcjGnh44eeURAVIcH5kWVC57hdU9vkp7OUztmgehu7F9OvXjC+QDgiWAfv9QsnSw90j7Uu/Sqslbz7EK7CwId6gAcUyfo2K74bZGQhHrK2Rol0hhQ/7Xo7GCsA5DB3fDxfmWsV3x+4VC9+Yw7636Nr+G/Sd8qP6p3FQlnSSTm15sXWehy2CccP6LJ1vjm2UxfqoUHa9adwfA76mAwwL20op9rofCsadSaemsEB1HLYASqFadp/GSYIHYhGGsH777tkbwJd7lvDn/pi++fcrQ3KI9yjoYYBdFjaGshzfi+OMPi5bNJivZ1FF6jOKLKaPqP1R144iPOpqXxZ1VGE2hHbpvlG6b5HHhg4M6EAbX+ZY9h+teXsJ47Lwd+PVIGK+BL6cEYE3YARms5+eWZoSgM/JSzpUV/7IWyzoNtO+tmzEi2Lyhgsa/IiAhBETi5U7TFwwRsJwbQO8j6RcpKED0cckHnRvZErsrlk/Hl4b1dEv8e485IZRvNYYfQDBEYOUTaSUTSpSdsKl7ERJ2XnIFGPHvZrB3LhXc4j3o1rzcO66gjMPubJgXtuZ83uL44rYnvtMW8V5NArHUjJK9NsV9P0rgJOScRngTImZ5LaScQYEsSWbv6HTHa8fv5jSjINRO6DLlkgIMcFbV5LOYMRGnXXaey3b67P2Xsv2+j3baDlDcTYyJe+wQpI1Je8Q6GEKzyp2Fxy7K4EdTwivNOxWSephmHeuOqsbe2w39tjRmCDFMGxBrYoUZmWtWZtOna7lJwEfs2xSGvpDJ8Q7BoFV+zO8PdcClgNg+nOIP2eHUJyms2oOAZbmYRm8slZdYRK5wsz8oT/yoe5k3RUmoSuMKDdg93mdK0yy7gpzUVlhLm6xwlxUVpiLJSvMRWWFuahZYY75CjNrLxEAW30Yt+X5Y7m2jJetLVJMJfqycuxfwLKyQDuscnGq7CjmXSwtAw+ZF4OnXbELOMGLPrjsPO3Sa9MXeA+PHT8W4ftmr+mr/7r8r/hH/ttrfhi4n7fQil22Jyv9bdixUt5hyjfwW6Udt6x8bHX28kfxggl+olumuJxGs0YLvjz63On8ZwkBPwHiZ4KNN1rw5dGHTFp7d3ZIJeoAoULK1d6oMvQq+xiNSNIrlUpCX03yN3qgushg3hMFiV/0TVlCjA7Qxu/sfOpY+FulnLTSA9V/ETITLqTwNyCE/zQy+gggShrU6oDepujbNwHKHsLxB3EWDNuh64Ds3ZuAppPPb/yOzbCAqo2omMFwqir4vl2vgz9ZE5WweVtTi00F6gDr6devrafqXdt/lSud634cGoZ5/YOZZqV3VIaudGQxi+XvGE+zjXOGqCjPTFeJmFRxpYGJTy3PqWizpAcbRMYlpe465Q3BZ7FZoJhmGfxKx6cYmvMGRBwTuqI++XqZxy//OKxcERQAVFN8DBIf/TmHzTKbNQ1aEJMWsUYLGrHXcR5n+dbolhmm//T6RatJybZFj9N5bORoBhK8+hCP3jUnqX0dj1NZJLJnTaIn0qs2aKbyt7hx2tWcaQ9ECS3NhGDRfKsV80umcrTLBSLKfJY4UKUZLLkRAzviZbbsqnFWeqLqK1AZRPumT++BDCisFy2IeHMnamBHpbjWRvmPeTSK8cSUxfPUR84bELSUUgv0OYwygPAWA9kkCmQDJhAwfQ2miroklzhY52fqcfopSuJRYwt7MJ/hSRJMcbre8uP1gT1TGEFxgtBlOAzNWXPv3kbZnUQFv0st7hIiNjinSommPdtglUY1AMn09p1+C4VGbNb8s4t7KRoLhfrHIaprLS3hXuCFYXDU3d3vDQxLEvHaqR/rKTGm5HpKjimFYX+ClIVwKcBmgKT4JQHZfRZpttBxF03AF1mLXvDV+RXSsH++yeotRQbDK//t2uq+BUZ5V2kvhvRYT5dtgoaCa6b2YrZbRJ9Ia3lz6GUBKH0NTHgD/32G/yYqF4WmBNYkaLu9oPeaaIPawx4NxHRPIC6AoCd5vI1NPRKwyw6SQRGZAlYS4mqx01mYG2GLspSbibiKjk2+IjBgJb5VzSnxCnY9mt1ikm9d8oE89sthtuVFiePGFszNoNtvt4pO4G2yKljygDFvz88ss0dBbQ+ZlBpThjCq+C2OA2yJ8G67dA+SCmONtEuLo0tgYrPH508rEeBpQy6yLIxdknZ5QBOkS9niipcHPrwGPryB/z7DfxMTomU1RLdUtoeS2zfJi9tNGbs38+rliqlVlT3x3WSPMWt0MdS99tqxb6TcVFI+e+b3xPPMNTB3UXzglC61NP9Xy1pb0t5GzubO4Tf6zdjcXF70Fqi24puMF6sEXUykYc38wYt5YarPeHOep7o8keZMzqh0tqdytrOuFO0wM9B/atpRYdD+qwSFD/e1CowNXSS8LDPXcAFnCG2ljfy8swsV5e1dSTcz2y8AAP62d8Wjl5quB2THG6SaDQE4Ie+IE5jDw2DfyOzjO32ZjVsQ0x4BpYuOPJeh1un9CgxWokFpHXAMtkbFs6cVJnCSGFbMvPvOLKtE6TLSFytJX2D1SFtoAH616a/qEBQCCwpKf+FQ3J5x/QqrlaJCvXtUjppCobaTk/pOKmk7wU3+d59nfgSL8I060zEYhRvcevuaAS3Yj9ohrK2TTiq4R5gsGUAfAfR8zSSWQMb1oOiyje7TJBoX9/riUY680Q61XwN5b5joPnu+1ff8qIN4tmGp9hP8ea1etuP2ZWJKiAlIiC/szEDIhckHf+yiypxRZRQmiggrCDCiBPjc4Ya5Sv9H2H+ZLQ7qbC6a+yM/go6hnKpQhN9oRdcakireQv3mqhhTvSiZijhFbuBLwTAr4GtQo5VK3wk4S/wOSkT6SsFu8EtFS6TKx5MElMSC3FntILw8aedbfT9uo5ETf+G/NNzrJh94pz6ypPU11rs7tC0XQ+z7WZbcjNE8aulCsuMbLSK9hfU9TVFfqiBZWxFdBXjf+9B967W7u76d+g5T1TyIw2AQSych6rWK2skYFcTOamNRLVWTbLwYMj5v/RYts+Z8Xv9CbXaygjiUUnzYh2NdR20+0Dqtg7Vp/Q2U0fphil2jFCtS5UCqXJEqXzFIuavSnFf6LxsiOSPkrrtYd4iWzU1EBEOzNXMWHk1PpwHP7Ixv2+WBo3viuvs3sLBSw+CFbf50RTkyAOiN9moxI/6RaVBlHrrOdVuq3YphaKUtmOAqlp5hkWWXtIwXT2pER1pWDAt4DAt4DMt13J349gZrMcym9AkENLRYDByKEp78oN37tR324b9KtwlchhagnwNlzRgaV+sx5ZzQs6ICTz8wcrW0TYuVrw5gzO2Q4rb+6xIPep6ftNvi2uDPP47IFdNhP8UqES9AQrlqBkJ3H9HHGNR49cMBIojzohGPwiZ6PkODz8cf2qIt3eftD83DA9zANa7DZq/ZuKF/2YFF2PyhTUxYfgiBObGZs3V4sCXaPfxBOpskxTCakbfTBIdJ8I+8UrH1/v9tbPznP/5PqzMIjzp/ftga+yQ8bN77zyY0PJxEOdorH5WtntduDphdvN6o3hzB1z4zoxefxu3raTK4BG1qb8dvti/LLGqJS5EfIfuYkxNf5LnNnxXKm0TG+d+4DlxEatwEDQeJGo3rPk3PK/AsvbDS6SOcRthoMmmy/0NbWMJpB0YEqMKyOtksGsblzX5TgkTJbBJxIB4us0OHlcLIpckexR9qzKAmjZiZ0xdmzYoVUzMzrs2ow3ombX4UHpvlbKzjYaTRtUXHG5Z8Y5NdcnnZ/VzL52V3spTT/RV8Mqb37juzCJua50nrP/9CR72malFCSNHhEEyWybcWjmksy3rSPNgaHza9+qY6HW9BVdiLDKpgizlbQ5vNgeOcJw5/QD0N+bvK2DAEmCn4OtRAFGMD0A+1Z0FL2C4xToQo86FYXjkmhuzG1nH69/4PYNFukaMfbuAr6NHvffpBf8KoXfcNMPG1T3/yEl7718P/yf/jADZJswZ7D83AuBBoYkaHUmD/17Y8n9IFAeRXxECgketXYN1KE6z5ZY30VzbSdzSyZRL58Fd8AUwHnM+Cu1DcA0K51tF2e2Ads70mV4RepudHGHPnKRs6Vxbuk2qN7/VTW8kcUpE5jZsGy3BLHZ5pix0ud3iuJXiAfyhCxiTbgLXxBzp8YdOQ8j0mzFdb+u1+sxtHAsZpwP+b0aXB2Io+Uv1XLprL6WzT0UXnOsNEPa25MaLRGFKCM6OEZxNoyKjeosaKSm5+zXJdJXNe0lXub0D2ZbakvyXRnHM4WD6H605QxBER81tKLzErV529QYYGTbZxzXDjGqbvsw+r1BXcC7K5m7u0qFYB8w8vPz1Pqf+5wu4flu/AKjzJ8pA94m/SaJGdq2gaJzdsAqfR1NaZKQx9cUIh9CYMyJmo77PU0Fqke5klo6Mm/m3uA0Pm0yhpatUy0lLIuIySeHjUZP9a0NXBieng/OoeHFzofsUVTN/ltH+lyx/SARe9oh2avdkMuvd3/55nGi4+q55SPHWw4JKTAmyAUQAP5ndvdUyQtUN5BGBbyPU87Xggcs+HBOZDchCJ+ZAI4/4kjN4nH8SFfrMLE9aFMXTh7dqG/TGgNWdWextjLcsw6K8xF8euuZj9e+rpU29iT73MPfXueOCWrHPgRm/VrjMnbtoV1ILbTo3lJ2hZ7Qna95ki17eZIvTsa15z9jVmZ19/+6nSqg6h93/lhKmcGa40eUgzaNgshRfyFqqE+i6v0TQtZ02vkeNTKtJqtlvBg95mvCUO0mqNIHX2VmH3qJ5E1pW4rQWkrh40g7jOnbRTjL5XT0IgH5qKGo1R2DyFQWYHExW60XMK3ZNx/ZFFGHi1jTUbL2htsbON2G5j+bg3/mxWtwThP3lD4DhO+pdRvv1PIvx3JTsSGyTGPj03M1J/AxnBk283RK5D8P/rBwlnR93m79e6zR8Kbc7TlSMz65KuhGlg2ENp7fIbGKSkEaWNrJyQvPE5uuk2vQW9zVG6qqER3BqYjz5jgLGsCrG0dvS2QmJudDrADu1mp3PIz2+Msxfu7qHV7+7ubLa0Y9AteerpofCnL2Ba2xiXxoDlWwM3MA+hUm/yHnh/1eKtN1G/sNyqnfp1hZsqfz04up4mDYxggU+AwkYz6PZw2kfpKEpABGBSmjUbR9QQu3Hy6vji3dmTBhC+cfbT4xfPjxvNztbWm+3jra2Ti5MGYNUA1WVr68lLYOxJWc72t7Y+f/7c/bzdzfLx1o/8IcoWAG4hIBTCA7Yg6I7KUZOZlKFubr9rNH+FAf9hOG1Kox0a+AlL+hSTz4+za0zrNXpiQrAxt6eYPsR63q/NBhAgLbCSKrr9Xq+H6DVNCgXNBsUUTwOYLmQeEIiBaf96sCVgHGc38jT1V6fl+levaVUuB1xvYMxM5IDl4X/8ulgMRFWggdMAZLF1YP2GfGGBp6veWjCNR5+YUMcxyod+xN+kPcrz6AZjBtBrMcynES/BYghoNl0s9L78EBLuRpe1qFco3dWIEMqaO0MKTa8OfHZ5lqGJ9KoAy5ZxXuuihrDwbdN5QeO4RjyAOkgmGuZPPkHgXsN8C801os9n85Lkr6NRPK+8s9KyKMo6qKSxlqheB/R8GbyQhgn0vFtiVvEgKC8miB7bNTEKBOKSgY7WwweLhf+WWBz19Mv/oojDLrfxNOJ01R82S+Yu4QVH8rpSQkYJ8+N3oEUWblVyVdxh20/wPz94cULwIfJtIxd/e4odajxQT7Ho2kUx9h4d1jubbjLDCuCk0rnNRU+mb/B8PeVCvHT3fKt8l+7t8UJYUMlC56WYUSmk4XzsComuZdFR10GlZNASpWTSuiWnrkmoaPj7mGrUtGBQadnKZ83bhRQOVo5CZGw/vl2GRn8FGn0XGv1aNPpro2EOrnsYZLY2FKqImIx1C4z0kbB6kbGqXn9QaTXsbjbJncG4RaYKyi3BzeDcIlmFJjfDx8P8q2vIzBUiXi8gmzLTnW2VdYNSGsNRrj0QF+sPhKxUrbhyvS39Bz3PD7y6YbhbLHSjnqFzZg7VfBxas3BozL1qXX1nXX1VV9+qq++sCy9EzJmvX5fQsrJZ6FariHqDamaoN/My/aye3xVQ7dR1gFgIXXwPznFUf9eucR+NNb3CXKtDQjdfrvD+KOGph4nbdAkbWMEY9QhbyLo4wVn3PI3LpxFVVO1YxzKH1q0BiuB2tURgcJoO9CfJMxUHXVVVi5ILGYmG6hx+1XcrS531YDoFKuaXK+ZcFYIi4SioLktX8iSHGllLmNSAq52Cbqgqft9lIrpb+Gs9dc3ICkC1f+vNy/O1JmOl4hXz8ZXapi2XJxagNVvtahyT1wJZvVetpzO9cLeC0+f8zYGj4CouolC3JDW7S++iNd5CnxfuyamyGK4aqJqOKnFJ/atFBQWjxj4nFpijIcEuX5s4YJobhUn2+SXdiVXqljmsbgWo6pZpzrrZDs9JPi2L1q6Dyuq1RDm5WdpSxZ+BwD74fEZonCNHyyJXa1wWWD2dEWw1k5nVLqHQC7qnDtyY8kwNUQFu0Yknr2ynv6ydfqWdvrud/pJ2nH6htSytjTff1JKn1bmUIdMym+dL+VJBGOypFaxwqcqzmJVnLVmJDLjaNdcNVcXvu6y57hZu3VMldV1Sz8yV8om56XPJJ5Yj5RMHNOQTS6uww2ojKdoOhUUUrWJ0gaOBdckYj6+gVjYVwgdL9vKGJedj93ESDX+vtV9UTS4faeDfR/n4stXf3fX7Oz3xn+fXmEfsIjQUAv3Pc5u9wl3fZSTQndSbW3otR+2m+z29Fkk53conX8CJvv2IQUV8Y2/Krkct31RVNpgmXV26Yd93bniCXiVdpWk7hUBLwsBqKxVNlyZuYlmjxAZ+nTK4669Syx4+8GvVG1FaV0lwAKIbv6InqA6q9X2jt3QBNtZqfQytRXDXdy1ZD3u+a4UxgZlY310tcFwS+WP3JMp/t9GqiLPArwgO2XH70MQUVtTU/EKLOaA04zVCL9SGWvC2gl1fc7shFcPv1h7MY709paL+k3ooOsjulPCBq/DpEojaaEmucHLs+CJ8/2HhCuSpnvNTMO4W0RGP1DwcKa3DkdJ1OGKzk74a0JWPlrUXPZq4eDQa/ZLR3YCKd/E0ro13wZBTcS54nDrDgwdWkZFBLn1z9/xc+s3G3xfa78fyd9k9tz1mPoNx/e95hJFcfObq2HwcPi270hWCFghc+l72U8sXs+58KKh4G+JTtsZtvTsAC70FsxH4GMxlHQzxyi2nS7tFOvKjI0kE84b6sbkQUHFHfnQkwRAqCeW0qa+qtrjXoT2yVnB/EvY3k83tbrCDoQDm4c6m9CKytTuQXEx5jvv2xH59osUEoFO5wfp+CVVtnwbO6wGf9OsBlGa/wewQM+UP+P3HwafBH+JS8McSqvzDWen739rtD8yRbdnK2hw99CbzsUQnPDwBnc1AgrdYmNPHOgkUkwqrIy23klWjSHmVk73vdsworsOFINRecFcT3deIin72z8XL4TZ6NTcuwel91Qp4Tj3K7ISlwOgdsfSXeu1KUqqiEJltVfUlvbmqxrRUU5LBElq2trYRBkfNa3HUrdKtC0L7zaanwfgjO+zC+dOWfhvcWoDRaxo6XhNRPLLOSLzbwDkTtZOtPiRpTtD8kXCjzj6EJ3UMCkvnqO1PfWw3aX7KsB2pV9HhNkCJ8764umRDVpZV3jFK3fOaznWSre26zmk9c/iIX918ZZln3TxHd92IE/rtv/CP/an/2n/u/x6u0Iox+IAUROcgiM5dS/a5HriJrdrnH7o8RJqtB2BWVZRKo6jcM1kKEu4ifasavCTigYC9W+Ho2qOc88vhJ4bFb6EFol3lQUL4f4QtLnQ7c1hO2vPN1qeOuq+ypRrTUn0Q15Viv6wu9iYEEd35w9tMateWwZsD9L72Jux7du/0W2n9zTftvrqF+xiG8fFB+GbwWCwoSRn+0eatPd56M3DXxe6rPfbF6gKLyW9qfUn4+vKbWmEgyWNcB/u+3zpWrWxG6Pz1GHE6ROw6ndsjhr0MOgZ6cVnFT6QpBMUiaHCnDKzgWCskIP7Qlw2jBm+B/ZpVZtim4tItO89DWSCzWbSPTqUGbzBTd6gG3qxdgUC2HoZB28lZlVZVo9WtL40CUpO3OTyYsHE6r2CwVVdowKhyrpPhnEb2rvT7vNrR80F9t7AWyUuf8DrnwXDwSfD4L+Gs/WnzfPDLgX6jrnVxp7l5rLz0XXj+VHnwg6/X4e+braTjVF7QE+LzEE97OjWGCm+ztbS4RwVRabiEcaoHftZ5vXkMLP96cwq/n9PfzzenyPDIHTB0plwfUjHOxfGsfb7pYqpPGvW8Lxd3koffjHjfiHLrkc2p4XzSNJwu/DtteU77BmgF20Ir+CXs7nAR9EdetvjKvyk0ALH+b46kc9ffpB7Ret75xds8tvUJljy1dApRNU4uTbGgClNFs/hU1dWsLrgSuXbxGw0GIpd5i/ZKhFT0cOOtlqnWVzXxO2xSe37uVaxxmkKi2VdFfARqgGXT4I/QVoI3XWa5Tbc4wpWNDnN0WbS0ujuVpr2DP47qbnXSIvs1d2hpZrVoO/yjWqIT/rHQRbWWtWV30/8U2n3CLm12e7tSAYSEzicQoOeh9u355+quatvIxm/Pd0iM878qMZJNh1WUTvbnzrw+HRo2Fc38N2xSQcnftN35jrE7B9757X1P7bGVuICJ+j7QNt+/gASJOr9sHmNGX8ugQqX9nJXY1qqiJdq0RNVcbO4GDUMylD8rWxVTsgz+ZU4xraj/m7fUpAui4kuNxdiFjm5Q1jenVZPy0la9Giu1ulDcr4Pg94pr85fYCgZsyqtx3zXG/Q8cdBx5/w8cZRxq+NXHX338tY2/tvHXDodTS01RQyX/DxCburGxLoau3wMwbmQ7y4ryLM+GAEal9ZfloswOUL2gr1yelM43Cf++A62jESWw/UujklHVRsLMpShYBSQCZrrzcP2fdVF5wqNT4lbyFXohs9uqAND2qsVkm5Wsle0ua7LSmrshZxuwXX91RU/oT6tva4xM8ahIA2en/Rsv59NLknfj4mX0soXRma0Uuy5Qg+uemMDME693zAJ/7b2OUVfNOxSja6toVb0cYGTatJLPbG5NK1jKl9DqIHQVWIdW2jOdGkLVPtgx+rWCUM4rL1a2RSzrsouVUS8IvsFV+SvHDRFMW+PuxnpXK4zLGCuuUew8YP8TK7slELWGam9RVMXMriMnfFJ2n2nf3ZMnx89PH73wXfOCcyvwqu/ihiXZ1ZN6897G1YoTX75928XQUXzH5hkHx1f6Ce0LhNBue6x5Rus+lKU1YPVG6FDaHnXaQW8W6agYR6t/78PPQWEcdhbuw87vdNrlCLNrHi1heAIVD+2uR66SnIchDUqsTjrDoOcpCsvsx3r2WlRNQ9JpqTNbdbbqZ2HcUS221dkqbovSQwxQncFfHoVn4JzslOpHrSh0TXiWqTa3mkeBfQe8mlwM3PPXWYIU/IED4EhNCIk5F9cuKbC/joKgWjx0ANy2xVpwOm33W5oIcQD4gvLmuLD9T+IwckW+bFAc202ERypD+AonVK7qhbSZh3UimkZ8t/NohGeM+V5fKlKh47tN76C3tB7uFMvOplGoJ9zMpt1WSJl5oLL2oAWB2qy1OwsZRlcX7sDQ/pboB5aJcWDpV+xvOpHV+DLz2gRNh5qXLhv74ycvL568duLfSaSfL8Tib4EuH7l9dgDdbPqjMOpiRMznYhz9JhUoIzqYlVwYZc8fHYY9bwxZxfyyYIpdzx/hoSkNqoGm7VHYG4ykTzWoKXo/+nCIPvaBaeDnQdh82Pz6FX+GYbOjfv6gfjYAE2/Ubg8qTbGDrSvXsXdlvgycQ3PFCN5ZxmTe32bUWKz1ZTz2t+uIaVv5S+bjJYaZxa2il/PodUznxg8WvVwn9crw5SitRHRy/A3z5QW5KmngciYLRC77wtDgBCOCUgg+/QQI/wSYEzKMqYc7AKKjLUDoBwC8piGxMd61jm5IFl7rSfn1K/xR8a6vS3rl+7wm7DXXQ2HLFYbhpyweNXpHvX0+Gjch0VMJKLKZ/noH0TrntkV+rH8DVPRfkpUxtq+lDeq6L2JI3+Bd9Vj8BsU/dzX4kquE14Eor0qrX4jGNHagIYJczYdouAs3AqnKz5MyBC7y83xJsZLMxObiiuo+tMjPlhHvBFbbLxdio1uKkMwgYmUcgHs/d09AFJKQtMXNUizFLvUAs0P+Kc//uTuFWTUp3gvAU/xseR8U6Lt3YhMgYJ7CKv8Oth0t3W3gAKvLufzEuK5UInf6tNGFDCJAK7xVlbQ8L3r8muONjjUpdhO8lPJzd16Q/s4zRjZRNywCsv/Psnle1OOLKRrKtOYpcDvCNJ81eRQnE2Ve5QDI/ui06eeHQQDIwdfZKVAOPmkUyDDvBFAhaL1UUw/xg7WsUBG9m7owB211XhIH7s39Zh3+osLCVeE5AeYb3a3CaRGoKg0kkyQuaivu1lS87WmpgWdwybTofb+2+pW2vmNj255co5Bh793bMPmVszQsNAQWGpi7YYB/T8I+/HMa7gxwyoQP4J9JGOzBP9NwG7OKcA/zYEyAqx4MGMnC/u7egPco3A0Q7vg1iOk+gsbFa5JE+HYJNo47DwZsLoY7vYdYZkTXAiYpoKcvsmGUkIt4StTpd/bTDNa04wjDbQ3MXoRQgdLSYUZQNd1IPKOJAyFzwvfN36IU1pwrcgl/QWuAv9Esp79v4O9v85T+TTB9Poa/BZnB32xYwt80+wR/R2TY/EBXo7dctPLASD9dHL/MPpvy/WcRNeki+ymNr7FvRtgkGHCa5m0FZFvAopFLh2byllYnLpETvKXE8jehJA4kL1zmN2dRXnASXmSPLgskcLWuaTwg2soxYK4UxYCA/IhNMekXLIXLaz9ln2z0YA/fgy0g6Fj8ijGGp2dXFwalGo8GiHjqPC9UEaMw0acqMXNNDIvYHP+MpU9jmgkTZyxjxsmo4URezWF6+Vjq5aOD/mDEbhCOQetWOHQQBUaIq5Bm8VYgY3DFy2NsvzScISGfp2Xr6n3vg7evMvtHLSM3+IDkMcE7AWyaDai+DRUgFFDaLAgb4XCjJ8WFif1+Hfb7FvbZUuztXBg7Ey/AfSUMDDZNeJpkEe8fbqo3elz6bMxB8ky+fmU2jNwTvwr5K5W/Mvkrkr8S+NWKaRRbwYVM0fVpIlsOMz/yE9TuYRpstpL/E3hUuSdCCYrNOeZrPN9bMm1gzaKCaBal9rQBtac3oPxtCCe+VquhOmFcm+N4wb+xTqzS2PbhmTrrcuwpzoYyohftsB1vPtjbAd03p3EpmdAPPCUOZKd8QpHT1gjYv+JyaiD3jGoM3wKzeHN779vhdfoN8dq7M1Yc0MDsHDE7YDqVqBMjIK2FI2p2CrM6JiwU0yl9WwXdQlOt0Lg5IiC0/DLs4BOiw5AyiAzgsEU/8fYiqIRt86gKo2V2GPwmhpKHKYu0E1WI7uON9aN8v9kbsUYPQxxq1QJ+4dTD4NGaohLfu5cpSQR4ZlQdzFApzdtZuzmhzWNps3VM+fq1PCBVDCYCgz2t/b07tT6lre9Zbe/VtTxtAodokVZhwQUayNs+hVySD7vBUUHFAjMu97x9SOuZiQFLtFL73j77lJflYjy7RMt3q6DoFwz9ot0sQPMXDCOUK2a5Ng9QgLcpg6f4J0PmifBPgmt9eRB2A1o38h98BZSb8IPR+OtXShKPkk8ks+Hh44RZkcyifEPzGAdBZkIz40PZUkC/eEvsYw87mIovrJY1yL5pVayZQGgHPUHuyddQVy/9HABpGu4Y/EJ9gZ7tp+ITyJjJLFjRxG+YyYn4fQILsCDwY1LQxePKQWBcDfLcJHJPEdnXVRmguWATJP1RzjbfwB37kKC+6Wdffvbxc1d+7lLgnvhmwPKTAm/Lz2383JGfO/i5Jz9ZVapw0GOlVXGa8FAl7NGE4IFKgd+00J5eiibd7+vlWMEdsi2SHrKkfrBnVEYTd7a1stu8MOUEkYiV0+KbRnJ/U2TsmBk7MuO+mUE/GG52VTKr/8CuTGbt7plZ91VWEFjIBVq5ft9qbjtQmTs7VoN7GjIPHlpNPtzmmZJeu1xNiMPwbRc5V4bN6z56fP7qxU8XT1B3FcIBZzByaw+4tTxkRefyF6jgh0CAPaF60Eb4hGazViSpKS5S9tRUFkl8fkdGopjkiQnKSYJz0qpjV+bMeY6wXdFpLj7V5C8qqQGTAnpiwYSBrMwowISDM2+iENigBhfQd+eeVfnxaxApVhpImbmVdOr5Yyvp3Tutg/RbR4Rbtrx9mfK261gSGO2gom9jVTa4aqVZWXCdMPuKb9jzwdY0S+YlYbZhfstAmof5N1qIeZeY9/q8gM1eVEbUZGzgQm3Gb0HVeqssxv+93FR8qhyK4OUM8VNdb8JUslj4V6W52WedlLEO+DEtlpT6aDkQMeVP8eIx5g0008B/lwy+E2+2CCinW32fQrbltwy5fEKuItAc+f0/EVL9ZoZxUUkYNkEtIVdxSkZN2TbLLI3MI96sdgVF/fT2BVJ+yZ4+uqrwzA4QvN6D+tNBWX+nCr0fx+mnKIlHDVCWoykpSV7QG1WGUnpoBo/xbGIh+3GCxMUJQ0gZUzb0IRBwx9n0koc9rh0m0RVMBD7Eo/WBBCUuUFqeDZanmU3sSqSRB9IOYvyL1lrGXLRaVkU1i7pcxo/DGD9YFl4k00pVs7BUbHX8TVxO2BAzEojIqBoZjrShhDWGJqo0Vi+orPTHkUEAolhGIwjMlZKYc4VefD7OZjd6YC5ht4H5N0gPikGKtpr3sFH5EJbvCfzT5ccl5tUy9cwCZUD4nkc/lOHc9ZDBtF1PAWue8+X+rQQJpaHHBQCC428Fphoppb9tV5ji89LdIBEvLX/Mo3SeRHlc3niqMbwGXuqtBHb4Wz6fxETSiMImFb3WCVMWY3Lk1AzJ/FDIJjjabScqWtQLDfagHKjeMGcVLNbAYuCsJQzINpW6b4S0HJPy8fwK5POMvqY0bw5+KpMzFu33IOwdYc37+pnYW3kG9lY+tH0n097hW7HFyXyKQbCxTc5bA6RMlpBuko1h0z6fTqP8ppGQTyThRvaCJFf02L/d9BsyjfZFvD1uNxsiRYKUWRkltBuwCWuwH9xoWWh+FRg/uyqlLP7FQK8hmoFGUjvUp1HHe5gQM0YsGvpTr6bV4sOsA1Ouyj54Ibv9BJtbdfrJ/tkvu9cByF2/2W61yBo1kEoNhB1PAj1GuEZHb8NmW98q11QJ7XbQQ4HZiXgNFOIKCnH3ui86ka9RQ16pIafns3foRL+zpIMe2nqXlF0sKufJ4liWw0vhpnGe0FDeap7QcHaI3++09HdauppqIoXWR11U8YS4eBEVpTxDhpnIJ88LnDsXeTwek1wAyzkkpBYmUFEnzr9V/bFZf28xY+9MuPyQLvEq1v0Bs7oqA95A9b3E8AZccorjekoIV8a7SokbjUSuDAfJdRJqsafIIMbH5TE+LhepOZopDkqMJ6VJ00EuXsICY4i89/mHQdG9PpB4ipujFGe8guBD9qHEVmUD5jRbdV3eW1Cottt2Cn88IIdHVHiVoHjfCDyNwQqDgIVBNXo7AvUkcRyRh3aHfdrPTiCp66d6xyHDzzB2F9rI+WFoZAD0PwzQuHfdibrXC0CmkwpSSPQ3s7/QAfYVjUYvyecn01l5w1my5WkPTzVWEFgyfe9N2bLWk8CaC9ZM2Lwu+WV4CcEWVXF7V03BuFudJIsFw5TOR3N9V/VxVntTdk8e/3jvnrHadDqdxqOTk+cvf2y8fPKm8eLJz08wGlrpDdTxxpuyVd6xF8Tuhdj/GEKwp81OtGfX5/YrAlTLpRdk0mX5oDJk2kyN4HfkXpcjnJdmzFSz3kitvRhD1UY64s0mH+T9HVceonxQUEPJUhhveRWHKbW+LK8CJ1XWDuu64bsp0Qn4pWJHkcO+CJpbB9FBk2c9ZYJOTR4KiOv+wMptBzqj1JStRwWrPJwAr+JdB+cU923OtJqs8KaZX+VOI9/JnxYE41CY1xk1HQk0z2O86k/djwhk6Z7JT/3MW9TCaHsr5+xvgOJzyBThRlUTpnuMgtbKdFuhmTYtduTbAIAek5ZQ1/ltOGhbIGjS+s4YEaxmPVTwEjrdnVAUzskfc4CJo0QLiAaTwo0ISMUGhfOVVLTR+blMOGVCka2ts80tniblJBS5eHXx6AWruAgd+whDYPKppy834bVINSR/RR8JxYNqphqZ+pCpBJmaj/jS6gp8QSJL0UMbr0m1TuewAYiRUSMo8rLxKc7LeQREgp+qvnVIZdABdirG4vLeXmQ/dN3jSxcmpjmy23O1w42I17IdbALKiI4xqKTcYcBbtkEAxAFXGlfYyDokdRy+tKUJwEFzJRmWaFrzXWqMU3J9u7H+1nSHVmpU2ZLqqt2bGlW2NFXZ0qnK3ooza8nOWBZP6llf/jrjLtWuvw3SlC1APFfYxFt8qzFcsDphN9ZyKQcgZaB6z9IQ6mSw2LsZ659b5/gwIGxRJGL5Zs4rbmEHqmzagFlkbdU9EF5z5ioyqqloPRp/R5ulPG0wTJYztR+vGC2PWsutluNbWC1FOzJ532jvJXE3Nl7fYilaCKBq8/njLeqU5Fhlvxx/E/vleKn98h+a/bIxL0h+AhVU4oHwdBaGSACpUEQ8JSyFUR4rO42umT5wRvJzkse6O+F/lN2P1Xx1OchZGtpzlwuZs/4ST8jwQKYS101kqAfiTjiVU2eJp/OOtm5YmBQFtAfXN4+u44JJQOnE2/QUnpAxSUeW+/DLim/z6FM8jgARqzR3D6lchI+4LwBp2Po4dHh+Lyvuxhkayu+64Wa+YqIrqKkMqc5w6UI/pSdLM4aGiMpND7AaEeyoCEjuBkZ5psRRUfHEAIVXIKr0I0DPt4emDoTFo+WsoGhvj7HKocysAZoBY1l1Rudqzv1eZrDCDiesqupZn/KVoDFE6VcaeW8Dfeg+mkNFk0x4JHDEIK26Ba44BB5q7oJK20PQrOryZ02PwDzSqGRhGzPF2yZ+Gs+vxHJTJxIviI/HumUeDZmzKeZvS7oAlrWzKM86dq4px5zl4ISreMhxPXCvOosaCjdRCoCFVNHmbCWQij6fLS9QxlRn9NE8QcgYIKxd9FdhfI/tgBbdS/qmO5AY6g0wYciESEUSsmTmMYODKJ8ZXPCYTGw4zxCiyK5XpNOKJZCsWUqwJVUPXV5EhtJ3yND0GDI0IuJ8S/nrwu3vEVn0Fr11dYLBueczRZ8DlOacWjZmdwxraFf1iBmEhBXIOkSizwOGpIVuIujNGmRZ2j6+fj5znMpa+jk9mmVPI+mFEbwpspZW77LQ1YEOudFuMYnSUUL4wZOmOav11ZANKrmyEKuNyZuy1bMy/Wv00WslGq5LZCqa6mrsSUh6/iUGylizHZcwTCDQE67da3ldUQWFOobYZXUCP4Y/MqhAdQg5fjav+C79DfZL18pDb3VEdBtLw24SyUVH8zCgr8zcBnp3EWq17dyqRB/P+PCK1S3LBbTcIb3JGB/AxjY+7G8S4IkaOq1FkKVA/m3w+6COVa0csZmtjpl7FyAxsgocusH1jdsxKKbpT7OWjB95OY+T0bmYGC3P0DFhkvwG0vjHJLuMkgu56VAcbsutan1frvEiyNev32Bu+9VJXDlQ0+kLInE0n850ZCRnm/LBFWpGIWZHm1EYlB+67LIKu9hjmH424f+owsyBG5jQBJT0UfiyZHZr5+Vl6B7ZzYc96RZ9cAupzB2oWezTETtrOz28RdW+c6VyFwF1bVCz3zws5YsQJ6Z+dhukOqmvmywyb2BeEVt76fOhIr/n36ppz1+//jC6Vd1h6rsHLF24THX6Qay/7Ax32RHuzdIT3LWvTLErUZW7NLRfA+77qHLJBnFzrEB6tufHBzU3dOgCQR/XLwPwrNPljB4l5zUYRdBn9nqsNtvzi4OlhYtlhReWekHvk4poHlpqdC3u5Gj6BAXOHcl4VWLxPC1IztRF+75OqOSPkRrcVSfiY3NXtYjyllyTOW+/Z6qFZOf3pTZBMEN+9xlPg8QpUKVak0cralAq1aBa/pV82LHQQV9aPMNZxt0SLTrIcMHPDkCZoawGEiXClAhSYso/KXtziY6Olgi2/IO0JjvTBb7VbIpL3b1aV/2mtbpSVTs027IVn+p93KLat0r7heiHncoXphqkijshxVenjWDZBU9RIJOqg2g0cw57Zly1ooN/UHKptyGP3uzFNTO2gfTZmjdI5bGRfabDwZb3cfENpvmtCxsTxrOnqT417yxHUipHvpFaXadV21qxur+POUpZ1W7vl0pyHBL1+6gT7GtZB3pWsN9bMF8NkTxYef9hYLFIlpetf1Di6G0r4lprqbqWSfAGJOl0PHUtsjew11YiVuwYB4WHPrQhKMrxB/V4YnEVp6PjJCtIob9/4Y34eCEVb1+v1I0bqLuvexlMs3hXrhyxGSbU4tU3kpRsrr0/hQUpaqxHdVUM8k58GAxYNZMwbueH8Jm8nyAjlEd5ONmPwwlK9yKMcf06YM+H8YU5XbHxVLQMwwTF2LWgC35R8tGMdmBmwTd/eMtsQPL1LTrZ8ifdG1bbTbvFC990WIK32So7vKUtkXktUvwJsx6IUebpBxKuPMKUffZNX2gb41jmN19qFUt5Bhuh28jI+zKCnSZeXl5ouwRHQdgnmJE1nPpup/TWvlPIxrum0sis1J+sAlzCWohUcpAtuRhIu5dAK0uhapuAwhPpFiFVJE6oa5iae+vf8ASr6/I67LtPHxeLGqGNwZuivPGZaIe7oziHys5oI1W7vMpbfJuTYPe9AOdJKUmtc0uMNUM78jKaEjOZ+UyKpjOVjON5BvjHBUYyogdv6jDTyAw/k+6JntA9e/3k+Pn581cvP7589eL56fMLeZbKHu8pJ9nUzMVDrvdFKrvSBBWdxOyaQbjbk06ShZNr5ckbA6FjUHT2n7c6RjvNqZ7YzqLRCHspg4V/Aqh4GCWnzDm0TJ9kefwnBj6u5Dh8lFvnBcwHt/rWeUTutRjPMn/IKmKC6b+bOe9+wK7LUO7iA24zF0+mvCVAJGsJJimdLZvnDQb/2K0YmbQtE1y2aHLhuu1KBnW1KzNluwrcaFex+TrtOmZAZYZXQapFlxZiZ3YGuDq4M2aZfN43nc1L8tGJ3YpeLS2r4k+Z7a4xvZ0IS5kh7/bVw/S6TX7CyQREVZKydH7CyYFWnfOdcMDVx3xSMK3DF7rQqgQN0fJY0BAdeBXCz6I0wcARCLwaaUN4rsXQtlytkNkGYPSuFBP9COspzyDXoHxF1rOlkgv6yg2CsQpoIUBURJ2xEcDCKY2XkEdbMSrNqizWtAaqmtdWnJrT4tXN1x52W9kaGt/l4NteJO/QIb6eVm7XsGTaAQGyCvEzBrcabbGGrzMdzOW9clnDyGV3NswCq5BmYKtxttSMtUSQpYFUxJCVz0SRXehbdaCiD63TBT45qxN8VRQMeU2IT3fPCgnyF2511YV5l9PA3+h59mWt2pA238RZirHyrnSWUlmZhTeUSga6TykaeFvQ14sF1QIBgAYWWM8B10PAXrcC6oTlwL0qtBtcwLsK1JSQRZxl6gqpUu5iteW0gjUl64vqZesKLyltFK8tv6wCswZahcV61DfOZ/L1K/xR3nFOy3/dVpheDbOuLFZuiMl8dkXMBl+pyMCKCTM1KtB1EBWB6J1xWCY3tRfGZBP1UlC/Q1msobSvveXXGg/qrAAMbxjQ07J7xn93H7+6uHh1KgJKwYKURJop4N+b7n/dplsMV2U14+lMjRJAsgk5yuu0wQe8EkSOJbPgcRxEBY3jTLLeUv9vXf7fuvy/dfl/6/L//9blxXL7l0LpXLw607P5J0BcZLOODqVBsFyRYUTREd+8AhFMZ0WsHcI1BgNISwLQx1lZZtOOXcIElnAahN47laJq5H1U5KSq6SmG+jnVQv3MyL9WNUV781t8dvRLlpLCZbZWudJurRUwDNcqndeec5eWLCCVXbuZS2u3CmDtzD10ySIwHu6yj92emBNmiZVy4BZq6qeYfJ5lecljdPK3uTk9xdPArI7LF3kWYlIPrKi6XKgEdtzXfl/+Jzo7nOdFlj821FczVmyP/c/T3yE+QwssLlEz0n2nJ3Qf/XTxysSivzYWlfbxhRJTt3sWviv0Xr1X1oOca0TXpajTjIuKnn7pqsRU90/i6Y/S3Q/Pc1RUVeT+F6vngsVqdNtAV26DinYb3FW9rbBr5emWDcCecVWKqSddlQlQrmaiZSgaE8T5XlRkqiejElyiZU6zW4xIv2ZE+vqI9Csj0v9rI7JkLOxRcNLfSfk7MIZLG9NrM3Unox3jIaZCynNInr+gnSnx4xQ7Lt3M4sNlHF99IFthYuOZrM37fqAjYJWlyCj8bTxUDh1sDVCOtSZ777AVMynlbP7C2FlaBb7hxtJaK+68UXYM52XNQF66h7BO23dy1KUxlN/DVHB5W2lpYetG5MJhMLj4fgaD6sDeqluA45m0SwkfKLgtaplaoIjZuhHG/B6xynotsvJK1oXIKipZj0UWhtVuVcW557sxUK8arPbVuwarCfEopoJWWNgZpk1YJj9jSiw9aX/++oVNMfU6nMMDzHW1FkiVjlNV6p9ZNr2udgqTb0IaAyYvj6MZ8BkxHMgq0Fd5DJ2JEqqG669BaiAiR3MCgmFe7U0dvBgU91jVlfqF9tlFCAfNeOfPkRBvlc8oBcMB0OkszlJBrMq7fhMcKJvNFGxdnQH3FcDS6yr9awaWgpgGFmtr1HcaXL6vFcTYKK0O/wAbKRn6AX7jueW8zKZ4y50aDZ6/fPbktTro5J8A9jydkDyG3sA2qjGN4pSSmloODBSo+WCGJ1sz7WTr3Xfx4PORuoSG/ZwWxFFzFQ0ZmyUNDcVMCPR2FA/Eod3P0tP5o1LTuKDlD4rPMV5jruZQih2XrWBv+8GOYAMdgDopUQGVBeuUMEA0lUetfwdCTySxkPWOqlQ1PT2ct1GWB4xfWjqoLc0igS8t3OcBuGuJRal+hte+sd7jKEkuYWNsj/pplP8Oq6MGQce/Wk4yQrUEN+OsbZe6hXXFHGOV7kBi2W3ha3mE1LNTnqugrBL8RoI/7GuMEjZZs02beULH0C85blRHjX7wsO8+bjyBll5L5y11B44RaEOfqV/xXesIctd9ArlbdwC5W79TpI2sss7UuaD6TuYQY7mX54Sm8kZh2IhJxQDgqDLHE0a6isKrkcyzjFVItzSC7VTiS4mIPejJ9k+SZ5h7WKkRGUcTo3XNHZUdVct+WXPIXv8qYKm2/hesShthKRfqFYam2yPHN4h1Z8bXxqHxdfXUuI7Inikk+Gu0pSTCsc7F0NYioo1XHTfs14UhYzc6jGZkoNWynrvkUy8XFhuhfBtWnXuSnQYiKid94I3Po45aS0RkhYU7Yeztt9YQqjKzHQoX72tOhFVcbNwteJVS7d2MPP22tOusn9uecQtBVCeeeQ+Z4OCvUg0ppJ63Eqs7Xboj9QbLxgqfPbLfYgsowXAg5TxTJCNL5JOq7Vbczml5UzfpboxJd1OddGrlpJrgNE6pwZ99RNfon8S7ywSExbVyHQrS2LTBTOV0CBfq2wuhWyJDV3oXRjRDosXADNyYwlCu0G9ugU4Ba3l5UUMg+fSz3ztSqfsagB6kN3jgtZtd/nzhO110uUXPvocx6y8pM7fG/btemim/waWZ9RfpO1NC6qg2DWQG7b0Ck+OntNvy9s3+DS/5fBvx8w1uBy293nMLVL7ZbZ8V13VuM+++6+0dJT2czOxqQxc4RjOakV8z5yvwf/Z1oW/okLSKxRL/ot/XQCe35X/pnhLb0otc9gX5x8CGJF99w0hDgxro3uH9nnfa/Z6f4/8Vr7DLuEyIejj9jff2QV+760CbqnrpLrnHWZateZosk/Xe39Zzm39150H403UriiaiV8xfqHsA7miE+ukTdmwTUYq9cvahKuHuQWAGfcMrXfTYdoKrXGXrr2XRunRQWZ2WeDsm0gvWq2DjPLbd7la8mT9Kkuyz8ICtNpoYYEOL6ssTo+tqIg0TXkmtmtlcTtLxQtePgKRqF1GuGPt28bZTT911QqDqPSJ7JtFhV64jbjOxuKtd5LOfYz61vNpJ983dhrtWFj6WdhNiiM1m5MDrTUnSuqioN8lLfwvH1cL1ZoXN1jGqGWUq80vPZDPMAFdzzGi5XGgVOgAECavzRM04w63vR2NiIzdQ2wdOoFPYq4soUSKYtHfvHv+J5ojyMCT1Ya4dTu4bwyhNM6pAj3MS0RC90HYDZiZCkxqX+FNND8RJTNag/rSqik659jmV18ur3ZKNYNLTLiPD8YQMfz/hXsdptxVYffeX91XWsEafl9xIONXGqTyQwStvSzJOs6gSCAGSGM2i61U0i9NlNDsIFVjdjf5rjWYJbmoZwTgrieJ1BIuu1/O+AQK/cnsZ0tidZcys9LN+W3gO8Prem72mI/XP6ehysw6af2sn8Utv7H07z/urnKjg2uu6iI7p8go6BTIun9Mle50xkEuOa9lShicFJptRekBZr8ysarr29pSRKVH4LjenTF3ljp2pVbhXBhJY+DOhkevqpRY+6lTFd6afKsRzdFlomfil8ug0lL+jvFQfmcyYybfCPUDkrX6BQljWbbRjaX43Hikoxog1+7yKM+QMMcS0E+biT+om+FnVtdVNp9hx6sIKyaAg8rqOXylCjBKlVaK8mWGArDgMm3MYZgzXM2oebQT78YL7P3Oet9DKKm2ZdXsLJdTVvRAFLe6DvO0WZEi9Hs2i9EIU0dvpeQO+zXpLNfCf0vgaC+hAsFkPyy5Q/ynw7zvqsc1YVDo01CHknwKTTiAlqOTTbNjWEKtog2c9y+Z5YeXtN6ln/jFdteclMfMHsTTUUyf8YbPXbMeIKmnHWHjAg0pjBecEOGCEtsNC1JgkcSFSxQYyD/N2sRWQbT9nj2OwMqgXi4W9I/zKNRT2RcLT+BrUwW1ofLG4yG9g11EQ7YaPPTpHb7slh2JVwcioYYKC+1WAR5cFko8NDV853LfRhuISmgai1g/Bm4vF4G3ZPbkYxcUsiW6u2HFK8+Rk6/R06927xmSyP53uF0X36qqJkBfnFuRo1DVg0CZT5PXCh+0ZT0BETKPknID8Q4tW2Ow2QVj8xoWFtC9dxV8cc5ZZqmjIBE5TIxDYJB5PErQf/ULyzPHi/bey+yz/Uz56R4sVD2CZpiRnFzR5XXhjUPymlytFG6xFfskxvWKRvItcfi/ppyY+z0Fsoi5ES89iR44tZs0sELqBOwfq7LKLhbErUBdNXCTZ8HeuCQvGmIqblmaFbFHQFOMaGBFXsXZd+//Ye9futJUmUfj7/AqHMycLWQIDNr4Aso9vSZyd2A4miR2PJyODAMUgEUn4koTz29+qvqlbagHOzn7mrFnvs54do75UV3dXV1dVV1dP/ZxGlzM7zDWpy9OesafLmdSYrhRPLOkK8fy/cDWfRWsj3qn7fu+CydrJW+tAOMxPAV+zZIFfYfiaLiUEsXXjW5bJ5mz147IX0ffjUNRDrV0XPbPMxAESwr1aqRiW4vdA8nlaaNDI9FgWbbtMfAjZT+JbDRthiDVLdrluhSb8C7XJy9WYVgxLnrFaruBtuJCmQhk51WVrwiO/YAkgdC7TePw3tkpYf2RDXfT2YAo4GQmDP/VAjtdHwaBaKUZG0y+R7/4oAGbjG7R5Vognwq6mjKNfqu7uVpo0HDcpOQkeitWKXMiwHDtaCxALp2XX9hgWdrBWl4uVSkYD8utSfi2dz3MsSYlE5ZBHifXWaInmSO7LiPVlZI92K3tKhlltKN+lajLEFNTqaDaT4o/TRGn/swLbLxOOctYvAoMzmsEubpPSIJWKPg/zHEADDYUQFUdMlS+6uJX+icMMieH/reOMBYcVUjPkuOIb2sK+SccVR5od7l8V32NMHPqirK2CJKO9nbr8KRb3q1ixuL8OnclQZ25nUBKDe7rSYj82WoyjzEz2nu/ha1noz5/dxEQWGR656MKIPlhqsR4ngeRDLHZI+FHKlFpVUs76fUBsTTwtKHZOqGsykUNUXWIGFbA5w0Ez5QFhxRNlSk6GVSDFZFdmgkjyEaDShST2xJvMSB8NIyU0fP2NMUnEia9iVL4uPSyJ55iXWBdLApxkFQR8S96zUPFmi2dk5Ny6I+Gan1LViS95lColpoFJ0M++UJ+RfgUTOIrLn8JYH82Jrc/kZEQm7fVKxdLRRsVSUAX4r87a7/c70rV21Zk3z0mTH84wz8kEMGiSxE2lIkng7C5URYpDBZvTg7ioAWicpdLKR2enZ503J6evsxxFMuiqQ4BUAQgHQte9LH/sHJ7iIYGx9Holu/F6JXkjOc/ZVckUTqtt2WlVN6LLMHY+rJlzVJZOWhOFRENiNiin5XORoWOWTqCIQgkZ8ymMZ7duFHMqlx6auCwfQAa21BeZOupJolDJU6sLRyXni7hUSiUlQJVCPajyKoRsV54lYPhWYDl8FeIHFTCkhbdQwMiNyrIoNorSjO0y8N7SqIYE1fTiEfh6DGCo4Bsmi4tg5hULIgGQOwpW/ADG2h8AgmH54rB99u4dL0i/oNRFNwxGI3yuLsbY/qTo4dlpp71/2OGF+TcW/z513R+uXD6Ltx2ChHWEEtaRJGHdpyUsJ/65BA/Fp49BeqOeJvdx+Y3wqJKvphwfWVJ5mAxR/hNzCdOWTtyzxOQpTQiWzfnlZeoOilztUypNVLrih5a3UTACjfEyc3WH51xlcq4uAKLLHlRnXoDSiGR9AaVM5hEoF08EVGVcf8sZURpoLRo8M0FDFFfRENP1t/z1znMk9WyJlM/eeUZ615BF/PtejXmIpfMVz8YsUhmS+w2UMhSYOcdPF6Bn+ZlqyXl+hqb/BlpXi9C60qJ1lY/W1d9B6ylZe2mEpGVJ7w1IRQUS8tp9ZvPP062H1tQacOaJH0y3VlnlUvr12StZwz57lXUZPD5SnQaPjzRugwkY9qlq4ypiizfMTAfphqnw9oW75f7B2adjvqeRD7HDh2rfPH3fwvLB8buzz7wI+UhJATJCdsgQiZbulp+at4zkEjGQvtI3ais/OGsfMY/OiE4fTWFTyJzxAU9pO+OlRQLe32ZrZ+VSGDZIJTKTaiNSEp9g2kxqmgXP8hn+wdJD4igznRmQgAF0lAFxUJSTUA2IQCcQhUlPRsNJ9mleViTIo3Elj4bDREK1DTlNEEbSUrYbtgOS0j1KSveSpOTrjmmAq0ivWwh+VAD5LYqGjhfiOc25q6+pOzjlZ6/CXihs1wU82FMfq6Kl8egNloFsd/Xw7E2+Iu+urxa9klLCoE/7vvxUHkdVbuAtVCoFM5IPDF08hDF96fqOsE2uG+qlHiN5nJxArfwRsLUM2D8Dd508yYkgIw4u/N+bFSsgZ6K+CjSQqgbi0VLDdM1CVCBPe8rDH65toh8mYvv7oAvjgunOAT1MQNc2ngl6qAdd26CgjwRoFZ52WBFeD+GxrRhN0OegtXndO/oIGB4X20CBNEJESt149TNxzzhHsVPvo0GyxCNBndDp3mneu0my/qUxiv7VMYnifyYmUfo1TFlaPgqdAVpxjtN3uK/wMRp6AqYvyqFFc6BBhxfCScKBdImjI7sNe0jCjFF/jit+aZYmKkE+2CvtBe8TbAQPlb9eD4J9+N/pxcfh8ccB/DrEz/3B4f4V/Dn44fphBRPevWm/+vymfdQdfxr2Xo/ub72Dj87n6mj/VTvoXew/vT88OOh97g7ef8Pf+4/vvwWPp52gCr/D90fHD+/P17dPh6StN73j0Wn7Q//u8ODD2dv9+8NwXPmCGYeXByefL9/v7796fA1td9uD44+j49MDzDt43TvofDwGRF6fH66srTwODz5A8vjT2/bxq4/uaRh/Cl9NXx0df3jT23EPTsb7Jwevgv3Bp8PK6dsPH18dPbyDWh8G7csf+/2PP1bMlZOnyuTDQ3Tydn94+OH9h4OPF/Vu7ejyfqtT7/84rX+PoPyrx95D5dv51Xocd9a/xfWNL+Ony5Oro6Pgw6Uf9D4ffIJCF+23l1+Gb28fDi+D+8365AsA3/hxN+ofRF/a/drx+8ezaedbF0p6g5NpJap8fBrs3/uB//lL5fR8o39Q+3D34cfm05v7cyyztflp47j67Qv8vvW6G+9Opu/906OtLw9HIwA83YD0sQu/9v27v87vp/BrK3z1/vTLwY8vmxtuuzOuP2xGH7a7+92PX9zHT0/x2eHkzL/f+gYlP/SOjuDP4ZvBX9/eD7Yr/ueJ+yG8GvQ29tcf3nz7fP52//vpxsGn4F03Oqh+ed+r1b8c3f24u384fdfb3H//YePy9cn08nj014/Ni/1gPbyavBtGX/56eno7fpjWPnfeea/qA8BwUDsNfpxcVeHnwZ3TbT84V3dfBh/PR+HWu9pxz90ffnv3OPn+0DkLK/f7b86+vF7fenV+cna2Pu5fXr6ufj/+vP/6/j3g2jncbD/17gDQX+P391u348+jI/i436l/j53DzvD1JKh2zqNX95Oth4Ozyv2Gf/D9c3B13648nbnvXnWGb8a9Nxud7uD1h6dtDwAO7/w6Ttvn24tvr8Mtdyc42tlc36q9e3tQDba8H7fn8dWbyfnDFhbanm483f94dXd/3jlbf385fX/7uP22fe59247uB/vd/Qcoc/xw6Fb625evH79cvTrYfPvhyw+cqfDN52/V1/365y/vPnW+1SdP9Te3n4LLb+6rjbPp++GV/+HNX9PRZ6TlzY+bG4fn8W1/8unxw3Tr8LJy7nrd98H9evev6aR+/GWM7fz18P7V6e325H08qr9efz88eXpzd3a5fn7+8eL9+PLH2eXWq+/Rw3r99bR+6vWOHy4/h1Drm+/jlF9+fPXj3X77bds5uvQPP9TXg8rB5OLdj+7ljw/9/b+QKEY7x1Ap/KvzFFbPPr921qNX/rv786PI3+wMts8r5+FB9+J9u3Ya9yPCJC4+fjpr/1U/vDo5WbEL5FnUFOuhlwrCohMHt/iWM3sV1TWICBiMXDxEB3WGOiJThrbSBWYOgikNnFhgN+TJw2+4+UXaB/FIzszp9Y74l3IceU+PI3UnkEl16dYP+nrLcUx4zJtIvmszlksQPwu3l0TosbSFgslEKuTOdCFTloGvXiuYV1KcqiqFOH4fTw5RBfJ8UO/7AYz8UkdHc3suuanO7XxSDgShWHpCtVRNkkEXYldT5VSquqQyxD1HclgsgVc7nglAPDcq8TtUGpeISxwH0+6QjES/q1wsIhmwkl1d+rHfSyWPg2nkHgUPvi5dA4akfx667kiX8Zf7lIWFwcw+ee7DeTqGtvRgrjwe2YgCuZGx8VkX+p+xKHx19vWXZAjPPb87FC/6lar6AtTwQV2Z4qJ04ytVjhxV5sAgUQUr+jw6EpK3MxOp224/dKMhDlYwZQMLbE8njMnRaQmiRzIfSmKBy1fPIvpYcHIVTfCnJE2QOu29mwUqaQukzHtNw1KfSJkHDRyVrgN7l/KmjkguptmIFRgzHe2rdTF1YVW2PNSakDivorKARM33PHVh1Qy673nqwqpiGYq6SfLxvevHCyFI61XAYGlz6so8HHZA0tQ7WD0uJICShINGtpmCbk6NpWGMYQwKmpldHgJQZCE7v0vVJ8PTg3EoaOZ5eQhyH+TpXgrCA05kQTfjS1W/c58yHUgm3Fj8aHmT+auUH9DXGD02y/QRA+KWThN9kTjrubCLB0/CXVaZdkV+kPEOyRj9Fg0pVPFHGlBnRyaaPwJeoT+Fop4HfhniVMjtN8AvoFyVHp8HfyFdp2n1eeAX0T2RLsuCWi3q5VcGGLgR0muyIJuGxw4GIgW2CBvwCEsQ7zSyYV1XblgkA2J7yrifSZrARVxEv3D4z2j20XOV2JQrTbclb7/Mptd0TdPA24nUZ4dkXbs35R67aalEe0uyAQUh0qLvG/V7Lj+irzTzvyUfkLSLv8jTKZ4hHFpBj/kGOtDrUXDrjDqcIUjx6VROgV7TSVw6hYEcBuNbmJnPXjykTvHpQlbMfbBdQ7YQQZ9KLvHa260YShBYIsyU0/4xLJqrzseKOnM03F25PnpGKQAT/ztRwFgtb9dfvnT5ZVZRkN+7ZRde28L1UyomX6tOtetZKXgmD49HbndzcIYcLFbXMe548ntd2/ntriHG/A6JDuPZP/y2yL/owYzsswXa1wrUUDq5cXT4qyLZsCEkkd5yJSs4c8eVpKJt4YohkXCTb5JYLYvzjH+kTA00S3F1ltyWoYELbEpp4N9pAylAjEnlQdK5TP/MG2aN2jyTxXs0AGCoAJTfeL9su0qD25G14ErStSWKAk8uT5yBe5lNukJP/jTEGl6YQ/9+3D2Y4MMJnzYD2/VZn7QlIkAuUB3JoU70HbohblgkyFQZfiUNyjXDzK9xla1xZSWx0OeqqdnmzWzzu7s1K9tqtuAVFJyn9GbUfSWUvU4VztaQYuxr9eNFjG6mEAeS0u00jgM/IjOetc+8UIKT5Jpu5lmW5trGlJJFIjSgW4hAqsrq6SibkzOl4ZmmCF4zZBdHEchFN6wdj8ZASqH3WB4DRXuT0dPB06fim5jYQy6vDoMg7BWxIl5PZSIDCPRh+dLCc8cr3ISjXc3MsKcMXr6MWppcch+xlE1v81q+DmZH5OpgUg9rDVD2nkVymVgzpXRgHPuqzKuRznYCoLBiBqTF1gveymFWRwVmWRdS2uFPMBDyM/4sqWRxMPLMi4xZz+jlrr/RYWmIM29pJB0l9/cW1eAu6WKlzqmxkBVoaykvbugodU5d6d2NPH6lpMum5ytbBznzPkdQngMIn+jgzhV8sSWyQzn9fEiy5nSFpKWny86swLkN+XMaktejLl8sy0WEqKms0KP13GWbTwMYOWr0t6Et4G7YCvJNmPNdG7jCy5fwq2WPyo9Gur9KROnASm1fabmbXRzSiehEbRoimZWK0FAJmjXWatbUHpriu5mjoQytqU4DoUlH+LtizGYzyXLKIkVpBDNjvhAlmTOXlNWafGFoZDbcz9OtscgJ/1rZa22uIIgGsjwpaTWkO2wO84Glvot+ZZJu7C8Sepp63mnnyl1cX9SKjuXLUu5yyuk39qv0+zCjuZr0MnsC6VS+1LgWGlbOePOnrxJf48TqL45ec/WBmULekrT5goT5yOX/PAJ8whf4Hq+Ig7kaiG5tqdJi5hipLHyti/NPmLiMQrS6Dk1bUMVYdGgFc8ohFQ1+0iCG3MLr+ly+1fT555x9tGplOaz0nFX26Kms+pwLJDRD+g9J13kS656OKUgSwG8J3XNl7ueL3HsZG2wUP43ccpd5fqX8McrUP1djulWrSX67nD7zCttab7M9fcMNCbDRWIQEc4RbjIIo+Y/AzBcbuU4zX5Q2i1FpodjMOHm+dFxaLOOCYOWXFgjLzTmyS3GxElFarJlQqWcJWOZysAb2Qp/Ily+FP/jI2K2yUBUkoEa5UrVGRqOaJ3pNS8PVQcmxpib5my+GiavjTLkTBneN4K0jD105LZXMK5ja9ueUlGhGVyxNOs3nG9TnNM6nz3SsJcsCNTxj7GeEi5BLB8wXljx+STQJTkvJG5h4imHb9n3g9VYqXBkSnNyUrgdgdIISlV6MVSaQoPKT8GHOd0tqrSda64nXehIGW6bCBLu7FcuBf4wZjS7zjPb9Zdr3jNUw3WiEjfqk0dQwXUzHAOdpydEa5WNbzaI7XAJdEvAhNWLANHKbqWWbGSzTjPM4d2Jirziy6J2eRdNS/b15wY6SqbGCZ/XOWbJ3mWmHLoHKTm5w80nXqdp8tlnNZMb32CEpk+GhHVAVJHWDm2TIqJpFU6Dplq8SVHnBJ6OxHDxvDqhQ9OSV5/eSGLy0B3Tess4SSMeoIj7ugnTvXYcl0CAfWzGPbRgxVQ4vo8DKtCtJBSj0E4+GaSZUbAYlf7fapG0Nbd+E1VxtetdDhB7vBfaw4dvDmYNBnSynhRGTACAlqREBQGCPbpJ11XNvp4OBG/IcRPMZrbbcPWixAS3PRnZgwha3CzVIpCb4C+NFom95185N+cmKSAgu+iHOvIe2Y1abw5Y9ag7xkBvBPrVIPQDD62OiYdG/uwQOzSTwSCanvWgG+oUbM78z18cjJ94WPtsZa8/XY2haTr+Ob8oqHNAEkPe/ky7GpKa+Wq7Vm+KQXvZ846qFqrwjQe6HofNU1GBEolLNL+AsKjBaVGC4qMAUaGAA//Uw3BoOHnnOgt7D9fzBG1jH9jguX8DvkXvgxedueO49uiOMtfvKi2F1Xrjx4cibFMkZIjpHEu0pcXloA9S2dkra6Slp35TpmIL0XNgbwretz2+QvAI5xIxWCmaxrYbyTHwU5DkSV6Dt93FZBCfonJ1znXxxYXqxkdJD23ZLtVVNTfpSkJnNSb3U0syWQGeHkTMB0m/b7VLIuRf8YoodmTFCXicwY3fwm4/zBfy+0I7zBXUtUYby4gbErAG+NsuL7Vb44URShIWbf/nyRTpH9Uu5x4B6rhMRIY9MwRAKZR1Eyxgd2Kq6daMZQAH7nnmQAX9AMF8ggTiXmbVK88QmAeGmpihlWO3SSevLHubsFR0EcGKN8M+ddZcUs3qtL1CxZ38xjEZRziBVKrzKif3FmirVTki1E6ymQj8xoayUPxvstuH3wG4bSeC5tjQZMDnNE+1knGgm42TxZJzkTsZJejLuNJNxMn8yfChg37Gxr0JPMQEmgfSX/QZ+RUvxKbP6LUyBMn0bfwC/wgI4vvCnbbVNUXg1wpEm88aTGknejGxfE7tn/q3lZHXt6d+E0AHsD2HqFDckHVdgTkgyayAvSnfsbJ3001dW7rLfK3ZMWyx6wCTkJhuz6JXEB/zicloX1FagVlHHtCd8COahYGZKpEYCxflDGxolDcjuSSnWuXyvDzWF1GfKlh8YMxkZo/FPdH5OjxvzsEyQBPlTx79LExjQ0uLhKi0mVpk8Fg3tYnBARR0bcP6T+C3CaokVmXQRFvdCeLrV/9wmUYmdM/30+fYO7P1LDNLk71J9yRaUk6H6dobqvy4m+6+/R/fP7PXSXXoGh/snursEj6MS3z/Wf0/uamkRrfyTA+EtbB0Gav4o/T/EGuVxnc4T00uLecZ/D/NcYj7mdWthE6WpJYbIXCA5/Qm+uoB2/nsEid9Zf+/+9Pp73uIjwvKYuuwWO2Tt4j8T/KdLNq+4/MobjdpuN3ZQa9eIscw31xpj9HT0+phXeOL6tKDWMrDvx97+yHOiJRX+tO7TXqz7tHN1n7as+9CeUJXn8qqIJoI8pUefXL4lg9IxHagKGo+ZuyDIqJsjLDavjMEUdQZxISGs1fLBmZvY6J29qFkzgOy1Gu7ldEDeeb5b1JtRzmFmSQCruHhi3Rnit1mtwacx48bQo+CCTpGYfW4Zs4gFmJjyQ2oCDX79Cq8jagL1uQmUWiwc213xfOonE/RX2rE1An0Ln7KYUqMoBQHVqD2PZAKo5rA0EubJnj0yh2ieDK972J6/N7R7jZHdm03tUalqTYlRdMqNogMCgMAeEPSeAbsV7AHcBsCfDWzUiwe7ETF9EqAkltGgNN0FJsCP48WmJg7iOeDEDLe+irVMfDW3b1+VtcdJ4fUU1OkJ0WirVCu1xlabLLFmtzUAfHvXHdO8sdmU9cuXVr98ZVhjO7zuoin20IYKOd5v3NsNaqEaX75CbMqPzV6wQmvvHkIvDxkow6J/W2NIHIvErmk2H4YesAxA6OVLkvzYanOaz+kZs9HT0sBWDCDppYoeGkZTHL2elK9Kd9DdXXTlV0fiBEbiBEdCTb6DZKwxd9C7N+JmFKvdt3p2rxyNvK5brFgdw+rsAgG4YmFFRc/qQapw6XSyE05nW7DHvj1t9lv2oNkHbti77pemN/kY9W+MZro12hYH1wNwPaCIHkBLSkLBXJg9IK38TLN6YwhTO6Au8QB6kjefFVgOP8hLBqC2GuGbFEO6yCPgiwm/qO46CcOotQKVY0wzHEO2VSdAWmxZ01xc1r3SQCzrb/bA7NFl/Y00Gez17G+Ngf1t1rcHJTRkVYgVi/GMScIzJojVrvMM6LWWsweQG9DCDE1aVdiZKdeYUK6BdbpWBxZoH9e0ddLsSvOvOy4Nrw9hykbXQ4meu+XLqtUtX70/OaUr7s7Gr/1L68Kmyda9TQp9YWbJ5mHLnjSN5Rq726XQAG0O2LAuWhQyJPJGDOuLaQIel7XdezwTUnC8xz3lonRHVmkqyyR1dqvWBSxJgilsOZkuAO4GbLRm88tuRQOe45AHmyFOODXjxNMF3fdhNBVoUxzDqbahKSI9pW1wvjHcpWdjI8E0hnjpQ17BeA1kOMMUcsvrC3lgmvmckfcpubQjHyZFoKimnjNir8iUtOl4mlnUHOwKJ7CEIflAIH7LK9P3qJmo5lNRjaVe+0IE414NUg66+DtKgufj8mGPI9FLnwHePcVq2k4YllLYMcjBZl7PrKDl8OkMmoHtQPPTGfcfmHuYHeQPV2SghDW01eIOywA2rEjVl1dvPsvDgz+oUJ3vka4Ji7LIkS/feRY4yxBENKSjy2fSETnOJ3emkEbyZZf/LhJBzHIIAj3jk+kfiukfzua5jzi8u8+cSt2EsfVjMdpAmnmGM2Und1q5E0IidXMOkeyw+old8dSH4eRPdhL9TN6BR9ML2AeZzuSQVPdk3ch29hKyChsJqXETVtiMfv1KuCNobR5RN0dWMs74O40HdyNERnwYF6ub69sbRnNYRiAk5DBKKDYskHLy5ezVGlyq8DTP0a3KoVp1b9yt6WoZTaZwlGx9NlVCikW/BGXyeI+hhY0apFnFISq6C5Rv2o4kGKXhidesmKhTyi1gWIMWH3GDM4AJQJ2AlDmBNU9WXldhk1NzsqrrQT6zDchCBES7u7DH/+zq+HaXdKpj50EnIwMZ7OlfFLF2KxjrQNvmC2hHFt0JsbEHb62ER3etDJlaXcMSqkfHaFXd0ubLl15ZeYkvA3qyDFgd7ZtFZ69Ua9RAxaIf9UapDh8GneRDuyNe8uyjwuemTnsPgQEkR7swxGN6sLvbI8e57MuwXkTcj4Gpg7Tl9cY6NsbUDgrz/FUC1ZNtJW2yB80IwVGbQjn24pGLDhwU+iSDn1rSEp8Kzhy5bmqNd8vy+u5mVny33Am98Rgf36gw8qHd6pUm/OS5Z/KfZs2gxu84OYaQCFEw68RDrEb3j07o+BE+FlMEQd4C8IQ+zk/Wag3xi8+uGMK5HVe+2OjKAccIsbTRYSlp25j1TJv3ZabbDIo9ykTUTYEIDe8D34uD8FLeYbijk1emmwNuBfgEUep5nMiKpNuvZfWNHNg7ovliBWwdxWjNT3hcDR2ZNEwYmmfFgPRbHvMYG5msMI7IApsk3SayvKWpLLy057C6dDWcqapZzbpidMVOQWsdNXsBswyk3i8eEHpno7FeLVdXtzc3KhViZlIefyJR3fBl4p76xLHVk540tqoGqBeDXZuMFp3Pfo5UNKAzjMx48Xj0rSH+V9rAuOfqQ1t702yfyuIRZ79MqcZozC0W0rHKsotpxrE7YRTyAssrqEtU11cfWAPhiWs16CBfTzB7xmzAaW1GTV2DFlkawk308h0+nJZaPk16g1F5JSv34THDLUuPr6VHNsq8di0NmSdGFr2J5bDhyVuYmbDgq8V0kHr0guUvbYEkglcQm5ENgsIePoiNY3TuFku+5F+XNMxytZkz4a8pdBTF9zuzhBJm0apWuGxbZWqLug1E8jYgZNxEHNU/NAdS7V52mTYEo2+GWmk0YQWBZt0HBjNuS3oVir4LeCDwZodIfVzOY66YWfdiLoOhs9+d9lzlLu1IeZeci4CINJDiMxUHVrqkiNBEbzJ7ghjsAdkAvKVJmQrWaS4O48E6CoyJevuSMRpQ5176EDBSbFofJIWNxCI4pQiZ2UZoK6UEdYO3OJu2SB71JPQkobyHgrLatRe5XSOS09RA4Ye/JkfQLxGMmpTLemXpfTkp25I1bqSxJcV5ELqtbpPibPfZo7lEpJngi+uvRoGDRqhk4RvElMh4UgcWWt8acKExzVa7spQIUmSVGgnHq/PWpbE2bB1SXtk0xqbZpPKjvKl0Sj0x+ChboSck2/ru0sysY3BVBbe+Gt/4lie4n0l1e32zTgFQLnxh30nbYrOTs5feqXupWbzYre9VGyBw4esazNa+ZGXrLrURY+86rRPhgo9ycmeXGTgYlvqtucMNFiOiJ1207Mys4LvTKf0nR7m5kLTpC502rVNDLqzALPqgM5dAkGUfpXqjjuKFhsqsRRR2yLbV3QkxhR8Kn17oRPt/j4mzb0pe7mpVDmZ8ZSiBbiQgAxtFZCNq8D2xO1aHL3lLngY8h2b7eafFbErNOSrM3W+qMGF2juftCSXmgEuVDOteu1mZE7OebFilSUm40VbLdVUe+i11g4zsPYzgJPHeBWxSygV7ALU4SWkXNH02wRsCj/QVTsvloQtdwgVd/gZ8/kDw06dwt7LnrYWNygyXXSfYnyKrE0dO/IZ2oWBFyubr29eFt45fsAqv3Fv4970T4vtFk5D8foJ/30598u8I06cDfM/RncC/Z90Y/j0N7vHZSLdbuBEHVuwqH26dUu8QCxL9A4oQAlqacVGRISPcoSJ07Uhs5AYEBfJNGI58xwHkBZLxJpjik9my/DdlgkGrRo7C8ZmaKbdEUeCeP43dVK2BXGtAag34VklqUQEyVasn1+qRWj2DbYgSR2PNjkZexKGsgZAnQ+rLkPoypMliSCqoaNfmSlRo2iOzsFIw8cJNq1zdg4RiSC6YQGoD1rg5NeGvOSD/9kx8zKjfCFrLlZxAyc3KoqJQaH2zMqcYFJAQzpZ5U5AuGiDdtN2Rg4/PMGkjkUtANQ+QjBYI/pUKCv6eIvjDIDZxuFKS/0gaWkeI/GrqjDOIkAj7R9KLQbLI/yI3JoN6RpGEtH4XKA9HkvVok3v/v35F5ctWfgwozL9q5UceI/VZXCT5av7D/AMZAlZTbbgoYhnrYP6FKarFLBmvKEI7C94BxH/+9jUwoWOgI85Uq2NMNb5b01zHrGn6UsrATuf3Pb93OAoiEJmppuOXH60XVeBDIjDfEMrZA2t0nesikRkXrEI1HBIC8zrd6hOqoeQlyhtyr3TZsnh31LCKTqvy61ewm8QAwHJXpQg9S8jhlS7HKmbJvufGLnnVUkSQtBEyD8E1t6gcgwBbuYRWLo3WEjXpKdrUoBKSQ0zvdNpHeGeThepRYXjOGMCEVCgZ0IJXCwv27PwSzEHxGFj4JEr5pgFwKoxMrYHVQ98a6sWmFpahorDKC9N9x5o0cWnnn5wW3fxj1fyVD3LZXh+WW6NvVy1kArmsBX3Zf+foDxqYYAMTZtPosmkx+6uajtM4J+/I8kTpj6hbHTZB5mR1fg3VQVAY/dIjKxAob1W2VhfNumh7+dIIeyGm1vKd4gSzXK/+ZMtW1+pwbbtQSK6gylVQVyO3Vk9hINDHzrTT5E/lcvO//iP8t//SBTFCELhjX8TOeMIVlCHWfGxycGl5+S57RA07Mm1jpkWUvAXCjwTFTm/bD6BiKFnn7ePDk4uTs9Ovp2fvTt6fdERhA7AheD1JopmZ7u7U9+LEYHlnL0Kl50bd0JsgV7MubHruMgoG1QqzHRXvYCuVW6YnZRf6lpkzdZw5QsuiwXS7DcNq8zM04f+t0Jdy21DOSbt9nwAcfg71dwA1+6AoFWONU4OmKvP8BlotFU92d6sGuqBl3MBzauPa0dcUbte5Q6dPZty+a+b2n3A11uLcUnht95mDUGr//jDk1F1yIJ4/DqX2M0aC+gXR177S/iNqSEFSQoRZ5Gb3ppsSU+XjsI74lWsotOb6jsyXdUUszjnADBR/F1XPntAJBPAIci6KqA2BXF2qNt1l7z2gf+uwlT+6NPqFdvwxwAVXhH6OiIvGKGNsyLJwrjVM7RckikMzHzoaJsJ8w0T7+N1+5+TT8Z5cneuGwF0Gdg7cR37mYupqNgCzamNxZWuwC9J/CbVSkPsHraD8aLKPKT/DnO8lPsBArCD04U0YnS9JDgZPHINVh+zgeZjGQALl0J2MnK5bLPzHf/gF679we+7Y3BhMfFnKHmoLZ/1i4d8LBpGuU6nv99t/Hbc7J++PeQF51/vtWbssR26XCAUTxxfngwtHfcSC2GXMa4sq6kix2bW7yRApPbXuiL4hD8Sn/Xcfj+kQLHe+ldY9pSMuQ22ZgjaLd2pMEBPmxCoUpNPRCzsNMaOTDqwXFfRPvmCxBi8kkaJiNAqlUqG5fOv3mWH4eHrSec4o5A3BnooEAZs7Ao2lC6ebQ5HJSFP6u+PXx6dH/0AvGOBl+zG3eLpJKmWrYZIlUj/Hx0OR76fDtxdzWUSmSrFrUG9/3dFIDpBEyBzbhykhM1NYFRAz2Wlxsy0OXf4USK0jbV5VJnP1S8UxkZkmpWKb/Bgj520T1c3NFb+ymKJPyhxY9BpSU/OgUIqtE0cCFs/jil5yJEk0oMeJzRsx5w+ZfLtVAUOvjgMck8IpLQWHRaHEeuzaJ3EqSZ2PzaOiOXnqec+JNTHyStOX56mROXVMOG9eElEL56Mv5uc5ICYmm9O+Rv6jir6+uhOGoGSDxMQuGi3a+ndrdb4NX/PrdKVFsAV64tZk3/yNOiJpYWXjhq2282D0NAj84rwKdKnRXXdR91tb/53dZ4RR+me6D/9jTpNElTHE4QR731m6uiaRivROM9200HX45z+sEfGdM4CdM2jlINIMZEkoyb4OZP1BigSrFMGN2yk/XXSdkUvM2q2QHwCI4JsU/9qqI9ROJ8P1R61qhaoo5MiI6j7pLc4hzNVyKDMakQU7tYdiTxMNmJkGQJUZJjvVvIK9JFaTI128P1ejNN3D0GfyCHs/OGsfHbcbveSEXmbj+nqEn0sVUzO+GAA/BL5sUOHgORdyenkXXMr7t1EwmsbuJV/XHOChIeK6zKgmJY0ZjzGQHbFPqRyMfcN63U/cpVO9zVSijndSvYwj7gIAfLCutLVL+jG4EmMQXisEf8MitGaSyfFOMk5ifCa4dt6EP2QhQZnVRFQ4e9Xoleyp6WQiQOSShCQgYG3Tzq3LxQFsYa2mxfJTGKew5INJm9k/OPt03OiXbFxIamyJnEmg9Q6O3519bvQROW0tjhpCFqjpBENHyIA9IhXgP1NyqESYQ2Z17wqPoDQcFBB0MJizQMpVVBmlTkri289IfJPUnYKKNZGcTZUISftZOS9du6bUrqXGbJK5vzBRHFuTVdtlAT965hx+SI9V+ouLMDa8uwstFoeS/xReVJelTBz5FCt3FHslyI7URy4ewsZL4gITX9Jj2IfDYuHQ8f0gXgmJ9cwNV3A/WiETsfK/CmagaGnWih+sRNPucOVqxYFtvYD7N2rk7MY5WaqaxxmSgK7kznY6nEhLGDVL3Je4Ql5kSJVjsXOBLgIf2IiLpwrFwigI7gA/vG6/UjDd9D6dgUJ2aAUCFICagVlYuS6YSXncsnE0yAV2s1AuazPVpC4wupjclDcLNwXYDbhfIXHdbHIvJalSdGM58rdPxsjdDSj4QAIpwhWXyiTIrdtyEgR5pm+yzF07yOZSz/eWzSo6Gujk1qdv25HxU7jjsdnZ2SH3tEv4NJ6AiO1R2SQyfbzTPZS7MwKpsAXCAmluKDW3B23gNY3IHhkN+D0ivzEMASUptHhFeIBGiOrEZyQ2l7qSZt0b5t+nxFZu2WF2SCqyR4seFkWbvoDLQUSpKalKMaQj4vbBLvU3idwalPxWMmgJJj4Ohd8Img4L6mwleXhguBfYTsO3ndmM2rel68Nuq4536eBftSvhnFfXIjv38LyZc/PZdnNvz/KHZ3VN2bpLt+0kr3wxDgIo4Q/eBz3XfgKYAPLD1Bl58RMby7pYy2MYzXEr+6hqcyyL29RJZJy65nyCBwmq6FvYLlipKsIxVERPZVfJfBJU1rdPjFmux4Biccq94wDy2V6loXug7uA5YKjElkDSRdFi8ZL10bIz7fMngqD0Pu4GDrYjFDDaiJPKIJD4Cz8aYNr+kXjB+dl1I/82d17djqjblDxApfssGUO4YnhB63Fz6dnL9yexg0ZuvyDTmvsKWPJYGNEMl6P6n86cmyjPjvCVeFLZ9nheEK/8+MmaQGEklrIjX25xrKuyHLl//hN7Vh58ElMZeOTcAoRr8wc0k5XeDcYTUEHIWyf7ILvE7gT9I/M5WQ7lvZtHte35ddsJ1S432XRSr8pSyIFcwuY9tSoJdWu9rOzUyMwNFrDXbsxh6cvDIlI4AtO9miNMJOhgO89x9EX+RmbwEde8Zk2ZxDjzCk/InHWZp36O7ygeORPztfx86iI+HTQqzcwzaK4oVtRy5DnPpLZzc5juPc73XzPb+cy51J7DuU17PKODOnKiuBNMqIL5Yp7zrih+EMRxMM6vcZCaN83D5Eqr+Y1a2jbnNJl6cF55bzpBA22hblF9rN5SPtFkmu/ZwrXq50xzJzfnt+PRWM9/Ui7fSVIMHdFeO7JJoCjnnLt+elhFOg6sHyvJZDT1oI15zj8C6P+sQTYyz3f8z+recrufEOnkcFwLtz+286XDL+XV4++Ey6cR1nOFSRZPgEXN/Cf39mdt3aPGkOD2nEo0jgPfFJbd2PFOANaa/c+m29wXa5/xPvUS7uzFBY8Lc+cyslEmgRf/1Pvczx8zGJnJP/6g97x56dr98qPVsScYkNT+gwSkXcuqajXWqFbj3As440SpSkVTHmsCLnMukS6Y6G3NaSZzot0O8YBFkdZRbdLGGJML5Td8I0HMNMRizS5uThD3fJz4o0MndjWnayWbRPbRL9An3QL9G6Hg1k6WHiRs3s7BCnYd0EqJfbOwurqCBVbwccwSvo65EvFHtMZKJAHJLzFjgx9bHWT41kVufpfk36Nf6hd7AflRw/sder1eENdXqFbFEKRfIAH/YQn3PN6qFPjhziyDgvxdTrogDmrfWxUjOZJgpxFpRFeYZdPxVzz/3hl5vRXi1rZSLJjfzYJRIKC+/V1Q3wDUCwZrd+Fg/IG2WGPf/+nGvpPGsDWcmK9xQg559vWx9Q2jKLtLFf2OQa8+U7fmb7b93fhsf41LLr0uskJm5rvx83MufV1/50cmbmx+jQWPPbC/mdXmQet78wB46mczH8ABA0CO4LxYvob8ee2QBg2IW4/xr1+PcUtyfzwApA9aC0aftD4wUTTTxFfXyGhTax6iWYOVrifkkpLVW6LPiZ/sgby8+IUb6LixJj4eY8PAi6hxFi4JsosfBzfWp5gIE2ImOnig2olbozgzOB18sBHy7WweiaYMoCBn4MYH037fDSf0wXXD4gOaF6xaO65SG9edmI1lOnESH5IR/JQMYk6RGT0SVY4B0etoxQndlWAaeT2XnIQiEy5QJ62sXqCzW6mMXBRYWV0t5Nme+CvIVnuOQdfFeXD1D2e6mZcz3VgJL9SWLbBtK1M0FV8ojeBliHkIw32MYZ4ARLVcwZg0XOgdM7lqLITacUaITcMrJ1t+NkvYF9CWQ6RIMm0v7B4Xo3SvmgsRKwHIcpg1KmURZLfUYzWCuTKJ9O3pZCL5C/AqpBeKhUNnd9TVsntBd4rNlLuh68Tu8ciljXYd4OORvinqF2CzEdeWoMZKKEIFG91A2r0mpSoy32r/95D3N+Af3HP+inV9snjzoo0d9A1O63yCHKBcR/zipNIWpJKU4iZMoYONJdnezbewJRMuHk75k23LsRTlCMvJQyiSbXcYSPYGFloltn9zFazNXVtNzXaWxZJsY3xdS9m4kSgnpXxzSJXBg5lPOVnOY5OGAhvFaL8V24t+SdOin0jRT/lFMYJ0/mSnUEhiQY+T6+OjeO6geuhKkxAGfgA+JeiDyJpDDSSaKnBDLwJmDSy1lzO3RpY4lpp0ru19try4OZYPCnWlm3T+N5BS5pEwTI1WMR9zRXzeWoDV92lx/dTqsuTF2yHSwKN1an+CP7pthihLb/DGNrnHPHHLV3JKGcMtJu9IvwaKf63dDl9Tale17ddyuAs3b5cWmtZrWdOyxrLOnAC8xz26rczD6zhTStLQAatpJl+0jtr65wWNAEXMLeE8QonSZ5R0GdKfS+U61vqMfjpCYPwY21iu+blkf4xXD6CASX7MeC22tz/ZMlV1BFUJ/beIYKhk8xDbc3iVNfAkg+hHFGc+quIM9iUtY35E0WbgmXZeweuPMZeGEe5bV9YABt7aA70N9dbV6ADPQyJHDRgDp0rL/Wn8soK/tgewRqxTQ5kknVj/1s2K9QdZskjEemjAunNVuf6dC31/57YOsnL9Oxe6C/n2gV6uB1AHvyHXs4GSgF6/c9nYpBO5IH/n0jGZzdQndeTFr9jTX3N7OizEfGH6ASf+QS9MP2SE6YdYdY94nbbkPcSyKa9Im+bi9uvYyhROViwI3LQ4k6yhdNWsrR4YghNQw9JrugvT/fMzbp+f7dcx21TjTFFkA6SoR7ZaKIGFM494MEAVBFE1OOcgaTLbEAzwuVxh6fFOW02fOeTZAeZSzWJO/xArrD7FnxGYzKBpiDZvLqN760qM7gC7fpDiMQ+xxtSA4/DWNe3cktcHCqv7qBg73rprAxrp7qPW3PEsNJ7D6zIYZpmdvhNpbneg53Yfs0aMpqK2n4o5LV7tX55c2Cenb47bJ6D+r5A4LmSO0Xe55/qRFz+teNHK/y2YwNQLkzhaI9f3V1DJQydixjR/uD3qCD1y7yG3YB7EzN7qauYnsZ8Ao32XYrQfkBo+uK07NzPWH5DRQr6dzSOMFkBBzu8yWgno9QfOaNOJnNG+SxitjsdqgyW8zg+W8Dp12el1rA8OMObBAXKAJLEL8kr8nagJJIYscGA3XnTlMS2mATe9lPRK9pkRmmcZ5TTrLKFrPF0B3RqW0mettMqaeUaAEIdemZCVXCngedbYFbkxmUvmwEQ1FLZHcJsQ3ymMmZuynKnGhl+/cAC8CCYadugZPS2ao6ebVetuQf6FnWt9AEmJPKN5n1+EFJBiAN5rUKZTdjJ2Bq7WOnJh3Vu17LhpXWWeOfvQP3n+5dSM8lfVRtrSg88lJG3e32pK35M5uiPhvF/+2Kk2LHnr2z9+SI2tfJ8TE1FnAGbM8AuoyVj9a/x79b/R+jmvDCf1utMwCsIDcdP834vfy5cleVq+AmMrQaJZm2sRKVWNBfPPmhJUQBrK2GCk1GdTWLoFRN3MNiEn69uQLyOzk7VcN3smei7vZq+PVHTh4fwcePE54I7yCAYLf+XFEg/ncaLmei+RqyG/7ctfyfXlT9/Jno+EpIxICOmDziqeV6KzwByBtco3wGGjnv3lPh0FDz4NWE1iLXTx5ohd2Mcb5e/cflzggazLtdXFrjNyAkz517HWJb3kpZ3SS7xLITkbKBqzDDJtJKx/Ahszg42ZwUZF5eOkwKiUROv9PHSBQGWulomsi5eQchygSbSHKgkDIreB0/KnWylBMzMJmBSmnKgDk+ChWC3X6pa7Vq1V8MmbHJesVY9cOtzNyX75Mtytuuu/fi2cojVvt1ZfTR4x4OGCtTc7TLx0dJnvTmSs5eBTWlQvZJejFqA7l6Ay6ObcTzH9NS/f1y1MEV4yW8f37KoenzJS8KIb1o5HY5i+0Hssj6ej2JuMng6ePhXfxCTM+uXVIeh+PVhME1j/lxb9e2VgrKBzqv3APHsgbGM4+atmDsFhGD2o23NHsXO1W9krVeuVBvyHiZPQRdyYYQiQnjWvyl/ZbV9+rRqY0OALdPGY6jD2iyoU6tKTxEOyz1Ad794JV5zQ7o6cKCKXUuNw2oXNqGj8JKgF09gN207Pm0b8OhwJwq8mkc2Z3EZRUo79Hv9+6gLKbsg/H9VPumg6wURNoB7wPI2anLgoYCeRrcnTZUkR9siRckGbEQDM/2IgvNQcOM7jMnBYqcX44OsCShWRcM++ZjPre0xnaYXa2aKVVz8HeBjv+TBXyi4PSbOIZcU05AiLJf4VGnj58sWrMl1Jh0O3e3fEzxT0l6vfe/5Kl16wvnVXBuSUN4SGHH8FgKGDjoCsXLRGvyaBji0siEPgs6SLLZEpvOqTTFtkpncG0mXgAekuO4+0y8geaJdbttTC87oM/Uq6PIKtnPUXhiLpr+fn9dd51PR3V5qA3P6ieTPbX6p5gNKe7rXI0F5PmDz/eoKVqk8dGA+dCXdVlLKABklGppKEM2lLjzXJInMmF40Z25ELicGUuiVu1agDBXLZgBgT6Y2WTMupfNp8ulKCQyonQSRzuWceGrUFaNR0aNRy0agtjYY6ufppENnSVCRV+FKq5KwUUXJlPI3IanFWqL3r3l0hvEusihTouZP6dQLiUV63JB7vZmhLySRdUouLQVWSOTIql/F8WI95Dam5nN3KFURTarq2rThvkmJleuJ/YmIEUCqUIgelP3D3sLYr+MjUEtMC9S4mrtvTcGaSztkzLSR4dF4HSLHFyHOAdpzQhpYmElpI0YB2Prpa9tFNmEY3xSq6CoPIwqppYdUSWLUUrJoWFt7wT0PCNE6w75HOskWSHFIQ9x12eTlVMMkhmEkFBXZJmljC88ii50WTkfOEARLSjUlZpDW5qGhOSsxrbx4fxD5H3g/3cIi0lYAVIGayzMsCU0TTCdHuPU5l0kbNZFEi1IjfMBYYyZlqCPRsAsaHxuy3t7PKB9mWA3ceB5T3v6/lgxHsAbm9zW5UX4kush8Obou1et2qbVT4f4aVs6mkq0B/2H851yTtuqVjpRJaKcYn5SQ8p1a3Uiu5XJXhikHu8p69Dl1+J4Qvla/lttuzkuWQQoLRvpwqUTE3GqXJCr0N0ZRz7oT0PQn6PKjDZSeZMr/TAwD2WT46uTh/t3+1U9HgACDeUYGMZFoJr6VGBSvmj9atVetW0bB3KcmmKTkF2JgZGrxcZVCe0XTdklw+Qxcbbk9Bz+kR4yL7EkdTnbODs84bFrmFu1xaaajEwZJFbzmkAQzU8QWtN1Mna89rhtJhS3fkOvTEond2+w3UsagoxKbsOklWvb598YqUW7JDYeQPhUHcw+SOSObR5WjwHbdUL2kXiuXbXm5eYLtrNYy0Y7ELl+yF1pRC2Uupj32MGIYvd5L0M7dIelko8GDhUooSnTZL1EzF1C1lGo1aypGjUmsqJKTFMozMauMqigYPoQxrmYeMC1W9Upikpa8ElbHiiZ1ulWvci1slCu7yraIu1808+rGo9xmOQR+27CwPiHUoB9Ci9vONFXPa0laa2F2+iDvqs5z809CwLBYxL4+hNjDi1gSjbMG/jh1Zzq6vX1nkESqWl1Fznd1Im0MqRTmVRlRAPj/BF7z579yxSUxazoIywso1lbiLbwUSCwIeYTprtdLE1HORvu2s4nN7pdT2Sl+Y4NwkKNFQhvSP+AffdpdjCfYy0QV/YxWnTWNBqeiYfbOrvD461XeHPJLAYriSc64J+bMs8cqBFJetko7GuIjiM93L78m05JhFp9QvdZS+0z5ZHamfyy608nMw/c0Osmr0z6uRMwBRzZDDUupXaHWbLVH2RFV6Lzpcmo/dS0wseeAXVicsA936XI4TfP1TrKAisYCp7einHxjF/JX5B5lHepHrMTIn8kvGVm2VFBYh+6sZdlD9/9nBb7ED7F5qxc/pXudZ3fvTzGCJdV3bqjTYdrtWowsKb6jD4mGfkbiw/ifI2WErbH012XLl3dFbuLL0ex6jd/pnEaFX/wihz9kYzGKfrAGudNUylN5VF+b/0wSv6ctcipd69j9tF1zfrDQwDD5bMOXtulg05Pc/uHBWy1vKSsnfmUbsXUNYXBuw1Oqrydd/w9Kip+zj5GnbPsWnG0TFkYHPIbIEzCM/Is/HHLOWpKOYZaxKuWvrzIT3rK1pTGm3XZpoluS/evOp/sZaHPOdJ9WR/9ZtpjqjgcZlG7AGhuxwkE/0sg9CP7eU5JYwml8IPRWGuUW488I0twT3ZwisufJsMlWD+QWZRt3LK5UKpZxvYZ4bozjPmU88O/hHg+rKkZ3n2d80NYWPPrHg0evoLA55bTWUaYZzsdViKGa2FEqUYKwVa7wQ82BKm+xxdTh2PoCgKZsTxZvntVVYelVDhE9LvdloB+RtRvYUtgzRHK46EsjrkWne2Oz1mpCTlqnpJjLHqWGFnEBLmjLICKeGMUuQATx2EaNS6e8gI63AXGQyZTgySdzU54StTJ1y5JxkGBmHhH/MO2IEDO5b4AEgyuzewu9yG1HhoTTVh4SUIJpkeI2Mn8gL2RRLJ8i31SMS7oqZuMyN2WOiTbEVSkBK6SaMlr+X44FCKjRyfHVIZqamafuZCiXbnykh6UUOLuVoV/Lv+RkpnjGR5ArDvASLkdzLdN+JdTdQSTh36a76IPbkcozgdxjF0M7UG4EEprCFEbIF8nYqX4X4Pk6/ZY+afc4SJraEdH912JxeD57DByZL8IGJxAf62DjygT7nA8/AQLv4J0ss/gl7rbCXsHR2sGfLJ3oGPe84j5Uy0k27vly8WnZGk6GDb7LKicOpK95aZUmRA7IH2azQoi7njKZASOhj8MRj7jFUGOyxmoiw22qSBPtEzZFg38kXHvtm8RAFVh8fBXqJp64XyQIelyZGy67WtvYu7IlJPlfR/b9RxO9afZOk4Q+abl3swm9YQRclGxPp6rm3u2axXeqyMl/sjlk8KXXoZ1OMMv75WnxRse7IxZ8vBga/lPlXz5qmrhJobgLRyw0plseZpcr00q+/LG0FTH6yx2HClGTFE9SbX6oOv2zr+Ycy6QSGzNK6xpK6wDNGKv/c57m4ptWKJcV945+6tpFzlyLkUut5EMXnYdCFYsQX8+fcLZX5+AsPkVmz2J/6XXIN8Nb4SV1sY+FkO4wVr2j2ih/1EMEPFyDcyjaAY386Pold4BdN5q4rYHXjnzPpLIssvrhYEAkFq7BT+Y/Hg0qBPGEpLOqpgpACJeHfdNHaVroopEBR+DdddH0zXRRSoCj8y4oqnbLdmVH8Hv/6Bf/YP2fAXNBv/AFUwYvQxpBsrl2qWaexXVq3zuDfDcv17FLdCiB309qH31vWX3Zp2zqChB3rBCsBs8E/VcuD7GrNeodf69Yp/tmwzvFP3TrGP5vWPf7Zst7jn23rFf7Zsa6gXq1iHbt2rbqxtbG9vrmxZbku4vPNtXdqtfX1rVplfXO7vrG1temuW7eAGQse8H7/8it5RNn6YBdenJzC75OjFwXrUwgK91Vo16yz0N6wfoT2thV6mmqRZ2fSRqH9wTrzYFR+eACm4wGYYWj/8H51POs1QHY3rI8AG/7cevZ6hQziNLQLUcE6gD9xwXoDf6YF6zP8uS9Yl/DnoWB9gz+PBes7/HkqWF/hz48CqfsXwKRQXmODPYBNvr6gY/2/Y1feYlc+hPa6FUfQHxe9dgahvWl1Q3vL8iLsXmTvkFpjTEeXnG2rjwD8CADsu/bPV2x9NPqhdeH6URA2/GhmDV3NtYHYLhS4PhoN7Bgd192U4zpx8VNqlcvlmK8q8ptqIC4WfB+xp9194DuW+GUXrgKoS2AB4bKrDSCBde/wfpZb8Hza0MuX5E85U4Ke1n/HFWx1tX3hdyDCwcdwZNOYBdCwM42DguWhk36I/8DIwv8sPLItFJpxORp5AL1ibRm2XRjG8aSxtlbYK7r0o2DFNi+zZRiNpHwdyz9EovRDJJetK2W3OexIAR4xbNalittKxU3aiNyKrtKmUon0BLtNasn4S4V2sFDkdmGQsRhutKLgjsGbcHkZjA1nS+/dr8HOUL598smr21Z8HYs4AjcANwUPX18S4UWpqONApngvfK1gNB1yOzkQdRzDkgE4QlOX6v0fGtR0hM+MM+U4qTFCGX6aFG5A4QGU3Ct6kMxLDfCCD/8coOTf8NByJAChNjCjqrjUMj61pnQBoFukCyREm9MaEnOxUsAawqbrtCr4EFlsBS+A/KCQyyijsAfLu9Lgn1GBqFcwB4ZBniuThwJmB0bfG4+/OnHgFcWQIfqGBRo0LDD64DiHssH9QiZhEAfc02wauSF/UmsC64lfsBrCHm0zGRDv+drctBTgpm8HM2x64MZvoFzKTxSr8uxzJ+Mija2IbLxanMqGJJ79Mcr4cSO+IjscAYW9qAKJgkTiYThg8Vwv7STw5ui2wG7Nkd/MpgXLnkOF4QlZBBRSySzgYoCtlwke2CKbKF4Ok5IhSzJxhgUsBw0QmAgkKlJxbKx0SbzNyj/o+Frey5fhdZgsqBdsQWFVRE6MQTsIyDiooyQNEIwMjNCLiiHGHDuZHnRMIwXwXpt7exF079xYV4heMIk+e/GwiPzOYFEu+XgTVptKY+yDI3AxvT0ivUzBp10npYZOtD+Nh0R01RAAjjjH9oIAz0eYMs80SnR9zcEzdqP4xO8Hb6PAzwE7p6ua1vQY0F5Mek7sHrgRmxtyhzFZea60bF8wYIw25TTCLqQmYkMCDhJ/2+15IVFIJBM0WeaxlWksSwp7Emhvj4xpAwmgoaZTTBoUSwkBXOk4nnLnKJpy45xEzkJv4PnO6GP7XWrw6dYu9ywMxmLjZyDpX4nBxakli0Xgj8TqYro0E1xiui5lphfz1akIGRylmfXRy7+WeTvtE/n9o+fH6zVqaOIM+daLo0wmP2T0/ANWlaTTsDzFzQ2RvS2qbtOaSTVRZr2Wga8tdV254edXt97g2O95DrNlQjuQ+ULkTvuk7NZ6rb69Ud1Z30VrhcgCCWCjUlsHgX6juqVm1W7Q2lFb316vVmpq1jpkbQHI9e2tbSkHRgfbkj8BfmX29fYpBqX3HjRb9wQXKbeUYdypuFXdbMbcVufaSRfjm6b8YRddaKu28avookXHaLXo7+rmVrW6uV0xIHcbEzbrNfhqtbYxpTKbfY1Dx4+gTeRQtNni1BpYPcPeLfb+c/qyOPjPnkEKwwYlsmI0zaDM4UnFp/+JZUnRUEoe/Gdx+uv/ciARy7H61oTEmsYS9sCcFkmSYRa7WI4WHtjFQavVwd+/BvDveq3UYTlmjxSz2MzSqbQCW5o9y7GlCbNGtjRH1jAZzKZvo4IPgrTlWCNrCIDM9c3qRmUH1DiUQqEqFhixIkOAba7vVOpAHVugUFZrxEMMSjiszBDaMzcrm9VKfRtUxuoW2oqxQMCKDAEFE6iusgFkt7lp1WrYExWLjRtzo1oFNXJ7fWdHh0X9xqzWKpXKdmWjtqnFYvPGrG3XgBjrO/W6Fo0taKS2sVPbrK6DFqxDYxta2dqqVNbrG6ASa9DYgUbW1zfrQFlbO1o0qhVsZQeaqUNJLR7VKkKpbNQ3AY8NLSJVGNMq9HUTleuadlrWsZ36xiZ0Z6euRwVGtba1U9vZrFcqm3pUyLhCh9br67UdgYoro4JTU9upblW2tjdBgSKYuBImmzi7iEl9c3MDVBSChyvjASA2N9aBUWzBuFc3KBquhAYS4U6tWtnc2dmBAalksQA8YWLXNyrbm5W6Dgsc9/XtSnWzsr2uRQIhbK5vbGxv72xWtVhsIITtHZy9jW0tFjD99c3tjQ3ozbYWCQRR26pXN2ExberQwFmrVrZgXtfX61oskAahfn29Wq9UtVjg1Ne26xX4bxsmTYNHjVD6OhBYvVrTobGFhI5zvr2xpZ8SpEAgjG1cTps1gYenzgmOVX17ewuGY4Oi4UloQFdqta0aTO02LoUqxcNLkUYV1nxlvYKtVDcpIp6MyAYhdCDirS28YLWeRQTX09bm+s4WLLlNHSIbSOVbte0dGHQ9Isgbqus7G5s7SMRaPJDAgAVBE0DpejxgYja3oSVYLRs6PAidrwP1VCpQQIcHssr6Vm1jA+Z/S4sHLDcgH1iQ2ztaJHaQzmE1AnlUdnRI4MzChg30Vd3AlaCbFpja+jrgCEysosUCYdR2djZr25sbdYFHqG4ssKtsArfcqNesTYpHKOGBNFitbW7vVDeqdRIvxiElUgwMRItNYFE7gGmd4hFKeBAaXN+qr6/XNmC1VLN4EFYKPH1ju17fquoQweUE287ONvCfih4RytQBCSDCdS0iSIO1DWhmY2NnS4sILmwYduD5sKZ0eFRJZ4A66vC/mhYR3OS21je2cNQ29XhAb6rrFcC0urmxo0WEbLYbwOQ2arCX6hDBPR9IeKu+uYNUqEEEBnULerO9BStTiweS4Q5Q2DbAqRM0ZDG0KH2Y/kuyYW5u1XbqRkYsLUofZpBftCYXBfSc/KLrclEYr1G66Mzp9TAMFaopTBplmr2FtmfmYcPkXHLirAi+oVl0W611IyMSt0KmBjKZ2DQVEdm0iWS7Aw2EKAG+3Fxvei23SQVl/PnyZdja3GgaQsIP8fg4vvbgDwlgBLlKyCGhFPD4tykRnN8WTSRjaBxk5a4z6k5HoK0JUVnuh0CuXxSYxIhJtbZtxbv1TYZxrCJLilTk8Xo2ckxT2GiKAMxcK6iQ4M+83fpmtt2l2pwlQIH9KL2WtC5YqrY8c1lMmSU7pekBK6XdlxUeF9EX9BgjCeAIb68W45frBuo43PTlgs56qLWjCx3965Mz8cQ9blLyFG35rrjP6/tuN3Z7r/zI/jljqaH7fepG6dThw0nv4IlUF2l4MHDw9AZykjRy6pdOvHUit/M0cWFiUPcPXWJV5QcdyUVQ2YklAQ5DAnzrRZX3POLPsMCPQmHPZSY8TTXoKVSsGI3ohe2KIklXrqMb245fvuy50LK7osm2CPQ9LeyGUi2DL0aPUlCTALswyaBE7mXGDAF7DW2y6laVykQjfijImA+3Lb2ty9NC2ATILADtDdw4mQRF2Va700zeq2Fd0vVo3ki6N1b+aBmWrk+8SaWeWqQpxQpTqBnzPNF3maLJAKu4pCoajEajYHTvimEBZi8dBpTpwYXXqtDAgnamwzEhHeI6Scn2JzlewyloPFj8qK1R8IMVlx6qQYvTUdxgF7VcY9b0kq0mNm1o1Eyt5HI0vYV1XwRJBSOevQse3PDQwavaeSWrRuIMqBvu30M2BmS5ad6KyMjwJ0nIwQfH0jOaUfLtmezx28BO2BW3fh+593gk4pNxfhFk8TqLJcRo6ZXrgumbhZsVjCUV+OgvKDAtFGZkU7QD3gLG+nZG9FgZdhNYGSYOcaQhRvfm704lOTID4Yq2zl0gSCht9syAA9uA0xo1HTR7cWTU4ie9okNHbJhdpS7Z9Id81QxtO/ptdOnjCT+luaomsfnx0UDNyuEewn5mlfgcCPrr/jZa+IrObD4VnAYrfKiQFCIkhT76fgExrPQEicDQ3sh0we3Wr0LP9Xsjsn5T7FDlCBYJEOmWBRov7AeDb8tsIbhl2oDkeSf2X7vwPuhNR26B73gh39q87LzCHuTxSfXYfhLpihnWM0c0Mtg8MySUiYMdLEwWbmRYukUqj5jYSHjnLN9gYwAaQ6ACH9nObmUvSBpwjAaoEkmTEfKG/EEJNYMytL1nD8GIrLIhkhZ2KZL3w1QsSpUEmh7r255mD+F5KCPodyBxVpKz/aYbU6jNBmr7mbvzccIj7MBT+NaKJ18KSCPFhztU36bLgW6H6iaaAoaHnOQBFsWLMVUoPeb01ZX0wKf3fN4XMf+27e69qDb0gpErn56mGtJFrhI1eZ0DJjhlw8rRdFJu7MTdoSgpAbbtfvjrV8z9bZVKiJAXRvEbJ+w9OKF70hMKlngQIk6YrYSeQe/E8UY4tFP3UQYWJ4cqrh4MOXAHdvSikLAv+CaiMknlTqgkisvM+itH3xAnkn3iK8QP3kBrls4/B0A50eGt7QEgPweQ/YCOPmK1MqjAuvGwLgktE9x++0rpUEp0oie/eyJCoDrdrjuJAzkQUhwcuBeuEpoowhDcgYisKqEpVfPGbjCNAbRar6NJ92EK5Bg45J1GEV8UiN1Pvm49n/eCjViyxF1LdcnCQTvwnjNoc2BlBhH9xu4Xze3XcOqfBiJC1DTuXuATvyIBpJlRlHy1g4fki/gd4HiJlB7z3k4SgFouAN7IjU7Qpx3oVOT1cZmwQAZH6YrdYDQd+7gFRfY1174TkSkZfC86HAURic4rUvbvB8kn9QYWgJ37gfxJ/W+TZp1R/DSRPydOmCAA36HzoH67/eSbLEMJYS96Fzg9Cbmj/c7+V+Yqad/yyO4f2/udk7PTTMZXaBxpi39SzV/KoUmJfwDgM+zxNQVUEvRXULUDYYm+UMh1PCzr+V6MJ/VoBrtw4yLSxEyXkbBui7jucjMjdDORgygZuWjtK7rX1ZtWC43KKaJy0WwH2ess24OUjRtl2oreS/S8ByUXZBOPOPSzpBc2yBZ2sLq+Wak0IK1erWEacU8LVjdFiDUdyWGdtQCkH/d6E9T4VtVd30vTsIqr6a9Bocb8QqXcFueRuHtdV/osYo5rS+dnIYJ0DLdu0osB9tHNen29Dtn0Bz7/ZYsxouvYk79AcstvSmT2FqPF3+ghUEtVYzV3kBpamKTe8pXw9lDMRVdcAN4tzRHWRbamh8LAx1JeoH+iMFVKyycrEh8mYMk7lCxMFYeErn9DodRLnIOlyfwE+Icu1e0nqaFdbYatiNk3OajJNBoWhyAkowE3NKtEkiBFzSoWdmzMBKncQcIAYRw+zSp6CoxIgoIBAeYYKgIkcUTB19SbKhLnTQZb0mANmaD3ihkenumylEWaTTdjFpBxF4xnlAfO/qzywPpFebrNrRuNP4C6CrNqqKtMSOBsIxLE13PxLQUYPmCQ28Am4c/OzX+u17Y2tw3KLgUotqWlqkISsl7GgRkLNtR9Tl+FcuUqY8sG3gzBMkB1EYYYcp2xbDGD3S1UeD/f5cTrfJwNcfnzgZTlA2nzNxNWVKGClPLSq48i+jkIe1FR2fow81sU+IQUI26yUqyO0twlMgohUfIiXtM111sef8fMkFarRyyfjHHCh1nln3tFthJPnVO8q6f9DWQUSrShjjeCwwHHv8mI68sjNSAuQA0UixQ95NXj7Wywduq8HbSIueamOkgEQsjclQ16Q3CFDVD12QMkjUPjd3s1Dz3Sg1pTQ0Kamc/IYUBmhLYfHJaU1gB5Ua5+fZ0SV16iwYlG7cIoGAzcsIwEuOeBOGpmGcxLkIkggxklpDuLksRkGFAOxIk55biwgcMikEKV81+EmNQqtBhN+33vMdvuUtgTZW5lBOPLuErWRVrmOc6D48UrqrzbCx58BFCUnarpHBlUfE1WAOdZ4nDNRr3KVXdDKghIcjEVApKjETuVU3SVysp+r2yyyuaKdDtTl0AiV0s2MeCv3vMQ9DIIer+JoMcmiLPv7NKg6awYDjzQCnmbNV2U0JBUTkjQ6YJClC6CuuGW/eChaGD/0R1SV/9j5zABkaE2UUyuC7Q0utDWT1WS6mgEz/fRnIY15VdRPJ8PMhPNO1tEAkCE7aPFUHRCuTwcwQM7ofiZ5aEJpYnZ3pOyG/KalNexLOPInabCkr49FI9QqZM+F8LHQln4RBjTRIdPiXBJY1LeoialonLD/I6xJkz8J2XWnHs3dAautjAVAWWo7Daw5gEAtSDSNJ/bvGWaUtkamhVWUhdhilpxMgXwok6usiu/fqVlvpcv5w8ohZBqijLDP9fSrk4Y+PXLVdOv4xuWtXfvKraZRqoYSCuzWTNVyL6NSVLWfEPugnp55tCCuPiIHuQVbokbCiNvYt3SWbymvicZH2+nozuUWLJWufeJpY7ZNaUUbhOVlVDvNrFcRWQoJVMWvpjluZLta0w5jFSEvoD89F41uPFU1dDGUjtB7IzQ7qNLl02LzzOcvdlvH33ebx+fHImsDzTn1cfTQ6ySzfl4etJJp3F0iJdPx+WxxDGauEvcVIpz7HSycW7RrAjFczEkiSRcmSJ0LYWriSiRtBZJqYIOSlVxoKIo9j9z7AAzrcklxYIxS5b66Ggmx2JAOimjoqXcp7AOrbHVxrd4aUwN65v13foa4+PFny0vtg6sUWx9om+IKyop7xZz5ejEabXy1vNreCQZG1AZpvLnrKBqpVzgJE+rFF3PKrCzZthex7hM8QHxOAhWglEPryaS0+OBnZJZIxfaNqxBS+i8g9ln1J8wBNyBHXnQATv08I1X+O3ib3Ek/zo53mGrkfRFCX8iN8cK4SvVerGHSCTWhb2gUrKvWPf2nSm1dkEh3HEuKpGaMGskZIYs+56/ICaSDaM7D4FkX7UO55VTt1WrMxem2FWtsX1nte1768S+oIFwBMVIdVL64a9fxU+xrS0ldA8rtudqK5+SKCoqBNXGgmxlTkeSTdlys9YUqSIW5kuAeaJ40HN/SdLJlzQpAURLwunlg3DIWQHX0nFfcHZre0O72hiy31O71sB3HPgzDWOYtjZ0oosrpYOLBva8Zq/lCvvEKcDs3UAyyHmh7TdCG9+G8MzQCnaXJVivlaZXKPjFPr0e3Vjf4M/wxvoOf6Y31ngXfdHG6J/QbgXws20HhtXd/QI/u/YXoMnWd/jZsb+DZhWdOqfFb0hKE3tiflsNoVt9M0Slyw4A4x7ac3cre8VDe7LWB/IstktjIqbBznAIvT+BeZ4pOzG1i7CNaUx0xjb5twtcswOQD3a70P6B3TWAybQ68Bt4TQffk94dwwewnDHQUdxqo5Yb220DuZIXm4erJ9Zn+7N5MlPkMXlfwZHKpO5+jY3kXT6pNKRb2sFOpbVcCUBSElKtz+IEIrUjf41Jn1365wC6sPYZusvfltDs3yAjkP8DDeYtGLZlTWhAnPdB6CqHYLhtzdmyMJvtWnxP4tFzeBOprYalarev7OKWd1LXkI2mfPmpQGCPzbI0L8N9XDT802a8NLdJyQrqp1m1wudwIw338ObuWEFehUV8ys+rOIcxBTY7U/SBz7V84pcFP4d2KPEr5EtD4FED4FcD9rsH/KpH+NWLJEbdBe7hodHfK47syAwws2o08LcPLDC8vri5HtxYo6XZU6RhTy8od3EMrrlzyVzhEBE9FSL/knaBhTn0V+/GQJ4+SuiPKxW7whogKFKhNDYeRC55NhEut29NbHEKl1g9YRPwUhtwR03hdkrrkI5CxxDh5xK6bY613Xn58pD9aqnD0TTSnRzfWC8yHXv5UoOybU/IbrAIy67dNQtWwSQIj9kxX3u+dAEc/s7OPxxxyM0E4O8nZBtNMZ28MThpHUq/78QuqxmCvO5q+2rbh9cnN2i4zLCgO8hALE/MKuv9bBGNSHaESejdO7FL+AHFLWvpI8lSnWHGS0s9WEjypRsDSSJobbqZIUIn8ZcUvFNS7lkFUipS3JWJ32Kqq5pD1gSW3P2llLakOOqMGWMspC00uiqGd7XITJ+cY259T1iS1B5javmtyQVmusRc+6zgl2spq2xCST+1e3KrsldpqEm7tm7B7FXRLaVqwv9Te/3qzraxJpJTnJPcRRMKMhE1GCFarlYeWOaIJ2sJoI4yoMWYhZf9MBjnH//op9AQh3JiJGWQcbAYoDxPJCRSSgGbP7x8s8AAvdLdjLzNxl1is1HEO6W+lTIWQCu1W88vFgqAdWy76tYzi8Onn88CP/9gyzBmXfQ8LXrGHwYrr20mQKYXJ01WFgjRNrLrgyTLtmsmdezHkrMAE5bxH0VebuKFyyyZEcOUlzjKkjC3WTPIAu2zN9cAQj1h07sYyEBUkma30Iq5srAs63Kqipr+HxNq58imPtEzfdQzR4o8ijrziOjMVaIzj4hsWmvI4ZJ7VBR1bB/kUGdpidPXSJyqZEkc0SyHSZa9G9SRyd8p+zu4IfHPHHHVT0M1mRMPls6KMluaMBwSCsF159pvL85Oyzw7WTl4I+qFq1e00MKQK3RmraxlrycbWt0y/kmb390y/twjiMC8Fem30agALyJ20L2ibGjXerm8gpUaR0VWwZAt83jrWP3kZziNhWCp8wyBaiy0a/+G+V+QmAfk5rXcssq6mx6P+RNmhdS+5/cSiY2GkxQArj26Kl+ERjfwY8+fuuyhUDp94ZwVhpfizXSxxLSJRZpZEwZsaX4ra93MmCqwoNipRGpiFKH9p54rqaDP6ZOXlDw7a3rZUyZPf8oEybqTDkzXnXNgunrK8S9tC8/EnrxF/uhk1OUjksT5PCJxUyX/c/YtaBJZZ+TGCtnSgZWS0Jnf6z2qCbE3FgncB5rhNUt9a6RZcVyD6Lop7Lw0+qWq9TCLMIJzd+VEgktWiLJXMhdPcV9U8mfzYan5rbBpBHZ87aPb58fyK1hLNLZsEXaISDh5+sDyxT3rEVnzTx76e+MNMH6q7JNHTLrAKpTtO+XwbU0ToVR0CM+OhB9tkqwMg+qPxScq7VsppiudwSZNlwxTp7j5NflTCxyRphGquOC95TQLwY67LCREMrHJtBppzMngRkYGcZKeOFozvLOpiDZPRY82qujHSVemud35Sd7FUkBhlxybOzR7ttI6Zg4VPZX3AnLK6i4sbgSKHpE7qLvCv/nly6CFQjgQXh7ERJOxghY1plWTJ9BlwHawNGKwsSQoQPdprSFsEeW0dmGlh8Z2QOUjrrdTItNMd9FYBh8OG3sUFqaS8RI7mJqOmM7WFJdT3sRk2rWne39rMkbpbqaOvWLhs51pOrVyMAmvZjdiyWVVN9eEWwSMJPlFMTJ2kLGm9hijn/i7Ozskc2cHpbzZzHqTy+MxGoQmhkVIA6ZKnDMxiiSODqD1eiDBkLu2IhEw70ED2sTk1tjXW9fpyreS3Psr2AFK/IoQxuU/FjerHtKpeL1KumzK5a3u0LV/fnUfJx5zsKlYxObWSIUEAcpH8akbBHdur/FzNksd5Et70+00ekqYIdA0KNQfpjAcIGedg9ruReSqJrlBakhoIum33b6oSh4aSF+pggE8ZAGI5ctskHwSncM3tJXcmoLUCblBh2Fvk1MdeWa8svypmSWvLH1pJswrS1+ZuRO5wp7BZtEr0x/qZHr0LjJ7brxUbbAEKXiqCE56dQ5SWVrJZ/FLWIgCzASNmR3/63Z+lWhiHdG4chsKqPmxgvmKmGmDGqQEECmPl3+XDHu6uDQjiRY2pzwh87JE5eR4RGJfodsHihwm5Cg1kIQ35rOsMbPxrFTprBlTkIO4xEvIIHOFl6QmndOXena/GFg+wsmiK2rogmXJpfO89eSlSsMchx6a92BOcFEWk/jZygJmZorsElaCQ6UWd6VJLyIXXh93ViArKseP8R6uc25DpMu+KZEtLK82veBdVGjTii3CRCpGOR66fpG5Dtu75CxIjaLwU8tp2O4yy+/fgopUpXxU/Hk86QIuHmqF5NGVExam4L/+7f/8F9EoiWPQQuBJtAQ0bLKACXJSZNaMpsIwhf4f8Ij674lcTsMnnPiHoMfCjlxMRliz6eHG75ehiXHRKEeTEegI//VvgDgaPNQH8UZcx8Zn8WShQhrLIgjv18MbbhsZynswGTsoWywcP+LNagyy4YmwGpCxwmPWk0j5M+2QzXhwnYEXxYRyRdOxNMpiboFXUu/1PcGb00TfKKa2IW3DBo81wJeiFCVL3hZj3bYoGM4R2UAyvtgklbnsR93Qu01FSuMLoZnLjnmcKDublWWWSWGzsFKU1iMvYBaMgmFkt1EoDqVnmR1O2MoSE6BHTKkG/wzJJxpZeIwu+I13CH07KieHTNbc8C8VKzBsTQ8pTMeOaNWmI0JdObZrpEWga+fGvlZCyqCym3T+xnJNc8YN2Ek/gTXJk57l6hKpv0Y66d4xZ3RT4XF9B/jFIdYG0drrkXc9ZYgo14EenvCWJvcFAY4hH2EI4Ya84UKUMRxl1/AghZ4JCq9RRZpyyzR3kVAlys2XrUSxeSJWulBa0hL59Bsf4cB4+iEyh0i+S64QHukCKVJ+ckej4OEcNJbIaMJYVeTQNC+oysvHhxjf+RAZmvWh67mQTBcOUUhit83rHr33RuOrJL3kAa9cVMEkgM3kSUxf2yKPgkUqOj1Q3GIQ33v0BceAX9+ReTahxUzkFC1hkJNiz+KbDI01lRyUiHVlCNqUlxoak21hcVNy8F0LX4xqKsv26TDS17sxchN3D5knRVMeGgYTsr6K+Wu1oq45oTPZP2kgn1SArZ88sLwmHkoyALFpqiFVpHPyXBaZgsEiqtip44RkdDwc0iayKPauSUFpSo4hk4oHpGBDTjZfUNYhx8pRojNlYGZ4CSEON4ntRfj8Plli+y7wdxsnn8cF4hhzuCrmv4U18zcVjpkemg9eFGEhlKo3u4Ud3EFKJREJijiCxsHHyUTEuUsi21keOqZrR1WN6PUHprA6ZwpFcKG5I8F7REZjL3/yGLS8mWukGsf4g1AVpZQ4x7cDL6nsZZNgaDmwbz8Cv4b7GN0wkRjQPFH2Ivb6hCGITkxcuoxr8IMcPrm7lT2cvwbRBZTDIGqh9po+SKbRtX+TjJmECZquQyM5GOQsmAcvgXEMbr+53bjAG8YrMz9natw613BBXonOHnxQHoGK4qeijwa+/GZByHEhE18BMtPNC26RQiaWkdENDa/YnNOB1OF2JDa/TA8iGGsM7hHdMHZL+y/1PaLiXJytiR692tQXKaQxwtyvX/hHzKexF2IEVe2woWcFVmnMLeIZYkhT8cLESRgT5FjosP3zEyTsJKheemvYzRXjuOhKnqF2ixmhLZlcOTSSdGZMflJ1zus/FfU7EPpHztjLdag7ryEiCB5vcumrND22b6MbHNvB+dWRtjtygdHhLJl2Ya//APq36+NR7cf2CT7rHvgudC6vnsGfgc8ID7nKusuVdRIuUxvjMGzi25TKRRmdXGxoBONQFoxRSSWN6Mc75x6ODAJGWyVTGZZBJEU2MkpwYZUS5ToYojSNUgQKBp+gSCdiwWahTZeKp+ZFrpGeMiZFpqhN6Vhz/sDaOU5JvpEnNkmj7ht0ISaRGBJ5zJLowf6LfxGjNyOmlb7jjdyetdINpqMeCcRKwK7Awl15++XsdIWiiEEjVrjqym2YlAH8rSaIA+ucNpqsjWQwxdRqEjXLcPEAzps4IzV1y6mfGt1Oh2xWzWPai64wM1JSQw8IPX9zZi/mz6zg8ZyZM4spE8wVY2rC5xewFyGsK0yKiTbMhJ5kWbHokyUlG8qt7rS5IJYnz3rg7qBY4Vw5c0kZfNQDGXaxg9gpkeexBtngw4rH46//j7pvf2sbSRb9/fwVRt9d1oqFsXlkMjaCS4AknPBa20w2w+VjjC3b2hjJK8kJJPh/v1X97lbLNiQz2d3vnAyWulvV1dXVVdX1iOkK0vS73mlQfDNmRpRwNQmLfQsDFuVD4l5hEvZQzhAuBkyN5wUjbzih80qR5KLvBjPhI23yC5TW+elNdHsDnDPwWYW2mzcn++JZV2mXYVzuTRp+Dfyx0lR5rF7xY8lO8gPHuYkHqT/kjg/Igy7ogaB4P/hbHlbXjfyXXuzXX3pdeDD2f31ZeeWN8D+bG94U/7v1yhvif6EJDbkou/4ula8yEgSG+Yz6FcyB9EpQVL/ib3hhNvMmc5vTvzdoxhz6A9P0bGypA22RgXo+9KcDvfb7lTAjolnz9W5/dTW4ek2qrtaa7uu1NVolNTOM1UTNod75fe+1q34gzLxxRpJb98pb7orvvP54JiJUiQiJIx74AxLU2Ctj+Z4W++8x/vcVxgTAfzfI0cddJHb9jdrj47H89erx8ZP8tZH7QhvQ+9nHqvc171/w/xh+izetGIHbTL+ESOsHQOtdZMANlGMzoIy2PwG4PpB/27vx4+OHFaExrI21j9Ckp6R/yvqP8BsEdG8lBM3xlDrcIvGicAT0czvGyC8Mp8P5G19z9c+Nij4XNeBb0yYnA3UtgBZeuk1YhvrLJl1duXCj4J5cNGQYVsfKPzSBBfOKIspAQyap/Zbl+0MPpQQHWaTXK/5vGYf2Xprmj6PPyB2VyOO77hDQFQ6jLpZj9uDNmMQj9+IkmU5A1/DuyclyEnwOxrCucMQp4436Sen0cLsBDP01thQvbh8i/gIDVo03uL3xFccsXvcjSgHy5derjfutUrkGomJ//E7W7V/K6n3e7VrWjJ0WDTV5Lf8bFuEUOQkPFr/JRLx4AKTqqlzHACsT+XL59mLXZAFbMzi34dz6jTLNMkm4KK3ha45MaE2cJND6yEsChzRZFfsdaDdRaEdHK7e4L8rcXek76u6p6wXHY+8T6HHDN2Ew7jdKsBh4YVdxSuhFgQYDD6PKVmr6fbH9plhcs9KzI3fJSh8bl7EFV7FKwmNVoLIkpCGvC5rvo5+z7CMxonVWi+WKM8wWtcHfiSt2ebyZzZVXAjZ58JmtlVfq2PLssw0v36pfKO6jvxVXVMhYLMmCZE3nbJTDBTwDmePNXJlDeF1SwUJJaZxlIOqkft6XRV8WIp6onjfEkegG69bnn/aK04/ADwAsAK0mkOl34TTtBdInRXMaMkQhDZ7QnEWiDUhrXQufW+X+SEa42iYUCGd0GYNxE6KPfkSzjaGrciaTHtLkYzK1Gf9gzXP4FmBXWSXibRhgIglubMrPyneo/iEKtahvJUt6iGGJJ9NeUO3Fd45LaqvnYah7ziELDYEhxdHimBkI6J3EAyzL3U0Qfa7yeBI8ccp5MJSVcvklrvndk6d+c8732AEb+uzMuVBsDBpcgUoB1Kk81E3BqpPOeebx6iNc6aH0BjwXjllUk/pBRvLnO945V921iW57zgHy7VI4KFHtDHtiqrVu/wENd7egReHMgsTh9hxmRH2Sx0DFqfI7M5wVxSPAkp6TUincQjanGos6mls1HZP0Mg/rtw/0cFmHz3V3aUpmceBhqfsG/7lWd3mJdGhTwRrpVAomPAUaxHglmIfq3fS2PHblRaGmRMu6BdAsFZbQGMTseCfiduu4UkErEUNGdBUT58nXAuGg2LliTtr0d9GFFhYCuvBLLlJfRiu4kF/stfry9OJ6P4LehMKZCHPGJWEl2nw8kxN65Qjv63e/WQi2Uo5evKpVtmvuer1WQ9/O2J1xr5HIkqpRmX1UvYO/QCq1ze69fO29J6WKhK2ERoLAWroWVlGzMUrohdTeL6XTHjLhASzMg8OCCfODvIIxPiCe0ICRjQLu2pLFaNlArsvIcp6t5mWwRW9Y2ebqgdySMOtZcyW/5VZX51ism26O17XHQTApb6OPdO4dXVVKHCdhigPkPyg9Cugy68U+NIT8CoypRQ5b5MEMG7yfwwHAWgjZTXc8brM3+1H/DbDg1PiQ0r77OejEb0DUGGGSVv6YpWnQxUNfRsHnRMe9AkJo0+V2WLxTbvtdRl0Q53FdGaXI46WoC9tx/ZAavpIAWTLRoWCnIVFx/UKEa9Dzn8jjHPAbEb9Cchyze8u1LaN0F7DCKsjteRWeW/Hv7SceSbajnW0gtoVc6VhJHx/TqiH1C3YsFDXQhvfwg41Un8iBOpGje7NkHwhweCkfG/dZQgoJ5gkdxCZGXYAsE9TECGeUZZPG+vqXL1+q2kDrb1rr8J+7OFpnXpQc2JMw+lSdjCZ7XHCtZN49us0pJlvd1tJ1MfPIuAobBhMhjatcTaD8rSv4m6J4UeMo5RUwaVCmFR08wjKQxMpbwojqUg56x+sSPZwzwe8eDssBOo48GTlm38B7gyTRMKp6Lr5y8Zq1uyJdVrrVudoYBshUNe1C7IYQ82iGO9Fe2nCcuSSlCMeaAzUAbCc9dOnThkPlezzGk/uEntxCHtIEb17CVRcPSK5y6QUBMkIis0UlPCiRRwKhZ0ROTDBus0VII15qhywGCO+RBW4WgC+hVpFRPMvyvWtROhQvAC3m266WLACpbBtrHuDLrpAdyuVWdA5RGbSkDD2X9p6Q82HXcAXXUJ+LY7IMfEqFnaLxUZlkvYgEwgQ3mfdBZNUuSlponMFK9eJg138J+qH0zsRaKg65GGnIdJUy6aNNzxW9X3rB2ktX5qY0lXZNsS9CWN3NYWzmnc8vcateip1XT87fHh/sn5ztnx7xcFJezEd3q4O2+4e/HbU6x+2jQ2h3abYn+Vy5HzJ3xtEqO6FQd5R3STPtI4OplpIVS4SKXxZweT7RAuhEutGC0r7SOUvxmxWmj+dEL/VlkhxZ0HcKs0RLUw4hepgTEA13MQr7cAR4oy/kv7OFSP7zwml44vIWaNcgFD+ofJYLItqNZD75TjNvDZDjydQCgqmt1GaySsZ+ljECZnciGb0TcRTEOY18BIpCaoFXJ/cSjkL8RhfNyZU3N/aA0cXcIdCNn1U1hXONtQggSyIkA9qdYm0pl5V54ZUv3u9ad3lDuKNot+B8uVMDcDPfP5c7yblwojXcKwe+KHOrsS4YlCymtgywsDzPAiW7+yoD8Wa/9fby9Ois44lrGqyWV2oQiTTXSj2GjKX5WXgv4EkS9wacOv7NSeRrLixAs0m+gGp++KMVLFdKUw58Xr0hLUBaprq4yiZJgmZRwgEtTufle3wMvfb7/U6c74KL7AW2jysijaVmgwmH2loZP8CrI1m0gYKE4xWDFJArpFD4V9D4mt9U/prDCw+tociGoal0oXUidgSSagPLqC/Zsu7O5e8iqEejQ9UmIpI2mQTFYl9U8gijz/EnHRT0sPQ4z7I2UF0IrUDmvTWK29JZC7YfLBE1pY3TIJRssNq7qYFfu/Rt21hO+/gEGIjDN980+p7BxDDIKHAjhrfTTK2LLreZAxNen5uWDm27FaxcokW188RTQS7SVsTq5c9t6wysx7qay0oPjzUq0xiAi7x8xWn4tJxDybtgPFHDbmszDKkXZKK7CClxECRKW6MmRaRT5DiXFsdSvJ3uq+3Lg4OjdjtnLAos9nKzPqz5oSp3LxQrShkEMQidVwv4nLxsUPlxkuYnfl8tKHsrGZmUrYq/rSh92nc0dZLr+ct/cbnZKpMs5uWazGp69NPymdYx1NoWpftcR+3jyjnArYqqy6feTf3igTRJZzx2lrjz3mOWCOzcCjBQMj6kkkBq6vHF3B+h55uFyd7z2lqHxUjMfiuYxEm25ODzerANqsRlCr6PmtiK9OUoGduh4pTVdIkVxxWhz9iz+d172eq9iAo53YU8ETQ23lsM2zRi3+47jaVmwj5TlOF0AZr+VBSUrWKB9z2f8vRvuMt4iZ5b0lhhVpQc4rR8qmoYnQ1z5HHzh58Efw3a9KkswF4+2ZfLj6Yq97ZXPaSqCi/mdiVMRGMvNvKz8PxzUKAQWxIGUX/8oCrgtuA/pdlfsRef8cnn7ck3reOjs8OTj6r2n9uVPAkkC19bWdEcub+pv5Z0wg80K5c6gG7304amd6YiJyQ1BWotpHlMtQ9qTdBmZkQsqpPR6yESTTnU/NZJasRcsRkhrM5mfFlvCO4U46pcb5q4A1N2ZKyoIUoUbpXl0FSf48WMO0N5Xo4ncvax/LJ0uAS6BawEIfrW8+G050IaF+SA90tC8B4y40BmS9ryJxpDiJBY1jywyCevsmvfUkVdqQ10FqM/wqjU5apUiTpowroOhDpPxDJPH1ed85vwPugvM3EzV81/9gSRjEFS604CY270IVJOEkzG3V5QXr+qXK8PPedvG68d5enfNmr4tKI/q+OzFf3ZFj77P/qzX/DZ3/Vnr/BZWX/2Kz5z9WdXvQMCkGc8Hrwhj9e1x5tX3X3yuGE8vn1NHjeNx2yQPe3xNm99ZTzuH5LH10J1FzY0zhADi5sSW8JxgB4SbHmpoQLvoWEE4hijrSpdRuZXZwlLzLBQiGBQysoGeGuMtoCwApPCf0EkTSrOatVpWumYpRC3knjh1vbmx1oZ43DnnpxfDVKtHitpO868VJyhUXFAkvLKi+SxFqkBSTxVtpqRWw0mZ0cNTW5Oc8Ewr0j1sObWC9ditiAmz3+4ik+85rjLFnRezCgQCYlu5USA8aLczFk8e+WVF8rZg+jWULMxmfM/n2bng9fd6L8CEfU/ARHTCaLhQ5iNLhRXZBkLZWIjYdhInoqNBLHBvEBZnDTd4mxKsRIlaDuZvVgGDurvxUW3F8+Yz9DFeRsQR+dWHWV3Y3Qikl4XjDXlvIkeH9EHJs26UQ/f0EuDvaAo6BU2lNaerK0w9SvLHbia+VFZYxJxB43fc1OLJyoOs6Whbik8bl+ll4Kl07D6dEIh3eeQys+BRryc4SdVcVJNUSLJNPRNrY1TJxUQI383spApfYmBeaSP8S1YxS9scLGxuXCKr9QdY3FxDvFkIkF/otNMpCjIZdrMPaGwpZj/jVaPF6V1PgUPKi4Wx7lnMsqPbYLwKrheUYWvPXwisnbwL6X8Go1LT0t9a2YpBCTY7VIjGE5ULF8FdX0q2JxGrDQ6Vrly2qHQ/Alc6J3/ZBR6mICEJsZzHh3ppZX6tWa6wys0NFPu4xX5mLCCElCIOUdCXVTSmcbM4glQPL1QqztPJ5VbrEwWjdhznMbya6eOGkZZwZC1J4xoZtxXdnLVZpOpgDhbUWrRKK4jqITmC5iLd/ZdqdUkYHkZWLWt+pZNdr2v/nbUamM6+tPj9ul+5+CdWov1y51Ri5VpIeLOhMYwfQ7YhZ6SbsYGM+aFYFyXeHlLTOnZq3QHGnGPxVVrI5fJ0TKZTLTow+zZEqtwSnp6jL0iB/hxosXQC9vLwvQgK3CMGgLEHE+fWV6WKGh9KpzmdOn5e/Ck2OUKj0fllRfI4zEoyjbAMIV+EjK3gBox8K1gfQlYcGDNNehpa4SWPItpKpfgw06Jz9C9XD4ffqQr9XPJaa5abJ8dxqRaP8lSBTBt1Zq6U1O8CZ5lAQ9yaPQDflHKFYTMasENMehp8dSkA2boKnPTKGUpsw0F7zsnS2dmTNMzp+h959wW9mTZHW/iwQ2/u1Lus27U+yxXtY4LarNJlZYrm0NyMThBp9Kn33nhIPSCQCe5gpR8T7p2MM3wmR/y5ZjJm2Xls7ggWWOcqIX7mJdmrngfe644Z4mmIg2vcPHMZrPmud1VtXle7KfaLHMcl2/db7fiKuTwqH3QOr7onLcUn9Zba8UY79ZaMAYfWy4B/H/M3PL542P5HI5Z2JpYROaUOg+XgLpATE9L53k34nSKZnD8s5nPjXpavWidH14edCwexVoGqNNq+6h1DPi5PH191DJayjSqYjw5H70Nzw8lGraOTo722+a3zXRSsJ+OW6eIP3v7CUawpICDjEdp4RdQVmp3js467aNO5/jsbdvoNZ7ehVGcAm+B1ieXp8dn5+3jzkejFUsydFp9fbR/ICsBcU/hCV7Pw9vLi85xDofT9PZgmmBgH7Zovz64bLUAHqMVDbciBwuahKBp6+j1+Xnn4PzyrHN4/iH3zRRd3xIy5FHrt/3WPN9uyoSMMge26gcwycHBqBsNA9tbigXLGwsBcSduG8nwdzk68YNAe2MstHhdQAhi3Pyin5zvHx4dcgd2S4P2/m/wvl74/vT88PjNMTTZKGzCoeBhBHlqEhNgZHT+5g0HiT854zDolCYG1UnM/xcbME9X4lsFdOQfia4a/Yjnqsc9JSCnqfJ8IoskvNKEkAuIIBViOQx+LCZMhkjnWSSaqVFWwzci+bhlRA85YKetdrFol6P+PG973cOHxltShOWde5Qs68bFNhXtTDEr2GVlRSU6AymSFcawS/mMF0XIRVZfkRurax5QHRNVjauL3MmW5AegHVoin9mKWsiUTOTxcUXFOpxPOXH+TX4kLdT8T5DK7QmSc8AL9W8vq1ryKjfOM2O8474l8605WrAX5DPiohlLH6sgo/Ci0Vi3/HhzcisvGlPpmh9Xzy689JisW368ogTCiwbk/eSIBfEaliFlhjp+oZu7NZtzhy7k5KpZIqaZ17yHtrCJnBfmqTXKI1gQz8E+RGS6ar4RT8Fqw2bIpx/mlGKaXGcw7mYgQf1vGkdtIkFa4kqfbyf9xq5tZDZ5o44l2kb1XMYpv6nBuFJcwdgXxV6owThWcgprw3X9hLhiR+TiNW6GvALg7OkWTbVS8C3lYlrwqjWgapqMlTZNNR3O1XVTVm4FXDmOEVpbmORDC7kdlMPidCCAsHz6kkym4+Lh8CT3fTB3HJb8g9SQBV4f6rMg1mfCxV8/fOzfY+53XOgV7STWu+ipsWWGcvr5fvA5dc0Htukoqrcym9XVaMVPZF1e11ZpV6Ta+J5ldBxlGY3Q6oUrqIRcF+M+yU+aauN8GVM58XT+MiZqDhdRC9jhQl1uDUVEj7aOaK8PVf1bw44m0chLsMzn5Vzmxhyiy5240BK4XULK4aeEiiZ5QtDile0snkBH4NxaLLRmxzCPC8YvXXFrWFjYx1Sq3CWCIRUl3AhT1EqX8MhGFVdGe710Cu8gVHL76FjxxGjKVG17e66Hi06Ggm70MtV3+a2cnm5+L6/Iy2hQoa6bwaBSjxeNqb5qNOTVTngjqrwbjZhGLxsJHd5sKJV70dhQ5Y0epqKvfINo9LkPUD1fiVSlJ3+evvTQe6XGHA+kL7qFIZVSiYNJbhdgNJq6BcQ+06rYyVRbT3LAk6ZxiwFhZoT9a5V7FoQ7/eC56grod0/WZhIxZ6uXPcqvLHEP/xPXFcf/Uasq7TsFa4qFlvJTlOkzFwcCP9sFtMgGKeN9dWhkuK81ldPPiFkutIvKORhw6pPIs9ufNY9im5qyHDlo9Qhsy2yeHIRtOaF09ioPm5+FqrxtUckOIKAzkgNIqJ+MEuXc1VFxy+uJLmJG81TrpzIpXsT0uzmUbmQ12RMvrKvgkE33yfhjooiOOypl/CwS0i3JknwoVDqPkGLOT4M2Z+BWIBbQ6VAbotbPAr3AAC/hN+DUd605iSeTnimOGjRI5cuft6za5YO6pgQuHRcc2CfjgMvWRjoNaqVX4vy9RKq9Gfr1K9Z4fpHgoWWDp9P/hVx2ZMo9g2dLxcHuT9Ct1kzEcVq+x8dG1gvRIZ+GI+dRIJRYTGEt/DhBY0i1sDsBYKqUA/iFeFAHKvwLUnhwyJJ8Ao9TTMdYOJXkPz99B7sn/U9O3kFBXCZ1ByfuH5G4g1QUUu3OBUA3LcmUFMVtP+q3gs9hGqoSg8yukTMPaWqsnhbbpih4wW59j+xGIK/P1ZJToWyhiikkD0bd5CDuB+WXW1hTEPc3p0UtWWtBzhCLXClCVuFjQAS4XZ48Rk2OgVzaniTQfgywjqxW9Bsj7fGy46xlboGZTEvUoHHVeeY0Y3sb1a8Nrj3XGkjCVvbOs0bZVjN7DkDobMg2iAxiYNdEAhjzBli+MmYArG8QDnWnCNXvWONQp9U59786i1rcVPAoi1dGZrIPK5iq421ujAIekm/I6taKhG8LGUjPAksD/UvNBEAcx681x5K/GLuGV0sOs3ngBFL1rgUIvTX6P5kf6wNYMykxJlBABLY9PE/XdTYceTz1zGyjFmEj2Ev8mN6ed7M4LJvZkUwzidvAyqXhgv2fyoS+esrTkPite6kUblhGT5fYgYxIz9QVPuys9JmWZ1dMR0p+88FKzPdKXnBSPlAEIgjfBZHzWKblho6WdONJUYQXm+GC/i4J4XqjXsx6BFmSMesosJ8TFjStaPkZtBnLczxfts3rewP/6tqb4H0fuQiyJsVyRAFRvKEU+JMlZPv+372SAxJo0k2dxtXfYcDCDFxp2ekEd0DXpBoUQapyvdrDHTVxn0Stu78Gm7CWY578a3LVu64462kQpdRlyPHiouS01vmOYaXwJttpHbVvzjoHzuMj/3VyfHa033JQxuz6+CFR+7nukZ9McK/XsRYFvVbr+k4d5jksQC5BG0Hv3qQ7DHyn0oXGosItyX+dVP7+zRmEfafh/J3O7+8OYJysSePvlYLJDd3KH7P/+cPr+/0KFkPHwHBavAuf/HHt/Y+DKc1xyf5QT+xRNxUewqwFNwLZp0Da0Cl0/X6YrA581LTypBI0B0r5Uz3SK7CRwsBNLR0wkG0AWPCciHhuiGtWRBfoTw4ROaYTZLiUcAGLUzvwttjwFAhgZCMZVg5tCjuZrgn5Pi5KSlcEI23I71HlD8fE/Uwqr3Y28vdvJaThOUuauZV+xbmeOVJVw1l0RkFyF2KdhCOkJvXmFLa3tu8JfhO+V1A1JuuGmeu7Ud//3fGsaEo0zxUzSK8o7hWT3NcAlfz+vzmu1HdGTTfyw6vxNewQ+E+lfu3ZFpmFpUUu3722t11CNAVzuXNgWTAgLC6c09gfVzaaonKCtGWQXZmzUSM26dEaPBUZGKph1AHXr7WVCEOs9u2R/a5lLzAnTwJF5w7BmHbB3k7ydiGTkJKidIipjJFU0WYtwqHYbzglUl+hmjo7M8iS7ATtwHYL8kUqx11G2Fs0Z1R2SsEOVniGMaKx+HYMRK6GWBOSxF3MUmmFIaApdho3l+WxtPwCsWYVrb/nJPgRzsds9AMcdwTMMv7k2CIZsQYE+Qwru+t477EoRTFm2bRgTxVtjVRugQFugbE7LRpvfDWQ7H1YPAdgxQvGICzZ9fpzxxjiWY3loSr1Rj5avTw0twE9CMjG7stiE11/PkHEWIzCwDFxYS71pwmtMjbG4kH4TUR3g8fHqOSjmUMRnRrFGO6xwLRrzXAnaDLvPkvL4z4yksT3MxnUGfphhTs0rNSteebMfc1dxpaDxgoJcW9lsOwx97AigN2GfTbCTZaNI/zMCgdCqGC20gvN6mlpZjla6I7J9bPuOLzl9TiVMYDeap6zt9lQbNgeC6GST0rwpAaN6g3io/X4SPo5e/CbhyFvwMNcFFatsaF+vw3/6pk9cZwhG2/YnaYp+/sDjB1skq8dOHsB/agqjQfuzqu9+stGvVYjre5Yx34whK61Rl397vlgALvAmPbfSq13rNPdbTdhf47vHYB6c+OXl7+oI4AEh8Y7o9iPqsUg+xziP338h6ozXs/reAdYYBU5aqrSibEeXlT4MkDBw3xJMYmQeN3cSzbdEFlgDIy360U7m0R+9zf2ytP5seXe9Kp27fv1zZcvV1enV1iNub6xXavtwTlZh4/VgOJjH1/AD2wLWwAGrhNrt2WZdus1l1SzqwGF9/khWvOwYGW6s0n4QQqAkT/mwpbNgW0MsI0IbGMK24jC5k1FneZN7LJxvVtzkT10/M3KxosyPvkbQOh1dnlLALbj8x+u1/M3m72dTtPt0/07BXkfn/aAMRF7N4W/7n4jNUBoegVPSa9wjCfM0J3S7ipyhlfH11QPKrNthTAzhIHAqkBfQ+BrEvg6Bb62EPj6fOBTan84UOwyA0T0AVH4WK8aLpzx1ymWz0yAnfbLL7e3N7fXD1zxjjxwmZzZA1bb2+EL33THwEj6AIZfxn/XRu76uEF+51c+vOuOO/FhPMWSw8oHsbmrTQM/NLDTzhs4xDJCPBNfGWMAuFsHFgOPgTRwshN/srZZ4zgbCIDZpFDPox3Id4l4Bz3Ru7qviIYZ4ae0sB5ClfnlzVplgoXN2OUjDqCjpNxbrSN/zfBOouE0yH9LDmaWrBjTfgEQECj08RAg0stzBFECdHVCLXc+/9T6BhYozPy7PDQbL+6aboxpMVo5PJIFwCTIZEXyK9Fo+QS2uNL1GBQq3C0LsARIibct4vWr9IEpvoDRN6/X+rCb3fU+7FP4E3a0MpaMyeGm2Cx5OLoPempKdizuEsKSmvZWJaMYM7ICVwe5YEYT5tQUA+19Ua1B6xi5+wolpwMX0AK7qmLqd/gfFGjgdIB/YvwHThsiqOM/ypnjDdTThpTz5rW8sfg8qTzvhZn32htn3m+Z18m8M+9t8w6QE2QLdZ8gU81AmR/AbvodS/eMSVn71/iPokTahBar/kil8VDyyrcZMsuEnAWdrFhSTq7eZte4ozuihtMA/xbyB9p9Bju1x8eJaiA0cvvx2iOKZXUcNI9xIBExMIBx/EGl7n1WHgOy1wZo7SGc4Rh1OPqXYLwxffDZ9Y59Hn64rrlmAyJ/9z+7M0JmC+2djLzeZq6VJhf3/9cCczUA4//r8fF3koeKwObcnJ3fUCfUmzfHJ52j1g2q8POWuTtP6eqayzxeuMzj/4hlHollnprLPOTLPJNH3UjwdZhdyx+hfXDit/gE+vCnrAwMsKyU+2IGBCOfoIUArO8S013da8unfYALnp/5KzXvkxooBesGD+vwanW1DS9M13vzveKvnntF/d3Nx5Z7ILNJt38XRhfdNP0CUpvlk0FS+NL0QcoPrZe9yUEXB0XzwQrSYYS1UM034WS/309sbwDdUZCddtNP+eHiaUY3sfYY62T+YwrUlj3kR0vD/Ix7o24UBeN846AHmrhlFFYSON8hHIK+Z0dLj+Jk7stW98v899PoGKk2j/MpHOVIKxZsdNMM31wgdoN+4XtGnn0L/Y6DlJBD/lUSBO1Jt5cHOIMRLzsH+SXLelaSnkbhvfUFL6iQH6kIVzih03SYHykYdx+C/kUxqpJ7+zSzgud36dD+Irk/LXqV2V4RCRH/9jqgkL3FP177Q+BZzY4o3Lm6uvK26aLu4PvRVed6dXVE/k7J3+W3yIdAEojhp/d6xcecOVi04Xf6FdT7On6HisxnyBQJWaGiSv0FL7pJ985xibj8GxEoQvLvB/yHQ/VEcH6j4PAv49A3mf+p4qzDcmfasCNtWGgFLFsOBKAM7QOp93pLD/dBG+11TnXndgYQ0XARUGT74Hr/5lcLn/jVglNpk3hV263Ra1DfNIGAS8X/dr07khnpgCbSufMPmM/W0z4wBnGO8tQ0Hk9JFuu9gJ6E/wYNfPmPu02qw+lyQeDaRwioNJAbpZk3x6uZw7w7Jmx3++QioBO/63QulnM3UmSp//vx4HUF8KHdJ+6dZSJHca5uyPySSob8pfiG8kItSspji2uGqntIAMJeHG30y/N7OLRVdRINHc3xCdjXSWwJ7ChAyRjaVrN7tP8XXhOKy8FhwTyYZVsO5hVfXFkDrK2TLYzBtsX2Fo5gi/7Vg1oLu+oBr6T61SlPyPXfXPtqYboyo/KVMeniulenPJGdreqV+lWz5lUOlsUVr8xvLTNDnNiseWpPYtQ8Lchg1Dy1pi9qnhbnLmqeFicuap7Oy1pkf8tSFtlfynxFzdP5yYqap/ZMRc1TLU2R8vOMfDSXoKh5ms9O1Dy1pyZqns7JS9Q8tSQlIrnOLp+R6wzlAv+yenl2bObcUsVnaMGgtFVKHsdfglQ0PDn/cNS2thuFw5HS8N3x23cFLQ3pXH6+tf/BDsHwTYJpPKPeAwHh7ZvW0T8uj84OPuYyiWGVMLVx6+jivNUpag+6F+wJhGD/8DcgmxykhkCHoMLr1619TFp3sd/aP81BwMUH8vH2+cklNs3llkMxqw0bHr/dPjprn7fanf3O3CrVbdJJTUqW5Suj5RtNkuCzUkJNFLIOCajiZ0zuV2SZa7yLEb/6QS+4n4if8C570H7CoYImO/EbtAn9dzAQv5GBwaNRf6yAqZIoz2VmI0r/NuO1tXOEKN7ZaE+8LKA1ZeA8eXGICqhJKepNiej09OjwGJaTo4i/AGZ0fH54s//bW57qzHgDvIhnWTPf7P/T3zQ+Y+RHKyJNCb1JjmLSFhK0JkOj5OUskeGBqCRGPD9yIxHzrynwRkFslTkpBvRg/eV2dXvzpYu3BbJItuBPuSLZknMtGkXlXsYwGmNbNI5pebBOTHC+xXOTnC9fAVzyOSX/gsYAc/kXdPaoVg5HPpivGE64o1wyU78165gb3FIBSyhVJkSCXS7ChcIzcylAJDd9Wq4IpMifE/6nH8pK7B9ApEdyqpvhZ8Fq48QNw6O5O5mMHw4kCZStJE/y3NgHpMn+cgyAFKN7oZ5Znnarlrnr+ku9KLxgAcWRk+pgL/Ce96VbWAle8hojLF750E9aJMuJqATGS/iei0uVD/4IZGosV8em9qmfhE6bECHxqUL4HIQqO5tvjZ+8uU2BqGHuRg6nPgn1HPp5lJ8X2VTSlxCa3EGB/el5IdTDWadf46D9WXgpEFfV6HsNTjP6Xp/EM6LvdWFExxGTLn4WbgwhWuKEwaXjggP7ZBxwyUqfuykp/bStX6AxKHvfgFRHS24eT8ZPTqSUiKI0yOXDH3HiKGKouV/FZ37aVjV1M3WXcuh01qvIvT8LbIveKOFW4PMyLfkEVSMtS5pPH8E0TqyhYqaPuCzf42Mj54LokE8fQV/Z0kfIAMi5CSD42EE+AcQlGa0ImOA/PwEEsxz9JyeAoCAukwCCE9jPTABhFGKWsaJK2JiaMorY1LgthxngxE9qY5OexqqlzfY0GJhPJRfZ5XESzASouiium41dnoOANa4HW3lTZz1Y23KLbKbUt77oXc2IjxG2xZqGG62b6dVP6CWc7yprHcjVDZoh858lDqXKi92aVsYLH+3chla4YcEk4IqlM39jpajK77pRfxwk2gfcnLHUUtJX+Si5b55jykVLSiBiBYuoCn1KMYREe00uwUOs4Ew8YanDwJMIEIet1HFgDE7M0PczIradGH9ikGLsx+SBNizLYayPSj3OKSgbZHPOWX3mZF+w+KGI8yhey0Vo1S3k8JNQUTPbrXEsslfqjxd1REq2RtxHQnH1vlG4FTSMU1LdyJvTn0tknKb9ek0UWqWPGvr7DfP9Wr3WCPxtoCyMPIAjYDeUTvuS3NwfwcX8TU5ECSWilBNPnloT1/IwdS3ktcBDP3Ft5LegU+py8jSOhDClB1Mr6PYfxDX7SnnFetRyrqnIUSu+ltUFw+9OYkx/oeciKEwzw0tliQQUgc1vA2ursgrxgOqKU5XfQQf+r+Qy+VB+G7EtpHaMDj/MwbXI7QI9deRX1hPYvQnWXd0Tf/l1JUMCHGFfGkaw31QkiCAwlHC4MQP6vQQvnvwp0NWeAF08sQNHVREcMejTal3L5OhQS3TmM3RQEzdJjhGyjFgYUmjJV9TJ3yZaJHQqUtlFU8sIROwMbNLpnMZCQC2+4MylqimAXhzbhUMViJOF7Z8hVFrGsqay4SdUgNrHRRxGWbqYBG6CCE86hdMrPXV6mKd2Y0inkvTAPhxBp2TJgfyzrB6Kfk0KfEsnQn2WCsoPzPPMlKR3rK7zZ6DEKVMrTXDyARB/WmLx2HdheocLWy1dEAfe0nQyTLr9oPQQT5MS6Zk8lOKkxP3QsVziWda0okUEB4SyzgM9fNxMPUnoMyyiW9QjGLiB2SMYkB5GpoC59KDkLyIhyyIEIZGJEReFHPTs+Cun4ddAoM8FrPyD1arnKwGyvlwlTinftez/yK+6ODRx/L+UCHB6uHqhxTB1i+o/q0nddDEmGuPJLAasq5SEw5GbT7egUaA1gmFTGWHNTQyW6zg1UNh+A1d006dJnqQOpRXnpq4ydzjZWJQSpsNpgpsmsGmCmEjdRwV9hf3zMmekHoktKxNGlZFsEHBOD0EKDxpD3+org3kNCrxo+pjVAAPHhn5fUST8beryHdGwYlxyYMGwOjsiS4uLYmuCgcbdSvQiRVXoxcb2S2iWwDKW09X6xiug8RpJbtRdizBUqKvrRoClFZHtSyKS223KE99E8eRZKMb4IcCVP5mJ0M+RX6+ALli/Xt3E+G51lhtNEkq37FS9kT9ao7qkbdLiQ7u7G/xbU9hARd+Y+tO534hh2Kk66tb3jjqGWU3F4gyYAtvzxz9nsbxBbqDB8wbq5QbqPY98uHyDwmcnKIvNpxa0/02pr6VImcvjL8hBGzyT2AMFrP3Pw/8csNDRmgmf/92O1pdVqxm+0NHamHSxozWzs9sdrdWvmo7WOVgWO1qb31pmhtTR+tJwc2xeFvk4Ni8LHBybl0Xejc3LOa6NzcsCv8bmZbFTY/PS5tGoPFXdGfOPiS+j5TE6MjYvLV6Mzcs5LozNS7v/YvOywHmROE13Auo1bfpK07Q6XHUj9gJheAqivvj7LsSyi+Jn9/NQ/XnXvVd/0mEyZZhAHybUh0n0YdIZjRKGQTo03M/M1EvekVYweEEbeENa0E9OzVrp7Dlp0v0cJN1hYG1GQaQjEfAsI5HnOaBvuukhvZFUuD95osq5cj5EknWNWT1hEOjEhph5X5/hI2/EgvpfxTaCzXp2ePRPwyebhWJCO/T3R1hND3BuEvoKFHtw3jo8Pntr+p1PMeEDUsvX6v5l5xxot9Wx1t0+TMLPQQTNaMjBYev4t6N8PWxMbfm1etnef5vzYMegsXck6dwDTu3kaL/17rjdOW99nOdrLk1kio92AV5EtWUDH6JAs8SCUvRZeSjqPstnF0dn+F/uC53Do7gYk9hTxlYeirFzaBZDaJjNlaXmz43i1PpCyBLV6hIIxGhYf7N/0haO4dobwOwR/4ptoZTbQOmRLVdqGa9sM/DZ7p7Mt4Lw3+Xhx3pzvhMUN19G+jkvX74lpMcx3wGmz7HYGUYpO7oRrAXt2B5RqslhMLlZSw73iPRkVraFiQR1xzzNndjA389xyijkX3mHPgan7lWSiXPlpwBvMBEJNINLd0DiwD7Z74hTtOkHxAj1Z80+x+hULyAGm+mlx0F+hn8e366GZx7fgz8LCzlerXjncdgM/zwB8tM99AQnslX3orzlZyHCdtZIXKgQ6ujQYH9mwS7GcM2SScBGfxY2tMNVLZcEMBme1QoP/2lc2HKCKyxYgdDwqVRhf7o/pXqwGSWflHvPZTzvDtVL37z33Ver953WKe+BJ19/hxee+g2LJ95Xqyee1uk/3xtPEcD/kz3yJJjLeOWpBPgzPfMGcQJcYn88RoBgQwXdu7SwcpG2H+um90U7yOxdiZAomxQmmwBksHRmfGijZz593rz86EpOb3n7mPKU6IoXAOcfYZXKs0WZuPGyycVRqReYwGVCrJJ5V4r/Usuk6dOyjHXSMvliC6XCf+xWypxXTVb0tSdZK23fXXbm1Gr5dY7i3/xq0fqbX02VX3+CORS+2pT95lerpt/8aqr5+hM6nk3Bb361aPe5h7R/gV7f/JpT6ptfrRq9+Ziq882vRbo8MVBGocVAybhhmJ7F/eB/25i/iie6b7cPL+D3bBp9ioCNtB/g5Lo7ij6TTOe6uezfcOpdRukk6IWDMOiXEhBnQOspBdHnMImjO6wZSi+0J0n8r6AHfGIUT8d9YBa98bQPnDUr4e13VoqjHnQLs1GQQAcA8QZ2w00EwP0rxVtw+WyU3Y0ddzaK40+X0Yh4HPZbAQ7OrqDJDTwrtWOfAloCPwS37bj3KciOoiGecUREWK7ruyybyF54D/zET/Jz4zmD4Mdt/TG59nIj4PqedqMuE9KW6CR9djCz3JM68YOIdlwSx3rXVnAXZ8EBSh2DsMfK7y0xyszrpuQ4ikLvS2g30rNtgBmcLkDmBSXtTiadGE1vhamdUTbmJzqOBrEfCMkORoyA+PhauN/oFV+Yai/O4i9lzM4Gr3nHf0+D1MyMTuENykTQESnt5YHln2Ue+3maDn3nbRAFSdh7N70F8eSWW6ZhP2ZY8CEV3yJRct1wPE0kiLQO1Qmd+oBMvWzFBxrFq4DiMr1UDdMDOrNASZgl26zlR9gR+JQHafYlTj6hKT6eZmLgN3ECh0pfGVhUL0BJAl5fBBGaE/4xhWnT2iSwzq2gWeYuiuVb99vt1W315Ojt/sFHv3btO/RPx8PHp8f/xKw+8JT8RR+2j+D4OfI34Cn9kz6+aJ13zm8uz96fnX848zfhrfbEmbnlVvD4CP/432auS5jtbTCX0EiusCOxmu894ylZVFzNbpaBUoEMFItHlKI4g6GDiJeiw9Wl/Hp62yaetZj0jwmU+PP1w8f+vZIfhZrjaAKDtZf8nqGLQip7uE0fspa4xHCE8EGRlltUzEpSMSwj8vwLWLvk4RCzN/r1beXSgpANVorAZI5qBpnky36vF6Sp8uxTEEw6yQMsttSh+daU7xgFHfeVnpnlGR50wD8+ANGhkZgfd/3gM+pJ5AtByoePsOlFnAprOHlwAPLvwznMU2AFi5ml2X6ShKA5iBKHK/JmL03xY99m7AHhU5fJWCLqBjcmYSjiyTQNLmCbYrI9ASaRDTkvEiyIrXcGHw76DBGnKQhqN5G2vU5TydBawcC/DarDcXzbHb8jv4kRIkgqFdmK8ix1geAhSdTRCthumTFPN3Z46YlDNCLPbEQeqOnqtKE4K7Cg1rwetKGfdE+ZlGr2F+U1rQuXzTh3wuV+AAIwPsjpgrdTd5UJm/qOtz9Q95bRQdt3fBJ6Bw69vkXZba1Mlj5nLWTTU5oPt7A1rBEtpBInPV71ln3e2DOFVq0ZU7K1k475zPlOiz5tlEjhL/g3aIZYLbviO6UySgu+UwmrA6wgVHHcfKpE1N4TlyOKLoFYXo3dZbxRR7I72VTlgRmjvUNxeFM7vX4lJTvsANfMdVFPRWsPXkJTBVIZ6SIJzpMWMxjNHWzXr7M+3E6jNxUbec/4Xc0d442VeuERvORoSkc+Wrfff89YnkS4YIJVpgTAKc7FgnM43cKoO75snZRdEZwie1DvZHtrRaZh3xP2pD/rkxo/5k3w48C34RRYqbm+VJu15wwZaldWFjSJ76Q5aTa/leVw31mrc/qirBX2yUnwORjvYrEImwWMbG4sXtWdZqNSD0gOxgIJgngql1gmW2OOrTgm89Gw/gaDjvrAE3q61YAHUjbW1x23GZBaCNqLdccLKptYX5yWSeCJ5HHz1dDA6zZpLUQUjnu4d5tFeFFAEEabd3FKalfx3xfowMt/w2nbxpzhAdXMxKI+GXtAEaXuALZsCU9uELkpGGhZbCzEYpMyRfXLhALhgE5fP0CbqzDXiVR8TVZXkxWfdKQVwnSkmJOD1jq57Pp5EoJ9T7d0BMp4mFFaww9oRGkHc+40r1lkDzcsqh9ImKn1aSggA85ywFp4+06m/VScKs2DQWsngyUCv9bEURTxmnvyBpUKr9apvb8KrvFMWzHFcnjOaxfrT32Ufgbl/JLsEjdQY6fX+B77Jg7/xheP64YNokYwwhNaApy06PPZ7T+UxHHlzLAIiS7ii2knpXhQCt2kzG3hAh/4wujl5nUFyj/RE6pAh8httE37RiuYTZjKiZRAUVqw0yqOV+on8WSCW1bqIxgzBz2LN6hH2ThWJo0jedaXHUZ3jvfFmwNiDuelz2F3IVdgH5WmBDQiKBRJV4AU1OXHFfQqPPKCotMtcIXgG3wRwim1NnOnOLb3y+R77+JpkiIyR4g0eHAaRtMsII/u2CPUPcru314GW2bdpYpzU6OORKAkdkAGZHLIGyVdh2JzqGTNQn1wJ+AbyaotBoXa4uoquXPh9oeiZm6xupnSKWLvsuvvfltCL9VkTaV++ZJHDaIKSYypt3DE4LVjHwhaFVe5pNwP0IBQvq8en98ctVrnLa9oALwW8mSWcGp50AMbVQEWQ3HUbAVW4dpmdiA8bLeWu7+j0w+iFA4qqmnQ9OOoZIAm1ppGES2Ble8EAqYQYjEhOb11UsHiABm3gJZ9Nct8zdk+T5z1Ws2d2WX3vactJeyzErAIZA10nYAjyCWsVqtC37Ep43mNX/m2XfXXsLHG74OFSaasVrJSmIDrNmwLubbJ55sz6jwTEQorZuoiEjYxI5WAC5TKyLRLV4xjagpwxblG9TC/n/PAuUuYokz7F8fAj55QFJcm1JZZUsEp7a3sCW13mfUpWxdoS0TH6s833DnaQbno3MVDlo4zftC5jacD/yUcj0u3gbRSltIYHhetm12rd5jVA2Pss0AIz7qMau1IeZDZT+FecBqXib3BlXfhzLB8IGYhw5BzzE/EegbVu5RH9Kk2E89idGkWiXR8sC+kxY5f10cnqEfDr5TUvP2waT9K5rCtTKhPSOSM1tMmvWu4AIE5TINyueuN8RgL9acjbyoON4tcNwKmjP8k9uNw6ZONHUi4FKSMMiie+ibCQthlRc7dDxVBd4nuM3LEwb8UF7xqbNqcv8waU0mwhMkPXHZz8C8ENF6zVngqmc1i1X3hy+oqikAUrlhcDGmtzJsqdrSvGAeM+7Q1G8fxJ4LpdBpmJO8EkmtAhiIbXt3fVpu2YvpmDhfE94KjTRWLQbYkTbFmXtnlNsS8EcDUd5s2AZvq/75/X/14ftA5vzk8erN/edK5QejaNxiohHZILMDUpHdy5WTPGWXZJEULRoP8SWwZlXnmH7T0gKgb4ivifNN8HnrFAHhX7lRSYGECu6Q4p0rPykgpuQ4FsepzVbuDTRXO6dKC9f/bPj+jzkTle80xJ0LfOkJeavYWXXduq3ld9Ia4XyZJnMW9eAx0Kv72gbUBrtfr1bojTh2NRGqkK6wTW+uYeRo14x36XATRktdjnz69iiuVa15LuIE8wx9f1TDEVi0fPMbKqE1SNRk24y1IwZ+aOkVS5vaNwNsYefi4MQXmMXvSEsqVS6fkcmsA5P1Afa/65lIy+TQiWzNSLnzRQ6l9gneONwdHrY4iv+aU0czT23pRlZW9U2RiU5tkNh0Sff00y5fINoNnrpzsAM6OHKHSRXzuRqrDRlrHBDm2gqBiE3SX3wSxtgkKyVnfDV2Xr1J30SoInasrVoAjGv7HTEV8hMs0eA387QKprezSdF2MmwmPkbL7RMEaBi2J3uQ0LGDNUsGw483mKkMy/EjZ8wkgEdvo90Gjet/QVEPoW1pwmhWsEKbnuASFc4JbGzYjQsS5EwqO0lZMF0Wunkpi8gYk7wXCva1JeUk4GeVdi3QG0JSymmte6AdPs0RT6xOKuNLKpG/A0OLReJGEd93kQSjPlPyMWyaa/NDQeuuKIh8+WYsPi1T4UGWF8ziWCU9oGHhDHb/6a2bMDIu8DMI5JgBmrJ9rddWWwZlhHjnDwBrm7aGheXOeyHNAe4kX6IkQ9oRBMEKDYOpG4l6UE592OZk9UdArHKm0hAEzL/+ubRryAzVJbLrP8NNQ0uMl8aTIElTkpaF6+ZqeLM0i/xbF4RmQHbhpeQ4dSMoFYribQDckBldL3pm7bdbSCelI2nafwxIWGMSFBQprKtel1pK3nmjXwU8Aoa8QjWEwUGzjKcIAp3t/nrmArRq5aKFiHhbXTkhCzAr8XSkT8eo4ykgKFrdSVy3PWnyO9FHa2Q42uRwqn77wN56Bbm12ckphxBdCfgDt4hUnxekmyhmoG6CSQpOVXeN+immLHZpWKnyqcbpFLFuG5QsNXcbspBaaELOzjhJc4FnBmc18ZPP+RYHNvyi08R5/bWPPsq22iqycVk61rRuYVbu33KC5ZQB8fr+F0jX826yDZsblhe4N53rUalC8uCtYdxk5glNM5coaD7ogUPeJ0KRK/EuwXu0IDSTrDPG4zFucmlZHxMLDT5caqOst3/5klvktsbdSt5lTd9c2rISw8UOWYxnnGqszsSuTnBUd9GiC4M7U9DoIw0eEchJQEyP6lxLfUvT1Cm/RxCtOhDlSNKcSEoNXqF8++8bCuPnQjbUKs1LKNlBWR+2czUA3ZGIqFs4kzWNd5PMN/xwzZl+FFo+rH2HJZHJ0oF98hHy9oZcphReFTwH7oo3KC5xUUN7PpLhFy0QzKYrpRcDLByCgjageGyh5FG3suK7HDRKIpgbUN6CXofGEhfN5ICd/my2iN+ZQihFZup024JqQhJdczuxfHC+MuaWqkWp8/avnpnydcdCwGt/+64ZGnaHtjZRtrn4ZhVlw0R0GKVE8bE0egvE4/kLaiHC7vXLgPxlm3FhesFPbKy+1JNqGUo9xz/pG2tYtXYQFQlca9p7kpVpRh++LafJVP00bTxtuu0Zc1hrLoeO951DUEvcTmhsu7SXhbUBE85B6/ndxO2MSZ+UaW8jpS/rPyEDX/hSl4RKdaymIpiBeEL0XDnHByk1qtt/aL0fQDGgQ32ambmPi5v2sKDzGemOxXMzMey1k5h3vzrEbRiH6O2JIM4bMWGqtq4YeHSzuOPMas0V1E5lw3fn9q1MhiaQG4xhEFJpTqhv147uy+6L+8pdfftmobyvKSf0lLPjX3x3udX13RHLsvo77D0r4ul9Q5P3vJKAyytbgZJzEaUiXE4dZwyjfZikimXz+DkRGXar/cJolNIXS5zCc8/+S/+GDkIOphOldMd4KhlqPQaLI1lISx6w2hBmlgyBZI8DCNBolgAbwAG3g//5A1awA4sD10qJ3ztqag4kzC17/QYeO/asU2E8EC5GR9PHwZ0qrnlxjNlZ2Z9CF/3Z3Yn5j0K1U3HHFj6+61/wRYnZEK+yEUfZqn4Q5j5mjlV/zLCOMMG67jIN4IMMZ4zEKGsk47tdwiKLxOUC3KXYKKwTGqcp5e9RxPGd9AGxuRKzpe10fCDNzPCLa1KUGq51DexqHVYxGmaB72Ipuo/CiJ6vCX+yMcN0qfpLHsbPswywEwIhWW6nDKoEiGWPQS9fv+bsqJIqo2fOuephHurztOQejoPepdCtQUsoAVGaiHM9Di7wBoDdqFCk1cjCPrQdzV/gv4EaH+U1i4nLBvjZSr74KgtPHGmq8qT/S7ria02o6Rtmp5v3i+r7z23Gr8+7ytbOHyGlkvj/Fv2qN8tyZ3T5Qm+86UZ/09SfeDGKu3li9GwJFToVP1AYATQS/ioujjc08jYdGBn+NPDEjsT6njzCh9rsTxxuQLTHAjbUz5NQ+4N6vPX94NSBeyT3fz1ygiXqTWlkHZXS4sw+qLNV5BLpHDIz5Iwb7wsKttUdhgNHCaCXC8qLEkEIPndId1rwj/rIr6epqvLrKIQL5XBm0E8elu270wM67NDcCoZ7ixYmWXw+d8A66EXHeINROOqGGyvcTwIAYp59/Bh2Oqim1Ujh0ICTqx0f5lIBMKD0HES1doQDSJ+4yt9P0Ab1j2BjER6aJFm9Sk6wvO+CxwTbQxBdhlz2v437r7YKoUPM69D/YuVLeePWitw5PAFeWgdBw0Ks471+X1uGvDv4Fi1q8JhfnbbYodN5VEg5Oak+8D8oOHxsEGaHbYJUL15u4c1frjb4uilljLL0q/qtJZcV3SHJ9lSIu6WTVj/GJhywVP39hUgbCgjf6Q/hOCmPXa7WlR+bGcG1mKeciBbMKXe9AnXzPrWLCjDv/20wYgY5xdx+4xwAP13TQw+Du6vjaP4B/KNW2igQLMjoNPAkHD+U7lwCWlDdfAel2PwfcCw6TKKF+noKU8iwyJVtwijcWA3aUtTxqDsqRyeMjAvDrDwaALwpCMOfjrrpDyPKR6jIICYcAGDbRTggnTt2kvAUM4w3uArHyjua6m98zys1+EqBcQHQpvLDfM377a0Bmm3JH5RSS9jgIJuVfgk2XHD3fYk0LX3DsPgWODSl9UKq9NxXBjWDL6wDJwilIkfIB4UCLDtO8AJO3ARKsFIVgJ/RjkgR//hFtOYIB+3j84sn77QBNrMSxZXbw+FiApG30Zv4yQneIlYPVVRP+nR5y/63t/GKSCd/5BoNlsFS26xu7u8D8W96xL01oT2CUeGMzCqLyJ/RGHJQ/afIO5RFtXxdfP6kMz/uscom22/ycPxSBJ3wWzGtno7aHM60oz9Y36YF1lHQxhLuEtRnCeJoKNODJUL57oXRZw2IZr7CbOM7u6HHWKBr9DYOH5FKZM/JGzV3/5aVtaHfWUm2Wxx5ZVbdKNe5PugWz2BYgeTRChHaAT65nHXnGNRDjLSkTMl5aqSE/VlMfNp7YzJohs2Wyor3F5yQZ1NHUnKVOyJmS+qkoY4ZhCNCNe6p9QO/HrbHdtMUyHJQV043IekDvAhYrhgU+UBSr6hM/+YKeC5JJGR/MtF0101PpskYsIFgB3NqMJXpCbSffHWhE9BdYlFCQhDYkCYEl2hiezozgJr2NDGOimoXLbSfUeywt50KO/avrmS2SVxvXMIBrDWemVXxeT9GI99Kcy/Suwu1nZnNE46iTzkEyV4GRSUUb1bx34YMbnfjw+Wsa3kEYzSx7QbZqiYtc0UzJBEKbtQM04BanRLFni2D7SHii/W8cRtbUE3IrfgluU7PtLO9vp96JmI7CtIUXaG+lh0QuJ4bh2CzUcVd0Ubxc3W/lDM6kLymWriV/gDSnX8xyM8rZeeemfXmBrslHhyBI8JkJnzVu4ZAebbcPpd9CkDHJteDaFiCj6iiVv0B+CHes0DZDrs9z0x1vcBXSkGPqx1slMmz6IcxGZeLJ6bhFjkWbT/VOoRHbFYfGkwDOoB37LDwk/0WxEwGjb9BT2FgmpgBS7VauNxvGY52YlDSj/q8MNV5ClqVZNuZfu6adYbHIhHmMja3BF7KYeUKhuYjkStCCXfaVSPlKROZKpNdNfWRJg/DRyAQzsoP149YJl+guvAe6A/F2HAy7vQdmXcmnjyF5l7B4qU/yIoMsFtJgyKiQsMQMtHc4F5e46rO3ePXLaAFHT0koQG58hpbUwAtFjGWsWbgyJ1bzx9C2harDZQkaPXH5AU4zzcCgp7gYiHHLuSoIhqwEJ2L1BSXSRYm3lhSJivrPZk17IiLYEZhJ6yA0Km18CfMlVvLFNkIWJqL4PY26dZGyCbb7+E78ijDtoPgVT7ogbukvCUxKXqjbh4hlrlGTS/FvhgT/d91PQUu/KKI14ljite4tLLFowB6mMEdLJx7/QD7W9R3Mmrk+GXfDqAlyMMq4mX+/BiuerPWDAeC7LwsgcrC49wr7SXFgPiSzxTNJYIm5yOjdGLmQ1mYDOoT0pENMW4ZQUW8ZII98fjVgzcTH91V7ensY3wFeYHMF3sj/5tyvPWBKE6fx7S7IRnG/kXmg7TTGs5ni5GgZDIT1fehHipbyYKOhX3iXt1Hf+mXr1ebLrV/02zz4cRJ/CZKDbhoQq3q5UjGmNrfDYP58QYpJkI80hF8hoFb+LOp20UVJ3pv4GWk75pXYSHI+XVEaBffkbsjy+uH0cLs8cE2QO88aq/1uv16e5AY78HtyOgRn5Gef/DuEf3Fx4c+Od/f8zx6Yn22OrgThXFdxX5Eb0iWWwtN69ih9D/WnCtFTWtff9vy+/uTf8YSckiNHf05vstLAv0OrW8hptAgNxHxKrkhhftXbuP/gf+OXvw2WZMu7fbnVo9e6jdss7paHGO/kM0Ni7Bu20RHdlFM0A/E8PnsgYU5Zep9A3PZMXe5sD5CuKJru2M+lhZTX6M25HIwgbw/YIbA+Yt5slm5ZVx+IugFv7kC1DycgLawrt+BqI5iT/n3j0j30xm7OX8Fk7V0vZnyanZag7bwJWDkcJVGu8EPDM4tbZUy2T7V8ZhBhwbq734IiD3PHowaMRoI+YWUKBnSI9pYcPV5q9JiMTuqbumaHWHboYnBtQ3ubyLfpjATfFidNVZWqakH2O28xTeTtmGt6qxTzke7WN4JNRYCZ4+Gnbybq5kfCRZSINz3KRiuHLchBCQR1m4lxh5uwvOH86BTyhGLJ4m0MLNAJ5azPSh4hfQb5kB/SwmVJpOiPb/pSWJyx9Ww36hbWbRwF6W9UvcC+2k6+SYGTK48Hosqb4zTzyWZlOsddv7YHjfa6t8T2OKelEjbQyMFqTS65UlNBfhJJnU8CjI4qoWJipCVC988yca52Te9qXRyds+mddWhahbYwjmQsSCEreR5sJKmcu00258zpgpvMmRGzlGao8aQs6QUyZGXnqKnF5A4vL0XrXm4OemLOnZoKpjUkbwEZKz6Z1qzJuXUne/boc0CKovN36C/2UzAvgo8KEG4JX1TOk78KWkajkl66D2kjF0ms5aDj4OTCVxSt9mnQyFtOcn/NYWI7MAeOQTjMuEl8YrEsfRg+PsJ/PoagFa1E6mcL+Crpqbcy0xS5C/KLWxj/klzoI5ol54cdIMfnwbYa+2EXxTymTsW/nV5k1LWuDudHnq97f/8RErhFPqem5WQBKVnz3S5mTnuK/6oaO55PvTONup+BPjHuHmhRkyvZXrUeAnQ+QuRbDFBafh5IIiL8qaTHMgDDvyRVQtAnIoIAw9aN+2zErutqAur3QkDdVHDHd2niYR0b8B2XyrIzr7XYRGWpBsvzjXQOLm5a55dnhzed1vHFDRY58Td5ZKva6HT/nzcfjs8Ozz/ctI9/P/K3Xrzc3t7kSdw/Hp9rrXGc88uOj/4HskUdayVfdo60Ji/1JjXWpm004hncL9uvb06POvs3l50DfEuhyb09PHlzctl+R9/Wzbf7B+9vDjfe3VzAH0cd2mjDbPShfbN/dga4OWAfeVXZqNkaXXbeHZ11jg9IOWc22CtLQ0K+9P1LG0SXFyfn+4cFDaA/KahygyaD/IzgdesDn4O4dVLz0fcmB6NuJFJeYlWjfeQ4x31/i0Orx/uJCOeEFL/4LUhSJf09e2ok/mdPz4iNQdRxjfSfaZDiSDQJuMpGlRdRrL7AizjqzbXf+/T6IQtSH3OqWF4SwG3vWmixLuyJb42uU/FCPhx86RuTwSc2fONzJY+xwDt5Po5TUbdLnabEPw3/5DQJi9dCq0EnCScEyoWbWHY87d5/CKN+/KUdfrV1NDa2AqUBDEunjTQjk3GQMifKPeqTZZ0P7QbjebEITy6ycSkZnwt1+PmIfLZSJJZY1YyKJDCL2YDJJHMsvrm8UXt4IUST1HxJlRQ1hRZANbe3Ft7/hS8XzqYMuOaamAXwQq1yRWctS+jn7z1FkoW9gK4ygnIMKVqMW8WKTSRbjR8yuX+BELfiZ882oxyjGyiur0xTQ3RC9JAT7la2FRcJQDh8Asen6bBshHEws6dbsMv9Ldf+YttbSmNUGbErvN0LvlXT79U1VrznSDSQBzJ/odauodz+H6+f07bc5qHzcH+rVt9bSCkhSroNqxrz3ksWKSMzL0dChMP+FQQkEUY+iRwpCD8DyS+gII/kJZgSv74rixHIALFA7XwuqBIcAnU/x8lyvL9YsCCfUvJY1JbQMN+r/iM9xmXyYDlqGGoST/bHY3aDqyTKXNZEZ6ESKn/8pVRCPrk0lSh8hufwWl0tr6yXjvCMPwTJuLRexbyEZfF+vtVhS/MHeeJJbUyCwYiOmqEIC672yP29c3h00Xl38/tR6/ymfXTyBkSLt2dHhyQjnLOYH3wMPTmhIr4gW7h/GSUW8aCn0SBpl81LA663cG3d7GkCcmVQHh/L3yGZqXlkqF8e99aNQZQoFIAM7GjzLnAZdHnKlck0C/Dq2wzzo3fFIfk3EHGZT78xTnOXvLEZdnlVTlY3trfd3d3dmgd/v9zeeFXDX6/wV/3lL/X6S/qg/tJL4D8bW9eu1/WjygKgYvOit8C4I++Gu3oHd0GBHJvc7vNiP5qqsuKrKS108QUZXfLwTc8QpXxSycgxxxKtfa6KtiDjokSIw3LitmszQyt1MWURFosApQxQv4mOcsTdJPT9V+437tMW+/VmvCNydMaViptUWFXxKqaHBG04OUDnpOwqvlYsgfYZGW5FCyzs6ixZgLHABJIugL76C4O5/vgI/26Qf3+lmTd3NxUM2xSu95g5kJdYLA2S7h2piVFiSj5IbRHNMh2yCDoJTuxznADBqpaBq4h4Vq50F3/7EPOgy68yGWLBx+lsYYbx2hq7tkfMN+ebirfnMCgC3ZpTmWKeO036wmCfapdZN1Dkfea5XfyFEglaQWtt6f86lW71hug36FHXTXlOdVV8KcAkscCMkjgi57/2Ba/EgwDGD9wq7GipUlHKF9Nc8ad/xjTDKM0CGkPHW4lP8tZLzBP1rARLEbFR6FfIMQnTCVD3V8hHZrpk4dhKpISXD5LnUT/xWp2FBGJcPAnnoH+SWk60cHjdizGog/ZAKpEj+yPP2IjG9gA40GpGWpH3CvKfT2PtQgr4Uchvz6ExVm4DZB5RsTVHY6biT2aexa9B5Yyy1dUu4e0Xcbojn3IEL7gIWiR+AO4pwCTttPgQzH2H/DY/t0BI6xYKXV1V2FJZB4jLXS2LR1fJ4tE5uODMj0lFLJYUh+hheFOcuDRpifhd7vJUJEORimRGMSogYJ5UBp0DcQ/h4PDLGzs7m24lMvUZcsKiw9SsW5wOzJiolCZr3JdK3RLCraq+SZNV79TcYnS8BlLlTmGlUUBiCZvCp32+Z5j2VbFbieOW1/eHPNFiiYbp9hEPvnP+3nG/qfDQ7PWDojl408oG9XpvDnbh76Y79QfeouaoR5QHwF51bmGHeABdxMZhYNYAzGKsKQf5BC3sKXq/qcm2JAoHvkgs2Sf5w9VRB9TWEoYNfXyS7ZhqbE5lyDziEDLONjGxNTW+djHD0GUyRgqSW2Dvueczv0PXD8g+6N0eCZybovuLMgUtpyFsdHqK8gvEyFV2FXIdZUe5ja5RkGCpg1fc8gtjl0Scq+xN0/TJrpmpRLPtfku/hMTbDtfkWw8E9dJWAxkfw/BOvbLgakkoafpNS3a1cW27gtmpu+pVdxfk6KvN652dLbcCf23BX3Ug3O6ujBjI3QN0Xct9TXa1fY0jvIQRXpGxfsGxXpI/X8GfG1syaGTi/9qc7Pxa2ag1JzT0N7uaXCvSlnY/NG/vK9vnV2/i8ngYevYbTHBLkdTxRoA4QP/WHcMylkUiQ3pDg1n3KyTRPp3NGLDJZjMm6ILZ2O+95mslBSayTXsKH+va528MMamLbaVZrlD9aWPDG2LwFIg6yGG24TzwRjBPfxv+s3HtT70l3K9XiKMG58r2e0aWX0PNvyjV8yW8kZfxAs8TS54yJdX1YN69nQlX63qYBunq10rv2p9c9a5nI1hYf4jKO2BiC/4kSvsI6NpXSIO9f6k9xJbsxS/mi/pL9uaV+WZji7yxHcUjRshNwhG2G0U2+RV/8/FxPq+w0Avb/3PvB5+kV1fqBXeGOxu1rVeczZtf2vlF5TE6EL9QkaLv28d9AXr8ur3r7m6t+XwXolanI/wqzZErzl3qlT601QYaVFicUbn5dSp9miK59P71euq43hP5tMKmBz5yac6hXxFBpjxYtV3kw+as7eWu5kQQ80rN4g4q39Zdzzqu3NfuCr8Hmvga99341eXBGH/5fo/0nd6Bnd7Z6fGd3qFnTO+qc70Ce71zzY8Z/b4JRCCrk4GDc8C7eJpLjjnYOAW8vKZftZivt3TVaP6EfeSzBeM0lYonRfOYi3GMX+zfhZHDK7wq3ogyZn5vGYx00xIZiqOmYe2Ec/oSJ30a6Yv2JPSVxLWk6SEX4FNhiC8btnnrW8RbcKW41BrbJ9ISQHMVTishl42EzGyBoXCayvx+QYav8gZpSBBbT3+MO0+bPv61LSWwl0xm6Sxg75J15jxj4CskkLS3W+RXQ8Cb89LvecVj+x3C6Q783lqh+w1O9M7vrBV54DA75N3Odq32+Hi3U8e8+Ac7xNtMK5RkH9sCnzKy3/EmIqXJwe3q6kQxZKhvyj1vkjMvsMRNB+TkumuabkI4fvXVC8vjSnXzRQsvE56pSWFBx0SrJ6gNr5xQpTLOG7O3HOBTka4lRaWSWFHKCIirdHEdrez1c1bd+1krskBjpPxmpvn1zzOpy9QF7GqxoUWX2C+aXLOuq20FLyPY4328PwtE3hvgtdq9SwMz385mmsdOm16bfNMFTEYquduVGQsdNRAhb0Uy4FHZzlYzYxqbyoCyayatrHB2vVJfFH6tVC8pZEcVtJhm1OwilsAC5OpqCGIfd08h8a1wHJVDb2MblFly/2LzNlauQVMMbsAM6sHafJBmf6qztQYlRlwDlFRP5w6+f5RYblpvbN4OjWxqIGryPJhxbQNP/dWqAxoj9wnWVc6a6y6+VSlPmUnGL8sy1397GajpgPMhJTbbzlTYdshuoVPELKXCQuNH8IOalvwA/mRmXCxxRJe7Py8KUwQhF8ZI9oE+/K4I9gQMVRw9jTAP0fTU6Mt+5Q++DFPBWUz9vcvNZAPBc2Rjcrsw8LrKK8mw/FD5QTns4s9I+bcPW7W/w583+7BjZferPt5G9NgV5n5W7tMsgXhzONVMjVPN1CgZnLxuSUhOfbla5SlnaH3NQr0yNgMqCiNechru9sKQEE4I4z1HOlv6Z5cnJw7GgZo0kPs0dNNLkGMvJmJZ4NmjpbGo3CaK++rNGloc3zIbgImcnuIuitW14y8RCRofVCburHh5pIONXnB3mfUZkR3Njbamh3elknP63vXrG0J3153BRYJe7XhIiFg2pGdJc0j6NN2hz/6i//Gniighe/rT5ryDOuEBRZZ3+iEjzyp6ngRNJSm7QPqfSafL2buDJUjCwfqiKi0ES9ACNBI3S0gW8ieGEMmLJQx+J+uC4fRhNA1YaGpd8JehH/BV5IvohpUK8QEIBKMh+AiWvUufI8OGyrECWMGLc3ZN7hkIoxPmlcrkbaR1RokfKJewHssGHvAjxov9wBQaMUYHZxnvbtRrwrCln7c+VtvB2RIdDv4b+9i4MBoBCFLEReRFZOWlIrdn188zjOm2B+vXcJkoDjoFF57GWyRF7UGxd5l1j84KAhX00q7sWnNtDhY9LgpoiNLY/xyLpg0ZcAhsvOhX6rWNrbVhpf9iwPQiJIFJZbi7MCICmORkcdzE2tD1Jjsvt3gCYfjIi3J949XaxF3v4+d6Oxt4GYsF3f7ipemJVYh3o8oE57Nb39gi8ypP1uFP1Ahf1NG2EPsRHlKEuUY7cZPfRdcr8VrUHEI/lB3hNwrl9MQertWhaf0VyKhRBc+VX3GiffhvfS3yhj7g3vUS8tLP78bV1eEODLZXzl31DLEfXuL4r178CkrE+Gp4LXc7bvWa27B0E53qGCY6JjKa8llh7Yw8gMj14CNRxe97+WgJonuN3Rm711kTXIWUFRJSbOSJv3eCvAcEwx+Qw2jdQtpIGkNCGsOfQBpD1T0L1giz2OdRumGsQ11dh0K8IXRS3CUB/6jFLHN8zXUK4S4rtJ/Up9EReUhXa5pjF7kCX3QNqVJCqovTP2UimXX0q+7dVrP7zCEpG/igRZGMDcsYAPSQpUZ9/iDJ/V06/O4xMAQFXRaeP0Y3+z5kYLaf9DvnoSYSzw9iDR61giLyAH/PKB8/f9k6hlHIGCiALxyFbgrrdh2CGqvuWC0iHV/OvCktcxegNTp6muK+vMuGIY0Rw2G5vo71qFUJznUqWEldOKYF0jHNK3ERDZQwT6sjR7wZHSyVzSu5NrlcN7OkpfNojamVlUD1jiI7Vy9h6OkiKpV18/5T6LFBGdlGJSviXOH8DCrcQFVX0mcGTapDNVOf/uEmIEkXYTlZWhQOSaUQNlXHnan0ohYTtC0lOulOEO+qiylXUbqDDGve0LFIQglG3YpFleYwFjoafG7mbQebhAYX2lJ5EUHiV8S3DroFo0sftTtkxD14Nst/i6+7ofKB9GB9TOlHIwHC0Yt0q2VhU3WtwtMqAWVrwSk7mx+/9K3Ic38F6/flXem50m6N0bW53pP7LatXPk2E1tStwyp6ufUJ7cW8VV4VD8QmductT6FTorq7Nf5Yc81VfaZqjtg39lZZKuSojbtz1XG2mjq94KATzNJgjrQU4WAlOm5et2SJ1k3RFgNWedEWZGky9MLXPZq9/l8xCgLeSp1ny9DJIrPHsAdFIexhcdT4hqeG9CacY9kDVfYKgla39wp4dUIjaxtzBUay+JMuWSCM/CjBx0v7F8elcjrP/EfYU6MY2s095TYD73ZgSJKz81P2vXDh9zTYLABQ7unJaNe5uF0mW4G6pArj0Z6XuarP2R1OGkhqGvUCnLgrDXnmG2mo06Dgl07U2Sxbyn9O9Z3EFMVPcBJEL1PhNIcem/6Wh3f0SKjoPGY3yezuMj8vdCoralLfwDZGfvMtkss8u9quhMAKMX25Lf+56g4jFONwZ6PGev+KvS1NlRuAUI8mk5kqlvHqLN6/m3OCuXih9Bz5s1yKT/Rpe3zElVkhS/PcfBJ/3Hb7a/AAc5TWsUBj4cRqagg/0AF8FwHYuN7d+BEf31j+40UeZWXdG2S+R9ci0+ySYG8uDbZtKz8XgCheg4HWvqTLfZ3sHqzqabqusVg749wiO47utjRXYCDmYXCmv1sKe5Xk3vXIX5Numhb6ronNRmWpGL4Vi6u71dXuVQzCa4LRbhiHSI3Pvrjyo04KqJvs+qmwG33/Wm4RbFZB7R6Xa97mvLDMJZCOxPjo27wVvWcwnKZSUuAHYp5GOCL2IzXyExkoLEGEK/AcJGx/ZwF7QbDzHSU2g00svRViuS69NsMWqcNgCtfpNU9lHMpiW2EuBz4noLuwl8Sk7tZNiDnuoy6WhaHVt6BXsjsfPLe5IJreoTN2qJVifs6OhekDC2IuCtJTLJ/yzwsNj4vmshn8DLkpFIKX+CnzWZEr25BrXoqqGFYB8XdhBFCvruastaST0kD5oY0y836t1X5ccoyAh5XL3DKL9Y+VeoNklavmugJ4k4QmpdMz0QmXXSygEfTxro4Nb8mF1W4fXhzgBvK/zWS58qDbVxp9xEY3WJLGrwNG1IenB/vtzs3+4WHrpt1p+c7G5q9VkM7Y/9ccte1l6+zm4/lB5/zi8uDId2DajQes/jqZ9oI1IPMGLZbXACw26lrPw+P2wflvR62PN6ftt/4fp2vto/3WwbvSixKGXa3Xq/X/l/zPu/N2p/FHpRA4mWFezoe4ppzunzWcNO1PGmSrfA4SLJB9+s/GNvzHHFObhPRskYVBfF5OGXb/5/iTFOmZwinjE9iLXLn1nt5DEuT8+m4hKc5Y4nN4EHk2Gg46bNFyIdOw34kpZ5d3/o7jYTZl4Jx4tUtLaTcT4IZJpeKlFX/DDewx/SJOjogI6KaXehuuB2cQPSeAm8I4L3/QOK++axw0Z1Z8Z81B8UVal9cOzt+8WTs6wuSPOzVXKQ/Hvuy/amZEAQDhPwX5z3dqTtMlELFCLPxbNe8Vec/qQtccTD9dE/9zGvyn4wEkIe/G5fe11MXnEnT4yUjpAUmPluUme1XQ0g6x1oR+/RUyqvAFXoA11cRTtsAqXotdbH00LpGKnmiezAh7IZElIBlU77r3+5gkzANu5JMCNXtllVgNIk9ZxWyAjzR26X/8wG0s14uaysQ9tiK7GLTbFDmjtYn43+hQjciD7zYCT51RI/HofBrhzJsDT8QBES6MZAUukLxOqY1F2T2cB5U2arXS+Xuymc7OO8dvPioMyqGCNImvZUXtUyxnixeCJH7VDx4f2V+h9CSNfLz1TbiUFQl5GuTc6JrH6zYwYJfXkoIB8J4zvSJFqmCX3JXdaz8G3Yv9oOVbqyfnVCmEA7J62cb/XDkH+wfvjmBLnHVa5yfONXsldksRH3R3a7x6Fe3A4XJc+KwX+/Jr/NU6vALlqytjbfOf5/6o5LO5PRCR/KwzbYVIvfmj+0mYdJnVVyn5ZnXiV48802CqvnPzh6OUhUlpV4MW+fWISaLBdXMlBAFqLdQ2227IthruZ77ravOINOSbhglGuNvYjQGH0npPbUfUzAOx2FVx2UbxQaltoQkVIpRWyBSZZy4WpkGkRkQRkESeH7ITSohNQlCp5cbIwel699X25cHBUbutAxtPRA3I561m/tsoVooJSPN94WIHNsa6Avs6kGubq9B7GSXBEMPRE6zSEFCmGSxFAYFGAYFGARa5TsqDKubkahju65vkOoJ+/p4VEq7XdnayPKbQSHxBLKzlIqnNlCSLhUgUbD+ENsFWy3+aBAPh7tXL7n0lsT++4kcnSfCfweGdJVIdM1zqoTvWXX4bRFqhDBiGig2sZivdB47T5IHoNArd4esX9C+TsdMQYoGtqCgJWnKknG/tIRKw0tZqsdd8Y716Ae1Bb1ToQaX0wAqr6ito3g8GXVJXhs1tpqANmPL3oA3r8oXpcXSJ2VM4DFST3qs3annMrtVNzIbpeTQGldWYNX9cdslArGkLdjI8fxCNKZUGVa0i716tUac9dFeVPGLN1GkKavHqyoZXfJ5D6lpdIDW1IdUzjoq5aKX4I16T5gRQj7XXfAXFUyuuq9gltPNx3pf5IcAWMKsa5XobV9f5HaecHiobs2/JPOUVd7eQZh7HFLWWAYqWgQ2BM9P2dHnBLMoGC1AHslQ01qu9W5dFGUDjFYsh0VmLOlBqrUhcNI7GdPgwbDuXFyxLWe773Zroyvfs4r5s06ud+eZeprtgBHIAWHHDNQ1py04TZXNjeZmKxqigCHMRPMZg6lAKz1g0imQ7uQEEM1+0pNqpoA6DRuDDbtY1zVH8uYJE0VRYmfgTP5vhXWrYK5Hc1sBBDFq5Jw4K/Pkxp/W1umvteByR2KJ7TQQtHkJ9kTOrZQXf1lgciB1xNs+eRsV14rZwzq7i6eaFcdPXDywFixC3lFcYkSWeC4MgvhMJ62/gc8BB+gdBkoUDjK0O5DtGQyRxeZg9nBODTyrEnweYAQjiurCX9ien3QiWWkv93w8+p0qjyIANH5xhEUTxZABPyJTFE72G9xdbDW8nilm2auGPj3rbYfD5BNhkm8mhHHzmlcXFWgUn/C7G35IPbAn9u3oidfUV1jvsjay98JqjoNeImW7RjmZ7P6BZOulltxRDu+Pw9h25pU2UWZBWfBREgHyFXKHfCjBYzN7gNugiLUrsh+lZ3A/+ty2tuqbLrX+ZyMUOewEOCCCEfaAcePuWvWVCConwA+z7zi0IqckDWzHh7osxPVjxRZqRmfbFZ40Fy4/PjjvH+yfHvx8diooNx2f02nS/9fby9Ois469tyA6iwrm/xm6+D49+Oz44usGXb7DGgr/G1hwUiDZeXZ8et0/3Owfv/LVtrcfry/ZHf40V8uCFTNZ+YUCw6yN/7RX/+M3peevo5nC/s++v/UofHv3z3f5lm0BTZ7M6PL98fXJ0s49ThadsTpdneJ9+3mITZRNqdQ4I3K2j/UMApc5m9Ob4RJtPnU2o3T7hQNXZVFpv8H75/E1HvHipvHi33zoUL9jEXl++eXPUuumcn98AWk5O4A2b4eFZWzT+VX7x8uw9SQsNyyAW7qbTItO+Odi/OXh3dPCe+6/Aq6N/Xhy3qNMAfSVW7wYN7Wf7p0fsBZsWLSTtv9Koi2ignPh4on1OGcdAFEeB/uwSHwbGw5Pzs7f+v4yHdIX8W6b3nR6f8UcJY84YOsIepaHeGdTMYxjzH/Tpu/32O6CjN7QmDL8GPTzqHB10YAXPjgS/Z88u26/9r/qjs6OO39Ef4bKM2G4jpjIR2IJGQXqfsgX/K2rRFk0YRaUPcELc3QTRZ7yCu8cCmPLR42M3NXmE0avKX3CuHIX/ngbHh1Zbul75+JdfK1uvvCWfKVdmrQBtUPEhJYeUXUnmnuZPWHMJ/pPO2x9wiPIn1dO4Px1T16oDWv3Kc+gzkQXpZxy4G/8VB+4PPVnN01vx1603sx1/o0YMYpQvM33vAPtQ0yTrycuFnIAG07W8ZxbnOQPchgtGmHNCz9Ciiff7xl2jTkKZjYQCVnomPy53xUca/XdQJsXN4CMltbRt5iW8gHLIXBNJ/YBcyge8tKnewfdCO3kHNthgBD5om3Czo+izkMtVrphjgILlzUT1N69arQZq8ALGd3iJH6I2/gZI7iOgXSsKW3HWnErZqcE/pNEpKCYjeFx3XZktQjYibQ6JM4Hy3kt9+fZdPE30wrPaSA11pNMwmmZBOq9JGws09fUmXuQnJEkEL2KpsfyKc13CUt8rdRqhRa+OSAIMvDVS9J/V1XWyDushLYFhvq/ihsd6F7Evq+IqbIN5ZssP0BGYq/JeVvHV3w3+W8FMfsxyVMn4vXjXJdpaPGaO5PBOvxTvAZ+P70rQXd6Iw9y7rsf7kYt0oAqWbTyjRZ9JXdBhA9hwvGd+gRFRQx1BPKWx+U/tRHVszhdO4uGbaUS9S8wrGJUnZ96XGbNXEpudbqHVj8SrLGdgprnoA2n6D+Xlht5ZeEWZg4bXVkO372fW5642ldxYnIkEM0sF68LJUVFAzk+3iV/zPDt4E+MDYHvlp44gOMtijGJTt1Feyapzy45hLsq5DTCIc24D0sJa1nNX4l5/sVdmBvRoBPPL3oC8hw55gSjm+TSM5MZCfzRhiO32+weK6KX4JUWFyAMhVmQgehdScSjfTNa1d6tJMEiCFLhxkzJ0xacvQa/KHYsQyG/TE36bnvqWVlfJdf5Chvhbm099P9V8A2ehkfmCfXYyTUc8fVSY7sPu/hwwzMion1ozmAdzwGEOrTAH1+xO8PXDx/49icRbXSXBeL4IAajNRN4p7tVmLpR2zaOBIVwBCC5WysFOzVXYB3W2V2HIuQITPwj5Hn31aVS0FK4B9YrwYoiNfMlOq28AGCorK8ZCJBk4+Kp3TIhu2mVeuhjfAqwq0iBeQdRtJPFox0Y6c2d4dBmBeofEplLWYWVHUYo+g7NFePMCEsZqa4S+ETB44NWF4wnINSls+ksuzzODzlmctaZRRA7IbzLnl1XuZ9+ypnKwtd/ZrGFujKarGJLp9e/GttjdUwMg40JLLN4PBIjR7zchdTa+eDx2rCE1oJk19MO6mULF29fYSOxYC1NrpUbkvXwJDV0IuJziJYwL/iRw5sCCLs+MENBxhdOmXdezYJhxSEWzoT7ccyCK+abtWrlNfO1h2RAbl1xZUWOD2K4Zu6yshb0adV2kxMxFG8o6Hp/CSckkPhL0jM6PmFreyOD6LsasdyRcWlSyjgcDesMks9yQpPw4FnE2CdIdGwZJmYqbuzDFgoKoOYaUjWCZ6JlAqhShkD/o+CMcI7YcLLz3GJZkvBPyBRjzBRj54dXY0q8rvQ9HPKjB9zFPFWnPgcXQCBDPZyybT44GQsuKhwgoYNXkPVhQi8+b1V6inIJl46vCTignqIAoh3GM5VVSN/Kjx8eYpoUJuCtbAYdmEPERugBodydudjmE44KOV91r7kgwrhIGz9wJQGuSGnEuzEOGdJOZAi2N2TkFCtRkPB0OlQJ15qaXPrxjdvJUMYNCudAYqte6MoYr80H4yTJSqkXl3X6pnb/EBlH9fkeukgvYWVfmb5hpck7IxvvnQYRh3sOgGKC15y/INDKXxBQTzBkZ7583IzaIbUqzWYF1rYC8qaYeE2/MSKmohhulwLzlxtWb0ZfjPmyhqrxQb1q6Fpi/7AMA70L9bDz3QOFS48Ljl0kIOQFhksTEBccoOFgDPgGclNYhl5sdcZ7wfZ7AlhYpO7npFLf5yGf+MOWRZkIVdTeUxr6S9XEKvGS6w2NAm1POUob++Gp6TUrhjLpJ/0s3CY773gB+3gK94kDNESGQJCACndDR+94Q9fkQ6AJNv/Cr2/+MpuU0oEZLb0BtJH3Jr/vSC72KyToiwaR1lid4s8L5Qpx97PMNQdUyVhqD5U7xpvAXs2RjQhWRt3PTbU65R3sNs5yuOySrSt7/rDLl0Nb1bIX8HGtatu924faNkZHC2QocmZ7GMAqmSh7uOU4DXaZLDhzUaZDBs2yu+LUHx/lAeYNpKAGDQ/j0ArENYwkKeDjPjTlHsYifqlhUhGIRc8WiPyNbXleCRtd+7A1RGB3yVTiR5IRlRMYqfVExijC3oVSB7Rb4P2Na6/ZpEctXGen48XGYo6YVf6o8fk3s73Rm1Bbv8pA6ZUoiDZ9qEZh6YyxXXbySf91CZrqEVZ9ZAVpMltn8wvB1FvFKREvxSaK7qABoOnS8UIfu/lAMreUx1J0pKWyK9GeAk1v9UnZ2aAU/uTppzzEqIhaJpT8LBx+A3aF0vlLzsuLqv1rV33nVfotL/Qr+hn7iJAMQK92rVDigCYCcSlbkVEoTxJOKJ0UlfQtL+TJ9DiYT4cQPgOgezuHQqQQuDzTBMBO82WApOdOmCFZaw+ok8P7/s/eu7W3jSKLw9/MrZM6sV4woRZKdm2jaq1h24mnf1pd0Z7xuL2PRFqdlUktSsdOJ3t/+VuEOEJRkJzOb8zzn7JmORRSAQgEoFAp12TJrw9HSbGaXvXrWbHqlQmCzvvRNaaNviuqUErO0AtIXpe3yKxZLopXKo0eFJGJfuBlMMenYRnCF7m5KlukATSUoMsdpTuOAyd+NIJVp1nx6QqZq1IaO23z5AiQI7WPXba6/9qHnlxikcdSEf71xI+h0X/MkfTqPHpOhTbVNNr3kggOMtfNiy8GlxHNhMAi6+pmksDd8+wWkBmgPMxchv6cZogjH4teWHBClx/Ua3BNYsrP/yXo5wuIZFuTcj+a/2o570b7UrhPIRlh3RPaoT2EvO41bL9dyJf2W9YaBhqk35PbFQ4J0kcUYWA9OomP4WtdqT7Oe3iVwj5ttIvDXpxrkP7Ie+feK/ftr1iOJerxJcBGC+PHgbLV7+Mefzlan16VX0xv0Q5SBBG7Q629CGY70GOKL+Ub18jPHdAstk1mhRD4LJhedy0b3xctnk4vuZYNkvIA/1y4bnZevXr3qdvDX+qW3DYAvLp+te3ckhqlYp6/cr9sNKHt5ubn5kuWqmFy8uvRPGkEdP692XrjPoH2P/ni5dRec9OB/uNfp29AdBh3nHB839El0Uz9rkFwS3h17QNKpqwj0YjqHQlQIc9GMq38eTLnnjDfRZuU9nQUlDdEwwmDvh3TxwML50K3nhKLX3P+d0s+ocDz9BMD1a1iF3rXX8V5qbluVa/FMvQnW3sJaZFbz7DI1E9l/BIsAyTKV4vM6iq4fD9sd5/tZBWt0HcOUjnDIY2j7PxxX1pN+anxrvnCZdMI2rQBALRcZVBtvt6NAVuCb1nNcoa3BOCiU24gGMLucSUQqLrH9hfnoPBKfHHrp9lguRPLP615haLL0fDkveosRIhwGkVCZzFwGgwiRecX8eF6ODInnF2SRyktIefohillNiSBBUx2x1LwkXhPwYDh64KadusrEBk0ubGm2IfjCrGBKbSaYKIEy5Ih54VsWu3j3aGP0AvWkiFwSloj6R1+0PeX/yJkQb6xhQuPNtW6j031VciKOm8Fal1AlqMerL9dJ3rF3cW+YefFq8HLNzzbuMnwYB4F2pR5titzhQETuV2nBx6dRs3/JWL4e/EkQSWyIJAQJEBfijY1XmNc2v8gancsg3tzcfNHM6AAbDSmKlXa4cXF3HC9hfj7v8MErCIasLBV+PFi0lQa3WS/FqEyNxiVMIt0cf896yrL8Kzsb/sb+/U/2b5HTfyP2L7TExQ96QqRwNDR4pifWxXUwgUFhMI/gWhoSwPmAJcCdvVKBGDXF5pr1nuU9yiFow4QxNNiPjY3XnvKj81L91V330iC45tE3a6wnaiuHkbuRSVAH88BSRl474DB4iUpUcQaS/CT5RdLsXDIv9GYz4Y45emELpQQo9YikwDlmAldkNsKYjmzERzZShzXShjVSh8UEo/potd6B32suyJEN9uez+gjIvtb5Bkz0NiA/umu4rgCo+8obBtNnZJATkGy73m0TqlSSYPgMR//PIoHh9bblzLi2heLjOH5ItmS4gcGUL0JM54VO/1ZLSSwH9mjZO8DspPXGRSdqvvTgPy/wP+teq93uwH/gfx04NTtt+P/wPxAAOhGcQxFCIfgr+N9r+N+by4vikjcc34Xjs3SQTj+NFU/0lY5Hwt+sdtvrr8ijKsrfDKm2XwBbePXy1VY9IpejgEg+zcLtFST3MvsKH3zlTVwdCabo7AhXMDhaO1txkD3Le/Df58rkdZ5j7IKtZtyjtmBDgifaexLETYS9XDASBVucCRMx5MvPO2/evCFhKuJNE8McbtL5RueFFp8BCPK8DAgtgKCA4XiQWFtJUO+8gOUOqxl/9+B3Tn8q48rIqJJewo1TbOZ/pu+JalWozCAsHLipDpX0ThelmHV81Yt384v4ko6cTK3zzCGpJLichJ9+c9ycTOwLzyz6iEVkBehFm4ETOvyY4YZazU6zrh05+DbZfPPKhS1IJKo8wLRiVFTF63ncWNsUxxY34vHzoNzI+mvkv7bvGxsvfMtph6U+HHSdLkomSfAGjekaQUJqdNqziF4Lclc3HqJE3h2nYaFRGRZRmwRjUN6XgNqZr2qkO8C/2x5wBEwdRVkkgRuvYAgRjN6+Aezn27fxpvPGcWl6lHgzyOTQeb0ZkyabjgUoCYBBCUjawyYyttXV8UYATUMPhJf5Lv13Kww6vXRjjV4Cn3XajboWnrCNdHS9tIGpp2FQW7zx3jhAMc6ndVNMOJ6TcCFwMsM+xr/b7R75B93PCUWTZypNmZMWCYVapLEkqYy6InhDnB+GhyCmwMWO7J+bcUqDsuqN3BiNkMmyN0PnVOSyFiYqXLWBAWwMy5/Iz+DW2BYmPjKMXeaJvGcZ7Hcvwpujlbm3wslk/KVODI5I1EtSCmvNNcxdi6z7KU6siBlhM5UYahLPhhtjAh9t3WeSDrNSNrwlxy8NnNCcSRV5cMD8XN3obqEtad7LxagA9nwyQQNlElqLxJ8kfduHiUfD44ZajtXTfZaxe7w+bkVryLulIS+EU7I831/hpXBUFJPe8+cO2tiJkhdYcp+Xvr/mNcpFL2kVUrBV5wZXwnwNOAlXl9QjVekQw+1HVQEVl1taeXHZ01pDjT5pztaQCAJ0Rd/hS4+CZQ/yEohqtRWJ+D3KCyCwCmGSVK7N7NbcXqxYLpXBmPVSjNZLGsoVj5FlxCsAH4V+VRvWQVQBq0NRtXfb6B2qrn71Bc+PmLJBxnCKGh2hp9UPHAESN0H4cwmz99242fSFjRxfhh1X34wNUQZbrtnRA9LKF0/YY3x1lkvUx9IMFhm1r2evmuZus1hgxkGFYSg5WW0vWL62roVBLd9N0SVa+TP9prE1AN/YtTvOWB9jY/l0AdKlNBalcq2XMAzFpDLzKCr7YxzIhMSB5NYphv6WKcVSqbcNDRgyYBAxx1KE1hdQyqkhpoSZ9thG4jRSL1RGMVNj+f9zpmoYYVawmjZjnvZRTptXnqwAGFkJmhXOmUY6Itss/jNnbtkZCi+rkIQJ4pOSRXk6/hxJ0332eNWn+cKUYCfmbi0qd2uh79bCLdk2FHzxkM7x1KUch/TqZfQqJa3SeD1p+mi2dIcGMW+ZxUM9xmfzLFjUqaf6AwX3wtI/80uGI0eFYjlymLJ8pheYs9W5rN3gZatWT8dDfOO/QyOMLdeZcVlgN4sjuE6RBfW/Q2gDiX8twcud/0sIr6h8uXfZjyes2gkJfckHrE3zP3VeRfeujHqh67pNqcUmH/jlmY5LQ5TNiQu+XbIyohSLaICC1SVBdpFf+isJt+5ifwRBwbXhCY8eprWOw5zJgaqPTIa2t3KoXjJfeJsXMJrx4IRZEq2shBRvQFoZgMWQOGyxcDYut44NvSmzQh212NVfHQ0diy8gKC0sKGPaV4UiyqOmCBgzx2iiUM4sEa4NmohvaSNKfgfRhfayoxvPMx9VsraDz2k8rLW5Z4ksWglEWDQFPvKNJaoKC35MogwyeKjvPWlkDHN1LRnbiC1xzaHEul/sezoq7UveoNmR4J0/oC/RluyFBKYRBoEs8cK/7KwxendZGG562sTfe9oQ5804WL57YMx8vOIKjqOcCUOVB41YjziaW/YmzAO2anIjGdxWuexUN0qC3oqnnyo6IvLZCo+YXqwEmbRpQYsY6UTwmPM9fwzFc0FxoaEhFOfx8j8rOb1QDUPSQAZC9RWp9kCJyGdPol5Sw1svpK5t/3xFilbwBgty4tZYKiMYhNMixRJq8IhBRrmHM9ovUcvVMAgbGE+WvLAq1+YuQrzbOas9T9Ki9elLwoT+G0ORE176N0Qnqtx3bi6ZNSP2m9q5qLeSihdWRQIDGStRclox69cLImpdkrTLKY1vRl89yLMwwxPjgdJsiazdtMVSyfWP9+b4EvhoVmVe/Gb06ZIShb7jY5hgVEcLtZ8N/3Gk4b+XfMZueE47j4wgStLp7ah2jy8Yfi16mBCfoFpYu4uKUTqsoQlqLUzwy/nJPhvpWFo8PKHbIk1rd2HyhXd6F/4R1dA1DrZrhL1gFq7zk71mhBGNMId3wuyhNcNy+mo8x+VJeU62uTzd2J1CQ2FePZFeOBP366iiEeEpClLPiGujTOfiS2LXXlEGy2+0xPIDIR8do6hoj25SSCmnETLqTANMOeuh3XuHZp5X9U7cNhwzl0tDcE/zOTKpoTghlcrc20DUrayJL8q3MgL4DTqYiVygz9H+UPvieDeNNXxw5lNwA9VndCQ8FgKMYxXfg1e4/KeFBLVRMY41KlJQYLRJHA17tXB4h4EFZO4bskzjTK66YcBPJhmMbsQ3c33q3RJ5tEU9TybBJktnrXJmfrRea+nyriVWEx40wbueuSSSeLq6monMnDfAE7jJ7n9OQVqO8hZsFfRVGGK0cKMsuIGTgdLnhtrs8J8ocXASlQMylgUuXdIk8QW45zE7xsueBl6mb1N605mzTZW7j22H5fZtGottmsh1msAMVTTCtynDP/v2jS2hTF9CQkkMA7eGdsWJfRuzI1eRX2wKI/K8Kyd9Ba70sbIGlCIvlqshE3/SvYOA0DqcFT4XAlRltYdvvWIb5ygHiN85pgQPbROa4FFDI8DWY53pxNYzL+FnHmFAjtuLW+mnf1xRxIKvV5EI7d1rdjyWACRkf8TDXuLxfQQ/Um90D/9EM/n2xt4ZGOkr7+alaaGLQVObCJHWLDoq7N7a0sRZPJop59fdJM3z+BPGE0lJpt7wGu66yRfuSfYpug6nuMsogxaJjWQoWQdke6oXUN3Yqh2vV9qYaVKYPWgrSJ+uhUsIRPzefAIyymOZJnuqYufiKcg1JIlUrI5VnVZPh5UCsc8TD8iFxb3JcCYDRdnLVSF0ClTZKqOnuEj0hCe62h1ufKUD7oalbmtO+LFCaKURbywJHUpCj2dpoLZ8kbTkir9k1pMCYxGvgWRAoNw1xdgT9N0kDhwmPzJjeyFWPoetqDTciNFxW1JauUHwvuIhf3VoM6FRIz8frPA5+xQnbAgIPZK7A5U5gvNskSTeYu5UZkD6yolfexr87fTosEWeiKWzBX/8H7ncZXOKARcoDXLtlMwtSWVvwnhMcrOm0/GQ8CTSPkkF+hnVCkQ84jSqIcGQ3VBuqvklJm6K/oQJcTRWh5CajiwYxk9Lt0x5k53yBcs6ggTXOQrfxCJpQXqv7mdlD9MnIuCycjoYKrsYPYCyjRPmXfWIo7t2VFSe3U8IuJJUBVwxnPfNw1uY8cnTG49vxY28dF6lpU2j8oJUcTWjDOBeV05QYodeqock80JuPC7bWeaiVr2R5FexpeTKQj8UHFDe+hKNx+n9MUh96MxDAgORAwHj73w8hr0hDscSt/Du2VI45fRRQ8NqYf7nxI8t0DiVNfRufkOGqt7WHHo8bIow3aeml5MFqVK420IiU1XZQMRsgjXQHw7PcTtOx5HWL7MSJfPTqx0C48inE9QZw40XuAFO2el1Fk8KhzU0gKsaev9j6AklvqQhGJajdSuROoesiROSilFphBixk/3pSqKdlWJZ5kZMlieMQk6GEQfT0mxtbtzMwnMcSWMLstUtlqN0ckMO2aZ1OdtzByxc+fMWtjXC+qItUF5bdswqFt/8FVW1kJZagHNnpBLJBbO3cE1WzssSa3jRwqxse/E6rmJAi5q08KkqdlS1fCqZlsRJO0QEK7TGWFa4oV5L31i2ujN7jHy9og1GGz0cvh8B4OjTP4R8ITLlcZU3iIMIg2cWy2eH6cWlLR3yuF95+DcRcmVIKp2lIgWeYhwHw4WTl+V1NsaKx6BRPrN84xyy22q3Xq69Wl/n/GUviemxXnp8VuMVmyGaUUGA2Y3w7WfViBSNDkCam9IZdbR8r0TBVc7r3SzCtN9qhiYjxpB6aWImhi38dKypeOqaU9kv8XhMWmW9iN9fSxkEjLxVSklLyb5VkXlAzZwl4pNogp+rZVg1YtHZ8m6VwhQujAx56VfFSmy+4DMRtVjiYSXtsCOzvNZImtlh7dMXPiGO4t1eDnTNODcNoitiyYhg17b4vVwO2kmWr8OTee2nt+cJTRE/ZIGYTqJ/UNRFA+ryTNM/RAUBWSernKeKE955ArAmIGth0eMRn2oOXF2cWhaFcPnE4KrAB8yIpmQ2tdftOVG+eCV0q0f1SA8tVWCBBTTtkaPJ6OU9t1U39+e3wNiCXvW+U1QfLIpx5B2CDMMYtZJhNc7pPZJremCBhrVPcGEAcd2BOjwPVuBM80860qXWz3P6kvEhzoopSR6MnpCd7itgR+1WB7VIIdVCn5++ZUqknHYiVYz0XSrTrkJI+BhulFuLAy2pZI8e4E/8g5E/LkeHcWrpeBg4jays6Pcy5W6Cn2JXBBldEgHirVnVN1EYA8An9oAe8x7hlPiFJVSqC6NRM8ysJWprxm0gslZYEC7Q5X5Q1G1UaMczwlnhOq0kgLbfKzxqb5iYl0orp1MQYGwowfSr+S0fGbU8pKmkvPIaYtBeQtFOn6Q0TA2l4aMmjCpYavdxMXIaSkuwTuriA9ydG47rGFm1F1BCacyT7SxJGHtl9TMsTX7UHmdRZjKspbYX6uzdheRSml9uj9k2ks/fpR/b3WN31Eq2gGUl8gqJOuxJlhbpdTrWOjjGjzAxyKi+c4vONPlZbNSOlJSUw+Z9UUzM3NtUScXNGkQMN0zCgWmh2RRnwqZNmWK6lVcS92uikSl3mbrGPIqwnoLCTnKLrgqwSz2u/JbvtyZ5Y0JeVB7WeP3aXTqM+IETfoatFrITByvXoMc4S5M7EGzomZDw9gB51vcIjmSmAGeUW+O8grE4qSFfmsWldr2ZdWMnfGMnfGOjXo2wuDIFWJGpaHscPxsb/Ix3nxGbv12g4jSL6mOFpZQRGVt1+OpnhX8oC/DX6BMN1W1fhfEWGtHARmk4/4Hhy2D9CXubRtZwjNWZ8NVJnurM1ZmIp4BUW52JiGRTXp0l/NgySeEoYdrf6fz9L1p48ipNy6t0yldpaqzSkK9SqXNdepWGVPO61CpN+SpN+Sode6F9lQIutMgbczbwlFU6sp26S+Km1PVGc9axKDUg1c/KOhZT+7c0FgbfumOz/S10a6WjZXrXNfzty5atZdapngpZOvuJkzcuLXz2kquGz1xwM07n3oxjvqaM8m677bLH2Lgi8y6RALSItuV7aHbpp8T0tiS3xEHqRUHMH0Dc2TLnuyQYEyKYQT+IW5ZgjgvELjiK41KMNQx4Vo7KXELkPena1icyg3CMWba/1IZKsw5f/TPlrViPtgw8T0yHEvUNdvkLnI3YHhBu64cjC806bo+vD4uO4L36fj9NlBd8ceB5cYWoOu8WrE6DCCVXt8VOzxH5u9xhoaMWtsyswuBOKZcQEdwXLiC2Vc+ivGACMk80ZLua6wdpBHdo9d3BgU98V8lNnpc2ecYsdRcOC7GyydV5WdoV8Q+WblSRnm0X3lw7eEGGXMnni3fzpOfMJj3TpZTzY5ExpIQfi/zGl1uOxQglAX7HEy/JGkpw7JOTLJWHQCnwd6HEAYuWPeo63op80I7Uo86CB6wn5ZiK5DGlfJYIWtOGaa8cWhYsG/TqalSKFG2Do08m1OwgmxspGudSqoiUQNGZOyvppVbPYqoMjvBY0HTC+mkYawG4jGsqTC8NbSW2p0WvVUjblpKi1p2r3uVt1M2rp6rqtUiYWJcVkwouSzGm9aynNlJzgfkLdM5hVtSZYw9XWC5YEBR4JmI38HWkRQnjdDJgaAYMWAXKHohtx1ajQA0B9fLONtsirIgMOeF1X/DdjPPGlKh1uBymOBIlBilcFwFdDOHZtPQkh3F1F19nKUHR8uqtdnKjudIpXRXeGlLmVP2iXFdsA42A6RHikFCpzBHNhqifbKy3t+rJ5ppwR1PHnYJ8ro8bmBGOu1DDbxANYrIZdF609feIcn4CkBwktZsPplzR6bRdbTvRuU2a3TbwcYy6KmIckVcYvTqnKmZ4ayUYpZW8Jm2Pous/VDdq5eEMzbO2Vtq9lQI9HJgVfOcNysrPf7/oN/8eNv9sN99c/Vfz8tlfn9M8a+IhcV7DnAtZYIwLKSWPGVhYWFWYCR0La3XDiU3aZBg5H+21T4wA/KK6mReyKF+mLfxYp0L1I4A1tWSxWP/PTH+IJkZj6ex6q5lPWK+3xjCsySKF754ZKCqIZlUZILmlpceSiwDfCDI04w+Jt0cz9cYslFm08SneUjZD9G+dtpeJcMDciqqnhFgrNrOL8eXqaqMx3kh87l6Zonulj92MaTdj7KbYgNtMujkiTjjTRj1sTt1n9aI5cp/X0+ZIBskpGiHZJF8OBi/0i915LEWDcDikueWFUCDCzWBMIqDQ9XRMXu1oCq0kLvJReG8jR7PDgzepUTdoxOKX6zJk8SiIGomH6QBGG+OtqR6ABwgTk8O5DkczhgXGuI1wyR2TcPmx28O/G2tQLaZ/rpMChET7aVIzbTQ8vHSSaFJrXfjeDF6TL9+C6cZGiPc81kmMIa5eb403AKcXL9AY9qLz4jJ4/Wzs9vif9ZfrDegHtbUr3NB2FGQYqO8b9Tunbradl8TBFvv5PRhRv8wY1iCnFzu/aPA1DwNMsFCVQYELCWONYSBP+Kd7idrQi7VLVDthXNxxAI2PN163SXKaMIguxs21y9/xn9f0n846+/flpYehLYIQ8PsWkuCA9DmXJLnp8hYwJOWLbxiIsvvKbaQNrNPovOi8hnted/1No56t5t/+v2w1Id5qGA8QMIMxr7W/ZVgJz0e4QIer6903629evuq+ecG6wS7g6Jnbz+sXb169erH2Zg36+T3//fGdYPsbL+d20l1vt99AP+3XdDAwlm/5E8aDvUjKW7taW3vzYv3lm1evu48fD2beJAugESufYQ47l2RBNDL9c/eSLJBGrn9euyQLppHon9cvyQJqpMpnyhVO3/c7Soi2zqu17ovX6503a956u7vWXVtb77wCoelld+31Wqfd9bqvAGTt9avX3lr39Ys1mL4uLNqYBWgVMbESEY9qrUsDUr2Gm8gwJcoiwWQUNpJ5sAE9jBIp9SRi1+AdyqOR+V6QVF3o0x8kmL8uawQv12cke2g938yab1S9uhIPC+QLtsuwFVic2EyKzUBbOCmX+J/1JuzzeHWNBnnltzYuDaR3k2kRHZ/+oj5OPZVkmAnKI/mfE/xPiv8BVuCNvClBdGqjoFcmXUSC4XZI+1Mb8WL8PCJs9oU/glFnmPJiCv95Qj/dtZfr60v2k2v9AOPRShMsbT8KhQIHCv+bIovH9CyvO2+6vmusKY5PhnDTC+Dd3c76q/XXgPlrwOAlYNChKEwpChhZXuHx3bZtdDm2lsD+/B2GBNOXwJ7EPzv4Z5f8iewa9h7+uYZ/rpM/gW2HcBDVYbcDH3KJjxgizGiB0QbXugSd9AJ4Cy7rEV2LJC6w/rHz0vLxtfmNRyiGcxD6fKn1p9L+MXTvErrPaBazWx7xjjbK8L9t0DTLTC2bQieuFvdOSZHM99btbJFVGzcv2mhvtXtFg4QtRUaSkRCmap6zvDKBrmb4bjx35rj3khbVd5Eo7sSdLwiovUzCVJ1w7T/KToR60cimq1jeRTA2mYWQ5iPejEhUGUwwxINNx+QX5Vuxq/nyQ2PvosTMTjp/cLF9cBGNka2OjsT1iBeNKtZ83a1mg/qbxBeQ9UGQhiKMtGqzGPxqAQRJe+anRev0fHt75/QU5aeidXh0drV3uHe219/f+/vOAARK/Lp3+AF+D676J+/OD3YOz4JmlwOfnh8fH52cIegafhvsfNjb3rnCot2j80P4vI6fP+ycnO4dHV4d7J0e9M+23wfNFwr02/PTj0HzJX452zvYOTqHHl6RjpmyOWi+ph1eHRyd7FwN+mf9oPkGP+389r5/fkr675ARDI7O3+7vXPVxUPCN4H9+2D8/e390woZEkD852yZYnuz0B9B5h2C/u7ev4d4hyJ+e7nM0OgTtk10gxunR7pn4/FJ8ft8/GYjPZBBvz3d3d06uzo6OrmDw+/vwnYxmcHgqAN/wfs4Pf7na3jlBErMJuTo7IQO82u5fbb/f2f4l6LCCnd+O9076Z0hXWsBm5er90enZYf9gh30mg9jfedff/hi89j+HWe2BcJ+0ID9+i4NrjCNRA24QJUO45sVflUzncPWHOx8wlVarFWa3U7zn5SxOmMg4D/yAfGCXULTPq7C0g8V7Dys6vcd7D9E9ofIiSqADJ02mvELGKzhexLQscRD5BWwoam+HSSipJgX1N+rDLntRVe1WcbRn9N45YxYKEkp540O4fsaf52yvxcI8RgThvPqC8QvYtflB3xTf+1hMI98ZNhXKA8SSSDzZpEL0r+k01X6rerSpDpbqDA34b2LNX0DTmuG42YKgzye7AIxu2VHmZ600Ifpy6YaOKarreasI8QWKKtPdmYeA2JEGR51MFLlVVGPej6QiPpP1cwLwdnpzQ+gBC5B7rlDUjaUnkGdKW2lg99vBPk4t84VDt7pJlNTRf9HxCnxB8OAT0DCLh9FBfEcDqTgYn+j5ZBzGiY/JJrM8KoKH5jSPsuYwgvOCPMFBxYS86WHw4YjmpAyIyjIng/hCTIEDfPnBlDLwY5qvwNURo8mLn2vt9S3+aysjBCKK6jpdU4Se5KWJgrhuTwM6Jxa91BX4bkJCI5J6MqoGNy4F8m05GKYU1pKqA0Fc8wlwo+gMBu3iHGAijmRYdxxpbVvtN7TYBYgbrs5mXsomJfYf+OvMKVGw7SSf6ykwPWSX/cxgl9s6u2Rbk/JMxkloMJw/IsNnmGohRDyw0nogCi1u/UWXBg8gmk0TzO5zZXgO4qscWlkQQ4tGhH84Dvx/Er0iKli778l2qTsk1FVSNHFVOWj6Fj51sYWVi434FMv1thmsidhlbNFs0ry4obkqR2w1jsgyxKAiIFJ3vn2Df7uwLNm1Awb/NzgOsK27CdxzUlhA6nmPL47htBilWfwnvidTY+I6pkym3eP7LlKL6LXWoWFsQRcEGAdlq7bGteSkeg2q1OrC15+21RM62IrX+rT0kg7cUH97J+0YcCoWit0pR0UOSrGzmakPgRXZ5OQzEj9Jyi/DSql8qs/SyQRfiTlSJKSicPIf2cal4pWjl7S2wVlSIP2rSFi6iTrIvG6U0pvNGO5IGHwWbkoJbVZbTYlRC+5TZNXS84Is1eWInU4LRm8yRTOys2iaBKrtDT8BbxE7HbM0kS+YcNY7M5nHSfwV69xzMeGIbHJVVSwkCBIHGj2cw4yEzgocEtb9EzmFHMoXoJ2cAAcRj0t2AgJVekfTBCmHKhPCrrMvkyJtleHgcoDcbmDge2TyOoXT8eCxSHngC3keDFooXu8dwv3iil0iGP+6C6/7Q5DyCNBBf7s/GJyUoeKJBNo7tsPk009wihyE+R8AdHr+9nDn7KB/+osBlcG0RRkiBLcLkMb1UuYcAxI5QGyfn5zAJQfFcxMbGtSQILN9dLi7986AmGTxHcwObef4ZO+gf/Kx3E4eAQ2HAu50B9oaWCGTYnJK0kAB2OHZ8enOyYcS7siJj2GKMEAUgJ0D0HH/9PTXI7iH6JAkfo8C2h8c7B1WwKJN5jGsWgDDjYBynQUiV0BOLTA5cz08AJGTjvT8ZO/s48HRYMeAZJ556OENgIOd3f75/tlx/10JjgmVKFcg4N7p9hHQpI93Ph3y/v7+V7RbGKa3NEHaoPUr/D+8fQ6O3g129vsfzVXAJGQ4RHEZwFXtbX/7l/OT/Qq4AxL1SwE92IFTZ1ABvYMBujBFp4TfOdw+gt3xrqLGWQQyE/IvWeNs5+B4v3+2U1FjW8ZmUiptn+wMYEHDnf60oh76+kElTidekWkC5tHq9HoUYXhMpdYp3DoH5/tVOB7EidkPLMN5fRyED6Ua/d9sNSZptE23Mu6/ox22lQ2oz2osWObeRONwkHLJsgZHvx7ylG3y685ve6dnp0HH/L6/d/jLziDolr73D6+OfgnWzO+wGPH7uvmdIYuPeaSkzB2DB6GSOT07gQVEAUscsgKuzCQrAHVeWQFUZpeV6Ok8swKszDarhmHhmxWgJd5ZAWdjnhWgVuZZAWtyUAXsfO/wTAKdLoTSWCiIpju7sGgGfJFqpUzj07EUHez9JleqVkJ+7PDFamPYYl1amHTF+DUuvQtsaIcjrJWcnZzvcHRtjF30XMXHrRSz8PGqlayz8eOj0zOOp1EE93OOqFnp/IzT1X4qiEGUDoHdo5MDsz9RiJGBgs6cwqv+yUn/o9m3ANk+/cAntVT28Wj77Oiqf7zHeZG9g8Pzg+BFBcDOwdHh9sFp8LKivP93XFWvKkr3Dnf3z38bvA1eVwAc/OfZWfBmEfpXf/s7EqmKhMcnZ++CTmcBDlcfukGnWwlkn0NxLB/t7ppTKMtKE2ie5qV2LSf3grVrO7LnbgvztF60N4yjem7b5iltBS4f01awK3IPQSuvgLskO+SKQ8JZ9YuC30ZYDk6ab9MRdxGnp72ZyDtK5HVIckhHXkkMWOWuIoDFzcSAlTcWASovKAascnMRwPSeYiJLLy8CSF5XDEDlHqNgSm8tJUTZZUYAysuLAarcauSglDuMOSz1eiMqiKuMAS2vOAJUvdEY0NplR1TQLjZGDf3SI6rw+40BLa49GmBeAZnroOptp0wTeRESFZRLjwGvXockuHL3MeHVa5GoYF6BjEqlG5JcYPImZK4w5Y5UAqcXoooa7LZUqsTvRRXVxLWpVJFfjyoqittTqaJyS6qoq96jStXVy1JFfe0+VWqA35kqKosrVZm+7OpURWF+sypXZDeoqor8giV5gbhImbxA3rAAWAT+QxVQq8yNmXr+Niokw61T5VbhG6jAqHdEWNQN9qZO1I26IbLmLYBK/7oCag0/t6I2xp67tyyqqR7mMNNPB69QxyAPgqUGERjhbr4H2fIlUGIr0dLRFWfRT0Py0g1VDkIgq49BnpE/zSDK12c5ComuPgx6gv88S1+72CvrnqCpoy5lip8G/bLKQQ5BomtuBirv/ER7QVeHqFuBoioHkKsDKMcXY2Zehebdga+XhBFLCVDnyFKs+2loUtb9SKpIdHW6KMN4NGUUkVenjSrD/jyMx6LwUliPgrJOIW0wj6aRJunrVBKy+09DopKiT9JHIKsTR47h0ZSRVxqdLOol5aehjE21KYmjoqzTRxuMSSLh1fXQet8/fX/19nz36nTv7ztayOaHkv2g5/AWSX6TcZrc1npOo/DKoG6vvnAetPuiJ91BcS60699PMxlW5bGcDQ1pfTr08fyc86Ffx40J4Tfsn2YuTOW8nAaOqj4DYgCP5hdC56CzC6FJ+KlIclpNk9xOlPzpVMktZFFVJj/TEVx6ENGOYIFy6QiWg3nKESwVSzqVFEXRT0Mky8OQpJGCsE4idSSPppCqSTMIpGjGfh4KWV63FBIpKBs0UgfzeCKp+kOdSqYq8KehVNVTn6SWibpOsdLAHk21khJVp5yiEP157sflJ0/lgiwR1kmljuTRVFI1xnYCUf3vT0cj/XW2TCaKtp1SbEhPJhbTl9vpxRXfPx3FzNfQMs046naqiYE9mW7iycBOOa75/+koZ773linHUbdTTgzsyZQTbyZ2yinvHj8d8Sxv4WX6KQOwk1Ad4ZOpqD4gSULyUgxIkihuyiKrUVA0HLhWRY9oPLbNkvq69NNNk80AoTxP6hDsE6UN8skzpb3V2dc8f2776ShpWmaUqchRt1NQDOzJ1BMPlRUnOntv/PnOdMNIxXKqM9QrznU+sKef7PyltoJy7MH156OcYbFjoRxDvYJyfGBPpxx/qjYeK8S788/zWFEyXFIeKwS6SCd0F4mva7txMmSmSxb6HLWuEEC6eQszJ8+SJ2ZQf8DPUAmzE6WlGixNTLnnvYR4fT0U1hPKREKFlq1HGBGE4xMzfEi2yip80AsOKrEJ5UH8PqiG2GVlJk1LuUWnC1qmEc+0SjQ+I4aeXGnzYKULITvuPENwmLEVNjZlocT5EUlfjuunHgk97Wd0NcyjIenKi1ZIQkp1fcfJ5/QPHZM6Tg3PeWIFKJRwhTYcWb5OM4CjDZRnE2IxHGUoAM2PS4vkqDXTI/uQhFJgcTaJqUcF2nzq+OimeTR4v31suCurud/Uh00HYXskFOtzp8H4BQnilaFrHdKNlAihiDUfTjFY6JKtK3VPyebYWxq907P+2d72YxCc2K85WnRm5rpadxC4VTwUW6M0LwKa+UWfK54KVHDGggZyEzNQNQbjwqqU2m7o2utqlMVw17reLgkVFcn8bAKIExE3cEK4RgXhXBKNhK9axuMDgwClvNG6Zagn8+fSHDRq2NUHzrpdJbyGryZQEt3cYnqyh+J9mA3vwyzaG5Y74j7hclIps8L/9AYtO8MVveCeEqw5y0vDfuBokFIFD8FRRcdFZcf1wtqJgo8I8LJ8d0uNE4c38wclTxrtE3ej0T5yHxr9I3Og0T5y7xl/YHWd8QfL+M34gyWcZvzBMh4z/mCRu4w/WMZXxh8sdpTxB8t4yfiD5Vxk/MES/jH+YDnnGH+wpGeMP1jkFuMPFvrE+INKhxiziHvDmN+ZK4z5mfvB+IMqJxh/sJQHjD+wur+Yn6nviz+ocnzxB8t6vfiDpVxe/IHd36X8nTi7WMDR08UfVLu5+IMqHxdbCXVwqSrh3i22cuLaYitQ/Foq2yVOLbZS4dFiK2TuLP5gni+LrZQ6ssxFlnux2ICYC8u8fqn/ij+Y57ziDyo8V6wF+rRYfFb8waMcVvzBY7xV/MHyrir+YFk/FX+wrJOKP1jsoULjglBP+a/syIXTtPZpGo+HpUybnVZHpNpUgGluu9PrLIqSX+NhMZLSXE4+tu7x6zPmuE/Bj+OHaHyCV96qpt5H8e2oKLU1Ip+XaSzOj0dpEh1lZ/huqLTUb9EeBsd7m29erq7ScLvhQ73fKo3F079RpNznShMbna7a63U4gU6i0/jP6Dgdx9df1H6vxDXdAOIt5NYWQN6ZUzcoNBLCWLfh8x9vUVbNzydMuDmIkqkFlcEccBWpuc2q+M1rUMcUKH6cxkmRH0fZuyycjDDpSmQj14EVUkWvoi0MYrFJgvUuaiwoNjfbbhV6GOYY7ptwY1kKRwO8ClGzVYpts1OJrlHBijPCnETXaTbEGqdRkpNIaDZ8baAGrtbWKqhqgy2jyFa3wShKy5uUW3YFrUcw0BFQ6wWFrUuToZTqUgBLp6xmda8UwN7tgOToreoTSi0dYp3q3qDU3hWJe1TdFxZbOiO1bCyGJkpW+7nFcHfheBe29G54F4815ia/VlRBlmVWwG8WcPy8nWLoyTL4c53h5pwRWxm81vY0hi+7IQsOKIDh4w35WAX8a5gfsfBSibWiKK1qYU9rgN6V+6jD2E7TP2Drk7Yo6C/Rl9IdeaXTI/5Ju+M0xHW42a7qiHdDFFxLdUVzARG9XHlgTM2gdS5u1JvtrahnIR8PxfVOpTeN5rm6WsCiSm9qqHGcJjwO11Yf9S9WBL1IhoN1vbWXL9pubw60k8CR71A4lUYn0ySBJo6SfjLM0nioTmOcs49qhV+JgPE2vP7jlqh6ttOxsmqcv9y08f8cSxVggJEC2Zk81HI4qIe1v7xu4/9Z6hyHQ2YxwZDqlmH2EtgZtHEDl9pf+m38P6eqUvUg+vh/ztzObCNxGv2WHatyUzRmWzUO7far7nXoVFU0wO9HcRFVAs+h/YJuzMOh266CLHOy188U5vRyXr1lmebdNC9IjpDdNKNPAhpbv9aKtCO7XBE4O4fAiLyUUVK2QMMg+yt3qGI/iIZxWHfqcOo3ibpyippKkslb2YENZziJXcdtkTpR7rtw7G1sdLg+cnMTAyyzdDpxM9rs+CKDZiOCUn9BZ9mczrbiIOtFMrFs/Kyu7N6tijtBryM4Ab6qs8PtOMzCu1xVJRKN8gguPvnbLyQpi8xlH+PzQsQHgoHkvdxnDvsxc9g/IyE3nZ5DniEcqJC18IUw/jQtopye4/zEJaDBbmtb/d26ydI7NnSjyFObapEOXJdGi6ZuryQQ4tyuLUe77AR+2XvHrF6L+sZl/5i+lZuL6AiWK8xxbkWClS3E40Sso7nYSBGLHmt7SVFf1DSRKpdplYqf+fItU76zTNNMxly65d10PMSgBUusRwoaWFpkEcln6gY63/vOvWPunA/4FnkdjgdZePv3NL2bg/PH1mcDeIdEah1akAdGcj6Z4CNTHmEIcwdVlY5GI3FZVS6pcyk27xr8WBR0qupc+wdTWD8wFqwJDfZpdI1vkzSL3qIWaX5nCuC8la136VoJeBDdpdmX8zy8/dHUsysXnB5Izvax8RRy8/aq32/Z2w1y769FS732k895kM8UClfczb8XqZzf6yvaB+RuCXJKYZC7BmZVCosfSzJTG8JR2yffBHIqbkORdI7byHw/wcQV3WwaEHponUbFoFRSz91WMcKrIKOcvpJ/2MI9z6Pz07fzd+CUwDxtm7MD2oELWVmyyjTQ8z0OJY4PA4Cwm1y0ZWOHeg1lw/NaZR5gdJJHH+KsmIbj99NPC+kiQZ9GHkyp4fT2CWbwNzHkyUq8C+X97ZPtM+bnA8sRmXB2TT6sGBdzUeArfwcXlz61LMOlgSp9/MRyH3VfvCRpi74WQSzKMwzPvfHaz6AA5PfVztbam9evu2+6a6/Xfy8wZ0yP/FftBdMeFbMyJnwc8Huty7OPUCT6LT4wROb3ZsejHYu4yNh/HGAqpde/Rxf1+Hctn1vmkpRKl0zhAMXNjguwbeXGw7QAWu5LYtYFq8bPWixHJWzdW/aX24ifddefvWzj/+9ELFl9HjgR2uABm6VXkPOzbX4L8YfpNUke0bomnaE1dEDiRftOI4f/TkKQ+Z6rV0uOldjHWAMGPwSmNIzOT/YwLVSaoFGg0bjbyidjYAHQttzpOVAt3+B5AP2cZ8NLguwip5mS/IRQDqjWxsVYc3w3CZJWDkuQpdIhmp6kBXek6OHoph6RrELcokQBjEQ6Lp5uUEvrMvN1jUvgfEzhzw9xDlsl/pMYMa7/Gn0SMI6v3NGCJPwc34bwuYXOz/1bHHmR7qf3fCcJBJ2QVnFcOJN8RaUHy0pcZH31Bh04fcza7tXeR+PPEUqJXi0Pk7wJPcU3jq+oqugEESXZXOWYTccX2NuhW1WtEdhqr64qyjR7S+5me2sxUA/Jqr1wbSmGSZ32M4Vkz+tvXj7rtLqu+7zT7nV8qa8IOt1nqr5vmZvi8eE7v0Lx3ml31/0q9bi9EGf0Vdt/1DXxlyia+AufdNr+cs8oBpxV7lFg5r5wrRCeyQ7VlbZfOkkowHxFwFmKuUH80gXNcfyygE47UQVphmtJHll72W5r5wZZsMiq/yz0N+BBRMKrU6UtSxbvyFy4/7bOGAcgRBPc8AQknZc0A4nw59/sSjZG03nGnI1hUs/4IrmUAhaPiJ88W/fgf4111+u85Bnn44v2pdJUR2mq2SGNZb8H2B7yuWwF/pTFlzq+OU9FVsaq2SVN5Q1m9k00EtvsTKpD840OSZX2e6SeVMm/ca7p/o54NhICI+Db66/h4Op0Njbq/Fvn1ZsufHvtCqi17quXBOyFAtZ9/fIVwnVg74osx/yk2Uks02ROTUWg/KoZa2BH+sFTqAdPfJEDXgH9Z/Xli+7r9jft1M5dnTa5SZuc0ya30CYv0Sa30SY3aONrs62vlRzWSq6uFToMBR7XTX7J1pmyNOjwY3X4GclX1247Daxiz1S37urCIZ83oRyP6Lyp0TC01NOO0/uzaMnZhR9j9M3a/jIZyYghJL8RpqrQn/1Ezgv63KeAFEq6DPa2hy1MsrRIr9Ox2QT/TtoQQKIR/oW1gse52QJ+I7VJoaiJv1gtRoloqEQ60ZFg30kzZWiJDQ+USdu9HkdhtqhNhdaC4WkAlYTPS11YEFGaL084wTIcDks0w2+kfVIoE37DLz5fNOKGEd0wK+g8sVAW8jOrRZN20zuGEVCWFZD6EsxI943nBes/VF/u+ajxtZ4XKsTAx3hSa5slUkkTktrEbICk3zEAB1F+ncXEvL8u4+NKcHrLrXVYoEdnW+RqabUccgWrdVkZq4aTeY3Zz9HfYcv4xnLfJFGBv9yGUzv6hTWzZnaRJjyziuMzyYGDYJ4mljUmGrac2ayUY0nN4qwkIuU9A2o810hKwmnKCP8SWQk0yeCkT6f5+cl++WP66WaaYz6poVbMGUDXM/aygCB7VDbHF7X4QtajLMd1Jn7JBbPS9pSFIADI7AFvff77fz1/3iow3Uzo+m6ImZUIC+3QI8h//l/P/2oFaHtwFfQNbmYOJlLHEquopua48q2MLAmF7WZVu78HezpTyZCogwxLRGAv3uNAe/FeaffG/DxgSTJ/u1Nyl3bhyuzc53hrBAnP4YNCZUWhKyviQP3Q4pCuFHVIoClLzVyviVC0VkJqcepYaiZGn5w2LI8yqY2Rcco1U6MmQNFaIeuzGFlqhWZ/IE2QWrhk2fnq4GRY6o71ugjleo6YH0uNTK8hQCt0Ph7KUn8WmOGPbOyVjjcmuztzRRZowg/EwytWGEW+uhs63nGLuDTB1uVuZpigCt9fub+Ltpvrrqs6gWD5DTAKEs7Dp44tD61j2RhmX0SH25XgfqvO+rpYuawt3x9wRMb06vgofJffYgoyV9vUa0/hSm6vXq4Vza1USRNGcZkorC4FFtE4dXfjVDhPbASwd8ydQB9ashbJa2l24X4He2b8EcaSZfFnzGhMjw0+ElrOmTc/NiL91IhLR0amNd8VIggNtFuWQojuGQ6vdBwpQWICncs2nN7z55xkWM0vCSaM2gULIyALgEYz+dr/1UiOrPU909Y3w0RsfUNilR1aUHWVU0HBTH40zgYD+0cLi9AfVv0Ph/4hCeXpFNoq06dHP63D/3NoK88d5azRMMcPWI40ZcRLogcQVCrj+6jU2rLTChCAMwj/+kG467q+mWUD/69N7V/w/znLzlbVehZzoQKJ/UHOLZigmW9fLIHT2Hz228XWVTz66+Gr+/7KzCH6Gdi8VD9TymFH20VtN2q3hQxEnigCKlDzQnOP8+8E6DOzF9QgyMfZzHuIdfXQzkN0DSfjdnp3FyZDisjMkkqUJbocRg8it0iaDGMSYpwn/kmn2XXEf1GFLE+xQyK7d3jmFtoZujILRgk4Ff1xmN0JlX9d5KInvTJyTEIW952JYrFmfAiz5FA0UBSIdVFARVLoqVQYVgjb3BGDq2pHjt7elCjH1j7wtylbS5RQipJYa4cqiBGju2E1LpKeOhJ3Q6hJQxlU1KUzYx8DKUOvWPI4w8YjboSSAoRLSQB95Ynv2AolsGiCTQapz4r0yvQj1qRGsLwipRmp98Gy2sk3rCXiQKBGbaPtkuCjzhC/Evu62qeoFsJFOwcMP0d05zi+QhjSBQ+ToXZBvlHCCOIrpJETwogjgUzyiJIZ0QbLa8MKmt/B/sikgZpCFHljDpyDvUPHy9kT812cMJooD5h4ewa4/m8KXPigw4nLb+D0P7yTgCGG67uNNOCZipBc61/1C7TPUIRhbEJ7m3JySACDlbaBIsIFCBjMh1xDSAQMFgCuI+AGQm4sgHxBIBGwCm5Gb1PiRRKW1Er07VsinyObOieTBRudaO2ZXDZMrcsvWP39/skBiKp1ye0aHVexnfSpcJuC0J4mXKaljJBM0Eg6S7vyhFIAbrI4gjXGrA6gmTqmy1aMM+OGHLVmtAl3AnajM1erH5IEuZNxCLvW+evpzuHp0cmH/v75zl+BikojIGZrkO9/HewN/up480Zh1jnsH+xYqujjMiudH+6dWSpN0SyjBIw+yntne0eHf6VJqLXCQf+sf/bxGFHIzLKzk71373ZOeEcmCUsjOfoVQI9b+N5zxqHgkPAxkIaIKRC6dR4tY+x+ZXcb+zqB2cSHaJJNGuarRrIeD2thUotEQA2QbMatO7gbwDZ2Z+Z5C1LBp2y+UALCQlbwwxx+pRPlBxYVahEVQ0iBRTeYFaw4nZRL0wlg82U+NgdRdhtRJniq4qV9lxiWwAs7OEpHt/zxjDodnkTh8CgZfynrWcNhCt+/fVuhH1ISl4WMayheJPfTcAhtUG8Fs4kKMEsTx1l6a7vX2aHIqWevL1S59prM0puePW0/oowQn2nzs/QwLeKbL/z1JEJbk1LpRXQZw3yFyTUKZkXBcnabMLj0w33RPYj9mA19j1OAwMXXoYitofl+6G+6kiS3RetKL1NN6Y1aQIgyvO4dZdqelXrSSo2+9JqyN92ajd7tyD78fGuTYtiq4rptBbB3OL37FGWtw/BQNHIgjvMFjXBAayNCdljUCANUGxH6sZv49n2Yb4/C5DYacp3N9c3t9kib3fx0OsGrVjQUymWUyU4iDEXDEsMJrTPFAH8rgV4yBbSuxfSClXwdcXcL232GxzbC00Bqa25IrvXk+ov4JD0aeOJE2P04gZgObKVjYMd+Tyhig1T5VvownyCdKoJILCgPkl8m4z+3cfON9f2vIQqYDcd009Nd93aaK01UF+GkvyNSPmLR5sRBSkTDAdnRCiuxlCtPH5IB7EYh2kSIXnTWgJZVwI4UciB+u0RvqX2iw1Y+3mAMmX0Q6bFnlMGA89+JE4GUSiKVynGs1oq8gN1b+BrB5YW3aOjvbTgs1QKBnBDg4pKBTzPtN7PPFb+JRjG6PzCqsc/bRm0ObTSi8YtA7lKvvIcrShmbKJdWHF1yr1acL21zjslxjGcs0XewYiKU5GIc2ukhvubMI5n+Gt0PD1WtKRcLuSqVh1KLmQkmsy1sw/0h1qxy91CmqptWLrlq5fKVCu05GqekLdItSPCIs8Ov1OQaRz7R9jJXHdlFdknuEA9xnSqivNT10HhyNpuZNZkFpq9UZ7hsFI2O76rfJ9N8VGcNl+FJTy7R0pHvLA6hxuW1CihHMEhx8RcSWBlPbYTFZUvTGERqv4oaQe18cZO6jkHgx1UKj0OO1VIwk6qJR6PFVRcCJ6aseBxKtJKCkVB5PBohdoYLfJga5HH40EoKPkKZ8mh8mAJFWVOKzuSxq0pW1daVpoV5wspSFDT0gcJ6hBhbxg4k61sOGVsLFjAhks3rvlTOQ/5R+eNqkP7K4nyKUI5WAcD9yt5n6EVzZWWldjcdFzGcvsplpIb1amFRRHeTQkRjm/GmK85uS9tVbdbCcTFKp7cjFSDO4TMKO18ILNphiK7nyjRt9gqrHhENp8eJg++D2E0NrQKJZyy5m2raj1qRspJ0ohXUh9EYDltyGSelTVYd1Ta78QOIvWuu8qJafSnjcUA1UUmLZYgnXYtmL5UgddafR7un6oP5MpkmN0sYIkAdpFkkNA4p1ziYlCNzdQegViWD00iljoHeIqu6pJn/iNxSZ6Yf3yn0MAPJtkeP9U7bSzAoVPmahz4+3Ihxs1xMbDB4ebNcLmWDNIj9dIOD+imXDcIgukgJT7kCIQR35vnZNj7jbwZszlZXw42AzhsXGfTRy7P8LqqHnmhPanZd10aeqnq6Ateoy8ZX2ae4VqIqayNZXc02cm50oC8QdWfdhxnKhL1arQAK5MibarcplmBQTvR2wu81orPacBpJow7NNjtoY+d4tZtpVoxg7+fxXTxG9xOMoJnX7tOEaOzJNkI+QAWnXhgEFC9hB7AEYsPpZIz3rkjBkODzHZjAogtdwRCNyWFrrsNFSAvMRfuyxZ/yvNAKUd1ysyMro3J6LveDzasyv9TC9kL9G2N5wPHCZlpmczYVB+41tubRQeUrNfKZzxTizzAEcscqgOnf5XCtHwVjMURvCiI5kYlH2Pp0w9av704brJvxxYiu4yy9ZzLv/FuIUY0gLzaxN2o2Cae55Vjcbtj2L8WW6b/0sotbOUsb8zDx3dtGw7/d7FTwCPQtItZzt82OnRtUQ/A9r0HABURVXlyJExxNXNFLhyhM36JLSohOrPKhqk3909iyv9OIsNlmdxg22juTROqa31RBUFUo1rMbATGwHeDOflzVVGHZCuwtiTcaq43GjYZwiALO9yVDuy93ZqPAV2NX84NKdeqr2nW1nirQKMzomndArLAqFxK0AMs3F9KEFYgzljhgcqVlwsqVgW/BHdhUkZOLsaEfb5bBfE29oc0JN+3MXNSOXIeFrXPPUiVr5PyA4noS9ceChtnS9yxVlIa5wkX9sQhjCuVZqpCGDZVBteo8savOkyVU58lli3owHUb32P/bcXrNYqtbprD8ac4KA8baxuj1M8UK8Vo7XfyIcHOl4CLStpn9QsKZV1mlVt2UXdeGv/nekUc2bImKHUc4t3nTwHxN7lKqUP3+xFy86cWO64hNJbko4NHdifp5F78m19wKoSzay6j+/H1GaqELrwyfk6sA6ol3BSZGPW5Nar9HAD1kTXpzQCP6o91dPW+A0p9WxeyM4li3d0YtGOvoUQNi6Fm6C/M4EleNWDxuMmtUkDyuybsBf+aWUwpgNdEpMsyYXzeIBDKjCQIMfTyqHJQZE09gFIAt6NJEqdMttP3lR0BWMMs1MN4HbVX9zptVl4dWD00KVuwqcnfJtSMfJwrfyM0wfz5FxS1jfntkZcxfUnyWQRCgABGVniJ04qUK5DoeNX+SYO0DMbh63HCUsTrc2pmvckEbA8U/Wyc720cnJKTw0WFP+7m7y1+CaCuYmYHwP0sr/fOzo9Oz/skZbUX5KVuJrCs3esTKFT3iqo2WWbV0f1e/47IlVKXkKbG1b9/qlQ887blPLy6XbaxslgsydyHc6OSFQnJdZ764TSJuPE3/MadVry3s6VE07aBWAE64PJirIPGlqr0KZKPTbvuqMq3yxY1tR/no117yAau9UGHUFgZJP1DnEyoIc/zaioYvX5lPPPfrIupS3Ujuhxsd4gQCV5Jw880b8vebNwv1ZFBtq9PDGltv3vRCZsVS1Vsz3wy61CtmLtbMpmvelfQuCnPgv/mPUlRxQTEEQTHc4IEZ/JDrj8ZBchFa9EcwCWNFhTTmKiR3vJGtrkYbcYVS5tEamTHRyGSNOrT5BD0I2ob0xkFAkarSyCyrjhl/Dxqw7cdevVrqDYL2t2/jTdstfZ6oLCVVdwn93dgT8/ko/Z1S79H6O7VPRX/n+njYkFU2kmbWYxI6xZvKL2yR0e+3+vd0Qj8PgxFxALgOx6iuiRRNkdOQRVTeZxFfb4JpdZ2pvc4kuK2uc2utYz+qkrSI4FbwRzyZkBOLbutaWEA7wwasLQDAXZCxM/wG6rRaLfhrAqe0XZGszgMWbY+jMDmfKC/IdJfPW01k59uVCziHhhrDBGioq5FaN+OfTbqB4gTfXtCxCeQ4x1+gmNyq3KnoG9uorqopCp87jcT2nUlBOQkpLKwYn6TdbC5QnerayVoeXXs1cn1E1jKsUdrch7l9UEsi4fZ+CLk4Webrdrr8beHpvMobP1IxhGpXUwc0fooOqFzpsUqhcguN0VJaoiW7nqM2mtf1XD3SsqOuVizN67rShElTqyh7YraEPOorDxOG9ictaX/SH6f9SRdrf0AUqqU3louFoagFic748LVCKUtqXks4tUFKEfszqK7M5XIMvQQK3ZJNr2S+l6ty/2O6QsZ1zerZucYTTcaslnRzTAIXWDlqj/RWRrhBZPRl2qrU8lnoI5Xqj9Oqg4xv3j6I1mK+YWJbHPUFHPXFHM1vYdf8FktofguyPRhiyqsE2nT5S9wXDavyX8P8PI/MWCoVQ5wNVcEGd1NZFtoQ4edo8MKgDPLsTfs5oLK52fbVvc9N8yxtWtgQXy135huY5T2oWbgGP9eA9YYF8J35MqZ9FcDkjagk9f0w4ujrdRGNKh4f578azhEaigXPiXPko2LBO6OtUCEqXi/kMmYbGug6k3pOm126yOirWoNLLQ0FWqhAFdoUYhJuV0FR3yGbmakdXndQKlmUV+m5OIDSFX8RqKqivwe4ppG4beTSu6XCLHvLVCkv857AXhJ6VbbyuiH5g5EYu9LqvaR2ZS9B1wRgSjNuU30Aph6IpCmSVcEqJ1O3FZxjk7+6umJFbkssml69Xh7iBioZzGE2y3CbL+Bazbi/vpLZs4En+uEPE3KZ/KBBKOkb/gVDkb1hWFLr4fv1O70WFvkTLOWoUW3w3vkh0hcRWeXYRQjAqqcgPod2sohSi5UnCUg8J+72RnsZQTS8xjbRMBNoQSL2S4vMFZOsbBlYBlFf9uFWGkwo4q769IEKqk+UbjIYNzsURNgVV30K41wj4knVlvcymvsOJodJNbaRbh9C7TNIaNebcQr9CtWaK52Fn5NIxvz00uUUcQurNLalrg3qI1whrJdy/dplk4PUi1gSZM3cTwISRn6Jul2zruslxHzJOtGwfIjimZK8BqcvCu9FSq1MUYlkKnH4BdB8Y6otJcEbmyz3Mpc9IsiTcHW1ClU8SBHVL7yvhEjmdPmQKHjU3a1uKe6zJShSmuMC18Uc/vhr3yvfvqlOL2RFsU+2l755dt7STmn+Kirm3DfYTl96G0RcfrVNQ9uzLlV3ZiXg1+++a7W0FnmSeOZnWjmnP6xfpdWh0TmNTDau6xYK0qNNdWhcsATZOisxOakKcbZZmRoliy1411uZKydrdxlAbzkzE2EZsFh0zRZJq3mADCb20gXWCIYWngKnrRvmZc8EGKKAN8tIkNUQ48JJYwXh4GXxX2xTO5ryxuLmG0x/u8B8Yly2kKA1Qos9hWE64Y248WrLsFtZCQwDCW+qgUoLCQKqWUEgrxh9+wb8n5qBeDkT8LeSIO/B4cDshupJ4HSe5xSAyi8ZfZAgppU7KJjP46se6rTwCYYZUcRFXlNXELdUjrh5cs5tRebatuQY+2mljUq3ZCWIn4RXauJVM9Ysxy3muCVVuJmLPZHocbrSg2D0/RREZ3SCrXJSSksUwPPoUNjbjA17G92+hpi0r0x/HEqqMAlrj0p8NozkytRtdRjZmPUMUo8Sz+MLkuDKlqT3fROe26cbenniZBfcyi61WhaFNssizsrLxkUk8IduUyRuyDISIn354kdODRgjcXawciMjEEsJhreLgt7whAxym59ldYyDG2zSM4wAiCIsmbklH3q+7kuajmTGOxJNcNM6/ezlWSYKzC7B5B8dgryNoxW7eojacFSG6RHBXTfZM4B5qHbj6hCpbsboTVSy5Zjnox4Ik6gKgBjO0or3lq2q55Z4jk1tIadxkT87D+5ZAdBozK2/0WnbBexejaQ8oLYoinEvslT9FlDn0Tb5PtBHBBDkPd9OBdNnxfXmjiYQi6kCYDPotIUFiO5vH1nsNmye95FhF2Lzv48MOw5df62afcQW13/xVmkxTYktKBlvm9XwDB9XuP7YbCO0twMpj7HUQSWnc5rESPOVp+679cha2SqDZ3YZPOMyOEFbE75hH8+QNwCdsQ53u1ds4W0dNTt+hOlsombTLYLAGuvG9prDteGR16GKvNxI7K4woZnJjzUYtoFmZU2zaZguFdVqkFY1BqwK41uDHeFKbwSwB/kHGS+Yh4fpFbhHgZvv7x3uuM5sZnHABIpZw+G0SXTMKQvAVIseCsAnr90WWhQo92s+nYDwS4KJOA5l0r4WBcI5PAIpYae/T0OSOTZtvR3GFpek0qN6qWBPNk2z41gPNuNwqnA1gMoli3brIiIJnkoBeZ065tR2naroDnPjNLRt8Q0qoxW0bdEHKmMJtKtjA8z38QeCzLx9PaYpu/5iUof3009jzNWmXuH3SZx5TKcjd3KBO7mAnSwL8dYuwoWjmao1WLQOr0U2dj2lJ7bpC6/jioBWYhkQSbMk5Vxda99lgCq93g7slCwJx1X1zXLZThXLw+Bf+4wDKWQiYb/U7+ihp7WhZj7kWfIqEiCaoVZohjvhTh1TozjMVEeCrJTCtb8/f+twbeefRUsJu491UEew0jGcskrzTjMNtcohlgNljaDbVRmCaETx1p/D3VhpmByXmetlLREnXmqklfhiDF7uV9kGB4Ofv4Y5WYHUA1FOkG0Fi7NIQT26hHNpdbW8DMnZw/qBwx2otw1cnXk6atOljdqYrTJB2bQpKMSXVvpGPF1dOI7gduecwYLlqTbwIY+HfIA6eYFaBWFPUjOpXUBhW24NJBcs+SzcS25SXBPYoxgVSZV0so+VUDIfwd0TD4RGRPIQqIdfLCy5SA4gJdR1AMvv/v6+5ZBgARxuHfZ7PNM40GFU3MNp0ZdPEOxmxgpqNLEX/FOQDCM9eSUrX8T0dwdSHk/6POS7VK9x3RsmVmbPzplWJpRN3D0gs1RJYI1V0FKtNCV8TomJ0PZTy7JICeOoaG+/xddKajJQ4tevlfPnHJZ6xVUi7/2SpPcJFfFkrEP1o2R8qGKjH/dBlCUWxOx5Ry4UzKdGlrLahH6z08vmsjcqtMaqjMpS0sYgmfo5jyTFUv+urtLmQhGMGfjI3oDs5nqEWXq533KkLzm6ouhgeAA+ue62tcdypuCAv9g6NJafrm3kC7A+B0RJPdn2XpfZRflIic0jhfELdekbrQLz4AoUs2Y59iCdQuMk5Q8SpYI6ObLtx6Y+9bz/CmCguR/zbnZa+nzE8ihQJ01hE6hK1re7obM2tnvJz07jBVO4+2GE6y/CNN6heYxrrEu8Z/MUM6VTM1LDnpnoEDV5QmLcGiUwcQmhfgqrmvE7Rw8BMSCqblZGPAFh/XFl2n7L4J5jVyj7Ul0t7zKPBlrR6mKIDZtacb8+CnTF+OG3b8an451D/Fcc9+SauCxx3sJpsSSB2Lbn9GEo++K4uK/Rhc6fs/GkYFmBRuqUYXSMqW2jra6ujPypudmm5c0WBLBigTLiCdyswDkwOr0zTTXt+bwl2SrMlsfNhaalPrwhOYdvi/rUu4UdV82Ob6ETbTTkxB9yreTQ8pA/nPMuNpvxWRAitLIzxebdb1nYKJyX9IU+nRb1Ouo4rWAoBXtoc+k9hu2UrJuMDbpjsWvCZqZ5kd4xIFs3tnJFTlfZzwl7fxQnYDWDMbgIe7lE7HDUymzBstwJ0c0bqIVrpY55zoWx67RwuQQfl9aIz1Mkb4pwTKurmXYUiFyU5ESIW+IFdTZ7HPU9QSpGhEpSGuUKKU/YghqovFy9klVNh5RK9CbKXX2tQkM2AfIgMAu2F5QrAxU/bAdwxiV2ZZdnl3Lg2mcLtyhcIZZroExa0JgCEbrZzo+8Yu7OL2SO1DIDiBVRG1A6BFxPDf0HnB/iq77cqYplIHLqljJ5Ca95uOubsCTnFtdiO2Yxz6nVYzm1yvt6Tg1la+sIX2XTpI9/mZhyLOevvUhhVfwwjfAlxl7dXHdqdc4jlOr7ZRoRTrmXQIsIy1hlGWrmdaM1qQuZohmjOmtklNNC4yhoRFdeDmot8cAkaMafcGZwklyj+BThbtBldyruy4sLOupWblgOa9+LolRX3uifSzoZkb55Gum6LPJaIqzy3Bl96BCHDVGQoWbyRPFb3rs5jKIhMfCnZiWRtLghzvPwPU/CST5K5erHjN5eRP9hMYTO9zAddhgnUdZKb25gVmn275WgvVUBQFKHP59bu9fh2Uz6rWszPzjLamLNEt4rgnm9etF8rNVsH6X2ycMQww/TyF+r2c69IoiexYvrEzQAS1Fd4PV8idq2igYi3O+frPDbKDmJ4JqZwTgZVB8EX1jUuB727oCTSAqjHIr6cox+Lj4Ojveoa8jbEM15x6VHiCtRQBLCSjChYhSfeCxmlfp58WUctXB935JM9gxQr9gaFXdjzC9NMcFFnNlxkUUUGwVU4iM/zsGIAAVOZ/JQy2HZCXdNtbqOF80fQqbFwEttnkIdQqUgGKbX0zvMOfIpHXKrvCpY3P1b93AWpvetOIFStpKq67SuxzFHSEGQLpN/BYZsryxGkQKyvMXjEB9Rj0m+pTT5zZxi5AN7+QkDE+4HRi3aaQ6wJ7iq0MPpWcXO349uiudKAhhCL5dlRzaRUbIkG0UivYn8Qox4yaquF8/MHp4TpytbLx+re/lY6uVjZS+UqM+Fb1e5m6dQ9uMjKHuWTp6XEKLIPGp6K2bXPpWEpJYJW6rhgK3Wq9K0ljnEGDoLDGjNbXvywN8VFTasGbrq/Bnfos6yMMlvCMuH9mBqs/ihrpPs41NI9rFXPUcaxT4+jmIfSxT7WE0xzKBjAP+zCCbXp3w/VDYKWbQu7g1ta9h49/xtoTDhpbaEIvtUchuKBU9IF/CMdOTxVGSkwxvudTH+IhLTsZR0OmaCXdBfj2RI7KT4XkxoMwIV9vOxbMt6bM2fHPX8WWp2WN8WnkUDsfF+sFfAhAwh/JTXLZS3krc5b1W4MoyrOYnfu7xcrwJVOjw7+ZtziWTDlk/099O7EmHBaR9FXzwXbAgrXP47xYWFCH98HJGBLc9D+GPwvacw3VxLMzwLv6tYfYSDfB8LW4iAOHQ0Jlc+cO5JcV2BbXZd+5GjVr6Xu47X+kHnkrB9pD2dRDiDQ3bAL8/hbAyuaneR+fhOTr4YBzEjOrMvT8mIltdV6KUmZaQwF1HvXzEt+uDnTw8htlGhQp5aIe+0thJxUuqf/4ncy/tncRnvn3Kcef+8Y4d8o3dYsQroMhCrY29grgGliCwAFVQNual8l0pxpgSnedXFdRt63BlH+OfbL3soxPa4sQFLR869Ruk+Pkxr788O9lkVfK4vRhHc92+j2n1cjGr59HpU2xuQYCdo1+zPuZPTHbQ179ZOFYbbaMdQN+HcnqYzmA/L7eC36hXsYsKWYuDw2Xa8qBUneZQVb6MbDE9p1oRyYhVPunS5Ofq8puHURidzaFpHfX43OqzapfcE5mOsOa+8Yqh+5Cx6KB0R+I0sPFIo+A3+sjHiIi7GmHMajUTRmknUUCsg9sdZOiF2yaypmYHk1/I4B9Tb+yQaZuG9GIadkRn8q8zXPA3sYwXYRwqmcgGDNVAAhfnoDKmS/VvmsT8eIwHo6Gb9yWT8Rb0U7N2cRP8zjTOFOnECWJInKz6TdAPXK/d6RTVX3ZjawqiowILP/fuvPH4mc7QiaYaBLwxJAtuk5vx7o6qJxr+jt32SUgaCLKYWUVRb/+7aZ5ehs0fb0susS302jEDwSNF+mSkPmRHYZ+hmnwQmjDL0VEJ4riBQ2+APJLb5Em17R5/+EV0XLWhThLNzxeNzEWx+PYluxggB24Ja/GPaCWo8PnNZ9npKlyNyiujG8eVT5pjwS4+nvqCRgzGfRFDIM9OL5E88m71C/KT1fSX3xGlBc0/g5MOGPIiSKY79rXA0UnI7aFQ4vc66O+M7ynFaLG3Xl7dfPtTfFy1iE/txO02zIQ+PkJLgD2gZ1fptE52N4N+NuQ8rCPKRgX7cmP/IwoPEyVHs5UeTiBrFz+yfv5bzs6Jtn5coTAjZlZJBVKWA+lk+R1y1CEemB5tXfhy4ar3Lwi9eldTVrhSb2iVVcLuktm1bZSOQWuzSjSyggGviNwPgP60bT8Ypqfpe3vsy4+217SM5EhyHxwP8MkFzjRh4Gwhf0Q1AD52tuNfGFEW0LNPLMigb87JcL8uhbMTLEr0sgbKpmnD0VvnBBCRphTcxTMqp6SqCOeOUBr5xgAVOKPRZMGnxzyXbSt95QNAzYN1pAGsmj/Zgj5y1HoAROl94UagWfXGJW6xDOJfeDX6ydHHP2xmr7dxjFyNeNFKLRqwLvlzIPjb60srmjWvJ+wXpfnechmz46viXvEloTXwhTdzbm7DeGbTq965GnmUuB1r9EakfXhPpUmvEvpfOWhS25G9wdnK+49DpEFvGmArx3TIN8VDv3bIlz1rxkOdgUtirfKa7Jib6TJyoO9v9ww/9U+6DtZQMTDb0MCi/43k3Qen50bcKclaybSkK35tnVUuN6H3dXmoX/RY2PKxq+CNrOCzLgo/HVqrL3d7YIn0+Hk1F6e32Rsu/SX8CUe4P53tf1S31o6LP12bdwUuC4zkfUzh8P8T5NBzHfxIe+SuRIWF56XehEHYF9Flx5asW4AK0A7LehtjCC4fDx0uFM9gSGYnY/XfiBY6bjUluFhGcnxHzRhsFbcNsXbNVRzPzlZIIhNsa7c/p1PxJjP+DSNF7kXD0fsVUWuBnFWFqQFaaF0hGFBs+rsRKiD5z/ErIyLcOilVwDWbZ3Ap6ITS2vHJl08s/6uUfebmyAakdC/uu7iOmv6RTrOQArtLzFouViJoOMrLDW9SA5U/E41BSBn3KFG/DY7ToY9ODVy6yfPSYAHTtOIdpAqsX9vTh877j5ezfhP2booBFjGILq1FsGDQVrkL+hBtfp10vSkEi0RKbyUJmwEklcA8s0oxBqQ7idRktPSQhwgTEgXBLVyESFUI4pSsQLgytUKJlCk+VAJVL5IJad/562D/Y+asDNx5P/97/8O5Df/8cyzKz7KD/Gy9LSmV7h7wsN8vOD/fO4HsK32cz7yEyXIyn0VfLImD3jHB6Gxl6Z/xkW0nyrsuC1KUT5Y5K/JZ/3J214iq10+KGfaSkiO5a0zzKhjxMuWcB+Bzn8acxCV2xI2OofcAYhSWQDteX3sTEiTeSGRn4FhmktS/pFAOqjMdfavdhQkK7DAksUWrVCAVrW87MtoGE/6GgoYzvcJWTfzT/9Pn7Ec4/t/p6SX3J1U++MsfEAPV/irJ28H8K1IXB6vpygBrTwd7p8X7/4xu4u5Ak1xZdRaA0y4N3yWFNwiQaqyB4GB5QY+BjLJMRv4xKsGDghMMFGPRhywFy4XgXPqF4UlUFl03w34cpjaVHKSoDzAz/z397gvQ09UdcpxdoV9ceyhli98S/tYin9lg9VDgIuZY9RC05RWRgxJ0Jc8OKSF2otEpbnwgDc0OaiCT/NS5GdecUxaJ3SJ+rUG/GAeZW0ThLGyqjgFXAkShgxhQYcHVtdbSIGgfWnmXVhUzUsRVJFTJp5TPyT2oHCsuEhc8hAFoJKfCUvHLV57gguZzHFlFmlqfG9XYxMAiw8W2MssEUvDIL1by6bACVTXS0YRK2Ahwti+CYoyYWZjle4KbAY4ZF60T8ap3s7PfP9j7snB29PTp7T+vMVc1qzeoqXZ2iWvgeO6MxDmbG4PD49kW0RnvNcsA8h4XFcHxFk2dWnmTRNbDaNCFpWXlgI6eFYdXQhWOTxeLkjqTNrNmhbmDJPIapnMacd0bixM7dRmIzK69gH1FCJ9iQWjzj91ZpkQftnuJ3pQc/rJRaxaDEGRzMG6i4X6v9qkLQli0yTw8d+/wq7kQDk1w9RmoAKk7HYfauLDyoJf/rMsS/7vj9v19UebwMoU41OUh/szw0LpIY1EbmCw7ayvqZ5IfTHyY/XH2f/NBXKGSTIK6qJAhvTjt/4iWPVsY/c7vQoZUqooY2af3h8O9pUo5berVQYjHnvkpw0eC+U35BDSYuDeIfUPxkook60IUSikaVakHFBPux8oq+EjSxBTjgPep7plRJw56YLdXYMWttEhtBrzC0DgjkS48OQzrZxzCGRaVEoFex2gQ8XWhgARjlgImwZR0QydLhOG5PO97LDcyprWop3F6pJhfYFk+R968TbBZTfxlR9mmEXkrc3Voa0SfMkle56udEXKyet++adJQZryplRo3jMxny9DEy5JBqGHTxkX38f5Ljzy85DuPbuAjHNTZlT5Mh2d7ztNknUtVO8XhhktWfL0fyJfYziZB7P0yEPP0+EZIRxyY9ni6pfzpdKM0pM1AlyHGQ79VB8Xb+L9ZCsSEslPL4UKsFPA5BuPwx7Pfi9DqLooQ5awt8HtHUDxcTNRz/n2LrX6LYQnC7HEeOwwrNl9jFYxLqoaBCCX3802TWb9/q82soIsn3i5nLr4qlxrGcSMgdyOe32GxyN3ySTG1JgZi3ZrdOruhLMRnUWOA8MdK69ZgEuXjuQFg8natgLIqycGgXs/RArUXRIrm7mG4h4vHI4oCLcLdRIWfdc95l4WREIjpFOUadkQ/lLtmcJVKTp2vylq28XZN/Q/bvWLxlZ9a37FHVW3Zme8umXACO+CHxm+A/etaUipn+wp0E2bwX7hE+TmfzXrhHGKstm/fCjQ6B40DNBznDS4r+tO006lGjo7s+0adpHZY/d1fAJyY8fwKvgA9L8OxZvAI+NeHxqbwCdixe8ot//VO3/XEeV7LxOI+fqsw8/heuEtUgWjczImQehNkfyNqJuCE8N+7I1xzDSxMoXg63sIc4Pw6z8A54Dg952Z8WKfqg4DHwRY3mi/0hEn4ksCv4X095IUdCE+H844KLSOVLN5mqn+CaIYO486TJy2BYrqWg2Ok+Ayyn8eB4bzdEqs6vc81M0gcw1dIs3QL9qcKC3QJKSPA++7M/jm+ToF+03qdZ/CdO0Zh8AqG9tb+zeza/gQ9ZIRr4gHL3tVL97Oi4sjahfUHzyMkUc7DpDvLbykpcBJOJNdkFMPxhF0BA6SPum0dd++iRabn0QWtLPRloZy6tpxzaFeBf+g8CWuIMF0o6DHwrIF+Oo+xjCMU4GmY6hjR7h7GrMXX62EaVUL4yjHDkYz7ykYYJ0WExHEodNhozigpjXKzsNwsysEm/Bw3GAxkilu4AFTLP6c0N6q8pF8iPl2U3lmqtT7d8n6EXTT+7/VTvvOl63RcvPPwX/jevsrZRcV+DxFgNXuICc6GX2done+/eny1oYrnNzYKFsdQWS5PUUs1G0u562+u224ysa/Mql0j6Dm/n1RUsrHUu/OM4ZmULi6hq6IO0zU20QCwIsEFjAqS8DY6g9mjDti39ETQyls+JM1WMwMiGJQQsG6oKkwdEA9umdTAfbutBuBr81jpLz5P4gWSy5clt3Ub47GXbU7GgcRvH7qyEyiLbLE6OCs0YZbGSwViHq96XRNNmTYriUneoUL1DiROKY0p6q2tyU4uwdpBxVUFRLf9u27Ky6SG2q/UxxySLlC9SgwFbwWsX2/s5YfP9LMO0LhqJldeeI1plEejPY+GGhKjWLC7cyeUpDy9bBIQK68Qpgkr5S8jylsbcmWfvA+cOq58C1WGwi/cA2+qPX++w/9Enht7b4P45LisQtCuarpCzQEMjs8es00od6+7ebzuDpVWr1UFUy7tCKF6HUOEOuF90lp5Gt8THhF6WeGBrVJ60vQTj1qbcUTjbiBpxs+PTOP9pUFxkDSXvdpNEWua/WAThsft1GH2aorRMeGYeQB0/34iBqhe5VjlXk3hvdJ+lvgvikU9nP29mKD6Gm20+43IvhubhEtKT5GJ0GTAXZUR1pKT5Zr+J7sz1E8HWsyDnyoJqFSyjqKG4o1pkL1NXLaqIc3PV5hi5erkFm2tKrniR5vPbtzp032Esu1pTDLc67rdvU50qHA8z8ax0dFOFCpi6jblimc3Bg+Yu5UpGz9pk22PBgxfWV9/DNaRUtswKNFlvkkV4u6NaaBJhGGd58b6CxVuh0Z6z5ypdoxZ0N7NjSV5KDK3lV/0sxkWEua5IoI+6lgH9aVpWHgBZW4l4H0a3aBYCudNDbx2WtlGNHtylBTSpHisYRjfhdFyQEpYZksUKptuHXrgtzCrz2h6PtK+LKOVhy9QXuUw7lWDaqQRTIFrr7pEwKyTkQF7PL5LLqk4y4G7xeHg6vQMREU9gHpdPX2/Muc9x/IVacMtSxkeDoGjQODtb//1//rvnOG6jYsMBpgExtaq8RDE+wJ8i5oAgN/E0yy0bMOpMVgJgPyuL2nMXNcMt8ubi1J7zcKS+HzKne8MtUqd4zGUIJnCa4vRFfIkHT1bmvRguiWSHyOa/Nn61zlN8GWQV74KPY5XxpRAKbQuPb3prvTkMkqXVseHIU7iKvYR5rGE7uYw7ZHO5g2UbxZd4MaPxPdiBbeuX8RRVbPAWwNED3tXZ0HdgQJnXYgwknI4B53dPR4ERfyEKCpyGwszeNTHYyeY+VM9msyEVeeBco7fonBgWtcL8j3qVZRGtUYOPNXaH3nI8cn2QiS3bfrGh3bKZ43LBuaHylCAZ04w2M2PvLYTbK+mTFmEWZbgayPMK8PgaHKCIo1Tu5jTKK81jTm3qkWYce7qfUNV3lm7rXeMZoONWZNPkGh9X4+i+vsRD6PzzjBKNvEbejFNoiyss6iRXFNFhuM870Zp+ZlENSE7zNsOtEDXTjTIAi/Dw9zS9w4cz5QlIezVjcsIIBRwptQiWoo+YJaOtJBc7HRWdx3xenS8nvcSq9GKx6iMvv3np5RfnNZ3I1BNj+gBQ53YdeTkxVBokmnGIn8AHNedP6rKLTEWyr6ThKGl8HaLyp6ChdpbQu49yhWfqNL5lRsTXHy4+QUgCtmCqz/G3byzhSIibeE6UAJY6CRkCzY8KO52QrYDNc4fpGhWIXEtLpick40n3Fq0X/4kLyltYL5oNtRccgAVBIt/jqY5JTuuYhtWRz400LJZuSmTvgEdKXHjVY0nWHn/fsyzYtFWRuBmzKzYCs5i/T3k4t7MYs5vXn/Luhcmx8XH9eSytCdogmPyb69CJzgLSeET+sxE/67Tb/qK3sozJcIfRPfb5dpxSEY4lyNQEOWqG8+1bvrq69MTQvUoiVOppPo05SvkchcvNUaopkXCbVoiGLCVeM2oQCWm82eECUjhXQEqqbz1htbQDhBurepBEimcjvOqM7Fed1LjqJMA7DHHpsfhQ2eefgA8Xnh6JEJOEfjxCwEvnpTAq30Rg9S5evoZYpC9WlIiWWqXFfE5CJRf9iGMmeVWJl+SXbSA72osPWSDZR23JaMFTt3E6WV841Lg2FXc2657k7M8GLzlVn6ZwRvYXDYWRo1XnV61FiudogogHRsWTEU66NuX0Q/nNnHy2vV+TAsVUgPy2cfXAYX/XbrL0TpF8HWLXF/KEXpqNjbBCRec54m5Ab6la8FcsJf/Bslk51B0T977O/FItAoiuebkwtMJEbsWFbJAqdcOIZnMrZpb0xVKeXLoDKiCJlmXTajw0NbgmtuZFMAiPxbARwakQyXx+DmW4fl9kl5dGxTp+lAbBhLx9tXt1NCZus5n3j9gyZWzGCjxjhEtGrv26iZNwfBaiwKdYmBZRdocFdBcpBRO6cchkks/Q9W5hXy0izjQ1U1VCJLJIioUWSRFTOvKCIHASAu64ahNwQ2LpdBVAKmcDIGq+tuw99sqfMd0xaU28UUiuyYnNGohzaEIdi7vlOGqTahSs6zF5wP6qxEndZcya1iVT+5kaaOpxk8lHEjiZFgulLhs90Pp/4jk7M85/zeIipP5AzOM13wFCSklanXq5vHAl04WN04r9/DJnOX2iWw3fh9hvshq+wpHo3Wc2/KQFO2lfMZTC4EZ/07MHHoKUOSY+AZw8K22ecTHKr8NJhNGtZBodaQr6/OL32spf/vpv9aYfbDX/vHx+C5t001n9Cyqzr+HShsHl+gWRX33HiLHDaS3jS5McxjSEG/dmIoVqwFZpE/LihUfsQuj/XK2CZgWyj8G+lECuVRFQjbhmbdvnj/pnMxSrGsKsK77awqem9/AbwUW8bYUOiaSDYkX7nRayqGsgoX7vxvTcJG7CyqPrmN5ihJxgIEpN62YlKPmQ6XMGJAcXeVo01twmkMQyXpgRpVXcJdDqi697foHgv0FqpDcDuRul1meMNRPkdOMgSLmhuSrVxWjfPMWHRAzbCTfV0/BzNNxLfjvYF/sVw3KGyvYF2WYaqB9a9nrQMHb9t9ZefkrWPVqUom24jd7JxfgSiDmiXJJgestD4I4wGzaUlw4i7yYYUjaH6I9U9cptgX3f6EFK4QA4PN/fd1ZXb/ChgcfI3W9pSYFvXF9dS0Aib8Iyq5vf91tGbl1XHBkaNqPCNauOWigLMT5+U1Vxt+BIMs4+Bzmz7m+iLjuCblzvGgjGo27aA7iWmidxOYr6xLt2Kzq64v1QBiXG5LPbNCwYLHs7JlHKS+i32BlW0fq+GMaQWA6TMRCbNe8M/kIP0vja24Y/P6XjoXdXWt/+HT0Ibrw7anoMdyQtpjIjz8Ttddrk5nCij+Qam6BWcifsNfukx8bDkYe2KSbBmZ2uAID4Bdv2Yjp2dmu/pTd0Lmv0TJLdqPdmLrqUoMSsa9Cf0nQchYnTozS9WXIVTMyrMZdjfJqCY5qMwmSIeZoLIt3VcO/WMB/7bcOpOw3iccCPPzIfmIhjRv8fkT7Pzk7kKXB1xcLHaTK/Qw2eaiSFg2Otth0W0W2afZGS7v/P3tf3N40rC/9/P4Xx2cMm2zTE7jsl8CttgZ5bKE9bdmG5/Dhu4ra+JHGO7dB2Ic9nf2b0YkuyJDsvcPbsw7KQRBqNpBlpNBqNRkphQzH2FPEkxSNADIhO3GnS6zKeex19e0FZSKIxLpPauslzA9jvtnOOJn78isdt+CQB7mLx1RJ++9iBwk6UOUNcSp3rcDAmxwoZrAR9aFp0eeeEsOyxRwzaDu1T3hhV0csziLJXgGmUkEzpW658GBjyNI+x65AJ4prLz8wZse4K4pJRcaG0pS2Qxfh8r5xbEEjzkK+ijZVIVahdJmIRCAOhxNKzk0qquxaxhLa0HBj2TlY8BkCTcbxdw4Ajj+lQeImk5neI1XyBrLoXiUtaq0paWWf9+FGvb5hnqFpeyx3Ibju4PjggyPANsLZbgWZmNpXaYeXUy+BTmPKHSsSGEV08fxkS2ZTr2ASOSpiWA2pgvpC28MwxvkkRegiInYBjDkQXSifu9SbjO3JAiRte5DyI9xQwf47Cm3GcZC18EAUKwJ5JyqcqO2vAkdC+IZovinZjJ0hviOLmwIBzwtsxGuxh8QBV8++VZJ9ZVmvQ1HjITFfK8JpZacTmG6nZB6tQVDtO8Z0U11xm5kEp1ldnDcOHf7n4eJuzVRAMxseN5dyCxprnitUo24Y2v5ufvO8M5D2Px665yNzUfVeTulk85sR9ZyPuOytx35WJ+85A3Hcl4pJt/eyEZcUMehvkufoCM5OUV1SHnDdFxUVZLemK1zsFQJlkLGq70hxq8JidXryclmA00zUUmZlkeV11aHYt1C2U1lJNeGRTBJXpxqPaK40SDEOzU08qrCVhftfWOTpwbaVnpqZct5WkAN+DRRzXyRs+wclbo6Dxj3BxRv0qGElvi9E3CwMnHYc9dBzAlwsDelLk4DqpPHEIi+0lgsBeIhyOM9g9CLVFxOckTNC5KMicJI5RgH9GVecpVIxeJQAOOW9b7xz6SlVKluRP4RhWetx1DIPCkwn5DNiH+P33MImlrccMT0SW4PMBIz/5h44uo6ywvrqOi+bXMMA0bqWVzEuCoZYf5ZeN95AmWhjoNl8CZHtqBZDuqCVAvp1WIJ/SZCX1OlMSrtSEj8rvZyrA2+zJPe8hM4YC6U9u+L2fO3oYlDXZ6c/j3IyNYKQA2jReByjXhOfSlMOjsDisTgonqPB98gFjW1Cn4t1UtG8Xrs7Nx9317fv3TbmPuhtbu030asJ8OW9l1EohQ3RkEnLRvDfCAxflOkPUSgWDYVzOk8HjVv501AiPRtlIiTih8JQfpi8n6F4P/Xg+nj07594inBxoE/vfaFc46xIOujSnXPojrlIqMQ+XWJVwbzCN9VhF0WQxRt4nOfE+oA2YW4+/fm3wlvK3xxQM76WyH/KOdd2YNMxF/lqL5HF0eNEK+JJlqFmmTHUrlQLU7M7cAZx0VzlLjBQuhexyvJTKHLI5lxnB4hZPEEgSC52mmbGmW7zJj7pe0bLi3pm3GzziIOTGmdxGuW1yh5ACUgeT90F+JK10oApPVua3pUCp41ZoHa/57GMz9SMUIyd+/CaU5hJJiw507bN7nLLRbnG/jMutRJRMiSq3TLlUbqGHOpNbQt5K2kogQ5RbQm7OAXJYjIR62FC7khQmcSq2chmVov+GTTTVEUviCDLJl/L0CctJYiPVzFYk3n3xdkfFOB6RcTwLroTcgSETzyqpdKLJKHMssxEv+pVmjyBdcumrHaDJ+84Hvj4RmcNP4mV3QG83LmiCjoB4sdGAdARI4w9Ndq8xEO41KjN5pJut+UQclfs8zdfKEYhAyZX440e3qUpJ0bE4XvG5Y7E8fuUyzV2ljYG1jYGmjXzO8KEPo/p5/trUnei4yRljnxz5G7IsxBqZhmIfRuIkaY3k/hQTcHzHKxBVgqIdLn2xqhXQ1X1gapikUOwOxMpzYTrqDiiFAOWADmn41v1ISHT//oh//foVUt9mRTL7/kQ8v5GqaA2k/rUGpYnCTuMeDvLpxbRhUsGzWStgB5dqPVDB3G1sGrhyfj7H6MCpy07p8Svv9LOcqPnw5T5CTNkcqZSjJ9G1R9a9bnz/vkgDG3QrLo5HWRvvdVnTmvlZnAIhDBjeCZpg6sJu3A7/NQkGjdqdAI2yfhfKJ70WcrMUY1O/FZ0tjXxbauRbeyNbsrC0NnO3EedH8/dAMPLvMMXpyMJE6tO1QHdmoJramRlqVYuyt+IVV1y25y9nHeKNoX+0uWtWq9OcchP/nBg81gLVd4cHccN7l+I2ux+KnsTGoFlsu+Xugxg6jyktXCFIFrlqJzjO3NNntMXyTRRD9xSvmaQJ++Zu5wlKM0Xi0dhuLdzuPlSzn0nZxU4Z/YfSQdRDN6OA+qO67ILFQKslYsgJySdg0HJ5uDyX71CvdWRKCs1wgsc715Ij0xW6HpXIx2HeT2TyNa66+iyZgC0RqPCLun//imgepLuTphD2ojQqxFmStAAWBwnqm2NCtMIyAQMLLzqx1ShKRS1Fs3MRrDXcbsgcFmEXYTHqCOo1vf2Tq5IkxAMM3vfpB7RvAf2+fmU/yGut3HzKlKB7XtFWTpd/Y1vv3+dbOBxUum2cpuXlmUidfwujnIAlXxoRon0dpEJ7G26BRDDj7ge969DNbQdZ2wzF7hkU1ADQLMaWgEoNAzEiW7L/xlgduA19/4HEOWF7Uap07DZZTJBEpquISZhDsXibJMbbJPHqKncKtHBlhDsK0Ek7agAT8TofOhK+v4YtvSto5cCke5gqRZvD3QK5vkgnxKDVIXreTUIQtEhtUJ0Q2n0ihkSYPO4OdifQ8BSnKPHO6mJBtDUwlBOU2VP5PlUqbqBQSpJLM8SpRnp96Pz8FOPg5bnlDukLYq/u3/9HW5jHBJBce8mLNMWoff+KGkXGbsS9lfklyFbERVFAQD50g5boq9n9h/BDWxkBJ17V2fs89YNkVAYQccclwvEsYe8lZuf7DY5ByNPszOzcMDODDBa27uRA8s4Th96jjWK60qVIQJlvRDcwhNK1NivAPapgF+K0H3wwCAXchAtQwoqCF1uVfW7OErYxnwgb82kNYQE77mhqUFWEeEhGVSOXqriMJnwZJREjWA/SD5IbML9DXFCaEnr0qNOkXnvRCBTKqO/w4U680tzcFipatUYY9VlMGq2QwJkgzgb5aJejxMCKC7tTPAMb8hghpeWWOGrD8qpeNcM40ANyt0k6/WAoxffFloT6MKOomQ/ekrD+i2EtHmZdEuJ3FC+5BTc3StBcdv/RfjscgJYc/hom+PpAF8QzXsr6B79mAyBZ+yD8vB+PLvcuLwFP2O+6DvHCwStdJGAB9eW5iQYDJyAw5BCyH36OhHjC5AJa20V8JE4cdZruukfU0SglP8mZIz9vRL80wA4IRqRe6hmJLpMDjIjUdwCefQvyyCUtp4fYnTdnT50Hzqswu4mTT3IjcAZhlVeD+CIY6BpY3JgjJMYhxxMcvMDcdpw30Lj/+Z8RcbPqBUkSBVehQ+VA2nbO4iG6OEEqzEV6php8DqIB/nzo/HSw9+4n56eXJ6/OX8Dnu8O9058IIgyP0nJ+enHy5hTzj169OT+EL2eH+yevDihIhoE4nDwuukfhiu8s/jl+xzjr+Ikxy+GTFL+MkhSECLn3R67iCbh8AZcv4PIZLp/h8hmuNATS9UVk1L0rduKRQsY/MQWFTgt9Zl1mPf6J9ZcMUR6uAzvcpncY9xP5WhHxGECPu7BPQgcVd+ref5hOW2/CuuDsBF3KhGn7JlTSuu9df+NB6rZcr0M+6I918u8a+den2eTfzc6DIWbQD88nH5vk33WaQ/6l6R6Hvaaw1wT2msBeE9hrAkuy4d8PhCS/Kn1k4T5IeEJ2vbHTCnnwamIzJVa4XYsaGxZ3fpLu4y+JrL6pQaFXVqbq3ciMnGrz8EHsJnznoYbIbFvs4Wx55+CFV1e6ru5ZCvkwCXRlfEuZtaRURo7hoynUSNRXCLJrBcn017BdUB5DWk2rx5xc5utX6Xce7lEdk7+WxyQdCZ+iBUf7p6g82nmUURhzj/FvF/7Bv4/IP2wMHis1Y8BjHEnnoCEK+hneOp+3bceatu2B0BpAM54mwCXnjFTjvDyHlP14CJWcBaPUeXlGfk9AdiawTN3Ar+cY3hQkKn4N4+QqCuDbi3DwOUT/XPh+NBwHoMW33PPgOh5iCsbgSbG4cwoJI0zBQHGwBGa0hl/xEYVRwAgSL8qKWNPdDlTTaXv0X599rLEaB4vWONAR+PMV1TlQlr2E1bz4EdzyH7T+g0h5NeYf5dui9A2HkEcxKt/oL130apUg8/ebupQWJYA90FiHZyDZAKZDxF4/bHSadkCPA3ocsFAlMbpSfiNTTA5uu15Hk4FeZy9JRKYimrKQTbz+veLOaB4KvATkA1Aef13MxflFWvx71uCzwO+02GWp1j2vda+j7wg06pmmsFddmGnsLzFQwL+y9kHxs31wdPb6eO/djqazcqx0WoMB6Pw66n0a4aMXvgYkv3Wyz8lXdUvXXNovle50+F9N6axo2IZ2GJyNQxD5xSu+UhSIlA7Cg7ARaAO57x++Oj88bQWaGO1PT87PT1628PGEFn3N5ye3JTS90/L8Lf63ackh7JV63ME/zaahyd6fvsnli8Y0HfWY4ArUxmKi04sMjebUkvdFvlKsxIY2iKtWh4duMxkTmMWgFRL1KCT7oaZsuDEIJKJYAQoME8citlEoU2OahfdsKc/gukuFrGstaPHaPSjesrHjINHEOSIaV1WHj2r9grpQgTUJD2/HsA8K++ZGig7Nut7Ndx9RR2Crf/K7GBbB8aSX774vQWDQXT3sjsmLvszFt4RaXbZLAMTTt1xMfgW3XMy4BmfVE4nclFK5VdlQJTK1O8KX3B4agDVxU6fU05qO2tMw6J+MBneVtbajlMNqGQjs/pd1fjgI4VrKLjJFKIYZvPJLZY9I92LoHsatLhd2WMQQmWwWhAal8Q17dDrXGC3EtM4FRlVqxej9axKxC2tYdhKOendtd6VsClMnB0JX854OIoYXH7DXIMl94jUxtaTimV7E5gqpYRS95vluVfFFBpLYCiv5X8Q3Dmxg7uiz0Cm7IhFc8nuGfcAzDAbOGKOjVdZlGCyweykPFh0GCwtzGJVrRWEd64r9QaZtvLQ9sE98dnMSCzieWwfbfBNZQcLn6LzlFxlGKnWsQ2mPUoba+shL4wX6Ft42RSMlZg7jJGyX1jepLstAkODUwSAj0Q0IeT9YPSi8+oPCd+tgW3xQeAsOCm95g8KrNyj8ZQwKr+ag8GyDwqscFJ44KOTdsmEowOY+Gk6GdCy45sIWolO56CSoUVkwVFxdF9vBw1qQ6NwXd4JqSfHLqEsXs6VcQlClQHEnW7aMGIgX3JqIF9xWEg8LL0Y8Un3Fvf/b+YgX3NqIF9yWiIeRuXXEC24NxCsMSAYakkgmDlD/ASBxK3EsREqpMXbNDluFlIOGOQ9Ay+AmwjIRC6QWWhZAKkmF4jrKCgY4PYGpCc48u519JXiIpuxCRM0bYCUoaQUVluJML5OTorOQkgKoZGTFdCRkRkoL+Xzz/K4kn78M8vkzkE+c6wby+VXk87Xk883k8w3kQ+utgXhvRlHmOGihdS1FLbTDoqmtbD1FotzaivvXo4yeCtNOcdMGofcDPJGYoDtNH8Oz84GhVGGhPmartCdFdJQnpnHjgs7M35aZj8PXwgARx3xsEDHMzAypCzOzhC0Y/OBGoxYw5HbtgAFplARe3KAr8MMHPXuEAwYDf1giCXXjVuOw6bx46lGjFVYSIxKHvQAO++hgHJZIKmCz0FSAUokqItBRVTyV0ZP1Yt6AWSYcc5H1on7oLEJWMXBWWWBfmINi6aFUsl7oAmQZjq1sZM3PrOykzU+QHLcesgVoLDbJSucckIeg6heEN1A8L1JJ9RxST/kCkZn6xXmggQPKkWDN2HmSKceKbj4mlFtVY7QXbbxKgn5UBIfzNINfqcHGCwW0xAwVlZYb6tFrLXb4ddnhuzXRLYMd/oLs8CvZ4ddnh1/BDr8OO0xKZlYhmUhHC7nU+HvTIJuyBaVStpA8auGZ6ThMesAD6rZYhOND1kzKakxWQ0hlJvGUWQVTViGSuC+AZWuUYr6F3AWKuagttMBG7J+59YM2R1wAzPSGMqugIrPIqvD/MGQOxINoCPsWNwsHIcYuxOA/TkhObtL2zxoDCmmi3YpCQDSmFFrUYE+hjhjZ9CgtbH17aRpdjYTq7jVqHVA2tfQtOXcYWC144RrWGw0mC8cLfGltdDPvLnSds++wJ2kWD6M/iNkMvY0d8i5xeU6WMKvMLwGorC9jyMdA2eEmq9U9r5p3vlsX0zJ55y2Bd943451XxTuvineemXceeaji7Ds5Ey7JV1C8JyN5C8oZkr+glIXvcT4LsG+5F5mUj1rIhPr3ex07AEZMrQQ6gZGQnJLlk8DvbNvhy655BkCdo58B9NkMPowSinRyIVaITyJtVMKRblaDFR31alRd0dcRLEaDkIMVjpxaoFEGI43DHgTJpzrwFc2lsMfk+qDX3elUwfhdb8MMQ+NyWgBe8gW4vWEc5Dqmr7doj8nzKRa+EzPiIhjMzqgasIK22t7M4ZBqK1/HJVUq/0cMbaMy6zpqdFobOHUKj2JzGY+XgRLbWOhdiK4a5gI+LwDQKL/IUG4u3dmVZf1wdv3h7FrD2XXJGv4Pl9n/SJfZFfmO6w8P2h8etMv3oHVVirn/Dt/XxZ11/5Tesz/cMX+4Y/5wx/zhjmlwx1QtKzM6ZJaLWwhPoMiBT8lWp2nG8hwzVeSli7pKPiFvqVBO1pIxykjOmV00y8WXQc4lu2qqyO3kZL6FpUIGcsoehQYbns2365JAuDVwLIG0UpPsx54oFWhgmQuk8OcI9giUunnYmYsQ5AR+oBbOmICxYggIe/YqjfAl+aRomwM7l0+pjjVF46wcKsDKjBJQ6Pkl2FVNbCvsecbJABvZoj9pFo6NBBeRLYF/Utsqjq1BV4TNWA/5k92EIdDyhjxYloa9CX0fTO4H4YuGLUWdVrYUYGW2CCj0bBHM2dVsQcttTdbgc2eNvzfdmjiXyiHWzAo5VmYBbXVx6NqSjlzJiax4zm2pvSa/ENTGM4Kqim/EnF7NO+WcoR4baXfrMbJUwVJ5Wm7+7OyNEQfv06JsVhpUk+NKKRvz1QqqxoF6kFQ9JKo85hQi5h4X7iyYlzoKajvUafmvdqCijposld3rKpFWsVHramc74qvHPNWj1I5xqUyr5WmqZZjocmpDXpNThfupFVkVh0quqJZT1XrMuZR93K34lsqaWVzf7b2sdoCf4GunuL0t+j0ILnIvBwv6muzNHeFtqKqYqzrFVxx3mywik4tVce5NzPzV4VwCj7VNrXcbPZUa31jxmmw6VqqzE7s+W26TlbNl8DJ3NSj1HNZ4KtTiskVXkplcpfFqsC6bzXUUI7nRC6u9pfrrc1Sv/5QR1uCnVd/RO5XU4mmlxmPCvWzO1tZ7dOy1qT36Wuoz0aL8GFDXYGe1ClR2/qkpiC1KkA7n8gVxDVVIx0OjJlRGP4tM1epDGpS1ZKpNKxL8rwycekUg7CySsFh4Q3HVwmJnBWvUZTQYoKXNyAUBpZX8AlyZ7iISPcFFL7YqShdObFUEJ5D1CC8iXZj+UgvrsEFqqo0NBeZa3CjAzUwRUNp5IzgP1mJR1Yqk9L1ySTIhXw675r/RNpL6UcW8ekuRvkgFE6uWIoNXp52ZzLHTzkOiJ1fpiQq+BdlWtMvKLQqmsGocJBmNPUV8fWJhsSNXgf5uvAFkbkgNdjJIExc5IhvzuJttHZ75dp5d4vvhs/DMXxLP/Pl5hq8FLJdvfm2++Xa++TX45lfwjTg/27l2gyDVHGOYFuQXb4+VWwRIZtbszCBIarCCwJkYQZHY2EC9y+1MeGm/XpdLPOGWnVsT4YLseFnz2h1ronT7TsOSBvRhdRiNmnPdtbO0rwYfX4p372yobNx8WdzFsxxNV8RBOY5GoRqKw4DEwr5zvNoEmnSYVqOZwygpdKSmOZI9ipLxdjl9UvACBSdiM52VVxklOZDhnNxsiMwvZhh3vvnNC9OOl0Z4qWSYiGgOWovFF+K41KF52UacThyKSrdJzuuwb45zMM2muEBh2AwXV2JMvJs7/IcZS/2LyZaWzBUCxITPSmE1DIgRiZ7GhlAgthtDcwQDsaNbiOJLDAhiw16DB5bdkjEsiPVmlpEfSwgNUoFwXpZ8m/Ag1jrsnNGFCLGjM/DGEibEevNtnkAhFQiXw5xlBQux1jELc/xK5vj1mGPe7dBrhQaW/A6Z5jnCi1qIjwjSqvJzKAZ5q63sos3H7Sr0KgsT3apNMVmZQkHKrGBF9Qxg1zWtZPdsZPfdiqILkd2bn+xeLbL7NcjuVZPdM5Dds5Hds5Pdn5/s/oJk9+cnu780svvVZPcNZPdtZDcLmQWDqFThmjkURxXCOXi05FAqdtz1gqlU4KgXTsWKZMaAKlW4lstHbyl89L4hH2sGVqnAURFaZcLfiVMCquDLyLTc5yiN8M3sezymBLlEwr8Ht92QfSdaTjeil1npHWW1BwzXkxyR9Ipiu+2u5GiFnIfFq4MFWxgqwxD7lebq4Oe8sVzUVy1mCWw0iLI7pvKxwgZyEDZykEyluzDbZr/xRC85zdfjGhebSG+H5bo115b4TSXpcpJyH2n2K0j01tGc/au+aUT7V65bc4+IXx2SbgspF4R6FrOLGiO7V8cwQtonWGp6OutHLzd19GS7Ro8ZMaat60opcCNFe4kLP+8iWNAPQfFDUPwQFH9lQZHXKcx/QytPxHsu8sGbXLi62eKVGVv8T8FLlJlShZrUvgpZpMciaN5vUcwJvb+xHP7+pjn1valzOEu6Sg+NZ+vkje5A9iY/fb2Rj1pv2LnqtPV7ZpL5raSVcvgR9C4X4uiDoEpx9ivKgkHU6ybs50U86HfT6XkumuXmIdYV1+FSHPEKYty2MNQoSWiOcAYWkTMczHdVcEP4jOPI9NYdLTanWGFNtHudAQw3vxc3NEZifwTCEIaTzEzmX1FpavYlJ3TBfFcFn7ODaR1fcHRrKXUw1Xhxp9xXO5U8ssmYfBlk121iz2x4nc4vWfMBfNQTp6TXvXlkKn1PRGh7eymylc4kQ2uPSKargbY29SjNG+mk2R1sRWm5J6zJ9JfaZppKGs0A8laz6S40G2e88aBrICpkDHLGBmMp3lz8rjYW00hTSWbeUCKIUNwd/cUeJNe9+b2+LQX9k0Mfsiv6ukiFYuhDA5ivgF0nf5C4d0MQBt3DrP1C+N0+PXr+4lwDeHIJDBI3ESeXpyhZQCklXXmWNV5Nhhdh0n4VvGqWwUBJqgFWjrD5Iyrhj6iEP6IS/ohK+H2jEjJJ+p8el3DhAIH/psCGP+IS/ohL+ONV7xqverd/POv9I47kjziSP+JI/v8TR5Jvci1Pryp+63IJq0MhATQWrcdipYEVbof0GczCfCaWVqmbv54qAeXUU99LNVkN5nGhNeOai56z+85SOlW7z5pqUGlpgpPoa/aXNVpkquk/l5esGdcy6O8vTn/fTn+/Jv19G/39Svr7OvqLZiwD7V8kf8CKwWCcYZhdx323CtNclFcaU6EKcmORoXE6pCqhxTyJuFKhnLCScbCCmMQmWIui8SWCurXQLUxW3qzZaUubKR/htZ1XMbuV59xchyOndx3Dtti51iGA1ZSa88z8Ia2zMYkAGDlFi2vZRU20Gp5J1toZnQsMOCxMIkAOXoBP4kE1Jiub/nkaEg85+oK87IXQdqJLpuxdxWHq4DlwGvXxzJWWoYVaTECRiLiU5LGDZ9x4/JOwtuIRUvs4BCXQuRgEo0+I+i6eOLBn/xnYzu5r9sNLvC2WTnrXTkDLtp1/SpyWOqc5uC4yJQ7LxcRDbMHMbufszG4VBhzL4Wyl28V/MmfLjiFSpomzotOIfDJi5aztwp+mszVQLYXFNW//ERsG4xNKT8rWiERTzZuu6A5KJWZiFzcBTUU1BC/d/+NlF/Rlt6CZ2f3Zgmu2TciSndeNaOv5rZuL13NZN5Wf0VvdgmZpnPIW5ZT3bThV0zPdXLzCKb0fMtckiyMQPVWgp3ywywdp049ojHHqoDDqh7fNbrfzpPAJfegejph3qHT0n7uSEJTGQ36CMn/Lk/4SPWtsR3KC9cXJ7saSiw0rN4MBiRcx2GUHRn+leqda1LiTCocArOWNvc9hEuCiyZdatPDIrzFM0BPLAe6hCpyFCSQzXzj9MZfCR+lIlTKROv3kh11SsdRYrCVa8nt8dBjYcx5Cc/Mh5GoLzsAfoZSBRZ+MLBLKznmKKXa2Bp8h+eqKXKyXup//nGviMU+nPMvANm1h5JxywK7MUGHWkVFn4+qvisbKCszATV6FlZakGmYODR2JssyzGwEqaEmQlOlIi5poWCqkjHyQnqM+huIwUYnxP+iVxr5QdKbRL1Zppdo/gs8BzXfSUTQe4zn2LYb0pQE27jDa3EUS36TQvjAAvTqLhiGhMDXNgwrIiIxxc1Al7wUjjM/BvMdwiqE4+hwkEUr+9KHz09nhq7OT01/3jt8c/tRyfnrz6ugcP1/8dnB0gF+Ihwx87p+8Ojg6Pzp5hT/OT4+ePz88xa8He+d75+9eE5hXJ7/91HYObwN85sR56DzKssekZY2ffwuSEVZN8TldueJ7Pzd3Hz0A6LbzjrW6hw4CziC+SnEzAVuJPlFv6VYjYR3uxbCDuYmLN1QEYldOVAKJsUp0U7VAY56sWgTScOuHuODbBxqBcUtlZhhhvJZajy4RYOJSnYYokdKWFESa0DUlgZVgY9cDMXsJS/+dgwcYw+AT7ueSkAytG7Lb6yUhqHeMHaA8YWGmLWFFFUw4IDAl8tOiJsKXCiHJp63fQ50Dt+o41R1Bd7iHFqosq+x6Di7sMNqAI3sD6FP/7jgO+mG/uL4zm/vjOWg1uXKUlR4IH4RX4ajfdV3Je1x00rvbu43SI0nHWr7XpOhta1Asl+6NstIwO8qAak9m7hMXtFNn1Tl59uz46NWh25wejaKMeqUq/MxEZoZVPjxG3zRLkTl974pmUSe8sNIJLyJOeBHOzbAZzeSEF9V2wvs27nPx+O48Pg+SK8EOe8/7D3gqNwnG1392l7R85N0j0ouyfJ5B/m984Ja4E30rX7BZht8P77F/u/cYkgJ3/fZRg1BuRfmZd/xaLLMMH6Ht9uCisORfU6bjLoiJHhBzxduATjwSZRAoaETLehncEjjYC0QDYojCYUqwcMrCyuE88l78UXIk4a3T8Rk1EpWdObzEUqK7WGXPAmuhlqoJqKIJCmX7kMjB3Cos80kTAcGSBISAcZZRJtLDOsyoBe8BDioyVEQrVY6EB2fsh5+jHg6n1Ys4SPpOofKaRZCuUfWkiACuDrsiq0KUiIAFobKKSILnmoDsWd0wfyRKZw7N9jKZKYxfJsXsy8oB+jJdND6q/Rtaf0wyXQ20fZm5jpOMBUslMPwqXhqC+s07QnGpvaCppAsMIG8/26h8y8vYhOJiHMsFbwwWOyfjAvFraFogxMLaLr5zAoBwDSXspwvXcZyGzg1ZGigeOi9xtt6Ano+vy6a9YABrQxYzYhToVYoUOYQsAmBOG2ET+Z/qGPzDG/fP4o37V3SBnbZ+18V64SVDekBWGIHiz2EyCMZFwjim6nz3ZdZ+zb5LFz51F1O31JuDaz79vynfUb244pc3C+hOp4Ul2N8cUgjDK99MpTnFMpQ3POjjwtr1uHXpM7sp+RI0lGhUpBdOWWpOlgQ9GpmevSLt2QxJjJZP8lNHbXgaBmWYAPmBZRl+TnNCUV/V6joZ9Im0pisiPRgmAptcJoGBPYqZNx7DaSAAGbQcJFNHmhhVhI41k5sKzXV18PZVKKDaIO0AK1RsRMi8bWF/UtrnmxBn7yDqRRlsQ6gNeAyMJ5M5yp6w2CIUT8mvhCbTmCIMpPAfYZNJ6DOfTqZ7RSzb1ZawdpsX5WqRyEaKjmNS+8DTSSdyoLwXuQQQulHfkX4WL/g63u/H4ujEl31gIqTEF57pLFYneLvzOxNHdX2tXV3J+o2/UPDxYAdXWgcmlkxDHlwpjkpcjkrxGWYJ/C71pX6gdrk/5YDtlhjtalh2bSR2Q/B1ReTPEW+9jGHmfiqvYikY9d2Vd1NqEaXb2p0VW9VM4oPmij0tClQ565Mzj+KsLJegrL+o3hSJfOYxyUIrKQkWmkzlCgMpxApbn8XDfWmFNkVwY0D4SiFAiX0tlbcf4XNE/Vp9J/cqJwmZsNBu1nO5ylIcNymXHu7LBYqobrJ2IlBF1U9MzvOFb3mZMhocSxgOepKodZX81pV8QpZSocJbXVXPBNKoCppt1+7ANhEIDFAOBXateOzPghAo+jBIFoOyM0CrF7NEMIka8er4dVxmpCqvy2rtJRuMkk9NMWqhwiKjaq24Czio4WL3V1FgCyfDP7MSOyc5ZlSCS7QQ9WFmqXcwXreoEat5hID/moThH3S8KzpyLhuWqyqje6rR0+s2E8UbA7VRxPlH1i68cem8g1KluQZpdH5hZjGn4Je8DEN3sRXkIo2tlflNG9dSuvJyP3HVjVJ6awh9n5AFKbGGo73bGU4GWbRKHj2isGjYb/PFWaytvEaLuWyplgoIK7aYXiIHDwlloMZbR7e5kQvOOSfU6u12HHVGvM33PAK9ODYtuXhmQa0cXCYWT9btAE/IvbG3RmqdqNffygWt/Szoza6osYfmnAYXAUN0LsOB0pT3h6wC0zaRZUu7RV6ktGlkGaXB8mtinTrvjIOlKLjIYBGqn22wvNMNFo5NO1h4ZjFYcnB5sPBk82B5Z6RWxWB5V+lDsuBgeWcfLO80g+WdabC8+3MYGsgFBeGS/Q+7wg+7wrLtCq9/GBS+hUFBG+G4NWrFraA1qH/0QZQ+9EwMH6Ib+LufHvz08uTV+Qv4fHe4d/qT29LqRUHWzn/wQI06ncAa2VG/inZauvVCFwXy/OR1Sy9cO5ZzG8+3H9x43/PgZqOFnjvxpZPe67ogzch12757/35DYE/a5FCRHkrtfpQXSPQF+DBIcsCRHpDTYJQDxgZAgQRxDhzogUlgYRLkOMhBBxZQ6h0wyGFDAxmkERPm4JkFvNBe0f38lRpQ9yD88sMo8NczCpBDMtUaQE/O/nJmgOfYrTltAdPW03CWk3UcbGdoIMQ+yMnn0TA8y4KhsPbgIWUeZLD7NGwfiAnt16eH+0dnRyevPr46OT56eXSeR3Omr73lQZev8QYPe+S+62/Mf2b/vUU/7Q70hbgycG2iu9H5/+EInriWoB33E+hJiqBqL1VSSaPS5JUDMM4ZtW0PVOc9FcFcXUQkJJV4/vyccks6rY31WKqpdO9KzKQ3iCXw4q6VNA0VSuQT0UYJBEoRyDUXXg4VMl6TQIG8Fh0F8sycAgW4RIFC4oiREkQRM0PgU7Wc3aLi3AR3uHoMomGUUQLk0T3JqhIGeJHycjLg0Uy5d69AK34FT6y5FC1MzKTX7iTwIi6YJGul0BFUmhqdNaJR5hwwIFdbzr5HIp0nWHgR+hZMdCvEZKAZ5VhoNJ1FXmBAQqwzthCIB4nCWmA6RCQg6qsgSkFrn1LhgQ9aTtoB9osu8/0f9fYTzsPE6kqHh0IePTgUgYtDQ3HZ+1OYkw7EmT4ILpht6Xs7rcxuW/q1YI/zZzErzWdVEnsi2CDYKP1LGpgquvwnNjl9K4sTDS3F3MaW6r1SUlZNsWE4XO544tqR2K+9s3AsHJewgLQkSgxjjJOAJAhEKXzJb9Nw2QRLMGoIbecNgP8RJjH1gxxd4oMfodLmUnNLy5QKwO6/q8WKhauk8sNWa7dxORmR1MZF8ws1Q2S5IeI6k3ZgxNbHH/fBH2FzOr2QN1CHo8nwKAuH3WyXGTVybL3syzQsb7DIdgl2S6UMt+XugY6Sus2WWMwrF/AA1FPAOhq4DgLiY0IKqBaWAXfK0HpwDk8KKFTphtNm42n49Sv80/0ybTZ3PweJ81O0oOtIre0xWxO8rrIL9f38r7ID9euAkol/XtpomremvUmSxkl5i4uv35A3cJoS4FMJkdScnU36f1MMePCCRtS46o7D9jsxob335vyEQd5iRrnRJFnXZq0pt1O1n/9P2hCPgs/RFfHd+qa7YT4I54l2LZSteOIv70plYGqO06BdeaJ65ZX0K0/TtbkCSQtlF+6aL3fNN3TNF7vml7rml7Wq8xm1KteGoF43Ra3p3K41nWu0pnOT1nSu05q+h4ZcMPDpdzt0FQSuoV9Fqyisc4nBW0tvOEp4ZmGgULJ0KbPIolczBdDigqawZJQ69rSSbaXuDcLL7EGCz/rpzr6NuGfv8lMzR0sAQvef6rhbXg7VG6t8pbPeO6WxXV1z0apnJIuVgiH8I46HTjDJ4mGQRT2H6LLXYRJhzLFLWB+dYQAa8+cIlk/oYoZ+zE+Em6m8au3lVJ5Z3E/NweUrqvmyLxBFXuWNfmDsFm1ZapXKzzIA5MJq5+Rc0julQN49RVdR+2cb+Kxv6kSWytUUVyKqttBD7dgucoqeKaNZULXqWY/ermIJ5xsbkUodXsQ9adp6bbsamkXZICwCeBndBagiSq91CkdxWNpybOeWQet4BGV5UVKqdGKHifTIjmRncmf+TBfYFuPc81D/mHd+mwT2c6Dcaq7x/i95uzW/yXt8+IyfHQ5tr7IObW+xplk4Nuf2dJsj6aVRNZKEeDb6PImEXeIV/NJutnzY77C/TQG2vIky7pWKcZwfdbLYEAj9mj98jv7w7EHZSdTotDY60hu8TRHM42AAtI1w70IMyiDB+BwGALwOAp2GfQ7B2RiqBMm6hS9Qfj0Tox9r2PtQSSOXt22nqKzWilNUBmW6pUVzdfBzbhqL+uptGoPMIRvsfMfIX5NmiAy9ppe0GEimzqfvcpP3nUPazcGdBiqEzgOHqITNpd/lHc78vsew+gIZJb30QkMLFNviSQU0KhZa2UV4DUtbvnYPy7fGhuyi2FC8GzaUr4MNZ37PYlj55gTviYhglp6U330YstcehuLbDkP5RQeUqKYzaMgS1UAGWqMPCEmO9mZoP5YpnTRDGj1gxsziXBlXgW8ZR4fNi/3lRdL5poGW9jSK+5LjLPH1wOaugPmutkiVHL1xcAkVHy0iF4xasumNI9T5I2B67opAgCQvBLqUFW3LV3dDfxC+9GKJWMjao+e6zkhbhhyV2pc8g3SmAMt7U+glSneq9nekUbrdnVp4jq4paCWMuh7KGz4ZXOqpdrv379Oo9xbdCX3TuGWkdaLb1BJClFEl1NDO3/HGpmiZ5tCWd0qwTKopUo9JeXOshKDtcsb4ijy6prD6aGGVHDSVkIMB5ORgGrhKDs9GDt8tQ89KDm8mcni1yOHryeFpyeEV5PAUcnglcvg2cqy5ZehZyeHPRA6/FjnW9OTwteTwC3L4Cjl8skm+swVML59A0uservCLer+/M97nQP+8JLyEv3hO/baNXnWn/Hd77+nZyfGb80P1HsboLYoEsu17mzWgVPxmFN1i2Qam4X2TprAJvct19p2Nei643o6vd8E9CJJPRQD2uk64JmdhzYZZuCb9l/bQDVB7T0Tn3CfLPYiscHqfzecddj+krQhK3Tr+539GNFRdfm2cZZ7Fw7B4PYOG6aVxJNk7d6nz08u90/8+PD0/os9mHB8+P3x14OFX8tSFxx/Z8HS5/k9OmPXa+IZGFo7SCDYh6JUSX3J6FnUPYbdLrxgUFxCAoTBk8UJaCpMxuox6wQiDdqXYRK7FLXCtP5v3Rn/2vS7zZ6Z7/Jl0hT8r397PdBf3JQlm6jS+wZIDucbCc849BcsMkRzVxtd1JmBDjbwtkxtZYCIHF2k8gEIOicQ8gO0wDE/yNkuSMk/l3CP7iQMNDR8WcBRpyl4NAWz9JLgZOZNRFg2w1oQ8YBj0sglGHAJcnKFiJ8r2bCGT2bVFcMG+La5EmX7JafPGoqlQXa1OD4/3zo9+PdRcIaelbaNjbDZ2FaXriKicHfA/PeJoK9fNKTrjdXOaLV83Z0XK183ZSszIpdAwp9YTE6kemlZ84fSywkr4a5IJdr6/N1190XpxrMZKBEA2zqmzMbnOj9cO86jr5OZW2/kdXfzQTBpnWTxkJ58m8+KdZF+8KxsY73QWxm9+/52Nnr/C1XfWlb/wpXe5h3kxwXG1/de9AT+UOs+vQLBU7pdcJsWSXJT/fTYaxvRnC516/mG7cInuybA3+T2Oh93N4tVOkkgvf5ePzA6yNkjg/GTs6cn5+clLYXN3Wndzh/dWL0EJzf08APOJktY+2z89OT7+XqeiG50W+fNtj0OZ2kMPRO/CBmc0ehdLEJ4K4asQvgqxpkKsqRDrKsS6CrGhQmyoEJsqxKYKsaVCbKkQ267g+iAMRMNcO6IQDoK4poIV1pJ46AzCz7Cww140GGP4YnqhmzyqNRmDCGnD4n6DYQC5PoA+TqtjfEWheByPyRehanVSCllkboqgmW7yZaUe0elXQYxSCCO1sJUgFIr3VNDY6S0HlKdh0gPhGlyFIj0IOQiV2iCckvztNydwNjp/Z3fTyGPx40km4M7REvEd9fE6jYKWvDGYkrceL8I8VuQVbhZS3GYnyEN+/YI+U5KvADJbaOcMjKGZImsYuMocJgS/yxH2W/UIO4vHzgOmYy7/CFuS1fNsY0/rbiP3EmKL6NPJlm8HU+PmMbyFgRehuYBOTVLmiVNs/k5tm7/T0ubvVL/5K1YqJQyFuAJZ4lEgmMPhXCuKimehQB5Bt/uxc3MNOg95kJG8DIampAt84RRyE/q4a2HXEZxdi+ARYr26KBJifh5OQiokxZWQ1udveU799sc59b/jnJpHUP4LnFLLXfkLnVErHftxQv19Tqjr9aTeeTaTbks+0eb7CKP/FttV6ErU610BbznppPWk2moqQoITtZBt5NVTTI6k7ApG05k/GAMSnMLY5qpMKM9OKN/VlZiJUN58hPKqnwvFjUcFpTwDpTyRUl6JUp6GUr6dUmuursRMlPLno1TlkTgIsaSKUL6BUL5IKL9EKF9DqDU7odZdXYmZCLU2H6HWKudePEmy6wpKrRkotSZSaq1EqTUNpdbtlNpwdSVmotT6fJRar5ZSlXRaN9BpXaTTeolO6xo6bdjptOnqSsxEp4356LRRKaSi20pCbRgItSESaqNEqA0NoTbthNpydSVmItTmfITarJbmn2FrW0WqTQOpNkVSbZZItakh1ZadVNuursRMpNqaj1RblUf/Idnl2im1ZaDUlkiprRKltoh9PFBDdP6jfD+IhsUIm+xNdhIB8SMNt0aNuL+HjY/tc/QGj7nZUwTyCqCDuH8VJk8Hk1AH6BeAZ2EgXY4RwdYKsOfxoK+AwPbrlDyRG/YxUkVh8qb5snsTu4UT3GlgypZvlmsMO9Hhf5u6AlLwCYRf7/C/MnwSosf96WQQdvtZ+zT/1X529PbwQAK9zf3C/giljLu9W86d52GjIzygKOR7PF802Qv5Ps/3S/lUHSfBqCk3Iikb7TfnNDoMyX4qty6/cUsyf+JliyCjBDFr/ytTtidlo8kSyft2OEC+4+vIR2nxzOVemhLXmWKynFz8b9jL8F3mk5vR6ySGQZ4RCZGSiLbN9mWcHAa960bYffwlumyEbWKNS3+DBbHhko6kbES6zfv375FS78MP7edhRoIokYQWPhHebJfecs7NxvGlM8mazVy2oCNfISmkyWZ8ApVEPhR3Okoxi3AiQcZoy1IzgtdJeEieKw37ZlyiYDSXn6lcPSmsEqnGrou+xEpKmF5ilbCqMlbKJIJWBs+lrSwtM32jPTtnfddYbDHOevNQuO52bUYSezYSeyUSe3oSeyYS+3YSr7nGYouR2J+HxDX3eTNS2LdR2C9R2NdT2DdReM1O4XXXWGwxCq/NQ+G6G8QZSbxmI/FaicRrehKvaUisqDUGWqOnrnA2iF/dalQW+pMidVDE47vz+BzftCvslJqFrNyNCh+QT2EqnPoM4oC6v6Tk2e9UexDq7F1m2HniJI6OOOTt7cswAJRhy7mLJ6AV3zk3wYidLNFzCUo5EtWDPDyPKeSUabU3AE2Q4r8FjTocTWTWK50yjAEFShwMKgJ1VCj597pZHnbfoPUyB8X4ZhQmz+JkeK+LekhFqSdymTZSW8w/unwVhn3UoR4qkEk4jD+HBzkzKBmaTZX/c0ck0hSfedTO4FK3H4w+Byk7XpRPU0q49OxW/evKxRQmG3zttDuS2eNVGdDMScPaJzgKHfOWaWhpPMXRApVoqjnV0W/myrRdIIKbimF2etYMAfe0MvCbjM9ARDEInFJAJZsmIJy8nZ0nLJyKYV56+fPTy9fRy7fSyy/TyzfQS6MdFdt5y0kiuWRfnrBi2ZlpJVVc6aJymbfCuYxuwz4ehvdjXAXvnB65p0HdM26iUT++Qfdvir//RKRnUaeeokW+QFOhkEJVwRRSouut5YoBPXF0DUUslHz7AEMGhMais2iat3VuMdAoUCXdUqTpre76gpAlUPJWvrYgGolK9KMmIlNoNXJiWxZ1vNAsdOBl5iF73sgae3oa7MGuplN8emLSPIGaDFghJzOt6enpWenpu6ZCM9PTW4CedXfwtQnqWQjqqQT1tAT1DAT1rQRdc02FZiaovwBBa+7Xa9PTt9DTV+npa+mpWYgEm63VG8R5XTysYCo+C3mlgjOvYnKra7yNiPu0IMIHQTBseVGAXGUaDMQtPV4qNbNCqFnPDwFAYIpYTOGMaDUvsUewmZvCwAtB111r8VnYIxWcmT1yq6v97vp3o2AY9ZibNLloloJiEQ1CIeQ8Rk+KPyMH0Quz2P/b+SU0Rc8vAUDgl1hM4Zd4jFHiV36IURWk1bWUnJneQtlZmCw21s6kIc4RvAeEAMGAGV7QVEBNKagGxoOQTyP6KAu58U3yY+dfE9hqDe54WNXQCYYx5JALrFb+5W3Ucy/PFnhXFFE4V5wwlfhWOmUy8E94yLmsB2mQWFhZoErrYJqFsbre2LfkkzSLh9Ef5EInMWjRBy88kRUlrCpLSgACU8qFc+aUT/gq2eNVs8d3ayBZEnu8xdjjzcse38Yer4o9noU9npk9HnlJA190+Icl7uv5abcf9yZ4YaHdS0Kg8+EgxF8N9/yUX4Q6P23H5MCVmifxZJSnE8TkbbVPWfvs8PXe6d75yelHGjSCQR187AWEZOaqDvKqcuB2mt0NwnZxx5ea16CaCPrx9Dn5aSjE7kIeh5dZ110b37p2uFO0FFPA3QHak40NfQE02VVx9eLBGTC665dqCcZj0Bn2YYVEb9g8GztQjxYIaSYEq+bplUiLU7lWAVHTCsGQNadZfJYl4h0M2FKg+0q+Gl5Cy0kMF/GwYExCQLwMR5Mo3R/EKUVAX42JhxrT+vnpdNr6P+JjI6A9JH2NDZ6nk3mQA+UDn6foXoLOr1jgKcCLCDRKbGH3Hr8ampdFCzu/9YcQWWsJ0+M/aeAbAEG7y8IzDB3QdUfxDQghd4ZhHMpHF3xAR6NRmLw4f3ncDRcZ6nuV5N3j1M1BhbqjnHu0VhrSvuuSu36gpOfZWXBxNOqHt/xCcV4inmR4sQEpMwp5JClYPj6Fd/34ZtRNuo+/JO1xQpzmDsLLYDLIGqxFDKaRNKdFQaJBo9pMipJkkpTgnS0d6CQrQU4yAXCvNsq92hjJXCqAgl4WfQ5wGRRaR0RENOo2mhyMpByNylBYowKGNXI4lFb9/iFS8DhKsxC413DzTrka2jUrC04yt0xIWzHSZVemgA2eMbc8JErDsUbf9kpdqy5e9HCv1EHD8iQhbi5pMbHQiA0RtzRoKgvJ/ONJmoXLUTtMJj9GdTKsY7QADw1djOwvUwJbKE1t9ltYMkAVitPwbHKBPyBrmo/4L/UEvCLh7983466/ZOxhH0J5ybBLWqHEtJiNXxZapGaR7VN6Hr036oOynSXxnUB1qmS8ivv5wlLOYefZ4ng8LYYUzZxxuprK1RRDlrI2SVTM8nqV2+RErSbszdgCu1TUFqkx6c3lTPOeXKmlDc21Qt2CT2c9h5TnvAZ+ypdoxAlKfj/sdt29JIlvDnCwSPOTi4pXJN4ceqC25CJvxvoCr0E5iIDqaqFDooKwIoUgEgBSaHDo5l4hhZiQpVKhl+MDiNK00QFwwaa2HzVK11JO8VGp15q8sqmgkmQzyJqFpJtNdheaT/Y9RZ91t2R+zCBXSPvU2HKPaaTaxw1U4G72xHUfsgKGXRwhD6YSLE9Uwu0NBtytSOI8bPAO1TsK/yf6Iqyrut0ZG2VFnYX/ey8YDJCK8jDmqVBhaQPYSvgdCLof3JWLdMsbqXw3D63/qLb+MPpSVQV1GjcaCfKwPnSw8Qbw38oMEXaTH2mOuDstbWu9vDcBTtp6204COtugFosUgSZd4nHnaqEsG04KVohp9/7fdjY31nddq4ZJStXQh9kilfINBhrD2USH8VIDQRZPetfk9gDFkrZJSpi2B/S98a5XEtPTpsLVP+gGUmUkS1/xxLWGjKV2kaBIYkLCXO6LS4NUIxGt5Gwd5atJp8rBZVnNU/scukUbVUYzVSezTF8aGpj9UkIx0OSpVODLbGRj1rpOK4S/UZeNl110fVnpRu2YhMDBpevrV4Apks7jMaZEeQINYLpLzrIauZTgzcAm7lMPUioEV0otIjGFVr0NqGVDVP0p3fLfdSedQQkXsJGEOeawQcRrR4NuWVa6ItIA6HgQwooS9vfo483Ftp4tQmyiKHNQs9qKaHt402YgY2a1C9aCaetFKNgSZTFaDqQn5rJ4elIBpSGFPJ5+Y0tl6SkvNge8Dvznl5cCwXCpNFXI0Zk5Y5Cp+3wZZFe8sGyGO2LzyrH39PiQLx45OBfyPFaTy8MjuXpA6tfZdb3xrQOAUd/523YH/wD83RivVUWgw8AIDi+jUdjPpZ2KB/3engXDaHDXjQxtQpCz6I+w2/B/yR6sNUF6P0MXuYbXXHHzZUjfQLR7YvQgt2MEuz27DkBOd11nHfrC/2K/kquLoMGC8rU7G00DCknE0R/twpAhRp4XmFcMkmmhgH0p1CbN7JRVJnF65Qim2pkmhhzOtfzeIAwSDLEVT7KGAFBuMNmeySj5fLBMbIYARTWrhMoSNAtudNjLg8V4189vsrzkS9iXS5hqbL3YzR4pzOihcoHmA76s72YrK00j0Pvsg2Dz16yLu0pRg+VCB1A2YORQbGVhy/o8PfqC8GG3Zsd2ydXJ3E7W/BLyLdsupfd0KlrdaFtcd5c3DJbl3bC6YSFvWGRpWCg1LOtmKxHfPq247pTzfxqlb9+djOg6jTegoQv3xEnDb2t62LnssVpjoTMAix6Zc1e0Ob+hGnD/fmhAC3oHZD4yZuqR0pvk+S3TnLoRUDeqpm7EqZtYqBupbE/ES64fo/v3kzbXDhQKF9df88NA2RzCBx2Q/Ps0vdvNmlAdjL0BOiTBGMbmC8M4KQ/jskGGNxun63ds+JdcQpQmm9AHkMFhNwG1BwUhUT4VGagdmVPFziEsGZCIRdLD2144zhpUdJMnWciaVHqShaTSJ1koQPEkC1vR5lnvLEYOFVEdW4ehjGTyYAumZUna/YYrh1Yb31UW+ZbEJm6jSuhzC7ncFabXcuXubiS4eej8PJ40IjOBW9iy5kMVApYJ1Oq6+IzwFHbdheZNtWE6eTBIwGFEL+MzA45+TIgmgqTNbGjNFjWpDRnudB92RZlxXJUINNXNjKxYd7/d8hap0jfi0pfcH8x/FZa2lLYySk+AEGIwTH0fkOQsUaR6JM1PaZtNmfFxIWYQtRF0zX123ZPpMLtVJHzc2bXMqE6FLjbdg75yF5Z8umBv/hHV6EFW9CCblkwBqGJMp7svwtKs6Lpp7jeD+cImvOv+7bKPf0iGbATGPA//kDzBEAAZvfXQu7x0iVfXaaLYJl+Edtsk/tgt7R/DVr7Vu4j7d2Vbm6B8ajtfe6NRHqH0yKO0G5UxiDmkRv26go/mdjNhKbHs7rJ43A31oLnQ7exqZ2yhAK6qqHtJPBhUqIatxKj76fFVKIW70WN6p4vaT5n62TBTqJGtNqLVUplmUyUHTFcJNa3PhBsp2ghXG8lquYwG93Ta+pTVGL6K7T4fqRozLx2WONDcFvqmIPdS3Isk7YzcbOejaq99Ohnh+DsZgZBI4qgPnUq7HAw+rnCha7ZSUC2OXr1+c44LlcmNR50SABdchW9b9PNdE03Blmb3LwbMQI1t3mvD73AfE54iudI3YwG3YDyz1WivUKiNrQ7wG917mjPIAVoIFhhpY/X1K43lI+wOWNMy1jQGwdcsrTihs+4oa0POOct5CpL89wjXItSSo0cdtuXYFVYp7s71feRCsmy5kC5ZLiQzyoWXQXbdxieqO61MncZGCZHOKCGESkBWpPVkxTwLxKPuBtlnbzAY0WrCnKJfMGNxmpF3sM9+fX4dBv1c1jD98+dH6ecrx7kdDkYgTK6zbPzwwYObm5v2zVo7Tq4e+J1O5wGAuHQP1nV/XslWfnad65AedLGfGJjiaXzbdTtOx/H8bQf/cR//nGsfBqNn0k1W3EdZlA3Cx+5KBN8fsB/NVsjyf34EBdLHjy6jAUbOiPpdF3QHBytznTv8F/LC58EkTaNg9HQwwZ1916VxWYhXedRznTQDfelzFFDzre86Dx4/ekBRwhdSw8+wJJD6rvAe0ygFzW3YdcnXAR4AdVrQqSbUJuWnvWCAQcpWPcj6GXTAguDP4jgTrvtA564e079A0ccuhwQhdgTi/RxxEnWiVzwziY2J0UqbYU/bG1CFUuws6e2DliiUGAcYG6brDp1tx193juFjvQMf8J1/bmzCJ/zgnyQdfvBPUgx+8M9tWox9wP+O87vrAPkGoLStdy4v1ztI4iT+FHbdC3xqhf9cZeNmO09Aj1LQCLsuOcJxHxQ96ocwKMOqTnkbDmkVfjl2vB3H3yE/19fw54azgcmQRvoCieQ3/EPysU879Dcpvr5OkEGaty10CTs0f5eKHpG+kIFIusNU1lbaGrXiVkAn4aD7oi3PziDfd+AcGHQH5jG52VrdxHG3MlohwwvmTcTKvGhrB1azhZlxDsaLJWqxnAcgB/M8DYsoQtIHPuBbA04AMv8QvOh7vjt90TaSR+K3T4eh11krvnidLfzmky9/cL4NUChdJcEdScjwBGaSDBqw32iSCS8gzbEWn5635joOkeYgYgDhQ9zf7zImP8yR70rj4OH6+HZXHAj/G0ejh2Qg7MrDgyVq2gZzYN4uw1C9vAx3SPfIw6e3Xtddh47cwae/DnLSZ7/hE0oWY/pv4Rr+UUe1bxrV37mGLaWGraXX4Pm0hg2P1gBEplVgwlJr2NpRasCEpdZAqCJVsTCdpOG4hWNvbd3ZZMJ0Gz+3OjTd63ScnTU+IolRrKj52TM82K1fszKT9L3uKIPjm/R6dhFBlolFxQMIg2auRODZMag2V+EiMvQlco4shx75hH83fGfP2ejg//SPRxOPHfKNAO8UnwR8rYP/Ayj8QYyQ+LsrEaMQkfhzlSsunfa6Xuo9IncIb5n46Lqrax0+itiKa1C08lphd/XQuYgHfWARnrUD9Cpen7/cnaNBjz1/DRRQaJMkj78b+Zgsz4cTHVuuMCrrNAV0mW1U1FDh2fLbG6CrFZV3jJUnYV+ueNZ6l0KCbzGdvuUok8ZMPm1PgxsSkm4xvQfUcCpdt4ovTAnYnEnv+Xl2vLphqWgAW0wEs4WH/K4vgeW1flPGRX7PictjuNbzpYE1DBPmxLXZUXBtdubGhX2TcGFCPVwL8JDMq/mmlbos7jg7HqlxvfiCf8leDL+ow+fCxz/5rP7b5iX+mbEBpXG346njTuQvraPuuOO4inFXF1cx5/fj0WV0NUkWW6m3mWrldXxnm8hbbw3JvAfi3COK1voGkbbO9qazheRfgxFA8mFH62Guh7mQtIajAUAAUFMccCLqY6wFK1twJf/5z9iJqyS8+3a62UF0FWXBgMV/WHiPu04oRntPv2zvUKUTPueU9NVYberHPHKCL7X+Dl1qN/y5l9r1jnmpdQo27I2uJoMgmVtJ7kVJbxA6Tg9avQnTvndHP4Gy650ZyF6Bx2pJWrfu5hEL3eOxJY0kwOfOegVelFF1dpGEW/C5zSpY2y5vU5dSwbpSwfr2kirY2ZZ7gBJ9qT3gFawrFSzaA5Ndb721uV6yNScYACVsrG7Rl7BdcV1GkXgMf3Ger/r81+qGOsvprLZMcd8yxR885jbsYgIe9qNsYU13fZusF9vFF7KHgRz4nMO+t71F9+xbG3QHsrnlrOFCs+k7m5i+s4YbF1g4fDQB0y2KvzO/Rl3V/mXL2WX0VGwTCYNhbZFvb5EokQeDxcbDZodQ8NhZB/WAHmBs4cZyjZHX38YF7Bjh1vBzx8ffrI+E7Gix6mAKFIf/5+TrN2mHPBLCcL2zVqjGO9623/FmGwsF4c+TIF3Q2L62RrsEQ2pnnWv5ZBhtYEbtmWgQayC4PLwqYJBrnkaura53iCyDXTuRbeyDpM4hGFZ3qITcof3MPzYKMW5DBgM9l4AzEk5m/Db+WUgEHKu2+G2f7YjY4up7eaWz1COeVIjVcDWEV8O1kCVXs70pV7PdWWY1321cLpvbNUfwcixp9HRcXejPgs/hYtLFR+cA2MfhoSszGm7i/8xqQfZ4RR5Ce+zAuvhCBPLOlvCFZBErBHyTsQMMoqUrMtShZq8TgT3f6vDn7Yw09tY2ttf6hWn3b76/ednbnnv0kebT1m9uYAs2nI3C8LzVoRJvqyNn4aZ9c4MdFUH58gzZwj9FK3ub+Gc2zVQQxptkqwtN6RRftjsSvdD0wLwf4FPMgdLbZA7LTQw38M8CTURCJmGP7I83t8j+GLcnbJ/grXOvGgeE3TbuGhw7J2dugDyV6XMpi03obTrgN/mY9nwyC/5wTNakqsN0r2NuP52SD80z0tQaZaw92zvcKpQs9XeNhqgaeK1qK+Vx1dAxLF2rsFWEv02HmlM6bRjGbfhZQPibnZbvbcjL13+G9JLotOC6+Y0klzKa5thRf2O5tWADF5VaC1ZPNW33IB79jAHN0IMZ4zinIMDabi7P0lEwTq/jxe0Qa2T/Bl+2toG2m/CHjRDf2V6nO0H6uY3aPQyUNuy719r+Bj9e3VgnI+UYEeCXPZpL4DjMNtka4D6RYcPRD1+kGnEGAQ6yiyT7SykTCvg4CqBd/qacRTqBo2A+S8ZfiALSONzq4J9C6q9v4p8Zpck+NfISG+8GtfFubBAbr7/pqiN/e2cj3NmsqHGz7uYeL88p6ndrNLMC7rWBONttIkC22h4sWu01SsTtnTbZxmy3kX+bbZ8uadsohSBvLU+EjVJ7m4NvdwDX5nqeDMV3eAHf50igqg2HIifJ3rzj88/U/pJJ7/Ky4HWnsx5s+zMacoCfnNsv48/heUxC4czHcy6yiYMYjFI/F9kgsXP3bX+9rgWF4/M7Kr7thfBtbBJ8eDrOl5RNAeHO5uwmHpz9xBEFPslSubGZf+7g5/Y2ZfnGJrXbweeGP9MusD51lz5KZuDEt6t7p5pry698GRz+DpMWb8IsOGeXPWm9zpJnrfcNZu3OJuXpDuPllp9/7jCFl/AUfhOebvlzz9p/57StwYtvWPm/ed7OzeNvOm/puy+L6lb5vRr43GJCh39S/6gtv/iy5TOtN/+ywQjBP/114S4OCrDNubWmb94ww75dJfTJp/mI3BPUbtm1YoOo3bM6aRgQMR+MTufC71y6qtcbPfpbxwNXcuS36dPD1B1q1NihqiY9CzQcr6r0eBZEg7D/n0CTy0uv44UyTdbXnJ0dqiBvEaV5g/7GTR+9H7DDVesOvX0Fqf42U6l36O0snx2ksutZrASmbKPncj06HsSj7L9H8c1/BCW9iwCWAMFXam1DdUsm3ZzFV2pnU/WVepJ7Sgl0ikaX8X8AjQ7i/lWYPB1MQpFMG51vQKZIR6b9eBCMl7DZVsSuKlSXJM01aGuI4r1+/2WQfAoT3ktb7+55xf+ua3F2I3zsqJYQ0r27EJ9h2zVeouy6fWhPEvYlP8J1qrCsrs/vsr9Zctn/eUW+BM/GgFsmzmy2REKa3GOMHFx7pIfiOTZejC53uebNUlmd2uwU8pV82SaWemUAsDroEMg1wXWmhRaaIDaQK4JrvuYA5x3hYJ3Gi3arwyRIQ7wNMYivruaiqPZIfm2DH8mbzkU2Nlv+unzogUcP7D7lNhoyyXK9Ts460Izok6spHUzc6TCoHeK+Q84suK+PRw9O1vF/epdlk9yUVtVUGvFTofv2NqE7qvncQVCgu++XLuUU9KYX6zTIdjq1kF2gQNVg+470KZ2IlZwny56xhguBOg+FJEzD7NcovHkdJ9kic9fjtzU2mBcKTfCpxaeyzdpbphyTPxsikTvkjIeoS/yTupn5zGrvs6NI+PS3mWDIv9DDPY9ZRIhOtq1Tr+ZniTyYttqgH261UVvG48POVpvsF9CC63nrJH1ru40O/z6zy5Kszhqx6CIIXjABOPILEW17bXrXBY2+m5vUUtuBj00PMazv4Fdy+38DtpUUjQ84t9F8+7tj7SsdjNAB3dKG8yyh15OkGb7Z621vXWjmlCMe6m218eikjccpPrmuQ48p1jex853tNtOINY6i22F/c2e73EjH1kpvU6MAVLRxE09v95yNHdzgrK6z4xfY0nTceaasMdSDI92vXcMdwh4x0nnOqkfPb3bQY3WZtcrOqQckgMGP1X1JqzuNKTWPplypR677qh5Jr6WaFUg2Mrj0JXwiyugdc1+k7pGI9445MC6MnzBcwo8OjMvBf8fbz90v6Y0Dn1W0FPyk/RJ+0v7F8Mt784z+P/cgyY2XVNtZE4yX28Wg9ra1Yk88alpfrPxOZ67yIjGO46tn0WAOL0pZ+KzL0Q/WuIvsuuR/YXO52B7fKvcq1xSkG5sS0po4Hf3VpTyIx/oSkHLRy5Fuby8BKWvoekcm6XpnCSTlSDlJGdI5SerJSHc6S0C6o7TU85aBlSHd2JRpSi1GC9KUI+U0ZUgXoylHur0MpKyhW77c+y1/Cb3nSDdkpPM1dGNTRkpPqBbFym8LbMvd395eQvc5Us58hnQx5nOkW/4SkG5ty0i9zvxN/ZmH9Hsth/TD8JINEv//dfsjDTXYpU9SCBGAL8PdLH+35PxujA8JZfQ1n+72L6UoiA+8zuPHCMGWtc1fyjEMcxgSWNGzIMGYiL4NAwn213XZsui2io5g248wkDOm9Vg45W6eT7GxMMsH0WcRqvx2ituDNTWJ8ClJPRx9QMXr/LLXvsI4osEAU/bj8LIUr1GDAV+kvBzgIynBJIvV1yEAHoeFFC37NQZZwysvDZ77PvzQnBbdo7wVQv0R4Dxkv+n1mtenhy4N587DUg5BQY9G58AIfORFTn0aZ1k8ZBn507HdTOqiGCc1bO6KWSRENaubRB5/7IVru00RRHzqQ0y/xFiVJDnv5Djon+ErZNQYTcNmM5o9CnebGbZzJcsjSuZBA6H/55xFWRH6HBiZPYPJ8C4MkobMxVV35XU7r65BQF9Cy64h0xNBW34JmgAfkPfAVECnDPgCxl1ahnxYhnwZjSZZWAlLgc9CIGQfgFdY2cEgSnnaA2BC8QrQWrO1mZN4EBMSvW7Dl1cn52fAEol8OOmwb7QzmViOgJOybDSPJ+k1m57i8MYhcP9+npiOB1EPQ2cqYKvYyGK684CnxbzIUOjxQt33H4gAvJMF4HVEQkTeqVgaeYrwxkDhK5yLzbtZxKaXi82darG5XUPonQY3OHgDt3WnkXp3gtS7M0o9yMFeTVLyTLtJKhwc/eo2ZVjLg1Y6OCLp99q/kVa8pk8dlgSjriB5MXGukoySwKSz873zN2fHR68OXxwePX9xXkdI6zBeUHE3T2PY647nPMYvsdc0NuZtCUOHnmKgxFRAsScljWB89XnLlp8ZcClCviGVpCMmHKVxkmJ87RrDqwCuGF8lwNoDrFQy4cOEZmEOmZJl3qxs/6LU0KxXBaoxrm/M5gx4JzKgBFWMZ0D3kqy/dYdPmaza8WMCUwdQCY69VseJc4RC5ilJM8ArDzDKBeVM0zArkJKhE5MXImqOMwHYPs7KgFSC1xktWlaUEdYWcOWiZFh1jNnzDxgNfXQDxgimDJgyXPl5wyyPMZyZJIuApklizIe7eerLo1dGttMnCgTGA3AbA4p33Wg0nmSunNO7Dnufwj6+KiSly6/zQFGUca4OK8FwEd+6OgQlvwN3pcQUiSdNLRqqgFNCz7GiFOg0LyBcB6Mr6Bl5UPCunb+iNC3NHZU3gI9yJtqNjOw4e733CqNMCxsG92jUG0z6oTOMRtFwMnQ+B4NJmLqG+qJmy6yrPD11Te0MhYy9X5/XHzAAbBgwmJMPmI6cXjVgCqyaAVMgWGjAFGiWMmAQ3TIHDOCDkTDXUAlg0Qyuwu8wVF7uvZ1Btuy9NckWyNHKFkivlC05Vp1syREsJltyNMuRLYBuqbJl7+28Q2UY3NaTKvoM2/CZqwx7IMVog3Gbu0n57fgeZIaJu0vf7cGN3jtgMKOgjqKARLS9pG1WA61/lKMIb8cxvt3OMNCfGgSjHIGh0wnJwC1pvvOsVMVEaLsupoGsq/RritZWuzRlyVtOVq1qZaPWTkGDm+0xG+sqgpW597E6EuvUOTOcos9pAHV7yNr4NLqeWDYfJ+e1Ht4WgatHlAimmGF1IGTE5Tq3mstPdTudv2vzJYVdzbzgxlRDfm5mzrn+jKWYmH5eeq8bdlTEMxkN2uSLBbZ429vSIG4fL9xjy6wXZYiIpjm9U8zVLVF+5S558iOe7z8o5vFjYSsmmsjF9PfhB+G5yEn29WtG7Y8KUHOXbC0HIXnYtFxXVn6xEk/Xd8PHXWWjW3qh8UmjcvFKK9WMVNYtUlGhSE1aRFpSHdIF9IV0CUpCOptmEMnrGL6yVKkGSC9sloxLYm6kglvX7uZD4KOR1zCEgIuR/PYmNFdK8T40C87dvy+OOGYUx5EIIFG/i1/RQv/xOkj6N7A9PurDNEnEwxYOcZlE0IXBHb7N18B30JPGbtWgfJwP6KYCKp67KFmDgJ+8AP5Tyqf8vVKxN4uezLwZRbf4uj2UHY7P4zQ/omHPTrPDhgb+035zvt/wdkhgU69ZvH8E8zuDLH7gkaEF3QvXfmlkfwewVmg/5bkTDk7CylMeATq0nvKogOZTHhXSdspTamxxyhPOdMqj8rTy1PD8xeHegWtTz8+fnhy8c20z9/zUKgFJtiSReyCRe4VE7oFEzudP70O7N0nIa7f8uIieau5K65j2GV0JQpkGRYY0CYR0+bSzZcyLqBYeo+QO8J8B/nMNfdIZo+7fb8RoX7iGTmqND+R9rRKAsOUEgCAHCFXxGCoSlrRtYuG3q24OJs2WHb6VKvA2Rlagmkjyr6eTfwADKg7oMKPiUUWgL6brbdDu3y47+MctIIgadCzuMUTLtgx2Ku0nzHB4AqSDKlEzBo7NQAYXJMNCTR98/Rrgm+RW+EqaCftVssNyS2xvtgYz9mzv85W2Z3Flc4Xufae+BbNyLbjV9g24MVP3vnnPiES46vJZ+st1qw/T1iaLYV4+7nbu3+8/EuXxe0z/0MalEZd2IFe/a8mn9V52O60xOWKnQrz/GPBePrprg4A73fvtYO987/Tkt7Nduk71iGawlyTBXeOq2ToX2rkP3/eLdu5zLX4Iwhdfzh2938dGk8P9DL4LrdoXWtXt9mm5U8CHE7X3/nRl/5frD11SaBiNhELE6iQu16coggelUnJV+lJBua7gtrLUEAU/AqyuTlkP79+3dO/xOVRz3rVANKdAoHtDAxFcV9NHnhhoEqeI7gqZCitw88vYqgXsUkYaQUAR2d0X5thdW69H9lH7OY5x35OTa7+e/NwvifTLbrfzRAP6EHq4XzkPxwaIxuV9r4mY2U3lh2IRcYLuF6vpELgxfNTjQ3wI5LUTqyUSq/d++CFvcFksaOgz/Pt1nb4LsqoxBPW5VinRwjCMR3E6Dnqhpu/y/m3cbF2urEz73XMcVmPq1NOURdW4rPsRqSWmo1QSW/9Udv8Q2rxLOtPQ+oyUmP7sGd7qVL0shDXhVUzceoif0ajl0O2UE2TOIASl04GFvuXAmujEiQPLh8MMsU4EO6fr0Mni8SrhlsP3+2HqNh9efscWxqPQoRtG3ijYd0D+RUxiLj6s1QxOZtUdoCz2nxjbeX4dpqEDu2baCGybuyJbNGhHkvgmbbsPl4TIcd6kFJLa0p1LmHQTLBw7JPwk5Nxcx4OQUTHMhEiUALD/OcUMfnuDStkU1kBp/zOBgTwp1rJJsf/pNHdhYU1XVvCNXvxIyAfdcMBuw0VhmKIwdG3YvrAl//3kg9BTRN0IVrrurrtyteI2YLFrskeDhdTg81WTvQkswga3kDqNu8HKP/8n+a9/7tLni3OlIoUN0KvJ8CJM2q9Pzo7Oj349/Hj06tnRq6Pzd9Z+QxMfkXbKuz5cT8Tk9wgoKR/XXUs+2zJePzK2idJoguvYVXXLUWPqFy3vcxpfovYxet/HPvTLfWiIqe8RTtREEAB7MqFkJrCFAtLXKAWUWSK8jLsMn6j4c6VDD39JFY7+B1zwzR2z9OvRFVSJY88IgdV8/Zp33dl13KJj9Fci/mpOB6hggHZuUgiumyu471rpTujohMF4NWV2pJhPT346xqzRpoU1wPfn8Q5kFjzEZfRBL/2827sOEpjs3Ul2ubrdclfCUQ/WmTenRyAQhWkvmtC0rilaC4B21w96e4YWsL0MungxycKGe52El24rbLbUDJC1o0Ec9N2WmwQ32JI2NNolgLJhmVynbeVdv4j7d9ICnGGZ3iDqfQKVSgYT7SnEQ/dO8NAVjtS6XgctIYqTVdcnqbL4Z6Dq4RjAloz56AL8LmQ+wD1YNLNk0stido+3+SW7jtL2x3CE1hriz0ETch9gntALxvQ4yVUSMvY7oFWG7KS3ZBLfRYt8fOlE97ourGzhJZCg78LoTLpRk+EAsnwyjq89VwQTzSFie0QQykOYSymu8eM4IqfJZQjl+OBiEPc+8UNnyc6flO36IxFiTQOxK1SXBRdH0PXbbqfcCHZO2E2JuVT6twxMTyK6I5Iv/VuGzY/BiKJDA2xoiGBW1Uuggo4qHczRND08uy2yqaPhHCyzuF8KsOUjl2E8SUM89GSnLtLwx3Wnkix0W4JnNDUqmmRz18PJX1kTkTr6asSZSaqsRPYpvBsnYZq6rVjT6rgN+d2ue0i48vUr/w1rjb6yKep+fAYX90zyFkxTXFLYrECju26yZNNLEAlpQ8plSaQCJqzUClgyqYOD5FVwAZeZxYEEiJYpugqQKhlN1CpZMqmSg/Aq6W9cAsZhgieQe5RUzS/3pMJfv2ooiduOs2tYhnuTrOhEXqKR4W2NVvZEFZAvzl8ed91Hk8egxohisp1OLpgOgIdHGM/JBuM1H1aL3mnewy/Zva5+xPOFRiJ7weknnYerXksCfdKYRzzUF2Y9CkCvnsNGrQausIN/LHILVrdgMsjMtf1tr4N/UEWbti758owD6/mbI1wt1YHFkqfSCs6GAV0nX8U3eJxCUuglww5bZdAFI/+hXmvENOrDsc5BmBP1Gv8dpS/jfjDIsdOxGODdG64eYBKenQVRLodTKfNFGKC85knsOg8aLakAZ6Tq8YDtOeQ1Kfj0itGewVHHkf8Ow/E+7L8T3hHuf3FA6f/M6D5iBK9a1rCBMCH2g8EAd+nEzkJztFt3deAxoJIruLwsS05QXV9MFBY6VoHDx1IZrNyWPfzjGhCKDWKiQF+pWJ4ytlxVp7Pl9wK3DCotoxpMZdpIqPhMKCuYZVz0DpmooPm626rlgvnAAX2lRj11Bg5sODKYu6CSt5ginKmKsKn90OjM3sZMoQ2sMTBQR2FDvp4H27OTi/+FvQEu2yldWfKdegQ79ehRyHfqEexjw/fRB2gkazpp4ntM+0CEO/2qIhA7K+LK8kR6Xi2AAZpm4QgxbR1l8pVFFIsgXHDBeRmOJk/DNPs9IgoDdaygXezsZo+O8Lohkkh0jMqg9uiyIeW9zz5wsQabd1r3qscb4YUbK/4vOmRa+fuxH30WBMFHItzIMayQSOo6iD6fXUfhoC/mpDdR1rs+i/rhgYyHkSeXq2LeOEiCYdrFPSfhc0tubU5jru7V9E7NisWEKXQg6OIeceogeo9ymVJdpng1BFYR0ios7YIqyonqpJbMKa0vk2sTvPr8UqucrPibSihlx1NbbaX9C6UM6PqZjTQwSKb5kCtl0du0T+55D/MkRRuFtY/r2KxdDJtNBa6LuaQjP8lX7gZT/ejFYaKIyiOf0VoZLS1TbbkBQZ4RCsvkzBIKhv4CuJCdx8+SGLcXJsEqEU3Sf7p+XmHRUKoNZWUuF50jZ6W8GDtsoXTfpbO5oWOUoXNVU9JMj8LH9xI9mlwbrODFa4EqvHUtQNSPvBJMcu61wam6Q3J1ETT8jY0W/9tpb280Hav5TYO+KYzBWjTWjFVq9jMOoOaXXpCGTqc0tXTe1yoM4YiEGlMMxpGiGLJIKgUJlYXYmBaLkaTKgmwvIJWkaSU71wVQ9tMuIYg3P0HcDXQk13XakKOPY9v5e8vBf5v/dlr4FlpI01btra4JiXCLQM3j821jkQFAWz4t4yZauWbFlIxuQgFlUutKKqecEkixx9RI6Iv4lu0/XQcDVfO/uGcgwoM8PQxiA58nps4TWde82u/m0lyonCrZsM7pCorq+craLxbUdidSIn2wetutjdAoL+wXeUKTwKhXLCkP9noFddOkTDZjcfNQEzeIrbD+QNNuUVuaKx3GssJmLpQMOcYS5TrIXs1ag/Zeizn8RX4DB3fSeHOFBKq9SYIx5tWwE8vaU24ZLrYvFTcOFPCSWZCvTwiguNsqRZvy5M+tQOy+SdX8sUyeSKOzRCVlJ5KkpGAvqJr7G+XDjGixaRCVLmah4l2kl8dBJB4rRSYTabTofIkEg/KLtvCyYu0Oyk8i7ONwRPcQwm2yX3HoDpZeZqkev2xHoocuDjISgE+kgwu2JcjLq27q01o7BnnfXkfBlEpUKkY66GUMUDP2RDWXVWOvQjnnLDAjVOeFhbKlmWKGVfc9OhjDqYMOdO5JpkMpTjv1tbxF5x56JjhhP8rixIlHDqoYTop01Q/ZGpOyKKCZWhqc4i5NuUkyVfUy2ayIbrMGQ1mdyagWqpyPhgJM7bbPGuONaCvqOvNxPswlN1f10qeZ7OQeqAF5mdcyCry3l9/I17Ndj7mCaTzsj78h6+LMHm4ijt6+tyJ5dBgwTrWWRfPg0d3in0G31iKZWUPXYiHbg3qgyzac6msxye3qe/VauFz3JgbUhh1GVkP1p4klw6C5XravqKhZt/swHk02y/tk9eD1icnsbdpYlb1n1KLV65nuxDE/Tde3RDjjY7t2h/3fdOu1wzURX68lFLJGaVez0rQIRZtTFjtTsfxqDBRa++EC9m6CRrNJEk6i74lmeAMMPRFqUqcb3HuVDlbouXymbu2Uxmq3fM2pvJ9kJ4+rnrK0aM/ocE2RD+jCD10yzLDSbkiMJPca2aNOs/lFxsCipWYtz3wINm8T2n/QfVU4JTT7Q3FTsg0BVrLhdeA/b8X/JZPuL89wPqAiJIeTEjZkqaB2fdEaVmGyPGkYTK4WU6NbUyctnl2Xj9ur1uN6iim93UE101yqqN2oYy6trVp/i14I6jX6AUujjfvqJqF8+B2kn9RLESzWbqrG2k3F7eEwkvqw3tF6PggQKejK4Yii+KW908Tby9eCA4WC0NusiZDi+KW9RTDmvkSdluwY5LVMXkSeErvpHcazIhuOJMyDqVDR3Ar5fAwbCW4/4rzUq9hYKOKFIlJoN5VdFUbYbiklbrYKLDz+MLtBHnSFCtTQw4OqSD67A01YHYL32h4mYGK/HMgOhScqdpdfzWWTQHoUVuDldkWU9xbwU3jtstm6nuGm/IFbXFGXlD+f7Mgn9byOJ7PHDNLcBf7fSZpFl3eufN++3J2BlHDdbAVSwkAcITzST5EynbayRPMwAYkVQk2ebJJH6iSPZp/k4sxGY9nss1qayiTiXDGNI2UaR9ZpnOQT8uS/2YQ8UifkFE260oSD/d9RacKxcBJp98g84UaVE25kmnCxfcIFtSZcUJ5wgTDhslYsDZugCm8rMM+ToN48CWafJ4FlngTCPAnL3RlJCbEaEmMkMpbPkyNxnhyx9dCBCqBY6mSJPGVyj5d0MkaDACa+aAuvhC8ixvC+Tus2masJ7OH2RasnWsFh2SOOvNuJl8Tw7U70izvKwmHh/3PY/qiFEO5cOukoGENjM21pNTN/V2OMCneAIun5IL4IBtEoyqhLDJSijwSShy1eh8nb4DZKuxhcoHBD/APdEP+Bl7/2BoPXSQwUy6IQI+4UnoR4hxZ2eySuSRNPLoIkS3+LsuuGOyQVpHjhQF/dysr0sD0MRsEVyCOunRcp2ITjZuuQbf6oS6EAJyUj8KcMUi+CNCR+w0REg9AChEiX9ATGMonQBMnTlma+kaq0nOjKlaFxNWfEi7b8LGvRAoPS2Wy5p1iCXK/9DMWYcD1sS3UTm6ypQcLDDwp92nv9/lmI6i/6ParUU1p+GtwgZjL467T7DKaLk+QPO7BgaOwxF1KXOhTtlOPQ9RvACuQkQwzQqozXb65LfJuudl8H8VVa1AUpgCWlVhSsUYhJdYV29uQg/Aw73L0kiT4HA9zLX5C9fPPLcbsKRI/qFG8k2lGVQcSnQMQGf3mtPLxTUO+LhnftSRom5KYlzylKlqeUOn71Q7VUR5GreCcf4koMokdyTc4T30cf2gKvC7MJtGRXGQeaoI3SPPtinGU5AdSZyemXXwB9EaQ0RCDeM8rfBh+Os7tTULfi0eAOVJ3LCIYZKlGEC/98F/eyePXXKJ2AZP6DiGnnMEni5L/+iwJPEpoYpehme+2EiM8JRn3oQdB3EGuLxlFwelKBSxjo7X8W7yuld6Oe8yxOcLDgJVrWFv5WTsOlycBK4fa/hLKNCs1NEGXOcbuHFuIXkwsMm9AQDTYqy1Y9DD3Z2Q1XVwXOhR/a/RCfArsj4okXYcahsOUhA7E5z5J4+PblsTCgabv3GaEz5JyURH4kQzrec9diKxBTZJn3zx5ocr01H1c42J8etm+HA+T6/uk+rDiMVhQZobHDeO5chNeAzokniYNz8B63ACaM+U8O2zryP7Q2DbenaFP4pzwaroM0rxd+whD9HCb/9Vs8GfSdu3jiDKJPJJZDQupyouzJP7kE07WhZW8DknDKy1cDEv/alki4bii8syQylXjmoq0L2aidKkw1nxbbrIOTl6/xljoGQxzjF0THH8cCao8HAYwh99G91dXHbot84lV7V9CEHkDTSKg/ErAJ2iBGvwRVOzkMeteNFPqbtkeQhooNrBJvQBVO9mHVAFJ03dOTk3P3/v1Ca0m65MImS2hm10l8g4FIEBCDnjiICnUl6DtdPXeTOeo9O3x1dnJ6BlVjaFiy/x+d0eCX5HWrIGyg1RhjcBqQMwMN9p35P5uqox6z7v7Jq2dHzzHW1xFqj0Utguek+/x07/WLZyenL92HxYymJhmAz4RirZFccu/V8zfHe6fP9948PzQi+BiaEdhL3lpKHhw9PzrfOz44Ont9vPfOiOJMi2J6DMONLsN0PuTrL9cWtGvDFLdVMw8rVbA+whBZhkmTL3KTUR44gDrbh4qzfW6BU7tyCJunZCSoFKEypQsx2WJCca+YYA7ZA7Sc38JBLx4SUaRb6RowKp2b8KKJSwvDooMD4ZayRRDj/15MYFj/StPkcuNJL3T2Xh/JJW7b0XD48TlsYV4fsWIYA2SvfToZoe5yMtob9ZM46uPrbATZU4ySEyZYPKEwKGYZlMvD44tG5/YGxkPvE23sjNhf6Ktpe21qjTl4fYTBQ+1F2CtqYpndfHXGqB4g7mmWk4LiyulRqlUyCdyqIBonHoyMhGB5vRgtaBy1nMb/dVcSFV0qJfSGTadgX97OcXQbDhyyXtF2MqsBbclrzD3FTCksC0Wy147S19fxKDxJSFjS7IkLO88L+HonsiPAq+jE9pPA9zEWaLsPDaAgAz+h633eUqjlahJBV58FeD3styA9gUGTgCYweuJCsoPbg77zRxwPnZjmQJaDQxkqUQAuCQ6HnNRBfnNFRp4HsfWaZUJRutCrWpSt3ZxYxfN7Kg/Kj++VD7oP24bdfwtmO4gGhNArWVRbHMMW/CgFTe8zi2o8lQwaVObkVoh7Hbl0GnwOC2NLkQvipT8IzyAXlqYsumTtK2L40kUdGobvRrIDYoz0nt01V9udDeKA/ajT/GKL28LVBgVBV9rsAbswxk48ybjANrdt2vI6HbTvFPvGrrddNhDtSkKys5uLbTwxgk0GM4icTS74DoPn6GwxWL5K4SIWp35UFTMGFY78qJjGEOuG0k9iFIzI/TQS5Ue9nAZpJJNCq9k0VQBAdHogzJlOW2EiXKQfJ3EW9+LSZTueThDDbr50LxHTSCaLeiSXhjSaGWBQbPVGY3ZNMnGL9xoachMnpRARYh5rwzAamaClTEqLMInKVwhpKgVIPr9Jcakdlq4DQtaEZdFl+kkp/aHrciymNkHWmGWpWHg6YikNHHw2AHSdL2U65KEF5P4WybCK9IWzaNJZ4XfRfOlibdEeltxOyXZwFSNMgswlvgU8sdNa9XJnRD5IiuhGMCjy0Y2DoBuZQP9fY0fXnTaufO+vaDk5DZxMk7TJU1I3l4AJbABT2yShu3soAQfcgE1tk4Z289/vfMi2DPTefUKaL0kjaWYkZIlGgYFNfWMYT+jcXx/nJ4a1elLYt5Mir3JFE/im8PknWm+6WKualI+pJUf58SIuXCOTtmkN2yVL18r/lSV6euEL+lf3/Wiu/2slV0wojRyUzo6OStmX3b/5OFPVRn7K/oGR8M3u3kHpP3QQ/EBkkv4Zri6xiJKt0xR500gKNuQgA6OcF/Ehi9EjrlW/r7w4P6JS7Eep9UHe7Xmxw41yzzd1Wk60godSMoP84CE8/BaHQUm94pdE61+eIZsfDx5/MQq/FhjCn5XGuO4qvVRe0FMg2E8n37uTF/5QKHxUymYZvpLhsfRyyhVlXO9feDVKNX/7Vn6187MSdgr4z+O/eb8kKWODs7alozuiVx204c8+tRUk5Yged3jZYYxQrCTkkkB9dviHEz/aOePpKL+W31rMuHbfTKd9wYL4h3r2N3wYM+SPJIjHMk6PT/XJQB158e7DWU6AszPNsEMTk/fuJCN5wbGcHhbT/sAlT5o9rL1j4UzfJWDfRNnKzTCQ2TeiNNSgLxtYtrVKamgAMTJBbcYUXIkLp63nfM9D/wr5X25u7N7DYGXkbfJBlpB8BivaLifeZIhAbWcJS7zNEmyyxFBqru5jYQi2GegKz0BTIj8dkG0S0hMCs4/pJYvnM7nwYfTn7G9Nt1RAKb3gU629iaRymF0IGMPEmGLIFls/AvXP1LpcIhtQqlxM2QbRVb0PO4j4OTEiosRZia5yWe4iU9NJSFWGZI53EeNwFEJMEJG7g4hGPRNRgi8S3ilJpoWSlvloWBgbU+V8UbgZ6pTmzu3t7SEZt4WhI0/VBem2kZvKDVn272XZhl2UhVUx7Ldvx4bmcXY6TneHd/+ZHNa9cbReJuUaYAbXQ35QWy9nuUWgE1cvsLfzJkQVktDmKxeRBhY4ITjITfOzZDF3onENx1QGoznorGMMu6vjsRfHdS/wPS1ywWVQPllVzK0FKeQYjEQ5J15LZasWvmyAdsnp+srzYg09TXnyMAefDrQeyuh+6KmWc80fp1yHfkpzQRPtUxZ2ZGKL5Hrn+WkEoesgWy+lCXVW4RAXQHLCIbuSwdC9/j//yHHEgpK/frzAZLrPYpTeHx6XXl98evWRdzsz8IfD9yUEik4xQWZDfrKI3yh9PciUm0cj+yUO943SvoZlB48Y9mkFzIavR6L9g7KGTn3FPi8FNngRQgw4xSoHX1/zSpIfcis1qm3HLB1hjY9UzY+yphxRSz+9+npW0EuysQiWR4W2BgkVSb0GvsHWB6PVrXFxHn06vuDBoyK5qHLGIzmXkqrQKM2SZBlzjIwST09PShXtGUZ0J1s8uZRZGCdclyxIyIlRqxeF3Bm9V1o5lzAmPiwEaNrJvz3aKc2O1TAxHT/mCQMBL1lQY6LL+vZiU2kz+6dRKyU7XanoqTQ0nQsfbdjDKpBb+HjhIseCCI+zuon6USLOfS2Sj7R0drKQgBw2lMNDNMqyiUqHp7BcCHFFn8w0D2+8Oa6c5YREoTaMvI6/8OgkWLnEV+wu5yM/OH+d3rL7/I7M5Lt0njFjQPsqa2q3JxvGRtaoyq+Q/0xaO4TFUCg1CBLXfKK7Z1VsJJCPJ8fHF/KnwMQvyy4omogP935QJlHxEs2qpyyFsGAV8tipUjnLuHMbuJOw8sKV9+ivS73G/5af2GM66U+3UL6c7+Gg96cB30nO70UZsr+Lk5AMc5O3aSI5aVIuFcjNYGLsq8n5118BzoP9c7kS+Re9yRu/rs5H0cJRlxc/+xooSdB2xPCYw1wcLtR/dS8eR77cWOsIOpiukOJqtJp6jTBa5EdjYKYTfEGl6NwdhQzChCdVbxR4c6h7O6A6W9f/3wRX0Wg5gy8sBt1WlDgYy3vwmDAg/yMcTH8DQltQ8HkX9BLDAhjuwqjdKzPANQ38sUmRHT0BO9JQigmmUqdVnISLgfxxBU8MI0Mg+ki8NO94U/JRsJfkEGrZNKdYLRajaJ0S/sgQbjQaP+JK5nIToiv2C8ulA0A6tM5t2tW5D4KhTT9/XH32YxglGkSq/4cOyXlHwktdtSF1wpim6/YisVG2F6/mCQZHDF/dgxepVAs9Ftwwfdub4pSBnpYpDLUkh0u9vvgbEJ18wOSyCwlrL8/oRJEiQjf7fPJ8AlXJYyQ1mnpSyGcB+UFn9AwPWkbNWliy7O7oyZ/yKNnzC3m9uBWzd+n1OzVSlgzp0Ue9EOfpBlyzlFyn9K8bfNeB61QyipkkKQINA5Y0msOSadnaOEm4dBJvCbdMpkYY3FGGdoxxRKOBx6AJFv4WjNdvqv8WXoqeSP1v6CZ6qHFnbhqWJhd241GUewIhs6ZHyjLjVGeiOx55P5mEd4p1Oc8EHVR7LQiTNKnmIHSiFDK87Dcapj10LWvodKrtNoQ5rm7etGomkjgDsJJNcNdyhw2r361DQ2PpOkPTti0bHjWg1b9sm8NqrWY60Mrh5l2z2ndcsw7dHNhotXXZcy/DtLo31XarPqzaV/2O2XXhPtnCSVFgbnO1kOHbNrhtda/g8xbYce0WIrxthj4Jus7Blmrvz7wJbfOqWhtA7GeQTvUurVqkQVvdFOrk3NR2eo+hhcV9Id0kBZTT7/Usm5Q20HlQmb2WXXVbVndYa5q1a7AK6KbluN1qx1TIegHZsWxzSPfUw00B7trcPcNaVbE95Wi7gcpoVu26ar+5gXKshqtQbQ3l1rgVtlmtD6CXIxynragHfgHY714Pa6btwo8c3KeR5EA1p3RbHdPqu+DnoH632nebls1K9HL4jWk7pKVOCwe8W2vCnepkzZdDw9dh5L7hm+oHmnNjQV9Gq3gGQ07LXQBrX2UC/kYSI7SJeCu04oyhXDucTtFqNDKAjZbYixDkexmMWJ60bIJB3wJuUoAHptSn7k/9hL48488OYSxQM1gtYJan2b/PRByfLOvEU+hIvuFHC3qylWIqaBRh/SW1AdoiiRwkWJJU0R3cC4Pyc+SklpEOcZx6ryPneGEgCI5SrpM8449jsIt55+YKrkU0OcTLcLKGIM+rIB5qom+K681gigE03CoIVuRHllS4WAS0MY0dHY0mPsYK0omuoDreKMbwETqSCycr1EmdM10v+RFGjxBIRXteAHucstFWY4yOhH3OKx9liUT6S7ABa2FyFmGI4W8wRcke9BSQRorU4rsGkYFYUxBe0VK8MEogkHbJDoYZPMHdBqCJ631YCCdF1jK+UECTHKbJ8FvvvoedArafZp0Qw6JEqWoltb/lvy2hlagc/eEII8HdLea0rwcz6W/0C65Zc4fkRFy/AOqaLlgbIKtrws8irO9cwlwJa/S7NTJmddOp2a2ea9mpBYYrKX7T4X0XMC0QeITDXg4orhjgljE8q1d+mtRljZlgOBgM+9GcY60WQ0bIncBQ0pq9UGoaMEK+ggGfW0LXrOOA6tFXiF5C//kiXcR0Y/kXF6oqQ+9+JzG0uEaTwrTeCBQdb5tEVaHBPTUJV/dzrzsKoM3S6LsR2lHdDDaeWdBUa0LC/FOahQryzO2gLRLoUWoe8jiEhCUvOKiTSOyBpeFSL71eANsMDgvk+1fuBtD1slycBlRrAkVyAJ0lNxmA0WS4isa0b8wlyTEqDuA3WtH3cnwDQ+dNfKjxY2g99mP1aZZO1M5p4tRe3XHdn8nk99QXXXDDha2rxdH3cv7qv4naYyZtSwkA";
BinariesBlobs.rw_minjs = "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";

// obj/full/installer_rw.js
var codeInstance = class {
  constructor(filename, EStarget, version, readonly) {
    this._compressed = filename.slice(-3) == ".gz";
    this._filename = this._compressed ? filename.slice(0, -3) : filename;
    this._version = version == "" ? "Unknown" : version;
    this._EStarget = EStarget == "" ? "Unknown" : EStarget;
    this._minified = filename.indexOf(".min.") > 0;
    this._readonly = readonly;
  }
  get compressed() {
    return this._compressed;
  }
  get version() {
    return this._version;
  }
  get readonly() {
    return this._readonly;
  }
  get EStarget() {
    return this._EStarget;
  }
  get minified() {
    return this._minified;
  }
  get filename() {
    return this._filename + (this.compressed ? ".gz" : "");
  }
};
var pageInstance = class {
  constructor(filename, contents) {
    let strContents = YAPI.imm_bin2str(contents);
    this._compressed = filename.slice(-3) == ".gz";
    this._filename = this._compressed ? filename.slice(0, -3) : filename;
    this._readonly = strContents.indexOf("yv4web-readonly") > 0;
    this._useMinified = strContents.indexOf("yv4web-readonly.min.js") > 0 || strContents.indexOf("yv4web-full.min.js") > 0;
    this._action = 0;
    this._contents = contents;
  }
  get compressed() {
    return this._compressed;
  }
  get readonly() {
    return this._readonly;
  }
  set readonly(value) {
    this._readonly = value;
  }
  get fs_filename() {
    return this._filename + (this.compressed ? ".gz" : "");
  }
  get http_filename() {
    return this._filename;
  }
  set action(value) {
    this._action = value;
  }
  get action() {
    return this._action;
  }
  get contents() {
    return this._contents;
  }
  get useMinified() {
    return this._useMinified;
  }
  set useMinified(value) {
    this._useMinified = value;
  }
};
var YV4W_installer = class {
  constructor(container, options) {
    this.CALLERISHTTPS = location.protocol.toLowerCase().substr(0, 5) == "HTTPS";
    this.DEFAULT_PROTOCOL = this.CALLERISHTTPS ? YV4W_installer.HTTPS : YV4W_installer.HTTP;
    this.FIRMWAREMINVERSION = 43805;
    this.DEFAULTADDR = "";
    this.DEFAULTPORT = "80";
    this.DEFAULTPATH = "";
    this.DEFAULTCANCELABLE = false;
    this.DEFAULTINTIALFOCUS = true;
    this.DEFAULTUSER = "";
    this.DEFAULTPWD = "";
    this.DEFAULTFILEPREFIX = "default";
    this.DEFAULTSRVUSERNAME = "";
    this.DEFAULTSRVPASSORD = "";
    this._currentStep = 0;
    this._warningRow = null;
    this._welcomeText = null;
    this._hubAddr = null;
    this._connectingText = null;
    this._ipAddrInput = null;
    this._protocolInput = null;
    this._ipPortInput = null;
    this._pathInput = null;
    this._configFileInput = null;
    this._webPageInput = null;
    this._connectiongError = null;
    this._pwdPanel = null;
    this._descPanel = null;
    this._customFilesPanel = null;
    this._doneMsgContainer = null;
    this._confirmUninstallPanel = null;
    this._modInstancesPanel = null;
    this._donePanel = null;
    this._runPanel = null;
    this._modifyInstallPanel = null;
    this._adminNameInput = null;
    this._adminPasswordInput = null;
    this._userNameInput = null;
    this._userPasswordInput = null;
    this._useReadOnlyInput = null;
    this._fileprefixInput = null;
    this._useFullVersionInput = null;
    this._removeUnusedJs = null;
    this._makeDefaultInput = null;
    this._userCredTable = null;
    this._optionsPanel = null;
    this._connectionErrorMsg = null;
    this._instancesFiles = [];
    this._jsCodeinstances = [];
    this._webPageinstances = [];
    this._uninstallOpt = null;
    this._updateOpt = null;
    this._addInstanceOpt = null;
    this._modInstanceOpt = null;
    this._confirmUninstall = null;
    this._history = [];
    this._ErrMsgContainer = null;
    this._currentHub = null;
    this._currentfs = null;
    this._currentHub_RW_username = "";
    this._currentHub_RW_password = "";
    this._currentHub_RO_username = "";
    this._currentHub_RO_password = "";
    this._currentHub_protocol = "";
    this._currentHubLink_protocol = "";
    this._currentHub_Addr = "";
    this._currentHub_port = "";
    this._currentHub_path = "";
    this._currentHub_ReadOnlyProtected = false;
    this._warning = "";
    this._finalURL = "";
    this._plannedaction = 0;
    this._alreadyInstalled = false;
    this._applicationURL = "";
    this.ESVersion = "es2017";
    this.WELCOMEPANEL = 0;
    this.ENTERHUBADDR = 1;
    this.CONNECTINGPANEL = 2;
    this.CONNECTIONERROR = 3;
    this.PASSWORDPANEL = 4;
    this.DESCRIPTIONPANEL = 5;
    this.CUSTOMFILESPANEL = 6;
    this.OPTIONSPANEL = 7;
    this.RUNPANEL = 8;
    this.DONEPANEL = 9;
    this.MODIFYINSTALLPANEL = 10;
    this.CONFIRMUNINSTALLPANEL = 11;
    this.MODINSTANCESPANEL = 12;
    this.ACTIONINSTALL = 1;
    this.ACTIONUNINSTALL = 2;
    this.ACTIONADDINSTANCE = 3;
    this.ACTIONMODINSTANCE = 4;
    this.ACTIONUPDATE = 5;
    this._MODIFYNOTHING = 0;
    this._MODIFYCOMPRESS = 1;
    this._MODIFYUNCOMPRESS = 2;
    this._MODIFYMAKEREADONLY = 3;
    this._MODIFYMAKEREADWRITE = 4;
    this._MODIFYUSEMINIFIED = 5;
    this._MODIFYUSEPLAIN = 6;
    this._MODIFYDELETE = 7;
    this.TARGETEXTENSION = ".html";
    this.icon = '<link rel="icon" type="image/svg+xml" href="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNjQiIGhlaWdodD0iNjQiIHZlcnNpb249IjEuMSIgdmlld0JveD0iMCAwIDE3IDE3IiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPjxyZWN0IHg9IjAiIHk9IjAiIHdpZHRoPSIxNyIgaGVpZ2h0PSIxNyIgcng9IjEuMSIgcnk9IjEuMSIgZmlsbD0iI2ZmZiIgZmlsbC1vcGFjaXR5PSIuOSIvPjxwYXRoIGQ9Im0xMC43IDEuMy0wLjI5IDAuMjljLTAuMDQ3IDAuMDQ3LTAuMDczIDAuMTEtMC4wNzIgMC4xOHYxLjFjLTEuMS0wLjktMi43LTAuODMtMy43IDAuMTRsLTAuNC0wLjR2LTAuOTdjMC4zNS0wLjI1IDAuMi0wLjgyLTAuMjMtMC44My0wLjQzLTAuMDE0LTAuNjMgMC41My0wLjI3IDAuODJ2MS4xYzAgMC4wNjcgMC4wMjcgMC4xMyAwLjA3NCAwLjE4bDAuNDkgMC40OWMtMC40MyAwLjU5LTAuNjMgMS4zLTAuNTQgMi4xdjAuMDA3MmwtMC44My0wLjgzYy0wLjA0Ny0wLjA0Ny0wLjExLTAuMDczLTAuMTgtMC4wNzJoLTJjLTAuMjctMC4zNi0wLjgzLTAuMTktMC44MyAwLjI1IDAuMDAxMiAwLjQ0IDAuNTYgMC42MiAwLjgyIDAuMjVoMS45bDEuMyAxLjNjMC40MyAwLjM4IDAuNzQgMS4yIDAuNTkgMS42aC0yLjVjLTAuMDY2IDAgLTAuMTMgMC4wMjctMC4xOCAwLjA3NGwtMS40IDEuNGMtMC4zOS0wLjA4OS0wLjcyIDAuMzQtMC40OCAwLjY5czAuODYgMC4yIDAuODItMC4zM2wxLjMtMS4zaDIuNmMwLjI2IDAuMTUgMC41MSAwLjQgMC42NyAwLjY1djEuOWwtMS41IDEuNWMtMC4wNDcgMC4wNDctMC4wNzMgMC4xMS0wLjA3NCAwLjE4djAuMjhjLTAuNDUgMC4zLTAuMTUgMC44MyAwLjIzIDAuODMgMC4zOCAwIDAuNjMtMC40NyAwLjI3LTAuODF2LTAuMjFsMS41LTEuNWMwLjA0Ny0wLjA0NiAwLjA3NC0wLjExIDAuMDc0LTAuMTh2LTEuN2MwLjI0LTAuMzIgMS4xLTAuNCAxLjQtMC4wM3YxLjJjIDAgMC4wNjYgMC4wMjcgMC4xMyAwLjA3NCAwLjE4bDEuNSAxLjV2MC42OWMtMC4zNiAwLjI0LTAuMjMgMC44MSAwLjI3IDAuODIgMC40OSAwLjAwMjEgMC41NC0wLjY0IDAuMjMtMC44MnYtMC43OWMgMCAtMC4wNjYtMC4wMjctMC4xMy0wLjA3NC0wLjE4bC0xLjUtMS41di0xLjRjMC4xNS0wLjIgMC4zLTAuMjUgMC41My0wLjI0aDMuMmwwLjkxIDAuOTFjLTAuMDk5IDAuNDQgMC40OCAwLjcyIDAuNzcgMC40IDAuMjgtMC4zMiAwLjA3Mi0wLjc5LTAuNDItMC43NmwtMC45OC0wLjk4Yy0wLjA0Ny0wLjA0Ny0wLjExLTAuMDcyLTAuMTgtMC4wNzJoLTNjLTAuMjEtMC4zMiAwLjI0LTEuNSAwLjY3LTEuOWwyLjIgMC4wMDU5YzAuMDY3IDAgMC4xMy0wLjAyNiAwLjE4LTAuMDcybDEuMS0xLjFjMC4zOSAwLjA5NiAwLjczLTAuNCAwLjQ0LTAuNzNzLTAuODctMC4xLTAuNzggMC4zNmwtMS4xIDEuMWgtMmMwLjI3LTAuOTUgMC4wMDY3LTEuOS0wLjQzLTIuNXYtMS41bDAuMjEtMC4yMWMwLjM4IDAuMDgyIDAuNzEtMC4zMyAwLjQ2LTAuNjlzLTAuODctMC4xOS0wLjggMC4zM3ptLTMuMiA0LjljMC44NC0wLjAyOSAwLjk2IDEuNSAwLjIgMS41LTAuNzYtMC4wMTQtMS0xLjQtMC4yLTEuNXptMi4xIDBjMC43NSAwLjA4NCAwLjYxIDEuNS0wLjIgMS41LTAuODEgMC4wMDMzLTAuNTUtMS41IDAuMi0xLjV6IiBmaWxsLW9wYWNpdHk9Ii4xIi8+PHJlY3QgeD0iMCIgeT0iMCIgd2lkdGg9IjE3IiBoZWlnaHQ9IjE2IiByeT0iMS44IiBvcGFjaXR5PSIwIiBzdHJva2Utd2lkdGg9Ii4yNiIvPjxlbGxpcHNlIGN4PSI5LjQiIGN5PSI3LjQiIHJ4PSIuMzQiIHJ5PSIuMzMiIG9wYWNpdHk9Ii4xIi8+PGVsbGlwc2UgY3g9IjcuNyIgY3k9IjcuNCIgcng9Ii4zNCIgcnk9Ii4zMyIgb3BhY2l0eT0iLjEiLz48ZyBmaWxsPSJub25lIj48cGF0aCBkPSJtMS4xIDEuOSAwLjA2NiAxNCIgc3Ryb2tlPSIjN2U3ZTdlIiBzdHJva2Utd2lkdGg9Ii4yIi8+PHBhdGggZD0ibTE1IDEzaC0xNSIgc3Ryb2tlPSIjN2U3ZTdlIiBzdHJva2Utd2lkdGg9Ii4yIi8+PHBhdGggZD0ibTEuMiAxM2M1LjQtMS4xIDEwLTIuNyAxNS02LjkiIHN0cm9rZT0ibGltZSIgIHN0cm9rZS13aWR0aD0iLjQiLz48cGF0aCBkPSJtMS4yIDEzYzAuMS0wLjA1MyAwLjQ1LTEuNCAxLjItMS40IDAuNzggMCAxLjQgMi44IDIuMyAyLjggMC44Ni0wLjAwMTUgMS42LTIuOCAyLjQtMi44IDAuODQgMCAxLjUgMi44IDIuNCAyLjggMC45IDAuMDEzIDEuNi0yLjggMi40LTIuOCAwLjgyIDAuMDI4IDEuNSAyLjcgMi4zIDIuOCAwLjI2IDAuMDQzIDAuNjgtMC4zNCAwLjY3LTAuNDIiICBzdHJva2U9InJlZCIgIHN0cm9rZS13aWR0aD0iLjQiLz48L2c+PHBhdGggZD0ibTE1IDEyLjQgMS4xIDAuNi0xLjEgMC41N3oiIGZpbGw9IiM3ZTdlN2UiLz48cGF0aCBkPSJtMC41MiAyIDAuNjItMSAwLjU5IDF6IiBmaWxsPSIjN2U3ZTdlIi8+PHBhdGggZD0ibTkuOCAwIDcuMiA3LjJ2LTRsLTMuMi0zLjJ6IiBmaWxsPSJncmVlbiIvPjxnIGZpbGw9IiNmZmYiIHN0cm9rZS13aWR0aD0iMSI+PHBhdGggZD0ibTEyLjcgMS42MyAwLjQ5LTEuMSAwLjE5IDAuMTktMC4zMyAwLjc0IDAuNzUtMC4zMiAwLjEyIDAuMTItMC4zMiAwLjc1IDAuNzMtMC4zNCAwLjE3IDAuMTctMS4xIDAuNDktMC4xMi0wLjEyIDAuMzMtMC43Ny0wLjc3IDAuMzN6Ii8+PHBhdGggZD0ibTEzLjggMi43OSAwLjc5LTAuNzkgMC44MiAwLjgyLTAuMTQgMC4xNC0wLjY0LTAuNjQtMC4xOCAwLjE4IDAuMzYgMC4zNi0wLjE0IDAuMTQtMC4zNi0wLjM2LTAuMTkgMC4xOSAwLjY0IDAuNjQtMC4xNSAwLjE1eiIvPjxwYXRoIGQ9Im0xNi4xIDMuOC0wLjQyLTAuNDItMC4xOSAwLjE5IDAuNDIgMC40MnEwLjA0OSAwLjA0OSAwLjA3OSAwLjA1MyAwLjAzMiAwIDAuMDY0LTAuMDI2bDAuMDc1LTAuMDc1cTAuMDMxLTAuMDMxIDAuMDI1LTAuMDYyLTAuMDA0NS0wLjAzMi0wLjA1Mi0wLjA3OXptLTAuMzIgMC4zMi0wLjQyLTAuNDItMC4yIDAuMiAwLjQyIDAuNDJxMC4wNTIgMC4wNTMgMC4wODYgMC4wNTQgMC4wMzUgMC4wMDMxIDAuMDc1LTAuMDM3bDAuMDYtMC4wNnEwLjA0LTAuMDQgMC4wMzYtMC4wNzQtMC4wMDIzLTAuMDM0LTAuMDU0LTAuMDg2em0tMC45NS0wLjI2IDAuNzktMC43OSAwLjY4IDAuNjhxMC4wOTQgMC4wOTQgMC4xIDAuMTcgMC4wMDUzIDAuMDc5LTAuMDc1IDAuMTZsLTAuMDk4IDAuMDk4cS0wLjA1NyAwLjA1Ny0wLjEyIDAuMDU3LTAuMDY5LTAuMDAxNS0wLjE1LTAuMDU5IDAuMDU5IDAuMDc3IDAuMDU3IDAuMTYtMC4wMDIzIDAuMDc3LTAuMDY2IDAuMTRsLTAuMSAwLjFxLTAuMDc5IDAuMDc5LTAuMTcgMC4wNTktMC4wOTYtMC4wMTktMC4yMi0wLjE0eiIvPjwvZz48L3N2Zz4=">';
    if (typeof options !== "undefined") {
      if (options != null) {
        if (typeof options["protocol"] === "string")
          this.DEFAULT_PROTOCOL = options["protocol"].toUpperCase() == YV4W_installer.HTTPS.toUpperCase() ? YV4W_installer.HTTPS : YV4W_installer.HTTP;
        if (typeof options["addr"] === "string") {
          this.DEFAULTADDR = options["addr"];
          let n = this.DEFAULTADDR.indexOf(":");
          if (n > 0) {
            this.DEFAULTPORT = this.DEFAULTADDR.substring(n + 1);
            this.DEFAULTADDR = this.DEFAULTADDR.substring(0, n);
          }
        }
        if (typeof options["port"] === "number")
          this.DEFAULTPORT = options["port"].toString();
        if (typeof options["path"] === "string")
          this.DEFAULTPATH = options["path"];
        if (typeof options["cancelable"] === "boolean")
          this.DEFAULTCANCELABLE = options["cancelable"];
        if (typeof options["initialFocus"] === "boolean")
          this.DEFAULTINTIALFOCUS = options["initialFocus"];
      }
    }
    this._container = container;
    this._container.innerHTML = "";
    this._container.style.backgroundColor = constants.WindowBackgroundColor;
    this._container.style.fontFamily = constants.WindowHeaderFontFamily;
    let bottomdiv = document.createElement("DIV");
    bottomdiv.style.position = "absolute";
    bottomdiv.style.bottom = "0px";
    bottomdiv.style.right = "5px";
    bottomdiv.style.height = "30px";
    bottomdiv.style.textAlign = "right";
    bottomdiv.style.verticalAlign = "center";
    this._prevButton = new button("< Prev", () => {
      this.gotoPrevious();
    }, 1);
    this._cancelButton = new button("Cancel", async () => {
      this.closeWindow();
    }, 1);
    this._nextButton = new button("Next >", () => {
      this.gotoNext();
    }, 1);
    this._okButton = new button("Ok", async () => {
      this.DEFAULTCANCELABLE ? this.closeWindow() : await this.resetAll();
    }, 1);
    this._prevButton.tabIndex = 100;
    this._cancelButton.tabIndex = 101;
    this._nextButton.tabIndex = 102;
    this._okButton.tabIndex = 103;
    bottomdiv.appendChild(this._prevButton.Element);
    bottomdiv.appendChild(this._cancelButton.Element);
    bottomdiv.appendChild(this._nextButton.Element);
    bottomdiv.appendChild(this._okButton.Element);
    this._prevButton.visible = false;
    this._cancelButton.visible = this.DEFAULTCANCELABLE;
    this._container.appendChild(bottomdiv);
    let topDiv = document.createElement("DIV");
    topDiv.style.position = "absolute";
    topDiv.style.top = "5px";
    topDiv.style.paddingLeft = "10px";
    topDiv.style.paddingTop = "5px";
    topDiv.style.paddingBottom = "5px";
    topDiv.style.left = "5px";
    topDiv.style.right = "5px";
    topDiv.style.backgroundColor = constants.WindowHeaderBackgroundColor;
    topDiv.style.color = constants.WindowHeaderColor;
    topDiv.style.fontSize = "x-large";
    topDiv.style.whiteSpace = "nowrap";
    topDiv.style.overflow = "hidden";
    topDiv.innerText = "Yocto-Visualization (for web) installer";
    this._container.appendChild(topDiv);
    this.gotoPanel(this.WELCOMEPANEL);
  }
  closeWindow() {
    var _a;
    (_a = this._container.parentElement) === null || _a === void 0 ? void 0 : _a.removeChild(this._container);
  }
  createNewContentDiv() {
    let div = document.createElement("DIV");
    div.style.position = "absolute";
    div.style.textAlign = "justify";
    div.style.top = "50px";
    div.style.left = "15px";
    div.style.right = "15px";
    return div;
  }
  loadLocalFile(fileChooser) {
    return new Promise(function(resolve, reject) {
      if (fileChooser.files && fileChooser.files[0]) {
        let reader = new FileReader();
        reader.onload = function(e) {
          resolve(e.target.result);
        };
        reader.readAsText(fileChooser.files[0]);
      } else {
        resolve(null);
      }
    });
  }
  showWelcomePanel(visible, goingback) {
    if (!visible) {
      if (this._welcomeText != null)
        this._welcomeText.style.display = "none";
      return;
    }
    this._okButton.visible = false;
    this._prevButton.visible = false;
    this._nextButton.visible = true;
    this._nextButton.enabled = true;
    this._cancelButton.visible = this.DEFAULTCANCELABLE;
    if (this._welcomeText == null) {
      this._welcomeText = this.createNewContentDiv();
      this._welcomeText.innerText = "Yoctopuce is proud to offer you  Yocto-Visualization (for web), an application that  allows to view Yoctopuce sensors data with a simple web browser.\n\nThis wizard will help you to install Yocto-Visualization (for web) version " + constants.buildVersion + " (" + this.ESVersion + ') on a YoctoHub such as YoctoHub-Ethernet, YoctoHub-Wireless, VirtualHub etc..\n\n Click on "next" to start';
      this._container.appendChild(this._welcomeText);
    }
    this._currentHub = null;
    this._currentfs = null;
    this._currentHub_RW_username = "";
    this._currentHub_RW_password = "";
    this._currentHub_RO_username = "";
    this._currentHub_RO_password = "";
    this._currentHub_protocol = "";
    this._currentHub_Addr = "";
    this._currentHub_port = "";
    this._currentHub_path = "";
    let tabIndex = 1;
    this._nextButton.tabIndex = tabIndex++;
    if (this.DEFAULTINTIALFOCUS)
      this._nextButton.focus();
    this._welcomeText.style.display = "";
  }
  showEnterHubAddr(visible, goingback) {
    if (!visible) {
      if (this._hubAddr != null)
        this._hubAddr.style.display = "none";
      return;
    }
    if (this._hubAddr == null) {
      this._hubAddr = this.createNewContentDiv();
      let p = document.createElement("P");
      p.innerText = "Enter the address of the hub you want to install Yocto-Visualization on. This address must be reacheable from your web browser.";
      this._hubAddr.appendChild(p);
      let Table = document.createElement("TABLE");
      Table.style.fontSize = "smaller";
      let Row = document.createElement("TR");
      let TD1 = document.createElement("TD");
      TD1.innerText = "Hub address:";
      TD1.style.whiteSpace = "normal";
      Row.appendChild(TD1);
      let TD2 = document.createElement("TD");
      TD2.style.whiteSpace = "normal";
      this._protocolInput = document.createElement("SELECT");
      let httpopt1 = document.createElement("OPTION");
      httpopt1.text = "http://";
      httpopt1.value = YV4W_installer.HTTP;
      this._protocolInput.add(httpopt1);
      let httpopt2 = document.createElement("OPTION");
      httpopt2.text = "https://";
      httpopt2.value = YV4W_installer.HTTPS;
      this._protocolInput.add(httpopt2);
      this._protocolInput.value = this.DEFAULT_PROTOCOL;
      this._protocolInput.addEventListener("change", () => {
        if (this._protocolInput != null && this._ipPortInput != null) {
          if (this._protocolInput.value == YV4W_installer.HTTPS && parseInt(this._ipPortInput.value) == 80)
            this._ipPortInput.value = "443";
          if (this._protocolInput.value == YV4W_installer.HTTP && parseInt(this._ipPortInput.value) == 443)
            this._ipPortInput.value = "80";
          if (this._warningRow != null)
            this._warningRow.style.display = this._protocolInput.value == YV4W_installer.HTTP && this.CALLERISHTTPS ? "" : "none";
        }
      });
      TD2.appendChild(this._protocolInput);
      this._ipAddrInput = document.createElement("INPUT");
      this._ipAddrInput.value = this.DEFAULTADDR;
      this._ipAddrInput.size = 34;
      this._ipAddrInput.addEventListener("input", () => {
        this._nextButton.enabled = this._ipAddrInput.value != "" && this._ipPortInput.value != "";
      });
      TD2.appendChild(this._ipAddrInput);
      let span = document.createElement("SPAN");
      span.innerText = ":";
      TD2.appendChild(span);
      this._ipPortInput = document.createElement("INPUT");
      this._ipPortInput.value = this.DEFAULTPORT != "" ? this.DEFAULTPORT : "4444";
      this._ipPortInput.type = "number";
      this._ipPortInput.min = "1";
      this._ipPortInput.max = "65535";
      this._ipPortInput.maxLength = 6;
      this._ipPortInput.style.width = "60px";
      this._ipPortInput.addEventListener("input", () => {
        this._nextButton.enabled = this._ipAddrInput.value != "" && this._ipPortInput.value != "";
      });
      TD2.appendChild(this._ipPortInput);
      Row.appendChild(TD2);
      Table.appendChild(Row);
      this._warningRow = document.createElement("TR");
      TD1 = document.createElement("TD");
      TD1.style.whiteSpace = "normal";
      TD1.style.fontSize = "smaller";
      TD1.innerText = "WARNING: Unless your web browser is configured to accept 'mixed content', trying to establish an HTTP connection from an HTTPS page is likely to fail.";
      TD1.colSpan = 2;
      this._warningRow.style.display = "none";
      this._warningRow.appendChild(TD1);
      Table.appendChild(this._warningRow);
      Row = document.createElement("TR");
      TD1 = document.createElement("TD");
      TD1.style.whiteSpace = "normal";
      TD1.style.paddingTop = "20px";
      TD1.style.paddingBottom = "20px";
      TD1.style.textAlign = "justify";
      TD1.innerText = "On YoctoHubs, protocol is HTTP and port is likely to be 80. On native Virtualhub, protocol is HTTP and port is likely to be 4444. On VirtualHub (for web), the  hub path is mandatory and should be set to your VirtualHub (for web) instance path, protocol and  port can be either HTTP and 80 or HTTPS and 433.";
      TD1.colSpan = 2;
      Row.appendChild(TD1);
      Table.appendChild(Row);
      Row = document.createElement("TR");
      TD1 = document.createElement("TD");
      TD1.style.whiteSpace = "normal";
      TD1.innerText = "Hub path:";
      Row.appendChild(TD1);
      TD2 = document.createElement("TD");
      TD2.style.whiteSpace = "normal";
      this._pathInput = document.createElement("INPUT");
      this._pathInput.value = this.DEFAULTPATH;
      this._pathInput.size = 48;
      TD2.appendChild(this._pathInput);
      Row.appendChild(TD2);
      Table.appendChild(Row);
      this._hubAddr.appendChild(Table);
      this._container.appendChild(this._hubAddr);
    }
    this._hubAddr.style.display = "";
    let tabIndex = 1;
    this._protocolInput.tabIndex = tabIndex++;
    this._ipAddrInput.tabIndex = tabIndex++;
    this._ipPortInput.tabIndex = tabIndex++;
    this._pathInput.tabIndex = tabIndex++;
    this._prevButton.tabIndex = tabIndex++;
    this._nextButton.tabIndex = tabIndex++;
    this._protocolInput.focus();
    this._nextButton.visible = true;
    this._nextButton.enabled = this._ipAddrInput.value != "";
  }
  async showConnectingPanel(visible, goingback) {
    if (!visible) {
      if (this._connectingText != null)
        this._connectingText.style.display = "none";
      return;
    }
    if (this._connectingText == null) {
      this._connectingText = this.createNewContentDiv();
      this._container.appendChild(this._connectingText);
    }
    this.removeCurrentPanelFromHistory();
    this._connectingText.innerText = "Connecting to hub " + this._ipAddrInput.value + ". Please wait...";
    this._connectingText.style.display = "";
    this._nextButton.visible = false;
    this._prevButton.visible = false;
    this._cancelButton.visible = false;
    let IP = this._ipAddrInput.value;
    let port = parseInt(this._ipPortInput.value);
    let protocol = this._protocolInput.value;
    this._currentHubLink_protocol = this._protocolInput.value;
    let RW_username = "";
    let RW_password = "";
    let RO_username = "";
    let RO_password = "";
    if (this._adminNameInput != null)
      RW_username = this._adminNameInput.value;
    if (this._adminPasswordInput != null)
      RW_password = this._adminPasswordInput.value;
    if (this._userNameInput != null)
      RO_username = this._userNameInput.value;
    if (this._userPasswordInput != null)
      RO_password = this._userPasswordInput.value;
    let url = protocol + "://" + IP + ":" + port.toString();
    let HubData = null;
    let serial = "";
    let path = this._pathInput.value;
    if (path != "") {
      if (path.charAt(0) == "/")
        path = path.slice(1);
      url += "/" + path;
    }
    let info = new HubInfo(protocol, IP, port, path, null, null);
    let infoRes = await info.makeRequest();
    if (infoRes !== true) {
      let err = "Failed to connect to the Hub while using the url\n\n" + url + "\n\n";
      let prvmsg = 'Click on the "prev" button,';
      switch (infoRes) {
        case 0:
          err += prvmsg + " and make sure that protocol, address, port and path are correct, and try again.\n\n";
          break;
        case -1:
          err += "(invalid server answer), contact yoctopuce support.";
          break;
        case -2:
          err += prvmsg + " then check path. If path is correct check hub firmware version. This installer doesn't work with versions older that " + this.FIRMWAREMINVERSION + ".";
          break;
        case -3:
          err += "An network error occured, make sure hub address is correct.\n\nAlso connexion migh have been  blocked by your web browser, most likely due to CORS policy.\n\nCheck your browser console (Shift-Control-I on most browsers), if you find an error message about a Cross-Origin Request Blocked over a 404 error, Press '<Prev' and check path carefuly.";
          break;
        case 404:
          err += prvmsg + " make sure the path is correct, and try again.";
          break;
        case 500:
          err += " the hub encountered an interal error (Error 500)";
          break;
        case 503:
          err += " the hub is  not available (Error 503)";
          break;
        case 401:
          err += " Unauthorized access, check server configuration(Error 401)";
          break;
        default:
          err += "server responded with an HTTP error " + infoRes;
          break;
      }
      this.gotoPanel(this.CONNECTIONERROR, err);
      return;
    }
    if (info.serial != "") {
      port = info.port;
      serial = info.serial;
      path = info.path;
      this._currentHub_ReadOnlyProtected = info.userPassword;
    }
    protocol = info.protocol;
    if (info.adminPassword && RW_username == "" && RW_password == "") {
      this.gotoPanel(this.PASSWORDPANEL);
      return;
    }
    await YAPI.DisableExceptions();
    let errmsg = new YErrorMsg();
    if (info.userPassword) {
      let RO_addr = info.get_hubUrl(RO_username, RO_password);
      let RO_res = await YAPI.TestHub(RO_addr, 5e3, errmsg);
      if (RO_res != YAPI.SUCCESS) {
        if (RO_res == YAPI.UNAUTHORIZED) {
          this.gotoPanel(this.PASSWORDPANEL, "ReadOnly test failed, check credentials for read only operations.");
          return;
        } else {
          let err = "Cannot connect to " + url + " : " + errmsg.msg + '.\n\nMake sure the Hub is Up and address is correct, then click the "prev" to try again';
          this.gotoPanel(this.CONNECTIONERROR, err);
          return;
        }
      }
    }
    let addr = info.get_hubUrl(RW_username, RW_password);
    this._applicationURL = IP + ":" + port.toString() + (path != "" ? "/" + path : "");
    let res = await YAPI.TestHub(addr, 5e3, errmsg);
    if (res != YAPI.SUCCESS) {
      if (res == YAPI.UNAUTHORIZED) {
        this.gotoPanel(this.PASSWORDPANEL);
        return;
      } else {
        let err = "Cannot connect to " + url + " : " + errmsg.msg + '.\n\nMake sure the Hub is Up and address is correct, then click the "prev" to try again';
        this.gotoPanel(this.CONNECTIONERROR, err);
        return;
      }
    }
    if (await YAPI.RegisterHub(addr, errmsg) != YAPI.SUCCESS) {
      let err = "Cannot connect to " + IP + " : " + errmsg.msg + '.\nMake sure the Hub is Up and address is correct, then click the "prev" to try again';
      this.gotoPanel(this.CONNECTIONERROR, err);
      return;
    }
    let m = YModule.FirstModule();
    while (m != null) {
      if (await m.get_parentHub() == "") {
        let urlMatch = false;
        let serialMatch = await m.get_serialNumber() == serial;
        if (!serialMatch)
          urlMatch = (await m.get_url()).indexOf(IP + ":" + port.toString()) > 0;
        if (serialMatch || urlMatch) {
          this._currentHub = m;
          this._currentHub_RW_username = RW_username;
          this._currentHub_RW_password = RW_password;
          this._currentHub_protocol = protocol;
          this._currentHub_Addr = IP;
          this._currentHub_port = port.toString();
          this._currentHub_path = path;
          if (await m.isReadOnly()) {
            await YAPI.UnregisterHub(await m.get_url());
            this._currentHub = null;
            this.gotoPanel(this.PASSWORDPANEL, "Write test failed, check credentials for read/write operations.");
          } else {
            this.gotoPanel(this.DESCRIPTIONPANEL);
          }
          return;
        }
      }
      m = m.nextModule();
    }
    this.gotoPanel(this.CONNECTIONERROR, "Internal Error, cannot find Hub after RegisterHub call");
  }
  removeCurrentPanelFromHistory() {
    this._history.pop();
  }
  async showConnectionError(visible, goingback, message) {
    if (!visible) {
      if (this._connectiongError != null)
        this._connectiongError.style.display = "none";
      return;
    }
    if (this._connectiongError == null) {
      this._connectiongError = this.createNewContentDiv();
      this._container.appendChild(this._connectiongError);
    }
    this.removeAllChilds(this._connectiongError);
    let Table = document.createElement("TABLE");
    let Row = document.createElement("TR");
    let TD1 = document.createElement("TD");
    TD1.style.whiteSpace = "normal";
    TD1.innerHTML = ressources.FailedIcon("64", true, false, false, false, "oops");
    Row.appendChild(TD1);
    this._ErrMsgContainer = document.createElement("TD");
    this._ErrMsgContainer.style.whiteSpace = "normal";
    this._ErrMsgContainer.style.textAlign = "justify";
    Row.appendChild(this._ErrMsgContainer);
    Table.appendChild(Row);
    this._connectiongError.appendChild(Table);
    this._ErrMsgContainer.innerText = message;
    this._nextButton.visible = false;
    this._prevButton.visible = true;
    this._cancelButton.visible = this.DEFAULTCANCELABLE;
    this._connectiongError.style.display = "";
    let tabIndex = 1;
    this._prevButton.tabIndex = tabIndex++;
    this._prevButton.focus();
  }
  MakeSureCredentialsAreNotEmpty() {
    if (this._currentHub_ReadOnlyProtected) {
      this._nextButton.enabled = this._userPasswordInput.value != "" && this._userNameInput.value != "";
    } else {
      this._nextButton.enabled = true;
    }
    if (this._adminPasswordInput.value == "" || this._adminNameInput.value == "") {
      this._nextButton.enabled = false;
    }
  }
  showPasswordPanel(visible, goingback, err) {
    if (!visible) {
      if (this._pwdPanel != null)
        this._pwdPanel.style.display = "none";
      return;
    }
    let errmsg = typeof err != "undefined" ? err : "Well, looks like this hub requires some authentication.";
    if (this._history[this._history.length - 2] == this.PASSWORDPANEL) {
      errmsg = "Invalid credentials. " + errmsg;
      this.removeCurrentPanelFromHistory();
    }
    if (this._pwdPanel == null) {
      this._pwdPanel = this.createNewContentDiv();
      this._connectionErrorMsg = document.createElement("P");
      this._connectionErrorMsg.style.marginTop = "0px";
      this._pwdPanel.appendChild(this._connectionErrorMsg);
      let Table = document.createElement("TABLE");
      let Row = document.createElement("TR");
      let TD1 = document.createElement("TD");
      TD1.style.whiteSpace = "normal";
      TD1.innerText = "Enter read/write credentials below, these are required for the installation but won't be saved in Yocto-Visualization's configuration.";
      TD1.style.fontSize = "smaller";
      TD1.colSpan = 4;
      Row.appendChild(TD1);
      Table.appendChild(Row);
      Row = document.createElement("TR");
      TD1 = document.createElement("TD");
      TD1.style.whiteSpace = "normal";
      TD1.innerText = "Username:";
      TD1.style.borderLeft = "20px solid transparent";
      TD1.style.fontSize = "smaller";
      Row.appendChild(TD1);
      let TD2 = document.createElement("TD");
      TD2.style.whiteSpace = "normal";
      TD2.style.fontSize = "smaller";
      this._adminNameInput = document.createElement("INPUT");
      this._adminNameInput.size = 12;
      this._adminNameInput.addEventListener("input", () => {
        this.MakeSureCredentialsAreNotEmpty();
      });
      TD2.appendChild(this._adminNameInput);
      Row.appendChild(TD2);
      let TD3 = document.createElement("TD");
      TD3.style.whiteSpace = "normal";
      TD3.innerText = "Password:";
      TD3.style.fontSize = "smaller";
      Row.appendChild(TD3);
      let TD4 = document.createElement("TD");
      TD4.style.whiteSpace = "normal";
      this._adminPasswordInput = document.createElement("INPUT");
      this._adminPasswordInput.type = "password";
      this._adminPasswordInput.size = 12;
      this._adminPasswordInput.addEventListener("input", () => {
        this.MakeSureCredentialsAreNotEmpty();
      });
      TD4.appendChild(this._adminPasswordInput);
      TD4.style.fontSize = "smaller";
      Row.appendChild(TD4);
      this._adminNameInput.value = this.DEFAULTUSER;
      this._adminPasswordInput.value = this.DEFAULTPWD;
      Table.appendChild(Row);
      let userRow1 = document.createElement("TR");
      TD1 = document.createElement("TD");
      TD1.style.whiteSpace = "normal";
      TD1.innerText = "\n\nEnter read-only credentials below, these will be saved in the configuration";
      TD1.style.fontSize = "smaller";
      TD1.colSpan = 4;
      userRow1.appendChild(TD1);
      Table.appendChild(userRow1);
      let userRow2 = document.createElement("TR");
      TD1 = document.createElement("TD");
      TD1.style.whiteSpace = "normal";
      TD1.innerText = "Username:";
      TD1.style.borderLeft = "20px solid transparent";
      TD1.style.fontSize = "smaller";
      userRow2.appendChild(TD1);
      TD2 = document.createElement("TD");
      TD2.style.whiteSpace = "normal";
      TD2.style.fontSize = "smaller";
      this._userNameInput = document.createElement("INPUT");
      this._userNameInput.size = 12;
      this._userNameInput.addEventListener("input", () => {
        this.MakeSureCredentialsAreNotEmpty();
      });
      TD2.appendChild(this._userNameInput);
      userRow2.appendChild(TD2);
      TD3 = document.createElement("TD");
      TD3.style.whiteSpace = "normal";
      TD3.innerText = "Password:";
      TD3.style.fontSize = "smaller";
      userRow2.appendChild(TD3);
      TD4 = document.createElement("TD");
      TD4.style.whiteSpace = "normal";
      this._userPasswordInput = document.createElement("INPUT");
      this._userPasswordInput.type = "password";
      this._userPasswordInput.size = 12;
      this._userPasswordInput.addEventListener("input", () => {
        this.MakeSureCredentialsAreNotEmpty();
      });
      TD4.appendChild(this._userPasswordInput);
      TD4.style.fontSize = "smaller";
      userRow2.appendChild(TD4);
      this._userNameInput.value = this.DEFAULTUSER;
      this._userPasswordInput.value = this.DEFAULTPWD;
      Table.appendChild(userRow2);
      Table.style.marginTop = "0px";
      Table.style.marginBottom = "20px";
      this._pwdPanel.appendChild(Table);
      let userCredVisible = "";
      if (!this._currentHub_ReadOnlyProtected) {
        userCredVisible = "none";
        this._userPasswordInput.value = "";
        this._userNameInput.value = "";
      }
      userRow1.style.display = userCredVisible;
      userRow2.style.display = userCredVisible;
      let p = document.createElement("P");
      p.innerText = 'Note: On YoctoHubs and VirtualHub, username is either "user" for readonly or "admin" for read/write. Only ready-only credentials (if any) will saved in the configuration as Yocto-Visualization will ask for read/write credentials when saving, if needed.';
      p.style.fontSize = "smaller";
      this._pwdPanel.appendChild(p);
      this._container.appendChild(this._pwdPanel);
    }
    this._connectionErrorMsg.innerText = errmsg;
    this._nextButton.visible = true;
    this._prevButton.visible = true;
    this._cancelButton.visible = this.DEFAULTCANCELABLE;
    this._pwdPanel.style.display = "";
    let tabIndex = 1;
    this._adminNameInput.tabIndex = tabIndex++;
    this._adminPasswordInput.tabIndex = tabIndex++;
    this._userNameInput.tabIndex = tabIndex++;
    this._userPasswordInput.tabIndex = tabIndex++;
    this._prevButton.tabIndex = tabIndex++;
    this._nextButton.tabIndex = tabIndex++;
    this._adminNameInput.focus();
    this.MakeSureCredentialsAreNotEmpty();
  }
  createTextRow(caption, value) {
    let Row = document.createElement("TR");
    let TD1 = document.createElement("TD");
    TD1.style.whiteSpace = "normal";
    TD1.style.whiteSpace = "nowrap";
    TD1.innerText = caption;
    Row.appendChild(TD1);
    let TD2 = document.createElement("TD");
    TD2.style.whiteSpace = "normal";
    TD2.innerText = value;
    Row.appendChild(TD2);
    return Row;
  }
  async showHubDescription(visible, goingback) {
    if (!visible) {
      if (this._descPanel != null)
        this._descPanel.style.display = "none";
      return;
    }
    if (this._descPanel == null) {
      this._descPanel = this.createNewContentDiv();
      this._container.appendChild(this._descPanel);
    }
    if (!goingback) {
      this.removeAllChilds(this._descPanel);
      this._alreadyInstalled = false;
      let p = document.createElement("P");
      p.innerText = "Sucessfully connected to Hub " + this._ipAddrInput.value;
      this._descPanel.appendChild(p);
      let m = this._currentHub;
      let Table = document.createElement("TABLE");
      Table.style.marginTop = "20px";
      Table.style.marginBottom = "20px";
      let serial = await m.get_serialNumber();
      let firmware = await m.get_firmwareRelease();
      Table.appendChild(this.createTextRow("Model:", await m.get_productName()));
      Table.appendChild(this.createTextRow("Serial:", serial));
      Table.appendChild(this.createTextRow("Firmware:", firmware));
      let tmp = firmware.lastIndexOf(".");
      if (tmp >= 0)
        firmware = firmware.substr(tmp + 1);
      this._instancesFiles = [];
      let freespace = 0;
      this._instancesFiles = [];
      this._currentfs = null;
      let error = "";
      if (firmware.indexOf("-") < 0 && parseInt(firmware) < this.FIRMWAREMINVERSION) {
        error = "Hub firmware is too old for Yocto-Visualization to run properly. You need at least version " + this.FIRMWAREMINVERSION;
        this._nextButton.enabled = false;
      }
      if (error == "") {
        let ids = await m.get_functionIds("Files");
        if (ids.length > 0) {
          this._currentfs = await YFiles.FindFiles(serial + "." + ids[0]);
          freespace = Math.floor(await this._currentfs.get_freeSpace() / 1024);
          this._instancesFiles = await this._currentfs.get_list("yv4web*");
          Table.appendChild(this.createTextRow("Free space:", freespace.toString() + "K"));
          this._nextButton.enabled = true;
          if (freespace < 200) {
            error = "Not enough free space on device, please make sure there is at least 200K available.";
            this._nextButton.enabled = false;
          }
        } else {
          error = "No filesystem found on hub. On VirtualHub, the filesystem feature needs to be explicitely enabled at startup with the -F flag.";
        }
      }
      if (error != "") {
        Table.appendChild(this.createTextRow(" ", " "));
        let Row = document.createElement("TR");
        let TD1 = document.createElement("TD");
        TD1.style.whiteSpace = "normal";
        TD1.innerHTML = ressources.FailedIcon("32", true, false, false, false, "oops");
        TD1.style.textAlign = "right";
        Row.appendChild(TD1);
        let TD2 = document.createElement("TD");
        TD2.style.whiteSpace = "normal";
        TD2.style.fontSize = "smaller";
        TD2.innerText = error;
        Row.appendChild(TD2);
        Table.appendChild(Row);
        this._nextButton.enabled = false;
      }
      this._descPanel.appendChild(Table);
      if (this._instancesFiles.length > 0) {
        let p2 = document.createElement("P");
        p2.innerText = "Yocto-Visualization (for web) appears to be already installed on this hub. Click on next to modify this installation.";
        this._descPanel.appendChild(p2);
        this._alreadyInstalled = true;
      }
    }
    this._descPanel.style.display = "";
    this._nextButton.visible = true;
    this._prevButton.visible = true;
    this._cancelButton.visible = this.DEFAULTCANCELABLE;
    let tabIndex = 1;
    this._prevButton.tabIndex = tabIndex++;
    this._nextButton.tabIndex = tabIndex++;
    this._nextButton.focus();
  }
  async loadWebPagesList(filenameDesc) {
    this._webPageinstances = [];
    let webFiles = await this._currentfs.get_list("*");
    for (let i = 0; i < webFiles.length; i++) {
      let filename = await webFiles[i].get_name();
      if (filename.indexOf(".html") >= 0) {
        if (filenameDesc != null) {
          filenameDesc.innerText = "Now downloading " + filename + "...";
        }
        let contents = await this._currentfs.download(filename);
        if (filename.slice(-3) == ".gz") {
          contents = Pako_Inflate.ungzip(contents, {});
        }
        let contentsStr = YAPI.imm_bin2str(contents);
        if (contentsStr.indexOf("window.runYV()") > 0) {
          this._webPageinstances.push(new pageInstance(filename, contents));
        }
      }
    }
  }
  async showModifyInstallPanel(visible, goingback) {
    if (!visible) {
      if (this._modifyInstallPanel != null)
        this._modifyInstallPanel.style.display = "none";
      return;
    }
    this._nextButton.visible = false;
    this._prevButton.visible = false;
    this._cancelButton.visible = false;
    if (this._modifyInstallPanel == null) {
      this._modifyInstallPanel = this.createNewContentDiv();
      this._container.appendChild(this._modifyInstallPanel);
    }
    if (!goingback) {
      this.removeAllChilds(this._modifyInstallPanel);
      this._jsCodeinstances = [];
      this._webPageinstances = [];
      let p = document.createElement("P");
      p.innerText = "Please wait, downloading and parsing files from the hub ";
      this._modifyInstallPanel.appendChild(p);
      this._modifyInstallPanel.style.display = "";
      let files = document.createElement("P");
      files.innerText = "";
      let filenameDesc = document.createElement("P");
      filenameDesc.style.fontSize = "smaller";
      this._modifyInstallPanel.appendChild(filenameDesc);
      for (let i = 0; i < this._instancesFiles.length; i++) {
        let filename = await this._instancesFiles[i].get_name();
        filenameDesc.innerText = "Now downloading " + filename + "...";
        files.innerText = filename;
        let contentsStr = "";
        let contents = await this._currentfs.download(filename);
        if (filename.slice(-3) == ".gz") {
          contents = Pako_Inflate.ungzip(contents, {});
        }
        contentsStr = YAPI.imm_bin2str(contents);
        let esTarget = "";
        let version = "";
        let readonlyVersion = true;
        let p2 = contentsStr.indexOf("*/");
        if (p2 > 0) {
          let firstLine = contentsStr.slice(0, p2);
          let p1 = firstLine.indexOf("(");
          let p22 = firstLine.indexOf(")");
          if (p1 > 0 && p22 > p1) {
            let tokens = firstLine.slice(p1 + 1, p22).split(" ");
            if (tokens.length > 0)
              esTarget = tokens[0];
            if (tokens.length > 1)
              readonlyVersion = tokens[1] != "full";
            if (tokens.length > 2)
              version = tokens[2];
          }
        }
        this._jsCodeinstances.push(new codeInstance(filename, esTarget, version, readonlyVersion));
      }
      await this.loadWebPagesList(filenameDesc);
      filenameDesc.style.display = "none";
      p.innerText = "What would you like to do ?";
      let uninstallLegend = document.createElement("span");
      uninstallLegend.innerText = "Uninstall / delete all Yocto-Visualization (for web) related files\n\n";
      this._uninstallOpt = document.createElement("input");
      this._uninstallOpt.setAttribute("type", "radio");
      this._uninstallOpt.setAttribute("name", "installType");
      this._modifyInstallPanel.appendChild(this._uninstallOpt);
      this._modifyInstallPanel.appendChild(uninstallLegend);
      let BuildsFound = {};
      for (let i = 0; i < this._jsCodeinstances.length; i++) {
        BuildsFound[this._jsCodeinstances[i].version] = 1;
      }
      let BuildsFoundList = "";
      for (let key in BuildsFound) {
        if (BuildsFound.hasOwnProperty(key)) {
          BuildsFoundList += (BuildsFoundList != "" ? ", " : "") + key;
        }
      }
      let updateLegend = document.createElement("span");
      updateLegend.innerText = "Update all from " + BuildsFoundList + " to " + constants.buildVersion + "\n\n";
      this._updateOpt = document.createElement("input");
      this._updateOpt.setAttribute("type", "radio");
      this._updateOpt.setAttribute("name", "installType");
      this._modifyInstallPanel.appendChild(this._updateOpt);
      this._modifyInstallPanel.appendChild(updateLegend);
      let addInstanceLegend = document.createElement("span");
      addInstanceLegend.innerText = "Add a new instance \n\n";
      this._addInstanceOpt = document.createElement("input");
      this._addInstanceOpt.setAttribute("type", "radio");
      this._addInstanceOpt.setAttribute("name", "installType");
      this._modifyInstallPanel.appendChild(this._addInstanceOpt);
      this._modifyInstallPanel.appendChild(addInstanceLegend);
      let modInstanceLegend = document.createElement("span");
      modInstanceLegend.innerText = "Modify or delete existing instances \n\n";
      this._modInstanceOpt = document.createElement("input");
      this._modInstanceOpt.setAttribute("type", "radio");
      this._modInstanceOpt.setAttribute("name", "installType");
      this._modifyInstallPanel.appendChild(this._modInstanceOpt);
      this._modifyInstallPanel.appendChild(modInstanceLegend);
      if (!this._uninstallOpt.checked && !this._updateOpt.checked && !this._addInstanceOpt.checked && !this._modInstanceOpt.checked) {
        this._updateOpt.checked = true;
      }
    }
    this._modifyInstallPanel.style.display = "";
    this._nextButton.enabled = true;
    this._prevButton.enabled = true;
    this._nextButton.visible = true;
    this._prevButton.visible = true;
    this._cancelButton.visible = this.DEFAULTCANCELABLE;
    let tabIndex = 1;
    this._uninstallOpt.tabIndex = tabIndex++;
    this._updateOpt.tabIndex = tabIndex++;
    this._addInstanceOpt.tabIndex = tabIndex++;
    this._modInstanceOpt.tabIndex = tabIndex++;
    this._prevButton.tabIndex = tabIndex++;
    this._nextButton.tabIndex = tabIndex++;
    this._nextButton.focus();
  }
  async showModInstancesPanel(visible, goingback) {
    if (!visible) {
      if (this._modInstancesPanel != null)
        this._modInstancesPanel.style.display = "none";
      return;
    }
    if (this._modInstancesPanel == null) {
      this._modInstancesPanel = this.createNewContentDiv();
      this._container.appendChild(this._modInstancesPanel);
    }
    let tabIndex = 1;
    if (!goingback) {
      this.removeAllChilds(this._modInstancesPanel);
      let p = document.createElement("P");
      this._modInstancesPanel.appendChild(p);
      p.innerText = "Here is a list of installed instances. Select an action for each one, then click on next to have them applied.";
      let table = document.createElement("Table");
      table.style.marginLeft = "20px";
      for (let i = 0; i < this._webPageinstances.length; i++) {
        let tr = document.createElement("TR");
        let td = document.createElement("TD");
        td.style.whiteSpace = "normal";
        td.innerText = this._webPageinstances[i].http_filename + (this._webPageinstances[i].compressed ? "[.gz]" : "");
        tr.appendChild(td);
        let td2 = document.createElement("TD");
        td2.style.whiteSpace = "normal";
        td2.style.paddingLeft = "10px";
        let chooser = document.createElement("SELECT");
        chooser.tabIndex = tabIndex++;
        let opt = document.createElement("OPTION");
        opt.tabIndex = tabIndex++;
        opt.text = "Do Nothing";
        opt.value = this._MODIFYNOTHING.toString();
        chooser.add(opt);
        let opt2 = document.createElement("OPTION");
        if (this._webPageinstances[i].compressed) {
          opt2.text = "Uncompress instance file";
          opt2.value = this._MODIFYUNCOMPRESS.toString();
        } else {
          opt2.text = "Compress instance file";
          opt2.value = this._MODIFYCOMPRESS.toString();
        }
        chooser.add(opt2);
        let opt3 = document.createElement("OPTION");
        if (this._webPageinstances[i].readonly) {
          opt3.text = "Allow read/write";
          opt3.value = this._MODIFYMAKEREADWRITE.toString();
        } else {
          opt3.text = "Make read only";
          opt3.value = this._MODIFYMAKEREADONLY.toString();
        }
        chooser.add(opt3);
        let opt4 = document.createElement("OPTION");
        if (this._webPageinstances[i].useMinified) {
          opt4.text = "Use human readable JS module";
          opt4.value = this._MODIFYUSEPLAIN.toString();
        } else {
          opt4.text = "Use minified JS module";
          opt4.value = this._MODIFYUSEMINIFIED.toString();
        }
        chooser.add(opt4);
        let opt5 = document.createElement("OPTION");
        opt5.text = "Delete (cannot be reverted)";
        opt5.value = this._MODIFYDELETE.toString();
        chooser.add(opt5);
        let index = i;
        chooser.addEventListener("change", () => {
          this._webPageinstances[index].action = Number(chooser.value);
        });
        td2.appendChild(chooser);
        tr.appendChild(td2);
        table.appendChild(tr);
      }
      this._modInstancesPanel.appendChild(table);
      let p2 = document.createElement("P");
      this._removeUnusedJs = document.createElement("INPUT");
      this._removeUnusedJs.tabIndex = tabIndex++;
      this._removeUnusedJs.type = "checkbox";
      this._removeUnusedJs.checked = true;
      p2.appendChild(this._removeUnusedJs);
      let span = document.createElement("SPAN");
      span.innerText = "Remove unused Yocto-Visualization (for web) JS module files";
      p2.appendChild(span);
      this._modInstancesPanel.appendChild(p2);
      this._prevButton.tabIndex = tabIndex++;
      this._nextButton.tabIndex = tabIndex++;
      this._nextButton.focus();
    }
    this._modInstancesPanel.style.display = "";
  }
  async showCustomFilesPanel(visible, goingback) {
    if (!visible) {
      if (this._customFilesPanel != null)
        this._customFilesPanel.style.display = "none";
      return;
    }
    if (this._customFilesPanel == null) {
      this._customFilesPanel = this.createNewContentDiv();
      this._container.appendChild(this._customFilesPanel);
    }
    if (!goingback) {
      this.removeAllChilds(this._customFilesPanel);
      let p = document.createElement("P");
      p.innerText = this._plannedaction == this.ACTIONINSTALL ? "Optionnaly, you can customize your Yocto-Visualization (for web) installation by providing some files" : "Optionnaly, you can customize your new instance by providing some files";
      this._customFilesPanel.appendChild(p);
      let Table = document.createElement("TABLE");
      Table.style.fontSize = "smaller";
      Table.style.marginTop = "20px";
      Table.style.marginBottom = "20px";
      let Row;
      let TD1;
      let TD2;
      Row = document.createElement("TR");
      TD1 = document.createElement("TD");
      TD1.style.whiteSpace = "normal";
      TD1.colSpan = 2;
      TD1.style.textAlign = "justify";
      TD1.innerText = 'You can choose an initial XML configuration file. You can get a XML configuration file from a Yocto-Visualization (for web) instance in the  "Global configulation" panel. You can also use a config.xml file from the Yocto-Visualization native version.';
      Row.appendChild(TD1);
      Table.appendChild(Row);
      Row = document.createElement("TR");
      TD1 = document.createElement("TD");
      TD1.style.whiteSpace = "normal";
      TD1.innerText = "Config file:";
      Row.appendChild(TD1);
      TD2 = document.createElement("TD");
      TD2.style.whiteSpace = "normal";
      this._configFileInput = document.createElement("INPUT");
      this._configFileInput.type = "file";
      this._configFileInput.accept = ".xml";
      TD2.appendChild(this._configFileInput);
      Row.style.marginBottom = "10px";
      Row.appendChild(TD2);
      Table.appendChild(Row);
      Row = document.createElement("TR");
      TD1 = document.createElement("TD");
      TD1.style.whiteSpace = "normal";
      TD1.colSpan = 2;
      TD1.style.textAlign = "justify";
      TD1.innerText = "\nYou can choose a container HTML file. Note: if this file relies on local dependencies such as images or CSS files, you'll have to upload them on the hub yourself.";
      Row.appendChild(TD1);
      Table.appendChild(Row);
      this._customFilesPanel.appendChild(Table);
      Row = document.createElement("TR");
      TD1 = document.createElement("TD");
      TD1.style.whiteSpace = "normal";
      TD1.innerText = "HTML file:";
      Row.appendChild(TD1);
      TD2 = document.createElement("TD");
      TD2.style.whiteSpace = "normal";
      this._webPageInput = document.createElement("INPUT");
      this._webPageInput.type = "file";
      this._webPageInput.accept = ".html";
      TD2.appendChild(this._webPageInput);
      Row.appendChild(TD2);
      Table.appendChild(Row);
    }
    this._customFilesPanel.style.display = "";
    this._nextButton.enabled = true;
    this._prevButton.enabled = true;
    this._nextButton.visible = true;
    this._prevButton.visible = true;
    this._cancelButton.visible = this.DEFAULTCANCELABLE;
    let tabIndex = 1;
    this._webPageInput.tabIndex = tabIndex++;
    this._configFileInput.tabIndex = tabIndex++;
    this._prevButton.tabIndex = tabIndex++;
    this._nextButton.tabIndex = tabIndex++;
    this._nextButton.focus();
  }
  async showOptionsPanel(visible, goingback) {
    if (!visible) {
      if (this._optionsPanel != null)
        this._optionsPanel.style.display = "none";
      return;
    }
    if (this._optionsPanel == null) {
      this._optionsPanel = this.createNewContentDiv();
      let p = document.createElement("P");
      p.innerText = this._plannedaction == this.ACTIONINSTALL ? "You can also customize the installation behavior" : "You can also customize this new instance behavior";
      this._optionsPanel.appendChild(p);
      p = document.createElement("P");
      p.style.fontSize = "smaller";
      p.style.marginBottom = "0px";
      p.style.marginTop = "0px";
      this._fileprefixInput = document.createElement("INPUT");
      let presetname = this.DEFAULTFILEPREFIX;
      let n = 1;
      let checkgain = false;
      do {
        checkgain = false;
        for (let i = 0; i < this._webPageinstances.length; i++) {
          if (presetname + this.TARGETEXTENSION == this._webPageinstances[i].http_filename) {
            n++;
            presetname = this.DEFAULTFILEPREFIX + "(" + n.toString() + ")";
            checkgain = true;
          }
        }
      } while (checkgain);
      this._fileprefixInput.value = presetname;
      this._fileprefixInput.maxLength = 10;
      this._fileprefixInput.size = 10;
      let span = document.createElement("SPAN");
      span.innerText = "Set the instance name to : ";
      p.appendChild(span);
      p.appendChild(this._fileprefixInput);
      this._optionsPanel.appendChild(p);
      p = document.createElement("P");
      p.style.fontSize = "smaller";
      p.style.marginBottom = "0px";
      p.style.marginTop = "0px";
      this._useFullVersionInput = document.createElement("INPUT");
      this._useFullVersionInput.type = "checkbox";
      p.appendChild(this._useFullVersionInput);
      span = document.createElement("SPAN");
      span.innerText = this._plannedaction == this.ACTIONINSTALL ? "Install the non-minified version (easier to debug)" : "Use the non-minified version (easier to debug)";
      p.appendChild(span);
      this._optionsPanel.appendChild(p);
      p = document.createElement("P");
      p.style.fontSize = "smaller";
      p.style.marginBottom = "0px";
      p.style.marginTop = "0px";
      this._makeDefaultInput = document.createElement("INPUT");
      this._makeDefaultInput.type = "checkbox";
      p.appendChild(this._makeDefaultInput);
      span = document.createElement("SPAN");
      span.innerText = this._plannedaction == this.ACTIONINSTALL ? "Make Yocto-Visualization (for web) the hub's default page" : "Make this instance the hub's default page";
      p.appendChild(span);
      this._optionsPanel.appendChild(p);
      p = document.createElement("P");
      p.style.fontSize = "smaller";
      p.style.marginBottom = "0px";
      p.style.marginTop = "0px";
      this._useReadOnlyInput = document.createElement("INPUT");
      this._useReadOnlyInput.type = "checkbox";
      p.appendChild(this._useReadOnlyInput);
      span = document.createElement("SPAN");
      span.innerText = this._plannedaction == this.ACTIONINSTALL ? "Make the install read-only" : "Make this instance read-only";
      p.appendChild(span);
      this._optionsPanel.appendChild(p);
      if (this._jsCodeinstances.length > 0) {
        this._useReadOnlyInput.checked = this._jsCodeinstances[0].readonly;
        this._useFullVersionInput.checked = !this._jsCodeinstances[0].minified;
      }
      p = document.createElement("P");
      p.innerText = 'Click on "Next" button to start the installation';
      this._optionsPanel.appendChild(p);
      this._container.appendChild(this._optionsPanel);
    }
    this._nextButton.visible = true;
    this._prevButton.visible = true;
    this._cancelButton.visible = this.DEFAULTCANCELABLE;
    this._optionsPanel.style.display = "";
    let tabIndex = 1;
    this._fileprefixInput.tabIndex = tabIndex++;
    this._useFullVersionInput.tabIndex = tabIndex++;
    this._makeDefaultInput.tabIndex = tabIndex++;
    this._useReadOnlyInput.tabIndex = tabIndex++;
    this._prevButton.tabIndex = tabIndex++;
    this._nextButton.tabIndex = tabIndex++;
    this._nextButton.focus();
  }
  logLine(line) {
    let p = document.createElement("P");
    p.innerText = line + " ";
    p.style.fontSize = "smaller";
    p.style.marginLeft = "10px";
    p.style.marginTop = "0px;";
    p.style.marginBottom = "0px;";
    p.style.paddingTop = "0px;";
    p.style.paddingBottom = "0px;";
    let span = document.createElement("SPAN");
    p.appendChild(span);
    this._runPanel.appendChild(p);
    return span;
  }
  async showRunPanel(visible, goingback) {
    if (!visible) {
      if (this._runPanel != null)
        this._runPanel.style.display = "none";
      return;
    }
    if (this._runPanel == null) {
      this._runPanel = this.createNewContentDiv();
    }
    this.removeAllChilds(this._runPanel);
    this._runPanel.style.display = "";
    let desc = document.createElement("P");
    this._runPanel.appendChild(desc);
    this._container.appendChild(this._runPanel);
    this._nextButton.visible = false;
    this._prevButton.visible = false;
    this._cancelButton.visible = false;
    switch (this._plannedaction) {
      case this.ACTIONINSTALL:
        desc.innerText = "Installing on " + this._currentHub_Addr + "... please wait.";
        try {
          await this.install((line) => {
            return this.logLine(line);
          });
        } catch (e) {
          this.gotoPanel(this.CONNECTIONERROR, "Installation failed with an internal error : " + e.toString() + "\n\nFeel free to contact Yoctopuce support.");
        }
        break;
      case this.ACTIONADDINSTANCE:
        desc.innerText = "Creating new instance  on " + this._currentHub_Addr + "... please wait.";
        try {
          await this.install((line) => {
            return this.logLine(line);
          });
        } catch (e) {
          this.gotoPanel(this.CONNECTIONERROR, "Instance creation failed with an internal error : " + e.toString() + "\n\nFeel free to contact Yoctopuce support.");
        }
        break;
      case this.ACTIONUNINSTALL:
        desc.innerText = "Uninstalling everything from " + this._currentHub_Addr + "... please wait.";
        try {
          await this.uninstall((line) => {
            return this.logLine(line);
          });
        } catch (e) {
          this.gotoPanel(this.CONNECTIONERROR, "Installation failed with an internal error : " + e.toString() + "\n\nFeel free to contact Yoctopuce support.");
        }
        break;
      case this.ACTIONUPDATE:
        desc.innerText = "Updating js files on " + this._currentHub_Addr + "... please wait.";
        try {
          await this.upgrade((line) => {
            return this.logLine(line);
          });
        } catch (e) {
          this.gotoPanel(this.CONNECTIONERROR, "Update failed with an internal error : " + e.toString() + "\n\nFeel free to contact Yoctopuce support.");
        }
        break;
      case this.ACTIONMODINSTANCE:
        desc.innerText = "Modifying instances on " + this._currentHub_Addr + "... please wait.";
        try {
          await this.modifyInstances((line) => {
            return this.logLine(line);
          });
        } catch (e) {
          this.gotoPanel(this.CONNECTIONERROR, "Instances modification failed with an internal error : " + e.toString() + "\n\nFeel free to contact Yoctopuce support.");
        }
        break;
    }
  }
  checkHTMLfile(htmlData, errmsg) {
    let upper = htmlData.toUpperCase();
    if (upper.indexOf("<HTML") < 0) {
      errmsg.msg = "Provided web page is not a proper HTML file: no HTML tag";
      return false;
    }
    if (upper.indexOf("</BODY>") < 0) {
      errmsg.msg = "Provided web page has an unexpected structure: no closing BODY tag";
      return false;
    }
    return true;
  }
  checkConfigfile(xmlData, errmsg) {
    let parser = new DOMParser();
    let doc = parser.parseFromString(xmlData, "application/xml");
    let root = null;
    doc.childNodes.forEach((node) => {
      if (node.nodeName.toUpperCase() == "ROOT" && root == null)
        root = node;
    });
    if (root == null) {
      errmsg.msg = "Provided config XML file is not a proper YoctoVisualization 2 config file. Unable to find ROOT node, either the root node does not exists or the file caused an XML parse error.";
      return false;
    }
    let rootNode = new YXmlNode(root);
    let attributes = rootNode.Attributes;
    if (!attributes.hasOwnProperty("version")) {
      errmsg.msg = "Provided  XML config file is not a proper Yocto-Visualization 2 config file (No ROOT Version attribute)";
      return false;
    }
    if (parseFloat(attributes["version"]) < 2) {
      errmsg.msg = "Provided XML config file is not a proper Yocto-Visualization 2 config file (at least Version 2.0 is required)";
      return false;
    }
    return true;
  }
  findChild(parent, name) {
    let res = null;
    parent.childNodes.forEach((node) => {
      if (node.nodeName == name) {
        res = node;
        return;
      }
    });
    return res;
  }
  patchConfigFile(xmlData) {
    let startTag = "<Hubs>";
    let endTag = "</Hubs>";
    let parser = new DOMParser();
    let doc = parser.parseFromString(xmlData, "application/xml");
    let rootNode = this.findChild(doc, "ROOT");
    if (rootNode == null)
      throw "No root node in config file.";
    let configNode = this.findChild(rootNode, "Config");
    if (configNode == null)
      throw "No config node in config file.";
    let Hubs = this.findChild(configNode, "Hubs");
    let HubSection;
    if (Hubs == null) {
      HubSection = startTag + "\n" + this.getHubConfig() + "\n" + endTag + "\n";
      xmlData = xmlData.replace("<Config>", "<Config>\n" + HubSection);
    } else {
      let list = Hubs.childNodes;
      let sourceHubFound = false;
      HubSection = startTag + "\n";
      for (let i = 0; i < list.length; i++) {
        if (list[i].nodeName == "Hub") {
          let node = new YXmlNode(list[i]);
          let attributes = node.Attributes;
          let addr = attributes.hasOwnProperty("addr") ? attributes["addr"] : "";
          let port = attributes.hasOwnProperty("port") ? attributes["port"] : "80";
          let protocol = attributes.hasOwnProperty("protocol") ? attributes["protocol"] : "";
          let path = attributes.hasOwnProperty("path") ? attributes["path"] : "";
          let username = attributes.hasOwnProperty("user") ? attributes["user"] : "";
          let password = attributes.hasOwnProperty("password") ? attributes["password"] : "";
          if (!sourceHubFound && addr == this._currentHub_Addr && port == this._currentHub_port && path == this._currentHub_path) {
            sourceHubFound = true;
            HubSection += "    " + this.getHubConfig() + "\n";
          } else {
            HubSection += "    " + this.createHubRecord(protocol, addr, port, path, username, password, true) + "\n";
          }
        }
      }
      if (!sourceHubFound)
        HubSection += "    " + this.getHubConfig() + "\n";
      HubSection += "  ";
      let indexStart = xmlData.indexOf(startTag);
      let indexStop = xmlData.indexOf(endTag);
      if (indexStart < 0)
        throw "Cannot locate Hubs start tag in provided  config file";
      if (indexStop < 0)
        throw "Cannot locate Hubs end tag in provided  config file";
      xmlData = xmlData.substr(0, indexStart) + HubSection + xmlData.substr(indexStop);
    }
    return xmlData;
  }
  createHubRecord(protocol, addr, port, path, username, password, removable) {
    let res = '<Hub protocol="' + constants.XMLquote(protocol) + '" addr="' + constants.XMLquote(addr) + '" port="' + constants.XMLquote(port) + '"';
    if (path != "")
      res += ' path="' + constants.XMLquote(path) + '"';
    if (username != "")
      res += ' user="' + constants.XMLquote(username) + '"';
    if (password != "")
      res += ' password="' + constants.XMLquote(password) + '"';
    if (!removable)
      res += ' removable="FALSE"';
    res += "/>";
    return res;
  }
  getHubConfig() {
    let username = "";
    let password = "";
    if (this._currentHub_ReadOnlyProtected) {
      username = this._userNameInput.value;
      password = Hub.encryptPassword(this._userPasswordInput.value);
    }
    return this.createHubRecord(this._currentHub_protocol, this._currentHub_Addr, this._currentHub_port, this._currentHub_path, username, password, false);
  }
  getSeedCode(configfile, readonly, minified) {
    let res = '\n<script type="module">\n';
    if (configfile == null)
      configfile = '<?xml version="1.0" ?><ROOT version="2.1"><Config><Hubs>' + this.getHubConfig() + "</Hubs></Config></ROOT>\n";
    let filename = "yv4web-" + (readonly ? "readonly" : "full") + (minified ? ".min" : "") + ".js";
    res += ' import { YWebPage, YoctoHubFileHandler }  from "./' + filename + '";\n';
    res += " window.runYV= async ()=>{";
    res += " let filehandler = await YoctoHubFileHandler.start(";
    if (configfile != null)
      res += JSON.stringify(configfile);
    res += ");\n";
    res += "  YWebPage.run(filehandler.xmlConfigData, filehandler.configChangeCallbackFct";
    if (!readonly)
      res += ",filehandler.saveFct";
    res += ");\n";
    res += "};\n window.runYV();</script>\n";
    res += '<script nomodule="">\n';
    res += `document.write("<p style='font-family: sans-serif; text-align:center'>Yocto-Visualization (for web) cannot run on this browser. Sorry.<br>Consider using a more recent browser, or <a href='https://www.yoctopuce.com/EN/tools.php'>the native version</a>. </p>")
`;
    res += "</script>\n";
    return res;
  }
  defaultHTMLfile(configfile, readonly, minified) {
    return "<!DOCTYPE HTML>\n<HTML lang='en-US'><HEAD>\n<title>\nYocto-Visualization</title>\n" + this.icon + "\n<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no'/></HEAD>\n<BODY>\n</BODY>" + this.getSeedCode(configfile, readonly, minified) + "\n</HTML>\n";
  }
  async uploadWidthProgress(str_path, bin_content, progress) {
    let yreq = await this._currentfs._uploadWithProgress(str_path, bin_content, progress);
    return yreq.errorType;
  }
  async upgrade(log) {
    let install_minified_readonly = false;
    let install_plain_readonly = false;
    let install_minified_readwrite = false;
    let install_plain_readwrite = false;
    for (let i = 0; i < this._jsCodeinstances.length; i++) {
      if (this._jsCodeinstances[i].minified) {
        if (this._jsCodeinstances[i].readonly) {
          install_minified_readonly = true;
        } else {
          install_minified_readwrite = true;
        }
      } else {
        if (this._jsCodeinstances[i].readonly) {
          install_plain_readonly = true;
        } else {
          install_plain_readwrite = true;
        }
      }
    }
    if (install_minified_readonly)
      await this.copyJsCode(log, true, true);
    if (install_plain_readonly)
      await this.copyJsCode(log, true, false);
    if (install_minified_readwrite)
      await this.copyJsCode(log, false, true);
    if (install_plain_readwrite)
      await this.copyJsCode(log, false, false);
    log("Done.");
    setTimeout(() => {
      this.gotoPanel(this.DONEPANEL);
    }, 2e3);
  }
  async syncJsFile(log, required, readonly, minified, removeunused) {
    let jsfile = this.get_js_filename(readonly, minified) + ".gz";
    let exists = await this._currentfs.fileExist(jsfile);
    if (required && !exists)
      await this.copyJsCode(log, readonly, minified);
    if (!required && exists && removeunused) {
      let span = log("Deleting " + jsfile);
      await this._currentfs.remove(jsfile);
      span.innerText = "done.";
    }
  }
  async syncJsFileVersions(log, removeunused) {
    let require_minified_readonly = false;
    let require_plain_readonly = false;
    let require_minified_readwrite = false;
    let require_plain_readwrite = false;
    for (let i = 0; i < this._webPageinstances.length; i++) {
      if (this._webPageinstances[i].useMinified) {
        if (this._webPageinstances[i].readonly) {
          require_minified_readonly = true;
        } else {
          require_minified_readwrite = true;
        }
      } else {
        if (this._webPageinstances[i].readonly) {
          require_plain_readonly = true;
        } else {
          require_plain_readwrite = true;
        }
      }
    }
    await this.syncJsFile(log, require_minified_readonly, true, true, removeunused);
    await this.syncJsFile(log, require_plain_readonly, true, false, removeunused);
    await this.syncJsFile(log, require_minified_readwrite, false, true, removeunused);
    await this.syncJsFile(log, require_plain_readwrite, false, false, removeunused);
  }
  async patchPageInstance(log, page, signature1, replace1, altsignature1, altreplace1, signature2, replace2) {
    let contents = YAPI.imm_bin2str(page.contents);
    let p = contents.indexOf(signature1);
    if (p < 0 && altsignature1 != "") {
      signature1 = altsignature1;
      replace1 = altreplace1;
      p = contents.indexOf(signature1);
    }
    if (p < 0)
      throw "Operation failed: cannot find the [" + signature1 + "] import signature in " + page.fs_filename;
    contents = contents.substr(0, p) + replace1 + contents.substr(p + signature1.length);
    if (signature2 != "") {
      p = contents.indexOf(signature2);
      if (p < 0)
        throw "Operation failed: cannot find the [" + signature2 + "] signature parameter in " + page.fs_filename;
      contents = contents.substr(0, p) + replace2 + contents.substr(p + signature2.length);
    }
    let bincontents = YAPI.imm_str2bin(contents);
    let filename = page.fs_filename;
    if (page.compressed) {
      let status2 = log("Compressing  " + filename);
      bincontents = Pako_Deflate.gzip(bincontents, {level: 9});
      status2.innerText = "done";
    }
    let status = log("Uploading  " + filename + " to hub");
    status.innerText = "0%";
    let success = await this.uploadWidthProgress(filename, bincontents, (curr, total) => {
      status.innerText = Math.round(100 * curr / total).toString() + "%";
    });
    status.innerText = "done";
    if (success != YAPI_SUCCESS)
      throw "Upload failed (Error" + success.toString() + ").";
  }
  async modifyInstances(log) {
    for (let i = 0; i < this._webPageinstances.length; i++) {
      switch (this._webPageinstances[i].action) {
        case this._MODIFYNOTHING:
          break;
        case this._MODIFYDELETE:
          let span = log("Deleting " + this._webPageinstances[i].fs_filename);
          await this._currentfs.remove(this._webPageinstances[i].fs_filename);
          span.innerText = "done.";
          break;
        case this._MODIFYUNCOMPRESS:
          {
            let filename = this._webPageinstances[i].http_filename;
            let status = log("Uploading  " + filename + " to hub");
            status.innerText = "0%";
            let success = await this.uploadWidthProgress(filename, this._webPageinstances[i].contents, (curr, total) => {
              status.innerText = Math.round(100 * curr / total).toString() + "%";
            });
            status.innerText = "done";
            if (success != YAPI_SUCCESS)
              throw "Upload failed! (Error" + success.toString() + ")";
            status = log("Deleting " + this._webPageinstances[i].fs_filename);
            await this._currentfs.remove(this._webPageinstances[i].fs_filename);
            status.innerText = "done.";
          }
          break;
        case this._MODIFYCOMPRESS:
          {
            let filename = this._webPageinstances[i].http_filename + ".gz";
            let status = log("Compressing  " + filename);
            let GZ_data = Pako_Deflate.gzip(this._webPageinstances[i].contents, {level: 9});
            status.innerText = "done";
            status = log("Uploading  " + filename + " to hub");
            status.innerText = "0%";
            let success = await this.uploadWidthProgress(filename, GZ_data, (curr, total) => {
              status.innerText = Math.round(100 * curr / total).toString() + "%";
            });
            status.innerText = "done";
            if (success != YAPI_SUCCESS)
              throw "Upload failed!! (Error" + success.toString() + ")";
            status = log("Deleting " + this._webPageinstances[i].http_filename);
            await this._currentfs.remove(this._webPageinstances[i].http_filename);
            status.innerText = "done.";
          }
          break;
        case this._MODIFYMAKEREADONLY:
          await this.patchPageInstance(log, this._webPageinstances[i], 'from "./yv4web-full', 'from "./yv4web-readonly', "", "", ",filehandler.saveFct);", ");");
          this._webPageinstances[i].readonly = true;
          break;
        case this._MODIFYMAKEREADWRITE:
          await this.patchPageInstance(log, this._webPageinstances[i], 'from "./yv4web-readonly', 'from "./yv4web-full', "", "", "filehandler.configChangeCallbackFct);", "filehandler.configChangeCallbackFct,filehandler.saveFct);");
          this._webPageinstances[i].readonly = false;
          break;
        case this._MODIFYUSEPLAIN:
          await this.patchPageInstance(log, this._webPageinstances[i], '"./yv4web-full.min.js"', '"./yv4web-full.js"', '"./yv4web-readonly.min.js"', '"./yv4web-readonly.js"', "", "");
          this._webPageinstances[i].useMinified = false;
          break;
        case this._MODIFYUSEMINIFIED:
          await this.patchPageInstance(log, this._webPageinstances[i], '"./yv4web-full.js"', '"./yv4web-full.min.js"', '"./yv4web-readonly.js"', '"./yv4web-readonly.min.js"', "", "");
          this._webPageinstances[i].useMinified = true;
          break;
      }
    }
    await this.syncJsFileVersions(log, this._removeUnusedJs.checked);
    log("Done.");
    setTimeout(() => {
      this.gotoPanel(this.DONEPANEL);
    }, 2e3);
  }
  async uninstall(log) {
    for (let i = 0; i < this._jsCodeinstances.length; i++) {
      let filename = this._jsCodeinstances[i].filename;
      log("Deleteting " + filename);
      await this._currentfs.remove(filename);
    }
    let network = await YNetwork.FindNetwork(await this._currentHub.get_serialNumber() + ".network");
    let startPage = await network.get_defaultPage();
    let mustResetStartPage = false;
    for (let i = 0; i < this._webPageinstances.length; i++) {
      let filename = this._webPageinstances[i].fs_filename;
      if (startPage == this._webPageinstances[i].http_filename)
        mustResetStartPage = true;
      log("Deleteting " + filename);
      await this._currentfs.remove(filename);
    }
    if (mustResetStartPage) {
      log("Setting default page to index.html");
      await network.set_defaultPage("");
      await this._currentHub.saveToFlash();
    }
    log("Done.");
    setTimeout(() => {
      this.gotoPanel(this.DONEPANEL);
    }, 2e3);
  }
  get_js_filename(readonly, minified) {
    return "yv4web-" + (readonly ? "readonly" : "full") + (minified ? ".min" : "") + ".js";
  }
  get_js_blob(readonly, minified) {
    let data;
    if (readonly) {
      data = minified ? BinariesBlobs.ro_minjs : BinariesBlobs.ro_js;
    } else {
      data = minified ? BinariesBlobs.rw_minjs : BinariesBlobs.rw_js;
    }
    if (data == "")
      return null;
    return YAPI.imm_str2bin(atob(data));
  }
  async copyJsCode(log, readonly, minified) {
    let currentURL = window.location.href;
    let filename = currentURL.split("/").pop().split("#")[0].split("?")[0];
    let jsfile = this.get_js_filename(readonly, minified);
    let GZ_data = this.get_js_blob(readonly, minified);
    let status;
    if (GZ_data == null) {
      status = log("Downloading " + jsfile + " module from server..");
      let jsfileURL = currentURL.replace(filename, "../../dist/" + this.ESVersion + "/" + jsfile);
      let result;
      result = await YoctoHubFileHandler.makeRequest("GET", jsfileURL);
      if (result.data == null) {
        let err = "Installation Failed: cannot download the Yocto-Visualization file from the serveur serving this installer.\n\nError was : " + result.statusText + "\n\nURL was: " + jsfileURL;
        this.gotoPanel(this.CONNECTIONERROR, err);
        return;
      }
      status.innerText = "done.";
      status = log("Compressing JS Module..");
      GZ_data = Pako_Deflate.gzip(result.data, {level: 9});
      status.innerText = "done.";
    }
    status = log("Copying JS Module to hub..");
    status.innerText = "0%";
    let success = await this.uploadWidthProgress(jsfile + ".gz", GZ_data, (curr, total) => {
      status.innerText = Math.round(100 * curr / total).toString() + "%";
    });
    if (success != YAPI_SUCCESS)
      throw "Upload failed. (Error" + success.toString() + ").";
    status.innerText = "done.";
  }
  async install(log) {
    let configFile = await this.loadLocalFile(this._configFileInput);
    if (configFile != null) {
      configFile = configFile.replace("<!-->", "<!-- ");
      let err = new YErrorMsg();
      if (!this.checkConfigfile(configFile, err)) {
        this.gotoPanel(this.CONNECTIONERROR, "Installation failed\n\n" + err.msg);
        return;
      }
      let index = configFile.toUpperCase().indexOf("</ROOT");
      if (index < 0)
        this.gotoPanel(this.CONNECTIONERROR, "Installation failed\n\nunable to find ROOT closing tag in provided config file");
      configFile = configFile.substring(0, index) + "</ROOT>\n";
      configFile = this.patchConfigFile(configFile);
    }
    let htmlFile = await this.loadLocalFile(this._webPageInput);
    if (htmlFile != null) {
      let err = new YErrorMsg();
      if (!this.checkHTMLfile(htmlFile, err)) {
        this.gotoPanel(this.CONNECTIONERROR, "Installation failed\n\n" + err.msg);
        return;
      }
    }
    let status;
    let GZ_data;
    let success;
    let readonly = this._useReadOnlyInput.checked;
    let minified = !this._useFullVersionInput.checked;
    let mustInstallJsCode = this._plannedaction == this.ACTIONINSTALL;
    if (this._plannedaction == this.ACTIONADDINSTANCE) {
      mustInstallJsCode = true;
      for (let i = 0; i < this._jsCodeinstances.length; i++) {
        if (this._jsCodeinstances[i].minified == minified && this._jsCodeinstances[i].readonly == readonly) {
          mustInstallJsCode = false;
        }
      }
    }
    if (mustInstallJsCode)
      await this.copyJsCode(log, readonly, minified);
    status = log("Creating HTML file..");
    let targetHTMLfile;
    if (htmlFile != null) {
      let index = htmlFile.toUpperCase().indexOf("</BODY>");
      let tag = htmlFile.substr(index, 7);
      targetHTMLfile = htmlFile.replace(tag, tag + this.getSeedCode(configFile, readonly, minified));
    } else {
      targetHTMLfile = this.defaultHTMLfile(configFile, readonly, minified);
    }
    status = log("Compressing  HTML file..");
    GZ_data = Pako_Deflate.gzip(YAPI.imm_str2bin(targetHTMLfile), {level: 9});
    status.innerText = "done.";
    status = log("Saving HTML file on hub");
    let targetFile = this._fileprefixInput.value + this.TARGETEXTENSION;
    status.innerText = "0%";
    success = await this.uploadWidthProgress(targetFile + ".gz", GZ_data, (curr, total) => {
      status.innerText = Math.round(100 * curr / total).toString() + "%";
    });
    if (success != YAPI_SUCCESS)
      throw "Upload failed (Error" + success.toString() + ")";
    status.innerText = "done.";
    status = log("Configuring hub");
    let url = this._currentHubLink_protocol + "://" + this._applicationURL;
    let network = await YNetwork.FindNetwork(await this._currentHub.get_serialNumber() + ".network");
    if (this._makeDefaultInput.checked) {
      await network.set_defaultPage(targetFile);
    } else {
      if (await network.get_defaultPage() == targetFile)
        await network.set_defaultPage("");
      url += "/" + targetFile;
    }
    let warning = "";
    if (readonly && configFile == null)
      warning = "However, since you chose to install the read-only version without any configuration file, your install is probably useless.";
    await YAPI.UnregisterHub(await this._currentHub.get_url());
    status.innerText = "done.";
    this._warning = warning;
    this._finalURL = url;
    setTimeout(() => {
      this.gotoPanel(this.DONEPANEL);
    }, 2e3);
  }
  removeAllChilds(element) {
    while (element.firstChild) {
      element.removeChild(element.firstChild);
    }
  }
  async showConfirmUninstallPanel(visible, goingback) {
    if (!visible) {
      if (this._confirmUninstallPanel != null)
        this._confirmUninstallPanel.style.display = "none";
      return;
    }
    if (this._confirmUninstallPanel == null) {
      this._confirmUninstallPanel = this.createNewContentDiv();
      this._container.appendChild(this._confirmUninstallPanel);
    }
    if (!goingback) {
      this.removeAllChilds(this._confirmUninstallPanel);
      let p = document.createElement("P");
      p.innerText = "You are about to remove all files related to Yocto-Visualization (for web)  from hub " + this._currentHub_Addr + ", including instances that probably took you quite some time to configure. Are you sure you want to click on Next and start uninstallation? You will not be able to revert this operation.\n\n";
      this._confirmUninstallPanel.appendChild(p);
      this._confirmUninstall = document.createElement("input");
      this._confirmUninstall.type = "checkbox";
      let bt = this._nextButton;
      this._confirmUninstall.addEventListener("change", function() {
        bt.enabled = this.checked;
      });
      this._confirmUninstallPanel.appendChild(this._confirmUninstall);
      let txt = document.createElement("span");
      txt.innerText = "Yes, I know what I am doing.";
      this._confirmUninstallPanel.appendChild(txt);
    }
    this._confirmUninstallPanel.style.display = "";
    this._nextButton.visible = true;
    this._nextButton.enabled = this._confirmUninstall.checked;
    this._prevButton.visible = true;
    this._cancelButton.visible = this.DEFAULTCANCELABLE;
    let tabIndex = 1;
    this._confirmUninstall.tabIndex = tabIndex++;
    this._prevButton.tabIndex = tabIndex++;
    this._nextButton.tabIndex = tabIndex++;
    this._confirmUninstall.focus();
  }
  async showDonePanel(visible, goingback) {
    if (!visible) {
      if (this._donePanel != null)
        this._donePanel.style.display = "none";
      return;
    }
    if (this._donePanel == null) {
      this._donePanel = this.createNewContentDiv();
      let Table = document.createElement("TABLE");
      let Row = document.createElement("TR");
      let TD1 = document.createElement("TD");
      TD1.style.whiteSpace = "normal";
      TD1.innerHTML = ressources.OkIcon("64", true, false, false, false, "youpi!");
      Row.appendChild(TD1);
      this._doneMsgContainer = document.createElement("TD");
      Row.appendChild(this._doneMsgContainer);
      Table.appendChild(Row);
      this._donePanel.appendChild(Table);
      this._container.appendChild(this._donePanel);
    }
    this.removeAllChilds(this._doneMsgContainer);
    let p = document.createElement("P");
    p.style.whiteSpace = "normal";
    switch (this._plannedaction) {
      case this.ACTIONADDINSTANCE:
      case this.ACTIONINSTALL:
        p.innerText = this._plannedaction == this.ACTIONINSTALL ? "Installation sucessfully completed. Application can be accessed through the following URL:" : "New instance sucessfully completed, it can be accessed through the following URL:";
        this._doneMsgContainer.appendChild(p);
        let url = document.createElement("A");
        url.innerText = this._finalURL;
        url.style.cursor = "pointer";
        url.style.color = "#0000EE";
        url.style.textDecoration = "underline";
        url.addEventListener("click", () => {
          if (top)
            top.location.assign(this._finalURL);
        });
        this._doneMsgContainer.appendChild(url);
        if (this._warning != "") {
          p = document.createElement("P");
          p.innerText = this._warning;
          this._doneMsgContainer.appendChild(p);
        }
        break;
      case this.ACTIONUNINSTALL:
        p.innerText = "Files sucessfully removed.";
        this._doneMsgContainer.appendChild(p);
        break;
      case this.ACTIONUPDATE:
        p.innerText = "JS Files sucessfully updated.";
        this._doneMsgContainer.appendChild(p);
        break;
      case this.ACTIONMODINSTANCE:
        p.innerText = "Instances modifications done";
        this._doneMsgContainer.appendChild(p);
        break;
    }
    p = document.createElement("P");
    this._cancelButton.visible = this.DEFAULTCANCELABLE;
    p.innerText = this.DEFAULTCANCELABLE ? 'Click on the "Ok" button to close the wizard' : 'Click on the "Ok" button to restart the wizard';
    this._doneMsgContainer.appendChild(p);
    this.removeCurrentPanelFromHistory();
    this._nextButton.visible = false;
    this._prevButton.visible = false;
    this._cancelButton.visible = false;
    this._okButton.visible = true;
    this._donePanel.style.display = "";
    let tabIndex = 1;
    this._okButton.tabIndex = tabIndex++;
    this._okButton.focus();
  }
  showCurrentStep(back, msg) {
    this.showWelcomePanel(this._currentStep == this.WELCOMEPANEL, back);
    this.showEnterHubAddr(this._currentStep == this.ENTERHUBADDR, back);
    this.showConnectingPanel(this._currentStep == this.CONNECTINGPANEL, back);
    this.showConnectionError(this._currentStep == this.CONNECTIONERROR, back, msg);
    this.showPasswordPanel(this._currentStep == this.PASSWORDPANEL, back, msg);
    this.showHubDescription(this._currentStep == this.DESCRIPTIONPANEL, back);
    this.showCustomFilesPanel(this._currentStep == this.CUSTOMFILESPANEL, back);
    this.showOptionsPanel(this._currentStep == this.OPTIONSPANEL, back);
    this.showRunPanel(this._currentStep == this.RUNPANEL, back);
    this.showDonePanel(this._currentStep == this.DONEPANEL, back);
    this.showModifyInstallPanel(this._currentStep == this.MODIFYINSTALLPANEL, back);
    this.showConfirmUninstallPanel(this._currentStep == this.CONFIRMUNINSTALLPANEL, back);
    this.showModInstancesPanel(this._currentStep == this.MODINSTANCESPANEL, back);
  }
  gotoPrevious() {
    if (this._history.length > 1) {
      this._history.pop();
      this._currentStep = this._history[this._history.length - 1];
    }
    this.showCurrentStep(true);
  }
  gotoPanel(step, errmsg) {
    this._currentStep = step;
    this._prevButton.visible = step > 0;
    this._history.push(step);
    this.showCurrentStep(false, errmsg);
  }
  async resetAll() {
    this._currentStep = this.WELCOMEPANEL;
    this._history = [this.WELCOMEPANEL];
    this._alreadyInstalled = false;
    this._prevButton.visible = false;
    this._nextButton.visible = true;
    this._okButton.visible = false;
    this._cancelButton.visible = this.DEFAULTCANCELABLE;
    this._jsCodeinstances = [];
    this._webPageinstances = [];
    await YAPI.UnregisterHub(await this._currentHub.get_url());
    await YAPI.FreeAPI();
    this._currentHub = null;
    this.showCurrentStep(false);
  }
  gotoNext() {
    switch (this._currentStep) {
      case this.WELCOMEPANEL:
        this.gotoPanel(this.ENTERHUBADDR);
        break;
      case this.ENTERHUBADDR:
        this.gotoPanel(this.CONNECTINGPANEL);
        break;
      case this.PASSWORDPANEL:
        this.gotoPanel(this.CONNECTINGPANEL);
        break;
      case this.DESCRIPTIONPANEL:
        if (this._alreadyInstalled) {
          this.gotoPanel(this.MODIFYINSTALLPANEL);
        } else {
          this._plannedaction = this.ACTIONINSTALL;
          this.gotoPanel(this.CUSTOMFILESPANEL);
        }
        break;
      case this.CUSTOMFILESPANEL:
        this.gotoPanel(this.OPTIONSPANEL);
        break;
      case this.OPTIONSPANEL:
        this.gotoPanel(this.RUNPANEL);
        break;
      case this.MODIFYINSTALLPANEL:
        if (this._uninstallOpt.checked)
          this.gotoPanel(this.CONFIRMUNINSTALLPANEL);
        if (this._addInstanceOpt.checked) {
          this._plannedaction = this.ACTIONADDINSTANCE;
          this.gotoPanel(this.CUSTOMFILESPANEL);
        }
        if (this._updateOpt.checked) {
          this._plannedaction = this.ACTIONUPDATE;
          this.gotoPanel(this.RUNPANEL);
        }
        if (this._modInstanceOpt.checked) {
          this._plannedaction = this.ACTIONMODINSTANCE;
          this.gotoPanel(this.MODINSTANCESPANEL);
        }
        break;
      case this.MODINSTANCESPANEL:
        this.gotoPanel(this.RUNPANEL);
        break;
      case this.CONFIRMUNINSTALLPANEL:
        this._plannedaction = this.ACTIONUNINSTALL;
        this.gotoPanel(this.RUNPANEL);
        break;
    }
  }
};
YV4W_installer.HTTP = "http";
YV4W_installer.HTTPS = "https";
window.startYV4W_installer = (div, options) => {
  new YV4W_installer(div, options);
};
export {
  YV4W_installer
};
//# sourceMappingURL=yv4w-installer.js.map
