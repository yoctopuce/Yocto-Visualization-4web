/* Yocto-Visualization-4web installer (version 1.10.58391) - www.yoctopuce.com */
// obj/full/Renderer/YDataRendererCommon.js
var Vector3 = class {
  constructor(a, b, c) {
    this.a = a;
    this.b = b;
    this.c = c;
  }
  static FromXYCoord(x, y) {
    return new Vector3(x, y, 1);
  }
  multiplyByM(m) {
    return new Vector3(m.a * this.a + m.b * this.b + m.c * this.c, m.d * this.a + m.e * this.b + m.f * this.c, m.g * this.a + m.h * this.b + m.i * this.c);
  }
  multiplyByN(n) {
    return new Vector3(this.a * n, this.b * n, this.c * n);
  }
  AddV(v) {
    return new Vector3(this.a + v.a, this.b + v.b, this.c + v.c);
  }
  SubstractV(v) {
    return new Vector3(this.a - v.a, this.b - v.b, this.c - v.c);
  }
  toPointF() {
    return new PointF(this.a, this.b);
  }
  toPoint() {
    return new Point(this.a, this.b);
  }
};
var Matrix3x3 = class {
  constructor(a, b, c, d, e, f, g, h, i, flags) {
    this.a = a;
    this.b = b;
    this.c = c;
    this.d = d;
    this.e = e;
    this.f = f;
    this.g = g;
    this.h = h;
    this.i = i;
    if (b == 0 && d == 0 && a == 1 && e == 1 && i == 1 && g == 0 && h == 0) {
      flags |= Matrix3x3.Flag_TRANSLATION;
      if (c == 0 && f == 0)
        flags |= Matrix3x3.Flag_IDENTITY;
    }
    this.isTranslation = (flags & Matrix3x3.Flag_TRANSLATION) != 0;
    this.isIdentity = (flags & Matrix3x3.Flag_IDENTITY) != 0;
  }
  clone() {
    let flag = 0;
    if (this.isTranslation)
      flag |= Matrix3x3.Flag_TRANSLATION;
    if (this.isIdentity)
      flag |= Matrix3x3.Flag_IDENTITY;
    return new Matrix3x3(this.a, this.b, this.c, this.d, this.e, this.f, this.g, this.h, this.i, flag);
  }
  get determinant() {
    let detA = this.e * this.i - this.h * this.f;
    let detB = this.d * this.i - this.g * this.f;
    let detC = this.d * this.h - this.g * this.e;
    return this.a * detA + -this.b * detB + this.c * detC;
  }
  get transpose() {
    if (this.isIdentity)
      return Matrix3x3.newIdentityMatrix();
    return new Matrix3x3(this.a, this.d, this.g, this.b, this.e, this.h, this.c, this.f, this.i, Matrix3x3.Flag_NONE);
  }
  multiplyByV(v) {
    if (this.isTranslation)
      return new Vector3(this.c + v.a, this.f + v.b, 1);
    return new Vector3(this.a * v.a + this.b * v.b + this.c * v.c, this.d * v.a + this.e * v.b + this.f * v.c, this.g * v.a + this.h * v.b + this.i * v.c);
  }
  static newMatrix(a, b, c, d, e, f, g, h, i) {
    return new Matrix3x3(a, b, c, d, e, f, g, h, i, Matrix3x3.Flag_NONE);
  }
  static newTranslateMatrix(offsetX, offsetY) {
    let flag = Matrix3x3.Flag_TRANSLATION;
    if (offsetX == 0 && offsetY == 0)
      flag |= Matrix3x3.Flag_IDENTITY;
    return new Matrix3x3(1, 0, offsetX, 0, 1, offsetY, 0, 0, 1, flag);
  }
  static newRotateMatrix(AngleDeg) {
    AngleDeg = Math.PI * AngleDeg / 180;
    return new Matrix3x3(Math.cos(AngleDeg), -Math.sin(AngleDeg), 0, Math.sin(AngleDeg), -Math.cos(AngleDeg), 0, 0, 0, 1, Matrix3x3.Flag_NONE);
  }
  static newScaleMatrix(Coef) {
    return new Matrix3x3(Coef, 0, 0, 0, Coef, 0, 0, 0, 1, Matrix3x3.Flag_NONE);
  }
  static newIdentityMatrix() {
    return new Matrix3x3(1, 0, 0, 0, 1, 0, 0, 0, 1, Matrix3x3.Flag_IDENTITY | Matrix3x3.Flag_TRANSLATION);
  }
  toCSS() {
    return "matrix(" + this.a.toString() + "," + this.d.toString() + "," + this.b.toString() + "," + this.e.toString() + "," + this.c.toString() + "," + this.f.toString() + ")";
  }
  toString() {
    return "| " + this.a.toFixed(2) + " " + this.b.toFixed(2) + " " + this.c.toFixed(2) + " |" + (this.isIdentity ? " I" : "") + "\n| " + this.d.toFixed(2) + " " + this.e.toFixed(2) + " " + this.f.toFixed(2) + " |" + (this.isTranslation ? " T" : "") + "\n| " + this.g.toFixed(2) + " " + this.g.toFixed(2) + " " + this.i.toFixed(2) + " |\n";
  }
  multiplyByM(m) {
    if (this.isIdentity)
      return m.clone();
    if (m.isIdentity)
      return this.clone();
    if (this.isTranslation && m.isTranslation)
      return Matrix3x3.newTranslateMatrix(this.c + m.c, this.f + m.f);
    return new Matrix3x3(this.a * m.a + this.b * m.d + this.c * m.g, this.a * m.b + this.b * m.e + this.c * m.h, this.a * m.c + this.b * m.f + this.c * m.i, this.d * m.a + this.e * m.d + this.f * m.g, this.d * m.b + this.e * m.e + this.f * m.h, this.d * m.c + this.e * m.f + this.f * m.i, this.g * m.a + this.h * m.d + this.i * m.g, this.g * m.b + this.h * m.e + this.i * m.h, this.g * m.c + this.h * m.f + this.i * m.i, Matrix3x3.Flag_NONE);
  }
  get inverse() {
    if (this.isIdentity)
      return Matrix3x3.newIdentityMatrix();
    if (this.isTranslation)
      return Matrix3x3.newTranslateMatrix(-this.c, -this.f);
    let det = this.determinant;
    if (det == 0)
      throw "matrix cannot be inverted";
    let detA = this.e * this.i - this.f * this.h;
    let detB = this.b * this.i - this.c * this.h;
    let detC = this.b * this.f - this.c * this.e;
    let detD = this.d * this.i - this.f * this.g;
    let detE = this.a * this.i - this.c * this.g;
    let detF = this.a * this.f - this.c * this.d;
    let detG = this.d * this.h - this.e * this.g;
    let detH = this.a * this.h - this.b * this.g;
    let detI = this.a * this.e - this.b * this.d;
    return new Matrix3x3(detA / det, -detB / det, detC / det, -detD / det, detE / det, -detF / det, detG / det, -detH / det, detI / det, Matrix3x3.Flag_NONE);
  }
  log() {
    console.log(this.toString());
  }
};
Matrix3x3.Flag_NONE = 0;
Matrix3x3.Flag_IDENTITY = 1;
Matrix3x3.Flag_TRANSLATION = 2;
var YEnum = class {
  static fromString(container, value) {
    let p = Object.getOwnPropertyNames(container);
    for (let i = 0; i < p.length; i++) {
      if (p[i] == value)
        return container[value];
    }
    throw "YEnum" + value + " is not a " + container + " value";
  }
  static siblings(container) {
    let res = [];
    let p = Object.getOwnPropertyNames(container);
    for (let i = 0; i < p.length; i++) {
      if (container[p[i]] instanceof YEnumItem) {
        res.push(container[p[i]]);
      }
    }
    return res;
  }
};
var YEnumItem = class {
  constructor(value, humanreadable, container) {
    this._value = value;
    this._container = container;
    this._humanreadable = humanreadable;
  }
  fromString(value) {
    return YEnum.fromString(this._container, value);
  }
  get toString() {
    return this._value.toString();
  }
  get description() {
    return this._humanreadable;
  }
  get sibblings() {
    return YEnum.siblings(this._container);
  }
};
var ViewPortSettings = class {
  constructor() {
    this.IRLx = 0;
    this.IRLy = 0;
    this.zoomx = 0;
    this.zoomy = 0;
    this.Lmargin = 0;
    this.Rmargin = 0;
    this.Tmargin = 0;
    this.Bmargin = 0;
    this.Width = 0;
    this.Height = 0;
    this.Capture = false;
    this.IRLCaptureStartX = 0;
    this.CaptureStartY = 0;
    this.OriginalXAxisMin = 0;
    this.OriginalXAxisMax = 0;
    this.OriginalIRLx = 0;
    this.OriginalLmargin = 0;
    this.OriginalZoomx = 0;
  }
};
var YFont = class {
  get userData() {
    return this._userData;
  }
  set userData(value) {
    this._userData = value;
  }
  get directParent() {
    return this._directParent;
  }
  constructor(parentRenderer, directParent, size, fontChangeCallback) {
    this._userData = null;
    this._fontChangeCallback = null;
    this._name = "Arial";
    this._italic = false;
    this._bold = false;
    this._color = YColor.Black;
    this._alternateColor = null;
    this._font = null;
    this._brush = new YSolidBrush(YColor.Black);
    this._parentRenderer = parentRenderer;
    this._directParent = directParent;
    this._fontChangeCallback = fontChangeCallback ? fontChangeCallback : null;
    this._size = new Proportional(size ? size : 10, Proportional.ResizeRule.FIXED, parentRenderer, this, this.ResetFont);
  }
  ResetFont(source) {
    this._font = null;
    if (source != null)
      this._parentRenderer.ProportionnalValueChanged(source);
  }
  get name() {
    return this._name;
  }
  set name(value) {
    this._name = value;
    this.ResetFont(null);
    this._parentRenderer.redraw();
  }
  get hasChanged() {
    return this._font == null;
  }
  get size() {
    return this._size.value;
  }
  set size(value) {
    if (value <= 0)
      throw new RangeError("Size must be a positive value");
    value = Math.round(100 * value) / 100;
    this._size.value = value;
    this.ResetFont(null);
    if (this._fontChangeCallback != null)
      this._fontChangeCallback(this);
    this._parentRenderer.redraw();
  }
  get italic() {
    return this._italic;
  }
  set italic(value) {
    if (this._italic != value) {
      this._italic = value;
      this.ResetFont(null);
      this._parentRenderer.redraw();
    }
  }
  get bold() {
    return this._bold;
  }
  set bold(value) {
    if (this._bold != value) {
      this._bold = value;
      this.ResetFont(null);
      this._parentRenderer.redraw();
    }
  }
  get color() {
    return this._color;
  }
  set color(value) {
    if (this._color != value) {
      this._color = value;
      this._brush = null;
      this._parentRenderer.redraw();
    }
  }
  get alternateColor() {
    return this._alternateColor;
  }
  set alternateColor(value) {
    if (this._alternateColor != value) {
      this._alternateColor = value;
      this._brush = null;
      this._parentRenderer.redraw();
    }
  }
  get fontObject() {
    return this._name ? this._name : "Arial";
  }
  get brush() {
    if (this._brush == null)
      this._brush = new YSolidBrush(this._alternateColor != null ? this._alternateColor : this._color);
    return this._brush;
  }
  get sizeInPoints() {
    return this._size.value * 0.75;
  }
  get sizeForCanvas() {
    return this._size.value * 1.15;
  }
  get htmlCode() {
    return (this._italic ? "italic " : "") + (this._bold ? "bold " : "") + this.sizeForCanvas.toString() + "px " + this._name;
  }
};
var YSizeF = class {
  constructor(font, st) {
    this._w = 0;
    this._h = 0;
    this._lines = [];
    this._linesCount = 0;
    this._lineHeight = 0;
    this._firstlineHeight = 0;
    if (font != null) {
      this._lineHeight = font.size * 1.25;
      this._firstlineHeight = this._lineHeight * 0.75;
      if (st.indexOf("\n") < 0) {
        this._lines = [st];
        this._linesCount = 1;
      } else {
        this._lines = st.split("\n");
        this._linesCount = this._lines.length;
      }
    }
  }
  get lines() {
    return this._lines;
  }
  get linesCount() {
    return this._linesCount;
  }
  get firstLineHeight() {
    return this._firstlineHeight;
  }
  get lineHeight() {
    return this._lineHeight;
  }
  get height() {
    return this._h;
  }
  get width() {
    return this._w;
  }
  set width(value) {
    this._w = value;
  }
  set height(value) {
    this._h = value;
  }
};
var YTextRenderingHint = class {
  constructor(value) {
    this._value = 0;
    this._value = value;
  }
};
YTextRenderingHint.SystemDefault = new YTextRenderingHint(0);
YTextRenderingHint.SingleBitPerPixelGridFit = new YTextRenderingHint(1);
YTextRenderingHint.SingleBitPerPixel = new YTextRenderingHint(2);
YTextRenderingHint.AntiAliasGridFit = new YTextRenderingHint(3);
YTextRenderingHint.AntiAlias = new YTextRenderingHint(4);
YTextRenderingHint.ClearTypeGridFit = new YTextRenderingHint(5);
var YSmoothingMode = class {
  constructor(value) {
    this._value = 0;
    this._value = value;
  }
};
YSmoothingMode.Invalid = new YSmoothingMode(-1);
YSmoothingMode.Default = new YSmoothingMode(0);
YSmoothingMode.HighSpeed = new YSmoothingMode(1);
YSmoothingMode.HighQuality = new YSmoothingMode(2);
YSmoothingMode.None = new YSmoothingMode(3);
YSmoothingMode.AntiAlias = new YSmoothingMode(4);
var YStringBuilder = class {
  constructor() {
    this._str = "";
  }
  AppendLine(s) {
    this._str += s + "\n";
  }
  Append(s) {
    this._str += s;
  }
  get contents() {
    return this._str;
  }
};
var YStringFormat = class {
  get Alignment() {
    return this._Alignment;
  }
  set Alignment(value) {
    this._Alignment = value;
  }
  get LineAlignment() {
    return this._LineAlignment;
  }
  set LineAlignment(value) {
    this._LineAlignment = value;
  }
  get FormatFlags() {
    return this._formatFlags;
  }
  set FormatFlags(value) {
    this._formatFlags = value;
  }
  get Trimming() {
    return this._Trimming;
  }
  set Trimming(value) {
    this._Trimming = value;
  }
  constructor(clip) {
    this._Alignment = 0;
    this._LineAlignment = 0;
    this._formatFlags = 0;
    this._Trimming = 0;
    this._clip = 16384;
    this._clip = clip;
  }
};
var YColor = class {
  get name() {
    return this._name;
  }
  set predefname(value) {
    this._name = value;
  }
  static get predefinedColors() {
    if (YColor._predefinedColors == null) {
      YColor._predefinedColors = {};
      let names = Object.getOwnPropertyNames(YColor);
      for (let i = 0; i < names.length; i++) {
        if (YColor[names[i]] instanceof YColor) {
          YColor._predefinedColors[names[i]] = YColor[names[i]];
          YColor._predefinedColors[names[i]].predefname = names[i];
        }
      }
    }
    return YColor._predefinedColors;
  }
  static FromString(value) {
    let valueUpper = value.toUpperCase();
    let propNames = Object.getOwnPropertyNames(YColor);
    for (let i = 0; i < propNames.length; i++) {
      if (propNames[i].toUpperCase() == valueUpper) {
        if (YColor[propNames[i]] instanceof YColor) {
          return YColor[propNames[i]];
        }
      }
    }
    if (value.length == 7 && value.substr(0, 1).toUpperCase() == "#") {
      let r = parseInt(value.substr(1, 2), 16);
      let g = parseInt(value.substr(3, 2), 16);
      let b = parseInt(value.substr(5, 2), 16);
      return new YColor(false, 255, r, g, b);
    }
    if (value.length == 12) {
      if (value.substr(0, 4).toUpperCase() == "RGB:") {
        let alpha = parseInt(value.substr(4, 2), 16);
        let r = parseInt(value.substr(6, 2), 16);
        let g = parseInt(value.substr(8, 2), 16);
        let b = parseInt(value.substr(10, 2), 16);
        return new YColor(false, alpha, r, g, b);
      } else if (value.substr(0, 4).toUpperCase() == "HSL:") {
        let alpha = parseInt(value.substr(4, 2), 16);
        let h = parseInt(value.substr(6, 2), 16);
        let s = parseInt(value.substr(8, 2), 16);
        let l = parseInt(value.substr(10, 2), 16);
        return new YColor(true, alpha, h, s, l);
      }
    }
    return null;
  }
  static hex(v) {
    let s = v.toString(16);
    if (s.length <= 1)
      return "0" + s;
    return s;
  }
  toString() {
    if (this.isHSLColor) {
      return "HSL:" + (YColor.hex(this.transparency) + YColor.hex(this.h) + YColor.hex(this.s) + YColor.hex(this.l)).toUpperCase();
    } else {
      let propNames = Object.getOwnPropertyNames(YColor);
      for (let i = 0; i < propNames.length; i++) {
        let o = Reflect.get(YColor, propNames[i]);
        let c = o;
        if (c.alpha == this.alpha && c.red == this.red && c.green == this.green && c.blue == this.blue)
          return propNames[i];
      }
    }
    return "RGB:" + (YColor.hex(this.transparency) + YColor.hex(this.r) + YColor.hex(this.g) + YColor.hex(this.b)).toUpperCase();
  }
  get svgCode() {
    return "rgb(" + this.r.toString() + ", " + this.g.toString() + ", " + this.b.toString() + ")";
  }
  get alphaCode() {
    return (this.transparency / 255).toFixed(3);
  }
  static hsl2rgbInt(temp1, temp2, temp3) {
    if (temp3 >= 170)
      return (temp1 + 127) / 255 >> 0;
    if (temp3 > 42) {
      if (temp3 <= 127)
        return (temp2 + 127) / 255 >> 0;
      temp3 = 170 - temp3;
    }
    return (temp1 * 255 + (temp2 - temp1) * (6 * temp3) + 32512) / 65025 >> 0;
  }
  hsl2rgb() {
    let temp1;
    let temp2;
    let temp3;
    this.rgbConvertionDone = true;
    if (this.s == 0) {
      this.r = this.l;
      this.g = this.l;
      this.b = this.l;
      return;
    }
    if (this.l <= 127) {
      temp2 = this.l * (255 + this.s);
    } else {
      temp2 = (this.l + this.s) * 255 - this.l * this.s;
    }
    temp1 = 510 * this.l - temp2;
    temp3 = this.h + 85;
    if (temp3 > 255)
      temp3 = temp3 - 255;
    this.r = YColor.hsl2rgbInt(temp1, temp2, temp3);
    temp3 = this.h;
    if (temp3 > 255)
      temp3 = temp3 - 255;
    this.g = YColor.hsl2rgbInt(temp1, temp2, temp3);
    if (this.h >= 85) {
      temp3 = this.h - 85;
    } else {
      temp3 = this.h + 170;
    }
    this.b = YColor.hsl2rgbInt(temp1, temp2, temp3);
    if (this.r > 255)
      this.r = 255;
    if (this.g > 255)
      this.g = 255;
    if (this.b > 255)
      this.b = 255;
  }
  computeHSL() {
    let R = this.r;
    let G = this.g;
    let B = this.b;
    let H;
    let S;
    let L;
    let max = R > G ? R : G;
    let min = R < G ? R : G;
    let correction = 0;
    let divisor = 0;
    this.hslConvertionDone = true;
    if (B > max)
      max = B;
    if (B < min)
      min = B;
    L = (max + min + 1) / 2 >> 0;
    if (max == min) {
      this.h = 0;
      this.s = 0;
      this.l = L;
      return;
    }
    correction = (max + min) / 2 >> 0;
    if (L <= 127) {
      S = (255 * (max - min) + correction) / (max + min) >> 0;
    } else {
      S = (255 * (max - min) + 255 - correction) / (510 - (max + min)) >> 0;
    }
    correction = 3 * (max - min);
    divisor = 2 * correction;
    if (R == max) {
      H = 0;
      R = G;
      G = B;
    } else if (G == max) {
      H = 85;
      G = R;
      R = B;
    } else {
      H = 170;
    }
    if (R >= G) {
      H += (255 * (R - G) + correction) / divisor >> 0;
    } else {
      H += 255 - (255 * (G - R) - correction) / divisor >> 0;
    }
    if (H > 255)
      H -= 255;
    if (S > 255)
      S = 255;
    if (L > 255)
      L = 255;
    this.h = H;
    this.s = S;
    this.l = L;
  }
  get hue() {
    if (!this.hslConvertionDone)
      this.computeHSL();
    return this.h;
  }
  get saturation() {
    if (!this.hslConvertionDone)
      this.computeHSL();
    return this.s;
  }
  get luminosity() {
    if (!this.hslConvertionDone)
      this.computeHSL();
    return this.l;
  }
  get red() {
    if (!this.rgbConvertionDone)
      this.hsl2rgb();
    return this.r;
  }
  get green() {
    if (!this.rgbConvertionDone)
      this.hsl2rgb();
    return this.g;
  }
  get blue() {
    if (!this.rgbConvertionDone)
      this.hsl2rgb();
    return this.b;
  }
  get alpha() {
    return this.transparency;
  }
  static FromArgb(a, r, g, b) {
    return new YColor(false, a, r, g, b);
  }
  static FromAhsl(a, h, s, l) {
    return new YColor(true, a, h, s, l);
  }
  get isHSL() {
    return this.isHSLColor;
  }
  get isRGB() {
    return !this.isHSLColor;
  }
  equal(c) {
    if (this.isHSLColor) {
      if (!c.isHSLColor)
        return false;
      if (c.hue != this.hue)
        return false;
      if (c.saturation != this.saturation)
        return false;
      if (c.luminosity != this.luminosity)
        return false;
      if (c.alpha != this.alpha)
        return false;
    } else {
      if (c.isHSLColor)
        return false;
      if (c.red != this.red)
        return false;
      if (c.green != this.green)
        return false;
      if (c.blue != this.blue)
        return false;
      if (c.alpha != this.alpha)
        return false;
    }
    return true;
  }
  clone() {
    if (this.isHSLColor)
      return new YColor(true, this.transparency, this.h, this.s, this.l, this.isPredefined);
    return new YColor(false, this.transparency, this.r, this.g, this.b, this.isPredefined);
  }
  get isPredefined() {
    return this._isPredefined;
  }
  constructor(isHsl, transparency, r_h, g_s, b_l, isPredefined) {
    this.hslConvertionDone = false;
    this.rgbConvertionDone = false;
    this.transparency = 0;
    this.r = 0;
    this.g = 0;
    this.b = 0;
    this.h = 0;
    this.s = 0;
    this.l = 0;
    this._name = "";
    this._htmlcode = this.computeHTMLCode();
    this.hslConvertionDone = isHsl;
    this.isHSLColor = isHsl;
    this.transparency = transparency;
    this._isPredefined = isPredefined === true;
    if (isHsl) {
      this.h = r_h;
      this.s = g_s;
      this.l = b_l;
      this.hsl2rgb();
    } else {
      this.r = r_h;
      this.g = g_s;
      this.b = b_l;
      this.rgbConvertionDone = true;
    }
    this._htmlcode = this.computeHTMLCode();
  }
  computeHTMLCode() {
    let a = this.transparency / 255;
    let r = this.r;
    let g = this.g;
    let b = this.b;
    return "rgba(" + r + "," + g + "," + b + "," + a.toFixed(3) + ")";
  }
  get htmlCode() {
    return this._htmlcode;
  }
};
YColor.AliceBlue = new YColor(false, 255, 240, 248, 255, true);
YColor.AntiqueWhite = new YColor(false, 255, 250, 235, 215, true);
YColor.Aqua = new YColor(false, 255, 0, 255, 255, true);
YColor.Aquamarine = new YColor(false, 255, 127, 255, 212, true);
YColor.Azure = new YColor(false, 255, 240, 255, 255, true);
YColor.Beige = new YColor(false, 255, 245, 245, 220, true);
YColor.Bisque = new YColor(false, 255, 255, 228, 196, true);
YColor.Black = new YColor(false, 255, 0, 0, 0, true);
YColor.BlanchedAlmond = new YColor(false, 255, 255, 235, 205, true);
YColor.Blue = new YColor(false, 255, 0, 0, 255, true);
YColor.BlueViolet = new YColor(false, 255, 138, 43, 226, true);
YColor.Brown = new YColor(false, 255, 165, 42, 42, true);
YColor.BurlyWood = new YColor(false, 255, 222, 184, 135, true);
YColor.CadetBlue = new YColor(false, 255, 95, 158, 160, true);
YColor.Chartreuse = new YColor(false, 255, 127, 255, 0, true);
YColor.Chocolate = new YColor(false, 255, 210, 105, 30, true);
YColor.Coral = new YColor(false, 255, 255, 127, 80, true);
YColor.CornflowerBlue = new YColor(false, 255, 100, 149, 237, true);
YColor.Cornsilk = new YColor(false, 255, 255, 248, 220, true);
YColor.Crimson = new YColor(false, 255, 220, 20, 60, true);
YColor.Cyan = new YColor(false, 255, 0, 255, 255, true);
YColor.DarkBlue = new YColor(false, 255, 0, 0, 139, true);
YColor.DarkCyan = new YColor(false, 255, 0, 139, 139, true);
YColor.DarkGoldenrod = new YColor(false, 255, 184, 134, 11, true);
YColor.DarkGray = new YColor(false, 255, 169, 169, 169, true);
YColor.DarkGreen = new YColor(false, 255, 0, 100, 0, true);
YColor.DarkKhaki = new YColor(false, 255, 189, 183, 107, true);
YColor.DarkMagenta = new YColor(false, 255, 139, 0, 139, true);
YColor.DarkOliveGreen = new YColor(false, 255, 85, 107, 47, true);
YColor.DarkOrange = new YColor(false, 255, 255, 140, 0, true);
YColor.DarkOrchid = new YColor(false, 255, 153, 50, 204, true);
YColor.DarkRed = new YColor(false, 255, 139, 0, 0, true);
YColor.DarkSalmon = new YColor(false, 255, 233, 150, 122, true);
YColor.DarkSeaGreen = new YColor(false, 255, 143, 188, 143, true);
YColor.DarkSlateBlue = new YColor(false, 255, 72, 61, 139, true);
YColor.DarkSlateGray = new YColor(false, 255, 47, 79, 79, true);
YColor.DarkTurquoise = new YColor(false, 255, 0, 206, 209, true);
YColor.DarkViolet = new YColor(false, 255, 148, 0, 211, true);
YColor.DeepPink = new YColor(false, 255, 255, 20, 147, true);
YColor.DeepSkyBlue = new YColor(false, 255, 0, 191, 255, true);
YColor.DimGray = new YColor(false, 255, 105, 105, 105, true);
YColor.DodgerBlue = new YColor(false, 255, 30, 144, 255, true);
YColor.Firebrick = new YColor(false, 255, 178, 34, 34, true);
YColor.FloralWhite = new YColor(false, 255, 255, 250, 240, true);
YColor.ForestGreen = new YColor(false, 255, 34, 139, 34, true);
YColor.Fuchsia = new YColor(false, 255, 255, 0, 255, true);
YColor.Gainsboro = new YColor(false, 255, 220, 220, 220, true);
YColor.GhostWhite = new YColor(false, 255, 248, 248, 255, true);
YColor.Gold = new YColor(false, 255, 255, 215, 0, true);
YColor.Goldenrod = new YColor(false, 255, 218, 165, 32, true);
YColor.Gray = new YColor(false, 255, 128, 128, 128, true);
YColor.Green = new YColor(false, 255, 0, 128, 0, true);
YColor.GreenYellow = new YColor(false, 255, 173, 255, 47, true);
YColor.Honeydew = new YColor(false, 255, 240, 255, 240, true);
YColor.HotPink = new YColor(false, 255, 255, 105, 180, true);
YColor.IndianRed = new YColor(false, 255, 205, 92, 92, true);
YColor.Indigo = new YColor(false, 255, 75, 0, 130, true);
YColor.Ivory = new YColor(false, 255, 255, 255, 240, true);
YColor.Khaki = new YColor(false, 255, 240, 230, 140, true);
YColor.Lavender = new YColor(false, 255, 230, 230, 250, true);
YColor.LavenderBlush = new YColor(false, 255, 255, 240, 245, true);
YColor.LawnGreen = new YColor(false, 255, 124, 252, 0, true);
YColor.LemonChiffon = new YColor(false, 255, 255, 250, 205, true);
YColor.LightBlue = new YColor(false, 255, 173, 216, 230, true);
YColor.LightCoral = new YColor(false, 255, 240, 128, 128, true);
YColor.LightCyan = new YColor(false, 255, 224, 255, 255, true);
YColor.LightGoldenrodYellow = new YColor(false, 255, 250, 250, 210, true);
YColor.LightGray = new YColor(false, 255, 211, 211, 211, true);
YColor.LightGreen = new YColor(false, 255, 144, 238, 144, true);
YColor.LightPink = new YColor(false, 255, 255, 182, 193, true);
YColor.LightSalmon = new YColor(false, 255, 255, 160, 122, true);
YColor.LightSeaGreen = new YColor(false, 255, 32, 178, 170, true);
YColor.LightSkyBlue = new YColor(false, 255, 135, 206, 250, true);
YColor.LightSlateGray = new YColor(false, 255, 119, 136, 153, true);
YColor.LightSteelBlue = new YColor(false, 255, 176, 196, 222, true);
YColor.LightYellow = new YColor(false, 255, 255, 255, 224, true);
YColor.Lime = new YColor(false, 255, 0, 255, 0, true);
YColor.LimeGreen = new YColor(false, 255, 50, 205, 50, true);
YColor.Linen = new YColor(false, 255, 250, 240, 230, true);
YColor.Magenta = new YColor(false, 255, 255, 0, 255, true);
YColor.Maroon = new YColor(false, 255, 128, 0, 0, true);
YColor.MediumAquamarine = new YColor(false, 255, 102, 205, 170, true);
YColor.MediumBlue = new YColor(false, 255, 0, 0, 205, true);
YColor.MediumOrchid = new YColor(false, 255, 186, 85, 211, true);
YColor.MediumPurple = new YColor(false, 255, 147, 112, 219, true);
YColor.MediumSeaGreen = new YColor(false, 255, 60, 179, 113, true);
YColor.MediumSlateBlue = new YColor(false, 255, 123, 104, 238, true);
YColor.MediumSpringGreen = new YColor(false, 255, 0, 250, 154, true);
YColor.MediumTurquoise = new YColor(false, 255, 72, 209, 204, true);
YColor.MediumVioletRed = new YColor(false, 255, 199, 21, 133, true);
YColor.MidnightBlue = new YColor(false, 255, 25, 25, 112, true);
YColor.MintCream = new YColor(false, 255, 245, 255, 250, true);
YColor.MistyRose = new YColor(false, 255, 255, 228, 225, true);
YColor.Moccasin = new YColor(false, 255, 255, 228, 181, true);
YColor.NavajoWhite = new YColor(false, 255, 255, 222, 173, true);
YColor.Navy = new YColor(false, 255, 0, 0, 128, true);
YColor.OldLace = new YColor(false, 255, 253, 245, 230, true);
YColor.Olive = new YColor(false, 255, 128, 128, 0, true);
YColor.OliveDrab = new YColor(false, 255, 107, 142, 35, true);
YColor.Orange = new YColor(false, 255, 255, 165, 0, true);
YColor.OrangeRed = new YColor(false, 255, 255, 69, 0, true);
YColor.Orchid = new YColor(false, 255, 218, 112, 214, true);
YColor.PaleGoldenrod = new YColor(false, 255, 238, 232, 170, true);
YColor.PaleGreen = new YColor(false, 255, 152, 251, 152, true);
YColor.PaleTurquoise = new YColor(false, 255, 175, 238, 238, true);
YColor.PaleVioletRed = new YColor(false, 255, 219, 112, 147, true);
YColor.PapayaWhip = new YColor(false, 255, 255, 239, 213, true);
YColor.PeachPuff = new YColor(false, 255, 255, 218, 185, true);
YColor.Peru = new YColor(false, 255, 205, 133, 63, true);
YColor.Pink = new YColor(false, 255, 255, 192, 203, true);
YColor.Plum = new YColor(false, 255, 221, 160, 221, true);
YColor.PowderBlue = new YColor(false, 255, 176, 224, 230, true);
YColor.Purple = new YColor(false, 255, 128, 0, 128, true);
YColor.Red = new YColor(false, 255, 255, 0, 0, true);
YColor.RosyBrown = new YColor(false, 255, 188, 143, 143, true);
YColor.RoyalBlue = new YColor(false, 255, 65, 105, 225, true);
YColor.SaddleBrown = new YColor(false, 255, 139, 69, 19, true);
YColor.Salmon = new YColor(false, 255, 250, 128, 114, true);
YColor.SandyBrown = new YColor(false, 255, 244, 164, 96, true);
YColor.SeaGreen = new YColor(false, 255, 46, 139, 87, true);
YColor.SeaShell = new YColor(false, 255, 255, 245, 238, true);
YColor.Sienna = new YColor(false, 255, 160, 82, 45, true);
YColor.Silver = new YColor(false, 255, 192, 192, 192, true);
YColor.SkyBlue = new YColor(false, 255, 135, 206, 235, true);
YColor.SlateBlue = new YColor(false, 255, 106, 90, 205, true);
YColor.SlateGray = new YColor(false, 255, 112, 128, 144, true);
YColor.Snow = new YColor(false, 255, 255, 250, 250, true);
YColor.SpringGreen = new YColor(false, 255, 0, 255, 127, true);
YColor.SteelBlue = new YColor(false, 255, 70, 130, 180, true);
YColor.Tan = new YColor(false, 255, 210, 180, 140, true);
YColor.Teal = new YColor(false, 255, 0, 128, 128, true);
YColor.Thistle = new YColor(false, 255, 216, 191, 216, true);
YColor.Tomato = new YColor(false, 255, 255, 99, 71, true);
YColor.Transparent = new YColor(false, 0, 255, 255, 255, true);
YColor.Turquoise = new YColor(false, 255, 64, 224, 208, true);
YColor.Violet = new YColor(false, 255, 238, 130, 238, true);
YColor.Wheat = new YColor(false, 255, 245, 222, 179, true);
YColor.White = new YColor(false, 255, 255, 255, 255, true);
YColor.WhiteSmoke = new YColor(false, 255, 245, 245, 245, true);
YColor.Yellow = new YColor(false, 255, 255, 255, 0, true);
YColor.YellowGreen = new YColor(false, 255, 154, 205, 50, true);
YColor._predefinedColors = null;
var YBrush = class {
  constructor(c, disableAntialias) {
    this._noAntiAlias = false;
    this._color = c;
    if (typeof disableAntialias != "undefined") {
      this._noAntiAlias = disableAntialias;
    }
  }
  get noAntiAlias() {
    return this._noAntiAlias;
  }
  get color() {
    return this._color;
  }
};
var YSolidBrush = class extends YBrush {
};
var YLinearGradientBrush = class extends YBrush {
  constructor(c1, c2) {
    super(c1);
    this._color1 = c1;
    this._color2 = c2;
  }
  get color1() {
    return this._color1;
  }
  get color2() {
    return this._color2;
  }
};
var YPen = class {
  constructor(color, thickness, disableAntialias) {
    this._thickness = 1;
    this._color = YColor.Black;
    this._noAntiAlias = false;
    this._startCap = 1;
    this._endCap = 1;
    this._linejoin = YPen.LineJoin.Miter;
    this._thickness = thickness;
    this._color = thickness > 0 ? color : YColor.Transparent;
    if (typeof disableAntialias != "undefined") {
      this._noAntiAlias = disableAntialias;
    }
  }
  get noAntiAlias() {
    return this._noAntiAlias;
  }
  get lineWidth() {
    return this._thickness;
  }
  get strokeStyle() {
    return this._color.htmlCode;
  }
  get color() {
    return this._color;
  }
  set startCap(value) {
    this._startCap = value;
  }
  set endCap(value) {
    this._endCap = value;
  }
  set linejoin(value) {
    this._linejoin = value;
  }
};
(function(YPen2) {
  let LineJoin;
  (function(LineJoin2) {
    LineJoin2[LineJoin2["Miter"] = 0] = "Miter";
    LineJoin2[LineJoin2["Bevel"] = 1] = "Bevel";
    LineJoin2[LineJoin2["Round"] = 2] = "Round";
    LineJoin2[LineJoin2["MiterClipped"] = 3] = "MiterClipped";
  })(LineJoin = YPen2.LineJoin || (YPen2.LineJoin = {}));
})(YPen || (YPen = {}));
var YRectangle = class {
  constructor(x, y, w, h) {
    this.x = x;
    this.y = y;
    this.w = w;
    this.h = h;
  }
};
var Point = class {
  constructor(valueX, valueY) {
    this.X = valueX >> 0;
    this.Y = valueY >> 0;
  }
};
var minMaxPoint = class {
  constructor(valueX1, valueYMIN, valueX2, valueYMAX) {
    this.X1 = valueX1 >> 0;
    this.YMIN = valueYMIN >> 0;
    this.X2 = valueX2 >> 0;
    this.YMAX = valueYMAX >> 0;
  }
};
var PointF = class {
  constructor(valueX, valueY) {
    this.X = valueX;
    this.Y = valueY;
  }
};
var GenericPanel = class {
  get userData() {
    return this._userData;
  }
  set userData(value) {
    this._userData = value;
  }
  get directParent() {
    return this._directParent;
  }
  constructor(parent, directParent) {
    this._userData = null;
    this._enabled = false;
    this._panelTextAlign = GenericPanel.TextAlign.LEFT;
    this._text = "";
    this._bgColor = new YColor(false, 255, 255, 255, 192);
    this._borderColor = YColor.Black;
    this._borderthickness = 1;
    this._padding = 10;
    this._verticalMargin = 10;
    this._horizontalMargin = 10;
    this._bgBrush = null;
    this._pen = null;
    this._font = null;
    this._directParent = directParent;
    this._parentRenderer = parent;
    this._font = new YFont(parent, this, 8, null);
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    if (this._enabled != value) {
      this._enabled = value;
      this._parentRenderer.clearCachedObjects();
      this._parentRenderer.redraw();
    }
  }
  get panelTextAlign() {
    return this._panelTextAlign;
  }
  set panelTextAlign(value) {
    this._panelTextAlign = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get text() {
    return this._text;
  }
  set text(value) {
    this._text = value;
    this._parentRenderer.clearCachedObjects();
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get bgColor() {
    return this._bgColor;
  }
  set bgColor(value) {
    this._bgColor = value;
    this._bgBrush = null;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get borderColor() {
    return this._borderColor;
  }
  set borderColor(value) {
    this._borderColor = value;
    this._pen = null;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get borderthickness() {
    return this._borderthickness;
  }
  set borderthickness(value) {
    if (value < 0)
      throw "Border thickness must be a positive value";
    this._borderthickness = value;
    this._parentRenderer.clearCachedObjects();
    this._pen = null;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get padding() {
    return this._padding;
  }
  set padding(value) {
    if (value < 0)
      throw new RangeError("Padding must be a positive value");
    this._padding = value;
    this._parentRenderer.clearCachedObjects();
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get verticalMargin() {
    return this._verticalMargin;
  }
  set verticalMargin(value) {
    this._verticalMargin = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get horizontalMargin() {
    return this._horizontalMargin;
  }
  set horizontalMargin(value) {
    this._horizontalMargin = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get bgBrush() {
    if (this._bgBrush == null)
      this._bgBrush = new YSolidBrush(this._bgColor);
    return this._bgBrush;
  }
  get pen() {
    if (this._pen == null) {
      this._pen = new YPen(this._borderColor, this._borderthickness, true);
    }
    return this._pen;
  }
  get font() {
    return this._font;
  }
};
(function(GenericPanel2) {
  class HorizontalAlignPosEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, HorizontalAlignPos);
    }
  }
  GenericPanel2.HorizontalAlignPosEnumItem = HorizontalAlignPosEnumItem;
  class HorizontalAlignPos extends YEnum {
  }
  HorizontalAlignPos.LEFT = new HorizontalAlignPosEnumItem("LEFT", "Left");
  HorizontalAlignPos.CENTER = new HorizontalAlignPosEnumItem("CENTER", "Center");
  HorizontalAlignPos.RIGHT = new HorizontalAlignPosEnumItem("RIGHT", "Right");
  GenericPanel2.HorizontalAlignPos = HorizontalAlignPos;
  class VerticalAlignPosEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, VerticalAlignPos);
    }
  }
  GenericPanel2.VerticalAlignPosEnumItem = VerticalAlignPosEnumItem;
  class VerticalAlignPos extends YEnum {
  }
  VerticalAlignPos.TOP = new VerticalAlignPosEnumItem("TOP", "Top");
  VerticalAlignPos.CENTER = new VerticalAlignPosEnumItem("CENTER", "Center");
  VerticalAlignPos.BOTTOM = new VerticalAlignPosEnumItem("BOTTOM", "Bottom");
  GenericPanel2.VerticalAlignPos = VerticalAlignPos;
  class TextAlignEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, TextAlign);
    }
  }
  GenericPanel2.TextAlignEnumItem = TextAlignEnumItem;
  class TextAlign extends YEnum {
  }
  TextAlign.LEFT = new TextAlignEnumItem("LEFT", "Left");
  TextAlign.CENTER = new TextAlignEnumItem("CENTER", "Center");
  TextAlign.RIGHT = new TextAlignEnumItem("RIGHT", "Right");
  GenericPanel2.TextAlign = TextAlign;
})(GenericPanel || (GenericPanel = {}));
var MessagePanel = class extends GenericPanel {
  constructor(parent, directParent) {
    super(parent, directParent);
    this._panelHrzAlign = GenericPanel.HorizontalAlignPos.CENTER;
    this._panelVrtAlign = GenericPanel.VerticalAlignPos.CENTER;
  }
  get panelHrzAlign() {
    return this._panelHrzAlign;
  }
  set panelHrzAlign(value) {
    this._panelHrzAlign = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get panelVrtAlign() {
    return this._panelVrtAlign;
  }
  set panelVrtAlign(value) {
    this._panelVrtAlign = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
};
var AnnotationPanel = class extends GenericPanel {
  constructor(parent, directParent) {
    super(parent, directParent);
    this._overlap = false;
    this._positionOffsetX = 50;
    this._positionOffsetY = 50;
    this._panelHrzAlign = GenericPanel.HorizontalAlignPos.CENTER;
    this._panelVrtAlign = GenericPanel.VerticalAlignPos.TOP;
  }
  get overlap() {
    return this._overlap;
  }
  set overlap(value) {
    if (!value && this._panelHrzAlign == GenericPanel.HorizontalAlignPos.CENTER && this._panelVrtAlign == GenericPanel.VerticalAlignPos.CENTER) {
      this._panelVrtAlign = GenericPanel.VerticalAlignPos.TOP;
    }
    this._overlap = value;
    this._parentRenderer.clearCachedObjects();
    this._parentRenderer.redraw();
  }
  get positionOffsetX() {
    return this._positionOffsetX;
  }
  set positionOffsetX(value) {
    this._positionOffsetX = value;
    this._parentRenderer.clearCachedObjects();
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get positionOffsetY() {
    return this._positionOffsetY;
  }
  set positionOffsetY(value) {
    this._positionOffsetY = value;
    this._parentRenderer.clearCachedObjects();
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get panelHrzAlign() {
    return this._panelHrzAlign;
  }
  set panelHrzAlign(value) {
    if (!this._overlap && value == GenericPanel.HorizontalAlignPos.CENTER && this._panelVrtAlign == GenericPanel.VerticalAlignPos.CENTER) {
      this._panelVrtAlign = GenericPanel.VerticalAlignPos.TOP;
    }
    this._panelHrzAlign = value;
    this._parentRenderer.clearCachedObjects();
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get panelVrtAlign() {
    return this._panelVrtAlign;
  }
  set panelVrtAlign(value) {
    if (!this._overlap && value == GenericPanel.VerticalAlignPos.CENTER && this._panelHrzAlign == GenericPanel.HorizontalAlignPos.CENTER) {
      this._panelHrzAlign = GenericPanel.HorizontalAlignPos.RIGHT;
    }
    this._panelVrtAlign = value;
    this._parentRenderer.clearCachedObjects();
    if (this._enabled)
      this._parentRenderer.redraw();
  }
};
var Zone = class {
  get directParent() {
    return this._directParent;
  }
  get userData() {
    return this._userData;
  }
  set userData(value) {
    this._userData = value;
  }
  resetCache() {
  }
  constructor(parentRenderer, directParent) {
    this._userData = null;
    this._zoneBrush = null;
    this._color = YColor.Red;
    this._visible = false;
    this._min = 0;
    this._max = 100;
    this._directParent = directParent;
    this._parentRenderer = parentRenderer;
  }
  get zoneBrush() {
    if (this._zoneBrush == null)
      this._zoneBrush = new YSolidBrush(this._color);
    return this._zoneBrush;
  }
  get color() {
    return this._color;
  }
  set color(value) {
    this._color = value;
    this._zoneBrush = null;
    if (this.visible)
      this._parentRenderer.redraw();
  }
  get visible() {
    return this._visible;
  }
  set visible(value) {
    this._visible = value;
    this._parentRenderer.redraw();
  }
  set_minMax(min, max) {
    if (min > max)
      throw new RangeError("Min cannot be greater than max ");
    this._min = min;
    this._max = max;
    this.resetCache();
    if (this.visible)
      this._parentRenderer.redraw();
  }
  get min() {
    return this._min;
  }
  set min(value) {
    if (value >= this._max && !YDataRenderer.minMaxCheckDisabled) {
      throw new RangeError("Min cannot be greater than max (" + this._max.toString() + ")");
    }
    this._min = value;
    this.resetCache();
    if (this.visible)
      this._parentRenderer.redraw();
  }
  get max() {
    return this._max;
  }
  set max(value) {
    if (value <= this._min && !YDataRenderer.minMaxCheckDisabled) {
      throw new RangeError("Max cannot be greater than min (" + this._min.toString() + ")");
    }
    this._max = value;
    this.resetCache();
    if (this.visible)
      this._parentRenderer.redraw();
  }
};
var Proportional = class {
  get userData() {
    return this._userData;
  }
  set userData(value) {
    this._userData = value;
  }
  get directParent() {
    return this._directParent;
  }
  get value() {
    return this._value;
  }
  set value(v) {
    this._value = v;
    this.set_refPoint();
    if (this._reset != null)
      this._reset(this);
  }
  get resizeRule() {
    return this._resizeRule;
  }
  set resizeRule(value) {
    this.set_refPoint();
    this._resizeRule = value;
  }
  set_refPoint() {
    this._refWidth = Math.max(1, this._parentRenderer.usableUiWidth());
    this._refHeight = Math.max(1, this._parentRenderer.usableUiHeight());
    this._refValue = this._value;
  }
  constructor(value, resizeRule, parentRenderer, directParent, resetCallBack) {
    this._reset = null;
    this._refWidth = 1;
    this._refHeight = 1;
    this._refValue = 1;
    this.valueStack = [];
    this._resizeRule = Proportional.ResizeRule.FIXED;
    this._userData = null;
    this._reset = resetCallBack;
    this._parentRenderer = parentRenderer;
    this._value = value;
    this._resizeRule = resizeRule;
    this._directParent = directParent;
    this.set_refPoint();
    this._parentRenderer.AddNewProportionalToSizeValue(this);
  }
  containerResizedPushNewCoef(coef) {
    this.valueStack.push(this._value);
    this._value = Math.round(100 * this._refValue * coef) / 100;
    if (this._reset != null)
      this._reset(this);
  }
  containerResizedPop() {
    if (this.valueStack.length <= 0)
      throw new RangeError("Can't pop, empty stack.");
    this._value = this.valueStack.pop();
    if (this._reset != null)
      this._reset(this);
  }
  static resizeCoef(rule, refWidth, refHeight, newWidth, newHeight) {
    switch (rule) {
      case Proportional.ResizeRule.RELATIVETOWIDTH:
        return newWidth / refWidth;
      case Proportional.ResizeRule.RELATIVETOHEIGHT:
        return newHeight / refHeight;
      case Proportional.ResizeRule.RELATIVETOBOTH:
        return Math.min(newHeight / refHeight, newWidth / refWidth);
    }
    return 1;
  }
  containerResized(newWidth, newHeight) {
    this._value = Math.round(100 * this._refValue * Proportional.resizeCoef(this._resizeRule, this._refWidth, this._refHeight, newWidth, newHeight)) / 100;
    if (this._reset != null)
      this._reset(this);
  }
  forceChangeCallback() {
    if (this._reset != null)
      this._reset(this);
  }
};
(function(Proportional2) {
  class ResizeRuleEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, ResizeRule);
    }
  }
  Proportional2.ResizeRuleEnumItem = ResizeRuleEnumItem;
  class ResizeRule extends YEnum {
  }
  ResizeRule.FIXED = new ResizeRuleEnumItem("FIXED", "Fixed");
  ResizeRule.RELATIVETOWIDTH = new ResizeRuleEnumItem("RELATIVETOWIDTH", "Relative to Width");
  ResizeRule.RELATIVETOHEIGHT = new ResizeRuleEnumItem("RELATIVETOHEIGHT", "Relative to height");
  ResizeRule.RELATIVETOBOTH = new ResizeRuleEnumItem("RELATIVETOBOTH", "Relative to Width and Height");
  Proportional2.ResizeRule = ResizeRule;
})(Proportional || (Proportional = {}));
var YDataRenderer = class {
  get annotationPanels() {
    return this._annotationPanels;
  }
  get userData() {
    return this._userData;
  }
  static get minMaxCheckDisabled() {
    return YDataRenderer._disableMinMaxCheck;
  }
  static set minMaxCheckDisabled(value) {
    YDataRenderer._disableMinMaxCheck = value;
  }
  resetlegendPens() {
  }
  get getCaptureParameters() {
    return this._getCaptureParameters;
  }
  set getCaptureParameters(value) {
    this._getCaptureParameters = value;
  }
  get messagePanels() {
    return this._messagePanels;
  }
  static globalMouseMove(e) {
    YDataRenderer.globalMouseX = e.pageX;
    YDataRenderer.globalMouseY = e.pageY;
  }
  clearTransformationMatrix() {
    this._Scr2ElmMatrix = null;
    this._Elm2ScrMatrix = null;
  }
  findElementAbsolutePosition(el) {
    let staticFound = false;
    let relativeFound = false;
    let dx = 0;
    let dy = 0;
    while (el != null) {
      let style = window.getComputedStyle(el);
      if (!relativeFound && style.position == "static" && !staticFound) {
        dx = el.offsetLeft + parseFloat(style.borderLeftWidth);
        dy = el.offsetTop + parseFloat(style.borderTopWidth);
        staticFound = true;
      }
      if (style.position == "relative" || style.position == "absolute") {
        dx += el.offsetLeft + parseFloat(style.borderLeftWidth);
        dy += el.offsetTop + parseFloat(style.borderTopWidth);
        relativeFound = true;
      }
      el = el.parentElement;
    }
    return new PointF(dx, dy);
  }
  get Elm2ScrMatrix() {
    if (this._Elm2ScrMatrix == null) {
      let el = this.UIContainer;
      let AsolutePositionsStack = [];
      while (el != null) {
        AsolutePositionsStack.push(this.findElementAbsolutePosition(el));
        el = el.parentElement;
      }
      el = this.UIContainer;
      let MatrixStack = [];
      let staticFound = false;
      let relativeFound = false;
      let index = 0;
      while (el != null) {
        let parent = el.parentElement;
        let style = window.getComputedStyle(el);
        let dx = AsolutePositionsStack[index].X;
        let dy = AsolutePositionsStack[index].Y;
        if (index < AsolutePositionsStack.length - 1) {
          dx -= AsolutePositionsStack[index + 1].X;
          dy -= AsolutePositionsStack[index + 1].Y;
        }
        let matrix = style["transform"];
        if (matrix != "none") {
          let matrixStr = matrix.match(/matrix.*\((.+)\)/)[1].split(", ");
          let matrixValues = [];
          for (let i = 0; i < 6; i++) {
            matrixValues.push(parseFloat(matrixStr[i]));
          }
          let OriginMatrixMatrixBefore = null;
          let TransformMatrix = Matrix3x3.newMatrix(matrixValues[0], matrixValues[2], matrixValues[4], matrixValues[1], matrixValues[3], matrixValues[5], 0, 0, 1);
          let OriginMatrixMatrixAfter = null;
          if (style.transformOrigin) {
            let parts = style.transformOrigin.split(" ");
            let Ox = Number.parseFloat(parts[0]);
            let Oy = Number.parseFloat(parts[1]);
            OriginMatrixMatrixBefore = Matrix3x3.newTranslateMatrix(-Ox, -Oy);
            OriginMatrixMatrixAfter = Matrix3x3.newTranslateMatrix(Ox, Oy);
          }
          if (OriginMatrixMatrixBefore != null)
            MatrixStack.push(OriginMatrixMatrixBefore);
          if (TransformMatrix != null)
            MatrixStack.push(TransformMatrix);
          if (OriginMatrixMatrixAfter != null)
            MatrixStack.push(OriginMatrixMatrixAfter);
        }
        if (dx != 0 || dy != 0)
          MatrixStack.push(Matrix3x3.newTranslateMatrix(dx, dy));
        el = parent;
        index++;
      }
      this._Elm2ScrMatrix = Matrix3x3.newIdentityMatrix();
      for (let i = MatrixStack.length - 1; i >= 0; i--) {
        this._Elm2ScrMatrix = this._Elm2ScrMatrix.multiplyByM(MatrixStack[i]);
      }
    }
    return this._Elm2ScrMatrix;
  }
  get Scr2ElmMatrix() {
    if (this._Scr2ElmMatrix == null) {
      this._Scr2ElmMatrix = this.Elm2ScrMatrix.inverse;
    }
    return this._Scr2ElmMatrix;
  }
  addAnnotationPanel() {
    let p = new AnnotationPanel(this, this);
    this._annotationPanels.push(p);
    this.redraw();
    return p;
  }
  AllowRedraw() {
    this._redrawAllowed--;
    if (this._redrawAllowed < 0)
      throw new RangeError("Too many AllowRedraw calls");
    if (this._redrawAllowed == 0)
      this.redraw();
  }
  AllowRedrawNoRefresh() {
    this._redrawAllowed--;
    if (this._redrawAllowed < 0)
      throw new RangeError("Too many AllowRedraw calls");
  }
  DisableRedraw() {
    this._redrawAllowed++;
  }
  AddNewProportionalToSizeValue(v) {
    if (this.ProportionalToSizeValues.indexOf(v) < 0)
      this.ProportionalToSizeValues.push(v);
  }
  canRedraw() {
    return this._redrawAllowed == 0;
  }
  setPatchAnnotationCallback(callback) {
    this._PatchAnnotationCallback = callback;
  }
  patchAnnotation(text) {
    text = text.replace("\\n", "\n");
    if (text.indexOf("$") < 0)
      return text;
    let now = new Date();
    text = text.replace("$DAY$", now.getDay().toString());
    text = text.replace("$MONTH$", now.getMonth().toString());
    text = text.replace("$YEAR$", now.getFullYear().toString());
    text = text.replace("$HOUR$", now.getHours().toString());
    text = text.replace("$MINUTE$", now.getMinutes().toString());
    text = text.replace("$SECOND$", now.getSeconds().toString());
    if (this._PatchAnnotationCallback != null)
      text = this._PatchAnnotationCallback(text);
    return text;
  }
  mouseLocalPosition() {
    let v = Vector3.FromXYCoord(YDataRenderer.globalMouseX, YDataRenderer.globalMouseY);
    let m = this.Scr2ElmMatrix;
    let p = m.multiplyByV(v).toPoint();
    if (p.X < 0 || p.Y < 0 || p.X > this.UIContainer.offsetWidth || p.Y > this.UIContainer.offsetHeight)
      return null;
    return p;
  }
  set proportionnalValueChangeCallback(value) {
    this._proportionnalValueChangeCallback = value;
  }
  ProportionnalValueChanged(source) {
    if (this._proportionnalValueChangeCallback != null)
      this._proportionnalValueChangeCallback(source);
  }
  getContainerInnerWidth() {
    return this.UIContainer.offsetWidth;
  }
  getContainerInnerHeight() {
    return this.UIContainer.offsetHeight;
  }
  Draw(timestamp) {
    if (!this.canRedraw())
      return 0;
    let w = this.getContainerInnerWidth();
    let h = this.getContainerInnerHeight();
    if (w <= 5 || h <= 5)
      return 0;
    this.DisableRedraw();
    let offscreenCanvas = document.createElement("canvas");
    offscreenCanvas.width = w;
    offscreenCanvas.height = h;
    let g = new YGraphics(offscreenCanvas, w, h, 90);
    let start = performance.now();
    try {
      this.Render(g, w, h);
    } catch (e) {
      debugger;
      this.log("Rendering error: " + e.message);
    }
    let elapsed = performance.now() - start;
    let drawArea = this.UIContainer.getContext("2d");
    drawArea.clearRect(0, 0, w, h);
    drawArea.drawImage(offscreenCanvas, 0, 0);
    this.rendererTimingTotal += elapsed;
    this.rendererTimingCount++;
    let avg = this.rendererTimingTotal / this.rendererTimingCount;
    g.Dispose();
    this.AllowRedrawNoRefresh();
    this.renderingPostProcessing();
    return 0;
  }
  renderingPostProcessing() {
  }
  get resizeRule() {
    return this._resizeRule;
  }
  set resizeRule(value) {
    if (value != this._resizeRule) {
      this.DisableRedraw();
      this._resizeRule = value;
      for (let i = 0; i < this.ProportionalToSizeValues.length; i++) {
        this.ProportionalToSizeValues[i].resizeRule = this._resizeRule;
      }
      this.AllowRedraw();
      this.redraw();
    }
  }
  redraw() {
    if (!(document.visibilityState === "visible"))
      return;
    if (this._redrawAllowed > 0)
      return;
    if (this.getContainerInnerWidth() < 2)
      return;
    if (this.getContainerInnerHeight() < 2)
      return;
    if (this.requestAnimationFrameID != null) {
      window.cancelAnimationFrame(this.requestAnimationFrameID);
    }
    this.requestAnimationFrameID = window.requestAnimationFrame((timestamp) => {
      try {
        this.Draw(timestamp);
      } catch (e) {
        console.log("caught");
        this.requestAnimationFrameID = null;
        throw e;
      }
      this.requestAnimationFrameID = null;
    });
  }
  usableUiWidth() {
    return this.getContainerInnerWidth();
  }
  usableUiHeight() {
    return this.getContainerInnerHeight();
  }
  resetProportionalSizeObjectsCachePush(newcoef) {
    this.clearCachedObjects();
    if (this._resizeRule != Proportional.ResizeRule.FIXED) {
      for (let i = 0; i < this.ProportionalToSizeValues.length; i++) {
        this.ProportionalToSizeValues[i].containerResizedPushNewCoef(newcoef);
      }
    }
  }
  resetProportionalSizeObjectsCachePop() {
    this.clearCachedObjects();
    if (this._resizeRule != Proportional.ResizeRule.FIXED) {
      for (let i = 0; i < this.ProportionalToSizeValues.length; i++) {
        this.ProportionalToSizeValues[i].containerResizedPop();
      }
    }
  }
  resetProportionalSizeObjectsCache(w, h) {
    this.clearCachedObjects();
    if (this._resizeRule != Proportional.ResizeRule.FIXED) {
      for (let i = 0; i < this.ProportionalToSizeValues.length; i++) {
        this.ProportionalToSizeValues[i].containerResized(w, h);
      }
    }
  }
  containerResized() {
    this.containerResize(null, null);
  }
  containerResize(sender, e) {
    this.clearTransformationMatrix();
    this.DisableRedraw();
    this.UIContainer.width = this.UIContainer.offsetWidth;
    this.UIContainer.height = this.UIContainer.offsetHeight;
    this.resetProportionalSizeObjectsCache(this.usableUiWidth(), this.usableUiHeight());
    this.AllowRedraw();
    this.redraw();
  }
  proportionnalsizeReset() {
    this.resetProportionalSizeObjectsCache(this.usableUiWidth(), this.usableUiHeight());
  }
  captureAndDownloadImage(captureType, defaultFilename, captureWidth, captureHeight, captureDPI) {
    let error = "";
    let w;
    let h;
    let ratio = this.getContainerInnerWidth() / this.getContainerInnerHeight();
    if (captureDPI == null)
      captureDPI = 90;
    if (defaultFilename == null || typeof defaultFilename == "undefined") {
      defaultFilename = "capture.";
      if (captureType == YDataRenderer.CaptureType.PNG) {
        defaultFilename = defaultFilename + "png";
      }
      if (captureType == YDataRenderer.CaptureType.SVG) {
        defaultFilename = defaultFilename + "svg";
      }
    }
    if (captureWidth == null || typeof captureWidth == "undefined") {
      w = this.getContainerInnerWidth();
      if (captureHeight == null || typeof captureHeight == "undefined") {
        h = this.getContainerInnerHeight();
      } else {
        h = captureHeight >> 0;
        w = h * ratio >> 0;
      }
    } else {
      w = captureWidth >> 0;
      if (captureHeight == null || typeof captureHeight == "undefined") {
        h = w * ratio >> 0;
      } else {
        h = captureHeight >> 0;
      }
    }
    if (w <= 5 || h <= 5)
      return;
    this.DisableRedraw();
    let DrawArea = document.createElement("canvas");
    DrawArea.width = w;
    DrawArea.height = h;
    let g;
    switch (captureType) {
      case YDataRenderer.CaptureType.PNG:
        g = new YGraphics(DrawArea, w, h, captureDPI);
        break;
      case YDataRenderer.CaptureType.SVG:
        g = new YGraphicsSVG(DrawArea, w, h, captureDPI);
        break;
      default:
        throw new RangeError("capture :unknown type");
    }
    let newCoef = Proportional.resizeCoef(Proportional.ResizeRule.RELATIVETOBOTH, this.refWidth, this.refHeight, w, h);
    this.log("start capture");
    this.resetProportionalSizeObjectsCachePush(newCoef);
    let renderok = false;
    this._snapshotPanel.enabled = false;
    try {
      let t = this.Render(g, w, h);
      renderok = true;
    } catch (e) {
      error = e.message;
      this.log("Render error: " + error);
    }
    this.log("capture completed");
    this.resetProportionalSizeObjectsCachePop();
    if (renderok) {
      let element = document.createElement("a");
      let data = g.get_downloadableData();
      element.setAttribute("href", data);
      element.setAttribute("download", defaultFilename);
      element.style.display = "none";
      document.body.appendChild(element);
      element.click();
      document.body.removeChild(element);
    }
    g.Dispose();
    this.AllowRedraw();
  }
  getFocus(sender, e) {
    this.log("got focus");
  }
  gainFocus() {
  }
  lostFocus(sender, e) {
  }
  get AllowPrintScreenCapture() {
    return this._AllowPrintScreenCapture;
  }
  set AllowPrintScreenCapture(value) {
    this._AllowPrintScreenCapture = value;
  }
  constructor(UIContainer, logFunction) {
    this._redrawAllowed = 1;
    this._refWidth = 1;
    this._refHeight = 1;
    this.rendererTimingTotal = 0;
    this.rendererTimingCount = 0;
    this._PatchAnnotationCallback = null;
    this._logFunction = null;
    this._annotationPanels = [];
    this._userData = null;
    this.documentVisibiltyChangeFct = null;
    this.containerResizedFct = null;
    this._getCaptureParameters = null;
    this.OnDblClick = null;
    this.OnRightClick = null;
    this._messagePanels = [];
    this._Scr2ElmMatrix = null;
    this._Elm2ScrMatrix = null;
    this.ProportionalToSizeValues = [];
    this._proportionnalValueChangeCallback = null;
    this._resizeRule = Proportional.ResizeRule.FIXED;
    this.requestAnimationFrameID = null;
    this._snapshotPanel = null;
    this._snapshotTimer = null;
    this._AllowPrintScreenCapture = false;
    if (!YDataRenderer.globalMouseMoveSet) {
      document.addEventListener("mousemove", (e) => {
        YDataRenderer.globalMouseMove(e);
      });
      YDataRenderer.globalMouseMoveSet = true;
    }
    this.UIContainer = UIContainer;
    this.UIContainer.width = this.getContainerInnerWidth();
    this.UIContainer.height = this.getContainerInnerHeight();
    this._logFunction = logFunction;
    this.parentForm = UIContainer.ownerDocument;
    this._annotationPanels = [];
    this._messagePanels = [];
    this.DisableRedraw();
    this._snapshotPanel = this.addMessagePanel();
    this._snapshotPanel.panelTextAlign = MessagePanel.TextAlign.CENTER;
    this._snapshotPanel.text = "Captured to clipboard";
    this._snapshotPanel.panelHrzAlign = MessagePanel.HorizontalAlignPos.CENTER;
    this._snapshotPanel.panelVrtAlign = MessagePanel.VerticalAlignPos.CENTER;
    this._snapshotPanel.bgColor = new YColor(false, 200, 204, 247, 161);
    this._snapshotPanel.font.size = 16;
    this.AllowRedrawNoRefresh();
    this.containerResizedFct = () => {
      this.containerResize(null, null);
    };
    document.addEventListener("resize", this.containerResizedFct);
    this.resetRefrenceSize();
    this.documentVisibiltyChangeFct = () => {
      if (document.visibilityState === "visible") {
        this.redraw();
      }
    };
    document.addEventListener("visibilitychange", this.documentVisibiltyChangeFct);
  }
  destroy() {
    document.removeEventListener("visibilitychange", this.documentVisibiltyChangeFct);
    document.removeEventListener("resize", this.containerResized);
    this.UIContainer.parentNode.removeChild(this.UIContainer);
    this.UIContainer = null;
    this.parentForm = null;
    this._annotationPanels = null;
    this._messagePanels = null;
    this._Scr2ElmMatrix = null;
    this._Elm2ScrMatrix = null;
  }
  resetRefrenceSize() {
    this._refWidth = this.getContainerInnerWidth();
    this._refHeight = this.getContainerInnerHeight();
  }
  get refWidth() {
    return this._refWidth;
  }
  get refHeight() {
    return this._refHeight;
  }
  RendererCanvas_Click(sender, e) {
  }
  RendererCanvas_DoubleClick(sender, e) {
  }
  addMessagePanel() {
    let p = new MessagePanel(this, this);
    this._messagePanels.push(p);
    return p;
  }
  DrawMessagePanels(g, viewPortWidth, viewPortHeight) {
    for (let i = 0; i < this._messagePanels.length; i++) {
      if (this._messagePanels[i].enabled) {
        let p = this._messagePanels[i];
        let AvailableWidth = viewPortWidth - 2 * p.padding - p.borderthickness;
        if (AvailableWidth < 100)
          AvailableWidth = 100;
        let ssize = null;
        let sizeok = false;
        while (!sizeok) {
          ssize = g.MeasureString(p.text, p.font, AvailableWidth);
          if ((ssize.width >= this.UIContainer.width || ssize.height >= this.UIContainer.height) && p.font.size > 5) {
            p.font.size = Math.round(p.font.size * 9) / 10;
          } else
            sizeok = true;
        }
        if (ssize == null)
          return;
        let panelWidth = ssize.width + 2 * p.padding + p.borderthickness;
        let panelHeight = ssize.height + 2 * p.padding + p.borderthickness;
        let x = 0;
        switch (p.panelHrzAlign) {
          case MessagePanel.HorizontalAlignPos.LEFT:
            x = p.horizontalMargin;
            break;
          case MessagePanel.HorizontalAlignPos.RIGHT:
            x = viewPortWidth - panelWidth - p.horizontalMargin;
            break;
          default:
            x = (viewPortWidth - panelWidth) / 2;
            break;
        }
        let y = 0;
        switch (p.panelVrtAlign) {
          case MessagePanel.VerticalAlignPos.TOP:
            y = p.verticalMargin;
            break;
          case MessagePanel.VerticalAlignPos.BOTTOM:
            y = viewPortHeight - panelHeight - p.verticalMargin;
            break;
          default:
            y = (viewPortHeight - panelHeight) / 2;
            break;
        }
        g.FillRectangleXYHW(p.bgBrush, x, y, panelWidth, panelHeight);
        if (p.borderthickness > 0)
          g.DrawRectangleXYHW(p.pen, x, y, panelWidth, panelHeight);
        let sf = new YStringFormat(16384);
        switch (p.panelTextAlign) {
          case MessagePanel.TextAlign.LEFT:
            sf.LineAlignment = 0;
            sf.Alignment = 0;
            break;
          case MessagePanel.TextAlign.RIGHT:
            sf.LineAlignment = 2;
            sf.Alignment = 2;
            break;
          default:
            sf.LineAlignment = 1;
            sf.Alignment = 1;
            break;
        }
        let r = new YRectangle(x + p.padding + p.borderthickness / 2 >> 0, y + p.padding + p.borderthickness / 2 >> 0, ssize.width + 1, ssize.height + 1);
        g.DrawStringRect(p.text, p.font, p.font.brush, r, sf);
      }
    }
  }
  drawAnnotationPanels(g, annotationPanels, viewPortWidth, viewPortHeight, overlap, mainViewPort) {
    let active = false;
    for (let i = 0; i < this.annotationPanels.length; i++) {
      if (this.annotationPanels[i].enabled)
        active = true;
    }
    if (!active)
      return;
    for (let i = 0; i < this.annotationPanels.length; i++) {
      if (annotationPanels[i].enabled && annotationPanels[i].overlap == overlap) {
        let p = annotationPanels[i];
        let AvailableWidth = viewPortWidth - 2 * p.padding - p.borderthickness;
        if (AvailableWidth < 100)
          AvailableWidth = 100;
        let textToDisplay = p.text.replace("\\n", "\n");
        if (textToDisplay.indexOf("$") >= 0) {
          textToDisplay = textToDisplay.replace("\\n", "\n");
          textToDisplay = this.patchAnnotation(textToDisplay);
        }
        let ssize = g.MeasureString(textToDisplay, p.font, AvailableWidth);
        let panelWidth = ssize.width + 2 * p.padding + p.borderthickness;
        let panelHeight = ssize.height + 2 * p.padding + p.borderthickness;
        let x = 0;
        switch (p.panelHrzAlign) {
          case MessagePanel.HorizontalAlignPos.LEFT:
            x = p.horizontalMargin;
            if (!annotationPanels[i].overlap && mainViewPort.Lmargin < panelWidth + 10) {
              mainViewPort.Lmargin = panelWidth + 10;
            }
            break;
          case MessagePanel.HorizontalAlignPos.RIGHT:
            x = viewPortWidth - panelWidth - p.horizontalMargin;
            if (!annotationPanels[i].overlap && mainViewPort.Rmargin < panelWidth + 20) {
              mainViewPort.Rmargin = panelWidth + 20;
            }
            break;
          default:
            x = (viewPortWidth - panelWidth) / 2;
            break;
        }
        let y = 0;
        switch (p.panelVrtAlign) {
          case MessagePanel.VerticalAlignPos.TOP:
            y = p.verticalMargin;
            if (!annotationPanels[i].overlap && mainViewPort.Tmargin < panelHeight + 20) {
              mainViewPort.Tmargin = panelHeight + 20;
            }
            break;
          case MessagePanel.VerticalAlignPos.BOTTOM:
            y = viewPortHeight - panelHeight - p.verticalMargin;
            if (!annotationPanels[i].overlap && mainViewPort.Bmargin < panelHeight + 20) {
              mainViewPort.Bmargin = panelHeight + 20;
            }
            break;
          default:
            y = (viewPortHeight - panelHeight) / 2;
            break;
        }
        if (annotationPanels[i].overlap) {
          x += annotationPanels[i].positionOffsetX / 100 * (viewPortWidth - panelWidth);
          y += annotationPanels[i].positionOffsetY / 100 * (viewPortHeight - panelHeight);
          if (x < 0)
            x = 0;
          if (y < 0)
            y = 0;
          if (x > viewPortWidth - panelWidth)
            x = viewPortWidth - panelWidth;
          if (y > viewPortHeight - panelHeight)
            y = viewPortHeight - panelHeight;
        }
        g.FillRectangleXYHW(p.bgBrush, x, y, panelWidth, panelHeight);
        if (p.borderthickness > 0)
          g.DrawRectangleXYHW(p.pen, x, y, panelWidth, panelHeight);
        let sf = new YStringFormat(16384);
        switch (p.panelTextAlign) {
          case MessagePanel.TextAlign.LEFT:
            sf.LineAlignment = 0;
            sf.Alignment = 0;
            break;
          case MessagePanel.TextAlign.RIGHT:
            sf.LineAlignment = 2;
            sf.Alignment = 2;
            break;
          default:
            sf.LineAlignment = 1;
            sf.Alignment = 1;
            break;
        }
        let r = new YRectangle(x + p.padding + p.borderthickness / 2, y + p.padding + p.borderthickness / 2, ssize.width + 1, ssize.height + 1);
        g.DrawStringRect(textToDisplay, p.font, p.font.brush, r, sf);
      }
    }
  }
  log(s) {
    if (this._logFunction == null)
      return;
    this._logFunction(s);
  }
};
YDataRenderer.RendererDebug = false;
YDataRenderer.FloatToStrformats = ["0", "0", "0", "0.0", "0.00", "0.000", "0.0000"];
YDataRenderer._disableMinMaxCheck = false;
YDataRenderer.globalMouseMoveSet = false;
YDataRenderer.globalMouseX = -1;
YDataRenderer.globalMouseY = -1;
(function(YDataRenderer2) {
  class CaptureTypeEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, CaptureType);
    }
  }
  YDataRenderer2.CaptureTypeEnumItem = CaptureTypeEnumItem;
  class CaptureType extends YEnum {
  }
  CaptureType.PNG = new CaptureTypeEnumItem("PNG", "Bitmap (PNG)");
  CaptureType.SVG = new CaptureTypeEnumItem("SVG", "Vector (SVG)");
  YDataRenderer2.CaptureType = CaptureType;
  class CaptureTargetEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, CaptureTarget);
    }
  }
  YDataRenderer2.CaptureTargetEnumItem = CaptureTargetEnumItem;
  class CaptureTarget extends YEnum {
  }
  CaptureTarget.ToClipBoard = new CaptureTargetEnumItem("ToClipBoard", "ClipBoard");
  CaptureTarget.ToFile = new CaptureTargetEnumItem("ToFile", "File");
  YDataRenderer2.CaptureTarget = CaptureTarget;
  class CaptureFormatsEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, CaptureFormats);
    }
  }
  YDataRenderer2.CaptureFormatsEnumItem = CaptureFormatsEnumItem;
  class CaptureFormats extends YEnum {
  }
  CaptureFormats.Keep = new CaptureFormatsEnumItem("Keep", "Keep original size");
  CaptureFormats.Fixed = new CaptureFormatsEnumItem("Fixed", "Fixed size");
  CaptureFormats.FixedWidth = new CaptureFormatsEnumItem("FixedWidth", "Fixed width, keep ration aspect");
  CaptureFormats.FixedHeight = new CaptureFormatsEnumItem("FixedHeight", "Fixed height, keep ration aspect");
  YDataRenderer2.CaptureFormats = CaptureFormats;
})(YDataRenderer || (YDataRenderer = {}));
var YGraphics = class {
  constructor(canvas, width, height, dpi) {
    this._c = null;
    this._g = null;
    this._width = 0;
    this._height = 0;
    this._dpi = 0;
    this._image = null;
    this._lastPen = null;
    this._lastBrush = null;
    this._lastFont = null;
    this._clipCounter = 0;
    this._textRenderingHint = null;
    this._smoothingMode = YSmoothingMode.Default;
    this._c = canvas;
    this._g = this._c.getContext("2d");
    this._g.textBaseline = "top";
    this._width = width;
    this._height = height;
    this._dpi = dpi;
  }
  get_downloadableData() {
    return this._c.toDataURL("image/png");
  }
  get graphics() {
    return this._g;
  }
  setPen(p) {
    if (p == this._lastPen)
      return;
    if (p != null) {
      this._g.lineWidth = p.lineWidth;
      let st = p.strokeStyle;
      this._g.strokeStyle = p.strokeStyle;
    } else {
      this._g.lineWidth = 0;
    }
    this._lastPen = p;
  }
  setBrush(b) {
    if (b == this._lastBrush)
      return;
    if (b instanceof YSolidBrush) {
      this._g.fillStyle = b.color.htmlCode;
    } else if (b instanceof YLinearGradientBrush) {
      let lingrad = this._g.createLinearGradient(0, 0, 0, this._height);
      lingrad.addColorStop(0, b.color1.htmlCode);
      lingrad.addColorStop(1, b.color2.htmlCode);
      this._g.fillStyle = lingrad;
    } else {
      throw new Error("invalid / insupported brush type");
    }
    this._lastBrush = b;
  }
  setFont(f) {
    if (f == this._lastFont && !f.hasChanged)
      return;
    this._g.font = f.htmlCode;
    this._lastFont = f;
  }
  DrawLineXY(p, x1, y1, x2, y2) {
    if (p.noAntiAlias) {
      let offset = p.lineWidth == p.lineWidth >> 0 && (p.lineWidth & 1) == 1 ? 0.5 : 0;
      x1 = Math.round(x1) + offset;
      y1 = Math.round(y1) + offset;
      x2 = Math.round(x2) + offset;
      y2 = Math.round(y2) + offset;
    }
    this.setPen(p);
    this._g.beginPath();
    this._g.moveTo(x1, y1);
    this._g.lineTo(x2, y2);
    this._g.stroke();
  }
  DrawLine(p, p1, p2) {
    this.setPen(p);
    this._g.beginPath();
    this._g.moveTo(p1.X, p1.Y);
    this._g.lineTo(p2.X, p2.Y);
    this._g.stroke();
  }
  SetClip(rect) {
    this._g.save();
    this._g.beginPath();
    this._g.rect(rect.x, rect.y, rect.w, rect.h);
    this._g.clip();
    this._clipCounter++;
  }
  ResetClip() {
    if (this._clipCounter <= 0)
      throw new Error("clipping stack error");
    this._g.restore();
    this._clipCounter--;
  }
  MeasureString(text, font, width) {
    this.setFont(font);
    let res = new YSizeF(font, text);
    let count = res.linesCount;
    if (count == 0)
      return res;
    res.height = res.firstLineHeight * 1.2 + (count - 1) * res.lineHeight;
    let max = 0;
    let dim;
    for (let i = 0; i < count; i++) {
      dim = this._g.measureText(res.lines[i]);
      max = Math.max(max, dim.width);
    }
    res.width = max;
    return res;
  }
  MeasureStringSF(text, font, width, stringFormat) {
    return this.MeasureString(text, font, width);
  }
  FillRectangle(brush, rect) {
    this.setBrush(brush);
    this._g.beginPath();
    this._g.fillRect(rect.x, rect.y, rect.w, rect.h);
    this._g.fill();
  }
  FillRectangleXYHW(brush, x, y, width, height) {
    this.setBrush(brush);
    this._g.beginPath();
    this._g.fillRect(x, y, width, height);
    this._g.fill();
  }
  DrawRectangle(p, rect) {
    this.setPen(p);
    this._g.beginPath();
    if (p.noAntiAlias) {
      let offset = p.lineWidth == p.lineWidth >> 0 && (p.lineWidth & 1) == 1 ? 0.5 : 0;
      this._g.rect(Math.round(rect.x) + offset, Math.round(rect.y) + offset, Math.round(rect.w), Math.round(rect.h));
    } else {
      this._g.rect(rect.x, rect.y, rect.w, rect.h);
    }
    this._g.stroke();
  }
  DrawRectangleXYHW(p, x, y, width, height) {
    if (p.noAntiAlias) {
      let offset = p.lineWidth == p.lineWidth >> 0 && (p.lineWidth & 1) == 1 ? 0.5 : 0;
      x = Math.round(x) + offset;
      y = Math.round(y) + offset;
      width = Math.round(width);
      height = Math.round(height);
    }
    this.setPen(p);
    this._g.beginPath();
    this._g.rect(x, y, width, height);
    this._g.stroke();
  }
  DrawStringXY(s, font, brush, x, y) {
    this.setPen(null);
    this.setBrush(brush);
    this.setFont(font);
    let totalsz = this.MeasureString(s, font, 0);
    let dy = totalsz.lineHeight;
    for (let i = 0; i < totalsz.linesCount; i++) {
      this._g.fillText(totalsz.lines[i], x, y);
      y += dy;
    }
  }
  DrawStringXYF(s, font, brush, x, y, format) {
    if (YGraphics._debugDrawString) {
      let pen = new YPen(YColor.Red, 1);
      this.DrawLineXY(pen, x - 5, y, x + 5, y);
      this.DrawLineXY(pen, x, y - 5, x, y + 5);
    }
    let sz = this.MeasureString(s, font, 1e4);
    if (format.Alignment == 1) {
      x -= sz.width >> 1;
    } else if (format.Alignment == 2)
      x -= sz.width;
    if (format.LineAlignment == 1) {
      y -= sz.height / 2 >> 0;
    } else if (format.LineAlignment == 2)
      y -= sz.height;
    this.DrawStringXY(s, font, brush, x, y);
  }
  DrawStringPF(s, font, brush, p, format) {
    this.DrawStringXYF(s, font, brush, p.X, p.Y, format);
  }
  DrawString(s, font, brush, p) {
    if (YGraphics._debugDrawString) {
      let pen = new YPen(YColor.Red, 1);
      this.DrawLineXY(pen, p.X - 5, p.Y, p.X + 5, p.Y);
      this.DrawLineXY(pen, p.X, p.Y - 5, p.X, p.Y + 5);
    }
    this.setPen(null);
    this.setBrush(brush);
    this.setFont(font);
    this._g.fillText(s, p.X, p.Y);
  }
  DrawStringRect(s, font, brush, layoutRectangle, format) {
    if (YGraphics._debugDrawString) {
      let pen = new YPen(YColor.Red, 1);
      this.DrawRectangle(pen, layoutRectangle);
    }
    this.setPen(null);
    this.setBrush(brush);
    this.setFont(font);
    let totalsz = this.MeasureString(s, font, 0);
    let dy = totalsz.lineHeight;
    let y = layoutRectangle.y;
    switch (format.LineAlignment) {
      case 0:
        break;
      case 1:
        y += (layoutRectangle.h - totalsz.height) / 2;
        break;
      case 2:
        y += layoutRectangle.h - totalsz.height;
        break;
    }
    let xOrigin = layoutRectangle.x;
    if (format.FormatFlags & 2) {
      this.Transform(layoutRectangle.x, layoutRectangle.y, Math.PI / 2);
      y -= layoutRectangle.y + layoutRectangle.w;
      xOrigin -= layoutRectangle.x;
    }
    for (let i = 0; i < totalsz.linesCount; i++) {
      let s2 = totalsz.lines[i];
      let sz = this.MeasureString(s2, font, 0);
      let x = xOrigin;
      switch (format.Alignment) {
        case 0:
          break;
        case 1:
          x += (layoutRectangle.w - sz.width) / 2;
          break;
        case 2:
          x += layoutRectangle.w - sz.width;
          break;
      }
      this._g.fillText(s2, x, y);
      y += dy;
    }
    if (format.FormatFlags & 2)
      this.ResetTransform();
  }
  Transform(dx, dy, angle) {
    let sin = Math.sin(angle);
    let cos = Math.cos(angle);
    this._g.save();
    this._g.transform(cos, sin, -sin, cos, dx, dy);
  }
  ResetTransform() {
    this._g.restore();
  }
  FillEllipse(brush, x, y, width, height) {
    this.setBrush(brush);
    this._g.beginPath();
    this._g.ellipse(x + width / 2, y + height / 2, width / 2, height / 2, 0, 0, 2 * Math.PI);
    this._g.fill();
  }
  DrawEllipse(pen, x, y, width, height) {
    this.setPen(pen);
    this._g.beginPath();
    this._g.ellipse(x + width / 2, y + height / 2, width / 2, height / 2, 0, 0, 2 * Math.PI);
    this._g.stroke();
  }
  FillPolygon(brush, points) {
    this.setBrush(brush);
    if (points.length <= 2)
      return;
    this._g.beginPath();
    if (brush.noAntiAlias) {
      this._g.moveTo(Math.round(points[0].X) + 0.5, Math.round(points[0].Y) + 0.5);
      for (let i = 1; i < points.length; i++) {
        this._g.lineTo(Math.round(points[i].X) + 0.5, Math.round(points[i].Y) + 0.5);
      }
    } else {
      this._g.moveTo(points[0].X, points[0].Y);
      for (let i = 1; i < points.length; i++) {
        this._g.lineTo(points[i].X, points[i].Y);
      }
    }
    this._g.closePath();
    this._g.fill();
  }
  DrawPolygon(pen, points) {
    this.setPen(pen);
    if (points.length <= 1)
      return;
    this._g.beginPath();
    if (pen.noAntiAlias) {
      let offset = pen.lineWidth == pen.lineWidth >> 0 && (pen.lineWidth & 1) == 1 ? 0.5 : 0;
      this._g.moveTo(Math.round(points[0].X) + offset, Math.round(points[0].Y) + offset);
      for (let i = 1; i < points.length; i++) {
        this._g.lineTo(Math.round(points[i].X) + offset, Math.round(points[i].Y) + offset);
      }
    } else {
      this._g.moveTo(points[0].X, points[0].Y);
      for (let i = 1; i < points.length; i++) {
        this._g.lineTo(points[i].X, points[i].Y);
      }
    }
    this._g.closePath();
    this._g.stroke();
  }
  DrawLines(pen, points) {
    this.setPen(pen);
    if (points.length <= 1)
      return;
    this._g.beginPath();
    this._g.lineCap = "round";
    this._g.lineJoin = "round";
    this._g.moveTo(points[0].X, points[0].Y);
    for (let i = 1; i < points.length; i++) {
      this._g.lineTo(points[i].X, points[i].Y);
    }
    this._g.stroke();
  }
  Dispose() {
    this._c = null;
    this._g = null;
    this._width = 0;
    this._height = 0;
    this._dpi = 0;
  }
  get TextRenderingHint() {
    return this._textRenderingHint;
  }
  set TextRenderingHint(value) {
    this._textRenderingHint = value;
  }
  get SmoothingMode() {
    return this._smoothingMode;
  }
  set SmoothingMode(value) {
    this._smoothingMode = value;
  }
  DrawImage(srcimage, destRect, srcRect, srcUnit) {
    this._g.drawImage(srcimage, srcRect.x, srcRect.y, srcRect.w, srcRect.h, destRect.x, destRect.y, destRect.w, destRect.h);
  }
  comment(s) {
  }
};
YGraphics._debugDrawString = false;
var YGraphicsSVG = class extends YGraphics {
  constructor(canvas, width, height, dpi) {
    super(canvas, width, height, dpi);
    this._clipcount = 0;
    this._clipSectionsToClose = 0;
    this._transformSectionsToClose = 0;
    this._gradientCount = 0;
    YGraphicsSVG.SVGID++;
    this._SVGdefs = new YStringBuilder();
    this._SVGcontents = new YStringBuilder();
    this._SVGdefs.AppendLine('<clipPath id="pageClip_' + YGraphicsSVG.SVGID.toString() + '"><rect x="0" y="0"  width="' + width.toString() + '" height="' + height.toString() + '"/></clipPath>');
  }
  static escapeXml(unsafe) {
    return unsafe.replace(/[^ !#$%(-;=?-z]/g, (c) => "&#" + c.charCodeAt(0) + ";");
  }
  get_downloadableData() {
    return "data:image/svg+xml;base64," + btoa(this.get_svgContents());
  }
  DrawLineXY(p, x1, y1, x2, y2) {
    this._SVGcontents.AppendLine('<line x1="' + x1.toString() + '"  y1 ="' + y1.toString() + '"  x2 ="' + x2.toString() + '"  y2 ="' + y2.toString() + '" style = "stroke:' + p.color.svgCode + ";stroke-opacity:" + p.color.alphaCode + "; stroke-width:" + p.lineWidth.toString() + '"/>');
  }
  DrawLine(p, p1, p2) {
    this.DrawLineXY(p, p1.X, p1.Y, p2.X, p2.Y);
  }
  SetClip(rect) {
    this.ResetClip();
    this._SVGdefs.AppendLine('<clipPath id="clip_' + YGraphicsSVG.SVGID.toString() + "_" + this._clipcount.toString() + '"><rect x="' + rect.x.toString() + '" y="' + rect.y.toString() + '"  width="' + rect.w.toString() + '" height="' + rect.h.toString() + '"/></clipPath>');
    this._SVGcontents.AppendLine('<g clip-path="url(#clip_' + YGraphicsSVG.SVGID.toString() + "_" + this._clipcount.toString() + ')">');
    this._clipcount++;
    this._clipSectionsToClose++;
  }
  ResetClip() {
    if (this._clipSectionsToClose > 0) {
      this._SVGcontents.AppendLine("</g>");
      this._clipSectionsToClose--;
    }
  }
  BrushToSVG(brush, revert) {
    let fillParam = "";
    if (brush instanceof YSolidBrush) {
      fillParam = 'fill = "' + brush.color.svgCode + '" fill-opacity="' + brush.color.alphaCode + '" ';
    } else if (brush instanceof YLinearGradientBrush) {
      this._SVGdefs.AppendLine('<linearGradient id="grad_' + YGraphicsSVG.SVGID.toString() + "_" + this._gradientCount + '" x1="0%" ' + (revert ? 'y1="100%" ' : 'y1="0%" ') + 'x2="0%" ' + (revert ? 'y2="0%" ' : 'y2="100%" ') + '>\r\n<stop offset="0%" style ="stop-color:' + brush.color1.svgCode + ";stop-opacity:" + brush.color1.alphaCode + '"/>\r\n<stop offset="100%" style ="stop-color:' + brush.color2.svgCode + ";stop-opacity:" + brush.color2.alphaCode + '"/>\r\n</linearGradient>');
      fillParam = 'fill="url(#grad_' + YGraphicsSVG.SVGID.toString() + "_" + this._gradientCount + ')" ';
      this._gradientCount++;
    } else {
      throw new ReferenceError("unsupported brush type.");
    }
    return fillParam;
  }
  FillRectangle(brush, rect) {
    this._SVGcontents.AppendLine('<rect x="' + rect.x.toString() + '"  y ="' + rect.y.toString() + '"  width ="' + rect.w.toString() + '"  height ="' + rect.h.toString() + '" ' + this.BrushToSVG(brush, true) + 'style="stroke-width:0"/>');
  }
  FillRectangleXYHW(brush, x, y, width, height) {
    this.FillRectangle(brush, new YRectangle(x, y, width, height));
  }
  DrawRectangle(p, rect) {
    this._SVGcontents.AppendLine('<rect x="' + rect.x.toString() + '"  y ="' + rect.y.toString() + '"  width ="' + rect.w.toString() + '"  height ="' + rect.h.toString() + '"  fill="none" style = "stroke:' + p.color.svgCode + ";stroke-opacity:" + p.color.alphaCode + "; stroke-width:" + p.lineWidth.toString() + '"/>');
  }
  DrawRectangleXYHW(p, x, y, width, height) {
    this.DrawRectangle(p, new YRectangle(x, y, width, height));
  }
  DrawEllipse(pen, x, y, width, height) {
    this._SVGcontents.AppendLine('<ellipse  cx="' + (x + width / 2).toString() + '"  cy ="' + (y + height / 2).toString() + '"  rx ="' + (width / 2).toString() + '"  ry ="' + (height / 2).toString() + '"  fill="none" style = "stroke:' + pen.color.svgCode + ";stroke-opacity:" + pen.color.alphaCode + "; stroke-width:" + pen.lineWidth.toString() + '"/>');
  }
  FillEllipse(brush, x, y, width, height) {
    this._SVGcontents.AppendLine('<ellipse  cx="' + (x + width / 2).toString() + '"  cy ="' + (y + height / 2).toString() + '"  rx ="' + (width / 2).toString() + '"  ry ="' + (height / 2).toString() + '" ' + this.BrushToSVG(brush, false) + 'style="stroke-width:0"/>');
  }
  DrawStringXY(s, font, brush, x, y) {
    let tokens = s.split("\n");
    for (let i = 0; i < tokens.length; i++) {
      s = tokens[i];
      this._SVGcontents.AppendLine('<text x="' + x.toString() + '" y="' + (y + font.sizeInPoints).toString() + '" text-anchor="start" font-family="' + font.name.toString() + '" font-size="' + font.sizeInPoints.toString() + 'pt" font-weight="' + (font.bold ? "bold" : "normal") + '" font-style="' + (font.italic ? "italic" : "normal") + '" ' + this.BrushToSVG(brush, false) + 'style="stroke-width:0">\r\n' + YGraphicsSVG.escapeXml(s) + "\r\n</text>");
      y += font.sizeInPoints * 1.75;
    }
  }
  DrawString(s, font, brush, p) {
    if (YGraphics._debugDrawString) {
      let pen = new YPen(YColor.Red, 1);
      this.DrawLineXY(pen, p.X - 5, p.Y, p.X + 5, p.Y);
      this.DrawLineXY(pen, p.X, p.Y - 5, p.X, p.Y + 5);
    }
    this.DrawStringXY(s, font, brush, p.X, p.Y);
  }
  DrawStringF(s, font, brush, point, format) {
    let totalsz = this.MeasureString(s, font, 0);
    let y = point.Y + font.size * 1.25;
    switch (format.LineAlignment) {
      case 0:
        break;
      case 1:
        y += -totalsz.height / 2;
        break;
      case 2:
        y += -totalsz.height;
        break;
    }
    let tokens = s.split("\n");
    for (let i = 0; i < tokens.length; i++) {
      let s2 = tokens[i];
      let sz = this.MeasureString(s2, font, 0);
      let x = point.X;
      switch (format.Alignment) {
        case 0:
          break;
        case 1:
          x += -sz.width / 2;
          break;
        case 2:
          x += -sz.width;
          break;
      }
      this._SVGcontents.AppendLine('<text x="' + x.toString() + '" y="' + y.toString() + '" text-anchor="start" font-family="' + font.name.toString() + '" font-size="' + font.sizeInPoints.toString() + 'pt" font-weight="' + (font.bold ? "bold" : "normal") + '" font-style="' + (font.italic ? "italic" : "normal") + '" ' + this.BrushToSVG(brush, false) + 'style="stroke-width:0">\r\n' + YGraphicsSVG.escapeXml(s2) + "\r\n</text>");
      y += font.sizeInPoints * 1.75;
    }
  }
  DrawStringRect(s, font, brush, layoutRectangle, format) {
    if (YGraphics._debugDrawString) {
      let pen = new YPen(YColor.Red, 1);
      this.DrawRectangle(pen, layoutRectangle);
    }
    let totalsz = this.MeasureString(s, font, 0);
    let y = layoutRectangle.y + font.sizeInPoints * 1.1;
    switch (format.LineAlignment) {
      case 0:
        break;
      case 1:
        y += (layoutRectangle.h - totalsz.height) / 2;
        break;
      case 2:
        y += layoutRectangle.h - totalsz.height;
        break;
    }
    let tokens = s.split("\n");
    for (let i = 0; i < tokens.length; i++) {
      let s2 = tokens[i];
      let sz = this.MeasureString(s2, font, 0);
      let x = layoutRectangle.x;
      switch (format.Alignment) {
        case 0:
          break;
        case 1:
          x += (layoutRectangle.w - sz.width) / 2;
          break;
        case 2:
          x += layoutRectangle.w - sz.width;
          break;
      }
      this._SVGcontents.AppendLine('<text x="' + x.toString() + '" y="' + y.toString() + '" text-anchor="start" font-family="' + font.name.toString() + '" font-size="' + (font.sizeInPoints * 1.1).toString() + 'pt" font-weight="' + (font.bold ? "bold" : "normal") + '" font-style="' + (font.italic ? "italic" : "normal") + '" ' + this.BrushToSVG(brush, false) + 'style="stroke-width:0">\r\n' + YGraphicsSVG.escapeXml(s2) + "\r\n</text>");
      y += font.sizeInPoints * 1.75;
    }
  }
  Transform(dx, dy, angle) {
    this._SVGcontents.AppendLine('<g transform="translate(' + dx.toString() + " " + dy.toString() + ") rotate(" + (180 * angle / Math.PI).toString() + ')">');
    this._transformSectionsToClose++;
  }
  ResetTransform() {
    if (this._transformSectionsToClose > 0) {
      this._SVGcontents.AppendLine("</g>");
      this._transformSectionsToClose--;
    }
  }
  DrawPolygon(pen, points) {
    if (points.length < 2)
      return;
    this._SVGcontents.Append('<path  d="M ' + points[0].X.toString() + " " + points[0].Y.toString());
    for (let i = 1; i < points.length; i += 1) {
      this._SVGcontents.Append(" L " + points[i].X.toString() + " " + points[i].Y.toString());
    }
    this._SVGcontents.AppendLine(' z" fill="none" style="stroke:' + pen.color.svgCode + ";stroke-opacity:" + pen.color.alphaCode + "; stroke-width:" + pen.lineWidth.toString() + '"/>');
  }
  DrawLines(pen, points) {
    if (points.length < 2)
      return;
    this._SVGcontents.Append('<path  d="M ' + points[0].X.toString() + " " + points[0].Y.toString());
    for (let i = 1; i < points.length; i++) {
      this._SVGcontents.Append(" L " + points[i].X.toString() + " " + points[i].Y.toString());
    }
    this._SVGcontents.AppendLine('" fill="none" style="stroke:' + pen.color.svgCode + ";stroke-opacity:" + pen.color.alphaCode + "; stroke-linecap:round; stroke-linejoin:round;stroke-width:" + pen.lineWidth.toString() + '"/>');
  }
  FillPolygon(brush, points) {
    if (points.length < 2)
      return;
    this._SVGcontents.Append('<path  d="M ' + points[0].X.toString() + " " + points[0].Y.toString());
    for (let i = 1; i < points.length; i++) {
      this._SVGcontents.Append(" L " + points[i].X.toString() + " " + points[i].Y.toString());
    }
    this._SVGcontents.AppendLine(' z" ' + this.BrushToSVG(brush, false) + 'style="stroke-width:0"/>\r\n');
  }
  DrawImage(image, destRect, srcRect, srcUnit) {
    throw new Error("DrawImage not supported, find an other way.");
  }
  save(filename) {
    throw new Error("Direct save to file not supported.");
  }
  comment(s) {
    this._SVGcontents.AppendLine("<!--" + s + "-->");
  }
  get_svgContents() {
    let physicalWidth = (2.54 * (this._width / this._dpi)).toFixed(3);
    let physicalheight = (2.54 * (this._height / this._dpi)).toFixed(3);
    while (this._clipSectionsToClose > 0) {
      this._SVGcontents.AppendLine("</g>");
      this._clipSectionsToClose--;
    }
    while (this._transformSectionsToClose > 0) {
      this._SVGcontents.AppendLine("</g>");
      this._transformSectionsToClose--;
    }
    return '<?xml version = "1.0" standalone = "no" ?>\r\n<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">\r\n<svg width = "' + physicalWidth + 'cm" height = "' + physicalheight + 'cm" viewBox = "0 0 ' + this._width.toString() + " " + this._height.toString() + '" xmlns = "http://www.w3.org/2000/svg" version = "1.1" >\r\n<defs>\r\n' + this._SVGdefs.contents + '</defs>\r\n<g clip-path="url(#pageClip_' + YGraphicsSVG.SVGID.toString() + ')">\r\n' + this._SVGcontents.contents + "</g>\r\n</svg>\n";
  }
};
YGraphicsSVG.SVGID = 0;

// obj/full/Renderer/YAngularGauge.js
var YAngularZone = class extends Zone {
  get path() {
    return this._path;
  }
  setPathSize(count) {
    this._path = new Array(count).fill(null);
  }
  setPathPoint(index, p) {
    this._path[index] = p;
  }
  resetPath() {
    this._path = null;
  }
  resetCache() {
    this.resetPath();
  }
  get width() {
    return this._width;
  }
  set width(value) {
    if (value <= 0)
      throw new RangeError("Width must be a positive value");
    this._width = value;
    this._path = null;
    this._parentRenderer.redraw();
  }
  get outerRadius() {
    return this._outerRadius;
  }
  set outerRadius(value) {
    this._outerRadius = Math.max(0, Math.min(100, value));
    this._path = null;
    this._parentRenderer.redraw();
  }
  constructor(parentRenderer, directParent) {
    super(parentRenderer, directParent);
    this._path = null;
    this._width = 10;
    this._outerRadius = 98;
  }
};
var YAngularGauge = class extends YDataRenderer {
  get min() {
    return this._min;
  }
  set min(value) {
    if (value >= this._max && !YDataRenderer.minMaxCheckDisabled) {
      throw new RangeError("Min cannot be greater than max (" + this._max.toString() + ")");
    }
    this._min = value;
    for (let i = 0; i < this._zones.length; i++) {
      this._zones[i].resetPath();
    }
    if (this._needleValue < this._min) {
      this._needleValue = this._min;
    }
    this.redraw();
  }
  get max() {
    return this._max;
  }
  set max(value) {
    if (value <= this._min && !YDataRenderer.minMaxCheckDisabled) {
      throw new RangeError("Max cannot be less than min (" + this._min.toString() + ")");
    }
    this._max = value;
    for (let i = 0; i < this._zones.length; i++) {
      this._zones[i].resetPath();
    }
    if (this._needleValue > this._max) {
      this._needleValue = this._max;
    }
    this.redraw();
  }
  get borderpen() {
    if (this._borderpen == null) {
      this._borderpen = new YPen(this._borderColor, this._borderThickness);
      this._borderpen.startCap = 1;
      this._borderpen.endCap = 1;
    }
    return this._borderpen;
  }
  get borderColor() {
    return this._borderColor;
  }
  set borderColor(value) {
    this._borderColor = value;
    this._borderpen = null;
    this.redraw();
  }
  get backgroundColor1() {
    return this._backgroundColor1;
  }
  set backgroundColor1(value) {
    this._backgroundColor1 = value;
    this._bgBrush = null;
    this.redraw();
  }
  get backgroundColor2() {
    return this._backgroundColor2;
  }
  set backgroundColor2(value) {
    this._backgroundColor2 = value;
    this._bgBrush = null;
    this.redraw();
  }
  get borderThickness() {
    return this._borderThickness;
  }
  set borderThickness(value) {
    if (value < 0)
      throw new RangeError("thickness must be a positive value");
    this._borderThickness = value;
    this._borderpen = null;
    this.redraw();
  }
  get valueFormater() {
    return this._valueFormater;
  }
  set valueFormater(value) {
    this._valueFormater = value;
    this.redraw();
  }
  get minmaxFormater() {
    return this._minmaxFormater;
  }
  set minmaxFormater(value) {
    this._minmaxFormater = value;
    this.redraw();
  }
  get thickness() {
    return this._thickness;
  }
  set thickness(value) {
    if (value < 0)
      throw new RangeError("Thickness must be a positive value");
    this._thickness = Math.max(Math.min(value, 80), 1);
    this.redraw();
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value;
    this.redraw();
  }
  get color1() {
    return this._color1;
  }
  set color1(value) {
    this._color1 = value;
    this.redraw();
  }
  get color2() {
    return this._color2;
  }
  set color2(value) {
    this._color2 = value;
    this.redraw();
  }
  get graduationColor() {
    return this._graduationColor;
  }
  set graduationColor(value) {
    this._graduationColor = value;
    this._graduationPen = null;
    this.redraw();
  }
  get graduationThickness() {
    return this._graduationThickness;
  }
  set graduationThickness(value) {
    if (value < 0)
      throw new RangeError("Thickness must be a positive value");
    this._graduationThickness = value;
    this._graduationPen = null;
    this.redraw();
  }
  get graduationSize() {
    return this._graduationSize;
  }
  set graduationSize(value) {
    if (value <= 0)
      throw new RangeError("Graduation size must be a positive value");
    this._graduationSize = value;
    this.redraw();
  }
  get graduation() {
    return this._graduation;
  }
  set graduation(value) {
    this._graduation = value;
    this.redraw();
  }
  get unitFactor() {
    return this._unitFactor;
  }
  set unitFactor(value) {
    if (value == 0)
      throw new RangeError("Factor cannot be zero.");
    this._unitFactor = value;
    this.redraw();
  }
  get unit() {
    return this._unit;
  }
  set unit(value) {
    this._unit = value;
    this.redraw();
  }
  get unitFont() {
    return this._unitFont;
  }
  get subgraduationColor() {
    return this._subgraduationColor;
  }
  set subgraduationColor(value) {
    this._subgraduationColor = value;
    this._subgraduationPen = null;
    this.redraw();
  }
  get subgraduationThickness() {
    return this._subgraduationThickness;
  }
  set subgraduationThickness(value) {
    if (value < 0)
      throw new RangeError("Thickness must be a positive value");
    this._subgraduationThickness = value;
    this._subgraduationPen = null;
    this.redraw();
  }
  get subgraduationSize() {
    return this._subgraduationSize;
  }
  set subgraduationSize(value) {
    if (value <= 0)
      throw new RangeError("Size must be a positive value");
    this._subgraduationSize = value;
    this.redraw();
  }
  get graduationOuterRadiusSize() {
    return this._graduationOuterRadiusSize;
  }
  set graduationOuterRadiusSize(value) {
    this._graduationOuterRadiusSize = Math.max(0, Math.min(100, value));
    this.redraw();
  }
  get subgraduationCount() {
    return this._subgraduationCount;
  }
  set subgraduationCount(value) {
    if (value < 0)
      throw new RangeError("Count must be a positive value");
    this._subgraduationCount = value;
    this.redraw();
  }
  get statusColor() {
    return this._statusColor;
  }
  set statusColor(value) {
    this._statusColor = value;
    this.redraw();
  }
  get statusFont() {
    return this._unitFont;
  }
  get statusLine() {
    return this._statusLine;
  }
  set statusLine(value) {
    this._statusLine = value;
    this.redraw();
  }
  get showNeedle() {
    return this._showNeedle;
  }
  set showNeedle(value) {
    this._showNeedle = value;
    this.redraw();
  }
  get needleColor() {
    return this._needleColor;
  }
  set needleColor(value) {
    this._needleColor = value;
    this._needleBrush = null;
    this.redraw();
  }
  get needleMaxSpeed() {
    return this._needleMaxSpeed;
  }
  set needleMaxSpeed(value) {
    if (value <= 0)
      throw new RangeError("Speed must be a positive value");
    this._needleMaxSpeed = value;
    this.redraw();
  }
  get needleLength1() {
    return this._needleLength1;
  }
  set needleLength1(value) {
    this._needleLength1 = value;
    this.redraw();
  }
  get needleLength2() {
    return this._needleLength2;
  }
  set needleLength2(value) {
    this._needleLength2 = value;
    this.redraw();
  }
  get needleWidth() {
    return this._needleWidth;
  }
  set needleWidth(value) {
    if (value <= 0)
      throw new RangeError("Width must be a positive value");
    this._needleWidth = value;
    this.redraw();
  }
  get needleContourColor() {
    return this._needleContourColor;
  }
  set needleContourColor(value) {
    this._needleContourColor = value;
    this._needleContourPen = null;
    this.redraw();
  }
  get needleContourThickness() {
    return this._needleContourThickness;
  }
  set needleContourThickness(value) {
    if (value < 0)
      throw new RangeError("Thickness must be a positive value");
    this._needleContourThickness = value;
    this._needleContourPen = null;
    this.redraw();
  }
  get graduationFont() {
    return this._graduationFont;
  }
  get showMinMax() {
    return this._showMinMax;
  }
  set showMinMax(value) {
    this._showMinMax = value;
    this.redraw();
  }
  constructor(UIContainer, logFunction) {
    super(UIContainer, logFunction);
    this._min = 0;
    this._max = 100;
    this.SegmentMaxLength = 8;
    this._borderpen = null;
    this._borderColor = YColor.Black;
    this._bgBrush = null;
    this._backgroundColor1 = YColor.FromArgb(255, 240, 240, 240);
    this._backgroundColor2 = YColor.FromArgb(255, 200, 200, 200);
    this._borderThickness = 5;
    this._valueFormater = null;
    this._minmaxFormater = null;
    this._thickness = 20;
    this._value = 0;
    this._needleValue = 0;
    this._color1 = YColor.Green;
    this._color2 = YColor.Red;
    this._graduationPen = null;
    this._graduationColor = YColor.Black;
    this._graduationThickness = 2;
    this._graduationSize = 10;
    this._graduation = 10;
    this._unitFactor = 1;
    this._unit = "";
    this._subgraduationPen = null;
    this._subgraduationColor = YColor.Black;
    this._subgraduationThickness = 1;
    this._subgraduationSize = 5;
    this._graduationOuterRadiusSize = 98;
    this._subgraduationCount = 5;
    this._statusColor = YColor.Gray;
    this._statusLine = "";
    this._showNeedle = true;
    this._needleBrush = null;
    this._needleColor = YColor.Red;
    this._needleMaxSpeed = 5;
    this._needleLength1 = 90;
    this._needleLength2 = 5;
    this._needleWidth = 5;
    this._needleContourPen = null;
    this._needleContourColor = YColor.DarkRed;
    this._needleContourThickness = 1;
    this._showMinMax = true;
    this._path = null;
    this._graduationFont = new YFont(this, this, Math.min(this.getContainerInnerWidth(), this.getContainerInnerHeight()) / 15, null);
    this._unitFont = new YFont(this, this, Math.min(this.getContainerInnerWidth(), this.getContainerInnerHeight()) / 20, null);
    this._statusFont = new YFont(this, this, Math.min(this.getContainerInnerWidth(), this.getContainerInnerHeight()) / 15, null);
    this.unitFont.color = YColor.DarkGray;
    this._statusFont.color = YColor.DarkGray;
    this.resizeRule = Proportional.ResizeRule.RELATIVETOBOTH;
    this._zones = [];
  }
  clearCachedObjects() {
    if (this._zones != null) {
      for (let i = 0; i < this._zones.length; i++) {
        this._zones[i].resetPath();
      }
    }
    this._path = null;
    this._bgBrush = null;
  }
  get zones() {
    return this._zones;
  }
  AddZone() {
    let z = new YAngularZone(this, this);
    this._zones.push(z);
    return z;
  }
  Render(g, w, h) {
    let mainViewPort = new ViewPortSettings();
    mainViewPort.Lmargin = 0;
    mainViewPort.Rmargin = 0;
    mainViewPort.Tmargin = 0;
    mainViewPort.Bmargin = 0;
    g.SmoothingMode = YSmoothingMode.HighQuality;
    g.TextRenderingHint = YTextRenderingHint.AntiAlias;
    let stringFormat4Sizing = new YStringFormat(16384);
    let stringFormat = new YStringFormat(16384);
    stringFormat.Alignment = 1;
    stringFormat.LineAlignment = 1;
    this.drawAnnotationPanels(g, this._annotationPanels, w, h, false, mainViewPort);
    g.TextRenderingHint = YTextRenderingHint.AntiAlias;
    let xcenter = mainViewPort.Lmargin + (w - mainViewPort.Lmargin - mainViewPort.Rmargin) / 2;
    let ycenter = mainViewPort.Tmargin + (h - mainViewPort.Tmargin - mainViewPort.Bmargin) / 2;
    let radius = Math.min((w - mainViewPort.Lmargin - mainViewPort.Rmargin) / 2, (h - mainViewPort.Tmargin - mainViewPort.Bmargin) / 2) - this.borderThickness;
    let circonference = 2 * radius * 3.14 >> 0;
    let AngleAperture = 4 * 2 * Math.PI / 5;
    if (this._path == null) {
      let outterlength = 2 * radius * Math.PI;
      let stepCount = outterlength / this.SegmentMaxLength >> 0;
      let stepsize = 2 * Math.PI / stepCount;
      this._path = new Array(stepCount).fill(null);
      let n = 0;
      for (let i = 0; i < stepCount; i++) {
        let a = 2 * i * Math.PI / stepCount;
        this._path[n++] = new PointF(xcenter + radius * Math.cos(a), ycenter - radius * Math.sin(a));
      }
    }
    if (this._bgBrush == null)
      this._bgBrush = new YLinearGradientBrush(this._backgroundColor1, this._backgroundColor2);
    if (this._borderpen == null) {
      this._borderpen = new YPen(this._borderColor, this._borderThickness);
      this._borderpen.linejoin = YPen.LineJoin.Round;
    }
    if (this._path.length > 3)
      g.FillPolygon(this._bgBrush, this._path);
    if (this._graduationPen == null)
      this._graduationPen = new YPen(this._graduationColor, this._graduationThickness);
    if (this._subgraduationPen == null)
      this._subgraduationPen = new YPen(this._subgraduationColor, this._subgraduationThickness);
    let unitDesc = (this._unitFactor != 1 ? "x" + this._unitFactor.toString() + " " : "") + this._unit;
    let size = g.MeasureStringSF(unitDesc.toString(), this._unitFont, 1e4, stringFormat4Sizing);
    let unitPos = new YRectangle(xcenter - size.width / 2 >> 0, ycenter + radius / 2 - size.height / 2 >> 0, size.width + 1 >> 0, size.height + 1 >> 0);
    g.DrawStringRect(unitDesc, this._unitFont, this._unitFont.brush, unitPos, stringFormat);
    if (this._statusLine != "") {
      size = g.MeasureStringSF(this._statusLine, this._statusFont, 1e4, stringFormat4Sizing);
      let statusPos = new YRectangle(xcenter - size.width / 2 >> 0, ycenter - radius / 3 - size.height / 2 >> 0, size.width + 1, size.height + 1);
      g.DrawStringRect(this._statusLine, this._statusFont, this._statusFont.brush, statusPos, stringFormat);
    }
    let firstGraduation;
    let gratuationCount;
    let Angle, C, S, R1, R2;
    let outerCoef = this._graduationOuterRadiusSize / 100;
    for (let i = 0; i < this._zones.length; i++) {
      if (this._zones[i].visible) {
        if (this._zones[i].path == null) {
          let zmin = Math.max(this._min, Math.min(this._max, this._zones[i].min));
          let zmax = Math.max(this._min, Math.min(this._max, this._zones[i].max));
          if (zmax > zmin) {
            let zOuterCoef = this._zones[i].outerRadius / 100;
            let Angle1 = (Math.PI - AngleAperture) / 2 + AngleAperture * (zmin - this._min) / (this._max - this._min);
            let Angle2 = (Math.PI - AngleAperture) / 2 + AngleAperture * (zmax - this._min) / (this._max - this._min);
            let outterlength = (Angle2 - Angle1) * radius;
            let stepCount = outterlength / this.SegmentMaxLength >> 0;
            if (stepCount < 2)
              stepCount = 2;
            this._zones[i].setPathSize(2 * stepCount + 2);
            for (let j = 0; j <= stepCount; j++) {
              let A = Angle1 + (Angle2 - Angle1) * j / stepCount;
              this._zones[i].setPathPoint(j, new PointF(xcenter - radius * zOuterCoef * Math.cos(A), ycenter - radius * zOuterCoef * Math.sin(A)));
            }
            let innerRadiusCoef = zOuterCoef - this._zones[i].width / 100;
            for (let j = stepCount; j >= 0; j--) {
              let A = Angle1 + (Angle2 - Angle1) * j / stepCount;
              this._zones[i].setPathPoint(2 * stepCount + 1 - j, new PointF(xcenter - radius * innerRadiusCoef * Math.cos(A), ycenter - radius * innerRadiusCoef * Math.sin(A)));
            }
          }
        }
        if (this._zones[i].path != null)
          g.FillPolygon(this._zones[i].zoneBrush, this._zones[i].path);
      }
    }
    firstGraduation = this._graduation * (this._min / this._graduation) >> 0;
    if (this._min < 0)
      firstGraduation -= this._graduation;
    while (firstGraduation < this._min) {
      firstGraduation += this._graduation;
    }
    gratuationCount = 1 + (this._max - this._min) / this._graduation >> 0;
    if (this._subgraduationCount > 0 && this._subgraduationCount * gratuationCount < circonference) {
      let subgraduation = this._graduation / this._subgraduationCount;
      firstGraduation = subgraduation * (this._min / subgraduation >> 0);
      if (this._min < 0)
        firstGraduation -= subgraduation;
      while (firstGraduation < this._min) {
        firstGraduation += subgraduation;
      }
      gratuationCount = 1 + (this._max - this._min) / subgraduation >> 0;
      for (let i = 0; i < gratuationCount; i++) {
        let value = firstGraduation + i * subgraduation;
        if (value <= this._max) {
          Angle = (Math.PI - AngleAperture) / 2 + AngleAperture * (value - this._min) / (this._max - this._min);
          C = Math.cos(Angle);
          S = Math.sin(Angle);
          R1 = outerCoef * (radius - this._borderThickness / 2);
          R2 = (100 - this._subgraduationSize) * (outerCoef * (radius - this._borderThickness / 2)) / 100;
          g.DrawLineXY(this._subgraduationPen, xcenter - R1 * C, ycenter - R1 * S, xcenter - R2 * C, ycenter - R2 * S);
        }
      }
    }
    if (gratuationCount < circonference) {
      for (let i = 0; i < gratuationCount; i++) {
        let gvalue = firstGraduation + i * this._graduation;
        if (gvalue <= this._max) {
          Angle = (Math.PI - AngleAperture) / 2 + AngleAperture * (gvalue - this._min) / (this._max - this._min);
          C = Math.cos(Angle);
          S = Math.sin(Angle);
          R1 = outerCoef * (radius - this._borderThickness / 2);
          R2 = (100 - this._graduationSize) * (outerCoef * (radius - this._borderThickness / 2)) / 100;
          g.DrawLineXY(this._graduationPen, xcenter - R1 * C, ycenter - R1 * S, xcenter - R2 * C, ycenter - R2 * S);
          size = g.MeasureStringSF(gvalue.toString().trim(), this._graduationFont, 1e3, stringFormat4Sizing);
          let HalfDiagonal = 0.4 * Math.sqrt(size.width * size.width + size.height * size.height);
          let position = new YRectangle(xcenter - (R2 - HalfDiagonal) * C - size.width / 2 >> 0, ycenter - (R2 - HalfDiagonal) * S - size.height / 2 >> 0, (size.width >> 0) + 1, size.height >> 0);
          g.DrawStringRect(gvalue.toString(), this._graduationFont, this._graduationFont.brush, position, stringFormat);
        }
      }
    }
    if (this._borderThickness > 0 && this._path.length > 3)
      g.DrawPolygon(this._borderpen, this._path);
    this.drawAnnotationPanels(g, this._annotationPanels, w, h, true, mainViewPort);
    if (this._showNeedle) {
      if (this._needleValue != this._value) {
        let step = this._unitFactor * this._needleMaxSpeed * (this._max - this._min) / 100;
        if (Math.abs(this._value - this._needleValue) < step) {
          this._needleValue = this._value;
        } else if (this._needleValue < this.value) {
          this._needleValue += step;
        } else {
          this._needleValue -= step;
        }
      }
      let needlevalue = this._needleValue / this._unitFactor;
      let allowedOverflow = (this._max - this.min) * 0.05;
      if (needlevalue < this._min - allowedOverflow)
        needlevalue = this._min - allowedOverflow;
      if (needlevalue > this._max + allowedOverflow)
        needlevalue = this._max + allowedOverflow;
      Angle = (Math.PI - AngleAperture) / 2 + AngleAperture * (needlevalue - this._min) / (this._max - this._min);
      C = Math.cos(Angle);
      S = Math.sin(Angle);
      R1 = radius * this._needleLength1 / 100;
      R2 = radius * this._needleLength2 / 100;
      let R3 = radius * this._needleWidth / 200;
      let needlepath = new Array(4).fill(null);
      needlepath[0] = new PointF(xcenter - R1 * C, ycenter - R1 * S);
      needlepath[1] = new PointF(xcenter + R3 * S, ycenter - R3 * C);
      needlepath[2] = new PointF(xcenter + R2 * C, ycenter + R2 * S);
      needlepath[3] = new PointF(xcenter - R3 * S, ycenter + R3 * C);
      if (this._needleBrush == null)
        this._needleBrush = new YSolidBrush(this._needleColor);
      g.FillPolygon(this._needleBrush, needlepath);
      if (this._needleContourThickness > 0) {
        if (this._needleContourPen == null) {
          this._needleContourPen = new YPen(this._needleContourColor, this._needleContourThickness);
          this._needleContourPen.startCap = 2;
          this._needleContourPen.endCap = 2;
          this._needleContourPen.linejoin = YPen.LineJoin.Round;
        }
        let needlepath2 = new Array(5).fill(null);
        needlepath2[0] = needlepath[0];
        needlepath2[1] = needlepath[1];
        needlepath2[2] = needlepath[2];
        needlepath2[3] = needlepath[3];
        needlepath2[4] = needlepath[0];
        g.DrawLines(this._needleContourPen, needlepath2);
      }
    }
    this.DrawMessagePanels(g, w, h);
    return 0;
  }
  renderingPostProcessing() {
    if (this._needleValue != this._value)
      this.redraw();
  }
};

// obj/full/Renderer/YDigitalDisplay.js
var YDigitalDisplay = class extends YDataRenderer {
  get backgroundColor1() {
    return this._backgroundColor1;
  }
  set backgroundColor1(value) {
    this._backgroundColor1 = value;
    this._bgBrush = null;
    this.redraw();
  }
  get backgroundColor2() {
    return this._backgroundColor2;
  }
  set backgroundColor2(value) {
    this._backgroundColor2 = value;
    this._bgBrush = null;
    this.redraw();
  }
  get alternateValue() {
    return this._alternateValue;
  }
  set alternateValue(value) {
    this._alternateValue = value;
    this.redraw();
  }
  get valueFormater() {
    return this._valueFormater;
  }
  set valueFormater(value) {
    this._valueFormater = value;
    this.redraw();
  }
  get hrzAlignmentOfset() {
    return this._hrzAlignmentOfset;
  }
  set hrzAlignmentOfset(value) {
    this._hrzAlignmentOfset = value;
    this.redraw();
  }
  get hrzAlignment() {
    return this._hrzAlignment;
  }
  set hrzAlignment(value) {
    this._hrzAlignment = value;
    this.redraw();
  }
  get outOfRangeMin() {
    return this._outOfRangeMin;
  }
  set outOfRangeMin(value) {
    if (!Number.isNaN(value) && !Number.isNaN(this._outOfRangeMax) && !YDataRenderer.minMaxCheckDisabled) {
      if (value >= this._outOfRangeMax)
        throw new RangeError("Min cannot be greater than max (" + this._outOfRangeMax.toString() + ")");
    }
    this._outOfRangeMin = value;
    this.redraw();
  }
  get outOfRangeMax() {
    return this._outOfRangeMax;
  }
  set outOfRangeMax(value) {
    if (!Number.isNaN(value) && !Number.isNaN(this._outOfRangeMin) && !YDataRenderer.minMaxCheckDisabled) {
      if (value <= this._outOfRangeMin)
        throw new RangeError("Min cannot be less than max (" + this._outOfRangeMin.toString() + ")");
    }
    this._outOfRangeMax = value;
    this.redraw();
  }
  get outOfRangeColor() {
    return this._outOfRangeColor;
  }
  set outOfRangeColor(value) {
    this._outOfRangeColor = value;
    this.redraw();
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value;
    this.redraw();
  }
  get font() {
    return this._font;
  }
  constructor(UIContainer, logFunction) {
    super(UIContainer, logFunction);
    this._bgBrush = null;
    this._backgroundColor1 = YColor.Black;
    this._backgroundColor2 = YColor.FromArgb(255, 48, 48, 48);
    this._alternateValue = null;
    this._valueFormater = null;
    this._hrzAlignmentOfset = 5;
    this._hrzAlignment = YDigitalDisplay.HrzAlignment.DECIMAL;
    this._outOfRangeMin = Number.NaN;
    this._outOfRangeMax = Number.NaN;
    this._outOfRangeColor = YColor.Red;
    this._value = 0;
    this._font = new YFont(this, this, Math.min(UIContainer.width / 5, UIContainer.height / 2), null);
    this._font.color = YColor.LightGreen;
    this.resizeRule = Proportional.ResizeRule.RELATIVETOBOTH;
  }
  clearCachedObjects() {
    if (this.font != null)
      this.font.ResetFont(null);
    this._bgBrush = null;
  }
  Render(g, w, h) {
    let mainViewPort = new ViewPortSettings();
    mainViewPort.Lmargin = 0;
    mainViewPort.Rmargin = 0;
    mainViewPort.Tmargin = 0;
    mainViewPort.Bmargin = 0;
    g.SmoothingMode = YSmoothingMode.HighQuality;
    g.TextRenderingHint = YTextRenderingHint.AntiAlias;
    let stringFormat = new YStringFormat(16384);
    stringFormat.Alignment = 1;
    stringFormat.LineAlignment = 1;
    if (this._bgBrush == null) {
      this._bgBrush = new YLinearGradientBrush(this._backgroundColor1, this._backgroundColor2);
    }
    g.FillRectangleXYHW(this._bgBrush, 0, 0, w, h);
    this.drawAnnotationPanels(g, this._annotationPanels, w, h, false, mainViewPort);
    if (mainViewPort.Tmargin >= 20)
      mainViewPort.Tmargin -= 10;
    if (mainViewPort.Bmargin >= 20)
      mainViewPort.Bmargin -= 10;
    g.TextRenderingHint = YTextRenderingHint.AntiAlias;
    let availWidth = w - (mainViewPort.Lmargin + mainViewPort.Rmargin);
    let availHeight = h - (mainViewPort.Tmargin + mainViewPort.Bmargin);
    if (availWidth > 10 && availHeight > 10) {
      let svalue;
      if (this._alternateValue == null) {
        svalue = this._valueFormater == null ? this.value.toFixed(3) : this._valueFormater(this, this.value);
        if (!Number.isNaN(this._outOfRangeMin) && this.value < this._outOfRangeMin) {
          this.font.alternateColor = this._outOfRangeColor;
        } else if (!Number.isNaN(this._outOfRangeMax) && this.value > this._outOfRangeMax) {
          this.font.alternateColor = this._outOfRangeColor;
        } else {
          this.font.alternateColor = null;
        }
      } else {
        this._font.alternateColor = null;
        svalue = this._alternateValue;
      }
      let size = g.MeasureStringSF(svalue, this.font, 1e4, stringFormat);
      let pos;
      let align = this._hrzAlignment;
      if (this._alternateValue != null && align == YDigitalDisplay.HrzAlignment.DECIMAL)
        align = YDigitalDisplay.HrzAlignment.RIGHT;
      if (align == YDigitalDisplay.HrzAlignment.DECIMAL && svalue.indexOf(".") < 0)
        align = YDigitalDisplay.HrzAlignment.RIGHT;
      switch (align) {
        case YDigitalDisplay.HrzAlignment.LEFT:
          pos = new YRectangle(mainViewPort.Lmargin + (availWidth * this.hrzAlignmentOfset / 100 >> 0), mainViewPort.Tmargin + (availHeight - size.height) / 2 >> 0, size.width + 1 >> 0, size.height + 1 >> 0);
          g.DrawStringRect(svalue, this.font, this.font.brush, pos, stringFormat);
          break;
        case YDigitalDisplay.HrzAlignment.CENTER:
          pos = new YRectangle(mainViewPort.Lmargin + (availWidth - size.width) / 2 >> 0, mainViewPort.Tmargin + (availHeight - size.height) / 2 >> 0, size.width + 1 >> 0, size.height + 1 >> 0);
          g.DrawStringRect(svalue, this.font, this.font.brush, pos, stringFormat);
          break;
        case YDigitalDisplay.HrzAlignment.DECIMAL:
          let left = "";
          let p = svalue.lastIndexOf(",");
          if (p < 0)
            p = svalue.lastIndexOf(".");
          if (p >= 0) {
            left = svalue.substring(0, p + 1);
          } else {
            p = 0;
            while (p < svalue.length && (svalue[p] >= "0" && svalue[p] <= "9" || svalue[p] == "-" || svalue[p] == "'" || svalue[p] == " ")) {
              p++;
            }
            left = svalue.substring(0, p);
          }
          let lsize = g.MeasureStringSF(left, this.font, 1e4, stringFormat);
          pos = new YRectangle(mainViewPort.Lmargin + (availWidth - lsize.width - availWidth * this.hrzAlignmentOfset / 100) >> 0, mainViewPort.Tmargin + (availHeight - size.height) / 2 >> 0, size.width + 1 >> 0, size.height + 1 >> 0);
          g.DrawStringRect(svalue, this.font, this.font.brush, pos, stringFormat);
          break;
        case YDigitalDisplay.HrzAlignment.RIGHT:
          pos = new YRectangle(mainViewPort.Lmargin + (availWidth - size.width - availWidth * this.hrzAlignmentOfset / 100) >> 0, mainViewPort.Tmargin + (availHeight - size.height) / 2 >> 0, size.width + 1 >> 0, size.height + 1 >> 0);
          g.DrawStringRect(svalue, this.font, this.font.brush, pos, stringFormat);
          break;
      }
    }
    this.drawAnnotationPanels(g, this._annotationPanels, w, h, true, mainViewPort);
    this.DrawMessagePanels(g, w, h);
    return 0;
  }
};
(function(YDigitalDisplay2) {
  class HrzAlignmentEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, HrzAlignment);
    }
  }
  YDigitalDisplay2.HrzAlignmentEnumItem = HrzAlignmentEnumItem;
  class HrzAlignment extends YEnum {
  }
  HrzAlignment.LEFT = new HrzAlignmentEnumItem("LEFT", "Left");
  HrzAlignment.CENTER = new HrzAlignmentEnumItem("CENTER", "Center");
  HrzAlignment.DECIMAL = new HrzAlignmentEnumItem("DECIMAL", "Decimal");
  HrzAlignment.RIGHT = new HrzAlignmentEnumItem("RIGHT", "Right");
  YDigitalDisplay2.HrzAlignment = HrzAlignment;
})(YDigitalDisplay || (YDigitalDisplay = {}));

// obj/full/Renderer/YGraph.js
var SUMMARY_GRANULARITY = 100;
var pointXY = class {
  constructor(X, Y) {
    this.x = X === void 0 ? 0 : X;
    this.y = Y === void 0 ? 0 : Y;
  }
  clone() {
    return new pointXY(this.x, this.y);
  }
};
var pointsSummary = class {
  constructor(X1, X2, YMIN, YMAX) {
    this.x1 = X1;
    this.x2 = X2;
    this.ymin = YMIN;
    this.ymax = YMAX;
  }
  clone() {
    return new pointsSummary(this.x1, this.x2, this.ymin, this.ymin);
  }
};
var TimeConverterParseResult = class {
  constructor() {
    this.success = false;
    this.result = 0;
  }
};
var TimeResolution = class {
  constructor() {
    this.step = 0;
    this.format = 0;
  }
};
var YDate = class extends Date {
  ToString(format) {
    let res = "";
    let ampm = "";
    if (format & YDate.D)
      res = res + this.getDate() + " ";
    if (format & YDate.M)
      res = res + YDate.months[this.getMonth()] + " ";
    if (format & YDate.YY) {
      let y = this.getFullYear().toString();
      res = res + y.substr(y.length - 2) + " ";
    } else if (format & YDate.YYYY) {
      let y = this.getFullYear().toString();
      res = res + y + " ";
    }
    if (format & YDate.CR)
      res = res + "\n";
    if (format & YDate.h) {
      if (YDate.use24Hformat) {
        let h = "0" + this.getHours().toString();
        res = res + h.substring(h.length - 2);
        if (!(format & YDate.m))
          res = res + "H";
      } else {
        let hour = this.getHours();
        ampm = "AM";
        if (hour > 11)
          ampm = "PM";
        if (hour > 12)
          hour = hour - 12;
        if (hour == 0)
          hour = 12;
        res = res + hour.toString();
      }
    }
    if (format & YDate.m) {
      let m = "0" + this.getMinutes().toString();
      res = res + ":" + m.substring(m.length - 2);
    }
    if (format & YDate.s) {
      let s = "0" + this.getSeconds().toString();
      res = res + ":" + s.substring(s.length - 2);
    }
    if (format & YDate.ms1) {
      let ms = "00" + this.getMilliseconds().toString();
      res = res + "." + ms.substring(ms.length - 3).substring(1);
    } else if (format & YDate.ms01) {
      let ms = "00" + this.getMilliseconds().toString();
      res = res + "." + ms.substring(ms.length - 3).substring(2);
    } else if (format & YDate.ms001) {
      let ms = "00" + this.getMilliseconds().toString();
      res = res + "." + ms.substring(ms.length - 3).substring(3);
    }
    if (format & YDate.h && !YDate.use24Hformat) {
      res = res + ampm;
    }
    return res;
  }
};
YDate.D = 1;
YDate.DD = 2;
YDate.M = 4;
YDate.YY = 8;
YDate.h = 16;
YDate.m = 32;
YDate.s = 64;
YDate.ms1 = 128;
YDate.ms01 = 256;
YDate.ms001 = 512;
YDate.CR = 1024;
YDate.isRelative = 2048;
YDate.YYYY = 4096;
YDate.d = new Date().toLocaleTimeString().toUpperCase();
YDate.use24Hformat = YDate.d.indexOf("AM") < 0 && YDate.d.indexOf("PM") < 0;
YDate.months = ["jan", "feb", "mar", "apr", "may", "jun", "jul", "aug", "sep", "oct", "nov", "dec"];
var TimeConverter = class {
  static UTCNow() {
    return new YDate();
  }
  static ToUnixTime(datetime) {
    return datetime.getTime() / 1e3;
  }
  static FromUnixTime(unixtime) {
    let t = new YDate();
    t.setTime(unixtime * 1e3);
    return t;
  }
  static tryParseStringToAbsDateTime(str) {
    let res = new TimeConverterParseResult();
    res.success = false;
    let date = new Date();
    let year = date.getFullYear();
    let month = date.getMonth();
    let day = date.getDate();
    let hours = 0;
    let minutes = 0;
    let seconds = 0;
    str = str.trim();
    while (str.indexOf("  ") > 0) {
      str = str.replace("  ", " ");
    }
    let dateFound = false;
    let timeFound = false;
    let it = str.split(" ");
    if (it.length <= 0)
      return res;
    for (let i = 0; i < it.length && i < 2; i++) {
      if (it[i].indexOf("-") > 0) {
        let tokens = it[i].split("-");
        if (tokens.length == 1) {
          day = parseInt(tokens[0]);
        } else if (tokens.length == 2) {
          day = parseInt(tokens[1]);
          month = parseInt(tokens[0]) - 1;
        } else {
          day = parseInt(tokens[2]);
          month = parseInt(tokens[1]) - 1;
          year = parseInt(tokens[0]);
        }
        dateFound = true;
      } else if (it[i].indexOf(":") > 0) {
        let tokens = it[i].split(":");
        if (tokens.length == 1) {
          hours = parseInt(tokens[0]);
        } else if (tokens.length == 2) {
          hours = parseInt(tokens[0]);
          minutes = parseInt(tokens[1]);
        } else {
          hours = parseInt(tokens[0]);
          minutes = parseInt(tokens[1]);
          seconds = parseFloat(tokens[2]);
        }
        timeFound = true;
      }
    }
    if (!timeFound && !dateFound)
      return res;
    if (isNaN(year) || isNaN(month) || isNaN(day) || isNaN(hours) || isNaN(minutes) || isNaN(seconds))
      return res;
    date.setFullYear(year, month, day);
    date.setHours(hours, minutes, seconds >> 0, 1e3 * (seconds % 1) >> 0);
    res.result = date.getTime() / 1e3;
    res.success = true;
    return res;
  }
  static tryParseStringToSecTimeSpan(st) {
    let res = new TimeConverterParseResult();
    let d = 0;
    st = st.toUpperCase();
    let n = st.indexOf("D");
    if (n > 0) {
      d = parseFloat(st.substring(0, n));
      if (isNaN(d)) {
        return res;
      }
      res.result += +d * 86400;
      if (n == st.length - 1) {
        res.success = true;
        return res;
      }
      st = st.substring(n + 1);
    }
    n = st.indexOf("H");
    if (n > 0) {
      d = parseFloat(st.substring(0, n));
      if (isNaN(d)) {
        return res;
      }
      res.result += d * 3600;
      if (n == st.length - 1) {
        res.success = true;
        return res;
      }
      st = st.substring(n + 1);
    }
    n = st.indexOf("M");
    if (n > 0) {
      d = parseFloat(st.substring(0, n));
      if (isNaN(d)) {
        return res;
      }
      res.result += d * 60;
      if (n == st.length - 1) {
        res.success = true;
        return res;
      }
      st = st.substring(n + 1);
    }
    n = st.indexOf("S");
    if (n < 0)
      n = st.length;
    d = parseFloat(st.substring(0, n));
    if (isNaN(d)) {
      return res;
    }
    res.result += d;
    res.success = true;
    return res;
  }
  static secTimeSpanToString(timespan, resolution) {
    let started = false;
    let res = "";
    if (timespan < 0) {
      res = "-";
      timespan = -timespan;
    }
    if (timespan >= 86400) {
      let d = timespan / 86400 >> 0;
      res = res + d.toString() + "d";
      timespan -= 86400 * d;
      started = true;
    }
    if (resolution >= 86400)
      return res != "" ? res : "0d";
    if (timespan >= 3600) {
      let d = timespan / 3600 >> 0;
      let ds = d.toString();
      if (started && ds.length == 1)
        ds = "0" + ds;
      res = res + ds + "h";
      timespan -= 3600 * d;
      started = true;
    }
    if (resolution >= 3600)
      return res != "" ? res : "0h";
    if (timespan < resolution)
      return res != "" ? res : "0h";
    if (timespan >= 60) {
      let d = timespan / 60 >> 0;
      let ds = d.toString();
      if (started && ds.length == 1)
        ds = "0" + ds;
      res = res + ds + "m";
      timespan -= 60 * d;
      started = true;
    }
    if (resolution >= 60)
      return res != "" ? res : "0m";
    if (timespan < resolution)
      return res != "" ? res : "0m";
    timespan = Math.round(timespan * 100) / 100;
    let s;
    if (resolution > 0.1) {
      s = timespan.toFixed(0);
    } else if (resolution > 0.01) {
      s = timespan.toFixed(1);
    } else if (resolution > 1e-3) {
      s = timespan.toFixed(2);
    } else {
      s = timespan.toString();
    }
    if (started && timespan < 10)
      s = "0" + s;
    res = res + s + "s";
    return res;
  }
  static RelativeFormat(dataDeltaTime, viewportDeltaTime, resolution) {
    let ShowSecondsTenth = true;
    let ShowSecondsHundredth = true;
    let ShowSeconds = true;
    let ShowMinutes = false;
    let ShowHours = false;
    let ShowDays = false;
    if (dataDeltaTime <= 0.1) {
      ShowSecondsHundredth = true;
    }
    if (dataDeltaTime <= 1) {
      ShowSecondsTenth = true;
    }
    if (dataDeltaTime >= 60 || viewportDeltaTime >= 60) {
      ShowMinutes = true;
    }
    if (dataDeltaTime >= 3600 || viewportDeltaTime >= 3600) {
      ShowHours = true;
    }
    if (dataDeltaTime >= 86400 || viewportDeltaTime >= 86400) {
      ShowDays = true;
    }
    if (resolution >= 0.1)
      ShowSecondsHundredth = false;
    if (resolution >= 1)
      ShowSecondsTenth = false;
    if (resolution >= 60)
      ShowSeconds = false;
    if (resolution >= 3600)
      ShowMinutes = false;
    if (resolution >= 86400)
      ShowHours = false;
    let format = 0;
    format |= YDate.isRelative;
    if (ShowSecondsTenth)
      format |= YDate.ms1;
    if (ShowSecondsHundredth)
      format |= YDate.ms01;
    if (ShowSeconds)
      format |= YDate.s;
    if (ShowMinutes)
      format |= YDate.m;
    if (ShowHours)
      format |= YDate.h;
    if (ShowDays)
      format |= YDate.D;
    return format;
  }
  static BestTimeformat(dataDeltaTime, viewportDeltaTime, tref) {
    let res = new TimeResolution();
    let ShowSecondsTenth = true;
    let ShowSecondsHundredth = true;
    let ShowSeconds = true;
    let ShowMinutes = false;
    let ShowHours = false;
    let ShowDays = false;
    let ShowMonths = false;
    let ShowYears = false;
    if (viewportDeltaTime <= 0.1) {
      res.step = 0.01;
    } else if (viewportDeltaTime <= 1) {
      res.step = 0.1;
    } else if (viewportDeltaTime <= 2) {
      res.step = 0.2;
    } else if (viewportDeltaTime <= 5) {
      res.step = 0.5;
    } else if (viewportDeltaTime <= 10) {
      res.step = 1;
    } else if (viewportDeltaTime <= 20) {
      res.step = 2;
    } else if (viewportDeltaTime <= 30) {
      res.step = 3;
    } else if (viewportDeltaTime <= 40) {
      res.step = 4;
    } else if (viewportDeltaTime <= 60) {
      res.step = 5;
    } else if (viewportDeltaTime <= 120) {
      res.step = 10;
    } else if (viewportDeltaTime <= 300) {
      res.step = 30;
    } else if (viewportDeltaTime <= 900) {
      res.step = 60;
    } else if (viewportDeltaTime <= 1800) {
      res.step = 180;
    } else if (viewportDeltaTime <= 3600) {
      res.step = 300;
    } else if (viewportDeltaTime <= 7200) {
      res.step = 600;
    } else if (viewportDeltaTime <= 14e3) {
      res.step = 900;
    } else if (viewportDeltaTime <= 21600) {
      res.step = 1800;
    } else if (viewportDeltaTime <= 43200) {
      res.step = 3600;
    } else if (viewportDeltaTime <= 86400) {
      res.step = 7200;
    } else if (viewportDeltaTime <= 2 * 86400) {
      res.step = 2 * 7200;
    } else if (viewportDeltaTime <= 4 * 86400) {
      res.step = 4 * 7200;
    } else if (viewportDeltaTime <= 7 * 86400) {
      res.step = 86400;
    } else if (viewportDeltaTime <= 14 * 86400) {
      res.step = 2 * 86400;
    } else if (viewportDeltaTime <= 28 * 86400) {
      res.step = 4 * 86400;
    } else if (viewportDeltaTime <= 56 * 86400) {
      res.step = 7 * 86400;
    } else if (viewportDeltaTime <= 112 * 86400) {
      res.step = 14 * 86400;
    } else if (viewportDeltaTime <= 224 * 86400) {
      res.step = 31 * 86400;
    } else if (viewportDeltaTime <= 448 * 86400) {
      res.step = 62 * 86400;
    } else if (viewportDeltaTime <= 896 * 86400) {
      res.step = 93 * 86400;
    } else {
      res.step = 365 * 86400;
    }
    if (tref == TimeConverter.TimeReference.ABSOLUTE) {
      ShowSecondsHundredth = true;
      ShowSecondsTenth = true;
      ShowMinutes = true;
      ShowHours = true;
      ShowDays = dataDeltaTime > 86400;
      ShowMonths = dataDeltaTime > 86400;
      ShowYears = dataDeltaTime > 28 * 6 * 86400;
      if (res.step >= 0.1)
        ShowSecondsHundredth = false;
      if (res.step >= 1)
        ShowSecondsTenth = false;
      if (res.step >= 60)
        ShowSeconds = false;
      if (res.step >= 3600)
        ShowMinutes = false;
      if (res.step >= 86400)
        ShowHours = false;
      if (res.step >= 31 * 86400)
        ShowDays = false;
      if (res.step >= 365 * 86400)
        ShowMonths = false;
      res.format = 0;
      if (ShowSecondsHundredth)
        res.format |= YDate.ms01;
      if (ShowSecondsTenth)
        res.format |= YDate.ms1;
      if (ShowSeconds)
        res.format |= YDate.s;
      if (ShowMinutes)
        res.format = res.format |= YDate.m;
      if (ShowHours)
        res.format = res.format |= YDate.h;
      if (res.format != 0 && (ShowDays || ShowMonths))
        res.format |= YDate.CR;
      if (ShowDays)
        res.format |= YDate.D;
      if (ShowMonths)
        res.format |= YDate.M;
      if (ShowYears)
        res.format |= YDate.YY;
      if (res.format == YDate.YY)
        res.format = YDate.YYYY;
    } else {
      res.format = TimeConverter.RelativeFormat(dataDeltaTime, viewportDeltaTime, res.step);
    }
    return res;
  }
};
(function(TimeConverter2) {
  class TimeReferenceEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, TimeReference);
    }
  }
  TimeConverter2.TimeReferenceEnumItem = TimeReferenceEnumItem;
  class TimeReference extends YEnum {
  }
  TimeReference.ABSOLUTE = new TimeReferenceEnumItem("ABSOLUTE", "Absolute");
  TimeReference.RELATIVE = new TimeReferenceEnumItem("RELATIVE", "Relative to first data");
  TimeConverter2.TimeReference = TimeReference;
})(TimeConverter || (TimeConverter = {}));
var MinMax = class {
  constructor(minimum, maximum) {
    this.Min = 0;
    this.Max = 0;
    this.Min = minimum;
    this.Max = maximum;
  }
};
var MinMaxHandler = class {
  static extend(M, factor) {
    if (isNaN(M.Min))
      return M;
    let delta = M.Max - M.Min;
    return new MinMax(M.Min - delta * (factor - 1) / 2, M.Max + delta * (factor - 1) / 2);
  }
  static DefaultValue(value1, value2) {
    if (typeof value2 === "undefined") {
      if (typeof value1 === "undefined")
        return new MinMax(Number.NaN, Number.NaN);
      return new MinMax(value1, value1);
    }
    if (typeof value1 === "undefined")
      return new MinMax(value2, value2);
    if (value2 < value1)
      throw new RangeError("MinMax invalid parameters (" + value1.toString() + ">" + value2.toString());
    return new MinMax(value1, value2);
  }
  static isDefined(v) {
    return !isNaN(v.Min);
  }
  static Combine(M1, M2) {
    if (isNaN(M1.Min))
      return new MinMax(M2.Min, M2.Max);
    if (isNaN(M2.Min))
      return new MinMax(M1.Min, M1.Max);
    let res = new MinMax(M2.Min, M2.Max);
    if (M1.Min < res.Min)
      res.Min = M1.Min;
    if (M1.Max < res.Min)
      res.Min = M1.Max;
    if (M1.Min > res.Max)
      res.Max = M1.Min;
    if (M1.Max > res.Max)
      res.Max = M1.Max;
    return res;
  }
  static CombineWithNumber(M1, value) {
    if (isNaN(M1.Min))
      return new MinMax(value, value);
    if (value < M1.Min)
      return new MinMax(value, M1.Max);
    if (value > M1.Max)
      return new MinMax(M1.Min, value);
    return new MinMax(M1.Min, M1.Max);
  }
};
var DataSegment = class {
  static ArrayCopy(sourceArray, sourceIndex, destinationArray, destinationIndex, length) {
    for (let i = 0; i < length; i++) {
      destinationArray[destinationIndex + i] = sourceArray[sourceIndex + i].clone();
    }
  }
  constructor(p) {
    this.data = [];
    this.count = 0;
    if (p instanceof Array) {
      this.data = new Array(p.length);
      DataSegment.ArrayCopy(p, 0, this.data, 0, p.length);
      this.count = p.length;
    } else if (p instanceof pointXY) {
      this.data = new Array(DataSegment.SegmentGranularity);
      this.data[0] = p;
      this.count = 1;
    } else {
      throw new Error("invalid constructor paramter type");
    }
  }
  grow() {
    let targetCount = this.data.length + DataSegment.SegmentGranularity;
    while (this.data.length < targetCount) {
      this.data.push(null);
    }
  }
};
DataSegment.SegmentGranularity = 1e3;
var Summary = class {
  getBufferpoint() {
    if (this.vtlPtCount <= 0)
      return null;
    return new pointsSummary(this.Xmin, this.Xmax, this.Ymin, this.Ymax);
  }
  Dump() {
    var _a, _b, _c, _d;
    console.log("Summary level" + this.selfIndex + ", " + this.segments.length + " segments, " + this.totalpoints + " points");
    let lastx = 0;
    for (let s = 0; s < this.segments.length; s++) {
      console.log("  segment " + s);
      for (let i = 0; i < this.segments[s].ptCount; i++) {
        console.log(((_a = this.segments[s].data[i]) === null || _a === void 0 ? void 0 : _a.x1) + "," + ((_b = this.segments[s].data[i]) === null || _b === void 0 ? void 0 : _b.ymin) + " delataX=" + Math.round(this.segments[s].data[i].x1 - lastx));
        console.log(((_c = this.segments[s].data[i]) === null || _c === void 0 ? void 0 : _c.x2) + "," + ((_d = this.segments[s].data[i]) === null || _d === void 0 ? void 0 : _d.ymax) + " delataX=" + Math.round(this.segments[s].data[i].x2 - this.segments[s].data[i].x1));
        lastx = this.segments[s].data[i].x2;
      }
    }
  }
  constructor(index, array, pointSize) {
    this.segments = [];
    this.totalpoints = 0;
    this.Xmin = 0;
    this.Xmax = 0;
    this.Ymin = 0;
    this.Ymax = 0;
    this.vtlPtCount = 0;
    this.pointSize = 0;
    this.isLast = false;
    this.newSummaryLevelTrigger = 0;
    this.selfIndex = index;
    this.selfArray = array;
    this.pointSize = pointSize;
    this.isLast = true;
  }
  processSegments(segments) {
    if (segments.length <= 0)
      return;
    let last = segments.length - 1;
    this.Xmin = segments[last].data[0].x;
    this.Xmax = segments[last].data[0].x;
    this.Ymin = segments[last].data[0].y;
    this.Ymax = segments[last].data[0].y;
    this.totalpoints = 0;
    this.vtlPtCount = 0;
    for (let s = last; s >= 0; s--) {
      for (let i = 0; i < segments[s].data.length; i++) {
        let p = segments[s].data[i];
        if (p.x < this.Ymin)
          this.Ymin = p.y;
        if (p.x > this.Ymax)
          this.Ymax = p.y;
        this.Xmax = p.x;
        this.vtlPtCount++;
        if (this.vtlPtCount >= this.pointSize) {
          this.flush(false);
          this.Xmin = p.x;
          this.Ymin = p.y;
          this.Ymax = p.y;
        }
      }
      if (s > 0) {
        let len = segments[s].data.length;
        let p2 = segments[s - 1].data[0];
        let p1 = segments[s].data[len - 1];
        let lastDelta = 1;
        if (len > 1) {
          let p0 = segments[s].data[len - 2];
          lastDelta = p1.x - p0.x;
        }
        if (p2.x - p1.x > this.pointSize * lastDelta) {
          this.flush(false);
          this.Xmin = p2.x;
          this.Ymin = p2.y;
          this.Ymax = p2.y;
          this.addNewEmptySegment();
        }
      }
    }
    if (this.totalpoints > 1) {
      let it = new Summary(this.selfIndex + 1, this.selfArray, this.pointSize * SUMMARY_GRANULARITY);
      this.selfArray.push(it);
      this.isLast = false;
      it.processSegments(segments);
    }
  }
  addNewLevel() {
    let newIndex = this.selfArray.length;
    if (Summary.DBG)
      console.log("--- ADDING NEW LEVEL " + newIndex);
    let it = new Summary(newIndex, this.selfArray, this.pointSize * SUMMARY_GRANULARITY);
    this.selfArray.push(it);
    this.isLast = false;
    let _xmin = this.segments[0].data[0].x1;
    let _xmax = this.segments[0].data[0].x2;
    let _ymin = this.segments[0].data[0].ymin;
    let _ymax = this.segments[0].data[0].ymax;
    let _count = 0;
    for (let s = 0; s < this.segments.length; s++) {
      for (let i = 0; i < this.segments[s].ptCount; i++) {
        _xmax = this.segments[s].data[i].x2;
        if (this.segments[s].data[i].ymin < _ymin)
          _ymin = this.segments[s].data[i].ymin;
        if (this.segments[s].data[i].ymin > _ymax)
          _ymax = this.segments[s].data[i].ymin;
      }
      _count += this.segments[s].ptCount;
      if (s < this.segments.length - 1) {
        if (this.segments[s].ptCount > 2) {
          let lastIndex = this.segments[s].ptCount - 1;
          let lastDelta = this.segments[s].data[lastIndex].x1 - this.segments[s].data[lastIndex - 1].x2;
          if (this.segments[s + 1].data[0].x1 - this.segments[s].data[this.segments[s].ptCount - 1].x2 > lastDelta * SUMMARY_GRANULARITY) {
            it.addNewEmptySegment();
            _xmin = this.segments[s + 1].data[0].x1;
            _xmax = this.segments[s + 1].data[0].x2;
            _ymin = this.segments[s + 1].data[0].ymin;
            _ymax = this.segments[s + 1].data[0].ymax;
            _count = 0;
          }
        }
      }
    }
    if (_count != 0) {
      it.addNewSinglePointSegment(_xmin, _xmax, _ymin, _ymax, _count);
    }
  }
  addNewSinglePointSegment(xmin, xmax, ymin, ymax, _count) {
    if (Summary.DBG)
      console.log(" ===> level " + this.selfIndex + " new single point segment");
    this.segments.push(new DataSummarySegment(new pointsSummary(xmin, xmax, ymin, ymax), _count));
  }
  addNewEmptySegment() {
    if (Summary.DBG)
      console.log(" ===> level " + this.selfIndex + " new empty segment");
    this.segments.push(new DataSummarySegment(null, null));
  }
  addSequentialPoint(p, maxHoleSize) {
    if (Summary.DBG)
      console.log(" ADD Point, LEVEL " + this.selfIndex + " Vtl point = " + this.vtlPtCount + "/" + this.pointSize + " TOTAL Points= " + this.totalpoints);
    if (this.isLast && this.totalpoints >= SUMMARY_GRANULARITY)
      this.addNewLevel();
    if (this.vtlPtCount == 0) {
      this.Xmin = p.x;
      this.Xmax = p.x;
      this.Ymin = p.y;
      this.Ymax = p.y;
      this.vtlPtCount = 1;
      if (Summary.DBG) {
        if (this.selfIndex == 1)
          console.log(" --> added 1srt virtual pt vtlPtCount=" + this.vtlPtCount + "/" + this.pointSize);
      }
      if (!this.isLast)
        this.selfArray[this.selfIndex + 1].addSequentialPoint(p, maxHoleSize * SUMMARY_GRANULARITY);
      return;
    } else {
      if (Summary.DBG)
        console.log(" --> level " + this.selfIndex + " delta = " + (p.x - this.Xmax) + "/" + maxHoleSize);
      if (maxHoleSize > 0 && p.x - this.Xmax > maxHoleSize) {
        if (Summary.DBG)
          console.log(" --> level " + this.selfIndex + " hole detected");
        this.flush(false);
        this.addNewEmptySegment();
        this.Xmin = p.x;
        this.Xmax = p.x;
        this.Ymin = p.y;
        this.Ymax = p.y;
        this.vtlPtCount = 1;
        if (!this.isLast)
          this.selfArray[this.selfIndex + 1].addSequentialPoint(p, maxHoleSize * SUMMARY_GRANULARITY);
        return;
      }
      if (p.y < this.Ymin)
        this.Ymin = p.y;
      if (p.y > this.Ymax)
        this.Ymax = p.y;
      this.Xmax = p.x;
      this.vtlPtCount++;
      if (Summary.DBG) {
        if (this.selfIndex == 1)
          console.log(" --> level " + this.selfIndex + " added subsequent virtual pt vtlPtCount=" + this.vtlPtCount + "/" + this.pointSize);
      }
      if (this.vtlPtCount >= this.pointSize) {
        if (Summary.DBG) {
          if (this.selfIndex == 1)
            console.log(" --> level " + this.selfIndex + " flushing");
        }
        this.flush(false);
      }
    }
    if (!this.isLast)
      this.selfArray[this.selfIndex + 1].addSequentialPoint(p, maxHoleSize * SUMMARY_GRANULARITY);
  }
  flush(forceNewSegment) {
    if (this.segments.length == 0 || forceNewSegment)
      this.segments.push(new DataSummarySegment(null, null));
    let lastsegment = this.segments[this.segments.length - 1];
    lastsegment.data[lastsegment.ptCount] = new pointsSummary(this.Xmin, this.Xmax, this.Ymin, this.Ymax);
    this.totalpoints++;
    lastsegment.ptCount++;
    this.vtlPtCount = 0;
  }
};
Summary.DBG = false;
var DataSummarySegment = class {
  static ArrayCopy(sourceArray, sourceIndex, destinationArray, destinationIndex, length) {
    for (let i = 0; i < length; i++) {
      destinationArray[destinationIndex + i] = sourceArray[sourceIndex + i].clone();
    }
  }
  constructor(p, virtualPointCount) {
    this.data = [];
    this.ptCount = 0;
    if (p instanceof Array) {
      this.data = new Array(p.length);
      DataSummarySegment.ArrayCopy(p, 0, this.data, 0, p.length);
      this.ptCount = p.length;
    } else if (p instanceof pointsSummary) {
      this.data = new Array(DataSummarySegment.SegmentGranularity);
      this.data[0] = p;
      this.ptCount = 1;
    } else if (p == null) {
      this.data = new Array(DataSummarySegment.SegmentGranularity);
      this.ptCount = 0;
    }
  }
  grow() {
    let targetCount = this.data.length + DataSummarySegment.SegmentGranularity;
    while (this.data.length < targetCount) {
      this.data.push(null);
    }
  }
};
DataSummarySegment.SegmentGranularity = 1e3;
var DataSerie = class {
  get userData() {
    return this._userData;
  }
  set userData(value) {
    this._userData = value;
  }
  static get MaxPointsPerSeries() {
    return DataSerie._MaxPointsPerSeries;
  }
  static set MaxPointsPerSeries(value) {
    DataSerie._MaxPointsPerSeries = value;
  }
  get timeRange() {
    return this._timeRange;
  }
  get valueRange() {
    return this._valueRange;
  }
  constructor(parent) {
    this.totalPointCount = 0;
    this._userData = null;
    this._yAxisIndex = 0;
    this._pen = null;
    this._legendPen = null;
    this._brush = null;
    this._navigatorpen = null;
    this._visible = true;
    this._disabled = false;
    this._color = YColor.Black;
    this._thickness = 1;
    this._legend = "";
    this._unit = "";
    this.segments = [];
    this.summaries = null;
    if (parent.yAxes.length <= 0)
      throw new Error("Define at least one yAxis");
    this._timeRange = MinMaxHandler.DefaultValue();
    this._valueRange = MinMaxHandler.DefaultValue();
    this.parent = parent;
  }
  get yAxisIndex() {
    return this._yAxisIndex;
  }
  set yAxisIndex(value) {
    if (value >= this.parent.yAxes.length)
      throw new RangeError("No such yAxis (" + value.toString() + ")");
    this._yAxisIndex = value;
    this.parent.yAxes[this._yAxisIndex].AutoShow();
  }
  get pen() {
    if (this._pen == null) {
      this._pen = new YPen(this._color, this._thickness);
      this._pen.endCap = 2;
      this._pen.linejoin = YPen.LineJoin.Round;
    }
    return this._pen;
  }
  get legendPen() {
    if (this._legendPen == null) {
      this._legendPen = new YPen(this._color, this._thickness * this.parent.legendPanel.traceWidthFactor);
    }
    return this._legendPen;
  }
  resetlegendPen() {
    this._legendPen = null;
  }
  get brush() {
    if (this._brush == null)
      this._brush = new YSolidBrush(this._color);
    return this._brush;
  }
  get navigatorpen() {
    if (this._navigatorpen == null) {
      this._navigatorpen = new YPen(YColor.FromArgb(100, this._color.red, this._color.green, this._color.blue), 1);
    }
    return this._navigatorpen;
  }
  get visible() {
    return this._visible;
  }
  set visible(value) {
    this._visible = value;
    this.parent.redraw();
  }
  get disabled() {
    return this._disabled;
  }
  set disabled(value) {
    this._disabled = value;
    this.parent.redraw();
  }
  get color() {
    return this._color;
  }
  set color(value) {
    this._color = value;
    this._pen = null;
    this._legendPen = null;
    this._brush = null;
    this._navigatorpen = null;
    this.parent.redraw();
  }
  get thickness() {
    return this._thickness;
  }
  set thickness(value) {
    if (value < 0)
      throw new RangeError("Thickness must be a positive value");
    this._thickness = value;
    this._pen = null;
    this._legendPen = null;
    this.parent.redraw();
  }
  get legend() {
    return this._legend;
  }
  set legend(value) {
    this._legend = value;
    this.parent.redraw();
  }
  get unit() {
    return this._unit;
  }
  set unit(value) {
    this._unit = value;
    this.parent.redraw();
  }
  AddNewSegment(p) {
    this.segments.splice(0, 0, new DataSegment(p));
  }
  getlastPoint() {
    if (this.segments.length <= 0) {
      return new pointXY(NaN, NaN);
    }
    return this.segments[this.segments.length - 1].data[this.segments[this.segments.length - 1].count - 1];
  }
  handleSummary(p, delta) {
    if (this.summaries == null) {
      this.summaries = [];
      this.summaries.push(new Summary(0, this.summaries, SUMMARY_GRANULARITY));
    }
    if (this.summaries != null)
      this.summaries[0].addSequentialPoint(p, delta);
  }
  AddPoint(p) {
    this._timeRange = MinMaxHandler.CombineWithNumber(this._timeRange, p.x);
    this._valueRange = MinMaxHandler.CombineWithNumber(this._valueRange, p.y);
    let delta1 = -1;
    let delta2 = -1;
    if (this.segments.length <= 0) {
      this.AddNewSegment(p);
      this.totalPointCount++;
      if (SUMMARY_GRANULARITY > 0)
        this.handleSummary(p, delta1);
      return;
    } else if (this.segments[0].count > 1) {
      delta1 = this.segments[0].data[this.segments[0].count - 1].x - this.segments[0].data[this.segments[0].count - 2].x;
      delta2 = p.x - this.segments[0].data[this.segments[0].count - 1].x;
      if (delta2 > 0.1 && (delta2 < 0 || delta2 > 2 * delta1)) {
        this.AddNewSegment(p);
        if (SUMMARY_GRANULARITY > 0)
          this.handleSummary(p, delta1);
        return;
      }
    }
    if (SUMMARY_GRANULARITY > 0)
      this.handleSummary(p, delta1);
    this.segments[0].data[this.segments[0].count] = p;
    this.segments[0].count++;
    this.totalPointCount++;
    if (DataSerie._MaxPointsPerSeries > 0 && this.totalPointCount > DataSerie._MaxPointsPerSeries) {
      this.dataCleanUp();
      this.rebuildSummaries();
    }
    this.parent.adjustGlobalTimeRange(p.x);
    this.parent.redraw();
  }
  rebuildSummaries() {
    if (SUMMARY_GRANULARITY <= 0)
      return;
    this.summaries = [];
    this.summaries.push(new Summary(0, this.summaries, SUMMARY_GRANULARITY));
    this.summaries[0].processSegments(this.segments);
  }
  dumpSummaries() {
    if (this.summaries != null)
      for (let i = 0; i < this.summaries.length; i++)
        this.summaries[i].Dump();
    else
      console.log("****No summaries ****");
  }
  dataCleanUp() {
    if (this.segments.length <= 0)
      return;
    let newLimit = DataSerie._MaxPointsPerSeries * 90 / 100;
    while (this.segments[this.segments.length - 1].count <= this.totalPointCount - newLimit) {
      this.totalPointCount -= this.segments[this.segments.length - 1].count;
      this.segments.splice(this.segments.length - 1, 1);
    }
    if (this.totalPointCount > newLimit) {
      let delta = this.totalPointCount - newLimit;
      let newsize = this.segments[this.segments.length - 1].count - delta;
      let newdata = new Array(newsize);
      DataSegment.ArrayCopy(this.segments[this.segments.length - 1].data, delta, newdata, 0, this.segments[this.segments.length - 1].count - delta);
      this.segments[this.segments.length - 1].data = newdata;
      this.segments[this.segments.length - 1].count -= delta;
      this.totalPointCount -= delta;
    }
    let tmin = this.segments[0].data[0].x;
    let tmax = this.segments[0].data[0].x;
    let ymin = this.segments[0].data[0].y;
    let ymax = this.segments[0].data[0].y;
    for (let i = 0; i < this.segments.length; i++) {
      let count = this.segments[i].count;
      if (tmin > this.segments[i].data[0].x)
        tmin = this.segments[i].data[0].x;
      if (tmax < this.segments[i].data[count - 1].x)
        tmax = this.segments[i].data[count - 1].x;
      for (let j = 0; j < count; j++) {
        if (ymin > this.segments[i].data[j].y)
          ymin = this.segments[i].data[j].y;
        if (ymax < this.segments[i].data[j].y)
          ymax = this.segments[i].data[j].y;
      }
    }
    this._timeRange.Min = tmin;
    this._timeRange.Max = tmax;
    this._valueRange.Min = ymin;
    this._valueRange.Max = ymax;
  }
  InsertPoints(points) {
    if (points.length == 0)
      return;
    if (points.length == 1) {
      this._timeRange = MinMaxHandler.CombineWithNumber(this._timeRange, points[0].x);
      this._valueRange = MinMaxHandler.CombineWithNumber(this._valueRange, points[0].y);
      return;
    }
    let FirstStep = points[1].x - points[0].x;
    let LastStep = points[points.length - 1].x - points[points.length - 2].x;
    let InsertAtBegining = -1;
    let InsertAtEnd = -1;
    for (let i = 0; i < this.segments.length; i++) {
      if (this.segments[i].count > 1) {
        let DeltaInsertAtBegining = this.segments[i].data[0].x - points[points.length - 1].x;
        let DeltaInsertAtEnd = points[0].x - this.segments[i].data[this.segments[i].count - 1].x;
        if (DeltaInsertAtBegining > 0 && DeltaInsertAtBegining < 2 * FirstStep)
          InsertAtBegining = i;
        if (DeltaInsertAtEnd > 0 && DeltaInsertAtEnd < 2 * LastStep)
          InsertAtEnd = i;
      }
    }
    if (InsertAtBegining >= 0) {
      DataSegment.ArrayCopy(this.segments[InsertAtBegining].data, 0, this.segments[InsertAtBegining].data, points.length, this.segments[InsertAtBegining].count);
      DataSegment.ArrayCopy(points, 0, this.segments[InsertAtBegining].data, 0, points.length);
      this.segments[InsertAtBegining].count += points.length;
      this.totalPointCount += points.length;
    } else if (InsertAtEnd >= 0) {
      DataSegment.ArrayCopy(points, 0, this.segments[InsertAtEnd].data, this.segments[InsertAtEnd].count, points.length);
      this.segments[InsertAtEnd].count += points.length;
      this.totalPointCount += points.length;
    } else {
      let inserted = false;
      for (let i = 0; i < this.segments.length; i++) {
        if (this.segments[i].data[this.segments[i].data.length - 1].x < points[0].x && !inserted) {
          this.segments.splice(i, 0, new DataSegment(points));
          inserted = true;
        }
      }
      if (!inserted)
        this.segments.push(new DataSegment(points));
      this.totalPointCount += points.length;
    }
    this._timeRange = MinMaxHandler.CombineWithNumber(this._timeRange, points[0].x);
    this._timeRange = MinMaxHandler.CombineWithNumber(this._timeRange, points[points.length - 1].x);
    for (let i = 0; i < points.length; i++) {
      this._valueRange = MinMaxHandler.CombineWithNumber(this._valueRange, points[i].y);
    }
    if (DataSerie._MaxPointsPerSeries > 0 && this.totalPointCount > DataSerie._MaxPointsPerSeries)
      this.dataCleanUp();
    this.parent.redraw();
  }
  static CompareSegments(a, b) {
    if (a.data[0].x > b.data[0].x)
      return -1;
    if (a.data[0].x < b.data[0].x)
      return 1;
    return 0;
  }
  getData() {
    let res = [];
    this.segments.sort(DataSerie.CompareSegments);
    for (let i = this.segments.length - 1; i >= 0; i--) {
      for (let j = 0; j < this.segments[i].count; j++) {
        res.push(this.segments[i].data[j]);
      }
    }
    return res;
  }
  findClosestValue(x, AllowInterpolation) {
    let N1 = 0;
    let N2 = 0;
    let Pos = 0;
    if (this.segments.length <= 0)
      return null;
    for (let i = 0; i < this.segments.length; i++) {
      if (x >= this.segments[i].data[0].x && x <= this.segments[i].data[this.segments[i].count - 1].x) {
        let data = this.segments[i].data;
        N1 = 0;
        N2 = this.segments[i].count - 1;
        while (N2 - N1 > 1) {
          let N = N1 + N2 >> 1;
          if (data[N].x > x)
            N2 = N;
          else
            N1 = N;
        }
        Pos = N1 - 1;
        if (Pos < 0)
          Pos = 0;
        if (!AllowInterpolation) {
          if (x - data[Pos].x < data[Pos + 1].x - x)
            return data[Pos];
          else
            return data[Pos + 1];
        } else {
          Pos++;
          if (x == data[Pos].x)
            return data[Pos];
          if (x == data[Pos + 1].x)
            return data[Pos + 1];
          let p = new pointXY();
          p.x = x;
          p.y = data[Pos].y + (data[Pos + 1].y - data[Pos].y) * (x - data[Pos].x) / (data[Pos + 1].x - data[Pos].x);
          return p;
        }
      }
    }
    if (AllowInterpolation)
      return null;
    try {
      this.segments[0].data[0].clone();
    } catch (e) {
      debugger;
    }
    let match = this.segments[0].data[0];
    let delta = Math.abs(this.segments[0].data[0].x - x);
    for (let i = 0; i < this.segments.length; i++) {
      let d1 = Math.abs(this.segments[i].data[0].x - x);
      let d2 = Math.abs(this.segments[i].data[this.segments[i].count - 1].x - x);
      if (d1 < delta) {
        match = this.segments[i].data[0];
        delta = d1;
      }
      if (d2 < delta) {
        match = this.segments[i].data[this.segments[i].count - 1];
        delta = d2;
      }
    }
    return match.clone();
  }
  clear() {
    this.segments = [];
    this._timeRange = MinMaxHandler.DefaultValue();
    this._valueRange = MinMaxHandler.DefaultValue();
    this.parent.clearCachedObjects();
    this.totalPointCount = 0;
  }
};
DataSerie._MaxPointsPerSeries = 0;
var DataTracker = class {
  get directParent() {
    return this._directParent;
  }
  get userData() {
    return this._userData;
  }
  set userData(value) {
    this._userData = value;
  }
  constructor(parent, directParent) {
    this._userData = null;
    this._enabled = false;
    this._showSerieName = false;
    this._showTimeStamp = false;
    this._dataPrecisionString = "";
    this._dataPrecision = DataTracker.DataPrecision.PRECISION_NOLIMIT;
    this._diameter = 5;
    this._handleLength = 25;
    this._detectionDistance = 50;
    this._bgColor = YColor.FromArgb(200, 255, 255, 255);
    this._borderColor = YColor.Black;
    this._borderthickness = 1;
    this._padding = 10;
    this._verticalMargin = 10;
    this._horizontalMargin = 10;
    this._bgBrush = null;
    this._pen = null;
    this._font = null;
    this._directParent = directParent;
    this._parentRenderer = parent;
    this._font = new YFont(parent, this, 8, null);
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    this._enabled = value;
    this._parentRenderer.redraw();
  }
  get showSerieName() {
    return this._showSerieName;
  }
  set showSerieName(value) {
    this._showSerieName = value;
    this._parentRenderer.redraw();
  }
  get showTimeStamp() {
    return this._showTimeStamp;
  }
  set showTimeStamp(value) {
    this._showTimeStamp = value;
    this._parentRenderer.redraw();
  }
  get dataPrecisionString() {
    return this._dataPrecisionString;
  }
  get dataPrecision() {
    return this._dataPrecision;
  }
  set dataPrecision(value) {
    this._dataPrecision = value;
    this.compute_dataPrecisionString();
    this._parentRenderer.redraw();
  }
  compute_dataPrecisionString() {
    if (this._dataPrecision == DataTracker.DataPrecision.PRECISION_NOLIMIT) {
      this._dataPrecisionString = "";
      return;
    }
    this._dataPrecisionString = "0.";
  }
  get diameter() {
    return this._diameter;
  }
  set diameter(value) {
    if (value < 0)
      throw new RangeError("Diameter must be a positive value");
    this._diameter = value;
    this._parentRenderer.redraw();
  }
  get handleLength() {
    return this._handleLength;
  }
  set handleLength(value) {
    if (value < 0)
      throw new RangeError("Hanle length must be a positive value");
    this._handleLength = value;
    this._parentRenderer.redraw();
  }
  get detectionDistance() {
    return this._detectionDistance;
  }
  set detectionDistance(value) {
    if (value <= 0)
      throw new RangeError("Distance must be a positive value");
    this._detectionDistance = value;
  }
  get bgColor() {
    return this._bgColor;
  }
  set bgColor(value) {
    this._bgColor = value;
    this._bgBrush = null;
    this._parentRenderer.redraw();
  }
  get borderColor() {
    return this._borderColor;
  }
  set borderColor(value) {
    this._borderColor = value;
    this._pen = null;
    this._parentRenderer.redraw();
  }
  get borderthickness() {
    return this._borderthickness;
  }
  set borderthickness(value) {
    if (value < 0)
      throw new RangeError("Thickness must be a positive value");
    this._borderthickness = value;
    this._pen = null;
    this._parentRenderer.redraw();
  }
  get padding() {
    return this._padding;
  }
  set padding(value) {
    if (value < 0)
      throw new RangeError("Padding must be a positive value");
    this._padding = value;
    this._parentRenderer.redraw();
  }
  get verticalMargin() {
    return this._verticalMargin;
  }
  set verticalMargin(value) {
    if (value < 0)
      throw new RangeError("Margin must be a positive value");
    this._verticalMargin = value;
    this._parentRenderer.redraw();
  }
  get horizontalMargin() {
    return this._horizontalMargin;
  }
  set horizontalMargin(value) {
    if (value < 0)
      throw new RangeError("Margin must be a positive value");
    this._horizontalMargin = value;
    this._parentRenderer.redraw();
  }
  get bgBrush() {
    if (this._bgBrush == null) {
      this._bgBrush = new YSolidBrush(this._bgColor);
    }
    return this._bgBrush;
  }
  get pen() {
    if (this._pen == null)
      this._pen = new YPen(this._borderColor, this._borderthickness, true);
    return this._pen;
  }
  get font() {
    return this._font;
  }
};
(function(DataTracker2) {
  class DataPrecisionEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, DataPrecision);
    }
  }
  DataTracker2.DataPrecisionEnumItem = DataPrecisionEnumItem;
  class DataPrecision extends YEnum {
  }
  DataPrecision.PRECISION_NOLIMIT = new DataPrecisionEnumItem("PRECISION_NOLIMIT", "As is");
  DataPrecision.PRECISION_1 = new DataPrecisionEnumItem("PRECISION_1", "1");
  DataPrecision.PRECISION_01 = new DataPrecisionEnumItem("PRECISION_01", "0.1");
  DataPrecision.PRECISION_001 = new DataPrecisionEnumItem("PRECISION_001", "0.01");
  DataPrecision.PRECISION_0001 = new DataPrecisionEnumItem("PRECISION_0001", "0.001");
  DataPrecision.PRECISION_00001 = new DataPrecisionEnumItem("PRECISION_00001", "0.0001");
  DataPrecision.PRECISION_000001 = new DataPrecisionEnumItem("PRECISION_000001", "0.00001");
  DataPrecision.PRECISION_0000001 = new DataPrecisionEnumItem("PRECISION_0000001", "0.000001");
  DataPrecision.PRECISION_00000001 = new DataPrecisionEnumItem("PRECISION_00000001", "0.0000001");
  DataPrecision.PRECISION_000000001 = new DataPrecisionEnumItem("PRECISION_000000001", "0.00000001");
  DataPrecision.PRECISION_0000000001 = new DataPrecisionEnumItem("PRECISION_0000000001", "0.000000001");
  DataTracker2.DataPrecision = DataPrecision;
})(DataTracker || (DataTracker = {}));
var LegendPanel = class {
  get directParent() {
    return this._directParent;
  }
  get userData() {
    return this._userData;
  }
  set userData(value) {
    this._userData = value;
  }
  get traceWidthFactor() {
    return this._traceWidth;
  }
  set traceWidthFactor(value) {
    if (value <= 0)
      throw new RangeError("This has to be a strictly positive value");
    this._traceWidth = value;
    this._parentRenderer.resetlegendPens();
    this._parentRenderer.redraw();
  }
  constructor(parent, directParent) {
    this._userData = null;
    this._traceWidth = 1;
    this._enabled = false;
    this._position = LegendPanel.Position.BOTTOM;
    this._overlap = false;
    this._bgColor = YColor.FromArgb(200, 255, 255, 255);
    this._borderColor = YColor.Black;
    this._borderthickness = 1;
    this._padding = 10;
    this._verticalMargin = 10;
    this._horizontalMargin = 10;
    this._bgBrush = null;
    this._pen = null;
    this._font = null;
    this._directParent = directParent;
    this._parentRenderer = parent;
    this._font = new YFont(parent, this, 8, null);
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    this._enabled = value;
    this._parentRenderer.redraw();
  }
  get position() {
    return this._position;
  }
  set position(value) {
    this._position = value;
    this._parentRenderer.redraw();
  }
  get overlap() {
    return this._overlap;
  }
  set overlap(value) {
    this._overlap = value;
    this._parentRenderer.redraw();
  }
  get bgColor() {
    return this._bgColor;
  }
  set bgColor(value) {
    this._bgColor = value;
    this._bgBrush = null;
    this._parentRenderer.redraw();
  }
  get borderColor() {
    return this._borderColor;
  }
  set borderColor(value) {
    this._borderColor = value;
    this._pen = null;
    this._parentRenderer.redraw();
  }
  get borderthickness() {
    return this._borderthickness;
  }
  set borderthickness(value) {
    if (value < 0)
      throw new RangeError("Thickness must be a positive value");
    this._borderthickness = value;
    this._pen = null;
    this._parentRenderer.redraw();
  }
  get padding() {
    return this._padding;
  }
  set padding(value) {
    if (value < 0)
      throw new RangeError("Padding must be a positive value");
    this._padding = value;
    this._parentRenderer.redraw();
  }
  get verticalMargin() {
    return this._verticalMargin;
  }
  set verticalMargin(value) {
    if (value < 0)
      throw new RangeError("Margin must be a positive value");
    this._verticalMargin = value;
    this._parentRenderer.redraw();
  }
  get horizontalMargin() {
    return this._horizontalMargin;
  }
  set horizontalMargin(value) {
    if (value < 0)
      throw new RangeError("Margin must be a positive value");
    this._horizontalMargin = value;
    this._parentRenderer.redraw();
  }
  get bgBrush() {
    if (this._bgBrush == null) {
      this._bgBrush = new YSolidBrush(this._bgColor);
    }
    return this._bgBrush;
  }
  get pen() {
    if (this._pen == null)
      this._pen = new YPen(this._borderColor, this._borderthickness, true);
    return this._pen;
  }
  get font() {
    return this._font;
  }
};
(function(LegendPanel2) {
  class PositionEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, Position);
    }
  }
  LegendPanel2.PositionEnumItem = PositionEnumItem;
  class Position extends YEnum {
  }
  Position.LEFT = new PositionEnumItem("LEFT", "Left");
  Position.TOPLEFT = new PositionEnumItem("TOPLEFT", "Top-Left");
  Position.TOP = new PositionEnumItem("TOP", "Top");
  Position.TOPRIGHT = new PositionEnumItem("TOPRIGHT", "Top-Right");
  Position.RIGHT = new PositionEnumItem("RIGHT", "Right");
  Position.BOTTOMRIGHT = new PositionEnumItem("BOTTOMRIGHT", "Bottom-Right");
  Position.BOTTOM = new PositionEnumItem("BOTTOM", "Bottom");
  Position.BOTTOMLEFT = new PositionEnumItem("BOTTOMLEFT", "Bottom-Left");
  LegendPanel2.Position = Position;
})(LegendPanel || (LegendPanel = {}));
var Navigator = class {
  get directParent() {
    return this._directParent;
  }
  get userData() {
    return this._userData;
  }
  set userData(value) {
    this._userData = value;
  }
  get showXAxisZones() {
    return this._showXAxisZones;
  }
  set showXAxisZones(value) {
    this._showXAxisZones = value;
  }
  get relativeheight() {
    return this._relativeheight;
  }
  set relativeheight(value) {
    if (value < 10)
      value = 10;
    if (value > 50)
      value = 50;
    this._relativeheight = value;
    this._parentRenderer.redraw();
  }
  constructor(parent, directParent) {
    this._userData = null;
    this._viewport = new ViewPortSettings();
    this.Xrange = null;
    this._showXAxisZones = true;
    this._relativeheight = 10;
    this._enabled = false;
    this._bgColor1 = YColor.FromArgb(255, 225, 225, 225);
    this._cursorBorderColor = YColor.FromArgb(255, 40, 40, 40);
    this._yAxisHandling = Navigator.YAxisHandling.AUTO;
    this._bgColor2 = YColor.FromArgb(255, 225, 225, 225);
    this._cursorColor = YColor.FromArgb(100, 0, 255, 0);
    this._cursorBrush = null;
    this._pen = null;
    this._cursorBorderPen = null;
    this._xAxisColor = YColor.Black;
    this._xAxisThickness = 1;
    this._borderPen = null;
    this._borderColor = YColor.DimGray;
    this._borderThickness = 1;
    this._bgBrush = null;
    this._font = null;
    this._directParent = directParent;
    this._parentRenderer = parent;
    this._font = new YFont(parent, this, 8, null);
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    this._enabled = value;
    this._parentRenderer.redraw();
  }
  get bgColor1() {
    return this._bgColor1;
  }
  set bgColor1(value) {
    this._bgColor1 = value;
    this._bgBrush = null;
    this._parentRenderer.redraw();
  }
  get cursorBorderColor() {
    return this._cursorBorderColor;
  }
  set cursorBorderColor(value) {
    this._cursorBorderColor = value;
    this._cursorBorderPen = null;
    this._parentRenderer.redraw();
  }
  get yAxisHandling() {
    return this._yAxisHandling;
  }
  set yAxisHandling(value) {
    this._yAxisHandling = value;
    this._parentRenderer.redraw();
  }
  get bgColor2() {
    return this._bgColor2;
  }
  set bgColor2(value) {
    this._bgColor2 = value;
    this._bgBrush = null;
    this._parentRenderer.redraw();
  }
  get cursorColor() {
    return this._cursorColor;
  }
  set cursorColor(value) {
    this._cursorColor = value;
    this._cursorBrush = null;
    this._parentRenderer.redraw();
  }
  get cursorBrush() {
    if (this._cursorBrush == null) {
      this._cursorBrush = new YSolidBrush(this._cursorColor);
    }
    return this._cursorBrush;
  }
  get pen() {
    if (this._pen == null)
      this._pen = new YPen(this._xAxisColor, this._xAxisThickness, true);
    return this._pen;
  }
  get cursorBorderPen() {
    if (this._cursorBorderPen == null)
      this._cursorBorderPen = new YPen(this._cursorBorderColor, 1, true);
    return this._cursorBorderPen;
  }
  get xAxisColor() {
    return this._xAxisColor;
  }
  set xAxisColor(value) {
    this._xAxisColor = value;
    this._pen = null;
    this._parentRenderer.redraw();
  }
  get xAxisThickness() {
    return this._xAxisThickness;
  }
  set xAxisThickness(value) {
    if (value < 0)
      throw new RangeError("Thickness must be a positive value");
    this._xAxisThickness = value;
    this._pen = null;
    this._parentRenderer.redraw();
  }
  get borderPen() {
    if (this._borderPen == null)
      this._borderPen = new YPen(this._borderColor, this._borderThickness, true);
    return this._borderPen;
  }
  get borderColor() {
    return this._borderColor;
  }
  set borderColor(value) {
    this._borderColor = value;
    this._borderPen = null;
    this._parentRenderer.redraw();
  }
  get borderThickness() {
    return this._borderThickness;
  }
  set borderThickness(value) {
    if (value < 0)
      throw new RangeError("Thickness must be a positive value");
    this._borderThickness = value;
    this._borderPen = null;
    this._parentRenderer.redraw();
  }
  setPosition(ParentWidth, ParentHeight, Lmargin, Rmargin, Tmargin, Bmargin) {
    if (this._viewport.Lmargin != Lmargin || this._viewport.Rmargin != Rmargin || this._viewport.Tmargin != Tmargin || this._viewport.Bmargin != Bmargin) {
      this._bgBrush = null;
    }
    this._viewport.Lmargin = Lmargin;
    this._viewport.Rmargin = Rmargin;
    this._viewport.Bmargin = Bmargin;
    this._viewport.Tmargin = Tmargin;
    this._viewport.Width = ParentWidth;
    this._viewport.Height = ParentHeight;
  }
  setIRLPosition(IRLx, IRLy, xZoom, yZoom) {
    this._viewport.IRLx = IRLx;
    this._viewport.IRLy = IRLy;
    this._viewport.zoomx = xZoom;
    this._viewport.zoomy = yZoom;
  }
  startCapture(IRLStartPoint, xAxisMin, xAxisMax) {
    this._viewport.OriginalXAxisMin = xAxisMin;
    this._viewport.OriginalXAxisMax = xAxisMax;
    this._viewport.OriginalIRLx = this._viewport.IRLx;
    this._viewport.OriginalLmargin = this._viewport.Lmargin;
    this._viewport.OriginalZoomx = this._viewport.zoomx;
    this._viewport.IRLCaptureStartX = IRLStartPoint.x;
    this._viewport.Capture = true;
  }
  get Capture() {
    return this._viewport.Capture;
  }
  stopCapture() {
    this._viewport.Capture = false;
  }
  get viewport() {
    return this._viewport;
  }
  get bgBrush() {
    if (this._bgBrush == null) {
      this._bgBrush = new YLinearGradientBrush(this._bgColor1, this._bgColor2);
    }
    return this._bgBrush;
  }
  get font() {
    return this._font;
  }
};
(function(Navigator2) {
  class YAxisHandlingEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, YAxisHandling);
    }
  }
  Navigator2.YAxisHandlingEnumItem = YAxisHandlingEnumItem;
  class YAxisHandling extends YEnum {
  }
  YAxisHandling.AUTO = new YAxisHandlingEnumItem("AUTO", "Automatic");
  YAxisHandling.INHERIT = new YAxisHandlingEnumItem("INHERIT", "Inherit from main view");
  Navigator2.YAxisHandling = YAxisHandling;
})(Navigator || (Navigator = {}));
var Marker = class {
  get userData() {
    return this._userData;
  }
  set userData(value) {
    this._userData = value;
  }
  static _round100(v) {
    return Math.round(100 * v) / 100;
  }
  get stringFormat() {
    if (this._stringFormat != null)
      return this._stringFormat;
    this._stringFormat = new YStringFormat(16384);
    this._stringFormat.LineAlignment = 1;
    switch (this._textAlign) {
      case Marker.TextAlign.LEFT:
        this._stringFormat.Alignment = 0;
        break;
      case Marker.TextAlign.CENTER:
        this._stringFormat.Alignment = 1;
        break;
      case Marker.TextAlign.RIGHT:
        this._stringFormat.Alignment = 2;
        break;
    }
    return this._stringFormat;
  }
  get PatchTextCallback() {
    return this._MarkerTextCallback;
  }
  set PatchTextCallback(callback) {
    this._MarkerTextCallback = callback;
  }
  get directParent() {
    return this._directParent;
  }
  constructor(parent, directParent) {
    this._userData = null;
    this._stringFormat = null;
    this._MarkerTextCallback = null;
    this._enabled = false;
    this._xposition = 0;
    this._xpositionIsRelative = false;
    this._yposition = 92;
    this._text = "Marker";
    this._textAlign = Marker.TextAlign.CENTER;
    this._bgColor = YColor.FromArgb(255, 255, 255, 192);
    this._borderColor = YColor.DarkRed;
    this._borderthickness = 1;
    this._arrowSize = 5;
    this._padding = 5;
    this._verticalMargin = 5;
    this._horizontalMargin = 5;
    this._bgBrush = null;
    this._arrowBrush = null;
    this._pen = null;
    this._navigatorpen = null;
    this._font = null;
    this._directParent = directParent;
    this._parentRenderer = parent;
    this._font = new YFont(parent, this, 8, null);
  }
  startCapture() {
    this._parentRenderer.startMarkerCapture(this);
  }
  setCapturedPosition(position, axis) {
    this.enabled = true;
    this._xpositionIsRelative = axis.timeReference == TimeConverter.TimeReference.RELATIVE && axis.zeroTime > 0;
    this._xposition = Marker._round100(this._xpositionIsRelative ? position - axis.zeroTime : position);
    this._parentRenderer.clearCachedObjects();
    this._parentRenderer.redraw();
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    if (this._enabled != value) {
      this._enabled = value;
      this._parentRenderer.clearCachedObjects();
      this._parentRenderer.redraw();
    }
  }
  get xposition() {
    return this._xposition;
  }
  set xposition(value) {
    this._xposition = Marker._round100(value);
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get timereference() {
    return this._xpositionIsRelative ? TimeConverter.TimeReference.RELATIVE : TimeConverter.TimeReference.ABSOLUTE;
  }
  set timereference(value) {
    let v = value == TimeConverter.TimeReference.RELATIVE;
    if (this._xpositionIsRelative != v) {
      let ZeroPosition = this._directParent.zeroTime;
      if (isNaN(ZeroPosition))
        ZeroPosition = 0;
      if (v) {
        this._xpositionIsRelative = true;
        this._xposition -= ZeroPosition;
      } else {
        this._xpositionIsRelative = false;
        this._xposition += ZeroPosition;
      }
      this._xposition = Marker._round100(this._xposition);
      this._parentRenderer.redraw();
    }
  }
  get positionOnXAxis() {
    return new xAxisPosition(this._xposition, this._xpositionIsRelative);
  }
  set positionOnXAxis(value) {
    if (value.capture) {
      this.startCapture();
    } else {
      let v = Marker._round100(value.value);
      if (this._xpositionIsRelative != value.relative || this._xposition != v) {
        this._xposition = v;
        this._xpositionIsRelative = value.relative;
        if (this._enabled)
          this._parentRenderer.redraw();
      }
    }
  }
  get yposition() {
    return this._yposition;
  }
  set yposition(value) {
    this._yposition = Math.min(100, Math.max(0, value));
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get text() {
    return this._text;
  }
  set text(value) {
    this._text = value;
    this._parentRenderer.clearCachedObjects();
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get textAlign() {
    return this._textAlign;
  }
  set textAlign(value) {
    this._textAlign = value;
    this._stringFormat = null;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get shortText() {
    if (this._text.length <= 20)
      return this._text;
    return this._text.substring(0, 18) + "..";
  }
  get bgColor() {
    return this._bgColor;
  }
  set bgColor(value) {
    this._bgColor = value;
    this._bgBrush = null;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get borderColor() {
    return this._borderColor;
  }
  set borderColor(value) {
    this._borderColor = value;
    this._arrowBrush = null;
    this._pen = null;
    this._navigatorpen = null;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get borderthickness() {
    return this._borderthickness;
  }
  set borderthickness(value) {
    if (value < 0)
      throw new RangeError("thickness must be a positive value");
    this._borderthickness = value;
    this._parentRenderer.clearCachedObjects();
    this._pen = null;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get arrowSize() {
    return this._arrowSize;
  }
  set arrowSize(value) {
    this._arrowSize = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get padding() {
    return this._padding;
  }
  set padding(value) {
    if (value < 0)
      throw new RangeError("Padding must be a positive value");
    this._padding = value;
    this._parentRenderer.clearCachedObjects();
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get verticalMargin() {
    return this._verticalMargin;
  }
  set verticalMargin(value) {
    this._verticalMargin = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get horizontalMargin() {
    return this._horizontalMargin;
  }
  set horizontalMargin(value) {
    this._horizontalMargin = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get bgBrush() {
    if (this._bgBrush == null) {
      this._bgBrush = new YSolidBrush(this._bgColor);
    }
    return this._bgBrush;
  }
  get arrowBrush() {
    if (this._arrowBrush == null) {
      this._arrowBrush = new YSolidBrush(this._borderColor, true);
    }
    return this._arrowBrush;
  }
  get pen() {
    if (this._pen == null)
      this._pen = new YPen(this._borderColor, this._borderthickness, true);
    return this._pen;
  }
  get navigatorpen() {
    if (this._navigatorpen == null)
      this._navigatorpen = new YPen(this._borderColor, 1);
    return this._navigatorpen;
  }
  get font() {
    return this._font;
  }
};
(function(Marker2) {
  class TextAlignEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, TextAlign);
    }
  }
  Marker2.TextAlignEnumItem = TextAlignEnumItem;
  class TextAlign extends YEnum {
  }
  TextAlign.LEFT = new TextAlignEnumItem("LEFT", "Left");
  TextAlign.CENTER = new TextAlignEnumItem("CENTER", "Center");
  TextAlign.RIGHT = new TextAlignEnumItem("RIGHT", "Right");
  Marker2.TextAlign = TextAlign;
})(Marker || (Marker = {}));
var Legend = class {
  get directParent() {
    return this._directParent;
  }
  get userData() {
    return this._userData;
  }
  set userData(value) {
    this._userData = value;
  }
  constructor(parent, directParent) {
    this._userData = null;
    this._title = "";
    this._font = null;
    this._directParent = directParent;
    this._parentRenderer = parent;
    this._font = new YFont(parent, this, 12, null);
  }
  get title() {
    return this._title;
  }
  set title(value) {
    this._title = value;
    this._parentRenderer.redraw();
  }
  get font() {
    return this._font;
  }
};
var GenericAxis = class {
  get directParent() {
    return this._directParent;
  }
  get zones() {
    return this._zones;
  }
  AddZone() {
    let z = new Zone(this._parentRenderer, this);
    this._zones.push(z);
    return z;
  }
  get userData() {
    return this._userData;
  }
  set userData(value) {
    this._userData = value;
  }
  get AxisChanged() {
    return this._AxisChanged;
  }
  set AxisChanged(value) {
    this._AxisChanged = value;
  }
  constructor(parent, directParent) {
    this._userData = null;
    this._AxisChanged = null;
    this._pen = null;
    this._gridPen = null;
    this._visible = true;
    this._AllowAutoShow = false;
    this._min = Number.NaN;
    this._max = Number.NaN;
    this._step = Number.NaN;
    this._thickness = 1;
    this._color = YColor.Black;
    this._showGrid = false;
    this._gridColor = YColor.FromArgb(50, 0, 0, 0);
    this._gridThickness = 1;
    this._font = null;
    this._zones = [];
    this._directParent = directParent;
    this._parentRenderer = parent;
    this._legend = new Legend(parent, this);
    this._font = new YFont(parent, this);
  }
  get pen() {
    if (this._pen == null)
      this._pen = new YPen(this._color, this._thickness, true);
    return this._pen;
  }
  get gridPen() {
    if (this._gridPen == null)
      this._gridPen = new YPen(this._gridColor, this._gridThickness, true);
    return this._gridPen;
  }
  get visible() {
    return this._visible;
  }
  set visible(value) {
    this._visible = value;
    if (!value) {
      this._AllowAutoShow = false;
    }
    this._parentRenderer.redraw();
  }
  get AllowAutoShow() {
    return this._AllowAutoShow;
  }
  set AllowAutoShow(value) {
    this._AllowAutoShow = value;
  }
  AutoShow() {
    if (this._AllowAutoShow) {
      this.visible = true;
      if (this._AxisChanged != null)
        this._AxisChanged(this);
    }
  }
  set_minMax(value_min, value_max) {
    if (!isNaN(value_min) && !isNaN(value_max) && value_min >= value_max) {
      throw new RangeError("Min (" + value_min.toString() + ") cannot be greater than max (" + value_max.toString() + ")");
    }
    this._min = value_min;
    this._max = value_max;
    this._parentRenderer.redraw();
  }
  get min() {
    return this._min;
  }
  set min(value) {
    if (!isNaN(value) && !isNaN(this._max) && !YDataRenderer.minMaxCheckDisabled) {
      if (value >= this._max) {
        throw new RangeError("Min cannot be greater than max (" + this._max.toString() + ")");
      }
    }
    this._min = value;
    this._parentRenderer.redraw();
  }
  setMinMax(min, max) {
    if (min < max) {
      this._min = min;
      this._max = max;
      this._parentRenderer.redraw();
    }
  }
  get max() {
    return this._max;
  }
  set max(value) {
    if (!isNaN(value) && !isNaN(this._min) && !YDataRenderer.minMaxCheckDisabled) {
      if (value <= this._min)
        throw new RangeError("Max cannot be less than min (" + this._min.toString() + ")");
    }
    this._max = value;
    this._parentRenderer.redraw();
  }
  get step() {
    return this._step;
  }
  set step(value) {
    if (!isNaN(value) && value < 0)
      throw new RangeError("Steps must be a strictely positive value");
    this._step = value;
    this._parentRenderer.redraw();
  }
  get thickness() {
    return this._thickness;
  }
  set thickness(value) {
    if (value < 0)
      throw new RangeError("Thickness must be a positive value");
    this._thickness = value;
    this._pen = null;
    this._parentRenderer.redraw();
  }
  get color() {
    return this._color;
  }
  set color(value) {
    this._color = value;
    this._pen = null;
    this._parentRenderer.redraw();
  }
  get showGrid() {
    return this._showGrid;
  }
  set showGrid(value) {
    this._showGrid = value;
    this._parentRenderer.redraw();
  }
  get gridColor() {
    return this._gridColor;
  }
  set gridColor(value) {
    this._gridColor = value;
    this._gridPen = null;
    this._parentRenderer.redraw();
  }
  get gridThickness() {
    return this._gridThickness;
  }
  set gridThickness(value) {
    if (value < 0)
      throw new RangeError("Thickness must be a positive value");
    this._gridThickness = value;
    this._gridPen = null;
    this._parentRenderer.redraw();
  }
  get font() {
    return this._font;
  }
  get legend() {
    return this._legend;
  }
};
var StartStopStep = class {
  constructor() {
    this.dataMin = 0;
    this.dataMax = 0;
    this.absMin = 0;
    this.absMax = 0;
    this.step = 0;
    this.start = 0;
    this.stop = 0;
    this.precision = 0;
  }
};
var xAxisPosition = class {
  get relative() {
    return this._isRelative;
  }
  set relative(value) {
    this._isRelative = value;
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value;
  }
  constructor(v, rel, capture) {
    this._isRelative = false;
    this._value = 0;
    this._capture = false;
    this._isRelative = rel;
    this._value = v;
    this._capture = typeof capture == "undefined" ? false : capture;
  }
  clone() {
    return new xAxisPosition(this._value, this._isRelative, this._capture);
  }
  toString() {
    if (this._isRelative) {
      return TimeConverter.secTimeSpanToString(this._value, 0);
    } else {
      let date = TimeConverter.FromUnixTime(this._value);
      let res = date.getFullYear().toString() + "-" + (date.getMonth() + 1).toString() + "-" + date.getDate().toString() + " " + date.getHours().toString() + ":";
      let st = date.getMinutes().toString();
      if (st.length <= 1)
        st = "0" + st;
      res = res + st + ":";
      let s = date.getSeconds();
      let ms = date.getMilliseconds();
      s = s + ms / 1e3;
      if (s < 10)
        res = res + "0";
      if (ms == 0) {
        res = res + s.toString();
      } else {
        res = res + s.toFixed(3);
      }
      return res;
    }
  }
  TryParse(str) {
    if (this._isRelative)
      return TimeConverter.tryParseStringToSecTimeSpan(str);
    return TimeConverter.tryParseStringToAbsDateTime(str);
  }
  get capture() {
    return this._capture;
  }
  set capture(value) {
    this._capture = value;
  }
};
xAxisPosition.DTdisplayformat = "DD/MM/YY hh:mm:ss.ff";
xAxisPosition.TSdisplayformat = "dd.hh:mm:ss.ff";
var YNumberFormatInfo = class {
  constructor() {
    this.NumberDecimalSeparator = ".";
  }
};
var YAxis = class extends GenericAxis {
  constructor(parent, directParent, index) {
    super(parent, directParent);
    this._index = 0;
    this._highlightZero = false;
    this._position = YAxis.HrzPosition.LEFT;
    this.innerWidth = 0;
    this.zoom = 0;
    this.IRLy = 0;
    this._index = index;
    this.nfi = new YNumberFormatInfo();
    this.nfi.NumberDecimalSeparator = ".";
    this.startStopStep = new StartStopStep();
    this.startStopStep.start = 0;
    this.startStopStep.stop = 1;
    this.startStopStep.step = 0.1;
  }
  get index() {
    return this._index;
  }
  lockMinMax() {
    this._min = this.startStopStep.absMin;
    this._max = this.startStopStep.absMax;
    this._parentRenderer.redraw();
  }
  unlockMinMax() {
    this._min = Number.NaN;
    this._max = Number.NaN;
    this._parentRenderer.redraw();
  }
  get highlightZero() {
    return this._highlightZero;
  }
  set highlightZero(value) {
    this._highlightZero = value;
    this._parentRenderer.redraw();
  }
  get position() {
    return this._position;
  }
  set position(value) {
    this._position = value;
    this._parentRenderer.redraw();
  }
  computeStartAndStep(M) {
    let res = new StartStopStep();
    let min = this.min;
    let max = this.max;
    res.step = this.step;
    res.precision = 0;
    if (!MinMaxHandler.isDefined(M)) {
      M = MinMaxHandler.DefaultValue();
      M.Min = 0;
      M.Max = 100;
    }
    if (isNaN(min))
      min = M.Min;
    if (isNaN(max))
      max = M.Max;
    res.absMax = max;
    res.absMin = min;
    if (min == max) {
      min -= 0.5;
      max += 0.5;
    }
    if (min != 0)
      min -= (max - min) * 0.025;
    if (max != 0)
      max += (max - min) * 0.025;
    res.start = min;
    res.stop = max;
    res.dataMin = min;
    res.dataMax = max;
    let Delta = max - min;
    if (isNaN(res.step)) {
      let MagnitudePwr = Math.log10(Delta);
      if (MagnitudePwr - Math.floor(MagnitudePwr) != 0)
        MagnitudePwr = Math.floor(MagnitudePwr) + 1;
      res.precision = MagnitudePwr - 1 >> 0;
      let Magnitude = Math.pow(10, res.precision);
      let C = Delta / Magnitude;
      if (C <= 2) {
        res.step = Magnitude / 5;
        res.precision--;
      } else if (C <= 5) {
        res.step = Magnitude / 2;
        res.precision--;
      } else {
        res.step = Magnitude;
      }
      if (isNaN(this.min)) {
        let c = min / res.step;
        if (c - Math.floor(c) != 0)
          c = c > 0 ? Math.floor(c) + 1 : Math.floor(c) - 1;
        res.start = res.step * c;
      }
    } else {
      let v = res.step.toString();
      let p = v.indexOf(".");
      if (p >= 0) {
        res.precision = -(v.length - p - 1);
      } else {
        res.precision = 0;
      }
    }
    this.startStopStep = res;
    return res;
  }
};
(function(YAxis2) {
  class HrzPositionEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, HrzPosition);
    }
  }
  YAxis2.HrzPositionEnumItem = HrzPositionEnumItem;
  class HrzPosition extends YEnum {
  }
  HrzPosition.LEFT = new HrzPositionEnumItem("LEFT", "Left");
  HrzPosition.RIGHT = new HrzPositionEnumItem("RIGHT", "Right");
  YAxis2.HrzPosition = HrzPosition;
})(YAxis || (YAxis = {}));
var XAxis = class extends GenericAxis {
  get position() {
    return this._position;
  }
  set position(value) {
    this._position = value;
    this._parentRenderer.redraw();
  }
  get markers() {
    return this._markers;
  }
  AddMarker() {
    let m = new Marker(this._parentGraph, this);
    this._markers.push(m);
    this._parentGraph.clearCachedObjects();
    this._parentGraph.redraw();
    return m;
  }
  get initialZoom() {
    return this._initialZoom;
  }
  set initialZoom(value) {
    if (value <= 0)
      throw new RangeError("Zoom must be a positive value");
    this._initialZoom = value;
    this.min = this.min - this._initialZoom * this._initialOffset / 100;
    this.max = this.min + this.initialZoom;
    this._parentRenderer.redraw();
  }
  get initialOffset() {
    return this._initialOffset;
  }
  set initialOffset(value) {
    this._initialOffset = value;
    let p = this._parentGraph.getMostRecentPoint();
    if (isNaN(p.x)) {
      this._min = this._min - this._initialZoom * this._initialOffset / 100;
      this._max = this._min + this._initialZoom;
      this._parentRenderer.redraw();
    } else {
      let zoom = this._max - this._min;
      this._min = p.x - zoom * this._initialOffset / 100;
      this._max = this._min + zoom;
    }
    this._parentRenderer.redraw();
  }
  get labelFormat() {
    return this._format;
  }
  set labelFormat(value) {
    this._format = value;
    this._parentRenderer.redraw();
  }
  constructor(parent, directParent) {
    super(parent, directParent);
    this._position = XAxis.VrtPosition.BOTTOM;
    this._markers = [];
    this._initialZoom = 300;
    this._initialOffset = 0;
    this._format = XAxis.FORMATAUTO;
    this._timeReference = TimeConverter.TimeReference.ABSOLUTE;
    this._zeroTime = 0;
    this._fullSize = 0;
    this.innerHeight = 0;
    this._overflowHandling = XAxis.OverflowHandling.DONOTHING;
    this._parentGraph = parent;
    this._markers = [];
    this.min = TimeConverter.ToUnixTime(TimeConverter.UTCNow());
    this.max = this.min + this.initialZoom;
    this.step = 30;
  }
  get timeReference() {
    return this._timeReference;
  }
  set timeReference(value) {
    this._timeReference = value;
    this._parentRenderer.redraw();
  }
  get zeroTime() {
    return this._zeroTime;
  }
  set zeroTime(value) {
    this._zeroTime = value;
  }
  get fullSize() {
    return this._fullSize;
  }
  set fullSize(value) {
    this._fullSize = value;
  }
  bestFormat(dataTimedelta, viewportTimedelta) {
    return TimeConverter.BestTimeformat(dataTimedelta, viewportTimedelta, this._timeReference);
  }
  get overflowHandling() {
    return this._overflowHandling;
  }
  set overflowHandling(value) {
    this._overflowHandling = value;
  }
};
XAxis.FORMATAUTO = 0;
(function(XAxis2) {
  class VrtPositionEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, VrtPosition);
    }
  }
  XAxis2.VrtPositionEnumItem = VrtPositionEnumItem;
  class VrtPosition extends YEnum {
  }
  VrtPosition.TOP = new VrtPositionEnumItem("TOP", "Top");
  VrtPosition.BOTTOM = new VrtPositionEnumItem("BOTTOM", "Bottom");
  XAxis2.VrtPosition = VrtPosition;
  class OverflowHandlingEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, OverflowHandling);
    }
  }
  XAxis2.OverflowHandlingEnumItem = OverflowHandlingEnumItem;
  class OverflowHandling extends YEnum {
  }
  OverflowHandling.DONOTHING = new OverflowHandlingEnumItem("DONOTHING", "Do nothing");
  OverflowHandling.SCROLL = new OverflowHandlingEnumItem("SCROLL", "Scroll contents");
  OverflowHandling.CONTRACT = new OverflowHandlingEnumItem("CONTRACT", "Squeeze contents");
  XAxis2.OverflowHandling = OverflowHandling;
})(XAxis || (XAxis = {}));
var DataPanel = class extends GenericPanel {
  constructor(parent, directParent) {
    super(parent, directParent);
    this._panelHrzAlign = DataPanel.HorizontalAlign.CENTERED;
    this._panelVrtAlign = DataPanel.VerticalAlign.CENTERED;
    this._horizontalPosition = DataPanel.HorizontalPosition.ABSOLUTEX;
    this._verticalPosition = DataPanel.VerticalPosition.ABSOLUTEY;
    this._AbsoluteXposition = 0;
    this._AbsoluteYposition = 0;
    this._YScaleIndex = 0;
  }
  get panelHrzAlign() {
    return this._panelHrzAlign;
  }
  set panelHrzAlign(value) {
    this._panelHrzAlign = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get panelVrtAlign() {
    return this._panelVrtAlign;
  }
  set panelVrtAlign(value) {
    this._panelVrtAlign = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get horizontalPosition() {
    return this._horizontalPosition;
  }
  set horizontalPosition(value) {
    this._horizontalPosition = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get verticalPosition() {
    return this._verticalPosition;
  }
  set verticalPosition(value) {
    this._verticalPosition = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get AbsoluteXposition() {
    return this._AbsoluteXposition;
  }
  set AbsoluteXposition(value) {
    this._AbsoluteXposition = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get AbsoluteYposition() {
    return this._AbsoluteYposition;
  }
  set AbsoluteYposition(value) {
    this._AbsoluteYposition = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get yScaleIndex() {
    return this._YScaleIndex;
  }
  set yScaleIndex(value) {
    this._YScaleIndex = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
};
(function(DataPanel2) {
  class HorizontalAlignEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, HorizontalAlign);
    }
  }
  DataPanel2.HorizontalAlignEnumItem = HorizontalAlignEnumItem;
  class HorizontalAlign extends YEnum {
  }
  HorizontalAlign.LEFTOF = new HorizontalAlignEnumItem("LEFTOF", "Left");
  HorizontalAlign.CENTERED = new HorizontalAlignEnumItem("CENTERED", "Center");
  HorizontalAlign.RIGHTOF = new HorizontalAlignEnumItem("RIGHTOF", "Right");
  DataPanel2.HorizontalAlign = HorizontalAlign;
  class VerticalAlignEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, VerticalAlign);
    }
  }
  DataPanel2.VerticalAlignEnumItem = VerticalAlignEnumItem;
  class VerticalAlign extends YEnum {
  }
  VerticalAlign.ABOVE = new VerticalAlignEnumItem("ABOVE", "Top");
  VerticalAlign.CENTERED = new VerticalAlignEnumItem("CENTERED", "Center");
  VerticalAlign.BELOW = new VerticalAlignEnumItem("BELOW", "Bottom");
  DataPanel2.VerticalAlign = VerticalAlign;
  class HorizontalPositionEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, HorizontalPosition);
    }
  }
  DataPanel2.HorizontalPositionEnumItem = HorizontalPositionEnumItem;
  class HorizontalPosition extends YEnum {
  }
  HorizontalPosition.LEFTBORDER = new HorizontalPositionEnumItem("LEFTBORDER", "Left border");
  HorizontalPosition.ABSOLUTEX = new HorizontalPositionEnumItem("ABSOLUTEX", "Absolute X position");
  HorizontalPosition.RIGHTBORDER = new HorizontalPositionEnumItem("RIGHTBORDER", "Right borde");
  DataPanel2.HorizontalPosition = HorizontalPosition;
  class VerticalPositionEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, VerticalPosition);
    }
  }
  DataPanel2.VerticalPositionEnumItem = VerticalPositionEnumItem;
  class VerticalPosition extends YEnum {
  }
  VerticalPosition.TOPBORDER = new VerticalPositionEnumItem("TOPBORDER", "Top border");
  VerticalPosition.ABSOLUTEY = new VerticalPositionEnumItem("ABSOLUTEY", "Absolute Y position");
  VerticalPosition.BOTTOMBORDER = new VerticalPositionEnumItem("BOTTOMBORDER", "Bottom border");
  DataPanel2.VerticalPosition = VerticalPosition;
})(DataPanel || (DataPanel = {}));
var YCursor = class {
  constructor(pngImageData) {
  }
  get handle() {
    return "crosshair";
  }
};
var YTimeSpan = class {
  constructor(value) {
    this._value = 0;
    this._value = value;
  }
  toString(format) {
    let res = "";
    let v = Math.abs(this._value / 1e3);
    let dec = Math.floor(v);
    let frac = Math.round(1e3 * (v - Math.floor(v)));
    if (format & YDate.ms1) {
      let ms = "00" + frac.toString();
      res = "." + ms.substring(ms.length - 3).substring(0, 1);
    } else if (format & YDate.ms01) {
      let ms = "00" + frac.toString();
      res = "." + ms.substring(ms.length - 3).substring(0, 2);
    } else if (format & YDate.ms001) {
      let ms = "00" + frac.toString();
      res = "." + ms.substring(ms.length - 3).substring(0, 3);
    }
    if (format & YDate.s) {
      let sec = dec % 60;
      let s = "0" + sec.toString();
      res = s.substring(s.length - 2) + res + "s";
    }
    dec = Math.floor(dec / 60);
    if (format & YDate.m) {
      let min = dec % 60;
      let s = "0" + min.toString();
      res = s.substring(s.length - 2) + "m" + res;
    }
    dec = Math.floor(dec / 60);
    if (format & YDate.h) {
      let hrs = dec % 24;
      let s = "0" + hrs.toString();
      res = s.substring(s.length - 2) + "h" + res;
    }
    dec = Math.floor(dec / 24);
    if (format & YDate.D) {
      let s = dec.toString();
      res = s.substring(s.length - 2) + "d" + res;
    }
    return res;
  }
};
YTimeSpan.TicksPerSecond = 1e3;
var YGraph = class extends YDataRenderer {
  get legendPanel() {
    return this._legendPanel;
  }
  get dataTracker() {
    return this._dataTracker;
  }
  get borderColor() {
    return this._borderColor;
  }
  set borderColor(value) {
    this._borderColor = value;
    this._borderPen = null;
    this.redraw();
  }
  get borderThickness() {
    return this._borderThickness;
  }
  set borderThickness(value) {
    if (value < 0)
      throw new RangeError("thickness must be a positive value");
    this._borderThickness = value;
    this._borderPen = null;
    this.redraw();
  }
  static get verticalDragZoomEnabled() {
    return YGraph._defaultVerticalDragZoomEnabled;
  }
  static set verticalDragZoomEnabled(value) {
    YGraph._defaultVerticalDragZoomEnabled = value;
  }
  static createCaptureCursor() {
    if (YGraph.captureCursor != null)
      return;
    let base64png = "iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAALHRFWHRDcmVhdGlvbiBUaW1lAFRodSAyMCBBdWcgMjAyMCAxMjoxNTo1MCArMDEwMP38NhoAAAAHdElNRQfkCBQOJAvCrm0ZAAAACXBIWXMAAFxGAABcRgEUlENBAAAABGdBTUEAALGPC / xhBQAAAmVJREFUeNrtVrFuFDEQHd9eBImAIBFoAgVC0NJQUFDwL / QgRXzAfUz + Iy0pQwsIJAhCQMQBUS5c2DXv7T5fzN5qs / Fxdw0jPY3ttT3jt54ZmyXIYDDoQXnodWBV / SRJXZhJbwCXov65pZ + 4zklfBsZRf2EMxOuTjc / igIu0s0UygAvnonWZ0NP4fB2QkQz6yHvP / i76V4E1jZ / bic4LIuMnND7ZwDl + u4 / me + AnkKPvu + 7rFMNZBzZ64eRTm5w6sQ8cAcUZexVytOCpOnv7j + QdDD + CHgKjMg80nWpeQrYgd4A3wHjWPJAqN4BVoLcsB1ZMd25ZDkzkvwNLd6AMQ4XGIuXElKz6SAo3rYpLhsZKyyJmwu2WTLiF5g / g2NozIY1 / BkacRwaYkZgUPlr7L2EdeAhjLxpqwTOr0vAHOZG37FPIOO3mfXXG1qEWAGvM + TC6Rydk / KmMv7bmWlD / v95qtaCThGpo1TPsFvp7wBO0v4nBqWoYvR0yOeLFThHmdH4TcgGQy8i + hkn5V / WbSjGr7e9oD96372LJB1o7izbPtYHpPw7V / 8u4yvzFkvPTO3MXuMbx8JRPij8svgAcAw / EwCe0f8XGxZYFB6JQZzl + rHWj1Gf5WZLVTj5py5HbVoXjeF4OuMhYnQHKulW / x6U64CPtbfpVxQu7CX0PeicMov3cKup5EZmw / KwMFNb8pMtl5G3MhIyHkOX3PPUSMmXzOX7Fqsw35Gu5NidEwXWr / jnnD + XUFzLARJRaDXnCQ53o0BpSLzcXzQfAK + Cl9EEwXrKTyr1OWGa3sFnLvPDsn6Tg8P0PrBcSMR2NtfsAAAAASUVORK5CYII =";
    try {
      YGraph.captureCursor = new YCursor(atob(base64png));
    } catch (Exception) {
      console.log("Cannot create custom cursor");
    }
  }
  get dataPanels() {
    return this._dataPanels;
  }
  addDataPanel() {
    let p = new DataPanel(this, this);
    this._dataPanels.push(p);
    return p;
  }
  setMarkerCaptureCallbacks(start, stop) {
    this._markerCaptureStartedCallback = start;
    this._markerCaptureStoppedCallback = stop;
  }
  startMarkerCapture(m) {
    if (this._markerCaptureStartedCallback != null)
      this._markerCaptureStartedCallback(m);
    this.markerCapture = m;
    this.UIContainer.focus();
  }
  constructor(ChartContainer, logFunction) {
    super(ChartContainer, logFunction);
    this._markerCaptureStartedCallback = null;
    this._markerCaptureStoppedCallback = null;
    this.lastPointCount = -1;
    this.lastTopMargin = -1;
    this.lastBottomMargin = -1;
    this.navigatorCache = null;
    this.markerCapture = null;
    this._borderPen = null;
    this._borderColor = YColor.LightGray;
    this._borderThickness = 1;
    this._touchStartfct = null;
    this._touchMovefct = null;
    this._touchEndfct = null;
    this._mouseDownfct = null;
    this._mouseMovefct = null;
    this._mouseWheelfct = null;
    this._mouseKeyDownfct = null;
    this.mainViewPort = new ViewPortSettings();
    this._timeRange = null;
    this._bgBrush = null;
    this._bgColor1 = YColor.FromArgb(255, 200, 200, 200);
    this._bgColor2 = YColor.FromArgb(255, 255, 255, 255);
    this._touchStartPinchDistance = -1;
    this._touchStartPinchCenter = new Point(0, 0);
    this._touchStartPinchZoom = 1;
    this._touchStartPinchIRLx = 0;
    this._touchStartPinchRange = 0;
    this.dataTrackerRefreshtimeout = null;
    YGraph.createCaptureCursor();
    this._xAxis = new XAxis(this, this);
    this._yAxes = [];
    this._series = [];
    this._dataPanels = [];
    this._navigator = new Navigator(this, this);
    this._legendPanel = new LegendPanel(this, this);
    this._dataTracker = new DataTracker(this, this);
    this._touchStartfct = (e) => {
      this.TouchStart(this.UIContainer, e);
    };
    this._touchMovefct = (e) => {
      this.TouchMove(this.UIContainer, e);
    };
    this._touchEndfct = (e) => {
      this.TouchEnd(this.UIContainer, e);
    };
    this._mouseDownfct = (e) => {
      this.MouseDown(this.UIContainer, e);
    };
    this._mouseMovefct = (e) => {
      this.MouseMove(this.UIContainer, e);
    };
    this._mouseWheelfct = (e) => {
      this.mouseWheelEvent(this.UIContainer, e);
    };
    this._mouseKeyDownfct = (e) => {
      this.KeyDown(this.UIContainer, e);
    };
    this.UIContainer.addEventListener("touchstart", this._touchStartfct);
    this.UIContainer.addEventListener("touchmove", this._touchMovefct);
    this.UIContainer.addEventListener("touchend", this._touchEndfct);
    this.UIContainer.addEventListener("mousedown", this._mouseDownfct);
    this.UIContainer.addEventListener("mousemove", this._mouseMovefct);
    this.UIContainer.addEventListener("wheel", this._mouseWheelfct);
    this.UIContainer.addEventListener("keydown", this._mouseKeyDownfct);
    this._timeRange = MinMaxHandler.DefaultValue();
    let originalContainerWidth = ChartContainer.width;
    let originalContainerHeight = ChartContainer.height;
    let originalFormWidth = ChartContainer.width;
    let originalFormHeight = ChartContainer.height;
  }
  destroy() {
    if (this._touchStartfct != null)
      this.UIContainer.removeEventListener("touchstart", this._touchStartfct);
    if (this._touchMovefct != null)
      this.UIContainer.removeEventListener("touchstart", this._touchMovefct);
    if (this._touchEndfct != null)
      this.UIContainer.removeEventListener("touchstart", this._touchEndfct);
    if (this._mouseDownfct != null)
      this.UIContainer.removeEventListener("mousedown", this._mouseDownfct);
    if (this._mouseMovefct != null)
      this.UIContainer.removeEventListener("mousemove", this._mouseMovefct);
    if (this._mouseWheelfct != null)
      this.UIContainer.removeEventListener("wheel", this._mouseWheelfct);
    if (this._mouseKeyDownfct != null)
      this.UIContainer.removeEventListener("keydown", this._mouseKeyDownfct);
    super.destroy();
    Object.entries(this).forEach((pair) => {
      Reflect.set(this, pair[0], null);
    });
  }
  getMostRecentPoint() {
    let res = new pointXY(NaN, NaN);
    for (let i = 0; i < this._series.length; i++)
      if (!this.series[i].disabled) {
        let p = this.series[i].getlastPoint();
        if (!isNaN(p.x)) {
          if (isNaN(res.x))
            res = p;
          else if (p.x > res.x)
            res = p;
        }
      }
    return res;
  }
  adjustGlobalTimeRange(x) {
    let max = this._timeRange.Max;
    this._timeRange = MinMaxHandler.CombineWithNumber(this._timeRange, x);
    if (isNaN(max))
      return;
    let ofset = x - max;
    if (ofset > 0) {
      switch (this._xAxis.overflowHandling) {
        case XAxis.OverflowHandling.SCROLL:
          if (max > this._xAxis.min + (this._xAxis.max - this._xAxis.min) * 0.85 && max <= this._xAxis.max) {
            this.DisableRedraw();
            this._xAxis.set_minMax(this._xAxis.min + ofset, this._xAxis.max + ofset);
            this.AllowRedraw();
          }
          break;
        case XAxis.OverflowHandling.CONTRACT:
          if (max > this._xAxis.min + (this._xAxis.max - this._xAxis.min) * 0.95 && max <= this._xAxis.max) {
            this.DisableRedraw();
            this._xAxis.max += ofset;
            this.AllowRedraw();
          }
          break;
      }
    }
  }
  get bgColor1() {
    return this._bgColor1;
  }
  set bgColor1(value) {
    this._bgColor1 = value;
    this._bgBrush = null;
    this.redraw();
  }
  get bgColor2() {
    return this._bgColor2;
  }
  set bgColor2(value) {
    this._bgColor2 = value;
    this._bgBrush = null;
    this.redraw();
  }
  get xAxis() {
    return this._xAxis;
  }
  get navigator() {
    return this._navigator;
  }
  get yAxes() {
    return this._yAxes;
  }
  get series() {
    return this._series;
  }
  addYAxis() {
    let s = new YAxis(this, this, this._yAxes.length);
    this._yAxes.push(s);
    this.redraw();
    return s;
  }
  addSerie() {
    let s = new DataSerie(this);
    this._series.push(s);
    this.redraw();
    return s;
  }
  clearCachedObjects() {
    this._bgBrush = null;
    this.navigatorCache = null;
  }
  TouchStart(sender, e) {
    if (e.touches.length == 1) {
      this.HandleMouseDown(sender, e.touches[0].pageX, e.touches[0].pageY);
    } else if (e.touches.length == 2) {
      e.preventDefault();
      this.HandleEndOfMouseCapture();
      this._touchStartPinchDistance = Math.sqrt(Math.pow(e.touches[1].pageX - e.touches[0].pageX, 2) + Math.pow(e.touches[1].pageY - e.touches[0].pageY, 2));
      this._touchStartPinchCenter = new Point(e.touches[1].pageX + e.touches[0].pageX >> 2, e.touches[1].pageY + e.touches[0].pageY >> 2);
      this._touchStartPinchZoom = this.mainViewPort.zoomx;
      this._touchStartPinchIRLx = this.mainViewPort.IRLx;
      this._touchStartPinchRange = this._xAxis.max - this._xAxis.min;
    }
  }
  MouseDown(sender, e) {
    if (e.buttons == 2 && this.markerCapture != null) {
      this.markerCapture = null;
      if (this._markerCaptureStoppedCallback != null)
        this._markerCaptureStoppedCallback(null);
    }
    if (e.buttons != 1)
      return;
    this.HandleMouseDown(sender, e.pageX, e.pageY);
  }
  HandleMouseDown(sender, pageX, pageY) {
    let p = this.Scr2ElmMatrix.multiplyByV(Vector3.FromXYCoord(pageX, pageY)).toPoint();
    let eX = p.X;
    let eY = p.Y;
    if (eX >= this.mainViewPort.Lmargin && eX <= this.mainViewPort.Width - this.mainViewPort.Rmargin && eY >= this.mainViewPort.Tmargin && eY <= this.mainViewPort.Height - this.mainViewPort.Bmargin) {
      if (this.markerCapture != null) {
        let p22 = YGraph.ViewPortPointToIRL(this.mainViewPort, new Point(eX, eY));
        this.markerCapture.setCapturedPosition(p22.x, this.xAxis);
        if (this._markerCaptureStoppedCallback != null)
          this._markerCaptureStoppedCallback(this.markerCapture);
        this.markerCapture = null;
        return;
      }
      let p2 = YGraph.ViewPortPointToIRL(this.mainViewPort, new Point(eX, eY));
      this.mainViewPort.OriginalXAxisMin = this.xAxis.min;
      this.mainViewPort.OriginalXAxisMax = this.xAxis.max;
      this.mainViewPort.OriginalIRLx = this.mainViewPort.IRLx;
      this.mainViewPort.OriginalLmargin = this.mainViewPort.Lmargin;
      this.mainViewPort.OriginalZoomx = this.mainViewPort.zoomx;
      this.mainViewPort.CaptureStartY = eY;
      this.mainViewPort.IRLCaptureStartX = p2.x;
      this.mainViewPort.Capture = true;
    } else if (eX >= this._navigator.viewport.Lmargin && eX <= this._navigator.viewport.Width - this._navigator.viewport.Rmargin && eY >= this._navigator.viewport.Lmargin && eY <= this._navigator.viewport.Height - this._navigator.viewport.Bmargin) {
      let p2 = YGraph.ViewPortPointToIRL(this._navigator.viewport, new Point(eX, eY));
      let p22 = YGraph.ViewPortPointToIRL(this.mainViewPort, new Point(this.mainViewPort.Lmargin, 0));
      let p3 = YGraph.ViewPortPointToIRL(this.mainViewPort, new Point(this.mainViewPort.Width - this.mainViewPort.Rmargin, 0));
      if (p2.x >= p22.x && p2.x <= p3.x) {
        this._navigator.startCapture(p2, this._xAxis.min, this._xAxis.max);
      } else {
        this.DisableRedraw();
        let min = p2.x - (p3.x - p22.x) / 2;
        let max = min + (p3.x - p22.x);
        this._xAxis.set_minMax(min, max);
        this.AllowRedraw();
        this.Draw(0);
      }
    }
  }
  TouchMove(sender, e) {
    if (e.touches.length == 1) {
      e.preventDefault();
      this.HandleMouseMove(sender, e.touches[0].pageX, e.touches[0].pageY);
    } else if (e.touches.length == 2) {
      e.preventDefault();
      let newdistance = Math.sqrt(Math.pow(e.touches[1].pageX - e.touches[0].pageX, 2) + Math.pow(e.touches[1].pageY - e.touches[0].pageY, 2));
      let ZoomFactor = newdistance / this._touchStartPinchDistance;
      let NextZoomX = this._touchStartPinchZoom * ZoomFactor;
      if (NextZoomX > this.mainViewPort.zoomx && NextZoomX > 1e3)
        return;
      let currentRange = this._xAxis.max - this._xAxis.min;
      this.mainViewPort.IRLx = this._touchStartPinchIRLx + (this._touchStartPinchCenter.X - this.mainViewPort.Lmargin) / this._touchStartPinchZoom - (this._touchStartPinchCenter.X - this.mainViewPort.Lmargin) / NextZoomX;
      this._xAxis.set_minMax(this.mainViewPort.IRLx, this.mainViewPort.IRLx + this._touchStartPinchRange / ZoomFactor);
      this.mainViewPort.zoomx = NextZoomX;
      this.redraw();
    }
  }
  TouchEnd(sender, e) {
    this.HandleEndOfMouseCapture();
  }
  MouseMove(sender, e) {
    if (e.buttons != 1 && (this.mainViewPort.Capture || this._navigator.Capture))
      this.HandleEndOfMouseCapture();
    this.HandleMouseMove(sender, e.pageX, e.pageY);
    if (this.dataTracker.enabled) {
      if (this.dataTrackerRefreshtimeout != null)
        clearTimeout(this.dataTrackerRefreshtimeout);
      this.dataTrackerRefreshtimeout = setTimeout(() => {
        this.redraw();
      }, 100);
    }
  }
  HandleEndOfMouseCapture() {
    this.mainViewPort.Capture = false;
    this._navigator.stopCapture();
    if (this._dataTracker.enabled)
      this.redraw();
  }
  HandleMouseMove(sender, pageX, pageY) {
    let p = this.Scr2ElmMatrix.multiplyByV(Vector3.FromXYCoord(pageX, pageY)).toPoint();
    let eX = p.X;
    let eY = p.Y;
    if (this.markerCapture != null) {
      if (eX > this.mainViewPort.Lmargin && eX < this.mainViewPort.Width - this.mainViewPort.Rmargin && eY > this.mainViewPort.Tmargin && eY < this.mainViewPort.Height - this.mainViewPort.Bmargin) {
        if (this.UIContainer.style.cursor != YGraph.captureCursor.handle && this.UIContainer.style.cursor != "crosshair") {
          this.UIContainer.style.cursor = YGraph.captureCursor != null ? YGraph.captureCursor.handle : "crosshair";
        }
      } else if (this.UIContainer.style.cursor != "default")
        this.UIContainer.style.cursor = "default";
    } else if (this.UIContainer.style.cursor != "default")
      this.UIContainer.style.cursor = "default";
    if (this.mainViewPort.Capture) {
      let x1 = this.mainViewPort.OriginalIRLx + (eX - this.mainViewPort.OriginalLmargin) / this.mainViewPort.OriginalZoomx;
      let deltaX = x1 - this.mainViewPort.IRLCaptureStartX;
      let deltaY = eY - this.mainViewPort.CaptureStartY;
      this.DisableRedraw();
      let halfAxisDelta = (this.mainViewPort.OriginalXAxisMax - this.mainViewPort.OriginalXAxisMin) / 2;
      let Axismiddle = (this.mainViewPort.OriginalXAxisMax + this.mainViewPort.OriginalXAxisMin) / 2;
      let deltaCoef = YGraph._defaultVerticalDragZoomEnabled && Math.abs(deltaY) > 10 ? Math.pow(1.01, deltaY) : 1;
      this._xAxis.set_minMax(Axismiddle - halfAxisDelta * deltaCoef - deltaX, Axismiddle + halfAxisDelta * deltaCoef - deltaX);
      this.AllowRedraw();
      this.redraw();
      return;
    }
    if (this._navigator.viewport.Capture) {
      let x1 = this._navigator.viewport.OriginalIRLx + (eX - this._navigator.viewport.OriginalLmargin) / this._navigator.viewport.OriginalZoomx;
      let delta = x1 - this._navigator.viewport.IRLCaptureStartX;
      this.DisableRedraw();
      this._xAxis.set_minMax(this._navigator.viewport.OriginalXAxisMin + delta, this._navigator.viewport.OriginalXAxisMax + delta);
      this.AllowRedraw();
      this.redraw();
      return;
    }
  }
  cross(p) {
  }
  static IRLPointToViewPort(viewport, p, IRLy, zoomy) {
    if (IRLy === void 0) {
      let xx2 = viewport.Lmargin + Math.round((p.x - viewport.IRLx) * viewport.zoomx);
      let yy2 = viewport.Height - viewport.Bmargin - Math.round((p.y - viewport.IRLy) * viewport.zoomy);
      return new Point(xx2 >> 0, yy2 >> 0);
    }
    let xx = viewport.Lmargin + Math.round((p.x - viewport.IRLx) * viewport.zoomx);
    let yy = viewport.Height - viewport.Bmargin - Math.round((p.y - IRLy) * zoomy);
    return new Point(xx >> 0, yy >> 0);
  }
  static IRLPointSummaryToViewPort(viewport, p, IRLy, zoomy) {
    if (IRLy === void 0) {
      let x12 = viewport.Lmargin + Math.round((p.x1 - viewport.IRLx) * viewport.zoomx);
      let ymin2 = viewport.Height - viewport.Bmargin - Math.round((p.ymin - viewport.IRLy) * viewport.zoomy);
      let x22 = viewport.Lmargin + Math.round((p.x2 - viewport.IRLx) * viewport.zoomx);
      let ymax2 = viewport.Height - viewport.Bmargin - Math.round((p.ymax - viewport.IRLy) * viewport.zoomy);
      return new minMaxPoint(x12, ymin2, x22, ymax2);
    }
    let x1 = viewport.Lmargin + Math.round((p.x1 - viewport.IRLx) * viewport.zoomx);
    let ymin = viewport.Height - viewport.Bmargin - Math.round((p.ymin - IRLy) * zoomy);
    let x2 = viewport.Lmargin + Math.round((p.x2 - viewport.IRLx) * viewport.zoomx);
    let ymax = viewport.Height - viewport.Bmargin - Math.round((p.ymax - IRLy) * zoomy);
    return new minMaxPoint(x1, ymin, x2, ymax);
  }
  static ViewPortPointToIRL(viewport, p, IRLy, zoomy) {
    if (IRLy === void 0) {
      return new pointXY(viewport.IRLx + (p.X - viewport.Lmargin) / viewport.zoomx, viewport.IRLy + (+viewport.Height - p.Y - viewport.Bmargin) / viewport.zoomy);
    }
    return new pointXY(viewport.IRLx + (p.X - viewport.Lmargin) / viewport.zoomx, IRLy + (+viewport.Height - p.Y - viewport.Bmargin) / zoomy);
  }
  static FindMinMax(start, end, data, count) {
    let res = MinMaxHandler.DefaultValue();
    if (data[0].x > end)
      return res;
    if (data[count - 1].x < start)
      return res;
    let N1 = 0;
    let N2 = 0;
    let First = 0;
    if (data[0].x < start) {
      N1 = 0;
      N2 = count - 1;
      while (N2 - N1 > 1) {
        let N = N1 + N2 >> 1;
        if (data[N].x > start)
          N2 = N;
        else
          N1 = N;
      }
      First = N1 - 1;
      if (First < 0)
        First = 0;
    }
    let Last = count - 1;
    if (data[Last] === void 0) {
      debugger;
    }
    if (data[Last].x > end) {
      N1 = 0;
      N2 = count - 1;
      while (N2 - N1 > 1) {
        let N = N1 + N2 >> 1;
        if (data[N].x < end)
          N1 = N;
        else
          N2 = N;
      }
      Last = N2 + 1;
      if (Last > count - 1)
        Last = count - 1;
    }
    res.Min = data[First].y;
    res.Max = data[First].y;
    for (let i = First + 1; i <= Last; i++) {
      if (data[i].y < res.Min)
        res.Min = data[i].y;
      if (data[i].y > res.Max)
        res.Max = data[i].y;
    }
    return res;
  }
  resetlegendPens() {
    for (let i = 0; i < this._series.length; i++) {
      this._series[i].resetlegendPen();
    }
  }
  drawLegendPanel(g, viewPortWidth, viewPortHeight, mainViewPort) {
    let verticalRatio = 1.25;
    if (!this._legendPanel.enabled)
      return;
    let legendWidths = new Array(this._series.length);
    let legendHeight = new Array(this._series.length);
    let ofsetx = new Array(this._series.length);
    let ofsety = new Array(this._series.length);
    let legends = new Array(this._series.length);
    let totalHeight = 0;
    let totalWidth = 0;
    let maxWidth = 0;
    let maxHeight = 0;
    g.TextRenderingHint = YTextRenderingHint.SingleBitPerPixelGridFit;
    g.SetClip(new YRectangle(0, 0, viewPortWidth, viewPortHeight));
    for (let i = 0; i < this._series.length; i++) {
      if (this._series[i].legend != "")
        legends[i] = this._series[i].legend;
      else
        legends[i] = "Series " + (i + 1).toString();
    }
    if (this._legendPanel.position == LegendPanel.Position.TOP || this._legendPanel.position == LegendPanel.Position.BOTTOM) {
      let availableWidth = viewPortWidth - 2 * this._legendPanel.padding + this._legendPanel.borderthickness;
      if (this._legendPanel.overlap)
        availableWidth = availableWidth - mainViewPort.Lmargin - mainViewPort.Rmargin;
      totalHeight = 0;
      let xx = 0;
      let yy = 0;
      for (let i = 0; i < this._series.length; i++) {
        if (this._series[i].segments.length > 0 && this._series[i].visible && !this._series[i].disabled) {
          let ssize = g.MeasureString(legends[i], this._legendPanel.font, 1e5);
          legendHeight[i] = ssize.height + 1;
          let ww = ssize.width + 20;
          if (xx == 0)
            totalHeight += ssize.height;
          if (availableWidth - xx < ww) {
            if (xx == 0) {
              ofsetx[i] = xx;
              ofsety[i] = yy;
              yy += ssize.height;
              if (maxWidth < ww)
                maxWidth = ww;
            } else {
              yy += ssize.height;
              ofsetx[i] = 0;
              ofsety[i] = yy;
              xx = ww;
              totalHeight += ssize.height;
              if (maxWidth < xx)
                maxWidth = xx;
            }
          } else {
            ofsetx[i] = xx;
            ofsety[i] = yy;
            xx += ww;
            if (maxWidth < xx)
              maxWidth = xx;
          }
        }
      }
      if (totalWidth > availableWidth) {
        totalWidth = availableWidth;
      }
    } else {
      let ty = 0;
      for (let i = 0; i < this._series.length; i++) {
        if (this._series[i].segments.length > 0 && this._series[i].visible && !this._series[i].disabled) {
          let ssize = g.MeasureString(legends[i], this._legendPanel.font, 1e5);
          legendWidths[i] = ssize.width + 1;
          if (maxWidth < legendWidths[i] + 20)
            maxWidth = legendWidths[i] + 20;
          legendHeight[i] = ssize.height + 1;
          if (maxHeight < legendHeight[i])
            maxHeight = legendHeight[i];
          ofsetx[i] = 0;
          ofsety[i] = ty;
          ty += ssize.height * verticalRatio;
          totalHeight += i == 0 ? ssize.height : ssize.height * verticalRatio;
        }
      }
    }
    let w = maxWidth + 2 * this._legendPanel.padding + this._legendPanel.borderthickness;
    let h = totalHeight + 2 * this._legendPanel.padding + this._legendPanel.borderthickness;
    let x = 0;
    let y = 0;
    switch (this._legendPanel.position) {
      case LegendPanel.Position.LEFT:
        x = this._legendPanel.horizontalMargin;
        if (!this._legendPanel.overlap) {
          mainViewPort.Lmargin += w + 2 * this.legendPanel.horizontalMargin + this.legendPanel.borderthickness >> 0;
          y = (viewPortHeight - h) / 2;
        } else {
          x += mainViewPort.Lmargin;
          y = mainViewPort.Tmargin + (viewPortHeight - mainViewPort.Tmargin - mainViewPort.Bmargin - h) / 2;
        }
        break;
      case LegendPanel.Position.TOPLEFT:
        x = this._legendPanel.horizontalMargin;
        y = this._legendPanel.verticalMargin;
        if (!this._legendPanel.overlap) {
          mainViewPort.Lmargin += w + 2 * this.legendPanel.horizontalMargin + this.legendPanel.borderthickness >> 0;
        } else {
          x += mainViewPort.Lmargin;
          y += mainViewPort.Tmargin;
        }
        break;
      case LegendPanel.Position.TOP:
        if (!this._legendPanel.overlap) {
          x = (viewPortWidth - w) / 2 - this._legendPanel.horizontalMargin - this._legendPanel.borderthickness;
          y = this._legendPanel.verticalMargin + this._legendPanel.borderthickness;
          mainViewPort.Tmargin += totalHeight + this._legendPanel.verticalMargin + 2 * this._legendPanel.verticalMargin + this._legendPanel.borderthickness >> 0;
        } else {
          x = mainViewPort.Lmargin + (viewPortWidth - mainViewPort.Lmargin - mainViewPort.Rmargin - w) / 2 - this._legendPanel.horizontalMargin - this._legendPanel.borderthickness;
          y = mainViewPort.Tmargin + this._legendPanel.verticalMargin - this._legendPanel.borderthickness;
        }
        break;
      case LegendPanel.Position.TOPRIGHT:
        x = viewPortWidth - this._legendPanel.horizontalMargin - w;
        y = this._legendPanel.verticalMargin;
        if (!this._legendPanel.overlap) {
          mainViewPort.Rmargin += w + 2 * this._legendPanel.horizontalMargin + this._legendPanel.borderthickness >> 0;
        } else {
          x -= mainViewPort.Rmargin;
          y += mainViewPort.Tmargin;
        }
        break;
      case LegendPanel.Position.RIGHT:
        x = viewPortWidth - this._legendPanel.horizontalMargin - w;
        if (!this._legendPanel.overlap) {
          mainViewPort.Rmargin += w + 2 * this._legendPanel.horizontalMargin + this._legendPanel.borderthickness >> 0;
          y = (viewPortHeight - h) / 2;
        } else {
          x -= mainViewPort.Rmargin;
          y = mainViewPort.Tmargin + (viewPortHeight - mainViewPort.Tmargin - mainViewPort.Bmargin - h) / 2;
        }
        break;
      case LegendPanel.Position.BOTTOMRIGHT:
        x = viewPortWidth - this._legendPanel.horizontalMargin - w;
        if (!this._legendPanel.overlap) {
          mainViewPort.Rmargin += w + 2 * this._legendPanel.horizontalMargin + this._legendPanel.borderthickness >> 0;
          y = viewPortHeight - this._legendPanel.verticalMargin - h;
        } else {
          x -= mainViewPort.Rmargin;
          y = viewPortHeight - mainViewPort.Bmargin - h - this._legendPanel.verticalMargin;
        }
        break;
      case LegendPanel.Position.BOTTOM:
        if (!this._legendPanel.overlap) {
          x = (viewPortWidth - w) / 2 - this._legendPanel.horizontalMargin - this._legendPanel.borderthickness;
          y = viewPortHeight - this._legendPanel.verticalMargin - 2 * this._legendPanel.padding - this._legendPanel.borderthickness - totalHeight;
          mainViewPort.Bmargin += totalHeight + 2 * this._legendPanel.padding + 2 * this._legendPanel.verticalMargin + this._legendPanel.borderthickness;
        } else {
          x = mainViewPort.Lmargin + (viewPortWidth - mainViewPort.Lmargin - mainViewPort.Rmargin - w) / 2 - this._legendPanel.horizontalMargin - this._legendPanel.borderthickness;
          y = viewPortHeight - mainViewPort.Bmargin - totalHeight - 2 * this._legendPanel.padding - 2 * this._legendPanel.verticalMargin - this._legendPanel.borderthickness;
        }
        break;
      case LegendPanel.Position.BOTTOMLEFT:
        x = this._legendPanel.horizontalMargin;
        y = this._legendPanel.verticalMargin;
        if (!this._legendPanel.overlap) {
          mainViewPort.Lmargin += w + 2 * this._legendPanel.horizontalMargin + this._legendPanel.borderthickness;
          y = viewPortHeight - this._legendPanel.verticalMargin - h;
        } else {
          x += mainViewPort.Lmargin;
          y = viewPortHeight - mainViewPort.Bmargin - h - this._legendPanel.verticalMargin;
        }
        break;
    }
    let rect = new YRectangle(x >> 0, y >> 0, w >> 0, h >> 0);
    g.FillRectangle(this._legendPanel.bgBrush, rect);
    g.DrawRectangle(this._legendPanel.pen, rect);
    g.TextRenderingHint = YTextRenderingHint.AntiAlias;
    for (let i = 0; i < this._series.length; i++) {
      if (this._series[i].segments.length > 0 && this._series[i].visible && !this._series[i].disabled) {
        g.DrawStringXY(legends[i], this._legendPanel.font, this._legendPanel.font.brush, x + ofsetx[i] + 20 + this._legendPanel.padding >> 0, y + ofsety[i] + this._legendPanel.padding >> 0);
        let px = x + ofsetx[i] + this._legendPanel.borderthickness / 2 + this._legendPanel.padding + 6 >> 0;
        let py = y + ofsety[i] + this._legendPanel.padding + legendHeight[i] / 2 >> 0;
        g.DrawLine(this._series[i].legendPen, new PointF(px, py), new PointF(px + 12, py));
      }
    }
  }
  static DoSegmentRendering(w, g, p, data, count, xTimeStart, xTimeEnd) {
    if (data[0].x > xTimeEnd || data[count - 1].x < xTimeStart)
      return 0;
    let isSVG = g instanceof YGraphicsSVG;
    let N1 = 0;
    let N2 = 0;
    let First = 0;
    if (data[0].x < xTimeStart) {
      N1 = 0;
      N2 = count - 1;
      while (N2 - N1 > 1) {
        let N = N1 + N2 >> 1;
        if (data[N].x > xTimeStart)
          N2 = N;
        else
          N1 = N;
      }
      First = N1 - 1;
      if (First < 0)
        First = 0;
    }
    let Last = count - 1;
    if (data[Last].x > xTimeEnd) {
      N1 = 0;
      N2 = count - 1;
      while (N2 - N1 > 1) {
        let N = N1 + N2 >> 1;
        if (data[N].x < xTimeEnd)
          N1 = N;
        else
          N2 = N;
      }
      Last = N2 + 1;
      if (Last > count - 1)
        Last = count - 1;
    }
    if (Last - First > 2 * w.Width - w.Lmargin - w.Rmargin) {
      let ToDraw = new Array(3 * (Last - First + 1));
      let Current = YGraph.IRLPointToViewPort(w, data[First]);
      let New;
      let i = First + 1;
      let n = 0;
      let max;
      let min;
      let limit;
      while (i < Last) {
        ToDraw[n++] = new PointF(Current.X, Current.Y);
        min = data[i].y;
        max = min;
        limit = YGraph.ViewPortPointToIRL(w, new Point(Current.X + 1, Current.Y + 1)).x;
        do {
          if (data[i].y > max)
            max = data[i].y;
          if (data[i].y < min)
            min = data[i].y;
          i++;
        } while (i < Last && data[i].x < limit);
        let p1 = YGraph.IRLPointToViewPort(w, new pointXY(data[i].x, min));
        let p2 = YGraph.IRLPointToViewPort(w, new pointXY(data[i].x, max));
        if (Math.abs(p1.Y - p2.Y) > 2) {
          ToDraw[n++] = new PointF(p1.X, p1.Y);
          ToDraw[n++] = new PointF(p2.X, p2.Y);
        }
        Current = YGraph.IRLPointToViewPort(w, data[i]);
      }
      ToDraw[n++] = Current;
      ToDraw = ToDraw.slice(0, n);
      if (n > 1)
        g.DrawLines(p, ToDraw);
      return n;
    } else {
      if (isSVG) {
        let ToDraw = new Array(Last - First + 1);
        for (let i = First; i <= Last; i++) {
          ToDraw[i - First] = YGraph.IRLPointToViewPort(w, data[i]);
        }
        g.DrawLines(p, ToDraw);
      } else {
        for (let i = First; i < Last; i++) {
          g.DrawLine(p, YGraph.IRLPointToViewPort(w, data[i]), YGraph.IRLPointToViewPort(w, data[i + 1]));
        }
      }
    }
    return Last - First;
  }
  static DoSummarySegmentRendering(w, g, p, data, count, finalPoint, xTimeStart, xTimeEnd) {
    let ToDraw = new Array(2 * count + 1);
    let n = 0;
    if (count > 0) {
      if (data[0].x1 > xTimeEnd || data[count - 1].x2 < xTimeStart)
        return 0;
      let isSVG = g instanceof YGraphicsSVG;
      let N1 = 0;
      let N2 = 0;
      let First = 0;
      if (data[0].x1 < xTimeStart) {
        N1 = 0;
        N2 = count - 1;
        while (N2 - N1 > 1) {
          let N = N1 + N2 >> 1;
          if (data[N].x1 > xTimeStart)
            N2 = N;
          else
            N1 = N;
        }
        First = N1 - 1;
        if (First < 0)
          First = 0;
      }
      let Last = count - 1;
      if (data[Last].x2 > xTimeEnd) {
        N1 = 0;
        N2 = count - 1;
        while (N2 - N1 > 1) {
          let N = N1 + N2 >> 1;
          if (data[N].x2 < xTimeEnd)
            N1 = N;
          else
            N2 = N;
        }
        Last = N2 + 1;
        if (Last > count - 1)
          Last = count - 1;
      }
      let Current;
      let New;
      let i = First;
      let max;
      let min;
      let limit;
      Current = YGraph.IRLPointSummaryToViewPort(w, data[i]);
      ToDraw[n++] = new PointF(Current.X1, Current.YMIN);
      let ymin = Current.YMAX;
      let ymax = Current.YMIN;
      let x = Current.X1;
      let buffered = 0;
      while (i <= Last) {
        Current = YGraph.IRLPointSummaryToViewPort(w, data[i]);
        if (ymin > Current.YMAX)
          ymin = Current.YMAX;
        if (ymax < Current.YMIN)
          ymax = Current.YMIN;
        buffered++;
        if (Current.X2 > x) {
          ToDraw[n++] = new PointF(x, ymin);
          if (ymax - ymin > 2)
            ToDraw[n++] = new PointF(x + Current.X2 >> 1, ymax);
          x = Current.X2;
          ymin = Current.YMAX;
          ymax = Current.YMIN;
          buffered = 0;
        }
        i++;
      }
      if (buffered > 0) {
        ToDraw[n++] = new PointF(x, Current.YMIN);
        ToDraw[n++] = new PointF(x + Current.X2 >> 1, Current.YMAX);
      }
    }
    if (finalPoint) {
      let Current = YGraph.IRLPointSummaryToViewPort(w, finalPoint);
      ToDraw[n++] = new PointF(Current.X1, Current.YMIN);
      ToDraw[n++] = new PointF(Current.X2, Current.YMAX);
    }
    if (n > 1) {
      ToDraw = ToDraw.slice(0, n);
      g.DrawLines(p, ToDraw);
    }
    return n;
  }
  DrawYAxisZones(w, g, scale) {
    if (!scale.visible)
      return;
    let Delta = scale.startStopStep.dataMax - scale.startStopStep.dataMin;
    let YZoom = Delta / (w.Height - w.Bmargin - w.Tmargin);
    for (let i = 0; i < scale.zones.length; i++) {
      if (scale.zones[i].visible) {
        let max = scale.zones[i].max;
        let min = scale.zones[i].min;
        if (Number.isNaN(max)) {
          max = scale.startStopStep.dataMax;
        }
        if (Number.isNaN(min))
          min = scale.startStopStep.dataMin;
        if (max < min) {
          let t = max;
          max = min;
          min = t;
        }
        let y0 = w.Height - w.Bmargin - Math.round((max - scale.startStopStep.dataMin) / YZoom) >> 0;
        let h = Math.round((max - min) / YZoom) >> 0;
        g.FillRectangleXYHW(scale.zones[i].zoneBrush, this.mainViewPort.Lmargin, y0, this.mainViewPort.Width - this.mainViewPort.Rmargin - this.mainViewPort.Lmargin + 1, h);
      }
    }
  }
  DrawXAxisZones(w, g, scale) {
    if (!scale.visible)
      return;
    let delta = scale.max - scale.min;
    let XZoom = delta / (w.Width - w.Lmargin - w.Rmargin);
    for (let i = 0; i < scale.zones.length; i++) {
      if (scale.zones[i].visible) {
        let max = scale.zones[i].max;
        let min = scale.zones[i].min;
        if (Number.isNaN(max))
          max = scale.min;
        if (Number.isNaN(min))
          min = scale.max;
        if (max < min) {
          let t = max;
          max = min;
          min = t;
        }
        let x0 = w.Lmargin + Math.round((min - scale.min) / XZoom) >> 0;
        g.FillRectangleXYHW(scale.zones[i].zoneBrush, x0, this.mainViewPort.Tmargin, (max - min) / XZoom >> 0, this.mainViewPort.Height - this.mainViewPort.Tmargin - this.mainViewPort.Bmargin);
      }
    }
  }
  static DrawYAxis(w, g, axis, ofset, simulation) {
    if (!axis.visible) {
      axis.innerWidth = 0;
      return axis.innerWidth;
    }
    let Delta = axis.startStopStep.dataMax - axis.startStopStep.dataMin;
    let YZoom = Delta / (w.Height - w.Bmargin - w.Tmargin);
    let leftSide = axis.position == YAxis.HrzPosition.LEFT;
    let x = leftSide ? w.Lmargin - ofset : w.Width - w.Rmargin + ofset;
    if (!simulation)
      g.DrawLineXY(axis.pen, x, w.Tmargin, x, w.Height - w.Bmargin);
    let format = new YStringFormat(16384);
    format.LineAlignment = 1;
    format.Alignment = leftSide ? 2 : 0;
    let FirstStep = axis.startStopStep.step * Math.floor(axis.startStopStep.start / axis.startStopStep.step);
    if (FirstStep < 0) {
      FirstStep -= axis.startStopStep.step;
    }
    let stepCount = ((Delta - (FirstStep - axis.startStopStep.dataMin)) / axis.startStopStep.step >> 0) + 1;
    if (!simulation)
      g.TextRenderingHint = YTextRenderingHint.AntiAlias;
    let UnitWidth = 0;
    let labelPrecision = 0;
    if (axis.startStopStep.precision < 0)
      labelPrecision = -axis.startStopStep.precision;
    if (stepCount < w.Height) {
      for (let i = 0; i < stepCount; i++) {
        let y = Math.round((FirstStep + i * axis.startStopStep.step - axis.startStopStep.dataMin) / YZoom) >> 0;
        if (y >= 0) {
          y = w.Height - w.Bmargin - y;
          let v = FirstStep + i * axis.startStopStep.step;
          if (!simulation) {
            if (axis.showGrid && (i > 0 || axis.startStopStep.dataMin != 0))
              g.DrawLineXY(axis.gridPen, w.Lmargin, y, w.Width - w.Rmargin, y);
            if (Math.abs(v) < 1e-6 && axis.highlightZero) {
              g.DrawLineXY(axis.pen, w.Lmargin, y, w.Width - w.Rmargin, y);
            }
            g.DrawLineXY(axis.pen, x + (leftSide ? -2 : 2), y, x + (leftSide ? 5 : -5), y);
          }
          let label = v.toFixed(labelPrecision);
          let ssize = g.MeasureString(label, axis.font, 1e5);
          if (ssize.width > UnitWidth)
            UnitWidth = ssize.width;
          if (!simulation) {
            let p = new Point(x + (leftSide ? -3 : 3), y);
            g.DrawStringPF(label, axis.font, axis.font.brush, p, format);
          }
        }
      }
    }
    if (axis.legend.title != "") {
      let size = g.MeasureString(axis.legend.title, axis.legend.font, 1e5);
      if (!simulation) {
        let format2 = new YStringFormat(16384);
        format2.Alignment = 1;
        format2.LineAlignment = 1;
        format2.Trimming = 0;
        let legendX = x + (leftSide ? -UnitWidth - size.height : UnitWidth + size.height + 2) >> 0;
        let legendY = w.Tmargin + (w.Height - w.Tmargin - w.Bmargin) / 2 >> 0;
        g.Transform(legendX, legendY, leftSide ? -Math.PI / 2 : Math.PI / 2);
        g.DrawStringPF(axis.legend.title, axis.legend.font, axis.legend.font.brush, new Point(0, 0), format2);
        g.ResetTransform();
      }
      UnitWidth += size.height;
    }
    axis.innerWidth = (UnitWidth >> 0) + 10;
    return axis.innerWidth;
  }
  DrawMonitorXAxis(w, g, xRange, format) {
    let delta = xRange.Max - xRange.Min;
    let scale = TimeConverter.BestTimeformat(delta, delta, this.xAxis.timeReference);
    let XZoom = delta / (w.Width - w.Lmargin - w.Rmargin);
    let stepCount = (delta / scale.step >> 0) + 2;
    let FirstStep = scale.step * Math.floor(xRange.Min / scale.step);
    if (FirstStep < xRange.Min)
      FirstStep += scale.step;
    g.TextRenderingHint = YTextRenderingHint.AntiAlias;
    let y = w.Height - w.Bmargin;
    g.DrawLineXY(this._navigator.pen, w.Lmargin, w.Height - w.Bmargin - 1, w.Width - w.Rmargin, w.Height - w.Bmargin - 1);
    let label;
    let t = FirstStep;
    do {
      let d = TimeConverter.FromUnixTime(t);
      if (scale.step > 31.1 * 86400) {
        t = TimeConverter.ToUnixTime(new Date(d.getFullYear(), d.getMonth(), 1));
      }
      if (t >= xRange.Min) {
        let x = w.Lmargin + Math.round((t - xRange.Min) / XZoom);
        g.DrawLineXY(this._navigator.pen, x, y, x, y - 4);
        if (format == XAxis.FORMATAUTO) {
          label = TimeConverter.FromUnixTime(t).ToString(scale.format);
        } else {
          label = TimeConverter.FromUnixTime(t).ToString(format);
        }
        let ssize = g.MeasureString(label, this._navigator.font, 1e5);
        g.DrawString(label, this._navigator.font, this._navigator.font.brush, new Point(x - ssize.width / 2, y - ssize.height - 1));
      }
      t += scale.step;
    } while (t < xRange.Max);
  }
  static XLabel(t, scale, scaleFormat, timeRange) {
    let label;
    if (scale.timeReference == TimeConverter.TimeReference.ABSOLUTE) {
      if (scale.labelFormat == XAxis.FORMATAUTO) {
        label = TimeConverter.FromUnixTime(t).ToString(scaleFormat.format);
      } else {
        label = t.toString();
      }
    } else {
      let ticks = YTimeSpan.TicksPerSecond * (Math.round(1e3 * (t - scale.zeroTime)) / 1e3);
      label = ticks < 0 ? "-" + new YTimeSpan(-ticks).toString(scaleFormat.format) : new YTimeSpan(ticks).toString(scaleFormat.format);
    }
    return label;
  }
  DrawXAxis(w, g, scale, simulation) {
    if (w.Width - w.Rmargin - w.Lmargin < 10)
      return 1;
    let stringFormat = new YStringFormat(16384);
    stringFormat.Alignment = 1;
    let bottomSide = scale.position == XAxis.VrtPosition.BOTTOM;
    let y = bottomSide ? w.Height - w.Bmargin : w.Tmargin;
    if (!simulation)
      g.DrawLineXY(scale.pen, w.Lmargin, y, w.Width - w.Rmargin, y);
    let delta = scale.max - scale.min;
    let XZoom = delta / (w.Width - w.Lmargin - w.Rmargin);
    let stepCount = (delta / scale.step >> 0) + 1;
    let FirstStep = 0;
    let timeRange = MinMaxHandler.DefaultValue();
    for (let i = 0; i < this._series.length; i++) {
      if (!this._series[i].disabled) {
        timeRange = MinMaxHandler.Combine(timeRange, this._series[i].timeRange);
      }
    }
    scale.zeroTime = timeRange.Min;
    if (scale.timeReference == TimeConverter.TimeReference.ABSOLUTE) {
      FirstStep = scale.step * Math.floor(scale.min / scale.step);
      timeRange.Min = scale.min;
      timeRange.Max = scale.max;
    } else {
      if (Number.isNaN(timeRange.Min))
        return 0;
      FirstStep = timeRange.Min + scale.step * Math.floor((scale.min - scale.zeroTime) / scale.step);
    }
    if (FirstStep < scale.min)
      FirstStep += scale.step;
    let timeOffset = 0;
    if (scale.timeReference != TimeConverter.TimeReference.ABSOLUTE) {
      timeOffset = FirstStep;
    }
    scale.fullSize = timeRange.Max - timeRange.Min;
    let scaleFormat = scale.bestFormat(timeRange.Max - timeRange.Min, scale.max - scale.min);
    if (!simulation)
      g.TextRenderingHint = YTextRenderingHint.AntiAlias;
    let UnitHeight = 0;
    let label;
    scale.step = scaleFormat.step;
    let t = parseFloat(FirstStep.toString());
    label = YGraph.XLabel(t, scale, scaleFormat, timeRange);
    let ssize = g.MeasureString(label, scale.font, 1e5);
    let mod = 1;
    while (mod * (w.Width - w.Rmargin - w.Lmargin) / stepCount < ssize.width) {
      mod++;
    }
    let steps = Math.round((t - timeOffset) / scale.step) >> 0;
    let previousT = 0;
    do {
      let d = TimeConverter.FromUnixTime(t);
      if (scale.step > 32 * 86400 && scale.timeReference == TimeConverter.TimeReference.ABSOLUTE) {
        if (scale.step >= 365 * 86400) {
          let m = d.getMonth();
          t = TimeConverter.ToUnixTime(new Date(d.getFullYear() + (m > 5 ? 1 : 0), 0, 1));
        } else
          t = TimeConverter.ToUnixTime(new Date(d.getFullYear(), d.getMonth(), 1));
        if (t < previousT) {
          debugger;
        }
      }
      if (t >= scale.min) {
        let x = w.Lmargin + Math.round((t - scale.min) / XZoom) >> 0;
        if (x <= w.Width - w.Rmargin) {
          if (!simulation) {
            if (scale.showGrid)
              g.DrawLineXY(scale.gridPen, x, w.Tmargin, x, w.Height - w.Bmargin);
            g.DrawLineXY(scale.pen, x, y + (bottomSide ? 2 : -2), x, y + (bottomSide ? -5 : 5));
          }
          label = YGraph.XLabel(t, scale, scaleFormat, timeRange);
          ssize = g.MeasureString(label, scale.font, 1e5);
          if (ssize.height > UnitHeight)
            UnitHeight = ssize.height;
          if (!simulation) {
            if (steps % mod == 0) {
              g.DrawStringPF(label, scale.font, scale.font.brush, new PointF(x, y + (bottomSide ? 5 : -ssize.height >> 0) - 2), stringFormat);
            }
          }
        }
      }
      previousT = t;
      t += scale.step;
      if (t < previousT)
        debugger;
      steps++;
    } while (t <= scale.max);
    if (scale.legend.title != "") {
      let size = g.MeasureString(scale.legend.title, scale.legend.font, 1e5);
      if (!simulation) {
        let legendX = w.Lmargin + (w.Width - w.Lmargin - w.Rmargin - size.width) / 2 >> 0;
        let legendY = bottomSide ? w.Height - w.Bmargin + UnitHeight + 5 : w.Tmargin - UnitHeight - size.height * 1.5;
        g.DrawString(scale.legend.title, scale.legend.font, scale.legend.font.brush, new PointF(legendX, legendY));
      }
      UnitHeight += size.height >> 0;
    }
    scale.innerHeight = (UnitHeight >> 0) + 10;
    return scale.innerHeight;
  }
  pixelxSize(mainViewPort, scaleX) {
    let dtime = scaleX.max - scaleX.min;
    let dview = mainViewPort.Width - mainViewPort.Lmargin - mainViewPort.Rmargin;
    if (dview > 0)
      return dtime / dview;
    return 0;
  }
  TimeToAutoSting(t, mainViewPort, scaleX) {
    let strValue = "";
    let dtime = scaleX.max - scaleX.min;
    let months = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
    if (dtime > 0) {
      let pixelSize = this.pixelxSize(mainViewPort, scaleX);
      if (pixelSize > 0) {
        if (scaleX.timeReference == TimeConverter.TimeReference.ABSOLUTE) {
          let date = TimeConverter.FromUnixTime(t);
          let MMMM = months[date.getMonth()];
          let dd = date.getDate().toString();
          let HH = date.getHours().toString();
          if (HH.length < 2)
            HH = "0" + HH;
          let mm = date.getMinutes().toString();
          if (mm.length < 2)
            mm = "0" + mm;
          let ss = date.getSeconds().toString();
          if (ss.length < 2)
            ss = "0" + ss;
          let ff = Math.round(date.getMilliseconds() / 10).toString();
          if (ff.length < 2)
            ff = "0" + ss;
          let f = Math.round(date.getMilliseconds() / 100).toString();
          if (dtime >= 86400)
            strValue += MMMM + " " + dd;
          if (pixelSize < 0.1) {
            strValue += (strValue != "" ? " " : "") + HH + ":" + mm + ":" + ss + "." + ff;
          } else if (pixelSize < 1) {
            strValue += (strValue != "" ? " " : "") + HH + ":" + mm + ":" + ss + "." + f;
          } else if (pixelSize < 60) {
            strValue += (strValue != "" ? " " : "") + HH + ":" + mm + ":" + ss;
          } else if (pixelSize < 3600) {
            strValue += (strValue != "" ? " " : "") + HH + ":" + mm;
          } else if (pixelSize < 86400)
            strValue += (strValue != "" ? " " : "") + HH + "H";
        } else {
          let format = TimeConverter.RelativeFormat(scaleX.fullSize, dtime, pixelSize);
          let ticks = YTimeSpan.TicksPerSecond * (Math.round(100 * (t - scaleX.zeroTime)) / 100);
          strValue += ticks < 0 ? "-" + new YTimeSpan(-ticks).toString(format) : new YTimeSpan(ticks).toString(format);
        }
      }
    }
    return strValue;
  }
  DrawDataTracker(g, viewPortWidth, viewPortHeight, scaleX) {
    if (!this._dataTracker.enabled) {
      return;
    }
    let p = this.mouseLocalPosition();
    if (p == null) {
      return;
    }
    if (p.X <= this.mainViewPort.Lmargin) {
      return;
    }
    if (p.Y <= this.mainViewPort.Tmargin) {
      return;
    }
    if (p.X >= this.UIContainer.width - this.mainViewPort.Rmargin) {
      return;
    }
    if (p.Y >= this.UIContainer.height - this.mainViewPort.Bmargin) {
      return;
    }
    g.SetClip(new YRectangle(0, 0, viewPortWidth, viewPortHeight));
    let DataPoint = YGraph.ViewPortPointToIRL(this.mainViewPort, p);
    let delta = -1;
    let bestindex = -1;
    let bestmatch = new Array(this._series.length);
    let IRLmatch = new Array(this._series.length);
    for (let i = 0; i < this._series.length; i++) {
      if (this._series[i].visible && !this._series[i].disabled) {
        let p2 = this._series[i].findClosestValue(DataPoint.x, false);
        if (p2 != null) {
          IRLmatch[i] = p2;
          bestmatch[i] = YGraph.IRLPointToViewPort(this.mainViewPort, IRLmatch[i], this.yAxes[this._series[i].yAxisIndex].IRLy, this.yAxes[this._series[i].yAxisIndex].zoom);
          if (bestindex < 0 || delta > Math.abs(bestmatch[i].Y - p.Y)) {
            delta = Math.abs(bestmatch[i].Y - p.Y);
            if (this._dataTracker.detectionDistance == 0 || delta <= this._dataTracker.detectionDistance && Math.abs(bestmatch[i].X - p.X) < this._dataTracker.detectionDistance) {
              bestindex = i;
            }
          }
        }
      }
    }
    if (bestindex >= 0) {
      let xx = bestmatch[bestindex].X - this._dataTracker.diameter / 2 >> 0;
      let yy = bestmatch[bestindex].Y - this._dataTracker.diameter / 2 >> 0;
      let dd = this._dataTracker.diameter;
      g.FillEllipse(this._series[bestindex].brush, xx, yy, dd, dd);
      g.DrawEllipse(this._dataTracker.pen, xx, yy, dd, dd);
      let dx;
      let dy;
      if (p.X > this.mainViewPort.Lmargin + (viewPortWidth - this.mainViewPort.Lmargin - this.mainViewPort.Rmargin) / 2)
        dx = -1;
      else
        dx = 1;
      if (p.Y > this.mainViewPort.Tmargin + (viewPortHeight - this.mainViewPort.Tmargin - this.mainViewPort.Bmargin) / 2)
        dy = -1;
      else
        dy = 1;
      let xx2 = bestmatch[bestindex].X + dx * (this._dataTracker.handleLength * 1.5) >> 0;
      let yy2 = bestmatch[bestindex].Y + dy * this._dataTracker.handleLength >> 0;
      g.DrawLineXY(this._dataTracker.pen, bestmatch[bestindex].X + dx * 0.707 * this._dataTracker.diameter / 2 >> 0, bestmatch[bestindex].Y + dy * 0.707 * this._dataTracker.diameter / 2 >> 0, bestmatch[bestindex].X + dx * this._dataTracker.handleLength >> 0, bestmatch[bestindex].Y + dy * this._dataTracker.handleLength >> 0);
      g.DrawLineXY(this._dataTracker.pen, bestmatch[bestindex].X + dx * this._dataTracker.handleLength >> 0, bestmatch[bestindex].Y + dy * this._dataTracker.handleLength >> 0, xx2, yy2);
      let strValue = "";
      if (this._dataTracker.showSerieName)
        strValue += this._series[bestindex].legend + "\r\n";
      if (this._dataTracker.showTimeStamp) {
        let t = IRLmatch[bestindex].x;
        strValue += this.TimeToAutoSting(t, this.mainViewPort, scaleX) + "\r\n";
      }
      if (this._dataTracker.dataPrecision.toString == DataTracker.DataPrecision.PRECISION_NOLIMIT.toString) {
        strValue += IRLmatch[bestindex].y.toString() + this._series[bestindex].unit;
      } else {
        let strvalue = this._dataTracker.dataPrecision.description;
        let precision = -Math.log10(Number(strvalue));
        strValue += IRLmatch[bestindex].y.toFixed(precision) + this._series[bestindex].unit;
      }
      let ssize = g.MeasureString(strValue, this._dataTracker.font, 1e4);
      let labelwidth = ssize.width + 2 * this._dataTracker.padding + this._dataTracker.borderthickness;
      let labelHeight = ssize.height + 2 * this._dataTracker.padding + this._dataTracker.borderthickness;
      if (dx > 0) {
        g.FillRectangleXYHW(this._dataTracker.bgBrush, xx2, yy2 - (labelHeight >> 1), labelwidth, labelHeight);
        g.DrawRectangleXYHW(this._dataTracker.pen, xx2, yy2 - (labelHeight >> 1), labelwidth, labelHeight);
        g.DrawStringXY(strValue, this._dataTracker.font, this._dataTracker.font.brush, xx2 + this._dataTracker.padding >> 0, yy2 - (labelHeight >> 1) + this._dataTracker.padding >> 0);
      } else {
        g.FillRectangleXYHW(this._dataTracker.bgBrush, xx2 - labelwidth, yy2 - (labelHeight >> 1), labelwidth, labelHeight);
        g.DrawRectangleXYHW(this._dataTracker.pen, xx2 - labelwidth, yy2 - (labelHeight >> 1), labelwidth, labelHeight);
        g.DrawStringXY(strValue, this._dataTracker.font, this.dataTracker.font.brush, xx2 + this._dataTracker.padding - labelwidth >> 0, yy2 - (labelHeight >> 1) + this._dataTracker.padding >> 0);
      }
    }
  }
  DrawMarkers(w, g, scaleX, viewPortWidth, viewPortHeight) {
    if (this._xAxis.markers.length == 0)
      return;
    g.SetClip(new YRectangle(w.Lmargin, w.Tmargin, w.Width - w.Rmargin - w.Lmargin, w.Height - w.Bmargin - w.Tmargin));
    let Bottomleft = YGraph.ViewPortPointToIRL(w, new Point(w.Lmargin, w.Height - w.Bmargin));
    let TopRight = YGraph.ViewPortPointToIRL(w, new Point(w.Width - w.Rmargin, w.Tmargin));
    let dy = (w.Height - w.Bmargin - w.Tmargin) / 100;
    let pixelSize = -1;
    g.TextRenderingHint = YTextRenderingHint.AntiAlias;
    for (let i = 0; i < this._xAxis.markers.length; i++) {
      if (this._xAxis.markers[i].enabled) {
        if (pixelSize < 0)
          pixelSize = this.pixelxSize(this.mainViewPort, scaleX);
        let mustdraw = true;
        let xpos = 0;
        if (this._xAxis.markers[i].timereference == TimeConverter.TimeReference.RELATIVE) {
          if (this._xAxis.zeroTime > 0) {
            xpos = this._xAxis.markers[i].xposition + this._xAxis.zeroTime;
          } else {
            mustdraw = false;
          }
        } else {
          xpos = this._xAxis.markers[i].xposition;
        }
        if (xpos > Bottomleft.x - 100 * pixelSize && xpos < TopRight.x + 100 * pixelSize && mustdraw) {
          let p = YGraph.IRLPointToViewPort(w, new pointXY(xpos, 0));
          let xxCenter = p.X >> 0;
          let yyCenter = w.Height - w.Bmargin - this._xAxis.markers[i].yposition * dy >> 0;
          let strValue = this._xAxis.markers[i].text.replace("\\n", "\n");
          let now = new Date();
          if (strValue.indexOf("$") >= 0) {
            if (strValue.indexOf("$MARKERTIME$") >= 0) {
              let s = this._xAxis.markers[i].timereference == TimeConverter.TimeReference.RELATIVE ? TimeConverter.secTimeSpanToString(this._xAxis.markers[i].xposition, pixelSize) : this.TimeToAutoSting(this._xAxis.markers[i].xposition, this.mainViewPort, scaleX);
              strValue = strValue.replace("$MARKERTIME$", s);
            }
            if (strValue.indexOf("$VALUE") >= 0) {
              for (let j = 0; j < this._series.length; j++) {
                if (!this._series[j].disabled) {
                  let pt = this._series[j].findClosestValue(xpos, true);
                  let st = pt != null ? pt.y.toFixed(0) : "--";
                  strValue = strValue.replace("$VALUE" + (j + 1).toString() + "$", st);
                } else {
                  strValue = strValue.replace("$VALUE" + (j + 1).toString() + "$", "");
                }
              }
            }
            if (strValue.indexOf("$UNIT") >= 0) {
              for (let j = 0; j < this._series.length; j++) {
                if (!this._series[j].disabled) {
                  strValue = strValue.replace("$UNIT" + (j + 1).toString() + "$", this._series[j].unit);
                } else {
                  strValue = strValue.replace("$UNIT" + (j + 1).toString() + "$", "");
                }
              }
            }
            if (strValue.indexOf("$LEGEND") >= 0) {
              for (let j = 0; j < this._series.length; j++) {
                if (!this._series[j].disabled) {
                  strValue = strValue.replace("$LEGEND" + (j + 1).toString() + "$", this._series[j].legend);
                } else {
                  strValue = strValue.replace("$LEGEND" + (j + 1).toString() + "$", "");
                }
              }
            }
            if (this._xAxis.markers[i].PatchTextCallback != null) {
              strValue = this._xAxis.markers[i].PatchTextCallback(strValue);
            }
          }
          let ssize = g.MeasureString(strValue, this._xAxis.markers[i].font, 1e4);
          let labelWidth = ssize.width + 2 * this._xAxis.markers[i].padding + this._xAxis.markers[i].borderthickness;
          let labelHeight = ssize.height + 2 * this._xAxis.markers[i].padding + this._xAxis.markers[i].borderthickness;
          g.FillRectangleXYHW(this._xAxis.markers[i].bgBrush, xxCenter - (labelWidth >> 1), yyCenter - (labelHeight >> 1), labelWidth >> 0, labelHeight >> 0);
          g.DrawRectangleXYHW(this._xAxis.markers[i].pen, xxCenter - (labelWidth >> 1), yyCenter - (labelHeight >> 1), labelWidth >> 0, labelHeight >> 0);
          let xText;
          switch (this._xAxis.markers[i].textAlign) {
            case Marker.TextAlign.LEFT:
              xText = xxCenter - (labelWidth >> 1) + this._xAxis.markers[i].padding;
              break;
            case Marker.TextAlign.RIGHT:
              xText = xxCenter + (labelWidth >> 1) - this._xAxis.markers[i].padding;
              break;
            default:
              xText = xxCenter;
              break;
          }
          g.DrawStringPF(strValue, this._xAxis.markers[i].font, this._xAxis.markers[i].font.brush, new PointF(xText, yyCenter), this._xAxis.markers[i].stringFormat);
          g.DrawLineXY(this._xAxis.markers[i].pen, xxCenter, w.Tmargin >> 0, xxCenter, yyCenter - (labelHeight >> 1));
          g.DrawLineXY(this._xAxis.markers[i].pen, xxCenter, yyCenter + (labelHeight >> 1), xxCenter, w.Height - w.Bmargin >> 0);
          if (this._xAxis.markers[i].arrowSize > 0) {
            if (this._xAxis.markers[i].yposition > 25) {
              let triangle = [
                new PointF(xxCenter - this._xAxis.markers[i].arrowSize, yyCenter + (labelHeight >> 1)),
                new PointF(xxCenter + this._xAxis.markers[i].arrowSize, yyCenter + (labelHeight >> 1)),
                new PointF(xxCenter, yyCenter + (labelHeight >> 1) + this._xAxis.markers[i].arrowSize)
              ];
              g.FillPolygon(this._xAxis.markers[i].arrowBrush, triangle);
            }
            if (this._xAxis.markers[i].yposition < 75) {
              let triangle = [
                new PointF(xxCenter - this._xAxis.markers[i].arrowSize, yyCenter + (labelHeight >> 1)),
                new PointF(xxCenter + this._xAxis.markers[i].arrowSize, yyCenter + (labelHeight >> 1)),
                new PointF(xxCenter, yyCenter - (labelHeight >> 1) - this._xAxis.markers[i].arrowSize)
              ];
              g.FillPolygon(this._xAxis.markers[i].arrowBrush, triangle);
            }
          }
        }
      }
    }
    g.ResetClip();
  }
  DrawDataPanels(w, g, scaleX, scalesY, viewPortWidth, viewPortHeight) {
    if (this._dataPanels.length == 0)
      return;
    g.SetClip(new YRectangle(w.Lmargin, w.Tmargin, w.Width - w.Rmargin - w.Lmargin, w.Height - w.Bmargin - w.Tmargin));
    for (let i = 0; i < this._dataPanels.length; i++) {
      if (this._dataPanels[i].enabled) {
        let p = this._dataPanels[i];
        if (p.yScaleIndex < scalesY.length) {
          let AvailableWidth = w.Width - 2 * p.padding - p.borderthickness;
          if (AvailableWidth < 100)
            AvailableWidth = 100;
          let ssize = g.MeasureString(p.text, p.font, AvailableWidth >> 0);
          let panelWidth = ssize.width + 2 * p.padding + p.borderthickness;
          let panelHeight = ssize.height + 2 * p.padding + p.borderthickness;
          let x = 0;
          switch (p.horizontalPosition) {
            case DataPanel.HorizontalPosition.LEFTBORDER:
              x = w.Lmargin;
              break;
            case DataPanel.HorizontalPosition.RIGHTBORDER:
              x = w.Width - w.Rmargin;
              break;
            case DataPanel.HorizontalPosition.ABSOLUTEX:
              let delta = scaleX.max - scaleX.min;
              let XZoom = delta / (w.Width - w.Lmargin - w.Rmargin);
              x = w.Lmargin + Math.round((p.AbsoluteXposition - scaleX.min) / XZoom) >> 0;
              break;
          }
          let y = 0;
          switch (p.verticalPosition) {
            case DataPanel.VerticalPosition.TOPBORDER:
              y = w.Tmargin;
              break;
            case DataPanel.VerticalPosition.BOTTOMBORDER:
              y = w.Height - w.Bmargin;
              break;
            case DataPanel.VerticalPosition.ABSOLUTEY:
              y = w.Height - w.Bmargin - Math.round((p.AbsoluteYposition - scalesY[p.yScaleIndex].IRLy) * scalesY[p.yScaleIndex].zoom) >> 0;
              break;
          }
          switch (p.panelHrzAlign) {
            case DataPanel.HorizontalAlign.LEFTOF:
              x -= panelWidth + p.horizontalMargin;
              break;
            case DataPanel.HorizontalAlign.RIGHTOF:
              x += p.horizontalMargin;
              break;
            default:
              x -= panelWidth / 2;
              break;
          }
          switch (p.panelVrtAlign) {
            case DataPanel.VerticalAlign.ABOVE:
              y -= panelHeight + p.verticalMargin;
              break;
            case DataPanel.VerticalAlign.BELOW:
              y += p.verticalMargin;
              break;
            default:
              y -= panelHeight / 2;
              break;
          }
          g.FillRectangleXYHW(p.bgBrush, x >> 0, y >> 0, panelWidth >> 0, panelHeight >> 0);
          if (p.borderthickness > 0)
            g.DrawRectangleXYHW(p.pen, x >> 0, y >> 0, panelWidth >> 0, panelHeight >> 0);
          let sf = new YStringFormat(16384);
          switch (p.panelTextAlign) {
            case MessagePanel.TextAlign.LEFT:
              sf.LineAlignment = 0;
              sf.Alignment = 0;
              break;
            case MessagePanel.TextAlign.RIGHT:
              sf.LineAlignment = 2;
              sf.Alignment = 2;
              break;
            default:
              sf.LineAlignment = 1;
              sf.Alignment = 1;
              break;
          }
          let rect = new YRectangle(x + p.padding + p.borderthickness / 2 >> 0, y + p.padding + p.borderthickness / 2 >> 0, ssize.width >>= 1, (ssize.height >> 0) + 1);
          g.DrawStringRect(p.text, p.font, p.font.brush, rect, sf);
        } else {
          throw new RangeError("Cannot renderer data panel #" + i.toString() + ", no such Y axis");
        }
      }
    }
  }
  findSegmentIndex(serieIndex, timeStamp, debug) {
    let s = this._series[serieIndex];
    if (s.segments.length <= 0)
      return -1;
    let start = 0;
    let end = s.segments.length - 1;
    if (debug) {
      console.log("looking for " + timeStamp);
      for (let i = 0; i < s.segments.length; i++)
        console.log("seg " + i + " [" + s.segments[i].data[0].x + ".." + s.segments[i].data[s.segments[i].count - 1].x + "]");
      debugger;
    }
    while (true) {
      let startSeg = s.segments[start];
      let endSeg = s.segments[end];
      if (timeStamp > startSeg.data[startSeg.count - 1].x)
        return start - 0.5;
      if (timeStamp < endSeg.data[0].x)
        return end + 0.5;
      if (timeStamp >= startSeg.data[0].x)
        return start;
      if (timeStamp <= endSeg.data[endSeg.count - 1].x)
        return end;
      if (end == start) {
        debugger;
        return -99;
      }
      if (end - start == 1)
        return start + 0.5;
      let middle = start + end >> 1;
      let middleSeg = s.segments[middle];
      if (timeStamp <= middleSeg.data[middleSeg.count - 1].x) {
        end = end - 1;
        start = middle;
      } else {
        end = middle - 1;
        start = start + 1;
      }
    }
  }
  findTimestampIndexInSegment(serieIndex, segmentIndex, timeStamp) {
    let seg = this._series[serieIndex].segments[segmentIndex];
    if (!seg)
      debugger;
    if (timeStamp <= seg.data[0].x)
      return 0;
    let count = this._series[serieIndex].segments[segmentIndex].count;
    if (timeStamp >= seg.data[count - 1].x)
      return count - 1;
    let start = 0;
    let end = count - 1;
    let middle = 0;
    while (true) {
      if (end - start <= 1) {
        if (timeStamp <= seg.data[start].x)
          return start;
        return end;
      }
      middle = start + end >> 1;
      if (timeStamp <= seg.data[middle].x)
        end = middle;
      else
        start = middle;
    }
  }
  Render(g, UIw, UIh) {
    if (UIw < 50 || UIh < 50)
      return 0;
    let lastLmargin = this.mainViewPort.Lmargin;
    let lastRmargin = this.mainViewPort.Rmargin;
    this.mainViewPort.Width = UIw;
    this.mainViewPort.Height = UIh;
    this.mainViewPort.Lmargin = 0;
    this.mainViewPort.Rmargin = 0;
    g.SmoothingMode = YSmoothingMode.HighQuality;
    let yMarginOffset = 5;
    for (let i = 0; i < this._yAxes.length; i++) {
      if (this._yAxes[i].visible) {
        let s = g.MeasureString("8", this._yAxes[i].font, 1e5);
        let o = (s.height + 1) / 2 >> 0;
        if (yMarginOffset < o)
          yMarginOffset = o;
      }
    }
    this.mainViewPort.Tmargin = this._xAxis.position == XAxis.VrtPosition.TOP ? 0 : yMarginOffset;
    this.mainViewPort.Bmargin = this._xAxis.position == XAxis.VrtPosition.BOTTOM ? 0 : yMarginOffset;
    if (!this._legendPanel.overlap)
      this.drawLegendPanel(g, UIw, UIh, this.mainViewPort);
    this.drawAnnotationPanels(g, this._annotationPanels, UIw, UIh, false, this.mainViewPort);
    if (this.mainViewPort.Bmargin == 0)
      this.mainViewPort.Bmargin = 5;
    if (this.mainViewPort.Tmargin == 0)
      this.mainViewPort.Tmargin = 5;
    let h = this.DrawXAxis(this.mainViewPort, g, this._xAxis, true);
    if (this._xAxis.position == XAxis.VrtPosition.TOP)
      this.mainViewPort.Tmargin += h;
    else
      this.mainViewPort.Bmargin += h;
    this.mainViewPort.IRLx = this._xAxis.min;
    let M;
    for (let i = 0; i < this._yAxes.length; i++) {
      M = MinMaxHandler.DefaultValue();
      for (let k = 0; k < this._series.length; k++) {
        if (this._series[k].yAxisIndex == i && !this._series[k].disabled) {
          for (let j = 0; j < this._series[k].segments.length; j++) {
            M = MinMaxHandler.Combine(M, YGraph.FindMinMax(this._xAxis.min, this._xAxis.max, this._series[k].segments[j].data, this._series[k].segments[j].count));
          }
        }
      }
      this._yAxes[i].computeStartAndStep(M);
    }
    if (this.mainViewPort.Lmargin == 0)
      this.mainViewPort.Lmargin = 5;
    if (this.mainViewPort.Rmargin == 0)
      this.mainViewPort.Rmargin = 5;
    for (let i = 0; i < this._yAxes.length; i++) {
      let sw = YGraph.DrawYAxis(this.mainViewPort, g, this._yAxes[i], 0, true);
      this.mainViewPort.Lmargin += this._yAxes[i].position == YAxis.HrzPosition.LEFT ? sw : 0;
      this.mainViewPort.Rmargin += this._yAxes[i].position == YAxis.HrzPosition.RIGHT ? sw : 0;
    }
    if (this._navigator.enabled) {
      if (lastLmargin != this.mainViewPort.Lmargin || lastRmargin != this.mainViewPort.Rmargin) {
        this.navigatorCache = null;
      }
      let nh = this._navigator.relativeheight * this.UIContainer.height / 100 >> 0;
      let ofset = this.xAxis.position == XAxis.VrtPosition.BOTTOM ? h : 0;
      this._navigator.setPosition(UIw, UIh, this.mainViewPort.Lmargin, this.mainViewPort.Rmargin, this.mainViewPort.Height - nh - this.mainViewPort.Bmargin + ofset, this.mainViewPort.Bmargin - ofset);
      this.mainViewPort.Bmargin += nh;
    }
    if (this.lastTopMargin != this.mainViewPort.Tmargin || this.lastBottomMargin != this.mainViewPort.Bmargin) {
      this._bgBrush = null;
      this.lastTopMargin = this.mainViewPort.Tmargin;
      this.lastBottomMargin = this.mainViewPort.Bmargin;
    }
    if (this._bgBrush == null) {
      this._bgBrush = new YLinearGradientBrush(this._bgColor2, this._bgColor1);
    }
    g.FillRectangleXYHW(this._bgBrush, this.mainViewPort.Lmargin, this.mainViewPort.Tmargin, this.mainViewPort.Width - this.mainViewPort.Rmargin - this.mainViewPort.Lmargin, this.mainViewPort.Height - this.mainViewPort.Bmargin - this.mainViewPort.Tmargin);
    if (this._borderThickness > 0) {
      if (this._borderPen == null)
        this._borderPen = new YPen(this._borderColor, this._borderThickness);
      g.DrawRectangleXYHW(this._borderPen, this.mainViewPort.Lmargin, this.mainViewPort.Tmargin, this.mainViewPort.Width - this.mainViewPort.Rmargin - this.mainViewPort.Lmargin, this.mainViewPort.Height - this.mainViewPort.Bmargin - this.mainViewPort.Tmargin);
    }
    g.SetClip(new YRectangle(this.mainViewPort.Lmargin, this.mainViewPort.Tmargin, this.mainViewPort.Width - this.mainViewPort.Rmargin - this.mainViewPort.Lmargin, this.mainViewPort.Height - this.mainViewPort.Bmargin - this.mainViewPort.Tmargin));
    for (let i = 0; i < this._yAxes.length; i++) {
      this.DrawYAxisZones(this.mainViewPort, g, this._yAxes[i]);
    }
    this.DrawXAxisZones(this.mainViewPort, g, this.xAxis);
    g.ResetClip();
    this.DrawXAxis(this.mainViewPort, g, this._xAxis, false);
    let leftOffset = 0;
    let rightOffset = 0;
    for (let i = 0; i < this._yAxes.length; i++) {
      let ww = YGraph.DrawYAxis(this.mainViewPort, g, this._yAxes[i], this._yAxes[i].position == YAxis.HrzPosition.LEFT ? leftOffset : rightOffset, false);
      if (this._yAxes[i].position == YAxis.HrzPosition.LEFT)
        leftOffset += ww;
      if (this._yAxes[i].position == YAxis.HrzPosition.RIGHT)
        rightOffset += ww;
    }
    g.SetClip(new YRectangle(this.mainViewPort.Lmargin, this.mainViewPort.Tmargin, this.mainViewPort.Width - this.mainViewPort.Rmargin - this.mainViewPort.Lmargin, this.mainViewPort.Height - this.mainViewPort.Bmargin - this.mainViewPort.Tmargin));
    this.mainViewPort.zoomx = (this.mainViewPort.Width - this.mainViewPort.Lmargin - this.mainViewPort.Rmargin) / (this._xAxis.max - this._xAxis.min);
    let mypenb = null;
    let lineCount = 0;
    let pointCount = 0;
    let Bottomleft = YGraph.ViewPortPointToIRL(this.mainViewPort, new Point(this.mainViewPort.Lmargin, this.mainViewPort.Height - this.mainViewPort.Bmargin));
    let TopRight = YGraph.ViewPortPointToIRL(this.mainViewPort, new Point(this.mainViewPort.Width - this.mainViewPort.Rmargin, this.mainViewPort.Tmargin));
    let xTimeStart = Bottomleft.x;
    let xTimeEnd = TopRight.x;
    let availabelPixelWidth = this.mainViewPort.Width - this.mainViewPort.Rmargin - this.mainViewPort.Lmargin;
    for (let k = 0; k < this._series.length; k++) {
      if (this._series[k].visible && !this._series[k].disabled && this._series[k].segments.length > 0) {
        let scaleIndex = this._series[k].yAxisIndex;
        mypenb = this._series[k].pen;
        this.mainViewPort.IRLy = this._yAxes[scaleIndex].startStopStep.dataMin;
        this._yAxes[this._series[k].yAxisIndex].IRLy = this.mainViewPort.IRLy;
        let delta = this._yAxes[scaleIndex].startStopStep.dataMax - this._yAxes[scaleIndex].startStopStep.dataMin;
        if (delta == 0) {
          delta = 1;
          this.mainViewPort.IRLy -= delta / 2;
        }
        this.mainViewPort.zoomy = (this.mainViewPort.Height - this.mainViewPort.Tmargin - this.mainViewPort.Bmargin) / delta;
        this._yAxes[this._series[k].yAxisIndex].zoom = this.mainViewPort.zoomy;
        g.comment("** main view-port series " + k.toString());
        let FirstSegmentIndexTmp = this.findSegmentIndex(k, xTimeEnd, false);
        let LastSegmentIndexTmp = this.findSegmentIndex(k, xTimeStart, false);
        let inside = true;
        let maxIndex = this._series[k].segments.length - 1;
        if (FirstSegmentIndexTmp < 0 && LastSegmentIndexTmp < 0) {
          inside = false;
        }
        if (FirstSegmentIndexTmp > maxIndex && LastSegmentIndexTmp > maxIndex) {
          inside = false;
        }
        if (inside) {
          let FirstSegmentIndex = Math.floor(FirstSegmentIndexTmp + 0.5);
          let LastSegmentIndex = Math.floor(LastSegmentIndexTmp);
          if (LastSegmentIndex < 0) {
            throw new Error("findSegmentIndex return an invalid index (" + LastSegmentIndex + ")");
          }
          if (FirstSegmentIndex < 0) {
            throw new Error("findSegmentIndex return an invalid index (" + FirstSegmentIndex + ")!");
          }
          if (FirstSegmentIndex > this._series[k].segments.length - 1) {
            throw new Error("findSegmentIndex return an invalid index (" + FirstSegmentIndex + ")!!");
          }
          if (LastSegmentIndex > this._series[k].segments.length - 1) {
            throw new Error("findSegmentIndex return an invalid index (" + LastSegmentIndex + ")!!!");
          }
          let firstDataIndex = this.findTimestampIndexInSegment(k, FirstSegmentIndex, xTimeEnd);
          let lastDataIndex = this.findTimestampIndexInSegment(k, LastSegmentIndex, xTimeStart);
          let totalPointsToDraw = 0;
          if (FirstSegmentIndex == LastSegmentIndex)
            totalPointsToDraw = firstDataIndex - lastDataIndex;
          else if (FirstSegmentIndex < LastSegmentIndex) {
            totalPointsToDraw = this._series[k].segments[LastSegmentIndex].count - lastDataIndex + firstDataIndex;
            for (let i = FirstSegmentIndex + 1; i < LastSegmentIndex; i++)
              totalPointsToDraw += this._series[k].segments[i].count;
          }
          let density = Math.round(totalPointsToDraw / availabelPixelWidth);
          if (density < SUMMARY_GRANULARITY || SUMMARY_GRANULARITY <= 0) {
            for (let i = 0; i < this._series[k].segments.length; i++) {
              lineCount += YGraph.DoSegmentRendering(this.mainViewPort, g, mypenb, this._series[k].segments[i].data, this._series[k].segments[i].count, xTimeStart, xTimeEnd);
              pointCount += this._series[k].segments[i].count;
            }
          } else {
            let level = Math.floor(Math.log(density) / Math.log(SUMMARY_GRANULARITY)) - 1;
            let s = this._series[k].summaries[level];
            let finalpoint = null;
            for (let i = 0; i < s.segments.length; i++) {
              if (i == s.segments.length - 1) {
                finalpoint = s.getBufferpoint();
              }
              lineCount += YGraph.DoSummarySegmentRendering(this.mainViewPort, g, mypenb, s.segments[i].data, s.segments[i].ptCount, finalpoint, xTimeStart, xTimeEnd);
              pointCount += s.segments[i].ptCount;
            }
          }
        } else
          console.log("Data are ouside dataview");
      }
    }
    g.ResetClip();
    if (this._navigator.enabled) {
      g.comment("** navigator **");
      let v = this._navigator.viewport;
      let range = MinMaxHandler.DefaultValue();
      for (let i = 0; i < this._series.length; i++) {
        if (!this._series[i].disabled)
          range = MinMaxHandler.Combine(range, this._series[i].timeRange);
      }
      this._navigator.Xrange = MinMaxHandler.extend(range, 1.05);
      v.zoomx = (v.Width - v.Lmargin - v.Rmargin) / (this._navigator.Xrange.Max - this._navigator.Xrange.Min);
      if (this.lastPointCount != pointCount && !this.mainViewPort.Capture && !this._navigator.Capture || this.navigatorCache == null || g instanceof YGraphicsSVG) {
        g.comment("Redraw navigator");
        if (this.navigatorCache != null)
          this.navigatorCache = null;
        this.navigatorCache = document.createElement("canvas");
        this.navigatorCache.width = v.Width;
        this.navigatorCache.height = v.Height;
        this.lastPointCount = pointCount;
        let ng;
        if (g instanceof YGraphicsSVG) {
          ng = g;
        } else {
          ng = new YGraphics(this.navigatorCache, v.Width, v.Height, 90);
        }
        ng.SetClip(new YRectangle(v.Lmargin, v.Tmargin, v.Width - v.Rmargin - v.Lmargin, v.Height - v.Bmargin - v.Tmargin));
        ng.FillRectangleXYHW(this._navigator.bgBrush, v.Lmargin, v.Tmargin, v.Width - v.Rmargin - v.Lmargin, v.Height - v.Bmargin - v.Tmargin);
        if (this.xAxis.zones.length > 0 && this._navigator.showXAxisZones) {
          let delta = this._navigator.Xrange.Max - this._navigator.Xrange.Min;
          let XZoom = delta / (v.Width - v.Lmargin - v.Rmargin);
          for (let i = 0; i < this.xAxis.zones.length; i++) {
            if (this.xAxis.zones[i].visible) {
              let min = this.xAxis.zones[i].min;
              let max = this.xAxis.zones[i].max;
              if (isNaN(min))
                min = this._navigator.Xrange.Min;
              if (isNaN(max))
                max = this._navigator.Xrange.Max;
              ng.FillRectangleXYHW(this.xAxis.zones[i].zoneBrush, v.Lmargin + (min - this._navigator.Xrange.Min) / XZoom >> 0, v.Tmargin >> 0, (max - min) / XZoom >> 0, v.Height - v.Bmargin - v.Tmargin);
            }
          }
        }
        if (MinMaxHandler.isDefined(this._navigator.Xrange) && this._navigator.Xrange.Max - this._navigator.Xrange.Min > 0) {
          let Min;
          let Max;
          v.IRLx = this._navigator.Xrange.Min;
          let dontSticktoBorderZoom = 4 / (v.Height - v.Bmargin - v.Tmargin);
          let Bottomleft2 = YGraph.ViewPortPointToIRL(v, new Point(v.Lmargin, v.Height - v.Bmargin));
          let TopRight2 = YGraph.ViewPortPointToIRL(v, new Point(v.Width - v.Rmargin, v.Tmargin));
          let xTimeStart2 = Bottomleft2.x;
          let xTimeEnd2 = TopRight2.x;
          if (this._navigator.yAxisHandling == Navigator.YAxisHandling.AUTO) {
            for (let k = 0; k < this._series.length; k++) {
              if (!this._series[k].disabled) {
                ng.comment("** navigator series " + k.toString());
                v.IRLy = this._series[k].valueRange.Min;
                let yAxisIndex = this._series[k].yAxisIndex;
                mypenb = this._series[k].navigatorpen;
                Min = this._series[k].valueRange.Min;
                Max = this._series[k].valueRange.Max;
                if (Max - Min <= 0) {
                  v.IRLy = Min - 0.5;
                  Max = Min + 0.5;
                } else {
                  let delta = Max - Min;
                  Min -= delta * dontSticktoBorderZoom;
                  Max += delta * dontSticktoBorderZoom;
                }
                v.IRLy = Min;
                v.zoomy = (v.Height - v.Tmargin - v.Bmargin) / (Max - Min);
                let availableWidth = v.Width - v.Lmargin - v.Rmargin;
                let totalPoint = 0;
                for (let i = 0; i < this._series[k].segments.length; i++)
                  totalPoint += this._series[k].segments[i].count;
                let density = Math.round(totalPoint / availableWidth);
                if (density < SUMMARY_GRANULARITY || SUMMARY_GRANULARITY <= 0) {
                  for (let i = 0; i < this._series[k].segments.length; i++) {
                    lineCount += YGraph.DoSegmentRendering(v, ng, mypenb, this._series[k].segments[i].data, this._series[k].segments[i].count, xTimeStart2, xTimeEnd2);
                  }
                } else {
                  let level = Math.floor(Math.log(density) / Math.log(SUMMARY_GRANULARITY)) - 1;
                  let s = this._series[k].summaries[level];
                  let finalpoint = null;
                  for (let i = 0; i < s.segments.length; i++) {
                    if (i == s.segments.length - 1)
                      finalpoint = s.getBufferpoint();
                    lineCount += YGraph.DoSummarySegmentRendering(v, ng, mypenb, s.segments[i].data, s.segments[i].ptCount, finalpoint, xTimeStart2, xTimeEnd2);
                  }
                }
              }
            }
          } else {
            for (let i = 0; i < this._yAxes.length; i++) {
              let Yrange = MinMaxHandler.DefaultValue();
              for (let j = 0; j < this._series.length; j++) {
                if (this._series[j].yAxisIndex == i && !this._series[j].disabled) {
                  Yrange = MinMaxHandler.Combine(Yrange, this._series[j].valueRange);
                }
              }
              Yrange = MinMaxHandler.extend(Yrange, 1 + 2 * dontSticktoBorderZoom);
              Min = this._yAxes[i].min;
              if (isNaN(Min))
                Min = Yrange.Min;
              Max = this._yAxes[i].max;
              if (isNaN(Max))
                Max = Yrange.Max;
              if (Number.isNaN(Min)) {
                Min = 0;
                Max = 1;
              }
              if (Max - Min <= 0) {
                Min = Min - 0.5;
                Max = Min + 0.5;
              }
              v.IRLy = Min;
              v.zoomy = (v.Height - v.Tmargin - v.Bmargin) / (Max - Min);
              for (let j = 0; j < this._series.length; j++) {
                if (this._series[j].yAxisIndex == i && !this._series[j].disabled && this._series[j].visible) {
                  ng.comment("** navigator series " + j.toString());
                  mypenb = this._series[j].navigatorpen;
                  let availableWidth = v.Width - v.Lmargin - v.Rmargin;
                  let totalPoint = 0;
                  for (let i2 = 0; i2 < this._series[j].segments.length; i2++)
                    totalPoint += this._series[j].segments[i2].count;
                  let density = Math.round(totalPoint / availableWidth);
                  if (density < SUMMARY_GRANULARITY || SUMMARY_GRANULARITY <= 0) {
                    for (let i2 = 0; i2 < this._series[j].segments.length; i2++) {
                      lineCount += YGraph.DoSegmentRendering(v, ng, mypenb, this._series[j].segments[i2].data, this._series[j].segments[i2].count, xTimeStart2, xTimeEnd2);
                    }
                  } else {
                    let level = Math.floor(Math.log(density) / Math.log(SUMMARY_GRANULARITY)) - 1;
                    console.log("Navigator (YAXIS=INHERIT), Serie " + j + ", density is ~" + density + "pts/pixel drawing summarized data level " + level);
                    let s = this._series[j].summaries[level];
                    let finalpoint = null;
                    for (let i2 = 0; i2 < s.segments.length; i2++) {
                      if (i2 == s.segments.length - 1)
                        finalpoint = s.getBufferpoint();
                      lineCount += YGraph.DoSummarySegmentRendering(v, ng, mypenb, s.segments[i2].data, s.segments[i2].ptCount, finalpoint, xTimeStart2, xTimeEnd2);
                    }
                  }
                }
              }
            }
          }
          for (let i = 0; i < this._xAxis.markers.length; i++) {
            if (this._xAxis.markers[i].enabled) {
              let p = YGraph.IRLPointToViewPort(v, new pointXY(this._xAxis.markers[i].xposition + (this._xAxis.markers[i].timereference == TimeConverter.TimeReference.RELATIVE ? this._xAxis.zeroTime : 0), 0));
              ng.DrawLineXY(this._xAxis.markers[i].navigatorpen, p.X, v.Tmargin, p.X, v.Height - v.Bmargin);
            }
          }
          if (this._navigator.borderThickness > 0) {
            ng.DrawLineXY(this._navigator.borderPen, v.Lmargin, v.Tmargin, v.Width - v.Rmargin, v.Tmargin);
          }
          this.DrawMonitorXAxis(v, ng, this._navigator.Xrange, this.xAxis.labelFormat);
          this._navigator.setIRLPosition(v.IRLx, v.IRLy, v.zoomx, v.zoomy);
        }
        ng.ResetClip();
        if (!(g instanceof YGraphicsSVG))
          ng.Dispose();
      }
      let cacheW = v.Width - v.Rmargin - v.Lmargin + 1;
      let cacheH = v.Width - v.Rmargin - v.Lmargin + 1;
      let rectsrc = new YRectangle(v.Lmargin, v.Tmargin - 1, cacheW, cacheH);
      let rectdst = new YRectangle(v.Lmargin, v.Tmargin, cacheW, cacheH);
      g.SetClip(rectdst);
      if (!(g instanceof YGraphicsSVG)) {
        g.DrawImage(this.navigatorCache, rectsrc, rectdst, 2);
      }
      if (this._navigator.borderThickness > 0) {
        g.DrawLineXY(this._navigator.borderPen, v.Lmargin + 1, v.Tmargin, v.Lmargin + 1, v.Height - v.Bmargin - 1);
        g.DrawLineXY(this._navigator.borderPen, v.Width - v.Rmargin, v.Tmargin, v.Width - v.Rmargin, v.Height - v.Bmargin - 1);
        g.DrawLineXY(this._navigator.borderPen, v.Lmargin + 1, v.Tmargin, v.Width - v.Rmargin, v.Tmargin);
      }
      let IRLCursorStart = YGraph.ViewPortPointToIRL(this.mainViewPort, new Point(this.mainViewPort.Lmargin, 0));
      let IRLCursorEnd = YGraph.ViewPortPointToIRL(this.mainViewPort, new Point(this.mainViewPort.Width - this.mainViewPort.Rmargin, 0));
      let CursorStart = YGraph.IRLPointToViewPort(this._navigator.viewport, new pointXY(IRLCursorStart.x, 0));
      let CursorEnd = YGraph.IRLPointToViewPort(this._navigator.viewport, new pointXY(IRLCursorEnd.x, 0));
      g.FillRectangle(this._navigator.cursorBrush, new YRectangle(CursorStart.X - 1, v.Tmargin, CursorEnd.X - CursorStart.X + 2, v.Height - v.Bmargin - v.Tmargin - 1));
      g.DrawLineXY(this._navigator.cursorBorderPen, CursorStart.X - 1 >> 0, v.Tmargin >> 0, CursorStart.X - 1 >> 0, v.Height - v.Bmargin - 1);
      g.DrawLineXY(this._navigator.cursorBorderPen, CursorEnd.X + 1 >> 0, v.Tmargin >> 0, CursorEnd.X + 1 >> 0, v.Height - v.Bmargin - 1);
      g.ResetClip();
    }
    if (this._legendPanel.overlap)
      this.drawLegendPanel(g, UIw, UIh, this.mainViewPort);
    g.TextRenderingHint = YTextRenderingHint.SingleBitPerPixelGridFit;
    this.DrawMarkers(this.mainViewPort, g, this.xAxis, UIw, UIh);
    this.drawAnnotationPanels(g, this._annotationPanels, UIw, UIh, true, this.mainViewPort);
    this.DrawDataPanels(this.mainViewPort, g, this.xAxis, this._yAxes, UIw, UIh);
    this.DrawDataTracker(g, UIw, UIh, this.xAxis);
    this.DrawMessagePanels(g, UIw, UIh);
    return 0;
  }
  KeyDown(sender, e) {
    if (e.code == "ArrowLeft") {
      let delta = 0.2 * (this._xAxis.max - this._xAxis.min);
      this._xAxis.set_minMax(this._xAxis.min - delta, this._xAxis.max - delta);
      this.redraw();
    }
    if (e.code == "ArrowRight") {
      let delta = 0.2 * (this._xAxis.max - this._xAxis.min);
      this._xAxis.set_minMax(this._xAxis.min + delta, this._xAxis.max + delta);
      this.redraw();
    }
    if (e.code == "ArrowUp") {
      this.mouseWheel(new Point(this.UIContainer.width >> 1, this.UIContainer.height >> 1), 10);
    }
    if (e.code == "ArrowDown") {
      this.mouseWheel(new Point(this.UIContainer.width >> 1, this.UIContainer.height >> 1), -10);
    }
  }
  mouseWheel(pos, delta) {
    let ZoomFactor = Math.pow(1.25, delta / 120);
    let NextZoomX = this.mainViewPort.zoomx * ZoomFactor;
    if (NextZoomX > this.mainViewPort.zoomx && NextZoomX > 1e3)
      return;
    let currentRange = this._xAxis.max - this._xAxis.min;
    if (currentRange / ZoomFactor > 25 * 365 * 86400)
      return;
    this.mainViewPort.IRLx += (pos.X - this.mainViewPort.Lmargin) / this.mainViewPort.zoomx - (pos.X - this.mainViewPort.Lmargin) / NextZoomX;
    let range = this._xAxis.max - this._xAxis.min;
    this._xAxis.set_minMax(this.mainViewPort.IRLx, this.mainViewPort.IRLx + range / ZoomFactor);
    this.mainViewPort.zoomx = NextZoomX;
    this.redraw();
  }
  mouseWheelEvent(sender, e) {
    let p = this.Scr2ElmMatrix.multiplyByV(Vector3.FromXYCoord(e.pageX, e.pageY)).toPoint();
    let eX = p.X;
    let eY = p.Y;
    this.mouseWheel(new Point(eX, eY), e.deltaY > 0 ? -150 : 150);
    e.preventDefault();
  }
};
YGraph._defaultVerticalDragZoomEnabled = false;
YGraph.captureCursor = null;

// obj/full/Renderer/YSolidGauge.js
var DrawPrameters = class {
  constructor() {
    this.outerRadius = 0;
    this.innerRadius = 0;
    this.angleStart = 0;
    this.angleEnd = 0;
    this.ycenter = 0;
    this.xcenter = 0;
    this.heightTop = 0;
    this.heightBottom = 0;
    this.valueRectangle = new YRectangle(0, 0, 0, 0);
    this.valueFormat = new YStringFormat(16384);
    this.minValueRectangle = new YRectangle(0, 0, 0, 0);
    this.minValueFormat = new YStringFormat(16384);
    this.maxValueRectangle = new YRectangle(0, 0, 0, 0);
    this.maxValueFormat = new YStringFormat(16384);
    this.minValue = "";
    this.maxValue = "";
    this.value = "";
  }
};
var YSolidGauge = class extends YDataRenderer {
  get min() {
    return this._min;
  }
  set min(value) {
    if (value >= this._max && !YDataRenderer.minMaxCheckDisabled) {
      throw new RangeError("Min cannot be greater than max (" + this._max.toString() + ")");
    }
    this._min = value;
    if (this._shownValue < this._min)
      this._shownValue = this._min;
    this.redraw();
  }
  get max() {
    return this._max;
  }
  set max(value) {
    if (value <= this._min && !YDataRenderer.minMaxCheckDisabled) {
      throw new RangeError("Max cannot be less than min (" + this._min.toString() + ")");
    }
    this._max = value;
    if (this._shownValue > this._max)
      this._shownValue = this._max;
    this.redraw();
  }
  get borderpen() {
    if (this._borderpen == null) {
      this._borderpen = new YPen(this._borderColor, this._borderThickness);
      this._borderpen.startCap = 1;
      this._borderpen.endCap = 1;
    }
    return this._borderpen;
  }
  get borderColor() {
    return this._borderColor;
  }
  set borderColor(value) {
    this._borderColor = value;
    this._borderpen = null;
    this.redraw();
  }
  get backgroundColor1() {
    return this._backgroundColor1;
  }
  set backgroundColor1(value) {
    this._backgroundColor1 = value;
    this._bgBrush = null;
    this.redraw();
  }
  get backgroundColor2() {
    return this._backgroundColor2;
  }
  set backgroundColor2(value) {
    this._backgroundColor2 = value;
    this._bgBrush = null;
    this.redraw();
  }
  get borderThickness() {
    return this._borderThickness;
  }
  set borderThickness(value) {
    if (value < 0)
      throw new RangeError("Thickness must be a positive value");
    this._borderThickness = value;
    this._borderpen = null;
    this._path = null;
    this.redraw();
  }
  get valueFormater() {
    return this._valueFormater;
  }
  set valueFormater(value) {
    this._valueFormater = value;
    this.redraw();
  }
  get minmaxFormater() {
    return this._minmaxFormater;
  }
  set minmaxFormater(value) {
    this._minmaxFormater = value;
    this.redraw();
  }
  get thickness() {
    return this._thickness;
  }
  set thickness(value) {
    if (value < 0)
      throw new RangeError("Thickness must be a positive value");
    this._thickness = Math.max(Math.min(value, 80), 1);
    this._path = null;
    this.redraw();
  }
  get maxSpeed() {
    return this._maxSpeed;
  }
  set maxSpeed(value) {
    if (value <= 0)
      throw new RangeError("Speed must be a positive value");
    this._maxSpeed = value;
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value;
    this.redraw();
  }
  get color1() {
    return this._color1;
  }
  set color1(value) {
    this._color1 = value;
    this.redraw();
  }
  get color2() {
    return this._color2;
  }
  set color2(value) {
    this._color2 = value;
    this.redraw();
  }
  get font() {
    return this._font;
  }
  get minMaxFont() {
    return this._minMaxFont;
  }
  get showMinMax() {
    return this._showMinMax;
  }
  set showMinMax(value) {
    this._showMinMax = value;
    this._path = null;
    this.redraw();
  }
  get displayMode() {
    return this._displayMode;
  }
  set displayMode(value) {
    this._displayMode = value;
    this._path = null;
    this._bgBrush = null;
    this.redraw();
  }
  FontsizeChange(source) {
    this._path = null;
  }
  constructor(UIContainer, mode, logFunction) {
    super(UIContainer, logFunction);
    this._shownValue = 0;
    this._min = 0;
    this._max = 100;
    this.SegmentMaxLength = 8;
    this.mainViewPort = new ViewPortSettings();
    this._borderpen = null;
    this._borderColor = YColor.Black;
    this._bgBrush = null;
    this._backgroundColor1 = YColor.FromArgb(255, 240, 240, 240);
    this._backgroundColor2 = YColor.FromArgb(255, 200, 200, 200);
    this._borderThickness = 5;
    this._valueFormater = null;
    this._minmaxFormater = null;
    this._thickness = 25;
    this._maxSpeed = 0.1;
    this._value = 0;
    this._color1 = YColor.Green;
    this._color2 = YColor.Red;
    this._font = null;
    this._minMaxFont = null;
    this._showMinMax = true;
    this._path = null;
    this.lastDrawParameters = new DrawPrameters();
    this._displayMode = YSolidGauge.DisplayMode.DISPLAY90;
    this._minMaxFont = new YFont(this, this, Math.min(UIContainer.width, UIContainer.height) / 15, () => {
      this.FontsizeChange(this._minMaxFont);
    });
    this._displayMode = mode;
    this._font = new YFont(this, this, Math.min(UIContainer.width, UIContainer.height) / 5, null);
    this.resizeRule = Proportional.ResizeRule.RELATIVETOBOTH;
    let g = new YGraphics(UIContainer, UIContainer.width, UIContainer.height, 90);
    let p = this.ComputeDrawParameters(g, UIContainer.width, UIContainer.height, this.mainViewPort);
    g.Dispose();
  }
  clearCachedObjects() {
    this._bgBrush = null;
    this._path = null;
  }
  ComputeDrawParameters(g, UIw, UIh, mainViewPort) {
    UIw -= mainViewPort.Lmargin + mainViewPort.Rmargin;
    UIh -= mainViewPort.Tmargin + mainViewPort.Bmargin;
    let w = UIw - 5 - this._borderThickness;
    let h = UIh - 5 - this._borderThickness;
    let xcenter = UIw / 2;
    let outerRadius = 0;
    let angleStart = 0;
    let angleEnd = 0;
    let ycenter = 0;
    let ValueRectangle = new YRectangle(0, 0, 0, 0);
    let valueFormat = new YStringFormat(16384);
    let innerRadius = 0;
    let minMaxHeight = 0;
    let s1 = new YSizeF(null, "");
    let s2 = new YSizeF(null, "");
    this.lastDrawParameters.value = this._valueFormater == null ? this._value.toFixed(0) : this._valueFormater(this, this._value);
    if (this._showMinMax) {
      this.lastDrawParameters.minValue = this._minmaxFormater == null ? this._min.toFixed(0) : this._minmaxFormater(this, this._min);
      this.lastDrawParameters.maxValue = this._minmaxFormater == null ? this._max.toFixed(0) : this._minmaxFormater(this, this._max);
      s1 = g.MeasureString(this.lastDrawParameters.minValue, this._minMaxFont, 1e5);
      s2 = g.MeasureString(this.lastDrawParameters.maxValue, this._minMaxFont, 1e5);
      this.lastDrawParameters.minValueFormat = new YStringFormat(16384);
      this.lastDrawParameters.maxValueFormat = new YStringFormat(16384);
      minMaxHeight = s1.height;
      if (s2.height > minMaxHeight)
        minMaxHeight = s2.height;
    }
    switch (this._displayMode) {
      case YSolidGauge.DisplayMode.DISPLAY90:
        h = h - minMaxHeight;
        w = w - minMaxHeight;
        outerRadius = w;
        if (outerRadius > h - this._borderThickness)
          outerRadius = h - this.borderThickness;
        if (outerRadius > w - this.borderThickness)
          outerRadius = w - this.borderThickness;
        angleStart = Math.PI / 2;
        angleEnd = Math.PI;
        this.lastDrawParameters.heightTop = outerRadius;
        this.lastDrawParameters.heightBottom = 0;
        ycenter = mainViewPort.Tmargin + h;
        xcenter = mainViewPort.Lmargin + UIw / 2 + outerRadius / 2 - minMaxHeight + this._borderThickness;
        innerRadius = outerRadius * (100 - this._thickness) / 100;
        ValueRectangle = new YRectangle(xcenter - innerRadius >> 0, ycenter - innerRadius >> 0, innerRadius >> 0, innerRadius >> 0);
        valueFormat.Alignment = 2;
        valueFormat.LineAlignment = 2;
        if (this._showMinMax) {
          this.lastDrawParameters.minValueRectangle = new YRectangle(xcenter - (outerRadius + innerRadius + s1.width) / 2 >> 0, ycenter + this._borderThickness >> 0, s1.width + 1 >> 0, minMaxHeight + 1 >> 0);
          this.lastDrawParameters.minValueFormat.Alignment = 0;
          this.lastDrawParameters.minValueFormat.LineAlignment = 0;
          this.lastDrawParameters.maxValueRectangle = new YRectangle(xcenter + this._borderThickness >> 0, ycenter - outerRadius + (outerRadius - innerRadius - s2.width) / 2 >> 0, minMaxHeight + 1 >> 0, s2.width + 1 >> 0);
          this.lastDrawParameters.maxValueFormat.Alignment = 0;
          this.lastDrawParameters.maxValueFormat.LineAlignment = 0;
          this.lastDrawParameters.maxValueFormat.FormatFlags = 2;
        }
        break;
      case YSolidGauge.DisplayMode.DISPLAY180:
        h = h - minMaxHeight;
        let s0 = new YSizeF(null, "");
        s0 = g.MeasureString(this.lastDrawParameters.value, this._font, 1e5);
        outerRadius = w / 2 - this.borderThickness;
        if (outerRadius > h - this._borderThickness)
          outerRadius = h - this._borderThickness;
        if (outerRadius > w - this.borderThickness)
          outerRadius = w - this.borderThickness;
        angleStart = 0;
        angleEnd = Math.PI;
        ycenter = outerRadius + this._borderThickness / 2;
        innerRadius = outerRadius * (100 - this._thickness) / 100;
        this.lastDrawParameters.heightTop = outerRadius;
        this.lastDrawParameters.heightBottom = 0;
        ValueRectangle = new YRectangle(xcenter - innerRadius >> 0, ycenter + this._borderThickness + minMaxHeight - s0.height >> 0, 2 * innerRadius >> 0, s0.height + 1 >> 0);
        valueFormat.Alignment = 1;
        valueFormat.LineAlignment = 2;
        if (this._showMinMax) {
          this.lastDrawParameters.minValueRectangle = new YRectangle(xcenter - (outerRadius + innerRadius + s1.width) / 2 >> 0, ycenter + this._borderThickness >> 0, s1.width + 1 >> 0, minMaxHeight + 1 >> 0);
          this.lastDrawParameters.minValueFormat.Alignment = 0;
          this.lastDrawParameters.minValueFormat.LineAlignment = 0;
          this.lastDrawParameters.maxValueRectangle = new YRectangle(xcenter + (outerRadius + innerRadius - s2.width) / 2 >> 0, ycenter + this._borderThickness >> 0, s2.width + 1 >> 0, minMaxHeight + 1 >> 0);
          this.lastDrawParameters.maxValueFormat.Alignment = 0;
          this.lastDrawParameters.maxValueFormat.LineAlignment = 0;
        }
        break;
      case YSolidGauge.DisplayMode.DISPLAY270:
        outerRadius = w;
        if (outerRadius > h / 2)
          outerRadius = h / 2;
        if (outerRadius > w / 2)
          outerRadius = w / 2;
        this.lastDrawParameters.heightTop = outerRadius;
        this.lastDrawParameters.heightBottom = outerRadius;
        angleStart = 0;
        angleEnd = 3 * Math.PI / 2;
        ycenter = mainViewPort.Tmargin + UIh / 2;
        innerRadius = outerRadius * (100 - this._thickness) / 100;
        ValueRectangle = new YRectangle(xcenter - innerRadius >> 0, ycenter - innerRadius >> 0, 2 * innerRadius >> 0, 2 * innerRadius >> 0);
        valueFormat.Alignment = 1;
        valueFormat.LineAlignment = 1;
        if (this._showMinMax) {
          this.lastDrawParameters.minValueRectangle = new YRectangle(xcenter + this._borderThickness >> 0, ycenter + (innerRadius + innerRadius + s1.height) / 2 >> 0, s1.width + 1 >> 0, s1.height + 1 >> 0);
          this.lastDrawParameters.minValueFormat.Alignment = 0;
          this.lastDrawParameters.minValueFormat.LineAlignment = 0;
          this.lastDrawParameters.maxValueRectangle = new YRectangle(xcenter + (innerRadius + innerRadius + s1.height) / 2 >> 0, ycenter + this._borderThickness >> 0, s2.height + 1 >> 0, s2.width + 1 >> 0);
          this.lastDrawParameters.maxValueFormat.Alignment = 0;
          this.lastDrawParameters.maxValueFormat.LineAlignment = 0;
          this.lastDrawParameters.maxValueFormat.FormatFlags = 2;
        }
        break;
      case YSolidGauge.DisplayMode.DISPLAY360:
        outerRadius = w;
        if (outerRadius > h / 0.85 / 2)
          outerRadius = h / 0.85 / 2;
        if (outerRadius > w / 2)
          outerRadius = w / 2;
        this.lastDrawParameters.heightTop = outerRadius;
        this.lastDrawParameters.heightBottom = outerRadius * 0.7;
        ycenter = mainViewPort.Tmargin + outerRadius + this._borderThickness / 2;
        angleStart = -Math.PI / 4;
        angleEnd = 5 * Math.PI / 4;
        innerRadius = outerRadius * (100 - this._thickness) / 100;
        ValueRectangle = new YRectangle(xcenter - innerRadius >> 0, ycenter - innerRadius >> 0, 2 * innerRadius >> 0, 2 * innerRadius >> 0);
        valueFormat.Alignment = 1;
        valueFormat.LineAlignment = 1;
        if (this._showMinMax) {
          let dx = Math.abs(innerRadius * Math.cos(angleStart));
          let dy = innerRadius * Math.abs(Math.sin(angleStart)) + 2 * Math.abs((outerRadius - innerRadius) * Math.sin(angleStart) / 3);
          this.lastDrawParameters.minValueRectangle = new YRectangle(xcenter - dx >> 0, ycenter + dy - minMaxHeight / 2 >> 0, s1.width + 1 >> 0, minMaxHeight + 1 >> 0);
          this.lastDrawParameters.minValueFormat.Alignment = 0;
          this.lastDrawParameters.minValueFormat.LineAlignment = 1;
          this.lastDrawParameters.maxValueRectangle = new YRectangle(xcenter + dx - s2.width >> 0, ycenter + dy - minMaxHeight / 2 >> 0, s2.width + 1 >> 0, minMaxHeight + 1 >> 0);
          this.lastDrawParameters.maxValueFormat.Alignment = 0;
          this.lastDrawParameters.maxValueFormat.LineAlignment = 1;
        }
        break;
    }
    this.lastDrawParameters.outerRadius = outerRadius;
    this.lastDrawParameters.innerRadius = innerRadius;
    this.lastDrawParameters.angleStart = angleStart;
    this.lastDrawParameters.angleEnd = angleEnd;
    this.lastDrawParameters.ycenter = ycenter;
    this.lastDrawParameters.xcenter = xcenter;
    this.lastDrawParameters.valueRectangle = ValueRectangle;
    this.lastDrawParameters.valueFormat = valueFormat;
    return this.lastDrawParameters;
  }
  Render(g, w, h) {
    this.mainViewPort = new ViewPortSettings();
    g.SmoothingMode = YSmoothingMode.HighQuality;
    g.TextRenderingHint = YTextRenderingHint.AntiAlias;
    this.drawAnnotationPanels(g, this._annotationPanels, w, h, false, this.mainViewPort);
    let p = this.ComputeDrawParameters(g, w, h, this.mainViewPort);
    if (this._path == null) {
      let outterlength = 2 * p.outerRadius * Math.PI * (p.angleEnd - p.angleStart) / (2 * Math.PI);
      let stepCount = outterlength / this.SegmentMaxLength >> 0;
      let stepsize = (p.angleEnd - p.angleStart) / stepCount;
      this._path = new Array(2 * (stepCount + 1));
      let n = 0;
      for (let i = 0; i <= stepCount; i++) {
        let a = p.angleStart + i * stepsize;
        this._path[n++] = new PointF(p.xcenter + p.outerRadius * Math.cos(a), p.ycenter - p.outerRadius * Math.sin(a));
      }
      for (let i = stepCount; i >= 0; i--) {
        let a = p.angleStart + i * stepsize;
        this._path[n++] = new PointF(p.xcenter + p.innerRadius * Math.cos(a), p.ycenter - p.innerRadius * Math.sin(a));
      }
    }
    if (this._bgBrush == null) {
      this._bgBrush = new YLinearGradientBrush(this._backgroundColor1, this._backgroundColor2);
    }
    if (this._borderpen == null) {
      this._borderpen = new YPen(this._borderColor, this._borderThickness);
      this._borderpen.linejoin = YPen.LineJoin.Round;
    }
    g.FillPolygon(this._bgBrush, this._path);
    if (this._shownValue != this._value) {
      let step = this._maxSpeed * (this._max - this._min) / 100;
      if (Math.abs(this._value - this._shownValue) < step) {
        this._shownValue = this._value;
      } else if (this._shownValue < this._value) {
        this._shownValue += step;
      } else {
        this._shownValue -= step;
      }
    }
    let v = this._shownValue;
    if (v >= this._min) {
      if (v > this._max)
        v = this._max;
      let valueFactor = (v - this._min) / (this._max - this.min);
      let angleValue = p.angleStart + (p.angleEnd - p.angleStart) * valueFactor;
      let outterlength = 2 * p.outerRadius * Math.PI * (angleValue - p.angleStart) / (2 * Math.PI);
      let stepCount = outterlength / this.SegmentMaxLength >> 0;
      let stepsize = (angleValue - p.angleStart) / stepCount;
      let pt = new Array(2 * (stepCount + 1));
      let n = 0;
      for (let i = 0; i <= stepCount; i++) {
        let a = p.angleEnd - i * stepsize;
        pt[n++] = new PointF(p.xcenter + p.outerRadius * Math.cos(a), p.ycenter - p.outerRadius * Math.sin(a));
      }
      for (let i = stepCount; i >= 0; i--) {
        let a = p.angleEnd - i * stepsize;
        pt[n++] = new PointF(p.xcenter + p.innerRadius * Math.cos(a), p.ycenter - p.innerRadius * Math.sin(a));
      }
      let b;
      if (this._color1 == this._color2) {
        b = new YSolidBrush(this._color1);
      } else {
        let A1 = this._color1.alpha;
        let H1 = this._color1.hue;
        let S1 = this._color1.saturation;
        let L1 = this._color1.luminosity;
        let A2 = this._color2.alpha;
        let H2 = this._color2.hue;
        let S2 = this._color2.saturation;
        let L2 = this._color2.luminosity;
        let A = Math.round(A1 + (A2 - A1) * valueFactor) >> 0 & 255;
        let H;
        if (Math.abs(H2 - H1) <= 127) {
          H = H1 + (H2 - H1) * valueFactor >> 0;
        } else {
          H = H1 + 256 + (H2 - H1 + 256) * valueFactor >> 0;
          if (H > 256)
            H -= 256;
        }
        let S = S1 + (S2 - S1) * valueFactor >> 0;
        let L = L1 + (L2 - L1) * valueFactor >> 0;
        b = new YSolidBrush(new YColor(true, A, H, S, L));
      }
      g.FillPolygon(b, pt);
    }
    if (this._borderThickness > 0)
      g.DrawPolygon(this._borderpen, this._path);
    g.DrawStringRect(this.lastDrawParameters.value, this._font, this._font.brush, p.valueRectangle, p.valueFormat);
    if (this._showMinMax) {
      g.DrawStringRect(this.lastDrawParameters.minValue, this._minMaxFont, this._minMaxFont.brush, this.lastDrawParameters.minValueRectangle, this.lastDrawParameters.minValueFormat);
      g.DrawStringRect(this.lastDrawParameters.maxValue, this._minMaxFont, this._minMaxFont.brush, this.lastDrawParameters.maxValueRectangle, this.lastDrawParameters.maxValueFormat);
    }
    this.drawAnnotationPanels(g, this._annotationPanels, w, h, true, this.mainViewPort);
    this.DrawMessagePanels(g, w, h);
    return 0;
  }
  renderingPostProcessing() {
    if (this._shownValue != this._value)
      this.redraw();
  }
};
(function(YSolidGauge2) {
  class DisplayModeEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, DisplayMode);
    }
  }
  YSolidGauge2.DisplayModeEnumItem = DisplayModeEnumItem;
  class DisplayMode extends YEnum {
  }
  DisplayMode.DISPLAY90 = new DisplayModeEnumItem("DISPLAY90", "90\xB0");
  DisplayMode.DISPLAY180 = new DisplayModeEnumItem("DISPLAY180", "180\xB0");
  DisplayMode.DISPLAY270 = new DisplayModeEnumItem("DISPLAY270", "270\xB0");
  DisplayMode.DISPLAY360 = new DisplayModeEnumItem("DISPLAY360", "360\xB0");
  YSolidGauge2.DisplayMode = DisplayMode;
})(YSolidGauge || (YSolidGauge = {}));

// obj/full/Api/yocto_api.js
var YAPI_SUCCESS = 0;
var YAPI_INVALID_ARGUMENT = -2;
var YAPI_NOT_SUPPORTED = -3;
var YAPI_DEVICE_NOT_FOUND = -4;
var YAPI_VERSION_MISMATCH = -5;
var YAPI_DEVICE_BUSY = -6;
var YAPI_TIMEOUT = -7;
var YAPI_IO_ERROR = -8;
var YAPI_UNAUTHORIZED = -12;
var YAPI_FILE_NOT_FOUND = -14;
var YAPI_INVALID_INT = 2147483647;
var YAPI_INVALID_UINT = -1;
var YAPI_INVALID_LONG = 9223372036854776e3;
var YAPI_INVALID_DOUBLE = -Number.MAX_VALUE;
var YAPI_INVALID_STRING = "!INVALID!";
var YAPI_MIN_DOUBLE = -Number.MAX_VALUE;
var YAPI_MAX_DOUBLE = Number.MAX_VALUE;
var Y_FUNCTIONDESCRIPTOR_INVALID = YAPI_INVALID_STRING;
var Y_DETECT_NONE = 0;
var Y_DETECT_USB = 1;
var Y_DETECT_NET = 2;
var Y_DETECT_ALL = Y_DETECT_USB | Y_DETECT_NET;
var DEFAULT_DEVICE_LIST_VALIDITY_MS = 1e4;
var DEFAULT_NETWORK_TIMEOUT_MS = 2e4;
var YOCTO_CALIB_TYPE_OFS = 30;
var NOTIFY_NETPKT_CONFCHGYDX = "s";
var NOTIFY_NETPKT_FLUSHV2YDX = "t";
var NOTIFY_NETPKT_FUNCV2YDX = "u";
var NOTIFY_NETPKT_TIMEV2YDX = "v";
var NOTIFY_NETPKT_DEVLOGYDX = "w";
var NOTIFY_NETPKT_TIMEVALYDX = "x";
var NOTIFY_NETPKT_FUNCVALYDX = "y";
var NOTIFY_NETPKT_TIMEAVGYDX = "z";
var NOTIFY_NETPKT_STOP = 10;
var NOTIFY_V2_6RAWBYTES = 1;
var NOTIFY_V2_TYPEDDATA = 2;
var PUBVAL_LEGACY = 0;
var PUBVAL_1RAWBYTE = 1;
var PUBVAL_2RAWBYTES = 2;
var PUBVAL_3RAWBYTES = 3;
var PUBVAL_4RAWBYTES = 4;
var PUBVAL_5RAWBYTES = 5;
var PUBVAL_6RAWBYTES = 6;
var PUBVAL_C_LONG = 7;
var PUBVAL_C_FLOAT = 8;
var PUBVAL_YOCTO_FLOAT_E3 = 9;
var YOCTO_PUBVAL_SIZE = 6;
var YOCTO_HASH_BUF_SIZE = 28;
var YOCTO_BASETYPE_FUNCTION = 0;
var YOCTO_BASETYPE_SENSOR = 1;
var Y_BASETYPES = {
  Function: YOCTO_BASETYPE_FUNCTION,
  Sensor: YOCTO_BASETYPE_SENSOR
};
var YErrorMsg = class {
  constructor(msg = "") {
    this.msg = msg;
  }
};
var YoctoError = class extends Error {
  constructor(...params) {
    super(...params);
    this.errorMsg = this.name;
    this.name = "YoctoError";
    if ("captureStackTrace" in Error) {
      Error.captureStackTrace(this, YoctoError);
    }
  }
};
var Y_MD5Ctx = class {
  constructor() {
    this.buf = new Uint32Array(4);
    this.bits = new Uint32Array(2);
    this.inBuf = new ArrayBuffer(64);
    this.in8 = new Uint8Array(this.inBuf);
    this.in32 = new Uint32Array(this.inBuf);
    this.in32[0] = 1;
    this.bigEndian = this.in8[0] != 1;
    this.buf[0] = 1732584193 >>> 0;
    this.buf[1] = 4023233417 >>> 0;
    this.buf[2] = 2562383102 >>> 0;
    this.buf[3] = 271733878 >>> 0;
    this.bits[0] = 0;
    this.bits[1] = 0;
  }
  _byteReverseIn() {
    for (let i = 0; i < 16; i++) {
      let a = this.in32[i];
      this.in32[i] = (a >>> 24 | (a & 255) << 24 | (a & 16711680) >>> 8 | (a & 65280) << 8) >>> 0;
    }
  }
  _transform() {
    let F1 = (x, y, z) => (z ^ x & (y ^ z)) >>> 0;
    let F2 = (x, y, z) => F1(z, x, y);
    let F3 = (x, y, z) => (x ^ y ^ z) >>> 0;
    let F4 = (x, y, z) => (y ^ (x | ~z)) >>> 0;
    let MD5STEP = (f, w, x, y, z, data, s) => {
      w = w + f(x, y, z) + (data >>> 0) >>> 0;
      w = (w << s >>> 0 | w >>> 32 - s) >>> 0;
      return w + x >>> 0;
    };
    let a = this.buf[0];
    let b = this.buf[1];
    let c = this.buf[2];
    let d = this.buf[3];
    let dataIn = this.in32;
    a = MD5STEP(F1, a, b, c, d, dataIn[0] + 3614090360, 7);
    d = MD5STEP(F1, d, a, b, c, dataIn[1] + 3905402710, 12);
    c = MD5STEP(F1, c, d, a, b, dataIn[2] + 606105819, 17);
    b = MD5STEP(F1, b, c, d, a, dataIn[3] + 3250441966, 22);
    a = MD5STEP(F1, a, b, c, d, dataIn[4] + 4118548399, 7);
    d = MD5STEP(F1, d, a, b, c, dataIn[5] + 1200080426, 12);
    c = MD5STEP(F1, c, d, a, b, dataIn[6] + 2821735955, 17);
    b = MD5STEP(F1, b, c, d, a, dataIn[7] + 4249261313, 22);
    a = MD5STEP(F1, a, b, c, d, dataIn[8] + 1770035416, 7);
    d = MD5STEP(F1, d, a, b, c, dataIn[9] + 2336552879, 12);
    c = MD5STEP(F1, c, d, a, b, dataIn[10] + 4294925233, 17);
    b = MD5STEP(F1, b, c, d, a, dataIn[11] + 2304563134, 22);
    a = MD5STEP(F1, a, b, c, d, dataIn[12] + 1804603682, 7);
    d = MD5STEP(F1, d, a, b, c, dataIn[13] + 4254626195, 12);
    c = MD5STEP(F1, c, d, a, b, dataIn[14] + 2792965006, 17);
    b = MD5STEP(F1, b, c, d, a, dataIn[15] + 1236535329, 22);
    a = MD5STEP(F2, a, b, c, d, dataIn[1] + 4129170786, 5);
    d = MD5STEP(F2, d, a, b, c, dataIn[6] + 3225465664, 9);
    c = MD5STEP(F2, c, d, a, b, dataIn[11] + 643717713, 14);
    b = MD5STEP(F2, b, c, d, a, dataIn[0] + 3921069994, 20);
    a = MD5STEP(F2, a, b, c, d, dataIn[5] + 3593408605, 5);
    d = MD5STEP(F2, d, a, b, c, dataIn[10] + 38016083, 9);
    c = MD5STEP(F2, c, d, a, b, dataIn[15] + 3634488961, 14);
    b = MD5STEP(F2, b, c, d, a, dataIn[4] + 3889429448, 20);
    a = MD5STEP(F2, a, b, c, d, dataIn[9] + 568446438, 5);
    d = MD5STEP(F2, d, a, b, c, dataIn[14] + 3275163606, 9);
    c = MD5STEP(F2, c, d, a, b, dataIn[3] + 4107603335, 14);
    b = MD5STEP(F2, b, c, d, a, dataIn[8] + 1163531501, 20);
    a = MD5STEP(F2, a, b, c, d, dataIn[13] + 2850285829, 5);
    d = MD5STEP(F2, d, a, b, c, dataIn[2] + 4243563512, 9);
    c = MD5STEP(F2, c, d, a, b, dataIn[7] + 1735328473, 14);
    b = MD5STEP(F2, b, c, d, a, dataIn[12] + 2368359562, 20);
    a = MD5STEP(F3, a, b, c, d, dataIn[5] + 4294588738, 4);
    d = MD5STEP(F3, d, a, b, c, dataIn[8] + 2272392833, 11);
    c = MD5STEP(F3, c, d, a, b, dataIn[11] + 1839030562, 16);
    b = MD5STEP(F3, b, c, d, a, dataIn[14] + 4259657740, 23);
    a = MD5STEP(F3, a, b, c, d, dataIn[1] + 2763975236, 4);
    d = MD5STEP(F3, d, a, b, c, dataIn[4] + 1272893353, 11);
    c = MD5STEP(F3, c, d, a, b, dataIn[7] + 4139469664, 16);
    b = MD5STEP(F3, b, c, d, a, dataIn[10] + 3200236656, 23);
    a = MD5STEP(F3, a, b, c, d, dataIn[13] + 681279174, 4);
    d = MD5STEP(F3, d, a, b, c, dataIn[0] + 3936430074, 11);
    c = MD5STEP(F3, c, d, a, b, dataIn[3] + 3572445317, 16);
    b = MD5STEP(F3, b, c, d, a, dataIn[6] + 76029189, 23);
    a = MD5STEP(F3, a, b, c, d, dataIn[9] + 3654602809, 4);
    d = MD5STEP(F3, d, a, b, c, dataIn[12] + 3873151461, 11);
    c = MD5STEP(F3, c, d, a, b, dataIn[15] + 530742520, 16);
    b = MD5STEP(F3, b, c, d, a, dataIn[2] + 3299628645, 23);
    a = MD5STEP(F4, a, b, c, d, dataIn[0] + 4096336452, 6);
    d = MD5STEP(F4, d, a, b, c, dataIn[7] + 1126891415, 10);
    c = MD5STEP(F4, c, d, a, b, dataIn[14] + 2878612391, 15);
    b = MD5STEP(F4, b, c, d, a, dataIn[5] + 4237533241, 21);
    a = MD5STEP(F4, a, b, c, d, dataIn[12] + 1700485571, 6);
    d = MD5STEP(F4, d, a, b, c, dataIn[3] + 2399980690, 10);
    c = MD5STEP(F4, c, d, a, b, dataIn[10] + 4293915773, 15);
    b = MD5STEP(F4, b, c, d, a, dataIn[1] + 2240044497, 21);
    a = MD5STEP(F4, a, b, c, d, dataIn[8] + 1873313359, 6);
    d = MD5STEP(F4, d, a, b, c, dataIn[15] + 4264355552, 10);
    c = MD5STEP(F4, c, d, a, b, dataIn[6] + 2734768916, 15);
    b = MD5STEP(F4, b, c, d, a, dataIn[13] + 1309151649, 21);
    a = MD5STEP(F4, a, b, c, d, dataIn[4] + 4149444226, 6);
    d = MD5STEP(F4, d, a, b, c, dataIn[11] + 3174756917, 10);
    c = MD5STEP(F4, c, d, a, b, dataIn[2] + 718787259, 15);
    b = MD5STEP(F4, b, c, d, a, dataIn[9] + 3951481745, 21);
    this.buf[0] = (this.buf[0] + a & 4294967295) >>> 0;
    this.buf[1] = (this.buf[1] + b & 4294967295) >>> 0;
    this.buf[2] = (this.buf[2] + c & 4294967295) >>> 0;
    this.buf[3] = (this.buf[3] + d & 4294967295) >>> 0;
  }
  addData(buf) {
    let len = buf.length;
    let pos = 0;
    let t = this.bits[0];
    this.bits[0] = t + (len << 3) >>> 0;
    if (this.bits[0] < t) {
      this.bits[1]++;
    }
    this.bits[1] += len >>> 29;
    t = t >>> 3 & 63;
    while (pos < len) {
      while (pos < len && t < 64) {
        this.in8[t++] = buf[pos++];
      }
      if (t < 64)
        return;
      if (this.bigEndian)
        this._byteReverseIn();
      this._transform();
      t = 0;
    }
  }
  calculate() {
    let t = this.bits[0] >>> 3 & 63;
    this.in8[t++] = 128;
    if (t > 56) {
      while (t < 64) {
        this.in8[t++] = 0;
      }
      if (this.bigEndian)
        this._byteReverseIn();
      this._transform();
      for (t = 0; t < 14; t++) {
        this.in32[t] = 0;
      }
    } else {
      while (t < 56) {
        this.in8[t++] = 0;
      }
      if (this.bigEndian)
        this._byteReverseIn();
    }
    this.in32[14] = this.bits[0];
    this.in32[15] = this.bits[1];
    this._transform();
    let res = new Uint8Array(16);
    for (t = 0; t < 16; t++) {
      res[t] = this.buf[t >>> 2] >>> 8 * (t & 3) & 255;
    }
    return res;
  }
};
var YFunctionType = class {
  constructor(yapi, classname) {
    this._yapi = yapi;
    this._className = classname;
    this._connectedFns = {};
    this._requestedFns = {};
    this._hwIdByName = {};
    this._nameByHwId = {};
    this._valueByHwId = {};
    this._baseType = 0;
  }
  imm_reindexFunction(str_hwid, str_name, str_val, int_basetype) {
    let currname = this._nameByHwId[str_hwid];
    let res = false;
    if (currname == void 0 || currname == "") {
      if (str_name != "") {
        this._nameByHwId[str_hwid] = str_name;
        res = true;
      }
    } else if (currname != str_name) {
      if (this._hwIdByName[currname] == str_hwid) {
        delete this._hwIdByName[currname];
      }
      if (str_name != "") {
        this._nameByHwId[str_hwid] = str_name;
      } else {
        delete this._nameByHwId[str_hwid];
      }
      res = true;
    }
    if (str_name != "") {
      this._hwIdByName[str_name] = str_hwid;
    }
    if (str_val) {
      this._valueByHwId[str_hwid] = str_val;
    } else {
      if (this._valueByHwId[str_hwid] == void 0) {
        this._valueByHwId[str_hwid] = "";
      }
    }
    if (int_basetype) {
      if (this._baseType == 0) {
        this._baseType = int_basetype;
      }
    }
    return res;
  }
  imm_forgetFunction(str_hwid) {
    let currname = this._nameByHwId[str_hwid];
    if (currname != void 0) {
      if (currname != "" && this._hwIdByName[currname] == str_hwid) {
        delete this._hwIdByName[currname];
      }
      delete this._nameByHwId[str_hwid];
    }
    if (this._valueByHwId[str_hwid] != void 0) {
      delete this._valueByHwId[str_hwid];
    }
    let con_fn = this._connectedFns[str_hwid];
    if (con_fn) {
      this._requestedFns[str_hwid] = con_fn;
      delete this._connectedFns[str_hwid];
    }
  }
  imm_resolve(str_func) {
    let res;
    let dotpos = str_func.indexOf(".");
    if (dotpos < 0) {
      res = this._hwIdByName[str_func];
      if (res != void 0) {
        return {
          errorType: YAPI_SUCCESS,
          errorMsg: "no error",
          result: String(res)
        };
      }
      dotpos = str_func.length;
      str_func += "." + this._className.substr(0, 1).toLowerCase() + this._className.substr(1);
    }
    if (this._valueByHwId[str_func] != void 0) {
      return {
        errorType: YAPI_SUCCESS,
        errorMsg: "no error",
        result: String(str_func)
      };
    }
    let serial = "";
    let funcid;
    if (dotpos > 0) {
      let devid = str_func.substr(0, dotpos);
      funcid = str_func.substr(dotpos + 1);
      let dev = this._yapi.imm_getDevice(devid);
      if (!dev) {
        return {
          errorType: YAPI_DEVICE_NOT_FOUND,
          errorMsg: "Device [" + devid + "] not online",
          result: ""
        };
      }
      serial = dev.imm_getSerialNumber();
      res = serial + "." + funcid;
      if (this._valueByHwId[res] != void 0) {
        return {
          errorType: YAPI_SUCCESS,
          errorMsg: "no error",
          result: String(res)
        };
      }
      let i, nfun = dev.imm_functionCount();
      for (i = 0; i < nfun; i++) {
        res = serial + "." + dev.imm_functionId(i);
        let name = this._nameByHwId[res];
        if (name != void 0 && name == funcid) {
          return {
            errorType: YAPI_SUCCESS,
            errorMsg: "no error",
            result: String(res)
          };
        }
      }
    } else {
      funcid = str_func.substr(1);
      for (let hwid_str in this._connectedFns) {
        let pos = hwid_str.indexOf(".");
        let str_function = hwid_str.substr(pos + 1);
        if (str_function == funcid) {
          return {
            errorType: YAPI_SUCCESS,
            errorMsg: "no error",
            result: String(hwid_str)
          };
        }
      }
    }
    return {
      errorType: YAPI_DEVICE_NOT_FOUND,
      errorMsg: "No function [" + funcid + "] found on device [" + serial + "]",
      result: ""
    };
  }
  imm_getFriendlyName(str_func) {
    let resolved = this.imm_resolve(str_func);
    let name;
    if (resolved.errorType != YAPI_SUCCESS) {
      return resolved;
    }
    let hwId = resolved.result;
    if (this._className == "Module") {
      let friend = hwId;
      name = this._nameByHwId[friend];
      if (name != void 0 && name != "") {
        friend = this._nameByHwId[friend];
      }
      return {
        errorType: YAPI_SUCCESS,
        errorMsg: "no error",
        result: String(friend)
      };
    } else {
      let pos = hwId.indexOf(".");
      let str_serialMod = hwId.substr(0, pos);
      let str_friendModFull = this._yapi.imm_getFriendlyNameFunction("Module", str_serialMod).result;
      let int_friendModDot = str_friendModFull.indexOf(".");
      let str_friendMod = int_friendModDot > 0 ? str_friendModFull.substr(0, int_friendModDot) : str_friendModFull;
      let str_friendFunc = hwId.substr(pos + 1);
      name = this._nameByHwId[hwId];
      if (name != void 0 && name != "") {
        str_friendFunc = name;
      }
      return {
        errorType: YAPI_SUCCESS,
        errorMsg: "no error",
        result: String(str_friendMod + "." + str_friendFunc)
      };
    }
  }
  imm_setFunction(str_func, obj_func) {
    let funres = this.imm_resolve(str_func);
    if (funres.result) {
      this._connectedFns[funres.result] = obj_func;
    } else {
      this._requestedFns[str_func] = obj_func;
    }
  }
  imm_getFunction(str_func) {
    let funres = this.imm_resolve(str_func);
    if (funres.errorType == YAPI_SUCCESS) {
      let conn_fn = this._connectedFns[funres.result];
      if (conn_fn != void 0) {
        return conn_fn;
      }
      let req_fn = this._requestedFns[str_func];
      if (req_fn != void 0) {
        this._connectedFns[funres.result] = req_fn;
        delete this._requestedFns[str_func];
      }
      return req_fn;
    } else {
      return this._requestedFns[str_func];
    }
  }
  imm_setFunctionValue(str_hwid, str_pubval) {
    let currval = this._valueByHwId[str_hwid];
    if (!(currval == void 0) && currval == str_pubval) {
      return false;
    }
    this._valueByHwId[str_hwid] = str_pubval;
    return true;
  }
  imm_getFunctionValue(str_hwid) {
    return this._valueByHwId[str_hwid];
  }
  imm_getBaseType() {
    return this._baseType;
  }
  imm_matchBaseType(baseclass) {
    return baseclass == YOCTO_BASETYPE_FUNCTION || baseclass == this._baseType;
  }
  imm_getFirstHardwareId() {
    let res = null;
    for (res in this._valueByHwId) {
      break;
    }
    return res;
  }
  imm_getNextHardwareId(str_hwid) {
    for (let iter_hwid in this._valueByHwId) {
      if (str_hwid == "!") {
        return iter_hwid;
      }
      if (str_hwid == iter_hwid) {
        str_hwid = "!";
      }
    }
    return null;
  }
};
var YHTTPBody = class {
  constructor(str_fname, bin_data, fun_progressCb) {
    this.fname = str_fname;
    this.data = bin_data;
    this.progressCb = fun_progressCb;
  }
};
var YHTTPRequest = class {
  constructor(bin_res, int_errType = YAPI_SUCCESS, str_errMsg = "no error") {
    this.devUrl = null;
    this.obj_result = null;
    this.asyncId = 0;
    this.acceptor = null;
    this.toBeSent = null;
    this.sendPos = 0;
    this.progressCb = null;
    this.timeoutId = null;
    this.sendTimeoutId = null;
    this.next = null;
    this._creat = "";
    this._sent = "";
    this.bin_result = bin_res;
    this.errorType = int_errType;
    this.errorMsg = str_errMsg;
  }
};
var YFuncRequest = class {
  constructor(obj_res, int_errType = YAPI_SUCCESS, str_errMsg = "no error") {
    this.errorType = int_errType;
    this.errorMsg = str_errMsg;
    this.obj_result = obj_res;
  }
};
var YDataStream = class {
  constructor(obj_parent, obj_dataset, encoded) {
    this._runNo = 0;
    this._utcStamp = 0;
    this._nCols = 0;
    this._nRows = 0;
    this._startTime = 0;
    this._duration = 0;
    this._dataSamplesInterval = 0;
    this._firstMeasureDuration = 0;
    this._columnNames = [];
    this._functionId = "";
    this._isClosed = false;
    this._isAvg = false;
    this._minVal = 0;
    this._avgVal = 0;
    this._maxVal = 0;
    this._caltyp = 0;
    this._calpar = [];
    this._calraw = [];
    this._calref = [];
    this._values = [];
    this._isLoaded = false;
    this.DATA_INVALID = YAPI_INVALID_DOUBLE;
    this.DURATION_INVALID = YAPI_INVALID_DOUBLE;
    this._parent = obj_parent;
    this._yapi = this._parent._yapi;
    this.imm_calhdl = null;
    if (typeof obj_dataset != "undefined") {
      this.imm_initFromDataSet(obj_dataset, encoded);
    }
  }
  imm_initFromDataSet(dataset, encoded) {
    let val;
    let i;
    let maxpos;
    let ms_offset;
    let samplesPerHour;
    let fRaw;
    let fRef;
    let iCalib = [];
    this._runNo = encoded[0] + (encoded[1] << 16);
    this._utcStamp = encoded[2] + (encoded[3] << 16);
    val = encoded[4];
    this._isAvg = (val & 256) == 0;
    samplesPerHour = val & 255;
    if ((val & 256) != 0) {
      samplesPerHour = samplesPerHour * 3600;
    } else {
      if ((val & 512) != 0) {
        samplesPerHour = samplesPerHour * 60;
      }
    }
    this._dataSamplesInterval = 3600 / samplesPerHour;
    ms_offset = encoded[6];
    if (ms_offset < 1e3) {
      this._startTime = this._utcStamp + ms_offset / 1e3;
    } else {
      this._startTime = this._utcStamp - this._dataSamplesInterval;
    }
    this._firstMeasureDuration = encoded[5];
    if (!this._isAvg) {
      this._firstMeasureDuration = this._firstMeasureDuration / 1e3;
    }
    val = encoded[7];
    this._isClosed = val != 65535;
    if (val == 65535) {
      val = 0;
    }
    this._nRows = val;
    if (this._nRows > 0) {
      if (this._firstMeasureDuration > 0) {
        this._duration = this._firstMeasureDuration + (this._nRows - 1) * this._dataSamplesInterval;
      } else {
        this._duration = this._nRows * this._dataSamplesInterval;
      }
    } else {
      this._duration = 0;
    }
    iCalib = dataset.imm_get_calibration();
    this._caltyp = iCalib[0];
    if (this._caltyp != 0) {
      this.imm_calhdl = this._yapi.imm_getCalibrationHandler(this._caltyp);
      maxpos = iCalib.length;
      this._calpar.length = 0;
      this._calraw.length = 0;
      this._calref.length = 0;
      i = 1;
      while (i < maxpos) {
        this._calpar.push(iCalib[i]);
        i = i + 1;
      }
      i = 1;
      while (i + 1 < maxpos) {
        fRaw = iCalib[i];
        fRaw = fRaw / 1e3;
        fRef = iCalib[i + 1];
        fRef = fRef / 1e3;
        this._calraw.push(fRaw);
        this._calref.push(fRef);
        i = i + 2;
      }
    }
    this._functionId = dataset.imm_get_functionId();
    if (this._isAvg) {
      this._columnNames.length = 0;
      this._columnNames.push(this._functionId + "_min");
      this._columnNames.push(this._functionId + "_avg");
      this._columnNames.push(this._functionId + "_max");
      this._nCols = 3;
    } else {
      this._columnNames.length = 0;
      this._columnNames.push(this._functionId);
      this._nCols = 1;
    }
    if (this._nRows > 0) {
      this._avgVal = this.imm_decodeAvg(encoded[8] + ((encoded[9] ^ 32768) << 16), 1);
      this._minVal = this.imm_decodeVal(encoded[10] + (encoded[11] << 16));
      this._maxVal = this.imm_decodeVal(encoded[12] + (encoded[13] << 16));
    }
    return 0;
  }
  imm_parseStream(sdata) {
    let idx;
    let udat = [];
    let dat = [];
    if (this._isLoaded && !this._isClosed) {
      return YAPI_SUCCESS;
    }
    if (sdata.length == 0) {
      this._nRows = 0;
      return YAPI_SUCCESS;
    }
    udat = this._yapi.imm_decodeWords(this._parent.imm_json_get_string(sdata));
    this._values.length = 0;
    idx = 0;
    if (this._isAvg) {
      while (idx + 3 < udat.length) {
        dat.length = 0;
        if (udat[idx] == 65535 && udat[idx + 1] == 65535) {
          dat.push(NaN);
          dat.push(NaN);
          dat.push(NaN);
        } else {
          dat.push(this.imm_decodeVal(udat[idx + 2] + (udat[idx + 3] << 16)));
          dat.push(this.imm_decodeAvg(udat[idx] + ((udat[idx + 1] ^ 32768) << 16), 1));
          dat.push(this.imm_decodeVal(udat[idx + 4] + (udat[idx + 5] << 16)));
        }
        idx = idx + 6;
        this._values.push(dat.slice());
      }
    } else {
      while (idx + 1 < udat.length) {
        dat.length = 0;
        if (udat[idx] == 65535 && udat[idx + 1] == 65535) {
          dat.push(NaN);
        } else {
          dat.push(this.imm_decodeAvg(udat[idx] + ((udat[idx + 1] ^ 32768) << 16), 1));
        }
        this._values.push(dat.slice());
        idx = idx + 2;
      }
    }
    this._nRows = this._values.length;
    this._isLoaded = true;
    return YAPI_SUCCESS;
  }
  imm_wasLoaded() {
    return this._isLoaded;
  }
  imm_get_url() {
    let url;
    url = "logger.json?id=" + this._functionId + "&run=" + String(Math.round(this._runNo)) + "&utc=" + String(Math.round(this._utcStamp));
    return url;
  }
  imm_get_baseurl() {
    let url;
    url = "logger.json?id=" + this._functionId + "&run=" + String(Math.round(this._runNo)) + "&utc=";
    return url;
  }
  imm_get_urlsuffix() {
    let url;
    url = String(Math.round(this._utcStamp));
    return url;
  }
  async loadStream() {
    return this.imm_parseStream(await this._parent._download(this.imm_get_url()));
  }
  imm_decodeVal(w) {
    let val;
    val = w;
    val = val / 1e3;
    if (this._caltyp != 0) {
      if (this.imm_calhdl != null) {
        val = this.imm_calhdl(val, this._caltyp, this._calpar, this._calraw, this._calref);
      }
    }
    return val;
  }
  imm_decodeAvg(dw, count) {
    let val;
    val = dw;
    val = val / 1e3;
    if (this._caltyp != 0) {
      if (this.imm_calhdl != null) {
        val = this.imm_calhdl(val, this._caltyp, this._calpar, this._calraw, this._calref);
      }
    }
    return val;
  }
  async isClosed() {
    return this._isClosed;
  }
  async get_runIndex() {
    return this._runNo;
  }
  async get_startTime() {
    return this._utcStamp - (Date.now() / 1e3 >> 0);
  }
  async get_startTimeUTC() {
    return Math.round(this._startTime);
  }
  async get_realStartTimeUTC() {
    return this._startTime;
  }
  async get_dataSamplesIntervalMs() {
    return Math.round(this._dataSamplesInterval * 1e3);
  }
  async get_dataSamplesInterval() {
    return this._dataSamplesInterval;
  }
  async get_firstDataSamplesInterval() {
    return this._firstMeasureDuration;
  }
  async get_rowCount() {
    if (this._nRows != 0 && this._isClosed) {
      return this._nRows;
    }
    await this.loadStream();
    return this._nRows;
  }
  async get_columnCount() {
    if (this._nCols != 0) {
      return this._nCols;
    }
    await this.loadStream();
    return this._nCols;
  }
  async get_columnNames() {
    if (this._columnNames.length != 0) {
      return this._columnNames;
    }
    await this.loadStream();
    return this._columnNames;
  }
  async get_minValue() {
    return this._minVal;
  }
  async get_averageValue() {
    return this._avgVal;
  }
  async get_maxValue() {
    return this._maxVal;
  }
  async get_realDuration() {
    if (this._isClosed) {
      return this._duration;
    }
    return (Date.now() / 1e3 >> 0) - this._utcStamp;
  }
  async get_dataRows() {
    if (this._values.length == 0 || !this._isClosed) {
      await this.loadStream();
    }
    return this._values;
  }
  async get_data(row, col) {
    if (this._values.length == 0 || !this._isClosed) {
      await this.loadStream();
    }
    if (row >= this._values.length) {
      return YDataStream.DATA_INVALID;
    }
    if (col >= this._values[row].length) {
      return YDataStream.DATA_INVALID;
    }
    return this._values[row][col];
  }
};
YDataStream.DATA_INVALID = YAPI_INVALID_DOUBLE;
YDataStream.DURATION_INVALID = YAPI_INVALID_DOUBLE;
var YDataSet = class {
  constructor(obj_parent, str_functionId = "", str_unit = "", double_startTime = 0, double_endTime = 0) {
    this._hardwareId = "";
    this._functionId = "";
    this._unit = "";
    this._bulkLoad = 0;
    this._startTimeMs = 0;
    this._endTimeMs = 0;
    this._progress = 0;
    this._calib = [];
    this._streams = [];
    this._preview = [];
    this._measures = [];
    this._summaryMinVal = 0;
    this._summaryMaxVal = 0;
    this._summaryTotalAvg = 0;
    this._summaryTotalTime = 0;
    this.DATA_INVALID = YAPI_INVALID_DOUBLE;
    this.DURATION_INVALID = YAPI_INVALID_DOUBLE;
    this.HARDWAREID_INVALID = YAPI_INVALID_STRING;
    this.FUNCTIONID_INVALID = YAPI_INVALID_STRING;
    this.UNIT_INVALID = YAPI_INVALID_STRING;
    this._summary = new YMeasure(0, 0, 0, 0, 0);
    if (str_functionId == "") {
      this._parent = obj_parent;
      this._yapi = obj_parent._yapi;
      this._startTimeMs = 0;
      this._endTimeMs = 0;
    } else {
      this._parent = obj_parent;
      this._yapi = obj_parent._yapi;
      this._functionId = str_functionId;
      this._unit = str_unit;
      this._startTimeMs = double_startTime * 1e3;
      this._endTimeMs = double_endTime * 1e3;
      this._progress = -1;
    }
  }
  imm_get_functionId() {
    return this._functionId;
  }
  imm_get_calibration() {
    return this._calib;
  }
  async loadSummary(data) {
    let dataRows = [];
    let tim;
    let mitv;
    let itv;
    let fitv;
    let end_;
    let nCols;
    let minCol;
    let avgCol;
    let maxCol;
    let res;
    let m_pos;
    let previewTotalTime;
    let previewTotalAvg;
    let previewMinVal;
    let previewMaxVal;
    let previewAvgVal;
    let previewStartMs;
    let previewStopMs;
    let previewDuration;
    let streamStartTimeMs;
    let streamDuration;
    let streamEndTimeMs;
    let minVal;
    let avgVal;
    let maxVal;
    let summaryStartMs;
    let summaryStopMs;
    let summaryTotalTime;
    let summaryTotalAvg;
    let summaryMinVal;
    let summaryMaxVal;
    let url;
    let strdata;
    let measure_data = [];
    if (this._progress < 0) {
      strdata = this._yapi.imm_bin2str(data);
      if (strdata == "{}") {
        this._parent._throw(YAPI_VERSION_MISMATCH, "device firmware is too old");
        return YAPI_VERSION_MISMATCH;
      }
      res = await this._parse(strdata);
      if (res < 0) {
        return res;
      }
    }
    summaryTotalTime = 0;
    summaryTotalAvg = 0;
    summaryMinVal = YAPI_MAX_DOUBLE;
    summaryMaxVal = YAPI_MIN_DOUBLE;
    summaryStartMs = YAPI_MAX_DOUBLE;
    summaryStopMs = YAPI_MIN_DOUBLE;
    for (let ii in this._streams) {
      streamStartTimeMs = Math.round(await this._streams[ii].get_realStartTimeUTC() * 1e3);
      streamDuration = await this._streams[ii].get_realDuration();
      streamEndTimeMs = streamStartTimeMs + Math.round(streamDuration * 1e3);
      if (streamStartTimeMs >= this._startTimeMs && (this._endTimeMs == 0 || streamEndTimeMs <= this._endTimeMs)) {
        previewMinVal = await this._streams[ii].get_minValue();
        previewAvgVal = await this._streams[ii].get_averageValue();
        previewMaxVal = await this._streams[ii].get_maxValue();
        previewStartMs = streamStartTimeMs;
        previewStopMs = streamEndTimeMs;
        previewDuration = streamDuration;
      } else {
        if (!this._streams[ii].imm_wasLoaded()) {
          url = this._streams[ii].imm_get_url();
          data = await this._parent._download(url);
          this._streams[ii].imm_parseStream(data);
        }
        dataRows = await this._streams[ii].get_dataRows();
        if (dataRows.length == 0) {
          return await this.get_progress();
        }
        tim = streamStartTimeMs;
        fitv = Math.round(await this._streams[ii].get_firstDataSamplesInterval() * 1e3);
        itv = Math.round(await this._streams[ii].get_dataSamplesInterval() * 1e3);
        nCols = dataRows[0].length;
        minCol = 0;
        if (nCols > 2) {
          avgCol = 1;
        } else {
          avgCol = 0;
        }
        if (nCols > 2) {
          maxCol = 2;
        } else {
          maxCol = 0;
        }
        previewTotalTime = 0;
        previewTotalAvg = 0;
        previewStartMs = streamEndTimeMs;
        previewStopMs = streamStartTimeMs;
        previewMinVal = YAPI_MAX_DOUBLE;
        previewMaxVal = YAPI_MIN_DOUBLE;
        m_pos = 0;
        while (m_pos < dataRows.length) {
          measure_data = dataRows[m_pos];
          if (m_pos == 0) {
            mitv = fitv;
          } else {
            mitv = itv;
          }
          end_ = tim + mitv;
          if (end_ > this._startTimeMs && (this._endTimeMs == 0 || tim < this._endTimeMs)) {
            minVal = measure_data[minCol];
            avgVal = measure_data[avgCol];
            maxVal = measure_data[maxCol];
            if (previewStartMs > tim) {
              previewStartMs = tim;
            }
            if (previewStopMs < end_) {
              previewStopMs = end_;
            }
            if (previewMinVal > minVal) {
              previewMinVal = minVal;
            }
            if (previewMaxVal < maxVal) {
              previewMaxVal = maxVal;
            }
            if (!isNaN(avgVal)) {
              previewTotalAvg = previewTotalAvg + avgVal * mitv;
              previewTotalTime = previewTotalTime + mitv;
            }
          }
          tim = end_;
          m_pos = m_pos + 1;
        }
        if (previewTotalTime > 0) {
          previewAvgVal = previewTotalAvg / previewTotalTime;
          previewDuration = (previewStopMs - previewStartMs) / 1e3;
        } else {
          previewAvgVal = 0;
          previewDuration = 0;
        }
      }
      this._preview.push(new YMeasure(previewStartMs / 1e3, previewStopMs / 1e3, previewMinVal, previewAvgVal, previewMaxVal));
      if (summaryMinVal > previewMinVal) {
        summaryMinVal = previewMinVal;
      }
      if (summaryMaxVal < previewMaxVal) {
        summaryMaxVal = previewMaxVal;
      }
      if (summaryStartMs > previewStartMs) {
        summaryStartMs = previewStartMs;
      }
      if (summaryStopMs < previewStopMs) {
        summaryStopMs = previewStopMs;
      }
      summaryTotalAvg = summaryTotalAvg + previewAvgVal * previewDuration;
      summaryTotalTime = summaryTotalTime + previewDuration;
    }
    if (this._startTimeMs == 0 || this._startTimeMs > summaryStartMs) {
      this._startTimeMs = summaryStartMs;
    }
    if (this._endTimeMs == 0 || this._endTimeMs < summaryStopMs) {
      this._endTimeMs = summaryStopMs;
    }
    if (summaryTotalTime > 0) {
      this._summary = new YMeasure(summaryStartMs / 1e3, summaryStopMs / 1e3, summaryMinVal, summaryTotalAvg / summaryTotalTime, summaryMaxVal);
    } else {
      this._summary = new YMeasure(0, 0, YAPI_INVALID_DOUBLE, YAPI_INVALID_DOUBLE, YAPI_INVALID_DOUBLE);
    }
    return await this.get_progress();
  }
  async processMore(progress, data) {
    let stream;
    let dataRows = [];
    let tim;
    let itv;
    let fitv;
    let avgv;
    let end_;
    let nCols;
    let minCol;
    let avgCol;
    let maxCol;
    let firstMeasure;
    let baseurl;
    let url;
    let suffix;
    let suffixes = [];
    let idx;
    let bulkFile;
    let streamStr = [];
    let urlIdx;
    let streamBin;
    if (progress != this._progress) {
      return this._progress;
    }
    if (this._progress < 0) {
      return await this.loadSummary(data);
    }
    stream = this._streams[this._progress];
    if (!stream.imm_wasLoaded()) {
      stream.imm_parseStream(data);
    }
    dataRows = await stream.get_dataRows();
    this._progress = this._progress + 1;
    if (dataRows.length == 0) {
      return await this.get_progress();
    }
    tim = Math.round(await stream.get_realStartTimeUTC() * 1e3);
    fitv = Math.round(await stream.get_firstDataSamplesInterval() * 1e3);
    itv = Math.round(await stream.get_dataSamplesInterval() * 1e3);
    if (fitv == 0) {
      fitv = itv;
    }
    if (tim < itv) {
      tim = itv;
    }
    nCols = dataRows[0].length;
    minCol = 0;
    if (nCols > 2) {
      avgCol = 1;
    } else {
      avgCol = 0;
    }
    if (nCols > 2) {
      maxCol = 2;
    } else {
      maxCol = 0;
    }
    firstMeasure = true;
    for (let ii in dataRows) {
      if (firstMeasure) {
        end_ = tim + fitv;
        firstMeasure = false;
      } else {
        end_ = tim + itv;
      }
      avgv = dataRows[ii][avgCol];
      if (end_ > this._startTimeMs && (this._endTimeMs == 0 || tim < this._endTimeMs) && !isNaN(avgv)) {
        this._measures.push(new YMeasure(tim / 1e3, end_ / 1e3, dataRows[ii][minCol], avgv, dataRows[ii][maxCol]));
      }
      tim = end_;
    }
    if (this._bulkLoad > 0 && this._progress < this._streams.length) {
      stream = this._streams[this._progress];
      if (stream.imm_wasLoaded()) {
        return await this.get_progress();
      }
      baseurl = stream.imm_get_baseurl();
      url = stream.imm_get_url();
      suffix = stream.imm_get_urlsuffix();
      suffixes.push(suffix);
      idx = this._progress + 1;
      while (idx < this._streams.length && suffixes.length < this._bulkLoad) {
        stream = this._streams[idx];
        if (!stream.imm_wasLoaded() && stream.imm_get_baseurl() == baseurl) {
          suffix = stream.imm_get_urlsuffix();
          suffixes.push(suffix);
          url = url + "," + suffix;
        }
        idx = idx + 1;
      }
      bulkFile = await this._parent._download(url);
      streamStr = this._parent.imm_json_get_array(bulkFile);
      urlIdx = 0;
      idx = this._progress;
      while (idx < this._streams.length && urlIdx < suffixes.length && urlIdx < streamStr.length) {
        stream = this._streams[idx];
        if (stream.imm_get_baseurl() == baseurl && stream.imm_get_urlsuffix() == suffixes[urlIdx]) {
          streamBin = this._yapi.imm_str2bin(streamStr[urlIdx]);
          stream.imm_parseStream(streamBin);
          urlIdx = urlIdx + 1;
        }
        idx = idx + 1;
      }
    }
    return await this.get_progress();
  }
  async get_privateDataStreams() {
    return this._streams;
  }
  async get_hardwareId() {
    let mo;
    if (!(this._hardwareId == "")) {
      return this._hardwareId;
    }
    mo = await this._parent.get_module();
    this._hardwareId = await mo.get_serialNumber() + "." + await this.get_functionId();
    return this._hardwareId;
  }
  async get_functionId() {
    return this._functionId;
  }
  async get_unit() {
    return this._unit;
  }
  async get_startTimeUTC() {
    return this.imm_get_startTimeUTC();
  }
  imm_get_startTimeUTC() {
    return this._startTimeMs / 1e3;
  }
  async get_endTimeUTC() {
    return this.imm_get_endTimeUTC();
  }
  imm_get_endTimeUTC() {
    return Math.round(this._endTimeMs / 1e3);
  }
  async get_progress() {
    if (this._progress < 0) {
      return 0;
    }
    if (this._progress >= this._streams.length) {
      return 100;
    }
    return (1 + (1 + this._progress) * 98) / (1 + this._streams.length) >> 0;
  }
  async loadMore() {
    let url;
    let stream;
    if (this._progress < 0) {
      url = "logger.json?id=" + this._functionId;
      if (this._startTimeMs != 0) {
        url = url + "&from=" + String(Math.round(this.imm_get_startTimeUTC()));
      }
      if (this._endTimeMs != 0) {
        url = url + "&to=" + String(Math.round(this.imm_get_endTimeUTC() + 1));
      }
    } else {
      if (this._progress >= this._streams.length) {
        return 100;
      } else {
        stream = this._streams[this._progress];
        if (stream.imm_wasLoaded()) {
          return await this.processMore(this._progress, this._yapi.imm_str2bin(""));
        }
        url = stream.imm_get_url();
      }
    }
    try {
      return await this.processMore(this._progress, await this._parent._download(url));
    } catch (e) {
      return await this.processMore(this._progress, await this._parent._download(url));
    }
  }
  async get_summary() {
    return this._summary;
  }
  async get_preview() {
    return this._preview;
  }
  async get_measuresAt(measure) {
    let startUtcMs;
    let stream;
    let dataRows = [];
    let measures = [];
    let tim;
    let itv;
    let end_;
    let nCols;
    let minCol;
    let avgCol;
    let maxCol;
    startUtcMs = measure.get_startTimeUTC() * 1e3;
    stream = null;
    for (let ii in this._streams) {
      if (Math.round(await this._streams[ii].get_realStartTimeUTC() * 1e3) == startUtcMs) {
        stream = this._streams[ii];
      }
    }
    if (stream == null) {
      return measures;
    }
    dataRows = await stream.get_dataRows();
    if (dataRows.length == 0) {
      return measures;
    }
    tim = Math.round(await stream.get_realStartTimeUTC() * 1e3);
    itv = Math.round(await stream.get_dataSamplesInterval() * 1e3);
    if (tim < itv) {
      tim = itv;
    }
    nCols = dataRows[0].length;
    minCol = 0;
    if (nCols > 2) {
      avgCol = 1;
    } else {
      avgCol = 0;
    }
    if (nCols > 2) {
      maxCol = 2;
    } else {
      maxCol = 0;
    }
    for (let ii in dataRows) {
      end_ = tim + itv;
      if (end_ > this._startTimeMs && (this._endTimeMs == 0 || tim < this._endTimeMs)) {
        measures.push(new YMeasure(tim / 1e3, end_ / 1e3, dataRows[ii][minCol], dataRows[ii][avgCol], dataRows[ii][maxCol]));
      }
      tim = end_;
    }
    return measures;
  }
  async get_measures() {
    return this._measures;
  }
  async _parse(str_json) {
    let loadval = null;
    try {
      loadval = JSON.parse(str_json);
    } catch (err) {
    }
    if (!loadval) {
      this._progress = 0;
      return await this.get_progress();
    }
    this._functionId = loadval.id;
    this._unit = loadval.unit;
    this._bulkLoad = loadval.bulk ? parseInt(loadval.bulk) : 0;
    if (loadval.calib) {
      this._calib = this._yapi.imm_decodeFloats(loadval.calib);
      this._calib[0] = this._calib[0] / 1e3 >> 0;
    } else {
      this._calib = this._yapi.imm_decodeWords(loadval.cal);
    }
    this._summary = new YMeasure(0, 0, 0, 0, 0);
    this._streams = [];
    this._preview = [];
    this._measures = [];
    for (let i = 0; i < loadval.streams.length; i++) {
      let stream = this._parent.imm_findDataStream(this, loadval.streams[i]);
      if (!stream)
        continue;
      let streamStartTime = await stream.get_realStartTimeUTC() * 1e3;
      let streamEndTime = streamStartTime + await stream.get_realDuration() * 1e3;
      if (this._startTimeMs > 0 && streamEndTime <= this._startTimeMs) {
      } else if (this._endTimeMs > 0 && streamStartTime >= this._endTimeMs) {
      } else {
        this._streams.push(stream);
      }
    }
    this._progress = 0;
    return this.get_progress();
  }
};
YDataSet.DATA_INVALID = YAPI_INVALID_DOUBLE;
YDataSet.DURATION_INVALID = YAPI_INVALID_DOUBLE;
YDataSet.HARDWAREID_INVALID = YAPI_INVALID_STRING;
YDataSet.FUNCTIONID_INVALID = YAPI_INVALID_STRING;
YDataSet.UNIT_INVALID = YAPI_INVALID_STRING;
YDataSet.DATA_INVALID = YAPI_INVALID_DOUBLE;
YDataSet.DURATION_INVALID = YAPI_INVALID_DOUBLE;
YDataSet.HARDWAREID_INVALID = YAPI_INVALID_STRING;
YDataSet.FUNCTIONID_INVALID = YAPI_INVALID_STRING;
YDataSet.UNIT_INVALID = YAPI_INVALID_STRING;
var YDevice = class {
  constructor(obj_yapi, str_rooturl, obj_wpRec, obj_ypRecs) {
    this._yapi = obj_yapi;
    this._rootUrl = str_rooturl;
    this._serialNumber = "";
    this._logicalName = "";
    this._productName = "";
    this._productId = 0;
    this._beacon = 0;
    this._devYdx = -1;
    this._lastErrorType = YAPI_SUCCESS;
    this._lastErrorMsg = "no error";
    this._cache = {_expiration: 0, _json: new Uint8Array(0), _precooked: {}};
    this._functions = [];
    this._busy = 0;
    this._pendingQueries = Promise.resolve();
    this._lastTimeRef = 0;
    this._lastDuration = 0;
    this._logCallback = null;
    this._logIsPulling = false;
    this._logpos = 0;
    if (obj_wpRec && obj_ypRecs) {
      this._serialNumber = obj_wpRec.serialNumber;
      this._logicalName = obj_wpRec.logicalName;
      this._productName = obj_wpRec.productName;
      this._productId = obj_wpRec.productId;
      this._beacon = obj_wpRec.beacon;
      this._devYdx = obj_wpRec.index == void 0 ? -1 : obj_wpRec.index;
      this.imm_updateFromYP(obj_ypRecs);
      this._yapi.imm_reindexDevice(this);
    }
  }
  _throw(int_errType, str_errMsg, obj_retVal) {
    this._lastErrorType = int_errType;
    this._lastErrorMsg = str_errMsg;
    return this._yapi._throw(int_errType, str_errMsg, obj_retVal);
  }
  imm_getRootUrl() {
    return this._rootUrl;
  }
  imm_getSerialNumber() {
    return this._serialNumber;
  }
  imm_getLogicalName() {
    return this._logicalName;
  }
  async getLogicalName() {
    if (this._cache._expiration == 0) {
      await this.refresh();
    }
    return this._logicalName;
  }
  imm_getProductName() {
    return this._productName;
  }
  imm_getProductId() {
    return this._productId;
  }
  imm_getBeacon() {
    return this._beacon;
  }
  async getBeacon() {
    if (this._cache._expiration == 0) {
      await this.refresh();
    }
    return this._beacon;
  }
  imm_getLastTimeRef() {
    return this._lastTimeRef;
  }
  imm_getLastDuration() {
    return this._lastDuration;
  }
  imm_triggerLogPull() {
    if (this._logCallback == null || this._logIsPulling) {
      return;
    }
    this._logIsPulling = true;
    let request = "GET logs.txt?pos=" + this._logpos;
    let prom = this._yapi.devRequest(this._rootUrl, request, null, 0);
    prom.then(async (yreq) => {
      if (yreq.errorType != YAPI_SUCCESS) {
        this._logIsPulling = false;
        return;
      }
      if (this._logCallback == null) {
        this._logIsPulling = false;
        return;
      }
      let resultStr = YAPI.imm_bin2str(yreq.bin_result);
      let pos = resultStr.lastIndexOf("\n@");
      if (pos < 0) {
        this._logIsPulling = false;
        return;
      }
      let logs = resultStr.substring(0, pos);
      let posStr = resultStr.substring(pos + 2);
      this._logpos = parseInt(posStr);
      let module = YModule.FindModuleInContext(this._yapi, this._serialNumber);
      let lines = logs.trim().split("\n");
      try {
        for (let i = 0; i < lines.length; i++) {
          await this._logCallback(module, lines[i]);
        }
      } catch (e) {
        this._yapi.imm_log("Exception in device log callback:", e);
      }
      this._logIsPulling = false;
    });
  }
  imm_registerLogCallback(callback) {
    this._logCallback = callback;
    if (callback != null) {
      this.imm_triggerLogPull();
    } else {
      this._logpos = 0;
    }
  }
  imm_setTimeRef(float_timestamp, float_duration) {
    this._lastTimeRef = float_timestamp;
    this._lastDuration = float_duration;
  }
  imm_getDevYdx() {
    return this._devYdx;
  }
  imm_describe() {
    let res = this._rootUrl;
    if (this._serialNumber != "") {
      res = this._serialNumber;
      if (this._logicalName != "") {
        res = res + " (" + this._logicalName + ")";
      }
    }
    return this._productName + " " + res;
  }
  imm_updateFromYP(obj_ypRecs) {
    let funidx = 0;
    for (let categ in obj_ypRecs) {
      for (let key in obj_ypRecs[categ]) {
        let rec = obj_ypRecs[categ][key];
        let hwid = rec["hardwareId"];
        let dotpos = hwid.indexOf(".");
        if (hwid.substr(0, dotpos) == this._serialNumber) {
          let funydx = rec["index"];
          if (funydx == void 0)
            funydx = funidx;
          this._functions[funydx] = [hwid.substr(dotpos + 1), rec["logicalName"]];
          funidx++;
        }
      }
    }
  }
  async updateFromReq(yreq, loadval) {
    this._cache._expiration = this._yapi.GetTickCount() + this._yapi.defaultCacheValidity;
    this._cache._json = yreq.bin_result;
    let func;
    let reindex = false;
    if (this._productName == "") {
      for (func in loadval) {
        if (func == "module") {
          this._serialNumber = loadval.module.serialNumber;
          this._logicalName = loadval.module.logicalName;
          this._productName = loadval.module.productName;
          this._productId = loadval.module.productId;
          this._beacon = loadval.module.beacon;
        } else if (func == "services") {
          this.imm_updateFromYP(loadval.services.yellowPages);
        }
      }
      reindex = true;
    } else {
      let renamed = false;
      for (func in loadval) {
        if (func == "module") {
          if (this._logicalName != loadval.module.logicalName) {
            this._logicalName = loadval.module.logicalName;
            reindex = true;
          }
          this._beacon = loadval.module.beacon;
        } else if (func != "services") {
          let name = loadval[func]["logicalName"];
          if (name == void 0)
            name = loadval.module.logicalName;
          let pubval = loadval[func]["advertisedValue"];
          if (pubval != void 0) {
            await this._yapi.setFunctionValue(loadval.module.serialNumber + "." + func, pubval);
          }
          let funydx;
          for (funydx in this._functions) {
            if (this._functions[funydx][0] == func) {
              if (this._functions[funydx][1] != name) {
                this._functions[funydx][1] = name;
                reindex = true;
              }
              break;
            }
          }
        }
      }
    }
    if (reindex) {
      this._yapi.imm_reindexDevice(this);
    }
  }
  imm_dropCache() {
    this._cache._expiration = 0;
    this._cache._precooked = {};
  }
  imm_functionCount() {
    let funcPos = 0;
    for (let key in this._functions) {
      funcPos++;
    }
    return funcPos;
  }
  imm_functionId(int_idx) {
    let funcPos = 0;
    for (let key in this._functions) {
      if (int_idx === funcPos) {
        return this._functions[key][0];
      }
      funcPos++;
    }
    return "";
  }
  imm_functionBaseType(int_idx) {
    let funid = this.imm_functionId(int_idx);
    if (funid !== "") {
      let ftype = this._yapi.imm_getFunctionBaseType(this._serialNumber + "." + funid);
      for (let baseType in Y_BASETYPES) {
        if (Y_BASETYPES[baseType] === ftype) {
          return baseType;
        }
      }
    }
    return "Function";
  }
  imm_functionType(int_idx) {
    let funid = this.imm_functionId(int_idx);
    if (funid !== "") {
      let i;
      for (i = funid.length; i > 0; i--) {
        if (funid[i - 1] > "9") {
          break;
        }
      }
      let functionType = funid[0].toUpperCase() + funid.substr(1, i - 1);
      return functionType;
    }
    return "";
  }
  imm_functionName(int_idx) {
    let funcPos = 0;
    for (let key in this._functions) {
      if (int_idx === funcPos) {
        return this._functions[key][1];
      }
      funcPos++;
    }
    return "";
  }
  imm_functionValue(int_idx) {
    let funid = this.imm_functionId(int_idx);
    if (funid !== "") {
      return this._yapi.imm_getFunctionValue(this._serialNumber + "." + funid);
    }
    return "";
  }
  imm_functionIdByFunYdx(int_funydx) {
    if (this._functions[int_funydx]) {
      return this._functions[int_funydx][0];
    }
    return "";
  }
  imm_jzon2json(jzon, json) {
    if (Array.isArray(jzon)) {
      let sz = jzon.length;
      if (Array.isArray(json)) {
        let defval = json.length > 0 ? json[0] : null;
        let res = [];
        for (let idx = 0; idx < sz; idx++) {
          res[idx] = this.imm_jzon2json(jzon[idx], defval);
        }
        return res;
      } else if (typeof json === "object") {
        let idx = 0;
        let res = {};
        for (let key in json) {
          if (json.hasOwnProperty(key)) {
            res[key] = this.imm_jzon2json(jzon[idx], json[key]);
            idx++;
          }
        }
        return res;
      } else {
        return jzon;
      }
    } else if (typeof jzon === "object") {
      if (Array.isArray(json)) {
        return jzon;
      } else if (typeof json === "object") {
        let defval = null;
        for (let key in json) {
          if (json.hasOwnProperty(key)) {
            defval = json[key];
            break;
          }
        }
        let res = {};
        for (let key in jzon) {
          if (jzon.hasOwnProperty(key)) {
            if (json.hasOwnProperty(key) && (!Array.isArray(json[key]) || json[key].length > 0)) {
              res[key] = this.imm_jzon2json(jzon[key], json[key]);
            } else {
              res[key] = this.imm_jzon2json(jzon[key], defval);
            }
          }
        }
        return res;
      } else {
        return jzon;
      }
    }
    return jzon;
  }
  async requestAPI(int_msValidity) {
    if (this._cache._expiration > this._yapi.GetTickCount()) {
      let res = new YHTTPRequest(this._cache._json);
      res.obj_result = JSON.parse(JSON.stringify(this._cache._precooked));
      return res;
    }
    let req = "GET /api.json";
    let precooked = this._cache._precooked;
    if (precooked.module && precooked.module.firmwareRelease) {
      req += "?fw=" + encodeURIComponent(precooked.module.firmwareRelease);
    }
    let yreq = await this._yapi.devRequest(this._rootUrl, req, null, 0);
    if (yreq.errorType != YAPI_SUCCESS)
      return yreq;
    if (!int_msValidity) {
      int_msValidity = this._yapi.defaultCacheValidity;
    }
    this._cache._json = yreq.bin_result;
    try {
      yreq.obj_result = JSON.parse(this._yapi.imm_bin2str(yreq.bin_result));
      if (Array.isArray(yreq.obj_result)) {
        if (precooked.module) {
          let objres = this.imm_jzon2json(yreq.obj_result, precooked);
          yreq.obj_result = objres;
          if (objres.module && objres.module.serialNumber === objres.module.serialNumber && objres.module.firmwareRelease === objres.module.firmwareRelease) {
            let jsonstr = JSON.stringify(yreq.obj_result);
            this._cache._json = yreq.bin_result = this._yapi.imm_str2bin(jsonstr);
            this._cache._precooked = JSON.parse(jsonstr);
          } else {
            this.imm_dropCache();
            yreq.errorType = YAPI_IO_ERROR;
            yreq.errorMsg = "Request failed, could not parse API JZON result for " + this._rootUrl;
          }
        } else {
          yreq.errorType = YAPI_IO_ERROR;
          yreq.errorMsg = "Request failed, could not parse API array result for " + this._rootUrl;
        }
      } else if (yreq.obj_result.module && yreq.obj_result.module.firmwareRelease) {
        this._cache._precooked = JSON.parse(JSON.stringify(yreq.obj_result));
      }
      this._cache._expiration = this._yapi.GetTickCount() + int_msValidity;
      this._logicalName = yreq.obj_result.module.logicalName;
      this._beacon = yreq.obj_result.module.beacon;
    } catch (err) {
      yreq.errorType = YAPI_IO_ERROR;
      yreq.errorMsg = "Request failed, could not parse API JSON result for " + this._rootUrl;
    }
    return yreq;
  }
  async refresh() {
    let yreq = await this.requestAPI(this._yapi.defaultCacheValidity);
    if (yreq.errorType != YAPI_SUCCESS) {
      return this._throw(yreq.errorType, yreq.errorMsg, yreq.errorType);
    }
    await this.updateFromReq(yreq, yreq.obj_result);
    return YAPI_SUCCESS;
  }
};
var YFirmwareFile = class {
  constructor(path, serial, pictype, product, firmware, prog_version, ROM_nb_zone, FLA_nb_zone, ROM_total_size, FLA_total_size, data, zone_ofs) {
    this._path = path;
    this._serial = serial;
    this._pictype = pictype;
    this._product = product;
    this._firmware = firmware;
    this._prog_version = prog_version;
    this._ROM_nb_zone = ROM_nb_zone;
    this._FLA_nb_zone = FLA_nb_zone;
    this._ROM_total_size = ROM_total_size;
    this._FLA_total_size = FLA_total_size;
    this._data = data;
    this._zone_ofs = zone_ofs;
  }
  static imm_Parse(path, data, force) {
    const BYN_REV_V4 = 4;
    const BYN_REV_V5 = 5;
    const BYN_REV_V6 = 6;
    const MAX_ROM_ZONES_PER_FILES = 16;
    const MAX_FLASH_ZONES_PER_FILES = 4;
    const BYN_HEAD_SIZE_V4 = 96 + 8;
    const BYN_HEAD_SIZE_V5 = 96 + 32;
    const BYN_HEAD_SIZE_V6 = 96 + 48;
    const BYN_MD5_OFS_V6 = 96 + 16;
    let pos = 0;
    let getShort = () => {
      let res = data[pos] + (data[pos + 1] << 8);
      pos += 2;
      return res;
    };
    let getInt = () => {
      let res = data[pos] + (data[pos + 1] << 8) + (data[pos + 2] << 16) + (data[pos + 3] << 24);
      pos += 4;
      return res;
    };
    let getString = (maxlen) => {
      let end = pos + maxlen;
      while (end > pos && data[end - 1] == 0) {
        end--;
      }
      let res = YAPI.imm_bin2str(data.subarray(pos, end));
      pos += maxlen;
      return res;
    };
    let sign = getString(4);
    if (sign != "BYN")
      return null;
    let rev = getShort();
    let serial = getString(20);
    let pictype = getString(20);
    let product = getString(28);
    let firmware = getString(22);
    if (serial.length >= 20)
      return null;
    if (product.length >= 28)
      return null;
    if (firmware.length >= 22)
      return null;
    let ROM_nb_zone = 0;
    let FLA_nb_zone = 0;
    let ROM_total_size = 0;
    let FLA_total_size = 0;
    let prog_buf;
    let prog_version = "";
    let zone_ofs;
    let datasize;
    switch (rev) {
      case BYN_REV_V4:
        zone_ofs = BYN_HEAD_SIZE_V4;
        ROM_nb_zone = getInt();
        datasize = getInt();
        if (ROM_nb_zone > MAX_ROM_ZONES_PER_FILES)
          return null;
        if (datasize != data.length - BYN_HEAD_SIZE_V4)
          return null;
        break;
      case BYN_REV_V5:
        zone_ofs = BYN_HEAD_SIZE_V5;
        prog_version = getString(22);
        if (!force && !YFirmwareFile.imm_progCompatible(prog_version))
          return null;
        getShort();
        ROM_nb_zone = getInt();
        datasize = getInt();
        if (ROM_nb_zone > MAX_ROM_ZONES_PER_FILES)
          return null;
        if (datasize != data.length - BYN_HEAD_SIZE_V5)
          return null;
        break;
      case BYN_REV_V6:
        zone_ofs = BYN_HEAD_SIZE_V6;
        let md5hdr = data.subarray(pos, pos + 16);
        pos += 16;
        let md5hdrstr = YAPI.imm_bin2hexstr(md5hdr);
        let md5ctx = new Y_MD5Ctx();
        md5ctx.addData(data.subarray(BYN_MD5_OFS_V6));
        let md5bynstr = YAPI.imm_bin2hexstr(md5ctx.calculate());
        if (md5hdrstr != md5bynstr) {
          YAPI.imm_log("Invalid firmware image signature, file is corrupt");
          if (YAPI._logLevel >= 2) {
            YAPI.imm_log("hdr MD5: " + md5hdrstr);
            YAPI.imm_log("byn MD5: " + md5bynstr);
            YAPI.imm_log("byn size: " + data.length);
          }
          return null;
        }
        prog_version = getString(22);
        if (!force && !YFirmwareFile.imm_progCompatible(prog_version))
          return null;
        ROM_nb_zone = data[pos++];
        FLA_nb_zone = data[pos++];
        ROM_total_size = getInt();
        FLA_total_size = getInt();
        if (ROM_nb_zone > MAX_ROM_ZONES_PER_FILES)
          return null;
        if (FLA_nb_zone > MAX_FLASH_ZONES_PER_FILES)
          return null;
        break;
      default:
        return null;
    }
    return new YFirmwareFile(path, serial, pictype, product, firmware, prog_version, ROM_nb_zone, FLA_nb_zone, ROM_total_size, FLA_total_size, data, zone_ofs);
  }
  static imm_progCompatible(prog_version) {
    if (prog_version == "")
      return true;
    let apiVer = YAPI.imm_GetAPIVersion();
    let dashpos = apiVer.indexOf("-");
    if (dashpos > 0) {
      apiVer = apiVer.slice(0, dashpos);
    }
    apiVer = apiVer.slice(apiVer.lastIndexOf(".") + 1);
    if (parseInt(prog_version) > parseInt(apiVer)) {
      YAPI.imm_log("checkProgField: byn=" + prog_version + " api=" + apiVer);
      return false;
    }
    return true;
  }
  imm_getSerial() {
    return this._serial;
  }
  imm_getPictype() {
    return this._pictype;
  }
  imm_getProduct() {
    return this._product;
  }
  imm_getFirmwareRelease() {
    return this._firmware;
  }
  imm_getFirmwareReleaseAsInt() {
    return parseInt(this._firmware);
  }
  imm_getProg_version() {
    return this._prog_version;
  }
  imm_getROM_nb_zone() {
    return this._ROM_nb_zone;
  }
  imm_getFLA_nb_zone() {
    return this._FLA_nb_zone;
  }
  imm_getROM_total_size() {
    return this._ROM_total_size;
  }
  imm_getFLA_total_size() {
    return this._FLA_total_size;
  }
  imm_getData() {
    return this._data;
  }
  imm_getPath() {
    return this._path;
  }
};
var YFirmwareUpdate = class {
  constructor(obj_yapi, str_serial, str_path, bin_settings, bool_force) {
    this._serial = "";
    this._settings = new Uint8Array(0);
    this._firmwarepath = "";
    this._progress_msg = "";
    this._progress_c = 0;
    this._progress = 0;
    this._restore_step = 0;
    this._force = false;
    this._yapi = obj_yapi;
    this._serial = str_serial;
    this._firmwarepath = str_path;
    this._settings = bin_settings;
    this._force = bool_force;
  }
  imm_progress(progress, msg) {
    this._progress = progress;
    this._progress_msg = msg;
  }
  async _processMore_internal(newupdate) {
    if (!newupdate)
      return YAPI_SUCCESS;
    let bytes;
    this.imm_progress(0, "Firmware update started");
    if (typeof this._firmwarepath == "string" && this._firmwarepath.indexOf("yoctopuce.com") >= 0) {
      this.imm_progress(1, "Downloading firmware");
      bytes = await this._yapi.system_env.downloadfile(this._firmwarepath);
    } else {
      this.imm_progress(1, "Loading firmware");
      bytes = await this._yapi.system_env.loadfile(this._firmwarepath);
    }
    let firmware = YFirmwareFile.imm_Parse(this._firmwarepath, bytes, this._force);
    if (!firmware) {
      return this._yapi._throw(YAPI_DEVICE_NOT_FOUND, "Device " + this._serial + " is not detected", YAPI_DEVICE_NOT_FOUND);
    }
    this.imm_progress(5, "Check if module is already in bootloader");
    let hub = null;
    let module = YModule.FindModuleInContext(this._yapi, this._serial + ".module");
    if (await module.isOnline()) {
      let dev = this._yapi.imm_getDevice(this._serial);
      let baseUrl = dev.imm_getRootUrl();
      let byPos = baseUrl.indexOf("/bySerial/");
      if (byPos >= 0) {
        baseUrl = baseUrl.slice(0, byPos + 1);
      } else if (baseUrl.slice(-1) != "/")
        baseUrl = baseUrl + "/";
      let urlInfo = this._yapi.imm_parseRegisteredUrl(baseUrl);
      hub = this._yapi.imm_getHub(urlInfo);
    } else {
      let hubs = this._yapi._connectedHubs;
      for (let i = 0; i < hubs.length; i++) {
        let ldrs = await hubs[i].getBootloaders();
        if (ldrs.indexOf(this._serial) >= 0) {
          hub = hubs[i];
          break;
        }
      }
    }
    if (hub == null) {
      this.imm_progress(-1, "Device " + this._serial + " is not detected");
      return this._yapi._throw(YAPI_DEVICE_NOT_FOUND, "Device " + this._serial + " is not detected", YAPI_DEVICE_NOT_FOUND);
    }
    try {
      await hub.firmwareUpdate(this._serial, firmware, this._settings, (percent, msg) => {
        this.imm_progress(5 + (percent * 80 + 50) / 100 >> 0, msg);
      });
    } catch (e) {
      this.imm_progress(-1, e.message);
      return this._yapi._throw(YAPI_IO_ERROR, e.message, YAPI_IO_ERROR);
    }
    if (module._cache.parentHub) {
      this.imm_progress(100, "Firmware update scheduled successfully");
    } else {
      this.imm_progress(80, "Wait for the device to restart");
      let timeout = this._yapi.GetTickCount() + 6e4;
      await module.clearCache();
      while (!await module.isOnline() && timeout > this._yapi.GetTickCount()) {
        await this._yapi.Sleep(500);
        await this._yapi.UpdateDeviceList();
      }
      if (await module.isOnline()) {
        if (this._settings != null) {
          this.imm_progress(95, "Restoring device settings");
          await module.set_allSettingsAndFiles(this._settings);
          await module.saveToFlash();
        }
        let real_fw = await module.get_firmwareRelease();
        if (real_fw == firmware.imm_getFirmwareRelease()) {
          this.imm_progress(100, "Success");
        } else {
          this.imm_progress(-1, "Unable to update firmware");
        }
      } else {
        this.imm_progress(-1, "Device did not reboot correctly");
      }
    }
    return YAPI_SUCCESS;
  }
  static async checkFirmware_r(file, serial_base, force) {
    if (file.substr(-4).toLowerCase() != ".byn")
      return null;
    let bynfile = await YAPI.system_env.loadfile(file);
    let firmware = YFirmwareFile.imm_Parse(file, bynfile, force);
    if (!firmware)
      return null;
    if (firmware.imm_getSerial().slice(0, serial_base.length) != serial_base)
      return null;
    return firmware;
  }
  static async CheckFirmwareEx(serial, path, minrelease, force) {
    let link = "";
    let best_rev = 0;
    let current_rev;
    if (typeof path == "string" && path.indexOf("yoctopuce.com") >= 0) {
      try {
        let data = await YAPI.system_env.downloadfile("http://www.yoctopuce.com/FR/common/getLastFirmwareLink.php?serial=" + serial);
        let obj = JSON.parse(YAPI.imm_bin2str(data));
        link = obj["link"];
        best_rev = obj["version"];
      } catch (e) {
        YAPI.imm_log("failed to retrieve firmware information from www.yoctopuce.com", e);
        YAPI._throw(YAPI_IO_ERROR, "failed to retrieve firmware information from www.yoctopuce.com", "");
        return "";
      }
    } else {
      let firmware = await YFirmwareUpdate.checkFirmware_r(path, serial.substring(0, 8), force);
      if (firmware != null) {
        best_rev = firmware.imm_getFirmwareReleaseAsInt();
        link = firmware.imm_getPath();
      }
    }
    if (minrelease != 0) {
      if (minrelease < best_rev) {
        return link;
      } else {
        return "";
      }
    }
    return link;
  }
  static async CheckFirmware_internal(serial, path, minrelease) {
    return YFirmwareUpdate.CheckFirmwareEx(serial, path, minrelease, false);
  }
  static async GetAllBootLoadersInContext_internal(yctx) {
    let hubs = yctx._connectedHubs;
    let res = [];
    for (let i = 0; i < hubs.length; i++) {
      let ldrs = await hubs[i].getBootloaders();
      for (let j = 0; j < ldrs.length; j++) {
        res.push(ldrs[j]);
      }
    }
    return res;
  }
  static async GetAllBootLoaders_internal() {
    return YFirmwareUpdate.GetAllBootLoadersInContext(YAPI);
  }
  async _processMore(newupdate) {
    return await this._processMore_internal(newupdate);
  }
  static async GetAllBootLoaders() {
    return await this.GetAllBootLoaders_internal();
  }
  static async GetAllBootLoadersInContext(yctx) {
    return await this.GetAllBootLoadersInContext_internal(yctx);
  }
  static async CheckFirmware(serial, path, minrelease) {
    return await this.CheckFirmware_internal(serial, path, minrelease);
  }
  async get_progress() {
    if (this._progress >= 0) {
      await this._processMore(0);
    }
    return this._progress;
  }
  async get_progressMessage() {
    return this._progress_msg;
  }
  async startUpdate() {
    let err;
    let leng;
    err = this._yapi.imm_bin2str(this._settings);
    leng = err.length;
    if (leng >= 6 && err.substr(0, 6) == "error:") {
      this._progress = -1;
      this._progress_msg = err.substr(6, leng - 6);
    } else {
      this._progress = 0;
      this._progress_c = 0;
      await this._processMore(1);
    }
    return this._progress;
  }
};
var YFunction = class {
  constructor(obj_yapi, str_func) {
    this._logicalName = YFunction.LOGICALNAME_INVALID;
    this._advertisedValue = YFunction.ADVERTISEDVALUE_INVALID;
    this._valueCallbackFunction = null;
    this._cacheExpiration = 0;
    this._serial = "";
    this._funId = "";
    this._hwId = "";
    this.LOGICALNAME_INVALID = YAPI_INVALID_STRING;
    this.ADVERTISEDVALUE_INVALID = YAPI_INVALID_STRING;
    this._yapi = obj_yapi;
    this._className = "Function";
    this._func = str_func;
    this._lastErrorType = YAPI_SUCCESS;
    this._lastErrorMsg = "no error";
    this._dataStreams = {};
    this._userData = null;
    this._cache = {_expiration: -1, functionid: "", hwid: ""};
    this._valueCallbackFunction = null;
  }
  _throw(int_errType, str_errMsg, obj_retVal) {
    this._lastErrorType = int_errType;
    this._lastErrorMsg = str_errMsg;
    return this._yapi._throw(int_errType, str_errMsg, obj_retVal);
  }
  async isReadOnly_internal() {
    try {
      let serial = await this.get_serialNumber();
      return this._yapi.isReadOnly(serial);
    } catch (e) {
      return true;
    }
  }
  imm_parseAttr(name, val) {
    switch (name) {
      case "_expiration":
        this._cacheExpiration = val;
        return 1;
      case "logicalName":
        this._logicalName = val;
        return 1;
      case "advertisedValue":
        this._advertisedValue = val;
        return 1;
    }
    return 0;
  }
  async get_logicalName() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YFunction.LOGICALNAME_INVALID;
      }
    }
    res = this._logicalName;
    return res;
  }
  async set_logicalName(newval) {
    let rest_val;
    if (!await YAPI.CheckLogicalName(newval)) {
      return this._throw(YAPI.INVALID_ARGUMENT, "Invalid name :" + newval, YAPI.INVALID_ARGUMENT);
    }
    rest_val = String(newval);
    return await this._setAttr("logicalName", rest_val);
  }
  async get_advertisedValue() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YFunction.ADVERTISEDVALUE_INVALID;
      }
    }
    res = this._advertisedValue;
    return res;
  }
  async set_advertisedValue(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("advertisedValue", rest_val);
  }
  static FindFunction(func) {
    let obj;
    obj = YFunction._FindFromCache("Function", func);
    if (obj == null) {
      obj = new YFunction(YAPI, func);
      YFunction._AddToCache("Function", func, obj);
    }
    return obj;
  }
  static FindFunctionInContext(yctx, func) {
    let obj;
    obj = YFunction._FindFromCacheInContext(yctx, "Function", func);
    if (obj == null) {
      obj = new YFunction(yctx, func);
      YFunction._AddToCache("Function", func, obj);
    }
    return obj;
  }
  async registerValueCallback(callback) {
    let val;
    if (callback != null) {
      await YFunction._UpdateValueCallbackList(this, true);
    } else {
      await YFunction._UpdateValueCallbackList(this, false);
    }
    this._valueCallbackFunction = callback;
    if (callback != null && await this.isOnline()) {
      val = this._advertisedValue;
      if (!(val == "")) {
        await this._invokeValueCallback(val);
      }
    }
    return 0;
  }
  async _invokeValueCallback(value) {
    if (this._valueCallbackFunction != null) {
      try {
        await this._valueCallbackFunction(this, value);
      } catch (e) {
        this._yapi.imm_log("Exception in valueCallback:", e);
      }
    } else {
    }
    return 0;
  }
  async muteValueCallbacks() {
    return await this.set_advertisedValue("SILENT");
  }
  async unmuteValueCallbacks() {
    return await this.set_advertisedValue("");
  }
  async loadAttribute(attrName) {
    let url;
    let attrVal;
    url = "api/" + await this.get_functionId() + "/" + attrName;
    attrVal = await this._download(url);
    return this._yapi.imm_bin2str(attrVal);
  }
  async isReadOnly() {
    return await this.isReadOnly_internal();
  }
  async get_serialNumber() {
    let m;
    m = await this.get_module();
    return await m.get_serialNumber();
  }
  async _parserHelper() {
    return 0;
  }
  nextFunction() {
    let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
    if (resolve.errorType != YAPI.SUCCESS)
      return null;
    let next_hwid = this._yapi.imm_getNextHardwareId(this._className, resolve.result);
    if (next_hwid == null)
      return null;
    return YFunction.FindFunctionInContext(this._yapi, next_hwid);
  }
  static FirstFunction() {
    let next_hwid = YAPI.imm_getFirstHardwareId("Function");
    if (next_hwid == null)
      return null;
    return YFunction.FindFunction(next_hwid);
  }
  static FirstFunctionInContext(yctx) {
    let next_hwid = yctx.imm_getFirstHardwareId("Function");
    if (next_hwid == null)
      return null;
    return YFunction.FindFunctionInContext(yctx, next_hwid);
  }
  static _FindFromCacheInContext(yctx, className, func) {
    return yctx.imm_getFunction(className, func);
  }
  static _FindFromCache(className, func) {
    return YAPI.imm_getFunction(className, func);
  }
  static _AddToCache(className, func, obj) {
    obj._yapi.imm_setFunction(className, func, obj);
  }
  static _ClearCache(obj_yapi = null) {
    if (!obj_yapi)
      obj_yapi = YAPI;
    obj_yapi.imm_ResetToDefaults();
  }
  static async _UpdateValueCallbackList(obj_func, bool_add) {
    await obj_func._yapi._UpdateValueCallbackList(obj_func, bool_add);
  }
  static async _UpdateTimedReportCallbackList(obj_func, bool_add) {
    await obj_func._yapi._UpdateTimedReportCallbackList(obj_func, bool_add);
  }
  async describe() {
    if (this._hwId != "") {
      return this._className + "(" + this._func + ")=" + this._hwId;
    }
    let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
    if (resolve.errorType != YAPI_SUCCESS && resolve.result != this._func) {
      return this._className + "(" + this._func + ")=unresolved";
    }
    return this._className + "(" + this._func + ")=" + resolve.result;
  }
  async get_hardwareId() {
    if (this._hwId != "") {
      return this._hwId;
    }
    let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
    if (resolve.errorType != YAPI_SUCCESS) {
      await this.isOnline();
      resolve = this._yapi.imm_resolveFunction(this._className, this._func);
      if (resolve.errorType != YAPI_SUCCESS) {
        return this._throw(resolve.errorType, resolve.errorMsg, YFunction.HARDWAREID_INVALID);
      }
    }
    return resolve.result;
  }
  async get_functionId() {
    if (this._funId != "") {
      return this._funId;
    }
    let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
    if (resolve.errorType != YAPI_SUCCESS) {
      await this.isOnline();
      resolve = this._yapi.imm_resolveFunction(this._className, this._func);
      if (resolve.errorType != YAPI_SUCCESS) {
        return this._throw(resolve.errorType, resolve.errorMsg, YFunction.FUNCTIONID_INVALID);
      }
    }
    let hardwareId = resolve.result;
    let pos = hardwareId.indexOf(".");
    return hardwareId.substr(pos + 1);
  }
  imm_get_functionId() {
    if (this._funId != "") {
      return this._funId;
    }
    let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
    if (resolve.errorType != YAPI_SUCCESS) {
      return this._throw(resolve.errorType, resolve.errorMsg, YFunction.FUNCTIONID_INVALID);
    }
    let hardwareId = resolve.result;
    let pos = hardwareId.indexOf(".");
    return hardwareId.substr(pos + 1);
  }
  async get_friendlyName() {
    let resolve = this._yapi.imm_getFriendlyNameFunction(this._className, this._func);
    if (resolve.errorType != YAPI_SUCCESS) {
      await this.isOnline();
      resolve = this._yapi.imm_getFriendlyNameFunction(this._className, this._func);
      if (resolve.errorType != YAPI_SUCCESS) {
        return this._throw(resolve.errorType, resolve.errorMsg, YFunction.FRIENDLYNAME_INVALID);
      }
    }
    return resolve.result;
  }
  async _parse(yreq, msValidity) {
    if (!yreq.obj_result)
      return;
    yreq.obj_result._expiration = this._yapi.GetTickCount() + msValidity;
    this._cache = yreq.obj_result;
    this._serial = yreq.obj_result.deviceid;
    this._funId = yreq.obj_result.functionid;
    this._hwId = yreq.obj_result.hwid;
    for (let key in yreq.obj_result) {
      this.imm_parseAttr(key, yreq.obj_result[key]);
    }
    await this._parserHelper();
  }
  isOnline_async(func, ctx) {
    this.isOnline().then((res) => {
      func(ctx, this, res);
    }).catch((e) => {
      func(ctx, this, false);
    });
  }
  load_async(ms_validiy, func, ctx) {
    this.load(ms_validiy).then((res) => {
      func(ctx, this, YAPI_SUCCESS);
    }).catch((e) => {
      func(ctx, this, this.get_errorType());
    });
  }
  async _getAttr(str_attr) {
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS)
        return null;
    }
    if (typeof this._cache[str_attr] == "undefined") {
      this._throw(YAPI_VERSION_MISMATCH, "No such attribute " + str_attr + " in function", null);
    }
    return this._cache[str_attr];
  }
  async _getFixedAttr(str_attr) {
    if (this._cacheExpiration == 0) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS)
        return null;
    }
    if (typeof this._cache[str_attr] == "undefined") {
      this._throw(YAPI_VERSION_MISMATCH, "No such attribute " + str_attr + " in function", null);
    }
    return this._cache[str_attr];
  }
  imm_escapeAttr(str_newval) {
    return escape(str_newval).replace(/[+]/g, "%2B").replace(/%20/g, "+").replace(/%21/g, "!").replace(/%24/g, "$").replace(/%27/g, "'").replace(/%28/g, "(").replace(/%29/g, ")").replace(/%2[cC]/g, ",").replace(/%2[fF]/g, "/").replace(/%3[aA]/g, ":").replace(/%3[bB]/g, ";").replace(/%3[fF]/g, "?").replace(/%5[bB]/g, "[").replace(/%5[dD]/g, "]");
  }
  async _setAttr(str_attr, str_newval) {
    if (str_newval == void 0) {
      return this._throw(YAPI_INVALID_ARGUMENT, "Undefined value to set for attribute " + str_attr, null);
    }
    let attrname = encodeURIComponent(str_attr);
    let attrval = this.imm_escapeAttr(str_newval);
    let extra = "/" + attrname + "?" + attrname + "=" + attrval + "&.";
    if (this._cacheExpiration != 0) {
      this._cacheExpiration = this._yapi.GetTickCount();
      this._cache._expiration = this._cacheExpiration;
    }
    let yreq = await this._yapi.funcRequest(this._className, this._func, extra);
    if (yreq.errorType != YAPI_SUCCESS) {
      return this._throw(yreq.errorType, yreq.errorMsg, yreq.errorType);
    }
    return YAPI_SUCCESS;
  }
  async _download(str_path) {
    let devid = this._serial;
    if (devid == "") {
      devid = await (await this.module()).get_serialNumber();
    }
    if (devid == YAPI_INVALID_STRING) {
      return new Uint8Array(0);
    }
    let yreq = await this._yapi.devRequest(devid, "GET /" + str_path, null, 0);
    if (yreq.errorType != YAPI_SUCCESS) {
      return this._throw(yreq.errorType, yreq.errorMsg, "");
    }
    return yreq.bin_result;
  }
  async _downloadOutOfBand(str_path) {
    let devid = this._serial;
    if (devid == "") {
      devid = await (await this.module()).get_serialNumber();
    }
    if (devid == YAPI_INVALID_STRING) {
      return new Uint8Array(0);
    }
    let yreq = await this._yapi.devRequest(devid, "GET /" + str_path, null, 1);
    if (yreq.errorType != YAPI_SUCCESS) {
      return this._throw(yreq.errorType, yreq.errorMsg, "");
    }
    return yreq.bin_result;
  }
  async _uploadWithProgress(str_path, bin_content, fun_progressCb) {
    let devid = this._serial;
    if (devid == "") {
      devid = await (await this.module()).get_serialNumber();
    }
    if (devid == YAPI_INVALID_STRING) {
      let res = new YHTTPRequest(null);
      res.errorType = this.get_errorType();
      res.errorMsg = this.get_errorMessage();
      return res;
    }
    let httpreq = "POST /upload.html";
    let len = bin_content.length;
    if (typeof bin_content == "string" || bin_content instanceof String) {
      bin_content = this._yapi.imm_str2bin(bin_content);
    } else if (bin_content instanceof Array) {
      bin_content = new Uint8Array(bin_content);
    }
    return this._yapi.devRequest(devid, httpreq, new YHTTPBody(str_path, bin_content, fun_progressCb), 0);
  }
  async _uploadEx(str_path, bin_content) {
    let yreq = await this._uploadWithProgress(str_path, bin_content, null);
    if (yreq.errorType != YAPI_SUCCESS) {
      return this._throw(yreq.errorType, yreq.errorMsg, null);
    }
    return yreq.bin_result;
  }
  async _upload(str_path, bin_content) {
    let yreq = await this._uploadWithProgress(str_path, bin_content, null);
    if (yreq.errorType != YAPI_SUCCESS) {
      return this._throw(yreq.errorType, yreq.errorMsg, null);
    }
    return yreq.errorType;
  }
  wait_async(callback, context) {
    let devid = this._serial;
    if (devid == "") {
      this.module().then((module) => module.get_serialNumber().then(() => this.wait_async(callback, context)));
      return YAPI_SUCCESS;
    }
    if (devid == YAPI_INVALID_STRING) {
      callback(context, this);
      return YAPI_SUCCESS;
    }
    let lockdev = this._yapi.imm_getDevice(devid);
    let delayedCode = () => {
      callback(context, this);
    };
    lockdev._pendingQueries = lockdev._pendingQueries.then(delayedCode, delayedCode);
    return YAPI_SUCCESS;
  }
  imm_json_get_key(bin_jsonbuff, str_key) {
    let loadval = JSON.parse(this._yapi.imm_bin2str(bin_jsonbuff));
    if (typeof loadval[str_key] != "undefined") {
      return loadval[str_key];
    }
    return "";
  }
  imm_json_get_string(bin_jsonbuff) {
    return JSON.parse(this._yapi.imm_bin2str(bin_jsonbuff));
  }
  imm_json_get_array(bin_jsonbuff) {
    let loadval = JSON.parse(this._yapi.imm_bin2str(bin_jsonbuff));
    let res = [];
    for (let idx in loadval) {
      res.push(JSON.stringify(loadval[idx]));
    }
    return res;
  }
  imm_get_json_path(str_json, str_path) {
    let json = JSON.parse(str_json);
    let paths = str_path.split("|");
    for (let i = 0; i < paths.length; i++) {
      let tmp = paths[i];
      json = json[tmp];
      if (json == void 0) {
        return "";
      }
    }
    return JSON.stringify(json);
  }
  imm_decode_json_string(str_json) {
    if (str_json === "") {
      return "";
    }
    return JSON.parse(str_json);
  }
  imm_findDataStream(obj_dataset, str_def) {
    let key = obj_dataset.imm_get_functionId() + ":" + str_def;
    if (this._dataStreams[key]) {
      return this._dataStreams[key];
    }
    let words = this._yapi.imm_decodeWords(str_def);
    if (words.length < 14) {
      this._throw(YAPI.VERSION_MISMATCH, "device firwmare is too old", null);
      return null;
    }
    let newDataStream = new YDataStream(this, obj_dataset, words);
    this._dataStreams[key] = newDataStream;
    return newDataStream;
  }
  async clearDataStreamCache() {
    this._dataStreams = {};
  }
  async isOnline() {
    if (this._cacheExpiration > this._yapi.GetTickCount())
      return true;
    let yreq = await this._yapi.funcRequest(this._className, this._func, "", this._yapi.defaultCacheValidity);
    if (yreq.errorType != YAPI_SUCCESS) {
      return yreq.errorType == YAPI_DEVICE_BUSY;
    }
    await this._parse(yreq, this._yapi.defaultCacheValidity);
    return true;
  }
  get_errorType() {
    return this._lastErrorType;
  }
  get_errorMessage() {
    return this._lastErrorMsg;
  }
  async load(msValidity) {
    let yreq = await this._yapi.funcRequest(this._className, this._func, "", msValidity);
    if (yreq.errorType != YAPI_SUCCESS) {
      return this._throw(yreq.errorType, yreq.errorMsg, yreq.errorType);
    }
    await this._parse(yreq, msValidity);
    return YAPI_SUCCESS;
  }
  async clearCache() {
    let devreq = await this._yapi._funcDev(this._className, this._func);
    if (devreq.errorType != YAPI_SUCCESS) {
      return;
    }
    devreq.obj_result.device.imm_dropCache();
    if (this._cacheExpiration > 0) {
      this._cacheExpiration = this._yapi.GetTickCount();
    }
  }
  async module() {
    if (this._serial != "") {
      return YModule.FindModuleInContext(this._yapi, this._serial + ".module");
    }
    let hwid = this._func;
    let resolve;
    if (hwid.indexOf(".") < 0) {
      resolve = this._yapi.imm_resolveFunction(this._className, this._func);
      if (resolve.errorType == YAPI_SUCCESS)
        hwid = resolve.result;
    }
    let dotidx = hwid.indexOf(".");
    if (dotidx >= 0) {
      return YModule.FindModuleInContext(this._yapi, hwid.substr(0, dotidx) + ".module");
    }
    if (await this.load(this._yapi.defaultCacheValidity) == YAPI_SUCCESS) {
      resolve = this._yapi.imm_resolveFunction(this._className, this._func);
      if (resolve.result)
        hwid = resolve.result;
    }
    dotidx = hwid.indexOf(".");
    if (dotidx >= 0) {
      return YModule.FindModuleInContext(this._yapi, hwid.substr(0, dotidx) + ".module");
    }
    return YModule.FindModuleInContext(this._yapi, "module_of_" + this._className + "_" + this._func);
  }
  async get_module() {
    return this.module();
  }
  async get_functionDescriptor() {
    if (this._hwId != "") {
      return this._hwId;
    }
    let hwid = this._func;
    if (hwid.indexOf(".") < 0) {
      let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
      if (resolve.errorType != YAPI_SUCCESS)
        hwid = resolve.result;
    }
    let dotidx = hwid.indexOf(".");
    if (dotidx >= 0) {
      return hwid;
    }
    return Y_FUNCTIONDESCRIPTOR_INVALID;
  }
  async get_userData() {
    return this._userData;
  }
  async set_userData(data) {
    this._userData = data;
  }
};
YFunction.LOGICALNAME_INVALID = YAPI_INVALID_STRING;
YFunction.ADVERTISEDVALUE_INVALID = YAPI_INVALID_STRING;
(function(YFunction2) {
  YFunction2.FUNCTIONDESCRIPTOR_INVALID = YAPI_INVALID_STRING;
  YFunction2.HARDWAREID_INVALID = YAPI_INVALID_STRING;
  YFunction2.FUNCTIONID_INVALID = YAPI_INVALID_STRING;
  YFunction2.FRIENDLYNAME_INVALID = YAPI_INVALID_STRING;
})(YFunction || (YFunction = {}));
var YModule = class extends YFunction {
  constructor(yapi, func) {
    super(yapi, func);
    this._productName = YModule.PRODUCTNAME_INVALID;
    this._serialNumber = YModule.SERIALNUMBER_INVALID;
    this._productId = YModule.PRODUCTID_INVALID;
    this._productRelease = YModule.PRODUCTRELEASE_INVALID;
    this._firmwareRelease = YModule.FIRMWARERELEASE_INVALID;
    this._persistentSettings = YModule.PERSISTENTSETTINGS_INVALID;
    this._luminosity = YModule.LUMINOSITY_INVALID;
    this._beacon = YModule.BEACON_INVALID;
    this._upTime = YModule.UPTIME_INVALID;
    this._usbCurrent = YModule.USBCURRENT_INVALID;
    this._rebootCountdown = YModule.REBOOTCOUNTDOWN_INVALID;
    this._userVar = YModule.USERVAR_INVALID;
    this._valueCallbackModule = null;
    this._logCallback = null;
    this._confChangeCallback = null;
    this._beaconCallback = null;
    this.PRODUCTNAME_INVALID = YAPI_INVALID_STRING;
    this.SERIALNUMBER_INVALID = YAPI_INVALID_STRING;
    this.PRODUCTID_INVALID = YAPI_INVALID_UINT;
    this.PRODUCTRELEASE_INVALID = YAPI_INVALID_UINT;
    this.FIRMWARERELEASE_INVALID = YAPI_INVALID_STRING;
    this.PERSISTENTSETTINGS_LOADED = 0;
    this.PERSISTENTSETTINGS_SAVED = 1;
    this.PERSISTENTSETTINGS_MODIFIED = 2;
    this.PERSISTENTSETTINGS_INVALID = -1;
    this.LUMINOSITY_INVALID = YAPI_INVALID_UINT;
    this.BEACON_OFF = 0;
    this.BEACON_ON = 1;
    this.BEACON_INVALID = -1;
    this.UPTIME_INVALID = YAPI_INVALID_LONG;
    this.USBCURRENT_INVALID = YAPI_INVALID_UINT;
    this.REBOOTCOUNTDOWN_INVALID = YAPI_INVALID_INT;
    this.USERVAR_INVALID = YAPI_INVALID_INT;
    this._className = "Module";
    let devid = this._func;
    let dotidx = devid.indexOf(".");
    if (dotidx > 0)
      devid = devid.substr(0, dotidx);
    let dev = this._yapi.imm_getDevice(devid);
    if (dev) {
      this._serial = dev.imm_getSerialNumber();
      this._funId = "module";
      this._hwId = this._serial + ".module";
    }
  }
  _throw(int_errType, str_errMsg, obj_retVal) {
    this._lastErrorType = int_errType;
    this._lastErrorMsg = str_errMsg;
    return this._yapi._throw(int_errType, str_errMsg, obj_retVal);
  }
  static async _updateModuleCallbackList(YModule_module, bool_add) {
  }
  imm_getDev() {
    let devid = this._func;
    let dotidx = devid.indexOf(".");
    if (dotidx > 0)
      devid = devid.substr(0, dotidx);
    let dev = this._yapi.imm_getDevice(devid);
    if (!dev) {
      this._throw(YAPI_DEVICE_NOT_FOUND, "Device [" + devid + "] is not online", null);
    }
    return dev;
  }
  async forceDeviceRefresh() {
    let dev = this.imm_getDev();
    if (!dev || !this._serial)
      return;
    await this._yapi.ForceDeviceRefresh(this._serial);
    if (this._cacheExpiration > 0) {
      this._cacheExpiration = this._yapi.GetTickCount();
    }
  }
  async functionCount() {
    let dev = this.imm_getDev();
    if (!dev)
      return YAPI_DEVICE_NOT_FOUND;
    return dev.imm_functionCount();
  }
  async functionId(functionIndex) {
    let dev = this.imm_getDev();
    if (!dev)
      return "";
    return dev.imm_functionId(functionIndex);
  }
  async functionType(functionIndex) {
    let dev = this.imm_getDev();
    if (!dev)
      return "";
    return dev.imm_functionType(functionIndex);
  }
  async functionBaseType(functionIndex) {
    let dev = this.imm_getDev();
    if (!dev)
      return "";
    return dev.imm_functionBaseType(functionIndex);
  }
  async functionName(functionIndex) {
    let dev = this.imm_getDev();
    if (!dev)
      return "";
    return dev.imm_functionName(functionIndex);
  }
  async functionValue(functionIndex) {
    let dev = this.imm_getDev();
    if (!dev)
      return "";
    return dev.imm_functionValue(functionIndex);
  }
  async get_logicalName() {
    let dev = this.imm_getDev();
    if (dev != null && this._cache._expiration <= this._yapi.GetTickCount()) {
      return dev.getLogicalName();
    }
    let json_val = await this._getAttr("logicalName");
    return json_val == null ? YModule.LOGICALNAME_INVALID : json_val;
  }
  async set_logicalName(newval) {
    let res = await super.set_logicalName(newval);
    let dev = this.imm_getDev();
    if (dev != null) {
      dev.imm_dropCache();
    }
    return res;
  }
  imm_flattenJsonStruct_internal(jsoncomplex) {
    let decoded = JSON.parse(this._yapi.imm_bin2str(jsoncomplex));
    let attrs = [];
    for (let function_name in decoded) {
      if (function_name == "services") {
        continue;
      }
      let function_attrs = decoded[function_name];
      for (let attr_name in function_attrs) {
        let attr_value = function_attrs[attr_name];
        if (attr_value === null || typeof attr_value === "object") {
          continue;
        }
        let flat = function_name + "/" + attr_name + "=" + attr_value;
        attrs.push(flat);
      }
    }
    return this._yapi.imm_str2bin(JSON.stringify(attrs));
  }
  async get_subDevices_internal() {
    let baseUrl = await this.get_url_internal();
    if (!baseUrl) {
      return [];
    }
    let hub = null;
    let hubUrl = "";
    for (let i = 0; i < this._yapi._connectedHubs.length; i++) {
      hubUrl = this._yapi._connectedHubs[i].urlInfo.rootUrl;
      if (baseUrl.slice(0, hubUrl.length) == hubUrl) {
        hub = this._yapi._connectedHubs[i];
        break;
      }
    }
    if (!hub || !hubUrl) {
      return [];
    }
    let hubSerial = hub.serialByYdx[0];
    if (hubSerial != this._serial) {
      return [];
    }
    let res = [];
    for (let serial in this._yapi._devs) {
      let rooturl = this._yapi._devs[serial].imm_getRootUrl();
      if (rooturl.substr(0, hubUrl.length) == hubUrl && serial != hubSerial) {
        res.push(serial);
      }
    }
    return res;
  }
  async get_parentHub_internal() {
    let baseUrl = await this.get_url_internal();
    if (!baseUrl) {
      return "";
    }
    let hub = null;
    for (let i = 0; i < this._yapi._connectedHubs.length; i++) {
      let hubUrl = this._yapi._connectedHubs[i].urlInfo.rootUrl;
      if (baseUrl.slice(0, hubUrl.length) == hubUrl) {
        hub = this._yapi._connectedHubs[i];
        break;
      }
    }
    if (!hub) {
      return "";
    }
    let hubSerial = hub.serialByYdx[0];
    if (hubSerial == this._serial) {
      return "";
    }
    return hubSerial;
  }
  async get_url_internal() {
    let devid = this._serial;
    if (devid == "") {
      devid = await this.get_serialNumber();
    }
    if (devid == YAPI_INVALID_STRING) {
      return "";
    }
    let lockdev = this._yapi.imm_getDevice(devid);
    if (!lockdev) {
      return "";
    }
    return lockdev.imm_getRootUrl();
  }
  async _startStopDevLog_internal(str_serial, bool_start) {
    let dev = this.imm_getDev();
    if (dev != null) {
      return dev.imm_registerLogCallback(this._logCallback);
    }
  }
  imm_parseAttr(name, val) {
    switch (name) {
      case "productName":
        this._productName = val;
        return 1;
      case "serialNumber":
        this._serialNumber = val;
        return 1;
      case "productId":
        this._productId = val;
        return 1;
      case "productRelease":
        this._productRelease = val;
        return 1;
      case "firmwareRelease":
        this._firmwareRelease = val;
        return 1;
      case "persistentSettings":
        this._persistentSettings = val;
        return 1;
      case "luminosity":
        this._luminosity = val;
        return 1;
      case "beacon":
        this._beacon = val;
        return 1;
      case "upTime":
        this._upTime = val;
        return 1;
      case "usbCurrent":
        this._usbCurrent = val;
        return 1;
      case "rebootCountdown":
        this._rebootCountdown = val;
        return 1;
      case "userVar":
        this._userVar = val;
        return 1;
    }
    return super.imm_parseAttr(name, val);
  }
  async get_productName() {
    let res;
    let dev;
    if (this._cacheExpiration == 0) {
      dev = this.imm_getDev();
      if (!(dev == null)) {
        return dev.imm_getProductName();
      }
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YModule.PRODUCTNAME_INVALID;
      }
    }
    res = this._productName;
    return res;
  }
  async get_serialNumber() {
    let res;
    let dev;
    if (this._cacheExpiration == 0) {
      dev = this.imm_getDev();
      if (!(dev == null)) {
        return dev.imm_getSerialNumber();
      }
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YModule.SERIALNUMBER_INVALID;
      }
    }
    res = this._serialNumber;
    return res;
  }
  async get_productId() {
    let res;
    let dev;
    if (this._cacheExpiration == 0) {
      dev = this.imm_getDev();
      if (!(dev == null)) {
        return dev.imm_getProductId();
      }
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YModule.PRODUCTID_INVALID;
      }
    }
    res = this._productId;
    return res;
  }
  async get_productRelease() {
    let res;
    if (this._cacheExpiration == 0) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YModule.PRODUCTRELEASE_INVALID;
      }
    }
    res = this._productRelease;
    return res;
  }
  async get_firmwareRelease() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YModule.FIRMWARERELEASE_INVALID;
      }
    }
    res = this._firmwareRelease;
    return res;
  }
  async get_persistentSettings() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YModule.PERSISTENTSETTINGS_INVALID;
      }
    }
    res = this._persistentSettings;
    return res;
  }
  async set_persistentSettings(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("persistentSettings", rest_val);
  }
  async get_luminosity() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YModule.LUMINOSITY_INVALID;
      }
    }
    res = this._luminosity;
    return res;
  }
  async set_luminosity(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("luminosity", rest_val);
  }
  async get_beacon() {
    let res;
    let dev;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      dev = this.imm_getDev();
      if (!(dev == null)) {
        return dev.imm_getBeacon();
      }
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YModule.BEACON_INVALID;
      }
    }
    res = this._beacon;
    return res;
  }
  async set_beacon(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("beacon", rest_val);
  }
  async get_upTime() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YModule.UPTIME_INVALID;
      }
    }
    res = this._upTime;
    return res;
  }
  async get_usbCurrent() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YModule.USBCURRENT_INVALID;
      }
    }
    res = this._usbCurrent;
    return res;
  }
  async get_rebootCountdown() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YModule.REBOOTCOUNTDOWN_INVALID;
      }
    }
    res = this._rebootCountdown;
    return res;
  }
  async set_rebootCountdown(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("rebootCountdown", rest_val);
  }
  async get_userVar() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YModule.USERVAR_INVALID;
      }
    }
    res = this._userVar;
    return res;
  }
  async set_userVar(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("userVar", rest_val);
  }
  static FindModule(func) {
    let obj;
    let cleanHwId;
    let modpos;
    cleanHwId = func;
    modpos = func.indexOf(".module");
    if (modpos != func.length - 7) {
      cleanHwId = func + ".module";
    }
    obj = YFunction._FindFromCache("Module", cleanHwId);
    if (obj == null) {
      obj = new YModule(YAPI, cleanHwId);
      YFunction._AddToCache("Module", cleanHwId, obj);
    }
    return obj;
  }
  static FindModuleInContext(yctx, func) {
    let obj;
    let cleanHwId;
    let modpos;
    cleanHwId = func;
    modpos = func.indexOf(".module");
    if (modpos != func.length - 7) {
      cleanHwId = func + ".module";
    }
    obj = YFunction._FindFromCacheInContext(yctx, "Module", cleanHwId);
    if (obj == null) {
      obj = new YModule(yctx, cleanHwId);
      YFunction._AddToCache("Module", cleanHwId, obj);
    }
    return obj;
  }
  async registerValueCallback(callback) {
    let val;
    if (callback != null) {
      await YFunction._UpdateValueCallbackList(this, true);
    } else {
      await YFunction._UpdateValueCallbackList(this, false);
    }
    this._valueCallbackModule = callback;
    if (callback != null && await this.isOnline()) {
      val = this._advertisedValue;
      if (!(val == "")) {
        await this._invokeValueCallback(val);
      }
    }
    return 0;
  }
  async _invokeValueCallback(value) {
    if (this._valueCallbackModule != null) {
      try {
        await this._valueCallbackModule(this, value);
      } catch (e) {
        this._yapi.imm_log("Exception in valueCallback:", e);
      }
    } else {
      await super._invokeValueCallback(value);
    }
    return 0;
  }
  async get_productNameAndRevision() {
    let prodname;
    let prodrel;
    let fullname;
    prodname = await this.get_productName();
    prodrel = await this.get_productRelease();
    if (prodrel > 1) {
      fullname = prodname + " rev. " + String.fromCharCode(64 + prodrel);
    } else {
      fullname = prodname;
    }
    return fullname;
  }
  async saveToFlash() {
    return await this.set_persistentSettings(1);
  }
  async revertFromFlash() {
    return await this.set_persistentSettings(0);
  }
  async reboot(secBeforeReboot) {
    return await this.set_rebootCountdown(secBeforeReboot);
  }
  async triggerFirmwareUpdate(secBeforeReboot) {
    return await this.set_rebootCountdown(-secBeforeReboot);
  }
  async _startStopDevLog(serial, start) {
    return await this._startStopDevLog_internal(serial, start);
  }
  async registerLogCallback(callback) {
    let serial;
    serial = await this.get_serialNumber();
    if (serial == YAPI_INVALID_STRING) {
      return YAPI_DEVICE_NOT_FOUND;
    }
    this._logCallback = callback;
    await this._startStopDevLog(serial, callback != null);
    return 0;
  }
  async get_logCallback() {
    return this._logCallback;
  }
  async registerConfigChangeCallback(callback) {
    if (callback != null) {
      await YModule._updateModuleCallbackList(this, true);
    } else {
      await YModule._updateModuleCallbackList(this, false);
    }
    this._confChangeCallback = callback;
    return 0;
  }
  async _invokeConfigChangeCallback() {
    if (this._confChangeCallback != null) {
      try {
        await this._confChangeCallback(this);
      } catch (e) {
        this._yapi.imm_log("Exception in configChangeCallback:", e);
      }
    }
    return 0;
  }
  async registerBeaconCallback(callback) {
    if (callback != null) {
      await YModule._updateModuleCallbackList(this, true);
    } else {
      await YModule._updateModuleCallbackList(this, false);
    }
    this._beaconCallback = callback;
    return 0;
  }
  async _invokeBeaconCallback(beaconState) {
    if (this._beaconCallback != null) {
      try {
        await this._beaconCallback(this, beaconState);
      } catch (e) {
        this._yapi.imm_log("Exception in beaconCallback:", e);
      }
    }
    return 0;
  }
  async triggerConfigChangeCallback() {
    await this._setAttr("persistentSettings", "2");
    return 0;
  }
  async checkFirmware(path, onlynew) {
    let serial;
    let release;
    let tmp_res;
    if (onlynew) {
      release = YAPIContext.imm_atoi(await this.get_firmwareRelease());
    } else {
      release = 0;
    }
    serial = await this.get_serialNumber();
    tmp_res = await YFirmwareUpdate.CheckFirmware(serial, path, release);
    if (tmp_res.indexOf("error:") == 0) {
      this._throw(YAPI_INVALID_ARGUMENT, tmp_res);
    }
    return tmp_res;
  }
  async updateFirmwareEx(path, force) {
    let serial;
    let settings;
    serial = await this.get_serialNumber();
    settings = await this.get_allSettings();
    if (settings.length == 0) {
      this._throw(YAPI_IO_ERROR, "Unable to get device settings");
      settings = this._yapi.imm_str2bin("error:Unable to get device settings");
    }
    return new YFirmwareUpdate(this._yapi, serial, path, settings, force);
  }
  async updateFirmware(path) {
    return await this.updateFirmwareEx(path, false);
  }
  async get_allSettings() {
    let settings;
    let json;
    let res;
    let sep;
    let name;
    let item;
    let t_type;
    let id;
    let url;
    let file_data;
    let file_data_bin;
    let temp_data_bin;
    let ext_settings;
    let filelist = [];
    let templist = [];
    settings = await this._download("api.json");
    if (settings.length == 0) {
      return settings;
    }
    ext_settings = ', "extras":[';
    templist = await this.get_functionIds("Temperature");
    sep = "";
    for (let ii in templist) {
      if (YAPIContext.imm_atoi(await this.get_firmwareRelease()) > 9e3) {
        url = "api/" + templist[ii] + "/sensorType";
        t_type = this._yapi.imm_bin2str(await this._download(url));
        if (t_type == "RES_NTC" || t_type == "RES_LINEAR") {
          id = templist[ii].substr(11, templist[ii].length - 11);
          if (id == "") {
            id = "1";
          }
          temp_data_bin = await this._download("extra.json?page=" + id);
          if (temp_data_bin.length > 0) {
            item = sep + '{"fid":"' + templist[ii] + '", "json":' + this._yapi.imm_bin2str(temp_data_bin) + "}\n";
            ext_settings = ext_settings + item;
            sep = ",";
          }
        }
      }
    }
    ext_settings = ext_settings + '],\n"files":[';
    if (await this.hasFunction("files")) {
      json = await this._download("files.json?a=dir&f=");
      if (json.length == 0) {
        return json;
      }
      filelist = this.imm_json_get_array(json);
      sep = "";
      for (let ii in filelist) {
        name = this.imm_json_get_key(this._yapi.imm_str2bin(filelist[ii]), "name");
        if (name.length > 0 && !(name == "startupConf.json")) {
          file_data_bin = await this._download(this.imm_escapeAttr(name));
          file_data = this._yapi.imm_bin2hexstr(file_data_bin);
          item = sep + '{"name":"' + name + '", "data":"' + file_data + '"}\n';
          ext_settings = ext_settings + item;
          sep = ",";
        }
      }
    }
    res = this._yapi.imm_str2bin('{ "api":' + this._yapi.imm_bin2str(settings) + ext_settings + "]}");
    return res;
  }
  async loadThermistorExtra(funcId, jsonExtra) {
    let values = [];
    let url;
    let curr;
    let currTemp;
    let ofs;
    let size;
    url = "api/" + funcId + ".json?command=Z";
    await this._download(url);
    values = this.imm_json_get_array(this._yapi.imm_str2bin(jsonExtra));
    ofs = 0;
    size = values.length;
    while (ofs + 1 < size) {
      curr = values[ofs];
      currTemp = values[ofs + 1];
      url = "api/" + funcId + ".json?command=m" + curr + ":" + currTemp;
      await this._download(url);
      ofs = ofs + 2;
    }
    return YAPI_SUCCESS;
  }
  async set_extraSettings(jsonExtra) {
    let extras = [];
    let functionId;
    let data;
    extras = this.imm_json_get_array(this._yapi.imm_str2bin(jsonExtra));
    for (let ii in extras) {
      functionId = this.imm_get_json_path(extras[ii], "fid");
      functionId = this.imm_decode_json_string(functionId);
      data = this.imm_get_json_path(extras[ii], "json");
      if (await this.hasFunction(functionId)) {
        await this.loadThermistorExtra(functionId, data);
      }
    }
    return YAPI_SUCCESS;
  }
  async set_allSettingsAndFiles(settings) {
    let down;
    let json;
    let json_api;
    let json_files;
    let json_extra;
    let fuperror;
    let globalres;
    fuperror = 0;
    json = this._yapi.imm_bin2str(settings);
    json_api = this.imm_get_json_path(json, "api");
    if (json_api == "") {
      return await this.set_allSettings(settings);
    }
    json_extra = this.imm_get_json_path(json, "extras");
    if (!(json_extra == "")) {
      await this.set_extraSettings(json_extra);
    }
    await this.set_allSettings(this._yapi.imm_str2bin(json_api));
    if (await this.hasFunction("files")) {
      let files = [];
      let res;
      let name;
      let data;
      down = await this._download("files.json?a=format");
      res = this.imm_get_json_path(this._yapi.imm_bin2str(down), "res");
      res = this.imm_decode_json_string(res);
      if (!(res == "ok")) {
        return this._throw(YAPI_IO_ERROR, "format failed", YAPI_IO_ERROR);
      }
      json_files = this.imm_get_json_path(json, "files");
      files = this.imm_json_get_array(this._yapi.imm_str2bin(json_files));
      for (let ii in files) {
        name = this.imm_get_json_path(files[ii], "name");
        name = this.imm_decode_json_string(name);
        data = this.imm_get_json_path(files[ii], "data");
        data = this.imm_decode_json_string(data);
        if (name == "") {
          fuperror = fuperror + 1;
        } else {
          await this._upload(name, this._yapi.imm_hexstr2bin(data));
        }
      }
    }
    globalres = await this.set_allSettings(this._yapi.imm_str2bin(json_api));
    if (!(fuperror == 0)) {
      return this._throw(YAPI_IO_ERROR, "Error during file upload", YAPI_IO_ERROR);
    }
    return globalres;
  }
  async hasFunction(funcId) {
    let count;
    let i;
    let fid;
    count = await this.functionCount();
    i = 0;
    while (i < count) {
      fid = await this.functionId(i);
      if (fid == funcId) {
        return true;
      }
      i = i + 1;
    }
    return false;
  }
  async get_functionIds(funType) {
    let count;
    let i;
    let ftype;
    let res = [];
    count = await this.functionCount();
    i = 0;
    while (i < count) {
      ftype = await this.functionType(i);
      if (ftype == funType) {
        res.push(await this.functionId(i));
      } else {
        ftype = await this.functionBaseType(i);
        if (ftype == funType) {
          res.push(await this.functionId(i));
        }
      }
      i = i + 1;
    }
    return res;
  }
  imm_flattenJsonStruct(jsoncomplex) {
    return this.imm_flattenJsonStruct_internal(jsoncomplex);
  }
  async calibVersion(cparams) {
    if (cparams == "0,") {
      return 3;
    }
    if (cparams.indexOf(",") >= 0) {
      if (cparams.indexOf(" ") > 0) {
        return 3;
      } else {
        return 1;
      }
    }
    if (cparams == "" || cparams == "0") {
      return 1;
    }
    if (cparams.length < 2 || cparams.indexOf(".") >= 0) {
      return 0;
    } else {
      return 2;
    }
  }
  async calibScale(unit_name, sensorType) {
    if (unit_name == "g" || unit_name == "gauss" || unit_name == "W") {
      return 1e3;
    }
    if (unit_name == "C") {
      if (sensorType == "") {
        return 16;
      }
      if (YAPIContext.imm_atoi(sensorType) < 8) {
        return 16;
      } else {
        return 100;
      }
    }
    if (unit_name == "m" || unit_name == "deg") {
      return 10;
    }
    return 1;
  }
  async calibOffset(unit_name) {
    if (unit_name == "% RH" || unit_name == "mbar" || unit_name == "lx") {
      return 0;
    }
    return 32767;
  }
  async calibConvert(param, currentFuncValue, unit_name, sensorType) {
    let paramVer;
    let funVer;
    let funScale;
    let funOffset;
    let paramScale;
    let paramOffset;
    let words = [];
    let words_str = [];
    let calibData = [];
    let iCalib = [];
    let calibType;
    let i;
    let maxSize;
    let ratio;
    let nPoints;
    let wordVal;
    paramVer = await this.calibVersion(param);
    funVer = await this.calibVersion(currentFuncValue);
    funScale = await this.calibScale(unit_name, sensorType);
    funOffset = await this.calibOffset(unit_name);
    paramScale = funScale;
    paramOffset = funOffset;
    if (funVer < 3) {
      if (funVer == 2) {
        words = this._yapi.imm_decodeWords(currentFuncValue);
        if (words[0] == 1366 && words[1] == 12500) {
          funScale = 1;
          funOffset = 0;
        } else {
          funScale = words[1];
          funOffset = words[0];
        }
      } else {
        if (funVer == 1) {
          if (currentFuncValue == "" || YAPIContext.imm_atoi(currentFuncValue) > 10) {
            funScale = 0;
          }
        }
      }
    }
    calibData.length = 0;
    calibType = 0;
    if (paramVer < 3) {
      if (paramVer == 2) {
        words = this._yapi.imm_decodeWords(param);
        if (words[0] == 1366 && words[1] == 12500) {
          paramScale = 1;
          paramOffset = 0;
        } else {
          paramScale = words[1];
          paramOffset = words[0];
        }
        if (words.length >= 3 && words[2] > 0) {
          maxSize = 3 + 2 * (words[2] % 10);
          if (maxSize > words.length) {
            maxSize = words.length;
          }
          i = 3;
          while (i < maxSize) {
            calibData.push(words[i]);
            i = i + 1;
          }
        }
      } else {
        if (paramVer == 1) {
          words_str = param.split(",");
          for (let ii in words_str) {
            words.push(YAPIContext.imm_atoi(words_str[ii]));
          }
          if (param == "" || words[0] > 10) {
            paramScale = 0;
          }
          if (words.length > 0 && words[0] > 0) {
            maxSize = 1 + 2 * (words[0] % 10);
            if (maxSize > words.length) {
              maxSize = words.length;
            }
            i = 1;
            while (i < maxSize) {
              calibData.push(words[i]);
              i = i + 1;
            }
          }
        } else {
          if (paramVer == 0) {
            ratio = parseFloat(param);
            if (ratio > 0) {
              calibData.push(0);
              calibData.push(0);
              calibData.push(Math.round(65535 / ratio));
              calibData.push(65535);
            }
          }
        }
      }
      i = 0;
      while (i < calibData.length) {
        if (paramScale > 0) {
          calibData[i] = (calibData[i] - paramOffset) / paramScale;
        } else {
          calibData[i] = this._yapi.imm_decimalToDouble(Math.round(calibData[i]));
        }
        i = i + 1;
      }
    } else {
      iCalib = this._yapi.imm_decodeFloats(param);
      calibType = Math.round(iCalib[0] / 1e3);
      if (calibType >= 30) {
        calibType = calibType - 30;
      }
      i = 1;
      while (i < iCalib.length) {
        calibData.push(iCalib[i] / 1e3);
        i = i + 1;
      }
    }
    if (funVer >= 3) {
      if (calibData.length == 0) {
        param = "0,";
      } else {
        param = (30 + calibType).toString();
        i = 0;
        while (i < calibData.length) {
          if ((i & 1) > 0) {
            param = param + ":";
          } else {
            param = param + " ";
          }
          param = param + Math.round(calibData[i] * 1e3 / 1e3).toString();
          i = i + 1;
        }
        param = param + ",";
      }
    } else {
      if (funVer >= 1) {
        nPoints = calibData.length / 2 >> 0;
        param = nPoints.toString();
        i = 0;
        while (i < 2 * nPoints) {
          if (funScale == 0) {
            wordVal = this._yapi.imm_doubleToDecimal(Math.round(calibData[i]));
          } else {
            wordVal = calibData[i] * funScale + funOffset;
          }
          param = param + "," + Math.round(wordVal).toString();
          i = i + 1;
        }
      } else {
        if (calibData.length == 4) {
          param = Math.round(1e3 * (calibData[3] - calibData[1]) / calibData[2] - calibData[0]).toString();
        }
      }
    }
    return param;
  }
  async _tryExec(url) {
    let res;
    let done;
    res = YAPI_SUCCESS;
    done = 1;
    try {
      await this._download(url);
    } catch (e) {
      done = 0;
    }
    if (done == 0) {
      try {
        await YAPI.Sleep(500);
        await this._download(url);
      } catch (e) {
        res = await this.get_errorType();
      }
    }
    return res;
  }
  async set_allSettings(settings) {
    let restoreLast = [];
    let old_json_flat;
    let old_dslist = [];
    let old_jpath = [];
    let old_jpath_len = [];
    let old_val_arr = [];
    let actualSettings;
    let new_dslist = [];
    let new_jpath = [];
    let new_jpath_len = [];
    let new_val_arr = [];
    let cpos;
    let eqpos;
    let leng;
    let i;
    let j;
    let subres;
    let res;
    let njpath;
    let jpath;
    let fun;
    let attr;
    let value;
    let url;
    let tmp;
    let new_calib;
    let sensorType;
    let unit_name;
    let newval;
    let oldval;
    let old_calib;
    let each_str;
    let do_update;
    let found;
    res = YAPI_SUCCESS;
    tmp = this._yapi.imm_bin2str(settings);
    tmp = this.imm_get_json_path(tmp, "api");
    if (!(tmp == "")) {
      settings = this._yapi.imm_str2bin(tmp);
    }
    oldval = "";
    newval = "";
    old_json_flat = this.imm_flattenJsonStruct(settings);
    old_dslist = this.imm_json_get_array(old_json_flat);
    for (let ii in old_dslist) {
      each_str = this.imm_json_get_string(this._yapi.imm_str2bin(old_dslist[ii]));
      leng = each_str.length;
      eqpos = each_str.indexOf("=");
      if (eqpos < 0 || leng == 0) {
        this._throw(YAPI_INVALID_ARGUMENT, "Invalid settings");
        return YAPI_INVALID_ARGUMENT;
      }
      jpath = each_str.substr(0, eqpos);
      eqpos = eqpos + 1;
      value = each_str.substr(eqpos, leng - eqpos);
      old_jpath.push(jpath);
      old_jpath_len.push(jpath.length);
      old_val_arr.push(value);
    }
    try {
      actualSettings = await this._download("api.json");
    } catch (e) {
      await YAPI.Sleep(500);
      actualSettings = await this._download("api.json");
    }
    actualSettings = this.imm_flattenJsonStruct(actualSettings);
    new_dslist = this.imm_json_get_array(actualSettings);
    for (let ii in new_dslist) {
      each_str = this.imm_json_get_string(this._yapi.imm_str2bin(new_dslist[ii]));
      leng = each_str.length;
      eqpos = each_str.indexOf("=");
      if (eqpos < 0 || leng == 0) {
        this._throw(YAPI_INVALID_ARGUMENT, "Invalid settings");
        return YAPI_INVALID_ARGUMENT;
      }
      jpath = each_str.substr(0, eqpos);
      eqpos = eqpos + 1;
      value = each_str.substr(eqpos, leng - eqpos);
      new_jpath.push(jpath);
      new_jpath_len.push(jpath.length);
      new_val_arr.push(value);
    }
    i = 0;
    while (i < new_jpath.length) {
      njpath = new_jpath[i];
      leng = njpath.length;
      cpos = njpath.indexOf("/");
      if (cpos < 0 || leng == 0) {
        continue;
      }
      fun = njpath.substr(0, cpos);
      cpos = cpos + 1;
      attr = njpath.substr(cpos, leng - cpos);
      do_update = true;
      if (fun == "services") {
        do_update = false;
      }
      if (do_update && attr == "firmwareRelease") {
        do_update = false;
      }
      if (do_update && attr == "usbCurrent") {
        do_update = false;
      }
      if (do_update && attr == "upTime") {
        do_update = false;
      }
      if (do_update && attr == "persistentSettings") {
        do_update = false;
      }
      if (do_update && attr == "adminPassword") {
        do_update = false;
      }
      if (do_update && attr == "userPassword") {
        do_update = false;
      }
      if (do_update && attr == "rebootCountdown") {
        do_update = false;
      }
      if (do_update && attr == "advertisedValue") {
        do_update = false;
      }
      if (do_update && attr == "poeCurrent") {
        do_update = false;
      }
      if (do_update && attr == "readiness") {
        do_update = false;
      }
      if (do_update && attr == "ipAddress") {
        do_update = false;
      }
      if (do_update && attr == "subnetMask") {
        do_update = false;
      }
      if (do_update && attr == "router") {
        do_update = false;
      }
      if (do_update && attr == "linkQuality") {
        do_update = false;
      }
      if (do_update && attr == "ssid") {
        do_update = false;
      }
      if (do_update && attr == "channel") {
        do_update = false;
      }
      if (do_update && attr == "security") {
        do_update = false;
      }
      if (do_update && attr == "message") {
        do_update = false;
      }
      if (do_update && attr == "signalValue") {
        do_update = false;
      }
      if (do_update && attr == "currentValue") {
        do_update = false;
      }
      if (do_update && attr == "currentRawValue") {
        do_update = false;
      }
      if (do_update && attr == "currentRunIndex") {
        do_update = false;
      }
      if (do_update && attr == "pulseTimer") {
        do_update = false;
      }
      if (do_update && attr == "lastTimePressed") {
        do_update = false;
      }
      if (do_update && attr == "lastTimeReleased") {
        do_update = false;
      }
      if (do_update && attr == "filesCount") {
        do_update = false;
      }
      if (do_update && attr == "freeSpace") {
        do_update = false;
      }
      if (do_update && attr == "timeUTC") {
        do_update = false;
      }
      if (do_update && attr == "rtcTime") {
        do_update = false;
      }
      if (do_update && attr == "unixTime") {
        do_update = false;
      }
      if (do_update && attr == "dateTime") {
        do_update = false;
      }
      if (do_update && attr == "rawValue") {
        do_update = false;
      }
      if (do_update && attr == "lastMsg") {
        do_update = false;
      }
      if (do_update && attr == "delayedPulseTimer") {
        do_update = false;
      }
      if (do_update && attr == "rxCount") {
        do_update = false;
      }
      if (do_update && attr == "txCount") {
        do_update = false;
      }
      if (do_update && attr == "msgCount") {
        do_update = false;
      }
      if (do_update && attr == "rxMsgCount") {
        do_update = false;
      }
      if (do_update && attr == "txMsgCount") {
        do_update = false;
      }
      if (do_update) {
        do_update = false;
        newval = new_val_arr[i];
        j = 0;
        found = false;
        while (j < old_jpath.length && !found) {
          if (new_jpath_len[i] == old_jpath_len[j] && new_jpath[i] == old_jpath[j]) {
            found = true;
            oldval = old_val_arr[j];
            if (!(newval == oldval)) {
              do_update = true;
            }
          }
          j = j + 1;
        }
      }
      if (do_update) {
        if (attr == "calibrationParam") {
          old_calib = "";
          unit_name = "";
          sensorType = "";
          new_calib = newval;
          j = 0;
          found = false;
          while (j < old_jpath.length && !found) {
            if (new_jpath_len[i] == old_jpath_len[j] && new_jpath[i] == old_jpath[j]) {
              found = true;
              old_calib = old_val_arr[j];
            }
            j = j + 1;
          }
          tmp = fun + "/unit";
          j = 0;
          found = false;
          while (j < new_jpath.length && !found) {
            if (tmp == new_jpath[j]) {
              found = true;
              unit_name = new_val_arr[j];
            }
            j = j + 1;
          }
          tmp = fun + "/sensorType";
          j = 0;
          found = false;
          while (j < new_jpath.length && !found) {
            if (tmp == new_jpath[j]) {
              found = true;
              sensorType = new_val_arr[j];
            }
            j = j + 1;
          }
          newval = await this.calibConvert(old_calib, new_val_arr[i], unit_name, sensorType);
          url = "api/" + fun + ".json?" + attr + "=" + this.imm_escapeAttr(newval);
          subres = await this._tryExec(url);
          if (res == YAPI_SUCCESS && subres != YAPI_SUCCESS) {
            res = subres;
          }
        } else {
          url = "api/" + fun + ".json?" + attr + "=" + this.imm_escapeAttr(oldval);
          if (attr == "resolution") {
            restoreLast.push(url);
          } else {
            subres = await this._tryExec(url);
            if (res == YAPI_SUCCESS && subres != YAPI_SUCCESS) {
              res = subres;
            }
          }
        }
      }
      i = i + 1;
    }
    for (let ii in restoreLast) {
      subres = await this._tryExec(restoreLast[ii]);
      if (res == YAPI_SUCCESS && subres != YAPI_SUCCESS) {
        res = subres;
      }
    }
    await this.clearCache();
    return res;
  }
  async addFileToHTTPCallback(filename) {
    let content;
    content = await this._download("@YCB+" + filename);
    if (content.length == 0) {
      return YAPI_NOT_SUPPORTED;
    }
    return YAPI_SUCCESS;
  }
  async get_hardwareId() {
    let serial;
    serial = await this.get_serialNumber();
    return serial + ".module";
  }
  async download(pathname) {
    return await this._download(pathname);
  }
  async get_icon2d() {
    return await this._download("icon2d.png");
  }
  async get_lastLogs() {
    let content;
    content = await this._download("logs.txt");
    return this._yapi.imm_bin2str(content);
  }
  async log(text) {
    return await this._upload("logs.txt", this._yapi.imm_str2bin(text));
  }
  async get_subDevices() {
    return await this.get_subDevices_internal();
  }
  async get_parentHub() {
    return await this.get_parentHub_internal();
  }
  async get_url() {
    return await this.get_url_internal();
  }
  nextModule() {
    let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
    if (resolve.errorType != YAPI.SUCCESS)
      return null;
    let next_hwid = this._yapi.imm_getNextHardwareId(this._className, resolve.result);
    if (next_hwid == null)
      return null;
    return YModule.FindModuleInContext(this._yapi, next_hwid);
  }
  static FirstModule() {
    let next_hwid = YAPI.imm_getFirstHardwareId("Module");
    if (next_hwid == null)
      return null;
    return YModule.FindModule(next_hwid);
  }
  static FirstModuleInContext(yctx) {
    let next_hwid = yctx.imm_getFirstHardwareId("Module");
    if (next_hwid == null)
      return null;
    return YModule.FindModuleInContext(yctx, next_hwid);
  }
};
YModule.PRODUCTNAME_INVALID = YAPI_INVALID_STRING;
YModule.SERIALNUMBER_INVALID = YAPI_INVALID_STRING;
YModule.PRODUCTID_INVALID = YAPI_INVALID_UINT;
YModule.PRODUCTRELEASE_INVALID = YAPI_INVALID_UINT;
YModule.FIRMWARERELEASE_INVALID = YAPI_INVALID_STRING;
YModule.PERSISTENTSETTINGS_LOADED = 0;
YModule.PERSISTENTSETTINGS_SAVED = 1;
YModule.PERSISTENTSETTINGS_MODIFIED = 2;
YModule.PERSISTENTSETTINGS_INVALID = -1;
YModule.LUMINOSITY_INVALID = YAPI_INVALID_UINT;
YModule.BEACON_OFF = 0;
YModule.BEACON_ON = 1;
YModule.BEACON_INVALID = -1;
YModule.UPTIME_INVALID = YAPI_INVALID_LONG;
YModule.USBCURRENT_INVALID = YAPI_INVALID_UINT;
YModule.REBOOTCOUNTDOWN_INVALID = YAPI_INVALID_INT;
YModule.USERVAR_INVALID = YAPI_INVALID_INT;
var YSensor = class extends YFunction {
  constructor(yapi, func) {
    super(yapi, func);
    this._unit = YSensor.UNIT_INVALID;
    this._currentValue = YSensor.CURRENTVALUE_INVALID;
    this._lowestValue = YSensor.LOWESTVALUE_INVALID;
    this._highestValue = YSensor.HIGHESTVALUE_INVALID;
    this._currentRawValue = YSensor.CURRENTRAWVALUE_INVALID;
    this._logFrequency = YSensor.LOGFREQUENCY_INVALID;
    this._reportFrequency = YSensor.REPORTFREQUENCY_INVALID;
    this._advMode = YSensor.ADVMODE_INVALID;
    this._calibrationParam = YSensor.CALIBRATIONPARAM_INVALID;
    this._resolution = YSensor.RESOLUTION_INVALID;
    this._sensorState = YSensor.SENSORSTATE_INVALID;
    this._valueCallbackSensor = null;
    this._timedReportCallbackSensor = null;
    this._prevTimedReport = 0;
    this._iresol = 0;
    this._offset = 0;
    this._scale = 0;
    this._decexp = 0;
    this._caltyp = 0;
    this._calpar = [];
    this._calraw = [];
    this._calref = [];
    this.imm_calhdl = null;
    this.UNIT_INVALID = YAPI_INVALID_STRING;
    this.CURRENTVALUE_INVALID = YAPI_INVALID_DOUBLE;
    this.LOWESTVALUE_INVALID = YAPI_INVALID_DOUBLE;
    this.HIGHESTVALUE_INVALID = YAPI_INVALID_DOUBLE;
    this.CURRENTRAWVALUE_INVALID = YAPI_INVALID_DOUBLE;
    this.LOGFREQUENCY_INVALID = YAPI_INVALID_STRING;
    this.REPORTFREQUENCY_INVALID = YAPI_INVALID_STRING;
    this.ADVMODE_IMMEDIATE = 0;
    this.ADVMODE_PERIOD_AVG = 1;
    this.ADVMODE_PERIOD_MIN = 2;
    this.ADVMODE_PERIOD_MAX = 3;
    this.ADVMODE_INVALID = -1;
    this.CALIBRATIONPARAM_INVALID = YAPI_INVALID_STRING;
    this.RESOLUTION_INVALID = YAPI_INVALID_DOUBLE;
    this.SENSORSTATE_INVALID = YAPI_INVALID_INT;
    this._className = "Sensor";
  }
  imm_parseAttr(name, val) {
    switch (name) {
      case "unit":
        this._unit = val;
        return 1;
      case "currentValue":
        this._currentValue = Math.round(val / 65.536) / 1e3;
        return 1;
      case "lowestValue":
        this._lowestValue = Math.round(val / 65.536) / 1e3;
        return 1;
      case "highestValue":
        this._highestValue = Math.round(val / 65.536) / 1e3;
        return 1;
      case "currentRawValue":
        this._currentRawValue = Math.round(val / 65.536) / 1e3;
        return 1;
      case "logFrequency":
        this._logFrequency = val;
        return 1;
      case "reportFrequency":
        this._reportFrequency = val;
        return 1;
      case "advMode":
        this._advMode = val;
        return 1;
      case "calibrationParam":
        this._calibrationParam = val;
        return 1;
      case "resolution":
        this._resolution = Math.round(val / 65.536) / 1e3;
        return 1;
      case "sensorState":
        this._sensorState = val;
        return 1;
    }
    return super.imm_parseAttr(name, val);
  }
  async get_unit() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YSensor.UNIT_INVALID;
      }
    }
    res = this._unit;
    return res;
  }
  async get_currentValue() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YSensor.CURRENTVALUE_INVALID;
      }
    }
    res = await this._applyCalibration(this._currentRawValue);
    if (res == YSensor.CURRENTVALUE_INVALID) {
      res = this._currentValue;
    }
    res = res * this._iresol;
    res = Math.round(res) / this._iresol;
    return res;
  }
  async set_lowestValue(newval) {
    let rest_val;
    rest_val = String(Math.round(newval * 65536));
    return await this._setAttr("lowestValue", rest_val);
  }
  async get_lowestValue() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YSensor.LOWESTVALUE_INVALID;
      }
    }
    res = this._lowestValue * this._iresol;
    res = Math.round(res) / this._iresol;
    return res;
  }
  async set_highestValue(newval) {
    let rest_val;
    rest_val = String(Math.round(newval * 65536));
    return await this._setAttr("highestValue", rest_val);
  }
  async get_highestValue() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YSensor.HIGHESTVALUE_INVALID;
      }
    }
    res = this._highestValue * this._iresol;
    res = Math.round(res) / this._iresol;
    return res;
  }
  async get_currentRawValue() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YSensor.CURRENTRAWVALUE_INVALID;
      }
    }
    res = this._currentRawValue;
    return res;
  }
  async get_logFrequency() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YSensor.LOGFREQUENCY_INVALID;
      }
    }
    res = this._logFrequency;
    return res;
  }
  async set_logFrequency(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("logFrequency", rest_val);
  }
  async get_reportFrequency() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YSensor.REPORTFREQUENCY_INVALID;
      }
    }
    res = this._reportFrequency;
    return res;
  }
  async set_reportFrequency(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("reportFrequency", rest_val);
  }
  async get_advMode() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YSensor.ADVMODE_INVALID;
      }
    }
    res = this._advMode;
    return res;
  }
  async set_advMode(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("advMode", rest_val);
  }
  async get_calibrationParam() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YSensor.CALIBRATIONPARAM_INVALID;
      }
    }
    res = this._calibrationParam;
    return res;
  }
  async set_calibrationParam(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("calibrationParam", rest_val);
  }
  async set_resolution(newval) {
    let rest_val;
    rest_val = String(Math.round(newval * 65536));
    return await this._setAttr("resolution", rest_val);
  }
  async get_resolution() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YSensor.RESOLUTION_INVALID;
      }
    }
    res = this._resolution;
    return res;
  }
  async get_sensorState() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YSensor.SENSORSTATE_INVALID;
      }
    }
    res = this._sensorState;
    return res;
  }
  static FindSensor(func) {
    let obj;
    obj = YFunction._FindFromCache("Sensor", func);
    if (obj == null) {
      obj = new YSensor(YAPI, func);
      YFunction._AddToCache("Sensor", func, obj);
    }
    return obj;
  }
  static FindSensorInContext(yctx, func) {
    let obj;
    obj = YFunction._FindFromCacheInContext(yctx, "Sensor", func);
    if (obj == null) {
      obj = new YSensor(yctx, func);
      YFunction._AddToCache("Sensor", func, obj);
    }
    return obj;
  }
  async registerValueCallback(callback) {
    let val;
    if (callback != null) {
      await YFunction._UpdateValueCallbackList(this, true);
    } else {
      await YFunction._UpdateValueCallbackList(this, false);
    }
    this._valueCallbackSensor = callback;
    if (callback != null && await this.isOnline()) {
      val = this._advertisedValue;
      if (!(val == "")) {
        await this._invokeValueCallback(val);
      }
    }
    return 0;
  }
  async _invokeValueCallback(value) {
    if (this._valueCallbackSensor != null) {
      try {
        await this._valueCallbackSensor(this, value);
      } catch (e) {
        this._yapi.imm_log("Exception in valueCallback:", e);
      }
    } else {
      await super._invokeValueCallback(value);
    }
    return 0;
  }
  async _parserHelper() {
    let position;
    let maxpos;
    let iCalib = [];
    let iRaw;
    let iRef;
    let fRaw;
    let fRef;
    this._caltyp = -1;
    this._scale = -1;
    this._calpar.length = 0;
    this._calraw.length = 0;
    this._calref.length = 0;
    if (this._resolution > 0) {
      this._iresol = Math.round(1 / this._resolution);
    } else {
      this._iresol = 1e4;
      this._resolution = 1e-4;
    }
    if (this._calibrationParam == "" || this._calibrationParam == "0") {
      this._caltyp = 0;
      return 0;
    }
    if (this._calibrationParam.indexOf(",") >= 0) {
      iCalib = this._yapi.imm_decodeFloats(this._calibrationParam);
      this._caltyp = iCalib[0] / 1e3 >> 0;
      if (this._caltyp > 0) {
        if (this._caltyp < YOCTO_CALIB_TYPE_OFS) {
          this._caltyp = -1;
          return 0;
        }
        this.imm_calhdl = this._yapi.imm_getCalibrationHandler(this._caltyp);
        if (!(this.imm_calhdl != null)) {
          this._caltyp = -1;
          return 0;
        }
      }
      this._offset = 0;
      this._scale = 1e3;
      maxpos = iCalib.length;
      this._calpar.length = 0;
      position = 1;
      while (position < maxpos) {
        this._calpar.push(iCalib[position]);
        position = position + 1;
      }
      this._calraw.length = 0;
      this._calref.length = 0;
      position = 1;
      while (position + 1 < maxpos) {
        fRaw = iCalib[position];
        fRaw = fRaw / 1e3;
        fRef = iCalib[position + 1];
        fRef = fRef / 1e3;
        this._calraw.push(fRaw);
        this._calref.push(fRef);
        position = position + 2;
      }
    } else {
      iCalib = this._yapi.imm_decodeWords(this._calibrationParam);
      if (iCalib.length < 2) {
        this._caltyp = -1;
        return 0;
      }
      this._offset = 0;
      this._scale = 1;
      this._decexp = 1;
      position = iCalib[0];
      while (position > 0) {
        this._decexp = this._decexp * 10;
        position = position - 1;
      }
      if (iCalib.length == 2) {
        this._caltyp = 0;
        return 0;
      }
      this._caltyp = iCalib[2];
      this.imm_calhdl = this._yapi.imm_getCalibrationHandler(this._caltyp);
      if (this._caltyp <= 10) {
        maxpos = this._caltyp;
      } else {
        if (this._caltyp <= 20) {
          maxpos = this._caltyp - 10;
        } else {
          maxpos = 5;
        }
      }
      maxpos = 3 + 2 * maxpos;
      if (maxpos > iCalib.length) {
        maxpos = iCalib.length;
      }
      this._calpar.length = 0;
      this._calraw.length = 0;
      this._calref.length = 0;
      position = 3;
      while (position + 1 < maxpos) {
        iRaw = iCalib[position];
        iRef = iCalib[position + 1];
        this._calpar.push(iRaw);
        this._calpar.push(iRef);
        this._calraw.push(this._yapi.imm_decimalToDouble(iRaw));
        this._calref.push(this._yapi.imm_decimalToDouble(iRef));
        position = position + 2;
      }
    }
    return 0;
  }
  async isSensorReady() {
    if (!await this.isOnline()) {
      return false;
    }
    if (!(this._sensorState == 0)) {
      return false;
    }
    return true;
  }
  async get_dataLogger() {
    let logger;
    let modu;
    let serial;
    let hwid;
    modu = await this.get_module();
    serial = await modu.get_serialNumber();
    if (serial == YAPI_INVALID_STRING) {
      return null;
    }
    hwid = serial + ".dataLogger";
    logger = YDataLogger.FindDataLogger(hwid);
    return logger;
  }
  async startDataLogger() {
    let res;
    res = await this._download("api/dataLogger/recording?recording=1");
    if (!(res.length > 0)) {
      return this._throw(YAPI_IO_ERROR, "unable to start datalogger", YAPI_IO_ERROR);
    }
    return YAPI_SUCCESS;
  }
  async stopDataLogger() {
    let res;
    res = await this._download("api/dataLogger/recording?recording=0");
    if (!(res.length > 0)) {
      return this._throw(YAPI_IO_ERROR, "unable to stop datalogger", YAPI_IO_ERROR);
    }
    return YAPI_SUCCESS;
  }
  async get_recordedData(startTime, endTime) {
    let funcid;
    let funit;
    funcid = await this.get_functionId();
    funit = await this.get_unit();
    return new YDataSet(this, funcid, funit, startTime, endTime);
  }
  async registerTimedReportCallback(callback) {
    let sensor;
    sensor = this;
    if (callback != null) {
      await YFunction._UpdateTimedReportCallbackList(sensor, true);
    } else {
      await YFunction._UpdateTimedReportCallbackList(sensor, false);
    }
    this._timedReportCallbackSensor = callback;
    return 0;
  }
  async _invokeTimedReportCallback(value) {
    if (this._timedReportCallbackSensor != null) {
      try {
        await this._timedReportCallbackSensor(this, value);
      } catch (e) {
        this._yapi.imm_log("Exception in timedReportCallback:", e);
      }
    } else {
    }
    return 0;
  }
  async calibrateFromPoints(rawValues, refValues) {
    let rest_val;
    let res;
    rest_val = await this._encodeCalibrationPoints(rawValues, refValues);
    res = await this._setAttr("calibrationParam", rest_val);
    return res;
  }
  async loadCalibrationPoints(rawValues, refValues) {
    rawValues.length = 0;
    refValues.length = 0;
    if (this._scale == 0) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YAPI_DEVICE_NOT_FOUND;
      }
    }
    if (this._caltyp < 0) {
      this._throw(YAPI_NOT_SUPPORTED, "Calibration parameters format mismatch. Please upgrade your library or firmware.");
      return YAPI_NOT_SUPPORTED;
    }
    rawValues.length = 0;
    refValues.length = 0;
    for (let ii in this._calraw) {
      rawValues.push(this._calraw[ii]);
    }
    for (let ii in this._calref) {
      refValues.push(this._calref[ii]);
    }
    return YAPI_SUCCESS;
  }
  async _encodeCalibrationPoints(rawValues, refValues) {
    let res;
    let npt;
    let idx;
    npt = rawValues.length;
    if (npt != refValues.length) {
      this._throw(YAPI_INVALID_ARGUMENT, "Invalid calibration parameters (size mismatch)");
      return YAPI_INVALID_STRING;
    }
    if (npt == 0) {
      return "0";
    }
    if (this._scale == 0) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YAPI_INVALID_STRING;
      }
    }
    if (this._caltyp < 0 || this._scale < 0) {
      this._throw(YAPI_NOT_SUPPORTED, "Calibration parameters format mismatch. Please upgrade your library or firmware.");
      return "0";
    }
    res = String(Math.round(YOCTO_CALIB_TYPE_OFS));
    idx = 0;
    while (idx < npt) {
      res = res + "," + String(Math.round(rawValues[idx] * 1e3) / 1e3) + "," + String(Math.round(refValues[idx] * 1e3) / 1e3);
      idx = idx + 1;
    }
    return res;
  }
  async _applyCalibration(rawValue) {
    if (rawValue == YSensor.CURRENTVALUE_INVALID) {
      return YSensor.CURRENTVALUE_INVALID;
    }
    if (this._caltyp == 0) {
      return rawValue;
    }
    if (this._caltyp < 0) {
      return YSensor.CURRENTVALUE_INVALID;
    }
    if (!(this.imm_calhdl != null)) {
      return YSensor.CURRENTVALUE_INVALID;
    }
    return this.imm_calhdl(rawValue, this._caltyp, this._calpar, this._calraw, this._calref);
  }
  async _decodeTimedReport(timestamp, duration, report) {
    let i;
    let byteVal;
    let poww;
    let minRaw;
    let avgRaw;
    let maxRaw;
    let sublen;
    let difRaw;
    let startTime;
    let endTime;
    let minVal;
    let avgVal;
    let maxVal;
    if (duration > 0) {
      startTime = timestamp - duration;
    } else {
      startTime = this._prevTimedReport;
    }
    endTime = timestamp;
    this._prevTimedReport = endTime;
    if (startTime == 0) {
      startTime = endTime;
    }
    if (report.length <= 5) {
      poww = 1;
      avgRaw = 0;
      byteVal = 0;
      i = 1;
      while (i < report.length) {
        byteVal = report[i];
        avgRaw = avgRaw + poww * byteVal;
        poww = poww * 256;
        i = i + 1;
      }
      if ((byteVal & 128) != 0) {
        avgRaw = avgRaw - poww;
      }
      avgVal = avgRaw / 1e3;
      if (this._caltyp != 0) {
        if (this.imm_calhdl != null) {
          avgVal = this.imm_calhdl(avgVal, this._caltyp, this._calpar, this._calraw, this._calref);
        }
      }
      minVal = avgVal;
      maxVal = avgVal;
    } else {
      sublen = 1 + (report[1] & 3);
      poww = 1;
      avgRaw = 0;
      byteVal = 0;
      i = 2;
      while (sublen > 0 && i < report.length) {
        byteVal = report[i];
        avgRaw = avgRaw + poww * byteVal;
        poww = poww * 256;
        i = i + 1;
        sublen = sublen - 1;
      }
      if ((byteVal & 128) != 0) {
        avgRaw = avgRaw - poww;
      }
      sublen = 1 + (report[1] >> 2 & 3);
      poww = 1;
      difRaw = 0;
      while (sublen > 0 && i < report.length) {
        byteVal = report[i];
        difRaw = difRaw + poww * byteVal;
        poww = poww * 256;
        i = i + 1;
        sublen = sublen - 1;
      }
      minRaw = avgRaw - difRaw;
      sublen = 1 + (report[1] >> 4 & 3);
      poww = 1;
      difRaw = 0;
      while (sublen > 0 && i < report.length) {
        byteVal = report[i];
        difRaw = difRaw + poww * byteVal;
        poww = poww * 256;
        i = i + 1;
        sublen = sublen - 1;
      }
      maxRaw = avgRaw + difRaw;
      avgVal = avgRaw / 1e3;
      minVal = minRaw / 1e3;
      maxVal = maxRaw / 1e3;
      if (this._caltyp != 0) {
        if (this.imm_calhdl != null) {
          avgVal = this.imm_calhdl(avgVal, this._caltyp, this._calpar, this._calraw, this._calref);
          minVal = this.imm_calhdl(minVal, this._caltyp, this._calpar, this._calraw, this._calref);
          maxVal = this.imm_calhdl(maxVal, this._caltyp, this._calpar, this._calraw, this._calref);
        }
      }
    }
    return new YMeasure(startTime, endTime, minVal, avgVal, maxVal);
  }
  imm_decodeVal(w) {
    let val;
    val = w;
    if (this._caltyp != 0) {
      if (this.imm_calhdl != null) {
        val = this.imm_calhdl(val, this._caltyp, this._calpar, this._calraw, this._calref);
      }
    }
    return val;
  }
  imm_decodeAvg(dw) {
    let val;
    val = dw;
    if (this._caltyp != 0) {
      if (this.imm_calhdl != null) {
        val = this.imm_calhdl(val, this._caltyp, this._calpar, this._calraw, this._calref);
      }
    }
    return val;
  }
  nextSensor() {
    let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
    if (resolve.errorType != YAPI.SUCCESS)
      return null;
    let next_hwid = this._yapi.imm_getNextHardwareId(this._className, resolve.result);
    if (next_hwid == null)
      return null;
    return YSensor.FindSensorInContext(this._yapi, next_hwid);
  }
  static FirstSensor() {
    let next_hwid = YAPI.imm_getFirstHardwareId("Sensor");
    if (next_hwid == null)
      return null;
    return YSensor.FindSensor(next_hwid);
  }
  static FirstSensorInContext(yctx) {
    let next_hwid = yctx.imm_getFirstHardwareId("Sensor");
    if (next_hwid == null)
      return null;
    return YSensor.FindSensorInContext(yctx, next_hwid);
  }
};
YSensor.UNIT_INVALID = YAPI_INVALID_STRING;
YSensor.CURRENTVALUE_INVALID = YAPI_INVALID_DOUBLE;
YSensor.LOWESTVALUE_INVALID = YAPI_INVALID_DOUBLE;
YSensor.HIGHESTVALUE_INVALID = YAPI_INVALID_DOUBLE;
YSensor.CURRENTRAWVALUE_INVALID = YAPI_INVALID_DOUBLE;
YSensor.LOGFREQUENCY_INVALID = YAPI_INVALID_STRING;
YSensor.REPORTFREQUENCY_INVALID = YAPI_INVALID_STRING;
YSensor.ADVMODE_IMMEDIATE = 0;
YSensor.ADVMODE_PERIOD_AVG = 1;
YSensor.ADVMODE_PERIOD_MIN = 2;
YSensor.ADVMODE_PERIOD_MAX = 3;
YSensor.ADVMODE_INVALID = -1;
YSensor.CALIBRATIONPARAM_INVALID = YAPI_INVALID_STRING;
YSensor.RESOLUTION_INVALID = YAPI_INVALID_DOUBLE;
YSensor.SENSORSTATE_INVALID = YAPI_INVALID_INT;
var YMeasure = class {
  constructor(float_start, float_end, float_minVal, float_avgVal, float_maxVal) {
    this._start = 0;
    this._end = 0;
    this._minVal = 0;
    this._avgVal = 0;
    this._maxVal = 0;
    this._start = float_start;
    this._end = float_end;
    this._minVal = float_minVal;
    this._avgVal = float_avgVal;
    this._maxVal = float_maxVal;
  }
  get_startTimeUTC() {
    return this._start;
  }
  get_endTimeUTC() {
    return this._end;
  }
  get_minValue() {
    return this._minVal;
  }
  get_averageValue() {
    return this._avgVal;
  }
  get_maxValue() {
    return this._maxVal;
  }
  get_startTimeUTC_asDate() {
    return new Date(Math.round(this._start * 1e3));
  }
  get_endTimeUTC_asDate() {
    return new Date(Math.round(this._end * 1e3));
  }
};
var YDataLogger = class extends YFunction {
  constructor(yapi, func) {
    super(yapi, func);
    this._currentRunIndex = YDataLogger.CURRENTRUNINDEX_INVALID;
    this._timeUTC = YDataLogger.TIMEUTC_INVALID;
    this._recording = YDataLogger.RECORDING_INVALID;
    this._autoStart = YDataLogger.AUTOSTART_INVALID;
    this._beaconDriven = YDataLogger.BEACONDRIVEN_INVALID;
    this._usage = YDataLogger.USAGE_INVALID;
    this._clearHistory = YDataLogger.CLEARHISTORY_INVALID;
    this._valueCallbackDataLogger = null;
    this.CURRENTRUNINDEX_INVALID = YAPI_INVALID_UINT;
    this.TIMEUTC_INVALID = YAPI_INVALID_LONG;
    this.RECORDING_OFF = 0;
    this.RECORDING_ON = 1;
    this.RECORDING_PENDING = 2;
    this.RECORDING_INVALID = -1;
    this.AUTOSTART_OFF = 0;
    this.AUTOSTART_ON = 1;
    this.AUTOSTART_INVALID = -1;
    this.BEACONDRIVEN_OFF = 0;
    this.BEACONDRIVEN_ON = 1;
    this.BEACONDRIVEN_INVALID = -1;
    this.USAGE_INVALID = YAPI_INVALID_UINT;
    this.CLEARHISTORY_FALSE = 0;
    this.CLEARHISTORY_TRUE = 1;
    this.CLEARHISTORY_INVALID = -1;
    this._className = "DataLogger";
  }
  imm_parseAttr(name, val) {
    switch (name) {
      case "currentRunIndex":
        this._currentRunIndex = val;
        return 1;
      case "timeUTC":
        this._timeUTC = val;
        return 1;
      case "recording":
        this._recording = val;
        return 1;
      case "autoStart":
        this._autoStart = val;
        return 1;
      case "beaconDriven":
        this._beaconDriven = val;
        return 1;
      case "usage":
        this._usage = val;
        return 1;
      case "clearHistory":
        this._clearHistory = val;
        return 1;
    }
    return super.imm_parseAttr(name, val);
  }
  async get_currentRunIndex() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YDataLogger.CURRENTRUNINDEX_INVALID;
      }
    }
    res = this._currentRunIndex;
    return res;
  }
  async get_timeUTC() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YDataLogger.TIMEUTC_INVALID;
      }
    }
    res = this._timeUTC;
    return res;
  }
  async set_timeUTC(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("timeUTC", rest_val);
  }
  async get_recording() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YDataLogger.RECORDING_INVALID;
      }
    }
    res = this._recording;
    return res;
  }
  async set_recording(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("recording", rest_val);
  }
  async get_autoStart() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YDataLogger.AUTOSTART_INVALID;
      }
    }
    res = this._autoStart;
    return res;
  }
  async set_autoStart(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("autoStart", rest_val);
  }
  async get_beaconDriven() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YDataLogger.BEACONDRIVEN_INVALID;
      }
    }
    res = this._beaconDriven;
    return res;
  }
  async set_beaconDriven(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("beaconDriven", rest_val);
  }
  async get_usage() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YDataLogger.USAGE_INVALID;
      }
    }
    res = this._usage;
    return res;
  }
  async get_clearHistory() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YDataLogger.CLEARHISTORY_INVALID;
      }
    }
    res = this._clearHistory;
    return res;
  }
  async set_clearHistory(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("clearHistory", rest_val);
  }
  static FindDataLogger(func) {
    let obj;
    obj = YFunction._FindFromCache("DataLogger", func);
    if (obj == null) {
      obj = new YDataLogger(YAPI, func);
      YFunction._AddToCache("DataLogger", func, obj);
    }
    return obj;
  }
  static FindDataLoggerInContext(yctx, func) {
    let obj;
    obj = YFunction._FindFromCacheInContext(yctx, "DataLogger", func);
    if (obj == null) {
      obj = new YDataLogger(yctx, func);
      YFunction._AddToCache("DataLogger", func, obj);
    }
    return obj;
  }
  async registerValueCallback(callback) {
    let val;
    if (callback != null) {
      await YFunction._UpdateValueCallbackList(this, true);
    } else {
      await YFunction._UpdateValueCallbackList(this, false);
    }
    this._valueCallbackDataLogger = callback;
    if (callback != null && await this.isOnline()) {
      val = this._advertisedValue;
      if (!(val == "")) {
        await this._invokeValueCallback(val);
      }
    }
    return 0;
  }
  async _invokeValueCallback(value) {
    if (this._valueCallbackDataLogger != null) {
      try {
        await this._valueCallbackDataLogger(this, value);
      } catch (e) {
        this._yapi.imm_log("Exception in valueCallback:", e);
      }
    } else {
      await super._invokeValueCallback(value);
    }
    return 0;
  }
  async forgetAllDataStreams() {
    return await this.set_clearHistory(1);
  }
  async get_dataSets() {
    return await this.parse_dataSets(await this._download("logger.json"));
  }
  async parse_dataSets(json) {
    let dslist = [];
    let dataset;
    let res = [];
    dslist = this.imm_json_get_array(json);
    res.length = 0;
    for (let ii in dslist) {
      dataset = new YDataSet(this);
      await dataset._parse(dslist[ii]);
      res.push(dataset);
    }
    return res;
  }
  nextDataLogger() {
    let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
    if (resolve.errorType != YAPI.SUCCESS)
      return null;
    let next_hwid = this._yapi.imm_getNextHardwareId(this._className, resolve.result);
    if (next_hwid == null)
      return null;
    return YDataLogger.FindDataLoggerInContext(this._yapi, next_hwid);
  }
  static FirstDataLogger() {
    let next_hwid = YAPI.imm_getFirstHardwareId("DataLogger");
    if (next_hwid == null)
      return null;
    return YDataLogger.FindDataLogger(next_hwid);
  }
  static FirstDataLoggerInContext(yctx) {
    let next_hwid = yctx.imm_getFirstHardwareId("DataLogger");
    if (next_hwid == null)
      return null;
    return YDataLogger.FindDataLoggerInContext(yctx, next_hwid);
  }
};
YDataLogger.CURRENTRUNINDEX_INVALID = YAPI_INVALID_UINT;
YDataLogger.TIMEUTC_INVALID = YAPI_INVALID_LONG;
YDataLogger.RECORDING_OFF = 0;
YDataLogger.RECORDING_ON = 1;
YDataLogger.RECORDING_PENDING = 2;
YDataLogger.RECORDING_INVALID = -1;
YDataLogger.AUTOSTART_OFF = 0;
YDataLogger.AUTOSTART_ON = 1;
YDataLogger.AUTOSTART_INVALID = -1;
YDataLogger.BEACONDRIVEN_OFF = 0;
YDataLogger.BEACONDRIVEN_ON = 1;
YDataLogger.BEACONDRIVEN_INVALID = -1;
YDataLogger.USAGE_INVALID = YAPI_INVALID_UINT;
YDataLogger.CLEARHISTORY_FALSE = 0;
YDataLogger.CLEARHISTORY_TRUE = 1;
YDataLogger.CLEARHISTORY_INVALID = -1;
var YSystemEnv = class {
  constructor() {
    this.isNodeJS = false;
    this.hasSSDP = false;
  }
  unknownSystemEnvError() {
    return new YoctoError("Unspecified runtime environment, your project should include at least once either yocto_api_nodejs or yocto_api_html");
  }
  hookUnhandledRejection(handler) {
    throw this.unknownSystemEnvError();
  }
  getWebSocketHub(obj_yapi, urlInfo) {
    throw this.unknownSystemEnvError();
  }
  getHttpHub(obj_yapi, urlInfo) {
    throw this.unknownSystemEnvError();
  }
  getWebSocketCallbackHub(obj_yapi, urlInfo, ws) {
    throw this.unknownSystemEnvError();
  }
  getHttpCallbackHub(yapi, urlInfo, incomingMessage, serverResponse) {
    throw this.unknownSystemEnvError();
  }
  getSSDPManager(obj_yapi) {
    throw this.unknownSystemEnvError();
  }
  async loadfile(file) {
    throw this.unknownSystemEnvError();
  }
  async downloadfile(url) {
    throw this.unknownSystemEnvError();
  }
};
var _UnspecifiedSystemEnv = new YSystemEnv();
var YGenericHub = class {
  constructor(yapi, urlInfo) {
    this._lastErrorType = YAPI_IO_ERROR;
    this._lastErrorMsg = "Hub attachment has not been triggered";
    this.hubSerial = "";
    this.serialByYdx = [];
    this._currentState = -6;
    this._targetState = -5;
    this.currentConnID = "";
    this.connResolvers = [];
    this.disconnResolvers = [];
    this.retryDelay = 15;
    this._reconnectionTimer = null;
    this._rwAccess = null;
    this.keepTryingExpiration = 0;
    this.keepTryingTimeoutId = null;
    this.timeoutId = null;
    this.lastPingStamp = 0;
    this.isNotifWorking = false;
    this.devListExpires = 0;
    this.notifPos = -1;
    this.notifCarryOver = "";
    this.missing = {};
    this._firstArrivalCallback = true;
    this._missing = {};
    this._knownUrls = [];
    this._yapi = yapi;
    this.urlInfo = urlInfo;
    this.stalledTimeoutMs = yapi._networkTimeoutMs;
    this._hubRef = YGenericHub.globalHubRefCounter++;
    this._knownUrls.push(urlInfo.orgUrl);
  }
  _throw(int_errType, str_errMsg, obj_retVal) {
    this._lastErrorType = int_errType;
    this._lastErrorMsg = str_errMsg;
    return this._yapi._throw(int_errType, str_errMsg, obj_retVal);
  }
  get_errorType() {
    return this._lastErrorType;
  }
  get_errorMessage() {
    return this._lastErrorMsg;
  }
  imm_forceUpdate() {
    this.devListExpires = this._yapi.GetTickCount();
  }
  imm_logrequest(method, devUrl, obj_body) {
    let msg = "Request: " + method + " " + devUrl;
    if (obj_body) {
      msg += " (file=" + obj_body.fname + ")";
    }
    this._yapi.imm_log(msg);
  }
  imm_setState(newState) {
    this._currentState = newState;
  }
  imm_setTargetState(newState) {
    this._targetState = newState;
  }
  imm_isDisconnecting() {
    return this._targetState <= -5;
  }
  imm_isDisconnected() {
    return this._targetState <= -5 && this._currentState <= -5;
  }
  imm_isPreOrRegistered() {
    return this._targetState >= 1;
  }
  imm_isOnline() {
    return Date.now() - this.lastPingStamp < this.stalledTimeoutMs;
  }
  imm_isForwarded() {
    return false;
  }
  imm_updateUrl(urlInfo) {
    if (!this._knownUrls.includes(urlInfo.orgUrl)) {
      this._knownUrls.push(urlInfo.orgUrl);
    }
    if (this.urlInfo.authUrl == urlInfo.authUrl) {
      this.urlInfo = urlInfo;
      return;
    }
    this.urlInfo = urlInfo;
    if (this._currentState < -1) {
      if (this._yapi._logLevel >= 4) {
        this._yapi.imm_log("Updating auth credentials for " + this.urlInfo.rootUrl);
      }
    }
  }
  imm_inheritFrom(otherHub) {
    if (this._targetState < otherHub._targetState) {
      this.imm_setTargetState(otherHub._targetState);
    }
    for (let j = 0; j < otherHub.serialByYdx.length; j++) {
      let serial = otherHub.serialByYdx[j];
      if (serial && !this.serialByYdx[j]) {
        this.serialByYdx[j] = serial;
      }
    }
    if (this._currentState >= 0 && otherHub._currentState < 0) {
      let res_struct = {errorType: YAPI_SUCCESS, errorMsg: "Hub " + this.hubSerial + " already connected"};
      let resolvers = otherHub.connResolvers;
      for (let resolveOne of resolvers) {
        resolveOne(res_struct);
      }
    } else {
      for (let resolver of otherHub.connResolvers) {
        this.connResolvers.push(resolver);
      }
    }
    otherHub.connResolvers = [];
    if (this._yapi._logLevel >= 3) {
      this._yapi.imm_log("Hub " + this.hubSerial + " is connected as " + this.urlInfo.rootUrl + ", dropping connection to " + otherHub.urlInfo.rootUrl);
    }
    otherHub.imm_commonDisconnect("inherit", YAPI_SUCCESS, "Hub " + this.hubSerial + " is already connected via " + this.urlInfo.rootUrl);
    otherHub.imm_disconnectNow();
    for (const url of otherHub.get_knownUrls()) {
      if (!this._knownUrls.includes(url)) {
        this._knownUrls.push(url);
      }
    }
  }
  imm_getNewConnID() {
    let time = new Date();
    return (time.getHours() + "h" + time.getMinutes() + "m" + time.getTime() % 6e4 / 1e3).toString() + "_0";
  }
  imm_tryTestConnectFor(mstimeout) {
    let minimalExpiration = Date.now() + mstimeout;
    if (this.keepTryingExpiration < minimalExpiration) {
      this.keepTryingExpiration = minimalExpiration;
      if (this.keepTryingTimeoutId) {
        clearTimeout(this.keepTryingTimeoutId);
      }
      this.keepTryingTimeoutId = setTimeout(() => {
        this.keepTryingTimeoutId = null;
        if (this._targetState == 0) {
          if (this._yapi._logLevel >= 4) {
            this._yapi.imm_log("TestHub timeout reached, disconnecting");
          }
          this.detach(YAPI.IO_ERROR, "TestHub timeout reached");
        }
      }, mstimeout);
    }
  }
  async attach(targetConnType) {
    if (this._targetState <= 0 || targetConnType > 0) {
      this.imm_setTargetState(targetConnType);
      if (this._currentState == 0 && targetConnType > 0) {
        try {
          await this._yapi._ensureUpdateDeviceListNotRunning();
          await this._yapi._addConnectedHub(this);
          this.imm_setState(targetConnType);
        } catch (e) {
          this.imm_disconnectNow();
        }
      }
      if (targetConnType == 0) {
        this.imm_tryTestConnectFor(100);
      }
    }
    if (this._currentState <= -5) {
      this.imm_setState(-1);
      this.reconnect(this.imm_getNewConnID());
    } else if (this._currentState == -3) {
      if (this._reconnectionTimer) {
        if (this._yapi._logLevel >= 4) {
          this._yapi.imm_log("New hub connection requested, retry now (drop [" + this.currentConnID + "])");
        }
        clearTimeout(this._reconnectionTimer);
        this._reconnectionTimer = null;
        this.currentConnID = "";
      } else {
        if (this._yapi._logLevel >= 4) {
          this._yapi.imm_log("New hub connection requested, retry now (no pending reconnection ?!?)");
        }
      }
      this.reconnect(this.imm_getNewConnID());
    } else if (this._currentState == -4 || this._currentState == -2) {
      if (this._yapi._logLevel >= 4) {
        this._yapi.imm_log("Hub is currently disconnecting, reconnection will be triggered soon [" + this.currentConnID + "]");
        this._yapi.imm_log("Current state: " + this._currentState);
        this._yapi.imm_log("Target state: " + this._targetState + " (" + targetConnType + ")");
      }
    }
  }
  async waitForConnection(mstimeout, errmsg) {
    if (this._targetState < 0) {
      errmsg.msg = this._lastErrorMsg;
      return this._lastErrorType;
    }
    if (this._currentState >= 0) {
      return YAPI_SUCCESS;
    }
    if (mstimeout <= 1) {
      errmsg.msg = "Hub not connected";
      return YAPI_TIMEOUT;
    }
    if (this._targetState == 0) {
      this.imm_tryTestConnectFor(mstimeout);
    }
    let connOpenPromise = null;
    let connOpenTimeoutObj = null;
    let addResolverPromise;
    addResolverPromise = new Promise((resolverReady, noResolver) => {
      connOpenPromise = new Promise((resolve, reject) => {
        this.connResolvers.push(resolve);
        resolverReady(resolve);
        connOpenTimeoutObj = setTimeout(() => {
          if (this._yapi._logLevel >= 4) {
            this._yapi.imm_log("Timeout waiting for hub connection");
          }
          resolve({errorType: YAPI_TIMEOUT, errorMsg: "Timeout waiting for hub connection"});
        }, mstimeout);
      });
    });
    let resolver = await addResolverPromise;
    if (this._targetState < 0) {
      clearTimeout(connOpenTimeoutObj);
      errmsg.msg = this._lastErrorMsg;
      return this._lastErrorType;
    }
    if (this._currentState >= 0) {
      clearTimeout(connOpenTimeoutObj);
      return YAPI_SUCCESS;
    }
    let openRes = await connOpenPromise;
    clearTimeout(connOpenTimeoutObj);
    if (openRes.errorType != YAPI_SUCCESS) {
      if (errmsg) {
        errmsg.msg = openRes.errorMsg;
      }
    }
    return openRes.errorType;
  }
  async reconnect(tryOpenID) {
  }
  async signalHubConnected(tryOpenID, hubSerial) {
    this.imm_setState(0);
    this.hubSerial = hubSerial;
    if (this._yapi._logLevel >= 4) {
      this._yapi.imm_log("Hub " + hubSerial + " connected [" + tryOpenID + "]");
    }
    let primaryHub = this._yapi.imm_getPrimaryHub(this);
    if (primaryHub._targetState >= 1) {
      if (primaryHub._currentState < 1) {
        try {
          await primaryHub._yapi._ensureUpdateDeviceListNotRunning();
          await primaryHub._yapi._addConnectedHub(primaryHub);
        } catch (e) {
          primaryHub.imm_disconnectNow();
          return;
        }
      }
      if (primaryHub._currentState < primaryHub._targetState) {
        primaryHub.imm_setState(primaryHub._targetState);
      }
    } else {
      primaryHub.keepTryingExpiration = 0;
      primaryHub.imm_tryTestConnectFor(100);
    }
    let res_struct = {errorType: YAPI_SUCCESS, errorMsg: "Hub " + hubSerial + " connected"};
    let resolvers = primaryHub.connResolvers;
    primaryHub.connResolvers = [];
    primaryHub._lastErrorType = res_struct.errorType;
    primaryHub._lastErrorMsg = res_struct.errorMsg;
    for (let resolveOne of resolvers) {
      resolveOne(res_struct);
    }
  }
  imm_signalHubDisconnected(tryOpenID) {
    if (this._currentState > -3) {
      this.imm_setState(-3);
    }
    this.isNotifWorking = false;
    this.devListExpires = 0;
    this._yapi.imm_dropConnectedHub(this);
    this._firstArrivalCallback = true;
    let resolvers = this.disconnResolvers;
    this.disconnResolvers = [];
    for (let resolveOne of resolvers) {
      resolveOne({errorType: YAPI_SUCCESS, errorMsg: "Hub disconnect completed"});
    }
    if (this.imm_isDisconnecting()) {
      this.imm_setState(-5);
      if (this._yapi._logLevel >= 4) {
        this._yapi.imm_log("Hub " + this.urlInfo.rootUrl + " detached");
      }
      return false;
    }
    if (this._reconnectionTimer) {
      if (this._yapi._logLevel >= 4) {
        this._yapi.imm_log("Hub disconnected, reconnection is already scheduled [" + this.currentConnID + "]");
      }
      return true;
    }
    let openIDwords = tryOpenID.split("_");
    let nextOpenID = openIDwords[0] + "_" + (parseInt(openIDwords[1]) + 1).toString();
    if (this.retryDelay < 5e3)
      this.retryDelay *= 2;
    if (this._yapi._logLevel >= 4) {
      this._yapi.imm_log("Hub reconnection scheduled in " + this.retryDelay / 1e3 + "s [" + nextOpenID + "]");
    }
    this.currentConnID = nextOpenID;
    this._reconnectionTimer = setTimeout(() => {
      this._reconnectionTimer = null;
      this.currentConnID = "";
      if (this.imm_isDisconnecting()) {
        return;
      }
      if (this._yapi._logLevel >= 4) {
        this._yapi.imm_log("Retry hub connection now [" + nextOpenID + "]");
      }
      this.reconnect(nextOpenID);
    }, this.retryDelay);
    return true;
  }
  imm_commonDisconnect(tryOpenID, errType, errMsg) {
    this._lastErrorType = errType;
    this._lastErrorMsg = errMsg;
    if (this._currentState >= -2) {
      this.imm_setState(-4);
    } else if (this._currentState == -3) {
      this.imm_setState(-5);
    }
    this.imm_setTargetState(-5);
    if (this._reconnectionTimer) {
      clearTimeout(this._reconnectionTimer);
      this._reconnectionTimer = null;
    }
    if (this.timeoutId) {
      clearTimeout(this.timeoutId);
      this.timeoutId = null;
    }
    if (errType != YAPI_SUCCESS && this._yapi._logLevel >= 4 && tryOpenID != "detach") {
      this._yapi.imm_log("Hub connection failed: " + errMsg + " [" + tryOpenID + "]");
    }
    this._firstArrivalCallback = true;
    let res_struct = {errorType: errType, errorMsg: errMsg};
    let resolvers = this.connResolvers;
    this.connResolvers = [];
    for (let resolveOne of resolvers) {
      resolveOne(res_struct);
    }
  }
  imm_disconnectNow(connID = "") {
    if (connID && connID != this.currentConnID) {
      return false;
    }
    if (this._currentState > -2) {
      this.imm_setState(-2);
    }
    if (this.timeoutId) {
      clearTimeout(this.timeoutId);
      this.timeoutId = null;
    }
    return true;
  }
  async detach(errType = YAPI.IO_ERROR, errMsg = "Hub has been forcibly detached") {
    this.imm_commonDisconnect("detach", errType, errMsg);
    this.imm_disconnectNow();
  }
  async waitForDisconnection(mstimeout) {
    let disconnPromise = null;
    let disconnTimeoutObj = null;
    disconnPromise = new Promise((resolve, reject) => {
      this.disconnResolvers.push(resolve);
      disconnTimeoutObj = setTimeout(() => {
        if (this._yapi._logLevel >= 4) {
          this._yapi.imm_log("Timeout waiting for hub disconnection");
        }
        resolve({errorType: YAPI_TIMEOUT, errorMsg: "Timeout waiting for hub connection"});
      }, mstimeout);
    });
    await disconnPromise;
    clearTimeout(disconnTimeoutObj);
  }
  async hubUpdateDeviceList() {
    let hubDev = this._yapi.imm_getDevice(this.urlInfo.rootUrl);
    try {
      hubDev.imm_dropCache();
      let retcode = await hubDev.refresh();
      if (retcode != YAPI_SUCCESS) {
        if (this._currentState >= 1) {
          await this._yapi.updateDeviceList_process(this, hubDev, [], {});
        }
        this.imm_disconnectNow();
        return this._throw(retcode, hubDev._lastErrorMsg, retcode);
      }
      let yreq = await hubDev.requestAPI(this._yapi.defaultCacheValidity);
      if (yreq.errorType != YAPI_SUCCESS) {
        if (this._currentState >= 1) {
          await this._yapi.updateDeviceList_process(this, hubDev, [], {});
        }
        this.imm_disconnectNow();
        return yreq.errorType;
      }
      let whitePages = yreq.obj_result.services.whitePages;
      let yellowPages = yreq.obj_result.services.yellowPages;
      if (!whitePages) {
        this.imm_disconnectNow();
        return this._throw(YAPI_IO_ERROR, "Device " + hubDev.imm_describe() + " is not a hub", YAPI_IO_ERROR);
      }
      retcode = await this._yapi.updateDeviceList_process(this, hubDev, whitePages, yellowPages);
      if (retcode < 0) {
        this.imm_disconnectNow();
        return this._throw(this._yapi._lastErrorType, this._yapi._lastErrorMsg, this._yapi._lastErrorType);
      }
      if (this.isNotifWorking) {
        this.devListExpires = this._yapi.GetTickCount() + this._yapi._deviceListValidityMs;
      } else {
        this.devListExpires = this._yapi.GetTickCount() + 500;
      }
      return retcode;
    } catch (e) {
      this._yapi.imm_log("Exception during device enumeration: ", e);
      if (this._currentState >= 1) {
        try {
          await this._yapi.updateDeviceList_process(this, hubDev, [], {});
        } catch (e2) {
        }
      }
      this.imm_disconnectNow();
      return YAPI_IO_ERROR;
    }
  }
  async request(method, devUrl, obj_body, tcpchan) {
    let res = new YHTTPRequest(null);
    res.errorType = YAPI_NOT_SUPPORTED;
    res.errorMsg = "GenericHub subclass expected";
    return res;
  }
  imm_getBoundary() {
    return "Zz" + Math.floor(Math.random() * 16777215).toString(16) + "zZ";
  }
  imm_formEncodeBody(obj_body, str_boundary) {
    let hdr = this._yapi.imm_str2bin('Content-Disposition: form-data; name="' + obj_body.fname + '"; filename="api"\r\nContent-Type: application/octet-stream\r\nContent-Transfer-Encoding: binary\r\n\r\n');
    let boundary = this._yapi.imm_str2bin(str_boundary);
    let dash = this._yapi.imm_str2bin("--");
    let crlf = this._yapi.imm_str2bin("\r\n");
    let parts = [dash, boundary, crlf, hdr, obj_body.data, crlf, dash, boundary, dash, crlf];
    let i, len = 0;
    for (i = 0; i < parts.length; i++) {
      len += parts[i].length;
    }
    let res = new Uint8Array(len);
    len = 0;
    for (i = 0; i < parts.length; i++) {
      res.set(parts[i], len);
      len += parts[i].length;
    }
    return res;
  }
  async getBootloaders() {
    let yreq = await this.request("GET", "/flash.json?a=list", null, 1);
    if (yreq.errorType != YAPI_SUCCESS) {
      return this._throw(yreq.errorType, yreq.errorMsg, []);
    }
    let flashState = JSON.parse(YAPI.imm_bin2str(yreq.bin_result));
    return flashState["list"];
  }
  async firmwareUpdate(serial, firmware, settings, progress) {
    let use_self_flash = false;
    let baseUrl = "";
    let need_reboot = true;
    let _throw = (msg) => {
      return this._throw(YAPI.IO_ERROR, msg, [msg]);
    };
    progress(5, "Check bootloader type");
    let yreq = await this.request("GET", "/api/module.json", null, 0);
    if (yreq.errorType != YAPI_SUCCESS) {
      return _throw("Hub is not responding");
    }
    let json = JSON.parse(this._yapi.imm_bin2str(yreq.bin_result));
    let ownSerial = json.serialNumber;
    if (ownSerial.slice(0, 7) == "VIRTHUB") {
      use_self_flash = false;
    } else if (serial == ownSerial) {
      use_self_flash = true;
    } else {
      yreq = await this.request("GET", "/bySerial/" + serial + "/flash.json?a=state", null, 0);
      if (yreq.errorType == YAPI_SUCCESS && yreq.bin_result.length > 0) {
        use_self_flash = true;
        baseUrl = "/bySerial/" + serial;
      }
    }
    let bootloaders = await this.getBootloaders();
    let is_shield = serial.slice(0, 7) == "YHUBSHL";
    let i;
    for (i = 0; i < bootloaders.length; i++) {
      let bl = bootloaders[i];
      if (bl == serial) {
        need_reboot = false;
      } else if (is_shield) {
        if (bl.slice(0, 7) == "YHUBSHL") {
          return _throw("Only one YoctoHub-Shield is allowed in update mode");
        }
      }
    }
    if (!use_self_flash && need_reboot) {
      if (bootloaders.length >= 4) {
        return _throw("Too many devices in update mode");
      }
    }
    yreq = await this.request("GET", baseUrl + "/flash.json?a=state", null, 0);
    if (yreq.errorType != YAPI_SUCCESS) {
      return _throw("Cannot check state of firmware upload");
    }
    json = JSON.parse(this._yapi.imm_bin2str(yreq.bin_result));
    if (json["state"] == "uploading" || json["state"] == "flashing") {
      return _throw("Cannot start firmware update: busy (" + json["state"] + ")");
    }
    progress(10, "Send firmware file");
    let progressCb = function(curr, total) {
      curr >>= 10;
      total >>= 10;
      progress(10 + (28 * curr / total >> 0), "Send firmware file: " + curr + "KB / " + total + "KB");
    };
    yreq = await this.request("POST", baseUrl + "/upload.html", new YHTTPBody("firmware", firmware.imm_getData(), progressCb), 0);
    if (yreq.errorType != YAPI_SUCCESS) {
      return _throw("Firmware upload failed: " + yreq.errorMsg);
    }
    yreq = await this.request("GET", baseUrl + "/flash.json?a=state", null, 0);
    if (yreq.errorType != YAPI_SUCCESS) {
      return _throw("Cannot check state of firmware upload");
    }
    json = JSON.parse(this._yapi.imm_bin2str(yreq.bin_result));
    if (json["state"] != "valid") {
      return _throw("Upload of firmware failed: invalid firmware(" + json["state"] + ")");
    }
    if (json["progress"] != "100") {
      return _throw("Upload of firmware failed: incomplete upload");
    }
    if (use_self_flash) {
      let settingsStr = this._yapi.imm_bin2str(settings);
      let settingsAndFiles = JSON.parse(settingsStr);
      let settingsOnly = settingsAndFiles["api"];
      let startupApi = {};
      for (let key in settingsOnly) {
        if (key != "services") {
          startupApi[key] = settingsOnly[key];
        }
      }
      let startupConf = this._yapi.imm_str2bin(JSON.stringify(startupApi));
      progress(38, "Save current settings");
      yreq = await this.request("POST", baseUrl + "/upload.html", new YHTTPBody("startupConf.json", startupConf, null), 0);
      if (yreq.errorType != YAPI_SUCCESS) {
        return _throw("Failed to save settings on hub");
      }
      progress(39, "Save current settings");
      yreq = await this.request("POST", baseUrl + "/upload.html", new YHTTPBody("firmwareConf", startupConf, null), 0);
      if (yreq.errorType != YAPI_SUCCESS) {
        return _throw("Failed to save settings on hub");
      }
    }
    if (use_self_flash) {
      progress(40, "Flash firmware");
      await this.request("GET", baseUrl + "/api/module/rebootCountdown?rebootCountdown=-1003", null, 0);
      await this._yapi.Sleep(7e3);
    } else {
      if (need_reboot) {
        await this.request("GET", "/bySerial/" + serial + "/api/module/rebootCountdown?rebootCountdown=-2", null, 0);
      }
      let timeout = YAPI.GetTickCount() + 2e4;
      let res;
      let found = false;
      progress(40, "Wait for device to be in bootloader");
      do {
        bootloaders = await this.getBootloaders();
        for (i = 0; i < bootloaders.length; i++) {
          let bl = bootloaders[i];
          if (bl == serial) {
            found = true;
            break;
          }
        }
        if (!found) {
          await this._yapi.Sleep(500);
        }
      } while (!found && YAPI.GetTickCount() < timeout);
      progress(45, "Flash firmware");
      let fwsize = firmware.imm_getData().length + 512 >> 10;
      let checkTimer;
      let checkFlash = () => {
        this.request("GET", baseUrl + "/flash.json?a=state", null, 1).then((flashReq) => {
          if (flashReq.errorType == YAPI_SUCCESS) {
            let jsonState = YAPI.imm_bin2str(flashReq.bin_result);
            let res2 = JSON.parse(jsonState);
            if (res2.state == "flashing") {
              if (res2.progress < 20) {
                progress(45 + (res2.progress / 3 >> 0), "Erasing previous firmware: " + (fwsize * (res2.progress - 3) / 18 >> 0) + "KB / " + fwsize + "KB");
              } else {
                progress(45 + (res2.progress / 3 >> 0), "Flashing new firmware: " + (fwsize * (res2.progress - 20) / 76 >> 0) + "KB / " + fwsize + "KB");
              }
            }
          }
          checkTimer = setTimeout(checkFlash, 500);
        }).catch((e) => {
          this._yapi.imm_log("Exception during firmware flash: ", e);
          checkTimer = setTimeout(checkFlash, 500);
        });
      };
      checkTimer = setTimeout(checkFlash, 1e3);
      yreq = await this.request("GET", "/flash.json?a=flash&s=" + serial, null, 0);
      clearTimeout(checkTimer);
      if (yreq.errorType != YAPI_SUCCESS) {
        return _throw("Cannot check state of firmware flash");
      }
      return JSON.parse(this._yapi.imm_bin2str(yreq.bin_result));
    }
    return null;
  }
  async reportFailure(message) {
  }
  async hasRwAccess() {
    if (this._rwAccess == null) {
      let yreq = await this.request("GET", "/api/module/serialNumber.json?serialNumber=rwTest", null, 0);
      this._rwAccess = yreq.errorType == YAPI_SUCCESS;
    }
    return this._rwAccess;
  }
  getHubRef() {
    return this._hubRef;
  }
  get_knownUrls() {
    let res = this._knownUrls.slice();
    return res;
  }
  imm_forgetUrls() {
    this._knownUrls = [];
  }
};
YGenericHub.globalHubRefCounter = 0;
var YHttpHub = class extends YGenericHub {
  constructor(yapi, urlInfo) {
    super(yapi, urlInfo);
    this.infoJson = null;
    this.realm = "";
    this.nonce = "";
    this.nonceCount = 0;
    this.notbynRequest = null;
  }
  imm_makeRequest(method, relUrl, contentType, body, onProgress, onSuccess, onError) {
  }
  imm_abortRequest(clientRequest) {
  }
  imm_sendRequest(method, relUrl, obj_body, onProgress, onSuccess, onError) {
    let body = null;
    let contentType = "text/plain; charset=x-user-defined";
    if (this.infoJson && this.infoJson.realm && this.infoJson.nonce) {
      if (this.realm != this.infoJson.realm || this.nonce != this.infoJson.nonce) {
        this.realm = this.infoJson.realm;
        this.nonce = this.infoJson.nonce;
        this.nonceCount = 0;
      }
      let shorturi = "/" + this.urlInfo.domain + relUrl;
      let jsonBody = {
        "x-yauth": {
          method,
          uri: shorturi
        }
      };
      if (this.urlInfo.user || this.urlInfo.pass) {
        let cnonce = Math.floor(Math.random() * 2147483647).toString(16).toLowerCase();
        let nc = (++this.nonceCount).toString(16).toLowerCase();
        let ha1_str = this.urlInfo.user + ":" + this.realm + ":" + this.urlInfo.pass;
        let ha2_str = method + ":" + shorturi;
        let A1 = this._yapi.imm_bin2hexstr(this._yapi.imm_yMD5(ha1_str)).toLowerCase();
        let A2 = this._yapi.imm_bin2hexstr(this._yapi.imm_ySHA1(ha2_str)).toLowerCase();
        let signature = A1 + ":" + this.nonce + ":" + nc + ":" + cnonce + ":auth:" + A2;
        let response = this._yapi.imm_bin2hexstr(this._yapi.imm_ySHA1(signature)).toLowerCase();
        jsonBody["x-yauth"]["username"] = this.urlInfo.user;
        jsonBody["x-yauth"]["cnonce"] = cnonce;
        jsonBody["x-yauth"]["nonce"] = this.nonce;
        jsonBody["x-yauth"]["nc"] = nc;
        jsonBody["x-yauth"]["qop"] = "auth";
        jsonBody["x-yauth"]["response"] = response;
      }
      if (obj_body) {
        let binstr = this._yapi.imm_bin2str(obj_body.data);
        jsonBody["body"] = {
          filename: obj_body.fname,
          b64content: btoa(binstr)
        };
      }
      method = "POST";
      body = JSON.stringify(jsonBody);
      let qpos = relUrl.indexOf("?");
      if (qpos > 0) {
        relUrl = relUrl.slice(0, qpos);
      }
    } else if (obj_body != null) {
      let boundary = this.imm_getBoundary();
      if (this.infoJson && this.infoJson.nonce) {
        contentType = "x-upload; boundary=" + boundary;
      } else {
        contentType = "multipart/form-data; boundary=" + boundary;
      }
      body = this.imm_formEncodeBody(obj_body, boundary);
    }
    return this.imm_makeRequest(method, relUrl, contentType, body, onProgress, onSuccess, onError);
  }
  async tryFetch(relUrl) {
    return new Promise((resolve, reject) => {
      this.imm_sendRequest("GET", relUrl, null, null, (responseText) => {
        resolve({errorType: YAPI_SUCCESS, errorMsg: "", result: responseText});
      }, (errorType, errorMsg) => {
        resolve({errorType, errorMsg});
      });
    });
  }
  async reconnect(tryOpenID) {
    this.currentConnID = tryOpenID;
    if (!this.hubSerial || this.infoJson && this.infoJson.nonce && YAPI.GetTickCount() - this.infoJson.stamp > 12e3) {
      if (this._yapi._logLevel >= 4) {
        this._yapi.imm_log("Trying info.json [" + tryOpenID + "]");
      }
      let res_struct = await this.tryFetch("info.json");
      if (res_struct.errorType == YAPI_SUCCESS && res_struct.result) {
        this.infoJson = JSON.parse(res_struct.result);
        this.infoJson.stamp = YAPI.GetTickCount();
        if (this.infoJson && this.infoJson.serialNumber) {
          this.hubSerial = this.infoJson.serialNumber;
        }
      } else if (res_struct.errorType == YAPI_FILE_NOT_FOUND) {
        res_struct = await this.tryFetch("api/module/serialNumber");
        if (res_struct.errorType == YAPI_SUCCESS && res_struct.result) {
          this.hubSerial = res_struct.result;
        }
      }
      if (!this.hubSerial) {
        if (!super.imm_disconnectNow(tryOpenID)) {
          return;
        }
        if (!this.imm_isDisconnecting()) {
          if (this._yapi._logLevel >= 3) {
            this._yapi.imm_log("Failed to load info.json: " + res_struct.errorMsg + " [" + tryOpenID + "]");
          }
        }
        this._lastErrorType = res_struct.errorType;
        this._lastErrorMsg = res_struct.errorMsg;
        this.currentConnID = "";
        this.imm_signalHubDisconnected(tryOpenID);
        return;
      }
    }
    let primaryHub = this._yapi.imm_getPrimaryHub(this);
    if (primaryHub !== this) {
      this.imm_commonDisconnect(tryOpenID, YAPI_SUCCESS, "Hub " + this.hubSerial + " is already connected");
      this.currentConnID = "";
      this.imm_signalHubDisconnected(tryOpenID);
      return;
    }
    let args = "";
    if (this.notifPos >= 0) {
      args = "?abs=" + this.notifPos.toString();
    } else {
      this._firstArrivalCallback = true;
    }
    if (this._yapi._logLevel >= 4) {
      this._yapi.imm_log("Opening http connection to hub (" + args + ") [" + tryOpenID + "]");
    }
    this.notbynRequest = this.imm_sendRequest("GET", "not.byn" + args, null, (moreText) => {
      if (tryOpenID != this.currentConnID) {
        if (this._yapi._logLevel >= 3) {
          this._yapi.imm_log("Previous request still sending data [" + tryOpenID + "]");
        }
        return;
      }
      if (this.infoJson) {
        this.infoJson.stamp = YAPI.GetTickCount();
      }
      if (this._currentState < 0) {
        this.signalHubConnected(tryOpenID, this.hubSerial);
      }
      this._yapi.parseEvents(this, moreText);
    }, (resultText) => {
      if (tryOpenID != this.currentConnID) {
        if (this._yapi._logLevel >= 3) {
          this._yapi.imm_log("Previous request completed [" + tryOpenID + "]");
        }
        return;
      }
      this.reconnect(tryOpenID);
    }, (errorType, errorMsg) => {
      if (tryOpenID != this.currentConnID) {
        if (this._yapi._logLevel >= 3) {
          this._yapi.imm_log("Previous not.byn request says: " + errorMsg + " [" + tryOpenID + "]");
        }
        return;
      }
      if (!this.imm_isDisconnecting()) {
        if (this._yapi._logLevel >= 3) {
          this._yapi.imm_log("Failed to load not.byn (" + args + "): " + errorMsg + " [" + tryOpenID + "]");
        }
      }
      this._lastErrorType = errorType;
      this._lastErrorMsg = errorMsg;
      if (errorType == YAPI_UNAUTHORIZED) {
        this.imm_commonDisconnect(tryOpenID, errorType, errorMsg);
      }
      this.imm_disconnectNow();
    });
  }
  imm_disconnectNow(connID = "") {
    if (!super.imm_disconnectNow(connID)) {
      return false;
    }
    if (!this.notbynRequest) {
      return false;
    }
    let closeConnID = connID ? connID : this.currentConnID;
    this.imm_abortRequest(this.notbynRequest);
    this.notbynRequest = null;
    this.currentConnID = "";
    this.imm_signalHubDisconnected(closeConnID);
    return true;
  }
  async request(method, devUrl, obj_body, tcpchan) {
    if (this._yapi._logLevel >= 3) {
      this.imm_logrequest(method, devUrl, obj_body);
    }
    if (this._currentState < 0) {
      return new YHTTPRequest(null, YAPI.IO_ERROR, "Hub is currently unavailable");
    }
    return new Promise((resolve, reject) => {
      this.imm_sendRequest(method, devUrl.slice(1), obj_body, null, (responseText) => {
        if (this._currentState < 0) {
          resolve(new YHTTPRequest(null, YAPI.IO_ERROR, "Hub is currently unavailable"));
        } else {
          if (this._yapi._logLevel >= 4) {
            this._yapi.imm_log(method + " " + devUrl + " succeeded");
          }
          resolve(new YHTTPRequest(this._yapi.imm_str2bin(responseText)));
        }
      }, (errorType, errorMsg) => {
        if (this._yapi._logLevel >= 4) {
          this._yapi.imm_log(method + " " + devUrl + " failed (" + errorMsg + ")");
        }
        resolve(new YHTTPRequest(null, errorType, errorMsg));
      });
    });
  }
};
var YWebSocketHub = class extends YGenericHub {
  constructor(yapi, urlInfo) {
    super(yapi, urlInfo);
    this._DEFAULT_TCP_ROUND_TRIP_TIME = 30;
    this._DEFAULT_TCP_MAX_WINDOW_SIZE = 4 * 65536;
    this._YIO_DEFAULT_TCP_TIMEOUT = 2e4;
    this._YIO_1_MINUTE_TCP_TIMEOUT = 6e4;
    this._YIO_10_MINUTES_TCP_TIMEOUT = 6e5;
    this._USB_META_UTCTIME_SIZE = 5;
    this._USB_META_DLFLUSH_SIZE = 1;
    this._USB_META_ACK_D2H_PACKET_SIZE = 2;
    this._USB_META_WS_ANNOUNCE_SIZE = 8 + 20;
    this._USB_META_WS_AUTHENTICATION_SIZE = 28;
    this._USB_META_WS_ERROR_SIZE = 6;
    this._USB_META_ACK_UPLOAD_SIZE = 6;
    this._USB_META_WS_VALID_SHA1 = 1;
    this._USB_META_WS_RW = 2;
    this.websocket = null;
    this.tcpChan = [];
    this.nextAsyncId = 48;
    this._connectionTime = 0;
    this._remoteVersion = 0;
    this._remoteSerial = "";
    this._remoteNonce = -1;
    this._nonce = -1;
    this._session_error = null;
    this._session_errno = null;
    this._lastUploadAckBytes = [0];
    this._lastUploadAckTime = [0];
    this._lastUploadRateBytes = [0];
    this._lastUploadRateTime = [0];
    this._uploadRate = [0];
    this.fwd_nonce = -1;
    this.fwd_websocket = null;
    this.fwd_credentials = [];
    this.fwd_closeCallback = null;
    this._connectionState = 2;
    this._tcpRoundTripTime = this._DEFAULT_TCP_ROUND_TRIP_TIME;
    this._tcpMaxWindowSize = this._DEFAULT_TCP_MAX_WINDOW_SIZE;
    this.fwd_connectionState = 1;
  }
  imm_asyncWebSocketError(errorType, message) {
    this._yapi.imm_log("WS: " + message + " on " + this.urlInfo.rootUrl);
  }
  async reconnect(tryOpenID) {
    this._connectionState = 2;
    if (this._yapi._logLevel >= 4) {
      this._yapi.imm_log("Opening websocket connection [" + tryOpenID + "]");
    }
    this.currentConnID = tryOpenID;
    this.imm_webSocketOpen(this.urlInfo.authUrl + "not.byn");
    this._firstArrivalCallback = true;
    if (!this.websocket) {
      this.imm_commonDisconnect(tryOpenID, YAPI_IO_ERROR, "Failed to create WebSocket");
      return;
    }
    this.websocket.onmessage = (evt) => {
      if (this.currentConnID != tryOpenID) {
        if (this._yapi._logLevel >= 4) {
          this._yapi.imm_log("Incoming WebSocket data for previous connection [" + tryOpenID + "]");
        }
        return;
      }
      this._webSocketMsg(new Uint8Array(evt.data));
      if (this._connectionState == 4) {
        this._connectionState = 5;
        this.signalHubConnected(tryOpenID, this._remoteSerial);
      } else if (this._connectionState == 0) {
        let errMsg = this._session_error ? "WebSocket error: " + this._session_error : "Websocket I/O error";
        if (this._session_errno == 401) {
          this.imm_commonDisconnect(tryOpenID, YAPI_UNAUTHORIZED, errMsg);
        } else {
          this._lastErrorType = YAPI_IO_ERROR;
          this._lastErrorMsg = errMsg;
        }
        this.imm_disconnectNow();
      }
    };
    this.websocket.onclose = (evt) => {
      if (this.currentConnID != tryOpenID) {
        if (this._yapi._logLevel >= 4) {
          this._yapi.imm_log("WebSocket close received for previous connection [" + tryOpenID + "], now using [" + this.currentConnID + "]");
        }
        return;
      }
      if (this._yapi._logLevel >= 4) {
        this._yapi.imm_log("WebSocket connection closed [" + tryOpenID + "]");
      }
      this._connectionState = 1;
      this.websocket = null;
      if (this.retryDelay < 0) {
        this.imm_commonDisconnect(tryOpenID, YAPI_IO_ERROR, "Websocket callback connection closed");
      }
      this.imm_dropAllPendingConnection();
      this.imm_signalHubDisconnected(tryOpenID);
    };
    this.websocket.onerror = (evt) => {
      if (this.currentConnID != tryOpenID) {
        if (this._yapi._logLevel >= 4) {
          this._yapi.imm_log("WebSocket error received for previous connection [" + tryOpenID + "]");
        }
        return;
      }
      if (evt.message && (!/ ETIMEDOUT /.test(evt.message) || this._yapi._logLevel >= 4)) {
        this._yapi.imm_log("WebSocket error [" + tryOpenID + "]: ", evt);
        this._lastErrorType = YAPI_IO_ERROR;
        this._lastErrorMsg = evt.message;
      }
      if (this.retryDelay < 0) {
        this.imm_commonDisconnect(tryOpenID, YAPI_IO_ERROR, "Websocket callback connection closed");
      }
      this.imm_disconnectNow();
      this.imm_signalHubDisconnected(tryOpenID);
    };
    if (this.timeoutId) {
      clearTimeout(this.timeoutId);
    }
    this.timeoutId = setTimeout(() => {
      if (!this.imm_isForwarded()) {
        this._yapi.imm_log("WS: connection stalled during open [" + tryOpenID + "]");
        this.imm_disconnectNow();
      }
    }, this.stalledTimeoutMs);
  }
  imm_computeAuth(user, pass, serial, nonce) {
    let ha1_str = user + ":" + serial + ":" + pass;
    let ha1 = this._yapi.imm_bin2hexstr(this._yapi.imm_yMD5(ha1_str)).toLowerCase();
    let nonce8 = new Uint8Array([(nonce & 255) >>> 0, (nonce & 65280) >>> 8, (nonce & 16711680) >>> 16, nonce >>> 24]);
    let sha1_raw = ha1 + this._yapi.imm_bin2hexstr(nonce8).toLowerCase();
    return this._yapi.imm_ySHA1(sha1_raw.toLowerCase());
  }
  imm_isForwarded() {
    return this.fwd_connectionState == 5 && this.fwd_websocket !== null;
  }
  async _webSocketMsg(arr_bytes) {
    try {
      if (this.imm_isForwarded()) {
        this.lastPingStamp = Date.now();
        this.fwd_websocket.send(arr_bytes);
        return;
      }
      let reltime = (this._yapi.GetTickCount() - this._connectionTime) / 1e3;
      let ystream = arr_bytes[0] >>> 3;
      let text = "";
      if (ystream == 8) {
        for (let i = 1; i < arr_bytes.length; i++) {
          text += String.fromCharCode(arr_bytes[i]);
        }
        await this._yapi.parseEvents(this, text);
        return;
      }
      let ws = this.websocket;
      let tcpchan = arr_bytes[0] & 7;
      if (ystream == 1 || ystream == 2 || ystream == 9) {
        if (tcpchan > 3) {
          this.imm_asyncWebSocketError(YAPI_IO_ERROR, "Unexpected frame for tcpChan " + tcpchan + " (" + ystream + ")");
          return;
        }
        let tcp_end = arr_bytes.length;
        let yreq = this.tcpChan[tcpchan];
        if (!yreq) {
          this.imm_asyncWebSocketError(YAPI_IO_ERROR, "Drop frame for closed tcpChan " + tcpchan + " (" + ystream + ")");
          return;
        }
        if (ystream == 9) {
          tcp_end--;
          let rcvId = arr_bytes[tcp_end];
          if (this._yapi._logLevel >= 5) {
            this._yapi.imm_log("async-" + rcvId + " close received");
          }
          if (yreq.asyncId == 0) {
            if (this._yapi._logLevel >= 4) {
              this._yapi.imm_log("async-" + rcvId + " close received while req @" + yreq._creat + " was pending");
            }
            this.imm_asyncWebSocketError(YAPI_IO_ERROR, "Asynchronous close received, sync reply request");
            return;
          } else if (yreq.asyncId != rcvId) {
            if (this._yapi._logLevel >= 4) {
              this._yapi.imm_log("async-" + rcvId + " close received instead of async-" + yreq.asyncId + " close");
            }
            this.imm_asyncWebSocketError(YAPI_IO_ERROR, "Incorrect async-close signature on tcpChan " + tcpchan);
            return;
          }
        }
        let oldArr = yreq.bin_result;
        let newArr = new Uint8Array(oldArr.length + tcp_end - 1);
        newArr.set(oldArr, 0);
        newArr.set(arr_bytes.subarray(1, tcp_end), oldArr.length);
        yreq.bin_result = newArr;
        if (ystream == 2 || ystream == 9) {
          this.tcpChan[tcpchan] = yreq.next;
          if (ystream == 2) {
            if (yreq.asyncId != 0) {
              if (this._yapi._logLevel >= 4) {
                this._yapi.imm_log("Synchronous close received instead of async-" + yreq.asyncId + " close");
              }
              this.imm_asyncWebSocketError(YAPI_IO_ERROR, "Synchronous close received, async ack expected");
              return;
            } else if (this.websocket) {
              if (yreq.toBeSent && yreq.sendPos < yreq.toBeSent.length) {
                this._yapi.imm_log("WS: tcpclose at " + yreq.sendPos + " < " + yreq.toBeSent.length);
                this.imm_disconnectNow();
                if (yreq.timeoutId) {
                  clearTimeout(yreq.timeoutId);
                }
                if (yreq.asyncId == 0) {
                  yreq.errorType = YAPI_IO_ERROR;
                  yreq.errorMsg = "TCP closed during upload";
                  if (yreq.acceptor) {
                    try {
                      yreq.acceptor(yreq);
                    } catch (e) {
                    }
                  }
                }
                return;
              }
              if (yreq.timeoutId) {
                let frame = new Uint8Array(1);
                frame[0] = (2 << 3) + tcpchan;
                this.websocket.send(frame);
              }
            }
          }
          if (yreq.timeoutId) {
            clearTimeout(yreq.timeoutId);
            yreq.timeoutId = 0;
          }
          let pos = yreq.bin_result.indexOf(13);
          if (pos < 0) {
            yreq.errorType = YAPI_IO_ERROR;
            yreq.errorMsg = "Bad response header";
          } else {
            let header = this._yapi.imm_bin2str(yreq.bin_result.subarray(0, pos));
            let words = header.split(" ");
            if (words[0] == "OK") {
              yreq.errorType = YAPI_SUCCESS;
              let nextpos = yreq.bin_result.indexOf(13, pos + 2);
              while (nextpos > pos + 2) {
                pos = nextpos;
                nextpos = yreq.bin_result.indexOf(13, pos + 2);
              }
              if (nextpos < 0) {
                nextpos = pos;
              }
              yreq.bin_result = yreq.bin_result.subarray(nextpos + 2);
            } else if (words[0] == "0K") {
              yreq.errorType = YAPI_IO_ERROR;
              yreq.errorMsg = "Unexpected persistent connection";
            } else {
              let status = parseInt(words[1]);
              yreq.errorType = status == 401 ? YAPI_UNAUTHORIZED : YAPI_IO_ERROR;
              yreq.errorMsg = "HTTP error " + header.slice(words[0].length + 1) + " on " + yreq.devUrl;
            }
          }
          if (yreq.asyncId == 0) {
            if (this._yapi._logLevel >= 5) {
              this._yapi.imm_log("request @" + yreq._creat + " done, status=" + yreq.errorType);
            }
            this.imm_sendPendingRequest(tcpchan);
            if (yreq.acceptor) {
              yreq.acceptor(yreq);
            }
          } else {
            if (yreq.errorType != YAPI_SUCCESS) {
              this.imm_asyncWebSocketError(YAPI_IO_ERROR, "Async request error: " + yreq.errorMsg);
            }
          }
        }
        return;
      }
      if (!this.websocket) {
        return;
      }
      if (ystream == 5) {
        let metatype = arr_bytes[1];
        switch (metatype) {
          case 4:
            if (arr_bytes.length < 1 + this._USB_META_WS_ANNOUNCE_SIZE) {
              return;
            }
            this._remoteVersion = arr_bytes[2];
            if (this._remoteVersion < 1) {
              return;
            }
            let maxtcpws = (arr_bytes[3] << 4) + (arr_bytes[4] << 12);
            if (maxtcpws > 0) {
              this._tcpMaxWindowSize = maxtcpws;
            }
            this._remoteNonce = arr_bytes[5] + (arr_bytes[6] << 8) + (arr_bytes[7] << 16) + (arr_bytes[8] << 24);
            for (let i = 9; i < 9 + 20; i++) {
              if (arr_bytes[i] == 0) {
                this._remoteSerial = this._yapi.imm_bin2str(arr_bytes.subarray(9, i));
                break;
              }
            }
            let nonce = new Uint8Array(4);
            this.imm_getRandomValues(nonce);
            this._nonce = nonce[0] + (nonce[1] << 8) + (nonce[2] << 16) + (nonce[3] << 24);
            this._connectionTime = this._yapi.GetTickCount();
            this._connectionState = 3;
            let frame = new Uint8Array(1 + this._USB_META_WS_AUTHENTICATION_SIZE);
            let version = this._remoteVersion < 2 ? this._remoteVersion : 2;
            let flags = 0;
            frame[0] = 5 << 3;
            frame[1] = 5;
            frame[2] = version;
            if (this.urlInfo.pass != "") {
              flags = this._USB_META_WS_VALID_SHA1;
              let sha1 = this.imm_computeAuth(this.urlInfo.user, this.urlInfo.pass, this._remoteSerial, this._remoteNonce);
              for (let i = 0; i < sha1.length; i++) {
                frame[9 + i] = sha1[i];
              }
            }
            frame[3] = flags & 255;
            frame[4] = flags >>> 8;
            frame[5] = this._nonce & 255;
            frame[6] = this._nonce >>> 8 & 255;
            frame[7] = this._nonce >>> 16 & 255;
            frame[8] = this._nonce >>> 24 & 255;
            this.websocket.send(frame);
            break;
          case 5:
            if (this._connectionState != 3) {
              return;
            }
            if (arr_bytes.length < 1 + this._USB_META_WS_AUTHENTICATION_SIZE) {
              return;
            }
            this._tcpRoundTripTime = this._yapi.GetTickCount() - this._connectionTime + 1;
            if (this._tcpMaxWindowSize < 2048 && this._tcpRoundTripTime < 7) {
              this._tcpRoundTripTime = 7;
            }
            let uploadRate = this._tcpMaxWindowSize * 1e3 / this._tcpRoundTripTime >> 0;
            if (this._yapi._logLevel >= 4) {
              this._yapi.imm_log("RTT=" + this._tcpRoundTripTime + "ms, WS=" + this._tcpMaxWindowSize + ", uploadRate=" + uploadRate / 1e3 + " KB/s");
            }
            this._remoteVersion = arr_bytes[2];
            if (this._remoteVersion < 1) {
              return;
            }
            let inflags = arr_bytes[3] + (arr_bytes[4] << 8);
            if ((inflags & this._USB_META_WS_RW) != 0) {
              this._rwAccess = true;
            } else {
              this._rwAccess = false;
            }
            if ((inflags & this._USB_META_WS_VALID_SHA1) != 0) {
              let remote_sha1 = arr_bytes.subarray(9, 29);
              let sha1 = this.imm_computeAuth(this.urlInfo.user, this.urlInfo.pass, this._remoteSerial, this._nonce);
              for (let i = 0; i < sha1.length; i++) {
                if (sha1[i] != remote_sha1[i]) {
                  this._session_errno = 401;
                  this._session_error = "Authentication failed";
                  this._connectionState = 0;
                  return;
                }
              }
              this._connectionState = 4;
            } else {
              if (this.urlInfo.pass == "") {
                this._connectionState = 4;
              } else {
                this._session_errno = 401;
                if (this.urlInfo.user == "admin" && !this._rwAccess) {
                  this._session_error = "Authentication as admin failed";
                } else {
                  this._session_error = "Password not set on remote hub";
                }
                this._connectionState = 0;
                return;
              }
            }
            break;
          case 6:
            this._session_errno = arr_bytes[3] + (arr_bytes[4] << 8);
            if (this._session_errno == 401) {
              this._session_error = "Authentication failed";
            } else {
              this._session_error = "Remote hub closed connection with error " + this._session_errno;
            }
            this._connectionState = 0;
            break;
          case 7:
            tcpchan = arr_bytes[2];
            if (this.tcpChan[tcpchan]) {
              let yreq = this.tcpChan[tcpchan];
              let ackBytes = arr_bytes[3] + (arr_bytes[4] << 8) + (arr_bytes[5] << 16) + (arr_bytes[6] << 24);
              let ackTime = this._yapi.GetTickCount();
              if (this._lastUploadAckTime[tcpchan] != 0 && ackBytes > this._lastUploadAckBytes[tcpchan]) {
                this._lastUploadAckBytes[tcpchan] = ackBytes;
                this._lastUploadAckTime[tcpchan] = ackTime;
                let deltaBytes = ackBytes - this._lastUploadRateBytes[tcpchan];
                let deltaTime = ackTime - this._lastUploadRateTime[tcpchan];
                if (deltaTime < 500)
                  break;
                if (deltaTime < 1e3 && deltaBytes < 65536)
                  break;
                this._lastUploadRateBytes[tcpchan] = ackBytes;
                this._lastUploadRateTime[tcpchan] = ackTime;
                if (yreq.progressCb && yreq.toBeSent) {
                  yreq.progressCb(ackBytes, yreq.toBeSent.length);
                }
                let newRate = deltaBytes * 1e3 / deltaTime;
                this._uploadRate[tcpchan] = 0.8 * this._uploadRate[tcpchan] + 0.3 * newRate >> 0;
                if (this._yapi._logLevel >= 5) {
                  this._yapi.imm_log("New rate: " + this._uploadRate[tcpchan] / 1e3 + " KB/s (last " + (deltaBytes / 1e3 >> 0) + "KB sent at " + (newRate >> 0) / 1e3 + " KB/s)");
                }
              } else {
                this._lastUploadAckBytes[tcpchan] = ackBytes;
                this._lastUploadAckTime[tcpchan] = ackTime;
                this._lastUploadRateBytes[tcpchan] = ackBytes;
                this._lastUploadRateTime[tcpchan] = ackTime;
                if (yreq.progressCb && yreq.toBeSent) {
                  yreq.progressCb(ackBytes, yreq.toBeSent.length);
                }
                this.imm_sendPendingRequest(tcpchan);
              }
            }
            break;
        }
        return;
      }
      this.imm_asyncWebSocketError(YAPI_IO_ERROR, "Unsupported message: " + this._yapi.imm_bin2hexstr(arr_bytes));
    } catch (e) {
      this._yapi.imm_log("Unhandled exception in _webSocketMsg:", e);
    }
  }
  imm_webSocketSend(arr_bytes) {
    if (this.websocket) {
      this.websocket.send(arr_bytes);
    }
  }
  async request(method, devUrl, obj_body, tcpchan) {
    if (this._yapi._logLevel >= 3) {
      this.imm_logrequest(method, devUrl, obj_body);
    }
    let httpPromise = new Promise((resolve, reject) => {
      let subReq = method + " " + devUrl + " \r\n\r\n";
      let ws = this.websocket;
      let isAsync = this._remoteVersion > 0 && devUrl.slice(-2) == "&.";
      let yreq = new YHTTPRequest(new Uint8Array(0));
      if (this._yapi._logLevel >= 5) {
        yreq._creat = (Date.now() % 6e5).toString();
        this._yapi.imm_log("request @" + yreq._creat + ": " + method + " " + devUrl);
      }
      yreq.acceptor = resolve;
      yreq.devUrl = devUrl;
      yreq.sendPos = 0;
      if (obj_body) {
        let boundary = this.imm_getBoundary();
        let body = this.imm_formEncodeBody(obj_body, boundary);
        subReq = subReq.slice(0, -2) + "Content-Type: x-upload, boundary=" + boundary + "\r\n\r\n";
        yreq.toBeSent = new Uint8Array(subReq.length + body.length);
        yreq.toBeSent.set(body, subReq.length);
        yreq.progressCb = obj_body.progressCb;
      } else {
        yreq.toBeSent = new Uint8Array(subReq.length);
      }
      for (let i = 0; i < subReq.length; i++) {
        yreq.toBeSent[i] = subReq.charCodeAt(i);
      }
      if (tcpchan > 3) {
        yreq.errorType = YAPI_IO_ERROR;
        yreq.errorMsg = "Unsupported tcpChan " + tcpchan;
        try {
          yreq.acceptor(yreq);
        } catch (e) {
        }
        return;
      }
      if (!ws || this.imm_isDisconnecting() || this._connectionState != 5) {
        if (this._yapi._logLevel >= 4) {
          let wsState = ws ? " websocket=NULL" : "";
          let dsState = this.imm_isDisconnecting() ? " disconnecting" : "";
          let cnState = this._connectionState != 5 ? " connState=" + this._connectionState : "";
          this._yapi.imm_log("request @" + yreq._creat + " failed, websocket is down:" + wsState + dsState + cnState);
        }
        yreq.errorType = YAPI_IO_ERROR;
        yreq.errorMsg = "WebSocket not connected";
        try {
          yreq.acceptor(yreq);
        } catch (e) {
        }
        return;
      }
      if (isAsync) {
        yreq.asyncId = this.nextAsyncId++;
        if (this.nextAsyncId >= 127) {
          this.nextAsyncId = 48;
        }
      }
      let queue = this.tcpChan[tcpchan];
      if (queue) {
        while (queue.next) {
          queue = queue.next;
        }
        queue.next = yreq;
      } else {
        this.tcpChan[tcpchan] = yreq;
      }
      this.imm_sendPendingRequest(tcpchan);
    });
    return httpPromise;
  }
  imm_sendPendingRequest(tcpchan) {
    let yreq = this.tcpChan[tcpchan];
    while (yreq) {
      if (!this.websocket || this.imm_isDisconnecting() || this._connectionState != 5) {
        if (this._yapi._logLevel >= 4) {
          this._yapi.imm_log("request @" + yreq._creat + " failed, websocket is down");
        }
        yreq.errorType = YAPI_IO_ERROR;
        yreq.errorMsg = "WebSocket not connected";
        if (yreq.acceptor) {
          try {
            yreq.acceptor(yreq);
          } catch (e) {
          }
        }
        yreq = yreq.next;
        continue;
      }
      let pendingCount = 1;
      for (let yr = yreq; yr.next; yr = yr.next) {
        pendingCount++;
      }
      if (!yreq.toBeSent) {
        if (yreq.asyncId == 0) {
          if (this._yapi._logLevel >= 5) {
            this._yapi.imm_log(pendingCount.toString() + " req pending, @" + yreq._creat + " not completed");
          }
          return;
        }
        yreq = yreq.next;
        continue;
      }
      let isAsync = yreq.asyncId != 0;
      let asyncCloseSet = false;
      let pos = yreq.sendPos;
      let end = yreq.toBeSent.length;
      let i, frame;
      if (end > 2108 && this._remoteVersion >= 2 && tcpchan == 0) {
        if (pos == 0) {
          end = 2108;
          this._lastUploadAckBytes[tcpchan] = 0;
          this._lastUploadAckTime[tcpchan] = 0;
          this._uploadRate[tcpchan] = this._tcpMaxWindowSize * 1e3 / this._tcpRoundTripTime >> 0;
        } else if (this._lastUploadAckTime[tcpchan] == 0) {
          if (yreq.sendTimeoutId)
            clearTimeout(yreq.sendTimeoutId);
          yreq.sendTimeoutId = setTimeout(() => {
            this.imm_sendPendingRequest(tcpchan);
          }, this._tcpRoundTripTime);
          return;
        } else {
          let bytesOnTheAir = pos - this._lastUploadAckBytes[tcpchan];
          let uploadRate = this._uploadRate[tcpchan];
          let timeOnTheAir = this._yapi.GetTickCount() - this._lastUploadAckTime[tcpchan];
          let toBeSent = 2 * uploadRate + 1024 - bytesOnTheAir + uploadRate * timeOnTheAir / 1e3 >> 0;
          if (toBeSent + bytesOnTheAir > this._DEFAULT_TCP_MAX_WINDOW_SIZE) {
            toBeSent = this._DEFAULT_TCP_MAX_WINDOW_SIZE - bytesOnTheAir;
          }
          if (toBeSent < 64) {
            let waitTime = 1e3 * (128 - toBeSent) / uploadRate >> 0;
            if (waitTime < 2)
              waitTime = 2;
            if (yreq.sendTimeoutId)
              clearTimeout(yreq.sendTimeoutId);
            yreq.sendTimeoutId = setTimeout(() => {
              this.imm_sendPendingRequest(tcpchan);
            }, waitTime);
            return;
          }
          if (end > pos + toBeSent) {
            if (toBeSent > 124) {
              toBeSent = (toBeSent / 124 >> 0) * 124;
            }
            end = pos + toBeSent;
          }
        }
      }
      while (pos < end) {
        let framelen = 1 + end - pos;
        if (framelen > 125)
          framelen = 125;
        let datalen = framelen - 1;
        if (isAsync && pos + datalen == yreq.toBeSent.length && framelen < 125) {
          frame = new Uint8Array(framelen + 1);
          frame[0] = 8 * 9 + tcpchan;
          frame[framelen] = yreq.asyncId;
          asyncCloseSet = true;
        } else {
          frame = new Uint8Array(framelen);
          frame[0] = 8 * 1 + tcpchan;
        }
        frame.set(yreq.toBeSent.subarray(pos, pos + datalen), 1);
        pos += datalen;
        this.imm_webSocketSend(frame);
      }
      let sent = pos - yreq.sendPos;
      yreq.sendPos = pos;
      if (yreq.sendPos < yreq.toBeSent.length) {
        let waitTime = 1e3 * sent / this._uploadRate[tcpchan] >> 0;
        if (waitTime < 2)
          waitTime = 2;
        if (yreq.sendTimeoutId)
          clearTimeout(yreq.sendTimeoutId);
        yreq.sendTimeoutId = setTimeout(() => {
          this.imm_sendPendingRequest(tcpchan);
        }, waitTime);
        return;
      }
      if (isAsync && !asyncCloseSet) {
        frame = new Uint8Array(2);
        frame[0] = 8 * 9 + tcpchan;
        frame[1] = yreq.asyncId;
        this.imm_webSocketSend(frame);
      }
      yreq.toBeSent = null;
      if (isAsync && yreq.acceptor) {
        try {
          yreq.acceptor(yreq);
        } catch (e) {
          this._yapi.imm_log("WS: async acceptor exception: ", e);
        }
      }
      let mstimeout = this._yapi._networkTimeoutMs;
      if (yreq.devUrl) {
        if (yreq.devUrl.indexOf("/testcb.txt") >= 0) {
          mstimeout = this._YIO_1_MINUTE_TCP_TIMEOUT;
        } else if (yreq.devUrl.indexOf("/logger.json") >= 0) {
          mstimeout = this._YIO_1_MINUTE_TCP_TIMEOUT;
        } else if (yreq.devUrl.indexOf("/rxmsg.json") >= 0) {
          mstimeout = this._YIO_1_MINUTE_TCP_TIMEOUT;
        } else if (yreq.devUrl.indexOf("/rxdata.bin") >= 0) {
          mstimeout = this._YIO_1_MINUTE_TCP_TIMEOUT;
        } else if (yreq.devUrl.indexOf("/at.txt") >= 0) {
          mstimeout = this._YIO_1_MINUTE_TCP_TIMEOUT;
        } else if (yreq.devUrl.indexOf("/files.json") >= 0) {
          mstimeout = this._YIO_1_MINUTE_TCP_TIMEOUT;
        } else if (yreq.devUrl.indexOf("/upload.html") >= 0) {
          mstimeout = this._YIO_10_MINUTES_TCP_TIMEOUT;
        } else if (yreq.devUrl.indexOf("/flash.json") >= 0) {
          mstimeout = this._YIO_10_MINUTES_TCP_TIMEOUT;
        } else if (yreq.devUrl.indexOf("/Yvw4I.js") >= 0) {
          mstimeout = this._YIO_10_MINUTES_TCP_TIMEOUT;
        }
      }
      yreq.timeoutId = setTimeout((chan, yr) => {
        this.imm_abortRequest(chan, yr);
      }, mstimeout, tcpchan, yreq);
      yreq._sent = (Date.now() % 6e5).toString();
      if (this._yapi._logLevel >= 5) {
        this._yapi.imm_log("req @" + yreq._creat + " sent (1/" + pendingCount.toString() + ")" + (isAsync ? " async-" + yreq.asyncId + ", continue" : ", waiting for reply"));
      }
      if (!isAsync) {
        return;
      }
      yreq = yreq.next;
    }
  }
  imm_abortRequest(tcpchan, yreq) {
    if (!yreq.timeoutId)
      return;
    yreq.timeoutId = null;
    if (yreq.asyncId == 0) {
      let frame = new Uint8Array(1);
      frame[0] = 8 * 2 + tcpchan;
      this.imm_webSocketSend(frame);
      if (this._yapi._logLevel >= 4) {
        let pendingCount = 1;
        for (let yr = yreq; yr.next; yr = yr.next) {
          pendingCount++;
        }
        this._yapi.imm_log(pendingCount.toString() + " req pending, @" + yreq._creat + " is in timeout");
      }
      setTimeout((chan, yr) => {
        this._yapi.imm_log("Dropping synchronous request after timeout: " + yr.devUrl);
        this.imm_forgetRequest(chan, yr);
      }, 5e3, tcpchan, yreq);
    }
    this.imm_asyncWebSocketError(YAPI_IO_ERROR, "Timeout on " + yreq.devUrl + " (tcpchan " + tcpchan + ")");
  }
  imm_forgetRequest(tcpchan, yreq) {
    let queue = this.tcpChan[tcpchan];
    if (queue == yreq) {
      this.tcpChan[tcpchan] = yreq.next;
      if (yreq.asyncId == 0) {
        yreq.errorType = YAPI_IO_ERROR;
        yreq.errorMsg = "Timeout on " + yreq.devUrl + " (tcpchan " + tcpchan + ")";
        if (yreq.acceptor) {
          try {
            yreq.acceptor(yreq);
          } catch (e) {
          }
        }
      }
      this.imm_sendPendingRequest(tcpchan);
    }
  }
  imm_dropAllPendingConnection() {
    if (this.fwd_connectionState != 1 && this.fwd_websocket) {
      this.fwd_connectionState = 1;
      this.fwd_websocket.close();
      this.fwd_websocket = null;
    }
    for (let tcpchan = 0; tcpchan < this.tcpChan.length; tcpchan++) {
      for (let yreq = this.tcpChan[tcpchan]; yreq; yreq = yreq.next) {
        this.tcpChan[tcpchan] = yreq.next;
        if (yreq.timeoutId) {
          clearTimeout(yreq.timeoutId);
          yreq.timeoutId = 0;
        }
        if (yreq.asyncId == 0) {
          if (this._yapi._logLevel >= 4) {
            this._yapi.imm_log("drop @" + yreq._creat + " (websocket down)");
          }
          yreq.errorType = YAPI_IO_ERROR;
          yreq.errorMsg = "Request " + yreq.devUrl + " dropped (websocket down)";
          if (yreq.acceptor) {
            try {
              yreq.acceptor(yreq);
            } catch (e) {
            }
          }
        }
      }
    }
  }
  async websocketJoin(ws, arr_credentials, close_callback) {
    if (this._connectionState != 5) {
      this.imm_asyncWebSocketError(YAPI_IO_ERROR, "Hub is disconnected, cannot join");
      return false;
    }
    this.fwd_websocket = ws;
    this.fwd_credentials = arr_credentials;
    this.fwd_closeCallback = close_callback;
    this.fwd_connectionState = 2;
    ws.onmessage = (evt) => {
      if (this.fwd_connectionState == 5) {
        if (this._connectionState == 5) {
          this.imm_webSocketSend(evt.data);
        } else {
          this._yapi.imm_log("WS: drop packet from fwd API (state=" + this._connectionState + ")");
        }
      } else if (this.fwd_connectionState == 3) {
        this.imm_handleAPIAuthPkt(evt.data);
      } else {
        this._yapi.imm_log("WS: drop packet from fwd API (fwd_state=" + this.fwd_connectionState + ")");
      }
    };
    ws.onclose = (evt) => {
      this.fwd_connectionState = 1;
      this.fwd_websocket = null;
      if (this.fwd_closeCallback) {
        this.fwd_closeCallback();
      }
    };
    return this.imm_sendAPIAnnouncePkt();
  }
  imm_sendAPIAnnouncePkt() {
    if (!this.fwd_websocket) {
      return false;
    }
    let frame = new Uint8Array(1 + this._USB_META_WS_ANNOUNCE_SIZE);
    let nonce = new Uint8Array(4);
    this.imm_getRandomValues(nonce);
    frame[0] = 5 << 3;
    frame[1] = 4;
    frame[2] = 2;
    frame[3] = this._tcpMaxWindowSize >> 4 & 255;
    frame[4] = this._tcpMaxWindowSize >> 12 & 255;
    for (let i = 0; i < 4; i++) {
      frame[5 + i] = nonce[i];
    }
    for (let i = 0; i < this._remoteSerial.length && i < 20; i++) {
      frame[9 + i] = this._remoteSerial.charCodeAt(i);
    }
    this.fwd_nonce = frame[5] + (frame[6] << 8) + (frame[7] << 16) + (frame[8] << 24);
    this.fwd_connectionState = 3;
    this.fwd_websocket.send(frame);
    return true;
  }
  imm_handleAPIAuthPkt(msg) {
    if (msg.length < 1 + this._USB_META_WS_AUTHENTICATION_SIZE || msg[0] != 5 << 3) {
      this._yapi.imm_log("bad-apiauth1\n");
      this.fwd_connectionState = 0;
      return;
    }
    if (msg[1] != 5 || msg[2] > 2) {
      this._yapi.imm_log("bad-apiauth2\n");
      this.fwd_connectionState = 0;
      return;
    }
    this._remoteVersion = msg[2];
    let flags = msg[3] + (msg[4] << 8);
    if ((flags & this._USB_META_WS_VALID_SHA1) == 0) {
      this._yapi.imm_log("bad-apiauth3\n");
      this.fwd_connectionState = 0;
      return;
    }
    if (!this.fwd_websocket) {
      this._yapi.imm_log("no-fwd-ws\n");
      this.fwd_connectionState = 0;
      return;
    }
    let credIdx, remote_sha1 = msg.subarray(9, 29);
    let credentials = this.fwd_credentials;
    for (credIdx = 0; credIdx < credentials.length; credIdx++) {
      let j, sha12 = this.imm_computeAuth(credentials[credIdx].user, credentials[credIdx].pass, this._remoteSerial, this.fwd_nonce);
      for (j = 0; j < sha12.length; j++) {
        if (sha12[j] != remote_sha1[j])
          break;
      }
      if (j >= sha12.length)
        break;
    }
    if (credIdx >= credentials.length) {
      this._yapi.imm_log("bad-apiauth4\n");
      msg.fill(0, 3);
      this.fwd_websocket.send(msg);
      this.fwd_connectionState = 0;
      return;
    }
    msg[3] |= this._USB_META_WS_RW;
    this.fwd_nonce = msg[5] + (msg[6] << 8) + (msg[7] << 16) + (msg[8] << 24);
    let sha1 = this.imm_computeAuth(credentials[credIdx].user, credentials[credIdx].pass, this._remoteSerial, this.fwd_nonce);
    for (let i = 0; i < sha1.length; i++) {
      msg[9 + i] = sha1[i];
    }
    this.fwd_websocket.send(msg);
    this.fwd_connectionState = 5;
  }
  async detach(errType = YAPI.IO_ERROR, errMsg = "Hub has been forcibly detached") {
    let tcpchan_busy;
    let timeout = this._yapi.GetTickCount() + 3e3;
    do {
      tcpchan_busy = false;
      for (let tcpchan = 0; tcpchan < 4; tcpchan++) {
        if (this.tcpChan[tcpchan] != null) {
          tcpchan_busy = true;
          break;
        }
      }
      if (tcpchan_busy) {
        await this._yapi._microSleep_internal();
      }
    } while (tcpchan_busy && timeout > this._yapi.GetTickCount());
    this.imm_commonDisconnect("detach", errType, errMsg);
    this.imm_disconnectNow();
  }
  imm_disconnectNow(connID = "") {
    if (!super.imm_disconnectNow(connID)) {
      return false;
    }
    if (!this.websocket) {
      return false;
    }
    this._connectionState = 1;
    let prevOpenID = connID ? connID : this.currentConnID;
    let websocket = this.websocket;
    this.currentConnID = "";
    this.websocket = null;
    websocket.onclose = null;
    websocket.onerror = null;
    try {
      websocket.close();
    } catch (e) {
    }
    if (websocket.terminate) {
      setTimeout(() => {
        try {
          if (websocket.terminate) {
            websocket.terminate();
          }
        } catch (e) {
        }
      }, 900);
    }
    this.imm_dropAllPendingConnection();
    this.imm_signalHubDisconnected(prevOpenID);
    return true;
  }
  imm_isOnline() {
    if (this._connectionState != 5) {
      return false;
    }
    return super.imm_isOnline();
  }
};
var YHub = class {
  constructor(obj_yapi, hubref) {
    this._hubref = 0;
    this._ctx = obj_yapi;
    this._hubref = hubref;
  }
  async _getStrAttr_internal(attrName) {
    let hub = this._ctx.getGenHub(this._hubref);
    if (hub == null) {
      return "";
    }
    switch (attrName) {
      case "registeredUrl":
        return hub.urlInfo.orgUrl;
      case "connectionUrl":
        return hub.urlInfo.rootUrl;
      case "serialNumber":
        return hub.hubSerial;
      case "errorMessage":
        return hub.get_errorMessage();
      default:
        return "";
    }
  }
  async _getIntAttr_internal(attrName) {
    let hub = this._ctx.getGenHub(this._hubref);
    if (attrName == "isInUse") {
      return hub != null ? 1 : 0;
    }
    if (hub == null) {
      return -1;
    }
    switch (attrName) {
      case "isOnline":
        return hub.imm_isOnline() ? 1 : 0;
      case "isReadOnly":
        return await hub.hasRwAccess() ? 0 : 1;
      case "networkTimeout":
        return hub.stalledTimeoutMs;
      case "errorType":
        return hub.get_errorType();
      default:
        return -1;
    }
  }
  async _setIntAttr_internal(attrName, value) {
    let hub = this._ctx.getGenHub(this._hubref);
    if (hub != null && attrName == "networkTimeout") {
      hub.stalledTimeoutMs = value;
    }
  }
  get_knownUrls_internal() {
    let hub = this._ctx.getGenHub(this._hubref);
    if (hub != null) {
      return hub.get_knownUrls();
    }
    return [];
  }
  async _getStrAttr(attrName) {
    return await this._getStrAttr_internal(attrName);
  }
  async _getIntAttr(attrName) {
    return await this._getIntAttr_internal(attrName);
  }
  async _setIntAttr(attrName, value) {
    return await this._setIntAttr_internal(attrName, value);
  }
  async get_registeredUrl() {
    return await this._getStrAttr("registeredUrl");
  }
  async get_knownUrls() {
    return await this.get_knownUrls_internal();
  }
  async get_connectionUrl() {
    return await this._getStrAttr("connectionUrl");
  }
  async get_serialNumber() {
    return await this._getStrAttr("serialNumber");
  }
  async isInUse() {
    return await this._getIntAttr("isInUse") > 0;
  }
  async isOnline() {
    return await this._getIntAttr("isOnline") > 0;
  }
  async isReadOnly() {
    return await this._getIntAttr("isReadOnly") > 0;
  }
  async set_networkTimeout(networkMsTimeout) {
    await this._setIntAttr("networkTimeout", networkMsTimeout);
  }
  async get_networkTimeout() {
    return await this._getIntAttr("networkTimeout");
  }
  async get_errorType() {
    return await this._getIntAttr("errorType");
  }
  async get_errorMessage() {
    return await this._getStrAttr("errorMessage");
  }
  async get_userData() {
    return this._userData;
  }
  async set_userData(data) {
    this._userData = data;
  }
  static FirstHubInUse() {
    return YAPI.nextHubInUseInternal(-1);
  }
  static FirstHubInUseInContext(yctx) {
    return yctx.nextHubInUseInternal(-1);
  }
  nextHubInUse() {
    return this._ctx.nextHubInUseInternal(this._hubref);
  }
};
var YAPIContext = class {
  constructor(system_env) {
    this._detectType = Y_DETECT_NONE;
    this._knownHubsBySerial = {};
    this._knownHubsByUrl = {};
    this._connectedHubs = [];
    this._yhub_cache = {};
    this._ssdpManager = null;
    this._devs = {};
    this._snByUrl = {};
    this._snByName = {};
    this._fnByType = {};
    this._lastErrorType = YAPI_SUCCESS;
    this._lastErrorMsg = "no error";
    this._updateDevListStarted = 0;
    this._pendingCallbacks = [];
    this._logLevel = 2;
    this._logCallback = null;
    this._arrivalCallback = null;
    this._namechgCallback = null;
    this._removalCallback = null;
    this._hubDiscoveryCallback = null;
    this._forwardValues = 0;
    this._calibHandlers = [];
    this._ValueCallbackList = [];
    this._TimedReportCallbackList = [];
    this._beacons = {};
    this._isNodeJS = false;
    this._networkTimeoutMs = DEFAULT_NETWORK_TIMEOUT_MS;
    this._deviceListValidityMs = DEFAULT_DEVICE_LIST_VALIDITY_MS;
    this.defaultEncoding = "binary";
    this.exceptionsDisabled = false;
    this.SUCCESS = 0;
    this.NOT_INITIALIZED = -1;
    this.INVALID_ARGUMENT = -2;
    this.NOT_SUPPORTED = -3;
    this.DEVICE_NOT_FOUND = -4;
    this.VERSION_MISMATCH = -5;
    this.DEVICE_BUSY = -6;
    this.TIMEOUT = -7;
    this.IO_ERROR = -8;
    this.NO_MORE_DATA = -9;
    this.EXHAUSTED = -10;
    this.DOUBLE_ACCES = -11;
    this.UNAUTHORIZED = -12;
    this.RTC_NOT_READY = -13;
    this.FILE_NOT_FOUND = -14;
    this.SSL_ERROR = -15;
    this.RFID_SOFT_ERROR = -16;
    this.RFID_HARD_ERROR = -17;
    this.BUFFER_TOO_SMALL = -18;
    this.defaultCacheValidity = 5;
    this.INVALID_INT = YAPI_INVALID_INT;
    this.INVALID_UINT = YAPI_INVALID_UINT;
    this.INVALID_LONG = YAPI_INVALID_LONG;
    this.INVALID_DOUBLE = YAPI_INVALID_DOUBLE;
    this.MIN_DOUBLE = YAPI_MIN_DOUBLE;
    this.MAX_DOUBLE = YAPI_MAX_DOUBLE;
    this.INVALID_STRING = YAPI_INVALID_STRING;
    this.HASH_BUF_SIZE = YOCTO_HASH_BUF_SIZE;
    this.DETECT_NONE = Y_DETECT_NONE;
    this.DETECT_USB = Y_DETECT_USB;
    this.DETECT_NET = Y_DETECT_NET;
    this.DETECT_ALL = Y_DETECT_ALL;
    this.system_env = system_env || YAPI && YAPI.system_env || _UnspecifiedSystemEnv;
    this._isNodeJS = this.system_env.isNodeJS;
    this._uniqueID = String.fromCharCode(Math.random() * 79 + 48, Math.random() * 79 + 48, Math.random() * 79 + 48);
    this.imm_ResetToDefaults();
  }
  imm_ResetToDefaults() {
    this._detectType = this.DETECT_NONE;
    this._knownHubsBySerial = {};
    this._knownHubsByUrl = {};
    this._connectedHubs = [];
    this._devs = {};
    this._snByUrl = {};
    this._snByName = {};
    this._fnByType = {};
    this._fnByType.Module = new YFunctionType(this, "Module");
    this._lastErrorType = YAPI_SUCCESS;
    this._lastErrorMsg = "no error";
    this._updateDevListStarted = 0;
    this._pendingCallbacks = [];
    this._logLevel = 2;
    this._logCallback = null;
    this._arrivalCallback = null;
    this._namechgCallback = null;
    this._removalCallback = null;
    this._hubDiscoveryCallback = null;
    this._forwardValues = 0;
    this._ValueCallbackList = [];
    this._TimedReportCallbackList = [];
    this._beacons = {};
    this._calibHandlers = [];
    for (let i = 1; i <= 20; i++) {
      this.RegisterCalibrationHandler(i, this.LinearCalibrationHandler);
    }
    this.RegisterCalibrationHandler(YOCTO_CALIB_TYPE_OFS, this.LinearCalibrationHandler);
    this.exceptionsDisabled = false;
  }
  _throw(int_errType, str_errMsg, obj_retVal) {
    this._lastErrorType = int_errType;
    this._lastErrorMsg = str_errMsg;
    if (!this.exceptionsDisabled) {
      let exc = new YoctoError(str_errMsg);
      exc.errorType = int_errType;
      throw exc;
    }
    return obj_retVal;
  }
  imm_setErr(errmsg, int_errType, str_errMsg, obj_retVal) {
    if (errmsg) {
      errmsg.msg = str_errMsg;
    }
    this._lastErrorType = int_errType;
    this._lastErrorMsg = str_errMsg;
    return obj_retVal;
  }
  imm_setSystemEnv(env) {
    this.system_env = env;
    this._isNodeJS = env.isNodeJS;
  }
  imm_log(msg, ...moreArgs) {
    let now = new Date();
    let day = now.getFullYear().toString() + "-" + ("0" + (now.getMonth() + 1)).slice(-2) + "-" + ("0" + now.getDate()).slice(-2);
    let time = ("0" + now.getHours().toString()).slice(-2) + ":" + ("0" + now.getMinutes()).slice(-2) + ":" + ("0" + now.getSeconds()).slice(-2);
    let prefix = day + " " + time + " [" + this._uniqueID + "] ";
    let isError = false;
    if (moreArgs.length > 0) {
      if (moreArgs[0].constructor && /Error/i.test(moreArgs[0].constructor.name)) {
        isError = true;
      }
    }
    if (this._logCallback) {
      try {
        if (moreArgs.length > 0) {
          if (moreArgs[0].message) {
            msg += moreArgs[0].message;
          } else {
            msg += moreArgs[0].toString();
          }
        }
        this._logCallback(prefix + msg);
      } catch (e) {
        console.error(prefix + "Exception in custom log callback: ", e);
        console.log("... while trying to log:");
        if (isError) {
          console.error(prefix + msg, ...moreArgs);
        } else {
          console.log(prefix + msg, ...moreArgs);
        }
      }
    } else {
      if (isError) {
        console.error(prefix + msg, ...moreArgs);
      } else {
        console.log(prefix + msg, ...moreArgs);
      }
    }
  }
  async RegisterLogFunction(logfun) {
    this._logCallback = logfun;
    return YAPI_SUCCESS;
  }
  imm_getHub(obj_urlInfo) {
    return this._knownHubsByUrl[obj_urlInfo.rootUrl];
  }
  imm_getPrimaryHub(hub) {
    let primaryHub = this._knownHubsBySerial[hub.hubSerial];
    if (!primaryHub || primaryHub === hub) {
      this._knownHubsBySerial[hub.hubSerial] = hub;
      this._knownHubsByUrl[hub.urlInfo.rootUrl] = hub;
      return hub;
    }
    if (primaryHub._currentState >= hub._currentState) {
      primaryHub.imm_inheritFrom(hub);
      return primaryHub;
    }
    this._knownHubsBySerial[hub.hubSerial] = hub;
    hub.imm_inheritFrom(primaryHub);
    return hub;
  }
  async _addConnectedHub(newhub) {
    let serial = this._snByUrl[newhub.urlInfo.rootUrl];
    if (!serial) {
      let newdev = new YDevice(this, newhub.urlInfo.rootUrl, null, null);
      await newdev.refresh();
    }
    let hubFound = false;
    for (let i = 0; i < this._connectedHubs.length; i++) {
      let url = this._connectedHubs[i].urlInfo.rootUrl;
      if (newhub.urlInfo.rootUrl == url) {
        hubFound = true;
        break;
      }
    }
    if (!hubFound) {
      this._connectedHubs.push(newhub);
    }
  }
  imm_isActiveHub(hubSerial) {
    for (let i = 0; i < this._connectedHubs.length; i++) {
      let hubSerials = this._connectedHubs[i].serialByYdx;
      if (hubSerials && hubSerials[0] == hubSerial) {
        return true;
      }
    }
    return false;
  }
  imm_dropConnectedHub(hub) {
    let idx = this._connectedHubs.indexOf(hub);
    if (idx < 0) {
      return;
    }
    for (let j = 0; j < hub.serialByYdx.length; j++) {
      let serial = hub.serialByYdx[j];
      if (serial && this._devs[serial]) {
        if (this._removalCallback) {
          let module = YModule.FindModuleInContext(this, serial + ".module");
          this._pendingCallbacks.push({event: "-", serial, module});
        }
        try {
          this.imm_forgetDevice(this._devs[serial]);
        } catch (e) {
        }
      }
    }
    idx = this._connectedHubs.indexOf(hub);
    if (idx >= 0) {
      this._connectedHubs.splice(idx, 1);
    }
  }
  async _ensureUpdateDeviceListNotRunning() {
    while (this._updateDevListStarted && this.GetTickCount() - this._updateDevListStarted < 30 * 1e3) {
      await this.Sleep(25);
    }
  }
  async _updateDeviceList_internal(bool_forceupdate, bool_invokecallbacks) {
    if (this._updateDevListStarted && this.GetTickCount() - this._updateDevListStarted < 30 * 1e3) {
      return {
        errorType: YAPI_SUCCESS,
        errorMsg: "no error"
      };
    }
    for (let i = 0; i < this._connectedHubs.length; i++) {
      if (this._connectedHubs[i]._firstArrivalCallback && bool_invokecallbacks && this._arrivalCallback) {
        bool_forceupdate = true;
        break;
      }
    }
    if (bool_forceupdate) {
      for (let i = 0; i < this._connectedHubs.length; i++) {
        this._connectedHubs[i].imm_forceUpdate();
      }
    }
    try {
      this._updateDevListStarted = this.GetTickCount();
      let hubs = [];
      for (let i = 0; i < this._connectedHubs.length; i++) {
        let hub = this._connectedHubs[i];
        let rootUrl = hub.urlInfo.rootUrl;
        let hubDev = this.imm_getDevice(rootUrl);
        if (!hubDev) {
          continue;
        }
        if (hub._currentState < 1) {
          if (this._logLevel >= 4) {
            this.imm_log("Skip updateDeviceList for hub " + hub.urlInfo.host + ", currently offline");
          }
          continue;
        }
        if (hub.devListExpires <= this.GetTickCount()) {
          hub._missing = {};
          hubs.push(hub);
        }
      }
      for (let serial in this._devs) {
        let rooturl = this._devs[serial].imm_getRootUrl();
        for (let i = 0; i < hubs.length; i++) {
          let huburl = hubs[i].urlInfo.rootUrl;
          if (rooturl.substr(0, huburl.length) == huburl) {
            hubs[i]._missing[serial] = true;
          }
        }
      }
      let update_promises = [];
      for (let i = 0; i < hubs.length; i++) {
        let prom = hubs[i].hubUpdateDeviceList();
        update_promises.push(prom);
      }
      let newDeviceCounts = await Promise.all(update_promises);
      let newDeviceArrived = false;
      for (let res of newDeviceCounts) {
        newDeviceArrived = newDeviceArrived || res > 0;
      }
      if (bool_invokecallbacks) {
        let nbEvents = this._pendingCallbacks.length;
        for (let i = 0; i < nbEvents; i++) {
          let evt = this._pendingCallbacks[i];
          switch (evt.event) {
            case "+":
              if (this._logLevel >= 3) {
                this.imm_log("Device " + evt.serial + " plugged");
              }
              if (this._arrivalCallback) {
                try {
                  await evt.module.load(this.defaultCacheValidity);
                  await this._arrivalCallback(evt.module);
                } catch (e) {
                  this.imm_log("Exception in device arrival callback:", e);
                }
              }
              break;
            case "/":
              if (this._namechgCallback) {
                try {
                  await this._namechgCallback(evt.module);
                } catch (e) {
                  this.imm_log("Exception in device change callback:", e);
                }
              }
              break;
            case "-":
              if (this._logLevel >= 3) {
                this.imm_log("Device " + evt.serial + " unplugged");
              }
              if (this._removalCallback) {
                try {
                  await this._removalCallback(evt.module);
                } catch (e) {
                  this.imm_log("Exception in device removal callback:", e);
                }
              }
              break;
          }
        }
        this._pendingCallbacks = this._pendingCallbacks.slice(nbEvents);
      }
      if (newDeviceArrived) {
        for (let fun of this._ValueCallbackList) {
          if (!fun._hwId) {
            fun.isOnline();
          }
        }
        for (let fun of this._TimedReportCallbackList) {
          if (!fun._hwId) {
            fun.isOnline();
          }
        }
      }
    } finally {
      this._updateDevListStarted = 0;
    }
    return {
      errorType: YAPI_SUCCESS,
      errorMsg: "no error"
    };
  }
  async updateDeviceList_process(hub, hubDev, whitePages, yellowPages) {
    let newDevices = 0;
    let refresh = {};
    let serial = null;
    for (let classname in yellowPages) {
      let obj_yprecs = yellowPages[classname];
      let ftype = this._fnByType[classname];
      if (ftype == void 0) {
        ftype = new YFunctionType(this, classname);
        this._fnByType[classname] = ftype;
      }
      for (let i = 0; i < obj_yprecs.length; i++) {
        let yprec = obj_yprecs[i];
        let hwid = yprec.hardwareId;
        let basetype = yprec.baseType;
        if (ftype.imm_reindexFunction(hwid, yprec["logicalName"], yprec["advertisedValue"], basetype)) {
          serial = hwid.substr(0, hwid.indexOf("."));
          refresh[serial] = true;
        }
      }
    }
    for (let i = 0; i < whitePages.length; i++) {
      let devinfo = whitePages[i];
      serial = devinfo.serialNumber;
      let devydx = devinfo.index;
      let rooturl = devinfo.networkUrl.slice(0, -3);
      if (rooturl.charAt(0) == "/")
        rooturl = hubDev.imm_getRootUrl() + rooturl.substr(1);
      let currdev = this._devs[serial];
      if (this._logLevel >= 5) {
        this.imm_log("Device " + serial + " present, currdev " + (currdev ? "" : "NOT ") + "set" + (hub._firstArrivalCallback ? ", firstArrival" : ""));
      }
      if (currdev && hub._firstArrivalCallback) {
        newDevices++;
        if (this._arrivalCallback) {
          let module = YModule.FindModuleInContext(this, serial + ".module");
          this._pendingCallbacks.push({event: "+", serial, module});
        }
      }
      hub.serialByYdx[devydx] = serial;
      if (!currdev) {
        new YDevice(this, rooturl, devinfo, yellowPages);
        newDevices++;
        if (this._arrivalCallback) {
          let module = YModule.FindModuleInContext(this, serial + ".module");
          this._pendingCallbacks.push({event: "+", serial, module});
        }
      } else if (currdev.imm_getLogicalName() != devinfo["logicalName"]) {
        await currdev.refresh();
        if (this._namechgCallback) {
          let module = YModule.FindModuleInContext(this, serial + ".module");
          this._pendingCallbacks.push({event: "/", serial, module});
        }
      } else if (refresh[serial] || currdev.imm_getRootUrl() != rooturl || currdev.imm_getBeacon() != devinfo["beacon"]) {
        await currdev.refresh();
      }
      hub._missing[serial] = false;
    }
    if (this._arrivalCallback && hub._firstArrivalCallback) {
      hub._firstArrivalCallback = false;
    }
    for (serial in hub._missing) {
      if (hub._missing[serial] && this._devs[serial]) {
        if (this._removalCallback) {
          let module = YModule.FindModuleInContext(this, serial + ".module");
          this._pendingCallbacks.push({event: "-", serial, module});
        }
        this.imm_forgetDevice(this._devs[serial]);
      }
    }
    return newDevices;
  }
  async parseEvents(hub, str_lines) {
    if (hub.imm_isDisconnecting()) {
      return;
    }
    hub.isNotifWorking = true;
    hub.lastPingStamp = Date.now();
    if (hub.timeoutId) {
      clearTimeout(hub.timeoutId);
    }
    hub.timeoutId = setTimeout(() => {
      if (!hub.imm_isForwarded()) {
        this.imm_log("Closing stalled connection after " + hub.stalledTimeoutMs / 1e3 + "s");
        hub.imm_disconnectNow();
      }
    }, hub.stalledTimeoutMs);
    let rows = (hub.notifCarryOver + str_lines).split("\n");
    let nrows = rows.length;
    let value;
    if (str_lines.substr(-1) != "\n") {
      hub.notifCarryOver = rows[--nrows];
    } else {
      nrows--;
      hub.notifCarryOver = "";
    }
    for (let idx = 0; idx < nrows; idx++) {
      let ev = rows[idx];
      if (ev.length == 0)
        continue;
      let firstCode = ev.charAt(0);
      if (ev.length >= 3 && firstCode >= NOTIFY_NETPKT_CONFCHGYDX && firstCode <= NOTIFY_NETPKT_TIMEAVGYDX) {
        hub.retryDelay = 15;
        if (hub.notifPos >= 0)
          hub.notifPos += ev.length + 1;
        let devydx = ev.charCodeAt(1) - 65;
        let funydx = ev.charCodeAt(2) - 48;
        if (funydx >= 64) {
          funydx -= 64;
          devydx += 128;
        }
        let serial = hub.serialByYdx[devydx];
        if (serial && this._devs[serial]) {
          let funcid = funydx == 15 ? "time" : this._devs[serial].imm_functionIdByFunYdx(funydx);
          if (funcid != "") {
            let dev;
            value = ev.slice(3);
            switch (firstCode) {
              case NOTIFY_NETPKT_FUNCVALYDX:
                if (value != "")
                  value = value.split("\0")[0];
                await this.setFunctionValue(serial + "." + funcid, value);
                break;
              case NOTIFY_NETPKT_DEVLOGYDX:
                dev = this._devs[serial];
                if (dev != null) {
                  dev.imm_triggerLogPull();
                }
                break;
              case NOTIFY_NETPKT_CONFCHGYDX:
                await this.setConfChange(serial);
                break;
              case NOTIFY_NETPKT_TIMEVALYDX:
              case NOTIFY_NETPKT_TIMEAVGYDX:
              case NOTIFY_NETPKT_TIMEV2YDX:
                let pos, arr = [firstCode == "x" ? 0 : firstCode == "z" ? 1 : 2];
                for (pos = 0; pos < value.length; pos += 2) {
                  arr.push(parseInt(value.substr(pos, 2), 16));
                }
                dev = this._devs[serial];
                if (funcid == "time") {
                  let time = arr[1] + 256 * arr[2] + 65536 * arr[3] + 16777216 * arr[4];
                  let ms = arr[5] * 4;
                  let duration;
                  if (arr.length >= 7) {
                    ms += arr[6] >> 6;
                    let duration_ms = arr[7];
                    duration_ms += (arr[6] & 15) * 256;
                    if (arr[6] & 16) {
                      duration = duration_ms;
                    } else {
                      duration = duration_ms / 1e3;
                    }
                  } else {
                    duration = 0;
                  }
                  dev.imm_setTimeRef(time + ms / 1e3, duration);
                } else {
                  await this.setTimedReport(serial + "." + funcid, dev.imm_getLastTimeRef(), dev.imm_getLastDuration(), arr);
                }
                break;
              case NOTIFY_NETPKT_FUNCV2YDX:
                let rawval = this.imm_decodeNetFuncValV2(value);
                if (rawval != null) {
                  let decodedval = this.imm_decodePubVal(rawval[0], rawval, 1, 6);
                  await this.setFunctionValue(serial + "." + funcid, decodedval);
                }
                break;
              case NOTIFY_NETPKT_FLUSHV2YDX:
              default:
                break;
            }
          }
        }
      } else if (ev.length > 5 && ev.substr(0, 4) == "YN01") {
        hub.retryDelay = 15;
        if (hub.notifPos >= 0)
          hub.notifPos += ev.length + 1;
        let notype = ev.substr(4, 1);
        let parts;
        if (notype == "@") {
          hub.notifPos = parseInt(ev.slice(5));
        } else {
          switch (parseInt(notype)) {
            case 0:
              parts = ev.slice(5).split(",");
              if (parts.length > 2) {
                let int_beacon = parseInt(parts[2]);
                await this.setBeaconChange(parts[0], int_beacon);
              }
            case 2:
            case 4:
            case 8:
              hub.devListExpires = 0;
              break;
            case 5:
              parts = ev.slice(5).split(",");
              if (parts.length > 2) {
                value = parts[2].split("\0");
                await this.setFunctionValue(parts[0] + "." + parts[1], value[0]);
              }
              break;
          }
        }
      } else {
        hub.devListExpires = 0;
        this.imm_log("Bad event on received from server:", ev);
        hub.notifPos = -1;
      }
    }
    if (this._forwardValues > 0) {
      await this.HandleEvents(new YErrorMsg());
    }
  }
  imm_decodeNetFuncValV2(p) {
    let p_ofs = 0;
    let ch = p.charCodeAt(p_ofs) & 255;
    let len = 0;
    let funcVal = [0, 0, 0, 0, 0, 0, 0];
    if (ch < 32 || ch > 32 + 127) {
      return null;
    }
    ch -= 32;
    funcVal[0] = (ch & 64) != 0 ? NOTIFY_V2_6RAWBYTES : NOTIFY_V2_TYPEDDATA;
    ch &= 63;
    while (len < YOCTO_PUBVAL_SIZE) {
      p_ofs++;
      if (p_ofs >= p.length) {
        break;
      }
      let newCh = p.charCodeAt(p_ofs) & 255;
      if (newCh == NOTIFY_NETPKT_STOP) {
        break;
      }
      if (newCh < 32 || newCh > 32 + 127) {
        return null;
      }
      newCh -= 32;
      ch = (ch << 7) + newCh;
      funcVal[len + 1] = ch >>> 5 - len & 255;
      len++;
    }
    return funcVal;
  }
  imm_decodePubVal(int_typeV2, arr_funcval, int_ofs, int_funcvalen) {
    let buffer = "";
    let endp;
    if (int_typeV2 == NOTIFY_V2_6RAWBYTES || int_typeV2 == NOTIFY_V2_TYPEDDATA) {
      let funcValType;
      if (int_typeV2 == NOTIFY_V2_6RAWBYTES) {
        funcValType = PUBVAL_6RAWBYTES;
      } else {
        funcValType = arr_funcval[int_ofs++];
      }
      switch (funcValType) {
        case PUBVAL_LEGACY:
          break;
        case PUBVAL_1RAWBYTE:
        case PUBVAL_2RAWBYTES:
        case PUBVAL_3RAWBYTES:
        case PUBVAL_4RAWBYTES:
        case PUBVAL_5RAWBYTES:
        case PUBVAL_6RAWBYTES:
          for (let i = 0; i < funcValType; i++) {
            let c = arr_funcval[int_ofs++];
            let b = c >>> 4;
            buffer += b.toString(16);
            b = c & 15;
            buffer += b.toString(16);
          }
          return buffer;
        case PUBVAL_C_LONG:
        case PUBVAL_YOCTO_FLOAT_E3:
          let numVal = arr_funcval[int_ofs++];
          numVal += arr_funcval[int_ofs++] << 8;
          numVal += arr_funcval[int_ofs++] << 16;
          numVal += arr_funcval[int_ofs++] << 24;
          if (funcValType == PUBVAL_C_LONG) {
            return String(Math.round(numVal));
          } else {
            buffer = String(Math.round(numVal * 1e3) / 1e6);
            endp = buffer.length;
            while (endp > 0 && buffer[endp - 1] == "0") {
              --endp;
            }
            if (endp > 0 && buffer[endp - 1] == ".") {
              --endp;
              buffer = buffer.substr(0, endp);
            }
            return buffer;
          }
        case PUBVAL_C_FLOAT:
          let v = arr_funcval[int_ofs++];
          v += arr_funcval[int_ofs++] << 8;
          v += arr_funcval[int_ofs++] << 16;
          v += arr_funcval[int_ofs++] << 24;
          let fraction = (v & (1 << 23) - 1) + (1 << 23) * (v >>> 31 | 1);
          let exp = (v >>> 23 & 255) - 127;
          let floatVal = fraction * Math.pow(2, exp - 23);
          buffer = String(Math.round(floatVal * 1e6) / 1e6);
          endp = buffer.length;
          while (endp > 0 && buffer[endp - 1] == "0") {
            --endp;
          }
          if (endp > 0 && buffer[endp - 1] == ".") {
            --endp;
            buffer = buffer.substr(0, endp);
          }
          return buffer;
        default:
          return "?";
      }
      let len = 0;
      buffer = "";
      while (len < YOCTO_PUBVAL_SIZE && len < int_funcvalen) {
        if (arr_funcval[len] == 0) {
          break;
        }
        buffer += String.fromCharCode(arr_funcval[len]);
        len++;
      }
    }
    return buffer;
  }
  imm_decExp(int_pow) {
    const arr = [
      1e-6,
      1e-5,
      1e-4,
      1e-3,
      0.01,
      0.1,
      1,
      10,
      100,
      1e3,
      1e4,
      1e5,
      1e6,
      1e7,
      1e8,
      1e9
    ];
    return arr[int_pow];
  }
  imm_decimalToDouble(val) {
    let negate = false;
    let res;
    let mantis = val & 2047;
    if (mantis == 0)
      return 0;
    if (val > 32767) {
      negate = true;
      val = 65536 - val;
    } else if (val < 0) {
      negate = true;
      val = -val;
    }
    let decexp = this.imm_decExp(val >>> 11);
    if (decexp >= 1) {
      res = mantis * decexp;
    } else {
      res = mantis / Math.round(1 / decexp);
    }
    return negate ? -res : res;
  }
  imm_doubleToDecimal(val) {
    let negate = false;
    let comp, mant;
    let decpow;
    let res;
    if (val == 0) {
      return 0;
    }
    if (val < 0) {
      negate = true;
      val = -val;
    }
    comp = val / 1999;
    decpow = 0;
    while (comp > this.imm_decExp(decpow) && decpow < 15) {
      decpow++;
    }
    mant = val / this.imm_decExp(decpow);
    if (decpow == 15 && mant > 2047) {
      res = (15 << 11) + 2047;
    } else {
      res = (decpow << 11) + Math.round(mant);
    }
    return negate ? -res : res;
  }
  imm_getCalibrationHandler(calibType) {
    return this._calibHandlers[calibType];
  }
  imm_decodeWords(data) {
    let udata = [];
    for (let i = 0; i < data.length; ) {
      let c = data[i];
      let val = 0;
      if (c == "*") {
        i++;
      } else if (c == "X") {
        val = 65535;
        i++;
      } else if (c == "Y") {
        val = 32767;
        i++;
      } else if (c >= "a") {
        let srcpos = udata.length - 1 - (data.charCodeAt(i++) - 97);
        if (srcpos >= 0) {
          val = udata[srcpos];
        }
      } else {
        if (i + 3 > data.length) {
          return udata;
        }
        val = data.charCodeAt(i++) - 48;
        val += data.charCodeAt(i++) - 48 << 5;
        let lastcode = data.charCodeAt(i++);
        if (lastcode == 122)
          lastcode = 92;
        val += lastcode - 48 << 10;
      }
      udata.push(val);
    }
    return udata;
  }
  imm_decodeFloats(data) {
    let idata = [];
    let p = 0;
    let datalen = data.length;
    while (p < datalen) {
      let val = 0;
      let sign = 1;
      let dec = 0;
      let decInc = 0;
      let c = data[p++];
      while (c != "-" && (c < "0" || c > "9")) {
        if (p >= datalen) {
          return idata;
        }
        c = data[p++];
      }
      if (c == "-") {
        if (p >= datalen) {
          return idata;
        }
        sign = -sign;
        c = data[p++];
      }
      while (c >= "0" && c <= "9" || c == ".") {
        if (c == ".") {
          decInc = 1;
        } else if (dec < 3) {
          val = val * 10 + (c.charCodeAt(0) - 48);
          dec += decInc;
        }
        if (p < datalen) {
          c = data[p++];
        } else {
          c = "\0";
        }
      }
      if (dec < 3) {
        if (dec == 0) {
          val *= 1e3;
        } else if (dec == 1) {
          val *= 100;
        } else {
          val *= 10;
        }
      }
      idata.push(sign * val);
    }
    return idata;
  }
  static imm_atoi(str_data) {
    let num = parseInt(str_data);
    if (isNaN(num)) {
      return 0;
    }
    return Math.floor(num);
  }
  imm_bin2str(bin_data) {
    let len = bin_data.length;
    let res = "";
    for (let i = 0; i < len; i += 20) {
      let subdata = bin_data.subarray(i, Math.min(i + 20, len));
      res += String.fromCharCode.apply(null, Array.from(subdata));
    }
    return res;
  }
  imm_str2bin(str_data) {
    let len = str_data.length;
    let res = new Uint8Array(len);
    for (let i = 0; i < len; i++) {
      res[i] = str_data.charCodeAt(i);
    }
    return res;
  }
  imm_bin2hexstr(bin_data) {
    let len = bin_data.length;
    let res = "";
    for (let i = 0; i < len; i++) {
      let n = bin_data[i].toString(16);
      res += n.length < 2 ? "0" + n : n;
    }
    return res.toUpperCase();
  }
  imm_hexstr2bin(str_data) {
    let len = str_data.length >>> 1;
    let res = new Uint8Array(len);
    for (let i = 0; i < len; i++) {
      res[i] = parseInt(str_data.substr(2 * i, 2), 16);
    }
    return res;
  }
  imm_getDevice(str_device) {
    let dev = null;
    let serial;
    if (str_device.substr(0, 7) == "http://" || str_device.substr(0, 5) == "ws://" || str_device.substr(0, 8) == "https://" || str_device.substr(0, 6) == "wss://") {
      serial = this._snByUrl[str_device];
      if (serial != void 0)
        dev = this._devs[serial];
    } else {
      if (this._devs[str_device]) {
        dev = this._devs[str_device];
      } else {
        serial = this._snByName[str_device];
        if (serial) {
          dev = this._devs[serial];
        }
      }
    }
    return dev;
  }
  async _UpdateValueCallbackList(obj_func, bool_add) {
    let index = this._ValueCallbackList.indexOf(obj_func);
    if (bool_add) {
      await obj_func.isOnline();
      if (index < 0) {
        this._ValueCallbackList.push(obj_func);
      }
    } else if (index >= 0) {
      this._ValueCallbackList.splice(index, 1);
    }
  }
  async _UpdateTimedReportCallbackList(obj_func, bool_add) {
    let index = this._TimedReportCallbackList.indexOf(obj_func);
    if (bool_add) {
      await obj_func.isOnline();
      if (index < 0) {
        this._TimedReportCallbackList.push(obj_func);
      }
    } else if (index >= 0) {
      this._TimedReportCallbackList.splice(index, 1);
    }
  }
  imm_functionClass(str_funcid) {
    let dotpos = str_funcid.indexOf(".");
    if (dotpos >= 0)
      str_funcid = str_funcid.substr(dotpos + 1);
    let classlen = str_funcid.length;
    while (str_funcid.substr(classlen - 1, 1) <= "9") {
      classlen--;
    }
    let classname = str_funcid.substr(0, 1).toUpperCase() + str_funcid.substr(1, classlen - 1);
    if (this._fnByType[classname] == void 0) {
      this._fnByType[classname] = new YFunctionType(this, classname);
    }
    return classname;
  }
  imm_reindexDevice(obj_dev) {
    let rootUrl = obj_dev.imm_getRootUrl();
    let serial = obj_dev.imm_getSerialNumber();
    let lname = obj_dev.imm_getLogicalName();
    this._devs[serial] = obj_dev;
    this._snByUrl[rootUrl] = serial;
    if (lname != "")
      this._snByName[lname] = serial;
    this._fnByType["Module"].imm_reindexFunction(serial + ".module", lname, null, null);
    let i, count = obj_dev.imm_functionCount();
    for (i = 0; i < count; i++) {
      let funcid = obj_dev.imm_functionId(i);
      if (funcid != "") {
        let funcname = obj_dev.imm_functionName(i);
        let classname = this.imm_functionClass(funcid);
        this._fnByType[classname].imm_reindexFunction(serial + "." + funcid, funcname, null, null);
      }
    }
  }
  imm_forgetDevice(obj_dev) {
    let rootUrl = obj_dev.imm_getRootUrl();
    let serial = obj_dev.imm_getSerialNumber();
    let lname = obj_dev.imm_getLogicalName();
    delete this._devs[serial];
    delete this._snByUrl[rootUrl];
    if (this._snByName[lname] == serial) {
      delete this._snByName[lname];
    }
    this._fnByType["Module"].imm_forgetFunction(serial + ".module");
    let i, count = obj_dev.imm_functionCount();
    for (i = 0; i < count; i++) {
      let funcid = obj_dev.imm_functionId(i);
      if (funcid != "") {
        let classname = this.imm_functionClass(funcid);
        this._fnByType[classname].imm_forgetFunction(serial + "." + funcid);
      }
    }
  }
  imm_resolveFunction(str_className, str_func) {
    if (Y_BASETYPES[str_className] == void 0) {
      if (this._fnByType[str_className] == void 0) {
        this._fnByType[str_className] = new YFunctionType(this, str_className);
      }
      return this._fnByType[str_className].imm_resolve(str_func);
    }
    let baseType = Y_BASETYPES[str_className];
    let res;
    for (str_className in this._fnByType) {
      if (this._fnByType[str_className].imm_matchBaseType(baseType)) {
        res = this._fnByType[str_className].imm_resolve(str_func);
        if (res.errorType == YAPI_SUCCESS)
          return res;
      }
    }
    return {
      errorType: YAPI_DEVICE_NOT_FOUND,
      errorMsg: "No " + str_className + " [" + str_func + "] found (old firmware?)"
    };
  }
  imm_getFriendlyNameFunction(str_className, str_func) {
    if (Y_BASETYPES[str_className] == void 0) {
      if (this._fnByType[str_className] == void 0) {
        this._fnByType[str_className] = new YFunctionType(this, str_className);
      }
      return this._fnByType[str_className].imm_getFriendlyName(str_func);
    }
    let baseType = Y_BASETYPES[str_className];
    let res;
    for (str_className in this._fnByType) {
      if (this._fnByType[str_className].imm_matchBaseType(baseType)) {
        res = this._fnByType[str_className].imm_getFriendlyName(str_func);
        if (res.errorType == YAPI_SUCCESS)
          return res;
      }
    }
    return {
      errorType: YAPI_DEVICE_NOT_FOUND,
      errorMsg: "No " + str_className + " [" + str_func + "] found (old firmware?)"
    };
  }
  imm_setFunction(str_className, str_func, obj_func) {
    if (this._fnByType[str_className] == void 0) {
      this._fnByType[str_className] = new YFunctionType(this, str_className);
    }
    this._fnByType[str_className].imm_setFunction(str_func, obj_func);
  }
  imm_getFunction(str_className, str_func) {
    if (this._fnByType[str_className] == void 0) {
      this._fnByType[str_className] = new YFunctionType(this, str_className);
    }
    return this._fnByType[str_className].imm_getFunction(str_func);
  }
  async setFunctionValue(str_hwid, str_pubval) {
    let classname = this.imm_functionClass(str_hwid);
    if (this._fnByType[classname].imm_setFunctionValue(str_hwid, str_pubval)) {
      let receivers = this._ValueCallbackList;
      for (let i = 0; i < receivers.length; i++) {
        let fun = receivers[i];
        if (!fun._hwId)
          continue;
        if (fun._hwId == str_hwid) {
          await fun._invokeValueCallback(str_pubval);
        }
      }
    }
  }
  async setTimedReport(str_hwid, float_timestamp, float_duration, arr_report) {
    let classname = this.imm_functionClass(str_hwid);
    let receivers = this._TimedReportCallbackList;
    for (let i = 0; i < receivers.length; i++) {
      let fun = receivers[i];
      if (!fun._hwId)
        continue;
      if (fun._hwId == str_hwid) {
        let dev = this.imm_getDevice(fun._serial);
        if (dev) {
          let sensor = fun;
          let report = await sensor._decodeTimedReport(float_timestamp, float_duration, arr_report);
          await sensor._invokeTimedReportCallback(report);
        }
      }
    }
  }
  async setConfChange(str_serial) {
    let module = YModule.FindModuleInContext(this, str_serial + ".module");
    await module._invokeConfigChangeCallback();
  }
  async setBeaconChange(str_serial, int_beacon) {
    if (this._beacons[str_serial] === void 0 || this._beacons[str_serial] != int_beacon) {
      this._beacons[str_serial] = int_beacon;
      let dev = this.imm_getDevice(str_serial);
      if (dev) {
        dev._beacon = int_beacon;
      }
      let module = YModule.FindModuleInContext(this, str_serial + ".module");
      await module._invokeBeaconCallback(int_beacon);
    }
  }
  imm_getFunctionValue(str_hwid) {
    let classname = this.imm_functionClass(str_hwid);
    return this._fnByType[classname].imm_getFunctionValue(str_hwid);
  }
  imm_getFunctionBaseType(str_hwid) {
    let classname = this.imm_functionClass(str_hwid);
    return this._fnByType[classname].imm_getBaseType();
  }
  imm_getFirstHardwareId(str_className) {
    if (Y_BASETYPES[str_className] == void 0) {
      if (this._fnByType[str_className] == void 0) {
        this._fnByType[str_className] = new YFunctionType(this, str_className);
      }
      return this._fnByType[str_className].imm_getFirstHardwareId();
    }
    let baseType = Y_BASETYPES[str_className];
    let res;
    for (str_className in this._fnByType) {
      if (this._fnByType[str_className].imm_matchBaseType(baseType)) {
        res = this._fnByType[str_className].imm_getFirstHardwareId();
        if (res)
          return res;
      }
    }
    return null;
  }
  imm_getNextHardwareId(str_className, str_hwid) {
    if (Y_BASETYPES[str_className] == void 0) {
      return this._fnByType[str_className].imm_getNextHardwareId(str_hwid);
    }
    let baseType = Y_BASETYPES[str_className];
    let prevclass = this.imm_functionClass(str_hwid);
    let res = this._fnByType[prevclass].imm_getNextHardwareId(str_hwid);
    if (res)
      return res;
    for (str_className in this._fnByType) {
      if (prevclass != "") {
        if (str_className != prevclass)
          continue;
        prevclass = "";
        continue;
      }
      if (this._fnByType[str_className].imm_matchBaseType(baseType)) {
        res = this._fnByType[str_className].imm_getFirstHardwareId();
        if (res)
          return res;
      }
    }
    return null;
  }
  async devRequest(str_device, str_request, obj_body = null, int_tcpchan = 0) {
    let lines = str_request.split("\n");
    let res = new YHTTPRequest(null);
    let lockdev = null;
    let baseUrl;
    if (str_device.substr(0, 7) == "http://" || str_device.substr(0, 5) == "ws://" || str_device.substr(0, 8) == "https://" || str_device.substr(0, 6) == "wss://") {
      baseUrl = str_device;
      if (baseUrl.slice(-1) != "/")
        baseUrl = baseUrl + "/";
      if (lines[0].substr(0, 12) != "GET /not.byn") {
        let serial = this._snByUrl[baseUrl];
        if (serial) {
          lockdev = this._devs[serial];
        }
      }
    } else {
      lockdev = this.imm_getDevice(str_device);
      if (!lockdev) {
        res.errorType = YAPI_DEVICE_NOT_FOUND;
        res.errorMsg = "Device [" + str_device + "] not online";
        return res;
      }
      if (lines[0] == "GET /api.json") {
        return lockdev.requestAPI(this.defaultCacheValidity);
      }
      baseUrl = lockdev.imm_getRootUrl();
    }
    let words = lines[0].split(" ");
    if (words.length < 2) {
      res.errorType = YAPI_INVALID_ARGUMENT;
      res.errorMsg = "Invalid request, not enough words; expected a method name and a URL";
      return res;
    } else if (words.length > 2) {
      res.errorType = YAPI_INVALID_ARGUMENT;
      res.errorMsg = "Invalid request, too many words; make sure the URL is URI-encoded";
      return res;
    }
    let hub = null;
    for (let i = 0; i < this._connectedHubs.length; i++) {
      let hubUrl = this._connectedHubs[i].urlInfo.rootUrl;
      if (baseUrl.slice(0, hubUrl.length) == hubUrl) {
        hub = this._connectedHubs[i];
        break;
      }
    }
    if (!hub && this._knownHubsByUrl[str_device]) {
      hub = this._knownHubsByUrl[str_device];
    }
    if (!hub) {
      res.errorType = YAPI_DEVICE_NOT_FOUND;
      res.errorMsg = "No hub found for URL " + baseUrl;
      return res;
    }
    let method = words[0];
    let devUrl = words[1];
    if (devUrl.substr(0, 1) == "/")
      devUrl = devUrl.substr(1);
    if (baseUrl.substr(0, hub.urlInfo.rootUrl.length) == hub.urlInfo.rootUrl) {
      devUrl = baseUrl.substr(hub.urlInfo.rootUrl.length - 1) + devUrl;
    } else {
      let pos = baseUrl.indexOf("//");
      pos = baseUrl.indexOf("/", pos + 3);
      devUrl = baseUrl.slice(pos) + devUrl;
    }
    if (devUrl.slice(-2) == "&." && !await hub.hasRwAccess()) {
      res.errorType = YAPI_UNAUTHORIZED;
      res.errorMsg = "Access denied: admin credentials required";
      return res;
    }
    let delayedCode = function delayedRequest() {
      return hub.request(method, devUrl, obj_body, int_tcpchan).catch((e) => {
        let res2 = new YHTTPRequest(null);
        res2.errorType = YAPI_IO_ERROR;
        res2.errorMsg = e.message;
        return res2;
      });
    };
    if (lockdev && int_tcpchan == 0) {
      let newPromise = lockdev._pendingQueries.then(delayedCode, delayedCode);
      lockdev._pendingQueries = newPromise;
      res = await newPromise;
    } else {
      res = await delayedCode();
    }
    return res;
  }
  async isReadOnly(str_device) {
    let lockdev = this.imm_getDevice(str_device);
    if (!lockdev) {
      return true;
    }
    let baseUrl = lockdev.imm_getRootUrl();
    let hub = null;
    for (let i = 0; i < this._connectedHubs.length; i++) {
      let hubUrl = this._connectedHubs[i].urlInfo.rootUrl;
      if (baseUrl.slice(0, hubUrl.length) == hubUrl) {
        hub = this._connectedHubs[i];
        break;
      }
    }
    if (!hub || !await hub.hasRwAccess()) {
      return true;
    }
    return false;
  }
  imm_funcDev_internal(str_className, str_func) {
    let res = new YFuncRequest(null);
    let resolve = this.imm_resolveFunction(str_className, str_func);
    if (resolve.errorType != YAPI_SUCCESS) {
      res.errorType = resolve.errorType;
      res.errorMsg = resolve.errorMsg;
    } else {
      str_func = resolve.result;
      let dotpos = str_func.indexOf(".");
      let devid = str_func.substr(0, dotpos);
      let funcid = str_func.substr(dotpos + 1);
      let dev = this.imm_getDevice(devid);
      if (dev == null) {
        res.errorType = YAPI_DEVICE_NOT_FOUND;
        res.errorMsg = "Device [" + devid + "] not found";
      } else {
        res.obj_result = {_expiration: -1, device: dev, deviceid: devid, functionid: funcid, hwid: str_func};
      }
    }
    return res;
  }
  async _funcDev(str_className, str_func) {
    let res = this.imm_funcDev_internal(str_className, str_func);
    if (res.errorType == YAPI_SUCCESS) {
      return res;
    } else if (res.errorType == YAPI_DEVICE_NOT_FOUND && this._connectedHubs.length == 0) {
      res.errorMsg = "Impossible to contact any device because no hub has been registered";
      return res;
    }
    let updRes = await this._updateDeviceList_internal(true, false);
    if (updRes.errorType != YAPI_SUCCESS) {
      res.errorType = updRes.errorType;
      res.errorMsg = updRes.errorMsg;
      return res;
    }
    return this.imm_funcDev_internal(str_className, str_func);
  }
  async funcRequest(str_className, str_func, str_extra, int_msValidity = 0) {
    let funcreq = this.imm_funcDev_internal(str_className, str_func);
    if (funcreq.errorType != YAPI_SUCCESS) {
      funcreq = await this._funcDev(str_className, str_func);
      if (funcreq.errorType != YAPI_SUCCESS) {
        return funcreq;
      }
    }
    let devreq = funcreq.obj_result;
    let loadval = null;
    if (str_extra == "") {
      let yreq = await devreq.device.requestAPI(int_msValidity);
      if (yreq != null) {
        if (yreq.errorType != YAPI_SUCCESS || !yreq.obj_result) {
          let res = new YFuncRequest(null);
          res.errorType = yreq.errorType;
          res.errorMsg = yreq.errorMsg;
          return res;
        }
        loadval = yreq.obj_result[devreq.functionid];
      }
    } else {
      devreq.device.imm_dropCache();
    }
    if (!loadval) {
      if (str_extra == "")
        str_extra = ".json";
      let httpreq = "GET /api/" + devreq.functionid + str_extra;
      let yreq = await this.devRequest(devreq.deviceid, httpreq, null, 0);
      if (yreq.errorType != YAPI_SUCCESS)
        return yreq;
      let replyBuff = yreq.bin_result;
      if (replyBuff.length == 0 && httpreq.indexOf("?") >= 0) {
        funcreq.obj_result = null;
        return funcreq;
      }
      try {
        loadval = JSON.parse(this.imm_bin2str(replyBuff));
      } catch (err) {
      }
    }
    if (!loadval) {
      funcreq.errorType = YAPI_IO_ERROR;
      funcreq.errorMsg = "Request failed, could not parse API value for function " + devreq.hwid;
    } else {
      for (let key in devreq) {
        loadval[key] = devreq[key];
      }
      funcreq.obj_result = loadval;
    }
    return funcreq;
  }
  async HTTPRequest(str_device, str_request) {
    let yreq = await this.devRequest(str_device, str_request, null, 0);
    if (yreq.errorType != YAPI_SUCCESS) {
      return this._throw(yreq.errorType, yreq.errorMsg, null);
    }
    return yreq.bin_result;
  }
  async ForceDeviceRefresh(str_device) {
    let dev = this.imm_getDevice(str_device);
    if (!dev)
      return YAPI_DEVICE_NOT_FOUND;
    let rootUrl = dev.imm_getRootUrl();
    for (let i = 0; i < this._connectedHubs.length; i++) {
      let hub = this._connectedHubs[i];
      let hubUrl = hub.urlInfo.rootUrl;
      if (rootUrl.substr(0, hubUrl.length) === hubUrl) {
        let hubDev = this.imm_getDevice(hubUrl);
        hubDev.imm_dropCache();
        let retcode = await hubDev.refresh();
        if (retcode != YAPI_SUCCESS) {
          return this._throw(retcode, hubDev._lastErrorMsg, retcode);
        }
        let yreq = await hubDev.requestAPI(this.defaultCacheValidity);
        if (yreq.errorType != YAPI_SUCCESS) {
          return yreq.errorType;
        }
        let yellowPages = yreq.obj_result["services"]["yellowPages"];
        dev.imm_updateFromYP(yellowPages);
      }
    }
    dev.imm_dropCache();
    return YAPI_SUCCESS;
  }
  async SetDeviceListValidity_internal(deviceListValidity) {
    this._deviceListValidityMs = deviceListValidity * 1e3;
  }
  async GetDeviceListValidity_internal() {
    return this._deviceListValidityMs / 1e3 >> 0;
  }
  async SetNetworkTimeout_internal(networkMsTimeout) {
    this._networkTimeoutMs = networkMsTimeout;
  }
  async GetNetworkTimeout_internal() {
    return this._networkTimeoutMs;
  }
  async AddUdevRule_internal(force) {
    return "error: Not supported in TypeScript";
  }
  async SetDeviceListValidity(deviceListValidity) {
    return await this.SetDeviceListValidity_internal(deviceListValidity);
  }
  async GetDeviceListValidity() {
    return await this.GetDeviceListValidity_internal();
  }
  async AddUdevRule(force) {
    return await this.AddUdevRule_internal(force);
  }
  async SetNetworkTimeout(networkMsTimeout) {
    return await this.SetNetworkTimeout_internal(networkMsTimeout);
  }
  async GetNetworkTimeout() {
    return await this.GetNetworkTimeout_internal();
  }
  async SetCacheValidity(cacheValidityMs) {
    this.defaultCacheValidity = cacheValidityMs;
  }
  async GetCacheValidity() {
    return this.defaultCacheValidity;
  }
  nextHubInUseInternal(hubref) {
    return this.nextHubInUseInternal_internal(hubref);
  }
  getYHubObj(hubref) {
    let obj;
    obj = this._findYHubFromCache(hubref);
    if (obj == null) {
      obj = new YHub(this, hubref);
      this._addYHubToCache(hubref, obj);
    }
    return obj;
  }
  async GetAPIVersion() {
    return this.imm_GetAPIVersion();
  }
  imm_GetAPIVersion() {
    return "1.10.58391";
  }
  async InitAPI(mode, errmsg) {
    this._detectType = mode;
    if (this.system_env.hasSSDP) {
      if ((mode & this.DETECT_NET) !== 0) {
        await this.TriggerHubDiscovery();
      }
    } else {
    }
    return YAPI_SUCCESS;
  }
  async FreeAPI() {
    for (let serial in this._devs) {
      let lockdev = this._devs[serial];
      let newPromise = lockdev._pendingQueries;
      if (newPromise != null) {
        try {
          await newPromise;
        } catch (e) {
        }
      }
    }
    await this.KillAPI();
  }
  async KillAPI() {
    if (this._ssdpManager) {
      await this._ssdpManager.ySSDPStop();
      this._ssdpManager = null;
    }
    for (let hub of this._connectedHubs) {
      this.imm_dropConnectedHub(hub);
    }
    for (let serial in this._knownHubsBySerial) {
      let hub = this._knownHubsBySerial[serial];
      if (hub._currentState > -5) {
        await hub.detach(YAPI.IO_ERROR, "Connection closed by FreeAPI");
      }
    }
    this.imm_ResetToDefaults();
  }
  async DisableExceptions() {
    this.exceptionsDisabled = true;
  }
  async EnableExceptions() {
    this.exceptionsDisabled = false;
  }
  async LogUnhandledPromiseRejections() {
    this.system_env.hookUnhandledRejection((reason, promise) => {
      this.imm_log("Unhandled Rejection at: Promise ", promise, " reason: ", reason);
    });
  }
  imm_parseRegisteredUrl(str_url) {
    let org_url = str_url;
    let proto = "ws://";
    let user = "";
    let pass = "";
    let port = "4444";
    let host;
    let dom = "";
    let url = "";
    let rooturl = "";
    if (!this._isNodeJS && window && window.navigator && window.navigator.userAgent && /(iPad|iPhone|iPod)/g.test(window.navigator.userAgent)) {
      proto = "http://";
    }
    if (str_url.slice(0, 7) == "http://") {
      proto = "http://";
      str_url = str_url.slice(7);
    } else if (str_url.slice(0, 5) == "ws://") {
      str_url = str_url.slice(5);
    } else if (str_url.slice(0, 8) == "https://") {
      proto = "https://";
      str_url = str_url.slice(8);
    } else if (str_url.slice(0, 6) == "wss://") {
      proto = "wss://";
      str_url = str_url.slice(6);
    }
    str_url = str_url.replace("/not.byn", "");
    let pos = str_url.indexOf("/");
    if (pos > 0) {
      dom = str_url.slice(pos + 1);
      if (dom.length > 0 && dom.slice(-1) != "/") {
        dom += "/";
      }
      str_url = str_url.slice(0, pos);
    }
    url = proto;
    let authpos = str_url.indexOf("@");
    if (authpos >= 0) {
      let auth = str_url.slice(0, authpos);
      let passpos = auth.indexOf(":");
      if (passpos >= 0) {
        user = auth.slice(0, passpos);
        pass = auth.slice(passpos + 1);
        url += user + ":" + pass + "@";
      } else {
        user = auth;
        url += user + "@";
      }
      str_url = str_url.slice(authpos + 1);
    }
    pos = str_url.indexOf(":");
    if (pos < 0) {
      host = str_url;
      if (dom != "") {
        if (proto == "http://") {
          port = "80";
        } else if (proto == "https://") {
          port = "443";
        }
      }
    } else {
      host = str_url.slice(0, pos);
      port = str_url.slice(pos + 1);
    }
    if (host == "callback") {
      if (proto == "ws:") {
        url = "ws://callback:4444/";
      } else {
        url = "http://callback:4444/";
      }
      rooturl = url;
    } else {
      url += host + ":" + port + "/" + dom;
      rooturl = proto + host + ":" + port + "/" + dom;
    }
    return {
      proto,
      user,
      pass,
      host,
      port,
      domain: dom,
      authUrl: url,
      rootUrl: rooturl,
      orgUrl: org_url
    };
  }
  imm_registerHub_internal(urlInfo) {
    let newhub;
    if (urlInfo.proto.slice(0, 3) == "ws:" || urlInfo.proto.slice(0, 4) == "wss:") {
      newhub = this.system_env.getWebSocketHub(this, urlInfo);
    } else {
      newhub = this.system_env.getHttpHub(this, urlInfo);
    }
    if (newhub) {
      this._knownHubsByUrl[urlInfo.rootUrl] = newhub;
    }
    return newhub;
  }
  async RegisterHub(url, errmsg) {
    if (url === "net") {
      if (this.system_env.hasSSDP) {
        this._detectType |= this.DETECT_NET;
        return this.TriggerHubDiscovery();
      } else {
        return this.imm_setErr(errmsg, YAPI_NOT_SUPPORTED, "Network discovery is not possible in a browser", YAPI_NOT_SUPPORTED);
      }
    }
    if (url === "usb") {
      return this.imm_setErr(errmsg, YAPI_NOT_SUPPORTED, "Use the VirtualHub on 127.0.0.1 to access USB devices", YAPI_NOT_SUPPORTED);
    }
    let urlInfo = this.imm_parseRegisteredUrl(url);
    let hub = this.imm_getHub(urlInfo);
    if (!hub) {
      if (this._logLevel >= 3) {
        this.imm_log("Registering new hub: " + urlInfo.rootUrl);
      }
      hub = this.imm_registerHub_internal(urlInfo);
      if (!hub) {
        return this.imm_setErr(errmsg, YAPI_NOT_SUPPORTED, "Unsupported hub protocol: " + urlInfo.proto, YAPI_NOT_SUPPORTED);
      }
    } else {
      if (this._logLevel >= 3) {
        this.imm_log("Registering existing hub: " + urlInfo.rootUrl);
      }
      hub.imm_updateUrl(urlInfo);
    }
    await hub.attach(2);
    let sub_errmsg = new YErrorMsg();
    let retcode = await hub.waitForConnection(this._networkTimeoutMs, sub_errmsg);
    if (retcode != YAPI_SUCCESS) {
      this.imm_dropConnectedHub(hub);
      await hub.detach(retcode, sub_errmsg.msg);
      return this.imm_setErr(errmsg, retcode, sub_errmsg.msg, retcode);
    }
    let yreq = await this._updateDeviceList_internal(true, false);
    if (yreq.errorType != YAPI_SUCCESS) {
      this.imm_dropConnectedHub(hub);
      await hub.detach(yreq.errorType, yreq.errorMsg);
      return this.imm_setErr(errmsg, yreq.errorType, yreq.errorMsg, yreq.errorType);
    }
    return YAPI_SUCCESS;
  }
  async PreregisterHub(url, errmsg) {
    let urlInfo = this.imm_parseRegisteredUrl(url);
    let hub = this.imm_getHub(urlInfo);
    if (!hub) {
      if (this._logLevel >= 3) {
        this.imm_log("Preregistering new hub: " + urlInfo.rootUrl);
      }
      hub = this.imm_registerHub_internal(urlInfo);
      if (!hub) {
        return this.imm_setErr(errmsg, YAPI_NOT_SUPPORTED, "Unsupported hub protocol: " + urlInfo.proto, YAPI_NOT_SUPPORTED);
      }
    } else {
      if (this._logLevel >= 3) {
        this.imm_log("Preregistering existing hub: " + urlInfo.rootUrl);
      }
      hub.imm_updateUrl(urlInfo);
    }
    await hub.attach(1);
    return YAPI_SUCCESS;
  }
  async RegisterHubHttpCallback(incomingMessage, serverResponse, errmsg) {
    let url = "http://callback:4444";
    let urlInfo = this.imm_parseRegisteredUrl(url);
    let hub = this.imm_getHub(urlInfo);
    if (!hub) {
      hub = this.system_env.getHttpCallbackHub(this, urlInfo, incomingMessage, serverResponse);
      if (!hub) {
        return this.imm_setErr(errmsg, YAPI_NOT_SUPPORTED, "HTTP Callback mode is not available in this environment", YAPI_NOT_SUPPORTED);
      }
    }
    await hub.attach(3);
    let sub_errmsg = new YErrorMsg();
    let retcode = await hub.waitForConnection(this._networkTimeoutMs, sub_errmsg);
    if (retcode != YAPI_SUCCESS) {
      this.imm_dropConnectedHub(hub);
      await hub.detach(retcode, sub_errmsg.msg);
      return this.imm_setErr(errmsg, retcode, sub_errmsg.msg, retcode);
    }
    let yreq = await this._updateDeviceList_internal(true, false);
    if (yreq.errorType != YAPI_SUCCESS) {
      await hub.reportFailure(yreq.errorMsg);
      return this.imm_setErr(errmsg, yreq.errorType, yreq.errorMsg, yreq.errorType);
    }
    return YAPI_SUCCESS;
  }
  async RegisterHubWebSocketCallback(ws, errmsg, authpwd) {
    let authstr = authpwd ? "ws:" + authpwd + "@" : "";
    let url = "http://" + authstr + "callback:4444";
    let urlInfo = this.imm_parseRegisteredUrl(url);
    let hub = this.imm_getHub(urlInfo);
    if (!hub) {
      hub = this.system_env.getWebSocketCallbackHub(this, urlInfo, ws);
      if (!hub) {
        return this.imm_setErr(errmsg, YAPI_NOT_SUPPORTED, "WebSocket Callback mode is not available in this environment", YAPI_NOT_SUPPORTED);
      }
    }
    await hub.attach(3);
    let sub_errmsg = new YErrorMsg();
    let retcode = await hub.waitForConnection(this._networkTimeoutMs, sub_errmsg);
    if (retcode != YAPI_SUCCESS) {
      this.imm_dropConnectedHub(hub);
      await hub.detach(retcode, sub_errmsg.msg);
      return this.imm_setErr(errmsg, retcode, sub_errmsg.msg, retcode);
    }
    let yreq = await this._updateDeviceList_internal(true, false);
    if (yreq.errorType != YAPI_SUCCESS) {
      this.imm_dropConnectedHub(hub);
      await hub.detach(yreq.errorType, yreq.errorMsg);
      return this.imm_setErr(errmsg, yreq.errorType, yreq.errorMsg, yreq.errorType);
    }
    return YAPI_SUCCESS;
  }
  async WebSocketJoin(ws, arr_credentials, closeCallback) {
    if (this._connectedHubs.length == 0) {
      return false;
    }
    return this._connectedHubs[0].websocketJoin(ws, arr_credentials, closeCallback);
  }
  async UnregisterHub(url) {
    let urlInfo = this.imm_parseRegisteredUrl(url);
    let hub = this.imm_getHub(urlInfo);
    if (hub) {
      if (hub.hubSerial) {
        let activeHub = this._knownHubsBySerial[hub.hubSerial];
        if (activeHub) {
          hub.imm_forgetUrls();
          hub = activeHub;
          urlInfo = hub.urlInfo;
        }
      }
      if (this._logLevel >= 3) {
        this.imm_log("Unregistering hub " + url + " (" + urlInfo.rootUrl + ")");
      }
      this.imm_dropConnectedHub(hub);
      if (hub.imm_isDisconnected()) {
        if (this._logLevel >= 3) {
          this.imm_log("Hub " + urlInfo.rootUrl + " is already disconnected");
        }
        return;
      }
      let before = this.GetTickCount();
      let disconnected = hub.waitForDisconnection(500);
      if (hub.imm_isDisconnecting()) {
        if (this._logLevel >= 3) {
          this.imm_log("Hub " + urlInfo.rootUrl + " is already disconnecting");
        }
      } else {
        await hub.detach(YAPI.IO_ERROR, "Hub has been unregistered");
      }
      await disconnected;
      hub.imm_forgetUrls();
      if (this._logLevel >= 4) {
        this.imm_log("Disconnected after " + (this.GetTickCount() - before) + " ms");
      }
    }
  }
  async TestHub(url, mstimeout, errmsg) {
    let urlInfo = this.imm_parseRegisteredUrl(url);
    let hub = this.imm_getHub(urlInfo);
    if (!hub) {
      if (this._logLevel >= 4) {
        this.imm_log("Testing new hub: " + urlInfo.rootUrl);
      }
      hub = this.imm_registerHub_internal(urlInfo);
      if (!hub) {
        return this.imm_setErr(errmsg, YAPI_NOT_SUPPORTED, "Unsupported hub protocol: " + urlInfo.proto, YAPI_NOT_SUPPORTED);
      }
    } else {
      if (this._logLevel >= 4) {
        this.imm_log("Testing existing hub: " + urlInfo.rootUrl);
      }
    }
    await hub.attach(0);
    let sub_errmsg = new YErrorMsg();
    let retcode = await hub.waitForConnection(mstimeout, sub_errmsg);
    if (retcode != YAPI_SUCCESS) {
      return this.imm_setErr(errmsg, retcode, sub_errmsg.msg, retcode);
    }
    return YAPI_SUCCESS;
  }
  async UpdateDeviceList(errmsg = null) {
    let yreq = await this._updateDeviceList_internal(false, true);
    if (yreq.errorType !== YAPI_SUCCESS) {
      return this.imm_setErr(errmsg, yreq.errorType, yreq.errorMsg, yreq.errorType);
    }
    return YAPI_SUCCESS;
  }
  async _hubDiscoveryCallback_internal(serial, urlToRegister, urlToUnregister) {
    if (this._hubDiscoveryCallback && urlToRegister) {
      try {
        await this._hubDiscoveryCallback(serial, urlToRegister, urlToUnregister);
      } catch (e) {
        this.imm_log("Exception in hub discovery callback:", e);
      }
    }
    if ((this._detectType & Y_DETECT_NET) !== 0) {
      if (urlToRegister) {
        if (urlToUnregister) {
          await this.UnregisterHub(urlToUnregister);
        }
        await this.PreregisterHub(urlToRegister, new YErrorMsg());
      }
    }
  }
  async TriggerHubDiscovery(errmsg = null) {
    if (!this._ssdpManager) {
      this._ssdpManager = this.system_env.getSSDPManager(this);
      if (!this._ssdpManager)
        return this._lastErrorType;
      await this._ssdpManager.ySSDPStart((serial, newUrl, oldUrl) => {
        this._hubDiscoveryCallback_internal(serial, newUrl, oldUrl);
      });
    } else {
      await this._ssdpManager.ySSDPDiscover();
    }
    return YAPI_SUCCESS;
  }
  async HandleEvents(errmsg = null) {
    return YAPI_SUCCESS;
  }
  async Sleep(ms_duration, errmsg = null) {
    let end = this.GetTickCount() + ms_duration;
    let remaining = ms_duration;
    while (remaining > 0) {
      let waitTime = Math.min(remaining, 25);
      await new Promise((resolve, reject) => {
        setTimeout(resolve, waitTime);
      });
      remaining = end - this.GetTickCount();
    }
    return YAPI_SUCCESS;
  }
  _microSleep_internal() {
    return new Promise(function(resolve, reject) {
      setTimeout(resolve, 3);
    });
  }
  SetTimeout(callback, ms_timeout, args) {
    let endtime = this.GetTickCount() + ms_timeout;
    let setTimeout_internal = async () => {
      let delay = endtime - this.GetTickCount();
      if (delay < 40) {
        if (delay > 3) {
          await new Promise((resolve, reject) => {
            setTimeout(resolve, delay);
          });
        }
        callback.apply(null, args);
      } else {
        if (delay >= 150) {
          await this.UpdateDeviceList();
          delay = Math.min(endtime - YAPI.GetTickCount(), 110);
        }
        await this.Sleep(delay - 20);
        setTimeout_internal();
      }
    };
    setTimeout_internal();
    return YAPI_SUCCESS;
  }
  GetTickCount() {
    return Date.now();
  }
  imm_CheckLogicalName(name) {
    if (name == "")
      return true;
    if (!name)
      return false;
    if (name.length > 19)
      return false;
    return /^[A-Za-z0-9_\-]*$/.test(name);
  }
  async CheckLogicalName(name) {
    return this.imm_CheckLogicalName(name);
  }
  async RegisterDeviceArrivalCallback(arrivalCallback) {
    this._arrivalCallback = arrivalCallback;
  }
  async RegisterDeviceChangeCallback(changeCallback) {
    this._namechgCallback = changeCallback;
  }
  async RegisterDeviceRemovalCallback(removalCallback) {
    this._removalCallback = removalCallback;
  }
  async RegisterHubDiscoveryCallback(hubDiscoveryCallback) {
    if (!this.system_env.hasSSDP) {
      return this._throw(YAPI_NOT_SUPPORTED, "Hub discovery is not supported in this environment", YAPI_NOT_SUPPORTED);
    }
    this._hubDiscoveryCallback = hubDiscoveryCallback;
    return this.TriggerHubDiscovery();
  }
  async RegisterCalibrationHandler(calibrationType, calibrationHandler) {
    this._calibHandlers[calibrationType] = calibrationHandler;
  }
  LinearCalibrationHandler(float_rawValue, int_calibType, arr_calibParams, arr_calibRawValues, arr_calibRefValues) {
    let npt;
    let x = arr_calibRawValues[0];
    let adj = arr_calibRefValues[0] - x;
    let i = 0;
    if (int_calibType < YOCTO_CALIB_TYPE_OFS) {
      npt = Math.min(int_calibType % 10, arr_calibRawValues.length, arr_calibRefValues.length);
    } else {
      npt = arr_calibRefValues.length;
    }
    while (float_rawValue > arr_calibRawValues[i] && ++i < npt) {
      let x2 = x;
      let adj2 = adj;
      x = arr_calibRawValues[i];
      adj = arr_calibRefValues[i] - x;
      if (float_rawValue < x && x > x2) {
        adj = adj2 + (adj - adj2) * (float_rawValue - x2) / (x - x2);
      }
    }
    return float_rawValue + adj;
  }
  imm_yMD5(text) {
    let ctx = new Y_MD5Ctx();
    ctx.addData(this.imm_str2bin(text));
    return ctx.calculate();
  }
  imm_initshaw(str_s, int_ofs, int_pad, int_xinit, _shaw) {
    let ii;
    let j = -1;
    let k = 0;
    let n = str_s.length;
    for (ii = 0; ii < 64; ii++) {
      let i = int_ofs + ii;
      let c = 0;
      if (i < n) {
        c = str_s.charCodeAt(i);
      } else if (int_pad != 0) {
        if ((int_pad & 128) != 0) {
          if (i == n)
            c = int_pad;
        } else {
          if (i == n + 3) {
            c = int_pad;
          } else if (i == n + 4)
            c = 128;
        }
      }
      if (k == 0) {
        j++;
        _shaw[j] = 0;
        k = 32;
      }
      k -= 8;
      _shaw[j] |= c << k;
    }
    if (int_pad != 0) {
      if (int_pad == 128) {
        if (n <= int_ofs + 55) {
          _shaw[15] = 8 * n;
        }
      } else {
        _shaw[15] = 8 * (64 + n + 4);
      }
    }
    if (int_xinit != 0) {
      let xdw = int_xinit << 16 | int_xinit;
      for (j = 0; j < 16; j++) {
        _shaw[j] ^= xdw;
      }
    }
  }
  imm_itershaw(s, _shaw) {
    let a, b, c, d, e, t, k;
    a = s[0];
    b = s[1];
    c = s[2];
    d = s[3];
    e = s[4];
    for (k = 16; k < 80; k++) {
      t = _shaw[k - 3] ^ _shaw[k - 8] ^ _shaw[k - 14] ^ _shaw[k - 16];
      _shaw[k] = t << 1 | t >>> 31;
    }
    for (k = 0; k < 20; k++) {
      t = (a << 5 | a >>> 27) + e + _shaw[k] + 1518500249 + (b & c | ~b & d);
      e = d;
      d = c;
      c = b << 30 | b >>> 2;
      b = a;
      a = t & 4294967295;
    }
    for (k = 20; k < 40; k++) {
      t = (a << 5 | a >>> 27) + e + _shaw[k] + 1859775393 + (b ^ c ^ d);
      e = d;
      d = c;
      c = b << 30 | b >>> 2;
      b = a;
      a = t & 4294967295;
    }
    for (k = 40; k < 60; k++) {
      t = (a << 5 | a >>> 27) + e + _shaw[k] + 2400959708 + (b & c | b & d | c & d);
      e = d;
      d = c;
      c = b << 30 | b >>> 2;
      b = a;
      a = t & 4294967295;
    }
    for (k = 60; k < 80; k++) {
      t = (a << 5 | a >>> 27) + e + _shaw[k] + 3395469782 + (b ^ c ^ d);
      e = d;
      d = c;
      c = b << 30 | b >>> 2;
      b = a;
      a = t & 4294967295;
    }
    _shaw[0] = s[0] + a & 4294967295;
    _shaw[1] = s[1] + b & 4294967295;
    _shaw[2] = s[2] + c & 4294967295;
    _shaw[3] = s[3] + d & 4294967295;
    _shaw[4] = s[4] + e & 4294967295;
  }
  imm_ySHA1(text) {
    let shau = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
    let i, ofs = 0;
    let n = text.length;
    let _shaw = new Uint32Array(80);
    do {
      this.imm_initshaw(text, ofs, 128, 0, _shaw);
      this.imm_itershaw(shau, _shaw);
      for (i = 0; i < 5; i++) {
        shau[i] = _shaw[i];
      }
      ofs += 64;
    } while (n > ofs - 9);
    let res = new Uint8Array(20);
    for (i = 0; i < 20; i++) {
      res[i] = shau[i >>> 2] >>> 24 - 8 * (i & 3) & 255;
    }
    return res;
  }
  async ComputePSK(ssid, pass) {
    let sha1_init = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
    let inner = [], outer = [], shau = [], res = [];
    let iter, pos, k, _shaw;
    _shaw = new Uint32Array(80);
    this.imm_initshaw(pass, 0, 0, 13878, _shaw);
    this.imm_itershaw(sha1_init, _shaw);
    for (k = 0; k < 5; k++) {
      inner[k] = _shaw[k];
    }
    _shaw = new Uint32Array(80);
    this.imm_initshaw(pass, 0, 0, 23644, _shaw);
    this.imm_itershaw(sha1_init, _shaw);
    for (k = 0; k < 5; k++) {
      outer[k] = _shaw[k];
    }
    pos = 0;
    for (k = 0; k < 5; k++) {
      shau[k] = 0;
    }
    _shaw = new Uint32Array(80);
    this.imm_initshaw(ssid, 0, 1, 0, _shaw);
    for (iter = 0; iter < 8192; ) {
      this.imm_itershaw(inner, _shaw);
      _shaw[5] = 2147483648;
      for (k = 6; k < 15; k++) {
        _shaw[k] = 0;
      }
      _shaw[15] = 8 * (64 + 20);
      this.imm_itershaw(outer, _shaw);
      shau[0] ^= _shaw[0];
      shau[1] ^= _shaw[1];
      shau[2] ^= _shaw[2];
      shau[3] ^= _shaw[3];
      shau[4] ^= _shaw[4];
      iter++;
      if ((iter & 4095) == 0) {
        for (k = 0; k < 5 && pos < 32; k++) {
          res[pos++] = shau[k] >>> 24 & 255;
          res[pos++] = shau[k] >>> 16 & 255;
          res[pos++] = shau[k] >>> 8 & 255;
          res[pos++] = shau[k] & 255;
        }
        if (iter == 4096) {
          for (k = 0; k < 5; k++) {
            shau[k] = 0;
          }
          _shaw = new Uint32Array(80);
          this.imm_initshaw(ssid, 0, 2, 0, _shaw);
        }
      }
    }
    let hex = "";
    for (k = 0; k < 32; k++) {
      hex += ("0" + Number(res[k]).toString(16)).slice(-2);
    }
    return hex;
  }
  nextHubInUseInternal_internal(hubref) {
    let nextref = hubref < 0 ? 0 : hubref + 1;
    for (let url in this._knownHubsByUrl) {
      let hub = this._knownHubsByUrl[url];
      if (hub.getHubRef() == nextref) {
        if (hub.imm_isPreOrRegistered()) {
          return this.getYHubObj(nextref);
        } else {
          nextref++;
        }
      }
    }
    return null;
  }
  getGenHub(hubref) {
    for (let url in this._knownHubsByUrl) {
      let hub = this._knownHubsByUrl[url];
      if (hub.getHubRef() == hubref && hub.imm_isPreOrRegistered()) {
        return hub;
      }
    }
    return null;
  }
  _findYHubFromCache(hubref) {
    return this._yhub_cache[hubref];
  }
  _addYHubToCache(hubref, obj) {
    this._yhub_cache[hubref] = obj;
  }
};
YAPIContext.SUCCESS = 0;
YAPIContext.NOT_INITIALIZED = -1;
YAPIContext.INVALID_ARGUMENT = -2;
YAPIContext.NOT_SUPPORTED = -3;
YAPIContext.DEVICE_NOT_FOUND = -4;
YAPIContext.VERSION_MISMATCH = -5;
YAPIContext.DEVICE_BUSY = -6;
YAPIContext.TIMEOUT = -7;
YAPIContext.IO_ERROR = -8;
YAPIContext.NO_MORE_DATA = -9;
YAPIContext.EXHAUSTED = -10;
YAPIContext.DOUBLE_ACCES = -11;
YAPIContext.UNAUTHORIZED = -12;
YAPIContext.RTC_NOT_READY = -13;
YAPIContext.FILE_NOT_FOUND = -14;
YAPIContext.SSL_ERROR = -15;
YAPIContext.RFID_SOFT_ERROR = -16;
YAPIContext.RFID_HARD_ERROR = -17;
YAPIContext.BUFFER_TOO_SMALL = -18;
var YAPI = new YAPIContext();

// obj/full/Api/yocto_api_html.js
var YSystemEnvHtml = class extends YSystemEnv {
  constructor() {
    super(...arguments);
    this.isNodeJS = false;
    this.hasSSDP = false;
  }
  hookUnhandledRejection(handler) {
    window.addEventListener("onunhandledrejection", (event) => {
      let promiseRejectionEvent = event;
      handler(promiseRejectionEvent.reason, promiseRejectionEvent.promise);
    });
  }
  getWebSocketHub(obj_yapi, urlInfo) {
    return new YWebSocketHtmlHub(obj_yapi, urlInfo);
  }
  getHttpHub(obj_yapi, urlInfo) {
    return new YHttpHtmlHub(obj_yapi, urlInfo);
  }
  getWebSocketCallbackHub(obj_yapi, urlInfo, ws) {
    return obj_yapi._throw(YAPI.NOT_SUPPORTED, "WebSocket Callback mode is not available in this environment", null);
  }
  getHttpCallbackHub(obj_yapi, urlInfo, incomingMessage, serverResponse) {
    return obj_yapi._throw(YAPI.NOT_SUPPORTED, "HTTP Callback mode is not available in this environment", null);
  }
  getSSDPManager(obj_yapi) {
    return obj_yapi._throw(YAPI.NOT_SUPPORTED, "Hub discovery is not available in this environment", null);
  }
  loadfile(file) {
    return new Promise((resolve, reject) => {
      let reader = new FileReader();
      reader.onerror = function(evt) {
        reject(evt.target.error);
      };
      reader.onload = function(evt) {
        resolve(new Uint8Array(evt.target.result));
      };
      reader.readAsArrayBuffer(file);
    });
  }
  downloadfile(url) {
    return new Promise((resolve, reject) => {
      let httpRequest = new XMLHttpRequest();
      httpRequest.open("GET", url, true);
      httpRequest.overrideMimeType("text/plain; charset=x-user-defined");
      httpRequest.onreadystatechange = () => {
        if (httpRequest.readyState == 4) {
          if (httpRequest.status != 200 && httpRequest.status != 304) {
            if (httpRequest.status) {
              reject(new Error("HTTP error " + httpRequest.status));
            } else {
              reject(new Error("Unable to complete HTTP request, network down?"));
            }
          } else {
            resolve(YAPI.imm_str2bin(httpRequest.responseText));
          }
        }
      };
      httpRequest.send("");
    });
  }
};
var _HtmlSystemEnv = new YSystemEnvHtml();
YAPI.imm_setSystemEnv(_HtmlSystemEnv);
var YHttpHtmlHub = class extends YHttpHub {
  constructor(yapi, urlInfo) {
    super(yapi, urlInfo);
  }
  imm_makeRequest(method, relUrl, contentType, body, onProgress, onSuccess, onError) {
    let xhr = new XMLHttpRequest();
    let currPos = 0;
    xhr.open(method, this.urlInfo.authUrl + relUrl, true, "", "");
    xhr.setRequestHeader("Content-Type", contentType);
    xhr.overrideMimeType("text/plain; charset=x-user-defined");
    xhr.onreadystatechange = () => {
      if (xhr.readyState >= 3) {
        let httpStatus = xhr.status >> 0;
        if (xhr.readyState == 4 && httpStatus != 200 && httpStatus != 304) {
          if (httpStatus == 401 || httpStatus == 204) {
            this.infoJson.stamp = 0;
            onError(YAPI.UNAUTHORIZED, "Unauthorized access (" + xhr.status + ")");
          } else if (httpStatus == 404) {
            onError(YAPI.FILE_NOT_FOUND, "HTTP request return status 404 (not found)");
          } else if (this.imm_isDisconnecting()) {
            onError(YAPI.IO_ERROR, "Hub is disconnecting");
          } else {
            onError(YAPI.IO_ERROR, "HTTP request failed with status " + xhr.status);
          }
          return;
        }
        if (this.imm_isDisconnecting()) {
          if (this._yapi._logLevel >= 4) {
            this._yapi.imm_log("Dropping request " + relUrl + " because hub is disconnecting");
          }
          return;
        }
        if (onProgress && xhr.responseText) {
          let newlen = xhr.responseText.length;
          if (newlen > currPos) {
            onProgress(xhr.responseText.slice(currPos, newlen));
            currPos = newlen;
          }
        }
        if (onSuccess && xhr.readyState == 4) {
          onSuccess(xhr.responseText);
        }
      }
    };
    xhr.onerror = () => {
      onError(YAPI.IO_ERROR, "HTTP request failed without status");
    };
    xhr.send(body);
    return xhr;
  }
  imm_abortRequest(clientRequest) {
    clientRequest.abort();
  }
};
var YWebSocketHtmlHub = class extends YWebSocketHub {
  imm_webSocketOpen(str_url) {
    let websock = new WebSocket(str_url);
    websock.binaryType = "arraybuffer";
    this.websocket = websock;
  }
  imm_getRandomValues(arr) {
    return window.crypto.getRandomValues(arr);
  }
};

// obj/full/Api/yocto_network.js
var YNetwork = class extends YFunction {
  constructor(yapi, func) {
    super(yapi, func);
    this._readiness = YNetwork.READINESS_INVALID;
    this._macAddress = YNetwork.MACADDRESS_INVALID;
    this._ipAddress = YNetwork.IPADDRESS_INVALID;
    this._subnetMask = YNetwork.SUBNETMASK_INVALID;
    this._router = YNetwork.ROUTER_INVALID;
    this._currentDNS = YNetwork.CURRENTDNS_INVALID;
    this._ipConfig = YNetwork.IPCONFIG_INVALID;
    this._primaryDNS = YNetwork.PRIMARYDNS_INVALID;
    this._secondaryDNS = YNetwork.SECONDARYDNS_INVALID;
    this._ntpServer = YNetwork.NTPSERVER_INVALID;
    this._userPassword = YNetwork.USERPASSWORD_INVALID;
    this._adminPassword = YNetwork.ADMINPASSWORD_INVALID;
    this._httpPort = YNetwork.HTTPPORT_INVALID;
    this._defaultPage = YNetwork.DEFAULTPAGE_INVALID;
    this._discoverable = YNetwork.DISCOVERABLE_INVALID;
    this._wwwWatchdogDelay = YNetwork.WWWWATCHDOGDELAY_INVALID;
    this._callbackUrl = YNetwork.CALLBACKURL_INVALID;
    this._callbackMethod = YNetwork.CALLBACKMETHOD_INVALID;
    this._callbackEncoding = YNetwork.CALLBACKENCODING_INVALID;
    this._callbackTemplate = YNetwork.CALLBACKTEMPLATE_INVALID;
    this._callbackCredentials = YNetwork.CALLBACKCREDENTIALS_INVALID;
    this._callbackInitialDelay = YNetwork.CALLBACKINITIALDELAY_INVALID;
    this._callbackSchedule = YNetwork.CALLBACKSCHEDULE_INVALID;
    this._callbackMinDelay = YNetwork.CALLBACKMINDELAY_INVALID;
    this._callbackMaxDelay = YNetwork.CALLBACKMAXDELAY_INVALID;
    this._poeCurrent = YNetwork.POECURRENT_INVALID;
    this._valueCallbackNetwork = null;
    this.READINESS_DOWN = 0;
    this.READINESS_EXISTS = 1;
    this.READINESS_LINKED = 2;
    this.READINESS_LAN_OK = 3;
    this.READINESS_WWW_OK = 4;
    this.READINESS_INVALID = -1;
    this.MACADDRESS_INVALID = YAPI.INVALID_STRING;
    this.IPADDRESS_INVALID = YAPI.INVALID_STRING;
    this.SUBNETMASK_INVALID = YAPI.INVALID_STRING;
    this.ROUTER_INVALID = YAPI.INVALID_STRING;
    this.CURRENTDNS_INVALID = YAPI.INVALID_STRING;
    this.IPCONFIG_INVALID = YAPI.INVALID_STRING;
    this.PRIMARYDNS_INVALID = YAPI.INVALID_STRING;
    this.SECONDARYDNS_INVALID = YAPI.INVALID_STRING;
    this.NTPSERVER_INVALID = YAPI.INVALID_STRING;
    this.USERPASSWORD_INVALID = YAPI.INVALID_STRING;
    this.ADMINPASSWORD_INVALID = YAPI.INVALID_STRING;
    this.HTTPPORT_INVALID = YAPI.INVALID_UINT;
    this.DEFAULTPAGE_INVALID = YAPI.INVALID_STRING;
    this.DISCOVERABLE_FALSE = 0;
    this.DISCOVERABLE_TRUE = 1;
    this.DISCOVERABLE_INVALID = -1;
    this.WWWWATCHDOGDELAY_INVALID = YAPI.INVALID_UINT;
    this.CALLBACKURL_INVALID = YAPI.INVALID_STRING;
    this.CALLBACKMETHOD_POST = 0;
    this.CALLBACKMETHOD_GET = 1;
    this.CALLBACKMETHOD_PUT = 2;
    this.CALLBACKMETHOD_INVALID = -1;
    this.CALLBACKENCODING_FORM = 0;
    this.CALLBACKENCODING_JSON = 1;
    this.CALLBACKENCODING_JSON_ARRAY = 2;
    this.CALLBACKENCODING_CSV = 3;
    this.CALLBACKENCODING_YOCTO_API = 4;
    this.CALLBACKENCODING_JSON_NUM = 5;
    this.CALLBACKENCODING_EMONCMS = 6;
    this.CALLBACKENCODING_AZURE = 7;
    this.CALLBACKENCODING_INFLUXDB = 8;
    this.CALLBACKENCODING_MQTT = 9;
    this.CALLBACKENCODING_YOCTO_API_JZON = 10;
    this.CALLBACKENCODING_PRTG = 11;
    this.CALLBACKENCODING_INFLUXDB_V2 = 12;
    this.CALLBACKENCODING_INVALID = -1;
    this.CALLBACKTEMPLATE_OFF = 0;
    this.CALLBACKTEMPLATE_ON = 1;
    this.CALLBACKTEMPLATE_INVALID = -1;
    this.CALLBACKCREDENTIALS_INVALID = YAPI.INVALID_STRING;
    this.CALLBACKINITIALDELAY_INVALID = YAPI.INVALID_UINT;
    this.CALLBACKSCHEDULE_INVALID = YAPI.INVALID_STRING;
    this.CALLBACKMINDELAY_INVALID = YAPI.INVALID_UINT;
    this.CALLBACKMAXDELAY_INVALID = YAPI.INVALID_UINT;
    this.POECURRENT_INVALID = YAPI.INVALID_UINT;
    this._className = "Network";
  }
  imm_parseAttr(name, val) {
    switch (name) {
      case "readiness":
        this._readiness = val;
        return 1;
      case "macAddress":
        this._macAddress = val;
        return 1;
      case "ipAddress":
        this._ipAddress = val;
        return 1;
      case "subnetMask":
        this._subnetMask = val;
        return 1;
      case "router":
        this._router = val;
        return 1;
      case "currentDNS":
        this._currentDNS = val;
        return 1;
      case "ipConfig":
        this._ipConfig = val;
        return 1;
      case "primaryDNS":
        this._primaryDNS = val;
        return 1;
      case "secondaryDNS":
        this._secondaryDNS = val;
        return 1;
      case "ntpServer":
        this._ntpServer = val;
        return 1;
      case "userPassword":
        this._userPassword = val;
        return 1;
      case "adminPassword":
        this._adminPassword = val;
        return 1;
      case "httpPort":
        this._httpPort = val;
        return 1;
      case "defaultPage":
        this._defaultPage = val;
        return 1;
      case "discoverable":
        this._discoverable = val;
        return 1;
      case "wwwWatchdogDelay":
        this._wwwWatchdogDelay = val;
        return 1;
      case "callbackUrl":
        this._callbackUrl = val;
        return 1;
      case "callbackMethod":
        this._callbackMethod = val;
        return 1;
      case "callbackEncoding":
        this._callbackEncoding = val;
        return 1;
      case "callbackTemplate":
        this._callbackTemplate = val;
        return 1;
      case "callbackCredentials":
        this._callbackCredentials = val;
        return 1;
      case "callbackInitialDelay":
        this._callbackInitialDelay = val;
        return 1;
      case "callbackSchedule":
        this._callbackSchedule = val;
        return 1;
      case "callbackMinDelay":
        this._callbackMinDelay = val;
        return 1;
      case "callbackMaxDelay":
        this._callbackMaxDelay = val;
        return 1;
      case "poeCurrent":
        this._poeCurrent = val;
        return 1;
    }
    return super.imm_parseAttr(name, val);
  }
  async get_readiness() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.READINESS_INVALID;
      }
    }
    res = this._readiness;
    return res;
  }
  async get_macAddress() {
    let res;
    if (this._cacheExpiration == 0) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.MACADDRESS_INVALID;
      }
    }
    res = this._macAddress;
    return res;
  }
  async get_ipAddress() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.IPADDRESS_INVALID;
      }
    }
    res = this._ipAddress;
    return res;
  }
  async get_subnetMask() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.SUBNETMASK_INVALID;
      }
    }
    res = this._subnetMask;
    return res;
  }
  async get_router() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.ROUTER_INVALID;
      }
    }
    res = this._router;
    return res;
  }
  async get_currentDNS() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.CURRENTDNS_INVALID;
      }
    }
    res = this._currentDNS;
    return res;
  }
  async get_ipConfig() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.IPCONFIG_INVALID;
      }
    }
    res = this._ipConfig;
    return res;
  }
  async set_ipConfig(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("ipConfig", rest_val);
  }
  async get_primaryDNS() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.PRIMARYDNS_INVALID;
      }
    }
    res = this._primaryDNS;
    return res;
  }
  async set_primaryDNS(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("primaryDNS", rest_val);
  }
  async get_secondaryDNS() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.SECONDARYDNS_INVALID;
      }
    }
    res = this._secondaryDNS;
    return res;
  }
  async set_secondaryDNS(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("secondaryDNS", rest_val);
  }
  async get_ntpServer() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.NTPSERVER_INVALID;
      }
    }
    res = this._ntpServer;
    return res;
  }
  async set_ntpServer(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("ntpServer", rest_val);
  }
  async get_userPassword() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.USERPASSWORD_INVALID;
      }
    }
    res = this._userPassword;
    return res;
  }
  async set_userPassword(newval) {
    let rest_val;
    if (newval.length > YAPI.HASH_BUF_SIZE) {
      return this._throw(YAPI.INVALID_ARGUMENT, "Password too long :" + newval, YAPI.INVALID_ARGUMENT);
    }
    rest_val = String(newval);
    return await this._setAttr("userPassword", rest_val);
  }
  async get_adminPassword() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.ADMINPASSWORD_INVALID;
      }
    }
    res = this._adminPassword;
    return res;
  }
  async set_adminPassword(newval) {
    let rest_val;
    if (newval.length > YAPI.HASH_BUF_SIZE) {
      return this._throw(YAPI.INVALID_ARGUMENT, "Password too long :" + newval, YAPI.INVALID_ARGUMENT);
    }
    rest_val = String(newval);
    return await this._setAttr("adminPassword", rest_val);
  }
  async get_httpPort() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.HTTPPORT_INVALID;
      }
    }
    res = this._httpPort;
    return res;
  }
  async set_httpPort(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("httpPort", rest_val);
  }
  async get_defaultPage() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.DEFAULTPAGE_INVALID;
      }
    }
    res = this._defaultPage;
    return res;
  }
  async set_defaultPage(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("defaultPage", rest_val);
  }
  async get_discoverable() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.DISCOVERABLE_INVALID;
      }
    }
    res = this._discoverable;
    return res;
  }
  async set_discoverable(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("discoverable", rest_val);
  }
  async get_wwwWatchdogDelay() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.WWWWATCHDOGDELAY_INVALID;
      }
    }
    res = this._wwwWatchdogDelay;
    return res;
  }
  async set_wwwWatchdogDelay(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("wwwWatchdogDelay", rest_val);
  }
  async get_callbackUrl() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.CALLBACKURL_INVALID;
      }
    }
    res = this._callbackUrl;
    return res;
  }
  async set_callbackUrl(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("callbackUrl", rest_val);
  }
  async get_callbackMethod() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.CALLBACKMETHOD_INVALID;
      }
    }
    res = this._callbackMethod;
    return res;
  }
  async set_callbackMethod(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("callbackMethod", rest_val);
  }
  async get_callbackEncoding() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.CALLBACKENCODING_INVALID;
      }
    }
    res = this._callbackEncoding;
    return res;
  }
  async set_callbackEncoding(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("callbackEncoding", rest_val);
  }
  async get_callbackTemplate() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.CALLBACKTEMPLATE_INVALID;
      }
    }
    res = this._callbackTemplate;
    return res;
  }
  async set_callbackTemplate(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("callbackTemplate", rest_val);
  }
  async get_callbackCredentials() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.CALLBACKCREDENTIALS_INVALID;
      }
    }
    res = this._callbackCredentials;
    return res;
  }
  async set_callbackCredentials(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("callbackCredentials", rest_val);
  }
  async callbackLogin(username, password) {
    let rest_val;
    rest_val = username + ":" + password;
    return await this._setAttr("callbackCredentials", rest_val);
  }
  async get_callbackInitialDelay() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.CALLBACKINITIALDELAY_INVALID;
      }
    }
    res = this._callbackInitialDelay;
    return res;
  }
  async set_callbackInitialDelay(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("callbackInitialDelay", rest_val);
  }
  async get_callbackSchedule() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.CALLBACKSCHEDULE_INVALID;
      }
    }
    res = this._callbackSchedule;
    return res;
  }
  async set_callbackSchedule(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("callbackSchedule", rest_val);
  }
  async get_callbackMinDelay() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.CALLBACKMINDELAY_INVALID;
      }
    }
    res = this._callbackMinDelay;
    return res;
  }
  async set_callbackMinDelay(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("callbackMinDelay", rest_val);
  }
  async get_callbackMaxDelay() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.CALLBACKMAXDELAY_INVALID;
      }
    }
    res = this._callbackMaxDelay;
    return res;
  }
  async set_callbackMaxDelay(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("callbackMaxDelay", rest_val);
  }
  async get_poeCurrent() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.POECURRENT_INVALID;
      }
    }
    res = this._poeCurrent;
    return res;
  }
  static FindNetwork(func) {
    let obj;
    obj = YFunction._FindFromCache("Network", func);
    if (obj == null) {
      obj = new YNetwork(YAPI, func);
      YFunction._AddToCache("Network", func, obj);
    }
    return obj;
  }
  static FindNetworkInContext(yctx, func) {
    let obj;
    obj = YFunction._FindFromCacheInContext(yctx, "Network", func);
    if (obj == null) {
      obj = new YNetwork(yctx, func);
      YFunction._AddToCache("Network", func, obj);
    }
    return obj;
  }
  async registerValueCallback(callback) {
    let val;
    if (callback != null) {
      await YFunction._UpdateValueCallbackList(this, true);
    } else {
      await YFunction._UpdateValueCallbackList(this, false);
    }
    this._valueCallbackNetwork = callback;
    if (callback != null && await this.isOnline()) {
      val = this._advertisedValue;
      if (!(val == "")) {
        await this._invokeValueCallback(val);
      }
    }
    return 0;
  }
  async _invokeValueCallback(value) {
    if (this._valueCallbackNetwork != null) {
      try {
        await this._valueCallbackNetwork(this, value);
      } catch (e) {
        this._yapi.imm_log("Exception in valueCallback:", e);
      }
    } else {
      await super._invokeValueCallback(value);
    }
    return 0;
  }
  async useDHCP(fallbackIpAddr, fallbackSubnetMaskLen, fallbackRouter) {
    return await this.set_ipConfig("DHCP:" + fallbackIpAddr + "/" + String(Math.round(fallbackSubnetMaskLen)) + "/" + fallbackRouter);
  }
  async useDHCPauto() {
    return await this.set_ipConfig("DHCP:");
  }
  async useStaticIP(ipAddress, subnetMaskLen, router) {
    return await this.set_ipConfig("STATIC:" + ipAddress + "/" + String(Math.round(subnetMaskLen)) + "/" + router);
  }
  async ping(host) {
    let content;
    content = await this._download("ping.txt?host=" + host);
    return this._yapi.imm_bin2str(content);
  }
  async triggerCallback() {
    return await this.set_callbackMethod(await this.get_callbackMethod());
  }
  async set_periodicCallbackSchedule(interval, offset) {
    return await this.set_callbackSchedule("every " + interval + "+" + String(Math.round(offset)));
  }
  nextNetwork() {
    let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
    if (resolve.errorType != YAPI.SUCCESS)
      return null;
    let next_hwid = this._yapi.imm_getNextHardwareId(this._className, resolve.result);
    if (next_hwid == null)
      return null;
    return YNetwork.FindNetworkInContext(this._yapi, next_hwid);
  }
  static FirstNetwork() {
    let next_hwid = YAPI.imm_getFirstHardwareId("Network");
    if (next_hwid == null)
      return null;
    return YNetwork.FindNetwork(next_hwid);
  }
  static FirstNetworkInContext(yctx) {
    let next_hwid = yctx.imm_getFirstHardwareId("Network");
    if (next_hwid == null)
      return null;
    return YNetwork.FindNetworkInContext(yctx, next_hwid);
  }
};
YNetwork.READINESS_DOWN = 0;
YNetwork.READINESS_EXISTS = 1;
YNetwork.READINESS_LINKED = 2;
YNetwork.READINESS_LAN_OK = 3;
YNetwork.READINESS_WWW_OK = 4;
YNetwork.READINESS_INVALID = -1;
YNetwork.MACADDRESS_INVALID = YAPI.INVALID_STRING;
YNetwork.IPADDRESS_INVALID = YAPI.INVALID_STRING;
YNetwork.SUBNETMASK_INVALID = YAPI.INVALID_STRING;
YNetwork.ROUTER_INVALID = YAPI.INVALID_STRING;
YNetwork.CURRENTDNS_INVALID = YAPI.INVALID_STRING;
YNetwork.IPCONFIG_INVALID = YAPI.INVALID_STRING;
YNetwork.PRIMARYDNS_INVALID = YAPI.INVALID_STRING;
YNetwork.SECONDARYDNS_INVALID = YAPI.INVALID_STRING;
YNetwork.NTPSERVER_INVALID = YAPI.INVALID_STRING;
YNetwork.USERPASSWORD_INVALID = YAPI.INVALID_STRING;
YNetwork.ADMINPASSWORD_INVALID = YAPI.INVALID_STRING;
YNetwork.HTTPPORT_INVALID = YAPI.INVALID_UINT;
YNetwork.DEFAULTPAGE_INVALID = YAPI.INVALID_STRING;
YNetwork.DISCOVERABLE_FALSE = 0;
YNetwork.DISCOVERABLE_TRUE = 1;
YNetwork.DISCOVERABLE_INVALID = -1;
YNetwork.WWWWATCHDOGDELAY_INVALID = YAPI.INVALID_UINT;
YNetwork.CALLBACKURL_INVALID = YAPI.INVALID_STRING;
YNetwork.CALLBACKMETHOD_POST = 0;
YNetwork.CALLBACKMETHOD_GET = 1;
YNetwork.CALLBACKMETHOD_PUT = 2;
YNetwork.CALLBACKMETHOD_INVALID = -1;
YNetwork.CALLBACKENCODING_FORM = 0;
YNetwork.CALLBACKENCODING_JSON = 1;
YNetwork.CALLBACKENCODING_JSON_ARRAY = 2;
YNetwork.CALLBACKENCODING_CSV = 3;
YNetwork.CALLBACKENCODING_YOCTO_API = 4;
YNetwork.CALLBACKENCODING_JSON_NUM = 5;
YNetwork.CALLBACKENCODING_EMONCMS = 6;
YNetwork.CALLBACKENCODING_AZURE = 7;
YNetwork.CALLBACKENCODING_INFLUXDB = 8;
YNetwork.CALLBACKENCODING_MQTT = 9;
YNetwork.CALLBACKENCODING_YOCTO_API_JZON = 10;
YNetwork.CALLBACKENCODING_PRTG = 11;
YNetwork.CALLBACKENCODING_INFLUXDB_V2 = 12;
YNetwork.CALLBACKENCODING_INVALID = -1;
YNetwork.CALLBACKTEMPLATE_OFF = 0;
YNetwork.CALLBACKTEMPLATE_ON = 1;
YNetwork.CALLBACKTEMPLATE_INVALID = -1;
YNetwork.CALLBACKCREDENTIALS_INVALID = YAPI.INVALID_STRING;
YNetwork.CALLBACKINITIALDELAY_INVALID = YAPI.INVALID_UINT;
YNetwork.CALLBACKSCHEDULE_INVALID = YAPI.INVALID_STRING;
YNetwork.CALLBACKMINDELAY_INVALID = YAPI.INVALID_UINT;
YNetwork.CALLBACKMAXDELAY_INVALID = YAPI.INVALID_UINT;
YNetwork.POECURRENT_INVALID = YAPI.INVALID_UINT;

// obj/full/Api/yocto_files.js
var YFileRecord = class {
  constructor(str_json) {
    this._name = "";
    this._size = 0;
    this._crc = 0;
    const loadval = JSON.parse(str_json);
    this._name = loadval.name;
    this._size = loadval.size;
    this._crc = loadval.crc;
  }
  get_name() {
    return this._name;
  }
  get_size() {
    return this._size;
  }
  get_crc() {
    return this._crc;
  }
};
var YFiles = class extends YFunction {
  constructor(yapi, func) {
    super(yapi, func);
    this._filesCount = YFiles.FILESCOUNT_INVALID;
    this._freeSpace = YFiles.FREESPACE_INVALID;
    this._valueCallbackFiles = null;
    this.FILESCOUNT_INVALID = YAPI.INVALID_UINT;
    this.FREESPACE_INVALID = YAPI.INVALID_UINT;
    this._className = "Files";
  }
  imm_parseAttr(name, val) {
    switch (name) {
      case "filesCount":
        this._filesCount = val;
        return 1;
      case "freeSpace":
        this._freeSpace = val;
        return 1;
    }
    return super.imm_parseAttr(name, val);
  }
  async get_filesCount() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YFiles.FILESCOUNT_INVALID;
      }
    }
    res = this._filesCount;
    return res;
  }
  async get_freeSpace() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YFiles.FREESPACE_INVALID;
      }
    }
    res = this._freeSpace;
    return res;
  }
  static FindFiles(func) {
    let obj;
    obj = YFunction._FindFromCache("Files", func);
    if (obj == null) {
      obj = new YFiles(YAPI, func);
      YFunction._AddToCache("Files", func, obj);
    }
    return obj;
  }
  static FindFilesInContext(yctx, func) {
    let obj;
    obj = YFunction._FindFromCacheInContext(yctx, "Files", func);
    if (obj == null) {
      obj = new YFiles(yctx, func);
      YFunction._AddToCache("Files", func, obj);
    }
    return obj;
  }
  async registerValueCallback(callback) {
    let val;
    if (callback != null) {
      await YFunction._UpdateValueCallbackList(this, true);
    } else {
      await YFunction._UpdateValueCallbackList(this, false);
    }
    this._valueCallbackFiles = callback;
    if (callback != null && await this.isOnline()) {
      val = this._advertisedValue;
      if (!(val == "")) {
        await this._invokeValueCallback(val);
      }
    }
    return 0;
  }
  async _invokeValueCallback(value) {
    if (this._valueCallbackFiles != null) {
      try {
        await this._valueCallbackFiles(this, value);
      } catch (e) {
        this._yapi.imm_log("Exception in valueCallback:", e);
      }
    } else {
      await super._invokeValueCallback(value);
    }
    return 0;
  }
  async sendCommand(command) {
    let url;
    url = "files.json?a=" + command;
    return await this._download(url);
  }
  async format_fs() {
    let json;
    let res;
    json = await this.sendCommand("format");
    res = this.imm_json_get_key(json, "res");
    if (!(res == "ok")) {
      return this._throw(this._yapi.IO_ERROR, "format failed", this._yapi.IO_ERROR);
    }
    return this._yapi.SUCCESS;
  }
  async get_list(pattern) {
    let json;
    let filelist = [];
    let res = [];
    json = await this.sendCommand("dir&f=" + pattern);
    filelist = this.imm_json_get_array(json);
    res.length = 0;
    for (let ii in filelist) {
      res.push(new YFileRecord(filelist[ii]));
    }
    return res;
  }
  async fileExist(filename) {
    let json;
    let filelist = [];
    if (filename.length == 0) {
      return false;
    }
    json = await this.sendCommand("dir&f=" + filename);
    filelist = this.imm_json_get_array(json);
    if (filelist.length > 0) {
      return true;
    }
    return false;
  }
  async download(pathname) {
    return await this._download(pathname);
  }
  async upload(pathname, content) {
    return await this._upload(pathname, content);
  }
  async remove(pathname) {
    let json;
    let res;
    json = await this.sendCommand("del&f=" + pathname);
    res = this.imm_json_get_key(json, "res");
    if (!(res == "ok")) {
      return this._throw(this._yapi.IO_ERROR, "unable to remove file", this._yapi.IO_ERROR);
    }
    return this._yapi.SUCCESS;
  }
  nextFiles() {
    let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
    if (resolve.errorType != YAPI.SUCCESS)
      return null;
    let next_hwid = this._yapi.imm_getNextHardwareId(this._className, resolve.result);
    if (next_hwid == null)
      return null;
    return YFiles.FindFilesInContext(this._yapi, next_hwid);
  }
  static FirstFiles() {
    let next_hwid = YAPI.imm_getFirstHardwareId("Files");
    if (next_hwid == null)
      return null;
    return YFiles.FindFiles(next_hwid);
  }
  static FirstFilesInContext(yctx) {
    let next_hwid = yctx.imm_getFirstHardwareId("Files");
    if (next_hwid == null)
      return null;
    return YFiles.FindFilesInContext(yctx, next_hwid);
  }
};
YFiles.FILESCOUNT_INVALID = YAPI.INVALID_UINT;
YFiles.FREESPACE_INVALID = YAPI.INVALID_UINT;

// obj/full/constants.js
var constants = class {
  static get buildVersion() {
    return "1.10.58391";
  }
  static get deviceScreenWidth() {
    return screen.width * window.devicePixelRatio;
  }
  static get deviceScreenHeight() {
    return screen.height * window.devicePixelRatio;
  }
  static get isPhoneOrTablet() {
    return constants.ScreenDPI > 96 && Math.max(constants.deviceScreenWidth, constants.deviceScreenHeight) / constants.ScreenDPI < 12;
  }
  static get captureSizePolicy() {
    return constants._defaultCaptureSizePolicy;
  }
  static set captureSizePolicy(value) {
    constants._defaultCaptureSizePolicy = value;
  }
  static get dbleClickBringsUpContextMenu() {
    return constants._defaulDbleClickBringsUpContextMenu;
  }
  static set dbleClickBringsUpContextMenu(value) {
    constants._defaulDbleClickBringsUpContextMenu = value;
  }
  static get maxPointsPerGraphSerie() {
    return constants._defaultMaxPointsPerGraphSerie;
  }
  static set maxPointsPerGraphSerie(value) {
    if (value >= 0)
      constants._defaultMaxPointsPerGraphSerie = value >> 0;
  }
  static get maxPointsPerDataloggerSerie() {
    return constants._defaultMaxPointsPerDataloggerSerie;
  }
  static set maxPointsPerDataloggerSerie(value) {
    if (value >= -1)
      constants._defaultMaxPointsPerDataloggerSerie = value >> 0;
  }
  static get maxDataRecordsPerSensor() {
    return constants._defaultMaxDataRecordsPerSensor;
  }
  static set maxDataRecordsPerSensor(value) {
    if (value >= 0)
      constants._defaultMaxDataRecordsPerSensor = value >> 0;
  }
  static get captureWidth() {
    return constants._defaultCaptureWidth;
  }
  static set captureWidth(value) {
    if (value > 0)
      constants._defaultCaptureWidth = value;
  }
  static get captureHeight() {
    return constants._defaultCaptureHeight;
  }
  static set captureHeight(value) {
    if (value > 0)
      constants._defaultCaptureHeight = value;
  }
  static get captureDPI() {
    return constants._defaultCaptureDPI;
  }
  static set captureDPI(value) {
    if (value > 0)
      constants._defaultCaptureDPI = value;
  }
  static get captureType() {
    return constants._defaultCaptureType;
  }
  static set captureType(value) {
    constants._defaultCaptureType = value;
  }
  static get generalFontFamily() {
    return constants.FontFamily;
  }
  static get generalFontSize() {
    return constants.FontSize;
  }
  static get generalSizeCoef() {
    return constants.FontSize / 12;
  }
  static get screenDPI() {
    return constants.ScreenDPI;
  }
  static get guiDPIFactor() {
    return constants.DPIfactor;
  }
  static get guiDPIFactorWasOverriden() {
    return constants.DPIfactorOverriden;
  }
  static get guiDPIFactorIsOverriden() {
    let vs = constants.getCookie(constants.DPIFactorKey);
    if (vs == null)
      return false;
    let v = parseFloat(vs);
    if (v > 0)
      return true;
    return false;
  }
  static get guiDPIFactorOverrideValue() {
    let vs = constants.getCookie(constants.DPIFactorKey);
    if (vs == null)
      return constants.DPIfactor;
    let v = parseFloat(vs);
    if (v > 0)
      return v;
    return constants.DPIfactor;
  }
  static overrideGuiDPIFactor(override, value) {
    if (override && typeof value !== "undefined") {
      constants.setCookie(constants.DPIFactorKey, value.toString(), 3650);
    } else {
      constants.setCookie(constants.DPIFactorKey, "none", 3650);
    }
  }
  static get RunningOnAndroid() {
    return constants.isAndroid;
  }
  static get WindowBackgroundColor() {
    return "#f0f0f0";
  }
  static get WindowBorder() {
    return "1px solid #808080";
  }
  static get WindowPadding() {
    return 2;
  }
  static get WindowInnerBorderColor() {
    return " #A0A0A0";
  }
  static get WindowInnerBackgroundColor() {
    return "#fAfAfA";
  }
  static get WindowInnerBorder() {
    return "1px solid " + constants.WindowInnerBorderColor;
  }
  static get WindowHeaderBackgroundColor() {
    return "#0072ca";
  }
  static get WindowHeaderColor() {
    return "white";
  }
  static get WindowHeaderBorder() {
    return "1px solid #0072ca";
  }
  static get WindowHeaderHeight() {
    return 20;
  }
  static get WindowHeaderFontSize() {
    return 8 * constants.FontSize / 6;
  }
  static get WindowHeaderFontFamily() {
    return constants.FontFamily;
  }
  static get mustCheckForUpdate() {
    return constants._checkForUpdate;
  }
  static set mustCheckForUpdate(value) {
    if (value != constants._checkForUpdate) {
      constants._checkForUpdate = value;
      constants.edited = true;
    }
  }
  static get edited() {
    return constants._edited;
  }
  static set edited(value) {
    if (constants._edited != value) {
      constants._edited = value;
      YWebPage.ShowSaveReminder(value);
    }
  }
  static InitColorHistory(node) {
    let nodes = node.get_childsByIndex();
    for (let i = 0; i < nodes.length; i++) {
      let node2 = nodes[i];
      switch (nodes[i].Name) {
        case "Color":
          try {
            let colordef = node2.Attributes["value"];
            let color = YColor.FromString(colordef);
            if (color != null)
              colorEditor.AddColorToHistory(color);
          } catch (_a) {
          }
      }
    }
  }
  static findDPI() {
    let DPI = 1;
    while (!matchMedia("(max-resolution: " + DPI.toString() + "dpi)").matches) {
      DPI = DPI << 1;
    }
    let a = DPI >> 1;
    let b = DPI;
    while (b - a > 1) {
      let pivot = b + a >> 1;
      if (matchMedia("(max-resolution: " + pivot.toString() + "dpi)").matches) {
        b = pivot;
      } else {
        a = pivot;
      }
    }
    return b * (constants.isAndroid ? window.devicePixelRatio : 1);
  }
  static InitCaptureParams(node) {
    let nodes = node.get_childsByName();
    for (let nodeName in nodes) {
      let node2 = nodes[nodeName];
      let value;
      switch (nodeName) {
        case "Target":
          if ("value" in node2.Attributes) {
            constants._captureTarget = YDataRenderer.CaptureTarget.fromString(YDataRenderer.CaptureTarget, node2.Attributes["value"]);
          }
          break;
        case "Type":
          if ("value" in node2.Attributes) {
            constants._defaultCaptureType = YDataRenderer.CaptureType.fromString(YDataRenderer.CaptureType, node2.Attributes["value"]);
          }
          break;
        case "Size":
          if ("value" in node2.Attributes) {
            constants._defaultCaptureSizePolicy = YDataRenderer.CaptureFormats.fromString(YDataRenderer.CaptureFormats, node2.Attributes["value"]);
          }
          break;
        case "Resolution":
          if ("value" in node2.Attributes) {
            constants.captureDPI = parseInt(node2.Attributes["value"]);
          }
          break;
        case "Width":
          if ("value" in node2.Attributes) {
            constants.captureWidth = value = parseInt(node2.Attributes["value"]);
          }
          break;
        case "Height":
          if ("value" in node2.Attributes) {
            constants.captureHeight = parseInt(node2.Attributes["value"]);
          }
          break;
        case "Folder":
          if ("value" in node2.Attributes) {
            constants._captureFolder = node2.Attributes["value"];
          }
          break;
      }
    }
  }
  static InitUIParams(node) {
    let nodes = node.get_childsByName();
    for (let nodeName in nodes) {
      let node2 = nodes[nodeName];
      switch (nodeName) {
        case "VerticalDragZoom":
          if ("value" in node2.Attributes) {
            YGraph.verticalDragZoomEnabled = node2.Attributes["value"].toUpperCase() == "TRUE";
          }
          break;
        case "DbleClickContextMenu":
          if ("value" in node2.Attributes) {
            constants.dbleClickBringsUpContextMenu = node2.Attributes["value"].toUpperCase() == "TRUE";
          }
          break;
      }
    }
  }
  static InitCheckForUpdateParams(node) {
    let nodes = node.get_childsByName();
    for (let nodeName in nodes) {
      let node2 = nodes[nodeName];
      switch (nodeName) {
        case "checkForUpdate":
          if ("value" in node2.Attributes) {
            constants._checkForUpdate = node2.Attributes["value"].toUpperCase() == "TRUE";
          }
          break;
        case "ignoreBuild":
          if ("value" in node2.Attributes) {
            constants._ignoreBuild = parseInt(node2.Attributes["value"].toUpperCase());
          }
          break;
      }
    }
  }
  static InitMemoryUsageParams(node) {
    let nodes = node.get_childsByName();
    for (let nodeName in nodes) {
      let node2 = nodes[nodeName];
      switch (nodeName) {
        case "maxPointsPerGraphSerie":
          if ("value" in node2.Attributes) {
            let value = parseInt(node2.Attributes["value"]);
            constants.maxPointsPerGraphSerie = value;
            DataSerie.MaxPointsPerSeries = value;
          }
          break;
        case "maxDataRecordsPerSensor":
          if ("value" in node2.Attributes) {
            let value = parseInt(node2.Attributes["value"]);
            if (value >= 0) {
              constants.maxDataRecordsPerSensor = value;
              CustomYSensor.MaxDataRecords = value;
            }
          }
          break;
        case "maxPointsPerDataloggerSerie":
          if ("value" in node2.Attributes) {
            let value = parseInt(node2.Attributes["value"]);
            constants.maxPointsPerDataloggerSerie = value;
            CustomYSensor.MaxLoggerRecords = value;
          }
          break;
        case "deviceListValidity":
          if ("value" in node2.Attributes) {
            let value = parseInt(node2.Attributes["value"]);
            if (value > 0) {
              constants._deviceListValidity = value;
              YAPI.SetDeviceListValidity(value).then();
            }
          }
          break;
      }
    }
  }
  static Init(initData) {
    let nodes = initData.get_childsByName();
    for (let nodeName in nodes) {
      let node = nodes[nodeName];
      switch (nodeName) {
        case "UseUSB":
          if ("value" in node.Attributes) {
            constants._useUSB = node.Attributes["value"].toUpperCase() == "TRUE";
          }
          break;
        case "Colors":
          constants.InitColorHistory(node);
          break;
        case "Capture":
          constants.InitCaptureParams(node);
          break;
        case "UI":
          constants.InitUIParams(node);
          break;
        case "Updates":
          constants.InitCheckForUpdateParams(node);
          break;
        case "MemoryUsage":
          constants.InitMemoryUsageParams(node);
          break;
        case "UseVirtualHub":
          if ("value" in node.Attributes) {
            constants._useVirtualHub = node.Attributes["value"].toUpperCase() == "TRUE";
          }
          break;
        case "Hubs":
          sensorsManager.InitHubList(node);
          break;
      }
    }
  }
  static get CRCTable() {
    if (constants._crcTable != null)
      return constants._crcTable;
    constants._crcTable = [];
    let c;
    var crcTable = [];
    for (var n = 0; n < 256; n++) {
      c = n;
      for (var k = 0; k < 8; k++) {
        c = c & 1 ? 3988292384 ^ c >>> 1 : c >>> 1;
      }
      constants._crcTable[n] = c;
    }
    return constants._crcTable;
  }
  static crc32(str) {
    var crcTable = constants.CRCTable;
    var crc = 0 ^ -1;
    for (var i = 0; i < str.length; i++) {
      crc = crc >>> 8 ^ crcTable[(crc ^ str.charCodeAt(i)) & 255];
    }
    return (crc ^ -1) >>> 0;
  }
  static setCookie(cname, cvalue, exdays) {
    let d = new Date();
    d.setTime(d.getTime() + exdays * 24 * 60 * 60 * 1e3);
    let expires = "expires=" + d.toUTCString();
    document.cookie = cname + "=" + cvalue + ";" + expires + ";path=/";
  }
  static getCookie(cname) {
    let name = cname + "=";
    let decodedCookie = decodeURIComponent(document.cookie);
    let ca = decodedCookie.split(";");
    for (let i = 0; i < ca.length; i++) {
      let c = ca[i];
      while (c.charAt(0) == " ") {
        c = c.substring(1);
      }
      if (c.indexOf(name) == 0) {
        return c.substring(name.length, c.length);
      }
    }
    return null;
  }
  static XMLquote(st) {
    return st.replace("'", "&apos;").replace('"', "&quot;");
  }
  static GetXMLConfiguration() {
    let res = '<Config>\n  <UseUSB value="' + (constants._useUSB ? "TRUE" : "FALSE") + '"/>\n  <UseVirtualHub value="' + (constants._useVirtualHub ? "TRUE" : "FALSE") + '"/>\n  <Hubs>\n';
    res += sensorsManager.getXmlHublist();
    res += "  </Hubs>\n";
    res += "  <Colors>\n";
    for (let i = 0; i < colorEditor.colorHistory.length; i++) {
      res = res + '    <Color value="' + colorEditor.colorHistory[i].toString() + '"/>\n';
    }
    res += "  </Colors>\n";
    res += "  <MemoryUsage>\n";
    res += '    <maxPointsPerGraphSerie value= "' + constants.maxPointsPerGraphSerie.toString() + '"/>\n';
    res += '    <maxDataRecordsPerSensor value= "' + constants.maxDataRecordsPerSensor.toString() + '"/>\n';
    res += '    <maxPointsPerDataloggerSerie value= "' + constants.maxPointsPerDataloggerSerie.toString() + '"/>\n';
    res += '    <deviceListValidity value= "' + constants._deviceListValidity.toString() + '"/>\n';
    res += "  </MemoryUsage>\n";
    res += "  <Capture>\n";
    res += '    <Target value= "' + constants._captureTarget.toString + '"/>\n';
    res += '    <Type value= "' + constants.captureType.toString + '"/>\n';
    res += '    <Size value= "' + constants.captureSizePolicy.toString + '"/>\n';
    res += '    <Resolution value= "' + constants.captureDPI.toString() + '"/>\n';
    res += '    <Folder value= "' + constants.XMLquote(constants._captureFolder) + '"/>\n';
    res += '    <Width value= "' + constants.captureWidth.toString() + '"/>\n';
    res += '    <Height value= "' + constants.captureHeight.toString() + '"/>\n';
    res += "  </Capture>\n";
    res += "  <Updates>\n";
    res += '    <checkForUpdate  value = "' + (constants._checkForUpdate ? "True" : "False") + '"/>\n';
    res += '    <ignoreBuild  value = "' + constants._ignoreBuild.toString() + '"/>\n';
    res += "  </Updates>\n";
    res += "  <UI>\n";
    res += '    <VerticalDragZoom value= "' + (YGraph.verticalDragZoomEnabled ? "True" : "False") + '"/>\n';
    res += '    <DbleClickContextMenu value= "' + (constants.dbleClickBringsUpContextMenu ? "True" : "False") + '"/>\n';
    res += "  </UI>\n";
    res += "</Config>\n";
    return res;
  }
};
constants.DPIFactorKey = "YoctoVisualization4WebDPIFactor";
constants.isAndroid = navigator.userAgent.toLowerCase().indexOf("android") >= 0;
constants.ScreenDPI = constants.findDPI();
constants.FontFamily = "Arial, Helvetica, sans-serif";
constants.DPIfactorCookieValue = constants.getCookie(constants.DPIFactorKey);
constants.DPIfactorOverriden = constants.DPIfactorCookieValue != null;
constants.DPIfactor = constants.DPIfactorOverriden && parseFloat(constants.DPIfactorCookieValue) > 0 ? parseFloat(constants.DPIfactorCookieValue) : constants.isPhoneOrTablet ? Math.round(10 * constants.ScreenDPI / (96 * 1.2)) / 10 : 1;
constants.FontSize = 12 * constants.DPIfactor;
constants._defaultCaptureType = YDataRenderer.CaptureType.PNG;
constants._defaultCaptureWidth = 1024;
constants._defaultCaptureHeight = 1024;
constants._defaultCaptureDPI = 70;
constants._defaultCaptureSizePolicy = YDataRenderer.CaptureFormats.Keep;
constants._defaultMaxPointsPerGraphSerie = 0;
constants._defaultMaxPointsPerDataloggerSerie = 0;
constants._defaultMaxDataRecordsPerSensor = 0;
constants._defaulDbleClickBringsUpContextMenu = false;
constants._useUSB = true;
constants._useVirtualHub = false;
constants._captureTarget = YDataRenderer.CaptureTarget.ToFile;
constants._captureFolder = "";
constants._checkForUpdate = true;
constants._ignoreBuild = 0;
constants._deviceListValidity = 3600;
constants._edited = false;
constants._crcTable = null;

// obj/full/sensorManager.js
var Hub = class {
  static Decrypt(data, loginCypherPassword) {
    if (data == "")
      return "";
    if (data.length % 4)
      return "";
    let buffer = new Uint16Array(data.length >> 2);
    for (let i = 0; i < buffer.length; i++) {
      buffer[i] = parseInt(data.slice(i * 4, i * 4 + 4), 16);
    }
    let checksum = buffer[0];
    for (let i = 1; i < buffer.length - 1; i++) {
      checksum ^= buffer[i];
    }
    if (checksum != buffer[buffer.length - 1])
      return "";
    let res = "";
    for (let i = 0; i < buffer.length - 2; i++) {
      res += String.fromCharCode(buffer[i + 1] & 255 ^ loginCypherPassword.charCodeAt(i % loginCypherPassword.length) ^ buffer[0] + i & 255 ^ (buffer[i + 1] & 2048) >> 11 << ((buffer[i + 1] & 1792) >> 8) ^ (buffer[i + 1] & 32768) >> 15 << ((buffer[i + 1] & 28672) >> 12));
    }
    return res;
  }
  static Encrypt(data, loginCypherPassword) {
    if (data == "")
      return "";
    let buffer = crypto.getRandomValues(new Uint16Array(data.length + 2));
    for (let i = 0; i < data.length; i++) {
      buffer[i + 1] = buffer[i + 1] & 65280 | data.charCodeAt(i) ^ loginCypherPassword.charCodeAt(i % loginCypherPassword.length) ^ buffer[0] + i & 255 ^ (buffer[i + 1] & 2048) >> 11 << ((buffer[i + 1] & 1792) >> 8) ^ (buffer[i + 1] & 32768) >> 15 << ((buffer[i + 1] & 28672) >> 12);
    }
    buffer[buffer.length - 1] = buffer[0];
    for (let i = 1; i < buffer.length - 1; i++) {
      buffer[buffer.length - 1] ^= buffer[i];
    }
    let res = "";
    for (let i = 0; i < buffer.length; i++) {
      res += ("000" + buffer[i].toString(16)).slice(-4).toUpperCase();
    }
    return res;
  }
  static encryptPassword(clearPassword) {
    return clearPassword == "" ? "" : Hub.Encrypt(clearPassword, Hub.loginCypherPassword);
  }
  get hubType() {
    return this._hubType;
  }
  set hubType(value) {
    this._hubType = value;
  }
  get protocol() {
    return this._protocol;
  }
  set protocol(value) {
    this._protocol = value;
  }
  get user() {
    return this._user;
  }
  set user(value) {
    this._user = value;
  }
  get encryptedPassword() {
    return this._password;
  }
  set encryptedPassword(value) {
    this._password = value;
  }
  get clearPassword() {
    return this._password == "" ? "" : Hub.Decrypt(this._password, Hub.loginCypherPassword);
  }
  set clearPassword(value) {
    this._password = value == "" ? "" : Hub.encryptPassword(value);
  }
  get addr() {
    return this._addr;
  }
  set addr(value) {
    this._addr = value;
  }
  get port() {
    return this._port;
  }
  set port(value) {
    this._port = value;
  }
  get removable() {
    return this._removable;
  }
  set removable(value) {
    this._removable = value;
  }
  get path() {
    return this._path;
  }
  set path(value) {
    this._path = value;
  }
  get ConnectionState() {
    return this._state;
  }
  get ConnectionDescription() {
    switch (this._state) {
      case 1:
        return "Connecting..";
      case 2:
        return (this._logicname != "" ? this._logicname : this._netname) + " OK";
      case 3:
        return "Connection failed ";
      default:
        return "Not connected.";
    }
  }
  constructor(hubType, protocol, user, password, clearPassword, addr, port, path, removeable) {
    this._netname = "";
    this._module = null;
    this._logicname = "";
    this._previousURL = "";
    this._previousobfuscatedURL = "";
    this._hubType = 2;
    this._protocol = "";
    this._user = "";
    this._password = "";
    this._addr = "";
    this._port = "";
    this._removable = true;
    this._path = "";
    this._state = 0;
    while (/^\//.test(path)) {
      path = path.slice(1);
    }
    while (/\/$/.test(path)) {
      path = path.slice(0, -1);
    }
    this._hubType = hubType;
    this._protocol = protocol;
    this._user = user;
    this._port = port;
    this._password = clearPassword ? password != "" ? Hub.Encrypt(password, Hub.loginCypherPassword) : "" : password;
    this._addr = addr;
    this._path = path;
    this._removable = typeof removeable === "undefined" ? true : removeable;
  }
  static HubFromXml(subnode) {
    let hubType = 2;
    let protocol = "ws";
    let removable = true;
    if ("protocol" in subnode.Attributes)
      protocol = subnode.Attributes["protocol"];
    let user = "";
    if ("user" in subnode.Attributes)
      user = subnode.Attributes["user"];
    let password = "";
    if ("password" in subnode.Attributes)
      password = subnode.Attributes["password"];
    let port = "";
    if ("port" in subnode.Attributes)
      port = subnode.Attributes["port"];
    let path = "";
    if ("path" in subnode.Attributes)
      path = subnode.Attributes["path"];
    let addr = "";
    if ("addr" in subnode.Attributes)
      addr = subnode.Attributes["addr"];
    if ("removable" in subnode.Attributes)
      removable = subnode.Attributes["removable"].toUpperCase() == "TRUE";
    return new Hub(hubType, protocol, user, password, false, addr, port, path, removable);
  }
  async Connect() {
    let errmsg = new YErrorMsg();
    this._state = 1;
    logForm.log("preregistering  " + this.get_obfuscatedURL());
    if (!YWebPage.readonly)
      configForm.hubStateChanged(this);
    let url = this.get_fullUrl();
    if (await YAPI.PreregisterHub(url, errmsg) != YAPI_SUCCESS) {
      logForm.log("[!] preregistering  " + this.get_obfuscatedURL() + " failed (" + errmsg.msg + ")");
      this._state = 3;
      this._previousURL = "";
      this._previousobfuscatedURL = "";
    } else {
      this._previousURL = url;
      this._previousobfuscatedURL = this.get_obfuscatedURL();
    }
    if (!YWebPage.readonly)
      configForm.hubStateChanged(this);
  }
  async Disconnect() {
    if (this._previousURL == "")
      return;
    logForm.log("Unregistering  " + this._previousobfuscatedURL);
    await YAPI.UnregisterHub(this._previousURL);
    this._previousURL = "";
    this._previousobfuscatedURL = "";
    this._state = 0;
    if (!YWebPage.readonly)
      configForm.hubStateChanged(this);
  }
  arrival(ip, netname, module, logicname) {
    this._state = 2;
    this._netname = netname;
    this._module = module;
    this._logicname = logicname;
    this._state = 2;
    if (!YWebPage.readonly) {
      configForm.hubStateChanged(this);
    }
  }
  get address() {
    return this._addr;
  }
  get_consoleUrl() {
    let fullurl = this._protocol + "://" + this._addr;
    if (this._port != "")
      fullurl = fullurl + ":" + this._port;
    return fullurl;
  }
  toString() {
    return this.get_consoleUrl();
  }
  get_fullUrl() {
    let fullurl = "";
    if (this._protocol != "")
      fullurl = this._protocol + "://";
    if (this._user != "") {
      fullurl = fullurl + this._user;
      if (this._password != "")
        fullurl = fullurl + ":" + Hub.Decrypt(this._password, Hub.loginCypherPassword);
      fullurl = fullurl + "@";
    }
    fullurl = fullurl + this._addr;
    if (this._port != "")
      fullurl = fullurl + ":" + this._port;
    else
      fullurl = fullurl + ":4444";
    fullurl = fullurl + "/";
    if (this._path) {
      fullurl = fullurl + this._path + "/";
    }
    return fullurl;
  }
  get_connexionUrl() {
    let fullurl;
    if (this._protocol != "")
      fullurl = this._protocol + "://";
    else
      fullurl = "ws://";
    fullurl = fullurl + this._addr;
    if (this._port != "")
      fullurl = fullurl + ":" + this._port;
    else
      fullurl = fullurl + ":4444";
    fullurl = fullurl + "/";
    return fullurl.toLowerCase();
  }
  get_obfuscatedURL() {
    let fullurl = "";
    if (this._protocol != "")
      fullurl = this._protocol + "://";
    if (this._user != "") {
      fullurl = fullurl + this._user;
      if (this._password != "")
        fullurl = fullurl + ":#####";
      fullurl = fullurl + "@";
    }
    fullurl = fullurl + this._addr;
    if (this._port != "")
      fullurl = fullurl + ":" + this._port;
    if (this._path != "")
      fullurl = fullurl + "/" + this._path;
    return fullurl;
  }
  XmlCode() {
    let NodeLine = "<Hub ";
    if (this._protocol != "")
      NodeLine = NodeLine + 'protocol="' + constants.XMLquote(this._protocol) + '" ';
    if (this._user != "")
      NodeLine = NodeLine + 'user="' + constants.XMLquote(this._user) + '" ';
    if (this._password != "")
      NodeLine = NodeLine + 'password="' + constants.XMLquote(this._password) + '" ';
    NodeLine = NodeLine + 'addr="' + constants.XMLquote(this._addr) + '" ';
    if (this._port != "")
      NodeLine = NodeLine + 'port="' + constants.XMLquote(this.port) + '" ';
    if (this._path != "")
      NodeLine = NodeLine + 'path="' + constants.XMLquote(this._path) + '" ';
    if (!this._removable)
      NodeLine = NodeLine + 'removable="FALSE" ';
    return NodeLine + "/>";
  }
};
Hub.loginCypherPassword = "+>*X[?_ih$N7wA!}";
var TimedSensorValue = class {
  constructor(DateTime, value) {
    this._DateTime = DateTime;
    this._value = value;
  }
  get DateTime() {
    return this._DateTime;
  }
  get value() {
    return this._value;
  }
};
var AlarmSettings = class {
  static ExecuteCommand(source, command) {
  }
  constructor(index, owner, xmldata) {
    this.index = 0;
    this.Condition = 0;
    this.Source = 0;
    this.Value = 0;
    this.Delay = 15;
    this.Commandline = "";
    this.lastAlarm = new Date(0);
    this.index = index;
    this.parent = owner;
    if (typeof xmldata !== "undefined") {
      if ("Source" in xmldata.Attributes)
        this.Source = parseInt(xmldata.Attributes["Source"]);
      if ("Condition" in xmldata.Attributes)
        this.Condition = parseInt(xmldata.Attributes["Condition"]);
      if ("Value" in xmldata.Attributes)
        this.Value = parseFloat(xmldata.Attributes["Value"]);
      if ("Cmd" in xmldata.Attributes)
        this.Commandline = xmldata.Attributes["Cmd"];
      if ("Delay" in xmldata.Attributes)
        this.Delay = parseInt(xmldata.Attributes["Delay"]);
    }
  }
  getXmlData() {
    return '<Alarm Source="' + this.Source.toString() + '" Condition="' + this.Condition.toString() + '" Value="' + this.Value.toString() + '" Cmd="' + GenericProperties.escapeXml(this.Commandline) + '" Delay="' + this.Delay.toString() + '"/>\n';
  }
  setCondition(condition) {
    this.Condition = condition;
  }
  getCondition() {
    return this.Condition;
  }
  setSource(source) {
    this.Source = source;
  }
  getSource() {
    return this.Source;
  }
  setValue(value) {
    this.Value = value;
  }
  getValue() {
    return this.Value;
  }
  setDelay(value) {
    if (value < 0)
      throw "delay must be a positive value";
    this.Delay = value;
  }
  getDelay() {
    return this.Delay;
  }
  setCommandline(value) {
    this.Commandline = value;
  }
  getCommandline() {
    return this.Commandline;
  }
  check(m) {
    let alarm = false;
    let reason = "";
    let src;
    let SensorValue;
    switch (this.Source) {
      case 1:
        src = "MIN";
        SensorValue = m.get_minValue();
        break;
      case 2:
        src = "MAX";
        SensorValue = m.get_maxValue();
        break;
      default:
        src = "AVG";
        SensorValue = m.get_averageValue();
        break;
    }
    switch (this.Condition) {
      default:
        return;
      case 1:
        reason = ">";
        if (SensorValue > this.Value)
          alarm = true;
        break;
      case 2:
        reason = ">=";
        if (SensorValue >= this.Value)
          alarm = true;
        break;
      case 3:
        reason = "=";
        if (SensorValue == this.Value)
          alarm = true;
        break;
      case 4:
        reason = "<=";
        if (SensorValue <= this.Value)
          alarm = true;
        break;
      case 5:
        reason = "<";
        if (SensorValue < this.Value)
          alarm = true;
        break;
    }
    let now = new Date();
    if (!alarm)
      return;
    if (now.getTime() - this.lastAlarm.getTime() < 1e3 * this.Delay)
      return;
    let source = "ALARM " + (this.index + 1).toString();
    logForm.log(source + " on " + this.parent.get_hardwareId() + "/" + this.parent.get_friendlyName() + " (" + SensorValue.toString() + reason + this.Value.toString() + ")");
    let Execute = this.Commandline;
    Execute = Execute.replace("$SENSORVALUE$", SensorValue.toString());
    Execute = Execute.replace("$HWDID$", this.parent.get_hardwareId());
    Execute = Execute.replace("$NAME$", this.parent.get_friendlyName());
    Execute = Execute.replace("$UNIT$", this.parent.get_unit());
    Execute = Execute.replace("$CONDITION$", reason);
    Execute = Execute.replace("$DATATYPE$", src);
    Execute = Execute.replace("$TRIGGER$", this.Value.toString());
    Execute = Execute.replace("$NOW$", logForm.dateToString(now));
    try {
      Function(Execute)();
    } catch (e) {
      logForm.log("ALARM " + (this.index + 1) + " code (" + Execute + ") caused an exception :" + e.message);
    }
    this.lastAlarm = now;
  }
};
var DataLoggerBoundary = class {
  constructor(start, stop) {
    this._start = 0;
    this._stop = 0;
    this._start = start;
    this._stop = stop;
  }
  get start() {
    return this._start;
  }
  get stop() {
    return this._stop;
  }
};
var MergeSourceRange = class {
  constructor(start, stop) {
    this.MergeSourceStart = 0;
    this.MergeSourceStop = 0;
    this.MergeSourceStart = start;
    this.MergeSourceStop = stop;
  }
};
var CustomYSensor = class {
  get isReadOnly() {
    return this._readonly || !this._online;
  }
  get dataloggerLoadisRunning() {
    return this._dataloggerLoadisRunning;
  }
  get dataloggerLoadProgress() {
    return this._dataloggerLoadProgress;
  }
  setDataloggerLoadProgress(value) {
    this._dataloggerLoadProgress = value;
    for (let i = 0; i < this.FormsToNotify.length; i++) {
      if (this.FormsToNotify[i] instanceof graphWidget) {
        this.FormsToNotify[i].dataLoggerLoadprocessIsRunningNotification(this);
      }
    }
  }
  static get MaxDataRecords() {
    return CustomYSensor._MaxDataRecords;
  }
  static set MaxDataRecords(value) {
    CustomYSensor._MaxDataRecords = value;
  }
  static get MaxLoggerRecords() {
    return CustomYSensor._MaxLoggerRecords;
  }
  static set MaxLoggerRecords(value) {
    CustomYSensor._MaxLoggerRecords = value;
  }
  get_lastAvgValue() {
    if (this._online)
      return this._lastAvgValue;
    return Number.NaN;
  }
  get_lastMaxValue() {
    if (this._online)
      return this._lastMaxValue;
    return Number.NaN;
  }
  get_lastMinValue() {
    if (this._online)
      return this._lastMinValue;
    return Number.NaN;
  }
  async ConfigHasChanged() {
    this.cfgChgNotificationsSupported = true;
    this.mustReloadConfig = true;
    this._online = true;
    await this.reloadConfig();
    await this.forceUpdate();
  }
  constructor(s, name, SensorLocalConfig) {
    this.unit = "";
    this._frequency = "";
    this.resolution = 1;
    this._recording = false;
    this._online = false;
    this.preloadDone = false;
    this.loadDone = false;
    this.cfgChgNotificationsSupported = false;
    this.mustReloadConfig = false;
    this._readonly = false;
    this._plzCancelDataloggerLoading = false;
    this._predloadProcessIsBusy = false;
    this._loadProcessIsBusy = false;
    this.lastGetConfig = 0;
    this.recordedDataLoadProgress = 0;
    this.recordedData = null;
    this.dataLoggerFeature = false;
    this.dataLoggerLoadCompleted = false;
    this.loadFailed = false;
    this.loadCanceled = false;
    this.firstLiveDataTimeStamp = 0;
    this.firstDataloggerTimeStamp = 0;
    this.lastDataTimeStamp = 0;
    this.lastDataSource = "";
    this.consecutiveBadTimeStamp = 0;
    this.minData = [];
    this.curData = [];
    this.maxData = [];
    this.previewMinData = [];
    this.previewCurData = [];
    this.previewMaxData = [];
    this._lastAvgValue = Number.NaN;
    this._lastMinValue = Number.NaN;
    this._lastMaxValue = Number.NaN;
    this._dataloggerLoadisRunning = true;
    this._dataloggerLoadProgress = 0;
    this.dataLoggerStartReadTime = 0;
    this.Alarms = [];
    this.FormsToNotify = [];
    this.sensor = s;
    this.hwdName = name;
    this._friendlyname = name;
    if (s == null)
      return;
    if (SensorLocalConfig != null) {
      let index = 0;
      let childs = SensorLocalConfig.get_childsByIndex();
      for (let i = 0; i < childs.length; i++) {
        let n = childs[i];
        if (n.Name == "Alarm") {
          this.checkAlarmIndex(index);
          this.Alarms[index] = new AlarmSettings(index, this, n);
          index++;
        }
      }
    }
  }
  checkAlarmIndex(index) {
    while (this.Alarms.length < index + 1) {
      this.Alarms.push(new AlarmSettings(this.Alarms.length, this));
    }
  }
  getAlarmCount() {
    return this.Alarms.length;
  }
  setAlarmCondition(index, condition) {
    this.checkAlarmIndex(index);
    this.Alarms[index].setCondition(condition);
  }
  getAlarmCondition(index) {
    this.checkAlarmIndex(index);
    return this.Alarms[index].getCondition();
  }
  setAlarmSource(index, source) {
    this.checkAlarmIndex(index);
    this.Alarms[index].setSource(source);
  }
  getAlarmSource(index) {
    this.checkAlarmIndex(index);
    return this.Alarms[index].getSource();
  }
  setAlarmValue(index, value) {
    this.checkAlarmIndex(index);
    this.Alarms[index].setValue(value);
  }
  getAlarmValue(index) {
    this.checkAlarmIndex(index);
    return this.Alarms[index].getValue();
  }
  setAlarmDelay(index, value) {
    this.checkAlarmIndex(index);
    this.Alarms[index].setDelay(value);
  }
  getAlarmDelay(index) {
    this.checkAlarmIndex(index);
    return this.Alarms[index].getDelay();
  }
  setAlarmCommandline(index, value) {
    this.checkAlarmIndex(index);
    this.Alarms[index].setCommandline(value);
  }
  getAlarmCommandline(index) {
    this.checkAlarmIndex(index);
    return this.Alarms[index].getCommandline();
  }
  GetXmlData() {
    let res = '<Sensor ID="' + this.get_hardwareId() + '">\n';
    for (let i = 0; i < this.getAlarmCount(); i++) {
      res = res + this.Alarms[i].getXmlData();
    }
    res = res + "</Sensor>\n";
    return res;
  }
  get_firstLiveDataTimeStamp() {
    return this.firstLiveDataTimeStamp;
  }
  get_firstDataloggerTimeStamp() {
    return this.firstDataloggerTimeStamp;
  }
  get_lastDataTimeStamp() {
    return this.lastDataTimeStamp;
  }
  async preload_DoWork(arg) {
    if (this._predloadProcessIsBusy) {
      console.log("!!! multiple datalogger load attempt");
      return;
    }
    if (this.dataLoggerLoadCompleted) {
      console.log("!!!  datalogger load attempt although datalogger is already loaded.");
      return;
    }
    this._predloadProcessIsBusy = true;
    logForm.log(this.hwdName + ": preloading data from " + arg.start.toString() + " to " + arg.stop.toString() + "(delta= " + (arg.stop - arg.start).toFixed(3) + ")");
    this.setDataloggerLoadProgress(1);
    this.recordedData = await this.sensor.get_recordedData(arg.start, arg.stop);
    try {
      this.recordedDataLoadProgress = await this.recordedData.loadMore();
    } catch (e) {
      logForm.log(this.hwdName + ": load more caused an exception " + e.message);
    }
    let measures = await this.recordedData.get_preview();
    this.previewMinData = [];
    this.previewCurData = [];
    this.previewMaxData = [];
    let startIndex = 0;
    let errCount = 0;
    let maxErrorCount = 10;
    let lastT = -1;
    if (CustomYSensor._MaxDataRecords > 0 && measures.length > CustomYSensor._MaxDataRecords)
      startIndex = measures.length - CustomYSensor._MaxDataRecords;
    for (let i = startIndex; i < measures.length; i++) {
      let t = measures[i].get_endTimeUTC();
      if (t >= arg.start && t <= arg.stop) {
        this.previewMinData.push(new TimedSensorValue(t, measures[i].get_minValue()));
        this.previewCurData.push(new TimedSensorValue(t, measures[i].get_averageValue()));
        this.previewMaxData.push(new TimedSensorValue(t, measures[i].get_maxValue()));
        if (t < lastT && errCount < maxErrorCount) {
          logForm.log(this.hwdName + " preloading warning:  timestamp going back in time " + t + "<" + lastT + (errCount < maxErrorCount - 1 ? "" : ", further similar errors wont be logged."));
          errCount++;
        } else if (t == lastT && errCount < maxErrorCount) {
          logForm.log(this.hwdName + " preloading warning: duplicate timestamp  " + t + (errCount < maxErrorCount - 1 ? "" : ", further similar errors wont be logged."));
          errCount++;
        }
        lastT = t;
      }
    }
    if (this.previewCurData.length > 1) {
      let a = this.previewCurData[0].DateTime;
      let b = this.previewCurData[this.previewCurData.length - 1].DateTime;
      logForm.log(this.hwdName + ": preloaded data from " + a.toString() + " to " + b.toString() + " (delta=" + (b - a).toFixed(3) + ")");
      if (CustomYSensor._MaxLoggerRecords > 0 && arg.start == 0) {
        let list = await this.recordedData.get_privateDataStreams();
        let index = list.length - 1;
        let totalRecords = 0;
        while (index > 0 && totalRecords < CustomYSensor._MaxLoggerRecords) {
          totalRecords += await list[index].get_rowCount();
          this.dataLoggerStartReadTime = await list[index].get_startTimeUTC();
          index--;
        }
        let n = 0;
        while (n < this.previewMinData.length && this.previewMinData[n].DateTime < this.dataLoggerStartReadTime) {
          n++;
        }
        if (n > 1) {
          this.previewMinData.splice(0, n - 1);
          this.previewCurData.splice(0, n - 1);
          this.previewMaxData.splice(0, n - 1);
        }
      }
    }
    this.preload_Completed(arg);
  }
  findMergeBoundaries(previewMinData) {
    let MergeSourceStart = 0;
    let MergeSourceStop = 0;
    if (this.minData.length > 0) {
      while (MergeSourceStart < this.minData.length && previewMinData[0].DateTime > this.minData[MergeSourceStart].DateTime) {
        MergeSourceStart++;
      }
      MergeSourceStop = MergeSourceStart;
      while (MergeSourceStop < this.minData.length && previewMinData[previewMinData.length - 1].DateTime >= this.minData[MergeSourceStop].DateTime) {
        MergeSourceStop++;
      }
    }
    return new MergeSourceRange(MergeSourceStart, MergeSourceStop);
  }
  preload_Completed(arg) {
    if (this.previewMinData == null)
      return;
    logForm.log(this.hwdName + " : datalogger preloading completed (" + this.previewMinData.length + " rows)");
    if (this.previewMinData.length > 1) {
      let it = this.findMergeBoundaries(this.previewMinData);
      let insertIndex = it.MergeSourceStart;
      let deleteCount = it.MergeSourceStop - it.MergeSourceStart;
      this.minData = this.minData.slice(0, insertIndex).concat(this.previewMinData, this.minData.slice(insertIndex + deleteCount));
      this.curData = this.curData.slice(0, insertIndex).concat(this.previewCurData, this.curData.slice(insertIndex + deleteCount));
      this.maxData = this.maxData.slice(0, insertIndex).concat(this.previewMaxData, this.maxData.slice(insertIndex + deleteCount));
      for (let i = 0; i < this.FormsToNotify.length; i++) {
        if (this.FormsToNotify[i] instanceof graphWidget) {
          this.FormsToNotify[i].SensorNewDataBlock(this, it.MergeSourceStart, it.MergeSourceStart + this.previewMinData.length - 1, 0, true);
        }
      }
    }
    let count = this.curData.length;
    if (count > 0) {
      if (this.curData[count - 1].DateTime > this.lastDataTimeStamp) {
        this.lastDataTimeStamp = this.curData[count - 1].DateTime;
        this.lastDataSource = "last preload timestamp";
      }
    }
    logForm.log(this.hwdName + " : start datalogger loading");
    this._predloadProcessIsBusy = false;
    this.load_DoWork(arg).then();
  }
  get_frequency() {
    return this._frequency;
  }
  async updateFrequncy(frequencyToSet) {
    if (await this.sensor.isOnline()) {
      this._frequency = frequencyToSet;
      await this.sensor.set_reportFrequency(this._frequency);
      let lfreq = await this.sensor.get_logFrequency();
      try {
        if (lfreq != "OFF")
          await this.sensor.set_logFrequency(this._frequency);
        let m = await this.sensor.get_module();
        await m.saveToFlash();
      } catch (e) {
        logForm.log("failed to change " + this.hwdName + " log frequency (" + e.message + ")");
      }
    } else {
      this._online = false;
    }
  }
  set_frequency(frequencyToSet) {
    if (this._online) {
      this.updateFrequncy(frequencyToSet).then();
    }
  }
  get_recording() {
    return this._recording;
  }
  set_recording(recordingStatus) {
    this.updaterecording(recordingStatus).then();
  }
  async updaterecording(recordingStatus) {
    if (!this.dataLoggerFeature)
      return;
    if (await this.sensor.isOnline()) {
      this._recording = recordingStatus;
      try {
        await this.sensor.set_logFrequency(this._recording ? this._frequency : "OFF");
        let module = await this.sensor.get_module();
        let serial = await module.get_serialNumber();
        let dl = YDataLogger.FindDataLogger(serial + ".dataLogger");
        await dl.set_recording(this._recording ? YDataLogger.RECORDING_ON : YDataLogger.RECORDING_OFF);
        await dl.set_autoStart(this._recording ? YDataLogger.AUTOSTART_ON : YDataLogger.AUTOSTART_OFF);
        await module.saveToFlash();
      } catch (e) {
        logForm.log("failed to change " + this.hwdName + " recording (" + e.message + ")");
      }
    } else {
      this._online = false;
    }
  }
  reportDataloggerLoadProgress(progress) {
  }
  async load_DoWork(arg) {
    if (this._loadProcessIsBusy)
      return;
    this._loadProcessIsBusy = true;
    if (this.dataLoggerLoadCompleted)
      return;
    logForm.log(this.hwdName + " loading main data from datalogger");
    if (this.dataLoggerStartReadTime > 0) {
      this.recordedData = await this.sensor.get_recordedData(this.dataLoggerStartReadTime, 0);
    }
    let errCount = 0;
    let maxErrorCount = 10;
    let lastT = -1;
    let lastProgress = this.recordedDataLoadProgress;
    while (this.recordedDataLoadProgress < 100) {
      if (this._plzCancelDataloggerLoading) {
        this.loadDone = true;
        this.loadFailed = false;
        this.loadCanceled = true;
        this.setDataloggerLoadProgress(100);
        break;
      }
      try {
        this.recordedDataLoadProgress = await this.recordedData.loadMore();
      } catch (Exception) {
        this.loadFailed = true;
        return;
      }
      if (lastProgress != this.recordedDataLoadProgress) {
        lastProgress = this.recordedDataLoadProgress;
        let p = lastProgress;
        if (p < 1)
          p = 1;
        if (p > 99)
          p = 99;
        this.setDataloggerLoadProgress(p < 1 ? 1 : p > 99 ? 99 : p);
      }
      if (this.recordedDataLoadProgress - lastProgress >= 2) {
        lastProgress = this.recordedDataLoadProgress;
      }
    }
    let measures = await this.recordedData.get_measures();
    this.previewMinData = [];
    this.previewCurData = [];
    this.previewMaxData = [];
    for (let i = 0; i < measures.length; i++) {
      let t = measures[i].get_endTimeUTC();
      if (t >= arg.start && t <= arg.stop) {
        if (t < lastT && errCount < maxErrorCount) {
          logForm.log(this.hwdName + " loading warning:  timestamp going back in time " + t + "<" + lastT + (errCount < maxErrorCount - 1 ? "" : ", further similar errors wont be logged."));
          errCount++;
        } else if (t == lastT && errCount < maxErrorCount) {
          logForm.log(this.hwdName + " loading warning: duplicate timestamp  " + t + (errCount < maxErrorCount - 1 ? "" : ", further similar errors wont be logged."));
          errCount++;
        }
        lastT = t;
        if (this.previewMinData.length == 0 || t > this.previewMinData[this.previewMinData.length - 1].DateTime) {
          this.previewMinData.push(new TimedSensorValue(t, measures[i].get_minValue()));
          this.previewCurData.push(new TimedSensorValue(t, measures[i].get_averageValue()));
          this.previewMaxData.push(new TimedSensorValue(t, measures[i].get_maxValue()));
        }
      } else {
        let d = new Date(t * 1e3);
        let d1 = new Date(arg.start * 1e3);
        let d2 = new Date(arg.stop * 1e3);
        let dstr = d.toLocaleDateString() + " " + d.toLocaleTimeString();
        let d1str = d1.toLocaleDateString() + " " + d1.toLocaleTimeString();
        let d2str = d2.toLocaleDateString() + " " + d2.toLocaleTimeString();
        logForm.log(this.hwdName + " note: skipping measure at " + dstr + ", not in range " + d1str + " ... " + d2str);
      }
    }
    if (CustomYSensor._MaxDataRecords > 0)
      this.previewDataCleanUp();
    for (let i = 0; i < this.previewMinData.length - 1; i++) {
      if (this.previewMinData[i].DateTime >= this.previewMinData[i + 1].DateTime) {
        throw "Time-stamp inconsistency";
      }
    }
    if (this.previewCurData.length > 1) {
      logForm.log(this.hwdName + " loaded " + this.previewCurData.length.toString() + "/" + measures.length.toString() + " records over " + (this.previewCurData[this.previewCurData.length - 1].DateTime - this.previewCurData[0].DateTime).toFixed(3) + " sec, last timed stamp was " + this.previewCurData[this.previewCurData.length - 1].DateTime);
    } else {
      logForm.log(this.hwdName + " loaded " + this.previewCurData.length.toString() + " records");
    }
    if (this.previewMinData.length > 2) {
      let lastPreviewTimeStamp = this.previewMinData[this.previewMinData.length - 1].DateTime;
      let it = this.findMergeBoundaries(this.previewMinData);
      let deleteCount = it.MergeSourceStop - it.MergeSourceStart;
      this.minData = this.minData.slice(0, it.MergeSourceStart).concat(this.previewMinData, this.minData.slice(it.MergeSourceStart + deleteCount));
      this.curData = this.curData.slice(0, it.MergeSourceStart).concat(this.previewCurData, this.curData.slice(it.MergeSourceStart + deleteCount));
      this.maxData = this.maxData.slice(0, it.MergeSourceStart).concat(this.previewMaxData, this.maxData.slice(it.MergeSourceStart + deleteCount));
      this.firstDataloggerTimeStamp = this.curData[0].DateTime;
    }
    this.loadDone = true;
    this.loadFailed = false;
    let count = this.curData.length;
    if (count > 0) {
      if (this.curData[count - 1].DateTime > this.lastDataTimeStamp) {
        this.lastDataTimeStamp = this.curData[count - 1].DateTime;
        this.lastDataSource = "end of datalogger";
      }
    }
    this.load_Completed();
  }
  load_Completed() {
    logForm.log(this.hwdName + ".loadcompleted()");
    if (this.loadFailed) {
      logForm.log(this.hwdName + " : datalogger loading failed");
      this._loadProcessIsBusy = false;
      return;
    }
    if (this.loadCanceled) {
      logForm.log(this.hwdName + " : datalogger loading was canceled");
      this.previewMinData = [];
      this.previewCurData = [];
      this.previewMaxData = [];
      this.loadCanceled = false;
      this._loadProcessIsBusy = false;
      this.preloadDone = false;
      this.loadDone = false;
      return;
    }
    if (this.previewCurData.length <= 2) {
      this.preloadDone = false;
      this.loadDone = false;
    }
    logForm.log(this.hwdName + " : datalogger loading completed  (" + this.previewMinData.length + " rows)");
    this.resetDataloggerLoader();
    this.dataLoggerLoadCompleted = true;
    for (let i = 0; i < this.FormsToNotify.length; i++) {
      if (this.FormsToNotify[i] instanceof graphWidget) {
        this.FormsToNotify[i].DataloggerCompleted(this);
      }
    }
    this.setDataloggerLoadProgress(100);
  }
  get dataloggerWasUsed() {
    return this.dataLoggerLoadCompleted;
  }
  dataCleanUp() {
    if (CustomYSensor._MaxDataRecords <= 0)
      return;
    let newsize = CustomYSensor._MaxDataRecords * 90 / 100 >> 0;
    if (this.curData != null && CustomYSensor._MaxDataRecords < this.curData.length) {
      this.minData.splice(0, this.minData.length - newsize);
      this.curData.splice(0, this.curData.length - newsize);
      this.maxData.splice(0, this.maxData.length - newsize);
    }
  }
  previewDataCleanUp() {
    if (CustomYSensor._MaxDataRecords <= 0)
      return;
    let newsize = CustomYSensor._MaxDataRecords * 90 / 100 >> 0;
    if (this.previewMinData != null && CustomYSensor._MaxDataRecords < this.previewMinData.length) {
      this.previewMinData.splice(0, this.previewMinData.length - newsize);
      this.previewCurData.splice(0, this.previewCurData.length - newsize);
      this.previewMaxData.splice(0, this.previewMaxData.length - newsize);
    }
  }
  stopDataloggerloading() {
  }
  isOnline() {
    return this._online;
  }
  async reloadConfig() {
    if (this._online) {
      let ison = await this.sensor.isOnline();
      if (ison) {
        try {
          this.unit = await this.sensor.get_unit();
          this._friendlyname = await this.sensor.get_friendlyName();
          this.resolution = await this.sensor.get_resolution();
          this._frequency = await this.sensor.get_reportFrequency();
          this._readonly = await this.sensor.isReadOnly();
          if (this.dataLoggerFeature) {
            this._recording = await this.sensor.get_logFrequency() != "OFF";
          } else {
            this._recording = false;
          }
          this.lastGetConfig = YAPI.GetTickCount();
          this.mustReloadConfig = false;
        } catch (e) {
          logForm.log("reload configuration error: " + e.message);
        }
      } else {
        this._online = false;
      }
    }
  }
  get_unit() {
    if (this.cfgChgNotificationsSupported && !this.mustReloadConfig)
      return this.unit;
    if (this.lastGetConfig <= 0 || YAPI.GetTickCount() - this.lastGetConfig > 5e3)
      this.reloadConfig().then();
    return this.unit;
  }
  get_resolution() {
    if (this.cfgChgNotificationsSupported && !this.mustReloadConfig)
      return this.resolution;
    if (this.lastGetConfig <= 0 || YAPI.GetTickCount() - this.lastGetConfig > 5e3)
      this.reloadConfig().then();
    return this.resolution;
  }
  resetDataloggerLoader() {
    this._predloadProcessIsBusy = false;
    this._loadProcessIsBusy = false;
    this.dataLoggerLoadCompleted = false;
    this.preloadDone = false;
    this.loadDone = false;
    this._dataloggerLoadisRunning = false;
    this.previewMinData = [];
    this.previewCurData = [];
    this.previewMaxData = [];
  }
  loadDatalogger(start, stop) {
    if (!this.dataLoggerFeature)
      return;
    if (this._predloadProcessIsBusy)
      return;
    if (this._loadProcessIsBusy)
      return;
    if (constants.maxPointsPerDataloggerSerie < 0) {
      logForm.log(this.hwdName + " : datalogger access is disabled");
      return;
    }
    if (!this.preloadDone && this.dataLoggerFeature) {
      logForm.log(this.hwdName + " : start datalogger preloading");
      this.preload_DoWork(new DataLoggerBoundary(start, stop)).then();
    }
  }
  async arrival(dataloggerOn) {
    await this.configureSensor();
    this._online = true;
    await this.reloadConfig();
    let dt = await this.sensor.get_dataLogger();
    if (dt == null)
      return;
    let now = Math.floor(new Date().getTime() / 1e3);
    if (this.curData.length > 0 && this.dataLoggerLoadCompleted) {
      let end = await dt.get_timeUTC();
      let start = this.curData[this.curData.length - 1].DateTime;
      let duration = end - start;
      if (duration == 0) {
        start = this.curData[this.curData.length - 2].DateTime;
        duration = end - start;
      }
      if (duration > 1) {
        logForm.log(this.hwdName + " is back online trying to load " + duration.toFixed(3) + " sec of data from datalogger ");
        this.resetDataloggerLoader();
        this.loadDatalogger(start, end);
      }
    }
    if (this.isReadOnly)
      logForm.log(this.hwdName + " is read only");
    this.notifySensorStateChange();
    this.notifySensorArrival();
  }
  async startDataloggerload(source) {
    if (!this.dataLoggerFeature)
      return;
    if (this.sensor == null)
      return;
    if (this._loadProcessIsBusy)
      return;
    if (this._predloadProcessIsBusy)
      return;
    if (this.dataLoggerLoadCompleted) {
      source.DataloggerCompleted(this);
      return;
    }
    let dt = await this.sensor.get_dataLogger();
    if (dt == null)
      return;
    this.loadDatalogger(0, await dt.get_timeUTC());
  }
  notifySensorArrival() {
    for (let i = 0; i < this.FormsToNotify.length; i++) {
      this.FormsToNotify[i].SensorArrivalcallback(this);
    }
  }
  notifySensorStateChange() {
    for (let i = 0; i < this.FormsToNotify.length; i++) {
      this.FormsToNotify[i].SensorStateChangedcallback(this);
    }
  }
  removal() {
    this._online = false;
    this.forceUpdate();
    this.notifySensorStateChange();
  }
  async configureSensor() {
    logForm.log("Configuring  " + this.hwdName);
    if (!await this.sensor.isOnline())
      return;
    let mustSave = false;
    let olfreq = await this.sensor.get_logFrequency();
    let orfreq = await this.sensor.get_reportFrequency();
    let readOnly = await this.sensor.isReadOnly();
    let lfreq = olfreq;
    let rfreq = orfreq;
    let m = await this.sensor.get_module();
    for (let i = 0; i < await m.functionCount(); i++) {
      if (await m.functionType(i) == "DataLogger") {
        this.dataLoggerFeature = true;
      }
    }
    try {
      if (this.dataLoggerFeature) {
        let m2 = await this.sensor.get_module();
        let dl = YDataLogger.FindDataLogger(await m2.get_serialNumber() + ".dataLogger");
        let dataloggerOn = await dl.get_recording() != YDataLogger.RECORDING_OFF;
        let dataloggerAS = await dl.get_autoStart() != YDataLogger.AUTOSTART_OFF;
        if (!dataloggerOn) {
          lfreq = "OFF";
        }
        if (lfreq != "OFF") {
          rfreq = lfreq;
        } else if (rfreq == "OFF") {
          rfreq = "1/s";
        }
        if (lfreq != olfreq) {
          if (readOnly)
            throw new Error(this.hwdName + " is read only, cannot change its logFrequency from " + olfreq + " to " + lfreq);
          await this.sensor.set_logFrequency(lfreq);
          mustSave = true;
        }
        if (rfreq != orfreq) {
          if (readOnly)
            throw new Error(this.hwdName + " is read only, connot change its  reportFrequency from " + orfreq + " to " + rfreq);
          await this.sensor.set_reportFrequency(rfreq);
          mustSave = true;
        }
        if (lfreq != "OFF") {
          if (!dataloggerOn) {
            if (readOnly)
              throw new Error(this.hwdName + " is read only, cannot change set its  datalogger recording to ON");
            await dl.set_recording(YDataLogger.RECORDING_ON);
          }
          if (!dataloggerAS) {
            if (readOnly)
              throw new Error(this.hwdName + " is read only, cannot change set its datalogger autostart to ON");
            await dl.set_autoStart(YDataLogger.AUTOSTART_ON);
            mustSave = true;
          }
        }
      } else {
        lfreq = "OFF";
        if (rfreq == "OFF") {
          rfreq = "1/s";
          if (readOnly)
            throw new Error(this.hwdName + " is read only, connot change is reportFrequency from OFF to " + rfreq);
          await this.sensor.set_reportFrequency(rfreq);
          mustSave = true;
        }
      }
      if (mustSave)
        await m.saveToFlash();
    } catch (e) {
      logForm.log("failed to configure " + this.hwdName + "  (" + e.message + ")");
    }
    logForm.log("registering timed callback for  " + await this.sensor.get_hardwareId());
    await this.sensor.registerTimedReportCallback((callbacksource, M) => {
      this.TimedCallback(callbacksource, M);
    });
    this._recording = lfreq != "OFF";
    this._frequency = rfreq;
  }
  registerCallback(f) {
    if (this.FormsToNotify.indexOf(f) >= 0)
      return;
    this.FormsToNotify.push(f);
    return;
  }
  forceUpdate() {
    this.TimedCallback(this.sensor, null).then();
  }
  async TimedCallback(source, M) {
    this._online = true;
    if (M != null) {
      let t = M.get_endTimeUTC();
      if (this.firstLiveDataTimeStamp == 0)
        this.firstLiveDataTimeStamp = t;
      if (t > this.lastDataTimeStamp) {
        this.lastDataTimeStamp = t;
        this.lastDataSource = "last timedReport";
        this.consecutiveBadTimeStamp = 0;
      } else {
        this.consecutiveBadTimeStamp++;
        if (this.consecutiveBadTimeStamp < 10) {
          logForm.log(this.hwdName + ": ignoring bad timestamp " + t.toFixed(3) + " (previous " + this.lastDataSource + " at " + this.lastDataTimeStamp.toFixed(3) + ")");
        }
      }
      if (this.consecutiveBadTimeStamp == 0 || this.consecutiveBadTimeStamp >= 10) {
        this._lastAvgValue = M.get_averageValue();
        this._lastMinValue = M.get_minValue();
        this._lastMaxValue = M.get_maxValue();
        this.curData.push(new TimedSensorValue(t, this._lastAvgValue));
        this.minData.push(new TimedSensorValue(t, this._lastMinValue));
        this.maxData.push(new TimedSensorValue(t, this._lastMaxValue));
        if (CustomYSensor._MaxDataRecords > 0)
          this.dataCleanUp();
      }
      for (let i = 0; i < this.Alarms.length; i++) {
        this.Alarms[i].check(M);
      }
      for (let i = 0; i < this.FormsToNotify.length; i++) {
        this.FormsToNotify[i].SensorValuecallback(this, M);
      }
    }
  }
  forgetForm(source) {
    for (let i = this.FormsToNotify.length - 1; i >= 0; i--) {
      if (source == this.FormsToNotify[i]) {
        this.FormsToNotify.splice(i, 1);
      }
    }
  }
  get_sensor() {
    return this.sensor;
  }
  get_hardwareId() {
    return this.hwdName;
  }
  get_friendlyName() {
    return this._friendlyname;
  }
  toString() {
    let name = this._friendlyname;
    if (this._readonly)
      name += " (readonly)";
    if (this._online)
      return name;
    return name + " (OFFLINE)";
  }
};
CustomYSensor._MaxDataRecords = 0;
CustomYSensor._MaxLoggerRecords = 0;
var NullYSensor = class extends CustomYSensor {
  constructor() {
    super(null, "", null);
    this.hwdName = "NOTAREALSENSOR";
    this._friendlyname = "NOTAREALSENSOR";
    this.dataLoggerFeature = false;
  }
  async preload_DoWork(arg) {
    return;
  }
  get dataloggerLoadisRunning() {
    return false;
  }
  get_unit() {
    return "";
  }
  registerCallback(Form) {
  }
  forceUpdate() {
  }
  get_frequency() {
    return "";
  }
  set_frequency(frequencyToSet) {
  }
  get_sensor() {
    return null;
  }
  toString() {
    return "(none)";
  }
  setAlarmCondition(index, condition) {
  }
  getAlarmCondition(index) {
    return 0;
  }
  setAlarmValue(index, value) {
  }
  getAlarmValue(index) {
    return 0;
  }
  setAlarmDelay(index, value) {
  }
  getAlarmDelay(index) {
    return 0;
  }
  setAlarmCommandline(index, value) {
  }
  getAlarmCommandline(index) {
    return "";
  }
};
var sensorsManager = class {
  static async clearHublist() {
    for (let i = sensorsManager._hubList.length - 1; i >= 0; i--) {
      if (sensorsManager._hubList[i].removable) {
        await YAPI.UnregisterHub(sensorsManager._hubList[i].get_fullUrl());
        sensorsManager._hubList.splice(i, 1);
      }
    }
  }
  static registerChangeCallback(changeCallback) {
    this._changeCallback = changeCallback;
  }
  static registerChangeExternalCallback(changeCallback) {
    this._changeExternalCallback = changeCallback;
  }
  static forgetForm(source) {
    for (let i = 0; i < sensorsManager.sensorList.length; i++) {
      sensorsManager.sensorList[i].forgetForm(source);
    }
  }
  static InitHubList(node) {
    let nodes = node.get_childsByIndex();
    for (let i = 0; i < nodes.length; i++) {
      if (nodes[i].Name.toUpperCase() == "HUB") {
        let h = Hub.HubFromXml(nodes[i]);
        let alreadthere = false;
        for (let j = 0; j < sensorsManager._hubList.length; j++) {
          if (h.get_connexionUrl() == sensorsManager._hubList[j].get_connexionUrl())
            alreadthere = true;
        }
        if (!alreadthere) {
          sensorsManager._hubList.push(h);
          h.Connect().then();
        }
      }
    }
  }
  static get hubList() {
    return sensorsManager._hubList;
  }
  static hubWasremoved(h) {
    for (let i = sensorsManager._hubList.length - 1; i >= 0; i--) {
      if (sensorsManager._hubList[i] == h)
        sensorsManager._hubList.splice(i, 1);
    }
  }
  static newHubCreated(h) {
    let url = h.get_connexionUrl();
    for (let i = 0; i < sensorsManager._hubList.length; i++) {
      if (sensorsManager._hubList[i].get_connexionUrl() == url) {
        alert("This connection already exists");
        return false;
      }
    }
    sensorsManager._hubList.push(h);
    return true;
  }
  static removeExtraInfoFromUrl(url) {
    let it = new URL(url);
    let res = it.hostname + it.pathname;
    if (res.slice(0, 4).toLowerCase() === "www.") {
      res = res.slice(4);
    }
    return res;
  }
  static async NetworkArrival(net) {
    logForm.log("Network device detected: " + await net.get_hardwareId());
    let ip = await net.get_ipAddress();
    let netname = await net.get_logicalName();
    let module = await net.get_module();
    let loginame = await module.get_logicalName();
    let url = sensorsManager.removeExtraInfoFromUrl(await module.get_url());
    for (let i = 0; i < sensorsManager._hubList.length; i++) {
      let str = sensorsManager.removeExtraInfoFromUrl(sensorsManager.hubList[i].get_fullUrl());
      if (str == url) {
        sensorsManager.hubList[i].arrival(ip, netname, module, loginame);
      }
    }
  }
  static getXmlHublist() {
    let res = "";
    for (let i = 0; i < sensorsManager._hubList.length; i++) {
      res += "    " + sensorsManager._hubList[i].XmlCode() + "\n";
    }
    return res;
  }
  static getXMLSensorsConfig() {
    let res = "<Sensors>\n";
    sensorsManager.sensorList.forEach((s) => {
      if (!(s instanceof NullYSensor)) {
        res = res + s.GetXmlData();
      }
    });
    res = res + "</Sensors>\n";
    return res;
  }
  static setKnownSensors(sensorXMLList) {
    this.KnownSensors = sensorXMLList;
  }
  static FindSensorLastLocalConfig(hwdId) {
    let SensorConfig = null;
    if (sensorsManager.KnownSensors != null) {
      let childs = sensorsManager.KnownSensors.get_childsByIndex();
      for (let i = 0; i < childs.length; i++) {
        let node = childs[i];
        if (node.Name == "Sensor") {
          let id = node.get_attributes()["ID"];
          if (id == hwdId) {
            SensorConfig = node;
          }
        }
      }
    }
    return SensorConfig;
  }
  static async deviceConfigChanged(m) {
    logForm.log("Configuration change on device  " + await m.get_serialNumber());
    let serialprefix = (await m.get_serialNumber()).substring(0, 8);
    for (let i = 0; i < sensorsManager.sensorList.length; i++) {
      if (sensorsManager.sensorList[i].get_hardwareId().substring(0, 8) == serialprefix) {
        await sensorsManager.sensorList[i].ConfigHasChanged();
      }
    }
    if (sensorsManager._changeCallback != null)
      sensorsManager._changeCallback();
    if (sensorsManager._changeExternalCallback != null) {
      let data = await sensorsManager._changeExternalCallback(m);
      if (data != null)
        YWebPage.ConfigChanged(data);
    }
  }
  static async deviceArrival(m) {
    try {
      let count = await m.functionCount();
      let serial = await m.get_serialNumber();
      let luminosity = await m.get_luminosity();
      logForm.log("Device Arrival " + serial);
      let recording = false;
      for (let i = 0; i < count; i++) {
        let ftype = await m.functionType(i);
        let fid = await m.functionId(i);
        if (ftype == "Network") {
          let net = await YNetwork.FindNetwork(serial + "." + fid);
          await sensorsManager.NetworkArrival(net);
        } else if (ftype == "DataLogger") {
          let dlog = YDataLogger.FindDataLogger(serial + "." + fid);
          let state = await dlog.get_recording();
          if (state == YDataLogger.RECORDING_ON || state == YDataLogger.RECORDING_PENDING) {
            recording = true;
          }
        }
      }
      for (let i = 0; i < count; i++) {
        let fbasetype = await m.functionBaseType(i);
        let fid = await m.functionId(i);
        if (fbasetype == "Sensor") {
          let hwdID = serial + "." + fid;
          logForm.log("New sensor arrival: " + hwdID);
          let found = false;
          for (let j = 0; j < sensorsManager.sensorList.length && !found; j++) {
            if (sensorsManager.sensorList[j].get_hardwareId() == hwdID) {
              found = true;
              await sensorsManager.sensorList[j].arrival(recording);
            }
          }
          if (!found) {
            let s = YSensor.FindSensor(hwdID);
            let hwd = await s.get_hardwareId();
            let cs = new CustomYSensor(s, hwd, sensorsManager.FindSensorLastLocalConfig(hwd));
            sensorsManager.sensorList.push(cs);
            await cs.configureSensor();
            YWebPage.refreshEditor();
            cs.notifySensorStateChange();
          }
        }
      }
      await m.registerConfigChangeCallback(sensorsManager.deviceConfigChanged);
      setTimeout(() => {
        sensorsManager.deviceConfigChanged(m);
      }, 100);
      if (sensorsManager._changeCallback != null)
        sensorsManager._changeCallback();
    } catch (e) {
      logForm.log("Device Arrival Error: " + e.message);
    }
    if (sensorsManager._customArrivalCallback != null)
      sensorsManager._customArrivalCallback(m);
  }
  static async deviceRemoval(m) {
    let serial = await m.get_serialNumber();
    logForm.log("Device removal " + serial);
    sensorsManager.sensorList.forEach((alreadyThereSensor) => {
      if (!(alreadyThereSensor instanceof NullYSensor)) {
        let hwd = alreadyThereSensor.get_hardwareId();
        if (hwd.length >= serial.length) {
          if (hwd.substring(0, serial.length) == serial) {
            alreadyThereSensor.removal();
          }
        }
      }
    });
    if (sensorsManager._changeCallback != null)
      sensorsManager._changeCallback();
    if (sensorsManager._customRemovalCallback != null)
      sensorsManager._customRemovalCallback(m);
  }
  static RegisterDeviceArrivalCallback(arrivalCallback) {
    sensorsManager._customArrivalCallback = arrivalCallback;
  }
  static RegisterDeviceRemovalCallback(removalCallback) {
    sensorsManager._customRemovalCallback = removalCallback;
  }
  static AddNewSensor(hwdID) {
    for (let i = 0; i < sensorsManager.sensorList.length; i++) {
      if (sensorsManager.sensorList[i] != null) {
        if (sensorsManager.sensorList[i].get_hardwareId() == hwdID)
          return sensorsManager.sensorList[i];
      }
    }
    let s = YSensor.FindSensor(hwdID);
    let cs = new CustomYSensor(s, hwdID, sensorsManager.FindSensorLastLocalConfig(hwdID));
    sensorsManager.sensorList.push(cs);
    return cs;
  }
  static getNullSensor() {
    return sensorsManager.NullSensor;
  }
  static async UpdateDeviceList() {
    let err = new YErrorMsg();
    try {
      if (await YAPI.UpdateDeviceList(err) != YAPI_SUCCESS) {
        logForm.log("UpdateDeviceList failed :" + err.msg);
      }
    } catch (e) {
      logForm.log("UpdateDeviceList failed :" + e.message);
    }
  }
  static async _runAsync() {
    let errmsg = new YErrorMsg();
    await YAPI.RegisterDeviceArrivalCallback((m) => {
      sensorsManager.deviceArrival(m);
    });
    await YAPI.RegisterDeviceRemovalCallback((m) => {
      sensorsManager.deviceRemoval(m);
    });
    await sensorsManager.UpdateDeviceList();
    setInterval(() => {
      sensorsManager.UpdateDeviceList();
    }, 2e3);
  }
  static run() {
    sensorsManager.NullSensor = new NullYSensor();
    sensorsManager.sensorList = [];
    sensorsManager.sensorList.push(sensorsManager.NullSensor);
    this._runAsync().then();
  }
};
sensorsManager.counter = 0;
sensorsManager.KnownSensors = null;
sensorsManager._hubList = [];
sensorsManager._customArrivalCallback = null;
sensorsManager._customRemovalCallback = null;
sensorsManager._changeCallback = null;
sensorsManager._changeExternalCallback = null;

// obj/full/formManager.js
var ResizeMoveHandle = class {
  constructor(container, index, mouseDownListener, touchStartlistener) {
    this.index = index;
    this.container = container;
    this.isactive = false;
    this.div = document.createElement("DIV");
    let size = ResizeMoveHandle.HANDLESIZE - 2;
    if (this.index == ResizeMoveHandle.RESIZEHANDLE_CENTER)
      size = size * 2;
    this.div.style.position = "absolute";
    this.div.style.border = "0px solid black";
    this.div.style.background = "transparent";
    this.div.style.pointerEvents = "auto";
    this.div.style.width = size.toString() + "px";
    this.div.style.height = size.toString() + "px";
    switch (index) {
      case ResizeMoveHandle.RESIZEHANDLE_TOPLEFT:
        this.div.style.cursor = "nw-resize";
        this.div.style.left = "0px";
        this.div.style.top = "0px";
        break;
      case ResizeMoveHandle.RESIZEHANDLE_TOPCENTER:
        this.div.style.cursor = "n-resize";
        this.div.style.top = "0px";
        this.div.style.left = "50%";
        this.div.style.transform = "translate(-50%,0)";
        break;
      case ResizeMoveHandle.RESIZEHANDLE_TOPRIGHT:
        this.div.style.cursor = "ne-resize";
        this.div.style.right = "0px";
        this.div.style.top = "0px";
        break;
      case ResizeMoveHandle.RESIZEHANDLE_CENTERRIGHT:
        this.div.style.cursor = "e-resize";
        this.div.style.right = "0px";
        this.div.style.top = "50%";
        this.div.style.transform = "translate(0,-50%)";
        break;
      case ResizeMoveHandle.RESIZEHANDLE_BOTTOMRIGHT:
        this.div.style.cursor = "se-resize";
        this.div.style.right = "0px";
        this.div.style.bottom = "0px";
        break;
      case ResizeMoveHandle.RESIZEHANDLE_BOTTOMCENTER:
        this.div.style.cursor = "s-resize";
        this.div.style.bottom = "0px";
        this.div.style.left = "50%";
        this.div.style.transform = "translate(-50%,0)";
        break;
      case ResizeMoveHandle.RESIZEHANDLE_BOTTOMLEFT:
        this.div.style.cursor = "sw-resize";
        this.div.style.left = "0px";
        this.div.style.bottom = "0px";
        break;
      case ResizeMoveHandle.RESIZEHANDLE_CENTERLEFT:
        this.div.style.cursor = "w-resize";
        this.div.style.left = "0px";
        this.div.style.top = "50%";
        this.div.style.transform = "translate(0,-50%)";
        break;
      case ResizeMoveHandle.RESIZEHANDLE_CENTER:
        this.div.style.cursor = "move";
        this.div.style.left = "50%";
        this.div.style.top = "50%";
        this.div.style.transform = "translate(-50%,-50%)";
        break;
    }
    this.container.appendChild(this.div);
    this.div.addEventListener("mousedown", mouseDownListener);
    this.div.addEventListener("touchstart", touchStartlistener);
    this.svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    this.svg.setAttribute("viewBox", "0 0 " + size + " " + size);
    this.svg.setAttribute("version", "1.1");
    this.svg.setAttribute("width", size.toString());
    this.svg.setAttribute("height", size.toString());
    let x = 0;
    let y = 0;
    let r = size;
    switch (this.index) {
      case ResizeMoveHandle.RESIZEHANDLE_TOPLEFT:
        break;
      case ResizeMoveHandle.RESIZEHANDLE_TOPCENTER:
        x = size / 2;
        break;
      case ResizeMoveHandle.RESIZEHANDLE_TOPRIGHT:
        x = size;
        break;
      case ResizeMoveHandle.RESIZEHANDLE_CENTERRIGHT:
        x = size;
        y = size / 2;
        break;
      case ResizeMoveHandle.RESIZEHANDLE_BOTTOMRIGHT:
        x = size;
        y = size;
        break;
      case ResizeMoveHandle.RESIZEHANDLE_BOTTOMCENTER:
        x = size / 2;
        y = size;
        break;
      case ResizeMoveHandle.RESIZEHANDLE_BOTTOMLEFT:
        y = size;
        break;
      case ResizeMoveHandle.RESIZEHANDLE_CENTERLEFT:
        y = size / 2;
        break;
      case ResizeMoveHandle.RESIZEHANDLE_CENTER:
        x = size / 2;
        y = size / 2;
        r = size / 2;
        break;
    }
    this.circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
    this.circle.setAttribute("cx", x.toString());
    this.circle.setAttribute("cy", y.toString());
    this.circle.setAttribute("r", r.toString());
    this.circle.setAttribute("style", "fill:white");
    this.circle.setAttribute("opacity", "0.75");
    this.svg.appendChild(this.circle);
    this.arrow = document.createElementNS("http://www.w3.org/2000/svg", "path");
    let d = "";
    for (let i = 0; i < ResizeMoveHandle.RESIZEHANDLE_data[index].length >> 1; i++) {
      let x2 = 1 + (size - 2) * ResizeMoveHandle.RESIZEHANDLE_data[index][i << 1] / 12;
      let y2 = 1 + (size - 2) * ResizeMoveHandle.RESIZEHANDLE_data[index][1 + (i << 1)] / 12;
      d += i == 0 ? "M " : "L ";
      d += Math.round(x2).toString() + " " + Math.round(y2).toString() + " ";
    }
    d += "z";
    this.arrow.setAttribute("d", d);
    this.arrow.setAttribute("fill", ResizeMoveHandle.inactiveColor);
    this.svg.appendChild(this.arrow);
    this.div.appendChild(this.svg);
    this.container.appendChild(this.div);
  }
  get active() {
    return this.isactive;
  }
  set active(value) {
    if (value != this.isactive) {
      this.isactive = value;
      this.arrow.setAttribute("fill", this.active ? ResizeMoveHandle.activeColor : ResizeMoveHandle.inactiveColor);
    }
  }
};
ResizeMoveHandle.HANDLESIZE = Math.round(20 * (1 + 2 * (constants.guiDPIFactor - 1)));
ResizeMoveHandle.activeColor = "lightgreen";
ResizeMoveHandle.inactiveColor = "grey";
ResizeMoveHandle.RESIZEHANDLE_TOPLEFT = 0;
ResizeMoveHandle.RESIZEHANDLE_TOPCENTER = 1;
ResizeMoveHandle.RESIZEHANDLE_TOPRIGHT = 2;
ResizeMoveHandle.RESIZEHANDLE_CENTERRIGHT = 3;
ResizeMoveHandle.RESIZEHANDLE_BOTTOMRIGHT = 4;
ResizeMoveHandle.RESIZEHANDLE_BOTTOMCENTER = 5;
ResizeMoveHandle.RESIZEHANDLE_BOTTOMLEFT = 6;
ResizeMoveHandle.RESIZEHANDLE_CENTERLEFT = 7;
ResizeMoveHandle.RESIZEHANDLE_CENTER = 8;
ResizeMoveHandle.RESIZEHANDLE_data = [
  [0, 0, 0, 7, 2, 5, 7, 10, 10, 7, 5, 2, 7, 0],
  [6, 0, 11, 5, 8, 5, 8, 12, 4, 12, 4, 5, 1, 5],
  [12, 0, 12, 7, 10, 5, 5, 10, 2, 7, 7, 2, 5, 0],
  [12, 6, 7, 11, 7, 8, 0, 8, 0, 4, 7, 4, 7, 1],
  [12, 12, 5, 12, 7, 10, 2, 5, 5, 2, 10, 7, 12, 5],
  [6, 12, 1, 7, 4, 7, 4, 0, 8, 0, 8, 7, 11, 7],
  [0, 12, 0, 5, 2, 7, 7, 2, 10, 5, 5, 10, 7, 12],
  [0, 6, 5, 1, 5, 4, 12, 4, 12, 8, 5, 8, 5, 11],
  [
    6,
    0,
    8,
    2,
    7,
    2,
    7,
    5,
    10,
    5,
    10,
    4,
    12,
    6,
    10,
    8,
    10,
    7,
    7,
    7,
    7,
    10,
    8,
    10,
    6,
    12,
    4,
    10,
    5,
    10,
    5,
    7,
    2,
    7,
    2,
    8,
    0,
    6,
    2,
    4,
    2,
    5,
    5,
    5,
    5,
    2,
    4,
    2
  ]
];
var YWidget = class {
  static log(st) {
    logForm.log(st);
  }
  SourceChanged(src, index) {
  }
  loadRecordedDataIfNeeded() {
  }
  removeDataloggerData() {
  }
  delete() {
    this.editStopped();
    sensorsManager.forgetForm(this);
    this.destroy();
  }
  get confirmDeleteString() {
    return "not defined";
  }
  snapshot() {
    let w = 1024;
    let h = 1024;
    let ratio = this.UIContainer.offsetHeight != 0 ? this.UIContainer.offsetWidth / this.UIContainer.offsetHeight : 1;
    switch (constants.captureSizePolicy) {
      case YDataRenderer.CaptureFormats.Keep:
        w = this.UIContainer.offsetWidth;
        h = this.UIContainer.offsetHeight;
        break;
      case YDataRenderer.CaptureFormats.FixedHeight:
        h = constants.captureHeight;
        w = h * ratio;
        break;
      case YDataRenderer.CaptureFormats.FixedWidth:
        w = constants.captureWidth;
        h = w / ratio;
        break;
      case YDataRenderer.CaptureFormats.Fixed:
        w = constants.captureWidth;
        h = constants.captureHeight;
        break;
    }
    this._genRenderer.captureAndDownloadImage(constants.captureType, "", w, h, constants.captureDPI);
  }
  get BackColor() {
    return this._BackColor;
  }
  set BackColor(value) {
    this._BackColor = value;
    this.UIContainer.style.backgroundColor = this._BackColor.htmlCode;
  }
  get BorderColor() {
    return this._BorderColor;
  }
  set BorderColor(value) {
    this._BorderColor = value;
    this.UIContainer.style.border = "1px solid " + this._BorderColor.htmlCode;
  }
  get parentWidth() {
    if (this.UIContainer.parentNode == document.body || this.UIContainer.parentNode == null)
      return window.innerWidth;
    return this.UIContainer.parentNode.clientWidth;
  }
  get parentHeight() {
    if (this.UIContainer.parentNode == document.body || this.UIContainer.parentNode == null)
      return window.innerHeight;
    return this.UIContainer.parentNode.clientHeight;
  }
  get relativePositionX() {
    if (this._SizeIsRelative)
      return this._relativePositionX;
    return this.sizeRound(100 * this.UIContainer.offsetLeft / this.parentWidth);
  }
  set relativePositionX(value) {
    this._relativePositionX = value;
    this._PositionX = Math.round(value * this.parentWidth / 100);
  }
  set relativePositionY(value) {
    this._relativePositionY = value;
    this._PositionY = Math.round(value * this.parentHeight / 100);
  }
  get relativePositionY() {
    if (this._SizeIsRelative)
      return this._relativePositionY;
    return this.sizeRound(100 * this.UIContainer.offsetTop / this.parentHeight);
  }
  get PositionX() {
    if (this._SizeIsRelative)
      return this.relativePositionX;
    return this.UIContainer.offsetLeft;
  }
  set PositionX(value) {
    if (this._SizeIsRelative)
      this.relativePositionX = value;
    else
      this._PositionX = value;
    this.UIContainer.style.left = this._PositionX.toString() + "px";
    if (this._genRenderer != null)
      this._genRenderer.clearTransformationMatrix();
    this.DrawHandles(this.UIContainer.offsetLeft, this.UIContainer.offsetTop, this.UIContainer.offsetWidth, this.UIContainer.offsetHeight);
  }
  get PositionY() {
    if (this._SizeIsRelative)
      return this.relativePositionY;
    return this.UIContainer.offsetTop;
  }
  set PositionY(value) {
    if (this._SizeIsRelative)
      this.relativePositionY = value;
    else
      this._PositionY = value;
    this.UIContainer.style.top = this._PositionY.toString() + "px";
    if (this._genRenderer != null)
      this._genRenderer.clearTransformationMatrix();
    this.DrawHandles(this.UIContainer.offsetLeft, this.UIContainer.offsetTop, this.UIContainer.offsetWidth, this.UIContainer.offsetHeight);
  }
  sizeRound(v) {
    return Math.round(100 * v) / 100;
  }
  get relativeWidth() {
    if (this._SizeIsRelative)
      return this._relativeWidth;
    return this.sizeRound(100 * this.UIContainer.offsetWidth / this.parentWidth);
  }
  set relativeWidth(value) {
    if (value <= 0)
      throw "Value must be strictly positive";
    this._relativeWidth = value;
    this._Width = Math.round(value * this.parentWidth / 100);
  }
  set relativeHeight(value) {
    if (value <= 0)
      throw "Value must be strictly positive";
    this._relativeHeight = value;
    this._Height = Math.round(value * this.parentHeight / 100);
  }
  get relativeHeight() {
    if (this._SizeIsRelative)
      return this._relativeHeight;
    return this.sizeRound(100 * this.UIContainer.offsetHeight / this.parentHeight);
  }
  updateRelativeSize() {
    if (Math.abs(this._relativeWidth * this.parentWidth / 100 - this.UIContainer.offsetWidth) > 1)
      this._relativeWidth = this.sizeRound(100 * this.UIContainer.offsetWidth / this.parentWidth);
    if (Math.abs(this._relativeHeight * this.parentHeight / 100 - this.UIContainer.offsetHeight) > 1)
      this._relativeHeight = this.sizeRound(100 * this.UIContainer.offsetHeight / this.parentHeight);
    if (Math.abs(this._relativePositionX * this.parentWidth / 100 - this.UIContainer.offsetLeft) > 1)
      this._relativePositionX = this.sizeRound(100 * this.UIContainer.offsetLeft / this.parentWidth);
    if (Math.abs(this._relativePositionY * this.parentHeight / 100 - this.UIContainer.offsetTop) > 1)
      this._relativePositionY = this.sizeRound(100 * this.UIContainer.offsetTop / this.parentHeight);
  }
  get Width() {
    if (this._SizeIsRelative)
      return this.relativeWidth;
    else
      return this.UIContainer.offsetWidth;
  }
  set Width(value) {
    if (value <= 0)
      throw "Value must be strictly positive";
    if (this._SizeIsRelative)
      this.relativeWidth = value;
    else
      this._Width = value;
    this.UIContainer.style.width = (this._Width - 2).toString() + "px";
    this.UIContainer.width = this._Width - 2;
    if (this._genRenderer != null)
      this._genRenderer.clearTransformationMatrix();
    this.DrawHandles(this.UIContainer.offsetLeft, this.UIContainer.offsetTop, this.UIContainer.offsetWidth, this.UIContainer.offsetHeight);
    this.containerResized();
  }
  get Height() {
    if (this._SizeIsRelative)
      return this.relativeHeight;
    else
      return this.UIContainer.offsetHeight;
  }
  set Height(value) {
    if (value <= 0)
      throw "Value must be strictly positive";
    if (this._SizeIsRelative)
      this.relativeHeight = value;
    else
      this._Height = value;
    this.UIContainer.style.height = (this._Height - 2).toString() + "px";
    this.UIContainer.height = this._Height - 2;
    if (this._genRenderer != null)
      this._genRenderer.clearTransformationMatrix();
    this.DrawHandles(this.UIContainer.offsetLeft, this.UIContainer.offsetTop, this.UIContainer.offsetWidth, this.UIContainer.offsetHeight);
    this.containerResized();
  }
  get SizeIsRelative() {
    return this._SizeIsRelative;
  }
  set SizeIsRelative(value) {
    if (this._SizeIsRelative != value) {
      this._SizeIsRelative = value;
      if (this._SizeIsRelative) {
        this._relativePositionX = this.sizeRound(100 * this.UIContainer.offsetLeft / this.parentWidth);
        this._relativePositionY = this.sizeRound(100 * this.UIContainer.offsetTop / this.parentHeight);
        this._relativeWidth = this.sizeRound(100 * this.UIContainer.offsetWidth / this.parentWidth);
        this._relativeHeight = this.sizeRound(100 * this.UIContainer.offsetHeight / this.parentHeight);
      }
      this.windowResized();
    }
  }
  get containerID() {
    return this._containerID;
  }
  set containerID(value) {
    if (this._containerID == value)
      return;
    let target = value != "" ? document.getElementById(value) : null;
    if (value != "" && target == null)
      throw "No HTMLElement on the page with such ID (" + value + ")";
    if (this.UIContainer.parentNode != null) {
      this.UIContainer.parentNode.removeChild(this.UIContainer);
    } else {
      document.body.removeChild(this.UIContainer);
    }
    if (target != null) {
      this.UIContainer.style.position = "relative";
      target.insertBefore(this.UIContainer, target.firstChild);
    } else {
      this.UIContainer.style.position = "absolute";
      document.body.insertBefore(this.UIContainer, document.body.firstChild);
    }
    this._genRenderer.clearTransformationMatrix();
    this.windowResized();
    this.DrawHandles(this.UIContainer.offsetLeft, this.UIContainer.offsetTop, this.UIContainer.offsetWidth, this.UIContainer.offsetHeight);
    this._containerID = value;
  }
  get Text() {
    return this._Text;
  }
  set Text(value) {
    this._Text = value;
    this.UIContainer.title = value;
  }
  set_name(name) {
    this.Text = name;
    this._genProp.Form_Text = name;
  }
  windowResized() {
    this._genRenderer.DisableRedraw();
    if (this._SizeIsRelative) {
      this.PositionX = this._relativePositionX;
      this.PositionY = this._relativePositionY;
      this.Height = this._relativeHeight;
      this.Width = this._relativeWidth;
    }
    this.containerResized();
    this._genRenderer.AllowRedraw();
  }
  ApplyRelativeSizeIfRequired() {
    if (this._initialContainerID != "") {
      if (document.getElementById(this._initialContainerID) != null) {
        this.containerID = this._initialContainerID;
      } else {
        logForm.log('Warning: cannot place widget in "' + this._initialContainerID + '" : no such HTML element.');
      }
    }
    this._SizeIsRelative = this._InitialSizeIsRelative;
    this.windowResized();
  }
  destroy() {
    window.removeEventListener("resize", this._windowResizeCallback);
    this._genRenderer.destroy();
    Object.entries(this).forEach((pair) => {
      Reflect.set(this, pair[0], null);
    });
  }
  getContainerOffset() {
    let it = this.UIContainer.offsetParent;
    let absx = 0;
    let absy = 0;
    while (it) {
      absy += it.offsetTop;
      absx += it.offsetLeft;
      it = it.offsetParent;
    }
    return new pointXY(absx, absy);
  }
  contextMenuCallBack(mouseX, mouseY) {
    let p = this._genRenderer.Scr2ElmMatrix.multiplyByV(Vector3.FromXYCoord(mouseX, mouseY)).toPoint();
    if (p.X >= 0 && p.X <= this.UIContainer.offsetWidth && p.Y >= 0 && p.Y <= this.UIContainer.offsetHeight) {
      this.contextMenuIsOpening();
    }
  }
  contextMenuIsOpening() {
  }
  constructor(node, editor, default_x, default_y, default_width, default_height) {
    this._genProp = null;
    this._genRenderer = null;
    this._BackColor = YColor.Transparent;
    this._BorderColor = YColor.Gray;
    this._relativePositionX = 0;
    this._relativePositionY = 0;
    this._PositionX = 0;
    this._PositionY = 0;
    this._relativeWidth = 100;
    this._relativeHeight = 100;
    this._Width = 300;
    this._Height = 0;
    this._InitialSizeIsRelative = false;
    this._SizeIsRelative = false;
    this._initialContainerID = "";
    this._containerID = "";
    this._Text = "";
    this.resizeCaptureRunning = false;
    this.resizeCaptureXOrigineMouse = 0;
    this.resizeCaptureYOrigineMouse = 0;
    this.resizeCaptureXOrigine = 0;
    this.resizeCaptureYOrigine = 0;
    this.resizeCaptureOriginalTop = 0;
    this.resizeCaptureOriginalLeft = 0;
    this.resizeCaptureOriginalWidth = 0;
    this.resizeCaptureOriginalHeight = 0;
    this.resizeCaptureHandleIndex = 0;
    this.resizeCaptureOriginalMatrix = null;
    this.resizeCaptureOriginalMatrixInv = null;
    this.previousTRansform = "";
    this.previousWidth = 0;
    this.previousHeight = 0;
    let left = typeof default_x != "undefined" ? default_x : 0;
    let top2 = typeof default_y != "undefined" ? default_y : 0;
    let width = typeof default_width != "undefined" ? default_width : 0;
    let height = typeof default_height != "undefined" ? default_height : 0;
    let bottom = Number.NaN;
    let right = Number.NaN;
    if (node != null) {
      let childnodes = node.get_childsByName();
      if ("location" in childnodes) {
        let it = childnodes["location"];
        let attributes = it.get_attributes();
        if ("x" in attributes)
          left = parseInt(attributes["x"]);
        if ("y" in attributes)
          top2 = parseInt(attributes["y"]);
      }
      if ("size" in childnodes) {
        let it = childnodes["size"];
        let attributes = it.get_attributes();
        if ("w" in attributes)
          width = parseInt(attributes["w"]);
        if ("h" in attributes)
          height = parseInt(attributes["h"]);
      }
      if ("relativeCoord" in childnodes) {
        let it = childnodes["relativeCoord"];
        let attributes = it.get_attributes();
        if ("x" in attributes)
          this._relativePositionX = this.sizeRound(parseFloat(attributes["x"]));
        if ("y" in attributes)
          this._relativePositionY = this.sizeRound(parseFloat(attributes["y"]));
        if ("w" in attributes)
          this._relativeWidth = this.sizeRound(parseFloat(attributes["w"]));
        if ("h" in attributes)
          this._relativeHeight = this.sizeRound(parseFloat(attributes["h"]));
        if ("active" in attributes)
          this._InitialSizeIsRelative = attributes["active"].toUpperCase() == "TRUE";
      }
      if ("container" in childnodes) {
        let it = childnodes["container"];
        let attributes = it.get_attributes();
        if ("id" in attributes)
          this._initialContainerID = attributes["id"];
      }
    }
    this.UIContainer = document.createElement("CANVAS");
    this.UIContainer.style.position = "absolute";
    YWidget.currentEdited = null;
    let h = window.innerHeight;
    let w = window.innerWidth;
    this.PositionX = this._InitialSizeIsRelative ? Math.round(w * (this._relativePositionX / 100)) : left;
    this.PositionY = this._InitialSizeIsRelative ? Math.round(h * (this._relativePositionY / 100)) : top2;
    this.Width = this._InitialSizeIsRelative ? Math.round(w * (this._relativeWidth / 100)) : width;
    this.Height = this._InitialSizeIsRelative ? Math.round(h * (this._relativeHeight / 100)) : height;
    this.UIContainer.style.border = "1px solid black";
    this.UIContainer.style.backgroundColor = this._BackColor.htmlCode;
    this.UIContainer.setAttribute("name", "YoctoVisualizationWidget");
    document.body.appendChild(this.UIContainer);
    this._windowResizeCallback = () => this.windowResized();
    window.addEventListener("resize", this._windowResizeCallback);
  }
  rearrangeZindexes() {
    let containers = document.getElementsByName("YoctoVisualizationWidget");
    let n = 0;
    for (let i = 0; i < containers.length; i++) {
      if (containers[i] != this.UIContainer) {
        containers[i].style.zIndex = n.toString();
        n++;
      }
    }
    this.UIContainer.style.zIndex = n.toString();
    n++;
    YWidget.HandlesDiv.style.zIndex = n.toString();
  }
  SensorArrivalcallback(source) {
  }
  SensorStateChangedcallback(source) {
    if (YWidget.currentEdited == this) {
      YWebPage.refreshEditor();
    }
  }
  SensorValuecallback(source, M) {
  }
  get isBeingEdited() {
    return YWidget.currentEdited == this;
  }
  static stopEdition() {
    if (YWidget.currentEdited != null) {
      YWidget.currentEdited.editStopped();
      YWidget.currentEdited = null;
    }
  }
  refreshProperties() {
  }
  edit() {
    YWidget.stopEdition();
    YWidget.currentEdited = this;
    if (YWidget.editHandles.length <= 0) {
      YWidget.HandlesDiv = document.createElement("DIV");
      YWidget.HandlesDiv.style.position = "absolute";
      YWidget.HandlesDiv.style.left = "0px";
      YWidget.HandlesDiv.style.top = "0px";
      YWidget.HandlesDiv.style.backgroundColor = "transparent";
      YWidget.HandlesDiv.style.transformOrigin = "top left";
      YWidget.HandlesDiv.style.pointerEvents = "none";
      for (let i = 0; i < 9; i++) {
        YWidget.editHandles.push(new ResizeMoveHandle(YWidget.HandlesDiv, i, (e) => {
          if (YWidget.currentEdited != null)
            YWidget.currentEdited.mouseStartCapture(e, i);
        }, (e) => {
          if (YWidget.currentEdited != null) {
            YWidget.currentEdited.touchStartCapture(e, i);
          }
        }));
      }
      document.body.appendChild(YWidget.HandlesDiv);
      document.addEventListener("touchmove", (e) => {
        if (YWidget.currentEdited != null)
          YWidget.currentEdited.touchCaptureRun(e);
      }, {passive: false});
      document.addEventListener("touchend", (e) => {
        if (YWidget.currentEdited != null)
          YWidget.currentEdited.touchCaptureStop(e);
      }, {passive: false});
      document.addEventListener("mousemove", (e) => {
        if (YWidget.currentEdited != null)
          YWidget.currentEdited.mouseCaptureRun(e);
      }, {passive: false});
      document.addEventListener("mouseup", (e) => {
        if (YWidget.currentEdited != null)
          YWidget.currentEdited.mouseCaptureStop(e);
      }, {passive: false});
    }
    this.DrawHandles(this.UIContainer.offsetLeft, this.UIContainer.offsetTop, this.UIContainer.offsetWidth, this.UIContainer.offsetHeight);
    YWidget.HandlesDiv.style.display = "";
    this.rearrangeZindexes();
  }
  DrawHandles(offsetLeft, offsetTop, offsetWidth, offsetHeight) {
    if (YWidget.currentEdited == null)
      return;
    if (YWidget.editHandles.length <= 0)
      return;
    YWidget.HandlesDiv.style.width = offsetWidth.toString() + "px";
    YWidget.HandlesDiv.style.height = offsetHeight.toString() + "px";
    if (this._genRenderer == null)
      debugger;
    let borderWidth = parseFloat(this.UIContainer.style.border);
    let borderMatrix = Matrix3x3.newTranslateMatrix(-borderWidth, -borderWidth);
    YWidget.HandlesDiv.style.transform = borderMatrix.multiplyByM(this._genRenderer.Elm2ScrMatrix).toCSS();
    YWidget.HandlesDiv.style.transform = "top left";
  }
  updateWindowPositionProperties(prop) {
    prop.Form_PositionX = this.PositionX;
    prop.Form_PositionY = this.PositionY;
    prop.Form_Width = this.Width;
    prop.Form_Height = this.Height;
  }
  touchStartCapture(e, handleIndex) {
    if (e.touches.length == 1) {
      this.handleMouseStartCapture(e.touches[0].pageX, e.touches[0].pageY, handleIndex);
      e.preventDefault();
    }
  }
  mouseStartCapture(e, handleIndex) {
    if (e.button != 0)
      return;
    this.handleMouseStartCapture(e.pageX, e.pageY, handleIndex);
  }
  handleMouseStartCapture(pageX, pageY, handleIndex) {
    this.resizeCaptureOriginalMatrix = this._genRenderer.Scr2ElmMatrix;
    this.resizeCaptureOriginalMatrixInv = this._genRenderer.Elm2ScrMatrix;
    let p = this.resizeCaptureOriginalMatrix.multiplyByV(Vector3.FromXYCoord(pageX, pageY)).toPoint();
    this.resizeCaptureRunning = true;
    this.resizeCaptureXOrigine = p.X;
    this.resizeCaptureYOrigine = p.Y;
    this.resizeCaptureOriginalLeft = this.UIContainer.offsetLeft;
    this.resizeCaptureOriginalTop = this.UIContainer.offsetTop;
    this.resizeCaptureOriginalWidth = this.UIContainer.offsetWidth;
    this.resizeCaptureOriginalHeight = this.UIContainer.offsetHeight;
    this.resizeCaptureHandleIndex = handleIndex;
    YWidget.editHandles[this.resizeCaptureHandleIndex].active = true;
    this.previousTRansform = YWidget.HandlesDiv.style.transform;
  }
  touchCaptureRun(e) {
    if (e.touches.length == 1) {
      this.handleCaptureRun(e.touches[0].pageX, e.touches[0].pageY);
      e.preventDefault();
    }
  }
  mouseCaptureRun(e) {
    this.handleCaptureRun(e.pageX, e.pageY);
  }
  handleCaptureRun(pageX, pageY) {
    if (!this.resizeCaptureRunning)
      return;
    let p = this.resizeCaptureOriginalMatrix.multiplyByV(Vector3.FromXYCoord(pageX, pageY)).toPoint();
    let dx = p.X - this.resizeCaptureXOrigine;
    let dy = p.Y - this.resizeCaptureYOrigine;
    let newLeft = this.resizeCaptureOriginalLeft;
    let newTop = this.resizeCaptureOriginalTop;
    let newWidth = this.resizeCaptureOriginalWidth;
    let newHeight = this.resizeCaptureOriginalHeight;
    switch (this.resizeCaptureHandleIndex) {
      case 0:
        newLeft += dx;
        newTop += dy;
        newWidth -= dx;
        newHeight -= dy;
        break;
      case 1:
        newTop += dy;
        newHeight -= dy;
        break;
      case 2:
        newTop += dy;
        newWidth += dx;
        newHeight -= dy;
        break;
      case 3:
        newWidth += dx;
        break;
      case 4:
        newWidth += dx;
        newHeight += dy;
        break;
      case 5:
        newHeight += dy;
        break;
      case 6:
        newLeft += dx;
        newWidth -= dx;
        newHeight += dy;
        break;
      case 7:
        newLeft += dx;
        newWidth -= dx;
        break;
      case 8:
        newLeft += dx;
        newTop += dy;
        break;
    }
    if (newWidth < 2 * YWidget.HANDLESIZE)
      newWidth = 2 * YWidget.HANDLESIZE;
    if (newHeight < 2 * YWidget.HANDLESIZE)
      newHeight = 2 * YWidget.HANDLESIZE;
    this.UIContainer.style.left = newLeft.toString() + "px";
    this.UIContainer.style.top = newTop.toString() + "px";
    if (this.resizeCaptureOriginalWidth != newWidth || this.resizeCaptureOriginalHeight != newHeight) {
      this.resize(newWidth - 2, newHeight - 2);
    }
    this._genRenderer.clearTransformationMatrix();
    YWidget.HandlesDiv.style.width = newWidth.toString() + "px";
    YWidget.HandlesDiv.style.height = newHeight.toString() + "px";
    YWidget.HandlesDiv.style.left = "0px";
    YWidget.HandlesDiv.style.top = "0px";
    let A = this.resizeCaptureOriginalMatrixInv;
    let B = Matrix3x3.newTranslateMatrix(newLeft - this.resizeCaptureOriginalLeft, newTop - this.resizeCaptureOriginalTop);
    let borderWidth = parseFloat(this.UIContainer.style.border);
    let borderMatrix = Matrix3x3.newTranslateMatrix(-borderWidth, -borderWidth);
    YWidget.HandlesDiv.style.transform = borderMatrix.multiplyByM(A.multiplyByM(B)).toCSS();
  }
  editStopped() {
    this.resizeCaptureRunning = false;
    if (YWidget.HandlesDiv != null)
      YWidget.HandlesDiv.style.display = "none";
  }
  touchCaptureStop(e) {
    this.mouseCaptureStop(null);
  }
  mouseCaptureStop(e) {
    if (!this.resizeCaptureRunning)
      return;
    this.resizeCaptureRunning = false;
    YWidget.editHandles[this.resizeCaptureHandleIndex].active = false;
    if (this.previousTRansform != YWidget.HandlesDiv.style.transform || this.resizeCaptureOriginalWidth != this.UIContainer.offsetWidth || this.resizeCaptureOriginalHeight != this.UIContainer.offsetHeight) {
      if (this._SizeIsRelative)
        this.updateRelativeSize();
      constants.edited = true;
    }
    this.refreshProperties();
  }
  resize(newWidth, newHeight) {
    this.UIContainer.style.width = newWidth.toString() + "px";
    this.UIContainer.style.height = newHeight.toString() + "px";
    this.containerResized();
  }
  containerResized() {
  }
  getContentsConfigData() {
    return "  <location x='" + this.UIContainer.offsetLeft.toString() + "' y='" + this.UIContainer.offsetTop.toString() + "'/>\n  <size     w='" + this.UIContainer.offsetWidth.toString() + "' h='" + this.UIContainer.offsetHeight.toString() + "'  state='Normal'/>\n  <relativeCoord x='" + this._relativePositionX.toString() + "' y='" + this._relativePositionY.toString() + "' w='" + this._relativeWidth.toString() + "' h='" + this._relativeHeight.toString() + "' active='" + (this._SizeIsRelative ? "True" : "False") + "'/>\n  <container id='" + constants.XMLquote(this._containerID) + "'/>\n" + this.getPropertiesXml();
  }
  getPropertiesXml() {
    return "";
  }
  PatchSensorAnnotationCallback(sensor, text) {
    let name = "None";
    let avgvalue = "N/A";
    let minvalue = "N/A";
    let maxvalue = "N/A";
    let unit = "";
    if (!(sensor instanceof NullYSensor)) {
      let resolution = -Math.round(Math.log10(sensor.get_resolution()));
      name = sensor.get_friendlyName();
      if (sensor.isOnline()) {
        avgvalue = sensor.get_lastAvgValue().toFixed(resolution);
        minvalue = sensor.get_lastMinValue().toFixed(resolution);
        maxvalue = sensor.get_lastMaxValue().toFixed(resolution);
      }
      unit = sensor.get_unit();
    }
    text = text.replace("$NAME$", name);
    text = text.replace("$AVGVALUE$", avgvalue);
    text = text.replace("$MAXVALUE$", maxvalue);
    text = text.replace("$MINVALUE$", minvalue);
    text = text.replace("$UNIT$", unit);
    return text;
  }
};
YWidget.HANDLESIZE = Math.round(20 * (1 + 2 * (constants.guiDPIFactor - 1)));
YWidget.editHandles = [];
YWidget.currentEdited = null;
var gaugeWidget = class extends YWidget {
  getPropertiesXml() {
    return this.prop.getXml(1);
  }
  containerResized() {
    if (this._gauge != null)
      this._gauge.containerResized();
  }
  destroy() {
    this.prop.destroy();
    super.destroy();
    Object.entries(this).forEach((pair) => {
      Reflect.set(this, pair[0], null);
    });
  }
  contextMenuIsOpening() {
    YWebPage.snapshotMenuItem.userdata = this;
    YWebPage.snapshotMenuItem.visible = true;
    YWebPage.resetDataViewMenuItem.visible = false;
    if (YWebPage.editMenuItem == null)
      return;
    YWebPage.clearDataloggerMenuItem.visible = true;
    YWebPage.editMenuItem.caption = "Configure this gauge";
    YWebPage.editMenuItem.visible = true;
    YWebPage.deleteMenuItem.caption = "Delete this gauge";
    YWebPage.deleteMenuItem.visible = true;
    YWebPage.addMarkerMenuItem.visible = false;
    YWebPage.disableMarkerMenuItem.visible = false;
    YWebPage.editMenuItem.userdata = this;
    YWebPage.deleteMenuItem.userdata = this;
  }
  get confirmDeleteString() {
    return "Do you really want to delete this gauge ?";
  }
  AnnotationCallback(text) {
    let sensor = this.prop.DataSource_source;
    return this.PatchSensorAnnotationCallback(sensor, text);
  }
  constructor(node, editor, x, y, width, height) {
    super(node, editor, x, y, width, height);
    this._gauge = new YSolidGauge(this.UIContainer, YSolidGauge.DisplayMode.DISPLAY90, YWidget.log);
    this._genRenderer = this._gauge;
    this.noDataSourcepanel = this._gauge.addMessagePanel();
    this.noDataSourcepanel.font.size = constants.generalFontSize;
    this.noDataSourcepanel.text = 'No data source configured\n 1 - Make sure you have a Yoctopuce sensor connected.\n 2 - Do a right-click or a long touch on this widget.\n 3 - Choose "Configure this gauge" to bring up the properties editor.\n 4 - Choose a data source\n';
    this.prop = new GaugeFormProperties(node, this);
    this._genProp = this.prop;
    let propDesc = GenericProperties.getAllProperties(this.prop);
    if (gaugeWidget.AnnotationPanelCount == 0) {
      for (let propname in propDesc.byName) {
        if (propname.startsWith("SolidGauge_annotationPanel"))
          gaugeWidget.AnnotationPanelCount++;
      }
    }
    for (let i = 0; i < gaugeWidget.AnnotationPanelCount; i++) {
      this._gauge.addAnnotationPanel();
    }
    this._gauge.setPatchAnnotationCallback((s) => {
      return this.AnnotationCallback(s);
    });
    this._gauge.valueFormater = (source, value) => {
      return this.valueFormater(source, value);
    };
    this.updateWindowPositionProperties(this.prop);
    this.prop.ApplyAllProperties(this);
    YDataRenderer.minMaxCheckDisabled = true;
    this.prop.ApplyAllProperties(this._gauge);
    YDataRenderer.minMaxCheckDisabled = false;
    this._gauge.resetRefrenceSize();
    this._gauge.resizeRule = Proportional.ResizeRule.RELATIVETOBOTH;
    this.ApplyRelativeSizeIfRequired();
    if (this.SizeIsRelative)
      this.refreshProperties();
    this._gauge.AllowRedraw();
  }
  valueFormater(source, value) {
    if (this.prop.DataSource_source instanceof NullYSensor) {
      return "N/A";
    } else if (!this.prop.DataSource_source.isOnline())
      return "OFFLINE";
    let format = this.prop.DataSource_precision;
    let p = format.indexOf(".");
    let n = 0;
    if (p >= 0)
      n = format.length - p - 1;
    let unit = this.prop.DataSource_source.get_unit();
    return value.toFixed(n) + unit;
  }
  PropertyChanged2(src) {
    let info = new PropPathinfo();
    let path = src.ExtractPropPath(info);
    switch (info.propType) {
      case "Form":
        GenericProperties.copyProperty_STT(this, this.prop, info.fullpropname, path);
        break;
      case "SolidGauge":
        GenericProperties.copyProperty_STT(this._gauge, this.prop, info.fullpropname, path);
        break;
      case "DataSource":
        break;
    }
  }
  Get_PropertyValue(src) {
    let info = new PropPathinfo();
    let path = src.ExtractPropPath(info);
    switch (info.propType) {
      case "Form":
        return GenericProperties.newGetProperty(this, this.prop, info.fullpropname, path, null);
      case "SolidGauge":
        return GenericProperties.newGetProperty(this._gauge, this.prop, info.fullpropname, path, null);
    }
    return null;
  }
  edit() {
    super.edit();
    YWebPage.EditObject(this, this.prop, (src) => {
      this.PropertyChanged2(src);
    }, (src) => {
      return this.Get_PropertyValue(src);
    }, () => {
      this.editStopped();
    });
  }
  refreshProperties() {
    this.prop.RefreshAllProperties(this);
    this.prop.RefreshAllProperties(this._gauge);
    YWebPage.refreshPropertiesForm();
  }
  SourceChanged(value, index) {
    this.noDataSourcepanel.enabled = value instanceof NullYSensor;
    if (value instanceof NullYSensor) {
      this._gauge.value = 0;
    } else {
      value.registerCallback(this);
    }
  }
  SensorValuecallback(source, M) {
    if (this.prop == null)
      return;
    if (source == this.prop.DataSource_source) {
      this._gauge.value = source.isOnline() ? M.get_averageValue() : 0;
    }
  }
  getConfigData() {
    return "<GaugeForm>\n" + this.getContentsConfigData() + "</GaugeForm>\n";
  }
};
gaugeWidget.AnnotationPanelCount = 0;
var angularGaugeWidget = class extends YWidget {
  getPropertiesXml() {
    return this.prop.getXml(1);
  }
  containerResized() {
    if (this._angularGauge != null)
      this._angularGauge.containerResized();
  }
  destroy() {
    this.prop.destroy();
    super.destroy();
    Object.entries(this).forEach((pair) => {
      Reflect.set(this, pair[0], null);
    });
  }
  AnnotationCallback(text) {
    let sensor = this.prop.DataSource_source;
    return this.PatchSensorAnnotationCallback(sensor, text);
  }
  contextMenuIsOpening() {
    YWebPage.snapshotMenuItem.userdata = this;
    YWebPage.snapshotMenuItem.visible = true;
    YWebPage.resetDataViewMenuItem.visible = false;
    if (YWebPage.editMenuItem == null)
      return;
    YWebPage.clearDataloggerMenuItem.visible = false;
    YWebPage.editMenuItem.caption = "Configure this gauge";
    YWebPage.editMenuItem.visible = true;
    YWebPage.deleteMenuItem.caption = "Delete this gauge";
    YWebPage.deleteMenuItem.visible = true;
    YWebPage.addMarkerMenuItem.visible = false;
    YWebPage.disableMarkerMenuItem.visible = false;
    YWebPage.editMenuItem.userdata = this;
    YWebPage.deleteMenuItem.userdata = this;
  }
  get confirmDeleteString() {
    return "Do you really want to delete this gauge ?";
  }
  constructor(node, editor, x, y, width, height) {
    super(node, editor, x, y, width, height);
    this._angularGauge = new YAngularGauge(this.UIContainer, YWidget.log);
    this._genRenderer = this._angularGauge;
    this.noDataSourcepanel = this._angularGauge.addMessagePanel();
    this.noDataSourcepanel.font.size = constants.generalFontSize;
    this.noDataSourcepanel.text = 'No data source configured\n 1 - Make sure you have a Yoctopuce sensor connected.\n 2 - Do a right-click  or a long touch on this widget.\n 3 - Choose "Configure this gauge" to bring up the properties editor.\n 4 - Choose a data source\n';
    this.prop = new AngularGaugeFormProperties(node, this);
    this._genProp = this.prop;
    let propDesc = GenericProperties.getAllProperties(this.prop);
    if (angularGaugeWidget.AnnotationPanelCount == 0) {
      for (let propname in propDesc.byName) {
        if (propname.startsWith("AngularGauge_annotationPanel"))
          angularGaugeWidget.AnnotationPanelCount++;
        if (propname.startsWith("AngularGauge_zone"))
          angularGaugeWidget.zonesCount++;
      }
    }
    for (let i = 0; i < angularGaugeWidget.zonesCount; i++) {
      this._angularGauge.AddZone();
    }
    for (let i = 0; i < angularGaugeWidget.AnnotationPanelCount; i++) {
      this._angularGauge.addAnnotationPanel();
    }
    this._angularGauge.setPatchAnnotationCallback((s) => {
      return this.AnnotationCallback(s);
    });
    this.initDataNode = node;
    this.updateWindowPositionProperties(this.prop);
    this.prop.ApplyAllProperties(this);
    YDataRenderer.minMaxCheckDisabled = true;
    this.prop.ApplyAllProperties(this._angularGauge);
    YDataRenderer.minMaxCheckDisabled = false;
    this._angularGauge.resetRefrenceSize();
    this._angularGauge.resizeRule = Proportional.ResizeRule.RELATIVETOBOTH;
    this.ApplyRelativeSizeIfRequired();
    if (this.SizeIsRelative)
      this.refreshProperties();
    this._angularGauge.AllowRedraw();
  }
  PropertyChanged2(src) {
    let info = new PropPathinfo();
    let path = src.ExtractPropPath(info);
    switch (info.propType) {
      case "Form":
        GenericProperties.copyProperty_STT(this, this.prop, info.fullpropname, path);
        break;
      case "AngularGauge":
        GenericProperties.copyProperty_STT(this._angularGauge, this.prop, info.fullpropname, path);
        break;
      case "DataSource":
        break;
    }
  }
  Get_PropertyValue(src) {
    let info = new PropPathinfo();
    let path = src.ExtractPropPath(info);
    switch (info.propType) {
      case "Form":
        return GenericProperties.newGetProperty(this, this.prop, info.fullpropname, path, null);
      case "AngularGauge":
        return GenericProperties.newGetProperty(this._angularGauge, this.prop, info.fullpropname, path, null);
    }
    return null;
  }
  edit() {
    super.edit();
    YWebPage.EditObject(this, this.prop, (src) => {
      this.PropertyChanged2(src);
    }, (src) => {
      return this.Get_PropertyValue(src);
    }, () => {
      this.editStopped();
    });
  }
  refreshProperties() {
    this.prop.RefreshAllProperties(this);
    this.prop.RefreshAllProperties(this._angularGauge);
    YWebPage.refreshPropertiesForm();
  }
  showStatus(status) {
    if (status != "")
      this._angularGauge.value = 0;
    this._angularGauge.showNeedle = status == "";
    this._angularGauge.statusLine = status;
  }
  SourceChanged(value, index) {
    this._angularGauge.DisableRedraw();
    this.noDataSourcepanel.enabled = value instanceof NullYSensor;
    if (value instanceof NullYSensor) {
      this.showStatus("N/A");
      this._angularGauge.unit = "";
    } else if (!value.isOnline()) {
      this.showStatus("OFFLINE");
    } else {
      this.showStatus("");
      this._angularGauge.unit = value.get_unit();
    }
    this._angularGauge.AllowRedraw();
    value.registerCallback(this);
  }
  SensorValuecallback(source, M) {
    if (this.prop == null)
      return;
    if (source == this.prop.DataSource_source) {
      this._angularGauge.DisableRedraw();
      if (this.prop.DataSource_source instanceof NullYSensor) {
        this.showStatus("N/A");
        this._angularGauge.unit = "";
      } else if (!this.prop.DataSource_source.isOnline()) {
        this.showStatus("OFFLINE");
      } else {
        this._angularGauge.DisableRedraw();
        this.showStatus("");
        this._angularGauge.unit = source.get_unit();
        this._angularGauge.value = M.get_averageValue();
        this._angularGauge.AllowRedraw();
      }
      this._angularGauge.AllowRedraw();
    }
  }
  getConfigData() {
    return "<angularGaugeForm>\n" + this.getContentsConfigData() + "</angularGaugeForm>\n";
  }
};
angularGaugeWidget.AnnotationPanelCount = 0;
angularGaugeWidget.zonesCount = 0;
var digitalDisplayWidget = class extends YWidget {
  getPropertiesXml() {
    return this.prop.getXml(1);
  }
  containerResized() {
    if (this._display != null)
      this._display.containerResized();
  }
  destroy() {
    this.prop.destroy();
    super.destroy();
    Object.entries(this).forEach((pair) => {
      Reflect.set(this, pair[0], null);
    });
  }
  AnnotationCallback(text) {
    let sensor = this.prop.DataSource_source;
    return this.PatchSensorAnnotationCallback(sensor, text);
  }
  contextMenuIsOpening() {
    YWebPage.snapshotMenuItem.userdata = this;
    YWebPage.snapshotMenuItem.visible = true;
    YWebPage.resetDataViewMenuItem.visible = false;
    if (YWebPage.editMenuItem == null)
      return;
    YWebPage.clearDataloggerMenuItem.visible = false;
    YWebPage.editMenuItem.caption = "Configure this digital display";
    YWebPage.editMenuItem.visible = true;
    YWebPage.deleteMenuItem.caption = "Delete this digital display";
    YWebPage.deleteMenuItem.visible = true;
    YWebPage.addMarkerMenuItem.visible = false;
    YWebPage.disableMarkerMenuItem.visible = false;
    YWebPage.editMenuItem.userdata = this;
    YWebPage.deleteMenuItem.userdata = this;
  }
  get confirmDeleteString() {
    return "Do you really want to delete this digital display ?";
  }
  constructor(node, editor, x, y, width, height) {
    super(node, editor, x, y, width, height);
    this._unit = "";
    this._display = new YDigitalDisplay(this.UIContainer, YWidget.log);
    this._genRenderer = this._display;
    this.noDataSourcepanel = this._display.addMessagePanel();
    this.noDataSourcepanel.font.size = constants.generalFontSize;
    this.noDataSourcepanel.text = 'No data source configured\n 1 - Make sure you have a Yoctopuce sensor connected.\n 2 - Do a right-click  or a long touch on this widget.\n 3 - Choose "Configure this digital display" to bring up the properties editor.\n 4 - Choose a data source\n';
    this.prop = new digitalDisplayFormProperties(node, this);
    this._genProp = this.prop;
    let propDesc = GenericProperties.getAllProperties(this.prop);
    if (digitalDisplayWidget.AnnotationPanelCount == 0) {
      for (let propname in propDesc.byName) {
        if (propname.startsWith("display_annotationPanel"))
          digitalDisplayWidget.AnnotationPanelCount++;
      }
    }
    for (let i = 0; i < digitalDisplayWidget.AnnotationPanelCount; i++) {
      this._display.addAnnotationPanel();
    }
    this._display.setPatchAnnotationCallback((s) => {
      return this.AnnotationCallback(s);
    });
    this._display.valueFormater = (source, value) => {
      return this.valueFormater(source, value);
    };
    this.updateWindowPositionProperties(this.prop);
    this.prop.ApplyAllProperties(this);
    YDataRenderer.minMaxCheckDisabled = true;
    this.prop.ApplyAllProperties(this._display);
    YDataRenderer.minMaxCheckDisabled = false;
    this._display.resetRefrenceSize();
    this._display.AllowPrintScreenCapture = true;
    this._display.resetRefrenceSize();
    this._display.resizeRule = Proportional.ResizeRule.RELATIVETOBOTH;
    this.ApplyRelativeSizeIfRequired();
    if (this.SizeIsRelative)
      this.refreshProperties();
    this._display.AllowRedraw();
  }
  valueFormater(source, value) {
    if (this.prop.DataSource_source instanceof NullYSensor) {
      return "N/A";
    } else if (!this.prop.DataSource_source.isOnline())
      return "OFFLINE";
    let format = this.prop.DataSource_precision;
    let p = format.indexOf(".");
    let n = 0;
    if (p >= 0)
      n = format.length - p - 1;
    let unit = this.prop.DataSource_source.get_unit();
    return value.toFixed(n) + unit;
  }
  PropertyChanged2(src) {
    let info = new PropPathinfo();
    let path = src.ExtractPropPath(info);
    switch (info.propType) {
      case "Form":
        GenericProperties.copyProperty_STT(this, this.prop, info.fullpropname, path);
        break;
      case "display":
        GenericProperties.copyProperty_STT(this._display, this.prop, info.fullpropname, path);
        break;
      case "DataSource":
        break;
    }
  }
  Get_PropertyValue(src) {
    let info = new PropPathinfo();
    let path = src.ExtractPropPath(info);
    switch (info.propType) {
      case "Form":
        return GenericProperties.newGetProperty(this, this.prop, info.fullpropname, path, null);
      case "display":
        return GenericProperties.newGetProperty(this._display, this.prop, info.fullpropname, path, null);
    }
    return null;
  }
  edit() {
    super.edit();
    YWebPage.EditObject(this, this.prop, (src) => {
      this.PropertyChanged2(src);
    }, (src) => {
      return this.Get_PropertyValue(src);
    }, () => {
      this.editStopped();
    });
  }
  refreshProperties() {
    this.prop.RefreshAllProperties(this);
    this.prop.RefreshAllProperties(this._display);
    YWebPage.refreshPropertiesForm();
  }
  SourceChanged(value, index) {
    this.noDataSourcepanel.enabled = value instanceof NullYSensor;
    this.SensorValuecallback(value, null);
    if (value instanceof NullYSensor) {
      this._display.alternateValue = "N/A";
    } else if (!value.isOnline())
      this._display.alternateValue = "OFFLINE";
    value.registerCallback(this);
  }
  SensorValuecallback(source, M) {
    if (this.prop == null)
      return;
    if (this.prop.DataSource_source instanceof NullYSensor) {
      this._display.alternateValue = "N/A";
    } else if (!this.prop.DataSource_source.isOnline()) {
      this._display.alternateValue = "OFFLINE";
    } else if (M == null) {
      this._display.alternateValue = "--" + this._unit;
    } else if (source == this.prop.DataSource_source) {
      this._display.DisableRedraw();
      this._display.alternateValue = null;
      this._display.value = M.get_averageValue();
      this._display.AllowRedraw();
    }
  }
  getConfigData() {
    return "<digitalDisplayForm>\n" + this.getContentsConfigData() + "</digitalDisplayForm>\n";
  }
};
digitalDisplayWidget.AnnotationPanelCount = 0;
var graphWidget = class extends YWidget {
  AnnotationCallback(text) {
    for (let i = 0; i < graphWidget.SeriesCount; i++) {
      let s = Reflect.get(this.prop, "Graph_series" + i.toString());
      let sensor = s.DataSource_source;
      let name = "None";
      let avgvalue = "N/A";
      let minvalue = "N/A";
      let maxvalue = "N/A";
      let unit = "";
      if (!(sensor instanceof NullYSensor)) {
        let resolution = -Math.round(Math.log10(sensor.get_resolution()));
        name = s.legend != "" ? s.legend : sensor.get_friendlyName();
        if (sensor.isOnline()) {
          avgvalue = sensor.get_lastAvgValue().toFixed(resolution);
          minvalue = sensor.get_lastMinValue().toFixed(resolution);
          maxvalue = sensor.get_lastMaxValue().toFixed(resolution);
        }
        unit = sensor.get_unit();
      }
      text = text.replace("$NAME" + (i + 1).toString() + "$", name);
      text = text.replace("$AVGVALUE" + (i + 1).toString() + "$", avgvalue);
      text = text.replace("$MAXVALUE" + (i + 1).toString() + "$", maxvalue);
      text = text.replace("$MINVALUE" + (i + 1).toString() + "$", minvalue);
      text = text.replace("$UNIT" + (i + 1).toString() + "$", unit);
    }
    return text;
  }
  destroy() {
    this.prop.destroy();
    super.destroy();
    Object.entries(this).forEach((pair) => {
      Reflect.set(this, pair[0], null);
    });
  }
  getPropertiesXml() {
    return this.prop.getXml(1);
  }
  containerResized() {
    if (this._graph != null)
      this._graph.containerResized();
  }
  contextMenuIsOpening() {
    YWebPage.snapshotMenuItem.userdata = this;
    YWebPage.snapshotMenuItem.visible = true;
    YWebPage.resetDataViewMenuItem.visible = true;
    YWebPage.resetDataViewMenuItem.userdata = this;
    if (YWebPage.editMenuItem == null)
      return;
    YWebPage.clearDataloggerMenuItem.visible = true;
    YWebPage.clearDataloggerMenuItem.userdata = this;
    YWebPage.editMenuItem.caption = "Configure this graph";
    YWebPage.editMenuItem.visible = true;
    YWebPage.deleteMenuItem.caption = "Delete this graph";
    YWebPage.deleteMenuItem.visible = true;
    YWebPage.addMarkerMenuItem.visible = true;
    YWebPage.disableMarkerMenuItem.visible = true;
    YWebPage.editMenuItem.userdata = this;
    YWebPage.deleteMenuItem.userdata = this;
    YWebPage.disableMarkerMenuItem.userdata = this;
    for (let i = 0; i < YWebPage.markersSubMenuItems.length; i++) {
      YWebPage.markersSubMenuItems[i].caption = "Place marker #" + (i + 1).toString();
      YWebPage.markersSubMenuItems[i].userdata = this;
    }
  }
  startMarkerCapture(markerIndex) {
    this.markers[markerIndex].startCapture();
  }
  AxisParamtersChangedAutomatically(source) {
    let yaxis = source.userData;
    yaxis.visible = source.visible;
    YWebPage.refreshPropertiesForm();
  }
  get confirmDeleteString() {
    return "Do you really want to delete this graph ?";
  }
  constructor(node, editor, x, y, width, height) {
    super(node, editor, x, y, width, height);
    this.editedMarkerWasEnabled = false;
    this.editedMarkerPosition = 0;
    this._graph = new YGraph(this.UIContainer, YWidget.log);
    this.noDataSourcepanel = this._graph.addMessagePanel();
    this.noDataSourcepanel.font.size = constants.generalFontSize;
    this.noDataSourcepanel.text = 'No data source configured\n 1 - Make sure you have a Yoctopuce sensor connected.\n 2 - Do a right-click  or a long touch on this widget.\n 3 - Choose "Configure this graph" to bring up the properties editor.\n 4 - Choose a data source\n';
    this.dataloggerProgress = this._graph.addMessagePanel();
    this.dataloggerProgress.font.size = 12 * constants.guiDPIFactor;
    this.dataloggerProgress.font.color = YColor.DarkGray;
    this.dataloggerProgress.borderColor = YColor.Gray;
    this.dataloggerProgress.panelHrzAlign = MessagePanel.HorizontalAlignPos.LEFT;
    this.dataloggerProgress.panelVrtAlign = MessagePanel.VerticalAlignPos.TOP;
    this.dataloggerProgress.text = graphWidget.DataLoggerLoadingMsg;
    this.dataloggerProgress.enabled = false;
    this.prop = new GraphFormProperties(node, this);
    this._genProp = this.prop;
    let propDesc = GenericProperties.getAllProperties(this.prop);
    if (graphWidget.YAxisCount == 0) {
      for (let propname in propDesc.byName) {
        if (propname.startsWith("Graph_annotationPanel"))
          graphWidget.AnnotationPanelCount++;
        if (propname.startsWith("Graph_series"))
          graphWidget.SeriesCount++;
        if (propname.startsWith("Graph_yAxes"))
          graphWidget.YAxisCount++;
      }
    }
    if (graphWidget.ZoneCountPerYaxis == 0) {
      let yAxisProp = new YaxisDescription(0, false);
      let propDesc2 = GenericProperties.getAllProperties(yAxisProp);
      for (let propname in propDesc2.byName) {
        if (propname.startsWith("zones"))
          graphWidget.ZoneCountPerYaxis++;
      }
    }
    if (graphWidget.MarkerCountPerXaxis == 0) {
      let xAxisProp = new XaxisDescription();
      let propDesc2 = GenericProperties.getAllProperties(xAxisProp);
      for (let propname in propDesc2.byName) {
        if (propname.startsWith("markers"))
          graphWidget.MarkerCountPerXaxis++;
      }
    }
    this.offLineSourcesPanel = this._graph.addMessagePanel();
    this.offLineSourcesPanel.bgColor = YColor.FromArgb(192, 255, 192, 192);
    this.offLineSourcesPanel.borderColor = YColor.DarkRed;
    this.offLineSourcesPanel.font.color = YColor.DarkRed;
    this.offLineSourcesPanel.panelHrzAlign = MessagePanel.HorizontalAlignPos.RIGHT;
    this.offLineSourcesPanel.panelVrtAlign = MessagePanel.VerticalAlignPos.TOP;
    this.captureRunningPanel = this._graph.addMessagePanel();
    this.captureRunningPanel.bgColor = YColor.FromArgb(240, 200, 255, 193);
    this.captureRunningPanel.borderColor = YColor.DarkGreen;
    this.captureRunningPanel.font.color = YColor.DarkGreen;
    this.captureRunningPanel.panelHrzAlign = MessagePanel.HorizontalAlignPos.LEFT;
    this.captureRunningPanel.panelVrtAlign = MessagePanel.VerticalAlignPos.TOP;
    for (let i = 0; i < graphWidget.YAxisCount; i++) {
      let axis = this._graph.addYAxis();
      for (let j = 0; j < graphWidget.ZoneCountPerYaxis; j++) {
        axis.AddZone();
      }
    }
    this.markers = [];
    for (let i = 0; i < graphWidget.MarkerCountPerXaxis; i++) {
      let m = this._graph.xAxis.AddMarker();
      m.xposition = TimeConverter.ToUnixTime(new Date()) + i * 60;
      this.markers.push(m);
    }
    for (let i = 0; i < graphWidget.AnnotationPanelCount; i++) {
      this._graph.addAnnotationPanel();
    }
    this.seriesProperties = [];
    for (let i = 0; i < graphWidget.SeriesCount; i++) {
      this.seriesProperties.push(Reflect.get(this.prop, "Graph_series" + i.toString()));
      this._graph.addSerie();
    }
    this._graph.yAxes[0].visible = true;
    this._graph.setPatchAnnotationCallback((s) => {
      return this.AnnotationCallback(s);
    });
    this._genRenderer = this._graph;
    this._graph.resetRefrenceSize();
    this._graph.AllowPrintScreenCapture = true;
    this._graph.setMarkerCaptureCallbacks((m) => {
      this.MarkedCaptureStarted(m);
    }, (m) => {
      this.MarkedCaptureStopped(m);
    });
    this.offlineMessages = new Array(graphWidget.SeriesCount);
    this.showOffline = new Array(graphWidget.SeriesCount);
    this.updateWindowPositionProperties(this.prop);
    this.prop.ApplyAllProperties(this);
    YDataRenderer.minMaxCheckDisabled = true;
    this.prop.ApplyAllProperties(this._graph);
    YDataRenderer.minMaxCheckDisabled = false;
    for (let i = 0; i < graphWidget.YAxisCount; i++) {
      this._graph.yAxes[i].AxisChanged = () => {
        this.AxisParamtersChangedAutomatically(this._graph.yAxes[i]);
      };
      this._graph.yAxes[i].AllowAutoShow = true;
    }
    for (let i = 0; i < graphWidget.SeriesCount; i++) {
      let s = Reflect.get(this.prop, "Graph_series" + i.toString());
      s.Init(this, i);
      if (s.DataSource_source != null) {
        this.SourceChanged(s.DataSource_source, i);
      }
    }
    this._graph.resetRefrenceSize();
    this._graph.resizeRule = Proportional.ResizeRule.FIXED;
    this.ApplyRelativeSizeIfRequired();
    if (this.SizeIsRelative)
      this.refreshProperties();
    this.loadRecordedDataIfNeeded();
    this._graph.AllowRedraw();
  }
  MarkedCaptureStarted(src) {
    let str = src.text != "" ? 'Click to place the "' + src.shortText + '" marker.' : "Click to place the marker.";
    str += "\nRight-click to cancel the operation.";
    this.editedMarkerWasEnabled = src.enabled;
    this.editedMarkerPosition = src.positionOnXAxis.value;
    this.captureRunningPanel.text = str;
    this.captureRunningPanel.enabled = true;
  }
  MarkedCaptureStopped(src) {
    if (src != null) {
      if (this.editedMarkerWasEnabled != src.enabled && this.editedMarkerPosition != src.positionOnXAxis.value) {
        constants.edited = true;
      }
    }
    this.captureRunningPanel.enabled = false;
    this.refreshProperties();
  }
  refreshProperties() {
    this.prop.RefreshAllProperties(this);
    this.prop.RefreshAllProperties(this._graph);
    YWebPage.refreshPropertiesForm();
  }
  decomposeToSegments(data, start, dataCount) {
    let n1 = start;
    let n2 = 0;
    let l = [];
    let deltaT = 0;
    while (n1 < start + dataCount - 1) {
      try {
        deltaT = data[n1 + 1].DateTime - data[n1].DateTime;
      } catch (Exception) {
        debugger;
      }
      n2 = n1 + 1;
      while (n2 < dataCount && data[n2].DateTime - data[n2 - 1].DateTime < 2 * deltaT) {
        n2++;
      }
      let count = n2 - n1;
      if (count > 0) {
        let p = new Array(count);
        for (let i = 0; i < count; i++) {
          p[i] = new pointXY(data[n1 + i].DateTime, data[n1 + i].value);
        }
        l.push(p);
      }
      n1 = n2;
    }
    return l;
  }
  SourceChanged(value, index) {
    this._graph.DisableRedraw();
    let s;
    let noDataSource = true;
    for (let i = 0; i < graphWidget.SeriesCount; i++) {
      s = Reflect.get(this.prop, "Graph_series" + i.toString());
      if (!(s.DataSource_source instanceof NullYSensor))
        noDataSource = false;
    }
    this.noDataSourcepanel.enabled = noDataSource;
    if (value != null) {
      if (!(value instanceof NullYSensor)) {
        if (value.isOnline()) {
          this.showOffline[index] = false;
        } else {
          this.offlineMessages[index] = value.get_friendlyName() + " is OFFLINE";
          this.showOffline[index] = true;
          logForm.log(value.get_friendlyName() + " is OFFLINE");
        }
      } else {
        this.showOffline[index] = false;
      }
    } else {
      this.showOffline[index] = false;
    }
    this.updateOfflinePanel();
    this.preLoadSensorData(value, index);
    this.loadRecordedDataIfNeeded();
    if (value)
      value.registerCallback(this);
    this._graph.AllowRedraw();
  }
  SensorArrivalcallback(source) {
    this.loadRecordedDataIfNeeded();
  }
  preLoadSensorData(value, index) {
    if (value instanceof NullYSensor) {
      this._graph.series[index].clear();
      return;
    }
    let s = Reflect.get(this.prop, "Graph_series" + index.toString());
    let data;
    switch (s.DataSource_datatype) {
      case 1:
        data = value.minData;
        break;
      case 2:
        data = value.maxData;
        break;
      default:
        data = value.curData;
        break;
    }
    let l = this.decomposeToSegments(data, 0, data.length);
    this._graph.series[index].clear();
    for (let i = l.length - 1; i >= 0; i--) {
      this._graph.series[index].InsertPoints(l[i]);
    }
    this._graph.series[index].rebuildSummaries();
  }
  PropertyChanged2(src) {
    let info = new PropPathinfo();
    let path = src.ExtractPropPath(info);
    switch (info.propType) {
      case "Form":
        GenericProperties.copyProperty_STT(this, this.prop, info.fullpropname, path);
        break;
      case "Graph":
        GenericProperties.copyProperty_STT(this._graph, this.prop, info.fullpropname, path);
        break;
      case "DataSource":
        break;
    }
  }
  Get_PropertyValue(src) {
    let info = new PropPathinfo();
    let path = src.ExtractPropPath(info);
    switch (info.propType) {
      case "Form":
        return GenericProperties.newGetProperty(this, this.prop, info.fullpropname, path, null);
      case "Graph":
        return GenericProperties.newGetProperty(this._graph, this.prop, info.fullpropname, path, null);
      case "DataSource":
        return null;
    }
    return null;
  }
  edit() {
    super.edit();
    YWebPage.EditObject(this, this.prop, (src) => {
      this.PropertyChanged2(src);
    }, (src) => {
      return this.Get_PropertyValue(src);
    }, () => {
      this.editStopped();
    });
  }
  updateOfflinePanel() {
    let message = "";
    for (let i = 0; i < graphWidget.SeriesCount; i++) {
      if (this.showOffline[i])
        message = message + (message != "" ? "\n" : "") + this.offlineMessages[i];
    }
    if (message == "" && this.offLineSourcesPanel.enabled)
      this.offLineSourcesPanel.enabled = false;
    if (message != "" && (this.offLineSourcesPanel.text != message || !this.offLineSourcesPanel.enabled)) {
      this.offLineSourcesPanel.text = message;
      this.offLineSourcesPanel.enabled = true;
    }
  }
  SensorValuecallback(source, M) {
    if (this.prop == null)
      return;
    for (let i = 0; i < graphWidget.SeriesCount; i++) {
      let s = this.seriesProperties[i];
      if (s.DataSource_source == source) {
        if (!s.DataSource_source.isOnline()) {
          this.offlineMessages[i] = s.DataSource_source.get_friendlyName() + " is OFFLINE";
          this.showOffline[i] = true;
          this.updateOfflinePanel();
          return;
        }
        this.showOffline[i] = false;
        this.updateOfflinePanel();
        let index = s.DataSource_source.curData.length - 1;
        if (index >= 0)
          switch (s.DataSource_datatype) {
            case 1:
              this._graph.series[i].AddPoint(new pointXY(s.DataSource_source.minData[index].DateTime, s.DataSource_source.minData[index].value));
              break;
            case 2:
              this._graph.series[i].AddPoint(new pointXY(s.DataSource_source.maxData[index].DateTime, s.DataSource_source.maxData[index].value));
              break;
            default:
              this._graph.series[i].AddPoint(new pointXY(s.DataSource_source.curData[index].DateTime, s.DataSource_source.curData[index].value));
              break;
          }
        this._graph.series[i].unit = s.DataSource_source.get_unit();
      }
    }
  }
  disableAllMarkers() {
    confirm.ask("Do you really want to disable all markers?", () => {
      for (let i = 0; i < this.markers.length; i++) {
        this.markers[i].enabled = false;
      }
    }, () => {
    }, null);
  }
  clearDataLogger() {
    confirm.ask("Do you really want to erase contents of all dataloggers related to this graph?", () => {
      this.startToClearDataLoggers();
    }, () => {
    }, null);
  }
  truncateView() {
    for (let i = 0; i < graphWidget.SeriesCount; i++) {
      this._graph.series[i].clear();
    }
    let FirstLiveValue = Math.floor(new Date().getTime() / 1e3);
    this._graph.xAxis.set_minMax(FirstLiveValue, FirstLiveValue + this._graph.xAxis.initialZoom);
  }
  resetDataView() {
    this.prop.Graph_showRecordedData = false;
    this.truncateView();
  }
  async startToClearDataLoggers() {
    let loggers = [];
    for (let i = 0; i < graphWidget.SeriesCount; i++) {
      let s = Reflect.get(this.prop, "Graph_series" + i.toString());
      let sensor = s.DataSource_source;
      if (!(sensor instanceof NullYSensor)) {
        sensor.stopDataloggerloading();
        let serial = sensor.get_hardwareId();
        let n = serial.indexOf(".");
        serial = serial.substring(0, n);
        let d = await YDataLogger.FindDataLogger(serial + ".dataLogger");
        if (await d.isOnline()) {
          let found = false;
          for (let j = 0; j < loggers.length; j++) {
            if (loggers[j] == d)
              found = true;
          }
          if (!found)
            loggers.push(d);
        }
      }
    }
    for (let i = 0; i < loggers.length; i++) {
      await loggers[i].forgetAllDataStreams();
      await loggers[i].set_recording(YDataLogger.RECORDING_ON);
    }
    let tmp = this.prop.Graph_showRecordedData;
    this.prop.Graph_showRecordedData = false;
    this.truncateView();
    this.prop.Graph_showRecordedData = tmp;
  }
  dataLoggerLoadprocessIsRunningNotification(source) {
    let loadTotalPercent = 0;
    let sensorCount = 0;
    if (!this.prop.Graph_showRecordedData)
      return;
    for (let i = 0; i < graphWidget.SeriesCount; i++) {
      let s = Reflect.get(this.prop, "Graph_series" + i.toString());
      let sensor = s.DataSource_source;
      if (sensor.dataloggerLoadisRunning) {
        loadTotalPercent += sensor.dataloggerLoadProgress;
        sensorCount++;
      }
    }
    if (sensorCount > 0)
      this.dataloggerProgress.text = graphWidget.DataLoggerLoadingMsg + " (" + (loadTotalPercent / sensorCount).toFixed(0) + "%)";
    let showPanel = sensorCount > 0 && loadTotalPercent > 0 && loadTotalPercent < sensorCount * 100;
    this.dataloggerProgress.enabled = showPanel;
  }
  SensorNewDataBlock(source, sourceFromIndex, sourcetoIndex, targetIndex, fromDataLogger) {
    if (this.prop == null)
      return;
    if (fromDataLogger && !this.prop.Graph_showRecordedData)
      return;
    let l = null;
    for (let i = 0; i < graphWidget.SeriesCount; i++) {
      let s = Reflect.get(this.prop, "Graph_series" + i.toString());
      if (s.DataSource_source == source) {
        let count = sourcetoIndex - sourceFromIndex + 1;
        if (count > 1) {
          switch (s.DataSource_datatype) {
            case 1:
              l = this.decomposeToSegments(s.DataSource_source.minData, sourceFromIndex, count);
              for (let j = l.length - 1; j >= 0; j--) {
                this._graph.series[i].InsertPoints(l[j]);
              }
              break;
            case 2:
              l = this.decomposeToSegments(s.DataSource_source.maxData, sourceFromIndex, count);
              for (let j = l.length - 1; j >= 0; j--) {
                this._graph.series[i].InsertPoints(l[j]);
              }
              break;
            default:
              l = this.decomposeToSegments(s.DataSource_source.curData, sourceFromIndex, count);
              for (let j = l.length - 1; j >= 0; j--) {
                this._graph.series[i].InsertPoints(l[j]);
              }
              break;
          }
        }
      }
    }
  }
  loadRecordedDataIfNeeded() {
    if (this.prop == null)
      return;
    if (!this.prop.Graph_showRecordedData)
      return;
    for (let i = 0; i < graphWidget.SeriesCount; i++) {
      let s = Reflect.get(this.prop, "Graph_series" + i.toString());
      s.DataSource_source.startDataloggerload(this);
    }
  }
  removeDataloggerData() {
  }
  DataloggerCompleted(Source) {
    if (!this.prop.Graph_showRecordedData)
      return;
    let props = GenericProperties.getAllProperties(this.prop);
    for (let i = 0; i < this.seriesProperties.length; i++) {
      if (this.seriesProperties[i].DataSource_source == Source) {
        if (!this.seriesProperties[i].dataloggerAlreadyLoaded) {
          this._graph.DisableRedraw();
          this.preLoadSensorData(Source, i);
          this._graph.AllowRedraw();
        }
      }
    }
  }
  getConfigData() {
    return "<GraphForm>\n" + this.getContentsConfigData() + "</GraphForm>\n";
  }
};
graphWidget.AnnotationPanelCount = 0;
graphWidget.SeriesCount = 0;
graphWidget.ZoneCountPerYaxis = 0;
graphWidget.MarkerCountPerXaxis = 0;
graphWidget.YAxisCount = 0;
graphWidget.DataLoggerLoadingMsg = "Loading from datalogger";

// obj/full/propertiesMngmt.js
var YXmlNode = class {
  constructor(node) {
    this.node = node;
  }
  get Name() {
    return this.node.nodeName;
  }
  get_childsByName() {
    let res = {};
    this.node.childNodes.forEach((child) => {
      res[child.nodeName] = new YXmlNode(child);
    });
    return res;
  }
  get_childsByIndex() {
    let res = [];
    this.node.childNodes.forEach((child) => {
      res.push(new YXmlNode(child));
    });
    return res;
  }
  get_attributes() {
    let el = this.node;
    let res = {};
    let keys = el.getAttributeNames();
    for (let i = 0; i < keys.length; i++) {
      res[keys[i]] = el.getAttribute(keys[i]);
    }
    return res;
  }
  get Attributes() {
    return this.get_attributes();
  }
};
var PropertyAccess = class {
  constructor() {
    this.ttype = "";
    this.stype = "";
    this.finalTarget = null;
    this.terminalSource = null;
    this.propertyName = null;
  }
};
var doubleNan = class {
  constructor(v) {
    this._value = Number.NaN;
    if (typeof v == "undefined") {
      return;
    } else if (typeof v == "number") {
      this._value = v;
    } else if (typeof v == "string") {
      if (v == "") {
        this._value = Number.NaN;
      } else {
        this._value = Number(v);
      }
    } else {
      debugger;
    }
  }
  toString() {
    if (Number.isNaN(this._value))
      return "";
    return this._value.toString();
  }
  clone() {
    return new doubleNan(this.value);
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value;
  }
};
var PropertyDescriptor = class {
  constructor(name) {
    this.isWritable = false;
    this.isEnum = false;
    this.type = "";
    this.Attributes = {};
    this.name = name;
  }
};
var PropertiesList = class {
  constructor() {
    this.byIndex = [];
    this.byName = {};
  }
};
var PropDescription = class {
  constructor(name, prop) {
    this.name = name;
    this.prop = prop;
  }
};
var GenericProperties = class {
  static NoFilter(propNname) {
    return true;
  }
  static escapeXml(unsafe) {
    return unsafe.replace(/[^ !#$%(-;=?-z]/g, (c) => "&#" + c.charCodeAt(0) + ";");
  }
  constructor(Owner) {
    this._Form_Text = "New window";
    this._Form_BackColor = YColor.FromArgb(255, 240, 240, 240);
    this._Form_BorderColor = YColor.LightGray;
    this._SizeIsRelative = false;
    this._Form_PositionX = 0;
    this._Form_PositionY = 0;
    this._Form_Width = 300;
    this._Form_Height = 200;
    this._containerID = "";
    this.ownerForm = Owner;
    this._Form_Text = "new window";
  }
  destroy() {
    Object.entries(this).forEach((pair) => {
      Reflect.set(this, pair[0], null);
    });
  }
  initFromXmlData(initData) {
    if (initData != null)
      this.loadProperties(initData, this.ownerForm, this);
  }
  loadProperties(initData, Owner, o) {
    let value;
    this.ownerForm = Owner;
    if (initData != null) {
      let properties = GenericProperties.getAllProperties(o);
      let childs = initData.get_childsByName();
      for (let propname in properties.byName) {
        let p = properties.byName[propname];
        if (p.isWritable) {
          for (let childName in childs) {
            if (childName == propname) {
              let target = Reflect.get(o, propname);
              let Mustload = true;
              if ("NotSavedInXMLAttribute" in p.Attributes) {
                Mustload = p.Attributes["NotSavedInXMLAttribute"];
              }
              if (Mustload) {
                if (GenericProperties.IsStructured(target)) {
                  this.loadProperties(childs[childName], Owner, target);
                } else {
                  let targetType = typeof target;
                  let attributes = childs[childName].get_attributes();
                  let value2 = attributes["value"];
                  if (target instanceof CustomYSensor) {
                    if (value2.toUpperCase() != "NULL" && value2 != "") {
                      let s = sensorsManager.AddNewSensor(value2);
                      Reflect.set(o, propname, s);
                    } else {
                      Reflect.set(o, propname, sensorsManager.getNullSensor());
                    }
                  } else if (target instanceof YEnumItem) {
                    Reflect.set(o, propname, target.fromString(value2));
                  } else if (target instanceof doubleNan) {
                    let d = new doubleNan(value2);
                    Reflect.set(o, propname, d);
                  } else if (target instanceof xAxisPosition) {
                    let xpos = Number(value2);
                    let rel = attributes["relative"].toUpperCase() == "TRUE";
                    Reflect.set(o, propname, new xAxisPosition(xpos, rel));
                  } else if (target instanceof YColor) {
                    let c = YColor.FromString(value2);
                    if (c == null)
                      c = YColor.Black;
                    Reflect.set(o, propname, c.clone());
                  } else if (target instanceof YFont) {
                    let size = attributes["size"];
                    let color = attributes["color"];
                    let italic = attributes["italic"];
                    let bold = attributes["bold"];
                    let f = Reflect.get(o, propname);
                    f.name = value2;
                    f.size = size !== "undefined" ? Number(size) : 10;
                    let c = YColor.FromString(color);
                    f.color = c != null ? c : YColor.Black.clone();
                    f.italic = italic.toUpperCase() == "TRUE";
                    f.bold = bold.toUpperCase() == "TRUE";
                  } else {
                    switch (targetType) {
                      case "string":
                        Reflect.set(o, propname, value2);
                        break;
                      case "number":
                        Reflect.set(o, propname, Number(value2));
                        break;
                      case "boolean":
                        let v = value2.toUpperCase() == "TRUE";
                        Reflect.set(o, propname, v);
                        break;
                      default:
                        debugger;
                        throw "unhandled target type : " + targetType + "(" + target.constructor.name + ")";
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  get ATTR_Form_Text__DisplayName() {
    return "Window title";
  }
  get ATTR_Form_Text__CategoryAttribute() {
    return "Window";
  }
  get ATTR_Form_Text__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_Form_Text__DescriptionAttribute() {
    return "Widget name. This name is not show on display, but it might help you to identify each widget. ";
  }
  get Form_Text() {
    return this._Form_Text;
  }
  set Form_Text(value) {
    this._Form_Text = value;
  }
  get ATTR_Form_BackColor__DisplayName() {
    return "Background color";
  }
  get ATTR_Form_BackColor__CategoryAttribute() {
    return "Window";
  }
  get ATTR_Form_BackColor__DescriptionAttribute() {
    return "Window background color.";
  }
  get Form_BackColor() {
    return this._Form_BackColor;
  }
  set Form_BackColor(value) {
    this._Form_BackColor = value;
  }
  get ATTR_Form_BorderColor__DisplayName() {
    return "Border color";
  }
  get ATTR_Form_BorderColor__CategoryAttribute() {
    return "Window";
  }
  get ATTR_Form_BorderColor__DescriptionAttribute() {
    return "Window border color, use transparent color to hide the border.";
  }
  get Form_BorderColor() {
    return this._Form_BorderColor;
  }
  set Form_BorderColor(value) {
    this._Form_BorderColor = value;
  }
  get ATTR_Form_SizeIsRelative__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_Form_SizeIsRelative__DisplayName() {
    return "Rel. size and pos.";
  }
  get ATTR_Form_SizeIsRelative__CategoryAttribute() {
    return "Window";
  }
  get ATTR_Form_SizeIsRelative__DescriptionAttribute() {
    return "Makes widget size and position relative to container size. This, for instance, allows to make a widget automatically occupy all of the browser viewport, no matter the browser window size. In relative mode, position and size value are expressed in %";
  }
  get ATTR_Form_SizeIsRelative__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get Form_SizeIsRelative() {
    return this._SizeIsRelative;
  }
  set Form_SizeIsRelative(value) {
    this._SizeIsRelative = value;
  }
  get ATTR_Form_PositionX__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_Form_PositionX__DisplayName() {
    return "Left";
  }
  get ATTR_Form_PositionX__CategoryAttribute() {
    return "Window";
  }
  get ATTR_Form_PositionX__DescriptionAttribute() {
    return "Widget left border X position";
  }
  get Form_PositionX() {
    return this._Form_PositionX;
  }
  set Form_PositionX(value) {
    this._Form_PositionX = value;
  }
  get ATTR_Form_PositionY__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_Form_PositionY__DisplayName() {
    return "Top";
  }
  get ATTR_Form_PositionY__CategoryAttribute() {
    return "Window";
  }
  get ATTR_Form_PositionY__DescriptionAttribute() {
    return "Widget top border Y position";
  }
  get Form_PositionY() {
    return this._Form_PositionY;
  }
  set Form_PositionY(value) {
    this._Form_PositionY = value;
  }
  get ATTR_Form_Width__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_Form_Width__DisplayName() {
    return "Width";
  }
  get ATTR_Form_Width__CategoryAttribute() {
    return "Window";
  }
  get ATTR_Form_Width__DescriptionAttribute() {
    return "Widget width";
  }
  get Form_Width() {
    return this._Form_Width;
  }
  set Form_Width(value) {
    this._Form_Width = value;
  }
  get ATTR_Form_Height__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_Form_Height__DisplayName() {
    return "Height";
  }
  get ATTR_Form_Height__CategoryAttribute() {
    return "Window";
  }
  get ATTR_Form_Height__DescriptionAttribute() {
    return "Widget height";
  }
  get Form_Height() {
    return this._Form_Height;
  }
  set Form_Height(value) {
    this._Form_Height = value;
  }
  get ATTR_Form_containerID__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_Form_containerID__DisplayName() {
    return "Container ID";
  }
  get ATTR_Form_containerID__CategoryAttribute() {
    return "Window";
  }
  get ATTR_Form_containerID__DescriptionAttribute() {
    return "Forces the widget to be shown inside an HTML element with a specific ID already present on the page. If ID is empty, the widget is inserted at root level. Be aware that X,Y offsets are kept, you may want to set them to Zero. ";
  }
  get Form_containerID() {
    return this._containerID;
  }
  set Form_containerID(value) {
    this._containerID = value;
  }
  indent(n) {
    return " ".repeat(n);
  }
  getXml(deep, o) {
    if (typeof o == "undefined")
      o = this;
    let res = "";
    let value = "";
    let properties = GenericProperties.getAllProperties(o);
    let propName = "";
    for (propName in properties.byName) {
      let p = properties.byName[propName];
      if (p.isWritable) {
        let Mustsave = true;
        if ("NotSavedInXMLAttribute" in p.Attributes)
          Mustsave = !p.Attributes["NotSavedInXMLAttribute"];
        let child = Reflect.get(o, p.name);
        if (GenericProperties.IsStructured(child)) {
          if (Mustsave) {
            res = res + this.indent(2 * deep) + "<" + p.name + ">\r\n" + this.getXml(deep + 1, child) + this.indent(2 * deep) + "</" + p.name + ">\r\n";
          }
        } else {
          if (Mustsave) {
            if (child instanceof YEnumItem) {
              value = child.toString;
            } else {
              let type = typeof child;
              if (type == "object")
                type = child.constructor.name;
              switch (type) {
                case "boolean":
                  value = child ? "TRUE" : "FALSE";
                  break;
                case "number":
                  value = child.toString();
                  break;
                case "string":
                  value = GenericProperties.escapeXml(child);
                  break;
                case YColor.name:
                  value = child.toString();
                  break;
                case doubleNan.name:
                  value = child.value.toString();
                  break;
                case xAxisPosition.name:
                  let it = child;
                  value = it.value.toString() + '" relative="' + (it.relative ? "True" : "False");
                  break;
                case NullYSensor.name:
                case CustomYSensor.name:
                  let s = child;
                  value = s == null || s instanceof NullYSensor ? "NULL" : s.get_hardwareId();
                  break;
                default:
                  throw "XML generation : unhandled type (" + p.type + ")";
              }
            }
            res = res + this.indent(2 * deep) + "<" + p.name + ' value="' + value + '"/>\n';
          }
        }
      }
    }
    return res;
  }
  static IsStructured(o) {
    if (o == null)
      return false;
    if (typeof o === "string" || o instanceof String)
      return false;
    if (typeof o === "number" || o instanceof Number)
      return false;
    if (typeof o === "boolean" || o instanceof Boolean)
      return false;
    if (o instanceof YEnumItem)
      return false;
    if (o instanceof CustomYSensor)
      return false;
    if (o instanceof YColor)
      return false;
    if (o instanceof doubleNan)
      return false;
    if (o instanceof xAxisPosition)
      return false;
    if (Object.getOwnPropertyNames(o).length > 0)
      return true;
    return false;
  }
  static getObjectFromPath(rootTarget, path) {
    let FinalTarget = rootTarget;
    for (let i = 0; i < path.length - 1; i++) {
      let name = path[i];
      let index = "";
      while (name.charCodeAt(name.length - 1) >= 48 && name.charCodeAt(name.length - 1) <= 57) {
        index = name.charAt(name.length - 1) + index;
        name = name.substring(0, name.length - 1);
      }
      if (index == "") {
        FinalTarget = Reflect.get(FinalTarget, name);
      } else {
        let arrayObject = Reflect.get(FinalTarget, name);
        FinalTarget = Reflect.get(arrayObject, parseInt(index));
      }
    }
    return FinalTarget;
  }
  static computePropertyAccess_SFT(WidgetObject, SettingObject, propertySourceName, path) {
    let res = new PropertyAccess();
    res.ttype = "";
    res.stype = "";
    res.finalTarget = null;
    res.terminalSource = null;
    res.terminalSource = GenericProperties.getObjectFromPath(WidgetObject, path);
    let props = GenericProperties.getAllProperties(res.terminalSource);
    if (!(path[path.length - 1] in props.byName))
      return res;
    res.stype = typeof res.terminalSource[path[path.length - 1]];
    if (res.stype == "object" && res.terminalSource[path[path.length - 1]] != null) {
      res.stype = res.terminalSource[path[path.length - 1]].constructor.name;
    }
    res.terminalSource = res.terminalSource[path[path.length - 1]];
    if (res.terminalSource == null)
      return res;
    res.propertyName = propertySourceName;
    res.finalTarget = SettingObject;
    let o = res.finalTarget[propertySourceName];
    res.ttype = typeof o;
    if (res.ttype == "object" && o != null)
      res.ttype = o.constructor.name;
    if (path.length <= 1)
      return res;
    for (let i = 1; i < path.length; i++) {
      res.finalTarget = res.finalTarget[res.propertyName];
      res.propertyName = path[i];
    }
    res.ttype = typeof res.finalTarget[res.propertyName];
    if (res.ttype == "object" && res.finalTarget[res.propertyName] != null)
      res.ttype = res.finalTarget[res.propertyName].constructor.name;
    return res;
  }
  static Reflect_getIndexed(o, indexedProp) {
    let res = Reflect.get(o, indexedProp);
    if (typeof res !== "undefined")
      return res;
    let name = indexedProp;
    let index = "";
    while (name.charCodeAt(name.length - 1) >= 48 && name.charCodeAt(name.length - 1) <= 57) {
      index = name.charAt(name.length - 1) + index;
      name = name.substring(0, name.length - 1);
    }
    if (index == "") {
      return null;
    }
    res = Reflect.get(o, name);
    return Reflect.get(res, parseInt(index));
  }
  static computePropertyAccess(rootTarget, source, propertySourceName, path) {
    let res = new PropertyAccess();
    res.ttype = "";
    res.finalTarget = GenericProperties.getObjectFromPath(rootTarget, path);
    res.terminalSource = source;
    res.terminalSource = Reflect.get(res.terminalSource, propertySourceName);
    for (let i = 1; i < path.length; i++) {
      res.terminalSource = Reflect.get(res.terminalSource, path[i]);
    }
    res.stype = typeof res.terminalSource;
    if (res.stype == "object")
      res.stype = res.terminalSource.constructor.name;
    if (path.length > 0) {
      res.propertyName = path[path.length - 1];
      let o = GenericProperties.Reflect_getIndexed(rootTarget, path[0]);
      if (o == null)
        return null;
      for (let i = 1; i < path.length; i++) {
        try {
          o = GenericProperties.Reflect_getIndexed(o, path[i]);
        } catch (e) {
          debugger;
        }
      }
      res.ttype = typeof o;
      if (res.ttype == "object")
        res.ttype = o.constructor.name;
    } else {
      let targetname = propertySourceName;
      let n = targetname.indexOf("__");
      res.propertyName = targetname.substring(n + 2);
      let o = Reflect.get(rootTarget, res.propertyName);
      res.ttype = typeof o;
      if (res.ttype == "object")
        res.ttype = o.constructor.name;
    }
    return res;
  }
  static newGetProperty(rootTarget, source, propertySourceName, path, filterAllow) {
    let access = GenericProperties.computePropertyAccess(rootTarget, source, propertySourceName, path);
    if (access == null)
      return null;
    return Reflect.get(access.finalTarget, access.propertyName);
  }
  static copyProperty_SFT(rootTarget, source, propertySourceName, path, filterAllow) {
    let ttype = "";
    let stype = "";
    let TerminalSource = null;
    let p = GenericProperties.computePropertyAccess_SFT(rootTarget, source, propertySourceName, path);
    if (p.finalTarget == null)
      return;
    ttype = p.ttype;
    stype = p.stype;
    if (stype == YColor.name && ttype == YColor.name) {
      Reflect.set(p.finalTarget, p.propertyName, p.terminalSource.clone());
    } else if (stype == xAxisPosition.name && ttype == xAxisPosition.name) {
      Reflect.set(p.finalTarget, p.propertyName, p.terminalSource.clone());
    } else if (p.stype == "number" && ttype == doubleNan.name) {
      Reflect.set(p.finalTarget, p.propertyName, new doubleNan(p.terminalSource));
    } else {
      Reflect.set(p.finalTarget, p.propertyName, p.terminalSource);
    }
  }
  static copyProperty_STT(rootTarget, source, propertySourceName, path, filterAllow) {
    let p = GenericProperties.computePropertyAccess(rootTarget, source, propertySourceName, path);
    if (p == null)
      return;
    if (p.stype == doubleNan.name && p.ttype == "number") {
      let v = p.terminalSource.value;
      if (Reflect.get(p.finalTarget, p.propertyName) != v) {
        Reflect.set(p.finalTarget, p.propertyName, v);
        constants.edited = true;
      }
    } else if (p.stype != p.ttype) {
      debugger;
    } else if (p.stype == YColor.name && p.ttype == YColor.name) {
      let color = p.terminalSource;
      if (!color.equal(Reflect.get(p.finalTarget, p.propertyName))) {
        Reflect.set(p.finalTarget, p.propertyName, color.clone());
        constants.edited = true;
      }
    } else if (p.stype == doubleNan.name && p.ttype == doubleNan.name) {
      let v = p.terminalSource;
      if (Reflect.get(p.finalTarget, p.propertyName) != v) {
        Reflect.set(p.finalTarget, p.propertyName, v.clone());
        constants.edited = true;
      }
    } else if (p.stype == xAxisPosition.name && p.ttype == xAxisPosition.name) {
      let x = p.terminalSource;
      let x2 = Reflect.get(p.finalTarget, p.propertyName);
      if (x.relative != x2.relative || x.value != x2.value) {
        Reflect.set(p.finalTarget, p.propertyName, x.clone());
        constants.edited = true;
      }
    } else if (Reflect.get(p.finalTarget, p.propertyName) != p.terminalSource) {
      Reflect.set(p.finalTarget, p.propertyName, p.terminalSource);
      constants.edited = true;
    }
  }
  ApplyAllProperties(target) {
    this.ApplyAllPropertiesEx(target, GenericProperties.NoFilter, 0);
  }
  RefreshAllProperties(target) {
    this.ApplyAllPropertiesEx(target, GenericProperties.NoFilter, 1);
  }
  ApplyProperties(rootSource, rootTarget, fullpropname, sourceValue, path, direction) {
    if (sourceValue instanceof AlarmSection)
      return;
    let sourceproperties = GenericProperties.getAllProperties(this);
    if ("CopyToTarget" in sourceproperties.byName[fullpropname].Attributes) {
      if (!sourceproperties.byName[fullpropname].Attributes["CopyToTarget"]) {
        return;
      }
    }
    if (!GenericProperties.IsStructured(sourceValue)) {
      if (direction == 0) {
        GenericProperties.copyProperty_STT(rootTarget, this, fullpropname, path);
      } else {
        GenericProperties.copyProperty_SFT(rootTarget, this, fullpropname, path);
      }
    } else {
      let path2 = path.slice();
      path2.push("");
      let target = GenericProperties.getObjectFromPath(rootTarget, path2);
      Reflect.set(target, "userData", sourceValue);
      let sourceproperties2 = GenericProperties.getAllProperties(sourceValue);
      for (let subpropname in sourceproperties2.byName) {
        let shouldcopy = true;
        if ("CopyToTarget" in sourceproperties2.byName[subpropname].Attributes) {
          shouldcopy = sourceproperties2.byName[subpropname].Attributes["CopyToTarget"];
        }
        if (sourceproperties2.byName[subpropname].isWritable && shouldcopy) {
          path.push(subpropname);
          this.ApplyProperties(rootSource, rootTarget, fullpropname, Reflect.get(sourceValue, subpropname), path, direction);
          path.splice(path.length - 1, 1);
        }
      }
    }
  }
  static isProperty(proto, propName) {
    let d = Reflect.getOwnPropertyDescriptor(proto, propName);
    let list = Object.getOwnPropertyNames(d);
    for (let i = 0; i < list.length; i++) {
      if (list[i] == "set")
        return true;
      if (list[i] == "get")
        return true;
    }
    return false;
  }
  static isWritable(proto, propName) {
    let d = Reflect.getOwnPropertyDescriptor(proto, propName);
    let list = Object.getOwnPropertyNames(d);
    for (let i = 0; i < list.length; i++) {
      if (list[i] == "set") {
        if (typeof d.set !== "undefined")
          return true;
      }
    }
    return false;
  }
  static getAllProperties(o) {
    if (typeof o === "undefined")
      debugger;
    if (o.hasOwnProperty("PropertiesDescriptionCache")) {
      return o["PropertiesDescriptionCache"];
    }
    let proto = Object.getPrototypeOf(o);
    let res = new PropertiesList();
    let p = proto;
    let entries = [];
    let genealogy = [];
    while (p != null) {
      genealogy.push(p);
      p = Object.getPrototypeOf(p);
    }
    for (let j = genealogy.length - 1; j >= 0; j--) {
      let names = Object.getOwnPropertyNames(genealogy[j]);
      let index = 0;
      for (let i = 0; i < names.length; i++) {
        if (names[i] != "constructor" && !names[i].startsWith("__")) {
          entries.splice(index, 0, new PropDescription(names[i], genealogy[j]));
          index++;
          for (let k = entries.length - 1; k >= index; k--) {
            if (entries[k].name == names[i])
              entries.splice(k, 1);
          }
        }
      }
    }
    for (let i = 0; i < entries.length; i++) {
      if (!entries[i].name.startsWith("ATTR") && entries[i].name != "constructor" && !entries[i].name.startsWith("__")) {
        if (GenericProperties.isProperty(entries[i].prop, entries[i].name)) {
          let d = new PropertyDescriptor(entries[i].name);
          res.byIndex.push(d);
          res.byName[d.name] = d;
          d.isWritable = GenericProperties.isWritable(entries[i].prop, entries[i].name);
          d.isEnum = o[entries[i].name] instanceof YEnumItem;
          d.type = typeof o[entries[i].name];
          if (d.type == "object" && o[entries[i].name] != null) {
            d.type = o[entries[i].name].constructor.name;
          }
        }
      }
    }
    for (let i = 0; i < entries.length; i++) {
      if (entries[i].name.startsWith("ATTR_")) {
        let p2 = entries[i].name.indexOf("__");
        if (p2 < 5)
          debugger;
        let name = entries[i].name.substring(5, p2);
        let attr = entries[i].name.substring(p2 + 2);
        if (typeof res.byName[name] === "undefined")
          debugger;
        try {
          res.byName[name].Attributes[attr] = Reflect.get(o, entries[i].name);
        } catch (e) {
          debugger;
        }
      }
    }
    o["PropertiesDescriptionCache"] = res;
    return res;
  }
  ApplyAllPropertiesEx(target, filter, direction) {
    let properties = GenericProperties.getAllProperties(this);
    for (let fullpropname in properties.byName) {
      if (properties.byName[fullpropname].isWritable) {
        let index = fullpropname.indexOf("_");
        if (index < 0)
          throw "invalid Property name";
        let propType = fullpropname.substring(0, index);
        let propname = fullpropname.substring(index + 1);
        let path = [];
        path.push(propname);
        if (target instanceof YWidget && propType == "Form") {
          this.ApplyProperties(this, target, fullpropname, Reflect.get(this, fullpropname), path, direction);
        }
        if (target instanceof YAngularGauge && propType == "AngularGauge") {
          this.ApplyProperties(this, target, fullpropname, Reflect.get(this, fullpropname), path, direction);
        }
        if (target instanceof YDigitalDisplay && propType == "display") {
          this.ApplyProperties(this, target, fullpropname, Reflect.get(this, fullpropname), path, direction);
        }
        if (target instanceof YSolidGauge && propType == "SolidGauge") {
          this.ApplyProperties(this, target, fullpropname, Reflect.get(this, fullpropname), path, direction);
        }
        if (target instanceof YGraph && propType == "Graph") {
          this.ApplyProperties(this, target, fullpropname, Reflect.get(this, fullpropname), path, direction);
        }
      }
    }
  }
};
GenericProperties.XmlFileVersion = -1;

// obj/full/properties.js
var GenericHints = class {
};
GenericHints.DevConfAffected = " Changing this value will affect the device configuration.";
GenericHints.CheckSensor = "If the sensor you want to use is connected, but not listed or listed as OFFLINE, check USB / Network configuration in the global configuration.";
GenericHints.AnnotationGraph = "Annotation text.  Use \\n for carriage returns. Some variables are available: $DAY$ $MONTH$ $YEAR$ for date, $HOUR$ $MINUTE$ $SECOND$ for time, $AVGVALUE1$ $MINVALUE1$ $MAXVALUE1$ $NAME1$ $UNIT1$  for first series data, $AVGVALUE2$ $MINVALUE2$ $MAXVALUE2$ $NAME2$ $UNIT2$  for second series data and so on";
GenericHints.Annotation = "Annotation text.  Use \\n for carriage returns. Some variables are available: $DAY$ $MONTH$ $YEAR$ for date, $HOUR$ $MINUTE$ $SECOND$ for time, $AVGVALUE$ $MINVALUE$ $MAXVALUE$ $NAME$ $UNIT$ for sensor related data.";
var sensorFreqTypeDescription = class {
  static get AllowedValues() {
    return this._AllowedValues;
  }
};
sensorFreqTypeDescription._AllowedValues = [
  "25/s",
  "10/s",
  "5/s",
  "4/s",
  "3/s",
  "2/s",
  "1/s",
  "60/m",
  "30/m",
  "12/m",
  "6/m",
  "4/m",
  "3/m",
  "2/m",
  "1/m",
  "30/h",
  "12/h",
  "6/h",
  "4/h",
  "3/h",
  "2/h",
  "1/h"
];
var yAxisDescription = class {
  static initialize() {
    let yaxiscount = 0;
    let obj = new GraphFormProperties(null, null);
    let names = Object.getOwnPropertyNames(obj);
    names.forEach((name) => {
      if (name.startsWith("_Graph_yAxes"))
        yaxiscount++;
    });
    for (let i = 0; i < yaxiscount; i++) {
      switch (i) {
        case 0:
          this._AllowedValues.push("1rst Y axis");
          break;
        case 1:
          this._AllowedValues.push("2nd Y axis");
          break;
        case 2:
          this._AllowedValues.push("3rd Y axis");
          break;
        default:
          this._AllowedValues.push((i + 1).toString() + "th Y axis");
          break;
      }
    }
    yAxisDescription.initialized = true;
  }
  static get AllowedValues() {
    if (!yAxisDescription.initialized)
      yAxisDescription.initialize();
    return this._AllowedValues;
  }
};
yAxisDescription._AllowedValues = [];
var AlarmTestTypeDescription = class {
  static get AllowedValues() {
    return this._AllowedValues;
  }
};
AlarmTestTypeDescription._AllowedValues = ["Disabled", ">", ">=", "=", "<=", "<"];
var fontNameTypeDescription = class {
  static fontNameTypeDescription() {
  }
  static get AllowedValues() {
    return this._AllowedValues;
  }
};
fontNameTypeDescription._AllowedValues = [
  "Arial",
  "Brush Script MT",
  "Comic Sans MS",
  "Courier New",
  "Garamond",
  "Georgia",
  "Helvetica",
  "Impact",
  "Tahoma",
  "Times New Roman",
  "Trebuchet MS",
  "Verdana"
];
var sensorPrecisionTypeDescription = class {
  static get AllowedValues() {
    return this._AllowedValues;
  }
};
sensorPrecisionTypeDescription._AllowedValues = ["0", "0.1", "0.12", "0.123"];
var sensorDataTypeDescription = class {
  static get AllowedValues() {
    return this._AllowedValues;
  }
};
sensorDataTypeDescription._AllowedValues = ["Avg values", "Min values", "Max values"];
var GaugeFormProperties = class extends GenericProperties {
  constructor(initData, owner) {
    super(owner);
    this._DataSource_source = sensorsManager.getNullSensor();
    this._DataSource_precision = "0.1";
    this._DataSource_AlarmSection0 = new AlarmSection(0);
    this._DataSource_AlarmSection1 = new AlarmSection(1);
    this._SolidGauge_min = 0;
    this._SolidGauge_max = 100;
    this._SolidGauge_showMinMax = true;
    this._SolidGauge_color1 = YColor.LightGreen;
    this._SolidGauge_color2 = YColor.Red;
    this._SolidGauge_font = new FontDescription("Arial", 20, YColor.Black, false, true);
    this._SolidGauge_minMaxFont = new FontDescription("Arial", 10, YColor.Black, false, true);
    this._SolidGauge_displayMode = YSolidGauge.DisplayMode.DISPLAY90;
    this._SolidGauge_borderColor = YColor.Black;
    this._SolidGauge_borderThickness = 2;
    this._SolidGauge_backgroundColor1 = YColor.FromArgb(255, 240, 240, 240);
    this._SolidGauge_backgroundColor2 = YColor.FromArgb(255, 200, 200, 200);
    this._SolidGauge_thickness = 25;
    this._SolidGauge_maxSpeed = 1;
    this._annotationPanels0 = new AnnotationPanelDescription(GenericPanel.HorizontalAlignPos.CENTER, GenericPanel.VerticalAlignPos.BOTTOM, 0, false, "$NAME$", YColor.FromArgb(0, 127, 127, 127), YColor.FromArgb(0, 127, 127, 127), 10, YColor.FromArgb(255, 0, 0, 0));
    this._annotationPanels1 = new AnnotationPanelDescription(GenericPanel.HorizontalAlignPos.CENTER, GenericPanel.VerticalAlignPos.BOTTOM, 0, false, "$NAME$", YColor.FromArgb(0, 127, 127, 127), YColor.FromArgb(0, 127, 127, 127), 10, YColor.FromArgb(255, 0, 0, 0));
    this.initFromXmlData(initData);
    this.PropagateDataSourceChange();
  }
  PropagateDataSourceChange() {
    this.ownerForm.SourceChanged(this._DataSource_source, 0);
    let props = GenericProperties.getAllProperties(this).byName;
    let name;
    for (name in props) {
      if (name.startsWith("DataSource_AlarmSection")) {
        this[name].setDataSource(this._DataSource_source);
      }
    }
  }
  get ATTR_DataSource_source__DisplayName() {
    return "Sensor";
  }
  get ATTR_DataSource_source__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_source__ParamCategorySummaryAttribute() {
    return "sensorDescription";
  }
  get ATTR_DataSource_source__PreExpandedCategoryAttribute() {
    return true;
  }
  get ATTR_DataSource_source__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_DataSource_source__DescriptionAttribute() {
    return "Yoctopuce sensor feeding the gauge. ";
  }
  get DataSource_source() {
    return this._DataSource_source;
  }
  set DataSource_source(value) {
    let prev = this._DataSource_source;
    this._DataSource_source = value;
    this.PropagateDataSourceChange();
    if (this._DataSource_source != prev)
      constants.edited = true;
  }
  get sensorDescription() {
    return this._DataSource_source instanceof NullYSensor ? "none" : this._DataSource_source.get_friendlyName();
  }
  get isSensorReadOnly() {
    return this._DataSource_source.isReadOnly;
  }
  get ATTR_DataSource_freq__DisplayName() {
    return "Sensor freq";
  }
  get ATTR_DataSource_freq__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_freq__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_DataSource_freq__IsReadonlyCallAttribute() {
    return this.isSensorReadOnly;
  }
  get ATTR_DataSource_freq__AllowedValues() {
    return sensorFreqTypeDescription.AllowedValues;
  }
  get ATTR_DataSource_freq__DescriptionAttribute() {
    return "Sensor data acquisition frequency." + GenericHints.DevConfAffected;
  }
  get DataSource_freq() {
    return this._DataSource_source.get_frequency();
  }
  set DataSource_freq(value) {
    this._DataSource_source.set_frequency(value);
  }
  get ATTR_DataSource_precision__DisplayName() {
    return "Precision";
  }
  get ATTR_DataSource_precision__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_precision__DescriptionAttribute() {
    return "How many digits shown after the decimal point";
  }
  get ATTR_DataSource_precision__AllowedValues() {
    return sensorPrecisionTypeDescription.AllowedValues;
  }
  get DataSource_precision() {
    return this._DataSource_precision;
  }
  set DataSource_precision(value) {
    this._DataSource_precision = value;
  }
  get ATTR_DataSource_AlarmSection0__DisplayName() {
    return "Sensor value alarm 1";
  }
  get ATTR_DataSource_AlarmSection0__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection0__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection0__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_AlarmSection0__DescriptionAttribute() {
    return "Alarm 1 for this data source, expand for more.";
  }
  get DataSource_AlarmSection0() {
    return this._DataSource_AlarmSection0;
  }
  set DataSource_AlarmSection0(value) {
    this._DataSource_AlarmSection0 = value;
  }
  get ATTR_DataSource_AlarmSection1__DisplayName() {
    return "Sensor value alarm 2";
  }
  get ATTR_DataSource_AlarmSection1__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection1__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection1__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_AlarmSection1__DescriptionAttribute() {
    return "Alarm 2 for this data source, expand for more.";
  }
  get DataSource_AlarmSection1() {
    return this._DataSource_AlarmSection1;
  }
  set DataSource_AlarmSection1(value) {
    this._DataSource_AlarmSection1 = value;
  }
  get ATTR_SolidGauge_min__DisplayName() {
    return "Minimum value";
  }
  get ATTR_SolidGauge_min__CategoryAttribute() {
    return "Values range";
  }
  get ATTR_SolidGauge_min__DescriptionAttribute() {
    return "Minimum value displayable by the gauge.";
  }
  get SolidGauge_min() {
    return this._SolidGauge_min;
  }
  set SolidGauge_min(value) {
    this._SolidGauge_min = value;
  }
  get ATTR_SolidGauge_max__DisplayName() {
    return "Maximum value";
  }
  get ATTR_SolidGauge_max__CategoryAttribute() {
    return "Values range";
  }
  get ATTR_SolidGauge_max__DescriptionAttribute() {
    return "Maximum value displayable by the gauge.";
  }
  get SolidGauge_max() {
    return this._SolidGauge_max;
  }
  set SolidGauge_max(value) {
    this._SolidGauge_max = value;
  }
  get ATTR_SolidGauge_showMinMax__DisplayName() {
    return "show  min/max";
  }
  get ATTR_SolidGauge_showMinMax__CategoryAttribute() {
    return "Values range";
  }
  get ATTR_SolidGauge_showMinMax__DescriptionAttribute() {
    return "Show the min / max values.";
  }
  get SolidGauge_showMinMax() {
    return this._SolidGauge_showMinMax;
  }
  set SolidGauge_showMinMax(value) {
    this._SolidGauge_showMinMax = value;
  }
  get ATTR_SolidGauge_color1__DisplayName() {
    return "Min Color";
  }
  get ATTR_SolidGauge_color1__CategoryAttribute() {
    return "Values range";
  }
  get ATTR_SolidGauge_color1__DescriptionAttribute() {
    return "Color for minimum value.";
  }
  get SolidGauge_color1() {
    return this._SolidGauge_color1;
  }
  set SolidGauge_color1(value) {
    this._SolidGauge_color1 = value;
  }
  get ATTR_SolidGauge_color2__DisplayName() {
    return "Max Color";
  }
  get ATTR_SolidGauge_color2__CategoryAttribute() {
    return "Values range";
  }
  get ATTR_SolidGauge_color2__DescriptionAttribute() {
    return "Color for maximum value.";
  }
  get SolidGauge_color2() {
    return this._SolidGauge_color2;
  }
  set SolidGauge_color2(value) {
    this._SolidGauge_color2 = value;
  }
  get ATTR_SolidGauge_font__DisplayName() {
    return "Unit  Font";
  }
  get ATTR_SolidGauge_font__CategoryAttribute() {
    return "Fonts";
  }
  get ATTR_SolidGauge_font__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_SolidGauge_font__DescriptionAttribute() {
    return "Font for displaying the value/status indicator";
  }
  get SolidGauge_font() {
    return this._SolidGauge_font;
  }
  set SolidGauge_font(value) {
    this._SolidGauge_font = value;
  }
  get ATTR_SolidGauge_minMaxFont__DisplayName() {
    return "Min Max  Font";
  }
  get ATTR_SolidGauge_minMaxFont__CategoryAttribute() {
    return "Fonts";
  }
  get ATTR_SolidGauge_minMaxFont__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_SolidGauge_minMaxFont__DescriptionAttribute() {
    return "Font for displaying min/max values";
  }
  get SolidGauge_minMaxFont() {
    return this._SolidGauge_minMaxFont;
  }
  set SolidGauge_minMaxFont(value) {
    this._SolidGauge_minMaxFont = value;
  }
  get ATTR_SolidGauge_displayMode__DisplayName() {
    return "Display mode";
  }
  get ATTR_SolidGauge_displayMode__CategoryAttribute() {
    return "Dial";
  }
  get ATTR_SolidGauge_displayMode__DescriptionAttribute() {
    return "Dial general shape";
  }
  get SolidGauge_displayMode() {
    return this._SolidGauge_displayMode;
  }
  set SolidGauge_displayMode(value) {
    this._SolidGauge_displayMode = value;
  }
  get ATTR_SolidGauge_borderColor__DisplayName() {
    return "Border color";
  }
  get ATTR_SolidGauge_borderColor__CategoryAttribute() {
    return "Dial";
  }
  get ATTR_SolidGauge_borderColor__DescriptionAttribute() {
    return "Dial border color.";
  }
  get SolidGauge_borderColor() {
    return this._SolidGauge_borderColor;
  }
  set SolidGauge_borderColor(value) {
    this._SolidGauge_borderColor = value;
  }
  get ATTR_SolidGauge_borderThickness__DisplayName() {
    return "Border thickness ";
  }
  get ATTR_SolidGauge_borderThickness__CategoryAttribute() {
    return "Dial";
  }
  get ATTR_SolidGauge_borderThickness__DescriptionAttribute() {
    return "Thickness of the dial border";
  }
  get SolidGauge_borderThickness() {
    return this._SolidGauge_borderThickness;
  }
  set SolidGauge_borderThickness(value) {
    this._SolidGauge_borderThickness = value;
  }
  get ATTR_SolidGauge_backgroundColor1__DisplayName() {
    return "Background color 1";
  }
  get ATTR_SolidGauge_backgroundColor1__CategoryAttribute() {
    return "Dial";
  }
  get ATTR_SolidGauge_backgroundColor1__DescriptionAttribute() {
    return "Dial background gradient color 1.";
  }
  get SolidGauge_backgroundColor1() {
    return this._SolidGauge_backgroundColor1;
  }
  set SolidGauge_backgroundColor1(value) {
    this._SolidGauge_backgroundColor1 = value;
  }
  get ATTR_SolidGauge_backgroundColor2__DisplayName() {
    return "Background color 2";
  }
  get ATTR_SolidGauge_backgroundColor2__CategoryAttribute() {
    return "Dial";
  }
  get ATTR_SolidGauge_backgroundColor2__DescriptionAttribute() {
    return "Dial background gradient color 2.";
  }
  get SolidGauge_backgroundColor2() {
    return this._SolidGauge_backgroundColor2;
  }
  set SolidGauge_backgroundColor2(value) {
    this._SolidGauge_backgroundColor2 = value;
  }
  get ATTR_SolidGauge_thickness__DisplayName() {
    return "Dial thickness (%) ";
  }
  get ATTR_SolidGauge_thickness__CategoryAttribute() {
    return "Dial";
  }
  get ATTR_SolidGauge_thickness__DescriptionAttribute() {
    return "Thickness of the dial, in percentage relative to radius";
  }
  get SolidGauge_thickness() {
    return this._SolidGauge_thickness;
  }
  set SolidGauge_thickness(value) {
    this._SolidGauge_thickness = value;
  }
  get ATTR_SolidGauge_maxSpeed__DisplayName() {
    return "Max speed (%) ";
  }
  get ATTR_SolidGauge_maxSpeed__CategoryAttribute() {
    return "Dial";
  }
  get ATTR_SolidGauge_maxSpeed__DescriptionAttribute() {
    return 'Maximum speed of the dial in percentage relative to Max-Min. This is meant to limit "teleporting" effects.';
  }
  get SolidGauge_maxSpeed() {
    return this._SolidGauge_maxSpeed;
  }
  set SolidGauge_maxSpeed(value) {
    this._SolidGauge_maxSpeed = value;
  }
  IsDataSourceAssigned() {
    return !(this._DataSource_source instanceof NullYSensor);
  }
  get ATTR_SolidGauge_annotationPanels0__DisplayName() {
    return "Annotation 1";
  }
  get ATTR_SolidGauge_annotationPanels0__CategoryAttribute() {
    return "Annotations";
  }
  get ATTR_SolidGauge_annotationPanels0__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_SolidGauge_annotationPanels0__DescriptionAttribute() {
    return "Customizable text panels";
  }
  get SolidGauge_annotationPanels0() {
    return this._annotationPanels0;
  }
  set SolidGauge_annotationPanels0(value) {
    this._annotationPanels0 = value;
  }
  get ATTR_SolidGauge_annotationPanels1__DisplayName() {
    return "Annotation 2";
  }
  get ATTR_SolidGauge_annotationPanels1__CategoryAttribute() {
    return "Annotations";
  }
  get ATTR_SolidGauge_annotationPanels1__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_SolidGauge_annotationPanels1__DescriptionAttribute() {
    return "Customizable text panels";
  }
  get SolidGauge_annotationPanels1() {
    return this._annotationPanels1;
  }
  set SolidGauge_annotationPanels1(value) {
    this._annotationPanels1 = value;
  }
};
var AngularGaugeFormProperties = class extends GenericProperties {
  constructor(initData, owner) {
    super(owner);
    this._DataSource_source = sensorsManager.getNullSensor();
    this._DataSource_AlarmSection0 = new AlarmSection(0);
    this._DataSource_AlarmSection1 = new AlarmSection(1);
    this._AngularGauge_min = 0;
    this._AngularGauge_max = 100;
    this._AngularGauge_unitFactor = 1;
    this._AngularGauge_graduation = 10;
    this._AngularGauge_graduationSize = 10;
    this._AngularGauge_graduationOuterRadiusSize = 98;
    this._AngularGauge_graduationThickness = 2;
    this._AngularGauge_graduationColor = YColor.Black;
    this._AngularGauge_graduationFont = new FontDescription("Arial", 20, YColor.Black, false, true);
    this._AngularGauge_subgraduationCount = 5;
    this._AngularGauge_subgraduationSize = 5;
    this._AngularGauge_subgraduationThickness = 1;
    this._AngularGauge_subgraduationColor = YColor.Black;
    this._AngularGauge_needleColor = YColor.Red;
    this._AngularGauge_needleContourColor = YColor.DarkRed;
    this._AngularGauge_needleContourThickness = 1;
    this._AngularGauge_needleLength1 = 90;
    this._AngularGauge_needleLength2 = 15;
    this._AngularGauge_needleWidth = 5;
    this._AngularGauge_needleMaxSpeed = 0.5;
    this._AngularGauge_unitFont = new FontDescription("Arial", 24, YColor.DarkGray, false, true);
    this._AngularGauge_statusFont = new FontDescription("Arial", 24, YColor.DarkGray, false, true);
    this._AngularGauge_borderColor = YColor.Black;
    this._AngularGauge_borderThickness = 5;
    this._AngularGauge_backgroundColor1 = YColor.FromArgb(255, 240, 240, 240);
    this._AngularGauge_backgroundColor2 = YColor.FromArgb(255, 200, 200, 200);
    this._AngularGauge_zones0 = new AngularZoneDescription(0, 50, YColor.LightGreen);
    this._AngularGauge_zones1 = new AngularZoneDescription(50, 80, YColor.Yellow);
    this._AngularGauge_zones2 = new AngularZoneDescription(80, 100, YColor.Red);
    this._annotationPanels0 = new AnnotationPanelDescription(GenericPanel.HorizontalAlignPos.CENTER, GenericPanel.VerticalAlignPos.CENTER, 0, false, "$NAME$", YColor.FromArgb(0, 127, 127, 127), YColor.FromArgb(0, 127, 127, 127), 10, YColor.FromArgb(255, 0, 0, 0));
    this._annotationPanels1 = new AnnotationPanelDescription(GenericPanel.HorizontalAlignPos.CENTER, GenericPanel.VerticalAlignPos.BOTTOM, 0, false, "$NAME$", YColor.FromArgb(0, 127, 127, 127), YColor.FromArgb(0, 127, 127, 127), 10, YColor.FromArgb(255, 0, 0, 0));
    this.initFromXmlData(initData);
    this.PropagateDataSourceChange();
  }
  PropagateDataSourceChange() {
    this.ownerForm.SourceChanged(this._DataSource_source, 0);
    let props = GenericProperties.getAllProperties(this).byName;
    let name;
    for (name in props) {
      if (name.startsWith("DataSource_AlarmSection")) {
        this[name].setDataSource(this._DataSource_source);
      }
    }
  }
  IsDataSourceAssigned() {
    return !(this._DataSource_source instanceof NullYSensor);
  }
  get ATTR_DataSource_source__DisplayName() {
    return "Sensor";
  }
  get ATTR_DataSource_source__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_source__ParamCategorySummaryAttribute() {
    return "sensorDescription";
  }
  get ATTR_DataSource_source__PreExpandedCategoryAttribute() {
    return true;
  }
  get ATTR_DataSource_source__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_DataSource_source__DescriptionAttribute() {
    return "Yoctopuce sensor feeding the gauge. " + GenericHints.CheckSensor;
  }
  get DataSource_source() {
    return this._DataSource_source;
  }
  set DataSource_source(value) {
    let prev = this._DataSource_source;
    this._DataSource_source = value;
    this.PropagateDataSourceChange();
    if (this._DataSource_source != prev)
      constants.edited = true;
  }
  get sensorDescription() {
    return this._DataSource_source instanceof NullYSensor ? "none" : this._DataSource_source.get_friendlyName();
  }
  get isSensorReadOnly() {
    return this._DataSource_source.isReadOnly;
  }
  get ATTR_DataSource_freq__DisplayName() {
    return "Sensor freq";
  }
  get ATTR_DataSource_freq__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_freq__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_DataSource_freq__IsReadonlyCallAttribute() {
    return "isSensorReadOnly";
  }
  get ATTR_DataSource_freq__DescriptionAttribute() {
    return "Sensor data acquisition frequency." + GenericHints.DevConfAffected;
  }
  get ATTR_DataSource_freq__AllowedValues() {
    return sensorFreqTypeDescription.AllowedValues;
  }
  get DataSource_freq() {
    return this._DataSource_source.get_frequency();
  }
  set DataSource_freq(value) {
    this._DataSource_source.set_frequency(value);
  }
  get ATTR_DataSource_AlarmSection0__DisplayName() {
    return "Sensor value alarm 1";
  }
  get ATTR_DataSource_AlarmSection0__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection0__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection0__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_AlarmSection0__DescriptionAttribute() {
    return "Alarm 1 for this data source, expand for more.";
  }
  get DataSource_AlarmSection0() {
    return this._DataSource_AlarmSection0;
  }
  set DataSource_AlarmSection0(value) {
    this._DataSource_AlarmSection0 = value;
  }
  get ATTR_DataSource_AlarmSection1__DisplayName() {
    return "Sensor value alarm 2";
  }
  get ATTR_DataSource_AlarmSection1__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection1__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection1__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_AlarmSection1__DescriptionAttribute() {
    return "Alarm 2 for this data source, expand for more.";
  }
  get DataSource_AlarmSection1() {
    return this._DataSource_AlarmSection1;
  }
  set DataSource_AlarmSection1(value) {
    this._DataSource_AlarmSection1 = value;
  }
  get ATTR_AngularGauge_min__DisplayName() {
    return "Minimum value";
  }
  get ATTR_AngularGauge_min__CategoryAttribute() {
    return "Gauge gradations";
  }
  get ATTR_AngularGauge_min__DescriptionAttribute() {
    return "Minimum value displayable by the gauge.";
  }
  get AngularGauge_min() {
    return this._AngularGauge_min;
  }
  set AngularGauge_min(value) {
    this._AngularGauge_min = value;
  }
  get ATTR_AngularGauge_max__DisplayName() {
    return "Maximum value";
  }
  get ATTR_AngularGauge_max__CategoryAttribute() {
    return "Gauge gradations";
  }
  get ATTR_AngularGauge_max__DescriptionAttribute() {
    return "Maximum value displayable by the gauge.";
  }
  get AngularGauge_max() {
    return this._AngularGauge_max;
  }
  set AngularGauge_max(value) {
    this._AngularGauge_max = value;
  }
  get ATTR_AngularGauge_unitFactor__DisplayName() {
    return "Unit factor";
  }
  get ATTR_AngularGauge_unitFactor__CategoryAttribute() {
    return "Gauge gradations";
  }
  get ATTR_AngularGauge_unitFactor__DescriptionAttribute() {
    return "Data  will be divided by this value before being displayed, this allows simpler gradation marks.";
  }
  get AngularGauge_unitFactor() {
    return this._AngularGauge_unitFactor;
  }
  set AngularGauge_unitFactor(value) {
    this._AngularGauge_unitFactor = value;
  }
  get ATTR_AngularGauge_graduation__DisplayName() {
    return "Main gradation steps";
  }
  get ATTR_AngularGauge_graduation__CategoryAttribute() {
    return "Gauge gradations";
  }
  get ATTR_AngularGauge_graduation__DescriptionAttribute() {
    return "Difference between two consecutive main gradation marks";
  }
  get AngularGauge_graduation() {
    return this._AngularGauge_graduation;
  }
  set AngularGauge_graduation(value) {
    this._AngularGauge_graduation = value;
  }
  get ATTR_AngularGauge_graduationSize__DisplayName() {
    return "Main gradation size (%)";
  }
  get ATTR_AngularGauge_graduationSize__CategoryAttribute() {
    return "Gauge gradations";
  }
  get ATTR_AngularGauge_graduationSize__DescriptionAttribute() {
    return "Main gradation marks size in percent, relative to dial radius";
  }
  get AngularGauge_graduationSize() {
    return this._AngularGauge_graduationSize;
  }
  set AngularGauge_graduationSize(value) {
    this._AngularGauge_graduationSize = value;
  }
  get ATTR_AngularGauge_graduationOuterRadiusSize__DisplayName() {
    return "Main gradation radius (%)";
  }
  get ATTR_AngularGauge_graduationOuterRadiusSize__CategoryAttribute() {
    return "Gauge gradations";
  }
  get ATTR_AngularGauge_graduationOuterRadiusSize__DescriptionAttribute() {
    return "Main gradation marks outer radius in percent, relative to dial radius";
  }
  get AngularGauge_graduationOuterRadiusSize() {
    return this._AngularGauge_graduationOuterRadiusSize;
  }
  set AngularGauge_graduationOuterRadiusSize(value) {
    this._AngularGauge_graduationOuterRadiusSize = value;
  }
  get ATTR_AngularGauge_graduationThickness__DisplayName() {
    return "Main gradation thickness";
  }
  get ATTR_AngularGauge_graduationThickness__CategoryAttribute() {
    return "Gauge gradations";
  }
  get ATTR_AngularGauge_graduationThickness__DescriptionAttribute() {
    return "Main gradation marks thickness";
  }
  get AngularGauge_graduationThickness() {
    return this._AngularGauge_graduationThickness;
  }
  set AngularGauge_graduationThickness(value) {
    this._AngularGauge_graduationThickness = value;
  }
  get ATTR_AngularGauge_graduationColor__DisplayName() {
    return "Main gradation color";
  }
  get ATTR_AngularGauge_graduationColor__CategoryAttribute() {
    return "Gauge gradations";
  }
  get ATTR_AngularGauge_graduationColor__DescriptionAttribute() {
    return "Main gradation marks color.";
  }
  get AngularGauge_graduationColor() {
    return this._AngularGauge_graduationColor;
  }
  set AngularGauge_graduationColor(value) {
    this._AngularGauge_graduationColor = value;
  }
  get ATTR_AngularGauge_graduationFont__DisplayName() {
    return "Main gradation font";
  }
  get ATTR_AngularGauge_graduationFont__CategoryAttribute() {
    return "Gauge gradations";
  }
  get ATTR_AngularGauge_graduationFont__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_AngularGauge_graduationFont__DescriptionAttribute() {
    return "Font used for gradation labels";
  }
  get AngularGauge_graduationFont() {
    return this._AngularGauge_graduationFont;
  }
  set AngularGauge_graduationFont(value) {
    this._AngularGauge_graduationFont = value;
  }
  get ATTR_AngularGauge_subgraduationCount__DisplayName() {
    return "Sub-gradation count";
  }
  get ATTR_AngularGauge_subgraduationCount__CategoryAttribute() {
    return "Gauge gradations";
  }
  get ATTR_AngularGauge_subgraduationCount__DescriptionAttribute() {
    return "How many sub-gradation (+1) marks between two consecutive main graduation marks";
  }
  get AngularGauge_subgraduationCount() {
    return this._AngularGauge_subgraduationCount;
  }
  set AngularGauge_subgraduationCount(value) {
    this._AngularGauge_subgraduationCount = value;
  }
  get ATTR_AngularGauge_subgraduationSize__DisplayName() {
    return "Sub-gradation size (%)";
  }
  get ATTR_AngularGauge_subgraduationSize__CategoryAttribute() {
    return "Gauge gradations";
  }
  get ATTR_AngularGauge_subgraduationSize__DescriptionAttribute() {
    return "Sub-gradation marks size in percent, relative to dial radius";
  }
  get AngularGauge_subgraduationSize() {
    return this._AngularGauge_subgraduationSize;
  }
  set AngularGauge_subgraduationSize(value) {
    this._AngularGauge_subgraduationSize = value;
  }
  get ATTR_AngularGauge_subgraduationThickness__DisplayName() {
    return "Sub-gradation thickness";
  }
  get ATTR_AngularGauge_subgraduationThickness__CategoryAttribute() {
    return "Gauge gradations";
  }
  get ATTR_AngularGauge_subgraduationThickness__DescriptionAttribute() {
    return "Sub-gradation marks thickness";
  }
  get AngularGauge_subgraduationThickness() {
    return this._AngularGauge_subgraduationThickness;
  }
  set AngularGauge_subgraduationThickness(value) {
    this._AngularGauge_subgraduationThickness = value;
  }
  get ATTR_AngularGauge_subgraduationColor__DisplayName() {
    return "Sub-gradation color";
  }
  get ATTR_AngularGauge_subgraduationColor__CategoryAttribute() {
    return "Gauge gradations";
  }
  get ATTR_AngularGauge_subgraduationColor__DescriptionAttribute() {
    return "Sub-gradation marks color.";
  }
  get AngularGauge_subgraduationColor() {
    return this._AngularGauge_subgraduationColor;
  }
  set AngularGauge_subgraduationColor(value) {
    this._AngularGauge_subgraduationColor = value;
  }
  get ATTR_AngularGauge_needleColor__DisplayName() {
    return "Needle color";
  }
  get ATTR_AngularGauge_needleColor__CategoryAttribute() {
    return "Needle";
  }
  get ATTR_AngularGauge_needleColor__DescriptionAttribute() {
    return "Needle filling color.";
  }
  get AngularGauge_needleColor() {
    return this._AngularGauge_needleColor;
  }
  set AngularGauge_needleColor(value) {
    this._AngularGauge_needleColor = value;
  }
  get ATTR_AngularGauge_needleContourColor__DisplayName() {
    return "Needle contour color";
  }
  get ATTR_AngularGauge_needleContourColor__CategoryAttribute() {
    return "Needle";
  }
  get ATTR_AngularGauge_needleContourColor__DescriptionAttribute() {
    return "Needle contour color.";
  }
  get AngularGauge_needleContourColor() {
    return this._AngularGauge_needleContourColor;
  }
  set AngularGauge_needleContourColor(value) {
    this._AngularGauge_needleContourColor = value;
  }
  get ATTR_AngularGauge_needleContourThickness__DisplayName() {
    return "Needle contour thickness";
  }
  get ATTR_AngularGauge_needleContourThickness__CategoryAttribute() {
    return "Needle";
  }
  get ATTR_AngularGauge_needleContourThickness__DescriptionAttribute() {
    return "Thickness of the needle contour";
  }
  get AngularGauge_needleContourThickness() {
    return this._AngularGauge_needleContourThickness;
  }
  set AngularGauge_needleContourThickness(value) {
    this._AngularGauge_needleContourThickness = value;
  }
  get ATTR_AngularGauge_needleLength1__DisplayName() {
    return "Needle main size (%)";
  }
  get ATTR_AngularGauge_needleLength1__CategoryAttribute() {
    return "Needle";
  }
  get ATTR_AngularGauge_needleLength1__DescriptionAttribute() {
    return "Length of the needle part pointing to gradations, in % relative to radius";
  }
  get AngularGauge_needleLength1() {
    return this._AngularGauge_needleLength1;
  }
  set AngularGauge_needleLength1(value) {
    this._AngularGauge_needleLength1 = value;
  }
  get ATTR_AngularGauge_needleLength2__DisplayName() {
    return "Needle foot size (%)";
  }
  get ATTR_AngularGauge_needleLength2__CategoryAttribute() {
    return "Needle";
  }
  get ATTR_AngularGauge_needleLength2__DescriptionAttribute() {
    return "Length of the needle part not pointing to gradations, in % relative to radius";
  }
  get AngularGauge_needleLength2() {
    return this._AngularGauge_needleLength2;
  }
  set AngularGauge_needleLength2(value) {
    this._AngularGauge_needleLength2 = value;
  }
  get ATTR_AngularGauge_needleWidth__DisplayName() {
    return "Needle width (%)";
  }
  get ATTR_AngularGauge_needleWidth__CategoryAttribute() {
    return "Needle";
  }
  get ATTR_AngularGauge_needleWidth__DescriptionAttribute() {
    return "Width of the needle, in % relative to radius";
  }
  get AngularGauge_needleWidth() {
    return this._AngularGauge_needleWidth;
  }
  set AngularGauge_needleWidth(value) {
    this._AngularGauge_needleWidth = value;
  }
  get ATTR_AngularGauge_needleMaxSpeed__DisplayName() {
    return "Needle max speed (%)";
  }
  get ATTR_AngularGauge_needleMaxSpeed__CategoryAttribute() {
    return "Needle";
  }
  get ATTR_AngularGauge_needleMaxSpeed__DescriptionAttribute() {
    return 'Needle Maximum speed, in % relative to (max-min). This is meant to limit "teleporting" effects.';
  }
  get AngularGauge_needleMaxSpeed() {
    return this._AngularGauge_needleMaxSpeed;
  }
  set AngularGauge_needleMaxSpeed(value) {
    this._AngularGauge_needleMaxSpeed = value;
  }
  get ATTR_AngularGauge_unitFont__DisplayName() {
    return "Unit Line Font";
  }
  get ATTR_AngularGauge_unitFont__CategoryAttribute() {
    return "Text lines";
  }
  get ATTR_AngularGauge_unitFont__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_AngularGauge_unitFont__DescriptionAttribute() {
    return "Font used in the text line describing unit";
  }
  get AngularGauge_unitFont() {
    return this._AngularGauge_unitFont;
  }
  set AngularGauge_unitFont(value) {
    this._AngularGauge_unitFont = value;
  }
  get ATTR_AngularGauge_statusFont__DisplayName() {
    return "Status Line Font";
  }
  get ATTR_AngularGauge_statusFont__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_AngularGauge_statusFont__CategoryAttribute() {
    return "Text lines";
  }
  get ATTR_AngularGauge_statusFont__DescriptionAttribute() {
    return "Font used in the text line gauge status";
  }
  get AngularGauge_statusFont() {
    return this._AngularGauge_statusFont;
  }
  set AngularGauge_statusFont(value) {
    this._AngularGauge_statusFont = value;
  }
  get ATTR_AngularGauge_borderColor__DisplayName() {
    return "Border color";
  }
  get ATTR_AngularGauge_borderColor__CategoryAttribute() {
    return "Dial";
  }
  get ATTR_AngularGauge_borderColor__DescriptionAttribute() {
    return "Dial border color.";
  }
  get AngularGauge_borderColor() {
    return this._AngularGauge_borderColor;
  }
  set AngularGauge_borderColor(value) {
    this._AngularGauge_borderColor = value;
  }
  get ATTR_AngularGauge_borderThickness__DisplayName() {
    return "Border thickness ";
  }
  get ATTR_AngularGauge_borderThickness__CategoryAttribute() {
    return "Dial";
  }
  get ATTR_AngularGauge_borderThickness__DescriptionAttribute() {
    return "Thickness of the dial border";
  }
  get AngularGauge_borderThickness() {
    return this._AngularGauge_borderThickness;
  }
  set AngularGauge_borderThickness(value) {
    this._AngularGauge_borderThickness = value;
  }
  get ATTR_AngularGauge_backgroundColor1__DisplayName() {
    return "Background color 1";
  }
  get ATTR_AngularGauge_backgroundColor1__CategoryAttribute() {
    return "Dial";
  }
  get ATTR_AngularGauge_backgroundColor1__DescriptionAttribute() {
    return "Dial background gradient color 1.";
  }
  get AngularGauge_backgroundColor1() {
    return this._AngularGauge_backgroundColor1;
  }
  set AngularGauge_backgroundColor1(value) {
    this._AngularGauge_backgroundColor1 = value;
  }
  get ATTR_AngularGauge_backgroundColor2__DisplayName() {
    return "Background color 2";
  }
  get ATTR_AngularGauge_backgroundColor2__CategoryAttribute() {
    return "Dial";
  }
  get ATTR_AngularGauge_backgroundColor2__DescriptionAttribute() {
    return "Dial background gradient color 2.";
  }
  get AngularGauge_backgroundColor2() {
    return this._AngularGauge_backgroundColor2;
  }
  set AngularGauge_backgroundColor2(value) {
    this._AngularGauge_backgroundColor2 = value;
  }
  get ATTR_AngularGauge_zones0__DisplayName() {
    return "Zone 1";
  }
  get ATTR_AngularGauge_zones0__CategoryAttribute() {
    return "Zones";
  }
  get ATTR_AngularGauge_zones0__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_AngularGauge_zones0__DescriptionAttribute() {
    return "Zone 1 parameters";
  }
  get AngularGauge_zones0() {
    return this._AngularGauge_zones0;
  }
  set AngularGauge_zones0(value) {
    this._AngularGauge_zones0 = value;
  }
  get ATTR_AngularGauge_zones1__DisplayName() {
    return "Zone 2";
  }
  get ATTR_AngularGauge_zones1__CategoryAttribute() {
    return "Zones";
  }
  get ATTR_AngularGauge_zones1__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_AngularGauge_zones1__DescriptionAttribute() {
    return "Zone 2 parameters";
  }
  get AngularGauge_zones1() {
    return this._AngularGauge_zones1;
  }
  set AngularGauge_zones1(value) {
    this._AngularGauge_zones1 = value;
  }
  get ATTR_AngularGauge_zones2__DisplayName() {
    return "Zone 2";
  }
  get ATTR_AngularGauge_zones2__CategoryAttribute() {
    return "Zones";
  }
  get ATTR_AngularGauge_zones2__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_AngularGauge_zones2__DescriptionAttribute() {
    return "Zone 2 parameters";
  }
  get AngularGauge_zones2() {
    return this._AngularGauge_zones2;
  }
  set AngularGauge_zones2(value) {
    this._AngularGauge_zones2 = value;
  }
  get ATTR_AngularGauge_annotationPanels0__DisplayName() {
    return "Annotation 1";
  }
  get ATTR_AngularGauge_annotationPanels0__CategoryAttribute() {
    return "Annotations";
  }
  get ATTR_AngularGauge_annotationPanels0__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_AngularGauge_annotationPanels0__DescriptionAttribute() {
    return "Customizable text panels";
  }
  get AngularGauge_annotationPanels0() {
    return this._annotationPanels0;
  }
  set AngularGauge_annotationPanels0(value) {
    this._annotationPanels0 = value;
  }
  get ATTR_AngularGauge_annotationPanels1__DisplayName() {
    return "Annotation 2";
  }
  get ATTR_AngularGauge_annotationPanels1__CategoryAttribute() {
    return "Annotations";
  }
  get ATTR_AngularGauge_annotationPanels1__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_AngularGauge_annotationPanels1__DescriptionAttribute() {
    return "Customizable text panels";
  }
  get AngularGauge_annotationPanels1() {
    return this._annotationPanels1;
  }
  set AngularGauge_annotationPanels1(value) {
    this._annotationPanels1 = value;
  }
};
var ZoneDescription = class {
  constructor(min, max, color) {
    this._visible = false;
    this._min = min;
    this._max = max;
    this._color = color;
  }
  get summary() {
    return this._visible ? this._min.toString() + ".." + this._max.toString() : "Disabled";
  }
  get ATTR_visible__DisplayName() {
    return "Visible";
  }
  get ATTR_visible__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_visible__DescriptionAttribute() {
    return "Zone visibility.";
  }
  get visible() {
    return this._visible;
  }
  set visible(value) {
    this._visible = value;
  }
  get ATTR_min__DisplayName() {
    return "Minimum value";
  }
  get ATTR_min__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_min__DescriptionAttribute() {
    return "Zone minimum value";
  }
  get min() {
    return this._min;
  }
  set min(value) {
    this._min = value;
  }
  get ATTR_max__DisplayName() {
    return "Maximum value";
  }
  get ATTR_max__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_max__DescriptionAttribute() {
    return "Zone maximum value";
  }
  get max() {
    return this._max;
  }
  set max(value) {
    this._max = value;
  }
  get ATTR_color__DisplayName() {
    return "Color";
  }
  get ATTR_color__DescriptionAttribute() {
    return "Zone color";
  }
  get color() {
    return this._color;
  }
  set color(value) {
    this._color = value;
  }
};
var AngularZoneDescription = class {
  constructor(min, max, color) {
    this._width = 5;
    this._outerRadius = 98;
    this._visible = false;
    this._min = min;
    this._max = max;
    this._color = color;
  }
  get summary() {
    return this._visible ? this._min.toString() + ".." + this._max.toString() : "Disabled";
  }
  get ATTR_visible__DisplayName() {
    return "Visible";
  }
  get ATTR_visible__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_visible__DescriptionAttribute() {
    return "Zone visibility.";
  }
  get visible() {
    return this._visible;
  }
  set visible(value) {
    this._visible = value;
  }
  get ATTR_min__DisplayName() {
    return "Minimum value";
  }
  get ATTR_min__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_min__DescriptionAttribute() {
    return "Zone minimum value";
  }
  get min() {
    return this._min;
  }
  set min(value) {
    this._min = value;
  }
  get ATTR_max__DisplayName() {
    return "Maximum value";
  }
  get ATTR_max__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_max__DescriptionAttribute() {
    return "Zone maximum value";
  }
  get max() {
    return this._max;
  }
  set max(value) {
    this._max = value;
  }
  get ATTR_color__DisplayName() {
    return "Color";
  }
  get ATTR_color__DescriptionAttribute() {
    return "Zone color";
  }
  get color() {
    return this._color;
  }
  set color(value) {
    this._color = value;
  }
  get ATTR_outerRadius__DisplayName() {
    return "Outer radius (%)";
  }
  get ATTR_outerRadius__DescriptionAttribute() {
    return "Zone outer radius, in percentage relative to dial radius ";
  }
  get outerRadius() {
    return this._outerRadius;
  }
  set outerRadius(value) {
    this._outerRadius = value;
  }
  get ATTR_width__DisplayName() {
    return "Width (%)";
  }
  get ATTR_width__DescriptionAttribute() {
    return "Zone  width, in percentage relative to dial radius ";
  }
  get width() {
    return this._width;
  }
  set width(value) {
    this._width = value;
  }
};
var FontDescription = class {
  constructor(name, size, color, italic, bold) {
    this._name = name;
    this._size = size;
    this._color = color;
    this._italic = italic;
    this._bold = bold;
  }
  ToString() {
    return this._name + " " + this._size.toString();
  }
  get summary() {
    return this._name + " " + this._size.toString();
  }
  get ATTR_name__DisplayName() {
    return "Font name";
  }
  get ATTR_name__AllowedValues() {
    return fontNameTypeDescription.AllowedValues;
  }
  get ATTR_name__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_name__DescriptionAttribute() {
    return "Name of the font";
  }
  get name() {
    return this._name;
  }
  set name(value) {
    this._name = value;
  }
  get ATTR_size__DisplayName() {
    return "Font size";
  }
  get ATTR_size__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_size__DescriptionAttribute() {
    return "Size of the font";
  }
  get size() {
    return this._size;
  }
  set size(value) {
    this._size = Math.round(100 * value) / 100;
  }
  get ATTR_color__DisplayName() {
    return "Font color";
  }
  get ATTR_color__DescriptionAttribute() {
    return "Color of the font.";
  }
  get color() {
    return this._color;
  }
  set color(value) {
    this._color = value;
  }
  get ATTR_italic__DisplayName() {
    return "Italic";
  }
  get ATTR_italic__DescriptionAttribute() {
    return "Is the font style italic?.";
  }
  get italic() {
    return this._italic;
  }
  set italic(value) {
    this._italic = value;
  }
  get ATTR_bold__DisplayName() {
    return "Bold";
  }
  get ATTR_bold__DescriptionAttribute() {
    return "Is the font style bold?.";
  }
  get bold() {
    return this._bold;
  }
  set bold(value) {
    this._bold = value;
  }
};
var digitalDisplayFormProperties = class extends GenericProperties {
  constructor(initData, owner) {
    super(owner);
    this._DataSource_source = sensorsManager.getNullSensor();
    this._DataSource_precision = "0.1";
    this._DataSource_AlarmSection0 = new AlarmSection(0);
    this._DataSource_AlarmSection1 = new AlarmSection(1);
    this._font = new FontDescription("Arial", 48, YColor.LightGreen, false, true);
    this._display_backgroundColor1 = YColor.Black;
    this._display_backgroundColor2 = YColor.Black;
    this._hrzAlignment = YDigitalDisplay.HrzAlignment.RIGHT;
    this._hrzAlignmentOfset = 5;
    this._outOfRangeMin = new doubleNan(Number.NaN);
    this._outOfRangeMax = new doubleNan(Number.NaN);
    this._outOfRangeColor = YColor.Red;
    this._annotationPanels0 = new AnnotationPanelDescription(GenericPanel.HorizontalAlignPos.CENTER, GenericPanel.VerticalAlignPos.CENTER, 0, false, "$NAME$", YColor.FromArgb(0, 127, 127, 127), YColor.FromArgb(0, 127, 127, 127), 10, YColor.FromArgb(255, 0, 0, 0));
    this._annotationPanels1 = new AnnotationPanelDescription(GenericPanel.HorizontalAlignPos.CENTER, GenericPanel.VerticalAlignPos.BOTTOM, 0, false, "$NAME$", YColor.FromArgb(0, 127, 127, 127), YColor.FromArgb(0, 127, 127, 127), 10, YColor.FromArgb(255, 0, 0, 0));
    this.initFromXmlData(initData);
    this.PropagateDataSourceChange();
  }
  PropagateDataSourceChange() {
    this.ownerForm.SourceChanged(this._DataSource_source, 0);
    let props = GenericProperties.getAllProperties(this).byName;
    let name;
    for (name in props) {
      if (name.startsWith("DataSource_AlarmSection")) {
        this[name].setDataSource(this._DataSource_source);
      }
    }
  }
  IsDataSourceAssigned() {
    return !(this._DataSource_source instanceof NullYSensor);
  }
  get ATTR_DataSource_source__DisplayName() {
    return "Sensor";
  }
  get ATTR_DataSource_source__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_source__ParamCategorySummaryAttribute() {
    return "sensorDescription";
  }
  get ATTR_DataSource_source__PreExpandedCategoryAttribute() {
    return true;
  }
  get ATTR_DataSource_source__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_DataSource_source__DescriptionAttribute() {
    return "Yoctopuce sensor feeding the display. " + GenericHints.CheckSensor;
  }
  get DataSource_source() {
    return this._DataSource_source;
  }
  set DataSource_source(value) {
    let prev = this._DataSource_source;
    this._DataSource_source = value;
    this.PropagateDataSourceChange();
    if (this._DataSource_source != prev)
      constants.edited = true;
  }
  get isSensorReadOnly() {
    return this._DataSource_source.isReadOnly;
  }
  get sensorDescription() {
    return this._DataSource_source instanceof NullYSensor ? "none" : this._DataSource_source.get_friendlyName();
  }
  get ATTR_DataSource_freq__DisplayName() {
    return "Sensor freq";
  }
  get ATTR_DataSource_freq__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_freq__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_DataSource_freq__IsReadonlyCallAttribute() {
    return "isSensorReadOnly";
  }
  get ATTR_DataSource_freq__DescriptionAttribute() {
    return "Sensor data acquisition frequency." + GenericHints.DevConfAffected;
  }
  get ATTR_DataSource_freq__AllowedValues() {
    return sensorFreqTypeDescription.AllowedValues;
  }
  get DataSource_freq() {
    return this._DataSource_source.get_frequency();
  }
  set DataSource_freq(value) {
    this._DataSource_source.set_frequency(value);
  }
  get ATTR_DataSource_precision__DisplayName() {
    return "Precision";
  }
  get ATTR_DataSource_precision__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_precision__DescriptionAttribute() {
    return "How many digits shown after the decimal point.";
  }
  get ATTR_DataSource_precision__AllowedValues() {
    return sensorPrecisionTypeDescription.AllowedValues;
  }
  get DataSource_precision() {
    return this._DataSource_precision;
  }
  set DataSource_precision(value) {
    this._DataSource_precision = value;
  }
  get ATTR_DataSource_AlarmSection0__DisplayName() {
    return "Sensor value alarm 1";
  }
  get ATTR_DataSource_AlarmSection0__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection0__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection0__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_AlarmSection0__DescriptionAttribute() {
    return "Alarm 1 for this data source, expand for more.";
  }
  get DataSource_AlarmSection0() {
    return this._DataSource_AlarmSection0;
  }
  set DataSource_AlarmSection0(value) {
    this._DataSource_AlarmSection0 = value;
  }
  get ATTR_DataSource_AlarmSection1__DisplayName() {
    return "Sensor value alarm 2";
  }
  get ATTR_DataSource_AlarmSection1__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection1__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection1__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_AlarmSection1__DescriptionAttribute() {
    return "Alarm 2 for this data source, expand for more.";
  }
  get DataSource_AlarmSection1() {
    return this._DataSource_AlarmSection1;
  }
  set DataSource_AlarmSection1(value) {
    this._DataSource_AlarmSection1 = value;
  }
  get ATTR_display_font__DisplayName() {
    return "Font";
  }
  get ATTR_display_font__CategoryAttribute() {
    return "Display";
  }
  get ATTR_display_font__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_display_font__DescriptionAttribute() {
    return "Display font";
  }
  get display_font() {
    return this._font;
  }
  set display_font(value) {
    this._font = value;
  }
  get ATTR_display_backgroundColor1__DisplayName() {
    return "Background color 1";
  }
  get ATTR_display_backgroundColor1__CategoryAttribute() {
    return "Display";
  }
  get ATTR_display_backgroundColor1__DescriptionAttribute() {
    return "Display background gradient color 1.";
  }
  get display_backgroundColor1() {
    return this._display_backgroundColor1;
  }
  set display_backgroundColor1(value) {
    this._display_backgroundColor1 = value;
  }
  get ATTR_display_backgroundColor2__DisplayName() {
    return "Background color 2";
  }
  get ATTR_display_backgroundColor2__CategoryAttribute() {
    return "Display";
  }
  get ATTR_display_backgroundColor2__DescriptionAttribute() {
    return "Display background gradient color 2.";
  }
  get display_backgroundColor2() {
    return this._display_backgroundColor2;
  }
  set display_backgroundColor2(value) {
    this._display_backgroundColor2 = value;
  }
  get ATTR_display_hrzAlignment__DisplayName() {
    return "Hrz alignment method";
  }
  get ATTR_display_hrzAlignment__CategoryAttribute() {
    return "Display";
  }
  get ATTR_display_hrzAlignment__DescriptionAttribute() {
    return "Horizontal alignment method";
  }
  get display_hrzAlignment() {
    return this._hrzAlignment;
  }
  set display_hrzAlignment(value) {
    this._hrzAlignment = value;
  }
  get ATTR_display_hrzAlignmentOfset__DisplayName() {
    return "Hrz alignment offset";
  }
  get ATTR_display_hrzAlignmentOfset__CategoryAttribute() {
    return "Display";
  }
  get ATTR_display_hrzAlignmentOfset__DescriptionAttribute() {
    return "Horizontal alignment offset in percentage. No effect when chosen horizontal alignment is CENTER";
  }
  get display_hrzAlignmentOfset() {
    return this._hrzAlignmentOfset;
  }
  set display_hrzAlignmentOfset(value) {
    this._hrzAlignmentOfset = value;
  }
  get ATTR_display_outOfRangeMin__DisplayName() {
    return "Minimum value";
  }
  get ATTR_display_outOfRangeMin__CategoryAttribute() {
    return "Range Control";
  }
  get ATTR_display_outOfRangeMin__DescriptionAttribute() {
    return `Regular range minimum value. if value goes  outside regular  range, color will turn to "Out of range Color".Leave blank if you don't want to define such a range. `;
  }
  get display_outOfRangeMin() {
    return this._outOfRangeMin;
  }
  set display_outOfRangeMin(value) {
    this._outOfRangeMin = value;
  }
  get ATTR_display_outOfRangeMax__DisplayName() {
    return "Maximum value";
  }
  get ATTR_display_outOfRangeMax__CategoryAttribute() {
    return "Range Control";
  }
  get ATTR_display_outOfRangeMax__DescriptionAttribute() {
    return `Regular range minimum value. if value goes  outside regular  range, color will turn to "Out of range Color".Leave blank if you don't want to define such a range. `;
  }
  get display_outOfRangeMax() {
    return this._outOfRangeMax;
  }
  set display_outOfRangeMax(value) {
    this._outOfRangeMax = value;
  }
  get ATTR_display_outOfRangeColor__DisplayName() {
    return "Out of range Color";
  }
  get ATTR_display_outOfRangeColor__CategoryAttribute() {
    return "Range Control";
  }
  get ATTR_display_outOfRangeColor__DescriptionAttribute() {
    return "Digits color when value is out of range.";
  }
  get display_outOfRangeColor() {
    return this._outOfRangeColor;
  }
  set display_outOfRangeColor(value) {
    this._outOfRangeColor = value;
  }
  get ATTR_display_annotationPanels0__DisplayName() {
    return "Annotation 1";
  }
  get ATTR_display_annotationPanels0__CategoryAttribute() {
    return "Annotations";
  }
  get ATTR_display_annotationPanels0__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_display_annotationPanels0__DescriptionAttribute() {
    return "Customizable text panels";
  }
  get display_annotationPanels0() {
    return this._annotationPanels0;
  }
  set display_annotationPanels0(value) {
    this._annotationPanels0 = value;
  }
  get ATTR_display_annotationPanels1__DisplayName() {
    return "Annotation 2";
  }
  get ATTR_display_annotationPanels1__CategoryAttribute() {
    return "Annotations";
  }
  get ATTR_display_annotationPanels1__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_display_annotationPanels1__DescriptionAttribute() {
    return "Customizable text panels";
  }
  get display_annotationPanels1() {
    return this._annotationPanels1;
  }
  set display_annotationPanels1(value) {
    this._annotationPanels1 = value;
  }
};
var AlarmSection = class {
  get summary() {
    let c = this._sensor.getAlarmCondition(this._index);
    if (c == 0)
      return "Disabled";
    return "Enabled";
  }
  constructor(index) {
    this._sensor = sensorsManager.getNullSensor();
    this._index = 0;
    this._index = index;
  }
  get ATTR_source__DisplayName() {
    return "Data source type";
  }
  get ATTR_source__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_source__AllowedValues() {
    return sensorDataTypeDescription.AllowedValues;
  }
  get ATTR_source__DescriptionAttribute() {
    return "Alarm sensor data source (Average, minimum or maximum value during last interval)";
  }
  get source() {
    return this._sensor.getAlarmSource(this._index);
  }
  set source(value) {
    this._sensor.setAlarmSource(this._index, value);
  }
  get ATTR_condition__DisplayName() {
    return "Test Condition";
  }
  get ATTR_condition__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_condition__AllowedValues() {
    return AlarmTestTypeDescription.AllowedValues;
  }
  get ATTR_condition__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_condition__DescriptionAttribute() {
    return "Alarm trigger condition";
  }
  get condition() {
    return this._sensor.getAlarmCondition(this._index);
  }
  set condition(value) {
    this._sensor.setAlarmCondition(this._index, value);
  }
  setDataSource(sensor) {
    this._sensor = sensor;
  }
  get ATTR_value__DisplayName() {
    return "Test Value";
  }
  get ATTR_value__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_value__DescriptionAttribute() {
    return "Value for the Alarm trigger";
  }
  get value() {
    return this._sensor.getAlarmValue(this._index);
  }
  set value(value) {
    this._sensor.setAlarmValue(this._index, value);
  }
  get ATTR_commandLine__DisplayName() {
    return "Trigger action";
  }
  get ATTR_commandLine__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_commandLine__DescriptionAttribute() {
    return "Javascript snippet executed in your browser each time the alarm is triggered, you can use the following variables: $SENSORVALUE$, $UNIT$, $HWDID$, $NAME$, $CONDITION$, $TRIGGER$, $DATATYPE$, $NOW$. Example : <tt>alarm('Warning $NAME$ = $SENSORVALUE$!');</tt>. You can check logs to find out if your alarm code works.";
  }
  get commandLine() {
    return this._sensor.getAlarmCommandline(this._index);
  }
  set commandLine(value) {
    this._sensor.setAlarmCommandline(this._index, value);
  }
  get ATTR_delay__DisplayName() {
    return "Trigger delay";
  }
  get ATTR_delay__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_delay__DescriptionAttribute() {
    return "Minimum delay, in seconds, between two alarms. Think carefully and make sure you won't create alarm storms.";
  }
  get delay() {
    return this._sensor.getAlarmDelay(this._index);
  }
  set delay(value) {
    this._sensor.setAlarmDelay(this._index, value);
  }
};
var ChartSerie = class {
  constructor(defaultColor) {
    this.ownerForm = null;
    this.index = -1;
    this.dataloggerAlreadyLoaded = false;
    this._DataSource_source = sensorsManager.getNullSensor();
    this._DataType = 0;
    this._thickness = 2;
    this._legend = "";
    this._color = YColor.Red;
    this._yAxisIndex = 0;
    this._DataSource_AlarmSection0 = new AlarmSection(0);
    this._DataSource_AlarmSection1 = new AlarmSection(1);
    this._color = defaultColor;
  }
  get summary() {
    return this._DataSource_source instanceof NullYSensor ? "none" : this._DataSource_source.get_friendlyName() + (this._DataSource_source.isOnline() ? "" : " - OFFLINE");
  }
  Init(owner, serieIndex) {
    this.ownerForm = owner;
    this.index = serieIndex;
    this.PropagateDataSourceChange(this._DataSource_source);
  }
  PropagateDataSourceChange(value) {
    this.ownerForm.SourceChanged(this._DataSource_source, this.index);
    let props = GenericProperties.getAllProperties(this).byName;
    let name;
    for (name in props) {
      if (name.startsWith("DataSource_AlarmSection")) {
        this[name].setDataSource(this._DataSource_source);
      }
    }
  }
  get ATTR_DataSource_source__DisplayName() {
    return "Sensor";
  }
  get ATTR_DataSource_source__CopyToTarget() {
    return false;
  }
  get ATTR_DataSource_source__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_DataSource_source__DescriptionAttribute() {
    return "Yoctopuce sensor feeding the graph. " + GenericHints.CheckSensor;
  }
  get DataSource_source() {
    return this._DataSource_source;
  }
  set DataSource_source(value) {
    let prev = this._DataSource_source;
    this._DataSource_source = value;
    if (this._DataSource_source != prev)
      constants.edited = true;
    if (this.ownerForm != null)
      this.PropagateDataSourceChange(this._DataSource_source);
  }
  get isSensorReadOnly() {
    return this._DataSource_source.isReadOnly;
  }
  get ATTR_DataSource_freq__DisplayName() {
    return "Sensor frequency";
  }
  get ATTR_DataSource_freq__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_DataSource_freq__CopyToTarget() {
    return false;
  }
  get ATTR_DataSource_freq__IsReadonlyCallAttribute() {
    return "isSensorReadOnly";
  }
  get ATTR_DataSource_freq__DescriptionAttribute() {
    return "Sensor data acquisition frequency." + GenericHints.DevConfAffected;
  }
  get ATTR_DataSource_freq__AllowedValues() {
    return sensorFreqTypeDescription.AllowedValues;
  }
  get DataSource_freq() {
    return this._DataSource_source.get_frequency();
  }
  set DataSource_freq(value) {
    this._DataSource_source.set_frequency(value);
  }
  get ATTR_DataSource_datatype__DisplayName() {
    return "Sensor data";
  }
  get ATTR_DataSource_datatype__AllowedValues() {
    return sensorDataTypeDescription.AllowedValues;
  }
  get ATTR_DataSource_datatype__CopyToTarget() {
    return false;
  }
  get ATTR_DataSource_datatype__DescriptionAttribute() {
    return "Which data for sensor are displayed on the graph. Min and Max are available only for frequencies <1Hz";
  }
  get DataSource_datatype() {
    return this._DataType;
  }
  set DataSource_datatype(value) {
    this._DataType = value;
    if (this.ownerForm != null) {
      this.ownerForm.SourceChanged(this._DataSource_source, this.index);
    }
  }
  get ATTR_DataSource_recording__DisplayName() {
    return "Sensor recording";
  }
  get ATTR_DataSource_recording__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_DataSource_recording__IsReadonlyCallAttribute() {
    return "isSensorReadOnly";
  }
  get ATTR_DataSource_recording__CopyToTarget() {
    return false;
  }
  get ATTR_DataSource_recording__DescriptionAttribute() {
    return "Enable/ disable sensor data recording in the device on-board datalogger." + GenericHints.DevConfAffected;
  }
  get DataSource_recording() {
    return this._DataSource_source.get_recording();
  }
  set DataSource_recording(value) {
    this._DataSource_source.set_recording(value);
  }
  get ATTR_thickness__DisplayName() {
    return "Thickness";
  }
  get ATTR_thickness__DescriptionAttribute() {
    return "Line thickness.";
  }
  get thickness() {
    return this._thickness;
  }
  set thickness(value) {
    this._thickness = value;
  }
  get ATTR_legend__DisplayName() {
    return "Legend";
  }
  get ATTR_legend__DescriptionAttribute() {
    return "Short description of the series.";
  }
  get legend() {
    return this._legend;
  }
  set legend(value) {
    this._legend = value;
  }
  get ATTR_color__DisplayName() {
    return "Color";
  }
  get ATTR_color__DescriptionAttribute() {
    return "Line color.";
  }
  get color() {
    return this._color;
  }
  set color(value) {
    this._color = value;
  }
  get ATTR_yAxisIndex__AllowedValues() {
    return yAxisDescription.AllowedValues;
  }
  get ATTR_yAxisIndex__DisplayName() {
    return "Y axis";
  }
  get ATTR_yAxisIndex__DescriptionAttribute() {
    return "Choose which Y axis the data with be scaled to.";
  }
  get yAxisIndex() {
    return this._yAxisIndex;
  }
  set yAxisIndex(value) {
    this._yAxisIndex = value;
  }
  get ATTR_DataSource_AlarmSection0__DisplayName() {
    return "Sensor value alarm 1";
  }
  get ATTR_DataSource_AlarmSection0__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection0__DescriptionAttribute() {
    return "Alarm 1 for this data source, expand for more.";
  }
  get DataSource_AlarmSection0() {
    return this._DataSource_AlarmSection0;
  }
  set DataSource_AlarmSection0(value) {
    this._DataSource_AlarmSection0 = value;
  }
  get ATTR_DataSource_AlarmSection1__DisplayName() {
    return "Sensor value alarm 2";
  }
  get ATTR_DataSource_AlarmSection1__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection1__DescriptionAttribute() {
    return "Alarm 2 for this data source, expand for more.";
  }
  get DataSource_AlarmSection1() {
    return this._DataSource_AlarmSection1;
  }
  set DataSource_AlarmSection1(value) {
    this._DataSource_AlarmSection1 = value;
  }
};
var LegendPanelDescription = class {
  constructor() {
    this._enabled = false;
    this._overlap = false;
    this._position = LegendPanel.Position.RIGHT;
    this._font = new FontDescription("Arial", 7, YColor.FromArgb(255, 32, 32, 32), false, true);
    this._bgColor = YColor.FromArgb(200, 255, 255, 255);
    this._borderColor = YColor.Black;
    this._borderthickness = 1;
    this._padding = 10;
    this._verticalMargin = 10;
    this._horizontalMargin = 10;
    this._traceWidthFactor = 1;
  }
  get summary() {
    return this._enabled ? "Enabled" : "Disabled";
  }
  get ATTR_enabled__DisplayName() {
    return "Enabled";
  }
  get ATTR_enabled__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_enabled__DescriptionAttribute() {
    return "Should the legend panel be shown or not";
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    this._enabled = value;
  }
  get ATTR_overlap__DisplayName() {
    return "Overlap";
  }
  get ATTR_overlap__DescriptionAttribute() {
    return "Can the panel overlap the graph data, or should we explicitly make space for it?";
  }
  get overlap() {
    return this._overlap;
  }
  set overlap(value) {
    this._overlap = value;
  }
  get ATTR_position__DisplayName() {
    return "Position";
  }
  get ATTR_position__DescriptionAttribute() {
    return "Position of the legend panel";
  }
  get position() {
    return this._position;
  }
  set position(value) {
    this._position = value;
  }
  get ATTR_font__DisplayName() {
    return "Font";
  }
  get ATTR_font__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_font__DescriptionAttribute() {
    return "Legend panel contents fonts";
  }
  get font() {
    return this._font;
  }
  set font(value) {
    this._font = value;
  }
  get ATTR_bgColor__DisplayName() {
    return "Background color ";
  }
  get ATTR_bgColor__DescriptionAttribute() {
    return "Legend panel background color.";
  }
  get bgColor() {
    return this._bgColor;
  }
  set bgColor(value) {
    this._bgColor = value;
  }
  get ATTR_borderColor__DisplayName() {
    return "Border color ";
  }
  get ATTR_borderColor__DescriptionAttribute() {
    return "Legend panel border color.";
  }
  get borderColor() {
    return this._borderColor;
  }
  set borderColor(value) {
    this._borderColor = value;
  }
  get ATTR_borderthickness__DisplayName() {
    return "Border thickness ";
  }
  get ATTR_borderthickness__DescriptionAttribute() {
    return "Legend panel border thickness";
  }
  get borderthickness() {
    return this._borderthickness;
  }
  set borderthickness(value) {
    this._borderthickness = value;
  }
  get ATTR_padding__DisplayName() {
    return "Padding ";
  }
  get ATTR_padding__DescriptionAttribute() {
    return "Distance between the panel border and the panel contents";
  }
  get padding() {
    return this._padding;
  }
  set padding(value) {
    this._padding = value;
  }
  get ATTR_verticalMargin__DisplayName() {
    return "Vertical margin ";
  }
  get ATTR_verticalMargin__DescriptionAttribute() {
    return "Vertical distance between the panel border and its surroundings";
  }
  get verticalMargin() {
    return this._verticalMargin;
  }
  set verticalMargin(value) {
    this._verticalMargin = value;
  }
  get ATTR_horizontalMargin__DisplayName() {
    return "Horizontal margin ";
  }
  get ATTR_horizontalMargin__DescriptionAttribute() {
    return "Distance between the panel border and its surroundings";
  }
  get horizontalMargin() {
    return this._horizontalMargin;
  }
  set horizontalMargin(value) {
    this._horizontalMargin = value;
  }
  get ATTR_traceWidthFactor__DisplayName() {
    return "Color Indicator Factor";
  }
  get ATTR_traceWidthFactor__DescriptionAttribute() {
    return "Factor used to enlarge series color indicators shown in the legend panel";
  }
  get traceWidthFactor() {
    return this._traceWidthFactor;
  }
  set traceWidthFactor(value) {
    this._traceWidthFactor = value;
  }
};
var AnnotationPanelDescription = class {
  get summary() {
    return this._enabled ? "Enabled" : "Disabled";
  }
  get ATTR_enabled__DisplayName() {
    return "Enabled";
  }
  get ATTR_enabled__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_enabled__DescriptionAttribute() {
    return "Should the annotation panel be shown or not";
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    this._enabled = value;
  }
  get ATTR_overlap__DisplayName() {
    return "Overlap";
  }
  get ATTR_overlap__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_overlap__DescriptionAttribute() {
    return "Can the annotation panel overlap the display zone, or should the display zone be squeezed to make space for the panel?";
  }
  get overlap() {
    return this._overlap;
  }
  set overlap(value) {
    this._overlap = value;
  }
  get ATTR_text__DisplayName() {
    return "Text ";
  }
  get ATTR_text__DescriptionAttribute() {
    return GenericHints.Annotation;
  }
  get text() {
    return this._text;
  }
  set text(value) {
    this._text = value;
  }
  get ATTR_panelTextAlign__DisplayName() {
    return "Text Alignment";
  }
  get ATTR_panelTextAlign__DescriptionAttribute() {
    return "How text is aligned, makes sense on multi-lines text only.";
  }
  get panelTextAlign() {
    return this._panelTextAlign;
  }
  set panelTextAlign(value) {
    this._panelTextAlign = value;
  }
  get ATTR_panelHrzAlign__DisplayName() {
    return "X Position";
  }
  get ATTR_panelHrzAlign__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_panelHrzAlign__DescriptionAttribute() {
    return "Annotation panel X position";
  }
  get panelHrzAlign() {
    return this._panelHrzAlign;
  }
  set panelHrzAlign(value) {
    this._panelHrzAlign = value;
  }
  get ATTR_positionOffsetX__DisplayName() {
    return "X Offset";
  }
  get ATTR_positionOffsetX__DescriptionAttribute() {
    return "X Position offset, in %  (overlap mode only)";
  }
  get positionOffsetX() {
    return this._positionOffsetX;
  }
  set positionOffsetX(value) {
    this._positionOffsetX = value;
  }
  get ATTR_panelVrtAlign__DisplayName() {
    return "Y Position";
  }
  get ATTR_panelVrtAlign__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_panelVrtAlign__DescriptionAttribute() {
    return "Annotation panel Y position";
  }
  get panelVrtAlign() {
    return this._panelVrtAlign;
  }
  set panelVrtAlign(value) {
    this._panelVrtAlign = value;
  }
  get ATTR_positionOffsetY__DisplayName() {
    return "Y Offset";
  }
  get ATTR_positionOffsetY__DescriptionAttribute() {
    return "Y Position offset, in %  (overlap mode only)";
  }
  get positionOffsetY() {
    return this._positionOffsetY;
  }
  set positionOffsetY(value) {
    this._positionOffsetY = value;
  }
  get ATTR_font__DisplayName() {
    return "Font";
  }
  get ATTR_font__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_font__DescriptionAttribute() {
    return "Panel font";
  }
  get font() {
    return this._font;
  }
  set font(value) {
    this._font = value;
  }
  get ATTR_bgColor__DisplayName() {
    return "Background color ";
  }
  get ATTR_bgColor__DescriptionAttribute() {
    return "Legend panel background color.";
  }
  get bgColor() {
    return this._bgColor;
  }
  set bgColor(value) {
    this._bgColor = value;
  }
  get ATTR_borderColor__DisplayName() {
    return "Border color ";
  }
  get ATTR_borderColor__DescriptionAttribute() {
    return "Legend panel border color.";
  }
  get borderColor() {
    return this._borderColor;
  }
  set borderColor(value) {
    this._borderColor = value;
  }
  get ATTR_borderthickness__DisplayName() {
    return "Border thickness ";
  }
  get ATTR_borderthickness__DescriptionAttribute() {
    return "Panel border thickness";
  }
  get borderthickness() {
    return this._borderthickness;
  }
  set borderthickness(value) {
    this._borderthickness = value;
  }
  get ATTR_padding__DisplayName() {
    return "Padding ";
  }
  get ATTR_padding__DescriptionAttribute() {
    return "Distance between the panel border and the panel contents";
  }
  get padding() {
    return this._padding;
  }
  set padding(value) {
    this._padding = value;
  }
  constructor(hrzAlignInit, vrtAlignInit, offsetY, overlap, textInit, BgColorInit, BorderColorInit, fontSizeInit, FontColorInit) {
    this._enabled = false;
    this._overlap = false;
    this._text = "Date: $DAY$/$MONTH$/$YEAR$";
    this._panelTextAlign = GenericPanel.TextAlign.CENTER;
    this._panelHrzAlign = GenericPanel.HorizontalAlignPos.CENTER;
    this._positionOffsetX = 0;
    this._panelVrtAlign = GenericPanel.VerticalAlignPos.TOP;
    this._positionOffsetY = 0;
    this._font = new FontDescription("Arial", 12, YColor.FromArgb(255, 32, 32, 32), false, false);
    this._bgColor = YColor.FromArgb(200, 255, 255, 255);
    this._borderColor = YColor.Black;
    this._borderthickness = 1;
    this._padding = 5;
    if (typeof textInit != "undefined")
      this._text = textInit;
    if (typeof offsetY != "undefined")
      this._positionOffsetY = offsetY;
    if (typeof overlap != "undefined")
      this._overlap = overlap;
    if (typeof BgColorInit != "undefined")
      this._bgColor = BgColorInit;
    if (typeof BorderColorInit != "undefined")
      this._borderColor = BorderColorInit;
    if (typeof fontSizeInit != "undefined")
      this._font.size = fontSizeInit;
    if (typeof FontColorInit != "undefined")
      this._font.color = FontColorInit;
    if (typeof vrtAlignInit != "undefined")
      this._panelVrtAlign = vrtAlignInit;
    if (typeof hrzAlignInit != "undefined")
      this._panelHrzAlign = hrzAlignInit;
  }
};
var AnnotationPanelDescriptionGraph = class extends AnnotationPanelDescription {
  get ATTR_enabled__DisplayName() {
    return "Enabled";
  }
  get ATTR_enabled__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_enabled__DescriptionAttribute() {
    return "Should the annotation panel be shown or not";
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    this._enabled = value;
  }
  get ATTR_overlap__DisplayName() {
    return "Overlap";
  }
  get ATTR_overlap__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_overlap__DescriptionAttribute() {
    return "Can the annotation panel overlap the graph, or should the graph be squeezed to make space for the panel?";
  }
  get overlap() {
    return this._overlap;
  }
  set overlap(value) {
    this._overlap = value;
  }
  get ATTR_text__DisplayName() {
    return "Text ";
  }
  get ATTR_text__DescriptionAttribute() {
    return GenericHints.AnnotationGraph;
  }
  get text() {
    return this._text;
  }
  set text(value) {
    this._text = value;
  }
};
var DataTrackerDescription = class {
  constructor() {
    this._enabled = false;
    this._showSerieName = false;
    this._showTimeStamp = false;
    this._dataPrecision = DataTrackerDescription.DataPrecision.PRECISION_NOLIMIT;
    this._diameter = 5;
    this._handleLength = 25;
    this._font = new FontDescription("Arial", 7, YColor.FromArgb(255, 32, 32, 32), false, false);
    this._bgColor = YColor.FromArgb(200, 255, 255, 255);
    this._borderColor = YColor.Black;
    this._borderthickness = 1;
    this._padding = 5;
    this._detectionDistance = 50;
  }
  get summary() {
    return this._enabled ? "Enabled" : "Disabled";
  }
  get ATTR_enabled__DisplayName() {
    return "Enabled";
  }
  get ATTR_enabled__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_enabled__DescriptionAttribute() {
    return "Should the data tracker be shown or not.";
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    this._enabled = value;
  }
  get ATTR_showSerieName__DisplayName() {
    return "Show Series legend";
  }
  get ATTR_showSerieName__DescriptionAttribute() {
    return "Should the data tracker show the value's series legend.";
  }
  get showSerieName() {
    return this._showSerieName;
  }
  set showSerieName(value) {
    this._showSerieName = value;
  }
  get ATTR_showTimeStamp__DisplayName() {
    return "Show Timestamp";
  }
  get ATTR_showTimeStamp__DescriptionAttribute() {
    return "Should the data tracker show the value's timestamp.";
  }
  get showTimeStamp() {
    return this._showTimeStamp;
  }
  set showTimeStamp(value) {
    this._showTimeStamp = value;
  }
  get ATTR_dataPrecision__DisplayName() {
    return "Precision";
  }
  get ATTR_dataPrecision__DescriptionAttribute() {
    return "A way to limit data precision to meaningful digits in the data tracker.";
  }
  get dataPrecision() {
    return this._dataPrecision;
  }
  set dataPrecision(value) {
    this._dataPrecision = value;
  }
  get ATTR_diameter__DisplayName() {
    return "Point Diameter";
  }
  get ATTR_diameter__DescriptionAttribute() {
    return "Data point diameter, in pixels";
  }
  get diameter() {
    return this._diameter;
  }
  set diameter(value) {
    this._diameter = value;
  }
  get ATTR_handleLength__DisplayName() {
    return "Handle size";
  }
  get ATTR_handleLength__DescriptionAttribute() {
    return "size of the handle between the data point and the value panel";
  }
  get handleLength() {
    return this._handleLength;
  }
  set handleLength(value) {
    this._handleLength = value;
  }
  get ATTR_font__DisplayName() {
    return "Font";
  }
  get ATTR_font__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_font__DescriptionAttribute() {
    return "Data tracker label fonts";
  }
  get font() {
    return this._font;
  }
  set font(value) {
    this._font = value;
  }
  get ATTR_bgColor__DisplayName() {
    return "Background color";
  }
  get ATTR_bgColor__DescriptionAttribute() {
    return "Value panel ground color.";
  }
  get bgColor() {
    return this._bgColor;
  }
  set bgColor(value) {
    this._bgColor = value;
  }
  get ATTR_borderColor__DisplayName() {
    return "Border color";
  }
  get ATTR_borderColor__DescriptionAttribute() {
    return "Value panel border and handle  color.";
  }
  get borderColor() {
    return this._borderColor;
  }
  set borderColor(value) {
    this._borderColor = value;
  }
  get ATTR_borderthickness__DisplayName() {
    return "Border thickness ";
  }
  get ATTR_borderthickness__DescriptionAttribute() {
    return "Value panel border and handle  thickness";
  }
  get borderthickness() {
    return this._borderthickness;
  }
  set borderthickness(value) {
    this._borderthickness = value;
  }
  get ATTR_padding__DisplayName() {
    return "Padding";
  }
  get ATTR_padding__DescriptionAttribute() {
    return "Distance between the panel border and its contents ";
  }
  get padding() {
    return this._padding;
  }
  set padding(value) {
    this._padding = value;
  }
  get ATTR_detectionDistance__DisplayName() {
    return "Detection distance";
  }
  get ATTR_detectionDistance__DescriptionAttribute() {
    return "Maximum distance, in pixels, between the mouse and a data point for data tracker to show. Use zero for infinite distance";
  }
  get detectionDistance() {
    return this._detectionDistance;
  }
  set detectionDistance(value) {
    this._detectionDistance = value;
  }
};
(function(DataTrackerDescription2) {
  class DataPrecisionEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, DataPrecision);
    }
  }
  DataTrackerDescription2.DataPrecisionEnumItem = DataPrecisionEnumItem;
  class DataPrecision extends YEnum {
  }
  DataPrecision.PRECISION_NOLIMIT = new DataPrecisionEnumItem("PRECISION_NOLIMIT", "As is");
  DataPrecision.PRECISION_1 = new DataPrecisionEnumItem("PRECISION_1", "1");
  DataPrecision.PRECISION_01 = new DataPrecisionEnumItem("PRECISION_01", "0.1");
  DataPrecision.PRECISION_001 = new DataPrecisionEnumItem("PRECISION_001", "0.01");
  DataPrecision.PRECISION_0001 = new DataPrecisionEnumItem("PRECISION_0001", "0.001");
  DataTrackerDescription2.DataPrecision = DataPrecision;
})(DataTrackerDescription || (DataTrackerDescription = {}));
var NavigatorDescription = class {
  get summary() {
    return this._enabled ? "Enabled" : "Disabled";
  }
  constructor() {
    this._enabled = false;
    this._bgColor1 = YColor.FromArgb(255, 225, 225, 225);
    this._bgColor2 = YColor.FromArgb(255, 225, 225, 225);
    this._borderThickness = 1;
    this._borderColor = YColor.Black;
    this._cursorColor = YColor.FromArgb(25, 0, 255, 0);
    this._cursorBorderColor = YColor.FromArgb(255, 96, 96, 96);
    this._yAxisHandling = Navigator.YAxisHandling.AUTO;
    this._xAxisThickness = 1;
    this._xAxisColor = YColor.Black;
    this._font = new FontDescription("Arial", 10, YColor.FromArgb(255, 32, 32, 32), false, false);
  }
  get ATTR_enabled__DisplayName() {
    return "Enabled";
  }
  get ATTR_enabled__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_enabled__DescriptionAttribute() {
    return "Should the navigator be shown or not.";
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    this._enabled = value;
  }
  get ATTR_bgColor1__DisplayName() {
    return "Background color 1";
  }
  get ATTR_bgColor1__DescriptionAttribute() {
    return "Navigator background gradient color 1.";
  }
  get bgColor1() {
    return this._bgColor1;
  }
  set bgColor1(value) {
    this._bgColor1 = value;
  }
  get ATTR_bgColor2__DisplayName() {
    return "Background color 2";
  }
  get ATTR_bgColor2__DescriptionAttribute() {
    return "Navigator background gradient color 2.";
  }
  get bgColor2() {
    return this._bgColor2;
  }
  set bgColor2(value) {
    this._bgColor2 = value;
  }
  get ATTR_borderThickness__DisplayName() {
    return "Border thickness";
  }
  get ATTR_borderThickness__DescriptionAttribute() {
    return "Navigator";
  }
  get borderThickness() {
    return this._borderThickness;
  }
  set borderThickness(value) {
    this._borderThickness = value;
  }
  get ATTR_borderColor__DisplayName() {
    return "Border color";
  }
  get ATTR_borderColor__DescriptionAttribute() {
    return "Navigator Border color.";
  }
  get borderColor() {
    return this._borderColor;
  }
  set borderColor(value) {
    this._borderColor = value;
  }
  get ATTR_cursorColor__DisplayName() {
    return "Navigator cursor fill color";
  }
  get ATTR_cursorColor__DescriptionAttribute() {
    return "Navigator";
  }
  get cursorColor() {
    return this._cursorColor;
  }
  set cursorColor(value) {
    this._cursorColor = value;
  }
  get ATTR_cursorBorderColor__DisplayName() {
    return "Navigator cursor left/right border color.";
  }
  get ATTR_cursorBorderColor__DescriptionAttribute() {
    return "Navigator";
  }
  get cursorBorderColor() {
    return this._cursorBorderColor;
  }
  set cursorBorderColor(value) {
    this._cursorBorderColor = value;
  }
  get ATTR_yAxisHandling__DisplayName() {
    return "Y axis range";
  }
  get ATTR_yAxisHandling__DescriptionAttribute() {
    return "Is navigator Y axis zoom automatic or inherited from main view settings?";
  }
  get yAxisHandling() {
    return this._yAxisHandling;
  }
  set yAxisHandling(value) {
    this._yAxisHandling = value;
  }
  get ATTR_xAxisThickness__DisplayName() {
    return "X axis thickness";
  }
  get ATTR_xAxisThickness__DescriptionAttribute() {
    return "Navigator";
  }
  get xAxisThickness() {
    return this._xAxisThickness;
  }
  set xAxisThickness(value) {
    this._xAxisThickness = value;
  }
  get ATTR_xAxisColor__DisplayName() {
    return "X axis color";
  }
  get ATTR_xAxisColor__DescriptionAttribute() {
    return "Navigator X axis color.";
  }
  get xAxisColor() {
    return this._xAxisColor;
  }
  set xAxisColor(value) {
    this._xAxisColor = value;
  }
  get ATTR_font__DisplayName() {
    return "X-Axis Font";
  }
  get ATTR_font__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_font__DescriptionAttribute() {
    return "Navigator X axis font";
  }
  get font() {
    return this._font;
  }
  set font(value) {
    this._font = value;
  }
};
var LegendDescription = class {
  constructor() {
    this._title = "";
    this._font = new FontDescription("Arial", 12, YColor.Black, false, true);
  }
  get ATTR_title__DisplayName() {
    return "Text";
  }
  get ATTR_title__DescriptionAttribute() {
    return "Legend text";
  }
  get title() {
    return this._title;
  }
  set title(value) {
    this._title = value;
  }
  get ATTR_font__DisplayName() {
    return "Font";
  }
  get ATTR_font__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_font__DescriptionAttribute() {
    return "Legend font";
  }
  get font() {
    return this._font;
  }
  set font(value) {
    this._font = value;
  }
};
var YaxisDescription = class {
  constructor(index, shown) {
    this._visible = false;
    this._position = YAxis.HrzPosition.LEFT;
    this._min = new doubleNan(Number.NaN);
    this._max = new doubleNan(Number.NaN);
    this._step = new doubleNan(Number.NaN);
    this._color = YColor.FromArgb(255, 127, 127, 127);
    this._thickness = 1;
    this._showGrid = false;
    this._gridColor = YColor.FromArgb(255, 210, 210, 210);
    this._gridThickness = 1;
    this._font = new FontDescription("Arial", 10, YColor.Black, false, false);
    this._legend = new LegendDescription();
    this._zones0 = new ZoneDescription(0, 50, YColor.LightGreen);
    this._zones1 = new ZoneDescription(50, 80, YColor.Yellow);
    this._zones2 = new ZoneDescription(80, 100, YColor.Red);
    this._visible = shown;
    this._showGrid = index == 0;
    this._position = index == 0 ? YAxis.HrzPosition.LEFT : YAxis.HrzPosition.RIGHT;
  }
  get summary() {
    return this._visible ? "Enabled" : "Disabled";
  }
  get ATTR_visible__DisplayName() {
    return "Visible";
  }
  get ATTR_visible__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_visible__DescriptionAttribute() {
    return "Should that YAxis be shown?.";
  }
  get visible() {
    return this._visible;
  }
  set visible(value) {
    this._visible = value;
  }
  get ATTR_position__DisplayName() {
    return "Position";
  }
  get ATTR_position__DescriptionAttribute() {
    return "Y Axis position (left / right)";
  }
  get position() {
    return this._position;
  }
  set position(value) {
    this._position = value;
  }
  get ATTR_min__DisplayName() {
    return "Minimum value";
  }
  get ATTR_min__DescriptionAttribute() {
    return "YAxis minimum value, leave blank for automatic behavior.";
  }
  get min() {
    return this._min;
  }
  set min(value) {
    this._min = value;
  }
  get ATTR_max__DisplayName() {
    return "Maximum value";
  }
  get ATTR_max__DescriptionAttribute() {
    return "YAxis maximum value, leave blank for automatic behavior.";
  }
  get max() {
    return this._max;
  }
  set max(value) {
    this._max = value;
  }
  get ATTR_step__DisplayName() {
    return "Steps";
  }
  get ATTR_step__DescriptionAttribute() {
    return "YAxis step size, leave blank for automatic behavior.";
  }
  get step() {
    return this._step;
  }
  set step(value) {
    this._step = value;
  }
  get ATTR_color__DisplayName() {
    return "Color";
  }
  get ATTR_color__DescriptionAttribute() {
    return "Y Axis Color.";
  }
  get color() {
    return this._color;
  }
  set color(value) {
    this._color = value;
  }
  get ATTR_thickness__DisplayName() {
    return "Thickness";
  }
  get ATTR_thickness__DescriptionAttribute() {
    return "Axis thickness";
  }
  get thickness() {
    return this._thickness;
  }
  set thickness(value) {
    this._thickness = value;
  }
  get ATTR_showGrid__DisplayName() {
    return "Show Grid";
  }
  get ATTR_showGrid__DescriptionAttribute() {
    return "Show grid horizontal lines, or not.";
  }
  get showGrid() {
    return this._showGrid;
  }
  set showGrid(value) {
    this._showGrid = value;
  }
  get ATTR_gridColor__DisplayName() {
    return "Grid Color";
  }
  get ATTR_gridColor__DescriptionAttribute() {
    return "Grid horizontal lines color.";
  }
  get gridColor() {
    return this._gridColor;
  }
  set gridColor(value) {
    this._gridColor = value;
  }
  get ATTR_gridThickness__DisplayName() {
    return "Grid thickness";
  }
  get ATTR_gridThickness__DescriptionAttribute() {
    return "Grid horizontal lines thickness";
  }
  get gridThickness() {
    return this._gridThickness;
  }
  set gridThickness(value) {
    this._gridThickness = value;
  }
  get ATTR_font__DisplayName() {
    return "Font";
  }
  get ATTR_font__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_font__DescriptionAttribute() {
    return "Axis font";
  }
  get font() {
    return this._font;
  }
  set font(value) {
    this._font = value;
  }
  get ATTR_legend__DisplayName() {
    return "Legend";
  }
  get ATTR_legend__DescriptionAttribute() {
    return "Axis legend";
  }
  get legend() {
    return this._legend;
  }
  set legend(value) {
    this._legend = value;
  }
  get ATTR_zones0__DisplayName() {
    return "Zone 1";
  }
  get ATTR_zones0__CategoryAttribute() {
    return "Zones";
  }
  get ATTR_zones0__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_zones0__DescriptionAttribute() {
    return "Zone 1 parameters";
  }
  get zones0() {
    return this._zones0;
  }
  set zones0(value) {
    this._zones0 = value;
  }
  get ATTR_zones1__DisplayName() {
    return "Zone 2";
  }
  get ATTR_zones1__CategoryAttribute() {
    return "Zones";
  }
  get ATTR_zones1__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_zones1__DescriptionAttribute() {
    return "Zone 2 parameters";
  }
  get zones1() {
    return this._zones1;
  }
  set zones1(value) {
    this._zones1 = value;
  }
  get ATTR_zones2__DisplayName() {
    return "Zone 3";
  }
  get ATTR_zones2__CategoryAttribute() {
    return "Zones";
  }
  get ATTR_zones2__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_zones2__DescriptionAttribute() {
    return "Zone 3 parameters";
  }
  get zones2() {
    return this._zones2;
  }
  set zones2(value) {
    this._zones2 = value;
  }
};
var MarkerDescription = class {
  constructor(defaultText) {
    this._enabled = false;
    this._text = "";
    this._textAlign = Marker.TextAlign.CENTER;
    this._timereference = TimeConverter.TimeReference.ABSOLUTE;
    this._positionOnXAxis = new xAxisPosition(TimeConverter.ToUnixTime(new Date()), false);
    this._yposition = 95;
    this._bgColor = YColor.FromArgb(200, 255, 255, 192);
    this._borderColor = YColor.DarkRed;
    this._borderthickness = 1;
    this._padding = 5;
    this._font = new FontDescription("Arial", 7, YColor.Black, false, false);
    this._text = defaultText;
  }
  get summary() {
    return this._enabled ? "Enabled" : "Disabled";
  }
  get ATTR_enabled__DisplayName() {
    return "Enabled";
  }
  get ATTR_enabled__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_enabled__DescriptionAttribute() {
    return "Should that marker be shown?.";
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    this._enabled = value;
  }
  get ATTR_text__DisplayName() {
    return "Text";
  }
  get ATTR_text__DescriptionAttribute() {
    return "Marker text. Use \\n for multi-line text. Some variables are allowed such as $MARKERTIME$, $LEGEND1$, $VALUE1$, $UNIT1$, $LEGEND1$, $VALUE2$ etc.. Extensive use of marker variables migh make the graph rendering significantly slower.";
  }
  get text() {
    return this._text;
  }
  set text(value) {
    this._text = value;
  }
  get ATTR_textAlign__DisplayName() {
    return "Text Alignment";
  }
  get ATTR_textAlign__DescriptionAttribute() {
    return "How text is aligned, makes sense on multi-lines text only.";
  }
  get textAlign() {
    return this._textAlign;
  }
  set textAlign(value) {
    this._textAlign = value;
  }
  get ATTR_timereference__DisplayName() {
    return "Time reference";
  }
  get ATTR_timereference__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_timereference__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_timereference__DescriptionAttribute() {
    return "Should the marker time position be absolute or relative to first data timestamp? Note: relative markers won't be drawn until there is actual data.";
  }
  get timereference() {
    return this._timereference;
  }
  set timereference(value) {
    this._timereference = value;
    this._positionOnXAxis.relative = value == TimeConverter.TimeReference.RELATIVE;
  }
  get ATTR_positionOnXAxis__DisplayName() {
    return "Time position";
  }
  get ATTR_positionOnXAxis__DescriptionAttribute() {
    return "Marker position on X axis.";
  }
  get positionOnXAxis() {
    return this._positionOnXAxis;
  }
  set positionOnXAxis(value) {
    this._positionOnXAxis = value;
    this.timereference = value.relative ? TimeConverter.TimeReference.RELATIVE : TimeConverter.TimeReference.ABSOLUTE;
  }
  get ATTR_yposition__DisplayName() {
    return "Vrt position (%)";
  }
  get ATTR_yposition__DescriptionAttribute() {
    return "Vertical position of the marker label in % of available space. Zero is bottom";
  }
  get yposition() {
    return this._yposition;
  }
  set yposition(value) {
    this._yposition = value;
  }
  get ATTR_bgColor__DisplayName() {
    return "Background color ";
  }
  get ATTR_bgColor__DescriptionAttribute() {
    return "Marker  background color.";
  }
  get bgColor() {
    return this._bgColor;
  }
  set bgColor(value) {
    this._bgColor = value;
  }
  get ATTR_borderColor__DisplayName() {
    return "Border color ";
  }
  get ATTR_borderColor__DescriptionAttribute() {
    return "Marker border color.";
  }
  get borderColor() {
    return this._borderColor;
  }
  set borderColor(value) {
    this._borderColor = value;
  }
  get ATTR_borderthickness__DisplayName() {
    return "Border thickness ";
  }
  get ATTR_borderthickness__DescriptionAttribute() {
    return "Marker border thickness, in pixels.";
  }
  get borderthickness() {
    return this._borderthickness;
  }
  set borderthickness(value) {
    this._borderthickness = value;
  }
  get ATTR_padding__DisplayName() {
    return "Padding ";
  }
  get ATTR_padding__DescriptionAttribute() {
    return "Distance between the marker border and the marker contents, in pixels.";
  }
  get padding() {
    return this._padding;
  }
  set padding(value) {
    this._padding = value;
  }
  get ATTR_font__DisplayName() {
    return "Font";
  }
  get ATTR_font__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_font__DescriptionAttribute() {
    return "Marker Font";
  }
  get font() {
    return this._font;
  }
  set font(value) {
    this._font = value;
  }
};
var XaxisDescription = class {
  constructor() {
    this._initialZoom = 60;
    this._initialOffset = 0;
    this._position = XAxis.VrtPosition.BOTTOM;
    this._timeReference = TimeConverter.TimeReference.ABSOLUTE;
    this._overflowHandling = XAxis.OverflowHandling.SCROLL;
    this._color = YColor.FromArgb(255, 127, 127, 127);
    this._thickness = 1;
    this._showGrid = false;
    this._gridColor = YColor.FromArgb(50, 0, 0, 0);
    this._gridThickness = 1;
    this._font = new FontDescription("Arial", 10, YColor.Black, false, false);
    this._legend = new LegendDescription();
    this._markers0 = new MarkerDescription("Marker 1");
    this._markers1 = new MarkerDescription("Marker 2");
    this._markers2 = new MarkerDescription("Marker 3");
    this._markers3 = new MarkerDescription("Marker 4");
    this._markers4 = new MarkerDescription("Marker 5");
    this._markers5 = new MarkerDescription("Marker 6");
    this._markers6 = new MarkerDescription("Marker 7");
    this._markers7 = new MarkerDescription("Marker 8");
  }
  get ATTR_initialZoom__DisplayName() {
    return "Initial Zoom";
  }
  get ATTR_initialZoom__DescriptionAttribute() {
    return "Zoom level at application startup, i.e. width of the view-port in seconds.";
  }
  get initialZoom() {
    return this._initialZoom;
  }
  set initialZoom(value) {
    this._initialZoom = value;
  }
  get ATTR_initialOffset__DisplayName() {
    return "Initial Offset";
  }
  get ATTR_initialOffset__DescriptionAttribute() {
    return "Offset of the first data point in percentage of the viewport width. For instance a 50% value will put the first point in the middle of the viewport. This can be used to give some room for datalogger contents.";
  }
  get initialOffset() {
    return this._initialOffset;
  }
  set initialOffset(value) {
    this._initialOffset = value;
  }
  get ATTR_position__DisplayName() {
    return "Position";
  }
  get ATTR_position__DescriptionAttribute() {
    return "X Axis position (top / bottom)";
  }
  get position() {
    return this._position;
  }
  set position(value) {
    this._position = value;
  }
  get ATTR_timeReference__DisplayName() {
    return "Time reference";
  }
  get ATTR_timeReference__DescriptionAttribute() {
    return "Are gradation timestamps absolute or relative to experiment start time? ";
  }
  get timeReference() {
    return this._timeReference;
  }
  set timeReference(value) {
    this._timeReference = value;
  }
  get ATTR_overflowHandling__DisplayName() {
    return "Overflow Handling";
  }
  get ATTR_overflowHandling__DescriptionAttribute() {
    return "What to do when new data are about to reach the graph right border";
  }
  get overflowHandling() {
    return this._overflowHandling;
  }
  set overflowHandling(value) {
    this._overflowHandling = value;
  }
  get ATTR_color__DisplayName() {
    return "Color";
  }
  get ATTR_color__DescriptionAttribute() {
    return "X Axis Color.";
  }
  get color() {
    return this._color;
  }
  set color(value) {
    this._color = value;
  }
  get ATTR_thickness__DisplayName() {
    return "Thickness";
  }
  get ATTR_thickness__DescriptionAttribute() {
    return "Axis thickness";
  }
  get thickness() {
    return this._thickness;
  }
  set thickness(value) {
    this._thickness = value;
  }
  get ATTR_showGrid__DisplayName() {
    return "Show Grid";
  }
  get ATTR_showGrid__DescriptionAttribute() {
    return "Show grid vertical lines, or not.";
  }
  get showGrid() {
    return this._showGrid;
  }
  set showGrid(value) {
    this._showGrid = value;
  }
  get ATTR_gridColor__DisplayName() {
    return "Grid Color";
  }
  get ATTR_gridColor__DescriptionAttribute() {
    return "Grid vertical lines color.";
  }
  get gridColor() {
    return this._gridColor;
  }
  set gridColor(value) {
    this._gridColor = value;
  }
  get ATTR_gridThickness__DisplayName() {
    return "Grid thickness";
  }
  get ATTR_gridThickness__DescriptionAttribute() {
    return "Grid vertical lines thickness";
  }
  get gridThickness() {
    return this._gridThickness;
  }
  set gridThickness(value) {
    this._gridThickness = value;
  }
  get ATTR_font__DisplayName() {
    return "Font";
  }
  get ATTR_font__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_font__DescriptionAttribute() {
    return "Axis font";
  }
  get font() {
    return this._font;
  }
  set font(value) {
    this._font = value;
  }
  get ATTR_legend__DisplayName() {
    return "Legend";
  }
  get ATTR_legend__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_legend__DescriptionAttribute() {
    return "X Axis legend";
  }
  get legend() {
    return this._legend;
  }
  set legend(value) {
    this._legend = value;
  }
  get ATTR_markers0__DisplayName() {
    return "Marker 1";
  }
  get ATTR_markers0__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_markers0__CategoryAttribute() {
    return "Markers";
  }
  get ATTR_markers0__DescriptionAttribute() {
    return "First marker parameters";
  }
  get markers0() {
    return this._markers0;
  }
  set markers0(value) {
    this._markers0 = value;
  }
  get ATTR_markers1__DisplayName() {
    return "Marker 2";
  }
  get ATTR_markers1__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_markers1__CategoryAttribute() {
    return "Markers";
  }
  get ATTR_markers1__DescriptionAttribute() {
    return "Second marker parameters";
  }
  get markers1() {
    return this._markers1;
  }
  set markers1(value) {
    this._markers1 = value;
  }
  get ATTR_markers2__DisplayName() {
    return "Marker 3";
  }
  get ATTR_markers2__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_markers2__CategoryAttribute() {
    return "Markers";
  }
  get ATTR_markers2__DescriptionAttribute() {
    return "Third marker parameters";
  }
  get markers2() {
    return this._markers2;
  }
  set markers2(value) {
    this._markers2 = value;
  }
  get ATTR_markers3__DisplayName() {
    return "Marker 4";
  }
  get ATTR_markers3__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_markers3__CategoryAttribute() {
    return "Markers";
  }
  get ATTR_markers3__DescriptionAttribute() {
    return "Fourth marker parameters";
  }
  get markers3() {
    return this._markers3;
  }
  set markers3(value) {
    this._markers3 = value;
  }
  get ATTR_markers4__DisplayName() {
    return "Marker 5";
  }
  get ATTR_markers4__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_markers4__CategoryAttribute() {
    return "Markers";
  }
  get ATTR_markers4__DescriptionAttribute() {
    return "Fith marker parameters";
  }
  get markers4() {
    return this._markers4;
  }
  set markers4(value) {
    this._markers4 = value;
  }
  get ATTR_markers5__DisplayName() {
    return "Marker 6";
  }
  get ATTR_markers5__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_markers5__CategoryAttribute() {
    return "Markers";
  }
  get ATTR_markers5__DescriptionAttribute() {
    return "Sixth marker parameters";
  }
  get markers5() {
    return this._markers5;
  }
  set markers5(value) {
    this._markers5 = value;
  }
  get ATTR_markers6__DisplayName() {
    return "Marker 7";
  }
  get ATTR_markers6__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_markers6__CategoryAttribute() {
    return "Markers";
  }
  get ATTR_markers6__DescriptionAttribute() {
    return "Seventh marker parameters";
  }
  get markers6() {
    return this._markers6;
  }
  set markers6(value) {
    this._markers6 = value;
  }
  get ATTR_markers7__DisplayName() {
    return "Marker 8";
  }
  get ATTR_markers7__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_markers7__CategoryAttribute() {
    return "Markers";
  }
  get ATTR_markers7__DescriptionAttribute() {
    return "Height marker parameters";
  }
  get markers7() {
    return this._markers7;
  }
  set markers7(value) {
    this._markers7 = value;
  }
};
var GraphFormProperties = class extends GenericProperties {
  constructor(initData, owner) {
    super(owner);
    this._Graph_series0 = new ChartSerie(YColor.Tomato);
    this._Graph_series1 = new ChartSerie(YColor.DodgerBlue);
    this._Graph_series2 = new ChartSerie(YColor.SeaGreen);
    this._Graph_series3 = new ChartSerie(YColor.Gold);
    this._Graph_showRecordedData = false;
    this._Graph_borderColor = YColor.LightGray;
    this._Graph_borderThickness = 1;
    this._Graph_bgColor1 = YColor.FromArgb(255, 220, 220, 220);
    this._Graph_bgColor2 = YColor.FromArgb(55, 240, 240, 240);
    this._Graph_resizeRule = Proportional.ResizeRule.FIXED;
    this._Graph_xAxis = new XaxisDescription();
    this._Graph_yAxes0 = new YaxisDescription(0, true);
    this._Graph_yAxes1 = new YaxisDescription(1, false);
    this._Graph_yAxes2 = new YaxisDescription(2, false);
    this._Graph_legendPanel = new LegendPanelDescription();
    this._Graph_dataTracker = new DataTrackerDescription();
    this._Graph_navigator = new NavigatorDescription();
    this._annotationPanels0 = new AnnotationPanelDescriptionGraph();
    this._annotationPanels1 = new AnnotationPanelDescriptionGraph();
    this.initFromXmlData(initData);
  }
  IsDataSourceAssigned() {
    let propList = Object.getOwnPropertyNames(this);
    propList.forEach((name) => {
      if (name.startsWith("Graphs_series")) {
        let s = this[name].GetValue(this, null);
        if (!(s.DataSource_source instanceof NullYSensor))
          return true;
      }
    });
    return false;
  }
  get ATTR_Graph_series0__DisplayName() {
    return "Series 1";
  }
  get ATTR_Graph_series0__CategoryAttribute() {
    return "Data Sources";
  }
  get ATTR_Graph_series0__PreExpandedCategoryAttribute() {
    return true;
  }
  get ATTR_Graph_series0__PreExpandedAttribute() {
    return true;
  }
  get ATTR_Graph_series0__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_Graph_series0__DescriptionAttribute() {
    return "First data series, expand for more.";
  }
  get Graph_series0() {
    return this._Graph_series0;
  }
  set Graph_series0(value) {
    this._Graph_series0 = value;
  }
  get ATTR_Graph_series1__DisplayName() {
    return "Series 2";
  }
  get ATTR_Graph_series1__CategoryAttribute() {
    return "Data Sources";
  }
  get ATTR_Graph_series1__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_Graph_series1__DescriptionAttribute() {
    return "Second data series, expand for more.";
  }
  get Graph_series1() {
    return this._Graph_series1;
  }
  set Graph_series1(value) {
    this._Graph_series1 = value;
  }
  get ATTR_Graph_series2__DisplayName() {
    return "Series 3";
  }
  get ATTR_Graph_series2__CategoryAttribute() {
    return "Data Sources";
  }
  get ATTR_Graph_series2__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_Graph_series2__DescriptionAttribute() {
    return "Third data series, expand for more.";
  }
  get Graph_series2() {
    return this._Graph_series2;
  }
  set Graph_series2(value) {
    this._Graph_series2 = value;
  }
  get ATTR_Graph_series3__DisplayName() {
    return "Series 4";
  }
  get ATTR_Graph_series3__CategoryAttribute() {
    return "Data Sources";
  }
  get ATTR_Graph_series3__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_Graph_series3__DescriptionAttribute() {
    return "Fourth data series, expand for more.";
  }
  get Graph_series3() {
    return this._Graph_series3;
  }
  set Graph_series3(value) {
    this._Graph_series3 = value;
  }
  get ATTR_Graph_showRecordedData__DisplayName() {
    return "Use datalogger data";
  }
  get ATTR_Graph_showRecordedData__CategoryAttribute() {
    return "Graph";
  }
  get ATTR_Graph_showRecordedData__CopyToTarget() {
    return false;
  }
  get ATTR_Graph_showRecordedData__DescriptionAttribute() {
    return "Makes the graph load the sensors datalogger contents. After disabling this feature, you may want to reset the dataview with the right-click context menu.";
  }
  get Graph_showRecordedData() {
    return this._Graph_showRecordedData;
  }
  set Graph_showRecordedData(value) {
    if (this._Graph_showRecordedData != value) {
      this._Graph_showRecordedData = value;
      if (this.ownerForm != null) {
        this._Graph_showRecordedData ? this.ownerForm.loadRecordedDataIfNeeded() : this.ownerForm.removeDataloggerData();
      }
    }
  }
  get ATTR_Graph_borderColor__DisplayName() {
    return "Border color";
  }
  get ATTR_Graph_borderColor__CategoryAttribute() {
    return "Graph";
  }
  get ATTR_Graph_borderColor__DescriptionAttribute() {
    return "Canvas borders color.";
  }
  get Graph_borderColor() {
    return this._Graph_borderColor;
  }
  set Graph_borderColor(value) {
    this._Graph_borderColor = value;
  }
  get ATTR_Graph_borderThickness__DisplayName() {
    return "Border thickness";
  }
  get ATTR_Graph_borderThickness__CategoryAttribute() {
    return "Graph";
  }
  get ATTR_Graph_borderThickness__DescriptionAttribute() {
    return "Canvas borders thickness.";
  }
  get Graph_borderThickness() {
    return this._Graph_borderThickness;
  }
  set Graph_borderThickness(value) {
    this._Graph_borderThickness = value;
  }
  get ATTR_Graph_bgColor1__DisplayName() {
    return "Background color 1";
  }
  get ATTR_Graph_bgColor1__CategoryAttribute() {
    return "Graph";
  }
  get ATTR_Graph_bgColor1__DescriptionAttribute() {
    return "Background gradient color 1.";
  }
  get Graph_bgColor1() {
    return this._Graph_bgColor1;
  }
  set Graph_bgColor1(value) {
    this._Graph_bgColor1 = value;
  }
  get ATTR_Graph_bgColor2__DisplayName() {
    return "Background color 2";
  }
  get ATTR_Graph_bgColor2__CategoryAttribute() {
    return "Graph";
  }
  get ATTR_Graph_bgColor2__DescriptionAttribute() {
    return "Background gradient color 2.";
  }
  get Graph_bgColor2() {
    return this._Graph_bgColor2;
  }
  set Graph_bgColor2(value) {
    this._Graph_bgColor2 = value;
  }
  get ATTR_Graph_resizeRule__DisplayName() {
    return "Font sizes";
  }
  get ATTR_Graph_resizeRule__CategoryAttribute() {
    return "Graph";
  }
  get ATTR_Graph_resizeRule__DescriptionAttribute() {
    return "Are font sizes fixed or do they change when window is resized?";
  }
  get Graph_resizeRule() {
    return this._Graph_resizeRule;
  }
  set Graph_resizeRule(value) {
    this._Graph_resizeRule = value;
  }
  get ATTR_Graph_xAxis__DisplayName() {
    return "X Axis";
  }
  get ATTR_Graph_xAxis__CategoryAttribute() {
    return "X/Y Axes";
  }
  get ATTR_Graph_xAxis__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_Graph_xAxis__DescriptionAttribute() {
    return "X-Axis, expand for more";
  }
  get Graph_xAxis() {
    return this._Graph_xAxis;
  }
  set Graph_xAxis(value) {
    this._Graph_xAxis = value;
  }
  get ATTR_Graph_yAxes0__DisplayName() {
    return "YAxis 1";
  }
  get ATTR_Graph_yAxes0__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_Graph_yAxes0__CategoryAttribute() {
    return "X/Y Axes";
  }
  get ATTR_Graph_yAxes0__DescriptionAttribute() {
    return "First Y Axis, expand for more.";
  }
  get Graph_yAxes0() {
    return this._Graph_yAxes0;
  }
  set Graph_yAxes0(value) {
    this._Graph_yAxes0 = value;
  }
  get ATTR_Graph_yAxes1__DisplayName() {
    return "YAxis 2";
  }
  get ATTR_Graph_yAxes1__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_Graph_yAxes1__CategoryAttribute() {
    return "X/Y Axes";
  }
  get ATTR_Graph_yAxes1__DescriptionAttribute() {
    return "Second Y Axis, expand for more.";
  }
  get Graph_yAxes1() {
    return this._Graph_yAxes1;
  }
  set Graph_yAxes1(value) {
    this._Graph_yAxes1 = value;
  }
  get ATTR_Graph_yAxes2__DisplayName() {
    return "YAxis 3";
  }
  get ATTR_Graph_yAxes2__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_Graph_yAxes2__CategoryAttribute() {
    return "X/Y Axes";
  }
  get ATTR_Graph_yAxes2__DescriptionAttribute() {
    return "Third Y Axis, expand for more.";
  }
  get Graph_yAxes2() {
    return this._Graph_yAxes2;
  }
  set Graph_yAxes2(value) {
    this._Graph_yAxes2 = value;
  }
  get ATTR_Graph_legendPanel__DisplayName() {
    return "Legend Panel";
  }
  get ATTR_Graph_legendPanel__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_Graph_legendPanel__CategoryAttribute() {
    return "Graph";
  }
  get ATTR_Graph_legendPanel__DescriptionAttribute() {
    return "Panel containing a description of all data series. Expand for more.";
  }
  get Graph_legendPanel() {
    return this._Graph_legendPanel;
  }
  set Graph_legendPanel(value) {
    this._Graph_legendPanel = value;
  }
  get ATTR_Graph_dataTracker__DisplayName() {
    return "Data tracker";
  }
  get ATTR_Graph_dataTracker__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_Graph_dataTracker__CategoryAttribute() {
    return "Graph";
  }
  get ATTR_Graph_dataTracker__DescriptionAttribute() {
    return "Show dynamic value labels while the mouse is moving over the graph. Expand for more.";
  }
  get Graph_dataTracker() {
    return this._Graph_dataTracker;
  }
  set Graph_dataTracker(value) {
    this._Graph_dataTracker = value;
  }
  get ATTR_Graph_navigator__DisplayName() {
    return "Navigator";
  }
  get ATTR_Graph_navigator__CategoryAttribute() {
    return "Graph";
  }
  get ATTR_Graph_navigator__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_Graph_navigator__DescriptionAttribute() {
    return "Small additional graph showing the whole data set and allowing to quickly navigate among data. Expand for more.";
  }
  get Graph_navigator() {
    return this._Graph_navigator;
  }
  set Graph_navigator(value) {
    this._Graph_navigator = value;
  }
  get ATTR_Graph_annotationPanels0__DisplayName() {
    return "Annotation 1";
  }
  get ATTR_Graph_annotationPanels0__CategoryAttribute() {
    return "Annotations";
  }
  get ATTR_Graph_annotationPanels0__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_Graph_annotationPanels0__DescriptionAttribute() {
    return "Customizable text panel 1";
  }
  get Graph_annotationPanels0() {
    return this._annotationPanels0;
  }
  set Graph_annotationPanels0(value) {
    this._annotationPanels0 = value;
  }
  get ATTR_Graph_annotationPanels1__DisplayName() {
    return "Annotation 2";
  }
  get ATTR_Graph_annotationPanels1__CategoryAttribute() {
    return "Annotations";
  }
  get ATTR_Graph_annotationPanels1__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_Graph_annotationPanels1__DescriptionAttribute() {
    return "Customizable text panel 2";
  }
  get Graph_annotationPanels1() {
    return this._annotationPanels1;
  }
  set Graph_annotationPanels1(value) {
    this._annotationPanels1 = value;
  }
};

// obj/full/contextMenu.js
var ContextMenuSeparator = class {
  constructor() {
    this.TR = document.createElement("TR");
    this.TR["objectData"] = this;
    this.TR.className = ContextMenu.SEPARATOR_MARKER;
    this.TD_caption = document.createElement("TD");
    this.TD_caption.style.backgroundColor = ContextMenu.iconBGColor;
    this.TD_caption.style.paddingLeft = "3px";
    this.TD_caption.style.paddingRight = "3px";
    let hr = document.createElement("HR");
    this.TD_caption.colSpan = 2;
    this.TD_caption.appendChild(hr);
    this.TD_icon = document.createElement("TD");
    this.TD_icon.style.backgroundColor = ContextMenu.captionBgColor;
    this.TR.appendChild(this.TD_icon);
    this.TR.appendChild(this.TD_caption);
  }
  toString() {
    return "Separator";
  }
  get focusable() {
    return false;
  }
  parentMenuisClosing() {
  }
  get domData() {
    return this.TR;
  }
};
var ContextMenuItemBase = class {
  get userdata() {
    return this._userdata;
  }
  set userdata(value) {
    this._userdata = value;
  }
  constructor(menu, icon, caption) {
    this._clickHidesMenu = true;
    this._userdata = null;
    this._menu = menu;
    this.TR = document.createElement("TR");
    this.TR["objectData"] = this;
    this.TD_caption = document.createElement("TD");
    this.TD_caption.style.backgroundColor = ContextMenu.iconBGColor;
    this.TD_caption.style.paddingLeft = "3px";
    this.TD_caption.style.paddingRight = "3px";
    this.TD_caption.style.whiteSpace = "nowrap";
    this.TD_icon = document.createElement("TD");
    if (icon != null)
      this.TD_icon.innerHTML = icon;
    this.TD_icon.style.backgroundColor = ContextMenu.captionBgColor;
    this.A_caption = document.createElement("A");
    this.A_caption.innerHTML = caption;
    this.TR.style.cursor = "pointer";
    this.TR.tabIndex = 0;
    this.TR.style.outline = "none";
    this._TR_keydown = (e) => {
      e.preventDefault();
      this.keydown(e);
    };
    this._TR_mouseover = (e) => {
      this.mouserOver(e);
    };
    this._TR_mouseout = (e) => {
      this.mouserOut(e);
    };
    this._A_mouseover = (e) => {
      this.mouserOver(e);
    };
    this._A_mouseout = (e) => {
      this.mouserOut(e);
    };
    this._A_click = (e) => {
      this.activate();
    };
    this._TR_focusin = () => {
      this.focusIn();
    };
    this._TR_focusout = () => {
      this.focusOut();
    };
    this.TR.addEventListener("mouseover", this._TR_mouseover);
    this.TR.addEventListener("mouseout", this._TR_mouseout);
    this.TR.addEventListener("click", this._A_click);
    this.TR.addEventListener("keydown", this._TR_keydown);
    this.A_caption.addEventListener("mouseover", this._A_mouseover);
    this.A_caption.addEventListener("mouseout", this._A_mouseout);
    this.TD_caption.appendChild(this.A_caption);
    this.TR.appendChild(this.TD_icon);
    this.TR.appendChild(this.TD_caption);
    this.TR.addEventListener("focusin", this._TR_focusin);
    this.TR.addEventListener("focusout", this._TR_focusout);
  }
  toString() {
    return this.TD_caption.innerText;
  }
  get focusable() {
    return this.visible;
  }
  activate() {
  }
  focus() {
    this.TR.focus();
    this._menu.closeSubmenus();
  }
  focusIn() {
    if (this.TD_caption.style.backgroundColor == ContextMenu.iconBGColor)
      this._menu.closeSubmenus();
    this.TD_caption.style.backgroundColor = ContextMenu.ActiveColor;
    this.TD_icon.style.backgroundColor = ContextMenu.ActiveColor;
  }
  focusOut() {
    this.TD_caption.style.backgroundColor = ContextMenu.iconBGColor;
    this.TD_icon.style.backgroundColor = ContextMenu.captionBgColor;
  }
  removeAndDestroy() {
    if (this.TR.parentNode != null)
      this.TR.parentNode.removeChild(this.TR);
    this.TR.removeEventListener("keydown", this._TR_keydown);
    this.TR.removeEventListener("mouseover", this._TR_mouseover);
    this.TR.removeEventListener("mouseout", this._TR_mouseout);
    this.A_caption.removeEventListener("mouseover", this._A_mouseover);
    this.A_caption.removeEventListener("mouseout", this._A_mouseout);
    this.A_caption.removeEventListener("click", this._A_click);
    this.TR.removeEventListener("focusin", this._TR_focusin);
    this.TR.removeEventListener("focusout", this._TR_focusout);
  }
  set caption(value) {
    this.A_caption.innerHTML = value;
  }
  get caption() {
    return this.A_caption.innerHTML;
  }
  keydown(e) {
    if (e.code == "ArrowDown")
      this._menu.activateNext(this);
    if (e.code == "ArrowUp")
      this._menu.activatePrevious(this);
    if (e.code == "Enter")
      this.activate();
    if (e.code == "Escape") {
      this._menu.close();
      if (this._menu.parentMenuItem != null)
        this._menu.parentMenuItem.focus();
    }
    if (e.code == "ArrowLeft") {
      if (this._menu.parentMenuItem != null) {
        this._menu.close();
        this._menu.parentMenuItem.focus();
      }
    }
  }
  mouserOver(e) {
    this.TD_caption.style.backgroundColor = ContextMenu.ActiveColor;
    this.TD_icon.style.backgroundColor = ContextMenu.ActiveColor;
    this._menu.closeSubmenus();
  }
  mouserOut(e) {
    this.TD_caption.style.backgroundColor = ContextMenu.iconBGColor;
    this.TD_icon.style.backgroundColor = ContextMenu.captionBgColor;
  }
  get domData() {
    return this.TR;
  }
  get visible() {
    return this.TR.style.display != "none";
  }
  set visible(value) {
    this.TR.style.display = value ? "" : "none";
  }
  parentMenuisClosing() {
  }
  closeMenu(all) {
    if (all)
      this._menu.closeAll();
    else
      this._menu.close();
  }
};
var ContextMenuItem = class extends ContextMenuItemBase {
  activate() {
    if (this._clickHidesMenu)
      this.closeMenu(true);
    if (this._callback != null)
      this._callback();
  }
  constructor(menu, icon, caption, callback) {
    super(menu, icon, caption);
    this._callback = callback;
    this.TD_caption.colSpan = 2;
  }
};
var ContextMenuItemSubMenuEntry = class extends ContextMenuItem {
  constructor(menu, icon, caption, submenu) {
    super(menu, icon, caption, null);
    this.TD_caption.colSpan = 1;
    this._submenu = submenu;
    this._submenu.parentMenuItem = this;
    this._parentmenu = menu;
    this._clickHidesMenu = false;
    this.TD_arrow = document.createElement("TD");
    this.TD_arrow.style.backgroundColor = ContextMenu.iconBGColor;
    this.TD_arrow.style.textAlign = "right";
    this.TD_arrow.style.paddingRight = "3px";
    this.TD_arrow.innerHTML = "&#9654;";
    this.TR.appendChild(this.TD_arrow);
    this.A_caption.addEventListener("click", (e) => {
      this.showSubmenu();
    });
    this.A_caption.addEventListener("touchstart", (e) => {
      if (e.touches.length == 1)
        this.activate();
    });
    this._submenu.zIndex = this._parentmenu.zIndex + 1;
  }
  keydown(e) {
    super.keydown(e);
    if (e.code == "ArrowRight") {
      this.activate();
      this._submenu.focusFirst();
    }
  }
  removeAndDestroy() {
    this._submenu.close();
    this._submenu.destroy();
    super.removeAndDestroy();
  }
  activate() {
    this.showSubmenu();
  }
  get submenu() {
    return this._submenu;
  }
  showSubmenu() {
    this._submenu.zIndex = this._parentmenu.zIndex + 1;
    let x = 0;
    let y = 0;
    let it = this.TR;
    do {
      x += it.offsetLeft || 0;
      y += it.offsetTop || 0;
      it = it.offsetParent;
    } while (it);
    this._submenu.showContextMenu(x + this._parentmenu.width - 15, y + 5);
  }
  focusIn() {
    super.focusIn();
    this.TD_arrow.style.backgroundColor = ContextMenu.ActiveColor;
  }
  focusOut() {
    super.focusOut();
    this.TD_arrow.style.backgroundColor = ContextMenu.iconBGColor;
  }
  parentMenuisClosing() {
    this._submenu.close();
  }
  mouserOver(e) {
    this.focusIn();
    this._parentmenu.setDelayedAction(() => {
      if (this.visible)
        this.showSubmenu();
    });
  }
  mouserOut(e) {
    this._parentmenu.cancelDelayedAction();
    this.focusOut();
  }
};
var ContextMenuBase = class {
  get parentMenuItem() {
    return this._parentMenuItem;
  }
  set parentMenuItem(value) {
    this._parentMenuItem = value;
  }
  get userdata() {
    return this._userdata;
  }
  set userdata(value) {
    this._userdata = value;
  }
  constructor(baseSize, openCallback, fontFamily) {
    this._visible = false;
    this._zIndex = 100002;
    this._parentmenu = null;
    this._parentMenuItem = null;
    this._userdata = null;
    this._openCallback = openCallback;
    this.Menutable = document.createElement("TABLE");
    this.Menutable.style.position = "absolute";
    this.Menutable.style.border = "1px solid #808080";
    if (typeof fontFamily !== "undefined")
      this.Menutable.style.fontFamily = fontFamily;
    this.Menutable.style.fontSize = (2 * baseSize / 3).toFixed(1) + "px";
    this.Menutable.style.borderSpacing = "0";
    this.Menutable.style.boxShadow = " 4px 4px 4px 1px rgba(0,0,0,0.05)";
    this.Menutable.style.zIndex = this._zIndex.toString();
    this._timer = null;
    this.visible = false;
  }
  closeAll() {
    this.close();
    if (this._parentmenu != null)
      this._parentmenu.closeAll();
  }
  cancelDelayedAction() {
    if (this._timer != null) {
      clearTimeout(this._timer);
      this._timer = null;
    }
  }
  setDelayedAction(action) {
    this.cancelDelayedAction();
    this._timer = setTimeout(() => {
      action();
    }, 500);
  }
  get parentMenu() {
    return this._parentmenu;
  }
  destroy() {
    for (let i = 0; i < this.Menutable.childNodes.length; i++) {
      let item = this.Menutable.childNodes[i]["objectData"];
      item.removeAndDestroy();
    }
    if (this.Menutable.parentNode != null)
      this.Menutable.parentNode.removeChild(this.Menutable);
  }
  focusFirst() {
    for (let i = 0; i < this.Menutable.childNodes.length; i++) {
      let item = this.Menutable.childNodes[i]["objectData"];
      if (item.focusable) {
        item.focus();
        return;
      }
    }
  }
  toString() {
    let res = "";
    for (let i = 0; i < this.Menutable.childNodes.length; i++) {
      let item = this.Menutable.childNodes[i]["objectData"];
      res = res + item.caption + "";
    }
    return res;
  }
  isXYOnMenu(x, y) {
    if (!this.visible)
      return false;
    if (x >= this.Menutable.offsetLeft && x <= this.Menutable.offsetLeft + this.Menutable.offsetWidth && y >= this.Menutable.offsetTop && y <= this.Menutable.offsetTop + this.Menutable.offsetHeight) {
      return true;
    }
    for (let i = 0; i < this.Menutable.childNodes.length; i++) {
      let item = this.Menutable.childNodes[i]["objectData"];
      if (item instanceof ContextMenuItemSubMenuEntry) {
        if (item.submenu.isXYOnMenu(x, y))
          return true;
      }
    }
    return false;
  }
  activateNext(source) {
    let found = false;
    for (let i = 0; i < this.Menutable.childNodes.length; i++) {
      let item = this.Menutable.childNodes[i]["objectData"];
      if (item == source) {
        found = true;
      } else if (found && item.focusable) {
        item.focus();
        return;
      }
    }
  }
  activatePrevious(source) {
    let previous = null;
    for (let i = 0; i < this.Menutable.childNodes.length; i++) {
      let item = this.Menutable.childNodes[i]["objectData"];
      if (item == source) {
        if (previous != null)
          previous.focus();
        return;
      }
      if (item.focusable)
        previous = item;
    }
  }
  get width() {
    return this.Menutable.offsetWidth;
  }
  closeSubmenus() {
    this.closeSubMenusExcept(null);
  }
  get zIndex() {
    return this._zIndex;
  }
  set zIndex(value) {
    this._zIndex = value;
    this.Menutable.style.zIndex = this._zIndex.toString();
  }
  get visible() {
    return this.Menutable.style.display != "none";
  }
  set visible(value) {
    this.Menutable.style.display = value ? "" : "none";
  }
  close() {
    this.cancelDelayedAction();
    for (let i = 0; i < this.Menutable.childNodes.length; i++) {
      let item = this.Menutable.childNodes[i]["objectData"];
      item.parentMenuisClosing();
    }
    this.visible = false;
    this.closeSubmenus();
  }
  refresh() {
    let showSeparation = false;
    for (let i = 0; i < this.Menutable.childNodes.length; i++) {
      let element = this.Menutable.childNodes[i];
      if (element.className == ContextMenu.SEPARATOR_MARKER) {
        element.style.display = showSeparation ? "" : "none";
        showSeparation = false;
      } else if (element.style.display == "")
        showSeparation = true;
    }
  }
  addMenuItem(icon, caption, callback) {
    let menuItem = new ContextMenuItem(this, icon, caption, callback);
    this.Menutable.appendChild(menuItem.domData);
    return menuItem;
  }
  get menuItemsCount() {
    return this.Menutable.childNodes.length;
  }
  closeSubMenusExcept(doNotClose) {
    for (let i = 0; i < this.Menutable.childNodes.length; i++) {
      let item = this.Menutable.childNodes[i]["objectData"];
      if (item instanceof ContextMenuItemSubMenuEntry) {
        if (item.submenu != doNotClose) {
          item.submenu.close();
        }
      }
    }
  }
  subMenuisOpening(source) {
    this.closeSubMenusExcept(source);
  }
  addSubMenuItem(icon, caption, submenu) {
    submenu.zIndex = this.zIndex + 1;
    let menuItem = new ContextMenuItemSubMenuEntry(this, icon, caption, submenu);
    this.Menutable.appendChild(menuItem.domData);
    return menuItem;
  }
  clearAllContents() {
    while (this.Menutable.childNodes.length > 0) {
      let item = this.Menutable.childNodes[0]["objectData"];
      item.removeAndDestroy();
    }
  }
  AddSeparator() {
    let separator = new ContextMenuSeparator();
    this.Menutable.appendChild(separator.domData);
    return separator;
  }
  showContextMenu(x, y) {
  }
};
ContextMenuBase.SEPARATOR_MARKER = "separator";
ContextMenuBase.iconBGColor = "#fdfdfd";
ContextMenuBase.captionBgColor = "#f1f1f1";
ContextMenuBase.ActiveColor = "#c4e1ff";
var ContextSubMenu = class extends ContextMenuBase {
  constructor(baseSize, parentMenu, openCallback, fontFamily) {
    super(baseSize, openCallback, fontFamily);
    this._parentmenu = parentMenu;
    document.body.appendChild(this.Menutable);
  }
  showContextMenu(x, y) {
    if (this._parentmenu != null)
      this._parentmenu.subMenuisOpening(this);
    if (this._openCallback != null)
      this._openCallback(x, y);
    this.Menutable.style.left = x.toString() + "px";
    this.Menutable.style.top = y.toString() + "px";
    this.visible = true;
    let right = this.Menutable.offsetLeft - this.Menutable.scrollLeft + this.Menutable.offsetWidth;
    let bottom = this.Menutable.offsetTop - this.Menutable.scrollTop + this.Menutable.offsetHeight;
    if (right > window.innerWidth)
      this.Menutable.style.left = (x - (right - window.innerWidth)).toString() + "px";
    if (bottom > window.innerHeight)
      this.Menutable.style.top = (y - (bottom - window.innerHeight)).toString() + "px";
  }
};
var ContextMenu = class extends ContextMenuBase {
  constructor(baseSize, openCallback, fontFamily) {
    super(baseSize, openCallback, fontFamily);
    document.addEventListener("contextmenu", (e) => {
      let tagname = "";
      if (e.target != null && constants.RunningOnAndroid)
        tagname = e.target.tagName;
      if (tagname != "INPUT") {
        e.preventDefault();
        this.showContextMenu(e.pageX, e.pageY);
      }
    });
    document.addEventListener("dblclick", (e) => {
      if (constants.dbleClickBringsUpContextMenu)
        this.showContextMenu(e.pageX, e.pageY);
    });
    document.addEventListener("click", (e) => {
      this.click(e);
    });
    document.body.appendChild(this.Menutable);
  }
  click(e) {
    if (!this.visible)
      return;
    if (!this.isXYOnMenu(e.pageX, e.pageY)) {
      this.close();
    }
  }
  showContextMenu(x, y) {
    let z = YWindow.ConTextMenuBestZindex;
    if (z < 0)
      return;
    this.zIndex = z;
    this.Menutable.style.left = x.toString() + "px";
    this.Menutable.style.top = y.toString() + "px";
    this.visible = true;
    let right = this.Menutable.offsetLeft - this.Menutable.scrollLeft + this.Menutable.offsetWidth;
    let bottom = this.Menutable.offsetTop - this.Menutable.scrollTop + this.Menutable.offsetHeight;
    if (right > window.innerWidth)
      this.Menutable.style.left = Math.max(0, x - (right - window.innerWidth)).toString() + "px";
    if (bottom > window.innerHeight)
      this.Menutable.style.top = Math.max(0, y - (bottom - window.innerHeight)).toString() + "px";
    if (this._openCallback != null)
      this._openCallback(x, y);
    if (x <= 5 && y <= 5)
      this.focusFirst();
  }
};

// obj/full/ressources.js
var ressources = class {
  static SVGheader(size, shadowDef, title) {
    let res = '<svg  xmlns="http://www.w3.org/2000/svg" width="' + size + '" height="' + size + '" viewBox="0 0 128  128">';
    if (typeof title != "undefined")
      res = res + "<title>" + title + "</title>";
    if (shadowDef)
      res = res + '<defs><filter id="f1" x="0" y="0"><feGaussianBlur in="SourceGraphic" stdDeviation="2" /></filter></defs>';
    res = res + '<g transform="translate(0,128)"><g transform="scale(1,-1)">';
    return res;
  }
  static SVGFooter() {
    return "</g></g></svg>";
  }
  static addIconTransparency() {
    return '<g opacity="0.5">';
  }
  static addIconSrcCode() {
    return '<path d="m 8 24 L 8 40 L 24 40 L 24 56 L 40 56 L 40 40 L 56 40 L 56 24 L 40 24 L 40 8 L 24 8 L 24 24   Z" fill="#40ff40" stroke="black" stroke-width="8" stroke-linecap="round"/>';
  }
  static deleteIconSrcCode() {
    return '<path d="m 15 4 L 4 15 L 19 29 L 4 43 L 15 55 L 29 40 L 43 55 L 55 43 L 40 29 L 55 15 L 44 4 L 29 18 Z" fill="#ff4040" stroke="black" stroke-width="8" stroke-linecap="round">';
  }
  static IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, shadowcode, activeCode, title) {
    let res = ressources.SVGheader(size, shadow, title);
    if (shadow)
      res = res + '<g transform="translate(6,-6)">' + shadowcode + "</g>";
    if (semitransparent)
      res = res + ressources.addIconTransparency();
    res = res + activeCode;
    if (semitransparent)
      res = res + "</g>";
    if (addIcon)
      res = res + ressources.addIconSrcCode();
    if (deleteIcon)
      res = res + ressources.deleteIconSrcCode();
    res = res + ressources.SVGFooter();
    return res;
  }
  static GraphIcon(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="m 12 24 L 103 24 L 103 107 L 12 107 z" fill="lightgray" filter="url(#f1)" /><path d="m 112 24 L 12 24 L 12 113"  style="fill:none; stroke:lightgray; stroke-width:4px; stroke-linejoin:round;stroke-linecap:round;" filter="url(#f1)"/>', '<path d="m 12 24 L 103 24 L 103 107 L 12 107 z" fill="#ffffe9" /><line x1="43" y1="24" x2="43" y2="107" stroke="#e3e3e3" stroke-width="2" stroke-linecap="round" /><line x1="43" y1="24" x2="43" y2="107" stroke="#e3e3e3" stroke-width="2" stroke-linecap="round" /><line x1="73" y1="24" x2="73" y2="107" stroke="#e3e3e3" stroke-width="2" stroke-linecap="round" /><line x1="12" y1="51" x2="103" y2="51" stroke="#e3e3e3" stroke-width="2" stroke-linecap="round" /><line x1="12" y1="79" x2="103" y2="79" stroke="#e3e3e3" stroke-width="2" stroke-linecap="round" /><line x1="12" y1="107" x2="103" y2="107" stroke="#e3e3e3" stroke-width="2" stroke-linecap="round" /><path d="m 12 77 L 34 65 L 55 85 L 70 77 L 100 93" fill="none" stroke="#FF0000" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" /><line x1="103" y1="24" x2="103" y2="107" stroke="#e3e3e3" stroke-width="2" stroke-linecap="round" /><path d="m 112 24 L 12 24 L 12 113"  style="fill:none; stroke:black; stroke-width:4px; stroke-linejoin:round;stroke-linecap:round;"/>');
  }
  static SolidGaugeIcon(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="M 34 40 L 14 40 14 52 A 50 50 0 0 0 114 52 L  114 40 L 94 40 L 94 52 A 30 30 0 1 1  34 52 Z" style="fill:lightgray;fill-opacity=0.4;" filter="url(#f1)"/><text x="43" y="-30" fill="black" transform="scale(1,-1)" style="font: bold 24px sans-serif;fill:lightgray;fill-opacity=0.4;" filter="url(#f1)">123</text>', '<path d="M 34 40 L 14 40 14 52 A 50 50 0 0 0 114 52 L  114 40 L 94 40 L 94 52 A 30 30 0 1 1  34 52 Z" style="fill:#ffffe9; stroke:none; "/><path d="M 34 40 L 14 40 14 52 A 50 50 0 0 0 29 88 L  43 72.5   A 30 30 0 0 1  34 52 Z" style="fill:red; stroke:none;"/><path d="M 34 40 L 14 40 14 52 A 50 50 0 0 0 114 52 L  114 40 L 94 40 L 94 52 A 30 30 0 1 1  34 52 Z" style="fill:none; stroke:black; stroke-width:4px; stroke-linejoin:round;stroke-linecap:round;"/><text x="43" y="-30" fill="black" transform="scale(1,-1)" style="font: bold 24px sans-serif;">123</text>');
  }
  static RawDataIcon(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="m 16 27 L 107 27 L 107 107 L 16 107 z" fill="lightgray" filter="url(#f1)" />', '<path d="m 16 27 L 107 27 L 107 107 L 16 107 z" style="fill:#ffffe9;" /><line x1="47" y1="27" x2="47" y2="107" stroke="#e3e3e3" stroke-width="2"  /><line x1="76" y1="27" x2="76" y2="107" stroke="#e3e3e3" stroke-width="2"  /><line x1="16" y1="44" x2="107" y2="44" stroke="#e3e3e3" stroke-width="2"  /><line x1="16" y1="60" x2="107" y2="60" stroke="#e3e3e3" stroke-width="2"  /><line x1="16" y1="76" x2="107" y2="76" stroke="#e3e3e3" stroke-width="2"  /><path d="m 16 27 L 107 27 L 107 107 L 16 107 z" style="fill:none;stroke:black; stroke-width:4px; stroke-linejoin:round;" /><path d="m 19 91 L 104 91 L 104 104 L 19 104 z" style="fill:#b2b2b2; stroke:#6f6f6f; stroke-width:4px; stroke-linejoin:round;" /><line x1="47" y1="91" x2="47" y2="104" stroke="#6f6f6f" stroke-width="2"  /><line x1="76" y1="91" x2="76" y2="104" stroke="#6f6f6f" stroke-width="2"  />');
  }
  static ConfigureIcon(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="M85 85 L 102 80 L 113 91 A  41 100 45 0 0  86 71 L 37 21 A  5 11 45 1 0  21 37 L 71 86  A  41 100 45 0 0  91 113 L 80 102 Z" style="fill:lightgray;fill-opacity=0.4;" filter="url(#f1)"/>', '<path d="M85 85 L 102 80 L 113 91 A  41 100 45 0 0  86 71 L 37 21 A  5 11 45 1 0  21 37 L 71 86  A  41 100 45 0 0  91 113 L 80 102 Z" style="fill:grey; stroke:black; stroke-width:4px; stroke-linejoin:round;stroke-linecap:round;"/>');
  }
  static DigitalDisplayIcon(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="m 12 45 L 111 45 L 111 89 L 12 89 z" fill="lightgray" filter="url(#f1)" />', '<path d="m 12 45 L 111 45 L 111 89 L 12 89 z" style="fill:#ffffe9; stroke:black; stroke-width:4px; stroke-linejoin:round;" /><text x="29" y="-52" fill="black" transform="scale(1,-1)" style="font: bold 40px sans-serif;">123</text> ');
  }
  static AngularGaugeIcon(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<circle  cx="64" cy="64" r="40" fill="lightgray" filter="url(#f1)" />', '<circle  cx="64" cy="64" r="40" stroke="black" stroke-width="4" fill="#ffffe9" /><line x1="64" y1="104" x2="64" y2="94" stroke="black" stroke-width="2"   stroke-linecap="round" /><line x1="29" y1="84" x2="38" y2="79" stroke="black" stroke-width="2"   stroke-linecap="round" /><line x1="29" y1="44" x2="38" y2="48" stroke="black" stroke-width="2"   stroke-linecap="round" /><line x1="98" y1="84" x2="91" y2="79" stroke="black" stroke-width="2"   stroke-linecap="round" /><line x1="98" y1="44" x2="91" y2="48" stroke="black" stroke-width="2"   stroke-linecap="round" /><g transform="translate(64,64)"><g transform="rotate(-70,0,0)"><path d="m 5 0 L 0 5 L -25 0 L 0 -5 z" style="fill:black;stroke:black; stroke-width:2px; stroke-linejoin:round;"/></g></g>');
  }
  static EditIcon(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="m 16 48 L 108 48 L 108 88 L 16 88 z" fill="lightgray" filter="url(#f1)" /><path d="m 87 24 L 75 40 L 67 31 L 62 64 L 93 50 L 82 44  L 94 29 z" fill="lightgray" filter="url(#f1)" />', '<path d="m 16 48 L 108 48 L 108 88 L 16 88 z" style="fill:#ffffe9; stroke:black; stroke-width:4px; stroke-linejoin:round;" /><path d="m 87 24 L 75 40 L 67 31 L 62 64 L 93 50 L 82 44  L 94 29 z" style="fill:white; stroke:black; stroke-width:2px; stroke-linejoin:round;" /> ');
  }
  static AllIcon(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="m 60 108 L 46 74 L 8 72 L 38 48 L 28 12 L 60 32 L 92 12  L 82 48 L 112 70  L 74 74  z" fill="lightgray" filter="url(#f1)" />', '<path d="m 60 108 L 46 74 L 8 72 L 38 48 L 28 12 L 60 32 L 92 12  L 82 48 L 112 70  L 74 74  z" style="fill:#fee403; stroke:#918201; stroke-width:4px; stroke-linejoin:round;" />');
  }
  static TrashIcon(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="m 33 12 L 24 94 L 104 94 L 95 12 z" fill="lightgray" filter="url(#f1)" /><g transform="translate(70,105)"><g transform="rotate(-10,0,0)"><path d="m -40 0 L -30 5 L 30 5 L 40 0 z" fill="lightgray" filter="url(#f1)" /><path d="m -9 5 L -9 12 L 9 12 L 9 5" stroke="lightgray" filter="url(#f1)"/> </g></g>', '<path d="m 33 12 L 24 94 L 104 94 L 95 12 z" style="fill:#f8f8f8; stroke:black; stroke-width:4px; stroke-linejoin:round;" /><Line x1="43" y1="82" x2="48" y2="21" style=" stroke:black; stroke-width:4px; stroke-linecap:round;" /><Line x1="64" y1="82" x2="64" y2="21" style=" stroke:black; stroke-width:4px; stroke-linecap:round;" /><Line x1="86" y1="82" x2="80" y2="21" style=" stroke:black; stroke-width:4px; stroke-linecap:round;" /><g transform="translate(70,105)"><g transform="rotate(-10,0,0)"><path d="m -40 0 L -30 5 L 30 5 L 40 0 z" style="fill:#f8f8f8; stroke:black; stroke-width:4px; stroke-linejoin:round;" /><path d="m -9 5 L -9 12 L 9 12 L 9 5" style="fill:none; stroke:black; stroke-width:4px; stroke-linejoin:round;" /></g></g>');
  }
  static SaveIcon(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="m 20 12 A 4 4 0 0 0 16 16 L 16 106  A 4 4 0 0 0 20 110 L 24 110 L 24 108 L 97 108 L 97 110 L 104 110  A 4 4 0 0 0 108 106 L 108 16   A 4 4 0 0 0 104 12  z" fill="lightgray" filter="url(#f1)" />', '<path d="m 20 12 A 4 4 0 0 0 16 16 L 16 106  A 4 4 0 0 0 20 110 L 24 110 L 24 108 L 97 108 L 97 110 L 104 110  A 4 4 0 0 0 108 106 L 108 16   A 4 4 0 0 0 104 12  z" style="fill:#3583dd; stroke:#226fc8; stroke-width:4px; stroke-linejoin:round;" /><path d="m 24 11 L 24 65  A 5 5 0 0 0 29 70 L 95 70  A 5 5 0 0 0 100 65 L 100 11  z" style="fill:#f7f7f7; stroke:#c6c6c6; stroke-width:2px; stroke-linejoin:round;"/><path d="m 36 111 L 90 111 L 90 80 A 4 4 0 0 0 86 76 L 40 76 A 4 4 0 0 0 36 80 z"  style="fill:#e5e5e5; stroke:#c6c6c6; stroke-width:2px; stroke-linejoin:round;" /><rect x="67" y="79" width="14" height ="28"     style="fill:#3583dd; stroke:#c6c6c6; stroke-width:2px; stroke-linejoin:round;"');
  }
  static SaveNeededIcon(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="m 8 16 L 64 110 L 120 16 z " style="fill:lightgray; stroke:lightgray; stroke-width:10px; stroke-linejoin:round;filter:url(#f1)" />', '<path d="m 8 16 L 64 110 L 120 16 z" style="fill:#FAE701; stroke:#FAE701; stroke-width:10px; stroke-linejoin:round;" /><path d="m 8 16 L 64 110 L 120 16 z" style="fill:none; stroke:black; stroke-width:2px; stroke-linejoin:round;" /><g transform="translate(-64,-64) scale(0.4 0.4) translate(260,215)"><path d="m 20 12 A 4 4 0 0 0 16 16 L 16 106  A 4 4 0 0 0 20 110 L 24 110 L 24 108 L 97 108 L 97 110 L 104 110  A 4 4 0 0 0 108 106 L 108 16   A 4 4 0 0 0 104 12  z" style="fill:black; stroke:black; stroke-width:4px; stroke-linejoin:round;" /><path d="m 24 11 L 24 65  A 5 5 0 0 0 29 70 L 95 70  A 5 5 0 0 0 100 65 L 100 11  z" style="fill:#FAE701; stroke:black; stroke-width:2px; stroke-linejoin:round;"/><path d="m 36 111 L 90 111 L 90 80 A 4 4 0 0 0 86 76 L 40 76 A 4 4 0 0 0 36 80 z"  style="fill:#FAE701; stroke:black; stroke-width:2px; stroke-linejoin:round;" /><rect x="67" y="79" width="14" height ="28"     style="fill:#FAE701; stroke:black; stroke-width:2px; stroke-linejoin:round;"</g>', "Don't forget to save.");
  }
  static snapshotIcon(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="m 16 32  L 16 78 A 6 6 0 0 0 22 84 L 46 84 L 48 94 A 5.75 3.25 30 0 0 54 100 L 78 100 A 3.25 5.75  30 0 0 84 94  L 86 84 L 104 84  A 6 6 0 0 0 110 78  L 110 32 A 6 6 0 0 0 104 26 L 22 26 A 6 6 0 0 0 16 32 z"  fill="lightgray" filter="url(#f1)" />', '<path d="m 16 32  L 16 78 A 6 6 0 0 0 22 84 L 46 84 L 48 94 A 5.75 3.25 30 0 0 54 100 L 78 100 A 3.25 5.75  30 0 0 84 94  L 86 84 L 104 84  A 6 6 0 0 0 110 78  L 110 32 A 6 6 0 0 0 104 26 L 22 26 A 6 6 0 0 0 16 32 z" style="fill:#707070; stroke:#464646; stroke-width:4px; stroke-linejoin:round;" /><Circle cx="65" cy="55" r="26"   style="fill:#895e96; stroke:#464646; stroke-width:6px; stroke-linejoin:round;" />');
  }
  static CloseIcon(size, shadow, semitransparent, addIcon, deleteIcon, title) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="m 21.6 38.6 L 47.1 64.3 L 22 89.5 L 38.4 106.2 L 64 81 L 89.3 106.2 L 105.8 89.5 L 80.6 64 L 105.8 38.9 L 89.3 22.2 L 64 47.5  L 38.3 22.1 z"  fill="lightgray" filter="url(#f1)" />', '<path d="m 21.6 38.6 L 47.1 64.3 L 22 89.5 L 38.4 106.2 L 64 81 L 89.3 106.2 L 105.8 89.5 L 80.6 64 L 105.8 38.9 L 89.3 22.2 L 64 47.5  L 38.3 22.1 z" style="fill:#ffffff; stroke:#004a82; stroke-width:4px; stroke-linejoin:round;" />', title);
  }
  static MoveToRightIcon(size, shadow, semitransparent, addIcon, deleteIcon, title) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<rect x="12" y="52" width="4"  height="24" fill="lightgray" filter="url(#f1)" /><rect x="20" y="52" width="8"  height="24" fill="lightgray" filter="url(#f1)" /><rect x="56" y="16" width="16"  height="96" fill="lightgray" filter="url(#f1)" /><path d="m  32 52 L 32 76 L 56 76 L 56 96 L 88 64 L 56 32 L 56 52 z" fill="lightgray" filter="url(#f1)" />', '<rect x="12" y="52" width="4"  height="24" style="fill:#ffffff; stroke:#004a82; stroke-width:4px; stroke-linejoin:round;" /><rect x="20" y="52" width="8"  height="24" style="fill:#ffffff; stroke:#004a82; stroke-width:4px; stroke-linejoin:round;" /><rect x="96" y="16" width="16"  height="96" style="fill:#ffffff; stroke:#004a82; stroke-width:4px; stroke-linejoin:round;" /><path d="m  32 52 L 32 76 L 56 76 L 56 96 L 88 64 L 56 32 L 56 52 z" style="fill:#ffffff; stroke:#004a82; stroke-width:4px; stroke-linejoin:round;" />', title);
  }
  static MoveToLeftIcon(size, shadow, semitransparent, addIcon, deleteIcon, title) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<rect x="112" y="52" width="4"  height="24" fill="lightgray" filter="url(#f1)" /><rect x="100" y="52" width="8"  height="24" fill="lightgray" filter="url(#f1)" /><rect x="16" y="16" width="16"  height="96" fill="lightgray" filter="url(#f1)" /><path d="m  96 52 L 96 76 L 72 76 L 72 96 L 40 64 L 72 32 L 72 52 z" fill="lightgray" filter="url(#f1)" />', '<rect x="112" y="52" width="4"  height="24" style="fill:#ffffff; stroke:#004a82; stroke-width:4px; stroke-linejoin:round;" /><rect x="100" y="52" width="8"  height="24" style="fill:#ffffff; stroke:#004a82; stroke-width:4px; stroke-linejoin:round;" /><rect x="16" y="16" width="16"  height="96" style="fill:#ffffff; stroke:#004a82; stroke-width:4px; stroke-linejoin:round;" /><path d="m  96 52 L 96 76 L 72 76 L 72 96 L 40 64 L 72 32 L 72 52 z" style="fill:#ffffff; stroke:#004a82; stroke-width:4px; stroke-linejoin:round;" />', title);
  }
  static ExpandIcon(size, shadow, semitransparent, addIcon, deleteIcon, title) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="m  24 56 L 24 72 L 56 72 L 56 104 L 72 104 L 72 72 L 104 72 L 104 56 L 72 56 L 72 24 L 56 24 L 56 56 z"  fill="lightgray" filter="url(#f1)" />', '<path d="m 24 56 L 24 72 L 56 72 L 56 104 L 72 104 L 72 72 L 104 72 L 104 56 L 72 56 L 72 24 L 56 24 L 56 56  z" style="fill:black; " />', title);
  }
  static OkIcon(size, shadow, semitransparent, addIcon, deleteIcon, title) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<circle cx="64" cy="64" r="56"   fill="lightgray" filter="url(#f1)" />', '<circle cx="64" cy="64" r="56" fill="#00b20f"/><path d="m 19 72 L 34 87 L 60 62 L 94 96 L 109 81 L 60 32  z" style="fill:white; " />', title);
  }
  static FailedIcon(size, shadow, semitransparent, addIcon, deleteIcon, title) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<circle cx="64" cy="64" r="56"   fill="lightgray" filter="url(#f1)" />', '<circle cx="64" cy="64" r="56" fill="#ff101e"/><path d="m 43 99 L 64 79 L 85 99 L 100 85 L 79 64 L 100 43 L 85 28 L 64 49 L 43 28 L 28  43 L 49 64 L  28 85   z" style="fill:white; " />', title);
  }
  static DontKnowIcon(size, shadow, semitransparent, addIcon, deleteIcon, title) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<circle cx="64" cy="64" r="56"   fill="lightgray" filter="url(#f1)" />', '<circle cx="64" cy="64" r="56" fill="#f1ba00"/><text x="35" y="-30" fill="white" transform="scale(1,-1)" style="font: bold 96px sans-serif;">?</text> ', title);
  }
  static infoIcon(size, shadow, semitransparent, addIcon, deleteIcon, title) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<circle cx="64" cy="64" r="56"   fill="lightgray" filter="url(#f1)" />', '<circle cx="64" cy="64" r="56" fill="DodgerBlue"/><text x="50" y="-30" fill="white" transform="scale(1,-1)" style="font: bold 96px sans-serif;">i</text> ', title);
  }
  static ColapseIcon(size, shadow, semitransparent, addIcon, deleteIcon, title) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="m 24 56 L 24 72 L 104 72 L 104 56 z"  fill="lightgray" filter="url(#f1)" />', '<path d="m 24 56 L 24 72 L 104 72 L 104 56 z" style="fill:black; " />', title);
  }
  static AddMarkerIcon(size, index) {
    return ressources.IconSourceCode(size, false, false, false, false, "", '<circle  cx="64" cy="64"  r="50"   style="fill:lightyellow;" stroke-width="8" stroke="darkred" /><text x="46" y="-40" fill="black" transform="scale(1,-1)" style="font: bold 64px sans-serif;">' + index.toString() + "</text>");
  }
  static AddMarker(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, "", '<line x1="80" y1="8" x2="80" y2="128" stroke="darkred" stroke-width="8" stroke-linecap="round" /><path d="m 60 64 L 100 64 L 80 20 z" style="fill:darkred; " /><rect x="40" y="56" width="80" height="32" style="fill:lightYellow" stroke="darkred" stroke-width="8" />');
  }
  static EraseDatalogger(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, "", '<g transform="rotate(-35,0,0)"><g transform="translate(-56,24)"><path d="m 108 24 L 108 46 L 60 46  A 22 22 0 1 0 60 90 L 108 90  L 108 112 L 60 112 A 44 44 0 1 1 60 24 z" style="fill:#808080; " /><rect x="88" y="24" width="20" height="22" style="fill:red" stroke="none"  /><rect x="88" y="90" width="20" height="22" style="fill:blue" stroke="none"  /><path d="m 108 24 L 108 46 L 60 46  A 22 22 0 1 0 60 90 L 108 90  L 108 112 L 60 112 A 44 44 0 1 1 60 24 z"  style="fill:none" stroke="black"  stroke-width="4" stroke-linejoin="round"/></g></g>');
  }
  static resetViewPort(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, "", '<line x1="116" y1="52" x2="116" y2="12"  stroke="black"  stroke-width="4"/><line x1="12" y1="52" x2="12" y2="12"  stroke="black"  stroke-width="4"/><path d="m 100 36 L 28 36 L 28 48 L 12 32  L 28 16 L 28 28 L 100 28 L 100 16 L 116 32 L 100 48z" style="fill:white" stroke="black"  stroke-width="4" stroke-linejoin="round" /><path d="m 7.3 97.7 L 20 107.4 L 51.6 114.7 L 78.5 112.2 L 101.6 103.3 L 114.4 91.7  L 117.7 81.7 L 104.3 66.9 L 80.9 61.2 L49.9 65 L 25 76.3 L 12.6 87.5 Z " style="fill:white" stroke="none" /><circle  cx="64" cy="88" r="27" style="fill:#6cc87b" stroke="none"  /> <path d="m 37.2 84.8 A 27 27 0 0 0 46.5 108.8 L 64 88 z" style="fill:#8ed698" stroke="none" /> <circle  cx="64" cy="88" r="16" style="fill:black" stroke="none"  /> <path d="m 6 97 A 59 34 -4 0 0 119 80" style="fill:none" stroke="black"  stroke-width="4"  stroke-linecap="round"/> <path d="m 113 79 A 56 31 -16 0 0 9 93 " style="fill:none" stroke="black"  stroke-width="4"  stroke-linecap="round" /> ');
  }
  static DeleteMarker(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, "", '<line x1="80" y1="8" x2="80" y2="128" stroke="darkred" stroke-width="8" stroke-linecap="round" /><path d="m 60 64 L 100 64 L 80 20 z" style="fill:darkred; " /><rect x="40" y="56" width="80" height="32" style="fill:lightYellow" stroke="darkred" stroke-width="8" />');
  }
  static targetIcon(size, shadow, semitransparent, addIcon, deleteIcon, title) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, "", '<circle  cx="64" cy="64"  r="42"   style="fill:none;" stroke-width="8" stroke="black" /><line  x1="0"   y1="64"  x2="42"  y2="64"  style="fill:none;" stroke-width="8" stroke="black" /><line  x1="128" y1="64"  x2="86"  y2="64"  style="fill:none;" stroke-width="8" stroke="black" /><line  y1="0"   x1="64"  y2="42"  x2="64"  style="fill:none;" stroke-width="8" stroke="black" /><line  y1="128" x1="64"  y2="86"  x2="64"  style="fill:none;" stroke-width="8" stroke="black" />', title);
  }
  static DotDotDotIcon(size, shadow, semitransparent, addIcon, deleteIcon, title) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, "", '<rect x="18" y="36" width="18" height="18" style="fill:black" /><rect x="54" y="36" width="18" height="18" style="fill:black" /><rect x="90" y="36" width="18" height="18" style="fill:black" />', title);
  }
  static LogFileIcon(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, "", '<line x1="4" y1="24" x2="30" y2="24"     style=" stroke:black; stroke-width:8px;" /><line x1="34" y1="24" x2="56" y2="24"    style=" stroke:black; stroke-width:8px; " /><line x1="64" y1="24" x2="74" y2="24"    style=" stroke:black; stroke-width:8px; " /><line x1="80" y1="24" x2="88" y2="24"    style=" stroke:black; stroke-width:8px; " /><line x1="4" y1="40" x2="30" y2="40"     style=" stroke:black; stroke-width:8px;" /><line x1="34" y1="40" x2="56" y2="40"    style=" stroke:black; stroke-width:8px; " /><line x1="61" y1="40" x2="90" y2="40"    style=" stroke:black; stroke-width:8px; " /><line x1="94" y1="40" x2="110" y2="40"    style=" stroke:black; stroke-width:8px; " /><line x1="4" y1="56" x2="30" y2="56"     style=" stroke:black; stroke-width:8px;" /><line x1="34" y1="56" x2="56" y2="56"    style=" stroke:black; stroke-width:8px; " /><line x1="61" y1="56" x2="86" y2="56"    style=" stroke:black; stroke-width:8px; " /><line x1="4" y1="72" x2="30" y2="72"     style=" stroke:black; stroke-width:8px;" /><line x1="34" y1="72" x2="50" y2="72"    style=" stroke:black; stroke-width:8px; " /><line x1="56" y1="72" x2="100" y2="72"    style=" stroke:black; stroke-width:8px; " /><line x1="4" y1="88" x2="30" y2="88"     style=" stroke:black; stroke-width:8px;" /><line x1="34" y1="88" x2="56" y2="88"    style=" stroke:black; stroke-width:8px; " /><line x1="61" y1="88" x2="72" y2="88"    style=" stroke:black; stroke-width:8px; " /><line x1="78" y1="88" x2="106" y2="88"    style=" stroke:black; stroke-width:8px; " />');
  }
};

// obj/full/Pako/utils/common.js
var utils_common = class {
  static flattenChunks(chunks) {
    let len = 0;
    for (let i = 0, l = chunks.length; i < l; i++) {
      len += chunks[i].length;
    }
    const result = new Uint8Array(len);
    for (let i = 0, pos = 0, l = chunks.length; i < l; i++) {
      let chunk = chunks[i];
      result.set(chunk, pos);
      pos += chunk.length;
    }
    return result;
  }
};

// obj/full/Pako/utils/strings.js
var Pako_strings = class {
  static _init() {
    try {
      String.fromCharCode.apply(null, new Uint8Array(1));
    } catch (__) {
      Pako_strings.STR_APPLY_UIA_OK = false;
    }
    for (let q = 0; q < 256; q++) {
      Pako_strings._utf8len[q] = q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1;
    }
    Pako_strings._utf8len[254] = Pako_strings._utf8len[254] = 1;
    return true;
  }
  static string2buf(str) {
    let buf;
    let c;
    let c2;
    let m_pos;
    let i;
    let str_len = str.length;
    let buf_len = 0;
    for (m_pos = 0; m_pos < str_len; m_pos++) {
      c = str.charCodeAt(m_pos);
      if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
        c2 = str.charCodeAt(m_pos + 1);
        if ((c2 & 64512) === 56320) {
          c = 65536 + (c - 55296 << 10) + (c2 - 56320);
          m_pos++;
        }
      }
      buf_len += c < 128 ? 1 : c < 2048 ? 2 : c < 65536 ? 3 : 4;
    }
    buf = new Uint8Array(buf_len);
    for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
      c = str.charCodeAt(m_pos);
      if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
        c2 = str.charCodeAt(m_pos + 1);
        if ((c2 & 64512) === 56320) {
          c = 65536 + (c - 55296 << 10) + (c2 - 56320);
          m_pos++;
        }
      }
      if (c < 128) {
        buf[i++] = c;
      } else if (c < 2048) {
        buf[i++] = 192 | c >>> 6;
        buf[i++] = 128 | c & 63;
      } else if (c < 65536) {
        buf[i++] = 224 | c >>> 12;
        buf[i++] = 128 | c >>> 6 & 63;
        buf[i++] = 128 | c & 63;
      } else {
        buf[i++] = 240 | c >>> 18;
        buf[i++] = 128 | c >>> 12 & 63;
        buf[i++] = 128 | c >>> 6 & 63;
        buf[i++] = 128 | c & 63;
      }
    }
    return buf;
  }
  static buf2binstring(buf, len) {
    let result = "";
    for (let i = 0; i < len; i++) {
      result += String.fromCharCode(buf[i]);
    }
    return result;
  }
  static buf2string(buf, max) {
    let i;
    let out;
    const len = max || buf.length;
    const utf16buf = new Array(len * 2);
    for (out = 0, i = 0; i < len; ) {
      let c = buf[i++];
      if (c < 128) {
        utf16buf[out++] = c;
        continue;
      }
      let c_len = Pako_strings._utf8len[c];
      if (c_len > 4) {
        utf16buf[out++] = 65533;
        i += c_len - 1;
        continue;
      }
      c &= c_len === 2 ? 31 : c_len === 3 ? 15 : 7;
      while (c_len > 1 && i < len) {
        c = c << 6 | buf[i++] & 63;
        c_len--;
      }
      if (c_len > 1) {
        utf16buf[out++] = 65533;
        continue;
      }
      if (c < 65536) {
        utf16buf[out++] = c;
      } else {
        c -= 65536;
        utf16buf[out++] = 55296 | c >> 10 & 1023;
        utf16buf[out++] = 56320 | c & 1023;
      }
    }
    return Pako_strings.buf2binstring(utf16buf, out);
  }
  static utf8border(buf, max) {
    max = max || buf.length;
    if (max > buf.length) {
      max = buf.length;
    }
    let pos = max - 1;
    while (pos >= 0 && (buf[pos] & 192) === 128) {
      pos--;
    }
    if (pos < 0) {
      return max;
    }
    if (pos === 0) {
      return max;
    }
    return pos + Pako_strings._utf8len[buf[pos]] > max ? pos : max;
  }
};
Pako_strings.STR_APPLY_UIA_OK = true;
Pako_strings._utf8len = new Uint8Array(256);
Pako_strings.initDone = Pako_strings._init();

// obj/full/Pako/deflate.js
var Pako_deflate_option = class {
  constructor(CustOption) {
    this.level = zlib_constants.Z_DEFAULT_COMPRESSION;
    this.method = zlib_constants.Z_DEFLATED;
    this.chunkSize = 16384;
    this.windowBits = 15;
    this.memLevel = 8;
    this.strategy = zlib_constants.Z_DEFAULT_STRATEGY;
    this.raw = false;
    this.gzip = false;
    this.header = null;
    this.dictionary = null;
    this.ignore_os = false;
    Pako_deflate_option.ApplyCustomOptions(this, CustOption);
  }
  static ApplyCustomOptions(StdOption, CustOption) {
    if (typeof CustOption != "undefined") {
      let stdKeys = Object.keys(StdOption);
      let custKeys = Object.keys(CustOption);
      for (let i = 0; i < custKeys.length; i++) {
        if (stdKeys.indexOf(custKeys[i]) < 0) {
          debugger;
          throw "Invalid Pako option name '" + custKeys[i] + "', check Pako_deflate_option class";
        }
        let srcType = typeof Reflect.get(CustOption, custKeys[i]);
        let trgtType = typeof Reflect.get(StdOption, custKeys[i]);
        if (srcType != trgtType)
          throw "Invalid Pako type for option '" + custKeys[i] + "' (expected '" + trgtType + "', got '" + srcType + "')";
        Reflect.set(StdOption, custKeys[i], Reflect.get(CustOption, custKeys[i]));
      }
    }
  }
};
var Pako_Deflate = class {
  constructor(options) {
    this._dict_set = false;
    this.result = null;
    this.options = new Pako_deflate_option(options);
    let opt = this.options;
    if (opt.raw && opt.windowBits > 0) {
      opt.windowBits = -opt.windowBits;
    } else if (opt.gzip && opt.windowBits > 0 && opt.windowBits < 16) {
      opt.windowBits += 16;
    }
    this.err = 0;
    this.msg = "";
    this.ended = false;
    this.chunks = [];
    this.strm = new zlib_ZStream();
    this.strm.avail_out = 0;
    let status = zlib_deflate.deflateInit2(this.strm, opt.level, opt.method, opt.windowBits, opt.memLevel, opt.strategy);
    if (status !== zlib_constants.Z_OK) {
      throw new Error(zlib_messages.msg(status));
    }
    if (opt.header) {
      zlib_deflate.deflateSetHeader(this.strm, opt.header);
    }
    if (opt.dictionary) {
      let dict;
      if (typeof opt.dictionary === "string") {
        dict = Pako_strings.string2buf(opt.dictionary);
      } else if (toString.call(opt.dictionary) === "[object ArrayBuffer]") {
        dict = new Uint8Array(opt.dictionary);
      } else {
        dict = opt.dictionary;
      }
      status = zlib_deflate.deflateSetDictionary(this.strm, dict);
      if (status !== zlib_constants.Z_OK) {
        throw new Error(zlib_messages.msg(status));
      }
      this._dict_set = true;
    }
  }
  push(data, flush_mode) {
    const strm = this.strm;
    const chunkSize = this.options.chunkSize;
    let status;
    let _flush_mode;
    if (this.ended) {
      return false;
    }
    if (flush_mode === ~~flush_mode) {
      _flush_mode = flush_mode;
    } else {
      _flush_mode = flush_mode === true ? zlib_constants.Z_FINISH : zlib_constants.Z_NO_FLUSH;
    }
    if (typeof data === "string") {
      strm.input = Pako_strings.string2buf(data);
    } else if (toString.call(data) === "[object ArrayBuffer]") {
      strm.input = new Uint8Array(data);
    } else {
      strm.input = data;
    }
    strm.next_in = 0;
    strm.avail_in = strm.input.length;
    for (; ; ) {
      if (strm.avail_out === 0) {
        strm.output = new Uint8Array(chunkSize);
        strm.next_out = 0;
        strm.avail_out = chunkSize;
      }
      if ((_flush_mode === zlib_constants.Z_SYNC_FLUSH || _flush_mode === zlib_constants.Z_FULL_FLUSH) && strm.avail_out <= 6) {
        this.onData(strm.output.subarray(0, strm.next_out));
        strm.avail_out = 0;
        continue;
      }
      status = zlib_deflate.deflate(strm, _flush_mode);
      if (status === zlib_constants.Z_STREAM_END) {
        if (strm.next_out > 0) {
          this.onData(strm.output.subarray(0, strm.next_out));
        }
        status = zlib_deflate.deflateEnd(this.strm);
        this.onEnd(status);
        this.ended = true;
        return status === zlib_constants.Z_OK;
      }
      if (strm.avail_out === 0) {
        this.onData(strm.output);
        continue;
      }
      if (_flush_mode > 0 && strm.next_out > 0) {
        this.onData(strm.output.subarray(0, strm.next_out));
        strm.avail_out = 0;
        continue;
      }
      if (strm.avail_in === 0)
        break;
    }
    return true;
  }
  onData(chunk) {
    this.chunks.push(chunk);
  }
  onEnd(status) {
    if (status === zlib_constants.Z_OK) {
      this.result = utils_common.flattenChunks(this.chunks);
    }
    this.chunks = [];
    this.err = status;
    this.msg = this.strm.msg;
  }
  static deflate(input, options) {
    const deflator = new Pako_Deflate(options);
    deflator.push(input, true);
    if (deflator.err) {
      throw deflator.msg || zlib_messages.msg(deflator.err);
    }
    return deflator.result;
  }
  static deflateRaw(input, options) {
    options.raw = true;
    return Pako_Deflate.deflate(input, options);
  }
  static gzip(input, options) {
    if (typeof options == "undefined")
      options = {};
    options.gzip = true;
    return Pako_Deflate.deflate(input, options);
  }
};

// obj/full/Pako/inflate.js
var Pako_inflate_option = class {
  constructor(CustOption) {
    this.chunkSize = 1024 * 64;
    this.windowBits = 15;
    this.to = "";
    this.raw = false;
    this.dictionary = null;
    Pako_inflate_option.ApplyCustomOptions(this, CustOption);
  }
  static ApplyCustomOptions(StdOption, CustOption) {
    if (typeof CustOption != "undefined") {
      let stdKeys = Object.keys(StdOption);
      let custKeys = Object.keys(CustOption);
      for (let i = 0; i < custKeys.length; i++) {
        if (stdKeys.indexOf(custKeys[i]) < 0)
          throw "Invalid Pako option name '" + custKeys[i] + "', check Pako_inflate_option class";
        let srcType = typeof Reflect.get(CustOption, custKeys[i]);
        let trgtType = typeof Reflect.get(StdOption, custKeys[i]);
        if (srcType != trgtType) {
          throw "Invalid Pako type for option '" + custKeys[i] + "' (expected '" + trgtType + "', got '" + srcType + "')";
        }
        Reflect.set(StdOption, custKeys[i], Reflect.get(CustOption, custKeys[i]));
      }
    }
  }
};
var Pako_Inflate = class {
  constructor(options) {
    this.err = 0;
    this.msg = "";
    this.ended = false;
    this.result = null;
    this.options = new Pako_inflate_option(options);
    const opt = this.options;
    if (opt.raw && opt.windowBits >= 0 && opt.windowBits < 16) {
      opt.windowBits = -opt.windowBits;
      if (opt.windowBits === 0) {
        opt.windowBits = -15;
      }
    }
    if (opt.windowBits >= 0 && opt.windowBits < 16 && !(options && options.windowBits)) {
      opt.windowBits += 32;
    }
    if (opt.windowBits > 15 && opt.windowBits < 48) {
      if ((opt.windowBits & 15) === 0) {
        opt.windowBits |= 15;
      }
    }
    this.err = 0;
    this.msg = "";
    this.ended = false;
    this.chunks = [];
    this.strm = new zlib_ZStream();
    this.strm.avail_out = 0;
    let status = zlib_inflate.inflateInit2(this.strm, opt.windowBits);
    if (status !== zlib_constants.Z_OK) {
      throw new Error(zlib_messages.msg(status));
    }
    this.header = new zlib_GZheader();
    zlib_inflate.inflateGetHeader(this.strm, this.header);
    if (opt.dictionary) {
      if (typeof opt.dictionary === "string") {
        opt.dictionary = Pako_strings.string2buf(opt.dictionary);
      } else if (toString.call(opt.dictionary) === "[object ArrayBuffer]") {
        opt.dictionary = new Uint8Array(opt.dictionary);
      }
      if (opt.raw) {
        status = zlib_inflate.inflateSetDictionary(this.strm, opt.dictionary);
        if (status !== zlib_constants.Z_OK) {
          throw new Error(zlib_messages.msg(status));
        }
      }
    }
  }
  push(data, flush_mode) {
    const strm = this.strm;
    const chunkSize = this.options.chunkSize;
    const dictionary = this.options.dictionary;
    let status;
    let _flush_mode;
    let last_avail_out;
    if (this.ended)
      return false;
    if (flush_mode === ~~flush_mode) {
      _flush_mode = flush_mode;
    } else {
      _flush_mode = flush_mode === true ? zlib_constants.Z_FINISH : zlib_constants.Z_NO_FLUSH;
    }
    if (toString.call(data) === "[object ArrayBuffer]") {
      strm.input = new Uint8Array(data);
    } else {
      strm.input = data;
    }
    strm.next_in = 0;
    strm.avail_in = strm.input.length;
    for (; ; ) {
      if (strm.avail_out === 0) {
        strm.output = new Uint8Array(chunkSize);
        strm.next_out = 0;
        strm.avail_out = chunkSize;
      }
      status = zlib_inflate.inflate(strm, _flush_mode);
      if (status === zlib_constants.Z_NEED_DICT && dictionary) {
        status = zlib_inflate.inflateSetDictionary(strm, dictionary);
        if (status === zlib_constants.Z_OK) {
          status = zlib_inflate.inflate(strm, _flush_mode);
        } else if (status === zlib_constants.Z_DATA_ERROR) {
          status = zlib_constants.Z_NEED_DICT;
        }
      }
      while (strm.avail_in > 0 && status === zlib_constants.Z_STREAM_END && strm.state.wrap > 0 && data[strm.next_in] !== 0) {
        zlib_inflate.inflateReset(strm);
        status = zlib_inflate.inflate(strm, _flush_mode);
      }
      switch (status) {
        case zlib_constants.Z_STREAM_ERROR:
        case zlib_constants.Z_DATA_ERROR:
        case zlib_constants.Z_NEED_DICT:
        case zlib_constants.Z_MEM_ERROR:
          this.onEnd(status);
          this.ended = true;
          return false;
      }
      last_avail_out = strm.avail_out;
      if (strm.next_out) {
        if (strm.avail_out === 0 || status === zlib_constants.Z_STREAM_END) {
          if (this.options.to === "string") {
            let next_out_utf8 = Pako_strings.utf8border(strm.output, strm.next_out);
            let tail = strm.next_out - next_out_utf8;
            let utf8str = Pako_strings.buf2string(strm.output, next_out_utf8);
            strm.next_out = tail;
            strm.avail_out = chunkSize - tail;
            if (tail)
              strm.output.set(strm.output.subarray(next_out_utf8, next_out_utf8 + tail), 0);
            this.onData(utf8str);
          } else {
            this.onData(strm.output.length === strm.next_out ? strm.output : strm.output.subarray(0, strm.next_out));
          }
        }
      }
      if (status === zlib_constants.Z_OK && last_avail_out === 0)
        continue;
      if (status === zlib_constants.Z_STREAM_END) {
        status = zlib_inflate.inflateEnd(this.strm);
        this.onEnd(status);
        this.ended = true;
        return true;
      }
      if (strm.avail_in === 0)
        break;
    }
    return true;
  }
  onData(chunk) {
    this.chunks[this.chunks.length] = chunk;
  }
  onEnd(status) {
    if (status === zlib_constants.Z_OK) {
      if (this.options.to === "string") {
        this.result = this.chunks.join("");
      } else {
        this.result = utils_common.flattenChunks(this.chunks);
      }
    }
    this.chunks = [];
    this.err = status;
    this.msg = this.strm.msg;
  }
  static inflate(input, options) {
    const inflator = new Pako_Inflate(options);
    inflator.push(input, false);
    if (inflator.err)
      throw inflator.msg || zlib_messages.msg(inflator.err);
    return inflator.result;
  }
  inflateRaw(input, options) {
    options.raw = true;
    return Pako_Inflate.inflate(input, options);
  }
  static ungzip(input, options) {
    return Pako_Inflate.inflate(input, options);
  }
};

// obj/full/Pako/zlib/adler32.js
"use strict";
var zlib_adler32 = class {
  static adler32(adler, buf, len, pos) {
    let s1 = adler & 65535 | 0, s2 = adler >>> 16 & 65535 | 0, n = 0;
    while (len !== 0) {
      n = len > 2e3 ? 2e3 : len;
      len -= n;
      do {
        s1 = s1 + buf[pos++] | 0;
        s2 = s2 + s1 | 0;
      } while (--n);
      s1 %= 65521;
      s2 %= 65521;
    }
    return s1 | s2 << 16 | 0;
  }
};

// obj/full/Pako/zlib/constants.js
"use strict";
var zlib_constants = class {
};
zlib_constants.Z_NO_FLUSH = 0;
zlib_constants.Z_PARTIAL_FLUSH = 1;
zlib_constants.Z_SYNC_FLUSH = 2;
zlib_constants.Z_FULL_FLUSH = 3;
zlib_constants.Z_FINISH = 4;
zlib_constants.Z_BLOCK = 5;
zlib_constants.Z_TREES = 6;
zlib_constants.Z_OK = 0;
zlib_constants.Z_STREAM_END = 1;
zlib_constants.Z_NEED_DICT = 2;
zlib_constants.Z_ERRNO = -1;
zlib_constants.Z_STREAM_ERROR = -2;
zlib_constants.Z_DATA_ERROR = -3;
zlib_constants.Z_MEM_ERROR = -4;
zlib_constants.Z_BUF_ERROR = -5;
zlib_constants.Z_NO_COMPRESSION = 0;
zlib_constants.Z_BEST_SPEED = 1;
zlib_constants.Z_BEST_COMPRESSION = 9;
zlib_constants.Z_DEFAULT_COMPRESSION = -1;
zlib_constants.Z_FILTERED = 1;
zlib_constants.Z_HUFFMAN_ONLY = 2;
zlib_constants.Z_RLE = 3;
zlib_constants.Z_FIXED = 4;
zlib_constants.Z_DEFAULT_STRATEGY = 0;
zlib_constants.Z_BINARY = 0;
zlib_constants.Z_TEXT = 1;
zlib_constants.Z_UNKNOWN = 2;
zlib_constants.Z_DEFLATED = 8;

// obj/full/Pako/zlib/crc32.js
"use strict";
var zlib_crc32 = class {
  static makeTable() {
    let c;
    let table = new Int32Array(256);
    for (let n = 0; n < 256; n++) {
      c = n;
      for (let k = 0; k < 8; k++) {
        c = c & 1 ? 3988292384 ^ c >>> 1 : c >>> 1;
      }
      table[n] = c;
    }
    return table;
  }
  static crc32(crc, buf, len, pos) {
    let t = zlib_crc32.crcTable;
    let end = pos + len;
    crc ^= -1;
    for (let i = pos; i < end; i++) {
      crc = crc >>> 8 ^ t[(crc ^ buf[i]) & 255];
    }
    return crc ^ -1;
  }
};
zlib_crc32.crcTable = zlib_crc32.makeTable();

// obj/full/Pako/zlib/deflate.js
"use strict";
var zlib_config = class {
  constructor(good_length, max_lazy, nice_length, max_chain, func) {
    this.good_length = good_length;
    this.max_lazy = max_lazy;
    this.nice_length = nice_length;
    this.max_chain = max_chain;
    this.func = func;
  }
};
var zlib_DeflateState = class {
  constructor() {
    this.strm = null;
    this.status = 0;
    this.pending_buf = null;
    this.pending_buf_size = 0;
    this.pending_out = 0;
    this.pending = 0;
    this.wrap = 0;
    this.gzhead = null;
    this.gzindex = 0;
    this.method = zlib_constants.Z_DEFLATED;
    this.last_flush = -1;
    this.w_size = 0;
    this.w_bits = 0;
    this.w_mask = 0;
    this.window = null;
    this.window_size = 0;
    this.prev = null;
    this.head = null;
    this.ins_h = 0;
    this.hash_size = 0;
    this.hash_bits = 0;
    this.hash_mask = 0;
    this.hash_shift = 0;
    this.block_start = 0;
    this.match_length = 0;
    this.prev_match = 0;
    this.match_available = 0;
    this.strstart = 0;
    this.match_start = 0;
    this.lookahead = 0;
    this.prev_length = 0;
    this.max_chain_length = 0;
    this.max_lazy_match = 0;
    this.level = 0;
    this.strategy = 0;
    this.good_match = 0;
    this.nice_match = 0;
    this.dyn_ltree = new Uint16Array(zlib_Pako_trees.HEAP_SIZE * 2);
    this.dyn_dtree = new Uint16Array((2 * zlib_Pako_trees.D_CODES + 1) * 2);
    this.bl_tree = new Uint16Array((2 * zlib_Pako_trees.BL_CODES + 1) * 2);
    this.l_desc = null;
    this.d_desc = null;
    this.bl_desc = null;
    this.bl_count = new Uint16Array(zlib_Pako_trees.MAX_BITS + 1);
    this.heap = new Uint16Array(2 * zlib_Pako_trees.L_CODES + 1);
    this.heap_len = 0;
    this.heap_max = 0;
    this.depth = new Uint16Array(2 * zlib_Pako_trees.L_CODES + 1);
    this.l_buf = 0;
    this.lit_bufsize = 0;
    this.last_lit = 0;
    this.d_buf = 0;
    this.opt_len = 0;
    this.static_len = 0;
    this.matches = 0;
    this.insert = 0;
    this.bi_buf = 0;
    this.bi_valid = 0;
    zlib_Pako_trees.zero(this.dyn_ltree);
    zlib_Pako_trees.zero(this.dyn_dtree);
    zlib_Pako_trees.zero(this.bl_tree);
    zlib_Pako_trees.zero(this.heap);
    zlib_Pako_trees.zero(this.depth);
  }
};
var zlib_deflate = class {
  static err(strm, errorCode) {
    strm.msg = zlib_messages.msg(errorCode);
    return errorCode;
  }
  static rank(f) {
    return (f << 1) - (f > 4 ? 9 : 0);
  }
  zero(buf) {
    let len = buf.length;
    while (--len >= 0) {
      buf[len] = 0;
    }
  }
  static HASH_ZLIB(s, prev, data) {
    return (prev << s.hash_shift ^ data) & s.hash_mask;
  }
  static HASH(s, prev, data) {
    return (prev << s.hash_shift ^ data) & s.hash_mask;
  }
  static flush_pending(strm) {
    const s = strm.state;
    let len = s.pending;
    if (len > strm.avail_out) {
      len = strm.avail_out;
    }
    if (len === 0) {
      return;
    }
    strm.output.set(s.pending_buf.subarray(s.pending_out, s.pending_out + len), strm.next_out);
    strm.next_out += len;
    s.pending_out += len;
    strm.total_out += len;
    strm.avail_out -= len;
    s.pending -= len;
    if (s.pending === 0) {
      s.pending_out = 0;
    }
  }
  static flush_block_only(s, last) {
    zlib_Pako_trees._tr_flush_block(s, s.block_start >= 0 ? s.block_start : -1, s.strstart - s.block_start, last);
    s.block_start = s.strstart;
    zlib_deflate.flush_pending(s.strm);
  }
  static put_byte(s, b) {
    s.pending_buf[s.pending++] = b;
  }
  static putShortMSB(s, b) {
    s.pending_buf[s.pending++] = b >>> 8 & 255;
    s.pending_buf[s.pending++] = b & 255;
  }
  static read_buf(strm, buf, start, size) {
    let len = strm.avail_in;
    if (len > size) {
      len = size;
    }
    if (len === 0) {
      return 0;
    }
    strm.avail_in -= len;
    buf.set(strm.input.subarray(strm.next_in, strm.next_in + len), start);
    if (strm.state.wrap === 1) {
      strm.adler = zlib_adler32.adler32(strm.adler, buf, len, start);
    } else if (strm.state.wrap === 2) {
      strm.adler = zlib_crc32.crc32(strm.adler, buf, len, start);
    }
    strm.next_in += len;
    strm.total_in += len;
    return len;
  }
  static longest_match(s, cur_match) {
    let chain_length = s.max_chain_length;
    let scan = s.strstart;
    let match;
    let len;
    let best_len = s.prev_length;
    let nice_match = s.nice_match;
    const limit = s.strstart > s.w_size - zlib_deflate.MIN_LOOKAHEAD ? s.strstart - (s.w_size - zlib_deflate.MIN_LOOKAHEAD) : 0;
    const _win = s.window;
    const wmask = s.w_mask;
    const prev = s.prev;
    const strend = s.strstart + zlib_Pako_trees.MAX_MATCH;
    let scan_end1 = _win[scan + best_len - 1];
    let scan_end = _win[scan + best_len];
    if (s.prev_length >= s.good_match) {
      chain_length >>= 2;
    }
    if (nice_match > s.lookahead) {
      nice_match = s.lookahead;
    }
    do {
      match = cur_match;
      if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1]) {
        continue;
      }
      scan += 2;
      match++;
      do {
      } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend);
      len = zlib_Pako_trees.MAX_MATCH - (strend - scan);
      scan = strend - zlib_Pako_trees.MAX_MATCH;
      if (len > best_len) {
        s.match_start = cur_match;
        best_len = len;
        if (len >= nice_match) {
          break;
        }
        scan_end1 = _win[scan + best_len - 1];
        scan_end = _win[scan + best_len];
      }
    } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);
    if (best_len <= s.lookahead) {
      return best_len;
    }
    return s.lookahead;
  }
  static fill_window(s) {
    const _w_size = s.w_size;
    let p;
    let n;
    let m;
    let more;
    let str;
    do {
      more = s.window_size - s.lookahead - s.strstart;
      if (s.strstart >= _w_size + (_w_size - zlib_deflate.MIN_LOOKAHEAD)) {
        s.window.set(s.window.subarray(_w_size, _w_size + _w_size), 0);
        s.match_start -= _w_size;
        s.strstart -= _w_size;
        s.block_start -= _w_size;
        n = s.hash_size;
        p = n;
        do {
          m = s.head[--p];
          s.head[p] = m >= _w_size ? m - _w_size : 0;
        } while (--n);
        n = _w_size;
        p = n;
        do {
          m = s.prev[--p];
          s.prev[p] = m >= _w_size ? m - _w_size : 0;
        } while (--n);
        more += _w_size;
      }
      if (s.strm.avail_in === 0) {
        break;
      }
      n = zlib_deflate.read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
      s.lookahead += n;
      if (s.lookahead + s.insert >= zlib_Pako_trees.MIN_MATCH) {
        str = s.strstart - s.insert;
        s.ins_h = s.window[str];
        s.ins_h = zlib_deflate.HASH(s, s.ins_h, s.window[str + 1]);
        while (s.insert) {
          s.ins_h = zlib_deflate.HASH(s, s.ins_h, s.window[str + zlib_Pako_trees.MIN_MATCH - 1]);
          s.prev[str & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = str;
          str++;
          s.insert--;
          if (s.lookahead + s.insert < zlib_Pako_trees.MIN_MATCH) {
            break;
          }
        }
      }
    } while (s.lookahead < zlib_deflate.MIN_LOOKAHEAD && s.strm.avail_in !== 0);
  }
  static deflate_stored(s, flush) {
    let max_block_size = 65535;
    if (max_block_size > s.pending_buf_size - 5) {
      max_block_size = s.pending_buf_size - 5;
    }
    for (; ; ) {
      if (s.lookahead <= 1) {
        zlib_deflate.fill_window(s);
        if (s.lookahead === 0 && flush === zlib_constants.Z_NO_FLUSH) {
          return zlib_deflate.BS_NEED_MORE;
        }
        if (s.lookahead === 0) {
          break;
        }
      }
      s.strstart += s.lookahead;
      s.lookahead = 0;
      const max_start = s.block_start + max_block_size;
      if (s.strstart === 0 || s.strstart >= max_start) {
        s.lookahead = s.strstart - max_start;
        s.strstart = max_start;
        zlib_deflate.flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return zlib_deflate.BS_NEED_MORE;
        }
      }
      if (s.strstart - s.block_start >= s.w_size - zlib_deflate.MIN_LOOKAHEAD) {
        zlib_deflate.flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return zlib_deflate.BS_NEED_MORE;
        }
      }
    }
    s.insert = 0;
    if (flush === zlib_constants.Z_FINISH) {
      zlib_deflate.flush_block_only(s, true);
      if (s.strm.avail_out === 0) {
        return zlib_deflate.BS_FINISH_STARTED;
      }
      return zlib_deflate.BS_FINISH_DONE;
    }
    if (s.strstart > s.block_start) {
      zlib_deflate.flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return zlib_deflate.BS_NEED_MORE;
      }
    }
    return zlib_deflate.BS_NEED_MORE;
  }
  static deflate_slow(s, flush) {
    let hash_head;
    let bflush;
    let max_insert;
    for (; ; ) {
      if (s.lookahead < zlib_deflate.MIN_LOOKAHEAD) {
        zlib_deflate.fill_window(s);
        if (s.lookahead < zlib_deflate.MIN_LOOKAHEAD && flush === zlib_constants.Z_NO_FLUSH) {
          return zlib_deflate.BS_NEED_MORE;
        }
        if (s.lookahead === 0) {
          break;
        }
      }
      hash_head = 0;
      if (s.lookahead >= zlib_Pako_trees.MIN_MATCH) {
        s.ins_h = zlib_deflate.HASH(s, s.ins_h, s.window[s.strstart + zlib_Pako_trees.MIN_MATCH - 1]);
        hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
        s.head[s.ins_h] = s.strstart;
      }
      s.prev_length = s.match_length;
      s.prev_match = s.match_start;
      s.match_length = zlib_Pako_trees.MIN_MATCH - 1;
      if (hash_head !== 0 && s.prev_length < s.max_lazy_match && s.strstart - hash_head <= s.w_size - zlib_deflate.MIN_LOOKAHEAD) {
        s.match_length = zlib_deflate.longest_match(s, hash_head);
        if (s.match_length <= 5 && (s.strategy === zlib_constants.Z_FILTERED || s.match_length === zlib_Pako_trees.MIN_MATCH && s.strstart - s.match_start > 4096)) {
          s.match_length = zlib_Pako_trees.MIN_MATCH - 1;
        }
      }
      if (s.prev_length >= zlib_Pako_trees.MIN_MATCH && s.match_length <= s.prev_length) {
        max_insert = s.strstart + s.lookahead - zlib_Pako_trees.MIN_MATCH;
        bflush = zlib_Pako_trees._tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - zlib_Pako_trees.MIN_MATCH);
        s.lookahead -= s.prev_length - 1;
        s.prev_length -= 2;
        do {
          if (++s.strstart <= max_insert) {
            s.ins_h = zlib_deflate.HASH(s, s.ins_h, s.window[s.strstart + zlib_Pako_trees.MIN_MATCH - 1]);
            hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
            s.head[s.ins_h] = s.strstart;
          }
        } while (--s.prev_length !== 0);
        s.match_available = 0;
        s.match_length = zlib_Pako_trees.MIN_MATCH - 1;
        s.strstart++;
        if (bflush) {
          zlib_deflate.flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return zlib_deflate.BS_NEED_MORE;
          }
        }
      } else if (s.match_available) {
        bflush = zlib_Pako_trees._tr_tally(s, 0, s.window[s.strstart - 1]);
        if (bflush) {
          zlib_deflate.flush_block_only(s, false);
        }
        s.strstart++;
        s.lookahead--;
        if (s.strm.avail_out === 0) {
          return zlib_deflate.BS_NEED_MORE;
        }
      } else {
        s.match_available = 1;
        s.strstart++;
        s.lookahead--;
      }
    }
    if (s.match_available) {
      bflush = zlib_Pako_trees._tr_tally(s, 0, s.window[s.strstart - 1]);
      s.match_available = 0;
    }
    s.insert = s.strstart < zlib_Pako_trees.MIN_MATCH - 1 ? s.strstart : zlib_Pako_trees.MIN_MATCH - 1;
    if (flush === zlib_constants.Z_FINISH) {
      zlib_deflate.flush_block_only(s, true);
      if (s.strm.avail_out === 0) {
        return zlib_deflate.BS_FINISH_STARTED;
      }
      return zlib_deflate.BS_FINISH_DONE;
    }
    if (s.last_lit) {
      zlib_deflate.flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return zlib_deflate.BS_NEED_MORE;
      }
    }
    return zlib_deflate.BS_BLOCK_DONE;
  }
  static deflate_rle(s, flush) {
    let bflush;
    let prev;
    let scan;
    let strend;
    const _win = s.window;
    for (; ; ) {
      if (s.lookahead <= zlib_Pako_trees.MAX_MATCH) {
        zlib_deflate.fill_window(s);
        if (s.lookahead <= zlib_Pako_trees.MAX_MATCH && flush === zlib_constants.Z_NO_FLUSH) {
          return zlib_deflate.BS_NEED_MORE;
        }
        if (s.lookahead === 0) {
          break;
        }
      }
      s.match_length = 0;
      if (s.lookahead >= zlib_Pako_trees.MIN_MATCH && s.strstart > 0) {
        scan = s.strstart - 1;
        prev = _win[scan];
        if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
          strend = s.strstart + zlib_Pako_trees.MAX_MATCH;
          do {
          } while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);
          s.match_length = zlib_Pako_trees.MAX_MATCH - (strend - scan);
          if (s.match_length > s.lookahead) {
            s.match_length = s.lookahead;
          }
        }
      }
      if (s.match_length >= zlib_Pako_trees.MIN_MATCH) {
        bflush = zlib_Pako_trees._tr_tally(s, 1, s.match_length - zlib_Pako_trees.MIN_MATCH);
        s.lookahead -= s.match_length;
        s.strstart += s.match_length;
        s.match_length = 0;
      } else {
        bflush = zlib_Pako_trees._tr_tally(s, 0, s.window[s.strstart]);
        s.lookahead--;
        s.strstart++;
      }
      if (bflush) {
        zlib_deflate.flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return zlib_deflate.BS_NEED_MORE;
        }
      }
    }
    s.insert = 0;
    if (flush === zlib_constants.Z_FINISH) {
      zlib_deflate.flush_block_only(s, true);
      if (s.strm.avail_out === 0) {
        return zlib_deflate.BS_FINISH_STARTED;
      }
      return zlib_deflate.BS_FINISH_DONE;
    }
    if (s.last_lit) {
      zlib_deflate.flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return zlib_deflate.BS_NEED_MORE;
      }
    }
    return zlib_deflate.BS_BLOCK_DONE;
  }
  static deflate_huff(s, flush) {
    let bflush;
    for (; ; ) {
      if (s.lookahead === 0) {
        zlib_deflate.fill_window(s);
        if (s.lookahead === 0) {
          if (flush === zlib_constants.Z_NO_FLUSH) {
            return zlib_deflate.BS_NEED_MORE;
          }
          break;
        }
      }
      s.match_length = 0;
      bflush = zlib_Pako_trees._tr_tally(s, 0, s.window[s.strstart]);
      s.lookahead--;
      s.strstart++;
      if (bflush) {
        zlib_deflate.flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return zlib_deflate.BS_NEED_MORE;
        }
      }
    }
    s.insert = 0;
    if (flush === zlib_constants.Z_FINISH) {
      zlib_deflate.flush_block_only(s, true);
      if (s.strm.avail_out === 0) {
        return zlib_deflate.BS_FINISH_STARTED;
      }
      return zlib_deflate.BS_FINISH_DONE;
    }
    if (s.last_lit) {
      zlib_deflate.flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return zlib_deflate.BS_NEED_MORE;
      }
    }
    return zlib_deflate.BS_BLOCK_DONE;
  }
  static lm_init(s) {
    s.window_size = 2 * s.w_size;
    zlib_Pako_trees.zero(s.head);
    s.max_lazy_match = zlib_deflate.configuration_table[s.level].max_lazy;
    s.good_match = zlib_deflate.configuration_table[s.level].good_length;
    s.nice_match = zlib_deflate.configuration_table[s.level].nice_length;
    s.max_chain_length = zlib_deflate.configuration_table[s.level].max_chain;
    s.strstart = 0;
    s.block_start = 0;
    s.lookahead = 0;
    s.insert = 0;
    s.match_length = s.prev_length = zlib_Pako_trees.MIN_MATCH - 1;
    s.match_available = 0;
    s.ins_h = 0;
  }
  static deflateResetKeep(strm) {
    if (!strm || !strm.state) {
      return zlib_deflate.err(strm, zlib_constants.Z_STREAM_ERROR);
    }
    strm.total_in = strm.total_out = 0;
    strm.data_type = zlib_constants.Z_UNKNOWN;
    let s = strm.state;
    s.pending = 0;
    s.pending_out = 0;
    if (s.wrap < 0) {
      s.wrap = -s.wrap;
    }
    s.status = s.wrap ? zlib_deflate.INIT_STATE : zlib_deflate.BUSY_STATE;
    strm.adler = s.wrap === 2 ? 0 : 1;
    s.last_flush = zlib_constants.Z_NO_FLUSH;
    zlib_Pako_trees._tr_init(s);
    return zlib_constants.Z_OK;
  }
  static deflateReset(strm) {
    const ret = zlib_deflate.deflateResetKeep(strm);
    if (ret === zlib_constants.Z_OK) {
      zlib_deflate.lm_init(strm.state);
    }
    return ret;
  }
  static deflateSetHeader(strm, head) {
    if (!strm || !strm.state) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    if (strm.state.wrap !== 2) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    strm.state.gzhead = head;
    return zlib_constants.Z_OK;
  }
  static deflateInit2(strm, level, method, windowBits, memLevel, strategy) {
    if (!strm) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    let wrap = 1;
    if (level === zlib_constants.Z_DEFAULT_COMPRESSION) {
      level = 6;
    }
    if (windowBits < 0) {
      wrap = 0;
      windowBits = -windowBits;
    } else if (windowBits > 15) {
      wrap = 2;
      windowBits -= 16;
    }
    if (memLevel < 1 || memLevel > zlib_deflate.MAX_MEM_LEVEL || method !== zlib_constants.Z_DEFLATED || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > zlib_constants.Z_FIXED) {
      return zlib_deflate.err(strm, zlib_constants.Z_STREAM_ERROR);
    }
    if (windowBits === 8) {
      windowBits = 9;
    }
    const s = new zlib_DeflateState();
    strm.state = s;
    s.strm = strm;
    s.wrap = wrap;
    s.gzhead = null;
    s.w_bits = windowBits;
    s.w_size = 1 << s.w_bits;
    s.w_mask = s.w_size - 1;
    s.hash_bits = memLevel + 7;
    s.hash_size = 1 << s.hash_bits;
    s.hash_mask = s.hash_size - 1;
    s.hash_shift = ~~((s.hash_bits + zlib_Pako_trees.MIN_MATCH - 1) / zlib_Pako_trees.MIN_MATCH);
    s.window = new Uint8Array(s.w_size * 2);
    s.head = new Uint16Array(s.hash_size);
    s.prev = new Uint16Array(s.w_size);
    s.lit_bufsize = 1 << memLevel + 6;
    s.pending_buf_size = s.lit_bufsize * 4;
    s.pending_buf = new Uint8Array(s.pending_buf_size);
    s.d_buf = 1 * s.lit_bufsize;
    s.l_buf = (1 + 2) * s.lit_bufsize;
    s.level = level;
    s.strategy = strategy;
    s.method = method;
    return zlib_deflate.deflateReset(strm);
  }
  static deflateInit(strm, level) {
    return zlib_deflate.deflateInit2(strm, level, zlib_constants.Z_DEFLATED, zlib_deflate.MAX_WBITS, zlib_deflate.DEF_MEM_LEVEL, zlib_constants.Z_DEFAULT_STRATEGY);
  }
  static deflate(strm, flush) {
    let beg, val;
    if (!strm || !strm.state || flush > zlib_constants.Z_BLOCK || flush < 0) {
      return strm ? zlib_deflate.err(strm, zlib_constants.Z_STREAM_ERROR) : zlib_constants.Z_STREAM_ERROR;
    }
    let s = strm.state;
    if (!strm.output || !strm.input && strm.avail_in !== 0 || s.status === zlib_deflate.FINISH_STATE && flush !== zlib_constants.Z_FINISH) {
      return zlib_deflate.err(strm, strm.avail_out === 0 ? zlib_constants.Z_BUF_ERROR : zlib_constants.Z_STREAM_ERROR);
    }
    s.strm = strm;
    const old_flush = s.last_flush;
    s.last_flush = flush;
    if (s.status === zlib_deflate.INIT_STATE) {
      if (s.wrap === 2) {
        strm.adler = 0;
        zlib_deflate.put_byte(s, 31);
        zlib_deflate.put_byte(s, 139);
        zlib_deflate.put_byte(s, 8);
        if (!s.gzhead) {
          zlib_deflate.put_byte(s, 0);
          zlib_deflate.put_byte(s, 0);
          zlib_deflate.put_byte(s, 0);
          zlib_deflate.put_byte(s, 0);
          zlib_deflate.put_byte(s, 0);
          zlib_deflate.put_byte(s, s.level === 9 ? 2 : s.strategy >= zlib_constants.Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
          zlib_deflate.put_byte(s, zlib_deflate.OS_CODE);
          s.status = zlib_deflate.BUSY_STATE;
        } else {
          zlib_deflate.put_byte(s, (s.gzhead.text ? 1 : 0) + (s.gzhead.hcrc ? 2 : 0) + (!s.gzhead.extra ? 0 : 4) + (!s.gzhead.name ? 0 : 8) + (!s.gzhead.comment ? 0 : 16));
          zlib_deflate.put_byte(s, s.gzhead.time & 255);
          zlib_deflate.put_byte(s, s.gzhead.time >> 8 & 255);
          zlib_deflate.put_byte(s, s.gzhead.time >> 16 & 255);
          zlib_deflate.put_byte(s, s.gzhead.time >> 24 & 255);
          zlib_deflate.put_byte(s, s.level === 9 ? 2 : s.strategy >= zlib_constants.Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
          zlib_deflate.put_byte(s, s.gzhead.os & 255);
          if (s.gzhead.extra && s.gzhead.extra.length) {
            zlib_deflate.put_byte(s, s.gzhead.extra.length & 255);
            zlib_deflate.put_byte(s, s.gzhead.extra.length >> 8 & 255);
          }
          if (s.gzhead.hcrc) {
            strm.adler = zlib_crc32.crc32(strm.adler, s.pending_buf, s.pending, 0);
          }
          s.gzindex = 0;
          s.status = zlib_deflate.EXTRA_STATE;
        }
      } else {
        let header = zlib_constants.Z_DEFLATED + (s.w_bits - 8 << 4) << 8;
        let level_flags = -1;
        if (s.strategy >= zlib_constants.Z_HUFFMAN_ONLY || s.level < 2) {
          level_flags = 0;
        } else if (s.level < 6) {
          level_flags = 1;
        } else if (s.level === 6) {
          level_flags = 2;
        } else {
          level_flags = 3;
        }
        header |= level_flags << 6;
        if (s.strstart !== 0) {
          header |= zlib_deflate.PRESET_DICT;
        }
        header += 31 - header % 31;
        s.status = zlib_deflate.BUSY_STATE;
        zlib_deflate.putShortMSB(s, header);
        if (s.strstart !== 0) {
          zlib_deflate.putShortMSB(s, strm.adler >>> 16);
          zlib_deflate.putShortMSB(s, strm.adler & 65535);
        }
        strm.adler = 1;
      }
    }
    if (s.status === zlib_deflate.EXTRA_STATE) {
      if (s.gzhead.extra) {
        beg = s.pending;
        while (s.gzindex < (s.gzhead.extra.length & 65535)) {
          if (s.pending === s.pending_buf_size) {
            if (s.gzhead.hcrc && s.pending > beg) {
              strm.adler = zlib_crc32.crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
            }
            zlib_deflate.flush_pending(strm);
            beg = s.pending;
            if (s.pending === s.pending_buf_size) {
              break;
            }
          }
          zlib_deflate.put_byte(s, s.gzhead.extra[s.gzindex] & 255);
          s.gzindex++;
        }
        if (s.gzhead.hcrc && s.pending > beg) {
          strm.adler = zlib_crc32.crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
        }
        if (s.gzindex === s.gzhead.extra.length) {
          s.gzindex = 0;
          s.status = zlib_deflate.NAME_STATE;
        }
      } else {
        s.status = zlib_deflate.NAME_STATE;
      }
    }
    if (s.status === zlib_deflate.NAME_STATE) {
      if (s.gzhead.name) {
        beg = s.pending;
        do {
          if (s.pending === s.pending_buf_size) {
            if (s.gzhead.hcrc && s.pending > beg) {
              strm.adler = zlib_crc32.crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
            }
            zlib_deflate.flush_pending(strm);
            beg = s.pending;
            if (s.pending === s.pending_buf_size) {
              val = 1;
              break;
            }
          }
          if (s.gzindex < s.gzhead.name.length) {
            val = s.gzhead.name.charCodeAt(s.gzindex++) & 255;
          } else {
            val = 0;
          }
          zlib_deflate.put_byte(s, val);
        } while (val !== 0);
        if (s.gzhead.hcrc && s.pending > beg) {
          strm.adler = zlib_crc32.crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
        }
        if (val === 0) {
          s.gzindex = 0;
          s.status = zlib_deflate.COMMENT_STATE;
        }
      } else {
        s.status = zlib_deflate.COMMENT_STATE;
      }
    }
    if (s.status === zlib_deflate.COMMENT_STATE) {
      if (s.gzhead.comment) {
        beg = s.pending;
        do {
          if (s.pending === s.pending_buf_size) {
            if (s.gzhead.hcrc && s.pending > beg) {
              strm.adler = zlib_crc32.crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
            }
            zlib_deflate.flush_pending(strm);
            beg = s.pending;
            if (s.pending === s.pending_buf_size) {
              val = 1;
              break;
            }
          }
          if (s.gzindex < s.gzhead.comment.length) {
            val = s.gzhead.comment.charCodeAt(s.gzindex++) & 255;
          } else {
            val = 0;
          }
          zlib_deflate.put_byte(s, val);
        } while (val !== 0);
        if (s.gzhead.hcrc && s.pending > beg) {
          strm.adler = zlib_crc32.crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
        }
        if (val === 0) {
          s.status = zlib_deflate.HCRC_STATE;
        }
      } else {
        s.status = zlib_deflate.HCRC_STATE;
      }
    }
    if (s.status === zlib_deflate.HCRC_STATE) {
      if (s.gzhead.hcrc) {
        if (s.pending + 2 > s.pending_buf_size) {
          zlib_deflate.flush_pending(strm);
        }
        if (s.pending + 2 <= s.pending_buf_size) {
          zlib_deflate.put_byte(s, strm.adler & 255);
          zlib_deflate.put_byte(s, strm.adler >> 8 & 255);
          strm.adler = 0;
          s.status = zlib_deflate.BUSY_STATE;
        }
      } else {
        s.status = zlib_deflate.BUSY_STATE;
      }
    }
    if (s.pending !== 0) {
      zlib_deflate.flush_pending(strm);
      if (strm.avail_out === 0) {
        s.last_flush = -1;
        return zlib_constants.Z_OK;
      }
    } else if (strm.avail_in === 0 && zlib_deflate.rank(flush) <= zlib_deflate.rank(old_flush) && flush !== zlib_constants.Z_FINISH) {
      return zlib_deflate.err(strm, zlib_constants.Z_BUF_ERROR);
    }
    if (s.status === zlib_deflate.FINISH_STATE && strm.avail_in !== 0) {
      return zlib_deflate.err(strm, zlib_constants.Z_BUF_ERROR);
    }
    if (strm.avail_in !== 0 || s.lookahead !== 0 || flush !== zlib_constants.Z_NO_FLUSH && s.status !== zlib_deflate.FINISH_STATE) {
      let bstate = s.strategy === zlib_constants.Z_HUFFMAN_ONLY ? zlib_deflate.deflate_huff(s, flush) : s.strategy === zlib_constants.Z_RLE ? zlib_deflate.deflate_rle(s, flush) : zlib_deflate.configuration_table[s.level].func(s, flush);
      if (bstate === zlib_deflate.BS_FINISH_STARTED || bstate === zlib_deflate.BS_FINISH_DONE) {
        s.status = zlib_deflate.FINISH_STATE;
      }
      if (bstate === zlib_deflate.BS_NEED_MORE || bstate === zlib_deflate.BS_FINISH_STARTED) {
        if (strm.avail_out === 0) {
          s.last_flush = -1;
        }
        return zlib_constants.Z_OK;
      }
      if (bstate === zlib_deflate.BS_BLOCK_DONE) {
        if (flush === zlib_constants.Z_PARTIAL_FLUSH) {
          zlib_Pako_trees._tr_align(s);
        } else if (flush !== zlib_constants.Z_BLOCK) {
          zlib_Pako_trees._tr_stored_block(s, 0, 0, false);
          if (flush === zlib_constants.Z_FULL_FLUSH) {
            zlib_Pako_trees.zero(s.head);
            if (s.lookahead === 0) {
              s.strstart = 0;
              s.block_start = 0;
              s.insert = 0;
            }
          }
        }
        zlib_deflate.flush_pending(strm);
        if (strm.avail_out === 0) {
          s.last_flush = -1;
          return zlib_constants.Z_OK;
        }
      }
    }
    if (flush !== zlib_constants.Z_FINISH) {
      return zlib_constants.Z_OK;
    }
    if (s.wrap <= 0) {
      return zlib_constants.Z_STREAM_END;
    }
    if (s.wrap === 2) {
      zlib_deflate.put_byte(s, strm.adler & 255);
      zlib_deflate.put_byte(s, strm.adler >> 8 & 255);
      zlib_deflate.put_byte(s, strm.adler >> 16 & 255);
      zlib_deflate.put_byte(s, strm.adler >> 24 & 255);
      zlib_deflate.put_byte(s, strm.total_in & 255);
      zlib_deflate.put_byte(s, strm.total_in >> 8 & 255);
      zlib_deflate.put_byte(s, strm.total_in >> 16 & 255);
      zlib_deflate.put_byte(s, strm.total_in >> 24 & 255);
    } else {
      zlib_deflate.putShortMSB(s, strm.adler >>> 16);
      zlib_deflate.putShortMSB(s, strm.adler & 65535);
    }
    zlib_deflate.flush_pending(strm);
    if (s.wrap > 0) {
      s.wrap = -s.wrap;
    }
    return s.pending !== 0 ? zlib_constants.Z_OK : zlib_constants.Z_STREAM_END;
  }
  static deflateEnd(strm) {
    if (!strm || !strm.state) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    let status = strm.state.status;
    if (status !== zlib_deflate.INIT_STATE && status !== zlib_deflate.EXTRA_STATE && status !== zlib_deflate.NAME_STATE && status !== zlib_deflate.COMMENT_STATE && status !== zlib_deflate.HCRC_STATE && status !== zlib_deflate.BUSY_STATE && status !== zlib_deflate.FINISH_STATE) {
      return zlib_deflate.err(strm, zlib_constants.Z_STREAM_ERROR);
    }
    strm.state = null;
    return status === zlib_deflate.BUSY_STATE ? zlib_deflate.err(strm, zlib_constants.Z_DATA_ERROR) : zlib_constants.Z_OK;
  }
  static deflateSetDictionary(strm, dictionary) {
    let dictLength = dictionary.length;
    if (!strm || !strm.state) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    const s = strm.state;
    const wrap = s.wrap;
    if (wrap === 2 || wrap === 1 && s.status !== zlib_deflate.INIT_STATE || s.lookahead) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    if (wrap === 1) {
      strm.adler = zlib_adler32.adler32(strm.adler, dictionary, dictLength, 0);
    }
    s.wrap = 0;
    if (dictLength >= s.w_size) {
      if (wrap === 0) {
        zlib_Pako_trees.zero(s.head);
        s.strstart = 0;
        s.block_start = 0;
        s.insert = 0;
      }
      let tmpDict = new Uint8Array(s.w_size);
      tmpDict.set(dictionary.subarray(dictLength - s.w_size, dictLength), 0);
      dictionary = tmpDict;
      dictLength = s.w_size;
    }
    const avail = strm.avail_in;
    const next = strm.next_in;
    const input = strm.input;
    strm.avail_in = dictLength;
    strm.next_in = 0;
    strm.input = dictionary;
    zlib_deflate.fill_window(s);
    while (s.lookahead >= zlib_Pako_trees.MIN_MATCH) {
      let str = s.strstart;
      let n = s.lookahead - (zlib_Pako_trees.MIN_MATCH - 1);
      do {
        s.ins_h = zlib_deflate.HASH(s, s.ins_h, s.window[str + zlib_Pako_trees.MIN_MATCH - 1]);
        s.prev[str & s.w_mask] = s.head[s.ins_h];
        s.head[s.ins_h] = str;
        str++;
      } while (--n);
      s.strstart = str;
      s.lookahead = zlib_Pako_trees.MIN_MATCH - 1;
      zlib_deflate.fill_window(s);
    }
    s.strstart += s.lookahead;
    s.block_start = s.strstart;
    s.insert = s.lookahead;
    s.lookahead = 0;
    s.match_length = s.prev_length = zlib_Pako_trees.MIN_MATCH - 1;
    s.match_available = 0;
    strm.next_in = next;
    strm.input = input;
    strm.avail_in = avail;
    s.wrap = wrap;
    return zlib_constants.Z_OK;
  }
};
zlib_deflate.MAX_MEM_LEVEL = 9;
zlib_deflate.MAX_WBITS = 15;
zlib_deflate.DEF_MEM_LEVEL = 8;
zlib_deflate.LENGTH_CODES = 29;
zlib_deflate.LITERALS = 256;
zlib_deflate.L_CODES = zlib_deflate.LITERALS + 1 + zlib_deflate.LENGTH_CODES;
zlib_deflate.D_CODES = 30;
zlib_deflate.BL_CODES = 19;
zlib_deflate.HEAP_SIZE = 2 * zlib_deflate.L_CODES + 1;
zlib_deflate.MAX_BITS = 15;
zlib_deflate.MIN_MATCH = 3;
zlib_deflate.MAX_MATCH = 258;
zlib_deflate.MIN_LOOKAHEAD = zlib_deflate.MAX_MATCH + zlib_deflate.MIN_MATCH + 1;
zlib_deflate.PRESET_DICT = 32;
zlib_deflate.INIT_STATE = 42;
zlib_deflate.EXTRA_STATE = 69;
zlib_deflate.NAME_STATE = 73;
zlib_deflate.COMMENT_STATE = 91;
zlib_deflate.HCRC_STATE = 103;
zlib_deflate.BUSY_STATE = 113;
zlib_deflate.FINISH_STATE = 666;
zlib_deflate.BS_NEED_MORE = 1;
zlib_deflate.BS_BLOCK_DONE = 2;
zlib_deflate.BS_FINISH_STARTED = 3;
zlib_deflate.BS_FINISH_DONE = 4;
zlib_deflate.OS_CODE = 3;
zlib_deflate.deflate_fast = (s, flush) => {
  let hash_head;
  let bflush;
  for (; ; ) {
    if (s.lookahead < zlib_deflate.MIN_LOOKAHEAD) {
      zlib_deflate.fill_window(s);
      if (s.lookahead < zlib_deflate.MIN_LOOKAHEAD && flush === zlib_constants.Z_NO_FLUSH) {
        return zlib_deflate.BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break;
      }
    }
    hash_head = 0;
    if (s.lookahead >= zlib_Pako_trees.MIN_MATCH) {
      s.ins_h = zlib_deflate.HASH(s, s.ins_h, s.window[s.strstart + zlib_Pako_trees.MIN_MATCH - 1]);
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
    }
    if (hash_head !== 0 && s.strstart - hash_head <= s.w_size - zlib_deflate.MIN_LOOKAHEAD) {
      s.match_length = zlib_deflate.longest_match(s, hash_head);
    }
    if (s.match_length >= zlib_Pako_trees.MIN_MATCH) {
      bflush = zlib_Pako_trees._tr_tally(s, s.strstart - s.match_start, s.match_length - zlib_Pako_trees.MIN_MATCH);
      s.lookahead -= s.match_length;
      if (s.match_length <= s.max_lazy_match && s.lookahead >= zlib_Pako_trees.MIN_MATCH) {
        s.match_length--;
        do {
          s.strstart++;
          s.ins_h = zlib_deflate.HASH(s, s.ins_h, s.window[s.strstart + zlib_Pako_trees.MIN_MATCH - 1]);
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
        } while (--s.match_length !== 0);
        s.strstart++;
      } else {
        s.strstart += s.match_length;
        s.match_length = 0;
        s.ins_h = s.window[s.strstart];
        s.ins_h = zlib_deflate.HASH(s, s.ins_h, s.window[s.strstart + 1]);
      }
    } else {
      bflush = zlib_Pako_trees._tr_tally(s, 0, s.window[s.strstart]);
      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      zlib_deflate.flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return zlib_deflate.BS_NEED_MORE;
      }
    }
  }
  s.insert = s.strstart < zlib_Pako_trees.MIN_MATCH - 1 ? s.strstart : zlib_Pako_trees.MIN_MATCH - 1;
  if (flush === zlib_constants.Z_FINISH) {
    zlib_deflate.flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return zlib_deflate.BS_FINISH_STARTED;
    }
    return zlib_deflate.BS_FINISH_DONE;
  }
  if (s.last_lit) {
    zlib_deflate.flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return zlib_deflate.BS_NEED_MORE;
    }
  }
  return zlib_deflate.BS_BLOCK_DONE;
};
zlib_deflate.configuration_table = [
  new zlib_config(0, 0, 0, 0, zlib_deflate.deflate_stored),
  new zlib_config(4, 4, 8, 4, zlib_deflate.deflate_fast),
  new zlib_config(4, 5, 16, 8, zlib_deflate.deflate_fast),
  new zlib_config(4, 6, 32, 32, zlib_deflate.deflate_fast),
  new zlib_config(4, 4, 16, 16, zlib_deflate.deflate_slow),
  new zlib_config(8, 16, 32, 32, zlib_deflate.deflate_slow),
  new zlib_config(8, 16, 128, 128, zlib_deflate.deflate_slow),
  new zlib_config(8, 32, 128, 256, zlib_deflate.deflate_slow),
  new zlib_config(32, 128, 258, 1024, zlib_deflate.deflate_slow),
  new zlib_config(32, 258, 258, 4096, zlib_deflate.deflate_slow)
];

// obj/full/Pako/zlib/trees.js
"use strict";
var zlib_StaticTreeDesc = class {
  constructor(static_tree, extra_bits, extra_base, elems, max_length) {
    this.static_tree = static_tree;
    this.extra_bits = extra_bits;
    this.extra_base = extra_base;
    this.elems = elems;
    this.max_length = max_length;
    this.has_stree = static_tree != null && static_tree.length > 0;
  }
};
var zlib_TreeDesc = class {
  constructor(dyn_tree, stat_desc) {
    this.max_code = 0;
    this.dyn_tree = dyn_tree;
    this.max_code = 0;
    this.stat_desc = stat_desc;
  }
};
var zlib_Pako_trees = class {
  static zero(buf) {
    let len = buf.length;
    while (--len >= 0) {
      buf[len] = 0;
    }
  }
  static Zeroinit() {
    zlib_Pako_trees.zero(zlib_Pako_trees.static_ltree);
    zlib_Pako_trees.zero(zlib_Pako_trees.base_dist);
    zlib_Pako_trees.zero(zlib_Pako_trees.base_length);
    zlib_Pako_trees.zero(zlib_Pako_trees._length_code);
    zlib_Pako_trees.zero(zlib_Pako_trees._dist_code);
    zlib_Pako_trees.zero(zlib_Pako_trees.static_dtree);
    return true;
  }
  static d_code(dist) {
    return dist < 256 ? zlib_Pako_trees._dist_code[dist] : zlib_Pako_trees._dist_code[256 + (dist >>> 7)];
  }
  static put_short(s, w) {
    s.pending_buf[s.pending++] = w & 255;
    s.pending_buf[s.pending++] = w >>> 8 & 255;
  }
  static send_code(s, c, tree) {
    zlib_Pako_trees.send_bits(s, tree[c * 2], tree[c * 2 + 1]);
  }
  static bi_reverse(code, len) {
    let res = 0;
    do {
      res |= code & 1;
      code >>>= 1;
      res <<= 1;
    } while (--len > 0);
    return res >>> 1;
  }
  static bi_flush(s) {
    if (s.bi_valid === 16) {
      zlib_Pako_trees.put_short(s, s.bi_buf);
      s.bi_buf = 0;
      s.bi_valid = 0;
    } else if (s.bi_valid >= 8) {
      s.pending_buf[s.pending++] = s.bi_buf & 255;
      s.bi_buf >>= 8;
      s.bi_valid -= 8;
    }
  }
  static gen_codes(tree, max_code, bl_count) {
    const next_code = new Array(zlib_Pako_trees.MAX_BITS + 1);
    let code = 0;
    let bits;
    let n;
    for (bits = 1; bits <= zlib_Pako_trees.MAX_BITS; bits++) {
      next_code[bits] = code = code + bl_count[bits - 1] << 1;
    }
    for (n = 0; n <= max_code; n++) {
      let len = tree[n * 2 + 1];
      if (len === 0) {
        continue;
      }
      tree[n * 2] = zlib_Pako_trees.bi_reverse(next_code[len]++, len);
    }
  }
  static tr_static_init() {
    let n;
    let bits;
    let length;
    let code;
    let dist;
    const bl_count = new Uint16Array(zlib_Pako_trees.MAX_BITS + 1);
    length = 0;
    for (code = 0; code < zlib_Pako_trees.LENGTH_CODES - 1; code++) {
      zlib_Pako_trees.base_length[code] = length;
      for (n = 0; n < 1 << zlib_Pako_trees.extra_lbits[code]; n++) {
        zlib_Pako_trees._length_code[length++] = code;
      }
    }
    zlib_Pako_trees._length_code[length - 1] = code;
    dist = 0;
    for (code = 0; code < 16; code++) {
      zlib_Pako_trees.base_dist[code] = dist;
      for (n = 0; n < 1 << zlib_Pako_trees.extra_dbits[code]; n++) {
        zlib_Pako_trees._dist_code[dist++] = code;
      }
    }
    dist >>= 7;
    for (; code < zlib_Pako_trees.D_CODES; code++) {
      zlib_Pako_trees.base_dist[code] = dist << 7;
      for (n = 0; n < 1 << zlib_Pako_trees.extra_dbits[code] - 7; n++) {
        zlib_Pako_trees._dist_code[256 + dist++] = code;
      }
    }
    for (bits = 0; bits <= zlib_Pako_trees.MAX_BITS; bits++) {
      bl_count[bits] = 0;
    }
    n = 0;
    while (n <= 143) {
      zlib_Pako_trees.static_ltree[n * 2 + 1] = 8;
      n++;
      bl_count[8]++;
    }
    while (n <= 255) {
      zlib_Pako_trees.static_ltree[n * 2 + 1] = 9;
      n++;
      bl_count[9]++;
    }
    while (n <= 279) {
      zlib_Pako_trees.static_ltree[n * 2 + 1] = 7;
      n++;
      bl_count[7]++;
    }
    while (n <= 287) {
      zlib_Pako_trees.static_ltree[n * 2 + 1] = 8;
      n++;
      bl_count[8]++;
    }
    zlib_Pako_trees.gen_codes(zlib_Pako_trees.static_ltree, zlib_Pako_trees.L_CODES + 1, bl_count);
    for (n = 0; n < zlib_Pako_trees.D_CODES; n++) {
      zlib_Pako_trees.static_dtree[n * 2 + 1] = 5;
      zlib_Pako_trees.static_dtree[n * 2] = zlib_Pako_trees.bi_reverse(n, 5);
    }
    zlib_Pako_trees.static_l_desc = new zlib_StaticTreeDesc(zlib_Pako_trees.static_ltree, zlib_Pako_trees.extra_lbits, zlib_Pako_trees.LITERALS + 1, zlib_Pako_trees.L_CODES, zlib_Pako_trees.MAX_BITS);
    zlib_Pako_trees.static_d_desc = new zlib_StaticTreeDesc(zlib_Pako_trees.static_dtree, zlib_Pako_trees.extra_dbits, 0, zlib_Pako_trees.D_CODES, zlib_Pako_trees.MAX_BITS);
    zlib_Pako_trees.static_bl_desc = new zlib_StaticTreeDesc(new Uint16Array(0), zlib_Pako_trees.extra_blbits, 0, zlib_Pako_trees.BL_CODES, zlib_Pako_trees.MAX_BL_BITS);
  }
  static init_block(s) {
    let n;
    for (n = 0; n < zlib_Pako_trees.L_CODES; n++) {
      s.dyn_ltree[n * 2] = 0;
    }
    for (n = 0; n < zlib_Pako_trees.D_CODES; n++) {
      s.dyn_dtree[n * 2] = 0;
    }
    for (n = 0; n < zlib_Pako_trees.BL_CODES; n++) {
      s.bl_tree[n * 2] = 0;
    }
    s.dyn_ltree[zlib_Pako_trees.END_BLOCK * 2] = 1;
    s.opt_len = s.static_len = 0;
    s.last_lit = s.matches = 0;
  }
  static bi_windup(s) {
    if (s.bi_valid > 8) {
      zlib_Pako_trees.put_short(s, s.bi_buf);
    } else if (s.bi_valid > 0) {
      s.pending_buf[s.pending++] = s.bi_buf;
    }
    s.bi_buf = 0;
    s.bi_valid = 0;
  }
  static copy_block(s, buf, len, header) {
    zlib_Pako_trees.bi_windup(s);
    if (header) {
      zlib_Pako_trees.put_short(s, len);
      zlib_Pako_trees.put_short(s, ~len);
    }
    s.pending_buf.set(s.window.subarray(buf, buf + len), s.pending);
    s.pending += len;
  }
  static smaller(tree, n, m, depth) {
    const _n2 = n * 2;
    const _m2 = m * 2;
    return tree[_n2] < tree[_m2] || tree[_n2] === tree[_m2] && depth[n] <= depth[m];
  }
  static pqdownheap(s, tree, k) {
    const v = s.heap[k];
    let j = k << 1;
    while (j <= s.heap_len) {
      if (j < s.heap_len && zlib_Pako_trees.smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
        j++;
      }
      if (zlib_Pako_trees.smaller(tree, v, s.heap[j], s.depth)) {
        break;
      }
      s.heap[k] = s.heap[j];
      k = j;
      j <<= 1;
    }
    s.heap[k] = v;
  }
  static compress_block(s, ltree, dtree) {
    let dist;
    let lc;
    let lx = 0;
    let code;
    let extra;
    if (s.last_lit !== 0) {
      do {
        dist = s.pending_buf[s.d_buf + lx * 2] << 8 | s.pending_buf[s.d_buf + lx * 2 + 1];
        lc = s.pending_buf[s.l_buf + lx];
        lx++;
        if (dist === 0) {
          zlib_Pako_trees.send_code(s, lc, ltree);
        } else {
          code = zlib_Pako_trees._length_code[lc];
          zlib_Pako_trees.send_code(s, code + zlib_Pako_trees.LITERALS + 1, ltree);
          extra = zlib_Pako_trees.extra_lbits[code];
          if (extra !== 0) {
            lc -= zlib_Pako_trees.base_length[code];
            zlib_Pako_trees.send_bits(s, lc, extra);
          }
          dist--;
          code = zlib_Pako_trees.d_code(dist);
          zlib_Pako_trees.send_code(s, code, dtree);
          extra = zlib_Pako_trees.extra_dbits[code];
          if (extra !== 0) {
            dist -= zlib_Pako_trees.base_dist[code];
            zlib_Pako_trees.send_bits(s, dist, extra);
          }
        }
      } while (lx < s.last_lit);
    }
    zlib_Pako_trees.send_code(s, zlib_Pako_trees.END_BLOCK, ltree);
  }
  static build_tree(s, desc) {
    const tree = desc.dyn_tree;
    const stree = desc.stat_desc.static_tree;
    const has_stree = desc.stat_desc.has_stree;
    const elems = desc.stat_desc.elems;
    let n, m;
    let max_code = -1;
    let node;
    s.heap_len = 0;
    s.heap_max = zlib_Pako_trees.HEAP_SIZE;
    for (n = 0; n < elems; n++) {
      if (tree[n * 2] !== 0) {
        s.heap[++s.heap_len] = max_code = n;
        s.depth[n] = 0;
      } else {
        tree[n * 2 + 1] = 0;
      }
    }
    while (s.heap_len < 2) {
      node = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0;
      tree[node * 2] = 1;
      s.depth[node] = 0;
      s.opt_len--;
      if (has_stree) {
        s.static_len -= stree[node * 2 + 1];
      }
    }
    desc.max_code = max_code;
    for (n = s.heap_len >> 1; n >= 1; n--) {
      zlib_Pako_trees.pqdownheap(s, tree, n);
    }
    node = elems;
    do {
      n = s.heap[1];
      s.heap[1] = s.heap[s.heap_len--];
      zlib_Pako_trees.pqdownheap(s, tree, 1);
      m = s.heap[1];
      s.heap[--s.heap_max] = n;
      s.heap[--s.heap_max] = m;
      tree[node * 2] = tree[n * 2] + tree[m * 2];
      s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
      tree[n * 2 + 1] = tree[m * 2 + 1] = node;
      s.heap[1] = node++;
      zlib_Pako_trees.pqdownheap(s, tree, 1);
    } while (s.heap_len >= 2);
    s.heap[--s.heap_max] = s.heap[1];
    zlib_Pako_trees.gen_bitlen(s, desc);
    zlib_Pako_trees.gen_codes(tree, max_code, s.bl_count);
  }
  static scan_tree(s, tree, max_code) {
    let n;
    let prevlen = -1;
    let curlen;
    let nextlen = tree[0 * 2 + 1];
    let count = 0;
    let max_count = 7;
    let min_count = 4;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    }
    tree[(max_code + 1) * 2 + 1] = 65535;
    for (n = 0; n <= max_code; n++) {
      curlen = nextlen;
      nextlen = tree[(n + 1) * 2 + 1];
      if (++count < max_count && curlen === nextlen) {
        continue;
      } else if (count < min_count) {
        s.bl_tree[curlen * 2] += count;
      } else if (curlen !== 0) {
        if (curlen !== prevlen) {
          s.bl_tree[curlen * 2]++;
        }
        s.bl_tree[zlib_Pako_trees.REP_3_6 * 2]++;
      } else if (count <= 10) {
        s.bl_tree[zlib_Pako_trees.REPZ_3_10 * 2]++;
      } else {
        s.bl_tree[zlib_Pako_trees.REPZ_11_138 * 2]++;
      }
      count = 0;
      prevlen = curlen;
      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      } else if (curlen === nextlen) {
        max_count = 6;
        min_count = 3;
      } else {
        max_count = 7;
        min_count = 4;
      }
    }
  }
  static send_tree(s, tree, max_code) {
    let n;
    let prevlen = -1;
    let curlen;
    let nextlen = tree[0 * 2 + 1];
    let count = 0;
    let max_count = 7;
    let min_count = 4;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    }
    for (n = 0; n <= max_code; n++) {
      curlen = nextlen;
      nextlen = tree[(n + 1) * 2 + 1];
      if (++count < max_count && curlen === nextlen) {
        continue;
      } else if (count < min_count) {
        do {
          zlib_Pako_trees.send_code(s, curlen, s.bl_tree);
        } while (--count !== 0);
      } else if (curlen !== 0) {
        if (curlen !== prevlen) {
          zlib_Pako_trees.send_code(s, curlen, s.bl_tree);
          count--;
        }
        zlib_Pako_trees.send_code(s, zlib_Pako_trees.REP_3_6, s.bl_tree);
        zlib_Pako_trees.send_bits(s, count - 3, 2);
      } else if (count <= 10) {
        zlib_Pako_trees.send_code(s, zlib_Pako_trees.REPZ_3_10, s.bl_tree);
        zlib_Pako_trees.send_bits(s, count - 3, 3);
      } else {
        zlib_Pako_trees.send_code(s, zlib_Pako_trees.REPZ_11_138, s.bl_tree);
        zlib_Pako_trees.send_bits(s, count - 11, 7);
      }
      count = 0;
      prevlen = curlen;
      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      } else if (curlen === nextlen) {
        max_count = 6;
        min_count = 3;
      } else {
        max_count = 7;
        min_count = 4;
      }
    }
  }
  static build_bl_tree(s) {
    let max_blindex;
    zlib_Pako_trees.scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
    zlib_Pako_trees.scan_tree(s, s.dyn_dtree, s.d_desc.max_code);
    zlib_Pako_trees.build_tree(s, s.bl_desc);
    for (max_blindex = zlib_Pako_trees.BL_CODES - 1; max_blindex >= 3; max_blindex--) {
      if (s.bl_tree[zlib_Pako_trees.bl_order[max_blindex] * 2 + 1] !== 0) {
        break;
      }
    }
    s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
    return max_blindex;
  }
  static send_all_trees(s, lcodes, dcodes, blcodes) {
    let rank;
    zlib_Pako_trees.send_bits(s, lcodes - 257, 5);
    zlib_Pako_trees.send_bits(s, dcodes - 1, 5);
    zlib_Pako_trees.send_bits(s, blcodes - 4, 4);
    for (rank = 0; rank < blcodes; rank++) {
      zlib_Pako_trees.send_bits(s, s.bl_tree[zlib_Pako_trees.bl_order[rank] * 2 + 1], 3);
    }
    zlib_Pako_trees.send_tree(s, s.dyn_ltree, lcodes - 1);
    zlib_Pako_trees.send_tree(s, s.dyn_dtree, dcodes - 1);
  }
  static detect_data_type(s) {
    let black_mask = 4093624447;
    let n;
    for (n = 0; n <= 31; n++, black_mask >>>= 1) {
      if (black_mask & 1 && s.dyn_ltree[n * 2] !== 0) {
        return zlib_constants.Z_BINARY;
      }
    }
    if (s.dyn_ltree[9 * 2] !== 0 || s.dyn_ltree[10 * 2] !== 0 || s.dyn_ltree[13 * 2] !== 0) {
      return zlib_constants.Z_TEXT;
    }
    for (n = 32; n < zlib_Pako_trees.LITERALS; n++) {
      if (s.dyn_ltree[n * 2] !== 0) {
        return zlib_constants.Z_TEXT;
      }
    }
    return zlib_constants.Z_BINARY;
  }
  static _tr_init(s) {
    if (!zlib_Pako_trees.static_init_done) {
      zlib_Pako_trees.tr_static_init();
      zlib_Pako_trees.static_init_done = true;
    }
    s.l_desc = new zlib_TreeDesc(s.dyn_ltree, zlib_Pako_trees.static_l_desc);
    s.d_desc = new zlib_TreeDesc(s.dyn_dtree, zlib_Pako_trees.static_d_desc);
    s.bl_desc = new zlib_TreeDesc(s.bl_tree, zlib_Pako_trees.static_bl_desc);
    s.bi_buf = 0;
    s.bi_valid = 0;
    zlib_Pako_trees.init_block(s);
  }
  static _tr_stored_block(s, buf, stored_len, last) {
    zlib_Pako_trees.send_bits(s, (zlib_Pako_trees.STORED_BLOCK << 1) + (last ? 1 : 0), 3);
    zlib_Pako_trees.copy_block(s, buf, stored_len, true);
  }
  static _tr_align(s) {
    zlib_Pako_trees.send_bits(s, zlib_Pako_trees.STATIC_TREES << 1, 3);
    zlib_Pako_trees.send_code(s, zlib_Pako_trees.END_BLOCK, zlib_Pako_trees.static_ltree);
    zlib_Pako_trees.bi_flush(s);
  }
  static _tr_flush_block(s, buf, stored_len, last) {
    let opt_lenb;
    let static_lenb;
    let max_blindex = 0;
    if (s.level > 0) {
      if (s.strm.data_type === zlib_constants.Z_UNKNOWN) {
        s.strm.data_type = zlib_Pako_trees.detect_data_type(s);
      }
      zlib_Pako_trees.build_tree(s, s.l_desc);
      zlib_Pako_trees.build_tree(s, s.d_desc);
      max_blindex = zlib_Pako_trees.build_bl_tree(s);
      opt_lenb = s.opt_len + 3 + 7 >>> 3;
      static_lenb = s.static_len + 3 + 7 >>> 3;
      if (static_lenb <= opt_lenb) {
        opt_lenb = static_lenb;
      }
    } else {
      opt_lenb = static_lenb = stored_len + 5;
    }
    if (stored_len + 4 <= opt_lenb && buf !== -1) {
      zlib_Pako_trees._tr_stored_block(s, buf, stored_len, last);
    } else if (s.strategy === zlib_constants.Z_FIXED || static_lenb === opt_lenb) {
      zlib_Pako_trees.send_bits(s, (zlib_Pako_trees.STATIC_TREES << 1) + (last ? 1 : 0), 3);
      zlib_Pako_trees.compress_block(s, zlib_Pako_trees.static_ltree, zlib_Pako_trees.static_dtree);
    } else {
      zlib_Pako_trees.send_bits(s, (zlib_Pako_trees.DYN_TREES << 1) + (last ? 1 : 0), 3);
      zlib_Pako_trees.send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
      zlib_Pako_trees.compress_block(s, s.dyn_ltree, s.dyn_dtree);
    }
    zlib_Pako_trees.init_block(s);
    if (last) {
      zlib_Pako_trees.bi_windup(s);
    }
  }
  static _tr_tally(s, dist, lc) {
    s.pending_buf[s.d_buf + s.last_lit * 2] = dist >>> 8 & 255;
    s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 255;
    s.pending_buf[s.l_buf + s.last_lit] = lc & 255;
    s.last_lit++;
    if (dist === 0) {
      s.dyn_ltree[lc * 2]++;
    } else {
      s.matches++;
      dist--;
      s.dyn_ltree[(zlib_Pako_trees._length_code[lc] + zlib_Pako_trees.LITERALS + 1) * 2]++;
      s.dyn_dtree[zlib_Pako_trees.d_code(dist) * 2]++;
    }
    return s.last_lit === s.lit_bufsize - 1;
  }
};
zlib_Pako_trees.Z_FIXED = 4;
zlib_Pako_trees.Z_BINARY = 0;
zlib_Pako_trees.Z_TEXT = 1;
zlib_Pako_trees.Z_UNKNOWN = 2;
zlib_Pako_trees.STORED_BLOCK = 0;
zlib_Pako_trees.STATIC_TREES = 1;
zlib_Pako_trees.DYN_TREES = 2;
zlib_Pako_trees.MIN_MATCH = 3;
zlib_Pako_trees.MAX_MATCH = 258;
zlib_Pako_trees.LENGTH_CODES = 29;
zlib_Pako_trees.LITERALS = 256;
zlib_Pako_trees.L_CODES = zlib_Pako_trees.LITERALS + 1 + zlib_Pako_trees.LENGTH_CODES;
zlib_Pako_trees.D_CODES = 30;
zlib_Pako_trees.BL_CODES = 19;
zlib_Pako_trees.HEAP_SIZE = 2 * zlib_Pako_trees.L_CODES + 1;
zlib_Pako_trees.MAX_BITS = 15;
zlib_Pako_trees.Buf_size = 16;
zlib_Pako_trees.MAX_BL_BITS = 7;
zlib_Pako_trees.END_BLOCK = 256;
zlib_Pako_trees.REP_3_6 = 16;
zlib_Pako_trees.REPZ_3_10 = 17;
zlib_Pako_trees.REPZ_11_138 = 18;
zlib_Pako_trees.extra_lbits = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0]);
zlib_Pako_trees.extra_dbits = new Uint8Array([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]);
zlib_Pako_trees.extra_blbits = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7]);
zlib_Pako_trees.bl_order = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
zlib_Pako_trees.DIST_CODE_LEN = 512;
zlib_Pako_trees.static_ltree = new Uint16Array((zlib_Pako_trees.L_CODES + 2) * 2);
zlib_Pako_trees.static_dtree = new Uint16Array(zlib_Pako_trees.D_CODES * 2);
zlib_Pako_trees._dist_code = new Uint16Array(zlib_Pako_trees.DIST_CODE_LEN);
zlib_Pako_trees._length_code = new Uint16Array(zlib_Pako_trees.MAX_MATCH - zlib_Pako_trees.MIN_MATCH + 1);
zlib_Pako_trees.base_length = new Uint16Array(zlib_Pako_trees.LENGTH_CODES);
zlib_Pako_trees.base_dist = new Uint16Array(zlib_Pako_trees.D_CODES);
zlib_Pako_trees.send_bits = (s, value, length) => {
  if (s.bi_valid > zlib_Pako_trees.Buf_size - length) {
    s.bi_buf |= value << s.bi_valid & 65535;
    zlib_Pako_trees.put_short(s, s.bi_buf);
    s.bi_buf = value >> zlib_Pako_trees.Buf_size - s.bi_valid;
    s.bi_valid += length - zlib_Pako_trees.Buf_size;
  } else {
    s.bi_buf |= value << s.bi_valid & 65535;
    s.bi_valid += length;
  }
};
zlib_Pako_trees.gen_bitlen = (s, desc) => {
  const tree = desc.dyn_tree;
  const max_code = desc.max_code;
  const stree = desc.stat_desc.static_tree;
  const has_stree = desc.stat_desc.has_stree;
  const extra = desc.stat_desc.extra_bits;
  const base = desc.stat_desc.extra_base;
  const max_length = desc.stat_desc.max_length;
  let h;
  let n, m;
  let bits;
  let xbits;
  let f;
  let overflow = 0;
  for (bits = 0; bits <= zlib_Pako_trees.MAX_BITS; bits++) {
    s.bl_count[bits] = 0;
  }
  tree[s.heap[s.heap_max] * 2 + 1] = 0;
  for (h = s.heap_max + 1; h < zlib_Pako_trees.HEAP_SIZE; h++) {
    n = s.heap[h];
    bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;
    if (bits > max_length) {
      bits = max_length;
      overflow++;
    }
    tree[n * 2 + 1] = bits;
    if (n > max_code) {
      continue;
    }
    s.bl_count[bits]++;
    xbits = 0;
    if (n >= base) {
      xbits = extra[n - base];
    }
    f = tree[n * 2];
    s.opt_len += f * (bits + xbits);
    if (has_stree) {
      s.static_len += f * (stree[n * 2 + 1] + xbits);
    }
  }
  if (overflow === 0) {
    return;
  }
  do {
    bits = max_length - 1;
    while (s.bl_count[bits] === 0) {
      bits--;
    }
    s.bl_count[bits]--;
    s.bl_count[bits + 1] += 2;
    s.bl_count[max_length]--;
    overflow -= 2;
  } while (overflow > 0);
  for (bits = max_length; bits !== 0; bits--) {
    n = s.bl_count[bits];
    while (n !== 0) {
      m = s.heap[--h];
      if (m > max_code) {
        continue;
      }
      if (tree[m * 2 + 1] !== bits) {
        s.opt_len += (bits - tree[m * 2 + 1]) * tree[m * 2];
        tree[m * 2 + 1] = bits;
      }
      n--;
    }
  }
};
zlib_Pako_trees.static_init_done = false;
zlib_Pako_trees.initDone = zlib_Pako_trees.Zeroinit();

// obj/full/Pako/zlib/gzheader.js
"use strict";
var zlib_GZheader = class {
  constructor() {
    this.text = 0;
    this.time = 0;
    this.xflags = 0;
    this.os = 0;
    this.extra = null;
    this.extra_len = 0;
    this.name = "";
    this.comment = "";
    this.hcrc = 0;
    this.done = false;
  }
};

// obj/full/Pako/zlib/inffast.js
"use strict";
var zlib_inffast = class {
  static inflate_fast(strm, start) {
    let _in;
    let last;
    let _out;
    let beg;
    let end;
    let wsize;
    let whave;
    let wnext;
    let s_window;
    let hold;
    let bits;
    let lcode;
    let dcode;
    let lmask;
    let dmask;
    let here;
    let op;
    let len;
    let dist;
    let from;
    let from_source;
    let input;
    let output;
    let state = strm.state;
    _in = strm.next_in;
    input = strm.input;
    last = _in + (strm.avail_in - 5);
    _out = strm.next_out;
    output = strm.output;
    beg = _out - (start - strm.avail_out);
    end = _out + (strm.avail_out - 257);
    wsize = state.wsize;
    whave = state.whave;
    wnext = state.wnext;
    s_window = state.window;
    hold = state.hold;
    bits = state.bits;
    lcode = state.lencode;
    dcode = state.distcode;
    lmask = (1 << state.lenbits) - 1;
    dmask = (1 << state.distbits) - 1;
    top:
      do {
        if (bits < 15) {
          hold += input[_in++] << bits;
          bits += 8;
          hold += input[_in++] << bits;
          bits += 8;
        }
        here = lcode[hold & lmask];
        dolen:
          for (; ; ) {
            op = here >>> 24;
            hold >>>= op;
            bits -= op;
            op = here >>> 16 & 255;
            if (op === 0) {
              output[_out++] = here & 65535;
            } else if (op & 16) {
              len = here & 65535;
              op &= 15;
              if (op) {
                if (bits < op) {
                  hold += input[_in++] << bits;
                  bits += 8;
                }
                len += hold & (1 << op) - 1;
                hold >>>= op;
                bits -= op;
              }
              if (bits < 15) {
                hold += input[_in++] << bits;
                bits += 8;
                hold += input[_in++] << bits;
                bits += 8;
              }
              here = dcode[hold & dmask];
              dodist:
                for (; ; ) {
                  op = here >>> 24;
                  hold >>>= op;
                  bits -= op;
                  op = here >>> 16 & 255;
                  if (op & 16) {
                    dist = here & 65535;
                    op &= 15;
                    if (bits < op) {
                      hold += input[_in++] << bits;
                      bits += 8;
                      if (bits < op) {
                        hold += input[_in++] << bits;
                        bits += 8;
                      }
                    }
                    dist += hold & (1 << op) - 1;
                    hold >>>= op;
                    bits -= op;
                    op = _out - beg;
                    if (dist > op) {
                      op = dist - op;
                      if (op > whave) {
                        if (state.sane) {
                          strm.msg = "invalid distance too far back";
                          state.mode = zlib_inffast.BAD;
                          break top;
                        }
                      }
                      from = 0;
                      from_source = s_window;
                      if (wnext === 0) {
                        from += wsize - op;
                        if (op < len) {
                          len -= op;
                          do {
                            output[_out++] = s_window[from++];
                          } while (--op);
                          from = _out - dist;
                          from_source = output;
                        }
                      } else if (wnext < op) {
                        from += wsize + wnext - op;
                        op -= wnext;
                        if (op < len) {
                          len -= op;
                          do {
                            output[_out++] = s_window[from++];
                          } while (--op);
                          from = 0;
                          if (wnext < len) {
                            op = wnext;
                            len -= op;
                            do {
                              output[_out++] = s_window[from++];
                            } while (--op);
                            from = _out - dist;
                            from_source = output;
                          }
                        }
                      } else {
                        from += wnext - op;
                        if (op < len) {
                          len -= op;
                          do {
                            output[_out++] = s_window[from++];
                          } while (--op);
                          from = _out - dist;
                          from_source = output;
                        }
                      }
                      while (len > 2) {
                        output[_out++] = from_source[from++];
                        output[_out++] = from_source[from++];
                        output[_out++] = from_source[from++];
                        len -= 3;
                      }
                      if (len) {
                        output[_out++] = from_source[from++];
                        if (len > 1) {
                          output[_out++] = from_source[from++];
                        }
                      }
                    } else {
                      from = _out - dist;
                      do {
                        output[_out++] = output[from++];
                        output[_out++] = output[from++];
                        output[_out++] = output[from++];
                        len -= 3;
                      } while (len > 2);
                      if (len) {
                        output[_out++] = output[from++];
                        if (len > 1) {
                          output[_out++] = output[from++];
                        }
                      }
                    }
                  } else if ((op & 64) === 0) {
                    here = dcode[(here & 65535) + (hold & (1 << op) - 1)];
                    continue dodist;
                  } else {
                    strm.msg = "invalid distance code";
                    state.mode = zlib_inffast.BAD;
                    break top;
                  }
                  break;
                }
            } else if ((op & 64) === 0) {
              here = lcode[(here & 65535) + (hold & (1 << op) - 1)];
              continue dolen;
            } else if (op & 32) {
              state.mode = zlib_inffast.TYPE;
              break top;
            } else {
              strm.msg = "invalid literal/length code";
              state.mode = zlib_inffast.BAD;
              break top;
            }
            break;
          }
      } while (_in < last && _out < end);
    len = bits >> 3;
    _in -= len;
    bits -= len << 3;
    hold &= (1 << bits) - 1;
    strm.next_in = _in;
    strm.next_out = _out;
    strm.avail_in = _in < last ? 5 + (last - _in) : 5 - (_in - last);
    strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);
    state.hold = hold;
    state.bits = bits;
    return;
  }
};
zlib_inffast.BAD = 30;
zlib_inffast.TYPE = 12;

// obj/full/Pako/zlib/inflate.js
"use strict";
var zlib_InflateState = class {
  constructor() {
    this.mode = 0;
    this.last = 0;
    this.wrap = 0;
    this.havedict = 0;
    this.flags = 0;
    this.dmax = 0;
    this.check = 0;
    this.total = 0;
    this.head = null;
    this.wbits = 0;
    this.wsize = 0;
    this.whave = 0;
    this.wnext = 0;
    this.window = null;
    this.hold = 0;
    this.bits = 0;
    this.length = 0;
    this.offset = 0;
    this.extra = 0;
    this.lencode = null;
    this.distcode = null;
    this.lenbits = 0;
    this.distbits = 0;
    this.ncode = 0;
    this.nlen = 0;
    this.ndist = 0;
    this.have = 0;
    this.next = null;
    this.lens = new Uint16Array(320);
    this.work = new Uint16Array(288);
    this.lendyn = null;
    this.distdyn = null;
    this.sane = 0;
    this.back = 0;
    this.was = 0;
  }
};
var zlib_inflate = class {
  static zswap32(q) {
    return (q >>> 24 & 255) + (q >>> 8 & 65280) + ((q & 65280) << 8) + ((q & 255) << 24);
  }
  static inflateResetKeep(strm) {
    if (!strm || !strm.state) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    let state = strm.state;
    strm.total_in = strm.total_out = state.total = 0;
    strm.msg = "";
    if (state.wrap) {
      strm.adler = state.wrap & 1;
    }
    state.mode = zlib_inflate.HEAD;
    state.last = 0;
    state.havedict = 0;
    state.dmax = 32768;
    state.head = null;
    state.hold = 0;
    state.bits = 0;
    state.lencode = state.lendyn = new Int32Array(zlib_inflate.ENOUGH_LENS);
    state.distcode = state.distdyn = new Int32Array(zlib_inflate.ENOUGH_DISTS);
    state.sane = 1;
    state.back = -1;
    return zlib_constants.Z_OK;
  }
  static inflateReset(strm) {
    if (!strm || !strm.state) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    const state = strm.state;
    state.wsize = 0;
    state.whave = 0;
    state.wnext = 0;
    return zlib_inflate.inflateResetKeep(strm);
  }
  static inflateReset2(strm, windowBits) {
    let wrap;
    if (!strm || !strm.state) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    let state = strm.state;
    if (windowBits < 0) {
      wrap = 0;
      windowBits = -windowBits;
    } else {
      wrap = (windowBits >> 4) + 1;
      if (windowBits < 48) {
        windowBits &= 15;
      }
    }
    if (windowBits && (windowBits < 8 || windowBits > 15)) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    if (state.window !== null && state.wbits !== windowBits) {
      state.window = null;
    }
    state.wrap = wrap;
    state.wbits = windowBits;
    return zlib_inflate.inflateReset(strm);
  }
  static inflateInit2(strm, windowBits) {
    if (!strm) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    let state = new zlib_InflateState();
    strm.state = state;
    state.window = null;
    const ret = zlib_inflate.inflateReset2(strm, windowBits);
    if (ret !== zlib_constants.Z_OK) {
      strm.state = null;
    }
    return ret;
  }
  static inflateInit(strm) {
    return zlib_inflate.inflateInit2(strm, zlib_inflate.DEF_WBITS);
  }
  static fixedtables(state) {
    if (zlib_inflate.virgin) {
      zlib_inflate.lenfix = new Int32Array(512);
      zlib_inflate.distfix = new Int32Array(32);
      let sym = 0;
      while (sym < 144) {
        state.lens[sym++] = 8;
      }
      while (sym < 256) {
        state.lens[sym++] = 9;
      }
      while (sym < 280) {
        state.lens[sym++] = 7;
      }
      while (sym < 288) {
        state.lens[sym++] = 8;
      }
      zlib_inftrees.inflate_table(zlib_inflate.LENS, state.lens, 0, 288, zlib_inflate.lenfix, 0, state.work, {bits: 9});
      sym = 0;
      while (sym < 32) {
        state.lens[sym++] = 5;
      }
      zlib_inftrees.inflate_table(zlib_inflate.DISTS, state.lens, 0, 32, zlib_inflate.distfix, 0, state.work, {bits: 5});
      zlib_inflate.virgin = false;
    }
    state.lencode = zlib_inflate.lenfix;
    state.lenbits = 9;
    state.distcode = zlib_inflate.distfix;
    state.distbits = 5;
  }
  static updatewindow(strm, src, end, copy) {
    let dist;
    const state = strm.state;
    if (state.window === null) {
      state.wsize = 1 << state.wbits;
      state.wnext = 0;
      state.whave = 0;
      state.window = new Uint8Array(state.wsize);
    }
    if (copy >= state.wsize) {
      state.window.set(src.subarray(end - state.wsize, end), 0);
      state.wnext = 0;
      state.whave = state.wsize;
    } else {
      dist = state.wsize - state.wnext;
      if (dist > copy) {
        dist = copy;
      }
      state.window.set(src.subarray(end - copy, end - copy + dist), state.wnext);
      copy -= dist;
      if (copy) {
        state.window.set(src.subarray(end - copy, end), 0);
        state.wnext = copy;
        state.whave = state.wsize;
      } else {
        state.wnext += dist;
        if (state.wnext === state.wsize) {
          state.wnext = 0;
        }
        if (state.whave < state.wsize) {
          state.whave += dist;
        }
      }
    }
    return 0;
  }
  static inflate(strm, flush) {
    let state;
    let input, output;
    let next;
    let put;
    let have, left;
    let hold;
    let bits;
    let _in;
    let _out;
    let copy;
    let from;
    let from_source;
    let here = 0;
    let here_bits;
    let here_op;
    let here_val;
    let last_bits;
    let last_op;
    let last_val;
    let len;
    let ret;
    const hbuf = new Uint8Array(4);
    let opts;
    let n;
    let order = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
    if (!strm || !strm.state || !strm.output || !strm.input && strm.avail_in !== 0) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    state = strm.state;
    if (state.mode === zlib_inflate.TYPE) {
      state.mode = zlib_inflate.TYPEDO;
    }
    put = strm.next_out;
    output = strm.output;
    left = strm.avail_out;
    next = strm.next_in;
    input = strm.input;
    have = strm.avail_in;
    hold = state.hold;
    bits = state.bits;
    _in = have;
    _out = left;
    ret = zlib_constants.Z_OK;
    inf_leave:
      for (; ; ) {
        switch (state.mode) {
          case zlib_inflate.HEAD:
            if (state.wrap === 0) {
              state.mode = zlib_inflate.TYPEDO;
              break;
            }
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (state.wrap & 2 && hold === 35615) {
              state.check = 0;
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              state.check = zlib_crc32.crc32(state.check, hbuf, 2, 0);
              hold = 0;
              bits = 0;
              state.mode = zlib_inflate.FLAGS;
              break;
            }
            state.flags = 0;
            if (state.head) {
              state.head.done = false;
            }
            if (!(state.wrap & 1) || (((hold & 255) << 8) + (hold >> 8)) % 31) {
              strm.msg = "incorrect header check";
              state.mode = zlib_inflate.BAD;
              break;
            }
            if ((hold & 15) !== zlib_constants.Z_DEFLATED) {
              strm.msg = "unknown compression method";
              state.mode = zlib_inflate.BAD;
              break;
            }
            hold >>>= 4;
            bits -= 4;
            len = (hold & 15) + 8;
            if (state.wbits === 0) {
              state.wbits = len;
            } else if (len > state.wbits) {
              strm.msg = "invalid window size";
              state.mode = zlib_inflate.BAD;
              break;
            }
            state.dmax = 1 << state.wbits;
            strm.adler = state.check = 1;
            state.mode = hold & 512 ? zlib_inflate.DICTID : zlib_inflate.TYPE;
            hold = 0;
            bits = 0;
            break;
          case zlib_inflate.FLAGS:
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.flags = hold;
            if ((state.flags & 255) !== zlib_constants.Z_DEFLATED) {
              strm.msg = "unknown compression method";
              state.mode = zlib_inflate.BAD;
              break;
            }
            if (state.flags & 57344) {
              strm.msg = "unknown header flags set";
              state.mode = zlib_inflate.BAD;
              break;
            }
            if (state.head) {
              state.head.text = hold >> 8 & 1;
            }
            if (state.flags & 512) {
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              state.check = zlib_crc32.crc32(state.check, hbuf, 2, 0);
            }
            hold = 0;
            bits = 0;
            state.mode = zlib_inflate.TIME;
          case zlib_inflate.TIME:
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (state.head) {
              state.head.time = hold;
            }
            if (state.flags & 512) {
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              hbuf[2] = hold >>> 16 & 255;
              hbuf[3] = hold >>> 24 & 255;
              state.check = zlib_crc32.crc32(state.check, hbuf, 4, 0);
            }
            hold = 0;
            bits = 0;
            state.mode = zlib_inflate.OS;
          case zlib_inflate.OS:
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (state.head) {
              state.head.xflags = hold & 255;
              state.head.os = hold >> 8;
            }
            if (state.flags & 512) {
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              state.check = zlib_crc32.crc32(state.check, hbuf, 2, 0);
            }
            hold = 0;
            bits = 0;
            state.mode = zlib_inflate.EXLEN;
          case zlib_inflate.EXLEN:
            if (state.flags & 1024) {
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.length = hold;
              if (state.head) {
                state.head.extra_len = hold;
              }
              if (state.flags & 512) {
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                state.check = zlib_crc32.crc32(state.check, hbuf, 2, 0);
              }
              hold = 0;
              bits = 0;
            } else if (state.head) {
              state.head.extra = null;
            }
            state.mode = zlib_inflate.EXTRA;
          case zlib_inflate.EXTRA:
            if (state.flags & 1024) {
              copy = state.length;
              if (copy > have) {
                copy = have;
              }
              if (copy) {
                if (state.head) {
                  len = state.head.extra_len - state.length;
                  if (!state.head.extra) {
                    state.head.extra = new Uint8Array(state.head.extra_len);
                  }
                  state.head.extra.set(input.subarray(next, next + copy), len);
                }
                if (state.flags & 512) {
                  state.check = zlib_crc32.crc32(state.check, input, copy, next);
                }
                have -= copy;
                next += copy;
                state.length -= copy;
              }
              if (state.length) {
                break inf_leave;
              }
            }
            state.length = 0;
            state.mode = zlib_inflate.NAME;
          case zlib_inflate.NAME:
            if (state.flags & 2048) {
              if (have === 0) {
                break inf_leave;
              }
              copy = 0;
              do {
                len = input[next + copy++];
                if (state.head && len && state.length < 65536) {
                  state.head.name += String.fromCharCode(len);
                }
              } while (len && copy < have);
              if (state.flags & 512) {
                state.check = zlib_crc32.crc32(state.check, input, copy, next);
              }
              have -= copy;
              next += copy;
              if (len) {
                break inf_leave;
              }
            } else if (state.head) {
              state.head.name = null;
            }
            state.length = 0;
            state.mode = zlib_inflate.COMMENT;
          case zlib_inflate.COMMENT:
            if (state.flags & 4096) {
              if (have === 0) {
                break inf_leave;
              }
              copy = 0;
              do {
                len = input[next + copy++];
                if (state.head && len && state.length < 65536) {
                  state.head.comment += String.fromCharCode(len);
                }
              } while (len && copy < have);
              if (state.flags & 512) {
                state.check = zlib_crc32.crc32(state.check, input, copy, next);
              }
              have -= copy;
              next += copy;
              if (len) {
                break inf_leave;
              }
            } else if (state.head) {
              state.head.comment = null;
            }
            state.mode = zlib_inflate.HCRC;
          case zlib_inflate.HCRC:
            if (state.flags & 512) {
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (hold !== (state.check & 65535)) {
                strm.msg = "header crc mismatch";
                state.mode = zlib_inflate.BAD;
                break;
              }
              hold = 0;
              bits = 0;
            }
            if (state.head) {
              state.head.hcrc = state.flags >> 9 & 1;
              state.head.done = true;
            }
            strm.adler = state.check = 0;
            state.mode = zlib_inflate.TYPE;
            break;
          case zlib_inflate.DICTID:
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            strm.adler = state.check = zlib_inflate.zswap32(hold);
            hold = 0;
            bits = 0;
            state.mode = zlib_inflate.DICT;
          case zlib_inflate.DICT:
            if (!state.havedict) {
              strm.next_out = put;
              strm.avail_out = left;
              strm.next_in = next;
              strm.avail_in = have;
              state.hold = hold;
              state.bits = bits;
              return zlib_constants.Z_NEED_DICT;
            }
            strm.adler = state.check = 1;
            state.mode = zlib_inflate.TYPE;
          case zlib_inflate.TYPE:
            if (flush === zlib_constants.Z_BLOCK || flush === zlib_constants.Z_TREES) {
              break inf_leave;
            }
          case zlib_inflate.TYPEDO:
            if (state.last) {
              hold >>>= bits & 7;
              bits -= bits & 7;
              state.mode = zlib_inflate.CHECK;
              break;
            }
            while (bits < 3) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.last = hold & 1;
            hold >>>= 1;
            bits -= 1;
            switch (hold & 3) {
              case 0:
                state.mode = zlib_inflate.STORED;
                break;
              case 1:
                zlib_inflate.fixedtables(state);
                state.mode = zlib_inflate.LEN_;
                if (flush === zlib_constants.Z_TREES) {
                  hold >>>= 2;
                  bits -= 2;
                  break inf_leave;
                }
                break;
              case 2:
                state.mode = zlib_inflate.TABLE;
                break;
              case 3:
                strm.msg = "invalid block type";
                state.mode = zlib_inflate.BAD;
            }
            hold >>>= 2;
            bits -= 2;
            break;
          case zlib_inflate.STORED:
            hold >>>= bits & 7;
            bits -= bits & 7;
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if ((hold & 65535) !== (hold >>> 16 ^ 65535)) {
              strm.msg = "invalid stored block lengths";
              state.mode = zlib_inflate.BAD;
              break;
            }
            state.length = hold & 65535;
            hold = 0;
            bits = 0;
            state.mode = zlib_inflate.COPY_;
            if (flush === zlib_constants.Z_TREES) {
              break inf_leave;
            }
          case zlib_inflate.COPY_:
            state.mode = zlib_inflate.COPY;
          case zlib_inflate.COPY:
            copy = state.length;
            if (copy) {
              if (copy > have) {
                copy = have;
              }
              if (copy > left) {
                copy = left;
              }
              if (copy === 0) {
                break inf_leave;
              }
              output.set(input.subarray(next, next + copy), put);
              have -= copy;
              next += copy;
              left -= copy;
              put += copy;
              state.length -= copy;
              break;
            }
            state.mode = zlib_inflate.TYPE;
            break;
          case zlib_inflate.TABLE:
            while (bits < 14) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.nlen = (hold & 31) + 257;
            hold >>>= 5;
            bits -= 5;
            state.ndist = (hold & 31) + 1;
            hold >>>= 5;
            bits -= 5;
            state.ncode = (hold & 15) + 4;
            hold >>>= 4;
            bits -= 4;
            if (state.nlen > 286 || state.ndist > 30) {
              strm.msg = "too many length or distance symbols";
              state.mode = zlib_inflate.BAD;
              break;
            }
            state.have = 0;
            state.mode = zlib_inflate.LENLENS;
          case zlib_inflate.LENLENS:
            while (state.have < state.ncode) {
              while (bits < 3) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.lens[order[state.have++]] = hold & 7;
              hold >>>= 3;
              bits -= 3;
            }
            while (state.have < 19) {
              state.lens[order[state.have++]] = 0;
            }
            state.lencode = state.lendyn;
            state.lenbits = 7;
            opts = {bits: state.lenbits};
            ret = zlib_inftrees.inflate_table(zlib_inflate.CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
            state.lenbits = opts.bits;
            if (ret) {
              strm.msg = "invalid code lengths set";
              state.mode = zlib_inflate.BAD;
              break;
            }
            state.have = 0;
            state.mode = zlib_inflate.CODELENS;
          case zlib_inflate.CODELENS:
            while (state.have < state.nlen + state.ndist) {
              for (; ; ) {
                here = state.lencode[hold & (1 << state.lenbits) - 1];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (here_val < 16) {
                hold >>>= here_bits;
                bits -= here_bits;
                state.lens[state.have++] = here_val;
              } else {
                if (here_val === 16) {
                  n = here_bits + 2;
                  while (bits < n) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  hold >>>= here_bits;
                  bits -= here_bits;
                  if (state.have === 0) {
                    strm.msg = "invalid bit length repeat";
                    state.mode = zlib_inflate.BAD;
                    break;
                  }
                  len = state.lens[state.have - 1];
                  copy = 3 + (hold & 3);
                  hold >>>= 2;
                  bits -= 2;
                } else if (here_val === 17) {
                  n = here_bits + 3;
                  while (bits < n) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  hold >>>= here_bits;
                  bits -= here_bits;
                  len = 0;
                  copy = 3 + (hold & 7);
                  hold >>>= 3;
                  bits -= 3;
                } else {
                  n = here_bits + 7;
                  while (bits < n) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  hold >>>= here_bits;
                  bits -= here_bits;
                  len = 0;
                  copy = 11 + (hold & 127);
                  hold >>>= 7;
                  bits -= 7;
                }
                if (state.have + copy > state.nlen + state.ndist) {
                  strm.msg = "invalid bit length repeat";
                  state.mode = zlib_inflate.BAD;
                  break;
                }
                while (copy--) {
                  state.lens[state.have++] = len;
                }
              }
            }
            if (state.mode === zlib_inflate.BAD) {
              break;
            }
            if (state.lens[256] === 0) {
              strm.msg = "invalid code -- missing end-of-block";
              state.mode = zlib_inflate.BAD;
              break;
            }
            state.lenbits = 9;
            opts = {bits: state.lenbits};
            ret = zlib_inftrees.inflate_table(zlib_inflate.LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
            state.lenbits = opts.bits;
            if (ret) {
              strm.msg = "invalid literal/lengths set";
              state.mode = zlib_inflate.BAD;
              break;
            }
            state.distbits = 6;
            state.distcode = state.distdyn;
            opts = {bits: state.distbits};
            ret = zlib_inftrees.inflate_table(zlib_inflate.DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
            state.distbits = opts.bits;
            if (ret) {
              strm.msg = "invalid distances set";
              state.mode = zlib_inflate.BAD;
              break;
            }
            state.mode = zlib_inflate.LEN_;
            if (flush === zlib_constants.Z_TREES) {
              break inf_leave;
            }
          case zlib_inflate.LEN_:
            state.mode = zlib_inflate.LEN;
          case zlib_inflate.LEN:
            if (have >= 6 && left >= 258) {
              strm.next_out = put;
              strm.avail_out = left;
              strm.next_in = next;
              strm.avail_in = have;
              state.hold = hold;
              state.bits = bits;
              zlib_inffast.inflate_fast(strm, _out);
              put = strm.next_out;
              output = strm.output;
              left = strm.avail_out;
              next = strm.next_in;
              input = strm.input;
              have = strm.avail_in;
              hold = state.hold;
              bits = state.bits;
              if (state.mode === zlib_inflate.TYPE) {
                state.back = -1;
              }
              break;
            }
            state.back = 0;
            for (; ; ) {
              here = state.lencode[hold & (1 << state.lenbits) - 1];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (here_op && (here_op & 240) === 0) {
              last_bits = here_bits;
              last_op = here_op;
              last_val = here_val;
              for (; ; ) {
                here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (last_bits + here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              hold >>>= last_bits;
              bits -= last_bits;
              state.back += last_bits;
            }
            hold >>>= here_bits;
            bits -= here_bits;
            state.back += here_bits;
            state.length = here_val;
            if (here_op === 0) {
              state.mode = zlib_inflate.LIT;
              break;
            }
            if (here_op & 32) {
              state.back = -1;
              state.mode = zlib_inflate.TYPE;
              break;
            }
            if (here_op & 64) {
              strm.msg = "invalid literal/length code";
              state.mode = zlib_inflate.BAD;
              break;
            }
            state.extra = here_op & 15;
            state.mode = zlib_inflate.LENEXT;
          case zlib_inflate.LENEXT:
            if (state.extra) {
              n = state.extra;
              while (bits < n) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.length += hold & (1 << state.extra) - 1;
              hold >>>= state.extra;
              bits -= state.extra;
              state.back += state.extra;
            }
            state.was = state.length;
            state.mode = zlib_inflate.DIST;
          case zlib_inflate.DIST:
            for (; ; ) {
              here = state.distcode[hold & (1 << state.distbits) - 1];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if ((here_op & 240) === 0) {
              last_bits = here_bits;
              last_op = here_op;
              last_val = here_val;
              for (; ; ) {
                here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (last_bits + here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              hold >>>= last_bits;
              bits -= last_bits;
              state.back += last_bits;
            }
            hold >>>= here_bits;
            bits -= here_bits;
            state.back += here_bits;
            if (here_op & 64) {
              strm.msg = "invalid distance code";
              state.mode = zlib_inflate.BAD;
              break;
            }
            state.offset = here_val;
            state.extra = here_op & 15;
            state.mode = zlib_inflate.DISTEXT;
          case zlib_inflate.DISTEXT:
            if (state.extra) {
              n = state.extra;
              while (bits < n) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.offset += hold & (1 << state.extra) - 1;
              hold >>>= state.extra;
              bits -= state.extra;
              state.back += state.extra;
            }
            state.mode = zlib_inflate.MATCH;
          case zlib_inflate.MATCH:
            if (left === 0) {
              break inf_leave;
            }
            copy = _out - left;
            if (state.offset > copy) {
              copy = state.offset - copy;
              if (copy > state.whave) {
                if (state.sane) {
                  strm.msg = "invalid distance too far back";
                  state.mode = zlib_inflate.BAD;
                  break;
                }
              }
              if (copy > state.wnext) {
                copy -= state.wnext;
                from = state.wsize - copy;
              } else {
                from = state.wnext - copy;
              }
              if (copy > state.length) {
                copy = state.length;
              }
              from_source = state.window;
            } else {
              from_source = output;
              from = put - state.offset;
              copy = state.length;
            }
            if (copy > left) {
              copy = left;
            }
            left -= copy;
            state.length -= copy;
            do {
              output[put++] = from_source[from++];
            } while (--copy);
            if (state.length === 0) {
              state.mode = zlib_inflate.LEN;
            }
            break;
          case zlib_inflate.LIT:
            if (left === 0) {
              break inf_leave;
            }
            output[put++] = state.length;
            left--;
            state.mode = zlib_inflate.LEN;
            break;
          case zlib_inflate.CHECK:
            if (state.wrap) {
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold |= input[next++] << bits;
                bits += 8;
              }
              _out -= left;
              strm.total_out += _out;
              state.total += _out;
              if (_out) {
                strm.adler = state.check = state.flags ? zlib_crc32.crc32(state.check, output, _out, put - _out) : zlib_adler32.adler32(state.check, output, _out, put - _out);
              }
              _out = left;
              if ((state.flags ? hold : zlib_inflate.zswap32(hold)) !== state.check) {
                strm.msg = "incorrect data check";
                state.mode = zlib_inflate.BAD;
                break;
              }
              hold = 0;
              bits = 0;
            }
            state.mode = zlib_inflate.LENGTH;
          case zlib_inflate.LENGTH:
            if (state.wrap && state.flags) {
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (hold !== (state.total & 4294967295)) {
                strm.msg = "incorrect length check";
                state.mode = zlib_inflate.BAD;
                break;
              }
              hold = 0;
              bits = 0;
            }
            state.mode = zlib_inflate.DONE;
          case zlib_inflate.DONE:
            ret = zlib_constants.Z_STREAM_END;
            break inf_leave;
          case zlib_inflate.BAD:
            ret = zlib_constants.Z_DATA_ERROR;
            break inf_leave;
          case zlib_inflate.MEM:
            return zlib_constants.Z_MEM_ERROR;
          case zlib_inflate.SYNC:
          default:
            return zlib_constants.Z_STREAM_ERROR;
        }
      }
    strm.next_out = put;
    strm.avail_out = left;
    strm.next_in = next;
    strm.avail_in = have;
    state.hold = hold;
    state.bits = bits;
    if (state.wsize || _out !== strm.avail_out && state.mode < zlib_inflate.BAD && (state.mode < zlib_inflate.CHECK || flush !== zlib_constants.Z_FINISH)) {
      if (zlib_inflate.updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) {
        state.mode = zlib_inflate.MEM;
        return zlib_constants.Z_MEM_ERROR;
      }
    }
    _in -= strm.avail_in;
    _out -= strm.avail_out;
    strm.total_in += _in;
    strm.total_out += _out;
    state.total += _out;
    if (state.wrap && _out) {
      strm.adler = state.check = state.flags ? zlib_crc32.crc32(state.check, output, _out, strm.next_out - _out) : zlib_adler32.adler32(state.check, output, _out, strm.next_out - _out);
    }
    strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === zlib_inflate.TYPE ? 128 : 0) + (state.mode === zlib_inflate.LEN_ || state.mode === zlib_inflate.COPY_ ? 256 : 0);
    if ((_in === 0 && _out === 0 || flush === zlib_constants.Z_FINISH) && ret === zlib_constants.Z_OK) {
      ret = zlib_constants.Z_BUF_ERROR;
    }
    return ret;
  }
  static inflateEnd(strm) {
    if (!strm || !strm.state) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    let state = strm.state;
    if (state.window) {
      state.window = null;
    }
    strm.state = null;
    return zlib_constants.Z_OK;
  }
  static inflateGetHeader(strm, head) {
    if (!strm || !strm.state) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    let state = strm.state;
    if ((state.wrap & 2) === 0) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    state.head = head;
    head.done = false;
    return zlib_constants.Z_OK;
  }
  static inflateSetDictionary(strm, dictionary) {
    const dictLength = dictionary.length;
    let state;
    let dictid;
    let ret;
    if (!strm || !strm.state) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    state = strm.state;
    if (state.wrap !== 0 && state.mode !== zlib_inflate.DICT) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    if (state.mode === zlib_inflate.DICT) {
      dictid = 1;
      dictid = zlib_adler32.adler32(dictid, dictionary, dictLength, 0);
      if (dictid !== state.check) {
        return zlib_constants.Z_DATA_ERROR;
      }
    }
    ret = zlib_inflate.updatewindow(strm, dictionary, dictLength, dictLength);
    if (ret) {
      state.mode = zlib_inflate.MEM;
      return zlib_constants.Z_MEM_ERROR;
    }
    state.havedict = 1;
    return zlib_constants.Z_OK;
  }
};
zlib_inflate.CODES = 0;
zlib_inflate.LENS = 1;
zlib_inflate.DISTS = 2;
zlib_inflate.HEAD = 1;
zlib_inflate.FLAGS = 2;
zlib_inflate.TIME = 3;
zlib_inflate.OS = 4;
zlib_inflate.EXLEN = 5;
zlib_inflate.EXTRA = 6;
zlib_inflate.NAME = 7;
zlib_inflate.COMMENT = 8;
zlib_inflate.HCRC = 9;
zlib_inflate.DICTID = 10;
zlib_inflate.DICT = 11;
zlib_inflate.TYPE = 12;
zlib_inflate.TYPEDO = 13;
zlib_inflate.STORED = 14;
zlib_inflate.COPY_ = 15;
zlib_inflate.COPY = 16;
zlib_inflate.TABLE = 17;
zlib_inflate.LENLENS = 18;
zlib_inflate.CODELENS = 19;
zlib_inflate.LEN_ = 20;
zlib_inflate.LEN = 21;
zlib_inflate.LENEXT = 22;
zlib_inflate.DIST = 23;
zlib_inflate.DISTEXT = 24;
zlib_inflate.MATCH = 25;
zlib_inflate.LIT = 26;
zlib_inflate.CHECK = 27;
zlib_inflate.LENGTH = 28;
zlib_inflate.DONE = 29;
zlib_inflate.BAD = 30;
zlib_inflate.MEM = 31;
zlib_inflate.SYNC = 32;
zlib_inflate.ENOUGH_LENS = 852;
zlib_inflate.ENOUGH_DISTS = 592;
zlib_inflate.MAX_WBITS = 15;
zlib_inflate.DEF_WBITS = zlib_inflate.MAX_WBITS;
zlib_inflate.virgin = true;

// obj/full/Pako/zlib/messages.js
"use strict";
var zlib_messages = class {
  static msg(index) {
    switch (index) {
      case 2:
        return "need dictionary";
      case 1:
        return "stream end";
      case 0:
        return "";
      case -1:
        return "file error";
      case -2:
        return "stream error";
      case -3:
        return "data error";
      case -4:
        return "insufficient memory";
      case -5:
        return "buffer error";
      case -6:
        return "incompatible version";
      default:
        return "unknowwn error";
    }
  }
};

// obj/full/Pako/zlib/inftrees.js
"use strict";
var zlib_inftrees = class {
  static inflate_table(type, lens, lens_index, codes, table, table_index, work, opts) {
    const bits = opts.bits;
    let len;
    let sym;
    let min = 0;
    let max;
    let root;
    let curr = 0;
    let drop = 0;
    let left = 0;
    let used = 0;
    let huff = 0;
    let incr;
    let fill;
    let low;
    let mask;
    let next;
    let base;
    let base_index = 0;
    let end;
    const count = new Uint16Array(zlib_inftrees.MAXBITS + 1);
    const offs = new Uint16Array(zlib_inftrees.MAXBITS + 1);
    let extra;
    let extra_index = 0;
    let here_bits;
    let here_op;
    let here_val;
    for (len = 0; len <= zlib_inftrees.MAXBITS; len++) {
      count[len] = 0;
    }
    for (sym = 0; sym < codes; sym++) {
      count[lens[lens_index + sym]]++;
    }
    root = bits;
    for (max = zlib_inftrees.MAXBITS; max >= 1; max--) {
      if (count[max] !== 0) {
        break;
      }
    }
    if (root > max) {
      root = max;
    }
    if (max === 0) {
      table[table_index++] = 1 << 24 | 64 << 16 | 0;
      table[table_index++] = 1 << 24 | 64 << 16 | 0;
      opts.bits = 1;
      return 0;
    }
    for (min = 1; min < max; min++) {
      if (count[min] !== 0) {
        break;
      }
    }
    if (root < min) {
      root = min;
    }
    left = 1;
    for (len = 1; len <= zlib_inftrees.MAXBITS; len++) {
      left <<= 1;
      left -= count[len];
      if (left < 0) {
        return -1;
      }
    }
    if (left > 0 && (type === zlib_inftrees.CODES || max !== 1)) {
      return -1;
    }
    offs[1] = 0;
    for (len = 1; len < zlib_inftrees.MAXBITS; len++) {
      offs[len + 1] = offs[len] + count[len];
    }
    for (sym = 0; sym < codes; sym++) {
      if (lens[lens_index + sym] !== 0) {
        work[offs[lens[lens_index + sym]]++] = sym;
      }
    }
    if (type === zlib_inftrees.CODES) {
      base = work;
      extra = new Uint8Array();
      end = 19;
    } else if (type === zlib_inftrees.LENS) {
      base = zlib_inftrees.lbase;
      base_index -= 257;
      extra = zlib_inftrees.lext;
      extra_index -= 257;
      end = 256;
    } else {
      base = zlib_inftrees.dbase;
      extra = zlib_inftrees.dext;
      end = -1;
    }
    huff = 0;
    sym = 0;
    len = min;
    next = table_index;
    curr = root;
    drop = 0;
    low = -1;
    used = 1 << root;
    mask = used - 1;
    if (type === zlib_inftrees.LENS && used > zlib_inftrees.ENOUGH_LENS || type === zlib_inftrees.DISTS && used > zlib_inftrees.ENOUGH_DISTS) {
      return 1;
    }
    for (; ; ) {
      here_bits = len - drop;
      if (work[sym] < end) {
        here_op = 0;
        here_val = work[sym];
      } else if (work[sym] > end) {
        here_op = extra[extra_index + work[sym]];
        here_val = base[base_index + work[sym]];
      } else {
        here_op = 32 + 64;
        here_val = 0;
      }
      incr = 1 << len - drop;
      fill = 1 << curr;
      min = fill;
      do {
        fill -= incr;
        table[next + (huff >> drop) + fill] = here_bits << 24 | here_op << 16 | here_val | 0;
      } while (fill !== 0);
      incr = 1 << len - 1;
      while (huff & incr) {
        incr >>= 1;
      }
      if (incr !== 0) {
        huff &= incr - 1;
        huff += incr;
      } else {
        huff = 0;
      }
      sym++;
      if (--count[len] === 0) {
        if (len === max) {
          break;
        }
        len = lens[lens_index + work[sym]];
      }
      if (len > root && (huff & mask) !== low) {
        if (drop === 0) {
          drop = root;
        }
        next += min;
        curr = len - drop;
        left = 1 << curr;
        while (curr + drop < max) {
          left -= count[curr + drop];
          if (left <= 0) {
            break;
          }
          curr++;
          left <<= 1;
        }
        used += 1 << curr;
        if (type === zlib_inftrees.LENS && used > zlib_inftrees.ENOUGH_LENS || type === zlib_inftrees.DISTS && used > zlib_inftrees.ENOUGH_DISTS) {
          return 1;
        }
        low = huff & mask;
        table[low] = root << 24 | curr << 16 | next - table_index | 0;
      }
    }
    if (huff !== 0) {
      table[next + huff] = len - drop << 24 | 64 << 16 | 0;
    }
    opts.bits = root;
    return 0;
  }
};
zlib_inftrees.MAXBITS = 15;
zlib_inftrees.ENOUGH_LENS = 852;
zlib_inftrees.ENOUGH_DISTS = 592;
zlib_inftrees.CODES = 0;
zlib_inftrees.LENS = 1;
zlib_inftrees.DISTS = 2;
zlib_inftrees.lbase = new Uint16Array([
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  13,
  15,
  17,
  19,
  23,
  27,
  31,
  35,
  43,
  51,
  59,
  67,
  83,
  99,
  115,
  131,
  163,
  195,
  227,
  258,
  0,
  0
]);
zlib_inftrees.lext = new Uint8Array([
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  17,
  17,
  17,
  17,
  18,
  18,
  18,
  18,
  19,
  19,
  19,
  19,
  20,
  20,
  20,
  20,
  21,
  21,
  21,
  21,
  16,
  72,
  78
]);
zlib_inftrees.dbase = new Uint16Array([
  1,
  2,
  3,
  4,
  5,
  7,
  9,
  13,
  17,
  25,
  33,
  49,
  65,
  97,
  129,
  193,
  257,
  385,
  513,
  769,
  1025,
  1537,
  2049,
  3073,
  4097,
  6145,
  8193,
  12289,
  16385,
  24577,
  0,
  0
]);
zlib_inftrees.dext = new Uint8Array([
  16,
  16,
  16,
  16,
  17,
  17,
  18,
  18,
  19,
  19,
  20,
  20,
  21,
  21,
  22,
  22,
  23,
  23,
  24,
  24,
  25,
  25,
  26,
  26,
  27,
  27,
  28,
  28,
  29,
  29,
  64,
  64
]);

// obj/full/Pako/zlib/zstream.js
"use strict";
var zlib_ZStream = class {
  constructor() {
    this.input = null;
    this.next_in = 0;
    this.avail_in = 0;
    this.total_in = 0;
    this.output = null;
    this.next_out = 0;
    this.avail_out = 0;
    this.total_out = 0;
    this.msg = "";
    this.state = null;
    this.data_type = 2;
    this.adler = 0;
  }
};

// obj/full/webPage.js
var YWebPage = class {
  edit(widgetIndex) {
    YWebPage.widgets[widgetIndex].edit();
  }
  static get editMenuItem() {
    return YWebPage._editMenuItem;
  }
  static get deleteMenuItem() {
    return YWebPage._deleteMenuItem;
  }
  static get disableMarkerMenuItem() {
    return YWebPage._disableMarkerMenuItem;
  }
  static get clearDataloggerMenuItem() {
    return YWebPage._clearDataloggerMenuItem;
  }
  static get addMarkerMenuItem() {
    return YWebPage._addMarkerMenuItem;
  }
  static get markersSubMenuItems() {
    return YWebPage._markersSubMenuItems;
  }
  static get contextMarkerSubMenu() {
    return YWebPage._contextMarkerSubMenu;
  }
  static get contextWidgetsSubMenu() {
    return YWebPage._contextWidgetsSubMenu;
  }
  static get resetDataViewMenuItem() {
    return YWebPage._resetDataViewMenuItem;
  }
  static get snapshotMenuItem() {
    return YWebPage._snapshotMenuItem;
  }
  static applicationGlobalinit() {
    if (YWebPage._MarkerCountPerXaxis == 0) {
      let xAxisProp = new XaxisDescription();
      let propDesc = GenericProperties.getAllProperties(xAxisProp);
      for (let propname in propDesc.byName) {
        if (propname.startsWith("markers"))
          YWebPage._MarkerCountPerXaxis++;
      }
    }
    if (YWebPage.manager == null)
      YWebPage.manager = new sensorsManager();
    if (!YWebPage.readonly && YWebPage._editor == null)
      YWebPage._editor = new PropertiesForm2();
    if (!YWebPage.readonly && YWebPage._mainform == null)
      YWebPage._mainform = new mainForm();
    if (YWebPage._contextMenu == null) {
      YWebPage._contextMenu = new ContextMenu(YWebPage.baseSize, (mouseX, mouseY) => {
        YWebPage.menuIsOpening(mouseX, mouseY);
      }, constants.generalFontFamily);
      YWebPage._contextMarkerSubMenu = new ContextSubMenu(YWebPage.baseSize, YWebPage._contextMenu, null, constants.generalFontFamily);
      for (let i = 0; i < YWebPage._MarkerCountPerXaxis; i++) {
        YWebPage._markersSubMenuItems.push(YWebPage._contextMarkerSubMenu.addMenuItem(ressources.AddMarkerIcon(YWebPage.baseSize.toString(), i + 1), "Place marker " + (i + 1).toString(), () => {
          let target = YWebPage._markersSubMenuItems[i].userdata;
          target.startMarkerCapture(i);
        }));
      }
      if (!YWebPage.readonly) {
        YWebPage._contextWidgetsSubMenu = new ContextSubMenu(YWebPage.baseSize, YWebPage._contextMenu, (mouseX, mouseY) => {
          YWebPage.WidgetsSubMenuIsOpening(mouseX, mouseY);
        }, constants.generalFontFamily);
        YWebPage._widgetsMenuItem = YWebPage._contextMenu.addSubMenuItem(ressources.AllIcon(YWebPage.baseSize.toString(), false, false, false, false), "All widgets", YWebPage._contextWidgetsSubMenu);
        YWebPage._editMenuItem = YWebPage._contextMenu.addMenuItem(ressources.EditIcon(YWebPage.baseSize.toString(), false, false, false, false), "Configure this widget", () => {
          YWebPage.editWidget();
        });
        YWebPage._deleteMenuItem = YWebPage._contextMenu.addMenuItem(ressources.TrashIcon(YWebPage.baseSize.toString(), false, false, false, false), "Delete this widget", () => {
          YWebPage.deleteWidget();
        });
        YWebPage._editMenuItem.visible = false;
        YWebPage._deleteMenuItem.visible = false;
      }
      YWebPage._resetDataViewMenuItem = YWebPage._contextMenu.addMenuItem(ressources.resetViewPort(YWebPage.baseSize.toString(), false, false, false, false), "Reset dataview", () => {
        YWebPage.resetDataView();
      });
      YWebPage._resetDataViewMenuItem.visible = false;
      if (!YWebPage.readonly) {
        YWebPage._clearDataloggerMenuItem = YWebPage._contextMenu.addMenuItem(ressources.EraseDatalogger(YWebPage.baseSize.toString(), false, false, false, false), "Clear datalogger", () => {
          YWebPage.clearDatalogger();
        });
        YWebPage._resetDataViewMenuItem.visible = false;
      }
      YWebPage._contextMenu.AddSeparator();
      if (!YWebPage.readonly) {
        YWebPage._addMarkerMenuItem = YWebPage._contextMenu.addSubMenuItem(ressources.AddMarker(YWebPage.baseSize.toString(), false, true, true, false), "Place markers", YWebPage._contextMarkerSubMenu);
        YWebPage._disableMarkerMenuItem = YWebPage._contextMenu.addMenuItem(ressources.DeleteMarker(YWebPage.baseSize.toString(), false, true, false, true), "Disable Allmarkers", () => {
          YWebPage.disableAllMarker();
        });
        YWebPage._addMarkerMenuItem.visible = false;
        YWebPage._disableMarkerMenuItem.visible = false;
        YWebPage._contextMenu.AddSeparator();
        YWebPage._contextMenu.addMenuItem(ressources.SolidGaugeIcon(YWebPage.baseSize.toString(), false, true, true, false), "Add a new Solid gauge", () => {
          YWebPage.newGaugeWidget();
        });
        YWebPage._contextMenu.addMenuItem(ressources.AngularGaugeIcon(YWebPage.baseSize.toString(), false, true, true, false), "Add a new Angular gauge", () => {
          YWebPage.newAngularGaugeWidget();
        });
        YWebPage._contextMenu.addMenuItem(ressources.DigitalDisplayIcon(YWebPage.baseSize.toString(), false, true, true, false), "Add a new Digital Display", () => {
          YWebPage.newDigitalDisplayWidget();
        });
        YWebPage._contextMenu.addMenuItem(ressources.GraphIcon(YWebPage.baseSize.toString(), false, true, true, false), "Add a new Graph", () => {
          YWebPage.newGraphWidget();
        });
      }
      YWebPage._contextMenu.addMenuItem(ressources.RawDataIcon(YWebPage.baseSize.toString(), false, false, false, false), "Show raw data", () => {
        rawDataForm.show();
      });
      YWebPage._snapshotMenuItem = YWebPage._contextMenu.addMenuItem(ressources.snapshotIcon(YWebPage.baseSize.toString(), false, false, false, false), "Snapshot", () => {
        YWebPage.snapShot();
      });
      if (!YWebPage.readonly) {
        YWebPage._contextMenu.AddSeparator();
        YWebPage._contextMenu.addMenuItem(ressources.ConfigureIcon(YWebPage.baseSize.toString(), false, false, false, false), "Global configuration", () => {
          configForm.show();
        });
        YWebPage._contextMenu.addMenuItem(ressources.SaveIcon(YWebPage.baseSize.toString(), false, false, false, false), "Save now", () => {
          YWebPage.save(true);
        });
      }
      YWebPage._contextMenu.addMenuItem(ressources.LogFileIcon(YWebPage.baseSize.toString(), false, false, false, false), "Show logs", () => {
        YWebPage.showLogsWindow();
      });
    }
  }
  static RegisterDeviceArrivalCallback(arrivalCallback) {
    sensorsManager.RegisterDeviceArrivalCallback(arrivalCallback);
  }
  static RegisterDeviceRemovalCallback(removalCallback) {
    sensorsManager.RegisterDeviceRemovalCallback(removalCallback);
  }
  static WidgetsSubMenuIsOpening(mouseX, mouseY) {
    YWebPage._contextWidgetsSubMenu.clearAllContents();
    for (let i = 0; i < YWebPage.widgets.length; i++) {
      let icon = "";
      let subMenu = new ContextSubMenu(YWebPage.baseSize, YWebPage._contextWidgetsSubMenu, (mouseX2, mouseY2) => {
        YWebPage.specificWidgetSubMenuIsOpening(subMenu, mouseX2, mouseY2);
      }, constants.generalFontFamily);
      subMenu.userdata = YWebPage.widgets[i];
      if (YWebPage.widgets[i] instanceof graphWidget)
        icon = ressources.GraphIcon(YWebPage.baseSize.toString(), false, false, false, false);
      if (YWebPage.widgets[i] instanceof digitalDisplayWidget)
        icon = ressources.DigitalDisplayIcon(YWebPage.baseSize.toString(), false, false, false, false);
      if (YWebPage.widgets[i] instanceof gaugeWidget)
        icon = ressources.SolidGaugeIcon(YWebPage.baseSize.toString(), false, false, false, false);
      if (YWebPage.widgets[i] instanceof angularGaugeWidget)
        icon = ressources.AngularGaugeIcon(YWebPage.baseSize.toString(), false, false, false, false);
      YWebPage._contextWidgetsSubMenu.addSubMenuItem(icon, YWebPage.widgets[i].Text, subMenu);
    }
  }
  static specificWidgetSubMenuIsOpening(source, mouseX, mouseY) {
    if (source.menuItemsCount > 0)
      return;
    let w = source.userdata;
    source.addMenuItem(ressources.EditIcon(YWebPage.baseSize.toString(), false, false, false, false), "Configure", () => {
      w.edit();
    });
    source.addMenuItem(ressources.TrashIcon(YWebPage.baseSize.toString(), false, false, false, false), "Delete", () => {
      YWebPage.deleteWidget(w);
    });
    if (w instanceof graphWidget) {
      source.addMenuItem(ressources.resetViewPort(YWebPage.baseSize.toString(), false, false, false, false), "Reset dataview", () => {
        w.resetDataView();
      });
      source.addMenuItem(ressources.EraseDatalogger(YWebPage.baseSize.toString(), false, false, false, false), "Clear datalogger", () => {
        w.clearDataLogger();
      });
    }
  }
  static showLogsWindow() {
    logForm.show();
  }
  static snapShot() {
    let w = YWebPage._snapshotMenuItem.userdata;
    w.snapshot();
  }
  static menuIsOpening(mouseX, mouseY) {
    if (YWebPage.disableMarkerMenuItem != null)
      YWebPage.disableMarkerMenuItem.visible = false;
    if (YWebPage.addMarkerMenuItem != null)
      YWebPage.addMarkerMenuItem.visible = false;
    if (YWebPage.clearDataloggerMenuItem != null)
      YWebPage.clearDataloggerMenuItem.visible = false;
    if (YWebPage.editMenuItem != null)
      YWebPage.editMenuItem.visible = false;
    if (YWebPage.deleteMenuItem != null)
      YWebPage.deleteMenuItem.visible = false;
    YWebPage.resetDataViewMenuItem.visible = false;
    YWebPage.snapshotMenuItem.visible = false;
    for (let i = 0; i < YWebPage.widgets.length; i++) {
      YWebPage.widgets[i].contextMenuCallBack(mouseX, mouseY);
    }
    YWebPage._widgetsMenuItem.visible = !YWebPage.readonly && YWebPage.widgets.length > 0 && !YWebPage._editMenuItem.visible;
    YWebPage._contextMenu.refresh();
  }
  static resetDataView() {
    YWebPage._resetDataViewMenuItem.userdata.resetDataView();
  }
  static editWidget() {
    let w = YWebPage._editMenuItem.userdata;
    w.edit();
  }
  static disableAllMarker() {
    YWebPage._disableMarkerMenuItem.userdata.disableAllMarkers();
  }
  static clearDatalogger() {
    YWebPage._clearDataloggerMenuItem.userdata.clearDataLogger();
  }
  static deleteWidget(widget) {
    let w = typeof widget == "undefined" ? YWebPage._deleteMenuItem.userdata : widget;
    confirm.ask(w.confirmDeleteString, () => {
      if (!YWebPage.readonly && w.isBeingEdited && YWebPage._editor != null)
        YWebPage._editor.hide();
      w.delete();
      constants.edited = true;
      for (let i = YWebPage.widgets.length - 1; i >= 0; i--) {
        if (YWebPage.widgets[i] == w) {
          YWebPage.widgets.splice(i, 1);
        }
      }
      if (YWebPage.widgets.length <= 0 && YWebPage._mainform != null)
        YWebPage._mainform.show();
    }, null, null);
  }
  static FindUniqueNewName(prefix) {
    let n = 1;
    for (let i = 0; i < YWebPage.widgets.length; i++) {
      if (YWebPage.widgets[i].Text.startsWith(prefix))
        n++;
    }
    if (n > 1)
      prefix = prefix + " " + n.toString();
    return prefix;
  }
  static newGraphWidget() {
    let w = window.innerWidth / 2 >> 0;
    let h = window.innerHeight / 2 >> 0;
    if (w < 350)
      w = 350;
    if (h < 200)
      w = 200;
    let x = (window.innerWidth - w) / 2 >> 0;
    let y = (window.innerHeight - h) / 2 >> 0;
    let index = YWebPage.widgets.length;
    if (index > 0) {
      x = index * 25;
      y = index * 25;
    }
    let wdg = new graphWidget(null, YWebPage._editor, x, y, 765, 470);
    wdg.set_name(YWebPage.FindUniqueNewName("New Graph"));
    YWebPage.widgets.push(wdg);
    wdg.resize(w, h);
    if (this._mainform != null)
      this._mainform.hide();
    if (!YWebPage.readonly) {
      if (YWebPage._editor != null && YWebPage._editor.visible)
        wdg.edit();
    }
  }
  static newAngularGaugeWidget() {
    let s = Math.min(window.innerWidth, window.innerHeight) / 2;
    if (s < 350)
      s = 350;
    let x = (window.innerWidth - s) / 2 >> 0;
    let y = (window.innerHeight - s) / 2 >> 0;
    let w = s >> 0;
    let h = s >> 0;
    let index = YWebPage.widgets.length;
    if (index > 0) {
      x = index * 25;
      y = index * 25;
    }
    let wdg = new angularGaugeWidget(null, YWebPage._editor, x, y, 375, 300);
    wdg.set_name(YWebPage.FindUniqueNewName("New Angular Gauge"));
    YWebPage.widgets.push(wdg);
    wdg.resize(w, h);
    if (this._mainform != null)
      this._mainform.hide();
    if (!YWebPage.readonly) {
      if (YWebPage._editor != null && YWebPage._editor.visible)
        wdg.edit();
    }
  }
  static newGaugeWidget() {
    let s = Math.min(window.innerWidth, window.innerHeight) / 2;
    if (s < 350)
      s = 350;
    let x = (window.innerWidth - s) / 2 >> 0;
    let y = (window.innerHeight - s) / 2 >> 0;
    let w = s >> 0;
    let h = s >> 0;
    let index = YWebPage.widgets.length;
    if (index > 0) {
      x = index * 25;
      y = index * 25;
    }
    let wdg = new gaugeWidget(null, YWebPage._editor, x, y, 355, 201);
    wdg.set_name(YWebPage.FindUniqueNewName("New Solid Gauge"));
    YWebPage.widgets.push(wdg);
    wdg.resize(w, h);
    if (this._mainform != null)
      this._mainform.hide();
    if (!YWebPage.readonly) {
      if (YWebPage._editor != null && YWebPage._editor.visible)
        wdg.edit();
    }
  }
  static newDigitalDisplayWidget() {
    let s = Math.min(window.innerWidth, window.innerHeight) / 8;
    if (s < 90)
      s = 90;
    let x = (window.innerWidth - 4 * s) / 2 >> 0;
    let y = (window.innerHeight - s) / 2 >> 0;
    let w = 4 * s >> 0;
    let h = s >> 0;
    let index = YWebPage.widgets.length;
    if (index > 0) {
      x = index * 25;
      y = index * 25;
    }
    let wdg = new digitalDisplayWidget(null, YWebPage._editor, x, y, 410, 125);
    wdg.set_name(YWebPage.FindUniqueNewName("New Digital Display"));
    let n = 1;
    for (let i = 0; i < YWebPage.widgets.length; i++) {
      if (YWebPage.widgets[i].Text.startsWith(wdg.Text))
        n++;
    }
    if (n > 1)
      wdg.Text = wdg.Text + " " + n.toString();
    YWebPage.widgets.push(wdg);
    wdg.resize(w, h);
    if (this._mainform != null)
      this._mainform.hide();
    if (!YWebPage.readonly) {
      if (YWebPage._editor != null && YWebPage._editor.visible)
        wdg.edit();
    }
  }
  static refreshPropertiesForm() {
    if (!YWebPage.readonly && YWebPage._editor != null)
      YWebPage._editor.refresh();
  }
  static sensorListHaschanged() {
    YWebPage.refreshPropertiesForm();
  }
  static EmptyReadonlyConfig() {
    alert2.show("Yocto-Visualization Error\n\nConfiguration is both empty and read only, check configuration file.");
  }
  static async ForceReloadConfig(newXMLdata) {
    if (!YWebPage.readonly) {
      if (YWebPage._editor != null)
        YWebPage._editor.visible = false;
      configForm.hide();
      rawDataForm.hide();
      HubEdit.hide();
    }
    logForm.log("Reloading the whole configuration.");
    await sensorsManager.clearHublist();
    for (let i = YWebPage.widgets.length - 1; i >= 0; i--) {
      YWebPage.widgets[i].destroy();
      YWebPage.widgets.splice(i, 1);
    }
    YWebPage.loadFromXML(newXMLdata);
    constants.edited = false;
  }
  static ConfigChanged(newXMLdata) {
    if (YWebPage.ConfigChangedConfirmWindows != null) {
      YWebPage.ConfigChangedConfirmWindows.hide();
    }
    let newCRC = constants.crc32(newXMLdata);
    if (newCRC == YWebPage.xmlDataCRC)
      return;
    logForm.log("Config file changed behind our back!");
    if (!this.readonly) {
      YWebPage.ConfigChangedConfirmWindows = confirm.ask("Configuration has changed on server\nWould you like to reload it?", () => {
        YWebPage.ForceReloadConfig(newXMLdata);
        YWebPage.ConfigChangedConfirmWindows = null;
      }, () => {
        YWebPage.ConfigChangedConfirmWindows = null;
      }, null);
    } else {
      YWebPage.ForceReloadConfig(newXMLdata);
    }
    YWebPage.xmlDataCRC = newCRC;
    constants.edited = false;
  }
  static ShowSaveReminder(visible) {
    if (YWebPage.saveIntDiv == null) {
      YWebPage.saveIntDiv = document.createElement("DIV");
      YWebPage.saveIntDiv.style.position = "fixed";
      YWebPage.saveIntDiv.style.left = "5px";
      YWebPage.saveIntDiv.style.top = "5px";
      YWebPage.saveIntDiv.style.zIndex = "200000";
      YWebPage.saveIntDiv.style.cursor = "pointer";
      YWebPage.saveIntDiv.innerHTML = ressources.SaveNeededIcon((48 * constants.guiDPIFactor).toString(), false, false, false, false);
      YWebPage.saveIntDiv.addEventListener("click", () => {
        YWebPage.saveIntDiv.style.display = "none";
        YWebPage.save(true);
      });
      document.body.appendChild(YWebPage.saveIntDiv);
    }
    YWebPage.saveIntDiv.style.display = visible ? "" : "none";
  }
  static loadFromXML(xmlData) {
    if (xmlData == "") {
      if (!YWebPage.readonly && YWebPage._mainform != null) {
        YWebPage._mainform.show();
      } else {
        YWebPage.EmptyReadonlyConfig();
      }
      return;
    }
    let parser = new DOMParser();
    let doc = parser.parseFromString(xmlData.replace("<!-->", "<!-- "), "application/xml");
    let root = null;
    doc.childNodes.forEach((node) => {
      if (node.nodeName.toUpperCase() == "ROOT" && root == null)
        root = node;
    });
    if (root == null)
      throw "No ROOT top node in XML data";
    root.childNodes.forEach((node) => {
      if (node.nodeName.toUpperCase() == "SENSORS") {
        sensorsManager.setKnownSensors(new YXmlNode(node));
      }
    });
    root.childNodes.forEach((node) => {
      let editor = null;
      editor = YWebPage._editor;
      switch (node.nodeName.toUpperCase()) {
        case "CONFIG":
          constants.Init(new YXmlNode(node));
          break;
        case "GRAPHFORM":
          YWebPage.widgets.push(new graphWidget(new YXmlNode(node), editor));
          break;
        case "ANGULARGAUGEFORM":
          YWebPage.widgets.push(new angularGaugeWidget(new YXmlNode(node), editor));
          break;
        case "GAUGEFORM":
          YWebPage.widgets.push(new gaugeWidget(new YXmlNode(node), editor));
          break;
        case "DIGITALDISPLAYFORM":
          YWebPage.widgets.push(new digitalDisplayWidget(new YXmlNode(node), editor));
          break;
      }
      sensorsManager.registerChangeCallback(() => {
        YWebPage.sensorListHaschanged();
      });
      if (node.nodeName.toUpperCase() == "ROOT" && root == null)
        root = node;
    });
    if (YWebPage.widgets.length <= 0) {
      constants.edited = false;
      if (!YWebPage.readonly && YWebPage._mainform != null) {
        YWebPage._mainform.show();
      } else {
        YWebPage.EmptyReadonlyConfig();
      }
    } else if (!YWebPage.readonly && YWebPage._mainform != null)
      YWebPage._mainform.hide();
  }
  static AnimateNewVerwsionMessage(step) {
    YWebPage.NewVersionmessageDiv.style.left = Math.round(100 - step) + "%";
    if (step < 100) {
      step += 2;
      if (step > 100)
        step = 100;
      setTimeout(() => {
        YWebPage.AnimateNewVerwsionMessage(step);
      });
    }
  }
  static StartInstaller(roothub) {
    let installerDiv = document.createElement("DIV");
    installerDiv.style.position = "absolute";
    installerDiv.style.top = "50%";
    installerDiv.style.left = "50%";
    installerDiv.style.transform = "translate(-50%,-50%)";
    installerDiv.style.width = "550px";
    installerDiv.style.height = "380px";
    installerDiv.style.zIndex = YWebPage.getTopZIndex().toString();
    installerDiv.style.border = "1px solid black";
    installerDiv.style.boxShadow = "rgba(0, 0, 0, 0.05) 4px 4px 4px 1px";
    document.body.appendChild(installerDiv);
    let options = {};
    if (roothub != null)
      options = {
        protocol: roothub.protocol,
        addr: roothub.addr,
        port: parseInt(roothub.port),
        path: roothub.path,
        cancelable: true
      };
    window.startYV4W_installer(installerDiv, options);
  }
  static DownloadAndStartInstaller(installerURL, roothub, deleteTimer) {
    clearTimeout(deleteTimer);
    console.log("Downloading installer (" + installerURL + ")...");
    let P = document.createElement("P");
    P.style.textAlign = "center";
    P.style.fontFamily = constants.generalFontFamily;
    P.style.fontSize = "16px";
    P.innerHTML = "Downloading Installer<br>Please wait...";
    YWebPage.NewVersionmessageDiv.removeChild(YWebPage.NewVersionmessageDiv.firstChild);
    YWebPage.NewVersionmessageDiv.appendChild(P);
    let script = document.createElement("script");
    script.async = false;
    script.type = "module";
    script.onerror = (err) => {
      console.log("Failed to donwload installer (" + Event.toString() + ")");
      P.innerHTML = "Failed to download installer,<br>Check conole logs";
    };
    script.onload = () => {
      P.innerHTML = "Starting installer...";
      YWebPage.DeleteNewVersionMessage(100);
      YWebPage.StartInstaller(roothub);
    };
    document.body.appendChild(script);
    script.src = installerURL;
  }
  static DeleteNewVersionMessage(opacity) {
    opacity -= 5;
    if (opacity > 0) {
      YWebPage.NewVersionmessageDiv.style.opacity = (opacity / 100).toString();
      setTimeout(() => {
        YWebPage.DeleteNewVersionMessage(opacity);
      }, 100);
      return;
    }
    document.body.removeChild(YWebPage.NewVersionmessageDiv.parentNode);
  }
  static getTopZIndex() {
    var elems = document.getElementsByTagName("DIV");
    var highestZ = 0;
    for (var i = 0; i < elems.length; i++) {
      var z = Number.parseInt(window.getComputedStyle(elems[i], null).getPropertyValue("z-index"));
      if (z > highestZ)
        highestZ = z;
    }
    return highestZ + 1;
  }
  static async CheckForNewVersion(force) {
    if (!constants.mustCheckForUpdate && !force)
      return;
    let checkurl = location.protocol + "//www.yoctopuce.com/FR/common/getLastFirmwareLink.php?app=yoctovisualization4web.installer&version=" + constants.buildVersion + "&platform=_";
    let response;
    try {
      response = await fetch(checkurl);
    } catch (e) {
      return;
    }
    if (!response.ok)
      return;
    let json;
    try {
      json = await response.json();
    } catch (e) {
      return;
    }
    if (!(json instanceof Array))
      return;
    if (json.length <= 0)
      return;
    if (!("version" in json[0]))
      return;
    if (!("link" in json[0]))
      return;
    let newVersionInstallerURL = json[0]["link"];
    let newVersionNumber = parseInt(json[0]["version"]);
    let currentVersionStr = constants.buildVersion;
    let currentVersionNumber = 0;
    if (currentVersionStr.indexOf("-") < 0) {
      let n = currentVersionStr.lastIndexOf(".");
      if (n >= 0)
        currentVersionStr = currentVersionStr.substr(n + 1);
      currentVersionNumber = parseInt(currentVersionStr);
    }
    if (currentVersionNumber >= newVersionNumber)
      return;
    let generalSize = constants.generalFontSize;
    let NewVersionSizeX = generalSize * 24;
    let NewVersionSizeY = generalSize * 5;
    let containerDiv = document.createElement("DIV");
    containerDiv.style.position = "absolute";
    containerDiv.style.width = NewVersionSizeX + "px";
    containerDiv.style.height = NewVersionSizeY + "px";
    containerDiv.style.zIndex = YWebPage.getTopZIndex().toString();
    containerDiv.style.top = "5px";
    containerDiv.style.right = "0px";
    containerDiv.style.overflow = "hidden";
    document.body.appendChild(containerDiv);
    YWebPage.NewVersionmessageDiv = document.createElement("DIV");
    YWebPage.NewVersionmessageDiv.style.position = "absolute";
    YWebPage.NewVersionmessageDiv.style.width = NewVersionSizeX - 7 + "px";
    YWebPage.NewVersionmessageDiv.style.height = NewVersionSizeY - 2 + "px";
    YWebPage.NewVersionmessageDiv.style.backgroundColor = "GhostWhite";
    YWebPage.NewVersionmessageDiv.style.border = "1px solid dimgray";
    YWebPage.NewVersionmessageDiv.style.top = "0px";
    YWebPage.NewVersionmessageDiv.style.left = NewVersionSizeX + "px";
    let table = document.createElement("TABLE");
    table.style.fontFamily = constants.generalFontFamily;
    table.style.fontSize = generalSize + "px";
    let TR = document.createElement("TR");
    let TD1 = document.createElement("TD");
    TD1.style.paddingLeft = "5px";
    TD1.style.paddingRight = "10px";
    TD1.rowSpan = 2;
    TD1.style.verticalAlign = "middle";
    TD1.innerHTML = ressources.infoIcon((generalSize * 4).toString(), false, false, false, false, "information");
    TR.appendChild(TD1);
    let TD2 = document.createElement("TD");
    TD2.innerHTML = "A new Yocto-Visualization (for web)<br>version is available";
    TR.appendChild(TD2);
    table.appendChild(TR);
    TR = document.createElement("TR");
    TD2 = document.createElement("TD");
    TD2.style.textAlign = "right";
    TD2.style.verticalAlign = "bottom";
    let hubList = sensorsManager.hubList;
    let rootHub = null;
    for (let i = 0; i < hubList.length; i++) {
      if (!hubList[i].removable)
        rootHub = hubList[i];
    }
    let a = document.createElement("A");
    let deleteTimer = setTimeout(() => {
      YWebPage.DeleteNewVersionMessage(100);
    }, 5e3);
    a.style.fontSize = "12px";
    a.style.color = " #0000EE";
    a.style.textDecoration = "underline";
    a.style.cursor = "pointer";
    a.style.fontFamily = constants.generalFontFamily;
    a.style.fontSize = generalSize + "px";
    if (rootHub != null) {
      a.innerText = "Download and start installer..";
      a.addEventListener("click", () => {
        YWebPage.DownloadAndStartInstaller(newVersionInstallerURL, rootHub, deleteTimer);
      });
    } else {
      a.innerText = "www.yoctopuce.com";
      a.addEventListener("click", () => {
        window.location.assign("http://www.yoctopuce.com/EN/tools.php");
      });
    }
    TD2.appendChild(a);
    TR.appendChild(TD2);
    table.appendChild(TR);
    YWebPage.NewVersionmessageDiv.appendChild(table);
    containerDiv.appendChild(YWebPage.NewVersionmessageDiv);
    YWebPage.AnimateNewVerwsionMessage(0);
  }
  static run(xmlData, ExternalConfigChange, saveFunction) {
    if (typeof ExternalConfigChange !== "undefined") {
      if (ExternalConfigChange != null) {
        sensorsManager.registerChangeExternalCallback(ExternalConfigChange);
      }
    }
    YWebPage.xmlDataCRC = constants.crc32(xmlData);
    if (typeof saveFunction !== "undefined")
      YWebPage._saveFunction = saveFunction;
    logForm.log("Application start, Welcome to Yocto-Visualization (for web).");
    logForm.log("This application contains code ported from the Pako library (www.github.com/nodeca/pako).");
    logForm.log("Yocto-Visualization version is " + constants.buildVersion);
    logForm.log("Yoctopuce API version is " + YAPI.imm_GetAPIVersion());
    if (constants.RunningOnAndroid)
      logForm.log("Browser is running on Android");
    let widthCm = Math.round(2.54 * constants.deviceScreenWidth / constants.screenDPI);
    let heightCm = Math.round(2.54 * constants.deviceScreenHeight / constants.screenDPI);
    logForm.log("Reported screen size is " + constants.deviceScreenWidth.toString() + "x" + constants.deviceScreenHeight.toString() + " at " + constants.screenDPI + " dpi, (~" + widthCm.toString() + "x" + heightCm.toString() + "cm) ");
    logForm.log("Reported pixel ratio is " + window.devicePixelRatio.toString());
    logForm.log(constants.isPhoneOrTablet ? "Probably running on a tablet or a phone." : "Probably running on a desktop.");
    logForm.log((constants.guiDPIFactorWasOverriden ? "DPI based zoom overridden  to " : "DPI based zoom factor set to ") + constants.guiDPIFactor.toFixed(1));
    logForm.log("Reported window inner size =" + window.innerWidth.toString() + "x" + window.innerHeight.toString() + "px");
    YWebPage.applicationGlobalinit();
    sensorsManager.run();
    YWebPage.loadFromXML(xmlData);
    constants.edited = false;
    YWebPage.CheckForNewVersion(false);
  }
  static async pageIsleaving(e) {
    if (!e.persistent) {
      if (constants.edited) {
        await YWebPage.save(false);
        await YAPI.FreeAPI();
      }
    }
  }
  static refreshEditor() {
    if (YWebPage.readonly)
      return;
    if (YWebPage._editor == null)
      return;
    YWebPage._editor.refresh();
  }
  static EditObject(widget, structData, setvalueCallBack, getvalueCallBack, EditStoppedCallBack) {
    if (YWebPage.readonly)
      return;
    if (YWebPage._editor == null)
      return;
    YWebPage._editor.showWindow(widget, structData, setvalueCallBack, getvalueCallBack, EditStoppedCallBack);
  }
  static get_XmlData() {
    let XmlConfigFile = `<?xml version="1.0" ?>
<!--
   **************************************************
   Yocto-Visualization (for web)  configuration file
   **************************************************
-->
<ROOT version='2.1'>
<!-- in 2.1 version, floating point values are saved in CultureInfo.InvariantCulture form -->
`;
    XmlConfigFile += constants.GetXMLConfiguration();
    for (let i = 0; i < YWebPage.widgets.length; i++) {
      if (YWebPage.widgets[i] instanceof graphWidget)
        XmlConfigFile += YWebPage.widgets[i].getConfigData();
      if (YWebPage.widgets[i] instanceof angularGaugeWidget)
        XmlConfigFile += YWebPage.widgets[i].getConfigData();
      if (YWebPage.widgets[i] instanceof gaugeWidget)
        XmlConfigFile += YWebPage.widgets[i].getConfigData();
      if (YWebPage.widgets[i] instanceof digitalDisplayWidget)
        XmlConfigFile += YWebPage.widgets[i].getConfigData();
    }
    XmlConfigFile += sensorsManager.getXMLSensorsConfig();
    XmlConfigFile += "</ROOT>\n";
    return XmlConfigFile;
  }
  static get readonly() {
    let res = true;
    res = YWebPage._saveFunction == null;
    return res;
  }
  static async runInternalTest() {
  }
  static async save(force) {
    if (YWebPage.readonly)
      return true;
    let xml = this.get_XmlData();
    let newCRC = constants.crc32(xml);
    if (!force && newCRC == YWebPage.xmlDataCRC)
      return true;
    let saveDoneCallback = (ok, message) => {
      let div = document.createElement("DIV");
      div.style.position = "Fixed";
      div.style.left = "5px";
      div.style.top = "5px";
      div.style.padding = "2px 5px 2px 5px";
      div.style.margin = "2px 2px 2px 2px";
      div.style.border = "1px solid darkgreen";
      div.style.fontFamily = "Arial";
      div.style.fontSize = (12 * constants.guiDPIFactor).toString();
      div.style.whiteSpace = "nowrap";
      div.style.zIndex = "200000";
      div.style.textAlign = "center";
      div.style.opacity = "1";
      let fgcolor = ok ? "darkgreen" : "darkred";
      let bgcolor = ok ? "#b9eea9" : "#eea9a9";
      div.style.opacity = "1";
      div.style.backgroundColor = bgcolor;
      div.style.border = "1px solid " + fgcolor;
      div.style.color = fgcolor;
      div.innerText = message;
      document.body.appendChild(div);
      setTimeout(() => {
        YWebPage.handleSavedNotification(div);
      }, 100);
    };
    try {
      if (YWebPage._saveFunction != null) {
        return await YWebPage._saveFunction(this.get_XmlData(), saveDoneCallback);
      }
    } catch (e) {
      saveDoneCallback(false, "Save failed");
      alert2.show("Configuration save failed, sorry\n" + e.message);
      return false;
    }
    YWebPage.xmlDataCRC = newCRC;
    logForm.log("Configuration saved.");
    constants.edited = false;
    return true;
  }
  static handleSavedNotification(div) {
    let opacity = parseFloat(div.style.opacity) - 0.05;
    if (opacity < 0) {
      document.body.removeChild(div);
      return;
    }
    div.style.opacity = opacity.toString();
    setTimeout(() => {
      YWebPage.handleSavedNotification(div);
    }, 100);
  }
  static Dummysave(xml) {
    let contents = document.createElement("PRE");
    contents.innerText = xml;
    document.body.appendChild(contents);
    return true;
  }
};
YWebPage.baseSize = 18 * constants.generalSizeCoef;
YWebPage.xmlDataCRC = 0;
YWebPage.widgets = [];
YWebPage._markersSubMenuItems = [];
YWebPage._editor = null;
YWebPage._mainform = null;
YWebPage._saveFunction = null;
YWebPage._MarkerCountPerXaxis = 0;
YWebPage.ConfigChangedConfirmWindows = null;
YWebPage.saveIntDiv = null;
var HTTPrequestResult = class {
  constructor(data, status, statusText) {
    this._data = data;
    this._status = status;
    this._statusText = statusText;
  }
  get data() {
    return this._data;
  }
  get status() {
    return this._status;
  }
  get statusText() {
    return this._statusText;
  }
};
var HubInfo = class {
  get protocol() {
    return this._protocol;
  }
  get addr() {
    return this._addr;
  }
  get port() {
    return this._port;
  }
  get path() {
    return this._path;
  }
  get userPassword() {
    return this._userPassword;
  }
  get adminPassword() {
    return this._adminPassword;
  }
  get serial() {
    return this._serial;
  }
  get srvUsername() {
    return this._srvusername != null ? this._srvusername : "";
  }
  get srvPassword() {
    return this._srvpassword != null ? this._srvpassword : "";
  }
  constructor(protocol, addr, port, path, srvusername, srvpassword) {
    this._userPassword = false;
    this._adminPassword = false;
    this._cred = "";
    this._serial = "";
    this._srvusername = null;
    this._srvpassword = null;
    if (protocol.slice(-1) == ":")
      protocol = protocol.slice(0, -1);
    this._protocol = protocol;
    this._addr = addr;
    this._port = port;
    this._protocol = protocol;
    this._path = path;
    if (srvusername !== void 0)
      this._srvusername = srvusername;
    if (srvpassword !== void 0)
      this._srvpassword = srvpassword;
    if (this._path != "") {
      if (this._path.charAt(0) == "/") {
        this._path = this._path.slice(1);
      }
    }
    if (this._path != "") {
      if (this._path.slice(-1) == "/") {
        this._path = this._path.slice(0, -1);
      }
    }
  }
  get_hubUrl(user, password) {
    let url = this.protocol + "://";
    if (typeof user != "undefined" && user != "") {
      if (user != "") {
        url += user + ":" + password + "@";
      }
    }
    url += this.addr + ":" + this.port.toString();
    if (this.path != "")
      url += "/" + this.path;
    return url;
  }
  async makeRequest() {
    let url = this._protocol + "://" + this._addr + ":" + this._port.toString();
    if (this._path != "")
      url += "/" + this._path;
    url += "/info.json";
    let response;
    try {
      response = await fetch(url, {mode: "cors"});
    } catch (e) {
      return -3;
    }
    if (response.ok) {
      let HubData;
      try {
        HubData = await response.json();
      } catch (e) {
        return -1;
      }
      if (HubData.port && HubData.port.length > 0) {
        let proto_port = HubData.port[0].split(":");
        this._protocol = proto_port[0];
        this._port = parseInt(proto_port[1]);
      }
      this._serial = HubData.serialNumber;
      this._path = HubData.dir;
      this._adminPassword = HubData.adminPassword.toUpperCase() == "TRUE";
      this._userPassword = HubData.userPassword.toUpperCase() == "TRUE";
      return true;
    }
    if (response.status == 404 && this._path != "")
      return -2;
    if (response.status == 0 && response.statusText == null)
      return -3;
    return response.status;
  }
  findChild(parent, name) {
    let res = null;
    parent.childNodes.forEach((node) => {
      if (node.nodeName == name) {
        res = node;
        return;
      }
    });
    return res;
  }
  findOutCredentialsFromConfigFile(xmlData) {
    if (xmlData == null)
      return;
    let parser = new DOMParser();
    let doc = parser.parseFromString(xmlData, "application/xml");
    let rootNode = this.findChild(doc, "ROOT");
    if (rootNode == null)
      return;
    let configNode = this.findChild(rootNode, "Config");
    if (configNode == null)
      return;
    let Hubs = this.findChild(configNode, "Hubs");
    if (Hubs == null)
      return;
    let HubSection;
    let list = Hubs.childNodes;
    let sourceHubFound = false;
    for (let i = 0; i < list.length; i++) {
      if (list[i].nodeName == "Hub") {
        let node = new YXmlNode(list[i]);
        let attributes = node.Attributes;
        let addr = attributes.hasOwnProperty("addr") ? attributes["addr"] : "";
        let port = attributes.hasOwnProperty("port") ? attributes["port"] : "80";
        let protocol = attributes.hasOwnProperty("protocol") ? attributes["protocol"] : "";
        let path = attributes.hasOwnProperty("path") ? attributes["path"] : "";
        let username = attributes.hasOwnProperty("user") ? attributes["user"] : "";
        let password = attributes.hasOwnProperty("password") ? attributes["password"] : "";
        let a1 = addr.toUpperCase();
        if (a1.substring(0, 4) == "WWW.")
          a1 = a1.substring(4);
        let a2 = this._addr.toUpperCase();
        if (a2.substring(0, 4) == "WWW.")
          a2 = a2.substring(4);
        if (a1 == a2 && path == this._path) {
          this._srvusername = username;
          this._srvpassword = Hub.Decrypt(password, Hub.loginCypherPassword);
        }
      }
    }
  }
};
var YoctoHubFileHandler = class {
  constructor(hubInfo) {
    this.filename = "";
    this.xmldata = "";
    this.htmlSrcCode = "";
    this.FileSystemAccessDenied = false;
    this._XMLConfigFileChanged = null;
    this.fileSystem = null;
    this.fileSystemReady = false;
    this.configFileCRC = -1;
    this.info = hubInfo;
  }
  async init(defaultXmlConfigFileContents) {
    let url = location.href;
    this.filename = url.substring(url.lastIndexOf("/") + 1);
    let p = this.filename.indexOf("?");
    if (p > 0)
      this.filename = this.filename.substring(0, p);
    this.htmlSrcCode = document.documentElement.outerHTML;
    if (typeof defaultXmlConfigFileContents === "undefined" || defaultXmlConfigFileContents == "") {
      this.xmldata = '<?xml version="1.0" ?>\n<ROOT version="2.1">\n<Config>\n<Hubs>\n<Hub protocol="' + this.info.protocol + '" addr="' + this.info.addr + '" port="' + this.info.port.toString() + '"' + (this.info.path != "" ? ' path="' + this.info.path + '"' : "") + ' removable="FALSE"/>\n</Hubs>\n</Config>\n</ROOT>\n';
    } else {
      this.xmldata = defaultXmlConfigFileContents;
    }
    this.fileSystem = null;
    this.fileSystemReady = false;
    await this.findSourceFileSystem(defaultXmlConfigFileContents);
  }
  static async start(defaultXmlConfigFileContents) {
    let dirpath = location.pathname;
    let defport = "80";
    let slashpos = dirpath.lastIndexOf("/");
    if (slashpos > 0) {
      dirpath = dirpath.slice(0, slashpos);
    } else {
      dirpath = "";
    }
    if (location.protocol == "https:") {
      defport = "443";
    }
    let hubinfo = new HubInfo(location.protocol, location.hostname, parseInt(location.port ? location.port : defport), dirpath);
    await hubinfo.makeRequest();
    let filehandler = new YoctoHubFileHandler(hubinfo);
    await filehandler.init(defaultXmlConfigFileContents);
    return filehandler;
  }
  get xmlConfigData() {
    return this.xmldata;
  }
  static makeRequest(method, url, username, password) {
    return new Promise(function(resolve, reject) {
      let xhr = new XMLHttpRequest();
      if (username !== void 0 && password !== void 0 && username != null && password !== null) {
        xhr.open(method, url, true, username, password);
        xhr.withCredentials = true;
      } else {
        xhr.open(method, url);
      }
      xhr.overrideMimeType("text/plain; charset=x-user-defined");
      xhr.onreadystatechange = function() {
        if (xhr.readyState == 4) {
          if (this.status >= 200 && this.status < 300) {
            resolve(new HTTPrequestResult(YAPI.imm_str2bin(xhr.response), this.status, xhr.statusText));
          } else {
            resolve(new HTTPrequestResult(null, this.status, xhr.statusText));
          }
        }
      };
      xhr.onerror = function() {
        resolve(new HTTPrequestResult(null, this.status, xhr.statusText));
      };
      xhr.send();
    });
  }
  async findSourceFileSystem(xmldata) {
    this.fileSystem = null;
    let errmsg = new YErrorMsg();
    this.info.findOutCredentialsFromConfigFile(xmldata);
    let url = this.info.get_hubUrl(this.info.srvUsername, this.info.srvPassword);
    try {
      await YAPI.RegisterHub(url, errmsg);
    } catch (e) {
      this.fileSystemReady = false;
      if (e.errorType == YAPI.UNAUTHORIZED) {
        console.log("Access to hub " + url + " is denied, waiting for YV callback to save the situation.");
        this.FileSystemAccessDenied = true;
        return;
      }
      throw "YV4F ERROR: Unable to register Hub " + this.info.get_hubUrl() + "(" + e.message + "), save will not work.";
    }
    let fs = YFiles.FirstFiles();
    if (fs == null) {
      this.fileSystemReady = true;
      throw "YV4F ERROR: No file system found on Hub " + this.info.get_hubUrl() + ", save will not work.";
    }
    while (fs != null) {
      if (await fs.get_serialNumber() == this.info.serial) {
        await this.registerSourceFileSystem(fs);
        return;
      }
      fs = fs.nextFiles();
    }
    fs = YFiles.FirstFiles();
    while (fs != null) {
      let m = await fs.get_module();
      let url2 = await m.get_url();
      console.log("URL = (" + url2 + ")");
      let p = url2.indexOf("://");
      if (p >= 0)
        url2 = url2.slice(p + 3);
      p = url2.indexOf(":");
      if (p > 0)
        url2 = url2.slice(0, p);
      {
        if (url2 == this.info.addr) {
          await this.registerSourceFileSystem(fs);
          return;
        }
      }
      fs = fs.nextFiles();
    }
    this.fileSystemReady = true;
    throw "YV4F ERROR: No file system matching Hub " + this.info.get_hubUrl() + " found, save will not work.";
  }
  async registerSourceFileSystem(fs) {
    this.fileSystem = fs;
    this.fileSystemReady = true;
    this.FileSystemAccessDenied = false;
    let entries = await this.fileSystem.get_list(this.filename);
    if (entries.length > 0)
      this.configFileCRC = await entries[0].get_crc();
  }
  async configChangeCallback(m) {
    if (this.fileSystem == null) {
      let urlSignature = this.info.addr + ":" + this.info.port.toString() + "/" + this.info.path + (this.info.path != "" ? "/" : "");
      let sourceUrl = await m.get_url();
      console.log("urlSignature=" + urlSignature);
      console.log("sourceUrl=" + sourceUrl);
      if (sourceUrl.length > urlSignature.length && sourceUrl.substring(sourceUrl.length - urlSignature.length) == urlSignature) {
        let fs = YFiles.FindFiles(await m.get_serialNumber() + ".files");
        if (await fs.isOnline())
          await this.registerSourceFileSystem(fs);
      }
    }
    if (this.fileSystem == null)
      return null;
    if (await this.fileSystem.get_serialNumber() != await m.get_serialNumber())
      return null;
    let entries = await this.fileSystem.get_list(this.filename);
    if (entries.length <= 0)
      return null;
    if (this.configFileCRC == await entries[0].get_crc())
      return null;
    let data = await this.fileSystem.download(this.filename);
    let file = new TextDecoder("utf-8").decode(data);
    let indexStart = file.indexOf(YoctoHubFileHandler.signatureStart);
    if (indexStart < 0)
      return null;
    this.configFileCRC = await entries[0].get_crc();
    indexStart += YoctoHubFileHandler.signatureStart.length;
    let indexEnd = file.indexOf(YoctoHubFileHandler.signatureEnd);
    if (indexEnd < indexStart)
      return "";
    indexEnd += YoctoHubFileHandler.signatureEnd.length - 2;
    let configdata = file.substring(indexStart, indexEnd);
    try {
      return JSON.parse(configdata);
    } catch (e) {
    }
    return null;
  }
  get configChangeCallbackFct() {
    return async (module) => {
      return await this.configChangeCallback(module);
    };
  }
  get saveFct() {
    return async (xml, callback) => {
      return await this.saveFctinternal(xml, callback);
    };
  }
  async retryWithNewCredentials(xml, username, password, callback) {
    if (this.fileSystem == null) {
      debugger;
      return;
    }
    let m = await this.fileSystem.get_module();
    let url = await m.get_url();
    let err = new YErrorMsg();
    let p1 = url.indexOf("://");
    let p2 = url.indexOf("@", p1 + 3);
    let newurl = url.substring(0, p1 + 3) + username + ":" + password + "@";
    if (p2 < 0)
      newurl += url.substring(p1 + 3);
    else
      newurl += url.substring(p2 + 1);
    await YAPI.UnregisterHub(url);
    if (await YAPI.RegisterHub(newurl, err) != YAPI.SUCCESS) {
      await YAPI.RegisterHub(url, err);
    }
    try {
      if (!await this.saveFctinternal(xml, callback))
        return;
    } catch (e) {
      if (callback != null)
        callback(false, "Save failed (" + e.message) + ")";
      return;
    }
  }
  async saveFctinternal(xml, callback) {
    if (this.FileSystemAccessDenied) {
      throw "YV4F ERROR: Access to file system on " + this.info.get_hubUrl() + " is denied, it is probably password protected. Check network connections in the global configuration.";
    }
    if (this.fileSystem == null) {
      throw "YV4F ERROR: No file system, Save aborted";
    }
    if (!this.fileSystemReady) {
      throw "YV4F ERROR: File system is not ready yet, retry in a few seconds.";
    }
    if (!this.fileSystem.isOnline()) {
      throw "YV4F ERROR: File system is off line, Save aborted";
    }
    let tosave = "";
    let index = this.htmlSrcCode.indexOf(YoctoHubFileHandler.signatureStart + ")");
    if (index > 0) {
      tosave = this.htmlSrcCode.substring(0, index + YoctoHubFileHandler.signatureStart.length) + JSON.stringify(xml) + this.htmlSrcCode.substring(index + YoctoHubFileHandler.signatureStart.length);
    } else {
      let index1 = this.htmlSrcCode.indexOf(YoctoHubFileHandler.signatureStart);
      let index2 = this.htmlSrcCode.indexOf(YoctoHubFileHandler.signatureEnd);
      if (index1 > 0 && index2 && index2 > index1) {
        tosave = this.htmlSrcCode.substring(0, index1 + YoctoHubFileHandler.signatureStart.length) + JSON.stringify(xml) + ");" + this.htmlSrcCode.substring(index2 + YoctoHubFileHandler.signatureEnd.length);
      } else {
        throw "Unable to locate YoctoHubFileHandler constructor call in original HTML file.";
      }
    }
    tosave = "<!DOCTYPE html>\n" + tosave;
    let GZdata = Pako_Deflate.gzip(tosave, {level: 9});
    let askForRwCredentials = false;
    try {
      await this.fileSystem.upload(this.filename + ".gz", GZdata);
    } catch (e) {
      if (this.fileSystem.get_errorType() == YAPI_UNAUTHORIZED)
        askForRwCredentials = true;
      else
        throw e;
    }
    if (askForRwCredentials) {
      let m = await this.fileSystem.get_module();
      let url = await m.get_url();
      let err = new YErrorMsg();
      let p1 = url.indexOf("://");
      let p2 = url.indexOf("@", p1 + 3);
      if (p2 >= 0)
        url = url.substring(p2 + 1);
      else if (p1 >= 0)
        url = url.substring(p1 + 3);
      await CredentialsPrompt.show(url, async () => {
        await this.retryWithNewCredentials(xml, CredentialsPrompt.username, CredentialsPrompt.password, callback);
      });
      if (callback != null)
        callback(false, "Save failed, credentials required");
      return false;
    }
    let entries = await this.fileSystem.get_list(this.filename);
    if (entries.length > 0)
      this.configFileCRC = await entries[0].get_crc();
    if (callback != null)
      callback(true, "Save sucessfull");
    return true;
  }
};
YoctoHubFileHandler.signatureStart = "YoctoHubFileHandler.start(";
YoctoHubFileHandler.signatureEnd = '</ROOT>\\n");';

// obj/full/logForm.js
var logForm = class {
  static show() {
    if (logForm._window == null) {
      let params = new newWindowParam();
      params.positionType = 0;
      params.width = 8 * window.innerWidth / 10 >> 0;
      params.height = 6 * window.innerHeight / 10 >> 0;
      params.left = 1 * window.innerWidth / 10 >> 0;
      params.top = 2 * window.innerHeight / 10 >> 0;
      params.title = "LogFile";
      logForm._window = new YWindow(params);
      logForm._contents = logForm._window.innerContentDiv;
      logForm._contents.style.fontFamily = "courrier";
      logForm._contents.style.fontSize = (10 * constants.generalSizeCoef).toString() + "px";
      logForm._contents.style.overflow = "auto";
      for (let i = 0; i < logForm._lines.length; i++) {
        logForm.addLine(logForm._lines[i]);
      }
    }
    logForm._window.show();
  }
  static addLine(st) {
    let pre = document.createElement("PRE");
    pre.style.marginTop = "0";
    pre.style.marginBottom = "0";
    pre.innerText = st;
    logForm._contents.appendChild(pre);
    while (logForm._contents.childElementCount > 1e3) {
      logForm._contents.removeChild(logForm._contents.firstChild);
    }
  }
  static padStart(st, length) {
    while (st.length < length) {
      st = "0" + st;
    }
    return st;
  }
  static dateToString(d) {
    return d.getFullYear().toString() + "-" + logForm.padStart((d.getMonth() + 1).toString(), 2) + "-" + logForm.padStart(d.getDate().toString(), 2) + " " + logForm.padStart(d.getHours().toString(), 2) + ":" + logForm.padStart(d.getMinutes().toString(), 2) + ":" + logForm.padStart((d.getSeconds() + d.getMilliseconds() / 1e3).toFixed(3), 6);
  }
  static log(st) {
    logForm.logNOTS(logForm.dateToString(new Date()) + " " + st);
  }
  static logNOTS(st) {
    logForm._lines.push(st);
    if (logForm._lines.length > 1e3) {
      logForm._lines.splice(0, logForm._lines.length - 1e3);
    }
    if (logForm._window != null)
      logForm.addLine(st);
  }
};
logForm._lines = [];

// obj/full/rawDataForm.js
var rawDataForm = class {
  static hide() {
    if (rawDataForm._window == null)
      return;
    rawDataForm._window.visible = false;
  }
  static show() {
    if (rawDataForm._window == null) {
      let params = new newWindowParam();
      params.positionType = 1;
      params.width = 9 * window.innerWidth / 10 >> 0;
      params.height = 8 * window.innerHeight / 10 >> 0;
      params.title = "Raw data";
      rawDataForm._window = new YWindow(params);
      rawDataForm._contents = rawDataForm._window.innerContentDiv;
      rawDataForm._statusline = document.createElement("DIV");
      rawDataForm._statusline.style.position = "absolute";
      rawDataForm._statusline.style.left = constants.WindowPadding.toString() + "px";
      rawDataForm._statusline.style.right = constants.WindowPadding.toString() + "px";
      rawDataForm._statusline.style.height = (rawDataForm.STATUSLINEHEIGHT * constants.generalSizeCoef).toString() + "px";
      rawDataForm._statusline.style.bottom = constants.WindowPadding.toString() + "px";
      rawDataForm._statusline.style.paddingTop = Math.round(5 * constants.generalSizeCoef).toString() + "px";
      rawDataForm._statusline.style.paddingLeft = "5px";
      rawDataForm._statusline.style.paddingRight = "5px";
      rawDataForm._statusline.style.overflowX = "auto";
      rawDataForm._statusline.style.paddingRight = "5px";
      rawDataForm._contents.append(rawDataForm._statusline);
      rawDataForm._sensorsList = document.createElement("DIV");
      rawDataForm._sensorsList.style.position = "absolute";
      rawDataForm._sensorsList.style.left = constants.WindowPadding.toString() + "px";
      rawDataForm._sensorsList.style.right = (rawDataForm.sensorListWidth * constants.generalSizeCoef + 8 * constants.WindowPadding).toString() + "px";
      rawDataForm._sensorsList.style.top = "2px";
      rawDataForm._sensorsList.style.overflowY = "auto";
      rawDataForm._sensorsList.style.height = (rawDataForm.topMargin * constants.generalSizeCoef).toString() + "px";
      rawDataForm._sensorsList.style.paddingLeft = "5px";
      rawDataForm._sensorsList.style.paddingRight = "5px";
      rawDataForm._sensorsList.style.border = constants.WindowInnerBorder;
      rawDataForm._sensorsList.style.backgroundColor = constants.WindowInnerBackgroundColor;
      rawDataForm._contents.append(rawDataForm._sensorsList);
      rawDataForm._optionsList = document.createElement("DIV");
      rawDataForm._optionsList.style.position = "absolute";
      rawDataForm._optionsList.style.width = (rawDataForm.sensorListWidth * constants.generalSizeCoef).toString() + "px";
      rawDataForm._optionsList.style.right = constants.WindowPadding.toString() + "px";
      rawDataForm._optionsList.style.top = "0px";
      rawDataForm._optionsList.style.height = (rawDataForm.topMargin * constants.generalSizeCoef).toString() + "px";
      rawDataForm._optionsList.style.paddingLeft = "5px";
      rawDataForm._optionsList.style.paddingRight = "5px";
      rawDataForm._optionsList.style.border = "1px solid transparent";
      rawDataForm._contents.append(rawDataForm._optionsList);
      let br;
      rawDataForm._optionMIN = document.createElement("INPUT");
      rawDataForm._optionMIN.type = "input";
      rawDataForm._optionMIN.checked = false;
      rawDataForm._optionMIN.style.display = "inline";
      rawDataForm._optionMIN.type = "checkbox";
      rawDataForm._optionMIN.style.transform = "scale(" + constants.generalSizeCoef.toString() + ")";
      rawDataForm._optionMIN.style.marginRight = Math.round(5 * constants.generalSizeCoef).toString() + "px";
      rawDataForm._optionMIN.addEventListener("change", () => {
        rawDataForm.refresh();
      });
      rawDataForm._optionsList.append(rawDataForm._optionMIN);
      let span;
      span = document.createElement("SPAN");
      span.innerText = "Include minimum values";
      rawDataForm._optionsList.append(span);
      br = document.createElement("BR");
      rawDataForm._optionsList.append(br);
      rawDataForm._optionAVG = document.createElement("INPUT");
      rawDataForm._optionAVG.type = "input";
      rawDataForm._optionAVG.checked = true;
      rawDataForm._optionAVG.style.display = "inline";
      rawDataForm._optionAVG.type = "checkbox";
      rawDataForm._optionAVG.style.transform = "scale(" + constants.generalSizeCoef.toString() + ")";
      rawDataForm._optionAVG.style.marginRight = Math.round(5 * constants.generalSizeCoef).toString() + "px";
      rawDataForm._optionAVG.addEventListener("change", () => {
        rawDataForm.refresh();
      });
      rawDataForm._optionsList.append(rawDataForm._optionAVG);
      span = document.createElement("SPAN");
      span.innerText = "Include average values";
      rawDataForm._optionsList.append(span);
      br = document.createElement("BR");
      rawDataForm._optionsList.append(br);
      rawDataForm._optionMAX = document.createElement("INPUT");
      rawDataForm._optionMAX.type = "input";
      rawDataForm._optionMAX.checked = false;
      rawDataForm._optionMAX.style.display = "inline";
      rawDataForm._optionMAX.type = "checkbox";
      rawDataForm._optionMAX.style.transform = "scale(" + constants.generalSizeCoef.toString() + ")";
      rawDataForm._optionMAX.style.marginRight = Math.round(5 * constants.generalSizeCoef).toString() + "px";
      rawDataForm._optionMAX.addEventListener("change", () => {
        rawDataForm.refresh();
      });
      rawDataForm._optionsList.append(rawDataForm._optionMAX);
      span = document.createElement("SPAN");
      span.innerText = "Include maximum values";
      rawDataForm._optionsList.append(span);
      rawDataForm._optionsList.append(document.createElement("BR"));
      rawDataForm._optionsList.append(document.createElement("BR"));
      let p = document.createElement("P");
      p.style.textAlign = "center";
      let refreshBtn = new button("refresh", () => {
        rawDataForm.refresh();
      });
      p.appendChild(refreshBtn.Element);
      let ExportBtn = new button("export", () => {
        rawDataForm.export();
      });
      p.appendChild(ExportBtn.Element);
      rawDataForm._optionsList.append(p);
      rawDataForm._datacontents = document.createElement("DIV");
      rawDataForm._datacontents.style.position = "absolute";
      rawDataForm._datacontents.style.left = constants.WindowPadding.toString() + "px";
      rawDataForm._datacontents.style.right = constants.WindowPadding.toString() + "px";
      rawDataForm._datacontents.style.top = (rawDataForm.topMargin * constants.generalSizeCoef + 5 * constants.WindowPadding).toString() + "px";
      rawDataForm._datacontents.style.bottom = (4 * constants.WindowPadding + rawDataForm.STATUSLINEHEIGHT * constants.generalSizeCoef).toString() + "px";
      rawDataForm._datacontents.style.paddingLeft = "5px";
      rawDataForm._datacontents.style.paddingRight = "5px";
      rawDataForm._datacontents.style.overflowX = "auto";
      rawDataForm._datacontents.style.paddingRight = "5px";
      rawDataForm._contents.append(rawDataForm._datacontents);
      rawDataForm._dataTable = document.createElement("TABLE");
      rawDataForm._dataTable.style.position = "absolute";
      rawDataForm._dataTable.style.overflow = "auto";
      rawDataForm._dataTable.style.left = "0px";
      rawDataForm._dataTable.style.width = "100%";
      rawDataForm._dataTable.style.top = "0px";
      rawDataForm._dataTable.style.bottom = "0px";
      rawDataForm._dataTable.style.fontSize = constants.generalFontSize.toString() + "px";
      rawDataForm._dataTable.style.borderCollapse = "colapse";
      rawDataForm._dataTable.style.borderSpacing = "0px";
      rawDataForm._dataTable.style.fontFamily = "sans-serif";
      rawDataForm._datacontents.appendChild(rawDataForm._dataTable);
    }
    rawDataForm._window.show();
    rawDataForm.refresh();
  }
  static refresh() {
    let list = [];
    for (let i = 0; i < sensorsManager.sensorList.length; i++) {
      if (!(sensorsManager.sensorList[i] instanceof NullYSensor)) {
        list.push(sensorsManager.sensorList[i]);
      }
    }
    rawDataForm._selection = [];
    for (let i = 0; i < list.length; i++) {
      let spanNode;
      let spanText;
      let input;
      if (i >= rawDataForm._sensorsList.childNodes.length) {
        spanNode = document.createElement("SPAN");
        input = document.createElement("INPUT");
        input.type = "input";
        input.checked = false;
        input.style.display = "inline";
        input.type = "checkbox";
        input.style.transform = "scale(" + constants.generalSizeCoef.toString() + ")";
        input.style.marginRight = Math.round(5 * constants.generalSizeCoef).toString() + "px";
        input.addEventListener("change", () => {
          rawDataForm.refresh();
        });
        spanNode.appendChild(input);
        spanText = document.createElement("SPAN");
        spanNode.appendChild(spanText);
        rawDataForm._sensorsList.appendChild(spanNode);
        spanNode.appendChild(document.createElement("BR"));
      } else {
        spanNode = rawDataForm._sensorsList.childNodes[i];
        input = spanNode.childNodes[0];
        spanText = spanNode.childNodes[1];
      }
      if (input.checked)
        rawDataForm._selection.push(list[i]);
      input.id = list[i].get_hardwareId();
      spanText.innerText = list[i].get_friendlyName();
    }
    while (rawDataForm._sensorsList.childNodes.length > list.length) {
      rawDataForm._sensorsList.removeChild(rawDataForm._sensorsList.lastChild);
    }
    rawDataForm.RefreshContents(rawDataForm._selection);
  }
  static padStart(st, length) {
    while (st.length < length) {
      st = "0" + st;
    }
    return st;
  }
  static UnixTimeStampTostring(ts) {
    let d = new Date(Date.UTC(1970, 0, 1));
    d.setUTCSeconds(ts >> 0, 1e3 * (ts % 1));
    return d.getFullYear().toString() + "-" + rawDataForm.padStart((d.getMonth() + 1).toString(), 2) + "-" + rawDataForm.padStart(d.getDate().toString(), 2) + " " + rawDataForm.padStart(d.getHours().toString(), 2) + ":" + rawDataForm.padStart(d.getMinutes().toString(), 2) + ":" + rawDataForm.padStart((d.getSeconds() + d.getMilliseconds() / 1e3).toFixed(3), 6);
  }
  static RefreshContents(slist) {
    let TH = document.createElement("THEAD");
    let TB = document.createElement("TBODY");
    let HR1 = document.createElement("TR");
    let HR2 = document.createElement("TR");
    let indexes = [];
    for (let i = 0; i < slist.length; i++) {
      indexes.push(slist[i].curData.length - 1);
    }
    while (rawDataForm._dataTable.childNodes.length > 0) {
      rawDataForm._dataTable.removeChild(rawDataForm._dataTable.lastChild);
    }
    rawDataForm._dataTable.appendChild(TH);
    rawDataForm._dataTable.appendChild(TB);
    let sMin = false;
    let sMax = false;
    let sAvg = false;
    let toShow = 0;
    if (rawDataForm._optionMIN.checked) {
      sMin = true;
      toShow++;
    }
    if (rawDataForm._optionAVG.checked) {
      sAvg = true;
      toShow++;
    }
    if (rawDataForm._optionMAX.checked) {
      sMax = true;
      toShow++;
    }
    TH.appendChild(HR1);
    TH.appendChild(HR2);
    let cell = document.createElement("TH");
    HR1.appendChild(cell);
    cell = document.createElement("TH");
    HR2.appendChild(cell);
    for (let i = 0; i < slist.length; i++) {
      cell = document.createElement("TH");
      cell.innerText = slist[i].get_friendlyName();
      cell.colSpan = Math.max(1, toShow);
      cell.style.backgroundColor = "#f0f0f0";
      cell.style.borderLeft = constants.WindowInnerBorder;
      cell.style.borderRight = constants.WindowInnerBorder;
      cell.style.borderTop = constants.WindowInnerBorder;
      HR1.appendChild(cell);
      if (sMin) {
        cell = document.createElement("TH");
        cell.innerText = "Min";
        cell.style.borderLeft = constants.WindowInnerBorder;
        cell.style.borderRight = sAvg || sMax ? "" : constants.WindowInnerBorder;
        cell.style.backgroundColor = "#f0f0f0";
        cell.style.textAlign = "right";
        HR2.appendChild(cell);
      }
      if (sAvg) {
        cell = document.createElement("TH");
        cell.innerText = "Avg";
        cell.style.borderLeft = sMin ? "" : constants.WindowInnerBorder;
        cell.style.borderRight = sMax ? "" : constants.WindowInnerBorder;
        cell.style.backgroundColor = "#f0f0f0";
        cell.style.textAlign = "right";
        HR2.appendChild(cell);
      }
      if (sMax) {
        cell = document.createElement("TH");
        cell.innerText = "Max";
        cell.style.borderLeft = sAvg || sMin ? "" : constants.WindowInnerBorder;
        cell.style.borderRight = constants.WindowInnerBorder;
        cell.style.backgroundColor = "#f0f0f0";
        cell.style.textAlign = "right";
        HR2.appendChild(cell);
      }
    }
    let colcount = slist.length * toShow;
    let MaxTimeStamp = 0;
    for (let i = 0; i < slist.length; i++) {
      if (indexes[i] >= 0) {
        if (MaxTimeStamp < slist[i].curData[indexes[i]].DateTime) {
          MaxTimeStamp = slist[i].curData[indexes[i]].DateTime;
        }
      }
    }
    let rowcount = 0;
    let currentRow = null;
    while (MaxTimeStamp > 0 && rowcount < rawDataForm.MAXRAWDATAROWS) {
      let row = new Array(colcount);
      let nextTimeStamp = 0;
      for (let i = 0; i < slist.length; i++) {
        let Shown = false;
        if (indexes[i] >= 0) {
          if (slist[i].curData[indexes[i]].DateTime == MaxTimeStamp) {
            let n = 0;
            if (sMin) {
              row[n + i * toShow] = slist[i].minData[indexes[i]].value.toString();
              n++;
            }
            if (sAvg) {
              row[n + i * toShow] = slist[i].curData[indexes[i]].value.toString();
              n++;
            }
            if (sMax) {
              row[n + i * toShow] = slist[i].maxData[indexes[i]].value.toString();
              n++;
            }
            Shown = true;
            indexes[i]--;
          }
          if (indexes[i] >= 0) {
            if (slist[i].curData[indexes[i]].DateTime > nextTimeStamp) {
              nextTimeStamp = slist[i].curData[indexes[i]].DateTime;
            }
          }
        }
        if (!Shown) {
          let n = 0;
          if (sMin) {
            row[n + i * toShow] = "";
            n++;
          }
          if (sAvg) {
            row[n + i * toShow] = "";
            n++;
          }
          if (sMax) {
            row[n + i * toShow] = "";
            n++;
          }
        }
      }
      if (colcount > 0 && toShow > 0) {
        currentRow = document.createElement("TR");
        let cell2 = document.createElement("TD");
        cell2.innerText = rawDataForm.UnixTimeStampTostring(MaxTimeStamp).toLocaleString();
        cell2.style.borderLeft = constants.WindowInnerBorder;
        cell2.style.borderTop = rowcount == 0 ? constants.WindowInnerBorder : "";
        cell2.style.backgroundColor = "#f0f0f0";
        currentRow.style.backgroundColor = (rowcount & 1) == 0 ? "white" : "#f0f0f0";
        currentRow.appendChild(cell2);
        for (let j = 0; j < row.length; j++) {
          cell2 = document.createElement("TD");
          cell2.innerText = row[j];
          cell2.style.textAlign = "right";
          cell2.style.borderLeft = j % toShow == 0 ? constants.WindowInnerBorder : "";
          cell2.style.borderRight = (j + 1) % toShow == 0 ? constants.WindowInnerBorder : "";
          cell2.style.fontFamily = "monospace";
          currentRow.appendChild(cell2);
        }
        TB.appendChild(currentRow);
        rowcount++;
      }
      MaxTimeStamp = nextTimeStamp;
    }
    if (currentRow != null) {
      for (let i = 0; i < currentRow.childNodes.length; i++) {
        currentRow.childNodes[i].style.borderBottom = constants.WindowInnerBorder;
      }
    }
    if (toShow == 0) {
      rawDataForm._statusline.style.backgroundColor = "#FF8080";
      rawDataForm._statusline.innerText = "No data shown, select at least Min, Avg or Max options in the top-right checkboxes";
    } else if (rowcount == 0) {
      rawDataForm._statusline.style.backgroundColor = "#FF8080";
      rawDataForm._statusline.innerText = "No data shown, select at least one sensor in the list above.";
    } else {
      rawDataForm._statusline.style.backgroundColor = constants.WindowBackgroundColor;
      if (rowcount < rawDataForm.MAXRAWDATAROWS) {
        rawDataForm._statusline.innerText = "These are the last " + rowcount.toString() + " data rows.";
      } else {
        rawDataForm._statusline.innerText = "These are the last " + rowcount.toString() + " data rows.  Use the export feature to get the whole data set.";
      }
    }
  }
  static getCvsdata(slist, sMin, sAvg, sMax) {
    let toShow = 0;
    let indexes = [];
    for (let i = 0; i < slist.length; i++) {
      indexes.push(0);
    }
    if (sMin)
      toShow++;
    if (sAvg)
      toShow++;
    if (sMax)
      toShow++;
    let res;
    let ColumnHeader = "Timestamp";
    for (let i = 0; i < slist.length; i++) {
      let sName = slist[i].toString();
      if (sMin)
        ColumnHeader += ";" + sName + "(min)";
      if (sAvg)
        ColumnHeader += ";" + sName + "(avg)";
      if (sMax)
        ColumnHeader += ";" + sName + "(max)";
    }
    res = ColumnHeader + "\r\n";
    let colcount = slist.length * toShow;
    let MinTimeStamp = Number.POSITIVE_INFINITY;
    for (let i = 0; i < slist.length; i++) {
      if (indexes[i] < slist[i].curData.length) {
        if (MinTimeStamp > slist[i].curData[indexes[i]].DateTime) {
          MinTimeStamp = slist[i].curData[indexes[i]].DateTime;
        }
      }
    }
    while (MinTimeStamp < Number.POSITIVE_INFINITY) {
      let line = "";
      let nextTimeStamp = Number.POSITIVE_INFINITY;
      for (let i = 0; i < slist.length; i++) {
        let Shown = false;
        if (indexes[i] < slist[i].curData.length) {
          if (slist[i].curData[indexes[i]].DateTime == MinTimeStamp) {
            if (sMin)
              line += ";" + slist[i].minData[indexes[i]].value.toString();
            if (sAvg)
              line += ";" + slist[i].curData[indexes[i]].value.toString();
            if (sMax)
              line += ";" + slist[i].maxData[indexes[i]].value.toString();
            Shown = true;
            indexes[i]++;
          }
          if (indexes[i] < slist[i].curData.length) {
            if (slist[i].curData[indexes[i]].DateTime < nextTimeStamp) {
              nextTimeStamp = slist[i].curData[indexes[i]].DateTime;
            }
          }
        }
        if (!Shown) {
          if (sMin)
            line += " ; ";
          if (sAvg)
            line += " ; ";
          if (sMax)
            line += " ; ";
        }
      }
      if (colcount > 0)
        line = rawDataForm.UnixTimeStampTostring(MinTimeStamp) + line;
      res += line + "\r\n";
      MinTimeStamp = nextTimeStamp;
    }
    return res;
  }
  static export() {
    let element = document.createElement("a");
    let data = "data:text/csv;charset=utf-8," + encodeURI(rawDataForm.getCvsdata(rawDataForm._selection, rawDataForm._optionMIN.checked, rawDataForm._optionAVG.checked, rawDataForm._optionMAX.checked));
    element.setAttribute("href", data);
    element.setAttribute("download", "rawdata.csv");
    element.style.display = "none";
    document.body.appendChild(element);
    element.click();
    document.body.removeChild(element);
  }
};
rawDataForm._lines = [];
rawDataForm.topMargin = 100;
rawDataForm.sensorListWidth = 200;
rawDataForm.MAXRAWDATAROWS = 100;
rawDataForm.STATUSLINEHEIGHT = 20;
rawDataForm._selection = [];

// obj/full/windowManager.js
var button = class {
  constructor(caption, action, sizeCoefOverload) {
    this._enabled = true;
    this._visible = true;
    this._caption = "";
    this._caption = caption;
    this._action = action;
    let GUIcoef = constants.generalSizeCoef;
    if (typeof sizeCoefOverload !== "undefined")
      GUIcoef = sizeCoefOverload;
    this._link = document.createElement("A");
    this._link.innerText = this._caption;
    this._link.style.cursor = "pointer";
    this._link.style.display = "inlineblock";
    let padding = Math.round(5 * GUIcoef).toString() + "px";
    let margin = Math.round(3 * GUIcoef).toString() + "px";
    this._link.tabIndex = 0;
    this._link.style.padding = padding + " " + padding + " " + padding + " " + padding;
    this._link.style.margin = margin + " " + margin + " " + margin + " " + margin;
    this._link.style.borderColor = "#808080";
    this._link.style.backgroundColor = "#f0f0f0";
    this._link.style.fontFamily = constants.generalFontFamily;
    this._link.style.fontSize = (16 * GUIcoef).toString() + "px";
    this._link.style.cursor = "pointer";
    this._link.style.border = constants.WindowInnerBorder;
    this._link.addEventListener("mouseover", () => {
      if (this._enabled)
        this._link.style.backgroundColor = "white";
    });
    this._link.addEventListener("mouseout", () => {
      if (this._enabled)
        this._link.style.backgroundColor = "#f0f0f0";
    });
    this._link.addEventListener("click", () => {
      if (this._enabled)
        this._action(this);
    });
    this._link.addEventListener("keypress", (e) => {
      if (this._enabled && (e.key == "Enter" || e.key == " "))
        this._action(this);
    });
  }
  get Element() {
    return this._link;
  }
  set tabIndex(index) {
    this._link.tabIndex = index;
  }
  focus() {
    this._link.focus();
  }
  get visible() {
    return this._visible;
  }
  set visible(value) {
    this._visible = value;
    this._link.style.display = this._visible ? "" : "none";
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    this.enable(value);
  }
  performAction() {
    if (!this._enabled)
      return;
    this._action(this);
  }
  showShortcut(enable) {
    if (!this._enabled)
      enable = false;
    if (enable) {
      this._link.innerHTML = "<u>" + this._caption.substring(0, 1) + "</u>" + this._caption.substring(1);
    } else {
      this._link.innerText = this._caption;
    }
  }
  enable(state) {
    if (state == this._enabled)
      return;
    this._enabled = state;
    this._link.tabIndex = state ? 0 : -1;
    if (this._enabled) {
      this._link.style.cursor = "pointer";
      this._link.style.backgroundColor = "#f0f0f0";
      this._link.style.color = "black";
    } else {
      this._link.style.backgroundColor = "#e0e0e0";
      this._link.style.cursor = "default";
      this._link.style.color = "#A0A0A0";
    }
  }
};
var newWindowParam = class {
  get GUICoef() {
    return this._GUICoef;
  }
  constructor(sizeCoefOverload) {
    this.createNow = false;
    this.left = 100;
    this.top = 100;
    this.positionType = 0;
    this.width = 400;
    this.height = 300;
    this.isModal = false;
    this.showShadow = true;
    this.showContainerBorders = true;
    this.showHeader = true;
    this.title = "new Window";
    this.closeIcon = true;
    this.headerBgColor = "";
    this.bottomKeepClear = 0;
    this.contentsDefaultFontSize = constants.generalFontSize;
    this.contentsDefaultFontFamily = constants.generalFontFamily;
    this.closingCallBack = null;
    this.WindowBackgroundColor = "#f0f0f0";
    this.WindowBorder = "1px solid #808080";
    this.WindowPadding = 2;
    this.WindowInnerBorderColor = " #A0A0A0";
    this.WindowInnerBackgroundColor = "#fAfAfA";
    this.WindowInnerBorder = "1px solid " + this.WindowInnerBorderColor;
    this.WindowHeaderBackgroundColor = "#0072ca";
    this.WindowHeaderColor = "white";
    this.WindowHeaderBorder = "1px solid #0072ca";
    this._GUICoef = constants.generalSizeCoef;
    this.WindowHeaderHeight = Math.round(20 * constants.generalSizeCoef);
    this.WindowHeaderFontSize = 16 * constants.generalSizeCoef;
    this.WindowHeaderFontFamily = constants.generalFontFamily;
    this.buttons = [];
    if (typeof sizeCoefOverload !== "undefined") {
      this.WindowHeaderHeight = 20 * sizeCoefOverload;
      this.WindowHeaderFontSize = 16 * sizeCoefOverload;
      this._GUICoef = sizeCoefOverload;
    }
  }
  clone() {
    let it = new newWindowParam();
    let keys = Object.keys(this);
    for (let i = 0; i < keys.length; i++) {
      if (keys[i] != "buttons")
        it[keys[i]] = this[keys[i]];
    }
    for (let i = 0; i < this.buttons.length; i++) {
      it.buttons.push(this.buttons[i]);
    }
    return it;
  }
};
var YWindow = class {
  static get ConTextMenuBestZindex() {
    for (let i = 0; i < YWindow.windowList.length; i++) {
      if (YWindow.windowList[i].isModal())
        return -1;
    }
    return 1e5 + 2 * YWindow.windowList.length;
  }
  constructor(params) {
    this._div = null;
    this._titleSpan = null;
    this._ModalDivShield = null;
    this._switchSideDiv = null;
    this._buttonsContainer = null;
    this._params = params.clone();
    YWindow.windowList.push(this);
    this._contents = document.createElement("DIV");
    if (params.createNow)
      this.allocate();
  }
  get innerContentDiv() {
    return this._contents;
  }
  get bottomKeepClear() {
    return this._params.bottomKeepClear;
  }
  set bottomKeepClear(value) {
    this._params.bottomKeepClear = value;
    if (this._contents != null) {
      this._contents.style.bottom = (this._params.WindowPadding + this._params.bottomKeepClear).toString() + "px";
    }
  }
  get outterContentDiv() {
    return this._div;
  }
  isModal() {
    if (this._div == null)
      return false;
    return this._div.style.display == "" && this._params.isModal;
  }
  get visible() {
    if (this._div == null)
      return false;
    return this._div.style.display == "";
  }
  set visible(v) {
    v ? this.show() : this.hide();
  }
  show(width) {
    if (this._div == null)
      this.allocate();
    this._div.style.display = "";
    if (this._ModalDivShield != null)
      this._ModalDivShield.style.display = "";
    this.brintToFront();
    if (typeof width !== "undefined" && this._params.positionType == 2) {
      this._div.style.width = width.toString() + "px";
    }
  }
  allocate() {
    if (this._div != null)
      return;
    if (this._params.isModal) {
      this._ModalDivShield = document.createElement("DIV");
      this._ModalDivShield.style.position = "fixed";
      this._ModalDivShield.style.left = "0px";
      this._ModalDivShield.style.top = "0px";
      this._ModalDivShield.style.right = "0px";
      this._ModalDivShield.style.bottom = "0px";
      this._ModalDivShield.style.backgroundColor = "rgba(255,255,255,0.85) ";
      document.body.appendChild(this._ModalDivShield);
    }
    this._div = document.createElement("DIV");
    this._div.style.display = "none";
    switch (this._params.positionType) {
      case 0:
        this._div.style.position = "absolute";
        this._div.style.left = this._params.left.toString() + "px";
        this._div.style.top = this._params.top.toString() + "px";
        this._div.style.width = this._params.width.toString() + "px";
        this._div.style.height = this._params.height.toString() + "px";
        break;
      case 1:
        this._div.style.position = "absolute";
        this._div.style.left = "50%";
        this._div.style.top = "50%";
        this._div.style.transform = "translate(-50%, -50%)";
        this._div.style.width = this._params.width.toString() + "px";
        this._div.style.height = this._params.height.toString() + "px";
        break;
      case 2:
        this._div.style.position = "fixed";
        this._div.style.top = "5px";
        this._div.style.right = "5px";
        this._div.style.bottom = "5px";
        this._div.style.width = this._params.width.toString() + "px";
        break;
    }
    this._div.style.border = this._params.WindowBorder;
    this._div.style.backgroundColor = this._params.WindowBackgroundColor;
    if (this._params.showShadow)
      this._div.style.boxShadow = " 4px 4px 4px 1px rgba(0,0,0,0.05)";
    let containerTop = this._params.WindowPadding;
    if (this._params.showHeader) {
      containerTop = this._params.WindowHeaderHeight + 3 * this._params.WindowPadding;
      let title = document.createElement("DIV");
      title.style.position = "absolute";
      title.style.left = this._params.WindowPadding.toString() + "px";
      title.style.top = this._params.WindowPadding.toString() + "px";
      title.style.right = this._params.WindowPadding.toString() + "px";
      title.style.height = this._params.WindowHeaderHeight.toString() + "px";
      title.style.border = this._params.WindowHeaderBorder;
      title.style.backgroundColor = this._params.WindowHeaderBackgroundColor;
      title.style.fontFamily = this._params.WindowHeaderFontFamily;
      title.style.color = this._params.WindowHeaderColor;
      title.style.fontSize = this._params.WindowHeaderFontSize.toString() + "px";
      title.style.paddingLeft = "5px";
      title.style.whiteSpace = "nowrap";
      title.addEventListener("click", () => {
        this.brintToFront();
      });
      this._titleSpan = document.createElement("SPAN");
      this._titleSpan.innerText = this._params.title;
      title.appendChild(this._titleSpan);
      if (this._params.closeIcon) {
        let closeDiv = document.createElement("DIV");
        closeDiv.style.position = "absolute";
        closeDiv.style.right = "0px";
        closeDiv.style.top = "0px";
        closeDiv.style.width = Math.round(this._params.WindowHeaderHeight + 5).toString() + "px";
        closeDiv.style.height = this._params.WindowHeaderHeight.toString() + "px";
        closeDiv.style.overflow = "hide";
        closeDiv.style.paddingLeft = "5px";
        closeDiv.tabIndex = 0;
        closeDiv.style.cursor = "pointer";
        closeDiv.style.backgroundColor = this._params.WindowHeaderBackgroundColor;
        closeDiv.innerHTML = ressources.CloseIcon(this._params.WindowHeaderHeight.toString(), false, false, false, false, "Click to close this window");
        closeDiv.addEventListener("click", () => {
          this.hide();
        });
        closeDiv.addEventListener("keypress", (e) => {
          if (e.key == "Enter")
            this.hide();
        });
        title.appendChild(closeDiv);
      }
      if (this._params.positionType == 2) {
        this._switchSideDiv = document.createElement("DIV");
        this._switchSideDiv.style.position = "absolute";
        this._switchSideDiv.style.width = Math.round(this._params.WindowHeaderHeight + 5).toString() + "px";
        this._switchSideDiv.style.right = Math.round(this._params.WindowHeaderHeight + 5) + "px";
        this._switchSideDiv.style.height = this._params.WindowHeaderHeight.toString() + "px";
        this._switchSideDiv.style.overflow = "hide";
        this._switchSideDiv.style.paddingLeft = "5px";
        this._switchSideDiv.style.top = "0px";
        this._switchSideDiv.style.cursor = "pointer";
        this._switchSideDiv.style.backgroundColor = this._params.WindowHeaderBackgroundColor;
        this._switchSideDiv.innerHTML = ressources.MoveToLeftIcon(this._params.WindowHeaderHeight.toString(), false, false, false, false, "Click to move editor on left side");
        this._switchSideDiv.addEventListener("click", () => {
          this.switchSide();
        });
        title.appendChild(this._switchSideDiv);
      }
      this._div.appendChild(title);
    }
    if (this._params.buttons.length > 0) {
      this._buttonsContainer = document.createElement("DIV");
      this._buttonsContainer.style.position = "absolute";
      this._buttonsContainer.style.bottom = Math.round(this._params.WindowPadding).toString() + "px";
      this._buttonsContainer.style.right = Math.round(this._params.WindowPadding).toString() + "px";
      this._buttonsContainer.style.textAlign = "right";
      for (let i = 0; i < this._params.buttons.length; i++) {
        this._buttonsContainer.appendChild(this._params.buttons[i].Element);
      }
      this._div.appendChild(this._buttonsContainer);
      this._buttonsContainer.style.height = (25 * this._params.GUICoef).toString() + "px";
      this._params.bottomKeepClear += Math.round(35 * this._params.GUICoef);
    }
    this._contents.style.position = "absolute";
    this._contents.style.left = this._params.WindowPadding.toString() + "px";
    this._contents.style.right = this._params.WindowPadding.toString() + "px";
    this._contents.style.top = containerTop.toString() + "px";
    this._contents.style.bottom = (this._params.WindowPadding + this._params.bottomKeepClear).toString() + "px";
    this._contents.style.paddingLeft = "5px";
    this._contents.style.paddingRight = "5px";
    if (this._contents.style.fontSize == "") {
      this._contents.style.fontSize = this._params.contentsDefaultFontSize.toString() + "px";
    }
    if (this._contents.style.fontFamily == "") {
      this._contents.style.fontFamily = this._params.contentsDefaultFontFamily;
    }
    if (this._params.showContainerBorders) {
      this._contents.style.border = this._params.WindowInnerBorder;
      this._contents.style.backgroundColor = this._params.WindowInnerBackgroundColor;
    } else {
      this._contents.style.border = "1px solid rgba(0, 0, 0, 0)";
      this._contents.style.backgroundColor = "";
    }
    this._contents.style.overflow = "hide";
    this._div.append(this._contents);
    document.body.appendChild(this._div);
  }
  hide() {
    if (this._div == null)
      return;
    this._div.style.display = "none";
    if (this._ModalDivShield != null)
      this._ModalDivShield.style.display = "none";
    if (this._params.closingCallBack != null)
      this._params.closingCallBack(this);
  }
  set title(value) {
    this._params.title = value;
    if (this._titleSpan != null) {
      this._titleSpan.innerText = value;
    }
  }
  brintToFront() {
    let n = -1;
    for (let i = 0; i < YWindow.windowList.length; i++) {
      if (YWindow.windowList[i] == this)
        n = i;
    }
    if (n < 0)
      return;
    YWindow.windowList.splice(n, 1);
    YWindow.windowList.push(this);
    for (let i = 0; i < YWindow.windowList.length; i++) {
      YWindow.windowList[i].zIndex = i;
    }
  }
  set zIndex(index) {
    if (this._div == null)
      return;
    this._div.style.zIndex = (100001 + 2 * index).toString();
    if (this._params.isModal)
      this._ModalDivShield.style.zIndex = (1e5 + 2 * index).toString();
  }
  switchSide() {
    if (this._div.style.left == "") {
      this._div.style.left = "5px";
      this._div.style.right = "";
      this._switchSideDiv.innerHTML = ressources.MoveToRightIcon(Math.round(20 * this._params.GUICoef).toString(), false, false, false, false, "Click to move editor on right side");
    } else {
      this._div.style.left = "";
      this._div.style.right = "5px";
      this._switchSideDiv.innerHTML = ressources.MoveToLeftIcon(Math.round(20 * this._params.GUICoef).toString(), false, false, false, false, "Click to move editor on left side");
    }
  }
};
YWindow.windowList = [];
var confirm = class {
  static ask(message, yes, no, userdata) {
    let params = new newWindowParam();
    params.positionType = 1;
    params.width = Math.min(Math.round(400 * constants.generalSizeCoef), Math.round(screen.width * 0.9));
    params.height = Math.min(Math.round(160 * constants.generalSizeCoef), Math.round(screen.height * 0.7));
    params.isModal = true;
    params.showHeader = false;
    params.showContainerBorders = false;
    let YesButton = new button("Yes", () => {
      confirm._window.hide();
      if (yes != null)
        yes(userdata);
    });
    let NoButton = new button("No", () => {
      confirm._window.hide();
      if (no != null)
        no(userdata);
    });
    params.buttons.push(YesButton);
    params.buttons.push(NoButton);
    confirm._window = new YWindow(params);
    let contents = confirm._window.innerContentDiv;
    let table = document.createElement("TABLE");
    table.style.width = "100%";
    let TR = document.createElement("TR");
    let TD = document.createElement("TD");
    TD.style.width = "10";
    TD.innerHTML = ressources.DontKnowIcon(Math.round(80 * constants.generalSizeCoef).toString(), true, false, false, false, "");
    TR.appendChild(TD);
    TD = document.createElement("TD");
    TD.style.paddingLeft = "20px";
    TD.style.fontFamily = constants.generalFontFamily;
    TD.style.fontSize = constants.generalFontSize.toString() + "px";
    TD.style.textAlign = "justify";
    TD.innerText = message;
    TR.appendChild(TD);
    table.appendChild(TR);
    contents.appendChild(table);
    confirm._window.show();
    return confirm._window;
  }
};
var notififaction = class {
  static show(icon, message) {
    let params = new newWindowParam();
    params.positionType = 1;
    params.width = Math.min(Math.round(400 * constants.generalSizeCoef), screen.width);
    params.height = Math.min(Math.round(160 * constants.generalSizeCoef), screen.height);
    params.isModal = true;
    params.showHeader = false;
    params.showContainerBorders = false;
    let okButton = new button("OK", () => {
      alert2._window.hide();
    });
    params.buttons.push(okButton);
    alert2._window = new YWindow(params);
    let contents = alert2._window.innerContentDiv;
    let table = document.createElement("TABLE");
    table.style.width = "100%";
    let TR = document.createElement("TR");
    let TD = document.createElement("TD");
    TD.style.width = "10";
    TD.innerHTML = icon;
    TR.appendChild(TD);
    TD = document.createElement("TD");
    TD.style.paddingLeft = "20px";
    TD.style.fontFamily = constants.generalFontFamily;
    TD.style.fontSize = constants.generalFontSize.toString() + "px";
    TD.style.textAlign = "justify";
    TD.innerText = message;
    TR.appendChild(TD);
    table.appendChild(TR);
    contents.appendChild(table);
    alert2._window.show();
    return alert2._window;
  }
};
var alert2 = class extends notififaction {
  static show(message) {
    return super.show(ressources.FailedIcon(Math.round(80 * constants.generalSizeCoef).toString(), true, false, false, false, ""), message);
  }
};

// obj/full/mainForm_rw.js
var mainForm = class {
  constructor() {
    this.GUIcoef = 1;
    let params = new newWindowParam();
    params.positionType = 1;
    this.GUIcoef = constants.generalSizeCoef;
    if (mainForm.REFWIDH * this.GUIcoef > screen.width)
      this.GUIcoef = screen.width / mainForm.REFWIDH;
    if (mainForm.REFHEIGHT * this.GUIcoef > screen.height)
      this.GUIcoef = screen.height / mainForm.REFHEIGHT;
    params.width = Math.round(mainForm.REFWIDH * this.GUIcoef);
    params.height = Math.round(mainForm.REFHEIGHT * this.GUIcoef);
    params.showHeader = false;
    params.showContainerBorders = false;
    this._window = new YWindow(params);
    let contents = this._window.innerContentDiv;
    let title = document.createElement("p");
    title.style.paddingTop = "0px";
    title.style.marginTop = 4 * this.GUIcoef + "px";
    title.style.fontSize = 16 * this.GUIcoef + "px";
    title.innerText = "Hello, welcome to Yocto-Visualization, what would you like to do?";
    title.style.textAlign = "center";
    contents.appendChild(title);
    let table = document.createElement("TABLE");
    table.style.position = "absolute";
    table.style.top = "0px";
    table.style.fontFamily = constants.generalFontFamily;
    table.style.tableLayout = "fixed";
    table.style.paddingLeft = Math.round(10 * this.GUIcoef).toString() + "px";
    table.style.paddingRight = Math.round(10 * this.GUIcoef).toString() + "px";
    table.style.paddingTop = Math.round(30 * this.GUIcoef).toString() + "px";
    table.style.paddingBottom = Math.round(15 * this.GUIcoef).toString() + "px";
    table.style.width = "100%";
    table.style.height = "100%";
    table.style.borderSpacing = Math.round(5 * this.GUIcoef).toString() + "px";
    let tr1 = document.createElement("TR");
    table.appendChild(tr1);
    let td11 = document.createElement("TD");
    tr1.appendChild(td11);
    let td12 = document.createElement("TD");
    tr1.appendChild(td12);
    let td13 = document.createElement("TD");
    tr1.appendChild(td13);
    let tr2 = document.createElement("TR");
    table.appendChild(tr2);
    let td21 = document.createElement("TD");
    tr2.appendChild(td21);
    let td22 = document.createElement("TD");
    tr2.appendChild(td22);
    let td23 = document.createElement("TD");
    tr2.appendChild(td23);
    contents.appendChild(table);
    let version = document.createElement("p");
    version.style.position = "absolute";
    version.style.right = "0px";
    version.style.bottom = "0px";
    version.style.marginBottom = "0px";
    version.style.paddingBottom = "0px";
    version.style.marginRight = "2px";
    version.style.fontSize = (8 * this.GUIcoef).toString() + "px";
    version.innerText = constants.buildVersion;
    version.style.color = "grey";
    version.style.textAlign = "right";
    contents.appendChild(version);
    let size = (128 * this.GUIcoef).toString();
    this.createButton(td11, "Configure global parameters", ressources.ConfigureIcon(size, true, false, false, false), () => {
      this.openConfig();
    });
    this.createButton(td12, "Create a new solid gauge", ressources.SolidGaugeIcon(size, true, false, false, false), () => {
      YWebPage.newGaugeWidget();
    });
    this.createButton(td13, "Create a new graph", ressources.GraphIcon(size, true, false, false, false), () => {
      YWebPage.newGraphWidget();
    });
    this.createButton(td21, "Get Raw data", ressources.RawDataIcon(size, true, false, false, false), () => {
      this.openRawData();
    });
    this.createButton(td22, "Create a new digital display", ressources.DigitalDisplayIcon(size, true, false, false, false), () => {
      YWebPage.newDigitalDisplayWidget();
    });
    this.createButton(td23, "Create a new angular gauge", ressources.AngularGaugeIcon(size, true, false, false, false), () => {
      YWebPage.newAngularGaugeWidget();
    });
  }
  hide() {
    this._window.hide();
  }
  show() {
    this._window.show();
  }
  createButton(container, caption, icon, callback) {
    container.style.border = "1px solid black";
    container.style.textAlign = "center";
    container.style.fontSize = (10 * this.GUIcoef).toString() + "px";
    container.style.paddingBottom = "3px";
    container.style.borderColor = "#808080";
    container.style.backgroundColor = "#f0f0f0";
    container.style.cursor = "pointer";
    container.addEventListener("mouseover", function() {
      container.style.backgroundColor = "white";
    });
    container.addEventListener("mouseout", function() {
      container.style.backgroundColor = "#f0f0f0";
    });
    let a = document.createElement("a");
    a.style.outline = "none";
    a.innerHTML = icon + "<br>" + caption;
    a.addEventListener("click", callback);
    a.tabIndex = 0;
    a.addEventListener("focusin", () => {
      container.style.backgroundColor = "white";
    });
    a.addEventListener("focusout", () => {
      container.style.backgroundColor = "f0f0f0";
    });
    a.addEventListener("keypress", (e) => {
      if (e.key == "Enter")
        callback();
    });
    container.appendChild(a);
  }
  openConfig() {
    configForm.show();
  }
  openRawData() {
    rawDataForm.show();
  }
};
mainForm.REFWIDH = 500;
mainForm.REFHEIGHT = 360;

// obj/full/Editor_rw.js
var EditedDataSource = class {
  constructor(source, root) {
    this._htmlchilds = [];
    this._source = source;
    this._root = root;
    this._htmlchilds = [];
  }
  storeChilds(childsList) {
    this._htmlchilds = [];
    for (let i = 0; i < childsList.length; i++) {
      this._htmlchilds.push(childsList.item(i));
    }
  }
  getStoredChilds() {
    return this._htmlchilds;
  }
  get root() {
    return this._root;
  }
  refresh() {
    if (this._root != null)
      this._root.refresh();
  }
};
var keyDataObject = class {
  constructor(key, data) {
    this.key = key;
    this.data = data;
  }
};
var objectDictionnary = class {
  constructor() {
    this.list = [];
  }
  isInlist(key) {
    for (let i = 0; i < this.list.length; i++) {
      if (key == this.list[i].key)
        return true;
    }
    return false;
  }
  find(key) {
    for (let i = 0; i < this.list.length; i++) {
      if (key == this.list[i].key)
        return this.list[i].data;
    }
    return null;
  }
  insert(key, data) {
    for (let i = 0; i < this.list.length; i++) {
      if (key == this.list[i].key) {
        this.list[i].data = data;
        return;
      }
    }
    this.list.push(new keyDataObject(key, data));
  }
};
var EditorBaseDef = class {
  refresh() {
  }
  get panel() {
    return null;
  }
  get expanded() {
    return true;
  }
  AllocateControls() {
  }
};
var PropertiesForm2 = class extends EditorBaseDef {
  get visible() {
    return this._window.visible;
  }
  set visible(v) {
    v ? this.show() : this.hide();
  }
  get text() {
    return this._text;
  }
  set text(value) {
    this._text = value;
    this._window.title = this._text;
  }
  get help() {
    return this._helpText;
  }
  set help(value) {
    this._helpText = value;
    this._helpPanel.innerHTML = this._helpText;
  }
  addTest(parentDiv) {
    PropertiesForm2.testid++;
    let mainlabel = document.createElement("DIV");
    mainlabel.style.position = "relative";
    mainlabel.style.display = "inline-block;";
    mainlabel.style.left = "0px";
    mainlabel.style.padding = "2px 2px 2px 2px";
    mainlabel.style.right = "5px";
    mainlabel.style.border = "1px solid black";
    mainlabel.style.marginTop = "2px";
    mainlabel.style.backgroundColor = "yellow";
    if (parentDiv != null) {
      parentDiv.appendChild(mainlabel);
    } else {
      this._container.appendChild(mainlabel);
    }
    let expandCtrl = document.createElement("ANCHOR");
    expandCtrl.innerText = "[+]";
    mainlabel.appendChild(expandCtrl);
    let mainText = document.createElement("SPAN");
    mainText.innerText = "Pouet " + PropertiesForm2.testid.toString();
    mainlabel.appendChild(mainText);
    let subElementPanel = document.createElement("DIV");
    subElementPanel.style.position = "relative";
    subElementPanel.style.display = "inline-block;";
    subElementPanel.style.left = "5px";
    subElementPanel.style.padding = "2px 2px 2px 2px";
    subElementPanel.style.right = "5px";
    subElementPanel.style.marginTop = "2px";
    subElementPanel.style.backgroundColor = "lightgray";
    subElementPanel.innerText = "sub elements";
    if (parentDiv != null) {
      parentDiv.appendChild(subElementPanel);
    } else {
      this._container.appendChild(subElementPanel);
    }
    return subElementPanel;
  }
  editorIsClosing(source) {
    if (this._editorClosedCallback != null)
      this._editorClosedCallback();
  }
  bestWidth() {
    let w = window.innerWidth / 4 >> 0;
    let minWidth = 275 * constants.guiDPIFactor;
    if (w < minWidth)
      w = minWidth;
    if (w > window.innerWidth - 10)
      w = window.innerWidth - 10;
    return w;
  }
  constructor() {
    super();
    this._hostWindow = null;
    this._editorClosedCallback = null;
    this.currentEditedDataSource = null;
    this._changeCallback = null;
    this._getvalueCallback = null;
    this._text = "Properties editor";
    this._helpText = "Properties editor";
    this.EditedDataSourceList = new objectDictionnary();
    let params = new newWindowParam();
    params.positionType = 2;
    params.width = this.bestWidth();
    params.createNow = true;
    params.closingCallBack = (source) => {
      this.editorIsClosing(source);
    };
    params.bottomKeepClear = PropertiesForm2.HelpHeight + 3 * constants.WindowPadding;
    params.title = this._text;
    this._window = new YWindow(params);
    this._container = this._window.innerContentDiv;
    this._helpPanel = document.createElement("DIV");
    this._helpPanel.style.position = "absolute";
    this._helpPanel.style.left = constants.WindowPadding.toString() + "px";
    this._helpPanel.style.bottom = constants.WindowPadding.toString() + "px";
    this._helpPanel.style.right = constants.WindowPadding.toString() + "px";
    this._helpPanel.style.height = PropertiesForm2.HelpHeight.toString() + "px";
    this._helpPanel.style.paddingLeft = "5px";
    this._helpPanel.style.paddingTop = "5px";
    this._helpPanel.style.overflowY = "auto";
    this._helpPanel.style.border = constants.WindowInnerBorder;
    this._helpPanel.style.backgroundColor = constants.WindowInnerBackgroundColor;
    this._helpPanel.style.fontFamily = constants.generalFontFamily;
    this._helpPanel.style.fontSize = constants.generalFontSize.toString() + "px";
    this._helpPanel.style.color = "black";
    this._helpPanel.style.display = "";
    this._helpPanel.innerHTML = "Help panel. Editor is loading, please wait....";
    this._window.outterContentDiv.appendChild(this._helpPanel);
    this._container.style.overflowY = "scroll";
    this._container.style.overflowX = "hidden";
    this._container.style.backgroundColor = constants.WindowInnerBackgroundColor;
    window.addEventListener("resize", () => {
      this.windowResized();
    });
  }
  windowResized() {
    if (this._window.innerContentDiv == null)
      return;
    if (this._window.innerContentDiv.offsetHeight < PropertiesForm2.MinHeightforShowingHelp && this._helpPanel.style.display == "") {
      this._helpPanel.style.display = "none";
      this._window.bottomKeepClear = 0;
    } else if (this._window.innerContentDiv.offsetHeight >= PropertiesForm2.MinHeightforShowingHelp + PropertiesForm2.HelpHeight && this._helpPanel.style.display != "") {
      this._helpPanel.style.display = "";
      this._window.bottomKeepClear = PropertiesForm2.HelpHeight;
    }
  }
  show() {
    this._window.show(this.bestWidth());
    this.windowResized();
  }
  hide() {
    YWidget.stopEdition();
    this._window.hide();
  }
  get panel() {
    return this._container;
  }
  refresh() {
    if (!this.visible)
      return;
    if (this.currentEditedDataSource == null)
      return;
    this.currentEditedDataSource.refresh();
  }
  refreshBanner() {
    if (this._hostWindow != null) {
      this.text = "Properties of " + this._hostWindow.Text;
    }
  }
  showWindow(hostWindow, structData, setvalueCallBack, getvalueCallBack, EditStoppedCallBack) {
    this._hostWindow = hostWindow;
    this._changeCallback = setvalueCallBack;
    this._getvalueCallback = getvalueCallBack;
    this.text = "Properties editor";
    this.show();
    this.refreshBanner();
    this.EditObject(structData, setvalueCallBack, getvalueCallBack, EditStoppedCallBack);
  }
  EditObject(structData, setvalueCallBack, getvalueCallBack, EditStoppedCallBack) {
    this._editorClosedCallback = EditStoppedCallBack;
    let helpYourselfMsg = "This is the property editor. Change any parameter you want. All changes are applied in real time.";
    if (!this.visible)
      return;
    this.help = "Please wait....";
    if (this.EditedDataSourceList.isInlist(structData)) {
      if (this.EditedDataSourceList.find(structData) == this.currentEditedDataSource) {
        this.help = helpYourselfMsg;
        return;
      }
    }
    if (this.currentEditedDataSource != null) {
      this.currentEditedDataSource.root.stopEdit();
      this.currentEditedDataSource.storeChilds(this._container.childNodes);
      while (this._container.firstChild) {
        this._container.removeChild(this._container.lastChild);
      }
    }
    let it;
    if (!this.EditedDataSourceList.isInlist(structData)) {
      let rootparam = new UIElementBaseParams(this._helpPanel, this, null, "root", "Root", "root node", "");
      it = new UIElement(rootparam);
      it.rootEditor = this;
      this.currentEditedDataSource = new EditedDataSource(structData, it);
      this.EditedDataSourceList.insert(structData, this.currentEditedDataSource);
      it.showLabel = false;
      it.expandable = true;
      it.ProcessNewType(structData);
      it.expanded = true;
    } else {
      this.currentEditedDataSource = this.EditedDataSourceList.find(structData);
      let childNodes = this.currentEditedDataSource.getStoredChilds();
      for (let i = 0; i < childNodes.length; i++) {
        this._container.appendChild(childNodes[i]);
      }
      this.currentEditedDataSource.refresh();
    }
    this.currentEditedDataSource.root.startEdit(setvalueCallBack, getvalueCallBack);
    this.currentEditedDataSource.root.resizeAll();
    this.help = helpYourselfMsg;
  }
  getConfigData() {
    let p = this._window.outterContentDiv.getBoundingClientRect();
    return "<PropertiesForm>\n<location x='" + p.left.toString() + "' y='" + p.top.toString() + "'/>\n<size     w='" + p.width.toString() + "' h='" + p.width.toString() + "'/>\n</PropertiesForm>\n";
  }
  Form1_SizeChanged(sender) {
    if (this.currentEditedDataSource == null)
      return;
    if (this.currentEditedDataSource.root != null)
      this.currentEditedDataSource.root.resizeAll();
  }
  valuechange(src) {
    let OriginalPropName = "";
    let fullpropname = "";
    let propType = "";
    if (this._changeCallback != null)
      this._changeCallback(src);
  }
};
PropertiesForm2.HelpHeight = Math.round(75 * constants.generalSizeCoef);
PropertiesForm2.MinHeightforShowingHelp = 175;
PropertiesForm2.testid = 0;

// obj/full/UIElements_rw.js
var UIElementBaseParams = class {
  constructor(p_descriptionLabel, p_parentNode, p_RootNode, p_internalname, p_label, p_description, p_isReadonlyCall) {
    this.expandable = false;
    this.isReadonlyCall = "";
    this.summary = null;
    this.structRoot = null;
    this.HelpZoneLabel = p_descriptionLabel;
    this.parentNode = p_parentNode;
    this.RootNode = p_RootNode;
    this.internalname = p_internalname;
    this.label = p_label;
    this.description = p_description;
    this.changeCausesParentRefresh = false;
    this.preExpanded = false;
    this.isReadonlyCall = p_isReadonlyCall;
  }
};
var PropPathinfo = class {
  constructor() {
    this.OriginalPropName = "";
    this.fullpropname = "";
    this.propType = "";
  }
};
var CustomAttributesExtractor = class {
  constructor(ps) {
    this.available = true;
    this.displayName = "unknown";
    this.category = "";
    this.displayDescription = "Not documented";
    this.prefinedValues = null;
    this.changeCausesParentRefresh = false;
    this.PreExpandedCategory = false;
    this.PreExpanded = false;
    this.summaryPropertyName = "";
    this.isReadOnlyCall = "";
    this.NotSavedInXML = false;
    this.ReadOnly = false;
    this.ParamCategorySummary = "";
    if ("OnlyAvailableon" in ps.Attributes)
      this.available = ps.Attributes["OnlyAvailableon"];
    if ("DisplayName" in ps.Attributes)
      this.displayName = ps.Attributes["DisplayName"];
    if ("CategoryAttribute" in ps.Attributes)
      this.category = ps.Attributes["CategoryAttribute"];
    if ("DescriptionAttribute" in ps.Attributes)
      this.displayDescription = ps.Attributes["DescriptionAttribute"];
    if ("AllowedValues" in ps.Attributes)
      this.prefinedValues = ps.Attributes["AllowedValues"];
    if ("ChangeCausesParentRefreshAttribute" in ps.Attributes)
      this.changeCausesParentRefresh = ps.Attributes["ChangeCausesParentRefreshAttribute"];
    if ("PreExpandedCategoryAttribute" in ps.Attributes)
      this.PreExpandedCategory = ps.Attributes["PreExpandedCategoryAttribute"];
    if ("PreExpandedAttribute" in ps.Attributes)
      this.PreExpanded = ps.Attributes["PreExpandedAttribute"];
    if ("ParamCategorySummaryAttribute" in ps.Attributes)
      this.summaryPropertyName = ps.Attributes["ParamCategorySummaryAttribute"];
    if ("IsReadonlyCallAttribute" in ps.Attributes)
      this.isReadOnlyCall = ps.Attributes["IsReadonlyCallAttribute"];
    if ("NotSavedInXMLAttribute" in ps.Attributes)
      this.NotSavedInXML = ps.Attributes["NotSavedInXMLAttribute"];
    if ("ReadOnlyAttribute " in ps.Attributes)
      this.ReadOnly = ps.Attributes["ReadOnlyAttribute "];
    if ("ParamCategorySummaryAttribute " in ps.Attributes)
      this.ParamCategorySummary = ps.Attributes["ParamCategorySummaryAttribute "];
  }
};
var UIElement = class extends EditorBaseDef {
  get parentNode() {
    return this._parentNode;
  }
  get targetFullName() {
    return this._targetFullName;
  }
  get expandIcon() {
    return ressources.ExpandIcon(UIElement.defaultFontSize.toString(), false, false, false, false, "Click to expand");
  }
  get colapseIcon() {
    return ressources.ColapseIcon(UIElement.defaultFontSize.toString(), false, false, false, false, "Click to colapse");
  }
  removeFromEditor() {
  }
  get panel() {
    return this.subElementPanel;
  }
  get editorHelpText() {
    return "";
  }
  get isRootElement() {
    return this._rootNode == this;
  }
  addToEditor() {
    if (this.mainlabel != null) {
      for (let i = 0; i < this._parentPanel.children.length; i++) {
        if (this._parentPanel.children[i] == this.mainlabel)
          return;
      }
      this._parentPanel.appendChild(this.mainlabel);
      this._parentPanel.appendChild(this.subElementPanel);
    }
  }
  refresh() {
    if (this.mainText != null)
      this.mainText.innerText = this.name + this.getSummary();
    for (let i = 0; i < this.subElements.length; i++) {
      this.subElements[i].refresh();
    }
    if (this._rootNode != null && this._rootNode.rootEditor != null)
      this._rootNode.rootEditor.refreshBanner();
  }
  tabReOrder(index) {
    if (this._expandable && this.expandCtrl != null)
      this.expandCtrl.tabIndex = index++;
    this.subElements.forEach((e) => {
      index = e.tabReOrder(index);
    });
    return index;
  }
  triggerValueChangeCallback() {
    if (this._valueChangeCallback != null)
      this._valueChangeCallback(this);
  }
  scrollToMakeVisible() {
    if (this.mainlabel == null)
      return;
    if (this._parentPanel == null)
      return;
    this.mainlabel.scrollIntoView();
  }
  control_GotFocus(sender) {
    let extraHelp = this.editorHelpText;
    if (extraHelp != "")
      extraHelp = " " + extraHelp;
    this._helpZoneLabel.innerHTML = this._description + extraHelp;
  }
  control_LostFocus(sender) {
    this._helpZoneLabel.innerHTML = "";
  }
  preExpandIfNeeded() {
    if (this._parentNode != null && this._parentNode.expanded) {
      this.AllocateControls();
      if (this.expandable)
        this.initExpandButton();
      this.initMainLabel();
    }
    this.initExpandButton();
  }
  constructor(p) {
    super();
    this.name = "NoName";
    this._targetFullName = "unknowTargetName";
    this.ExpandableDepth = 0;
    this._expanded = false;
    this._expandButtonSide = 0;
    this._rootEditor = null;
    this._description = "";
    this.expandCtrl = null;
    this.mainlabel = null;
    this.mainText = null;
    this.subElementPanel = null;
    this._rootNode = null;
    this._parentNode = null;
    this._parentPanel = null;
    this._changeCausesParentRefresh = false;
    this._isReadOnlyCall = "";
    this._controlsAllocated = false;
    this.expandButtonInitDone = false;
    this.mainLabelInitDone = false;
    this.subElements = [];
    this._valueChangeCallback = null;
    this._getValueCallback = null;
    this._shown = true;
    this._summaryCallback = null;
    this._showLabel = false;
    this._expandable = false;
    this._preExpanded = false;
    this.name = p.label;
    this._targetFullName = p.internalname;
    this._helpZoneLabel = p.HelpZoneLabel;
    this._description = p.description;
    this._changeCausesParentRefresh = p.changeCausesParentRefresh;
    this._expandable = p.expandable;
    this._preExpanded = p.preExpanded;
    this._structRoot = p.structRoot;
    this._isReadOnlyCall = p.isReadonlyCall;
    this._summaryProperty = p.summary;
    if (UIElement.baseheight == 0) {
      UIElement.baseheight = 12;
      UIElement.expandableShift = UIElement.baseheight + 2;
      UIElement.scrollBarWidth = 20;
    }
    this._parentNode = p.parentNode;
    this._rootNode = p.RootNode == null ? this : p.RootNode;
  }
  set rootEditor(value) {
    this._rootEditor = value;
  }
  get rootEditor() {
    return this._rootEditor;
  }
  initMainLabel() {
    if (this.mainlabel == null)
      return;
    if (this.mainLabelInitDone)
      return;
    this.ExpandableDepth = 0;
    let p = this;
    while (p != null) {
      if (p.expandable)
        this.ExpandableDepth++;
      p = p.parentNode;
    }
    this.mainText.innerText = this.name + this.getSummary();
    if (this.expandable && this._expandButtonSide == 0) {
      switch (this.ExpandableDepth) {
        case 1:
          this.mainlabel.style.backgroundColor = "Blue";
          this.mainText.style.color = "black";
          break;
        case 2:
          this.mainlabel.style.backgroundColor = "rgb(7,141,255)";
          this.mainText.style.color = "white";
          break;
        case 3:
          this.mainlabel.style.backgroundColor = "rgb(120,196,255)";
          break;
        case 4:
          this.mainlabel.style.backgroundColor = "rgb(213,237,255)";
          break;
        case 5:
          this.mainlabel.style.backgroundColor = "rgb(237,246,253)";
          break;
        default:
          this.mainlabel.style.backgroundColor = "rgb(246,251,255)";
          break;
      }
    } else {
      this.mainlabel.style.backgroundColor = "rgba( 0, 0, 0,0)";
    }
    this.mainLabelInitDone = true;
  }
  AllocateControls() {
    if (this._controlsAllocated)
      return;
    if (!this.isRootElement)
      this.parentNode.AllocateControls();
    this._parentPanel = this.parentNode.panel;
    if (this.mainlabel == null) {
      this.mainlabel = document.createElement("DIV");
      this.mainlabel.style.position = "relative";
      this.mainlabel.style.display = "inline-block;";
      this.mainlabel.style.left = "0px";
      this.mainlabel.style.padding = "2px 2px 2px 2px";
      this.mainlabel.style.overflow = "hidden";
      this.mainlabel.style.fontFamily = UIElement.defaultFontFamily;
      this.mainlabel.style.fontSize = UIElement.defaultFontSize.toString() + "px";
      this.mainlabel.style.right = "5px";
      this.mainlabel.style.whiteSpace = "nowrap";
      this.mainlabel.style.marginTop = "2px";
      this.mainlabel.style.backgroundColor = "yellow";
      this.mainText = document.createElement("SPAN");
      this.mainText.innerText = "Pouet";
      this.mainlabel.appendChild(this.mainText);
      this.mainlabel.style.display = this.isRootElement ? "none" : "";
      this.initMainLabel();
      if (this._parentPanel == null) {
        debugger;
      }
      this._parentPanel.appendChild(this.mainlabel);
    }
    if (this._expandable && this.expandCtrl == null) {
      this.expandCtrl = document.createElement("ANCHOR");
      if (this._expandButtonSide == 0) {
        this.mainlabel.insertBefore(this.expandCtrl, this.mainText);
      }
      this.initExpandButton();
      this.subElementPanel = document.createElement("DIV");
      this.subElementPanel.style.position = "relative";
      this.subElementPanel.style.display = "inline-block;";
      this.subElementPanel.style.left = this.isRootElement ? "0px" : "5px";
      this.subElementPanel.style.padding = "2px 2px 2px 2px";
      this.subElementPanel.style.right = "5px";
      this.subElementPanel.style.display = "none";
      this.subElementPanel.style.marginTop = "2px";
      this.subElementPanel.style.marginRight = "2px";
      this._parentPanel.appendChild(this.subElementPanel);
    }
    this._controlsAllocated = true;
  }
  initExpandButton() {
    if (this.expandCtrl == null)
      return;
    if (this.expandButtonInitDone)
      return;
    this.expandCtrl.innerHTML = this.expandIcon;
    this.expandCtrl.style.top = "0px";
    this.expandCtrl.style.left = "0px";
    this.expandCtrl.style.cursor = "pointer";
    this.expandCtrl.style.backgroundColor = "white";
    this.expandCtrl.style.marginRight = "3px";
    this.expandCtrl.style.paddingLeft = "0px";
    this.expandCtrl.style.paddingRight = "0px";
    this.expandCtrl.style.paddingTop = "1px";
    this.expandCtrl.style.marginTop = "0px";
    this.expandCtrl.style.marginBottom = "0px";
    this.expandCtrl.style.paddingBottom = "0px";
    this.expandCtrl.style.paddingRight = "0px";
    this.expandCtrl.addEventListener("click", () => {
      this.ToggleExpand();
    });
    this.expandCtrl.addEventListener("keyup", (e) => {
      if (e.key === "Enter" || e.key === " ")
        this.ToggleExpand();
    });
    this.expandCtrl.addEventListener("focusin", () => {
      this.control_GotFocus(this);
    });
    this.expandCtrl.addEventListener("focusout", () => {
      this.control_LostFocus(this);
    });
    this.expandButtonInitDone = true;
  }
  get rowHeight() {
    return UIElement.baseheight;
  }
  ExtractPropPath(info) {
    let index = -1;
    let path = [];
    let p = this;
    info.OriginalPropName = p.targetFullName;
    do {
      info.fullpropname = p.targetFullName;
      index = info.fullpropname.indexOf("_");
      if (index < 0) {
        if (info.fullpropname != UIElement.ARTIFICIALSECTIONNAME)
          path.splice(0, 0, info.fullpropname);
        p = p.parentNode;
        if (p == null)
          throw "invalid Property name";
      }
    } while (index < 0);
    info.propType = info.fullpropname.substring(0, index);
    let propname = info.fullpropname.substring(index + 1);
    path.splice(0, 0, propname);
    return path;
  }
  startEdit(setcallback, getCallback) {
    this.addToEditor();
    this._valueChangeCallback = setcallback;
    this._getValueCallback = getCallback;
    this.subElements.forEach((item) => {
      item.startEdit(setcallback, getCallback);
    });
  }
  stopEdit() {
    this.removeFromEditor();
    this._valueChangeCallback = null;
    this._getValueCallback = null;
    this.subElements.forEach((item) => {
      item.stopEdit();
    });
  }
  expand() {
    this.subElements.forEach((e) => {
      e.AllocateControls();
      e.show();
    });
    this._rootNode.tabReOrder(0);
    this._expanded = true;
    this.subElementPanel.style.display = "";
    this.expandCtrl.innerHTML = this.colapseIcon;
  }
  colapse() {
    this.subElementPanel.style.display = "none";
    this.expandCtrl.innerHTML = this.expandIcon;
  }
  get expanded() {
    return this._expanded;
  }
  set expanded(value) {
    this._expanded = value;
    if (this._expanded) {
      this.expand();
    } else {
      this.colapse();
    }
    this._rootNode.resizeAll();
  }
  ToggleExpand() {
    this.expanded = !this.expanded;
  }
  getSummary() {
    if (this._summaryProperty != null) {
      return " (" + Reflect.get(this._structRoot, this._summaryProperty.name) + ")";
    }
    return "";
  }
  sensorList() {
    let res = [];
    sensorsManager.sensorList.forEach((s) => {
      res.push(s);
    });
    return res;
  }
  ProcessNewType(dataStucture) {
    let subsections = {};
    this._structRoot = dataStucture;
    let toExpand = [];
    let properties = GenericProperties.getAllProperties(dataStucture);
    for (let i = 0; i < properties.byIndex.length; i++) {
      let ps = properties.byIndex[i];
      if (ps.isWritable) {
        let attr = new CustomAttributesExtractor(ps);
        if (attr.available) {
          let section = this;
          if (attr.category != "") {
            if (attr.category in subsections) {
              section = subsections[attr.category];
            } else {
              let sectionparam = new UIElementBaseParams(this._helpZoneLabel, this, this._rootNode, UIElement.ARTIFICIALSECTIONNAME, attr.category, attr.category + " section, expand for more...", "");
              sectionparam.preExpanded = attr.PreExpandedCategory;
              sectionparam.expandable = true;
              sectionparam.structRoot = dataStucture;
              if (attr.summaryPropertyName != "") {
                sectionparam.summary = ps;
              }
              section = new UIElement(sectionparam);
              if (attr.PreExpandedCategory)
                toExpand.push(section);
              section.showLabel = true;
              subsections[attr.category] = section;
              this.addSubElement(section);
            }
          }
          let elParam = new UIElementBaseParams(this._helpZoneLabel, section, this._rootNode, ps.name, attr.displayName, attr.displayDescription, attr.isReadOnlyCall);
          elParam.preExpanded = attr.PreExpanded;
          elParam.changeCausesParentRefresh = attr.changeCausesParentRefresh;
          let targetName = this._targetFullName;
          let targetPrefix = "";
          let p = targetName.indexOf("_");
          if (p >= 0) {
            targetPrefix = targetName.substring(0, p);
            targetName = targetName.substring(p + 1);
          }
          if (ps.isEnum) {
            let s = new UIElementEnum(elParam, dataStucture, ps);
            section.addSubElement(s);
          } else {
            switch (ps.type) {
              case "number":
                if (attr.prefinedValues == null) {
                  let n = new UIElementNumber(elParam, dataStucture, ps);
                  section.addSubElement(n);
                } else {
                  let s2 = new UIElementList(elParam, dataStucture, ps, () => {
                    return attr.prefinedValues;
                  });
                  section.addSubElement(s2);
                }
                break;
              case "boolean":
                let b = new UIElementBoolean(elParam, dataStucture, ps);
                section.addSubElement(b);
                break;
              case doubleNan.name:
                let d = new UIElementDoubleNan(elParam, dataStucture, ps);
                section.addSubElement(d);
                break;
              case NullYSensor.name:
              case CustomYSensor.name:
                let s = new UIElementList(elParam, dataStucture, ps, () => {
                  return this.sensorList();
                });
                section.addSubElement(s);
                break;
              case YColor.name:
                let c = new UIElementColor(elParam, dataStucture, ps);
                section.addSubElement(c);
                break;
              case xAxisPosition.name:
                let p2 = new UIElementMarkerPos(elParam, dataStucture, ps);
                section.addSubElement(p2);
                break;
              case "string":
                if (attr.prefinedValues == null) {
                  let s2 = new UIElementString(elParam, dataStucture, ps);
                  section.addSubElement(s2);
                } else {
                  let s2 = new UIElementList(elParam, dataStucture, ps, () => {
                    return attr.prefinedValues;
                  });
                  section.addSubElement(s2);
                }
                break;
              default:
                {
                  elParam.expandable = true;
                  elParam.preExpanded = attr.PreExpanded;
                  let subobjectsection = new UIElement(elParam);
                  if (attr.PreExpanded)
                    toExpand.push(subobjectsection);
                  subobjectsection.showLabel = true;
                  section.addSubElement(subobjectsection);
                  subobjectsection.ProcessNewType(dataStucture[ps.name]);
                }
                break;
            }
          }
        }
      } else {
        if (ps.name == "summary") {
          this._summaryProperty = ps;
        }
      }
    }
    if (this._summaryProperty != null)
      this.refresh();
    toExpand.forEach((e) => {
      e.expand();
    });
  }
  show() {
    this._shown = true;
    if (this.mainlabel != null)
      this.mainlabel.style.display = "";
    if (this.expandCtrl != null)
      this.expandCtrl.style.display = this._expandable ? "" : "hidden";
    if (this.expanded) {
      this.subElements.forEach((e) => {
        e.show();
      });
    }
  }
  hide() {
    this._shown = false;
    if (this.mainlabel != null)
      this.mainlabel.style.display = "hidden";
    if (this.expandCtrl != null)
      this.expandCtrl.style.display = this._expandable ? "hidden" : "";
    this.subElements.forEach((e) => {
      e.hide();
    });
  }
  ExpandCtrl_Click_expand(sender) {
    this.expanded = !this._expanded;
  }
  resizeAll() {
    this.resize(0, 0, 0, 0);
    if (this.expanded) {
      this.subElements.forEach((e) => {
        e.resizeAll();
      });
    }
  }
  get showLabel() {
    return this._showLabel;
  }
  set showLabel(value) {
    this._showLabel = value;
    if (this.expandCtrl != null)
      this.expandCtrl.style.display = value && this._expandable ? "" : "hidden";
  }
  get expandable() {
    return this._expandable;
  }
  set expandable(value) {
    this._expandable = value;
    if (!value)
      return;
    if (this.expandCtrl == null) {
      this.AllocateControls();
      this.initExpandButton();
    }
    this.expandCtrl.style.display = value && this._showLabel ? "" : "hidden";
  }
  addSubElement(node) {
    this.subElements.push(node);
  }
  computeHeight() {
    return 0;
  }
  resize(top2, left1, left2, width) {
    return 0;
  }
};
UIElement.defaultFontFamily = constants.generalFontFamily;
UIElement.defaultFontSize = constants.generalFontSize;
UIElement.ARTIFICIALSECTIONNAME = "-ignore-";
UIElement.baseheight = 0;
UIElement.indentation = 16;
UIElement.expandableShift = 0;
UIElement.scrollBarWidth = 0;
UIElement.expandableVerticalOffset = 2;
var UIElementGeneric = class extends UIElement {
  constructor(p, dataContainer, prop) {
    super(p);
    this.input = null;
    this.select = null;
    this._prop = prop;
    this._dataContainer = dataContainer;
    this._showLabel = true;
    if (this._preExpanded)
      this.AllocateControls();
    if (this._expandable && this._preExpanded)
      this.expand();
  }
  removeFromEditor() {
    super.removeFromEditor();
  }
  tabReOrder(index) {
    if (this.input != null)
      this.input.tabIndex = index++;
    this.subElements.forEach((e) => {
      index = e.tabReOrder(index);
    });
    return index;
  }
  addToEditor() {
    super.addToEditor();
  }
  show() {
    super.show();
    if (this.input != null)
      this.input.style.visibility = "";
  }
  checkForReadOnly() {
    if (this.input == null && this.select == null)
      return;
    if (this._isReadOnlyCall != "") {
      let ro = Reflect.get(this._dataContainer, this._isReadOnlyCall);
      if (this.input != null)
        this.input.disabled = ro;
      if (this.select != null)
        this.select.disabled = ro;
    }
  }
  hide() {
    if (this.input != null)
      this.input.style.visibility = "hidden";
    super.hide();
  }
  resize(top2, left1, left2, width) {
    return 0;
  }
};
var UIElementString = class extends UIElementGeneric {
  constructor(p, dataContainer, prop) {
    super(p, dataContainer, prop);
    this._value = "";
    this.preExpandIfNeeded();
  }
  AllocateControls() {
    super.AllocateControls();
    if (this.input == null) {
      this.input = document.createElement("INPUT");
      this.input.type = "input";
      this.input.value = Reflect.get(this._dataContainer, this._prop.name);
      this.input.style.position = "absolute";
      this.input.style.marginTop = "0px";
      this.input.style.marginBottom = "0px";
      this.input.style.fontFamily = UIElement.defaultFontFamily;
      this.input.style.fontSize = UIElement.defaultFontSize.toString() + "px";
      this.input.style.border = "1px solid grey";
      this.input.style.borderRadius = "1px";
      this.input.style.top = "0px";
      this.input.style.right = "3px";
      this.input.style.width = "50%";
      this.mainlabel.appendChild(this.input);
      new InputFieldManager(this.input, 0, true, Number.NaN, Number.NaN, () => {
        this.Text_TextChanged(null);
      });
      this.input.addEventListener("focusin", () => {
        this.control_GotFocus(this);
      });
      this.input.addEventListener("focusout", () => {
        this.control_LostFocus(this);
      });
      this.checkForReadOnly();
    }
  }
  refresh() {
    if (this.input == null)
      return;
    if (this._getValueCallback == null)
      return;
    let value = this._getValueCallback(this);
    if (value == null)
      return;
    let s = value.toString();
    if (this.input != null) {
      if (s != this.input.value)
        this.input.value = s;
    }
    this.checkForReadOnly();
  }
  Text_TextChanged(sender) {
    if (this.input != null) {
      this._value = this.input.value;
      Reflect.set(this._dataContainer, this._prop.name, this._value);
      if (this._valueChangeCallback != null)
        this._valueChangeCallback(this);
      if (this._changeCausesParentRefresh)
        this.parentNode.refresh();
    }
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value;
    this.input.value = value;
  }
  resize(top2, left1, left2, width) {
    this.mainlabel.style.height = this.input.offsetHeight.toString() + "px";
    return 0;
  }
};
var UIElementNumber = class extends UIElementGeneric {
  constructor(p, dataContainer, prop) {
    super(p, dataContainer, prop);
    this._value = 0;
    this.preExpandIfNeeded();
  }
  AllocateControls() {
    super.AllocateControls();
    if (this.input == null) {
      this.input = document.createElement("INPUT");
      this.input.type = "input";
      this.input.value = Reflect.get(this._dataContainer, this._prop.name);
      this.input.style.textAlign = "right";
      this.input.style.position = "absolute";
      this.input.style.marginTop = "0px";
      this.input.style.marginBottom = "0px";
      this.input.style.fontFamily = UIElement.defaultFontFamily;
      this.input.style.fontSize = UIElement.defaultFontSize.toString() + "px";
      this.input.type = "number";
      this.input.style.border = "1px solid grey";
      this.input.style.borderRadius = "1px";
      this.input.style.top = "0px";
      this.input.style.right = "3px";
      this.input.style.width = "50%";
      this.mainlabel.appendChild(this.input);
      new InputFieldManager(this.input, 4, false, Number.NaN, Number.NaN, () => {
        this.Text_TextChanged(null);
      });
      this.input.addEventListener("focusin", () => {
        this.control_GotFocus(this);
      });
      this.input.addEventListener("focusout", () => {
        this.control_LostFocus(this);
      });
      this.checkForReadOnly();
    }
  }
  refresh() {
    if (this.input == null)
      return;
    if (this._getValueCallback == null)
      return;
    let s = this._getValueCallback(this);
    if (s == null)
      return;
    if (this.input != null) {
      if (s != parseFloat(this.input.value))
        this.input.value = s.toString();
    }
    this.checkForReadOnly();
  }
  Text_TextChanged(sender) {
    if (this.input != null) {
      this._value = parseFloat(this.input.value);
      Reflect.set(this._dataContainer, this._prop.name, this._value);
      if (this._valueChangeCallback != null)
        this._valueChangeCallback(this);
      if (this._changeCausesParentRefresh)
        this.parentNode.refresh();
    }
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value;
    this.input.value = value.toString();
  }
  resize(top2, left1, left2, width) {
    this.mainlabel.style.height = this.input.offsetHeight.toString() + "px";
    return 0;
  }
};
var UIElementBoolean = class extends UIElementGeneric {
  constructor(p, dataContainer, prop) {
    super(p, dataContainer, prop);
    this._text = null;
    this._value = false;
    this.preExpandIfNeeded();
  }
  AllocateControls() {
    super.AllocateControls();
    if (this.input == null) {
      let span = document.createElement("SPAN");
      span.style.position = "absolute";
      span.style.display = "inline-block";
      span.style.width = "50%";
      span.style.right = "0px";
      this.mainlabel.appendChild(span);
      this.input = document.createElement("INPUT");
      this.input.type = "input";
      this.input.checked = Reflect.get(this._dataContainer, this._prop.name);
      this.input.style.textAlign = "right";
      this.input.style.display = "inline";
      this.input.style.marginTop = "0px";
      this.input.style.marginBottom = "0px";
      this.input.type = "checkbox";
      this.input.style.transform = "scale(" + constants.generalSizeCoef.toString() + ")";
      this.input.style.marginRight = Math.round(5 * constants.generalSizeCoef).toString() + "px";
      this.input.style.top = "0px";
      this.input.style.border = "1px solid grey";
      this.input.style.borderRadius = "1px";
      span.appendChild(this.input);
      this.input.addEventListener("keyup", (e) => {
        if (e.key === " ")
          this.value_TextChanged(null);
      });
      this.input.addEventListener("change", () => {
        this.value_TextChanged(null);
      });
      this._text = document.createElement("SPAN");
      this._text.style.display = "inline";
      this._text.style.fontFamily = UIElement.defaultFontFamily;
      this._text.style.fontSize = UIElement.defaultFontSize.toString() + "px";
      span.appendChild(this._text);
      this.updateText();
      this.input.addEventListener("focusin", () => {
        this.control_GotFocus(this);
      });
      this.input.addEventListener("focusout", () => {
        this.control_LostFocus(this);
      });
      this.checkForReadOnly();
    }
  }
  updateText() {
    this._text.innerText = this.input.checked ? "Enabled" : "Disabled";
  }
  refresh() {
    if (this.input == null)
      return;
    this.checkForReadOnly();
    if (this._getValueCallback == null)
      return;
    let v = this._getValueCallback(this);
    if (v == null)
      return;
    let b = v;
    if (this.input != null) {
      this.input.checked = b.valueOf();
      this.updateText();
    }
  }
  value_TextChanged(sender) {
    if (this.input != null) {
      this._value = this.input.checked;
      this.updateText();
      Reflect.set(this._dataContainer, this._prop.name, this._value);
      if (this._valueChangeCallback != null)
        this._valueChangeCallback(this);
      if (this._changeCausesParentRefresh)
        this.parentNode.refresh();
    }
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value;
    this.input.checked = value;
    this.updateText();
  }
  resize(top2, left1, left2, width) {
    return 0;
  }
};
var UIElementDoubleNan = class extends UIElementGeneric {
  constructor(p, dataContainer, prop) {
    super(p, dataContainer, prop);
    this._value = 0;
    this.preExpandIfNeeded();
  }
  AllocateControls() {
    super.AllocateControls();
    if (this.input == null) {
      this.input = document.createElement("INPUT");
      this.input.type = "input";
      this.input.value = Reflect.get(this._dataContainer, this._prop.name).toString();
      this.input.style.textAlign = "right";
      this.input.style.position = "absolute";
      this.input.style.marginTop = "0px";
      this.input.style.marginBottom = "0px";
      this.input.style.fontFamily = UIElement.defaultFontFamily;
      this.input.style.fontSize = UIElement.defaultFontSize.toString() + "px";
      this.input.type = "number";
      this.input.style.border = "1px solid grey";
      this.input.style.borderRadius = "1px";
      this.input.style.top = "0px";
      this.input.style.right = "3px";
      this.input.style.width = "50%";
      this.mainlabel.appendChild(this.input);
      new InputFieldManager(this.input, 4, true, Number.NaN, Number.NaN, () => {
        this.Text_TextChanged(null);
      });
      this.input.addEventListener("focusin", () => {
        this.control_GotFocus(this);
      });
      this.input.addEventListener("focusout", () => {
        this.control_LostFocus(this);
      });
      this.checkForReadOnly();
    }
  }
  refresh() {
    if (this.input == null)
      return;
    if (this._getValueCallback == null)
      return;
    let s = this._getValueCallback(this).toString();
    if (this.input != null) {
      if (s != this.input.value)
        this.input.value = s;
    }
    this.checkForReadOnly();
  }
  Text_TextChanged(sender) {
    if (this.input != null) {
      this._value = this.input.value == "" ? Number.NaN : parseFloat(this.input.value);
      Reflect.set(this._dataContainer, this._prop.name, new doubleNan(this._value));
      if (this._valueChangeCallback != null)
        this._valueChangeCallback(this);
      if (this._changeCausesParentRefresh)
        this.parentNode.refresh();
    }
  }
  get value() {
    return new doubleNan(this._value);
  }
  set value(value) {
    this._value = value.value;
    this.input.value = value.toString();
  }
  resize(top2, left1, left2, width) {
    this.mainlabel.style.height = this.input.offsetHeight.toString() + "px";
    return 0;
  }
};
var UIElementEnum = class extends UIElementGeneric {
  constructor(p, dataContainer, prop) {
    super(p, dataContainer, prop);
    this.allValues = [];
    this._value = "";
    this.preExpandIfNeeded();
  }
  AllocateControls() {
    super.AllocateControls();
    if (this.select == null) {
      this.select = document.createElement("SELECT");
      let enumvalue = Reflect.get(this._dataContainer, this._prop.name);
      this.allValues = enumvalue.sibblings;
      for (let i = 0; i < this.allValues.length; i++) {
        let opt = document.createElement("OPTION");
        opt.text = this.allValues[i].description;
        opt.value = this.allValues[i].toString;
        this.select.add(opt, null);
      }
      this.select.value = enumvalue.toString;
      this.select.style.position = "absolute";
      this.select.style.marginTop = "0px";
      this.select.style.marginBottom = "0px";
      this.select.style.fontFamily = UIElement.defaultFontFamily;
      this.select.style.fontSize = UIElement.defaultFontSize.toString() + "px";
      this.select.style.top = "0px";
      this.select.style.right = "3px";
      this.select.style.width = "50%";
      this.mainlabel.appendChild(this.select);
      this.select.addEventListener("change", () => {
        this.valueChanged(null);
      });
      this.select.addEventListener("focusin", () => {
        this.control_GotFocus(this);
      });
      this.select.addEventListener("focusout", () => {
        this.control_LostFocus(this);
      });
      this.checkForReadOnly();
    }
  }
  refresh() {
    if (this.select == null)
      return;
    if (this._getValueCallback == null)
      return;
    let value = this._getValueCallback(this);
    let s = value.toString;
    if (this.select != null) {
      if (s != this.select.value)
        this.select.value = s;
    }
    this.checkForReadOnly();
  }
  valueChanged(sender) {
    if (this.select != null) {
      this._value = this.select.value;
      let it = null;
      for (let i = 0; i < this.allValues.length; i++) {
        if (this.allValues[i].toString == this._value)
          it = this.allValues[i];
      }
      if (it != null)
        Reflect.set(this._dataContainer, this._prop.name, it);
      if (this._valueChangeCallback != null)
        this._valueChangeCallback(this);
      if (this._changeCausesParentRefresh)
        this.parentNode.refresh();
    }
  }
  tabReOrder(index) {
    if (this.select != null)
      this.select.tabIndex = index++;
    return index;
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value;
    this.select.value = value;
  }
  resize(top2, left1, left2, width) {
    this.mainlabel.style.height = this.select.offsetHeight.toString() + "px";
    return 0;
  }
};
var UIElementList = class extends UIElementGeneric {
  constructor(p, dataContainer, prop, allowedValues) {
    super(p, dataContainer, prop);
    this._refreshCallback = null;
    this._indexedValue = true;
    this.allValues = [];
    this.valueType = "";
    this._value = "";
    this._refreshCallback = allowedValues;
    this.preExpandIfNeeded();
  }
  AllocateControls() {
    super.AllocateControls();
    if (this.select == null) {
      this.allValues = this._refreshCallback();
      this.select = document.createElement("SELECT");
      let value = Reflect.get(this._dataContainer, this._prop.name);
      this.valueType = typeof value;
      this._indexedValue = typeof value == "number" && typeof this.allValues[0] != "number";
      let found = false;
      let first = null;
      for (let i = 0; i < this.allValues.length; i++) {
        let opt = document.createElement("OPTION");
        if (i == 0)
          first = opt;
        opt.text = this.allValues[i].toString();
        opt.value = this._indexedValue ? i : this.allValues[i];
        this.select.add(opt, null);
        if (opt.value.toString() == value.toString())
          found = true;
      }
      if (!found && !this._indexedValue) {
        let opt = document.createElement("OPTION");
        opt.text = value.toString();
        opt.value = value;
        this.select.add(opt, first);
      }
      this.select.value = value;
      this.select.style.position = "absolute";
      this.select.style.marginTop = "0px";
      this.select.style.marginBottom = "0px";
      this.select.style.fontFamily = UIElement.defaultFontFamily;
      this.select.style.fontSize = UIElement.defaultFontSize.toString() + "px";
      this.select.style.top = "0px";
      this.select.style.right = "3px";
      this.select.style.width = "50%";
      this.mainlabel.appendChild(this.select);
      this.select.addEventListener("change", () => {
        this.valueChanged(null);
      });
      this.select.addEventListener("focusin", () => {
        this.control_GotFocus(this);
      });
      this.select.addEventListener("focusout", () => {
        this.control_LostFocus(this);
      });
      this.checkForReadOnly();
    }
  }
  refresh() {
    if (this.select == null)
      return;
    if (this._getValueCallback == null)
      return;
    this.allValues = this._refreshCallback();
    for (let i = 0; i < this.allValues.length; i++) {
      let opt = i < this.select.options.length ? this.select.options[i] : document.createElement("OPTION");
      opt.text = this.allValues[i].toString();
      opt.value = this._indexedValue ? i : this.allValues[i];
      if (i >= this.select.options.length)
        this.select.add(opt, null);
    }
    while (this.allValues.length < this.select.options.length) {
      this.select.options[this.select.options.length - 1].remove();
    }
    let v = Reflect.get(this._dataContainer, this._prop.name);
    if (v == null)
      return;
    if (this._indexedValue) {
      let it = Number(v).toString();
      if (this.select.value != it)
        this.select.value = it;
    } else {
      let it = v.toString();
      if (this.select.value != it)
        this.select.value = it;
    }
    this.checkForReadOnly();
  }
  valueChanged(sender) {
    if (this.select != null) {
      this._value = this.select.value;
      if (this.valueType == "number") {
        let it = parseInt(this._value);
        if (it >= 0)
          Reflect.set(this._dataContainer, this._prop.name, it);
      } else {
        let it = "";
        for (let i = 0; i < this.allValues.length; i++) {
          if (this.allValues[i] == this._value)
            it = this.allValues[i];
        }
        if (it != "")
          Reflect.set(this._dataContainer, this._prop.name, it);
      }
      if (this._valueChangeCallback != null)
        this._valueChangeCallback(this);
      if (this._changeCausesParentRefresh) {
        this.parentNode.refresh();
      }
    }
  }
  tabReOrder(index) {
    if (this.select != null)
      this.select.tabIndex = index++;
    return index;
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value;
    this.select.value = value;
  }
  resize(top2, left1, left2, width) {
    this.mainlabel.style.height = this.select.offsetHeight.toString() + "px";
    return 0;
  }
};
var UIElementColor = class extends UIElementGeneric {
  constructor(p, dataContainer, prop) {
    super(p, dataContainer, prop);
    this.colorSample = null;
    this.colorEditor = null;
    this.colorPreview = null;
    this.currentColor = null;
    this._value = "";
    this.preExpandIfNeeded();
  }
  get expandIcon() {
    return ressources.DotDotDotIcon(UIElement.defaultFontSize.toString(), false, false, false, false, "Click to open color chooser");
  }
  get colapseIcon() {
    return ressources.DotDotDotIcon(UIElement.defaultFontSize.toString(), false, false, false, false, "Click to close color chooser");
  }
  AllocateControls() {
    this._expandable = true;
    this._expandButtonSide = 1;
    super.AllocateControls();
    if (this.input == null) {
      let table = document.createElement("TABLE");
      table.style.position = "absolute";
      table.style.top = "0px";
      table.style.right = "3px";
      table.style.width = "50%";
      table.style.borderCollapse = "collapse";
      let tr = document.createElement("TR");
      table.appendChild(tr);
      let td1 = document.createElement("TD");
      tr.appendChild(td1);
      this.colorSample = document.createElement("Div");
      this.colorSample.style.display = "inline-block";
      this.colorSample.style.border = "1px solid black";
      this.colorSample.style.marginRight = "1px";
      this.colorSample.style.marginTop = "0px";
      this.colorSample.style.width = "16px";
      this.colorSample.style.height = "16px";
      this.colorSample.style.top = "0px";
      this.colorSample.style.bottom = "0px";
      this.colorPreview = new ColorSampler(this.colorSample, null);
      td1.appendChild(this.colorSample);
      let td2 = document.createElement("TD");
      td2.style.width = "100%";
      tr.appendChild(td2);
      this.input = document.createElement("INPUT");
      this.input.type = "input";
      this.currentColor = Reflect.get(this._dataContainer, this._prop.name);
      this.colorPreview.color = this.currentColor;
      this.input.value = this.currentColor.toString();
      this.input.style.marginTop = "0px";
      this.input.style.marginBottom = "0px";
      this.input.style.width = "100%";
      this.input.style.border = "1px solid grey";
      this.input.style.borderRadius = "1px";
      this.input.style.fontFamily = UIElement.defaultFontFamily;
      this.input.style.fontSize = UIElement.defaultFontSize.toString() + "px";
      td2.appendChild(this.input);
      let td3 = document.createElement("TD");
      td3.style.paddingLeft = "5px";
      tr.appendChild(td3);
      td3.appendChild(this.expandCtrl);
      this.mainlabel.appendChild(table);
      new InputFieldManager(this.input, 7, false, Number.NaN, Number.NaN, (sender, refreshInput) => {
        this.Text_TextChanged(sender, refreshInput);
      });
      this.input.addEventListener("focusin", () => {
        this.control_GotFocus(this);
      });
      this.input.addEventListener("focusout", () => {
        this.control_LostFocus(this);
      });
      this.checkForReadOnly();
    }
  }
  expand() {
    if (this.colorEditor == null) {
      this.subElementPanel.style.marginLeft = "20px";
      this.colorEditor = new colorEditor(this.subElementPanel, UIElement.defaultFontSize, this.currentColor, (c) => {
        this.coloredited(c);
      });
    }
    this._rootNode.tabReOrder(0);
    this._expanded = true;
    this.subElementPanel.style.display = "";
    this.expandCtrl.innerHTML = this.colapseIcon;
  }
  colapse() {
    this.subElementPanel.style.display = "none";
    this.expandCtrl.innerHTML = this.expandIcon;
  }
  coloredited(newColor) {
    this.currentColor = newColor.clone();
    this.colorPreview.color = this.currentColor;
    this.input.value = this.currentColor.toString();
    Reflect.set(this._dataContainer, this._prop.name, this.currentColor);
    if (this._valueChangeCallback != null)
      this._valueChangeCallback(this);
    if (this._changeCausesParentRefresh)
      this.parentNode.refresh();
  }
  refresh() {
    if (this.input == null)
      return;
    if (this._getValueCallback == null)
      return;
    let c = this._getValueCallback(this);
    if (c != null) {
      if (this.colorPreview != null)
        this.colorPreview.color = c;
      if (this.input != null) {
        let s = c.toString();
        if (s != this.input.value)
          this.input.value = s;
      }
    }
    this.checkForReadOnly();
  }
  Text_TextChanged(sender, refreshInput) {
    if (this.input != null) {
      this._value = this.input.value;
      let c = YColor.FromString(this._value);
      if (c != null) {
        this.colorPreview.color = c;
        this.currentColor = c;
        if (this.colorEditor != null)
          this.colorEditor.color = c;
        Reflect.set(this._dataContainer, this._prop.name, c);
        if (refreshInput)
          this.input.value = c.toString();
        if (this._valueChangeCallback != null)
          this._valueChangeCallback(this);
        if (this._changeCausesParentRefresh)
          this.parentNode.refresh();
      }
    }
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value;
    this.input.value = value;
  }
  resize(top2, left1, left2, width) {
    let h = this.input.offsetHeight;
    this.mainlabel.style.height = h.toString() + "px";
    return 0;
  }
};
var UIElementMarkerPos = class extends UIElementGeneric {
  constructor(p, dataContainer, prop) {
    super(p, dataContainer, prop);
    this._cachedValue = null;
    this._value = "";
    this.preExpandIfNeeded();
  }
  static expandIconSVG(size) {
    return ressources.targetIcon(size.toString(), false, false, false, false, "Click to place marker on graph");
  }
  get expandIcon() {
    return UIElementMarkerPos.expandIconSVG(UIElement.defaultFontSize);
  }
  get colapseIcon() {
    return UIElementMarkerPos.expandIconSVG(UIElement.defaultFontSize);
  }
  AllocateControls() {
    this._expandable = true;
    this._expandButtonSide = 1;
    super.AllocateControls();
    if (this.input == null) {
      let table = document.createElement("TABLE");
      table.style.position = "absolute";
      table.style.top = "0px";
      table.style.right = "3px";
      table.style.width = "50%";
      table.style.borderCollapse = "collapse";
      let tr = document.createElement("TR");
      table.appendChild(tr);
      let td2 = document.createElement("TD");
      td2.style.width = "100%";
      tr.appendChild(td2);
      this.input = document.createElement("INPUT");
      this.input.type = "input";
      this._cachedValue = Reflect.get(this._dataContainer, this._prop.name);
      this.input.value = this._cachedValue.toString();
      this.input.style.marginTop = "0px";
      this.input.style.marginBottom = "0px";
      this.input.style.textAlign = "right";
      this.input.style.width = "100%";
      this.input.style.border = "1px solid grey";
      this.input.style.borderRadius = "1px";
      this.input.style.fontFamily = UIElement.defaultFontFamily;
      this.input.style.fontSize = UIElement.defaultFontSize.toString() + "px";
      this.input.addEventListener("keyup", () => {
        this.Text_TextChanged(null, true);
      });
      this.input.addEventListener("change", () => {
        this.Text_TextChanged(null, false);
      });
      td2.appendChild(this.input);
      let td3 = document.createElement("TD");
      td3.style.paddingLeft = "5px";
      tr.appendChild(td3);
      td3.appendChild(this.expandCtrl);
      this.mainlabel.appendChild(table);
      this.input.addEventListener("focusin", () => {
        this.control_GotFocus(this);
      });
      this.input.addEventListener("focusout", () => {
        this.control_LostFocus(this);
      });
      this.checkForReadOnly();
    }
  }
  expand() {
    let value = Reflect.get(this._dataContainer, this._prop.name);
    this.expanded = false;
    value.capture = true;
    Reflect.set(this._dataContainer, this._prop.name, value);
    if (this._valueChangeCallback != null)
      this._valueChangeCallback(this);
  }
  colapse() {
  }
  refresh() {
    if (this.input == null)
      return;
    if (this._getValueCallback == null)
      return;
    this._cachedValue = this._getValueCallback(this);
    if (this.input != null) {
      this.input.value = this._cachedValue.toString();
    }
    this.checkForReadOnly();
  }
  Text_TextChanged(sender, refreshInput) {
    let parsedValue = this._cachedValue.TryParse(this.input.value);
    if (parsedValue.success) {
      this._cachedValue.value = parsedValue.result;
      Reflect.set(this._dataContainer, this._prop.name, this._cachedValue);
      if (this._valueChangeCallback != null)
        this._valueChangeCallback(this);
      if (this._changeCausesParentRefresh)
        this.parentNode.refresh();
    }
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value;
    this.input.value = value;
  }
  resize(top2, left1, left2, width) {
    let h = this.input.offsetHeight;
    this.mainlabel.style.height = h.toString() + "px";
    return 0;
  }
};
var InputFieldManager = class {
  static nullCallback(sender) {
  }
  constructor(input, type, allowEmpty, min, max, callback) {
    this._allowEmpty = false;
    this._min = Number.NaN;
    this._max = Number.NaN;
    this._callback = null;
    this._input = input;
    this._type = type;
    this._allowEmpty = allowEmpty;
    this._min = min;
    this._max = max;
    this._callback = callback;
    this.checkData();
    this._input.addEventListener("keyup", () => {
      this.InputChange(this._input, true);
    });
    this._input.addEventListener("change", () => {
      this.InputChange(this._input, false);
    });
  }
  showError(msg) {
    this._input.title = msg;
  }
  clearError() {
    this._input.title = "";
  }
  backGroundColorFeedback(ErrorMsg, state) {
    if (state)
      this.clearError();
    else
      this.showError(ErrorMsg);
    let c = this._input.style.backgroundColor;
    if (state && c != "white")
      this._input.style.backgroundColor = "white";
    if (!state && c != "pink")
      this._input.style.backgroundColor = "pink";
    return state;
  }
  checkData() {
    let intValue = 0;
    let doubleValue = 0;
    if (this._input.disabled)
      return true;
    let strValue = this._input.value;
    if (strValue == "")
      return this.backGroundColorFeedback("This field can't be empty", this._allowEmpty);
    switch (this._type) {
      case 0:
        break;
      case 1:
        intValue = parseInt(strValue);
        doubleValue = parseFloat(strValue);
        if (Number.isNaN(intValue) || intValue != doubleValue)
          return this.backGroundColorFeedback("Integer value expected", false);
        if (!Number.isNaN(this._min) && intValue < this._min)
          return this.backGroundColorFeedback("Integer value greater or equal to " + this._min.toString() + " expected", false);
        if (!Number.isNaN(this._max) && intValue > this._max)
          return this.backGroundColorFeedback("Integer value lower or equal to  " + this._min.toString() + " expected", false);
        break;
      case 2:
        intValue = parseInt(strValue);
        doubleValue = parseFloat(strValue);
        if (Number.isNaN(intValue) || intValue != doubleValue)
          return this.backGroundColorFeedback("Positive integer  expected", false);
        if (intValue < 0)
          return this.backGroundColorFeedback("Positive integer value  expected", false);
        if (!Number.isNaN(this._min) && intValue < this._min)
          return this.backGroundColorFeedback("Positive integer value greater or equal to " + this._min.toString() + " expected", false);
        if (!Number.isNaN(this._max) && intValue > this._max)
          return this.backGroundColorFeedback("Positive integer value lower or equal to  " + this._min.toString() + " expected", false);
        break;
      case 3:
        intValue = parseInt(strValue);
        doubleValue = parseFloat(strValue);
        if (Number.isNaN(intValue) || intValue != doubleValue)
          return this.backGroundColorFeedback("Strictly positive Integer value expected", false);
        if (intValue <= 0)
          return this.backGroundColorFeedback("Strictly positive integer value  expected", false);
        if (!Number.isNaN(this._min) && intValue < this._min)
          return this.backGroundColorFeedback("Positive integer value greater or equal to " + this._min.toString() + " expected", false);
        if (!Number.isNaN(this._max) && intValue > this._max)
          return this.backGroundColorFeedback("Positive integer value lower or equal to  " + this._min.toString() + " expected", false);
        break;
      case 4:
        doubleValue = parseFloat(strValue);
        if (Number.isNaN(intValue))
          return this.backGroundColorFeedback("Floating point value expected", false);
        if (!Number.isNaN(this._min) && doubleValue < this._min)
          return this.backGroundColorFeedback("Floating point value greater or equal to " + this._min.toString() + " expected", false);
        if (!Number.isNaN(this._max) && doubleValue > this._max)
          return this.backGroundColorFeedback("Floating point value lower or equal to  " + this._min.toString() + " expected", false);
        break;
      case 5:
        doubleValue = parseFloat(strValue);
        if (Number.isNaN(doubleValue))
          return this.backGroundColorFeedback("Positive floating point value expected", false);
        if (doubleValue < 0)
          return this.backGroundColorFeedback("Positive floating point value expected", false);
        if (!Number.isNaN(this._min) && doubleValue < this._min)
          return this.backGroundColorFeedback("Floating point value greater or equal to " + this._min.toString() + " expected", false);
        if (!Number.isNaN(this._max) && doubleValue > this._max)
          return this.backGroundColorFeedback("Floating point value lower or equal to  " + this._min.toString() + " expected", false);
        break;
      case 6:
        doubleValue = parseFloat(strValue);
        if (Number.isNaN(doubleValue))
          return this.backGroundColorFeedback("Strictly positive floating point value expected", false);
        if (doubleValue <= 0)
          return this.backGroundColorFeedback("Strictly positive floating point value expected", false);
        if (!Number.isNaN(this._min) && doubleValue < this._min)
          return this.backGroundColorFeedback("Floating point value greater or equal to " + this._min.toString() + " expected", false);
        if (!Number.isNaN(this._max) && doubleValue > this._max)
          return this.backGroundColorFeedback("Floating point value greater or equal to " + this._min.toString() + " expected", false);
        break;
      case 7:
        if (YColor.FromString(strValue) == null)
          return this.backGroundColorFeedback("Value color name/definition expected", false);
        break;
    }
    return this.backGroundColorFeedback("", true);
  }
  InputChange(sender, refreshInput) {
    if (this.checkData()) {
      try {
        if (this._callback != null)
          this._callback(sender, refreshInput);
      } catch (ex) {
        this.backGroundColorFeedback(ex.message, false);
      }
    }
  }
};

// obj/full/colorEditor_rw.js
var ColorEditorTab = class {
  constructor(editor, label, fontSize) {
    this._realTab = false;
    this._div = null;
    this._tabLabel = null;
    this._td = document.createElement("TD");
    this._editor = editor;
    if (label != "") {
      this._div = document.createElement("DIV");
      this._div.style.display = "none";
      this._td.style.paddingTop = "4px";
      this._td.style.fontSize = fontSize.toString() + "px";
      this._td.style.paddingBottom = "2px";
      this._td.style.borderLeft = "1px solid " + this._editor.inactiveBorderColor;
      this._td.style.borderRight = "1px solid " + this._editor.inactiveBorderColor;
      this._td.style.borderTop = "1px solid " + this._editor.inactiveBorderColor;
      this._td.style.borderBottom = "1px solid " + this._editor.activeBorderColor;
      this._td.style.color = this._editor.inactiveColor;
      this._td.style.backgroundColor = this._editor.inactiveBackgroundColor;
      this._td.style.borderTopLeftRadius = "3px";
      this._td.style.borderTopRightRadius = "3px";
      this._td.style.paddingLeft = "5px";
      this._td.style.paddingRight = "5px";
      this._realTab = true;
      this._tabLabel = document.createElement("ANCHOR");
      this._tabLabel.innerText = label;
      this._tabLabel.addEventListener("click", () => {
        this._editor.tabSelected(this);
      });
      this._tabLabel.addEventListener("keyup", (e) => {
        if (e.key === "Enter" || e.key === " ")
          this._editor.tabSelected(this);
      });
      this._tabLabel.style.cursor = "pointer";
      this._td.appendChild(this._tabLabel);
    } else {
      this._td.style.borderBottom = "1px solid " + this._editor.activeBorderColor;
      this._td.innerHTML = "<span>&nbsp;</span>";
    }
  }
  setTabIndex(index) {
    this._tabLabel.tabIndex = index++;
    return index;
  }
  set active(value) {
    if (!this._realTab)
      return;
    this._td.style.borderLeftColor = value ? this._editor.activeBorderColor : this._editor.inactiveBorderColor;
    this._td.style.borderTopColor = value ? this._editor.activeBorderColor : this._editor.inactiveBorderColor;
    this._td.style.borderRightColor = value ? this._editor.activeBorderColor : this._editor.inactiveBorderColor;
    this._td.style.borderBottomColor = value ? "rgba(0, 0, 0, 0)" : this._editor.activeBorderColor;
    this._td.style.color = value ? this._editor.activeColor : this._editor.inactiveColor;
    this._td.style.backgroundColor = value ? this._editor.activeBackgroundColor : this._editor.inactiveBackgroundColor;
    this._div.style.display = value ? "" : "none";
  }
  get active() {
    return this._div.style.display == "";
  }
  get tabElement() {
    return this._td;
  }
  get divElement() {
    return this._div;
  }
};
var ColorEditorSroll = class {
  setTabIndex(index) {
    this._anchor.tabIndex = index++;
    this._input.tabIndex = index++;
    return index;
  }
  constructor(div, anchor, input, colorCallback, changeCallBack, checkerBoardBg, value) {
    this._value = 0;
    this._colorCallback = colorCallback;
    this._changeCallBack = changeCallBack;
    this._value = value;
    this._div = div;
    let s = ColorEditorSroll.scrollHeight;
    if (checkerBoardBg)
      this._div.style.background = "url('data:image/svg+xml;utf8," + ColorSampler.checkerboardImage(s, s) + "')";
    this._anchor = anchor;
    this._input = input;
    this._input.size = 3;
    this._input.maxLength = 3;
    this._input.type = "number";
    this._input.min = "0";
    this._input.max = "255";
    this._input.style.fontSize = (12 * constants.guiDPIFactor).toString() + "px";
    this._input.style.textAlign = "right";
    this._input.value = this._value.toString();
    this._input.style.marginLeft = "10px";
    this._div.style.width = "100%";
    this._div.style.position = "relative";
    this._div.style.height = ColorEditorSroll.scrollHeight.toString() + "px";
    this._div.style.border = "1px solid black";
    this._canvasBg = document.createElement("CANVAS");
    this._div.appendChild(this._canvasBg);
    this._canvasBg.style.left = "0px";
    this._canvasBg.style.top = "0px";
    this._canvasBg.style.width = "100%";
    this._canvasBg.style.height = "100%";
    this._canvasBg.width = 256;
    this._canvasBg.height = ColorEditorSroll.scrollHeight;
    this._canvasCursor = document.createElement("CANVAS");
    this._div.appendChild(this._canvasCursor);
    this._canvasCursor.style.position = "absolute";
    this._canvasCursor.style.width = "100%";
    this._canvasCursor.style.height = "100%";
    this._canvasCursor.style.left = "0px";
    this._canvasCursor.style.top = "0px";
    this._canvasCursor.style.display = "block";
    this._div.addEventListener("mousedown", (e) => {
      this.MouseDown(this._div, e);
    });
    this._div.addEventListener("mousemove", (e) => {
      this.MouseMove(this._div, e);
    });
    this._anchor.addEventListener("wheel", (e) => {
      this.mouseWheelEvent(this._div, e);
    });
    this._anchor.addEventListener("keydown", (e) => {
      this.KeyDown(this._div, e);
    });
    this._input.addEventListener("keyup", (e) => {
      this.inputKeyUp();
    });
    this._input.addEventListener("change", (e) => {
      this.inputKeyUp();
    });
    this._anchor.tabIndex = 4;
  }
  get value() {
    return this._value;
  }
  set value(v) {
    if (v < 0)
      v = 0;
    if (v > 255)
      v = 255;
    this._value = v;
    this._input.value = this._value.toString();
  }
  inputKeyUp() {
    let value = parseInt(this._input.value);
    if (isNaN(value))
      return;
    if (value < 0)
      value = 0;
    if (value > 255)
      value = 255;
    this._value = value;
    this.refresh();
    this._changeCallBack(this);
  }
  TouchStart(div, e) {
    if (e.touches.length == 1)
      this.handleMouseStartCapture(div, e.touches[0].clientX, e.touches[0].clientY);
  }
  TouchCaptureRun(div, e) {
    if (e.touches.length == 1)
      this.handleMouseRun(div, e.touches[0].clientX, e.touches[0].clientY);
  }
  TouchCaptureEnd(div, e) {
  }
  MouseDown(sender, e) {
    if (e.buttons != 1)
      return;
    this.handleMouseStartCapture(sender, e.clientX, e.clientY);
  }
  handleMouseStartCapture(sender, x, y) {
    let SenderRect = sender.getBoundingClientRect();
    let eX = Math.round(x - SenderRect.left);
    let index = Math.round(256 * eX / this._div.offsetWidth) >> 0;
    if (index < 0)
      index = 0;
    if (index > 255)
      index = 255;
    this._value = index;
    this._input.value = index.toString();
    this.refresh();
    this._changeCallBack(this);
  }
  MouseMove(sender, e) {
    if (e.buttons != 1)
      return;
    this.handleMouseRun(sender, e.clientX, e.clientY);
  }
  handleMouseRun(sender, x, y) {
    let SenderRect = sender.getBoundingClientRect();
    let eX = Math.round(x - SenderRect.left);
    let index = Math.round(256 * eX / this._div.offsetWidth) >> 0;
    if (index < 0)
      index = 0;
    if (index > 255)
      index = 255;
    this._value = index;
    this._input.value = index.toString();
    this.refresh();
    this._changeCallBack(this);
  }
  mouseWheelEvent(sender, e) {
    this._value += e.deltaY > 0 ? -1 : 1;
    if (this._value < 0) {
      this._value = 0;
    } else if (this._value > 255) {
      this._value = 255;
    } else {
      e.preventDefault();
    }
    this._input.value = this._value.toString();
    this.refresh();
    this._changeCallBack(this);
  }
  KeyDown(sender, e) {
    if (e.code == "ArrowRight") {
      this._value++;
      if (this._value > 255)
        this._value = 255;
    }
    if (e.code == "ArrowLeft") {
      this._value--;
      if (this._value < 0)
        this._value = 0;
    }
    this._input.value = this._value.toString();
    this.refresh();
    this._changeCallBack(this);
  }
  refresh() {
    let color = this._colorCallback(this);
    let ctx = this._canvasBg.getContext("2d");
    ctx.clearRect(0, 0, this._canvasBg.width, this._canvasBg.height);
    for (let i = 0; i < 256; i++) {
      ctx.beginPath();
      ctx.moveTo(i + 0.5, 0);
      ctx.lineTo(i + 0.5, ColorEditorSroll.scrollHeight);
      ctx.strokeStyle = color[i];
      ctx.stroke();
    }
    this._canvasCursor.width = this._div.offsetWidth;
    this._canvasCursor.height = this._div.offsetHeight;
    ctx = this._canvasCursor.getContext("2d");
    let x = 0.5 + this._value / 255 * this._canvasCursor.width;
    ctx.beginPath();
    let y = 0.5;
    ctx.moveTo(x, y + 5);
    ctx.lineTo(x + 3, y);
    ctx.lineTo(x - 3, y);
    ctx.fillStyle = "black";
    ctx.strokeStyle = "white";
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
    y = this._canvasCursor.height - 0.5;
    ctx.beginPath();
    ctx.moveTo(x, y - 5);
    ctx.lineTo(x + 3, y);
    ctx.lineTo(x - 3, y);
    ctx.fillStyle = "black";
    ctx.strokeStyle = "white";
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
  }
};
ColorEditorSroll.scrollHeight = 26 * constants.guiDPIFactor;
var ColorSampler = class {
  setTabIndex(index) {
    this._colorDiv.tabIndex = index++;
    return index;
  }
  static checkerboardImage(width, height) {
    let halfWidth = width >> 1;
    let halfHeight = height >> 1;
    return '<svg xmlns="http://www.w3.org/2000/svg"   viewbox="0 0 ' + width + " " + height + '" width="' + width + 'px"  height="' + height + 'px" ><rect x="0" y="0" width="' + width + '" height="' + height + '" style="fill:white"/><rect x="0" y="0" width="' + halfWidth + '" height="' + halfHeight + '" style="fill:black"/><rect x="' + halfWidth + '" y="' + halfHeight + '" width="' + halfWidth + '" height="' + halfHeight + '" style="fill:black"/></svg>';
  }
  constructor(containerDiv, selectCallback) {
    this._containerDiv = containerDiv;
    this._selectCallback = selectCallback;
    this._containerDiv.style.border = "1px solid grey";
    this._containerDiv.style.background = "url('data:image/svg+xml;utf8," + ColorSampler.checkerboardImage(100, 100) + "')";
    this._containerDiv.style.backgroundSize = "cover";
    this._containerDiv.style.backgroundPosition = "center";
    this._containerDiv.style.backgroundRepeat = "no-repeat";
    this._color = YColor.Transparent;
    this._colorDiv = document.createElement("DIV");
    this._colorDiv.style.display = "display-block";
    this._colorDiv.style.position = "relative";
    this._colorDiv.style.width = "100%";
    this._colorDiv.style.height = "100%";
    this._colorDiv.style.backgroundColor = "rgba(0,0,0,0)";
    this._containerDiv.appendChild(this._colorDiv);
    if (this._selectCallback != null) {
      this._colorDiv.addEventListener("click", () => {
        this._selectCallback(this.color);
      });
      this._colorDiv.addEventListener("keyup", (e) => {
        if (e.key === "Enter" || e.key === " ")
          this._selectCallback(this.color);
      });
      this._colorDiv.style.cursor = "pointer";
    }
  }
  set color(value) {
    this._color = value.clone();
    this._colorDiv.style.backgroundColor = this._color.htmlCode;
  }
  get color() {
    return this._color.clone();
  }
};
var colorEditor = class {
  static AddColorToHistory(c) {
    for (let i = 0; i < colorEditor._colorHistory.length; i++) {
      if (c.equal(colorEditor._colorHistory[i]))
        return;
    }
    colorEditor._colorHistory.splice(colorEditor._colorHistory.length - 1, 1);
    colorEditor._colorHistory.splice(0, 0, c);
    for (let i = colorEditor._editorsList.length - 1; i >= 0; i--) {
      colorEditor._editorsList[i].refreshColorHistory();
    }
  }
  static get colorHistory() {
    return colorEditor._colorHistory;
  }
  get activeBorderColor() {
    return "#767676";
  }
  get inactiveBorderColor() {
    return "#b0b0b0";
  }
  get activeColor() {
    return "black";
  }
  get inactiveColor() {
    return "grey";
  }
  get activeBackgroundColor() {
    return "white";
  }
  get inactiveBackgroundColor() {
    return "#f8f8f8";
  }
  tabSelected(source) {
    if (source == this._tabRGB) {
      this._tabRGB.active = true;
      this._rgb_R_editor.refresh();
      this._rgb_G_editor.refresh();
      this._rgb_B_editor.refresh();
      this._rgb_T_editor.refresh();
    } else {
      this._tabRGB.active = false;
    }
    if (source == this._tabHSL) {
      this._tabHSL.active = true;
      this._hsl_H_editor.refresh();
      this._hsl_S_editor.refresh();
      this._hsl_L_editor.refresh();
      this._hsl_T_editor.refresh();
    } else {
      this._tabHSL.active = false;
    }
    this._tabPredef.active = source == this._tabPredef;
  }
  HueScrollBg() {
    let s = 100;
    let l = 50;
    let t = this._hsl_T_editor.value / 255;
    let res = new Array(256);
    for (let i = 0; i < 256; i++) {
      res[i] = "hsl(" + (360 * i / 256).toString() + "," + s.toString() + "%," + l.toString() + "%)";
    }
    return res;
  }
  SaturationScrollBg() {
    let h = 360 * this._hsl_H_editor.value / 256;
    let l = 100 * this._hsl_L_editor.value / 255;
    let t = this._hsl_T_editor.value / 255;
    let res = new Array(256);
    for (let i = 0; i < 256; i++) {
      res[i] = "hsl(" + h.toString() + "," + (100 * i / 255).toString() + "%," + l.toString() + "%)";
    }
    return res;
  }
  LuminosityScrollBg() {
    let h = 360 * this._hsl_H_editor.value / 256;
    let s = 100 * this._hsl_S_editor.value / 255;
    let t = this._hsl_T_editor.value / 255;
    let res = new Array(256);
    for (let i = 0; i < 256; i++) {
      res[i] = "hsl(" + h.toString() + "," + s.toString() + "%," + (100 * i / 255).toString() + "%)";
    }
    return res;
  }
  HSLTranspScrollBg() {
    let h = 360 * this._hsl_H_editor.value / 256;
    let s = 100 * this._hsl_S_editor.value / 255;
    let l = 100 * this._hsl_L_editor.value / 255;
    let res = new Array(256);
    for (let i = 0; i < 256; i++) {
      res[i] = "hsla(" + h.toString() + "," + l.toString() + "%," + s.toString() + "%," + (i / 255).toString() + ")";
    }
    return res;
  }
  RedScrollBg() {
    let g = this._rgb_G_editor.value;
    let b = this._rgb_B_editor.value;
    let t = this._rgb_T_editor.value / 255;
    let res = new Array(256);
    for (let i = 0; i < 256; i++) {
      res[i] = "rgb(" + i.toString() + "," + g.toString() + "," + b.toString() + ")";
    }
    return res;
  }
  GreenScrollBg() {
    let r = this._rgb_R_editor.value;
    let b = this._rgb_B_editor.value;
    let t = this._rgb_T_editor.value / 255;
    let res = new Array(256);
    for (let i = 0; i < 256; i++) {
      res[i] = "rgb(" + r.toString() + "," + i.toString() + "," + b.toString() + ")";
    }
    return res;
  }
  BlueScrollBg() {
    let r = this._rgb_R_editor.value;
    let g = this._rgb_G_editor.value;
    let t = this._rgb_T_editor.value / 255;
    let res = new Array(256);
    for (let i = 0; i < 256; i++) {
      res[i] = "rgb(" + r.toString() + "," + g.toString() + "," + i.toString() + ")";
    }
    return res;
  }
  RGBTranspScrollBg() {
    let r = this._rgb_R_editor.value;
    let g = this._rgb_G_editor.value;
    let b = this._rgb_B_editor.value;
    let res = new Array(256);
    for (let i = 0; i < 256; i++) {
      res[i] = "rgba(" + r.toString() + "," + g.toString() + "," + b.toString() + "," + (i / 255).toString() + ")";
    }
    return res;
  }
  static defaultColorHistory() {
    let defaultHistory = [];
    defaultHistory.push(YColor.FromAhsl(100, 0, 0, 0));
    defaultHistory.push(YColor.FromAhsl(100, 0, 0, 51));
    defaultHistory.push(YColor.FromAhsl(100, 0, 0, 102));
    defaultHistory.push(YColor.FromAhsl(100, 0, 0, 153));
    defaultHistory.push(YColor.FromAhsl(100, 0, 0, 204));
    defaultHistory.push(YColor.FromAhsl(100, 0, 0, 255));
    defaultHistory.push(YColor.FromAhsl(100, 0, 255, 127));
    defaultHistory.push(YColor.FromAhsl(100, 42, 255, 127));
    defaultHistory.push(YColor.FromAhsl(100, 85, 255, 127));
    defaultHistory.push(YColor.FromAhsl(100, 96, 255, 127));
    defaultHistory.push(YColor.FromAhsl(100, 127, 255, 127));
    defaultHistory.push(YColor.FromAhsl(100, 170, 255, 127));
    defaultHistory.push(YColor.FromAhsl(100, 192, 255, 127));
    defaultHistory.push(YColor.FromAhsl(100, 212, 255, 127));
    defaultHistory.push(YColor.FromAhsl(255, 226, 217, 214));
    return defaultHistory;
  }
  destroy() {
    for (let i = colorEditor._editorsList.length - 1; i >= 0; i--) {
      if (colorEditor._editorsList[i] == this) {
        colorEditor._editorsList.splice(i, 1);
      }
    }
  }
  refreshColorHistory() {
    for (let i = 0; i < this._samples.length; i++) {
      if (i < colorEditor._colorHistory.length) {
        this._samples[i].color = colorEditor._colorHistory[i].clone();
      }
    }
  }
  constructor(container, fontSize, initialColor, colorChangeCallback) {
    this._firstTabIndex = 0;
    this._memorizeTimer = null;
    colorEditor._editorsList.push(this);
    this._colorChangeCallback = colorChangeCallback;
    this._container = container;
    this._table = document.createElement("TABLE");
    this._table.style.width = "100%";
    this._table.style.borderSpacing = "0";
    this._table.style.paddingLeft = "5px";
    this._table.style.paddingTop = "5px";
    this._table.style.paddingRight = "5px";
    this._table.style.borderCollapse = "separate";
    this._tr1 = document.createElement("TR");
    this._tr2 = document.createElement("TR");
    this._tabRGB = new ColorEditorTab(this, "RGB", fontSize);
    this._tabHSL = new ColorEditorTab(this, "HSL", fontSize);
    this._tabPredef = new ColorEditorTab(this, "Predefined", fontSize);
    this._tabStub = new ColorEditorTab(this, "", fontSize);
    this._contents = document.createElement("TD");
    this._contents.colSpan = 4;
    this._contents.style.borderLeft = "1px solid " + this.activeBorderColor;
    this._contents.style.borderRight = "1px solid " + this.activeBorderColor;
    this._contents.style.borderBottom = "1px solid " + this.activeBorderColor;
    this._contents.style.backgroundColor = this.activeBackgroundColor;
    this._tr1.appendChild(this._tabRGB.tabElement);
    this._tr1.appendChild(this._tabHSL.tabElement);
    this._tr1.appendChild(this._tabPredef.tabElement);
    this._tr1.appendChild(this._tabStub.tabElement);
    this._tr2.appendChild(this._contents);
    this._table.appendChild(this._tr1);
    this._table.appendChild(this._tr2);
    this._contents.appendChild(this._tabRGB.divElement);
    this._contents.appendChild(this._tabHSL.divElement);
    this._contents.appendChild(this._tabPredef.divElement);
    let RGBtable = document.createElement("TABLE");
    RGBtable.style.width = "100%";
    RGBtable.style.borderSpacing = "1";
    this._tabRGB.divElement.appendChild(RGBtable);
    let HSLtable = document.createElement("TABLE");
    HSLtable.style.width = "100%";
    HSLtable.style.borderSpacing = "1";
    this._tabHSL.divElement.appendChild(HSLtable);
    let predefTable = document.createElement("TABLE");
    this._tabPredef.divElement.appendChild(predefTable);
    predefTable.style.width = "100%";
    predefTable.style.borderSpacing = "1";
    predefTable.style.tableLayout = "fixed";
    this._container.appendChild(this._table);
    this._rgb_R_editor = this.AddColorScroll(RGBtable, "R", () => {
      return this.RedScrollBg();
    }, (src) => {
      this.RgbColorChangeCallBack(src);
    }, false, 1);
    this._rgb_G_editor = this.AddColorScroll(RGBtable, "G", () => {
      return this.GreenScrollBg();
    }, (src) => {
      this.RgbColorChangeCallBack(src);
    }, false, 2);
    this._rgb_B_editor = this.AddColorScroll(RGBtable, "B", () => {
      return this.BlueScrollBg();
    }, (src) => {
      this.RgbColorChangeCallBack(src);
    }, false, 3);
    this._rgb_T_editor = this.AddColorScroll(RGBtable, "T", () => {
      return this.RGBTranspScrollBg();
    }, (src) => {
      this.RgbColorChangeCallBack(src);
    }, true, 3);
    this._rgb_R_editor.value = initialColor.red;
    this._rgb_G_editor.value = initialColor.green;
    this._rgb_B_editor.value = initialColor.blue;
    this._rgb_T_editor.value = initialColor.alpha;
    this._rgb_R_editor.refresh();
    this._rgb_G_editor.refresh();
    this._rgb_B_editor.refresh();
    this._rgb_T_editor.refresh();
    this._hsl_H_editor = this.AddColorScroll(HSLtable, "H", () => {
      return this.HueScrollBg();
    }, (src) => {
      this.HslColorChangeCallBack(src);
    }, false, 1);
    this._hsl_S_editor = this.AddColorScroll(HSLtable, "S", () => {
      return this.SaturationScrollBg();
    }, (src) => {
      this.HslColorChangeCallBack(src);
    }, false, 2);
    this._hsl_L_editor = this.AddColorScroll(HSLtable, "L", () => {
      return this.LuminosityScrollBg();
    }, (src) => {
      this.HslColorChangeCallBack(src);
    }, false, 3);
    this._hsl_T_editor = this.AddColorScroll(HSLtable, "T", () => {
      return this.HSLTranspScrollBg();
    }, (src) => {
      this.HslColorChangeCallBack(src);
    }, true, 3);
    this._hsl_H_editor.value = initialColor.hue;
    this._hsl_S_editor.value = initialColor.saturation;
    this._hsl_L_editor.value = initialColor.luminosity;
    this._hsl_T_editor.value = initialColor.alpha;
    this._hsl_H_editor.refresh();
    this._hsl_S_editor.refresh();
    this._hsl_L_editor.refresh();
    this._hsl_T_editor.refresh();
    let samplesTable = document.createElement("TABLE");
    samplesTable.style.position = "relative";
    samplesTable.style.width = "100%";
    samplesTable.style.paddingLeft = "3px";
    samplesTable.style.paddingRight = "3px";
    samplesTable.style.paddingTop = "10px";
    samplesTable.style.bottom = "3px";
    samplesTable.style.tableLayout = "fixed";
    let samplesTD = [];
    let previewTD = null;
    let sampleHeight = 30;
    let sampletr1 = document.createElement("TR");
    sampletr1.style.height = sampleHeight.toString() + "px";
    for (let i = 0; i < 6; i++) {
      let td = document.createElement("TD");
      if (i == 5) {
        td.colSpan = 2;
        td.rowSpan = 3;
        previewTD = td;
      } else {
        samplesTD.push(td);
      }
      sampletr1.appendChild(td);
    }
    samplesTable.appendChild(sampletr1);
    let sampletr2 = document.createElement("TR");
    sampletr2.style.height = sampleHeight.toString() + "px";
    for (let i = 0; i < 5; i++) {
      let td = document.createElement("TD");
      samplesTD.push(td);
      sampletr2.appendChild(td);
    }
    samplesTable.appendChild(sampletr2);
    let sampletr3 = document.createElement("TR");
    sampletr3.style.height = sampleHeight.toString() + "px";
    for (let i = 0; i < 5; i++) {
      let td = document.createElement("TD");
      samplesTD.push(td);
      sampletr3.appendChild(td);
    }
    samplesTable.appendChild(sampletr3);
    this._container.appendChild(samplesTable);
    this._samples = [];
    for (let i = 0; i < samplesTD.length; i++) {
      let div2 = document.createElement("DIV");
      div2.style.position = "relative";
      div2.style.width = "100%";
      div2.style.height = (sampleHeight - 4).toString() + "px";
      div2.style.display = "inline-block";
      div2.title = "Color history";
      samplesTD[i].appendChild(div2);
      let sampler = new ColorSampler(div2, (c) => {
        this.sampleWasSelectedCallback(c);
      });
      sampler.color = colorEditor._colorHistory[i];
      this._samples.push(sampler);
    }
    let prefinedColors = YColor.predefinedColors;
    let colors = [];
    let predefinedColorNames = Object.keys(prefinedColors);
    for (let i = 0; i < predefinedColorNames.length; i++) {
      colors.push(prefinedColors[predefinedColorNames[i]]);
    }
    colors.sort((c1, c2) => {
      if (c1.alpha < c2.alpha)
        return 1;
      if (c1.alpha > c2.alpha)
        return -1;
      if (c1.luminosity < c2.luminosity)
        return 1;
      if (c1.luminosity > c2.luminosity)
        return -1;
      if (c1.saturation < c2.saturation)
        return 1;
      if (c1.saturation > c2.saturation)
        return -1;
      if (c1.hue < c2.hue)
        return 1;
      if (c1.hue > c2.hue)
        return -1;
      return 0;
    });
    let currenTR = null;
    this._prefedDivs = [];
    for (let i = 0; i < colors.length; i++) {
      let c = colors[i];
      if (i % 16 == 0) {
        currenTR = document.createElement("TR");
        predefTable.appendChild(currenTR);
      }
      let td = document.createElement("TD");
      currenTR.appendChild(td);
      let div2 = document.createElement("DIV");
      this._prefedDivs.push(div2);
      div2.style.position = "relative";
      div2.style.width = "100%";
      div2.style.height = Math.round(10 * constants.guiDPIFactor).toString() + "px";
      div2.style.display = "inline-block";
      div2.title = c.name;
      td.appendChild(div2);
      let sampler = new ColorSampler(div2, (c2) => {
        this.sampleWasSelectedCallback(c2);
      });
      sampler.color = c;
    }
    let div = document.createElement("DIV");
    div.style.position = "relative";
    div.style.width = "100%";
    div.style.height = (3 * sampleHeight).toString() + "px";
    div.style.display = "inline-block";
    div.title = "Color preview";
    previewTD.appendChild(div);
    this._preview = new ColorSampler(div, null);
    this._preview.color = initialColor;
    this.selectApropriateTab(initialColor);
  }
  selectApropriateTab(color) {
    if (color.isPredefined) {
      this._tabPredef.active = true;
      this.tabSelected(this._tabPredef);
    } else {
      this._tabPredef.active = false;
      if (color.isRGB) {
        this._tabRGB.active = true;
        this._tabHSL.active = false;
        this.tabSelected(this._tabRGB);
      } else {
        this._tabRGB.active = false;
        this._tabHSL.active = true;
        this.tabSelected(this._tabHSL);
      }
    }
  }
  sampleWasSelectedCallback(color) {
    this._rgb_R_editor.value = color.red;
    this._rgb_G_editor.value = color.green;
    this._rgb_B_editor.value = color.blue;
    this._rgb_T_editor.value = color.alpha;
    this._hsl_H_editor.value = color.hue;
    this._hsl_S_editor.value = color.saturation;
    this._hsl_L_editor.value = color.luminosity;
    this._hsl_T_editor.value = color.alpha;
    this._preview.color = color;
    this._rgb_R_editor.refresh();
    this._rgb_G_editor.refresh();
    this._rgb_B_editor.refresh();
    this._rgb_T_editor.refresh();
    this._hsl_H_editor.refresh();
    this._hsl_S_editor.refresh();
    this._hsl_L_editor.refresh();
    this._hsl_T_editor.refresh();
    this.initColorMemorization(color);
    if (this._colorChangeCallback != null)
      this._colorChangeCallback(color);
  }
  initColorMemorization(color) {
    if (this._memorizeTimer != null)
      clearTimeout(this._memorizeTimer);
    this._memorizeTimer = setTimeout(() => {
      this._memorizeTimer = null;
      colorEditor.AddColorToHistory(color);
    }, 2e3);
  }
  RgbColorChangeCallBack(src) {
    if (src != this._rgb_R_editor)
      this._rgb_R_editor.refresh();
    if (src != this._rgb_G_editor)
      this._rgb_G_editor.refresh();
    if (src != this._rgb_B_editor)
      this._rgb_B_editor.refresh();
    if (src != this._rgb_T_editor)
      this._rgb_T_editor.refresh();
    let color = YColor.FromArgb(this._rgb_T_editor.value, this._rgb_R_editor.value, this._rgb_G_editor.value, this._rgb_B_editor.value);
    this._preview.color = color;
    this.initColorMemorization(color);
    if (this._colorChangeCallback != null)
      this._colorChangeCallback(color);
  }
  HslColorChangeCallBack(src) {
    if (src != this._hsl_H_editor)
      this._hsl_H_editor.refresh();
    if (src != this._hsl_S_editor)
      this._hsl_S_editor.refresh();
    if (src != this._hsl_L_editor)
      this._hsl_L_editor.refresh();
    if (src != this._hsl_T_editor)
      this._hsl_T_editor.refresh();
    let color = YColor.FromAhsl(this._hsl_T_editor.value, this._hsl_H_editor.value, this._hsl_S_editor.value, this._hsl_L_editor.value);
    this._preview.color = color;
    this.initColorMemorization(color);
    if (this._colorChangeCallback != null)
      this._colorChangeCallback(color);
  }
  set color(color) {
    this._preview.color = color;
    this._hsl_H_editor.value = color.hue;
    this._hsl_S_editor.value = color.saturation;
    this._hsl_L_editor.value = color.luminosity;
    this._hsl_T_editor.value = color.alpha;
    this._rgb_R_editor.value = color.red;
    this._rgb_G_editor.value = color.green;
    this._rgb_B_editor.value = color.blue;
    this._rgb_T_editor.value = color.alpha;
    this._hsl_H_editor.refresh();
    this._hsl_S_editor.refresh();
    this._hsl_L_editor.refresh();
    this._hsl_T_editor.refresh();
    this._rgb_R_editor.refresh();
    this._rgb_G_editor.refresh();
    this._rgb_B_editor.refresh();
    this._rgb_T_editor.refresh();
    this.selectApropriateTab(color);
  }
  AddColorScroll(container, label, colorCallback, changeCallBack, checkerBoardBg, value) {
    let RGB_R_Row = document.createElement("TR");
    let RGB_R_Col1 = document.createElement("TD");
    RGB_R_Col1.innerHTML = "&nbsp;" + label + "&nbsp;";
    let RGB_R_Col2 = document.createElement("TD");
    let RGB_R_Anchor = document.createElement("ANCHOR");
    RGB_R_Col2.appendChild(RGB_R_Anchor);
    let RGB_R_Div = document.createElement("DIV");
    RGB_R_Col2.style.width = "100%";
    RGB_R_Anchor.appendChild(RGB_R_Div);
    let RGB_R_Col3 = document.createElement("TD");
    let RGB_R_Input = document.createElement("INPUT");
    RGB_R_Col3.appendChild(RGB_R_Input);
    RGB_R_Row.appendChild(RGB_R_Col1);
    RGB_R_Row.appendChild(RGB_R_Col2);
    RGB_R_Row.appendChild(RGB_R_Col3);
    container.appendChild(RGB_R_Row);
    return new ColorEditorSroll(RGB_R_Div, RGB_R_Anchor, RGB_R_Input, colorCallback, changeCallBack, checkerBoardBg, value);
  }
  setTabIndex(index) {
    this._firstTabIndex = index;
    index = this._tabRGB.setTabIndex(index);
    index = this._tabHSL.setTabIndex(index);
    index = this._tabPredef.setTabIndex(index);
    if (this._tabRGB.active) {
      index = this._rgb_R_editor.setTabIndex(index);
      index = this._rgb_G_editor.setTabIndex(index);
      index = this._rgb_B_editor.setTabIndex(index);
      index = this._rgb_T_editor.setTabIndex(index);
    } else if (this._tabHSL.active) {
      index = this._hsl_H_editor.setTabIndex(index);
      index = this._hsl_S_editor.setTabIndex(index);
      index = this._hsl_L_editor.setTabIndex(index);
      index = this._hsl_T_editor.setTabIndex(index);
    } else {
      for (let i = 0; i < this._prefedDivs.length; i++) {
        this._prefedDivs[i].tabIndex = index++;
      }
    }
    for (let i = 0; i < this._samples.length; i++) {
      index = this._samples[i].setTabIndex(index);
    }
    return index;
  }
};
colorEditor._colorHistory = colorEditor.defaultColorHistory();
colorEditor._editorsList = [];

// obj/full/configForm_rw.js
var configEditorTab = class {
  constructor(editor, label, fontSize, GUIcoef) {
    this._realTab = false;
    this._div = null;
    this._tabLabel = null;
    this._td = document.createElement("TD");
    if (label != "") {
      this._div = document.createElement("DIV");
      this._div.style.display = "none";
      let sz = Math.round(5 * GUIcoef).toString() + "px";
      this._div.style.padding = sz + " " + sz + " " + sz + " " + sz;
      this._td.style.paddingTop = Math.round(4 * GUIcoef).toString() + "px";
      this._td.style.fontSize = fontSize.toString() + "px";
      this._td.style.paddingBottom = Math.round(2 * GUIcoef).toString() + "px";
      this._td.tabIndex = 0;
      this._td.style.borderLeft = "1px solid " + configForm.inactiveBorderColor;
      this._td.style.borderRight = "1px solid " + configForm.inactiveBorderColor;
      this._td.style.borderTop = "1px solid " + configForm.inactiveBorderColor;
      this._td.style.borderBottom = "1px solid " + configForm.activeBorderColor;
      this._td.style.color = configForm.inactiveColor;
      this._td.style.backgroundColor = configForm.inactiveBackgroundColor;
      this._td.style.borderTopLeftRadius = Math.round(3 * GUIcoef).toString() + "px";
      this._td.style.borderTopRightRadius = Math.round(3 * GUIcoef).toString() + "px";
      this._td.style.paddingLeft = "5px";
      this._td.style.paddingRight = "5px";
      this._realTab = true;
      this._tabLabel = document.createElement("ANCHOR");
      this._tabLabel.innerText = label;
      this._tabLabel.addEventListener("click", () => {
        configForm.tabSelected(this);
      });
      this._tabLabel.addEventListener("keyup", (e) => {
        if (e.key === "Enter" || e.key === " ")
          configForm.tabSelected(this);
      });
      this._tabLabel.style.cursor = "pointer";
      this._td.appendChild(this._tabLabel);
    } else {
      this._td.style.borderBottom = "1px solid " + configForm.activeBorderColor;
      this._td.innerHTML = "<span>&nbsp;</span>";
    }
  }
  setTabIndex(index) {
    this._tabLabel.tabIndex = index++;
    return index;
  }
  set active(value) {
    if (!this._realTab)
      return;
    this._td.style.borderLeftColor = value ? configForm.activeBorderColor : configForm.inactiveBorderColor;
    this._td.style.borderTopColor = value ? configForm.activeBorderColor : configForm.inactiveBorderColor;
    this._td.style.borderRightColor = value ? configForm.activeBorderColor : configForm.inactiveBorderColor;
    this._td.style.borderBottomColor = value ? "rgba(0, 0, 0, 0)" : configForm.activeBorderColor;
    this._td.style.color = value ? configForm.activeColor : configForm.inactiveColor;
    this._td.style.backgroundColor = value ? configForm.activeBackgroundColor : configForm.inactiveBackgroundColor;
    this._div.style.display = value ? "" : "none";
  }
  get tabElement() {
    return this._td;
  }
  get divElement() {
    return this._div;
  }
};
var configForm = class {
  static get activeBorderColor() {
    return constants.WindowInnerBorderColor;
  }
  static get inactiveBorderColor() {
    return "#b0b0b0";
  }
  static get activeColor() {
    return "black";
  }
  static get inactiveColor() {
    return "grey";
  }
  static get activeBackgroundColor() {
    return constants.WindowInnerBackgroundColor;
  }
  static get inactiveBackgroundColor() {
    return constants.WindowBackgroundColor;
  }
  static hubStateChanged(source) {
    if (configForm._Hubtable == null)
      return;
    let srvNotification = source.removable ? "" : " (server)";
    for (let i = 1; i < configForm._Hubtable.childElementCount; i++) {
      if (configForm._Hubtable.childNodes[i]["YHUB"] == source) {
        configForm._Hubtable.childNodes[i].childNodes[2].innerText = source.ConnectionDescription + srvNotification;
        switch (source.ConnectionState) {
          case 2:
            configForm._Hubtable.childNodes[i].childNodes[0].innerHTML = ressources.OkIcon((1.2 * configForm.fontSize).toString(), true, false, false, false, " ");
            break;
          case 3:
            configForm._Hubtable.childNodes[i].childNodes[0].innerHTML = ressources.FailedIcon((1.2 * configForm.fontSize).toString(), true, false, false, false, " ");
            break;
          default:
            configForm._Hubtable.childNodes[i].childNodes[0].innerHTML = ressources.DontKnowIcon((1.2 * configForm.fontSize).toString(), true, false, false, false, " ");
            break;
        }
      }
    }
  }
  static RefreshUI(h) {
    for (let i = 1; i < configForm._Hubtable.childElementCount; i++) {
      if (configForm._Hubtable.childNodes[i]["YHUB"] == h) {
        configForm._Hubtable.childNodes[i].childNodes[1].innerText = h.toString();
        configForm._Hubtable.childNodes[i].childNodes[2].innerText = "...";
      }
    }
  }
  static HublineSelected(source) {
    configForm._selectedHub = null;
    for (let i = 1; i < configForm._Hubtable.childElementCount; i++) {
      if (configForm._Hubtable.childNodes[i] == source) {
        configForm._selectedHub = configForm._Hubtable.childNodes[i]["YHUB"];
        configForm._Hubtable.childNodes[i].style.backgroundColor = "#2fa5ff";
        configForm._Hubtable.childNodes[i].childNodes[0].style.color = "white";
        configForm._Hubtable.childNodes[i].childNodes[1].style.color = "white";
        configForm._Hubtable.childNodes[i].childNodes[2].style.color = "white";
      } else {
        configForm._Hubtable.childNodes[i].style.backgroundColor = "white";
        configForm._Hubtable.childNodes[i].childNodes[0].style.color = "black";
        configForm._Hubtable.childNodes[i].childNodes[1].style.color = "black";
        configForm._Hubtable.childNodes[i].childNodes[2].style.color = "black";
      }
    }
    configForm._editButton.enabled = configForm._selectedHub != null;
    configForm._deleteButton.enabled = configForm._selectedHub != null;
    this._editButton.showShortcut(configForm._selectedHub != null);
    this._deleteButton.showShortcut(configForm._selectedHub != null);
  }
  static newHub() {
    HubEdit.newHub(() => {
      configForm._window.show();
    });
  }
  static AddHubToUI(hub) {
    let HubtableTR = document.createElement("TR");
    HubtableTR.style.fontSize = configForm.fontSize.toString() + "px";
    HubtableTR["YHUB"] = hub;
    HubtableTR.style.backgroundColor = "white";
    HubtableTR.style.cursor = "pointer";
    HubtableTR.tabIndex = 0;
    HubtableTR.addEventListener("keypress", (e) => {
      switch (e.key.toUpperCase()) {
        case "D":
          this._deleteButton.performAction();
          break;
        case "E":
          this._editButton.performAction();
          break;
      }
    });
    HubtableTR.style.outline = "none";
    HubtableTR.addEventListener("click", () => {
      configForm.HublineSelected(HubtableTR);
    });
    HubtableTR.addEventListener("focusin", () => {
      configForm.HublineSelected(HubtableTR);
    });
    let HubtableTD = document.createElement("TD");
    switch (hub.ConnectionState) {
      case 2:
        HubtableTD.innerHTML = ressources.OkIcon((1.2 * configForm.fontSize).toString(), true, false, false, false, " ");
        break;
      case 3:
        HubtableTD.innerHTML = ressources.FailedIcon((1.2 * configForm.fontSize).toString(), true, false, false, false, " ");
        break;
      case 1:
      default:
        HubtableTD.innerHTML = ressources.DontKnowIcon((1.2 * configForm.fontSize).toString(), true, false, false, false, " ");
    }
    HubtableTD.style.width = (2 * configForm.fontSize).toString() + "px";
    HubtableTD.style.verticalAlign = "center";
    HubtableTD.style.borderBottom = "1px solid " + configForm.inactiveBorderColor;
    HubtableTD.style.paddingLeft = "5px";
    HubtableTR.appendChild(HubtableTD);
    HubtableTD = document.createElement("TD");
    HubtableTD.innerText = hub.toString();
    HubtableTD.style.borderBottom = "1px solid " + configForm.inactiveBorderColor;
    HubtableTD.style.verticalAlign = "center";
    HubtableTD.style.height = (2 * configForm.fontSize).toString() + "px";
    HubtableTR.appendChild(HubtableTD);
    HubtableTD = document.createElement("TD");
    HubtableTD.style.verticalAlign = "center";
    HubtableTD.innerText = hub.ConnectionDescription + (hub.removable ? "" : " (server)");
    HubtableTD.style.borderBottom = "1px solid " + configForm.inactiveBorderColor;
    HubtableTR.appendChild(HubtableTD);
    configForm._Hubtable.appendChild(HubtableTR);
  }
  static editSelectedHub() {
    if (configForm._selectedHub == null)
      return;
    HubEdit.editHub(configForm._selectedHub, () => {
      configForm._window.show();
    });
  }
  static deleteSelectedHub() {
    if (configForm._selectedHub == null)
      return;
    let ExtraMessage = configForm._selectedHub.removable ? "" : "\n\nThis one is also the one serving the Yocto-Visualization software. If you remove it, you won't be able to save later on.";
    confirm.ask("Do you really want to remove connection " + configForm._selectedHub.toString() + " ?" + ExtraMessage, () => {
      if (configForm._selectedHub == null)
        return;
      configForm._selectedHub.Disconnect().then((r) => {
      });
      for (let i = configForm._Hubtable.childElementCount - 1; i > 0; i--) {
        if (configForm._Hubtable.childNodes[i]["YHUB"] == configForm._selectedHub) {
          configForm._Hubtable.removeChild(configForm._Hubtable.childNodes[i]);
        }
      }
      sensorsManager.hubWasremoved(configForm._selectedHub);
      configForm._selectedHub = null;
      configForm._editButton.enabled = false;
      configForm._deleteButton.enabled = false;
      constants.edited = true;
    }, null, null);
  }
  static hide() {
    if (configForm._window == null)
      return;
    configForm._window.visible = false;
  }
  static show() {
    if (configForm._window == null) {
      configForm.GUIcoef = constants.generalSizeCoef;
      if (configForm.REFWIDH * configForm.GUIcoef > screen.width)
        configForm.GUIcoef = screen.width / configForm.REFWIDH;
      if (configForm.REFHEIGHT * configForm.GUIcoef > screen.height)
        configForm.GUIcoef = screen.height / configForm.REFHEIGHT;
      configForm.fontSize *= configForm.GUIcoef / constants.generalSizeCoef;
      let params = new newWindowParam(configForm.GUIcoef);
      params.positionType = 1;
      params.width = Math.round(configForm.REFWIDH * this.GUIcoef);
      params.height = Math.round(configForm.REFHEIGHT * this.GUIcoef);
      params.showContainerBorders = false;
      params.title = "Global configuration";
      configForm._window = new YWindow(params);
      configForm._contents = configForm._window.innerContentDiv;
      configForm._table = document.createElement("TABLE");
      configForm._contents.appendChild(configForm._table);
      configForm._table.style.position = "absolute";
      configForm._table.style.left = "0px";
      configForm._table.style.right = "0px";
      configForm._table.style.width = "100%";
      configForm._table.style.height = "100%";
      configForm._table.style.borderSpacing = "0";
      configForm._table.style.paddingLeft = (5 * this.GUIcoef).toString() + "px";
      configForm._table.style.paddingTop = (5 * this.GUIcoef).toString() + "px";
      configForm._table.style.paddingRight = (5 * this.GUIcoef).toString() + "px";
      configForm._table.style.borderCollapse = "separate";
      configForm._tr1 = document.createElement("TR");
      configForm._tr2 = document.createElement("TR");
      configForm._tr1.style.height = (2 * configForm.fontSize).toString() + "px";
      configForm._tabNetwork = new configEditorTab(configForm, "Network", configForm.fontSize, configForm.GUIcoef);
      configForm._tabCapture = new configEditorTab(configForm, "Screen capture", configForm.fontSize, configForm.GUIcoef);
      configForm._tabResources = new configEditorTab(configForm, "Ressources", configForm.fontSize, configForm.GUIcoef);
      configForm._tabUI = new configEditorTab(configForm, "User interface", configForm.fontSize, configForm.GUIcoef);
      configForm._tabExport = new configEditorTab(configForm, "Updates & XML", configForm.fontSize, configForm.GUIcoef);
      configForm._tabStub = new configEditorTab(configForm, "", configForm.fontSize, configForm.GUIcoef);
      this._tabPanelContents = document.createElement("TD");
      this._tabPanelContents.colSpan = 6;
      this._tabPanelContents.style.borderLeft = "1px solid " + this.activeBorderColor;
      this._tabPanelContents.style.borderRight = "1px solid " + this.activeBorderColor;
      this._tabPanelContents.style.borderBottom = "1px solid " + this.activeBorderColor;
      this._tabPanelContents.style.backgroundColor = this.activeBackgroundColor;
      configForm._tr1.appendChild(this._tabNetwork.tabElement);
      configForm._tr1.appendChild(this._tabCapture.tabElement);
      configForm._tr1.appendChild(this._tabResources.tabElement);
      configForm._tr1.appendChild(this._tabUI.tabElement);
      configForm._tr1.appendChild(this._tabExport.tabElement);
      configForm._tr1.appendChild(this._tabStub.tabElement);
      configForm._tr2.appendChild(this._tabPanelContents);
      configForm._tr2.childNodes[0].style.verticalAlign = "top";
      configForm._table.appendChild(this._tr1);
      configForm._table.appendChild(this._tr2);
      let p = document.createElement("P");
      p.style.textAlign = "justify";
      p.style.fontSize = configForm.fontSize.toString() + "px";
      p.style.paddingTop = "0px";
      p.style.marginTop = Math.round(3 * this.GUIcoef).toString() + "px";
      p.innerText = "Enter the list of VirtualHub or YoctoHub this page can connect to";
      this._tabNetwork.divElement.appendChild(p);
      configForm._Hubtable = document.createElement("TABLE");
      configForm._Hubtable.style.position = "absolute";
      configForm._Hubtable.style.display = "block";
      configForm._Hubtable.style.left = Math.round(20 * this.GUIcoef).toString() + "px";
      configForm._Hubtable.style.right = Math.round(20 * this.GUIcoef).toString() + "px";
      configForm._Hubtable.style.tableLayout = "auto";
      configForm._Hubtable.style.top = Math.round(80 * this.GUIcoef).toString() + "px";
      configForm._Hubtable.style.bottom = Math.round(40 * this.GUIcoef).toString() + "px";
      configForm._Hubtable.style.borderCollapse = "colapse";
      configForm._Hubtable.style.borderSpacing = "0px";
      configForm._Hubtable.style.border = "1px solid " + configForm.activeBorderColor;
      let HubtableTR = document.createElement("TR");
      HubtableTR.style.fontSize = configForm.fontSize.toString() + "px";
      let HubtableTH = document.createElement("TH");
      HubtableTH.colSpan = 2;
      HubtableTH.innerText = "Address";
      HubtableTH.style.borderBottom = "1px solid " + configForm.activeBorderColor;
      HubtableTH.style.width = Math.round(400 * this.GUIcoef).toString() + "px";
      HubtableTR.appendChild(HubtableTH);
      HubtableTH = document.createElement("TH");
      HubtableTH.innerText = "Status";
      HubtableTH.style.width = "40%";
      HubtableTH.style.borderBottom = "1px solid " + configForm.activeBorderColor;
      HubtableTH.style.borderLeft = "1px solid " + configForm.activeBorderColor;
      HubtableTR.appendChild(HubtableTH);
      configForm._Hubtable.appendChild(HubtableTR);
      let hubList = sensorsManager.hubList;
      for (let i = 0; i < hubList.length; i++) {
        configForm.AddHubToUI(hubList[i]);
      }
      let div = document.createElement("DIV");
      div.style.position = "absolute";
      div.style.bottom = "0px";
      div.style.right = Math.round(20 * configForm.GUIcoef).toString() + "px";
      div.style.height = Math.round(30 * configForm.GUIcoef).toString() + "px";
      div.style.textAlign = "right";
      div.style.verticalAlign = "center";
      configForm._newButton = new button("New", () => {
        configForm._window.hide();
        configForm.newHub();
      }, configForm.GUIcoef);
      div.appendChild(configForm._newButton.Element);
      configForm._editButton = new button("Edit", () => {
        configForm._window.hide();
        configForm.editSelectedHub();
      }, configForm.GUIcoef);
      configForm._editButton.enabled = false;
      div.appendChild(configForm._editButton.Element);
      configForm._deleteButton = new button("Delete", () => {
        configForm.deleteSelectedHub();
      }, configForm.GUIcoef);
      configForm._deleteButton.enabled = false;
      div.appendChild(configForm._deleteButton.Element);
      this._tabNetwork.divElement.appendChild(div);
      this._tabNetwork.divElement.appendChild(configForm._Hubtable);
      p = document.createElement("P");
      p.innerHTML = "Widgets content can be captured at anytime thought the <i>Snapshop</i> option available in right-click contextual menu";
      p.style.textAlign = "justify";
      p.style.fontSize = configForm.fontSize.toString() + "px";
      this._tabCapture.divElement.appendChild(p);
      let tableSize = document.createElement("TABLE");
      tableSize.style.fontSize = configForm.fontSize.toString() + "px";
      let row = document.createElement("TR");
      let td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      td.innerText = "ImageType";
      row.appendChild(td);
      td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      td.style.verticalAlign = "center";
      configForm.inputPNG = document.createElement("INPUT");
      configForm.inputSVG = document.createElement("INPUT");
      configForm.inputPNG.checked = constants.captureType == YDataRenderer.CaptureType.PNG;
      configForm.inputPNG.style.display = "inline";
      configForm.inputPNG.type = "checkbox";
      configForm.inputPNG.style.transform = "scale(" + this.GUIcoef.toString() + ")";
      configForm.inputPNG.style.marginRight = Math.round(5 * this.GUIcoef).toString() + "px";
      configForm.inputPNG.style.marginLeft = Math.round(5 * this.GUIcoef).toString() + "px";
      configForm.inputPNG.addEventListener("change", () => {
        configForm.captureFormatChange(configForm.inputPNG);
      });
      td.append(configForm.inputPNG);
      let span;
      span = document.createElement("SPAN");
      span.innerText = YDataRenderer.CaptureType.PNG.description;
      td.append(span);
      configForm.inputSVG = document.createElement("INPUT");
      configForm.inputSVG.checked = constants.captureType == YDataRenderer.CaptureType.SVG;
      configForm.inputSVG.style.display = "inline";
      configForm.inputSVG.type = "checkbox";
      configForm.inputSVG.style.transform = "scale(" + this.GUIcoef.toString() + ")";
      configForm.inputSVG.style.marginRight = Math.round(5 * this.GUIcoef).toString() + "px";
      configForm.inputSVG.style.marginLeft = Math.round(5 * this.GUIcoef).toString() + "px";
      configForm.inputSVG.addEventListener("change", () => {
        configForm.captureFormatChange(configForm.inputSVG);
      });
      td.append(configForm.inputSVG);
      span = document.createElement("SPAN");
      span.innerText = YDataRenderer.CaptureType.SVG.description;
      td.append(span);
      row.appendChild(td);
      tableSize.appendChild(row);
      row = document.createElement("TR");
      td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      td.innerText = "Resolution:";
      row.appendChild(td);
      td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      configForm.inputResolution = document.createElement("INPUT");
      configForm.inputResolution.style.fontFamily = constants.generalFontFamily;
      configForm.inputResolution.style.fontSize = constants.generalFontSize.toString() + "px";
      configForm.inputResolution.style.border = "1px solid grey";
      configForm.inputResolution.type = "number";
      configForm.inputResolution.style.textAlign = "right";
      configForm.inputResolution.style.marginRight = "5px";
      configForm.inputResolution.style.width = "60px";
      configForm.inputResolution.value = constants.captureDPI.toString();
      configForm.inputResolution.style.display = "inline";
      new InputFieldManager(configForm.inputResolution, 6, false, Number.NaN, Number.NaN, (sender, refreshInput) => {
        configForm.captureDPIChange(configForm.inputResolution);
      });
      td.append(configForm.inputResolution);
      span = document.createElement("SPAN");
      span.innerText = "DPI";
      td.append(span);
      row.appendChild(td);
      tableSize.appendChild(row);
      row = document.createElement("TR");
      td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      td.innerText = "Size:";
      td.style.verticalAlign = "top";
      row.appendChild(td);
      td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      configForm.inputSizeSelect = document.createElement("SELECT");
      configForm.inputSizeSelect.style.border = "1px solid grey";
      configForm.inputSizeSelect.style.fontFamily = constants.generalFontFamily;
      configForm.inputSizeSelect.style.fontSize = constants.generalFontSize.toString() + "px";
      let sizingOptions = YDataRenderer.CaptureFormats.Keep.sibblings;
      for (let i = 0; i < sizingOptions.length; i++) {
        let option = document.createElement("OPTION");
        option.text = sizingOptions[i].description;
        option.value = sizingOptions[i].toString;
        configForm.inputSizeSelect.add(option, null);
      }
      configForm.inputSizeSelect.value = constants.captureSizePolicy.toString;
      configForm.inputSizeSelect.addEventListener("change", () => {
        configForm.captureSizeSelectChange(configForm.inputSizeSelect);
      });
      td.append(configForm.inputSizeSelect);
      row.appendChild(td);
      tableSize.appendChild(row);
      let subtable = document.createElement("TABLE");
      configForm.captureWidthTR = document.createElement("TR");
      let subTD = document.createElement("TD");
      subTD.style.fontSize = configForm.fontSize.toString() + "px";
      subTD.innerText = "Width:";
      configForm.captureWidthTR.appendChild(subTD);
      subTD = document.createElement("TD");
      subTD.style.fontSize = configForm.fontSize.toString() + "px";
      configForm.inputCaptureWidth = document.createElement("INPUT");
      configForm.inputCaptureWidth.style.border = "1px solid grey";
      configForm.inputCaptureWidth.style.fontFamily = constants.generalFontFamily;
      configForm.inputCaptureWidth.style.fontSize = constants.generalFontSize.toString() + "px";
      configForm.inputCaptureWidth.type = "number";
      configForm.inputCaptureWidth.style.textAlign = "right";
      configForm.inputCaptureWidth.style.marginRight = "5px";
      configForm.inputCaptureWidth.style.width = "60px";
      configForm.inputCaptureWidth.value = constants.captureWidth.toString();
      configForm.inputCaptureWidth.style.display = "inline";
      new InputFieldManager(configForm.inputCaptureWidth, 3, false, Number.NaN, Number.NaN, (sender, refreshInput) => {
        configForm.captureWidthChange(configForm.inputCaptureWidth);
      });
      subTD.append(configForm.inputCaptureWidth);
      configForm.inputCaptureWidthInfo = document.createElement("SPAN");
      configForm.inputCaptureWidthInfo.innerText = "pixels";
      subTD.append(configForm.inputCaptureWidthInfo);
      configForm.captureWidthTR.appendChild(subTD);
      subtable.appendChild(configForm.captureWidthTR);
      configForm.captureHeightTR = document.createElement("TR");
      subTD = document.createElement("TD");
      subTD.style.fontSize = configForm.fontSize.toString() + "px";
      subTD.innerText = "Height:";
      configForm.captureHeightTR.appendChild(subTD);
      subTD = document.createElement("TD");
      subTD.style.fontSize = configForm.fontSize.toString() + "px";
      configForm.inputCaptureHeight = document.createElement("INPUT");
      configForm.inputCaptureHeight.style.border = "1px solid grey";
      configForm.inputCaptureHeight.style.fontFamily = constants.generalFontFamily;
      configForm.inputCaptureHeight.style.fontSize = constants.generalFontSize.toString() + "px";
      configForm.inputCaptureHeight.type = "number";
      configForm.inputCaptureHeight.style.textAlign = "right";
      configForm.inputCaptureHeight.style.marginRight = "5px";
      configForm.inputCaptureHeight.style.width = "60px";
      configForm.inputCaptureHeight.value = constants.captureHeight.toString();
      configForm.inputCaptureHeight.style.display = "inline";
      new InputFieldManager(configForm.inputCaptureHeight, 3, false, Number.NaN, Number.NaN, (sender, refreshInput) => {
        configForm.captureHeightChange(configForm.inputCaptureHeight);
      });
      subTD.append(configForm.inputCaptureHeight);
      configForm.inputCaptureHeightInfo = document.createElement("SPAN");
      configForm.inputCaptureHeightInfo.innerText = "pixels";
      subTD.append(configForm.inputCaptureHeightInfo);
      configForm.captureHeightTR.appendChild(subTD);
      subtable.appendChild(configForm.captureHeightTR);
      td.appendChild(subtable);
      configForm._tabCapture.divElement.appendChild(tableSize);
      let tableRessources = document.createElement("TABLE");
      row = document.createElement("TR");
      td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      td.innerText = "If you plan to use YoctoVisualization continuously for an extended period of time (i.e. several weeks),  or if you are running it on a computer with limited resources, you may want to limit the application memory consumption.";
      td.colSpan = 2;
      td.style.textAlign = "justify";
      row.appendChild(td);
      tableRessources.appendChild(row);
      row = document.createElement("TR");
      td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      td.innerText = "Max count of sensors data records:";
      row.appendChild(td);
      td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      let maxSensorRecs = document.createElement("INPUT");
      maxSensorRecs.style.border = "1px solid grey";
      maxSensorRecs.style.fontFamily = constants.generalFontFamily;
      maxSensorRecs.style.fontSize = constants.generalFontSize.toString() + "px";
      maxSensorRecs.type = "number";
      maxSensorRecs.style.textAlign = "right";
      maxSensorRecs.style.marginRight = "5px";
      maxSensorRecs.style.marginLeft = "5px";
      maxSensorRecs.style.width = "60px";
      maxSensorRecs.value = constants.maxDataRecordsPerSensor.toString();
      maxSensorRecs.style.display = "inline";
      new InputFieldManager(maxSensorRecs, 2, false, Number.NaN, Number.NaN, (sender, refreshInput) => {
        configForm.maxSensorRecsChange(maxSensorRecs);
      });
      td.append(maxSensorRecs);
      span = document.createElement("SPAN");
      span.innerText = "(0 = unlimited)";
      td.append(span);
      row.appendChild(td);
      tableRessources.appendChild(row);
      row = document.createElement("TR");
      td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      td.innerText = "Max count of graph series data points:";
      row.appendChild(td);
      td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      let maxSeriesRecs = document.createElement("INPUT");
      maxSeriesRecs.style.border = "1px solid grey";
      maxSeriesRecs.style.fontFamily = constants.generalFontFamily;
      maxSeriesRecs.style.fontSize = constants.generalFontSize.toString() + "px";
      maxSeriesRecs.type = "number";
      maxSeriesRecs.style.textAlign = "right";
      maxSeriesRecs.style.marginRight = "5px";
      maxSeriesRecs.style.marginLeft = "5px";
      maxSeriesRecs.style.width = "60px";
      maxSeriesRecs.value = constants.maxPointsPerGraphSerie.toString();
      maxSeriesRecs.style.display = "inline";
      new InputFieldManager(maxSeriesRecs, 2, false, Number.NaN, Number.NaN, (sender, refreshInput) => {
        configForm.maxSeriesRecsChange(maxSeriesRecs);
      });
      td.append(maxSeriesRecs);
      span = document.createElement("SPAN");
      span.innerText = "(0 = unlimited)";
      td.append(span);
      row.appendChild(td);
      tableRessources.appendChild(row);
      row = document.createElement("TR");
      td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      td.innerText = "\nYocto-Visualization automatically loads datalogger contents for all connected devices.  If you are using networked devices featuring  billable data transfers (GSM) you may want to limit or even disable that feature.";
      td.colSpan = 2;
      td.style.textAlign = "justify";
      row.appendChild(td);
      tableRessources.appendChild(row);
      row = document.createElement("TR");
      td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      td.innerText = "Max data points/series loaded from dataloggers:";
      row.appendChild(td);
      td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      let maxDataLogRecs = document.createElement("INPUT");
      maxDataLogRecs.style.border = "1px solid grey";
      maxDataLogRecs.style.fontFamily = constants.generalFontFamily;
      maxDataLogRecs.style.fontSize = constants.generalFontSize.toString() + "px";
      maxDataLogRecs.type = "number";
      maxDataLogRecs.style.textAlign = "right";
      maxDataLogRecs.style.marginRight = "5px";
      maxDataLogRecs.style.marginLeft = "5px";
      maxDataLogRecs.style.width = "60px";
      maxDataLogRecs.value = constants.maxPointsPerDataloggerSerie.toString();
      maxDataLogRecs.style.display = "inline";
      new InputFieldManager(maxDataLogRecs, 1, false, -1, Number.NaN, (sender, refreshInput) => {
        configForm.maxDataLogRecsChange(maxDataLogRecs);
      });
      td.append(maxDataLogRecs);
      span = document.createElement("SPAN");
      span.innerText = "(0 = unlimited,\n-1 = disabled)";
      td.append(span);
      row.appendChild(td);
      tableRessources.appendChild(row);
      row = document.createElement("TR");
      td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      td.innerText = "After a  limit increase, you'll have to restart the application to get your old data back.";
      td.colSpan = 2;
      td.style.textAlign = "justify";
      row.appendChild(td);
      tableRessources.appendChild(row);
      configForm._tabResources.divElement.appendChild(tableRessources);
      p = document.createElement("P");
      p.style.fontSize = configForm.fontSize.toString() + "px";
      p.innerText = "You can alter user interface behavior according to your hardware capabilities.";
      this._tabUI.divElement.appendChild(p);
      let checkbox1 = document.createElement("INPUT");
      checkbox1.style.fontFamily = constants.generalFontFamily;
      checkbox1.style.fontSize = constants.generalFontSize.toString() + "px";
      checkbox1.style.display = "inline";
      checkbox1.type = "checkbox";
      checkbox1.style.transform = "scale(" + this.GUIcoef.toString() + ")";
      checkbox1.style.marginRight = Math.round(5 * this.GUIcoef).toString() + "px";
      checkbox1.checked = constants.dbleClickBringsUpContextMenu;
      checkbox1.addEventListener("change", () => {
        configForm.dbleClickBringsUpContextMenuChange(checkbox1);
      });
      this._tabUI.divElement.appendChild(checkbox1);
      span = document.createElement("SPAN");
      span.style.fontSize = configForm.fontSize.toString() + "px";
      span.innerText = "Double click/tap  brings up context menu\n";
      this._tabUI.divElement.appendChild(span);
      let checkbox2 = document.createElement("INPUT");
      checkbox2.style.display = "inline";
      checkbox2.type = "checkbox";
      checkbox2.style.transform = "scale(" + this.GUIcoef.toString() + ")";
      checkbox2.style.marginRight = Math.round(5 * this.GUIcoef).toString() + "px";
      checkbox2.checked = YGraph.verticalDragZoomEnabled;
      checkbox2.addEventListener("change", () => {
        configForm.verticalDragZoomChange(checkbox2);
      });
      this._tabUI.divElement.appendChild(checkbox2);
      span = document.createElement("SPAN");
      span.style.fontSize = configForm.fontSize.toString() + "px";
      span.innerText = "Graphs zoom can be driven by vertical drag\n";
      this._tabUI.divElement.appendChild(span);
      p = document.createElement("P");
      p.style.fontSize = configForm.fontSize.toString() + "px";
      p.innerText = "Yocto-Visualization tries to ajust UI size to screen resolution the best it can through a DPI based zoom factor. Unfortunately not all devices can properly report their screen resolution. That's why you can manually override that factor.";
      this._tabUI.divElement.appendChild(p);
      let DPIoverride = document.createElement("INPUT");
      let checkbox3 = document.createElement("INPUT");
      checkbox3.style.display = "inline";
      checkbox3.type = "checkbox";
      checkbox3.style.transform = "scale(" + this.GUIcoef.toString() + ")";
      checkbox3.style.marginRight = Math.round(5 * this.GUIcoef).toString() + "px";
      checkbox3.checked = constants.guiDPIFactorIsOverriden;
      checkbox3.addEventListener("change", () => {
        configForm.DPIoverrideChange(checkbox3, DPIoverride);
      });
      this._tabUI.divElement.appendChild(checkbox3);
      span = document.createElement("SPAN");
      span.style.fontSize = configForm.fontSize.toString() + "px";
      span.innerText = "Override zoom factor to ";
      this._tabUI.divElement.appendChild(span);
      DPIoverride.style.border = "1px solid grey";
      DPIoverride.style.fontFamily = constants.generalFontFamily;
      DPIoverride.style.fontSize = constants.generalFontSize.toString() + "px";
      DPIoverride.disabled = !constants.guiDPIFactorIsOverriden;
      DPIoverride.type = "number";
      DPIoverride.style.textAlign = "right";
      DPIoverride.style.marginRight = "5px";
      DPIoverride.style.marginLeft = "5px";
      DPIoverride.style.width = "60px";
      DPIoverride.value = constants.guiDPIFactorOverrideValue.toString();
      DPIoverride.style.display = "inline";
      new InputFieldManager(DPIoverride, 5, false, Number.NaN, Number.NaN, (sender, refreshInput) => {
        configForm.DPIoverrideChange(checkbox3, DPIoverride);
      });
      this._tabUI.divElement.appendChild(DPIoverride);
      p = document.createElement("P");
      p.style.fontSize = configForm.fontSize.toString() + "px";
      p.innerText = "This setting is stored in your browser cookies. So it is specific to this device, browser and server.You will have to reload this page for this setting to take effect";
      this._tabUI.divElement.appendChild(p);
      p = document.createElement("P");
      p.style.fontSize = configForm.fontSize.toString() + "px";
      p.style.textAlign = "justify";
      p.innerText = "As long as your web browser can reach www.yoctopuce.com, the read/write edition of Yocto-Visualization (for web) can automatically check for new version. If you find this feature anoying, feel free to disable it. ";
      this._tabExport.divElement.appendChild(p);
      let checkbox4 = document.createElement("INPUT");
      checkbox4.style.display = "inline";
      checkbox4.type = "checkbox";
      checkbox4.style.transform = "scale(" + this.GUIcoef.toString() + ")";
      checkbox4.style.marginLeft = Math.round(25 * this.GUIcoef).toString() + "px";
      checkbox4.checked = constants.mustCheckForUpdate;
      checkbox4.addEventListener("change", () => {
        configForm.mustCheckForUpdateChange(checkbox4);
      });
      this._tabExport.divElement.appendChild(checkbox4);
      span = document.createElement("SPAN");
      span.style.fontSize = configForm.fontSize.toString() + "px";
      span.innerText = "Automatically check for updates";
      let a2 = document.createElement("A");
      a2.innerText = "Check now";
      a2.style.paddingLeft = "25px";
      a2.style.cursor = "pointer";
      a2.style.color = "#0000EE";
      a2.style.textDecoration = "underline";
      a2.addEventListener("click", () => {
        YWebPage.CheckForNewVersion(true);
      });
      span.appendChild(a2);
      this._tabExport.divElement.appendChild(span);
      p = document.createElement("P");
      p.style.fontSize = configForm.fontSize.toString() + "px";
      p.style.textAlign = "justify";
      p.innerText = "Yocto-Visualization (for web) stores its configuration in a XML file. This file can be used to create a static web page running Yocto-Visualization (for web) or it can be used in the Yocto-Visualization (for web) installer to create a pre-configured install. Also, it is mostly compatible with the native version of Yocto-Visualization: you can use it instead of the original config.xml file. Just click on the link below to export/download your current configuration.";
      this._tabExport.divElement.appendChild(p);
      p = document.createElement("P");
      p.style.fontSize = configForm.fontSize.toString() + "px";
      p.style.textAlign = "right";
      let a = document.createElement("A");
      a.innerText = "Export current configuration";
      a.style.cursor = "pointer";
      a.style.color = "#0000EE";
      a.style.textDecoration = "underline";
      a.addEventListener("click", () => {
        configForm.downloadCurrentConfig();
      });
      p.appendChild(a);
      this._tabExport.divElement.appendChild(p);
      configForm._tabPanelContents.appendChild(this._tabNetwork.divElement);
      configForm._tabPanelContents.appendChild(this._tabCapture.divElement);
      configForm._tabPanelContents.appendChild(this._tabResources.divElement);
      configForm._tabPanelContents.appendChild(this._tabUI.divElement);
      configForm._tabPanelContents.appendChild(this._tabExport.divElement);
      configForm.tabSelected(this._tabNetwork);
      configForm.refreshSizeParams();
    }
    configForm._window.show();
  }
  static DPIoverrideChange(checkbox, input) {
    let value = parseFloat(input.value);
    input.disabled = !checkbox.checked;
    if (checkbox.checked && value > 0) {
      constants.overrideGuiDPIFactor(true, value);
    } else {
      constants.overrideGuiDPIFactor(false);
    }
  }
  static hubWasAdded(hub) {
    if (sensorsManager.newHubCreated(hub)) {
      configForm.AddHubToUI(hub);
      constants.edited = true;
      hub.Connect().then((r) => {
      });
    }
  }
  static hubGotEdited(hub) {
    configForm.RefreshUI(hub);
    constants.edited = true;
    hub.Disconnect().then((r) => {
    });
    hub.Connect().then((r) => {
    });
  }
  static dbleClickBringsUpContextMenuChange(source) {
    let prev = constants.dbleClickBringsUpContextMenu;
    constants.dbleClickBringsUpContextMenu = source.checked;
    if (prev != constants.dbleClickBringsUpContextMenu)
      constants.edited = true;
  }
  static verticalDragZoomChange(source) {
    let prev = YGraph.verticalDragZoomEnabled;
    YGraph.verticalDragZoomEnabled = source.checked;
    if (prev != YGraph.verticalDragZoomEnabled)
      constants.edited = true;
  }
  static mustCheckForUpdateChange(source) {
    let prev = constants.mustCheckForUpdate;
    constants.mustCheckForUpdate = source.checked;
    if (prev != constants.mustCheckForUpdate)
      constants.edited = true;
  }
  static maxDataLogRecsChange(source) {
    let value = parseInt(source.value);
    if (value != constants.maxPointsPerDataloggerSerie || value != CustomYSensor.MaxLoggerRecords) {
      constants.maxPointsPerDataloggerSerie = value;
      CustomYSensor.MaxLoggerRecords = value;
      constants.edited = true;
    }
  }
  static maxSeriesRecsChange(source) {
    let value = parseInt(source.value);
    if (value != constants.maxPointsPerGraphSerie || value != DataSerie.MaxPointsPerSeries) {
      constants.maxPointsPerGraphSerie = value;
      DataSerie.MaxPointsPerSeries = value;
      constants.edited = true;
    }
  }
  static maxSensorRecsChange(source) {
    let value = parseInt(source.value);
    if (value != constants.maxDataRecordsPerSensor || value != CustomYSensor.MaxDataRecords) {
      constants.maxDataRecordsPerSensor = value;
      CustomYSensor.MaxDataRecords = value;
      constants.edited = true;
    }
  }
  static captureDPIChange(source) {
    let prev = constants.captureDPI;
    constants.captureDPI = parseInt(source.value);
    if (constants.captureDPI != prev)
      constants.edited = true;
    configForm.refreshSizeParams();
  }
  static captureWidthChange(source) {
    let prev = constants.captureWidth;
    constants.captureWidth = parseInt(source.value);
    if (constants.captureWidth != prev)
      constants.edited = true;
    configForm.refreshSizeParams();
  }
  static captureHeightChange(source) {
    let prev = constants.captureHeight;
    constants.captureHeight = parseInt(source.value);
    if (constants.captureHeight != prev)
      constants.edited = true;
    configForm.refreshSizeParams();
  }
  static captureSizeSelectChange(source) {
    let prev = constants.captureSizePolicy;
    constants.captureSizePolicy = YDataRenderer.CaptureFormats.fromString(YDataRenderer.CaptureFormats, source.value);
    if (constants.captureSizePolicy != prev)
      constants.edited = true;
    configForm.refreshSizeParams();
  }
  static refreshSizeParams() {
    let value = YDataRenderer.CaptureFormats.fromString(YDataRenderer.CaptureFormats, configForm.inputSizeSelect.value);
    if (value == YDataRenderer.CaptureFormats.Keep) {
      configForm.captureWidthTR.style.display = "none";
      configForm.captureHeightTR.style.display = "none";
    } else if (value == YDataRenderer.CaptureFormats.FixedWidth) {
      configForm.captureWidthTR.style.display = "";
      configForm.captureHeightTR.style.display = "none";
    } else if (value == YDataRenderer.CaptureFormats.FixedHeight) {
      configForm.captureWidthTR.style.display = "none";
      configForm.captureHeightTR.style.display = "";
    }
    if (value == YDataRenderer.CaptureFormats.Fixed) {
      configForm.captureWidthTR.style.display = "";
      configForm.captureHeightTR.style.display = "";
    }
    let sw = 25.4 * parseInt(configForm.inputCaptureWidth.value) / parseInt(configForm.inputResolution.value);
    configForm.inputCaptureWidthInfo.innerText = "Pixels  (" + sw.toFixed(1) + "mm)";
    let sh = 25.4 * parseInt(configForm.inputCaptureHeight.value) / parseInt(configForm.inputResolution.value);
    configForm.inputCaptureHeightInfo.innerText = "Pixels  (" + sh.toFixed(1) + "mm)";
  }
  static downloadCurrentConfig() {
    let element = document.createElement("a");
    let data = "data:text/xml;base64," + btoa(YWebPage.get_XmlData());
    element.setAttribute("href", data);
    element.setAttribute("download", "config.xml");
    element.style.display = "none";
    document.body.appendChild(element);
    element.click();
    document.body.removeChild(element);
  }
  static captureFormatChange(source) {
    if (source == configForm.inputPNG)
      configForm.inputSVG.checked = !source.checked;
    if (source == configForm.inputSVG)
      configForm.inputPNG.checked = !source.checked;
    let prev = constants.captureType;
    constants.captureType = configForm.inputPNG.checked ? YDataRenderer.CaptureType.PNG : YDataRenderer.CaptureType.SVG;
    if (constants.captureType != prev)
      constants.edited = true;
  }
  static tabSelected(source) {
    this._tabNetwork.active = source == this._tabNetwork;
    this._tabCapture.active = source == this._tabCapture;
    this._tabResources.active = source == this._tabResources;
    this._tabUI.active = source == this._tabUI;
    this._tabExport.active = source == this._tabExport;
  }
};
configForm.GUIcoef = 1;
configForm.REFWIDH = 520;
configForm.REFHEIGHT = 300;
configForm.fontSize = constants.generalFontSize;

// obj/full/HubEdit_rw.js
var HubEdit = class {
  static get activeBorderColor() {
    return constants.WindowInnerBorderColor;
  }
  static get inactiveBorderColor() {
    return "#b0b0b0";
  }
  static get activeColor() {
    return "black";
  }
  static get inactiveColor() {
    return "grey";
  }
  static get activeBackgroundColor() {
    return constants.WindowInnerBackgroundColor;
  }
  static get inactiveBackgroundColor() {
    return constants.WindowBackgroundColor;
  }
  static newHub(whenDone) {
    HubEdit._currenthub = new Hub(2, "ws", "", "", true, "", "", "");
    HubEdit.show(HubEdit._currenthub);
    HubEdit._window.title = "New Connection";
    HubEdit._thisIsEditing = false;
    HubEdit._whenDone = whenDone;
  }
  static editHub(hub, whenDone) {
    HubEdit._currenthub = hub;
    HubEdit.show(HubEdit._currenthub);
    HubEdit._window.title = "Edit Connection";
    HubEdit._thisIsEditing = true;
    HubEdit._whenDone = whenDone;
  }
  static show(hub) {
    if (HubEdit._window == null) {
      HubEdit._okButton = new button("Ok", () => {
        HubEdit.okClicked();
      });
      HubEdit._cancelButton = new button("Cancel", () => {
        HubEdit.hide();
      });
      let params = new newWindowParam();
      params.positionType = 1;
      params.width = Math.round(450 * constants.generalSizeCoef);
      params.height = Math.round(280 * constants.generalSizeCoef);
      params.isModal = true;
      params.closeIcon = false;
      params.title = "...";
      params.buttons.push(HubEdit._okButton);
      params.buttons.push(HubEdit._cancelButton);
      HubEdit._window = new YWindow(params);
      HubEdit._contents = HubEdit._window.innerContentDiv;
      let p = document.createElement("P");
      p.style.paddingTop = "0px";
      p.style.marginTop = Math.round(3 * constants.generalSizeCoef).toString() + "px";
      p.style.lineHeight = Math.round(12 * constants.generalSizeCoef).toString() + "px";
      p.innerText = "Enter the hub connection parameter, The only mandatory parameter is the address, just leave the other fields empty if you want to use default values";
      p.style.textAlign = "justify";
      HubEdit._contents.appendChild(p);
      p.appendChild(document.createElement("BR"));
      p.appendChild(document.createElement("BR"));
      let span = document.createElement("SPAN");
      span.innerText = "Protocol:";
      span.style.marginLeft = "20px";
      p.appendChild(span);
      HubEdit._protocolSelect = document.createElement("SELECT");
      HubEdit._protocolSelect.style.border = "1px solid grey";
      HubEdit._protocolSelect.style.fontFamily = constants.generalFontFamily;
      HubEdit._protocolSelect.style.fontSize = constants.generalFontSize.toString() + "px";
      let httpOption = document.createElement("OPTION");
      httpOption.text = "http";
      httpOption.value = "http";
      HubEdit._protocolSelect.appendChild(httpOption);
      let httpsOption = document.createElement("OPTION");
      httpsOption.text = "https";
      httpsOption.value = "https";
      HubEdit._protocolSelect.appendChild(httpsOption);
      let wsOption = document.createElement("OPTION");
      wsOption.text = "ws";
      wsOption.value = "ws";
      HubEdit._protocolSelect.appendChild(wsOption);
      let wssOption = document.createElement("OPTION");
      wssOption.text = "wss";
      wssOption.value = "wss";
      HubEdit._protocolSelect.appendChild(wssOption);
      p.appendChild(HubEdit._protocolSelect);
      span = document.createElement("SPAN");
      span.style.marginLeft = "20px";
      span.innerText = "Address:";
      p.appendChild(span);
      HubEdit._addressInput = document.createElement("INPUT");
      HubEdit._addressInput.style.border = "1px solid grey";
      HubEdit._addressInput.style.fontFamily = constants.generalFontFamily;
      HubEdit._addressInput.style.fontSize = constants.generalFontSize.toString() + "px";
      HubEdit._addressInput.maxLength = 512;
      HubEdit._addressInput.size = 15;
      HubEdit._addressInput.value = hub.addr;
      new InputFieldManager(HubEdit._addressInput, 0, false, Number.NaN, Number.NaN, null);
      p.appendChild(HubEdit._addressInput);
      span = document.createElement("SPAN");
      span.style.marginLeft = Math.round(20 * constants.generalSizeCoef).toString() + "px";
      span.innerText = "Port:";
      p.appendChild(span);
      HubEdit._portInput = document.createElement("INPUT");
      HubEdit._portInput.style.border = "1px solid grey";
      HubEdit._portInput.style.fontFamily = constants.generalFontFamily;
      HubEdit._portInput.style.fontSize = constants.generalFontSize.toString() + "px";
      HubEdit._portInput.style.textAlign = "right";
      HubEdit._portInput.maxLength = 5;
      HubEdit._portInput.size = 5;
      new InputFieldManager(HubEdit._portInput, 3, true, Number.NaN, Number.NaN, null);
      p.appendChild(HubEdit._portInput);
      p.appendChild(document.createElement("BR"));
      p.appendChild(document.createElement("BR"));
      span = document.createElement("SPAN");
      span.innerText = "Path:";
      span.style.marginLeft = Math.round(20 * constants.generalSizeCoef).toString() + "px";
      p.appendChild(span);
      HubEdit._pathInput = document.createElement("INPUT");
      HubEdit._pathInput.style.border = "1px solid grey";
      HubEdit._pathInput.style.fontFamily = constants.generalFontFamily;
      HubEdit._pathInput.style.fontSize = constants.generalFontSize.toString() + "px";
      HubEdit._pathInput.size = 45;
      p.appendChild(HubEdit._pathInput);
      p.appendChild(document.createElement("BR"));
      p.appendChild(document.createElement("BR"));
      span = document.createElement("SPAN");
      span.innerText = "Username:";
      span.style.marginLeft = Math.round(20 * constants.generalSizeCoef).toString() + "px";
      p.appendChild(span);
      HubEdit._usernameInput = document.createElement("INPUT");
      HubEdit._usernameInput.style.border = "1px solid grey";
      HubEdit._usernameInput.style.fontFamily = constants.generalFontFamily;
      HubEdit._usernameInput.style.fontSize = constants.generalFontSize.toString() + "px";
      HubEdit._usernameInput.size = 15;
      p.appendChild(HubEdit._usernameInput);
      span = document.createElement("SPAN");
      span.innerText = "Password:";
      span.style.marginLeft = Math.round(20 * constants.generalSizeCoef).toString() + "px";
      p.appendChild(span);
      HubEdit._passwordInput = document.createElement("INPUT");
      HubEdit._passwordInput.type = "password";
      HubEdit._passwordInput.style.border = "1px solid grey";
      HubEdit._passwordInput.style.fontFamily = constants.generalFontFamily;
      HubEdit._passwordInput.style.fontSize = constants.generalFontSize.toString() + "px";
      HubEdit._passwordInput.size = 15;
      p.appendChild(HubEdit._passwordInput);
      p = document.createElement("P");
      p.style.paddingTop = "0px";
      p.style.marginTop = Math.round(3 * constants.generalSizeCoef).toString() + "px";
      p.style.lineHeight = Math.round(12 * constants.generalSizeCoef).toString() + "px";
      p.innerText = "Important note: credentials are saved in the configuration file wich is easily accessible. Therefore, if hub is write-protected, it might be wise to use ReadOnly credentials here. When installed on a Yoctopuce hub, Yocto-Visualization (for web) will automatically ask for read/write credentials at save time if neccessary.";
      p.style.textAlign = "justify";
      HubEdit._contents.appendChild(p);
    }
    HubEdit._protocolSelect.value = hub.protocol;
    HubEdit._addressInput.value = hub.addr;
    HubEdit._portInput.value = hub.port;
    HubEdit._pathInput.value = hub.path;
    HubEdit._usernameInput.value = hub.user;
    HubEdit._passwordInput.value = hub.encryptedPassword != "" ? HubEdit.FakePassword : "";
    HubEdit._window.show();
  }
  static hide() {
    if (HubEdit._window == null)
      return;
    HubEdit._window.hide();
    HubEdit._passwordInput.value = "";
    if (HubEdit._whenDone != null)
      HubEdit._whenDone();
  }
  static okClicked() {
    HubEdit._currenthub.protocol = HubEdit._protocolSelect.value;
    HubEdit._currenthub.addr = HubEdit._addressInput.value;
    HubEdit._currenthub.port = HubEdit._portInput.value;
    HubEdit._currenthub.path = HubEdit._pathInput.value;
    HubEdit._currenthub.user = HubEdit._usernameInput.value;
    if (HubEdit._currenthub.user != "") {
      if (HubEdit._passwordInput.value != HubEdit.FakePassword) {
        HubEdit._currenthub.encryptedPassword = Hub.Encrypt(HubEdit._passwordInput.value, Hub.loginCypherPassword);
      }
    } else {
      HubEdit._currenthub.encryptedPassword = "";
    }
    if (HubEdit._thisIsEditing) {
      configForm.hubGotEdited(HubEdit._currenthub);
    } else {
      configForm.hubWasAdded(HubEdit._currenthub);
    }
    HubEdit.hide();
    if (HubEdit._whenDone != null)
      HubEdit._whenDone();
  }
};
HubEdit.FakePassword = "******";
HubEdit._thisIsEditing = false;
HubEdit._whenDone = null;
HubEdit.fontSize = constants.generalFontSize;

// obj/full/credPrompt_rw.js
var CredentialsPrompt = class {
  static get activeBorderColor() {
    return constants.WindowInnerBorderColor;
  }
  static get inactiveBorderColor() {
    return "#b0b0b0";
  }
  static get activeColor() {
    return "black";
  }
  static get inactiveColor() {
    return "grey";
  }
  static get activeBackgroundColor() {
    return constants.WindowInnerBackgroundColor;
  }
  static get inactiveBackgroundColor() {
    return constants.WindowBackgroundColor;
  }
  static get username() {
    return this._username;
  }
  static get password() {
    return this._password;
  }
  static show(targeturl, whenDone) {
    if (CredentialsPrompt._window == null) {
      CredentialsPrompt._okButton = new button("Ok", () => {
        CredentialsPrompt.okClicked();
      });
      CredentialsPrompt._cancelButton = new button("Cancel", () => {
        CredentialsPrompt.hide();
      });
      let params = new newWindowParam();
      params.positionType = 1;
      params.width = Math.round(450 * constants.generalSizeCoef);
      params.height = Math.round(175 * constants.generalSizeCoef);
      params.isModal = true;
      params.closeIcon = false;
      params.title = "Some credentials are required";
      params.buttons.push(CredentialsPrompt._okButton);
      params.buttons.push(CredentialsPrompt._cancelButton);
      CredentialsPrompt._window = new YWindow(params);
      CredentialsPrompt._contents = CredentialsPrompt._window.innerContentDiv;
      let p = document.createElement("P");
      p.style.paddingTop = "10px";
      p.style.marginTop = Math.round(5 * constants.generalSizeCoef).toString() + "px";
      p.style.lineHeight = Math.round(15 * constants.generalSizeCoef).toString() + "px";
      p.innerText = "Saving configuration on " + targeturl + " requires  read/write credentials.";
      p.style.textAlign = "justify";
      CredentialsPrompt._contents.appendChild(p);
      p.appendChild(document.createElement("BR"));
      p.appendChild(document.createElement("BR"));
      let span = document.createElement("SPAN");
      span = document.createElement("SPAN");
      span.innerText = "Username:";
      span.style.marginLeft = Math.round(20 * constants.generalSizeCoef).toString() + "px";
      p.appendChild(span);
      CredentialsPrompt._usernameInput = document.createElement("INPUT");
      CredentialsPrompt._usernameInput.style.border = "1px solid grey";
      CredentialsPrompt._usernameInput.style.fontFamily = constants.generalFontFamily;
      CredentialsPrompt._usernameInput.style.fontSize = constants.generalFontSize.toString() + "px";
      CredentialsPrompt._usernameInput.size = 15;
      p.appendChild(CredentialsPrompt._usernameInput);
      span = document.createElement("SPAN");
      span.innerText = "Password:";
      span.style.marginLeft = Math.round(20 * constants.generalSizeCoef).toString() + "px";
      p.appendChild(span);
      CredentialsPrompt._passwordInput = document.createElement("INPUT");
      CredentialsPrompt._passwordInput.type = "password";
      CredentialsPrompt._passwordInput.style.border = "1px solid grey";
      CredentialsPrompt._passwordInput.style.fontFamily = constants.generalFontFamily;
      CredentialsPrompt._passwordInput.style.fontSize = constants.generalFontSize.toString() + "px";
      CredentialsPrompt._passwordInput.size = 15;
      CredentialsPrompt._passwordInput.addEventListener("keypress", (e) => {
        if (e.key == "Enter")
          this.okClicked();
      });
      p.appendChild(CredentialsPrompt._passwordInput);
    }
    CredentialsPrompt._window.show();
    CredentialsPrompt._usernameInput.focus();
    CredentialsPrompt._whenDone = whenDone;
  }
  static hide() {
    if (CredentialsPrompt._window == null)
      return;
    CredentialsPrompt._window.hide();
    CredentialsPrompt._passwordInput.value = "";
  }
  static okClicked() {
    CredentialsPrompt._username = CredentialsPrompt._usernameInput.value;
    CredentialsPrompt._password = CredentialsPrompt._passwordInput.value;
    CredentialsPrompt.hide();
    if (CredentialsPrompt._whenDone != null)
      CredentialsPrompt._whenDone(CredentialsPrompt._usernameInput.value, CredentialsPrompt._passwordInput.value);
  }
};
CredentialsPrompt._whenDone = null;
CredentialsPrompt.fontSize = constants.generalFontSize;
CredentialsPrompt._username = "";
CredentialsPrompt._password = "";

// obj/full/YoctoVisualizationBinaries.js
var BinariesBlobs = class {
};
BinariesBlobs.ro_js = "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";
BinariesBlobs.rw_js = "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";
BinariesBlobs.ro_minjs = "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";
BinariesBlobs.rw_minjs = "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";

// obj/full/installer_rw.js
var codeInstance = class {
  constructor(filename, EStarget, version, readonly) {
    this._compressed = filename.slice(-3) == ".gz";
    this._filename = this._compressed ? filename.slice(0, -3) : filename;
    this._version = version == "" ? "Unknown" : version;
    this._EStarget = EStarget == "" ? "Unknown" : EStarget;
    this._minified = filename.indexOf(".min.") > 0;
    this._readonly = readonly;
  }
  get compressed() {
    return this._compressed;
  }
  get version() {
    return this._version;
  }
  get readonly() {
    return this._readonly;
  }
  get EStarget() {
    return this._EStarget;
  }
  get minified() {
    return this._minified;
  }
  get filename() {
    return this._filename + (this.compressed ? ".gz" : "");
  }
};
var pageInstance = class {
  constructor(filename, contents) {
    let strContents = YAPI.imm_bin2str(contents);
    this._compressed = filename.slice(-3) == ".gz";
    this._filename = this._compressed ? filename.slice(0, -3) : filename;
    this._readonly = strContents.indexOf("yv4web-readonly") > 0;
    this._useMinified = strContents.indexOf("yv4web-readonly.min.js") > 0 || strContents.indexOf("yv4web-full.min.js") > 0;
    this._action = 0;
    this._contents = contents;
  }
  get compressed() {
    return this._compressed;
  }
  get readonly() {
    return this._readonly;
  }
  set readonly(value) {
    this._readonly = value;
  }
  get fs_filename() {
    return this._filename + (this.compressed ? ".gz" : "");
  }
  get http_filename() {
    return this._filename;
  }
  set action(value) {
    this._action = value;
  }
  get action() {
    return this._action;
  }
  get contents() {
    return this._contents;
  }
  get useMinified() {
    return this._useMinified;
  }
  set useMinified(value) {
    this._useMinified = value;
  }
};
var YV4W_installer = class {
  constructor(container, options) {
    this.CALLERISHTTPS = location.protocol.toLowerCase().substr(0, 5) == "HTTPS";
    this.DEFAULT_PROTOCOL = this.CALLERISHTTPS ? YV4W_installer.HTTPS : YV4W_installer.HTTP;
    this.FIRMWAREMINVERSION = 43805;
    this.DEFAULTADDR = "";
    this.DEFAULTPORT = "80";
    this.DEFAULTPATH = "";
    this.DEFAULTCANCELABLE = false;
    this.DEFAULTINTIALFOCUS = true;
    this.DEFAULTUSER = "";
    this.DEFAULTPWD = "";
    this.DEFAULTFILEPREFIX = "default";
    this.DEFAULTSRVUSERNAME = "";
    this.DEFAULTSRVPASSORD = "";
    this._currentStep = 0;
    this._warningRow = null;
    this._welcomeText = null;
    this._hubAddr = null;
    this._connectingText = null;
    this._ipAddrInput = null;
    this._protocolInput = null;
    this._ipPortInput = null;
    this._pathInput = null;
    this._configFileInput = null;
    this._webPageInput = null;
    this._connectiongError = null;
    this._pwdPanel = null;
    this._descPanel = null;
    this._customFilesPanel = null;
    this._doneMsgContainer = null;
    this._confirmUninstallPanel = null;
    this._modInstancesPanel = null;
    this._donePanel = null;
    this._runPanel = null;
    this._modifyInstallPanel = null;
    this._adminNameInput = null;
    this._adminPasswordInput = null;
    this._userNameInput = null;
    this._userPasswordInput = null;
    this._useReadOnlyInput = null;
    this._fileprefixInput = null;
    this._useFullVersionInput = null;
    this._removeUnusedJs = null;
    this._makeDefaultInput = null;
    this._userCredTable = null;
    this._optionsPanel = null;
    this._connectionErrorMsg = null;
    this._instancesFiles = [];
    this._jsCodeinstances = [];
    this._webPageinstances = [];
    this._uninstallOpt = null;
    this._updateOpt = null;
    this._addInstanceOpt = null;
    this._modInstanceOpt = null;
    this._confirmUninstall = null;
    this._history = [];
    this._ErrMsgContainer = null;
    this._currentHub = null;
    this._currentfs = null;
    this._currentHub_RW_username = "";
    this._currentHub_RW_password = "";
    this._currentHub_RO_username = "";
    this._currentHub_RO_password = "";
    this._currentHub_protocol = "";
    this._currentHubLink_protocol = "";
    this._currentHub_Addr = "";
    this._currentHub_port = "";
    this._currentHub_path = "";
    this._currentHub_ReadOnlyProtected = false;
    this._warning = "";
    this._finalURL = "";
    this._plannedaction = 0;
    this._alreadyInstalled = false;
    this._applicationURL = "";
    this.ESVersion = "es2017";
    this.WELCOMEPANEL = 0;
    this.ENTERHUBADDR = 1;
    this.CONNECTINGPANEL = 2;
    this.CONNECTIONERROR = 3;
    this.PASSWORDPANEL = 4;
    this.DESCRIPTIONPANEL = 5;
    this.CUSTOMFILESPANEL = 6;
    this.OPTIONSPANEL = 7;
    this.RUNPANEL = 8;
    this.DONEPANEL = 9;
    this.MODIFYINSTALLPANEL = 10;
    this.CONFIRMUNINSTALLPANEL = 11;
    this.MODINSTANCESPANEL = 12;
    this.ACTIONINSTALL = 1;
    this.ACTIONUNINSTALL = 2;
    this.ACTIONADDINSTANCE = 3;
    this.ACTIONMODINSTANCE = 4;
    this.ACTIONUPDATE = 5;
    this._MODIFYNOTHING = 0;
    this._MODIFYCOMPRESS = 1;
    this._MODIFYUNCOMPRESS = 2;
    this._MODIFYMAKEREADONLY = 3;
    this._MODIFYMAKEREADWRITE = 4;
    this._MODIFYUSEMINIFIED = 5;
    this._MODIFYUSEPLAIN = 6;
    this._MODIFYDELETE = 7;
    this.TARGETEXTENSION = ".html";
    this.icon = '<link rel="icon" type="image/svg+xml" href="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNjQiIGhlaWdodD0iNjQiIHZlcnNpb249IjEuMSIgdmlld0JveD0iMCAwIDE3IDE3IiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPjxyZWN0IHg9IjAiIHk9IjAiIHdpZHRoPSIxNyIgaGVpZ2h0PSIxNyIgcng9IjEuMSIgcnk9IjEuMSIgZmlsbD0iI2ZmZiIgZmlsbC1vcGFjaXR5PSIuOSIvPjxwYXRoIGQ9Im0xMC43IDEuMy0wLjI5IDAuMjljLTAuMDQ3IDAuMDQ3LTAuMDczIDAuMTEtMC4wNzIgMC4xOHYxLjFjLTEuMS0wLjktMi43LTAuODMtMy43IDAuMTRsLTAuNC0wLjR2LTAuOTdjMC4zNS0wLjI1IDAuMi0wLjgyLTAuMjMtMC44My0wLjQzLTAuMDE0LTAuNjMgMC41My0wLjI3IDAuODJ2MS4xYzAgMC4wNjcgMC4wMjcgMC4xMyAwLjA3NCAwLjE4bDAuNDkgMC40OWMtMC40MyAwLjU5LTAuNjMgMS4zLTAuNTQgMi4xdjAuMDA3MmwtMC44My0wLjgzYy0wLjA0Ny0wLjA0Ny0wLjExLTAuMDczLTAuMTgtMC4wNzJoLTJjLTAuMjctMC4zNi0wLjgzLTAuMTktMC44MyAwLjI1IDAuMDAxMiAwLjQ0IDAuNTYgMC42MiAwLjgyIDAuMjVoMS45bDEuMyAxLjNjMC40MyAwLjM4IDAuNzQgMS4yIDAuNTkgMS42aC0yLjVjLTAuMDY2IDAgLTAuMTMgMC4wMjctMC4xOCAwLjA3NGwtMS40IDEuNGMtMC4zOS0wLjA4OS0wLjcyIDAuMzQtMC40OCAwLjY5czAuODYgMC4yIDAuODItMC4zM2wxLjMtMS4zaDIuNmMwLjI2IDAuMTUgMC41MSAwLjQgMC42NyAwLjY1djEuOWwtMS41IDEuNWMtMC4wNDcgMC4wNDctMC4wNzMgMC4xMS0wLjA3NCAwLjE4djAuMjhjLTAuNDUgMC4zLTAuMTUgMC44MyAwLjIzIDAuODMgMC4zOCAwIDAuNjMtMC40NyAwLjI3LTAuODF2LTAuMjFsMS41LTEuNWMwLjA0Ny0wLjA0NiAwLjA3NC0wLjExIDAuMDc0LTAuMTh2LTEuN2MwLjI0LTAuMzIgMS4xLTAuNCAxLjQtMC4wM3YxLjJjIDAgMC4wNjYgMC4wMjcgMC4xMyAwLjA3NCAwLjE4bDEuNSAxLjV2MC42OWMtMC4zNiAwLjI0LTAuMjMgMC44MSAwLjI3IDAuODIgMC40OSAwLjAwMjEgMC41NC0wLjY0IDAuMjMtMC44MnYtMC43OWMgMCAtMC4wNjYtMC4wMjctMC4xMy0wLjA3NC0wLjE4bC0xLjUtMS41di0xLjRjMC4xNS0wLjIgMC4zLTAuMjUgMC41My0wLjI0aDMuMmwwLjkxIDAuOTFjLTAuMDk5IDAuNDQgMC40OCAwLjcyIDAuNzcgMC40IDAuMjgtMC4zMiAwLjA3Mi0wLjc5LTAuNDItMC43NmwtMC45OC0wLjk4Yy0wLjA0Ny0wLjA0Ny0wLjExLTAuMDcyLTAuMTgtMC4wNzJoLTNjLTAuMjEtMC4zMiAwLjI0LTEuNSAwLjY3LTEuOWwyLjIgMC4wMDU5YzAuMDY3IDAgMC4xMy0wLjAyNiAwLjE4LTAuMDcybDEuMS0xLjFjMC4zOSAwLjA5NiAwLjczLTAuNCAwLjQ0LTAuNzNzLTAuODctMC4xLTAuNzggMC4zNmwtMS4xIDEuMWgtMmMwLjI3LTAuOTUgMC4wMDY3LTEuOS0wLjQzLTIuNXYtMS41bDAuMjEtMC4yMWMwLjM4IDAuMDgyIDAuNzEtMC4zMyAwLjQ2LTAuNjlzLTAuODctMC4xOS0wLjggMC4zM3ptLTMuMiA0LjljMC44NC0wLjAyOSAwLjk2IDEuNSAwLjIgMS41LTAuNzYtMC4wMTQtMS0xLjQtMC4yLTEuNXptMi4xIDBjMC43NSAwLjA4NCAwLjYxIDEuNS0wLjIgMS41LTAuODEgMC4wMDMzLTAuNTUtMS41IDAuMi0xLjV6IiBmaWxsLW9wYWNpdHk9Ii4xIi8+PHJlY3QgeD0iMCIgeT0iMCIgd2lkdGg9IjE3IiBoZWlnaHQ9IjE2IiByeT0iMS44IiBvcGFjaXR5PSIwIiBzdHJva2Utd2lkdGg9Ii4yNiIvPjxlbGxpcHNlIGN4PSI5LjQiIGN5PSI3LjQiIHJ4PSIuMzQiIHJ5PSIuMzMiIG9wYWNpdHk9Ii4xIi8+PGVsbGlwc2UgY3g9IjcuNyIgY3k9IjcuNCIgcng9Ii4zNCIgcnk9Ii4zMyIgb3BhY2l0eT0iLjEiLz48ZyBmaWxsPSJub25lIj48cGF0aCBkPSJtMS4xIDEuOSAwLjA2NiAxNCIgc3Ryb2tlPSIjN2U3ZTdlIiBzdHJva2Utd2lkdGg9Ii4yIi8+PHBhdGggZD0ibTE1IDEzaC0xNSIgc3Ryb2tlPSIjN2U3ZTdlIiBzdHJva2Utd2lkdGg9Ii4yIi8+PHBhdGggZD0ibTEuMiAxM2M1LjQtMS4xIDEwLTIuNyAxNS02LjkiIHN0cm9rZT0ibGltZSIgIHN0cm9rZS13aWR0aD0iLjQiLz48cGF0aCBkPSJtMS4yIDEzYzAuMS0wLjA1MyAwLjQ1LTEuNCAxLjItMS40IDAuNzggMCAxLjQgMi44IDIuMyAyLjggMC44Ni0wLjAwMTUgMS42LTIuOCAyLjQtMi44IDAuODQgMCAxLjUgMi44IDIuNCAyLjggMC45IDAuMDEzIDEuNi0yLjggMi40LTIuOCAwLjgyIDAuMDI4IDEuNSAyLjcgMi4zIDIuOCAwLjI2IDAuMDQzIDAuNjgtMC4zNCAwLjY3LTAuNDIiICBzdHJva2U9InJlZCIgIHN0cm9rZS13aWR0aD0iLjQiLz48L2c+PHBhdGggZD0ibTE1IDEyLjQgMS4xIDAuNi0xLjEgMC41N3oiIGZpbGw9IiM3ZTdlN2UiLz48cGF0aCBkPSJtMC41MiAyIDAuNjItMSAwLjU5IDF6IiBmaWxsPSIjN2U3ZTdlIi8+PHBhdGggZD0ibTkuOCAwIDcuMiA3LjJ2LTRsLTMuMi0zLjJ6IiBmaWxsPSJncmVlbiIvPjxnIGZpbGw9IiNmZmYiIHN0cm9rZS13aWR0aD0iMSI+PHBhdGggZD0ibTEyLjcgMS42MyAwLjQ5LTEuMSAwLjE5IDAuMTktMC4zMyAwLjc0IDAuNzUtMC4zMiAwLjEyIDAuMTItMC4zMiAwLjc1IDAuNzMtMC4zNCAwLjE3IDAuMTctMS4xIDAuNDktMC4xMi0wLjEyIDAuMzMtMC43Ny0wLjc3IDAuMzN6Ii8+PHBhdGggZD0ibTEzLjggMi43OSAwLjc5LTAuNzkgMC44MiAwLjgyLTAuMTQgMC4xNC0wLjY0LTAuNjQtMC4xOCAwLjE4IDAuMzYgMC4zNi0wLjE0IDAuMTQtMC4zNi0wLjM2LTAuMTkgMC4xOSAwLjY0IDAuNjQtMC4xNSAwLjE1eiIvPjxwYXRoIGQ9Im0xNi4xIDMuOC0wLjQyLTAuNDItMC4xOSAwLjE5IDAuNDIgMC40MnEwLjA0OSAwLjA0OSAwLjA3OSAwLjA1MyAwLjAzMiAwIDAuMDY0LTAuMDI2bDAuMDc1LTAuMDc1cTAuMDMxLTAuMDMxIDAuMDI1LTAuMDYyLTAuMDA0NS0wLjAzMi0wLjA1Mi0wLjA3OXptLTAuMzIgMC4zMi0wLjQyLTAuNDItMC4yIDAuMiAwLjQyIDAuNDJxMC4wNTIgMC4wNTMgMC4wODYgMC4wNTQgMC4wMzUgMC4wMDMxIDAuMDc1LTAuMDM3bDAuMDYtMC4wNnEwLjA0LTAuMDQgMC4wMzYtMC4wNzQtMC4wMDIzLTAuMDM0LTAuMDU0LTAuMDg2em0tMC45NS0wLjI2IDAuNzktMC43OSAwLjY4IDAuNjhxMC4wOTQgMC4wOTQgMC4xIDAuMTcgMC4wMDUzIDAuMDc5LTAuMDc1IDAuMTZsLTAuMDk4IDAuMDk4cS0wLjA1NyAwLjA1Ny0wLjEyIDAuMDU3LTAuMDY5LTAuMDAxNS0wLjE1LTAuMDU5IDAuMDU5IDAuMDc3IDAuMDU3IDAuMTYtMC4wMDIzIDAuMDc3LTAuMDY2IDAuMTRsLTAuMSAwLjFxLTAuMDc5IDAuMDc5LTAuMTcgMC4wNTktMC4wOTYtMC4wMTktMC4yMi0wLjE0eiIvPjwvZz48L3N2Zz4=">';
    if (typeof options !== "undefined") {
      if (options != null) {
        if (typeof options["protocol"] === "string")
          this.DEFAULT_PROTOCOL = options["protocol"].toUpperCase() == YV4W_installer.HTTPS.toUpperCase() ? YV4W_installer.HTTPS : YV4W_installer.HTTP;
        if (typeof options["addr"] === "string") {
          this.DEFAULTADDR = options["addr"];
          let n = this.DEFAULTADDR.indexOf(":");
          if (n > 0) {
            this.DEFAULTPORT.substring(n + 1);
            this.DEFAULTADDR.substring(0, n);
          }
        }
        if (typeof options["port"] === "number")
          this.DEFAULTPORT = options["port"].toString();
        if (typeof options["path"] === "string")
          this.DEFAULTPATH = options["path"];
        if (typeof options["cancelable"] === "boolean")
          this.DEFAULTCANCELABLE = options["cancelable"];
        if (typeof options["initialFocus"] === "boolean")
          this.DEFAULTINTIALFOCUS = options["initialFocus"];
      }
    }
    this._container = container;
    this._container.innerHTML = "";
    this._container.style.backgroundColor = constants.WindowBackgroundColor;
    this._container.style.fontFamily = constants.WindowHeaderFontFamily;
    let bottomdiv = document.createElement("DIV");
    bottomdiv.style.position = "absolute";
    bottomdiv.style.bottom = "0px";
    bottomdiv.style.right = "5px";
    bottomdiv.style.height = "30px";
    bottomdiv.style.textAlign = "right";
    bottomdiv.style.verticalAlign = "center";
    this._prevButton = new button("< Prev", () => {
      this.gotoPrevious();
    }, 1);
    this._cancelButton = new button("Cancel", async () => {
      this.closeWindow();
    }, 1);
    this._nextButton = new button("Next >", () => {
      this.gotoNext();
    }, 1);
    this._okButton = new button("Ok", async () => {
      this.DEFAULTCANCELABLE ? this.closeWindow() : await this.resetAll();
    }, 1);
    this._prevButton.tabIndex = 100;
    this._cancelButton.tabIndex = 101;
    this._nextButton.tabIndex = 102;
    this._okButton.tabIndex = 103;
    bottomdiv.appendChild(this._prevButton.Element);
    bottomdiv.appendChild(this._cancelButton.Element);
    bottomdiv.appendChild(this._nextButton.Element);
    bottomdiv.appendChild(this._okButton.Element);
    this._prevButton.visible = false;
    this._cancelButton.visible = this.DEFAULTCANCELABLE;
    this._container.appendChild(bottomdiv);
    let topDiv = document.createElement("DIV");
    topDiv.style.position = "absolute";
    topDiv.style.top = "5px";
    topDiv.style.paddingLeft = "10px";
    topDiv.style.paddingTop = "5px";
    topDiv.style.paddingBottom = "5px";
    topDiv.style.left = "5px";
    topDiv.style.right = "5px";
    topDiv.style.backgroundColor = constants.WindowHeaderBackgroundColor;
    topDiv.style.color = constants.WindowHeaderColor;
    topDiv.style.fontSize = "x-large";
    topDiv.style.whiteSpace = "nowrap";
    topDiv.style.overflow = "hidden";
    topDiv.innerText = "Yocto-Visualization (for web) installer";
    this._container.appendChild(topDiv);
    this.gotoPanel(this.WELCOMEPANEL);
  }
  closeWindow() {
    var _a;
    (_a = this._container.parentElement) === null || _a === void 0 ? void 0 : _a.removeChild(this._container);
  }
  createNewContentDiv() {
    let div = document.createElement("DIV");
    div.style.position = "absolute";
    div.style.textAlign = "justify";
    div.style.top = "50px";
    div.style.left = "15px";
    div.style.right = "15px";
    return div;
  }
  loadLocalFile(fileChooser) {
    return new Promise(function(resolve, reject) {
      if (fileChooser.files && fileChooser.files[0]) {
        let reader = new FileReader();
        reader.onload = function(e) {
          resolve(e.target.result);
        };
        reader.readAsText(fileChooser.files[0]);
      } else {
        resolve(null);
      }
    });
  }
  showWelcomePanel(visible, goingback) {
    if (!visible) {
      if (this._welcomeText != null)
        this._welcomeText.style.display = "none";
      return;
    }
    this._okButton.visible = false;
    this._prevButton.visible = false;
    this._nextButton.visible = true;
    this._nextButton.enabled = true;
    this._cancelButton.visible = this.DEFAULTCANCELABLE;
    if (this._welcomeText == null) {
      this._welcomeText = this.createNewContentDiv();
      this._welcomeText.innerText = "Yoctopuce is proud to offer you  Yocto-Visualization (for web), an application that  allows to view Yoctopuce sensors data with a simple web browser.\n\nThis wizard will help you to install Yocto-Visualization (for web) version " + constants.buildVersion + " (" + this.ESVersion + ') on a YoctoHub such as YoctoHub-Ethernet, YoctoHub-Wireless, VirtualHub etc..\n\n Click on "next" to start';
      this._container.appendChild(this._welcomeText);
    }
    this._currentHub = null;
    this._currentfs = null;
    this._currentHub_RW_username = "";
    this._currentHub_RW_password = "";
    this._currentHub_RO_username = "";
    this._currentHub_RO_password = "";
    this._currentHub_protocol = "";
    this._currentHub_Addr = "";
    this._currentHub_port = "";
    this._currentHub_path = "";
    let tabIndex = 1;
    this._nextButton.tabIndex = tabIndex++;
    if (this.DEFAULTINTIALFOCUS)
      this._nextButton.focus();
    this._welcomeText.style.display = "";
  }
  showEnterHubAddr(visible, goingback) {
    if (!visible) {
      if (this._hubAddr != null)
        this._hubAddr.style.display = "none";
      return;
    }
    if (this._hubAddr == null) {
      this._hubAddr = this.createNewContentDiv();
      let p = document.createElement("P");
      p.innerText = "Enter the address of the hub you want to install Yocto-Visualization on. This address must be reacheable from your web browser.";
      this._hubAddr.appendChild(p);
      let Table = document.createElement("TABLE");
      Table.style.fontSize = "smaller";
      let Row = document.createElement("TR");
      let TD1 = document.createElement("TD");
      TD1.innerText = "Hub address:";
      TD1.style.whiteSpace = "normal";
      Row.appendChild(TD1);
      let TD2 = document.createElement("TD");
      TD2.style.whiteSpace = "normal";
      this._protocolInput = document.createElement("SELECT");
      let httpopt1 = document.createElement("OPTION");
      httpopt1.text = "http://";
      httpopt1.value = YV4W_installer.HTTP;
      this._protocolInput.add(httpopt1);
      let httpopt2 = document.createElement("OPTION");
      httpopt2.text = "https://";
      httpopt2.value = YV4W_installer.HTTPS;
      this._protocolInput.add(httpopt2);
      this._protocolInput.value = this.DEFAULT_PROTOCOL;
      this._protocolInput.addEventListener("change", () => {
        if (this._protocolInput != null && this._ipPortInput != null) {
          if (this._protocolInput.value == YV4W_installer.HTTPS && parseInt(this._ipPortInput.value) == 80)
            this._ipPortInput.value = "443";
          if (this._protocolInput.value == YV4W_installer.HTTP && parseInt(this._ipPortInput.value) == 443)
            this._ipPortInput.value = "80";
          if (this._warningRow != null)
            this._warningRow.style.display = this._protocolInput.value == YV4W_installer.HTTP && this.CALLERISHTTPS ? "" : "none";
        }
      });
      TD2.appendChild(this._protocolInput);
      this._ipAddrInput = document.createElement("INPUT");
      this._ipAddrInput.value = this.DEFAULTADDR;
      this._ipAddrInput.size = 34;
      this._ipAddrInput.addEventListener("input", () => {
        this._nextButton.enabled = this._ipAddrInput.value != "" && this._ipPortInput.value != "";
      });
      TD2.appendChild(this._ipAddrInput);
      let span = document.createElement("SPAN");
      span.innerText = ":";
      TD2.appendChild(span);
      this._ipPortInput = document.createElement("INPUT");
      this._ipPortInput.value = this.DEFAULTPORT != "" ? this.DEFAULTPORT : "4444";
      this._ipPortInput.type = "number";
      this._ipPortInput.min = "1";
      this._ipPortInput.max = "65535";
      this._ipPortInput.maxLength = 6;
      this._ipPortInput.style.width = "60px";
      this._ipPortInput.addEventListener("input", () => {
        this._nextButton.enabled = this._ipAddrInput.value != "" && this._ipPortInput.value != "";
      });
      TD2.appendChild(this._ipPortInput);
      Row.appendChild(TD2);
      Table.appendChild(Row);
      this._warningRow = document.createElement("TR");
      TD1 = document.createElement("TD");
      TD1.style.whiteSpace = "normal";
      TD1.style.fontSize = "smaller";
      TD1.innerText = "WARNING: Unless your web browser is configured to accept 'mixed content', trying to establish an HTTP connection from an HTTPS page is likely to fail.";
      TD1.colSpan = 2;
      this._warningRow.style.display = "none";
      this._warningRow.appendChild(TD1);
      Table.appendChild(this._warningRow);
      Row = document.createElement("TR");
      TD1 = document.createElement("TD");
      TD1.style.whiteSpace = "normal";
      TD1.style.paddingTop = "20px";
      TD1.style.paddingBottom = "20px";
      TD1.style.textAlign = "justify";
      TD1.innerText = "On YoctoHubs, protocol is HTTP and port is likely to be 80. On native Virtualhub, protocol is HTTP and port is likely to be 4444. On VirtualHub (for web), the  hub path is mandatory and should be set to your VirtualHub (for web) instance path, protocol and  port can be either HTTP and 80 or HTTPS and 433.";
      TD1.colSpan = 2;
      Row.appendChild(TD1);
      Table.appendChild(Row);
      Row = document.createElement("TR");
      TD1 = document.createElement("TD");
      TD1.style.whiteSpace = "normal";
      TD1.innerText = "Hub path:";
      Row.appendChild(TD1);
      TD2 = document.createElement("TD");
      TD2.style.whiteSpace = "normal";
      this._pathInput = document.createElement("INPUT");
      this._pathInput.value = this.DEFAULTPATH;
      this._pathInput.size = 48;
      TD2.appendChild(this._pathInput);
      Row.appendChild(TD2);
      Table.appendChild(Row);
      this._hubAddr.appendChild(Table);
      this._container.appendChild(this._hubAddr);
    }
    this._hubAddr.style.display = "";
    let tabIndex = 1;
    this._protocolInput.tabIndex = tabIndex++;
    this._ipAddrInput.tabIndex = tabIndex++;
    this._ipPortInput.tabIndex = tabIndex++;
    this._pathInput.tabIndex = tabIndex++;
    this._prevButton.tabIndex = tabIndex++;
    this._nextButton.tabIndex = tabIndex++;
    this._protocolInput.focus();
    this._nextButton.visible = true;
    this._nextButton.enabled = this._ipAddrInput.value != "";
  }
  async showConnectingPanel(visible, goingback) {
    if (!visible) {
      if (this._connectingText != null)
        this._connectingText.style.display = "none";
      return;
    }
    if (this._connectingText == null) {
      this._connectingText = this.createNewContentDiv();
      this._container.appendChild(this._connectingText);
    }
    this.removeCurrentPanelFromHistory();
    this._connectingText.innerText = "Connecting to hub " + this._ipAddrInput.value + ". Please wait...";
    this._connectingText.style.display = "";
    this._nextButton.visible = false;
    this._prevButton.visible = false;
    this._cancelButton.visible = false;
    let IP = this._ipAddrInput.value;
    let port = parseInt(this._ipPortInput.value);
    let protocol = this._protocolInput.value;
    this._currentHubLink_protocol = this._protocolInput.value;
    let RW_username = "";
    let RW_password = "";
    let RO_username = "";
    let RO_password = "";
    if (this._adminNameInput != null)
      RW_username = this._adminNameInput.value;
    if (this._adminPasswordInput != null)
      RW_password = this._adminPasswordInput.value;
    if (this._userNameInput != null)
      RO_username = this._userNameInput.value;
    if (this._userPasswordInput != null)
      RO_password = this._userPasswordInput.value;
    let url = protocol + "://" + IP + ":" + port.toString();
    let HubData = null;
    let serial = "";
    let path = this._pathInput.value;
    if (path != "") {
      if (path.charAt(0) == "/")
        path = path.slice(1);
      url += "/" + path;
    }
    let info = new HubInfo(protocol, IP, port, path, null, null);
    let infoRes = await info.makeRequest();
    if (infoRes !== true) {
      let err = "Failed to connect to the Hub while using the url\n\n" + url + "\n\n";
      let prvmsg = 'Click on the "prev" button,';
      switch (infoRes) {
        case 0:
          err += prvmsg + " and make sure that protocol, address, port and path are correct, and try again.\n\n";
          break;
        case -1:
          err += "(invalid server answer), contact yoctopuce support.";
          break;
        case -2:
          err += prvmsg + " then check path. If path is correct check hub firmware version. This installer doesn't work with versions older that " + this.FIRMWAREMINVERSION + ".";
          break;
        case -3:
          err += "An network error occured, make sure hub address is correct.\n\nAlso connexion migh have been  blocked by your web browser, most likely due to CORS policy.\n\nCheck your browser console (Shift-Control-I on most browsers), if you find an error message about a Cross-Origin Request Blocked over a 404 error, Press '<Prev' and check path carefuly.";
          break;
        case 404:
          err += prvmsg + " make sure the path is correct, and try again.";
          break;
        case 500:
          err += " the hub encountered an interal error (Error 500)";
          break;
        case 503:
          err += " the hub is  not available (Error 503)";
          break;
        case 401:
          err += " Unauthorized access, check server configuration(Error 401)";
          break;
        default:
          err += "server responded with an HTTP error " + infoRes;
          break;
      }
      this.gotoPanel(this.CONNECTIONERROR, err);
      return;
    }
    if (info.serial != "") {
      port = info.port;
      serial = info.serial;
      path = info.path;
      this._currentHub_ReadOnlyProtected = info.userPassword;
    }
    protocol = info.protocol;
    if (info.adminPassword && RW_username == "" && RW_password == "") {
      this.gotoPanel(this.PASSWORDPANEL);
      return;
    }
    await YAPI.DisableExceptions();
    let errmsg = new YErrorMsg();
    if (info.userPassword) {
      let RO_addr = info.get_hubUrl(RO_username, RO_password);
      let RO_res = await YAPI.TestHub(RO_addr, 5e3, errmsg);
      if (RO_res != YAPI.SUCCESS) {
        if (RO_res == YAPI.UNAUTHORIZED) {
          this.gotoPanel(this.PASSWORDPANEL, "ReadOnly test failed, check credentials for read only operations.");
          return;
        } else {
          let err = "Cannot connect to " + url + " : " + errmsg.msg + '.\n\nMake sure the Hub is Up and address is correct, then click the "prev" to try again';
          this.gotoPanel(this.CONNECTIONERROR, err);
          return;
        }
      }
    }
    let addr = info.get_hubUrl(RW_username, RW_password);
    this._applicationURL = IP + ":" + port.toString() + (path != "" ? "/" + path : "");
    let res = await YAPI.TestHub(addr, 5e3, errmsg);
    if (res != YAPI.SUCCESS) {
      if (res == YAPI.UNAUTHORIZED) {
        this.gotoPanel(this.PASSWORDPANEL);
        return;
      } else {
        let err = "Cannot connect to " + url + " : " + errmsg.msg + '.\n\nMake sure the Hub is Up and address is correct, then click the "prev" to try again';
        this.gotoPanel(this.CONNECTIONERROR, err);
        return;
      }
    }
    if (await YAPI.RegisterHub(addr, errmsg) != YAPI.SUCCESS) {
      let err = "Cannot connect to " + IP + " : " + errmsg.msg + '.\nMake sure the Hub is Up and address is correct, then click the "prev" to try again';
      this.gotoPanel(this.CONNECTIONERROR, err);
      return;
    }
    let m = YModule.FirstModule();
    while (m != null) {
      if (await m.get_parentHub() == "") {
        let urlMatch = false;
        let serialMatch = await m.get_serialNumber() == serial;
        if (!serialMatch)
          urlMatch = (await m.get_url()).indexOf(IP + ":" + port.toString()) > 0;
        if (serialMatch || urlMatch) {
          this._currentHub = m;
          this._currentHub_RW_username = RW_username;
          this._currentHub_RW_password = RW_password;
          this._currentHub_protocol = protocol;
          this._currentHub_Addr = IP;
          this._currentHub_port = port.toString();
          this._currentHub_path = path;
          if (await m.isReadOnly()) {
            await YAPI.UnregisterHub(await m.get_url());
            this._currentHub = null;
            this.gotoPanel(this.PASSWORDPANEL, "Write test failed, check credentials for read/write operations.");
          } else {
            this.gotoPanel(this.DESCRIPTIONPANEL);
          }
          return;
        }
      }
      m = m.nextModule();
    }
    this.gotoPanel(this.CONNECTIONERROR, "Internal Error, cannot find Hub after RegisterHub call");
  }
  removeCurrentPanelFromHistory() {
    this._history.pop();
  }
  async showConnectionError(visible, goingback, message) {
    if (!visible) {
      if (this._connectiongError != null)
        this._connectiongError.style.display = "none";
      return;
    }
    if (this._connectiongError == null) {
      this._connectiongError = this.createNewContentDiv();
      this._container.appendChild(this._connectiongError);
    }
    this.removeAllChilds(this._connectiongError);
    let Table = document.createElement("TABLE");
    let Row = document.createElement("TR");
    let TD1 = document.createElement("TD");
    TD1.style.whiteSpace = "normal";
    TD1.innerHTML = ressources.FailedIcon("64", true, false, false, false, "oops");
    Row.appendChild(TD1);
    this._ErrMsgContainer = document.createElement("TD");
    this._ErrMsgContainer.style.whiteSpace = "normal";
    this._ErrMsgContainer.style.textAlign = "justify";
    Row.appendChild(this._ErrMsgContainer);
    Table.appendChild(Row);
    this._connectiongError.appendChild(Table);
    this._ErrMsgContainer.innerText = message;
    this._nextButton.visible = false;
    this._prevButton.visible = true;
    this._cancelButton.visible = this.DEFAULTCANCELABLE;
    this._connectiongError.style.display = "";
    let tabIndex = 1;
    this._prevButton.tabIndex = tabIndex++;
    this._prevButton.focus();
  }
  MakeSureCredentialsAreNotEmpty() {
    if (this._currentHub_ReadOnlyProtected) {
      this._nextButton.enabled = this._userPasswordInput.value != "" && this._userNameInput.value != "";
    } else {
      this._nextButton.enabled = true;
    }
    if (this._adminPasswordInput.value == "" || this._adminNameInput.value == "") {
      this._nextButton.enabled = false;
    }
  }
  showPasswordPanel(visible, goingback, err) {
    if (!visible) {
      if (this._pwdPanel != null)
        this._pwdPanel.style.display = "none";
      return;
    }
    let errmsg = typeof err != "undefined" ? err : "Well, looks like this hub requires some authentication.";
    if (this._history[this._history.length - 2] == this.PASSWORDPANEL) {
      errmsg = "Invalid credentials. " + errmsg;
      this.removeCurrentPanelFromHistory();
    }
    if (this._pwdPanel == null) {
      this._pwdPanel = this.createNewContentDiv();
      this._connectionErrorMsg = document.createElement("P");
      this._connectionErrorMsg.style.marginTop = "0px";
      this._pwdPanel.appendChild(this._connectionErrorMsg);
      let Table = document.createElement("TABLE");
      let Row = document.createElement("TR");
      let TD1 = document.createElement("TD");
      TD1.style.whiteSpace = "normal";
      TD1.innerText = "Enter read/write credentials below, these are required for the installation but won't be saved in Yocto-Visualization's configuration.";
      TD1.style.fontSize = "smaller";
      TD1.colSpan = 4;
      Row.appendChild(TD1);
      Table.appendChild(Row);
      Row = document.createElement("TR");
      TD1 = document.createElement("TD");
      TD1.style.whiteSpace = "normal";
      TD1.innerText = "Username:";
      TD1.style.borderLeft = "20px solid transparent";
      TD1.style.fontSize = "smaller";
      Row.appendChild(TD1);
      let TD2 = document.createElement("TD");
      TD2.style.whiteSpace = "normal";
      TD2.style.fontSize = "smaller";
      this._adminNameInput = document.createElement("INPUT");
      this._adminNameInput.size = 12;
      this._adminNameInput.addEventListener("input", () => {
        this.MakeSureCredentialsAreNotEmpty();
      });
      TD2.appendChild(this._adminNameInput);
      Row.appendChild(TD2);
      let TD3 = document.createElement("TD");
      TD3.style.whiteSpace = "normal";
      TD3.innerText = "Password:";
      TD3.style.fontSize = "smaller";
      Row.appendChild(TD3);
      let TD4 = document.createElement("TD");
      TD4.style.whiteSpace = "normal";
      this._adminPasswordInput = document.createElement("INPUT");
      this._adminPasswordInput.type = "password";
      this._adminPasswordInput.size = 12;
      this._adminPasswordInput.addEventListener("input", () => {
        this.MakeSureCredentialsAreNotEmpty();
      });
      TD4.appendChild(this._adminPasswordInput);
      TD4.style.fontSize = "smaller";
      Row.appendChild(TD4);
      this._adminNameInput.value = this.DEFAULTUSER;
      this._adminPasswordInput.value = this.DEFAULTPWD;
      Table.appendChild(Row);
      let userRow1 = document.createElement("TR");
      TD1 = document.createElement("TD");
      TD1.style.whiteSpace = "normal";
      TD1.innerText = "\n\nEnter read-only credentials below, these will be saved in the configuration";
      TD1.style.fontSize = "smaller";
      TD1.colSpan = 4;
      userRow1.appendChild(TD1);
      Table.appendChild(userRow1);
      let userRow2 = document.createElement("TR");
      TD1 = document.createElement("TD");
      TD1.style.whiteSpace = "normal";
      TD1.innerText = "Username:";
      TD1.style.borderLeft = "20px solid transparent";
      TD1.style.fontSize = "smaller";
      userRow2.appendChild(TD1);
      TD2 = document.createElement("TD");
      TD2.style.whiteSpace = "normal";
      TD2.style.fontSize = "smaller";
      this._userNameInput = document.createElement("INPUT");
      this._userNameInput.size = 12;
      this._userNameInput.addEventListener("input", () => {
        this.MakeSureCredentialsAreNotEmpty();
      });
      TD2.appendChild(this._userNameInput);
      userRow2.appendChild(TD2);
      TD3 = document.createElement("TD");
      TD3.style.whiteSpace = "normal";
      TD3.innerText = "Password:";
      TD3.style.fontSize = "smaller";
      userRow2.appendChild(TD3);
      TD4 = document.createElement("TD");
      TD4.style.whiteSpace = "normal";
      this._userPasswordInput = document.createElement("INPUT");
      this._userPasswordInput.type = "password";
      this._userPasswordInput.size = 12;
      this._userPasswordInput.addEventListener("input", () => {
        this.MakeSureCredentialsAreNotEmpty();
      });
      TD4.appendChild(this._userPasswordInput);
      TD4.style.fontSize = "smaller";
      userRow2.appendChild(TD4);
      this._userNameInput.value = this.DEFAULTUSER;
      this._userPasswordInput.value = this.DEFAULTPWD;
      Table.appendChild(userRow2);
      Table.style.marginTop = "0px";
      Table.style.marginBottom = "20px";
      this._pwdPanel.appendChild(Table);
      let userCredVisible = "";
      if (!this._currentHub_ReadOnlyProtected) {
        userCredVisible = "none";
        this._userPasswordInput.value = "";
        this._userNameInput.value = "";
      }
      userRow1.style.display = userCredVisible;
      userRow2.style.display = userCredVisible;
      let p = document.createElement("P");
      p.innerText = 'Note: On YoctoHubs and VirtualHub, username is either "user" for readonly or "admin" for read/write. Only ready-only credentials (if any) will saved in the configuration as Yocto-Visualization will ask for read/write credentials when saving, if needed.';
      p.style.fontSize = "smaller";
      this._pwdPanel.appendChild(p);
      this._container.appendChild(this._pwdPanel);
    }
    this._connectionErrorMsg.innerText = errmsg;
    this._nextButton.visible = true;
    this._prevButton.visible = true;
    this._cancelButton.visible = this.DEFAULTCANCELABLE;
    this._pwdPanel.style.display = "";
    let tabIndex = 1;
    this._adminNameInput.tabIndex = tabIndex++;
    this._adminPasswordInput.tabIndex = tabIndex++;
    this._userNameInput.tabIndex = tabIndex++;
    this._userPasswordInput.tabIndex = tabIndex++;
    this._prevButton.tabIndex = tabIndex++;
    this._nextButton.tabIndex = tabIndex++;
    this._adminNameInput.focus();
    this.MakeSureCredentialsAreNotEmpty();
  }
  createTextRow(caption, value) {
    let Row = document.createElement("TR");
    let TD1 = document.createElement("TD");
    TD1.style.whiteSpace = "normal";
    TD1.style.whiteSpace = "nowrap";
    TD1.innerText = caption;
    Row.appendChild(TD1);
    let TD2 = document.createElement("TD");
    TD2.style.whiteSpace = "normal";
    TD2.innerText = value;
    Row.appendChild(TD2);
    return Row;
  }
  async showHubDescription(visible, goingback) {
    if (!visible) {
      if (this._descPanel != null)
        this._descPanel.style.display = "none";
      return;
    }
    if (this._descPanel == null) {
      this._descPanel = this.createNewContentDiv();
      this._container.appendChild(this._descPanel);
    }
    if (!goingback) {
      this.removeAllChilds(this._descPanel);
      this._alreadyInstalled = false;
      let p = document.createElement("P");
      p.innerText = "Sucessfully connected to Hub " + this._ipAddrInput.value;
      this._descPanel.appendChild(p);
      let m = this._currentHub;
      let Table = document.createElement("TABLE");
      Table.style.marginTop = "20px";
      Table.style.marginBottom = "20px";
      let serial = await m.get_serialNumber();
      let firmware = await m.get_firmwareRelease();
      Table.appendChild(this.createTextRow("Model:", await m.get_productName()));
      Table.appendChild(this.createTextRow("Serial:", serial));
      Table.appendChild(this.createTextRow("Firmware:", firmware));
      let tmp = firmware.lastIndexOf(".");
      if (tmp >= 0)
        firmware = firmware.substr(tmp + 1);
      this._instancesFiles = [];
      let freespace = 0;
      this._instancesFiles = [];
      this._currentfs = null;
      let error = "";
      if (firmware.indexOf("-") < 0 && parseInt(firmware) < this.FIRMWAREMINVERSION) {
        error = "Hub firmware is too old for Yocto-Visualization to run properly. You need at least version " + this.FIRMWAREMINVERSION;
        this._nextButton.enabled = false;
      }
      if (error == "") {
        let ids = await m.get_functionIds("Files");
        if (ids.length > 0) {
          this._currentfs = await YFiles.FindFiles(serial + "." + ids[0]);
          freespace = Math.floor(await this._currentfs.get_freeSpace() / 1024);
          this._instancesFiles = await this._currentfs.get_list("yv4web*");
          Table.appendChild(this.createTextRow("Free space:", freespace.toString() + "K"));
          this._nextButton.enabled = true;
          if (freespace < 200) {
            error = "Not enough free space on device, please make sure there is at least 200K available.";
            this._nextButton.enabled = false;
          }
        } else {
          error = "No filesystem found on hub. On VirtualHub, the filesystem feature needs to be explicitely enabled at startup with the -F flag.";
        }
      }
      if (error != "") {
        Table.appendChild(this.createTextRow(" ", " "));
        let Row = document.createElement("TR");
        let TD1 = document.createElement("TD");
        TD1.style.whiteSpace = "normal";
        TD1.innerHTML = ressources.FailedIcon("32", true, false, false, false, "oops");
        TD1.style.textAlign = "right";
        Row.appendChild(TD1);
        let TD2 = document.createElement("TD");
        TD2.style.whiteSpace = "normal";
        TD2.style.fontSize = "smaller";
        TD2.innerText = error;
        Row.appendChild(TD2);
        Table.appendChild(Row);
        this._nextButton.enabled = false;
      }
      this._descPanel.appendChild(Table);
      if (this._instancesFiles.length > 0) {
        let p2 = document.createElement("P");
        p2.innerText = "Yocto-Visualization (for web) appears to be already installed on this hub. Click on next to modify this installation.";
        this._descPanel.appendChild(p2);
        this._alreadyInstalled = true;
      }
    }
    this._descPanel.style.display = "";
    this._nextButton.visible = true;
    this._prevButton.visible = true;
    this._cancelButton.visible = this.DEFAULTCANCELABLE;
    let tabIndex = 1;
    this._prevButton.tabIndex = tabIndex++;
    this._nextButton.tabIndex = tabIndex++;
    this._nextButton.focus();
  }
  async loadWebPagesList(filenameDesc) {
    this._webPageinstances = [];
    let webFiles = await this._currentfs.get_list("*");
    for (let i = 0; i < webFiles.length; i++) {
      let filename = await webFiles[i].get_name();
      if (filename.indexOf(".html") >= 0) {
        if (filenameDesc != null) {
          filenameDesc.innerText = "Now downloading " + filename + "...";
        }
        let contents = await this._currentfs.download(filename);
        if (filename.slice(-3) == ".gz") {
          contents = Pako_Inflate.ungzip(contents, {});
        }
        let contentsStr = YAPI.imm_bin2str(contents);
        if (contentsStr.indexOf("window.runYV()") > 0) {
          this._webPageinstances.push(new pageInstance(filename, contents));
        }
      }
    }
  }
  async showModifyInstallPanel(visible, goingback) {
    if (!visible) {
      if (this._modifyInstallPanel != null)
        this._modifyInstallPanel.style.display = "none";
      return;
    }
    this._nextButton.visible = false;
    this._prevButton.visible = false;
    this._cancelButton.visible = false;
    if (this._modifyInstallPanel == null) {
      this._modifyInstallPanel = this.createNewContentDiv();
      this._container.appendChild(this._modifyInstallPanel);
    }
    if (!goingback) {
      this.removeAllChilds(this._modifyInstallPanel);
      this._jsCodeinstances = [];
      this._webPageinstances = [];
      let p = document.createElement("P");
      p.innerText = "Please wait, downloading and parsing files from the hub ";
      this._modifyInstallPanel.appendChild(p);
      this._modifyInstallPanel.style.display = "";
      let files = document.createElement("P");
      files.innerText = "";
      let filenameDesc = document.createElement("P");
      filenameDesc.style.fontSize = "smaller";
      this._modifyInstallPanel.appendChild(filenameDesc);
      for (let i = 0; i < this._instancesFiles.length; i++) {
        let filename = await this._instancesFiles[i].get_name();
        filenameDesc.innerText = "Now downloading " + filename + "...";
        files.innerText = filename;
        let contentsStr = "";
        let contents = await this._currentfs.download(filename);
        if (filename.slice(-3) == ".gz") {
          contents = Pako_Inflate.ungzip(contents, {});
        }
        contentsStr = YAPI.imm_bin2str(contents);
        let esTarget = "";
        let version = "";
        let readonlyVersion = true;
        let p2 = contentsStr.indexOf("*/");
        if (p2 > 0) {
          let firstLine = contentsStr.slice(0, p2);
          let p1 = firstLine.indexOf("(");
          let p22 = firstLine.indexOf(")");
          if (p1 > 0 && p22 > p1) {
            let tokens = firstLine.slice(p1 + 1, p22).split(" ");
            if (tokens.length > 0)
              esTarget = tokens[0];
            if (tokens.length > 1)
              readonlyVersion = tokens[1] != "full";
            if (tokens.length > 2)
              version = tokens[2];
          }
        }
        this._jsCodeinstances.push(new codeInstance(filename, esTarget, version, readonlyVersion));
      }
      await this.loadWebPagesList(filenameDesc);
      filenameDesc.style.display = "none";
      p.innerText = "What would you like to do ?";
      let uninstallLegend = document.createElement("span");
      uninstallLegend.innerText = "Uninstall / delete all Yocto-Visualization (for web) related files\n\n";
      this._uninstallOpt = document.createElement("input");
      this._uninstallOpt.setAttribute("type", "radio");
      this._uninstallOpt.setAttribute("name", "installType");
      this._modifyInstallPanel.appendChild(this._uninstallOpt);
      this._modifyInstallPanel.appendChild(uninstallLegend);
      let BuildsFound = {};
      for (let i = 0; i < this._jsCodeinstances.length; i++) {
        BuildsFound[this._jsCodeinstances[i].version] = 1;
      }
      let BuildsFoundList = "";
      for (let key in BuildsFound) {
        if (BuildsFound.hasOwnProperty(key)) {
          BuildsFoundList += (BuildsFoundList != "" ? ", " : "") + key;
        }
      }
      let updateLegend = document.createElement("span");
      updateLegend.innerText = "Update all from " + BuildsFoundList + " to " + constants.buildVersion + "\n\n";
      this._updateOpt = document.createElement("input");
      this._updateOpt.setAttribute("type", "radio");
      this._updateOpt.setAttribute("name", "installType");
      this._modifyInstallPanel.appendChild(this._updateOpt);
      this._modifyInstallPanel.appendChild(updateLegend);
      let addInstanceLegend = document.createElement("span");
      addInstanceLegend.innerText = "Add a new instance \n\n";
      this._addInstanceOpt = document.createElement("input");
      this._addInstanceOpt.setAttribute("type", "radio");
      this._addInstanceOpt.setAttribute("name", "installType");
      this._modifyInstallPanel.appendChild(this._addInstanceOpt);
      this._modifyInstallPanel.appendChild(addInstanceLegend);
      let modInstanceLegend = document.createElement("span");
      modInstanceLegend.innerText = "Modify or delete existing instances \n\n";
      this._modInstanceOpt = document.createElement("input");
      this._modInstanceOpt.setAttribute("type", "radio");
      this._modInstanceOpt.setAttribute("name", "installType");
      this._modifyInstallPanel.appendChild(this._modInstanceOpt);
      this._modifyInstallPanel.appendChild(modInstanceLegend);
      if (!this._uninstallOpt.checked && !this._updateOpt.checked && !this._addInstanceOpt.checked && !this._modInstanceOpt.checked) {
        this._updateOpt.checked = true;
      }
    }
    this._modifyInstallPanel.style.display = "";
    this._nextButton.enabled = true;
    this._prevButton.enabled = true;
    this._nextButton.visible = true;
    this._prevButton.visible = true;
    this._cancelButton.visible = this.DEFAULTCANCELABLE;
    let tabIndex = 1;
    this._uninstallOpt.tabIndex = tabIndex++;
    this._updateOpt.tabIndex = tabIndex++;
    this._addInstanceOpt.tabIndex = tabIndex++;
    this._modInstanceOpt.tabIndex = tabIndex++;
    this._prevButton.tabIndex = tabIndex++;
    this._nextButton.tabIndex = tabIndex++;
    this._nextButton.focus();
  }
  async showModInstancesPanel(visible, goingback) {
    if (!visible) {
      if (this._modInstancesPanel != null)
        this._modInstancesPanel.style.display = "none";
      return;
    }
    if (this._modInstancesPanel == null) {
      this._modInstancesPanel = this.createNewContentDiv();
      this._container.appendChild(this._modInstancesPanel);
    }
    let tabIndex = 1;
    if (!goingback) {
      this.removeAllChilds(this._modInstancesPanel);
      let p = document.createElement("P");
      this._modInstancesPanel.appendChild(p);
      p.innerText = "Here is a list of installed instances. Select an action for each one, then click on next to have them applied.";
      let table = document.createElement("Table");
      table.style.marginLeft = "20px";
      for (let i = 0; i < this._webPageinstances.length; i++) {
        let tr = document.createElement("TR");
        let td = document.createElement("TD");
        td.style.whiteSpace = "normal";
        td.innerText = this._webPageinstances[i].http_filename + (this._webPageinstances[i].compressed ? "[.gz]" : "");
        tr.appendChild(td);
        let td2 = document.createElement("TD");
        td2.style.whiteSpace = "normal";
        td2.style.paddingLeft = "10px";
        let chooser = document.createElement("SELECT");
        chooser.tabIndex = tabIndex++;
        let opt = document.createElement("OPTION");
        opt.tabIndex = tabIndex++;
        opt.text = "Do Nothing";
        opt.value = this._MODIFYNOTHING.toString();
        chooser.add(opt);
        let opt2 = document.createElement("OPTION");
        if (this._webPageinstances[i].compressed) {
          opt2.text = "Uncompress instance file";
          opt2.value = this._MODIFYUNCOMPRESS.toString();
        } else {
          opt2.text = "Compress instance file";
          opt2.value = this._MODIFYCOMPRESS.toString();
        }
        chooser.add(opt2);
        let opt3 = document.createElement("OPTION");
        if (this._webPageinstances[i].readonly) {
          opt3.text = "Allow read/write";
          opt3.value = this._MODIFYMAKEREADWRITE.toString();
        } else {
          opt3.text = "Make read only";
          opt3.value = this._MODIFYMAKEREADONLY.toString();
        }
        chooser.add(opt3);
        let opt4 = document.createElement("OPTION");
        if (this._webPageinstances[i].useMinified) {
          opt4.text = "Use human readable JS module";
          opt4.value = this._MODIFYUSEPLAIN.toString();
        } else {
          opt4.text = "Use minified JS module";
          opt4.value = this._MODIFYUSEMINIFIED.toString();
        }
        chooser.add(opt4);
        let opt5 = document.createElement("OPTION");
        opt5.text = "Delete (cannot be reverted)";
        opt5.value = this._MODIFYDELETE.toString();
        chooser.add(opt5);
        let index = i;
        chooser.addEventListener("change", () => {
          this._webPageinstances[index].action = Number(chooser.value);
        });
        td2.appendChild(chooser);
        tr.appendChild(td2);
        table.appendChild(tr);
      }
      this._modInstancesPanel.appendChild(table);
      let p2 = document.createElement("P");
      this._removeUnusedJs = document.createElement("INPUT");
      this._removeUnusedJs.tabIndex = tabIndex++;
      this._removeUnusedJs.type = "checkbox";
      this._removeUnusedJs.checked = true;
      p2.appendChild(this._removeUnusedJs);
      let span = document.createElement("SPAN");
      span.innerText = "Remove unused Yocto-Visualization (for web) JS module files";
      p2.appendChild(span);
      this._modInstancesPanel.appendChild(p2);
      this._prevButton.tabIndex = tabIndex++;
      this._nextButton.tabIndex = tabIndex++;
      this._nextButton.focus();
    }
    this._modInstancesPanel.style.display = "";
  }
  async showCustomFilesPanel(visible, goingback) {
    if (!visible) {
      if (this._customFilesPanel != null)
        this._customFilesPanel.style.display = "none";
      return;
    }
    if (this._customFilesPanel == null) {
      this._customFilesPanel = this.createNewContentDiv();
      this._container.appendChild(this._customFilesPanel);
    }
    if (!goingback) {
      this.removeAllChilds(this._customFilesPanel);
      let p = document.createElement("P");
      p.innerText = this._plannedaction == this.ACTIONINSTALL ? "Optionnaly, you can customize your Yocto-Visualization (for web) installation by providing some files" : "Optionnaly, you can customize your new instance by providing some files";
      this._customFilesPanel.appendChild(p);
      let Table = document.createElement("TABLE");
      Table.style.fontSize = "smaller";
      Table.style.marginTop = "20px";
      Table.style.marginBottom = "20px";
      let Row;
      let TD1;
      let TD2;
      Row = document.createElement("TR");
      TD1 = document.createElement("TD");
      TD1.style.whiteSpace = "normal";
      TD1.colSpan = 2;
      TD1.style.textAlign = "justify";
      TD1.innerText = 'You can choose an initial XML configuration file. You can get a XML configuration file from a Yocto-Visualization (for web) instance in the  "Global configulation" panel. You can also use a config.xml file from the Yocto-Visualization native version.';
      Row.appendChild(TD1);
      Table.appendChild(Row);
      Row = document.createElement("TR");
      TD1 = document.createElement("TD");
      TD1.style.whiteSpace = "normal";
      TD1.innerText = "Config file:";
      Row.appendChild(TD1);
      TD2 = document.createElement("TD");
      TD2.style.whiteSpace = "normal";
      this._configFileInput = document.createElement("INPUT");
      this._configFileInput.type = "file";
      this._configFileInput.accept = ".xml";
      TD2.appendChild(this._configFileInput);
      Row.style.marginBottom = "10px";
      Row.appendChild(TD2);
      Table.appendChild(Row);
      Row = document.createElement("TR");
      TD1 = document.createElement("TD");
      TD1.style.whiteSpace = "normal";
      TD1.colSpan = 2;
      TD1.style.textAlign = "justify";
      TD1.innerText = "\nYou can choose a container HTML file. Note: if this file relies on local dependencies such as images or CSS files, you'll have to upload them on the hub yourself.";
      Row.appendChild(TD1);
      Table.appendChild(Row);
      this._customFilesPanel.appendChild(Table);
      Row = document.createElement("TR");
      TD1 = document.createElement("TD");
      TD1.style.whiteSpace = "normal";
      TD1.innerText = "HTML file:";
      Row.appendChild(TD1);
      TD2 = document.createElement("TD");
      TD2.style.whiteSpace = "normal";
      this._webPageInput = document.createElement("INPUT");
      this._webPageInput.type = "file";
      this._webPageInput.accept = ".html";
      TD2.appendChild(this._webPageInput);
      Row.appendChild(TD2);
      Table.appendChild(Row);
    }
    this._customFilesPanel.style.display = "";
    this._nextButton.enabled = true;
    this._prevButton.enabled = true;
    this._nextButton.visible = true;
    this._prevButton.visible = true;
    this._cancelButton.visible = this.DEFAULTCANCELABLE;
    let tabIndex = 1;
    this._webPageInput.tabIndex = tabIndex++;
    this._configFileInput.tabIndex = tabIndex++;
    this._prevButton.tabIndex = tabIndex++;
    this._nextButton.tabIndex = tabIndex++;
    this._nextButton.focus();
  }
  async showOptionsPanel(visible, goingback) {
    if (!visible) {
      if (this._optionsPanel != null)
        this._optionsPanel.style.display = "none";
      return;
    }
    if (this._optionsPanel == null) {
      this._optionsPanel = this.createNewContentDiv();
      let p = document.createElement("P");
      p.innerText = this._plannedaction == this.ACTIONINSTALL ? "You can also customize the installation behavior" : "You can also customize this new instance behavior";
      this._optionsPanel.appendChild(p);
      p = document.createElement("P");
      p.style.fontSize = "smaller";
      p.style.marginBottom = "0px";
      p.style.marginTop = "0px";
      this._fileprefixInput = document.createElement("INPUT");
      let presetname = this.DEFAULTFILEPREFIX;
      let n = 1;
      let checkgain = false;
      do {
        checkgain = false;
        for (let i = 0; i < this._webPageinstances.length; i++) {
          if (presetname + this.TARGETEXTENSION == this._webPageinstances[i].http_filename) {
            n++;
            presetname = this.DEFAULTFILEPREFIX + "(" + n.toString() + ")";
            checkgain = true;
          }
        }
      } while (checkgain);
      this._fileprefixInput.value = presetname;
      this._fileprefixInput.maxLength = 10;
      this._fileprefixInput.size = 10;
      let span = document.createElement("SPAN");
      span.innerText = "Set the instance name to : ";
      p.appendChild(span);
      p.appendChild(this._fileprefixInput);
      this._optionsPanel.appendChild(p);
      p = document.createElement("P");
      p.style.fontSize = "smaller";
      p.style.marginBottom = "0px";
      p.style.marginTop = "0px";
      this._useFullVersionInput = document.createElement("INPUT");
      this._useFullVersionInput.type = "checkbox";
      p.appendChild(this._useFullVersionInput);
      span = document.createElement("SPAN");
      span.innerText = this._plannedaction == this.ACTIONINSTALL ? "Install the non-minified version (easier to debug)" : "Use the non-minified version (easier to debug)";
      p.appendChild(span);
      this._optionsPanel.appendChild(p);
      p = document.createElement("P");
      p.style.fontSize = "smaller";
      p.style.marginBottom = "0px";
      p.style.marginTop = "0px";
      this._makeDefaultInput = document.createElement("INPUT");
      this._makeDefaultInput.type = "checkbox";
      p.appendChild(this._makeDefaultInput);
      span = document.createElement("SPAN");
      span.innerText = this._plannedaction == this.ACTIONINSTALL ? "Make Yocto-Visualization (for web) the hub's default page" : "Make this instance the hub's default page";
      p.appendChild(span);
      this._optionsPanel.appendChild(p);
      p = document.createElement("P");
      p.style.fontSize = "smaller";
      p.style.marginBottom = "0px";
      p.style.marginTop = "0px";
      this._useReadOnlyInput = document.createElement("INPUT");
      this._useReadOnlyInput.type = "checkbox";
      p.appendChild(this._useReadOnlyInput);
      span = document.createElement("SPAN");
      span.innerText = this._plannedaction == this.ACTIONINSTALL ? "Make the install read-only" : "Make this instance read-only";
      p.appendChild(span);
      this._optionsPanel.appendChild(p);
      if (this._jsCodeinstances.length > 0) {
        this._useReadOnlyInput.checked = this._jsCodeinstances[0].readonly;
        this._useFullVersionInput.checked = !this._jsCodeinstances[0].minified;
      }
      p = document.createElement("P");
      p.innerText = 'Click on "Next" button to start the installation';
      this._optionsPanel.appendChild(p);
      this._container.appendChild(this._optionsPanel);
    }
    this._nextButton.visible = true;
    this._prevButton.visible = true;
    this._cancelButton.visible = this.DEFAULTCANCELABLE;
    this._optionsPanel.style.display = "";
    let tabIndex = 1;
    this._fileprefixInput.tabIndex = tabIndex++;
    this._useFullVersionInput.tabIndex = tabIndex++;
    this._makeDefaultInput.tabIndex = tabIndex++;
    this._useReadOnlyInput.tabIndex = tabIndex++;
    this._prevButton.tabIndex = tabIndex++;
    this._nextButton.tabIndex = tabIndex++;
    this._nextButton.focus();
  }
  logLine(line) {
    let p = document.createElement("P");
    p.innerText = line + " ";
    p.style.fontSize = "smaller";
    p.style.marginLeft = "10px";
    p.style.marginTop = "0px;";
    p.style.marginBottom = "0px;";
    p.style.paddingTop = "0px;";
    p.style.paddingBottom = "0px;";
    let span = document.createElement("SPAN");
    p.appendChild(span);
    this._runPanel.appendChild(p);
    return span;
  }
  async showRunPanel(visible, goingback) {
    if (!visible) {
      if (this._runPanel != null)
        this._runPanel.style.display = "none";
      return;
    }
    if (this._runPanel == null) {
      this._runPanel = this.createNewContentDiv();
    }
    this.removeAllChilds(this._runPanel);
    this._runPanel.style.display = "";
    let desc = document.createElement("P");
    this._runPanel.appendChild(desc);
    this._container.appendChild(this._runPanel);
    this._nextButton.visible = false;
    this._prevButton.visible = false;
    this._cancelButton.visible = false;
    switch (this._plannedaction) {
      case this.ACTIONINSTALL:
        desc.innerText = "Installing on " + this._currentHub_Addr + "... please wait.";
        try {
          await this.install((line) => {
            return this.logLine(line);
          });
        } catch (e) {
          this.gotoPanel(this.CONNECTIONERROR, "Installation failed with an internal error : " + e.toString() + "\n\nFeel free to contact Yoctopuce support.");
        }
        break;
      case this.ACTIONADDINSTANCE:
        desc.innerText = "Creating new instance  on " + this._currentHub_Addr + "... please wait.";
        try {
          await this.install((line) => {
            return this.logLine(line);
          });
        } catch (e) {
          this.gotoPanel(this.CONNECTIONERROR, "Instance creation failed with an internal error : " + e.toString() + "\n\nFeel free to contact Yoctopuce support.");
        }
        break;
      case this.ACTIONUNINSTALL:
        desc.innerText = "Uninstalling everything from " + this._currentHub_Addr + "... please wait.";
        try {
          await this.uninstall((line) => {
            return this.logLine(line);
          });
        } catch (e) {
          this.gotoPanel(this.CONNECTIONERROR, "Installation failed with an internal error : " + e.toString() + "\n\nFeel free to contact Yoctopuce support.");
        }
        break;
      case this.ACTIONUPDATE:
        desc.innerText = "Updating js files on " + this._currentHub_Addr + "... please wait.";
        try {
          await this.upgrade((line) => {
            return this.logLine(line);
          });
        } catch (e) {
          this.gotoPanel(this.CONNECTIONERROR, "Update failed with an internal error : " + e.toString() + "\n\nFeel free to contact Yoctopuce support.");
        }
        break;
      case this.ACTIONMODINSTANCE:
        desc.innerText = "Modifying instances on " + this._currentHub_Addr + "... please wait.";
        try {
          await this.modifyInstances((line) => {
            return this.logLine(line);
          });
        } catch (e) {
          this.gotoPanel(this.CONNECTIONERROR, "Instances modification failed with an internal error : " + e.toString() + "\n\nFeel free to contact Yoctopuce support.");
        }
        break;
    }
  }
  checkHTMLfile(htmlData, errmsg) {
    let upper = htmlData.toUpperCase();
    if (upper.indexOf("<HTML") < 0) {
      errmsg.msg = "Provided web page is not a proper HTML file: no HTML tag";
      return false;
    }
    if (upper.indexOf("</BODY>") < 0) {
      errmsg.msg = "Provided web page has an unexpected structure: no closing BODY tag";
      return false;
    }
    return true;
  }
  checkConfigfile(xmlData, errmsg) {
    let parser = new DOMParser();
    let doc = parser.parseFromString(xmlData, "application/xml");
    let root = null;
    doc.childNodes.forEach((node) => {
      if (node.nodeName.toUpperCase() == "ROOT" && root == null)
        root = node;
    });
    if (root == null) {
      errmsg.msg = "Provided config XML file is not a proper YoctoVisualization 2 config file. Unable to find ROOT node, either the root node does not exists or the file caused an XML parse error.";
      return false;
    }
    let rootNode = new YXmlNode(root);
    let attributes = rootNode.Attributes;
    if (!attributes.hasOwnProperty("version")) {
      errmsg.msg = "Provided  XML config file is not a proper Yocto-Visualization 2 config file (No ROOT Version attribute)";
      return false;
    }
    if (parseFloat(attributes["version"]) < 2) {
      errmsg.msg = "Provided XML config file is not a proper Yocto-Visualization 2 config file (at least Version 2.0 is required)";
      return false;
    }
    return true;
  }
  findChild(parent, name) {
    let res = null;
    parent.childNodes.forEach((node) => {
      if (node.nodeName == name) {
        res = node;
        return;
      }
    });
    return res;
  }
  patchConfigFile(xmlData) {
    let startTag = "<Hubs>";
    let endTag = "</Hubs>";
    let parser = new DOMParser();
    let doc = parser.parseFromString(xmlData, "application/xml");
    let rootNode = this.findChild(doc, "ROOT");
    if (rootNode == null)
      throw "No root node in config file.";
    let configNode = this.findChild(rootNode, "Config");
    if (configNode == null)
      throw "No config node in config file.";
    let Hubs = this.findChild(configNode, "Hubs");
    let HubSection;
    if (Hubs == null) {
      HubSection = startTag + "\n" + this.getHubConfig() + "\n" + endTag + "\n";
      xmlData = xmlData.replace("<Config>", "<Config>\n" + HubSection);
    } else {
      let list = Hubs.childNodes;
      let sourceHubFound = false;
      HubSection = startTag + "\n";
      for (let i = 0; i < list.length; i++) {
        if (list[i].nodeName == "Hub") {
          let node = new YXmlNode(list[i]);
          let attributes = node.Attributes;
          let addr = attributes.hasOwnProperty("addr") ? attributes["addr"] : "";
          let port = attributes.hasOwnProperty("port") ? attributes["port"] : "80";
          let protocol = attributes.hasOwnProperty("protocol") ? attributes["protocol"] : "";
          let path = attributes.hasOwnProperty("path") ? attributes["path"] : "";
          let username = attributes.hasOwnProperty("user") ? attributes["user"] : "";
          let password = attributes.hasOwnProperty("password") ? attributes["password"] : "";
          if (!sourceHubFound && addr == this._currentHub_Addr && port == this._currentHub_port && path == this._currentHub_path) {
            sourceHubFound = true;
            HubSection += "    " + this.getHubConfig() + "\n";
          } else {
            HubSection += "    " + this.createHubRecord(protocol, addr, port, path, username, password, true) + "\n";
          }
        }
      }
      if (!sourceHubFound)
        HubSection += "    " + this.getHubConfig() + "\n";
      HubSection += "  ";
      let indexStart = xmlData.indexOf(startTag);
      let indexStop = xmlData.indexOf(endTag);
      if (indexStart < 0)
        throw "Cannot locate Hubs start tag in provided  config file";
      if (indexStop < 0)
        throw "Cannot locate Hubs end tag in provided  config file";
      xmlData = xmlData.substr(0, indexStart) + HubSection + xmlData.substr(indexStop);
    }
    return xmlData;
  }
  createHubRecord(protocol, addr, port, path, username, password, removable) {
    let res = '<Hub protocol="' + constants.XMLquote(protocol) + '" addr="' + constants.XMLquote(addr) + '" port="' + constants.XMLquote(port) + '"';
    if (path != "")
      res += ' path="' + constants.XMLquote(path) + '"';
    if (username != "")
      res += ' user="' + constants.XMLquote(username) + '"';
    if (password != "")
      res += ' password="' + constants.XMLquote(password) + '"';
    if (!removable)
      res += ' removable="FALSE"';
    res += "/>";
    return res;
  }
  getHubConfig() {
    let username = "";
    let password = "";
    if (this._currentHub_ReadOnlyProtected) {
      username = this._userNameInput.value;
      password = Hub.encryptPassword(this._userPasswordInput.value);
    }
    return this.createHubRecord(this._currentHub_protocol, this._currentHub_Addr, this._currentHub_port, this._currentHub_path, username, password, false);
  }
  getSeedCode(configfile, readonly, minified) {
    let res = '\n<script type="module">\n';
    if (configfile == null)
      configfile = '<?xml version="1.0" ?><ROOT version="2.1"><Config><Hubs>' + this.getHubConfig() + "</Hubs></Config></ROOT>\n";
    let filename = "yv4web-" + (readonly ? "readonly" : "full") + (minified ? ".min" : "") + ".js";
    res += ' import { YWebPage, YoctoHubFileHandler }  from "./' + filename + '";\n';
    res += " window.runYV= async ()=>{";
    res += " let filehandler = await YoctoHubFileHandler.start(";
    if (configfile != null)
      res += JSON.stringify(configfile);
    res += ");\n";
    res += "  YWebPage.run(filehandler.xmlConfigData, filehandler.configChangeCallbackFct";
    if (!readonly)
      res += ",filehandler.saveFct";
    res += ");\n";
    res += "};\n window.runYV();</script>\n";
    res += '<script nomodule="">\n';
    res += `document.write("<p style='font-family: sans-serif; text-align:center'>Yocto-Visualization (for web) cannot run on this browser. Sorry.<br>Consider using a more recent browser, or <a href='https://www.yoctopuce.com/EN/tools.php'>the native version</a>. </p>")
`;
    res += "</script>\n";
    return res;
  }
  defaultHTMLfile(configfile, readonly, minified) {
    return "<!DOCTYPE HTML>\n<HTML lang='en-US'><HEAD>\n<title>\nYocto-Visualization</title>\n" + this.icon + "\n<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no'/></HEAD>\n<BODY>\n</BODY>" + this.getSeedCode(configfile, readonly, minified) + "\n</HTML>\n";
  }
  async uploadWidthProgress(str_path, bin_content, progress) {
    let yreq = await this._currentfs._uploadWithProgress(str_path, bin_content, progress);
    return yreq.errorType;
  }
  async upgrade(log) {
    let install_minified_readonly = false;
    let install_plain_readonly = false;
    let install_minified_readwrite = false;
    let install_plain_readwrite = false;
    for (let i = 0; i < this._jsCodeinstances.length; i++) {
      if (this._jsCodeinstances[i].minified) {
        if (this._jsCodeinstances[i].readonly) {
          install_minified_readonly = true;
        } else {
          install_minified_readwrite = true;
        }
      } else {
        if (this._jsCodeinstances[i].readonly) {
          install_plain_readonly = true;
        } else {
          install_plain_readwrite = true;
        }
      }
    }
    if (install_minified_readonly)
      await this.copyJsCode(log, true, true);
    if (install_plain_readonly)
      await this.copyJsCode(log, true, false);
    if (install_minified_readwrite)
      await this.copyJsCode(log, false, true);
    if (install_plain_readwrite)
      await this.copyJsCode(log, false, false);
    log("Done.");
    setTimeout(() => {
      this.gotoPanel(this.DONEPANEL);
    }, 2e3);
  }
  async syncJsFile(log, required, readonly, minified, removeunused) {
    let jsfile = this.get_js_filename(readonly, minified) + ".gz";
    let exists = await this._currentfs.fileExist(jsfile);
    if (required && !exists)
      await this.copyJsCode(log, readonly, minified);
    if (!required && exists && removeunused) {
      let span = log("Deleting " + jsfile);
      await this._currentfs.remove(jsfile);
      span.innerText = "done.";
    }
  }
  async syncJsFileVersions(log, removeunused) {
    let require_minified_readonly = false;
    let require_plain_readonly = false;
    let require_minified_readwrite = false;
    let require_plain_readwrite = false;
    for (let i = 0; i < this._webPageinstances.length; i++) {
      if (this._webPageinstances[i].useMinified) {
        if (this._webPageinstances[i].readonly) {
          require_minified_readonly = true;
        } else {
          require_minified_readwrite = true;
        }
      } else {
        if (this._webPageinstances[i].readonly) {
          require_plain_readonly = true;
        } else {
          require_plain_readwrite = true;
        }
      }
    }
    await this.syncJsFile(log, require_minified_readonly, true, true, removeunused);
    await this.syncJsFile(log, require_plain_readonly, true, false, removeunused);
    await this.syncJsFile(log, require_minified_readwrite, false, true, removeunused);
    await this.syncJsFile(log, require_plain_readwrite, false, false, removeunused);
  }
  async patchPageInstance(log, page, signature1, replace1, altsignature1, altreplace1, signature2, replace2) {
    let contents = YAPI.imm_bin2str(page.contents);
    let p = contents.indexOf(signature1);
    if (p < 0 && altsignature1 != "") {
      signature1 = altsignature1;
      replace1 = altreplace1;
      p = contents.indexOf(signature1);
    }
    if (p < 0)
      throw "Operation failed: cannot find the [" + signature1 + "] import signature in " + page.fs_filename;
    contents = contents.substr(0, p) + replace1 + contents.substr(p + signature1.length);
    if (signature2 != "") {
      p = contents.indexOf(signature2);
      if (p < 0)
        throw "Operation failed: cannot find the [" + signature2 + "] signature parameter in " + page.fs_filename;
      contents = contents.substr(0, p) + replace2 + contents.substr(p + signature2.length);
    }
    let bincontents = YAPI.imm_str2bin(contents);
    let filename = page.fs_filename;
    if (page.compressed) {
      let status2 = log("Compressing  " + filename);
      bincontents = Pako_Deflate.gzip(bincontents, {level: 9});
      status2.innerText = "done";
    }
    let status = log("Uploading  " + filename + " to hub");
    status.innerText = "0%";
    let success = await this.uploadWidthProgress(filename, bincontents, (curr, total) => {
      status.innerText = Math.round(100 * curr / total).toString() + "%";
    });
    status.innerText = "done";
    if (success != YAPI_SUCCESS)
      throw "Upload failed (Error" + success.toString() + ").";
  }
  async modifyInstances(log) {
    for (let i = 0; i < this._webPageinstances.length; i++) {
      switch (this._webPageinstances[i].action) {
        case this._MODIFYNOTHING:
          break;
        case this._MODIFYDELETE:
          let span = log("Deleting " + this._webPageinstances[i].fs_filename);
          await this._currentfs.remove(this._webPageinstances[i].fs_filename);
          span.innerText = "done.";
          break;
        case this._MODIFYUNCOMPRESS:
          {
            let filename = this._webPageinstances[i].http_filename;
            let status = log("Uploading  " + filename + " to hub");
            status.innerText = "0%";
            let success = await this.uploadWidthProgress(filename, this._webPageinstances[i].contents, (curr, total) => {
              status.innerText = Math.round(100 * curr / total).toString() + "%";
            });
            status.innerText = "done";
            if (success != YAPI_SUCCESS)
              throw "Upload failed! (Error" + success.toString() + ")";
            status = log("Deleting " + this._webPageinstances[i].fs_filename);
            await this._currentfs.remove(this._webPageinstances[i].fs_filename);
            status.innerText = "done.";
          }
          break;
        case this._MODIFYCOMPRESS:
          {
            let filename = this._webPageinstances[i].http_filename + ".gz";
            let status = log("Compressing  " + filename);
            let GZ_data = Pako_Deflate.gzip(this._webPageinstances[i].contents, {level: 9});
            status.innerText = "done";
            status = log("Uploading  " + filename + " to hub");
            status.innerText = "0%";
            let success = await this.uploadWidthProgress(filename, GZ_data, (curr, total) => {
              status.innerText = Math.round(100 * curr / total).toString() + "%";
            });
            status.innerText = "done";
            if (success != YAPI_SUCCESS)
              throw "Upload failed!! (Error" + success.toString() + ")";
            status = log("Deleting " + this._webPageinstances[i].http_filename);
            await this._currentfs.remove(this._webPageinstances[i].http_filename);
            status.innerText = "done.";
          }
          break;
        case this._MODIFYMAKEREADONLY:
          await this.patchPageInstance(log, this._webPageinstances[i], 'from "./yv4web-full', 'from "./yv4web-readonly', "", "", ",filehandler.saveFct);", ");");
          this._webPageinstances[i].readonly = true;
          break;
        case this._MODIFYMAKEREADWRITE:
          await this.patchPageInstance(log, this._webPageinstances[i], 'from "./yv4web-readonly', 'from "./yv4web-full', "", "", "filehandler.configChangeCallbackFct);", "filehandler.configChangeCallbackFct,filehandler.saveFct);");
          this._webPageinstances[i].readonly = false;
          break;
        case this._MODIFYUSEPLAIN:
          await this.patchPageInstance(log, this._webPageinstances[i], '"./yv4web-full.min.js"', '"./yv4web-full.js"', '"./yv4web-readonly.min.js"', '"./yv4web-readonly.js"', "", "");
          this._webPageinstances[i].useMinified = false;
          break;
        case this._MODIFYUSEMINIFIED:
          await this.patchPageInstance(log, this._webPageinstances[i], '"./yv4web-full.js"', '"./yv4web-full.min.js"', '"./yv4web-readonly.js"', '"./yv4web-readonly.min.js"', "", "");
          this._webPageinstances[i].useMinified = true;
          break;
      }
    }
    await this.syncJsFileVersions(log, this._removeUnusedJs.checked);
    log("Done.");
    setTimeout(() => {
      this.gotoPanel(this.DONEPANEL);
    }, 2e3);
  }
  async uninstall(log) {
    for (let i = 0; i < this._jsCodeinstances.length; i++) {
      let filename = this._jsCodeinstances[i].filename;
      log("Deleteting " + filename);
      await this._currentfs.remove(filename);
    }
    let network = await YNetwork.FindNetwork(await this._currentHub.get_serialNumber() + ".network");
    let startPage = await network.get_defaultPage();
    let mustResetStartPage = false;
    for (let i = 0; i < this._webPageinstances.length; i++) {
      let filename = this._webPageinstances[i].fs_filename;
      if (startPage == this._webPageinstances[i].http_filename)
        mustResetStartPage = true;
      log("Deleteting " + filename);
      await this._currentfs.remove(filename);
    }
    if (mustResetStartPage) {
      log("Setting default page to index.html");
      await network.set_defaultPage("");
      await this._currentHub.saveToFlash();
    }
    log("Done.");
    setTimeout(() => {
      this.gotoPanel(this.DONEPANEL);
    }, 2e3);
  }
  get_js_filename(readonly, minified) {
    return "yv4web-" + (readonly ? "readonly" : "full") + (minified ? ".min" : "") + ".js";
  }
  get_js_blob(readonly, minified) {
    let data;
    if (readonly) {
      data = minified ? BinariesBlobs.ro_minjs : BinariesBlobs.ro_js;
    } else {
      data = minified ? BinariesBlobs.rw_minjs : BinariesBlobs.rw_js;
    }
    if (data == "")
      return null;
    return YAPI.imm_str2bin(atob(data));
  }
  async copyJsCode(log, readonly, minified) {
    let currentURL = window.location.href;
    let filename = currentURL.split("/").pop().split("#")[0].split("?")[0];
    let jsfile = this.get_js_filename(readonly, minified);
    let GZ_data = this.get_js_blob(readonly, minified);
    let status;
    if (GZ_data == null) {
      status = log("Downloading " + jsfile + " module from server..");
      let jsfileURL = currentURL.replace(filename, "../../dist/" + this.ESVersion + "/" + jsfile);
      let result;
      result = await YoctoHubFileHandler.makeRequest("GET", jsfileURL);
      if (result.data == null) {
        let err = "Installation Failed: cannot download the Yocto-Visualization file from the serveur serving this installer.\n\nError was : " + result.statusText + "\n\nURL was: " + jsfileURL;
        this.gotoPanel(this.CONNECTIONERROR, err);
        return;
      }
      status.innerText = "done.";
      status = log("Compressing JS Module..");
      GZ_data = Pako_Deflate.gzip(result.data, {level: 9});
      status.innerText = "done.";
    }
    status = log("Copying JS Module to hub..");
    status.innerText = "0%";
    let success = await this.uploadWidthProgress(jsfile + ".gz", GZ_data, (curr, total) => {
      status.innerText = Math.round(100 * curr / total).toString() + "%";
    });
    if (success != YAPI_SUCCESS)
      throw "Upload failed. (Error" + success.toString() + ").";
    status.innerText = "done.";
  }
  async install(log) {
    let configFile = await this.loadLocalFile(this._configFileInput);
    if (configFile != null) {
      configFile = configFile.replace("<!-->", "<!-- ");
      let err = new YErrorMsg();
      if (!this.checkConfigfile(configFile, err)) {
        this.gotoPanel(this.CONNECTIONERROR, "Installation failed\n\n" + err.msg);
        return;
      }
      let index = configFile.toUpperCase().indexOf("</ROOT");
      if (index < 0)
        this.gotoPanel(this.CONNECTIONERROR, "Installation failed\n\nunable to find ROOT closing tag in provided config file");
      configFile = configFile.substring(0, index) + "</ROOT>\n";
      configFile = this.patchConfigFile(configFile);
    }
    let htmlFile = await this.loadLocalFile(this._webPageInput);
    if (htmlFile != null) {
      let err = new YErrorMsg();
      if (!this.checkHTMLfile(htmlFile, err)) {
        this.gotoPanel(this.CONNECTIONERROR, "Installation failed\n\n" + err.msg);
        return;
      }
    }
    let status;
    let GZ_data;
    let success;
    let readonly = this._useReadOnlyInput.checked;
    let minified = !this._useFullVersionInput.checked;
    let mustInstallJsCode = this._plannedaction == this.ACTIONINSTALL;
    if (this._plannedaction == this.ACTIONADDINSTANCE) {
      mustInstallJsCode = true;
      for (let i = 0; i < this._jsCodeinstances.length; i++) {
        if (this._jsCodeinstances[i].minified == minified && this._jsCodeinstances[i].readonly == readonly) {
          mustInstallJsCode = false;
        }
      }
    }
    if (mustInstallJsCode)
      await this.copyJsCode(log, readonly, minified);
    status = log("Creating HTML file..");
    let targetHTMLfile;
    if (htmlFile != null) {
      let index = htmlFile.toUpperCase().indexOf("</BODY>");
      let tag = htmlFile.substr(index, 7);
      targetHTMLfile = htmlFile.replace(tag, tag + this.getSeedCode(configFile, readonly, minified));
    } else {
      targetHTMLfile = this.defaultHTMLfile(configFile, readonly, minified);
    }
    status = log("Compressing  HTML file..");
    GZ_data = Pako_Deflate.gzip(YAPI.imm_str2bin(targetHTMLfile), {level: 9});
    status.innerText = "done.";
    status = log("Saving HTML file on hub");
    let targetFile = this._fileprefixInput.value + this.TARGETEXTENSION;
    status.innerText = "0%";
    success = await this.uploadWidthProgress(targetFile + ".gz", GZ_data, (curr, total) => {
      status.innerText = Math.round(100 * curr / total).toString() + "%";
    });
    if (success != YAPI_SUCCESS)
      throw "Upload failed (Error" + success.toString() + ")";
    status.innerText = "done.";
    status = log("Configuring hub");
    let url = this._currentHubLink_protocol + "://" + this._applicationURL;
    let network = await YNetwork.FindNetwork(await this._currentHub.get_serialNumber() + ".network");
    if (this._makeDefaultInput.checked) {
      await network.set_defaultPage(targetFile);
    } else {
      if (await network.get_defaultPage() == targetFile)
        await network.set_defaultPage("");
      url += "/" + targetFile;
    }
    let warning = "";
    if (readonly && configFile == null)
      warning = "However, since you chose to install the read-only version without any configuration file, your install is probably useless.";
    await YAPI.UnregisterHub(await this._currentHub.get_url());
    status.innerText = "done.";
    this._warning = warning;
    this._finalURL = url;
    setTimeout(() => {
      this.gotoPanel(this.DONEPANEL);
    }, 2e3);
  }
  removeAllChilds(element) {
    while (element.firstChild) {
      element.removeChild(element.firstChild);
    }
  }
  async showConfirmUninstallPanel(visible, goingback) {
    if (!visible) {
      if (this._confirmUninstallPanel != null)
        this._confirmUninstallPanel.style.display = "none";
      return;
    }
    if (this._confirmUninstallPanel == null) {
      this._confirmUninstallPanel = this.createNewContentDiv();
      this._container.appendChild(this._confirmUninstallPanel);
    }
    if (!goingback) {
      this.removeAllChilds(this._confirmUninstallPanel);
      let p = document.createElement("P");
      p.innerText = "You are about to remove all files related to Yocto-Visualization (for web)  from hub " + this._currentHub_Addr + ", including instances that probably took you quite some time to configure. Are you sure you want to click on Next and start uninstallation? You will not be able to revert this operation.\n\n";
      this._confirmUninstallPanel.appendChild(p);
      this._confirmUninstall = document.createElement("input");
      this._confirmUninstall.type = "checkbox";
      let bt = this._nextButton;
      this._confirmUninstall.addEventListener("change", function() {
        bt.enabled = this.checked;
      });
      this._confirmUninstallPanel.appendChild(this._confirmUninstall);
      let txt = document.createElement("span");
      txt.innerText = "Yes, I know what I am doing.";
      this._confirmUninstallPanel.appendChild(txt);
    }
    this._confirmUninstallPanel.style.display = "";
    this._nextButton.visible = true;
    this._nextButton.enabled = this._confirmUninstall.checked;
    this._prevButton.visible = true;
    this._cancelButton.visible = this.DEFAULTCANCELABLE;
    let tabIndex = 1;
    this._confirmUninstall.tabIndex = tabIndex++;
    this._prevButton.tabIndex = tabIndex++;
    this._nextButton.tabIndex = tabIndex++;
    this._confirmUninstall.focus();
  }
  async showDonePanel(visible, goingback) {
    if (!visible) {
      if (this._donePanel != null)
        this._donePanel.style.display = "none";
      return;
    }
    if (this._donePanel == null) {
      this._donePanel = this.createNewContentDiv();
      let Table = document.createElement("TABLE");
      let Row = document.createElement("TR");
      let TD1 = document.createElement("TD");
      TD1.style.whiteSpace = "normal";
      TD1.innerHTML = ressources.OkIcon("64", true, false, false, false, "youpi!");
      Row.appendChild(TD1);
      this._doneMsgContainer = document.createElement("TD");
      Row.appendChild(this._doneMsgContainer);
      Table.appendChild(Row);
      this._donePanel.appendChild(Table);
      this._container.appendChild(this._donePanel);
    }
    this.removeAllChilds(this._doneMsgContainer);
    let p = document.createElement("P");
    p.style.whiteSpace = "normal";
    switch (this._plannedaction) {
      case this.ACTIONADDINSTANCE:
      case this.ACTIONINSTALL:
        p.innerText = this._plannedaction == this.ACTIONINSTALL ? "Installation sucessfully completed. Application can be accessed through the following URL:" : "New instance sucessfully completed, it can be accessed through the following URL:";
        this._doneMsgContainer.appendChild(p);
        let url = document.createElement("A");
        url.innerText = this._finalURL;
        url.style.cursor = "pointer";
        url.style.color = "#0000EE";
        url.style.textDecoration = "underline";
        url.addEventListener("click", () => {
          if (top)
            top.location.assign(this._finalURL);
        });
        this._doneMsgContainer.appendChild(url);
        if (this._warning != "") {
          p = document.createElement("P");
          p.innerText = this._warning;
          this._doneMsgContainer.appendChild(p);
        }
        break;
      case this.ACTIONUNINSTALL:
        p.innerText = "Files sucessfully removed.";
        this._doneMsgContainer.appendChild(p);
        break;
      case this.ACTIONUPDATE:
        p.innerText = "JS Files sucessfully updated.";
        this._doneMsgContainer.appendChild(p);
        break;
      case this.ACTIONMODINSTANCE:
        p.innerText = "Instances modifications done";
        this._doneMsgContainer.appendChild(p);
        break;
    }
    p = document.createElement("P");
    this._cancelButton.visible = this.DEFAULTCANCELABLE;
    p.innerText = this.DEFAULTCANCELABLE ? 'Click on the "Ok" button to close the wizard' : 'Click on the "Ok" button to restart the wizard';
    this._doneMsgContainer.appendChild(p);
    this.removeCurrentPanelFromHistory();
    this._nextButton.visible = false;
    this._prevButton.visible = false;
    this._cancelButton.visible = false;
    this._okButton.visible = true;
    this._donePanel.style.display = "";
    let tabIndex = 1;
    this._okButton.tabIndex = tabIndex++;
    this._okButton.focus();
  }
  showCurrentStep(back, msg) {
    this.showWelcomePanel(this._currentStep == this.WELCOMEPANEL, back);
    this.showEnterHubAddr(this._currentStep == this.ENTERHUBADDR, back);
    this.showConnectingPanel(this._currentStep == this.CONNECTINGPANEL, back);
    this.showConnectionError(this._currentStep == this.CONNECTIONERROR, back, msg);
    this.showPasswordPanel(this._currentStep == this.PASSWORDPANEL, back, msg);
    this.showHubDescription(this._currentStep == this.DESCRIPTIONPANEL, back);
    this.showCustomFilesPanel(this._currentStep == this.CUSTOMFILESPANEL, back);
    this.showOptionsPanel(this._currentStep == this.OPTIONSPANEL, back);
    this.showRunPanel(this._currentStep == this.RUNPANEL, back);
    this.showDonePanel(this._currentStep == this.DONEPANEL, back);
    this.showModifyInstallPanel(this._currentStep == this.MODIFYINSTALLPANEL, back);
    this.showConfirmUninstallPanel(this._currentStep == this.CONFIRMUNINSTALLPANEL, back);
    this.showModInstancesPanel(this._currentStep == this.MODINSTANCESPANEL, back);
  }
  gotoPrevious() {
    if (this._history.length > 1) {
      this._history.pop();
      this._currentStep = this._history[this._history.length - 1];
    }
    this.showCurrentStep(true);
  }
  gotoPanel(step, errmsg) {
    this._currentStep = step;
    this._prevButton.visible = step > 0;
    this._history.push(step);
    this.showCurrentStep(false, errmsg);
  }
  async resetAll() {
    this._currentStep = this.WELCOMEPANEL;
    this._history = [this.WELCOMEPANEL];
    this._alreadyInstalled = false;
    this._prevButton.visible = false;
    this._nextButton.visible = true;
    this._okButton.visible = false;
    this._cancelButton.visible = this.DEFAULTCANCELABLE;
    this._jsCodeinstances = [];
    this._webPageinstances = [];
    await YAPI.UnregisterHub(await this._currentHub.get_url());
    await YAPI.FreeAPI();
    this._currentHub = null;
    this.showCurrentStep(false);
  }
  gotoNext() {
    switch (this._currentStep) {
      case this.WELCOMEPANEL:
        this.gotoPanel(this.ENTERHUBADDR);
        break;
      case this.ENTERHUBADDR:
        this.gotoPanel(this.CONNECTINGPANEL);
        break;
      case this.PASSWORDPANEL:
        this.gotoPanel(this.CONNECTINGPANEL);
        break;
      case this.DESCRIPTIONPANEL:
        if (this._alreadyInstalled) {
          this.gotoPanel(this.MODIFYINSTALLPANEL);
        } else {
          this._plannedaction = this.ACTIONINSTALL;
          this.gotoPanel(this.CUSTOMFILESPANEL);
        }
        break;
      case this.CUSTOMFILESPANEL:
        this.gotoPanel(this.OPTIONSPANEL);
        break;
      case this.OPTIONSPANEL:
        this.gotoPanel(this.RUNPANEL);
        break;
      case this.MODIFYINSTALLPANEL:
        if (this._uninstallOpt.checked)
          this.gotoPanel(this.CONFIRMUNINSTALLPANEL);
        if (this._addInstanceOpt.checked) {
          this._plannedaction = this.ACTIONADDINSTANCE;
          this.gotoPanel(this.CUSTOMFILESPANEL);
        }
        if (this._updateOpt.checked) {
          this._plannedaction = this.ACTIONUPDATE;
          this.gotoPanel(this.RUNPANEL);
        }
        if (this._modInstanceOpt.checked) {
          this._plannedaction = this.ACTIONMODINSTANCE;
          this.gotoPanel(this.MODINSTANCESPANEL);
        }
        break;
      case this.MODINSTANCESPANEL:
        this.gotoPanel(this.RUNPANEL);
        break;
      case this.CONFIRMUNINSTALLPANEL:
        this._plannedaction = this.ACTIONUNINSTALL;
        this.gotoPanel(this.RUNPANEL);
        break;
    }
  }
};
YV4W_installer.HTTP = "http";
YV4W_installer.HTTPS = "https";
window.startYV4W_installer = (div, options) => {
  new YV4W_installer(div, options);
};
export {
  YV4W_installer
};
//# sourceMappingURL=yv4w-installer.js.map
