/* Yocto-Visualization-4web installer (version 1.11.10214) - www.yoctopuce.com */

// obj/full/Renderer/YDataRendererCommon.js
var Vector3 = class _Vector3 {
  constructor(a, b, c) {
    this.a = a;
    this.b = b;
    this.c = c;
  }
  static FromXYCoord(x, y) {
    return new _Vector3(x, y, 1);
  }
  multiplyByM(m) {
    return new _Vector3(m.a * this.a + m.b * this.b + m.c * this.c, m.d * this.a + m.e * this.b + m.f * this.c, m.g * this.a + m.h * this.b + m.i * this.c);
  }
  multiplyByN(n) {
    return new _Vector3(this.a * n, this.b * n, this.c * n);
  }
  AddV(v) {
    return new _Vector3(this.a + v.a, this.b + v.b, this.c + v.c);
  }
  SubstractV(v) {
    return new _Vector3(this.a - v.a, this.b - v.b, this.c - v.c);
  }
  toPointF() {
    return new PointF(this.a, this.b);
  }
  toPoint() {
    return new Point(this.a, this.b);
  }
};
var Matrix3x3 = class _Matrix3x3 {
  // don't use the constructor directly but newMatrix, newTranslateMatrix, newRotateMatrix etc...
  constructor(a, b, c, d, e, f, g, h, i, flags) {
    this.a = a;
    this.b = b;
    this.c = c;
    this.d = d;
    this.e = e;
    this.f = f;
    this.g = g;
    this.h = h;
    this.i = i;
    if (b == 0 && d == 0 && a == 1 && e == 1 && i == 1 && g == 0 && h == 0) {
      flags |= _Matrix3x3.Flag_TRANSLATION;
      if (c == 0 && f == 0)
        flags |= _Matrix3x3.Flag_IDENTITY;
    }
    this.isTranslation = (flags & _Matrix3x3.Flag_TRANSLATION) != 0;
    this.isIdentity = (flags & _Matrix3x3.Flag_IDENTITY) != 0;
  }
  clone() {
    let flag = 0;
    if (this.isTranslation)
      flag |= _Matrix3x3.Flag_TRANSLATION;
    if (this.isIdentity)
      flag |= _Matrix3x3.Flag_IDENTITY;
    return new _Matrix3x3(this.a, this.b, this.c, this.d, this.e, this.f, this.g, this.h, this.i, flag);
  }
  get determinant() {
    let detA = this.e * this.i - this.h * this.f;
    let detB = this.d * this.i - this.g * this.f;
    let detC = this.d * this.h - this.g * this.e;
    return this.a * detA + -this.b * detB + this.c * detC;
  }
  get transpose() {
    if (this.isIdentity)
      return _Matrix3x3.newIdentityMatrix();
    return new _Matrix3x3(this.a, this.d, this.g, this.b, this.e, this.h, this.c, this.f, this.i, _Matrix3x3.Flag_NONE);
  }
  multiplyByV(v) {
    if (this.isTranslation)
      return new Vector3(this.c + v.a, this.f + v.b, 1);
    return new Vector3(this.a * v.a + this.b * v.b + this.c * v.c, this.d * v.a + this.e * v.b + this.f * v.c, this.g * v.a + this.h * v.b + this.i * v.c);
  }
  static newMatrix(a, b, c, d, e, f, g, h, i) {
    return new _Matrix3x3(a, b, c, d, e, f, g, h, i, _Matrix3x3.Flag_NONE);
  }
  static newTranslateMatrix(offsetX, offsetY) {
    let flag = _Matrix3x3.Flag_TRANSLATION;
    if (offsetX == 0 && offsetY == 0)
      flag |= _Matrix3x3.Flag_IDENTITY;
    return new _Matrix3x3(1, 0, offsetX, 0, 1, offsetY, 0, 0, 1, flag);
  }
  static newRotateMatrix(AngleDeg) {
    AngleDeg = Math.PI * AngleDeg / 180;
    return new _Matrix3x3(Math.cos(AngleDeg), -Math.sin(AngleDeg), 0, Math.sin(AngleDeg), -Math.cos(AngleDeg), 0, 0, 0, 1, _Matrix3x3.Flag_NONE);
  }
  static newScaleMatrix(Coef) {
    return new _Matrix3x3(Coef, 0, 0, 0, Coef, 0, 0, 0, 1, _Matrix3x3.Flag_NONE);
  }
  static newIdentityMatrix() {
    return new _Matrix3x3(1, 0, 0, 0, 1, 0, 0, 0, 1, _Matrix3x3.Flag_IDENTITY | _Matrix3x3.Flag_TRANSLATION);
  }
  toCSS() {
    return "matrix(" + this.a.toString() + "," + this.d.toString() + "," + this.b.toString() + "," + this.e.toString() + "," + this.c.toString() + "," + this.f.toString() + ")";
  }
  toString() {
    return "| " + this.a.toFixed(2) + " " + this.b.toFixed(2) + " " + this.c.toFixed(2) + " |" + (this.isIdentity ? " I" : "") + "\n| " + this.d.toFixed(2) + " " + this.e.toFixed(2) + " " + this.f.toFixed(2) + " |" + (this.isTranslation ? " T" : "") + "\n| " + this.g.toFixed(2) + " " + this.g.toFixed(2) + " " + this.i.toFixed(2) + " |\n";
  }
  multiplyByM(m) {
    if (this.isIdentity)
      return m.clone();
    if (m.isIdentity)
      return this.clone();
    if (this.isTranslation && m.isTranslation)
      return _Matrix3x3.newTranslateMatrix(this.c + m.c, this.f + m.f);
    return new _Matrix3x3(this.a * m.a + this.b * m.d + this.c * m.g, this.a * m.b + this.b * m.e + this.c * m.h, this.a * m.c + this.b * m.f + this.c * m.i, this.d * m.a + this.e * m.d + this.f * m.g, this.d * m.b + this.e * m.e + this.f * m.h, this.d * m.c + this.e * m.f + this.f * m.i, this.g * m.a + this.h * m.d + this.i * m.g, this.g * m.b + this.h * m.e + this.i * m.h, this.g * m.c + this.h * m.f + this.i * m.i, _Matrix3x3.Flag_NONE);
  }
  get inverse() {
    if (this.isIdentity)
      return _Matrix3x3.newIdentityMatrix();
    if (this.isTranslation)
      return _Matrix3x3.newTranslateMatrix(-this.c, -this.f);
    let det = this.determinant;
    if (det == 0)
      throw "matrix cannot be inverted";
    let detA = this.e * this.i - this.f * this.h;
    let detB = this.b * this.i - this.c * this.h;
    let detC = this.b * this.f - this.c * this.e;
    let detD = this.d * this.i - this.f * this.g;
    let detE = this.a * this.i - this.c * this.g;
    let detF = this.a * this.f - this.c * this.d;
    let detG = this.d * this.h - this.e * this.g;
    let detH = this.a * this.h - this.b * this.g;
    let detI = this.a * this.e - this.b * this.d;
    return new _Matrix3x3(detA / det, -detB / det, detC / det, -detD / det, detE / det, -detF / det, detG / det, -detH / det, detI / det, _Matrix3x3.Flag_NONE);
  }
  log() {
    console.log(this.toString());
  }
};
Matrix3x3.Flag_NONE = 0;
Matrix3x3.Flag_IDENTITY = 1;
Matrix3x3.Flag_TRANSLATION = 2;
var YEnum = class {
  static fromString(container, value) {
    let p = Object.getOwnPropertyNames(container);
    for (let i = 0; i < p.length; i++) {
      if (p[i] == value)
        return container[value];
    }
    throw "YEnum" + value + " is not a " + container + " value";
  }
  static siblings(container) {
    let res = [];
    let p = Object.getOwnPropertyNames(container);
    for (let i = 0; i < p.length; i++) {
      if (container[p[i]] instanceof YEnumItem) {
        res.push(container[p[i]]);
      }
    }
    return res;
  }
};
var YEnumItem = class {
  constructor(value, humanreadable, container) {
    this._value = value;
    this._container = container;
    this._humanreadable = humanreadable;
  }
  fromString(value) {
    return YEnum.fromString(this._container, value);
  }
  get toString() {
    return this._value.toString();
  }
  get description() {
    return this._humanreadable;
  }
  get sibblings() {
    return YEnum.siblings(this._container);
  }
};
var ViewPortSettings = class {
  constructor() {
    this.IRLx = 0;
    this.IRLy = 0;
    this.zoomx = 0;
    this.zoomy = 0;
    this.Lmargin = 0;
    this.Rmargin = 0;
    this.Tmargin = 0;
    this.Bmargin = 0;
    this.Width = 0;
    this.Height = 0;
    this.Capture = false;
    this.IRLCaptureStartX = 0;
    this.CaptureStartY = 0;
    this.OriginalXAxisMin = 0;
    this.OriginalXAxisMax = 0;
    this.OriginalIRLx = 0;
    this.OriginalLmargin = 0;
    this.OriginalZoomx = 0;
  }
};
var YFont = class {
  get userData() {
    return this._userData;
  }
  set userData(value) {
    this._userData = value;
  }
  get directParent() {
    return this._directParent;
  }
  constructor(parentRenderer, directParent, size, fontChangeCallback) {
    this._userData = null;
    this._fontChangeCallback = null;
    this._name = "Arial";
    this._italic = false;
    this._bold = false;
    this._color = YColor.Black;
    this._alternateColor = null;
    this._font = null;
    this._brush = new YSolidBrush(YColor.Black);
    this._parentRenderer = parentRenderer;
    this._directParent = directParent;
    this._fontChangeCallback = fontChangeCallback ? fontChangeCallback : null;
    this._size = new Proportional(size ? size : 10, Proportional.ResizeRule.FIXED, parentRenderer, this, this.ResetFont);
  }
  ResetFont(source) {
    this._font = null;
    if (source != null)
      this._parentRenderer.ProportionnalValueChanged(source);
  }
  get name() {
    return this._name;
  }
  set name(value) {
    this._name = value;
    this.ResetFont(null);
    this._parentRenderer.redraw();
  }
  get hasChanged() {
    return this._font == null;
  }
  get size() {
    return this._size.value;
  }
  set size(value) {
    if (value <= 0)
      throw new RangeError("Size must be a positive value");
    value = Math.round(100 * value) / 100;
    this._size.value = value;
    this.ResetFont(null);
    if (this._fontChangeCallback != null)
      this._fontChangeCallback(this);
    this._parentRenderer.redraw();
  }
  get italic() {
    return this._italic;
  }
  set italic(value) {
    if (this._italic != value) {
      this._italic = value;
      this.ResetFont(null);
      this._parentRenderer.redraw();
    }
  }
  get bold() {
    return this._bold;
  }
  set bold(value) {
    if (this._bold != value) {
      this._bold = value;
      this.ResetFont(null);
      this._parentRenderer.redraw();
    }
  }
  get color() {
    return this._color;
  }
  set color(value) {
    if (this._color != value) {
      this._color = value;
      this._brush = null;
      this._parentRenderer.redraw();
    }
  }
  get alternateColor() {
    return this._alternateColor;
  }
  set alternateColor(value) {
    if (this._alternateColor != value) {
      this._alternateColor = value;
      this._brush = null;
      this._parentRenderer.redraw();
    }
  }
  get fontObject() {
    return this._name ? this._name : "Arial";
  }
  get brush() {
    if (this._brush == null)
      this._brush = new YSolidBrush(this._alternateColor != null ? this._alternateColor : this._color);
    return this._brush;
  }
  get sizeInPoints() {
    return this._size.value * 0.75;
  }
  get sizeForCanvas() {
    return this._size.value * 1.15;
  }
  get htmlCode() {
    return (this._italic ? "italic " : "") + (this._bold ? "bold " : "") + this.sizeForCanvas.toString() + "px " + this._name;
  }
};
var YSizeF = class {
  constructor(font, st) {
    this._w = 0;
    this._h = 0;
    this._lines = [];
    this._linesCount = 0;
    this._lineHeight = 0;
    this._firstlineHeight = 0;
    if (font != null) {
      this._lineHeight = font.size * 1.25;
      this._firstlineHeight = this._lineHeight * 0.75;
      if (st.indexOf("\n") < 0) {
        this._lines = [st];
        this._linesCount = 1;
      } else {
        this._lines = st.split("\n");
        this._linesCount = this._lines.length;
      }
    }
  }
  get lines() {
    return this._lines;
  }
  get linesCount() {
    return this._linesCount;
  }
  get firstLineHeight() {
    return this._firstlineHeight;
  }
  get lineHeight() {
    return this._lineHeight;
  }
  get height() {
    return this._h;
  }
  get width() {
    return this._w;
  }
  set width(value) {
    this._w = value;
  }
  set height(value) {
    this._h = value;
  }
};
var YTextRenderingHint = class {
  constructor(value) {
    this._value = 0;
    this._value = value;
  }
};
YTextRenderingHint.SystemDefault = new YTextRenderingHint(0);
YTextRenderingHint.SingleBitPerPixelGridFit = new YTextRenderingHint(1);
YTextRenderingHint.SingleBitPerPixel = new YTextRenderingHint(2);
YTextRenderingHint.AntiAliasGridFit = new YTextRenderingHint(3);
YTextRenderingHint.AntiAlias = new YTextRenderingHint(4);
YTextRenderingHint.ClearTypeGridFit = new YTextRenderingHint(5);
var YSmoothingMode = class {
  constructor(value) {
    this._value = 0;
    this._value = value;
  }
};
YSmoothingMode.Invalid = new YSmoothingMode(-1);
YSmoothingMode.Default = new YSmoothingMode(0);
YSmoothingMode.HighSpeed = new YSmoothingMode(1);
YSmoothingMode.HighQuality = new YSmoothingMode(2);
YSmoothingMode.None = new YSmoothingMode(3);
YSmoothingMode.AntiAlias = new YSmoothingMode(4);
var YStringBuilder = class {
  constructor() {
    this._str = "";
  }
  AppendLine(s) {
    this._str += s + "\n";
  }
  Append(s) {
    this._str += s;
  }
  get contents() {
    return this._str;
  }
};
var YStringFormat = class {
  get Alignment() {
    return this._Alignment;
  }
  set Alignment(value) {
    this._Alignment = value;
  }
  get LineAlignment() {
    return this._LineAlignment;
  }
  set LineAlignment(value) {
    this._LineAlignment = value;
  }
  get FormatFlags() {
    return this._formatFlags;
  }
  set FormatFlags(value) {
    this._formatFlags = value;
  }
  get Trimming() {
    return this._Trimming;
  }
  set Trimming(value) {
    this._Trimming = value;
  }
  constructor(clip) {
    this._Alignment = 0;
    this._LineAlignment = 0;
    this._formatFlags = 0;
    this._Trimming = 0;
    this._clip = 16384;
    this._clip = clip;
  }
};
var YColor = class _YColor {
  get name() {
    return this._name;
  }
  set predefname(value) {
    this._name = value;
  }
  static get predefinedColors() {
    if (_YColor._predefinedColors == null) {
      _YColor._predefinedColors = {};
      let names = Object.getOwnPropertyNames(_YColor);
      for (let i = 0; i < names.length; i++) {
        if (_YColor[names[i]] instanceof _YColor) {
          _YColor._predefinedColors[names[i]] = _YColor[names[i]];
          _YColor._predefinedColors[names[i]].predefname = names[i];
        }
      }
    }
    return _YColor._predefinedColors;
  }
  static FromString(value) {
    let valueUpper = value.toUpperCase();
    let propNames = Object.getOwnPropertyNames(_YColor);
    for (let i = 0; i < propNames.length; i++) {
      if (propNames[i].toUpperCase() == valueUpper) {
        if (_YColor[propNames[i]] instanceof _YColor) {
          return _YColor[propNames[i]];
        }
      }
    }
    if (value.length == 7 && value.substr(0, 1).toUpperCase() == "#") {
      let r = parseInt(value.substr(1, 2), 16);
      let g = parseInt(value.substr(3, 2), 16);
      let b = parseInt(value.substr(5, 2), 16);
      return new _YColor(false, 255, r, g, b);
    }
    if (value.length == 12) {
      if (value.substr(0, 4).toUpperCase() == "RGB:") {
        let alpha = parseInt(value.substr(4, 2), 16);
        let r = parseInt(value.substr(6, 2), 16);
        let g = parseInt(value.substr(8, 2), 16);
        let b = parseInt(value.substr(10, 2), 16);
        return new _YColor(false, alpha, r, g, b);
      } else if (value.substr(0, 4).toUpperCase() == "HSL:") {
        let alpha = parseInt(value.substr(4, 2), 16);
        let h = parseInt(value.substr(6, 2), 16);
        let s = parseInt(value.substr(8, 2), 16);
        let l = parseInt(value.substr(10, 2), 16);
        return new _YColor(true, alpha, h, s, l);
      }
    }
    return null;
  }
  static hex(v) {
    let s = v.toString(16);
    if (s.length <= 1)
      return "0" + s;
    return s;
  }
  toString() {
    if (this.isHSLColor) {
      return "HSL:" + (_YColor.hex(this.transparency) + _YColor.hex(this.h) + _YColor.hex(this.s) + _YColor.hex(this.l)).toUpperCase();
    } else {
      let propNames = Object.getOwnPropertyNames(_YColor);
      for (let i = 0; i < propNames.length; i++) {
        let o = Reflect.get(_YColor, propNames[i]);
        let c = o;
        if (c.alpha == this.alpha && c.red == this.red && c.green == this.green && c.blue == this.blue)
          return propNames[i];
      }
    }
    return "RGB:" + (_YColor.hex(this.transparency) + _YColor.hex(this.r) + _YColor.hex(this.g) + _YColor.hex(this.b)).toUpperCase();
  }
  get svgCode() {
    return "rgb(" + this.r.toString() + ", " + this.g.toString() + ", " + this.b.toString() + ")";
  }
  get alphaCode() {
    return (this.transparency / 255).toFixed(3);
  }
  static hsl2rgbInt(temp1, temp2, temp3) {
    if (temp3 >= 170)
      return (temp1 + 127) / 255 >> 0;
    if (temp3 > 42) {
      if (temp3 <= 127)
        return (temp2 + 127) / 255 >> 0;
      temp3 = 170 - temp3;
    }
    return (temp1 * 255 + (temp2 - temp1) * (6 * temp3) + 32512) / 65025 >> 0;
  }
  hsl2rgb() {
    let temp1;
    let temp2;
    let temp3;
    this.rgbConvertionDone = true;
    if (this.s == 0) {
      this.r = this.l;
      this.g = this.l;
      this.b = this.l;
      return;
    }
    if (this.l <= 127) {
      temp2 = this.l * (255 + this.s);
    } else {
      temp2 = (this.l + this.s) * 255 - this.l * this.s;
    }
    temp1 = 510 * this.l - temp2;
    temp3 = this.h + 85;
    if (temp3 > 255)
      temp3 = temp3 - 255;
    this.r = _YColor.hsl2rgbInt(temp1, temp2, temp3);
    temp3 = this.h;
    if (temp3 > 255)
      temp3 = temp3 - 255;
    this.g = _YColor.hsl2rgbInt(temp1, temp2, temp3);
    if (this.h >= 85) {
      temp3 = this.h - 85;
    } else {
      temp3 = this.h + 170;
    }
    this.b = _YColor.hsl2rgbInt(temp1, temp2, temp3);
    if (this.r > 255)
      this.r = 255;
    if (this.g > 255)
      this.g = 255;
    if (this.b > 255)
      this.b = 255;
  }
  computeHSL() {
    let R = this.r;
    let G = this.g;
    let B = this.b;
    let H;
    let S;
    let L;
    let max = R > G ? R : G;
    let min = R < G ? R : G;
    let correction = 0;
    let divisor = 0;
    this.hslConvertionDone = true;
    if (B > max)
      max = B;
    if (B < min)
      min = B;
    L = (max + min + 1) / 2 >> 0;
    if (max == min) {
      this.h = 0;
      this.s = 0;
      this.l = L;
      return;
    }
    correction = (max + min) / 2 >> 0;
    if (L <= 127) {
      S = (255 * (max - min) + correction) / (max + min) >> 0;
    } else {
      S = (255 * (max - min) + 255 - correction) / (510 - (max + min)) >> 0;
    }
    correction = 3 * (max - min);
    divisor = 2 * correction;
    if (R == max) {
      H = 0;
      R = G;
      G = B;
    } else if (G == max) {
      H = 85;
      G = R;
      R = B;
    } else {
      H = 170;
    }
    if (R >= G) {
      H += (255 * (R - G) + correction) / divisor >> 0;
    } else {
      H += 255 - (255 * (G - R) - correction) / divisor >> 0;
    }
    if (H > 255)
      H -= 255;
    if (S > 255)
      S = 255;
    if (L > 255)
      L = 255;
    this.h = H;
    this.s = S;
    this.l = L;
  }
  get hue() {
    if (!this.hslConvertionDone)
      this.computeHSL();
    return this.h;
  }
  get saturation() {
    if (!this.hslConvertionDone)
      this.computeHSL();
    return this.s;
  }
  get luminosity() {
    if (!this.hslConvertionDone)
      this.computeHSL();
    return this.l;
  }
  get red() {
    if (!this.rgbConvertionDone)
      this.hsl2rgb();
    return this.r;
  }
  get green() {
    if (!this.rgbConvertionDone)
      this.hsl2rgb();
    return this.g;
  }
  get blue() {
    if (!this.rgbConvertionDone)
      this.hsl2rgb();
    return this.b;
  }
  get alpha() {
    return this.transparency;
  }
  static FromArgb(a, r, g, b) {
    return new _YColor(false, a, r, g, b);
  }
  static FromAhsl(a, h, s, l) {
    return new _YColor(true, a, h, s, l);
  }
  get isHSL() {
    return this.isHSLColor;
  }
  get isRGB() {
    return !this.isHSLColor;
  }
  equal(c) {
    if (this.isHSLColor) {
      if (!c.isHSLColor)
        return false;
      if (c.hue != this.hue)
        return false;
      if (c.saturation != this.saturation)
        return false;
      if (c.luminosity != this.luminosity)
        return false;
      if (c.alpha != this.alpha)
        return false;
    } else {
      if (c.isHSLColor)
        return false;
      if (c.red != this.red)
        return false;
      if (c.green != this.green)
        return false;
      if (c.blue != this.blue)
        return false;
      if (c.alpha != this.alpha)
        return false;
    }
    return true;
  }
  clone() {
    if (this.isHSLColor)
      return new _YColor(true, this.transparency, this.h, this.s, this.l, this.isPredefined);
    return new _YColor(false, this.transparency, this.r, this.g, this.b, this.isPredefined);
  }
  get isPredefined() {
    return this._isPredefined;
  }
  constructor(isHsl, transparency, r_h, g_s, b_l, isPredefined) {
    this.hslConvertionDone = false;
    this.rgbConvertionDone = false;
    this.transparency = 0;
    this.r = 0;
    this.g = 0;
    this.b = 0;
    this.h = 0;
    this.s = 0;
    this.l = 0;
    this._name = "";
    this._htmlcode = this.computeHTMLCode();
    this.hslConvertionDone = isHsl;
    this.isHSLColor = isHsl;
    this.transparency = transparency;
    this._isPredefined = isPredefined === true;
    if (isHsl) {
      this.h = r_h;
      this.s = g_s;
      this.l = b_l;
      this.hsl2rgb();
    } else {
      this.r = r_h;
      this.g = g_s;
      this.b = b_l;
      this.rgbConvertionDone = true;
    }
    this._htmlcode = this.computeHTMLCode();
  }
  computeHTMLCode() {
    let a = this.transparency / 255;
    let r = this.r;
    let g = this.g;
    let b = this.b;
    return "rgba(" + r + "," + g + "," + b + "," + a.toFixed(3) + ")";
  }
  get htmlCode() {
    return this._htmlcode;
  }
};
YColor.AliceBlue = new YColor(false, 255, 240, 248, 255, true);
YColor.AntiqueWhite = new YColor(false, 255, 250, 235, 215, true);
YColor.Aqua = new YColor(false, 255, 0, 255, 255, true);
YColor.Aquamarine = new YColor(false, 255, 127, 255, 212, true);
YColor.Azure = new YColor(false, 255, 240, 255, 255, true);
YColor.Beige = new YColor(false, 255, 245, 245, 220, true);
YColor.Bisque = new YColor(false, 255, 255, 228, 196, true);
YColor.Black = new YColor(false, 255, 0, 0, 0, true);
YColor.BlanchedAlmond = new YColor(false, 255, 255, 235, 205, true);
YColor.Blue = new YColor(false, 255, 0, 0, 255, true);
YColor.BlueViolet = new YColor(false, 255, 138, 43, 226, true);
YColor.Brown = new YColor(false, 255, 165, 42, 42, true);
YColor.BurlyWood = new YColor(false, 255, 222, 184, 135, true);
YColor.CadetBlue = new YColor(false, 255, 95, 158, 160, true);
YColor.Chartreuse = new YColor(false, 255, 127, 255, 0, true);
YColor.Chocolate = new YColor(false, 255, 210, 105, 30, true);
YColor.Coral = new YColor(false, 255, 255, 127, 80, true);
YColor.CornflowerBlue = new YColor(false, 255, 100, 149, 237, true);
YColor.Cornsilk = new YColor(false, 255, 255, 248, 220, true);
YColor.Crimson = new YColor(false, 255, 220, 20, 60, true);
YColor.Cyan = new YColor(false, 255, 0, 255, 255, true);
YColor.DarkBlue = new YColor(false, 255, 0, 0, 139, true);
YColor.DarkCyan = new YColor(false, 255, 0, 139, 139, true);
YColor.DarkGoldenrod = new YColor(false, 255, 184, 134, 11, true);
YColor.DarkGray = new YColor(false, 255, 169, 169, 169, true);
YColor.DarkGreen = new YColor(false, 255, 0, 100, 0, true);
YColor.DarkKhaki = new YColor(false, 255, 189, 183, 107, true);
YColor.DarkMagenta = new YColor(false, 255, 139, 0, 139, true);
YColor.DarkOliveGreen = new YColor(false, 255, 85, 107, 47, true);
YColor.DarkOrange = new YColor(false, 255, 255, 140, 0, true);
YColor.DarkOrchid = new YColor(false, 255, 153, 50, 204, true);
YColor.DarkRed = new YColor(false, 255, 139, 0, 0, true);
YColor.DarkSalmon = new YColor(false, 255, 233, 150, 122, true);
YColor.DarkSeaGreen = new YColor(false, 255, 143, 188, 143, true);
YColor.DarkSlateBlue = new YColor(false, 255, 72, 61, 139, true);
YColor.DarkSlateGray = new YColor(false, 255, 47, 79, 79, true);
YColor.DarkTurquoise = new YColor(false, 255, 0, 206, 209, true);
YColor.DarkViolet = new YColor(false, 255, 148, 0, 211, true);
YColor.DeepPink = new YColor(false, 255, 255, 20, 147, true);
YColor.DeepSkyBlue = new YColor(false, 255, 0, 191, 255, true);
YColor.DimGray = new YColor(false, 255, 105, 105, 105, true);
YColor.DodgerBlue = new YColor(false, 255, 30, 144, 255, true);
YColor.Firebrick = new YColor(false, 255, 178, 34, 34, true);
YColor.FloralWhite = new YColor(false, 255, 255, 250, 240, true);
YColor.ForestGreen = new YColor(false, 255, 34, 139, 34, true);
YColor.Fuchsia = new YColor(false, 255, 255, 0, 255, true);
YColor.Gainsboro = new YColor(false, 255, 220, 220, 220, true);
YColor.GhostWhite = new YColor(false, 255, 248, 248, 255, true);
YColor.Gold = new YColor(false, 255, 255, 215, 0, true);
YColor.Goldenrod = new YColor(false, 255, 218, 165, 32, true);
YColor.Gray = new YColor(false, 255, 128, 128, 128, true);
YColor.Green = new YColor(false, 255, 0, 128, 0, true);
YColor.GreenYellow = new YColor(false, 255, 173, 255, 47, true);
YColor.Honeydew = new YColor(false, 255, 240, 255, 240, true);
YColor.HotPink = new YColor(false, 255, 255, 105, 180, true);
YColor.IndianRed = new YColor(false, 255, 205, 92, 92, true);
YColor.Indigo = new YColor(false, 255, 75, 0, 130, true);
YColor.Ivory = new YColor(false, 255, 255, 255, 240, true);
YColor.Khaki = new YColor(false, 255, 240, 230, 140, true);
YColor.Lavender = new YColor(false, 255, 230, 230, 250, true);
YColor.LavenderBlush = new YColor(false, 255, 255, 240, 245, true);
YColor.LawnGreen = new YColor(false, 255, 124, 252, 0, true);
YColor.LemonChiffon = new YColor(false, 255, 255, 250, 205, true);
YColor.LightBlue = new YColor(false, 255, 173, 216, 230, true);
YColor.LightCoral = new YColor(false, 255, 240, 128, 128, true);
YColor.LightCyan = new YColor(false, 255, 224, 255, 255, true);
YColor.LightGoldenrodYellow = new YColor(false, 255, 250, 250, 210, true);
YColor.LightGray = new YColor(false, 255, 211, 211, 211, true);
YColor.LightGreen = new YColor(false, 255, 144, 238, 144, true);
YColor.LightPink = new YColor(false, 255, 255, 182, 193, true);
YColor.LightSalmon = new YColor(false, 255, 255, 160, 122, true);
YColor.LightSeaGreen = new YColor(false, 255, 32, 178, 170, true);
YColor.LightSkyBlue = new YColor(false, 255, 135, 206, 250, true);
YColor.LightSlateGray = new YColor(false, 255, 119, 136, 153, true);
YColor.LightSteelBlue = new YColor(false, 255, 176, 196, 222, true);
YColor.LightYellow = new YColor(false, 255, 255, 255, 224, true);
YColor.Lime = new YColor(false, 255, 0, 255, 0, true);
YColor.LimeGreen = new YColor(false, 255, 50, 205, 50, true);
YColor.Linen = new YColor(false, 255, 250, 240, 230, true);
YColor.Magenta = new YColor(false, 255, 255, 0, 255, true);
YColor.Maroon = new YColor(false, 255, 128, 0, 0, true);
YColor.MediumAquamarine = new YColor(false, 255, 102, 205, 170, true);
YColor.MediumBlue = new YColor(false, 255, 0, 0, 205, true);
YColor.MediumOrchid = new YColor(false, 255, 186, 85, 211, true);
YColor.MediumPurple = new YColor(false, 255, 147, 112, 219, true);
YColor.MediumSeaGreen = new YColor(false, 255, 60, 179, 113, true);
YColor.MediumSlateBlue = new YColor(false, 255, 123, 104, 238, true);
YColor.MediumSpringGreen = new YColor(false, 255, 0, 250, 154, true);
YColor.MediumTurquoise = new YColor(false, 255, 72, 209, 204, true);
YColor.MediumVioletRed = new YColor(false, 255, 199, 21, 133, true);
YColor.MidnightBlue = new YColor(false, 255, 25, 25, 112, true);
YColor.MintCream = new YColor(false, 255, 245, 255, 250, true);
YColor.MistyRose = new YColor(false, 255, 255, 228, 225, true);
YColor.Moccasin = new YColor(false, 255, 255, 228, 181, true);
YColor.NavajoWhite = new YColor(false, 255, 255, 222, 173, true);
YColor.Navy = new YColor(false, 255, 0, 0, 128, true);
YColor.OldLace = new YColor(false, 255, 253, 245, 230, true);
YColor.Olive = new YColor(false, 255, 128, 128, 0, true);
YColor.OliveDrab = new YColor(false, 255, 107, 142, 35, true);
YColor.Orange = new YColor(false, 255, 255, 165, 0, true);
YColor.OrangeRed = new YColor(false, 255, 255, 69, 0, true);
YColor.Orchid = new YColor(false, 255, 218, 112, 214, true);
YColor.PaleGoldenrod = new YColor(false, 255, 238, 232, 170, true);
YColor.PaleGreen = new YColor(false, 255, 152, 251, 152, true);
YColor.PaleTurquoise = new YColor(false, 255, 175, 238, 238, true);
YColor.PaleVioletRed = new YColor(false, 255, 219, 112, 147, true);
YColor.PapayaWhip = new YColor(false, 255, 255, 239, 213, true);
YColor.PeachPuff = new YColor(false, 255, 255, 218, 185, true);
YColor.Peru = new YColor(false, 255, 205, 133, 63, true);
YColor.Pink = new YColor(false, 255, 255, 192, 203, true);
YColor.Plum = new YColor(false, 255, 221, 160, 221, true);
YColor.PowderBlue = new YColor(false, 255, 176, 224, 230, true);
YColor.Purple = new YColor(false, 255, 128, 0, 128, true);
YColor.Red = new YColor(false, 255, 255, 0, 0, true);
YColor.RosyBrown = new YColor(false, 255, 188, 143, 143, true);
YColor.RoyalBlue = new YColor(false, 255, 65, 105, 225, true);
YColor.SaddleBrown = new YColor(false, 255, 139, 69, 19, true);
YColor.Salmon = new YColor(false, 255, 250, 128, 114, true);
YColor.SandyBrown = new YColor(false, 255, 244, 164, 96, true);
YColor.SeaGreen = new YColor(false, 255, 46, 139, 87, true);
YColor.SeaShell = new YColor(false, 255, 255, 245, 238, true);
YColor.Sienna = new YColor(false, 255, 160, 82, 45, true);
YColor.Silver = new YColor(false, 255, 192, 192, 192, true);
YColor.SkyBlue = new YColor(false, 255, 135, 206, 235, true);
YColor.SlateBlue = new YColor(false, 255, 106, 90, 205, true);
YColor.SlateGray = new YColor(false, 255, 112, 128, 144, true);
YColor.Snow = new YColor(false, 255, 255, 250, 250, true);
YColor.SpringGreen = new YColor(false, 255, 0, 255, 127, true);
YColor.SteelBlue = new YColor(false, 255, 70, 130, 180, true);
YColor.Tan = new YColor(false, 255, 210, 180, 140, true);
YColor.Teal = new YColor(false, 255, 0, 128, 128, true);
YColor.Thistle = new YColor(false, 255, 216, 191, 216, true);
YColor.Tomato = new YColor(false, 255, 255, 99, 71, true);
YColor.Transparent = new YColor(false, 0, 255, 255, 255, true);
YColor.Turquoise = new YColor(false, 255, 64, 224, 208, true);
YColor.Violet = new YColor(false, 255, 238, 130, 238, true);
YColor.Wheat = new YColor(false, 255, 245, 222, 179, true);
YColor.White = new YColor(false, 255, 255, 255, 255, true);
YColor.WhiteSmoke = new YColor(false, 255, 245, 245, 245, true);
YColor.Yellow = new YColor(false, 255, 255, 255, 0, true);
YColor.YellowGreen = new YColor(false, 255, 154, 205, 50, true);
YColor._predefinedColors = null;
var YBrush = class {
  constructor(c, disableAntialias) {
    this._noAntiAlias = false;
    this._color = c;
    if (typeof disableAntialias != "undefined") {
      this._noAntiAlias = disableAntialias;
    }
  }
  get noAntiAlias() {
    return this._noAntiAlias;
  }
  get color() {
    return this._color;
  }
};
var YSolidBrush = class extends YBrush {
};
var YLinearGradientBrush = class extends YBrush {
  constructor(c1, c2) {
    super(c1);
    this._color1 = c1;
    this._color2 = c2;
  }
  get color1() {
    return this._color1;
  }
  get color2() {
    return this._color2;
  }
};
var YPen = class _YPen {
  constructor(color, thickness, disableAntialias) {
    this._thickness = 1;
    this._color = YColor.Black;
    this._noAntiAlias = false;
    this._startCap = 1;
    this._endCap = 1;
    this._linejoin = _YPen.LineJoin.Miter;
    this._thickness = thickness;
    this._color = thickness > 0 ? color : YColor.Transparent;
    if (typeof disableAntialias != "undefined") {
      this._noAntiAlias = disableAntialias;
    }
  }
  get noAntiAlias() {
    return this._noAntiAlias;
  }
  get lineWidth() {
    return this._thickness;
  }
  get strokeStyle() {
    return this._color.htmlCode;
  }
  get color() {
    return this._color;
  }
  set startCap(value) {
    this._startCap = value;
  }
  set endCap(value) {
    this._endCap = value;
  }
  set linejoin(value) {
    this._linejoin = value;
  }
};
(function(YPen2) {
  let LineJoin;
  (function(LineJoin2) {
    LineJoin2[LineJoin2["Miter"] = 0] = "Miter";
    LineJoin2[LineJoin2["Bevel"] = 1] = "Bevel";
    LineJoin2[LineJoin2["Round"] = 2] = "Round";
    LineJoin2[LineJoin2["MiterClipped"] = 3] = "MiterClipped";
  })(LineJoin = YPen2.LineJoin || (YPen2.LineJoin = {}));
})(YPen || (YPen = {}));
var YRectangle = class {
  constructor(x, y, w, h) {
    this.x = x;
    this.y = y;
    this.w = w;
    this.h = h;
  }
};
var Point = class {
  constructor(valueX, valueY) {
    this.X = valueX >> 0;
    this.Y = valueY >> 0;
  }
};
var minMaxPoint = class {
  constructor(valueX1, valueYMIN, valueX2, valueYMAX) {
    this.X1 = valueX1 >> 0;
    this.YMIN = valueYMIN >> 0;
    this.X2 = valueX2 >> 0;
    this.YMAX = valueYMAX >> 0;
  }
};
var PointF = class {
  constructor(valueX, valueY) {
    this.X = valueX;
    this.Y = valueY;
  }
};
var GenericPanel = class _GenericPanel {
  get userData() {
    return this._userData;
  }
  set userData(value) {
    this._userData = value;
  }
  get directParent() {
    return this._directParent;
  }
  constructor(parent, directParent) {
    this._userData = null;
    this._enabled = false;
    this._panelTextAlign = _GenericPanel.TextAlign.LEFT;
    this._text = "";
    this._bgColor = new YColor(false, 255, 255, 255, 192);
    this._borderColor = YColor.Black;
    this._borderthickness = 1;
    this._padding = 10;
    this._verticalMargin = 10;
    this._horizontalMargin = 10;
    this._bgBrush = null;
    this._pen = null;
    this._font = null;
    this._directParent = directParent;
    this._parentRenderer = parent;
    this._font = new YFont(parent, this, 8, null);
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    if (this._enabled != value) {
      this._enabled = value;
      this._parentRenderer.clearCachedObjects();
      this._parentRenderer.redraw();
    }
  }
  get panelTextAlign() {
    return this._panelTextAlign;
  }
  set panelTextAlign(value) {
    this._panelTextAlign = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get text() {
    return this._text;
  }
  set text(value) {
    this._text = value;
    this._parentRenderer.clearCachedObjects();
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get bgColor() {
    return this._bgColor;
  }
  set bgColor(value) {
    this._bgColor = value;
    this._bgBrush = null;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get borderColor() {
    return this._borderColor;
  }
  set borderColor(value) {
    this._borderColor = value;
    this._pen = null;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get borderthickness() {
    return this._borderthickness;
  }
  set borderthickness(value) {
    if (value < 0)
      throw "Border thickness must be a positive value";
    this._borderthickness = value;
    this._parentRenderer.clearCachedObjects();
    this._pen = null;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get padding() {
    return this._padding;
  }
  set padding(value) {
    if (value < 0)
      throw new RangeError("Padding must be a positive value");
    this._padding = value;
    this._parentRenderer.clearCachedObjects();
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get verticalMargin() {
    return this._verticalMargin;
  }
  set verticalMargin(value) {
    this._verticalMargin = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get horizontalMargin() {
    return this._horizontalMargin;
  }
  set horizontalMargin(value) {
    this._horizontalMargin = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get bgBrush() {
    if (this._bgBrush == null)
      this._bgBrush = new YSolidBrush(this._bgColor);
    return this._bgBrush;
  }
  get pen() {
    if (this._pen == null) {
      this._pen = new YPen(this._borderColor, this._borderthickness, true);
    }
    return this._pen;
  }
  get font() {
    return this._font;
  }
};
(function(GenericPanel2) {
  class HorizontalAlignPosEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, HorizontalAlignPos);
    }
  }
  GenericPanel2.HorizontalAlignPosEnumItem = HorizontalAlignPosEnumItem;
  class HorizontalAlignPos extends YEnum {
  }
  HorizontalAlignPos.LEFT = new HorizontalAlignPosEnumItem("LEFT", "Left");
  HorizontalAlignPos.CENTER = new HorizontalAlignPosEnumItem("CENTER", "Center");
  HorizontalAlignPos.RIGHT = new HorizontalAlignPosEnumItem("RIGHT", "Right");
  GenericPanel2.HorizontalAlignPos = HorizontalAlignPos;
  class VerticalAlignPosEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, VerticalAlignPos);
    }
  }
  GenericPanel2.VerticalAlignPosEnumItem = VerticalAlignPosEnumItem;
  class VerticalAlignPos extends YEnum {
  }
  VerticalAlignPos.TOP = new VerticalAlignPosEnumItem("TOP", "Top");
  VerticalAlignPos.CENTER = new VerticalAlignPosEnumItem("CENTER", "Center");
  VerticalAlignPos.BOTTOM = new VerticalAlignPosEnumItem("BOTTOM", "Bottom");
  GenericPanel2.VerticalAlignPos = VerticalAlignPos;
  class TextAlignEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, TextAlign);
    }
  }
  GenericPanel2.TextAlignEnumItem = TextAlignEnumItem;
  class TextAlign extends YEnum {
  }
  TextAlign.LEFT = new TextAlignEnumItem("LEFT", "Left");
  TextAlign.CENTER = new TextAlignEnumItem("CENTER", "Center");
  TextAlign.RIGHT = new TextAlignEnumItem("RIGHT", "Right");
  GenericPanel2.TextAlign = TextAlign;
})(GenericPanel || (GenericPanel = {}));
var MessagePanel = class extends GenericPanel {
  constructor(parent, directParent) {
    super(parent, directParent);
    this._panelHrzAlign = GenericPanel.HorizontalAlignPos.CENTER;
    this._panelVrtAlign = GenericPanel.VerticalAlignPos.CENTER;
  }
  get panelHrzAlign() {
    return this._panelHrzAlign;
  }
  set panelHrzAlign(value) {
    this._panelHrzAlign = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get panelVrtAlign() {
    return this._panelVrtAlign;
  }
  set panelVrtAlign(value) {
    this._panelVrtAlign = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
};
var AnnotationPanel = class extends GenericPanel {
  constructor(parent, directParent) {
    super(parent, directParent);
    this._overlap = false;
    this._positionOffsetX = 50;
    this._positionOffsetY = 50;
    this._panelHrzAlign = GenericPanel.HorizontalAlignPos.CENTER;
    this._panelVrtAlign = GenericPanel.VerticalAlignPos.TOP;
  }
  get overlap() {
    return this._overlap;
  }
  set overlap(value) {
    if (!value && this._panelHrzAlign == GenericPanel.HorizontalAlignPos.CENTER && this._panelVrtAlign == GenericPanel.VerticalAlignPos.CENTER) {
      this._panelVrtAlign = GenericPanel.VerticalAlignPos.TOP;
    }
    this._overlap = value;
    this._parentRenderer.clearCachedObjects();
    this._parentRenderer.redraw();
  }
  get positionOffsetX() {
    return this._positionOffsetX;
  }
  set positionOffsetX(value) {
    this._positionOffsetX = value;
    this._parentRenderer.clearCachedObjects();
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get positionOffsetY() {
    return this._positionOffsetY;
  }
  set positionOffsetY(value) {
    this._positionOffsetY = value;
    this._parentRenderer.clearCachedObjects();
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get panelHrzAlign() {
    return this._panelHrzAlign;
  }
  set panelHrzAlign(value) {
    if (!this._overlap && value == GenericPanel.HorizontalAlignPos.CENTER && this._panelVrtAlign == GenericPanel.VerticalAlignPos.CENTER) {
      this._panelVrtAlign = GenericPanel.VerticalAlignPos.TOP;
    }
    this._panelHrzAlign = value;
    this._parentRenderer.clearCachedObjects();
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get panelVrtAlign() {
    return this._panelVrtAlign;
  }
  set panelVrtAlign(value) {
    if (!this._overlap && value == GenericPanel.VerticalAlignPos.CENTER && this._panelHrzAlign == GenericPanel.HorizontalAlignPos.CENTER) {
      this._panelHrzAlign = GenericPanel.HorizontalAlignPos.RIGHT;
    }
    this._panelVrtAlign = value;
    this._parentRenderer.clearCachedObjects();
    if (this._enabled)
      this._parentRenderer.redraw();
  }
};
var Zone = class {
  get directParent() {
    return this._directParent;
  }
  get userData() {
    return this._userData;
  }
  set userData(value) {
    this._userData = value;
  }
  resetCache() {
  }
  constructor(parentRenderer, directParent) {
    this._userData = null;
    this._zoneBrush = null;
    this._color = YColor.Red;
    this._visible = false;
    this._min = 0;
    this._max = 100;
    this._directParent = directParent;
    this._parentRenderer = parentRenderer;
  }
  get zoneBrush() {
    if (this._zoneBrush == null)
      this._zoneBrush = new YSolidBrush(this._color);
    return this._zoneBrush;
  }
  get color() {
    return this._color;
  }
  set color(value) {
    this._color = value;
    this._zoneBrush = null;
    if (this.visible)
      this._parentRenderer.redraw();
  }
  get visible() {
    return this._visible;
  }
  set visible(value) {
    this._visible = value;
    this._parentRenderer.redraw();
  }
  set_minMax(min, max) {
    if (min > max)
      throw new RangeError("Min cannot be greater than max ");
    this._min = min;
    this._max = max;
    this.resetCache();
    if (this.visible)
      this._parentRenderer.redraw();
  }
  get min() {
    return this._min;
  }
  set min(value) {
    if (value >= this._max && !YDataRenderer.minMaxCheckDisabled) {
      throw new RangeError("Min cannot be greater than max (" + this._max.toString() + ")");
    }
    this._min = value;
    this.resetCache();
    if (this.visible)
      this._parentRenderer.redraw();
  }
  get max() {
    return this._max;
  }
  set max(value) {
    if (value <= this._min && !YDataRenderer.minMaxCheckDisabled) {
      throw new RangeError("Max cannot be greater than min (" + this._min.toString() + ")");
    }
    this._max = value;
    this.resetCache();
    if (this.visible)
      this._parentRenderer.redraw();
  }
};
var Proportional = class _Proportional {
  get userData() {
    return this._userData;
  }
  set userData(value) {
    this._userData = value;
  }
  get directParent() {
    return this._directParent;
  }
  get value() {
    return this._value;
  }
  set value(v) {
    this._value = v;
    this.set_refPoint();
    if (this._reset != null)
      this._reset(this);
  }
  get resizeRule() {
    return this._resizeRule;
  }
  set resizeRule(value) {
    this.set_refPoint();
    this._resizeRule = value;
  }
  set_refPoint() {
    this._refWidth = Math.max(1, this._parentRenderer.usableUiWidth());
    this._refHeight = Math.max(1, this._parentRenderer.usableUiHeight());
    this._refValue = this._value;
  }
  constructor(value, resizeRule, parentRenderer, directParent, resetCallBack) {
    this._reset = null;
    this._refWidth = 1;
    this._refHeight = 1;
    this._refValue = 1;
    this.valueStack = [];
    this._resizeRule = _Proportional.ResizeRule.FIXED;
    this._userData = null;
    this._reset = resetCallBack;
    this._parentRenderer = parentRenderer;
    this._value = value;
    this._resizeRule = resizeRule;
    this._directParent = directParent;
    this.set_refPoint();
    this._parentRenderer.AddNewProportionalToSizeValue(this);
  }
  containerResizedPushNewCoef(coef) {
    this.valueStack.push(this._value);
    this._value = Math.round(100 * this._refValue * coef) / 100;
    if (this._reset != null)
      this._reset(this);
  }
  containerResizedPop() {
    if (this.valueStack.length <= 0)
      throw new RangeError("Can't pop, empty stack.");
    this._value = this.valueStack.pop();
    if (this._reset != null)
      this._reset(this);
  }
  static resizeCoef(rule, refWidth, refHeight, newWidth, newHeight) {
    switch (rule) {
      case _Proportional.ResizeRule.RELATIVETOWIDTH:
        return newWidth / refWidth;
      case _Proportional.ResizeRule.RELATIVETOHEIGHT:
        return newHeight / refHeight;
      case _Proportional.ResizeRule.RELATIVETOBOTH:
        return Math.min(newHeight / refHeight, newWidth / refWidth);
    }
    return 1;
  }
  containerResized(newWidth, newHeight) {
    this._value = Math.round(100 * this._refValue * _Proportional.resizeCoef(this._resizeRule, this._refWidth, this._refHeight, newWidth, newHeight)) / 100;
    if (this._reset != null)
      this._reset(this);
  }
  forceChangeCallback() {
    if (this._reset != null)
      this._reset(this);
  }
};
(function(Proportional2) {
  class ResizeRuleEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, ResizeRule);
    }
  }
  Proportional2.ResizeRuleEnumItem = ResizeRuleEnumItem;
  class ResizeRule extends YEnum {
  }
  ResizeRule.FIXED = new ResizeRuleEnumItem("FIXED", "Fixed");
  ResizeRule.RELATIVETOWIDTH = new ResizeRuleEnumItem("RELATIVETOWIDTH", "Relative to Width");
  ResizeRule.RELATIVETOHEIGHT = new ResizeRuleEnumItem("RELATIVETOHEIGHT", "Relative to height");
  ResizeRule.RELATIVETOBOTH = new ResizeRuleEnumItem("RELATIVETOBOTH", "Relative to Width and Height");
  Proportional2.ResizeRule = ResizeRule;
})(Proportional || (Proportional = {}));
var YDataRenderer = class _YDataRenderer {
  get annotationPanels() {
    return this._annotationPanels;
  }
  get userData() {
    return this._userData;
  }
  static get minMaxCheckDisabled() {
    return _YDataRenderer._disableMinMaxCheck;
  }
  static set minMaxCheckDisabled(value) {
    _YDataRenderer._disableMinMaxCheck = value;
  }
  resetlegendPens() {
  }
  get getCaptureParameters() {
    return this._getCaptureParameters;
  }
  set getCaptureParameters(value) {
    this._getCaptureParameters = value;
  }
  get messagePanels() {
    return this._messagePanels;
  }
  static globalMouseMove(e) {
    _YDataRenderer.globalMouseX = e.pageX;
    _YDataRenderer.globalMouseY = e.pageY;
  }
  clearTransformationMatrix() {
    this._Scr2ElmMatrix = null;
    this._Elm2ScrMatrix = null;
  }
  // This is the one of the "magic" parts, instead on relying
  // on each HTML element offsetLeft and offsetTop coordinates,we
  // compute the whole transformation matrix for the canvas Element,
  // this way, CSS transformations, including scale and rotation are
  // handled property.  This is important since Yocto-Visualization
  // allows in to inject a widget inside an arbitrary DIV. This
  // also importnat to be able to make these convertion from
  // any position on the whole page because of drag operations
  findElementAbsolutePosition(el) {
    let staticFound = false;
    let relativeFound = false;
    let dx = 0;
    let dy = 0;
    while (el != null) {
      let style = window.getComputedStyle(el);
      if (!relativeFound && style.position == "static" && !staticFound) {
        dx = el.offsetLeft + parseFloat(style.borderLeftWidth);
        dy = el.offsetTop + parseFloat(style.borderTopWidth);
        staticFound = true;
      }
      if (style.position == "relative" || style.position == "absolute") {
        dx += el.offsetLeft + parseFloat(style.borderLeftWidth);
        dy += el.offsetTop + parseFloat(style.borderTopWidth);
        relativeFound = true;
      }
      el = el.parentElement;
    }
    return new PointF(dx, dy);
  }
  get Elm2ScrMatrix() {
    if (this._Elm2ScrMatrix == null) {
      let el = this.UIContainer;
      let AsolutePositionsStack = [];
      while (el != null) {
        AsolutePositionsStack.push(this.findElementAbsolutePosition(el));
        el = el.parentElement;
      }
      el = this.UIContainer;
      let MatrixStack = [];
      let staticFound = false;
      let relativeFound = false;
      let index = 0;
      while (el != null) {
        let parent = el.parentElement;
        let style = window.getComputedStyle(el);
        let dx = AsolutePositionsStack[index].X;
        let dy = AsolutePositionsStack[index].Y;
        if (index < AsolutePositionsStack.length - 1) {
          dx -= AsolutePositionsStack[index + 1].X;
          dy -= AsolutePositionsStack[index + 1].Y;
        }
        let matrix = style["transform"];
        if (matrix != "none") {
          let matrixStr = matrix.match(/matrix.*\((.+)\)/)[1].split(", ");
          let matrixValues = [];
          for (let i = 0; i < 6; i++) {
            matrixValues.push(parseFloat(matrixStr[i]));
          }
          let OriginMatrixMatrixBefore = null;
          let TransformMatrix = Matrix3x3.newMatrix(matrixValues[0], matrixValues[2], matrixValues[4], matrixValues[1], matrixValues[3], matrixValues[5], 0, 0, 1);
          let OriginMatrixMatrixAfter = null;
          if (style.transformOrigin) {
            let parts = style.transformOrigin.split(" ");
            let Ox = Number.parseFloat(parts[0]);
            let Oy = Number.parseFloat(parts[1]);
            OriginMatrixMatrixBefore = Matrix3x3.newTranslateMatrix(-Ox, -Oy);
            OriginMatrixMatrixAfter = Matrix3x3.newTranslateMatrix(Ox, Oy);
          }
          if (OriginMatrixMatrixBefore != null)
            MatrixStack.push(OriginMatrixMatrixBefore);
          if (TransformMatrix != null)
            MatrixStack.push(TransformMatrix);
          if (OriginMatrixMatrixAfter != null)
            MatrixStack.push(OriginMatrixMatrixAfter);
        }
        if (dx != 0 || dy != 0)
          MatrixStack.push(Matrix3x3.newTranslateMatrix(dx, dy));
        el = parent;
        index++;
      }
      this._Elm2ScrMatrix = Matrix3x3.newIdentityMatrix();
      for (let i = MatrixStack.length - 1; i >= 0; i--) {
        this._Elm2ScrMatrix = this._Elm2ScrMatrix.multiplyByM(MatrixStack[i]);
      }
    }
    return this._Elm2ScrMatrix;
  }
  get Scr2ElmMatrix() {
    if (this._Scr2ElmMatrix == null) {
      this._Scr2ElmMatrix = this.Elm2ScrMatrix.inverse;
    }
    return this._Scr2ElmMatrix;
  }
  addAnnotationPanel() {
    let p = new AnnotationPanel(this, this);
    this._annotationPanels.push(p);
    this.redraw();
    return p;
  }
  AllowRedraw() {
    this._redrawAllowed--;
    if (this._redrawAllowed < 0)
      throw new RangeError("Too many AllowRedraw calls");
    if (this._redrawAllowed == 0)
      this.redraw();
  }
  AllowRedrawNoRefresh() {
    this._redrawAllowed--;
    if (this._redrawAllowed < 0)
      throw new RangeError("Too many AllowRedraw calls");
  }
  DisableRedraw() {
    this._redrawAllowed++;
  }
  AddNewProportionalToSizeValue(v) {
    if (this.ProportionalToSizeValues.indexOf(v) < 0)
      this.ProportionalToSizeValues.push(v);
  }
  canRedraw() {
    return this._redrawAllowed == 0;
  }
  setPatchAnnotationCallback(callback) {
    this._PatchAnnotationCallback = callback;
  }
  patchAnnotation(text) {
    text = text.replace("\\n", "\n");
    if (text.indexOf("$") < 0)
      return text;
    let now = /* @__PURE__ */ new Date();
    text = text.replace("$DAY$", now.getDay().toString());
    text = text.replace("$MONTH$", now.getMonth().toString());
    text = text.replace("$YEAR$", now.getFullYear().toString());
    text = text.replace("$HOUR$", now.getHours().toString());
    text = text.replace("$MINUTE$", now.getMinutes().toString());
    text = text.replace("$SECOND$", now.getSeconds().toString());
    if (this._PatchAnnotationCallback != null)
      text = this._PatchAnnotationCallback(text);
    return text;
  }
  mouseLocalPosition() {
    let v = Vector3.FromXYCoord(_YDataRenderer.globalMouseX, _YDataRenderer.globalMouseY);
    let m = this.Scr2ElmMatrix;
    let p = m.multiplyByV(v).toPoint();
    if (p.X < 0 || p.Y < 0 || p.X > this.UIContainer.offsetWidth || p.Y > this.UIContainer.offsetHeight)
      return null;
    return p;
  }
  set proportionnalValueChangeCallback(value) {
    this._proportionnalValueChangeCallback = value;
  }
  ProportionnalValueChanged(source) {
    if (this._proportionnalValueChangeCallback != null)
      this._proportionnalValueChangeCallback(source);
  }
  getContainerInnerWidth() {
    return this.UIContainer.offsetWidth;
  }
  getContainerInnerHeight() {
    return this.UIContainer.offsetHeight;
  }
  Draw(timestamp) {
    if (!this.canRedraw())
      return 0;
    let w = this.getContainerInnerWidth();
    let h = this.getContainerInnerHeight();
    if (w <= 5 || h <= 5)
      return 0;
    this.DisableRedraw();
    let offscreenCanvas = document.createElement("canvas");
    offscreenCanvas.width = w;
    offscreenCanvas.height = h;
    let g = new YGraphics(offscreenCanvas, w, h, 90);
    let start = performance.now();
    try {
      this.Render(g, w, h);
    } catch (e) {
      debugger;
      this.log("Rendering error: " + e.message);
    }
    let elapsed = performance.now() - start;
    let drawArea = this.UIContainer.getContext("2d");
    drawArea.clearRect(0, 0, w, h);
    drawArea.drawImage(offscreenCanvas, 0, 0);
    this.rendererTimingTotal += elapsed;
    this.rendererTimingCount++;
    let avg = this.rendererTimingTotal / this.rendererTimingCount;
    g.Dispose();
    this.AllowRedrawNoRefresh();
    this.renderingPostProcessing();
    return 0;
  }
  renderingPostProcessing() {
  }
  get resizeRule() {
    return this._resizeRule;
  }
  set resizeRule(value) {
    if (value != this._resizeRule) {
      this.DisableRedraw();
      this._resizeRule = value;
      for (let i = 0; i < this.ProportionalToSizeValues.length; i++) {
        this.ProportionalToSizeValues[i].resizeRule = this._resizeRule;
      }
      this.AllowRedraw();
      this.redraw();
    }
  }
  redraw() {
    if (!(document.visibilityState === "visible"))
      return;
    if (this._redrawAllowed > 0)
      return;
    if (this.getContainerInnerWidth() < 2)
      return;
    if (this.getContainerInnerHeight() < 2)
      return;
    if (this.requestAnimationFrameID != null) {
      window.cancelAnimationFrame(this.requestAnimationFrameID);
    }
    this.requestAnimationFrameID = window.requestAnimationFrame((timestamp) => {
      try {
        this.Draw(timestamp);
      } catch (e) {
        console.log("caught");
        this.requestAnimationFrameID = null;
        throw e;
      }
      this.requestAnimationFrameID = null;
    });
  }
  usableUiWidth() {
    return this.getContainerInnerWidth();
  }
  usableUiHeight() {
    return this.getContainerInnerHeight();
  }
  resetProportionalSizeObjectsCachePush(newcoef) {
    this.clearCachedObjects();
    if (this._resizeRule != Proportional.ResizeRule.FIXED) {
      for (let i = 0; i < this.ProportionalToSizeValues.length; i++) {
        this.ProportionalToSizeValues[i].containerResizedPushNewCoef(newcoef);
      }
    }
  }
  resetProportionalSizeObjectsCachePop() {
    this.clearCachedObjects();
    if (this._resizeRule != Proportional.ResizeRule.FIXED) {
      for (let i = 0; i < this.ProportionalToSizeValues.length; i++) {
        this.ProportionalToSizeValues[i].containerResizedPop();
      }
    }
  }
  resetProportionalSizeObjectsCache(w, h) {
    this.clearCachedObjects();
    if (this._resizeRule != Proportional.ResizeRule.FIXED) {
      for (let i = 0; i < this.ProportionalToSizeValues.length; i++) {
        this.ProportionalToSizeValues[i].containerResized(w, h);
      }
    }
  }
  containerResized() {
    this.containerResize(null, null);
  }
  containerResize(sender, e) {
    this.clearTransformationMatrix();
    this.DisableRedraw();
    this.UIContainer.width = this.UIContainer.offsetWidth;
    this.UIContainer.height = this.UIContainer.offsetHeight;
    this.resetProportionalSizeObjectsCache(this.usableUiWidth(), this.usableUiHeight());
    this.AllowRedraw();
    this.redraw();
  }
  proportionnalsizeReset() {
    this.resetProportionalSizeObjectsCache(this.usableUiWidth(), this.usableUiHeight());
  }
  captureAndDownloadImage(captureType, defaultFilename, captureWidth, captureHeight, captureDPI) {
    let error = "";
    let w;
    let h;
    let ratio = this.getContainerInnerWidth() / this.getContainerInnerHeight();
    if (captureDPI == null)
      captureDPI = 90;
    if (defaultFilename == null || typeof defaultFilename == "undefined") {
      defaultFilename = "capture.";
      if (captureType == _YDataRenderer.CaptureType.PNG) {
        defaultFilename = defaultFilename + "png";
      }
      if (captureType == _YDataRenderer.CaptureType.SVG) {
        defaultFilename = defaultFilename + "svg";
      }
    }
    if (captureWidth == null || typeof captureWidth == "undefined") {
      w = this.getContainerInnerWidth();
      if (captureHeight == null || typeof captureHeight == "undefined") {
        h = this.getContainerInnerHeight();
      } else {
        h = captureHeight >> 0;
        w = h * ratio >> 0;
      }
    } else {
      w = captureWidth >> 0;
      if (captureHeight == null || typeof captureHeight == "undefined") {
        h = w * ratio >> 0;
      } else {
        h = captureHeight >> 0;
      }
    }
    if (w <= 5 || h <= 5)
      return;
    this.DisableRedraw();
    if (captureType == _YDataRenderer.CaptureType.SVG) {
      w = Math.round(w / 1.371);
      h = Math.round(h / 1.371);
    }
    let DrawArea = document.createElement("canvas");
    DrawArea.width = w;
    DrawArea.height = h;
    let g;
    switch (captureType) {
      case _YDataRenderer.CaptureType.PNG:
        g = new YGraphics(DrawArea, w, h, captureDPI);
        break;
      case _YDataRenderer.CaptureType.SVG:
        g = new YGraphicsSVG(DrawArea, w, h, captureDPI);
        break;
      default:
        throw new RangeError("capture :unknown type");
    }
    let newCoef = Proportional.resizeCoef(Proportional.ResizeRule.RELATIVETOBOTH, this.refWidth, this.refHeight, w, h);
    this.log("start capture");
    this.resetProportionalSizeObjectsCachePush(newCoef);
    let renderok = false;
    this._snapshotPanel.enabled = false;
    try {
      let t = this.Render(g, w, h);
      renderok = true;
    } catch (e) {
      error = e.message;
      this.log("Render error: " + error);
    }
    this.log("capture completed");
    this.resetProportionalSizeObjectsCachePop();
    if (renderok) {
      let element = document.createElement("a");
      let data = g.get_downloadableData();
      element.setAttribute("href", data);
      element.setAttribute("download", defaultFilename);
      element.style.display = "none";
      document.body.appendChild(element);
      element.click();
      document.body.removeChild(element);
    }
    g.Dispose();
    this.AllowRedraw();
  }
  getFocus(sender, e) {
    this.log("got focus");
  }
  gainFocus() {
  }
  lostFocus(sender, e) {
  }
  get AllowPrintScreenCapture() {
    return this._AllowPrintScreenCapture;
  }
  set AllowPrintScreenCapture(value) {
    this._AllowPrintScreenCapture = value;
  }
  constructor(UIContainer, logFunction) {
    this._redrawAllowed = 1;
    this._refWidth = 1;
    this._refHeight = 1;
    this.rendererTimingTotal = 0;
    this.rendererTimingCount = 0;
    this._PatchAnnotationCallback = null;
    this._logFunction = null;
    this._annotationPanels = [];
    this._userData = null;
    this.documentVisibiltyChangeFct = null;
    this.containerResizedFct = null;
    this._getCaptureParameters = null;
    this.OnDblClick = null;
    this.OnRightClick = null;
    this._messagePanels = [];
    this._Scr2ElmMatrix = null;
    this._Elm2ScrMatrix = null;
    this.ProportionalToSizeValues = [];
    this._proportionnalValueChangeCallback = null;
    this._resizeRule = Proportional.ResizeRule.FIXED;
    this.requestAnimationFrameID = null;
    this._snapshotPanel = null;
    this._snapshotTimer = null;
    this._AllowPrintScreenCapture = false;
    if (!_YDataRenderer.globalMouseMoveSet) {
      document.addEventListener("mousemove", (e) => {
        _YDataRenderer.globalMouseMove(e);
      });
      _YDataRenderer.globalMouseMoveSet = true;
    }
    this.UIContainer = UIContainer;
    this.UIContainer.width = this.getContainerInnerWidth();
    this.UIContainer.height = this.getContainerInnerHeight();
    this._logFunction = logFunction;
    this.parentForm = UIContainer.ownerDocument;
    this._annotationPanels = [];
    this._messagePanels = [];
    this.DisableRedraw();
    this._snapshotPanel = this.addMessagePanel();
    this._snapshotPanel.panelTextAlign = MessagePanel.TextAlign.CENTER;
    this._snapshotPanel.text = "Captured to clipboard";
    this._snapshotPanel.panelHrzAlign = MessagePanel.HorizontalAlignPos.CENTER;
    this._snapshotPanel.panelVrtAlign = MessagePanel.VerticalAlignPos.CENTER;
    this._snapshotPanel.bgColor = new YColor(false, 200, 204, 247, 161);
    this._snapshotPanel.font.size = 16;
    this.AllowRedrawNoRefresh();
    this.containerResizedFct = () => {
      this.containerResize(null, null);
    };
    document.addEventListener("resize", this.containerResizedFct);
    this.resetRefrenceSize();
    this.documentVisibiltyChangeFct = () => {
      if (document.visibilityState === "visible") {
        this.redraw();
      }
    };
    document.addEventListener("visibilitychange", this.documentVisibiltyChangeFct);
  }
  destroy() {
    document.removeEventListener("visibilitychange", this.documentVisibiltyChangeFct);
    document.removeEventListener("resize", this.containerResized);
    this.UIContainer.parentNode.removeChild(this.UIContainer);
    this.UIContainer = null;
    this.parentForm = null;
    this._annotationPanels = null;
    this._messagePanels = null;
    this._Scr2ElmMatrix = null;
    this._Elm2ScrMatrix = null;
  }
  resetRefrenceSize() {
    this._refWidth = this.getContainerInnerWidth();
    this._refHeight = this.getContainerInnerHeight();
  }
  get refWidth() {
    return this._refWidth;
  }
  get refHeight() {
    return this._refHeight;
  }
  RendererCanvas_Click(sender, e) {
  }
  RendererCanvas_DoubleClick(sender, e) {
  }
  addMessagePanel() {
    let p = new MessagePanel(this, this);
    this._messagePanels.push(p);
    return p;
  }
  DrawMessagePanels(g, viewPortWidth, viewPortHeight) {
    for (let i = 0; i < this._messagePanels.length; i++) {
      if (this._messagePanels[i].enabled) {
        let p = this._messagePanels[i];
        let AvailableWidth = viewPortWidth - 2 * p.padding - p.borderthickness;
        if (AvailableWidth < 100)
          AvailableWidth = 100;
        let ssize = null;
        let sizeok = false;
        while (!sizeok) {
          ssize = g.MeasureString(p.text, p.font, AvailableWidth);
          if ((ssize.width >= this.UIContainer.width || ssize.height >= this.UIContainer.height) && p.font.size > 5) {
            p.font.size = Math.round(p.font.size * 9) / 10;
          } else
            sizeok = true;
        }
        if (ssize == null)
          return;
        let panelWidth = ssize.width + 2 * p.padding + p.borderthickness;
        let panelHeight = ssize.height + 2 * p.padding + p.borderthickness;
        let x = 0;
        switch (p.panelHrzAlign) {
          case MessagePanel.HorizontalAlignPos.LEFT:
            x = p.horizontalMargin;
            break;
          case MessagePanel.HorizontalAlignPos.RIGHT:
            x = viewPortWidth - panelWidth - p.horizontalMargin;
            break;
          default:
            x = (viewPortWidth - panelWidth) / 2;
            break;
        }
        let y = 0;
        switch (p.panelVrtAlign) {
          case MessagePanel.VerticalAlignPos.TOP:
            y = p.verticalMargin;
            break;
          case MessagePanel.VerticalAlignPos.BOTTOM:
            y = viewPortHeight - panelHeight - p.verticalMargin;
            break;
          default:
            y = (viewPortHeight - panelHeight) / 2;
            break;
        }
        g.FillRectangleXYHW(p.bgBrush, x, y, panelWidth, panelHeight);
        if (p.borderthickness > 0)
          g.DrawRectangleXYHW(p.pen, x, y, panelWidth, panelHeight);
        let sf = new YStringFormat(
          16384
          /* YStringFormat.StringFormatFlags.NoClip */
        );
        switch (p.panelTextAlign) {
          case MessagePanel.TextAlign.LEFT:
            sf.LineAlignment = 0;
            sf.Alignment = 0;
            break;
          case MessagePanel.TextAlign.RIGHT:
            sf.LineAlignment = 2;
            sf.Alignment = 2;
            break;
          default:
            sf.LineAlignment = 1;
            sf.Alignment = 1;
            break;
        }
        let r = new YRectangle(x + p.padding + p.borderthickness / 2 >> 0, y + p.padding + p.borderthickness / 2 >> 0, ssize.width + 1, ssize.height + 1);
        g.DrawStringRect(p.text, p.font, p.font.brush, r, sf);
      }
    }
  }
  drawAnnotationPanels(g, annotationPanels, viewPortWidth, viewPortHeight, overlap, mainViewPort) {
    let active = false;
    for (let i = 0; i < this.annotationPanels.length; i++) {
      if (this.annotationPanels[i].enabled)
        active = true;
    }
    if (!active)
      return;
    for (let i = 0; i < this.annotationPanels.length; i++) {
      if (annotationPanels[i].enabled && annotationPanels[i].overlap == overlap) {
        let p = annotationPanels[i];
        let AvailableWidth = viewPortWidth - 2 * p.padding - p.borderthickness;
        if (AvailableWidth < 100)
          AvailableWidth = 100;
        let textToDisplay = p.text.replace("\\n", "\n");
        if (textToDisplay.indexOf("$") >= 0) {
          textToDisplay = textToDisplay.replace("\\n", "\n");
          textToDisplay = this.patchAnnotation(textToDisplay);
        }
        let ssize = g.MeasureString(textToDisplay, p.font, AvailableWidth);
        let panelWidth = ssize.width + 2 * p.padding + p.borderthickness;
        let panelHeight = ssize.height + 2 * p.padding + p.borderthickness;
        let x = 0;
        switch (p.panelHrzAlign) {
          case MessagePanel.HorizontalAlignPos.LEFT:
            x = p.horizontalMargin;
            if (!annotationPanels[i].overlap && mainViewPort.Lmargin < panelWidth + 10) {
              mainViewPort.Lmargin = panelWidth + 10;
            }
            break;
          case MessagePanel.HorizontalAlignPos.RIGHT:
            x = viewPortWidth - panelWidth - p.horizontalMargin;
            if (!annotationPanels[i].overlap && mainViewPort.Rmargin < panelWidth + 20) {
              mainViewPort.Rmargin = panelWidth + 20;
            }
            break;
          default:
            x = (viewPortWidth - panelWidth) / 2;
            break;
        }
        let y = 0;
        switch (p.panelVrtAlign) {
          case MessagePanel.VerticalAlignPos.TOP:
            y = p.verticalMargin;
            if (!annotationPanels[i].overlap && mainViewPort.Tmargin < panelHeight + 20) {
              mainViewPort.Tmargin = panelHeight + 20;
            }
            break;
          case MessagePanel.VerticalAlignPos.BOTTOM:
            y = viewPortHeight - panelHeight - p.verticalMargin;
            if (!annotationPanels[i].overlap && mainViewPort.Bmargin < panelHeight + 20) {
              mainViewPort.Bmargin = panelHeight + 20;
            }
            break;
          default:
            y = (viewPortHeight - panelHeight) / 2;
            break;
        }
        if (annotationPanels[i].overlap) {
          x += annotationPanels[i].positionOffsetX / 100 * (viewPortWidth - panelWidth);
          y += annotationPanels[i].positionOffsetY / 100 * (viewPortHeight - panelHeight);
          if (x < 0)
            x = 0;
          if (y < 0)
            y = 0;
          if (x > viewPortWidth - panelWidth)
            x = viewPortWidth - panelWidth;
          if (y > viewPortHeight - panelHeight)
            y = viewPortHeight - panelHeight;
        }
        g.FillRectangleXYHW(p.bgBrush, x, y, panelWidth, panelHeight);
        if (p.borderthickness > 0)
          g.DrawRectangleXYHW(p.pen, x, y, panelWidth, panelHeight);
        let sf = new YStringFormat(
          16384
          /* YStringFormat.StringFormatFlags.NoClip */
        );
        switch (p.panelTextAlign) {
          case MessagePanel.TextAlign.LEFT:
            sf.LineAlignment = 0;
            sf.Alignment = 0;
            break;
          case MessagePanel.TextAlign.RIGHT:
            sf.LineAlignment = 2;
            sf.Alignment = 2;
            break;
          default:
            sf.LineAlignment = 1;
            sf.Alignment = 1;
            break;
        }
        let r = new YRectangle(x + p.padding + p.borderthickness / 2, y + p.padding + p.borderthickness / 2, ssize.width + 1, ssize.height + 1);
        g.DrawStringRect(textToDisplay, p.font, p.font.brush, r, sf);
      }
    }
  }
  log(s) {
    if (this._logFunction == null)
      return;
    this._logFunction(s);
  }
};
YDataRenderer.RendererDebug = false;
YDataRenderer.FloatToStrformats = ["0", "0", "0", "0.0", "0.00", "0.000", "0.0000"];
YDataRenderer._disableMinMaxCheck = false;
YDataRenderer.globalMouseMoveSet = false;
YDataRenderer.globalMouseX = -1;
YDataRenderer.globalMouseY = -1;
(function(YDataRenderer2) {
  class CaptureTypeEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, CaptureType);
    }
  }
  YDataRenderer2.CaptureTypeEnumItem = CaptureTypeEnumItem;
  class CaptureType extends YEnum {
  }
  CaptureType.PNG = new CaptureTypeEnumItem("PNG", "Bitmap (PNG)");
  CaptureType.SVG = new CaptureTypeEnumItem("SVG", "Vector (SVG)");
  YDataRenderer2.CaptureType = CaptureType;
  class CaptureTargetEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, CaptureTarget);
    }
  }
  YDataRenderer2.CaptureTargetEnumItem = CaptureTargetEnumItem;
  class CaptureTarget extends YEnum {
  }
  CaptureTarget.ToClipBoard = new CaptureTargetEnumItem("ToClipBoard", "ClipBoard");
  CaptureTarget.ToFile = new CaptureTargetEnumItem("ToFile", "File");
  YDataRenderer2.CaptureTarget = CaptureTarget;
  class CaptureFormatsEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, CaptureFormats);
    }
  }
  YDataRenderer2.CaptureFormatsEnumItem = CaptureFormatsEnumItem;
  class CaptureFormats extends YEnum {
  }
  CaptureFormats.Keep = new CaptureFormatsEnumItem("Keep", "Keep original size");
  CaptureFormats.Fixed = new CaptureFormatsEnumItem("Fixed", "Fixed size");
  CaptureFormats.FixedWidth = new CaptureFormatsEnumItem("FixedWidth", "Fixed width, keep ration aspect");
  CaptureFormats.FixedHeight = new CaptureFormatsEnumItem("FixedHeight", "Fixed height, keep ration aspect");
  YDataRenderer2.CaptureFormats = CaptureFormats;
})(YDataRenderer || (YDataRenderer = {}));
var YGraphics = class _YGraphics {
  constructor(canvas, width, height, dpi) {
    this._c = null;
    this._g = null;
    this._width = 0;
    this._height = 0;
    this._dpi = 0;
    this._image = null;
    this._lastPen = null;
    this._lastBrush = null;
    this._lastFont = null;
    this._clipCounter = 0;
    this._textRenderingHint = null;
    this._smoothingMode = YSmoothingMode.Default;
    this._c = canvas;
    this._g = this._c.getContext("2d");
    this._g.textBaseline = "top";
    this._width = width;
    this._height = height;
    this._dpi = dpi;
  }
  get_downloadableData() {
    return this._c.toDataURL("image/png");
  }
  get graphics() {
    return this._g;
  }
  setPen(p) {
    if (p == this._lastPen)
      return;
    if (p != null) {
      this._g.lineWidth = p.lineWidth;
      let st = p.strokeStyle;
      this._g.strokeStyle = p.strokeStyle;
    } else {
      this._g.lineWidth = 0;
    }
    this._lastPen = p;
  }
  setBrush(b) {
    if (b == this._lastBrush)
      return;
    if (b instanceof YSolidBrush) {
      this._g.fillStyle = b.color.htmlCode;
    } else if (b instanceof YLinearGradientBrush) {
      let lingrad = this._g.createLinearGradient(0, 0, 0, this._height);
      lingrad.addColorStop(0, b.color1.htmlCode);
      lingrad.addColorStop(1, b.color2.htmlCode);
      this._g.fillStyle = lingrad;
    } else {
      throw new Error("invalid / insupported brush type");
    }
    this._lastBrush = b;
  }
  setFont(f) {
    if (f == this._lastFont && !f.hasChanged)
      return;
    this._g.font = f.htmlCode;
    this._lastFont = f;
  }
  DrawLineXY(p, x1, y1, x2, y2) {
    if (p.noAntiAlias) {
      let offset = p.lineWidth == p.lineWidth >> 0 && (p.lineWidth & 1) == 1 ? 0.5 : 0;
      x1 = Math.round(x1) + offset;
      y1 = Math.round(y1) + offset;
      x2 = Math.round(x2) + offset;
      y2 = Math.round(y2) + offset;
    }
    this.setPen(p);
    this._g.beginPath();
    this._g.moveTo(x1, y1);
    this._g.lineTo(x2, y2);
    this._g.stroke();
  }
  DrawLine(p, p1, p2) {
    this.setPen(p);
    this._g.beginPath();
    this._g.moveTo(p1.X, p1.Y);
    this._g.lineTo(p2.X, p2.Y);
    this._g.stroke();
  }
  SetClip(rect) {
    this._g.save();
    this._g.beginPath();
    this._g.rect(rect.x, rect.y, rect.w, rect.h);
    this._g.clip();
    this._clipCounter++;
  }
  ResetClip() {
    if (this._clipCounter <= 0)
      throw new Error("clipping stack error");
    this._g.restore();
    this._clipCounter--;
  }
  MeasureString(text, font, width) {
    this.setFont(font);
    let res = new YSizeF(font, text);
    let count = res.linesCount;
    if (count == 0)
      return res;
    res.height = res.firstLineHeight * 1.2 + (count - 1) * res.lineHeight;
    let max = 0;
    let dim;
    for (let i = 0; i < count; i++) {
      dim = this._g.measureText(res.lines[i]);
      max = Math.max(max, dim.width);
    }
    res.width = max;
    return res;
  }
  MeasureStringSF(text, font, width, stringFormat) {
    return this.MeasureString(text, font, width);
  }
  FillRectangle(brush, rect) {
    this.setBrush(brush);
    this._g.beginPath();
    this._g.fillRect(rect.x, rect.y, rect.w, rect.h);
    this._g.fill();
  }
  FillRectangleXYHW(brush, x, y, width, height) {
    this.setBrush(brush);
    this._g.beginPath();
    this._g.fillRect(x, y, width, height);
    this._g.fill();
  }
  DrawRectangle(p, rect) {
    this.setPen(p);
    this._g.beginPath();
    if (p.noAntiAlias) {
      let offset = p.lineWidth == p.lineWidth >> 0 && (p.lineWidth & 1) == 1 ? 0.5 : 0;
      this._g.rect(Math.round(rect.x) + offset, Math.round(rect.y) + offset, Math.round(rect.w), Math.round(rect.h));
    } else {
      this._g.rect(rect.x, rect.y, rect.w, rect.h);
    }
    this._g.stroke();
  }
  DrawRectangleXYHW(p, x, y, width, height) {
    if (p.noAntiAlias) {
      let offset = p.lineWidth == p.lineWidth >> 0 && (p.lineWidth & 1) == 1 ? 0.5 : 0;
      x = Math.round(x) + offset;
      y = Math.round(y) + offset;
      width = Math.round(width);
      height = Math.round(height);
    }
    this.setPen(p);
    this._g.beginPath();
    this._g.rect(x, y, width, height);
    this._g.stroke();
  }
  DrawStringXY(s, font, brush, x, y) {
    this.setPen(null);
    this.setBrush(brush);
    this.setFont(font);
    let totalsz = this.MeasureString(s, font, 0);
    let dy = totalsz.lineHeight;
    for (let i = 0; i < totalsz.linesCount; i++) {
      this._g.fillText(totalsz.lines[i], x, y);
      y += dy;
    }
  }
  DrawStringXYF(s, font, brush, x, y, format) {
    if (_YGraphics._debugDrawString) {
      let pen = new YPen(YColor.Red, 1);
      this.DrawLineXY(pen, x - 5, y, x + 5, y);
      this.DrawLineXY(pen, x, y - 5, x, y + 5);
    }
    let sz = this.MeasureString(s, font, 1e4);
    if (format.Alignment == 1) {
      x -= sz.width >> 1;
    } else if (format.Alignment == 2)
      x -= sz.width;
    if (format.LineAlignment == 1) {
      y -= sz.height / 2 >> 0;
    } else if (format.LineAlignment == 2)
      y -= sz.height;
    this.DrawStringXY(s, font, brush, x, y);
  }
  DrawStringPF(s, font, brush, p, format) {
    this.DrawStringXYF(s, font, brush, p.X, p.Y, format);
  }
  DrawString(s, font, brush, p) {
    if (_YGraphics._debugDrawString) {
      let pen = new YPen(YColor.Red, 1);
      this.DrawLineXY(pen, p.X - 5, p.Y, p.X + 5, p.Y);
      this.DrawLineXY(pen, p.X, p.Y - 5, p.X, p.Y + 5);
    }
    this.setPen(null);
    this.setBrush(brush);
    this.setFont(font);
    this._g.fillText(s, p.X, p.Y);
  }
  DrawStringRect(s, font, brush, layoutRectangle, format) {
    if (_YGraphics._debugDrawString) {
      let pen = new YPen(YColor.Red, 1);
      this.DrawRectangle(pen, layoutRectangle);
    }
    this.setPen(null);
    this.setBrush(brush);
    this.setFont(font);
    let totalsz = this.MeasureString(s, font, 0);
    let dy = totalsz.lineHeight;
    let y = layoutRectangle.y;
    switch (format.LineAlignment) {
      case 0:
        break;
      case 1:
        y += (layoutRectangle.h - totalsz.height) / 2;
        break;
      case 2:
        y += layoutRectangle.h - totalsz.height;
        break;
    }
    let xOrigin = layoutRectangle.x;
    if (format.FormatFlags & 2) {
      this.Transform(layoutRectangle.x, layoutRectangle.y, Math.PI / 2);
      y -= layoutRectangle.y + layoutRectangle.w;
      xOrigin -= layoutRectangle.x;
    }
    for (let i = 0; i < totalsz.linesCount; i++) {
      let s2 = totalsz.lines[i];
      let sz = this.MeasureString(s2, font, 0);
      let x = xOrigin;
      switch (format.Alignment) {
        case 0:
          break;
        case 1:
          x += (layoutRectangle.w - sz.width) / 2;
          break;
        case 2:
          x += layoutRectangle.w - sz.width;
          break;
      }
      this._g.fillText(s2, x, y);
      y += dy;
    }
    if (format.FormatFlags & 2)
      this.ResetTransform();
  }
  Transform(dx, dy, angle) {
    let sin = Math.sin(angle);
    let cos = Math.cos(angle);
    this._g.save();
    this._g.transform(cos, sin, -sin, cos, dx, dy);
  }
  ResetTransform() {
    this._g.restore();
  }
  FillEllipse(brush, x, y, width, height) {
    this.setBrush(brush);
    this._g.beginPath();
    this._g.ellipse(x + width / 2, y + height / 2, width / 2, height / 2, 0, 0, 2 * Math.PI);
    this._g.fill();
  }
  DrawEllipse(pen, x, y, width, height) {
    this.setPen(pen);
    this._g.beginPath();
    this._g.ellipse(x + width / 2, y + height / 2, width / 2, height / 2, 0, 0, 2 * Math.PI);
    this._g.stroke();
  }
  FillPolygon(brush, points) {
    this.setBrush(brush);
    if (points.length <= 2)
      return;
    this._g.beginPath();
    if (brush.noAntiAlias) {
      this._g.moveTo(Math.round(points[0].X) + 0.5, Math.round(points[0].Y) + 0.5);
      for (let i = 1; i < points.length; i++) {
        this._g.lineTo(Math.round(points[i].X) + 0.5, Math.round(points[i].Y) + 0.5);
      }
    } else {
      this._g.moveTo(points[0].X, points[0].Y);
      for (let i = 1; i < points.length; i++) {
        this._g.lineTo(points[i].X, points[i].Y);
      }
    }
    this._g.closePath();
    this._g.fill();
  }
  DrawPolygon(pen, points) {
    this.setPen(pen);
    if (points.length <= 1)
      return;
    this._g.beginPath();
    if (pen.noAntiAlias) {
      let offset = pen.lineWidth == pen.lineWidth >> 0 && (pen.lineWidth & 1) == 1 ? 0.5 : 0;
      this._g.moveTo(Math.round(points[0].X) + offset, Math.round(points[0].Y) + offset);
      for (let i = 1; i < points.length; i++) {
        this._g.lineTo(Math.round(points[i].X) + offset, Math.round(points[i].Y) + offset);
      }
    } else {
      this._g.moveTo(points[0].X, points[0].Y);
      for (let i = 1; i < points.length; i++) {
        this._g.lineTo(points[i].X, points[i].Y);
      }
    }
    this._g.closePath();
    this._g.stroke();
  }
  DrawLines(pen, points) {
    this.setPen(pen);
    if (points.length <= 1)
      return;
    this._g.beginPath();
    this._g.lineCap = "round";
    this._g.lineJoin = "round";
    this._g.moveTo(points[0].X, points[0].Y);
    for (let i = 1; i < points.length; i++) {
      this._g.lineTo(points[i].X, points[i].Y);
    }
    this._g.stroke();
  }
  Dispose() {
    this._c = null;
    this._g = null;
    this._width = 0;
    this._height = 0;
    this._dpi = 0;
  }
  get TextRenderingHint() {
    return this._textRenderingHint;
  }
  set TextRenderingHint(value) {
    this._textRenderingHint = value;
  }
  get SmoothingMode() {
    return this._smoothingMode;
  }
  set SmoothingMode(value) {
    this._smoothingMode = value;
  }
  DrawImage(srcimage, destRect, srcRect, srcUnit) {
    this._g.drawImage(srcimage, srcRect.x, srcRect.y, srcRect.w, srcRect.h, destRect.x, destRect.y, destRect.w, destRect.h);
  }
  comment(s) {
  }
};
YGraphics._debugDrawString = false;
var YGraphicsSVG = class _YGraphicsSVG extends YGraphics {
  constructor(canvas, width, height, dpi) {
    super(canvas, width, height, dpi);
    this._clipcount = 0;
    this._clipSectionsToClose = 0;
    this._transformSectionsToClose = 0;
    this._gradientCount = 0;
    _YGraphicsSVG.SVGID++;
    this._SVGdefs = new YStringBuilder();
    this._SVGcontents = new YStringBuilder();
    this._SVGdefs.AppendLine('<clipPath id="pageClip_' + _YGraphicsSVG.SVGID.toString() + '"><rect x="0" y="0"  width="' + width.toString() + '" height="' + height.toString() + '"/></clipPath>');
  }
  static escapeXml(unsafe) {
    return unsafe.replace(/[^ !#$%(-;=?-z]/g, (c) => "&#" + c.charCodeAt(0) + ";");
  }
  get_downloadableData() {
    return "data:image/svg+xml;base64," + btoa(this.get_svgContents());
  }
  DrawLineXY(p, x1, y1, x2, y2) {
    this._SVGcontents.AppendLine('<line x1="' + x1.toString() + '"  y1 ="' + y1.toString() + '"  x2 ="' + x2.toString() + '"  y2 ="' + y2.toString() + '" style = "stroke:' + p.color.svgCode + ";stroke-opacity:" + p.color.alphaCode + "; stroke-width:" + p.lineWidth.toString() + '"/>');
  }
  DrawLine(p, p1, p2) {
    this.DrawLineXY(p, p1.X, p1.Y, p2.X, p2.Y);
  }
  SetClip(rect) {
    this.ResetClip();
    this._SVGdefs.AppendLine('<clipPath id="clip_' + _YGraphicsSVG.SVGID.toString() + "_" + this._clipcount.toString() + '"><rect x="' + rect.x.toString() + '" y="' + rect.y.toString() + '"  width="' + rect.w.toString() + '" height="' + rect.h.toString() + '"/></clipPath>');
    this._SVGcontents.AppendLine('<g clip-path="url(#clip_' + _YGraphicsSVG.SVGID.toString() + "_" + this._clipcount.toString() + ')">');
    this._clipcount++;
    this._clipSectionsToClose++;
  }
  ResetClip() {
    if (this._clipSectionsToClose > 0) {
      this._SVGcontents.AppendLine("</g>");
      this._clipSectionsToClose--;
    }
  }
  BrushToSVG(brush, revert) {
    let fillParam = "";
    if (brush instanceof YSolidBrush) {
      fillParam = 'fill = "' + brush.color.svgCode + '" fill-opacity="' + brush.color.alphaCode + '" ';
    } else if (brush instanceof YLinearGradientBrush) {
      this._SVGdefs.AppendLine('<linearGradient id="grad_' + _YGraphicsSVG.SVGID.toString() + "_" + this._gradientCount + '" x1="0%" ' + (revert ? 'y1="100%" ' : 'y1="0%" ') + 'x2="0%" ' + (revert ? 'y2="0%" ' : 'y2="100%" ') + '>\r\n<stop offset="0%" style ="stop-color:' + brush.color1.svgCode + ";stop-opacity:" + brush.color1.alphaCode + '"/>\r\n<stop offset="100%" style ="stop-color:' + brush.color2.svgCode + ";stop-opacity:" + brush.color2.alphaCode + '"/>\r\n</linearGradient>');
      fillParam = 'fill="url(#grad_' + _YGraphicsSVG.SVGID.toString() + "_" + this._gradientCount + ')" ';
      this._gradientCount++;
    } else {
      throw new ReferenceError("unsupported brush type.");
    }
    return fillParam;
  }
  FillRectangle(brush, rect) {
    this._SVGcontents.AppendLine('<rect x="' + rect.x.toString() + '"  y ="' + rect.y.toString() + '"  width ="' + rect.w.toString() + '"  height ="' + rect.h.toString() + '" ' + this.BrushToSVG(brush, true) + 'style="stroke-width:0"/>');
  }
  FillRectangleXYHW(brush, x, y, width, height) {
    this.FillRectangle(brush, new YRectangle(x, y, width, height));
  }
  DrawRectangle(p, rect) {
    this._SVGcontents.AppendLine('<rect x="' + rect.x.toString() + '"  y ="' + rect.y.toString() + '"  width ="' + rect.w.toString() + '"  height ="' + rect.h.toString() + '"  fill="none" style = "stroke:' + p.color.svgCode + ";stroke-opacity:" + p.color.alphaCode + "; stroke-width:" + p.lineWidth.toString() + '"/>');
  }
  DrawRectangleXYHW(p, x, y, width, height) {
    this.DrawRectangle(p, new YRectangle(x, y, width, height));
  }
  DrawEllipse(pen, x, y, width, height) {
    this._SVGcontents.AppendLine('<ellipse  cx="' + (x + width / 2).toString() + '"  cy ="' + (y + height / 2).toString() + '"  rx ="' + (width / 2).toString() + '"  ry ="' + (height / 2).toString() + '"  fill="none" style = "stroke:' + pen.color.svgCode + ";stroke-opacity:" + pen.color.alphaCode + "; stroke-width:" + pen.lineWidth.toString() + '"/>');
  }
  FillEllipse(brush, x, y, width, height) {
    this._SVGcontents.AppendLine('<ellipse  cx="' + (x + width / 2).toString() + '"  cy ="' + (y + height / 2).toString() + '"  rx ="' + (width / 2).toString() + '"  ry ="' + (height / 2).toString() + '" ' + this.BrushToSVG(brush, false) + 'style="stroke-width:0"/>');
  }
  DrawStringXY(s, font, brush, x, y) {
    let tokens = s.split("\n");
    for (let i = 0; i < tokens.length; i++) {
      s = tokens[i];
      this._SVGcontents.AppendLine('<text x="' + x.toString() + '" y="' + (y + font.sizeInPoints).toString() + '" text-anchor="start" font-family="' + font.name.toString() + '" font-size="' + font.sizeInPoints.toString() + 'pt" font-weight="' + (font.bold ? "bold" : "normal") + '" font-style="' + (font.italic ? "italic" : "normal") + '" ' + this.BrushToSVG(brush, false) + 'style="stroke-width:0">\r\n' + _YGraphicsSVG.escapeXml(s) + "\r\n</text>");
      y += font.sizeInPoints * 1.75;
    }
  }
  DrawString(s, font, brush, p) {
    if (YGraphics._debugDrawString) {
      let pen = new YPen(YColor.Red, 1);
      this.DrawLineXY(pen, p.X - 5, p.Y, p.X + 5, p.Y);
      this.DrawLineXY(pen, p.X, p.Y - 5, p.X, p.Y + 5);
    }
    this.DrawStringXY(s, font, brush, p.X, p.Y);
  }
  DrawStringF(s, font, brush, point, format) {
    let totalsz = this.MeasureString(s, font, 0);
    let y = point.Y + font.size * 1.25;
    switch (format.LineAlignment) {
      case 0:
        break;
      case 1:
        y += -totalsz.height / 2;
        break;
      case 2:
        y += -totalsz.height;
        break;
    }
    let tokens = s.split("\n");
    for (let i = 0; i < tokens.length; i++) {
      let s2 = tokens[i];
      let sz = this.MeasureString(s2, font, 0);
      let x = point.X;
      switch (format.Alignment) {
        case 0:
          break;
        case 1:
          x += -sz.width / 2;
          break;
        case 2:
          x += -sz.width;
          break;
      }
      this._SVGcontents.AppendLine('<text x="' + x.toString() + '" y="' + y.toString() + '" text-anchor="start" font-family="' + font.name.toString() + '" font-size="' + font.sizeInPoints.toString() + 'pt" font-weight="' + (font.bold ? "bold" : "normal") + '" font-style="' + (font.italic ? "italic" : "normal") + '" ' + this.BrushToSVG(brush, false) + 'style="stroke-width:0">\r\n' + _YGraphicsSVG.escapeXml(s2) + "\r\n</text>");
      y += font.sizeInPoints * 1.75;
    }
  }
  DrawStringRect(s, font, brush, layoutRectangle, format) {
    if (YGraphics._debugDrawString) {
      let pen = new YPen(YColor.Red, 1);
      this.DrawRectangle(pen, layoutRectangle);
    }
    let totalsz = this.MeasureString(s, font, 0);
    let y = layoutRectangle.y + font.sizeInPoints * 1.1;
    switch (format.LineAlignment) {
      case 0:
        break;
      case 1:
        y += (layoutRectangle.h - totalsz.height) / 2;
        break;
      case 2:
        y += layoutRectangle.h - totalsz.height;
        break;
    }
    let tokens = s.split("\n");
    for (let i = 0; i < tokens.length; i++) {
      let s2 = tokens[i];
      let sz = this.MeasureString(s2, font, 0);
      let x = layoutRectangle.x;
      switch (format.Alignment) {
        case 0:
          break;
        case 1:
          x += (layoutRectangle.w - sz.width) / 2;
          break;
        case 2:
          x += layoutRectangle.w - sz.width;
          break;
      }
      this._SVGcontents.AppendLine('<text x="' + x.toString() + '" y="' + y.toString() + '" text-anchor="start" font-family="' + font.name.toString() + '" font-size="' + (font.sizeInPoints * 1.1).toString() + 'pt" font-weight="' + (font.bold ? "bold" : "normal") + '" font-style="' + (font.italic ? "italic" : "normal") + '" ' + this.BrushToSVG(brush, false) + 'style="stroke-width:0">\r\n' + _YGraphicsSVG.escapeXml(s2) + "\r\n</text>");
      y += font.sizeInPoints * 1.75;
    }
  }
  Transform(dx, dy, angle) {
    this._SVGcontents.AppendLine('<g transform="translate(' + dx.toString() + " " + dy.toString() + ") rotate(" + (180 * angle / Math.PI).toString() + ')">');
    this._transformSectionsToClose++;
  }
  ResetTransform() {
    if (this._transformSectionsToClose > 0) {
      this._SVGcontents.AppendLine("</g>");
      this._transformSectionsToClose--;
    }
  }
  DrawPolygon(pen, points) {
    if (points.length < 2)
      return;
    this._SVGcontents.Append('<path  d="M ' + points[0].X.toString() + " " + points[0].Y.toString());
    for (let i = 1; i < points.length; i += 1) {
      this._SVGcontents.Append(" L " + points[i].X.toString() + " " + points[i].Y.toString());
    }
    this._SVGcontents.AppendLine(' z" fill="none" style="stroke:' + pen.color.svgCode + ";stroke-opacity:" + pen.color.alphaCode + "; stroke-width:" + pen.lineWidth.toString() + '"/>');
  }
  DrawLines(pen, points) {
    if (points.length < 2)
      return;
    this._SVGcontents.Append('<path  d="M ' + points[0].X.toString() + " " + points[0].Y.toString());
    for (let i = 1; i < points.length; i++) {
      this._SVGcontents.Append(" L " + points[i].X.toString() + " " + points[i].Y.toString());
    }
    this._SVGcontents.AppendLine('" fill="none" style="stroke:' + pen.color.svgCode + ";stroke-opacity:" + pen.color.alphaCode + "; stroke-linecap:round; stroke-linejoin:round;stroke-width:" + pen.lineWidth.toString() + '"/>');
  }
  FillPolygon(brush, points) {
    if (points.length < 2)
      return;
    this._SVGcontents.Append('<path  d="M ' + points[0].X.toString() + " " + points[0].Y.toString());
    for (let i = 1; i < points.length; i++) {
      this._SVGcontents.Append(" L " + points[i].X.toString() + " " + points[i].Y.toString());
    }
    this._SVGcontents.AppendLine(' z" ' + this.BrushToSVG(brush, false) + 'style="stroke-width:0"/>\r\n');
  }
  DrawImage(image, destRect, srcRect, srcUnit) {
    throw new Error("DrawImage not supported, find an other way.");
  }
  save(filename) {
    throw new Error("Direct save to file not supported.");
  }
  comment(s) {
    this._SVGcontents.AppendLine("<!--" + s + "-->");
  }
  get_svgContents() {
    let physicalWidth = (2.54 * (this._width / this._dpi)).toFixed(3);
    let physicalheight = (2.54 * (this._height / this._dpi)).toFixed(3);
    while (this._clipSectionsToClose > 0) {
      this._SVGcontents.AppendLine("</g>");
      this._clipSectionsToClose--;
    }
    while (this._transformSectionsToClose > 0) {
      this._SVGcontents.AppendLine("</g>");
      this._transformSectionsToClose--;
    }
    return '<?xml version = "1.0" standalone = "no" ?>\r\n<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">\r\n<svg width = "' + physicalWidth + 'cm" height = "' + physicalheight + 'cm" viewBox = "0 0 ' + this._width.toString() + " " + this._height.toString() + '" xmlns = "http://www.w3.org/2000/svg" version = "1.1" >\r\n<defs>\r\n' + this._SVGdefs.contents + '</defs>\r\n<g clip-path="url(#pageClip_' + _YGraphicsSVG.SVGID.toString() + ')">\r\n' + this._SVGcontents.contents + "</g>\r\n</svg>\n";
  }
};
YGraphicsSVG.SVGID = 0;

// obj/full/Renderer/YAngularGauge.js
var YAngularZone = class extends Zone {
  get path() {
    return this._path;
  }
  setPathSize(count) {
    this._path = new Array(count).fill(null);
  }
  setPathPoint(index, p) {
    this._path[index] = p;
  }
  resetPath() {
    this._path = null;
  }
  resetCache() {
    this.resetPath();
  }
  get width() {
    return this._width;
  }
  set width(value) {
    if (value <= 0)
      throw new RangeError("Width must be a positive value");
    this._width = value;
    this._path = null;
    this._parentRenderer.redraw();
  }
  get outerRadius() {
    return this._outerRadius;
  }
  set outerRadius(value) {
    this._outerRadius = Math.max(0, Math.min(100, value));
    this._path = null;
    this._parentRenderer.redraw();
  }
  constructor(parentRenderer, directParent) {
    super(parentRenderer, directParent);
    this._path = null;
    this._width = 10;
    this._outerRadius = 98;
  }
};
var YAngularGauge = class extends YDataRenderer {
  get min() {
    return this._min;
  }
  set min(value) {
    if (value >= this._max && !YDataRenderer.minMaxCheckDisabled) {
      throw new RangeError("Min cannot be greater than max (" + this._max.toString() + ")");
    }
    this._min = value;
    for (let i = 0; i < this._zones.length; i++) {
      this._zones[i].resetPath();
    }
    if (this._needleValue < this._min) {
      this._needleValue = this._min;
    }
    this.redraw();
  }
  get max() {
    return this._max;
  }
  set max(value) {
    if (value <= this._min && !YDataRenderer.minMaxCheckDisabled) {
      throw new RangeError("Max cannot be less than min (" + this._min.toString() + ")");
    }
    this._max = value;
    for (let i = 0; i < this._zones.length; i++) {
      this._zones[i].resetPath();
    }
    if (this._needleValue > this._max) {
      this._needleValue = this._max;
    }
    this.redraw();
  }
  get borderpen() {
    if (this._borderpen == null) {
      this._borderpen = new YPen(this._borderColor, this._borderThickness);
      this._borderpen.startCap = 1;
      this._borderpen.endCap = 1;
    }
    return this._borderpen;
  }
  get borderColor() {
    return this._borderColor;
  }
  set borderColor(value) {
    this._borderColor = value;
    this._borderpen = null;
    this.redraw();
  }
  get backgroundColor1() {
    return this._backgroundColor1;
  }
  set backgroundColor1(value) {
    this._backgroundColor1 = value;
    this._bgBrush = null;
    this.redraw();
  }
  get backgroundColor2() {
    return this._backgroundColor2;
  }
  set backgroundColor2(value) {
    this._backgroundColor2 = value;
    this._bgBrush = null;
    this.redraw();
  }
  get borderThickness() {
    return this._borderThickness;
  }
  set borderThickness(value) {
    if (value < 0)
      throw new RangeError("thickness must be a positive value");
    this._borderThickness = value;
    this._borderpen = null;
    this.redraw();
  }
  get valueFormater() {
    return this._valueFormater;
  }
  set valueFormater(value) {
    this._valueFormater = value;
    this.redraw();
  }
  get minmaxFormater() {
    return this._minmaxFormater;
  }
  set minmaxFormater(value) {
    this._minmaxFormater = value;
    this.redraw();
  }
  get thickness() {
    return this._thickness;
  }
  set thickness(value) {
    if (value < 0)
      throw new RangeError("Thickness must be a positive value");
    this._thickness = Math.max(Math.min(value, 80), 1);
    this.redraw();
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value;
    this.redraw();
  }
  get color1() {
    return this._color1;
  }
  set color1(value) {
    this._color1 = value;
    this.redraw();
  }
  get color2() {
    return this._color2;
  }
  set color2(value) {
    this._color2 = value;
    this.redraw();
  }
  get graduationColor() {
    return this._graduationColor;
  }
  set graduationColor(value) {
    this._graduationColor = value;
    this._graduationPen = null;
    this.redraw();
  }
  get graduationThickness() {
    return this._graduationThickness;
  }
  set graduationThickness(value) {
    if (value < 0)
      throw new RangeError("Thickness must be a positive value");
    this._graduationThickness = value;
    this._graduationPen = null;
    this.redraw();
  }
  get graduationSize() {
    return this._graduationSize;
  }
  set graduationSize(value) {
    if (value <= 0)
      throw new RangeError("Graduation size must be a positive value");
    this._graduationSize = value;
    this.redraw();
  }
  get graduation() {
    return this._graduation;
  }
  set graduation(value) {
    this._graduation = value;
    this.redraw();
  }
  get unitFactor() {
    return this._unitFactor;
  }
  set unitFactor(value) {
    if (value == 0)
      throw new RangeError("Factor cannot be zero.");
    this._unitFactor = value;
    this.redraw();
  }
  get unit() {
    return this._unit;
  }
  set unit(value) {
    this._unit = value;
    this.redraw();
  }
  get unitFont() {
    return this._unitFont;
  }
  get subgraduationColor() {
    return this._subgraduationColor;
  }
  set subgraduationColor(value) {
    this._subgraduationColor = value;
    this._subgraduationPen = null;
    this.redraw();
  }
  get subgraduationThickness() {
    return this._subgraduationThickness;
  }
  set subgraduationThickness(value) {
    if (value < 0)
      throw new RangeError("Thickness must be a positive value");
    this._subgraduationThickness = value;
    this._subgraduationPen = null;
    this.redraw();
  }
  get subgraduationSize() {
    return this._subgraduationSize;
  }
  set subgraduationSize(value) {
    if (value <= 0)
      throw new RangeError("Size must be a positive value");
    this._subgraduationSize = value;
    this.redraw();
  }
  get graduationOuterRadiusSize() {
    return this._graduationOuterRadiusSize;
  }
  set graduationOuterRadiusSize(value) {
    this._graduationOuterRadiusSize = Math.max(0, Math.min(100, value));
    this.redraw();
  }
  get subgraduationCount() {
    return this._subgraduationCount;
  }
  set subgraduationCount(value) {
    if (value < 0)
      throw new RangeError("Count must be a positive value");
    this._subgraduationCount = value;
    this.redraw();
  }
  get statusColor() {
    return this._statusColor;
  }
  set statusColor(value) {
    this._statusColor = value;
    this.redraw();
  }
  get statusFont() {
    return this._unitFont;
  }
  get statusLine() {
    return this._statusLine;
  }
  set statusLine(value) {
    this._statusLine = value;
    this.redraw();
  }
  get showNeedle() {
    return this._showNeedle;
  }
  set showNeedle(value) {
    this._showNeedle = value;
    this.redraw();
  }
  get needleColor() {
    return this._needleColor;
  }
  set needleColor(value) {
    this._needleColor = value;
    this._needleBrush = null;
    this.redraw();
  }
  get needleMaxSpeed() {
    return this._needleMaxSpeed;
  }
  set needleMaxSpeed(value) {
    if (value <= 0)
      throw new RangeError("Speed must be a positive value");
    this._needleMaxSpeed = value;
    this.redraw();
  }
  get needleLength1() {
    return this._needleLength1;
  }
  set needleLength1(value) {
    this._needleLength1 = value;
    this.redraw();
  }
  get needleLength2() {
    return this._needleLength2;
  }
  set needleLength2(value) {
    this._needleLength2 = value;
    this.redraw();
  }
  get needleWidth() {
    return this._needleWidth;
  }
  set needleWidth(value) {
    if (value <= 0)
      throw new RangeError("Width must be a positive value");
    this._needleWidth = value;
    this.redraw();
  }
  get needleContourColor() {
    return this._needleContourColor;
  }
  set needleContourColor(value) {
    this._needleContourColor = value;
    this._needleContourPen = null;
    this.redraw();
  }
  get needleContourThickness() {
    return this._needleContourThickness;
  }
  set needleContourThickness(value) {
    if (value < 0)
      throw new RangeError("Thickness must be a positive value");
    this._needleContourThickness = value;
    this._needleContourPen = null;
    this.redraw();
  }
  get graduationFont() {
    return this._graduationFont;
  }
  get showMinMax() {
    return this._showMinMax;
  }
  set showMinMax(value) {
    this._showMinMax = value;
    this.redraw();
  }
  constructor(UIContainer, logFunction) {
    super(UIContainer, logFunction);
    this._min = 0;
    this._max = 100;
    this.SegmentMaxLength = 8;
    this._borderpen = null;
    this._borderColor = YColor.Black;
    this._bgBrush = null;
    this._backgroundColor1 = YColor.FromArgb(255, 240, 240, 240);
    this._backgroundColor2 = YColor.FromArgb(255, 200, 200, 200);
    this._borderThickness = 5;
    this._valueFormater = null;
    this._minmaxFormater = null;
    this._thickness = 20;
    this._value = 0;
    this._needleValue = 0;
    this._color1 = YColor.Green;
    this._color2 = YColor.Red;
    this._graduationPen = null;
    this._graduationColor = YColor.Black;
    this._graduationThickness = 2;
    this._graduationSize = 10;
    this._graduation = 10;
    this._unitFactor = 1;
    this._unit = "";
    this._subgraduationPen = null;
    this._subgraduationColor = YColor.Black;
    this._subgraduationThickness = 1;
    this._subgraduationSize = 5;
    this._graduationOuterRadiusSize = 98;
    this._subgraduationCount = 5;
    this._statusColor = YColor.Gray;
    this._statusLine = "";
    this._showNeedle = true;
    this._needleBrush = null;
    this._needleColor = YColor.Red;
    this._needleMaxSpeed = 5;
    this._needleLength1 = 90;
    this._needleLength2 = 5;
    this._needleWidth = 5;
    this._needleContourPen = null;
    this._needleContourColor = YColor.DarkRed;
    this._needleContourThickness = 1;
    this._showMinMax = true;
    this._path = null;
    this._graduationFont = new YFont(this, this, Math.min(this.getContainerInnerWidth(), this.getContainerInnerHeight()) / 15, null);
    this._unitFont = new YFont(this, this, Math.min(this.getContainerInnerWidth(), this.getContainerInnerHeight()) / 20, null);
    this._statusFont = new YFont(this, this, Math.min(this.getContainerInnerWidth(), this.getContainerInnerHeight()) / 15, null);
    this.unitFont.color = YColor.DarkGray;
    this._statusFont.color = YColor.DarkGray;
    this.resizeRule = Proportional.ResizeRule.RELATIVETOBOTH;
    this._zones = [];
  }
  clearCachedObjects() {
    if (this._zones != null) {
      for (let i = 0; i < this._zones.length; i++) {
        this._zones[i].resetPath();
      }
    }
    this._path = null;
    this._bgBrush = null;
  }
  get zones() {
    return this._zones;
  }
  AddZone() {
    let z = new YAngularZone(this, this);
    this._zones.push(z);
    return z;
  }
  Render(g, w, h) {
    let mainViewPort = new ViewPortSettings();
    mainViewPort.Lmargin = 0;
    mainViewPort.Rmargin = 0;
    mainViewPort.Tmargin = 0;
    mainViewPort.Bmargin = 0;
    g.SmoothingMode = YSmoothingMode.HighQuality;
    g.TextRenderingHint = YTextRenderingHint.AntiAlias;
    let stringFormat4Sizing = new YStringFormat(
      16384
      /* YDataRendering.YStringFormat.StringFormatFlags.NoClip */
    );
    let stringFormat = new YStringFormat(
      16384
      /* YDataRendering.YStringFormat.StringFormatFlags.NoClip */
    );
    stringFormat.Alignment = 1;
    stringFormat.LineAlignment = 1;
    this.drawAnnotationPanels(g, this._annotationPanels, w, h, false, mainViewPort);
    g.TextRenderingHint = YTextRenderingHint.AntiAlias;
    let xcenter = mainViewPort.Lmargin + (w - mainViewPort.Lmargin - mainViewPort.Rmargin) / 2;
    let ycenter = mainViewPort.Tmargin + (h - mainViewPort.Tmargin - mainViewPort.Bmargin) / 2;
    let radius = Math.min((w - mainViewPort.Lmargin - mainViewPort.Rmargin) / 2, (h - mainViewPort.Tmargin - mainViewPort.Bmargin) / 2) - this.borderThickness;
    let circonference = 2 * radius * 3.14 >> 0;
    let AngleAperture = 4 * 2 * Math.PI / 5;
    if (this._path == null) {
      let outterlength = 2 * radius * Math.PI;
      let stepCount = outterlength / this.SegmentMaxLength >> 0;
      let stepsize = 2 * Math.PI / stepCount;
      this._path = new Array(stepCount).fill(null);
      let n = 0;
      for (let i = 0; i < stepCount; i++) {
        let a = 2 * i * Math.PI / stepCount;
        this._path[n++] = new PointF(xcenter + radius * Math.cos(a), ycenter - radius * Math.sin(a));
      }
    }
    if (this._bgBrush == null)
      this._bgBrush = new YLinearGradientBrush(this._backgroundColor1, this._backgroundColor2);
    if (this._borderpen == null) {
      this._borderpen = new YPen(this._borderColor, this._borderThickness);
      this._borderpen.linejoin = YPen.LineJoin.Round;
    }
    if (this._path.length > 3)
      g.FillPolygon(this._bgBrush, this._path);
    if (this._graduationPen == null)
      this._graduationPen = new YPen(this._graduationColor, this._graduationThickness);
    if (this._subgraduationPen == null)
      this._subgraduationPen = new YPen(this._subgraduationColor, this._subgraduationThickness);
    let unitDesc = (this._unitFactor != 1 ? "x" + this._unitFactor.toString() + " " : "") + this._unit;
    let size = g.MeasureStringSF(unitDesc.toString(), this._unitFont, 1e4, stringFormat4Sizing);
    let unitPos = new YRectangle(xcenter - size.width / 2 >> 0, ycenter + radius / 2 - size.height / 2 >> 0, size.width + 1 >> 0, size.height + 1 >> 0);
    g.DrawStringRect(unitDesc, this._unitFont, this._unitFont.brush, unitPos, stringFormat);
    if (this._statusLine != "") {
      size = g.MeasureStringSF(this._statusLine, this._statusFont, 1e4, stringFormat4Sizing);
      let statusPos = new YRectangle(xcenter - size.width / 2 >> 0, ycenter - radius / 3 - size.height / 2 >> 0, size.width + 1, size.height + 1);
      g.DrawStringRect(this._statusLine, this._statusFont, this._statusFont.brush, statusPos, stringFormat);
    }
    let firstGraduation;
    let gratuationCount;
    let Angle, C, S, R1, R2;
    let outerCoef = this._graduationOuterRadiusSize / 100;
    for (let i = 0; i < this._zones.length; i++) {
      if (this._zones[i].visible) {
        if (this._zones[i].path == null) {
          let zmin = Math.max(this._min, Math.min(this._max, this._zones[i].min));
          let zmax = Math.max(this._min, Math.min(this._max, this._zones[i].max));
          if (zmax > zmin) {
            let zOuterCoef = this._zones[i].outerRadius / 100;
            let Angle1 = (Math.PI - AngleAperture) / 2 + AngleAperture * (zmin - this._min) / (this._max - this._min);
            let Angle2 = (Math.PI - AngleAperture) / 2 + AngleAperture * (zmax - this._min) / (this._max - this._min);
            let outterlength = (Angle2 - Angle1) * radius;
            let stepCount = outterlength / this.SegmentMaxLength >> 0;
            if (stepCount < 2)
              stepCount = 2;
            this._zones[i].setPathSize(2 * stepCount + 2);
            for (let j = 0; j <= stepCount; j++) {
              let A = Angle1 + (Angle2 - Angle1) * j / stepCount;
              this._zones[i].setPathPoint(j, new PointF(xcenter - radius * zOuterCoef * Math.cos(A), ycenter - radius * zOuterCoef * Math.sin(A)));
            }
            let innerRadiusCoef = zOuterCoef - this._zones[i].width / 100;
            for (let j = stepCount; j >= 0; j--) {
              let A = Angle1 + (Angle2 - Angle1) * j / stepCount;
              this._zones[i].setPathPoint(2 * stepCount + 1 - j, new PointF(xcenter - radius * innerRadiusCoef * Math.cos(A), ycenter - radius * innerRadiusCoef * Math.sin(A)));
            }
          }
        }
        if (this._zones[i].path != null)
          g.FillPolygon(this._zones[i].zoneBrush, this._zones[i].path);
      }
    }
    firstGraduation = this._graduation * (this._min / this._graduation) >> 0;
    if (this._min < 0)
      firstGraduation -= this._graduation;
    while (firstGraduation < this._min) {
      firstGraduation += this._graduation;
    }
    gratuationCount = 1 + (this._max - this._min) / this._graduation >> 0;
    if (this._subgraduationCount > 0 && this._subgraduationCount * gratuationCount < circonference) {
      let subgraduation = this._graduation / this._subgraduationCount;
      firstGraduation = subgraduation * (this._min / subgraduation >> 0);
      if (this._min < 0)
        firstGraduation -= subgraduation;
      while (firstGraduation < this._min) {
        firstGraduation += subgraduation;
      }
      gratuationCount = 1 + (this._max - this._min) / subgraduation >> 0;
      for (let i = 0; i < gratuationCount; i++) {
        let value = firstGraduation + i * subgraduation;
        if (value <= this._max) {
          Angle = (Math.PI - AngleAperture) / 2 + AngleAperture * (value - this._min) / (this._max - this._min);
          C = Math.cos(Angle);
          S = Math.sin(Angle);
          R1 = outerCoef * (radius - this._borderThickness / 2);
          R2 = (100 - this._subgraduationSize) * (outerCoef * (radius - this._borderThickness / 2)) / 100;
          g.DrawLineXY(this._subgraduationPen, xcenter - R1 * C, ycenter - R1 * S, xcenter - R2 * C, ycenter - R2 * S);
        }
      }
    }
    if (gratuationCount < circonference) {
      for (let i = 0; i < gratuationCount; i++) {
        let gvalue = firstGraduation + i * this._graduation;
        if (gvalue <= this._max) {
          Angle = (Math.PI - AngleAperture) / 2 + AngleAperture * (gvalue - this._min) / (this._max - this._min);
          C = Math.cos(Angle);
          S = Math.sin(Angle);
          R1 = outerCoef * (radius - this._borderThickness / 2);
          R2 = (100 - this._graduationSize) * (outerCoef * (radius - this._borderThickness / 2)) / 100;
          g.DrawLineXY(this._graduationPen, xcenter - R1 * C, ycenter - R1 * S, xcenter - R2 * C, ycenter - R2 * S);
          size = g.MeasureStringSF(gvalue.toString().trim(), this._graduationFont, 1e3, stringFormat4Sizing);
          let HalfDiagonal = 0.4 * Math.sqrt(size.width * size.width + size.height * size.height);
          let position = new YRectangle(xcenter - (R2 - HalfDiagonal) * C - size.width / 2 >> 0, ycenter - (R2 - HalfDiagonal) * S - size.height / 2 >> 0, (size.width >> 0) + 1, size.height >> 0);
          g.DrawStringRect(gvalue.toString(), this._graduationFont, this._graduationFont.brush, position, stringFormat);
        }
      }
    }
    if (this._borderThickness > 0 && this._path.length > 3)
      g.DrawPolygon(this._borderpen, this._path);
    this.drawAnnotationPanels(g, this._annotationPanels, w, h, true, mainViewPort);
    if (this._showNeedle) {
      if (this._needleValue != this._value) {
        let step = this._unitFactor * this._needleMaxSpeed * (this._max - this._min) / 100;
        if (Math.abs(this._value - this._needleValue) < step) {
          this._needleValue = this._value;
        } else if (this._needleValue < this.value) {
          this._needleValue += step;
        } else {
          this._needleValue -= step;
        }
      }
      let needlevalue = this._needleValue / this._unitFactor;
      let allowedOverflow = (this._max - this.min) * 0.05;
      if (needlevalue < this._min - allowedOverflow)
        needlevalue = this._min - allowedOverflow;
      if (needlevalue > this._max + allowedOverflow)
        needlevalue = this._max + allowedOverflow;
      Angle = (Math.PI - AngleAperture) / 2 + AngleAperture * (needlevalue - this._min) / (this._max - this._min);
      C = Math.cos(Angle);
      S = Math.sin(Angle);
      R1 = radius * this._needleLength1 / 100;
      R2 = radius * this._needleLength2 / 100;
      let R3 = radius * this._needleWidth / 200;
      let needlepath = new Array(4).fill(null);
      needlepath[0] = new PointF(xcenter - R1 * C, ycenter - R1 * S);
      needlepath[1] = new PointF(xcenter + R3 * S, ycenter - R3 * C);
      needlepath[2] = new PointF(xcenter + R2 * C, ycenter + R2 * S);
      needlepath[3] = new PointF(xcenter - R3 * S, ycenter + R3 * C);
      if (this._needleBrush == null)
        this._needleBrush = new YSolidBrush(this._needleColor);
      g.FillPolygon(this._needleBrush, needlepath);
      if (this._needleContourThickness > 0) {
        if (this._needleContourPen == null) {
          this._needleContourPen = new YPen(this._needleContourColor, this._needleContourThickness);
          this._needleContourPen.startCap = 2;
          this._needleContourPen.endCap = 2;
          this._needleContourPen.linejoin = YPen.LineJoin.Round;
        }
        let needlepath2 = new Array(5).fill(null);
        needlepath2[0] = needlepath[0];
        needlepath2[1] = needlepath[1];
        needlepath2[2] = needlepath[2];
        needlepath2[3] = needlepath[3];
        needlepath2[4] = needlepath[0];
        g.DrawLines(this._needleContourPen, needlepath2);
      }
    }
    this.DrawMessagePanels(g, w, h);
    return 0;
  }
  renderingPostProcessing() {
    if (this._needleValue != this._value)
      this.redraw();
  }
};

// obj/full/Renderer/YDigitalDisplay.js
var YDigitalDisplay = class _YDigitalDisplay extends YDataRenderer {
  get backgroundColor1() {
    return this._backgroundColor1;
  }
  set backgroundColor1(value) {
    this._backgroundColor1 = value;
    this._bgBrush = null;
    this.redraw();
  }
  get backgroundColor2() {
    return this._backgroundColor2;
  }
  set backgroundColor2(value) {
    this._backgroundColor2 = value;
    this._bgBrush = null;
    this.redraw();
  }
  get alternateValue() {
    return this._alternateValue;
  }
  set alternateValue(value) {
    this._alternateValue = value;
    this.redraw();
  }
  get valueFormater() {
    return this._valueFormater;
  }
  set valueFormater(value) {
    this._valueFormater = value;
    this.redraw();
  }
  get hrzAlignmentOfset() {
    return this._hrzAlignmentOfset;
  }
  set hrzAlignmentOfset(value) {
    this._hrzAlignmentOfset = value;
    this.redraw();
  }
  get hrzAlignment() {
    return this._hrzAlignment;
  }
  set hrzAlignment(value) {
    this._hrzAlignment = value;
    this.redraw();
  }
  get outOfRangeMin() {
    return this._outOfRangeMin;
  }
  set outOfRangeMin(value) {
    if (!Number.isNaN(value) && !Number.isNaN(this._outOfRangeMax) && !YDataRenderer.minMaxCheckDisabled) {
      if (value >= this._outOfRangeMax)
        throw new RangeError("Min cannot be greater than max (" + this._outOfRangeMax.toString() + ")");
    }
    this._outOfRangeMin = value;
    this.redraw();
  }
  get outOfRangeMax() {
    return this._outOfRangeMax;
  }
  set outOfRangeMax(value) {
    if (!Number.isNaN(value) && !Number.isNaN(this._outOfRangeMin) && !YDataRenderer.minMaxCheckDisabled) {
      if (value <= this._outOfRangeMin)
        throw new RangeError("Min cannot be less than max (" + this._outOfRangeMin.toString() + ")");
    }
    this._outOfRangeMax = value;
    this.redraw();
  }
  get outOfRangeColor() {
    return this._outOfRangeColor;
  }
  set outOfRangeColor(value) {
    this._outOfRangeColor = value;
    this.redraw();
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value;
    this.redraw();
  }
  get font() {
    return this._font;
  }
  constructor(UIContainer, logFunction) {
    super(UIContainer, logFunction);
    this._bgBrush = null;
    this._backgroundColor1 = YColor.Black;
    this._backgroundColor2 = YColor.FromArgb(255, 48, 48, 48);
    this._alternateValue = null;
    this._valueFormater = null;
    this._hrzAlignmentOfset = 5;
    this._hrzAlignment = _YDigitalDisplay.HrzAlignment.DECIMAL;
    this._outOfRangeMin = Number.NaN;
    this._outOfRangeMax = Number.NaN;
    this._outOfRangeColor = YColor.Red;
    this._value = 0;
    this._font = new YFont(this, this, Math.min(UIContainer.width / 5, UIContainer.height / 2), null);
    this._font.color = YColor.LightGreen;
    this.resizeRule = Proportional.ResizeRule.RELATIVETOBOTH;
  }
  clearCachedObjects() {
    if (this.font != null)
      this.font.ResetFont(null);
    this._bgBrush = null;
  }
  Render(g, w, h) {
    let mainViewPort = new ViewPortSettings();
    mainViewPort.Lmargin = 0;
    mainViewPort.Rmargin = 0;
    mainViewPort.Tmargin = 0;
    mainViewPort.Bmargin = 0;
    g.SmoothingMode = YSmoothingMode.HighQuality;
    g.TextRenderingHint = YTextRenderingHint.AntiAlias;
    let stringFormat = new YStringFormat(
      16384
      /* YDataRendering.YStringFormat.StringFormatFlags.NoClip */
    );
    stringFormat.Alignment = 1;
    stringFormat.LineAlignment = 1;
    if (this._bgBrush == null) {
      this._bgBrush = new YLinearGradientBrush(this._backgroundColor1, this._backgroundColor2);
    }
    g.FillRectangleXYHW(this._bgBrush, 0, 0, w, h);
    this.drawAnnotationPanels(g, this._annotationPanels, w, h, false, mainViewPort);
    if (mainViewPort.Tmargin >= 20)
      mainViewPort.Tmargin -= 10;
    if (mainViewPort.Bmargin >= 20)
      mainViewPort.Bmargin -= 10;
    g.TextRenderingHint = YTextRenderingHint.AntiAlias;
    let availWidth = w - (mainViewPort.Lmargin + mainViewPort.Rmargin);
    let availHeight = h - (mainViewPort.Tmargin + mainViewPort.Bmargin);
    if (availWidth > 10 && availHeight > 10) {
      let svalue;
      if (this._alternateValue == null) {
        svalue = this._valueFormater == null ? this.value.toFixed(3) : this._valueFormater(this, this.value);
        if (!Number.isNaN(this._outOfRangeMin) && this.value < this._outOfRangeMin) {
          this.font.alternateColor = this._outOfRangeColor;
        } else if (!Number.isNaN(this._outOfRangeMax) && this.value > this._outOfRangeMax) {
          this.font.alternateColor = this._outOfRangeColor;
        } else {
          this.font.alternateColor = null;
        }
      } else {
        this._font.alternateColor = null;
        svalue = this._alternateValue;
      }
      let size = g.MeasureStringSF(svalue, this.font, 1e4, stringFormat);
      let pos;
      let align = this._hrzAlignment;
      if (this._alternateValue != null && align == _YDigitalDisplay.HrzAlignment.DECIMAL)
        align = _YDigitalDisplay.HrzAlignment.RIGHT;
      if (align == _YDigitalDisplay.HrzAlignment.DECIMAL && svalue.indexOf(".") < 0)
        align = _YDigitalDisplay.HrzAlignment.RIGHT;
      switch (align) {
        case _YDigitalDisplay.HrzAlignment.LEFT:
          pos = new YRectangle(mainViewPort.Lmargin + (availWidth * this.hrzAlignmentOfset / 100 >> 0), mainViewPort.Tmargin + (availHeight - size.height) / 2 >> 0, size.width + 1 >> 0, size.height + 1 >> 0);
          g.DrawStringRect(svalue, this.font, this.font.brush, pos, stringFormat);
          break;
        case _YDigitalDisplay.HrzAlignment.CENTER:
          pos = new YRectangle(mainViewPort.Lmargin + (availWidth - size.width) / 2 >> 0, mainViewPort.Tmargin + (availHeight - size.height) / 2 >> 0, size.width + 1 >> 0, size.height + 1 >> 0);
          g.DrawStringRect(svalue, this.font, this.font.brush, pos, stringFormat);
          break;
        case _YDigitalDisplay.HrzAlignment.DECIMAL:
          let left = "";
          let p = svalue.lastIndexOf(",");
          if (p < 0)
            p = svalue.lastIndexOf(".");
          if (p >= 0) {
            left = svalue.substring(0, p + 1);
          } else {
            p = 0;
            while (p < svalue.length && (svalue[p] >= "0" && svalue[p] <= "9" || svalue[p] == "-" || svalue[p] == "'" || svalue[p] == " ")) {
              p++;
            }
            left = svalue.substring(0, p);
          }
          let lsize = g.MeasureStringSF(left, this.font, 1e4, stringFormat);
          pos = new YRectangle(mainViewPort.Lmargin + (availWidth - lsize.width - availWidth * this.hrzAlignmentOfset / 100) >> 0, mainViewPort.Tmargin + (availHeight - size.height) / 2 >> 0, size.width + 1 >> 0, size.height + 1 >> 0);
          g.DrawStringRect(svalue, this.font, this.font.brush, pos, stringFormat);
          break;
        case _YDigitalDisplay.HrzAlignment.RIGHT:
          pos = new YRectangle(mainViewPort.Lmargin + (availWidth - size.width - availWidth * this.hrzAlignmentOfset / 100) >> 0, mainViewPort.Tmargin + (availHeight - size.height) / 2 >> 0, size.width + 1 >> 0, size.height + 1 >> 0);
          g.DrawStringRect(svalue, this.font, this.font.brush, pos, stringFormat);
          break;
      }
    }
    this.drawAnnotationPanels(g, this._annotationPanels, w, h, true, mainViewPort);
    this.DrawMessagePanels(g, w, h);
    return 0;
  }
};
(function(YDigitalDisplay2) {
  class HrzAlignmentEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, HrzAlignment);
    }
  }
  YDigitalDisplay2.HrzAlignmentEnumItem = HrzAlignmentEnumItem;
  class HrzAlignment extends YEnum {
  }
  HrzAlignment.LEFT = new HrzAlignmentEnumItem("LEFT", "Left");
  HrzAlignment.CENTER = new HrzAlignmentEnumItem("CENTER", "Center");
  HrzAlignment.DECIMAL = new HrzAlignmentEnumItem("DECIMAL", "Decimal");
  HrzAlignment.RIGHT = new HrzAlignmentEnumItem("RIGHT", "Right");
  YDigitalDisplay2.HrzAlignment = HrzAlignment;
})(YDigitalDisplay || (YDigitalDisplay = {}));

// obj/full/Renderer/YGraph.js
var SUMMARY_GRANULARITY = 100;
var pointXY = class _pointXY {
  constructor(X, Y) {
    this.x = X === void 0 ? 0 : X;
    this.y = Y === void 0 ? 0 : Y;
  }
  clone() {
    return new _pointXY(this.x, this.y);
  }
};
var pointsSummary = class _pointsSummary {
  constructor(X1, X2, YMIN, YMAX) {
    this.x1 = X1;
    this.x2 = X2;
    this.ymin = YMIN;
    this.ymax = YMAX;
  }
  clone() {
    return new _pointsSummary(this.x1, this.x2, this.ymin, this.ymin);
  }
};
var TimeConverterParseResult = class {
  constructor() {
    this.success = false;
    this.result = 0;
  }
};
var TimeResolution = class {
  constructor() {
    this.step = 0;
    this.format = 0;
  }
};
var YDate = class _YDate extends Date {
  ToString(format) {
    let res = "";
    let ampm = "";
    if (format & _YDate.D)
      res = res + this.getDate() + " ";
    if (format & _YDate.M)
      res = res + _YDate.months[this.getMonth()] + " ";
    if (format & _YDate.YY) {
      let y = this.getFullYear().toString();
      res = res + y.substr(y.length - 2) + " ";
    } else if (format & _YDate.YYYY) {
      let y = this.getFullYear().toString();
      res = res + y + " ";
    }
    if (format & _YDate.CR)
      res = res + "\n";
    if (format & _YDate.h) {
      if (_YDate.use24Hformat) {
        let h = "0" + this.getHours().toString();
        res = res + h.substring(h.length - 2);
        if (!(format & _YDate.m))
          res = res + "H";
      } else {
        let hour = this.getHours();
        ampm = "AM";
        if (hour > 11)
          ampm = "PM";
        if (hour > 12)
          hour = hour - 12;
        if (hour == 0)
          hour = 12;
        res = res + hour.toString();
      }
    }
    if (format & _YDate.m) {
      let m = "0" + this.getMinutes().toString();
      res = res + ":" + m.substring(m.length - 2);
    }
    if (format & _YDate.s) {
      let s = "0" + this.getSeconds().toString();
      res = res + ":" + s.substring(s.length - 2);
    }
    if (format & _YDate.ms1) {
      let ms = "00" + this.getMilliseconds().toString();
      res = res + "." + ms.substring(ms.length - 3).substring(1);
    } else if (format & _YDate.ms01) {
      let ms = "00" + this.getMilliseconds().toString();
      res = res + "." + ms.substring(ms.length - 3).substring(2);
    } else if (format & _YDate.ms001) {
      let ms = "00" + this.getMilliseconds().toString();
      res = res + "." + ms.substring(ms.length - 3).substring(3);
    }
    if (format & _YDate.h && !_YDate.use24Hformat) {
      res = res + ampm;
    }
    return res;
  }
};
YDate.D = 1;
YDate.DD = 2;
YDate.M = 4;
YDate.YY = 8;
YDate.h = 16;
YDate.m = 32;
YDate.s = 64;
YDate.ms1 = 128;
YDate.ms01 = 256;
YDate.ms001 = 512;
YDate.CR = 1024;
YDate.isRelative = 2048;
YDate.YYYY = 4096;
YDate.d = (/* @__PURE__ */ new Date()).toLocaleTimeString().toUpperCase();
YDate.use24Hformat = YDate.d.indexOf("AM") < 0 && YDate.d.indexOf("PM") < 0;
YDate.months = ["jan", "feb", "mar", "apr", "may", "jun", "jul", "aug", "sep", "oct", "nov", "dec"];
var TimeConverter = class _TimeConverter {
  static UTCNow() {
    return new YDate();
  }
  static ToUnixTime(datetime) {
    return datetime.getTime() / 1e3;
  }
  static FromUnixTime(unixtime) {
    let t = new YDate();
    t.setTime(unixtime * 1e3);
    return t;
  }
  static tryParseStringToAbsDateTime(str) {
    let res = new TimeConverterParseResult();
    res.success = false;
    let date = /* @__PURE__ */ new Date();
    let year = date.getFullYear();
    let month = date.getMonth();
    let day = date.getDate();
    let hours = 0;
    let minutes = 0;
    let seconds = 0;
    str = str.trim();
    while (str.indexOf("  ") > 0) {
      str = str.replace("  ", " ");
    }
    let dateFound = false;
    let timeFound = false;
    let it = str.split(" ");
    if (it.length <= 0)
      return res;
    for (let i = 0; i < it.length && i < 2; i++) {
      if (it[i].indexOf("-") > 0) {
        let tokens = it[i].split("-");
        if (tokens.length == 1) {
          day = parseInt(tokens[0]);
        } else if (tokens.length == 2) {
          day = parseInt(tokens[1]);
          month = parseInt(tokens[0]) - 1;
        } else {
          day = parseInt(tokens[2]);
          month = parseInt(tokens[1]) - 1;
          year = parseInt(tokens[0]);
        }
        dateFound = true;
      } else if (it[i].indexOf(":") > 0) {
        let tokens = it[i].split(":");
        if (tokens.length == 1) {
          hours = parseInt(tokens[0]);
        } else if (tokens.length == 2) {
          hours = parseInt(tokens[0]);
          minutes = parseInt(tokens[1]);
        } else {
          hours = parseInt(tokens[0]);
          minutes = parseInt(tokens[1]);
          seconds = parseFloat(tokens[2]);
        }
        timeFound = true;
      }
    }
    if (!timeFound && !dateFound)
      return res;
    if (isNaN(year) || isNaN(month) || isNaN(day) || isNaN(hours) || isNaN(minutes) || isNaN(seconds))
      return res;
    date.setFullYear(year, month, day);
    date.setHours(hours, minutes, seconds >> 0, 1e3 * (seconds % 1) >> 0);
    res.result = date.getTime() / 1e3;
    res.success = true;
    return res;
  }
  static tryParseStringToSecTimeSpan(st) {
    let res = new TimeConverterParseResult();
    let d = 0;
    st = st.toUpperCase();
    let n = st.indexOf("D");
    if (n > 0) {
      d = parseFloat(st.substring(0, n));
      if (isNaN(d)) {
        return res;
      }
      res.result += +d * 86400;
      if (n == st.length - 1) {
        res.success = true;
        return res;
      }
      st = st.substring(n + 1);
    }
    n = st.indexOf("H");
    if (n > 0) {
      d = parseFloat(st.substring(0, n));
      if (isNaN(d)) {
        return res;
      }
      res.result += d * 3600;
      if (n == st.length - 1) {
        res.success = true;
        return res;
      }
      st = st.substring(n + 1);
    }
    n = st.indexOf("M");
    if (n > 0) {
      d = parseFloat(st.substring(0, n));
      if (isNaN(d)) {
        return res;
      }
      res.result += d * 60;
      if (n == st.length - 1) {
        res.success = true;
        return res;
      }
      st = st.substring(n + 1);
    }
    n = st.indexOf("S");
    if (n < 0)
      n = st.length;
    d = parseFloat(st.substring(0, n));
    if (isNaN(d)) {
      return res;
    }
    res.result += d;
    res.success = true;
    return res;
  }
  //public static  secTimeSpanToString( timespan:number):string
  //  { return TimeConverter.secTimeSpanToString( timespan, 0); }
  static secTimeSpanToString(timespan, resolution) {
    let started = false;
    let res = "";
    if (timespan < 0) {
      res = "-";
      timespan = -timespan;
    }
    if (timespan >= 86400) {
      let d = timespan / 86400 >> 0;
      res = res + d.toString() + "d";
      timespan -= 86400 * d;
      started = true;
    }
    if (resolution >= 86400)
      return res != "" ? res : "0d";
    if (timespan >= 3600) {
      let d = timespan / 3600 >> 0;
      let ds = d.toString();
      if (started && ds.length == 1)
        ds = "0" + ds;
      res = res + ds + "h";
      timespan -= 3600 * d;
      started = true;
    }
    if (resolution >= 3600)
      return res != "" ? res : "0h";
    if (timespan < resolution)
      return res != "" ? res : "0h";
    if (timespan >= 60) {
      let d = timespan / 60 >> 0;
      let ds = d.toString();
      if (started && ds.length == 1)
        ds = "0" + ds;
      res = res + ds + "m";
      timespan -= 60 * d;
      started = true;
    }
    if (resolution >= 60)
      return res != "" ? res : "0m";
    if (timespan < resolution)
      return res != "" ? res : "0m";
    timespan = Math.round(timespan * 100) / 100;
    let s;
    if (resolution > 0.1) {
      s = timespan.toFixed(0);
    } else if (resolution > 0.01) {
      s = timespan.toFixed(1);
    } else if (resolution > 1e-3) {
      s = timespan.toFixed(2);
    } else {
      s = timespan.toString();
    }
    if (started && timespan < 10)
      s = "0" + s;
    res = res + s + "s";
    return res;
  }
  static RelativeFormat(dataDeltaTime, viewportDeltaTime, resolution) {
    let ShowSecondsTenth = true;
    let ShowSecondsHundredth = true;
    let ShowSeconds = true;
    let ShowMinutes = false;
    let ShowHours = false;
    let ShowDays = false;
    if (dataDeltaTime <= 0.1) {
      ShowSecondsHundredth = true;
    }
    if (dataDeltaTime <= 1) {
      ShowSecondsTenth = true;
    }
    if (dataDeltaTime >= 60 || viewportDeltaTime >= 60) {
      ShowMinutes = true;
    }
    if (dataDeltaTime >= 3600 || viewportDeltaTime >= 3600) {
      ShowHours = true;
    }
    if (dataDeltaTime >= 86400 || viewportDeltaTime >= 86400) {
      ShowDays = true;
    }
    if (resolution >= 0.1)
      ShowSecondsHundredth = false;
    if (resolution >= 1)
      ShowSecondsTenth = false;
    if (resolution >= 60)
      ShowSeconds = false;
    if (resolution >= 3600)
      ShowMinutes = false;
    if (resolution >= 86400)
      ShowHours = false;
    let format = 0;
    format |= YDate.isRelative;
    if (ShowSecondsTenth)
      format |= YDate.ms1;
    if (ShowSecondsHundredth)
      format |= YDate.ms01;
    if (ShowSeconds)
      format |= YDate.s;
    if (ShowMinutes)
      format |= YDate.m;
    if (ShowHours)
      format |= YDate.h;
    if (ShowDays)
      format |= YDate.D;
    return format;
  }
  static BestTimeformat(dataDeltaTime, viewportDeltaTime, tref) {
    let res = new TimeResolution();
    let ShowSecondsTenth = true;
    let ShowSecondsHundredth = true;
    let ShowSeconds = true;
    let ShowMinutes = false;
    let ShowHours = false;
    let ShowDays = false;
    let ShowMonths = false;
    let ShowYears = false;
    if (viewportDeltaTime <= 0.1) {
      res.step = 0.01;
    } else if (viewportDeltaTime <= 1) {
      res.step = 0.1;
    } else if (viewportDeltaTime <= 2) {
      res.step = 0.2;
    } else if (viewportDeltaTime <= 5) {
      res.step = 0.5;
    } else if (viewportDeltaTime <= 10) {
      res.step = 1;
    } else if (viewportDeltaTime <= 20) {
      res.step = 2;
    } else if (viewportDeltaTime <= 30) {
      res.step = 3;
    } else if (viewportDeltaTime <= 40) {
      res.step = 4;
    } else if (viewportDeltaTime <= 60) {
      res.step = 5;
    } else if (viewportDeltaTime <= 120) {
      res.step = 10;
    } else if (viewportDeltaTime <= 300) {
      res.step = 30;
    } else if (viewportDeltaTime <= 900) {
      res.step = 60;
    } else if (viewportDeltaTime <= 1800) {
      res.step = 180;
    } else if (viewportDeltaTime <= 3600) {
      res.step = 300;
    } else if (viewportDeltaTime <= 7200) {
      res.step = 600;
    } else if (viewportDeltaTime <= 14e3) {
      res.step = 900;
    } else if (viewportDeltaTime <= 21600) {
      res.step = 1800;
    } else if (viewportDeltaTime <= 43200) {
      res.step = 3600;
    } else if (viewportDeltaTime <= 86400) {
      res.step = 7200;
    } else if (viewportDeltaTime <= 2 * 86400) {
      res.step = 2 * 7200;
    } else if (viewportDeltaTime <= 4 * 86400) {
      res.step = 4 * 7200;
    } else if (viewportDeltaTime <= 7 * 86400) {
      res.step = 86400;
    } else if (viewportDeltaTime <= 14 * 86400) {
      res.step = 2 * 86400;
    } else if (viewportDeltaTime <= 28 * 86400) {
      res.step = 4 * 86400;
    } else if (viewportDeltaTime <= 56 * 86400) {
      res.step = 7 * 86400;
    } else if (viewportDeltaTime <= 112 * 86400) {
      res.step = 14 * 86400;
    } else if (viewportDeltaTime <= 224 * 86400) {
      res.step = 31 * 86400;
    } else if (viewportDeltaTime <= 448 * 86400) {
      res.step = 62 * 86400;
    } else if (viewportDeltaTime <= 896 * 86400) {
      res.step = 93 * 86400;
    } else {
      res.step = 365 * 86400;
    }
    if (tref == _TimeConverter.TimeReference.ABSOLUTE) {
      ShowSecondsHundredth = true;
      ShowSecondsTenth = true;
      ShowMinutes = true;
      ShowHours = true;
      ShowDays = dataDeltaTime > 86400;
      ShowMonths = dataDeltaTime > 86400;
      ShowYears = dataDeltaTime > 28 * 6 * 86400;
      if (res.step >= 0.1)
        ShowSecondsHundredth = false;
      if (res.step >= 1)
        ShowSecondsTenth = false;
      if (res.step >= 60)
        ShowSeconds = false;
      if (res.step >= 3600)
        ShowMinutes = false;
      if (res.step >= 86400)
        ShowHours = false;
      if (res.step >= 31 * 86400)
        ShowDays = false;
      if (res.step >= 365 * 86400)
        ShowMonths = false;
      res.format = 0;
      if (ShowSecondsHundredth)
        res.format |= YDate.ms01;
      if (ShowSecondsTenth)
        res.format |= YDate.ms1;
      if (ShowSeconds)
        res.format |= YDate.s;
      if (ShowMinutes)
        res.format = res.format |= YDate.m;
      if (ShowHours)
        res.format = res.format |= YDate.h;
      if (res.format != 0 && (ShowDays || ShowMonths))
        res.format |= YDate.CR;
      if (ShowDays)
        res.format |= YDate.D;
      if (ShowMonths)
        res.format |= YDate.M;
      if (ShowYears)
        res.format |= YDate.YY;
      if (res.format == YDate.YY)
        res.format = YDate.YYYY;
    } else {
      res.format = _TimeConverter.RelativeFormat(dataDeltaTime, viewportDeltaTime, res.step);
    }
    return res;
  }
};
(function(TimeConverter2) {
  class TimeReferenceEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, TimeReference);
    }
  }
  TimeConverter2.TimeReferenceEnumItem = TimeReferenceEnumItem;
  class TimeReference extends YEnum {
  }
  TimeReference.ABSOLUTE = new TimeReferenceEnumItem("ABSOLUTE", "Absolute");
  TimeReference.RELATIVE = new TimeReferenceEnumItem("RELATIVE", "Relative to first data");
  TimeConverter2.TimeReference = TimeReference;
})(TimeConverter || (TimeConverter = {}));
var MinMax = class {
  constructor(minimum, maximum) {
    this.Min = 0;
    this.Max = 0;
    this.Min = minimum;
    this.Max = maximum;
  }
};
var MinMaxHandler = class {
  static extend(M, factor) {
    if (isNaN(M.Min))
      return M;
    let delta = M.Max - M.Min;
    return new MinMax(M.Min - delta * (factor - 1) / 2, M.Max + delta * (factor - 1) / 2);
  }
  static DefaultValue(value1, value2) {
    if (typeof value2 === "undefined") {
      if (typeof value1 === "undefined")
        return new MinMax(Number.NaN, Number.NaN);
      return new MinMax(value1, value1);
    }
    if (typeof value1 === "undefined")
      return new MinMax(value2, value2);
    if (value2 < value1)
      throw new RangeError("MinMax invalid parameters (" + value1.toString() + ">" + value2.toString());
    return new MinMax(value1, value2);
  }
  static isDefined(v) {
    return !isNaN(v.Min);
  }
  static Combine(M1, M2) {
    if (isNaN(M1.Min))
      return new MinMax(M2.Min, M2.Max);
    if (isNaN(M2.Min))
      return new MinMax(M1.Min, M1.Max);
    let res = new MinMax(M2.Min, M2.Max);
    if (M1.Min < res.Min)
      res.Min = M1.Min;
    if (M1.Max < res.Min)
      res.Min = M1.Max;
    if (M1.Min > res.Max)
      res.Max = M1.Min;
    if (M1.Max > res.Max)
      res.Max = M1.Max;
    return res;
  }
  static CombineWithNumber(M1, value) {
    if (isNaN(M1.Min))
      return new MinMax(value, value);
    if (value < M1.Min)
      return new MinMax(value, M1.Max);
    if (value > M1.Max)
      return new MinMax(M1.Min, value);
    return new MinMax(M1.Min, M1.Max);
  }
};
var DataSegment = class _DataSegment {
  static ArrayCopy(sourceArray, sourceIndex, destinationArray, destinationIndex, length) {
    for (let i = 0; i < length; i++) {
      destinationArray[destinationIndex + i] = sourceArray[sourceIndex + i].clone();
    }
  }
  constructor(p) {
    this.data = [];
    this.count = 0;
    if (p instanceof Array) {
      this.data = new Array(p.length);
      _DataSegment.ArrayCopy(p, 0, this.data, 0, p.length);
      this.count = p.length;
    } else if (p instanceof pointXY) {
      this.data = new Array(_DataSegment.SegmentGranularity);
      this.data[0] = p;
      this.count = 1;
    } else {
      throw new Error("invalid constructor paramter type");
    }
  }
  grow() {
    let targetCount = this.data.length + _DataSegment.SegmentGranularity;
    while (this.data.length < targetCount) {
      this.data.push(null);
    }
  }
};
DataSegment.SegmentGranularity = 1e3;
var Summary = class _Summary {
  getBufferpoint() {
    if (this.vtlPtCount <= 0)
      return null;
    return new pointsSummary(this.Xmin, this.Xmax, this.Ymin, this.Ymax);
  }
  Dump() {
    var _a, _b, _c, _d;
    console.log("Summary level" + this.selfIndex + ", " + this.segments.length + " segments, " + this.totalpoints + " points");
    let lastx = 0;
    for (let s = 0; s < this.segments.length; s++) {
      console.log("  segment " + s);
      for (let i = 0; i < this.segments[s].ptCount; i++) {
        console.log(((_a = this.segments[s].data[i]) === null || _a === void 0 ? void 0 : _a.x1) + "," + ((_b = this.segments[s].data[i]) === null || _b === void 0 ? void 0 : _b.ymin) + " delataX=" + Math.round(this.segments[s].data[i].x1 - lastx));
        console.log(((_c = this.segments[s].data[i]) === null || _c === void 0 ? void 0 : _c.x2) + "," + ((_d = this.segments[s].data[i]) === null || _d === void 0 ? void 0 : _d.ymax) + " delataX=" + Math.round(this.segments[s].data[i].x2 - this.segments[s].data[i].x1));
        lastx = this.segments[s].data[i].x2;
      }
    }
  }
  constructor(index, array, pointSize) {
    this.segments = [];
    this.totalpoints = 0;
    this.Xmin = 0;
    this.Xmax = 0;
    this.Ymin = 0;
    this.Ymax = 0;
    this.vtlPtCount = 0;
    this.pointSize = 0;
    this.isLast = false;
    this.newSummaryLevelTrigger = 0;
    this.selfIndex = index;
    this.selfArray = array;
    this.pointSize = pointSize;
    this.isLast = true;
  }
  processSegments(segments) {
    if (segments.length <= 0)
      return;
    let last = segments.length - 1;
    this.Xmin = segments[last].data[0].x;
    this.Xmax = segments[last].data[0].x;
    this.Ymin = segments[last].data[0].y;
    this.Ymax = segments[last].data[0].y;
    this.totalpoints = 0;
    this.vtlPtCount = 0;
    for (let s = last; s >= 0; s--) {
      for (let i = 0; i < segments[s].data.length; i++) {
        let p = segments[s].data[i];
        if (p.x < this.Ymin)
          this.Ymin = p.y;
        if (p.x > this.Ymax)
          this.Ymax = p.y;
        this.Xmax = p.x;
        this.vtlPtCount++;
        if (this.vtlPtCount >= this.pointSize) {
          this.flush(false);
          this.Xmin = p.x;
          this.Ymin = p.y;
          this.Ymax = p.y;
        }
      }
      if (s > 0) {
        let len = segments[s].data.length;
        let p2 = segments[s - 1].data[0];
        let p1 = segments[s].data[len - 1];
        let lastDelta = 1;
        if (len > 1) {
          let p0 = segments[s].data[len - 2];
          lastDelta = p1.x - p0.x;
        }
        if (p2.x - p1.x > this.pointSize * lastDelta) {
          this.flush(false);
          this.Xmin = p2.x;
          this.Ymin = p2.y;
          this.Ymax = p2.y;
          this.addNewEmptySegment();
        }
      }
    }
    if (this.totalpoints > 1) {
      let it = new _Summary(this.selfIndex + 1, this.selfArray, this.pointSize * SUMMARY_GRANULARITY);
      this.selfArray.push(it);
      this.isLast = false;
      it.processSegments(segments);
    }
  }
  addNewLevel() {
    let newIndex = this.selfArray.length;
    if (_Summary.DBG)
      console.log("--- ADDING NEW LEVEL " + newIndex);
    let it = new _Summary(newIndex, this.selfArray, this.pointSize * SUMMARY_GRANULARITY);
    this.selfArray.push(it);
    this.isLast = false;
    let _xmin = this.segments[0].data[0].x1;
    let _xmax = this.segments[0].data[0].x2;
    let _ymin = this.segments[0].data[0].ymin;
    let _ymax = this.segments[0].data[0].ymax;
    let _count = 0;
    for (let s = 0; s < this.segments.length; s++) {
      for (let i = 0; i < this.segments[s].ptCount; i++) {
        _xmax = this.segments[s].data[i].x2;
        if (this.segments[s].data[i].ymin < _ymin)
          _ymin = this.segments[s].data[i].ymin;
        if (this.segments[s].data[i].ymin > _ymax)
          _ymax = this.segments[s].data[i].ymin;
      }
      _count += this.segments[s].ptCount;
      if (s < this.segments.length - 1) {
        if (this.segments[s].ptCount > 2) {
          let lastIndex = this.segments[s].ptCount - 1;
          let lastDelta = this.segments[s].data[lastIndex].x1 - this.segments[s].data[lastIndex - 1].x2;
          if (this.segments[s + 1].data[0].x1 - this.segments[s].data[this.segments[s].ptCount - 1].x2 > lastDelta * SUMMARY_GRANULARITY) {
            it.addNewEmptySegment();
            _xmin = this.segments[s + 1].data[0].x1;
            _xmax = this.segments[s + 1].data[0].x2;
            _ymin = this.segments[s + 1].data[0].ymin;
            _ymax = this.segments[s + 1].data[0].ymax;
            _count = 0;
          }
        }
      }
    }
    if (_count != 0) {
      it.addNewSinglePointSegment(_xmin, _xmax, _ymin, _ymax, _count);
    }
  }
  addNewSinglePointSegment(xmin, xmax, ymin, ymax, _count) {
    if (_Summary.DBG)
      console.log(" ===> level " + this.selfIndex + " new single point segment");
    this.segments.push(new DataSummarySegment(new pointsSummary(xmin, xmax, ymin, ymax), _count));
  }
  addNewEmptySegment() {
    if (_Summary.DBG)
      console.log(" ===> level " + this.selfIndex + " new empty segment");
    this.segments.push(new DataSummarySegment(null, null));
  }
  addSequentialPoint(p, maxHoleSize) {
    if (_Summary.DBG)
      console.log(" ADD Point, LEVEL " + this.selfIndex + " Vtl point = " + this.vtlPtCount + "/" + this.pointSize + " TOTAL Points= " + this.totalpoints);
    if (this.isLast && this.totalpoints >= SUMMARY_GRANULARITY)
      this.addNewLevel();
    if (this.vtlPtCount == 0) {
      this.Xmin = p.x;
      this.Xmax = p.x;
      this.Ymin = p.y;
      this.Ymax = p.y;
      this.vtlPtCount = 1;
      if (_Summary.DBG) {
        if (this.selfIndex == 1)
          console.log(" --> added 1srt virtual pt vtlPtCount=" + this.vtlPtCount + "/" + this.pointSize);
      }
      if (!this.isLast)
        this.selfArray[this.selfIndex + 1].addSequentialPoint(p, maxHoleSize * SUMMARY_GRANULARITY);
      return;
    } else {
      if (_Summary.DBG)
        console.log(" --> level " + this.selfIndex + " delta = " + (p.x - this.Xmax) + "/" + maxHoleSize);
      if (maxHoleSize > 0 && p.x - this.Xmax > maxHoleSize) {
        if (_Summary.DBG)
          console.log(" --> level " + this.selfIndex + " hole detected");
        this.flush(false);
        this.addNewEmptySegment();
        this.Xmin = p.x;
        this.Xmax = p.x;
        this.Ymin = p.y;
        this.Ymax = p.y;
        this.vtlPtCount = 1;
        if (!this.isLast)
          this.selfArray[this.selfIndex + 1].addSequentialPoint(p, maxHoleSize * SUMMARY_GRANULARITY);
        return;
      }
      if (p.y < this.Ymin)
        this.Ymin = p.y;
      if (p.y > this.Ymax)
        this.Ymax = p.y;
      this.Xmax = p.x;
      this.vtlPtCount++;
      if (_Summary.DBG) {
        if (this.selfIndex == 1)
          console.log(" --> level " + this.selfIndex + " added subsequent virtual pt vtlPtCount=" + this.vtlPtCount + "/" + this.pointSize);
      }
      if (this.vtlPtCount >= this.pointSize) {
        if (_Summary.DBG) {
          if (this.selfIndex == 1)
            console.log(" --> level " + this.selfIndex + " flushing");
        }
        this.flush(false);
      }
    }
    if (!this.isLast)
      this.selfArray[this.selfIndex + 1].addSequentialPoint(p, maxHoleSize * SUMMARY_GRANULARITY);
  }
  flush(forceNewSegment) {
    if (this.segments.length == 0 || forceNewSegment)
      this.segments.push(new DataSummarySegment(null, null));
    let lastsegment = this.segments[this.segments.length - 1];
    lastsegment.data[lastsegment.ptCount] = new pointsSummary(this.Xmin, this.Xmax, this.Ymin, this.Ymax);
    this.totalpoints++;
    lastsegment.ptCount++;
    this.vtlPtCount = 0;
  }
};
Summary.DBG = false;
var DataSummarySegment = class _DataSummarySegment {
  static ArrayCopy(sourceArray, sourceIndex, destinationArray, destinationIndex, length) {
    for (let i = 0; i < length; i++) {
      destinationArray[destinationIndex + i] = sourceArray[sourceIndex + i].clone();
    }
  }
  constructor(p, virtualPointCount) {
    this.data = [];
    this.ptCount = 0;
    if (p instanceof Array) {
      this.data = new Array(p.length);
      _DataSummarySegment.ArrayCopy(p, 0, this.data, 0, p.length);
      this.ptCount = p.length;
    } else if (p instanceof pointsSummary) {
      this.data = new Array(_DataSummarySegment.SegmentGranularity);
      this.data[0] = p;
      this.ptCount = 1;
    } else if (p == null) {
      this.data = new Array(_DataSummarySegment.SegmentGranularity);
      this.ptCount = 0;
    }
  }
  grow() {
    let targetCount = this.data.length + _DataSummarySegment.SegmentGranularity;
    while (this.data.length < targetCount) {
      this.data.push(null);
    }
  }
};
DataSummarySegment.SegmentGranularity = 1e3;
var DataSerie = class _DataSerie {
  get userData() {
    return this._userData;
  }
  set userData(value) {
    this._userData = value;
  }
  static get MaxPointsPerSeries() {
    return _DataSerie._MaxPointsPerSeries;
  }
  static set MaxPointsPerSeries(value) {
    _DataSerie._MaxPointsPerSeries = value;
  }
  get timeRange() {
    return this._timeRange;
  }
  get valueRange() {
    return this._valueRange;
  }
  constructor(parent) {
    this.totalPointCount = 0;
    this._userData = null;
    this._yAxisIndex = 0;
    this._pen = null;
    this._legendPen = null;
    this._brush = null;
    this._navigatorpen = null;
    this._visible = true;
    this._disabled = false;
    this._color = YColor.Black;
    this._thickness = 1;
    this._legend = "";
    this._unit = "";
    this.segments = [];
    this.summaries = null;
    if (parent.yAxes.length <= 0)
      throw new Error("Define at least one yAxis");
    this._timeRange = MinMaxHandler.DefaultValue();
    this._valueRange = MinMaxHandler.DefaultValue();
    this.parent = parent;
  }
  get yAxisIndex() {
    return this._yAxisIndex;
  }
  set yAxisIndex(value) {
    if (value >= this.parent.yAxes.length)
      throw new RangeError("No such yAxis (" + value.toString() + ")");
    this._yAxisIndex = value;
    this.parent.yAxes[this._yAxisIndex].AutoShow();
  }
  get pen() {
    if (this._pen == null) {
      this._pen = new YPen(this._color, this._thickness);
      this._pen.endCap = 2;
      this._pen.linejoin = YPen.LineJoin.Round;
    }
    return this._pen;
  }
  get legendPen() {
    if (this._legendPen == null) {
      this._legendPen = new YPen(this._color, this._thickness * this.parent.legendPanel.traceWidthFactor);
    }
    return this._legendPen;
  }
  resetlegendPen() {
    this._legendPen = null;
  }
  get brush() {
    if (this._brush == null)
      this._brush = new YSolidBrush(this._color);
    return this._brush;
  }
  get navigatorpen() {
    if (this._navigatorpen == null) {
      this._navigatorpen = new YPen(YColor.FromArgb(100, this._color.red, this._color.green, this._color.blue), 1);
    }
    return this._navigatorpen;
  }
  get visible() {
    return this._visible;
  }
  set visible(value) {
    this._visible = value;
    this.parent.redraw();
  }
  get disabled() {
    return this._disabled;
  }
  set disabled(value) {
    this._disabled = value;
    this.parent.redraw();
  }
  get color() {
    return this._color;
  }
  set color(value) {
    this._color = value;
    this._pen = null;
    this._legendPen = null;
    this._brush = null;
    this._navigatorpen = null;
    this.parent.redraw();
  }
  get thickness() {
    return this._thickness;
  }
  set thickness(value) {
    if (value < 0)
      throw new RangeError("Thickness must be a positive value");
    this._thickness = value;
    this._pen = null;
    this._legendPen = null;
    this.parent.redraw();
  }
  get legend() {
    return this._legend;
  }
  set legend(value) {
    this._legend = value;
    this.parent.redraw();
  }
  get unit() {
    return this._unit;
  }
  set unit(value) {
    this._unit = value;
    this.parent.redraw();
  }
  AddNewSegment(p) {
    this.segments.splice(0, 0, new DataSegment(p));
  }
  getlastPoint() {
    if (this.segments.length <= 0) {
      return new pointXY(NaN, NaN);
    }
    return this.segments[this.segments.length - 1].data[this.segments[this.segments.length - 1].count - 1];
  }
  handleSummary(p, delta) {
    if (this.summaries == null) {
      this.summaries = [];
      this.summaries.push(new Summary(0, this.summaries, SUMMARY_GRANULARITY));
    }
    if (this.summaries != null)
      this.summaries[0].addSequentialPoint(p, delta);
  }
  AddPoint(p) {
    this._timeRange = MinMaxHandler.CombineWithNumber(this._timeRange, p.x);
    this._valueRange = MinMaxHandler.CombineWithNumber(this._valueRange, p.y);
    let delta1 = -1;
    let delta2 = -1;
    if (this.segments.length <= 0) {
      this.AddNewSegment(p);
      this.totalPointCount++;
      if (SUMMARY_GRANULARITY > 0)
        this.handleSummary(p, delta1);
      return;
    } else if (this.segments[0].count > 1) {
      delta1 = this.segments[0].data[this.segments[0].count - 1].x - this.segments[0].data[this.segments[0].count - 2].x;
      delta2 = p.x - this.segments[0].data[this.segments[0].count - 1].x;
      if (delta2 > 0.1 && (delta2 < 0 || delta2 > 2 * delta1)) {
        this.AddNewSegment(p);
        if (SUMMARY_GRANULARITY > 0)
          this.handleSummary(p, delta1);
        return;
      }
    }
    if (SUMMARY_GRANULARITY > 0)
      this.handleSummary(p, delta1);
    this.segments[0].data[this.segments[0].count] = p;
    this.segments[0].count++;
    this.totalPointCount++;
    if (_DataSerie._MaxPointsPerSeries > 0 && this.totalPointCount > _DataSerie._MaxPointsPerSeries) {
      this.dataCleanUp();
      this.rebuildSummaries();
    }
    this.parent.adjustGlobalTimeRange(p.x);
    this.parent.redraw();
  }
  rebuildSummaries() {
    if (SUMMARY_GRANULARITY <= 0)
      return;
    this.summaries = [];
    this.summaries.push(new Summary(0, this.summaries, SUMMARY_GRANULARITY));
    this.summaries[0].processSegments(this.segments);
  }
  dumpSummaries() {
    if (this.summaries != null)
      for (let i = 0; i < this.summaries.length; i++)
        this.summaries[i].Dump();
    else
      console.log("****No summaries ****");
  }
  dataCleanUp() {
    if (this.segments.length <= 0)
      return;
    let newLimit = _DataSerie._MaxPointsPerSeries * 90 / 100;
    while (this.segments[this.segments.length - 1].count <= this.totalPointCount - newLimit) {
      this.totalPointCount -= this.segments[this.segments.length - 1].count;
      this.segments.splice(this.segments.length - 1, 1);
    }
    if (this.totalPointCount > newLimit) {
      let delta = this.totalPointCount - newLimit;
      let newsize = this.segments[this.segments.length - 1].count - delta;
      let newdata = new Array(newsize);
      DataSegment.ArrayCopy(this.segments[this.segments.length - 1].data, delta, newdata, 0, this.segments[this.segments.length - 1].count - delta);
      this.segments[this.segments.length - 1].data = newdata;
      this.segments[this.segments.length - 1].count -= delta;
      this.totalPointCount -= delta;
    }
    let tmin = this.segments[0].data[0].x;
    let tmax = this.segments[0].data[0].x;
    let ymin = this.segments[0].data[0].y;
    let ymax = this.segments[0].data[0].y;
    for (let i = 0; i < this.segments.length; i++) {
      let count = this.segments[i].count;
      if (tmin > this.segments[i].data[0].x)
        tmin = this.segments[i].data[0].x;
      if (tmax < this.segments[i].data[count - 1].x)
        tmax = this.segments[i].data[count - 1].x;
      for (let j = 0; j < count; j++) {
        if (ymin > this.segments[i].data[j].y)
          ymin = this.segments[i].data[j].y;
        if (ymax < this.segments[i].data[j].y)
          ymax = this.segments[i].data[j].y;
      }
    }
    this._timeRange.Min = tmin;
    this._timeRange.Max = tmax;
    this._valueRange.Min = ymin;
    this._valueRange.Max = ymax;
  }
  InsertPoints(points) {
    if (points.length == 0)
      return;
    if (points.length == 1) {
      this._timeRange = MinMaxHandler.CombineWithNumber(this._timeRange, points[0].x);
      this._valueRange = MinMaxHandler.CombineWithNumber(this._valueRange, points[0].y);
      return;
    }
    let FirstStep = points[1].x - points[0].x;
    let LastStep = points[points.length - 1].x - points[points.length - 2].x;
    let InsertAtBegining = -1;
    let InsertAtEnd = -1;
    for (let i = 0; i < this.segments.length; i++) {
      if (this.segments[i].count > 1) {
        let DeltaInsertAtBegining = this.segments[i].data[0].x - points[points.length - 1].x;
        let DeltaInsertAtEnd = points[0].x - this.segments[i].data[this.segments[i].count - 1].x;
        if (DeltaInsertAtBegining > 0 && DeltaInsertAtBegining < 2 * FirstStep)
          InsertAtBegining = i;
        if (DeltaInsertAtEnd > 0 && DeltaInsertAtEnd < 2 * LastStep)
          InsertAtEnd = i;
      }
    }
    if (InsertAtBegining >= 0) {
      DataSegment.ArrayCopy(this.segments[InsertAtBegining].data, 0, this.segments[InsertAtBegining].data, points.length, this.segments[InsertAtBegining].count);
      DataSegment.ArrayCopy(points, 0, this.segments[InsertAtBegining].data, 0, points.length);
      this.segments[InsertAtBegining].count += points.length;
      this.totalPointCount += points.length;
    } else if (InsertAtEnd >= 0) {
      DataSegment.ArrayCopy(points, 0, this.segments[InsertAtEnd].data, this.segments[InsertAtEnd].count, points.length);
      this.segments[InsertAtEnd].count += points.length;
      this.totalPointCount += points.length;
    } else {
      let inserted = false;
      for (let i = 0; i < this.segments.length; i++) {
        if (this.segments[i].data[this.segments[i].data.length - 1].x < points[0].x && !inserted) {
          this.segments.splice(i, 0, new DataSegment(points));
          inserted = true;
        }
      }
      if (!inserted)
        this.segments.push(new DataSegment(points));
      this.totalPointCount += points.length;
    }
    this._timeRange = MinMaxHandler.CombineWithNumber(this._timeRange, points[0].x);
    this._timeRange = MinMaxHandler.CombineWithNumber(this._timeRange, points[points.length - 1].x);
    for (let i = 0; i < points.length; i++) {
      this._valueRange = MinMaxHandler.CombineWithNumber(this._valueRange, points[i].y);
    }
    if (_DataSerie._MaxPointsPerSeries > 0 && this.totalPointCount > _DataSerie._MaxPointsPerSeries)
      this.dataCleanUp();
    this.parent.redraw();
  }
  static CompareSegments(a, b) {
    if (a.data[0].x > b.data[0].x)
      return -1;
    if (a.data[0].x < b.data[0].x)
      return 1;
    return 0;
  }
  getData() {
    let res = [];
    this.segments.sort(_DataSerie.CompareSegments);
    for (let i = this.segments.length - 1; i >= 0; i--) {
      for (let j = 0; j < this.segments[i].count; j++) {
        res.push(this.segments[i].data[j]);
      }
    }
    return res;
  }
  findClosestValue(x, AllowInterpolation) {
    let N1 = 0;
    let N2 = 0;
    let Pos = 0;
    if (this.segments.length <= 0)
      return null;
    for (let i = 0; i < this.segments.length; i++) {
      if (x >= this.segments[i].data[0].x && x <= this.segments[i].data[this.segments[i].count - 1].x) {
        let data = this.segments[i].data;
        N1 = 0;
        N2 = this.segments[i].count - 1;
        while (N2 - N1 > 1) {
          let N = N1 + N2 >> 1;
          if (data[N].x > x)
            N2 = N;
          else
            N1 = N;
        }
        Pos = N1 - 1;
        if (Pos < 0)
          Pos = 0;
        if (!AllowInterpolation) {
          if (x - data[Pos].x < data[Pos + 1].x - x)
            return data[Pos];
          else
            return data[Pos + 1];
        } else {
          Pos++;
          if (x == data[Pos].x)
            return data[Pos];
          if (x == data[Pos + 1].x)
            return data[Pos + 1];
          let p = new pointXY();
          p.x = x;
          p.y = data[Pos].y + (data[Pos + 1].y - data[Pos].y) * (x - data[Pos].x) / (data[Pos + 1].x - data[Pos].x);
          return p;
        }
      }
    }
    if (AllowInterpolation)
      return null;
    try {
      this.segments[0].data[0].clone();
    } catch (e) {
      debugger;
    }
    let match = this.segments[0].data[0];
    let delta = Math.abs(this.segments[0].data[0].x - x);
    for (let i = 0; i < this.segments.length; i++) {
      let d1 = Math.abs(this.segments[i].data[0].x - x);
      let d2 = Math.abs(this.segments[i].data[this.segments[i].count - 1].x - x);
      if (d1 < delta) {
        match = this.segments[i].data[0];
        delta = d1;
      }
      if (d2 < delta) {
        match = this.segments[i].data[this.segments[i].count - 1];
        delta = d2;
      }
    }
    return match.clone();
  }
  clear() {
    this.segments = [];
    this._timeRange = MinMaxHandler.DefaultValue();
    this._valueRange = MinMaxHandler.DefaultValue();
    this.parent.clearCachedObjects();
    this.totalPointCount = 0;
  }
};
DataSerie._MaxPointsPerSeries = 0;
var DataTracker = class _DataTracker {
  get directParent() {
    return this._directParent;
  }
  get userData() {
    return this._userData;
  }
  set userData(value) {
    this._userData = value;
  }
  constructor(parent, directParent) {
    this._userData = null;
    this._enabled = false;
    this._showSerieName = false;
    this._showTimeStamp = false;
    this._dataPrecisionString = "";
    this._dataPrecision = _DataTracker.DataPrecision.PRECISION_NOLIMIT;
    this._diameter = 5;
    this._handleLength = 25;
    this._detectionDistance = 50;
    this._bgColor = YColor.FromArgb(200, 255, 255, 255);
    this._borderColor = YColor.Black;
    this._borderthickness = 1;
    this._padding = 10;
    this._verticalMargin = 10;
    this._horizontalMargin = 10;
    this._bgBrush = null;
    this._pen = null;
    this._font = null;
    this._directParent = directParent;
    this._parentRenderer = parent;
    this._font = new YFont(parent, this, 8, null);
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    this._enabled = value;
    this._parentRenderer.redraw();
  }
  get showSerieName() {
    return this._showSerieName;
  }
  set showSerieName(value) {
    this._showSerieName = value;
    this._parentRenderer.redraw();
  }
  get showTimeStamp() {
    return this._showTimeStamp;
  }
  set showTimeStamp(value) {
    this._showTimeStamp = value;
    this._parentRenderer.redraw();
  }
  get dataPrecisionString() {
    return this._dataPrecisionString;
  }
  get dataPrecision() {
    return this._dataPrecision;
  }
  set dataPrecision(value) {
    this._dataPrecision = value;
    this.compute_dataPrecisionString();
    this._parentRenderer.redraw();
  }
  compute_dataPrecisionString() {
    if (this._dataPrecision == _DataTracker.DataPrecision.PRECISION_NOLIMIT) {
      this._dataPrecisionString = "";
      return;
    }
    this._dataPrecisionString = "0.";
  }
  get diameter() {
    return this._diameter;
  }
  set diameter(value) {
    if (value < 0)
      throw new RangeError("Diameter must be a positive value");
    this._diameter = value;
    this._parentRenderer.redraw();
  }
  get handleLength() {
    return this._handleLength;
  }
  set handleLength(value) {
    if (value < 0)
      throw new RangeError("Hanle length must be a positive value");
    this._handleLength = value;
    this._parentRenderer.redraw();
  }
  get detectionDistance() {
    return this._detectionDistance;
  }
  set detectionDistance(value) {
    if (value <= 0)
      throw new RangeError("Distance must be a positive value");
    this._detectionDistance = value;
  }
  get bgColor() {
    return this._bgColor;
  }
  set bgColor(value) {
    this._bgColor = value;
    this._bgBrush = null;
    this._parentRenderer.redraw();
  }
  get borderColor() {
    return this._borderColor;
  }
  set borderColor(value) {
    this._borderColor = value;
    this._pen = null;
    this._parentRenderer.redraw();
  }
  get borderthickness() {
    return this._borderthickness;
  }
  set borderthickness(value) {
    if (value < 0)
      throw new RangeError("Thickness must be a positive value");
    this._borderthickness = value;
    this._pen = null;
    this._parentRenderer.redraw();
  }
  get padding() {
    return this._padding;
  }
  set padding(value) {
    if (value < 0)
      throw new RangeError("Padding must be a positive value");
    this._padding = value;
    this._parentRenderer.redraw();
  }
  get verticalMargin() {
    return this._verticalMargin;
  }
  set verticalMargin(value) {
    if (value < 0)
      throw new RangeError("Margin must be a positive value");
    this._verticalMargin = value;
    this._parentRenderer.redraw();
  }
  get horizontalMargin() {
    return this._horizontalMargin;
  }
  set horizontalMargin(value) {
    if (value < 0)
      throw new RangeError("Margin must be a positive value");
    this._horizontalMargin = value;
    this._parentRenderer.redraw();
  }
  get bgBrush() {
    if (this._bgBrush == null) {
      this._bgBrush = new YSolidBrush(this._bgColor);
    }
    return this._bgBrush;
  }
  get pen() {
    if (this._pen == null)
      this._pen = new YPen(this._borderColor, this._borderthickness, true);
    return this._pen;
  }
  get font() {
    return this._font;
  }
};
(function(DataTracker2) {
  class DataPrecisionEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, DataPrecision);
    }
  }
  DataTracker2.DataPrecisionEnumItem = DataPrecisionEnumItem;
  class DataPrecision extends YEnum {
  }
  DataPrecision.PRECISION_NOLIMIT = new DataPrecisionEnumItem("PRECISION_NOLIMIT", "As is");
  DataPrecision.PRECISION_1 = new DataPrecisionEnumItem("PRECISION_1", "1");
  DataPrecision.PRECISION_01 = new DataPrecisionEnumItem("PRECISION_01", "0.1");
  DataPrecision.PRECISION_001 = new DataPrecisionEnumItem("PRECISION_001", "0.01");
  DataPrecision.PRECISION_0001 = new DataPrecisionEnumItem("PRECISION_0001", "0.001");
  DataPrecision.PRECISION_00001 = new DataPrecisionEnumItem("PRECISION_00001", "0.0001");
  DataPrecision.PRECISION_000001 = new DataPrecisionEnumItem("PRECISION_000001", "0.00001");
  DataPrecision.PRECISION_0000001 = new DataPrecisionEnumItem("PRECISION_0000001", "0.000001");
  DataPrecision.PRECISION_00000001 = new DataPrecisionEnumItem("PRECISION_00000001", "0.0000001");
  DataPrecision.PRECISION_000000001 = new DataPrecisionEnumItem("PRECISION_000000001", "0.00000001");
  DataPrecision.PRECISION_0000000001 = new DataPrecisionEnumItem("PRECISION_0000000001", "0.000000001");
  DataTracker2.DataPrecision = DataPrecision;
})(DataTracker || (DataTracker = {}));
var LegendPanel = class _LegendPanel {
  get directParent() {
    return this._directParent;
  }
  get userData() {
    return this._userData;
  }
  set userData(value) {
    this._userData = value;
  }
  get traceWidthFactor() {
    return this._traceWidth;
  }
  set traceWidthFactor(value) {
    if (value <= 0)
      throw new RangeError("This has to be a strictly positive value");
    this._traceWidth = value;
    this._parentRenderer.resetlegendPens();
    this._parentRenderer.redraw();
  }
  constructor(parent, directParent) {
    this._userData = null;
    this._traceWidth = 1;
    this._enabled = false;
    this._position = _LegendPanel.Position.BOTTOM;
    this._overlap = false;
    this._bgColor = YColor.FromArgb(200, 255, 255, 255);
    this._borderColor = YColor.Black;
    this._borderthickness = 1;
    this._padding = 10;
    this._verticalMargin = 10;
    this._horizontalMargin = 10;
    this._bgBrush = null;
    this._pen = null;
    this._font = null;
    this._directParent = directParent;
    this._parentRenderer = parent;
    this._font = new YFont(parent, this, 8, null);
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    this._enabled = value;
    this._parentRenderer.redraw();
  }
  get position() {
    return this._position;
  }
  set position(value) {
    this._position = value;
    this._parentRenderer.redraw();
  }
  get overlap() {
    return this._overlap;
  }
  set overlap(value) {
    this._overlap = value;
    this._parentRenderer.redraw();
  }
  get bgColor() {
    return this._bgColor;
  }
  set bgColor(value) {
    this._bgColor = value;
    this._bgBrush = null;
    this._parentRenderer.redraw();
  }
  get borderColor() {
    return this._borderColor;
  }
  set borderColor(value) {
    this._borderColor = value;
    this._pen = null;
    this._parentRenderer.redraw();
  }
  get borderthickness() {
    return this._borderthickness;
  }
  set borderthickness(value) {
    if (value < 0)
      throw new RangeError("Thickness must be a positive value");
    this._borderthickness = value;
    this._pen = null;
    this._parentRenderer.redraw();
  }
  get padding() {
    return this._padding;
  }
  set padding(value) {
    if (value < 0)
      throw new RangeError("Padding must be a positive value");
    this._padding = value;
    this._parentRenderer.redraw();
  }
  get verticalMargin() {
    return this._verticalMargin;
  }
  set verticalMargin(value) {
    if (value < 0)
      throw new RangeError("Margin must be a positive value");
    this._verticalMargin = value;
    this._parentRenderer.redraw();
  }
  get horizontalMargin() {
    return this._horizontalMargin;
  }
  set horizontalMargin(value) {
    if (value < 0)
      throw new RangeError("Margin must be a positive value");
    this._horizontalMargin = value;
    this._parentRenderer.redraw();
  }
  get bgBrush() {
    if (this._bgBrush == null) {
      this._bgBrush = new YSolidBrush(this._bgColor);
    }
    return this._bgBrush;
  }
  get pen() {
    if (this._pen == null)
      this._pen = new YPen(this._borderColor, this._borderthickness, true);
    return this._pen;
  }
  get font() {
    return this._font;
  }
};
(function(LegendPanel2) {
  class PositionEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, Position);
    }
  }
  LegendPanel2.PositionEnumItem = PositionEnumItem;
  class Position extends YEnum {
  }
  Position.LEFT = new PositionEnumItem("LEFT", "Left");
  Position.TOPLEFT = new PositionEnumItem("TOPLEFT", "Top-Left");
  Position.TOP = new PositionEnumItem("TOP", "Top");
  Position.TOPRIGHT = new PositionEnumItem("TOPRIGHT", "Top-Right");
  Position.RIGHT = new PositionEnumItem("RIGHT", "Right");
  Position.BOTTOMRIGHT = new PositionEnumItem("BOTTOMRIGHT", "Bottom-Right");
  Position.BOTTOM = new PositionEnumItem("BOTTOM", "Bottom");
  Position.BOTTOMLEFT = new PositionEnumItem("BOTTOMLEFT", "Bottom-Left");
  LegendPanel2.Position = Position;
})(LegendPanel || (LegendPanel = {}));
var Navigator = class _Navigator {
  get directParent() {
    return this._directParent;
  }
  get userData() {
    return this._userData;
  }
  set userData(value) {
    this._userData = value;
  }
  get showXAxisZones() {
    return this._showXAxisZones;
  }
  set showXAxisZones(value) {
    this._showXAxisZones = value;
  }
  get relativeheight() {
    return this._relativeheight;
  }
  set relativeheight(value) {
    if (value < 10)
      value = 10;
    if (value > 50)
      value = 50;
    this._relativeheight = value;
    this._parentRenderer.redraw();
  }
  constructor(parent, directParent) {
    this._userData = null;
    this._viewport = new ViewPortSettings();
    this.Xrange = null;
    this._showXAxisZones = true;
    this._relativeheight = 10;
    this._enabled = false;
    this._bgColor1 = YColor.FromArgb(255, 225, 225, 225);
    this._cursorBorderColor = YColor.FromArgb(255, 40, 40, 40);
    this._yAxisHandling = _Navigator.YAxisHandling.AUTO;
    this._bgColor2 = YColor.FromArgb(255, 225, 225, 225);
    this._cursorColor = YColor.FromArgb(100, 0, 255, 0);
    this._cursorBrush = null;
    this._pen = null;
    this._cursorBorderPen = null;
    this._xAxisColor = YColor.Black;
    this._xAxisThickness = 1;
    this._borderPen = null;
    this._borderColor = YColor.DimGray;
    this._borderThickness = 1;
    this._bgBrush = null;
    this._font = null;
    this._directParent = directParent;
    this._parentRenderer = parent;
    this._font = new YFont(parent, this, 8, null);
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    this._enabled = value;
    this._parentRenderer.redraw();
  }
  get bgColor1() {
    return this._bgColor1;
  }
  set bgColor1(value) {
    this._bgColor1 = value;
    this._bgBrush = null;
    this._parentRenderer.redraw();
  }
  get cursorBorderColor() {
    return this._cursorBorderColor;
  }
  set cursorBorderColor(value) {
    this._cursorBorderColor = value;
    this._cursorBorderPen = null;
    this._parentRenderer.redraw();
  }
  get yAxisHandling() {
    return this._yAxisHandling;
  }
  set yAxisHandling(value) {
    this._yAxisHandling = value;
    this._parentRenderer.redraw();
  }
  get bgColor2() {
    return this._bgColor2;
  }
  set bgColor2(value) {
    this._bgColor2 = value;
    this._bgBrush = null;
    this._parentRenderer.redraw();
  }
  get cursorColor() {
    return this._cursorColor;
  }
  set cursorColor(value) {
    this._cursorColor = value;
    this._cursorBrush = null;
    this._parentRenderer.redraw();
  }
  get cursorBrush() {
    if (this._cursorBrush == null) {
      this._cursorBrush = new YSolidBrush(this._cursorColor);
    }
    return this._cursorBrush;
  }
  get pen() {
    if (this._pen == null)
      this._pen = new YPen(this._xAxisColor, this._xAxisThickness, true);
    return this._pen;
  }
  get cursorBorderPen() {
    if (this._cursorBorderPen == null)
      this._cursorBorderPen = new YPen(this._cursorBorderColor, 1, true);
    return this._cursorBorderPen;
  }
  get xAxisColor() {
    return this._xAxisColor;
  }
  set xAxisColor(value) {
    this._xAxisColor = value;
    this._pen = null;
    this._parentRenderer.redraw();
  }
  get xAxisThickness() {
    return this._xAxisThickness;
  }
  set xAxisThickness(value) {
    if (value < 0)
      throw new RangeError("Thickness must be a positive value");
    this._xAxisThickness = value;
    this._pen = null;
    this._parentRenderer.redraw();
  }
  get borderPen() {
    if (this._borderPen == null)
      this._borderPen = new YPen(this._borderColor, this._borderThickness, true);
    return this._borderPen;
  }
  get borderColor() {
    return this._borderColor;
  }
  set borderColor(value) {
    this._borderColor = value;
    this._borderPen = null;
    this._parentRenderer.redraw();
  }
  get borderThickness() {
    return this._borderThickness;
  }
  set borderThickness(value) {
    if (value < 0)
      throw new RangeError("Thickness must be a positive value");
    this._borderThickness = value;
    this._borderPen = null;
    this._parentRenderer.redraw();
  }
  setPosition(ParentWidth, ParentHeight, Lmargin, Rmargin, Tmargin, Bmargin) {
    if (this._viewport.Lmargin != Lmargin || this._viewport.Rmargin != Rmargin || this._viewport.Tmargin != Tmargin || this._viewport.Bmargin != Bmargin) {
      this._bgBrush = null;
    }
    this._viewport.Lmargin = Lmargin;
    this._viewport.Rmargin = Rmargin;
    this._viewport.Bmargin = Bmargin;
    this._viewport.Tmargin = Tmargin;
    this._viewport.Width = ParentWidth;
    this._viewport.Height = ParentHeight;
  }
  setIRLPosition(IRLx, IRLy, xZoom, yZoom) {
    this._viewport.IRLx = IRLx;
    this._viewport.IRLy = IRLy;
    this._viewport.zoomx = xZoom;
    this._viewport.zoomy = yZoom;
  }
  startCapture(IRLStartPoint, xAxisMin, xAxisMax) {
    this._viewport.OriginalXAxisMin = xAxisMin;
    this._viewport.OriginalXAxisMax = xAxisMax;
    this._viewport.OriginalIRLx = this._viewport.IRLx;
    this._viewport.OriginalLmargin = this._viewport.Lmargin;
    this._viewport.OriginalZoomx = this._viewport.zoomx;
    this._viewport.IRLCaptureStartX = IRLStartPoint.x;
    this._viewport.Capture = true;
  }
  get Capture() {
    return this._viewport.Capture;
  }
  stopCapture() {
    this._viewport.Capture = false;
  }
  get viewport() {
    return this._viewport;
  }
  get bgBrush() {
    if (this._bgBrush == null) {
      this._bgBrush = new YLinearGradientBrush(this._bgColor1, this._bgColor2);
    }
    return this._bgBrush;
  }
  get font() {
    return this._font;
  }
};
(function(Navigator2) {
  class YAxisHandlingEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, YAxisHandling);
    }
  }
  Navigator2.YAxisHandlingEnumItem = YAxisHandlingEnumItem;
  class YAxisHandling extends YEnum {
  }
  YAxisHandling.AUTO = new YAxisHandlingEnumItem("AUTO", "Automatic");
  YAxisHandling.INHERIT = new YAxisHandlingEnumItem("INHERIT", "Inherit from main view");
  Navigator2.YAxisHandling = YAxisHandling;
})(Navigator || (Navigator = {}));
var Marker = class _Marker {
  get userData() {
    return this._userData;
  }
  set userData(value) {
    this._userData = value;
  }
  static _round100(v) {
    return Math.round(100 * v) / 100;
  }
  get stringFormat() {
    if (this._stringFormat != null)
      return this._stringFormat;
    this._stringFormat = new YStringFormat(
      16384
      /* YDataRendering.YStringFormat.StringFormatFlags.NoClip */
    );
    this._stringFormat.LineAlignment = 1;
    switch (this._textAlign) {
      case _Marker.TextAlign.LEFT:
        this._stringFormat.Alignment = 0;
        break;
      case _Marker.TextAlign.CENTER:
        this._stringFormat.Alignment = 1;
        break;
      case _Marker.TextAlign.RIGHT:
        this._stringFormat.Alignment = 2;
        break;
    }
    return this._stringFormat;
  }
  get PatchTextCallback() {
    return this._MarkerTextCallback;
  }
  set PatchTextCallback(callback) {
    this._MarkerTextCallback = callback;
  }
  get directParent() {
    return this._directParent;
  }
  constructor(parent, directParent) {
    this._userData = null;
    this._stringFormat = null;
    this._MarkerTextCallback = null;
    this._enabled = false;
    this._xposition = 0;
    this._xpositionIsRelative = false;
    this._yposition = 92;
    this._text = "Marker";
    this._textAlign = _Marker.TextAlign.CENTER;
    this._bgColor = YColor.FromArgb(255, 255, 255, 192);
    this._borderColor = YColor.DarkRed;
    this._borderthickness = 1;
    this._arrowSize = 5;
    this._padding = 5;
    this._verticalMargin = 5;
    this._horizontalMargin = 5;
    this._bgBrush = null;
    this._arrowBrush = null;
    this._pen = null;
    this._navigatorpen = null;
    this._font = null;
    this._directParent = directParent;
    this._parentRenderer = parent;
    this._font = new YFont(parent, this, 8, null);
  }
  startCapture() {
    this._parentRenderer.startMarkerCapture(this);
  }
  setCapturedPosition(position, axis) {
    this.enabled = true;
    this._xpositionIsRelative = axis.timeReference == TimeConverter.TimeReference.RELATIVE && axis.zeroTime > 0;
    this._xposition = _Marker._round100(this._xpositionIsRelative ? position - axis.zeroTime : position);
    this._parentRenderer.clearCachedObjects();
    this._parentRenderer.redraw();
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    if (this._enabled != value) {
      this._enabled = value;
      this._parentRenderer.clearCachedObjects();
      this._parentRenderer.redraw();
    }
  }
  get xposition() {
    return this._xposition;
  }
  set xposition(value) {
    this._xposition = _Marker._round100(value);
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get timereference() {
    return this._xpositionIsRelative ? TimeConverter.TimeReference.RELATIVE : TimeConverter.TimeReference.ABSOLUTE;
  }
  set timereference(value) {
    let v = value == TimeConverter.TimeReference.RELATIVE;
    if (this._xpositionIsRelative != v) {
      let ZeroPosition = this._directParent.zeroTime;
      if (isNaN(ZeroPosition))
        ZeroPosition = 0;
      if (v) {
        this._xpositionIsRelative = true;
        this._xposition -= ZeroPosition;
      } else {
        this._xpositionIsRelative = false;
        this._xposition += ZeroPosition;
      }
      this._xposition = _Marker._round100(this._xposition);
      this._parentRenderer.redraw();
    }
  }
  // a special variant which also to get/set both xposition and xpositionIsRelative at the same time
  // and allow to start position capture as well.
  get positionOnXAxis() {
    return new xAxisPosition(this._xposition, this._xpositionIsRelative);
  }
  set positionOnXAxis(value) {
    if (value.capture) {
      this.startCapture();
    } else {
      let v = _Marker._round100(value.value);
      if (this._xpositionIsRelative != value.relative || this._xposition != v) {
        this._xposition = v;
        this._xpositionIsRelative = value.relative;
        if (this._enabled)
          this._parentRenderer.redraw();
      }
    }
  }
  get yposition() {
    return this._yposition;
  }
  set yposition(value) {
    this._yposition = Math.min(100, Math.max(0, value));
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get text() {
    return this._text;
  }
  set text(value) {
    this._text = value;
    this._parentRenderer.clearCachedObjects();
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get textAlign() {
    return this._textAlign;
  }
  set textAlign(value) {
    this._textAlign = value;
    this._stringFormat = null;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get shortText() {
    if (this._text.length <= 20)
      return this._text;
    return this._text.substring(0, 18) + "..";
  }
  get bgColor() {
    return this._bgColor;
  }
  set bgColor(value) {
    this._bgColor = value;
    this._bgBrush = null;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get borderColor() {
    return this._borderColor;
  }
  set borderColor(value) {
    this._borderColor = value;
    this._arrowBrush = null;
    this._pen = null;
    this._navigatorpen = null;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get borderthickness() {
    return this._borderthickness;
  }
  set borderthickness(value) {
    if (value < 0)
      throw new RangeError("thickness must be a positive value");
    this._borderthickness = value;
    this._parentRenderer.clearCachedObjects();
    this._pen = null;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get arrowSize() {
    return this._arrowSize;
  }
  set arrowSize(value) {
    this._arrowSize = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get padding() {
    return this._padding;
  }
  set padding(value) {
    if (value < 0)
      throw new RangeError("Padding must be a positive value");
    this._padding = value;
    this._parentRenderer.clearCachedObjects();
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get verticalMargin() {
    return this._verticalMargin;
  }
  set verticalMargin(value) {
    this._verticalMargin = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get horizontalMargin() {
    return this._horizontalMargin;
  }
  set horizontalMargin(value) {
    this._horizontalMargin = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get bgBrush() {
    if (this._bgBrush == null) {
      this._bgBrush = new YSolidBrush(this._bgColor);
    }
    return this._bgBrush;
  }
  get arrowBrush() {
    if (this._arrowBrush == null) {
      this._arrowBrush = new YSolidBrush(this._borderColor, true);
    }
    return this._arrowBrush;
  }
  get pen() {
    if (this._pen == null)
      this._pen = new YPen(this._borderColor, this._borderthickness, true);
    return this._pen;
  }
  get navigatorpen() {
    if (this._navigatorpen == null)
      this._navigatorpen = new YPen(this._borderColor, 1);
    return this._navigatorpen;
  }
  get font() {
    return this._font;
  }
};
(function(Marker2) {
  class TextAlignEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, TextAlign);
    }
  }
  Marker2.TextAlignEnumItem = TextAlignEnumItem;
  class TextAlign extends YEnum {
  }
  TextAlign.LEFT = new TextAlignEnumItem("LEFT", "Left");
  TextAlign.CENTER = new TextAlignEnumItem("CENTER", "Center");
  TextAlign.RIGHT = new TextAlignEnumItem("RIGHT", "Right");
  Marker2.TextAlign = TextAlign;
})(Marker || (Marker = {}));
var Legend = class {
  get directParent() {
    return this._directParent;
  }
  get userData() {
    return this._userData;
  }
  set userData(value) {
    this._userData = value;
  }
  constructor(parent, directParent) {
    this._userData = null;
    this._title = "";
    this._font = null;
    this._directParent = directParent;
    this._parentRenderer = parent;
    this._font = new YFont(parent, this, 12, null);
  }
  get title() {
    return this._title;
  }
  set title(value) {
    this._title = value;
    this._parentRenderer.redraw();
  }
  get font() {
    return this._font;
  }
};
var GenericAxis = class {
  get directParent() {
    return this._directParent;
  }
  get zones() {
    return this._zones;
  }
  AddZone() {
    let z = new Zone(this._parentRenderer, this);
    this._zones.push(z);
    return z;
  }
  get userData() {
    return this._userData;
  }
  set userData(value) {
    this._userData = value;
  }
  get AxisChanged() {
    return this._AxisChanged;
  }
  set AxisChanged(value) {
    this._AxisChanged = value;
  }
  constructor(parent, directParent) {
    this._userData = null;
    this._AxisChanged = null;
    this._pen = null;
    this._gridPen = null;
    this._visible = true;
    this._AllowAutoShow = false;
    this._min = Number.NaN;
    this._max = Number.NaN;
    this._step = Number.NaN;
    this._thickness = 1;
    this._color = YColor.Black;
    this._showGrid = false;
    this._gridColor = YColor.FromArgb(50, 0, 0, 0);
    this._gridThickness = 1;
    this._font = null;
    this._zones = [];
    this._directParent = directParent;
    this._parentRenderer = parent;
    this._legend = new Legend(parent, this);
    this._font = new YFont(parent, this);
  }
  get pen() {
    if (this._pen == null)
      this._pen = new YPen(this._color, this._thickness, true);
    return this._pen;
  }
  get gridPen() {
    if (this._gridPen == null)
      this._gridPen = new YPen(this._gridColor, this._gridThickness, true);
    return this._gridPen;
  }
  get visible() {
    return this._visible;
  }
  set visible(value) {
    this._visible = value;
    if (!value) {
      this._AllowAutoShow = false;
    }
    this._parentRenderer.redraw();
  }
  get AllowAutoShow() {
    return this._AllowAutoShow;
  }
  set AllowAutoShow(value) {
    this._AllowAutoShow = value;
  }
  AutoShow() {
    if (this._AllowAutoShow) {
      this.visible = true;
      if (this._AxisChanged != null)
        this._AxisChanged(this);
    }
  }
  set_minMax(value_min, value_max) {
    if (!isNaN(value_min) && !isNaN(value_max) && value_min >= value_max) {
      throw new RangeError("Min (" + value_min.toString() + ") cannot be greater than max (" + value_max.toString() + ")");
    }
    this._min = value_min;
    this._max = value_max;
    this._parentRenderer.redraw();
  }
  get min() {
    return this._min;
  }
  set min(value) {
    if (!isNaN(value) && !isNaN(this._max) && !YDataRenderer.minMaxCheckDisabled) {
      if (value >= this._max) {
        throw new RangeError("Min cannot be greater than max (" + this._max.toString() + ")");
      }
    }
    this._min = value;
    this._parentRenderer.redraw();
  }
  setMinMax(min, max) {
    if (min < max) {
      this._min = min;
      this._max = max;
      this._parentRenderer.redraw();
    }
  }
  get max() {
    return this._max;
  }
  set max(value) {
    if (!isNaN(value) && !isNaN(this._min) && !YDataRenderer.minMaxCheckDisabled) {
      if (value <= this._min)
        throw new RangeError("Max cannot be less than min (" + this._min.toString() + ")");
    }
    this._max = value;
    this._parentRenderer.redraw();
  }
  get step() {
    return this._step;
  }
  set step(value) {
    if (!isNaN(value) && value < 0)
      throw new RangeError("Steps must be a strictely positive value");
    this._step = value;
    this._parentRenderer.redraw();
  }
  get thickness() {
    return this._thickness;
  }
  set thickness(value) {
    if (value < 0)
      throw new RangeError("Thickness must be a positive value");
    this._thickness = value;
    this._pen = null;
    this._parentRenderer.redraw();
  }
  get color() {
    return this._color;
  }
  set color(value) {
    this._color = value;
    this._pen = null;
    this._parentRenderer.redraw();
  }
  get showGrid() {
    return this._showGrid;
  }
  set showGrid(value) {
    this._showGrid = value;
    this._parentRenderer.redraw();
  }
  get gridColor() {
    return this._gridColor;
  }
  set gridColor(value) {
    this._gridColor = value;
    this._gridPen = null;
    this._parentRenderer.redraw();
  }
  get gridThickness() {
    return this._gridThickness;
  }
  set gridThickness(value) {
    if (value < 0)
      throw new RangeError("Thickness must be a positive value");
    this._gridThickness = value;
    this._gridPen = null;
    this._parentRenderer.redraw();
  }
  get font() {
    return this._font;
  }
  get legend() {
    return this._legend;
  }
};
var StartStopStep = class {
  constructor() {
    this.dataMin = 0;
    this.dataMax = 0;
    this.absMin = 0;
    this.absMax = 0;
    this.step = 0;
    this.start = 0;
    this.stop = 0;
    this.precision = 0;
  }
};
var xAxisPosition = class _xAxisPosition {
  get relative() {
    return this._isRelative;
  }
  set relative(value) {
    this._isRelative = value;
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value;
  }
  constructor(v, rel, capture) {
    this._isRelative = false;
    this._value = 0;
    this._capture = false;
    this._isRelative = rel;
    this._value = v;
    this._capture = typeof capture == "undefined" ? false : capture;
  }
  clone() {
    return new _xAxisPosition(this._value, this._isRelative, this._capture);
  }
  toString() {
    if (this._isRelative) {
      return TimeConverter.secTimeSpanToString(this._value, 0);
    } else {
      let date = TimeConverter.FromUnixTime(this._value);
      let res = date.getFullYear().toString() + "-" + (date.getMonth() + 1).toString() + "-" + date.getDate().toString() + " " + date.getHours().toString() + ":";
      let st = date.getMinutes().toString();
      if (st.length <= 1)
        st = "0" + st;
      res = res + st + ":";
      let s = date.getSeconds();
      let ms = date.getMilliseconds();
      s = s + ms / 1e3;
      if (s < 10)
        res = res + "0";
      if (ms == 0) {
        res = res + s.toString();
      } else {
        res = res + s.toFixed(3);
      }
      return res;
    }
  }
  TryParse(str) {
    if (this._isRelative)
      return TimeConverter.tryParseStringToSecTimeSpan(str);
    return TimeConverter.tryParseStringToAbsDateTime(str);
  }
  get capture() {
    return this._capture;
  }
  set capture(value) {
    this._capture = value;
  }
};
xAxisPosition.DTdisplayformat = "DD/MM/YY hh:mm:ss.ff";
xAxisPosition.TSdisplayformat = "dd.hh:mm:ss.ff";
var YNumberFormatInfo = class {
  constructor() {
    this.NumberDecimalSeparator = ".";
  }
};
var YAxis = class _YAxis extends GenericAxis {
  constructor(parent, directParent, index) {
    super(parent, directParent);
    this._index = 0;
    this._highlightZero = false;
    this._position = _YAxis.HrzPosition.LEFT;
    this.innerWidth = 0;
    this.zoom = 0;
    this.IRLy = 0;
    this._index = index;
    this.nfi = new YNumberFormatInfo();
    this.nfi.NumberDecimalSeparator = ".";
    this.startStopStep = new StartStopStep();
    this.startStopStep.start = 0;
    this.startStopStep.stop = 1;
    this.startStopStep.step = 0.1;
  }
  get index() {
    return this._index;
  }
  lockMinMax() {
    this._min = this.startStopStep.absMin;
    this._max = this.startStopStep.absMax;
    this._parentRenderer.redraw();
  }
  unlockMinMax() {
    this._min = Number.NaN;
    this._max = Number.NaN;
    this._parentRenderer.redraw();
  }
  get highlightZero() {
    return this._highlightZero;
  }
  set highlightZero(value) {
    this._highlightZero = value;
    this._parentRenderer.redraw();
  }
  get position() {
    return this._position;
  }
  set position(value) {
    this._position = value;
    this._parentRenderer.redraw();
  }
  computeStartAndStep(M) {
    let res = new StartStopStep();
    let min = this.min;
    let max = this.max;
    res.step = this.step;
    res.precision = 0;
    if (!MinMaxHandler.isDefined(M)) {
      M = MinMaxHandler.DefaultValue();
      M.Min = 0;
      M.Max = 100;
    }
    if (isNaN(min))
      min = M.Min;
    if (isNaN(max))
      max = M.Max;
    res.absMax = max;
    res.absMin = min;
    if (min == max) {
      min -= 0.5;
      max += 0.5;
    }
    if (min != 0)
      min -= (max - min) * 0.025;
    if (max != 0)
      max += (max - min) * 0.025;
    res.start = min;
    res.stop = max;
    res.dataMin = min;
    res.dataMax = max;
    let Delta = max - min;
    if (isNaN(res.step)) {
      let MagnitudePwr = Math.log10(Delta);
      if (MagnitudePwr - Math.floor(MagnitudePwr) != 0)
        MagnitudePwr = Math.floor(MagnitudePwr) + 1;
      res.precision = MagnitudePwr - 1 >> 0;
      let Magnitude = Math.pow(10, res.precision);
      let C = Delta / Magnitude;
      if (C <= 2) {
        res.step = Magnitude / 5;
        res.precision--;
      } else if (C <= 5) {
        res.step = Magnitude / 2;
        res.precision--;
      } else {
        res.step = Magnitude;
      }
      if (isNaN(this.min)) {
        let c = min / res.step;
        if (c - Math.floor(c) != 0)
          c = c > 0 ? Math.floor(c) + 1 : Math.floor(c) - 1;
        res.start = res.step * c;
      }
    } else {
      let v = res.step.toString();
      let p = v.indexOf(".");
      if (p >= 0) {
        res.precision = -(v.length - p - 1);
      } else {
        res.precision = 0;
      }
    }
    this.startStopStep = res;
    return res;
  }
};
(function(YAxis2) {
  class HrzPositionEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, HrzPosition);
    }
  }
  YAxis2.HrzPositionEnumItem = HrzPositionEnumItem;
  class HrzPosition extends YEnum {
  }
  HrzPosition.LEFT = new HrzPositionEnumItem("LEFT", "Left");
  HrzPosition.RIGHT = new HrzPositionEnumItem("RIGHT", "Right");
  YAxis2.HrzPosition = HrzPosition;
})(YAxis || (YAxis = {}));
var XAxis = class _XAxis extends GenericAxis {
  get position() {
    return this._position;
  }
  set position(value) {
    this._position = value;
    this._parentRenderer.redraw();
  }
  get markers() {
    return this._markers;
  }
  AddMarker() {
    let m = new Marker(this._parentGraph, this);
    this._markers.push(m);
    this._parentGraph.clearCachedObjects();
    this._parentGraph.redraw();
    return m;
  }
  get initialZoom() {
    return this._initialZoom;
  }
  set initialZoom(value) {
    if (value <= 0)
      throw new RangeError("Zoom must be a positive value");
    this._initialZoom = value;
    this.min = this.min - this._initialZoom * this._initialOffset / 100;
    this.max = this.min + this.initialZoom;
    this._parentRenderer.redraw();
  }
  get initialOffset() {
    return this._initialOffset;
  }
  set initialOffset(value) {
    this._initialOffset = value;
    let p = this._parentGraph.getMostRecentPoint();
    if (isNaN(p.x)) {
      this._min = this._min - this._initialZoom * this._initialOffset / 100;
      this._max = this._min + this._initialZoom;
      this._parentRenderer.redraw();
    } else {
      let zoom = this._max - this._min;
      this._min = p.x - zoom * this._initialOffset / 100;
      this._max = this._min + zoom;
    }
    this._parentRenderer.redraw();
  }
  get labelFormat() {
    return this._format;
  }
  set labelFormat(value) {
    this._format = value;
    this._parentRenderer.redraw();
  }
  constructor(parent, directParent) {
    super(parent, directParent);
    this._position = _XAxis.VrtPosition.BOTTOM;
    this._markers = [];
    this._initialZoom = 300;
    this._initialOffset = 0;
    this._format = _XAxis.FORMATAUTO;
    this._timeReference = TimeConverter.TimeReference.ABSOLUTE;
    this._zeroTime = 0;
    this._fullSize = 0;
    this.innerHeight = 0;
    this._overflowHandling = _XAxis.OverflowHandling.DONOTHING;
    this._parentGraph = parent;
    this._markers = [];
    this.min = TimeConverter.ToUnixTime(TimeConverter.UTCNow());
    this.max = this.min + this.initialZoom;
    this.step = 30;
  }
  get timeReference() {
    return this._timeReference;
  }
  set timeReference(value) {
    this._timeReference = value;
    this._parentRenderer.redraw();
  }
  get zeroTime() {
    return this._zeroTime;
  }
  set zeroTime(value) {
    this._zeroTime = value;
  }
  get fullSize() {
    return this._fullSize;
  }
  set fullSize(value) {
    this._fullSize = value;
  }
  bestFormat(dataTimedelta, viewportTimedelta) {
    return TimeConverter.BestTimeformat(dataTimedelta, viewportTimedelta, this._timeReference);
  }
  get overflowHandling() {
    return this._overflowHandling;
  }
  set overflowHandling(value) {
    this._overflowHandling = value;
  }
};
XAxis.FORMATAUTO = 0;
(function(XAxis2) {
  class VrtPositionEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, VrtPosition);
    }
  }
  XAxis2.VrtPositionEnumItem = VrtPositionEnumItem;
  class VrtPosition extends YEnum {
  }
  VrtPosition.TOP = new VrtPositionEnumItem("TOP", "Top");
  VrtPosition.BOTTOM = new VrtPositionEnumItem("BOTTOM", "Bottom");
  XAxis2.VrtPosition = VrtPosition;
  class OverflowHandlingEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, OverflowHandling);
    }
  }
  XAxis2.OverflowHandlingEnumItem = OverflowHandlingEnumItem;
  class OverflowHandling extends YEnum {
  }
  OverflowHandling.DONOTHING = new OverflowHandlingEnumItem("DONOTHING", "Do nothing");
  OverflowHandling.SCROLL = new OverflowHandlingEnumItem("SCROLL", "Scroll contents");
  OverflowHandling.CONTRACT = new OverflowHandlingEnumItem("CONTRACT", "Squeeze contents");
  XAxis2.OverflowHandling = OverflowHandling;
})(XAxis || (XAxis = {}));
var DataPanel = class _DataPanel extends GenericPanel {
  constructor(parent, directParent) {
    super(parent, directParent);
    this._panelHrzAlign = _DataPanel.HorizontalAlign.CENTERED;
    this._panelVrtAlign = _DataPanel.VerticalAlign.CENTERED;
    this._horizontalPosition = _DataPanel.HorizontalPosition.ABSOLUTEX;
    this._verticalPosition = _DataPanel.VerticalPosition.ABSOLUTEY;
    this._AbsoluteXposition = 0;
    this._AbsoluteYposition = 0;
    this._YScaleIndex = 0;
  }
  get panelHrzAlign() {
    return this._panelHrzAlign;
  }
  set panelHrzAlign(value) {
    this._panelHrzAlign = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get panelVrtAlign() {
    return this._panelVrtAlign;
  }
  set panelVrtAlign(value) {
    this._panelVrtAlign = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get horizontalPosition() {
    return this._horizontalPosition;
  }
  set horizontalPosition(value) {
    this._horizontalPosition = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get verticalPosition() {
    return this._verticalPosition;
  }
  set verticalPosition(value) {
    this._verticalPosition = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get AbsoluteXposition() {
    return this._AbsoluteXposition;
  }
  set AbsoluteXposition(value) {
    this._AbsoluteXposition = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get AbsoluteYposition() {
    return this._AbsoluteYposition;
  }
  set AbsoluteYposition(value) {
    this._AbsoluteYposition = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get yScaleIndex() {
    return this._YScaleIndex;
  }
  set yScaleIndex(value) {
    this._YScaleIndex = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
};
(function(DataPanel2) {
  class HorizontalAlignEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, HorizontalAlign);
    }
  }
  DataPanel2.HorizontalAlignEnumItem = HorizontalAlignEnumItem;
  class HorizontalAlign extends YEnum {
  }
  HorizontalAlign.LEFTOF = new HorizontalAlignEnumItem("LEFTOF", "Left");
  HorizontalAlign.CENTERED = new HorizontalAlignEnumItem("CENTERED", "Center");
  HorizontalAlign.RIGHTOF = new HorizontalAlignEnumItem("RIGHTOF", "Right");
  DataPanel2.HorizontalAlign = HorizontalAlign;
  class VerticalAlignEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, VerticalAlign);
    }
  }
  DataPanel2.VerticalAlignEnumItem = VerticalAlignEnumItem;
  class VerticalAlign extends YEnum {
  }
  VerticalAlign.ABOVE = new VerticalAlignEnumItem("ABOVE", "Top");
  VerticalAlign.CENTERED = new VerticalAlignEnumItem("CENTERED", "Center");
  VerticalAlign.BELOW = new VerticalAlignEnumItem("BELOW", "Bottom");
  DataPanel2.VerticalAlign = VerticalAlign;
  class HorizontalPositionEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, HorizontalPosition);
    }
  }
  DataPanel2.HorizontalPositionEnumItem = HorizontalPositionEnumItem;
  class HorizontalPosition extends YEnum {
  }
  HorizontalPosition.LEFTBORDER = new HorizontalPositionEnumItem("LEFTBORDER", "Left border");
  HorizontalPosition.ABSOLUTEX = new HorizontalPositionEnumItem("ABSOLUTEX", "Absolute X position");
  HorizontalPosition.RIGHTBORDER = new HorizontalPositionEnumItem("RIGHTBORDER", "Right borde");
  DataPanel2.HorizontalPosition = HorizontalPosition;
  class VerticalPositionEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, VerticalPosition);
    }
  }
  DataPanel2.VerticalPositionEnumItem = VerticalPositionEnumItem;
  class VerticalPosition extends YEnum {
  }
  VerticalPosition.TOPBORDER = new VerticalPositionEnumItem("TOPBORDER", "Top border");
  VerticalPosition.ABSOLUTEY = new VerticalPositionEnumItem("ABSOLUTEY", "Absolute Y position");
  VerticalPosition.BOTTOMBORDER = new VerticalPositionEnumItem("BOTTOMBORDER", "Bottom border");
  DataPanel2.VerticalPosition = VerticalPosition;
})(DataPanel || (DataPanel = {}));
var YCursor = class {
  constructor(pngImageData) {
  }
  get handle() {
    return "crosshair";
  }
};
var YTimeSpan = class {
  constructor(value) {
    this._value = 0;
    this._value = value;
  }
  toString(format) {
    let res = "";
    let v = Math.abs(this._value / 1e3);
    let dec = Math.floor(v);
    let frac = Math.round(1e3 * (v - Math.floor(v)));
    if (format & YDate.ms1) {
      let ms = "00" + frac.toString();
      res = "." + ms.substring(ms.length - 3).substring(0, 1);
    } else if (format & YDate.ms01) {
      let ms = "00" + frac.toString();
      res = "." + ms.substring(ms.length - 3).substring(0, 2);
    } else if (format & YDate.ms001) {
      let ms = "00" + frac.toString();
      res = "." + ms.substring(ms.length - 3).substring(0, 3);
    }
    if (format & YDate.s) {
      let sec = dec % 60;
      let s = "0" + sec.toString();
      res = s.substring(s.length - 2) + res + "s";
    }
    dec = Math.floor(dec / 60);
    if (format & YDate.m) {
      let min = dec % 60;
      let s = "0" + min.toString();
      res = s.substring(s.length - 2) + "m" + res;
    }
    dec = Math.floor(dec / 60);
    if (format & YDate.h) {
      let hrs = dec % 24;
      let s = "0" + hrs.toString();
      res = s.substring(s.length - 2) + "h" + res;
    }
    dec = Math.floor(dec / 24);
    if (format & YDate.D) {
      let s = dec.toString();
      res = s.substring(s.length - 2) + "d" + res;
    }
    return res;
  }
};
YTimeSpan.TicksPerSecond = 1e3;
var YGraph = class _YGraph extends YDataRenderer {
  get legendPanel() {
    return this._legendPanel;
  }
  get dataTracker() {
    return this._dataTracker;
  }
  get borderColor() {
    return this._borderColor;
  }
  set borderColor(value) {
    this._borderColor = value;
    this._borderPen = null;
    this.redraw();
  }
  get borderThickness() {
    return this._borderThickness;
  }
  set borderThickness(value) {
    if (value < 0)
      throw new RangeError("thickness must be a positive value");
    this._borderThickness = value;
    this._borderPen = null;
    this.redraw();
  }
  static get verticalDragZoomEnabled() {
    return _YGraph._defaultVerticalDragZoomEnabled;
  }
  static set verticalDragZoomEnabled(value) {
    _YGraph._defaultVerticalDragZoomEnabled = value;
  }
  static createCaptureCursor() {
    if (_YGraph.captureCursor != null)
      return;
    let base64png = "iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAALHRFWHRDcmVhdGlvbiBUaW1lAFRodSAyMCBBdWcgMjAyMCAxMjoxNTo1MCArMDEwMP38NhoAAAAHdElNRQfkCBQOJAvCrm0ZAAAACXBIWXMAAFxGAABcRgEUlENBAAAABGdBTUEAALGPC / xhBQAAAmVJREFUeNrtVrFuFDEQHd9eBImAIBFoAgVC0NJQUFDwL / QgRXzAfUz + Iy0pQwsIJAhCQMQBUS5c2DXv7T5fzN5qs / Fxdw0jPY3ttT3jt54ZmyXIYDDoQXnodWBV / SRJXZhJbwCXov65pZ + 4zklfBsZRf2EMxOuTjc / igIu0s0UygAvnonWZ0NP4fB2QkQz6yHvP / i76V4E1jZ / bic4LIuMnND7ZwDl + u4 / me + AnkKPvu + 7rFMNZBzZ64eRTm5w6sQ8cAcUZexVytOCpOnv7j + QdDD + CHgKjMg80nWpeQrYgd4A3wHjWPJAqN4BVoLcsB1ZMd25ZDkzkvwNLd6AMQ4XGIuXElKz6SAo3rYpLhsZKyyJmwu2WTLiF5g / g2NozIY1 / BkacRwaYkZgUPlr7L2EdeAhjLxpqwTOr0vAHOZG37FPIOO3mfXXG1qEWAGvM + TC6Rydk / KmMv7bmWlD / v95qtaCThGpo1TPsFvp7wBO0v4nBqWoYvR0yOeLFThHmdH4TcgGQy8i + hkn5V / WbSjGr7e9oD96372LJB1o7izbPtYHpPw7V / 8u4yvzFkvPTO3MXuMbx8JRPij8svgAcAw / EwCe0f8XGxZYFB6JQZzl + rHWj1Gf5WZLVTj5py5HbVoXjeF4OuMhYnQHKulW / x6U64CPtbfpVxQu7CX0PeicMov3cKup5EZmw / KwMFNb8pMtl5G3MhIyHkOX3PPUSMmXzOX7Fqsw35Gu5NidEwXWr / jnnD + XUFzLARJRaDXnCQ53o0BpSLzcXzQfAK + Cl9EEwXrKTyr1OWGa3sFnLvPDsn6Tg8P0PrBcSMR2NtfsAAAAASUVORK5CYII =";
    try {
      _YGraph.captureCursor = new YCursor(atob(base64png));
    } catch (Exception) {
      console.log("Cannot create custom cursor");
    }
  }
  get dataPanels() {
    return this._dataPanels;
  }
  addDataPanel() {
    let p = new DataPanel(this, this);
    this._dataPanels.push(p);
    return p;
  }
  setMarkerCaptureCallbacks(start, stop) {
    this._markerCaptureStartedCallback = start;
    this._markerCaptureStoppedCallback = stop;
  }
  startMarkerCapture(m) {
    if (this._markerCaptureStartedCallback != null)
      this._markerCaptureStartedCallback(m);
    this.markerCapture = m;
    this.UIContainer.focus();
  }
  constructor(ChartContainer, logFunction) {
    super(ChartContainer, logFunction);
    this._markerCaptureStartedCallback = null;
    this._markerCaptureStoppedCallback = null;
    this.lastPointCount = -1;
    this.lastTopMargin = -1;
    this.lastBottomMargin = -1;
    this.navigatorCache = null;
    this.markerCapture = null;
    this._borderPen = null;
    this._borderColor = YColor.LightGray;
    this._borderThickness = 1;
    this._touchStartfct = null;
    this._touchMovefct = null;
    this._touchEndfct = null;
    this._mouseDownfct = null;
    this._mouseMovefct = null;
    this._mouseWheelfct = null;
    this._mouseKeyDownfct = null;
    this.mainViewPort = new ViewPortSettings();
    this._timeRange = null;
    this._bgBrush = null;
    this._bgColor1 = YColor.FromArgb(255, 200, 200, 200);
    this._bgColor2 = YColor.FromArgb(255, 255, 255, 255);
    this._touchStartPinchDistance = -1;
    this._touchStartPinchCenter = new Point(0, 0);
    this._touchStartPinchZoom = 1;
    this._touchStartPinchIRLx = 0;
    this._touchStartPinchRange = 0;
    this.dataTrackerRefreshtimeout = null;
    _YGraph.createCaptureCursor();
    this._xAxis = new XAxis(this, this);
    this._yAxes = [];
    this._series = [];
    this._dataPanels = [];
    this._navigator = new Navigator(this, this);
    this._legendPanel = new LegendPanel(this, this);
    this._dataTracker = new DataTracker(this, this);
    this._touchStartfct = (e) => {
      this.TouchStart(this.UIContainer, e);
    };
    this._touchMovefct = (e) => {
      this.TouchMove(this.UIContainer, e);
    };
    this._touchEndfct = (e) => {
      this.TouchEnd(this.UIContainer, e);
    };
    this._mouseDownfct = (e) => {
      this.MouseDown(this.UIContainer, e);
    };
    this._mouseMovefct = (e) => {
      this.MouseMove(this.UIContainer, e);
    };
    this._mouseWheelfct = (e) => {
      this.mouseWheelEvent(this.UIContainer, e);
    };
    this._mouseKeyDownfct = (e) => {
      this.KeyDown(this.UIContainer, e);
    };
    this.UIContainer.addEventListener("touchstart", this._touchStartfct);
    this.UIContainer.addEventListener("touchmove", this._touchMovefct);
    this.UIContainer.addEventListener("touchend", this._touchEndfct);
    this.UIContainer.addEventListener("mousedown", this._mouseDownfct);
    this.UIContainer.addEventListener("mousemove", this._mouseMovefct);
    this.UIContainer.addEventListener("wheel", this._mouseWheelfct);
    this.UIContainer.addEventListener("keydown", this._mouseKeyDownfct);
    this._timeRange = MinMaxHandler.DefaultValue();
    let originalContainerWidth = ChartContainer.width;
    let originalContainerHeight = ChartContainer.height;
    let originalFormWidth = ChartContainer.width;
    let originalFormHeight = ChartContainer.height;
  }
  destroy() {
    if (this._touchStartfct != null)
      this.UIContainer.removeEventListener("touchstart", this._touchStartfct);
    if (this._touchMovefct != null)
      this.UIContainer.removeEventListener("touchstart", this._touchMovefct);
    if (this._touchEndfct != null)
      this.UIContainer.removeEventListener("touchstart", this._touchEndfct);
    if (this._mouseDownfct != null)
      this.UIContainer.removeEventListener("mousedown", this._mouseDownfct);
    if (this._mouseMovefct != null)
      this.UIContainer.removeEventListener("mousemove", this._mouseMovefct);
    if (this._mouseWheelfct != null)
      this.UIContainer.removeEventListener("wheel", this._mouseWheelfct);
    if (this._mouseKeyDownfct != null)
      this.UIContainer.removeEventListener("keydown", this._mouseKeyDownfct);
    super.destroy();
    Object.entries(this).forEach((pair) => {
      Reflect.set(this, pair[0], null);
    });
  }
  getMostRecentPoint() {
    let res = new pointXY(NaN, NaN);
    for (let i = 0; i < this._series.length; i++)
      if (!this.series[i].disabled) {
        let p = this.series[i].getlastPoint();
        if (!isNaN(p.x)) {
          if (isNaN(res.x))
            res = p;
          else if (p.x > res.x)
            res = p;
        }
      }
    return res;
  }
  adjustGlobalTimeRange(x) {
    let max = this._timeRange.Max;
    this._timeRange = MinMaxHandler.CombineWithNumber(this._timeRange, x);
    if (isNaN(max))
      return;
    let ofset = x - max;
    if (ofset > 0) {
      switch (this._xAxis.overflowHandling) {
        case XAxis.OverflowHandling.SCROLL:
          if (max > this._xAxis.min + (this._xAxis.max - this._xAxis.min) * 0.85 && max <= this._xAxis.max) {
            this.DisableRedraw();
            this._xAxis.set_minMax(this._xAxis.min + ofset, this._xAxis.max + ofset);
            this.AllowRedraw();
          }
          break;
        case XAxis.OverflowHandling.CONTRACT:
          if (max > this._xAxis.min + (this._xAxis.max - this._xAxis.min) * 0.95 && max <= this._xAxis.max) {
            this.DisableRedraw();
            this._xAxis.max += ofset;
            this.AllowRedraw();
          }
          break;
      }
    }
  }
  get bgColor1() {
    return this._bgColor1;
  }
  set bgColor1(value) {
    this._bgColor1 = value;
    this._bgBrush = null;
    this.redraw();
  }
  get bgColor2() {
    return this._bgColor2;
  }
  set bgColor2(value) {
    this._bgColor2 = value;
    this._bgBrush = null;
    this.redraw();
  }
  get xAxis() {
    return this._xAxis;
  }
  get navigator() {
    return this._navigator;
  }
  get yAxes() {
    return this._yAxes;
  }
  get series() {
    return this._series;
  }
  addYAxis() {
    let s = new YAxis(this, this, this._yAxes.length);
    this._yAxes.push(s);
    this.redraw();
    return s;
  }
  addSerie() {
    let s = new DataSerie(this);
    this._series.push(s);
    this.redraw();
    return s;
  }
  clearCachedObjects() {
    this._bgBrush = null;
    this.navigatorCache = null;
  }
  TouchStart(sender, e) {
    if (e.touches.length == 1) {
      this.HandleMouseDown(sender, e.touches[0].pageX, e.touches[0].pageY);
    } else if (e.touches.length == 2) {
      e.preventDefault();
      this.HandleEndOfMouseCapture();
      this._touchStartPinchDistance = Math.sqrt(Math.pow(e.touches[1].pageX - e.touches[0].pageX, 2) + Math.pow(e.touches[1].pageY - e.touches[0].pageY, 2));
      this._touchStartPinchCenter = new Point(e.touches[1].pageX + e.touches[0].pageX >> 2, e.touches[1].pageY + e.touches[0].pageY >> 2);
      this._touchStartPinchZoom = this.mainViewPort.zoomx;
      this._touchStartPinchIRLx = this.mainViewPort.IRLx;
      this._touchStartPinchRange = this._xAxis.max - this._xAxis.min;
    }
  }
  MouseDown(sender, e) {
    if (e.buttons == 2 && this.markerCapture != null) {
      this.markerCapture = null;
      if (this._markerCaptureStoppedCallback != null)
        this._markerCaptureStoppedCallback(null);
    }
    if (e.buttons != 1)
      return;
    this.HandleMouseDown(sender, e.pageX, e.pageY);
  }
  HandleMouseDown(sender, pageX, pageY) {
    let p = this.Scr2ElmMatrix.multiplyByV(Vector3.FromXYCoord(pageX, pageY)).toPoint();
    let eX = p.X;
    let eY = p.Y;
    if (eX >= this.mainViewPort.Lmargin && eX <= this.mainViewPort.Width - this.mainViewPort.Rmargin && eY >= this.mainViewPort.Tmargin && eY <= this.mainViewPort.Height - this.mainViewPort.Bmargin) {
      if (this.markerCapture != null) {
        let p22 = _YGraph.ViewPortPointToIRL(this.mainViewPort, new Point(eX, eY));
        this.markerCapture.setCapturedPosition(p22.x, this.xAxis);
        if (this._markerCaptureStoppedCallback != null)
          this._markerCaptureStoppedCallback(this.markerCapture);
        this.markerCapture = null;
        return;
      }
      let p2 = _YGraph.ViewPortPointToIRL(this.mainViewPort, new Point(eX, eY));
      this.mainViewPort.OriginalXAxisMin = this.xAxis.min;
      this.mainViewPort.OriginalXAxisMax = this.xAxis.max;
      this.mainViewPort.OriginalIRLx = this.mainViewPort.IRLx;
      this.mainViewPort.OriginalLmargin = this.mainViewPort.Lmargin;
      this.mainViewPort.OriginalZoomx = this.mainViewPort.zoomx;
      this.mainViewPort.CaptureStartY = eY;
      this.mainViewPort.IRLCaptureStartX = p2.x;
      this.mainViewPort.Capture = true;
    } else if (eX >= this._navigator.viewport.Lmargin && eX <= this._navigator.viewport.Width - this._navigator.viewport.Rmargin && eY >= this._navigator.viewport.Lmargin && eY <= this._navigator.viewport.Height - this._navigator.viewport.Bmargin) {
      let p2 = _YGraph.ViewPortPointToIRL(this._navigator.viewport, new Point(eX, eY));
      let p22 = _YGraph.ViewPortPointToIRL(this.mainViewPort, new Point(this.mainViewPort.Lmargin, 0));
      let p3 = _YGraph.ViewPortPointToIRL(this.mainViewPort, new Point(this.mainViewPort.Width - this.mainViewPort.Rmargin, 0));
      if (p2.x >= p22.x && p2.x <= p3.x) {
        this._navigator.startCapture(p2, this._xAxis.min, this._xAxis.max);
      } else {
        this.DisableRedraw();
        let min = p2.x - (p3.x - p22.x) / 2;
        let max = min + (p3.x - p22.x);
        this._xAxis.set_minMax(min, max);
        this.AllowRedraw();
        this.Draw(0);
      }
    }
  }
  TouchMove(sender, e) {
    if (e.touches.length == 1) {
      e.preventDefault();
      this.HandleMouseMove(sender, e.touches[0].pageX, e.touches[0].pageY);
    } else if (e.touches.length == 2) {
      e.preventDefault();
      let newdistance = Math.sqrt(Math.pow(e.touches[1].pageX - e.touches[0].pageX, 2) + Math.pow(e.touches[1].pageY - e.touches[0].pageY, 2));
      let ZoomFactor = newdistance / this._touchStartPinchDistance;
      let NextZoomX = this._touchStartPinchZoom * ZoomFactor;
      if (NextZoomX > this.mainViewPort.zoomx && NextZoomX > 1e3)
        return;
      let currentRange = this._xAxis.max - this._xAxis.min;
      this.mainViewPort.IRLx = this._touchStartPinchIRLx + (this._touchStartPinchCenter.X - this.mainViewPort.Lmargin) / this._touchStartPinchZoom - (this._touchStartPinchCenter.X - this.mainViewPort.Lmargin) / NextZoomX;
      this._xAxis.set_minMax(this.mainViewPort.IRLx, this.mainViewPort.IRLx + this._touchStartPinchRange / ZoomFactor);
      this.mainViewPort.zoomx = NextZoomX;
      this.redraw();
    }
  }
  TouchEnd(sender, e) {
    this.HandleEndOfMouseCapture();
  }
  MouseMove(sender, e) {
    if (e.buttons != 1 && (this.mainViewPort.Capture || this._navigator.Capture))
      this.HandleEndOfMouseCapture();
    this.HandleMouseMove(sender, e.pageX, e.pageY);
    if (this.dataTracker.enabled) {
      if (this.dataTrackerRefreshtimeout != null)
        clearTimeout(this.dataTrackerRefreshtimeout);
      this.dataTrackerRefreshtimeout = setTimeout(() => {
        this.redraw();
      }, 100);
    }
  }
  HandleEndOfMouseCapture() {
    this.mainViewPort.Capture = false;
    this._navigator.stopCapture();
    if (this._dataTracker.enabled)
      this.redraw();
  }
  HandleMouseMove(sender, pageX, pageY) {
    let p = this.Scr2ElmMatrix.multiplyByV(Vector3.FromXYCoord(pageX, pageY)).toPoint();
    let eX = p.X;
    let eY = p.Y;
    if (this.markerCapture != null) {
      if (eX > this.mainViewPort.Lmargin && eX < this.mainViewPort.Width - this.mainViewPort.Rmargin && eY > this.mainViewPort.Tmargin && eY < this.mainViewPort.Height - this.mainViewPort.Bmargin) {
        if (this.UIContainer.style.cursor != _YGraph.captureCursor.handle && this.UIContainer.style.cursor != "crosshair") {
          this.UIContainer.style.cursor = _YGraph.captureCursor != null ? _YGraph.captureCursor.handle : "crosshair";
        }
      } else if (this.UIContainer.style.cursor != "default")
        this.UIContainer.style.cursor = "default";
    } else if (this.UIContainer.style.cursor != "default")
      this.UIContainer.style.cursor = "default";
    if (this.mainViewPort.Capture) {
      let x1 = this.mainViewPort.OriginalIRLx + (eX - this.mainViewPort.OriginalLmargin) / this.mainViewPort.OriginalZoomx;
      let deltaX = x1 - this.mainViewPort.IRLCaptureStartX;
      let deltaY = eY - this.mainViewPort.CaptureStartY;
      this.DisableRedraw();
      let halfAxisDelta = (this.mainViewPort.OriginalXAxisMax - this.mainViewPort.OriginalXAxisMin) / 2;
      let Axismiddle = (this.mainViewPort.OriginalXAxisMax + this.mainViewPort.OriginalXAxisMin) / 2;
      let deltaCoef = _YGraph._defaultVerticalDragZoomEnabled && Math.abs(deltaY) > 10 ? Math.pow(1.01, deltaY) : 1;
      this._xAxis.set_minMax(Axismiddle - halfAxisDelta * deltaCoef - deltaX, Axismiddle + halfAxisDelta * deltaCoef - deltaX);
      this.AllowRedraw();
      this.redraw();
      return;
    }
    if (this._navigator.viewport.Capture) {
      let x1 = this._navigator.viewport.OriginalIRLx + (eX - this._navigator.viewport.OriginalLmargin) / this._navigator.viewport.OriginalZoomx;
      let delta = x1 - this._navigator.viewport.IRLCaptureStartX;
      this.DisableRedraw();
      this._xAxis.set_minMax(this._navigator.viewport.OriginalXAxisMin + delta, this._navigator.viewport.OriginalXAxisMax + delta);
      this.AllowRedraw();
      this.redraw();
      return;
    }
  }
  cross(p) {
  }
  static IRLPointToViewPort(viewport, p, IRLy, zoomy) {
    if (IRLy === void 0) {
      let xx2 = viewport.Lmargin + Math.round((p.x - viewport.IRLx) * viewport.zoomx);
      let yy2 = viewport.Height - viewport.Bmargin - Math.round((p.y - viewport.IRLy) * viewport.zoomy);
      return new Point(xx2 >> 0, yy2 >> 0);
    }
    let xx = viewport.Lmargin + Math.round((p.x - viewport.IRLx) * viewport.zoomx);
    let yy = viewport.Height - viewport.Bmargin - Math.round((p.y - IRLy) * zoomy);
    return new Point(xx >> 0, yy >> 0);
  }
  static IRLPointSummaryToViewPort(viewport, p, IRLy, zoomy) {
    if (IRLy === void 0) {
      let x12 = viewport.Lmargin + Math.round((p.x1 - viewport.IRLx) * viewport.zoomx);
      let ymin2 = viewport.Height - viewport.Bmargin - Math.round((p.ymin - viewport.IRLy) * viewport.zoomy);
      let x22 = viewport.Lmargin + Math.round((p.x2 - viewport.IRLx) * viewport.zoomx);
      let ymax2 = viewport.Height - viewport.Bmargin - Math.round((p.ymax - viewport.IRLy) * viewport.zoomy);
      return new minMaxPoint(x12, ymin2, x22, ymax2);
    }
    let x1 = viewport.Lmargin + Math.round((p.x1 - viewport.IRLx) * viewport.zoomx);
    let ymin = viewport.Height - viewport.Bmargin - Math.round((p.ymin - IRLy) * zoomy);
    let x2 = viewport.Lmargin + Math.round((p.x2 - viewport.IRLx) * viewport.zoomx);
    let ymax = viewport.Height - viewport.Bmargin - Math.round((p.ymax - IRLy) * zoomy);
    return new minMaxPoint(x1, ymin, x2, ymax);
  }
  static ViewPortPointToIRL(viewport, p, IRLy, zoomy) {
    if (IRLy === void 0) {
      return new pointXY(viewport.IRLx + (p.X - viewport.Lmargin) / viewport.zoomx, viewport.IRLy + (+viewport.Height - p.Y - viewport.Bmargin) / viewport.zoomy);
    }
    return new pointXY(viewport.IRLx + (p.X - viewport.Lmargin) / viewport.zoomx, IRLy + (+viewport.Height - p.Y - viewport.Bmargin) / zoomy);
  }
  static FindMinMax(start, end, data, count) {
    let res = MinMaxHandler.DefaultValue();
    if (data[0].x > end)
      return res;
    if (data[count - 1].x < start)
      return res;
    let N1 = 0;
    let N2 = 0;
    let First = 0;
    if (data[0].x < start) {
      N1 = 0;
      N2 = count - 1;
      while (N2 - N1 > 1) {
        let N = N1 + N2 >> 1;
        if (data[N].x > start)
          N2 = N;
        else
          N1 = N;
      }
      First = N1 - 1;
      if (First < 0)
        First = 0;
    }
    let Last = count - 1;
    if (data[Last] === void 0) {
      debugger;
    }
    if (data[Last].x > end) {
      N1 = 0;
      N2 = count - 1;
      while (N2 - N1 > 1) {
        let N = N1 + N2 >> 1;
        if (data[N].x < end)
          N1 = N;
        else
          N2 = N;
      }
      Last = N2 + 1;
      if (Last > count - 1)
        Last = count - 1;
    }
    res.Min = data[First].y;
    res.Max = data[First].y;
    for (let i = First + 1; i <= Last; i++) {
      if (data[i].y < res.Min)
        res.Min = data[i].y;
      if (data[i].y > res.Max)
        res.Max = data[i].y;
    }
    return res;
  }
  resetlegendPens() {
    for (let i = 0; i < this._series.length; i++) {
      this._series[i].resetlegendPen();
    }
  }
  drawLegendPanel(g, viewPortWidth, viewPortHeight, mainViewPort) {
    let verticalRatio = 1.25;
    if (!this._legendPanel.enabled)
      return;
    let legendWidths = new Array(this._series.length);
    let legendHeight = new Array(this._series.length);
    let ofsetx = new Array(this._series.length);
    let ofsety = new Array(this._series.length);
    let legends = new Array(this._series.length);
    let totalHeight = 0;
    let totalWidth = 0;
    let maxWidth = 0;
    let maxHeight = 0;
    g.TextRenderingHint = YTextRenderingHint.SingleBitPerPixelGridFit;
    g.SetClip(new YRectangle(0, 0, viewPortWidth, viewPortHeight));
    for (let i = 0; i < this._series.length; i++) {
      if (this._series[i].legend != "")
        legends[i] = this._series[i].legend;
      else
        legends[i] = "Series " + (i + 1).toString();
    }
    if (this._legendPanel.position == LegendPanel.Position.TOP || this._legendPanel.position == LegendPanel.Position.BOTTOM) {
      let availableWidth = viewPortWidth - 2 * this._legendPanel.padding + this._legendPanel.borderthickness;
      if (this._legendPanel.overlap)
        availableWidth = availableWidth - mainViewPort.Lmargin - mainViewPort.Rmargin;
      totalHeight = 0;
      let xx = 0;
      let yy = 0;
      for (let i = 0; i < this._series.length; i++) {
        if (this._series[i].segments.length > 0 && this._series[i].visible && !this._series[i].disabled) {
          let ssize = g.MeasureString(legends[i], this._legendPanel.font, 1e5);
          legendHeight[i] = ssize.height + 1;
          let ww = ssize.width + 20;
          if (xx == 0)
            totalHeight += ssize.height;
          if (availableWidth - xx < ww) {
            if (xx == 0) {
              ofsetx[i] = xx;
              ofsety[i] = yy;
              yy += ssize.height;
              if (maxWidth < ww)
                maxWidth = ww;
            } else {
              yy += ssize.height;
              ofsetx[i] = 0;
              ofsety[i] = yy;
              xx = ww;
              totalHeight += ssize.height;
              if (maxWidth < xx)
                maxWidth = xx;
            }
          } else {
            ofsetx[i] = xx;
            ofsety[i] = yy;
            xx += ww;
            if (maxWidth < xx)
              maxWidth = xx;
          }
        }
      }
      if (totalWidth > availableWidth) {
        totalWidth = availableWidth;
      }
    } else {
      let ty = 0;
      for (let i = 0; i < this._series.length; i++) {
        if (this._series[i].segments.length > 0 && this._series[i].visible && !this._series[i].disabled) {
          let ssize = g.MeasureString(legends[i], this._legendPanel.font, 1e5);
          legendWidths[i] = ssize.width + 1;
          if (maxWidth < legendWidths[i] + 20)
            maxWidth = legendWidths[i] + 20;
          legendHeight[i] = ssize.height + 1;
          if (maxHeight < legendHeight[i])
            maxHeight = legendHeight[i];
          ofsetx[i] = 0;
          ofsety[i] = ty;
          ty += ssize.height * verticalRatio;
          totalHeight += i == 0 ? ssize.height : ssize.height * verticalRatio;
        }
      }
    }
    let w = maxWidth + 2 * this._legendPanel.padding + this._legendPanel.borderthickness;
    let h = totalHeight + 2 * this._legendPanel.padding + this._legendPanel.borderthickness;
    let x = 0;
    let y = 0;
    switch (this._legendPanel.position) {
      case LegendPanel.Position.LEFT:
        x = this._legendPanel.horizontalMargin;
        if (!this._legendPanel.overlap) {
          mainViewPort.Lmargin += w + 2 * this.legendPanel.horizontalMargin + this.legendPanel.borderthickness >> 0;
          y = (viewPortHeight - h) / 2;
        } else {
          x += mainViewPort.Lmargin;
          y = mainViewPort.Tmargin + (viewPortHeight - mainViewPort.Tmargin - mainViewPort.Bmargin - h) / 2;
        }
        break;
      case LegendPanel.Position.TOPLEFT:
        x = this._legendPanel.horizontalMargin;
        y = this._legendPanel.verticalMargin;
        if (!this._legendPanel.overlap) {
          mainViewPort.Lmargin += w + 2 * this.legendPanel.horizontalMargin + this.legendPanel.borderthickness >> 0;
        } else {
          x += mainViewPort.Lmargin;
          y += mainViewPort.Tmargin;
        }
        break;
      case LegendPanel.Position.TOP:
        if (!this._legendPanel.overlap) {
          x = (viewPortWidth - w) / 2 - this._legendPanel.horizontalMargin - this._legendPanel.borderthickness;
          y = this._legendPanel.verticalMargin + this._legendPanel.borderthickness;
          mainViewPort.Tmargin += totalHeight + this._legendPanel.verticalMargin + 2 * this._legendPanel.verticalMargin + this._legendPanel.borderthickness >> 0;
        } else {
          x = mainViewPort.Lmargin + (viewPortWidth - mainViewPort.Lmargin - mainViewPort.Rmargin - w) / 2 - this._legendPanel.horizontalMargin - this._legendPanel.borderthickness;
          y = mainViewPort.Tmargin + this._legendPanel.verticalMargin - this._legendPanel.borderthickness;
        }
        break;
      case LegendPanel.Position.TOPRIGHT:
        x = viewPortWidth - this._legendPanel.horizontalMargin - w;
        y = this._legendPanel.verticalMargin;
        if (!this._legendPanel.overlap) {
          mainViewPort.Rmargin += w + 2 * this._legendPanel.horizontalMargin + this._legendPanel.borderthickness >> 0;
        } else {
          x -= mainViewPort.Rmargin;
          y += mainViewPort.Tmargin;
        }
        break;
      case LegendPanel.Position.RIGHT:
        x = viewPortWidth - this._legendPanel.horizontalMargin - w;
        if (!this._legendPanel.overlap) {
          mainViewPort.Rmargin += w + 2 * this._legendPanel.horizontalMargin + this._legendPanel.borderthickness >> 0;
          y = (viewPortHeight - h) / 2;
        } else {
          x -= mainViewPort.Rmargin;
          y = mainViewPort.Tmargin + (viewPortHeight - mainViewPort.Tmargin - mainViewPort.Bmargin - h) / 2;
        }
        break;
      case LegendPanel.Position.BOTTOMRIGHT:
        x = viewPortWidth - this._legendPanel.horizontalMargin - w;
        if (!this._legendPanel.overlap) {
          mainViewPort.Rmargin += w + 2 * this._legendPanel.horizontalMargin + this._legendPanel.borderthickness >> 0;
          y = viewPortHeight - this._legendPanel.verticalMargin - h;
        } else {
          x -= mainViewPort.Rmargin;
          y = viewPortHeight - mainViewPort.Bmargin - h - this._legendPanel.verticalMargin;
        }
        break;
      case LegendPanel.Position.BOTTOM:
        if (!this._legendPanel.overlap) {
          x = (viewPortWidth - w) / 2 - this._legendPanel.horizontalMargin - this._legendPanel.borderthickness;
          y = viewPortHeight - this._legendPanel.verticalMargin - 2 * this._legendPanel.padding - this._legendPanel.borderthickness - totalHeight;
          mainViewPort.Bmargin += totalHeight + 2 * this._legendPanel.padding + 2 * this._legendPanel.verticalMargin + this._legendPanel.borderthickness;
        } else {
          x = mainViewPort.Lmargin + (viewPortWidth - mainViewPort.Lmargin - mainViewPort.Rmargin - w) / 2 - this._legendPanel.horizontalMargin - this._legendPanel.borderthickness;
          y = viewPortHeight - mainViewPort.Bmargin - totalHeight - 2 * this._legendPanel.padding - 2 * this._legendPanel.verticalMargin - this._legendPanel.borderthickness;
        }
        break;
      case LegendPanel.Position.BOTTOMLEFT:
        x = this._legendPanel.horizontalMargin;
        y = this._legendPanel.verticalMargin;
        if (!this._legendPanel.overlap) {
          mainViewPort.Lmargin += w + 2 * this._legendPanel.horizontalMargin + this._legendPanel.borderthickness;
          y = viewPortHeight - this._legendPanel.verticalMargin - h;
        } else {
          x += mainViewPort.Lmargin;
          y = viewPortHeight - mainViewPort.Bmargin - h - this._legendPanel.verticalMargin;
        }
        break;
    }
    let rect = new YRectangle(x >> 0, y >> 0, w >> 0, h >> 0);
    g.FillRectangle(this._legendPanel.bgBrush, rect);
    g.DrawRectangle(this._legendPanel.pen, rect);
    g.TextRenderingHint = YTextRenderingHint.AntiAlias;
    for (let i = 0; i < this._series.length; i++) {
      if (this._series[i].segments.length > 0 && this._series[i].visible && !this._series[i].disabled) {
        g.DrawStringXY(legends[i], this._legendPanel.font, this._legendPanel.font.brush, x + ofsetx[i] + 20 + this._legendPanel.padding >> 0, y + ofsety[i] + this._legendPanel.padding >> 0);
        let px = x + ofsetx[i] + this._legendPanel.borderthickness / 2 + this._legendPanel.padding + 6 >> 0;
        let py = y + ofsety[i] + this._legendPanel.padding + legendHeight[i] / 2 >> 0;
        g.DrawLine(this._series[i].legendPen, new PointF(px, py), new PointF(px + 12, py));
      }
    }
  }
  static DoSegmentRendering(w, g, p, data, count, xTimeStart, xTimeEnd) {
    if (data[0].x > xTimeEnd || data[count - 1].x < xTimeStart)
      return 0;
    let isSVG = g instanceof YGraphicsSVG;
    let N1 = 0;
    let N2 = 0;
    let First = 0;
    if (data[0].x < xTimeStart) {
      N1 = 0;
      N2 = count - 1;
      while (N2 - N1 > 1) {
        let N = N1 + N2 >> 1;
        if (data[N].x > xTimeStart)
          N2 = N;
        else
          N1 = N;
      }
      First = N1 - 1;
      if (First < 0)
        First = 0;
    }
    let Last = count - 1;
    if (data[Last].x > xTimeEnd) {
      N1 = 0;
      N2 = count - 1;
      while (N2 - N1 > 1) {
        let N = N1 + N2 >> 1;
        if (data[N].x < xTimeEnd)
          N1 = N;
        else
          N2 = N;
      }
      Last = N2 + 1;
      if (Last > count - 1)
        Last = count - 1;
    }
    if (Last - First > 2 * w.Width - w.Lmargin - w.Rmargin) {
      let ToDraw = new Array(3 * (Last - First + 1));
      let Current = _YGraph.IRLPointToViewPort(w, data[First]);
      let New;
      let i = First + 1;
      let n = 0;
      let max;
      let min;
      let limit;
      while (i < Last) {
        ToDraw[n++] = new PointF(Current.X, Current.Y);
        min = data[i].y;
        max = min;
        limit = _YGraph.ViewPortPointToIRL(w, new Point(Current.X + 1, Current.Y + 1)).x;
        do {
          if (data[i].y > max)
            max = data[i].y;
          if (data[i].y < min)
            min = data[i].y;
          i++;
        } while (i < Last && data[i].x < limit);
        let p1 = _YGraph.IRLPointToViewPort(w, new pointXY(data[i].x, min));
        let p2 = _YGraph.IRLPointToViewPort(w, new pointXY(data[i].x, max));
        if (Math.abs(p1.Y - p2.Y) > 2) {
          ToDraw[n++] = new PointF(p1.X, p1.Y);
          ToDraw[n++] = new PointF(p2.X, p2.Y);
        }
        Current = _YGraph.IRLPointToViewPort(w, data[i]);
      }
      ToDraw[n++] = Current;
      ToDraw = ToDraw.slice(0, n);
      if (n > 1)
        g.DrawLines(p, ToDraw);
      return n;
    } else {
      if (isSVG) {
        let ToDraw = new Array(Last - First + 1);
        for (let i = First; i <= Last; i++) {
          ToDraw[i - First] = _YGraph.IRLPointToViewPort(w, data[i]);
        }
        g.DrawLines(p, ToDraw);
      } else {
        for (let i = First; i < Last; i++) {
          g.DrawLine(p, _YGraph.IRLPointToViewPort(w, data[i]), _YGraph.IRLPointToViewPort(w, data[i + 1]));
        }
      }
    }
    return Last - First;
  }
  static DoSummarySegmentRendering(w, g, p, data, count, finalPoint, xTimeStart, xTimeEnd) {
    let ToDraw = new Array(2 * count + 1);
    let n = 0;
    if (count > 0) {
      if (data[0].x1 > xTimeEnd || data[count - 1].x2 < xTimeStart)
        return 0;
      let isSVG = g instanceof YGraphicsSVG;
      let N1 = 0;
      let N2 = 0;
      let First = 0;
      if (data[0].x1 < xTimeStart) {
        N1 = 0;
        N2 = count - 1;
        while (N2 - N1 > 1) {
          let N = N1 + N2 >> 1;
          if (data[N].x1 > xTimeStart)
            N2 = N;
          else
            N1 = N;
        }
        First = N1 - 1;
        if (First < 0)
          First = 0;
      }
      let Last = count - 1;
      if (data[Last].x2 > xTimeEnd) {
        N1 = 0;
        N2 = count - 1;
        while (N2 - N1 > 1) {
          let N = N1 + N2 >> 1;
          if (data[N].x2 < xTimeEnd)
            N1 = N;
          else
            N2 = N;
        }
        Last = N2 + 1;
        if (Last > count - 1)
          Last = count - 1;
      }
      let Current;
      let New;
      let i = First;
      let max;
      let min;
      let limit;
      Current = _YGraph.IRLPointSummaryToViewPort(w, data[i]);
      ToDraw[n++] = new PointF(Current.X1, Current.YMIN);
      let ymin = Current.YMAX;
      let ymax = Current.YMIN;
      let x = Current.X1;
      let buffered = 0;
      while (i <= Last) {
        Current = _YGraph.IRLPointSummaryToViewPort(w, data[i]);
        if (ymin > Current.YMAX)
          ymin = Current.YMAX;
        if (ymax < Current.YMIN)
          ymax = Current.YMIN;
        buffered++;
        if (Current.X2 > x) {
          ToDraw[n++] = new PointF(x, ymin);
          if (ymax - ymin > 2)
            ToDraw[n++] = new PointF(x + Current.X2 >> 1, ymax);
          x = Current.X2;
          ymin = Current.YMAX;
          ymax = Current.YMIN;
          buffered = 0;
        }
        i++;
      }
      if (buffered > 0) {
        ToDraw[n++] = new PointF(x, Current.YMIN);
        ToDraw[n++] = new PointF(x + Current.X2 >> 1, Current.YMAX);
      }
    }
    if (finalPoint) {
      let Current = _YGraph.IRLPointSummaryToViewPort(w, finalPoint);
      ToDraw[n++] = new PointF(Current.X1, Current.YMIN);
      ToDraw[n++] = new PointF(Current.X2, Current.YMAX);
    }
    if (n > 1) {
      ToDraw = ToDraw.slice(0, n);
      g.DrawLines(p, ToDraw);
    }
    return n;
  }
  DrawYAxisZones(w, g, scale) {
    if (!scale.visible)
      return;
    let Delta = scale.startStopStep.dataMax - scale.startStopStep.dataMin;
    let YZoom = Delta / (w.Height - w.Bmargin - w.Tmargin);
    for (let i = 0; i < scale.zones.length; i++) {
      if (scale.zones[i].visible) {
        let max = scale.zones[i].max;
        let min = scale.zones[i].min;
        if (Number.isNaN(max)) {
          max = scale.startStopStep.dataMax;
        }
        if (Number.isNaN(min))
          min = scale.startStopStep.dataMin;
        if (max < min) {
          let t = max;
          max = min;
          min = t;
        }
        let y0 = w.Height - w.Bmargin - Math.round((max - scale.startStopStep.dataMin) / YZoom) >> 0;
        let h = Math.round((max - min) / YZoom) >> 0;
        g.FillRectangleXYHW(scale.zones[i].zoneBrush, this.mainViewPort.Lmargin, y0, this.mainViewPort.Width - this.mainViewPort.Rmargin - this.mainViewPort.Lmargin + 1, h);
      }
    }
  }
  DrawXAxisZones(w, g, scale) {
    if (!scale.visible)
      return;
    let delta = scale.max - scale.min;
    let XZoom = delta / (w.Width - w.Lmargin - w.Rmargin);
    for (let i = 0; i < scale.zones.length; i++) {
      if (scale.zones[i].visible) {
        let max = scale.zones[i].max;
        let min = scale.zones[i].min;
        if (Number.isNaN(max))
          max = scale.min;
        if (Number.isNaN(min))
          min = scale.max;
        if (max < min) {
          let t = max;
          max = min;
          min = t;
        }
        let x0 = w.Lmargin + Math.round((min - scale.min) / XZoom) >> 0;
        g.FillRectangleXYHW(scale.zones[i].zoneBrush, x0, this.mainViewPort.Tmargin, (max - min) / XZoom >> 0, this.mainViewPort.Height - this.mainViewPort.Tmargin - this.mainViewPort.Bmargin);
      }
    }
  }
  // noinspection JSSuspiciousNameCombination
  static DrawYAxis(w, g, axis, ofset, simulation) {
    if (!axis.visible) {
      axis.innerWidth = 0;
      return axis.innerWidth;
    }
    let Delta = axis.startStopStep.dataMax - axis.startStopStep.dataMin;
    let YZoom = Delta / (w.Height - w.Bmargin - w.Tmargin);
    let leftSide = axis.position == YAxis.HrzPosition.LEFT;
    let x = leftSide ? w.Lmargin - ofset : w.Width - w.Rmargin + ofset;
    if (!simulation)
      g.DrawLineXY(axis.pen, x, w.Tmargin, x, w.Height - w.Bmargin);
    let format = new YStringFormat(
      16384
      /* YDataRendering.YStringFormat.StringFormatFlags.NoClip */
    );
    format.LineAlignment = 1;
    format.Alignment = leftSide ? 2 : 0;
    let FirstStep = axis.startStopStep.step * Math.floor(axis.startStopStep.start / axis.startStopStep.step);
    if (FirstStep < 0) {
      FirstStep -= axis.startStopStep.step;
    }
    let stepCount = ((Delta - (FirstStep - axis.startStopStep.dataMin)) / axis.startStopStep.step >> 0) + 1;
    if (!simulation)
      g.TextRenderingHint = YTextRenderingHint.AntiAlias;
    let UnitWidth = 0;
    let labelPrecision = 0;
    if (axis.startStopStep.precision < 0)
      labelPrecision = -axis.startStopStep.precision;
    if (stepCount < w.Height) {
      for (let i = 0; i < stepCount; i++) {
        let y = Math.round((FirstStep + i * axis.startStopStep.step - axis.startStopStep.dataMin) / YZoom) >> 0;
        if (y >= 0) {
          y = w.Height - w.Bmargin - y;
          let v = FirstStep + i * axis.startStopStep.step;
          if (!simulation) {
            if (axis.showGrid && (i > 0 || axis.startStopStep.dataMin != 0))
              g.DrawLineXY(axis.gridPen, w.Lmargin, y, w.Width - w.Rmargin, y);
            if (Math.abs(v) < 1e-6 && axis.highlightZero) {
              g.DrawLineXY(axis.pen, w.Lmargin, y, w.Width - w.Rmargin, y);
            }
            g.DrawLineXY(axis.pen, x + (leftSide ? -2 : 2), y, x + (leftSide ? 5 : -5), y);
          }
          let label = v.toFixed(labelPrecision);
          let ssize = g.MeasureString(label, axis.font, 1e5);
          if (ssize.width > UnitWidth)
            UnitWidth = ssize.width;
          if (!simulation) {
            let p = new Point(x + (leftSide ? -3 : 3), y);
            g.DrawStringPF(label, axis.font, axis.font.brush, p, format);
          }
        }
      }
    }
    if (axis.legend.title != "") {
      let size = g.MeasureString(axis.legend.title, axis.legend.font, 1e5);
      if (!simulation) {
        let format2 = new YStringFormat(
          16384
          /* YDataRendering.YStringFormat.StringFormatFlags.NoClip */
        );
        format2.Alignment = 1;
        format2.LineAlignment = 1;
        format2.Trimming = 0;
        let legendX = x + (leftSide ? -UnitWidth - size.height : UnitWidth + size.height + 2) >> 0;
        let legendY = w.Tmargin + (w.Height - w.Tmargin - w.Bmargin) / 2 >> 0;
        g.Transform(legendX, legendY, leftSide ? -Math.PI / 2 : Math.PI / 2);
        g.DrawStringPF(axis.legend.title, axis.legend.font, axis.legend.font.brush, new Point(0, 0), format2);
        g.ResetTransform();
      }
      UnitWidth += size.height;
    }
    axis.innerWidth = (UnitWidth >> 0) + 10;
    return axis.innerWidth;
  }
  DrawMonitorXAxis(w, g, xRange, format) {
    let delta = xRange.Max - xRange.Min;
    let scale = TimeConverter.BestTimeformat(delta, delta, this.xAxis.timeReference);
    let XZoom = delta / (w.Width - w.Lmargin - w.Rmargin);
    let stepCount = (delta / scale.step >> 0) + 2;
    let FirstStep = scale.step * Math.floor(xRange.Min / scale.step);
    if (FirstStep < xRange.Min)
      FirstStep += scale.step;
    g.TextRenderingHint = YTextRenderingHint.AntiAlias;
    let y = w.Height - w.Bmargin;
    g.DrawLineXY(this._navigator.pen, w.Lmargin, w.Height - w.Bmargin - 1, w.Width - w.Rmargin, w.Height - w.Bmargin - 1);
    let label;
    let t = FirstStep;
    do {
      let d = TimeConverter.FromUnixTime(t);
      if (scale.step > 31.1 * 86400) {
        t = TimeConverter.ToUnixTime(new Date(d.getFullYear(), d.getMonth(), 1));
      }
      if (t >= xRange.Min) {
        let x = w.Lmargin + Math.round((t - xRange.Min) / XZoom);
        g.DrawLineXY(this._navigator.pen, x, y, x, y - 4);
        if (format == XAxis.FORMATAUTO) {
          label = TimeConverter.FromUnixTime(t).ToString(scale.format);
        } else {
          label = TimeConverter.FromUnixTime(t).ToString(format);
        }
        let ssize = g.MeasureString(label, this._navigator.font, 1e5);
        g.DrawString(label, this._navigator.font, this._navigator.font.brush, new Point(x - ssize.width / 2, y - ssize.height - 1));
      }
      t += scale.step;
    } while (t < xRange.Max);
  }
  static XLabel(t, scale, scaleFormat, timeRange) {
    let label;
    if (scale.timeReference == TimeConverter.TimeReference.ABSOLUTE) {
      if (scale.labelFormat == XAxis.FORMATAUTO) {
        label = TimeConverter.FromUnixTime(t).ToString(scaleFormat.format);
      } else {
        label = t.toString();
      }
    } else {
      let ticks = YTimeSpan.TicksPerSecond * (Math.round(1e3 * (t - scale.zeroTime)) / 1e3);
      label = ticks < 0 ? "-" + new YTimeSpan(-ticks).toString(scaleFormat.format) : new YTimeSpan(ticks).toString(scaleFormat.format);
    }
    return label;
  }
  DrawXAxis(w, g, scale, simulation) {
    if (w.Width - w.Rmargin - w.Lmargin < 10)
      return 1;
    let stringFormat = new YStringFormat(
      16384
      /* YDataRendering.YStringFormat.StringFormatFlags.NoClip */
    );
    stringFormat.Alignment = 1;
    let bottomSide = scale.position == XAxis.VrtPosition.BOTTOM;
    let y = bottomSide ? w.Height - w.Bmargin : w.Tmargin;
    if (!simulation)
      g.DrawLineXY(scale.pen, w.Lmargin, y, w.Width - w.Rmargin, y);
    let delta = scale.max - scale.min;
    let XZoom = delta / (w.Width - w.Lmargin - w.Rmargin);
    let stepCount = (delta / scale.step >> 0) + 1;
    let FirstStep = 0;
    let timeRange = MinMaxHandler.DefaultValue();
    for (let i = 0; i < this._series.length; i++) {
      if (!this._series[i].disabled) {
        timeRange = MinMaxHandler.Combine(timeRange, this._series[i].timeRange);
      }
    }
    scale.zeroTime = timeRange.Min;
    if (scale.timeReference == TimeConverter.TimeReference.ABSOLUTE) {
      FirstStep = scale.step * Math.floor(scale.min / scale.step);
      timeRange.Min = scale.min;
      timeRange.Max = scale.max;
    } else {
      if (Number.isNaN(timeRange.Min))
        return 0;
      FirstStep = timeRange.Min + scale.step * Math.floor((scale.min - scale.zeroTime) / scale.step);
    }
    if (FirstStep < scale.min)
      FirstStep += scale.step;
    let timeOffset = 0;
    if (scale.timeReference != TimeConverter.TimeReference.ABSOLUTE) {
      timeOffset = FirstStep;
    }
    scale.fullSize = timeRange.Max - timeRange.Min;
    let scaleFormat = scale.bestFormat(timeRange.Max - timeRange.Min, scale.max - scale.min);
    if (!simulation)
      g.TextRenderingHint = YTextRenderingHint.AntiAlias;
    let UnitHeight = 0;
    let label;
    scale.step = scaleFormat.step;
    let t = parseFloat(FirstStep.toString());
    label = _YGraph.XLabel(t, scale, scaleFormat, timeRange);
    let ssize = g.MeasureString(label, scale.font, 1e5);
    let mod = 1;
    while (mod * (w.Width - w.Rmargin - w.Lmargin) / stepCount < ssize.width) {
      mod++;
    }
    let steps = Math.round((t - timeOffset) / scale.step) >> 0;
    let previousT = 0;
    do {
      let d = TimeConverter.FromUnixTime(t);
      if (scale.step > 32 * 86400 && scale.timeReference == TimeConverter.TimeReference.ABSOLUTE) {
        if (scale.step >= 365 * 86400) {
          let m = d.getMonth();
          t = TimeConverter.ToUnixTime(new Date(d.getFullYear() + (m > 5 ? 1 : 0), 0, 1));
        } else
          t = TimeConverter.ToUnixTime(new Date(d.getFullYear(), d.getMonth(), 1));
        if (t < previousT) {
          debugger;
        }
      }
      if (t >= scale.min) {
        let x = w.Lmargin + Math.round((t - scale.min) / XZoom) >> 0;
        if (x <= w.Width - w.Rmargin) {
          if (!simulation) {
            if (scale.showGrid)
              g.DrawLineXY(scale.gridPen, x, w.Tmargin, x, w.Height - w.Bmargin);
            g.DrawLineXY(scale.pen, x, y + (bottomSide ? 2 : -2), x, y + (bottomSide ? -5 : 5));
          }
          label = _YGraph.XLabel(t, scale, scaleFormat, timeRange);
          ssize = g.MeasureString(label, scale.font, 1e5);
          if (ssize.height > UnitHeight)
            UnitHeight = ssize.height;
          if (!simulation) {
            if (steps % mod == 0) {
              g.DrawStringPF(label, scale.font, scale.font.brush, new PointF(x, y + (bottomSide ? 5 : -ssize.height >> 0) - 2), stringFormat);
            }
          }
        }
      }
      previousT = t;
      t += scale.step;
      if (t < previousT)
        debugger;
      steps++;
    } while (t <= scale.max);
    if (scale.legend.title != "") {
      let size = g.MeasureString(scale.legend.title, scale.legend.font, 1e5);
      if (!simulation) {
        let legendX = w.Lmargin + (w.Width - w.Lmargin - w.Rmargin - size.width) / 2 >> 0;
        let legendY = bottomSide ? w.Height - w.Bmargin + UnitHeight + 5 : w.Tmargin - UnitHeight - size.height * 1.5;
        g.DrawString(scale.legend.title, scale.legend.font, scale.legend.font.brush, new PointF(legendX, legendY));
      }
      UnitHeight += size.height >> 0;
    }
    scale.innerHeight = (UnitHeight >> 0) + 10;
    return scale.innerHeight;
  }
  pixelxSize(mainViewPort, scaleX) {
    let dtime = scaleX.max - scaleX.min;
    let dview = mainViewPort.Width - mainViewPort.Lmargin - mainViewPort.Rmargin;
    if (dview > 0)
      return dtime / dview;
    return 0;
  }
  TimeToAutoSting(t, mainViewPort, scaleX) {
    let strValue = "";
    let dtime = scaleX.max - scaleX.min;
    let months = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
    if (dtime > 0) {
      let pixelSize = this.pixelxSize(mainViewPort, scaleX);
      if (pixelSize > 0) {
        if (scaleX.timeReference == TimeConverter.TimeReference.ABSOLUTE) {
          let date = TimeConverter.FromUnixTime(t);
          let MMMM = months[date.getMonth()];
          let dd = date.getDate().toString();
          let HH = date.getHours().toString();
          if (HH.length < 2)
            HH = "0" + HH;
          let mm = date.getMinutes().toString();
          if (mm.length < 2)
            mm = "0" + mm;
          let ss = date.getSeconds().toString();
          if (ss.length < 2)
            ss = "0" + ss;
          let ff = Math.round(date.getMilliseconds() / 10).toString();
          if (ff.length < 2)
            ff = "0" + ss;
          let f = Math.round(date.getMilliseconds() / 100).toString();
          if (dtime >= 86400)
            strValue += MMMM + " " + dd;
          if (pixelSize < 0.1) {
            strValue += (strValue != "" ? " " : "") + HH + ":" + mm + ":" + ss + "." + ff;
          } else if (pixelSize < 1) {
            strValue += (strValue != "" ? " " : "") + HH + ":" + mm + ":" + ss + "." + f;
          } else if (pixelSize < 60) {
            strValue += (strValue != "" ? " " : "") + HH + ":" + mm + ":" + ss;
          } else if (pixelSize < 3600) {
            strValue += (strValue != "" ? " " : "") + HH + ":" + mm;
          } else if (pixelSize < 86400)
            strValue += (strValue != "" ? " " : "") + HH + "H";
        } else {
          let format = TimeConverter.RelativeFormat(scaleX.fullSize, dtime, pixelSize);
          let ticks = YTimeSpan.TicksPerSecond * (Math.round(100 * (t - scaleX.zeroTime)) / 100);
          strValue += ticks < 0 ? "-" + new YTimeSpan(-ticks).toString(format) : new YTimeSpan(ticks).toString(format);
        }
      }
    }
    return strValue;
  }
  DrawDataTracker(g, viewPortWidth, viewPortHeight, scaleX) {
    if (!this._dataTracker.enabled) {
      return;
    }
    let p = this.mouseLocalPosition();
    if (p == null) {
      return;
    }
    if (p.X <= this.mainViewPort.Lmargin) {
      return;
    }
    if (p.Y <= this.mainViewPort.Tmargin) {
      return;
    }
    if (p.X >= this.UIContainer.width - this.mainViewPort.Rmargin) {
      return;
    }
    if (p.Y >= this.UIContainer.height - this.mainViewPort.Bmargin) {
      return;
    }
    g.SetClip(new YRectangle(0, 0, viewPortWidth, viewPortHeight));
    let DataPoint = _YGraph.ViewPortPointToIRL(this.mainViewPort, p);
    let delta = -1;
    let bestindex = -1;
    let bestmatch = new Array(this._series.length);
    let IRLmatch = new Array(this._series.length);
    for (let i = 0; i < this._series.length; i++) {
      if (this._series[i].visible && !this._series[i].disabled) {
        let p2 = this._series[i].findClosestValue(DataPoint.x, false);
        if (p2 != null) {
          IRLmatch[i] = p2;
          bestmatch[i] = _YGraph.IRLPointToViewPort(this.mainViewPort, IRLmatch[i], this.yAxes[this._series[i].yAxisIndex].IRLy, this.yAxes[this._series[i].yAxisIndex].zoom);
          if (bestindex < 0 || delta > Math.abs(bestmatch[i].Y - p.Y)) {
            delta = Math.abs(bestmatch[i].Y - p.Y);
            if (this._dataTracker.detectionDistance == 0 || delta <= this._dataTracker.detectionDistance && Math.abs(bestmatch[i].X - p.X) < this._dataTracker.detectionDistance) {
              bestindex = i;
            }
          }
        }
      }
    }
    if (bestindex >= 0) {
      let xx = bestmatch[bestindex].X - this._dataTracker.diameter / 2 >> 0;
      let yy = bestmatch[bestindex].Y - this._dataTracker.diameter / 2 >> 0;
      let dd = this._dataTracker.diameter;
      g.FillEllipse(this._series[bestindex].brush, xx, yy, dd, dd);
      g.DrawEllipse(this._dataTracker.pen, xx, yy, dd, dd);
      let dx;
      let dy;
      if (p.X > this.mainViewPort.Lmargin + (viewPortWidth - this.mainViewPort.Lmargin - this.mainViewPort.Rmargin) / 2)
        dx = -1;
      else
        dx = 1;
      if (p.Y > this.mainViewPort.Tmargin + (viewPortHeight - this.mainViewPort.Tmargin - this.mainViewPort.Bmargin) / 2)
        dy = -1;
      else
        dy = 1;
      let xx2 = bestmatch[bestindex].X + dx * (this._dataTracker.handleLength * 1.5) >> 0;
      let yy2 = bestmatch[bestindex].Y + dy * this._dataTracker.handleLength >> 0;
      g.DrawLineXY(this._dataTracker.pen, bestmatch[bestindex].X + dx * 0.707 * this._dataTracker.diameter / 2 >> 0, bestmatch[bestindex].Y + dy * 0.707 * this._dataTracker.diameter / 2 >> 0, bestmatch[bestindex].X + dx * this._dataTracker.handleLength >> 0, bestmatch[bestindex].Y + dy * this._dataTracker.handleLength >> 0);
      g.DrawLineXY(this._dataTracker.pen, bestmatch[bestindex].X + dx * this._dataTracker.handleLength >> 0, bestmatch[bestindex].Y + dy * this._dataTracker.handleLength >> 0, xx2, yy2);
      let strValue = "";
      if (this._dataTracker.showSerieName)
        strValue += this._series[bestindex].legend + "\r\n";
      if (this._dataTracker.showTimeStamp) {
        let t = IRLmatch[bestindex].x;
        strValue += this.TimeToAutoSting(t, this.mainViewPort, scaleX) + "\r\n";
      }
      if (this._dataTracker.dataPrecision.toString == DataTracker.DataPrecision.PRECISION_NOLIMIT.toString) {
        strValue += IRLmatch[bestindex].y.toString() + this._series[bestindex].unit;
      } else {
        let strvalue = this._dataTracker.dataPrecision.description;
        let precision = -Math.log10(Number(strvalue));
        strValue += IRLmatch[bestindex].y.toFixed(precision) + this._series[bestindex].unit;
      }
      let ssize = g.MeasureString(strValue, this._dataTracker.font, 1e4);
      let labelwidth = ssize.width + 2 * this._dataTracker.padding + this._dataTracker.borderthickness;
      let labelHeight = ssize.height + 2 * this._dataTracker.padding + this._dataTracker.borderthickness;
      if (dx > 0) {
        g.FillRectangleXYHW(this._dataTracker.bgBrush, xx2, yy2 - (labelHeight >> 1), labelwidth, labelHeight);
        g.DrawRectangleXYHW(this._dataTracker.pen, xx2, yy2 - (labelHeight >> 1), labelwidth, labelHeight);
        g.DrawStringXY(strValue, this._dataTracker.font, this._dataTracker.font.brush, xx2 + this._dataTracker.padding >> 0, yy2 - (labelHeight >> 1) + this._dataTracker.padding >> 0);
      } else {
        g.FillRectangleXYHW(this._dataTracker.bgBrush, xx2 - labelwidth, yy2 - (labelHeight >> 1), labelwidth, labelHeight);
        g.DrawRectangleXYHW(this._dataTracker.pen, xx2 - labelwidth, yy2 - (labelHeight >> 1), labelwidth, labelHeight);
        g.DrawStringXY(strValue, this._dataTracker.font, this.dataTracker.font.brush, xx2 + this._dataTracker.padding - labelwidth >> 0, yy2 - (labelHeight >> 1) + this._dataTracker.padding >> 0);
      }
    }
  }
  /*
       *  XAxis scale)
      {
          if (!scale.visible) return;
          double delta = scale.max - scale.min;
          Double XZoom = (delta) / (w.Width - w.Lmargin - w.Rmargin);
  
          for (int i = 0; i < scale.zones.Count; i++)
              if (scale.zones[i].visible)
              {
                  double max = scale.zones[i].max;
                  double min = scale.zones[i].min;
                  if (double.IsNaN(max)) max = scale.min;
                  if (double.IsNaN(min)) min = scale.max;
                  if (max < min) { double t = max; max = min; min = t; }
                  int x0 =  w.Lmargin + (int)Math.Round((min - scale.min) / XZoom);
       *
       * */
  DrawMarkers(w, g, scaleX, viewPortWidth, viewPortHeight) {
    if (this._xAxis.markers.length == 0)
      return;
    g.SetClip(new YRectangle(w.Lmargin, w.Tmargin, w.Width - w.Rmargin - w.Lmargin, w.Height - w.Bmargin - w.Tmargin));
    let Bottomleft = _YGraph.ViewPortPointToIRL(w, new Point(w.Lmargin, w.Height - w.Bmargin));
    let TopRight = _YGraph.ViewPortPointToIRL(w, new Point(w.Width - w.Rmargin, w.Tmargin));
    let dy = (w.Height - w.Bmargin - w.Tmargin) / 100;
    let pixelSize = -1;
    g.TextRenderingHint = YTextRenderingHint.AntiAlias;
    for (let i = 0; i < this._xAxis.markers.length; i++) {
      if (this._xAxis.markers[i].enabled) {
        if (pixelSize < 0)
          pixelSize = this.pixelxSize(this.mainViewPort, scaleX);
        let mustdraw = true;
        let xpos = 0;
        if (this._xAxis.markers[i].timereference == TimeConverter.TimeReference.RELATIVE) {
          if (this._xAxis.zeroTime > 0) {
            xpos = this._xAxis.markers[i].xposition + this._xAxis.zeroTime;
          } else {
            mustdraw = false;
          }
        } else {
          xpos = this._xAxis.markers[i].xposition;
        }
        if (xpos > Bottomleft.x - 100 * pixelSize && xpos < TopRight.x + 100 * pixelSize && mustdraw) {
          let p = _YGraph.IRLPointToViewPort(w, new pointXY(xpos, 0));
          let xxCenter = p.X >> 0;
          let yyCenter = w.Height - w.Bmargin - this._xAxis.markers[i].yposition * dy >> 0;
          let strValue = this._xAxis.markers[i].text.replace("\\n", "\n");
          let now = /* @__PURE__ */ new Date();
          if (strValue.indexOf("$") >= 0) {
            if (strValue.indexOf("$MARKERTIME$") >= 0) {
              let s = this._xAxis.markers[i].timereference == TimeConverter.TimeReference.RELATIVE ? TimeConverter.secTimeSpanToString(this._xAxis.markers[i].xposition, pixelSize) : this.TimeToAutoSting(this._xAxis.markers[i].xposition, this.mainViewPort, scaleX);
              strValue = strValue.replace("$MARKERTIME$", s);
            }
            if (strValue.indexOf("$VALUE") >= 0) {
              for (let j = 0; j < this._series.length; j++) {
                if (!this._series[j].disabled) {
                  let pt = this._series[j].findClosestValue(xpos, true);
                  let st = pt != null ? pt.y.toFixed(0) : "--";
                  strValue = strValue.replace("$VALUE" + (j + 1).toString() + "$", st);
                } else {
                  strValue = strValue.replace("$VALUE" + (j + 1).toString() + "$", "");
                }
              }
            }
            if (strValue.indexOf("$UNIT") >= 0) {
              for (let j = 0; j < this._series.length; j++) {
                if (!this._series[j].disabled) {
                  strValue = strValue.replace("$UNIT" + (j + 1).toString() + "$", this._series[j].unit);
                } else {
                  strValue = strValue.replace("$UNIT" + (j + 1).toString() + "$", "");
                }
              }
            }
            if (strValue.indexOf("$LEGEND") >= 0) {
              for (let j = 0; j < this._series.length; j++) {
                if (!this._series[j].disabled) {
                  strValue = strValue.replace("$LEGEND" + (j + 1).toString() + "$", this._series[j].legend);
                } else {
                  strValue = strValue.replace("$LEGEND" + (j + 1).toString() + "$", "");
                }
              }
            }
            if (this._xAxis.markers[i].PatchTextCallback != null) {
              strValue = this._xAxis.markers[i].PatchTextCallback(strValue);
            }
          }
          let ssize = g.MeasureString(strValue, this._xAxis.markers[i].font, 1e4);
          let labelWidth = ssize.width + 2 * this._xAxis.markers[i].padding + this._xAxis.markers[i].borderthickness;
          let labelHeight = ssize.height + 2 * this._xAxis.markers[i].padding + this._xAxis.markers[i].borderthickness;
          g.FillRectangleXYHW(this._xAxis.markers[i].bgBrush, xxCenter - (labelWidth >> 1), yyCenter - (labelHeight >> 1), labelWidth >> 0, labelHeight >> 0);
          g.DrawRectangleXYHW(this._xAxis.markers[i].pen, xxCenter - (labelWidth >> 1), yyCenter - (labelHeight >> 1), labelWidth >> 0, labelHeight >> 0);
          let xText;
          switch (this._xAxis.markers[i].textAlign) {
            case Marker.TextAlign.LEFT:
              xText = xxCenter - (labelWidth >> 1) + this._xAxis.markers[i].padding;
              break;
            case Marker.TextAlign.RIGHT:
              xText = xxCenter + (labelWidth >> 1) - this._xAxis.markers[i].padding;
              break;
            default:
              xText = xxCenter;
              break;
          }
          g.DrawStringPF(strValue, this._xAxis.markers[i].font, this._xAxis.markers[i].font.brush, new PointF(xText, yyCenter), this._xAxis.markers[i].stringFormat);
          g.DrawLineXY(this._xAxis.markers[i].pen, xxCenter, w.Tmargin >> 0, xxCenter, yyCenter - (labelHeight >> 1));
          g.DrawLineXY(this._xAxis.markers[i].pen, xxCenter, yyCenter + (labelHeight >> 1), xxCenter, w.Height - w.Bmargin >> 0);
          if (this._xAxis.markers[i].arrowSize > 0) {
            if (this._xAxis.markers[i].yposition > 25) {
              let triangle = [
                new PointF(xxCenter - this._xAxis.markers[i].arrowSize, yyCenter + (labelHeight >> 1)),
                new PointF(xxCenter + this._xAxis.markers[i].arrowSize, yyCenter + (labelHeight >> 1)),
                new PointF(xxCenter, yyCenter + (labelHeight >> 1) + this._xAxis.markers[i].arrowSize)
              ];
              g.FillPolygon(this._xAxis.markers[i].arrowBrush, triangle);
            }
            if (this._xAxis.markers[i].yposition < 75) {
              let triangle = [
                new PointF(xxCenter - this._xAxis.markers[i].arrowSize, yyCenter + (labelHeight >> 1)),
                new PointF(xxCenter + this._xAxis.markers[i].arrowSize, yyCenter + (labelHeight >> 1)),
                new PointF(xxCenter, yyCenter - (labelHeight >> 1) - this._xAxis.markers[i].arrowSize)
              ];
              g.FillPolygon(this._xAxis.markers[i].arrowBrush, triangle);
            }
          }
        }
      }
    }
    g.ResetClip();
  }
  DrawDataPanels(w, g, scaleX, scalesY, viewPortWidth, viewPortHeight) {
    if (this._dataPanels.length == 0)
      return;
    g.SetClip(new YRectangle(w.Lmargin, w.Tmargin, w.Width - w.Rmargin - w.Lmargin, w.Height - w.Bmargin - w.Tmargin));
    for (let i = 0; i < this._dataPanels.length; i++) {
      if (this._dataPanels[i].enabled) {
        let p = this._dataPanels[i];
        if (p.yScaleIndex < scalesY.length) {
          let AvailableWidth = w.Width - 2 * p.padding - p.borderthickness;
          if (AvailableWidth < 100)
            AvailableWidth = 100;
          let ssize = g.MeasureString(p.text, p.font, AvailableWidth >> 0);
          let panelWidth = ssize.width + 2 * p.padding + p.borderthickness;
          let panelHeight = ssize.height + 2 * p.padding + p.borderthickness;
          let x = 0;
          switch (p.horizontalPosition) {
            case DataPanel.HorizontalPosition.LEFTBORDER:
              x = w.Lmargin;
              break;
            case DataPanel.HorizontalPosition.RIGHTBORDER:
              x = w.Width - w.Rmargin;
              break;
            case DataPanel.HorizontalPosition.ABSOLUTEX:
              let delta = scaleX.max - scaleX.min;
              let XZoom = delta / (w.Width - w.Lmargin - w.Rmargin);
              x = w.Lmargin + Math.round((p.AbsoluteXposition - scaleX.min) / XZoom) >> 0;
              break;
          }
          let y = 0;
          switch (p.verticalPosition) {
            case DataPanel.VerticalPosition.TOPBORDER:
              y = w.Tmargin;
              break;
            case DataPanel.VerticalPosition.BOTTOMBORDER:
              y = w.Height - w.Bmargin;
              break;
            case DataPanel.VerticalPosition.ABSOLUTEY:
              y = w.Height - w.Bmargin - Math.round((p.AbsoluteYposition - scalesY[p.yScaleIndex].IRLy) * scalesY[p.yScaleIndex].zoom) >> 0;
              break;
          }
          switch (p.panelHrzAlign) {
            case DataPanel.HorizontalAlign.LEFTOF:
              x -= panelWidth + p.horizontalMargin;
              break;
            case DataPanel.HorizontalAlign.RIGHTOF:
              x += p.horizontalMargin;
              break;
            default:
              x -= panelWidth / 2;
              break;
          }
          switch (p.panelVrtAlign) {
            case DataPanel.VerticalAlign.ABOVE:
              y -= panelHeight + p.verticalMargin;
              break;
            case DataPanel.VerticalAlign.BELOW:
              y += p.verticalMargin;
              break;
            default:
              y -= panelHeight / 2;
              break;
          }
          g.FillRectangleXYHW(p.bgBrush, x >> 0, y >> 0, panelWidth >> 0, panelHeight >> 0);
          if (p.borderthickness > 0)
            g.DrawRectangleXYHW(p.pen, x >> 0, y >> 0, panelWidth >> 0, panelHeight >> 0);
          let sf = new YStringFormat(
            16384
            /* YDataRendering.YStringFormat.StringFormatFlags.NoClip */
          );
          switch (p.panelTextAlign) {
            case MessagePanel.TextAlign.LEFT:
              sf.LineAlignment = 0;
              sf.Alignment = 0;
              break;
            case MessagePanel.TextAlign.RIGHT:
              sf.LineAlignment = 2;
              sf.Alignment = 2;
              break;
            default:
              sf.LineAlignment = 1;
              sf.Alignment = 1;
              break;
          }
          let rect = new YRectangle(x + p.padding + p.borderthickness / 2 >> 0, y + p.padding + p.borderthickness / 2 >> 0, ssize.width >>= 1, (ssize.height >> 0) + 1);
          g.DrawStringRect(p.text, p.font, p.font.brush, rect, sf);
        } else {
          throw new RangeError("Cannot renderer data panel #" + i.toString() + ", no such Y axis");
        }
      }
    }
  }
  // find the index of a series segment containing a specific timestamp
  // non integer indexes (XX.5) means the timestamp is located between
  // segements XX and XX+1
  findSegmentIndex(serieIndex, timeStamp, debug) {
    let s = this._series[serieIndex];
    if (s.segments.length <= 0)
      return -1;
    let start = 0;
    let end = s.segments.length - 1;
    if (debug) {
      console.log("looking for " + timeStamp);
      for (let i = 0; i < s.segments.length; i++)
        console.log("seg " + i + " [" + s.segments[i].data[0].x + ".." + s.segments[i].data[s.segments[i].count - 1].x + "]");
      debugger;
    }
    while (true) {
      let startSeg = s.segments[start];
      let endSeg = s.segments[end];
      if (timeStamp > startSeg.data[startSeg.count - 1].x)
        return start - 0.5;
      if (timeStamp < endSeg.data[0].x)
        return end + 0.5;
      if (timeStamp >= startSeg.data[0].x)
        return start;
      if (timeStamp <= endSeg.data[endSeg.count - 1].x)
        return end;
      if (end == start) {
        debugger;
        return -99;
      }
      if (end - start == 1)
        return start + 0.5;
      let middle = start + end >> 1;
      let middleSeg = s.segments[middle];
      if (timeStamp <= middleSeg.data[middleSeg.count - 1].x) {
        end = end - 1;
        start = middle;
      } else {
        end = middle - 1;
        start = start + 1;
      }
    }
  }
  findTimestampIndexInSegment(serieIndex, segmentIndex, timeStamp) {
    let seg = this._series[serieIndex].segments[segmentIndex];
    if (!seg)
      debugger;
    if (timeStamp <= seg.data[0].x)
      return 0;
    let count = this._series[serieIndex].segments[segmentIndex].count;
    if (timeStamp >= seg.data[count - 1].x)
      return count - 1;
    let start = 0;
    let end = count - 1;
    let middle = 0;
    while (true) {
      if (end - start <= 1) {
        if (timeStamp <= seg.data[start].x)
          return start;
        return end;
      }
      middle = start + end >> 1;
      if (timeStamp <= seg.data[middle].x)
        end = middle;
      else
        start = middle;
    }
  }
  Render(g, UIw, UIh) {
    if (UIw < 50 || UIh < 50)
      return 0;
    let lastLmargin = this.mainViewPort.Lmargin;
    let lastRmargin = this.mainViewPort.Rmargin;
    this.mainViewPort.Width = UIw;
    this.mainViewPort.Height = UIh;
    this.mainViewPort.Lmargin = 0;
    this.mainViewPort.Rmargin = 0;
    g.SmoothingMode = YSmoothingMode.HighQuality;
    let yMarginOffset = 5;
    for (let i = 0; i < this._yAxes.length; i++) {
      if (this._yAxes[i].visible) {
        let s = g.MeasureString("8", this._yAxes[i].font, 1e5);
        let o = (s.height + 1) / 2 >> 0;
        if (yMarginOffset < o)
          yMarginOffset = o;
      }
    }
    this.mainViewPort.Tmargin = this._xAxis.position == XAxis.VrtPosition.TOP ? 0 : yMarginOffset;
    this.mainViewPort.Bmargin = this._xAxis.position == XAxis.VrtPosition.BOTTOM ? 0 : yMarginOffset;
    if (!this._legendPanel.overlap)
      this.drawLegendPanel(g, UIw, UIh, this.mainViewPort);
    this.drawAnnotationPanels(g, this._annotationPanels, UIw, UIh, false, this.mainViewPort);
    if (this.mainViewPort.Bmargin == 0)
      this.mainViewPort.Bmargin = 5;
    if (this.mainViewPort.Tmargin == 0)
      this.mainViewPort.Tmargin = 5;
    let h = this.DrawXAxis(this.mainViewPort, g, this._xAxis, true);
    if (this._xAxis.position == XAxis.VrtPosition.TOP)
      this.mainViewPort.Tmargin += h;
    else
      this.mainViewPort.Bmargin += h;
    this.mainViewPort.IRLx = this._xAxis.min;
    let M;
    for (let i = 0; i < this._yAxes.length; i++) {
      M = MinMaxHandler.DefaultValue();
      for (let k = 0; k < this._series.length; k++) {
        if (this._series[k].yAxisIndex == i && !this._series[k].disabled) {
          for (let j = 0; j < this._series[k].segments.length; j++) {
            M = MinMaxHandler.Combine(M, _YGraph.FindMinMax(this._xAxis.min, this._xAxis.max, this._series[k].segments[j].data, this._series[k].segments[j].count));
          }
        }
      }
      this._yAxes[i].computeStartAndStep(M);
    }
    if (this.mainViewPort.Lmargin == 0)
      this.mainViewPort.Lmargin = 5;
    if (this.mainViewPort.Rmargin == 0)
      this.mainViewPort.Rmargin = 5;
    for (let i = 0; i < this._yAxes.length; i++) {
      let sw = _YGraph.DrawYAxis(this.mainViewPort, g, this._yAxes[i], 0, true);
      this.mainViewPort.Lmargin += this._yAxes[i].position == YAxis.HrzPosition.LEFT ? sw : 0;
      this.mainViewPort.Rmargin += this._yAxes[i].position == YAxis.HrzPosition.RIGHT ? sw : 0;
    }
    if (this._navigator.enabled) {
      if (lastLmargin != this.mainViewPort.Lmargin || lastRmargin != this.mainViewPort.Rmargin) {
        this.navigatorCache = null;
      }
      let nh = this._navigator.relativeheight * this.UIContainer.height / 100 >> 0;
      let ofset = this.xAxis.position == XAxis.VrtPosition.BOTTOM ? h : 0;
      this._navigator.setPosition(UIw, UIh, this.mainViewPort.Lmargin, this.mainViewPort.Rmargin, this.mainViewPort.Height - nh - this.mainViewPort.Bmargin + ofset, this.mainViewPort.Bmargin - ofset);
      this.mainViewPort.Bmargin += nh;
    }
    if (this.lastTopMargin != this.mainViewPort.Tmargin || this.lastBottomMargin != this.mainViewPort.Bmargin) {
      this._bgBrush = null;
      this.lastTopMargin = this.mainViewPort.Tmargin;
      this.lastBottomMargin = this.mainViewPort.Bmargin;
    }
    if (this._bgBrush == null) {
      this._bgBrush = new YLinearGradientBrush(this._bgColor2, this._bgColor1);
    }
    g.FillRectangleXYHW(this._bgBrush, this.mainViewPort.Lmargin, this.mainViewPort.Tmargin, this.mainViewPort.Width - this.mainViewPort.Rmargin - this.mainViewPort.Lmargin, this.mainViewPort.Height - this.mainViewPort.Bmargin - this.mainViewPort.Tmargin);
    if (this._borderThickness > 0) {
      if (this._borderPen == null)
        this._borderPen = new YPen(this._borderColor, this._borderThickness);
      g.DrawRectangleXYHW(this._borderPen, this.mainViewPort.Lmargin, this.mainViewPort.Tmargin, this.mainViewPort.Width - this.mainViewPort.Rmargin - this.mainViewPort.Lmargin, this.mainViewPort.Height - this.mainViewPort.Bmargin - this.mainViewPort.Tmargin);
    }
    g.SetClip(new YRectangle(this.mainViewPort.Lmargin, this.mainViewPort.Tmargin, this.mainViewPort.Width - this.mainViewPort.Rmargin - this.mainViewPort.Lmargin, this.mainViewPort.Height - this.mainViewPort.Bmargin - this.mainViewPort.Tmargin));
    for (let i = 0; i < this._yAxes.length; i++) {
      this.DrawYAxisZones(this.mainViewPort, g, this._yAxes[i]);
    }
    this.DrawXAxisZones(this.mainViewPort, g, this.xAxis);
    g.ResetClip();
    this.DrawXAxis(this.mainViewPort, g, this._xAxis, false);
    let leftOffset = 0;
    let rightOffset = 0;
    for (let i = 0; i < this._yAxes.length; i++) {
      let ww = _YGraph.DrawYAxis(this.mainViewPort, g, this._yAxes[i], this._yAxes[i].position == YAxis.HrzPosition.LEFT ? leftOffset : rightOffset, false);
      if (this._yAxes[i].position == YAxis.HrzPosition.LEFT)
        leftOffset += ww;
      if (this._yAxes[i].position == YAxis.HrzPosition.RIGHT)
        rightOffset += ww;
    }
    g.SetClip(new YRectangle(this.mainViewPort.Lmargin, this.mainViewPort.Tmargin, this.mainViewPort.Width - this.mainViewPort.Rmargin - this.mainViewPort.Lmargin, this.mainViewPort.Height - this.mainViewPort.Bmargin - this.mainViewPort.Tmargin));
    this.mainViewPort.zoomx = (this.mainViewPort.Width - this.mainViewPort.Lmargin - this.mainViewPort.Rmargin) / (this._xAxis.max - this._xAxis.min);
    let mypenb = null;
    let lineCount = 0;
    let pointCount = 0;
    let Bottomleft = _YGraph.ViewPortPointToIRL(this.mainViewPort, new Point(this.mainViewPort.Lmargin, this.mainViewPort.Height - this.mainViewPort.Bmargin));
    let TopRight = _YGraph.ViewPortPointToIRL(this.mainViewPort, new Point(this.mainViewPort.Width - this.mainViewPort.Rmargin, this.mainViewPort.Tmargin));
    let xTimeStart = Bottomleft.x;
    let xTimeEnd = TopRight.x;
    let availabelPixelWidth = this.mainViewPort.Width - this.mainViewPort.Rmargin - this.mainViewPort.Lmargin;
    for (let k = 0; k < this._series.length; k++) {
      if (this._series[k].visible && !this._series[k].disabled && this._series[k].segments.length > 0) {
        let scaleIndex = this._series[k].yAxisIndex;
        mypenb = this._series[k].pen;
        this.mainViewPort.IRLy = this._yAxes[scaleIndex].startStopStep.dataMin;
        this._yAxes[this._series[k].yAxisIndex].IRLy = this.mainViewPort.IRLy;
        let delta = this._yAxes[scaleIndex].startStopStep.dataMax - this._yAxes[scaleIndex].startStopStep.dataMin;
        if (delta == 0) {
          delta = 1;
          this.mainViewPort.IRLy -= delta / 2;
        }
        this.mainViewPort.zoomy = (this.mainViewPort.Height - this.mainViewPort.Tmargin - this.mainViewPort.Bmargin) / delta;
        this._yAxes[this._series[k].yAxisIndex].zoom = this.mainViewPort.zoomy;
        g.comment("** main view-port series " + k.toString());
        let FirstSegmentIndexTmp = this.findSegmentIndex(k, xTimeEnd, false);
        let LastSegmentIndexTmp = this.findSegmentIndex(k, xTimeStart, false);
        let inside = true;
        let maxIndex = this._series[k].segments.length - 1;
        if (FirstSegmentIndexTmp < 0 && LastSegmentIndexTmp < 0) {
          inside = false;
        }
        if (FirstSegmentIndexTmp > maxIndex && LastSegmentIndexTmp > maxIndex) {
          inside = false;
        }
        if (inside) {
          let FirstSegmentIndex = Math.floor(FirstSegmentIndexTmp + 0.5);
          let LastSegmentIndex = Math.floor(LastSegmentIndexTmp);
          if (LastSegmentIndex < 0) {
            throw new Error("findSegmentIndex return an invalid index (" + LastSegmentIndex + ")");
          }
          if (FirstSegmentIndex < 0) {
            throw new Error("findSegmentIndex return an invalid index (" + FirstSegmentIndex + ")!");
          }
          if (FirstSegmentIndex > this._series[k].segments.length - 1) {
            throw new Error("findSegmentIndex return an invalid index (" + FirstSegmentIndex + ")!!");
          }
          if (LastSegmentIndex > this._series[k].segments.length - 1) {
            throw new Error("findSegmentIndex return an invalid index (" + LastSegmentIndex + ")!!!");
          }
          let firstDataIndex = this.findTimestampIndexInSegment(k, FirstSegmentIndex, xTimeEnd);
          let lastDataIndex = this.findTimestampIndexInSegment(k, LastSegmentIndex, xTimeStart);
          let totalPointsToDraw = 0;
          if (FirstSegmentIndex == LastSegmentIndex)
            totalPointsToDraw = firstDataIndex - lastDataIndex;
          else if (FirstSegmentIndex < LastSegmentIndex) {
            totalPointsToDraw = this._series[k].segments[LastSegmentIndex].count - lastDataIndex + firstDataIndex;
            for (let i = FirstSegmentIndex + 1; i < LastSegmentIndex; i++)
              totalPointsToDraw += this._series[k].segments[i].count;
          }
          let density = Math.round(totalPointsToDraw / availabelPixelWidth);
          if (density < SUMMARY_GRANULARITY || SUMMARY_GRANULARITY <= 0) {
            for (let i = 0; i < this._series[k].segments.length; i++) {
              lineCount += _YGraph.DoSegmentRendering(this.mainViewPort, g, mypenb, this._series[k].segments[i].data, this._series[k].segments[i].count, xTimeStart, xTimeEnd);
              pointCount += this._series[k].segments[i].count;
            }
          } else {
            let level = Math.floor(Math.log(density) / Math.log(SUMMARY_GRANULARITY)) - 1;
            let s = this._series[k].summaries[level];
            let finalpoint = null;
            for (let i = 0; i < s.segments.length; i++) {
              if (i == s.segments.length - 1) {
                finalpoint = s.getBufferpoint();
              }
              lineCount += _YGraph.DoSummarySegmentRendering(this.mainViewPort, g, mypenb, s.segments[i].data, s.segments[i].ptCount, finalpoint, xTimeStart, xTimeEnd);
              pointCount += s.segments[i].ptCount;
            }
          }
        } else
          console.log("Data are ouside dataview");
      }
    }
    g.ResetClip();
    if (this._navigator.enabled) {
      g.comment("** navigator **");
      let v = this._navigator.viewport;
      let range = MinMaxHandler.DefaultValue();
      for (let i = 0; i < this._series.length; i++) {
        if (!this._series[i].disabled)
          range = MinMaxHandler.Combine(range, this._series[i].timeRange);
      }
      this._navigator.Xrange = MinMaxHandler.extend(range, 1.05);
      v.zoomx = (v.Width - v.Lmargin - v.Rmargin) / (this._navigator.Xrange.Max - this._navigator.Xrange.Min);
      if (this.lastPointCount != pointCount && !this.mainViewPort.Capture && !this._navigator.Capture || this.navigatorCache == null || g instanceof YGraphicsSVG) {
        g.comment("Redraw navigator");
        if (this.navigatorCache != null)
          this.navigatorCache = null;
        this.navigatorCache = document.createElement("canvas");
        this.navigatorCache.width = v.Width;
        this.navigatorCache.height = v.Height;
        this.lastPointCount = pointCount;
        let ng;
        if (g instanceof YGraphicsSVG) {
          ng = g;
        } else {
          ng = new YGraphics(this.navigatorCache, v.Width, v.Height, 90);
        }
        ng.SetClip(new YRectangle(v.Lmargin, v.Tmargin, v.Width - v.Rmargin - v.Lmargin, v.Height - v.Bmargin - v.Tmargin));
        ng.FillRectangleXYHW(this._navigator.bgBrush, v.Lmargin, v.Tmargin, v.Width - v.Rmargin - v.Lmargin, v.Height - v.Bmargin - v.Tmargin);
        if (this.xAxis.zones.length > 0 && this._navigator.showXAxisZones) {
          let delta = this._navigator.Xrange.Max - this._navigator.Xrange.Min;
          let XZoom = delta / (v.Width - v.Lmargin - v.Rmargin);
          for (let i = 0; i < this.xAxis.zones.length; i++) {
            if (this.xAxis.zones[i].visible) {
              let min = this.xAxis.zones[i].min;
              let max = this.xAxis.zones[i].max;
              if (isNaN(min))
                min = this._navigator.Xrange.Min;
              if (isNaN(max))
                max = this._navigator.Xrange.Max;
              ng.FillRectangleXYHW(this.xAxis.zones[i].zoneBrush, v.Lmargin + (min - this._navigator.Xrange.Min) / XZoom >> 0, v.Tmargin >> 0, (max - min) / XZoom >> 0, v.Height - v.Bmargin - v.Tmargin);
            }
          }
        }
        if (MinMaxHandler.isDefined(this._navigator.Xrange) && this._navigator.Xrange.Max - this._navigator.Xrange.Min > 0) {
          let Min;
          let Max;
          v.IRLx = this._navigator.Xrange.Min;
          let dontSticktoBorderZoom = 4 / (v.Height - v.Bmargin - v.Tmargin);
          let Bottomleft2 = _YGraph.ViewPortPointToIRL(v, new Point(v.Lmargin, v.Height - v.Bmargin));
          let TopRight2 = _YGraph.ViewPortPointToIRL(v, new Point(v.Width - v.Rmargin, v.Tmargin));
          let xTimeStart2 = Bottomleft2.x;
          let xTimeEnd2 = TopRight2.x;
          if (this._navigator.yAxisHandling == Navigator.YAxisHandling.AUTO) {
            for (let k = 0; k < this._series.length; k++) {
              if (!this._series[k].disabled) {
                ng.comment("** navigator series " + k.toString());
                v.IRLy = this._series[k].valueRange.Min;
                let yAxisIndex = this._series[k].yAxisIndex;
                mypenb = this._series[k].navigatorpen;
                Min = this._series[k].valueRange.Min;
                Max = this._series[k].valueRange.Max;
                if (Max - Min <= 0) {
                  v.IRLy = Min - 0.5;
                  Max = Min + 0.5;
                } else {
                  let delta = Max - Min;
                  Min -= delta * dontSticktoBorderZoom;
                  Max += delta * dontSticktoBorderZoom;
                }
                v.IRLy = Min;
                v.zoomy = (v.Height - v.Tmargin - v.Bmargin) / (Max - Min);
                let availableWidth = v.Width - v.Lmargin - v.Rmargin;
                let totalPoint = 0;
                for (let i = 0; i < this._series[k].segments.length; i++)
                  totalPoint += this._series[k].segments[i].count;
                let density = Math.round(totalPoint / availableWidth);
                if (density < SUMMARY_GRANULARITY || SUMMARY_GRANULARITY <= 0) {
                  for (let i = 0; i < this._series[k].segments.length; i++) {
                    lineCount += _YGraph.DoSegmentRendering(v, ng, mypenb, this._series[k].segments[i].data, this._series[k].segments[i].count, xTimeStart2, xTimeEnd2);
                  }
                } else {
                  let level = Math.floor(Math.log(density) / Math.log(SUMMARY_GRANULARITY)) - 1;
                  let s = this._series[k].summaries[level];
                  let finalpoint = null;
                  for (let i = 0; i < s.segments.length; i++) {
                    if (i == s.segments.length - 1)
                      finalpoint = s.getBufferpoint();
                    lineCount += _YGraph.DoSummarySegmentRendering(v, ng, mypenb, s.segments[i].data, s.segments[i].ptCount, finalpoint, xTimeStart2, xTimeEnd2);
                  }
                }
              }
            }
          } else {
            for (let i = 0; i < this._yAxes.length; i++) {
              let Yrange = MinMaxHandler.DefaultValue();
              for (let j = 0; j < this._series.length; j++) {
                if (this._series[j].yAxisIndex == i && !this._series[j].disabled) {
                  Yrange = MinMaxHandler.Combine(Yrange, this._series[j].valueRange);
                }
              }
              Yrange = MinMaxHandler.extend(Yrange, 1 + 2 * dontSticktoBorderZoom);
              Min = this._yAxes[i].min;
              if (isNaN(Min))
                Min = Yrange.Min;
              Max = this._yAxes[i].max;
              if (isNaN(Max))
                Max = Yrange.Max;
              if (Number.isNaN(Min)) {
                Min = 0;
                Max = 1;
              }
              if (Max - Min <= 0) {
                Min = Min - 0.5;
                Max = Min + 0.5;
              }
              v.IRLy = Min;
              v.zoomy = (v.Height - v.Tmargin - v.Bmargin) / (Max - Min);
              for (let j = 0; j < this._series.length; j++) {
                if (this._series[j].yAxisIndex == i && !this._series[j].disabled && this._series[j].visible) {
                  ng.comment("** navigator series " + j.toString());
                  mypenb = this._series[j].navigatorpen;
                  let availableWidth = v.Width - v.Lmargin - v.Rmargin;
                  let totalPoint = 0;
                  for (let i2 = 0; i2 < this._series[j].segments.length; i2++)
                    totalPoint += this._series[j].segments[i2].count;
                  let density = Math.round(totalPoint / availableWidth);
                  if (density < SUMMARY_GRANULARITY || SUMMARY_GRANULARITY <= 0) {
                    for (let i2 = 0; i2 < this._series[j].segments.length; i2++) {
                      lineCount += _YGraph.DoSegmentRendering(v, ng, mypenb, this._series[j].segments[i2].data, this._series[j].segments[i2].count, xTimeStart2, xTimeEnd2);
                    }
                  } else {
                    let level = Math.floor(Math.log(density) / Math.log(SUMMARY_GRANULARITY)) - 1;
                    console.log("Navigator (YAXIS=INHERIT), Serie " + j + ", density is ~" + density + "pts/pixel drawing summarized data level " + level);
                    let s = this._series[j].summaries[level];
                    let finalpoint = null;
                    for (let i2 = 0; i2 < s.segments.length; i2++) {
                      if (i2 == s.segments.length - 1)
                        finalpoint = s.getBufferpoint();
                      lineCount += _YGraph.DoSummarySegmentRendering(v, ng, mypenb, s.segments[i2].data, s.segments[i2].ptCount, finalpoint, xTimeStart2, xTimeEnd2);
                    }
                  }
                }
              }
            }
          }
          for (let i = 0; i < this._xAxis.markers.length; i++) {
            if (this._xAxis.markers[i].enabled) {
              let p = _YGraph.IRLPointToViewPort(v, new pointXY(this._xAxis.markers[i].xposition + (this._xAxis.markers[i].timereference == TimeConverter.TimeReference.RELATIVE ? this._xAxis.zeroTime : 0), 0));
              ng.DrawLineXY(this._xAxis.markers[i].navigatorpen, p.X, v.Tmargin, p.X, v.Height - v.Bmargin);
            }
          }
          if (this._navigator.borderThickness > 0) {
            ng.DrawLineXY(this._navigator.borderPen, v.Lmargin, v.Tmargin, v.Width - v.Rmargin, v.Tmargin);
          }
          this.DrawMonitorXAxis(v, ng, this._navigator.Xrange, this.xAxis.labelFormat);
          this._navigator.setIRLPosition(v.IRLx, v.IRLy, v.zoomx, v.zoomy);
        }
        ng.ResetClip();
        if (!(g instanceof YGraphicsSVG))
          ng.Dispose();
      }
      let cacheW = v.Width - v.Rmargin - v.Lmargin + 1;
      let cacheH = v.Width - v.Rmargin - v.Lmargin + 1;
      let rectsrc = new YRectangle(v.Lmargin, v.Tmargin - 1, cacheW, cacheH);
      let rectdst = new YRectangle(v.Lmargin, v.Tmargin, cacheW, cacheH);
      g.SetClip(rectdst);
      if (!(g instanceof YGraphicsSVG)) {
        g.DrawImage(
          this.navigatorCache,
          rectsrc,
          rectdst,
          2
          /* YDataRendering.YGraphicsUnit.Pixel */
        );
      }
      if (this._navigator.borderThickness > 0) {
        g.DrawLineXY(this._navigator.borderPen, v.Lmargin + 1, v.Tmargin, v.Lmargin + 1, v.Height - v.Bmargin - 1);
        g.DrawLineXY(this._navigator.borderPen, v.Width - v.Rmargin, v.Tmargin, v.Width - v.Rmargin, v.Height - v.Bmargin - 1);
        g.DrawLineXY(this._navigator.borderPen, v.Lmargin + 1, v.Tmargin, v.Width - v.Rmargin, v.Tmargin);
      }
      let IRLCursorStart = _YGraph.ViewPortPointToIRL(this.mainViewPort, new Point(this.mainViewPort.Lmargin, 0));
      let IRLCursorEnd = _YGraph.ViewPortPointToIRL(this.mainViewPort, new Point(this.mainViewPort.Width - this.mainViewPort.Rmargin, 0));
      let CursorStart = _YGraph.IRLPointToViewPort(this._navigator.viewport, new pointXY(IRLCursorStart.x, 0));
      let CursorEnd = _YGraph.IRLPointToViewPort(this._navigator.viewport, new pointXY(IRLCursorEnd.x, 0));
      g.FillRectangle(this._navigator.cursorBrush, new YRectangle(CursorStart.X - 1, v.Tmargin, CursorEnd.X - CursorStart.X + 2, v.Height - v.Bmargin - v.Tmargin - 1));
      g.DrawLineXY(this._navigator.cursorBorderPen, CursorStart.X - 1 >> 0, v.Tmargin >> 0, CursorStart.X - 1 >> 0, v.Height - v.Bmargin - 1);
      g.DrawLineXY(this._navigator.cursorBorderPen, CursorEnd.X + 1 >> 0, v.Tmargin >> 0, CursorEnd.X + 1 >> 0, v.Height - v.Bmargin - 1);
      g.ResetClip();
    }
    if (this._legendPanel.overlap)
      this.drawLegendPanel(g, UIw, UIh, this.mainViewPort);
    g.TextRenderingHint = YTextRenderingHint.SingleBitPerPixelGridFit;
    this.DrawMarkers(this.mainViewPort, g, this.xAxis, UIw, UIh);
    this.drawAnnotationPanels(g, this._annotationPanels, UIw, UIh, true, this.mainViewPort);
    this.DrawDataPanels(this.mainViewPort, g, this.xAxis, this._yAxes, UIw, UIh);
    this.DrawDataTracker(g, UIw, UIh, this.xAxis);
    this.DrawMessagePanels(g, UIw, UIh);
    return 0;
  }
  KeyDown(sender, e) {
    if (e.code == "ArrowLeft") {
      let delta = 0.2 * (this._xAxis.max - this._xAxis.min);
      this._xAxis.set_minMax(this._xAxis.min - delta, this._xAxis.max - delta);
      this.redraw();
    }
    if (e.code == "ArrowRight") {
      let delta = 0.2 * (this._xAxis.max - this._xAxis.min);
      this._xAxis.set_minMax(this._xAxis.min + delta, this._xAxis.max + delta);
      this.redraw();
    }
    if (e.code == "ArrowUp") {
      this.mouseWheel(new Point(this.UIContainer.width >> 1, this.UIContainer.height >> 1), 10);
    }
    if (e.code == "ArrowDown") {
      this.mouseWheel(new Point(this.UIContainer.width >> 1, this.UIContainer.height >> 1), -10);
    }
  }
  mouseWheel(pos, delta) {
    let ZoomFactor = Math.pow(1.25, delta / 120);
    let NextZoomX = this.mainViewPort.zoomx * ZoomFactor;
    if (NextZoomX > this.mainViewPort.zoomx && NextZoomX > 1e3)
      return;
    let currentRange = this._xAxis.max - this._xAxis.min;
    if (currentRange / ZoomFactor > 25 * 365 * 86400)
      return;
    this.mainViewPort.IRLx += (pos.X - this.mainViewPort.Lmargin) / this.mainViewPort.zoomx - (pos.X - this.mainViewPort.Lmargin) / NextZoomX;
    let range = this._xAxis.max - this._xAxis.min;
    this._xAxis.set_minMax(this.mainViewPort.IRLx, this.mainViewPort.IRLx + range / ZoomFactor);
    this.mainViewPort.zoomx = NextZoomX;
    this.redraw();
  }
  mouseWheelEvent(sender, e) {
    let p = this.Scr2ElmMatrix.multiplyByV(Vector3.FromXYCoord(e.pageX, e.pageY)).toPoint();
    let eX = p.X;
    let eY = p.Y;
    this.mouseWheel(new Point(eX, eY), e.deltaY > 0 ? -150 : 150);
    e.preventDefault();
  }
};
YGraph._defaultVerticalDragZoomEnabled = false;
YGraph.captureCursor = null;

// obj/full/Renderer/YSolidGauge.js
var DrawPrameters = class {
  constructor() {
    this.outerRadius = 0;
    this.innerRadius = 0;
    this.angleStart = 0;
    this.angleEnd = 0;
    this.ycenter = 0;
    this.xcenter = 0;
    this.heightTop = 0;
    this.heightBottom = 0;
    this.valueRectangle = new YRectangle(0, 0, 0, 0);
    this.valueFormat = new YStringFormat(
      16384
      /* YDataRendering.YStringFormat.StringFormatFlags.NoClip */
    );
    this.minValueRectangle = new YRectangle(0, 0, 0, 0);
    this.minValueFormat = new YStringFormat(
      16384
      /* YDataRendering.YStringFormat.StringFormatFlags.NoClip */
    );
    this.maxValueRectangle = new YRectangle(0, 0, 0, 0);
    this.maxValueFormat = new YStringFormat(
      16384
      /* YDataRendering.YStringFormat.StringFormatFlags.NoClip */
    );
    this.minValue = "";
    this.maxValue = "";
    this.value = "";
  }
};
var YSolidGauge = class _YSolidGauge extends YDataRenderer {
  get min() {
    return this._min;
  }
  set min(value) {
    if (value >= this._max && !YDataRenderer.minMaxCheckDisabled) {
      throw new RangeError("Min cannot be greater than max (" + this._max.toString() + ")");
    }
    this._min = value;
    if (this._shownValue < this._min)
      this._shownValue = this._min;
    this.redraw();
  }
  get max() {
    return this._max;
  }
  set max(value) {
    if (value <= this._min && !YDataRenderer.minMaxCheckDisabled) {
      throw new RangeError("Max cannot be less than min (" + this._min.toString() + ")");
    }
    this._max = value;
    if (this._shownValue > this._max)
      this._shownValue = this._max;
    this.redraw();
  }
  get borderpen() {
    if (this._borderpen == null) {
      this._borderpen = new YPen(this._borderColor, this._borderThickness);
      this._borderpen.startCap = 1;
      this._borderpen.endCap = 1;
    }
    return this._borderpen;
  }
  get borderColor() {
    return this._borderColor;
  }
  set borderColor(value) {
    this._borderColor = value;
    this._borderpen = null;
    this.redraw();
  }
  get backgroundColor1() {
    return this._backgroundColor1;
  }
  set backgroundColor1(value) {
    this._backgroundColor1 = value;
    this._bgBrush = null;
    this.redraw();
  }
  get backgroundColor2() {
    return this._backgroundColor2;
  }
  set backgroundColor2(value) {
    this._backgroundColor2 = value;
    this._bgBrush = null;
    this.redraw();
  }
  get borderThickness() {
    return this._borderThickness;
  }
  set borderThickness(value) {
    if (value < 0)
      throw new RangeError("Thickness must be a positive value");
    this._borderThickness = value;
    this._borderpen = null;
    this._path = null;
    this.redraw();
  }
  get valueFormater() {
    return this._valueFormater;
  }
  set valueFormater(value) {
    this._valueFormater = value;
    this.redraw();
  }
  get minmaxFormater() {
    return this._minmaxFormater;
  }
  set minmaxFormater(value) {
    this._minmaxFormater = value;
    this.redraw();
  }
  get thickness() {
    return this._thickness;
  }
  set thickness(value) {
    if (value < 0)
      throw new RangeError("Thickness must be a positive value");
    this._thickness = Math.max(Math.min(value, 80), 1);
    this._path = null;
    this.redraw();
  }
  get maxSpeed() {
    return this._maxSpeed;
  }
  set maxSpeed(value) {
    if (value <= 0)
      throw new RangeError("Speed must be a positive value");
    this._maxSpeed = value;
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value;
    this.redraw();
  }
  get color1() {
    return this._color1;
  }
  set color1(value) {
    this._color1 = value;
    this.redraw();
  }
  get color2() {
    return this._color2;
  }
  set color2(value) {
    this._color2 = value;
    this.redraw();
  }
  get font() {
    return this._font;
  }
  get minMaxFont() {
    return this._minMaxFont;
  }
  get showMinMax() {
    return this._showMinMax;
  }
  set showMinMax(value) {
    this._showMinMax = value;
    this._path = null;
    this.redraw();
  }
  get displayMode() {
    return this._displayMode;
  }
  set displayMode(value) {
    this._displayMode = value;
    this._path = null;
    this._bgBrush = null;
    this.redraw();
  }
  FontsizeChange(source) {
    this._path = null;
  }
  constructor(UIContainer, mode, logFunction) {
    super(UIContainer, logFunction);
    this._shownValue = 0;
    this._min = 0;
    this._max = 100;
    this.SegmentMaxLength = 8;
    this.mainViewPort = new ViewPortSettings();
    this._borderpen = null;
    this._borderColor = YColor.Black;
    this._bgBrush = null;
    this._backgroundColor1 = YColor.FromArgb(255, 240, 240, 240);
    this._backgroundColor2 = YColor.FromArgb(255, 200, 200, 200);
    this._borderThickness = 5;
    this._valueFormater = null;
    this._minmaxFormater = null;
    this._thickness = 25;
    this._maxSpeed = 0.1;
    this._value = 0;
    this._color1 = YColor.Green;
    this._color2 = YColor.Red;
    this._font = null;
    this._minMaxFont = null;
    this._showMinMax = true;
    this._path = null;
    this.lastDrawParameters = new DrawPrameters();
    this._displayMode = _YSolidGauge.DisplayMode.DISPLAY90;
    this._minMaxFont = new YFont(this, this, Math.min(UIContainer.width, UIContainer.height) / 15, () => {
      this.FontsizeChange(this._minMaxFont);
    });
    this._displayMode = mode;
    this._font = new YFont(this, this, Math.min(UIContainer.width, UIContainer.height) / 5, null);
    this.resizeRule = Proportional.ResizeRule.RELATIVETOBOTH;
    let g = new YGraphics(UIContainer, UIContainer.width, UIContainer.height, 90);
    let p = this.ComputeDrawParameters(g, UIContainer.width, UIContainer.height, this.mainViewPort);
    g.Dispose();
  }
  clearCachedObjects() {
    this._bgBrush = null;
    this._path = null;
  }
  ComputeDrawParameters(g, UIw, UIh, mainViewPort) {
    UIw -= mainViewPort.Lmargin + mainViewPort.Rmargin;
    UIh -= mainViewPort.Tmargin + mainViewPort.Bmargin;
    let w = UIw - 5 - this._borderThickness;
    let h = UIh - 5 - this._borderThickness;
    let xcenter = UIw / 2;
    let outerRadius = 0;
    let angleStart = 0;
    let angleEnd = 0;
    let ycenter = 0;
    let ValueRectangle = new YRectangle(0, 0, 0, 0);
    let valueFormat = new YStringFormat(
      16384
      /* YDataRendering.YStringFormat.StringFormatFlags.NoClip */
    );
    let innerRadius = 0;
    let minMaxHeight = 0;
    let s1 = new YSizeF(null, "");
    let s2 = new YSizeF(null, "");
    this.lastDrawParameters.value = this._valueFormater == null ? this._value.toFixed(0) : this._valueFormater(this, this._value);
    if (this._showMinMax) {
      this.lastDrawParameters.minValue = this._minmaxFormater == null ? this._min.toFixed(0) : this._minmaxFormater(this, this._min);
      this.lastDrawParameters.maxValue = this._minmaxFormater == null ? this._max.toFixed(0) : this._minmaxFormater(this, this._max);
      s1 = g.MeasureString(this.lastDrawParameters.minValue, this._minMaxFont, 1e5);
      s2 = g.MeasureString(this.lastDrawParameters.maxValue, this._minMaxFont, 1e5);
      this.lastDrawParameters.minValueFormat = new YStringFormat(
        16384
        /* YDataRendering.YStringFormat.StringFormatFlags.NoClip */
      );
      this.lastDrawParameters.maxValueFormat = new YStringFormat(
        16384
        /* YDataRendering.YStringFormat.StringFormatFlags.NoClip */
      );
      minMaxHeight = s1.height;
      if (s2.height > minMaxHeight)
        minMaxHeight = s2.height;
    }
    switch (this._displayMode) {
      case _YSolidGauge.DisplayMode.DISPLAY90:
        h = h - minMaxHeight;
        w = w - minMaxHeight;
        outerRadius = w;
        if (outerRadius > h - this._borderThickness)
          outerRadius = h - this.borderThickness;
        if (outerRadius > w - this.borderThickness)
          outerRadius = w - this.borderThickness;
        angleStart = Math.PI / 2;
        angleEnd = Math.PI;
        this.lastDrawParameters.heightTop = outerRadius;
        this.lastDrawParameters.heightBottom = 0;
        ycenter = mainViewPort.Tmargin + h;
        xcenter = mainViewPort.Lmargin + UIw / 2 + outerRadius / 2 - minMaxHeight + this._borderThickness;
        innerRadius = outerRadius * (100 - this._thickness) / 100;
        ValueRectangle = new YRectangle(xcenter - innerRadius >> 0, ycenter - innerRadius >> 0, innerRadius >> 0, innerRadius >> 0);
        valueFormat.Alignment = 2;
        valueFormat.LineAlignment = 2;
        if (this._showMinMax) {
          this.lastDrawParameters.minValueRectangle = new YRectangle(xcenter - (outerRadius + innerRadius + s1.width) / 2 >> 0, ycenter + this._borderThickness >> 0, s1.width + 1 >> 0, minMaxHeight + 1 >> 0);
          this.lastDrawParameters.minValueFormat.Alignment = 0;
          this.lastDrawParameters.minValueFormat.LineAlignment = 0;
          this.lastDrawParameters.maxValueRectangle = new YRectangle(xcenter + this._borderThickness >> 0, ycenter - outerRadius + (outerRadius - innerRadius - s2.width) / 2 >> 0, minMaxHeight + 1 >> 0, s2.width + 1 >> 0);
          this.lastDrawParameters.maxValueFormat.Alignment = 0;
          this.lastDrawParameters.maxValueFormat.LineAlignment = 0;
          this.lastDrawParameters.maxValueFormat.FormatFlags = 2;
        }
        break;
      case _YSolidGauge.DisplayMode.DISPLAY180:
        h = h - minMaxHeight;
        let s0 = new YSizeF(null, "");
        s0 = g.MeasureString(this.lastDrawParameters.value, this._font, 1e5);
        outerRadius = w / 2 - this.borderThickness;
        if (outerRadius > h - this._borderThickness)
          outerRadius = h - this._borderThickness;
        if (outerRadius > w - this.borderThickness)
          outerRadius = w - this.borderThickness;
        angleStart = 0;
        angleEnd = Math.PI;
        ycenter = outerRadius + this._borderThickness / 2;
        innerRadius = outerRadius * (100 - this._thickness) / 100;
        this.lastDrawParameters.heightTop = outerRadius;
        this.lastDrawParameters.heightBottom = 0;
        ValueRectangle = new YRectangle(xcenter - innerRadius >> 0, ycenter + this._borderThickness + minMaxHeight - s0.height >> 0, 2 * innerRadius >> 0, s0.height + 1 >> 0);
        valueFormat.Alignment = 1;
        valueFormat.LineAlignment = 2;
        if (this._showMinMax) {
          this.lastDrawParameters.minValueRectangle = new YRectangle(xcenter - (outerRadius + innerRadius + s1.width) / 2 >> 0, ycenter + this._borderThickness >> 0, s1.width + 1 >> 0, minMaxHeight + 1 >> 0);
          this.lastDrawParameters.minValueFormat.Alignment = 0;
          this.lastDrawParameters.minValueFormat.LineAlignment = 0;
          this.lastDrawParameters.maxValueRectangle = new YRectangle(xcenter + (outerRadius + innerRadius - s2.width) / 2 >> 0, ycenter + this._borderThickness >> 0, s2.width + 1 >> 0, minMaxHeight + 1 >> 0);
          this.lastDrawParameters.maxValueFormat.Alignment = 0;
          this.lastDrawParameters.maxValueFormat.LineAlignment = 0;
        }
        break;
      case _YSolidGauge.DisplayMode.DISPLAY270:
        outerRadius = w;
        if (outerRadius > h / 2)
          outerRadius = h / 2;
        if (outerRadius > w / 2)
          outerRadius = w / 2;
        this.lastDrawParameters.heightTop = outerRadius;
        this.lastDrawParameters.heightBottom = outerRadius;
        angleStart = 0;
        angleEnd = 3 * Math.PI / 2;
        ycenter = mainViewPort.Tmargin + UIh / 2;
        innerRadius = outerRadius * (100 - this._thickness) / 100;
        ValueRectangle = new YRectangle(xcenter - innerRadius >> 0, ycenter - innerRadius >> 0, 2 * innerRadius >> 0, 2 * innerRadius >> 0);
        valueFormat.Alignment = 1;
        valueFormat.LineAlignment = 1;
        if (this._showMinMax) {
          this.lastDrawParameters.minValueRectangle = new YRectangle(xcenter + this._borderThickness >> 0, ycenter + (innerRadius + innerRadius + s1.height) / 2 >> 0, s1.width + 1 >> 0, s1.height + 1 >> 0);
          this.lastDrawParameters.minValueFormat.Alignment = 0;
          this.lastDrawParameters.minValueFormat.LineAlignment = 0;
          this.lastDrawParameters.maxValueRectangle = new YRectangle(xcenter + (innerRadius + innerRadius + s1.height) / 2 >> 0, ycenter + this._borderThickness >> 0, s2.height + 1 >> 0, s2.width + 1 >> 0);
          this.lastDrawParameters.maxValueFormat.Alignment = 0;
          this.lastDrawParameters.maxValueFormat.LineAlignment = 0;
          this.lastDrawParameters.maxValueFormat.FormatFlags = 2;
        }
        break;
      case _YSolidGauge.DisplayMode.DISPLAY360:
        outerRadius = w;
        if (outerRadius > h / 0.85 / 2)
          outerRadius = h / 0.85 / 2;
        if (outerRadius > w / 2)
          outerRadius = w / 2;
        this.lastDrawParameters.heightTop = outerRadius;
        this.lastDrawParameters.heightBottom = outerRadius * 0.7;
        ycenter = mainViewPort.Tmargin + outerRadius + this._borderThickness / 2;
        angleStart = -Math.PI / 4;
        angleEnd = 5 * Math.PI / 4;
        innerRadius = outerRadius * (100 - this._thickness) / 100;
        ValueRectangle = new YRectangle(xcenter - innerRadius >> 0, ycenter - innerRadius >> 0, 2 * innerRadius >> 0, 2 * innerRadius >> 0);
        valueFormat.Alignment = 1;
        valueFormat.LineAlignment = 1;
        if (this._showMinMax) {
          let dx = Math.abs(innerRadius * Math.cos(angleStart));
          let dy = innerRadius * Math.abs(Math.sin(angleStart)) + 2 * Math.abs((outerRadius - innerRadius) * Math.sin(angleStart) / 3);
          this.lastDrawParameters.minValueRectangle = new YRectangle(xcenter - dx >> 0, ycenter + dy - minMaxHeight / 2 >> 0, s1.width + 1 >> 0, minMaxHeight + 1 >> 0);
          this.lastDrawParameters.minValueFormat.Alignment = 0;
          this.lastDrawParameters.minValueFormat.LineAlignment = 1;
          this.lastDrawParameters.maxValueRectangle = new YRectangle(xcenter + dx - s2.width >> 0, ycenter + dy - minMaxHeight / 2 >> 0, s2.width + 1 >> 0, minMaxHeight + 1 >> 0);
          this.lastDrawParameters.maxValueFormat.Alignment = 0;
          this.lastDrawParameters.maxValueFormat.LineAlignment = 1;
        }
        break;
    }
    this.lastDrawParameters.outerRadius = outerRadius;
    this.lastDrawParameters.innerRadius = innerRadius;
    this.lastDrawParameters.angleStart = angleStart;
    this.lastDrawParameters.angleEnd = angleEnd;
    this.lastDrawParameters.ycenter = ycenter;
    this.lastDrawParameters.xcenter = xcenter;
    this.lastDrawParameters.valueRectangle = ValueRectangle;
    this.lastDrawParameters.valueFormat = valueFormat;
    return this.lastDrawParameters;
  }
  Render(g, w, h) {
    this.mainViewPort = new ViewPortSettings();
    g.SmoothingMode = YSmoothingMode.HighQuality;
    g.TextRenderingHint = YTextRenderingHint.AntiAlias;
    this.drawAnnotationPanels(g, this._annotationPanels, w, h, false, this.mainViewPort);
    let p = this.ComputeDrawParameters(g, w, h, this.mainViewPort);
    if (this._path == null) {
      let outterlength = 2 * p.outerRadius * Math.PI * (p.angleEnd - p.angleStart) / (2 * Math.PI);
      let stepCount = outterlength / this.SegmentMaxLength >> 0;
      let stepsize = (p.angleEnd - p.angleStart) / stepCount;
      this._path = new Array(2 * (stepCount + 1));
      let n = 0;
      for (let i = 0; i <= stepCount; i++) {
        let a = p.angleStart + i * stepsize;
        this._path[n++] = new PointF(p.xcenter + p.outerRadius * Math.cos(a), p.ycenter - p.outerRadius * Math.sin(a));
      }
      for (let i = stepCount; i >= 0; i--) {
        let a = p.angleStart + i * stepsize;
        this._path[n++] = new PointF(p.xcenter + p.innerRadius * Math.cos(a), p.ycenter - p.innerRadius * Math.sin(a));
      }
    }
    if (this._bgBrush == null) {
      this._bgBrush = new YLinearGradientBrush(this._backgroundColor1, this._backgroundColor2);
    }
    if (this._borderpen == null) {
      this._borderpen = new YPen(this._borderColor, this._borderThickness);
      this._borderpen.linejoin = YPen.LineJoin.Round;
    }
    g.FillPolygon(this._bgBrush, this._path);
    if (this._shownValue != this._value) {
      let step = this._maxSpeed * (this._max - this._min) / 100;
      if (Math.abs(this._value - this._shownValue) < step) {
        this._shownValue = this._value;
      } else if (this._shownValue < this._value) {
        this._shownValue += step;
      } else {
        this._shownValue -= step;
      }
    }
    let v = this._shownValue;
    if (v >= this._min) {
      if (v > this._max)
        v = this._max;
      let valueFactor = (v - this._min) / (this._max - this.min);
      let angleValue = p.angleStart + (p.angleEnd - p.angleStart) * valueFactor;
      let outterlength = 2 * p.outerRadius * Math.PI * (angleValue - p.angleStart) / (2 * Math.PI);
      let stepCount = outterlength / this.SegmentMaxLength >> 0;
      let stepsize = (angleValue - p.angleStart) / stepCount;
      let pt = new Array(2 * (stepCount + 1));
      let n = 0;
      for (let i = 0; i <= stepCount; i++) {
        let a = p.angleEnd - i * stepsize;
        pt[n++] = new PointF(p.xcenter + p.outerRadius * Math.cos(a), p.ycenter - p.outerRadius * Math.sin(a));
      }
      for (let i = stepCount; i >= 0; i--) {
        let a = p.angleEnd - i * stepsize;
        pt[n++] = new PointF(p.xcenter + p.innerRadius * Math.cos(a), p.ycenter - p.innerRadius * Math.sin(a));
      }
      let b;
      if (this._color1 == this._color2) {
        b = new YSolidBrush(this._color1);
      } else {
        let A1 = this._color1.alpha;
        let H1 = this._color1.hue;
        let S1 = this._color1.saturation;
        let L1 = this._color1.luminosity;
        let A2 = this._color2.alpha;
        let H2 = this._color2.hue;
        let S2 = this._color2.saturation;
        let L2 = this._color2.luminosity;
        let A = Math.round(A1 + (A2 - A1) * valueFactor) >> 0 & 255;
        let H;
        if (Math.abs(H2 - H1) <= 127) {
          H = H1 + (H2 - H1) * valueFactor >> 0;
        } else {
          H = H1 + 256 + (H2 - H1 + 256) * valueFactor >> 0;
          if (H > 256)
            H -= 256;
        }
        let S = S1 + (S2 - S1) * valueFactor >> 0;
        let L = L1 + (L2 - L1) * valueFactor >> 0;
        b = new YSolidBrush(new YColor(true, A, H, S, L));
      }
      g.FillPolygon(b, pt);
    }
    if (this._borderThickness > 0)
      g.DrawPolygon(this._borderpen, this._path);
    g.DrawStringRect(this.lastDrawParameters.value, this._font, this._font.brush, p.valueRectangle, p.valueFormat);
    if (this._showMinMax) {
      g.DrawStringRect(this.lastDrawParameters.minValue, this._minMaxFont, this._minMaxFont.brush, this.lastDrawParameters.minValueRectangle, this.lastDrawParameters.minValueFormat);
      g.DrawStringRect(this.lastDrawParameters.maxValue, this._minMaxFont, this._minMaxFont.brush, this.lastDrawParameters.maxValueRectangle, this.lastDrawParameters.maxValueFormat);
    }
    this.drawAnnotationPanels(g, this._annotationPanels, w, h, true, this.mainViewPort);
    this.DrawMessagePanels(g, w, h);
    return 0;
  }
  renderingPostProcessing() {
    if (this._shownValue != this._value)
      this.redraw();
  }
};
(function(YSolidGauge2) {
  class DisplayModeEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, DisplayMode);
    }
  }
  YSolidGauge2.DisplayModeEnumItem = DisplayModeEnumItem;
  class DisplayMode extends YEnum {
  }
  DisplayMode.DISPLAY90 = new DisplayModeEnumItem("DISPLAY90", "90\xB0");
  DisplayMode.DISPLAY180 = new DisplayModeEnumItem("DISPLAY180", "180\xB0");
  DisplayMode.DISPLAY270 = new DisplayModeEnumItem("DISPLAY270", "270\xB0");
  DisplayMode.DISPLAY360 = new DisplayModeEnumItem("DISPLAY360", "360\xB0");
  YSolidGauge2.DisplayMode = DisplayMode;
})(YSolidGauge || (YSolidGauge = {}));

// obj/full/Api/yocto_api.js
var YAPI_SUCCESS = 0;
var YAPI_INVALID_ARGUMENT = -2;
var YAPI_NOT_SUPPORTED = -3;
var YAPI_DEVICE_NOT_FOUND = -4;
var YAPI_VERSION_MISMATCH = -5;
var YAPI_DEVICE_BUSY = -6;
var YAPI_TIMEOUT = -7;
var YAPI_IO_ERROR = -8;
var YAPI_UNAUTHORIZED = -12;
var YAPI_SSL_UNK_CERT = -20;
var YAPI_INVALID_INT = 2147483647;
var YAPI_INVALID_UINT = -1;
var YAPI_INVALID_LONG = 9223372036854776e3;
var YAPI_INVALID_DOUBLE = -Number.MAX_VALUE;
var YAPI_INVALID_STRING = "!INVALID!";
var YAPI_MIN_DOUBLE = -Number.MAX_VALUE;
var YAPI_MAX_DOUBLE = Number.MAX_VALUE;
var Y_FUNCTIONDESCRIPTOR_INVALID = YAPI_INVALID_STRING;
var Y_DETECT_NONE = 0;
var Y_DETECT_USB = 1;
var Y_DETECT_NET = 2;
var Y_DETECT_ALL = Y_DETECT_USB | Y_DETECT_NET;
var DEFAULT_DEVICE_LIST_VALIDITY_MS = 1e4;
var DEFAULT_NETWORK_TIMEOUT_MS = 2e4;
var YOCTO_CALIB_TYPE_OFS = 30;
var NOTIFY_NETPKT_CONFCHGYDX = "s";
var NOTIFY_NETPKT_FLUSHV2YDX = "t";
var NOTIFY_NETPKT_FUNCV2YDX = "u";
var NOTIFY_NETPKT_TIMEV2YDX = "v";
var NOTIFY_NETPKT_DEVLOGYDX = "w";
var NOTIFY_NETPKT_TIMEVALYDX = "x";
var NOTIFY_NETPKT_FUNCVALYDX = "y";
var NOTIFY_NETPKT_TIMEAVGYDX = "z";
var NOTIFY_NETPKT_STOP = 10;
var NOTIFY_V2_6RAWBYTES = 1;
var NOTIFY_V2_TYPEDDATA = 2;
var PUBVAL_LEGACY = 0;
var PUBVAL_1RAWBYTE = 1;
var PUBVAL_2RAWBYTES = 2;
var PUBVAL_3RAWBYTES = 3;
var PUBVAL_4RAWBYTES = 4;
var PUBVAL_5RAWBYTES = 5;
var PUBVAL_6RAWBYTES = 6;
var PUBVAL_C_LONG = 7;
var PUBVAL_C_FLOAT = 8;
var PUBVAL_YOCTO_FLOAT_E3 = 9;
var YOCTO_PUBVAL_SIZE = 6;
var YOCTO_HASH_BUF_SIZE = 28;
var YOCTO_BASETYPE_FUNCTION = 0;
var YOCTO_BASETYPE_SENSOR = 1;
var Y_BASETYPES = {
  Function: YOCTO_BASETYPE_FUNCTION,
  Sensor: YOCTO_BASETYPE_SENSOR
};
var YErrorMsg = class {
  constructor(msg = "") {
    this.msg = msg;
  }
};
var YoctoError = class _YoctoError extends Error {
  constructor(...params) {
    super(...params);
    this.errorMsg = this.name;
    this.name = "YoctoError";
    if ("captureStackTrace" in Error) {
      Error.captureStackTrace(this, _YoctoError);
    }
  }
};
var _YY_UrlInfo = class {
  constructor(str_url) {
    this.orgUrl = str_url;
    let proto = "auto";
    let user = "";
    let pass = "";
    let port = 4444;
    let host;
    let dom = "";
    if (str_url.slice(0, 7) == "http://") {
      proto = "http";
      str_url = str_url.slice(7);
    } else if (str_url.slice(0, 5) == "ws://") {
      proto = "ws";
      str_url = str_url.slice(5);
    } else if (str_url.slice(0, 8) == "https://") {
      proto = "https";
      port = 4443;
      str_url = str_url.slice(8);
    } else if (str_url.slice(0, 6) == "wss://") {
      proto = "wss";
      port = 4443;
      str_url = str_url.slice(6);
    } else if (str_url.slice(0, 7) == "auto://") {
      str_url = str_url.slice(7);
    } else if (str_url.slice(0, 9) == "secure://") {
      str_url = str_url.slice(9);
      port = 4443;
      proto = "secure";
    }
    str_url = str_url.replace("/not.byn", "");
    if (str_url[str_url.length - 1] == "/") {
      str_url = str_url.slice(0, str_url.length - 1);
    }
    let pos = str_url.indexOf("/");
    if (pos > 0) {
      dom = str_url.slice(pos);
      str_url = str_url.slice(0, pos);
    }
    let authpos = str_url.indexOf("@");
    if (authpos >= 0) {
      let auth = str_url.slice(0, authpos);
      let passpos = auth.indexOf(":");
      if (passpos >= 0) {
        user = auth.slice(0, passpos);
        pass = auth.slice(passpos + 1);
      } else {
        user = auth;
      }
      str_url = str_url.slice(authpos + 1);
    }
    let endv6 = str_url.indexOf("]");
    pos = str_url.indexOf(":");
    if (pos > 0 && endv6 > 0 && pos < endv6) {
      pos = str_url.indexOf(":", endv6);
    }
    if (pos < 0) {
      host = str_url;
      if (dom != "") {
        if (proto == "http") {
          port = 80;
        } else if (proto == "https") {
          port = 443;
        }
      }
    } else {
      host = str_url.slice(0, pos);
      port = YAPIContext.imm_atoi(str_url.slice(pos + 1));
    }
    if (host == "callback") {
      port = 4444;
    }
    this.proto = proto;
    this.user = user;
    this.pass = pass;
    this.host = host;
    this.port = port;
    this.domain = dom;
  }
  imm_getHost() {
    return this.host;
  }
  imm_getPass() {
    return this.pass;
  }
  imm_getPort() {
    return this.port;
  }
  imm_getUser() {
    return this.user;
  }
  imm_getUrl(withProto = false, withUserPass = true, withEndSlash = false) {
    if (this.proto == "usb") {
      return "usb";
    }
    let url = "";
    if (withProto) {
      url += this.proto + "://";
    }
    if (withUserPass && this.user != "") {
      url += this.user;
      if (this.pass != "") {
        url += ":";
        url += this.pass;
      }
      url += "@";
    }
    url += this.host;
    url += ":";
    url += this.port;
    url += this.domain;
    if (withEndSlash && url[url.length - 1] != "/") {
      url += "/";
    }
    return url;
  }
  imm_getRootUrl() {
    return this.imm_getUrl(true, false, true);
  }
  imm_getProto() {
    return this.proto;
  }
  imm_useWebSocket() {
    return this.proto.startsWith("ws") || this.proto == "auto" || this.proto == "secure";
  }
  /**
   * @return subdomain (starting with a /)
   */
  imm_getSubDomain() {
    let dom = this.domain;
    return dom;
  }
  imm_hasAuthParam() {
    return this.user != "";
  }
  imm_useSecureSocket() {
    return "wss" == this.proto || "https" == this.proto || "secure" == this.proto;
  }
  imm_testInfoJson() {
    return this.proto == "auto" || this.proto == "secure" || this.proto == "http" || this.proto == "https";
  }
  imm_updateBestProto(proto, port) {
    this.port = port;
    if (this.proto != "http" && this.proto != "https") {
      this.proto = proto;
    }
  }
  imm_updateForRedirect(host, port, is_secure) {
    this.host = host;
    this.port = port;
    if (this.imm_useWebSocket()) {
      this.proto = is_secure ? "wss" : "ws";
    } else {
      this.proto = is_secure ? "https" : "http";
    }
  }
  imm_updatePortInfo(proto, port) {
    this.proto = proto;
    this.port = port;
  }
  imm_getOriginalURL() {
    return this.orgUrl;
  }
  imm_updateFrom(urlInfo) {
    this.proto = urlInfo.proto;
    this.user = urlInfo.user;
    this.pass = urlInfo.pass;
    this.host = urlInfo.host;
    this.port = urlInfo.port;
    this.domain = urlInfo.domain;
    this.orgUrl = urlInfo.orgUrl;
  }
};
var Y_MD5Ctx = class {
  constructor() {
    this.buf = new Uint32Array(4);
    this.bits = new Uint32Array(2);
    this.inBuf = new ArrayBuffer(64);
    this.in8 = new Uint8Array(this.inBuf);
    this.in32 = new Uint32Array(this.inBuf);
    this.in32[0] = 1;
    this.bigEndian = this.in8[0] != 1;
    this.buf[0] = 1732584193 >>> 0;
    this.buf[1] = 4023233417 >>> 0;
    this.buf[2] = 2562383102 >>> 0;
    this.buf[3] = 271733878 >>> 0;
    this.bits[0] = 0;
    this.bits[1] = 0;
  }
  _byteReverseIn() {
    for (let i = 0; i < 16; i++) {
      let a = this.in32[i];
      this.in32[i] = (a >>> 24 | (a & 255) << 24 | (a & 16711680) >>> 8 | (a & 65280) << 8) >>> 0;
    }
  }
  _transform() {
    let F1 = ((x, y, z) => (z ^ x & (y ^ z)) >>> 0);
    let F2 = ((x, y, z) => F1(z, x, y));
    let F3 = ((x, y, z) => (x ^ y ^ z) >>> 0);
    let F4 = ((x, y, z) => (y ^ (x | ~z)) >>> 0);
    let MD5STEP = ((f, w, x, y, z, data, s) => {
      w = w + f(x, y, z) + (data >>> 0) >>> 0;
      w = (w << s >>> 0 | w >>> 32 - s) >>> 0;
      return w + x >>> 0;
    });
    let a = this.buf[0];
    let b = this.buf[1];
    let c = this.buf[2];
    let d = this.buf[3];
    let dataIn = this.in32;
    a = MD5STEP(F1, a, b, c, d, dataIn[0] + 3614090360, 7);
    d = MD5STEP(F1, d, a, b, c, dataIn[1] + 3905402710, 12);
    c = MD5STEP(F1, c, d, a, b, dataIn[2] + 606105819, 17);
    b = MD5STEP(F1, b, c, d, a, dataIn[3] + 3250441966, 22);
    a = MD5STEP(F1, a, b, c, d, dataIn[4] + 4118548399, 7);
    d = MD5STEP(F1, d, a, b, c, dataIn[5] + 1200080426, 12);
    c = MD5STEP(F1, c, d, a, b, dataIn[6] + 2821735955, 17);
    b = MD5STEP(F1, b, c, d, a, dataIn[7] + 4249261313, 22);
    a = MD5STEP(F1, a, b, c, d, dataIn[8] + 1770035416, 7);
    d = MD5STEP(F1, d, a, b, c, dataIn[9] + 2336552879, 12);
    c = MD5STEP(F1, c, d, a, b, dataIn[10] + 4294925233, 17);
    b = MD5STEP(F1, b, c, d, a, dataIn[11] + 2304563134, 22);
    a = MD5STEP(F1, a, b, c, d, dataIn[12] + 1804603682, 7);
    d = MD5STEP(F1, d, a, b, c, dataIn[13] + 4254626195, 12);
    c = MD5STEP(F1, c, d, a, b, dataIn[14] + 2792965006, 17);
    b = MD5STEP(F1, b, c, d, a, dataIn[15] + 1236535329, 22);
    a = MD5STEP(F2, a, b, c, d, dataIn[1] + 4129170786, 5);
    d = MD5STEP(F2, d, a, b, c, dataIn[6] + 3225465664, 9);
    c = MD5STEP(F2, c, d, a, b, dataIn[11] + 643717713, 14);
    b = MD5STEP(F2, b, c, d, a, dataIn[0] + 3921069994, 20);
    a = MD5STEP(F2, a, b, c, d, dataIn[5] + 3593408605, 5);
    d = MD5STEP(F2, d, a, b, c, dataIn[10] + 38016083, 9);
    c = MD5STEP(F2, c, d, a, b, dataIn[15] + 3634488961, 14);
    b = MD5STEP(F2, b, c, d, a, dataIn[4] + 3889429448, 20);
    a = MD5STEP(F2, a, b, c, d, dataIn[9] + 568446438, 5);
    d = MD5STEP(F2, d, a, b, c, dataIn[14] + 3275163606, 9);
    c = MD5STEP(F2, c, d, a, b, dataIn[3] + 4107603335, 14);
    b = MD5STEP(F2, b, c, d, a, dataIn[8] + 1163531501, 20);
    a = MD5STEP(F2, a, b, c, d, dataIn[13] + 2850285829, 5);
    d = MD5STEP(F2, d, a, b, c, dataIn[2] + 4243563512, 9);
    c = MD5STEP(F2, c, d, a, b, dataIn[7] + 1735328473, 14);
    b = MD5STEP(F2, b, c, d, a, dataIn[12] + 2368359562, 20);
    a = MD5STEP(F3, a, b, c, d, dataIn[5] + 4294588738, 4);
    d = MD5STEP(F3, d, a, b, c, dataIn[8] + 2272392833, 11);
    c = MD5STEP(F3, c, d, a, b, dataIn[11] + 1839030562, 16);
    b = MD5STEP(F3, b, c, d, a, dataIn[14] + 4259657740, 23);
    a = MD5STEP(F3, a, b, c, d, dataIn[1] + 2763975236, 4);
    d = MD5STEP(F3, d, a, b, c, dataIn[4] + 1272893353, 11);
    c = MD5STEP(F3, c, d, a, b, dataIn[7] + 4139469664, 16);
    b = MD5STEP(F3, b, c, d, a, dataIn[10] + 3200236656, 23);
    a = MD5STEP(F3, a, b, c, d, dataIn[13] + 681279174, 4);
    d = MD5STEP(F3, d, a, b, c, dataIn[0] + 3936430074, 11);
    c = MD5STEP(F3, c, d, a, b, dataIn[3] + 3572445317, 16);
    b = MD5STEP(F3, b, c, d, a, dataIn[6] + 76029189, 23);
    a = MD5STEP(F3, a, b, c, d, dataIn[9] + 3654602809, 4);
    d = MD5STEP(F3, d, a, b, c, dataIn[12] + 3873151461, 11);
    c = MD5STEP(F3, c, d, a, b, dataIn[15] + 530742520, 16);
    b = MD5STEP(F3, b, c, d, a, dataIn[2] + 3299628645, 23);
    a = MD5STEP(F4, a, b, c, d, dataIn[0] + 4096336452, 6);
    d = MD5STEP(F4, d, a, b, c, dataIn[7] + 1126891415, 10);
    c = MD5STEP(F4, c, d, a, b, dataIn[14] + 2878612391, 15);
    b = MD5STEP(F4, b, c, d, a, dataIn[5] + 4237533241, 21);
    a = MD5STEP(F4, a, b, c, d, dataIn[12] + 1700485571, 6);
    d = MD5STEP(F4, d, a, b, c, dataIn[3] + 2399980690, 10);
    c = MD5STEP(F4, c, d, a, b, dataIn[10] + 4293915773, 15);
    b = MD5STEP(F4, b, c, d, a, dataIn[1] + 2240044497, 21);
    a = MD5STEP(F4, a, b, c, d, dataIn[8] + 1873313359, 6);
    d = MD5STEP(F4, d, a, b, c, dataIn[15] + 4264355552, 10);
    c = MD5STEP(F4, c, d, a, b, dataIn[6] + 2734768916, 15);
    b = MD5STEP(F4, b, c, d, a, dataIn[13] + 1309151649, 21);
    a = MD5STEP(F4, a, b, c, d, dataIn[4] + 4149444226, 6);
    d = MD5STEP(F4, d, a, b, c, dataIn[11] + 3174756917, 10);
    c = MD5STEP(F4, c, d, a, b, dataIn[2] + 718787259, 15);
    b = MD5STEP(F4, b, c, d, a, dataIn[9] + 3951481745, 21);
    this.buf[0] = (this.buf[0] + a & 4294967295) >>> 0;
    this.buf[1] = (this.buf[1] + b & 4294967295) >>> 0;
    this.buf[2] = (this.buf[2] + c & 4294967295) >>> 0;
    this.buf[3] = (this.buf[3] + d & 4294967295) >>> 0;
  }
  addData(buf) {
    let len = buf.length;
    let pos = 0;
    let t = this.bits[0];
    this.bits[0] = t + (len << 3) >>> 0;
    if (this.bits[0] < t) {
      this.bits[1]++;
    }
    this.bits[1] += len >>> 29;
    t = t >>> 3 & 63;
    while (pos < len) {
      while (pos < len && t < 64) {
        this.in8[t++] = buf[pos++];
      }
      if (t < 64)
        return;
      if (this.bigEndian)
        this._byteReverseIn();
      this._transform();
      t = 0;
    }
  }
  calculate() {
    let t = this.bits[0] >>> 3 & 63;
    this.in8[t++] = 128;
    if (t > 56) {
      while (t < 64) {
        this.in8[t++] = 0;
      }
      if (this.bigEndian)
        this._byteReverseIn();
      this._transform();
      for (t = 0; t < 14; t++) {
        this.in32[t] = 0;
      }
    } else {
      while (t < 56) {
        this.in8[t++] = 0;
      }
      if (this.bigEndian)
        this._byteReverseIn();
    }
    this.in32[14] = this.bits[0];
    this.in32[15] = this.bits[1];
    this._transform();
    let res = new Uint8Array(16);
    for (t = 0; t < 16; t++) {
      res[t] = this.buf[t >>> 2] >>> 8 * (t & 3) & 255;
    }
    return res;
  }
};
var YFunctionType = class {
  constructor(yapi, classname) {
    this._yapi = yapi;
    this._className = classname;
    this._connectedFns = {};
    this._requestedFns = {};
    this._hwIdByName = {};
    this._nameByHwId = {};
    this._valueByHwId = {};
    this._baseType = 0;
  }
  /** Index a single function given by HardwareId and logical name; store any advertised value
   *
   * @returns true iff there was a logical name discrepancy
   */
  imm_reindexFunction(str_hwid, str_name, str_val, int_basetype) {
    let currname = this._nameByHwId[str_hwid];
    let res = false;
    if (currname == void 0 || currname == "") {
      if (str_name != "") {
        this._nameByHwId[str_hwid] = str_name;
        res = true;
      }
    } else if (currname != str_name) {
      if (this._hwIdByName[currname] == str_hwid) {
        delete this._hwIdByName[currname];
      }
      if (str_name != "") {
        this._nameByHwId[str_hwid] = str_name;
      } else {
        delete this._nameByHwId[str_hwid];
      }
      res = true;
    }
    if (str_name != "") {
      this._hwIdByName[str_name] = str_hwid;
    }
    if (str_val) {
      this._valueByHwId[str_hwid] = str_val;
    } else {
      if (this._valueByHwId[str_hwid] == void 0) {
        this._valueByHwId[str_hwid] = "";
      }
    }
    if (int_basetype) {
      if (this._baseType == 0) {
        this._baseType = int_basetype;
      }
    }
    return res;
  }
  /** Forget a disconnected function given by HardwareId
   */
  imm_forgetFunction(str_hwid) {
    let currname = this._nameByHwId[str_hwid];
    if (currname != void 0) {
      if (currname != "" && this._hwIdByName[currname] == str_hwid) {
        delete this._hwIdByName[currname];
      }
      delete this._nameByHwId[str_hwid];
    }
    if (this._valueByHwId[str_hwid] != void 0) {
      delete this._valueByHwId[str_hwid];
    }
    let con_fn = this._connectedFns[str_hwid];
    if (con_fn) {
      this._requestedFns[str_hwid] = con_fn;
      delete this._connectedFns[str_hwid];
    }
  }
  /** Find the exact Hardware Id of the specified function, if currently connected
   * If device is not known as connected, return a clean error
   * This function will not cause any network access
   */
  imm_resolve(str_func) {
    let res;
    let dotpos = str_func.indexOf(".");
    if (dotpos < 0) {
      res = this._hwIdByName[str_func];
      if (res != void 0) {
        return {
          errorType: YAPI_SUCCESS,
          errorMsg: "no error",
          result: String(res)
        };
      }
      dotpos = str_func.length;
      str_func += "." + this._className.substr(0, 1).toLowerCase() + this._className.substr(1);
    }
    if (this._valueByHwId[str_func] != void 0) {
      return {
        errorType: YAPI_SUCCESS,
        errorMsg: "no error",
        result: String(str_func)
      };
    }
    let serial = "";
    let funcid;
    if (dotpos > 0) {
      let devid = str_func.substr(0, dotpos);
      funcid = str_func.substr(dotpos + 1);
      let dev = this._yapi.imm_getDevice(devid);
      if (!dev) {
        return {
          errorType: YAPI_DEVICE_NOT_FOUND,
          errorMsg: "Device [" + devid + "] not online",
          result: ""
        };
      }
      serial = dev.imm_getSerialNumber();
      res = serial + "." + funcid;
      if (this._valueByHwId[res] != void 0) {
        return {
          errorType: YAPI_SUCCESS,
          errorMsg: "no error",
          result: String(res)
        };
      }
      let i, nfun = dev.imm_functionCount();
      for (i = 0; i < nfun; i++) {
        res = serial + "." + dev.imm_functionId(i);
        let name = this._nameByHwId[res];
        if (name != void 0 && name == funcid) {
          return {
            errorType: YAPI_SUCCESS,
            errorMsg: "no error",
            result: String(res)
          };
        }
      }
    } else {
      funcid = str_func.substr(1);
      for (let hwid_str in this._connectedFns) {
        let pos = hwid_str.indexOf(".");
        let str_function = hwid_str.substr(pos + 1);
        if (str_function == funcid) {
          return {
            errorType: YAPI_SUCCESS,
            errorMsg: "no error",
            result: String(hwid_str)
          };
        }
      }
    }
    return {
      errorType: YAPI_DEVICE_NOT_FOUND,
      errorMsg: "No function [" + funcid + "] found on device [" + serial + "]",
      result: ""
    };
  }
  /** Find the friendly name (use logical name if available) of the specified function, if currently connected
   * If device is not known as connected, return a clean error
   * This function will not cause any network access
   */
  imm_getFriendlyName(str_func) {
    let resolved = this.imm_resolve(str_func);
    let name;
    if (resolved.errorType != YAPI_SUCCESS) {
      return resolved;
    }
    let hwId = resolved.result;
    if (this._className == "Module") {
      let friend = hwId;
      name = this._nameByHwId[friend];
      if (name != void 0 && name != "") {
        friend = this._nameByHwId[friend];
      }
      return {
        errorType: YAPI_SUCCESS,
        errorMsg: "no error",
        result: String(friend)
      };
    } else {
      let pos = hwId.indexOf(".");
      let str_serialMod = hwId.substr(0, pos);
      let str_friendModFull = this._yapi.imm_getFriendlyNameFunction("Module", str_serialMod).result;
      let int_friendModDot = str_friendModFull.indexOf(".");
      let str_friendMod = int_friendModDot > 0 ? str_friendModFull.substr(0, int_friendModDot) : str_friendModFull;
      let str_friendFunc = hwId.substr(pos + 1);
      name = this._nameByHwId[hwId];
      if (name != void 0 && name != "") {
        str_friendFunc = name;
      }
      return {
        errorType: YAPI_SUCCESS,
        errorMsg: "no error",
        result: String(str_friendMod + "." + str_friendFunc)
      };
    }
  }
  /** Associates a given function object to a function id
   */
  imm_setFunction(str_func, obj_func) {
    let funres = this.imm_resolve(str_func);
    if (funres.result) {
      this._connectedFns[funres.result] = obj_func;
    } else {
      this._requestedFns[str_func] = obj_func;
    }
  }
  /** Retrieve a function object by hardware id, updating the indexes on the fly if needed
   */
  imm_getFunction(str_func) {
    let funres = this.imm_resolve(str_func);
    if (funres.errorType == YAPI_SUCCESS) {
      let conn_fn = this._connectedFns[funres.result];
      if (conn_fn != void 0) {
        return conn_fn;
      }
      let req_fn = this._requestedFns[str_func];
      if (req_fn != void 0) {
        this._connectedFns[funres.result] = req_fn;
        delete this._requestedFns[str_func];
      }
      return req_fn;
    } else {
      return this._requestedFns[str_func];
    }
  }
  /** Stores a function advertised value by hardware id, and tell if an event should be queued for it
   */
  imm_setFunctionValue(str_hwid, str_pubval) {
    let currval = this._valueByHwId[str_hwid];
    if (!(currval == void 0) && currval == str_pubval) {
      return false;
    }
    this._valueByHwId[str_hwid] = str_pubval;
    return true;
  }
  /** Retrieve a function advertised value by hardware id
   */
  imm_getFunctionValue(str_hwid) {
    return this._valueByHwId[str_hwid];
  }
  /** Return the basetype of this function class
   */
  imm_getBaseType() {
    return this._baseType;
  }
  /** Test if function type is compatible with basetype
   */
  imm_matchBaseType(baseclass) {
    return baseclass == YOCTO_BASETYPE_FUNCTION || baseclass == this._baseType;
  }
  /** Find the hardwareId of the first instance of a given function class
   */
  imm_getFirstHardwareId() {
    let res = null;
    for (res in this._valueByHwId) {
      break;
    }
    return res;
  }
  /** Find the hardwareId for the next instance of a given function class
   */
  imm_getNextHardwareId(str_hwid) {
    for (let iter_hwid in this._valueByHwId) {
      if (str_hwid == "!") {
        return iter_hwid;
      }
      if (str_hwid == iter_hwid) {
        str_hwid = "!";
      }
    }
    return null;
  }
};
var YHTTPBody = class {
  /** Object storing a file to upload
   */
  constructor(str_fname, bin_data, fun_progressCb) {
    this.fname = str_fname;
    this.data = bin_data;
    this.progressCb = fun_progressCb;
  }
};
var YHTTPRequest = class {
  /** Object storing the result of any HTTP Query, with status code and error message
   */
  constructor(bin_res, int_errType = YAPI_SUCCESS, str_errMsg = "no error") {
    this.devUrl = null;
    this.obj_result = null;
    this.asyncId = 0;
    this.acceptor = null;
    this.toBeSent = null;
    this.sendPos = 0;
    this.progressCb = null;
    this.timeoutId = null;
    this.sendTimeoutId = null;
    this.next = null;
    this._creat = "";
    this._sent = "";
    this.bin_result = bin_res;
    this.errorType = int_errType;
    this.errorMsg = str_errMsg;
  }
};
var YFuncRequest = class {
  /* Object storing the result of a function request, with status code and error message */
  constructor(obj_res, int_errType = YAPI_SUCCESS, str_errMsg = "no error") {
    this.errorType = int_errType;
    this.errorMsg = str_errMsg;
    this.obj_result = obj_res;
  }
};
var YDataStream = class _YDataStream {
  // API symbols as static members
  //--- (end of generated code: YDataStream attributes declaration)
  constructor(obj_parent, obj_dataset, encoded) {
    this._cal = null;
    this._runNo = 0;
    this._utcStamp = 0;
    this._nCols = 0;
    this._nRows = 0;
    this._startTime = 0;
    this._duration = 0;
    this._dataSamplesInterval = 0;
    this._firstMeasureDuration = 0;
    this._columnNames = [];
    this._functionId = "";
    this._isClosed = false;
    this._isAvg = false;
    this._minVal = 0;
    this._avgVal = 0;
    this._maxVal = 0;
    this._values = [];
    this._isLoaded = false;
    this.DATA_INVALID = YAPI_INVALID_DOUBLE;
    this.DURATION_INVALID = YAPI_INVALID_DOUBLE;
    this._parent = obj_parent;
    this._yapi = this._parent._yapi;
    if (typeof obj_dataset != "undefined") {
      this.imm_initFromDataSet(obj_dataset, encoded);
    }
  }
  //--- (generated code: YDataStream implementation)
  _parseCalibArr(iCalib) {
    let caltyp;
    let calhdl;
    let maxpos;
    let position;
    let calpar = [];
    let calraw = [];
    let calref = [];
    let fRaw;
    let fRef;
    caltyp = iCalib[0] / 1e3 >> 0;
    if (caltyp < YOCTO_CALIB_TYPE_OFS) {
      this._cal = null;
      return YAPI_SUCCESS;
    }
    calhdl = this._yapi.imm_getCalibrationHandler(caltyp);
    if (!(calhdl != null)) {
      this._cal = null;
      return YAPI_SUCCESS;
    }
    maxpos = iCalib.length;
    calpar.length = 0;
    position = 1;
    while (position < maxpos) {
      calpar.push(iCalib[position]);
      position = position + 1;
    }
    calraw.length = 0;
    calref.length = 0;
    position = 1;
    while (position + 1 < maxpos) {
      fRaw = iCalib[position];
      fRaw = fRaw / 1e3;
      fRef = iCalib[position + 1];
      fRef = fRef / 1e3;
      calraw.push(fRaw);
      calref.push(fRef);
      position = position + 2;
    }
    this._cal = { src: "", hdl: calhdl, typ: caltyp, par: calpar, raw: calraw, cal: calref };
    return YAPI_SUCCESS;
  }
  imm_initFromDataSet(dataset, encoded) {
    let val;
    let ms_offset;
    let samplesPerHour;
    let caltyp;
    let iCalib = [];
    this._runNo = encoded[0] + (encoded[1] << 16);
    this._utcStamp = encoded[2] + (encoded[3] << 16);
    val = encoded[4];
    this._isAvg = (val & 256) == 0;
    samplesPerHour = val & 255;
    if ((val & 256) != 0) {
      samplesPerHour = samplesPerHour * 3600;
    } else {
      if ((val & 512) != 0) {
        samplesPerHour = samplesPerHour * 60;
      }
    }
    this._dataSamplesInterval = 3600 / samplesPerHour;
    ms_offset = encoded[6];
    if (ms_offset < 1e3) {
      this._startTime = this._utcStamp + ms_offset / 1e3;
    } else {
      this._startTime = this._utcStamp - this._dataSamplesInterval;
    }
    this._firstMeasureDuration = encoded[5];
    if (!this._isAvg) {
      this._firstMeasureDuration = this._firstMeasureDuration / 1e3;
    }
    val = encoded[7];
    this._isClosed = val != 65535;
    if (val == 65535) {
      val = 0;
    }
    this._nRows = val;
    if (this._nRows > 0) {
      if (this._firstMeasureDuration > 0) {
        this._duration = this._firstMeasureDuration + (this._nRows - 1) * this._dataSamplesInterval;
      } else {
        this._duration = this._nRows * this._dataSamplesInterval;
      }
    } else {
      this._duration = 0;
    }
    iCalib = dataset.imm_get_calibration();
    caltyp = iCalib[0];
    if (caltyp == 0) {
      this._cal = null;
    } else {
      this._parseCalibArr(iCalib);
    }
    this._functionId = dataset.imm_get_functionId();
    if (this._isAvg) {
      this._columnNames.length = 0;
      this._columnNames.push(this._functionId + "_min");
      this._columnNames.push(this._functionId + "_avg");
      this._columnNames.push(this._functionId + "_max");
      this._nCols = 3;
    } else {
      this._columnNames.length = 0;
      this._columnNames.push(this._functionId);
      this._nCols = 1;
    }
    if (this._nRows > 0) {
      this._avgVal = this.imm_decodeAvg(encoded[8] + ((encoded[9] ^ 32768) << 16), 1);
      this._minVal = this.imm_decodeVal(encoded[10] + (encoded[11] << 16));
      this._maxVal = this.imm_decodeVal(encoded[12] + (encoded[13] << 16));
    }
    return 0;
  }
  imm_parseStream(sdata) {
    let idx;
    let udat = [];
    let dat = [];
    if (this._isLoaded && !this._isClosed) {
      return YAPI_SUCCESS;
    }
    if (sdata.length == 0) {
      this._nRows = 0;
      return YAPI_SUCCESS;
    }
    udat = this._yapi.imm_decodeWords(this._parent.imm_json_get_string(sdata));
    this._values.length = 0;
    idx = 0;
    if (this._isAvg) {
      while (idx + 3 < udat.length) {
        dat.length = 0;
        if (udat[idx] == 65535 && udat[idx + 1] == 65535) {
          dat.push(NaN);
          dat.push(NaN);
          dat.push(NaN);
        } else {
          dat.push(this.imm_decodeVal(udat[idx + 2] + (udat[idx + 3] << 16)));
          dat.push(this.imm_decodeAvg(udat[idx] + ((udat[idx + 1] ^ 32768) << 16), 1));
          dat.push(this.imm_decodeVal(udat[idx + 4] + (udat[idx + 5] << 16)));
        }
        idx = idx + 6;
        this._values.push(dat.slice());
      }
    } else {
      while (idx + 1 < udat.length) {
        dat.length = 0;
        if (udat[idx] == 65535 && udat[idx + 1] == 65535) {
          dat.push(NaN);
        } else {
          dat.push(this.imm_decodeAvg(udat[idx] + ((udat[idx + 1] ^ 32768) << 16), 1));
        }
        this._values.push(dat.slice());
        idx = idx + 2;
      }
    }
    this._nRows = this._values.length;
    this._isLoaded = true;
    return YAPI_SUCCESS;
  }
  imm_wasLoaded() {
    return this._isLoaded;
  }
  imm_get_url() {
    let url;
    url = "logger.json?id=" + this._functionId + "&run=" + String(Math.round(this._runNo)) + "&utc=" + String(Math.round(this._utcStamp));
    return url;
  }
  imm_get_baseurl() {
    let url;
    url = "logger.json?id=" + this._functionId + "&run=" + String(Math.round(this._runNo)) + "&utc=";
    return url;
  }
  imm_get_urlsuffix() {
    let url;
    url = String(Math.round(this._utcStamp));
    return url;
  }
  async loadStream() {
    return this.imm_parseStream(await this._parent._download(this.imm_get_url()));
  }
  imm_decodeVal(w) {
    let val;
    val = w / 1e3;
    if (!(this._cal == null)) {
      val = this._cal.hdl(val, this._cal.typ, this._cal.par, this._cal.raw, this._cal.cal);
    }
    return val;
  }
  imm_decodeAvg(dw, count) {
    let val;
    val = dw / 1e3;
    if (!(this._cal == null)) {
      val = this._cal.hdl(val, this._cal.typ, this._cal.par, this._cal.raw, this._cal.cal);
    }
    return val;
  }
  async isClosed() {
    return this._isClosed;
  }
  /**
   * Returns the run index of the data stream. A run can be made of
   * multiple datastreams, for different time intervals.
   *
   * @return an unsigned number corresponding to the run index.
   */
  async get_runIndex() {
    return this._runNo;
  }
  /**
   * Returns the relative start time of the data stream, measured in seconds.
   * For recent firmwares, the value is relative to the present time,
   * which means the value is always negative.
   * If the device uses a firmware older than version 13000, value is
   * relative to the start of the time the device was powered on, and
   * is always positive.
   * If you need an absolute UTC timestamp, use get_realStartTimeUTC().
   *
   * <b>DEPRECATED</b>: This method has been replaced by get_realStartTimeUTC().
   *
   * @return an unsigned number corresponding to the number of seconds
   *         between the start of the run and the beginning of this data
   *         stream.
   */
  async get_startTime() {
    return this._utcStamp - (Date.now() / 1e3 >> 0);
  }
  /**
   * Returns the start time of the data stream, relative to the Jan 1, 1970.
   * If the UTC time was not set in the datalogger at the time of the recording
   * of this data stream, this method returns 0.
   *
   * <b>DEPRECATED</b>: This method has been replaced by get_realStartTimeUTC().
   *
   * @return an unsigned number corresponding to the number of seconds
   *         between the Jan 1, 1970 and the beginning of this data
   *         stream (i.e. Unix time representation of the absolute time).
   */
  async get_startTimeUTC() {
    return Math.round(this._startTime);
  }
  /**
   * Returns the start time of the data stream, relative to the Jan 1, 1970.
   * If the UTC time was not set in the datalogger at the time of the recording
   * of this data stream, this method returns 0.
   *
   * @return a floating-point number  corresponding to the number of seconds
   *         between the Jan 1, 1970 and the beginning of this data
   *         stream (i.e. Unix time representation of the absolute time).
   */
  async get_realStartTimeUTC() {
    return this._startTime;
  }
  /**
   * Returns the number of milliseconds between two consecutive
   * rows of this data stream. By default, the data logger records one row
   * per second, but the recording frequency can be changed for
   * each device function
   *
   * @return an unsigned number corresponding to a number of milliseconds.
   */
  async get_dataSamplesIntervalMs() {
    return Math.round(this._dataSamplesInterval * 1e3);
  }
  async get_dataSamplesInterval() {
    return this._dataSamplesInterval;
  }
  async get_firstDataSamplesInterval() {
    return this._firstMeasureDuration;
  }
  /**
   * Returns the number of data rows present in this stream.
   *
   * If the device uses a firmware older than version 13000,
   * this method fetches the whole data stream from the device
   * if not yet done, which can cause a little delay.
   *
   * @return an unsigned number corresponding to the number of rows.
   *
   * On failure, throws an exception or returns zero.
   */
  async get_rowCount() {
    if (this._nRows != 0 && this._isClosed) {
      return this._nRows;
    }
    await this.loadStream();
    return this._nRows;
  }
  /**
   * Returns the number of data columns present in this stream.
   * The meaning of the values present in each column can be obtained
   * using the method get_columnNames().
   *
   * If the device uses a firmware older than version 13000,
   * this method fetches the whole data stream from the device
   * if not yet done, which can cause a little delay.
   *
   * @return an unsigned number corresponding to the number of columns.
   *
   * On failure, throws an exception or returns zero.
   */
  async get_columnCount() {
    if (this._nCols != 0) {
      return this._nCols;
    }
    await this.loadStream();
    return this._nCols;
  }
  /**
   * Returns the title (or meaning) of each data column present in this stream.
   * In most case, the title of the data column is the hardware identifier
   * of the sensor that produced the data. For streams recorded at a lower
   * recording rate, the dataLogger stores the min, average and max value
   * during each measure interval into three columns with suffixes _min,
   * _avg and _max respectively.
   *
   * If the device uses a firmware older than version 13000,
   * this method fetches the whole data stream from the device
   * if not yet done, which can cause a little delay.
   *
   * @return a list containing as many strings as there are columns in the
   *         data stream.
   *
   * On failure, throws an exception or returns an empty array.
   */
  async get_columnNames() {
    if (this._columnNames.length != 0) {
      return this._columnNames;
    }
    await this.loadStream();
    return this._columnNames;
  }
  /**
   * Returns the smallest measure observed within this stream.
   * If the device uses a firmware older than version 13000,
   * this method will always return YDataStream.DATA_INVALID.
   *
   * @return a floating-point number corresponding to the smallest value,
   *         or YDataStream.DATA_INVALID if the stream is not yet complete (still recording).
   *
   * On failure, throws an exception or returns YDataStream.DATA_INVALID.
   */
  async get_minValue() {
    return this._minVal;
  }
  /**
   * Returns the average of all measures observed within this stream.
   * If the device uses a firmware older than version 13000,
   * this method will always return YDataStream.DATA_INVALID.
   *
   * @return a floating-point number corresponding to the average value,
   *         or YDataStream.DATA_INVALID if the stream is not yet complete (still recording).
   *
   * On failure, throws an exception or returns YDataStream.DATA_INVALID.
   */
  async get_averageValue() {
    return this._avgVal;
  }
  /**
   * Returns the largest measure observed within this stream.
   * If the device uses a firmware older than version 13000,
   * this method will always return YDataStream.DATA_INVALID.
   *
   * @return a floating-point number corresponding to the largest value,
   *         or YDataStream.DATA_INVALID if the stream is not yet complete (still recording).
   *
   * On failure, throws an exception or returns YDataStream.DATA_INVALID.
   */
  async get_maxValue() {
    return this._maxVal;
  }
  async get_realDuration() {
    if (this._isClosed) {
      return this._duration;
    }
    return (Date.now() / 1e3 >> 0) - this._utcStamp;
  }
  /**
   * Returns the whole data set contained in the stream, as a bidimensional
   * table of numbers.
   * The meaning of the values present in each column can be obtained
   * using the method get_columnNames().
   *
   * This method fetches the whole data stream from the device,
   * if not yet done.
   *
   * @return a list containing as many elements as there are rows in the
   *         data stream. Each row itself is a list of floating-point
   *         numbers.
   *
   * On failure, throws an exception or returns an empty array.
   */
  async get_dataRows() {
    if (this._values.length == 0 || !this._isClosed) {
      await this.loadStream();
    }
    return this._values;
  }
  /**
   * Returns a single measure from the data stream, specified by its
   * row and column index.
   * The meaning of the values present in each column can be obtained
   * using the method get_columnNames().
   *
   * This method fetches the whole data stream from the device,
   * if not yet done.
   *
   * @param row : row index
   * @param col : column index
   *
   * @return a floating-point number
   *
   * On failure, throws an exception or returns YDataStream.DATA_INVALID.
   */
  async get_data(row, col) {
    if (this._values.length == 0 || !this._isClosed) {
      await this.loadStream();
    }
    if (row >= this._values.length) {
      return _YDataStream.DATA_INVALID;
    }
    if (col >= this._values[row].length) {
      return _YDataStream.DATA_INVALID;
    }
    return this._values[row][col];
  }
};
YDataStream.DATA_INVALID = YAPI_INVALID_DOUBLE;
YDataStream.DURATION_INVALID = YAPI_INVALID_DOUBLE;
var YDataSet = class {
  // API symbols as static members
  //--- (end of generated code: YDataSet attributes declaration)
  constructor(obj_parent, str_functionId = "", str_unit = "", double_startTime = 0, double_endTime = 0) {
    this._hardwareId = "";
    this._functionId = "";
    this._unit = "";
    this._bulkLoad = 0;
    this._startTimeMs = 0;
    this._endTimeMs = 0;
    this._progress = 0;
    this._calib = [];
    this._streams = [];
    this._preview = [];
    this._measures = [];
    this._summaryMinVal = 0;
    this._summaryMaxVal = 0;
    this._summaryTotalAvg = 0;
    this._summaryTotalTime = 0;
    this.DATA_INVALID = YAPI_INVALID_DOUBLE;
    this.DURATION_INVALID = YAPI_INVALID_DOUBLE;
    this.HARDWAREID_INVALID = YAPI_INVALID_STRING;
    this.FUNCTIONID_INVALID = YAPI_INVALID_STRING;
    this.UNIT_INVALID = YAPI_INVALID_STRING;
    this._summary = new YMeasure(0, 0, 0, 0, 0);
    if (str_functionId == "") {
      this._parent = obj_parent;
      this._yapi = obj_parent._yapi;
      this._startTimeMs = 0;
      this._endTimeMs = 0;
    } else {
      this._parent = obj_parent;
      this._yapi = obj_parent._yapi;
      this._functionId = str_functionId;
      this._unit = str_unit;
      this._startTimeMs = double_startTime * 1e3;
      this._endTimeMs = double_endTime * 1e3;
      this._progress = -1;
    }
  }
  imm_get_functionId() {
    return this._functionId;
  }
  //--- (generated code: YDataSet implementation)
  imm_get_calibration() {
    return this._calib;
  }
  async loadSummary(data) {
    let dataRows = [];
    let tim;
    let mitv;
    let itv;
    let fitv;
    let end_;
    let nCols;
    let minCol;
    let avgCol;
    let maxCol;
    let res;
    let m_pos;
    let previewTotalTime;
    let previewTotalAvg;
    let previewMinVal;
    let previewMaxVal;
    let previewAvgVal;
    let previewStartMs;
    let previewStopMs;
    let previewDuration;
    let streamStartTimeMs;
    let streamDuration;
    let streamEndTimeMs;
    let minVal;
    let avgVal;
    let maxVal;
    let summaryStartMs;
    let summaryStopMs;
    let summaryTotalTime;
    let summaryTotalAvg;
    let summaryMinVal;
    let summaryMaxVal;
    let url;
    let strdata;
    let measure_data = [];
    if (this._progress < 0) {
      strdata = this._yapi.imm_bin2str(data);
      if (strdata == "{}") {
        this._parent._throw(YAPI_VERSION_MISMATCH, "device firmware is too old");
        return YAPI_VERSION_MISMATCH;
      }
      res = await this._parse(strdata);
      if (res < 0) {
        return res;
      }
    }
    summaryTotalTime = 0;
    summaryTotalAvg = 0;
    summaryMinVal = YAPI_MAX_DOUBLE;
    summaryMaxVal = YAPI_MIN_DOUBLE;
    summaryStartMs = YAPI_MAX_DOUBLE;
    summaryStopMs = YAPI_MIN_DOUBLE;
    for (let ii_0 of this._streams) {
      streamStartTimeMs = Math.round(await ii_0.get_realStartTimeUTC() * 1e3);
      streamDuration = await ii_0.get_realDuration();
      streamEndTimeMs = streamStartTimeMs + Math.round(streamDuration * 1e3);
      if (streamStartTimeMs >= this._startTimeMs && (this._endTimeMs == 0 || streamEndTimeMs <= this._endTimeMs)) {
        previewMinVal = await ii_0.get_minValue();
        previewAvgVal = await ii_0.get_averageValue();
        previewMaxVal = await ii_0.get_maxValue();
        previewStartMs = streamStartTimeMs;
        previewStopMs = streamEndTimeMs;
        previewDuration = streamDuration;
      } else {
        if (!ii_0.imm_wasLoaded()) {
          url = ii_0.imm_get_url();
          data = await this._parent._download(url);
          ii_0.imm_parseStream(data);
        }
        dataRows = await ii_0.get_dataRows();
        if (dataRows.length == 0) {
          return await this.get_progress();
        }
        tim = streamStartTimeMs;
        fitv = Math.round(await ii_0.get_firstDataSamplesInterval() * 1e3);
        itv = Math.round(await ii_0.get_dataSamplesInterval() * 1e3);
        nCols = dataRows[0].length;
        minCol = 0;
        if (nCols > 2) {
          avgCol = 1;
        } else {
          avgCol = 0;
        }
        if (nCols > 2) {
          maxCol = 2;
        } else {
          maxCol = 0;
        }
        previewTotalTime = 0;
        previewTotalAvg = 0;
        previewStartMs = streamEndTimeMs;
        previewStopMs = streamStartTimeMs;
        previewMinVal = YAPI_MAX_DOUBLE;
        previewMaxVal = YAPI_MIN_DOUBLE;
        m_pos = 0;
        while (m_pos < dataRows.length) {
          measure_data = dataRows[m_pos];
          if (m_pos == 0) {
            mitv = fitv;
          } else {
            mitv = itv;
          }
          end_ = tim + mitv;
          if (end_ > this._startTimeMs && (this._endTimeMs == 0 || tim < this._endTimeMs)) {
            minVal = measure_data[minCol];
            avgVal = measure_data[avgCol];
            maxVal = measure_data[maxCol];
            if (previewStartMs > tim) {
              previewStartMs = tim;
            }
            if (previewStopMs < end_) {
              previewStopMs = end_;
            }
            if (previewMinVal > minVal) {
              previewMinVal = minVal;
            }
            if (previewMaxVal < maxVal) {
              previewMaxVal = maxVal;
            }
            if (!isNaN(avgVal)) {
              previewTotalAvg = previewTotalAvg + avgVal * mitv;
              previewTotalTime = previewTotalTime + mitv;
            }
          }
          tim = end_;
          m_pos = m_pos + 1;
        }
        if (previewTotalTime > 0) {
          previewAvgVal = previewTotalAvg / previewTotalTime;
          previewDuration = (previewStopMs - previewStartMs) / 1e3;
        } else {
          previewAvgVal = 0;
          previewDuration = 0;
        }
      }
      this._preview.push(new YMeasure(previewStartMs / 1e3, previewStopMs / 1e3, previewMinVal, previewAvgVal, previewMaxVal));
      if (summaryMinVal > previewMinVal) {
        summaryMinVal = previewMinVal;
      }
      if (summaryMaxVal < previewMaxVal) {
        summaryMaxVal = previewMaxVal;
      }
      if (summaryStartMs > previewStartMs) {
        summaryStartMs = previewStartMs;
      }
      if (summaryStopMs < previewStopMs) {
        summaryStopMs = previewStopMs;
      }
      summaryTotalAvg = summaryTotalAvg + previewAvgVal * previewDuration;
      summaryTotalTime = summaryTotalTime + previewDuration;
    }
    if (this._startTimeMs == 0 || this._startTimeMs > summaryStartMs) {
      this._startTimeMs = summaryStartMs;
    }
    if (this._endTimeMs == 0 || this._endTimeMs < summaryStopMs) {
      this._endTimeMs = summaryStopMs;
    }
    if (summaryTotalTime > 0) {
      this._summary = new YMeasure(summaryStartMs / 1e3, summaryStopMs / 1e3, summaryMinVal, summaryTotalAvg / summaryTotalTime, summaryMaxVal);
    } else {
      this._summary = new YMeasure(0, 0, YAPI_INVALID_DOUBLE, YAPI_INVALID_DOUBLE, YAPI_INVALID_DOUBLE);
    }
    return await this.get_progress();
  }
  async processMore(progress, data) {
    let stream;
    let dataRows = [];
    let tim;
    let itv;
    let fitv;
    let avgv;
    let end_;
    let nCols;
    let minCol;
    let avgCol;
    let maxCol;
    let firstMeasure;
    let baseurl;
    let url;
    let suffix;
    let suffixes = [];
    let idx;
    let bulkFile;
    let urlIdx;
    let streamBin = [];
    if (progress != this._progress) {
      return this._progress;
    }
    if (this._progress < 0) {
      return await this.loadSummary(data);
    }
    stream = this._streams[this._progress];
    if (!stream.imm_wasLoaded()) {
      stream.imm_parseStream(data);
    }
    dataRows = await stream.get_dataRows();
    this._progress = this._progress + 1;
    if (dataRows.length == 0) {
      return await this.get_progress();
    }
    tim = Math.round(await stream.get_realStartTimeUTC() * 1e3);
    fitv = Math.round(await stream.get_firstDataSamplesInterval() * 1e3);
    itv = Math.round(await stream.get_dataSamplesInterval() * 1e3);
    if (fitv == 0) {
      fitv = itv;
    }
    if (tim < itv) {
      tim = itv;
    }
    nCols = dataRows[0].length;
    minCol = 0;
    if (nCols > 2) {
      avgCol = 1;
    } else {
      avgCol = 0;
    }
    if (nCols > 2) {
      maxCol = 2;
    } else {
      maxCol = 0;
    }
    firstMeasure = true;
    for (let ii_0 of dataRows) {
      if (firstMeasure) {
        end_ = tim + fitv;
        firstMeasure = false;
      } else {
        end_ = tim + itv;
      }
      avgv = ii_0[avgCol];
      if (end_ > this._startTimeMs && (this._endTimeMs == 0 || tim < this._endTimeMs) && !isNaN(avgv)) {
        this._measures.push(new YMeasure(tim / 1e3, end_ / 1e3, ii_0[minCol], avgv, ii_0[maxCol]));
      }
      tim = end_;
    }
    if (this._bulkLoad > 0 && this._progress < this._streams.length) {
      stream = this._streams[this._progress];
      if (stream.imm_wasLoaded()) {
        return await this.get_progress();
      }
      baseurl = stream.imm_get_baseurl();
      url = stream.imm_get_url();
      suffix = stream.imm_get_urlsuffix();
      suffixes.push(suffix);
      idx = this._progress + 1;
      while (idx < this._streams.length && suffixes.length < this._bulkLoad) {
        stream = this._streams[idx];
        if (!stream.imm_wasLoaded() && stream.imm_get_baseurl() == baseurl) {
          suffix = stream.imm_get_urlsuffix();
          suffixes.push(suffix);
          url = url + "," + suffix;
        }
        idx = idx + 1;
      }
      bulkFile = await this._parent._download(url);
      streamBin = this._parent.imm_json_get_array(bulkFile);
      urlIdx = 0;
      idx = this._progress;
      while (idx < this._streams.length && urlIdx < suffixes.length && urlIdx < streamBin.length) {
        stream = this._streams[idx];
        if (stream.imm_get_baseurl() == baseurl && stream.imm_get_urlsuffix() == suffixes[urlIdx]) {
          stream.imm_parseStream(streamBin[urlIdx]);
          urlIdx = urlIdx + 1;
        }
        idx = idx + 1;
      }
    }
    return await this.get_progress();
  }
  async get_privateDataStreams() {
    return this._streams;
  }
  /**
   * Returns the unique hardware identifier of the function who performed the measures,
   * in the form SERIAL.FUNCTIONID. The unique hardware identifier is composed of the
   * device serial number and of the hardware identifier of the function
   * (for example THRMCPL1-123456.temperature1)
   *
   * @return a string that uniquely identifies the function (ex: THRMCPL1-123456.temperature1)
   *
   * On failure, throws an exception or returns  YDataSet.HARDWAREID_INVALID.
   */
  async get_hardwareId() {
    let mo;
    if (!(this._hardwareId == "")) {
      return this._hardwareId;
    }
    mo = await this._parent.get_module();
    this._hardwareId = await mo.get_serialNumber() + "." + await this.get_functionId();
    return this._hardwareId;
  }
  /**
   * Returns the hardware identifier of the function that performed the measure,
   * without reference to the module. For example temperature1.
   *
   * @return a string that identifies the function (ex: temperature1)
   */
  async get_functionId() {
    return this._functionId;
  }
  /**
   * Returns the measuring unit for the measured value.
   *
   * @return a string that represents a physical unit.
   *
   * On failure, throws an exception or returns  YDataSet.UNIT_INVALID.
   */
  async get_unit() {
    return this._unit;
  }
  /**
   * Returns the start time of the dataset, relative to the Jan 1, 1970.
   * When the YDataSet object is created, the start time is the value passed
   * in parameter to the get_dataSet() function. After the
   * very first call to loadMore(), the start time is updated
   * to reflect the timestamp of the first measure actually found in the
   * dataLogger within the specified range.
   *
   * <b>DEPRECATED</b>: This method has been replaced by get_summary()
   * which contain more precise informations.
   *
   * @return an unsigned number corresponding to the number of seconds
   *         between the Jan 1, 1970 and the beginning of this data
   *         set (i.e. Unix time representation of the absolute time).
   */
  async get_startTimeUTC() {
    return this.imm_get_startTimeUTC();
  }
  imm_get_startTimeUTC() {
    return this._startTimeMs / 1e3;
  }
  /**
   * Returns the end time of the dataset, relative to the Jan 1, 1970.
   * When the YDataSet object is created, the end time is the value passed
   * in parameter to the get_dataSet() function. After the
   * very first call to loadMore(), the end time is updated
   * to reflect the timestamp of the last measure actually found in the
   * dataLogger within the specified range.
   *
   * <b>DEPRECATED</b>: This method has been replaced by get_summary()
   * which contain more precise informations.
   *
   * @return an unsigned number corresponding to the number of seconds
   *         between the Jan 1, 1970 and the end of this data
   *         set (i.e. Unix time representation of the absolute time).
   */
  async get_endTimeUTC() {
    return this.imm_get_endTimeUTC();
  }
  imm_get_endTimeUTC() {
    return Math.round(this._endTimeMs / 1e3);
  }
  /**
   * Returns the progress of the downloads of the measures from the data logger,
   * on a scale from 0 to 100. When the object is instantiated by get_dataSet,
   * the progress is zero. Each time loadMore() is invoked, the progress
   * is updated, to reach the value 100 only once all measures have been loaded.
   *
   * @return an integer in the range 0 to 100 (percentage of completion).
   */
  async get_progress() {
    if (this._progress < 0) {
      return 0;
    }
    if (this._progress >= this._streams.length) {
      return 100;
    }
    return (1 + (1 + this._progress) * 98) / (1 + this._streams.length) >> 0;
  }
  /**
   * Loads the next block of measures from the dataLogger, and updates
   * the progress indicator.
   *
   * @return an integer in the range 0 to 100 (percentage of completion),
   *         or a negative error code in case of failure.
   *
   * On failure, throws an exception or returns a negative error code.
   */
  async loadMore() {
    let url;
    let stream;
    if (this._progress < 0) {
      url = "logger.json?id=" + this._functionId;
      if (this._startTimeMs != 0) {
        url = url + "&from=" + String(Math.round(this.imm_get_startTimeUTC()));
      }
      if (this._endTimeMs != 0) {
        url = url + "&to=" + String(Math.round(this.imm_get_endTimeUTC() + 1));
      }
    } else {
      if (this._progress >= this._streams.length) {
        return 100;
      } else {
        stream = this._streams[this._progress];
        if (stream.imm_wasLoaded()) {
          return await this.processMore(this._progress, this._yapi.imm_str2bin(""));
        }
        url = stream.imm_get_url();
      }
    }
    try {
      return await this.processMore(this._progress, await this._parent._download(url));
    } catch (e) {
      return await this.processMore(this._progress, await this._parent._download(url));
    }
  }
  /**
   * Returns an YMeasure object which summarizes the whole
   * YDataSet. In includes the following information:
   * - the start of a time interval
   * - the end of a time interval
   * - the minimal value observed during the time interval
   * - the average value observed during the time interval
   * - the maximal value observed during the time interval
   *
   * This summary is available as soon as loadMore() has
   * been called for the first time.
   *
   * @return an YMeasure object
   */
  async get_summary() {
    return this._summary;
  }
  /**
   * Returns a condensed version of the measures that can
   * retrieved in this YDataSet, as a list of YMeasure
   * objects. Each item includes:
   * - the start of a time interval
   * - the end of a time interval
   * - the minimal value observed during the time interval
   * - the average value observed during the time interval
   * - the maximal value observed during the time interval
   *
   * This preview is available as soon as loadMore() has
   * been called for the first time.
   *
   * @return a table of records, where each record depicts the
   *         measured values during a time interval
   *
   * On failure, throws an exception or returns an empty array.
   */
  async get_preview() {
    return this._preview;
  }
  /**
   * Returns the detailed set of measures for the time interval corresponding
   * to a given condensed measures previously returned by get_preview().
   * The result is provided as a list of YMeasure objects.
   *
   * @param measure : condensed measure from the list previously returned by
   *         get_preview().
   *
   * @return a table of records, where each record depicts the
   *         measured values during a time interval
   *
   * On failure, throws an exception or returns an empty array.
   */
  async get_measuresAt(measure) {
    let startUtcMs;
    let stream;
    let dataRows = [];
    let measures = [];
    let tim;
    let itv;
    let end_;
    let nCols;
    let minCol;
    let avgCol;
    let maxCol;
    startUtcMs = measure.get_startTimeUTC() * 1e3;
    stream = null;
    for (let ii_0 of this._streams) {
      if (Math.round(await ii_0.get_realStartTimeUTC() * 1e3) == startUtcMs) {
        stream = ii_0;
      }
    }
    if (stream == null) {
      return measures;
    }
    dataRows = await stream.get_dataRows();
    if (dataRows.length == 0) {
      return measures;
    }
    tim = Math.round(await stream.get_realStartTimeUTC() * 1e3);
    itv = Math.round(await stream.get_dataSamplesInterval() * 1e3);
    if (tim < itv) {
      tim = itv;
    }
    nCols = dataRows[0].length;
    minCol = 0;
    if (nCols > 2) {
      avgCol = 1;
    } else {
      avgCol = 0;
    }
    if (nCols > 2) {
      maxCol = 2;
    } else {
      maxCol = 0;
    }
    for (let ii_1 of dataRows) {
      end_ = tim + itv;
      if (end_ > this._startTimeMs && (this._endTimeMs == 0 || tim < this._endTimeMs)) {
        measures.push(new YMeasure(tim / 1e3, end_ / 1e3, ii_1[minCol], ii_1[avgCol], ii_1[maxCol]));
      }
      tim = end_;
    }
    return measures;
  }
  /**
   * Returns all measured values currently available for this DataSet,
   * as a list of YMeasure objects. Each item includes:
   * - the start of the measure time interval
   * - the end of the measure time interval
   * - the minimal value observed during the time interval
   * - the average value observed during the time interval
   * - the maximal value observed during the time interval
   *
   * Before calling this method, you should call loadMore()
   * to load data from the device. You may have to call loadMore()
   * several time until all rows are loaded, but you can start
   * looking at available data rows before the load is complete.
   *
   * The oldest measures are always loaded first, and the most
   * recent measures will be loaded last. As a result, timestamps
   * are normally sorted in ascending order within the measure table,
   * unless there was an unexpected adjustment of the datalogger UTC
   * clock.
   *
   * @return a table of records, where each record depicts the
   *         measured value for a given time interval
   *
   * On failure, throws an exception or returns an empty array.
   */
  async get_measures() {
    return this._measures;
  }
  //--- (end of generated code: YDataSet implementation)
  // YDataSet parser for stream list
  async _parse(str_json) {
    let loadval = null;
    try {
      loadval = JSON.parse(str_json);
    } catch (err) {
    }
    if (!loadval) {
      this._progress = 0;
      return await this.get_progress();
    }
    this._functionId = loadval.id;
    this._unit = loadval.unit;
    this._bulkLoad = loadval.bulk ? parseInt(loadval.bulk) : 0;
    if (loadval.calib) {
      this._calib = this._yapi.imm_decodeFloats(loadval.calib);
      this._calib[0] = this._calib[0] / 1e3 >> 0;
    } else {
      this._calib = this._yapi.imm_decodeWords(loadval.cal);
    }
    this._summary = new YMeasure(0, 0, 0, 0, 0);
    this._streams = [];
    this._preview = [];
    this._measures = [];
    for (let i = 0; i < loadval.streams.length; i++) {
      let stream = this._parent.imm_findDataStream(this, loadval.streams[i]);
      if (!stream)
        continue;
      let streamStartTime = await stream.get_realStartTimeUTC() * 1e3;
      let streamEndTime = streamStartTime + await stream.get_realDuration() * 1e3;
      if (this._startTimeMs > 0 && streamEndTime <= this._startTimeMs) {
      } else if (this._endTimeMs > 0 && streamStartTime >= this._endTimeMs) {
      } else {
        this._streams.push(stream);
      }
    }
    this._progress = 0;
    return this.get_progress();
  }
};
YDataSet.DATA_INVALID = YAPI_INVALID_DOUBLE;
YDataSet.DURATION_INVALID = YAPI_INVALID_DOUBLE;
YDataSet.HARDWAREID_INVALID = YAPI_INVALID_STRING;
YDataSet.FUNCTIONID_INVALID = YAPI_INVALID_STRING;
YDataSet.UNIT_INVALID = YAPI_INVALID_STRING;
YDataSet.DATA_INVALID = YAPI_INVALID_DOUBLE;
YDataSet.DURATION_INVALID = YAPI_INVALID_DOUBLE;
YDataSet.HARDWAREID_INVALID = YAPI_INVALID_STRING;
YDataSet.FUNCTIONID_INVALID = YAPI_INVALID_STRING;
YDataSet.UNIT_INVALID = YAPI_INVALID_STRING;
var YDevice = class {
  // Device constructor. Automatically call the YAPI functin to reindex device
  constructor(obj_yapi, str_rooturl, obj_wpRec, obj_ypRecs) {
    this._yapi = obj_yapi;
    this._rootUrl = str_rooturl;
    this._serialNumber = "";
    this._logicalName = "";
    this._productName = "";
    this._productId = 0;
    this._beacon = 0;
    this._devYdx = -1;
    this._lastErrorType = YAPI_SUCCESS;
    this._lastErrorMsg = "no error";
    this._cache = { _expiration: 0, _json: new Uint8Array(0), _precooked: {} };
    this._functions = [];
    this._busy = 0;
    this._pendingQueries = Promise.resolve();
    this._lastTimeRef = 0;
    this._lastDuration = 0;
    this._logCallback = null;
    this._logIsPulling = false;
    this._logpos = 0;
    if (obj_wpRec && obj_ypRecs) {
      this._serialNumber = obj_wpRec.serialNumber;
      this._logicalName = obj_wpRec.logicalName;
      this._productName = obj_wpRec.productName;
      this._productId = obj_wpRec.productId;
      this._beacon = obj_wpRec.beacon;
      this._devYdx = obj_wpRec.index == void 0 ? -1 : obj_wpRec.index;
      this.imm_updateFromYP(obj_ypRecs);
      this._yapi.imm_reindexDevice(this);
    }
  }
  _throw(int_errType, str_errMsg, obj_retVal) {
    this._lastErrorType = int_errType;
    this._lastErrorMsg = str_errMsg;
    return this._yapi._throw(int_errType, str_errMsg, obj_retVal);
  }
  /** Return the root URL used to access a device (including the trailing slash)
   *
   * @returns {string}
   */
  imm_getRootUrl() {
    return this._rootUrl;
  }
  /** Return the serial number of the device, as found during discovery
   *
   * @returns {string}
   */
  imm_getSerialNumber() {
    return this._serialNumber;
  }
  /** Return the logical name of the device, as found during discovery
   *
   * @returns {string}
   */
  imm_getLogicalName() {
    return this._logicalName;
  }
  async getLogicalName() {
    if (this._cache._expiration == 0) {
      await this.refresh();
    }
    return this._logicalName;
  }
  /** Return the product name of the device, as found during discovery
   *
   * @returns {string}
   */
  imm_getProductName() {
    return this._productName;
  }
  /** Return the product Id of the device, as found during discovery
   *
   * @returns {number}
   */
  imm_getProductId() {
    return this._productId;
  }
  /** Return the beacon state of the device, as found during discovery
   *
   * @returns {number}
   */
  imm_getBeacon() {
    return this._beacon;
  }
  /** Return the beacon state of the device, as found during discovery
   *
   * @returns {number}
   */
  async getBeacon() {
    if (this._cache._expiration == 0) {
      await this.refresh();
    }
    return this._beacon;
  }
  // Return the value of the last timestamp sent by the device, if any
  imm_getLastTimeRef() {
    return this._lastTimeRef;
  }
  // Return the value of the last duration sent by the device, if any
  imm_getLastDuration() {
    return this._lastDuration;
  }
  imm_triggerLogPull() {
    if (this._logCallback == null || this._logIsPulling) {
      return;
    }
    this._logIsPulling = true;
    let request = "GET logs.txt?pos=" + this._logpos;
    let prom = this._yapi.devRequest(this._rootUrl, request, null, 0);
    prom.then(async (yreq) => {
      if (yreq.errorType != YAPI_SUCCESS) {
        this._logIsPulling = false;
        return;
      }
      if (this._logCallback == null) {
        this._logIsPulling = false;
        return;
      }
      let resultStr = YAPI.imm_bin2str(yreq.bin_result);
      let pos = resultStr.lastIndexOf("\n@");
      if (pos < 0) {
        this._logIsPulling = false;
        return;
      }
      let logs = resultStr.substring(0, pos);
      let posStr = resultStr.substring(pos + 2);
      this._logpos = parseInt(posStr);
      let module = YModule.FindModuleInContext(this._yapi, this._serialNumber);
      let lines = logs.trim().split("\n");
      try {
        for (let i = 0; i < lines.length; i++) {
          await this._logCallback(module, lines[i]);
        }
      } catch (e) {
        this._yapi.imm_log("Exception in device log callback:", e);
      }
      this._logIsPulling = false;
    });
  }
  imm_registerLogCallback(callback) {
    this._logCallback = callback;
    if (callback != null) {
      this.imm_triggerLogPull();
    } else {
      this._logpos = 0;
      this._logIsPulling = false;
    }
  }
  /** Return the value of the last timestamp sent by the device, if any
   */
  imm_setTimeRef(float_timestamp, float_duration) {
    this._lastTimeRef = float_timestamp;
    this._lastDuration = float_duration;
  }
  /** Return the hub-specific devYdx of the device, as found during discovery
   *
   * @returns {number}
   */
  imm_getDevYdx() {
    return this._devYdx;
  }
  /** Return a string that describes the device (serial number, logical name or root URL)
   *
   * @returns {string}
   */
  imm_describe() {
    let res = this._rootUrl;
    if (this._serialNumber != "") {
      res = this._serialNumber;
      if (this._logicalName != "") {
        res = res + " (" + this._logicalName + ")";
      }
    }
    return this._productName + " " + res;
  }
  /** Update device cache and YAPI function lists from yp records
   */
  imm_updateFromYP(obj_ypRecs) {
    let funidx = 0;
    for (let categ in obj_ypRecs) {
      for (let key in obj_ypRecs[categ]) {
        let rec = obj_ypRecs[categ][key];
        let hwid = rec["hardwareId"];
        let dotpos = hwid.indexOf(".");
        if (hwid.substr(0, dotpos) == this._serialNumber) {
          let funydx = rec["index"];
          if (funydx == void 0)
            funydx = funidx;
          this._functions[funydx] = [hwid.substr(dotpos + 1), rec["logicalName"]];
          funidx++;
        }
      }
    }
  }
  /** Update device cache and YAPI function lists accordingly
   */
  async updateFromReq(yreq, loadval) {
    this._cache._expiration = this._yapi.GetTickCount() + this._yapi.defaultCacheValidity;
    this._cache._json = yreq.bin_result;
    let func;
    let reindex = false;
    if (this._productName == "") {
      for (func in loadval) {
        if (func == "module") {
          this._serialNumber = loadval.module.serialNumber;
          this._logicalName = loadval.module.logicalName;
          this._productName = loadval.module.productName;
          this._productId = loadval.module.productId;
          this._beacon = loadval.module.beacon;
        } else if (func == "services") {
          this.imm_updateFromYP(loadval.services.yellowPages);
        }
      }
      reindex = true;
    } else {
      let renamed = false;
      for (func in loadval) {
        if (func == "module") {
          if (this._logicalName != loadval.module.logicalName) {
            this._logicalName = loadval.module.logicalName;
            reindex = true;
          }
          this._beacon = loadval.module.beacon;
        } else if (func != "services") {
          let name = loadval[func]["logicalName"];
          if (name == void 0)
            name = loadval.module.logicalName;
          let pubval = loadval[func]["advertisedValue"];
          if (pubval != void 0) {
            await this._yapi.setFunctionValue(loadval.module.serialNumber + "." + func, pubval);
          }
          let funydx;
          for (funydx in this._functions) {
            if (this._functions[funydx][0] == func) {
              if (this._functions[funydx][1] != name) {
                this._functions[funydx][1] = name;
                reindex = true;
              }
              break;
            }
          }
        }
      }
    }
    if (reindex) {
      this._yapi.imm_reindexDevice(this);
    }
  }
  // Force the REST API string in cache to expire immediately
  imm_dropCache() {
    this._cache._expiration = 0;
    this._cache._precooked = {};
  }
  /** Retrieve the number of functions (beside "module") in the device
   */
  imm_functionCount() {
    let funcPos = 0;
    for (let key in this._functions) {
      funcPos++;
    }
    return funcPos;
  }
  /** Retrieve the Id of the nth function (beside "module") in the device
   */
  imm_functionId(int_idx) {
    let funcPos = 0;
    for (let key in this._functions) {
      if (int_idx === funcPos) {
        return this._functions[key][0];
      }
      funcPos++;
    }
    return "";
  }
  /** Retrieve the base type of the nth function (beside "module") in the device
   */
  imm_functionBaseType(int_idx) {
    let funid = this.imm_functionId(int_idx);
    if (funid !== "") {
      let ftype = this._yapi.imm_getFunctionBaseType(this._serialNumber + "." + funid);
      for (let baseType in Y_BASETYPES) {
        if (Y_BASETYPES[baseType] === ftype) {
          return baseType;
        }
      }
    }
    return "Function";
  }
  /** Retrieve the type of the nth function (beside 'module') in the device
   */
  imm_functionType(int_idx) {
    let funid = this.imm_functionId(int_idx);
    if (funid !== "") {
      let i;
      for (i = funid.length; i > 0; i--) {
        if (funid[i - 1] > "9") {
          break;
        }
      }
      let functionType = funid[0].toUpperCase() + funid.substr(1, i - 1);
      return functionType;
    }
    return "";
  }
  /** Retrieve the logical name of the nth function (beside "module") in the device
   */
  imm_functionName(int_idx) {
    let funcPos = 0;
    for (let key in this._functions) {
      if (int_idx === funcPos) {
        return this._functions[key][1];
      }
      funcPos++;
    }
    return "";
  }
  /** Retrieve the advertised value of the nth function (beside "module") in the device
   */
  imm_functionValue(int_idx) {
    let funid = this.imm_functionId(int_idx);
    if (funid !== "") {
      return this._yapi.imm_getFunctionValue(this._serialNumber + "." + funid);
    }
    return "";
  }
  /** Retrieve the Id of a function given its funydx (internal function identifier index)
   */
  imm_functionIdByFunYdx(int_funydx) {
    if (this._functions[int_funydx]) {
      return this._functions[int_funydx][0];
    }
    return "";
  }
  /** Map an optimized JZON reply to a previously known JSON structure
   */
  imm_jzon2json(jzon, json) {
    if (Array.isArray(jzon)) {
      let sz = jzon.length;
      if (Array.isArray(json)) {
        let defval = json.length > 0 ? json[0] : null;
        let res = [];
        for (let idx = 0; idx < sz; idx++) {
          res[idx] = this.imm_jzon2json(jzon[idx], defval);
        }
        return res;
      } else if (typeof json === "object") {
        let idx = 0;
        let res = {};
        for (let key in json) {
          if (json.hasOwnProperty(key)) {
            res[key] = this.imm_jzon2json(jzon[idx], json[key]);
            idx++;
          }
        }
        return res;
      } else {
        return jzon;
      }
    } else if (typeof jzon === "object") {
      if (Array.isArray(json)) {
        return jzon;
      } else if (typeof json === "object") {
        let defval = null;
        for (let key in json) {
          if (json.hasOwnProperty(key)) {
            defval = json[key];
            break;
          }
        }
        let res = {};
        for (let key in jzon) {
          if (jzon.hasOwnProperty(key)) {
            if (json.hasOwnProperty(key) && (!Array.isArray(json[key]) || json[key].length > 0)) {
              res[key] = this.imm_jzon2json(jzon[key], json[key]);
            } else {
              res[key] = this.imm_jzon2json(jzon[key], defval);
            }
          }
        }
        return res;
      } else {
        return jzon;
      }
    }
    return jzon;
  }
  /** Get the whole REST API string for a device, from cache if possible
   */
  async requestAPI(int_msValidity) {
    if (this._cache._expiration > this._yapi.GetTickCount()) {
      let res = new YHTTPRequest(this._cache._json);
      res.obj_result = JSON.parse(JSON.stringify(this._cache._precooked));
      return res;
    }
    let req = "GET /api.json";
    let precooked = this._cache._precooked;
    if (precooked.module && precooked.module.firmwareRelease) {
      req += "?fw=" + encodeURIComponent(precooked.module.firmwareRelease);
    }
    let yreq = await this._yapi.devRequest(this._rootUrl, req, null, 0);
    if (yreq.errorType != YAPI_SUCCESS)
      return yreq;
    if (!int_msValidity) {
      int_msValidity = this._yapi.defaultCacheValidity;
    }
    this._cache._json = yreq.bin_result;
    try {
      yreq.obj_result = JSON.parse(this._yapi.imm_bin2str(yreq.bin_result));
      if (Array.isArray(yreq.obj_result)) {
        if (precooked.module) {
          let objres = this.imm_jzon2json(yreq.obj_result, precooked);
          yreq.obj_result = objres;
          if (objres.module && objres.module.serialNumber === objres.module.serialNumber && objres.module.firmwareRelease === objres.module.firmwareRelease) {
            let jsonstr = JSON.stringify(yreq.obj_result);
            this._cache._json = yreq.bin_result = this._yapi.imm_str2bin(jsonstr);
            this._cache._precooked = JSON.parse(jsonstr);
          } else {
            this.imm_dropCache();
            yreq.errorType = YAPI_IO_ERROR;
            yreq.errorMsg = "Request failed, could not parse API JZON result for " + this._rootUrl;
          }
        } else {
          yreq.errorType = YAPI_IO_ERROR;
          yreq.errorMsg = "Request failed, could not parse API array result for " + this._rootUrl;
        }
      } else if (yreq.obj_result.module && yreq.obj_result.module.firmwareRelease) {
        this._cache._precooked = JSON.parse(JSON.stringify(yreq.obj_result));
      }
      this._cache._expiration = this._yapi.GetTickCount() + int_msValidity;
      this._logicalName = yreq.obj_result.module.logicalName;
      this._beacon = yreq.obj_result.module.beacon;
    } catch (err) {
      yreq.errorType = YAPI_IO_ERROR;
      yreq.errorMsg = "Request failed, could not parse API JSON result for " + this._rootUrl;
    }
    return yreq;
  }
  /** Reload a device API (store in cache), and update YAPI function lists accordingly
   *
   * @returns {number}
   */
  async refresh() {
    let yreq = await this.requestAPI(this._yapi.defaultCacheValidity);
    if (yreq.errorType != YAPI_SUCCESS) {
      return this._throw(yreq.errorType, yreq.errorMsg, yreq.errorType);
    }
    await this.updateFromReq(yreq, yreq.obj_result);
    return YAPI_SUCCESS;
  }
  async waitPendingQueries() {
    let newPromise = this._pendingQueries;
    if (newPromise != null) {
      try {
        await newPromise;
      } catch (e) {
        console.log(e);
      }
    }
  }
};
var YFirmwareFile = class _YFirmwareFile {
  constructor(path, serial, pictype, product, firmware, prog_version, ROM_nb_zone, FLA_nb_zone, ROM_total_size, FLA_total_size, data, zone_ofs) {
    this._path = path;
    this._serial = serial;
    this._pictype = pictype;
    this._product = product;
    this._firmware = firmware;
    this._prog_version = prog_version;
    this._ROM_nb_zone = ROM_nb_zone;
    this._FLA_nb_zone = FLA_nb_zone;
    this._ROM_total_size = ROM_total_size;
    this._FLA_total_size = FLA_total_size;
    this._data = data;
    this._zone_ofs = zone_ofs;
  }
  /**
   * Parse the binary buffer provided as input and initialize a new object
   * returns null if the file is not a valid firmware
   */
  static imm_Parse(path, data, force) {
    const BYN_REV_V4 = 4;
    const BYN_REV_V5 = 5;
    const BYN_REV_V6 = 6;
    const MAX_ROM_ZONES_PER_FILES = 16;
    const MAX_FLASH_ZONES_PER_FILES = 4;
    const BYN_HEAD_SIZE_V4 = 96 + 8;
    const BYN_HEAD_SIZE_V5 = 96 + 32;
    const BYN_HEAD_SIZE_V6 = 96 + 48;
    const BYN_MD5_OFS_V6 = 96 + 16;
    let pos = 0;
    let getShort = (() => {
      let res = data[pos] + (data[pos + 1] << 8);
      pos += 2;
      return res;
    });
    let getInt = (() => {
      let res = data[pos] + (data[pos + 1] << 8) + (data[pos + 2] << 16) + (data[pos + 3] << 24);
      pos += 4;
      return res;
    });
    let getString = ((maxlen) => {
      let end = pos + maxlen;
      while (end > pos && data[end - 1] == 0) {
        end--;
      }
      let res = YAPI.imm_bin2str(data.subarray(pos, end));
      pos += maxlen;
      return res;
    });
    let sign = getString(4);
    if (sign != "BYN")
      return null;
    let rev = getShort();
    let serial = getString(20);
    let pictype = getString(20);
    let product = getString(28);
    let firmware = getString(22);
    if (serial.length >= 20)
      return null;
    if (product.length >= 28)
      return null;
    if (firmware.length >= 22)
      return null;
    let ROM_nb_zone = 0;
    let FLA_nb_zone = 0;
    let ROM_total_size = 0;
    let FLA_total_size = 0;
    let prog_buf;
    let prog_version = "";
    let zone_ofs;
    let datasize;
    switch (rev) {
      case BYN_REV_V4:
        zone_ofs = BYN_HEAD_SIZE_V4;
        ROM_nb_zone = getInt();
        datasize = getInt();
        if (ROM_nb_zone > MAX_ROM_ZONES_PER_FILES)
          return null;
        if (datasize != data.length - BYN_HEAD_SIZE_V4)
          return null;
        break;
      case BYN_REV_V5:
        zone_ofs = BYN_HEAD_SIZE_V5;
        prog_version = getString(22);
        if (!force && !_YFirmwareFile.imm_progCompatible(prog_version))
          return null;
        getShort();
        ROM_nb_zone = getInt();
        datasize = getInt();
        if (ROM_nb_zone > MAX_ROM_ZONES_PER_FILES)
          return null;
        if (datasize != data.length - BYN_HEAD_SIZE_V5)
          return null;
        break;
      case BYN_REV_V6:
        zone_ofs = BYN_HEAD_SIZE_V6;
        let md5hdr = data.subarray(pos, pos + 16);
        pos += 16;
        let md5hdrstr = YAPI.imm_bin2hexstr(md5hdr);
        let md5ctx = new Y_MD5Ctx();
        md5ctx.addData(data.subarray(BYN_MD5_OFS_V6));
        let md5bynstr = YAPI.imm_bin2hexstr(md5ctx.calculate());
        if (md5hdrstr != md5bynstr) {
          YAPI.imm_log("Invalid firmware image signature, file is corrupt");
          if (YAPI._logLevel >= 2) {
            YAPI.imm_log("hdr MD5: " + md5hdrstr);
            YAPI.imm_log("byn MD5: " + md5bynstr);
            YAPI.imm_log("byn size: " + data.length);
          }
          return null;
        }
        prog_version = getString(22);
        if (!force && !_YFirmwareFile.imm_progCompatible(prog_version))
          return null;
        ROM_nb_zone = data[pos++];
        FLA_nb_zone = data[pos++];
        ROM_total_size = getInt();
        FLA_total_size = getInt();
        if (ROM_nb_zone > MAX_ROM_ZONES_PER_FILES)
          return null;
        if (FLA_nb_zone > MAX_FLASH_ZONES_PER_FILES)
          return null;
        break;
      default:
        return null;
    }
    return new _YFirmwareFile(path, serial, pictype, product, firmware, prog_version, ROM_nb_zone, FLA_nb_zone, ROM_total_size, FLA_total_size, data, zone_ofs);
  }
  static imm_progCompatible(prog_version) {
    if (prog_version == "")
      return true;
    let apiVer = YAPI.imm_GetAPIVersion();
    let dashpos = apiVer.indexOf("-");
    if (dashpos > 0) {
      apiVer = apiVer.slice(0, dashpos);
    }
    apiVer = apiVer.slice(apiVer.lastIndexOf(".") + 1);
    if (parseInt(prog_version) > parseInt(apiVer)) {
      YAPI.imm_log("checkProgField: byn=" + prog_version + " api=" + apiVer);
      return false;
    }
    return true;
  }
  imm_getSerial() {
    return this._serial;
  }
  imm_getPictype() {
    return this._pictype;
  }
  imm_getProduct() {
    return this._product;
  }
  imm_getFirmwareRelease() {
    return this._firmware;
  }
  imm_getFirmwareReleaseAsInt() {
    return parseInt(this._firmware);
  }
  imm_getProg_version() {
    return this._prog_version;
  }
  imm_getROM_nb_zone() {
    return this._ROM_nb_zone;
  }
  imm_getFLA_nb_zone() {
    return this._FLA_nb_zone;
  }
  imm_getROM_total_size() {
    return this._ROM_total_size;
  }
  imm_getFLA_total_size() {
    return this._FLA_total_size;
  }
  imm_getData() {
    return this._data;
  }
  imm_getPath() {
    return this._path;
  }
};
var YFirmwareUpdate = class _YFirmwareUpdate {
  // API symbols as static members
  //--- (end of generated code: YFirmwareUpdate attributes declaration)
  constructor(obj_yapi, str_serial, str_path, bin_settings, bool_force) {
    this._serial = "";
    this._settings = new Uint8Array(0);
    this._firmwarepath = "";
    this._progress_msg = "";
    this._progress_c = 0;
    this._progress = 0;
    this._restore_step = 0;
    this._force = false;
    this._yapi = obj_yapi;
    this._serial = str_serial;
    this._firmwarepath = str_path;
    this._settings = bin_settings;
    this._force = bool_force;
  }
  imm_progress(progress, msg) {
    this._progress = progress;
    this._progress_msg = msg;
  }
  async _processMore_internal(newupdate) {
    if (!newupdate)
      return YAPI_SUCCESS;
    let bytes;
    this.imm_progress(0, "Firmware update started");
    if (typeof this._firmwarepath == "string" && this._firmwarepath.indexOf("yoctopuce.com") >= 0) {
      this.imm_progress(1, "Downloading firmware");
      bytes = await this._yapi.system_env.downloadfile(this._firmwarepath, this._yapi);
    } else {
      this.imm_progress(1, "Loading firmware");
      bytes = await this._yapi.system_env.loadfile(this._firmwarepath);
    }
    let firmware = YFirmwareFile.imm_Parse(this._firmwarepath, bytes, this._force);
    if (!firmware) {
      return this._yapi._throw(YAPI_DEVICE_NOT_FOUND, "Device " + this._serial + " is not detected", YAPI_DEVICE_NOT_FOUND);
    }
    this.imm_progress(5, "Check if module is already in bootloader");
    let hub = null;
    let module = YModule.FindModuleInContext(this._yapi, this._serial + ".module");
    if (await module.isOnline()) {
      let dev = this._yapi.imm_getDevice(this._serial);
      let baseUrl = dev.imm_getRootUrl();
      let byPos = baseUrl.indexOf("/bySerial/");
      if (byPos >= 0) {
        baseUrl = baseUrl.slice(0, byPos + 1);
      } else if (baseUrl.slice(-1) != "/")
        baseUrl = baseUrl + "/";
      let urlInfo = new _YY_UrlInfo(baseUrl);
      hub = this._yapi.imm_getHub(urlInfo);
    } else {
      let hubs = this._yapi._connectedHubs;
      for (let i = 0; i < hubs.length; i++) {
        let ldrs = await hubs[i].getBootloaders();
        if (ldrs.indexOf(this._serial) >= 0) {
          hub = hubs[i];
          break;
        }
      }
    }
    if (hub == null) {
      this.imm_progress(-1, "Device " + this._serial + " is not detected");
      return this._yapi._throw(YAPI_DEVICE_NOT_FOUND, "Device " + this._serial + " is not detected", YAPI_DEVICE_NOT_FOUND);
    }
    try {
      await hub.firmwareUpdate(this._serial, firmware, this._settings, (percent, msg) => {
        this.imm_progress(5 + (percent * 80 + 50) / 100 >> 0, msg);
      });
    } catch (e) {
      this.imm_progress(-1, e.message);
      return this._yapi._throw(YAPI_IO_ERROR, e.message, YAPI_IO_ERROR);
    }
    if (module._cache.parentHub) {
      this.imm_progress(100, "Firmware update scheduled successfully");
    } else {
      this.imm_progress(80, "Wait for the device to restart");
      let timeout = this._yapi.GetTickCount() + 6e4;
      await module.clearCache();
      while (!await module.isOnline() && timeout > this._yapi.GetTickCount()) {
        await this._yapi.Sleep(500);
        await this._yapi.UpdateDeviceList();
      }
      if (await module.isOnline()) {
        if (this._settings != null) {
          this.imm_progress(95, "Restoring device settings");
          await module.set_allSettingsAndFiles(this._settings);
          await module.saveToFlash();
        }
        let real_fw = await module.get_firmwareRelease();
        if (real_fw == firmware.imm_getFirmwareRelease()) {
          this.imm_progress(100, "Success");
        } else {
          this.imm_progress(-1, "Unable to update firmware");
        }
      } else {
        this.imm_progress(-1, "Device did not reboot correctly");
      }
    }
    return YAPI_SUCCESS;
  }
  static async checkFirmware_r(file, serial_base, force) {
    if (file.substr(-4).toLowerCase() != ".byn")
      return null;
    let bynfile = await YAPI.system_env.loadfile(file);
    let firmware = YFirmwareFile.imm_Parse(file, bynfile, force);
    if (!firmware)
      return null;
    if (firmware.imm_getSerial().slice(0, serial_base.length) != serial_base)
      return null;
    return firmware;
  }
  /**
   * Test if the byn file is valid for this module. It is possible to pass a directory instead of a file.
   * In that case, this method returns the path of the most recent appropriate byn file. This method will
   * ignore any firmware older than minrelease.
   *
   * @param serial {string} : the serial number of the module to update
   * @param path {string} : the path of a byn file or a directory that contains byn files
   * @param minrelease {number} : a positive integer
   * @param force {boolean} : true to force an update even if the API is below expected revision
   *
   * @return {string} : the path of the byn file to use, or an empty string if no byn files matches the requirement
   *
   * On failure, returns a string that starts with "error:".
   */
  static async CheckFirmwareEx(serial, path, minrelease, force) {
    let link = "";
    let best_rev = 0;
    let current_rev;
    if (typeof path == "string" && path.indexOf("yoctopuce.com") >= 0) {
      try {
        let data = await YAPI.system_env.downloadfile("http://www.yoctopuce.com/FR/common/getLastFirmwareLink.php?serial=" + serial, YAPI);
        let obj = JSON.parse(YAPI.imm_bin2str(data));
        link = obj["link"];
        best_rev = obj["version"];
      } catch (e) {
        YAPI.imm_log("failed to retrieve firmware information from www.yoctopuce.com", e);
        YAPI._throw(YAPI_IO_ERROR, "failed to retrieve firmware information from www.yoctopuce.com", "");
        return "";
      }
    } else {
      let firmware = await _YFirmwareUpdate.checkFirmware_r(path, serial.substring(0, 8), force);
      if (firmware != null) {
        best_rev = firmware.imm_getFirmwareReleaseAsInt();
        link = firmware.imm_getPath();
      }
    }
    if (minrelease != 0) {
      if (minrelease < best_rev) {
        return link;
      } else {
        return "";
      }
    }
    return link;
  }
  static async CheckFirmware_internal(serial, path, minrelease) {
    return _YFirmwareUpdate.CheckFirmwareEx(serial, path, minrelease, false);
  }
  static async GetAllBootLoadersInContext_internal(yctx) {
    let hubs = yctx._connectedHubs;
    let res = [];
    for (let i = 0; i < hubs.length; i++) {
      let ldrs = await hubs[i].getBootloaders();
      for (let j = 0; j < ldrs.length; j++) {
        res.push(ldrs[j]);
      }
    }
    return res;
  }
  static async GetAllBootLoaders_internal() {
    return _YFirmwareUpdate.GetAllBootLoadersInContext(YAPI);
  }
  //--- (generated code: YFirmwareUpdate implementation)
  async _processMore(newupdate) {
    return await this._processMore_internal(newupdate);
  }
  /**
   * Returns a list of all the modules in "firmware update" mode.
   *
   * @return an array of strings containing the serial numbers of devices in "firmware update" mode.
   */
  static async GetAllBootLoaders() {
    return await this.GetAllBootLoaders_internal();
  }
  /**
   * Returns a list of all the modules in "firmware update" mode.
   *
   * @param yctx : a YAPI context.
   *
   * @return an array of strings containing the serial numbers of devices in "firmware update" mode.
   */
  static async GetAllBootLoadersInContext(yctx) {
    return await this.GetAllBootLoadersInContext_internal(yctx);
  }
  /**
   * Test if the byn file is valid for this module. It is possible to pass a directory instead of a file.
   * In that case, this method returns the path of the most recent appropriate byn file. This method will
   * ignore any firmware older than minrelease.
   *
   * @param serial : the serial number of the module to update
   * @param path : the path of a byn file or a directory that contains byn files
   * @param minrelease : a positive integer
   *
   * @return : the path of the byn file to use, or an empty string if no byn files matches the requirement
   *
   * On failure, returns a string that starts with "error:".
   */
  static async CheckFirmware(serial, path, minrelease) {
    return await this.CheckFirmware_internal(serial, path, minrelease);
  }
  /**
   * Returns the progress of the firmware update, on a scale from 0 to 100. When the object is
   * instantiated, the progress is zero. The value is updated during the firmware update process until
   * the value of 100 is reached. The 100 value means that the firmware update was completed
   * successfully. If an error occurs during the firmware update, a negative value is returned, and the
   * error message can be retrieved with get_progressMessage.
   *
   * @return an integer in the range 0 to 100 (percentage of completion)
   *         or a negative error code in case of failure.
   */
  async get_progress() {
    if (this._progress >= 0) {
      await this._processMore(0);
    }
    return this._progress;
  }
  /**
   * Returns the last progress message of the firmware update process. If an error occurs during the
   * firmware update process, the error message is returned
   *
   * @return a string  with the latest progress message, or the error message.
   */
  async get_progressMessage() {
    return this._progress_msg;
  }
  /**
   * Starts the firmware update process. This method starts the firmware update process in background. This method
   * returns immediately. You can monitor the progress of the firmware update with the get_progress()
   * and get_progressMessage() methods.
   *
   * @return an integer in the range 0 to 100 (percentage of completion),
   *         or a negative error code in case of failure.
   *
   * On failure returns a negative error code.
   */
  async startUpdate() {
    let err;
    let leng;
    err = this._yapi.imm_bin2str(this._settings);
    leng = err.length;
    if (leng >= 6 && "error:" == err.substr(0, 6)) {
      this._progress = -1;
      this._progress_msg = err.substr(6, leng - 6);
    } else {
      this._progress = 0;
      this._progress_c = 0;
      await this._processMore(1);
    }
    return this._progress;
  }
};
var YFunction = class _YFunction {
  //--- (end of generated code: YFunction attributes declaration)
  constructor(obj_yapi, str_func) {
    this._logicalName = _YFunction.LOGICALNAME_INVALID;
    this._advertisedValue = _YFunction.ADVERTISEDVALUE_INVALID;
    this._valueCallbackFunction = null;
    this._cacheExpiration = 0;
    this._serial = "";
    this._funId = "";
    this._hwId = "";
    this.LOGICALNAME_INVALID = YAPI_INVALID_STRING;
    this.ADVERTISEDVALUE_INVALID = YAPI_INVALID_STRING;
    this._yapi = obj_yapi;
    this._className = "Function";
    this._func = str_func;
    this._lastErrorType = YAPI_SUCCESS;
    this._lastErrorMsg = "no error";
    this._dataStreams = {};
    this._userData = null;
    this._cache = { _expiration: -1, functionid: "", hwid: "" };
    this._valueCallbackFunction = null;
  }
  _throw(int_errType, str_errMsg, obj_retVal) {
    this._lastErrorType = int_errType;
    this._lastErrorMsg = str_errMsg;
    return this._yapi._throw(int_errType, str_errMsg, obj_retVal);
  }
  async isReadOnly_internal() {
    try {
      let serial = await this.get_serialNumber();
      return this._yapi.isReadOnly(serial);
    } catch (e) {
      return true;
    }
  }
  //--- (generated code: YFunction implementation)
  imm_parseAttr(name, val) {
    switch (name) {
      case "_expiration":
        this._cacheExpiration = val;
        return 1;
      case "logicalName":
        this._logicalName = val;
        return 1;
      case "advertisedValue":
        this._advertisedValue = val;
        return 1;
    }
    return 0;
  }
  /**
   * Returns the logical name of the function.
   *
   * @return a string corresponding to the logical name of the function
   *
   * On failure, throws an exception or returns YFunction.LOGICALNAME_INVALID.
   */
  async get_logicalName() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return _YFunction.LOGICALNAME_INVALID;
      }
    }
    res = this._logicalName;
    return res;
  }
  /**
   * Changes the logical name of the function. You can use yCheckLogicalName()
   * prior to this call to make sure that your parameter is valid.
   * Remember to call the saveToFlash() method of the module if the
   * modification must be kept.
   *
   * @param newval : a string corresponding to the logical name of the function
   *
   * @return YAPI.SUCCESS if the call succeeds.
   *
   * On failure, throws an exception or returns a negative error code.
   */
  async set_logicalName(newval) {
    let rest_val;
    if (!await YAPI.CheckLogicalName(newval)) {
      return this._throw(YAPI.INVALID_ARGUMENT, "Invalid name :" + newval, YAPI.INVALID_ARGUMENT);
    }
    rest_val = String(newval);
    return await this._setAttr("logicalName", rest_val);
  }
  /**
   * Returns a short string representing the current state of the function.
   *
   * @return a string corresponding to a short string representing the current state of the function
   *
   * On failure, throws an exception or returns YFunction.ADVERTISEDVALUE_INVALID.
   */
  async get_advertisedValue() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return _YFunction.ADVERTISEDVALUE_INVALID;
      }
    }
    res = this._advertisedValue;
    return res;
  }
  async set_advertisedValue(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("advertisedValue", rest_val);
  }
  /**
   * Retrieves a function for a given identifier.
   * The identifier can be specified using several formats:
   *
   * - FunctionLogicalName
   * - ModuleSerialNumber.FunctionIdentifier
   * - ModuleSerialNumber.FunctionLogicalName
   * - ModuleLogicalName.FunctionIdentifier
   * - ModuleLogicalName.FunctionLogicalName
   *
   *
   * This function does not require that the function is online at the time
   * it is invoked. The returned object is nevertheless valid.
   * Use the method YFunction.isOnline() to test if the function is
   * indeed online at a given time. In case of ambiguity when looking for
   * a function by logical name, no error is notified: the first instance
   * found is returned. The search is performed first by hardware name,
   * then by logical name.
   *
   * If a call to this object's is_online() method returns FALSE although
   * you are certain that the matching device is plugged, make sure that you did
   * call registerHub() at application initialization time.
   *
   * @param func : a string that uniquely characterizes the function, for instance
   *         MyDevice..
   *
   * @return a YFunction object allowing you to drive the function.
   */
  static FindFunction(func) {
    let obj;
    obj = _YFunction._FindFromCache("Function", func);
    if (obj == null) {
      obj = new _YFunction(YAPI, func);
      _YFunction._AddToCache("Function", func, obj);
    }
    return obj;
  }
  /**
   * Retrieves a function for a given identifier in a YAPI context.
   * The identifier can be specified using several formats:
   *
   * - FunctionLogicalName
   * - ModuleSerialNumber.FunctionIdentifier
   * - ModuleSerialNumber.FunctionLogicalName
   * - ModuleLogicalName.FunctionIdentifier
   * - ModuleLogicalName.FunctionLogicalName
   *
   *
   * This function does not require that the function is online at the time
   * it is invoked. The returned object is nevertheless valid.
   * Use the method YFunction.isOnline() to test if the function is
   * indeed online at a given time. In case of ambiguity when looking for
   * a function by logical name, no error is notified: the first instance
   * found is returned. The search is performed first by hardware name,
   * then by logical name.
   *
   * @param yctx : a YAPI context
   * @param func : a string that uniquely characterizes the function, for instance
   *         MyDevice..
   *
   * @return a YFunction object allowing you to drive the function.
   */
  static FindFunctionInContext(yctx, func) {
    let obj;
    obj = _YFunction._FindFromCacheInContext(yctx, "Function", func);
    if (obj == null) {
      obj = new _YFunction(yctx, func);
      _YFunction._AddToCache("Function", func, obj);
    }
    return obj;
  }
  /**
   * Registers the callback function that is invoked on every change of advertised value.
   * The callback is invoked only during the execution of ySleep or yHandleEvents.
   * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
   * one of these two functions periodically. To unregister a callback, pass a null pointer as argument.
   *
   * @param callback : the callback function to call, or a null pointer. The callback function should take two
   *         arguments: the function object of which the value has changed, and the character string describing
   *         the new advertised value.
   * @noreturn
   */
  async registerValueCallback(callback) {
    let val;
    if (callback != null) {
      await _YFunction._UpdateValueCallbackList(this, true);
    } else {
      await _YFunction._UpdateValueCallbackList(this, false);
    }
    this._valueCallbackFunction = callback;
    if (callback != null && await this.isOnline()) {
      val = this._advertisedValue;
      if (!(val == "")) {
        await this._invokeValueCallback(val);
      }
    }
    return 0;
  }
  async _invokeValueCallback(value) {
    if (this._valueCallbackFunction != null) {
      try {
        await this._valueCallbackFunction(this, value);
      } catch (e) {
        this._yapi.imm_log("Exception in valueCallback:", e);
      }
    } else {
    }
    return 0;
  }
  /**
   * Disables the propagation of every new advertised value to the parent hub.
   * You can use this function to save bandwidth and CPU on computers with limited
   * resources, or to prevent unwanted invocations of the HTTP callback.
   * Remember to call the saveToFlash() method of the module if the
   * modification must be kept.
   *
   * @return YAPI.SUCCESS when the call succeeds.
   *
   * On failure, throws an exception or returns a negative error code.
   */
  async muteValueCallbacks() {
    return await this.set_advertisedValue("SILENT");
  }
  /**
   * Re-enables the propagation of every new advertised value to the parent hub.
   * This function reverts the effect of a previous call to muteValueCallbacks().
   * Remember to call the saveToFlash() method of the module if the
   * modification must be kept.
   *
   * @return YAPI.SUCCESS when the call succeeds.
   *
   * On failure, throws an exception or returns a negative error code.
   */
  async unmuteValueCallbacks() {
    return await this.set_advertisedValue("");
  }
  /**
   * Returns the current value of a single function attribute, as a text string, as quickly as
   * possible but without using the cached value.
   *
   * @param attrName : the name of the requested attribute
   *
   * @return a string with the value of the the attribute
   *
   * On failure, throws an exception or returns an empty string.
   */
  async loadAttribute(attrName) {
    let url;
    let attrVal;
    url = "api/" + await this.get_functionId() + "/" + attrName;
    attrVal = await this._download(url);
    return this._yapi.imm_bin2str(attrVal);
  }
  /**
   * Indicates whether changes to the function are prohibited or allowed.
   * Returns true if the function is blocked by an admin password
   * or if the function is not available.
   *
   * @return true if the function is write-protected or not online.
   */
  async isReadOnly() {
    return await this.isReadOnly_internal();
  }
  /**
   * Returns the serial number of the module, as set by the factory.
   *
   * @return a string corresponding to the serial number of the module, as set by the factory.
   *
   * On failure, throws an exception or returns YFunction.SERIALNUMBER_INVALID.
   */
  async get_serialNumber() {
    let m;
    m = await this.get_module();
    return await m.get_serialNumber();
  }
  _parserHelper() {
    return 0;
  }
  /**
   * Returns the next Function
   *
   * @returns {YFunction}
   */
  nextFunction() {
    let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
    if (resolve.errorType != YAPI.SUCCESS)
      return null;
    let next_hwid = this._yapi.imm_getNextHardwareId(this._className, resolve.result);
    if (next_hwid == null)
      return null;
    return _YFunction.FindFunctionInContext(this._yapi, next_hwid);
  }
  /**
   * Retrieves the first Function in a YAPI context
   *
   * @returns {YFunction}
   */
  static FirstFunction() {
    let next_hwid = YAPI.imm_getFirstHardwareId("Function");
    if (next_hwid == null)
      return null;
    return _YFunction.FindFunction(next_hwid);
  }
  /**
   * Retrieves the first Function in a given context
   *
   * @param yctx {YAPIContext}
   *
   * @returns {YFunction}
   */
  static FirstFunctionInContext(yctx) {
    let next_hwid = yctx.imm_getFirstHardwareId("Function");
    if (next_hwid == null)
      return null;
    return _YFunction.FindFunctionInContext(yctx, next_hwid);
  }
  //--- (end of generated code: YFunction implementation)
  /** Retrieve a function instance from cache
   */
  static _FindFromCacheInContext(yctx, className, func) {
    return yctx.imm_getFunction(className, func);
  }
  /** Retrieve a function instance from cache
   */
  static _FindFromCache(className, func) {
    return YAPI.imm_getFunction(className, func);
  }
  /** Add a function instance to cache
   */
  static _AddToCache(className, func, obj) {
    obj._yapi.imm_setFunction(className, func, obj);
  }
  /** Clear the function instance cache
   */
  static _ClearCache(obj_yapi = null) {
    if (!obj_yapi)
      obj_yapi = YAPI;
    obj_yapi.imm_ResetToDefaults();
  }
  /** Add or remove a value change callback
   */
  static async _UpdateValueCallbackList(obj_func, bool_add) {
    await obj_func._yapi._UpdateValueCallbackList(obj_func, bool_add);
  }
  /** Add or remove a timed report callback
   */
  static async _UpdateTimedReportCallbackList(obj_func, bool_add) {
    await obj_func._yapi._UpdateTimedReportCallbackList(obj_func, bool_add);
  }
  /**
   * Returns a short text that describes unambiguously the instance of the function in the form
   * TYPE(NAME)=SERIAL&#46;FUNCTIONID.
   * More precisely,
   * TYPE       is the type of the function,
   * NAME       it the name used for the first access to the function,
   * SERIAL     is the serial number of the module if the module is connected or "unresolved", and
   * FUNCTIONID is  the hardware identifier of the function if the module is connected.
   * For example, this method returns Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1 if the
   * module is already connected or Relay(BadCustomeName.relay1)=unresolved if the module has
   * not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in
   * a debugger.
   *
   * @return a string that describes the function
   *         (ex: Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1)
   */
  async describe() {
    if (this._hwId != "") {
      return this._className + "(" + this._func + ")=" + this._hwId;
    }
    let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
    if (resolve.errorType != YAPI_SUCCESS && resolve.result != this._func) {
      return this._className + "(" + this._func + ")=unresolved";
    }
    return this._className + "(" + this._func + ")=" + resolve.result;
  }
  /**
   * Returns the unique hardware identifier of the function in the form SERIAL.FUNCTIONID.
   * The unique hardware identifier is composed of the device serial
   * number and of the hardware identifier of the function (for example RELAYLO1-123456.relay1).
   *
   * @return a string that uniquely identifies the function (ex: RELAYLO1-123456.relay1)
   *
   * On failure, throws an exception or returns  YFunction.HARDWAREID_INVALID.
   */
  async get_hardwareId() {
    if (this._hwId != "") {
      return this._hwId;
    }
    let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
    if (resolve.errorType != YAPI_SUCCESS) {
      await this.isOnline();
      resolve = this._yapi.imm_resolveFunction(this._className, this._func);
      if (resolve.errorType != YAPI_SUCCESS) {
        return this._throw(resolve.errorType, resolve.errorMsg, _YFunction.HARDWAREID_INVALID);
      }
    }
    return resolve.result;
  }
  /**
   * Returns the hardware identifier of the function, without reference to the module. For example
   * relay1
   *
   * @return a string that identifies the function (ex: relay1)
   *
   * On failure, throws an exception or returns  YFunction.FUNCTIONID_INVALID.
   */
  async get_functionId() {
    if (this._funId != "") {
      return this._funId;
    }
    let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
    if (resolve.errorType != YAPI_SUCCESS) {
      await this.isOnline();
      resolve = this._yapi.imm_resolveFunction(this._className, this._func);
      if (resolve.errorType != YAPI_SUCCESS) {
        return this._throw(resolve.errorType, resolve.errorMsg, _YFunction.FUNCTIONID_INVALID);
      }
    }
    let hardwareId = resolve.result;
    let pos = hardwareId.indexOf(".");
    return hardwareId.substr(pos + 1);
  }
  imm_get_functionId() {
    if (this._funId != "") {
      return this._funId;
    }
    let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
    if (resolve.errorType != YAPI_SUCCESS) {
      return this._throw(resolve.errorType, resolve.errorMsg, _YFunction.FUNCTIONID_INVALID);
    }
    let hardwareId = resolve.result;
    let pos = hardwareId.indexOf(".");
    return hardwareId.substr(pos + 1);
  }
  /**
   * Returns a global identifier of the function in the format MODULE_NAME&#46;FUNCTION_NAME.
   * The returned string uses the logical names of the module and of the function if they are defined,
   * otherwise the serial number of the module and the hardware identifier of the function
   * (for example: MyCustomName.relay1)
   *
   * @return a string that uniquely identifies the function using logical names
   *         (ex: MyCustomName.relay1)
   *
   * On failure, throws an exception or returns  YFunction.FRIENDLYNAME_INVALID.
   */
  async get_friendlyName() {
    let resolve = this._yapi.imm_getFriendlyNameFunction(this._className, this._func);
    if (resolve.errorType != YAPI_SUCCESS) {
      await this.isOnline();
      resolve = this._yapi.imm_getFriendlyNameFunction(this._className, this._func);
      if (resolve.errorType != YAPI_SUCCESS) {
        return this._throw(resolve.errorType, resolve.errorMsg, _YFunction.FRIENDLYNAME_INVALID);
      }
    }
    return resolve.result;
  }
  /** Store and parse an API request for current function
   */
  async _parse(yreq, msValidity) {
    if (!yreq.obj_result)
      return;
    yreq.obj_result._expiration = this._yapi.GetTickCount() + msValidity;
    this._cache = yreq.obj_result;
    this._serial = yreq.obj_result.deviceid;
    this._funId = yreq.obj_result.functionid;
    this._hwId = yreq.obj_result.hwid;
    for (let key in yreq.obj_result) {
      this.imm_parseAttr(key, yreq.obj_result[key]);
    }
    await this._parserHelper();
  }
  /**
       ** Helpers for built-in classes
       **
  
       // Helper for initializing standard attributes (used in particular by built-in classes)
       async _i(): Promise<void>
       {
       let arr_attrNames: string[] = this.constructor._attrList;
       this._className = this.constructor.name.slice(1);
       for(let i = 0; i < arr_attrNames.length; i++) {
       this['_'+arr_attrNames[i]] = this.constructor[arr_attrNames[i].toUpperCase()+'_INVALID'];
       }
       }
  
       // Helper for simple accessors (used in particular by built-in classes)
       async _g(str_attr): Promise<object>
       {
       if (this._cacheExpiration <= this._yapi.GetTickCount()) {
       if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
       return this.constructor[str_attr.toLocaleUpperCase()+'_INVALID'];
       }
       }
       return this['_'+str_attr];
       }
  
       // Helper for simple accessors (used in particular by built-in classes)
       async _s(str_attr, obj_val): Promise<number>
       {
       return this._setAttr(str_attr, String(obj_val));
       }
  
       // Helper for completing and exporting the class; used by built-in classes
       static _E(arr_attrlist)
       {
       let className = this.name.slice(1);
       this._attrList = arr_attrlist;
       for(let i = 0; i < arr_attrlist.length; i++) {
       let attrname = arr_attrlist[i];
       let getMethod = 'get_'+attrname;
       this.prototype[getMethod] = async function(): Promise<object> { return this._g(attrname); };
       }
       this['Find'+className] = function(func) {
       let str_classname = this.name.slice(1);
       let obj: YFunction;
       obj = YFunction._FindFromCache(str_classname, func);
       if (obj == null) {
       obj = new this(YAPI, func);
       YFunction._AddToCache(str_classname, func, obj);
       }
       return obj;
       };
       this['First'+className] = function() {
       let str_classname = this.name.slice(1);
       let next_hwid = YAPI.imm_getFirstHardwareId(str_classname);
       if(next_hwid == null) return null;
       return this['Find'+className](next_hwid);
       };
       this.prototype['next'+className] = function() {
       let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
       if(resolve.errorType != YAPI.SUCCESS) return null;
       let next_hwid = this._yapi.imm_getNextHardwareId(this._className, resolve.result);
       if(next_hwid == null) return null;
       return this.constructor['Find'+className](next_hwid);
       };
       this.imm_Init();
       }
  
       ********/
  // Backward-compatibility helper
  isOnline_async(func, ctx) {
    this.isOnline().then((res) => {
      func(ctx, this, res);
    }).catch((e) => {
      func(ctx, this, false);
    });
  }
  // Backward-compatibility helper
  load_async(ms_validiy, func, ctx) {
    this.load(ms_validiy).then((res) => {
      func(ctx, this, YAPI_SUCCESS);
    }).catch((e) => {
      func(ctx, this, this.get_errorType());
    });
  }
  /** Return the value of an attribute from function cache, after reloading it from device if needed
   * Note: the function cache is a typed (parsed) cache, contrarily to the agnostic device cache
   */
  async _getAttr(str_attr) {
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS)
        return null;
    }
    if (typeof this._cache[str_attr] == "undefined") {
      this._throw(YAPI_VERSION_MISMATCH, "No such attribute " + str_attr + " in function", null);
    }
    return this._cache[str_attr];
  }
  /** Return the value of an attribute from function cache, after reloading it from device if needed
   * Note: the function cache is a typed (parsed) cache, contrarily to the agnostic device cache
   */
  async _getFixedAttr(str_attr) {
    if (this._cacheExpiration == 0) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS)
        return null;
    }
    if (typeof this._cache[str_attr] == "undefined") {
      this._throw(YAPI_VERSION_MISMATCH, "No such attribute " + str_attr + " in function", null);
    }
    return this._cache[str_attr];
  }
  /** Escape a string for posting it as an URL
   */
  imm_escapeAttr(str_newval) {
    return escape(str_newval).replace(/[+]/g, "%2B").replace(/%20/g, "+").replace(/%21/g, "!").replace(/%24/g, "$").replace(/%27/g, "'").replace(/%28/g, "(").replace(/%29/g, ")").replace(/%2[cC]/g, ",").replace(/%2[fF]/g, "/").replace(/%3[aA]/g, ":").replace(/%3[bB]/g, ";").replace(/%3[fF]/g, "?").replace(/%5[bB]/g, "[").replace(/%5[dD]/g, "]");
  }
  /** Change the value of an attribute on a device, and invalidate the cache
   */
  async _setAttr(str_attr, str_newval) {
    if (str_newval == void 0) {
      return this._throw(YAPI_INVALID_ARGUMENT, "Undefined value to set for attribute " + str_attr, null);
    }
    let attrname = encodeURIComponent(str_attr);
    let attrval = this.imm_escapeAttr(str_newval);
    let extra = "/" + attrname + "?" + attrname + "=" + attrval + "&.";
    if (this._cacheExpiration != 0) {
      this._cacheExpiration = this._yapi.GetTickCount();
      this._cache._expiration = this._cacheExpiration;
    }
    let yreq = await this._yapi.funcRequest(this._className, this._func, extra);
    if (yreq.errorType != YAPI_SUCCESS) {
      return this._throw(yreq.errorType, yreq.errorMsg, yreq.errorType);
    }
    return YAPI_SUCCESS;
  }
  /** Execute an arbitrary HTTP GET request on the device and return the binary content
   */
  async _download(str_path) {
    let devid = this._serial;
    if (devid == "") {
      devid = await (await this.module()).get_serialNumber();
    }
    if (devid == YAPI_INVALID_STRING) {
      return new Uint8Array(0);
    }
    let yreq = await this._yapi.devRequest(devid, "GET /" + str_path, null, 0);
    if (yreq.errorType != YAPI_SUCCESS) {
      return this._throw(yreq.errorType, yreq.errorMsg, "");
    }
    return yreq.bin_result;
  }
  /** Execute an out-of-band HTTP GET request on the device and return the binary content.
   * The request may execute in parallel to regular requests currently in progress.
   */
  async _downloadOutOfBand(str_path) {
    let devid = this._serial;
    if (devid == "") {
      devid = await (await this.module()).get_serialNumber();
    }
    if (devid == YAPI_INVALID_STRING) {
      return new Uint8Array(0);
    }
    let yreq = await this._yapi.devRequest(devid, "GET /" + str_path, null, 1);
    if (yreq.errorType != YAPI_SUCCESS) {
      return this._throw(yreq.errorType, yreq.errorMsg, "");
    }
    return yreq.bin_result;
  }
  /** Upload a file to the filesystem, to the specified full path name.
   * If a file already exists with the same path name, its content is overwritten.
   * The progress callback function is called with two parameters: the number of
   * bytes uploaded so far and the total size to be uploaded.
   */
  async _uploadWithProgress(str_path, bin_content, fun_progressCb) {
    let devid = this._serial;
    if (devid == "") {
      devid = await (await this.module()).get_serialNumber();
    }
    if (devid == YAPI_INVALID_STRING) {
      let res = new YHTTPRequest(null);
      res.errorType = this.get_errorType();
      res.errorMsg = this.get_errorMessage();
      return res;
    }
    let httpreq = "POST /upload.html";
    let len = bin_content.length;
    if (typeof bin_content == "string" || bin_content instanceof String) {
      bin_content = this._yapi.imm_str2bin(bin_content);
    } else if (bin_content instanceof Array) {
      bin_content = new Uint8Array(bin_content);
    }
    return this._yapi.devRequest(devid, httpreq, new YHTTPBody(str_path, bin_content, fun_progressCb), 0);
  }
  /** Upload a file to the filesystem, to the specified full path name.
   * If a file already exists with the same path name, its content is overwritten.
   * The progress callback function is called with two parameters: the number of
   * bytes uploaded so far and the total size to be uploaded.
   */
  async _uploadEx(str_path, bin_content) {
    let yreq = await this._uploadWithProgress(str_path, bin_content, null);
    if (yreq.errorType != YAPI_SUCCESS) {
      return this._throw(yreq.errorType, yreq.errorMsg, null);
    }
    return yreq.bin_result;
  }
  /** Upload a file to the filesystem, to the specified full path name.
   * If a file already exists with the same path name, its content is overwritten.
   */
  async _upload(str_path, bin_content) {
    let yreq = await this._uploadWithProgress(str_path, bin_content, null);
    if (yreq.errorType != YAPI_SUCCESS) {
      return this._throw(yreq.errorType, yreq.errorMsg, null);
    }
    return yreq.errorType;
  }
  /**
   * Waits for all pending asynchronous commands on the module to complete, and invoke
   * the user-provided callback function. The callback function can therefore freely
   * issue synchronous or asynchronous commands, without risking to block the
   * JavaScript VM.
   *
   * @param callback : callback function that is invoked when all pending commands on
   *         the module are completed.
   *         The callback function receives two arguments: the caller-specific
   *         context object and the receiving function object.
   * @param context : caller-specific object that is passed as-is to the callback function
   *
   * @return nothing.
   */
  wait_async(callback, context) {
    let devid = this._serial;
    if (devid == "") {
      this.module().then((module) => module.get_serialNumber().then(() => this.wait_async(callback, context)));
      return YAPI_SUCCESS;
    }
    if (devid == YAPI_INVALID_STRING) {
      callback(context, this);
      return YAPI_SUCCESS;
    }
    let lockdev = this._yapi.imm_getDevice(devid);
    let delayedCode = (() => {
      callback(context, this);
    });
    lockdev._pendingQueries = lockdev._pendingQueries.then(delayedCode, delayedCode);
    return YAPI_SUCCESS;
  }
  /** Get a value from a JSON buffer
   **/
  imm_json_get_key(bin_jsonbuff, str_key) {
    let loadval = JSON.parse(this._yapi.imm_bin2str(bin_jsonbuff));
    if (typeof loadval[str_key] != "undefined") {
      return loadval[str_key];
    }
    return "";
  }
  /** Get a string from a JSON buffer
   **/
  imm_json_get_string(bin_jsonbuff) {
    return JSON.parse(this._yapi.imm_bin2str(bin_jsonbuff));
  }
  /** Get an array of strings from a JSON buffer
   **/
  imm_json_get_array(bin_jsonbuff) {
    let loadval = JSON.parse(this._yapi.imm_bin2str(bin_jsonbuff));
    let res = [];
    for (let idx in loadval) {
      res.push(this._yapi.imm_str2bin(JSON.stringify(loadval[idx])));
    }
    return res;
  }
  /** Get an array of strings from a JSON buffer
   **/
  imm_get_json_path(bin_json, str_path) {
    let json = JSON.parse(this._yapi.imm_bin2str(bin_json));
    let paths = str_path.split("|");
    for (let i = 0; i < paths.length; i++) {
      let tmp = paths[i];
      json = json[tmp];
      if (json == void 0) {
        return new Uint8Array();
      }
    }
    return this._yapi.imm_str2bin(JSON.stringify(json));
  }
  /** Get a string from a JSON string
   **/
  imm_decode_json_string(bin_json) {
    if (bin_json.length == 0) {
      return "";
    }
    return JSON.parse(this._yapi.imm_bin2str(bin_json));
  }
  /** Get a integer from a JSON string
   **/
  imm_decode_json_int(bin_json) {
    if (bin_json.length == 0) {
      return 0;
    }
    return JSON.parse(this._yapi.imm_bin2str(bin_json));
  }
  // Method used to cache DataStream objects (new DataLogger)
  //
  /** Method used to cache DataStream objects (new DataLogger)
   **/
  imm_findDataStream(obj_dataset, str_def) {
    let key = obj_dataset.imm_get_functionId() + ":" + str_def;
    if (this._dataStreams[key]) {
      return this._dataStreams[key];
    }
    let words = this._yapi.imm_decodeWords(str_def);
    if (words.length < 14) {
      this._throw(YAPI.VERSION_MISMATCH, "device firwmare is too old", null);
      return null;
    }
    let newDataStream = new YDataStream(this, obj_dataset, words);
    this._dataStreams[key] = newDataStream;
    return newDataStream;
  }
  // Method used to clear cache of DataStream object (undocumented)
  async clearDataStreamCache() {
    this._dataStreams = {};
  }
  /**
   * Checks if the function is currently reachable, without raising any error.
   * If there is a cached value for the function in cache, that has not yet
   * expired, the device is considered reachable.
   * No exception is raised if there is an error while trying to contact the
   * device hosting the function.
   *
   * @return true if the function can be reached, and false otherwise
   */
  async isOnline() {
    if (this._cacheExpiration > this._yapi.GetTickCount())
      return true;
    let yreq = await this._yapi.funcRequest(this._className, this._func, "", this._yapi.defaultCacheValidity);
    if (yreq.errorType != YAPI_SUCCESS) {
      return yreq.errorType == YAPI_DEVICE_BUSY;
    }
    await this._parse(yreq, this._yapi.defaultCacheValidity);
    return true;
  }
  /**
   * Returns the numerical error code of the latest error with the function.
   * This method is mostly useful when using the Yoctopuce library with
   * exceptions disabled.
   *
   * @return a number corresponding to the code of the latest error that occurred while
   *         using the function object
   */
  get_errorType() {
    return this._lastErrorType;
  }
  /**
   * Returns the error message of the latest error with the function.
   * This method is mostly useful when using the Yoctopuce library with
   * exceptions disabled.
   *
   * @return a string corresponding to the latest error message that occured while
   *         using the function object
   */
  get_errorMessage() {
    return this._lastErrorMsg;
  }
  /**
   * Preloads the function cache with a specified validity duration.
   * By default, whenever accessing a device, all function attributes
   * are kept in cache for the standard duration (5 ms). This method can be
   * used to temporarily mark the cache as valid for a longer period, in order
   * to reduce network traffic for instance.
   *
   * @param msValidity : an integer corresponding to the validity attributed to the
   *         loaded function parameters, in milliseconds
   *
   * @return YAPI.SUCCESS when the call succeeds.
   *
   * On failure, throws an exception or returns a negative error code.
   */
  async load(msValidity) {
    let yreq = await this._yapi.funcRequest(this._className, this._func, "", msValidity);
    if (yreq.errorType != YAPI_SUCCESS) {
      return this._throw(yreq.errorType, yreq.errorMsg, yreq.errorType);
    }
    await this._parse(yreq, msValidity);
    return YAPI_SUCCESS;
  }
  /**
   * Invalidates the cache. Invalidates the cache of the function attributes. Forces the
   * next call to get_xxx() or loadxxx() to use values that come from the device.
   *
   * @noreturn
   */
  async clearCache() {
    let devreq = await this._yapi._funcDev(this._className, this._func);
    if (devreq.errorType != YAPI_SUCCESS) {
      return;
    }
    devreq.obj_result.device.imm_dropCache();
    if (this._cacheExpiration > 0) {
      this._cacheExpiration = this._yapi.GetTickCount();
    }
  }
  /**
   * Gets the YModule object for the device on which the function is located.
   * If the function cannot be located on any module, the returned instance of
   * YModule is not shown as on-line.
   *
   * @return {YModule} an instance of YModule
   */
  async module() {
    if (this._serial != "") {
      return YModule.FindModuleInContext(this._yapi, this._serial + ".module");
    }
    let hwid = this._func;
    let resolve;
    if (hwid.indexOf(".") < 0) {
      resolve = this._yapi.imm_resolveFunction(this._className, this._func);
      if (resolve.errorType == YAPI_SUCCESS)
        hwid = resolve.result;
    }
    let dotidx = hwid.indexOf(".");
    if (dotidx >= 0) {
      return YModule.FindModuleInContext(this._yapi, hwid.substr(0, dotidx) + ".module");
    }
    if (await this.load(this._yapi.defaultCacheValidity) == YAPI_SUCCESS) {
      resolve = this._yapi.imm_resolveFunction(this._className, this._func);
      if (resolve.result)
        hwid = resolve.result;
    }
    dotidx = hwid.indexOf(".");
    if (dotidx >= 0) {
      return YModule.FindModuleInContext(this._yapi, hwid.substr(0, dotidx) + ".module");
    }
    return YModule.FindModuleInContext(this._yapi, "module_of_" + this._className + "_" + this._func);
  }
  /**
   * Gets the YModule object for the device on which the function is located.
   * If the function cannot be located on any module, the returned instance of
   * YModule is not shown as on-line.
   *
   * @return an instance of YModule
   */
  async get_module() {
    return this.module();
  }
  /**
   * Returns a unique identifier of type YFUN_DESCR corresponding to the function.
   * This identifier can be used to test if two instances of YFunction reference the same
   * physical function on the same physical device.
   *
   * @return an identifier of type YFUN_DESCR.
   *
   * If the function has never been contacted, the returned value is Y$CLASSNAME$.FUNCTIONDESCRIPTOR_INVALID.
   */
  async get_functionDescriptor() {
    if (this._hwId != "") {
      return this._hwId;
    }
    let hwid = this._func;
    if (hwid.indexOf(".") < 0) {
      let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
      if (resolve.errorType != YAPI_SUCCESS)
        hwid = resolve.result;
    }
    let dotidx = hwid.indexOf(".");
    if (dotidx >= 0) {
      return hwid;
    }
    return Y_FUNCTIONDESCRIPTOR_INVALID;
  }
  /**
   * Returns the value of the userData attribute, as previously stored using method
   * set_userData.
   * This attribute is never touched directly by the API, and is at disposal of the caller to
   * store a context.
   *
   * @return the object stored previously by the caller.
   */
  async get_userData() {
    return this._userData;
  }
  /**
   * Stores a user context provided as argument in the userData attribute of the function.
   * This attribute is never touched by the API, and is at disposal of the caller to store a context.
   *
   * @param data : any kind of object to be stored
   * @noreturn
   */
  async set_userData(data) {
    this._userData = data;
  }
};
YFunction.LOGICALNAME_INVALID = YAPI_INVALID_STRING;
YFunction.ADVERTISEDVALUE_INVALID = YAPI_INVALID_STRING;
(function(YFunction2) {
  YFunction2.FUNCTIONDESCRIPTOR_INVALID = YAPI_INVALID_STRING;
  YFunction2.HARDWAREID_INVALID = YAPI_INVALID_STRING;
  YFunction2.FUNCTIONID_INVALID = YAPI_INVALID_STRING;
  YFunction2.FRIENDLYNAME_INVALID = YAPI_INVALID_STRING;
})(YFunction || (YFunction = {}));
var YModule = class _YModule extends YFunction {
  //--- (end of generated code: YModule attributes declaration)
  constructor(yapi, func) {
    super(yapi, func);
    this._productName = _YModule.PRODUCTNAME_INVALID;
    this._serialNumber = _YModule.SERIALNUMBER_INVALID;
    this._productId = _YModule.PRODUCTID_INVALID;
    this._productRelease = _YModule.PRODUCTRELEASE_INVALID;
    this._firmwareRelease = _YModule.FIRMWARERELEASE_INVALID;
    this._persistentSettings = _YModule.PERSISTENTSETTINGS_INVALID;
    this._luminosity = _YModule.LUMINOSITY_INVALID;
    this._beacon = _YModule.BEACON_INVALID;
    this._upTime = _YModule.UPTIME_INVALID;
    this._usbCurrent = _YModule.USBCURRENT_INVALID;
    this._rebootCountdown = _YModule.REBOOTCOUNTDOWN_INVALID;
    this._userVar = _YModule.USERVAR_INVALID;
    this._valueCallbackModule = null;
    this._logCallback = null;
    this._confChangeCallback = null;
    this._beaconCallback = null;
    this.PRODUCTNAME_INVALID = YAPI_INVALID_STRING;
    this.SERIALNUMBER_INVALID = YAPI_INVALID_STRING;
    this.PRODUCTID_INVALID = YAPI_INVALID_UINT;
    this.PRODUCTRELEASE_INVALID = YAPI_INVALID_UINT;
    this.FIRMWARERELEASE_INVALID = YAPI_INVALID_STRING;
    this.PERSISTENTSETTINGS_LOADED = 0;
    this.PERSISTENTSETTINGS_SAVED = 1;
    this.PERSISTENTSETTINGS_MODIFIED = 2;
    this.PERSISTENTSETTINGS_INVALID = -1;
    this.LUMINOSITY_INVALID = YAPI_INVALID_UINT;
    this.BEACON_OFF = 0;
    this.BEACON_ON = 1;
    this.BEACON_INVALID = -1;
    this.UPTIME_INVALID = YAPI_INVALID_LONG;
    this.USBCURRENT_INVALID = YAPI_INVALID_UINT;
    this.REBOOTCOUNTDOWN_INVALID = YAPI_INVALID_INT;
    this.USERVAR_INVALID = YAPI_INVALID_INT;
    this._className = "Module";
    let devid = this._func;
    let dotidx = devid.indexOf(".");
    if (dotidx > 0)
      devid = devid.substr(0, dotidx);
    let dev = this._yapi.imm_getDevice(devid);
    if (dev) {
      this._serial = dev.imm_getSerialNumber();
      this._funId = "module";
      this._hwId = this._serial + ".module";
    }
  }
  _throw(int_errType, str_errMsg, obj_retVal) {
    this._lastErrorType = int_errType;
    this._lastErrorMsg = str_errMsg;
    return this._yapi._throw(int_errType, str_errMsg, obj_retVal);
  }
  static async _updateModuleCallbackList(YModule_module, bool_add) {
  }
  /** Return the internal device object hosting the function
   *
   * @return {YDevice}
   *
   * Raise an error if not found
   */
  imm_getDev() {
    let devid = this._func;
    let dotidx = devid.indexOf(".");
    if (dotidx > 0)
      devid = devid.substr(0, dotidx);
    let dev = this._yapi.imm_getDevice(devid);
    if (!dev) {
      this._throw(YAPI_DEVICE_NOT_FOUND, "Device [" + devid + "] is not online", null);
    }
    return dev;
  }
  /**
   * Forces a full redetection of the device, in case the functions changed
   *
   * @noreturn
   */
  async forceDeviceRefresh() {
    let dev = this.imm_getDev();
    if (!dev || !this._serial)
      return;
    await this._yapi.ForceDeviceRefresh(this._serial);
    if (this._cacheExpiration > 0) {
      this._cacheExpiration = this._yapi.GetTickCount();
    }
  }
  /**
   * Returns the number of functions (beside the "module" interface) available on the module.
   *
   * @return the number of functions on the module
   *
   * On failure, throws an exception or returns a negative error code.
   */
  async functionCount() {
    let dev = this.imm_getDev();
    if (!dev)
      return YAPI_DEVICE_NOT_FOUND;
    return dev.imm_functionCount();
  }
  /**
   * Retrieves the hardware identifier of the <i>n</i>th function on the module.
   *
   * @param functionIndex : the index of the function for which the information is desired, starting at
   * 0 for the first function.
   *
   * @return a string corresponding to the unambiguous hardware identifier of the requested module function
   *
   * On failure, throws an exception or returns an empty string.
   */
  async functionId(functionIndex) {
    let dev = this.imm_getDev();
    if (!dev)
      return "";
    return dev.imm_functionId(functionIndex);
  }
  /**
   * Retrieves the type of the <i>n</i>th function on the module. Yoctopuce functions type names match
   * their class names without the <i>Y</i> prefix, for instance <i>Relay</i>, <i>Temperature</i> etc..
   *
   * @param functionIndex : the index of the function for which the information is desired, starting at
   * 0 for the first function.
   *
   * @return a string corresponding to the type of the function.
   *
   * On failure, throws an exception or returns an empty string.
   */
  async functionType(functionIndex) {
    let dev = this.imm_getDev();
    if (!dev)
      return "";
    return dev.imm_functionType(functionIndex);
  }
  /**
   * Retrieves the base type of the <i>n</i>th function on the module.
   * For instance, the base type of all measuring functions is "Sensor".
   *
   * @param functionIndex : the index of the function for which the information is desired, starting at
   * 0 for the first function.
   *
   * @return a string corresponding to the base type of the function
   *
   * On failure, throws an exception or returns an empty string.
   */
  async functionBaseType(functionIndex) {
    let dev = this.imm_getDev();
    if (!dev)
      return "";
    return dev.imm_functionBaseType(functionIndex);
  }
  /**
   * Retrieves the logical name of the <i>n</i>th function on the module.
   *
   * @param functionIndex : the index of the function for which the information is desired, starting at
   * 0 for the first function.
   *
   * @return a string corresponding to the logical name of the requested module function
   *
   * On failure, throws an exception or returns an empty string.
   */
  async functionName(functionIndex) {
    let dev = this.imm_getDev();
    if (!dev)
      return "";
    return dev.imm_functionName(functionIndex);
  }
  /**
   * Retrieves the advertised value of the <i>n</i>th function on the module.
   *
   * @param functionIndex : the index of the function for which the information is desired, starting at
   * 0 for the first function.
   *
   * @return a short string (up to 6 characters) corresponding to the advertised value of the requested
   * module function
   *
   * On failure, throws an exception or returns an empty string.
   */
  async functionValue(functionIndex) {
    let dev = this.imm_getDev();
    if (!dev)
      return "";
    return dev.imm_functionValue(functionIndex);
  }
  /**
   * Returns the logical name of the module.
   *
   * @return a string corresponding to the logical name of the module
   *
   * On failure, throws an exception or returns YModule.LOGICALNAME_INVALID.
   */
  async get_logicalName() {
    let dev = this.imm_getDev();
    if (dev != null && this._cache._expiration <= this._yapi.GetTickCount()) {
      return dev.getLogicalName();
    }
    let json_val = await this._getAttr("logicalName");
    return json_val == null ? _YModule.LOGICALNAME_INVALID : json_val;
  }
  async set_logicalName(newval) {
    let res = await super.set_logicalName(newval);
    let dev = this.imm_getDev();
    if (dev != null) {
      dev.imm_dropCache();
    }
    return res;
  }
  imm_flattenJsonStruct_internal(jsoncomplex) {
    let decoded = JSON.parse(this._yapi.imm_bin2str(jsoncomplex));
    let attrs = [];
    for (let function_name in decoded) {
      if (function_name == "services") {
        continue;
      }
      let function_attrs = decoded[function_name];
      for (let attr_name in function_attrs) {
        let attr_value = function_attrs[attr_name];
        if (attr_value === null || typeof attr_value === "object") {
          continue;
        }
        let flat = function_name + "/" + attr_name + "=" + attr_value;
        attrs.push(flat);
      }
    }
    return this._yapi.imm_str2bin(JSON.stringify(attrs));
  }
  async get_subDevices_internal() {
    let baseUrl = await this.get_url_internal();
    if (!baseUrl) {
      return [];
    }
    let hub = null;
    let hubUrl = "";
    for (let i = 0; i < this._yapi._connectedHubs.length; i++) {
      hubUrl = this._yapi._connectedHubs[i].imm_getRootUrl();
      if (baseUrl.slice(0, hubUrl.length) == hubUrl) {
        hub = this._yapi._connectedHubs[i];
        break;
      }
    }
    if (!hub || !hubUrl) {
      return [];
    }
    let hubSerial = hub.serialByYdx[0];
    if (hubSerial != this._serial) {
      return [];
    }
    let res = [];
    for (let serial in this._yapi._devs) {
      let rooturl = this._yapi._devs[serial].imm_getRootUrl();
      if (rooturl.substr(0, hubUrl.length) == hubUrl && serial != hubSerial) {
        res.push(serial);
      }
    }
    return res;
  }
  async get_parentHub_internal() {
    let baseUrl = await this.get_url_internal();
    if (!baseUrl) {
      return "";
    }
    let hub = null;
    for (let i = 0; i < this._yapi._connectedHubs.length; i++) {
      let hubUrl = this._yapi._connectedHubs[i].imm_getRootUrl();
      if (baseUrl.slice(0, hubUrl.length) == hubUrl) {
        hub = this._yapi._connectedHubs[i];
        break;
      }
    }
    if (!hub) {
      return "";
    }
    let hubSerial = hub.serialByYdx[0];
    if (hubSerial == this._serial) {
      return "";
    }
    return hubSerial;
  }
  async get_url_internal() {
    let devid = this._serial;
    if (devid == "") {
      devid = await this.get_serialNumber();
    }
    if (devid == YAPI_INVALID_STRING) {
      return "";
    }
    let lockdev = this._yapi.imm_getDevice(devid);
    if (!lockdev) {
      return "";
    }
    return lockdev.imm_getRootUrl();
  }
  async _startStopDevLog_internal(str_serial, bool_start) {
    let dev = this.imm_getDev();
    if (dev != null) {
      return dev.imm_registerLogCallback(this._logCallback);
    }
  }
  //--- (generated code: YModule implementation)
  imm_parseAttr(name, val) {
    switch (name) {
      case "productName":
        this._productName = val;
        return 1;
      case "serialNumber":
        this._serialNumber = val;
        return 1;
      case "productId":
        this._productId = val;
        return 1;
      case "productRelease":
        this._productRelease = val;
        return 1;
      case "firmwareRelease":
        this._firmwareRelease = val;
        return 1;
      case "persistentSettings":
        this._persistentSettings = val;
        return 1;
      case "luminosity":
        this._luminosity = val;
        return 1;
      case "beacon":
        this._beacon = val;
        return 1;
      case "upTime":
        this._upTime = val;
        return 1;
      case "usbCurrent":
        this._usbCurrent = val;
        return 1;
      case "rebootCountdown":
        this._rebootCountdown = val;
        return 1;
      case "userVar":
        this._userVar = val;
        return 1;
    }
    return super.imm_parseAttr(name, val);
  }
  /**
   * Returns the commercial name of the module, as set by the factory.
   *
   * @return a string corresponding to the commercial name of the module, as set by the factory
   *
   * On failure, throws an exception or returns YModule.PRODUCTNAME_INVALID.
   */
  async get_productName() {
    let res;
    let dev;
    if (this._cacheExpiration == 0) {
      dev = this.imm_getDev();
      if (!(dev == null)) {
        return dev.imm_getProductName();
      }
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return _YModule.PRODUCTNAME_INVALID;
      }
    }
    res = this._productName;
    return res;
  }
  /**
   * Returns the serial number of the module, as set by the factory.
   *
   * @return a string corresponding to the serial number of the module, as set by the factory
   *
   * On failure, throws an exception or returns YModule.SERIALNUMBER_INVALID.
   */
  async get_serialNumber() {
    let res;
    let dev;
    if (this._cacheExpiration == 0) {
      dev = this.imm_getDev();
      if (!(dev == null)) {
        return dev.imm_getSerialNumber();
      }
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return _YModule.SERIALNUMBER_INVALID;
      }
    }
    res = this._serialNumber;
    return res;
  }
  /**
   * Returns the USB device identifier of the module.
   *
   * @return an integer corresponding to the USB device identifier of the module
   *
   * On failure, throws an exception or returns YModule.PRODUCTID_INVALID.
   */
  async get_productId() {
    let res;
    let dev;
    if (this._cacheExpiration == 0) {
      dev = this.imm_getDev();
      if (!(dev == null)) {
        return dev.imm_getProductId();
      }
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return _YModule.PRODUCTID_INVALID;
      }
    }
    res = this._productId;
    return res;
  }
  /**
   * Returns the release number of the module hardware, preprogrammed at the factory.
   * The original hardware release returns value 1, revision B returns value 2, etc.
   *
   * @return an integer corresponding to the release number of the module hardware, preprogrammed at the factory
   *
   * On failure, throws an exception or returns YModule.PRODUCTRELEASE_INVALID.
   */
  async get_productRelease() {
    let res;
    if (this._cacheExpiration == 0) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return _YModule.PRODUCTRELEASE_INVALID;
      }
    }
    res = this._productRelease;
    return res;
  }
  /**
   * Returns the version of the firmware embedded in the module.
   *
   * @return a string corresponding to the version of the firmware embedded in the module
   *
   * On failure, throws an exception or returns YModule.FIRMWARERELEASE_INVALID.
   */
  async get_firmwareRelease() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return _YModule.FIRMWARERELEASE_INVALID;
      }
    }
    res = this._firmwareRelease;
    return res;
  }
  /**
   * Returns the current state of persistent module settings.
   *
   * @return a value among YModule.PERSISTENTSETTINGS_LOADED, YModule.PERSISTENTSETTINGS_SAVED and
   * YModule.PERSISTENTSETTINGS_MODIFIED corresponding to the current state of persistent module settings
   *
   * On failure, throws an exception or returns YModule.PERSISTENTSETTINGS_INVALID.
   */
  async get_persistentSettings() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return _YModule.PERSISTENTSETTINGS_INVALID;
      }
    }
    res = this._persistentSettings;
    return res;
  }
  async set_persistentSettings(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("persistentSettings", rest_val);
  }
  /**
   * Returns the luminosity of the  module informative LEDs (from 0 to 100).
   *
   * @return an integer corresponding to the luminosity of the  module informative LEDs (from 0 to 100)
   *
   * On failure, throws an exception or returns YModule.LUMINOSITY_INVALID.
   */
  async get_luminosity() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return _YModule.LUMINOSITY_INVALID;
      }
    }
    res = this._luminosity;
    return res;
  }
  /**
   * Changes the luminosity of the module informative leds. The parameter is a
   * value between 0 and 100.
   * Remember to call the saveToFlash() method of the module if the
   * modification must be kept.
   *
   * @param newval : an integer corresponding to the luminosity of the module informative leds
   *
   * @return YAPI.SUCCESS if the call succeeds.
   *
   * On failure, throws an exception or returns a negative error code.
   */
  async set_luminosity(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("luminosity", rest_val);
  }
  /**
   * Returns the state of the localization beacon.
   *
   * @return either YModule.BEACON_OFF or YModule.BEACON_ON, according to the state of the localization beacon
   *
   * On failure, throws an exception or returns YModule.BEACON_INVALID.
   */
  async get_beacon() {
    let res;
    let dev;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      dev = this.imm_getDev();
      if (!(dev == null)) {
        return dev.imm_getBeacon();
      }
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return _YModule.BEACON_INVALID;
      }
    }
    res = this._beacon;
    return res;
  }
  /**
   * Turns on or off the module localization beacon.
   *
   * @param newval : either YModule.BEACON_OFF or YModule.BEACON_ON
   *
   * @return YAPI.SUCCESS if the call succeeds.
   *
   * On failure, throws an exception or returns a negative error code.
   */
  async set_beacon(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("beacon", rest_val);
  }
  /**
   * Returns the number of milliseconds spent since the module was powered on.
   *
   * @return an integer corresponding to the number of milliseconds spent since the module was powered on
   *
   * On failure, throws an exception or returns YModule.UPTIME_INVALID.
   */
  async get_upTime() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return _YModule.UPTIME_INVALID;
      }
    }
    res = this._upTime;
    return res;
  }
  /**
   * Returns the current consumed by the module on the USB bus, in milli-amps.
   *
   * @return an integer corresponding to the current consumed by the module on the USB bus, in milli-amps
   *
   * On failure, throws an exception or returns YModule.USBCURRENT_INVALID.
   */
  async get_usbCurrent() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return _YModule.USBCURRENT_INVALID;
      }
    }
    res = this._usbCurrent;
    return res;
  }
  /**
   * Returns the remaining number of seconds before the module restarts, or zero when no
   * reboot has been scheduled.
   *
   * @return an integer corresponding to the remaining number of seconds before the module restarts, or zero when no
   *         reboot has been scheduled
   *
   * On failure, throws an exception or returns YModule.REBOOTCOUNTDOWN_INVALID.
   */
  async get_rebootCountdown() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return _YModule.REBOOTCOUNTDOWN_INVALID;
      }
    }
    res = this._rebootCountdown;
    return res;
  }
  async set_rebootCountdown(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("rebootCountdown", rest_val);
  }
  /**
   * Returns the value previously stored in this attribute.
   * On startup and after a device reboot, the value is always reset to zero.
   *
   * @return an integer corresponding to the value previously stored in this attribute
   *
   * On failure, throws an exception or returns YModule.USERVAR_INVALID.
   */
  async get_userVar() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return _YModule.USERVAR_INVALID;
      }
    }
    res = this._userVar;
    return res;
  }
  /**
   * Stores a 32 bit value in the device RAM. This attribute is at programmer disposal,
   * should he need to store a state variable.
   * On startup and after a device reboot, the value is always reset to zero.
   *
   * @param newval : an integer
   *
   * @return YAPI.SUCCESS if the call succeeds.
   *
   * On failure, throws an exception or returns a negative error code.
   */
  async set_userVar(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("userVar", rest_val);
  }
  /**
   * Allows you to find a module from its serial number or from its logical name.
   *
   * This function does not require that the module is online at the time
   * it is invoked. The returned object is nevertheless valid.
   * Use the method YModule.isOnline() to test if the module is
   * indeed online at a given time. In case of ambiguity when looking for
   * a module by logical name, no error is notified: the first instance
   * found is returned. The search is performed first by hardware name,
   * then by logical name.
   *
   *
   * If a call to this object's is_online() method returns FALSE although
   * you are certain that the device is plugged, make sure that you did
   * call registerHub() at application initialization time.
   *
   * @param func : a string containing either the serial number or
   *         the logical name of the desired module
   *
   * @return a YModule object allowing you to drive the module
   *         or get additional information on the module.
   */
  static FindModule(func) {
    let obj;
    let cleanHwId;
    let modpos;
    cleanHwId = func;
    modpos = func.indexOf(".module");
    if (modpos != func.length - 7) {
      cleanHwId = func + ".module";
    }
    obj = YFunction._FindFromCache("Module", cleanHwId);
    if (obj == null) {
      obj = new _YModule(YAPI, cleanHwId);
      YFunction._AddToCache("Module", cleanHwId, obj);
    }
    return obj;
  }
  /**
   * Retrieves a module for a given identifier in a YAPI context.
   * The identifier can be specified using several formats:
   *
   * - FunctionLogicalName
   * - ModuleSerialNumber.FunctionIdentifier
   * - ModuleSerialNumber.FunctionLogicalName
   * - ModuleLogicalName.FunctionIdentifier
   * - ModuleLogicalName.FunctionLogicalName
   *
   *
   * This function does not require that the module is online at the time
   * it is invoked. The returned object is nevertheless valid.
   * Use the method YModule.isOnline() to test if the module is
   * indeed online at a given time. In case of ambiguity when looking for
   * a module by logical name, no error is notified: the first instance
   * found is returned. The search is performed first by hardware name,
   * then by logical name.
   *
   * @param yctx : a YAPI context
   * @param func : a string that uniquely characterizes the module, for instance
   *         MyDevice.module.
   *
   * @return a YModule object allowing you to drive the module.
   */
  static FindModuleInContext(yctx, func) {
    let obj;
    let cleanHwId;
    let modpos;
    cleanHwId = func;
    modpos = func.indexOf(".module");
    if (modpos != func.length - 7) {
      cleanHwId = func + ".module";
    }
    obj = YFunction._FindFromCacheInContext(yctx, "Module", cleanHwId);
    if (obj == null) {
      obj = new _YModule(yctx, cleanHwId);
      YFunction._AddToCache("Module", cleanHwId, obj);
    }
    return obj;
  }
  /**
   * Registers the callback function that is invoked on every change of advertised value.
   * The callback is invoked only during the execution of ySleep or yHandleEvents.
   * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
   * one of these two functions periodically. To unregister a callback, pass a null pointer as argument.
   *
   * @param callback : the callback function to call, or a null pointer. The callback function should take two
   *         arguments: the function object of which the value has changed, and the character string describing
   *         the new advertised value.
   * @noreturn
   */
  async registerValueCallback(callback) {
    let val;
    if (callback != null) {
      await YFunction._UpdateValueCallbackList(this, true);
    } else {
      await YFunction._UpdateValueCallbackList(this, false);
    }
    this._valueCallbackModule = callback;
    if (callback != null && await this.isOnline()) {
      val = this._advertisedValue;
      if (!(val == "")) {
        await this._invokeValueCallback(val);
      }
    }
    return 0;
  }
  async _invokeValueCallback(value) {
    if (this._valueCallbackModule != null) {
      try {
        await this._valueCallbackModule(this, value);
      } catch (e) {
        this._yapi.imm_log("Exception in valueCallback:", e);
      }
    } else {
      await super._invokeValueCallback(value);
    }
    return 0;
  }
  async get_productNameAndRevision() {
    let prodname;
    let prodrel;
    let fullname;
    prodname = await this.get_productName();
    prodrel = await this.get_productRelease();
    if (prodrel > 1) {
      fullname = prodname + " rev. " + String.fromCharCode(64 + prodrel);
    } else {
      fullname = prodname;
    }
    return fullname;
  }
  /**
   * Saves current settings in the nonvolatile memory of the module.
   * Warning: the number of allowed save operations during a module life is
   * limited (about 100000 cycles). Do not call this function within a loop.
   *
   * @return YAPI.SUCCESS when the call succeeds.
   *
   * On failure, throws an exception or returns a negative error code.
   */
  async saveToFlash() {
    return await this.set_persistentSettings(
      1
      /* YModule.PERSISTENTSETTINGS.SAVED */
    );
  }
  /**
   * Reloads the settings stored in the nonvolatile memory, as
   * when the module is powered on.
   *
   * @return YAPI.SUCCESS when the call succeeds.
   *
   * On failure, throws an exception or returns a negative error code.
   */
  async revertFromFlash() {
    return await this.set_persistentSettings(
      0
      /* YModule.PERSISTENTSETTINGS.LOADED */
    );
  }
  /**
   * Schedules a simple module reboot after the given number of seconds.
   *
   * @param secBeforeReboot : number of seconds before rebooting
   *
   * @return YAPI.SUCCESS when the call succeeds.
   *
   * On failure, throws an exception or returns a negative error code.
   */
  async reboot(secBeforeReboot) {
    return await this.set_rebootCountdown(secBeforeReboot);
  }
  /**
   * Schedules a module reboot into special firmware update mode.
   *
   * @param secBeforeReboot : number of seconds before rebooting
   *
   * @return YAPI.SUCCESS when the call succeeds.
   *
   * On failure, throws an exception or returns a negative error code.
   */
  async triggerFirmwareUpdate(secBeforeReboot) {
    return await this.set_rebootCountdown(-secBeforeReboot);
  }
  async _startStopDevLog(serial, start) {
    return await this._startStopDevLog_internal(serial, start);
  }
  /**
   * Registers a device log callback function. This callback will be called each time
   * that a module sends a new log message. Mostly useful to debug a Yoctopuce module.
   *
   * @param callback : the callback function to call, or a null pointer.
   *         The callback function should take two
   *         arguments: the module object that emitted the log message,
   *         and the character string containing the log.
   *         On failure, throws an exception or returns a negative error code.
   */
  async registerLogCallback(callback) {
    let serial;
    serial = await this.get_serialNumber();
    if (serial == YAPI_INVALID_STRING) {
      return YAPI_DEVICE_NOT_FOUND;
    }
    this._logCallback = callback;
    await this._startStopDevLog(serial, callback != null);
    return 0;
  }
  async get_logCallback() {
    return this._logCallback;
  }
  /**
   * Register a callback function, to be called when a persistent settings in
   * a device configuration has been changed (e.g. change of unit, etc).
   *
   * @param callback : a procedure taking a YModule parameter, or null
   *         to unregister a previously registered  callback.
   */
  async registerConfigChangeCallback(callback) {
    if (callback != null) {
      await _YModule._updateModuleCallbackList(this, true);
    } else {
      await _YModule._updateModuleCallbackList(this, false);
    }
    this._confChangeCallback = callback;
    return 0;
  }
  async _invokeConfigChangeCallback() {
    if (this._confChangeCallback != null) {
      try {
        await this._confChangeCallback(this);
      } catch (e) {
        this._yapi.imm_log("Exception in configChangeCallback:", e);
      }
    }
    return 0;
  }
  /**
   * Register a callback function, to be called when the localization beacon of the module
   * has been changed. The callback function should take two arguments: the YModule object of
   * which the beacon has changed, and an integer describing the new beacon state.
   *
   * @param callback : The callback function to call, or null to unregister a
   *         previously registered callback.
   */
  async registerBeaconCallback(callback) {
    if (callback != null) {
      await _YModule._updateModuleCallbackList(this, true);
    } else {
      await _YModule._updateModuleCallbackList(this, false);
    }
    this._beaconCallback = callback;
    return 0;
  }
  async _invokeBeaconCallback(beaconState) {
    if (this._beaconCallback != null) {
      try {
        await this._beaconCallback(this, beaconState);
      } catch (e) {
        this._yapi.imm_log("Exception in beaconCallback:", e);
      }
    }
    return 0;
  }
  /**
   * Triggers a configuration change callback, to check if they are supported or not.
   */
  async triggerConfigChangeCallback() {
    await this._setAttr("persistentSettings", "2");
    return 0;
  }
  /**
   * Tests whether the byn file is valid for this module. This method is useful to test if the module
   * needs to be updated.
   * It is possible to pass a directory as argument instead of a file. In this case, this method returns
   * the path of the most recent
   * appropriate .byn file. If the parameter onlynew is true, the function discards firmwares that are older or
   * equal to the installed firmware.
   *
   * @param path : the path of a byn file or a directory that contains byn files
   * @param onlynew : returns only files that are strictly newer
   *
   * @return the path of the byn file to use or a empty string if no byn files matches the requirement
   *
   * On failure, throws an exception or returns a string that start with "error:".
   */
  async checkFirmware(path, onlynew) {
    let serial;
    let release;
    let tmp_res;
    if (onlynew) {
      release = YAPIContext.imm_atoi(await this.get_firmwareRelease());
    } else {
      release = 0;
    }
    serial = await this.get_serialNumber();
    tmp_res = await YFirmwareUpdate.CheckFirmware(serial, path, release);
    if (tmp_res.indexOf("error:") == 0) {
      this._throw(YAPI_INVALID_ARGUMENT, tmp_res);
    }
    return tmp_res;
  }
  /**
   * Prepares a firmware update of the module. This method returns a YFirmwareUpdate object which
   * handles the firmware update process.
   *
   * @param path : the path of the .byn file to use.
   * @param force : true to force the firmware update even if some prerequisites appear not to be met
   *
   * @return a YFirmwareUpdate object or NULL on error.
   */
  async updateFirmwareEx(path, force) {
    let serial;
    let settings;
    serial = await this.get_serialNumber();
    settings = await this.get_allSettings();
    if (settings.length == 0) {
      this._throw(YAPI_IO_ERROR, "Unable to get device settings");
      settings = this._yapi.imm_str2bin("error:Unable to get device settings");
    }
    return new YFirmwareUpdate(this._yapi, serial, path, settings, force);
  }
  /**
   * Prepares a firmware update of the module. This method returns a YFirmwareUpdate object which
   * handles the firmware update process.
   *
   * @param path : the path of the .byn file to use.
   *
   * @return a YFirmwareUpdate object or NULL on error.
   */
  async updateFirmware(path) {
    return await this.updateFirmwareEx(path, false);
  }
  /**
   * Returns all the settings and uploaded files of the module. Useful to backup all the
   * logical names, calibrations parameters, and uploaded files of a device.
   *
   * @return a binary buffer with all the settings.
   *
   * On failure, throws an exception or returns an binary object of size 0.
   */
  async get_allSettings() {
    let settings;
    let json;
    let res;
    let sep;
    let name;
    let item;
    let t_type;
    let pageid;
    let url;
    let file_data;
    let file_data_bin;
    let temp_data_bin;
    let ext_settings;
    let filelist = [];
    let templist = [];
    settings = await this._download("api.json");
    if (settings.length == 0) {
      return settings;
    }
    ext_settings = ', "extras":[';
    templist = await this.get_functionIds("Temperature");
    sep = "";
    for (let ii_0 of templist) {
      if (YAPIContext.imm_atoi(await this.get_firmwareRelease()) > 9e3) {
        url = "api/" + ii_0 + "/sensorType";
        t_type = this._yapi.imm_bin2str(await this._download(url));
        if (t_type == "RES_NTC" || t_type == "RES_LINEAR") {
          pageid = ii_0.substr(11, ii_0.length - 11);
          if (pageid == "") {
            pageid = "1";
          }
          temp_data_bin = await this._download("extra.json?page=" + pageid);
          if (temp_data_bin.length > 0) {
            item = sep + '{"fid":"' + ii_0 + '", "json":' + this._yapi.imm_bin2str(temp_data_bin) + "}\n";
            ext_settings = ext_settings + item;
            sep = ",";
          }
        }
      }
    }
    ext_settings = ext_settings + '],\n"files":[';
    if (await this.hasFunction("files")) {
      json = await this._download("files.json?a=dir&d=1&f=");
      if (json.length == 0) {
        return json;
      }
      filelist = this.imm_json_get_array(json);
      sep = "";
      for (let ii_1 of filelist) {
        name = this.imm_json_get_key(ii_1, "name");
        if (name.length > 0 && !(name == "startupConf.json")) {
          if (name.substr(name.length - 1, 1) == "/") {
            file_data = "";
          } else {
            file_data_bin = await this._download(this.imm_escapeAttr(name));
            file_data = this._yapi.imm_bin2hexstr(file_data_bin);
          }
          item = sep + '{"name":"' + name + '", "data":"' + file_data + '"}\n';
          ext_settings = ext_settings + item;
          sep = ",";
        }
      }
    }
    res = this._yapi.imm_str2bin('{ "api":' + this._yapi.imm_bin2str(settings) + ext_settings + "]}");
    return res;
  }
  async loadThermistorExtra(funcId, jsonExtra) {
    let values = [];
    let url;
    let curr;
    let binCurr;
    let currTemp;
    let binCurrTemp;
    let ofs;
    let size;
    url = "api/" + funcId + ".json?command=Z";
    await this._download(url);
    values = this.imm_json_get_array(this._yapi.imm_str2bin(jsonExtra));
    ofs = 0;
    size = values.length;
    while (ofs + 1 < size) {
      binCurr = values[ofs];
      binCurrTemp = values[ofs + 1];
      curr = this.imm_json_get_string(binCurr);
      currTemp = this.imm_json_get_string(binCurrTemp);
      url = "api/" + funcId + ".json?command=m" + curr + ":" + currTemp;
      await this._download(url);
      ofs = ofs + 2;
    }
    return YAPI_SUCCESS;
  }
  async set_extraSettings(jsonExtra) {
    let extras = [];
    let tmp;
    let functionId;
    let data;
    extras = this.imm_json_get_array(this._yapi.imm_str2bin(jsonExtra));
    for (let ii_0 of extras) {
      tmp = this.imm_get_json_path(ii_0, "fid");
      functionId = this.imm_json_get_string(tmp);
      data = this.imm_get_json_path(ii_0, "json");
      if (await this.hasFunction(functionId)) {
        await this.loadThermistorExtra(functionId, this._yapi.imm_bin2str(data));
      }
    }
    return YAPI_SUCCESS;
  }
  /**
   * Restores all the settings and uploaded files to the module.
   * This method is useful to restore all the logical names and calibrations parameters,
   * uploaded files etc. of a device from a backup.
   * Remember to call the saveToFlash() method of the module if the
   * modifications must be kept.
   *
   * @param settings : a binary buffer with all the settings.
   *
   * @return YAPI.SUCCESS when the call succeeds.
   *
   * On failure, throws an exception or returns a negative error code.
   */
  async set_allSettingsAndFiles(settings) {
    let down;
    let json_api;
    let json_files;
    let json_extra;
    let fuperror;
    let globalres;
    fuperror = 0;
    json_api = this.imm_get_json_path(settings, "api");
    if (json_api.length == 0) {
      return await this.set_allSettings(settings);
    }
    json_extra = this.imm_get_json_path(settings, "extras");
    if (json_extra.length > 0) {
      await this.set_extraSettings(this._yapi.imm_bin2str(json_extra));
    }
    await this.set_allSettings(json_api);
    if (await this.hasFunction("files")) {
      let files = [];
      let res;
      let tmp;
      let name;
      let data;
      down = await this._download("files.json?a=format");
      down = this.imm_get_json_path(down, "res");
      res = this.imm_json_get_string(down);
      if (!(res == "ok")) {
        return this._throw(YAPI_IO_ERROR, "format failed", YAPI_IO_ERROR);
      }
      json_files = this.imm_get_json_path(settings, "files");
      files = this.imm_json_get_array(json_files);
      for (let ii_0 of files) {
        tmp = this.imm_get_json_path(ii_0, "name");
        name = this.imm_json_get_string(tmp);
        tmp = this.imm_get_json_path(ii_0, "data");
        data = this.imm_json_get_string(tmp);
        if (name == "") {
          fuperror = fuperror + 1;
        } else {
          await this._upload(name, this._yapi.imm_hexstr2bin(data));
        }
      }
    }
    globalres = await this.set_allSettings(json_api);
    if (!(fuperror == 0)) {
      return this._throw(YAPI_IO_ERROR, "Error during file upload", YAPI_IO_ERROR);
    }
    return globalres;
  }
  /**
   * Tests if the device includes a specific function. This method takes a function identifier
   * and returns a boolean.
   *
   * @param funcId : the requested function identifier
   *
   * @return true if the device has the function identifier
   */
  async hasFunction(funcId) {
    let count;
    let i;
    let fid;
    count = await this.functionCount();
    i = 0;
    while (i < count) {
      fid = await this.functionId(i);
      if (fid == funcId) {
        return true;
      }
      i = i + 1;
    }
    return false;
  }
  /**
   * Retrieve all hardware identifier that match the type passed in argument.
   *
   * @param funType : The type of function (Relay, LightSensor, Voltage,...)
   *
   * @return an array of strings.
   */
  async get_functionIds(funType) {
    let count;
    let i;
    let ftype;
    let res = [];
    count = await this.functionCount();
    i = 0;
    while (i < count) {
      ftype = await this.functionType(i);
      if (ftype == funType) {
        res.push(await this.functionId(i));
      } else {
        ftype = await this.functionBaseType(i);
        if (ftype == funType) {
          res.push(await this.functionId(i));
        }
      }
      i = i + 1;
    }
    return res;
  }
  imm_flattenJsonStruct(jsoncomplex) {
    return this.imm_flattenJsonStruct_internal(jsoncomplex);
  }
  async calibVersion(cparams) {
    if (cparams == "0,") {
      return 3;
    }
    if (cparams.indexOf(",") >= 0) {
      if (cparams.indexOf(" ") > 0) {
        return 3;
      } else {
        return 1;
      }
    }
    if (cparams == "" || cparams == "0") {
      return 1;
    }
    if (cparams.length < 2 || cparams.indexOf(".") >= 0) {
      return 0;
    } else {
      return 2;
    }
  }
  async calibScale(unit_name, sensorType) {
    if (unit_name == "g" || unit_name == "gauss" || unit_name == "W") {
      return 1e3;
    }
    if (unit_name == "C") {
      if (sensorType == "") {
        return 16;
      }
      if (YAPIContext.imm_atoi(sensorType) < 8) {
        return 16;
      } else {
        return 100;
      }
    }
    if (unit_name == "m" || unit_name == "deg") {
      return 10;
    }
    return 1;
  }
  async calibOffset(unit_name) {
    if (unit_name == "% RH" || unit_name == "mbar" || unit_name == "lx") {
      return 0;
    }
    return 32767;
  }
  async calibConvert(param, currentFuncValue, unit_name, sensorType) {
    let paramVer;
    let funVer;
    let funScale;
    let funOffset;
    let paramScale;
    let paramOffset;
    let words = [];
    let words_str = [];
    let calibData = [];
    let iCalib = [];
    let calibType;
    let i;
    let maxSize;
    let ratio;
    let nPoints;
    let wordVal;
    paramVer = await this.calibVersion(param);
    funVer = await this.calibVersion(currentFuncValue);
    funScale = await this.calibScale(unit_name, sensorType);
    funOffset = await this.calibOffset(unit_name);
    paramScale = funScale;
    paramOffset = funOffset;
    if (funVer < 3) {
      if (funVer == 2) {
        words = this._yapi.imm_decodeWords(currentFuncValue);
        if (words[0] == 1366 && words[1] == 12500) {
          funScale = 1;
          funOffset = 0;
        } else {
          funScale = words[1];
          funOffset = words[0];
        }
      } else {
        if (funVer == 1) {
          if (currentFuncValue == "" || YAPIContext.imm_atoi(currentFuncValue) > 10) {
            funScale = 0;
          }
        }
      }
    }
    calibData.length = 0;
    calibType = 0;
    if (paramVer < 3) {
      if (paramVer == 2) {
        words = this._yapi.imm_decodeWords(param);
        if (words[0] == 1366 && words[1] == 12500) {
          paramScale = 1;
          paramOffset = 0;
        } else {
          paramScale = words[1];
          paramOffset = words[0];
        }
        if (words.length >= 3 && words[2] > 0) {
          maxSize = 3 + 2 * (words[2] % 10);
          if (maxSize > words.length) {
            maxSize = words.length;
          }
          i = 3;
          while (i < maxSize) {
            calibData.push(words[i]);
            i = i + 1;
          }
        }
      } else {
        if (paramVer == 1) {
          words_str = param.split(",");
          for (let ii_0 of words_str) {
            words.push(YAPIContext.imm_atoi(ii_0));
          }
          if (param == "" || words[0] > 10) {
            paramScale = 0;
          }
          if (words.length > 0 && words[0] > 0) {
            maxSize = 1 + 2 * (words[0] % 10);
            if (maxSize > words.length) {
              maxSize = words.length;
            }
            i = 1;
            while (i < maxSize) {
              calibData.push(words[i]);
              i = i + 1;
            }
          }
        } else {
          if (paramVer == 0) {
            ratio = YAPIContext.imm_atof(param);
            if (ratio > 0) {
              calibData.push(0);
              calibData.push(0);
              calibData.push(Math.round(65535 / ratio));
              calibData.push(65535);
            }
          }
        }
      }
      i = 0;
      while (i < calibData.length) {
        if (paramScale > 0) {
          calibData[i] = (calibData[i] - paramOffset) / paramScale;
        } else {
          calibData[i] = this._yapi.imm_decimalToDouble(Math.round(calibData[i]));
        }
        i = i + 1;
      }
    } else {
      iCalib = this._yapi.imm_decodeFloats(param);
      calibType = Math.round(iCalib[0] / 1e3);
      if (calibType >= 30) {
        calibType = calibType - 30;
      }
      i = 1;
      while (i < iCalib.length) {
        calibData.push(iCalib[i] / 1e3);
        i = i + 1;
      }
    }
    if (funVer >= 3) {
      if (calibData.length == 0) {
        param = "0,";
      } else {
        param = (30 + calibType).toString();
        i = 0;
        while (i < calibData.length) {
          if ((i & 1) > 0) {
            param = param + ":";
          } else {
            param = param + " ";
          }
          param = param + Math.round(calibData[i] * 1e3 / 1e3).toString();
          i = i + 1;
        }
        param = param + ",";
      }
    } else {
      if (funVer >= 1) {
        nPoints = calibData.length / 2 >> 0;
        param = nPoints.toString();
        i = 0;
        while (i < 2 * nPoints) {
          if (funScale == 0) {
            wordVal = this._yapi.imm_doubleToDecimal(Math.round(calibData[i]));
          } else {
            wordVal = calibData[i] * funScale + funOffset;
          }
          param = param + "," + Math.round(wordVal).toString();
          i = i + 1;
        }
      } else {
        if (calibData.length == 4) {
          param = Math.round(1e3 * (calibData[3] - calibData[1]) / calibData[2] - calibData[0]).toString();
        }
      }
    }
    return param;
  }
  async _tryExec(url) {
    let res;
    let done;
    res = YAPI_SUCCESS;
    done = 1;
    try {
      await this._download(url);
    } catch (e) {
      done = 0;
    }
    if (done == 0) {
      try {
        await YAPI.Sleep(500);
        await this._download(url);
      } catch (e) {
        res = await this.get_errorType();
      }
    }
    return res;
  }
  /**
   * Restores all the settings of the device. Useful to restore all the logical names and calibrations parameters
   * of a module from a backup.Remember to call the saveToFlash() method of the module if the
   * modifications must be kept.
   *
   * @param settings : a binary buffer with all the settings.
   *
   * @return YAPI.SUCCESS when the call succeeds.
   *
   * On failure, throws an exception or returns a negative error code.
   */
  async set_allSettings(settings) {
    let restoreLast = [];
    let old_json_flat;
    let old_dslist = [];
    let old_jpath = [];
    let old_jpath_len = [];
    let old_val_arr = [];
    let actualSettings;
    let new_dslist = [];
    let new_jpath = [];
    let new_jpath_len = [];
    let new_val_arr = [];
    let cpos;
    let eqpos;
    let leng;
    let i;
    let j;
    let subres;
    let res;
    let njpath;
    let jpath;
    let fun;
    let attr;
    let value;
    let old_serial;
    let new_serial;
    let url;
    let tmp;
    let binTmp;
    let sensorType;
    let unit_name;
    let newval;
    let oldval;
    let old_calib;
    let each_str;
    let do_update;
    let found;
    res = YAPI_SUCCESS;
    binTmp = this.imm_get_json_path(settings, "api");
    if (binTmp.length > 0) {
      settings = binTmp;
    }
    old_serial = "";
    oldval = "";
    newval = "";
    old_json_flat = this.imm_flattenJsonStruct(settings);
    old_dslist = this.imm_json_get_array(old_json_flat);
    for (let ii_0 of old_dslist) {
      each_str = this.imm_json_get_string(ii_0);
      leng = each_str.length;
      eqpos = each_str.indexOf("=");
      if (eqpos < 0 || leng == 0) {
        this._throw(YAPI_INVALID_ARGUMENT, "Invalid settings");
        return YAPI_INVALID_ARGUMENT;
      }
      jpath = each_str.substr(0, eqpos);
      eqpos = eqpos + 1;
      value = each_str.substr(eqpos, leng - eqpos);
      old_jpath.push(jpath);
      old_jpath_len.push(jpath.length);
      old_val_arr.push(value);
      if (jpath == "module/serialNumber") {
        old_serial = value;
      }
    }
    try {
      actualSettings = await this._download("api.json");
    } catch (e) {
      await YAPI.Sleep(500);
      actualSettings = await this._download("api.json");
    }
    new_serial = await this.get_serialNumber();
    if (old_serial == new_serial || old_serial == "") {
      old_serial = "_NO_SERIAL_FILTER_";
    }
    actualSettings = this.imm_flattenJsonStruct(actualSettings);
    new_dslist = this.imm_json_get_array(actualSettings);
    for (let ii_1 of new_dslist) {
      each_str = this.imm_json_get_string(ii_1);
      leng = each_str.length;
      eqpos = each_str.indexOf("=");
      if (eqpos < 0 || leng == 0) {
        this._throw(YAPI_INVALID_ARGUMENT, "Invalid settings");
        return YAPI_INVALID_ARGUMENT;
      }
      jpath = each_str.substr(0, eqpos);
      eqpos = eqpos + 1;
      value = each_str.substr(eqpos, leng - eqpos);
      new_jpath.push(jpath);
      new_jpath_len.push(jpath.length);
      new_val_arr.push(value);
    }
    i = 0;
    while (i < new_jpath.length) {
      njpath = new_jpath[i];
      leng = njpath.length;
      cpos = njpath.indexOf("/");
      if (cpos < 0 || leng == 0) {
        continue;
      }
      fun = njpath.substr(0, cpos);
      cpos = cpos + 1;
      attr = njpath.substr(cpos, leng - cpos);
      do_update = true;
      if (fun == "services") {
        do_update = false;
      }
      if (do_update && attr == "firmwareRelease") {
        do_update = false;
      }
      if (do_update && attr == "usbCurrent") {
        do_update = false;
      }
      if (do_update && attr == "upTime") {
        do_update = false;
      }
      if (do_update && attr == "persistentSettings") {
        do_update = false;
      }
      if (do_update && attr == "adminPassword") {
        do_update = false;
      }
      if (do_update && attr == "userPassword") {
        do_update = false;
      }
      if (do_update && attr == "rebootCountdown") {
        do_update = false;
      }
      if (do_update && attr == "advertisedValue") {
        do_update = false;
      }
      if (do_update && attr == "poeCurrent") {
        do_update = false;
      }
      if (do_update && attr == "readiness") {
        do_update = false;
      }
      if (do_update && attr == "ipAddress") {
        do_update = false;
      }
      if (do_update && attr == "subnetMask") {
        do_update = false;
      }
      if (do_update && attr == "router") {
        do_update = false;
      }
      if (do_update && attr == "linkQuality") {
        do_update = false;
      }
      if (do_update && attr == "ssid") {
        do_update = false;
      }
      if (do_update && attr == "channel") {
        do_update = false;
      }
      if (do_update && attr == "security") {
        do_update = false;
      }
      if (do_update && attr == "message") {
        do_update = false;
      }
      if (do_update && attr == "signalValue") {
        do_update = false;
      }
      if (do_update && attr == "currentValue") {
        do_update = false;
      }
      if (do_update && attr == "currentRawValue") {
        do_update = false;
      }
      if (do_update && attr == "currentRunIndex") {
        do_update = false;
      }
      if (do_update && attr == "pulseTimer") {
        do_update = false;
      }
      if (do_update && attr == "lastTimePressed") {
        do_update = false;
      }
      if (do_update && attr == "lastTimeReleased") {
        do_update = false;
      }
      if (do_update && attr == "filesCount") {
        do_update = false;
      }
      if (do_update && attr == "freeSpace") {
        do_update = false;
      }
      if (do_update && attr == "timeUTC") {
        do_update = false;
      }
      if (do_update && attr == "rtcTime") {
        do_update = false;
      }
      if (do_update && attr == "unixTime") {
        do_update = false;
      }
      if (do_update && attr == "dateTime") {
        do_update = false;
      }
      if (do_update && attr == "rawValue") {
        do_update = false;
      }
      if (do_update && attr == "lastMsg") {
        do_update = false;
      }
      if (do_update && attr == "delayedPulseTimer") {
        do_update = false;
      }
      if (do_update && attr == "rxCount") {
        do_update = false;
      }
      if (do_update && attr == "txCount") {
        do_update = false;
      }
      if (do_update && attr == "msgCount") {
        do_update = false;
      }
      if (do_update && attr == "rxMsgCount") {
        do_update = false;
      }
      if (do_update && attr == "txMsgCount") {
        do_update = false;
      }
      if (do_update) {
        do_update = false;
        j = 0;
        found = false;
        newval = new_val_arr[i];
        while (j < old_jpath.length && !found) {
          if (new_jpath_len[i] == old_jpath_len[j] && new_jpath[i] == old_jpath[j]) {
            found = true;
            oldval = old_val_arr[j];
            if (!(newval == oldval) && !(oldval == old_serial)) {
              do_update = true;
            }
          }
          j = j + 1;
        }
      }
      if (do_update) {
        if (attr == "calibrationParam") {
          old_calib = "";
          unit_name = "";
          sensorType = "";
          j = 0;
          found = false;
          while (j < old_jpath.length && !found) {
            if (new_jpath_len[i] == old_jpath_len[j] && new_jpath[i] == old_jpath[j]) {
              found = true;
              old_calib = old_val_arr[j];
            }
            j = j + 1;
          }
          tmp = fun + "/unit";
          j = 0;
          found = false;
          while (j < new_jpath.length && !found) {
            if (tmp == new_jpath[j]) {
              found = true;
              unit_name = new_val_arr[j];
            }
            j = j + 1;
          }
          tmp = fun + "/sensorType";
          j = 0;
          found = false;
          while (j < new_jpath.length && !found) {
            if (tmp == new_jpath[j]) {
              found = true;
              sensorType = new_val_arr[j];
            }
            j = j + 1;
          }
          newval = await this.calibConvert(old_calib, new_val_arr[i], unit_name, sensorType);
          url = "api/" + fun + ".json?" + attr + "=" + this.imm_escapeAttr(newval);
          subres = await this._tryExec(url);
          if (res == YAPI_SUCCESS && subres != YAPI_SUCCESS) {
            res = subres;
          }
        } else {
          url = "api/" + fun + ".json?" + attr + "=" + this.imm_escapeAttr(oldval);
          if (attr == "resolution") {
            restoreLast.push(url);
          } else {
            subres = await this._tryExec(url);
            if (res == YAPI_SUCCESS && subres != YAPI_SUCCESS) {
              res = subres;
            }
          }
        }
      }
      i = i + 1;
    }
    for (let ii_2 of restoreLast) {
      subres = await this._tryExec(ii_2);
      if (res == YAPI_SUCCESS && subres != YAPI_SUCCESS) {
        res = subres;
      }
    }
    await this.clearCache();
    return res;
  }
  /**
   * Adds a file to the uploaded data at the next HTTP callback.
   * This function only affects the next HTTP callback and only works in
   * HTTP callback mode.
   *
   * @param filename : the name of the file to upload at the next HTTP callback
   *
   * @return nothing.
   */
  async addFileToHTTPCallback(filename) {
    let content;
    content = await this._download("@YCB+" + filename);
    if (content.length == 0) {
      return YAPI_NOT_SUPPORTED;
    }
    return YAPI_SUCCESS;
  }
  /**
   * Returns the unique hardware identifier of the module.
   * The unique hardware identifier is made of the device serial
   * number followed by string ".module".
   *
   * @return a string that uniquely identifies the module
   */
  async get_hardwareId() {
    let serial;
    serial = await this.get_serialNumber();
    return serial + ".module";
  }
  /**
   * Downloads the specified built-in file and returns a binary buffer with its content.
   *
   * @param pathname : name of the new file to load
   *
   * @return a binary buffer with the file content
   *
   * On failure, throws an exception or returns an empty content.
   */
  async download(pathname) {
    return await this._download(pathname);
  }
  /**
   * Returns the icon of the module. The icon is a PNG image and does not
   * exceeds 1536 bytes.
   *
   * @return a binary buffer with module icon, in png format.
   *         On failure, throws an exception or returns an empty content.
   */
  async get_icon2d() {
    return await this._download("icon2d.png");
  }
  /**
   * Returns a string with last logs of the module. This method return only
   * logs that are still in the module.
   *
   * @return a string with last logs of the module.
   *         On failure, throws an exception or returns  YAPI.INVALID_STRING.
   */
  async get_lastLogs() {
    let content;
    content = await this._download("logs.txt");
    if (content.length == 0) {
      return YAPI_INVALID_STRING;
    }
    return this._yapi.imm_bin2str(content);
  }
  /**
   * Adds a text message to the device logs. This function is useful in
   * particular to trace the execution of HTTP callbacks. If a newline
   * is desired after the message, it must be included in the string.
   *
   * @param text : the string to append to the logs.
   *
   * @return YAPI.SUCCESS if the call succeeds.
   *
   * On failure, throws an exception or returns a negative error code.
   */
  async log(text) {
    return await this._upload("logs.txt", this._yapi.imm_str2bin(text));
  }
  /**
   * Returns a list of all the modules that are plugged into the current module.
   * This method only makes sense when called for a YoctoHub/VirtualHub.
   * Otherwise, an empty array will be returned.
   *
   * @return an array of strings containing the sub modules.
   */
  async get_subDevices() {
    return await this.get_subDevices_internal();
  }
  /**
   * Returns the serial number of the YoctoHub on which this module is connected.
   * If the module is connected by USB, or if the module is the root YoctoHub, an
   * empty string is returned.
   *
   * @return a string with the serial number of the YoctoHub or an empty string
   */
  async get_parentHub() {
    return await this.get_parentHub_internal();
  }
  /**
   * Returns the URL used to access the module. If the module is connected by USB, the
   * string 'usb' is returned.
   *
   * @return a string with the URL of the module.
   */
  async get_url() {
    return await this.get_url_internal();
  }
  /**
   * Continues the module enumeration started using yFirstModule().
   * Caution: You can't make any assumption about the returned modules order.
   * If you want to find a specific module, use Module.findModule()
   * and a hardwareID or a logical name.
   *
   * @return a pointer to a YModule object, corresponding to
   *         the next module found, or a null pointer
   *         if there are no more modules to enumerate.
   */
  nextModule() {
    let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
    if (resolve.errorType != YAPI.SUCCESS)
      return null;
    let next_hwid = this._yapi.imm_getNextHardwareId(this._className, resolve.result);
    if (next_hwid == null)
      return null;
    return _YModule.FindModuleInContext(this._yapi, next_hwid);
  }
  /**
   * Starts the enumeration of modules currently accessible.
   * Use the method YModule.nextModule() to iterate on the
   * next modules.
   *
   * @return a pointer to a YModule object, corresponding to
   *         the first module currently online, or a null pointer
   *         if there are none.
   */
  static FirstModule() {
    let next_hwid = YAPI.imm_getFirstHardwareId("Module");
    if (next_hwid == null)
      return null;
    return _YModule.FindModule(next_hwid);
  }
  /**
   * Retrieves the first Module in a given context
   *
   * @param yctx {YAPIContext}
   *
   * @returns {YModule}
   */
  static FirstModuleInContext(yctx) {
    let next_hwid = yctx.imm_getFirstHardwareId("Module");
    if (next_hwid == null)
      return null;
    return _YModule.FindModuleInContext(yctx, next_hwid);
  }
};
YModule.PRODUCTNAME_INVALID = YAPI_INVALID_STRING;
YModule.SERIALNUMBER_INVALID = YAPI_INVALID_STRING;
YModule.PRODUCTID_INVALID = YAPI_INVALID_UINT;
YModule.PRODUCTRELEASE_INVALID = YAPI_INVALID_UINT;
YModule.FIRMWARERELEASE_INVALID = YAPI_INVALID_STRING;
YModule.PERSISTENTSETTINGS_LOADED = 0;
YModule.PERSISTENTSETTINGS_SAVED = 1;
YModule.PERSISTENTSETTINGS_MODIFIED = 2;
YModule.PERSISTENTSETTINGS_INVALID = -1;
YModule.LUMINOSITY_INVALID = YAPI_INVALID_UINT;
YModule.BEACON_OFF = 0;
YModule.BEACON_ON = 1;
YModule.BEACON_INVALID = -1;
YModule.UPTIME_INVALID = YAPI_INVALID_LONG;
YModule.USBCURRENT_INVALID = YAPI_INVALID_UINT;
YModule.REBOOTCOUNTDOWN_INVALID = YAPI_INVALID_INT;
YModule.USERVAR_INVALID = YAPI_INVALID_INT;
var YSensor = class _YSensor extends YFunction {
  //--- (end of generated code: YSensor attributes declaration)
  constructor(yapi, func) {
    super(yapi, func);
    this._cal = null;
    this._unit = _YSensor.UNIT_INVALID;
    this._currentValue = _YSensor.CURRENTVALUE_INVALID;
    this._lowestValue = _YSensor.LOWESTVALUE_INVALID;
    this._highestValue = _YSensor.HIGHESTVALUE_INVALID;
    this._currentRawValue = _YSensor.CURRENTRAWVALUE_INVALID;
    this._logFrequency = _YSensor.LOGFREQUENCY_INVALID;
    this._reportFrequency = _YSensor.REPORTFREQUENCY_INVALID;
    this._advMode = _YSensor.ADVMODE_INVALID;
    this._calibrationParam = _YSensor.CALIBRATIONPARAM_INVALID;
    this._resolution = _YSensor.RESOLUTION_INVALID;
    this._sensorState = _YSensor.SENSORSTATE_INVALID;
    this._valueCallbackSensor = null;
    this._timedReportCallbackSensor = null;
    this._prevTR = 0;
    this._iresol = 0;
    this.UNIT_INVALID = YAPI_INVALID_STRING;
    this.CURRENTVALUE_INVALID = YAPI_INVALID_DOUBLE;
    this.LOWESTVALUE_INVALID = YAPI_INVALID_DOUBLE;
    this.HIGHESTVALUE_INVALID = YAPI_INVALID_DOUBLE;
    this.CURRENTRAWVALUE_INVALID = YAPI_INVALID_DOUBLE;
    this.LOGFREQUENCY_INVALID = YAPI_INVALID_STRING;
    this.REPORTFREQUENCY_INVALID = YAPI_INVALID_STRING;
    this.ADVMODE_IMMEDIATE = 0;
    this.ADVMODE_PERIOD_AVG = 1;
    this.ADVMODE_PERIOD_MIN = 2;
    this.ADVMODE_PERIOD_MAX = 3;
    this.ADVMODE_INVALID = -1;
    this.CALIBRATIONPARAM_INVALID = YAPI_INVALID_STRING;
    this.RESOLUTION_INVALID = YAPI_INVALID_DOUBLE;
    this.SENSORSTATE_INVALID = YAPI_INVALID_INT;
    this._className = "Sensor";
  }
  //--- (generated code: YSensor implementation)
  imm_parseAttr(name, val) {
    switch (name) {
      case "unit":
        this._unit = val;
        return 1;
      case "currentValue":
        this._currentValue = Math.round(val / 65.536) / 1e3;
        return 1;
      case "lowestValue":
        this._lowestValue = Math.round(val / 65.536) / 1e3;
        return 1;
      case "highestValue":
        this._highestValue = Math.round(val / 65.536) / 1e3;
        return 1;
      case "currentRawValue":
        this._currentRawValue = Math.round(val / 65.536) / 1e3;
        return 1;
      case "logFrequency":
        this._logFrequency = val;
        return 1;
      case "reportFrequency":
        this._reportFrequency = val;
        return 1;
      case "advMode":
        this._advMode = val;
        return 1;
      case "calibrationParam":
        this._calibrationParam = val;
        return 1;
      case "resolution":
        this._resolution = Math.round(val / 65.536) / 1e3;
        return 1;
      case "sensorState":
        this._sensorState = val;
        return 1;
    }
    return super.imm_parseAttr(name, val);
  }
  /**
   * Returns the measuring unit for the measure.
   *
   * @return a string corresponding to the measuring unit for the measure
   *
   * On failure, throws an exception or returns YSensor.UNIT_INVALID.
   */
  async get_unit() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return _YSensor.UNIT_INVALID;
      }
    }
    res = this._unit;
    return res;
  }
  /**
   * Returns the current value of the measure, in the specified unit, as a floating point number.
   * Note that a get_currentValue() call will *not* start a measure in the device, it
   * will just return the last measure that occurred in the device. Indeed, internally, each Yoctopuce
   * devices is continuously making measurements at a hardware specific frequency.
   *
   * If continuously calling  get_currentValue() leads you to performances issues, then
   * you might consider to switch to callback programming model. Check the "advanced
   * programming" chapter in in your device user manual for more information.
   *
   * @return a floating point number corresponding to the current value of the measure, in the specified
   * unit, as a floating point number
   *
   * On failure, throws an exception or returns YSensor.CURRENTVALUE_INVALID.
   */
  async get_currentValue() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return _YSensor.CURRENTVALUE_INVALID;
      }
    }
    if (this._cal == null) {
      res = this._currentValue;
    } else {
      res = await this._applyCalibration(this._currentRawValue);
    }
    if (res == _YSensor.CURRENTVALUE_INVALID) {
      return res;
    }
    res = Math.round(res * this._iresol) / this._iresol;
    return res;
  }
  /**
   * Changes the recorded minimal value observed. Can be used to reset the value returned
   * by get_lowestValue().
   *
   * @param newval : a floating point number corresponding to the recorded minimal value observed
   *
   * @return YAPI.SUCCESS if the call succeeds.
   *
   * On failure, throws an exception or returns a negative error code.
   */
  async set_lowestValue(newval) {
    let rest_val;
    rest_val = String(Math.round(newval * 65536));
    return await this._setAttr("lowestValue", rest_val);
  }
  /**
   * Returns the minimal value observed for the measure since the device was started.
   * Can be reset to an arbitrary value thanks to set_lowestValue().
   *
   * @return a floating point number corresponding to the minimal value observed for the measure since
   * the device was started
   *
   * On failure, throws an exception or returns YSensor.LOWESTVALUE_INVALID.
   */
  async get_lowestValue() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return _YSensor.LOWESTVALUE_INVALID;
      }
    }
    res = Math.round(this._lowestValue * this._iresol) / this._iresol;
    return res;
  }
  /**
   * Changes the recorded maximal value observed. Can be used to reset the value returned
   * by get_lowestValue().
   *
   * @param newval : a floating point number corresponding to the recorded maximal value observed
   *
   * @return YAPI.SUCCESS if the call succeeds.
   *
   * On failure, throws an exception or returns a negative error code.
   */
  async set_highestValue(newval) {
    let rest_val;
    rest_val = String(Math.round(newval * 65536));
    return await this._setAttr("highestValue", rest_val);
  }
  /**
   * Returns the maximal value observed for the measure since the device was started.
   * Can be reset to an arbitrary value thanks to set_highestValue().
   *
   * @return a floating point number corresponding to the maximal value observed for the measure since
   * the device was started
   *
   * On failure, throws an exception or returns YSensor.HIGHESTVALUE_INVALID.
   */
  async get_highestValue() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return _YSensor.HIGHESTVALUE_INVALID;
      }
    }
    res = Math.round(this._highestValue * this._iresol) / this._iresol;
    return res;
  }
  /**
   * Returns the uncalibrated, unrounded raw value returned by the
   * sensor, in the specified unit, as a floating point number.
   *
   * @return a floating point number corresponding to the uncalibrated, unrounded raw value returned by the
   *         sensor, in the specified unit, as a floating point number
   *
   * On failure, throws an exception or returns YSensor.CURRENTRAWVALUE_INVALID.
   */
  async get_currentRawValue() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return _YSensor.CURRENTRAWVALUE_INVALID;
      }
    }
    res = this._currentRawValue;
    return res;
  }
  /**
   * Returns the datalogger recording frequency for this function, or "OFF"
   * when measures are not stored in the data logger flash memory.
   *
   * @return a string corresponding to the datalogger recording frequency for this function, or "OFF"
   *         when measures are not stored in the data logger flash memory
   *
   * On failure, throws an exception or returns YSensor.LOGFREQUENCY_INVALID.
   */
  async get_logFrequency() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return _YSensor.LOGFREQUENCY_INVALID;
      }
    }
    res = this._logFrequency;
    return res;
  }
  /**
   * Changes the datalogger recording frequency for this function.
   * The frequency can be specified as samples per second,
   * as sample per minute (for instance "15/m") or in samples per
   * hour (eg. "4/h"). To disable recording for this function, use
   * the value "OFF". Note that setting the  datalogger recording frequency
   * to a greater value than the sensor native sampling frequency is useless,
   * and even counterproductive: those two frequencies are not related.
   * Remember to call the saveToFlash() method of the module if the modification must be kept.
   *
   * @param newval : a string corresponding to the datalogger recording frequency for this function
   *
   * @return YAPI.SUCCESS if the call succeeds.
   *
   * On failure, throws an exception or returns a negative error code.
   */
  async set_logFrequency(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("logFrequency", rest_val);
  }
  /**
   * Returns the timed value notification frequency, or "OFF" if timed
   * value notifications are disabled for this function.
   *
   * @return a string corresponding to the timed value notification frequency, or "OFF" if timed
   *         value notifications are disabled for this function
   *
   * On failure, throws an exception or returns YSensor.REPORTFREQUENCY_INVALID.
   */
  async get_reportFrequency() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return _YSensor.REPORTFREQUENCY_INVALID;
      }
    }
    res = this._reportFrequency;
    return res;
  }
  /**
   * Changes the timed value notification frequency for this function.
   * The frequency can be specified as samples per second,
   * as sample per minute (for instance "15/m") or in samples per
   * hour (e.g. "4/h"). To disable timed value notifications for this
   * function, use the value "OFF". Note that setting the  timed value
   * notification frequency to a greater value than the sensor native
   * sampling frequency is unless, and even counterproductive: those two
   * frequencies are not related.
   * Remember to call the saveToFlash() method of the module if the modification must be kept.
   *
   * @param newval : a string corresponding to the timed value notification frequency for this function
   *
   * @return YAPI.SUCCESS if the call succeeds.
   *
   * On failure, throws an exception or returns a negative error code.
   */
  async set_reportFrequency(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("reportFrequency", rest_val);
  }
  /**
   * Returns the measuring mode used for the advertised value pushed to the parent hub.
   *
   * @return a value among YSensor.ADVMODE_IMMEDIATE, YSensor.ADVMODE_PERIOD_AVG,
   * YSensor.ADVMODE_PERIOD_MIN and YSensor.ADVMODE_PERIOD_MAX corresponding to the measuring mode used
   * for the advertised value pushed to the parent hub
   *
   * On failure, throws an exception or returns YSensor.ADVMODE_INVALID.
   */
  async get_advMode() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return _YSensor.ADVMODE_INVALID;
      }
    }
    res = this._advMode;
    return res;
  }
  /**
   * Changes the measuring mode used for the advertised value pushed to the parent hub.
   * Remember to call the saveToFlash() method of the module if the modification must be kept.
   *
   * @param newval : a value among YSensor.ADVMODE_IMMEDIATE, YSensor.ADVMODE_PERIOD_AVG,
   * YSensor.ADVMODE_PERIOD_MIN and YSensor.ADVMODE_PERIOD_MAX corresponding to the measuring mode used
   * for the advertised value pushed to the parent hub
   *
   * @return YAPI.SUCCESS if the call succeeds.
   *
   * On failure, throws an exception or returns a negative error code.
   */
  async set_advMode(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("advMode", rest_val);
  }
  async get_calibrationParam() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return _YSensor.CALIBRATIONPARAM_INVALID;
      }
    }
    res = this._calibrationParam;
    return res;
  }
  async set_calibrationParam(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("calibrationParam", rest_val);
  }
  /**
   * Changes the resolution of the measured physical values. The resolution corresponds to the numerical precision
   * when displaying value. It does not change the precision of the measure itself.
   * Remember to call the saveToFlash() method of the module if the modification must be kept.
   *
   * @param newval : a floating point number corresponding to the resolution of the measured physical values
   *
   * @return YAPI.SUCCESS if the call succeeds.
   *
   * On failure, throws an exception or returns a negative error code.
   */
  async set_resolution(newval) {
    let rest_val;
    rest_val = String(Math.round(newval * 65536));
    return await this._setAttr("resolution", rest_val);
  }
  /**
   * Returns the resolution of the measured values. The resolution corresponds to the numerical precision
   * of the measures, which is not always the same as the actual precision of the sensor.
   * Remember to call the saveToFlash() method of the module if the modification must be kept.
   *
   * @return a floating point number corresponding to the resolution of the measured values
   *
   * On failure, throws an exception or returns YSensor.RESOLUTION_INVALID.
   */
  async get_resolution() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return _YSensor.RESOLUTION_INVALID;
      }
    }
    res = this._resolution;
    return res;
  }
  /**
   * Returns the sensor state code, which is zero when there is an up-to-date measure
   * available or a positive code if the sensor is not able to provide a measure right now.
   *
   * @return an integer corresponding to the sensor state code, which is zero when there is an up-to-date measure
   *         available or a positive code if the sensor is not able to provide a measure right now
   *
   * On failure, throws an exception or returns YSensor.SENSORSTATE_INVALID.
   */
  async get_sensorState() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return _YSensor.SENSORSTATE_INVALID;
      }
    }
    res = this._sensorState;
    return res;
  }
  /**
   * Retrieves a sensor for a given identifier.
   * The identifier can be specified using several formats:
   *
   * - FunctionLogicalName
   * - ModuleSerialNumber.FunctionIdentifier
   * - ModuleSerialNumber.FunctionLogicalName
   * - ModuleLogicalName.FunctionIdentifier
   * - ModuleLogicalName.FunctionLogicalName
   *
   *
   * This function does not require that the sensor is online at the time
   * it is invoked. The returned object is nevertheless valid.
   * Use the method YSensor.isOnline() to test if the sensor is
   * indeed online at a given time. In case of ambiguity when looking for
   * a sensor by logical name, no error is notified: the first instance
   * found is returned. The search is performed first by hardware name,
   * then by logical name.
   *
   * If a call to this object's is_online() method returns FALSE although
   * you are certain that the matching device is plugged, make sure that you did
   * call registerHub() at application initialization time.
   *
   * @param func : a string that uniquely characterizes the sensor, for instance
   *         MyDevice..
   *
   * @return a YSensor object allowing you to drive the sensor.
   */
  static FindSensor(func) {
    let obj;
    obj = YFunction._FindFromCache("Sensor", func);
    if (obj == null) {
      obj = new _YSensor(YAPI, func);
      YFunction._AddToCache("Sensor", func, obj);
    }
    return obj;
  }
  /**
   * Retrieves a sensor for a given identifier in a YAPI context.
   * The identifier can be specified using several formats:
   *
   * - FunctionLogicalName
   * - ModuleSerialNumber.FunctionIdentifier
   * - ModuleSerialNumber.FunctionLogicalName
   * - ModuleLogicalName.FunctionIdentifier
   * - ModuleLogicalName.FunctionLogicalName
   *
   *
   * This function does not require that the sensor is online at the time
   * it is invoked. The returned object is nevertheless valid.
   * Use the method YSensor.isOnline() to test if the sensor is
   * indeed online at a given time. In case of ambiguity when looking for
   * a sensor by logical name, no error is notified: the first instance
   * found is returned. The search is performed first by hardware name,
   * then by logical name.
   *
   * @param yctx : a YAPI context
   * @param func : a string that uniquely characterizes the sensor, for instance
   *         MyDevice..
   *
   * @return a YSensor object allowing you to drive the sensor.
   */
  static FindSensorInContext(yctx, func) {
    let obj;
    obj = YFunction._FindFromCacheInContext(yctx, "Sensor", func);
    if (obj == null) {
      obj = new _YSensor(yctx, func);
      YFunction._AddToCache("Sensor", func, obj);
    }
    return obj;
  }
  /**
   * Registers the callback function that is invoked on every change of advertised value.
   * The callback is invoked only during the execution of ySleep or yHandleEvents.
   * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
   * one of these two functions periodically. To unregister a callback, pass a null pointer as argument.
   *
   * @param callback : the callback function to call, or a null pointer. The callback function should take two
   *         arguments: the function object of which the value has changed, and the character string describing
   *         the new advertised value.
   * @noreturn
   */
  async registerValueCallback(callback) {
    let val;
    if (callback != null) {
      await YFunction._UpdateValueCallbackList(this, true);
    } else {
      await YFunction._UpdateValueCallbackList(this, false);
    }
    this._valueCallbackSensor = callback;
    if (callback != null && await this.isOnline()) {
      val = this._advertisedValue;
      if (!(val == "")) {
        await this._invokeValueCallback(val);
      }
    }
    return 0;
  }
  async _invokeValueCallback(value) {
    if (this._valueCallbackSensor != null) {
      try {
        await this._valueCallbackSensor(this, value);
      } catch (e) {
        this._yapi.imm_log("Exception in valueCallback:", e);
      }
    } else {
      await super._invokeValueCallback(value);
    }
    return 0;
  }
  _parserHelper() {
    let calibStr;
    if (this._resolution > 0) {
      this._iresol = Math.round(1 / this._resolution);
    } else {
      this._iresol = 1e4;
    }
    calibStr = this._calibrationParam;
    if (calibStr == "0," || calibStr == "" || calibStr == "0") {
      this._cal = null;
      return 0;
    }
    if (this._cal == null || !(this._cal.src == calibStr)) {
      this._parseCalibStr(calibStr);
    }
    return 0;
  }
  /**
   * Checks if the sensor is currently able to provide an up-to-date measure.
   * Returns false if the device is unreachable, or if the sensor does not have
   * a current measure to transmit. No exception is raised if there is an error
   * while trying to contact the device hosting $THEFUNCTION$.
   *
   * @return true if the sensor can provide an up-to-date measure, and false otherwise
   */
  async isSensorReady() {
    try {
      if (await this.get_sensorState() != 0) {
        return false;
      }
    } catch (e) {
      return false;
    }
    return true;
  }
  /**
   * Returns the YDatalogger object of the device hosting the sensor. This method returns an object
   * that can control global parameters of the data logger. The returned object
   * should not be freed.
   *
   * @return an YDatalogger object, or null on error.
   */
  async get_dataLogger() {
    let logger;
    let modu;
    let serial;
    let hwid;
    modu = await this.get_module();
    serial = await modu.get_serialNumber();
    if (serial == YAPI_INVALID_STRING) {
      return null;
    }
    hwid = serial + ".dataLogger";
    logger = YDataLogger.FindDataLogger(hwid);
    return logger;
  }
  _parseCalibStr(calibStr) {
    let iCalib = [];
    let caltyp;
    let calhdl;
    let maxpos;
    let position;
    let calpar = [];
    let calraw = [];
    let calref = [];
    let fRaw;
    let fRef;
    let iRaw;
    let iRef;
    if (calibStr.indexOf(",") >= 0) {
      iCalib = this._yapi.imm_decodeFloats(calibStr);
      caltyp = iCalib[0] / 1e3 >> 0;
      if (caltyp < YOCTO_CALIB_TYPE_OFS) {
        this._cal = null;
        return YAPI_SUCCESS;
      }
      calhdl = this._yapi.imm_getCalibrationHandler(caltyp);
      if (!(calhdl != null)) {
        this._cal = null;
        return YAPI_SUCCESS;
      }
      maxpos = iCalib.length;
      calpar.length = 0;
      position = 1;
      while (position < maxpos) {
        calpar.push(iCalib[position]);
        position = position + 1;
      }
      calraw.length = 0;
      calref.length = 0;
      position = 1;
      while (position + 1 < maxpos) {
        fRaw = iCalib[position];
        fRaw = fRaw / 1e3;
        fRef = iCalib[position + 1];
        fRef = fRef / 1e3;
        calraw.push(fRaw);
        calref.push(fRef);
        position = position + 2;
      }
    } else {
      iCalib = this._yapi.imm_decodeWords(calibStr);
      if (iCalib.length <= 2) {
        this._cal = null;
        return YAPI_SUCCESS;
      }
      caltyp = iCalib[2];
      calhdl = this._yapi.imm_getCalibrationHandler(caltyp);
      if (!(calhdl != null)) {
        this._cal = null;
        return YAPI_SUCCESS;
      }
      if (caltyp <= 10) {
        maxpos = caltyp;
      } else {
        if (caltyp <= 20) {
          maxpos = caltyp - 10;
        } else {
          maxpos = 5;
        }
      }
      maxpos = 3 + 2 * maxpos;
      if (maxpos > iCalib.length) {
        maxpos = iCalib.length;
      }
      calpar.length = 0;
      calraw.length = 0;
      calref.length = 0;
      position = 3;
      while (position + 1 < maxpos) {
        iRaw = iCalib[position];
        iRef = iCalib[position + 1];
        calpar.push(iRaw);
        calpar.push(iRef);
        calraw.push(this._yapi.imm_decimalToDouble(iRaw));
        calref.push(this._yapi.imm_decimalToDouble(iRef));
        position = position + 2;
      }
    }
    this._cal = { src: calibStr, hdl: calhdl, typ: caltyp, par: calpar, raw: calraw, cal: calref };
    return YAPI_SUCCESS;
  }
  /**
   * Starts the data logger on the device. Note that the data logger
   * will only save the measures on this sensor if the logFrequency
   * is not set to "OFF".
   *
   * @return YAPI.SUCCESS if the call succeeds.
   */
  async startDataLogger() {
    let res;
    res = await this._download("api/dataLogger/recording?recording=1");
    if (!(res.length > 0)) {
      return this._throw(YAPI_IO_ERROR, "unable to start datalogger", YAPI_IO_ERROR);
    }
    return YAPI_SUCCESS;
  }
  /**
   * Stops the datalogger on the device.
   *
   * @return YAPI.SUCCESS if the call succeeds.
   */
  async stopDataLogger() {
    let res;
    res = await this._download("api/dataLogger/recording?recording=0");
    if (!(res.length > 0)) {
      return this._throw(YAPI_IO_ERROR, "unable to stop datalogger", YAPI_IO_ERROR);
    }
    return YAPI_SUCCESS;
  }
  /**
   * Retrieves a YDataSet object holding historical data for this
   * sensor, for a specified time interval. The measures will be
   * retrieved from the data logger, which must have been turned
   * on at the desired time. See the documentation of the YDataSet
   * class for information on how to get an overview of the
   * recorded data, and how to load progressively a large set
   * of measures from the data logger.
   *
   * This function only works if the device uses a recent firmware,
   * as YDataSet objects are not supported by firmwares older than
   * version 13000.
   *
   * @param startTime : the start of the desired measure time interval,
   *         as a Unix timestamp, i.e. the number of seconds since
   *         January 1, 1970 UTC. The special value 0 can be used
   *         to include any measure, without initial limit.
   * @param endTime : the end of the desired measure time interval,
   *         as a Unix timestamp, i.e. the number of seconds since
   *         January 1, 1970 UTC. The special value 0 can be used
   *         to include any measure, without ending limit.
   *
   * @return an instance of YDataSet, providing access to historical
   *         data. Past measures can be loaded progressively
   *         using methods from the YDataSet object.
   */
  async get_recordedData(startTime, endTime) {
    let funcid;
    let funit;
    funcid = await this.get_functionId();
    funit = await this.get_unit();
    return new YDataSet(this, funcid, funit, startTime, endTime);
  }
  /**
   * Registers the callback function that is invoked on every periodic timed notification.
   * The callback is invoked only during the execution of ySleep or yHandleEvents.
   * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
   * one of these two functions periodically. To unregister a callback, pass a null pointer as argument.
   *
   * @param callback : the callback function to call, or a null pointer. The callback function should take two
   *         arguments: the function object of which the value has changed, and an YMeasure object describing
   *         the new advertised value.
   * @noreturn
   */
  async registerTimedReportCallback(callback) {
    let sensor;
    sensor = this;
    if (callback != null) {
      await YFunction._UpdateTimedReportCallbackList(sensor, true);
    } else {
      await YFunction._UpdateTimedReportCallbackList(sensor, false);
    }
    this._timedReportCallbackSensor = callback;
    return 0;
  }
  async _invokeTimedReportCallback(value) {
    if (this._timedReportCallbackSensor != null) {
      try {
        await this._timedReportCallbackSensor(this, value);
      } catch (e) {
        this._yapi.imm_log("Exception in timedReportCallback:", e);
      }
    } else {
    }
    return 0;
  }
  /**
   * Configures error correction data points, in particular to compensate for
   * a possible perturbation of the measure caused by an enclosure. It is possible
   * to configure up to five correction points. Correction points must be provided
   * in ascending order, and be in the range of the sensor. The device will automatically
   * perform a linear interpolation of the error correction between specified
   * points. Remember to call the saveToFlash() method of the module if the
   * modification must be kept.
   *
   * For more information on advanced capabilities to refine the calibration of
   * sensors, please contact support@yoctopuce.com.
   *
   * @param rawValues : array of floating point numbers, corresponding to the raw
   *         values returned by the sensor for the correction points.
   * @param refValues : array of floating point numbers, corresponding to the corrected
   *         values for the correction points.
   *
   * @return YAPI.SUCCESS if the call succeeds.
   *
   * On failure, throws an exception or returns a negative error code.
   */
  async calibrateFromPoints(rawValues, refValues) {
    let rest_val;
    let res;
    rest_val = await this._encodeCalibrationPoints(rawValues, refValues);
    res = await this._setAttr("calibrationParam", rest_val);
    return res;
  }
  /**
   * Retrieves error correction data points previously entered using the method
   * calibrateFromPoints.
   *
   * @param rawValues : array of floating point numbers, that will be filled by the
   *         function with the raw sensor values for the correction points.
   * @param refValues : array of floating point numbers, that will be filled by the
   *         function with the desired values for the correction points.
   *
   * @return YAPI.SUCCESS if the call succeeds.
   *
   * On failure, throws an exception or returns a negative error code.
   */
  async loadCalibrationPoints(rawValues, refValues) {
    rawValues.length = 0;
    refValues.length = 0;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YAPI_DEVICE_NOT_FOUND;
      }
    }
    if (this._cal == null) {
      return YAPI_SUCCESS;
    }
    rawValues.length = 0;
    refValues.length = 0;
    for (let ii_0 of this._cal.raw) {
      rawValues.push(ii_0);
    }
    for (let ii_1 of this._cal.cal) {
      refValues.push(ii_1);
    }
    return YAPI_SUCCESS;
  }
  async _encodeCalibrationPoints(rawValues, refValues) {
    let res;
    let npt;
    let idx;
    npt = rawValues.length;
    if (npt != refValues.length) {
      this._throw(YAPI_INVALID_ARGUMENT, "Invalid calibration parameters (size mismatch)");
      return YAPI_INVALID_STRING;
    }
    if (npt == 0) {
      return "0";
    }
    res = String(Math.round(YOCTO_CALIB_TYPE_OFS));
    idx = 0;
    while (idx < npt) {
      res = res + "," + String(Math.round(rawValues[idx] * 1e3) / 1e3) + "," + String(Math.round(refValues[idx] * 1e3) / 1e3);
      idx = idx + 1;
    }
    return res;
  }
  async _applyCalibration(rawValue) {
    if (this._cal == null) {
      return rawValue;
    }
    if (rawValue == _YSensor.CURRENTVALUE_INVALID) {
      return _YSensor.CURRENTVALUE_INVALID;
    }
    return this._cal.hdl(rawValue, this._cal.typ, this._cal.par, this._cal.raw, this._cal.cal);
  }
  async _decodeTimedReport(timestamp, duration, report) {
    let i;
    let byteVal;
    let poww;
    let minRaw;
    let avgRaw;
    let maxRaw;
    let sublen;
    let difRaw;
    let startTime;
    let endTime;
    let minVal;
    let avgVal;
    let maxVal;
    if (duration > 0) {
      startTime = timestamp - duration;
    } else {
      startTime = this._prevTR;
    }
    endTime = timestamp;
    this._prevTR = endTime;
    if (startTime == 0) {
      startTime = endTime;
    }
    if (report.length <= 5) {
      poww = 1;
      avgRaw = 0;
      byteVal = 0;
      i = 1;
      while (i < report.length) {
        byteVal = report[i];
        avgRaw = avgRaw + poww * byteVal;
        poww = poww * 256;
        i = i + 1;
      }
      if ((byteVal & 128) != 0) {
        avgRaw = avgRaw - poww;
      }
      avgVal = avgRaw / 1e3;
      if (!(this._cal == null)) {
        avgVal = this._cal.hdl(avgVal, this._cal.typ, this._cal.par, this._cal.raw, this._cal.cal);
      }
      minVal = avgVal;
      maxVal = avgVal;
    } else {
      sublen = 1 + (report[1] & 3);
      poww = 1;
      avgRaw = 0;
      byteVal = 0;
      i = 2;
      while (sublen > 0 && i < report.length) {
        byteVal = report[i];
        avgRaw = avgRaw + poww * byteVal;
        poww = poww * 256;
        i = i + 1;
        sublen = sublen - 1;
      }
      if ((byteVal & 128) != 0) {
        avgRaw = avgRaw - poww;
      }
      sublen = 1 + (report[1] >> 2 & 3);
      poww = 1;
      difRaw = 0;
      while (sublen > 0 && i < report.length) {
        byteVal = report[i];
        difRaw = difRaw + poww * byteVal;
        poww = poww * 256;
        i = i + 1;
        sublen = sublen - 1;
      }
      minRaw = avgRaw - difRaw;
      sublen = 1 + (report[1] >> 4 & 3);
      poww = 1;
      difRaw = 0;
      while (sublen > 0 && i < report.length) {
        byteVal = report[i];
        difRaw = difRaw + poww * byteVal;
        poww = poww * 256;
        i = i + 1;
        sublen = sublen - 1;
      }
      maxRaw = avgRaw + difRaw;
      avgVal = avgRaw / 1e3;
      minVal = minRaw / 1e3;
      maxVal = maxRaw / 1e3;
      if (!(this._cal == null)) {
        avgVal = this._cal.hdl(avgVal, this._cal.typ, this._cal.par, this._cal.raw, this._cal.cal);
        minVal = this._cal.hdl(minVal, this._cal.typ, this._cal.par, this._cal.raw, this._cal.cal);
        maxVal = this._cal.hdl(maxVal, this._cal.typ, this._cal.par, this._cal.raw, this._cal.cal);
      }
    }
    return new YMeasure(startTime, endTime, minVal, avgVal, maxVal);
  }
  imm_decodeVal(w) {
    let val;
    val = w;
    if (!(this._cal == null)) {
      val = this._cal.hdl(val, this._cal.typ, this._cal.par, this._cal.raw, this._cal.cal);
    }
    return val;
  }
  imm_decodeAvg(dw) {
    let val;
    val = dw;
    if (!(this._cal == null)) {
      val = this._cal.hdl(val, this._cal.typ, this._cal.par, this._cal.raw, this._cal.cal);
    }
    return val;
  }
  /**
   * Continues the enumeration of sensors started using yFirstSensor().
   * Caution: You can't make any assumption about the returned sensors order.
   * If you want to find a specific a sensor, use Sensor.findSensor()
   * and a hardwareID or a logical name.
   *
   * @return a pointer to a YSensor object, corresponding to
   *         a sensor currently online, or a null pointer
   *         if there are no more sensors to enumerate.
   */
  nextSensor() {
    let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
    if (resolve.errorType != YAPI.SUCCESS)
      return null;
    let next_hwid = this._yapi.imm_getNextHardwareId(this._className, resolve.result);
    if (next_hwid == null)
      return null;
    return _YSensor.FindSensorInContext(this._yapi, next_hwid);
  }
  /**
   * Starts the enumeration of sensors currently accessible.
   * Use the method YSensor.nextSensor() to iterate on
   * next sensors.
   *
   * @return a pointer to a YSensor object, corresponding to
   *         the first sensor currently online, or a null pointer
   *         if there are none.
   */
  static FirstSensor() {
    let next_hwid = YAPI.imm_getFirstHardwareId("Sensor");
    if (next_hwid == null)
      return null;
    return _YSensor.FindSensor(next_hwid);
  }
  /**
   * Starts the enumeration of sensors currently accessible.
   * Use the method YSensor.nextSensor() to iterate on
   * next sensors.
   *
   * @param yctx : a YAPI context.
   *
   * @return a pointer to a YSensor object, corresponding to
   *         the first sensor currently online, or a null pointer
   *         if there are none.
   */
  static FirstSensorInContext(yctx) {
    let next_hwid = yctx.imm_getFirstHardwareId("Sensor");
    if (next_hwid == null)
      return null;
    return _YSensor.FindSensorInContext(yctx, next_hwid);
  }
};
YSensor.UNIT_INVALID = YAPI_INVALID_STRING;
YSensor.CURRENTVALUE_INVALID = YAPI_INVALID_DOUBLE;
YSensor.LOWESTVALUE_INVALID = YAPI_INVALID_DOUBLE;
YSensor.HIGHESTVALUE_INVALID = YAPI_INVALID_DOUBLE;
YSensor.CURRENTRAWVALUE_INVALID = YAPI_INVALID_DOUBLE;
YSensor.LOGFREQUENCY_INVALID = YAPI_INVALID_STRING;
YSensor.REPORTFREQUENCY_INVALID = YAPI_INVALID_STRING;
YSensor.ADVMODE_IMMEDIATE = 0;
YSensor.ADVMODE_PERIOD_AVG = 1;
YSensor.ADVMODE_PERIOD_MIN = 2;
YSensor.ADVMODE_PERIOD_MAX = 3;
YSensor.ADVMODE_INVALID = -1;
YSensor.CALIBRATIONPARAM_INVALID = YAPI_INVALID_STRING;
YSensor.RESOLUTION_INVALID = YAPI_INVALID_DOUBLE;
YSensor.SENSORSTATE_INVALID = YAPI_INVALID_INT;
var YMeasure = class {
  // API symbols as static members
  //--- (end of generated code: YMeasure attributes declaration)
  constructor(float_start, float_end, float_minVal, float_avgVal, float_maxVal) {
    this._start = 0;
    this._end = 0;
    this._minVal = 0;
    this._avgVal = 0;
    this._maxVal = 0;
    this._start = float_start;
    this._end = float_end;
    this._minVal = float_minVal;
    this._avgVal = float_avgVal;
    this._maxVal = float_maxVal;
  }
  //--- (generated code: YMeasure implementation)
  /**
   * Returns the start time of the measure, relative to the Jan 1, 1970 UTC
   * (Unix timestamp). When the recording rate is higher then 1 sample
   * per second, the timestamp may have a fractional part.
   *
   * @return a floating point number corresponding to the number of seconds
   *         between the Jan 1, 1970 UTC and the beginning of this measure.
   */
  get_startTimeUTC() {
    return this._start;
  }
  /**
   * Returns the end time of the measure, relative to the Jan 1, 1970 UTC
   * (Unix timestamp). When the recording rate is higher than 1 sample
   * per second, the timestamp may have a fractional part.
   *
   * @return a floating point number corresponding to the number of seconds
   *         between the Jan 1, 1970 UTC and the end of this measure.
   */
  get_endTimeUTC() {
    return this._end;
  }
  /**
   * Returns the smallest value observed during the time interval
   * covered by this measure.
   *
   * @return a floating-point number corresponding to the smallest value observed.
   */
  get_minValue() {
    return this._minVal;
  }
  /**
   * Returns the average value observed during the time interval
   * covered by this measure.
   *
   * @return a floating-point number corresponding to the average value observed.
   */
  get_averageValue() {
    return this._avgVal;
  }
  /**
   * Returns the largest value observed during the time interval
   * covered by this measure.
   *
   * @return a floating-point number corresponding to the largest value observed.
   */
  get_maxValue() {
    return this._maxVal;
  }
  //--- (end of generated code: YMeasure implementation)
  /**
   * Returns the start date of the measure.
   *
   * @return {Date} a Date object corresponding to the beginning of this measure
   */
  get_startTimeUTC_asDate() {
    return new Date(Math.round(this._start * 1e3));
  }
  /**
   * Returns the start date of the measure.
   *
   * @return {Date} a Date object corresponding to the end of this measure
   */
  get_endTimeUTC_asDate() {
    return new Date(Math.round(this._end * 1e3));
  }
};
var YDataLogger = class _YDataLogger extends YFunction {
  //--- (end of generated code: YDataLogger attributes declaration)
  constructor(yapi, func) {
    super(yapi, func);
    this._currentRunIndex = _YDataLogger.CURRENTRUNINDEX_INVALID;
    this._timeUTC = _YDataLogger.TIMEUTC_INVALID;
    this._recording = _YDataLogger.RECORDING_INVALID;
    this._autoStart = _YDataLogger.AUTOSTART_INVALID;
    this._beaconDriven = _YDataLogger.BEACONDRIVEN_INVALID;
    this._usage = _YDataLogger.USAGE_INVALID;
    this._clearHistory = _YDataLogger.CLEARHISTORY_INVALID;
    this._valueCallbackDataLogger = null;
    this.CURRENTRUNINDEX_INVALID = YAPI_INVALID_UINT;
    this.TIMEUTC_INVALID = YAPI_INVALID_LONG;
    this.RECORDING_OFF = 0;
    this.RECORDING_ON = 1;
    this.RECORDING_PENDING = 2;
    this.RECORDING_INVALID = -1;
    this.AUTOSTART_OFF = 0;
    this.AUTOSTART_ON = 1;
    this.AUTOSTART_INVALID = -1;
    this.BEACONDRIVEN_OFF = 0;
    this.BEACONDRIVEN_ON = 1;
    this.BEACONDRIVEN_INVALID = -1;
    this.USAGE_INVALID = YAPI_INVALID_UINT;
    this.CLEARHISTORY_FALSE = 0;
    this.CLEARHISTORY_TRUE = 1;
    this.CLEARHISTORY_INVALID = -1;
    this._className = "DataLogger";
  }
  //--- (generated code: YDataLogger implementation)
  imm_parseAttr(name, val) {
    switch (name) {
      case "currentRunIndex":
        this._currentRunIndex = val;
        return 1;
      case "timeUTC":
        this._timeUTC = val;
        return 1;
      case "recording":
        this._recording = val;
        return 1;
      case "autoStart":
        this._autoStart = val;
        return 1;
      case "beaconDriven":
        this._beaconDriven = val;
        return 1;
      case "usage":
        this._usage = val;
        return 1;
      case "clearHistory":
        this._clearHistory = val;
        return 1;
    }
    return super.imm_parseAttr(name, val);
  }
  /**
   * Returns the current run number, corresponding to the number of times the module was
   * powered on with the dataLogger enabled at some point.
   *
   * @return an integer corresponding to the current run number, corresponding to the number of times the module was
   *         powered on with the dataLogger enabled at some point
   *
   * On failure, throws an exception or returns YDataLogger.CURRENTRUNINDEX_INVALID.
   */
  async get_currentRunIndex() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return _YDataLogger.CURRENTRUNINDEX_INVALID;
      }
    }
    res = this._currentRunIndex;
    return res;
  }
  /**
   * Returns the Unix timestamp for current UTC time, if known.
   *
   * @return an integer corresponding to the Unix timestamp for current UTC time, if known
   *
   * On failure, throws an exception or returns YDataLogger.TIMEUTC_INVALID.
   */
  async get_timeUTC() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return _YDataLogger.TIMEUTC_INVALID;
      }
    }
    res = this._timeUTC;
    return res;
  }
  /**
   * Changes the current UTC time reference used for recorded data.
   *
   * @param newval : an integer corresponding to the current UTC time reference used for recorded data
   *
   * @return YAPI.SUCCESS if the call succeeds.
   *
   * On failure, throws an exception or returns a negative error code.
   */
  async set_timeUTC(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("timeUTC", rest_val);
  }
  /**
   * Returns the current activation state of the data logger.
   *
   * @return a value among YDataLogger.RECORDING_OFF, YDataLogger.RECORDING_ON and
   * YDataLogger.RECORDING_PENDING corresponding to the current activation state of the data logger
   *
   * On failure, throws an exception or returns YDataLogger.RECORDING_INVALID.
   */
  async get_recording() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return _YDataLogger.RECORDING_INVALID;
      }
    }
    res = this._recording;
    return res;
  }
  /**
   * Changes the activation state of the data logger to start/stop recording data.
   *
   * @param newval : a value among YDataLogger.RECORDING_OFF, YDataLogger.RECORDING_ON and
   * YDataLogger.RECORDING_PENDING corresponding to the activation state of the data logger to
   * start/stop recording data
   *
   * @return YAPI.SUCCESS if the call succeeds.
   *
   * On failure, throws an exception or returns a negative error code.
   */
  async set_recording(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("recording", rest_val);
  }
  /**
   * Returns the default activation state of the data logger on power up.
   *
   * @return either YDataLogger.AUTOSTART_OFF or YDataLogger.AUTOSTART_ON, according to the default
   * activation state of the data logger on power up
   *
   * On failure, throws an exception or returns YDataLogger.AUTOSTART_INVALID.
   */
  async get_autoStart() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return _YDataLogger.AUTOSTART_INVALID;
      }
    }
    res = this._autoStart;
    return res;
  }
  /**
   * Changes the default activation state of the data logger on power up.
   * Do not forget to call the saveToFlash() method of the module to save the
   * configuration change.  Note: if the device doesn't have any time source at his disposal when
   * starting up, it will wait for ~8 seconds before automatically starting to record  with
   * an arbitrary timestamp
   *
   * @param newval : either YDataLogger.AUTOSTART_OFF or YDataLogger.AUTOSTART_ON, according to the
   * default activation state of the data logger on power up
   *
   * @return YAPI.SUCCESS if the call succeeds.
   *
   * On failure, throws an exception or returns a negative error code.
   */
  async set_autoStart(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("autoStart", rest_val);
  }
  /**
   * Returns true if the data logger is synchronised with the localization beacon.
   *
   * @return either YDataLogger.BEACONDRIVEN_OFF or YDataLogger.BEACONDRIVEN_ON, according to true if
   * the data logger is synchronised with the localization beacon
   *
   * On failure, throws an exception or returns YDataLogger.BEACONDRIVEN_INVALID.
   */
  async get_beaconDriven() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return _YDataLogger.BEACONDRIVEN_INVALID;
      }
    }
    res = this._beaconDriven;
    return res;
  }
  /**
   * Changes the type of synchronisation of the data logger.
   * Remember to call the saveToFlash() method of the module if the
   * modification must be kept.
   *
   * @param newval : either YDataLogger.BEACONDRIVEN_OFF or YDataLogger.BEACONDRIVEN_ON, according to
   * the type of synchronisation of the data logger
   *
   * @return YAPI.SUCCESS if the call succeeds.
   *
   * On failure, throws an exception or returns a negative error code.
   */
  async set_beaconDriven(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("beaconDriven", rest_val);
  }
  /**
   * Returns the percentage of datalogger memory in use.
   *
   * @return an integer corresponding to the percentage of datalogger memory in use
   *
   * On failure, throws an exception or returns YDataLogger.USAGE_INVALID.
   */
  async get_usage() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return _YDataLogger.USAGE_INVALID;
      }
    }
    res = this._usage;
    return res;
  }
  async get_clearHistory() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return _YDataLogger.CLEARHISTORY_INVALID;
      }
    }
    res = this._clearHistory;
    return res;
  }
  async set_clearHistory(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("clearHistory", rest_val);
  }
  /**
   * Retrieves a data logger for a given identifier.
   * The identifier can be specified using several formats:
   *
   * - FunctionLogicalName
   * - ModuleSerialNumber.FunctionIdentifier
   * - ModuleSerialNumber.FunctionLogicalName
   * - ModuleLogicalName.FunctionIdentifier
   * - ModuleLogicalName.FunctionLogicalName
   *
   *
   * This function does not require that the data logger is online at the time
   * it is invoked. The returned object is nevertheless valid.
   * Use the method YDataLogger.isOnline() to test if the data logger is
   * indeed online at a given time. In case of ambiguity when looking for
   * a data logger by logical name, no error is notified: the first instance
   * found is returned. The search is performed first by hardware name,
   * then by logical name.
   *
   * If a call to this object's is_online() method returns FALSE although
   * you are certain that the matching device is plugged, make sure that you did
   * call registerHub() at application initialization time.
   *
   * @param func : a string that uniquely characterizes the data logger, for instance
   *         LIGHTMK4.dataLogger.
   *
   * @return a YDataLogger object allowing you to drive the data logger.
   */
  static FindDataLogger(func) {
    let obj;
    obj = YFunction._FindFromCache("DataLogger", func);
    if (obj == null) {
      obj = new _YDataLogger(YAPI, func);
      YFunction._AddToCache("DataLogger", func, obj);
    }
    return obj;
  }
  /**
   * Retrieves a data logger for a given identifier in a YAPI context.
   * The identifier can be specified using several formats:
   *
   * - FunctionLogicalName
   * - ModuleSerialNumber.FunctionIdentifier
   * - ModuleSerialNumber.FunctionLogicalName
   * - ModuleLogicalName.FunctionIdentifier
   * - ModuleLogicalName.FunctionLogicalName
   *
   *
   * This function does not require that the data logger is online at the time
   * it is invoked. The returned object is nevertheless valid.
   * Use the method YDataLogger.isOnline() to test if the data logger is
   * indeed online at a given time. In case of ambiguity when looking for
   * a data logger by logical name, no error is notified: the first instance
   * found is returned. The search is performed first by hardware name,
   * then by logical name.
   *
   * @param yctx : a YAPI context
   * @param func : a string that uniquely characterizes the data logger, for instance
   *         LIGHTMK4.dataLogger.
   *
   * @return a YDataLogger object allowing you to drive the data logger.
   */
  static FindDataLoggerInContext(yctx, func) {
    let obj;
    obj = YFunction._FindFromCacheInContext(yctx, "DataLogger", func);
    if (obj == null) {
      obj = new _YDataLogger(yctx, func);
      YFunction._AddToCache("DataLogger", func, obj);
    }
    return obj;
  }
  /**
   * Registers the callback function that is invoked on every change of advertised value.
   * The callback is invoked only during the execution of ySleep or yHandleEvents.
   * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
   * one of these two functions periodically. To unregister a callback, pass a null pointer as argument.
   *
   * @param callback : the callback function to call, or a null pointer. The callback function should take two
   *         arguments: the function object of which the value has changed, and the character string describing
   *         the new advertised value.
   * @noreturn
   */
  async registerValueCallback(callback) {
    let val;
    if (callback != null) {
      await YFunction._UpdateValueCallbackList(this, true);
    } else {
      await YFunction._UpdateValueCallbackList(this, false);
    }
    this._valueCallbackDataLogger = callback;
    if (callback != null && await this.isOnline()) {
      val = this._advertisedValue;
      if (!(val == "")) {
        await this._invokeValueCallback(val);
      }
    }
    return 0;
  }
  async _invokeValueCallback(value) {
    if (this._valueCallbackDataLogger != null) {
      try {
        await this._valueCallbackDataLogger(this, value);
      } catch (e) {
        this._yapi.imm_log("Exception in valueCallback:", e);
      }
    } else {
      await super._invokeValueCallback(value);
    }
    return 0;
  }
  /**
   * Clears the data logger memory and discards all recorded data streams.
   * This method also resets the current run index to zero.
   *
   * @return YAPI.SUCCESS if the call succeeds.
   *
   * On failure, throws an exception or returns a negative error code.
   */
  async forgetAllDataStreams() {
    return await this.set_clearHistory(
      1
      /* YDataLogger.CLEARHISTORY.TRUE */
    );
  }
  /**
   * Returns a list of YDataSet objects that can be used to retrieve
   * all measures stored by the data logger.
   *
   * This function only works if the device uses a recent firmware,
   * as YDataSet objects are not supported by firmwares older than
   * version 13000.
   *
   * @return a list of YDataSet object.
   *
   * On failure, throws an exception or returns an empty list.
   */
  async get_dataSets() {
    return await this.parse_dataSets(await this._download("logger.json"));
  }
  async parse_dataSets(jsonbuff) {
    let dslist = [];
    let dataset;
    let res = [];
    dslist = this.imm_json_get_array(jsonbuff);
    res.length = 0;
    for (let ii_0 of dslist) {
      dataset = new YDataSet(this);
      await dataset._parse(this._yapi.imm_bin2str(ii_0));
      res.push(dataset);
    }
    return res;
  }
  /**
   * Continues the enumeration of data loggers started using yFirstDataLogger().
   * Caution: You can't make any assumption about the returned data loggers order.
   * If you want to find a specific a data logger, use DataLogger.findDataLogger()
   * and a hardwareID or a logical name.
   *
   * @return a pointer to a YDataLogger object, corresponding to
   *         a data logger currently online, or a null pointer
   *         if there are no more data loggers to enumerate.
   */
  nextDataLogger() {
    let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
    if (resolve.errorType != YAPI.SUCCESS)
      return null;
    let next_hwid = this._yapi.imm_getNextHardwareId(this._className, resolve.result);
    if (next_hwid == null)
      return null;
    return _YDataLogger.FindDataLoggerInContext(this._yapi, next_hwid);
  }
  /**
   * Starts the enumeration of data loggers currently accessible.
   * Use the method YDataLogger.nextDataLogger() to iterate on
   * next data loggers.
   *
   * @return a pointer to a YDataLogger object, corresponding to
   *         the first data logger currently online, or a null pointer
   *         if there are none.
   */
  static FirstDataLogger() {
    let next_hwid = YAPI.imm_getFirstHardwareId("DataLogger");
    if (next_hwid == null)
      return null;
    return _YDataLogger.FindDataLogger(next_hwid);
  }
  /**
   * Starts the enumeration of data loggers currently accessible.
   * Use the method YDataLogger.nextDataLogger() to iterate on
   * next data loggers.
   *
   * @param yctx : a YAPI context.
   *
   * @return a pointer to a YDataLogger object, corresponding to
   *         the first data logger currently online, or a null pointer
   *         if there are none.
   */
  static FirstDataLoggerInContext(yctx) {
    let next_hwid = yctx.imm_getFirstHardwareId("DataLogger");
    if (next_hwid == null)
      return null;
    return _YDataLogger.FindDataLoggerInContext(yctx, next_hwid);
  }
};
YDataLogger.CURRENTRUNINDEX_INVALID = YAPI_INVALID_UINT;
YDataLogger.TIMEUTC_INVALID = YAPI_INVALID_LONG;
YDataLogger.RECORDING_OFF = 0;
YDataLogger.RECORDING_ON = 1;
YDataLogger.RECORDING_PENDING = 2;
YDataLogger.RECORDING_INVALID = -1;
YDataLogger.AUTOSTART_OFF = 0;
YDataLogger.AUTOSTART_ON = 1;
YDataLogger.AUTOSTART_INVALID = -1;
YDataLogger.BEACONDRIVEN_OFF = 0;
YDataLogger.BEACONDRIVEN_ON = 1;
YDataLogger.BEACONDRIVEN_INVALID = -1;
YDataLogger.USAGE_INVALID = YAPI_INVALID_UINT;
YDataLogger.CLEARHISTORY_FALSE = 0;
YDataLogger.CLEARHISTORY_TRUE = 1;
YDataLogger.CLEARHISTORY_INVALID = -1;
var YSystemEnv = class {
  constructor() {
    this.isNodeJS = false;
    this.hasSSDP = false;
  }
  unknownSystemEnvError() {
    return new YoctoError("Unspecified runtime environment, your project should include at least once either yocto_api_nodejs or yocto_api_html");
  }
  hookUnhandledRejection(handler) {
    throw this.unknownSystemEnvError();
  }
  getWebSocketEngine(hub, runtime_urlInfo) {
    throw this.unknownSystemEnvError();
  }
  getHttpEngine(hub, runtime_urlInfo, infojson) {
    throw this.unknownSystemEnvError();
  }
  getWebSocketCallbackEngine(hub, runtime_urlInfo, ws) {
    throw this.unknownSystemEnvError();
  }
  getHttpCallbackEngine(hub, runtime_urlInfo, incomingMessage, serverResponse) {
    throw this.unknownSystemEnvError();
  }
  getSSDPManager(obj_yapi) {
    throw this.unknownSystemEnvError();
  }
  async loadfile(file) {
    throw this.unknownSystemEnvError();
  }
  async downloadfile(url, yapi) {
    throw this.unknownSystemEnvError();
  }
  async downloadRemoteCertificate(urlinfo) {
    throw this.unknownSystemEnvError();
  }
};
var _UnspecifiedSystemEnv = new YSystemEnv();
var YHubEngine = class {
  constructor(hub, runtime_urlInfo) {
    this.lastPingStamp = 0;
    this._hub = hub;
    this._runtime_urlInfo = runtime_urlInfo;
  }
  /** Attempt to establish a connection to the hub asynchronously.
   *
   * On success, this method should call this.signalHubConnected()
   * On temporary failure, this method should call this.imm_signalHubDisconnected()
   * On fatal failure, this method should call this.imm_commonDisconnect()
   *
   * This method is supposed to be redefined by subclasses
   */
  async reconnectEngine(tryOpenID) {
  }
  imm_disconnectEngineNow(connID = "") {
  }
  /** Perform an HTTP query on the hub
   */
  async request(method, devUrl, obj_body, tcpchan) {
    let res = new YHTTPRequest(null);
    res.errorType = YAPI_NOT_SUPPORTED;
    res.errorMsg = "GenericHub subclass expected";
    return res;
  }
  // default implementation of function that reports a fatal error to the HTTP callback party
  async reportFailure(message) {
  }
  imm_updateLastPinfStamp() {
    this.lastPingStamp = Date.now();
  }
  imm_isConnected() {
    return Date.now() - this.lastPingStamp < this._hub.imm_getNetworkTimeout();
  }
  imm_isForwarded() {
    return false;
  }
  async waitForPendingQueries(ms_duration) {
  }
};
var HubMode;
(function(HubMode2) {
  HubMode2[HubMode2["LEGACY"] = 0] = "LEGACY";
  HubMode2[HubMode2["MIXED"] = 1] = "MIXED";
  HubMode2[HubMode2["SECURE"] = 2] = "SECURE";
  HubMode2[HubMode2["PROTO_UNKNOWN"] = 3] = "PROTO_UNKNOWN";
})(HubMode || (HubMode = {}));
var YGenericHub = class _YGenericHub {
  constructor(yapi, urlInfo) {
    this._lastErrorType = YAPI_IO_ERROR;
    this._lastErrorMsg = "Hub attachment has not been triggered";
    this.hubSerial = "";
    this.serialByYdx = [];
    this._currentState = -6;
    this._targetState = -5;
    this.currentConnID = "";
    this.connResolvers = [];
    this.disconnResolvers = [];
    this.retryDelay = 15;
    this._reconnectionTimer = null;
    this._rwAccess = null;
    this.keepTryingExpiration = 0;
    this.keepTryingTimeoutId = null;
    this.timeoutId = null;
    this.isNotifWorking = false;
    this.devListExpires = 0;
    this.notifPos = -1;
    this.notifCarryOver = "";
    this._firstArrivalCallback = true;
    this._missing = {};
    this._knownUrls = [];
    this._portInfo = [];
    this._usePureHTTP = false;
    this._yapi = yapi;
    this.urlInfo = urlInfo;
    this.stalledTimeoutMs = yapi._networkTimeoutMs;
    this._hubRef = _YGenericHub.globalHubRefCounter++;
    this._hubEngine = null;
    this._hubMode = HubMode.SECURE;
  }
  _throw(int_errType, str_errMsg, obj_retVal) {
    this._lastErrorType = int_errType;
    this._lastErrorMsg = str_errMsg;
    return this._yapi._throw(int_errType, str_errMsg, obj_retVal);
  }
  imm_isFirstArrivalCallback() {
    return this._firstArrivalCallback;
  }
  imm_setFirstArrivalCallback(isfirst) {
    this._firstArrivalCallback = isfirst;
  }
  imm_getNotifyPos() {
    return this.notifPos;
  }
  imm_getcurrentState() {
    return this._currentState;
  }
  imm_getCurrentConnID() {
    return this.currentConnID;
  }
  imm_setCurrentConnID(id) {
    this.currentConnID = id;
  }
  /**
   * Returns the numerical error code of the latest error with the function.
   * This method is mostly useful when using the Yoctopuce library with
   * exceptions disabled.
   *
   * @return a number corresponding to the code of the latest error that occurred while
   *         using the function object
   */
  get_errorType() {
    return this._lastErrorType;
  }
  /**
   * Returns the error message of the latest error with the function.
   * This method is mostly useful when using the Yoctopuce library with
   * exceptions disabled.
   *
   * @return a string corresponding to the latest error message that occured while
   *         using the function object
   */
  get_errorMessage() {
    if (this._lastErrorType == YAPI_SUCCESS) {
      return "";
    }
    return this._lastErrorMsg;
  }
  imm_forceUpdate() {
    this.devListExpires = this._yapi.GetTickCount();
  }
  imm_logrequest(method, devUrl, obj_body) {
    let msg = "Request: " + method + " " + devUrl;
    if (obj_body) {
      msg += " (file=" + obj_body.fname + ")";
    }
    this._yapi.imm_log(msg);
  }
  imm_setState(newState) {
    this._currentState = newState;
  }
  imm_setTargetState(newState) {
    this._targetState = newState;
  }
  imm_isDisconnecting() {
    return this._targetState <= -5;
  }
  imm_isDisconnected() {
    return this._targetState <= -5 && this._currentState <= -5;
  }
  imm_isPreOrRegistered() {
    return this._targetState >= 1;
  }
  // default implementation of isOnline
  imm_isOnline() {
    if (this._hubEngine) {
      return this._hubEngine.imm_isConnected();
    }
    return false;
  }
  imm_getConnectionState() {
    if (this.imm_isOnline()) {
      return YHub.CONNECTED;
    }
    if (this._targetState <= -5) {
      return YHub.ABORTED;
    }
    return YHub.TRYING;
  }
  // default implementation of function that says if a hub is currently forwarded and handled remotely
  imm_isForwarded() {
    if (this._hubEngine) {
      return this._hubEngine.imm_isForwarded();
    }
    return false;
  }
  imm_addKnownUrl(urlInfo) {
    if (!this._knownUrls.includes(urlInfo.imm_getOriginalURL())) {
      this._knownUrls.push(urlInfo.imm_getOriginalURL());
    }
  }
  imm_updateUrl(urlInfo) {
    if (!this._knownUrls.includes(urlInfo.imm_getOriginalURL())) {
      this._knownUrls.push(urlInfo.imm_getOriginalURL());
    }
    if (this.urlInfo.imm_getUrl(false, true, true) == urlInfo.imm_getUrl(false, true, true)) {
      this.urlInfo.imm_updateFrom(urlInfo);
      return;
    }
    this.urlInfo.imm_updateFrom(urlInfo);
    if (this._currentState < -1) {
      if (this._yapi._logLevel >= 4) {
        this._yapi.imm_log("Updating auth credentials for " + this.urlInfo.imm_getRootUrl());
      }
    }
  }
  imm_updateForRedirect(url) {
    let ofs = url.indexOf("://");
    if (ofs > 0) {
      ofs = url.indexOf("/", ofs + 3);
      if (ofs > 0) {
        url = url.substring(0, ofs);
      }
    }
    let new_url = new _YY_UrlInfo(url);
    this.urlInfo.imm_updateForRedirect(new_url.imm_getHost(), new_url.imm_getPort(), new_url.imm_useSecureSocket());
    if (this._yapi._logLevel >= 4) {
      this._yapi.imm_log("Updating URL after HTTP redirection : " + this.urlInfo.imm_getRootUrl());
    }
    let primaryHub = this._yapi._knownHubsByUrl[new_url.imm_getRootUrl()];
    if (primaryHub && primaryHub !== this) {
      if (primaryHub.urlInfo.imm_useSecureSocket()) {
        if (primaryHub._currentState >= this._currentState) {
          primaryHub.imm_inheritFrom(this);
          this._yapi.imm_updateRegisteredHubs(this, false);
          return;
        }
      }
      this._yapi._knownHubsByUrl[this.urlInfo.imm_getRootUrl()] = this;
      this.imm_inheritFrom(primaryHub);
      this._yapi.imm_updateRegisteredHubs(primaryHub, false);
    } else {
      this._yapi._knownHubsByUrl[new_url.imm_getRootUrl()] = this;
    }
  }
  imm_inheritFrom(otherHub) {
    if (this._targetState < otherHub._targetState) {
      this.imm_setTargetState(otherHub._targetState);
    }
    for (let j = 0; j < otherHub.serialByYdx.length; j++) {
      let serial = otherHub.serialByYdx[j];
      if (serial && !this.serialByYdx[j]) {
        this.serialByYdx[j] = serial;
      }
    }
    if (this._currentState >= 0 && otherHub._currentState < 0) {
      let res_struct = { errorType: YAPI_SUCCESS, errorMsg: "Hub " + this.hubSerial + " already connected" };
      let resolvers = otherHub.connResolvers;
      for (let resolveOne of resolvers) {
        resolveOne(res_struct);
      }
    } else {
      for (let resolver of otherHub.connResolvers) {
        this.connResolvers.push(resolver);
      }
    }
    otherHub.connResolvers = [];
    if (this._yapi._logLevel >= 3) {
      this._yapi.imm_log("Hub " + this.hubSerial + " is connected as " + this.urlInfo.imm_getRootUrl() + ", dropping connection to " + otherHub.urlInfo.imm_getRootUrl());
    }
    otherHub.imm_commonDisconnect("inherit", YAPI_SUCCESS, "Hub " + this.hubSerial + " is already connected via " + this.urlInfo.imm_getRootUrl());
    otherHub.imm_disconnectNow();
    for (const url of otherHub.get_knownUrls()) {
      if (!this._knownUrls.includes(url)) {
        this._knownUrls.push(url);
      }
    }
  }
  imm_getNewConnID() {
    let time = /* @__PURE__ */ new Date();
    return (time.getHours() + "h" + time.getMinutes() + "m" + time.getTime() % 6e4 / 1e3).toString() + "_0";
  }
  imm_tryTestConnectFor(mstimeout) {
    let minimalExpiration = Date.now() + mstimeout;
    if (this.keepTryingExpiration < minimalExpiration) {
      this.keepTryingExpiration = minimalExpiration;
      if (this.keepTryingTimeoutId) {
        clearTimeout(this.keepTryingTimeoutId);
      }
      this.keepTryingTimeoutId = setTimeout(() => {
        this.keepTryingTimeoutId = null;
        if (this._targetState == 0) {
          if (this._yapi._logLevel >= 4) {
            this._yapi.imm_log("TestHub timeout reached, disconnecting");
          }
          this.detach(YAPI.IO_ERROR, "TestHub timeout reached");
        }
      }, mstimeout);
    }
  }
  /** Trigger the setup of a connection to the target hub, and return.
   * This method uses a connection helper that is overridden by each type of hub.
   */
  async attach(targetConnType) {
    if (this._targetState <= 0 || targetConnType > 0) {
      this._lastErrorType = 0;
      this._lastErrorMsg = "Reconnecting";
      this.imm_setTargetState(targetConnType);
      if (this._currentState == 0 && targetConnType > 0) {
        try {
          await this._yapi._ensureUpdateDeviceListNotRunning();
          await this._yapi._addConnectedHub(this);
          this.imm_setState(targetConnType);
        } catch (e) {
          this.imm_disconnectNow();
        }
      }
      if (targetConnType == 0) {
        this.imm_tryTestConnectFor(100);
      }
    }
    if (this._currentState <= -5) {
      if (this._yapi._logLevel >= 4) {
        this._yapi.imm_log("New hub is detached connecting...");
      }
      this._hubEngine = null;
      this.stalledTimeoutMs = this._yapi._networkTimeoutMs;
      this.imm_setState(
        -1
        /* Y_YHubConnType.HUB_CONNECTING */
      );
      this.reconnect(this.imm_getNewConnID());
    } else if (this._currentState == -3) {
      if (this._reconnectionTimer) {
        if (this._yapi._logLevel >= 4) {
          this._yapi.imm_log("New hub connection requested, retry now (drop [" + this.currentConnID + "])");
        }
        clearTimeout(this._reconnectionTimer);
        this._reconnectionTimer = null;
        this.currentConnID = "";
      } else {
        if (this._yapi._logLevel >= 4) {
          this._yapi.imm_log("New hub connection requested, retry now (no pending reconnection ?!?)");
        }
      }
      this.reconnect(this.imm_getNewConnID());
    } else if (this._currentState == -4 || this._currentState == -2) {
      if (this._yapi._logLevel >= 4) {
        this._yapi.imm_log("Hub is currently disconnecting, reconnection will be triggered soon [" + this.currentConnID + "]");
        this._yapi.imm_log("Current state: " + this._currentState);
        this._yapi.imm_log("Target state: " + this._targetState + " (" + targetConnType + ")");
      }
    }
  }
  /** Wait until the connection to the hub is established
   */
  async waitForConnection(mstimeout, errmsg) {
    if (this._targetState < 0) {
      errmsg.msg = this._lastErrorMsg;
      return this._lastErrorType;
    }
    if (this._currentState >= 0) {
      return YAPI_SUCCESS;
    }
    if (mstimeout <= 1) {
      errmsg.msg = "Hub not connected";
      return YAPI_TIMEOUT;
    }
    if (this._targetState == 0) {
      this.imm_tryTestConnectFor(mstimeout);
    }
    let connOpenPromise = null;
    let connOpenTimeoutObj = null;
    let addResolverPromise;
    addResolverPromise = new Promise((resolverReady, noResolver) => {
      connOpenPromise = new Promise((resolve, reject) => {
        this.connResolvers.push(resolve);
        resolverReady(resolve);
        connOpenTimeoutObj = setTimeout(() => {
          if (this._yapi._logLevel >= 4) {
            this._yapi.imm_log("Timeout waiting for hub connection");
          }
          resolve({ errorType: YAPI_TIMEOUT, errorMsg: "Timeout waiting for hub connection" });
        }, mstimeout);
      });
    });
    let resolver = await addResolverPromise;
    if (this._targetState < 0) {
      clearTimeout(connOpenTimeoutObj);
      errmsg.msg = this._lastErrorMsg;
      return this._lastErrorType;
    }
    if (this._currentState >= 0) {
      clearTimeout(connOpenTimeoutObj);
      return YAPI_SUCCESS;
    }
    let openRes = await connOpenPromise;
    clearTimeout(connOpenTimeoutObj);
    if (openRes.errorType != YAPI_SUCCESS) {
      if (errmsg) {
        errmsg.msg = openRes.errorMsg;
      }
    }
    return openRes.errorType;
  }
  /** Attempt to establish a connection to the hub asynchronously.
   *
   * On success, this method should call this.signalHubConnected()
   * On temporary failure, this method should call this.imm_signalHubDisconnected()
   * On fatal failure, this method should call this.imm_commonDisconnect()
   *
   * This method is supposed to be redefined by subclasses
   */
  async reconnect(tryOpenID) {
    if (!this._hubEngine) {
      if (this._yapi._logLevel >= 4) {
        this._yapi.imm_log("look for suitable Hub engine [" + tryOpenID + "]");
      }
      this._usePureHTTP = false;
      this._portInfo = [];
      let infoJson = null;
      if (this.urlInfo.imm_testInfoJson()) {
        let https_req = this.urlInfo.imm_useSecureSocket();
        if (this.urlInfo.imm_getPort() == YAPI.YOCTO_DEFAULT_HTTPS_PORT) {
          https_req = true;
        }
        let url = (https_req ? "https://" : "http://") + this.urlInfo.imm_getUrl(false, false, true) + "info.json";
        if (this._yapi._logLevel >= 4) {
          this._yapi.imm_log("look for info.json at " + url + " [" + tryOpenID + "]");
        }
        try {
          let data = await this._yapi.system_env.downloadfile(url, this._yapi);
          infoJson = JSON.parse(YAPI.imm_bin2str(data));
          if (infoJson) {
            if (infoJson.serialNumber) {
              this.imm_setSerialNumber(infoJson.serialNumber);
            }
            if (infoJson.securityMode !== void 0 && infoJson.securityMode == 0) {
              this.imm_commonDisconnect(tryOpenID, YAPI.UNCONFIGURED, "Remote hub is not yet configured");
              this.imm_disconnectNow();
              return;
            }
            if (infoJson.protocol && infoJson.protocol == "HTTP/1.1") {
              this._usePureHTTP = true;
            }
            if (infoJson.port) {
              let i = 0;
              while (i < infoJson.port.length) {
                let proto_port = infoJson.port[i++];
                let split = proto_port.split(":");
                let proto = split[0];
                let port = YAPIContext.imm_atoi(split[1]);
                if (port == 0) {
                  break;
                }
                this._portInfo.push({ proto, port });
              }
            }
          }
          if (this._yapi._logLevel >= 4) {
            this._yapi.imm_log("info.json successfully parsed " + url + " [" + tryOpenID + "]");
          }
        } catch (e) {
          if (e.errorType == YAPI.SSL_UNK_CERT) {
            this.imm_commonDisconnect(tryOpenID, YAPI.SSL_UNK_CERT, e.message);
            this.imm_disconnectNow();
            return;
          } else {
            if (this._yapi._logLevel >= 4) {
              this._yapi.imm_log("Unable to get info.json from " + url + " [" + tryOpenID + "]");
            }
            let serialurl = (https_req ? "https://" : "http://") + this.urlInfo.imm_getUrl(false, false, false) + "/api/module/serialNumber";
            try {
              let data = await this._yapi.system_env.downloadfile(serialurl, this._yapi);
              this.imm_setSerialNumber(YAPI.imm_bin2str(data));
            } catch (e2) {
              this.imm_commonDisconnect(tryOpenID, YAPI.IO_ERROR, e2.message);
              return;
            }
          }
        }
      }
      const runtimeUrl = this.imm_UseBestProto();
      if (runtimeUrl.imm_useWebSocket()) {
        if (this._yapi._logLevel >= 4) {
          this._yapi.imm_log("Use WebSocket hub engine [" + tryOpenID + "]");
        }
        this._hubEngine = this._yapi.system_env.getWebSocketEngine(this, runtimeUrl);
      } else {
        if (this._yapi._logLevel >= 4) {
          this._yapi.imm_log("Use HTTP hub engine [" + tryOpenID + "]");
        }
        this._hubEngine = this._yapi.system_env.getHttpEngine(this, runtimeUrl, infoJson);
      }
      if (!this._hubEngine) {
        this.imm_commonDisconnect(tryOpenID, YAPI_NOT_SUPPORTED, "Unsupported hub protocol: " + runtimeUrl.imm_getProto());
        return;
      }
    }
    await this._hubEngine.reconnectEngine(tryOpenID);
  }
  /** Invoked by this.reconnect() to handle successful hub connection
   */
  async signalHubConnected(tryOpenID, hubSerial) {
    this.imm_setState(
      0
      /* Y_YHubConnType.HUB_CONNECTED */
    );
    this.hubSerial = hubSerial;
    if (this._yapi._logLevel >= 4) {
      this._yapi.imm_log("Hub " + hubSerial + " connected [" + tryOpenID + "]");
    }
    let primaryHub = this._yapi.imm_getPrimaryHub(this);
    if (primaryHub._targetState >= 1) {
      if (primaryHub._currentState < 1) {
        try {
          await primaryHub._yapi._ensureUpdateDeviceListNotRunning();
          await primaryHub._yapi._addConnectedHub(primaryHub);
        } catch (e) {
          primaryHub.imm_disconnectNow();
          return;
        }
      }
      if (primaryHub._currentState < primaryHub._targetState) {
        primaryHub.imm_setState(primaryHub._targetState);
      }
    } else {
      primaryHub.keepTryingExpiration = 0;
      primaryHub.imm_tryTestConnectFor(100);
    }
    let res_struct = { errorType: YAPI_SUCCESS, errorMsg: "Hub " + hubSerial + " connected" };
    let resolvers = primaryHub.connResolvers;
    primaryHub.connResolvers = [];
    primaryHub._lastErrorType = res_struct.errorType;
    primaryHub._lastErrorMsg = res_struct.errorMsg;
    for (let resolveOne of resolvers) {
      resolveOne(res_struct);
    }
  }
  /** Invoked by the network handler to signal hub disconnection
   *
   * Returns true if a reconnection has been scheduled
   *     or false if the target state is "detached"
   */
  imm_signalHubDisconnected(tryOpenID) {
    if (this._yapi._logLevel >= 4) {
      this._yapi.imm_log("imm_signalHubDisconnected  " + this.urlInfo.imm_getRootUrl());
    }
    if (this._currentState > -3) {
      this.imm_setState(
        -3
        /* Y_YHubConnType.HUB_DISCONNECTED */
      );
    }
    this.isNotifWorking = false;
    this.devListExpires = 0;
    this._yapi.imm_dropConnectedHub(this);
    this._firstArrivalCallback = true;
    let resolvers = this.disconnResolvers;
    this.disconnResolvers = [];
    for (let resolveOne of resolvers) {
      resolveOne({ errorType: YAPI_SUCCESS, errorMsg: "Hub disconnect completed" });
    }
    if (this.imm_isDisconnecting()) {
      this.imm_setState(
        -5
        /* Y_YHubConnType.HUB_DETACHED */
      );
      if (this._yapi._logLevel >= 4) {
        this._yapi.imm_log("Hub " + this.urlInfo.imm_getRootUrl() + " detached");
      }
      return false;
    }
    if (this._reconnectionTimer) {
      if (this._yapi._logLevel >= 4) {
        this._yapi.imm_log("Hub disconnected, reconnection is already scheduled [" + this.currentConnID + "]");
      }
      return true;
    }
    let openIDwords = tryOpenID.split("_");
    let nextOpenID = openIDwords[0] + "_" + (parseInt(openIDwords[1]) + 1).toString();
    if (this.retryDelay < 5e3)
      this.retryDelay *= 2;
    if (this._yapi._logLevel >= 4) {
      this._yapi.imm_log("Hub reconnection scheduled in " + this.retryDelay / 1e3 + "s [" + nextOpenID + "]");
    }
    this.currentConnID = nextOpenID;
    this._reconnectionTimer = setTimeout(() => {
      this._reconnectionTimer = null;
      this.currentConnID = "";
      if (this.imm_isDisconnecting()) {
        return;
      }
      if (this._yapi._logLevel >= 4) {
        this._yapi.imm_log("Retry hub connection now [" + nextOpenID + "]");
      }
      this.reconnect(nextOpenID);
    }, this.retryDelay);
    return true;
  }
  // Cancel current connection and report the fatal connection failure to the initiator.
  // This function may be called with YAPI_SUCCESS in case of desired disconnection
  //
  // This function should be called FIRST by any implementors of async detach()
  // in order to prevent automatic reconnect
  imm_commonDisconnect(tryOpenID, errType, errMsg) {
    this._lastErrorType = errType;
    this._lastErrorMsg = errMsg;
    if (this._currentState >= -2) {
      this.imm_setState(
        -4
        /* Y_YHubConnType.HUB_DETACHING */
      );
    } else if (this._currentState == -3) {
      this.imm_setState(
        -5
        /* Y_YHubConnType.HUB_DETACHED */
      );
    }
    this.imm_setTargetState(
      -5
      /* Y_YHubConnType.HUB_DETACHED */
    );
    if (this._reconnectionTimer) {
      clearTimeout(this._reconnectionTimer);
      this._reconnectionTimer = null;
    }
    if (this.timeoutId) {
      clearTimeout(this.timeoutId);
      this.timeoutId = null;
    }
    if (errType != YAPI_SUCCESS && this._yapi._logLevel >= 4 && tryOpenID != "detach") {
      this._yapi.imm_log("Hub connection failed: " + errMsg + " [" + tryOpenID + "]");
    }
    this._firstArrivalCallback = true;
    let res_struct = { errorType: errType, errorMsg: errMsg };
    let resolvers = this.connResolvers;
    this.connResolvers = [];
    for (let resolveOne of resolvers) {
      resolveOne(res_struct);
    }
  }
  // Implementation of function to abort communication channel immediately
  //
  // If a connectionID is passed as argument, only abort the
  // communication channel if the ID matched current connection
  //
  // Return true if the connection os getting aborted
  //
  // Subclasses are expected to invoke imm_signalHubDisconnected() after cleaning
  // up current communication, to bring back the link again later
  imm_disconnectNow(connID = "") {
    if (connID && connID != this.currentConnID) {
      return false;
    }
    if (this._currentState > -2) {
      this.imm_setState(
        -2
        /* Y_YHubConnType.HUB_DISCONNECTING */
      );
    }
    if (this.timeoutId) {
      clearTimeout(this.timeoutId);
      this.timeoutId = null;
    }
    if (this._hubEngine) {
      this._hubEngine.imm_disconnectEngineNow(connID);
    } else {
      this.imm_signalHubDisconnected(connID);
    }
    return true;
  }
  /** Invoked by UnregisterHub
   *
   * Free ressources allocated by the hub, close requests,
   * call this.imm_commonDisconnect() and bring the link down.
   *
   * This method may be redefined by subclasses to do additional
   * cleanup before invoking this.imm_commonDisconnect() to bring
   * communication down, to prevent automatic reconnect.
   */
  async detach(errType = YAPI.IO_ERROR, errMsg = "Hub has been forcibly detached") {
    this.imm_commonDisconnect("detach", errType, errMsg);
    this.imm_disconnectNow();
    this.stalledTimeoutMs = this._yapi._networkTimeoutMs;
    this._hubEngine = null;
  }
  /** Wait until the hub is fully disconnected
   */
  async waitForDisconnection(mstimeout) {
    let disconnPromise = null;
    let disconnTimeoutObj = null;
    disconnPromise = new Promise((resolve, reject) => {
      this.disconnResolvers.push(resolve);
      disconnTimeoutObj = setTimeout(() => {
        if (this._yapi._logLevel >= 4) {
          this._yapi.imm_log("Timeout waiting for hub disconnection");
        }
        resolve({ errorType: YAPI_TIMEOUT, errorMsg: "Timeout waiting for hub connection" });
      }, mstimeout);
    });
    await disconnPromise;
    clearTimeout(disconnTimeoutObj);
  }
  // Return the number of NEW devices discovered, or a negative error code
  async hubUpdateDeviceList() {
    let hubDev = this._yapi.imm_getDevice(this.urlInfo.imm_getRootUrl());
    try {
      hubDev.imm_dropCache();
      let retcode = await hubDev.refresh();
      if (retcode != YAPI_SUCCESS) {
        if (this._currentState >= 1) {
          await this._yapi.updateDeviceList_process(this, hubDev, [], {});
        }
        this.imm_disconnectNow();
        return this._throw(retcode, hubDev._lastErrorMsg, retcode);
      }
      let yreq = await hubDev.requestAPI(this._yapi.defaultCacheValidity);
      if (yreq.errorType != YAPI_SUCCESS) {
        if (this._currentState >= 1) {
          await this._yapi.updateDeviceList_process(this, hubDev, [], {});
        }
        this.imm_disconnectNow();
        return yreq.errorType;
      }
      let whitePages = yreq.obj_result.services.whitePages;
      let yellowPages = yreq.obj_result.services.yellowPages;
      if (!whitePages) {
        this.imm_disconnectNow();
        return this._throw(YAPI_IO_ERROR, "Device " + hubDev.imm_describe() + " is not a hub", YAPI_IO_ERROR);
      }
      retcode = await this._yapi.updateDeviceList_process(this, hubDev, whitePages, yellowPages);
      if (retcode < 0) {
        this.imm_disconnectNow();
        return this._throw(this._yapi._lastErrorType, this._yapi._lastErrorMsg, this._yapi._lastErrorType);
      }
      if (this.isNotifWorking) {
        this.devListExpires = this._yapi.GetTickCount() + this._yapi._deviceListValidityMs;
      } else {
        this.devListExpires = this._yapi.GetTickCount() + 500;
      }
      return retcode;
    } catch (e) {
      if (this._yapi._logLevel >= 3) {
        this._yapi.imm_log("Exception during device enumeration: ", e);
      }
      if (this._currentState >= 1) {
        try {
          await this._yapi.updateDeviceList_process(this, hubDev, [], {});
        } catch (e2) {
        }
      }
      this.imm_disconnectNow();
      return YAPI_IO_ERROR;
    }
  }
  /** Perform an HTTP query on the hub
   */
  async request(method, devUrl, obj_body, tcpchan) {
    if (!this._hubEngine) {
      let res = new YHTTPRequest(null);
      res.errorType = YAPI_IO_ERROR;
      res.errorMsg = "HubEngine is not initialised";
      return res;
    }
    return await this._hubEngine.request(method, devUrl, obj_body, tcpchan);
  }
  /** Create a new random boundary for form-encoding
   */
  imm_getBoundary() {
    return "Zz" + Math.floor(Math.random() * 16777215).toString(16) + "zZ";
  }
  /** Form-encode a body object into an raw Uint8Array to send
   */
  imm_formEncodeBody(obj_body, str_boundary) {
    let hdr = this._yapi.imm_str2bin('Content-Disposition: form-data; name="' + obj_body.fname + '"; filename="api"\r\nContent-Type: application/octet-stream\r\nContent-Transfer-Encoding: binary\r\n\r\n');
    let boundary = this._yapi.imm_str2bin(str_boundary);
    let dash = this._yapi.imm_str2bin("--");
    let crlf = this._yapi.imm_str2bin("\r\n");
    let parts = [dash, boundary, crlf, hdr, obj_body.data, crlf, dash, boundary, dash, crlf];
    let i, len = 0;
    for (i = 0; i < parts.length; i++) {
      len += parts[i].length;
    }
    let res = new Uint8Array(len);
    len = 0;
    for (i = 0; i < parts.length; i++) {
      res.set(parts[i], len);
      len += parts[i].length;
    }
    return res;
  }
  /** Return an array of serial numbers
   */
  async getBootloaders() {
    let yreq = await this.request("GET", "/flash.json?a=list", null, 1);
    if (yreq.errorType != YAPI_SUCCESS) {
      return this._throw(yreq.errorType, yreq.errorMsg, []);
    }
    let flashState = JSON.parse(YAPI.imm_bin2str(yreq.bin_result));
    return flashState["list"];
  }
  /** Perform a firmware update
   */
  async firmwareUpdate(serial, firmware, settings, progress) {
    let use_self_flash = false;
    let baseUrl = "";
    let need_reboot = true;
    let _throw = ((msg) => {
      return this._throw(YAPI.IO_ERROR, msg, [msg]);
    });
    progress(5, "Check bootloader type");
    let yreq = await this.request("GET", "/api/module.json", null, 0);
    if (yreq.errorType != YAPI_SUCCESS) {
      return _throw("Hub is not responding");
    }
    let json = JSON.parse(this._yapi.imm_bin2str(yreq.bin_result));
    let ownSerial = json.serialNumber;
    if (ownSerial.slice(0, 7) == "VIRTHUB") {
      use_self_flash = false;
    } else if (serial == ownSerial) {
      use_self_flash = true;
    } else {
      yreq = await this.request("GET", "/bySerial/" + serial + "/flash.json?a=state", null, 0);
      if (yreq.errorType == YAPI_SUCCESS && yreq.bin_result.length > 0) {
        use_self_flash = true;
        baseUrl = "/bySerial/" + serial;
      }
    }
    let bootloaders = await this.getBootloaders();
    let is_shield = serial.slice(0, 7) == "YHUBSHL";
    let i;
    for (i = 0; i < bootloaders.length; i++) {
      let bl = bootloaders[i];
      if (bl == serial) {
        need_reboot = false;
      } else if (is_shield) {
        if (bl.slice(0, 7) == "YHUBSHL") {
          return _throw("Only one YoctoHub-Shield is allowed in update mode");
        }
      }
    }
    if (!use_self_flash && need_reboot) {
      if (bootloaders.length >= 4) {
        return _throw("Too many devices in update mode");
      }
    }
    yreq = await this.request("GET", baseUrl + "/flash.json?a=state", null, 0);
    if (yreq.errorType != YAPI_SUCCESS) {
      return _throw("Cannot check state of firmware upload");
    }
    json = JSON.parse(this._yapi.imm_bin2str(yreq.bin_result));
    if (json["state"] == "uploading" || json["state"] == "flashing") {
      return _throw("Cannot start firmware update: busy (" + json["state"] + ")");
    }
    progress(10, "Send firmware file");
    let progressCb = function(curr, total) {
      curr >>= 10;
      total >>= 10;
      progress(10 + (28 * curr / total >> 0), "Send firmware file: " + curr + "KB / " + total + "KB");
    };
    yreq = await this.request("POST", baseUrl + "/upload.html", new YHTTPBody("firmware", firmware.imm_getData(), progressCb), 0);
    if (yreq.errorType != YAPI_SUCCESS) {
      return _throw("Firmware upload failed: " + yreq.errorMsg);
    }
    yreq = await this.request("GET", baseUrl + "/flash.json?a=state", null, 0);
    if (yreq.errorType != YAPI_SUCCESS) {
      return _throw("Cannot check state of firmware upload");
    }
    json = JSON.parse(this._yapi.imm_bin2str(yreq.bin_result));
    if (json["state"] != "valid") {
      return _throw("Upload of firmware failed: invalid firmware(" + json["state"] + ")");
    }
    if (json["progress"] != "100") {
      return _throw("Upload of firmware failed: incomplete upload");
    }
    if (use_self_flash) {
      let settingsStr = this._yapi.imm_bin2str(settings);
      let settingsAndFiles = JSON.parse(settingsStr);
      let settingsOnly = settingsAndFiles["api"];
      let startupApi = {};
      for (let key in settingsOnly) {
        if (key != "services") {
          startupApi[key] = settingsOnly[key];
        }
      }
      let startupConf = this._yapi.imm_str2bin(JSON.stringify(startupApi));
      progress(38, "Save current settings");
      yreq = await this.request("POST", baseUrl + "/upload.html", new YHTTPBody("startupConf.json", startupConf, null), 0);
      if (yreq.errorType != YAPI_SUCCESS) {
        return _throw("Failed to save settings on hub");
      }
      progress(39, "Save current settings");
      yreq = await this.request("POST", baseUrl + "/upload.html", new YHTTPBody("firmwareConf", startupConf, null), 0);
      if (yreq.errorType != YAPI_SUCCESS) {
        return _throw("Failed to save settings on hub");
      }
    }
    if (use_self_flash) {
      progress(40, "Flash firmware");
      await this.request("GET", baseUrl + "/api/module/rebootCountdown?rebootCountdown=-1003", null, 0);
      await this._yapi.Sleep(7e3);
    } else {
      if (need_reboot) {
        await this.request("GET", "/bySerial/" + serial + "/api/module/rebootCountdown?rebootCountdown=-2", null, 0);
      }
      let timeout = YAPI.GetTickCount() + 2e4;
      let res;
      let found = false;
      progress(40, "Wait for device to be in bootloader");
      do {
        bootloaders = await this.getBootloaders();
        for (i = 0; i < bootloaders.length; i++) {
          let bl = bootloaders[i];
          if (bl == serial) {
            found = true;
            break;
          }
        }
        if (!found) {
          await this._yapi.Sleep(500);
        }
      } while (!found && YAPI.GetTickCount() < timeout);
      progress(45, "Flash firmware");
      let fwsize = firmware.imm_getData().length + 512 >> 10;
      let checkTimer;
      let checkFlash = (() => {
        this.request("GET", baseUrl + "/flash.json?a=state", null, 1).then((flashReq) => {
          if (flashReq.errorType == YAPI_SUCCESS) {
            let jsonState = YAPI.imm_bin2str(flashReq.bin_result);
            let res2 = JSON.parse(jsonState);
            if (res2.state == "flashing") {
              if (res2.progress < 20) {
                progress(45 + (res2.progress / 3 >> 0), "Erasing previous firmware: " + (fwsize * (res2.progress - 3) / 18 >> 0) + "KB / " + fwsize + "KB");
              } else {
                progress(45 + (res2.progress / 3 >> 0), "Flashing new firmware: " + (fwsize * (res2.progress - 20) / 76 >> 0) + "KB / " + fwsize + "KB");
              }
            }
          }
          checkTimer = setTimeout(checkFlash, 500);
        }).catch((e) => {
          this._yapi.imm_log("Exception during firmware flash: ", e);
          checkTimer = setTimeout(checkFlash, 500);
        });
      });
      checkTimer = setTimeout(checkFlash, 1e3);
      yreq = await this.request("GET", "/flash.json?a=flash&s=" + serial, null, 0);
      clearTimeout(checkTimer);
      if (yreq.errorType != YAPI_SUCCESS) {
        return _throw("Cannot check state of firmware flash");
      }
      return JSON.parse(this._yapi.imm_bin2str(yreq.bin_result));
    }
    return null;
  }
  async reportFailure(message) {
    if (this._hubEngine) {
      await this._hubEngine.reportFailure(message);
    }
  }
  // check if a hub connection provides read-write access to the devices
  async hasRwAccess() {
    if (this._rwAccess == null) {
      let yreq = await this.request("GET", "/api/module/serialNumber.json?serialNumber=rwTest", null, 0);
      this._rwAccess = yreq.errorType == YAPI_SUCCESS;
    }
    return this._rwAccess;
  }
  imm_isRwAccess() {
    if (this._rwAccess == null) {
      return false;
    }
    return this._rwAccess;
  }
  imm_setRwAccess(rwAccess) {
    this._rwAccess = rwAccess;
  }
  getHubRef() {
    return this._hubRef;
  }
  get_knownUrls() {
    let res = this._knownUrls.slice();
    return res;
  }
  imm_forgetUrls() {
    this._knownUrls = [];
  }
  imm_getOriginalURL() {
    return this.urlInfo.imm_getOriginalURL();
  }
  imm_getRootUrl() {
    return this.urlInfo.imm_getRootUrl();
  }
  imm_getSerialNumber() {
    return this.hubSerial;
  }
  imm_setSerialNumber(serial) {
    this.hubSerial = serial;
  }
  imm_getNetworkTimeout() {
    return this.stalledTimeoutMs;
  }
  imm_setNetworkTimeout(mstimeout) {
    this.stalledTimeoutMs = mstimeout;
  }
  imm_setHubEngine(engine) {
    this._hubEngine = engine;
  }
  imm_setRetryDelay(value) {
    this.retryDelay = value;
  }
  imm_SetErr(errorType, errorMsg) {
    this._lastErrorType = errorType;
    this._lastErrorMsg = errorMsg;
  }
  async WebSocketJoin(ws, arr_credentials, closeCallback) {
    return this._hubEngine.websocketJoin(ws, arr_credentials, closeCallback);
  }
  imm_UseBestProto() {
    let cur_proto = this.urlInfo.imm_getProto();
    let runtime_urlInfo = this.urlInfo;
    this._hubMode = HubMode.SECURE;
    if (this._portInfo.length > 0) {
      if (this._usePureHTTP) {
        if (cur_proto == "ws" || cur_proto == "wss") {
          this._yapi._throw(YAPI.NOT_SUPPORTED, "Websocket protocol is not supported by VirtualHub-4web.");
        }
        for (let i = 0; i < this._portInfo.length; i++) {
          let portInfo = this._portInfo[i];
          if (portInfo.proto.startsWith("http")) {
            if (this._yapi._logLevel >= 3) {
              this._yapi.imm_log("Hub " + this.urlInfo.imm_getHost() + " will use " + portInfo.proto + " proto on port " + portInfo.port);
            }
            runtime_urlInfo = this.urlInfo;
            runtime_urlInfo.imm_updateBestProto(portInfo.proto, portInfo.port);
            break;
          }
        }
      } else {
        let best_port = 0;
        let best_proto = "ws";
        if (this._portInfo[0].proto == "http" || this._portInfo[0].proto == "ws") {
          this._hubMode = HubMode.LEGACY;
        }
        for (let i = 0; i < this._portInfo.length; i++) {
          let portInfo = this._portInfo[i];
          if (this._hubMode == HubMode.SECURE && (portInfo.proto == "http" || portInfo.proto == "ws")) {
            if (this._yapi._logLevel >= 3) {
              this._yapi.imm_log("Hub " + this.urlInfo.imm_getHost() + " use mixed or legacy mode");
            }
            this._hubMode = HubMode.MIXED;
          }
          if (cur_proto == "auto" && best_port == 0) {
            if (portInfo.proto.startsWith("http") || portInfo.proto.startsWith("ws")) {
              best_proto = portInfo.proto;
              best_port = portInfo.port;
            }
          }
          if (cur_proto == "secure" && best_port == 0) {
            if (portInfo.proto == "https" || portInfo.proto == "wss") {
              best_proto = portInfo.proto;
              best_port = portInfo.port;
            }
          }
        }
        if (best_port != 0) {
          if (this._yapi._logLevel >= 3) {
            this._yapi.imm_log("Hub " + this.urlInfo.imm_getHost() + " will use " + best_proto + " proto on port " + best_port);
          }
          runtime_urlInfo = this.urlInfo;
          runtime_urlInfo.imm_updateBestProto(best_proto, best_port);
        }
      }
    }
    return runtime_urlInfo;
  }
  imm_useMixedMode() {
    return this._hubMode == HubMode.MIXED || this._hubMode == HubMode.LEGACY;
  }
  async waitForPendingQueries(ms_timeout) {
    if (this._hubEngine) {
      await this._hubEngine.waitForPendingQueries(ms_timeout);
    }
  }
};
YGenericHub.globalHubRefCounter = 0;
var YHttpEngine = class extends YHubEngine {
  constructor(hub, runtime_urlInfo, firstInfoJson) {
    super(hub, runtime_urlInfo);
    this.infoJson = null;
    this.ha1 = "";
    this.realm = "";
    this.nonce = "";
    this.opaque = "";
    this.nonceCount = 0;
    this.notbynRequest = null;
    this.infoJson = firstInfoJson;
  }
  // Low-level function to create an HTTP client request (abstraction layer)
  imm_makeRequest(method, relUrl, contentType, body, onProgress, onSuccess, onError) {
  }
  // abort an HTTP client request immediately (abstraction layer)
  imm_abortRequest(clientRequest) {
  }
  // Initiate an HTTP client request with proper authentication settings and mime type
  // Handle header-based client authentication (to prevent browser pop-ups)
  imm_sendRequest(method, relUrl, obj_body, onProgress, onSuccess, onError) {
    let body = null;
    let contentType = "text/plain; charset=x-user-defined";
    if (this.infoJson && this.infoJson.realm && this.infoJson.nonce) {
      if (this.realm != this.infoJson.realm || this.nonce != this.infoJson.nonce) {
        this.realm = this.infoJson.realm;
        this.nonce = this.infoJson.nonce;
        this.nonceCount = 0;
      }
      let shorturi = this._runtime_urlInfo.imm_getSubDomain() + relUrl;
      let jsonBody = {
        "x-yauth": {
          method,
          uri: shorturi,
          nonce: this.nonce
        }
      };
      if (this._runtime_urlInfo.imm_hasAuthParam()) {
        let cnonce = Math.floor(Math.random() * 2147483647).toString(16).toLowerCase();
        let nc = (++this.nonceCount).toString(16).toLowerCase();
        let ha1_str = this._runtime_urlInfo.imm_getUser() + ":" + this.realm + ":" + this._runtime_urlInfo.imm_getPass();
        let ha2_str = method + ":" + shorturi;
        let A1 = this._hub._yapi.imm_bin2hexstr(this._hub._yapi.imm_yMD5(ha1_str)).toLowerCase();
        let A2 = this._hub._yapi.imm_bin2hexstr(this._hub._yapi.imm_ySHA1(ha2_str)).toLowerCase();
        let signature = A1 + ":" + this.nonce + ":" + nc + ":" + cnonce + ":auth:" + A2;
        let response = this._hub._yapi.imm_bin2hexstr(this._hub._yapi.imm_ySHA1(signature)).toLowerCase();
        jsonBody["x-yauth"]["username"] = this._runtime_urlInfo.imm_getUser();
        jsonBody["x-yauth"]["cnonce"] = cnonce;
        jsonBody["x-yauth"]["nc"] = nc;
        jsonBody["x-yauth"]["qop"] = "auth";
        jsonBody["x-yauth"]["response"] = response;
      }
      if (obj_body) {
        let binstr = this._hub._yapi.imm_bin2str(obj_body.data);
        jsonBody["body"] = {
          filename: obj_body.fname,
          b64content: btoa(binstr)
        };
      }
      method = "POST";
      body = JSON.stringify(jsonBody);
      let qpos = relUrl.indexOf("?");
      if (qpos > 0) {
        relUrl = relUrl.slice(0, qpos);
      }
    } else if (obj_body != null) {
      let boundary = this._hub.imm_getBoundary();
      if (this.infoJson && this.infoJson.nonce) {
        contentType = "x-upload; boundary=" + boundary;
      } else {
        contentType = "multipart/form-data; boundary=" + boundary;
      }
      body = this._hub.imm_formEncodeBody(obj_body, boundary);
    }
    return this.imm_makeRequest(method, relUrl, contentType, body, onProgress, onSuccess, onError);
  }
  // Internal method to perform a simple HTTP GET using a hub-relative URL
  async tryFetch(relUrl) {
    return new Promise((resolve, reject) => {
      this.imm_sendRequest("GET", relUrl, null, null, (responseText) => {
        resolve({ errorType: YAPI_SUCCESS, errorMsg: "", result: responseText });
      }, (errorType, errorMsg, can_be_retry) => {
        if (can_be_retry) {
          this.imm_sendRequest("GET", relUrl, null, null, (responseText2) => {
            resolve({ errorType: YAPI_SUCCESS, errorMsg: "", result: responseText2 });
          }, (errorType2, errorMsg2, can_be_retry2) => {
            resolve({ errorType: errorType2, errorMsg: errorMsg2 });
          });
        } else {
          resolve({ errorType, errorMsg });
        }
      });
    });
  }
  /** Handle HTTP-based event-monitoring work on a registered hub
   */
  async reconnectEngine(tryOpenID) {
    this._hub.imm_setCurrentConnID(tryOpenID);
    if (this.infoJson && this.infoJson.nonce && YAPI.GetTickCount() - this.infoJson.stamp > 12e3) {
      if (this._hub._yapi._logLevel >= 4) {
        this._hub._yapi.imm_log("Trying info.json [" + tryOpenID + "]");
      }
      let res_struct = await this.tryFetch("info.json");
      if (res_struct.errorType == YAPI_SUCCESS && res_struct.result) {
        this.infoJson = JSON.parse(res_struct.result);
        this.infoJson.stamp = YAPI.GetTickCount();
      }
    }
    let primaryHub = this._hub._yapi.imm_getPrimaryHub(this._hub);
    if (primaryHub !== this._hub) {
      this._hub.imm_commonDisconnect(tryOpenID, YAPI_SUCCESS, "Hub " + this._hub.imm_getSerialNumber() + " is already connected");
      this._hub.imm_setCurrentConnID("");
      this._hub.imm_signalHubDisconnected(tryOpenID);
      return;
    }
    let args = "";
    if (this._hub.imm_getNotifyPos() >= 0) {
      args = "?abs=" + this._hub.imm_getNotifyPos().toString();
    } else {
      this._hub.imm_setFirstArrivalCallback(true);
    }
    if (this._hub._yapi._logLevel >= 4) {
      this._hub._yapi.imm_log("Opening http connection to hub (" + args + ") [" + tryOpenID + "]");
    }
    this.notbynRequest = this.imm_sendRequest("GET", "/not.byn" + args, null, (moreText) => {
      if (tryOpenID != this._hub.imm_getCurrentConnID()) {
        if (this._hub._yapi._logLevel >= 3) {
          this._hub._yapi.imm_log("Previous request still sending data [" + tryOpenID + "]");
        }
        return;
      }
      if (this.infoJson) {
        this.infoJson.stamp = YAPI.GetTickCount();
      }
      if (this._hub.imm_getcurrentState() < 0) {
        this._hub.signalHubConnected(tryOpenID, this._hub.imm_getSerialNumber());
      }
      this.imm_updateLastPinfStamp();
      this._hub._yapi.parseEvents(this._hub, moreText);
    }, (resultText) => {
      if (tryOpenID != this._hub.imm_getCurrentConnID()) {
        if (this._hub._yapi._logLevel >= 3) {
          this._hub._yapi.imm_log("Previous request completed [" + tryOpenID + "]");
        }
        return;
      }
      this.reconnectEngine(tryOpenID);
    }, (errorType, errorMsg, can_be_retry) => {
      if (tryOpenID != this._hub.imm_getCurrentConnID()) {
        if (this._hub._yapi._logLevel >= 3) {
          this._hub._yapi.imm_log("Previous not.byn request says: " + errorMsg + " [" + tryOpenID + "]");
        }
        return;
      }
      if (!this._hub.imm_isDisconnecting()) {
        if (this._hub._yapi._logLevel >= 3) {
          this._hub._yapi.imm_log("Failed to load not.byn (" + args + "): " + errorMsg + " [" + tryOpenID + "]");
        }
      }
      this._hub.imm_SetErr(errorType, errorMsg);
      if ((errorType == YAPI_UNAUTHORIZED || errorType == YAPI_SSL_UNK_CERT) && !can_be_retry) {
        this._hub.imm_commonDisconnect(tryOpenID, errorType, errorMsg);
      }
      this._hub.imm_disconnectNow();
    });
  }
  // abort communication channel immediately
  //
  // If a connectionID is passed as argument, only abort the
  // communication channel if the ID matched current connection
  //
  imm_disconnectEngineNow(connID = "") {
    if (this._hub._yapi._logLevel >= 4) {
      this._hub._yapi.imm_log("YHTTPEngine.imm_disconnectEngineNow " + connID);
    }
    if (!this.notbynRequest) {
      return;
    }
    let closeConnID = connID ? connID : this._hub.imm_getCurrentConnID();
    this.imm_abortRequest(this.notbynRequest);
    this.notbynRequest = null;
    this._hub.imm_setCurrentConnID("");
    this._hub.imm_signalHubDisconnected(closeConnID);
  }
  /** Perform an HTTP query on the hub
   */
  async request(method, devUrl, obj_body, tcpchan) {
    if (this._hub._yapi._logLevel >= 3) {
      this._hub.imm_logrequest(method, devUrl, obj_body);
    }
    if (this._hub.imm_getcurrentState() < 0) {
      return new YHTTPRequest(null, YAPI.IO_ERROR, "Hub is currently unavailable");
    }
    return new Promise((resolve, reject) => {
      this.imm_sendRequest(method, devUrl, obj_body, null, (responseText) => {
        if (this._hub.imm_getcurrentState() < 0) {
          resolve(new YHTTPRequest(null, YAPI.IO_ERROR, "Hub is currently unavailable"));
        } else {
          if (this._hub._yapi._logLevel >= 4) {
            this._hub._yapi.imm_log(method + " " + devUrl + " succeeded");
          }
          resolve(new YHTTPRequest(this._hub._yapi.imm_str2bin(responseText)));
        }
      }, (errorType, errorMsg, can_be_retry) => {
        if (this._hub._yapi._logLevel >= 4) {
          this._hub._yapi.imm_log(method + " " + devUrl + " failed (" + errorMsg + ")");
        }
        resolve(new YHTTPRequest(null, errorType, errorMsg));
      });
    });
  }
};
var YWebSocketEngine = class extends YHubEngine {
  constructor(hub, runtime_urlInfo) {
    super(hub, runtime_urlInfo);
    this._DEFAULT_TCP_ROUND_TRIP_TIME = 30;
    this._DEFAULT_TCP_MAX_WINDOW_SIZE = 4 * 65536;
    this._YIO_DEFAULT_TCP_TIMEOUT = 2e4;
    this._YIO_1_MINUTE_TCP_TIMEOUT = 6e4;
    this._YIO_10_MINUTES_TCP_TIMEOUT = 6e5;
    this._USB_META_UTCTIME_SIZE = 5;
    this._USB_META_DLFLUSH_SIZE = 1;
    this._USB_META_ACK_D2H_PACKET_SIZE = 2;
    this._USB_META_WS_ANNOUNCE_SIZE = 8 + 20;
    this._USB_META_WS_AUTHENTICATION_SIZE = 28;
    this._USB_META_WS_ERROR_SIZE = 6;
    this._USB_META_ACK_UPLOAD_SIZE = 6;
    this._USB_META_WS_VALID_SHA1 = 1;
    this._USB_META_WS_RW = 2;
    this.websocket = null;
    this.tcpChan = [];
    this.nextAsyncId = 48;
    this._connectionTime = 0;
    this._remoteVersion = 0;
    this._remoteSerial = "";
    this._remoteNonce = -1;
    this._nonce = -1;
    this._session_error = null;
    this._session_errno = null;
    this._lastUploadAckBytes = [0];
    this._lastUploadAckTime = [0];
    this._lastUploadRateBytes = [0];
    this._lastUploadRateTime = [0];
    this._uploadRate = [0];
    this.fwd_nonce = -1;
    this.fwd_websocket = null;
    this.fwd_credentials = [];
    this.fwd_closeCallback = null;
    this._connectionState = 2;
    this._tcpRoundTripTime = this._DEFAULT_TCP_ROUND_TRIP_TIME;
    this._tcpMaxWindowSize = this._DEFAULT_TCP_MAX_WINDOW_SIZE;
    this.fwd_connectionState = 1;
  }
  /** Report a low-level asynchronous websocket error
   **/
  imm_asyncWebSocketError(errorType, message) {
    if (this._hub._yapi._logLevel >= 3) {
      this._hub._yapi.imm_log("WS: " + message + " on " + this._runtime_urlInfo.imm_getRootUrl());
    }
  }
  /** Handle websocket-based event-monitoring work on a registered hub
   */
  async reconnectEngine(tryOpenID) {
    this._connectionState = 2;
    if (this._hub._yapi._logLevel >= 4) {
      this._hub._yapi.imm_log("Opening websocket connection [" + tryOpenID + "]");
    }
    this._hub.imm_setCurrentConnID(tryOpenID);
    let url = (this._runtime_urlInfo.imm_useSecureSocket() ? "wss://" : "ws://") + this._runtime_urlInfo.imm_getUrl(false, true, true);
    this.imm_webSocketOpen(url + "not.byn");
    this._hub.imm_setFirstArrivalCallback(true);
    if (!this.websocket) {
      this._hub.imm_commonDisconnect(tryOpenID, YAPI_IO_ERROR, "Failed to create WebSocket");
      return;
    }
    this.websocket.onmessage = ((evt) => {
      if (this._hub.imm_getCurrentConnID() != tryOpenID) {
        if (this._hub._yapi._logLevel >= 4) {
          this._hub._yapi.imm_log("Incoming WebSocket data for previous connection [" + tryOpenID + "]");
        }
        return;
      }
      this._webSocketMsg(new Uint8Array(evt.data));
      if (this._connectionState == 4) {
        this._connectionState = 5;
        this._hub.signalHubConnected(tryOpenID, this._remoteSerial);
      } else if (this._connectionState == 0) {
        let errMsg = this._session_error ? "WebSocket error: " + this._session_error : "Websocket I/O error";
        if (this._session_errno == 401) {
          this._hub.imm_commonDisconnect(tryOpenID, YAPI_UNAUTHORIZED, errMsg);
        } else {
          this._hub.imm_SetErr(YAPI_IO_ERROR, errMsg);
        }
        this._hub.imm_disconnectNow();
      }
    });
    this.websocket.onclose = ((evt) => {
      if (this._hub.imm_getCurrentConnID() != tryOpenID) {
        if (this._hub._yapi._logLevel >= 4) {
          this._hub._yapi.imm_log("WebSocket close received for previous connection [" + tryOpenID + "], now using [" + this._hub.imm_getCurrentConnID() + "]");
        }
        return;
      }
      if (this._hub._yapi._logLevel >= 4) {
        this._hub._yapi.imm_log("WebSocket connection closed [" + tryOpenID + "]");
      }
      this._connectionState = 1;
      this.websocket = null;
      if (this._hub.retryDelay < 0) {
        this._hub.imm_commonDisconnect(tryOpenID, YAPI_IO_ERROR, "Websocket callback connection closed");
      }
      this.imm_dropAllPendingConnection();
      this._hub.imm_signalHubDisconnected(tryOpenID);
    });
    this.websocket.onerror = ((evt) => {
      if (this._hub.imm_getCurrentConnID() != tryOpenID) {
        if (this._hub._yapi._logLevel >= 4) {
          this._hub._yapi.imm_log("WebSocket error received for previous connection [" + tryOpenID + "]");
        }
        return;
      }
      if (evt.message && (!/ ETIMEDOUT /.test(evt.message) || this._hub._yapi._logLevel >= 4)) {
        if (this._hub._yapi._logLevel >= 3) {
          this._hub._yapi.imm_log("WebSocket error [" + tryOpenID + "]: ", evt);
        }
        if (evt.error.code == "DEPTH_ZERO_SELF_SIGNED_CERT") {
          this._hub.imm_commonDisconnect(tryOpenID, YAPI_SSL_UNK_CERT, evt.message);
        } else {
          this._hub.imm_SetErr(YAPI_IO_ERROR, evt.message);
        }
      }
      if (this._hub.retryDelay < 0) {
        this._hub.imm_commonDisconnect(tryOpenID, YAPI_IO_ERROR, "Websocket callback connection closed");
      }
      this._hub.imm_disconnectNow();
      this._hub.imm_signalHubDisconnected(tryOpenID);
    });
    if (this._hub.timeoutId) {
      clearTimeout(this._hub.timeoutId);
    }
    this._hub.timeoutId = setTimeout(() => {
      if (!this.imm_isForwarded()) {
        if (this._hub._yapi._logLevel >= 3) {
          this._hub._yapi.imm_log("WS: connection stalled during open [" + tryOpenID + "]");
        }
        this._hub.imm_disconnectNow();
      }
    }, this._hub.imm_getNetworkTimeout());
  }
  /** Compute websocket authentication sha1 key
   */
  imm_computeAuth(user, pass, serial, nonce) {
    let ha1_str = user + ":" + serial + ":" + pass;
    let ha1 = this._hub._yapi.imm_bin2hexstr(this._hub._yapi.imm_yMD5(ha1_str)).toLowerCase();
    let nonce8 = new Uint8Array([(nonce & 255) >>> 0, (nonce & 65280) >>> 8, (nonce & 16711680) >>> 16, nonce >>> 24]);
    let sha1_raw = ha1 + this._hub._yapi.imm_bin2hexstr(nonce8).toLowerCase();
    return this._hub._yapi.imm_ySHA1(sha1_raw.toLowerCase());
  }
  /** Tell if a websocket hub is currently forwarded and handled remotely
   */
  imm_isForwarded() {
    return this.fwd_connectionState == 5 && this.fwd_websocket !== null;
  }
  /** Handle an incoming packet
   **/
  async _webSocketMsg(arr_bytes) {
    try {
      if (this.imm_isForwarded()) {
        this.imm_updateLastPinfStamp();
        this.fwd_websocket.send(arr_bytes);
        return;
      }
      let reltime = (this._hub._yapi.GetTickCount() - this._connectionTime) / 1e3;
      let ystream = arr_bytes[0] >>> 3;
      let text = "";
      if (ystream == 8) {
        for (let i = 1; i < arr_bytes.length; i++) {
          text += String.fromCharCode(arr_bytes[i]);
        }
        this.imm_updateLastPinfStamp();
        await this._hub._yapi.parseEvents(this._hub, text);
        return;
      }
      let ws = this.websocket;
      let tcpchan = arr_bytes[0] & 7;
      if (ystream == 1 || ystream == 2 || ystream == 9) {
        if (tcpchan > 3) {
          this.imm_asyncWebSocketError(YAPI_IO_ERROR, "Unexpected frame for tcpChan " + tcpchan + " (" + ystream + ")");
          return;
        }
        let tcp_end = arr_bytes.length;
        let yreq = this.tcpChan[tcpchan];
        if (!yreq) {
          this.imm_asyncWebSocketError(YAPI_IO_ERROR, "Drop frame for closed tcpChan " + tcpchan + " (" + ystream + ")");
          return;
        }
        if (ystream == 9) {
          tcp_end--;
          let rcvId = arr_bytes[tcp_end];
          if (this._hub._yapi._logLevel >= 5) {
            this._hub._yapi.imm_log("async-" + rcvId + " close received");
          }
          if (yreq.asyncId == 0) {
            if (this._hub._yapi._logLevel >= 4) {
              this._hub._yapi.imm_log("async-" + rcvId + " close received while req @" + yreq._creat + " was pending");
            }
            this.imm_asyncWebSocketError(YAPI_IO_ERROR, "Asynchronous close received, sync reply request");
            return;
          } else if (yreq.asyncId != rcvId) {
            if (this._hub._yapi._logLevel >= 4) {
              this._hub._yapi.imm_log("async-" + rcvId + " close received instead of async-" + yreq.asyncId + " close");
            }
            this.imm_asyncWebSocketError(YAPI_IO_ERROR, "Incorrect async-close signature on tcpChan " + tcpchan);
            return;
          }
        }
        let oldArr = yreq.bin_result;
        let newArr = new Uint8Array(oldArr.length + tcp_end - 1);
        newArr.set(oldArr, 0);
        newArr.set(arr_bytes.subarray(1, tcp_end), oldArr.length);
        yreq.bin_result = newArr;
        if (ystream == 2 || ystream == 9) {
          this.tcpChan[tcpchan] = yreq.next;
          if (ystream == 2) {
            if (yreq.asyncId != 0) {
              if (this._hub._yapi._logLevel >= 4) {
                this._hub._yapi.imm_log("Synchronous close received instead of async-" + yreq.asyncId + " close");
              }
              this.imm_asyncWebSocketError(YAPI_IO_ERROR, "Synchronous close received, async ack expected");
              return;
            } else if (this.websocket) {
              if (yreq.toBeSent && yreq.sendPos < yreq.toBeSent.length) {
                if (this._hub._yapi._logLevel >= 3) {
                  this._hub._yapi.imm_log("WS: tcpclose at " + yreq.sendPos + " < " + yreq.toBeSent.length);
                }
                this._hub.imm_disconnectNow();
                if (yreq.timeoutId) {
                  clearTimeout(yreq.timeoutId);
                }
                if (yreq.asyncId == 0) {
                  yreq.errorType = YAPI_IO_ERROR;
                  yreq.errorMsg = "TCP closed during upload";
                  if (yreq.acceptor) {
                    try {
                      yreq.acceptor(yreq);
                    } catch (e) {
                    }
                  }
                }
                return;
              }
              if (yreq.timeoutId) {
                let frame = new Uint8Array(1);
                frame[0] = (2 << 3) + tcpchan;
                this.websocket.send(frame);
              }
            }
          }
          if (yreq.timeoutId) {
            clearTimeout(yreq.timeoutId);
            yreq.timeoutId = 0;
          }
          let pos = yreq.bin_result.indexOf(13);
          if (pos < 0) {
            yreq.errorType = YAPI_IO_ERROR;
            yreq.errorMsg = "Bad response header";
          } else {
            let header = this._hub._yapi.imm_bin2str(yreq.bin_result.subarray(0, pos));
            let words = header.split(" ");
            if (words[0] == "OK") {
              yreq.errorType = YAPI_SUCCESS;
              let nextpos = yreq.bin_result.indexOf(13, pos + 2);
              while (nextpos > pos + 2) {
                pos = nextpos;
                nextpos = yreq.bin_result.indexOf(13, pos + 2);
              }
              if (nextpos < 0) {
                nextpos = pos;
              }
              yreq.bin_result = yreq.bin_result.subarray(nextpos + 2);
            } else if (words[0] == "0K") {
              yreq.errorType = YAPI_IO_ERROR;
              yreq.errorMsg = "Unexpected persistent connection";
            } else {
              let status = parseInt(words[1]);
              yreq.errorType = status == 401 ? YAPI_UNAUTHORIZED : YAPI_IO_ERROR;
              yreq.errorMsg = "HTTP error " + header.slice(words[0].length + 1) + " on " + yreq.devUrl;
            }
          }
          if (yreq.asyncId == 0) {
            if (this._hub._yapi._logLevel >= 5) {
              this._hub._yapi.imm_log("request @" + yreq._creat + " done, status=" + yreq.errorType);
            }
            this.imm_sendPendingRequest(tcpchan);
            if (yreq.acceptor) {
              yreq.acceptor(yreq);
            }
          } else {
            if (yreq.errorType != YAPI_SUCCESS) {
              this.imm_asyncWebSocketError(YAPI_IO_ERROR, "Async request error: " + yreq.errorMsg);
            }
          }
        }
        return;
      }
      if (!this.websocket) {
        return;
      }
      if (ystream == 5) {
        let metatype = arr_bytes[1];
        switch (metatype) {
          case 4:
            if (arr_bytes.length < 1 + this._USB_META_WS_ANNOUNCE_SIZE) {
              return;
            }
            this._remoteVersion = arr_bytes[2];
            if (this._remoteVersion < 1) {
              return;
            }
            let maxtcpws = (arr_bytes[3] << 4) + (arr_bytes[4] << 12);
            if (maxtcpws > 0) {
              this._tcpMaxWindowSize = maxtcpws;
            }
            this._remoteNonce = arr_bytes[5] + (arr_bytes[6] << 8) + (arr_bytes[7] << 16) + (arr_bytes[8] << 24);
            for (let i = 9; i < 9 + 20; i++) {
              if (arr_bytes[i] == 0) {
                this._remoteSerial = this._hub._yapi.imm_bin2str(arr_bytes.subarray(9, i));
                break;
              }
            }
            let nonce = new Uint8Array(4);
            this.imm_getRandomValues(nonce);
            this._nonce = nonce[0] + (nonce[1] << 8) + (nonce[2] << 16) + (nonce[3] << 24);
            this._connectionTime = this._hub._yapi.GetTickCount();
            this._connectionState = 3;
            let frame = new Uint8Array(1 + this._USB_META_WS_AUTHENTICATION_SIZE);
            let version = this._remoteVersion < 2 ? this._remoteVersion : 2;
            let flags = 0;
            frame[0] = 5 << 3;
            frame[1] = 5;
            frame[2] = version;
            if (this._runtime_urlInfo.imm_getPass() != "") {
              flags = this._USB_META_WS_VALID_SHA1;
              let sha1 = this.imm_computeAuth(this._runtime_urlInfo.imm_getUser(), this._runtime_urlInfo.imm_getPass(), this._remoteSerial, this._remoteNonce);
              for (let i = 0; i < sha1.length; i++) {
                frame[9 + i] = sha1[i];
              }
            }
            frame[3] = flags & 255;
            frame[4] = flags >>> 8;
            frame[5] = this._nonce & 255;
            frame[6] = this._nonce >>> 8 & 255;
            frame[7] = this._nonce >>> 16 & 255;
            frame[8] = this._nonce >>> 24 & 255;
            this.websocket.send(frame);
            break;
          case 5:
            if (this._connectionState != 3) {
              return;
            }
            if (arr_bytes.length < 1 + this._USB_META_WS_AUTHENTICATION_SIZE) {
              return;
            }
            this._tcpRoundTripTime = this._hub._yapi.GetTickCount() - this._connectionTime + 1;
            if (this._tcpMaxWindowSize < 2048 && this._tcpRoundTripTime < 7) {
              this._tcpRoundTripTime = 7;
            }
            let uploadRate = this._tcpMaxWindowSize * 1e3 / this._tcpRoundTripTime >> 0;
            if (this._hub._yapi._logLevel >= 4) {
              this._hub._yapi.imm_log("RTT=" + this._tcpRoundTripTime + "ms, WS=" + this._tcpMaxWindowSize + ", uploadRate=" + uploadRate / 1e3 + " KB/s");
            }
            this._remoteVersion = arr_bytes[2];
            if (this._remoteVersion < 1) {
              return;
            }
            let inflags = arr_bytes[3] + (arr_bytes[4] << 8);
            if ((inflags & this._USB_META_WS_RW) != 0) {
              this._hub.imm_setRwAccess(true);
            } else {
              this._hub.imm_setRwAccess(false);
            }
            if ((inflags & this._USB_META_WS_VALID_SHA1) != 0) {
              let remote_sha1 = arr_bytes.subarray(9, 29);
              let sha1 = this.imm_computeAuth(this._runtime_urlInfo.imm_getUser(), this._runtime_urlInfo.imm_getPass(), this._remoteSerial, this._nonce);
              for (let i = 0; i < sha1.length; i++) {
                if (sha1[i] != remote_sha1[i]) {
                  this._session_errno = 401;
                  this._session_error = "Authentication failed";
                  this._connectionState = 0;
                  return;
                }
              }
              this._connectionState = 4;
            } else {
              if (this._runtime_urlInfo.imm_getPass() == "") {
                this._connectionState = 4;
              } else {
                this._session_errno = 401;
                if (this._runtime_urlInfo.imm_getUser() == "admin" && !this._hub.imm_isRwAccess()) {
                  this._session_error = "Authentication as admin failed";
                } else {
                  this._session_error = "Password not set on remote hub";
                }
                this._connectionState = 0;
                return;
              }
            }
            break;
          case 6:
            this._session_errno = arr_bytes[3] + (arr_bytes[4] << 8);
            if (this._session_errno == 401) {
              this._session_error = "Authentication failed";
            } else {
              this._session_error = "Remote hub closed connection with error " + this._session_errno;
            }
            this._connectionState = 0;
            break;
          case 7:
            tcpchan = arr_bytes[2];
            if (this.tcpChan[tcpchan]) {
              let yreq = this.tcpChan[tcpchan];
              let ackBytes = arr_bytes[3] + (arr_bytes[4] << 8) + (arr_bytes[5] << 16) + (arr_bytes[6] << 24);
              let ackTime = this._hub._yapi.GetTickCount();
              if (this._lastUploadAckTime[tcpchan] != 0 && ackBytes > this._lastUploadAckBytes[tcpchan]) {
                this._lastUploadAckBytes[tcpchan] = ackBytes;
                this._lastUploadAckTime[tcpchan] = ackTime;
                let deltaBytes = ackBytes - this._lastUploadRateBytes[tcpchan];
                let deltaTime = ackTime - this._lastUploadRateTime[tcpchan];
                if (deltaTime < 500)
                  break;
                if (deltaTime < 1e3 && deltaBytes < 65536)
                  break;
                this._lastUploadRateBytes[tcpchan] = ackBytes;
                this._lastUploadRateTime[tcpchan] = ackTime;
                if (yreq.progressCb && yreq.toBeSent) {
                  yreq.progressCb(ackBytes, yreq.toBeSent.length);
                }
                let newRate = deltaBytes * 1e3 / deltaTime;
                this._uploadRate[tcpchan] = 0.8 * this._uploadRate[tcpchan] + 0.3 * newRate >> 0;
                if (this._hub._yapi._logLevel >= 5) {
                  this._hub._yapi.imm_log("New rate: " + this._uploadRate[tcpchan] / 1e3 + " KB/s (last " + (deltaBytes / 1e3 >> 0) + "KB sent at " + (newRate >> 0) / 1e3 + " KB/s)");
                }
              } else {
                this._lastUploadAckBytes[tcpchan] = ackBytes;
                this._lastUploadAckTime[tcpchan] = ackTime;
                this._lastUploadRateBytes[tcpchan] = ackBytes;
                this._lastUploadRateTime[tcpchan] = ackTime;
                if (yreq.progressCb && yreq.toBeSent) {
                  yreq.progressCb(ackBytes, yreq.toBeSent.length);
                }
                this.imm_sendPendingRequest(tcpchan);
              }
            }
            break;
        }
        return;
      }
      this.imm_asyncWebSocketError(YAPI_IO_ERROR, "Unsupported message: " + this._hub._yapi.imm_bin2hexstr(arr_bytes));
    } catch (e) {
      this._hub._yapi.imm_log("Unhandled exception in _webSocketMsg:", e);
    }
  }
  /** Send an outgoing packet
   **/
  imm_webSocketSend(arr_bytes) {
    if (this.websocket) {
      this.websocket.send(arr_bytes);
    }
  }
  imm_hasPendingRequest() {
    for (let tcpchan = 0; tcpchan < 4; tcpchan++) {
      let queue = this.tcpChan[tcpchan];
      if (queue) {
        return true;
      }
    }
    return false;
  }
  async waitForPendingQueries(ms_duration) {
    let end = this._hub._yapi.GetTickCount() + ms_duration;
    let remaining = ms_duration;
    while (this.imm_hasPendingRequest() && remaining > 0) {
      let waitTime = Math.min(remaining, 25);
      await new Promise((resolve, reject) => {
        setTimeout(resolve, waitTime);
      });
      remaining = end - this._hub._yapi.GetTickCount();
    }
  }
  /** Perform an HTTP query on the hub
   */
  async request(method, devUrl, obj_body, tcpchan) {
    if (this._hub._yapi._logLevel >= 3) {
      this._hub.imm_logrequest(method, devUrl, obj_body);
    }
    let httpPromise = new Promise((resolve, reject) => {
      let subReq = method + " " + devUrl + " \r\n\r\n";
      let ws = this.websocket;
      let isAsync = this._remoteVersion > 0 && devUrl.slice(-2) == "&.";
      let yreq = new YHTTPRequest(new Uint8Array(0));
      if (this._hub._yapi._logLevel >= 5) {
        yreq._creat = (Date.now() % 6e5).toString();
        this._hub._yapi.imm_log("request @" + yreq._creat + ": " + method + " " + devUrl);
      }
      yreq.acceptor = resolve;
      yreq.devUrl = devUrl;
      yreq.sendPos = 0;
      if (obj_body) {
        let boundary = this._hub.imm_getBoundary();
        let body = this._hub.imm_formEncodeBody(obj_body, boundary);
        subReq = subReq.slice(0, -2) + "Content-Type: x-upload, boundary=" + boundary + "\r\n\r\n";
        yreq.toBeSent = new Uint8Array(subReq.length + body.length);
        yreq.toBeSent.set(body, subReq.length);
        yreq.progressCb = obj_body.progressCb;
      } else {
        yreq.toBeSent = new Uint8Array(subReq.length);
      }
      for (let i = 0; i < subReq.length; i++) {
        yreq.toBeSent[i] = subReq.charCodeAt(i);
      }
      if (tcpchan > 3) {
        yreq.errorType = YAPI_IO_ERROR;
        yreq.errorMsg = "Unsupported tcpChan " + tcpchan;
        try {
          yreq.acceptor(yreq);
        } catch (e) {
        }
        return;
      }
      if (!ws || this._hub.imm_isDisconnecting() || this._connectionState != 5) {
        if (this._hub._yapi._logLevel >= 4) {
          let wsState = ws ? " websocket=NULL" : "";
          let dsState = this._hub.imm_isDisconnecting() ? " disconnecting" : "";
          let cnState = this._connectionState != 5 ? " connState=" + this._connectionState : "";
          this._hub._yapi.imm_log("request @" + yreq._creat + " failed, websocket is down:" + wsState + dsState + cnState);
        }
        yreq.errorType = YAPI_IO_ERROR;
        yreq.errorMsg = "WebSocket not connected";
        try {
          yreq.acceptor(yreq);
        } catch (e) {
        }
        return;
      }
      if (isAsync) {
        yreq.asyncId = this.nextAsyncId++;
        if (this.nextAsyncId >= 127) {
          this.nextAsyncId = 48;
        }
      }
      let queue = this.tcpChan[tcpchan];
      if (queue) {
        while (queue.next) {
          queue = queue.next;
        }
        queue.next = yreq;
      } else {
        this.tcpChan[tcpchan] = yreq;
      }
      this.imm_sendPendingRequest(tcpchan);
    });
    return httpPromise;
  }
  /** Send all possible pending requests on specified tcpchan
   */
  imm_sendPendingRequest(tcpchan) {
    let yreq = this.tcpChan[tcpchan];
    while (yreq) {
      if (!this.websocket || this._hub.imm_isDisconnecting() || this._connectionState != 5) {
        if (this._hub._yapi._logLevel >= 4) {
          this._hub._yapi.imm_log("request @" + yreq._creat + " failed, websocket is down");
        }
        yreq.errorType = YAPI_IO_ERROR;
        yreq.errorMsg = "WebSocket not connected";
        if (yreq.acceptor) {
          try {
            yreq.acceptor(yreq);
          } catch (e) {
          }
        }
        yreq = yreq.next;
        continue;
      }
      let pendingCount = 1;
      for (let yr = yreq; yr.next; yr = yr.next) {
        pendingCount++;
      }
      if (!yreq.toBeSent) {
        if (yreq.asyncId == 0) {
          if (this._hub._yapi._logLevel >= 5) {
            this._hub._yapi.imm_log(pendingCount.toString() + " req pending, @" + yreq._creat + " not completed");
          }
          return;
        }
        yreq = yreq.next;
        continue;
      }
      let isAsync = yreq.asyncId != 0;
      let asyncCloseSet = false;
      let pos = yreq.sendPos;
      let end = yreq.toBeSent.length;
      let i, frame;
      if (end > 2108 && this._remoteVersion >= 2 && tcpchan == 0) {
        if (pos == 0) {
          end = 2108;
          this._lastUploadAckBytes[tcpchan] = 0;
          this._lastUploadAckTime[tcpchan] = 0;
          this._uploadRate[tcpchan] = this._tcpMaxWindowSize * 1e3 / this._tcpRoundTripTime >> 0;
        } else if (this._lastUploadAckTime[tcpchan] == 0) {
          if (yreq.sendTimeoutId)
            clearTimeout(yreq.sendTimeoutId);
          yreq.sendTimeoutId = setTimeout(() => {
            this.imm_sendPendingRequest(tcpchan);
          }, this._tcpRoundTripTime);
          return;
        } else {
          let bytesOnTheAir = pos - this._lastUploadAckBytes[tcpchan];
          let uploadRate = this._uploadRate[tcpchan];
          let timeOnTheAir = this._hub._yapi.GetTickCount() - this._lastUploadAckTime[tcpchan];
          let toBeSent = 2 * uploadRate + 1024 - bytesOnTheAir + uploadRate * timeOnTheAir / 1e3 >> 0;
          if (toBeSent + bytesOnTheAir > this._DEFAULT_TCP_MAX_WINDOW_SIZE) {
            toBeSent = this._DEFAULT_TCP_MAX_WINDOW_SIZE - bytesOnTheAir;
          }
          if (toBeSent < 64) {
            let waitTime = 1e3 * (128 - toBeSent) / uploadRate >> 0;
            if (waitTime < 2)
              waitTime = 2;
            if (yreq.sendTimeoutId)
              clearTimeout(yreq.sendTimeoutId);
            yreq.sendTimeoutId = setTimeout(() => {
              this.imm_sendPendingRequest(tcpchan);
            }, waitTime);
            return;
          }
          if (end > pos + toBeSent) {
            if (toBeSent > 124) {
              toBeSent = (toBeSent / 124 >> 0) * 124;
            }
            end = pos + toBeSent;
          }
        }
      }
      while (pos < end) {
        let framelen = 1 + end - pos;
        if (framelen > 125)
          framelen = 125;
        let datalen = framelen - 1;
        if (pos < 180 && pos + datalen >= 192) {
          datalen = 191 - pos;
          framelen = datalen + 1;
        }
        if (isAsync && pos + datalen == yreq.toBeSent.length && framelen < 125) {
          frame = new Uint8Array(framelen + 1);
          frame[0] = 8 * 9 + tcpchan;
          frame[framelen] = yreq.asyncId;
          asyncCloseSet = true;
        } else {
          frame = new Uint8Array(framelen);
          frame[0] = 8 * 1 + tcpchan;
        }
        frame.set(yreq.toBeSent.subarray(pos, pos + datalen), 1);
        pos += datalen;
        this.imm_webSocketSend(frame);
      }
      let sent = pos - yreq.sendPos;
      yreq.sendPos = pos;
      if (yreq.sendPos < yreq.toBeSent.length) {
        let waitTime = 1e3 * sent / this._uploadRate[tcpchan] >> 0;
        if (waitTime < 2)
          waitTime = 2;
        if (yreq.sendTimeoutId)
          clearTimeout(yreq.sendTimeoutId);
        yreq.sendTimeoutId = setTimeout(() => {
          this.imm_sendPendingRequest(tcpchan);
        }, waitTime);
        return;
      }
      if (isAsync && !asyncCloseSet) {
        frame = new Uint8Array(2);
        frame[0] = 8 * 9 + tcpchan;
        frame[1] = yreq.asyncId;
        this.imm_webSocketSend(frame);
      }
      yreq.toBeSent = null;
      if (isAsync && yreq.acceptor) {
        try {
          yreq.acceptor(yreq);
        } catch (e) {
          this._hub._yapi.imm_log("WS: async acceptor exception: ", e);
        }
      }
      let mstimeout = this._hub._yapi._networkTimeoutMs;
      if (yreq.devUrl) {
        if (yreq.devUrl.indexOf("/testcb.txt") >= 0) {
          mstimeout = this._YIO_1_MINUTE_TCP_TIMEOUT;
        } else if (yreq.devUrl.indexOf("/logger.json") >= 0) {
          mstimeout = this._YIO_1_MINUTE_TCP_TIMEOUT;
        } else if (yreq.devUrl.indexOf("/rxmsg.json") >= 0) {
          mstimeout = this._YIO_1_MINUTE_TCP_TIMEOUT;
        } else if (yreq.devUrl.indexOf("/rxdata.bin") >= 0) {
          mstimeout = this._YIO_1_MINUTE_TCP_TIMEOUT;
        } else if (yreq.devUrl.indexOf("/at.txt") >= 0) {
          mstimeout = this._YIO_1_MINUTE_TCP_TIMEOUT;
        } else if (yreq.devUrl.indexOf("/files.json") >= 0) {
          mstimeout = this._YIO_1_MINUTE_TCP_TIMEOUT;
        } else if (yreq.devUrl.indexOf("/upload.html") >= 0) {
          mstimeout = this._YIO_10_MINUTES_TCP_TIMEOUT;
        } else if (yreq.devUrl.indexOf("/flash.json") >= 0) {
          mstimeout = this._YIO_10_MINUTES_TCP_TIMEOUT;
        } else if (yreq.devUrl.indexOf("/Yvw4I.js") >= 0) {
          mstimeout = this._YIO_10_MINUTES_TCP_TIMEOUT;
        }
      }
      yreq.timeoutId = setTimeout((chan, yr) => {
        this.imm_abortRequest(chan, yr);
      }, mstimeout, tcpchan, yreq);
      yreq._sent = (Date.now() % 6e5).toString();
      if (this._hub._yapi._logLevel >= 5) {
        this._hub._yapi.imm_log("req @" + yreq._creat + " sent (1/" + pendingCount.toString() + ")" + (isAsync ? " async-" + yreq.asyncId + ", continue" : ", waiting for reply"));
      }
      if (!isAsync) {
        return;
      }
      yreq = yreq.next;
    }
  }
  // Abort a request and send close packet to peer
  //
  imm_abortRequest(tcpchan, yreq) {
    if (!yreq.timeoutId)
      return;
    yreq.timeoutId = null;
    if (yreq.asyncId == 0) {
      let frame = new Uint8Array(1);
      frame[0] = 8 * 2 + tcpchan;
      this.imm_webSocketSend(frame);
      if (this._hub._yapi._logLevel >= 4) {
        let pendingCount = 1;
        for (let yr = yreq; yr.next; yr = yr.next) {
          pendingCount++;
        }
        this._hub._yapi.imm_log(pendingCount.toString() + " req pending, @" + yreq._creat + " is in timeout");
      }
      setTimeout((chan, yr) => {
        this._hub._yapi.imm_log("Dropping synchronous request after timeout: " + yr.devUrl);
        this.imm_forgetRequest(chan, yr);
      }, 5e3, tcpchan, yreq);
    }
    this.imm_asyncWebSocketError(YAPI_IO_ERROR, "Timeout on " + yreq.devUrl + " (tcpchan " + tcpchan + ")");
  }
  // Drop a request from queue in case of timeout after abort
  //
  imm_forgetRequest(tcpchan, yreq) {
    let queue = this.tcpChan[tcpchan];
    if (queue == yreq) {
      this.tcpChan[tcpchan] = yreq.next;
      if (yreq.asyncId == 0) {
        yreq.errorType = YAPI_IO_ERROR;
        yreq.errorMsg = "Timeout on " + yreq.devUrl + " (tcpchan " + tcpchan + ")";
        if (yreq.acceptor) {
          try {
            yreq.acceptor(yreq);
          } catch (e) {
          }
        }
      }
      this.imm_sendPendingRequest(tcpchan);
    }
  }
  // Drop all pending requests from queues, as well as forwarded connection, when a hub connection is dropped
  //
  imm_dropAllPendingConnection() {
    if (this.fwd_connectionState != 1 && this.fwd_websocket) {
      this.fwd_connectionState = 1;
      this.fwd_websocket.close();
      this.fwd_websocket = null;
    }
    for (let tcpchan = 0; tcpchan < this.tcpChan.length; tcpchan++) {
      for (let yreq = this.tcpChan[tcpchan]; yreq; yreq = yreq.next) {
        this.tcpChan[tcpchan] = yreq.next;
        if (yreq.timeoutId) {
          clearTimeout(yreq.timeoutId);
          yreq.timeoutId = 0;
        }
        if (yreq.asyncId == 0) {
          if (this._hub._yapi._logLevel >= 4) {
            this._hub._yapi.imm_log("drop @" + yreq._creat + " (websocket down)");
          }
          yreq.errorType = YAPI_IO_ERROR;
          yreq.errorMsg = "Request " + yreq.devUrl + " dropped (websocket down)";
          if (yreq.acceptor) {
            try {
              yreq.acceptor(yreq);
            } catch (e) {
            }
          }
        }
      }
    }
  }
  async websocketJoin(ws, arr_credentials, close_callback) {
    if (this._connectionState != 5) {
      this.imm_asyncWebSocketError(YAPI_IO_ERROR, "Hub is disconnected, cannot join");
      return false;
    }
    this.fwd_websocket = ws;
    this.fwd_credentials = arr_credentials;
    this.fwd_closeCallback = close_callback;
    this.fwd_connectionState = 2;
    ws.onmessage = ((evt) => {
      if (this.fwd_connectionState == 5) {
        if (this._connectionState == 5) {
          this.imm_webSocketSend(evt.data);
        } else {
          this._hub._yapi.imm_log("WS: drop packet from fwd API (state=" + this._connectionState + ")");
        }
      } else if (this.fwd_connectionState == 3) {
        this.imm_handleAPIAuthPkt(evt.data);
      } else {
        this._hub._yapi.imm_log("WS: drop packet from fwd API (fwd_state=" + this.fwd_connectionState + ")");
      }
    });
    ws.onclose = ((evt) => {
      this.fwd_connectionState = 1;
      this.fwd_websocket = null;
      if (this.fwd_closeCallback) {
        this.fwd_closeCallback();
      }
    });
    return this.imm_sendAPIAnnouncePkt();
  }
  imm_sendAPIAnnouncePkt() {
    if (!this.fwd_websocket) {
      return false;
    }
    let frame = new Uint8Array(1 + this._USB_META_WS_ANNOUNCE_SIZE);
    let nonce = new Uint8Array(4);
    this.imm_getRandomValues(nonce);
    frame[0] = 5 << 3;
    frame[1] = 4;
    frame[2] = 2;
    frame[3] = this._tcpMaxWindowSize >> 4 & 255;
    frame[4] = this._tcpMaxWindowSize >> 12 & 255;
    for (let i = 0; i < 4; i++) {
      frame[5 + i] = nonce[i];
    }
    for (let i = 0; i < this._remoteSerial.length && i < 20; i++) {
      frame[9 + i] = this._remoteSerial.charCodeAt(i);
    }
    this.fwd_nonce = frame[5] + (frame[6] << 8) + (frame[7] << 16) + (frame[8] << 24);
    this.fwd_connectionState = 3;
    this.fwd_websocket.send(frame);
    return true;
  }
  imm_handleAPIAuthPkt(msg) {
    if (msg.length < 1 + this._USB_META_WS_AUTHENTICATION_SIZE || msg[0] != 5 << 3) {
      if (this._hub._yapi._logLevel >= 3) {
        this._hub._yapi.imm_log("bad-apiauth1\n");
      }
      this.fwd_connectionState = 0;
      return;
    }
    if (msg[1] != 5 || msg[2] > 2) {
      if (this._hub._yapi._logLevel >= 3) {
        this._hub._yapi.imm_log("bad-apiauth2\n");
      }
      this.fwd_connectionState = 0;
      return;
    }
    this._remoteVersion = msg[2];
    let flags = msg[3] + (msg[4] << 8);
    if ((flags & this._USB_META_WS_VALID_SHA1) == 0) {
      if (this._hub._yapi._logLevel >= 3) {
        this._hub._yapi.imm_log("bad-apiauth3\n");
      }
      this.fwd_connectionState = 0;
      return;
    }
    if (!this.fwd_websocket) {
      if (this._hub._yapi._logLevel >= 3) {
        this._hub._yapi.imm_log("no-fwd-ws\n");
      }
      this.fwd_connectionState = 0;
      return;
    }
    let credIdx, remote_sha1 = msg.subarray(9, 29);
    let credentials = this.fwd_credentials;
    for (credIdx = 0; credIdx < credentials.length; credIdx++) {
      let j, sha12 = this.imm_computeAuth(credentials[credIdx].user, credentials[credIdx].pass, this._remoteSerial, this.fwd_nonce);
      for (j = 0; j < sha12.length; j++) {
        if (sha12[j] != remote_sha1[j])
          break;
      }
      if (j >= sha12.length)
        break;
    }
    if (credIdx >= credentials.length) {
      if (this._hub._yapi._logLevel >= 3) {
        this._hub._yapi.imm_log("bad-apiauth4\n");
      }
      msg.fill(0, 3);
      this.fwd_websocket.send(msg);
      this.fwd_connectionState = 0;
      return;
    }
    msg[3] |= this._USB_META_WS_RW;
    this.fwd_nonce = msg[5] + (msg[6] << 8) + (msg[7] << 16) + (msg[8] << 24);
    let sha1 = this.imm_computeAuth(credentials[credIdx].user, credentials[credIdx].pass, this._remoteSerial, this.fwd_nonce);
    for (let i = 0; i < sha1.length; i++) {
      msg[9 + i] = sha1[i];
    }
    this.fwd_websocket.send(msg);
    this.fwd_connectionState = 5;
  }
  async detach(errType = YAPI.IO_ERROR, errMsg = "Hub has been forcibly detached") {
    let tcpchan_busy;
    let timeout = this._hub._yapi.GetTickCount() + 3e3;
    do {
      tcpchan_busy = false;
      for (let tcpchan = 0; tcpchan < 4; tcpchan++) {
        if (this.tcpChan[tcpchan] != null) {
          tcpchan_busy = true;
          break;
        }
      }
      if (tcpchan_busy) {
        await this._hub._yapi._microSleep_internal();
      }
    } while (tcpchan_busy && timeout > this._hub._yapi.GetTickCount());
    this._hub.imm_commonDisconnect("detach", errType, errMsg);
    this._hub.imm_disconnectNow();
  }
  // abort communication channel immediately
  //
  // If a connectionID is passed as argument, only abort the
  // communication channel if the ID matched current connection
  //
  imm_disconnectEngineNow(connID = "") {
    if (!this.websocket) {
      return;
    }
    this._connectionState = 1;
    let prevOpenID = connID ? connID : this._hub.imm_getCurrentConnID();
    let websocket = this.websocket;
    this._hub.imm_setCurrentConnID("");
    this.websocket = null;
    websocket.onclose = null;
    websocket.onerror = null;
    try {
      websocket.close();
    } catch (e) {
    }
    if (websocket.terminate) {
      setTimeout(() => {
        try {
          if (websocket.terminate) {
            websocket.terminate();
          }
        } catch (e) {
        }
      }, 900);
    }
    this.imm_dropAllPendingConnection();
    this._hub.imm_signalHubDisconnected(prevOpenID);
  }
  imm_isConnected() {
    if (this._connectionState != 5) {
      return false;
    }
    return super.imm_isConnected();
  }
};
var YHub = class _YHub {
  //--- (end of generated code: YHub attributes declaration)
  constructor(obj_yapi, hubref) {
    this._hubref = 0;
    this.TRYING = 1;
    this.CONNECTED = 2;
    this.RECONNECTING = 3;
    this.ABORTED = 4;
    this.UNREGISTERED = 5;
    this._ctx = obj_yapi;
    this._hubref = hubref;
  }
  async _getStrAttr_internal(attrName) {
    let hub = this._ctx.getGenHub(this._hubref);
    if (hub == null) {
      return "";
    }
    switch (attrName) {
      case "registeredUrl":
        return hub.imm_getOriginalURL();
      case "connectionUrl":
        return hub.imm_getRootUrl();
      case "serialNumber":
        return hub.imm_getSerialNumber();
      case "errorMessage":
        return hub.get_errorMessage();
      default:
        return "";
    }
  }
  async _getIntAttr_internal(attrName) {
    let hub = this._ctx.getGenHub(this._hubref);
    if (attrName == "isInUse") {
      return hub != null ? 1 : 0;
    }
    if (attrName == "connectionState") {
      if (hub == null) {
        return _YHub.UNREGISTERED;
      }
      return hub.imm_getConnectionState();
    }
    if (hub == null) {
      return -1;
    }
    switch (attrName) {
      case "isOnline":
        return hub.imm_isOnline() ? 1 : 0;
      case "isReadOnly":
        return await hub.hasRwAccess() ? 0 : 1;
      case "networkTimeout":
        return hub.imm_getNetworkTimeout();
      case "errorType":
        return hub.get_errorType();
      default:
        return -1;
    }
  }
  async _setIntAttr_internal(attrName, value) {
    let hub = this._ctx.getGenHub(this._hubref);
    if (hub != null && attrName == "networkTimeout") {
      hub.imm_setNetworkTimeout(value);
    }
  }
  get_knownUrls_internal() {
    let hub = this._ctx.getGenHub(this._hubref);
    if (hub != null) {
      return hub.get_knownUrls();
    }
    return [];
  }
  //--- (generated code: YHub implementation)
  async _getStrAttr(attrName) {
    return await this._getStrAttr_internal(attrName);
  }
  async _getIntAttr(attrName) {
    return await this._getIntAttr_internal(attrName);
  }
  async _setIntAttr(attrName, value) {
    return await this._setIntAttr_internal(attrName, value);
  }
  /**
   * Returns the URL that has been used first to register this hub.
   */
  async get_registeredUrl() {
    return await this._getStrAttr("registeredUrl");
  }
  /**
   * Returns all known URLs that have been used to register this hub.
   * URLs are pointing to the same hub when the devices connected
   * are sharing the same serial number.
   */
  async get_knownUrls() {
    return await this.get_knownUrls_internal();
  }
  /**
   * Returns the URL currently in use to communicate with this hub.
   */
  async get_connectionUrl() {
    return await this._getStrAttr("connectionUrl");
  }
  /**
   * Returns the state of the connection with this hub. (TRYING, CONNECTED, RECONNECTING, ABORTED, UNREGISTERED)
   */
  async get_connectionState() {
    return await this._getIntAttr("connectionState");
  }
  /**
   * Returns the hub serial number, if the hub was already connected once.
   */
  async get_serialNumber() {
    return await this._getStrAttr("serialNumber");
  }
  /**
   * Tells if this hub is still registered within the API.
   *
   * @return true if the hub has not been unregistered.
   */
  async isInUse() {
    return await this._getIntAttr("isInUse") > 0;
  }
  /**
   * Tells if there is an active communication channel with this hub.
   *
   * @return true if the hub is currently connected.
   */
  async isOnline() {
    return await this._getIntAttr("isOnline") > 0;
  }
  /**
   * Tells if write access on this hub is blocked. Return true if it
   * is not possible to change attributes on this hub
   *
   * @return true if it is not possible to change attributes on this hub.
   */
  async isReadOnly() {
    return await this._getIntAttr("isReadOnly") > 0;
  }
  /**
   * Modifies tthe network connection delay for this hub.
   * The default value is inherited from ySetNetworkTimeout
   * at the time when the hub is registered, but it can be updated
   * afterward for each specific hub if necessary.
   *
   * @param networkMsTimeout : the network connection delay in milliseconds.
   * @noreturn
   */
  async set_networkTimeout(networkMsTimeout) {
    await this._setIntAttr("networkTimeout", networkMsTimeout);
  }
  /**
   * Returns the network connection delay for this hub.
   * The default value is inherited from ySetNetworkTimeout
   * at the time when the hub is registered, but it can be updated
   * afterward for each specific hub if necessary.
   *
   * @return the network connection delay in milliseconds.
   */
  async get_networkTimeout() {
    return await this._getIntAttr("networkTimeout");
  }
  /**
   * Returns the numerical error code of the latest error with the hub.
   * This method is mostly useful when using the Yoctopuce library with
   * exceptions disabled.
   *
   * @return a number corresponding to the code of the latest error that occurred while
   *         using the hub object
   */
  async get_errorType() {
    return await this._getIntAttr("errorType");
  }
  /**
   * Returns the error message of the latest error with the hub.
   * This method is mostly useful when using the Yoctopuce library with
   * exceptions disabled.
   *
   * @return a string corresponding to the latest error message that occured while
   *         using the hub object
   */
  async get_errorMessage() {
    return await this._getStrAttr("errorMessage");
  }
  /**
   * Returns the value of the userData attribute, as previously stored
   * using method set_userData.
   * This attribute is never touched directly by the API, and is at
   * disposal of the caller to store a context.
   *
   * @return the object stored previously by the caller.
   */
  async get_userData() {
    return this._userData;
  }
  /**
   * Stores a user context provided as argument in the userData
   * attribute of the function.
   * This attribute is never touched by the API, and is at
   * disposal of the caller to store a context.
   *
   * @param data : any kind of object to be stored
   * @noreturn
   */
  async set_userData(data) {
    this._userData = data;
  }
  /**
   * Starts the enumeration of hubs currently in use by the API.
   * Use the method YHub.nextHubInUse() to iterate on the
   * next hubs.
   *
   * @return a pointer to a YHub object, corresponding to
   *         the first hub currently in use by the API, or a
   *         null pointer if none has been registered.
   */
  static FirstHubInUse() {
    return YAPI.nextHubInUseInternal(-1);
  }
  /**
   * Starts the enumeration of hubs currently in use by the API
   * in a given YAPI context.
   * Use the method YHub.nextHubInUse() to iterate on the
   * next hubs.
   *
   * @param yctx : a YAPI context
   *
   * @return a pointer to a YHub object, corresponding to
   *         the first hub currently in use by the API, or a
   *         null pointer if none has been registered.
   */
  static FirstHubInUseInContext(yctx) {
    return yctx.nextHubInUseInternal(-1);
  }
  /**
   * Retrieves hub for a given identifier. The identifier can be the URL or the
   * serial of the hub.
   *
   * @param url : The url or serial of the hub.
   *
   * @return a pointer to a YHub object, corresponding to
   *         the first hub currently in use by the API, or a
   *         null pointer if none has been registered.
   */
  static async FindHubInUse(url) {
    return await YAPI.findYHubFromID(url);
  }
  /**
   * Retrieves hub for a given identifier in a given YAPI context. The identifier can be the URL or the
   * serial of the hub.
   *
   * @param yctx : a YAPI context
   * @param url : The url or serial of the hub.
   *
   * @return a pointer to a YHub object, corresponding to
   *         the first hub currently in use by the API, or a
   *         null pointer if none has been registered.
   */
  static async FindHubInUseInContext(yctx, url) {
    return await yctx.findYHubFromID(url);
  }
  /**
   * Continues the module enumeration started using YHub.FirstHubInUse().
   * Caution: You can't make any assumption about the order of returned hubs.
   *
   * @return a pointer to a YHub object, corresponding to
   *         the next hub currently in use, or a null pointer
   *         if there are no more hubs to enumerate.
   */
  nextHubInUse() {
    return this._ctx.nextHubInUseInternal(this._hubref);
  }
};
YHub.TRYING = 1;
YHub.CONNECTED = 2;
YHub.RECONNECTING = 3;
YHub.ABORTED = 4;
YHub.UNREGISTERED = 5;
var YAPIContext = class {
  constructor(system_env) {
    this._detectType = Y_DETECT_NONE;
    this._knownHubsBySerial = {};
    this._knownHubsByUrl = {};
    this._connectedHubs = [];
    this._registeredHubs = [];
    this._trustedCertificate = [];
    this._networkSecurityOptions = 0;
    this._yhub_cache = {};
    this._ssdpManager = null;
    this._devs = {};
    this._snByUrl = {};
    this._snByName = {};
    this._fnByType = {};
    this._lastErrorType = YAPI_SUCCESS;
    this._lastErrorMsg = "no error";
    this._updateDevListStarted = 0;
    this._pendingCallbacks = [];
    this._logLevel = 4;
    this._logCallback = null;
    this._arrivalCallback = null;
    this._namechgCallback = null;
    this._removalCallback = null;
    this._hubDiscoveryCallback = null;
    this._forwardValues = 0;
    this._calibHandlers = [];
    this._ValueCallbackList = [];
    this._TimedReportCallbackList = [];
    this._beacons = {};
    this._isNodeJS = false;
    this._networkTimeoutMs = DEFAULT_NETWORK_TIMEOUT_MS;
    this._deviceListValidityMs = DEFAULT_DEVICE_LIST_VALIDITY_MS;
    this._crcTable = null;
    this.defaultEncoding = "binary";
    this.exceptionsDisabled = false;
    this.SUCCESS = 0;
    this.NOT_INITIALIZED = -1;
    this.INVALID_ARGUMENT = -2;
    this.NOT_SUPPORTED = -3;
    this.DEVICE_NOT_FOUND = -4;
    this.VERSION_MISMATCH = -5;
    this.DEVICE_BUSY = -6;
    this.TIMEOUT = -7;
    this.IO_ERROR = -8;
    this.NO_MORE_DATA = -9;
    this.EXHAUSTED = -10;
    this.DOUBLE_ACCES = -11;
    this.UNAUTHORIZED = -12;
    this.RTC_NOT_READY = -13;
    this.FILE_NOT_FOUND = -14;
    this.SSL_ERROR = -15;
    this.RFID_SOFT_ERROR = -16;
    this.RFID_HARD_ERROR = -17;
    this.BUFFER_TOO_SMALL = -18;
    this.DNS_ERROR = -19;
    this.SSL_UNK_CERT = -20;
    this.UNCONFIGURED = -21;
    this.NO_TRUSTED_CA_CHECK = 1;
    this.NO_EXPIRATION_CHECK = 2;
    this.NO_HOSTNAME_CHECK = 4;
    this.LEGACY = 8;
    this.defaultCacheValidity = 5;
    this.INVALID_INT = YAPI_INVALID_INT;
    this.INVALID_UINT = YAPI_INVALID_UINT;
    this.INVALID_LONG = YAPI_INVALID_LONG;
    this.INVALID_DOUBLE = YAPI_INVALID_DOUBLE;
    this.MIN_DOUBLE = YAPI_MIN_DOUBLE;
    this.MAX_DOUBLE = YAPI_MAX_DOUBLE;
    this.INVALID_STRING = YAPI_INVALID_STRING;
    this.HASH_BUF_SIZE = YOCTO_HASH_BUF_SIZE;
    this.DETECT_NONE = Y_DETECT_NONE;
    this.DETECT_USB = Y_DETECT_USB;
    this.DETECT_NET = Y_DETECT_NET;
    this.DETECT_ALL = Y_DETECT_ALL;
    this.YOCTO_DEFAULT_HTTP_PORT = 4444;
    this.YOCTO_DEFAULT_HTTPS_PORT = 4443;
    this.system_env = system_env || YAPI && YAPI.system_env || _UnspecifiedSystemEnv;
    this._isNodeJS = this.system_env.isNodeJS;
    this._uniqueID = String.fromCharCode(Math.random() * 79 + 48, Math.random() * 79 + 48, Math.random() * 79 + 48);
    this.imm_ResetToDefaults();
  }
  imm_ResetToDefaults() {
    this._detectType = this.DETECT_NONE;
    this._knownHubsBySerial = {};
    this._knownHubsByUrl = {};
    this._connectedHubs = [];
    this._registeredHubs = [];
    this._trustedCertificate = [];
    this._networkSecurityOptions = 0;
    this._devs = {};
    this._snByUrl = {};
    this._snByName = {};
    this._fnByType = {};
    this._fnByType.Module = new YFunctionType(this, "Module");
    this._lastErrorType = YAPI_SUCCESS;
    this._lastErrorMsg = "no error";
    this._updateDevListStarted = 0;
    this._pendingCallbacks = [];
    this._logLevel = 2;
    this._logCallback = null;
    this._arrivalCallback = null;
    this._namechgCallback = null;
    this._removalCallback = null;
    this._hubDiscoveryCallback = null;
    this._forwardValues = 0;
    this._ValueCallbackList = [];
    this._TimedReportCallbackList = [];
    this._beacons = {};
    this._calibHandlers = [];
    for (let i = 1; i <= 20; i++) {
      this.RegisterCalibrationHandler(i, this.LinearCalibrationHandler);
    }
    this.RegisterCalibrationHandler(YOCTO_CALIB_TYPE_OFS, this.LinearCalibrationHandler);
    this.exceptionsDisabled = false;
  }
  _throw(int_errType, str_errMsg, obj_retVal) {
    this._lastErrorType = int_errType;
    this._lastErrorMsg = str_errMsg;
    if (!this.exceptionsDisabled) {
      let exc = new YoctoError(str_errMsg);
      exc.errorType = int_errType;
      throw exc;
    }
    return obj_retVal;
  }
  imm_setErr(errmsg, int_errType, str_errMsg, obj_retVal) {
    if (errmsg) {
      errmsg.msg = str_errMsg;
    }
    this._lastErrorType = int_errType;
    this._lastErrorMsg = str_errMsg;
    return obj_retVal;
  }
  imm_setSystemEnv(env) {
    this.system_env = env;
    this._isNodeJS = env.isNodeJS;
  }
  // Log a message, either to the user defined function or to the console if none is defined
  imm_log(msg, ...moreArgs) {
    let now = /* @__PURE__ */ new Date();
    let day = now.getFullYear().toString() + "-" + ("0" + (now.getMonth() + 1)).slice(-2) + "-" + ("0" + now.getDate()).slice(-2);
    let time = ("0" + now.getHours().toString()).slice(-2) + ":" + ("0" + now.getMinutes()).slice(-2) + ":" + ("0" + now.getSeconds()).slice(-2);
    let prefix = day + " " + time + " [" + this._uniqueID + "] ";
    let isError = false;
    if (moreArgs.length > 0) {
      if (moreArgs[0].constructor && /Error/i.test(moreArgs[0].constructor.name)) {
        isError = true;
      }
    }
    if (this._logCallback) {
      try {
        if (moreArgs.length > 0) {
          if (moreArgs[0].message) {
            msg += moreArgs[0].message;
          } else {
            msg += moreArgs[0].toString();
          }
        }
        this._logCallback(prefix + msg);
      } catch (e) {
        console.error(prefix + "Exception in custom log callback: ", e);
        console.log("... while trying to log:");
        if (isError) {
          console.error(prefix + msg, ...moreArgs);
        } else {
          console.log(prefix + msg, ...moreArgs);
        }
      }
    } else {
      if (isError) {
        console.error(prefix + msg, ...moreArgs);
      } else {
        console.log(prefix + msg, ...moreArgs);
      }
    }
  }
  /**
   * Registers a log callback function. This callback will be called each time
   * the API have something to say. Quite useful to debug the API.
   *
   * @param logfun : a procedure taking a string parameter, or null
   *         to unregister a previously registered  callback.
   */
  async RegisterLogFunction(logfun) {
    this._logCallback = logfun;
    return YAPI_SUCCESS;
  }
  // Search for an existing a hub object for a given URL
  imm_getHub(obj_urlInfo) {
    let hub = this._knownHubsByUrl[obj_urlInfo.imm_getRootUrl()];
    if (!hub) {
      for (const url in this._knownHubsByUrl) {
        if (this._knownHubsByUrl[url].imm_getOriginalURL() == obj_urlInfo.imm_getOriginalURL()) {
          return this._knownHubsByUrl[url];
        }
      }
    }
    return hub;
  }
  // Check if a given connected YGenericHub should be used as the primary hub object
  // Update the internal list of hubs on the fly
  //
  // This function chooses between equivalent hubs based connection state and precedence.
  // A disconnected hub is NEVER returned in place of a connected hub
  //
  imm_getPrimaryHub(hub) {
    let primaryHub = this._knownHubsBySerial[hub.imm_getSerialNumber()];
    if (!primaryHub || primaryHub === hub) {
      this._knownHubsBySerial[hub.imm_getSerialNumber()] = hub;
      this._knownHubsByUrl[hub.imm_getRootUrl()] = hub;
      return hub;
    }
    if (primaryHub.urlInfo.imm_useSecureSocket() || !hub.urlInfo.imm_useSecureSocket()) {
      if (primaryHub.imm_getcurrentState() >= hub.imm_getcurrentState()) {
        primaryHub.imm_inheritFrom(hub);
        this.imm_updateRegisteredHubs(hub, false);
        return primaryHub;
      }
    }
    this._knownHubsBySerial[hub.imm_getSerialNumber()] = hub;
    hub.imm_inheritFrom(primaryHub);
    this.imm_updateRegisteredHubs(primaryHub, false);
    return hub;
  }
  // Add a hub object to the list of actively attached hub
  async _addConnectedHub(newhub) {
    let serial = this._snByUrl[newhub.imm_getRootUrl()];
    if (!serial) {
      let newdev = new YDevice(this, newhub.imm_getRootUrl(), null, null);
      await newdev.refresh();
    }
    let hubFound = false;
    for (let i = 0; i < this._connectedHubs.length; i++) {
      let url = this._connectedHubs[i].imm_getRootUrl();
      if (newhub.imm_getRootUrl() == url) {
        hubFound = true;
        break;
      }
    }
    if (!hubFound) {
      this._connectedHubs.push(newhub);
    }
  }
  // Tell if a hub with a given serial number is already registered actively
  imm_isActiveHub(hubSerial) {
    for (let i = 0; i < this._connectedHubs.length; i++) {
      let hubSerials = this._connectedHubs[i].serialByYdx;
      if (hubSerials && hubSerials[0] == hubSerial) {
        return true;
      }
    }
    return false;
  }
  imm_dropConnectedHub(hub) {
    let idx = this._connectedHubs.indexOf(hub);
    if (idx < 0) {
      return;
    }
    for (let j = 0; j < hub.serialByYdx.length; j++) {
      let serial = hub.serialByYdx[j];
      if (serial && this._devs[serial]) {
        if (this._removalCallback) {
          let module = YModule.FindModuleInContext(this, serial + ".module");
          this._pendingCallbacks.push({ event: "-", serial, module });
        }
        try {
          this.imm_forgetDevice(this._devs[serial]);
        } catch (e) {
        }
      }
    }
    idx = this._connectedHubs.indexOf(hub);
    if (idx >= 0) {
      this._connectedHubs.splice(idx, 1);
    }
    this.imm_updateRegisteredHubs(hub, false);
  }
  // Wait until updateDeviceList is completed to avoid course conditions
  async _ensureUpdateDeviceListNotRunning() {
    while (this._updateDevListStarted && this.GetTickCount() - this._updateDevListStarted < 30 * 1e3) {
      await this.Sleep(25);
    }
  }
  // Trigger an update of connected devices by querying all hubs
  async _updateDeviceList_internal(bool_forceupdate, bool_invokecallbacks) {
    if (this._updateDevListStarted && this.GetTickCount() - this._updateDevListStarted < 30 * 1e3) {
      return {
        errorType: YAPI_SUCCESS,
        errorMsg: "no error"
      };
    }
    for (let i = 0; i < this._connectedHubs.length; i++) {
      if (this._connectedHubs[i].imm_isFirstArrivalCallback() && bool_invokecallbacks && this._arrivalCallback) {
        bool_forceupdate = true;
        break;
      }
    }
    if (bool_forceupdate) {
      for (let i = 0; i < this._connectedHubs.length; i++) {
        this._connectedHubs[i].imm_forceUpdate();
      }
    }
    try {
      this._updateDevListStarted = this.GetTickCount();
      let hubs = [];
      for (let i = 0; i < this._connectedHubs.length; i++) {
        let hub = this._connectedHubs[i];
        let rootUrl = hub.imm_getRootUrl();
        let hubDev = this.imm_getDevice(rootUrl);
        if (!hubDev) {
          continue;
        }
        if (hub.imm_getcurrentState() < 1) {
          if (this._logLevel >= 4) {
            this.imm_log("Skip updateDeviceList for hub " + hub.urlInfo.imm_getHost() + ", currently offline");
          }
          continue;
        }
        if (hub.devListExpires <= this.GetTickCount()) {
          hub._missing = {};
          hubs.push(hub);
        }
      }
      for (let serial in this._devs) {
        let rooturl = this._devs[serial].imm_getRootUrl();
        for (let i = 0; i < hubs.length; i++) {
          let huburl = hubs[i].imm_getRootUrl();
          if (rooturl.substr(0, huburl.length) == huburl) {
            hubs[i]._missing[serial] = true;
          }
        }
      }
      let update_promises = [];
      for (let i = 0; i < hubs.length; i++) {
        let prom = hubs[i].hubUpdateDeviceList();
        update_promises.push(prom);
      }
      let newDeviceCounts = await Promise.all(update_promises);
      let newDeviceArrived = false;
      for (let res of newDeviceCounts) {
        newDeviceArrived = newDeviceArrived || res > 0;
      }
      if (bool_invokecallbacks) {
        let nbEvents = this._pendingCallbacks.length;
        for (let i = 0; i < nbEvents; i++) {
          let evt = this._pendingCallbacks[i];
          switch (evt.event) {
            case "+":
              if (this._logLevel >= 3) {
                this.imm_log("Device " + evt.serial + " plugged");
              }
              if (this._arrivalCallback) {
                try {
                  await evt.module.load(this.defaultCacheValidity);
                  await this._arrivalCallback(evt.module);
                } catch (e) {
                  this.imm_log("Exception in device arrival callback:", e);
                }
              }
              break;
            case "/":
              if (this._namechgCallback) {
                try {
                  await this._namechgCallback(evt.module);
                } catch (e) {
                  this.imm_log("Exception in device change callback:", e);
                }
              }
              break;
            case "-":
              if (this._logLevel >= 3) {
                this.imm_log("Device " + evt.serial + " unplugged");
              }
              if (this._removalCallback) {
                try {
                  await this._removalCallback(evt.module);
                } catch (e) {
                  this.imm_log("Exception in device removal callback:", e);
                }
              }
              break;
          }
        }
        this._pendingCallbacks = this._pendingCallbacks.slice(nbEvents);
      }
      if (newDeviceArrived) {
        for (let fun of this._ValueCallbackList) {
          if (!fun._hwId) {
            fun.isOnline();
          }
        }
        for (let fun of this._TimedReportCallbackList) {
          if (!fun._hwId) {
            fun.isOnline();
          }
        }
      }
    } finally {
      this._updateDevListStarted = 0;
    }
    return {
      errorType: YAPI_SUCCESS,
      errorMsg: "no error"
    };
  }
  // process a hub white-pages/yellow-pages records to update the device data
  // return the number of NEW devices discovered, or a negative error code
  async updateDeviceList_process(hub, hubDev, whitePages, yellowPages) {
    let newDevices = 0;
    let refresh = {};
    let serial = null;
    for (let classname in yellowPages) {
      let obj_yprecs = yellowPages[classname];
      let ftype = this._fnByType[classname];
      if (ftype == void 0) {
        ftype = new YFunctionType(this, classname);
        this._fnByType[classname] = ftype;
      }
      for (let i = 0; i < obj_yprecs.length; i++) {
        let yprec = obj_yprecs[i];
        let hwid = yprec.hardwareId;
        let basetype = yprec.baseType;
        if (ftype.imm_reindexFunction(hwid, yprec["logicalName"], yprec["advertisedValue"], basetype)) {
          serial = hwid.substr(0, hwid.indexOf("."));
          refresh[serial] = true;
        }
      }
    }
    for (let i = 0; i < whitePages.length; i++) {
      let devinfo = whitePages[i];
      serial = devinfo.serialNumber;
      let devydx = devinfo.index;
      let rooturl = devinfo.networkUrl.slice(0, -3);
      if (rooturl.charAt(0) == "/")
        rooturl = hubDev.imm_getRootUrl() + rooturl.substr(1);
      let currdev = this._devs[serial];
      if (this._logLevel >= 5) {
        this.imm_log("Device " + serial + " present, currdev " + (currdev ? "" : "NOT ") + "set" + (hub.imm_isFirstArrivalCallback() ? ", firstArrival" : ""));
      }
      if (currdev && hub.imm_isFirstArrivalCallback()) {
        newDevices++;
        if (this._arrivalCallback) {
          let module = YModule.FindModuleInContext(this, serial + ".module");
          this._pendingCallbacks.push({ event: "+", serial, module });
        }
      }
      hub.serialByYdx[devydx] = serial;
      if (!currdev) {
        new YDevice(this, rooturl, devinfo, yellowPages);
        newDevices++;
        if (this._arrivalCallback) {
          let module = YModule.FindModuleInContext(this, serial + ".module");
          this._pendingCallbacks.push({ event: "+", serial, module });
        }
      } else if (currdev.imm_getLogicalName() != devinfo["logicalName"]) {
        await currdev.refresh();
        if (this._namechgCallback) {
          let module = YModule.FindModuleInContext(this, serial + ".module");
          this._pendingCallbacks.push({ event: "/", serial, module });
        }
      } else if (refresh[serial] || currdev.imm_getRootUrl() != rooturl || currdev.imm_getBeacon() != devinfo["beacon"]) {
        await currdev.refresh();
      }
      hub._missing[serial] = false;
    }
    if (this._arrivalCallback && hub.imm_isFirstArrivalCallback()) {
      hub.imm_setFirstArrivalCallback(false);
    }
    for (serial in hub._missing) {
      if (hub._missing[serial] && this._devs[serial]) {
        if (this._removalCallback) {
          let module = YModule.FindModuleInContext(this, serial + ".module");
          this._pendingCallbacks.push({ event: "-", serial, module });
        }
        this.imm_forgetDevice(this._devs[serial]);
      }
    }
    return newDevices;
  }
  /** process event data produced by a hub
   */
  async parseEvents(hub, str_lines) {
    if (hub.imm_isDisconnecting()) {
      return;
    }
    hub.isNotifWorking = true;
    if (hub.timeoutId) {
      clearTimeout(hub.timeoutId);
    }
    hub.timeoutId = setTimeout(() => {
      if (!hub.imm_isForwarded()) {
        this.imm_log("Closing stalled connection after " + hub.imm_getNetworkTimeout() / 1e3 + "s");
        hub.imm_disconnectNow();
      }
    }, hub.imm_getNetworkTimeout());
    let rows = (hub.notifCarryOver + str_lines).split("\n");
    let nrows = rows.length;
    let value;
    if (str_lines.substr(-1) != "\n") {
      hub.notifCarryOver = rows[--nrows];
    } else {
      nrows--;
      hub.notifCarryOver = "";
    }
    for (let idx = 0; idx < nrows; idx++) {
      let ev = rows[idx];
      if (ev.length == 0)
        continue;
      let firstCode = ev.charAt(0);
      if (ev.length >= 3 && firstCode >= NOTIFY_NETPKT_CONFCHGYDX && firstCode <= NOTIFY_NETPKT_TIMEAVGYDX) {
        hub.retryDelay = 15;
        if (hub.notifPos >= 0)
          hub.notifPos += ev.length + 1;
        let devydx = ev.charCodeAt(1) - 65;
        let funydx = ev.charCodeAt(2) - 48;
        if (funydx >= 64) {
          funydx -= 64;
          devydx += 128;
        }
        let serial = hub.serialByYdx[devydx];
        if (serial && this._devs[serial]) {
          let funcid = funydx == 15 ? "time" : this._devs[serial].imm_functionIdByFunYdx(funydx);
          if (funcid != "") {
            let dev;
            value = ev.slice(3);
            switch (firstCode) {
              case NOTIFY_NETPKT_FUNCVALYDX:
                if (value != "")
                  value = value.split("\0")[0];
                await this.setFunctionValue(serial + "." + funcid, value);
                break;
              case NOTIFY_NETPKT_DEVLOGYDX:
                dev = this._devs[serial];
                if (dev != null) {
                  dev.imm_triggerLogPull();
                }
                break;
              case NOTIFY_NETPKT_CONFCHGYDX:
                await this.setConfChange(serial);
                break;
              case NOTIFY_NETPKT_TIMEVALYDX:
              case NOTIFY_NETPKT_TIMEAVGYDX:
              case NOTIFY_NETPKT_TIMEV2YDX:
                let pos, arr = [firstCode == "x" ? 0 : firstCode == "z" ? 1 : 2];
                for (pos = 0; pos < value.length; pos += 2) {
                  arr.push(parseInt(value.substr(pos, 2), 16));
                }
                dev = this._devs[serial];
                if (funcid == "time") {
                  let time = arr[1] + 256 * arr[2] + 65536 * arr[3] + 16777216 * arr[4];
                  let ms = arr[5] * 4;
                  let duration;
                  if (arr.length >= 7) {
                    ms += arr[6] >> 6;
                    let duration_ms = arr[7];
                    duration_ms += (arr[6] & 15) * 256;
                    if (arr[6] & 16) {
                      duration = duration_ms;
                    } else {
                      duration = duration_ms / 1e3;
                    }
                  } else {
                    duration = 0;
                  }
                  dev.imm_setTimeRef(time + ms / 1e3, duration);
                } else {
                  await this.setTimedReport(serial + "." + funcid, dev.imm_getLastTimeRef(), dev.imm_getLastDuration(), arr);
                }
                break;
              case NOTIFY_NETPKT_FUNCV2YDX:
                let rawval = this.imm_decodeNetFuncValV2(value);
                if (rawval != null) {
                  let decodedval = this.imm_decodePubVal(rawval[0], rawval, 1, 6);
                  await this.setFunctionValue(serial + "." + funcid, decodedval);
                }
                break;
              case NOTIFY_NETPKT_FLUSHV2YDX:
              // To be implemented later
              default:
                break;
            }
          }
        }
      } else if (ev.length > 5 && ev.substr(0, 4) == "YN01") {
        hub.retryDelay = 15;
        if (hub.notifPos >= 0)
          hub.notifPos += ev.length + 1;
        let notype = ev.substr(4, 1);
        let parts;
        if (notype == "@") {
          hub.notifPos = parseInt(ev.slice(5));
        } else {
          switch (parseInt(notype)) {
            case 0:
              parts = ev.slice(5).split(",");
              if (parts.length > 2) {
                let int_beacon = parseInt(parts[2]);
                await this.setBeaconChange(parts[0], int_beacon);
              }
            // no break on purpose
            case 2:
            // device plug/unplug
            case 4:
            // function name change
            case 8:
              hub.devListExpires = 0;
              break;
            case 5:
              parts = ev.slice(5).split(",");
              if (parts.length > 2) {
                value = parts[2].split("\0");
                await this.setFunctionValue(parts[0] + "." + parts[1], value[0]);
              }
              break;
          }
        }
      } else {
        hub.devListExpires = 0;
        this.imm_log("Bad event on received from server:", ev);
        hub.notifPos = -1;
      }
    }
    if (this._forwardValues > 0) {
      await this.HandleEvents(new YErrorMsg());
    }
  }
  /** Network notification format: 7x7bit (mapped to 7 chars in range 32..159)
   *                               used to represent 1 flag (RAW6BYTES) + 6 bytes
   * INPUT:  [R765432][1076543][2107654][3210765][4321076][5432107][6543210]
   * OUTPUT: 7 bytes array (1 byte for the funcint_TypeV2 and 6 bytes of USB like data
   *                     funcTypeV2 + [R][-byte 0][-byte 1-][-byte 2-][-byte 3-][-byte 4-][-byte 5-]
   *
   * @return {number[]}
   */
  imm_decodeNetFuncValV2(p) {
    let p_ofs = 0;
    let ch = p.charCodeAt(p_ofs) & 255;
    let len = 0;
    let funcVal = [0, 0, 0, 0, 0, 0, 0];
    if (ch < 32 || ch > 32 + 127) {
      return null;
    }
    ch -= 32;
    funcVal[0] = (ch & 64) != 0 ? NOTIFY_V2_6RAWBYTES : NOTIFY_V2_TYPEDDATA;
    ch &= 63;
    while (len < YOCTO_PUBVAL_SIZE) {
      p_ofs++;
      if (p_ofs >= p.length) {
        break;
      }
      let newCh = p.charCodeAt(p_ofs) & 255;
      if (newCh == NOTIFY_NETPKT_STOP) {
        break;
      }
      if (newCh < 32 || newCh > 32 + 127) {
        return null;
      }
      newCh -= 32;
      ch = (ch << 7) + newCh;
      funcVal[len + 1] = ch >>> 5 - len & 255;
      len++;
    }
    return funcVal;
  }
  /** Decode an enhanced notification (V2) buffer
   */
  imm_decodePubVal(int_typeV2, arr_funcval, int_ofs, int_funcvalen) {
    let buffer = "";
    let endp;
    if (int_typeV2 == NOTIFY_V2_6RAWBYTES || int_typeV2 == NOTIFY_V2_TYPEDDATA) {
      let funcValType;
      if (int_typeV2 == NOTIFY_V2_6RAWBYTES) {
        funcValType = PUBVAL_6RAWBYTES;
      } else {
        funcValType = arr_funcval[int_ofs++];
      }
      switch (funcValType) {
        case PUBVAL_LEGACY:
          break;
        case PUBVAL_1RAWBYTE:
        case PUBVAL_2RAWBYTES:
        case PUBVAL_3RAWBYTES:
        case PUBVAL_4RAWBYTES:
        case PUBVAL_5RAWBYTES:
        case PUBVAL_6RAWBYTES:
          for (let i = 0; i < funcValType; i++) {
            let c = arr_funcval[int_ofs++];
            let b = c >>> 4;
            buffer += b.toString(16);
            b = c & 15;
            buffer += b.toString(16);
          }
          return buffer;
        case PUBVAL_C_LONG:
        case PUBVAL_YOCTO_FLOAT_E3:
          let numVal = arr_funcval[int_ofs++];
          numVal += arr_funcval[int_ofs++] << 8;
          numVal += arr_funcval[int_ofs++] << 16;
          numVal += arr_funcval[int_ofs++] << 24;
          if (funcValType == PUBVAL_C_LONG) {
            return String(Math.round(numVal));
          } else {
            buffer = String(Math.round(numVal * 1e3) / 1e6);
            endp = buffer.length;
            while (endp > 0 && buffer[endp - 1] == "0") {
              --endp;
            }
            if (endp > 0 && buffer[endp - 1] == ".") {
              --endp;
              buffer = buffer.substr(0, endp);
            }
            return buffer;
          }
        case PUBVAL_C_FLOAT:
          let v = arr_funcval[int_ofs++];
          v += arr_funcval[int_ofs++] << 8;
          v += arr_funcval[int_ofs++] << 16;
          v += arr_funcval[int_ofs++] << 24;
          let fraction = (v & (1 << 23) - 1) + (1 << 23) * (v >>> 31 | 1);
          let exp = (v >>> 23 & 255) - 127;
          let floatVal = fraction * Math.pow(2, exp - 23);
          buffer = String(Math.round(floatVal * 1e6) / 1e6);
          endp = buffer.length;
          while (endp > 0 && buffer[endp - 1] == "0") {
            --endp;
          }
          if (endp > 0 && buffer[endp - 1] == ".") {
            --endp;
            buffer = buffer.substr(0, endp);
          }
          return buffer;
        default:
          return "?";
      }
      let len = 0;
      buffer = "";
      while (len < YOCTO_PUBVAL_SIZE && len < int_funcvalen) {
        if (arr_funcval[len] == 0) {
          break;
        }
        buffer += String.fromCharCode(arr_funcval[len]);
        len++;
      }
    }
    return buffer;
  }
  imm_decExp(int_pow) {
    const arr = [
      1e-6,
      1e-5,
      1e-4,
      1e-3,
      0.01,
      0.1,
      1,
      10,
      100,
      1e3,
      1e4,
      1e5,
      1e6,
      1e7,
      1e8,
      1e9
    ];
    return arr[int_pow];
  }
  // Convert Yoctopuce 16-bit decimal floats to standard double-precision floats
  //
  imm_decimalToDouble(val) {
    let negate = false;
    let res;
    let mantis = val & 2047;
    if (mantis == 0)
      return 0;
    if (val > 32767) {
      negate = true;
      val = 65536 - val;
    } else if (val < 0) {
      negate = true;
      val = -val;
    }
    let decexp = this.imm_decExp(val >>> 11);
    if (decexp >= 1) {
      res = mantis * decexp;
    } else {
      res = mantis / Math.round(1 / decexp);
    }
    return negate ? -res : res;
  }
  // Convert standard double-precision floats to Yoctopuce 16-bit decimal floats
  //
  imm_doubleToDecimal(val) {
    let negate = false;
    let comp, mant;
    let decpow;
    let res;
    if (val == 0) {
      return 0;
    }
    if (val < 0) {
      negate = true;
      val = -val;
    }
    comp = val / 1999;
    decpow = 0;
    while (comp > this.imm_decExp(decpow) && decpow < 15) {
      decpow++;
    }
    mant = val / this.imm_decExp(decpow);
    if (decpow == 15 && mant > 2047) {
      res = (15 << 11) + 2047;
    } else {
      res = (decpow << 11) + Math.round(mant);
    }
    return negate ? -res : res;
  }
  imm_getCalibrationHandler(calibType) {
    return this._calibHandlers[calibType];
  }
  // Parse an array of u16 encoded in a base64-like string with memory-based compression
  imm_decodeWords(data) {
    let udata = [];
    for (let i = 0; i < data.length; ) {
      let c = data[i];
      let val = 0;
      if (c == "*") {
        i++;
      } else if (c == "X") {
        val = 65535;
        i++;
      } else if (c == "Y") {
        val = 32767;
        i++;
      } else if (c >= "a") {
        let srcpos = udata.length - 1 - (data.charCodeAt(i++) - 97);
        if (srcpos >= 0) {
          val = udata[srcpos];
        }
      } else {
        if (i + 3 > data.length) {
          return udata;
        }
        val = data.charCodeAt(i++) - 48;
        val += data.charCodeAt(i++) - 48 << 5;
        let lastcode = data.charCodeAt(i++);
        if (lastcode == 122)
          lastcode = 92;
        val += lastcode - 48 << 10;
      }
      udata.push(val);
    }
    return udata;
  }
  // Parse an array of u16 encoded in a base64-like string with memory-based compresssion
  imm_decodeFloats(data) {
    let idata = [];
    let p = 0;
    let datalen = data.length;
    while (p < datalen) {
      let val = 0;
      let sign = 1;
      let dec = 0;
      let decInc = 0;
      let c = data[p++];
      while (c != "-" && (c < "0" || c > "9")) {
        if (p >= datalen) {
          return idata;
        }
        c = data[p++];
      }
      if (c == "-") {
        if (p >= datalen) {
          return idata;
        }
        sign = -sign;
        c = data[p++];
      }
      while (c >= "0" && c <= "9" || c == ".") {
        if (c == ".") {
          decInc = 1;
        } else if (dec < 3) {
          val = val * 10 + (c.charCodeAt(0) - 48);
          dec += decInc;
        }
        if (p < datalen) {
          c = data[p++];
        } else {
          c = "\0";
        }
      }
      if (dec < 3) {
        if (dec == 0) {
          val *= 1e3;
        } else if (dec == 1) {
          val *= 100;
        } else {
          val *= 10;
        }
      }
      idata.push(sign * val);
    }
    return idata;
  }
  /** Convert a numeric string to an integer
   */
  static imm_atoi(str_data) {
    let num = parseInt(str_data);
    if (isNaN(num)) {
      return 0;
    }
    return Math.floor(num);
  }
  /** Convert a numeric string to an float
   */
  static imm_atof(str_data) {
    let num = parseFloat(str_data);
    if (isNaN(num)) {
      return 0;
    }
    return num;
  }
  /** Convert a binary object to string
   */
  imm_bin2str(bin_data) {
    let len = bin_data.length;
    let res = "";
    for (let i = 0; i < len; i += 20) {
      let subdata = bin_data.subarray(i, Math.min(i + 20, len));
      res += String.fromCharCode.apply(null, Array.from(subdata));
    }
    return res;
  }
  /** Convert a string to binary object
   */
  imm_str2bin(str_data) {
    let len = str_data.length;
    let res = new Uint8Array(len);
    for (let i = 0; i < len; i++) {
      res[i] = str_data.charCodeAt(i);
    }
    return res;
  }
  /** Convert a binary object to hex string
   */
  imm_bin2hexstr(bin_data) {
    let len = bin_data.length;
    let res = "";
    for (let i = 0; i < len; i++) {
      let n = bin_data[i].toString(16);
      res += n.length < 2 ? "0" + n : n;
    }
    return res.toUpperCase();
  }
  /** Compute the 32-bit CRC of a binary object
   */
  imm_bincrc(bin_data, ofs, size) {
    let table = this._crcTable;
    if (!table) {
      table = new Int32Array(256);
      for (let i = 0; i < 256; i++) {
        let crc2 = i;
        for (let bit = 0; bit < 8; bit++) {
          crc2 = crc2 & 1 ? 3988292384 ^ crc2 >>> 1 : crc2 >>> 1;
        }
        table[i] = crc2;
      }
      this._crcTable = table;
    }
    let end = ofs + size;
    let crc = -1;
    while (ofs < end) {
      crc = crc >>> 8 ^ table[(crc ^ bin_data[ofs]) & 255];
      ofs++;
    }
    return crc ^ -1;
  }
  /** Convert a hex string to binary object
   */
  imm_hexstr2bin(str_data) {
    let len = str_data.length >>> 1;
    let res = new Uint8Array(len);
    for (let i = 0; i < len; i++) {
      res[i] = parseInt(str_data.substr(2 * i, 2), 16);
    }
    return res;
  }
  /** Return a Device object for a specified URL, serial number or logical device name
   *
   * This function will not cause any network access (not async !)
   */
  imm_getDevice(str_device) {
    let dev = null;
    let serial;
    if (str_device.substr(0, 7) == "http://" || str_device.substr(0, 5) == "ws://" || str_device.substr(0, 8) == "https://" || str_device.substr(0, 6) == "wss://") {
      serial = this._snByUrl[str_device];
      if (serial != void 0)
        dev = this._devs[serial];
    } else {
      if (this._devs[str_device]) {
        dev = this._devs[str_device];
      } else {
        serial = this._snByName[str_device];
        if (serial) {
          dev = this._devs[serial];
        }
      }
    }
    return dev;
  }
  /** Add or remove a value change callback
   */
  async _UpdateValueCallbackList(obj_func, bool_add) {
    let index = this._ValueCallbackList.indexOf(obj_func);
    if (bool_add) {
      await obj_func.isOnline();
      if (index < 0) {
        this._ValueCallbackList.push(obj_func);
      }
    } else if (index >= 0) {
      this._ValueCallbackList.splice(index, 1);
    }
  }
  /** Add or remove a timed report callback
   */
  async _UpdateTimedReportCallbackList(obj_func, bool_add) {
    let index = this._TimedReportCallbackList.indexOf(obj_func);
    if (bool_add) {
      await obj_func.isOnline();
      if (index < 0) {
        this._TimedReportCallbackList.push(obj_func);
      }
    } else if (index >= 0) {
      this._TimedReportCallbackList.splice(index, 1);
    }
  }
  // Return the class name for a given function ID or full Hardware Id
  // Also make sure that the function type is registered in the API
  imm_functionClass(str_funcid) {
    let dotpos = str_funcid.indexOf(".");
    if (dotpos >= 0)
      str_funcid = str_funcid.substr(dotpos + 1);
    let classlen = str_funcid.length;
    while (str_funcid.substr(classlen - 1, 1) <= "9") {
      classlen--;
    }
    let classname = str_funcid.substr(0, 1).toUpperCase() + str_funcid.substr(1, classlen - 1);
    if (this._fnByType[classname] == void 0) {
      this._fnByType[classname] = new YFunctionType(this, classname);
    }
    return classname;
  }
  // Reindex a device in YAPI after a name change detected by device refresh
  imm_reindexDevice(obj_dev) {
    let rootUrl = obj_dev.imm_getRootUrl();
    let serial = obj_dev.imm_getSerialNumber();
    let lname = obj_dev.imm_getLogicalName();
    this._devs[serial] = obj_dev;
    this._snByUrl[rootUrl] = serial;
    if (lname != "")
      this._snByName[lname] = serial;
    this._fnByType["Module"].imm_reindexFunction(serial + ".module", lname, null, null);
    let i, count = obj_dev.imm_functionCount();
    for (i = 0; i < count; i++) {
      let funcid = obj_dev.imm_functionId(i);
      if (funcid != "") {
        let funcname = obj_dev.imm_functionName(i);
        let classname = this.imm_functionClass(funcid);
        this._fnByType[classname].imm_reindexFunction(serial + "." + funcid, funcname, null, null);
      }
    }
  }
  // Remove a device from YAPI after an unplug detected by device refresh
  imm_forgetDevice(obj_dev) {
    let rootUrl = obj_dev.imm_getRootUrl();
    let serial = obj_dev.imm_getSerialNumber();
    let lname = obj_dev.imm_getLogicalName();
    delete this._devs[serial];
    delete this._snByUrl[rootUrl];
    if (this._snByName[lname] == serial) {
      delete this._snByName[lname];
    }
    this._fnByType["Module"].imm_forgetFunction(serial + ".module");
    let i, count = obj_dev.imm_functionCount();
    for (i = 0; i < count; i++) {
      let funcid = obj_dev.imm_functionId(i);
      if (funcid != "") {
        let classname = this.imm_functionClass(funcid);
        this._fnByType[classname].imm_forgetFunction(serial + "." + funcid);
      }
    }
  }
  // Find the best known identifier (hardware Id) for a given function
  imm_resolveFunction(str_className, str_func) {
    if (Y_BASETYPES[str_className] == void 0) {
      if (this._fnByType[str_className] == void 0) {
        this._fnByType[str_className] = new YFunctionType(this, str_className);
      }
      return this._fnByType[str_className].imm_resolve(str_func);
    }
    let baseType = Y_BASETYPES[str_className];
    let res;
    for (str_className in this._fnByType) {
      if (this._fnByType[str_className].imm_matchBaseType(baseType)) {
        res = this._fnByType[str_className].imm_resolve(str_func);
        if (res.errorType == YAPI_SUCCESS)
          return res;
      }
    }
    return {
      errorType: YAPI_DEVICE_NOT_FOUND,
      errorMsg: "No " + str_className + " [" + str_func + "] found (old firmware?)"
    };
  }
  // Find the best known identifier (hardware Id) for a given function
  imm_getFriendlyNameFunction(str_className, str_func) {
    if (Y_BASETYPES[str_className] == void 0) {
      if (this._fnByType[str_className] == void 0) {
        this._fnByType[str_className] = new YFunctionType(this, str_className);
      }
      return this._fnByType[str_className].imm_getFriendlyName(str_func);
    }
    let baseType = Y_BASETYPES[str_className];
    let res;
    for (str_className in this._fnByType) {
      if (this._fnByType[str_className].imm_matchBaseType(baseType)) {
        res = this._fnByType[str_className].imm_getFriendlyName(str_func);
        if (res.errorType == YAPI_SUCCESS)
          return res;
      }
    }
    return {
      errorType: YAPI_DEVICE_NOT_FOUND,
      errorMsg: "No " + str_className + " [" + str_func + "] found (old firmware?)"
    };
  }
  // Retrieve a function object by hardware id, updating the indexes on the fly if needed
  imm_setFunction(str_className, str_func, obj_func) {
    if (this._fnByType[str_className] == void 0) {
      this._fnByType[str_className] = new YFunctionType(this, str_className);
    }
    this._fnByType[str_className].imm_setFunction(str_func, obj_func);
  }
  // Retrieve a function object by hardware id, updating the indexes on the fly if needed
  imm_getFunction(str_className, str_func) {
    if (this._fnByType[str_className] == void 0) {
      this._fnByType[str_className] = new YFunctionType(this, str_className);
    }
    return this._fnByType[str_className].imm_getFunction(str_func);
  }
  // Set a function advertised value by hardware id
  async setFunctionValue(str_hwid, str_pubval) {
    let classname = this.imm_functionClass(str_hwid);
    if (this._fnByType[classname].imm_setFunctionValue(str_hwid, str_pubval)) {
      let receivers = this._ValueCallbackList;
      for (let i = 0; i < receivers.length; i++) {
        let fun = receivers[i];
        if (!fun._hwId)
          continue;
        if (fun._hwId == str_hwid) {
          await fun._invokeValueCallback(str_pubval);
        }
      }
    }
  }
  // Set a timed value report for a function
  async setTimedReport(str_hwid, float_timestamp, float_duration, arr_report) {
    let classname = this.imm_functionClass(str_hwid);
    let receivers = this._TimedReportCallbackList;
    for (let i = 0; i < receivers.length; i++) {
      let fun = receivers[i];
      if (!fun._hwId)
        continue;
      if (fun._hwId == str_hwid) {
        let dev = this.imm_getDevice(fun._serial);
        if (dev) {
          let sensor = fun;
          let report = await sensor._decodeTimedReport(float_timestamp, float_duration, arr_report);
          await sensor._invokeTimedReportCallback(report);
        }
      }
    }
  }
  // Publish a configuration change event
  async setConfChange(str_serial) {
    let module = YModule.FindModuleInContext(this, str_serial + ".module");
    await module._invokeConfigChangeCallback();
  }
  // Publish a beacon change event
  async setBeaconChange(str_serial, int_beacon) {
    if (this._beacons[str_serial] === void 0 || this._beacons[str_serial] != int_beacon) {
      this._beacons[str_serial] = int_beacon;
      let dev = this.imm_getDevice(str_serial);
      if (dev) {
        dev._beacon = int_beacon;
      }
      let module = YModule.FindModuleInContext(this, str_serial + ".module");
      await module._invokeBeaconCallback(int_beacon);
    }
  }
  // Retrieve a function advertised value by hardware id
  imm_getFunctionValue(str_hwid) {
    let classname = this.imm_functionClass(str_hwid);
    return this._fnByType[classname].imm_getFunctionValue(str_hwid);
  }
  // Retrieve a function advertised value by hardware id
  imm_getFunctionBaseType(str_hwid) {
    let classname = this.imm_functionClass(str_hwid);
    return this._fnByType[classname].imm_getBaseType();
  }
  // Find the hardwareId for the first instance of a given function class
  imm_getFirstHardwareId(str_className) {
    if (Y_BASETYPES[str_className] == void 0) {
      if (this._fnByType[str_className] == void 0) {
        this._fnByType[str_className] = new YFunctionType(this, str_className);
      }
      return this._fnByType[str_className].imm_getFirstHardwareId();
    }
    let baseType = Y_BASETYPES[str_className];
    let res;
    for (str_className in this._fnByType) {
      if (this._fnByType[str_className].imm_matchBaseType(baseType)) {
        res = this._fnByType[str_className].imm_getFirstHardwareId();
        if (res)
          return res;
      }
    }
    return null;
  }
  // Find the hardwareId for the next instance of a given function class
  imm_getNextHardwareId(str_className, str_hwid) {
    if (Y_BASETYPES[str_className] == void 0) {
      return this._fnByType[str_className].imm_getNextHardwareId(str_hwid);
    }
    let baseType = Y_BASETYPES[str_className];
    let prevclass = this.imm_functionClass(str_hwid);
    let res = this._fnByType[prevclass].imm_getNextHardwareId(str_hwid);
    if (res)
      return res;
    for (str_className in this._fnByType) {
      if (prevclass != "") {
        if (str_className != prevclass)
          continue;
        prevclass = "";
        continue;
      }
      if (this._fnByType[str_className].imm_matchBaseType(baseType)) {
        res = this._fnByType[str_className].imm_getFirstHardwareId();
        if (res)
          return res;
      }
    }
    return null;
  }
  /** Perform an HTTP request on a device, by URL or identifier.
   * When loading the REST API from a device by identifier, the device cache will be used.
   */
  async devRequest(str_device, str_request, obj_body = null, int_tcpchan = 0) {
    let lines = str_request.split("\n");
    let res = new YHTTPRequest(null);
    let lockdev = null;
    let baseUrl;
    if (str_device.substr(0, 7) == "http://" || str_device.substr(0, 5) == "ws://" || str_device.substr(0, 8) == "https://" || str_device.substr(0, 6) == "wss://" || str_device.substr(0, 9) == "secure://" || str_device.substr(0, 7) == "auto://") {
      baseUrl = str_device;
      if (baseUrl.slice(-1) != "/")
        baseUrl = baseUrl + "/";
      if (lines[0].substr(0, 12) != "GET /not.byn") {
        let serial = this._snByUrl[baseUrl];
        if (serial) {
          lockdev = this._devs[serial];
        }
      }
    } else {
      lockdev = this.imm_getDevice(str_device);
      if (!lockdev) {
        res.errorType = YAPI_DEVICE_NOT_FOUND;
        res.errorMsg = "Device [" + str_device + "] not online";
        return res;
      }
      if (lines[0] == "GET /api.json") {
        return lockdev.requestAPI(this.defaultCacheValidity);
      }
      baseUrl = lockdev.imm_getRootUrl();
    }
    let words = lines[0].split(" ");
    if (words.length < 2) {
      res.errorType = YAPI_INVALID_ARGUMENT;
      res.errorMsg = "Invalid request, not enough words; expected a method name and a URL";
      return res;
    } else if (words.length > 2) {
      res.errorType = YAPI_INVALID_ARGUMENT;
      res.errorMsg = "Invalid request, too many words; make sure the URL is URI-encoded";
      return res;
    }
    let hub = null;
    for (let i = 0; i < this._connectedHubs.length; i++) {
      let hubUrl = this._connectedHubs[i].imm_getRootUrl();
      if (baseUrl.slice(0, hubUrl.length) == hubUrl) {
        hub = this._connectedHubs[i];
        break;
      }
    }
    if (!hub && this._knownHubsByUrl[str_device]) {
      hub = this._knownHubsByUrl[str_device];
    }
    if (!hub) {
      res.errorType = YAPI_DEVICE_NOT_FOUND;
      res.errorMsg = "No hub found for URL " + baseUrl;
      return res;
    }
    let method = words[0];
    let devUrl = words[1];
    if (devUrl.substr(0, 1) == "/")
      devUrl = devUrl.substr(1);
    if (baseUrl.substr(0, hub.imm_getRootUrl().length) == hub.imm_getRootUrl()) {
      devUrl = baseUrl.substr(hub.imm_getRootUrl().length - 1) + devUrl;
    } else {
      let pos = baseUrl.indexOf("//");
      pos = baseUrl.indexOf("/", pos + 3);
      devUrl = baseUrl.slice(pos) + devUrl;
    }
    if (devUrl.slice(-2) == "&." && !await hub.hasRwAccess()) {
      res.errorType = YAPI_UNAUTHORIZED;
      res.errorMsg = "Access denied: admin credentials required";
      return res;
    }
    let delayedCode = function delayedRequest() {
      return hub.request(method, devUrl, obj_body, int_tcpchan).catch((e) => {
        let res2 = new YHTTPRequest(null);
        res2.errorType = YAPI_IO_ERROR;
        res2.errorMsg = e.message;
        return res2;
      });
    };
    if (lockdev && int_tcpchan == 0) {
      let newPromise = lockdev._pendingQueries.then(delayedCode, delayedCode);
      lockdev._pendingQueries = newPromise;
      res = await newPromise;
    } else {
      res = await delayedCode();
    }
    return res;
  }
  async isReadOnly(str_device) {
    let lockdev = this.imm_getDevice(str_device);
    if (!lockdev) {
      return true;
    }
    let baseUrl = lockdev.imm_getRootUrl();
    let hub = null;
    for (let i = 0; i < this._connectedHubs.length; i++) {
      let hubUrl = this._connectedHubs[i].imm_getRootUrl();
      if (baseUrl.slice(0, hubUrl.length) == hubUrl) {
        hub = this._connectedHubs[i];
        break;
      }
    }
    if (!hub || !await hub.hasRwAccess()) {
      return true;
    }
    return false;
  }
  /** Locate the device to access a specified function, without causing any I/O
   */
  imm_funcDev_internal(str_className, str_func) {
    let res = new YFuncRequest(null);
    let resolve = this.imm_resolveFunction(str_className, str_func);
    if (resolve.errorType != YAPI_SUCCESS) {
      res.errorType = resolve.errorType;
      res.errorMsg = resolve.errorMsg;
    } else {
      str_func = resolve.result;
      let dotpos = str_func.indexOf(".");
      let devid = str_func.substr(0, dotpos);
      let funcid = str_func.substr(dotpos + 1);
      let dev = this.imm_getDevice(devid);
      if (dev == null) {
        res.errorType = YAPI_DEVICE_NOT_FOUND;
        res.errorMsg = "Device [" + devid + "] not found";
      } else {
        res.obj_result = { _expiration: -1, device: dev, deviceid: devid, functionid: funcid, hwid: str_func };
      }
    }
    return res;
  }
  /** Locate the device to access a specified function. May cause device list update if needed
   */
  async _funcDev(str_className, str_func) {
    let res = this.imm_funcDev_internal(str_className, str_func);
    if (res.errorType == YAPI_SUCCESS) {
      return res;
    } else if (res.errorType == YAPI_DEVICE_NOT_FOUND && this._connectedHubs.length == 0) {
      res.errorMsg = "Impossible to contact any device because no hub has been registered";
      return res;
    }
    let updRes = await this._updateDeviceList_internal(true, false);
    if (updRes.errorType != YAPI_SUCCESS) {
      res.errorType = updRes.errorType;
      res.errorMsg = updRes.errorMsg;
      return res;
    }
    return this.imm_funcDev_internal(str_className, str_func);
  }
  /** Load and parse the REST API for a function given by class name and identifier, possibly applying changes
   * Device cache will be preloaded when loading function 'module' and leveraged for other modules
   */
  async funcRequest(str_className, str_func, str_extra, int_msValidity = 0) {
    let funcreq = this.imm_funcDev_internal(str_className, str_func);
    if (funcreq.errorType != YAPI_SUCCESS) {
      funcreq = await this._funcDev(str_className, str_func);
      if (funcreq.errorType != YAPI_SUCCESS) {
        return funcreq;
      }
    }
    let devreq = funcreq.obj_result;
    let loadval = null;
    if (str_extra == "") {
      let yreq = await devreq.device.requestAPI(int_msValidity);
      if (yreq != null) {
        if (yreq.errorType != YAPI_SUCCESS || !yreq.obj_result) {
          let res = new YFuncRequest(null);
          res.errorType = yreq.errorType;
          res.errorMsg = yreq.errorMsg;
          return res;
        }
        loadval = yreq.obj_result[devreq.functionid];
      }
    } else {
      devreq.device.imm_dropCache();
    }
    if (!loadval) {
      if (str_extra == "")
        str_extra = ".json";
      let httpreq = "GET /api/" + devreq.functionid + str_extra;
      let yreq = await this.devRequest(devreq.deviceid, httpreq, null, 0);
      if (yreq.errorType != YAPI_SUCCESS)
        return yreq;
      let replyBuff = yreq.bin_result;
      if (replyBuff.length == 0 && httpreq.indexOf("?") >= 0) {
        funcreq.obj_result = null;
        return funcreq;
      }
      try {
        loadval = JSON.parse(this.imm_bin2str(replyBuff));
      } catch (err) {
      }
    }
    if (!loadval) {
      funcreq.errorType = YAPI_IO_ERROR;
      funcreq.errorMsg = "Request failed, could not parse API value for function " + devreq.hwid;
    } else {
      for (let key in devreq) {
        loadval[key] = devreq[key];
      }
      funcreq.obj_result = loadval;
    }
    return funcreq;
  }
  /** Perform an HTTP request on a device and return the result string
   */
  async HTTPRequest(str_device, str_request) {
    let yreq = await this.devRequest(str_device, str_request, null, 0);
    if (yreq.errorType != YAPI_SUCCESS) {
      return this._throw(yreq.errorType, yreq.errorMsg, null);
    }
    return yreq.bin_result;
  }
  async ForceDeviceRefresh(str_device) {
    let dev = this.imm_getDevice(str_device);
    if (!dev)
      return YAPI_DEVICE_NOT_FOUND;
    let rootUrl = dev.imm_getRootUrl();
    for (let i = 0; i < this._connectedHubs.length; i++) {
      let hub = this._connectedHubs[i];
      let hubUrl = hub.urlInfo.imm_getRootUrl();
      if (rootUrl.substr(0, hubUrl.length) === hubUrl) {
        let hubDev = this.imm_getDevice(hubUrl);
        hubDev.imm_dropCache();
        let retcode = await hubDev.refresh();
        if (retcode != YAPI_SUCCESS) {
          return this._throw(retcode, hubDev._lastErrorMsg, retcode);
        }
        let yreq = await hubDev.requestAPI(this.defaultCacheValidity);
        if (yreq.errorType != YAPI_SUCCESS) {
          return yreq.errorType;
        }
        let yellowPages = yreq.obj_result["services"]["yellowPages"];
        dev.imm_updateFromYP(yellowPages);
      }
    }
    dev.imm_dropCache();
    return YAPI_SUCCESS;
  }
  async SetDeviceListValidity_internal(deviceListValidity) {
    this._deviceListValidityMs = deviceListValidity * 1e3;
  }
  async GetDeviceListValidity_internal() {
    return this._deviceListValidityMs / 1e3 >> 0;
  }
  async SetNetworkTimeout_internal(networkMsTimeout) {
    this._networkTimeoutMs = networkMsTimeout;
  }
  async GetNetworkTimeout_internal() {
    return this._networkTimeoutMs;
  }
  async GetYAPISharedLibraryPath_internal() {
    return "";
  }
  async AddUdevRule_internal(force) {
    return "error: Not supported in TypeScript";
  }
  async DownloadHostCertificate_internal(url, mstimeout) {
    return await this.system_env.downloadRemoteCertificate(new _YY_UrlInfo(url));
  }
  async SetTrustedCertificatesList_internal(certificatePath) {
    return "error: Not supported in TypeScript";
  }
  async SetNetworkSecurityOptions_internal(opts) {
    this._networkSecurityOptions = opts;
    return "";
  }
  async AddTrustedCertificates_internal(certificate) {
    this._trustedCertificate.push(certificate);
    return "";
  }
  imm_updateRegisteredHubs(hub, add) {
    let i;
    for (i = 0; i < this._registeredHubs.length; i++) {
      if (this._registeredHubs[i] === hub) {
        if (!add) {
          if (this._logLevel >= 4) {
            this.imm_log("Unlisting registered hub: " + hub.imm_getOriginalURL());
          }
          this._registeredHubs.splice(i, 1);
        }
        return;
      }
    }
    if (add) {
      if (this._logLevel >= 4) {
        this.imm_log("Adding registered hub: " + hub.imm_getOriginalURL());
      }
      this._registeredHubs.push(hub);
    } else {
      if (this._logLevel >= 4) {
        this.imm_log("Could not unlist registered hub: " + hub.imm_getOriginalURL());
        for (i = 0; i < this._registeredHubs.length; i++) {
          this.imm_log("- " + this._registeredHubs[i].imm_getOriginalURL());
        }
      }
    }
  }
  //--- (generated code: YAPIContext implementation)
  /**
   * Modifies the delay between each forced enumeration of the used YoctoHubs.
   * By default, the library performs a full enumeration every 10 seconds.
   * To reduce network traffic, you can increase this delay.
   * It's particularly useful when a YoctoHub is connected to the GSM network
   * where traffic is billed. This parameter doesn't impact modules connected by USB,
   * nor the working of module arrival/removal callbacks.
   * Note: you must call this function after yInitAPI.
   *
   * @param deviceListValidity : nubmer of seconds between each enumeration.
   * @noreturn
   */
  async SetDeviceListValidity(deviceListValidity) {
    return await this.SetDeviceListValidity_internal(deviceListValidity);
  }
  /**
   * Returns the delay between each forced enumeration of the used YoctoHubs.
   * Note: you must call this function after yInitAPI.
   *
   * @return the number of seconds between each enumeration.
   */
  async GetDeviceListValidity() {
    return await this.GetDeviceListValidity_internal();
  }
  /**
   * Returns the path to the dynamic YAPI library. This function is useful for debugging problems loading the
   * dynamic library YAPI. This function is supported by the C#, Python and VB languages. The other
   * libraries return an
   * empty string.
   *
   * @return a string containing the path of the YAPI dynamic library.
   */
  async GetYAPISharedLibraryPath() {
    return await this.GetYAPISharedLibraryPath_internal();
  }
  /**
   * Adds a UDEV rule which authorizes all users to access Yoctopuce modules
   * connected to the USB ports. This function works only under Linux. The process that
   * calls this method must have root privileges because this method changes the Linux configuration.
   *
   * @param force : if true, overwrites any existing rule.
   *
   * @return an empty string if the rule has been added.
   *
   * On failure, returns a string that starts with "error:".
   */
  async AddUdevRule(force) {
    return await this.AddUdevRule_internal(force);
  }
  /**
   * Download the TLS/SSL certificate from the hub. This function allows to download a TLS/SSL certificate to add it
   * to the list of trusted certificates using the AddTrustedCertificates method.
   *
   * @param url : the root URL of the VirtualHub V2 or HTTP server.
   * @param mstimeout : the number of milliseconds available to download the certificate.
   *
   * @return a string containing the certificate. In case of error, returns a string starting with "error:".
   */
  async DownloadHostCertificate(url, mstimeout) {
    return await this.DownloadHostCertificate_internal(url, mstimeout);
  }
  /**
   * Adds a TLS/SSL certificate to the list of trusted certificates. By default, the library
   * library will reject TLS/SSL connections to servers whose certificate is not known. This function
   * function allows to add a list of known certificates. It is also possible to disable the verification
   * using the SetNetworkSecurityOptions method.
   *
   * @param certificate : a string containing one or more certificates.
   *
   * @return an empty string if the certificate has been added correctly.
   *         In case of error, returns a string starting with "error:".
   */
  async AddTrustedCertificates(certificate) {
    return await this.AddTrustedCertificates_internal(certificate);
  }
  /**
   * Set the path of Certificate Authority file on local filesystem. This method takes as a parameter
   * the path of a file containing all certificates in PEM format.
   * For technical reasons, only one file can be specified. So if you need to connect to several Hubs
   * instances with self-signed certificates, you'll need to use
   * a single file containing all the certificates end-to-end. Passing a empty string will restore the
   * default settings. This option is only supported by PHP library.
   *
   * @param certificatePath : the path of the file containing all certificates in PEM format.
   *
   * @return an empty string if the certificate has been added correctly.
   *         In case of error, returns a string starting with "error:".
   */
  async SetTrustedCertificatesList(certificatePath) {
    return await this.SetTrustedCertificatesList_internal(certificatePath);
  }
  /**
   * Enables or disables certain TLS/SSL certificate checks.
   *
   * @param opts : The options are YAPI.NO_TRUSTED_CA_CHECK,
   *         YAPI.NO_EXPIRATION_CHECK, YAPI.NO_HOSTNAME_CHECK.
   *
   * @return an empty string if the options are taken into account.
   *         On error, returns a string beginning with "error:".
   */
  async SetNetworkSecurityOptions(opts) {
    return await this.SetNetworkSecurityOptions_internal(opts);
  }
  /**
   * Modifies the network connection delay for yRegisterHub() and yUpdateDeviceList().
   * This delay impacts only the YoctoHubs and VirtualHub
   * which are accessible through the network. By default, this delay is of 20000 milliseconds,
   * but depending on your network you may want to change this delay,
   * gor example if your network infrastructure is based on a GSM connection.
   *
   * @param networkMsTimeout : the network connection delay in milliseconds.
   * @noreturn
   */
  async SetNetworkTimeout(networkMsTimeout) {
    return await this.SetNetworkTimeout_internal(networkMsTimeout);
  }
  /**
   * Returns the network connection delay for yRegisterHub() and yUpdateDeviceList().
   * This delay impacts only the YoctoHubs and VirtualHub
   * which are accessible through the network. By default, this delay is of 20000 milliseconds,
   * but depending on your network you may want to change this delay,
   * for example if your network infrastructure is based on a GSM connection.
   *
   * @return the network connection delay in milliseconds.
   */
  async GetNetworkTimeout() {
    return await this.GetNetworkTimeout_internal();
  }
  /**
   * Change the validity period of the data loaded by the library.
   * By default, when accessing a module, all the attributes of the
   * module functions are automatically kept in cache for the standard
   * duration (5 ms). This method can be used to change this standard duration,
   * for example in order to reduce network or USB traffic. This parameter
   * does not affect value change callbacks
   * Note: This function must be called after yInitAPI.
   *
   * @param cacheValidityMs : an integer corresponding to the validity attributed to the
   *         loaded function parameters, in milliseconds.
   * @noreturn
   */
  async SetCacheValidity(cacheValidityMs) {
    this.defaultCacheValidity = cacheValidityMs;
  }
  /**
   * Returns the validity period of the data loaded by the library.
   * This method returns the cache validity of all attributes
   * module functions.
   * Note: This function must be called after yInitAPI .
   *
   * @return an integer corresponding to the validity attributed to the
   *         loaded function parameters, in milliseconds
   */
  async GetCacheValidity() {
    return this.defaultCacheValidity;
  }
  nextHubInUseInternal(hubref) {
    return this.nextHubInUseInternal_internal(hubref);
  }
  getYHubObj(hubref) {
    let obj;
    obj = this._findYHubFromCache(hubref);
    if (obj == null) {
      obj = new YHub(this, hubref);
      this._addYHubToCache(hubref, obj);
    }
    return obj;
  }
  async findYHubFromID(id) {
    let rhub;
    rhub = this.nextHubInUseInternal(-1);
    while (!(rhub == null)) {
      if (await rhub.get_serialNumber() == id) {
        return rhub;
      }
      if (await rhub.get_registeredUrl() == id) {
        return rhub;
      }
      rhub = rhub.nextHubInUse();
    }
    return rhub;
  }
  //--- (end of generated code: YAPIContext implementation)
  /**
   * Returns the version identifier for the Yoctopuce library in use.
   * The version is a string in the form "Major.Minor.Build",
   * for instance "1.01.5535". For languages using an external
   * DLL (for instance C#, VisualBasic or Delphi), the character string
   * includes as well the DLL version, for instance
   * "1.01.5535 (1.01.5439)".
   *
   * If you want to verify in your code that the library version is
   * compatible with the version that you have used during development,
   * verify that the major number is strictly equal and that the minor
   * number is greater or equal. The build number is not relevant
   * with respect to the library compatibility.
   *
   * @return a character string describing the library version.
   */
  async GetAPIVersion() {
    return this.imm_GetAPIVersion();
  }
  imm_GetAPIVersion() {
    return (
      /* version number patched automatically */
      "2.1.10214"
    );
  }
  /**
   * Initializes the Yoctopuce programming library explicitly.
   * It is not strictly needed to call yInitAPI(), as the library is
   * automatically  initialized when calling yRegisterHub() for the
   * first time.
   *
   * When YAPI.DETECT_NONE is used as detection mode,
   * you must explicitly use yRegisterHub() to point the API to the
   * VirtualHub on which your devices are connected before trying to access them.
   *
   * @param mode : an integer corresponding to the type of automatic
   *         device detection to use. Possible values are
   *         YAPI.DETECT_NONE, YAPI.DETECT_USB, YAPI.DETECT_NET,
   *         and YAPI.DETECT_ALL.
   * @param errmsg : a string passed by reference to receive any error message.
   *
   * @return YAPI.SUCCESS when the call succeeds.
   *
   * On failure returns a negative error code.
   */
  async InitAPI(mode, errmsg) {
    this._detectType = mode;
    if (this.system_env.hasSSDP) {
      if ((mode & this.DETECT_NET) !== 0) {
        await this.TriggerHubDiscovery();
      }
    } else {
    }
    return YAPI_SUCCESS;
  }
  /**
   * Waits for all pending communications with Yoctopuce devices to be
   * completed then frees dynamically allocated resources used by
   * the Yoctopuce library.
   *
   * From an operating system standpoint, it is generally not required to call
   * this function since the OS will automatically free allocated resources
   * once your program is completed. However, there are two situations when
   * you may really want to use that function:
   *
   * - Free all dynamically allocated memory blocks in order to
   * track a memory leak.
   *
   * - Send commands to devices right before the end
   * of the program. Since commands are sent in an asynchronous way
   * the program could exit before all commands are effectively sent.
   *
   * You should not call any other library function after calling
   * yFreeAPI(), or your program will crash.
   */
  async FreeAPI() {
    for (let serial in this._devs) {
      await this._devs[serial].waitPendingQueries();
    }
    await this.KillAPI();
  }
  /**
   * Abort any ongoing API activity immediately by closing all open hubs. Then
   * frees dynamically allocated memory blocks used by the Yoctopuce library.
   * You should not call any other library function after calling
   * yDropAPI(), or your program will crash.
   */
  async KillAPI() {
    if (this._ssdpManager) {
      await this._ssdpManager.ySSDPStop();
      this._ssdpManager = null;
    }
    for (let hub of this._connectedHubs) {
      this.imm_dropConnectedHub(hub);
    }
    for (let serial in this._knownHubsBySerial) {
      let hub = this._knownHubsBySerial[serial];
      if (hub.imm_getcurrentState() > -5) {
        await hub.detach(YAPI.IO_ERROR, "Connection closed by FreeAPI");
      }
    }
    this.imm_ResetToDefaults();
  }
  /**
   * Disables the use of exceptions to report runtime errors.
   * When exceptions are disabled, every function returns a specific
   * error value which depends on its type and which is documented in
   * this reference manual.
   */
  async DisableExceptions() {
    this.exceptionsDisabled = true;
  }
  /**
   * Re-enables the use of exceptions for runtime error handling.
   * Be aware than when exceptions are enabled, every function that fails
   * triggers an exception. If the exception is not caught by the user code,
   * it either fires the debugger or aborts (i.e. crash) the program.
   */
  async EnableExceptions() {
    this.exceptionsDisabled = false;
  }
  /**
   * Enable logging to the console for unhandled promise rejections,
   * such as exceptions in async functions without a try/catch.
   * This is not really a Yoctopuce thing, but since it is not obvious
   * to find out and since the code differs depending on the environment,
   * we provide it here for convenience.
   */
  async LogUnhandledPromiseRejections() {
    this.system_env.hookUnhandledRejection((reason, promise) => {
      this.imm_log("Unhandled Rejection at: Promise ", promise, " reason: ", reason);
    });
  }
  /**
   * Set up the Yoctopuce library to use modules connected on a given machine. Idealy this
   * call will be made once at the begining of your application.  The
   * parameter will determine how the API will work. Use the following values:
   *
   * <b>usb</b>: When the usb keyword is used, the API will work with
   * devices connected directly to the USB bus. Some programming languages such a JavaScript,
   * PHP, and Java don't provide direct access to USB hardware, so usb will
   * not work with these. In this case, use a VirtualHub or a networked YoctoHub (see below).
   *
   * <b><i>x.x.x.x</i></b> or <b><i>hostname</i></b>: The API will use the devices connected to the
   * host with the given IP address or hostname. That host can be a regular computer
   * running a <i>native VirtualHub</i>, a <i>VirtualHub for web</i> hosted on a server,
   * or a networked YoctoHub such as YoctoHub-Ethernet or
   * YoctoHub-Wireless. If you want to use the VirtualHub running on you local
   * computer, use the IP address 127.0.0.1. If the given IP is unresponsive, yRegisterHub
   * will not return until a time-out defined by ySetNetworkTimeout has elapsed.
   * However, it is possible to preventively test a connection  with yTestHub.
   * If you cannot afford a network time-out, you can use the non-blocking yPregisterHub
   * function that will establish the connection as soon as it is available.
   *
   *
   * <b>callback</b>: that keyword make the API run in "<i>HTTP Callback</i>" mode.
   * This a special mode allowing to take control of Yoctopuce devices
   * through a NAT filter when using a VirtualHub or a networked YoctoHub. You only
   * need to configure your hub to call your server script on a regular basis.
   * This mode is currently available for PHP and Node.JS only.
   *
   * Be aware that only one application can use direct USB access at a
   * given time on a machine. Multiple access would cause conflicts
   * while trying to access the USB modules. In particular, this means
   * that you must stop the VirtualHub software before starting
   * an application that uses direct USB access. The workaround
   * for this limitation is to set up the library to use the VirtualHub
   * rather than direct USB access.
   *
   * If access control has been activated on the hub, virtual or not, you want to
   * reach, the URL parameter should look like:
   *
   * http://username:password@address:port
   *
   * You can call <i>RegisterHub</i> several times to connect to several machines. On
   * the other hand, it is useless and even counterproductive to call <i>RegisterHub</i>
   * with to same address multiple times during the life of the application.
   *
   * @param url : a string containing either "usb","callback" or the
   *         root URL of the hub to monitor
   * @param errmsg : a string passed by reference to receive any error message.
   *
   * @return YAPI.SUCCESS when the call succeeds.
   *
   * On failure returns a negative error code.
   */
  async RegisterHub(url, errmsg) {
    if (this._logLevel >= 4) {
      this.imm_log("Registering hub: " + url);
    }
    if (url === "net") {
      if (this.system_env.hasSSDP) {
        this._detectType |= this.DETECT_NET;
        return this.TriggerHubDiscovery();
      } else {
        return this.imm_setErr(errmsg, YAPI_NOT_SUPPORTED, "Network discovery is not possible in a browser", YAPI_NOT_SUPPORTED);
      }
    }
    if (url === "usb") {
      return this.imm_setErr(errmsg, YAPI_NOT_SUPPORTED, "Use the VirtualHub on 127.0.0.1 to access USB devices", YAPI_NOT_SUPPORTED);
    }
    let urlInfo = new _YY_UrlInfo(url);
    let hub = this.imm_getHub(urlInfo);
    if (!hub) {
      if (this._logLevel >= 3) {
        this.imm_log("Registering new hub: " + urlInfo.imm_getRootUrl());
      }
      hub = new YGenericHub(this, urlInfo);
      hub.imm_addKnownUrl(urlInfo);
      this._knownHubsByUrl[urlInfo.imm_getRootUrl()] = hub;
    } else {
      if (this._logLevel >= 3) {
        this.imm_log("Registering existing hub: " + urlInfo.imm_getRootUrl() + " old=" + hub.imm_getRootUrl());
      }
      hub.imm_updateUrl(urlInfo);
    }
    this.imm_updateRegisteredHubs(hub, true);
    await hub.attach(
      2
      /* Y_YHubConnType.HUB_REGISTERED */
    );
    let sub_errmsg = new YErrorMsg();
    let retcode = await hub.waitForConnection(this._networkTimeoutMs, sub_errmsg);
    if (retcode != YAPI_SUCCESS) {
      this.imm_dropConnectedHub(hub);
      this.imm_updateRegisteredHubs(hub, false);
      await hub.detach(retcode, sub_errmsg.msg);
      hub.imm_forgetUrls();
      return this.imm_setErr(errmsg, retcode, sub_errmsg.msg, retcode);
    }
    let yreq = await this._updateDeviceList_internal(true, false);
    if (yreq.errorType != YAPI_SUCCESS) {
      if (this._logLevel >= 3) {
        this.imm_log("Registering failed with" + yreq.errorType + " (" + yreq.errorMsg + ")");
      }
      this.imm_dropConnectedHub(hub);
      this.imm_updateRegisteredHubs(hub, false);
      await hub.detach(yreq.errorType, yreq.errorMsg);
      hub.imm_forgetUrls();
      return this.imm_setErr(errmsg, yreq.errorType, yreq.errorMsg, yreq.errorType);
    }
    return YAPI_SUCCESS;
  }
  /**
   * Fault-tolerant alternative to yRegisterHub(). This function has the same
   * purpose and same arguments as yRegisterHub(), but does not trigger
   * an error when the selected hub is not available at the time of the function call.
   * If the connexion cannot be established immediately, a background task will automatically
   * perform periodic retries. This makes it possible to register a network hub independently of the current
   * connectivity, and to try to contact it only when a device is actively needed.
   *
   * @param url : a string containing either "usb","callback" or the
   *         root URL of the hub to monitor
   * @param errmsg : a string passed by reference to receive any error message.
   *
   * @return YAPI.SUCCESS when the call succeeds.
   *
   * On failure returns a negative error code.
   */
  async PreregisterHub(url, errmsg) {
    let urlInfo = new _YY_UrlInfo(url);
    let hub = this.imm_getHub(urlInfo);
    if (!hub) {
      if (this._logLevel >= 3) {
        this.imm_log("Preregistering new hub: " + urlInfo.imm_getRootUrl());
      }
      hub = new YGenericHub(this, urlInfo);
      if (!hub) {
        return this.imm_setErr(errmsg, YAPI_NOT_SUPPORTED, "Unsupported hub protocol: " + urlInfo.imm_getProto(), YAPI_NOT_SUPPORTED);
      }
      hub.imm_addKnownUrl(urlInfo);
      this._knownHubsByUrl[urlInfo.imm_getRootUrl()] = hub;
    } else {
      if (this._logLevel >= 3) {
        this.imm_log("Preregistering existing hub: " + urlInfo.imm_getRootUrl());
      }
      hub.imm_updateUrl(urlInfo);
    }
    await hub.attach(
      1
      /* Y_YHubConnType.HUB_PREREGISTERED */
    );
    this.imm_updateRegisteredHubs(hub, true);
    return YAPI_SUCCESS;
  }
  /**
   * Setup the Yoctopuce library to use modules connected on a remote hub
   * performing an incoming connection to an HTTP server.
   *
   * @param incomingMessage {IncomingMessage} : node http incomingMessage object.
   * @param serverResponse  {ServerResponse} : node http serverResponse object.
   * @param errmsg {YErrorMsg} : a string passed by reference to receive any error message.
   *
   * @return {number} YAPI_SUCCESS when the call succeeds.
   *
   * On failure, throws an exception or returns a negative error code.
   */
  async RegisterHubHttpCallback(incomingMessage, serverResponse, errmsg) {
    let url = "http://callback:4444";
    let urlInfo = new _YY_UrlInfo(url);
    let hub = this.imm_getHub(urlInfo);
    if (!hub) {
      hub = new YGenericHub(this, urlInfo);
      let engine = this.system_env.getHttpCallbackEngine(hub, urlInfo, incomingMessage, serverResponse);
      if (!engine) {
        return this.imm_setErr(errmsg, YAPI_NOT_SUPPORTED, "HTTP Callback mode is not available in this environment", YAPI_NOT_SUPPORTED);
      }
      hub.imm_setHubEngine(engine);
    }
    await hub.attach(
      3
      /* Y_YHubConnType.HUB_CALLBACK */
    );
    let sub_errmsg = new YErrorMsg();
    let retcode = await hub.waitForConnection(this._networkTimeoutMs, sub_errmsg);
    if (retcode != YAPI_SUCCESS) {
      this.imm_dropConnectedHub(hub);
      await hub.detach(retcode, sub_errmsg.msg);
      return this.imm_setErr(errmsg, retcode, sub_errmsg.msg, retcode);
    }
    let yreq = await this._updateDeviceList_internal(true, false);
    if (yreq.errorType != YAPI_SUCCESS) {
      await hub.reportFailure(yreq.errorMsg);
      return this.imm_setErr(errmsg, yreq.errorType, yreq.errorMsg, yreq.errorType);
    }
    this.imm_updateRegisteredHubs(hub, true);
    return YAPI_SUCCESS;
  }
  /**
   * Setup the Yoctopuce library to use modules connected on a remote hub
   * performing an incoming connection to a websocket server.
   *
   * @param ws {WebSocket} : node WebSocket object for the incoming websocket callback connection.
   * @param errmsg {YErrorMsg} : a string passed by reference to receive any error message.
   * @param authpwd {string} : an optional authentication password
   *
   * @return {number} YAPI_SUCCESS when the call succeeds.
   *
   * On failure, throws an exception or returns a negative error code.
   */
  async RegisterHubWebSocketCallback(ws, errmsg, authpwd) {
    let authstr = authpwd ? "ws:" + authpwd + "@" : "";
    let url = "http://" + authstr + "callback:4444";
    let urlInfo = new _YY_UrlInfo(url);
    let hub = this.imm_getHub(urlInfo);
    if (!hub) {
      hub = new YGenericHub(this, urlInfo);
      let engine = this.system_env.getWebSocketCallbackEngine(hub, urlInfo, ws);
      if (!engine) {
        return this.imm_setErr(errmsg, YAPI_NOT_SUPPORTED, "WebSocket Callback mode is not available in this environment", YAPI_NOT_SUPPORTED);
      }
      hub.imm_setHubEngine(engine);
    }
    await hub.attach(
      3
      /* Y_YHubConnType.HUB_CALLBACK */
    );
    let sub_errmsg = new YErrorMsg();
    let retcode = await hub.waitForConnection(this._networkTimeoutMs, sub_errmsg);
    if (retcode != YAPI_SUCCESS) {
      this.imm_dropConnectedHub(hub);
      await hub.detach(retcode, sub_errmsg.msg);
      return this.imm_setErr(errmsg, retcode, sub_errmsg.msg, retcode);
    }
    let yreq = await this._updateDeviceList_internal(true, false);
    if (yreq.errorType != YAPI_SUCCESS) {
      this.imm_dropConnectedHub(hub);
      await hub.detach(yreq.errorType, yreq.errorMsg);
      return this.imm_setErr(errmsg, yreq.errorType, yreq.errorMsg, yreq.errorType);
    }
    this.imm_updateRegisteredHubs(hub, true);
    return YAPI_SUCCESS;
  }
  async WebSocketJoin(ws, arr_credentials, closeCallback) {
    if (this._connectedHubs.length == 0) {
      return false;
    }
    let hub = this._connectedHubs[0];
    return await hub.WebSocketJoin(ws, arr_credentials, closeCallback);
  }
  /**
   * Set up the Yoctopuce library to no more use modules connected on a previously
   * registered machine with RegisterHub.
   *
   * @param url : a string containing either "usb" or the
   *         root URL of the hub to monitor
   */
  async UnregisterHub(url) {
    let urlInfo = new _YY_UrlInfo(url);
    let hub = this.imm_getHub(urlInfo);
    if (hub) {
      for (let serial in this._devs) {
        await this._devs[serial].waitPendingQueries();
      }
      await hub.waitForPendingQueries(200);
      let serialNumber = hub.imm_getSerialNumber();
      if (serialNumber) {
        let activeHub = this._knownHubsBySerial[serialNumber];
        if (activeHub) {
          hub.imm_forgetUrls();
          hub = activeHub;
          urlInfo = hub.urlInfo;
        }
      }
      if (this._logLevel >= 3) {
        this.imm_log("Unregistering hub " + url + " (" + urlInfo.imm_getRootUrl() + ")");
      }
      this.imm_dropConnectedHub(hub);
      if (hub.imm_isDisconnected()) {
        if (this._logLevel >= 3) {
          this.imm_log("Hub " + urlInfo.imm_getRootUrl() + " is already disconnected");
        }
        this.imm_updateRegisteredHubs(hub, false);
        return;
      }
      let before = this.GetTickCount();
      let disconnected = hub.waitForDisconnection(500);
      if (hub.imm_isDisconnecting()) {
        if (this._logLevel >= 3) {
          this.imm_log("Hub " + urlInfo.imm_getRootUrl() + " is already disconnecting");
        }
      } else {
        await hub.detach(YAPI.IO_ERROR, "Hub has been unregistered");
      }
      await disconnected;
      hub.imm_forgetUrls();
      this.imm_updateRegisteredHubs(hub, false);
      if (this._logLevel >= 4) {
        this.imm_log("Disconnected after " + (this.GetTickCount() - before) + " ms");
      }
    } else {
      if (this._logLevel >= 4) {
        this.imm_log("No hub to Unregister with " + url + " (" + urlInfo.imm_getRootUrl() + ")");
      }
    }
  }
  /**
   * Test if the hub is reachable. This method do not register the hub, it only test if the
   * hub is usable. The url parameter follow the same convention as the yRegisterHub
   * method. This method is useful to verify the authentication parameters for a hub. It
   * is possible to force this method to return after mstimeout milliseconds.
   *
   * @param url : a string containing either "usb","callback" or the
   *         root URL of the hub to monitor
   * @param mstimeout : the number of millisecond available to test the connection.
   * @param errmsg : a string passed by reference to receive any error message.
   *
   * @return YAPI.SUCCESS when the call succeeds.
   *
   * On failure returns a negative error code.
   */
  async TestHub(url, mstimeout, errmsg) {
    if (url == "net") {
      return this.imm_setErr(errmsg, YAPI_INVALID_ARGUMENT, "Not supported", YAPI_INVALID_ARGUMENT);
    }
    let urlInfo = new _YY_UrlInfo(url);
    let hub = this.imm_getHub(urlInfo);
    if (!hub) {
      if (this._logLevel >= 4) {
        this.imm_log("Testing new hub: " + urlInfo.imm_getRootUrl());
      }
      hub = new YGenericHub(this, urlInfo);
      if (!hub) {
        return this.imm_setErr(errmsg, YAPI_NOT_SUPPORTED, "Unsupported hub protocol: " + urlInfo.imm_getProto(), YAPI_NOT_SUPPORTED);
      }
    } else {
      if (this._logLevel >= 4) {
        this.imm_log("Testing existing hub: " + hub.imm_getRootUrl());
      }
    }
    await hub.attach(
      0
      /* Y_YHubConnType.HUB_CONNECTED */
    );
    let sub_errmsg = new YErrorMsg();
    let retcode = await hub.waitForConnection(mstimeout, sub_errmsg);
    if (retcode != YAPI_SUCCESS) {
      return this.imm_setErr(errmsg, retcode, sub_errmsg.msg, retcode);
    }
    return YAPI_SUCCESS;
  }
  /**
   * Triggers a (re)detection of connected Yoctopuce modules.
   * The library searches the machines or USB ports previously registered using
   * yRegisterHub(), and invokes any user-defined callback function
   * in case a change in the list of connected devices is detected.
   *
   * This function can be called as frequently as desired to refresh the device list
   * and to make the application aware of hot-plug events. However, since device
   * detection is quite a heavy process, UpdateDeviceList shouldn't be called more
   * than once every two seconds.
   *
   * @param errmsg : a string passed by reference to receive any error message.
   *
   * @return YAPI.SUCCESS when the call succeeds.
   *
   * On failure returns a negative error code.
   */
  async UpdateDeviceList(errmsg = null) {
    let yreq = await this._updateDeviceList_internal(false, true);
    if (yreq.errorType !== YAPI_SUCCESS) {
      return this.imm_setErr(errmsg, yreq.errorType, yreq.errorMsg, yreq.errorType);
    }
    return YAPI_SUCCESS;
  }
  async _hubDiscoveryCallback_internal(serial, urlToRegister, urlToUnregister) {
    if (this._hubDiscoveryCallback && urlToRegister) {
      try {
        await this._hubDiscoveryCallback(serial, urlToRegister);
      } catch (e) {
        this.imm_log("Exception in hub discovery callback:", e);
      }
    }
    if ((this._detectType & Y_DETECT_NET) !== 0) {
      if (urlToRegister) {
        if (urlToUnregister) {
          await this.UnregisterHub(urlToUnregister);
        }
        await this.PreregisterHub(urlToRegister, new YErrorMsg());
      }
    }
  }
  /**
   * Force a hub discovery, if a callback as been registered with yRegisterHubDiscoveryCallback it
   * will be called for each net work hub that will respond to the discovery.
   *
   * @param errmsg : a string passed by reference to receive any error message.
   *
   * @return YAPI.SUCCESS when the call succeeds.
   *         On failure returns a negative error code.
   */
  async TriggerHubDiscovery(errmsg = null) {
    if (!this._ssdpManager) {
      this._ssdpManager = this.system_env.getSSDPManager(this);
      if (!this._ssdpManager)
        return this._lastErrorType;
      await this._ssdpManager.ySSDPStart((serial, newUrl, oldUrl) => {
        this._hubDiscoveryCallback_internal(serial, newUrl, oldUrl);
      });
    } else {
      await this._ssdpManager.ySSDPDiscover();
    }
    return YAPI_SUCCESS;
  }
  /**
   * Maintains the device-to-library communication channel.
   * If your program includes significant loops, you may want to include
   * a call to this function to make sure that the library takes care of
   * the information pushed by the modules on the communication channels.
   * This is not strictly necessary, but it may improve the reactivity
   * of the library for the following commands.
   *
   * This function may signal an error in case there is a communication problem
   * while contacting a module.
   *
   * @param errmsg : a string passed by reference to receive any error message.
   *
   * @return YAPI.SUCCESS when the call succeeds.
   *
   * On failure returns a negative error code.
   */
  async HandleEvents(errmsg = null) {
    return YAPI_SUCCESS;
  }
  /**
   * Pauses the execution flow for a specified duration.
   * This function implements a passive waiting loop, meaning that it does not
   * consume CPU cycles significantly. The processor is left available for
   * other threads and processes. During the pause, the library nevertheless
   * reads from time to time information from the Yoctopuce modules by
   * calling yHandleEvents(), in order to stay up-to-date.
   *
   * This function may signal an error in case there is a communication problem
   * while contacting a module.
   *
   * @param ms_duration : an integer corresponding to the duration of the pause,
   *         in milliseconds.
   * @param errmsg : a string passed by reference to receive any error message.
   *
   * @return YAPI.SUCCESS when the call succeeds.
   *
   * On failure returns a negative error code.
   */
  async Sleep(ms_duration, errmsg = null) {
    let end = this.GetTickCount() + ms_duration;
    let remaining = ms_duration;
    while (remaining > 0) {
      let waitTime = Math.min(remaining, 25);
      await new Promise((resolve, reject) => {
        setTimeout(resolve, waitTime);
      });
      remaining = end - this.GetTickCount();
    }
    return YAPI_SUCCESS;
  }
  // internal async function to wait for a very short period
  _microSleep_internal() {
    return new Promise(function(resolve, reject) {
      setTimeout(resolve, 3);
    });
  }
  /**
   * Invoke the specified callback function after a given timeout.
   * This function behaves more or less like Javascript setTimeout,
   * but during the waiting time, it will call yHandleEvents
   * and yUpdateDeviceList periodically, in order to
   * keep the API up-to-date with current devices.
   *
   * @param callback : the function to call after the timeout occurs.
   *         On Microsoft Internet Explorer, the callback must
   *         be provided as a string to be evaluated.
   * @param ms_timeout : an integer corresponding to the duration of the
   *         timeout, in milliseconds.
   * @param args : additional arguments to be passed to the
   *         callback function can be provided, if needed
   *         (not supported on Microsoft Internet Explorer).
   *
   * @return YAPI.SUCCESS
   */
  SetTimeout(callback, ms_timeout, args) {
    let endtime = this.GetTickCount() + ms_timeout;
    let setTimeout_internal = async () => {
      let delay = endtime - this.GetTickCount();
      if (delay < 40) {
        if (delay > 3) {
          await new Promise((resolve, reject) => {
            setTimeout(resolve, delay);
          });
        }
        callback.apply(null, args);
      } else {
        if (delay >= 150) {
          await this.UpdateDeviceList();
          delay = Math.min(endtime - YAPI.GetTickCount(), 110);
        }
        await this.Sleep(delay - 20);
        setTimeout_internal();
      }
    };
    setTimeout_internal();
    return YAPI_SUCCESS;
  }
  /**
   * Returns the current value of a monotone millisecond-based time counter.
   * This counter can be used to compute delays in relation with
   * Yoctopuce devices, which also uses the millisecond as timebase.
   *
   * @return a long integer corresponding to the millisecond counter.
   */
  GetTickCount() {
    return Date.now();
  }
  imm_CheckLogicalName(name) {
    if (name == "")
      return true;
    if (!name)
      return false;
    if (name.length > 19)
      return false;
    return /^[A-Za-z0-9_\-]*$/.test(name);
  }
  /**
   * Checks if a given string is valid as logical name for a module or a function.
   * A valid logical name has a maximum of 19 characters, all among
   * A...Z, a...z, 0...9, _, and -.
   * If you try to configure a logical name with an incorrect string,
   * the invalid characters are ignored.
   *
   * @param name : a string containing the name to check.
   *
   * @return true if the name is valid, false otherwise.
   */
  async CheckLogicalName(name) {
    return this.imm_CheckLogicalName(name);
  }
  /**
   * Register a callback function, to be called each time
   * a device is plugged. This callback will be invoked while yUpdateDeviceList
   * is running. You will have to call this function on a regular basis.
   *
   * @param arrivalCallback : a procedure taking a YModule parameter, or null
   *         to unregister a previously registered  callback.
   */
  async RegisterDeviceArrivalCallback(arrivalCallback) {
    this._arrivalCallback = arrivalCallback;
  }
  async RegisterDeviceChangeCallback(changeCallback) {
    this._namechgCallback = changeCallback;
  }
  /**
   * Register a callback function, to be called each time
   * a device is unplugged. This callback will be invoked while yUpdateDeviceList
   * is running. You will have to call this function on a regular basis.
   *
   * @param removalCallback : a procedure taking a YModule parameter, or null
   *         to unregister a previously registered  callback.
   */
  async RegisterDeviceRemovalCallback(removalCallback) {
    this._removalCallback = removalCallback;
  }
  /**
   * Register a callback function, to be called each time an Network Hub send
   * an SSDP message. The callback has two string parameter, the first one
   * contain the serial number of the hub and the second contain the URL of the
   * network hub (this URL can be passed to RegisterHub). This callback will be invoked
   * while yUpdateDeviceList is running. You will have to call this function on a regular basis.
   *
   * @param hubDiscoveryCallback : a procedure taking two string parameter, the serial
   *         number and the hub URL. Use null to unregister a previously registered  callback.
   */
  async RegisterHubDiscoveryCallback(hubDiscoveryCallback) {
    if (!this.system_env.hasSSDP) {
      return this._throw(YAPI_NOT_SUPPORTED, "Hub discovery is not supported in this environment", YAPI_NOT_SUPPORTED);
    }
    this._hubDiscoveryCallback = hubDiscoveryCallback;
    return this.TriggerHubDiscovery();
  }
  // Register a new value calibration handler for a given calibration type
  //
  async RegisterCalibrationHandler(calibrationType, calibrationHandler) {
    this._calibHandlers[calibrationType] = calibrationHandler;
  }
  // Standard value calibration handler (n-point linear error correction)
  //
  LinearCalibrationHandler(float_rawValue, int_calibType, arr_calibParams, arr_calibRawValues, arr_calibRefValues) {
    let npt;
    let x = arr_calibRawValues[0];
    let adj = arr_calibRefValues[0] - x;
    let i = 0;
    if (int_calibType < YOCTO_CALIB_TYPE_OFS) {
      npt = Math.min(int_calibType % 10, arr_calibRawValues.length, arr_calibRefValues.length);
    } else {
      npt = arr_calibRefValues.length;
    }
    while (float_rawValue > arr_calibRawValues[i] && ++i < npt) {
      let x2 = x;
      let adj2 = adj;
      x = arr_calibRawValues[i];
      adj = arr_calibRefValues[i] - x;
      if (float_rawValue < x && x > x2) {
        adj = adj2 + (adj - adj2) * (float_rawValue - x2) / (x - x2);
      }
    }
    return float_rawValue + adj;
  }
  /**
   * Compute the MD5 digest for a given ASCII string
   *
   * @param text {string} : the ASCII string to hash
   *
   * @return {Uint8Array} the 16-bytes MD5 hash key
   */
  imm_yMD5(text) {
    let ctx = new Y_MD5Ctx();
    ctx.addData(this.imm_str2bin(text));
    return ctx.calculate();
  }
  // SHA1 and WPA preshared-key computation
  //
  imm_initshaw(str_s, int_ofs, int_pad, int_xinit, _shaw) {
    let ii;
    let j = -1;
    let k = 0;
    let n = str_s.length;
    for (ii = 0; ii < 64; ii++) {
      let i = int_ofs + ii;
      let c = 0;
      if (i < n) {
        c = str_s.charCodeAt(i);
      } else if (int_pad != 0) {
        if ((int_pad & 128) != 0) {
          if (i == n)
            c = int_pad;
        } else {
          if (i == n + 3) {
            c = int_pad;
          } else if (i == n + 4)
            c = 128;
        }
      }
      if (k == 0) {
        j++;
        _shaw[j] = 0;
        k = 32;
      }
      k -= 8;
      _shaw[j] |= c << k;
    }
    if (int_pad != 0) {
      if (int_pad == 128) {
        if (n <= int_ofs + 55) {
          _shaw[15] = 8 * n;
        }
      } else {
        _shaw[15] = 8 * (64 + n + 4);
      }
    }
    if (int_xinit != 0) {
      let xdw = int_xinit << 16 | int_xinit;
      for (j = 0; j < 16; j++) {
        _shaw[j] ^= xdw;
      }
    }
  }
  imm_itershaw(s, _shaw) {
    let a, b, c, d, e, t, k;
    a = s[0];
    b = s[1];
    c = s[2];
    d = s[3];
    e = s[4];
    for (k = 16; k < 80; k++) {
      t = _shaw[k - 3] ^ _shaw[k - 8] ^ _shaw[k - 14] ^ _shaw[k - 16];
      _shaw[k] = t << 1 | t >>> 31;
    }
    for (k = 0; k < 20; k++) {
      t = (a << 5 | a >>> 27) + e + _shaw[k] + 1518500249 + (b & c | ~b & d);
      e = d;
      d = c;
      c = b << 30 | b >>> 2;
      b = a;
      a = t & 4294967295;
    }
    for (k = 20; k < 40; k++) {
      t = (a << 5 | a >>> 27) + e + _shaw[k] + 1859775393 + (b ^ c ^ d);
      e = d;
      d = c;
      c = b << 30 | b >>> 2;
      b = a;
      a = t & 4294967295;
    }
    for (k = 40; k < 60; k++) {
      t = (a << 5 | a >>> 27) + e + _shaw[k] + 2400959708 + (b & c | b & d | c & d);
      e = d;
      d = c;
      c = b << 30 | b >>> 2;
      b = a;
      a = t & 4294967295;
    }
    for (k = 60; k < 80; k++) {
      t = (a << 5 | a >>> 27) + e + _shaw[k] + 3395469782 + (b ^ c ^ d);
      e = d;
      d = c;
      c = b << 30 | b >>> 2;
      b = a;
      a = t & 4294967295;
    }
    _shaw[0] = s[0] + a & 4294967295;
    _shaw[1] = s[1] + b & 4294967295;
    _shaw[2] = s[2] + c & 4294967295;
    _shaw[3] = s[3] + d & 4294967295;
    _shaw[4] = s[4] + e & 4294967295;
  }
  /**
   * Compute the SHA1 digest for a given ASCII string
   *
   * @param text {string} : the ASCII string to hash
   *
   * @return {Uint8Array} the 20-bytes SHA1 hash key
   */
  imm_ySHA1(text) {
    let shau = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
    let i, ofs = 0;
    let n = text.length;
    let _shaw = new Uint32Array(80);
    do {
      this.imm_initshaw(text, ofs, 128, 0, _shaw);
      this.imm_itershaw(shau, _shaw);
      for (i = 0; i < 5; i++) {
        shau[i] = _shaw[i];
      }
      ofs += 64;
    } while (n > ofs - 9);
    let res = new Uint8Array(20);
    for (i = 0; i < 20; i++) {
      res[i] = shau[i >>> 2] >>> 24 - 8 * (i & 3) & 255;
    }
    return res;
  }
  /**
   * Compute the WPA Preshared key for a given SSID and passphrase
   *
   * @param ssid {string} : the access point SSID
   * @param pass {string} : the access point WPA/WPA2 passphrase
   *
   * @return {string} an hexadecimal string for the preshared key
   */
  async ComputePSK(ssid, pass) {
    let sha1_init = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
    let inner = [], outer = [], shau = [], res = [];
    let iter, pos, k, _shaw;
    _shaw = new Uint32Array(80);
    this.imm_initshaw(pass, 0, 0, 13878, _shaw);
    this.imm_itershaw(sha1_init, _shaw);
    for (k = 0; k < 5; k++) {
      inner[k] = _shaw[k];
    }
    _shaw = new Uint32Array(80);
    this.imm_initshaw(pass, 0, 0, 23644, _shaw);
    this.imm_itershaw(sha1_init, _shaw);
    for (k = 0; k < 5; k++) {
      outer[k] = _shaw[k];
    }
    pos = 0;
    for (k = 0; k < 5; k++) {
      shau[k] = 0;
    }
    _shaw = new Uint32Array(80);
    this.imm_initshaw(ssid, 0, 1, 0, _shaw);
    for (iter = 0; iter < 8192; ) {
      this.imm_itershaw(inner, _shaw);
      _shaw[5] = 2147483648;
      for (k = 6; k < 15; k++) {
        _shaw[k] = 0;
      }
      _shaw[15] = 8 * (64 + 20);
      this.imm_itershaw(outer, _shaw);
      shau[0] ^= _shaw[0];
      shau[1] ^= _shaw[1];
      shau[2] ^= _shaw[2];
      shau[3] ^= _shaw[3];
      shau[4] ^= _shaw[4];
      iter++;
      if ((iter & 4095) == 0) {
        for (k = 0; k < 5 && pos < 32; k++) {
          res[pos++] = shau[k] >>> 24 & 255;
          res[pos++] = shau[k] >>> 16 & 255;
          res[pos++] = shau[k] >>> 8 & 255;
          res[pos++] = shau[k] & 255;
        }
        if (iter == 4096) {
          for (k = 0; k < 5; k++) {
            shau[k] = 0;
          }
          _shaw = new Uint32Array(80);
          this.imm_initshaw(ssid, 0, 2, 0, _shaw);
        }
      }
    }
    let hex = "";
    for (k = 0; k < 32; k++) {
      hex += ("0" + Number(res[k]).toString(16)).slice(-2);
    }
    return hex;
  }
  nextHubInUseInternal_internal(hubref) {
    let nextref = hubref < 0 ? 0 : hubref + 1;
    let restart;
    let has_higher_hubref;
    do {
      has_higher_hubref = false;
      restart = false;
      for (let url in this._registeredHubs) {
        let hub = this._registeredHubs[url];
        let hubRef = hub.getHubRef();
        if (hubRef == nextref) {
          return this.getYHubObj(nextref);
        } else if (hubRef > nextref) {
          has_higher_hubref = true;
        }
      }
      if (has_higher_hubref) {
        nextref++;
        restart = true;
      }
    } while (restart);
    return null;
  }
  getGenHub(hubref) {
    for (let i = 0; i < this._registeredHubs.length; i++) {
      let hub = this._registeredHubs[i];
      if (hub.getHubRef() == hubref) {
        return hub;
      }
    }
    return null;
  }
  _findYHubFromCache(hubref) {
    return this._yhub_cache[hubref];
  }
  _addYHubToCache(hubref, obj) {
    this._yhub_cache[hubref] = obj;
  }
};
YAPIContext.SUCCESS = 0;
YAPIContext.NOT_INITIALIZED = -1;
YAPIContext.INVALID_ARGUMENT = -2;
YAPIContext.NOT_SUPPORTED = -3;
YAPIContext.DEVICE_NOT_FOUND = -4;
YAPIContext.VERSION_MISMATCH = -5;
YAPIContext.DEVICE_BUSY = -6;
YAPIContext.TIMEOUT = -7;
YAPIContext.IO_ERROR = -8;
YAPIContext.NO_MORE_DATA = -9;
YAPIContext.EXHAUSTED = -10;
YAPIContext.DOUBLE_ACCES = -11;
YAPIContext.UNAUTHORIZED = -12;
YAPIContext.RTC_NOT_READY = -13;
YAPIContext.FILE_NOT_FOUND = -14;
YAPIContext.SSL_ERROR = -15;
YAPIContext.RFID_SOFT_ERROR = -16;
YAPIContext.RFID_HARD_ERROR = -17;
YAPIContext.BUFFER_TOO_SMALL = -18;
YAPIContext.DNS_ERROR = -19;
YAPIContext.SSL_UNK_CERT = -20;
YAPIContext.UNCONFIGURED = -21;
YAPIContext.NO_TRUSTED_CA_CHECK = 1;
YAPIContext.NO_EXPIRATION_CHECK = 2;
YAPIContext.NO_HOSTNAME_CHECK = 4;
YAPIContext.LEGACY = 8;
var YAPI = new YAPIContext();

// obj/full/Api/yocto_api_html.js
var YSystemEnvHtml = class extends YSystemEnv {
  constructor() {
    super(...arguments);
    this.isNodeJS = false;
    this.hasSSDP = false;
  }
  hookUnhandledRejection(handler) {
    window.addEventListener("onunhandledrejection", (event) => {
      let promiseRejectionEvent = event;
      handler(promiseRejectionEvent.reason, promiseRejectionEvent.promise);
    });
  }
  getWebSocketEngine(hub, runtime_urlInfo) {
    return new YWebSocketHtmlEngine(hub, runtime_urlInfo);
  }
  getHttpEngine(hub, runtime_urlInfo, firstInfoJson) {
    return new YHttpHtmlEngine(hub, runtime_urlInfo, firstInfoJson);
  }
  getWebSocketCallbackHub(hub, ws) {
    return hub._yapi._throw(YAPI.NOT_SUPPORTED, "WebSocket Callback mode is not available in this environment", null);
  }
  getHttpCallbackHub(hub, incomingMessage, serverResponse) {
    return hub._yapi._throw(YAPI.NOT_SUPPORTED, "HTTP Callback mode is not available in this environment", null);
  }
  getSSDPManager(obj_yapi) {
    return obj_yapi._throw(YAPI.NOT_SUPPORTED, "Hub discovery is not available in this environment", null);
  }
  loadfile(file) {
    return new Promise((resolve, reject) => {
      let reader = new FileReader();
      reader.onerror = function(evt) {
        reject(evt.target.error);
      };
      reader.onload = function(evt) {
        resolve(new Uint8Array(evt.target.result));
      };
      reader.readAsArrayBuffer(file);
    });
  }
  downloadfile(url, yapi) {
    return new Promise((resolve, reject) => {
      let httpRequest = new XMLHttpRequest();
      httpRequest.open("GET", url, true);
      httpRequest.overrideMimeType("text/plain; charset=x-user-defined");
      httpRequest.onreadystatechange = (() => {
        if (httpRequest.readyState == 4) {
          if (httpRequest.status != 200 && httpRequest.status != 304) {
            if (httpRequest.status) {
              reject(new Error("HTTP error " + httpRequest.status));
            } else {
              reject(new Error("Unable to complete HTTP request, network down?"));
            }
          } else {
            resolve(YAPI.imm_str2bin(httpRequest.responseText));
          }
        }
      });
      httpRequest.send("");
    });
  }
  async downloadRemoteCertificate(urlinfo) {
    return "error: Not supported in browser";
  }
};
var _HtmlSystemEnv = new YSystemEnvHtml();
YAPI.imm_setSystemEnv(_HtmlSystemEnv);
var YHttpHtmlEngine = class extends YHttpEngine {
  constructor(hub, runtime_urlInfo, firstInfoJson) {
    super(hub, runtime_urlInfo, firstInfoJson);
  }
  // Low-level function to create an HTTP client request (abstraction layer)
  imm_makeRequest(method, relUrl, contentType, body, onProgress, onSuccess, onError) {
    let xhr = new XMLHttpRequest();
    let currPos = 0;
    xhr.open(method, this._runtime_urlInfo.imm_getUrl(true, true, false) + relUrl, true, "", "");
    xhr.setRequestHeader("Content-Type", contentType);
    xhr.overrideMimeType("text/plain; charset=x-user-defined");
    xhr.onreadystatechange = () => {
      if (xhr.readyState >= 3) {
        let httpStatus = xhr.status >> 0;
        if (xhr.readyState == 4 && httpStatus != 200 && httpStatus != 304) {
          if (httpStatus == 401 || httpStatus == 204) {
            this.infoJson.stamp = 0;
            onError(YAPI.UNAUTHORIZED, "Unauthorized access (" + xhr.status + ")", false);
          } else if (httpStatus == 404) {
            onError(YAPI.FILE_NOT_FOUND, "HTTP request return status 404 (not found)", false);
          } else if (this._hub.imm_isDisconnecting()) {
            onError(YAPI.IO_ERROR, "Hub is disconnecting", false);
          } else {
            onError(YAPI.IO_ERROR, "HTTP request failed with status " + xhr.status, false);
          }
          return;
        }
        if (this._hub.imm_isDisconnecting()) {
          if (this._hub._yapi._logLevel >= 4) {
            this._hub._yapi.imm_log("Dropping request " + relUrl + " because hub is disconnecting");
          }
          return;
        }
        if (onProgress && xhr.responseText) {
          let newlen = xhr.responseText.length;
          if (newlen > currPos) {
            onProgress(xhr.responseText.slice(currPos, newlen));
            currPos = newlen;
          }
        }
        if (onSuccess && xhr.readyState == 4) {
          onSuccess(xhr.responseText);
        }
      }
    };
    xhr.onerror = () => {
      onError(YAPI.IO_ERROR, "HTTP request failed without status", false);
    };
    xhr.send(body);
    return xhr;
  }
  // abort communication channel immediately
  imm_abortRequest(clientRequest) {
    clientRequest.abort();
  }
};
var YWebSocketHtmlEngine = class extends YWebSocketEngine {
  /** Open an outgoing websocket
   **/
  imm_webSocketOpen(str_url) {
    let websock = new WebSocket(str_url);
    websock.binaryType = "arraybuffer";
    this.websocket = websock;
  }
  /** Fills a buffer with random numbers
   **/
  imm_getRandomValues(arr) {
    return window.crypto.getRandomValues(arr);
  }
};

// obj/full/Api/yocto_network.js
var YNetwork = class _YNetwork extends YFunction {
  //--- (end of YNetwork attributes declaration)
  constructor(yapi, func) {
    super(yapi, func);
    this._readiness = _YNetwork.READINESS_INVALID;
    this._macAddress = _YNetwork.MACADDRESS_INVALID;
    this._ipAddress = _YNetwork.IPADDRESS_INVALID;
    this._subnetMask = _YNetwork.SUBNETMASK_INVALID;
    this._router = _YNetwork.ROUTER_INVALID;
    this._currentDNS = _YNetwork.CURRENTDNS_INVALID;
    this._ipConfig = _YNetwork.IPCONFIG_INVALID;
    this._primaryDNS = _YNetwork.PRIMARYDNS_INVALID;
    this._secondaryDNS = _YNetwork.SECONDARYDNS_INVALID;
    this._ntpServer = _YNetwork.NTPSERVER_INVALID;
    this._userPassword = _YNetwork.USERPASSWORD_INVALID;
    this._adminPassword = _YNetwork.ADMINPASSWORD_INVALID;
    this._httpPort = _YNetwork.HTTPPORT_INVALID;
    this._httpsPort = _YNetwork.HTTPSPORT_INVALID;
    this._securityMode = _YNetwork.SECURITYMODE_INVALID;
    this._defaultPage = _YNetwork.DEFAULTPAGE_INVALID;
    this._discoverable = _YNetwork.DISCOVERABLE_INVALID;
    this._wwwWatchdogDelay = _YNetwork.WWWWATCHDOGDELAY_INVALID;
    this._callbackUrl = _YNetwork.CALLBACKURL_INVALID;
    this._callbackMethod = _YNetwork.CALLBACKMETHOD_INVALID;
    this._callbackEncoding = _YNetwork.CALLBACKENCODING_INVALID;
    this._callbackTemplate = _YNetwork.CALLBACKTEMPLATE_INVALID;
    this._callbackCredentials = _YNetwork.CALLBACKCREDENTIALS_INVALID;
    this._callbackInitialDelay = _YNetwork.CALLBACKINITIALDELAY_INVALID;
    this._callbackSchedule = _YNetwork.CALLBACKSCHEDULE_INVALID;
    this._callbackMinDelay = _YNetwork.CALLBACKMINDELAY_INVALID;
    this._callbackMaxDelay = _YNetwork.CALLBACKMAXDELAY_INVALID;
    this._poeCurrent = _YNetwork.POECURRENT_INVALID;
    this._valueCallbackNetwork = null;
    this.READINESS_DOWN = 0;
    this.READINESS_EXISTS = 1;
    this.READINESS_LINKED = 2;
    this.READINESS_LAN_OK = 3;
    this.READINESS_WWW_OK = 4;
    this.READINESS_INVALID = -1;
    this.MACADDRESS_INVALID = YAPI.INVALID_STRING;
    this.IPADDRESS_INVALID = YAPI.INVALID_STRING;
    this.SUBNETMASK_INVALID = YAPI.INVALID_STRING;
    this.ROUTER_INVALID = YAPI.INVALID_STRING;
    this.CURRENTDNS_INVALID = YAPI.INVALID_STRING;
    this.IPCONFIG_INVALID = YAPI.INVALID_STRING;
    this.PRIMARYDNS_INVALID = YAPI.INVALID_STRING;
    this.SECONDARYDNS_INVALID = YAPI.INVALID_STRING;
    this.NTPSERVER_INVALID = YAPI.INVALID_STRING;
    this.USERPASSWORD_INVALID = YAPI.INVALID_STRING;
    this.ADMINPASSWORD_INVALID = YAPI.INVALID_STRING;
    this.HTTPPORT_INVALID = YAPI.INVALID_UINT;
    this.HTTPSPORT_INVALID = YAPI.INVALID_UINT;
    this.SECURITYMODE_UNDEFINED = 0;
    this.SECURITYMODE_LEGACY = 1;
    this.SECURITYMODE_MIXED = 2;
    this.SECURITYMODE_SECURE = 3;
    this.SECURITYMODE_INVALID = -1;
    this.DEFAULTPAGE_INVALID = YAPI.INVALID_STRING;
    this.DISCOVERABLE_FALSE = 0;
    this.DISCOVERABLE_TRUE = 1;
    this.DISCOVERABLE_INVALID = -1;
    this.WWWWATCHDOGDELAY_INVALID = YAPI.INVALID_UINT;
    this.CALLBACKURL_INVALID = YAPI.INVALID_STRING;
    this.CALLBACKMETHOD_POST = 0;
    this.CALLBACKMETHOD_GET = 1;
    this.CALLBACKMETHOD_PUT = 2;
    this.CALLBACKMETHOD_INVALID = -1;
    this.CALLBACKENCODING_FORM = 0;
    this.CALLBACKENCODING_JSON = 1;
    this.CALLBACKENCODING_JSON_ARRAY = 2;
    this.CALLBACKENCODING_CSV = 3;
    this.CALLBACKENCODING_YOCTO_API = 4;
    this.CALLBACKENCODING_JSON_NUM = 5;
    this.CALLBACKENCODING_EMONCMS = 6;
    this.CALLBACKENCODING_AZURE = 7;
    this.CALLBACKENCODING_INFLUXDB = 8;
    this.CALLBACKENCODING_MQTT = 9;
    this.CALLBACKENCODING_YOCTO_API_JZON = 10;
    this.CALLBACKENCODING_PRTG = 11;
    this.CALLBACKENCODING_INFLUXDB_V2 = 12;
    this.CALLBACKENCODING_INVALID = -1;
    this.CALLBACKTEMPLATE_OFF = 0;
    this.CALLBACKTEMPLATE_ON = 1;
    this.CALLBACKTEMPLATE_INVALID = -1;
    this.CALLBACKCREDENTIALS_INVALID = YAPI.INVALID_STRING;
    this.CALLBACKINITIALDELAY_INVALID = YAPI.INVALID_UINT;
    this.CALLBACKSCHEDULE_INVALID = YAPI.INVALID_STRING;
    this.CALLBACKMINDELAY_INVALID = YAPI.INVALID_UINT;
    this.CALLBACKMAXDELAY_INVALID = YAPI.INVALID_UINT;
    this.POECURRENT_INVALID = YAPI.INVALID_UINT;
    this._className = "Network";
  }
  //--- (YNetwork implementation)
  imm_parseAttr(name, val) {
    switch (name) {
      case "readiness":
        this._readiness = val;
        return 1;
      case "macAddress":
        this._macAddress = val;
        return 1;
      case "ipAddress":
        this._ipAddress = val;
        return 1;
      case "subnetMask":
        this._subnetMask = val;
        return 1;
      case "router":
        this._router = val;
        return 1;
      case "currentDNS":
        this._currentDNS = val;
        return 1;
      case "ipConfig":
        this._ipConfig = val;
        return 1;
      case "primaryDNS":
        this._primaryDNS = val;
        return 1;
      case "secondaryDNS":
        this._secondaryDNS = val;
        return 1;
      case "ntpServer":
        this._ntpServer = val;
        return 1;
      case "userPassword":
        this._userPassword = val;
        return 1;
      case "adminPassword":
        this._adminPassword = val;
        return 1;
      case "httpPort":
        this._httpPort = val;
        return 1;
      case "httpsPort":
        this._httpsPort = val;
        return 1;
      case "securityMode":
        this._securityMode = val;
        return 1;
      case "defaultPage":
        this._defaultPage = val;
        return 1;
      case "discoverable":
        this._discoverable = val;
        return 1;
      case "wwwWatchdogDelay":
        this._wwwWatchdogDelay = val;
        return 1;
      case "callbackUrl":
        this._callbackUrl = val;
        return 1;
      case "callbackMethod":
        this._callbackMethod = val;
        return 1;
      case "callbackEncoding":
        this._callbackEncoding = val;
        return 1;
      case "callbackTemplate":
        this._callbackTemplate = val;
        return 1;
      case "callbackCredentials":
        this._callbackCredentials = val;
        return 1;
      case "callbackInitialDelay":
        this._callbackInitialDelay = val;
        return 1;
      case "callbackSchedule":
        this._callbackSchedule = val;
        return 1;
      case "callbackMinDelay":
        this._callbackMinDelay = val;
        return 1;
      case "callbackMaxDelay":
        this._callbackMaxDelay = val;
        return 1;
      case "poeCurrent":
        this._poeCurrent = val;
        return 1;
    }
    return super.imm_parseAttr(name, val);
  }
  /**
   * Returns the current established working mode of the network interface.
   * Level zero (DOWN_0) means that no hardware link has been detected. Either there is no signal
   * on the network cable, or the selected wireless access point cannot be detected.
   * Level 1 (LIVE_1) is reached when the network is detected, but is not yet connected.
   * For a wireless network, this shows that the requested SSID is present.
   * Level 2 (LINK_2) is reached when the hardware connection is established.
   * For a wired network connection, level 2 means that the cable is attached at both ends.
   * For a connection to a wireless access point, it shows that the security parameters
   * are properly configured. For an ad-hoc wireless connection, it means that there is
   * at least one other device connected on the ad-hoc network.
   * Level 3 (DHCP_3) is reached when an IP address has been obtained using DHCP.
   * Level 4 (DNS_4) is reached when the DNS server is reachable on the network.
   * Level 5 (WWW_5) is reached when global connectivity is demonstrated by properly loading the
   * current time from an NTP server.
   *
   * @return a value among YNetwork.READINESS_DOWN, YNetwork.READINESS_EXISTS,
   * YNetwork.READINESS_LINKED, YNetwork.READINESS_LAN_OK and YNetwork.READINESS_WWW_OK corresponding to
   * the current established working mode of the network interface
   *
   * On failure, throws an exception or returns YNetwork.READINESS_INVALID.
   */
  async get_readiness() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return _YNetwork.READINESS_INVALID;
      }
    }
    res = this._readiness;
    return res;
  }
  /**
   * Returns the MAC address of the network interface. The MAC address is also available on a sticker
   * on the module, in both numeric and barcode forms.
   *
   * @return a string corresponding to the MAC address of the network interface
   *
   * On failure, throws an exception or returns YNetwork.MACADDRESS_INVALID.
   */
  async get_macAddress() {
    let res;
    if (this._cacheExpiration == 0) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return _YNetwork.MACADDRESS_INVALID;
      }
    }
    res = this._macAddress;
    return res;
  }
  /**
   * Returns the IP address currently in use by the device. The address may have been configured
   * statically, or provided by a DHCP server.
   *
   * @return a string corresponding to the IP address currently in use by the device
   *
   * On failure, throws an exception or returns YNetwork.IPADDRESS_INVALID.
   */
  async get_ipAddress() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return _YNetwork.IPADDRESS_INVALID;
      }
    }
    res = this._ipAddress;
    return res;
  }
  /**
   * Returns the subnet mask currently used by the device.
   *
   * @return a string corresponding to the subnet mask currently used by the device
   *
   * On failure, throws an exception or returns YNetwork.SUBNETMASK_INVALID.
   */
  async get_subnetMask() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return _YNetwork.SUBNETMASK_INVALID;
      }
    }
    res = this._subnetMask;
    return res;
  }
  /**
   * Returns the IP address of the router on the device subnet (default gateway).
   *
   * @return a string corresponding to the IP address of the router on the device subnet (default gateway)
   *
   * On failure, throws an exception or returns YNetwork.ROUTER_INVALID.
   */
  async get_router() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return _YNetwork.ROUTER_INVALID;
      }
    }
    res = this._router;
    return res;
  }
  /**
   * Returns the IP address of the DNS server currently used by the device.
   *
   * @return a string corresponding to the IP address of the DNS server currently used by the device
   *
   * On failure, throws an exception or returns YNetwork.CURRENTDNS_INVALID.
   */
  async get_currentDNS() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return _YNetwork.CURRENTDNS_INVALID;
      }
    }
    res = this._currentDNS;
    return res;
  }
  /**
   * Returns the IP configuration of the network interface.
   *
   * If the network interface is set up to use a static IP address, the string starts with "STATIC:" and
   * is followed by three
   * parameters, separated by "/". The first is the device IP address, followed by the subnet mask
   * length, and finally the
   * router IP address (default gateway). For instance: "STATIC:192.168.1.14/16/192.168.1.1"
   *
   * If the network interface is configured to receive its IP from a DHCP server, the string start with
   * "DHCP:" and is followed by
   * three parameters separated by "/". The first is the fallback IP address, then the fallback subnet
   * mask length and finally the
   * fallback router IP address. These three parameters are used when no DHCP reply is received.
   *
   * @return a string corresponding to the IP configuration of the network interface
   *
   * On failure, throws an exception or returns YNetwork.IPCONFIG_INVALID.
   */
  async get_ipConfig() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return _YNetwork.IPCONFIG_INVALID;
      }
    }
    res = this._ipConfig;
    return res;
  }
  async set_ipConfig(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("ipConfig", rest_val);
  }
  /**
   * Returns the IP address of the primary name server to be used by the module.
   *
   * @return a string corresponding to the IP address of the primary name server to be used by the module
   *
   * On failure, throws an exception or returns YNetwork.PRIMARYDNS_INVALID.
   */
  async get_primaryDNS() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return _YNetwork.PRIMARYDNS_INVALID;
      }
    }
    res = this._primaryDNS;
    return res;
  }
  /**
   * Changes the IP address of the primary name server to be used by the module.
   * When using DHCP, if a value is specified, it overrides the value received from the DHCP server.
   * Remember to call the saveToFlash() method and then to reboot the module to apply this setting.
   *
   * @param newval : a string corresponding to the IP address of the primary name server to be used by the module
   *
   * @return YAPI.SUCCESS if the call succeeds.
   *
   * On failure, throws an exception or returns a negative error code.
   */
  async set_primaryDNS(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("primaryDNS", rest_val);
  }
  /**
   * Returns the IP address of the secondary name server to be used by the module.
   *
   * @return a string corresponding to the IP address of the secondary name server to be used by the module
   *
   * On failure, throws an exception or returns YNetwork.SECONDARYDNS_INVALID.
   */
  async get_secondaryDNS() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return _YNetwork.SECONDARYDNS_INVALID;
      }
    }
    res = this._secondaryDNS;
    return res;
  }
  /**
   * Changes the IP address of the secondary name server to be used by the module.
   * When using DHCP, if a value is specified, it overrides the value received from the DHCP server.
   * Remember to call the saveToFlash() method and then to reboot the module to apply this setting.
   *
   * @param newval : a string corresponding to the IP address of the secondary name server to be used by the module
   *
   * @return YAPI.SUCCESS if the call succeeds.
   *
   * On failure, throws an exception or returns a negative error code.
   */
  async set_secondaryDNS(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("secondaryDNS", rest_val);
  }
  /**
   * Returns the IP address of the NTP server to be used by the device.
   *
   * @return a string corresponding to the IP address of the NTP server to be used by the device
   *
   * On failure, throws an exception or returns YNetwork.NTPSERVER_INVALID.
   */
  async get_ntpServer() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return _YNetwork.NTPSERVER_INVALID;
      }
    }
    res = this._ntpServer;
    return res;
  }
  /**
   * Changes the IP address of the NTP server to be used by the module. Use an empty
   * string to restore the factory set  address.
   * Remember to call the saveToFlash() method and then to reboot the module to apply this setting.
   *
   * @param newval : a string corresponding to the IP address of the NTP server to be used by the module
   *
   * @return YAPI.SUCCESS if the call succeeds.
   *
   * On failure, throws an exception or returns a negative error code.
   */
  async set_ntpServer(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("ntpServer", rest_val);
  }
  /**
   * Returns a hash string if a password has been set for "user" user,
   * or an empty string otherwise.
   *
   * @return a string corresponding to a hash string if a password has been set for "user" user,
   *         or an empty string otherwise
   *
   * On failure, throws an exception or returns YNetwork.USERPASSWORD_INVALID.
   */
  async get_userPassword() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return _YNetwork.USERPASSWORD_INVALID;
      }
    }
    res = this._userPassword;
    return res;
  }
  /**
   * Changes the password for the "user" user. This password becomes instantly required
   * to perform any use of the module. If the specified value is an
   * empty string, a password is not required anymore.
   * Remember to call the saveToFlash() method of the module if the
   * modification must be kept.
   *
   * @param newval : a string corresponding to the password for the "user" user
   *
   * @return YAPI.SUCCESS if the call succeeds.
   *
   * On failure, throws an exception or returns a negative error code.
   */
  async set_userPassword(newval) {
    let rest_val;
    if (newval.length > YAPI.HASH_BUF_SIZE) {
      return this._throw(YAPI.INVALID_ARGUMENT, "Password too long :" + newval, YAPI.INVALID_ARGUMENT);
    }
    rest_val = String(newval);
    return await this._setAttr("userPassword", rest_val);
  }
  /**
   * Returns a hash string if a password has been set for user "admin",
   * or an empty string otherwise.
   *
   * @return a string corresponding to a hash string if a password has been set for user "admin",
   *         or an empty string otherwise
   *
   * On failure, throws an exception or returns YNetwork.ADMINPASSWORD_INVALID.
   */
  async get_adminPassword() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return _YNetwork.ADMINPASSWORD_INVALID;
      }
    }
    res = this._adminPassword;
    return res;
  }
  /**
   * Changes the password for the "admin" user. This password becomes instantly required
   * to perform any change of the module state. If the specified value is an
   * empty string, a password is not required anymore.
   * Remember to call the saveToFlash() method of the module if the
   * modification must be kept.
   *
   * @param newval : a string corresponding to the password for the "admin" user
   *
   * @return YAPI.SUCCESS if the call succeeds.
   *
   * On failure, throws an exception or returns a negative error code.
   */
  async set_adminPassword(newval) {
    let rest_val;
    if (newval.length > YAPI.HASH_BUF_SIZE) {
      return this._throw(YAPI.INVALID_ARGUMENT, "Password too long :" + newval, YAPI.INVALID_ARGUMENT);
    }
    rest_val = String(newval);
    return await this._setAttr("adminPassword", rest_val);
  }
  /**
   * Returns the TCP port used to serve the hub web UI.
   *
   * @return an integer corresponding to the TCP port used to serve the hub web UI
   *
   * On failure, throws an exception or returns YNetwork.HTTPPORT_INVALID.
   */
  async get_httpPort() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return _YNetwork.HTTPPORT_INVALID;
      }
    }
    res = this._httpPort;
    return res;
  }
  /**
   * Changes the the TCP port used to serve the hub web UI. The default value is port 80,
   * which is the default for all Web servers. Regardless of the value set here,
   * the hub will always reply on port 4444, which is used by default by Yoctopuce
   * API library. When you change this parameter, remember to call the saveToFlash()
   * method of the module if the modification must be kept.
   *
   * @param newval : an integer corresponding to the the TCP port used to serve the hub web UI
   *
   * @return YAPI.SUCCESS if the call succeeds.
   *
   * On failure, throws an exception or returns a negative error code.
   */
  async set_httpPort(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("httpPort", rest_val);
  }
  /**
   * Returns the secure TCP port used to serve the hub web UI.
   *
   * @return an integer corresponding to the secure TCP port used to serve the hub web UI
   *
   * On failure, throws an exception or returns YNetwork.HTTPSPORT_INVALID.
   */
  async get_httpsPort() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return _YNetwork.HTTPSPORT_INVALID;
      }
    }
    res = this._httpsPort;
    return res;
  }
  /**
   * Changes the secure TCP port used to serve the hub web UI. The default value is port 4443,
   * which is the default for all Web servers. When you change this parameter, remember to call the saveToFlash()
   * method of the module if the modification must be kept.
   *
   * @param newval : an integer corresponding to the secure TCP port used to serve the hub web UI
   *
   * @return YAPI.SUCCESS if the call succeeds.
   *
   * On failure, throws an exception or returns a negative error code.
   */
  async set_httpsPort(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("httpsPort", rest_val);
  }
  /**
   * Returns the security level chosen to prevent unauthorized access to the server.
   *
   * @return a value among YNetwork.SECURITYMODE_UNDEFINED, YNetwork.SECURITYMODE_LEGACY,
   * YNetwork.SECURITYMODE_MIXED and YNetwork.SECURITYMODE_SECURE corresponding to the security level
   * chosen to prevent unauthorized access to the server
   *
   * On failure, throws an exception or returns YNetwork.SECURITYMODE_INVALID.
   */
  async get_securityMode() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return _YNetwork.SECURITYMODE_INVALID;
      }
    }
    res = this._securityMode;
    return res;
  }
  /**
   * Changes the security level used to prevent unauthorized access to the server.
   * The value UNDEFINED causes the security configuration wizard to be
   * displayed the next time you log on to the Web console.
   * The value LEGACY offers unencrypted HTTP access by default, and
   * is designed to provide compatibility with legacy applications that do not
   * handle password or do not support HTTPS. But it should
   * only be used when system security is guaranteed by other means, such as the
   * use of a firewall.
   * The value MIXED requires the configuration of passwords, and allows
   * access via both HTTP (unencrypted) and HTTPS (encrypted), while requiring
   * the Yoctopuce API to be tolerant of certificate characteristics.
   * The value SECURE requires the configuration of passwords and the
   * use of secure communications in all cases.
   * When you change this parameter, remember to call the saveToFlash()
   * method of the module if the modification must be kept.
   *
   * @param newval : a value among YNetwork.SECURITYMODE_UNDEFINED, YNetwork.SECURITYMODE_LEGACY,
   * YNetwork.SECURITYMODE_MIXED and YNetwork.SECURITYMODE_SECURE corresponding to the security level
   * used to prevent unauthorized access to the server
   *
   * @return YAPI.SUCCESS if the call succeeds.
   *
   * On failure, throws an exception or returns a negative error code.
   */
  async set_securityMode(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("securityMode", rest_val);
  }
  /**
   * Returns the HTML page to serve for the URL "/"" of the hub.
   *
   * @return a string corresponding to the HTML page to serve for the URL "/"" of the hub
   *
   * On failure, throws an exception or returns YNetwork.DEFAULTPAGE_INVALID.
   */
  async get_defaultPage() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return _YNetwork.DEFAULTPAGE_INVALID;
      }
    }
    res = this._defaultPage;
    return res;
  }
  /**
   * Changes the default HTML page returned by the hub. If not value are set the hub return
   * "index.html" which is the web interface of the hub. It is possible to change this page
   * for file that has been uploaded on the hub. The maximum filename size is 15 characters.
   * When you change this parameter, remember to call the saveToFlash()
   * method of the module if the modification must be kept.
   *
   * @param newval : a string corresponding to the default HTML page returned by the hub
   *
   * @return YAPI.SUCCESS if the call succeeds.
   *
   * On failure, throws an exception or returns a negative error code.
   */
  async set_defaultPage(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("defaultPage", rest_val);
  }
  /**
   * Returns the activation state of the multicast announce protocols to allow easy
   * discovery of the module in the network neighborhood (uPnP/Bonjour protocol).
   *
   * @return either YNetwork.DISCOVERABLE_FALSE or YNetwork.DISCOVERABLE_TRUE, according to the
   * activation state of the multicast announce protocols to allow easy
   *         discovery of the module in the network neighborhood (uPnP/Bonjour protocol)
   *
   * On failure, throws an exception or returns YNetwork.DISCOVERABLE_INVALID.
   */
  async get_discoverable() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return _YNetwork.DISCOVERABLE_INVALID;
      }
    }
    res = this._discoverable;
    return res;
  }
  /**
   * Changes the activation state of the multicast announce protocols to allow easy
   * discovery of the module in the network neighborhood (uPnP/Bonjour protocol).
   * Remember to call the saveToFlash()
   * method of the module if the modification must be kept.
   *
   * @param newval : either YNetwork.DISCOVERABLE_FALSE or YNetwork.DISCOVERABLE_TRUE, according to the
   * activation state of the multicast announce protocols to allow easy
   *         discovery of the module in the network neighborhood (uPnP/Bonjour protocol)
   *
   * @return YAPI.SUCCESS if the call succeeds.
   *
   * On failure, throws an exception or returns a negative error code.
   */
  async set_discoverable(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("discoverable", rest_val);
  }
  /**
   * Returns the allowed downtime of the WWW link (in seconds) before triggering an automated
   * reboot to try to recover Internet connectivity. A zero value disables automated reboot
   * in case of Internet connectivity loss.
   *
   * @return an integer corresponding to the allowed downtime of the WWW link (in seconds) before
   * triggering an automated
   *         reboot to try to recover Internet connectivity
   *
   * On failure, throws an exception or returns YNetwork.WWWWATCHDOGDELAY_INVALID.
   */
  async get_wwwWatchdogDelay() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return _YNetwork.WWWWATCHDOGDELAY_INVALID;
      }
    }
    res = this._wwwWatchdogDelay;
    return res;
  }
  /**
   * Changes the allowed downtime of the WWW link (in seconds) before triggering an automated
   * reboot to try to recover Internet connectivity. A zero value disables automated reboot
   * in case of Internet connectivity loss. The smallest valid non-zero timeout is
   * 90 seconds. Remember to call the saveToFlash()
   * method of the module if the modification must be kept.
   *
   * @param newval : an integer corresponding to the allowed downtime of the WWW link (in seconds)
   * before triggering an automated
   *         reboot to try to recover Internet connectivity
   *
   * @return YAPI.SUCCESS if the call succeeds.
   *
   * On failure, throws an exception or returns a negative error code.
   */
  async set_wwwWatchdogDelay(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("wwwWatchdogDelay", rest_val);
  }
  /**
   * Returns the callback URL to notify of significant state changes.
   *
   * @return a string corresponding to the callback URL to notify of significant state changes
   *
   * On failure, throws an exception or returns YNetwork.CALLBACKURL_INVALID.
   */
  async get_callbackUrl() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return _YNetwork.CALLBACKURL_INVALID;
      }
    }
    res = this._callbackUrl;
    return res;
  }
  /**
   * Changes the callback URL to notify significant state changes. Remember to call the
   * saveToFlash() method of the module if the modification must be kept.
   *
   * @param newval : a string corresponding to the callback URL to notify significant state changes
   *
   * @return YAPI.SUCCESS if the call succeeds.
   *
   * On failure, throws an exception or returns a negative error code.
   */
  async set_callbackUrl(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("callbackUrl", rest_val);
  }
  /**
   * Returns the HTTP method used to notify callbacks for significant state changes.
   *
   * @return a value among YNetwork.CALLBACKMETHOD_POST, YNetwork.CALLBACKMETHOD_GET and
   * YNetwork.CALLBACKMETHOD_PUT corresponding to the HTTP method used to notify callbacks for
   * significant state changes
   *
   * On failure, throws an exception or returns YNetwork.CALLBACKMETHOD_INVALID.
   */
  async get_callbackMethod() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return _YNetwork.CALLBACKMETHOD_INVALID;
      }
    }
    res = this._callbackMethod;
    return res;
  }
  /**
   * Changes the HTTP method used to notify callbacks for significant state changes.
   * Remember to call the saveToFlash() method of the module if the
   * modification must be kept.
   *
   * @param newval : a value among YNetwork.CALLBACKMETHOD_POST, YNetwork.CALLBACKMETHOD_GET and
   * YNetwork.CALLBACKMETHOD_PUT corresponding to the HTTP method used to notify callbacks for
   * significant state changes
   *
   * @return YAPI.SUCCESS if the call succeeds.
   *
   * On failure, throws an exception or returns a negative error code.
   */
  async set_callbackMethod(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("callbackMethod", rest_val);
  }
  /**
   * Returns the encoding standard to use for representing notification values.
   *
   * @return a value among YNetwork.CALLBACKENCODING_FORM, YNetwork.CALLBACKENCODING_JSON,
   * YNetwork.CALLBACKENCODING_JSON_ARRAY, YNetwork.CALLBACKENCODING_CSV,
   * YNetwork.CALLBACKENCODING_YOCTO_API, YNetwork.CALLBACKENCODING_JSON_NUM,
   * YNetwork.CALLBACKENCODING_EMONCMS, YNetwork.CALLBACKENCODING_AZURE,
   * YNetwork.CALLBACKENCODING_INFLUXDB, YNetwork.CALLBACKENCODING_MQTT,
   * YNetwork.CALLBACKENCODING_YOCTO_API_JZON, YNetwork.CALLBACKENCODING_PRTG and
   * YNetwork.CALLBACKENCODING_INFLUXDB_V2 corresponding to the encoding standard to use for
   * representing notification values
   *
   * On failure, throws an exception or returns YNetwork.CALLBACKENCODING_INVALID.
   */
  async get_callbackEncoding() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return _YNetwork.CALLBACKENCODING_INVALID;
      }
    }
    res = this._callbackEncoding;
    return res;
  }
  /**
   * Changes the encoding standard to use for representing notification values.
   * Remember to call the saveToFlash() method of the module if the
   * modification must be kept.
   *
   * @param newval : a value among YNetwork.CALLBACKENCODING_FORM, YNetwork.CALLBACKENCODING_JSON,
   * YNetwork.CALLBACKENCODING_JSON_ARRAY, YNetwork.CALLBACKENCODING_CSV,
   * YNetwork.CALLBACKENCODING_YOCTO_API, YNetwork.CALLBACKENCODING_JSON_NUM,
   * YNetwork.CALLBACKENCODING_EMONCMS, YNetwork.CALLBACKENCODING_AZURE,
   * YNetwork.CALLBACKENCODING_INFLUXDB, YNetwork.CALLBACKENCODING_MQTT,
   * YNetwork.CALLBACKENCODING_YOCTO_API_JZON, YNetwork.CALLBACKENCODING_PRTG and
   * YNetwork.CALLBACKENCODING_INFLUXDB_V2 corresponding to the encoding standard to use for
   * representing notification values
   *
   * @return YAPI.SUCCESS if the call succeeds.
   *
   * On failure, throws an exception or returns a negative error code.
   */
  async set_callbackEncoding(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("callbackEncoding", rest_val);
  }
  /**
   * Returns the activation state of the custom template file to customize callback
   * format. If the custom callback template is disabled, it will be ignored even
   * if present on the YoctoHub.
   *
   * @return either YNetwork.CALLBACKTEMPLATE_OFF or YNetwork.CALLBACKTEMPLATE_ON, according to the
   * activation state of the custom template file to customize callback
   *         format
   *
   * On failure, throws an exception or returns YNetwork.CALLBACKTEMPLATE_INVALID.
   */
  async get_callbackTemplate() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return _YNetwork.CALLBACKTEMPLATE_INVALID;
      }
    }
    res = this._callbackTemplate;
    return res;
  }
  /**
   * Enable the use of a template file to customize callbacks format.
   * When the custom callback template file is enabled, the template file
   * will be loaded for each callback in order to build the data to post to the
   * server. If template file does not exist on the YoctoHub, the callback will
   * fail with an error message indicating the name of the expected template file.
   * Remember to call the saveToFlash() method of the module if the
   * modification must be kept.
   *
   * @param newval : either YNetwork.CALLBACKTEMPLATE_OFF or YNetwork.CALLBACKTEMPLATE_ON
   *
   * @return YAPI.SUCCESS if the call succeeds.
   *
   * On failure, throws an exception or returns a negative error code.
   */
  async set_callbackTemplate(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("callbackTemplate", rest_val);
  }
  /**
   * Returns a hashed version of the notification callback credentials if set,
   * or an empty string otherwise.
   *
   * @return a string corresponding to a hashed version of the notification callback credentials if set,
   *         or an empty string otherwise
   *
   * On failure, throws an exception or returns YNetwork.CALLBACKCREDENTIALS_INVALID.
   */
  async get_callbackCredentials() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return _YNetwork.CALLBACKCREDENTIALS_INVALID;
      }
    }
    res = this._callbackCredentials;
    return res;
  }
  /**
   * Changes the credentials required to connect to the callback address. The credentials
   * must be provided as returned by function get_callbackCredentials,
   * in the form username:hash. The method used to compute the hash varies according
   * to the the authentication scheme implemented by the callback, For Basic authentication,
   * the hash is the MD5 of the string username:password. For Digest authentication,
   * the hash is the MD5 of the string username:realm:password. For a simpler
   * way to configure callback credentials, use function callbackLogin instead.
   * Remember to call the saveToFlash() method of the module if the
   * modification must be kept.
   *
   * @param newval : a string corresponding to the credentials required to connect to the callback address
   *
   * @return YAPI.SUCCESS if the call succeeds.
   *
   * On failure, throws an exception or returns a negative error code.
   */
  async set_callbackCredentials(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("callbackCredentials", rest_val);
  }
  /**
   * Connects to the notification callback and saves the credentials required to
   * log into it. The password is not stored into the module, only a hashed
   * copy of the credentials are saved. Remember to call the
   * saveToFlash() method of the module if the modification must be kept.
   *
   * @param username : username required to log to the callback
   * @param password : password required to log to the callback
   *
   * @return YAPI.SUCCESS if the call succeeds.
   *
   * On failure, throws an exception or returns a negative error code.
   */
  async callbackLogin(username, password) {
    let rest_val;
    rest_val = username + ":" + password;
    return await this._setAttr("callbackCredentials", rest_val);
  }
  /**
   * Returns the initial waiting time before first callback notifications, in seconds.
   *
   * @return an integer corresponding to the initial waiting time before first callback notifications, in seconds
   *
   * On failure, throws an exception or returns YNetwork.CALLBACKINITIALDELAY_INVALID.
   */
  async get_callbackInitialDelay() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return _YNetwork.CALLBACKINITIALDELAY_INVALID;
      }
    }
    res = this._callbackInitialDelay;
    return res;
  }
  /**
   * Changes the initial waiting time before first callback notifications, in seconds.
   * Remember to call the saveToFlash() method of the module if the modification must be kept.
   *
   * @param newval : an integer corresponding to the initial waiting time before first callback
   * notifications, in seconds
   *
   * @return YAPI.SUCCESS if the call succeeds.
   *
   * On failure, throws an exception or returns a negative error code.
   */
  async set_callbackInitialDelay(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("callbackInitialDelay", rest_val);
  }
  /**
   * Returns the HTTP callback schedule strategy, as a text string.
   *
   * @return a string corresponding to the HTTP callback schedule strategy, as a text string
   *
   * On failure, throws an exception or returns YNetwork.CALLBACKSCHEDULE_INVALID.
   */
  async get_callbackSchedule() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return _YNetwork.CALLBACKSCHEDULE_INVALID;
      }
    }
    res = this._callbackSchedule;
    return res;
  }
  /**
   * Changes the HTTP callback schedule strategy, as a text string.
   * Remember to call the saveToFlash()
   * method of the module if the modification must be kept.
   *
   * @param newval : a string corresponding to the HTTP callback schedule strategy, as a text string
   *
   * @return YAPI.SUCCESS if the call succeeds.
   *
   * On failure, throws an exception or returns a negative error code.
   */
  async set_callbackSchedule(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("callbackSchedule", rest_val);
  }
  /**
   * Returns the minimum waiting time between two HTTP callbacks, in seconds.
   *
   * @return an integer corresponding to the minimum waiting time between two HTTP callbacks, in seconds
   *
   * On failure, throws an exception or returns YNetwork.CALLBACKMINDELAY_INVALID.
   */
  async get_callbackMinDelay() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return _YNetwork.CALLBACKMINDELAY_INVALID;
      }
    }
    res = this._callbackMinDelay;
    return res;
  }
  /**
   * Changes the minimum waiting time between two HTTP callbacks, in seconds.
   * Remember to call the saveToFlash() method of the module if the modification must be kept.
   *
   * @param newval : an integer corresponding to the minimum waiting time between two HTTP callbacks, in seconds
   *
   * @return YAPI.SUCCESS if the call succeeds.
   *
   * On failure, throws an exception or returns a negative error code.
   */
  async set_callbackMinDelay(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("callbackMinDelay", rest_val);
  }
  /**
   * Returns the waiting time between two HTTP callbacks when there is nothing new.
   *
   * @return an integer corresponding to the waiting time between two HTTP callbacks when there is nothing new
   *
   * On failure, throws an exception or returns YNetwork.CALLBACKMAXDELAY_INVALID.
   */
  async get_callbackMaxDelay() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return _YNetwork.CALLBACKMAXDELAY_INVALID;
      }
    }
    res = this._callbackMaxDelay;
    return res;
  }
  /**
   * Changes the waiting time between two HTTP callbacks when there is nothing new.
   * Remember to call the saveToFlash() method of the module if the modification must be kept.
   *
   * @param newval : an integer corresponding to the waiting time between two HTTP callbacks when there
   * is nothing new
   *
   * @return YAPI.SUCCESS if the call succeeds.
   *
   * On failure, throws an exception or returns a negative error code.
   */
  async set_callbackMaxDelay(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("callbackMaxDelay", rest_val);
  }
  /**
   * Returns the current consumed by the module from Power-over-Ethernet (PoE), in milliamps.
   * The current consumption is measured after converting PoE source to 5 Volt, and should
   * never exceed 1800 mA.
   *
   * @return an integer corresponding to the current consumed by the module from Power-over-Ethernet
   * (PoE), in milliamps
   *
   * On failure, throws an exception or returns YNetwork.POECURRENT_INVALID.
   */
  async get_poeCurrent() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return _YNetwork.POECURRENT_INVALID;
      }
    }
    res = this._poeCurrent;
    return res;
  }
  /**
   * Retrieves a network interface for a given identifier.
   * The identifier can be specified using several formats:
   *
   * - FunctionLogicalName
   * - ModuleSerialNumber.FunctionIdentifier
   * - ModuleSerialNumber.FunctionLogicalName
   * - ModuleLogicalName.FunctionIdentifier
   * - ModuleLogicalName.FunctionLogicalName
   *
   *
   * This function does not require that the network interface is online at the time
   * it is invoked. The returned object is nevertheless valid.
   * Use the method YNetwork.isOnline() to test if the network interface is
   * indeed online at a given time. In case of ambiguity when looking for
   * a network interface by logical name, no error is notified: the first instance
   * found is returned. The search is performed first by hardware name,
   * then by logical name.
   *
   * If a call to this object's is_online() method returns FALSE although
   * you are certain that the matching device is plugged, make sure that you did
   * call registerHub() at application initialization time.
   *
   * @param func : a string that uniquely characterizes the network interface, for instance
   *         YHUBETH1.network.
   *
   * @return a YNetwork object allowing you to drive the network interface.
   */
  static FindNetwork(func) {
    let obj;
    obj = YFunction._FindFromCache("Network", func);
    if (obj == null) {
      obj = new _YNetwork(YAPI, func);
      YFunction._AddToCache("Network", func, obj);
    }
    return obj;
  }
  /**
   * Retrieves a network interface for a given identifier in a YAPI context.
   * The identifier can be specified using several formats:
   *
   * - FunctionLogicalName
   * - ModuleSerialNumber.FunctionIdentifier
   * - ModuleSerialNumber.FunctionLogicalName
   * - ModuleLogicalName.FunctionIdentifier
   * - ModuleLogicalName.FunctionLogicalName
   *
   *
   * This function does not require that the network interface is online at the time
   * it is invoked. The returned object is nevertheless valid.
   * Use the method YNetwork.isOnline() to test if the network interface is
   * indeed online at a given time. In case of ambiguity when looking for
   * a network interface by logical name, no error is notified: the first instance
   * found is returned. The search is performed first by hardware name,
   * then by logical name.
   *
   * @param yctx : a YAPI context
   * @param func : a string that uniquely characterizes the network interface, for instance
   *         YHUBETH1.network.
   *
   * @return a YNetwork object allowing you to drive the network interface.
   */
  static FindNetworkInContext(yctx, func) {
    let obj;
    obj = YFunction._FindFromCacheInContext(yctx, "Network", func);
    if (obj == null) {
      obj = new _YNetwork(yctx, func);
      YFunction._AddToCache("Network", func, obj);
    }
    return obj;
  }
  /**
   * Registers the callback function that is invoked on every change of advertised value.
   * The callback is invoked only during the execution of ySleep or yHandleEvents.
   * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
   * one of these two functions periodically. To unregister a callback, pass a null pointer as argument.
   *
   * @param callback : the callback function to call, or a null pointer. The callback function should take two
   *         arguments: the function object of which the value has changed, and the character string describing
   *         the new advertised value.
   * @noreturn
   */
  async registerValueCallback(callback) {
    let val;
    if (callback != null) {
      await YFunction._UpdateValueCallbackList(this, true);
    } else {
      await YFunction._UpdateValueCallbackList(this, false);
    }
    this._valueCallbackNetwork = callback;
    if (callback != null && await this.isOnline()) {
      val = this._advertisedValue;
      if (!(val == "")) {
        await this._invokeValueCallback(val);
      }
    }
    return 0;
  }
  async _invokeValueCallback(value) {
    if (this._valueCallbackNetwork != null) {
      try {
        await this._valueCallbackNetwork(this, value);
      } catch (e) {
        this._yapi.imm_log("Exception in valueCallback:", e);
      }
    } else {
      await super._invokeValueCallback(value);
    }
    return 0;
  }
  /**
   * Changes the configuration of the network interface to enable the use of an
   * IP address received from a DHCP server. Until an address is received from a DHCP
   * server, the module uses the IP parameters specified to this function.
   * Remember to call the saveToFlash() method and then to reboot the module to apply this setting.
   *
   * @param fallbackIpAddr : fallback IP address, to be used when no DHCP reply is received
   * @param fallbackSubnetMaskLen : fallback subnet mask length when no DHCP reply is received, as an
   *         integer (e.g. 24 means 255.255.255.0)
   * @param fallbackRouter : fallback router IP address, to be used when no DHCP reply is received
   *
   * @return YAPI.SUCCESS when the call succeeds.
   *
   * On failure, throws an exception or returns a negative error code.
   */
  async useDHCP(fallbackIpAddr, fallbackSubnetMaskLen, fallbackRouter) {
    return await this.set_ipConfig("DHCP:" + fallbackIpAddr + "/" + String(Math.round(fallbackSubnetMaskLen)) + "/" + fallbackRouter);
  }
  /**
   * Changes the configuration of the network interface to enable the use of an
   * IP address received from a DHCP server. Until an address is received from a DHCP
   * server, the module uses an IP of the network 169.254.0.0/16 (APIPA).
   * Remember to call the saveToFlash() method and then to reboot the module to apply this setting.
   *
   * @return YAPI.SUCCESS when the call succeeds.
   *
   * On failure, throws an exception or returns a negative error code.
   */
  async useDHCPauto() {
    return await this.set_ipConfig("DHCP:");
  }
  /**
   * Changes the configuration of the network interface to use a static IP address.
   * Remember to call the saveToFlash() method and then to reboot the module to apply this setting.
   *
   * @param ipAddress : device IP address
   * @param subnetMaskLen : subnet mask length, as an integer (e.g. 24 means 255.255.255.0)
   * @param router : router IP address (default gateway)
   *
   * @return YAPI.SUCCESS when the call succeeds.
   *
   * On failure, throws an exception or returns a negative error code.
   */
  async useStaticIP(ipAddress, subnetMaskLen, router) {
    return await this.set_ipConfig("STATIC:" + ipAddress + "/" + String(Math.round(subnetMaskLen)) + "/" + router);
  }
  /**
   * Pings host to test the network connectivity. Sends four ICMP ECHO_REQUEST requests from the
   * module to the target host. This method returns a string with the result of the
   * 4 ICMP ECHO_REQUEST requests.
   *
   * @param host : the hostname or the IP address of the target
   *
   * @return a string with the result of the ping.
   */
  async ping(host) {
    let content;
    content = await this._download("ping.txt?host=" + host);
    return this._yapi.imm_bin2str(content);
  }
  /**
   * Trigger an HTTP callback quickly. This function can even be called within
   * an HTTP callback, in which case the next callback will be triggered 5 seconds
   * after the end of the current callback, regardless if the minimum time between
   * callbacks configured in the device.
   *
   * @return YAPI.SUCCESS when the call succeeds.
   *
   * On failure, throws an exception or returns a negative error code.
   */
  async triggerCallback() {
    return await this.set_callbackMethod(await this.get_callbackMethod());
  }
  /**
   * Set up periodic HTTP callbacks (simplified function).
   *
   * @param interval : a string representing the callback periodicity, expressed in
   *         seconds, minutes or hours, eg. "60s", "5m", "1h", "48h".
   * @param offset : an integer representing the time offset relative to the period
   *         when the callback should occur. For instance, if the periodicity is
   *         24h, an offset of 7 will make the callback occur each day at 7AM.
   *
   * @return YAPI.SUCCESS when the call succeeds.
   *
   * On failure, throws an exception or returns a negative error code.
   */
  async set_periodicCallbackSchedule(interval, offset) {
    return await this.set_callbackSchedule("every " + interval + "+" + String(Math.round(offset)));
  }
  /**
   * Continues the enumeration of network interfaces started using yFirstNetwork().
   * Caution: You can't make any assumption about the returned network interfaces order.
   * If you want to find a specific a network interface, use Network.findNetwork()
   * and a hardwareID or a logical name.
   *
   * @return a pointer to a YNetwork object, corresponding to
   *         a network interface currently online, or a null pointer
   *         if there are no more network interfaces to enumerate.
   */
  nextNetwork() {
    let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
    if (resolve.errorType != YAPI.SUCCESS)
      return null;
    let next_hwid = this._yapi.imm_getNextHardwareId(this._className, resolve.result);
    if (next_hwid == null)
      return null;
    return _YNetwork.FindNetworkInContext(this._yapi, next_hwid);
  }
  /**
   * Starts the enumeration of network interfaces currently accessible.
   * Use the method YNetwork.nextNetwork() to iterate on
   * next network interfaces.
   *
   * @return a pointer to a YNetwork object, corresponding to
   *         the first network interface currently online, or a null pointer
   *         if there are none.
   */
  static FirstNetwork() {
    let next_hwid = YAPI.imm_getFirstHardwareId("Network");
    if (next_hwid == null)
      return null;
    return _YNetwork.FindNetwork(next_hwid);
  }
  /**
   * Starts the enumeration of network interfaces currently accessible.
   * Use the method YNetwork.nextNetwork() to iterate on
   * next network interfaces.
   *
   * @param yctx : a YAPI context.
   *
   * @return a pointer to a YNetwork object, corresponding to
   *         the first network interface currently online, or a null pointer
   *         if there are none.
   */
  static FirstNetworkInContext(yctx) {
    let next_hwid = yctx.imm_getFirstHardwareId("Network");
    if (next_hwid == null)
      return null;
    return _YNetwork.FindNetworkInContext(yctx, next_hwid);
  }
};
YNetwork.READINESS_DOWN = 0;
YNetwork.READINESS_EXISTS = 1;
YNetwork.READINESS_LINKED = 2;
YNetwork.READINESS_LAN_OK = 3;
YNetwork.READINESS_WWW_OK = 4;
YNetwork.READINESS_INVALID = -1;
YNetwork.MACADDRESS_INVALID = YAPI.INVALID_STRING;
YNetwork.IPADDRESS_INVALID = YAPI.INVALID_STRING;
YNetwork.SUBNETMASK_INVALID = YAPI.INVALID_STRING;
YNetwork.ROUTER_INVALID = YAPI.INVALID_STRING;
YNetwork.CURRENTDNS_INVALID = YAPI.INVALID_STRING;
YNetwork.IPCONFIG_INVALID = YAPI.INVALID_STRING;
YNetwork.PRIMARYDNS_INVALID = YAPI.INVALID_STRING;
YNetwork.SECONDARYDNS_INVALID = YAPI.INVALID_STRING;
YNetwork.NTPSERVER_INVALID = YAPI.INVALID_STRING;
YNetwork.USERPASSWORD_INVALID = YAPI.INVALID_STRING;
YNetwork.ADMINPASSWORD_INVALID = YAPI.INVALID_STRING;
YNetwork.HTTPPORT_INVALID = YAPI.INVALID_UINT;
YNetwork.HTTPSPORT_INVALID = YAPI.INVALID_UINT;
YNetwork.SECURITYMODE_UNDEFINED = 0;
YNetwork.SECURITYMODE_LEGACY = 1;
YNetwork.SECURITYMODE_MIXED = 2;
YNetwork.SECURITYMODE_SECURE = 3;
YNetwork.SECURITYMODE_INVALID = -1;
YNetwork.DEFAULTPAGE_INVALID = YAPI.INVALID_STRING;
YNetwork.DISCOVERABLE_FALSE = 0;
YNetwork.DISCOVERABLE_TRUE = 1;
YNetwork.DISCOVERABLE_INVALID = -1;
YNetwork.WWWWATCHDOGDELAY_INVALID = YAPI.INVALID_UINT;
YNetwork.CALLBACKURL_INVALID = YAPI.INVALID_STRING;
YNetwork.CALLBACKMETHOD_POST = 0;
YNetwork.CALLBACKMETHOD_GET = 1;
YNetwork.CALLBACKMETHOD_PUT = 2;
YNetwork.CALLBACKMETHOD_INVALID = -1;
YNetwork.CALLBACKENCODING_FORM = 0;
YNetwork.CALLBACKENCODING_JSON = 1;
YNetwork.CALLBACKENCODING_JSON_ARRAY = 2;
YNetwork.CALLBACKENCODING_CSV = 3;
YNetwork.CALLBACKENCODING_YOCTO_API = 4;
YNetwork.CALLBACKENCODING_JSON_NUM = 5;
YNetwork.CALLBACKENCODING_EMONCMS = 6;
YNetwork.CALLBACKENCODING_AZURE = 7;
YNetwork.CALLBACKENCODING_INFLUXDB = 8;
YNetwork.CALLBACKENCODING_MQTT = 9;
YNetwork.CALLBACKENCODING_YOCTO_API_JZON = 10;
YNetwork.CALLBACKENCODING_PRTG = 11;
YNetwork.CALLBACKENCODING_INFLUXDB_V2 = 12;
YNetwork.CALLBACKENCODING_INVALID = -1;
YNetwork.CALLBACKTEMPLATE_OFF = 0;
YNetwork.CALLBACKTEMPLATE_ON = 1;
YNetwork.CALLBACKTEMPLATE_INVALID = -1;
YNetwork.CALLBACKCREDENTIALS_INVALID = YAPI.INVALID_STRING;
YNetwork.CALLBACKINITIALDELAY_INVALID = YAPI.INVALID_UINT;
YNetwork.CALLBACKSCHEDULE_INVALID = YAPI.INVALID_STRING;
YNetwork.CALLBACKMINDELAY_INVALID = YAPI.INVALID_UINT;
YNetwork.CALLBACKMAXDELAY_INVALID = YAPI.INVALID_UINT;
YNetwork.POECURRENT_INVALID = YAPI.INVALID_UINT;

// obj/full/Api/yocto_files.js
var YFileRecord = class {
  // API symbols as static members
  //--- (end of generated code: YFileRecord attributes declaration)
  constructor(str_json) {
    this._name = "";
    this._size = 0;
    this._crc = 0;
    const loadval = JSON.parse(str_json);
    this._name = loadval.name;
    this._size = loadval.size;
    this._crc = loadval.crc;
  }
  //--- (generated code: YFileRecord implementation)
  /**
   * Returns the name of the file.
   *
   * @return a string with the name of the file.
   */
  get_name() {
    return this._name;
  }
  /**
   * Returns the size of the file in bytes.
   *
   * @return the size of the file.
   */
  get_size() {
    return this._size;
  }
  /**
   * Returns the 32-bit CRC of the file content.
   *
   * @return the 32-bit CRC of the file content.
   */
  get_crc() {
    return this._crc;
  }
};
var YFiles = class _YFiles extends YFunction {
  //--- (end of generated code: YFiles attributes declaration)
  constructor(yapi, func) {
    super(yapi, func);
    this._filesCount = _YFiles.FILESCOUNT_INVALID;
    this._freeSpace = _YFiles.FREESPACE_INVALID;
    this._valueCallbackFiles = null;
    this._ver = 0;
    this.FILESCOUNT_INVALID = YAPI.INVALID_UINT;
    this.FREESPACE_INVALID = YAPI.INVALID_UINT;
    this._className = "Files";
  }
  //--- (generated code: YFiles implementation)
  imm_parseAttr(name, val) {
    switch (name) {
      case "filesCount":
        this._filesCount = val;
        return 1;
      case "freeSpace":
        this._freeSpace = val;
        return 1;
    }
    return super.imm_parseAttr(name, val);
  }
  /**
   * Returns the number of files currently loaded in the filesystem.
   *
   * @return an integer corresponding to the number of files currently loaded in the filesystem
   *
   * On failure, throws an exception or returns YFiles.FILESCOUNT_INVALID.
   */
  async get_filesCount() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return _YFiles.FILESCOUNT_INVALID;
      }
    }
    res = this._filesCount;
    return res;
  }
  /**
   * Returns the free space for uploading new files to the filesystem, in bytes.
   *
   * @return an integer corresponding to the free space for uploading new files to the filesystem, in bytes
   *
   * On failure, throws an exception or returns YFiles.FREESPACE_INVALID.
   */
  async get_freeSpace() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return _YFiles.FREESPACE_INVALID;
      }
    }
    res = this._freeSpace;
    return res;
  }
  /**
   * Retrieves a filesystem for a given identifier.
   * The identifier can be specified using several formats:
   *
   * - FunctionLogicalName
   * - ModuleSerialNumber.FunctionIdentifier
   * - ModuleSerialNumber.FunctionLogicalName
   * - ModuleLogicalName.FunctionIdentifier
   * - ModuleLogicalName.FunctionLogicalName
   *
   *
   * This function does not require that the filesystem is online at the time
   * it is invoked. The returned object is nevertheless valid.
   * Use the method YFiles.isOnline() to test if the filesystem is
   * indeed online at a given time. In case of ambiguity when looking for
   * a filesystem by logical name, no error is notified: the first instance
   * found is returned. The search is performed first by hardware name,
   * then by logical name.
   *
   * If a call to this object's is_online() method returns FALSE although
   * you are certain that the matching device is plugged, make sure that you did
   * call registerHub() at application initialization time.
   *
   * @param func : a string that uniquely characterizes the filesystem, for instance
   *         YRGBLED2.files.
   *
   * @return a YFiles object allowing you to drive the filesystem.
   */
  static FindFiles(func) {
    let obj;
    obj = YFunction._FindFromCache("Files", func);
    if (obj == null) {
      obj = new _YFiles(YAPI, func);
      YFunction._AddToCache("Files", func, obj);
    }
    return obj;
  }
  /**
   * Retrieves a filesystem for a given identifier in a YAPI context.
   * The identifier can be specified using several formats:
   *
   * - FunctionLogicalName
   * - ModuleSerialNumber.FunctionIdentifier
   * - ModuleSerialNumber.FunctionLogicalName
   * - ModuleLogicalName.FunctionIdentifier
   * - ModuleLogicalName.FunctionLogicalName
   *
   *
   * This function does not require that the filesystem is online at the time
   * it is invoked. The returned object is nevertheless valid.
   * Use the method YFiles.isOnline() to test if the filesystem is
   * indeed online at a given time. In case of ambiguity when looking for
   * a filesystem by logical name, no error is notified: the first instance
   * found is returned. The search is performed first by hardware name,
   * then by logical name.
   *
   * @param yctx : a YAPI context
   * @param func : a string that uniquely characterizes the filesystem, for instance
   *         YRGBLED2.files.
   *
   * @return a YFiles object allowing you to drive the filesystem.
   */
  static FindFilesInContext(yctx, func) {
    let obj;
    obj = YFunction._FindFromCacheInContext(yctx, "Files", func);
    if (obj == null) {
      obj = new _YFiles(yctx, func);
      YFunction._AddToCache("Files", func, obj);
    }
    return obj;
  }
  /**
   * Registers the callback function that is invoked on every change of advertised value.
   * The callback is invoked only during the execution of ySleep or yHandleEvents.
   * This provides control over the time when the callback is triggered. For good responsiveness, remember to call
   * one of these two functions periodically. To unregister a callback, pass a null pointer as argument.
   *
   * @param callback : the callback function to call, or a null pointer. The callback function should take two
   *         arguments: the function object of which the value has changed, and the character string describing
   *         the new advertised value.
   * @noreturn
   */
  async registerValueCallback(callback) {
    let val;
    if (callback != null) {
      await YFunction._UpdateValueCallbackList(this, true);
    } else {
      await YFunction._UpdateValueCallbackList(this, false);
    }
    this._valueCallbackFiles = callback;
    if (callback != null && await this.isOnline()) {
      val = this._advertisedValue;
      if (!(val == "")) {
        await this._invokeValueCallback(val);
      }
    }
    return 0;
  }
  async _invokeValueCallback(value) {
    if (this._valueCallbackFiles != null) {
      try {
        await this._valueCallbackFiles(this, value);
      } catch (e) {
        this._yapi.imm_log("Exception in valueCallback:", e);
      }
    } else {
      await super._invokeValueCallback(value);
    }
    return 0;
  }
  async sendCommand(command) {
    let url;
    url = "files.json?a=" + command;
    return await this._download(url);
  }
  async _getVersion() {
    let json;
    if (this._ver > 0) {
      return this._ver;
    }
    json = await this.sendCommand("info");
    if (json[0] != 123) {
      this._ver = 30;
    } else {
      this._ver = YAPIContext.imm_atoi(this.imm_json_get_key(json, "ver"));
    }
    return this._ver;
  }
  /**
   * Reinitialize the filesystem to its clean, unfragmented, empty state.
   * All files previously uploaded are permanently lost.
   *
   * @return YAPI.SUCCESS if the call succeeds.
   *
   * On failure, throws an exception or returns a negative error code.
   */
  async format_fs() {
    let json;
    let res;
    json = await this.sendCommand("format");
    res = this.imm_json_get_key(json, "res");
    if (!(res == "ok")) {
      return this._throw(this._yapi.IO_ERROR, "format failed", this._yapi.IO_ERROR);
    }
    return this._yapi.SUCCESS;
  }
  /**
   * Returns a list of YFileRecord objects that describe files currently loaded
   * in the filesystem.
   *
   * @param pattern : an optional filter pattern, using star and question marks
   *         as wild cards. When an empty pattern is provided, all file records
   *         are returned.
   *
   * @return a list of YFileRecord objects, containing the file path
   *         and name, byte size and 32-bit CRC of the file content.
   *
   * On failure, throws an exception or returns an empty list.
   */
  async get_list(pattern) {
    let json;
    let filelist = [];
    let res = [];
    json = await this.sendCommand("dir&f=" + pattern);
    filelist = this.imm_json_get_array(json);
    res.length = 0;
    for (let ii_0 of filelist) {
      res.push(new YFileRecord(this._yapi.imm_bin2str(ii_0)));
    }
    return res;
  }
  /**
   * Tests if a file exists on the filesystem of the module.
   *
   * @param filename : the filename to test.
   *
   * @return true if the file exists, false otherwise.
   *
   * On failure, throws an exception.
   */
  async fileExist(filename) {
    let json;
    let filelist = [];
    if (filename.length == 0) {
      return false;
    }
    json = await this.sendCommand("dir&f=" + filename);
    filelist = this.imm_json_get_array(json);
    if (filelist.length > 0) {
      return true;
    }
    return false;
  }
  /**
   * Downloads the requested file and returns a binary buffer with its content.
   *
   * @param pathname : path and name of the file to download
   *
   * @return a binary buffer with the file content
   *
   * On failure, throws an exception or returns an empty content.
   */
  async download(pathname) {
    return await this._download(pathname);
  }
  /**
   * Uploads a file to the filesystem, to the specified full path name.
   * If a file already exists with the same path name, its content is overwritten.
   *
   * @param pathname : path and name of the new file to create
   * @param content : binary buffer with the content to set
   *
   * @return YAPI.SUCCESS if the call succeeds.
   *
   * On failure, throws an exception or returns a negative error code.
   */
  async upload(pathname, content) {
    return await this._upload(pathname, content);
  }
  /**
   * Deletes a file, given by its full path name, from the filesystem.
   * Because of filesystem fragmentation, deleting a file may not always
   * free up the whole space used by the file. However, rewriting a file
   * with the same path name will always reuse any space not freed previously.
   * If you need to ensure that no space is taken by previously deleted files,
   * you can use format_fs to fully reinitialize the filesystem.
   *
   * @param pathname : path and name of the file to remove.
   *
   * @return YAPI.SUCCESS if the call succeeds.
   *
   * On failure, throws an exception or returns a negative error code.
   */
  async remove(pathname) {
    let json;
    let res;
    json = await this.sendCommand("del&f=" + pathname);
    res = this.imm_json_get_key(json, "res");
    if (!(res == "ok")) {
      return this._throw(this._yapi.IO_ERROR, "unable to remove file", this._yapi.IO_ERROR);
    }
    return this._yapi.SUCCESS;
  }
  /**
   * Returns the expected file CRC for a given content.
   * Note that the CRC value may vary depending on the version
   * of the filesystem used by the hub, so it is important to
   * use this method if a reference value needs to be computed.
   *
   * @param content : a buffer representing a file content
   *
   * @return the 32-bit CRC summarizing the file content, as it would
   *         be returned by the get_crc() method of
   *         YFileRecord objects returned by get_list().
   */
  async get_content_crc(content) {
    let fsver;
    let sz;
    let blkcnt;
    let meta;
    let blkidx;
    let blksz;
    let part;
    let res;
    sz = content.length;
    if (sz == 0) {
      res = this._yapi.imm_bincrc(content, 0, 0);
      return res;
    }
    fsver = await this._getVersion();
    if (fsver < 40) {
      res = this._yapi.imm_bincrc(content, 0, sz);
      return res;
    }
    blkcnt = (sz + 255) / 256 >> 0;
    meta = new Uint8Array(4 * blkcnt);
    blkidx = 0;
    while (blkidx < blkcnt) {
      blksz = sz - blkidx * 256;
      if (blksz > 256) {
        blksz = 256;
      }
      part = this._yapi.imm_bincrc(content, blkidx * 256, blksz) ^ 4294967295;
      meta.set([part & 255], 4 * blkidx);
      meta.set([part >> 8 & 255], 4 * blkidx + 1);
      meta.set([part >> 16 & 255], 4 * blkidx + 2);
      meta.set([part >> 24 & 255], 4 * blkidx + 3);
      blkidx = blkidx + 1;
    }
    res = this._yapi.imm_bincrc(meta, 0, 4 * blkcnt) ^ 4294967295;
    return res;
  }
  /**
   * Continues the enumeration of filesystems started using yFirstFiles().
   * Caution: You can't make any assumption about the returned filesystems order.
   * If you want to find a specific a filesystem, use Files.findFiles()
   * and a hardwareID or a logical name.
   *
   * @return a pointer to a YFiles object, corresponding to
   *         a filesystem currently online, or a null pointer
   *         if there are no more filesystems to enumerate.
   */
  nextFiles() {
    let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
    if (resolve.errorType != YAPI.SUCCESS)
      return null;
    let next_hwid = this._yapi.imm_getNextHardwareId(this._className, resolve.result);
    if (next_hwid == null)
      return null;
    return _YFiles.FindFilesInContext(this._yapi, next_hwid);
  }
  /**
   * Starts the enumeration of filesystems currently accessible.
   * Use the method YFiles.nextFiles() to iterate on
   * next filesystems.
   *
   * @return a pointer to a YFiles object, corresponding to
   *         the first filesystem currently online, or a null pointer
   *         if there are none.
   */
  static FirstFiles() {
    let next_hwid = YAPI.imm_getFirstHardwareId("Files");
    if (next_hwid == null)
      return null;
    return _YFiles.FindFiles(next_hwid);
  }
  /**
   * Starts the enumeration of filesystems currently accessible.
   * Use the method YFiles.nextFiles() to iterate on
   * next filesystems.
   *
   * @param yctx : a YAPI context.
   *
   * @return a pointer to a YFiles object, corresponding to
   *         the first filesystem currently online, or a null pointer
   *         if there are none.
   */
  static FirstFilesInContext(yctx) {
    let next_hwid = yctx.imm_getFirstHardwareId("Files");
    if (next_hwid == null)
      return null;
    return _YFiles.FindFilesInContext(yctx, next_hwid);
  }
};
YFiles.FILESCOUNT_INVALID = YAPI.INVALID_UINT;
YFiles.FREESPACE_INVALID = YAPI.INVALID_UINT;

// obj/full/constants.js
var constants = class _constants {
  static get versionInfo() {
    return (
      /* version number patched automatically */
      ["1.11.10214", "70214"]
    );
  }
  static get buildVersion() {
    return this.versionInfo[0];
  }
  static get trueBuild() {
    return this.versionInfo[1];
  }
  static get deviceScreenWidth() {
    return screen.width * window.devicePixelRatio;
  }
  static get deviceScreenHeight() {
    return screen.height * window.devicePixelRatio;
  }
  // if screen DPI is greater than 96 and screen width is less the 12 " (~A4) then it's probably a phone a tablet
  static get isPhoneOrTablet() {
    return _constants.ScreenDPI > 96 && Math.max(_constants.deviceScreenWidth, _constants.deviceScreenHeight) / _constants.ScreenDPI < 12;
  }
  static get captureSizePolicy() {
    return _constants._defaultCaptureSizePolicy;
  }
  static set captureSizePolicy(value) {
    _constants._defaultCaptureSizePolicy = value;
  }
  static get dbleClickBringsUpContextMenu() {
    return _constants._defaulDbleClickBringsUpContextMenu;
  }
  static set dbleClickBringsUpContextMenu(value) {
    _constants._defaulDbleClickBringsUpContextMenu = value;
  }
  static get maxPointsPerGraphSerie() {
    return _constants._defaultMaxPointsPerGraphSerie;
  }
  static set maxPointsPerGraphSerie(value) {
    if (value >= 0)
      _constants._defaultMaxPointsPerGraphSerie = value >> 0;
  }
  static get maxPointsPerDataloggerSerie() {
    return _constants._defaultMaxPointsPerDataloggerSerie;
  }
  static set maxPointsPerDataloggerSerie(value) {
    if (value >= -1)
      _constants._defaultMaxPointsPerDataloggerSerie = value >> 0;
  }
  static get maxDataRecordsPerSensor() {
    return _constants._defaultMaxDataRecordsPerSensor;
  }
  static set maxDataRecordsPerSensor(value) {
    if (value >= 0)
      _constants._defaultMaxDataRecordsPerSensor = value >> 0;
  }
  static get captureWidth() {
    return _constants._defaultCaptureWidth;
  }
  static set captureWidth(value) {
    if (value > 0)
      _constants._defaultCaptureWidth = value;
  }
  static get captureHeight() {
    return _constants._defaultCaptureHeight;
  }
  static set captureHeight(value) {
    if (value > 0)
      _constants._defaultCaptureHeight = value;
  }
  static get captureDPI() {
    return _constants._defaultCaptureDPI;
  }
  static set captureDPI(value) {
    if (value > 0)
      _constants._defaultCaptureDPI = value;
  }
  static get captureType() {
    return _constants._defaultCaptureType;
  }
  static set captureType(value) {
    _constants._defaultCaptureType = value;
  }
  // UI constants
  static get generalFontFamily() {
    return _constants.FontFamily;
  }
  static get generalFontSize() {
    return _constants.FontSize;
  }
  static get generalSizeCoef() {
    return _constants.FontSize / 12;
  }
  static get screenDPI() {
    return _constants.ScreenDPI;
  }
  static get guiDPIFactor() {
    return _constants.DPIfactor;
  }
  static get guiDPIFactorWasOverriden() {
    return _constants.DPIfactorOverriden;
  }
  static get guiDPIFactorIsOverriden() {
    let vs = _constants.getCookie(_constants.DPIFactorKey);
    if (vs == null)
      return false;
    let v = parseFloat(vs);
    if (v > 0)
      return true;
    return false;
  }
  static get guiDPIFactorOverrideValue() {
    let vs = _constants.getCookie(_constants.DPIFactorKey);
    if (vs == null)
      return _constants.DPIfactor;
    let v = parseFloat(vs);
    if (v > 0)
      return v;
    return _constants.DPIfactor;
  }
  static overrideGuiDPIFactor(override, value) {
    if (override && typeof value !== "undefined") {
      _constants.setCookie(_constants.DPIFactorKey, value.toString(), 3650);
    } else {
      _constants.setCookie(_constants.DPIFactorKey, "none", 3650);
    }
  }
  static get RunningOnAndroid() {
    return _constants.isAndroid;
  }
  static get WindowBackgroundColor() {
    return "#f0f0f0";
  }
  static get WindowBorder() {
    return "1px solid #808080";
  }
  static get WindowPadding() {
    return 2;
  }
  static get WindowInnerBorderColor() {
    return " #A0A0A0";
  }
  static get WindowInnerBackgroundColor() {
    return "#fAfAfA";
  }
  static get WindowInnerBorder() {
    return "1px solid " + _constants.WindowInnerBorderColor;
  }
  static get WindowHeaderBackgroundColor() {
    return "#0072ca";
  }
  static get WindowHeaderColor() {
    return "white";
  }
  static get WindowHeaderBorder() {
    return "1px solid #0072ca";
  }
  static get WindowHeaderHeight() {
    return 20;
  }
  static get WindowHeaderFontSize() {
    return 8 * _constants.FontSize / 6;
  }
  static get WindowHeaderFontFamily() {
    return _constants.FontFamily;
  }
  static get mustCheckForUpdate() {
    return _constants._checkForUpdate;
  }
  static set mustCheckForUpdate(value) {
    if (value != _constants._checkForUpdate) {
      _constants._checkForUpdate = value;
      _constants.edited = true;
    }
  }
  static get edited() {
    return _constants._edited;
  }
  static set edited(value) {
    if (_constants._edited != value) {
      _constants._edited = value;
      YWebPage.ShowSaveReminder(value);
    }
  }
  static InitColorHistory(node) {
    let nodes = node.get_childsByIndex();
    for (let i = 0; i < nodes.length; i++) {
      let node2 = nodes[i];
      switch (nodes[i].Name) {
        case "Color":
          try {
            let colordef = node2.Attributes["value"];
            let color = YColor.FromString(colordef);
            if (color != null)
              colorEditor.AddColorToHistory(color);
          } catch (_a) {
          }
      }
    }
  }
  //#endif
  static findDPI() {
    let DPI = 1;
    while (!matchMedia("(max-resolution: " + DPI.toString() + "dpi)").matches) {
      DPI = DPI << 1;
    }
    let a = DPI >> 1;
    let b = DPI;
    while (b - a > 1) {
      let pivot = b + a >> 1;
      if (matchMedia("(max-resolution: " + pivot.toString() + "dpi)").matches) {
        b = pivot;
      } else {
        a = pivot;
      }
    }
    return b * (_constants.isAndroid ? window.devicePixelRatio : 1);
  }
  static InitCaptureParams(node) {
    let nodes = node.get_childsByName();
    for (let nodeName in nodes) {
      let node2 = nodes[nodeName];
      let value;
      switch (nodeName) {
        case "Target":
          if ("value" in node2.Attributes) {
            _constants._captureTarget = YDataRenderer.CaptureTarget.fromString(YDataRenderer.CaptureTarget, node2.Attributes["value"]);
          }
          break;
        case "Type":
          if ("value" in node2.Attributes) {
            _constants._defaultCaptureType = YDataRenderer.CaptureType.fromString(YDataRenderer.CaptureType, node2.Attributes["value"]);
          }
          break;
        case "Size":
          if ("value" in node2.Attributes) {
            _constants._defaultCaptureSizePolicy = YDataRenderer.CaptureFormats.fromString(YDataRenderer.CaptureFormats, node2.Attributes["value"]);
          }
          break;
        case "Resolution":
          if ("value" in node2.Attributes) {
            _constants.captureDPI = parseInt(node2.Attributes["value"]);
          }
          break;
        case "Width":
          if ("value" in node2.Attributes) {
            _constants.captureWidth = value = parseInt(node2.Attributes["value"]);
          }
          break;
        case "Height":
          if ("value" in node2.Attributes) {
            _constants.captureHeight = parseInt(node2.Attributes["value"]);
          }
          break;
        case "Folder":
          if ("value" in node2.Attributes) {
            _constants._captureFolder = node2.Attributes["value"];
          }
          break;
      }
    }
  }
  static InitUIParams(node) {
    let nodes = node.get_childsByName();
    for (let nodeName in nodes) {
      let node2 = nodes[nodeName];
      switch (nodeName) {
        case "VerticalDragZoom":
          if ("value" in node2.Attributes) {
            YGraph.verticalDragZoomEnabled = node2.Attributes["value"].toUpperCase() == "TRUE";
          }
          break;
        case "DbleClickContextMenu":
          if ("value" in node2.Attributes) {
            _constants.dbleClickBringsUpContextMenu = node2.Attributes["value"].toUpperCase() == "TRUE";
          }
          break;
      }
    }
  }
  static InitCheckForUpdateParams(node) {
    let nodes = node.get_childsByName();
    for (let nodeName in nodes) {
      let node2 = nodes[nodeName];
      switch (nodeName) {
        case "checkForUpdate":
          if ("value" in node2.Attributes) {
            _constants._checkForUpdate = node2.Attributes["value"].toUpperCase() == "TRUE";
          }
          break;
        case "ignoreBuild":
          if ("value" in node2.Attributes) {
            _constants._ignoreBuild = parseInt(node2.Attributes["value"].toUpperCase());
          }
          break;
      }
    }
  }
  static InitMemoryUsageParams(node) {
    let nodes = node.get_childsByName();
    for (let nodeName in nodes) {
      let node2 = nodes[nodeName];
      switch (nodeName) {
        case "maxPointsPerGraphSerie":
          if ("value" in node2.Attributes) {
            let value = parseInt(node2.Attributes["value"]);
            _constants.maxPointsPerGraphSerie = value;
            DataSerie.MaxPointsPerSeries = value;
          }
          break;
        case "maxDataRecordsPerSensor":
          if ("value" in node2.Attributes) {
            let value = parseInt(node2.Attributes["value"]);
            if (value >= 0) {
              _constants.maxDataRecordsPerSensor = value;
              CustomYSensor.MaxDataRecords = value;
            }
          }
          break;
        case "maxPointsPerDataloggerSerie":
          if ("value" in node2.Attributes) {
            let value = parseInt(node2.Attributes["value"]);
            _constants.maxPointsPerDataloggerSerie = value;
            CustomYSensor.MaxLoggerRecords = value;
          }
          break;
        case "deviceListValidity":
          if ("value" in node2.Attributes) {
            let value = parseInt(node2.Attributes["value"]);
            if (value > 0) {
              _constants._deviceListValidity = value;
              YAPI.SetDeviceListValidity(value).then();
            }
          }
          break;
      }
    }
  }
  static Init(initData) {
    let nodes = initData.get_childsByName();
    for (let nodeName in nodes) {
      let node = nodes[nodeName];
      switch (nodeName) {
        case "UseUSB":
          if ("value" in node.Attributes) {
            _constants._useUSB = node.Attributes["value"].toUpperCase() == "TRUE";
          }
          break;
        //#ifndef READONLY
        case "Colors":
          _constants.InitColorHistory(node);
          break;
        //#endif
        case "Capture":
          _constants.InitCaptureParams(node);
          break;
        case "UI":
          _constants.InitUIParams(node);
          break;
        case "Updates":
          _constants.InitCheckForUpdateParams(node);
          break;
        case "MemoryUsage":
          _constants.InitMemoryUsageParams(node);
          break;
        case "UseVirtualHub":
          if ("value" in node.Attributes) {
            _constants._useVirtualHub = node.Attributes["value"].toUpperCase() == "TRUE";
          }
          break;
        case "Hubs":
          sensorsManager.InitHubList(node);
          break;
      }
    }
  }
  static get CRCTable() {
    if (_constants._crcTable != null)
      return _constants._crcTable;
    _constants._crcTable = [];
    let c;
    var crcTable = [];
    for (var n = 0; n < 256; n++) {
      c = n;
      for (var k = 0; k < 8; k++) {
        c = c & 1 ? 3988292384 ^ c >>> 1 : c >>> 1;
      }
      _constants._crcTable[n] = c;
    }
    return _constants._crcTable;
  }
  static crc32(str) {
    var crcTable = _constants.CRCTable;
    var crc = 0 ^ -1;
    for (var i = 0; i < str.length; i++) {
      crc = crc >>> 8 ^ crcTable[(crc ^ str.charCodeAt(i)) & 255];
    }
    return (crc ^ -1) >>> 0;
  }
  static setCookie(cname, cvalue, exdays) {
    let d = /* @__PURE__ */ new Date();
    d.setTime(d.getTime() + exdays * 24 * 60 * 60 * 1e3);
    let expires = "expires=" + d.toUTCString();
    document.cookie = cname + "=" + cvalue + ";" + expires + ";path=/";
  }
  static getCookie(cname) {
    let name = cname + "=";
    let decodedCookie = decodeURIComponent(document.cookie);
    let ca = decodedCookie.split(";");
    for (let i = 0; i < ca.length; i++) {
      let c = ca[i];
      while (c.charAt(0) == " ") {
        c = c.substring(1);
      }
      if (c.indexOf(name) == 0) {
        return c.substring(name.length, c.length);
      }
    }
    return null;
  }
  //#ifndef READONLY
  static XMLquote(st) {
    return st.replace("'", "&apos;").replace('"', "&quot;");
  }
  static GetXMLConfiguration() {
    let res = '<Config>\n  <UseUSB value="' + (_constants._useUSB ? "TRUE" : "FALSE") + '"/>\n  <UseVirtualHub value="' + (_constants._useVirtualHub ? "TRUE" : "FALSE") + '"/>\n  <Hubs>\n';
    res += sensorsManager.getXmlHublist();
    res += "  </Hubs>\n";
    res += "  <Colors>\n";
    for (let i = 0; i < colorEditor.colorHistory.length; i++) {
      res = res + '    <Color value="' + colorEditor.colorHistory[i].toString() + '"/>\n';
    }
    res += "  </Colors>\n";
    res += "  <MemoryUsage>\n";
    res += '    <maxPointsPerGraphSerie value= "' + _constants.maxPointsPerGraphSerie.toString() + '"/>\n';
    res += '    <maxDataRecordsPerSensor value= "' + _constants.maxDataRecordsPerSensor.toString() + '"/>\n';
    res += '    <maxPointsPerDataloggerSerie value= "' + _constants.maxPointsPerDataloggerSerie.toString() + '"/>\n';
    res += '    <deviceListValidity value= "' + _constants._deviceListValidity.toString() + '"/>\n';
    res += "  </MemoryUsage>\n";
    res += "  <Capture>\n";
    res += '    <Target value= "' + _constants._captureTarget.toString + '"/>\n';
    res += '    <Type value= "' + _constants.captureType.toString + '"/>\n';
    res += '    <Size value= "' + _constants.captureSizePolicy.toString + '"/>\n';
    res += '    <Resolution value= "' + _constants.captureDPI.toString() + '"/>\n';
    res += '    <Folder value= "' + _constants.XMLquote(_constants._captureFolder) + '"/>\n';
    res += '    <Width value= "' + _constants.captureWidth.toString() + '"/>\n';
    res += '    <Height value= "' + _constants.captureHeight.toString() + '"/>\n';
    res += "  </Capture>\n";
    res += "  <Updates>\n";
    res += '    <checkForUpdate  value = "' + (_constants._checkForUpdate ? "True" : "False") + '"/>\n';
    res += '    <ignoreBuild  value = "' + _constants._ignoreBuild.toString() + '"/>\n';
    res += "  </Updates>\n";
    res += "  <UI>\n";
    res += '    <VerticalDragZoom value= "' + (YGraph.verticalDragZoomEnabled ? "True" : "False") + '"/>\n';
    res += '    <DbleClickContextMenu value= "' + (_constants.dbleClickBringsUpContextMenu ? "True" : "False") + '"/>\n';
    res += "  </UI>\n";
    res += "</Config>\n";
    return res;
  }
};
constants.DPIFactorKey = "YoctoVisualization4WebDPIFactor";
constants.isAndroid = navigator.userAgent.toLowerCase().indexOf("android") >= 0;
constants.ScreenDPI = constants.findDPI();
constants.FontFamily = "Arial, Helvetica, sans-serif";
constants.DPIfactorCookieValue = constants.getCookie(constants.DPIFactorKey);
constants.DPIfactorOverriden = constants.DPIfactorCookieValue != null;
constants.DPIfactor = constants.DPIfactorOverriden && parseFloat(constants.DPIfactorCookieValue) > 0 ? parseFloat(constants.DPIfactorCookieValue) : constants.isPhoneOrTablet ? Math.round(10 * constants.ScreenDPI / (96 * 1.2)) / 10 : 1;
constants.FontSize = 12 * constants.DPIfactor;
constants._defaultCaptureType = YDataRenderer.CaptureType.PNG;
constants._defaultCaptureWidth = 1024;
constants._defaultCaptureHeight = 1024;
constants._defaultCaptureDPI = 70;
constants._defaultCaptureSizePolicy = YDataRenderer.CaptureFormats.Keep;
constants._defaultMaxPointsPerGraphSerie = 0;
constants._defaultMaxPointsPerDataloggerSerie = 0;
constants._defaultMaxDataRecordsPerSensor = 0;
constants._defaulDbleClickBringsUpContextMenu = false;
constants._useUSB = true;
constants._useVirtualHub = false;
constants._captureTarget = YDataRenderer.CaptureTarget.ToFile;
constants._captureFolder = "";
constants._checkForUpdate = true;
constants._ignoreBuild = 0;
constants._deviceListValidity = 3600;
constants._edited = false;
constants._crcTable = null;

// obj/full/sensorManager.js
var Hub = class _Hub {
  // not really crypto functions, but since source code will end up in the client browser,
  // there is no point in using techniques more complicated than obfuscation
  static Decrypt(data, loginCypherPassword) {
    if (data == "")
      return "";
    if (data.length % 4)
      return "";
    let buffer = new Uint16Array(data.length >> 2);
    for (let i = 0; i < buffer.length; i++) {
      buffer[i] = parseInt(data.slice(i * 4, i * 4 + 4), 16);
    }
    let checksum = buffer[0];
    for (let i = 1; i < buffer.length - 1; i++) {
      checksum ^= buffer[i];
    }
    if (checksum != buffer[buffer.length - 1])
      return "";
    let res = "";
    for (let i = 0; i < buffer.length - 2; i++) {
      res += String.fromCharCode(buffer[i + 1] & 255 ^ loginCypherPassword.charCodeAt(i % loginCypherPassword.length) ^ buffer[0] + i & 255 ^ (buffer[i + 1] & 2048) >> 11 << ((buffer[i + 1] & 1792) >> 8) ^ (buffer[i + 1] & 32768) >> 15 << ((buffer[i + 1] & 28672) >> 12));
    }
    return res;
  }
  static Encrypt(data, loginCypherPassword) {
    if (data == "")
      return "";
    let buffer = crypto.getRandomValues(new Uint16Array(data.length + 2));
    for (let i = 0; i < data.length; i++) {
      buffer[i + 1] = buffer[i + 1] & 65280 | data.charCodeAt(i) ^ loginCypherPassword.charCodeAt(i % loginCypherPassword.length) ^ buffer[0] + i & 255 ^ (buffer[i + 1] & 2048) >> 11 << ((buffer[i + 1] & 1792) >> 8) ^ (buffer[i + 1] & 32768) >> 15 << ((buffer[i + 1] & 28672) >> 12);
    }
    buffer[buffer.length - 1] = buffer[0];
    for (let i = 1; i < buffer.length - 1; i++) {
      buffer[buffer.length - 1] ^= buffer[i];
    }
    let res = "";
    for (let i = 0; i < buffer.length; i++) {
      res += ("000" + buffer[i].toString(16)).slice(-4).toUpperCase();
    }
    return res;
  }
  static encryptPassword(clearPassword) {
    return clearPassword == "" ? "" : _Hub.Encrypt(clearPassword, _Hub.loginCypherPassword);
  }
  get hubType() {
    return this._hubType;
  }
  set hubType(value) {
    this._hubType = value;
  }
  get protocol() {
    return this._protocol;
  }
  set protocol(value) {
    this._protocol = value;
  }
  get user() {
    return this._user;
  }
  set user(value) {
    this._user = value;
  }
  get encryptedPassword() {
    return this._password;
  }
  set encryptedPassword(value) {
    this._password = value;
  }
  get clearPassword() {
    return this._password == "" ? "" : _Hub.Decrypt(this._password, _Hub.loginCypherPassword);
  }
  set clearPassword(value) {
    this._password = value == "" ? "" : _Hub.encryptPassword(value);
  }
  get addr() {
    return this._addr;
  }
  set addr(value) {
    this._addr = value;
  }
  get port() {
    return this._port;
  }
  set port(value) {
    this._port = value;
  }
  get removable() {
    return this._removable;
  }
  set removable(value) {
    this._removable = value;
  }
  get path() {
    return this._path;
  }
  set path(value) {
    this._path = value;
  }
  async ConnectionState() {
    if (this._apiHub != null) {
      if (await this._apiHub.get_errorType() != YAPI_SUCCESS) {
        this._state = 3;
      }
    }
    return this._state;
  }
  async ConnectionDescription() {
    switch (this._state) {
      case 1:
        if (this._apiHub != null) {
          if (await this._apiHub.get_errorType() != YAPI_SUCCESS) {
            this._state = 3;
            return await this._apiHub.get_errorMessage();
          }
        }
        return "Connecting..";
        break;
      case 2:
        return (this._logicname != "" ? this._logicname : this._netname) + " OK";
      case 3:
        if (this._apiHub != null)
          return await this._apiHub.get_errorMessage();
        return "Connection failed ";
      default:
        return "Not connected.";
    }
  }
  constructor(hubType, protocol, user, password, clearPassword, addr, port, path, removeable) {
    this._netname = "";
    this._module = null;
    this._logicname = "";
    this._previousURL = "";
    this._previousobfuscatedURL = "";
    this._apiHub = null;
    this._hubType = 2;
    this._protocol = "";
    this._user = "";
    this._password = "";
    this._addr = "";
    this._port = "";
    this._removable = true;
    this._path = "";
    this._state = 0;
    while (/^\//.test(path)) {
      path = path.slice(1);
    }
    while (/\/$/.test(path)) {
      path = path.slice(0, -1);
    }
    this._hubType = hubType;
    this._protocol = protocol;
    this._user = user;
    this._port = port;
    this._password = clearPassword ? password != "" ? _Hub.Encrypt(password, _Hub.loginCypherPassword) : "" : password;
    this._addr = addr;
    this._path = path;
    this._removable = typeof removeable === "undefined" ? true : removeable;
  }
  static HubFromXml(subnode) {
    let hubType = 2;
    let protocol = "ws";
    let removable = true;
    if ("protocol" in subnode.Attributes)
      protocol = subnode.Attributes["protocol"];
    let user = "";
    if ("user" in subnode.Attributes)
      user = subnode.Attributes["user"];
    let password = "";
    if ("password" in subnode.Attributes)
      password = subnode.Attributes["password"];
    let port = "";
    if ("port" in subnode.Attributes)
      port = subnode.Attributes["port"];
    let path = "";
    if ("path" in subnode.Attributes)
      path = subnode.Attributes["path"];
    let addr = "";
    if ("addr" in subnode.Attributes)
      addr = subnode.Attributes["addr"];
    if ("removable" in subnode.Attributes)
      removable = subnode.Attributes["removable"].toUpperCase() == "TRUE";
    return new _Hub(hubType, protocol, user, password, false, addr, port, path, removable);
  }
  async Connect() {
    let errmsg = new YErrorMsg();
    this._state = 1;
    logForm.log("preregistering  " + this.get_obfuscatedURL());
    if (!YWebPage.readonly)
      configForm.hubStateChanged(this);
    let url = this.get_fullUrl();
    if (await YAPI.PreregisterHub(url, errmsg) != YAPI_SUCCESS) {
      logForm.log("[!] preregistering  " + this.get_obfuscatedURL() + " failed (" + errmsg.msg + ")");
      this._state = 3;
      this._previousURL = "";
      this._previousobfuscatedURL = "";
    } else {
      let h = YHub.FirstHubInUse();
      while (h != null) {
        if (await this.matches(h))
          this._apiHub = h;
        h = h.nextHubInUse();
      }
      this._previousURL = url;
      this._previousobfuscatedURL = this.get_obfuscatedURL();
    }
    if (!YWebPage.readonly)
      configForm.hubStateChanged(this);
  }
  async Disconnect() {
    if (this._previousURL == "")
      return;
    logForm.log("Unregistering  " + this._previousobfuscatedURL);
    await YAPI.UnregisterHub(this._previousURL);
    this._previousURL = "";
    this._previousobfuscatedURL = "";
    this._state = 0;
    this._apiHub = null;
    if (!YWebPage.readonly)
      configForm.hubStateChanged(this);
  }
  arrival(ip, netname, module, logicname) {
    this._state = 2;
    this._netname = netname;
    this._module = module;
    this._logicname = logicname;
    this._state = 2;
    if (!YWebPage.readonly) {
      configForm.hubStateChanged(this);
    }
  }
  get address() {
    return this._addr;
  }
  get_consoleUrl() {
    let fullurl = this._protocol + "://" + this._addr;
    if (this._port != "")
      fullurl = fullurl + ":" + this._port;
    return fullurl;
  }
  toString() {
    return this.get_consoleUrl();
  }
  get_fullUrl() {
    let fullurl = "";
    if (this._protocol != "")
      fullurl = this._protocol + "://";
    if (this._user != "") {
      fullurl = fullurl + this._user;
      if (this._password != "")
        fullurl = fullurl + ":" + _Hub.Decrypt(this._password, _Hub.loginCypherPassword);
      fullurl = fullurl + "@";
    }
    fullurl = fullurl + this._addr;
    if (this._port != "")
      fullurl = fullurl + ":" + this._port;
    else
      fullurl = fullurl + ":4444";
    fullurl = fullurl + "/";
    if (this._path) {
      fullurl = fullurl + this._path + "/";
    }
    return fullurl;
  }
  get_connexionUrl() {
    let fullurl;
    if (this._protocol != "")
      fullurl = this._protocol + "://";
    else
      fullurl = "ws://";
    fullurl = fullurl + this._addr;
    if (this._port != "")
      fullurl = fullurl + ":" + this._port;
    else
      fullurl = fullurl + ":4444";
    fullurl = fullurl + "/";
    return fullurl.toLowerCase();
  }
  get_obfuscatedURL() {
    let fullurl = "";
    if (this._protocol != "")
      fullurl = this._protocol + "://";
    if (this._user != "") {
      fullurl = fullurl + this._user;
      if (this._password != "")
        fullurl = fullurl + ":#####";
      fullurl = fullurl + "@";
    }
    fullurl = fullurl + this._addr;
    if (this._port != "")
      fullurl = fullurl + ":" + this._port;
    if (this._path != "")
      fullurl = fullurl + "/" + this._path;
    return fullurl;
  }
  async matches(apihub) {
    let URL1 = this.get_connexionUrl() + this._path;
    let URL2 = await apihub.get_connectionUrl();
    if (URL1.slice(-1) == "/")
      URL1 = URL1.substr(0, URL1.length - 1);
    if (URL2.slice(-1) == "/")
      URL2 = URL2.substr(0, URL2.length - 1);
    return URL1 == URL2;
  }
  //#ifndef READONLY
  XmlCode() {
    let NodeLine = "<Hub ";
    if (this._protocol != "")
      NodeLine = NodeLine + 'protocol="' + constants.XMLquote(this._protocol) + '" ';
    if (this._user != "")
      NodeLine = NodeLine + 'user="' + constants.XMLquote(this._user) + '" ';
    if (this._password != "")
      NodeLine = NodeLine + 'password="' + constants.XMLquote(this._password) + '" ';
    NodeLine = NodeLine + 'addr="' + constants.XMLquote(this._addr) + '" ';
    if (this._port != "")
      NodeLine = NodeLine + 'port="' + constants.XMLquote(this.port) + '" ';
    if (this._path != "")
      NodeLine = NodeLine + 'path="' + constants.XMLquote(this._path) + '" ';
    if (!this._removable)
      NodeLine = NodeLine + 'removable="FALSE" ';
    return NodeLine + "/>";
  }
};
Hub.loginCypherPassword = "+>*X[?_ih$N7wA!}";
var TimedSensorValue = class {
  constructor(DateTime, value) {
    this._DateTime = DateTime;
    this._value = value;
  }
  get DateTime() {
    return this._DateTime;
  }
  get value() {
    return this._value;
  }
};
var AlarmSettings = class {
  static ExecuteCommand(source, command) {
  }
  constructor(index, owner, xmldata) {
    this.index = 0;
    this.Condition = 0;
    this.Source = 0;
    this.Value = 0;
    this.Delay = 15;
    this.Commandline = "";
    this.lastAlarm = /* @__PURE__ */ new Date(0);
    this.index = index;
    this.parent = owner;
    if (typeof xmldata !== "undefined") {
      if ("Source" in xmldata.Attributes)
        this.Source = parseInt(xmldata.Attributes["Source"]);
      if ("Condition" in xmldata.Attributes)
        this.Condition = parseInt(xmldata.Attributes["Condition"]);
      if ("Value" in xmldata.Attributes)
        this.Value = parseFloat(xmldata.Attributes["Value"]);
      if ("Cmd" in xmldata.Attributes)
        this.Commandline = xmldata.Attributes["Cmd"];
      if ("Delay" in xmldata.Attributes)
        this.Delay = parseInt(xmldata.Attributes["Delay"]);
    }
  }
  //#ifndef READONLY
  getXmlData() {
    return '<Alarm Source="' + this.Source.toString() + '" Condition="' + this.Condition.toString() + '" Value="' + this.Value.toString() + '" Cmd="' + GenericProperties.escapeXml(this.Commandline) + '" Delay="' + this.Delay.toString() + '"/>\n';
  }
  //#endif
  setCondition(condition) {
    this.Condition = condition;
  }
  getCondition() {
    return this.Condition;
  }
  setSource(source) {
    this.Source = source;
  }
  getSource() {
    return this.Source;
  }
  setValue(value) {
    this.Value = value;
  }
  getValue() {
    return this.Value;
  }
  setDelay(value) {
    if (value < 0)
      throw "delay must be a positive value";
    this.Delay = value;
  }
  getDelay() {
    return this.Delay;
  }
  setCommandline(value) {
    this.Commandline = value;
  }
  getCommandline() {
    return this.Commandline;
  }
  check(m) {
    let alarm = false;
    let reason = "";
    let src;
    let SensorValue;
    switch (this.Source) {
      case 1:
        src = "MIN";
        SensorValue = m.get_minValue();
        break;
      case 2:
        src = "MAX";
        SensorValue = m.get_maxValue();
        break;
      default:
        src = "AVG";
        SensorValue = m.get_averageValue();
        break;
    }
    switch (this.Condition) {
      default:
        return;
      // alarm disabled
      case 1:
        reason = ">";
        if (SensorValue > this.Value)
          alarm = true;
        break;
      case 2:
        reason = ">=";
        if (SensorValue >= this.Value)
          alarm = true;
        break;
      case 3:
        reason = "=";
        if (SensorValue == this.Value)
          alarm = true;
        break;
      case 4:
        reason = "<=";
        if (SensorValue <= this.Value)
          alarm = true;
        break;
      case 5:
        reason = "<";
        if (SensorValue < this.Value)
          alarm = true;
        break;
    }
    let now = /* @__PURE__ */ new Date();
    if (!alarm)
      return;
    if (now.getTime() - this.lastAlarm.getTime() < 1e3 * this.Delay)
      return;
    let source = "ALARM " + (this.index + 1).toString();
    logForm.log(source + " on " + this.parent.get_hardwareId() + "/" + this.parent.get_friendlyName() + " (" + SensorValue.toString() + reason + this.Value.toString() + ")");
    let Execute = this.Commandline;
    Execute = Execute.replace("$SENSORVALUE$", SensorValue.toString());
    Execute = Execute.replace("$HWDID$", this.parent.get_hardwareId());
    Execute = Execute.replace("$NAME$", this.parent.get_friendlyName());
    Execute = Execute.replace("$UNIT$", this.parent.get_unit());
    Execute = Execute.replace("$CONDITION$", reason);
    Execute = Execute.replace("$DATATYPE$", src);
    Execute = Execute.replace("$TRIGGER$", this.Value.toString());
    Execute = Execute.replace("$NOW$", logForm.dateToString(now));
    try {
      Function(Execute)();
    } catch (e) {
      logForm.log("ALARM " + (this.index + 1) + " code (" + Execute + ") caused an exception :" + e.message);
    }
    this.lastAlarm = now;
  }
};
var DataLoggerBoundary = class {
  constructor(start, stop) {
    this._start = 0;
    this._stop = 0;
    this._start = start;
    this._stop = stop;
  }
  get start() {
    return this._start;
  }
  get stop() {
    return this._stop;
  }
};
var MergeSourceRange = class {
  constructor(start, stop) {
    this.MergeSourceStart = 0;
    this.MergeSourceStop = 0;
    this.MergeSourceStart = start;
    this.MergeSourceStop = stop;
  }
};
var CustomYSensor = class _CustomYSensor {
  get isReadOnly() {
    return this._readonly || !this._online;
  }
  get dataloggerLoadisRunning() {
    return this._dataloggerLoadisRunning;
  }
  get dataloggerLoadProgress() {
    return this._dataloggerLoadProgress;
  }
  setDataloggerLoadProgress(value) {
    this._dataloggerLoadProgress = value;
    for (let i = 0; i < this.FormsToNotify.length; i++) {
      if (this.FormsToNotify[i] instanceof graphWidget) {
        this.FormsToNotify[i].dataLoggerLoadprocessIsRunningNotification(this);
      }
    }
  }
  static get MaxDataRecords() {
    return _CustomYSensor._MaxDataRecords;
  }
  static set MaxDataRecords(value) {
    _CustomYSensor._MaxDataRecords = value;
  }
  static get MaxLoggerRecords() {
    return _CustomYSensor._MaxLoggerRecords;
  }
  static set MaxLoggerRecords(value) {
    _CustomYSensor._MaxLoggerRecords = value;
  }
  get_lastAvgValue() {
    if (this._online)
      return this._lastAvgValue;
    return Number.NaN;
  }
  get_lastMaxValue() {
    if (this._online)
      return this._lastMaxValue;
    return Number.NaN;
  }
  get_lastMinValue() {
    if (this._online)
      return this._lastMinValue;
    return Number.NaN;
  }
  async ConfigHasChanged() {
    this.cfgChgNotificationsSupported = true;
    this.mustReloadConfig = true;
    this._online = true;
    await this.reloadConfig();
    await this.forceUpdate();
  }
  constructor(s, name, SensorLocalConfig) {
    this.unit = "";
    this._frequency = "";
    this.resolution = 1;
    this._recording = false;
    this._online = false;
    this.preloadDone = false;
    this.loadDone = false;
    this.cfgChgNotificationsSupported = false;
    this.mustReloadConfig = false;
    this._readonly = false;
    this._plzCancelDataloggerLoading = false;
    this._predloadProcessIsBusy = false;
    this._loadProcessIsBusy = false;
    this.lastGetConfig = 0;
    this.recordedDataLoadProgress = 0;
    this.recordedData = null;
    this.dataLoggerFeature = false;
    this.dataLoggerLoadCompleted = false;
    this.loadFailed = false;
    this.loadCanceled = false;
    this.firstLiveDataTimeStamp = 0;
    this.firstDataloggerTimeStamp = 0;
    this.lastDataTimeStamp = 0;
    this.lastDataSource = "";
    this.consecutiveBadTimeStamp = 0;
    this.minData = [];
    this.curData = [];
    this.maxData = [];
    this.previewMinData = [];
    this.previewCurData = [];
    this.previewMaxData = [];
    this._lastAvgValue = Number.NaN;
    this._lastMinValue = Number.NaN;
    this._lastMaxValue = Number.NaN;
    this._dataloggerLoadisRunning = true;
    this._dataloggerLoadProgress = 0;
    this.dataLoggerStartReadTime = 0;
    this.Alarms = [];
    this.FormsToNotify = [];
    this.sensor = s;
    this.hwdName = name;
    this._friendlyname = name;
    if (s == null)
      return;
    if (SensorLocalConfig != null) {
      let index = 0;
      let childs = SensorLocalConfig.get_childsByIndex();
      for (let i = 0; i < childs.length; i++) {
        let n = childs[i];
        if (n.Name == "Alarm") {
          this.checkAlarmIndex(index);
          this.Alarms[index] = new AlarmSettings(index, this, n);
          index++;
        }
      }
    }
  }
  checkAlarmIndex(index) {
    while (this.Alarms.length < index + 1) {
      this.Alarms.push(new AlarmSettings(this.Alarms.length, this));
    }
  }
  getAlarmCount() {
    return this.Alarms.length;
  }
  setAlarmCondition(index, condition) {
    this.checkAlarmIndex(index);
    this.Alarms[index].setCondition(condition);
  }
  getAlarmCondition(index) {
    this.checkAlarmIndex(index);
    return this.Alarms[index].getCondition();
  }
  setAlarmSource(index, source) {
    this.checkAlarmIndex(index);
    this.Alarms[index].setSource(source);
  }
  getAlarmSource(index) {
    this.checkAlarmIndex(index);
    return this.Alarms[index].getSource();
  }
  setAlarmValue(index, value) {
    this.checkAlarmIndex(index);
    this.Alarms[index].setValue(value);
  }
  getAlarmValue(index) {
    this.checkAlarmIndex(index);
    return this.Alarms[index].getValue();
  }
  setAlarmDelay(index, value) {
    this.checkAlarmIndex(index);
    this.Alarms[index].setDelay(value);
  }
  getAlarmDelay(index) {
    this.checkAlarmIndex(index);
    return this.Alarms[index].getDelay();
  }
  setAlarmCommandline(index, value) {
    this.checkAlarmIndex(index);
    this.Alarms[index].setCommandline(value);
  }
  getAlarmCommandline(index) {
    this.checkAlarmIndex(index);
    return this.Alarms[index].getCommandline();
  }
  //#ifndef READONLY
  GetXmlData() {
    let res = '<Sensor ID="' + this.get_hardwareId() + '">\n';
    for (let i = 0; i < this.getAlarmCount(); i++) {
      res = res + this.Alarms[i].getXmlData();
    }
    res = res + "</Sensor>\n";
    return res;
  }
  //#endif
  get_firstLiveDataTimeStamp() {
    return this.firstLiveDataTimeStamp;
  }
  get_firstDataloggerTimeStamp() {
    return this.firstDataloggerTimeStamp;
  }
  get_lastDataTimeStamp() {
    return this.lastDataTimeStamp;
  }
  async preload_DoWork(arg) {
    if (this._predloadProcessIsBusy) {
      console.log("!!! multiple datalogger load attempt");
      return;
    }
    if (this.dataLoggerLoadCompleted) {
      console.log("!!!  datalogger load attempt although datalogger is already loaded.");
      return;
    }
    this._predloadProcessIsBusy = true;
    logForm.log(this.hwdName + ": preloading data from " + arg.start.toString() + " to " + arg.stop.toString() + "(delta= " + (arg.stop - arg.start).toFixed(3) + ")");
    this.setDataloggerLoadProgress(1);
    this.recordedData = await this.sensor.get_recordedData(arg.start, arg.stop);
    try {
      this.recordedDataLoadProgress = await this.recordedData.loadMore();
    } catch (e) {
      logForm.log(this.hwdName + ": load more caused an exception " + e.message);
    }
    let measures = await this.recordedData.get_preview();
    this.previewMinData = [];
    this.previewCurData = [];
    this.previewMaxData = [];
    let startIndex = 0;
    let errCount = 0;
    let maxErrorCount = 10;
    let lastT = -1;
    if (_CustomYSensor._MaxDataRecords > 0 && measures.length > _CustomYSensor._MaxDataRecords)
      startIndex = measures.length - _CustomYSensor._MaxDataRecords;
    for (let i = startIndex; i < measures.length; i++) {
      let t = measures[i].get_endTimeUTC();
      if (t >= arg.start && t <= arg.stop) {
        this.previewMinData.push(new TimedSensorValue(t, measures[i].get_minValue()));
        this.previewCurData.push(new TimedSensorValue(t, measures[i].get_averageValue()));
        this.previewMaxData.push(new TimedSensorValue(t, measures[i].get_maxValue()));
        if (t < lastT && errCount < maxErrorCount) {
          logForm.log(this.hwdName + " preloading warning:  timestamp going back in time " + t + "<" + lastT + (errCount < maxErrorCount - 1 ? "" : ", further similar errors wont be logged."));
          errCount++;
        } else if (t == lastT && errCount < maxErrorCount) {
          logForm.log(this.hwdName + " preloading warning: duplicate timestamp  " + t + (errCount < maxErrorCount - 1 ? "" : ", further similar errors wont be logged."));
          errCount++;
        }
        lastT = t;
      }
    }
    if (this.previewCurData.length > 1) {
      let a = this.previewCurData[0].DateTime;
      let b = this.previewCurData[this.previewCurData.length - 1].DateTime;
      logForm.log(this.hwdName + ": preloaded data from " + a.toString() + " to " + b.toString() + " (delta=" + (b - a).toFixed(3) + ")");
      if (_CustomYSensor._MaxLoggerRecords > 0 && arg.start == 0) {
        let list = await this.recordedData.get_privateDataStreams();
        let index = list.length - 1;
        let totalRecords = 0;
        while (index > 0 && totalRecords < _CustomYSensor._MaxLoggerRecords) {
          totalRecords += await list[index].get_rowCount();
          this.dataLoggerStartReadTime = await list[index].get_startTimeUTC();
          index--;
        }
        let n = 0;
        while (n < this.previewMinData.length && this.previewMinData[n].DateTime < this.dataLoggerStartReadTime) {
          n++;
        }
        if (n > 1) {
          this.previewMinData.splice(0, n - 1);
          this.previewCurData.splice(0, n - 1);
          this.previewMaxData.splice(0, n - 1);
        }
      }
    }
    this.preload_Completed(arg);
  }
  findMergeBoundaries(previewMinData) {
    let MergeSourceStart = 0;
    let MergeSourceStop = 0;
    if (this.minData.length > 0) {
      while (MergeSourceStart < this.minData.length && previewMinData[0].DateTime > this.minData[MergeSourceStart].DateTime) {
        MergeSourceStart++;
      }
      MergeSourceStop = MergeSourceStart;
      while (MergeSourceStop < this.minData.length && previewMinData[previewMinData.length - 1].DateTime >= this.minData[MergeSourceStop].DateTime) {
        MergeSourceStop++;
      }
    }
    return new MergeSourceRange(MergeSourceStart, MergeSourceStop);
  }
  preload_Completed(arg) {
    if (this.previewMinData == null)
      return;
    logForm.log(this.hwdName + " : datalogger preloading completed (" + this.previewMinData.length + " rows)");
    if (this.previewMinData.length > 1) {
      let it = this.findMergeBoundaries(this.previewMinData);
      let insertIndex = it.MergeSourceStart;
      let deleteCount = it.MergeSourceStop - it.MergeSourceStart;
      this.minData = this.minData.slice(0, insertIndex).concat(this.previewMinData, this.minData.slice(insertIndex + deleteCount));
      this.curData = this.curData.slice(0, insertIndex).concat(this.previewCurData, this.curData.slice(insertIndex + deleteCount));
      this.maxData = this.maxData.slice(0, insertIndex).concat(this.previewMaxData, this.maxData.slice(insertIndex + deleteCount));
      for (let i = 0; i < this.FormsToNotify.length; i++) {
        if (this.FormsToNotify[i] instanceof graphWidget) {
          this.FormsToNotify[i].SensorNewDataBlock(this, it.MergeSourceStart, it.MergeSourceStart + this.previewMinData.length - 1, 0, true);
        }
      }
    }
    let count = this.curData.length;
    if (count > 0) {
      if (this.curData[count - 1].DateTime > this.lastDataTimeStamp) {
        this.lastDataTimeStamp = this.curData[count - 1].DateTime;
        this.lastDataSource = "last preload timestamp";
      }
    }
    logForm.log(this.hwdName + " : start datalogger loading");
    this._predloadProcessIsBusy = false;
    this.load_DoWork(arg).then();
  }
  get_frequency() {
    return this._frequency;
  }
  async updateFrequncy(frequencyToSet) {
    if (await this.sensor.isOnline()) {
      this._frequency = frequencyToSet;
      await this.sensor.set_reportFrequency(this._frequency);
      let lfreq = await this.sensor.get_logFrequency();
      try {
        if (lfreq != "OFF")
          await this.sensor.set_logFrequency(this._frequency);
        let m = await this.sensor.get_module();
        await m.saveToFlash();
      } catch (e) {
        logForm.log("failed to change " + this.hwdName + " log frequency (" + e.message + ")");
      }
    } else {
      this._online = false;
    }
  }
  set_frequency(frequencyToSet) {
    if (this._online) {
      this.updateFrequncy(frequencyToSet).then();
    }
  }
  get_recording() {
    return this._recording;
  }
  set_recording(recordingStatus) {
    this.updaterecording(recordingStatus).then();
  }
  async updaterecording(recordingStatus) {
    if (!this.dataLoggerFeature)
      return;
    if (await this.sensor.isOnline()) {
      this._recording = recordingStatus;
      try {
        await this.sensor.set_logFrequency(this._recording ? this._frequency : "OFF");
        let module = await this.sensor.get_module();
        let serial = await module.get_serialNumber();
        let dl = YDataLogger.FindDataLogger(serial + ".dataLogger");
        await dl.set_recording(this._recording ? YDataLogger.RECORDING_ON : YDataLogger.RECORDING_OFF);
        await dl.set_autoStart(this._recording ? YDataLogger.AUTOSTART_ON : YDataLogger.AUTOSTART_OFF);
        await module.saveToFlash();
      } catch (e) {
        logForm.log("failed to change " + this.hwdName + " recording (" + e.message + ")");
      }
    } else {
      this._online = false;
    }
  }
  reportDataloggerLoadProgress(progress) {
  }
  async load_DoWork(arg) {
    if (this._loadProcessIsBusy)
      return;
    this._loadProcessIsBusy = true;
    if (this.dataLoggerLoadCompleted)
      return;
    logForm.log(this.hwdName + " loading main data from datalogger");
    if (this.dataLoggerStartReadTime > 0) {
      this.recordedData = await this.sensor.get_recordedData(this.dataLoggerStartReadTime, 0);
    }
    let errCount = 0;
    let maxErrorCount = 10;
    let lastT = -1;
    let lastProgress = this.recordedDataLoadProgress;
    while (this.recordedDataLoadProgress < 100) {
      if (this._plzCancelDataloggerLoading) {
        this.loadDone = true;
        this.loadFailed = false;
        this.loadCanceled = true;
        this.setDataloggerLoadProgress(100);
        break;
      }
      try {
        this.recordedDataLoadProgress = await this.recordedData.loadMore();
      } catch (Exception) {
        this.loadFailed = true;
        return;
      }
      if (lastProgress != this.recordedDataLoadProgress) {
        lastProgress = this.recordedDataLoadProgress;
        let p = lastProgress;
        if (p < 1)
          p = 1;
        if (p > 99)
          p = 99;
        this.setDataloggerLoadProgress(p < 1 ? 1 : p > 99 ? 99 : p);
      }
      if (this.recordedDataLoadProgress - lastProgress >= 2) {
        lastProgress = this.recordedDataLoadProgress;
      }
    }
    let measures = await this.recordedData.get_measures();
    this.previewMinData = [];
    this.previewCurData = [];
    this.previewMaxData = [];
    for (let i = 0; i < measures.length; i++) {
      let t = measures[i].get_endTimeUTC();
      if (t >= arg.start && t <= arg.stop) {
        if (t < lastT && errCount < maxErrorCount) {
          logForm.log(this.hwdName + " loading warning:  timestamp going back in time " + t + "<" + lastT + (errCount < maxErrorCount - 1 ? "" : ", further similar errors wont be logged."));
          errCount++;
        } else if (t == lastT && errCount < maxErrorCount) {
          logForm.log(this.hwdName + " loading warning: duplicate timestamp  " + t + (errCount < maxErrorCount - 1 ? "" : ", further similar errors wont be logged."));
          errCount++;
        }
        lastT = t;
        if (this.previewMinData.length == 0 || t > this.previewMinData[this.previewMinData.length - 1].DateTime) {
          this.previewMinData.push(new TimedSensorValue(t, measures[i].get_minValue()));
          this.previewCurData.push(new TimedSensorValue(t, measures[i].get_averageValue()));
          this.previewMaxData.push(new TimedSensorValue(t, measures[i].get_maxValue()));
        }
      } else {
        let d = new Date(t * 1e3);
        let d1 = new Date(arg.start * 1e3);
        let d2 = new Date(arg.stop * 1e3);
        let dstr = d.toLocaleDateString() + " " + d.toLocaleTimeString();
        let d1str = d1.toLocaleDateString() + " " + d1.toLocaleTimeString();
        let d2str = d2.toLocaleDateString() + " " + d2.toLocaleTimeString();
        logForm.log(this.hwdName + " note: skipping measure at " + dstr + ", not in range " + d1str + " ... " + d2str);
      }
    }
    if (_CustomYSensor._MaxDataRecords > 0)
      this.previewDataCleanUp();
    for (let i = 0; i < this.previewMinData.length - 1; i++) {
      if (this.previewMinData[i].DateTime >= this.previewMinData[i + 1].DateTime) {
        throw "Time-stamp inconsistency";
      }
    }
    if (this.previewCurData.length > 1) {
      logForm.log(this.hwdName + " loaded " + this.previewCurData.length.toString() + "/" + measures.length.toString() + " records over " + (this.previewCurData[this.previewCurData.length - 1].DateTime - this.previewCurData[0].DateTime).toFixed(3) + " sec, last timed stamp was " + this.previewCurData[this.previewCurData.length - 1].DateTime);
    } else {
      logForm.log(this.hwdName + " loaded " + this.previewCurData.length.toString() + " records");
    }
    if (this.previewMinData.length > 2) {
      let lastPreviewTimeStamp = this.previewMinData[this.previewMinData.length - 1].DateTime;
      let it = this.findMergeBoundaries(this.previewMinData);
      let deleteCount = it.MergeSourceStop - it.MergeSourceStart;
      this.minData = this.minData.slice(0, it.MergeSourceStart).concat(this.previewMinData, this.minData.slice(it.MergeSourceStart + deleteCount));
      this.curData = this.curData.slice(0, it.MergeSourceStart).concat(this.previewCurData, this.curData.slice(it.MergeSourceStart + deleteCount));
      this.maxData = this.maxData.slice(0, it.MergeSourceStart).concat(this.previewMaxData, this.maxData.slice(it.MergeSourceStart + deleteCount));
      this.firstDataloggerTimeStamp = this.curData[0].DateTime;
    }
    this.loadDone = true;
    this.loadFailed = false;
    let count = this.curData.length;
    if (count > 0) {
      if (this.curData[count - 1].DateTime > this.lastDataTimeStamp) {
        this.lastDataTimeStamp = this.curData[count - 1].DateTime;
        this.lastDataSource = "end of datalogger";
      }
    }
    this.load_Completed();
  }
  load_Completed() {
    logForm.log(this.hwdName + ".loadcompleted()");
    if (this.loadFailed) {
      logForm.log(this.hwdName + " : datalogger loading failed");
      this._loadProcessIsBusy = false;
      return;
    }
    if (this.loadCanceled) {
      logForm.log(this.hwdName + " : datalogger loading was canceled");
      this.previewMinData = [];
      this.previewCurData = [];
      this.previewMaxData = [];
      this.loadCanceled = false;
      this._loadProcessIsBusy = false;
      this.preloadDone = false;
      this.loadDone = false;
      return;
    }
    if (this.previewCurData.length <= 2) {
      this.preloadDone = false;
      this.loadDone = false;
    }
    logForm.log(this.hwdName + " : datalogger loading completed  (" + this.previewMinData.length + " rows)");
    this.resetDataloggerLoader();
    this.dataLoggerLoadCompleted = true;
    for (let i = 0; i < this.FormsToNotify.length; i++) {
      if (this.FormsToNotify[i] instanceof graphWidget) {
        this.FormsToNotify[i].DataloggerCompleted(this);
      }
    }
    this.setDataloggerLoadProgress(100);
  }
  get dataloggerWasUsed() {
    return this.dataLoggerLoadCompleted;
  }
  dataCleanUp() {
    if (_CustomYSensor._MaxDataRecords <= 0)
      return;
    let newsize = _CustomYSensor._MaxDataRecords * 90 / 100 >> 0;
    if (this.curData != null && _CustomYSensor._MaxDataRecords < this.curData.length) {
      this.minData.splice(0, this.minData.length - newsize);
      this.curData.splice(0, this.curData.length - newsize);
      this.maxData.splice(0, this.maxData.length - newsize);
    }
  }
  previewDataCleanUp() {
    if (_CustomYSensor._MaxDataRecords <= 0)
      return;
    let newsize = _CustomYSensor._MaxDataRecords * 90 / 100 >> 0;
    if (this.previewMinData != null && _CustomYSensor._MaxDataRecords < this.previewMinData.length) {
      this.previewMinData.splice(0, this.previewMinData.length - newsize);
      this.previewCurData.splice(0, this.previewCurData.length - newsize);
      this.previewMaxData.splice(0, this.previewMaxData.length - newsize);
    }
  }
  stopDataloggerloading() {
  }
  /*  protected load_ProgressChanged()
      {
         for (let i :number = 0; i < this.FormsToNotify.length; i++)
           if  (this.FormsToNotify[i] instanceof  YoctoVisualization.graphWidget)
            (this.FormsToNotify[i] as YoctoVisualization.graphWidget).DataLoggerProgress();
  
      }*/
  isOnline() {
    return this._online;
  }
  async reloadConfig() {
    if (this._online) {
      let ison = await this.sensor.isOnline();
      if (ison) {
        try {
          this.unit = await this.sensor.get_unit();
          this._friendlyname = await this.sensor.get_friendlyName();
          this.resolution = await this.sensor.get_resolution();
          this._frequency = await this.sensor.get_reportFrequency();
          this._readonly = await this.sensor.isReadOnly();
          if (this.dataLoggerFeature) {
            this._recording = await this.sensor.get_logFrequency() != "OFF";
          } else {
            this._recording = false;
          }
          this.lastGetConfig = YAPI.GetTickCount();
          this.mustReloadConfig = false;
        } catch (e) {
          logForm.log("reload configuration error: " + e.message);
        }
      } else {
        this._online = false;
      }
    }
  }
  get_unit() {
    if (this.cfgChgNotificationsSupported && !this.mustReloadConfig)
      return this.unit;
    if (this.lastGetConfig <= 0 || YAPI.GetTickCount() - this.lastGetConfig > 5e3)
      this.reloadConfig().then();
    return this.unit;
  }
  get_resolution() {
    if (this.cfgChgNotificationsSupported && !this.mustReloadConfig)
      return this.resolution;
    if (this.lastGetConfig <= 0 || YAPI.GetTickCount() - this.lastGetConfig > 5e3)
      this.reloadConfig().then();
    return this.resolution;
  }
  resetDataloggerLoader() {
    this._predloadProcessIsBusy = false;
    this._loadProcessIsBusy = false;
    this.dataLoggerLoadCompleted = false;
    this.preloadDone = false;
    this.loadDone = false;
    this._dataloggerLoadisRunning = false;
    this.previewMinData = [];
    this.previewCurData = [];
    this.previewMaxData = [];
  }
  loadDatalogger(start, stop) {
    if (!this.dataLoggerFeature)
      return;
    if (this._predloadProcessIsBusy)
      return;
    if (this._loadProcessIsBusy)
      return;
    if (constants.maxPointsPerDataloggerSerie < 0) {
      logForm.log(this.hwdName + " : datalogger access is disabled");
      return;
    }
    if (!this.preloadDone && this.dataLoggerFeature) {
      logForm.log(this.hwdName + " : start datalogger preloading");
      this.preload_DoWork(new DataLoggerBoundary(start, stop)).then();
    }
  }
  async arrival(dataloggerOn) {
    await this.configureSensor();
    this._online = true;
    await this.reloadConfig();
    let dt = await this.sensor.get_dataLogger();
    if (dt == null)
      return;
    let now = Math.floor((/* @__PURE__ */ new Date()).getTime() / 1e3);
    if (this.curData.length > 0 && this.dataLoggerLoadCompleted) {
      let end = await dt.get_timeUTC();
      let start = this.curData[this.curData.length - 1].DateTime;
      let duration = end - start;
      if (duration == 0) {
        start = this.curData[this.curData.length - 2].DateTime;
        duration = end - start;
      }
      if (duration > 1) {
        logForm.log(this.hwdName + " is back online trying to load " + duration.toFixed(3) + " sec of data from datalogger ");
        this.resetDataloggerLoader();
        this.loadDatalogger(start, end);
      }
    }
    if (this.isReadOnly)
      logForm.log(this.hwdName + " is read only");
    this.notifySensorStateChange();
    this.notifySensorArrival();
  }
  async startDataloggerload(source) {
    if (!this.dataLoggerFeature)
      return;
    if (this.sensor == null)
      return;
    if (this._loadProcessIsBusy)
      return;
    if (this._predloadProcessIsBusy)
      return;
    if (this.dataLoggerLoadCompleted) {
      source.DataloggerCompleted(this);
      return;
    }
    let dt = await this.sensor.get_dataLogger();
    if (dt == null)
      return;
    this.loadDatalogger(0, await dt.get_timeUTC());
  }
  notifySensorArrival() {
    for (let i = 0; i < this.FormsToNotify.length; i++) {
      this.FormsToNotify[i].SensorArrivalcallback(this);
    }
  }
  notifySensorStateChange() {
    for (let i = 0; i < this.FormsToNotify.length; i++) {
      this.FormsToNotify[i].SensorStateChangedcallback(this);
    }
  }
  removal() {
    this._online = false;
    this.forceUpdate();
    this.notifySensorStateChange();
  }
  async configureSensor() {
    logForm.log("Configuring  " + this.hwdName);
    if (!await this.sensor.isOnline())
      return;
    let mustSave = false;
    let olfreq = await this.sensor.get_logFrequency();
    let orfreq = await this.sensor.get_reportFrequency();
    let readOnly = await this.sensor.isReadOnly();
    let lfreq = olfreq;
    let rfreq = orfreq;
    let m = await this.sensor.get_module();
    for (let i = 0; i < await m.functionCount(); i++) {
      if (await m.functionType(i) == "DataLogger") {
        this.dataLoggerFeature = true;
      }
    }
    try {
      if (this.dataLoggerFeature) {
        let m2 = await this.sensor.get_module();
        let dl = YDataLogger.FindDataLogger(await m2.get_serialNumber() + ".dataLogger");
        let dataloggerOn = await dl.get_recording() != YDataLogger.RECORDING_OFF;
        let dataloggerAS = await dl.get_autoStart() != YDataLogger.AUTOSTART_OFF;
        if (!dataloggerOn) {
          lfreq = "OFF";
        }
        if (lfreq != "OFF") {
          rfreq = lfreq;
        } else if (rfreq == "OFF") {
          rfreq = "1/s";
        }
        if (lfreq != olfreq) {
          if (readOnly)
            throw new Error(this.hwdName + " is read only, cannot change its logFrequency from " + olfreq + " to " + lfreq);
          await this.sensor.set_logFrequency(lfreq);
          mustSave = true;
        }
        if (rfreq != orfreq) {
          if (readOnly)
            throw new Error(this.hwdName + " is read only, connot change its  reportFrequency from " + orfreq + " to " + rfreq);
          await this.sensor.set_reportFrequency(rfreq);
          mustSave = true;
        }
        if (lfreq != "OFF") {
          if (!dataloggerOn) {
            if (readOnly)
              throw new Error(this.hwdName + " is read only, cannot change set its  datalogger recording to ON");
            await dl.set_recording(YDataLogger.RECORDING_ON);
          }
          if (!dataloggerAS) {
            if (readOnly)
              throw new Error(this.hwdName + " is read only, cannot change set its datalogger autostart to ON");
            await dl.set_autoStart(YDataLogger.AUTOSTART_ON);
            mustSave = true;
          }
        }
      } else {
        lfreq = "OFF";
        if (rfreq == "OFF") {
          rfreq = "1/s";
          if (readOnly)
            throw new Error(this.hwdName + " is read only, connot change is reportFrequency from OFF to " + rfreq);
          await this.sensor.set_reportFrequency(rfreq);
          mustSave = true;
        }
      }
      if (mustSave)
        await m.saveToFlash();
    } catch (e) {
      logForm.log("failed to configure " + this.hwdName + "  (" + e.message + ")");
    }
    logForm.log("registering timed callback for  " + await this.sensor.get_hardwareId());
    await this.sensor.registerTimedReportCallback((callbacksource, M) => {
      this.TimedCallback(callbacksource, M);
    });
    this._recording = lfreq != "OFF";
    this._frequency = rfreq;
  }
  registerCallback(f) {
    if (this.FormsToNotify.indexOf(f) >= 0)
      return;
    this.FormsToNotify.push(f);
    return;
  }
  forceUpdate() {
    this.TimedCallback(this.sensor, null).then();
  }
  async TimedCallback(source, M) {
    this._online = true;
    if (M != null) {
      let t = M.get_endTimeUTC();
      if (this.firstLiveDataTimeStamp == 0)
        this.firstLiveDataTimeStamp = t;
      if (t > this.lastDataTimeStamp) {
        this.lastDataTimeStamp = t;
        this.lastDataSource = "last timedReport";
        this.consecutiveBadTimeStamp = 0;
      } else {
        this.consecutiveBadTimeStamp++;
        if (this.consecutiveBadTimeStamp < 10) {
          logForm.log(this.hwdName + ": ignoring bad timestamp " + t.toFixed(3) + " (previous " + this.lastDataSource + " at " + this.lastDataTimeStamp.toFixed(3) + ")");
        }
      }
      if (this.consecutiveBadTimeStamp == 0 || this.consecutiveBadTimeStamp >= 10) {
        this._lastAvgValue = M.get_averageValue();
        this._lastMinValue = M.get_minValue();
        this._lastMaxValue = M.get_maxValue();
        this.curData.push(new TimedSensorValue(t, this._lastAvgValue));
        this.minData.push(new TimedSensorValue(t, this._lastMinValue));
        this.maxData.push(new TimedSensorValue(t, this._lastMaxValue));
        if (_CustomYSensor._MaxDataRecords > 0)
          this.dataCleanUp();
      }
      for (let i = 0; i < this.Alarms.length; i++) {
        this.Alarms[i].check(M);
      }
      for (let i = 0; i < this.FormsToNotify.length; i++) {
        this.FormsToNotify[i].SensorValuecallback(this, M);
      }
    }
  }
  forgetForm(source) {
    for (let i = this.FormsToNotify.length - 1; i >= 0; i--) {
      if (source == this.FormsToNotify[i]) {
        this.FormsToNotify.splice(i, 1);
      }
    }
  }
  get_sensor() {
    return this.sensor;
  }
  get_hardwareId() {
    return this.hwdName;
  }
  get_friendlyName() {
    return this._friendlyname;
  }
  toString() {
    let name = this._friendlyname;
    if (this._readonly)
      name += " (readonly)";
    if (this._online)
      return name;
    return name + " (OFFLINE)";
  }
};
CustomYSensor._MaxDataRecords = 0;
CustomYSensor._MaxLoggerRecords = 0;
var NullYSensor = class extends CustomYSensor {
  constructor() {
    super(null, "", null);
    this.hwdName = "NOTAREALSENSOR";
    this._friendlyname = "NOTAREALSENSOR";
    this.dataLoggerFeature = false;
  }
  async preload_DoWork(arg) {
    return;
  }
  get dataloggerLoadisRunning() {
    return false;
  }
  get_unit() {
    return "";
  }
  registerCallback(Form) {
  }
  forceUpdate() {
  }
  get_frequency() {
    return "";
  }
  set_frequency(frequencyToSet) {
  }
  get_sensor() {
    return null;
  }
  toString() {
    return "(none)";
  }
  setAlarmCondition(index, condition) {
  }
  getAlarmCondition(index) {
    return 0;
  }
  setAlarmValue(index, value) {
  }
  getAlarmValue(index) {
    return 0;
  }
  setAlarmDelay(index, value) {
  }
  getAlarmDelay(index) {
    return 0;
  }
  setAlarmCommandline(index, value) {
  }
  getAlarmCommandline(index) {
    return "";
  }
};
var sensorsManager = class _sensorsManager {
  static async clearHublist() {
    for (let i = _sensorsManager._hubList.length - 1; i >= 0; i--) {
      if (_sensorsManager._hubList[i].removable) {
        await YAPI.UnregisterHub(_sensorsManager._hubList[i].get_fullUrl());
        _sensorsManager._hubList.splice(i, 1);
      }
    }
  }
  static registerChangeCallback(changeCallback) {
    this._changeCallback = changeCallback;
  }
  static registerChangeExternalCallback(changeCallback) {
    this._changeExternalCallback = changeCallback;
  }
  static forgetForm(source) {
    for (let i = 0; i < _sensorsManager.sensorList.length; i++) {
      _sensorsManager.sensorList[i].forgetForm(source);
    }
  }
  // load config data  from XML config file
  static InitHubList(node) {
    let nodes = node.get_childsByIndex();
    for (let i = 0; i < nodes.length; i++) {
      if (nodes[i].Name.toUpperCase() == "HUB") {
        let h = Hub.HubFromXml(nodes[i]);
        let alreadthere = false;
        for (let j = 0; j < _sensorsManager._hubList.length; j++) {
          if (h.get_connexionUrl() == _sensorsManager._hubList[j].get_connexionUrl())
            alreadthere = true;
        }
        if (!alreadthere) {
          _sensorsManager._hubList.push(h);
          h.Connect().then();
        }
      }
    }
  }
  static get hubList() {
    return _sensorsManager._hubList;
  }
  static hubWasremoved(h) {
    for (let i = _sensorsManager._hubList.length - 1; i >= 0; i--) {
      if (_sensorsManager._hubList[i] == h)
        _sensorsManager._hubList.splice(i, 1);
    }
  }
  static newHubCreated(h) {
    let url = h.get_connexionUrl();
    for (let i = 0; i < _sensorsManager._hubList.length; i++) {
      if (_sensorsManager._hubList[i].get_connexionUrl() == url) {
        alert("This connection already exists");
        return false;
      }
    }
    _sensorsManager._hubList.push(h);
    return true;
  }
  static removeExtraInfoFromUrl(url) {
    let it = new URL(url);
    let res = it.hostname + it.pathname;
    if (res.slice(0, 4).toLowerCase() === "www.") {
      res = res.slice(4);
    }
    return res;
  }
  static async NetworkArrival(net) {
    logForm.log("Network device detected: " + await net.get_hardwareId());
    let ip = await net.get_ipAddress();
    let netname = await net.get_logicalName();
    let module = await net.get_module();
    let loginame = await module.get_logicalName();
    let url = _sensorsManager.removeExtraInfoFromUrl(await module.get_url());
    for (let i = 0; i < _sensorsManager._hubList.length; i++) {
      let str = _sensorsManager.removeExtraInfoFromUrl(_sensorsManager.hubList[i].get_fullUrl());
      if (str == url) {
        _sensorsManager.hubList[i].arrival(ip, netname, module, loginame);
      }
    }
  }
  //#ifndef READONLY
  static getXmlHublist() {
    let res = "";
    for (let i = 0; i < _sensorsManager._hubList.length; i++) {
      res += "    " + _sensorsManager._hubList[i].XmlCode() + "\n";
    }
    return res;
  }
  static getXMLSensorsConfig() {
    let res = "<Sensors>\n";
    _sensorsManager.sensorList.forEach((s) => {
      if (!(s instanceof NullYSensor)) {
        res = res + s.GetXmlData();
      }
    });
    res = res + "</Sensors>\n";
    return res;
  }
  //#endif
  static setKnownSensors(sensorXMLList) {
    this.KnownSensors = sensorXMLList;
  }
  static FindSensorLastLocalConfig(hwdId) {
    let SensorConfig = null;
    if (_sensorsManager.KnownSensors != null) {
      let childs = _sensorsManager.KnownSensors.get_childsByIndex();
      for (let i = 0; i < childs.length; i++) {
        let node = childs[i];
        if (node.Name == "Sensor") {
          let id = node.get_attributes()["ID"];
          if (id == hwdId) {
            SensorConfig = node;
          }
        }
      }
    }
    return SensorConfig;
  }
  static async deviceConfigChanged(m) {
    logForm.log("Configuration change on device  " + await m.get_serialNumber());
    let serialprefix = (await m.get_serialNumber()).substring(0, 8);
    for (let i = 0; i < _sensorsManager.sensorList.length; i++) {
      if (_sensorsManager.sensorList[i].get_hardwareId().substring(0, 8) == serialprefix) {
        await _sensorsManager.sensorList[i].ConfigHasChanged();
      }
    }
    if (_sensorsManager._changeCallback != null)
      _sensorsManager._changeCallback();
    if (_sensorsManager._changeExternalCallback != null) {
      let data = await _sensorsManager._changeExternalCallback(m);
      if (data != null)
        YWebPage.ConfigChanged(data);
    }
  }
  static async deviceArrival(m) {
    try {
      let count = await m.functionCount();
      let serial = await m.get_serialNumber();
      let luminosity = await m.get_luminosity();
      logForm.log("Device Arrival " + serial);
      let recording = false;
      for (let i = 0; i < count; i++) {
        let ftype = await m.functionType(i);
        let fid = await m.functionId(i);
        if (ftype == "Network") {
          let net = await YNetwork.FindNetwork(serial + "." + fid);
          await sensorsManager.NetworkArrival(net);
        } else if (ftype == "DataLogger") {
          let dlog = YDataLogger.FindDataLogger(serial + "." + fid);
          let state = await dlog.get_recording();
          if (state == YDataLogger.RECORDING_ON || state == YDataLogger.RECORDING_PENDING) {
            recording = true;
          }
        }
      }
      for (let i = 0; i < count; i++) {
        let fbasetype = await m.functionBaseType(i);
        let fid = await m.functionId(i);
        if (fbasetype == "Sensor") {
          let hwdID = serial + "." + fid;
          logForm.log("New sensor arrival: " + hwdID);
          let found = false;
          for (let j = 0; j < _sensorsManager.sensorList.length && !found; j++) {
            if (_sensorsManager.sensorList[j].get_hardwareId() == hwdID) {
              found = true;
              await _sensorsManager.sensorList[j].arrival(recording);
            }
          }
          if (!found) {
            let s = YSensor.FindSensor(hwdID);
            let hwd = await s.get_hardwareId();
            let cs = new CustomYSensor(s, hwd, _sensorsManager.FindSensorLastLocalConfig(hwd));
            _sensorsManager.sensorList.push(cs);
            await cs.configureSensor();
            YWebPage.refreshEditor();
            cs.notifySensorStateChange();
          }
        }
      }
      await m.registerConfigChangeCallback(_sensorsManager.deviceConfigChanged);
      setTimeout(() => {
        _sensorsManager.deviceConfigChanged(m);
      }, 100);
      if (_sensorsManager._changeCallback != null)
        _sensorsManager._changeCallback();
    } catch (e) {
      logForm.log("Device Arrival Error: " + e.message);
    }
    if (_sensorsManager._customArrivalCallback != null)
      _sensorsManager._customArrivalCallback(m);
  }
  static async deviceRemoval(m) {
    let serial = await m.get_serialNumber();
    logForm.log("Device removal " + serial);
    _sensorsManager.sensorList.forEach((alreadyThereSensor) => {
      if (!(alreadyThereSensor instanceof NullYSensor)) {
        let hwd = alreadyThereSensor.get_hardwareId();
        if (hwd.length >= serial.length) {
          if (hwd.substring(0, serial.length) == serial) {
            alreadyThereSensor.removal();
          }
        }
      }
    });
    if (_sensorsManager._changeCallback != null)
      _sensorsManager._changeCallback();
    if (_sensorsManager._customRemovalCallback != null)
      _sensorsManager._customRemovalCallback(m);
  }
  static RegisterDeviceArrivalCallback(arrivalCallback) {
    _sensorsManager._customArrivalCallback = arrivalCallback;
  }
  static RegisterDeviceRemovalCallback(removalCallback) {
    _sensorsManager._customRemovalCallback = removalCallback;
  }
  static AddNewSensor(hwdID) {
    for (let i = 0; i < _sensorsManager.sensorList.length; i++) {
      if (_sensorsManager.sensorList[i] != null) {
        if (_sensorsManager.sensorList[i].get_hardwareId() == hwdID)
          return _sensorsManager.sensorList[i];
      }
    }
    let s = YSensor.FindSensor(hwdID);
    let cs = new CustomYSensor(s, hwdID, _sensorsManager.FindSensorLastLocalConfig(hwdID));
    _sensorsManager.sensorList.push(cs);
    return cs;
  }
  static getNullSensor() {
    return _sensorsManager.NullSensor;
  }
  static async UpdateDeviceList() {
    let err = new YErrorMsg();
    try {
      if (await YAPI.UpdateDeviceList(err) != YAPI_SUCCESS) {
        logForm.log("UpdateDeviceList failed :" + err.msg);
      }
    } catch (e) {
      logForm.log("UpdateDeviceList failed :" + e.message);
    }
    let hub = YHub.FirstHubInUse();
    while (hub != null) {
      let lastError = await hub.get_errorType();
      if (lastError != YAPI_SUCCESS) {
        let logline = "Cannot connect to " + await hub.get_connectionUrl() + " (" + await hub.get_errorMessage() + ")";
        if (lastError == YAPI_UNAUTHORIZED) {
          for (let i = 0; i < this._hubList.length; i++) {
            if (await this._hubList[i].matches(hub) && !this._hubList[i].removable) {
              logline += ". Update hub credentials in 'Global configuration' window.";
            }
          }
        }
        logForm.log(logline);
      }
      hub = hub.nextHubInUse();
    }
  }
  static async _runAsync() {
    let errmsg = new YErrorMsg();
    await YAPI.RegisterDeviceArrivalCallback((m) => {
      _sensorsManager.deviceArrival(m);
    });
    await YAPI.RegisterDeviceRemovalCallback((m) => {
      _sensorsManager.deviceRemoval(m);
    });
    await _sensorsManager.UpdateDeviceList();
    setInterval(() => {
      _sensorsManager.UpdateDeviceList();
    }, 2e3);
  }
  static run() {
    _sensorsManager.NullSensor = new NullYSensor();
    _sensorsManager.sensorList = [];
    _sensorsManager.sensorList.push(_sensorsManager.NullSensor);
    this._runAsync().then();
  }
};
sensorsManager.counter = 0;
sensorsManager.KnownSensors = null;
sensorsManager._hubList = [];
sensorsManager._customArrivalCallback = null;
sensorsManager._customRemovalCallback = null;
sensorsManager._changeCallback = null;
sensorsManager._changeExternalCallback = null;

// obj/full/formManager.js
var ResizeMoveHandle = class _ResizeMoveHandle {
  constructor(container, index, mouseDownListener, touchStartlistener) {
    this.index = index;
    this.container = container;
    this.isactive = false;
    this.div = document.createElement("DIV");
    let size = _ResizeMoveHandle.HANDLESIZE - 2;
    if (this.index == _ResizeMoveHandle.RESIZEHANDLE_CENTER)
      size = size * 2;
    this.div.style.position = "absolute";
    this.div.style.border = "0px solid black";
    this.div.style.background = "transparent";
    this.div.style.pointerEvents = "auto";
    this.div.style.width = size.toString() + "px";
    this.div.style.height = size.toString() + "px";
    switch (index) {
      case _ResizeMoveHandle.RESIZEHANDLE_TOPLEFT:
        this.div.style.cursor = "nw-resize";
        this.div.style.left = "0px";
        this.div.style.top = "0px";
        break;
      case _ResizeMoveHandle.RESIZEHANDLE_TOPCENTER:
        this.div.style.cursor = "n-resize";
        this.div.style.top = "0px";
        this.div.style.left = "50%";
        this.div.style.transform = "translate(-50%,0)";
        break;
      case _ResizeMoveHandle.RESIZEHANDLE_TOPRIGHT:
        this.div.style.cursor = "ne-resize";
        this.div.style.right = "0px";
        this.div.style.top = "0px";
        break;
      case _ResizeMoveHandle.RESIZEHANDLE_CENTERRIGHT:
        this.div.style.cursor = "e-resize";
        this.div.style.right = "0px";
        this.div.style.top = "50%";
        this.div.style.transform = "translate(0,-50%)";
        break;
      case _ResizeMoveHandle.RESIZEHANDLE_BOTTOMRIGHT:
        this.div.style.cursor = "se-resize";
        this.div.style.right = "0px";
        this.div.style.bottom = "0px";
        break;
      case _ResizeMoveHandle.RESIZEHANDLE_BOTTOMCENTER:
        this.div.style.cursor = "s-resize";
        this.div.style.bottom = "0px";
        this.div.style.left = "50%";
        this.div.style.transform = "translate(-50%,0)";
        break;
      case _ResizeMoveHandle.RESIZEHANDLE_BOTTOMLEFT:
        this.div.style.cursor = "sw-resize";
        this.div.style.left = "0px";
        this.div.style.bottom = "0px";
        break;
      case _ResizeMoveHandle.RESIZEHANDLE_CENTERLEFT:
        this.div.style.cursor = "w-resize";
        this.div.style.left = "0px";
        this.div.style.top = "50%";
        this.div.style.transform = "translate(0,-50%)";
        break;
      case _ResizeMoveHandle.RESIZEHANDLE_CENTER:
        this.div.style.cursor = "move";
        this.div.style.left = "50%";
        this.div.style.top = "50%";
        this.div.style.transform = "translate(-50%,-50%)";
        break;
    }
    this.container.appendChild(this.div);
    this.div.addEventListener("mousedown", mouseDownListener);
    this.div.addEventListener("touchstart", touchStartlistener);
    this.svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    this.svg.setAttribute("viewBox", "0 0 " + size + " " + size);
    this.svg.setAttribute("version", "1.1");
    this.svg.setAttribute("width", size.toString());
    this.svg.setAttribute("height", size.toString());
    let x = 0;
    let y = 0;
    let r = size;
    switch (this.index) {
      case _ResizeMoveHandle.RESIZEHANDLE_TOPLEFT:
        break;
      case _ResizeMoveHandle.RESIZEHANDLE_TOPCENTER:
        x = size / 2;
        break;
      case _ResizeMoveHandle.RESIZEHANDLE_TOPRIGHT:
        x = size;
        break;
      case _ResizeMoveHandle.RESIZEHANDLE_CENTERRIGHT:
        x = size;
        y = size / 2;
        break;
      case _ResizeMoveHandle.RESIZEHANDLE_BOTTOMRIGHT:
        x = size;
        y = size;
        break;
      case _ResizeMoveHandle.RESIZEHANDLE_BOTTOMCENTER:
        x = size / 2;
        y = size;
        break;
      case _ResizeMoveHandle.RESIZEHANDLE_BOTTOMLEFT:
        y = size;
        break;
      case _ResizeMoveHandle.RESIZEHANDLE_CENTERLEFT:
        y = size / 2;
        break;
      case _ResizeMoveHandle.RESIZEHANDLE_CENTER:
        x = size / 2;
        y = size / 2;
        r = size / 2;
        break;
    }
    this.circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
    this.circle.setAttribute("cx", x.toString());
    this.circle.setAttribute("cy", y.toString());
    this.circle.setAttribute("r", r.toString());
    this.circle.setAttribute("style", "fill:white");
    this.circle.setAttribute("opacity", "0.75");
    this.svg.appendChild(this.circle);
    this.arrow = document.createElementNS("http://www.w3.org/2000/svg", "path");
    let d = "";
    for (let i = 0; i < _ResizeMoveHandle.RESIZEHANDLE_data[index].length >> 1; i++) {
      let x2 = 1 + (size - 2) * _ResizeMoveHandle.RESIZEHANDLE_data[index][i << 1] / 12;
      let y2 = 1 + (size - 2) * _ResizeMoveHandle.RESIZEHANDLE_data[index][1 + (i << 1)] / 12;
      d += i == 0 ? "M " : "L ";
      d += Math.round(x2).toString() + " " + Math.round(y2).toString() + " ";
    }
    d += "z";
    this.arrow.setAttribute("d", d);
    this.arrow.setAttribute("fill", _ResizeMoveHandle.inactiveColor);
    this.svg.appendChild(this.arrow);
    this.div.appendChild(this.svg);
    this.container.appendChild(this.div);
  }
  get active() {
    return this.isactive;
  }
  set active(value) {
    if (value != this.isactive) {
      this.isactive = value;
      this.arrow.setAttribute("fill", this.active ? _ResizeMoveHandle.activeColor : _ResizeMoveHandle.inactiveColor);
    }
  }
};
ResizeMoveHandle.HANDLESIZE = Math.round(20 * (1 + 2 * (constants.guiDPIFactor - 1)));
ResizeMoveHandle.activeColor = "lightgreen";
ResizeMoveHandle.inactiveColor = "grey";
ResizeMoveHandle.RESIZEHANDLE_TOPLEFT = 0;
ResizeMoveHandle.RESIZEHANDLE_TOPCENTER = 1;
ResizeMoveHandle.RESIZEHANDLE_TOPRIGHT = 2;
ResizeMoveHandle.RESIZEHANDLE_CENTERRIGHT = 3;
ResizeMoveHandle.RESIZEHANDLE_BOTTOMRIGHT = 4;
ResizeMoveHandle.RESIZEHANDLE_BOTTOMCENTER = 5;
ResizeMoveHandle.RESIZEHANDLE_BOTTOMLEFT = 6;
ResizeMoveHandle.RESIZEHANDLE_CENTERLEFT = 7;
ResizeMoveHandle.RESIZEHANDLE_CENTER = 8;
ResizeMoveHandle.RESIZEHANDLE_data = [
  [0, 0, 0, 7, 2, 5, 7, 10, 10, 7, 5, 2, 7, 0],
  [6, 0, 11, 5, 8, 5, 8, 12, 4, 12, 4, 5, 1, 5],
  [12, 0, 12, 7, 10, 5, 5, 10, 2, 7, 7, 2, 5, 0],
  [12, 6, 7, 11, 7, 8, 0, 8, 0, 4, 7, 4, 7, 1],
  [12, 12, 5, 12, 7, 10, 2, 5, 5, 2, 10, 7, 12, 5],
  [6, 12, 1, 7, 4, 7, 4, 0, 8, 0, 8, 7, 11, 7],
  [0, 12, 0, 5, 2, 7, 7, 2, 10, 5, 5, 10, 7, 12],
  [0, 6, 5, 1, 5, 4, 12, 4, 12, 8, 5, 8, 5, 11],
  [
    6,
    0,
    8,
    2,
    7,
    2,
    7,
    5,
    10,
    5,
    10,
    4,
    12,
    6,
    10,
    8,
    10,
    7,
    7,
    7,
    7,
    10,
    8,
    10,
    6,
    12,
    4,
    10,
    5,
    10,
    5,
    7,
    2,
    7,
    2,
    8,
    0,
    6,
    2,
    4,
    2,
    5,
    5,
    5,
    5,
    2,
    4,
    2
  ]
];
var YWidget = class _YWidget {
  static log(st) {
    logForm.log(st);
  }
  SourceChanged(src, index) {
  }
  loadRecordedDataIfNeeded() {
  }
  removeDataloggerData() {
  }
  //#ifndef READONLY
  delete() {
    this.editStopped();
    sensorsManager.forgetForm(this);
    this.destroy();
  }
  get confirmDeleteString() {
    return "not defined";
  }
  //#endif
  snapshot() {
    let w = 1024;
    let h = 1024;
    let ratio = this.UIContainer.offsetHeight != 0 ? this.UIContainer.offsetWidth / this.UIContainer.offsetHeight : 1;
    switch (constants.captureSizePolicy) {
      case YDataRenderer.CaptureFormats.Keep:
        w = this.UIContainer.offsetWidth;
        h = this.UIContainer.offsetHeight;
        break;
      case YDataRenderer.CaptureFormats.FixedHeight:
        h = constants.captureHeight;
        w = h * ratio;
        break;
      case YDataRenderer.CaptureFormats.FixedWidth:
        w = constants.captureWidth;
        h = w / ratio;
        break;
      case YDataRenderer.CaptureFormats.Fixed:
        w = constants.captureWidth;
        h = constants.captureHeight;
        break;
    }
    this._genRenderer.captureAndDownloadImage(constants.captureType, "", w, h, constants.captureDPI);
  }
  get BackColor() {
    return this._BackColor;
  }
  set BackColor(value) {
    this._BackColor = value;
    this.UIContainer.style.backgroundColor = this._BackColor.htmlCode;
  }
  get BorderColor() {
    return this._BorderColor;
  }
  set BorderColor(value) {
    this._BorderColor = value;
    this.UIContainer.style.border = "1px solid " + this._BorderColor.htmlCode;
  }
  get parentWidth() {
    if (this.UIContainer.parentNode == document.body || this.UIContainer.parentNode == null)
      return window.innerWidth;
    return this.UIContainer.parentNode.clientWidth;
  }
  get parentHeight() {
    if (this.UIContainer.parentNode == document.body || this.UIContainer.parentNode == null)
      return window.innerHeight;
    return this.UIContainer.parentNode.clientHeight;
  }
  get relativePositionX() {
    if (this._SizeIsRelative)
      return this._relativePositionX;
    return this.sizeRound(100 * this.UIContainer.offsetLeft / this.parentWidth);
  }
  set relativePositionX(value) {
    this._relativePositionX = value;
    this._PositionX = Math.round(value * this.parentWidth / 100);
  }
  set relativePositionY(value) {
    this._relativePositionY = value;
    this._PositionY = Math.round(value * this.parentHeight / 100);
  }
  get relativePositionY() {
    if (this._SizeIsRelative)
      return this._relativePositionY;
    return this.sizeRound(100 * this.UIContainer.offsetTop / this.parentHeight);
  }
  get PositionX() {
    if (this._SizeIsRelative)
      return this.relativePositionX;
    return this.UIContainer.offsetLeft;
  }
  set PositionX(value) {
    if (this._SizeIsRelative)
      this.relativePositionX = value;
    else
      this._PositionX = value;
    this.UIContainer.style.left = this._PositionX.toString() + "px";
    if (this._genRenderer != null)
      this._genRenderer.clearTransformationMatrix();
    this.DrawHandles(this.UIContainer.offsetLeft, this.UIContainer.offsetTop, this.UIContainer.offsetWidth, this.UIContainer.offsetHeight);
  }
  get PositionY() {
    if (this._SizeIsRelative)
      return this.relativePositionY;
    return this.UIContainer.offsetTop;
  }
  set PositionY(value) {
    if (this._SizeIsRelative)
      this.relativePositionY = value;
    else
      this._PositionY = value;
    this.UIContainer.style.top = this._PositionY.toString() + "px";
    if (this._genRenderer != null)
      this._genRenderer.clearTransformationMatrix();
    this.DrawHandles(this.UIContainer.offsetLeft, this.UIContainer.offsetTop, this.UIContainer.offsetWidth, this.UIContainer.offsetHeight);
  }
  sizeRound(v) {
    return Math.round(100 * v) / 100;
  }
  get relativeWidth() {
    if (this._SizeIsRelative)
      return this._relativeWidth;
    return this.sizeRound(100 * this.UIContainer.offsetWidth / this.parentWidth);
  }
  set relativeWidth(value) {
    if (value <= 0)
      throw "Value must be strictly positive";
    this._relativeWidth = value;
    this._Width = Math.round(value * this.parentWidth / 100);
  }
  set relativeHeight(value) {
    if (value <= 0)
      throw "Value must be strictly positive";
    this._relativeHeight = value;
    this._Height = Math.round(value * this.parentHeight / 100);
  }
  get relativeHeight() {
    if (this._SizeIsRelative)
      return this._relativeHeight;
    return this.sizeRound(100 * this.UIContainer.offsetHeight / this.parentHeight);
  }
  updateRelativeSize() {
    if (Math.abs(this._relativeWidth * this.parentWidth / 100 - this.UIContainer.offsetWidth) > 1)
      this._relativeWidth = this.sizeRound(100 * this.UIContainer.offsetWidth / this.parentWidth);
    if (Math.abs(this._relativeHeight * this.parentHeight / 100 - this.UIContainer.offsetHeight) > 1)
      this._relativeHeight = this.sizeRound(100 * this.UIContainer.offsetHeight / this.parentHeight);
    if (Math.abs(this._relativePositionX * this.parentWidth / 100 - this.UIContainer.offsetLeft) > 1)
      this._relativePositionX = this.sizeRound(100 * this.UIContainer.offsetLeft / this.parentWidth);
    if (Math.abs(this._relativePositionY * this.parentHeight / 100 - this.UIContainer.offsetTop) > 1)
      this._relativePositionY = this.sizeRound(100 * this.UIContainer.offsetTop / this.parentHeight);
  }
  get Width() {
    if (this._SizeIsRelative)
      return this.relativeWidth;
    else
      return this.UIContainer.offsetWidth;
  }
  set Width(value) {
    if (value <= 0)
      throw "Value must be strictly positive";
    if (this._SizeIsRelative)
      this.relativeWidth = value;
    else
      this._Width = value;
    this.UIContainer.style.width = (this._Width - 2).toString() + "px";
    this.UIContainer.width = this._Width - 2;
    if (this._genRenderer != null)
      this._genRenderer.clearTransformationMatrix();
    this.DrawHandles(this.UIContainer.offsetLeft, this.UIContainer.offsetTop, this.UIContainer.offsetWidth, this.UIContainer.offsetHeight);
    this.containerResized();
  }
  get Height() {
    if (this._SizeIsRelative)
      return this.relativeHeight;
    else
      return this.UIContainer.offsetHeight;
  }
  set Height(value) {
    if (value <= 0)
      throw "Value must be strictly positive";
    if (this._SizeIsRelative)
      this.relativeHeight = value;
    else
      this._Height = value;
    this.UIContainer.style.height = (this._Height - 2).toString() + "px";
    this.UIContainer.height = this._Height - 2;
    if (this._genRenderer != null)
      this._genRenderer.clearTransformationMatrix();
    this.DrawHandles(this.UIContainer.offsetLeft, this.UIContainer.offsetTop, this.UIContainer.offsetWidth, this.UIContainer.offsetHeight);
    this.containerResized();
  }
  get SizeIsRelative() {
    return this._SizeIsRelative;
  }
  set SizeIsRelative(value) {
    if (this._SizeIsRelative != value) {
      this._SizeIsRelative = value;
      if (this._SizeIsRelative) {
        this._relativePositionX = this.sizeRound(100 * this.UIContainer.offsetLeft / this.parentWidth);
        this._relativePositionY = this.sizeRound(100 * this.UIContainer.offsetTop / this.parentHeight);
        this._relativeWidth = this.sizeRound(100 * this.UIContainer.offsetWidth / this.parentWidth);
        this._relativeHeight = this.sizeRound(100 * this.UIContainer.offsetHeight / this.parentHeight);
      }
      this.windowResized();
    }
  }
  get containerID() {
    return this._containerID;
  }
  set containerID(value) {
    if (this._containerID == value)
      return;
    let target = value != "" ? document.getElementById(value) : null;
    if (value != "" && target == null)
      throw "No HTMLElement on the page with such ID (" + value + ")";
    if (this.UIContainer.parentNode != null) {
      this.UIContainer.parentNode.removeChild(this.UIContainer);
    } else {
      document.body.removeChild(this.UIContainer);
    }
    if (target != null) {
      this.UIContainer.style.position = "relative";
      target.insertBefore(this.UIContainer, target.firstChild);
    } else {
      this.UIContainer.style.position = "absolute";
      document.body.insertBefore(this.UIContainer, document.body.firstChild);
    }
    this._genRenderer.clearTransformationMatrix();
    this.windowResized();
    this.DrawHandles(this.UIContainer.offsetLeft, this.UIContainer.offsetTop, this.UIContainer.offsetWidth, this.UIContainer.offsetHeight);
    this._containerID = value;
  }
  get Text() {
    return this._Text;
  }
  set Text(value) {
    this._Text = value;
    this.UIContainer.title = value;
  }
  set_name(name) {
    this.Text = name;
    this._genProp.Form_Text = name;
  }
  windowResized() {
    this._genRenderer.DisableRedraw();
    if (this._SizeIsRelative) {
      this.PositionX = this._relativePositionX;
      this.PositionY = this._relativePositionY;
      this.Height = this._relativeHeight;
      this.Width = this._relativeWidth;
    }
    this.containerResized();
    this._genRenderer.AllowRedraw();
  }
  ApplyRelativeSizeIfRequired() {
    if (this._initialContainerID != "") {
      if (document.getElementById(this._initialContainerID) != null) {
        this.containerID = this._initialContainerID;
      } else {
        logForm.log('Warning: cannot place widget in "' + this._initialContainerID + '" : no such HTML element.');
      }
    }
    this._SizeIsRelative = this._InitialSizeIsRelative;
    this.windowResized();
  }
  destroy() {
    window.removeEventListener("resize", this._windowResizeCallback);
    this._genRenderer.destroy();
    Object.entries(this).forEach((pair) => {
      Reflect.set(this, pair[0], null);
    });
  }
  getContainerOffset() {
    let it = this.UIContainer.offsetParent;
    let absx = 0;
    let absy = 0;
    while (it) {
      absy += it.offsetTop;
      absx += it.offsetLeft;
      it = it.offsetParent;
    }
    return new pointXY(absx, absy);
  }
  contextMenuCallBack(mouseX, mouseY) {
    let p = this._genRenderer.Scr2ElmMatrix.multiplyByV(Vector3.FromXYCoord(mouseX, mouseY)).toPoint();
    if (p.X >= 0 && p.X <= this.UIContainer.offsetWidth && p.Y >= 0 && p.Y <= this.UIContainer.offsetHeight) {
      this.contextMenuIsOpening();
    }
  }
  contextMenuIsOpening() {
  }
  constructor(node, editor, default_x, default_y, default_width, default_height) {
    this._genProp = null;
    this._genRenderer = null;
    this._BackColor = YColor.Transparent;
    this._BorderColor = YColor.Gray;
    this._relativePositionX = 0;
    this._relativePositionY = 0;
    this._PositionX = 0;
    this._PositionY = 0;
    this._relativeWidth = 100;
    this._relativeHeight = 100;
    this._Width = 300;
    this._Height = 0;
    this._InitialSizeIsRelative = false;
    this._SizeIsRelative = false;
    this._initialContainerID = "";
    this._containerID = "";
    this._Text = "";
    this.resizeCaptureRunning = false;
    this.resizeCaptureXOrigineMouse = 0;
    this.resizeCaptureYOrigineMouse = 0;
    this.resizeCaptureXOrigine = 0;
    this.resizeCaptureYOrigine = 0;
    this.resizeCaptureOriginalTop = 0;
    this.resizeCaptureOriginalLeft = 0;
    this.resizeCaptureOriginalWidth = 0;
    this.resizeCaptureOriginalHeight = 0;
    this.resizeCaptureHandleIndex = 0;
    this.resizeCaptureOriginalMatrix = null;
    this.resizeCaptureOriginalMatrixInv = null;
    this.previousTRansform = "";
    this.previousWidth = 0;
    this.previousHeight = 0;
    let left = typeof default_x != "undefined" ? default_x : 0;
    let top2 = typeof default_y != "undefined" ? default_y : 0;
    let width = typeof default_width != "undefined" ? default_width : 0;
    let height = typeof default_height != "undefined" ? default_height : 0;
    let bottom = Number.NaN;
    let right = Number.NaN;
    if (node != null) {
      let childnodes = node.get_childsByName();
      if ("location" in childnodes) {
        let it = childnodes["location"];
        let attributes = it.get_attributes();
        if ("x" in attributes)
          left = parseInt(attributes["x"]);
        if ("y" in attributes)
          top2 = parseInt(attributes["y"]);
      }
      if ("size" in childnodes) {
        let it = childnodes["size"];
        let attributes = it.get_attributes();
        if ("w" in attributes)
          width = parseInt(attributes["w"]);
        if ("h" in attributes)
          height = parseInt(attributes["h"]);
      }
      if ("relativeCoord" in childnodes) {
        let it = childnodes["relativeCoord"];
        let attributes = it.get_attributes();
        if ("x" in attributes)
          this._relativePositionX = this.sizeRound(parseFloat(attributes["x"]));
        if ("y" in attributes)
          this._relativePositionY = this.sizeRound(parseFloat(attributes["y"]));
        if ("w" in attributes)
          this._relativeWidth = this.sizeRound(parseFloat(attributes["w"]));
        if ("h" in attributes)
          this._relativeHeight = this.sizeRound(parseFloat(attributes["h"]));
        if ("active" in attributes)
          this._InitialSizeIsRelative = attributes["active"].toUpperCase() == "TRUE";
      }
      if ("container" in childnodes) {
        let it = childnodes["container"];
        let attributes = it.get_attributes();
        if ("id" in attributes)
          this._initialContainerID = attributes["id"];
      }
    }
    this.UIContainer = document.createElement("CANVAS");
    this.UIContainer.style.position = "absolute";
    _YWidget.currentEdited = null;
    let h = window.innerHeight;
    let w = window.innerWidth;
    this.PositionX = this._InitialSizeIsRelative ? Math.round(w * (this._relativePositionX / 100)) : left;
    this.PositionY = this._InitialSizeIsRelative ? Math.round(h * (this._relativePositionY / 100)) : top2;
    this.Width = this._InitialSizeIsRelative ? Math.round(w * (this._relativeWidth / 100)) : width;
    this.Height = this._InitialSizeIsRelative ? Math.round(h * (this._relativeHeight / 100)) : height;
    this.UIContainer.style.border = "1px solid black";
    this.UIContainer.style.backgroundColor = this._BackColor.htmlCode;
    this.UIContainer.setAttribute("name", "YoctoVisualizationWidget");
    document.body.appendChild(this.UIContainer);
    this._windowResizeCallback = () => this.windowResized();
    window.addEventListener("resize", this._windowResizeCallback);
  }
  rearrangeZindexes() {
    let containers = document.getElementsByName("YoctoVisualizationWidget");
    let n = 0;
    for (let i = 0; i < containers.length; i++) {
      if (containers[i] != this.UIContainer) {
        containers[i].style.zIndex = n.toString();
        n++;
      }
    }
    this.UIContainer.style.zIndex = n.toString();
    n++;
    _YWidget.HandlesDiv.style.zIndex = n.toString();
  }
  SensorArrivalcallback(source) {
  }
  SensorStateChangedcallback(source) {
    if (_YWidget.currentEdited == this) {
      YWebPage.refreshEditor();
    }
  }
  SensorValuecallback(source, M) {
  }
  get isBeingEdited() {
    return _YWidget.currentEdited == this;
  }
  static stopEdition() {
    if (_YWidget.currentEdited != null) {
      _YWidget.currentEdited.editStopped();
      _YWidget.currentEdited = null;
    }
  }
  refreshProperties() {
  }
  edit() {
    _YWidget.stopEdition();
    _YWidget.currentEdited = this;
    if (_YWidget.editHandles.length <= 0) {
      _YWidget.HandlesDiv = document.createElement("DIV");
      _YWidget.HandlesDiv.style.position = "absolute";
      _YWidget.HandlesDiv.style.left = "0px";
      _YWidget.HandlesDiv.style.top = "0px";
      _YWidget.HandlesDiv.style.backgroundColor = "transparent";
      _YWidget.HandlesDiv.style.transformOrigin = "top left";
      _YWidget.HandlesDiv.style.pointerEvents = "none";
      for (let i = 0; i < 9; i++) {
        _YWidget.editHandles.push(new ResizeMoveHandle(_YWidget.HandlesDiv, i, (e) => {
          if (_YWidget.currentEdited != null)
            _YWidget.currentEdited.mouseStartCapture(e, i);
        }, (e) => {
          if (_YWidget.currentEdited != null) {
            _YWidget.currentEdited.touchStartCapture(e, i);
          }
        }));
      }
      document.body.appendChild(_YWidget.HandlesDiv);
      document.addEventListener("touchmove", (e) => {
        if (_YWidget.currentEdited != null)
          _YWidget.currentEdited.touchCaptureRun(e);
      }, { passive: false });
      document.addEventListener("touchend", (e) => {
        if (_YWidget.currentEdited != null)
          _YWidget.currentEdited.touchCaptureStop(e);
      }, { passive: false });
      document.addEventListener("mousemove", (e) => {
        if (_YWidget.currentEdited != null)
          _YWidget.currentEdited.mouseCaptureRun(e);
      }, { passive: false });
      document.addEventListener("mouseup", (e) => {
        if (_YWidget.currentEdited != null)
          _YWidget.currentEdited.mouseCaptureStop(e);
      }, { passive: false });
    }
    this.DrawHandles(this.UIContainer.offsetLeft, this.UIContainer.offsetTop, this.UIContainer.offsetWidth, this.UIContainer.offsetHeight);
    _YWidget.HandlesDiv.style.display = "";
    this.rearrangeZindexes();
  }
  DrawHandles(offsetLeft, offsetTop, offsetWidth, offsetHeight) {
    if (_YWidget.currentEdited == null)
      return;
    if (_YWidget.editHandles.length <= 0)
      return;
    _YWidget.HandlesDiv.style.width = offsetWidth.toString() + "px";
    _YWidget.HandlesDiv.style.height = offsetHeight.toString() + "px";
    if (this._genRenderer == null)
      debugger;
    let borderWidth = parseFloat(this.UIContainer.style.border);
    let borderMatrix = Matrix3x3.newTranslateMatrix(-borderWidth, -borderWidth);
    _YWidget.HandlesDiv.style.transform = borderMatrix.multiplyByM(this._genRenderer.Elm2ScrMatrix).toCSS();
    _YWidget.HandlesDiv.style.transform = "top left";
  }
  //#endif
  updateWindowPositionProperties(prop) {
    prop.Form_PositionX = this.PositionX;
    prop.Form_PositionY = this.PositionY;
    prop.Form_Width = this.Width;
    prop.Form_Height = this.Height;
  }
  touchStartCapture(e, handleIndex) {
    if (e.touches.length == 1) {
      this.handleMouseStartCapture(e.touches[0].pageX, e.touches[0].pageY, handleIndex);
      e.preventDefault();
    }
  }
  mouseStartCapture(e, handleIndex) {
    if (e.button != 0)
      return;
    this.handleMouseStartCapture(e.pageX, e.pageY, handleIndex);
  }
  handleMouseStartCapture(pageX, pageY, handleIndex) {
    this.resizeCaptureOriginalMatrix = this._genRenderer.Scr2ElmMatrix;
    this.resizeCaptureOriginalMatrixInv = this._genRenderer.Elm2ScrMatrix;
    let p = this.resizeCaptureOriginalMatrix.multiplyByV(Vector3.FromXYCoord(pageX, pageY)).toPoint();
    this.resizeCaptureRunning = true;
    this.resizeCaptureXOrigine = p.X;
    this.resizeCaptureYOrigine = p.Y;
    this.resizeCaptureOriginalLeft = this.UIContainer.offsetLeft;
    this.resizeCaptureOriginalTop = this.UIContainer.offsetTop;
    this.resizeCaptureOriginalWidth = this.UIContainer.offsetWidth;
    this.resizeCaptureOriginalHeight = this.UIContainer.offsetHeight;
    this.resizeCaptureHandleIndex = handleIndex;
    _YWidget.editHandles[this.resizeCaptureHandleIndex].active = true;
    this.previousTRansform = _YWidget.HandlesDiv.style.transform;
  }
  touchCaptureRun(e) {
    if (e.touches.length == 1) {
      this.handleCaptureRun(e.touches[0].pageX, e.touches[0].pageY);
      e.preventDefault();
    }
  }
  mouseCaptureRun(e) {
    this.handleCaptureRun(e.pageX, e.pageY);
  }
  handleCaptureRun(pageX, pageY) {
    if (!this.resizeCaptureRunning)
      return;
    let p = this.resizeCaptureOriginalMatrix.multiplyByV(Vector3.FromXYCoord(pageX, pageY)).toPoint();
    let dx = p.X - this.resizeCaptureXOrigine;
    let dy = p.Y - this.resizeCaptureYOrigine;
    let newLeft = this.resizeCaptureOriginalLeft;
    let newTop = this.resizeCaptureOriginalTop;
    let newWidth = this.resizeCaptureOriginalWidth;
    let newHeight = this.resizeCaptureOriginalHeight;
    switch (this.resizeCaptureHandleIndex) {
      case 0:
        newLeft += dx;
        newTop += dy;
        newWidth -= dx;
        newHeight -= dy;
        break;
      // TopLeft
      case 1:
        newTop += dy;
        newHeight -= dy;
        break;
      // Top
      case 2:
        newTop += dy;
        newWidth += dx;
        newHeight -= dy;
        break;
      // TopRight
      case 3:
        newWidth += dx;
        break;
      // Right
      case 4:
        newWidth += dx;
        newHeight += dy;
        break;
      // bottom right
      case 5:
        newHeight += dy;
        break;
      // bottom
      case 6:
        newLeft += dx;
        newWidth -= dx;
        newHeight += dy;
        break;
      // bottom left
      case 7:
        newLeft += dx;
        newWidth -= dx;
        break;
      //  left
      case 8:
        newLeft += dx;
        newTop += dy;
        break;
    }
    if (newWidth < 2 * _YWidget.HANDLESIZE)
      newWidth = 2 * _YWidget.HANDLESIZE;
    if (newHeight < 2 * _YWidget.HANDLESIZE)
      newHeight = 2 * _YWidget.HANDLESIZE;
    this.UIContainer.style.left = newLeft.toString() + "px";
    this.UIContainer.style.top = newTop.toString() + "px";
    if (this.resizeCaptureOriginalWidth != newWidth || this.resizeCaptureOriginalHeight != newHeight) {
      this.resize(newWidth - 2, newHeight - 2);
    }
    this._genRenderer.clearTransformationMatrix();
    _YWidget.HandlesDiv.style.width = newWidth.toString() + "px";
    _YWidget.HandlesDiv.style.height = newHeight.toString() + "px";
    _YWidget.HandlesDiv.style.left = "0px";
    _YWidget.HandlesDiv.style.top = "0px";
    let A = this.resizeCaptureOriginalMatrixInv;
    let B = Matrix3x3.newTranslateMatrix(newLeft - this.resizeCaptureOriginalLeft, newTop - this.resizeCaptureOriginalTop);
    let borderWidth = parseFloat(this.UIContainer.style.border);
    let borderMatrix = Matrix3x3.newTranslateMatrix(-borderWidth, -borderWidth);
    _YWidget.HandlesDiv.style.transform = borderMatrix.multiplyByM(A.multiplyByM(B)).toCSS();
  }
  editStopped() {
    this.resizeCaptureRunning = false;
    if (_YWidget.HandlesDiv != null)
      _YWidget.HandlesDiv.style.display = "none";
  }
  touchCaptureStop(e) {
    this.mouseCaptureStop(null);
  }
  mouseCaptureStop(e) {
    if (!this.resizeCaptureRunning)
      return;
    this.resizeCaptureRunning = false;
    _YWidget.editHandles[this.resizeCaptureHandleIndex].active = false;
    if (this.previousTRansform != _YWidget.HandlesDiv.style.transform || this.resizeCaptureOriginalWidth != this.UIContainer.offsetWidth || this.resizeCaptureOriginalHeight != this.UIContainer.offsetHeight) {
      if (this._SizeIsRelative)
        this.updateRelativeSize();
      constants.edited = true;
    }
    this.refreshProperties();
  }
  //#endif
  resize(newWidth, newHeight) {
    this.UIContainer.style.width = newWidth.toString() + "px";
    this.UIContainer.style.height = newHeight.toString() + "px";
    this.containerResized();
  }
  containerResized() {
  }
  // overloaded later on
  //#ifndef READONLY
  getContentsConfigData() {
    return "  <location x='" + this.UIContainer.offsetLeft.toString() + "' y='" + this.UIContainer.offsetTop.toString() + "'/>\n  <size     w='" + this.UIContainer.offsetWidth.toString() + "' h='" + this.UIContainer.offsetHeight.toString() + "'  state='Normal'/>\n  <relativeCoord x='" + this._relativePositionX.toString() + "' y='" + this._relativePositionY.toString() + "' w='" + this._relativeWidth.toString() + "' h='" + this._relativeHeight.toString() + "' active='" + (this._SizeIsRelative ? "True" : "False") + "'/>\n  <container id='" + constants.XMLquote(this._containerID) + "'/>\n" + this.getPropertiesXml();
  }
  //#endif
  getPropertiesXml() {
    return "";
  }
  PatchSensorAnnotationCallback(sensor, text) {
    let name = "None";
    let avgvalue = "N/A";
    let minvalue = "N/A";
    let maxvalue = "N/A";
    let unit = "";
    if (!(sensor instanceof NullYSensor)) {
      let resolution = -Math.round(Math.log10(sensor.get_resolution()));
      name = sensor.get_friendlyName();
      if (sensor.isOnline()) {
        avgvalue = sensor.get_lastAvgValue().toFixed(resolution);
        minvalue = sensor.get_lastMinValue().toFixed(resolution);
        maxvalue = sensor.get_lastMaxValue().toFixed(resolution);
      }
      unit = sensor.get_unit();
    }
    text = text.replace("$NAME$", name);
    text = text.replace("$AVGVALUE$", avgvalue);
    text = text.replace("$MAXVALUE$", maxvalue);
    text = text.replace("$MINVALUE$", minvalue);
    text = text.replace("$UNIT$", unit);
    return text;
  }
};
YWidget.HANDLESIZE = Math.round(20 * (1 + 2 * (constants.guiDPIFactor - 1)));
YWidget.editHandles = [];
YWidget.currentEdited = null;
var gaugeWidget = class _gaugeWidget extends YWidget {
  //#ifndef READONLY
  getPropertiesXml() {
    return this.prop.getXml(1);
  }
  //#endif
  containerResized() {
    if (this._gauge != null)
      this._gauge.containerResized();
  }
  destroy() {
    this.prop.destroy();
    super.destroy();
    Object.entries(this).forEach((pair) => {
      Reflect.set(this, pair[0], null);
    });
  }
  contextMenuIsOpening() {
    YWebPage.snapshotMenuItem.userdata = this;
    YWebPage.snapshotMenuItem.visible = true;
    YWebPage.resetDataViewMenuItem.visible = false;
    if (YWebPage.editMenuItem == null)
      return;
    YWebPage.clearDataloggerMenuItem.visible = true;
    YWebPage.editMenuItem.caption = "Configure this gauge";
    YWebPage.editMenuItem.visible = true;
    YWebPage.deleteMenuItem.caption = "Delete this gauge";
    YWebPage.deleteMenuItem.visible = true;
    YWebPage.addMarkerMenuItem.visible = false;
    YWebPage.disableMarkerMenuItem.visible = false;
    YWebPage.editMenuItem.userdata = this;
    YWebPage.deleteMenuItem.userdata = this;
  }
  get confirmDeleteString() {
    return "Do you really want to delete this gauge ?";
  }
  AnnotationCallback(text) {
    let sensor = this.prop.DataSource_source;
    return this.PatchSensorAnnotationCallback(sensor, text);
  }
  constructor(node, editor, x, y, width, height) {
    super(node, editor, x, y, width, height);
    this._gauge = new YSolidGauge(this.UIContainer, YSolidGauge.DisplayMode.DISPLAY90, YWidget.log);
    this._genRenderer = this._gauge;
    this.noDataSourcepanel = this._gauge.addMessagePanel();
    this.noDataSourcepanel.font.size = constants.generalFontSize;
    this.noDataSourcepanel.text = 'No data source configured\n 1 - Make sure you have a Yoctopuce sensor connected.\n 2 - Do a right-click or a long touch on this widget.\n 3 - Choose "Configure this gauge" to bring up the properties editor.\n 4 - Choose a data source\n';
    this.prop = new GaugeFormProperties(node, this);
    this._genProp = this.prop;
    let propDesc = GenericProperties.getAllProperties(this.prop);
    if (_gaugeWidget.AnnotationPanelCount == 0) {
      for (let propname in propDesc.byName) {
        if (propname.startsWith("SolidGauge_annotationPanel"))
          _gaugeWidget.AnnotationPanelCount++;
      }
    }
    for (let i = 0; i < _gaugeWidget.AnnotationPanelCount; i++) {
      this._gauge.addAnnotationPanel();
    }
    this._gauge.setPatchAnnotationCallback((s) => {
      return this.AnnotationCallback(s);
    });
    this._gauge.valueFormater = (source, value) => {
      return this.valueFormater(source, value);
    };
    this.updateWindowPositionProperties(this.prop);
    this.prop.ApplyAllProperties(this);
    YDataRenderer.minMaxCheckDisabled = true;
    this.prop.ApplyAllProperties(this._gauge);
    YDataRenderer.minMaxCheckDisabled = false;
    this._gauge.resetRefrenceSize();
    this._gauge.resizeRule = Proportional.ResizeRule.RELATIVETOBOTH;
    this.ApplyRelativeSizeIfRequired();
    if (this.SizeIsRelative)
      this.refreshProperties();
    this._gauge.AllowRedraw();
  }
  valueFormater(source, value) {
    if (this.prop.DataSource_source instanceof NullYSensor) {
      return "N/A";
    } else if (!this.prop.DataSource_source.isOnline())
      return "OFFLINE";
    let format = this.prop.DataSource_precision;
    let p = format.indexOf(".");
    let n = 0;
    if (p >= 0)
      n = format.length - p - 1;
    let unit = this.prop.DataSource_source.get_unit();
    return value.toFixed(n) + unit;
  }
  //#ifndef READONLY
  PropertyChanged2(src) {
    let info = new PropPathinfo();
    let path = src.ExtractPropPath(info);
    switch (info.propType) {
      case "Form":
        GenericProperties.copyProperty_STT(this, this.prop, info.fullpropname, path);
        break;
      case "SolidGauge":
        GenericProperties.copyProperty_STT(this._gauge, this.prop, info.fullpropname, path);
        break;
      case "DataSource":
        break;
    }
  }
  Get_PropertyValue(src) {
    let info = new PropPathinfo();
    let path = src.ExtractPropPath(info);
    switch (info.propType) {
      case "Form":
        return GenericProperties.newGetProperty(this, this.prop, info.fullpropname, path, null);
      case "SolidGauge":
        return GenericProperties.newGetProperty(this._gauge, this.prop, info.fullpropname, path, null);
    }
    return null;
  }
  edit() {
    super.edit();
    YWebPage.EditObject(this, this.prop, (src) => {
      this.PropertyChanged2(src);
    }, (src) => {
      return this.Get_PropertyValue(src);
    }, () => {
      this.editStopped();
    });
  }
  refreshProperties() {
    this.prop.RefreshAllProperties(this);
    this.prop.RefreshAllProperties(this._gauge);
    YWebPage.refreshPropertiesForm();
  }
  //#endif
  SourceChanged(value, index) {
    this.noDataSourcepanel.enabled = value instanceof NullYSensor;
    if (value instanceof NullYSensor) {
      this._gauge.value = 0;
    } else {
      value.registerCallback(this);
    }
  }
  SensorValuecallback(source, M) {
    if (this.prop == null)
      return;
    if (source == this.prop.DataSource_source) {
      this._gauge.value = source.isOnline() ? M.get_averageValue() : 0;
    }
  }
  //#ifndef READONLY
  getConfigData() {
    return "<GaugeForm>\n" + this.getContentsConfigData() + "</GaugeForm>\n";
  }
};
gaugeWidget.AnnotationPanelCount = 0;
var angularGaugeWidget = class _angularGaugeWidget extends YWidget {
  //#ifndef READONLY
  getPropertiesXml() {
    return this.prop.getXml(1);
  }
  //#endif
  containerResized() {
    if (this._angularGauge != null)
      this._angularGauge.containerResized();
  }
  destroy() {
    this.prop.destroy();
    super.destroy();
    Object.entries(this).forEach((pair) => {
      Reflect.set(this, pair[0], null);
    });
  }
  AnnotationCallback(text) {
    let sensor = this.prop.DataSource_source;
    return this.PatchSensorAnnotationCallback(sensor, text);
  }
  contextMenuIsOpening() {
    YWebPage.snapshotMenuItem.userdata = this;
    YWebPage.snapshotMenuItem.visible = true;
    YWebPage.resetDataViewMenuItem.visible = false;
    if (YWebPage.editMenuItem == null)
      return;
    YWebPage.clearDataloggerMenuItem.visible = false;
    YWebPage.editMenuItem.caption = "Configure this gauge";
    YWebPage.editMenuItem.visible = true;
    YWebPage.deleteMenuItem.caption = "Delete this gauge";
    YWebPage.deleteMenuItem.visible = true;
    YWebPage.addMarkerMenuItem.visible = false;
    YWebPage.disableMarkerMenuItem.visible = false;
    YWebPage.editMenuItem.userdata = this;
    YWebPage.deleteMenuItem.userdata = this;
  }
  get confirmDeleteString() {
    return "Do you really want to delete this gauge ?";
  }
  constructor(node, editor, x, y, width, height) {
    super(node, editor, x, y, width, height);
    this._angularGauge = new YAngularGauge(this.UIContainer, YWidget.log);
    this._genRenderer = this._angularGauge;
    this.noDataSourcepanel = this._angularGauge.addMessagePanel();
    this.noDataSourcepanel.font.size = constants.generalFontSize;
    this.noDataSourcepanel.text = 'No data source configured\n 1 - Make sure you have a Yoctopuce sensor connected.\n 2 - Do a right-click  or a long touch on this widget.\n 3 - Choose "Configure this gauge" to bring up the properties editor.\n 4 - Choose a data source\n';
    this.prop = new AngularGaugeFormProperties(node, this);
    this._genProp = this.prop;
    let propDesc = GenericProperties.getAllProperties(this.prop);
    if (_angularGaugeWidget.AnnotationPanelCount == 0) {
      for (let propname in propDesc.byName) {
        if (propname.startsWith("AngularGauge_annotationPanel"))
          _angularGaugeWidget.AnnotationPanelCount++;
        if (propname.startsWith("AngularGauge_zone"))
          _angularGaugeWidget.zonesCount++;
      }
    }
    for (let i = 0; i < _angularGaugeWidget.zonesCount; i++) {
      this._angularGauge.AddZone();
    }
    for (let i = 0; i < _angularGaugeWidget.AnnotationPanelCount; i++) {
      this._angularGauge.addAnnotationPanel();
    }
    this._angularGauge.setPatchAnnotationCallback((s) => {
      return this.AnnotationCallback(s);
    });
    this.initDataNode = node;
    this.updateWindowPositionProperties(this.prop);
    this.prop.ApplyAllProperties(this);
    YDataRenderer.minMaxCheckDisabled = true;
    this.prop.ApplyAllProperties(this._angularGauge);
    YDataRenderer.minMaxCheckDisabled = false;
    this._angularGauge.resetRefrenceSize();
    this._angularGauge.resizeRule = Proportional.ResizeRule.RELATIVETOBOTH;
    this.ApplyRelativeSizeIfRequired();
    if (this.SizeIsRelative)
      this.refreshProperties();
    this._angularGauge.AllowRedraw();
  }
  //#ifndef READONLY
  PropertyChanged2(src) {
    let info = new PropPathinfo();
    let path = src.ExtractPropPath(info);
    switch (info.propType) {
      case "Form":
        GenericProperties.copyProperty_STT(this, this.prop, info.fullpropname, path);
        break;
      case "AngularGauge":
        GenericProperties.copyProperty_STT(this._angularGauge, this.prop, info.fullpropname, path);
        break;
      case "DataSource":
        break;
    }
  }
  Get_PropertyValue(src) {
    let info = new PropPathinfo();
    let path = src.ExtractPropPath(info);
    switch (info.propType) {
      case "Form":
        return GenericProperties.newGetProperty(this, this.prop, info.fullpropname, path, null);
      case "AngularGauge":
        return GenericProperties.newGetProperty(this._angularGauge, this.prop, info.fullpropname, path, null);
    }
    return null;
  }
  edit() {
    super.edit();
    YWebPage.EditObject(this, this.prop, (src) => {
      this.PropertyChanged2(src);
    }, (src) => {
      return this.Get_PropertyValue(src);
    }, () => {
      this.editStopped();
    });
  }
  refreshProperties() {
    this.prop.RefreshAllProperties(this);
    this.prop.RefreshAllProperties(this._angularGauge);
    YWebPage.refreshPropertiesForm();
  }
  //#endif
  showStatus(status) {
    if (status != "")
      this._angularGauge.value = 0;
    this._angularGauge.showNeedle = status == "";
    this._angularGauge.statusLine = status;
  }
  SourceChanged(value, index) {
    this._angularGauge.DisableRedraw();
    this.noDataSourcepanel.enabled = value instanceof NullYSensor;
    if (value instanceof NullYSensor) {
      this.showStatus("N/A");
      this._angularGauge.unit = "";
    } else if (!value.isOnline()) {
      this.showStatus("OFFLINE");
    } else {
      this.showStatus("");
      this._angularGauge.unit = value.get_unit();
    }
    this._angularGauge.AllowRedraw();
    value.registerCallback(this);
  }
  SensorValuecallback(source, M) {
    if (this.prop == null)
      return;
    if (source == this.prop.DataSource_source) {
      this._angularGauge.DisableRedraw();
      if (this.prop.DataSource_source instanceof NullYSensor) {
        this.showStatus("N/A");
        this._angularGauge.unit = "";
      } else if (!this.prop.DataSource_source.isOnline()) {
        this.showStatus("OFFLINE");
      } else {
        this._angularGauge.DisableRedraw();
        this.showStatus("");
        this._angularGauge.unit = source.get_unit();
        this._angularGauge.value = M.get_averageValue();
        this._angularGauge.AllowRedraw();
      }
      this._angularGauge.AllowRedraw();
    }
  }
  //#ifndef READONLY
  getConfigData() {
    return "<angularGaugeForm>\n" + this.getContentsConfigData() + "</angularGaugeForm>\n";
  }
};
angularGaugeWidget.AnnotationPanelCount = 0;
angularGaugeWidget.zonesCount = 0;
var digitalDisplayWidget = class _digitalDisplayWidget extends YWidget {
  //#ifndef READONLY
  getPropertiesXml() {
    return this.prop.getXml(1);
  }
  //#endif
  containerResized() {
    if (this._display != null)
      this._display.containerResized();
  }
  destroy() {
    this.prop.destroy();
    super.destroy();
    Object.entries(this).forEach((pair) => {
      Reflect.set(this, pair[0], null);
    });
  }
  AnnotationCallback(text) {
    let sensor = this.prop.DataSource_source;
    return this.PatchSensorAnnotationCallback(sensor, text);
  }
  contextMenuIsOpening() {
    YWebPage.snapshotMenuItem.userdata = this;
    YWebPage.snapshotMenuItem.visible = true;
    YWebPage.resetDataViewMenuItem.visible = false;
    if (YWebPage.editMenuItem == null)
      return;
    YWebPage.clearDataloggerMenuItem.visible = false;
    YWebPage.editMenuItem.caption = "Configure this digital display";
    YWebPage.editMenuItem.visible = true;
    YWebPage.deleteMenuItem.caption = "Delete this digital display";
    YWebPage.deleteMenuItem.visible = true;
    YWebPage.addMarkerMenuItem.visible = false;
    YWebPage.disableMarkerMenuItem.visible = false;
    YWebPage.editMenuItem.userdata = this;
    YWebPage.deleteMenuItem.userdata = this;
  }
  get confirmDeleteString() {
    return "Do you really want to delete this digital display ?";
  }
  constructor(node, editor, x, y, width, height) {
    super(node, editor, x, y, width, height);
    this._unit = "";
    this._display = new YDigitalDisplay(this.UIContainer, YWidget.log);
    this._genRenderer = this._display;
    this.noDataSourcepanel = this._display.addMessagePanel();
    this.noDataSourcepanel.font.size = constants.generalFontSize;
    this.noDataSourcepanel.text = 'No data source configured\n 1 - Make sure you have a Yoctopuce sensor connected.\n 2 - Do a right-click  or a long touch on this widget.\n 3 - Choose "Configure this digital display" to bring up the properties editor.\n 4 - Choose a data source\n';
    this.prop = new digitalDisplayFormProperties(node, this);
    this._genProp = this.prop;
    let propDesc = GenericProperties.getAllProperties(this.prop);
    if (_digitalDisplayWidget.AnnotationPanelCount == 0) {
      for (let propname in propDesc.byName) {
        if (propname.startsWith("display_annotationPanel"))
          _digitalDisplayWidget.AnnotationPanelCount++;
      }
    }
    for (let i = 0; i < _digitalDisplayWidget.AnnotationPanelCount; i++) {
      this._display.addAnnotationPanel();
    }
    this._display.setPatchAnnotationCallback((s) => {
      return this.AnnotationCallback(s);
    });
    this._display.valueFormater = (source, value) => {
      return this.valueFormater(source, value);
    };
    this.updateWindowPositionProperties(this.prop);
    this.prop.ApplyAllProperties(this);
    YDataRenderer.minMaxCheckDisabled = true;
    this.prop.ApplyAllProperties(this._display);
    YDataRenderer.minMaxCheckDisabled = false;
    this._display.resetRefrenceSize();
    this._display.AllowPrintScreenCapture = true;
    this._display.resetRefrenceSize();
    this._display.resizeRule = Proportional.ResizeRule.RELATIVETOBOTH;
    this.ApplyRelativeSizeIfRequired();
    if (this.SizeIsRelative)
      this.refreshProperties();
    this._display.AllowRedraw();
  }
  valueFormater(source, value) {
    if (this.prop.DataSource_source instanceof NullYSensor) {
      return "N/A";
    } else if (!this.prop.DataSource_source.isOnline())
      return "OFFLINE";
    let format = this.prop.DataSource_precision;
    let p = format.indexOf(".");
    let n = 0;
    if (p >= 0)
      n = format.length - p - 1;
    let unit = this.prop.DataSource_source.get_unit();
    return value.toFixed(n) + unit;
  }
  //#ifndef READONLY
  PropertyChanged2(src) {
    let info = new PropPathinfo();
    let path = src.ExtractPropPath(info);
    switch (info.propType) {
      case "Form":
        GenericProperties.copyProperty_STT(this, this.prop, info.fullpropname, path);
        break;
      case "display":
        GenericProperties.copyProperty_STT(this._display, this.prop, info.fullpropname, path);
        break;
      case "DataSource":
        break;
    }
  }
  Get_PropertyValue(src) {
    let info = new PropPathinfo();
    let path = src.ExtractPropPath(info);
    switch (info.propType) {
      case "Form":
        return GenericProperties.newGetProperty(this, this.prop, info.fullpropname, path, null);
      case "display":
        return GenericProperties.newGetProperty(this._display, this.prop, info.fullpropname, path, null);
    }
    return null;
  }
  edit() {
    super.edit();
    YWebPage.EditObject(this, this.prop, (src) => {
      this.PropertyChanged2(src);
    }, (src) => {
      return this.Get_PropertyValue(src);
    }, () => {
      this.editStopped();
    });
  }
  refreshProperties() {
    this.prop.RefreshAllProperties(this);
    this.prop.RefreshAllProperties(this._display);
    YWebPage.refreshPropertiesForm();
  }
  //#endif
  SourceChanged(value, index) {
    this.noDataSourcepanel.enabled = value instanceof NullYSensor;
    this.SensorValuecallback(value, null);
    if (value instanceof NullYSensor) {
      this._display.alternateValue = "N/A";
    } else if (!value.isOnline())
      this._display.alternateValue = "OFFLINE";
    value.registerCallback(this);
  }
  SensorValuecallback(source, M) {
    if (this.prop == null)
      return;
    if (this.prop.DataSource_source instanceof NullYSensor) {
      this._display.alternateValue = "N/A";
    } else if (!this.prop.DataSource_source.isOnline()) {
      this._display.alternateValue = "OFFLINE";
    } else if (M == null) {
      this._display.alternateValue = "--" + this._unit;
    } else if (source == this.prop.DataSource_source) {
      this._display.DisableRedraw();
      this._display.alternateValue = null;
      this._display.value = M.get_averageValue();
      this._display.AllowRedraw();
    }
  }
  //#ifndef READONLY
  getConfigData() {
    return "<digitalDisplayForm>\n" + this.getContentsConfigData() + "</digitalDisplayForm>\n";
  }
};
digitalDisplayWidget.AnnotationPanelCount = 0;
var graphWidget = class _graphWidget extends YWidget {
  AnnotationCallback(text) {
    for (let i = 0; i < _graphWidget.SeriesCount; i++) {
      let s = Reflect.get(this.prop, "Graph_series" + i.toString());
      let sensor = s.DataSource_source;
      let name = "None";
      let avgvalue = "N/A";
      let minvalue = "N/A";
      let maxvalue = "N/A";
      let unit = "";
      if (!(sensor instanceof NullYSensor)) {
        let resolution = -Math.round(Math.log10(sensor.get_resolution()));
        name = s.legend != "" ? s.legend : sensor.get_friendlyName();
        if (sensor.isOnline()) {
          avgvalue = sensor.get_lastAvgValue().toFixed(resolution);
          minvalue = sensor.get_lastMinValue().toFixed(resolution);
          maxvalue = sensor.get_lastMaxValue().toFixed(resolution);
        }
        unit = sensor.get_unit();
      }
      text = text.replace("$NAME" + (i + 1).toString() + "$", name);
      text = text.replace("$AVGVALUE" + (i + 1).toString() + "$", avgvalue);
      text = text.replace("$MAXVALUE" + (i + 1).toString() + "$", maxvalue);
      text = text.replace("$MINVALUE" + (i + 1).toString() + "$", minvalue);
      text = text.replace("$UNIT" + (i + 1).toString() + "$", unit);
    }
    return text;
  }
  destroy() {
    this.prop.destroy();
    super.destroy();
    Object.entries(this).forEach((pair) => {
      Reflect.set(this, pair[0], null);
    });
  }
  //#ifndef READONLY
  getPropertiesXml() {
    return this.prop.getXml(1);
  }
  //#endif
  containerResized() {
    if (this._graph != null)
      this._graph.containerResized();
  }
  contextMenuIsOpening() {
    YWebPage.snapshotMenuItem.userdata = this;
    YWebPage.snapshotMenuItem.visible = true;
    YWebPage.resetDataViewMenuItem.visible = true;
    YWebPage.resetDataViewMenuItem.userdata = this;
    if (YWebPage.editMenuItem == null)
      return;
    YWebPage.clearDataloggerMenuItem.visible = true;
    YWebPage.clearDataloggerMenuItem.userdata = this;
    YWebPage.editMenuItem.caption = "Configure this graph";
    YWebPage.editMenuItem.visible = true;
    YWebPage.deleteMenuItem.caption = "Delete this graph";
    YWebPage.deleteMenuItem.visible = true;
    YWebPage.addMarkerMenuItem.visible = true;
    YWebPage.disableMarkerMenuItem.visible = true;
    YWebPage.editMenuItem.userdata = this;
    YWebPage.deleteMenuItem.userdata = this;
    YWebPage.disableMarkerMenuItem.userdata = this;
    for (let i = 0; i < YWebPage.markersSubMenuItems.length; i++) {
      YWebPage.markersSubMenuItems[i].caption = "Place marker #" + (i + 1).toString();
      YWebPage.markersSubMenuItems[i].userdata = this;
    }
  }
  startMarkerCapture(markerIndex) {
    this.markers[markerIndex].startCapture();
  }
  AxisParamtersChangedAutomatically(source) {
    let yaxis = source.userData;
    yaxis.visible = source.visible;
    YWebPage.refreshPropertiesForm();
  }
  //#ifndef READONLY
  get confirmDeleteString() {
    return "Do you really want to delete this graph ?";
  }
  //#endif
  constructor(node, editor, x, y, width, height) {
    super(node, editor, x, y, width, height);
    this.editedMarkerWasEnabled = false;
    this.editedMarkerPosition = 0;
    this._graph = new YGraph(this.UIContainer, YWidget.log);
    this.noDataSourcepanel = this._graph.addMessagePanel();
    this.noDataSourcepanel.font.size = constants.generalFontSize;
    this.noDataSourcepanel.text = 'No data source configured\n 1 - Make sure you have a Yoctopuce sensor connected.\n 2 - Do a right-click  or a long touch on this widget.\n 3 - Choose "Configure this graph" to bring up the properties editor.\n 4 - Choose a data source\n';
    this.dataloggerProgress = this._graph.addMessagePanel();
    this.dataloggerProgress.font.size = 12 * constants.guiDPIFactor;
    this.dataloggerProgress.font.color = YColor.DarkGray;
    this.dataloggerProgress.borderColor = YColor.Gray;
    this.dataloggerProgress.panelHrzAlign = MessagePanel.HorizontalAlignPos.LEFT;
    this.dataloggerProgress.panelVrtAlign = MessagePanel.VerticalAlignPos.TOP;
    this.dataloggerProgress.text = _graphWidget.DataLoggerLoadingMsg;
    this.dataloggerProgress.enabled = false;
    this.prop = new GraphFormProperties(node, this);
    this._genProp = this.prop;
    let propDesc = GenericProperties.getAllProperties(this.prop);
    if (_graphWidget.YAxisCount == 0) {
      for (let propname in propDesc.byName) {
        if (propname.startsWith("Graph_annotationPanel"))
          _graphWidget.AnnotationPanelCount++;
        if (propname.startsWith("Graph_series"))
          _graphWidget.SeriesCount++;
        if (propname.startsWith("Graph_yAxes"))
          _graphWidget.YAxisCount++;
      }
    }
    if (_graphWidget.ZoneCountPerYaxis == 0) {
      let yAxisProp = new YaxisDescription(0, false);
      let propDesc2 = GenericProperties.getAllProperties(yAxisProp);
      for (let propname in propDesc2.byName) {
        if (propname.startsWith("zones"))
          _graphWidget.ZoneCountPerYaxis++;
      }
    }
    if (_graphWidget.MarkerCountPerXaxis == 0) {
      let xAxisProp = new XaxisDescription();
      let propDesc2 = GenericProperties.getAllProperties(xAxisProp);
      for (let propname in propDesc2.byName) {
        if (propname.startsWith("markers"))
          _graphWidget.MarkerCountPerXaxis++;
      }
    }
    this.offLineSourcesPanel = this._graph.addMessagePanel();
    this.offLineSourcesPanel.bgColor = YColor.FromArgb(192, 255, 192, 192);
    this.offLineSourcesPanel.borderColor = YColor.DarkRed;
    this.offLineSourcesPanel.font.color = YColor.DarkRed;
    this.offLineSourcesPanel.panelHrzAlign = MessagePanel.HorizontalAlignPos.RIGHT;
    this.offLineSourcesPanel.panelVrtAlign = MessagePanel.VerticalAlignPos.TOP;
    this.captureRunningPanel = this._graph.addMessagePanel();
    this.captureRunningPanel.bgColor = YColor.FromArgb(240, 200, 255, 193);
    this.captureRunningPanel.borderColor = YColor.DarkGreen;
    this.captureRunningPanel.font.color = YColor.DarkGreen;
    this.captureRunningPanel.panelHrzAlign = MessagePanel.HorizontalAlignPos.LEFT;
    this.captureRunningPanel.panelVrtAlign = MessagePanel.VerticalAlignPos.TOP;
    for (let i = 0; i < _graphWidget.YAxisCount; i++) {
      let axis = this._graph.addYAxis();
      for (let j = 0; j < _graphWidget.ZoneCountPerYaxis; j++) {
        axis.AddZone();
      }
    }
    this.markers = [];
    for (let i = 0; i < _graphWidget.MarkerCountPerXaxis; i++) {
      let m = this._graph.xAxis.AddMarker();
      m.xposition = TimeConverter.ToUnixTime(/* @__PURE__ */ new Date()) + i * 60;
      this.markers.push(m);
    }
    for (let i = 0; i < _graphWidget.AnnotationPanelCount; i++) {
      this._graph.addAnnotationPanel();
    }
    this.seriesProperties = [];
    for (let i = 0; i < _graphWidget.SeriesCount; i++) {
      this.seriesProperties.push(Reflect.get(this.prop, "Graph_series" + i.toString()));
      this._graph.addSerie();
    }
    this._graph.yAxes[0].visible = true;
    this._graph.setPatchAnnotationCallback((s) => {
      return this.AnnotationCallback(s);
    });
    this._genRenderer = this._graph;
    this._graph.resetRefrenceSize();
    this._graph.AllowPrintScreenCapture = true;
    this._graph.setMarkerCaptureCallbacks((m) => {
      this.MarkedCaptureStarted(m);
    }, (m) => {
      this.MarkedCaptureStopped(m);
    });
    this.offlineMessages = new Array(_graphWidget.SeriesCount);
    this.showOffline = new Array(_graphWidget.SeriesCount);
    this.updateWindowPositionProperties(this.prop);
    this.prop.ApplyAllProperties(this);
    YDataRenderer.minMaxCheckDisabled = true;
    this.prop.ApplyAllProperties(this._graph);
    YDataRenderer.minMaxCheckDisabled = false;
    for (let i = 0; i < _graphWidget.YAxisCount; i++) {
      this._graph.yAxes[i].AxisChanged = () => {
        this.AxisParamtersChangedAutomatically(this._graph.yAxes[i]);
      };
      this._graph.yAxes[i].AllowAutoShow = true;
    }
    for (let i = 0; i < _graphWidget.SeriesCount; i++) {
      let s = Reflect.get(this.prop, "Graph_series" + i.toString());
      s.Init(this, i);
      if (s.DataSource_source != null) {
        this.SourceChanged(s.DataSource_source, i);
      }
    }
    this._graph.resetRefrenceSize();
    this._graph.resizeRule = Proportional.ResizeRule.FIXED;
    this.ApplyRelativeSizeIfRequired();
    if (this.SizeIsRelative)
      this.refreshProperties();
    this.loadRecordedDataIfNeeded();
    this._graph.AllowRedraw();
  }
  MarkedCaptureStarted(src) {
    let str = src.text != "" ? 'Click to place the "' + src.shortText + '" marker.' : "Click to place the marker.";
    str += "\nRight-click to cancel the operation.";
    this.editedMarkerWasEnabled = src.enabled;
    this.editedMarkerPosition = src.positionOnXAxis.value;
    this.captureRunningPanel.text = str;
    this.captureRunningPanel.enabled = true;
  }
  MarkedCaptureStopped(src) {
    if (src != null) {
      if (this.editedMarkerWasEnabled != src.enabled && this.editedMarkerPosition != src.positionOnXAxis.value) {
        constants.edited = true;
      }
    }
    this.captureRunningPanel.enabled = false;
    this.refreshProperties();
  }
  refreshProperties() {
    this.prop.RefreshAllProperties(this);
    this.prop.RefreshAllProperties(this._graph);
    YWebPage.refreshPropertiesForm();
  }
  //#endif
  decomposeToSegments(data, start, dataCount) {
    let n1 = start;
    let n2 = 0;
    let l = [];
    let deltaT = 0;
    while (n1 < start + dataCount - 1) {
      try {
        deltaT = data[n1 + 1].DateTime - data[n1].DateTime;
      } catch (Exception) {
        debugger;
      }
      n2 = n1 + 1;
      while (n2 < dataCount && data[n2].DateTime - data[n2 - 1].DateTime < 2 * deltaT) {
        n2++;
      }
      let count = n2 - n1;
      if (count > 0) {
        let p = new Array(count);
        for (let i = 0; i < count; i++) {
          p[i] = new pointXY(data[n1 + i].DateTime, data[n1 + i].value);
        }
        l.push(p);
      }
      n1 = n2;
    }
    return l;
  }
  SourceChanged(value, index) {
    this._graph.DisableRedraw();
    let s;
    let noDataSource = true;
    for (let i = 0; i < _graphWidget.SeriesCount; i++) {
      s = Reflect.get(this.prop, "Graph_series" + i.toString());
      if (!(s.DataSource_source instanceof NullYSensor))
        noDataSource = false;
    }
    this.noDataSourcepanel.enabled = noDataSource;
    if (value != null) {
      if (!(value instanceof NullYSensor)) {
        if (value.isOnline()) {
          this.showOffline[index] = false;
        } else {
          this.offlineMessages[index] = value.get_friendlyName() + " is OFFLINE";
          this.showOffline[index] = true;
          logForm.log(value.get_friendlyName() + " is OFFLINE");
        }
      } else {
        this.showOffline[index] = false;
      }
    } else {
      this.showOffline[index] = false;
    }
    this.updateOfflinePanel();
    this.preLoadSensorData(value, index);
    this.loadRecordedDataIfNeeded();
    if (value)
      value.registerCallback(this);
    this._graph.AllowRedraw();
  }
  SensorArrivalcallback(source) {
    this.loadRecordedDataIfNeeded();
    for (let i = 0; i < _graphWidget.SeriesCount; i++) {
      let s = this.seriesProperties[i];
      if (s.DataSource_source == source) {
        if (!s.DataSource_source.isOnline())
          this.showOffline[i] = true;
        else
          this.showOffline[i] = false;
      }
    }
    this.updateOfflinePanel();
  }
  preLoadSensorData(value, index) {
    if (value instanceof NullYSensor) {
      this._graph.series[index].clear();
      return;
    }
    let s = Reflect.get(this.prop, "Graph_series" + index.toString());
    let data;
    switch (s.DataSource_datatype) {
      case 1:
        data = value.minData;
        break;
      case 2:
        data = value.maxData;
        break;
      default:
        data = value.curData;
        break;
    }
    let l = this.decomposeToSegments(data, 0, data.length);
    this._graph.series[index].clear();
    for (let i = l.length - 1; i >= 0; i--) {
      this._graph.series[index].InsertPoints(l[i]);
    }
    this._graph.series[index].rebuildSummaries();
  }
  //#ifndef READONLY
  PropertyChanged2(src) {
    let info = new PropPathinfo();
    let path = src.ExtractPropPath(info);
    switch (info.propType) {
      case "Form":
        GenericProperties.copyProperty_STT(this, this.prop, info.fullpropname, path);
        break;
      case "Graph":
        GenericProperties.copyProperty_STT(this._graph, this.prop, info.fullpropname, path);
        break;
      case "DataSource":
        break;
    }
  }
  Get_PropertyValue(src) {
    let info = new PropPathinfo();
    let path = src.ExtractPropPath(info);
    switch (info.propType) {
      case "Form":
        return GenericProperties.newGetProperty(this, this.prop, info.fullpropname, path, null);
      case "Graph":
        return GenericProperties.newGetProperty(this._graph, this.prop, info.fullpropname, path, null);
      case "DataSource":
        return null;
    }
    return null;
  }
  edit() {
    super.edit();
    YWebPage.EditObject(this, this.prop, (src) => {
      this.PropertyChanged2(src);
    }, (src) => {
      return this.Get_PropertyValue(src);
    }, () => {
      this.editStopped();
    });
  }
  //#endif
  updateOfflinePanel() {
    let message = "";
    for (let i = 0; i < _graphWidget.SeriesCount; i++) {
      if (this.showOffline[i])
        message = message + (message != "" ? "\n" : "") + this.offlineMessages[i];
    }
    if (message == "" && this.offLineSourcesPanel.enabled)
      this.offLineSourcesPanel.enabled = false;
    if (message != "" && (this.offLineSourcesPanel.text != message || !this.offLineSourcesPanel.enabled)) {
      this.offLineSourcesPanel.text = message;
      this.offLineSourcesPanel.enabled = true;
    }
  }
  SensorValuecallback(source, M) {
    if (this.prop == null)
      return;
    for (let i = 0; i < _graphWidget.SeriesCount; i++) {
      let s = this.seriesProperties[i];
      if (s.DataSource_source == source) {
        if (!s.DataSource_source.isOnline()) {
          this.offlineMessages[i] = s.DataSource_source.get_friendlyName() + " is OFFLINE";
          this.showOffline[i] = true;
          this.updateOfflinePanel();
          return;
        }
        this.showOffline[i] = false;
        this.updateOfflinePanel();
        let index = s.DataSource_source.curData.length - 1;
        if (index >= 0)
          switch (s.DataSource_datatype) {
            case 1:
              this._graph.series[i].AddPoint(new pointXY(s.DataSource_source.minData[index].DateTime, s.DataSource_source.minData[index].value));
              break;
            case 2:
              this._graph.series[i].AddPoint(new pointXY(s.DataSource_source.maxData[index].DateTime, s.DataSource_source.maxData[index].value));
              break;
            default:
              this._graph.series[i].AddPoint(new pointXY(s.DataSource_source.curData[index].DateTime, s.DataSource_source.curData[index].value));
              break;
          }
        this._graph.series[i].unit = s.DataSource_source.get_unit();
      }
    }
  }
  disableAllMarkers() {
    confirm.ask("Do you really want to disable all markers?", () => {
      for (let i = 0; i < this.markers.length; i++) {
        this.markers[i].enabled = false;
      }
    }, () => {
    }, null);
  }
  clearDataLogger() {
    confirm.ask("Do you really want to erase contents of all dataloggers related to this graph?", () => {
      this.startToClearDataLoggers();
    }, () => {
    }, null);
  }
  truncateView() {
    for (let i = 0; i < _graphWidget.SeriesCount; i++) {
      this._graph.series[i].clear();
    }
    let FirstLiveValue = Math.floor((/* @__PURE__ */ new Date()).getTime() / 1e3);
    this._graph.xAxis.set_minMax(FirstLiveValue, FirstLiveValue + this._graph.xAxis.initialZoom);
  }
  resetDataView() {
    this.prop.Graph_showRecordedData = false;
    this.truncateView();
  }
  async startToClearDataLoggers() {
    let loggers = [];
    for (let i = 0; i < _graphWidget.SeriesCount; i++) {
      let s = Reflect.get(this.prop, "Graph_series" + i.toString());
      let sensor = s.DataSource_source;
      if (!(sensor instanceof NullYSensor)) {
        sensor.stopDataloggerloading();
        let serial = sensor.get_hardwareId();
        let n = serial.indexOf(".");
        serial = serial.substring(0, n);
        let d = await YDataLogger.FindDataLogger(serial + ".dataLogger");
        if (await d.isOnline()) {
          let found = false;
          for (let j = 0; j < loggers.length; j++) {
            if (loggers[j] == d)
              found = true;
          }
          if (!found)
            loggers.push(d);
        }
      }
    }
    for (let i = 0; i < loggers.length; i++) {
      await loggers[i].forgetAllDataStreams();
      await loggers[i].set_recording(YDataLogger.RECORDING_ON);
    }
    let tmp = this.prop.Graph_showRecordedData;
    this.prop.Graph_showRecordedData = false;
    this.truncateView();
    this.prop.Graph_showRecordedData = tmp;
  }
  dataLoggerLoadprocessIsRunningNotification(source) {
    let loadTotalPercent = 0;
    let sensorCount = 0;
    if (!this.prop.Graph_showRecordedData)
      return;
    for (let i = 0; i < _graphWidget.SeriesCount; i++) {
      let s = Reflect.get(this.prop, "Graph_series" + i.toString());
      let sensor = s.DataSource_source;
      if (sensor.dataloggerLoadisRunning) {
        loadTotalPercent += sensor.dataloggerLoadProgress;
        sensorCount++;
      }
    }
    if (sensorCount > 0)
      this.dataloggerProgress.text = _graphWidget.DataLoggerLoadingMsg + " (" + (loadTotalPercent / sensorCount).toFixed(0) + "%)";
    let showPanel = sensorCount > 0 && loadTotalPercent > 0 && loadTotalPercent < sensorCount * 100;
    this.dataloggerProgress.enabled = showPanel;
  }
  /*
      public startDataPreload(source: YoctoVisualization.CustomYSensor)
          {
  
             if (!this.prop.Graph_showRecordedData)
             {
                this.dataloggerProgress.enabled=false;
                return;
            }
              this.dataloggerProgress.enabled=true;
  
          }
  
       */
  SensorNewDataBlock(source, sourceFromIndex, sourcetoIndex, targetIndex, fromDataLogger) {
    if (this.prop == null)
      return;
    if (fromDataLogger && !this.prop.Graph_showRecordedData)
      return;
    let l = null;
    for (let i = 0; i < _graphWidget.SeriesCount; i++) {
      let s = Reflect.get(this.prop, "Graph_series" + i.toString());
      if (s.DataSource_source == source) {
        let count = sourcetoIndex - sourceFromIndex + 1;
        if (count > 1) {
          switch (s.DataSource_datatype) {
            case 1:
              l = this.decomposeToSegments(s.DataSource_source.minData, sourceFromIndex, count);
              for (let j = l.length - 1; j >= 0; j--) {
                this._graph.series[i].InsertPoints(l[j]);
              }
              break;
            case 2:
              l = this.decomposeToSegments(s.DataSource_source.maxData, sourceFromIndex, count);
              for (let j = l.length - 1; j >= 0; j--) {
                this._graph.series[i].InsertPoints(l[j]);
              }
              break;
            default:
              l = this.decomposeToSegments(s.DataSource_source.curData, sourceFromIndex, count);
              for (let j = l.length - 1; j >= 0; j--) {
                this._graph.series[i].InsertPoints(l[j]);
              }
              break;
          }
        }
        this._graph.series[i].unit = source.get_unit();
      }
    }
  }
  loadRecordedDataIfNeeded() {
    if (this.prop == null)
      return;
    if (!this.prop.Graph_showRecordedData)
      return;
    for (let i = 0; i < _graphWidget.SeriesCount; i++) {
      let s = Reflect.get(this.prop, "Graph_series" + i.toString());
      s.DataSource_source.startDataloggerload(this);
    }
  }
  removeDataloggerData() {
  }
  /*
      public DataLoggerProgress(): void
      {
          let progress: number = 0;
          let sensorCount: number = 0;
  
          if (!this.prop.Graph_showRecordedData)
          {
              this.dataloggerProgress.enabled=false;
              return;
          }
  
          let props: YoctoVisualization.PropertiesList = YoctoVisualization.GenericProperties.getAllProperties(this.prop);
          for (let i: number = 0; i < props.byIndex.length; i++)
          {
              let name = props.byIndex[i].name;
              if (name.startsWith("Graph_series"))
              {
                  let s: YoctoVisualization.ChartSerie = Reflect.get(this.prop, name);
                  if (!(s.DataSource_source instanceof YoctoVisualization.NullYSensor))
                  {
                      progress += s.DataSource_source.getGetaLoadProgress();
                      sensorCount++;
                  }
              }
          }
  
          if ((progress < 100 * sensorCount) && (sensorCount > 0))
          {  this.dataloggerProgress.text  = graphWidget.DataLoggerLoadingMsg+" (" + (progress / sensorCount).toFixed(0) + "%)";
  
          }
          else
          {
              this.dataloggerProgress.enabled=false;
          }
      }
      */
  DataloggerCompleted(Source) {
    if (!this.prop.Graph_showRecordedData)
      return;
    let props = GenericProperties.getAllProperties(this.prop);
    for (let i = 0; i < this.seriesProperties.length; i++) {
      if (this.seriesProperties[i].DataSource_source == Source) {
        if (!this.seriesProperties[i].dataloggerAlreadyLoaded) {
          this._graph.DisableRedraw();
          this.preLoadSensorData(Source, i);
          this._graph.AllowRedraw();
        }
      }
    }
  }
  //#ifndef READONLY
  getConfigData() {
    return "<GraphForm>\n" + this.getContentsConfigData() + "</GraphForm>\n";
  }
};
graphWidget.AnnotationPanelCount = 0;
graphWidget.SeriesCount = 0;
graphWidget.ZoneCountPerYaxis = 0;
graphWidget.MarkerCountPerXaxis = 0;
graphWidget.YAxisCount = 0;
graphWidget.DataLoggerLoadingMsg = "Loading from datalogger";

// obj/full/propertiesMngmt.js
var YXmlNode = class _YXmlNode {
  constructor(node) {
    this.node = node;
  }
  get Name() {
    return this.node.nodeName;
  }
  get_childsByName() {
    let res = {};
    this.node.childNodes.forEach((child) => {
      res[child.nodeName] = new _YXmlNode(child);
    });
    return res;
  }
  get_childsByIndex() {
    let res = [];
    this.node.childNodes.forEach((child) => {
      res.push(new _YXmlNode(child));
    });
    return res;
  }
  get_attributes() {
    let el = this.node;
    let res = {};
    let keys = el.getAttributeNames();
    for (let i = 0; i < keys.length; i++) {
      res[keys[i]] = el.getAttribute(keys[i]);
    }
    return res;
  }
  get Attributes() {
    return this.get_attributes();
  }
};
var PropertyAccess = class {
  constructor() {
    this.ttype = "";
    this.stype = "";
    this.finalTarget = null;
    this.terminalSource = null;
    this.propertyName = null;
  }
};
var doubleNan = class _doubleNan {
  constructor(v) {
    this._value = Number.NaN;
    if (typeof v == "undefined") {
      return;
    } else if (typeof v == "number") {
      this._value = v;
    } else if (typeof v == "string") {
      if (v == "") {
        this._value = Number.NaN;
      } else {
        this._value = Number(v);
      }
    } else {
      debugger;
    }
  }
  toString() {
    if (Number.isNaN(this._value))
      return "";
    return this._value.toString();
  }
  clone() {
    return new _doubleNan(this.value);
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value;
  }
};
var PropertyDescriptor = class {
  constructor(name) {
    this.isWritable = false;
    this.isEnum = false;
    this.type = "";
    this.Attributes = {};
    this.name = name;
  }
};
var PropertiesList = class {
  constructor() {
    this.byIndex = [];
    this.byName = {};
  }
};
var PropDescription = class {
  constructor(name, prop) {
    this.name = name;
    this.prop = prop;
  }
};
var GenericProperties = class _GenericProperties {
  static NoFilter(propNname) {
    return true;
  }
  static escapeXml(unsafe) {
    return unsafe.replace(/[^ !#$%(-;=?-z]/g, (c) => "&#" + c.charCodeAt(0) + ";");
  }
  constructor(Owner) {
    this._Form_Text = "New window";
    this._Form_BackColor = YColor.FromArgb(255, 240, 240, 240);
    this._Form_BorderColor = YColor.LightGray;
    this._SizeIsRelative = false;
    this._Form_PositionX = 0;
    this._Form_PositionY = 0;
    this._Form_Width = 300;
    this._Form_Height = 200;
    this._containerID = "";
    this.ownerForm = Owner;
    this._Form_Text = "new window";
  }
  destroy() {
    Object.entries(this).forEach((pair) => {
      Reflect.set(this, pair[0], null);
    });
  }
  initFromXmlData(initData) {
    if (initData != null)
      this.loadProperties(initData, this.ownerForm, this);
  }
  loadProperties(initData, Owner, o) {
    let value;
    this.ownerForm = Owner;
    if (initData != null) {
      let properties = _GenericProperties.getAllProperties(o);
      let childs = initData.get_childsByName();
      for (let propname in properties.byName) {
        let p = properties.byName[propname];
        if (p.isWritable) {
          for (let childName in childs) {
            if (childName == propname) {
              let target = Reflect.get(o, propname);
              let Mustload = true;
              if ("NotSavedInXMLAttribute" in p.Attributes) {
                Mustload = p.Attributes["NotSavedInXMLAttribute"];
              }
              if (Mustload) {
                if (_GenericProperties.IsStructured(target)) {
                  this.loadProperties(childs[childName], Owner, target);
                } else {
                  let targetType = typeof target;
                  let attributes = childs[childName].get_attributes();
                  let value2 = attributes["value"];
                  if (target instanceof CustomYSensor) {
                    if (value2.toUpperCase() != "NULL" && value2 != "") {
                      let s = sensorsManager.AddNewSensor(value2);
                      Reflect.set(o, propname, s);
                    } else {
                      Reflect.set(o, propname, sensorsManager.getNullSensor());
                    }
                  } else if (target instanceof YEnumItem) {
                    Reflect.set(o, propname, target.fromString(value2));
                  } else if (target instanceof doubleNan) {
                    let d = new doubleNan(value2);
                    Reflect.set(o, propname, d);
                  } else if (target instanceof xAxisPosition) {
                    let xpos = Number(value2);
                    let rel = attributes["relative"].toUpperCase() == "TRUE";
                    Reflect.set(o, propname, new xAxisPosition(xpos, rel));
                  } else if (target instanceof YColor) {
                    let c = YColor.FromString(value2);
                    if (c == null)
                      c = YColor.Black;
                    Reflect.set(o, propname, c.clone());
                  } else if (target instanceof YFont) {
                    let size = attributes["size"];
                    let color = attributes["color"];
                    let italic = attributes["italic"];
                    let bold = attributes["bold"];
                    let f = Reflect.get(o, propname);
                    f.name = value2;
                    f.size = size !== "undefined" ? Number(size) : 10;
                    let c = YColor.FromString(color);
                    f.color = c != null ? c : YColor.Black.clone();
                    f.italic = italic.toUpperCase() == "TRUE";
                    f.bold = bold.toUpperCase() == "TRUE";
                  } else {
                    switch (targetType) {
                      case "string":
                        Reflect.set(o, propname, value2);
                        break;
                      case "number":
                        Reflect.set(o, propname, Number(value2));
                        break;
                      case "boolean":
                        let v = value2.toUpperCase() == "TRUE";
                        Reflect.set(o, propname, v);
                        break;
                      default:
                        debugger;
                        throw "unhandled target type : " + targetType + "(" + target.constructor.name + ")";
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  get ATTR_Form_Text__DisplayName() {
    return "Window title";
  }
  get ATTR_Form_Text__CategoryAttribute() {
    return "Window";
  }
  get ATTR_Form_Text__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_Form_Text__DescriptionAttribute() {
    return "Widget name. This name is not show on display, but it might help you to identify each widget. ";
  }
  get Form_Text() {
    return this._Form_Text;
  }
  set Form_Text(value) {
    this._Form_Text = value;
  }
  get ATTR_Form_BackColor__DisplayName() {
    return "Background color";
  }
  get ATTR_Form_BackColor__CategoryAttribute() {
    return "Window";
  }
  get ATTR_Form_BackColor__DescriptionAttribute() {
    return "Window background color.";
  }
  get Form_BackColor() {
    return this._Form_BackColor;
  }
  set Form_BackColor(value) {
    this._Form_BackColor = value;
  }
  get ATTR_Form_BorderColor__DisplayName() {
    return "Border color";
  }
  get ATTR_Form_BorderColor__CategoryAttribute() {
    return "Window";
  }
  get ATTR_Form_BorderColor__DescriptionAttribute() {
    return "Window border color, use transparent color to hide the border.";
  }
  get Form_BorderColor() {
    return this._Form_BorderColor;
  }
  set Form_BorderColor(value) {
    this._Form_BorderColor = value;
  }
  get ATTR_Form_SizeIsRelative__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_Form_SizeIsRelative__DisplayName() {
    return "Rel. size and pos.";
  }
  get ATTR_Form_SizeIsRelative__CategoryAttribute() {
    return "Window";
  }
  get ATTR_Form_SizeIsRelative__DescriptionAttribute() {
    return "Makes widget size and position relative to container size. This, for instance, allows to make a widget automatically occupy all of the browser viewport, no matter the browser window size. In relative mode, position and size value are expressed in %";
  }
  get ATTR_Form_SizeIsRelative__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get Form_SizeIsRelative() {
    return this._SizeIsRelative;
  }
  set Form_SizeIsRelative(value) {
    this._SizeIsRelative = value;
  }
  // Form/widget positions are handled differently (inheritance from the C# version)
  get ATTR_Form_PositionX__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_Form_PositionX__DisplayName() {
    return "Left";
  }
  get ATTR_Form_PositionX__CategoryAttribute() {
    return "Window";
  }
  get ATTR_Form_PositionX__DescriptionAttribute() {
    return "Widget left border X position";
  }
  get Form_PositionX() {
    return this._Form_PositionX;
  }
  set Form_PositionX(value) {
    this._Form_PositionX = value;
  }
  // Form/widget positions are handled differently (inheritance from the C# version)
  get ATTR_Form_PositionY__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_Form_PositionY__DisplayName() {
    return "Top";
  }
  get ATTR_Form_PositionY__CategoryAttribute() {
    return "Window";
  }
  get ATTR_Form_PositionY__DescriptionAttribute() {
    return "Widget top border Y position";
  }
  get Form_PositionY() {
    return this._Form_PositionY;
  }
  set Form_PositionY(value) {
    this._Form_PositionY = value;
  }
  // Form/widget positions are handled differently (inheritance from the C# version)
  get ATTR_Form_Width__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_Form_Width__DisplayName() {
    return "Width";
  }
  get ATTR_Form_Width__CategoryAttribute() {
    return "Window";
  }
  get ATTR_Form_Width__DescriptionAttribute() {
    return "Widget width";
  }
  get Form_Width() {
    return this._Form_Width;
  }
  set Form_Width(value) {
    this._Form_Width = value;
  }
  // Form/widget positions are handled differently (inheritance from the C# version)
  get ATTR_Form_Height__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_Form_Height__DisplayName() {
    return "Height";
  }
  get ATTR_Form_Height__CategoryAttribute() {
    return "Window";
  }
  get ATTR_Form_Height__DescriptionAttribute() {
    return "Widget height";
  }
  get Form_Height() {
    return this._Form_Height;
  }
  set Form_Height(value) {
    this._Form_Height = value;
  }
  get ATTR_Form_containerID__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_Form_containerID__DisplayName() {
    return "Container ID";
  }
  get ATTR_Form_containerID__CategoryAttribute() {
    return "Window";
  }
  get ATTR_Form_containerID__DescriptionAttribute() {
    return "Forces the widget to be shown inside an HTML element with a specific ID already present on the page. If ID is empty, the widget is inserted at root level. Be aware that X,Y offsets are kept, you may want to set them to Zero. ";
  }
  get Form_containerID() {
    return this._containerID;
  }
  set Form_containerID(value) {
    this._containerID = value;
  }
  indent(n) {
    return " ".repeat(n);
  }
  //#ifndef READONLY
  getXml(deep, o) {
    if (typeof o == "undefined")
      o = this;
    let res = "";
    let value = "";
    let properties = _GenericProperties.getAllProperties(o);
    let propName = "";
    for (propName in properties.byName) {
      let p = properties.byName[propName];
      if (p.isWritable) {
        let Mustsave = true;
        if ("NotSavedInXMLAttribute" in p.Attributes)
          Mustsave = !p.Attributes["NotSavedInXMLAttribute"];
        let child = Reflect.get(o, p.name);
        if (_GenericProperties.IsStructured(child)) {
          if (Mustsave) {
            res = res + this.indent(2 * deep) + "<" + p.name + ">\r\n" + this.getXml(deep + 1, child) + this.indent(2 * deep) + "</" + p.name + ">\r\n";
          }
        } else {
          if (Mustsave) {
            if (child instanceof YEnumItem) {
              value = child.toString;
            } else {
              let type = typeof child;
              if (type == "object")
                type = child.constructor.name;
              switch (type) {
                case "boolean":
                  value = child ? "TRUE" : "FALSE";
                  break;
                case "number":
                  value = child.toString();
                  break;
                case "string":
                  value = GenericProperties.escapeXml(child);
                  break;
                case YColor.name:
                  value = child.toString();
                  break;
                case doubleNan.name:
                  value = child.value.toString();
                  break;
                case xAxisPosition.name:
                  let it = child;
                  value = it.value.toString() + '" relative="' + (it.relative ? "True" : "False");
                  break;
                case NullYSensor.name:
                case CustomYSensor.name:
                  let s = child;
                  value = s == null || s instanceof NullYSensor ? "NULL" : s.get_hardwareId();
                  break;
                default:
                  throw "XML generation : unhandled type (" + p.type + ")";
              }
            }
            res = res + this.indent(2 * deep) + "<" + p.name + ' value="' + value + '"/>\n';
          }
        }
      }
    }
    return res;
  }
  //#endif
  static IsStructured(o) {
    if (o == null)
      return false;
    if (typeof o === "string" || o instanceof String)
      return false;
    if (typeof o === "number" || o instanceof Number)
      return false;
    if (typeof o === "boolean" || o instanceof Boolean)
      return false;
    if (o instanceof YEnumItem)
      return false;
    if (o instanceof CustomYSensor)
      return false;
    if (o instanceof YColor)
      return false;
    if (o instanceof doubleNan)
      return false;
    if (o instanceof xAxisPosition)
      return false;
    if (Object.getOwnPropertyNames(o).length > 0)
      return true;
    return false;
  }
  static getObjectFromPath(rootTarget, path) {
    let FinalTarget = rootTarget;
    for (let i = 0; i < path.length - 1; i++) {
      let name = path[i];
      let index = "";
      while (name.charCodeAt(name.length - 1) >= 48 && name.charCodeAt(name.length - 1) <= 57) {
        index = name.charAt(name.length - 1) + index;
        name = name.substring(0, name.length - 1);
      }
      if (index == "") {
        FinalTarget = Reflect.get(FinalTarget, name);
      } else {
        let arrayObject = Reflect.get(FinalTarget, name);
        FinalTarget = Reflect.get(arrayObject, parseInt(index));
      }
    }
    return FinalTarget;
  }
  //Direction Settings From Target
  static computePropertyAccess_SFT(WidgetObject, SettingObject, propertySourceName, path) {
    let res = new PropertyAccess();
    res.ttype = "";
    res.stype = "";
    res.finalTarget = null;
    res.terminalSource = null;
    res.terminalSource = _GenericProperties.getObjectFromPath(WidgetObject, path);
    let props = _GenericProperties.getAllProperties(res.terminalSource);
    if (!(path[path.length - 1] in props.byName))
      return res;
    res.stype = typeof res.terminalSource[path[path.length - 1]];
    if (res.stype == "object" && res.terminalSource[path[path.length - 1]] != null) {
      res.stype = res.terminalSource[path[path.length - 1]].constructor.name;
    }
    res.terminalSource = res.terminalSource[path[path.length - 1]];
    if (res.terminalSource == null)
      return res;
    res.propertyName = propertySourceName;
    res.finalTarget = SettingObject;
    let o = res.finalTarget[propertySourceName];
    res.ttype = typeof o;
    if (res.ttype == "object" && o != null)
      res.ttype = o.constructor.name;
    if (path.length <= 1)
      return res;
    for (let i = 1; i < path.length; i++) {
      res.finalTarget = res.finalTarget[res.propertyName];
      res.propertyName = path[i];
    }
    res.ttype = typeof res.finalTarget[res.propertyName];
    if (res.ttype == "object" && res.finalTarget[res.propertyName] != null)
      res.ttype = res.finalTarget[res.propertyName].constructor.name;
    return res;
  }
  static Reflect_getIndexed(o, indexedProp) {
    let res = Reflect.get(o, indexedProp);
    if (typeof res !== "undefined")
      return res;
    let name = indexedProp;
    let index = "";
    while (name.charCodeAt(name.length - 1) >= 48 && name.charCodeAt(name.length - 1) <= 57) {
      index = name.charAt(name.length - 1) + index;
      name = name.substring(0, name.length - 1);
    }
    if (index == "") {
      return null;
    }
    res = Reflect.get(o, name);
    return Reflect.get(res, parseInt(index));
  }
  static computePropertyAccess(rootTarget, source, propertySourceName, path) {
    let res = new PropertyAccess();
    res.ttype = "";
    res.finalTarget = _GenericProperties.getObjectFromPath(rootTarget, path);
    res.terminalSource = source;
    res.terminalSource = Reflect.get(res.terminalSource, propertySourceName);
    for (let i = 1; i < path.length; i++) {
      res.terminalSource = Reflect.get(res.terminalSource, path[i]);
    }
    res.stype = typeof res.terminalSource;
    if (res.stype == "object")
      res.stype = res.terminalSource.constructor.name;
    if (path.length > 0) {
      res.propertyName = path[path.length - 1];
      let o = _GenericProperties.Reflect_getIndexed(rootTarget, path[0]);
      if (o == null)
        return null;
      for (let i = 1; i < path.length; i++) {
        try {
          o = _GenericProperties.Reflect_getIndexed(o, path[i]);
        } catch (e) {
          debugger;
        }
      }
      res.ttype = typeof o;
      if (res.ttype == "object")
        res.ttype = o.constructor.name;
    } else {
      let targetname = propertySourceName;
      let n = targetname.indexOf("__");
      res.propertyName = targetname.substring(n + 2);
      let o = Reflect.get(rootTarget, res.propertyName);
      res.ttype = typeof o;
      if (res.ttype == "object")
        res.ttype = o.constructor.name;
    }
    return res;
  }
  static newGetProperty(rootTarget, source, propertySourceName, path, filterAllow) {
    let access = _GenericProperties.computePropertyAccess(rootTarget, source, propertySourceName, path);
    if (access == null)
      return null;
    return Reflect.get(access.finalTarget, access.propertyName);
  }
  // Direction : settings From Target
  //Direction : Settings From Target
  //   public static   copyProperty_SFT( rootTarget:object , source :object ,  propertySourceName: string, path: string[]): void
  //     {
  //     copyProperty_SFT(rootTarget, source, propertySourceName, path,  GenericProperties.NoFilter);
  //     }
  static copyProperty_SFT(rootTarget, source, propertySourceName, path, filterAllow) {
    let ttype = "";
    let stype = "";
    let TerminalSource = null;
    let p = _GenericProperties.computePropertyAccess_SFT(rootTarget, source, propertySourceName, path);
    if (p.finalTarget == null)
      return;
    ttype = p.ttype;
    stype = p.stype;
    if (stype == YColor.name && ttype == YColor.name) {
      Reflect.set(p.finalTarget, p.propertyName, p.terminalSource.clone());
    } else if (stype == xAxisPosition.name && ttype == xAxisPosition.name) {
      Reflect.set(p.finalTarget, p.propertyName, p.terminalSource.clone());
    } else if (p.stype == "number" && ttype == doubleNan.name) {
      Reflect.set(p.finalTarget, p.propertyName, new doubleNan(p.terminalSource));
    } else {
      Reflect.set(p.finalTarget, p.propertyName, p.terminalSource);
    }
  }
  //Direction :Settings To Target
  /*
  static public  copyProperty_STT(object rootTarget, object source, string propertySourceName, List<string> path) : void
  {
  copyProperty_STT(rootTarget, source, propertySourceName, path,  NoFilter);
  }
   */
  //Direction :Settings To Target
  static copyProperty_STT(rootTarget, source, propertySourceName, path, filterAllow) {
    let p = _GenericProperties.computePropertyAccess(rootTarget, source, propertySourceName, path);
    if (p == null)
      return;
    if (p.stype == doubleNan.name && p.ttype == "number") {
      let v = p.terminalSource.value;
      if (Reflect.get(p.finalTarget, p.propertyName) != v) {
        Reflect.set(p.finalTarget, p.propertyName, v);
        constants.edited = true;
      }
    } else if (p.stype != p.ttype) {
      debugger;
    } else if (p.stype == YColor.name && p.ttype == YColor.name) {
      let color = p.terminalSource;
      if (!color.equal(Reflect.get(p.finalTarget, p.propertyName))) {
        Reflect.set(p.finalTarget, p.propertyName, color.clone());
        constants.edited = true;
      }
    } else if (p.stype == doubleNan.name && p.ttype == doubleNan.name) {
      let v = p.terminalSource;
      if (Reflect.get(p.finalTarget, p.propertyName) != v) {
        Reflect.set(p.finalTarget, p.propertyName, v.clone());
        constants.edited = true;
      }
    } else if (p.stype == xAxisPosition.name && p.ttype == xAxisPosition.name) {
      let x = p.terminalSource;
      let x2 = Reflect.get(p.finalTarget, p.propertyName);
      if (x.relative != x2.relative || x.value != x2.value) {
        Reflect.set(p.finalTarget, p.propertyName, x.clone());
        constants.edited = true;
      }
    } else if (Reflect.get(p.finalTarget, p.propertyName) != p.terminalSource) {
      Reflect.set(p.finalTarget, p.propertyName, p.terminalSource);
      constants.edited = true;
    }
  }
  ApplyAllProperties(target) {
    this.ApplyAllPropertiesEx(
      target,
      _GenericProperties.NoFilter,
      0
      /* GenericProperties.APPLYDIRECTION.SETTINGS_TO_TARGET */
    );
  }
  RefreshAllProperties(target) {
    this.ApplyAllPropertiesEx(
      target,
      _GenericProperties.NoFilter,
      1
      /* GenericProperties.APPLYDIRECTION.SETTINGS_FROM_TARGET */
    );
  }
  ApplyProperties(rootSource, rootTarget, fullpropname, sourceValue, path, direction) {
    if (sourceValue instanceof AlarmSection)
      return;
    let sourceproperties = _GenericProperties.getAllProperties(this);
    if ("CopyToTarget" in sourceproperties.byName[fullpropname].Attributes) {
      if (!sourceproperties.byName[fullpropname].Attributes["CopyToTarget"]) {
        return;
      }
    }
    if (!_GenericProperties.IsStructured(sourceValue)) {
      if (direction == 0) {
        _GenericProperties.copyProperty_STT(rootTarget, this, fullpropname, path);
      } else {
        _GenericProperties.copyProperty_SFT(rootTarget, this, fullpropname, path);
      }
    } else {
      let path2 = path.slice();
      path2.push("");
      let target = _GenericProperties.getObjectFromPath(rootTarget, path2);
      Reflect.set(target, "userData", sourceValue);
      let sourceproperties2 = _GenericProperties.getAllProperties(sourceValue);
      for (let subpropname in sourceproperties2.byName) {
        let shouldcopy = true;
        if ("CopyToTarget" in sourceproperties2.byName[subpropname].Attributes) {
          shouldcopy = sourceproperties2.byName[subpropname].Attributes["CopyToTarget"];
        }
        if (sourceproperties2.byName[subpropname].isWritable && shouldcopy) {
          path.push(subpropname);
          this.ApplyProperties(rootSource, rootTarget, fullpropname, Reflect.get(sourceValue, subpropname), path, direction);
          path.splice(path.length - 1, 1);
        }
      }
    }
  }
  // will return true  if property has a getter or a setter
  static isProperty(proto, propName) {
    let d = Reflect.getOwnPropertyDescriptor(proto, propName);
    let list = Object.getOwnPropertyNames(d);
    for (let i = 0; i < list.length; i++) {
      if (list[i] == "set")
        return true;
      if (list[i] == "get")
        return true;
    }
    return false;
  }
  // will return true if property has  an implemented  setter
  static isWritable(proto, propName) {
    let d = Reflect.getOwnPropertyDescriptor(proto, propName);
    let list = Object.getOwnPropertyNames(d);
    for (let i = 0; i < list.length; i++) {
      if (list[i] == "set") {
        if (typeof d.set !== "undefined")
          return true;
      }
    }
    return false;
  }
  static getAllProperties(o) {
    if (typeof o === "undefined")
      debugger;
    if (o.hasOwnProperty("PropertiesDescriptionCache")) {
      return o["PropertiesDescriptionCache"];
    }
    let proto = Object.getPrototypeOf(o);
    let res = new PropertiesList();
    let p = proto;
    let entries = [];
    let genealogy = [];
    while (p != null) {
      genealogy.push(p);
      p = Object.getPrototypeOf(p);
    }
    for (let j = genealogy.length - 1; j >= 0; j--) {
      let names = Object.getOwnPropertyNames(genealogy[j]);
      let index = 0;
      for (let i = 0; i < names.length; i++) {
        if (names[i] != "constructor" && !names[i].startsWith("__")) {
          entries.splice(index, 0, new PropDescription(names[i], genealogy[j]));
          index++;
          for (let k = entries.length - 1; k >= index; k--) {
            if (entries[k].name == names[i])
              entries.splice(k, 1);
          }
        }
      }
    }
    for (let i = 0; i < entries.length; i++) {
      if (!entries[i].name.startsWith("ATTR") && entries[i].name != "constructor" && !entries[i].name.startsWith("__")) {
        if (_GenericProperties.isProperty(entries[i].prop, entries[i].name)) {
          let d = new PropertyDescriptor(entries[i].name);
          res.byIndex.push(d);
          res.byName[d.name] = d;
          d.isWritable = _GenericProperties.isWritable(entries[i].prop, entries[i].name);
          d.isEnum = o[entries[i].name] instanceof YEnumItem;
          d.type = typeof o[entries[i].name];
          if (d.type == "object" && o[entries[i].name] != null) {
            d.type = o[entries[i].name].constructor.name;
          }
        }
      }
    }
    for (let i = 0; i < entries.length; i++) {
      if (entries[i].name.startsWith("ATTR_")) {
        let p2 = entries[i].name.indexOf("__");
        if (p2 < 5)
          debugger;
        let name = entries[i].name.substring(5, p2);
        let attr = entries[i].name.substring(p2 + 2);
        if (typeof res.byName[name] === "undefined")
          debugger;
        try {
          res.byName[name].Attributes[attr] = Reflect.get(o, entries[i].name);
        } catch (e) {
          debugger;
        }
      }
    }
    o["PropertiesDescriptionCache"] = res;
    return res;
  }
  ApplyAllPropertiesEx(target, filter, direction) {
    let properties = _GenericProperties.getAllProperties(this);
    for (let fullpropname in properties.byName) {
      if (properties.byName[fullpropname].isWritable) {
        let index = fullpropname.indexOf("_");
        if (index < 0)
          throw "invalid Property name";
        let propType = fullpropname.substring(0, index);
        let propname = fullpropname.substring(index + 1);
        let path = [];
        path.push(propname);
        if (target instanceof YWidget && propType == "Form") {
          this.ApplyProperties(this, target, fullpropname, Reflect.get(this, fullpropname), path, direction);
        }
        if (target instanceof YAngularGauge && propType == "AngularGauge") {
          this.ApplyProperties(this, target, fullpropname, Reflect.get(this, fullpropname), path, direction);
        }
        if (target instanceof YDigitalDisplay && propType == "display") {
          this.ApplyProperties(this, target, fullpropname, Reflect.get(this, fullpropname), path, direction);
        }
        if (target instanceof YSolidGauge && propType == "SolidGauge") {
          this.ApplyProperties(this, target, fullpropname, Reflect.get(this, fullpropname), path, direction);
        }
        if (target instanceof YGraph && propType == "Graph") {
          this.ApplyProperties(this, target, fullpropname, Reflect.get(this, fullpropname), path, direction);
        }
      }
    }
  }
};
GenericProperties.XmlFileVersion = -1;

// obj/full/properties.js
var GenericHints = class {
};
GenericHints.DevConfAffected = " Changing this value will affect the device configuration.";
GenericHints.CheckSensor = "If the sensor you want to use is connected, but not listed or listed as OFFLINE, check USB / Network configuration in the global configuration.";
GenericHints.AnnotationGraph = "Annotation text.  Use \\n for carriage returns. Some variables are available: $DAY$ $MONTH$ $YEAR$ for date, $HOUR$ $MINUTE$ $SECOND$ for time, $AVGVALUE1$ $MINVALUE1$ $MAXVALUE1$ $NAME1$ $UNIT1$  for first series data, $AVGVALUE2$ $MINVALUE2$ $MAXVALUE2$ $NAME2$ $UNIT2$  for second series data and so on";
GenericHints.Annotation = "Annotation text.  Use \\n for carriage returns. Some variables are available: $DAY$ $MONTH$ $YEAR$ for date, $HOUR$ $MINUTE$ $SECOND$ for time, $AVGVALUE$ $MINVALUE$ $MAXVALUE$ $NAME$ $UNIT$ for sensor related data.";
var sensorFreqTypeDescription = class {
  static get AllowedValues() {
    return this._AllowedValues;
  }
};
sensorFreqTypeDescription._AllowedValues = [
  "25/s",
  "10/s",
  "5/s",
  "4/s",
  "3/s",
  "2/s",
  "1/s",
  "60/m",
  "30/m",
  "12/m",
  "6/m",
  "4/m",
  "3/m",
  "2/m",
  "1/m",
  "30/h",
  "12/h",
  "6/h",
  "4/h",
  "3/h",
  "2/h",
  "1/h"
];
var yAxisDescription = class _yAxisDescription {
  static initialize() {
    let yaxiscount = 0;
    let obj = new GraphFormProperties(null, null);
    let names = Object.getOwnPropertyNames(obj);
    names.forEach((name) => {
      if (name.startsWith("_Graph_yAxes"))
        yaxiscount++;
    });
    for (let i = 0; i < yaxiscount; i++) {
      switch (i) {
        case 0:
          this._AllowedValues.push("1rst Y axis");
          break;
        case 1:
          this._AllowedValues.push("2nd Y axis");
          break;
        case 2:
          this._AllowedValues.push("3rd Y axis");
          break;
        default:
          this._AllowedValues.push((i + 1).toString() + "th Y axis");
          break;
      }
    }
    _yAxisDescription.initialized = true;
  }
  static get AllowedValues() {
    if (!_yAxisDescription.initialized)
      _yAxisDescription.initialize();
    return this._AllowedValues;
  }
};
yAxisDescription._AllowedValues = [];
var AlarmTestTypeDescription = class {
  static get AllowedValues() {
    return this._AllowedValues;
  }
};
AlarmTestTypeDescription._AllowedValues = ["Disabled", ">", ">=", "=", "<=", "<"];
var fontNameTypeDescription = class {
  static fontNameTypeDescription() {
  }
  static get AllowedValues() {
    return this._AllowedValues;
  }
};
fontNameTypeDescription._AllowedValues = [
  "Arial",
  "Brush Script MT",
  "Comic Sans MS",
  "Courier New",
  "Garamond",
  "Georgia",
  "Helvetica",
  "Impact",
  "Tahoma",
  "Times New Roman",
  "Trebuchet MS",
  "Verdana"
];
var sensorPrecisionTypeDescription = class {
  static get AllowedValues() {
    return this._AllowedValues;
  }
};
sensorPrecisionTypeDescription._AllowedValues = ["0", "0.1", "0.12", "0.123"];
var sensorDataTypeDescription = class {
  static get AllowedValues() {
    return this._AllowedValues;
  }
};
sensorDataTypeDescription._AllowedValues = ["Avg values", "Min values", "Max values"];
var GaugeFormProperties = class extends GenericProperties {
  constructor(initData, owner) {
    super(owner);
    this._DataSource_source = sensorsManager.getNullSensor();
    this._DataSource_precision = "0.1";
    this._DataSource_AlarmSection0 = new AlarmSection(0);
    this._DataSource_AlarmSection1 = new AlarmSection(1);
    this._SolidGauge_min = 0;
    this._SolidGauge_max = 100;
    this._SolidGauge_showMinMax = true;
    this._SolidGauge_color1 = YColor.LightGreen;
    this._SolidGauge_color2 = YColor.Red;
    this._SolidGauge_font = new FontDescription("Arial", 20, YColor.Black, false, true);
    this._SolidGauge_minMaxFont = new FontDescription("Arial", 10, YColor.Black, false, true);
    this._SolidGauge_displayMode = YSolidGauge.DisplayMode.DISPLAY90;
    this._SolidGauge_borderColor = YColor.Black;
    this._SolidGauge_borderThickness = 2;
    this._SolidGauge_backgroundColor1 = YColor.FromArgb(255, 240, 240, 240);
    this._SolidGauge_backgroundColor2 = YColor.FromArgb(255, 200, 200, 200);
    this._SolidGauge_thickness = 25;
    this._SolidGauge_maxSpeed = 1;
    this._annotationPanels0 = new AnnotationPanelDescription(GenericPanel.HorizontalAlignPos.CENTER, GenericPanel.VerticalAlignPos.BOTTOM, 0, false, "$NAME$", YColor.FromArgb(0, 127, 127, 127), YColor.FromArgb(0, 127, 127, 127), 10, YColor.FromArgb(255, 0, 0, 0));
    this._annotationPanels1 = new AnnotationPanelDescription(GenericPanel.HorizontalAlignPos.CENTER, GenericPanel.VerticalAlignPos.BOTTOM, 0, false, "$NAME$", YColor.FromArgb(0, 127, 127, 127), YColor.FromArgb(0, 127, 127, 127), 10, YColor.FromArgb(255, 0, 0, 0));
    this.initFromXmlData(initData);
    this.PropagateDataSourceChange();
  }
  PropagateDataSourceChange() {
    this.ownerForm.SourceChanged(this._DataSource_source, 0);
    let props = GenericProperties.getAllProperties(this).byName;
    let name;
    for (name in props) {
      if (name.startsWith("DataSource_AlarmSection")) {
        this[name].setDataSource(this._DataSource_source);
      }
    }
  }
  get ATTR_DataSource_source__DisplayName() {
    return "Sensor";
  }
  get ATTR_DataSource_source__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_source__ParamCategorySummaryAttribute() {
    return "sensorDescription";
  }
  get ATTR_DataSource_source__PreExpandedCategoryAttribute() {
    return true;
  }
  get ATTR_DataSource_source__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_DataSource_source__DescriptionAttribute() {
    return "Yoctopuce sensor feeding the gauge. ";
  }
  get DataSource_source() {
    return this._DataSource_source;
  }
  set DataSource_source(value) {
    let prev = this._DataSource_source;
    this._DataSource_source = value;
    this.PropagateDataSourceChange();
    if (this._DataSource_source != prev)
      constants.edited = true;
  }
  get sensorDescription() {
    return this._DataSource_source instanceof NullYSensor ? "none" : this._DataSource_source.get_friendlyName();
  }
  get isSensorReadOnly() {
    return this._DataSource_source.isReadOnly;
  }
  get ATTR_DataSource_freq__DisplayName() {
    return "Sensor freq";
  }
  get ATTR_DataSource_freq__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_freq__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_DataSource_freq__IsReadonlyCallAttribute() {
    return this.isSensorReadOnly;
  }
  get ATTR_DataSource_freq__AllowedValues() {
    return sensorFreqTypeDescription.AllowedValues;
  }
  get ATTR_DataSource_freq__DescriptionAttribute() {
    return "Sensor data acquisition frequency." + GenericHints.DevConfAffected;
  }
  get DataSource_freq() {
    return this._DataSource_source.get_frequency();
  }
  set DataSource_freq(value) {
    this._DataSource_source.set_frequency(value);
  }
  get ATTR_DataSource_precision__DisplayName() {
    return "Precision";
  }
  get ATTR_DataSource_precision__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_precision__DescriptionAttribute() {
    return "How many digits shown after the decimal point";
  }
  get ATTR_DataSource_precision__AllowedValues() {
    return sensorPrecisionTypeDescription.AllowedValues;
  }
  get DataSource_precision() {
    return this._DataSource_precision;
  }
  set DataSource_precision(value) {
    this._DataSource_precision = value;
  }
  get ATTR_DataSource_AlarmSection0__DisplayName() {
    return "Sensor value alarm 1";
  }
  get ATTR_DataSource_AlarmSection0__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection0__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection0__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_AlarmSection0__DescriptionAttribute() {
    return "Alarm 1 for this data source, expand for more.";
  }
  get DataSource_AlarmSection0() {
    return this._DataSource_AlarmSection0;
  }
  set DataSource_AlarmSection0(value) {
    this._DataSource_AlarmSection0 = value;
  }
  get ATTR_DataSource_AlarmSection1__DisplayName() {
    return "Sensor value alarm 2";
  }
  get ATTR_DataSource_AlarmSection1__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection1__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection1__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_AlarmSection1__DescriptionAttribute() {
    return "Alarm 2 for this data source, expand for more.";
  }
  get DataSource_AlarmSection1() {
    return this._DataSource_AlarmSection1;
  }
  set DataSource_AlarmSection1(value) {
    this._DataSource_AlarmSection1 = value;
  }
  get ATTR_SolidGauge_min__DisplayName() {
    return "Minimum value";
  }
  get ATTR_SolidGauge_min__CategoryAttribute() {
    return "Values range";
  }
  get ATTR_SolidGauge_min__DescriptionAttribute() {
    return "Minimum value displayable by the gauge.";
  }
  get SolidGauge_min() {
    return this._SolidGauge_min;
  }
  set SolidGauge_min(value) {
    this._SolidGauge_min = value;
  }
  get ATTR_SolidGauge_max__DisplayName() {
    return "Maximum value";
  }
  get ATTR_SolidGauge_max__CategoryAttribute() {
    return "Values range";
  }
  get ATTR_SolidGauge_max__DescriptionAttribute() {
    return "Maximum value displayable by the gauge.";
  }
  get SolidGauge_max() {
    return this._SolidGauge_max;
  }
  set SolidGauge_max(value) {
    this._SolidGauge_max = value;
  }
  get ATTR_SolidGauge_showMinMax__DisplayName() {
    return "show  min/max";
  }
  get ATTR_SolidGauge_showMinMax__CategoryAttribute() {
    return "Values range";
  }
  get ATTR_SolidGauge_showMinMax__DescriptionAttribute() {
    return "Show the min / max values.";
  }
  get SolidGauge_showMinMax() {
    return this._SolidGauge_showMinMax;
  }
  set SolidGauge_showMinMax(value) {
    this._SolidGauge_showMinMax = value;
  }
  get ATTR_SolidGauge_color1__DisplayName() {
    return "Min Color";
  }
  get ATTR_SolidGauge_color1__CategoryAttribute() {
    return "Values range";
  }
  get ATTR_SolidGauge_color1__DescriptionAttribute() {
    return "Color for minimum value.";
  }
  get SolidGauge_color1() {
    return this._SolidGauge_color1;
  }
  set SolidGauge_color1(value) {
    this._SolidGauge_color1 = value;
  }
  get ATTR_SolidGauge_color2__DisplayName() {
    return "Max Color";
  }
  get ATTR_SolidGauge_color2__CategoryAttribute() {
    return "Values range";
  }
  get ATTR_SolidGauge_color2__DescriptionAttribute() {
    return "Color for maximum value.";
  }
  get SolidGauge_color2() {
    return this._SolidGauge_color2;
  }
  set SolidGauge_color2(value) {
    this._SolidGauge_color2 = value;
  }
  get ATTR_SolidGauge_font__DisplayName() {
    return "Unit  Font";
  }
  get ATTR_SolidGauge_font__CategoryAttribute() {
    return "Fonts";
  }
  get ATTR_SolidGauge_font__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_SolidGauge_font__DescriptionAttribute() {
    return "Font for displaying the value/status indicator";
  }
  get SolidGauge_font() {
    return this._SolidGauge_font;
  }
  set SolidGauge_font(value) {
    this._SolidGauge_font = value;
  }
  get ATTR_SolidGauge_minMaxFont__DisplayName() {
    return "Min Max  Font";
  }
  get ATTR_SolidGauge_minMaxFont__CategoryAttribute() {
    return "Fonts";
  }
  get ATTR_SolidGauge_minMaxFont__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_SolidGauge_minMaxFont__DescriptionAttribute() {
    return "Font for displaying min/max values";
  }
  get SolidGauge_minMaxFont() {
    return this._SolidGauge_minMaxFont;
  }
  set SolidGauge_minMaxFont(value) {
    this._SolidGauge_minMaxFont = value;
  }
  get ATTR_SolidGauge_displayMode__DisplayName() {
    return "Display mode";
  }
  get ATTR_SolidGauge_displayMode__CategoryAttribute() {
    return "Dial";
  }
  get ATTR_SolidGauge_displayMode__DescriptionAttribute() {
    return "Dial general shape";
  }
  get SolidGauge_displayMode() {
    return this._SolidGauge_displayMode;
  }
  set SolidGauge_displayMode(value) {
    this._SolidGauge_displayMode = value;
  }
  get ATTR_SolidGauge_borderColor__DisplayName() {
    return "Border color";
  }
  get ATTR_SolidGauge_borderColor__CategoryAttribute() {
    return "Dial";
  }
  get ATTR_SolidGauge_borderColor__DescriptionAttribute() {
    return "Dial border color.";
  }
  get SolidGauge_borderColor() {
    return this._SolidGauge_borderColor;
  }
  set SolidGauge_borderColor(value) {
    this._SolidGauge_borderColor = value;
  }
  get ATTR_SolidGauge_borderThickness__DisplayName() {
    return "Border thickness ";
  }
  get ATTR_SolidGauge_borderThickness__CategoryAttribute() {
    return "Dial";
  }
  get ATTR_SolidGauge_borderThickness__DescriptionAttribute() {
    return "Thickness of the dial border";
  }
  get SolidGauge_borderThickness() {
    return this._SolidGauge_borderThickness;
  }
  set SolidGauge_borderThickness(value) {
    this._SolidGauge_borderThickness = value;
  }
  get ATTR_SolidGauge_backgroundColor1__DisplayName() {
    return "Background color 1";
  }
  get ATTR_SolidGauge_backgroundColor1__CategoryAttribute() {
    return "Dial";
  }
  get ATTR_SolidGauge_backgroundColor1__DescriptionAttribute() {
    return "Dial background gradient color 1.";
  }
  get SolidGauge_backgroundColor1() {
    return this._SolidGauge_backgroundColor1;
  }
  set SolidGauge_backgroundColor1(value) {
    this._SolidGauge_backgroundColor1 = value;
  }
  get ATTR_SolidGauge_backgroundColor2__DisplayName() {
    return "Background color 2";
  }
  get ATTR_SolidGauge_backgroundColor2__CategoryAttribute() {
    return "Dial";
  }
  get ATTR_SolidGauge_backgroundColor2__DescriptionAttribute() {
    return "Dial background gradient color 2.";
  }
  get SolidGauge_backgroundColor2() {
    return this._SolidGauge_backgroundColor2;
  }
  set SolidGauge_backgroundColor2(value) {
    this._SolidGauge_backgroundColor2 = value;
  }
  get ATTR_SolidGauge_thickness__DisplayName() {
    return "Dial thickness (%) ";
  }
  get ATTR_SolidGauge_thickness__CategoryAttribute() {
    return "Dial";
  }
  get ATTR_SolidGauge_thickness__DescriptionAttribute() {
    return "Thickness of the dial, in percentage relative to radius";
  }
  get SolidGauge_thickness() {
    return this._SolidGauge_thickness;
  }
  set SolidGauge_thickness(value) {
    this._SolidGauge_thickness = value;
  }
  get ATTR_SolidGauge_maxSpeed__DisplayName() {
    return "Max speed (%) ";
  }
  get ATTR_SolidGauge_maxSpeed__CategoryAttribute() {
    return "Dial";
  }
  get ATTR_SolidGauge_maxSpeed__DescriptionAttribute() {
    return 'Maximum speed of the dial in percentage relative to Max-Min. This is meant to limit "teleporting" effects.';
  }
  get SolidGauge_maxSpeed() {
    return this._SolidGauge_maxSpeed;
  }
  set SolidGauge_maxSpeed(value) {
    this._SolidGauge_maxSpeed = value;
  }
  IsDataSourceAssigned() {
    return !(this._DataSource_source instanceof NullYSensor);
  }
  get ATTR_SolidGauge_annotationPanels0__DisplayName() {
    return "Annotation 1";
  }
  get ATTR_SolidGauge_annotationPanels0__CategoryAttribute() {
    return "Annotations";
  }
  get ATTR_SolidGauge_annotationPanels0__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_SolidGauge_annotationPanels0__DescriptionAttribute() {
    return "Customizable text panels";
  }
  get SolidGauge_annotationPanels0() {
    return this._annotationPanels0;
  }
  set SolidGauge_annotationPanels0(value) {
    this._annotationPanels0 = value;
  }
  get ATTR_SolidGauge_annotationPanels1__DisplayName() {
    return "Annotation 2";
  }
  get ATTR_SolidGauge_annotationPanels1__CategoryAttribute() {
    return "Annotations";
  }
  get ATTR_SolidGauge_annotationPanels1__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_SolidGauge_annotationPanels1__DescriptionAttribute() {
    return "Customizable text panels";
  }
  get SolidGauge_annotationPanels1() {
    return this._annotationPanels1;
  }
  set SolidGauge_annotationPanels1(value) {
    this._annotationPanels1 = value;
  }
};
var AngularGaugeFormProperties = class extends GenericProperties {
  constructor(initData, owner) {
    super(owner);
    this._DataSource_source = sensorsManager.getNullSensor();
    this._DataSource_AlarmSection0 = new AlarmSection(0);
    this._DataSource_AlarmSection1 = new AlarmSection(1);
    this._AngularGauge_min = 0;
    this._AngularGauge_max = 100;
    this._AngularGauge_unitFactor = 1;
    this._AngularGauge_graduation = 10;
    this._AngularGauge_graduationSize = 10;
    this._AngularGauge_graduationOuterRadiusSize = 98;
    this._AngularGauge_graduationThickness = 2;
    this._AngularGauge_graduationColor = YColor.Black;
    this._AngularGauge_graduationFont = new FontDescription("Arial", 20, YColor.Black, false, true);
    this._AngularGauge_subgraduationCount = 5;
    this._AngularGauge_subgraduationSize = 5;
    this._AngularGauge_subgraduationThickness = 1;
    this._AngularGauge_subgraduationColor = YColor.Black;
    this._AngularGauge_needleColor = YColor.Red;
    this._AngularGauge_needleContourColor = YColor.DarkRed;
    this._AngularGauge_needleContourThickness = 1;
    this._AngularGauge_needleLength1 = 90;
    this._AngularGauge_needleLength2 = 15;
    this._AngularGauge_needleWidth = 5;
    this._AngularGauge_needleMaxSpeed = 0.5;
    this._AngularGauge_unitFont = new FontDescription("Arial", 24, YColor.DarkGray, false, true);
    this._AngularGauge_statusFont = new FontDescription("Arial", 24, YColor.DarkGray, false, true);
    this._AngularGauge_borderColor = YColor.Black;
    this._AngularGauge_borderThickness = 5;
    this._AngularGauge_backgroundColor1 = YColor.FromArgb(255, 240, 240, 240);
    this._AngularGauge_backgroundColor2 = YColor.FromArgb(255, 200, 200, 200);
    this._AngularGauge_zones0 = new AngularZoneDescription(0, 50, YColor.LightGreen);
    this._AngularGauge_zones1 = new AngularZoneDescription(50, 80, YColor.Yellow);
    this._AngularGauge_zones2 = new AngularZoneDescription(80, 100, YColor.Red);
    this._annotationPanels0 = new AnnotationPanelDescription(GenericPanel.HorizontalAlignPos.CENTER, GenericPanel.VerticalAlignPos.CENTER, 0, false, "$NAME$", YColor.FromArgb(0, 127, 127, 127), YColor.FromArgb(0, 127, 127, 127), 10, YColor.FromArgb(255, 0, 0, 0));
    this._annotationPanels1 = new AnnotationPanelDescription(GenericPanel.HorizontalAlignPos.CENTER, GenericPanel.VerticalAlignPos.BOTTOM, 0, false, "$NAME$", YColor.FromArgb(0, 127, 127, 127), YColor.FromArgb(0, 127, 127, 127), 10, YColor.FromArgb(255, 0, 0, 0));
    this.initFromXmlData(initData);
    this.PropagateDataSourceChange();
  }
  PropagateDataSourceChange() {
    this.ownerForm.SourceChanged(this._DataSource_source, 0);
    let props = GenericProperties.getAllProperties(this).byName;
    let name;
    for (name in props) {
      if (name.startsWith("DataSource_AlarmSection")) {
        this[name].setDataSource(this._DataSource_source);
      }
    }
  }
  IsDataSourceAssigned() {
    return !(this._DataSource_source instanceof NullYSensor);
  }
  get ATTR_DataSource_source__DisplayName() {
    return "Sensor";
  }
  get ATTR_DataSource_source__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_source__ParamCategorySummaryAttribute() {
    return "sensorDescription";
  }
  get ATTR_DataSource_source__PreExpandedCategoryAttribute() {
    return true;
  }
  get ATTR_DataSource_source__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_DataSource_source__DescriptionAttribute() {
    return "Yoctopuce sensor feeding the gauge. " + GenericHints.CheckSensor;
  }
  get DataSource_source() {
    return this._DataSource_source;
  }
  set DataSource_source(value) {
    let prev = this._DataSource_source;
    this._DataSource_source = value;
    this.PropagateDataSourceChange();
    if (this._DataSource_source != prev)
      constants.edited = true;
  }
  get sensorDescription() {
    return this._DataSource_source instanceof NullYSensor ? "none" : this._DataSource_source.get_friendlyName();
  }
  get isSensorReadOnly() {
    return this._DataSource_source.isReadOnly;
  }
  get ATTR_DataSource_freq__DisplayName() {
    return "Sensor freq";
  }
  get ATTR_DataSource_freq__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_freq__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_DataSource_freq__IsReadonlyCallAttribute() {
    return "isSensorReadOnly";
  }
  get ATTR_DataSource_freq__DescriptionAttribute() {
    return "Sensor data acquisition frequency." + GenericHints.DevConfAffected;
  }
  get ATTR_DataSource_freq__AllowedValues() {
    return sensorFreqTypeDescription.AllowedValues;
  }
  get DataSource_freq() {
    return this._DataSource_source.get_frequency();
  }
  set DataSource_freq(value) {
    this._DataSource_source.set_frequency(value);
  }
  get ATTR_DataSource_AlarmSection0__DisplayName() {
    return "Sensor value alarm 1";
  }
  get ATTR_DataSource_AlarmSection0__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection0__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection0__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_AlarmSection0__DescriptionAttribute() {
    return "Alarm 1 for this data source, expand for more.";
  }
  get DataSource_AlarmSection0() {
    return this._DataSource_AlarmSection0;
  }
  set DataSource_AlarmSection0(value) {
    this._DataSource_AlarmSection0 = value;
  }
  get ATTR_DataSource_AlarmSection1__DisplayName() {
    return "Sensor value alarm 2";
  }
  get ATTR_DataSource_AlarmSection1__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection1__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection1__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_AlarmSection1__DescriptionAttribute() {
    return "Alarm 2 for this data source, expand for more.";
  }
  get DataSource_AlarmSection1() {
    return this._DataSource_AlarmSection1;
  }
  set DataSource_AlarmSection1(value) {
    this._DataSource_AlarmSection1 = value;
  }
  get ATTR_AngularGauge_min__DisplayName() {
    return "Minimum value";
  }
  get ATTR_AngularGauge_min__CategoryAttribute() {
    return "Gauge gradations";
  }
  get ATTR_AngularGauge_min__DescriptionAttribute() {
    return "Minimum value displayable by the gauge.";
  }
  get AngularGauge_min() {
    return this._AngularGauge_min;
  }
  set AngularGauge_min(value) {
    this._AngularGauge_min = value;
  }
  get ATTR_AngularGauge_max__DisplayName() {
    return "Maximum value";
  }
  get ATTR_AngularGauge_max__CategoryAttribute() {
    return "Gauge gradations";
  }
  get ATTR_AngularGauge_max__DescriptionAttribute() {
    return "Maximum value displayable by the gauge.";
  }
  get AngularGauge_max() {
    return this._AngularGauge_max;
  }
  set AngularGauge_max(value) {
    this._AngularGauge_max = value;
  }
  get ATTR_AngularGauge_unitFactor__DisplayName() {
    return "Unit factor";
  }
  get ATTR_AngularGauge_unitFactor__CategoryAttribute() {
    return "Gauge gradations";
  }
  get ATTR_AngularGauge_unitFactor__DescriptionAttribute() {
    return "Data  will be divided by this value before being displayed, this allows simpler gradation marks.";
  }
  get AngularGauge_unitFactor() {
    return this._AngularGauge_unitFactor;
  }
  set AngularGauge_unitFactor(value) {
    this._AngularGauge_unitFactor = value;
  }
  get ATTR_AngularGauge_graduation__DisplayName() {
    return "Main gradation steps";
  }
  get ATTR_AngularGauge_graduation__CategoryAttribute() {
    return "Gauge gradations";
  }
  get ATTR_AngularGauge_graduation__DescriptionAttribute() {
    return "Difference between two consecutive main gradation marks";
  }
  get AngularGauge_graduation() {
    return this._AngularGauge_graduation;
  }
  set AngularGauge_graduation(value) {
    this._AngularGauge_graduation = value;
  }
  get ATTR_AngularGauge_graduationSize__DisplayName() {
    return "Main gradation size (%)";
  }
  get ATTR_AngularGauge_graduationSize__CategoryAttribute() {
    return "Gauge gradations";
  }
  get ATTR_AngularGauge_graduationSize__DescriptionAttribute() {
    return "Main gradation marks size in percent, relative to dial radius";
  }
  get AngularGauge_graduationSize() {
    return this._AngularGauge_graduationSize;
  }
  set AngularGauge_graduationSize(value) {
    this._AngularGauge_graduationSize = value;
  }
  get ATTR_AngularGauge_graduationOuterRadiusSize__DisplayName() {
    return "Main gradation radius (%)";
  }
  get ATTR_AngularGauge_graduationOuterRadiusSize__CategoryAttribute() {
    return "Gauge gradations";
  }
  get ATTR_AngularGauge_graduationOuterRadiusSize__DescriptionAttribute() {
    return "Main gradation marks outer radius in percent, relative to dial radius";
  }
  get AngularGauge_graduationOuterRadiusSize() {
    return this._AngularGauge_graduationOuterRadiusSize;
  }
  set AngularGauge_graduationOuterRadiusSize(value) {
    this._AngularGauge_graduationOuterRadiusSize = value;
  }
  get ATTR_AngularGauge_graduationThickness__DisplayName() {
    return "Main gradation thickness";
  }
  get ATTR_AngularGauge_graduationThickness__CategoryAttribute() {
    return "Gauge gradations";
  }
  get ATTR_AngularGauge_graduationThickness__DescriptionAttribute() {
    return "Main gradation marks thickness";
  }
  get AngularGauge_graduationThickness() {
    return this._AngularGauge_graduationThickness;
  }
  set AngularGauge_graduationThickness(value) {
    this._AngularGauge_graduationThickness = value;
  }
  get ATTR_AngularGauge_graduationColor__DisplayName() {
    return "Main gradation color";
  }
  get ATTR_AngularGauge_graduationColor__CategoryAttribute() {
    return "Gauge gradations";
  }
  get ATTR_AngularGauge_graduationColor__DescriptionAttribute() {
    return "Main gradation marks color.";
  }
  get AngularGauge_graduationColor() {
    return this._AngularGauge_graduationColor;
  }
  set AngularGauge_graduationColor(value) {
    this._AngularGauge_graduationColor = value;
  }
  get ATTR_AngularGauge_graduationFont__DisplayName() {
    return "Main gradation font";
  }
  get ATTR_AngularGauge_graduationFont__CategoryAttribute() {
    return "Gauge gradations";
  }
  get ATTR_AngularGauge_graduationFont__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_AngularGauge_graduationFont__DescriptionAttribute() {
    return "Font used for gradation labels";
  }
  get AngularGauge_graduationFont() {
    return this._AngularGauge_graduationFont;
  }
  set AngularGauge_graduationFont(value) {
    this._AngularGauge_graduationFont = value;
  }
  get ATTR_AngularGauge_subgraduationCount__DisplayName() {
    return "Sub-gradation count";
  }
  get ATTR_AngularGauge_subgraduationCount__CategoryAttribute() {
    return "Gauge gradations";
  }
  get ATTR_AngularGauge_subgraduationCount__DescriptionAttribute() {
    return "How many sub-gradation (+1) marks between two consecutive main graduation marks";
  }
  get AngularGauge_subgraduationCount() {
    return this._AngularGauge_subgraduationCount;
  }
  set AngularGauge_subgraduationCount(value) {
    this._AngularGauge_subgraduationCount = value;
  }
  get ATTR_AngularGauge_subgraduationSize__DisplayName() {
    return "Sub-gradation size (%)";
  }
  get ATTR_AngularGauge_subgraduationSize__CategoryAttribute() {
    return "Gauge gradations";
  }
  get ATTR_AngularGauge_subgraduationSize__DescriptionAttribute() {
    return "Sub-gradation marks size in percent, relative to dial radius";
  }
  get AngularGauge_subgraduationSize() {
    return this._AngularGauge_subgraduationSize;
  }
  set AngularGauge_subgraduationSize(value) {
    this._AngularGauge_subgraduationSize = value;
  }
  get ATTR_AngularGauge_subgraduationThickness__DisplayName() {
    return "Sub-gradation thickness";
  }
  get ATTR_AngularGauge_subgraduationThickness__CategoryAttribute() {
    return "Gauge gradations";
  }
  get ATTR_AngularGauge_subgraduationThickness__DescriptionAttribute() {
    return "Sub-gradation marks thickness";
  }
  get AngularGauge_subgraduationThickness() {
    return this._AngularGauge_subgraduationThickness;
  }
  set AngularGauge_subgraduationThickness(value) {
    this._AngularGauge_subgraduationThickness = value;
  }
  get ATTR_AngularGauge_subgraduationColor__DisplayName() {
    return "Sub-gradation color";
  }
  get ATTR_AngularGauge_subgraduationColor__CategoryAttribute() {
    return "Gauge gradations";
  }
  get ATTR_AngularGauge_subgraduationColor__DescriptionAttribute() {
    return "Sub-gradation marks color.";
  }
  get AngularGauge_subgraduationColor() {
    return this._AngularGauge_subgraduationColor;
  }
  set AngularGauge_subgraduationColor(value) {
    this._AngularGauge_subgraduationColor = value;
  }
  get ATTR_AngularGauge_needleColor__DisplayName() {
    return "Needle color";
  }
  get ATTR_AngularGauge_needleColor__CategoryAttribute() {
    return "Needle";
  }
  get ATTR_AngularGauge_needleColor__DescriptionAttribute() {
    return "Needle filling color.";
  }
  get AngularGauge_needleColor() {
    return this._AngularGauge_needleColor;
  }
  set AngularGauge_needleColor(value) {
    this._AngularGauge_needleColor = value;
  }
  get ATTR_AngularGauge_needleContourColor__DisplayName() {
    return "Needle contour color";
  }
  get ATTR_AngularGauge_needleContourColor__CategoryAttribute() {
    return "Needle";
  }
  get ATTR_AngularGauge_needleContourColor__DescriptionAttribute() {
    return "Needle contour color.";
  }
  get AngularGauge_needleContourColor() {
    return this._AngularGauge_needleContourColor;
  }
  set AngularGauge_needleContourColor(value) {
    this._AngularGauge_needleContourColor = value;
  }
  get ATTR_AngularGauge_needleContourThickness__DisplayName() {
    return "Needle contour thickness";
  }
  get ATTR_AngularGauge_needleContourThickness__CategoryAttribute() {
    return "Needle";
  }
  get ATTR_AngularGauge_needleContourThickness__DescriptionAttribute() {
    return "Thickness of the needle contour";
  }
  get AngularGauge_needleContourThickness() {
    return this._AngularGauge_needleContourThickness;
  }
  set AngularGauge_needleContourThickness(value) {
    this._AngularGauge_needleContourThickness = value;
  }
  get ATTR_AngularGauge_needleLength1__DisplayName() {
    return "Needle main size (%)";
  }
  get ATTR_AngularGauge_needleLength1__CategoryAttribute() {
    return "Needle";
  }
  get ATTR_AngularGauge_needleLength1__DescriptionAttribute() {
    return "Length of the needle part pointing to gradations, in % relative to radius";
  }
  get AngularGauge_needleLength1() {
    return this._AngularGauge_needleLength1;
  }
  set AngularGauge_needleLength1(value) {
    this._AngularGauge_needleLength1 = value;
  }
  get ATTR_AngularGauge_needleLength2__DisplayName() {
    return "Needle foot size (%)";
  }
  get ATTR_AngularGauge_needleLength2__CategoryAttribute() {
    return "Needle";
  }
  get ATTR_AngularGauge_needleLength2__DescriptionAttribute() {
    return "Length of the needle part not pointing to gradations, in % relative to radius";
  }
  get AngularGauge_needleLength2() {
    return this._AngularGauge_needleLength2;
  }
  set AngularGauge_needleLength2(value) {
    this._AngularGauge_needleLength2 = value;
  }
  get ATTR_AngularGauge_needleWidth__DisplayName() {
    return "Needle width (%)";
  }
  get ATTR_AngularGauge_needleWidth__CategoryAttribute() {
    return "Needle";
  }
  get ATTR_AngularGauge_needleWidth__DescriptionAttribute() {
    return "Width of the needle, in % relative to radius";
  }
  get AngularGauge_needleWidth() {
    return this._AngularGauge_needleWidth;
  }
  set AngularGauge_needleWidth(value) {
    this._AngularGauge_needleWidth = value;
  }
  get ATTR_AngularGauge_needleMaxSpeed__DisplayName() {
    return "Needle max speed (%)";
  }
  get ATTR_AngularGauge_needleMaxSpeed__CategoryAttribute() {
    return "Needle";
  }
  get ATTR_AngularGauge_needleMaxSpeed__DescriptionAttribute() {
    return 'Needle Maximum speed, in % relative to (max-min). This is meant to limit "teleporting" effects.';
  }
  get AngularGauge_needleMaxSpeed() {
    return this._AngularGauge_needleMaxSpeed;
  }
  set AngularGauge_needleMaxSpeed(value) {
    this._AngularGauge_needleMaxSpeed = value;
  }
  get ATTR_AngularGauge_unitFont__DisplayName() {
    return "Unit Line Font";
  }
  get ATTR_AngularGauge_unitFont__CategoryAttribute() {
    return "Text lines";
  }
  get ATTR_AngularGauge_unitFont__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_AngularGauge_unitFont__DescriptionAttribute() {
    return "Font used in the text line describing unit";
  }
  get AngularGauge_unitFont() {
    return this._AngularGauge_unitFont;
  }
  set AngularGauge_unitFont(value) {
    this._AngularGauge_unitFont = value;
  }
  get ATTR_AngularGauge_statusFont__DisplayName() {
    return "Status Line Font";
  }
  get ATTR_AngularGauge_statusFont__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_AngularGauge_statusFont__CategoryAttribute() {
    return "Text lines";
  }
  get ATTR_AngularGauge_statusFont__DescriptionAttribute() {
    return "Font used in the text line gauge status";
  }
  get AngularGauge_statusFont() {
    return this._AngularGauge_statusFont;
  }
  set AngularGauge_statusFont(value) {
    this._AngularGauge_statusFont = value;
  }
  get ATTR_AngularGauge_borderColor__DisplayName() {
    return "Border color";
  }
  get ATTR_AngularGauge_borderColor__CategoryAttribute() {
    return "Dial";
  }
  get ATTR_AngularGauge_borderColor__DescriptionAttribute() {
    return "Dial border color.";
  }
  get AngularGauge_borderColor() {
    return this._AngularGauge_borderColor;
  }
  set AngularGauge_borderColor(value) {
    this._AngularGauge_borderColor = value;
  }
  get ATTR_AngularGauge_borderThickness__DisplayName() {
    return "Border thickness ";
  }
  get ATTR_AngularGauge_borderThickness__CategoryAttribute() {
    return "Dial";
  }
  get ATTR_AngularGauge_borderThickness__DescriptionAttribute() {
    return "Thickness of the dial border";
  }
  get AngularGauge_borderThickness() {
    return this._AngularGauge_borderThickness;
  }
  set AngularGauge_borderThickness(value) {
    this._AngularGauge_borderThickness = value;
  }
  get ATTR_AngularGauge_backgroundColor1__DisplayName() {
    return "Background color 1";
  }
  get ATTR_AngularGauge_backgroundColor1__CategoryAttribute() {
    return "Dial";
  }
  get ATTR_AngularGauge_backgroundColor1__DescriptionAttribute() {
    return "Dial background gradient color 1.";
  }
  get AngularGauge_backgroundColor1() {
    return this._AngularGauge_backgroundColor1;
  }
  set AngularGauge_backgroundColor1(value) {
    this._AngularGauge_backgroundColor1 = value;
  }
  get ATTR_AngularGauge_backgroundColor2__DisplayName() {
    return "Background color 2";
  }
  get ATTR_AngularGauge_backgroundColor2__CategoryAttribute() {
    return "Dial";
  }
  get ATTR_AngularGauge_backgroundColor2__DescriptionAttribute() {
    return "Dial background gradient color 2.";
  }
  get AngularGauge_backgroundColor2() {
    return this._AngularGauge_backgroundColor2;
  }
  set AngularGauge_backgroundColor2(value) {
    this._AngularGauge_backgroundColor2 = value;
  }
  get ATTR_AngularGauge_zones0__DisplayName() {
    return "Zone 1";
  }
  get ATTR_AngularGauge_zones0__CategoryAttribute() {
    return "Zones";
  }
  get ATTR_AngularGauge_zones0__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_AngularGauge_zones0__DescriptionAttribute() {
    return "Zone 1 parameters";
  }
  get AngularGauge_zones0() {
    return this._AngularGauge_zones0;
  }
  set AngularGauge_zones0(value) {
    this._AngularGauge_zones0 = value;
  }
  get ATTR_AngularGauge_zones1__DisplayName() {
    return "Zone 2";
  }
  get ATTR_AngularGauge_zones1__CategoryAttribute() {
    return "Zones";
  }
  get ATTR_AngularGauge_zones1__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_AngularGauge_zones1__DescriptionAttribute() {
    return "Zone 2 parameters";
  }
  get AngularGauge_zones1() {
    return this._AngularGauge_zones1;
  }
  set AngularGauge_zones1(value) {
    this._AngularGauge_zones1 = value;
  }
  get ATTR_AngularGauge_zones2__DisplayName() {
    return "Zone 2";
  }
  get ATTR_AngularGauge_zones2__CategoryAttribute() {
    return "Zones";
  }
  get ATTR_AngularGauge_zones2__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_AngularGauge_zones2__DescriptionAttribute() {
    return "Zone 2 parameters";
  }
  get AngularGauge_zones2() {
    return this._AngularGauge_zones2;
  }
  set AngularGauge_zones2(value) {
    this._AngularGauge_zones2 = value;
  }
  get ATTR_AngularGauge_annotationPanels0__DisplayName() {
    return "Annotation 1";
  }
  get ATTR_AngularGauge_annotationPanels0__CategoryAttribute() {
    return "Annotations";
  }
  get ATTR_AngularGauge_annotationPanels0__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_AngularGauge_annotationPanels0__DescriptionAttribute() {
    return "Customizable text panels";
  }
  get AngularGauge_annotationPanels0() {
    return this._annotationPanels0;
  }
  set AngularGauge_annotationPanels0(value) {
    this._annotationPanels0 = value;
  }
  get ATTR_AngularGauge_annotationPanels1__DisplayName() {
    return "Annotation 2";
  }
  get ATTR_AngularGauge_annotationPanels1__CategoryAttribute() {
    return "Annotations";
  }
  get ATTR_AngularGauge_annotationPanels1__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_AngularGauge_annotationPanels1__DescriptionAttribute() {
    return "Customizable text panels";
  }
  get AngularGauge_annotationPanels1() {
    return this._annotationPanels1;
  }
  set AngularGauge_annotationPanels1(value) {
    this._annotationPanels1 = value;
  }
};
var ZoneDescription = class {
  constructor(min, max, color) {
    this._visible = false;
    this._min = min;
    this._max = max;
    this._color = color;
  }
  get summary() {
    return this._visible ? this._min.toString() + ".." + this._max.toString() : "Disabled";
  }
  get ATTR_visible__DisplayName() {
    return "Visible";
  }
  get ATTR_visible__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_visible__DescriptionAttribute() {
    return "Zone visibility.";
  }
  get visible() {
    return this._visible;
  }
  set visible(value) {
    this._visible = value;
  }
  get ATTR_min__DisplayName() {
    return "Minimum value";
  }
  get ATTR_min__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_min__DescriptionAttribute() {
    return "Zone minimum value";
  }
  get min() {
    return this._min;
  }
  set min(value) {
    this._min = value;
  }
  get ATTR_max__DisplayName() {
    return "Maximum value";
  }
  get ATTR_max__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_max__DescriptionAttribute() {
    return "Zone maximum value";
  }
  get max() {
    return this._max;
  }
  set max(value) {
    this._max = value;
  }
  get ATTR_color__DisplayName() {
    return "Color";
  }
  get ATTR_color__DescriptionAttribute() {
    return "Zone color";
  }
  get color() {
    return this._color;
  }
  set color(value) {
    this._color = value;
  }
};
var AngularZoneDescription = class {
  constructor(min, max, color) {
    this._width = 5;
    this._outerRadius = 98;
    this._visible = false;
    this._min = min;
    this._max = max;
    this._color = color;
  }
  get summary() {
    return this._visible ? this._min.toString() + ".." + this._max.toString() : "Disabled";
  }
  get ATTR_visible__DisplayName() {
    return "Visible";
  }
  get ATTR_visible__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_visible__DescriptionAttribute() {
    return "Zone visibility.";
  }
  get visible() {
    return this._visible;
  }
  set visible(value) {
    this._visible = value;
  }
  get ATTR_min__DisplayName() {
    return "Minimum value";
  }
  get ATTR_min__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_min__DescriptionAttribute() {
    return "Zone minimum value";
  }
  get min() {
    return this._min;
  }
  set min(value) {
    this._min = value;
  }
  get ATTR_max__DisplayName() {
    return "Maximum value";
  }
  get ATTR_max__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_max__DescriptionAttribute() {
    return "Zone maximum value";
  }
  get max() {
    return this._max;
  }
  set max(value) {
    this._max = value;
  }
  get ATTR_color__DisplayName() {
    return "Color";
  }
  get ATTR_color__DescriptionAttribute() {
    return "Zone color";
  }
  get color() {
    return this._color;
  }
  set color(value) {
    this._color = value;
  }
  get ATTR_outerRadius__DisplayName() {
    return "Outer radius (%)";
  }
  get ATTR_outerRadius__DescriptionAttribute() {
    return "Zone outer radius, in percentage relative to dial radius ";
  }
  get outerRadius() {
    return this._outerRadius;
  }
  set outerRadius(value) {
    this._outerRadius = value;
  }
  get ATTR_width__DisplayName() {
    return "Width (%)";
  }
  get ATTR_width__DescriptionAttribute() {
    return "Zone  width, in percentage relative to dial radius ";
  }
  get width() {
    return this._width;
  }
  set width(value) {
    this._width = value;
  }
};
var FontDescription = class {
  constructor(name, size, color, italic, bold) {
    this._name = name;
    this._size = size;
    this._color = color;
    this._italic = italic;
    this._bold = bold;
  }
  ToString() {
    return this._name + " " + this._size.toString();
  }
  get summary() {
    return this._name + " " + this._size.toString();
  }
  get ATTR_name__DisplayName() {
    return "Font name";
  }
  get ATTR_name__AllowedValues() {
    return fontNameTypeDescription.AllowedValues;
  }
  get ATTR_name__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_name__DescriptionAttribute() {
    return "Name of the font";
  }
  get name() {
    return this._name;
  }
  set name(value) {
    this._name = value;
  }
  get ATTR_size__DisplayName() {
    return "Font size";
  }
  get ATTR_size__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_size__DescriptionAttribute() {
    return "Size of the font";
  }
  get size() {
    return this._size;
  }
  set size(value) {
    this._size = Math.round(100 * value) / 100;
  }
  get ATTR_color__DisplayName() {
    return "Font color";
  }
  get ATTR_color__DescriptionAttribute() {
    return "Color of the font.";
  }
  get color() {
    return this._color;
  }
  set color(value) {
    this._color = value;
  }
  get ATTR_italic__DisplayName() {
    return "Italic";
  }
  get ATTR_italic__DescriptionAttribute() {
    return "Is the font style italic?.";
  }
  get italic() {
    return this._italic;
  }
  set italic(value) {
    this._italic = value;
  }
  get ATTR_bold__DisplayName() {
    return "Bold";
  }
  get ATTR_bold__DescriptionAttribute() {
    return "Is the font style bold?.";
  }
  get bold() {
    return this._bold;
  }
  set bold(value) {
    this._bold = value;
  }
};
var digitalDisplayFormProperties = class extends GenericProperties {
  constructor(initData, owner) {
    super(owner);
    this._DataSource_source = sensorsManager.getNullSensor();
    this._DataSource_precision = "0.1";
    this._DataSource_AlarmSection0 = new AlarmSection(0);
    this._DataSource_AlarmSection1 = new AlarmSection(1);
    this._font = new FontDescription("Arial", 48, YColor.LightGreen, false, true);
    this._display_backgroundColor1 = YColor.Black;
    this._display_backgroundColor2 = YColor.Black;
    this._hrzAlignment = YDigitalDisplay.HrzAlignment.RIGHT;
    this._hrzAlignmentOfset = 5;
    this._outOfRangeMin = new doubleNan(Number.NaN);
    this._outOfRangeMax = new doubleNan(Number.NaN);
    this._outOfRangeColor = YColor.Red;
    this._annotationPanels0 = new AnnotationPanelDescription(GenericPanel.HorizontalAlignPos.CENTER, GenericPanel.VerticalAlignPos.CENTER, 0, false, "$NAME$", YColor.FromArgb(0, 127, 127, 127), YColor.FromArgb(0, 127, 127, 127), 10, YColor.FromArgb(255, 0, 0, 0));
    this._annotationPanels1 = new AnnotationPanelDescription(GenericPanel.HorizontalAlignPos.CENTER, GenericPanel.VerticalAlignPos.BOTTOM, 0, false, "$NAME$", YColor.FromArgb(0, 127, 127, 127), YColor.FromArgb(0, 127, 127, 127), 10, YColor.FromArgb(255, 0, 0, 0));
    this.initFromXmlData(initData);
    this.PropagateDataSourceChange();
  }
  PropagateDataSourceChange() {
    this.ownerForm.SourceChanged(this._DataSource_source, 0);
    let props = GenericProperties.getAllProperties(this).byName;
    let name;
    for (name in props) {
      if (name.startsWith("DataSource_AlarmSection")) {
        this[name].setDataSource(this._DataSource_source);
      }
    }
  }
  IsDataSourceAssigned() {
    return !(this._DataSource_source instanceof NullYSensor);
  }
  get ATTR_DataSource_source__DisplayName() {
    return "Sensor";
  }
  get ATTR_DataSource_source__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_source__ParamCategorySummaryAttribute() {
    return "sensorDescription";
  }
  get ATTR_DataSource_source__PreExpandedCategoryAttribute() {
    return true;
  }
  get ATTR_DataSource_source__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_DataSource_source__DescriptionAttribute() {
    return "Yoctopuce sensor feeding the display. " + GenericHints.CheckSensor;
  }
  get DataSource_source() {
    return this._DataSource_source;
  }
  set DataSource_source(value) {
    let prev = this._DataSource_source;
    this._DataSource_source = value;
    this.PropagateDataSourceChange();
    if (this._DataSource_source != prev)
      constants.edited = true;
  }
  get isSensorReadOnly() {
    return this._DataSource_source.isReadOnly;
  }
  get sensorDescription() {
    return this._DataSource_source instanceof NullYSensor ? "none" : this._DataSource_source.get_friendlyName();
  }
  get ATTR_DataSource_freq__DisplayName() {
    return "Sensor freq";
  }
  get ATTR_DataSource_freq__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_freq__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_DataSource_freq__IsReadonlyCallAttribute() {
    return "isSensorReadOnly";
  }
  get ATTR_DataSource_freq__DescriptionAttribute() {
    return "Sensor data acquisition frequency." + GenericHints.DevConfAffected;
  }
  get ATTR_DataSource_freq__AllowedValues() {
    return sensorFreqTypeDescription.AllowedValues;
  }
  get DataSource_freq() {
    return this._DataSource_source.get_frequency();
  }
  set DataSource_freq(value) {
    this._DataSource_source.set_frequency(value);
  }
  get ATTR_DataSource_precision__DisplayName() {
    return "Precision";
  }
  get ATTR_DataSource_precision__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_precision__DescriptionAttribute() {
    return "How many digits shown after the decimal point.";
  }
  get ATTR_DataSource_precision__AllowedValues() {
    return sensorPrecisionTypeDescription.AllowedValues;
  }
  get DataSource_precision() {
    return this._DataSource_precision;
  }
  set DataSource_precision(value) {
    this._DataSource_precision = value;
  }
  get ATTR_DataSource_AlarmSection0__DisplayName() {
    return "Sensor value alarm 1";
  }
  get ATTR_DataSource_AlarmSection0__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection0__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection0__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_AlarmSection0__DescriptionAttribute() {
    return "Alarm 1 for this data source, expand for more.";
  }
  get DataSource_AlarmSection0() {
    return this._DataSource_AlarmSection0;
  }
  set DataSource_AlarmSection0(value) {
    this._DataSource_AlarmSection0 = value;
  }
  get ATTR_DataSource_AlarmSection1__DisplayName() {
    return "Sensor value alarm 2";
  }
  get ATTR_DataSource_AlarmSection1__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection1__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection1__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_AlarmSection1__DescriptionAttribute() {
    return "Alarm 2 for this data source, expand for more.";
  }
  get DataSource_AlarmSection1() {
    return this._DataSource_AlarmSection1;
  }
  set DataSource_AlarmSection1(value) {
    this._DataSource_AlarmSection1 = value;
  }
  get ATTR_display_font__DisplayName() {
    return "Font";
  }
  get ATTR_display_font__CategoryAttribute() {
    return "Display";
  }
  get ATTR_display_font__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_display_font__DescriptionAttribute() {
    return "Display font";
  }
  get display_font() {
    return this._font;
  }
  set display_font(value) {
    this._font = value;
  }
  get ATTR_display_backgroundColor1__DisplayName() {
    return "Background color 1";
  }
  get ATTR_display_backgroundColor1__CategoryAttribute() {
    return "Display";
  }
  get ATTR_display_backgroundColor1__DescriptionAttribute() {
    return "Display background gradient color 1.";
  }
  get display_backgroundColor1() {
    return this._display_backgroundColor1;
  }
  set display_backgroundColor1(value) {
    this._display_backgroundColor1 = value;
  }
  get ATTR_display_backgroundColor2__DisplayName() {
    return "Background color 2";
  }
  get ATTR_display_backgroundColor2__CategoryAttribute() {
    return "Display";
  }
  get ATTR_display_backgroundColor2__DescriptionAttribute() {
    return "Display background gradient color 2.";
  }
  get display_backgroundColor2() {
    return this._display_backgroundColor2;
  }
  set display_backgroundColor2(value) {
    this._display_backgroundColor2 = value;
  }
  get ATTR_display_hrzAlignment__DisplayName() {
    return "Hrz alignment method";
  }
  get ATTR_display_hrzAlignment__CategoryAttribute() {
    return "Display";
  }
  get ATTR_display_hrzAlignment__DescriptionAttribute() {
    return "Horizontal alignment method";
  }
  get display_hrzAlignment() {
    return this._hrzAlignment;
  }
  set display_hrzAlignment(value) {
    this._hrzAlignment = value;
  }
  get ATTR_display_hrzAlignmentOfset__DisplayName() {
    return "Hrz alignment offset";
  }
  get ATTR_display_hrzAlignmentOfset__CategoryAttribute() {
    return "Display";
  }
  get ATTR_display_hrzAlignmentOfset__DescriptionAttribute() {
    return "Horizontal alignment offset in percentage. No effect when chosen horizontal alignment is CENTER";
  }
  get display_hrzAlignmentOfset() {
    return this._hrzAlignmentOfset;
  }
  set display_hrzAlignmentOfset(value) {
    this._hrzAlignmentOfset = value;
  }
  get ATTR_display_outOfRangeMin__DisplayName() {
    return "Minimum value";
  }
  get ATTR_display_outOfRangeMin__CategoryAttribute() {
    return "Range Control";
  }
  get ATTR_display_outOfRangeMin__DescriptionAttribute() {
    return `Regular range minimum value. if value goes  outside regular  range, color will turn to "Out of range Color".Leave blank if you don't want to define such a range. `;
  }
  get display_outOfRangeMin() {
    return this._outOfRangeMin;
  }
  set display_outOfRangeMin(value) {
    this._outOfRangeMin = value;
  }
  get ATTR_display_outOfRangeMax__DisplayName() {
    return "Maximum value";
  }
  get ATTR_display_outOfRangeMax__CategoryAttribute() {
    return "Range Control";
  }
  get ATTR_display_outOfRangeMax__DescriptionAttribute() {
    return `Regular range minimum value. if value goes  outside regular  range, color will turn to "Out of range Color".Leave blank if you don't want to define such a range. `;
  }
  get display_outOfRangeMax() {
    return this._outOfRangeMax;
  }
  set display_outOfRangeMax(value) {
    this._outOfRangeMax = value;
  }
  get ATTR_display_outOfRangeColor__DisplayName() {
    return "Out of range Color";
  }
  get ATTR_display_outOfRangeColor__CategoryAttribute() {
    return "Range Control";
  }
  get ATTR_display_outOfRangeColor__DescriptionAttribute() {
    return "Digits color when value is out of range.";
  }
  get display_outOfRangeColor() {
    return this._outOfRangeColor;
  }
  set display_outOfRangeColor(value) {
    this._outOfRangeColor = value;
  }
  get ATTR_display_annotationPanels0__DisplayName() {
    return "Annotation 1";
  }
  get ATTR_display_annotationPanels0__CategoryAttribute() {
    return "Annotations";
  }
  get ATTR_display_annotationPanels0__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_display_annotationPanels0__DescriptionAttribute() {
    return "Customizable text panels";
  }
  get display_annotationPanels0() {
    return this._annotationPanels0;
  }
  set display_annotationPanels0(value) {
    this._annotationPanels0 = value;
  }
  get ATTR_display_annotationPanels1__DisplayName() {
    return "Annotation 2";
  }
  get ATTR_display_annotationPanels1__CategoryAttribute() {
    return "Annotations";
  }
  get ATTR_display_annotationPanels1__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_display_annotationPanels1__DescriptionAttribute() {
    return "Customizable text panels";
  }
  get display_annotationPanels1() {
    return this._annotationPanels1;
  }
  set display_annotationPanels1(value) {
    this._annotationPanels1 = value;
  }
};
var AlarmSection = class {
  get summary() {
    let c = this._sensor.getAlarmCondition(this._index);
    if (c == 0)
      return "Disabled";
    return "Enabled";
  }
  constructor(index) {
    this._sensor = sensorsManager.getNullSensor();
    this._index = 0;
    this._index = index;
  }
  get ATTR_source__DisplayName() {
    return "Data source type";
  }
  get ATTR_source__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_source__AllowedValues() {
    return sensorDataTypeDescription.AllowedValues;
  }
  get ATTR_source__DescriptionAttribute() {
    return "Alarm sensor data source (Average, minimum or maximum value during last interval)";
  }
  get source() {
    return this._sensor.getAlarmSource(this._index);
  }
  set source(value) {
    this._sensor.setAlarmSource(this._index, value);
  }
  get ATTR_condition__DisplayName() {
    return "Test Condition";
  }
  get ATTR_condition__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_condition__AllowedValues() {
    return AlarmTestTypeDescription.AllowedValues;
  }
  get ATTR_condition__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_condition__DescriptionAttribute() {
    return "Alarm trigger condition";
  }
  get condition() {
    return this._sensor.getAlarmCondition(this._index);
  }
  set condition(value) {
    this._sensor.setAlarmCondition(this._index, value);
  }
  setDataSource(sensor) {
    this._sensor = sensor;
  }
  get ATTR_value__DisplayName() {
    return "Test Value";
  }
  get ATTR_value__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_value__DescriptionAttribute() {
    return "Value for the Alarm trigger";
  }
  get value() {
    return this._sensor.getAlarmValue(this._index);
  }
  set value(value) {
    this._sensor.setAlarmValue(this._index, value);
  }
  get ATTR_commandLine__DisplayName() {
    return "Trigger action";
  }
  get ATTR_commandLine__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_commandLine__DescriptionAttribute() {
    return "Javascript snippet executed in your browser each time the alarm is triggered, you can use the following variables: $SENSORVALUE$, $UNIT$, $HWDID$, $NAME$, $CONDITION$, $TRIGGER$, $DATATYPE$, $NOW$. Example : <tt>alarm('Warning $NAME$ = $SENSORVALUE$!');</tt>. You can check logs to find out if your alarm code works.";
  }
  get commandLine() {
    return this._sensor.getAlarmCommandline(this._index);
  }
  set commandLine(value) {
    this._sensor.setAlarmCommandline(this._index, value);
  }
  get ATTR_delay__DisplayName() {
    return "Trigger delay";
  }
  get ATTR_delay__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_delay__DescriptionAttribute() {
    return "Minimum delay, in seconds, between two alarms. Think carefully and make sure you won't create alarm storms.";
  }
  get delay() {
    return this._sensor.getAlarmDelay(this._index);
  }
  set delay(value) {
    this._sensor.setAlarmDelay(this._index, value);
  }
};
var ChartSerie = class {
  constructor(defaultColor) {
    this.ownerForm = null;
    this.index = -1;
    this.dataloggerAlreadyLoaded = false;
    this._DataSource_source = sensorsManager.getNullSensor();
    this._DataType = 0;
    this._thickness = 2;
    this._legend = "";
    this._color = YColor.Red;
    this._yAxisIndex = 0;
    this._DataSource_AlarmSection0 = new AlarmSection(0);
    this._DataSource_AlarmSection1 = new AlarmSection(1);
    this._color = defaultColor;
  }
  get summary() {
    return this._DataSource_source instanceof NullYSensor ? "none" : this._DataSource_source.get_friendlyName() + (this._DataSource_source.isOnline() ? "" : " - OFFLINE");
  }
  Init(owner, serieIndex) {
    this.ownerForm = owner;
    this.index = serieIndex;
    this.PropagateDataSourceChange(this._DataSource_source);
  }
  PropagateDataSourceChange(value) {
    this.ownerForm.SourceChanged(this._DataSource_source, this.index);
    let props = GenericProperties.getAllProperties(this).byName;
    let name;
    for (name in props) {
      if (name.startsWith("DataSource_AlarmSection")) {
        this[name].setDataSource(this._DataSource_source);
      }
    }
  }
  get ATTR_DataSource_source__DisplayName() {
    return "Sensor";
  }
  get ATTR_DataSource_source__CopyToTarget() {
    return false;
  }
  // this extra property doesn't exist is graph's series
  get ATTR_DataSource_source__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_DataSource_source__DescriptionAttribute() {
    return "Yoctopuce sensor feeding the graph. " + GenericHints.CheckSensor;
  }
  get DataSource_source() {
    return this._DataSource_source;
  }
  set DataSource_source(value) {
    let prev = this._DataSource_source;
    this._DataSource_source = value;
    if (this._DataSource_source != prev)
      constants.edited = true;
    if (this.ownerForm != null)
      this.PropagateDataSourceChange(this._DataSource_source);
  }
  get isSensorReadOnly() {
    return this._DataSource_source.isReadOnly;
  }
  get ATTR_DataSource_freq__DisplayName() {
    return "Sensor frequency";
  }
  get ATTR_DataSource_freq__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_DataSource_freq__CopyToTarget() {
    return false;
  }
  // this extra property doesn't exist is graph's series
  get ATTR_DataSource_freq__IsReadonlyCallAttribute() {
    return "isSensorReadOnly";
  }
  get ATTR_DataSource_freq__DescriptionAttribute() {
    return "Sensor data acquisition frequency." + GenericHints.DevConfAffected;
  }
  get ATTR_DataSource_freq__AllowedValues() {
    return sensorFreqTypeDescription.AllowedValues;
  }
  get DataSource_freq() {
    return this._DataSource_source.get_frequency();
  }
  set DataSource_freq(value) {
    this._DataSource_source.set_frequency(value);
  }
  get ATTR_DataSource_datatype__DisplayName() {
    return "Sensor data";
  }
  get ATTR_DataSource_datatype__AllowedValues() {
    return sensorDataTypeDescription.AllowedValues;
  }
  get ATTR_DataSource_datatype__CopyToTarget() {
    return false;
  }
  // this extra property doesn't exist is graph's series
  get ATTR_DataSource_datatype__DescriptionAttribute() {
    return "Which data for sensor are displayed on the graph. Min and Max are available only for frequencies <1Hz";
  }
  get DataSource_datatype() {
    return this._DataType;
  }
  set DataSource_datatype(value) {
    this._DataType = value;
    if (this.ownerForm != null) {
      this.ownerForm.SourceChanged(this._DataSource_source, this.index);
    }
  }
  get ATTR_DataSource_recording__DisplayName() {
    return "Sensor recording";
  }
  get ATTR_DataSource_recording__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_DataSource_recording__IsReadonlyCallAttribute() {
    return "isSensorReadOnly";
  }
  get ATTR_DataSource_recording__CopyToTarget() {
    return false;
  }
  // this extra property doesn't exist is graph's series
  get ATTR_DataSource_recording__DescriptionAttribute() {
    return "Enable/ disable sensor data recording in the device on-board datalogger." + GenericHints.DevConfAffected;
  }
  get DataSource_recording() {
    return this._DataSource_source.get_recording();
  }
  set DataSource_recording(value) {
    this._DataSource_source.set_recording(value);
  }
  get ATTR_thickness__DisplayName() {
    return "Thickness";
  }
  get ATTR_thickness__DescriptionAttribute() {
    return "Line thickness.";
  }
  get thickness() {
    return this._thickness;
  }
  set thickness(value) {
    this._thickness = value;
  }
  get ATTR_legend__DisplayName() {
    return "Legend";
  }
  get ATTR_legend__DescriptionAttribute() {
    return "Short description of the series.";
  }
  get legend() {
    return this._legend;
  }
  set legend(value) {
    this._legend = value;
  }
  get ATTR_color__DisplayName() {
    return "Color";
  }
  get ATTR_color__DescriptionAttribute() {
    return "Line color.";
  }
  get color() {
    return this._color;
  }
  set color(value) {
    this._color = value;
  }
  get ATTR_yAxisIndex__AllowedValues() {
    return yAxisDescription.AllowedValues;
  }
  get ATTR_yAxisIndex__DisplayName() {
    return "Y axis";
  }
  get ATTR_yAxisIndex__DescriptionAttribute() {
    return "Choose which Y axis the data with be scaled to.";
  }
  get yAxisIndex() {
    return this._yAxisIndex;
  }
  set yAxisIndex(value) {
    this._yAxisIndex = value;
  }
  get ATTR_DataSource_AlarmSection0__DisplayName() {
    return "Sensor value alarm 1";
  }
  get ATTR_DataSource_AlarmSection0__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection0__DescriptionAttribute() {
    return "Alarm 1 for this data source, expand for more.";
  }
  get DataSource_AlarmSection0() {
    return this._DataSource_AlarmSection0;
  }
  set DataSource_AlarmSection0(value) {
    this._DataSource_AlarmSection0 = value;
  }
  get ATTR_DataSource_AlarmSection1__DisplayName() {
    return "Sensor value alarm 2";
  }
  get ATTR_DataSource_AlarmSection1__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection1__DescriptionAttribute() {
    return "Alarm 2 for this data source, expand for more.";
  }
  get DataSource_AlarmSection1() {
    return this._DataSource_AlarmSection1;
  }
  set DataSource_AlarmSection1(value) {
    this._DataSource_AlarmSection1 = value;
  }
};
var LegendPanelDescription = class {
  constructor() {
    this._enabled = false;
    this._overlap = false;
    this._position = LegendPanel.Position.RIGHT;
    this._font = new FontDescription("Arial", 7, YColor.FromArgb(255, 32, 32, 32), false, true);
    this._bgColor = YColor.FromArgb(200, 255, 255, 255);
    this._borderColor = YColor.Black;
    this._borderthickness = 1;
    this._padding = 10;
    this._verticalMargin = 10;
    this._horizontalMargin = 10;
    this._traceWidthFactor = 1;
  }
  get summary() {
    return this._enabled ? "Enabled" : "Disabled";
  }
  get ATTR_enabled__DisplayName() {
    return "Enabled";
  }
  get ATTR_enabled__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_enabled__DescriptionAttribute() {
    return "Should the legend panel be shown or not";
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    this._enabled = value;
  }
  get ATTR_overlap__DisplayName() {
    return "Overlap";
  }
  get ATTR_overlap__DescriptionAttribute() {
    return "Can the panel overlap the graph data, or should we explicitly make space for it?";
  }
  get overlap() {
    return this._overlap;
  }
  set overlap(value) {
    this._overlap = value;
  }
  get ATTR_position__DisplayName() {
    return "Position";
  }
  get ATTR_position__DescriptionAttribute() {
    return "Position of the legend panel";
  }
  get position() {
    return this._position;
  }
  set position(value) {
    this._position = value;
  }
  get ATTR_font__DisplayName() {
    return "Font";
  }
  get ATTR_font__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_font__DescriptionAttribute() {
    return "Legend panel contents fonts";
  }
  get font() {
    return this._font;
  }
  set font(value) {
    this._font = value;
  }
  get ATTR_bgColor__DisplayName() {
    return "Background color ";
  }
  get ATTR_bgColor__DescriptionAttribute() {
    return "Legend panel background color.";
  }
  get bgColor() {
    return this._bgColor;
  }
  set bgColor(value) {
    this._bgColor = value;
  }
  get ATTR_borderColor__DisplayName() {
    return "Border color ";
  }
  get ATTR_borderColor__DescriptionAttribute() {
    return "Legend panel border color.";
  }
  get borderColor() {
    return this._borderColor;
  }
  set borderColor(value) {
    this._borderColor = value;
  }
  get ATTR_borderthickness__DisplayName() {
    return "Border thickness ";
  }
  get ATTR_borderthickness__DescriptionAttribute() {
    return "Legend panel border thickness";
  }
  get borderthickness() {
    return this._borderthickness;
  }
  set borderthickness(value) {
    this._borderthickness = value;
  }
  get ATTR_padding__DisplayName() {
    return "Padding ";
  }
  get ATTR_padding__DescriptionAttribute() {
    return "Distance between the panel border and the panel contents";
  }
  get padding() {
    return this._padding;
  }
  set padding(value) {
    this._padding = value;
  }
  get ATTR_verticalMargin__DisplayName() {
    return "Vertical margin ";
  }
  get ATTR_verticalMargin__DescriptionAttribute() {
    return "Vertical distance between the panel border and its surroundings";
  }
  get verticalMargin() {
    return this._verticalMargin;
  }
  set verticalMargin(value) {
    this._verticalMargin = value;
  }
  get ATTR_horizontalMargin__DisplayName() {
    return "Horizontal margin ";
  }
  get ATTR_horizontalMargin__DescriptionAttribute() {
    return "Distance between the panel border and its surroundings";
  }
  get horizontalMargin() {
    return this._horizontalMargin;
  }
  set horizontalMargin(value) {
    this._horizontalMargin = value;
  }
  get ATTR_traceWidthFactor__DisplayName() {
    return "Color Indicator Factor";
  }
  get ATTR_traceWidthFactor__DescriptionAttribute() {
    return "Factor used to enlarge series color indicators shown in the legend panel";
  }
  get traceWidthFactor() {
    return this._traceWidthFactor;
  }
  set traceWidthFactor(value) {
    this._traceWidthFactor = value;
  }
};
var AnnotationPanelDescription = class {
  get summary() {
    return this._enabled ? "Enabled" : "Disabled";
  }
  get ATTR_enabled__DisplayName() {
    return "Enabled";
  }
  get ATTR_enabled__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_enabled__DescriptionAttribute() {
    return "Should the annotation panel be shown or not";
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    this._enabled = value;
  }
  get ATTR_overlap__DisplayName() {
    return "Overlap";
  }
  get ATTR_overlap__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_overlap__DescriptionAttribute() {
    return "Can the annotation panel overlap the display zone, or should the display zone be squeezed to make space for the panel?";
  }
  get overlap() {
    return this._overlap;
  }
  set overlap(value) {
    this._overlap = value;
  }
  get ATTR_text__DisplayName() {
    return "Text ";
  }
  get ATTR_text__DescriptionAttribute() {
    return GenericHints.Annotation;
  }
  get text() {
    return this._text;
  }
  set text(value) {
    this._text = value;
  }
  get ATTR_panelTextAlign__DisplayName() {
    return "Text Alignment";
  }
  get ATTR_panelTextAlign__DescriptionAttribute() {
    return "How text is aligned, makes sense on multi-lines text only.";
  }
  get panelTextAlign() {
    return this._panelTextAlign;
  }
  set panelTextAlign(value) {
    this._panelTextAlign = value;
  }
  get ATTR_panelHrzAlign__DisplayName() {
    return "X Position";
  }
  get ATTR_panelHrzAlign__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_panelHrzAlign__DescriptionAttribute() {
    return "Annotation panel X position";
  }
  get panelHrzAlign() {
    return this._panelHrzAlign;
  }
  set panelHrzAlign(value) {
    this._panelHrzAlign = value;
  }
  get ATTR_positionOffsetX__DisplayName() {
    return "X Offset";
  }
  get ATTR_positionOffsetX__DescriptionAttribute() {
    return "X Position offset, in %  (overlap mode only)";
  }
  get positionOffsetX() {
    return this._positionOffsetX;
  }
  set positionOffsetX(value) {
    this._positionOffsetX = value;
  }
  get ATTR_panelVrtAlign__DisplayName() {
    return "Y Position";
  }
  get ATTR_panelVrtAlign__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_panelVrtAlign__DescriptionAttribute() {
    return "Annotation panel Y position";
  }
  get panelVrtAlign() {
    return this._panelVrtAlign;
  }
  set panelVrtAlign(value) {
    this._panelVrtAlign = value;
  }
  get ATTR_positionOffsetY__DisplayName() {
    return "Y Offset";
  }
  get ATTR_positionOffsetY__DescriptionAttribute() {
    return "Y Position offset, in %  (overlap mode only)";
  }
  get positionOffsetY() {
    return this._positionOffsetY;
  }
  set positionOffsetY(value) {
    this._positionOffsetY = value;
  }
  get ATTR_font__DisplayName() {
    return "Font";
  }
  get ATTR_font__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_font__DescriptionAttribute() {
    return "Panel font";
  }
  get font() {
    return this._font;
  }
  set font(value) {
    this._font = value;
  }
  get ATTR_bgColor__DisplayName() {
    return "Background color ";
  }
  get ATTR_bgColor__DescriptionAttribute() {
    return "Legend panel background color.";
  }
  get bgColor() {
    return this._bgColor;
  }
  set bgColor(value) {
    this._bgColor = value;
  }
  get ATTR_borderColor__DisplayName() {
    return "Border color ";
  }
  get ATTR_borderColor__DescriptionAttribute() {
    return "Legend panel border color.";
  }
  get borderColor() {
    return this._borderColor;
  }
  set borderColor(value) {
    this._borderColor = value;
  }
  get ATTR_borderthickness__DisplayName() {
    return "Border thickness ";
  }
  get ATTR_borderthickness__DescriptionAttribute() {
    return "Panel border thickness";
  }
  get borderthickness() {
    return this._borderthickness;
  }
  set borderthickness(value) {
    this._borderthickness = value;
  }
  get ATTR_padding__DisplayName() {
    return "Padding ";
  }
  get ATTR_padding__DescriptionAttribute() {
    return "Distance between the panel border and the panel contents";
  }
  get padding() {
    return this._padding;
  }
  set padding(value) {
    this._padding = value;
  }
  constructor(hrzAlignInit, vrtAlignInit, offsetY, overlap, textInit, BgColorInit, BorderColorInit, fontSizeInit, FontColorInit) {
    this._enabled = false;
    this._overlap = false;
    this._text = "Date: $DAY$/$MONTH$/$YEAR$";
    this._panelTextAlign = GenericPanel.TextAlign.CENTER;
    this._panelHrzAlign = GenericPanel.HorizontalAlignPos.CENTER;
    this._positionOffsetX = 0;
    this._panelVrtAlign = GenericPanel.VerticalAlignPos.TOP;
    this._positionOffsetY = 0;
    this._font = new FontDescription("Arial", 12, YColor.FromArgb(255, 32, 32, 32), false, false);
    this._bgColor = YColor.FromArgb(200, 255, 255, 255);
    this._borderColor = YColor.Black;
    this._borderthickness = 1;
    this._padding = 5;
    if (typeof textInit != "undefined")
      this._text = textInit;
    if (typeof offsetY != "undefined")
      this._positionOffsetY = offsetY;
    if (typeof overlap != "undefined")
      this._overlap = overlap;
    if (typeof BgColorInit != "undefined")
      this._bgColor = BgColorInit;
    if (typeof BorderColorInit != "undefined")
      this._borderColor = BorderColorInit;
    if (typeof fontSizeInit != "undefined")
      this._font.size = fontSizeInit;
    if (typeof FontColorInit != "undefined")
      this._font.color = FontColorInit;
    if (typeof vrtAlignInit != "undefined")
      this._panelVrtAlign = vrtAlignInit;
    if (typeof hrzAlignInit != "undefined")
      this._panelHrzAlign = hrzAlignInit;
  }
};
var AnnotationPanelDescriptionGraph = class extends AnnotationPanelDescription {
  // position,
  get ATTR_enabled__DisplayName() {
    return "Enabled";
  }
  get ATTR_enabled__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_enabled__DescriptionAttribute() {
    return "Should the annotation panel be shown or not";
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    this._enabled = value;
  }
  get ATTR_overlap__DisplayName() {
    return "Overlap";
  }
  get ATTR_overlap__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_overlap__DescriptionAttribute() {
    return "Can the annotation panel overlap the graph, or should the graph be squeezed to make space for the panel?";
  }
  get overlap() {
    return this._overlap;
  }
  set overlap(value) {
    this._overlap = value;
  }
  get ATTR_text__DisplayName() {
    return "Text ";
  }
  get ATTR_text__DescriptionAttribute() {
    return GenericHints.AnnotationGraph;
  }
  get text() {
    return this._text;
  }
  set text(value) {
    this._text = value;
  }
};
var DataTrackerDescription = class _DataTrackerDescription {
  constructor() {
    this._enabled = false;
    this._showSerieName = false;
    this._showTimeStamp = false;
    this._dataPrecision = _DataTrackerDescription.DataPrecision.PRECISION_NOLIMIT;
    this._diameter = 5;
    this._handleLength = 25;
    this._font = new FontDescription("Arial", 7, YColor.FromArgb(255, 32, 32, 32), false, false);
    this._bgColor = YColor.FromArgb(200, 255, 255, 255);
    this._borderColor = YColor.Black;
    this._borderthickness = 1;
    this._padding = 5;
    this._detectionDistance = 50;
  }
  get summary() {
    return this._enabled ? "Enabled" : "Disabled";
  }
  get ATTR_enabled__DisplayName() {
    return "Enabled";
  }
  get ATTR_enabled__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_enabled__DescriptionAttribute() {
    return "Should the data tracker be shown or not.";
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    this._enabled = value;
  }
  get ATTR_showSerieName__DisplayName() {
    return "Show Series legend";
  }
  get ATTR_showSerieName__DescriptionAttribute() {
    return "Should the data tracker show the value's series legend.";
  }
  get showSerieName() {
    return this._showSerieName;
  }
  set showSerieName(value) {
    this._showSerieName = value;
  }
  get ATTR_showTimeStamp__DisplayName() {
    return "Show Timestamp";
  }
  get ATTR_showTimeStamp__DescriptionAttribute() {
    return "Should the data tracker show the value's timestamp.";
  }
  get showTimeStamp() {
    return this._showTimeStamp;
  }
  set showTimeStamp(value) {
    this._showTimeStamp = value;
  }
  get ATTR_dataPrecision__DisplayName() {
    return "Precision";
  }
  get ATTR_dataPrecision__DescriptionAttribute() {
    return "A way to limit data precision to meaningful digits in the data tracker.";
  }
  get dataPrecision() {
    return this._dataPrecision;
  }
  set dataPrecision(value) {
    this._dataPrecision = value;
  }
  get ATTR_diameter__DisplayName() {
    return "Point Diameter";
  }
  get ATTR_diameter__DescriptionAttribute() {
    return "Data point diameter, in pixels";
  }
  get diameter() {
    return this._diameter;
  }
  set diameter(value) {
    this._diameter = value;
  }
  get ATTR_handleLength__DisplayName() {
    return "Handle size";
  }
  get ATTR_handleLength__DescriptionAttribute() {
    return "size of the handle between the data point and the value panel";
  }
  get handleLength() {
    return this._handleLength;
  }
  set handleLength(value) {
    this._handleLength = value;
  }
  get ATTR_font__DisplayName() {
    return "Font";
  }
  get ATTR_font__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_font__DescriptionAttribute() {
    return "Data tracker label fonts";
  }
  get font() {
    return this._font;
  }
  set font(value) {
    this._font = value;
  }
  get ATTR_bgColor__DisplayName() {
    return "Background color";
  }
  get ATTR_bgColor__DescriptionAttribute() {
    return "Value panel ground color.";
  }
  get bgColor() {
    return this._bgColor;
  }
  set bgColor(value) {
    this._bgColor = value;
  }
  get ATTR_borderColor__DisplayName() {
    return "Border color";
  }
  get ATTR_borderColor__DescriptionAttribute() {
    return "Value panel border and handle  color.";
  }
  get borderColor() {
    return this._borderColor;
  }
  set borderColor(value) {
    this._borderColor = value;
  }
  get ATTR_borderthickness__DisplayName() {
    return "Border thickness ";
  }
  get ATTR_borderthickness__DescriptionAttribute() {
    return "Value panel border and handle  thickness";
  }
  get borderthickness() {
    return this._borderthickness;
  }
  set borderthickness(value) {
    this._borderthickness = value;
  }
  get ATTR_padding__DisplayName() {
    return "Padding";
  }
  get ATTR_padding__DescriptionAttribute() {
    return "Distance between the panel border and its contents ";
  }
  get padding() {
    return this._padding;
  }
  set padding(value) {
    this._padding = value;
  }
  get ATTR_detectionDistance__DisplayName() {
    return "Detection distance";
  }
  get ATTR_detectionDistance__DescriptionAttribute() {
    return "Maximum distance, in pixels, between the mouse and a data point for data tracker to show. Use zero for infinite distance";
  }
  get detectionDistance() {
    return this._detectionDistance;
  }
  set detectionDistance(value) {
    this._detectionDistance = value;
  }
};
(function(DataTrackerDescription2) {
  class DataPrecisionEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, DataPrecision);
    }
  }
  DataTrackerDescription2.DataPrecisionEnumItem = DataPrecisionEnumItem;
  class DataPrecision extends YEnum {
  }
  DataPrecision.PRECISION_NOLIMIT = new DataPrecisionEnumItem("PRECISION_NOLIMIT", "As is");
  DataPrecision.PRECISION_1 = new DataPrecisionEnumItem("PRECISION_1", "1");
  DataPrecision.PRECISION_01 = new DataPrecisionEnumItem("PRECISION_01", "0.1");
  DataPrecision.PRECISION_001 = new DataPrecisionEnumItem("PRECISION_001", "0.01");
  DataPrecision.PRECISION_0001 = new DataPrecisionEnumItem("PRECISION_0001", "0.001");
  DataTrackerDescription2.DataPrecision = DataPrecision;
})(DataTrackerDescription || (DataTrackerDescription = {}));
var NavigatorDescription = class {
  get summary() {
    return this._enabled ? "Enabled" : "Disabled";
  }
  constructor() {
    this._enabled = false;
    this._bgColor1 = YColor.FromArgb(255, 225, 225, 225);
    this._bgColor2 = YColor.FromArgb(255, 225, 225, 225);
    this._borderThickness = 1;
    this._borderColor = YColor.Black;
    this._cursorColor = YColor.FromArgb(25, 0, 255, 0);
    this._cursorBorderColor = YColor.FromArgb(255, 96, 96, 96);
    this._yAxisHandling = Navigator.YAxisHandling.AUTO;
    this._xAxisThickness = 1;
    this._xAxisColor = YColor.Black;
    this._font = new FontDescription("Arial", 10, YColor.FromArgb(255, 32, 32, 32), false, false);
  }
  get ATTR_enabled__DisplayName() {
    return "Enabled";
  }
  get ATTR_enabled__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_enabled__DescriptionAttribute() {
    return "Should the navigator be shown or not.";
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    this._enabled = value;
  }
  get ATTR_bgColor1__DisplayName() {
    return "Background color 1";
  }
  get ATTR_bgColor1__DescriptionAttribute() {
    return "Navigator background gradient color 1.";
  }
  get bgColor1() {
    return this._bgColor1;
  }
  set bgColor1(value) {
    this._bgColor1 = value;
  }
  get ATTR_bgColor2__DisplayName() {
    return "Background color 2";
  }
  get ATTR_bgColor2__DescriptionAttribute() {
    return "Navigator background gradient color 2.";
  }
  get bgColor2() {
    return this._bgColor2;
  }
  set bgColor2(value) {
    this._bgColor2 = value;
  }
  get ATTR_borderThickness__DisplayName() {
    return "Border thickness";
  }
  get ATTR_borderThickness__DescriptionAttribute() {
    return "Navigator";
  }
  get borderThickness() {
    return this._borderThickness;
  }
  set borderThickness(value) {
    this._borderThickness = value;
  }
  get ATTR_borderColor__DisplayName() {
    return "Border color";
  }
  get ATTR_borderColor__DescriptionAttribute() {
    return "Navigator Border color.";
  }
  get borderColor() {
    return this._borderColor;
  }
  set borderColor(value) {
    this._borderColor = value;
  }
  get ATTR_cursorColor__DisplayName() {
    return "Navigator cursor fill color";
  }
  get ATTR_cursorColor__DescriptionAttribute() {
    return "Navigator";
  }
  get cursorColor() {
    return this._cursorColor;
  }
  set cursorColor(value) {
    this._cursorColor = value;
  }
  get ATTR_cursorBorderColor__DisplayName() {
    return "Navigator cursor left/right border color.";
  }
  get ATTR_cursorBorderColor__DescriptionAttribute() {
    return "Navigator";
  }
  get cursorBorderColor() {
    return this._cursorBorderColor;
  }
  set cursorBorderColor(value) {
    this._cursorBorderColor = value;
  }
  get ATTR_yAxisHandling__DisplayName() {
    return "Y axis range";
  }
  get ATTR_yAxisHandling__DescriptionAttribute() {
    return "Is navigator Y axis zoom automatic or inherited from main view settings?";
  }
  get yAxisHandling() {
    return this._yAxisHandling;
  }
  set yAxisHandling(value) {
    this._yAxisHandling = value;
  }
  get ATTR_xAxisThickness__DisplayName() {
    return "X axis thickness";
  }
  get ATTR_xAxisThickness__DescriptionAttribute() {
    return "Navigator";
  }
  get xAxisThickness() {
    return this._xAxisThickness;
  }
  set xAxisThickness(value) {
    this._xAxisThickness = value;
  }
  get ATTR_xAxisColor__DisplayName() {
    return "X axis color";
  }
  get ATTR_xAxisColor__DescriptionAttribute() {
    return "Navigator X axis color.";
  }
  get xAxisColor() {
    return this._xAxisColor;
  }
  set xAxisColor(value) {
    this._xAxisColor = value;
  }
  get ATTR_font__DisplayName() {
    return "X-Axis Font";
  }
  get ATTR_font__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_font__DescriptionAttribute() {
    return "Navigator X axis font";
  }
  get font() {
    return this._font;
  }
  set font(value) {
    this._font = value;
  }
};
var LegendDescription = class {
  constructor() {
    this._title = "";
    this._font = new FontDescription("Arial", 12, YColor.Black, false, true);
  }
  get ATTR_title__DisplayName() {
    return "Text";
  }
  get ATTR_title__DescriptionAttribute() {
    return "Legend text";
  }
  get title() {
    return this._title;
  }
  set title(value) {
    this._title = value;
  }
  get ATTR_font__DisplayName() {
    return "Font";
  }
  get ATTR_font__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_font__DescriptionAttribute() {
    return "Legend font";
  }
  get font() {
    return this._font;
  }
  set font(value) {
    this._font = value;
  }
};
var YaxisDescription = class {
  constructor(index, shown) {
    this._visible = false;
    this._position = YAxis.HrzPosition.LEFT;
    this._min = new doubleNan(Number.NaN);
    this._max = new doubleNan(Number.NaN);
    this._step = new doubleNan(Number.NaN);
    this._color = YColor.FromArgb(255, 127, 127, 127);
    this._thickness = 1;
    this._showGrid = false;
    this._gridColor = YColor.FromArgb(255, 210, 210, 210);
    this._gridThickness = 1;
    this._font = new FontDescription("Arial", 10, YColor.Black, false, false);
    this._legend = new LegendDescription();
    this._zones0 = new ZoneDescription(0, 50, YColor.LightGreen);
    this._zones1 = new ZoneDescription(50, 80, YColor.Yellow);
    this._zones2 = new ZoneDescription(80, 100, YColor.Red);
    this._visible = shown;
    this._showGrid = index == 0;
    this._position = index == 0 ? YAxis.HrzPosition.LEFT : YAxis.HrzPosition.RIGHT;
  }
  get summary() {
    return this._visible ? "Enabled" : "Disabled";
  }
  get ATTR_visible__DisplayName() {
    return "Visible";
  }
  get ATTR_visible__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_visible__DescriptionAttribute() {
    return "Should that YAxis be shown?.";
  }
  get visible() {
    return this._visible;
  }
  set visible(value) {
    this._visible = value;
  }
  get ATTR_position__DisplayName() {
    return "Position";
  }
  get ATTR_position__DescriptionAttribute() {
    return "Y Axis position (left / right)";
  }
  get position() {
    return this._position;
  }
  set position(value) {
    this._position = value;
  }
  get ATTR_min__DisplayName() {
    return "Minimum value";
  }
  get ATTR_min__DescriptionAttribute() {
    return "YAxis minimum value, leave blank for automatic behavior.";
  }
  get min() {
    return this._min;
  }
  set min(value) {
    this._min = value;
  }
  get ATTR_max__DisplayName() {
    return "Maximum value";
  }
  get ATTR_max__DescriptionAttribute() {
    return "YAxis maximum value, leave blank for automatic behavior.";
  }
  get max() {
    return this._max;
  }
  set max(value) {
    this._max = value;
  }
  get ATTR_step__DisplayName() {
    return "Steps";
  }
  get ATTR_step__DescriptionAttribute() {
    return "YAxis step size, leave blank for automatic behavior.";
  }
  get step() {
    return this._step;
  }
  set step(value) {
    this._step = value;
  }
  get ATTR_color__DisplayName() {
    return "Color";
  }
  get ATTR_color__DescriptionAttribute() {
    return "Y Axis Color.";
  }
  get color() {
    return this._color;
  }
  set color(value) {
    this._color = value;
  }
  get ATTR_thickness__DisplayName() {
    return "Thickness";
  }
  get ATTR_thickness__DescriptionAttribute() {
    return "Axis thickness";
  }
  get thickness() {
    return this._thickness;
  }
  set thickness(value) {
    this._thickness = value;
  }
  get ATTR_showGrid__DisplayName() {
    return "Show Grid";
  }
  get ATTR_showGrid__DescriptionAttribute() {
    return "Show grid horizontal lines, or not.";
  }
  get showGrid() {
    return this._showGrid;
  }
  set showGrid(value) {
    this._showGrid = value;
  }
  get ATTR_gridColor__DisplayName() {
    return "Grid Color";
  }
  get ATTR_gridColor__DescriptionAttribute() {
    return "Grid horizontal lines color.";
  }
  get gridColor() {
    return this._gridColor;
  }
  set gridColor(value) {
    this._gridColor = value;
  }
  get ATTR_gridThickness__DisplayName() {
    return "Grid thickness";
  }
  get ATTR_gridThickness__DescriptionAttribute() {
    return "Grid horizontal lines thickness";
  }
  get gridThickness() {
    return this._gridThickness;
  }
  set gridThickness(value) {
    this._gridThickness = value;
  }
  get ATTR_font__DisplayName() {
    return "Font";
  }
  get ATTR_font__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_font__DescriptionAttribute() {
    return "Axis font";
  }
  get font() {
    return this._font;
  }
  set font(value) {
    this._font = value;
  }
  get ATTR_legend__DisplayName() {
    return "Legend";
  }
  get ATTR_legend__DescriptionAttribute() {
    return "Axis legend";
  }
  get legend() {
    return this._legend;
  }
  set legend(value) {
    this._legend = value;
  }
  get ATTR_zones0__DisplayName() {
    return "Zone 1";
  }
  get ATTR_zones0__CategoryAttribute() {
    return "Zones";
  }
  get ATTR_zones0__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_zones0__DescriptionAttribute() {
    return "Zone 1 parameters";
  }
  get zones0() {
    return this._zones0;
  }
  set zones0(value) {
    this._zones0 = value;
  }
  get ATTR_zones1__DisplayName() {
    return "Zone 2";
  }
  get ATTR_zones1__CategoryAttribute() {
    return "Zones";
  }
  get ATTR_zones1__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_zones1__DescriptionAttribute() {
    return "Zone 2 parameters";
  }
  get zones1() {
    return this._zones1;
  }
  set zones1(value) {
    this._zones1 = value;
  }
  get ATTR_zones2__DisplayName() {
    return "Zone 3";
  }
  get ATTR_zones2__CategoryAttribute() {
    return "Zones";
  }
  get ATTR_zones2__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_zones2__DescriptionAttribute() {
    return "Zone 3 parameters";
  }
  get zones2() {
    return this._zones2;
  }
  set zones2(value) {
    this._zones2 = value;
  }
};
var MarkerDescription = class {
  constructor(defaultText) {
    this._enabled = false;
    this._text = "";
    this._textAlign = Marker.TextAlign.CENTER;
    this._timereference = TimeConverter.TimeReference.ABSOLUTE;
    this._positionOnXAxis = new xAxisPosition(TimeConverter.ToUnixTime(/* @__PURE__ */ new Date()), false);
    this._yposition = 95;
    this._bgColor = YColor.FromArgb(200, 255, 255, 192);
    this._borderColor = YColor.DarkRed;
    this._borderthickness = 1;
    this._padding = 5;
    this._font = new FontDescription("Arial", 7, YColor.Black, false, false);
    this._text = defaultText;
  }
  get summary() {
    return this._enabled ? "Enabled" : "Disabled";
  }
  get ATTR_enabled__DisplayName() {
    return "Enabled";
  }
  get ATTR_enabled__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_enabled__DescriptionAttribute() {
    return "Should that marker be shown?.";
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    this._enabled = value;
  }
  get ATTR_text__DisplayName() {
    return "Text";
  }
  get ATTR_text__DescriptionAttribute() {
    return "Marker text. Use \\n for multi-line text. Some variables are allowed such as $MARKERTIME$, $LEGEND1$, $VALUE1$, $UNIT1$, $LEGEND1$, $VALUE2$ etc.. Extensive use of marker variables migh make the graph rendering significantly slower.";
  }
  get text() {
    return this._text;
  }
  set text(value) {
    this._text = value;
  }
  get ATTR_textAlign__DisplayName() {
    return "Text Alignment";
  }
  get ATTR_textAlign__DescriptionAttribute() {
    return "How text is aligned, makes sense on multi-lines text only.";
  }
  get textAlign() {
    return this._textAlign;
  }
  set textAlign(value) {
    this._textAlign = value;
  }
  get ATTR_timereference__DisplayName() {
    return "Time reference";
  }
  get ATTR_timereference__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_timereference__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_timereference__DescriptionAttribute() {
    return "Should the marker time position be absolute or relative to first data timestamp? Note: relative markers won't be drawn until there is actual data.";
  }
  get timereference() {
    return this._timereference;
  }
  set timereference(value) {
    this._timereference = value;
    this._positionOnXAxis.relative = value == TimeConverter.TimeReference.RELATIVE;
  }
  get ATTR_positionOnXAxis__DisplayName() {
    return "Time position";
  }
  get ATTR_positionOnXAxis__DescriptionAttribute() {
    return "Marker position on X axis.";
  }
  get positionOnXAxis() {
    return this._positionOnXAxis;
  }
  set positionOnXAxis(value) {
    this._positionOnXAxis = value;
    this.timereference = value.relative ? TimeConverter.TimeReference.RELATIVE : TimeConverter.TimeReference.ABSOLUTE;
  }
  get ATTR_yposition__DisplayName() {
    return "Vrt position (%)";
  }
  get ATTR_yposition__DescriptionAttribute() {
    return "Vertical position of the marker label in % of available space. Zero is bottom";
  }
  get yposition() {
    return this._yposition;
  }
  set yposition(value) {
    this._yposition = value;
  }
  get ATTR_bgColor__DisplayName() {
    return "Background color ";
  }
  get ATTR_bgColor__DescriptionAttribute() {
    return "Marker  background color.";
  }
  get bgColor() {
    return this._bgColor;
  }
  set bgColor(value) {
    this._bgColor = value;
  }
  get ATTR_borderColor__DisplayName() {
    return "Border color ";
  }
  get ATTR_borderColor__DescriptionAttribute() {
    return "Marker border color.";
  }
  get borderColor() {
    return this._borderColor;
  }
  set borderColor(value) {
    this._borderColor = value;
  }
  get ATTR_borderthickness__DisplayName() {
    return "Border thickness ";
  }
  get ATTR_borderthickness__DescriptionAttribute() {
    return "Marker border thickness, in pixels.";
  }
  get borderthickness() {
    return this._borderthickness;
  }
  set borderthickness(value) {
    this._borderthickness = value;
  }
  get ATTR_padding__DisplayName() {
    return "Padding ";
  }
  get ATTR_padding__DescriptionAttribute() {
    return "Distance between the marker border and the marker contents, in pixels.";
  }
  get padding() {
    return this._padding;
  }
  set padding(value) {
    this._padding = value;
  }
  get ATTR_font__DisplayName() {
    return "Font";
  }
  get ATTR_font__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_font__DescriptionAttribute() {
    return "Marker Font";
  }
  get font() {
    return this._font;
  }
  set font(value) {
    this._font = value;
  }
};
var XaxisDescription = class {
  constructor() {
    this._initialZoom = 60;
    this._initialOffset = 0;
    this._position = XAxis.VrtPosition.BOTTOM;
    this._timeReference = TimeConverter.TimeReference.ABSOLUTE;
    this._overflowHandling = XAxis.OverflowHandling.SCROLL;
    this._color = YColor.FromArgb(255, 127, 127, 127);
    this._thickness = 1;
    this._showGrid = false;
    this._gridColor = YColor.FromArgb(50, 0, 0, 0);
    this._gridThickness = 1;
    this._font = new FontDescription("Arial", 10, YColor.Black, false, false);
    this._legend = new LegendDescription();
    this._markers0 = new MarkerDescription("Marker 1");
    this._markers1 = new MarkerDescription("Marker 2");
    this._markers2 = new MarkerDescription("Marker 3");
    this._markers3 = new MarkerDescription("Marker 4");
    this._markers4 = new MarkerDescription("Marker 5");
    this._markers5 = new MarkerDescription("Marker 6");
    this._markers6 = new MarkerDescription("Marker 7");
    this._markers7 = new MarkerDescription("Marker 8");
  }
  get ATTR_initialZoom__DisplayName() {
    return "Initial Zoom";
  }
  get ATTR_initialZoom__DescriptionAttribute() {
    return "Zoom level at application startup, i.e. width of the view-port in seconds.";
  }
  get initialZoom() {
    return this._initialZoom;
  }
  set initialZoom(value) {
    this._initialZoom = value;
  }
  get ATTR_initialOffset__DisplayName() {
    return "Initial Offset";
  }
  get ATTR_initialOffset__DescriptionAttribute() {
    return "Offset of the first data point in percentage of the viewport width. For instance a 50% value will put the first point in the middle of the viewport. This can be used to give some room for datalogger contents.";
  }
  get initialOffset() {
    return this._initialOffset;
  }
  set initialOffset(value) {
    this._initialOffset = value;
  }
  get ATTR_position__DisplayName() {
    return "Position";
  }
  get ATTR_position__DescriptionAttribute() {
    return "X Axis position (top / bottom)";
  }
  get position() {
    return this._position;
  }
  set position(value) {
    this._position = value;
  }
  get ATTR_timeReference__DisplayName() {
    return "Time reference";
  }
  get ATTR_timeReference__DescriptionAttribute() {
    return "Are gradation timestamps absolute or relative to experiment start time? ";
  }
  get timeReference() {
    return this._timeReference;
  }
  set timeReference(value) {
    this._timeReference = value;
  }
  get ATTR_overflowHandling__DisplayName() {
    return "Overflow Handling";
  }
  get ATTR_overflowHandling__DescriptionAttribute() {
    return "What to do when new data are about to reach the graph right border";
  }
  get overflowHandling() {
    return this._overflowHandling;
  }
  set overflowHandling(value) {
    this._overflowHandling = value;
  }
  get ATTR_color__DisplayName() {
    return "Color";
  }
  get ATTR_color__DescriptionAttribute() {
    return "X Axis Color.";
  }
  get color() {
    return this._color;
  }
  set color(value) {
    this._color = value;
  }
  get ATTR_thickness__DisplayName() {
    return "Thickness";
  }
  get ATTR_thickness__DescriptionAttribute() {
    return "Axis thickness";
  }
  get thickness() {
    return this._thickness;
  }
  set thickness(value) {
    this._thickness = value;
  }
  get ATTR_showGrid__DisplayName() {
    return "Show Grid";
  }
  get ATTR_showGrid__DescriptionAttribute() {
    return "Show grid vertical lines, or not.";
  }
  get showGrid() {
    return this._showGrid;
  }
  set showGrid(value) {
    this._showGrid = value;
  }
  get ATTR_gridColor__DisplayName() {
    return "Grid Color";
  }
  get ATTR_gridColor__DescriptionAttribute() {
    return "Grid vertical lines color.";
  }
  get gridColor() {
    return this._gridColor;
  }
  set gridColor(value) {
    this._gridColor = value;
  }
  get ATTR_gridThickness__DisplayName() {
    return "Grid thickness";
  }
  get ATTR_gridThickness__DescriptionAttribute() {
    return "Grid vertical lines thickness";
  }
  get gridThickness() {
    return this._gridThickness;
  }
  set gridThickness(value) {
    this._gridThickness = value;
  }
  get ATTR_font__DisplayName() {
    return "Font";
  }
  get ATTR_font__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_font__DescriptionAttribute() {
    return "Axis font";
  }
  get font() {
    return this._font;
  }
  set font(value) {
    this._font = value;
  }
  get ATTR_legend__DisplayName() {
    return "Legend";
  }
  get ATTR_legend__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_legend__DescriptionAttribute() {
    return "X Axis legend";
  }
  get legend() {
    return this._legend;
  }
  set legend(value) {
    this._legend = value;
  }
  get ATTR_markers0__DisplayName() {
    return "Marker 1";
  }
  get ATTR_markers0__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_markers0__CategoryAttribute() {
    return "Markers";
  }
  get ATTR_markers0__DescriptionAttribute() {
    return "First marker parameters";
  }
  get markers0() {
    return this._markers0;
  }
  set markers0(value) {
    this._markers0 = value;
  }
  get ATTR_markers1__DisplayName() {
    return "Marker 2";
  }
  get ATTR_markers1__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_markers1__CategoryAttribute() {
    return "Markers";
  }
  get ATTR_markers1__DescriptionAttribute() {
    return "Second marker parameters";
  }
  get markers1() {
    return this._markers1;
  }
  set markers1(value) {
    this._markers1 = value;
  }
  get ATTR_markers2__DisplayName() {
    return "Marker 3";
  }
  get ATTR_markers2__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_markers2__CategoryAttribute() {
    return "Markers";
  }
  get ATTR_markers2__DescriptionAttribute() {
    return "Third marker parameters";
  }
  get markers2() {
    return this._markers2;
  }
  set markers2(value) {
    this._markers2 = value;
  }
  get ATTR_markers3__DisplayName() {
    return "Marker 4";
  }
  get ATTR_markers3__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_markers3__CategoryAttribute() {
    return "Markers";
  }
  get ATTR_markers3__DescriptionAttribute() {
    return "Fourth marker parameters";
  }
  get markers3() {
    return this._markers3;
  }
  set markers3(value) {
    this._markers3 = value;
  }
  get ATTR_markers4__DisplayName() {
    return "Marker 5";
  }
  get ATTR_markers4__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_markers4__CategoryAttribute() {
    return "Markers";
  }
  get ATTR_markers4__DescriptionAttribute() {
    return "Fith marker parameters";
  }
  get markers4() {
    return this._markers4;
  }
  set markers4(value) {
    this._markers4 = value;
  }
  get ATTR_markers5__DisplayName() {
    return "Marker 6";
  }
  get ATTR_markers5__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_markers5__CategoryAttribute() {
    return "Markers";
  }
  get ATTR_markers5__DescriptionAttribute() {
    return "Sixth marker parameters";
  }
  get markers5() {
    return this._markers5;
  }
  set markers5(value) {
    this._markers5 = value;
  }
  get ATTR_markers6__DisplayName() {
    return "Marker 7";
  }
  get ATTR_markers6__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_markers6__CategoryAttribute() {
    return "Markers";
  }
  get ATTR_markers6__DescriptionAttribute() {
    return "Seventh marker parameters";
  }
  get markers6() {
    return this._markers6;
  }
  set markers6(value) {
    this._markers6 = value;
  }
  get ATTR_markers7__DisplayName() {
    return "Marker 8";
  }
  get ATTR_markers7__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_markers7__CategoryAttribute() {
    return "Markers";
  }
  get ATTR_markers7__DescriptionAttribute() {
    return "Height marker parameters";
  }
  get markers7() {
    return this._markers7;
  }
  set markers7(value) {
    this._markers7 = value;
  }
};
var GraphFormProperties = class extends GenericProperties {
  constructor(initData, owner) {
    super(owner);
    this._Graph_series0 = new ChartSerie(YColor.Tomato);
    this._Graph_series1 = new ChartSerie(YColor.DodgerBlue);
    this._Graph_series2 = new ChartSerie(YColor.SeaGreen);
    this._Graph_series3 = new ChartSerie(YColor.Gold);
    this._Graph_showRecordedData = false;
    this._Graph_borderColor = YColor.LightGray;
    this._Graph_borderThickness = 1;
    this._Graph_bgColor1 = YColor.FromArgb(255, 220, 220, 220);
    this._Graph_bgColor2 = YColor.FromArgb(55, 240, 240, 240);
    this._Graph_resizeRule = Proportional.ResizeRule.FIXED;
    this._Graph_xAxis = new XaxisDescription();
    this._Graph_yAxes0 = new YaxisDescription(0, true);
    this._Graph_yAxes1 = new YaxisDescription(1, false);
    this._Graph_yAxes2 = new YaxisDescription(2, false);
    this._Graph_legendPanel = new LegendPanelDescription();
    this._Graph_dataTracker = new DataTrackerDescription();
    this._Graph_navigator = new NavigatorDescription();
    this._annotationPanels0 = new AnnotationPanelDescriptionGraph();
    this._annotationPanels1 = new AnnotationPanelDescriptionGraph();
    this.initFromXmlData(initData);
  }
  IsDataSourceAssigned() {
    let propList = Object.getOwnPropertyNames(this);
    propList.forEach((name) => {
      if (name.startsWith("Graphs_series")) {
        let s = this[name].GetValue(this, null);
        if (!(s.DataSource_source instanceof NullYSensor))
          return true;
      }
    });
    return false;
  }
  get ATTR_Graph_series0__DisplayName() {
    return "Series 1";
  }
  get ATTR_Graph_series0__CategoryAttribute() {
    return "Data Sources";
  }
  get ATTR_Graph_series0__PreExpandedCategoryAttribute() {
    return true;
  }
  get ATTR_Graph_series0__PreExpandedAttribute() {
    return true;
  }
  get ATTR_Graph_series0__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_Graph_series0__DescriptionAttribute() {
    return "First data series, expand for more.";
  }
  get Graph_series0() {
    return this._Graph_series0;
  }
  set Graph_series0(value) {
    this._Graph_series0 = value;
  }
  get ATTR_Graph_series1__DisplayName() {
    return "Series 2";
  }
  get ATTR_Graph_series1__CategoryAttribute() {
    return "Data Sources";
  }
  get ATTR_Graph_series1__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_Graph_series1__DescriptionAttribute() {
    return "Second data series, expand for more.";
  }
  get Graph_series1() {
    return this._Graph_series1;
  }
  set Graph_series1(value) {
    this._Graph_series1 = value;
  }
  get ATTR_Graph_series2__DisplayName() {
    return "Series 3";
  }
  get ATTR_Graph_series2__CategoryAttribute() {
    return "Data Sources";
  }
  get ATTR_Graph_series2__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_Graph_series2__DescriptionAttribute() {
    return "Third data series, expand for more.";
  }
  get Graph_series2() {
    return this._Graph_series2;
  }
  set Graph_series2(value) {
    this._Graph_series2 = value;
  }
  get ATTR_Graph_series3__DisplayName() {
    return "Series 4";
  }
  get ATTR_Graph_series3__CategoryAttribute() {
    return "Data Sources";
  }
  get ATTR_Graph_series3__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_Graph_series3__DescriptionAttribute() {
    return "Fourth data series, expand for more.";
  }
  get Graph_series3() {
    return this._Graph_series3;
  }
  set Graph_series3(value) {
    this._Graph_series3 = value;
  }
  get ATTR_Graph_showRecordedData__DisplayName() {
    return "Use datalogger data";
  }
  get ATTR_Graph_showRecordedData__CategoryAttribute() {
    return "Graph";
  }
  get ATTR_Graph_showRecordedData__CopyToTarget() {
    return false;
  }
  // this extra property doesn't exist is graph
  get ATTR_Graph_showRecordedData__DescriptionAttribute() {
    return "Makes the graph load the sensors datalogger contents. After disabling this feature, you may want to reset the dataview with the right-click context menu.";
  }
  get Graph_showRecordedData() {
    return this._Graph_showRecordedData;
  }
  set Graph_showRecordedData(value) {
    if (this._Graph_showRecordedData != value) {
      this._Graph_showRecordedData = value;
      if (this.ownerForm != null) {
        this._Graph_showRecordedData ? this.ownerForm.loadRecordedDataIfNeeded() : this.ownerForm.removeDataloggerData();
      }
    }
  }
  get ATTR_Graph_borderColor__DisplayName() {
    return "Border color";
  }
  get ATTR_Graph_borderColor__CategoryAttribute() {
    return "Graph";
  }
  get ATTR_Graph_borderColor__DescriptionAttribute() {
    return "Canvas borders color.";
  }
  get Graph_borderColor() {
    return this._Graph_borderColor;
  }
  set Graph_borderColor(value) {
    this._Graph_borderColor = value;
  }
  get ATTR_Graph_borderThickness__DisplayName() {
    return "Border thickness";
  }
  get ATTR_Graph_borderThickness__CategoryAttribute() {
    return "Graph";
  }
  get ATTR_Graph_borderThickness__DescriptionAttribute() {
    return "Canvas borders thickness.";
  }
  get Graph_borderThickness() {
    return this._Graph_borderThickness;
  }
  set Graph_borderThickness(value) {
    this._Graph_borderThickness = value;
  }
  get ATTR_Graph_bgColor1__DisplayName() {
    return "Background color 1";
  }
  get ATTR_Graph_bgColor1__CategoryAttribute() {
    return "Graph";
  }
  get ATTR_Graph_bgColor1__DescriptionAttribute() {
    return "Background gradient color 1.";
  }
  get Graph_bgColor1() {
    return this._Graph_bgColor1;
  }
  set Graph_bgColor1(value) {
    this._Graph_bgColor1 = value;
  }
  get ATTR_Graph_bgColor2__DisplayName() {
    return "Background color 2";
  }
  get ATTR_Graph_bgColor2__CategoryAttribute() {
    return "Graph";
  }
  get ATTR_Graph_bgColor2__DescriptionAttribute() {
    return "Background gradient color 2.";
  }
  get Graph_bgColor2() {
    return this._Graph_bgColor2;
  }
  set Graph_bgColor2(value) {
    this._Graph_bgColor2 = value;
  }
  get ATTR_Graph_resizeRule__DisplayName() {
    return "Font sizes";
  }
  get ATTR_Graph_resizeRule__CategoryAttribute() {
    return "Graph";
  }
  get ATTR_Graph_resizeRule__DescriptionAttribute() {
    return "Are font sizes fixed or do they change when window is resized?";
  }
  get Graph_resizeRule() {
    return this._Graph_resizeRule;
  }
  set Graph_resizeRule(value) {
    this._Graph_resizeRule = value;
  }
  get ATTR_Graph_xAxis__DisplayName() {
    return "X Axis";
  }
  get ATTR_Graph_xAxis__CategoryAttribute() {
    return "X/Y Axes";
  }
  get ATTR_Graph_xAxis__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_Graph_xAxis__DescriptionAttribute() {
    return "X-Axis, expand for more";
  }
  get Graph_xAxis() {
    return this._Graph_xAxis;
  }
  set Graph_xAxis(value) {
    this._Graph_xAxis = value;
  }
  get ATTR_Graph_yAxes0__DisplayName() {
    return "YAxis 1";
  }
  get ATTR_Graph_yAxes0__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_Graph_yAxes0__CategoryAttribute() {
    return "X/Y Axes";
  }
  get ATTR_Graph_yAxes0__DescriptionAttribute() {
    return "First Y Axis, expand for more.";
  }
  get Graph_yAxes0() {
    return this._Graph_yAxes0;
  }
  set Graph_yAxes0(value) {
    this._Graph_yAxes0 = value;
  }
  get ATTR_Graph_yAxes1__DisplayName() {
    return "YAxis 2";
  }
  get ATTR_Graph_yAxes1__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_Graph_yAxes1__CategoryAttribute() {
    return "X/Y Axes";
  }
  get ATTR_Graph_yAxes1__DescriptionAttribute() {
    return "Second Y Axis, expand for more.";
  }
  get Graph_yAxes1() {
    return this._Graph_yAxes1;
  }
  set Graph_yAxes1(value) {
    this._Graph_yAxes1 = value;
  }
  get ATTR_Graph_yAxes2__DisplayName() {
    return "YAxis 3";
  }
  get ATTR_Graph_yAxes2__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_Graph_yAxes2__CategoryAttribute() {
    return "X/Y Axes";
  }
  get ATTR_Graph_yAxes2__DescriptionAttribute() {
    return "Third Y Axis, expand for more.";
  }
  get Graph_yAxes2() {
    return this._Graph_yAxes2;
  }
  set Graph_yAxes2(value) {
    this._Graph_yAxes2 = value;
  }
  get ATTR_Graph_legendPanel__DisplayName() {
    return "Legend Panel";
  }
  get ATTR_Graph_legendPanel__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_Graph_legendPanel__CategoryAttribute() {
    return "Graph";
  }
  get ATTR_Graph_legendPanel__DescriptionAttribute() {
    return "Panel containing a description of all data series. Expand for more.";
  }
  get Graph_legendPanel() {
    return this._Graph_legendPanel;
  }
  set Graph_legendPanel(value) {
    this._Graph_legendPanel = value;
  }
  get ATTR_Graph_dataTracker__DisplayName() {
    return "Data tracker";
  }
  get ATTR_Graph_dataTracker__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_Graph_dataTracker__CategoryAttribute() {
    return "Graph";
  }
  get ATTR_Graph_dataTracker__DescriptionAttribute() {
    return "Show dynamic value labels while the mouse is moving over the graph. Expand for more.";
  }
  get Graph_dataTracker() {
    return this._Graph_dataTracker;
  }
  set Graph_dataTracker(value) {
    this._Graph_dataTracker = value;
  }
  get ATTR_Graph_navigator__DisplayName() {
    return "Navigator";
  }
  get ATTR_Graph_navigator__CategoryAttribute() {
    return "Graph";
  }
  get ATTR_Graph_navigator__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_Graph_navigator__DescriptionAttribute() {
    return "Small additional graph showing the whole data set and allowing to quickly navigate among data. Expand for more.";
  }
  get Graph_navigator() {
    return this._Graph_navigator;
  }
  set Graph_navigator(value) {
    this._Graph_navigator = value;
  }
  get ATTR_Graph_annotationPanels0__DisplayName() {
    return "Annotation 1";
  }
  get ATTR_Graph_annotationPanels0__CategoryAttribute() {
    return "Annotations";
  }
  get ATTR_Graph_annotationPanels0__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_Graph_annotationPanels0__DescriptionAttribute() {
    return "Customizable text panel 1";
  }
  get Graph_annotationPanels0() {
    return this._annotationPanels0;
  }
  set Graph_annotationPanels0(value) {
    this._annotationPanels0 = value;
  }
  get ATTR_Graph_annotationPanels1__DisplayName() {
    return "Annotation 2";
  }
  get ATTR_Graph_annotationPanels1__CategoryAttribute() {
    return "Annotations";
  }
  get ATTR_Graph_annotationPanels1__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_Graph_annotationPanels1__DescriptionAttribute() {
    return "Customizable text panel 2";
  }
  get Graph_annotationPanels1() {
    return this._annotationPanels1;
  }
  set Graph_annotationPanels1(value) {
    this._annotationPanels1 = value;
  }
};

// obj/full/contextMenu.js
var ContextMenuSeparator = class {
  constructor() {
    this.TR = document.createElement("TR");
    this.TR["objectData"] = this;
    this.TR.className = ContextMenu.SEPARATOR_MARKER;
    this.TD_caption = document.createElement("TD");
    this.TD_caption.style.backgroundColor = ContextMenu.iconBGColor;
    this.TD_caption.style.paddingLeft = "3px";
    this.TD_caption.style.paddingRight = "3px";
    let hr = document.createElement("HR");
    this.TD_caption.colSpan = 2;
    this.TD_caption.appendChild(hr);
    this.TD_icon = document.createElement("TD");
    this.TD_icon.style.backgroundColor = ContextMenu.captionBgColor;
    this.TR.appendChild(this.TD_icon);
    this.TR.appendChild(this.TD_caption);
  }
  toString() {
    return "Separator";
  }
  get focusable() {
    return false;
  }
  parentMenuisClosing() {
  }
  get domData() {
    return this.TR;
  }
};
var ContextMenuItemBase = class {
  get userdata() {
    return this._userdata;
  }
  set userdata(value) {
    this._userdata = value;
  }
  constructor(menu, icon, caption) {
    this._clickHidesMenu = true;
    this._userdata = null;
    this._menu = menu;
    this.TR = document.createElement("TR");
    this.TR["objectData"] = this;
    this.TD_caption = document.createElement("TD");
    this.TD_caption.style.backgroundColor = ContextMenu.iconBGColor;
    this.TD_caption.style.paddingLeft = "3px";
    this.TD_caption.style.paddingRight = "3px";
    this.TD_caption.style.whiteSpace = "nowrap";
    this.TD_icon = document.createElement("TD");
    if (icon != null)
      this.TD_icon.innerHTML = icon;
    this.TD_icon.style.backgroundColor = ContextMenu.captionBgColor;
    this.A_caption = document.createElement("A");
    this.A_caption.innerHTML = caption;
    this.TR.style.cursor = "pointer";
    this.TR.tabIndex = 0;
    this.TR.style.outline = "none";
    this._TR_keydown = (e) => {
      e.preventDefault();
      this.keydown(e);
    };
    this._TR_mouseover = (e) => {
      this.mouserOver(e);
    };
    this._TR_mouseout = (e) => {
      this.mouserOut(e);
    };
    this._A_mouseover = (e) => {
      this.mouserOver(e);
    };
    this._A_mouseout = (e) => {
      this.mouserOut(e);
    };
    this._A_click = (e) => {
      this.activate();
    };
    this._TR_focusin = () => {
      this.focusIn();
    };
    this._TR_focusout = () => {
      this.focusOut();
    };
    this.TR.addEventListener("mouseover", this._TR_mouseover);
    this.TR.addEventListener("mouseout", this._TR_mouseout);
    this.TR.addEventListener("click", this._A_click);
    this.TR.addEventListener("keydown", this._TR_keydown);
    this.A_caption.addEventListener("mouseover", this._A_mouseover);
    this.A_caption.addEventListener("mouseout", this._A_mouseout);
    this.TD_caption.appendChild(this.A_caption);
    this.TR.appendChild(this.TD_icon);
    this.TR.appendChild(this.TD_caption);
    this.TR.addEventListener("focusin", this._TR_focusin);
    this.TR.addEventListener("focusout", this._TR_focusout);
  }
  toString() {
    return this.TD_caption.innerText;
  }
  get focusable() {
    return this.visible;
  }
  activate() {
  }
  focus() {
    this.TR.focus();
    this._menu.closeSubmenus();
  }
  focusIn() {
    if (this.TD_caption.style.backgroundColor == ContextMenu.iconBGColor)
      this._menu.closeSubmenus();
    this.TD_caption.style.backgroundColor = ContextMenu.ActiveColor;
    this.TD_icon.style.backgroundColor = ContextMenu.ActiveColor;
  }
  focusOut() {
    this.TD_caption.style.backgroundColor = ContextMenu.iconBGColor;
    this.TD_icon.style.backgroundColor = ContextMenu.captionBgColor;
  }
  removeAndDestroy() {
    if (this.TR.parentNode != null)
      this.TR.parentNode.removeChild(this.TR);
    this.TR.removeEventListener("keydown", this._TR_keydown);
    this.TR.removeEventListener("mouseover", this._TR_mouseover);
    this.TR.removeEventListener("mouseout", this._TR_mouseout);
    this.A_caption.removeEventListener("mouseover", this._A_mouseover);
    this.A_caption.removeEventListener("mouseout", this._A_mouseout);
    this.A_caption.removeEventListener("click", this._A_click);
    this.TR.removeEventListener("focusin", this._TR_focusin);
    this.TR.removeEventListener("focusout", this._TR_focusout);
  }
  set caption(value) {
    this.A_caption.innerHTML = value;
  }
  get caption() {
    return this.A_caption.innerHTML;
  }
  keydown(e) {
    if (e.code == "ArrowDown")
      this._menu.activateNext(this);
    if (e.code == "ArrowUp")
      this._menu.activatePrevious(this);
    if (e.code == "Enter")
      this.activate();
    if (e.code == "Escape") {
      this._menu.close();
      if (this._menu.parentMenuItem != null)
        this._menu.parentMenuItem.focus();
    }
    if (e.code == "ArrowLeft") {
      if (this._menu.parentMenuItem != null) {
        this._menu.close();
        this._menu.parentMenuItem.focus();
      }
    }
  }
  mouserOver(e) {
    this.TD_caption.style.backgroundColor = ContextMenu.ActiveColor;
    this.TD_icon.style.backgroundColor = ContextMenu.ActiveColor;
    this._menu.closeSubmenus();
  }
  mouserOut(e) {
    this.TD_caption.style.backgroundColor = ContextMenu.iconBGColor;
    this.TD_icon.style.backgroundColor = ContextMenu.captionBgColor;
  }
  get domData() {
    return this.TR;
  }
  get visible() {
    return this.TR.style.display != "none";
  }
  set visible(value) {
    this.TR.style.display = value ? "" : "none";
  }
  parentMenuisClosing() {
  }
  closeMenu(all) {
    if (all)
      this._menu.closeAll();
    else
      this._menu.close();
  }
};
var ContextMenuItem = class extends ContextMenuItemBase {
  activate() {
    if (this._clickHidesMenu)
      this.closeMenu(true);
    if (this._callback != null)
      this._callback();
  }
  constructor(menu, icon, caption, callback) {
    super(menu, icon, caption);
    this._callback = callback;
    this.TD_caption.colSpan = 2;
  }
};
var ContextMenuItemSubMenuEntry = class extends ContextMenuItem {
  constructor(menu, icon, caption, submenu) {
    super(menu, icon, caption, null);
    this.TD_caption.colSpan = 1;
    this._submenu = submenu;
    this._submenu.parentMenuItem = this;
    this._parentmenu = menu;
    this._clickHidesMenu = false;
    this.TD_arrow = document.createElement("TD");
    this.TD_arrow.style.backgroundColor = ContextMenu.iconBGColor;
    this.TD_arrow.style.textAlign = "right";
    this.TD_arrow.style.paddingRight = "3px";
    this.TD_arrow.innerHTML = "&#9654;";
    this.TR.appendChild(this.TD_arrow);
    this.A_caption.addEventListener("click", (e) => {
      this.showSubmenu();
    });
    this.A_caption.addEventListener("touchstart", (e) => {
      if (e.touches.length == 1)
        this.activate();
    });
    this._submenu.zIndex = this._parentmenu.zIndex + 1;
  }
  keydown(e) {
    super.keydown(e);
    if (e.code == "ArrowRight") {
      this.activate();
      this._submenu.focusFirst();
    }
  }
  removeAndDestroy() {
    this._submenu.close();
    this._submenu.destroy();
    super.removeAndDestroy();
  }
  activate() {
    this.showSubmenu();
  }
  get submenu() {
    return this._submenu;
  }
  showSubmenu() {
    this._submenu.zIndex = this._parentmenu.zIndex + 1;
    let x = 0;
    let y = 0;
    let it = this.TR;
    do {
      x += it.offsetLeft || 0;
      y += it.offsetTop || 0;
      it = it.offsetParent;
    } while (it);
    this._submenu.showContextMenu(x + this._parentmenu.width - 15, y + 5);
  }
  focusIn() {
    super.focusIn();
    this.TD_arrow.style.backgroundColor = ContextMenu.ActiveColor;
  }
  focusOut() {
    super.focusOut();
    this.TD_arrow.style.backgroundColor = ContextMenu.iconBGColor;
  }
  parentMenuisClosing() {
    this._submenu.close();
  }
  mouserOver(e) {
    this.focusIn();
    this._parentmenu.setDelayedAction(() => {
      if (this.visible)
        this.showSubmenu();
    });
  }
  mouserOut(e) {
    this._parentmenu.cancelDelayedAction();
    this.focusOut();
  }
};
var ContextMenuBase = class {
  get parentMenuItem() {
    return this._parentMenuItem;
  }
  set parentMenuItem(value) {
    this._parentMenuItem = value;
  }
  get userdata() {
    return this._userdata;
  }
  set userdata(value) {
    this._userdata = value;
  }
  constructor(baseSize, openCallback, fontFamily) {
    this._visible = false;
    this._zIndex = 100002;
    this._parentmenu = null;
    this._parentMenuItem = null;
    this._userdata = null;
    this._openCallback = openCallback;
    this.Menutable = document.createElement("TABLE");
    this.Menutable.style.position = "absolute";
    this.Menutable.style.border = "1px solid #808080";
    if (typeof fontFamily !== "undefined")
      this.Menutable.style.fontFamily = fontFamily;
    this.Menutable.style.fontSize = (2 * baseSize / 3).toFixed(1) + "px";
    this.Menutable.style.borderSpacing = "0";
    this.Menutable.style.boxShadow = " 4px 4px 4px 1px rgba(0,0,0,0.05)";
    this.Menutable.style.zIndex = this._zIndex.toString();
    this._timer = null;
    this.visible = false;
  }
  closeAll() {
    this.close();
    if (this._parentmenu != null)
      this._parentmenu.closeAll();
  }
  cancelDelayedAction() {
    if (this._timer != null) {
      clearTimeout(this._timer);
      this._timer = null;
    }
  }
  setDelayedAction(action) {
    this.cancelDelayedAction();
    this._timer = setTimeout(() => {
      action();
    }, 500);
  }
  get parentMenu() {
    return this._parentmenu;
  }
  destroy() {
    for (let i = 0; i < this.Menutable.childNodes.length; i++) {
      let item = this.Menutable.childNodes[i]["objectData"];
      item.removeAndDestroy();
    }
    if (this.Menutable.parentNode != null)
      this.Menutable.parentNode.removeChild(this.Menutable);
  }
  focusFirst() {
    for (let i = 0; i < this.Menutable.childNodes.length; i++) {
      let item = this.Menutable.childNodes[i]["objectData"];
      if (item.focusable) {
        item.focus();
        return;
      }
    }
  }
  toString() {
    let res = "";
    for (let i = 0; i < this.Menutable.childNodes.length; i++) {
      let item = this.Menutable.childNodes[i]["objectData"];
      res = res + item.caption + "";
    }
    return res;
  }
  isXYOnMenu(x, y) {
    if (!this.visible)
      return false;
    if (x >= this.Menutable.offsetLeft && x <= this.Menutable.offsetLeft + this.Menutable.offsetWidth && y >= this.Menutable.offsetTop && y <= this.Menutable.offsetTop + this.Menutable.offsetHeight) {
      return true;
    }
    for (let i = 0; i < this.Menutable.childNodes.length; i++) {
      let item = this.Menutable.childNodes[i]["objectData"];
      if (item instanceof ContextMenuItemSubMenuEntry) {
        if (item.submenu.isXYOnMenu(x, y))
          return true;
      }
    }
    return false;
  }
  activateNext(source) {
    let found = false;
    for (let i = 0; i < this.Menutable.childNodes.length; i++) {
      let item = this.Menutable.childNodes[i]["objectData"];
      if (item == source) {
        found = true;
      } else if (found && item.focusable) {
        item.focus();
        return;
      }
    }
  }
  activatePrevious(source) {
    let previous = null;
    for (let i = 0; i < this.Menutable.childNodes.length; i++) {
      let item = this.Menutable.childNodes[i]["objectData"];
      if (item == source) {
        if (previous != null)
          previous.focus();
        return;
      }
      if (item.focusable)
        previous = item;
    }
  }
  get width() {
    return this.Menutable.offsetWidth;
  }
  closeSubmenus() {
    this.closeSubMenusExcept(null);
  }
  get zIndex() {
    return this._zIndex;
  }
  set zIndex(value) {
    this._zIndex = value;
    this.Menutable.style.zIndex = this._zIndex.toString();
  }
  get visible() {
    return this.Menutable.style.display != "none";
  }
  set visible(value) {
    this.Menutable.style.display = value ? "" : "none";
  }
  close() {
    this.cancelDelayedAction();
    for (let i = 0; i < this.Menutable.childNodes.length; i++) {
      let item = this.Menutable.childNodes[i]["objectData"];
      item.parentMenuisClosing();
    }
    this.visible = false;
    this.closeSubmenus();
  }
  refresh() {
    let showSeparation = false;
    for (let i = 0; i < this.Menutable.childNodes.length; i++) {
      let element = this.Menutable.childNodes[i];
      if (element.className == ContextMenu.SEPARATOR_MARKER) {
        element.style.display = showSeparation ? "" : "none";
        showSeparation = false;
      } else if (element.style.display == "")
        showSeparation = true;
    }
  }
  addMenuItem(icon, caption, callback) {
    let menuItem = new ContextMenuItem(this, icon, caption, callback);
    this.Menutable.appendChild(menuItem.domData);
    return menuItem;
  }
  get menuItemsCount() {
    return this.Menutable.childNodes.length;
  }
  closeSubMenusExcept(doNotClose) {
    for (let i = 0; i < this.Menutable.childNodes.length; i++) {
      let item = this.Menutable.childNodes[i]["objectData"];
      if (item instanceof ContextMenuItemSubMenuEntry) {
        if (item.submenu != doNotClose) {
          item.submenu.close();
        }
      }
    }
  }
  subMenuisOpening(source) {
    this.closeSubMenusExcept(source);
  }
  addSubMenuItem(icon, caption, submenu) {
    submenu.zIndex = this.zIndex + 1;
    let menuItem = new ContextMenuItemSubMenuEntry(this, icon, caption, submenu);
    this.Menutable.appendChild(menuItem.domData);
    return menuItem;
  }
  clearAllContents() {
    while (this.Menutable.childNodes.length > 0) {
      let item = this.Menutable.childNodes[0]["objectData"];
      item.removeAndDestroy();
    }
  }
  AddSeparator() {
    let separator = new ContextMenuSeparator();
    this.Menutable.appendChild(separator.domData);
    return separator;
  }
  showContextMenu(x, y) {
  }
};
ContextMenuBase.SEPARATOR_MARKER = "separator";
ContextMenuBase.iconBGColor = "#fdfdfd";
ContextMenuBase.captionBgColor = "#f1f1f1";
ContextMenuBase.ActiveColor = "#c4e1ff";
var ContextSubMenu = class extends ContextMenuBase {
  constructor(baseSize, parentMenu, openCallback, fontFamily) {
    super(baseSize, openCallback, fontFamily);
    this._parentmenu = parentMenu;
    document.body.appendChild(this.Menutable);
  }
  showContextMenu(x, y) {
    if (this._parentmenu != null)
      this._parentmenu.subMenuisOpening(this);
    if (this._openCallback != null)
      this._openCallback(x, y);
    this.Menutable.style.left = x.toString() + "px";
    this.Menutable.style.top = y.toString() + "px";
    this.visible = true;
    let right = this.Menutable.offsetLeft - this.Menutable.scrollLeft + this.Menutable.offsetWidth;
    let bottom = this.Menutable.offsetTop - this.Menutable.scrollTop + this.Menutable.offsetHeight;
    if (right > window.innerWidth)
      this.Menutable.style.left = (x - (right - window.innerWidth)).toString() + "px";
    if (bottom > window.innerHeight)
      this.Menutable.style.top = (y - (bottom - window.innerHeight)).toString() + "px";
  }
};
var ContextMenu = class extends ContextMenuBase {
  constructor(baseSize, openCallback, fontFamily) {
    super(baseSize, openCallback, fontFamily);
    document.addEventListener("contextmenu", (e) => {
      let tagname = "";
      if (e.target != null && constants.RunningOnAndroid)
        tagname = e.target.tagName;
      if (tagname != "INPUT") {
        e.preventDefault();
        this.showContextMenu(e.pageX, e.pageY);
      }
    });
    document.addEventListener("dblclick", (e) => {
      if (constants.dbleClickBringsUpContextMenu)
        this.showContextMenu(e.pageX, e.pageY);
    });
    document.addEventListener("click", (e) => {
      this.click(e);
    });
    document.body.appendChild(this.Menutable);
  }
  click(e) {
    if (!this.visible)
      return;
    if (!this.isXYOnMenu(e.pageX, e.pageY)) {
      this.close();
    }
  }
  showContextMenu(x, y) {
    let z = YWindow.ConTextMenuBestZindex;
    if (z < 0)
      return;
    this.zIndex = z;
    this.Menutable.style.left = x.toString() + "px";
    this.Menutable.style.top = y.toString() + "px";
    this.visible = true;
    let right = this.Menutable.offsetLeft - this.Menutable.scrollLeft + this.Menutable.offsetWidth;
    let bottom = this.Menutable.offsetTop - this.Menutable.scrollTop + this.Menutable.offsetHeight;
    if (right > window.innerWidth)
      this.Menutable.style.left = Math.max(0, x - (right - window.innerWidth)).toString() + "px";
    if (bottom > window.innerHeight)
      this.Menutable.style.top = Math.max(0, y - (bottom - window.innerHeight)).toString() + "px";
    if (this._openCallback != null)
      this._openCallback(x, y);
    if (x <= 5 && y <= 5)
      this.focusFirst();
  }
};

// obj/full/ressources.js
var ressources = class _ressources {
  static SVGheader(size, shadowDef, title) {
    let res = '<svg  xmlns="http://www.w3.org/2000/svg" width="' + size + '" height="' + size + '" viewBox="0 0 128  128">';
    if (typeof title != "undefined")
      res = res + "<title>" + title + "</title>";
    if (shadowDef)
      res = res + '<defs><filter id="f1" x="0" y="0"><feGaussianBlur in="SourceGraphic" stdDeviation="2" /></filter></defs>';
    res = res + '<g transform="translate(0,128)"><g transform="scale(1,-1)">';
    return res;
  }
  static SVGFooter() {
    return "</g></g></svg>";
  }
  static addIconTransparency() {
    return '<g opacity="0.5">';
  }
  static addIconSrcCode() {
    return '<path d="m 8 24 L 8 40 L 24 40 L 24 56 L 40 56 L 40 40 L 56 40 L 56 24 L 40 24 L 40 8 L 24 8 L 24 24   Z" fill="#40ff40" stroke="black" stroke-width="8" stroke-linecap="round"/>';
  }
  static deleteIconSrcCode() {
    return '<path d="m 15 4 L 4 15 L 19 29 L 4 43 L 15 55 L 29 40 L 43 55 L 55 43 L 40 29 L 55 15 L 44 4 L 29 18 Z" fill="#ff4040" stroke="black" stroke-width="8" stroke-linecap="round">';
  }
  static IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, shadowcode, activeCode, title) {
    let res = _ressources.SVGheader(size, shadow, title);
    if (shadow)
      res = res + '<g transform="translate(6,-6)">' + shadowcode + "</g>";
    if (semitransparent)
      res = res + _ressources.addIconTransparency();
    res = res + activeCode;
    if (semitransparent)
      res = res + "</g>";
    if (addIcon)
      res = res + _ressources.addIconSrcCode();
    if (deleteIcon)
      res = res + _ressources.deleteIconSrcCode();
    res = res + _ressources.SVGFooter();
    return res;
  }
  static GraphIcon(size, shadow, semitransparent, addIcon, deleteIcon) {
    return _ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="m 12 24 L 103 24 L 103 107 L 12 107 z" fill="lightgray" filter="url(#f1)" /><path d="m 112 24 L 12 24 L 12 113"  style="fill:none; stroke:lightgray; stroke-width:4px; stroke-linejoin:round;stroke-linecap:round;" filter="url(#f1)"/>', '<path d="m 12 24 L 103 24 L 103 107 L 12 107 z" fill="#ffffe9" /><line x1="43" y1="24" x2="43" y2="107" stroke="#e3e3e3" stroke-width="2" stroke-linecap="round" /><line x1="43" y1="24" x2="43" y2="107" stroke="#e3e3e3" stroke-width="2" stroke-linecap="round" /><line x1="73" y1="24" x2="73" y2="107" stroke="#e3e3e3" stroke-width="2" stroke-linecap="round" /><line x1="12" y1="51" x2="103" y2="51" stroke="#e3e3e3" stroke-width="2" stroke-linecap="round" /><line x1="12" y1="79" x2="103" y2="79" stroke="#e3e3e3" stroke-width="2" stroke-linecap="round" /><line x1="12" y1="107" x2="103" y2="107" stroke="#e3e3e3" stroke-width="2" stroke-linecap="round" /><path d="m 12 77 L 34 65 L 55 85 L 70 77 L 100 93" fill="none" stroke="#FF0000" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" /><line x1="103" y1="24" x2="103" y2="107" stroke="#e3e3e3" stroke-width="2" stroke-linecap="round" /><path d="m 112 24 L 12 24 L 12 113"  style="fill:none; stroke:black; stroke-width:4px; stroke-linejoin:round;stroke-linecap:round;"/>');
  }
  static SolidGaugeIcon(size, shadow, semitransparent, addIcon, deleteIcon) {
    return _ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="M 34 40 L 14 40 14 52 A 50 50 0 0 0 114 52 L  114 40 L 94 40 L 94 52 A 30 30 0 1 1  34 52 Z" style="fill:lightgray;fill-opacity=0.4;" filter="url(#f1)"/><text x="43" y="-30" fill="black" transform="scale(1,-1)" style="font: bold 24px sans-serif;fill:lightgray;fill-opacity=0.4;" filter="url(#f1)">123</text>', '<path d="M 34 40 L 14 40 14 52 A 50 50 0 0 0 114 52 L  114 40 L 94 40 L 94 52 A 30 30 0 1 1  34 52 Z" style="fill:#ffffe9; stroke:none; "/><path d="M 34 40 L 14 40 14 52 A 50 50 0 0 0 29 88 L  43 72.5   A 30 30 0 0 1  34 52 Z" style="fill:red; stroke:none;"/><path d="M 34 40 L 14 40 14 52 A 50 50 0 0 0 114 52 L  114 40 L 94 40 L 94 52 A 30 30 0 1 1  34 52 Z" style="fill:none; stroke:black; stroke-width:4px; stroke-linejoin:round;stroke-linecap:round;"/><text x="43" y="-30" fill="black" transform="scale(1,-1)" style="font: bold 24px sans-serif;">123</text>');
  }
  static RawDataIcon(size, shadow, semitransparent, addIcon, deleteIcon) {
    return _ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="m 16 27 L 107 27 L 107 107 L 16 107 z" fill="lightgray" filter="url(#f1)" />', '<path d="m 16 27 L 107 27 L 107 107 L 16 107 z" style="fill:#ffffe9;" /><line x1="47" y1="27" x2="47" y2="107" stroke="#e3e3e3" stroke-width="2"  /><line x1="76" y1="27" x2="76" y2="107" stroke="#e3e3e3" stroke-width="2"  /><line x1="16" y1="44" x2="107" y2="44" stroke="#e3e3e3" stroke-width="2"  /><line x1="16" y1="60" x2="107" y2="60" stroke="#e3e3e3" stroke-width="2"  /><line x1="16" y1="76" x2="107" y2="76" stroke="#e3e3e3" stroke-width="2"  /><path d="m 16 27 L 107 27 L 107 107 L 16 107 z" style="fill:none;stroke:black; stroke-width:4px; stroke-linejoin:round;" /><path d="m 19 91 L 104 91 L 104 104 L 19 104 z" style="fill:#b2b2b2; stroke:#6f6f6f; stroke-width:4px; stroke-linejoin:round;" /><line x1="47" y1="91" x2="47" y2="104" stroke="#6f6f6f" stroke-width="2"  /><line x1="76" y1="91" x2="76" y2="104" stroke="#6f6f6f" stroke-width="2"  />');
  }
  static ConfigureIcon(size, shadow, semitransparent, addIcon, deleteIcon) {
    return _ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="M85 85 L 102 80 L 113 91 A  41 100 45 0 0  86 71 L 37 21 A  5 11 45 1 0  21 37 L 71 86  A  41 100 45 0 0  91 113 L 80 102 Z" style="fill:lightgray;fill-opacity=0.4;" filter="url(#f1)"/>', '<path d="M85 85 L 102 80 L 113 91 A  41 100 45 0 0  86 71 L 37 21 A  5 11 45 1 0  21 37 L 71 86  A  41 100 45 0 0  91 113 L 80 102 Z" style="fill:grey; stroke:black; stroke-width:4px; stroke-linejoin:round;stroke-linecap:round;"/>');
  }
  static DigitalDisplayIcon(size, shadow, semitransparent, addIcon, deleteIcon) {
    return _ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="m 12 45 L 111 45 L 111 89 L 12 89 z" fill="lightgray" filter="url(#f1)" />', '<path d="m 12 45 L 111 45 L 111 89 L 12 89 z" style="fill:#ffffe9; stroke:black; stroke-width:4px; stroke-linejoin:round;" /><text x="29" y="-52" fill="black" transform="scale(1,-1)" style="font: bold 40px sans-serif;">123</text> ');
  }
  static AngularGaugeIcon(size, shadow, semitransparent, addIcon, deleteIcon) {
    return _ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<circle  cx="64" cy="64" r="40" fill="lightgray" filter="url(#f1)" />', '<circle  cx="64" cy="64" r="40" stroke="black" stroke-width="4" fill="#ffffe9" /><line x1="64" y1="104" x2="64" y2="94" stroke="black" stroke-width="2"   stroke-linecap="round" /><line x1="29" y1="84" x2="38" y2="79" stroke="black" stroke-width="2"   stroke-linecap="round" /><line x1="29" y1="44" x2="38" y2="48" stroke="black" stroke-width="2"   stroke-linecap="round" /><line x1="98" y1="84" x2="91" y2="79" stroke="black" stroke-width="2"   stroke-linecap="round" /><line x1="98" y1="44" x2="91" y2="48" stroke="black" stroke-width="2"   stroke-linecap="round" /><g transform="translate(64,64)"><g transform="rotate(-70,0,0)"><path d="m 5 0 L 0 5 L -25 0 L 0 -5 z" style="fill:black;stroke:black; stroke-width:2px; stroke-linejoin:round;"/></g></g>');
  }
  static EditIcon(size, shadow, semitransparent, addIcon, deleteIcon) {
    return _ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="m 16 48 L 108 48 L 108 88 L 16 88 z" fill="lightgray" filter="url(#f1)" /><path d="m 87 24 L 75 40 L 67 31 L 62 64 L 93 50 L 82 44  L 94 29 z" fill="lightgray" filter="url(#f1)" />', '<path d="m 16 48 L 108 48 L 108 88 L 16 88 z" style="fill:#ffffe9; stroke:black; stroke-width:4px; stroke-linejoin:round;" /><path d="m 87 24 L 75 40 L 67 31 L 62 64 L 93 50 L 82 44  L 94 29 z" style="fill:white; stroke:black; stroke-width:2px; stroke-linejoin:round;" /> ');
  }
  static AllIcon(size, shadow, semitransparent, addIcon, deleteIcon) {
    return _ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="m 60 108 L 46 74 L 8 72 L 38 48 L 28 12 L 60 32 L 92 12  L 82 48 L 112 70  L 74 74  z" fill="lightgray" filter="url(#f1)" />', '<path d="m 60 108 L 46 74 L 8 72 L 38 48 L 28 12 L 60 32 L 92 12  L 82 48 L 112 70  L 74 74  z" style="fill:#fee403; stroke:#918201; stroke-width:4px; stroke-linejoin:round;" />');
  }
  static TrashIcon(size, shadow, semitransparent, addIcon, deleteIcon) {
    return _ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="m 33 12 L 24 94 L 104 94 L 95 12 z" fill="lightgray" filter="url(#f1)" /><g transform="translate(70,105)"><g transform="rotate(-10,0,0)"><path d="m -40 0 L -30 5 L 30 5 L 40 0 z" fill="lightgray" filter="url(#f1)" /><path d="m -9 5 L -9 12 L 9 12 L 9 5" stroke="lightgray" filter="url(#f1)"/> </g></g>', '<path d="m 33 12 L 24 94 L 104 94 L 95 12 z" style="fill:#f8f8f8; stroke:black; stroke-width:4px; stroke-linejoin:round;" /><Line x1="43" y1="82" x2="48" y2="21" style=" stroke:black; stroke-width:4px; stroke-linecap:round;" /><Line x1="64" y1="82" x2="64" y2="21" style=" stroke:black; stroke-width:4px; stroke-linecap:round;" /><Line x1="86" y1="82" x2="80" y2="21" style=" stroke:black; stroke-width:4px; stroke-linecap:round;" /><g transform="translate(70,105)"><g transform="rotate(-10,0,0)"><path d="m -40 0 L -30 5 L 30 5 L 40 0 z" style="fill:#f8f8f8; stroke:black; stroke-width:4px; stroke-linejoin:round;" /><path d="m -9 5 L -9 12 L 9 12 L 9 5" style="fill:none; stroke:black; stroke-width:4px; stroke-linejoin:round;" /></g></g>');
  }
  static SaveIcon(size, shadow, semitransparent, addIcon, deleteIcon) {
    return _ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="m 20 12 A 4 4 0 0 0 16 16 L 16 106  A 4 4 0 0 0 20 110 L 24 110 L 24 108 L 97 108 L 97 110 L 104 110  A 4 4 0 0 0 108 106 L 108 16   A 4 4 0 0 0 104 12  z" fill="lightgray" filter="url(#f1)" />', '<path d="m 20 12 A 4 4 0 0 0 16 16 L 16 106  A 4 4 0 0 0 20 110 L 24 110 L 24 108 L 97 108 L 97 110 L 104 110  A 4 4 0 0 0 108 106 L 108 16   A 4 4 0 0 0 104 12  z" style="fill:#3583dd; stroke:#226fc8; stroke-width:4px; stroke-linejoin:round;" /><path d="m 24 11 L 24 65  A 5 5 0 0 0 29 70 L 95 70  A 5 5 0 0 0 100 65 L 100 11  z" style="fill:#f7f7f7; stroke:#c6c6c6; stroke-width:2px; stroke-linejoin:round;"/><path d="m 36 111 L 90 111 L 90 80 A 4 4 0 0 0 86 76 L 40 76 A 4 4 0 0 0 36 80 z"  style="fill:#e5e5e5; stroke:#c6c6c6; stroke-width:2px; stroke-linejoin:round;" /><rect x="67" y="79" width="14" height ="28"     style="fill:#3583dd; stroke:#c6c6c6; stroke-width:2px; stroke-linejoin:round;"');
  }
  static SaveNeededIcon(size, shadow, semitransparent, addIcon, deleteIcon) {
    return _ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="m 8 16 L 64 110 L 120 16 z " style="fill:lightgray; stroke:lightgray; stroke-width:10px; stroke-linejoin:round;filter:url(#f1)" />', '<path d="m 8 16 L 64 110 L 120 16 z" style="fill:#FAE701; stroke:#FAE701; stroke-width:10px; stroke-linejoin:round;" /><path d="m 8 16 L 64 110 L 120 16 z" style="fill:none; stroke:black; stroke-width:2px; stroke-linejoin:round;" /><g transform="translate(-64,-64) scale(0.4 0.4) translate(260,215)"><path d="m 20 12 A 4 4 0 0 0 16 16 L 16 106  A 4 4 0 0 0 20 110 L 24 110 L 24 108 L 97 108 L 97 110 L 104 110  A 4 4 0 0 0 108 106 L 108 16   A 4 4 0 0 0 104 12  z" style="fill:black; stroke:black; stroke-width:4px; stroke-linejoin:round;" /><path d="m 24 11 L 24 65  A 5 5 0 0 0 29 70 L 95 70  A 5 5 0 0 0 100 65 L 100 11  z" style="fill:#FAE701; stroke:black; stroke-width:2px; stroke-linejoin:round;"/><path d="m 36 111 L 90 111 L 90 80 A 4 4 0 0 0 86 76 L 40 76 A 4 4 0 0 0 36 80 z"  style="fill:#FAE701; stroke:black; stroke-width:2px; stroke-linejoin:round;" /><rect x="67" y="79" width="14" height ="28"     style="fill:#FAE701; stroke:black; stroke-width:2px; stroke-linejoin:round;"</g>', "Don't forget to save.");
  }
  static snapshotIcon(size, shadow, semitransparent, addIcon, deleteIcon) {
    return _ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="m 16 32  L 16 78 A 6 6 0 0 0 22 84 L 46 84 L 48 94 A 5.75 3.25 30 0 0 54 100 L 78 100 A 3.25 5.75  30 0 0 84 94  L 86 84 L 104 84  A 6 6 0 0 0 110 78  L 110 32 A 6 6 0 0 0 104 26 L 22 26 A 6 6 0 0 0 16 32 z"  fill="lightgray" filter="url(#f1)" />', '<path d="m 16 32  L 16 78 A 6 6 0 0 0 22 84 L 46 84 L 48 94 A 5.75 3.25 30 0 0 54 100 L 78 100 A 3.25 5.75  30 0 0 84 94  L 86 84 L 104 84  A 6 6 0 0 0 110 78  L 110 32 A 6 6 0 0 0 104 26 L 22 26 A 6 6 0 0 0 16 32 z" style="fill:#707070; stroke:#464646; stroke-width:4px; stroke-linejoin:round;" /><Circle cx="65" cy="55" r="26"   style="fill:#895e96; stroke:#464646; stroke-width:6px; stroke-linejoin:round;" />');
  }
  static CloseIcon(size, shadow, semitransparent, addIcon, deleteIcon, title) {
    return _ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="m 21.6 38.6 L 47.1 64.3 L 22 89.5 L 38.4 106.2 L 64 81 L 89.3 106.2 L 105.8 89.5 L 80.6 64 L 105.8 38.9 L 89.3 22.2 L 64 47.5  L 38.3 22.1 z"  fill="lightgray" filter="url(#f1)" />', '<path d="m 21.6 38.6 L 47.1 64.3 L 22 89.5 L 38.4 106.2 L 64 81 L 89.3 106.2 L 105.8 89.5 L 80.6 64 L 105.8 38.9 L 89.3 22.2 L 64 47.5  L 38.3 22.1 z" style="fill:#ffffff; stroke:#004a82; stroke-width:4px; stroke-linejoin:round;" />', title);
  }
  static MoveToRightIcon(size, shadow, semitransparent, addIcon, deleteIcon, title) {
    return _ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<rect x="12" y="52" width="4"  height="24" fill="lightgray" filter="url(#f1)" /><rect x="20" y="52" width="8"  height="24" fill="lightgray" filter="url(#f1)" /><rect x="56" y="16" width="16"  height="96" fill="lightgray" filter="url(#f1)" /><path d="m  32 52 L 32 76 L 56 76 L 56 96 L 88 64 L 56 32 L 56 52 z" fill="lightgray" filter="url(#f1)" />', '<rect x="12" y="52" width="4"  height="24" style="fill:#ffffff; stroke:#004a82; stroke-width:4px; stroke-linejoin:round;" /><rect x="20" y="52" width="8"  height="24" style="fill:#ffffff; stroke:#004a82; stroke-width:4px; stroke-linejoin:round;" /><rect x="96" y="16" width="16"  height="96" style="fill:#ffffff; stroke:#004a82; stroke-width:4px; stroke-linejoin:round;" /><path d="m  32 52 L 32 76 L 56 76 L 56 96 L 88 64 L 56 32 L 56 52 z" style="fill:#ffffff; stroke:#004a82; stroke-width:4px; stroke-linejoin:round;" />', title);
  }
  static MoveToLeftIcon(size, shadow, semitransparent, addIcon, deleteIcon, title) {
    return _ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<rect x="112" y="52" width="4"  height="24" fill="lightgray" filter="url(#f1)" /><rect x="100" y="52" width="8"  height="24" fill="lightgray" filter="url(#f1)" /><rect x="16" y="16" width="16"  height="96" fill="lightgray" filter="url(#f1)" /><path d="m  96 52 L 96 76 L 72 76 L 72 96 L 40 64 L 72 32 L 72 52 z" fill="lightgray" filter="url(#f1)" />', '<rect x="112" y="52" width="4"  height="24" style="fill:#ffffff; stroke:#004a82; stroke-width:4px; stroke-linejoin:round;" /><rect x="100" y="52" width="8"  height="24" style="fill:#ffffff; stroke:#004a82; stroke-width:4px; stroke-linejoin:round;" /><rect x="16" y="16" width="16"  height="96" style="fill:#ffffff; stroke:#004a82; stroke-width:4px; stroke-linejoin:round;" /><path d="m  96 52 L 96 76 L 72 76 L 72 96 L 40 64 L 72 32 L 72 52 z" style="fill:#ffffff; stroke:#004a82; stroke-width:4px; stroke-linejoin:round;" />', title);
  }
  static ExpandIcon(size, shadow, semitransparent, addIcon, deleteIcon, title) {
    return _ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="m  24 56 L 24 72 L 56 72 L 56 104 L 72 104 L 72 72 L 104 72 L 104 56 L 72 56 L 72 24 L 56 24 L 56 56 z"  fill="lightgray" filter="url(#f1)" />', '<path d="m 24 56 L 24 72 L 56 72 L 56 104 L 72 104 L 72 72 L 104 72 L 104 56 L 72 56 L 72 24 L 56 24 L 56 56  z" style="fill:black; " />', title);
  }
  static OkIcon(size, shadow, semitransparent, addIcon, deleteIcon, title) {
    return _ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<circle cx="64" cy="64" r="56"   fill="lightgray" filter="url(#f1)" />', '<circle cx="64" cy="64" r="56" fill="#00b20f"/><path d="m 19 72 L 34 87 L 60 62 L 94 96 L 109 81 L 60 32  z" style="fill:white; " />', title);
  }
  static FailedIcon(size, shadow, semitransparent, addIcon, deleteIcon, title) {
    return _ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<circle cx="64" cy="64" r="56"   fill="lightgray" filter="url(#f1)" />', '<circle cx="64" cy="64" r="56" fill="#ff101e"/><path d="m 43 99 L 64 79 L 85 99 L 100 85 L 79 64 L 100 43 L 85 28 L 64 49 L 43 28 L 28  43 L 49 64 L  28 85   z" style="fill:white; " />', title);
  }
  static DontKnowIcon(size, shadow, semitransparent, addIcon, deleteIcon, title) {
    return _ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<circle cx="64" cy="64" r="56"   fill="lightgray" filter="url(#f1)" />', '<circle cx="64" cy="64" r="56" fill="#f1ba00"/><text x="35" y="-30" fill="white" transform="scale(1,-1)" style="font: bold 96px sans-serif;">?</text> ', title);
  }
  static infoIcon(size, shadow, semitransparent, addIcon, deleteIcon, title) {
    return _ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<circle cx="64" cy="64" r="56"   fill="lightgray" filter="url(#f1)" />', '<circle cx="64" cy="64" r="56" fill="DodgerBlue"/><text x="50" y="-30" fill="white" transform="scale(1,-1)" style="font: bold 96px sans-serif;">i</text> ', title);
  }
  static ColapseIcon(size, shadow, semitransparent, addIcon, deleteIcon, title) {
    return _ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="m 24 56 L 24 72 L 104 72 L 104 56 z"  fill="lightgray" filter="url(#f1)" />', '<path d="m 24 56 L 24 72 L 104 72 L 104 56 z" style="fill:black; " />', title);
  }
  static AddMarkerIcon(size, index) {
    return _ressources.IconSourceCode(size, false, false, false, false, "", '<circle  cx="64" cy="64"  r="50"   style="fill:lightyellow;" stroke-width="8" stroke="darkred" /><text x="46" y="-40" fill="black" transform="scale(1,-1)" style="font: bold 64px sans-serif;">' + index.toString() + "</text>");
  }
  static AddMarker(size, shadow, semitransparent, addIcon, deleteIcon) {
    return _ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, "", '<line x1="80" y1="8" x2="80" y2="128" stroke="darkred" stroke-width="8" stroke-linecap="round" /><path d="m 60 64 L 100 64 L 80 20 z" style="fill:darkred; " /><rect x="40" y="56" width="80" height="32" style="fill:lightYellow" stroke="darkred" stroke-width="8" />');
  }
  static EraseDatalogger(size, shadow, semitransparent, addIcon, deleteIcon) {
    return _ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, "", '<g transform="rotate(-35,0,0)"><g transform="translate(-56,24)"><path d="m 108 24 L 108 46 L 60 46  A 22 22 0 1 0 60 90 L 108 90  L 108 112 L 60 112 A 44 44 0 1 1 60 24 z" style="fill:#808080; " /><rect x="88" y="24" width="20" height="22" style="fill:red" stroke="none"  /><rect x="88" y="90" width="20" height="22" style="fill:blue" stroke="none"  /><path d="m 108 24 L 108 46 L 60 46  A 22 22 0 1 0 60 90 L 108 90  L 108 112 L 60 112 A 44 44 0 1 1 60 24 z"  style="fill:none" stroke="black"  stroke-width="4" stroke-linejoin="round"/></g></g>');
  }
  static resetViewPort(size, shadow, semitransparent, addIcon, deleteIcon) {
    return _ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, "", '<line x1="116" y1="52" x2="116" y2="12"  stroke="black"  stroke-width="4"/><line x1="12" y1="52" x2="12" y2="12"  stroke="black"  stroke-width="4"/><path d="m 100 36 L 28 36 L 28 48 L 12 32  L 28 16 L 28 28 L 100 28 L 100 16 L 116 32 L 100 48z" style="fill:white" stroke="black"  stroke-width="4" stroke-linejoin="round" /><path d="m 7.3 97.7 L 20 107.4 L 51.6 114.7 L 78.5 112.2 L 101.6 103.3 L 114.4 91.7  L 117.7 81.7 L 104.3 66.9 L 80.9 61.2 L49.9 65 L 25 76.3 L 12.6 87.5 Z " style="fill:white" stroke="none" /><circle  cx="64" cy="88" r="27" style="fill:#6cc87b" stroke="none"  /> <path d="m 37.2 84.8 A 27 27 0 0 0 46.5 108.8 L 64 88 z" style="fill:#8ed698" stroke="none" /> <circle  cx="64" cy="88" r="16" style="fill:black" stroke="none"  /> <path d="m 6 97 A 59 34 -4 0 0 119 80" style="fill:none" stroke="black"  stroke-width="4"  stroke-linecap="round"/> <path d="m 113 79 A 56 31 -16 0 0 9 93 " style="fill:none" stroke="black"  stroke-width="4"  stroke-linecap="round" /> ');
  }
  static DeleteMarker(size, shadow, semitransparent, addIcon, deleteIcon) {
    return _ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, "", '<line x1="80" y1="8" x2="80" y2="128" stroke="darkred" stroke-width="8" stroke-linecap="round" /><path d="m 60 64 L 100 64 L 80 20 z" style="fill:darkred; " /><rect x="40" y="56" width="80" height="32" style="fill:lightYellow" stroke="darkred" stroke-width="8" />');
  }
  static targetIcon(size, shadow, semitransparent, addIcon, deleteIcon, title) {
    return _ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, "", '<circle  cx="64" cy="64"  r="42"   style="fill:none;" stroke-width="8" stroke="black" /><line  x1="0"   y1="64"  x2="42"  y2="64"  style="fill:none;" stroke-width="8" stroke="black" /><line  x1="128" y1="64"  x2="86"  y2="64"  style="fill:none;" stroke-width="8" stroke="black" /><line  y1="0"   x1="64"  y2="42"  x2="64"  style="fill:none;" stroke-width="8" stroke="black" /><line  y1="128" x1="64"  y2="86"  x2="64"  style="fill:none;" stroke-width="8" stroke="black" />', title);
  }
  static DotDotDotIcon(size, shadow, semitransparent, addIcon, deleteIcon, title) {
    return _ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, "", '<rect x="18" y="36" width="18" height="18" style="fill:black" /><rect x="54" y="36" width="18" height="18" style="fill:black" /><rect x="90" y="36" width="18" height="18" style="fill:black" />', title);
  }
  static LogFileIcon(size, shadow, semitransparent, addIcon, deleteIcon) {
    return _ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, "", '<line x1="4" y1="24" x2="30" y2="24"     style=" stroke:black; stroke-width:8px;" /><line x1="34" y1="24" x2="56" y2="24"    style=" stroke:black; stroke-width:8px; " /><line x1="64" y1="24" x2="74" y2="24"    style=" stroke:black; stroke-width:8px; " /><line x1="80" y1="24" x2="88" y2="24"    style=" stroke:black; stroke-width:8px; " /><line x1="4" y1="40" x2="30" y2="40"     style=" stroke:black; stroke-width:8px;" /><line x1="34" y1="40" x2="56" y2="40"    style=" stroke:black; stroke-width:8px; " /><line x1="61" y1="40" x2="90" y2="40"    style=" stroke:black; stroke-width:8px; " /><line x1="94" y1="40" x2="110" y2="40"    style=" stroke:black; stroke-width:8px; " /><line x1="4" y1="56" x2="30" y2="56"     style=" stroke:black; stroke-width:8px;" /><line x1="34" y1="56" x2="56" y2="56"    style=" stroke:black; stroke-width:8px; " /><line x1="61" y1="56" x2="86" y2="56"    style=" stroke:black; stroke-width:8px; " /><line x1="4" y1="72" x2="30" y2="72"     style=" stroke:black; stroke-width:8px;" /><line x1="34" y1="72" x2="50" y2="72"    style=" stroke:black; stroke-width:8px; " /><line x1="56" y1="72" x2="100" y2="72"    style=" stroke:black; stroke-width:8px; " /><line x1="4" y1="88" x2="30" y2="88"     style=" stroke:black; stroke-width:8px;" /><line x1="34" y1="88" x2="56" y2="88"    style=" stroke:black; stroke-width:8px; " /><line x1="61" y1="88" x2="72" y2="88"    style=" stroke:black; stroke-width:8px; " /><line x1="78" y1="88" x2="106" y2="88"    style=" stroke:black; stroke-width:8px; " />');
  }
};

// obj/full/Pako/utils/common.js
var utils_common = class {
  // This was orignaly used to manipulate deflate/inflate options
  // stored in anonymous structures
  // Yoctopuce replaced it with a proper options object with name
  // setting names and types check (see Pako_inflate_option and
  // Pako_deflate_option)
  //  public static assign  (obj : any, /*from1, from2, from3, ...*/)
  //    {
  //      const sources : any[] = Array.prototype.slice.call(arguments, 1);
  //      while (sources.length) {
  //     const source = sources.shift();
  //       if (!source) { continue; }
  //
  //       if (typeof source !== 'object') {
  //        throw new TypeError(source + 'must be non-object');
  //      }
  //
  //
  //    for (const p : string in source) {
  //      if (p.hasOwnProperty (source)) {
  //        obj[p] = source[p];
  //      }
  //    }
  //  }
  //
  //  return obj;
  //};
  // Join array of chunks to single array.
  static flattenChunks(chunks) {
    let len = 0;
    for (let i = 0, l = chunks.length; i < l; i++) {
      len += chunks[i].length;
    }
    const result = new Uint8Array(len);
    for (let i = 0, pos = 0, l = chunks.length; i < l; i++) {
      let chunk = chunks[i];
      result.set(chunk, pos);
      pos += chunk.length;
    }
    return result;
  }
};

// obj/full/Pako/utils/strings.js
var Pako_strings = class _Pako_strings {
  static _init() {
    try {
      String.fromCharCode.apply(null, new Uint8Array(1));
    } catch (__) {
      _Pako_strings.STR_APPLY_UIA_OK = false;
    }
    for (let q = 0; q < 256; q++) {
      _Pako_strings._utf8len[q] = q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1;
    }
    _Pako_strings._utf8len[254] = _Pako_strings._utf8len[254] = 1;
    return true;
  }
  // convert string to array (typed, when possible)
  static string2buf(str) {
    let buf;
    let c;
    let c2;
    let m_pos;
    let i;
    let str_len = str.length;
    let buf_len = 0;
    for (m_pos = 0; m_pos < str_len; m_pos++) {
      c = str.charCodeAt(m_pos);
      if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
        c2 = str.charCodeAt(m_pos + 1);
        if ((c2 & 64512) === 56320) {
          c = 65536 + (c - 55296 << 10) + (c2 - 56320);
          m_pos++;
        }
      }
      buf_len += c < 128 ? 1 : c < 2048 ? 2 : c < 65536 ? 3 : 4;
    }
    buf = new Uint8Array(buf_len);
    for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
      c = str.charCodeAt(m_pos);
      if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
        c2 = str.charCodeAt(m_pos + 1);
        if ((c2 & 64512) === 56320) {
          c = 65536 + (c - 55296 << 10) + (c2 - 56320);
          m_pos++;
        }
      }
      if (c < 128) {
        buf[i++] = c;
      } else if (c < 2048) {
        buf[i++] = 192 | c >>> 6;
        buf[i++] = 128 | c & 63;
      } else if (c < 65536) {
        buf[i++] = 224 | c >>> 12;
        buf[i++] = 128 | c >>> 6 & 63;
        buf[i++] = 128 | c & 63;
      } else {
        buf[i++] = 240 | c >>> 18;
        buf[i++] = 128 | c >>> 12 & 63;
        buf[i++] = 128 | c >>> 6 & 63;
        buf[i++] = 128 | c & 63;
      }
    }
    return buf;
  }
  // Helper
  static buf2binstring(buf, len) {
    let result = "";
    for (let i = 0; i < len; i++) {
      result += String.fromCharCode(buf[i]);
    }
    return result;
  }
  // convert array to string
  static buf2string(buf, max) {
    let i;
    let out;
    const len = max || buf.length;
    const utf16buf = new Array(len * 2);
    for (out = 0, i = 0; i < len; ) {
      let c = buf[i++];
      if (c < 128) {
        utf16buf[out++] = c;
        continue;
      }
      let c_len = _Pako_strings._utf8len[c];
      if (c_len > 4) {
        utf16buf[out++] = 65533;
        i += c_len - 1;
        continue;
      }
      c &= c_len === 2 ? 31 : c_len === 3 ? 15 : 7;
      while (c_len > 1 && i < len) {
        c = c << 6 | buf[i++] & 63;
        c_len--;
      }
      if (c_len > 1) {
        utf16buf[out++] = 65533;
        continue;
      }
      if (c < 65536) {
        utf16buf[out++] = c;
      } else {
        c -= 65536;
        utf16buf[out++] = 55296 | c >> 10 & 1023;
        utf16buf[out++] = 56320 | c & 1023;
      }
    }
    return _Pako_strings.buf2binstring(utf16buf, out);
  }
  // Calculate max possible position in utf8 buffer,
  // that will not break sequence. If that's not possible
  // - (very small limits) return max size as is.
  //
  // buf[] - utf8 bytes array
  // max   - length limit (mandatory);
  static utf8border(buf, max) {
    max = max || buf.length;
    if (max > buf.length) {
      max = buf.length;
    }
    let pos = max - 1;
    while (pos >= 0 && (buf[pos] & 192) === 128) {
      pos--;
    }
    if (pos < 0) {
      return max;
    }
    if (pos === 0) {
      return max;
    }
    return pos + _Pako_strings._utf8len[buf[pos]] > max ? pos : max;
  }
};
Pako_strings.STR_APPLY_UIA_OK = true;
Pako_strings._utf8len = new Uint8Array(256);
Pako_strings.initDone = Pako_strings._init();

// obj/full/Pako/deflate.js
var Pako_deflate_option = class _Pako_deflate_option {
  constructor(CustOption) {
    this.level = zlib_constants.Z_DEFAULT_COMPRESSION;
    this.method = zlib_constants.Z_DEFLATED;
    this.chunkSize = 16384;
    this.windowBits = 15;
    this.memLevel = 8;
    this.strategy = zlib_constants.Z_DEFAULT_STRATEGY;
    this.raw = false;
    this.gzip = false;
    this.header = null;
    this.dictionary = null;
    this.ignore_os = false;
    _Pako_deflate_option.ApplyCustomOptions(this, CustOption);
  }
  static ApplyCustomOptions(StdOption, CustOption) {
    if (typeof CustOption != "undefined") {
      let stdKeys = Object.keys(StdOption);
      let custKeys = Object.keys(CustOption);
      for (let i = 0; i < custKeys.length; i++) {
        if (stdKeys.indexOf(custKeys[i]) < 0) {
          debugger;
          throw "Invalid Pako option name '" + custKeys[i] + "', check Pako_deflate_option class";
        }
        let srcType = typeof Reflect.get(CustOption, custKeys[i]);
        let trgtType = typeof Reflect.get(StdOption, custKeys[i]);
        if (srcType != trgtType)
          throw "Invalid Pako type for option '" + custKeys[i] + "' (expected '" + trgtType + "', got '" + srcType + "')";
        Reflect.set(StdOption, custKeys[i], Reflect.get(CustOption, custKeys[i]));
      }
    }
  }
};
var Pako_Deflate = class _Pako_Deflate {
  constructor(options) {
    this._dict_set = false;
    this.result = null;
    this.options = new Pako_deflate_option(options);
    let opt = this.options;
    if (opt.raw && opt.windowBits > 0) {
      opt.windowBits = -opt.windowBits;
    } else if (opt.gzip && opt.windowBits > 0 && opt.windowBits < 16) {
      opt.windowBits += 16;
    }
    this.err = 0;
    this.msg = "";
    this.ended = false;
    this.chunks = [];
    this.strm = new zlib_ZStream();
    this.strm.avail_out = 0;
    let status = zlib_deflate.deflateInit2(this.strm, opt.level, opt.method, opt.windowBits, opt.memLevel, opt.strategy);
    if (status !== zlib_constants.Z_OK) {
      throw new Error(zlib_messages.msg(status));
    }
    if (opt.header) {
      zlib_deflate.deflateSetHeader(this.strm, opt.header);
    }
    if (opt.dictionary) {
      let dict;
      if (typeof opt.dictionary === "string") {
        dict = Pako_strings.string2buf(opt.dictionary);
      } else if (toString.call(opt.dictionary) === "[object ArrayBuffer]") {
        dict = new Uint8Array(opt.dictionary);
      } else {
        dict = opt.dictionary;
      }
      status = zlib_deflate.deflateSetDictionary(this.strm, dict);
      if (status !== zlib_constants.Z_OK) {
        throw new Error(zlib_messages.msg(status));
      }
      this._dict_set = true;
    }
  }
  /**
   * Deflate#push(data[, flush_mode]) -> Boolean
   * - data (Uint8Array|ArrayBuffer|String): input data. Strings will be
   *   converted to utf8 byte sequence.
   * - flush_mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.
   *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` means Z_FINISH.
   *
   * Sends input data to deflate pipe, generating [[Deflate#onData]] calls with
   * new compressed chunks. Returns `true` on success. The last data block must
   * have `flush_mode` Z_FINISH (or `true`). That will flush internal pending
   * buffers and call [[Deflate#onEnd]].
   *
   * On fail call [[Deflate#onEnd]] with error code and return false.
   *
   * ##### Example
   *
   * ```javascript
   * push(chunk, false); // push one of data chunks
   * ...
   * push(chunk, true);  // push last chunk
   * ```
   **/
  push(data, flush_mode) {
    const strm = this.strm;
    const chunkSize = this.options.chunkSize;
    let status;
    let _flush_mode;
    if (this.ended) {
      return false;
    }
    if (flush_mode === ~~flush_mode) {
      _flush_mode = flush_mode;
    } else {
      _flush_mode = flush_mode === true ? zlib_constants.Z_FINISH : zlib_constants.Z_NO_FLUSH;
    }
    if (typeof data === "string") {
      strm.input = Pako_strings.string2buf(data);
    } else if (toString.call(data) === "[object ArrayBuffer]") {
      strm.input = new Uint8Array(data);
    } else {
      strm.input = data;
    }
    strm.next_in = 0;
    strm.avail_in = strm.input.length;
    for (; ; ) {
      if (strm.avail_out === 0) {
        strm.output = new Uint8Array(chunkSize);
        strm.next_out = 0;
        strm.avail_out = chunkSize;
      }
      if ((_flush_mode === zlib_constants.Z_SYNC_FLUSH || _flush_mode === zlib_constants.Z_FULL_FLUSH) && strm.avail_out <= 6) {
        this.onData(strm.output.subarray(0, strm.next_out));
        strm.avail_out = 0;
        continue;
      }
      status = zlib_deflate.deflate(strm, _flush_mode);
      if (status === zlib_constants.Z_STREAM_END) {
        if (strm.next_out > 0) {
          this.onData(strm.output.subarray(0, strm.next_out));
        }
        status = zlib_deflate.deflateEnd(this.strm);
        this.onEnd(status);
        this.ended = true;
        return status === zlib_constants.Z_OK;
      }
      if (strm.avail_out === 0) {
        this.onData(strm.output);
        continue;
      }
      if (_flush_mode > 0 && strm.next_out > 0) {
        this.onData(strm.output.subarray(0, strm.next_out));
        strm.avail_out = 0;
        continue;
      }
      if (strm.avail_in === 0)
        break;
    }
    return true;
  }
  /**
   * Deflate#onData(chunk) -> Void
   * - chunk (Uint8Array): output data.
   *
   * By default, stores data blocks in `chunks[]` property and glue
   * those in `onEnd`. Override this handler, if you need another behaviour.
   **/
  onData(chunk) {
    this.chunks.push(chunk);
  }
  /**
   * Deflate#onEnd(status) -> Void
   * - status (Number): deflate status. 0 (Z_OK) on success,
   *   other if not.
   *
   * Called once after you tell deflate that the input stream is
   * complete (Z_FINISH). By default - join collected chunks,
   * free memory and fill `results` / `err` properties.
   **/
  onEnd(status) {
    if (status === zlib_constants.Z_OK) {
      this.result = utils_common.flattenChunks(this.chunks);
    }
    this.chunks = [];
    this.err = status;
    this.msg = this.strm.msg;
  }
  /**
   * deflate(data[, options]) -> Uint8Array
   * - data (Uint8Array|String): input data to compress.
   * - options (Object): zlib deflate options.
   *
   * Compress `data` with deflate algorithm and `options`.
   *
   * Supported options are:
   *
   * - level
   * - windowBits
   * - memLevel
   * - strategy
   * - dictionary
   *
   * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
   * for more information on these.
   *
   * Sugar (options):
   *
   * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify
   *   negative windowBits implicitly.
   *
   * ##### Example:
   *
   * ```javascript
   * const pako = require('pako')
   * const data = new Uint8Array([1,2,3,4,5,6,7,8,9]);
   *
   * console.log(pako.deflate(data));
   * ```
   **/
  static deflate(input, options) {
    const deflator = new _Pako_Deflate(options);
    deflator.push(input, true);
    if (deflator.err) {
      throw deflator.msg || zlib_messages.msg(deflator.err);
    }
    return deflator.result;
  }
  /**
   * deflateRaw(data[, options]) -> Uint8Array
   * - data (Uint8Array|String): input data to compress.
   * - options (Object): zlib deflate options.
   *
   * The same as [[deflate]], but creates raw data, without wrapper
   * (header and adler32 crc).
   **/
  static deflateRaw(input, options) {
    options.raw = true;
    return _Pako_Deflate.deflate(input, options);
  }
  /**
   * gzip(data[, options]) -> Uint8Array
   * - data (Uint8Array|String): input data to compress.
   * - options (Object): zlib deflate options.
   *
   * The same as [[deflate]], but create gzip wrapper instead of
   * deflate one.
   **/
  static gzip(input, options) {
    if (typeof options == "undefined")
      options = {};
    options.gzip = true;
    return _Pako_Deflate.deflate(input, options);
  }
};

// obj/full/Pako/inflate.js
var Pako_inflate_option = class _Pako_inflate_option {
  constructor(CustOption) {
    this.chunkSize = 1024 * 64;
    this.windowBits = 15;
    this.to = "";
    this.raw = false;
    this.dictionary = null;
    _Pako_inflate_option.ApplyCustomOptions(this, CustOption);
  }
  static ApplyCustomOptions(StdOption, CustOption) {
    if (typeof CustOption != "undefined") {
      let stdKeys = Object.keys(StdOption);
      let custKeys = Object.keys(CustOption);
      for (let i = 0; i < custKeys.length; i++) {
        if (stdKeys.indexOf(custKeys[i]) < 0)
          throw "Invalid Pako option name '" + custKeys[i] + "', check Pako_inflate_option class";
        let srcType = typeof Reflect.get(CustOption, custKeys[i]);
        let trgtType = typeof Reflect.get(StdOption, custKeys[i]);
        if (srcType != trgtType) {
          throw "Invalid Pako type for option '" + custKeys[i] + "' (expected '" + trgtType + "', got '" + srcType + "')";
        }
        Reflect.set(StdOption, custKeys[i], Reflect.get(CustOption, custKeys[i]));
      }
    }
  }
};
var Pako_Inflate = class _Pako_Inflate {
  constructor(options) {
    this.err = 0;
    this.msg = "";
    this.ended = false;
    this.result = null;
    this.options = new Pako_inflate_option(options);
    const opt = this.options;
    if (opt.raw && opt.windowBits >= 0 && opt.windowBits < 16) {
      opt.windowBits = -opt.windowBits;
      if (opt.windowBits === 0) {
        opt.windowBits = -15;
      }
    }
    if (opt.windowBits >= 0 && opt.windowBits < 16 && !(options && options.windowBits)) {
      opt.windowBits += 32;
    }
    if (opt.windowBits > 15 && opt.windowBits < 48) {
      if ((opt.windowBits & 15) === 0) {
        opt.windowBits |= 15;
      }
    }
    this.err = 0;
    this.msg = "";
    this.ended = false;
    this.chunks = [];
    this.strm = new zlib_ZStream();
    this.strm.avail_out = 0;
    let status = zlib_inflate.inflateInit2(this.strm, opt.windowBits);
    if (status !== zlib_constants.Z_OK) {
      throw new Error(zlib_messages.msg(status));
    }
    this.header = new zlib_GZheader();
    zlib_inflate.inflateGetHeader(this.strm, this.header);
    if (opt.dictionary) {
      if (typeof opt.dictionary === "string") {
        opt.dictionary = Pako_strings.string2buf(opt.dictionary);
      } else if (toString.call(opt.dictionary) === "[object ArrayBuffer]") {
        opt.dictionary = new Uint8Array(opt.dictionary);
      }
      if (opt.raw) {
        status = zlib_inflate.inflateSetDictionary(this.strm, opt.dictionary);
        if (status !== zlib_constants.Z_OK) {
          throw new Error(zlib_messages.msg(status));
        }
      }
    }
  }
  /**
   * Inflate#push(data[, flush_mode]) -> Boolean
   * - data (Uint8Array|ArrayBuffer): input data
   * - flush_mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE
   *   flush modes. See constants. Skipped or `false` means Z_NO_FLUSH,
   *   `true` means Z_FINISH.
   *
   * Sends input data to inflate pipe, generating [[Inflate#onData]] calls with
   * new output chunks. Returns `true` on success. If end of stream detected,
   * [[Inflate#onEnd]] will be called.
   *
   * `flush_mode` is not needed for normal operation, because end of stream
   * detected automatically. You may try to use it for advanced things, but
   * this functionality was not tested.
   *
   * On fail call [[Inflate#onEnd]] with error code and return false.
   *
   * ##### Example
   *
   * ```javascript
   * push(chunk, false); // push one of data chunks
   * ...
   * push(chunk, true);  // push last chunk
   * ```
   **/
  push(data, flush_mode) {
    const strm = this.strm;
    const chunkSize = this.options.chunkSize;
    const dictionary = this.options.dictionary;
    let status;
    let _flush_mode;
    let last_avail_out;
    if (this.ended)
      return false;
    if (flush_mode === ~~flush_mode) {
      _flush_mode = flush_mode;
    } else {
      _flush_mode = flush_mode === true ? zlib_constants.Z_FINISH : zlib_constants.Z_NO_FLUSH;
    }
    if (toString.call(data) === "[object ArrayBuffer]") {
      strm.input = new Uint8Array(data);
    } else {
      strm.input = data;
    }
    strm.next_in = 0;
    strm.avail_in = strm.input.length;
    for (; ; ) {
      if (strm.avail_out === 0) {
        strm.output = new Uint8Array(chunkSize);
        strm.next_out = 0;
        strm.avail_out = chunkSize;
      }
      status = zlib_inflate.inflate(strm, _flush_mode);
      if (status === zlib_constants.Z_NEED_DICT && dictionary) {
        status = zlib_inflate.inflateSetDictionary(strm, dictionary);
        if (status === zlib_constants.Z_OK) {
          status = zlib_inflate.inflate(strm, _flush_mode);
        } else if (status === zlib_constants.Z_DATA_ERROR) {
          status = zlib_constants.Z_NEED_DICT;
        }
      }
      while (strm.avail_in > 0 && status === zlib_constants.Z_STREAM_END && strm.state.wrap > 0 && data[strm.next_in] !== 0) {
        zlib_inflate.inflateReset(strm);
        status = zlib_inflate.inflate(strm, _flush_mode);
      }
      switch (status) {
        case zlib_constants.Z_STREAM_ERROR:
        case zlib_constants.Z_DATA_ERROR:
        case zlib_constants.Z_NEED_DICT:
        case zlib_constants.Z_MEM_ERROR:
          this.onEnd(status);
          this.ended = true;
          return false;
      }
      last_avail_out = strm.avail_out;
      if (strm.next_out) {
        if (strm.avail_out === 0 || status === zlib_constants.Z_STREAM_END) {
          if (this.options.to === "string") {
            let next_out_utf8 = Pako_strings.utf8border(strm.output, strm.next_out);
            let tail = strm.next_out - next_out_utf8;
            let utf8str = Pako_strings.buf2string(strm.output, next_out_utf8);
            strm.next_out = tail;
            strm.avail_out = chunkSize - tail;
            if (tail)
              strm.output.set(strm.output.subarray(next_out_utf8, next_out_utf8 + tail), 0);
            this.onData(utf8str);
          } else {
            this.onData(strm.output.length === strm.next_out ? strm.output : strm.output.subarray(0, strm.next_out));
          }
        }
      }
      if (status === zlib_constants.Z_OK && last_avail_out === 0)
        continue;
      if (status === zlib_constants.Z_STREAM_END) {
        status = zlib_inflate.inflateEnd(this.strm);
        this.onEnd(status);
        this.ended = true;
        return true;
      }
      if (strm.avail_in === 0)
        break;
    }
    return true;
  }
  /**
   * Inflate#onData(chunk) -> Void
   * - chunk (Uint8Array|String): output data. When string output requested,
   *   each chunk will be string.
   *
   * By default, stores data blocks in `chunks[]` property and glue
   * those in `onEnd`. Override this handler, if you need another behaviour.
   **/
  onData(chunk) {
    this.chunks[this.chunks.length] = chunk;
  }
  /**
   * Inflate#onEnd(status) -> Void
   * - status (Number): inflate status. 0 (Z_OK) on success,
   *   other if not.
   *
   * Called either after you tell inflate that the input stream is
   * complete (Z_FINISH). By default - join collected chunks,
   * free memory and fill `results` / `err` properties.
   **/
  onEnd(status) {
    if (status === zlib_constants.Z_OK) {
      if (this.options.to === "string") {
        this.result = this.chunks.join("");
      } else {
        this.result = utils_common.flattenChunks(this.chunks);
      }
    }
    this.chunks = [];
    this.err = status;
    this.msg = this.strm.msg;
  }
  /**
   * inflate(data[, options]) -> Uint8Array|String
   * - data (Uint8Array): input data to decompress.
   * - options (Object): zlib inflate options.
   *
   * Decompress `data` with inflate/ungzip and `options`. Autodetect
   * format via wrapper header by default. That's why we don't provide
   * separate `ungzip` method.
   *
   * Supported options are:
   *
   * - windowBits
   *
   * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
   * for more information.
   *
   * Sugar (options):
   *
   * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify
   *   negative windowBits implicitly.
   * - `to` (String) - if equal to 'string', then result will be converted
   *   from utf8 to utf16 (javascript) string. When string output requested,
   *   chunk length can differ from `chunkSize`, depending on content.
   *
   *
   * ##### Example:
   *
   * ```javascript
   * const pako = require('pako');
   * const input = pako.deflate(new Uint8Array([1,2,3,4,5,6,7,8,9]));
   * let output;
   *
   * try {
   *   output = pako.inflate(input);
   * } catch (err)
   *   console.log(err);
   * }
   * ```
   **/
  static inflate(input, options) {
    const inflator = new _Pako_Inflate(options);
    inflator.push(input, false);
    if (inflator.err)
      throw inflator.msg || zlib_messages.msg(inflator.err);
    return inflator.result;
  }
  /**
   * inflateRaw(data[, options]) -> Uint8Array|String
   * - data (Uint8Array): input data to decompress.
   * - options (Object): zlib inflate options.
   *
   * The same as [[inflate]], but creates raw data, without wrapper
   * (header and adler32 crc).
   **/
  inflateRaw(input, options) {
    options.raw = true;
    return _Pako_Inflate.inflate(input, options);
  }
  /**
   * ungzip(data[, options]) -> Uint8Array|String
   * - data (Uint8Array): input data to decompress.
   * - options (Object): zlib inflate options.
   *
   * Just shortcut to [[inflate]], because it autodetects format
   * by header.content. Done for convenience.
   **/
  static ungzip(input, options) {
    return _Pako_Inflate.inflate(input, options);
  }
};

// obj/full/Pako/zlib/adler32.js
var zlib_adler32 = class {
  static adler32(adler, buf, len, pos) {
    let s1 = adler & 65535 | 0, s2 = adler >>> 16 & 65535 | 0, n = 0;
    while (len !== 0) {
      n = len > 2e3 ? 2e3 : len;
      len -= n;
      do {
        s1 = s1 + buf[pos++] | 0;
        s2 = s2 + s1 | 0;
      } while (--n);
      s1 %= 65521;
      s2 %= 65521;
    }
    return s1 | s2 << 16 | 0;
  }
};

// obj/full/Pako/zlib/constants.js
var zlib_constants = class {
};
zlib_constants.Z_NO_FLUSH = 0;
zlib_constants.Z_PARTIAL_FLUSH = 1;
zlib_constants.Z_SYNC_FLUSH = 2;
zlib_constants.Z_FULL_FLUSH = 3;
zlib_constants.Z_FINISH = 4;
zlib_constants.Z_BLOCK = 5;
zlib_constants.Z_TREES = 6;
zlib_constants.Z_OK = 0;
zlib_constants.Z_STREAM_END = 1;
zlib_constants.Z_NEED_DICT = 2;
zlib_constants.Z_ERRNO = -1;
zlib_constants.Z_STREAM_ERROR = -2;
zlib_constants.Z_DATA_ERROR = -3;
zlib_constants.Z_MEM_ERROR = -4;
zlib_constants.Z_BUF_ERROR = -5;
zlib_constants.Z_NO_COMPRESSION = 0;
zlib_constants.Z_BEST_SPEED = 1;
zlib_constants.Z_BEST_COMPRESSION = 9;
zlib_constants.Z_DEFAULT_COMPRESSION = -1;
zlib_constants.Z_FILTERED = 1;
zlib_constants.Z_HUFFMAN_ONLY = 2;
zlib_constants.Z_RLE = 3;
zlib_constants.Z_FIXED = 4;
zlib_constants.Z_DEFAULT_STRATEGY = 0;
zlib_constants.Z_BINARY = 0;
zlib_constants.Z_TEXT = 1;
zlib_constants.Z_UNKNOWN = 2;
zlib_constants.Z_DEFLATED = 8;

// obj/full/Pako/zlib/crc32.js
var zlib_crc32 = class _zlib_crc32 {
  static makeTable() {
    let c;
    let table = new Int32Array(256);
    for (let n = 0; n < 256; n++) {
      c = n;
      for (let k = 0; k < 8; k++) {
        c = c & 1 ? 3988292384 ^ c >>> 1 : c >>> 1;
      }
      table[n] = c;
    }
    return table;
  }
  static crc32(crc, buf, len, pos) {
    let t = _zlib_crc32.crcTable;
    let end = pos + len;
    crc ^= -1;
    for (let i = pos; i < end; i++) {
      crc = crc >>> 8 ^ t[(crc ^ buf[i]) & 255];
    }
    return crc ^ -1;
  }
};
zlib_crc32.crcTable = zlib_crc32.makeTable();

// obj/full/Pako/zlib/deflate.js
var zlib_config = class {
  constructor(good_length, max_lazy, nice_length, max_chain, func) {
    this.good_length = good_length;
    this.max_lazy = max_lazy;
    this.nice_length = nice_length;
    this.max_chain = max_chain;
    this.func = func;
  }
};
var zlib_DeflateState = class {
  /* Number of valid bits in bi_buf.  All bits above the last valid bit
   * are always zero.
   */
  // Used for window memory init. We safely ignore it for JS. That makes
  // sense only for pointers and memory check tools.
  //this.high_water = 0;
  /* High water mark offset in window for initialized bytes -- bytes above
   * this are set to zero in order to avoid memory check warnings when
   * longest match routines access bytes past the input.  This is then
   * updated to the new high water mark.
   */
  constructor() {
    this.strm = null;
    this.status = 0;
    this.pending_buf = null;
    this.pending_buf_size = 0;
    this.pending_out = 0;
    this.pending = 0;
    this.wrap = 0;
    this.gzhead = null;
    this.gzindex = 0;
    this.method = zlib_constants.Z_DEFLATED;
    this.last_flush = -1;
    this.w_size = 0;
    this.w_bits = 0;
    this.w_mask = 0;
    this.window = null;
    this.window_size = 0;
    this.prev = null;
    this.head = null;
    this.ins_h = 0;
    this.hash_size = 0;
    this.hash_bits = 0;
    this.hash_mask = 0;
    this.hash_shift = 0;
    this.block_start = 0;
    this.match_length = 0;
    this.prev_match = 0;
    this.match_available = 0;
    this.strstart = 0;
    this.match_start = 0;
    this.lookahead = 0;
    this.prev_length = 0;
    this.max_chain_length = 0;
    this.max_lazy_match = 0;
    this.level = 0;
    this.strategy = 0;
    this.good_match = 0;
    this.nice_match = 0;
    this.dyn_ltree = new Uint16Array(zlib_Pako_trees.HEAP_SIZE * 2);
    this.dyn_dtree = new Uint16Array((2 * zlib_Pako_trees.D_CODES + 1) * 2);
    this.bl_tree = new Uint16Array((2 * zlib_Pako_trees.BL_CODES + 1) * 2);
    this.l_desc = null;
    this.d_desc = null;
    this.bl_desc = null;
    this.bl_count = new Uint16Array(zlib_Pako_trees.MAX_BITS + 1);
    this.heap = new Uint16Array(2 * zlib_Pako_trees.L_CODES + 1);
    this.heap_len = 0;
    this.heap_max = 0;
    this.depth = new Uint16Array(2 * zlib_Pako_trees.L_CODES + 1);
    this.l_buf = 0;
    this.lit_bufsize = 0;
    this.last_lit = 0;
    this.d_buf = 0;
    this.opt_len = 0;
    this.static_len = 0;
    this.matches = 0;
    this.insert = 0;
    this.bi_buf = 0;
    this.bi_valid = 0;
    zlib_Pako_trees.zero(this.dyn_ltree);
    zlib_Pako_trees.zero(this.dyn_dtree);
    zlib_Pako_trees.zero(this.bl_tree);
    zlib_Pako_trees.zero(this.heap);
    zlib_Pako_trees.zero(this.depth);
  }
};
var zlib_deflate = class _zlib_deflate {
  static err(strm, errorCode) {
    strm.msg = zlib_messages.msg(errorCode);
    return errorCode;
  }
  static rank(f) {
    return (f << 1) - (f > 4 ? 9 : 0);
  }
  zero(buf) {
    let len = buf.length;
    while (--len >= 0) {
      buf[len] = 0;
    }
  }
  /* eslint-disable new-cap */
  static HASH_ZLIB(s, prev, data) {
    return (prev << s.hash_shift ^ data) & s.hash_mask;
  }
  // This hash causes less collisions, https://github.com/nodeca/pako/issues/135
  // But breaks binary compatibility
  //let HASH_FAST = (s, prev, data) => ((prev << 8) + (prev >> 8) + (data << 4)) & s.hash_mask;
  static HASH(s, prev, data) {
    return (prev << s.hash_shift ^ data) & s.hash_mask;
  }
  /* =========================================================================
   * Flush as much pending output as possible. All deflate() output goes
   * through this function so some applications may wish to modify it
   * to avoid allocating a large strm->output buffer and copying into it.
   * (See also read_buf()).
   */
  static flush_pending(strm) {
    const s = strm.state;
    let len = s.pending;
    if (len > strm.avail_out) {
      len = strm.avail_out;
    }
    if (len === 0) {
      return;
    }
    strm.output.set(s.pending_buf.subarray(s.pending_out, s.pending_out + len), strm.next_out);
    strm.next_out += len;
    s.pending_out += len;
    strm.total_out += len;
    strm.avail_out -= len;
    s.pending -= len;
    if (s.pending === 0) {
      s.pending_out = 0;
    }
  }
  static flush_block_only(s, last) {
    zlib_Pako_trees._tr_flush_block(s, s.block_start >= 0 ? s.block_start : -1, s.strstart - s.block_start, last);
    s.block_start = s.strstart;
    _zlib_deflate.flush_pending(s.strm);
  }
  static put_byte(s, b) {
    s.pending_buf[s.pending++] = b;
  }
  /* =========================================================================
   * Put a short in the pending buffer. The 16-bit value is put in MSB order.
   * IN assertion: the stream state is correct and there is enough room in
   * pending_buf.
   */
  static putShortMSB(s, b) {
    s.pending_buf[s.pending++] = b >>> 8 & 255;
    s.pending_buf[s.pending++] = b & 255;
  }
  /* ===========================================================================
   * Read a new buffer from the current input stream, update the adler32
   * and total number of bytes read.  All deflate() input goes through
   * this function so some applications may wish to modify it to avoid
   * allocating a large strm->input buffer and copying from it.
   * (See also flush_pending()).
   */
  static read_buf(strm, buf, start, size) {
    let len = strm.avail_in;
    if (len > size) {
      len = size;
    }
    if (len === 0) {
      return 0;
    }
    strm.avail_in -= len;
    buf.set(strm.input.subarray(strm.next_in, strm.next_in + len), start);
    if (strm.state.wrap === 1) {
      strm.adler = zlib_adler32.adler32(strm.adler, buf, len, start);
    } else if (strm.state.wrap === 2) {
      strm.adler = zlib_crc32.crc32(strm.adler, buf, len, start);
    }
    strm.next_in += len;
    strm.total_in += len;
    return len;
  }
  /* ===========================================================================
   * Set match_start to the longest match starting at the given string and
   * return its length. Matches shorter or equal to prev_length are discarded,
   * in which case the result is equal to prev_length and match_start is
   * garbage.
   * IN assertions: cur_match is the head of the hash chain for the current
   *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1
   * OUT assertion: the match length is not greater than s->lookahead.
   */
  static longest_match(s, cur_match) {
    let chain_length = s.max_chain_length;
    let scan = s.strstart;
    let match;
    let len;
    let best_len = s.prev_length;
    let nice_match = s.nice_match;
    const limit = s.strstart > s.w_size - _zlib_deflate.MIN_LOOKAHEAD ? s.strstart - (s.w_size - _zlib_deflate.MIN_LOOKAHEAD) : 0;
    const _win = s.window;
    const wmask = s.w_mask;
    const prev = s.prev;
    const strend = s.strstart + zlib_Pako_trees.MAX_MATCH;
    let scan_end1 = _win[scan + best_len - 1];
    let scan_end = _win[scan + best_len];
    if (s.prev_length >= s.good_match) {
      chain_length >>= 2;
    }
    if (nice_match > s.lookahead) {
      nice_match = s.lookahead;
    }
    do {
      match = cur_match;
      if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1]) {
        continue;
      }
      scan += 2;
      match++;
      do {
      } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend);
      len = zlib_Pako_trees.MAX_MATCH - (strend - scan);
      scan = strend - zlib_Pako_trees.MAX_MATCH;
      if (len > best_len) {
        s.match_start = cur_match;
        best_len = len;
        if (len >= nice_match) {
          break;
        }
        scan_end1 = _win[scan + best_len - 1];
        scan_end = _win[scan + best_len];
      }
    } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);
    if (best_len <= s.lookahead) {
      return best_len;
    }
    return s.lookahead;
  }
  /* ===========================================================================
   * Fill the window when the lookahead becomes insufficient.
   * Updates strstart and lookahead.
   *
   * IN assertion: lookahead < MIN_LOOKAHEAD
   * OUT assertions: strstart <= window_size-MIN_LOOKAHEAD
   *    At least one byte has been read, or avail_in == 0; reads are
   *    performed for at least two bytes (required for the zip translate_eol
   *    option -- not supported here).
   */
  static fill_window(s) {
    const _w_size = s.w_size;
    let p;
    let n;
    let m;
    let more;
    let str;
    do {
      more = s.window_size - s.lookahead - s.strstart;
      if (s.strstart >= _w_size + (_w_size - _zlib_deflate.MIN_LOOKAHEAD)) {
        s.window.set(s.window.subarray(_w_size, _w_size + _w_size), 0);
        s.match_start -= _w_size;
        s.strstart -= _w_size;
        s.block_start -= _w_size;
        n = s.hash_size;
        p = n;
        do {
          m = s.head[--p];
          s.head[p] = m >= _w_size ? m - _w_size : 0;
        } while (--n);
        n = _w_size;
        p = n;
        do {
          m = s.prev[--p];
          s.prev[p] = m >= _w_size ? m - _w_size : 0;
        } while (--n);
        more += _w_size;
      }
      if (s.strm.avail_in === 0) {
        break;
      }
      n = _zlib_deflate.read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
      s.lookahead += n;
      if (s.lookahead + s.insert >= zlib_Pako_trees.MIN_MATCH) {
        str = s.strstart - s.insert;
        s.ins_h = s.window[str];
        s.ins_h = _zlib_deflate.HASH(s, s.ins_h, s.window[str + 1]);
        while (s.insert) {
          s.ins_h = _zlib_deflate.HASH(s, s.ins_h, s.window[str + zlib_Pako_trees.MIN_MATCH - 1]);
          s.prev[str & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = str;
          str++;
          s.insert--;
          if (s.lookahead + s.insert < zlib_Pako_trees.MIN_MATCH) {
            break;
          }
        }
      }
    } while (s.lookahead < _zlib_deflate.MIN_LOOKAHEAD && s.strm.avail_in !== 0);
  }
  /* ===========================================================================
   * Copy without compression as much as possible from the input stream, return
   * the current block state.
   * This function does not insert new strings in the dictionary since
   * uncompressible data is probably not useful. This function is used
   * only for the level=0 compression option.
   * NOTE: this function should be optimized to avoid extra copying from
   * window to pending_buf.
   */
  static deflate_stored(s, flush) {
    let max_block_size = 65535;
    if (max_block_size > s.pending_buf_size - 5) {
      max_block_size = s.pending_buf_size - 5;
    }
    for (; ; ) {
      if (s.lookahead <= 1) {
        _zlib_deflate.fill_window(s);
        if (s.lookahead === 0 && flush === zlib_constants.Z_NO_FLUSH) {
          return _zlib_deflate.BS_NEED_MORE;
        }
        if (s.lookahead === 0) {
          break;
        }
      }
      s.strstart += s.lookahead;
      s.lookahead = 0;
      const max_start = s.block_start + max_block_size;
      if (s.strstart === 0 || s.strstart >= max_start) {
        s.lookahead = s.strstart - max_start;
        s.strstart = max_start;
        _zlib_deflate.flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return _zlib_deflate.BS_NEED_MORE;
        }
      }
      if (s.strstart - s.block_start >= s.w_size - _zlib_deflate.MIN_LOOKAHEAD) {
        _zlib_deflate.flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return _zlib_deflate.BS_NEED_MORE;
        }
      }
    }
    s.insert = 0;
    if (flush === zlib_constants.Z_FINISH) {
      _zlib_deflate.flush_block_only(s, true);
      if (s.strm.avail_out === 0) {
        return _zlib_deflate.BS_FINISH_STARTED;
      }
      return _zlib_deflate.BS_FINISH_DONE;
    }
    if (s.strstart > s.block_start) {
      _zlib_deflate.flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return _zlib_deflate.BS_NEED_MORE;
      }
    }
    return _zlib_deflate.BS_NEED_MORE;
  }
  /* ===========================================================================
   * Same as above, but achieves better compression. We use a lazy
   * evaluation for matches: a match is finally adopted only if there is
   * no better match at the next window position.
   */
  static deflate_slow(s, flush) {
    let hash_head;
    let bflush;
    let max_insert;
    for (; ; ) {
      if (s.lookahead < _zlib_deflate.MIN_LOOKAHEAD) {
        _zlib_deflate.fill_window(s);
        if (s.lookahead < _zlib_deflate.MIN_LOOKAHEAD && flush === zlib_constants.Z_NO_FLUSH) {
          return _zlib_deflate.BS_NEED_MORE;
        }
        if (s.lookahead === 0) {
          break;
        }
      }
      hash_head = 0;
      if (s.lookahead >= zlib_Pako_trees.MIN_MATCH) {
        s.ins_h = _zlib_deflate.HASH(s, s.ins_h, s.window[s.strstart + zlib_Pako_trees.MIN_MATCH - 1]);
        hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
        s.head[s.ins_h] = s.strstart;
      }
      s.prev_length = s.match_length;
      s.prev_match = s.match_start;
      s.match_length = zlib_Pako_trees.MIN_MATCH - 1;
      if (hash_head !== 0 && s.prev_length < s.max_lazy_match && s.strstart - hash_head <= s.w_size - _zlib_deflate.MIN_LOOKAHEAD) {
        s.match_length = _zlib_deflate.longest_match(s, hash_head);
        if (s.match_length <= 5 && (s.strategy === zlib_constants.Z_FILTERED || s.match_length === zlib_Pako_trees.MIN_MATCH && s.strstart - s.match_start > 4096)) {
          s.match_length = zlib_Pako_trees.MIN_MATCH - 1;
        }
      }
      if (s.prev_length >= zlib_Pako_trees.MIN_MATCH && s.match_length <= s.prev_length) {
        max_insert = s.strstart + s.lookahead - zlib_Pako_trees.MIN_MATCH;
        bflush = zlib_Pako_trees._tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - zlib_Pako_trees.MIN_MATCH);
        s.lookahead -= s.prev_length - 1;
        s.prev_length -= 2;
        do {
          if (++s.strstart <= max_insert) {
            s.ins_h = _zlib_deflate.HASH(s, s.ins_h, s.window[s.strstart + zlib_Pako_trees.MIN_MATCH - 1]);
            hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
            s.head[s.ins_h] = s.strstart;
          }
        } while (--s.prev_length !== 0);
        s.match_available = 0;
        s.match_length = zlib_Pako_trees.MIN_MATCH - 1;
        s.strstart++;
        if (bflush) {
          _zlib_deflate.flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return _zlib_deflate.BS_NEED_MORE;
          }
        }
      } else if (s.match_available) {
        bflush = zlib_Pako_trees._tr_tally(s, 0, s.window[s.strstart - 1]);
        if (bflush) {
          _zlib_deflate.flush_block_only(s, false);
        }
        s.strstart++;
        s.lookahead--;
        if (s.strm.avail_out === 0) {
          return _zlib_deflate.BS_NEED_MORE;
        }
      } else {
        s.match_available = 1;
        s.strstart++;
        s.lookahead--;
      }
    }
    if (s.match_available) {
      bflush = zlib_Pako_trees._tr_tally(s, 0, s.window[s.strstart - 1]);
      s.match_available = 0;
    }
    s.insert = s.strstart < zlib_Pako_trees.MIN_MATCH - 1 ? s.strstart : zlib_Pako_trees.MIN_MATCH - 1;
    if (flush === zlib_constants.Z_FINISH) {
      _zlib_deflate.flush_block_only(s, true);
      if (s.strm.avail_out === 0) {
        return _zlib_deflate.BS_FINISH_STARTED;
      }
      return _zlib_deflate.BS_FINISH_DONE;
    }
    if (s.last_lit) {
      _zlib_deflate.flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return _zlib_deflate.BS_NEED_MORE;
      }
    }
    return _zlib_deflate.BS_BLOCK_DONE;
  }
  /* ===========================================================================
   * For Pako_constants.Z_RLE, simply look for runs of bytes, generate matches only of distance
   * one.  Do not maintain a hash table.  (It will be regenerated if this run of
   * deflate switches away from Pako_constants.Z_RLE.)
   */
  static deflate_rle(s, flush) {
    let bflush;
    let prev;
    let scan;
    let strend;
    const _win = s.window;
    for (; ; ) {
      if (s.lookahead <= zlib_Pako_trees.MAX_MATCH) {
        _zlib_deflate.fill_window(s);
        if (s.lookahead <= zlib_Pako_trees.MAX_MATCH && flush === zlib_constants.Z_NO_FLUSH) {
          return _zlib_deflate.BS_NEED_MORE;
        }
        if (s.lookahead === 0) {
          break;
        }
      }
      s.match_length = 0;
      if (s.lookahead >= zlib_Pako_trees.MIN_MATCH && s.strstart > 0) {
        scan = s.strstart - 1;
        prev = _win[scan];
        if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
          strend = s.strstart + zlib_Pako_trees.MAX_MATCH;
          do {
          } while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);
          s.match_length = zlib_Pako_trees.MAX_MATCH - (strend - scan);
          if (s.match_length > s.lookahead) {
            s.match_length = s.lookahead;
          }
        }
      }
      if (s.match_length >= zlib_Pako_trees.MIN_MATCH) {
        bflush = zlib_Pako_trees._tr_tally(s, 1, s.match_length - zlib_Pako_trees.MIN_MATCH);
        s.lookahead -= s.match_length;
        s.strstart += s.match_length;
        s.match_length = 0;
      } else {
        bflush = zlib_Pako_trees._tr_tally(s, 0, s.window[s.strstart]);
        s.lookahead--;
        s.strstart++;
      }
      if (bflush) {
        _zlib_deflate.flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return _zlib_deflate.BS_NEED_MORE;
        }
      }
    }
    s.insert = 0;
    if (flush === zlib_constants.Z_FINISH) {
      _zlib_deflate.flush_block_only(s, true);
      if (s.strm.avail_out === 0) {
        return _zlib_deflate.BS_FINISH_STARTED;
      }
      return _zlib_deflate.BS_FINISH_DONE;
    }
    if (s.last_lit) {
      _zlib_deflate.flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return _zlib_deflate.BS_NEED_MORE;
      }
    }
    return _zlib_deflate.BS_BLOCK_DONE;
  }
  /* ===========================================================================
   * For Pako_constants.Z_HUFFMAN_ONLY, do not look for matches.  Do not maintain a hash table.
   * (It will be regenerated if this run of deflate switches away from Huffman.)
   */
  static deflate_huff(s, flush) {
    let bflush;
    for (; ; ) {
      if (s.lookahead === 0) {
        _zlib_deflate.fill_window(s);
        if (s.lookahead === 0) {
          if (flush === zlib_constants.Z_NO_FLUSH) {
            return _zlib_deflate.BS_NEED_MORE;
          }
          break;
        }
      }
      s.match_length = 0;
      bflush = zlib_Pako_trees._tr_tally(s, 0, s.window[s.strstart]);
      s.lookahead--;
      s.strstart++;
      if (bflush) {
        _zlib_deflate.flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return _zlib_deflate.BS_NEED_MORE;
        }
      }
    }
    s.insert = 0;
    if (flush === zlib_constants.Z_FINISH) {
      _zlib_deflate.flush_block_only(s, true);
      if (s.strm.avail_out === 0) {
        return _zlib_deflate.BS_FINISH_STARTED;
      }
      return _zlib_deflate.BS_FINISH_DONE;
    }
    if (s.last_lit) {
      _zlib_deflate.flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return _zlib_deflate.BS_NEED_MORE;
      }
    }
    return _zlib_deflate.BS_BLOCK_DONE;
  }
  /* ===========================================================================
   * Initialize the "longest match" routines for a new zlib stream
   */
  static lm_init(s) {
    s.window_size = 2 * s.w_size;
    zlib_Pako_trees.zero(s.head);
    s.max_lazy_match = _zlib_deflate.configuration_table[s.level].max_lazy;
    s.good_match = _zlib_deflate.configuration_table[s.level].good_length;
    s.nice_match = _zlib_deflate.configuration_table[s.level].nice_length;
    s.max_chain_length = _zlib_deflate.configuration_table[s.level].max_chain;
    s.strstart = 0;
    s.block_start = 0;
    s.lookahead = 0;
    s.insert = 0;
    s.match_length = s.prev_length = zlib_Pako_trees.MIN_MATCH - 1;
    s.match_available = 0;
    s.ins_h = 0;
  }
  static deflateResetKeep(strm) {
    if (!strm || !strm.state) {
      return _zlib_deflate.err(strm, zlib_constants.Z_STREAM_ERROR);
    }
    strm.total_in = strm.total_out = 0;
    strm.data_type = zlib_constants.Z_UNKNOWN;
    let s = strm.state;
    s.pending = 0;
    s.pending_out = 0;
    if (s.wrap < 0) {
      s.wrap = -s.wrap;
    }
    s.status = s.wrap ? _zlib_deflate.INIT_STATE : _zlib_deflate.BUSY_STATE;
    strm.adler = s.wrap === 2 ? 0 : 1;
    s.last_flush = zlib_constants.Z_NO_FLUSH;
    zlib_Pako_trees._tr_init(s);
    return zlib_constants.Z_OK;
  }
  static deflateReset(strm) {
    const ret = _zlib_deflate.deflateResetKeep(strm);
    if (ret === zlib_constants.Z_OK) {
      _zlib_deflate.lm_init(strm.state);
    }
    return ret;
  }
  static deflateSetHeader(strm, head) {
    if (!strm || !strm.state) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    if (strm.state.wrap !== 2) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    strm.state.gzhead = head;
    return zlib_constants.Z_OK;
  }
  static deflateInit2(strm, level, method, windowBits, memLevel, strategy) {
    if (!strm) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    let wrap = 1;
    if (level === zlib_constants.Z_DEFAULT_COMPRESSION) {
      level = 6;
    }
    if (windowBits < 0) {
      wrap = 0;
      windowBits = -windowBits;
    } else if (windowBits > 15) {
      wrap = 2;
      windowBits -= 16;
    }
    if (memLevel < 1 || memLevel > _zlib_deflate.MAX_MEM_LEVEL || method !== zlib_constants.Z_DEFLATED || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > zlib_constants.Z_FIXED) {
      return _zlib_deflate.err(strm, zlib_constants.Z_STREAM_ERROR);
    }
    if (windowBits === 8) {
      windowBits = 9;
    }
    const s = new zlib_DeflateState();
    strm.state = s;
    s.strm = strm;
    s.wrap = wrap;
    s.gzhead = null;
    s.w_bits = windowBits;
    s.w_size = 1 << s.w_bits;
    s.w_mask = s.w_size - 1;
    s.hash_bits = memLevel + 7;
    s.hash_size = 1 << s.hash_bits;
    s.hash_mask = s.hash_size - 1;
    s.hash_shift = ~~((s.hash_bits + zlib_Pako_trees.MIN_MATCH - 1) / zlib_Pako_trees.MIN_MATCH);
    s.window = new Uint8Array(s.w_size * 2);
    s.head = new Uint16Array(s.hash_size);
    s.prev = new Uint16Array(s.w_size);
    s.lit_bufsize = 1 << memLevel + 6;
    s.pending_buf_size = s.lit_bufsize * 4;
    s.pending_buf = new Uint8Array(s.pending_buf_size);
    s.d_buf = 1 * s.lit_bufsize;
    s.l_buf = (1 + 2) * s.lit_bufsize;
    s.level = level;
    s.strategy = strategy;
    s.method = method;
    return _zlib_deflate.deflateReset(strm);
  }
  static deflateInit(strm, level) {
    return _zlib_deflate.deflateInit2(strm, level, zlib_constants.Z_DEFLATED, _zlib_deflate.MAX_WBITS, _zlib_deflate.DEF_MEM_LEVEL, zlib_constants.Z_DEFAULT_STRATEGY);
  }
  static deflate(strm, flush) {
    let beg, val;
    if (!strm || !strm.state || flush > zlib_constants.Z_BLOCK || flush < 0) {
      return strm ? _zlib_deflate.err(strm, zlib_constants.Z_STREAM_ERROR) : zlib_constants.Z_STREAM_ERROR;
    }
    let s = strm.state;
    if (!strm.output || !strm.input && strm.avail_in !== 0 || s.status === _zlib_deflate.FINISH_STATE && flush !== zlib_constants.Z_FINISH) {
      return _zlib_deflate.err(strm, strm.avail_out === 0 ? zlib_constants.Z_BUF_ERROR : zlib_constants.Z_STREAM_ERROR);
    }
    s.strm = strm;
    const old_flush = s.last_flush;
    s.last_flush = flush;
    if (s.status === _zlib_deflate.INIT_STATE) {
      if (s.wrap === 2) {
        strm.adler = 0;
        _zlib_deflate.put_byte(s, 31);
        _zlib_deflate.put_byte(s, 139);
        _zlib_deflate.put_byte(s, 8);
        if (!s.gzhead) {
          _zlib_deflate.put_byte(s, 0);
          _zlib_deflate.put_byte(s, 0);
          _zlib_deflate.put_byte(s, 0);
          _zlib_deflate.put_byte(s, 0);
          _zlib_deflate.put_byte(s, 0);
          _zlib_deflate.put_byte(s, s.level === 9 ? 2 : s.strategy >= zlib_constants.Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
          _zlib_deflate.put_byte(s, _zlib_deflate.OS_CODE);
          s.status = _zlib_deflate.BUSY_STATE;
        } else {
          _zlib_deflate.put_byte(s, (s.gzhead.text ? 1 : 0) + (s.gzhead.hcrc ? 2 : 0) + (!s.gzhead.extra ? 0 : 4) + (!s.gzhead.name ? 0 : 8) + (!s.gzhead.comment ? 0 : 16));
          _zlib_deflate.put_byte(s, s.gzhead.time & 255);
          _zlib_deflate.put_byte(s, s.gzhead.time >> 8 & 255);
          _zlib_deflate.put_byte(s, s.gzhead.time >> 16 & 255);
          _zlib_deflate.put_byte(s, s.gzhead.time >> 24 & 255);
          _zlib_deflate.put_byte(s, s.level === 9 ? 2 : s.strategy >= zlib_constants.Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
          _zlib_deflate.put_byte(s, s.gzhead.os & 255);
          if (s.gzhead.extra && s.gzhead.extra.length) {
            _zlib_deflate.put_byte(s, s.gzhead.extra.length & 255);
            _zlib_deflate.put_byte(s, s.gzhead.extra.length >> 8 & 255);
          }
          if (s.gzhead.hcrc) {
            strm.adler = zlib_crc32.crc32(strm.adler, s.pending_buf, s.pending, 0);
          }
          s.gzindex = 0;
          s.status = _zlib_deflate.EXTRA_STATE;
        }
      } else {
        let header = zlib_constants.Z_DEFLATED + (s.w_bits - 8 << 4) << 8;
        let level_flags = -1;
        if (s.strategy >= zlib_constants.Z_HUFFMAN_ONLY || s.level < 2) {
          level_flags = 0;
        } else if (s.level < 6) {
          level_flags = 1;
        } else if (s.level === 6) {
          level_flags = 2;
        } else {
          level_flags = 3;
        }
        header |= level_flags << 6;
        if (s.strstart !== 0) {
          header |= _zlib_deflate.PRESET_DICT;
        }
        header += 31 - header % 31;
        s.status = _zlib_deflate.BUSY_STATE;
        _zlib_deflate.putShortMSB(s, header);
        if (s.strstart !== 0) {
          _zlib_deflate.putShortMSB(s, strm.adler >>> 16);
          _zlib_deflate.putShortMSB(s, strm.adler & 65535);
        }
        strm.adler = 1;
      }
    }
    if (s.status === _zlib_deflate.EXTRA_STATE) {
      if (s.gzhead.extra) {
        beg = s.pending;
        while (s.gzindex < (s.gzhead.extra.length & 65535)) {
          if (s.pending === s.pending_buf_size) {
            if (s.gzhead.hcrc && s.pending > beg) {
              strm.adler = zlib_crc32.crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
            }
            _zlib_deflate.flush_pending(strm);
            beg = s.pending;
            if (s.pending === s.pending_buf_size) {
              break;
            }
          }
          _zlib_deflate.put_byte(s, s.gzhead.extra[s.gzindex] & 255);
          s.gzindex++;
        }
        if (s.gzhead.hcrc && s.pending > beg) {
          strm.adler = zlib_crc32.crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
        }
        if (s.gzindex === s.gzhead.extra.length) {
          s.gzindex = 0;
          s.status = _zlib_deflate.NAME_STATE;
        }
      } else {
        s.status = _zlib_deflate.NAME_STATE;
      }
    }
    if (s.status === _zlib_deflate.NAME_STATE) {
      if (s.gzhead.name) {
        beg = s.pending;
        do {
          if (s.pending === s.pending_buf_size) {
            if (s.gzhead.hcrc && s.pending > beg) {
              strm.adler = zlib_crc32.crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
            }
            _zlib_deflate.flush_pending(strm);
            beg = s.pending;
            if (s.pending === s.pending_buf_size) {
              val = 1;
              break;
            }
          }
          if (s.gzindex < s.gzhead.name.length) {
            val = s.gzhead.name.charCodeAt(s.gzindex++) & 255;
          } else {
            val = 0;
          }
          _zlib_deflate.put_byte(s, val);
        } while (val !== 0);
        if (s.gzhead.hcrc && s.pending > beg) {
          strm.adler = zlib_crc32.crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
        }
        if (val === 0) {
          s.gzindex = 0;
          s.status = _zlib_deflate.COMMENT_STATE;
        }
      } else {
        s.status = _zlib_deflate.COMMENT_STATE;
      }
    }
    if (s.status === _zlib_deflate.COMMENT_STATE) {
      if (s.gzhead.comment) {
        beg = s.pending;
        do {
          if (s.pending === s.pending_buf_size) {
            if (s.gzhead.hcrc && s.pending > beg) {
              strm.adler = zlib_crc32.crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
            }
            _zlib_deflate.flush_pending(strm);
            beg = s.pending;
            if (s.pending === s.pending_buf_size) {
              val = 1;
              break;
            }
          }
          if (s.gzindex < s.gzhead.comment.length) {
            val = s.gzhead.comment.charCodeAt(s.gzindex++) & 255;
          } else {
            val = 0;
          }
          _zlib_deflate.put_byte(s, val);
        } while (val !== 0);
        if (s.gzhead.hcrc && s.pending > beg) {
          strm.adler = zlib_crc32.crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
        }
        if (val === 0) {
          s.status = _zlib_deflate.HCRC_STATE;
        }
      } else {
        s.status = _zlib_deflate.HCRC_STATE;
      }
    }
    if (s.status === _zlib_deflate.HCRC_STATE) {
      if (s.gzhead.hcrc) {
        if (s.pending + 2 > s.pending_buf_size) {
          _zlib_deflate.flush_pending(strm);
        }
        if (s.pending + 2 <= s.pending_buf_size) {
          _zlib_deflate.put_byte(s, strm.adler & 255);
          _zlib_deflate.put_byte(s, strm.adler >> 8 & 255);
          strm.adler = 0;
          s.status = _zlib_deflate.BUSY_STATE;
        }
      } else {
        s.status = _zlib_deflate.BUSY_STATE;
      }
    }
    if (s.pending !== 0) {
      _zlib_deflate.flush_pending(strm);
      if (strm.avail_out === 0) {
        s.last_flush = -1;
        return zlib_constants.Z_OK;
      }
    } else if (strm.avail_in === 0 && _zlib_deflate.rank(flush) <= _zlib_deflate.rank(old_flush) && flush !== zlib_constants.Z_FINISH) {
      return _zlib_deflate.err(strm, zlib_constants.Z_BUF_ERROR);
    }
    if (s.status === _zlib_deflate.FINISH_STATE && strm.avail_in !== 0) {
      return _zlib_deflate.err(strm, zlib_constants.Z_BUF_ERROR);
    }
    if (strm.avail_in !== 0 || s.lookahead !== 0 || flush !== zlib_constants.Z_NO_FLUSH && s.status !== _zlib_deflate.FINISH_STATE) {
      let bstate = s.strategy === zlib_constants.Z_HUFFMAN_ONLY ? _zlib_deflate.deflate_huff(s, flush) : s.strategy === zlib_constants.Z_RLE ? _zlib_deflate.deflate_rle(s, flush) : _zlib_deflate.configuration_table[s.level].func(s, flush);
      if (bstate === _zlib_deflate.BS_FINISH_STARTED || bstate === _zlib_deflate.BS_FINISH_DONE) {
        s.status = _zlib_deflate.FINISH_STATE;
      }
      if (bstate === _zlib_deflate.BS_NEED_MORE || bstate === _zlib_deflate.BS_FINISH_STARTED) {
        if (strm.avail_out === 0) {
          s.last_flush = -1;
        }
        return zlib_constants.Z_OK;
      }
      if (bstate === _zlib_deflate.BS_BLOCK_DONE) {
        if (flush === zlib_constants.Z_PARTIAL_FLUSH) {
          zlib_Pako_trees._tr_align(s);
        } else if (flush !== zlib_constants.Z_BLOCK) {
          zlib_Pako_trees._tr_stored_block(s, 0, 0, false);
          if (flush === zlib_constants.Z_FULL_FLUSH) {
            zlib_Pako_trees.zero(s.head);
            if (s.lookahead === 0) {
              s.strstart = 0;
              s.block_start = 0;
              s.insert = 0;
            }
          }
        }
        _zlib_deflate.flush_pending(strm);
        if (strm.avail_out === 0) {
          s.last_flush = -1;
          return zlib_constants.Z_OK;
        }
      }
    }
    if (flush !== zlib_constants.Z_FINISH) {
      return zlib_constants.Z_OK;
    }
    if (s.wrap <= 0) {
      return zlib_constants.Z_STREAM_END;
    }
    if (s.wrap === 2) {
      _zlib_deflate.put_byte(s, strm.adler & 255);
      _zlib_deflate.put_byte(s, strm.adler >> 8 & 255);
      _zlib_deflate.put_byte(s, strm.adler >> 16 & 255);
      _zlib_deflate.put_byte(s, strm.adler >> 24 & 255);
      _zlib_deflate.put_byte(s, strm.total_in & 255);
      _zlib_deflate.put_byte(s, strm.total_in >> 8 & 255);
      _zlib_deflate.put_byte(s, strm.total_in >> 16 & 255);
      _zlib_deflate.put_byte(s, strm.total_in >> 24 & 255);
    } else {
      _zlib_deflate.putShortMSB(s, strm.adler >>> 16);
      _zlib_deflate.putShortMSB(s, strm.adler & 65535);
    }
    _zlib_deflate.flush_pending(strm);
    if (s.wrap > 0) {
      s.wrap = -s.wrap;
    }
    return s.pending !== 0 ? zlib_constants.Z_OK : zlib_constants.Z_STREAM_END;
  }
  static deflateEnd(strm) {
    if (!strm || !strm.state) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    let status = strm.state.status;
    if (status !== _zlib_deflate.INIT_STATE && status !== _zlib_deflate.EXTRA_STATE && status !== _zlib_deflate.NAME_STATE && status !== _zlib_deflate.COMMENT_STATE && status !== _zlib_deflate.HCRC_STATE && status !== _zlib_deflate.BUSY_STATE && status !== _zlib_deflate.FINISH_STATE) {
      return _zlib_deflate.err(strm, zlib_constants.Z_STREAM_ERROR);
    }
    strm.state = null;
    return status === _zlib_deflate.BUSY_STATE ? _zlib_deflate.err(strm, zlib_constants.Z_DATA_ERROR) : zlib_constants.Z_OK;
  }
  /* =========================================================================
   * Initializes the compression dictionary from the given byte
   * sequence without producing any compressed output.
   */
  static deflateSetDictionary(strm, dictionary) {
    let dictLength = dictionary.length;
    if (!strm || !strm.state) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    const s = strm.state;
    const wrap = s.wrap;
    if (wrap === 2 || wrap === 1 && s.status !== _zlib_deflate.INIT_STATE || s.lookahead) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    if (wrap === 1) {
      strm.adler = zlib_adler32.adler32(strm.adler, dictionary, dictLength, 0);
    }
    s.wrap = 0;
    if (dictLength >= s.w_size) {
      if (wrap === 0) {
        zlib_Pako_trees.zero(s.head);
        s.strstart = 0;
        s.block_start = 0;
        s.insert = 0;
      }
      let tmpDict = new Uint8Array(s.w_size);
      tmpDict.set(dictionary.subarray(dictLength - s.w_size, dictLength), 0);
      dictionary = tmpDict;
      dictLength = s.w_size;
    }
    const avail = strm.avail_in;
    const next = strm.next_in;
    const input = strm.input;
    strm.avail_in = dictLength;
    strm.next_in = 0;
    strm.input = dictionary;
    _zlib_deflate.fill_window(s);
    while (s.lookahead >= zlib_Pako_trees.MIN_MATCH) {
      let str = s.strstart;
      let n = s.lookahead - (zlib_Pako_trees.MIN_MATCH - 1);
      do {
        s.ins_h = _zlib_deflate.HASH(s, s.ins_h, s.window[str + zlib_Pako_trees.MIN_MATCH - 1]);
        s.prev[str & s.w_mask] = s.head[s.ins_h];
        s.head[s.ins_h] = str;
        str++;
      } while (--n);
      s.strstart = str;
      s.lookahead = zlib_Pako_trees.MIN_MATCH - 1;
      _zlib_deflate.fill_window(s);
    }
    s.strstart += s.lookahead;
    s.block_start = s.strstart;
    s.insert = s.lookahead;
    s.lookahead = 0;
    s.match_length = s.prev_length = zlib_Pako_trees.MIN_MATCH - 1;
    s.match_available = 0;
    strm.next_in = next;
    strm.input = input;
    strm.avail_in = avail;
    s.wrap = wrap;
    return zlib_constants.Z_OK;
  }
};
zlib_deflate.MAX_MEM_LEVEL = 9;
zlib_deflate.MAX_WBITS = 15;
zlib_deflate.DEF_MEM_LEVEL = 8;
zlib_deflate.LENGTH_CODES = 29;
zlib_deflate.LITERALS = 256;
zlib_deflate.L_CODES = zlib_deflate.LITERALS + 1 + zlib_deflate.LENGTH_CODES;
zlib_deflate.D_CODES = 30;
zlib_deflate.BL_CODES = 19;
zlib_deflate.HEAP_SIZE = 2 * zlib_deflate.L_CODES + 1;
zlib_deflate.MAX_BITS = 15;
zlib_deflate.MIN_MATCH = 3;
zlib_deflate.MAX_MATCH = 258;
zlib_deflate.MIN_LOOKAHEAD = zlib_deflate.MAX_MATCH + zlib_deflate.MIN_MATCH + 1;
zlib_deflate.PRESET_DICT = 32;
zlib_deflate.INIT_STATE = 42;
zlib_deflate.EXTRA_STATE = 69;
zlib_deflate.NAME_STATE = 73;
zlib_deflate.COMMENT_STATE = 91;
zlib_deflate.HCRC_STATE = 103;
zlib_deflate.BUSY_STATE = 113;
zlib_deflate.FINISH_STATE = 666;
zlib_deflate.BS_NEED_MORE = 1;
zlib_deflate.BS_BLOCK_DONE = 2;
zlib_deflate.BS_FINISH_STARTED = 3;
zlib_deflate.BS_FINISH_DONE = 4;
zlib_deflate.OS_CODE = 3;
zlib_deflate.deflate_fast = (s, flush) => {
  let hash_head;
  let bflush;
  for (; ; ) {
    if (s.lookahead < zlib_deflate.MIN_LOOKAHEAD) {
      zlib_deflate.fill_window(s);
      if (s.lookahead < zlib_deflate.MIN_LOOKAHEAD && flush === zlib_constants.Z_NO_FLUSH) {
        return zlib_deflate.BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break;
      }
    }
    hash_head = 0;
    if (s.lookahead >= zlib_Pako_trees.MIN_MATCH) {
      s.ins_h = zlib_deflate.HASH(s, s.ins_h, s.window[s.strstart + zlib_Pako_trees.MIN_MATCH - 1]);
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
    }
    if (hash_head !== 0 && s.strstart - hash_head <= s.w_size - zlib_deflate.MIN_LOOKAHEAD) {
      s.match_length = zlib_deflate.longest_match(s, hash_head);
    }
    if (s.match_length >= zlib_Pako_trees.MIN_MATCH) {
      bflush = zlib_Pako_trees._tr_tally(s, s.strstart - s.match_start, s.match_length - zlib_Pako_trees.MIN_MATCH);
      s.lookahead -= s.match_length;
      if (s.match_length <= s.max_lazy_match && s.lookahead >= zlib_Pako_trees.MIN_MATCH) {
        s.match_length--;
        do {
          s.strstart++;
          s.ins_h = zlib_deflate.HASH(s, s.ins_h, s.window[s.strstart + zlib_Pako_trees.MIN_MATCH - 1]);
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
        } while (--s.match_length !== 0);
        s.strstart++;
      } else {
        s.strstart += s.match_length;
        s.match_length = 0;
        s.ins_h = s.window[s.strstart];
        s.ins_h = zlib_deflate.HASH(s, s.ins_h, s.window[s.strstart + 1]);
      }
    } else {
      bflush = zlib_Pako_trees._tr_tally(s, 0, s.window[s.strstart]);
      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      zlib_deflate.flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return zlib_deflate.BS_NEED_MORE;
      }
    }
  }
  s.insert = s.strstart < zlib_Pako_trees.MIN_MATCH - 1 ? s.strstart : zlib_Pako_trees.MIN_MATCH - 1;
  if (flush === zlib_constants.Z_FINISH) {
    zlib_deflate.flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return zlib_deflate.BS_FINISH_STARTED;
    }
    return zlib_deflate.BS_FINISH_DONE;
  }
  if (s.last_lit) {
    zlib_deflate.flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return zlib_deflate.BS_NEED_MORE;
    }
  }
  return zlib_deflate.BS_BLOCK_DONE;
};
zlib_deflate.configuration_table = [
  /*      good lazy nice chain */
  new zlib_config(0, 0, 0, 0, zlib_deflate.deflate_stored),
  new zlib_config(4, 4, 8, 4, zlib_deflate.deflate_fast),
  new zlib_config(4, 5, 16, 8, zlib_deflate.deflate_fast),
  new zlib_config(4, 6, 32, 32, zlib_deflate.deflate_fast),
  new zlib_config(4, 4, 16, 16, zlib_deflate.deflate_slow),
  new zlib_config(8, 16, 32, 32, zlib_deflate.deflate_slow),
  new zlib_config(8, 16, 128, 128, zlib_deflate.deflate_slow),
  new zlib_config(8, 32, 128, 256, zlib_deflate.deflate_slow),
  new zlib_config(32, 128, 258, 1024, zlib_deflate.deflate_slow),
  new zlib_config(32, 258, 258, 4096, zlib_deflate.deflate_slow)
  /* 9 max compression */
];

// obj/full/Pako/zlib/trees.js
var zlib_StaticTreeDesc = class {
  constructor(static_tree, extra_bits, extra_base, elems, max_length) {
    this.static_tree = static_tree;
    this.extra_bits = extra_bits;
    this.extra_base = extra_base;
    this.elems = elems;
    this.max_length = max_length;
    this.has_stree = static_tree != null && static_tree.length > 0;
  }
};
var zlib_TreeDesc = class {
  constructor(dyn_tree, stat_desc) {
    this.max_code = 0;
    this.dyn_tree = dyn_tree;
    this.max_code = 0;
    this.stat_desc = stat_desc;
  }
};
var zlib_Pako_trees = class _zlib_Pako_trees {
  /*============================================================================*/
  static zero(buf) {
    let len = buf.length;
    while (--len >= 0) {
      buf[len] = 0;
    }
  }
  /* First normalized distance for each code (0 = distance of 1) */
  static Zeroinit() {
    _zlib_Pako_trees.zero(_zlib_Pako_trees.static_ltree);
    _zlib_Pako_trees.zero(_zlib_Pako_trees.base_dist);
    _zlib_Pako_trees.zero(_zlib_Pako_trees.base_length);
    _zlib_Pako_trees.zero(_zlib_Pako_trees._length_code);
    _zlib_Pako_trees.zero(_zlib_Pako_trees._dist_code);
    _zlib_Pako_trees.zero(_zlib_Pako_trees.static_dtree);
    return true;
  }
  static d_code(dist) {
    return dist < 256 ? _zlib_Pako_trees._dist_code[dist] : _zlib_Pako_trees._dist_code[256 + (dist >>> 7)];
  }
  /* ===========================================================================
   * Output a short LSB first on the stream.
   * IN assertion: there is enough room in pendingBuf.
   */
  static put_short(s, w) {
    s.pending_buf[s.pending++] = w & 255;
    s.pending_buf[s.pending++] = w >>> 8 & 255;
  }
  static send_code(s, c, tree) {
    _zlib_Pako_trees.send_bits(
      s,
      tree[c * 2],
      tree[c * 2 + 1]
      /*.Len*/
    );
  }
  /* ===========================================================================
   * Reverse the first len bits of a code, using straightforward code (a faster
   * method would use a table)
   * IN assertion: 1 <= len <= 15
   */
  static bi_reverse(code, len) {
    let res = 0;
    do {
      res |= code & 1;
      code >>>= 1;
      res <<= 1;
    } while (--len > 0);
    return res >>> 1;
  }
  /* ===========================================================================
   * Flush the bit buffer, keeping at most 7 bits in it.
   */
  static bi_flush(s) {
    if (s.bi_valid === 16) {
      _zlib_Pako_trees.put_short(s, s.bi_buf);
      s.bi_buf = 0;
      s.bi_valid = 0;
    } else if (s.bi_valid >= 8) {
      s.pending_buf[s.pending++] = s.bi_buf & 255;
      s.bi_buf >>= 8;
      s.bi_valid -= 8;
    }
  }
  /* ===========================================================================
   * Generate the codes for a given tree and bit counts (which need not be
   * optimal).
   * IN assertion: the array bl_count contains the bit length statistics for
   * the given tree and the field len is set for all tree elements.
   * OUT assertion: the field code is set for all tree elements of non
   *     zero code length.
   */
  static gen_codes(tree, max_code, bl_count) {
    const next_code = new Array(_zlib_Pako_trees.MAX_BITS + 1);
    let code = 0;
    let bits;
    let n;
    for (bits = 1; bits <= _zlib_Pako_trees.MAX_BITS; bits++) {
      next_code[bits] = code = code + bl_count[bits - 1] << 1;
    }
    for (n = 0; n <= max_code; n++) {
      let len = tree[n * 2 + 1];
      if (len === 0) {
        continue;
      }
      tree[n * 2] = _zlib_Pako_trees.bi_reverse(next_code[len]++, len);
    }
  }
  /* ===========================================================================
   * Initialize the various 'constant' tables.
   */
  static tr_static_init() {
    let n;
    let bits;
    let length;
    let code;
    let dist;
    const bl_count = new Uint16Array(_zlib_Pako_trees.MAX_BITS + 1);
    length = 0;
    for (code = 0; code < _zlib_Pako_trees.LENGTH_CODES - 1; code++) {
      _zlib_Pako_trees.base_length[code] = length;
      for (n = 0; n < 1 << _zlib_Pako_trees.extra_lbits[code]; n++) {
        _zlib_Pako_trees._length_code[length++] = code;
      }
    }
    _zlib_Pako_trees._length_code[length - 1] = code;
    dist = 0;
    for (code = 0; code < 16; code++) {
      _zlib_Pako_trees.base_dist[code] = dist;
      for (n = 0; n < 1 << _zlib_Pako_trees.extra_dbits[code]; n++) {
        _zlib_Pako_trees._dist_code[dist++] = code;
      }
    }
    dist >>= 7;
    for (; code < _zlib_Pako_trees.D_CODES; code++) {
      _zlib_Pako_trees.base_dist[code] = dist << 7;
      for (n = 0; n < 1 << _zlib_Pako_trees.extra_dbits[code] - 7; n++) {
        _zlib_Pako_trees._dist_code[256 + dist++] = code;
      }
    }
    for (bits = 0; bits <= _zlib_Pako_trees.MAX_BITS; bits++) {
      bl_count[bits] = 0;
    }
    n = 0;
    while (n <= 143) {
      _zlib_Pako_trees.static_ltree[n * 2 + 1] = 8;
      n++;
      bl_count[8]++;
    }
    while (n <= 255) {
      _zlib_Pako_trees.static_ltree[n * 2 + 1] = 9;
      n++;
      bl_count[9]++;
    }
    while (n <= 279) {
      _zlib_Pako_trees.static_ltree[n * 2 + 1] = 7;
      n++;
      bl_count[7]++;
    }
    while (n <= 287) {
      _zlib_Pako_trees.static_ltree[n * 2 + 1] = 8;
      n++;
      bl_count[8]++;
    }
    _zlib_Pako_trees.gen_codes(_zlib_Pako_trees.static_ltree, _zlib_Pako_trees.L_CODES + 1, bl_count);
    for (n = 0; n < _zlib_Pako_trees.D_CODES; n++) {
      _zlib_Pako_trees.static_dtree[n * 2 + 1] = 5;
      _zlib_Pako_trees.static_dtree[n * 2] = _zlib_Pako_trees.bi_reverse(n, 5);
    }
    _zlib_Pako_trees.static_l_desc = new zlib_StaticTreeDesc(_zlib_Pako_trees.static_ltree, _zlib_Pako_trees.extra_lbits, _zlib_Pako_trees.LITERALS + 1, _zlib_Pako_trees.L_CODES, _zlib_Pako_trees.MAX_BITS);
    _zlib_Pako_trees.static_d_desc = new zlib_StaticTreeDesc(_zlib_Pako_trees.static_dtree, _zlib_Pako_trees.extra_dbits, 0, _zlib_Pako_trees.D_CODES, _zlib_Pako_trees.MAX_BITS);
    _zlib_Pako_trees.static_bl_desc = new zlib_StaticTreeDesc(new Uint16Array(0), _zlib_Pako_trees.extra_blbits, 0, _zlib_Pako_trees.BL_CODES, _zlib_Pako_trees.MAX_BL_BITS);
  }
  /* ===========================================================================
   * Initialize a new block.
   */
  static init_block(s) {
    let n;
    for (n = 0; n < _zlib_Pako_trees.L_CODES; n++) {
      s.dyn_ltree[n * 2] = 0;
    }
    for (n = 0; n < _zlib_Pako_trees.D_CODES; n++) {
      s.dyn_dtree[n * 2] = 0;
    }
    for (n = 0; n < _zlib_Pako_trees.BL_CODES; n++) {
      s.bl_tree[n * 2] = 0;
    }
    s.dyn_ltree[_zlib_Pako_trees.END_BLOCK * 2] = 1;
    s.opt_len = s.static_len = 0;
    s.last_lit = s.matches = 0;
  }
  /* ===========================================================================
   * Flush the bit buffer and align the output on a byte boundary
   */
  static bi_windup(s) {
    if (s.bi_valid > 8) {
      _zlib_Pako_trees.put_short(s, s.bi_buf);
    } else if (s.bi_valid > 0) {
      s.pending_buf[s.pending++] = s.bi_buf;
    }
    s.bi_buf = 0;
    s.bi_valid = 0;
  }
  /* ===========================================================================
   * Copy a stored block, storing first the length and its
   * one's complement if requested.
   */
  static copy_block(s, buf, len, header) {
    _zlib_Pako_trees.bi_windup(s);
    if (header) {
      _zlib_Pako_trees.put_short(s, len);
      _zlib_Pako_trees.put_short(s, ~len);
    }
    s.pending_buf.set(s.window.subarray(buf, buf + len), s.pending);
    s.pending += len;
  }
  /* ===========================================================================
   * Compares to subtrees, using the tree depth as tie breaker when
   * the subtrees have equal frequency. This minimizes the worst case length.
   */
  static smaller(tree, n, m, depth) {
    const _n2 = n * 2;
    const _m2 = m * 2;
    return tree[_n2] < tree[_m2] || tree[_n2] === tree[_m2] && depth[n] <= depth[m];
  }
  /* ===========================================================================
   * Restore the heap property by moving down the tree starting at node k,
   * exchanging a node with the smallest of its two sons if necessary, stopping
   * when the heap property is re-established (each father smaller than its
   * two sons).
   */
  static pqdownheap(s, tree, k) {
    const v = s.heap[k];
    let j = k << 1;
    while (j <= s.heap_len) {
      if (j < s.heap_len && _zlib_Pako_trees.smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
        j++;
      }
      if (_zlib_Pako_trees.smaller(tree, v, s.heap[j], s.depth)) {
        break;
      }
      s.heap[k] = s.heap[j];
      k = j;
      j <<= 1;
    }
    s.heap[k] = v;
  }
  // inlined manually
  // const SMALLEST = 1;
  /* ===========================================================================
   * Send the block data compressed using the given Huffman trees
   */
  static compress_block(s, ltree, dtree) {
    let dist;
    let lc;
    let lx = 0;
    let code;
    let extra;
    if (s.last_lit !== 0) {
      do {
        dist = s.pending_buf[s.d_buf + lx * 2] << 8 | s.pending_buf[s.d_buf + lx * 2 + 1];
        lc = s.pending_buf[s.l_buf + lx];
        lx++;
        if (dist === 0) {
          _zlib_Pako_trees.send_code(s, lc, ltree);
        } else {
          code = _zlib_Pako_trees._length_code[lc];
          _zlib_Pako_trees.send_code(s, code + _zlib_Pako_trees.LITERALS + 1, ltree);
          extra = _zlib_Pako_trees.extra_lbits[code];
          if (extra !== 0) {
            lc -= _zlib_Pako_trees.base_length[code];
            _zlib_Pako_trees.send_bits(s, lc, extra);
          }
          dist--;
          code = _zlib_Pako_trees.d_code(dist);
          _zlib_Pako_trees.send_code(s, code, dtree);
          extra = _zlib_Pako_trees.extra_dbits[code];
          if (extra !== 0) {
            dist -= _zlib_Pako_trees.base_dist[code];
            _zlib_Pako_trees.send_bits(s, dist, extra);
          }
        }
      } while (lx < s.last_lit);
    }
    _zlib_Pako_trees.send_code(s, _zlib_Pako_trees.END_BLOCK, ltree);
  }
  /* ===========================================================================
   * Construct one Huffman tree and assigns the code bit strings and lengths.
   * Update the total bit length for the current block.
   * IN assertion: the field freq is set for all tree elements.
   * OUT assertions: the fields len and code are set to the optimal bit length
   *     and corresponding code. The length opt_len is updated; static_len is
   *     also updated if stree is not null. The field max_code is set.
   */
  static build_tree(s, desc) {
    const tree = desc.dyn_tree;
    const stree = desc.stat_desc.static_tree;
    const has_stree = desc.stat_desc.has_stree;
    const elems = desc.stat_desc.elems;
    let n, m;
    let max_code = -1;
    let node;
    s.heap_len = 0;
    s.heap_max = _zlib_Pako_trees.HEAP_SIZE;
    for (n = 0; n < elems; n++) {
      if (tree[n * 2] !== 0) {
        s.heap[++s.heap_len] = max_code = n;
        s.depth[n] = 0;
      } else {
        tree[n * 2 + 1] = 0;
      }
    }
    while (s.heap_len < 2) {
      node = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0;
      tree[node * 2] = 1;
      s.depth[node] = 0;
      s.opt_len--;
      if (has_stree) {
        s.static_len -= stree[node * 2 + 1];
      }
    }
    desc.max_code = max_code;
    for (n = s.heap_len >> 1; n >= 1; n--) {
      _zlib_Pako_trees.pqdownheap(s, tree, n);
    }
    node = elems;
    do {
      n = s.heap[
        1
        /*SMALLEST*/
      ];
      s.heap[
        1
        /*SMALLEST*/
      ] = s.heap[s.heap_len--];
      _zlib_Pako_trees.pqdownheap(
        s,
        tree,
        1
        /*SMALLEST*/
      );
      m = s.heap[
        1
        /*SMALLEST*/
      ];
      s.heap[--s.heap_max] = n;
      s.heap[--s.heap_max] = m;
      tree[node * 2] = tree[n * 2] + tree[m * 2];
      s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
      tree[n * 2 + 1] = tree[m * 2 + 1] = node;
      s.heap[
        1
        /*SMALLEST*/
      ] = node++;
      _zlib_Pako_trees.pqdownheap(
        s,
        tree,
        1
        /*SMALLEST*/
      );
    } while (s.heap_len >= 2);
    s.heap[--s.heap_max] = s.heap[
      1
      /*SMALLEST*/
    ];
    _zlib_Pako_trees.gen_bitlen(s, desc);
    _zlib_Pako_trees.gen_codes(tree, max_code, s.bl_count);
  }
  /* ===========================================================================
   * Scan a literal or distance tree to determine the frequencies of the codes
   * in the bit length tree.
   */
  static scan_tree(s, tree, max_code) {
    let n;
    let prevlen = -1;
    let curlen;
    let nextlen = tree[0 * 2 + 1];
    let count = 0;
    let max_count = 7;
    let min_count = 4;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    }
    tree[(max_code + 1) * 2 + 1] = 65535;
    for (n = 0; n <= max_code; n++) {
      curlen = nextlen;
      nextlen = tree[(n + 1) * 2 + 1];
      if (++count < max_count && curlen === nextlen) {
        continue;
      } else if (count < min_count) {
        s.bl_tree[curlen * 2] += count;
      } else if (curlen !== 0) {
        if (curlen !== prevlen) {
          s.bl_tree[curlen * 2]++;
        }
        s.bl_tree[_zlib_Pako_trees.REP_3_6 * 2]++;
      } else if (count <= 10) {
        s.bl_tree[_zlib_Pako_trees.REPZ_3_10 * 2]++;
      } else {
        s.bl_tree[_zlib_Pako_trees.REPZ_11_138 * 2]++;
      }
      count = 0;
      prevlen = curlen;
      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      } else if (curlen === nextlen) {
        max_count = 6;
        min_count = 3;
      } else {
        max_count = 7;
        min_count = 4;
      }
    }
  }
  /* ===========================================================================
   * Send a literal or distance tree in compressed form, using the codes in
   * bl_tree.
   */
  static send_tree(s, tree, max_code) {
    let n;
    let prevlen = -1;
    let curlen;
    let nextlen = tree[0 * 2 + 1];
    let count = 0;
    let max_count = 7;
    let min_count = 4;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    }
    for (n = 0; n <= max_code; n++) {
      curlen = nextlen;
      nextlen = tree[(n + 1) * 2 + 1];
      if (++count < max_count && curlen === nextlen) {
        continue;
      } else if (count < min_count) {
        do {
          _zlib_Pako_trees.send_code(s, curlen, s.bl_tree);
        } while (--count !== 0);
      } else if (curlen !== 0) {
        if (curlen !== prevlen) {
          _zlib_Pako_trees.send_code(s, curlen, s.bl_tree);
          count--;
        }
        _zlib_Pako_trees.send_code(s, _zlib_Pako_trees.REP_3_6, s.bl_tree);
        _zlib_Pako_trees.send_bits(s, count - 3, 2);
      } else if (count <= 10) {
        _zlib_Pako_trees.send_code(s, _zlib_Pako_trees.REPZ_3_10, s.bl_tree);
        _zlib_Pako_trees.send_bits(s, count - 3, 3);
      } else {
        _zlib_Pako_trees.send_code(s, _zlib_Pako_trees.REPZ_11_138, s.bl_tree);
        _zlib_Pako_trees.send_bits(s, count - 11, 7);
      }
      count = 0;
      prevlen = curlen;
      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      } else if (curlen === nextlen) {
        max_count = 6;
        min_count = 3;
      } else {
        max_count = 7;
        min_count = 4;
      }
    }
  }
  /* ===========================================================================
   * Construct the Huffman tree for the bit lengths and return the index in
   * bl_order of the last bit length code to send.
   */
  static build_bl_tree(s) {
    let max_blindex;
    _zlib_Pako_trees.scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
    _zlib_Pako_trees.scan_tree(s, s.dyn_dtree, s.d_desc.max_code);
    _zlib_Pako_trees.build_tree(s, s.bl_desc);
    for (max_blindex = _zlib_Pako_trees.BL_CODES - 1; max_blindex >= 3; max_blindex--) {
      if (s.bl_tree[_zlib_Pako_trees.bl_order[max_blindex] * 2 + 1] !== 0) {
        break;
      }
    }
    s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
    return max_blindex;
  }
  /* ===========================================================================
   * Send the header for a block using dynamic Huffman trees: the counts, the
   * lengths of the bit length codes, the literal tree and the distance tree.
   * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.
   */
  static send_all_trees(s, lcodes, dcodes, blcodes) {
    let rank;
    _zlib_Pako_trees.send_bits(s, lcodes - 257, 5);
    _zlib_Pako_trees.send_bits(s, dcodes - 1, 5);
    _zlib_Pako_trees.send_bits(s, blcodes - 4, 4);
    for (rank = 0; rank < blcodes; rank++) {
      _zlib_Pako_trees.send_bits(s, s.bl_tree[_zlib_Pako_trees.bl_order[rank] * 2 + 1], 3);
    }
    _zlib_Pako_trees.send_tree(s, s.dyn_ltree, lcodes - 1);
    _zlib_Pako_trees.send_tree(s, s.dyn_dtree, dcodes - 1);
  }
  /* ===========================================================================
   * Check if the data type is TEXT or BINARY, using the following algorithm:
   * - TEXT if the two conditions below are satisfied:
   *    a) There are no non-portable control characters belonging to the
   *       "black list" (0..6, 14..25, 28..31).
   *    b) There is at least one printable character belonging to the
   *       "white list" (9 {TAB}, 10 {LF}, 13 {CR}, 32..255).
   * - BINARY otherwise.
   * - The following partially-portable control characters form a
   *   "gray list" that is ignored in this detection algorithm:
   *   (7 {BEL}, 8 {BS}, 11 {VT}, 12 {FF}, 26 {SUB}, 27 {ESC}).
   * IN assertion: the fields Freq of dyn_ltree are set.
   */
  static detect_data_type(s) {
    let black_mask = 4093624447;
    let n;
    for (n = 0; n <= 31; n++, black_mask >>>= 1) {
      if (black_mask & 1 && s.dyn_ltree[n * 2] !== 0) {
        return zlib_constants.Z_BINARY;
      }
    }
    if (s.dyn_ltree[9 * 2] !== 0 || s.dyn_ltree[10 * 2] !== 0 || s.dyn_ltree[13 * 2] !== 0) {
      return zlib_constants.Z_TEXT;
    }
    for (n = 32; n < _zlib_Pako_trees.LITERALS; n++) {
      if (s.dyn_ltree[n * 2] !== 0) {
        return zlib_constants.Z_TEXT;
      }
    }
    return zlib_constants.Z_BINARY;
  }
  /* ===========================================================================
   * Initialize the tree data structures for a new zlib stream.
   */
  static _tr_init(s) {
    if (!_zlib_Pako_trees.static_init_done) {
      _zlib_Pako_trees.tr_static_init();
      _zlib_Pako_trees.static_init_done = true;
    }
    s.l_desc = new zlib_TreeDesc(s.dyn_ltree, _zlib_Pako_trees.static_l_desc);
    s.d_desc = new zlib_TreeDesc(s.dyn_dtree, _zlib_Pako_trees.static_d_desc);
    s.bl_desc = new zlib_TreeDesc(s.bl_tree, _zlib_Pako_trees.static_bl_desc);
    s.bi_buf = 0;
    s.bi_valid = 0;
    _zlib_Pako_trees.init_block(s);
  }
  /* ===========================================================================
   * Send a stored block
   */
  static _tr_stored_block(s, buf, stored_len, last) {
    _zlib_Pako_trees.send_bits(s, (_zlib_Pako_trees.STORED_BLOCK << 1) + (last ? 1 : 0), 3);
    _zlib_Pako_trees.copy_block(s, buf, stored_len, true);
  }
  /* ===========================================================================
   * Send one empty static block to give enough lookahead for inflate.
   * This takes 10 bits, of which 7 may remain in the bit buffer.
   */
  static _tr_align(s) {
    _zlib_Pako_trees.send_bits(s, _zlib_Pako_trees.STATIC_TREES << 1, 3);
    _zlib_Pako_trees.send_code(s, _zlib_Pako_trees.END_BLOCK, _zlib_Pako_trees.static_ltree);
    _zlib_Pako_trees.bi_flush(s);
  }
  /* ===========================================================================
   * Determine the best encoding for the current block: dynamic trees, static
   * trees or store, and output the encoded block to the zip file.
   */
  static _tr_flush_block(s, buf, stored_len, last) {
    let opt_lenb;
    let static_lenb;
    let max_blindex = 0;
    if (s.level > 0) {
      if (s.strm.data_type === zlib_constants.Z_UNKNOWN) {
        s.strm.data_type = _zlib_Pako_trees.detect_data_type(s);
      }
      _zlib_Pako_trees.build_tree(s, s.l_desc);
      _zlib_Pako_trees.build_tree(s, s.d_desc);
      max_blindex = _zlib_Pako_trees.build_bl_tree(s);
      opt_lenb = s.opt_len + 3 + 7 >>> 3;
      static_lenb = s.static_len + 3 + 7 >>> 3;
      if (static_lenb <= opt_lenb) {
        opt_lenb = static_lenb;
      }
    } else {
      opt_lenb = static_lenb = stored_len + 5;
    }
    if (stored_len + 4 <= opt_lenb && buf !== -1) {
      _zlib_Pako_trees._tr_stored_block(s, buf, stored_len, last);
    } else if (s.strategy === zlib_constants.Z_FIXED || static_lenb === opt_lenb) {
      _zlib_Pako_trees.send_bits(s, (_zlib_Pako_trees.STATIC_TREES << 1) + (last ? 1 : 0), 3);
      _zlib_Pako_trees.compress_block(s, _zlib_Pako_trees.static_ltree, _zlib_Pako_trees.static_dtree);
    } else {
      _zlib_Pako_trees.send_bits(s, (_zlib_Pako_trees.DYN_TREES << 1) + (last ? 1 : 0), 3);
      _zlib_Pako_trees.send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
      _zlib_Pako_trees.compress_block(s, s.dyn_ltree, s.dyn_dtree);
    }
    _zlib_Pako_trees.init_block(s);
    if (last) {
      _zlib_Pako_trees.bi_windup(s);
    }
  }
  /* ===========================================================================
   * Save the match info and tally the frequency counts. Return true if
   * the current block must be flushed.
   */
  static _tr_tally(s, dist, lc) {
    s.pending_buf[s.d_buf + s.last_lit * 2] = dist >>> 8 & 255;
    s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 255;
    s.pending_buf[s.l_buf + s.last_lit] = lc & 255;
    s.last_lit++;
    if (dist === 0) {
      s.dyn_ltree[lc * 2]++;
    } else {
      s.matches++;
      dist--;
      s.dyn_ltree[(_zlib_Pako_trees._length_code[lc] + _zlib_Pako_trees.LITERALS + 1) * 2]++;
      s.dyn_dtree[_zlib_Pako_trees.d_code(dist) * 2]++;
    }
    return s.last_lit === s.lit_bufsize - 1;
  }
};
zlib_Pako_trees.Z_FIXED = 4;
zlib_Pako_trees.Z_BINARY = 0;
zlib_Pako_trees.Z_TEXT = 1;
zlib_Pako_trees.Z_UNKNOWN = 2;
zlib_Pako_trees.STORED_BLOCK = 0;
zlib_Pako_trees.STATIC_TREES = 1;
zlib_Pako_trees.DYN_TREES = 2;
zlib_Pako_trees.MIN_MATCH = 3;
zlib_Pako_trees.MAX_MATCH = 258;
zlib_Pako_trees.LENGTH_CODES = 29;
zlib_Pako_trees.LITERALS = 256;
zlib_Pako_trees.L_CODES = zlib_Pako_trees.LITERALS + 1 + zlib_Pako_trees.LENGTH_CODES;
zlib_Pako_trees.D_CODES = 30;
zlib_Pako_trees.BL_CODES = 19;
zlib_Pako_trees.HEAP_SIZE = 2 * zlib_Pako_trees.L_CODES + 1;
zlib_Pako_trees.MAX_BITS = 15;
zlib_Pako_trees.Buf_size = 16;
zlib_Pako_trees.MAX_BL_BITS = 7;
zlib_Pako_trees.END_BLOCK = 256;
zlib_Pako_trees.REP_3_6 = 16;
zlib_Pako_trees.REPZ_3_10 = 17;
zlib_Pako_trees.REPZ_11_138 = 18;
zlib_Pako_trees.extra_lbits = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0]);
zlib_Pako_trees.extra_dbits = new Uint8Array([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]);
zlib_Pako_trees.extra_blbits = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7]);
zlib_Pako_trees.bl_order = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
zlib_Pako_trees.DIST_CODE_LEN = 512;
zlib_Pako_trees.static_ltree = new Uint16Array((zlib_Pako_trees.L_CODES + 2) * 2);
zlib_Pako_trees.static_dtree = new Uint16Array(zlib_Pako_trees.D_CODES * 2);
zlib_Pako_trees._dist_code = new Uint16Array(zlib_Pako_trees.DIST_CODE_LEN);
zlib_Pako_trees._length_code = new Uint16Array(zlib_Pako_trees.MAX_MATCH - zlib_Pako_trees.MIN_MATCH + 1);
zlib_Pako_trees.base_length = new Uint16Array(zlib_Pako_trees.LENGTH_CODES);
zlib_Pako_trees.base_dist = new Uint16Array(zlib_Pako_trees.D_CODES);
zlib_Pako_trees.send_bits = (s, value, length) => {
  if (s.bi_valid > zlib_Pako_trees.Buf_size - length) {
    s.bi_buf |= value << s.bi_valid & 65535;
    zlib_Pako_trees.put_short(s, s.bi_buf);
    s.bi_buf = value >> zlib_Pako_trees.Buf_size - s.bi_valid;
    s.bi_valid += length - zlib_Pako_trees.Buf_size;
  } else {
    s.bi_buf |= value << s.bi_valid & 65535;
    s.bi_valid += length;
  }
};
zlib_Pako_trees.gen_bitlen = (s, desc) => {
  const tree = desc.dyn_tree;
  const max_code = desc.max_code;
  const stree = desc.stat_desc.static_tree;
  const has_stree = desc.stat_desc.has_stree;
  const extra = desc.stat_desc.extra_bits;
  const base = desc.stat_desc.extra_base;
  const max_length = desc.stat_desc.max_length;
  let h;
  let n, m;
  let bits;
  let xbits;
  let f;
  let overflow = 0;
  for (bits = 0; bits <= zlib_Pako_trees.MAX_BITS; bits++) {
    s.bl_count[bits] = 0;
  }
  tree[s.heap[s.heap_max] * 2 + 1] = 0;
  for (h = s.heap_max + 1; h < zlib_Pako_trees.HEAP_SIZE; h++) {
    n = s.heap[h];
    bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;
    if (bits > max_length) {
      bits = max_length;
      overflow++;
    }
    tree[n * 2 + 1] = bits;
    if (n > max_code) {
      continue;
    }
    s.bl_count[bits]++;
    xbits = 0;
    if (n >= base) {
      xbits = extra[n - base];
    }
    f = tree[n * 2];
    s.opt_len += f * (bits + xbits);
    if (has_stree) {
      s.static_len += f * (stree[n * 2 + 1] + xbits);
    }
  }
  if (overflow === 0) {
    return;
  }
  do {
    bits = max_length - 1;
    while (s.bl_count[bits] === 0) {
      bits--;
    }
    s.bl_count[bits]--;
    s.bl_count[bits + 1] += 2;
    s.bl_count[max_length]--;
    overflow -= 2;
  } while (overflow > 0);
  for (bits = max_length; bits !== 0; bits--) {
    n = s.bl_count[bits];
    while (n !== 0) {
      m = s.heap[--h];
      if (m > max_code) {
        continue;
      }
      if (tree[m * 2 + 1] !== bits) {
        s.opt_len += (bits - tree[m * 2 + 1]) * tree[m * 2];
        tree[m * 2 + 1] = bits;
      }
      n--;
    }
  }
};
zlib_Pako_trees.static_init_done = false;
zlib_Pako_trees.initDone = zlib_Pako_trees.Zeroinit();

// obj/full/Pako/zlib/gzheader.js
var zlib_GZheader = class {
  constructor() {
    this.text = 0;
    this.time = 0;
    this.xflags = 0;
    this.os = 0;
    this.extra = null;
    this.extra_len = 0;
    this.name = "";
    this.comment = "";
    this.hcrc = 0;
    this.done = false;
  }
};

// obj/full/Pako/zlib/inffast.js
var zlib_inffast = class _zlib_inffast {
  /*
         Decode literal, length, and distance codes and write out the resulting
         literal and match bytes until either not enough input or output is
         available, an end-of-block is encountered, or a data error is encountered.
         When large enough input and output buffers are supplied to inflate(), for
         example, a 16K input buffer and a 64K output buffer, more than 95% of the
         inflate execution time is spent in this routine.
  
         Entry assumptions:
  
              state.mode === LEN
              strm.avail_in >= 6
              strm.avail_out >= 258
              start >= strm.avail_out
              state.bits < 8
  
         On return, state.mode is one of:
  
              LEN -- ran out of enough output space or enough available input
              TYPE -- reached end of block code, inflate() to interpret next block
              BAD -- error in block data
  
         Notes:
  
          - The maximum input bits used by a length/distance pair is 15 bits for the
            length code, 5 bits for the length extra, 15 bits for the distance code,
            and 13 bits for the distance extra.  This totals 48 bits, or six bytes.
            Therefore if strm.avail_in >= 6, then there is enough input to avoid
            checking for available input while decoding.
  
          - The maximum bytes that a single length/distance pair can output is 258
            bytes, which is the maximum length that can be coded.  inflate_fast()
            requires strm.avail_out >= 258 for each loop to avoid checking for
            output space.
       */
  static inflate_fast(strm, start) {
    let _in;
    let last;
    let _out;
    let beg;
    let end;
    let wsize;
    let whave;
    let wnext;
    let s_window;
    let hold;
    let bits;
    let lcode;
    let dcode;
    let lmask;
    let dmask;
    let here;
    let op;
    let len;
    let dist;
    let from;
    let from_source;
    let input;
    let output;
    let state = strm.state;
    _in = strm.next_in;
    input = strm.input;
    last = _in + (strm.avail_in - 5);
    _out = strm.next_out;
    output = strm.output;
    beg = _out - (start - strm.avail_out);
    end = _out + (strm.avail_out - 257);
    wsize = state.wsize;
    whave = state.whave;
    wnext = state.wnext;
    s_window = state.window;
    hold = state.hold;
    bits = state.bits;
    lcode = state.lencode;
    dcode = state.distcode;
    lmask = (1 << state.lenbits) - 1;
    dmask = (1 << state.distbits) - 1;
    top: do {
      if (bits < 15) {
        hold += input[_in++] << bits;
        bits += 8;
        hold += input[_in++] << bits;
        bits += 8;
      }
      here = lcode[hold & lmask];
      dolen: for (; ; ) {
        op = here >>> 24;
        hold >>>= op;
        bits -= op;
        op = here >>> 16 & 255;
        if (op === 0) {
          output[_out++] = here & 65535;
        } else if (op & 16) {
          len = here & 65535;
          op &= 15;
          if (op) {
            if (bits < op) {
              hold += input[_in++] << bits;
              bits += 8;
            }
            len += hold & (1 << op) - 1;
            hold >>>= op;
            bits -= op;
          }
          if (bits < 15) {
            hold += input[_in++] << bits;
            bits += 8;
            hold += input[_in++] << bits;
            bits += 8;
          }
          here = dcode[hold & dmask];
          dodist: for (; ; ) {
            op = here >>> 24;
            hold >>>= op;
            bits -= op;
            op = here >>> 16 & 255;
            if (op & 16) {
              dist = here & 65535;
              op &= 15;
              if (bits < op) {
                hold += input[_in++] << bits;
                bits += 8;
                if (bits < op) {
                  hold += input[_in++] << bits;
                  bits += 8;
                }
              }
              dist += hold & (1 << op) - 1;
              hold >>>= op;
              bits -= op;
              op = _out - beg;
              if (dist > op) {
                op = dist - op;
                if (op > whave) {
                  if (state.sane) {
                    strm.msg = "invalid distance too far back";
                    state.mode = _zlib_inffast.BAD;
                    break top;
                  }
                }
                from = 0;
                from_source = s_window;
                if (wnext === 0) {
                  from += wsize - op;
                  if (op < len) {
                    len -= op;
                    do {
                      output[_out++] = s_window[from++];
                    } while (--op);
                    from = _out - dist;
                    from_source = output;
                  }
                } else if (wnext < op) {
                  from += wsize + wnext - op;
                  op -= wnext;
                  if (op < len) {
                    len -= op;
                    do {
                      output[_out++] = s_window[from++];
                    } while (--op);
                    from = 0;
                    if (wnext < len) {
                      op = wnext;
                      len -= op;
                      do {
                        output[_out++] = s_window[from++];
                      } while (--op);
                      from = _out - dist;
                      from_source = output;
                    }
                  }
                } else {
                  from += wnext - op;
                  if (op < len) {
                    len -= op;
                    do {
                      output[_out++] = s_window[from++];
                    } while (--op);
                    from = _out - dist;
                    from_source = output;
                  }
                }
                while (len > 2) {
                  output[_out++] = from_source[from++];
                  output[_out++] = from_source[from++];
                  output[_out++] = from_source[from++];
                  len -= 3;
                }
                if (len) {
                  output[_out++] = from_source[from++];
                  if (len > 1) {
                    output[_out++] = from_source[from++];
                  }
                }
              } else {
                from = _out - dist;
                do {
                  output[_out++] = output[from++];
                  output[_out++] = output[from++];
                  output[_out++] = output[from++];
                  len -= 3;
                } while (len > 2);
                if (len) {
                  output[_out++] = output[from++];
                  if (len > 1) {
                    output[_out++] = output[from++];
                  }
                }
              }
            } else if ((op & 64) === 0) {
              here = dcode[(here & 65535) + (hold & (1 << op) - 1)];
              continue dodist;
            } else {
              strm.msg = "invalid distance code";
              state.mode = _zlib_inffast.BAD;
              break top;
            }
            break;
          }
        } else if ((op & 64) === 0) {
          here = lcode[(here & 65535) + (hold & (1 << op) - 1)];
          continue dolen;
        } else if (op & 32) {
          state.mode = _zlib_inffast.TYPE;
          break top;
        } else {
          strm.msg = "invalid literal/length code";
          state.mode = _zlib_inffast.BAD;
          break top;
        }
        break;
      }
    } while (_in < last && _out < end);
    len = bits >> 3;
    _in -= len;
    bits -= len << 3;
    hold &= (1 << bits) - 1;
    strm.next_in = _in;
    strm.next_out = _out;
    strm.avail_in = _in < last ? 5 + (last - _in) : 5 - (_in - last);
    strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);
    state.hold = hold;
    state.bits = bits;
    return;
  }
};
zlib_inffast.BAD = 30;
zlib_inffast.TYPE = 12;

// obj/full/Pako/zlib/inflate.js
var zlib_InflateState = class {
  constructor() {
    this.mode = 0;
    this.last = 0;
    this.wrap = 0;
    this.havedict = 0;
    this.flags = 0;
    this.dmax = 0;
    this.check = 0;
    this.total = 0;
    this.head = null;
    this.wbits = 0;
    this.wsize = 0;
    this.whave = 0;
    this.wnext = 0;
    this.window = null;
    this.hold = 0;
    this.bits = 0;
    this.length = 0;
    this.offset = 0;
    this.extra = 0;
    this.lencode = null;
    this.distcode = null;
    this.lenbits = 0;
    this.distbits = 0;
    this.ncode = 0;
    this.nlen = 0;
    this.ndist = 0;
    this.have = 0;
    this.next = null;
    this.lens = new Uint16Array(320);
    this.work = new Uint16Array(288);
    this.lendyn = null;
    this.distdyn = null;
    this.sane = 0;
    this.back = 0;
    this.was = 0;
  }
};
var zlib_inflate = class _zlib_inflate {
  static zswap32(q) {
    return (q >>> 24 & 255) + (q >>> 8 & 65280) + ((q & 65280) << 8) + ((q & 255) << 24);
  }
  static inflateResetKeep(strm) {
    if (!strm || !strm.state) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    let state = strm.state;
    strm.total_in = strm.total_out = state.total = 0;
    strm.msg = "";
    if (state.wrap) {
      strm.adler = state.wrap & 1;
    }
    state.mode = _zlib_inflate.HEAD;
    state.last = 0;
    state.havedict = 0;
    state.dmax = 32768;
    state.head = null;
    state.hold = 0;
    state.bits = 0;
    state.lencode = state.lendyn = new Int32Array(_zlib_inflate.ENOUGH_LENS);
    state.distcode = state.distdyn = new Int32Array(_zlib_inflate.ENOUGH_DISTS);
    state.sane = 1;
    state.back = -1;
    return zlib_constants.Z_OK;
  }
  static inflateReset(strm) {
    if (!strm || !strm.state) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    const state = strm.state;
    state.wsize = 0;
    state.whave = 0;
    state.wnext = 0;
    return _zlib_inflate.inflateResetKeep(strm);
  }
  static inflateReset2(strm, windowBits) {
    let wrap;
    if (!strm || !strm.state) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    let state = strm.state;
    if (windowBits < 0) {
      wrap = 0;
      windowBits = -windowBits;
    } else {
      wrap = (windowBits >> 4) + 1;
      if (windowBits < 48) {
        windowBits &= 15;
      }
    }
    if (windowBits && (windowBits < 8 || windowBits > 15)) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    if (state.window !== null && state.wbits !== windowBits) {
      state.window = null;
    }
    state.wrap = wrap;
    state.wbits = windowBits;
    return _zlib_inflate.inflateReset(strm);
  }
  static inflateInit2(strm, windowBits) {
    if (!strm) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    let state = new zlib_InflateState();
    strm.state = state;
    state.window = null;
    const ret = _zlib_inflate.inflateReset2(strm, windowBits);
    if (ret !== zlib_constants.Z_OK) {
      strm.state = null;
    }
    return ret;
  }
  static inflateInit(strm) {
    return _zlib_inflate.inflateInit2(strm, _zlib_inflate.DEF_WBITS);
  }
  static fixedtables(state) {
    if (_zlib_inflate.virgin) {
      _zlib_inflate.lenfix = new Int32Array(512);
      _zlib_inflate.distfix = new Int32Array(32);
      let sym = 0;
      while (sym < 144) {
        state.lens[sym++] = 8;
      }
      while (sym < 256) {
        state.lens[sym++] = 9;
      }
      while (sym < 280) {
        state.lens[sym++] = 7;
      }
      while (sym < 288) {
        state.lens[sym++] = 8;
      }
      zlib_inftrees.inflate_table(_zlib_inflate.LENS, state.lens, 0, 288, _zlib_inflate.lenfix, 0, state.work, { bits: 9 });
      sym = 0;
      while (sym < 32) {
        state.lens[sym++] = 5;
      }
      zlib_inftrees.inflate_table(_zlib_inflate.DISTS, state.lens, 0, 32, _zlib_inflate.distfix, 0, state.work, { bits: 5 });
      _zlib_inflate.virgin = false;
    }
    state.lencode = _zlib_inflate.lenfix;
    state.lenbits = 9;
    state.distcode = _zlib_inflate.distfix;
    state.distbits = 5;
  }
  /*
       Update the window with the last wsize (normally 32K) bytes written before
       returning.  If window does not exist yet, create it.  This is only called
       when a window is already in use, or when output has been written during this
       inflate call, but the end of the deflate stream has not been reached yet.
       It is also called to create a window for dictionary data when a dictionary
       is loaded.
  
       Providing output buffers larger than 32K to inflate() should provide a speed
       advantage, since only the last 32K of output is copied to the sliding window
       upon return from inflate(), and since all distances after the first 32K of
       output will fall in the output data, making match copies simpler and faster.
       The advantage may be dependent on the size of the processor's data caches.
       */
  static updatewindow(strm, src, end, copy) {
    let dist;
    const state = strm.state;
    if (state.window === null) {
      state.wsize = 1 << state.wbits;
      state.wnext = 0;
      state.whave = 0;
      state.window = new Uint8Array(state.wsize);
    }
    if (copy >= state.wsize) {
      state.window.set(src.subarray(end - state.wsize, end), 0);
      state.wnext = 0;
      state.whave = state.wsize;
    } else {
      dist = state.wsize - state.wnext;
      if (dist > copy) {
        dist = copy;
      }
      state.window.set(src.subarray(end - copy, end - copy + dist), state.wnext);
      copy -= dist;
      if (copy) {
        state.window.set(src.subarray(end - copy, end), 0);
        state.wnext = copy;
        state.whave = state.wsize;
      } else {
        state.wnext += dist;
        if (state.wnext === state.wsize) {
          state.wnext = 0;
        }
        if (state.whave < state.wsize) {
          state.whave += dist;
        }
      }
    }
    return 0;
  }
  static inflate(strm, flush) {
    let state;
    let input, output;
    let next;
    let put;
    let have, left;
    let hold;
    let bits;
    let _in;
    let _out;
    let copy;
    let from;
    let from_source;
    let here = 0;
    let here_bits;
    let here_op;
    let here_val;
    let last_bits;
    let last_op;
    let last_val;
    let len;
    let ret;
    const hbuf = new Uint8Array(4);
    let opts;
    let n;
    let order = (
      /* permutation of code lengths */
      new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15])
    );
    if (!strm || !strm.state || !strm.output || !strm.input && strm.avail_in !== 0) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    state = strm.state;
    if (state.mode === _zlib_inflate.TYPE) {
      state.mode = _zlib_inflate.TYPEDO;
    }
    put = strm.next_out;
    output = strm.output;
    left = strm.avail_out;
    next = strm.next_in;
    input = strm.input;
    have = strm.avail_in;
    hold = state.hold;
    bits = state.bits;
    _in = have;
    _out = left;
    ret = zlib_constants.Z_OK;
    inf_leave:
      for (; ; ) {
        switch (state.mode) {
          case _zlib_inflate.HEAD:
            if (state.wrap === 0) {
              state.mode = _zlib_inflate.TYPEDO;
              break;
            }
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (state.wrap & 2 && hold === 35615) {
              state.check = 0;
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              state.check = zlib_crc32.crc32(state.check, hbuf, 2, 0);
              hold = 0;
              bits = 0;
              state.mode = _zlib_inflate.FLAGS;
              break;
            }
            state.flags = 0;
            if (state.head) {
              state.head.done = false;
            }
            if (!(state.wrap & 1) || /* check if zlib header allowed */
            (((hold & 255) << 8) + (hold >> 8)) % 31) {
              strm.msg = "incorrect header check";
              state.mode = _zlib_inflate.BAD;
              break;
            }
            if ((hold & 15) !== zlib_constants.Z_DEFLATED) {
              strm.msg = "unknown compression method";
              state.mode = _zlib_inflate.BAD;
              break;
            }
            hold >>>= 4;
            bits -= 4;
            len = (hold & 15) + 8;
            if (state.wbits === 0) {
              state.wbits = len;
            } else if (len > state.wbits) {
              strm.msg = "invalid window size";
              state.mode = _zlib_inflate.BAD;
              break;
            }
            state.dmax = 1 << state.wbits;
            strm.adler = state.check = 1;
            state.mode = hold & 512 ? _zlib_inflate.DICTID : _zlib_inflate.TYPE;
            hold = 0;
            bits = 0;
            break;
          case _zlib_inflate.FLAGS:
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.flags = hold;
            if ((state.flags & 255) !== zlib_constants.Z_DEFLATED) {
              strm.msg = "unknown compression method";
              state.mode = _zlib_inflate.BAD;
              break;
            }
            if (state.flags & 57344) {
              strm.msg = "unknown header flags set";
              state.mode = _zlib_inflate.BAD;
              break;
            }
            if (state.head) {
              state.head.text = hold >> 8 & 1;
            }
            if (state.flags & 512) {
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              state.check = zlib_crc32.crc32(state.check, hbuf, 2, 0);
            }
            hold = 0;
            bits = 0;
            state.mode = _zlib_inflate.TIME;
          /* falls through */
          case _zlib_inflate.TIME:
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (state.head) {
              state.head.time = hold;
            }
            if (state.flags & 512) {
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              hbuf[2] = hold >>> 16 & 255;
              hbuf[3] = hold >>> 24 & 255;
              state.check = zlib_crc32.crc32(state.check, hbuf, 4, 0);
            }
            hold = 0;
            bits = 0;
            state.mode = _zlib_inflate.OS;
          /* falls through */
          case _zlib_inflate.OS:
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (state.head) {
              state.head.xflags = hold & 255;
              state.head.os = hold >> 8;
            }
            if (state.flags & 512) {
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              state.check = zlib_crc32.crc32(state.check, hbuf, 2, 0);
            }
            hold = 0;
            bits = 0;
            state.mode = _zlib_inflate.EXLEN;
          /* falls through */
          case _zlib_inflate.EXLEN:
            if (state.flags & 1024) {
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.length = hold;
              if (state.head) {
                state.head.extra_len = hold;
              }
              if (state.flags & 512) {
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                state.check = zlib_crc32.crc32(state.check, hbuf, 2, 0);
              }
              hold = 0;
              bits = 0;
            } else if (state.head) {
              state.head.extra = null;
            }
            state.mode = _zlib_inflate.EXTRA;
          /* falls through */
          case _zlib_inflate.EXTRA:
            if (state.flags & 1024) {
              copy = state.length;
              if (copy > have) {
                copy = have;
              }
              if (copy) {
                if (state.head) {
                  len = state.head.extra_len - state.length;
                  if (!state.head.extra) {
                    state.head.extra = new Uint8Array(state.head.extra_len);
                  }
                  state.head.extra.set(
                    input.subarray(
                      next,
                      // extra field is limited to 65536 bytes
                      // - no need for additional size check
                      next + copy
                    ),
                    /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
                    len
                  );
                }
                if (state.flags & 512) {
                  state.check = zlib_crc32.crc32(state.check, input, copy, next);
                }
                have -= copy;
                next += copy;
                state.length -= copy;
              }
              if (state.length) {
                break inf_leave;
              }
            }
            state.length = 0;
            state.mode = _zlib_inflate.NAME;
          /* falls through */
          case _zlib_inflate.NAME:
            if (state.flags & 2048) {
              if (have === 0) {
                break inf_leave;
              }
              copy = 0;
              do {
                len = input[next + copy++];
                if (state.head && len && state.length < 65536) {
                  state.head.name += String.fromCharCode(len);
                }
              } while (len && copy < have);
              if (state.flags & 512) {
                state.check = zlib_crc32.crc32(state.check, input, copy, next);
              }
              have -= copy;
              next += copy;
              if (len) {
                break inf_leave;
              }
            } else if (state.head) {
              state.head.name = null;
            }
            state.length = 0;
            state.mode = _zlib_inflate.COMMENT;
          /* falls through */
          case _zlib_inflate.COMMENT:
            if (state.flags & 4096) {
              if (have === 0) {
                break inf_leave;
              }
              copy = 0;
              do {
                len = input[next + copy++];
                if (state.head && len && state.length < 65536) {
                  state.head.comment += String.fromCharCode(len);
                }
              } while (len && copy < have);
              if (state.flags & 512) {
                state.check = zlib_crc32.crc32(state.check, input, copy, next);
              }
              have -= copy;
              next += copy;
              if (len) {
                break inf_leave;
              }
            } else if (state.head) {
              state.head.comment = null;
            }
            state.mode = _zlib_inflate.HCRC;
          /* falls through */
          case _zlib_inflate.HCRC:
            if (state.flags & 512) {
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (hold !== (state.check & 65535)) {
                strm.msg = "header crc mismatch";
                state.mode = _zlib_inflate.BAD;
                break;
              }
              hold = 0;
              bits = 0;
            }
            if (state.head) {
              state.head.hcrc = state.flags >> 9 & 1;
              state.head.done = true;
            }
            strm.adler = state.check = 0;
            state.mode = _zlib_inflate.TYPE;
            break;
          case _zlib_inflate.DICTID:
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            strm.adler = state.check = _zlib_inflate.zswap32(hold);
            hold = 0;
            bits = 0;
            state.mode = _zlib_inflate.DICT;
          /* falls through */
          case _zlib_inflate.DICT:
            if (!state.havedict) {
              strm.next_out = put;
              strm.avail_out = left;
              strm.next_in = next;
              strm.avail_in = have;
              state.hold = hold;
              state.bits = bits;
              return zlib_constants.Z_NEED_DICT;
            }
            strm.adler = state.check = 1;
            state.mode = _zlib_inflate.TYPE;
          /* falls through */
          case _zlib_inflate.TYPE:
            if (flush === zlib_constants.Z_BLOCK || flush === zlib_constants.Z_TREES) {
              break inf_leave;
            }
          /* falls through */
          case _zlib_inflate.TYPEDO:
            if (state.last) {
              hold >>>= bits & 7;
              bits -= bits & 7;
              state.mode = _zlib_inflate.CHECK;
              break;
            }
            while (bits < 3) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.last = hold & 1;
            hold >>>= 1;
            bits -= 1;
            switch (hold & 3) {
              case 0:
                state.mode = _zlib_inflate.STORED;
                break;
              case 1:
                _zlib_inflate.fixedtables(state);
                state.mode = _zlib_inflate.LEN_;
                if (flush === zlib_constants.Z_TREES) {
                  hold >>>= 2;
                  bits -= 2;
                  break inf_leave;
                }
                break;
              case 2:
                state.mode = _zlib_inflate.TABLE;
                break;
              case 3:
                strm.msg = "invalid block type";
                state.mode = _zlib_inflate.BAD;
            }
            hold >>>= 2;
            bits -= 2;
            break;
          case _zlib_inflate.STORED:
            hold >>>= bits & 7;
            bits -= bits & 7;
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if ((hold & 65535) !== (hold >>> 16 ^ 65535)) {
              strm.msg = "invalid stored block lengths";
              state.mode = _zlib_inflate.BAD;
              break;
            }
            state.length = hold & 65535;
            hold = 0;
            bits = 0;
            state.mode = _zlib_inflate.COPY_;
            if (flush === zlib_constants.Z_TREES) {
              break inf_leave;
            }
          /* falls through */
          case _zlib_inflate.COPY_:
            state.mode = _zlib_inflate.COPY;
          /* falls through */
          case _zlib_inflate.COPY:
            copy = state.length;
            if (copy) {
              if (copy > have) {
                copy = have;
              }
              if (copy > left) {
                copy = left;
              }
              if (copy === 0) {
                break inf_leave;
              }
              output.set(input.subarray(next, next + copy), put);
              have -= copy;
              next += copy;
              left -= copy;
              put += copy;
              state.length -= copy;
              break;
            }
            state.mode = _zlib_inflate.TYPE;
            break;
          case _zlib_inflate.TABLE:
            while (bits < 14) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.nlen = (hold & 31) + 257;
            hold >>>= 5;
            bits -= 5;
            state.ndist = (hold & 31) + 1;
            hold >>>= 5;
            bits -= 5;
            state.ncode = (hold & 15) + 4;
            hold >>>= 4;
            bits -= 4;
            if (state.nlen > 286 || state.ndist > 30) {
              strm.msg = "too many length or distance symbols";
              state.mode = _zlib_inflate.BAD;
              break;
            }
            state.have = 0;
            state.mode = _zlib_inflate.LENLENS;
          /* falls through */
          case _zlib_inflate.LENLENS:
            while (state.have < state.ncode) {
              while (bits < 3) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.lens[order[state.have++]] = hold & 7;
              hold >>>= 3;
              bits -= 3;
            }
            while (state.have < 19) {
              state.lens[order[state.have++]] = 0;
            }
            state.lencode = state.lendyn;
            state.lenbits = 7;
            opts = { bits: state.lenbits };
            ret = zlib_inftrees.inflate_table(_zlib_inflate.CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
            state.lenbits = opts.bits;
            if (ret) {
              strm.msg = "invalid code lengths set";
              state.mode = _zlib_inflate.BAD;
              break;
            }
            state.have = 0;
            state.mode = _zlib_inflate.CODELENS;
          /* falls through */
          case _zlib_inflate.CODELENS:
            while (state.have < state.nlen + state.ndist) {
              for (; ; ) {
                here = state.lencode[hold & (1 << state.lenbits) - 1];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (here_val < 16) {
                hold >>>= here_bits;
                bits -= here_bits;
                state.lens[state.have++] = here_val;
              } else {
                if (here_val === 16) {
                  n = here_bits + 2;
                  while (bits < n) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  hold >>>= here_bits;
                  bits -= here_bits;
                  if (state.have === 0) {
                    strm.msg = "invalid bit length repeat";
                    state.mode = _zlib_inflate.BAD;
                    break;
                  }
                  len = state.lens[state.have - 1];
                  copy = 3 + (hold & 3);
                  hold >>>= 2;
                  bits -= 2;
                } else if (here_val === 17) {
                  n = here_bits + 3;
                  while (bits < n) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  hold >>>= here_bits;
                  bits -= here_bits;
                  len = 0;
                  copy = 3 + (hold & 7);
                  hold >>>= 3;
                  bits -= 3;
                } else {
                  n = here_bits + 7;
                  while (bits < n) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  hold >>>= here_bits;
                  bits -= here_bits;
                  len = 0;
                  copy = 11 + (hold & 127);
                  hold >>>= 7;
                  bits -= 7;
                }
                if (state.have + copy > state.nlen + state.ndist) {
                  strm.msg = "invalid bit length repeat";
                  state.mode = _zlib_inflate.BAD;
                  break;
                }
                while (copy--) {
                  state.lens[state.have++] = len;
                }
              }
            }
            if (state.mode === _zlib_inflate.BAD) {
              break;
            }
            if (state.lens[256] === 0) {
              strm.msg = "invalid code -- missing end-of-block";
              state.mode = _zlib_inflate.BAD;
              break;
            }
            state.lenbits = 9;
            opts = { bits: state.lenbits };
            ret = zlib_inftrees.inflate_table(_zlib_inflate.LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
            state.lenbits = opts.bits;
            if (ret) {
              strm.msg = "invalid literal/lengths set";
              state.mode = _zlib_inflate.BAD;
              break;
            }
            state.distbits = 6;
            state.distcode = state.distdyn;
            opts = { bits: state.distbits };
            ret = zlib_inftrees.inflate_table(_zlib_inflate.DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
            state.distbits = opts.bits;
            if (ret) {
              strm.msg = "invalid distances set";
              state.mode = _zlib_inflate.BAD;
              break;
            }
            state.mode = _zlib_inflate.LEN_;
            if (flush === zlib_constants.Z_TREES) {
              break inf_leave;
            }
          /* falls through */
          case _zlib_inflate.LEN_:
            state.mode = _zlib_inflate.LEN;
          /* falls through */
          case _zlib_inflate.LEN:
            if (have >= 6 && left >= 258) {
              strm.next_out = put;
              strm.avail_out = left;
              strm.next_in = next;
              strm.avail_in = have;
              state.hold = hold;
              state.bits = bits;
              zlib_inffast.inflate_fast(strm, _out);
              put = strm.next_out;
              output = strm.output;
              left = strm.avail_out;
              next = strm.next_in;
              input = strm.input;
              have = strm.avail_in;
              hold = state.hold;
              bits = state.bits;
              if (state.mode === _zlib_inflate.TYPE) {
                state.back = -1;
              }
              break;
            }
            state.back = 0;
            for (; ; ) {
              here = state.lencode[hold & (1 << state.lenbits) - 1];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (here_op && (here_op & 240) === 0) {
              last_bits = here_bits;
              last_op = here_op;
              last_val = here_val;
              for (; ; ) {
                here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (last_bits + here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              hold >>>= last_bits;
              bits -= last_bits;
              state.back += last_bits;
            }
            hold >>>= here_bits;
            bits -= here_bits;
            state.back += here_bits;
            state.length = here_val;
            if (here_op === 0) {
              state.mode = _zlib_inflate.LIT;
              break;
            }
            if (here_op & 32) {
              state.back = -1;
              state.mode = _zlib_inflate.TYPE;
              break;
            }
            if (here_op & 64) {
              strm.msg = "invalid literal/length code";
              state.mode = _zlib_inflate.BAD;
              break;
            }
            state.extra = here_op & 15;
            state.mode = _zlib_inflate.LENEXT;
          /* falls through */
          case _zlib_inflate.LENEXT:
            if (state.extra) {
              n = state.extra;
              while (bits < n) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.length += hold & (1 << state.extra) - 1;
              hold >>>= state.extra;
              bits -= state.extra;
              state.back += state.extra;
            }
            state.was = state.length;
            state.mode = _zlib_inflate.DIST;
          /* falls through */
          case _zlib_inflate.DIST:
            for (; ; ) {
              here = state.distcode[hold & (1 << state.distbits) - 1];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if ((here_op & 240) === 0) {
              last_bits = here_bits;
              last_op = here_op;
              last_val = here_val;
              for (; ; ) {
                here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (last_bits + here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              hold >>>= last_bits;
              bits -= last_bits;
              state.back += last_bits;
            }
            hold >>>= here_bits;
            bits -= here_bits;
            state.back += here_bits;
            if (here_op & 64) {
              strm.msg = "invalid distance code";
              state.mode = _zlib_inflate.BAD;
              break;
            }
            state.offset = here_val;
            state.extra = here_op & 15;
            state.mode = _zlib_inflate.DISTEXT;
          /* falls through */
          case _zlib_inflate.DISTEXT:
            if (state.extra) {
              n = state.extra;
              while (bits < n) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.offset += hold & (1 << state.extra) - 1;
              hold >>>= state.extra;
              bits -= state.extra;
              state.back += state.extra;
            }
            state.mode = _zlib_inflate.MATCH;
          /* falls through */
          case _zlib_inflate.MATCH:
            if (left === 0) {
              break inf_leave;
            }
            copy = _out - left;
            if (state.offset > copy) {
              copy = state.offset - copy;
              if (copy > state.whave) {
                if (state.sane) {
                  strm.msg = "invalid distance too far back";
                  state.mode = _zlib_inflate.BAD;
                  break;
                }
              }
              if (copy > state.wnext) {
                copy -= state.wnext;
                from = state.wsize - copy;
              } else {
                from = state.wnext - copy;
              }
              if (copy > state.length) {
                copy = state.length;
              }
              from_source = state.window;
            } else {
              from_source = output;
              from = put - state.offset;
              copy = state.length;
            }
            if (copy > left) {
              copy = left;
            }
            left -= copy;
            state.length -= copy;
            do {
              output[put++] = from_source[from++];
            } while (--copy);
            if (state.length === 0) {
              state.mode = _zlib_inflate.LEN;
            }
            break;
          case _zlib_inflate.LIT:
            if (left === 0) {
              break inf_leave;
            }
            output[put++] = state.length;
            left--;
            state.mode = _zlib_inflate.LEN;
            break;
          case _zlib_inflate.CHECK:
            if (state.wrap) {
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold |= input[next++] << bits;
                bits += 8;
              }
              _out -= left;
              strm.total_out += _out;
              state.total += _out;
              if (_out) {
                strm.adler = state.check = /*UPDATE(state.check, put - _out, _out);*/
                state.flags ? zlib_crc32.crc32(state.check, output, _out, put - _out) : zlib_adler32.adler32(state.check, output, _out, put - _out);
              }
              _out = left;
              if ((state.flags ? hold : _zlib_inflate.zswap32(hold)) !== state.check) {
                strm.msg = "incorrect data check";
                state.mode = _zlib_inflate.BAD;
                break;
              }
              hold = 0;
              bits = 0;
            }
            state.mode = _zlib_inflate.LENGTH;
          /* falls through */
          case _zlib_inflate.LENGTH:
            if (state.wrap && state.flags) {
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (hold !== (state.total & 4294967295)) {
                strm.msg = "incorrect length check";
                state.mode = _zlib_inflate.BAD;
                break;
              }
              hold = 0;
              bits = 0;
            }
            state.mode = _zlib_inflate.DONE;
          /* falls through */
          case _zlib_inflate.DONE:
            ret = zlib_constants.Z_STREAM_END;
            break inf_leave;
          case _zlib_inflate.BAD:
            ret = zlib_constants.Z_DATA_ERROR;
            break inf_leave;
          case _zlib_inflate.MEM:
            return zlib_constants.Z_MEM_ERROR;
          case _zlib_inflate.SYNC:
          /* falls through */
          default:
            return zlib_constants.Z_STREAM_ERROR;
        }
      }
    strm.next_out = put;
    strm.avail_out = left;
    strm.next_in = next;
    strm.avail_in = have;
    state.hold = hold;
    state.bits = bits;
    if (state.wsize || _out !== strm.avail_out && state.mode < _zlib_inflate.BAD && (state.mode < _zlib_inflate.CHECK || flush !== zlib_constants.Z_FINISH)) {
      if (_zlib_inflate.updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) {
        state.mode = _zlib_inflate.MEM;
        return zlib_constants.Z_MEM_ERROR;
      }
    }
    _in -= strm.avail_in;
    _out -= strm.avail_out;
    strm.total_in += _in;
    strm.total_out += _out;
    state.total += _out;
    if (state.wrap && _out) {
      strm.adler = state.check = /*UPDATE(state.check, strm.next_out - _out, _out);*/
      state.flags ? zlib_crc32.crc32(state.check, output, _out, strm.next_out - _out) : zlib_adler32.adler32(state.check, output, _out, strm.next_out - _out);
    }
    strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === _zlib_inflate.TYPE ? 128 : 0) + (state.mode === _zlib_inflate.LEN_ || state.mode === _zlib_inflate.COPY_ ? 256 : 0);
    if ((_in === 0 && _out === 0 || flush === zlib_constants.Z_FINISH) && ret === zlib_constants.Z_OK) {
      ret = zlib_constants.Z_BUF_ERROR;
    }
    return ret;
  }
  static inflateEnd(strm) {
    if (!strm || !strm.state) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    let state = strm.state;
    if (state.window) {
      state.window = null;
    }
    strm.state = null;
    return zlib_constants.Z_OK;
  }
  static inflateGetHeader(strm, head) {
    if (!strm || !strm.state) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    let state = strm.state;
    if ((state.wrap & 2) === 0) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    state.head = head;
    head.done = false;
    return zlib_constants.Z_OK;
  }
  static inflateSetDictionary(strm, dictionary) {
    const dictLength = dictionary.length;
    let state;
    let dictid;
    let ret;
    if (!strm || !strm.state) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    state = strm.state;
    if (state.wrap !== 0 && state.mode !== _zlib_inflate.DICT) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    if (state.mode === _zlib_inflate.DICT) {
      dictid = 1;
      dictid = zlib_adler32.adler32(dictid, dictionary, dictLength, 0);
      if (dictid !== state.check) {
        return zlib_constants.Z_DATA_ERROR;
      }
    }
    ret = _zlib_inflate.updatewindow(strm, dictionary, dictLength, dictLength);
    if (ret) {
      state.mode = _zlib_inflate.MEM;
      return zlib_constants.Z_MEM_ERROR;
    }
    state.havedict = 1;
    return zlib_constants.Z_OK;
  }
};
zlib_inflate.CODES = 0;
zlib_inflate.LENS = 1;
zlib_inflate.DISTS = 2;
zlib_inflate.HEAD = 1;
zlib_inflate.FLAGS = 2;
zlib_inflate.TIME = 3;
zlib_inflate.OS = 4;
zlib_inflate.EXLEN = 5;
zlib_inflate.EXTRA = 6;
zlib_inflate.NAME = 7;
zlib_inflate.COMMENT = 8;
zlib_inflate.HCRC = 9;
zlib_inflate.DICTID = 10;
zlib_inflate.DICT = 11;
zlib_inflate.TYPE = 12;
zlib_inflate.TYPEDO = 13;
zlib_inflate.STORED = 14;
zlib_inflate.COPY_ = 15;
zlib_inflate.COPY = 16;
zlib_inflate.TABLE = 17;
zlib_inflate.LENLENS = 18;
zlib_inflate.CODELENS = 19;
zlib_inflate.LEN_ = 20;
zlib_inflate.LEN = 21;
zlib_inflate.LENEXT = 22;
zlib_inflate.DIST = 23;
zlib_inflate.DISTEXT = 24;
zlib_inflate.MATCH = 25;
zlib_inflate.LIT = 26;
zlib_inflate.CHECK = 27;
zlib_inflate.LENGTH = 28;
zlib_inflate.DONE = 29;
zlib_inflate.BAD = 30;
zlib_inflate.MEM = 31;
zlib_inflate.SYNC = 32;
zlib_inflate.ENOUGH_LENS = 852;
zlib_inflate.ENOUGH_DISTS = 592;
zlib_inflate.MAX_WBITS = 15;
zlib_inflate.DEF_WBITS = zlib_inflate.MAX_WBITS;
zlib_inflate.virgin = true;

// obj/full/Pako/zlib/messages.js
var zlib_messages = class {
  static msg(index) {
    switch (index) {
      case 2:
        return "need dictionary";
      /* Z_NEED_DICT       2  */
      case 1:
        return "stream end";
      /* Z_STREAM_END      1  */
      case 0:
        return "";
      /* Z_OK              0  */
      case -1:
        return "file error";
      /* Z_ERRNO         (-1) */
      case -2:
        return "stream error";
      /* Z_STREAM_ERROR  (-2) */
      case -3:
        return "data error";
      /* Z_DATA_ERROR    (-3) */
      case -4:
        return "insufficient memory";
      /* Z_MEM_ERROR     (-4) */
      case -5:
        return "buffer error";
      /* Z_BUF_ERROR     (-5) */
      case -6:
        return "incompatible version";
      /* Z_VERSION_ERROR (-6) */
      default:
        return "unknowwn error";
    }
  }
};

// obj/full/Pako/zlib/inftrees.js
var zlib_inftrees = class _zlib_inftrees {
  static inflate_table(type, lens, lens_index, codes, table, table_index, work, opts) {
    const bits = opts.bits;
    let len;
    let sym;
    let min = 0;
    let max;
    let root;
    let curr = 0;
    let drop = 0;
    let left = 0;
    let used = 0;
    let huff = 0;
    let incr;
    let fill;
    let low;
    let mask;
    let next;
    let base;
    let base_index = 0;
    let end;
    const count = new Uint16Array(_zlib_inftrees.MAXBITS + 1);
    const offs = new Uint16Array(_zlib_inftrees.MAXBITS + 1);
    let extra;
    let extra_index = 0;
    let here_bits;
    let here_op;
    let here_val;
    for (len = 0; len <= _zlib_inftrees.MAXBITS; len++) {
      count[len] = 0;
    }
    for (sym = 0; sym < codes; sym++) {
      count[lens[lens_index + sym]]++;
    }
    root = bits;
    for (max = _zlib_inftrees.MAXBITS; max >= 1; max--) {
      if (count[max] !== 0) {
        break;
      }
    }
    if (root > max) {
      root = max;
    }
    if (max === 0) {
      table[table_index++] = 1 << 24 | 64 << 16 | 0;
      table[table_index++] = 1 << 24 | 64 << 16 | 0;
      opts.bits = 1;
      return 0;
    }
    for (min = 1; min < max; min++) {
      if (count[min] !== 0) {
        break;
      }
    }
    if (root < min) {
      root = min;
    }
    left = 1;
    for (len = 1; len <= _zlib_inftrees.MAXBITS; len++) {
      left <<= 1;
      left -= count[len];
      if (left < 0) {
        return -1;
      }
    }
    if (left > 0 && (type === _zlib_inftrees.CODES || max !== 1)) {
      return -1;
    }
    offs[1] = 0;
    for (len = 1; len < _zlib_inftrees.MAXBITS; len++) {
      offs[len + 1] = offs[len] + count[len];
    }
    for (sym = 0; sym < codes; sym++) {
      if (lens[lens_index + sym] !== 0) {
        work[offs[lens[lens_index + sym]]++] = sym;
      }
    }
    if (type === _zlib_inftrees.CODES) {
      base = work;
      extra = new Uint8Array();
      end = 19;
    } else if (type === _zlib_inftrees.LENS) {
      base = _zlib_inftrees.lbase;
      base_index -= 257;
      extra = _zlib_inftrees.lext;
      extra_index -= 257;
      end = 256;
    } else {
      base = _zlib_inftrees.dbase;
      extra = _zlib_inftrees.dext;
      end = -1;
    }
    huff = 0;
    sym = 0;
    len = min;
    next = table_index;
    curr = root;
    drop = 0;
    low = -1;
    used = 1 << root;
    mask = used - 1;
    if (type === _zlib_inftrees.LENS && used > _zlib_inftrees.ENOUGH_LENS || type === _zlib_inftrees.DISTS && used > _zlib_inftrees.ENOUGH_DISTS) {
      return 1;
    }
    for (; ; ) {
      here_bits = len - drop;
      if (work[sym] < end) {
        here_op = 0;
        here_val = work[sym];
      } else if (work[sym] > end) {
        here_op = extra[extra_index + work[sym]];
        here_val = base[base_index + work[sym]];
      } else {
        here_op = 32 + 64;
        here_val = 0;
      }
      incr = 1 << len - drop;
      fill = 1 << curr;
      min = fill;
      do {
        fill -= incr;
        table[next + (huff >> drop) + fill] = here_bits << 24 | here_op << 16 | here_val | 0;
      } while (fill !== 0);
      incr = 1 << len - 1;
      while (huff & incr) {
        incr >>= 1;
      }
      if (incr !== 0) {
        huff &= incr - 1;
        huff += incr;
      } else {
        huff = 0;
      }
      sym++;
      if (--count[len] === 0) {
        if (len === max) {
          break;
        }
        len = lens[lens_index + work[sym]];
      }
      if (len > root && (huff & mask) !== low) {
        if (drop === 0) {
          drop = root;
        }
        next += min;
        curr = len - drop;
        left = 1 << curr;
        while (curr + drop < max) {
          left -= count[curr + drop];
          if (left <= 0) {
            break;
          }
          curr++;
          left <<= 1;
        }
        used += 1 << curr;
        if (type === _zlib_inftrees.LENS && used > _zlib_inftrees.ENOUGH_LENS || type === _zlib_inftrees.DISTS && used > _zlib_inftrees.ENOUGH_DISTS) {
          return 1;
        }
        low = huff & mask;
        table[low] = root << 24 | curr << 16 | next - table_index | 0;
      }
    }
    if (huff !== 0) {
      table[next + huff] = len - drop << 24 | 64 << 16 | 0;
    }
    opts.bits = root;
    return 0;
  }
};
zlib_inftrees.MAXBITS = 15;
zlib_inftrees.ENOUGH_LENS = 852;
zlib_inftrees.ENOUGH_DISTS = 592;
zlib_inftrees.CODES = 0;
zlib_inftrees.LENS = 1;
zlib_inftrees.DISTS = 2;
zlib_inftrees.lbase = new Uint16Array([
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  13,
  15,
  17,
  19,
  23,
  27,
  31,
  35,
  43,
  51,
  59,
  67,
  83,
  99,
  115,
  131,
  163,
  195,
  227,
  258,
  0,
  0
]);
zlib_inftrees.lext = new Uint8Array([
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  17,
  17,
  17,
  17,
  18,
  18,
  18,
  18,
  19,
  19,
  19,
  19,
  20,
  20,
  20,
  20,
  21,
  21,
  21,
  21,
  16,
  72,
  78
]);
zlib_inftrees.dbase = new Uint16Array([
  1,
  2,
  3,
  4,
  5,
  7,
  9,
  13,
  17,
  25,
  33,
  49,
  65,
  97,
  129,
  193,
  257,
  385,
  513,
  769,
  1025,
  1537,
  2049,
  3073,
  4097,
  6145,
  8193,
  12289,
  16385,
  24577,
  0,
  0
]);
zlib_inftrees.dext = new Uint8Array([
  16,
  16,
  16,
  16,
  17,
  17,
  18,
  18,
  19,
  19,
  20,
  20,
  21,
  21,
  22,
  22,
  23,
  23,
  24,
  24,
  25,
  25,
  26,
  26,
  27,
  27,
  28,
  28,
  29,
  29,
  64,
  64
]);

// obj/full/Pako/zlib/zstream.js
var zlib_ZStream = class {
  constructor() {
    this.input = null;
    this.next_in = 0;
    this.avail_in = 0;
    this.total_in = 0;
    this.output = null;
    this.next_out = 0;
    this.avail_out = 0;
    this.total_out = 0;
    this.msg = "";
    this.state = null;
    this.data_type = 2;
    this.adler = 0;
  }
};

// obj/full/webPage.js
var YWebPage = class _YWebPage {
  edit(widgetIndex) {
    _YWebPage.widgets[widgetIndex].edit();
  }
  static get editMenuItem() {
    return _YWebPage._editMenuItem;
  }
  static get deleteMenuItem() {
    return _YWebPage._deleteMenuItem;
  }
  static get disableMarkerMenuItem() {
    return _YWebPage._disableMarkerMenuItem;
  }
  static get clearDataloggerMenuItem() {
    return _YWebPage._clearDataloggerMenuItem;
  }
  static get addMarkerMenuItem() {
    return _YWebPage._addMarkerMenuItem;
  }
  static get markersSubMenuItems() {
    return _YWebPage._markersSubMenuItems;
  }
  static get contextMarkerSubMenu() {
    return _YWebPage._contextMarkerSubMenu;
  }
  static get contextWidgetsSubMenu() {
    return _YWebPage._contextWidgetsSubMenu;
  }
  static get resetDataViewMenuItem() {
    return _YWebPage._resetDataViewMenuItem;
  }
  static get snapshotMenuItem() {
    return _YWebPage._snapshotMenuItem;
  }
  static applicationGlobalinit() {
    if (_YWebPage._MarkerCountPerXaxis == 0) {
      let xAxisProp = new XaxisDescription();
      let propDesc = GenericProperties.getAllProperties(xAxisProp);
      for (let propname in propDesc.byName) {
        if (propname.startsWith("markers"))
          _YWebPage._MarkerCountPerXaxis++;
      }
    }
    if (_YWebPage.manager == null)
      _YWebPage.manager = new sensorsManager();
    if (!_YWebPage.readonly && _YWebPage._editor == null)
      _YWebPage._editor = new PropertiesForm2();
    if (!_YWebPage.readonly && _YWebPage._mainform == null)
      _YWebPage._mainform = new mainForm();
    if (_YWebPage._contextMenu == null) {
      _YWebPage._contextMenu = new ContextMenu(_YWebPage.baseSize, (mouseX, mouseY) => {
        _YWebPage.menuIsOpening(mouseX, mouseY);
      }, constants.generalFontFamily);
      _YWebPage._contextMarkerSubMenu = new ContextSubMenu(_YWebPage.baseSize, _YWebPage._contextMenu, null, constants.generalFontFamily);
      for (let i = 0; i < _YWebPage._MarkerCountPerXaxis; i++) {
        _YWebPage._markersSubMenuItems.push(_YWebPage._contextMarkerSubMenu.addMenuItem(ressources.AddMarkerIcon(_YWebPage.baseSize.toString(), i + 1), "Place marker " + (i + 1).toString(), () => {
          let target = _YWebPage._markersSubMenuItems[i].userdata;
          target.startMarkerCapture(i);
        }));
      }
      if (!_YWebPage.readonly) {
        _YWebPage._contextWidgetsSubMenu = new ContextSubMenu(_YWebPage.baseSize, _YWebPage._contextMenu, (mouseX, mouseY) => {
          _YWebPage.WidgetsSubMenuIsOpening(mouseX, mouseY);
        }, constants.generalFontFamily);
        _YWebPage._widgetsMenuItem = _YWebPage._contextMenu.addSubMenuItem(ressources.AllIcon(_YWebPage.baseSize.toString(), false, false, false, false), "All widgets", _YWebPage._contextWidgetsSubMenu);
        _YWebPage._editMenuItem = _YWebPage._contextMenu.addMenuItem(ressources.EditIcon(_YWebPage.baseSize.toString(), false, false, false, false), "Configure this widget", () => {
          _YWebPage.editWidget();
        });
        _YWebPage._deleteMenuItem = _YWebPage._contextMenu.addMenuItem(ressources.TrashIcon(_YWebPage.baseSize.toString(), false, false, false, false), "Delete this widget", () => {
          _YWebPage.deleteWidget();
        });
        _YWebPage._editMenuItem.visible = false;
        _YWebPage._deleteMenuItem.visible = false;
      }
      _YWebPage._resetDataViewMenuItem = _YWebPage._contextMenu.addMenuItem(ressources.resetViewPort(_YWebPage.baseSize.toString(), false, false, false, false), "Reset dataview", () => {
        _YWebPage.resetDataView();
      });
      _YWebPage._resetDataViewMenuItem.visible = false;
      if (!_YWebPage.readonly) {
        _YWebPage._clearDataloggerMenuItem = _YWebPage._contextMenu.addMenuItem(ressources.EraseDatalogger(_YWebPage.baseSize.toString(), false, false, false, false), "Clear datalogger", () => {
          _YWebPage.clearDatalogger();
        });
        _YWebPage._resetDataViewMenuItem.visible = false;
      }
      _YWebPage._contextMenu.AddSeparator();
      if (!_YWebPage.readonly) {
        _YWebPage._addMarkerMenuItem = _YWebPage._contextMenu.addSubMenuItem(ressources.AddMarker(_YWebPage.baseSize.toString(), false, true, true, false), "Place markers", _YWebPage._contextMarkerSubMenu);
        _YWebPage._disableMarkerMenuItem = _YWebPage._contextMenu.addMenuItem(ressources.DeleteMarker(_YWebPage.baseSize.toString(), false, true, false, true), "Disable Allmarkers", () => {
          _YWebPage.disableAllMarker();
        });
        _YWebPage._addMarkerMenuItem.visible = false;
        _YWebPage._disableMarkerMenuItem.visible = false;
        _YWebPage._contextMenu.AddSeparator();
        _YWebPage._contextMenu.addMenuItem(ressources.SolidGaugeIcon(_YWebPage.baseSize.toString(), false, true, true, false), "Add a new Solid gauge", () => {
          _YWebPage.newGaugeWidget();
        });
        _YWebPage._contextMenu.addMenuItem(ressources.AngularGaugeIcon(_YWebPage.baseSize.toString(), false, true, true, false), "Add a new Angular gauge", () => {
          _YWebPage.newAngularGaugeWidget();
        });
        _YWebPage._contextMenu.addMenuItem(ressources.DigitalDisplayIcon(_YWebPage.baseSize.toString(), false, true, true, false), "Add a new Digital Display", () => {
          _YWebPage.newDigitalDisplayWidget();
        });
        _YWebPage._contextMenu.addMenuItem(ressources.GraphIcon(_YWebPage.baseSize.toString(), false, true, true, false), "Add a new Graph", () => {
          _YWebPage.newGraphWidget();
        });
      }
      _YWebPage._contextMenu.addMenuItem(ressources.RawDataIcon(_YWebPage.baseSize.toString(), false, false, false, false), "Show raw data", () => {
        rawDataForm.show();
      });
      _YWebPage._snapshotMenuItem = _YWebPage._contextMenu.addMenuItem(ressources.snapshotIcon(_YWebPage.baseSize.toString(), false, false, false, false), "Snapshot", () => {
        _YWebPage.snapShot();
      });
      if (!_YWebPage.readonly) {
        _YWebPage._contextMenu.AddSeparator();
        _YWebPage._contextMenu.addMenuItem(ressources.ConfigureIcon(_YWebPage.baseSize.toString(), false, false, false, false), "Global configuration", () => {
          configForm.show();
        });
        _YWebPage._contextMenu.addMenuItem(ressources.SaveIcon(_YWebPage.baseSize.toString(), false, false, false, false), "Save now", () => {
          _YWebPage.save(true);
        });
      }
      _YWebPage._contextMenu.addMenuItem(ressources.LogFileIcon(_YWebPage.baseSize.toString(), false, false, false, false), "Show logs", () => {
        _YWebPage.showLogsWindow();
      });
    }
  }
  static RegisterDeviceArrivalCallback(arrivalCallback) {
    sensorsManager.RegisterDeviceArrivalCallback(arrivalCallback);
  }
  static RegisterDeviceRemovalCallback(removalCallback) {
    sensorsManager.RegisterDeviceRemovalCallback(removalCallback);
  }
  //#ifndef READONLY
  static WidgetsSubMenuIsOpening(mouseX, mouseY) {
    _YWebPage._contextWidgetsSubMenu.clearAllContents();
    for (let i = 0; i < _YWebPage.widgets.length; i++) {
      let icon = "";
      let subMenu = new ContextSubMenu(_YWebPage.baseSize, _YWebPage._contextWidgetsSubMenu, (mouseX2, mouseY2) => {
        _YWebPage.specificWidgetSubMenuIsOpening(subMenu, mouseX2, mouseY2);
      }, constants.generalFontFamily);
      subMenu.userdata = _YWebPage.widgets[i];
      if (_YWebPage.widgets[i] instanceof graphWidget)
        icon = ressources.GraphIcon(_YWebPage.baseSize.toString(), false, false, false, false);
      if (_YWebPage.widgets[i] instanceof digitalDisplayWidget)
        icon = ressources.DigitalDisplayIcon(_YWebPage.baseSize.toString(), false, false, false, false);
      if (_YWebPage.widgets[i] instanceof gaugeWidget)
        icon = ressources.SolidGaugeIcon(_YWebPage.baseSize.toString(), false, false, false, false);
      if (_YWebPage.widgets[i] instanceof angularGaugeWidget)
        icon = ressources.AngularGaugeIcon(_YWebPage.baseSize.toString(), false, false, false, false);
      _YWebPage._contextWidgetsSubMenu.addSubMenuItem(icon, _YWebPage.widgets[i].Text, subMenu);
    }
  }
  static specificWidgetSubMenuIsOpening(source, mouseX, mouseY) {
    if (source.menuItemsCount > 0)
      return;
    let w = source.userdata;
    source.addMenuItem(ressources.EditIcon(_YWebPage.baseSize.toString(), false, false, false, false), "Configure", () => {
      w.edit();
    });
    source.addMenuItem(ressources.TrashIcon(_YWebPage.baseSize.toString(), false, false, false, false), "Delete", () => {
      _YWebPage.deleteWidget(w);
    });
    if (w instanceof graphWidget) {
      source.addMenuItem(ressources.resetViewPort(_YWebPage.baseSize.toString(), false, false, false, false), "Reset dataview", () => {
        w.resetDataView();
      });
      source.addMenuItem(ressources.EraseDatalogger(_YWebPage.baseSize.toString(), false, false, false, false), "Clear datalogger", () => {
        w.clearDataLogger();
      });
    }
  }
  //#endif
  static showLogsWindow() {
    logForm.show();
  }
  static snapShot() {
    let w = _YWebPage._snapshotMenuItem.userdata;
    w.snapshot();
  }
  static menuIsOpening(mouseX, mouseY) {
    if (_YWebPage.disableMarkerMenuItem != null)
      _YWebPage.disableMarkerMenuItem.visible = false;
    if (_YWebPage.addMarkerMenuItem != null)
      _YWebPage.addMarkerMenuItem.visible = false;
    if (_YWebPage.clearDataloggerMenuItem != null)
      _YWebPage.clearDataloggerMenuItem.visible = false;
    if (_YWebPage.editMenuItem != null)
      _YWebPage.editMenuItem.visible = false;
    if (_YWebPage.deleteMenuItem != null)
      _YWebPage.deleteMenuItem.visible = false;
    _YWebPage.resetDataViewMenuItem.visible = false;
    _YWebPage.snapshotMenuItem.visible = false;
    for (let i = 0; i < _YWebPage.widgets.length; i++) {
      _YWebPage.widgets[i].contextMenuCallBack(mouseX, mouseY);
    }
    _YWebPage._widgetsMenuItem.visible = !_YWebPage.readonly && _YWebPage.widgets.length > 0 && !_YWebPage._editMenuItem.visible;
    _YWebPage._contextMenu.refresh();
  }
  static resetDataView() {
    _YWebPage._resetDataViewMenuItem.userdata.resetDataView();
  }
  //#ifndef READONLY
  static editWidget() {
    let w = _YWebPage._editMenuItem.userdata;
    w.edit();
  }
  static disableAllMarker() {
    _YWebPage._disableMarkerMenuItem.userdata.disableAllMarkers();
  }
  static clearDatalogger() {
    _YWebPage._clearDataloggerMenuItem.userdata.clearDataLogger();
  }
  static deleteWidget(widget) {
    let w = typeof widget == "undefined" ? _YWebPage._deleteMenuItem.userdata : widget;
    confirm.ask(w.confirmDeleteString, () => {
      if (!_YWebPage.readonly && w.isBeingEdited && _YWebPage._editor != null)
        _YWebPage._editor.hide();
      w.delete();
      constants.edited = true;
      for (let i = _YWebPage.widgets.length - 1; i >= 0; i--) {
        if (_YWebPage.widgets[i] == w) {
          _YWebPage.widgets.splice(i, 1);
        }
      }
      if (_YWebPage.widgets.length <= 0 && _YWebPage._mainform != null)
        _YWebPage._mainform.show();
    }, null, null);
  }
  static FindUniqueNewName(prefix) {
    let n = 1;
    for (let i = 0; i < _YWebPage.widgets.length; i++) {
      if (_YWebPage.widgets[i].Text.startsWith(prefix))
        n++;
    }
    if (n > 1)
      prefix = prefix + " " + n.toString();
    return prefix;
  }
  static newGraphWidget() {
    let w = window.innerWidth / 2 >> 0;
    let h = window.innerHeight / 2 >> 0;
    if (w < 350)
      w = 350;
    if (h < 200)
      w = 200;
    let x = (window.innerWidth - w) / 2 >> 0;
    let y = (window.innerHeight - h) / 2 >> 0;
    let index = _YWebPage.widgets.length;
    if (index > 0) {
      x = index * 25;
      y = index * 25;
    }
    let wdg = new graphWidget(null, _YWebPage._editor, x, y, 765, 470);
    wdg.set_name(_YWebPage.FindUniqueNewName("New Graph"));
    _YWebPage.widgets.push(wdg);
    wdg.resize(w, h);
    if (this._mainform != null)
      this._mainform.hide();
    if (!_YWebPage.readonly) {
      if (_YWebPage._editor != null && _YWebPage._editor.visible)
        wdg.edit();
    }
  }
  static newAngularGaugeWidget() {
    let s = Math.min(window.innerWidth, window.innerHeight) / 2;
    if (s < 350)
      s = 350;
    let x = (window.innerWidth - s) / 2 >> 0;
    let y = (window.innerHeight - s) / 2 >> 0;
    let w = s >> 0;
    let h = s >> 0;
    let index = _YWebPage.widgets.length;
    if (index > 0) {
      x = index * 25;
      y = index * 25;
    }
    let wdg = new angularGaugeWidget(null, _YWebPage._editor, x, y, 375, 300);
    wdg.set_name(_YWebPage.FindUniqueNewName("New Angular Gauge"));
    _YWebPage.widgets.push(wdg);
    wdg.resize(w, h);
    if (this._mainform != null)
      this._mainform.hide();
    if (!_YWebPage.readonly) {
      if (_YWebPage._editor != null && _YWebPage._editor.visible)
        wdg.edit();
    }
  }
  static newGaugeWidget() {
    let s = Math.min(window.innerWidth, window.innerHeight) / 2;
    if (s < 350)
      s = 350;
    let x = (window.innerWidth - s) / 2 >> 0;
    let y = (window.innerHeight - s) / 2 >> 0;
    let w = s >> 0;
    let h = s >> 0;
    let index = _YWebPage.widgets.length;
    if (index > 0) {
      x = index * 25;
      y = index * 25;
    }
    let wdg = new gaugeWidget(null, _YWebPage._editor, x, y, 355, 201);
    wdg.set_name(_YWebPage.FindUniqueNewName("New Solid Gauge"));
    _YWebPage.widgets.push(wdg);
    wdg.resize(w, h);
    if (this._mainform != null)
      this._mainform.hide();
    if (!_YWebPage.readonly) {
      if (_YWebPage._editor != null && _YWebPage._editor.visible)
        wdg.edit();
    }
  }
  static newDigitalDisplayWidget() {
    let s = Math.min(window.innerWidth, window.innerHeight) / 8;
    if (s < 90)
      s = 90;
    let x = (window.innerWidth - 4 * s) / 2 >> 0;
    let y = (window.innerHeight - s) / 2 >> 0;
    let w = 4 * s >> 0;
    let h = s >> 0;
    let index = _YWebPage.widgets.length;
    if (index > 0) {
      x = index * 25;
      y = index * 25;
    }
    let wdg = new digitalDisplayWidget(null, _YWebPage._editor, x, y, 410, 125);
    wdg.set_name(_YWebPage.FindUniqueNewName("New Digital Display"));
    let n = 1;
    for (let i = 0; i < _YWebPage.widgets.length; i++) {
      if (_YWebPage.widgets[i].Text.startsWith(wdg.Text))
        n++;
    }
    if (n > 1)
      wdg.Text = wdg.Text + " " + n.toString();
    _YWebPage.widgets.push(wdg);
    wdg.resize(w, h);
    if (this._mainform != null)
      this._mainform.hide();
    if (!_YWebPage.readonly) {
      if (_YWebPage._editor != null && _YWebPage._editor.visible)
        wdg.edit();
    }
  }
  static refreshPropertiesForm() {
    if (!_YWebPage.readonly && _YWebPage._editor != null)
      _YWebPage._editor.refresh();
  }
  //#endif
  static sensorListHaschanged() {
    _YWebPage.refreshPropertiesForm();
  }
  static EmptyReadonlyConfig() {
    alert2.show("Yocto-Visualization Error\n\nConfiguration is both empty and read only, check configuration file.");
  }
  static async ForceReloadConfig(newXMLdata) {
    if (!_YWebPage.readonly) {
      if (_YWebPage._editor != null)
        _YWebPage._editor.visible = false;
      configForm.hide();
      rawDataForm.hide();
      HubEdit.hide();
    }
    logForm.log("Reloading the whole configuration.");
    await sensorsManager.clearHublist();
    for (let i = _YWebPage.widgets.length - 1; i >= 0; i--) {
      _YWebPage.widgets[i].destroy();
      _YWebPage.widgets.splice(i, 1);
    }
    _YWebPage.loadFromXML(newXMLdata);
    constants.edited = false;
  }
  static ConfigChanged(newXMLdata) {
    if (_YWebPage.ConfigChangedConfirmWindows != null) {
      _YWebPage.ConfigChangedConfirmWindows.hide();
    }
    let newCRC = constants.crc32(newXMLdata);
    if (newCRC == _YWebPage.xmlDataCRC)
      return;
    logForm.log("Config file changed behind our back!");
    if (!this.readonly) {
      _YWebPage.ConfigChangedConfirmWindows = confirm.ask("Configuration has changed on server\nWould you like to reload it?", () => {
        _YWebPage.ForceReloadConfig(newXMLdata);
        _YWebPage.ConfigChangedConfirmWindows = null;
      }, () => {
        _YWebPage.ConfigChangedConfirmWindows = null;
      }, null);
    } else {
      _YWebPage.ForceReloadConfig(newXMLdata);
    }
    _YWebPage.xmlDataCRC = newCRC;
    constants.edited = false;
  }
  static ShowSaveReminder(visible) {
    if (_YWebPage.saveIntDiv == null) {
      _YWebPage.saveIntDiv = document.createElement("DIV");
      _YWebPage.saveIntDiv.style.position = "fixed";
      _YWebPage.saveIntDiv.style.left = "5px";
      _YWebPage.saveIntDiv.style.top = "5px";
      _YWebPage.saveIntDiv.style.zIndex = "200000";
      _YWebPage.saveIntDiv.style.cursor = "pointer";
      _YWebPage.saveIntDiv.innerHTML = ressources.SaveNeededIcon((48 * constants.guiDPIFactor).toString(), false, false, false, false);
      _YWebPage.saveIntDiv.addEventListener("click", () => {
        _YWebPage.saveIntDiv.style.display = "none";
        _YWebPage.save(true);
      });
      document.body.appendChild(_YWebPage.saveIntDiv);
    }
    _YWebPage.saveIntDiv.style.display = visible ? "" : "none";
  }
  //#endif
  static loadFromXML(xmlData) {
    if (xmlData == "") {
      if (!_YWebPage.readonly && _YWebPage._mainform != null) {
        _YWebPage._mainform.show();
      } else {
        _YWebPage.EmptyReadonlyConfig();
      }
      return;
    }
    let parser = new DOMParser();
    let doc = parser.parseFromString(xmlData.replace("<!-->", "<!-- "), "application/xml");
    let root = null;
    doc.childNodes.forEach((node) => {
      if (node.nodeName.toUpperCase() == "ROOT" && root == null)
        root = node;
    });
    if (root == null)
      throw "No ROOT top node in XML data";
    root.childNodes.forEach((node) => {
      if (node.nodeName.toUpperCase() == "SENSORS") {
        sensorsManager.setKnownSensors(new YXmlNode(node));
      }
    });
    root.childNodes.forEach((node) => {
      let editor = null;
      editor = _YWebPage._editor;
      switch (node.nodeName.toUpperCase()) {
        case "CONFIG":
          constants.Init(new YXmlNode(node));
          break;
        case "GRAPHFORM":
          _YWebPage.widgets.push(new graphWidget(new YXmlNode(node), editor));
          break;
        case "ANGULARGAUGEFORM":
          _YWebPage.widgets.push(new angularGaugeWidget(new YXmlNode(node), editor));
          break;
        case "GAUGEFORM":
          _YWebPage.widgets.push(new gaugeWidget(new YXmlNode(node), editor));
          break;
        case "DIGITALDISPLAYFORM":
          _YWebPage.widgets.push(new digitalDisplayWidget(new YXmlNode(node), editor));
          break;
      }
      sensorsManager.registerChangeCallback(() => {
        _YWebPage.sensorListHaschanged();
      });
      if (node.nodeName.toUpperCase() == "ROOT" && root == null)
        root = node;
    });
    if (_YWebPage.widgets.length <= 0) {
      constants.edited = false;
      if (!_YWebPage.readonly && _YWebPage._mainform != null) {
        _YWebPage._mainform.show();
      } else {
        _YWebPage.EmptyReadonlyConfig();
      }
    } else if (!_YWebPage.readonly && _YWebPage._mainform != null)
      _YWebPage._mainform.hide();
  }
  static AnimateNewVerwsionMessage(step) {
    _YWebPage.NewVersionmessageDiv.style.left = Math.round(100 - step) + "%";
    if (step < 100) {
      step += 2;
      if (step > 100)
        step = 100;
      setTimeout(() => {
        _YWebPage.AnimateNewVerwsionMessage(step);
      });
    }
  }
  static StartInstaller(roothub) {
    let installerDiv = document.createElement("DIV");
    installerDiv.style.position = "absolute";
    installerDiv.style.top = "50%";
    installerDiv.style.left = "50%";
    installerDiv.style.transform = "translate(-50%,-50%)";
    installerDiv.style.width = "550px";
    installerDiv.style.height = "380px";
    installerDiv.style.zIndex = _YWebPage.getTopZIndex().toString();
    installerDiv.style.border = "1px solid black";
    installerDiv.style.boxShadow = "rgba(0, 0, 0, 0.05) 4px 4px 4px 1px";
    document.body.appendChild(installerDiv);
    let options = {};
    if (roothub != null)
      options = {
        "protocol": roothub.protocol,
        "addr": roothub.addr,
        "port": parseInt(roothub.port),
        "path": roothub.path,
        "cancelable": true
      };
    window.startYV4W_installer(installerDiv, options);
  }
  static DownloadAndStartInstaller(installerURL, roothub, deleteTimer) {
    clearTimeout(deleteTimer);
    console.log("Downloading installer (" + installerURL + ")...");
    let P = document.createElement("P");
    P.style.textAlign = "center";
    P.style.fontFamily = constants.generalFontFamily;
    P.style.fontSize = "16px";
    P.innerHTML = "Downloading Installer<br>Please wait...";
    _YWebPage.NewVersionmessageDiv.removeChild(_YWebPage.NewVersionmessageDiv.firstChild);
    _YWebPage.NewVersionmessageDiv.appendChild(P);
    let script = document.createElement("script");
    script.async = false;
    script.type = "module";
    script.onerror = (err) => {
      console.log("Failed to donwload installer (" + Event.toString() + ")");
      P.innerHTML = "Failed to download installer,<br>Check conole logs";
    };
    script.onload = () => {
      P.innerHTML = "Starting installer...";
      _YWebPage.DeleteNewVersionMessage(100);
      _YWebPage.StartInstaller(roothub);
    };
    document.body.appendChild(script);
    script.src = installerURL;
  }
  static DeleteNewVersionMessage(opacity) {
    opacity -= 5;
    if (opacity > 0) {
      _YWebPage.NewVersionmessageDiv.style.opacity = (opacity / 100).toString();
      setTimeout(() => {
        _YWebPage.DeleteNewVersionMessage(opacity);
      }, 100);
      return;
    }
    document.body.removeChild(_YWebPage.NewVersionmessageDiv.parentNode);
  }
  static getTopZIndex() {
    var elems = document.getElementsByTagName("DIV");
    var highestZ = 0;
    for (var i = 0; i < elems.length; i++) {
      var z = Number.parseInt(window.getComputedStyle(elems[i], null).getPropertyValue("z-index"));
      if (z > highestZ)
        highestZ = z;
    }
    return highestZ + 1;
  }
  static async CheckForNewVersion(force) {
    if (!constants.mustCheckForUpdate && !force)
      return;
    let checkurl = location.protocol + "//www.yoctopuce.com/FR/common/getLastFirmwareLink.php?app=yoctovisualization4web.installer&version=" + constants.buildVersion + "&platform=_";
    let response;
    try {
      response = await fetch(checkurl);
    } catch (e) {
      return;
    }
    if (!response.ok)
      return;
    let json;
    try {
      json = await response.json();
    } catch (e) {
      return;
    }
    if (!(json instanceof Array))
      return;
    if (json.length <= 0)
      return;
    if (!("version" in json[0]))
      return;
    if (!("link" in json[0]))
      return;
    let newVersionInstallerURL = json[0]["link"];
    let newVersionNumber = parseInt(json[0]["version"]);
    let currentVersionStr = constants.trueBuild;
    let currentVersionNumber = 0;
    if (currentVersionStr.indexOf("-") < 0) {
      let n = currentVersionStr.lastIndexOf(".");
      if (n >= 0)
        currentVersionStr = currentVersionStr.substr(n + 1);
      currentVersionNumber = parseInt(currentVersionStr);
    }
    if (currentVersionNumber >= newVersionNumber)
      return;
    let generalSize = constants.generalFontSize;
    let NewVersionSizeX = generalSize * 24;
    let NewVersionSizeY = generalSize * 5;
    let containerDiv = document.createElement("DIV");
    containerDiv.style.position = "absolute";
    containerDiv.style.width = NewVersionSizeX + "px";
    containerDiv.style.height = NewVersionSizeY + "px";
    containerDiv.style.zIndex = _YWebPage.getTopZIndex().toString();
    containerDiv.style.top = "5px";
    containerDiv.style.right = "0px";
    containerDiv.style.overflow = "hidden";
    document.body.appendChild(containerDiv);
    _YWebPage.NewVersionmessageDiv = document.createElement("DIV");
    _YWebPage.NewVersionmessageDiv.style.position = "absolute";
    _YWebPage.NewVersionmessageDiv.style.width = NewVersionSizeX - 7 + "px";
    _YWebPage.NewVersionmessageDiv.style.height = NewVersionSizeY - 2 + "px";
    _YWebPage.NewVersionmessageDiv.style.backgroundColor = "GhostWhite";
    _YWebPage.NewVersionmessageDiv.style.border = "1px solid dimgray";
    _YWebPage.NewVersionmessageDiv.style.top = "0px";
    _YWebPage.NewVersionmessageDiv.style.left = NewVersionSizeX + "px";
    let table = document.createElement("TABLE");
    table.style.fontFamily = constants.generalFontFamily;
    table.style.fontSize = generalSize + "px";
    let TR = document.createElement("TR");
    let TD1 = document.createElement("TD");
    TD1.style.paddingLeft = "5px";
    TD1.style.paddingRight = "10px";
    TD1.rowSpan = 2;
    TD1.style.verticalAlign = "middle";
    TD1.innerHTML = ressources.infoIcon((generalSize * 4).toString(), false, false, false, false, "information");
    TR.appendChild(TD1);
    let TD2 = document.createElement("TD");
    TD2.innerHTML = "A new Yocto-Visualization (for web)<br>version is available";
    TR.appendChild(TD2);
    table.appendChild(TR);
    TR = document.createElement("TR");
    TD2 = document.createElement("TD");
    TD2.style.textAlign = "right";
    TD2.style.verticalAlign = "bottom";
    let hubList = sensorsManager.hubList;
    let rootHub = null;
    for (let i = 0; i < hubList.length; i++) {
      if (!hubList[i].removable)
        rootHub = hubList[i];
    }
    let a = document.createElement("A");
    let deleteTimer = setTimeout(() => {
      _YWebPage.DeleteNewVersionMessage(100);
    }, 5e3);
    a.style.fontSize = "12px";
    a.style.color = " #0000EE";
    a.style.textDecoration = "underline";
    a.style.cursor = "pointer";
    a.style.fontFamily = constants.generalFontFamily;
    a.style.fontSize = generalSize + "px";
    if (rootHub != null) {
      a.innerText = "Download and start installer..";
      a.addEventListener("click", () => {
        _YWebPage.DownloadAndStartInstaller(newVersionInstallerURL, rootHub, deleteTimer);
      });
    } else {
      a.innerText = "www.yoctopuce.com";
      a.addEventListener("click", () => {
        window.location.assign("http://www.yoctopuce.com/EN/tools.php");
      });
    }
    TD2.appendChild(a);
    TR.appendChild(TD2);
    table.appendChild(TR);
    _YWebPage.NewVersionmessageDiv.appendChild(table);
    containerDiv.appendChild(_YWebPage.NewVersionmessageDiv);
    _YWebPage.AnimateNewVerwsionMessage(0);
  }
  //#endif
  // YWebPage.run is the application entry point.
  //
  // params:
  // xmldata  : XML  configuration data string
  // ExternalConfigChange:  will be called if a module config changes , can be used to track configuration file changes,
  // ExternalConfigChange should return the new  XML  configuration data string or null. If you don't want
  // to use that feature, set ExternalConfigChange to null
  // saveFunction will be called at save time and is supposed to sve the configuration data the way it sees fit
  // One can use the internal  YWebPage.Dummysave to test.
  static run(xmlData, ExternalConfigChange, saveFunction) {
    if (typeof ExternalConfigChange !== "undefined") {
      if (ExternalConfigChange != null) {
        sensorsManager.registerChangeExternalCallback(ExternalConfigChange);
      }
    }
    _YWebPage.xmlDataCRC = constants.crc32(xmlData);
    if (typeof saveFunction !== "undefined")
      _YWebPage._saveFunction = saveFunction;
    logForm.log("Application start, Welcome to Yocto-Visualization (for web).");
    logForm.log("This application contains code ported from the Pako library (www.github.com/nodeca/pako).");
    logForm.log("Yocto-Visualization (for web) version is " + constants.buildVersion);
    logForm.log("Yoctopuce API version is " + YAPI.imm_GetAPIVersion());
    if (constants.RunningOnAndroid)
      logForm.log("Browser is running on Android");
    let widthCm = Math.round(2.54 * constants.deviceScreenWidth / constants.screenDPI);
    let heightCm = Math.round(2.54 * constants.deviceScreenHeight / constants.screenDPI);
    logForm.log("Reported screen size is " + constants.deviceScreenWidth.toString() + "x" + constants.deviceScreenHeight.toString() + " at " + constants.screenDPI + " dpi, (~" + widthCm.toString() + "x" + heightCm.toString() + "cm) ");
    logForm.log("Reported pixel ratio is " + window.devicePixelRatio.toString());
    logForm.log(constants.isPhoneOrTablet ? "Probably running on a tablet or a phone." : "Probably running on a desktop.");
    logForm.log((constants.guiDPIFactorWasOverriden ? "DPI based zoom overridden  to " : "DPI based zoom factor set to ") + constants.guiDPIFactor.toFixed(1));
    logForm.log("Reported window inner size =" + window.innerWidth.toString() + "x" + window.innerHeight.toString() + "px");
    _YWebPage.applicationGlobalinit();
    sensorsManager.run();
    _YWebPage.loadFromXML(xmlData);
    constants.edited = false;
    _YWebPage.CheckForNewVersion(false);
  }
  static async pageIsleaving(e) {
    if (!e.persistent) {
      if (constants.edited) {
        await _YWebPage.save(false);
        await YAPI.FreeAPI();
      }
    }
  }
  //#ifndef READONLY
  static refreshEditor() {
    if (_YWebPage.readonly)
      return;
    if (_YWebPage._editor == null)
      return;
    _YWebPage._editor.refresh();
  }
  static EditObject(widget, structData, setvalueCallBack, getvalueCallBack, EditStoppedCallBack) {
    if (_YWebPage.readonly)
      return;
    if (_YWebPage._editor == null)
      return;
    _YWebPage._editor.showWindow(widget, structData, setvalueCallBack, getvalueCallBack, EditStoppedCallBack);
  }
  static get_XmlData() {
    let XmlConfigFile = `<?xml version="1.0" ?>
<!--
   **************************************************
   Yocto-Visualization (for web)  configuration file
   **************************************************
-->
<ROOT version='2.1'>
<!-- in 2.1 version, floating point values are saved in CultureInfo.InvariantCulture form -->
`;
    XmlConfigFile += constants.GetXMLConfiguration();
    for (let i = 0; i < _YWebPage.widgets.length; i++) {
      if (_YWebPage.widgets[i] instanceof graphWidget)
        XmlConfigFile += _YWebPage.widgets[i].getConfigData();
      if (_YWebPage.widgets[i] instanceof angularGaugeWidget)
        XmlConfigFile += _YWebPage.widgets[i].getConfigData();
      if (_YWebPage.widgets[i] instanceof gaugeWidget)
        XmlConfigFile += _YWebPage.widgets[i].getConfigData();
      if (_YWebPage.widgets[i] instanceof digitalDisplayWidget)
        XmlConfigFile += _YWebPage.widgets[i].getConfigData();
    }
    XmlConfigFile += sensorsManager.getXMLSensorsConfig();
    XmlConfigFile += "</ROOT>\n";
    return XmlConfigFile;
  }
  //#endif
  static get readonly() {
    let res = true;
    res = _YWebPage._saveFunction == null;
    return res;
  }
  //#ifndef READONLY
  // stub for dev tests
  static async runInternalTest() {
  }
  //#endif
  static async save(force) {
    if (_YWebPage.readonly)
      return true;
    let xml = this.get_XmlData();
    let newCRC = constants.crc32(xml);
    if (!force && newCRC == _YWebPage.xmlDataCRC)
      return true;
    let saveDoneCallback = (ok, message) => {
      let div = document.createElement("DIV");
      div.style.position = "Fixed";
      div.style.left = "5px";
      div.style.top = "5px";
      div.style.padding = "2px 5px 2px 5px";
      div.style.margin = "2px 2px 2px 2px";
      div.style.border = "1px solid darkgreen";
      div.style.fontFamily = "Arial";
      div.style.fontSize = (12 * constants.guiDPIFactor).toString();
      div.style.whiteSpace = "nowrap";
      div.style.zIndex = "200000";
      div.style.textAlign = "center";
      div.style.opacity = "1";
      let fgcolor = ok ? "darkgreen" : "darkred";
      let bgcolor = ok ? "#b9eea9" : "#eea9a9";
      div.style.opacity = "1";
      div.style.backgroundColor = bgcolor;
      div.style.border = "1px solid " + fgcolor;
      div.style.color = fgcolor;
      div.innerText = message;
      document.body.appendChild(div);
      setTimeout(() => {
        _YWebPage.handleSavedNotification(div);
      }, 100);
    };
    try {
      if (_YWebPage._saveFunction != null) {
        return await _YWebPage._saveFunction(this.get_XmlData(), saveDoneCallback);
      }
    } catch (e) {
      saveDoneCallback(false, "Save failed");
      alert2.show("Configuration save failed, sorry\n" + e.message);
      return false;
    }
    _YWebPage.xmlDataCRC = newCRC;
    logForm.log("Configuration saved.");
    constants.edited = false;
    return true;
  }
  static handleSavedNotification(div) {
    let opacity = parseFloat(div.style.opacity) - 0.05;
    if (opacity < 0) {
      document.body.removeChild(div);
      return;
    }
    div.style.opacity = opacity.toString();
    setTimeout(() => {
      _YWebPage.handleSavedNotification(div);
    }, 100);
  }
  //#ifndef READONLY
  // Will just print the XML  config  file on the page
  static Dummysave(xml) {
    let contents = document.createElement("PRE");
    contents.innerText = xml;
    document.body.appendChild(contents);
    return true;
  }
};
YWebPage.baseSize = 18 * constants.generalSizeCoef;
YWebPage.xmlDataCRC = 0;
YWebPage.widgets = [];
YWebPage._markersSubMenuItems = [];
YWebPage._editor = null;
YWebPage._mainform = null;
YWebPage._saveFunction = null;
YWebPage._MarkerCountPerXaxis = 0;
YWebPage.ConfigChangedConfirmWindows = null;
YWebPage.saveIntDiv = null;
var HTTPrequestResult = class {
  constructor(data, status, statusText) {
    this._data = data;
    this._status = status;
    this._statusText = statusText;
  }
  get data() {
    return this._data;
  }
  get status() {
    return this._status;
  }
  get statusText() {
    return this._statusText;
  }
};
var HubInfo = class {
  get protocol() {
    return this._protocol;
  }
  get addr() {
    return this._addr;
  }
  get port() {
    return this._port;
  }
  get path() {
    return this._path;
  }
  get userPassword() {
    return this._userPassword;
  }
  get adminPassword() {
    return this._adminPassword;
  }
  get serial() {
    return this._serial;
  }
  get srvUsername() {
    return this._srvusername != null ? this._srvusername : "";
  }
  get srvPassword() {
    return this._srvpassword != null ? this._srvpassword : "";
  }
  constructor(protocol, addr, port, path, srvusername, srvpassword) {
    this._userPassword = false;
    this._adminPassword = false;
    this._cred = "";
    this._serial = "";
    this._srvusername = null;
    this._srvpassword = null;
    if (protocol.slice(-1) == ":")
      protocol = protocol.slice(0, -1);
    this._protocol = protocol;
    this._addr = addr;
    this._port = port;
    this._protocol = protocol;
    this._path = path;
    if (srvusername !== void 0)
      this._srvusername = srvusername;
    if (srvpassword !== void 0)
      this._srvpassword = srvpassword;
    if (this._path != "") {
      if (this._path.charAt(0) == "/") {
        this._path = this._path.slice(1);
      }
    }
    if (this._path != "") {
      if (this._path.slice(-1) == "/") {
        this._path = this._path.slice(0, -1);
      }
    }
  }
  get_hubUrl(user, password) {
    let url = this.protocol + "://";
    if (typeof user != "undefined" && user != "") {
      if (user != "") {
        url += user + ":" + password + "@";
      }
    }
    url += this.addr + ":" + this.port.toString();
    if (this.path != "")
      url += "/" + this.path;
    return url;
  }
  async makeRequest() {
    let url = this._protocol + "://" + this._addr + ":" + this._port.toString();
    if (this._path != "")
      url += "/" + this._path;
    url += "/info.json";
    let response;
    try {
      response = await fetch(url, { mode: "cors" });
    } catch (e) {
      return -3;
    }
    if (response.ok) {
      let HubData;
      try {
        HubData = await response.json();
      } catch (e) {
        return -1;
      }
      if (HubData.port && HubData.port.length > 0) {
        let proto_port = HubData.port[0].split(":");
        this._protocol = proto_port[0];
        this._port = parseInt(proto_port[1]);
      }
      this._serial = HubData.serialNumber;
      this._path = HubData.dir;
      this._adminPassword = HubData.adminPassword.toUpperCase() == "TRUE";
      this._userPassword = HubData.userPassword.toUpperCase() == "TRUE";
      return true;
    }
    if (response.status == 404 && this._path != "")
      return -2;
    if (response.status == 0 && response.statusText == null)
      return -3;
    return response.status;
  }
  findChild(parent, name) {
    let res = null;
    parent.childNodes.forEach((node) => {
      if (node.nodeName == name) {
        res = node;
        return;
      }
    });
    return res;
  }
  findOutCredentialsFromConfigFile(xmlData) {
    if (xmlData == null)
      return;
    let parser = new DOMParser();
    let doc = parser.parseFromString(xmlData, "application/xml");
    let rootNode = this.findChild(doc, "ROOT");
    if (rootNode == null)
      return;
    let configNode = this.findChild(rootNode, "Config");
    if (configNode == null)
      return;
    let Hubs = this.findChild(configNode, "Hubs");
    if (Hubs == null)
      return;
    let HubSection;
    let list = Hubs.childNodes;
    let sourceHubFound = false;
    for (let i = 0; i < list.length; i++) {
      if (list[i].nodeName == "Hub") {
        let node = new YXmlNode(list[i]);
        let attributes = node.Attributes;
        let addr = attributes.hasOwnProperty("addr") ? attributes["addr"] : "";
        let port = attributes.hasOwnProperty("port") ? attributes["port"] : "80";
        let protocol = attributes.hasOwnProperty("protocol") ? attributes["protocol"] : "";
        let path = attributes.hasOwnProperty("path") ? attributes["path"] : "";
        let username = attributes.hasOwnProperty("user") ? attributes["user"] : "";
        let password = attributes.hasOwnProperty("password") ? attributes["password"] : "";
        let a1 = addr.toUpperCase();
        if (a1.substring(0, 4) == "WWW.")
          a1 = a1.substring(4);
        let a2 = this._addr.toUpperCase();
        if (a2.substring(0, 4) == "WWW.")
          a2 = a2.substring(4);
        if (a1 == a2 && path == this._path) {
          this._srvusername = username;
          this._srvpassword = Hub.Decrypt(password, Hub.loginCypherPassword);
        }
      }
    }
  }
};
var YoctoHubFileHandler = class _YoctoHubFileHandler {
  //#endif
  constructor(hubInfo) {
    this.filename = "";
    this.xmldata = "";
    this.htmlSrcCode = "";
    this.FileSystemAccessDenied = false;
    this._XMLConfigFileChanged = null;
    this.fileSystem = null;
    this.fileSystemReady = false;
    this.configFileCRC = -1;
    this.info = hubInfo;
  }
  async init(defaultXmlConfigFileContents) {
    let url = location.href;
    this.filename = url.substring(url.lastIndexOf("/") + 1);
    let p = this.filename.indexOf("?");
    if (p > 0)
      this.filename = this.filename.substring(0, p);
    this.htmlSrcCode = document.documentElement.outerHTML;
    if (typeof defaultXmlConfigFileContents === "undefined" || defaultXmlConfigFileContents == "") {
      this.xmldata = '<?xml version="1.0" ?>\n<ROOT version="2.1">\n<Config>\n<Hubs>\n<Hub protocol="' + this.info.protocol + '" addr="' + this.info.addr + '" port="' + this.info.port.toString() + '"' + (this.info.path != "" ? ' path="' + this.info.path + '"' : "") + ' removable="FALSE"/>\n</Hubs>\n</Config>\n</ROOT>\n';
    } else {
      this.xmldata = defaultXmlConfigFileContents;
    }
    this.fileSystem = null;
    this.fileSystemReady = false;
    await this.findSourceFileSystem(defaultXmlConfigFileContents);
  }
  static async start(defaultXmlConfigFileContents) {
    let dirpath = location.pathname;
    let defport = "80";
    let slashpos = dirpath.lastIndexOf("/");
    if (slashpos > 0) {
      dirpath = dirpath.slice(0, slashpos);
    } else {
      dirpath = "";
    }
    if (location.protocol == "https:") {
      defport = "443";
    }
    let hubinfo = new HubInfo(location.protocol, location.hostname, parseInt(location.port ? location.port : defport), dirpath);
    await hubinfo.makeRequest();
    let filehandler = new _YoctoHubFileHandler(hubinfo);
    await filehandler.init(defaultXmlConfigFileContents);
    return filehandler;
  }
  get xmlConfigData() {
    return this.xmldata;
  }
  static makeRequest(method, url, username, password) {
    return new Promise(function(resolve, reject) {
      let xhr = new XMLHttpRequest();
      if (username !== void 0 && password !== void 0 && username != null && password !== null) {
        xhr.open(method, url, true, username, password);
        xhr.withCredentials = true;
      } else {
        xhr.open(method, url);
      }
      xhr.overrideMimeType("text/plain; charset=x-user-defined");
      xhr.onreadystatechange = function() {
        if (xhr.readyState == 4) {
          if (this.status >= 200 && this.status < 300) {
            resolve(new HTTPrequestResult(YAPI.imm_str2bin(xhr.response), this.status, xhr.statusText));
          } else {
            resolve(new HTTPrequestResult(null, this.status, xhr.statusText));
          }
        }
      };
      xhr.onerror = function() {
        resolve(new HTTPrequestResult(null, this.status, xhr.statusText));
      };
      xhr.send();
    });
  }
  //#ifndef READONLY
  async findSourceFileSystem(xmldata) {
    this.fileSystem = null;
    let errmsg = new YErrorMsg();
    this.info.findOutCredentialsFromConfigFile(xmldata);
    let url = this.info.get_hubUrl(this.info.srvUsername, this.info.srvPassword);
    let errorNo = YAPI.SUCCESS;
    let errorMsg = "";
    try {
      errorNo = await YAPI.RegisterHub(url, errmsg);
      errorMsg = errmsg.msg;
    } catch (e) {
      errorNo = e.errorType;
      errorMsg = e.message;
    }
    if (errorNo != YAPI.SUCCESS) {
      this.fileSystemReady = false;
      if (errorNo == YAPI.UNAUTHORIZED) {
        console.log("Access to hub " + url + " is denied, waiting for YV callback to save the situation.");
        this.FileSystemAccessDenied = true;
        return;
      }
      throw "YV4F ERROR: Unable to register Hub " + this.info.get_hubUrl() + "(" + errorMsg + "), save will not work.";
    }
    let fs = YFiles.FirstFiles();
    if (fs == null) {
      this.fileSystemReady = true;
      throw "YV4F ERROR: No file system found on Hub " + this.info.get_hubUrl() + ", save will not work.";
    }
    while (fs != null) {
      if (await fs.get_serialNumber() == this.info.serial) {
        await this.registerSourceFileSystem(fs);
        return;
      }
      fs = fs.nextFiles();
    }
    fs = YFiles.FirstFiles();
    while (fs != null) {
      let m = await fs.get_module();
      let url2 = await m.get_url();
      console.log("URL = (" + url2 + ")");
      let p = url2.indexOf("://");
      if (p >= 0)
        url2 = url2.slice(p + 3);
      p = url2.indexOf(":");
      if (p > 0)
        url2 = url2.slice(0, p);
      {
        if (url2 == this.info.addr) {
          await this.registerSourceFileSystem(fs);
          return;
        }
      }
      fs = fs.nextFiles();
    }
    this.fileSystemReady = true;
    throw "YV4F ERROR: No file system matching Hub " + this.info.get_hubUrl() + " found, save will not work.";
  }
  async registerSourceFileSystem(fs) {
    this.fileSystem = fs;
    this.fileSystemReady = true;
    this.FileSystemAccessDenied = false;
    let entries = await this.fileSystem.get_list(this.filename);
    if (entries.length > 0)
      this.configFileCRC = await entries[0].get_crc();
  }
  // called from Yocto-visualization when a Module had a config change and
  // will find out if the config change source is the web page host and if
  // the original file has changed. This is called from a string of callbacks
  // because there can be only one change call back per module, and it is
  // already used by the Sensor manager
  async configChangeCallback(m) {
    if (this.fileSystem == null) {
      let urlSignature = this.info.addr + ":" + this.info.port.toString() + "/" + this.info.path + (this.info.path != "" ? "/" : "");
      let sourceUrl = await m.get_url();
      console.log("urlSignature=" + urlSignature);
      console.log("sourceUrl=" + sourceUrl);
      if (sourceUrl.length > urlSignature.length && sourceUrl.substring(sourceUrl.length - urlSignature.length) == urlSignature) {
        let fs = YFiles.FindFiles(await m.get_serialNumber() + ".files");
        if (await fs.isOnline())
          await this.registerSourceFileSystem(fs);
      }
    }
    if (this.fileSystem == null)
      return null;
    if (await this.fileSystem.get_serialNumber() != await m.get_serialNumber())
      return null;
    let entries = await this.fileSystem.get_list(this.filename);
    if (entries.length <= 0)
      return null;
    if (this.configFileCRC == await entries[0].get_crc())
      return null;
    let data = await this.fileSystem.download(this.filename);
    let file = new TextDecoder("utf-8").decode(data);
    let indexStart = file.indexOf(_YoctoHubFileHandler.signatureStart);
    if (indexStart < 0)
      return null;
    this.configFileCRC = await entries[0].get_crc();
    indexStart += _YoctoHubFileHandler.signatureStart.length;
    let indexEnd = file.indexOf(_YoctoHubFileHandler.signatureEnd);
    if (indexEnd < indexStart)
      return "";
    indexEnd += _YoctoHubFileHandler.signatureEnd.length - 2;
    let configdata = file.substring(indexStart, indexEnd);
    try {
      return JSON.parse(configdata);
    } catch (e) {
    }
    return null;
  }
  get configChangeCallbackFct() {
    return async (module) => {
      return await this.configChangeCallback(module);
    };
  }
  get saveFct() {
    return async (xml, callback) => {
      return await this.saveFctinternal(xml, callback);
    };
  }
  async retryWithNewCredentials(xml, username, password, callback) {
    if (this.fileSystem == null) {
      debugger;
      return;
    }
    let m = await this.fileSystem.get_module();
    let url = await m.get_url();
    let err = new YErrorMsg();
    let p1 = url.indexOf("://");
    let p2 = url.indexOf("@", p1 + 3);
    let newurl = url.substring(0, p1 + 3) + username + ":" + password + "@";
    if (p2 < 0)
      newurl += url.substring(p1 + 3);
    else
      newurl += url.substring(p2 + 1);
    await YAPI.UnregisterHub(url);
    if (await YAPI.RegisterHub(newurl, err) != YAPI.SUCCESS) {
      await YAPI.RegisterHub(url, err);
    }
    try {
      if (!await this.saveFctinternal(xml, callback))
        return;
    } catch (e) {
      if (callback != null)
        callback(false, "Save failed (" + e.message) + ")";
      return;
    }
  }
  async saveFctinternal(xml, callback) {
    if (this.FileSystemAccessDenied) {
      throw "YV4F ERROR: Access to file system on " + this.info.get_hubUrl() + " is denied, it is probably password protected. Check network connections in the global configuration.";
    }
    if (this.fileSystem == null) {
      throw "YV4F ERROR: No file system, Save aborted";
    }
    if (!this.fileSystemReady) {
      throw "YV4F ERROR: File system is not ready yet, retry in a few seconds.";
    }
    if (!this.fileSystem.isOnline()) {
      throw "YV4F ERROR: File system is off line, Save aborted";
    }
    let tosave = "";
    let index = this.htmlSrcCode.indexOf(_YoctoHubFileHandler.signatureStart + ")");
    if (index > 0) {
      tosave = this.htmlSrcCode.substring(0, index + _YoctoHubFileHandler.signatureStart.length) + JSON.stringify(xml) + this.htmlSrcCode.substring(index + _YoctoHubFileHandler.signatureStart.length);
    } else {
      let index1 = this.htmlSrcCode.indexOf(_YoctoHubFileHandler.signatureStart);
      let index2 = this.htmlSrcCode.indexOf(_YoctoHubFileHandler.signatureEnd);
      if (index1 > 0 && index2 && index2 > index1) {
        tosave = this.htmlSrcCode.substring(0, index1 + _YoctoHubFileHandler.signatureStart.length) + JSON.stringify(xml) + ");" + this.htmlSrcCode.substring(index2 + _YoctoHubFileHandler.signatureEnd.length);
      } else {
        throw "Unable to locate YoctoHubFileHandler constructor call in original HTML file.";
      }
    }
    tosave = "<!DOCTYPE html>\n" + tosave;
    let GZdata = Pako_Deflate.gzip(tosave, { level: 9 });
    let askForRwCredentials = false;
    try {
      await this.fileSystem.upload(this.filename + ".gz", GZdata);
    } catch (e) {
      if (this.fileSystem.get_errorType() == YAPI_UNAUTHORIZED)
        askForRwCredentials = true;
      else
        throw e;
    }
    if (askForRwCredentials) {
      let m = await this.fileSystem.get_module();
      let url = await m.get_url();
      let err = new YErrorMsg();
      let p1 = url.indexOf("://");
      let p2 = url.indexOf("@", p1 + 3);
      if (p2 >= 0)
        url = url.substring(p2 + 1);
      else if (p1 >= 0)
        url = url.substring(p1 + 3);
      await CredentialsPrompt.show(url, async () => {
        await this.retryWithNewCredentials(xml, CredentialsPrompt.username, CredentialsPrompt.password, callback);
      });
      if (callback != null)
        callback(false, "Save failed, credentials required");
      return false;
    }
    let entries = await this.fileSystem.get_list(this.filename);
    if (entries.length > 0)
      this.configFileCRC = await entries[0].get_crc();
    if (callback != null)
      callback(true, "Save sucessfull");
    return true;
  }
};
YoctoHubFileHandler.signatureStart = "YoctoHubFileHandler.start(";
YoctoHubFileHandler.signatureEnd = '</ROOT>\\n");';

// obj/full/logForm.js
var logForm = class _logForm {
  static show() {
    if (_logForm._window == null) {
      let params = new newWindowParam();
      params.positionType = 0;
      params.width = 8 * window.innerWidth / 10 >> 0;
      params.height = 6 * window.innerHeight / 10 >> 0;
      params.left = 1 * window.innerWidth / 10 >> 0;
      params.top = 2 * window.innerHeight / 10 >> 0;
      params.title = "LogFile";
      _logForm._window = new YWindow(params);
      _logForm._contents = _logForm._window.innerContentDiv;
      _logForm._contents.style.fontFamily = "courrier";
      _logForm._contents.style.fontSize = (10 * constants.generalSizeCoef).toString() + "px";
      _logForm._contents.style.overflow = "auto";
      for (let i = 0; i < _logForm._lines.length; i++) {
        _logForm.addLine(_logForm._lines[i]);
      }
    }
    _logForm._window.show();
  }
  static addLine(st) {
    let pre = document.createElement("PRE");
    pre.style.marginTop = "0";
    pre.style.marginBottom = "0";
    pre.innerText = st;
    _logForm._contents.appendChild(pre);
    while (_logForm._contents.childElementCount > 1e3) {
      _logForm._contents.removeChild(_logForm._contents.firstChild);
    }
  }
  static padStart(st, length) {
    while (st.length < length) {
      st = "0" + st;
    }
    return st;
  }
  static dateToString(d) {
    return d.getFullYear().toString() + "-" + _logForm.padStart((d.getMonth() + 1).toString(), 2) + "-" + _logForm.padStart(d.getDate().toString(), 2) + " " + _logForm.padStart(d.getHours().toString(), 2) + ":" + _logForm.padStart(d.getMinutes().toString(), 2) + ":" + _logForm.padStart((d.getSeconds() + d.getMilliseconds() / 1e3).toFixed(3), 6);
  }
  static log(st) {
    _logForm.logNOTS(_logForm.dateToString(/* @__PURE__ */ new Date()) + " " + st);
  }
  static logNOTS(st) {
    _logForm._lines.push(st);
    if (_logForm._lines.length > 1e3) {
      _logForm._lines.splice(0, _logForm._lines.length - 1e3);
    }
    if (_logForm._window != null)
      _logForm.addLine(st);
  }
};
logForm._lines = [];

// obj/full/rawDataForm.js
var rawDataForm = class _rawDataForm {
  static hide() {
    if (_rawDataForm._window == null)
      return;
    _rawDataForm._window.visible = false;
  }
  static show() {
    if (_rawDataForm._window == null) {
      let params = new newWindowParam();
      params.positionType = 1;
      params.width = 9 * window.innerWidth / 10 >> 0;
      params.height = 8 * window.innerHeight / 10 >> 0;
      params.title = "Raw data";
      _rawDataForm._window = new YWindow(params);
      _rawDataForm._contents = _rawDataForm._window.innerContentDiv;
      _rawDataForm._statusline = document.createElement("DIV");
      _rawDataForm._statusline.style.position = "absolute";
      _rawDataForm._statusline.style.left = constants.WindowPadding.toString() + "px";
      _rawDataForm._statusline.style.right = constants.WindowPadding.toString() + "px";
      _rawDataForm._statusline.style.height = (_rawDataForm.STATUSLINEHEIGHT * constants.generalSizeCoef).toString() + "px";
      _rawDataForm._statusline.style.bottom = constants.WindowPadding.toString() + "px";
      _rawDataForm._statusline.style.paddingTop = Math.round(5 * constants.generalSizeCoef).toString() + "px";
      _rawDataForm._statusline.style.paddingLeft = "5px";
      _rawDataForm._statusline.style.paddingRight = "5px";
      _rawDataForm._statusline.style.overflowX = "auto";
      _rawDataForm._statusline.style.paddingRight = "5px";
      _rawDataForm._contents.append(_rawDataForm._statusline);
      _rawDataForm._sensorsList = document.createElement("DIV");
      _rawDataForm._sensorsList.style.position = "absolute";
      _rawDataForm._sensorsList.style.left = constants.WindowPadding.toString() + "px";
      _rawDataForm._sensorsList.style.right = (_rawDataForm.sensorListWidth * constants.generalSizeCoef + 8 * constants.WindowPadding).toString() + "px";
      _rawDataForm._sensorsList.style.top = "2px";
      _rawDataForm._sensorsList.style.overflowY = "auto";
      _rawDataForm._sensorsList.style.height = (_rawDataForm.topMargin * constants.generalSizeCoef).toString() + "px";
      _rawDataForm._sensorsList.style.paddingLeft = "5px";
      _rawDataForm._sensorsList.style.paddingRight = "5px";
      _rawDataForm._sensorsList.style.border = constants.WindowInnerBorder;
      _rawDataForm._sensorsList.style.backgroundColor = constants.WindowInnerBackgroundColor;
      _rawDataForm._contents.append(_rawDataForm._sensorsList);
      _rawDataForm._optionsList = document.createElement("DIV");
      _rawDataForm._optionsList.style.position = "absolute";
      _rawDataForm._optionsList.style.width = (_rawDataForm.sensorListWidth * constants.generalSizeCoef).toString() + "px";
      _rawDataForm._optionsList.style.right = constants.WindowPadding.toString() + "px";
      _rawDataForm._optionsList.style.top = "0px";
      _rawDataForm._optionsList.style.height = (_rawDataForm.topMargin * constants.generalSizeCoef).toString() + "px";
      _rawDataForm._optionsList.style.paddingLeft = "5px";
      _rawDataForm._optionsList.style.paddingRight = "5px";
      _rawDataForm._optionsList.style.border = "1px solid transparent";
      _rawDataForm._contents.append(_rawDataForm._optionsList);
      let br;
      _rawDataForm._optionMIN = document.createElement("INPUT");
      _rawDataForm._optionMIN.type = "input";
      _rawDataForm._optionMIN.checked = false;
      _rawDataForm._optionMIN.style.display = "inline";
      _rawDataForm._optionMIN.type = "checkbox";
      _rawDataForm._optionMIN.style.transform = "scale(" + constants.generalSizeCoef.toString() + ")";
      _rawDataForm._optionMIN.style.marginRight = Math.round(5 * constants.generalSizeCoef).toString() + "px";
      _rawDataForm._optionMIN.addEventListener("change", () => {
        _rawDataForm.refresh();
      });
      _rawDataForm._optionsList.append(_rawDataForm._optionMIN);
      let span;
      span = document.createElement("SPAN");
      span.innerText = "Include minimum values";
      _rawDataForm._optionsList.append(span);
      br = document.createElement("BR");
      _rawDataForm._optionsList.append(br);
      _rawDataForm._optionAVG = document.createElement("INPUT");
      _rawDataForm._optionAVG.type = "input";
      _rawDataForm._optionAVG.checked = true;
      _rawDataForm._optionAVG.style.display = "inline";
      _rawDataForm._optionAVG.type = "checkbox";
      _rawDataForm._optionAVG.style.transform = "scale(" + constants.generalSizeCoef.toString() + ")";
      _rawDataForm._optionAVG.style.marginRight = Math.round(5 * constants.generalSizeCoef).toString() + "px";
      _rawDataForm._optionAVG.addEventListener("change", () => {
        _rawDataForm.refresh();
      });
      _rawDataForm._optionsList.append(_rawDataForm._optionAVG);
      span = document.createElement("SPAN");
      span.innerText = "Include average values";
      _rawDataForm._optionsList.append(span);
      br = document.createElement("BR");
      _rawDataForm._optionsList.append(br);
      _rawDataForm._optionMAX = document.createElement("INPUT");
      _rawDataForm._optionMAX.type = "input";
      _rawDataForm._optionMAX.checked = false;
      _rawDataForm._optionMAX.style.display = "inline";
      _rawDataForm._optionMAX.type = "checkbox";
      _rawDataForm._optionMAX.style.transform = "scale(" + constants.generalSizeCoef.toString() + ")";
      _rawDataForm._optionMAX.style.marginRight = Math.round(5 * constants.generalSizeCoef).toString() + "px";
      _rawDataForm._optionMAX.addEventListener("change", () => {
        _rawDataForm.refresh();
      });
      _rawDataForm._optionsList.append(_rawDataForm._optionMAX);
      span = document.createElement("SPAN");
      span.innerText = "Include maximum values";
      _rawDataForm._optionsList.append(span);
      _rawDataForm._optionsList.append(document.createElement("BR"));
      _rawDataForm._optionsList.append(document.createElement("BR"));
      let p = document.createElement("P");
      p.style.textAlign = "center";
      let refreshBtn = new button("refresh", () => {
        _rawDataForm.refresh();
      });
      p.appendChild(refreshBtn.Element);
      let ExportBtn = new button("export", () => {
        _rawDataForm.export();
      });
      p.appendChild(ExportBtn.Element);
      _rawDataForm._optionsList.append(p);
      _rawDataForm._datacontents = document.createElement("DIV");
      _rawDataForm._datacontents.style.position = "absolute";
      _rawDataForm._datacontents.style.left = constants.WindowPadding.toString() + "px";
      _rawDataForm._datacontents.style.right = constants.WindowPadding.toString() + "px";
      _rawDataForm._datacontents.style.top = (_rawDataForm.topMargin * constants.generalSizeCoef + 5 * constants.WindowPadding).toString() + "px";
      _rawDataForm._datacontents.style.bottom = (4 * constants.WindowPadding + _rawDataForm.STATUSLINEHEIGHT * constants.generalSizeCoef).toString() + "px";
      _rawDataForm._datacontents.style.paddingLeft = "5px";
      _rawDataForm._datacontents.style.paddingRight = "5px";
      _rawDataForm._datacontents.style.overflowX = "auto";
      _rawDataForm._datacontents.style.paddingRight = "5px";
      _rawDataForm._contents.append(_rawDataForm._datacontents);
      _rawDataForm._dataTable = document.createElement("TABLE");
      _rawDataForm._dataTable.style.position = "absolute";
      _rawDataForm._dataTable.style.overflow = "auto";
      _rawDataForm._dataTable.style.left = "0px";
      _rawDataForm._dataTable.style.width = "100%";
      _rawDataForm._dataTable.style.top = "0px";
      _rawDataForm._dataTable.style.bottom = "0px";
      _rawDataForm._dataTable.style.fontSize = constants.generalFontSize.toString() + "px";
      _rawDataForm._dataTable.style.borderCollapse = "colapse";
      _rawDataForm._dataTable.style.borderSpacing = "0px";
      _rawDataForm._dataTable.style.fontFamily = "sans-serif";
      _rawDataForm._datacontents.appendChild(_rawDataForm._dataTable);
    }
    _rawDataForm._window.show();
    _rawDataForm.refresh();
  }
  static refresh() {
    let list = [];
    for (let i = 0; i < sensorsManager.sensorList.length; i++) {
      if (!(sensorsManager.sensorList[i] instanceof NullYSensor)) {
        list.push(sensorsManager.sensorList[i]);
      }
    }
    _rawDataForm._selection = [];
    for (let i = 0; i < list.length; i++) {
      let spanNode;
      let spanText;
      let input;
      if (i >= _rawDataForm._sensorsList.childNodes.length) {
        spanNode = document.createElement("SPAN");
        input = document.createElement("INPUT");
        input.type = "input";
        input.checked = false;
        input.style.display = "inline";
        input.type = "checkbox";
        input.style.transform = "scale(" + constants.generalSizeCoef.toString() + ")";
        input.style.marginRight = Math.round(5 * constants.generalSizeCoef).toString() + "px";
        input.addEventListener("change", () => {
          _rawDataForm.refresh();
        });
        spanNode.appendChild(input);
        spanText = document.createElement("SPAN");
        spanNode.appendChild(spanText);
        _rawDataForm._sensorsList.appendChild(spanNode);
        spanNode.appendChild(document.createElement("BR"));
      } else {
        spanNode = _rawDataForm._sensorsList.childNodes[i];
        input = spanNode.childNodes[0];
        spanText = spanNode.childNodes[1];
      }
      if (input.checked)
        _rawDataForm._selection.push(list[i]);
      input.id = list[i].get_hardwareId();
      spanText.innerText = list[i].get_friendlyName();
    }
    while (_rawDataForm._sensorsList.childNodes.length > list.length) {
      _rawDataForm._sensorsList.removeChild(_rawDataForm._sensorsList.lastChild);
    }
    _rawDataForm.RefreshContents(_rawDataForm._selection);
  }
  static padStart(st, length) {
    while (st.length < length) {
      st = "0" + st;
    }
    return st;
  }
  static UnixTimeStampTostring(ts) {
    let d = new Date(Date.UTC(1970, 0, 1));
    d.setUTCSeconds(ts >> 0, 1e3 * (ts % 1));
    return d.getFullYear().toString() + "-" + _rawDataForm.padStart((d.getMonth() + 1).toString(), 2) + "-" + _rawDataForm.padStart(d.getDate().toString(), 2) + " " + _rawDataForm.padStart(d.getHours().toString(), 2) + ":" + _rawDataForm.padStart(d.getMinutes().toString(), 2) + ":" + _rawDataForm.padStart((d.getSeconds() + d.getMilliseconds() / 1e3).toFixed(3), 6);
  }
  static RefreshContents(slist) {
    let TH = document.createElement("THEAD");
    let TB = document.createElement("TBODY");
    let HR1 = document.createElement("TR");
    let HR2 = document.createElement("TR");
    let indexes = [];
    for (let i = 0; i < slist.length; i++) {
      indexes.push(slist[i].curData.length - 1);
    }
    while (_rawDataForm._dataTable.childNodes.length > 0) {
      _rawDataForm._dataTable.removeChild(_rawDataForm._dataTable.lastChild);
    }
    _rawDataForm._dataTable.appendChild(TH);
    _rawDataForm._dataTable.appendChild(TB);
    let sMin = false;
    let sMax = false;
    let sAvg = false;
    let toShow = 0;
    if (_rawDataForm._optionMIN.checked) {
      sMin = true;
      toShow++;
    }
    if (_rawDataForm._optionAVG.checked) {
      sAvg = true;
      toShow++;
    }
    if (_rawDataForm._optionMAX.checked) {
      sMax = true;
      toShow++;
    }
    TH.appendChild(HR1);
    TH.appendChild(HR2);
    let cell = document.createElement("TH");
    HR1.appendChild(cell);
    cell = document.createElement("TH");
    HR2.appendChild(cell);
    for (let i = 0; i < slist.length; i++) {
      cell = document.createElement("TH");
      cell.innerText = slist[i].get_friendlyName();
      cell.colSpan = Math.max(1, toShow);
      cell.style.backgroundColor = "#f0f0f0";
      cell.style.borderLeft = constants.WindowInnerBorder;
      cell.style.borderRight = constants.WindowInnerBorder;
      cell.style.borderTop = constants.WindowInnerBorder;
      HR1.appendChild(cell);
      if (sMin) {
        cell = document.createElement("TH");
        cell.innerText = "Min";
        cell.style.borderLeft = constants.WindowInnerBorder;
        cell.style.borderRight = sAvg || sMax ? "" : constants.WindowInnerBorder;
        cell.style.backgroundColor = "#f0f0f0";
        cell.style.textAlign = "right";
        HR2.appendChild(cell);
      }
      if (sAvg) {
        cell = document.createElement("TH");
        cell.innerText = "Avg";
        cell.style.borderLeft = sMin ? "" : constants.WindowInnerBorder;
        cell.style.borderRight = sMax ? "" : constants.WindowInnerBorder;
        cell.style.backgroundColor = "#f0f0f0";
        cell.style.textAlign = "right";
        HR2.appendChild(cell);
      }
      if (sMax) {
        cell = document.createElement("TH");
        cell.innerText = "Max";
        cell.style.borderLeft = sAvg || sMin ? "" : constants.WindowInnerBorder;
        cell.style.borderRight = constants.WindowInnerBorder;
        cell.style.backgroundColor = "#f0f0f0";
        cell.style.textAlign = "right";
        HR2.appendChild(cell);
      }
    }
    let colcount = slist.length * toShow;
    let MaxTimeStamp = 0;
    for (let i = 0; i < slist.length; i++) {
      if (indexes[i] >= 0) {
        if (MaxTimeStamp < slist[i].curData[indexes[i]].DateTime) {
          MaxTimeStamp = slist[i].curData[indexes[i]].DateTime;
        }
      }
    }
    let rowcount = 0;
    let currentRow = null;
    while (MaxTimeStamp > 0 && rowcount < _rawDataForm.MAXRAWDATAROWS) {
      let row = new Array(colcount);
      let nextTimeStamp = 0;
      for (let i = 0; i < slist.length; i++) {
        let Shown = false;
        if (indexes[i] >= 0) {
          if (slist[i].curData[indexes[i]].DateTime == MaxTimeStamp) {
            let n = 0;
            if (sMin) {
              row[n + i * toShow] = slist[i].minData[indexes[i]].value.toString();
              n++;
            }
            if (sAvg) {
              row[n + i * toShow] = slist[i].curData[indexes[i]].value.toString();
              n++;
            }
            if (sMax) {
              row[n + i * toShow] = slist[i].maxData[indexes[i]].value.toString();
              n++;
            }
            Shown = true;
            indexes[i]--;
          }
          if (indexes[i] >= 0) {
            if (slist[i].curData[indexes[i]].DateTime > nextTimeStamp) {
              nextTimeStamp = slist[i].curData[indexes[i]].DateTime;
            }
          }
        }
        if (!Shown) {
          let n = 0;
          if (sMin) {
            row[n + i * toShow] = "";
            n++;
          }
          if (sAvg) {
            row[n + i * toShow] = "";
            n++;
          }
          if (sMax) {
            row[n + i * toShow] = "";
            n++;
          }
        }
      }
      if (colcount > 0 && toShow > 0) {
        currentRow = document.createElement("TR");
        let cell2 = document.createElement("TD");
        cell2.innerText = _rawDataForm.UnixTimeStampTostring(MaxTimeStamp).toLocaleString();
        cell2.style.borderLeft = constants.WindowInnerBorder;
        cell2.style.borderTop = rowcount == 0 ? constants.WindowInnerBorder : "";
        cell2.style.backgroundColor = "#f0f0f0";
        currentRow.style.backgroundColor = (rowcount & 1) == 0 ? "white" : "#f0f0f0";
        currentRow.appendChild(cell2);
        for (let j = 0; j < row.length; j++) {
          cell2 = document.createElement("TD");
          cell2.innerText = row[j];
          cell2.style.textAlign = "right";
          cell2.style.borderLeft = j % toShow == 0 ? constants.WindowInnerBorder : "";
          cell2.style.borderRight = (j + 1) % toShow == 0 ? constants.WindowInnerBorder : "";
          cell2.style.fontFamily = "monospace";
          currentRow.appendChild(cell2);
        }
        TB.appendChild(currentRow);
        rowcount++;
      }
      MaxTimeStamp = nextTimeStamp;
    }
    if (currentRow != null) {
      for (let i = 0; i < currentRow.childNodes.length; i++) {
        currentRow.childNodes[i].style.borderBottom = constants.WindowInnerBorder;
      }
    }
    if (toShow == 0) {
      _rawDataForm._statusline.style.backgroundColor = "#FF8080";
      _rawDataForm._statusline.innerText = "No data shown, select at least Min, Avg or Max options in the top-right checkboxes";
    } else if (rowcount == 0) {
      _rawDataForm._statusline.style.backgroundColor = "#FF8080";
      _rawDataForm._statusline.innerText = "No data shown, select at least one sensor in the list above.";
    } else {
      _rawDataForm._statusline.style.backgroundColor = constants.WindowBackgroundColor;
      if (rowcount < _rawDataForm.MAXRAWDATAROWS) {
        _rawDataForm._statusline.innerText = "These are the last " + rowcount.toString() + " data rows.";
      } else {
        _rawDataForm._statusline.innerText = "These are the last " + rowcount.toString() + " data rows.  Use the export feature to get the whole data set.";
      }
    }
  }
  static getCvsdata(slist, sMin, sAvg, sMax) {
    let toShow = 0;
    let indexes = [];
    for (let i = 0; i < slist.length; i++) {
      indexes.push(0);
    }
    if (sMin)
      toShow++;
    if (sAvg)
      toShow++;
    if (sMax)
      toShow++;
    let res;
    let ColumnHeader = "Timestamp";
    for (let i = 0; i < slist.length; i++) {
      let sName = slist[i].toString();
      if (sMin)
        ColumnHeader += ";" + sName + "(min)";
      if (sAvg)
        ColumnHeader += ";" + sName + "(avg)";
      if (sMax)
        ColumnHeader += ";" + sName + "(max)";
    }
    res = ColumnHeader + "\r\n";
    let colcount = slist.length * toShow;
    let MinTimeStamp = Number.POSITIVE_INFINITY;
    for (let i = 0; i < slist.length; i++) {
      if (indexes[i] < slist[i].curData.length) {
        if (MinTimeStamp > slist[i].curData[indexes[i]].DateTime) {
          MinTimeStamp = slist[i].curData[indexes[i]].DateTime;
        }
      }
    }
    while (MinTimeStamp < Number.POSITIVE_INFINITY) {
      let line = "";
      let nextTimeStamp = Number.POSITIVE_INFINITY;
      for (let i = 0; i < slist.length; i++) {
        let Shown = false;
        if (indexes[i] < slist[i].curData.length) {
          if (slist[i].curData[indexes[i]].DateTime == MinTimeStamp) {
            if (sMin)
              line += ";" + slist[i].minData[indexes[i]].value.toString();
            if (sAvg)
              line += ";" + slist[i].curData[indexes[i]].value.toString();
            if (sMax)
              line += ";" + slist[i].maxData[indexes[i]].value.toString();
            Shown = true;
            indexes[i]++;
          }
          if (indexes[i] < slist[i].curData.length) {
            if (slist[i].curData[indexes[i]].DateTime < nextTimeStamp) {
              nextTimeStamp = slist[i].curData[indexes[i]].DateTime;
            }
          }
        }
        if (!Shown) {
          if (sMin)
            line += " ; ";
          if (sAvg)
            line += " ; ";
          if (sMax)
            line += " ; ";
        }
      }
      if (colcount > 0)
        line = _rawDataForm.UnixTimeStampTostring(MinTimeStamp) + line;
      res += line + "\r\n";
      MinTimeStamp = nextTimeStamp;
    }
    return res;
  }
  static export() {
    let element = document.createElement("a");
    let data = "data:text/csv;charset=utf-8," + encodeURI(_rawDataForm.getCvsdata(_rawDataForm._selection, _rawDataForm._optionMIN.checked, _rawDataForm._optionAVG.checked, _rawDataForm._optionMAX.checked));
    element.setAttribute("href", data);
    element.setAttribute("download", "rawdata.csv");
    element.style.display = "none";
    document.body.appendChild(element);
    element.click();
    document.body.removeChild(element);
  }
};
rawDataForm._lines = [];
rawDataForm.topMargin = 100;
rawDataForm.sensorListWidth = 200;
rawDataForm.MAXRAWDATAROWS = 100;
rawDataForm.STATUSLINEHEIGHT = 20;
rawDataForm._selection = [];

// obj/full/windowManager.js
var button = class {
  constructor(caption, action, sizeCoefOverload) {
    this._enabled = true;
    this._visible = true;
    this._caption = "";
    this._caption = caption;
    this._action = action;
    let GUIcoef = constants.generalSizeCoef;
    if (typeof sizeCoefOverload !== "undefined")
      GUIcoef = sizeCoefOverload;
    this._link = document.createElement("A");
    this._link.innerText = this._caption;
    this._link.style.cursor = "pointer";
    this._link.style.display = "inlineblock";
    let padding = Math.round(5 * GUIcoef).toString() + "px";
    let margin = Math.round(3 * GUIcoef).toString() + "px";
    this._link.tabIndex = 0;
    this._link.style.padding = padding + " " + padding + " " + padding + " " + padding;
    this._link.style.margin = margin + " " + margin + " " + margin + " " + margin;
    this._link.style.borderColor = "#808080";
    this._link.style.backgroundColor = "#f0f0f0";
    this._link.style.fontFamily = constants.generalFontFamily;
    this._link.style.fontSize = (16 * GUIcoef).toString() + "px";
    this._link.style.cursor = "pointer";
    this._link.style.border = constants.WindowInnerBorder;
    this._link.addEventListener("mouseover", () => {
      if (this._enabled)
        this._link.style.backgroundColor = "white";
    });
    this._link.addEventListener("mouseout", () => {
      if (this._enabled)
        this._link.style.backgroundColor = "#f0f0f0";
    });
    this._link.addEventListener("click", () => {
      if (this._enabled)
        this._action(this);
    });
    this._link.addEventListener("keypress", (e) => {
      if (this._enabled && (e.key == "Enter" || e.key == " "))
        this._action(this);
    });
  }
  get Element() {
    return this._link;
  }
  set tabIndex(index) {
    this._link.tabIndex = index;
  }
  focus() {
    this._link.focus();
  }
  get visible() {
    return this._visible;
  }
  set visible(value) {
    this._visible = value;
    this._link.style.display = this._visible ? "" : "none";
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    this.enable(value);
  }
  performAction() {
    if (!this._enabled)
      return;
    this._action(this);
  }
  showShortcut(enable) {
    if (!this._enabled)
      enable = false;
    if (enable) {
      this._link.innerHTML = "<u>" + this._caption.substring(0, 1) + "</u>" + this._caption.substring(1);
    } else {
      this._link.innerText = this._caption;
    }
  }
  enable(state) {
    if (state == this._enabled)
      return;
    this._enabled = state;
    this._link.tabIndex = state ? 0 : -1;
    if (this._enabled) {
      this._link.style.cursor = "pointer";
      this._link.style.backgroundColor = "#f0f0f0";
      this._link.style.color = "black";
    } else {
      this._link.style.backgroundColor = "#e0e0e0";
      this._link.style.cursor = "default";
      this._link.style.color = "#A0A0A0";
    }
  }
};
var newWindowParam = class _newWindowParam {
  get GUICoef() {
    return this._GUICoef;
  }
  constructor(sizeCoefOverload) {
    this.createNow = false;
    this.left = 100;
    this.top = 100;
    this.positionType = 0;
    this.width = 400;
    this.height = 300;
    this.isModal = false;
    this.showShadow = true;
    this.showContainerBorders = true;
    this.showHeader = true;
    this.title = "new Window";
    this.closeIcon = true;
    this.headerBgColor = "";
    this.bottomKeepClear = 0;
    this.contentsDefaultFontSize = constants.generalFontSize;
    this.contentsDefaultFontFamily = constants.generalFontFamily;
    this.closingCallBack = null;
    this.WindowBackgroundColor = "#f0f0f0";
    this.WindowBorder = "1px solid #808080";
    this.WindowPadding = 2;
    this.WindowInnerBorderColor = " #A0A0A0";
    this.WindowInnerBackgroundColor = "#fAfAfA";
    this.WindowInnerBorder = "1px solid " + this.WindowInnerBorderColor;
    this.WindowHeaderBackgroundColor = "#0072ca";
    this.WindowHeaderColor = "white";
    this.WindowHeaderBorder = "1px solid #0072ca";
    this._GUICoef = constants.generalSizeCoef;
    this.WindowHeaderHeight = Math.round(20 * constants.generalSizeCoef);
    this.WindowHeaderFontSize = 16 * constants.generalSizeCoef;
    this.WindowHeaderFontFamily = constants.generalFontFamily;
    this.buttons = [];
    if (typeof sizeCoefOverload !== "undefined") {
      this.WindowHeaderHeight = 20 * sizeCoefOverload;
      this.WindowHeaderFontSize = 16 * sizeCoefOverload;
      this._GUICoef = sizeCoefOverload;
    }
  }
  clone() {
    let it = new _newWindowParam();
    let keys = Object.keys(this);
    for (let i = 0; i < keys.length; i++) {
      if (keys[i] != "buttons")
        it[keys[i]] = this[keys[i]];
    }
    for (let i = 0; i < this.buttons.length; i++) {
      it.buttons.push(this.buttons[i]);
    }
    return it;
  }
};
var YWindow = class _YWindow {
  static get ConTextMenuBestZindex() {
    for (let i = 0; i < _YWindow.windowList.length; i++) {
      if (_YWindow.windowList[i].isModal())
        return -1;
    }
    return 1e5 + 2 * _YWindow.windowList.length;
  }
  constructor(params) {
    this._div = null;
    this._titleSpan = null;
    this._ModalDivShield = null;
    this._switchSideDiv = null;
    this._buttonsContainer = null;
    this._params = params.clone();
    _YWindow.windowList.push(this);
    this._contents = document.createElement("DIV");
    if (params.createNow)
      this.allocate();
  }
  get innerContentDiv() {
    return this._contents;
  }
  get bottomKeepClear() {
    return this._params.bottomKeepClear;
  }
  set bottomKeepClear(value) {
    this._params.bottomKeepClear = value;
    if (this._contents != null) {
      this._contents.style.bottom = (this._params.WindowPadding + this._params.bottomKeepClear).toString() + "px";
    }
  }
  get outterContentDiv() {
    return this._div;
  }
  isModal() {
    if (this._div == null)
      return false;
    return this._div.style.display == "" && this._params.isModal;
  }
  get visible() {
    if (this._div == null)
      return false;
    return this._div.style.display == "";
  }
  set visible(v) {
    v ? this.show() : this.hide();
  }
  show(width) {
    if (this._div == null)
      this.allocate();
    this._div.style.display = "";
    if (this._ModalDivShield != null)
      this._ModalDivShield.style.display = "";
    this.brintToFront();
    if (typeof width !== "undefined" && this._params.positionType == 2) {
      this._div.style.width = width.toString() + "px";
    }
  }
  allocate() {
    if (this._div != null)
      return;
    if (this._params.isModal) {
      this._ModalDivShield = document.createElement("DIV");
      this._ModalDivShield.style.position = "fixed";
      this._ModalDivShield.style.left = "0px";
      this._ModalDivShield.style.top = "0px";
      this._ModalDivShield.style.right = "0px";
      this._ModalDivShield.style.bottom = "0px";
      this._ModalDivShield.style.backgroundColor = "rgba(255,255,255,0.85) ";
      document.body.appendChild(this._ModalDivShield);
    }
    this._div = document.createElement("DIV");
    this._div.style.display = "none";
    switch (this._params.positionType) {
      case 0:
        this._div.style.position = "absolute";
        this._div.style.left = this._params.left.toString() + "px";
        this._div.style.top = this._params.top.toString() + "px";
        this._div.style.width = this._params.width.toString() + "px";
        this._div.style.height = this._params.height.toString() + "px";
        break;
      case 1:
        this._div.style.position = "absolute";
        this._div.style.left = "50%";
        this._div.style.top = "50%";
        this._div.style.transform = "translate(-50%, -50%)";
        this._div.style.width = this._params.width.toString() + "px";
        this._div.style.height = this._params.height.toString() + "px";
        break;
      case 2:
        this._div.style.position = "fixed";
        this._div.style.top = "5px";
        this._div.style.right = "5px";
        this._div.style.bottom = "5px";
        this._div.style.width = this._params.width.toString() + "px";
        break;
    }
    this._div.style.border = this._params.WindowBorder;
    this._div.style.backgroundColor = this._params.WindowBackgroundColor;
    if (this._params.showShadow)
      this._div.style.boxShadow = " 4px 4px 4px 1px rgba(0,0,0,0.05)";
    let containerTop = this._params.WindowPadding;
    if (this._params.showHeader) {
      containerTop = this._params.WindowHeaderHeight + 3 * this._params.WindowPadding;
      let title = document.createElement("DIV");
      title.style.position = "absolute";
      title.style.left = this._params.WindowPadding.toString() + "px";
      title.style.top = this._params.WindowPadding.toString() + "px";
      title.style.right = this._params.WindowPadding.toString() + "px";
      title.style.height = this._params.WindowHeaderHeight.toString() + "px";
      title.style.border = this._params.WindowHeaderBorder;
      title.style.backgroundColor = this._params.WindowHeaderBackgroundColor;
      title.style.fontFamily = this._params.WindowHeaderFontFamily;
      title.style.color = this._params.WindowHeaderColor;
      title.style.fontSize = this._params.WindowHeaderFontSize.toString() + "px";
      title.style.paddingLeft = "5px";
      title.style.whiteSpace = "nowrap";
      title.addEventListener("click", () => {
        this.brintToFront();
      });
      this._titleSpan = document.createElement("SPAN");
      this._titleSpan.innerText = this._params.title;
      title.appendChild(this._titleSpan);
      if (this._params.closeIcon) {
        let closeDiv = document.createElement("DIV");
        closeDiv.style.position = "absolute";
        closeDiv.style.right = "0px";
        closeDiv.style.top = "0px";
        closeDiv.style.width = Math.round(this._params.WindowHeaderHeight + 5).toString() + "px";
        closeDiv.style.height = this._params.WindowHeaderHeight.toString() + "px";
        closeDiv.style.overflow = "hide";
        closeDiv.style.paddingLeft = "5px";
        closeDiv.tabIndex = 0;
        closeDiv.style.cursor = "pointer";
        closeDiv.style.backgroundColor = this._params.WindowHeaderBackgroundColor;
        closeDiv.innerHTML = ressources.CloseIcon(this._params.WindowHeaderHeight.toString(), false, false, false, false, "Click to close this window");
        closeDiv.addEventListener("click", () => {
          this.hide();
        });
        closeDiv.addEventListener("keypress", (e) => {
          if (e.key == "Enter")
            this.hide();
        });
        title.appendChild(closeDiv);
      }
      if (this._params.positionType == 2) {
        this._switchSideDiv = document.createElement("DIV");
        this._switchSideDiv.style.position = "absolute";
        this._switchSideDiv.style.width = Math.round(this._params.WindowHeaderHeight + 5).toString() + "px";
        this._switchSideDiv.style.right = Math.round(this._params.WindowHeaderHeight + 5) + "px";
        this._switchSideDiv.style.height = this._params.WindowHeaderHeight.toString() + "px";
        this._switchSideDiv.style.overflow = "hide";
        this._switchSideDiv.style.paddingLeft = "5px";
        this._switchSideDiv.style.top = "0px";
        this._switchSideDiv.style.cursor = "pointer";
        this._switchSideDiv.style.backgroundColor = this._params.WindowHeaderBackgroundColor;
        this._switchSideDiv.innerHTML = ressources.MoveToLeftIcon(this._params.WindowHeaderHeight.toString(), false, false, false, false, "Click to move editor on left side");
        this._switchSideDiv.addEventListener("click", () => {
          this.switchSide();
        });
        title.appendChild(this._switchSideDiv);
      }
      this._div.appendChild(title);
    }
    if (this._params.buttons.length > 0) {
      this._buttonsContainer = document.createElement("DIV");
      this._buttonsContainer.style.position = "absolute";
      this._buttonsContainer.style.bottom = Math.round(this._params.WindowPadding).toString() + "px";
      this._buttonsContainer.style.right = Math.round(this._params.WindowPadding).toString() + "px";
      this._buttonsContainer.style.textAlign = "right";
      for (let i = 0; i < this._params.buttons.length; i++) {
        this._buttonsContainer.appendChild(this._params.buttons[i].Element);
      }
      this._div.appendChild(this._buttonsContainer);
      this._buttonsContainer.style.height = (25 * this._params.GUICoef).toString() + "px";
      this._params.bottomKeepClear += Math.round(35 * this._params.GUICoef);
    }
    this._contents.style.position = "absolute";
    this._contents.style.left = this._params.WindowPadding.toString() + "px";
    this._contents.style.right = this._params.WindowPadding.toString() + "px";
    this._contents.style.top = containerTop.toString() + "px";
    this._contents.style.bottom = (this._params.WindowPadding + this._params.bottomKeepClear).toString() + "px";
    this._contents.style.paddingLeft = "5px";
    this._contents.style.paddingRight = "5px";
    if (this._contents.style.fontSize == "") {
      this._contents.style.fontSize = this._params.contentsDefaultFontSize.toString() + "px";
    }
    if (this._contents.style.fontFamily == "") {
      this._contents.style.fontFamily = this._params.contentsDefaultFontFamily;
    }
    if (this._params.showContainerBorders) {
      this._contents.style.border = this._params.WindowInnerBorder;
      this._contents.style.backgroundColor = this._params.WindowInnerBackgroundColor;
    } else {
      this._contents.style.border = "1px solid rgba(0, 0, 0, 0)";
      this._contents.style.backgroundColor = "";
    }
    this._contents.style.overflow = "hide";
    this._div.append(this._contents);
    document.body.appendChild(this._div);
  }
  hide() {
    if (this._div == null)
      return;
    this._div.style.display = "none";
    if (this._ModalDivShield != null)
      this._ModalDivShield.style.display = "none";
    if (this._params.closingCallBack != null)
      this._params.closingCallBack(this);
  }
  set title(value) {
    this._params.title = value;
    if (this._titleSpan != null) {
      this._titleSpan.innerText = value;
    }
  }
  brintToFront() {
    let n = -1;
    for (let i = 0; i < _YWindow.windowList.length; i++) {
      if (_YWindow.windowList[i] == this)
        n = i;
    }
    if (n < 0)
      return;
    _YWindow.windowList.splice(n, 1);
    _YWindow.windowList.push(this);
    for (let i = 0; i < _YWindow.windowList.length; i++) {
      _YWindow.windowList[i].zIndex = i;
    }
  }
  set zIndex(index) {
    if (this._div == null)
      return;
    this._div.style.zIndex = (100001 + 2 * index).toString();
    if (this._params.isModal)
      this._ModalDivShield.style.zIndex = (1e5 + 2 * index).toString();
  }
  switchSide() {
    if (this._div.style.left == "") {
      this._div.style.left = "5px";
      this._div.style.right = "";
      this._switchSideDiv.innerHTML = ressources.MoveToRightIcon(Math.round(20 * this._params.GUICoef).toString(), false, false, false, false, "Click to move editor on right side");
    } else {
      this._div.style.left = "";
      this._div.style.right = "5px";
      this._switchSideDiv.innerHTML = ressources.MoveToLeftIcon(Math.round(20 * this._params.GUICoef).toString(), false, false, false, false, "Click to move editor on left side");
    }
  }
};
YWindow.windowList = [];
var confirm = class _confirm {
  static ask(message, yes, no, userdata) {
    let params = new newWindowParam();
    params.positionType = 1;
    params.width = Math.min(Math.round(400 * constants.generalSizeCoef), Math.round(screen.width * 0.9));
    params.height = Math.min(Math.round(160 * constants.generalSizeCoef), Math.round(screen.height * 0.7));
    params.isModal = true;
    params.showHeader = false;
    params.showContainerBorders = false;
    let YesButton = new button("Yes", () => {
      _confirm._window.hide();
      if (yes != null)
        yes(userdata);
    });
    let NoButton = new button("No", () => {
      _confirm._window.hide();
      if (no != null)
        no(userdata);
    });
    params.buttons.push(YesButton);
    params.buttons.push(NoButton);
    _confirm._window = new YWindow(params);
    let contents = _confirm._window.innerContentDiv;
    let table = document.createElement("TABLE");
    table.style.width = "100%";
    let TR = document.createElement("TR");
    let TD = document.createElement("TD");
    TD.style.width = "10";
    TD.innerHTML = ressources.DontKnowIcon(Math.round(80 * constants.generalSizeCoef).toString(), true, false, false, false, "");
    TR.appendChild(TD);
    TD = document.createElement("TD");
    TD.style.paddingLeft = "20px";
    TD.style.fontFamily = constants.generalFontFamily;
    TD.style.fontSize = constants.generalFontSize.toString() + "px";
    TD.style.textAlign = "justify";
    TD.innerText = message;
    TR.appendChild(TD);
    table.appendChild(TR);
    contents.appendChild(table);
    _confirm._window.show();
    return _confirm._window;
  }
};
var notififaction = class {
  static show(icon, message) {
    let params = new newWindowParam();
    params.positionType = 1;
    params.width = Math.min(Math.round(400 * constants.generalSizeCoef), screen.width);
    params.height = Math.min(Math.round(160 * constants.generalSizeCoef), screen.height);
    params.isModal = true;
    params.showHeader = false;
    params.showContainerBorders = false;
    let okButton = new button("OK", () => {
      alert2._window.hide();
    });
    params.buttons.push(okButton);
    alert2._window = new YWindow(params);
    let contents = alert2._window.innerContentDiv;
    let table = document.createElement("TABLE");
    table.style.width = "100%";
    let TR = document.createElement("TR");
    let TD = document.createElement("TD");
    TD.style.width = "10";
    TD.innerHTML = icon;
    TR.appendChild(TD);
    TD = document.createElement("TD");
    TD.style.paddingLeft = "20px";
    TD.style.fontFamily = constants.generalFontFamily;
    TD.style.fontSize = constants.generalFontSize.toString() + "px";
    TD.style.textAlign = "justify";
    TD.innerText = message;
    TR.appendChild(TD);
    table.appendChild(TR);
    contents.appendChild(table);
    alert2._window.show();
    return alert2._window;
  }
};
var alert2 = class extends notififaction {
  static show(message) {
    return super.show(ressources.FailedIcon(Math.round(80 * constants.generalSizeCoef).toString(), true, false, false, false, ""), message);
  }
};

// obj/full/mainForm_rw.js
var mainForm = class _mainForm {
  constructor() {
    this.GUIcoef = 1;
    let params = new newWindowParam();
    params.positionType = 1;
    this.GUIcoef = constants.generalSizeCoef;
    if (_mainForm.REFWIDH * this.GUIcoef > screen.width)
      this.GUIcoef = screen.width / _mainForm.REFWIDH;
    if (_mainForm.REFHEIGHT * this.GUIcoef > screen.height)
      this.GUIcoef = screen.height / _mainForm.REFHEIGHT;
    params.width = Math.round(_mainForm.REFWIDH * this.GUIcoef);
    params.height = Math.round(_mainForm.REFHEIGHT * this.GUIcoef);
    params.showHeader = false;
    params.showContainerBorders = false;
    this._window = new YWindow(params);
    let contents = this._window.innerContentDiv;
    let title = document.createElement("p");
    title.style.paddingTop = "0px";
    title.style.marginTop = 4 * this.GUIcoef + "px";
    title.style.fontSize = 16 * this.GUIcoef + "px";
    title.innerText = "Hello, welcome to Yocto-Visualization, what would you like to do?";
    title.style.textAlign = "center";
    contents.appendChild(title);
    let table = document.createElement("TABLE");
    table.style.position = "absolute";
    table.style.top = "0px";
    table.style.fontFamily = constants.generalFontFamily;
    table.style.tableLayout = "fixed";
    table.style.paddingLeft = Math.round(10 * this.GUIcoef).toString() + "px";
    table.style.paddingRight = Math.round(10 * this.GUIcoef).toString() + "px";
    table.style.paddingTop = Math.round(30 * this.GUIcoef).toString() + "px";
    table.style.paddingBottom = Math.round(15 * this.GUIcoef).toString() + "px";
    table.style.width = "100%";
    table.style.height = "100%";
    table.style.borderSpacing = Math.round(5 * this.GUIcoef).toString() + "px";
    let tr1 = document.createElement("TR");
    table.appendChild(tr1);
    let td11 = document.createElement("TD");
    tr1.appendChild(td11);
    let td12 = document.createElement("TD");
    tr1.appendChild(td12);
    let td13 = document.createElement("TD");
    tr1.appendChild(td13);
    let tr2 = document.createElement("TR");
    table.appendChild(tr2);
    let td21 = document.createElement("TD");
    tr2.appendChild(td21);
    let td22 = document.createElement("TD");
    tr2.appendChild(td22);
    let td23 = document.createElement("TD");
    tr2.appendChild(td23);
    contents.appendChild(table);
    let version = document.createElement("p");
    version.style.position = "absolute";
    version.style.right = "0px";
    version.style.bottom = "0px";
    version.style.marginBottom = "0px";
    version.style.paddingBottom = "0px";
    version.style.marginRight = "2px";
    version.style.fontSize = (8 * this.GUIcoef).toString() + "px";
    version.innerText = constants.buildVersion;
    version.style.color = "grey";
    version.style.textAlign = "right";
    contents.appendChild(version);
    let size = (128 * this.GUIcoef).toString();
    this.createButton(td11, "Configure global parameters", ressources.ConfigureIcon(size, true, false, false, false), () => {
      this.openConfig();
    });
    this.createButton(td12, "Create a new solid gauge", ressources.SolidGaugeIcon(size, true, false, false, false), () => {
      YWebPage.newGaugeWidget();
    });
    this.createButton(td13, "Create a new graph", ressources.GraphIcon(size, true, false, false, false), () => {
      YWebPage.newGraphWidget();
    });
    this.createButton(td21, "Get Raw data", ressources.RawDataIcon(size, true, false, false, false), () => {
      this.openRawData();
    });
    this.createButton(td22, "Create a new digital display", ressources.DigitalDisplayIcon(size, true, false, false, false), () => {
      YWebPage.newDigitalDisplayWidget();
    });
    this.createButton(td23, "Create a new angular gauge", ressources.AngularGaugeIcon(size, true, false, false, false), () => {
      YWebPage.newAngularGaugeWidget();
    });
  }
  hide() {
    this._window.hide();
  }
  show() {
    this._window.show();
  }
  createButton(container, caption, icon, callback) {
    container.style.border = "1px solid black";
    container.style.textAlign = "center";
    container.style.fontSize = (10 * this.GUIcoef).toString() + "px";
    container.style.paddingBottom = "3px";
    container.style.borderColor = "#808080";
    container.style.backgroundColor = "#f0f0f0";
    container.style.cursor = "pointer";
    container.addEventListener("mouseover", function() {
      container.style.backgroundColor = "white";
    });
    container.addEventListener("mouseout", function() {
      container.style.backgroundColor = "#f0f0f0";
    });
    let a = document.createElement("a");
    a.style.outline = "none";
    a.innerHTML = icon + "<br>" + caption;
    a.addEventListener("click", callback);
    a.tabIndex = 0;
    a.addEventListener("focusin", () => {
      container.style.backgroundColor = "white";
    });
    a.addEventListener("focusout", () => {
      container.style.backgroundColor = "f0f0f0";
    });
    a.addEventListener("keypress", (e) => {
      if (e.key == "Enter")
        callback();
    });
    container.appendChild(a);
  }
  openConfig() {
    configForm.show();
  }
  openRawData() {
    rawDataForm.show();
  }
};
mainForm.REFWIDH = 500;
mainForm.REFHEIGHT = 360;

// obj/full/Editor_rw.js
var EditedDataSource = class {
  constructor(source, root) {
    this._htmlchilds = [];
    this._source = source;
    this._root = root;
    this._htmlchilds = [];
  }
  storeChilds(childsList) {
    this._htmlchilds = [];
    for (let i = 0; i < childsList.length; i++) {
      this._htmlchilds.push(childsList.item(i));
    }
  }
  getStoredChilds() {
    return this._htmlchilds;
  }
  get root() {
    return this._root;
  }
  refresh() {
    if (this._root != null)
      this._root.refresh();
  }
};
var keyDataObject = class {
  constructor(key, data) {
    this.key = key;
    this.data = data;
  }
};
var objectDictionnary = class {
  constructor() {
    this.list = [];
  }
  isInlist(key) {
    for (let i = 0; i < this.list.length; i++) {
      if (key == this.list[i].key)
        return true;
    }
    return false;
  }
  find(key) {
    for (let i = 0; i < this.list.length; i++) {
      if (key == this.list[i].key)
        return this.list[i].data;
    }
    return null;
  }
  insert(key, data) {
    for (let i = 0; i < this.list.length; i++) {
      if (key == this.list[i].key) {
        this.list[i].data = data;
        return;
      }
    }
    this.list.push(new keyDataObject(key, data));
  }
};
var EditorBaseDef = class {
  refresh() {
  }
  get panel() {
    return null;
  }
  get expanded() {
    return true;
  }
  AllocateControls() {
  }
};
var PropertiesForm2 = class _PropertiesForm2 extends EditorBaseDef {
  get visible() {
    return this._window.visible;
  }
  set visible(v) {
    v ? this.show() : this.hide();
  }
  get text() {
    return this._text;
  }
  set text(value) {
    this._text = value;
    this._window.title = this._text;
  }
  get help() {
    return this._helpText;
  }
  set help(value) {
    this._helpText = value;
    this._helpPanel.innerHTML = this._helpText;
  }
  addTest(parentDiv) {
    _PropertiesForm2.testid++;
    let mainlabel = document.createElement("DIV");
    mainlabel.style.position = "relative";
    mainlabel.style.display = "inline-block;";
    mainlabel.style.left = "0px";
    mainlabel.style.padding = "2px 2px 2px 2px";
    mainlabel.style.right = "5px";
    mainlabel.style.border = "1px solid black";
    mainlabel.style.marginTop = "2px";
    mainlabel.style.backgroundColor = "yellow";
    if (parentDiv != null) {
      parentDiv.appendChild(mainlabel);
    } else {
      this._container.appendChild(mainlabel);
    }
    let expandCtrl = document.createElement("ANCHOR");
    expandCtrl.innerText = "[+]";
    mainlabel.appendChild(expandCtrl);
    let mainText = document.createElement("SPAN");
    mainText.innerText = "Pouet " + _PropertiesForm2.testid.toString();
    mainlabel.appendChild(mainText);
    let subElementPanel = document.createElement("DIV");
    subElementPanel.style.position = "relative";
    subElementPanel.style.display = "inline-block;";
    subElementPanel.style.left = "5px";
    subElementPanel.style.padding = "2px 2px 2px 2px";
    subElementPanel.style.right = "5px";
    subElementPanel.style.marginTop = "2px";
    subElementPanel.style.backgroundColor = "lightgray";
    subElementPanel.innerText = "sub elements";
    if (parentDiv != null) {
      parentDiv.appendChild(subElementPanel);
    } else {
      this._container.appendChild(subElementPanel);
    }
    return subElementPanel;
  }
  editorIsClosing(source) {
    if (this._editorClosedCallback != null)
      this._editorClosedCallback();
  }
  bestWidth() {
    let w = window.innerWidth / 4 >> 0;
    let minWidth = 275 * constants.guiDPIFactor;
    if (w < minWidth)
      w = minWidth;
    if (w > window.innerWidth - 10)
      w = window.innerWidth - 10;
    return w;
  }
  constructor() {
    super();
    this._hostWindow = null;
    this._editorClosedCallback = null;
    this.currentEditedDataSource = null;
    this._changeCallback = null;
    this._getvalueCallback = null;
    this._text = "Properties editor";
    this._helpText = "Properties editor";
    this.EditedDataSourceList = new objectDictionnary();
    let params = new newWindowParam();
    params.positionType = 2;
    params.width = this.bestWidth();
    params.createNow = true;
    params.closingCallBack = (source) => {
      this.editorIsClosing(source);
    };
    params.bottomKeepClear = _PropertiesForm2.HelpHeight + 3 * constants.WindowPadding;
    params.title = this._text;
    this._window = new YWindow(params);
    this._container = this._window.innerContentDiv;
    this._helpPanel = document.createElement("DIV");
    this._helpPanel.style.position = "absolute";
    this._helpPanel.style.left = constants.WindowPadding.toString() + "px";
    this._helpPanel.style.bottom = constants.WindowPadding.toString() + "px";
    this._helpPanel.style.right = constants.WindowPadding.toString() + "px";
    this._helpPanel.style.height = _PropertiesForm2.HelpHeight.toString() + "px";
    this._helpPanel.style.paddingLeft = "5px";
    this._helpPanel.style.paddingTop = "5px";
    this._helpPanel.style.overflowY = "auto";
    this._helpPanel.style.border = constants.WindowInnerBorder;
    this._helpPanel.style.backgroundColor = constants.WindowInnerBackgroundColor;
    this._helpPanel.style.fontFamily = constants.generalFontFamily;
    this._helpPanel.style.fontSize = constants.generalFontSize.toString() + "px";
    this._helpPanel.style.color = "black";
    this._helpPanel.style.display = "";
    this._helpPanel.innerHTML = "Help panel. Editor is loading, please wait....";
    this._window.outterContentDiv.appendChild(this._helpPanel);
    this._container.style.overflowY = "scroll";
    this._container.style.overflowX = "hidden";
    this._container.style.backgroundColor = constants.WindowInnerBackgroundColor;
    window.addEventListener("resize", () => {
      this.windowResized();
    });
  }
  windowResized() {
    if (this._window.innerContentDiv == null)
      return;
    if (this._window.innerContentDiv.offsetHeight < _PropertiesForm2.MinHeightforShowingHelp && this._helpPanel.style.display == "") {
      this._helpPanel.style.display = "none";
      this._window.bottomKeepClear = 0;
    } else if (this._window.innerContentDiv.offsetHeight >= _PropertiesForm2.MinHeightforShowingHelp + _PropertiesForm2.HelpHeight && this._helpPanel.style.display != "") {
      this._helpPanel.style.display = "";
      this._window.bottomKeepClear = _PropertiesForm2.HelpHeight;
    }
  }
  show() {
    this._window.show(this.bestWidth());
    this.windowResized();
  }
  hide() {
    YWidget.stopEdition();
    this._window.hide();
  }
  get panel() {
    return this._container;
  }
  refresh() {
    if (!this.visible)
      return;
    if (this.currentEditedDataSource == null)
      return;
    this.currentEditedDataSource.refresh();
  }
  refreshBanner() {
    if (this._hostWindow != null) {
      this.text = "Properties of " + this._hostWindow.Text;
    }
  }
  showWindow(hostWindow, structData, setvalueCallBack, getvalueCallBack, EditStoppedCallBack) {
    this._hostWindow = hostWindow;
    this._changeCallback = setvalueCallBack;
    this._getvalueCallback = getvalueCallBack;
    this.text = "Properties editor";
    this.show();
    this.refreshBanner();
    this.EditObject(structData, setvalueCallBack, getvalueCallBack, EditStoppedCallBack);
  }
  EditObject(structData, setvalueCallBack, getvalueCallBack, EditStoppedCallBack) {
    this._editorClosedCallback = EditStoppedCallBack;
    let helpYourselfMsg = "This is the property editor. Change any parameter you want. All changes are applied in real time.";
    if (!this.visible)
      return;
    this.help = "Please wait....";
    if (this.EditedDataSourceList.isInlist(structData)) {
      if (this.EditedDataSourceList.find(structData) == this.currentEditedDataSource) {
        this.help = helpYourselfMsg;
        return;
      }
    }
    if (this.currentEditedDataSource != null) {
      this.currentEditedDataSource.root.stopEdit();
      this.currentEditedDataSource.storeChilds(this._container.childNodes);
      while (this._container.firstChild) {
        this._container.removeChild(this._container.lastChild);
      }
    }
    let it;
    if (!this.EditedDataSourceList.isInlist(structData)) {
      let rootparam = new UIElementBaseParams(this._helpPanel, this, null, "root", "Root", "root node", "");
      it = new UIElement(rootparam);
      it.rootEditor = this;
      this.currentEditedDataSource = new EditedDataSource(structData, it);
      this.EditedDataSourceList.insert(structData, this.currentEditedDataSource);
      it.showLabel = false;
      it.expandable = true;
      it.ProcessNewType(structData);
      it.expanded = true;
    } else {
      this.currentEditedDataSource = this.EditedDataSourceList.find(structData);
      let childNodes = this.currentEditedDataSource.getStoredChilds();
      for (let i = 0; i < childNodes.length; i++) {
        this._container.appendChild(childNodes[i]);
      }
      this.currentEditedDataSource.refresh();
    }
    this.currentEditedDataSource.root.startEdit(setvalueCallBack, getvalueCallBack);
    this.currentEditedDataSource.root.resizeAll();
    this.help = helpYourselfMsg;
  }
  getConfigData() {
    let p = this._window.outterContentDiv.getBoundingClientRect();
    return "<PropertiesForm>\n<location x='" + p.left.toString() + "' y='" + p.top.toString() + "'/>\n<size     w='" + p.width.toString() + "' h='" + p.width.toString() + "'/>\n</PropertiesForm>\n";
  }
  Form1_SizeChanged(sender) {
    if (this.currentEditedDataSource == null)
      return;
    if (this.currentEditedDataSource.root != null)
      this.currentEditedDataSource.root.resizeAll();
  }
  valuechange(src) {
    let OriginalPropName = "";
    let fullpropname = "";
    let propType = "";
    if (this._changeCallback != null)
      this._changeCallback(src);
  }
};
PropertiesForm2.HelpHeight = Math.round(75 * constants.generalSizeCoef);
PropertiesForm2.MinHeightforShowingHelp = 175;
PropertiesForm2.testid = 0;

// obj/full/UIElements_rw.js
var UIElementBaseParams = class {
  constructor(p_descriptionLabel, p_parentNode, p_RootNode, p_internalname, p_label, p_description, p_isReadonlyCall) {
    this.expandable = false;
    this.isReadonlyCall = "";
    this.summary = null;
    this.structRoot = null;
    this.HelpZoneLabel = p_descriptionLabel;
    this.parentNode = p_parentNode;
    this.RootNode = p_RootNode;
    this.internalname = p_internalname;
    this.label = p_label;
    this.description = p_description;
    this.changeCausesParentRefresh = false;
    this.preExpanded = false;
    this.isReadonlyCall = p_isReadonlyCall;
  }
};
var PropPathinfo = class {
  constructor() {
    this.OriginalPropName = "";
    this.fullpropname = "";
    this.propType = "";
  }
};
var CustomAttributesExtractor = class {
  constructor(ps) {
    this.available = true;
    this.displayName = "unknown";
    this.category = "";
    this.displayDescription = "Not documented";
    this.prefinedValues = null;
    this.changeCausesParentRefresh = false;
    this.PreExpandedCategory = false;
    this.PreExpanded = false;
    this.summaryPropertyName = "";
    this.isReadOnlyCall = "";
    this.NotSavedInXML = false;
    this.ReadOnly = false;
    this.ParamCategorySummary = "";
    if ("OnlyAvailableon" in ps.Attributes)
      this.available = ps.Attributes["OnlyAvailableon"];
    if ("DisplayName" in ps.Attributes)
      this.displayName = ps.Attributes["DisplayName"];
    if ("CategoryAttribute" in ps.Attributes)
      this.category = ps.Attributes["CategoryAttribute"];
    if ("DescriptionAttribute" in ps.Attributes)
      this.displayDescription = ps.Attributes["DescriptionAttribute"];
    if ("AllowedValues" in ps.Attributes)
      this.prefinedValues = ps.Attributes["AllowedValues"];
    if ("ChangeCausesParentRefreshAttribute" in ps.Attributes)
      this.changeCausesParentRefresh = ps.Attributes["ChangeCausesParentRefreshAttribute"];
    if ("PreExpandedCategoryAttribute" in ps.Attributes)
      this.PreExpandedCategory = ps.Attributes["PreExpandedCategoryAttribute"];
    if ("PreExpandedAttribute" in ps.Attributes)
      this.PreExpanded = ps.Attributes["PreExpandedAttribute"];
    if ("ParamCategorySummaryAttribute" in ps.Attributes)
      this.summaryPropertyName = ps.Attributes["ParamCategorySummaryAttribute"];
    if ("IsReadonlyCallAttribute" in ps.Attributes)
      this.isReadOnlyCall = ps.Attributes["IsReadonlyCallAttribute"];
    if ("NotSavedInXMLAttribute" in ps.Attributes)
      this.NotSavedInXML = ps.Attributes["NotSavedInXMLAttribute"];
    if ("ReadOnlyAttribute " in ps.Attributes)
      this.ReadOnly = ps.Attributes["ReadOnlyAttribute "];
    if ("ParamCategorySummaryAttribute " in ps.Attributes)
      this.ParamCategorySummary = ps.Attributes["ParamCategorySummaryAttribute "];
  }
};
var UIElement = class _UIElement extends EditorBaseDef {
  get parentNode() {
    return this._parentNode;
  }
  get targetFullName() {
    return this._targetFullName;
  }
  get expandIcon() {
    return ressources.ExpandIcon(_UIElement.defaultFontSize.toString(), false, false, false, false, "Click to expand");
  }
  get colapseIcon() {
    return ressources.ColapseIcon(_UIElement.defaultFontSize.toString(), false, false, false, false, "Click to colapse");
  }
  removeFromEditor() {
  }
  get panel() {
    return this.subElementPanel;
  }
  get editorHelpText() {
    return "";
  }
  get isRootElement() {
    return this._rootNode == this;
  }
  addToEditor() {
    if (this.mainlabel != null) {
      for (let i = 0; i < this._parentPanel.children.length; i++) {
        if (this._parentPanel.children[i] == this.mainlabel)
          return;
      }
      this._parentPanel.appendChild(this.mainlabel);
      this._parentPanel.appendChild(this.subElementPanel);
    }
  }
  refresh() {
    if (this.mainText != null)
      this.mainText.innerText = this.name + this.getSummary();
    for (let i = 0; i < this.subElements.length; i++) {
      this.subElements[i].refresh();
    }
    if (this._rootNode != null && this._rootNode.rootEditor != null)
      this._rootNode.rootEditor.refreshBanner();
  }
  tabReOrder(index) {
    if (this._expandable && this.expandCtrl != null)
      this.expandCtrl.tabIndex = index++;
    this.subElements.forEach((e) => {
      index = e.tabReOrder(index);
    });
    return index;
  }
  triggerValueChangeCallback() {
    if (this._valueChangeCallback != null)
      this._valueChangeCallback(this);
  }
  scrollToMakeVisible() {
    if (this.mainlabel == null)
      return;
    if (this._parentPanel == null)
      return;
    this.mainlabel.scrollIntoView();
  }
  control_GotFocus(sender) {
    let extraHelp = this.editorHelpText;
    if (extraHelp != "")
      extraHelp = " " + extraHelp;
    this._helpZoneLabel.innerHTML = this._description + extraHelp;
  }
  control_LostFocus(sender) {
    this._helpZoneLabel.innerHTML = "";
  }
  preExpandIfNeeded() {
    if (this._parentNode != null && this._parentNode.expanded) {
      this.AllocateControls();
      if (this.expandable)
        this.initExpandButton();
      this.initMainLabel();
    }
    this.initExpandButton();
  }
  constructor(p) {
    super();
    this.name = "NoName";
    this._targetFullName = "unknowTargetName";
    this.ExpandableDepth = 0;
    this._expanded = false;
    this._expandButtonSide = 0;
    this._rootEditor = null;
    this._description = "";
    this.expandCtrl = null;
    this.mainlabel = null;
    this.mainText = null;
    this.subElementPanel = null;
    this._rootNode = null;
    this._parentNode = null;
    this._parentPanel = null;
    this._changeCausesParentRefresh = false;
    this._isReadOnlyCall = "";
    this._controlsAllocated = false;
    this.expandButtonInitDone = false;
    this.mainLabelInitDone = false;
    this.subElements = [];
    this._valueChangeCallback = null;
    this._getValueCallback = null;
    this._shown = true;
    this._summaryCallback = null;
    this._showLabel = false;
    this._expandable = false;
    this._preExpanded = false;
    this.name = p.label;
    this._targetFullName = p.internalname;
    this._helpZoneLabel = p.HelpZoneLabel;
    this._description = p.description;
    this._changeCausesParentRefresh = p.changeCausesParentRefresh;
    this._expandable = p.expandable;
    this._preExpanded = p.preExpanded;
    this._structRoot = p.structRoot;
    this._isReadOnlyCall = p.isReadonlyCall;
    this._summaryProperty = p.summary;
    if (_UIElement.baseheight == 0) {
      _UIElement.baseheight = 12;
      _UIElement.expandableShift = _UIElement.baseheight + 2;
      _UIElement.scrollBarWidth = 20;
    }
    this._parentNode = p.parentNode;
    this._rootNode = p.RootNode == null ? this : p.RootNode;
  }
  set rootEditor(value) {
    this._rootEditor = value;
  }
  get rootEditor() {
    return this._rootEditor;
  }
  initMainLabel() {
    if (this.mainlabel == null)
      return;
    if (this.mainLabelInitDone)
      return;
    this.ExpandableDepth = 0;
    let p = this;
    while (p != null) {
      if (p.expandable)
        this.ExpandableDepth++;
      p = p.parentNode;
    }
    this.mainText.innerText = this.name + this.getSummary();
    if (this.expandable && this._expandButtonSide == 0) {
      switch (this.ExpandableDepth) {
        case 1:
          this.mainlabel.style.backgroundColor = "Blue";
          this.mainText.style.color = "black";
          break;
        case 2:
          this.mainlabel.style.backgroundColor = "rgb(7,141,255)";
          this.mainText.style.color = "white";
          break;
        case 3:
          this.mainlabel.style.backgroundColor = "rgb(120,196,255)";
          break;
        case 4:
          this.mainlabel.style.backgroundColor = "rgb(213,237,255)";
          break;
        case 5:
          this.mainlabel.style.backgroundColor = "rgb(237,246,253)";
          break;
        default:
          this.mainlabel.style.backgroundColor = "rgb(246,251,255)";
          break;
      }
    } else {
      this.mainlabel.style.backgroundColor = "rgba( 0, 0, 0,0)";
    }
    this.mainLabelInitDone = true;
  }
  AllocateControls() {
    if (this._controlsAllocated)
      return;
    if (!this.isRootElement)
      this.parentNode.AllocateControls();
    this._parentPanel = this.parentNode.panel;
    if (this.mainlabel == null) {
      this.mainlabel = document.createElement("DIV");
      this.mainlabel.style.position = "relative";
      this.mainlabel.style.display = "inline-block;";
      this.mainlabel.style.left = "0px";
      this.mainlabel.style.padding = "2px 2px 2px 2px";
      this.mainlabel.style.overflow = "hidden";
      this.mainlabel.style.fontFamily = _UIElement.defaultFontFamily;
      this.mainlabel.style.fontSize = _UIElement.defaultFontSize.toString() + "px";
      this.mainlabel.style.right = "5px";
      this.mainlabel.style.whiteSpace = "nowrap";
      this.mainlabel.style.marginTop = "2px";
      this.mainlabel.style.backgroundColor = "yellow";
      this.mainText = document.createElement("SPAN");
      this.mainText.innerText = "Pouet";
      this.mainlabel.appendChild(this.mainText);
      this.mainlabel.style.display = this.isRootElement ? "none" : "";
      this.initMainLabel();
      if (this._parentPanel == null) {
        debugger;
      }
      this._parentPanel.appendChild(this.mainlabel);
    }
    if (this._expandable && this.expandCtrl == null) {
      this.expandCtrl = document.createElement("ANCHOR");
      if (this._expandButtonSide == 0) {
        this.mainlabel.insertBefore(this.expandCtrl, this.mainText);
      }
      this.initExpandButton();
      this.subElementPanel = document.createElement("DIV");
      this.subElementPanel.style.position = "relative";
      this.subElementPanel.style.display = "inline-block;";
      this.subElementPanel.style.left = this.isRootElement ? "0px" : "5px";
      this.subElementPanel.style.padding = "2px 2px 2px 2px";
      this.subElementPanel.style.right = "5px";
      this.subElementPanel.style.display = "none";
      this.subElementPanel.style.marginTop = "2px";
      this.subElementPanel.style.marginRight = "2px";
      this._parentPanel.appendChild(this.subElementPanel);
    }
    this._controlsAllocated = true;
  }
  initExpandButton() {
    if (this.expandCtrl == null)
      return;
    if (this.expandButtonInitDone)
      return;
    this.expandCtrl.innerHTML = this.expandIcon;
    this.expandCtrl.style.top = "0px";
    this.expandCtrl.style.left = "0px";
    this.expandCtrl.style.cursor = "pointer";
    this.expandCtrl.style.backgroundColor = "white";
    this.expandCtrl.style.marginRight = "3px";
    this.expandCtrl.style.paddingLeft = "0px";
    this.expandCtrl.style.paddingRight = "0px";
    this.expandCtrl.style.paddingTop = "1px";
    this.expandCtrl.style.marginTop = "0px";
    this.expandCtrl.style.marginBottom = "0px";
    this.expandCtrl.style.paddingBottom = "0px";
    this.expandCtrl.style.paddingRight = "0px";
    this.expandCtrl.addEventListener("click", () => {
      this.ToggleExpand();
    });
    this.expandCtrl.addEventListener("keyup", (e) => {
      if (e.key === "Enter" || e.key === " ")
        this.ToggleExpand();
    });
    this.expandCtrl.addEventListener("focusin", () => {
      this.control_GotFocus(this);
    });
    this.expandCtrl.addEventListener("focusout", () => {
      this.control_LostFocus(this);
    });
    this.expandButtonInitDone = true;
  }
  get rowHeight() {
    return _UIElement.baseheight;
  }
  ExtractPropPath(info) {
    let index = -1;
    let path = [];
    let p = this;
    info.OriginalPropName = p.targetFullName;
    do {
      info.fullpropname = p.targetFullName;
      index = info.fullpropname.indexOf("_");
      if (index < 0) {
        if (info.fullpropname != _UIElement.ARTIFICIALSECTIONNAME)
          path.splice(0, 0, info.fullpropname);
        p = p.parentNode;
        if (p == null)
          throw "invalid Property name";
      }
    } while (index < 0);
    info.propType = info.fullpropname.substring(0, index);
    let propname = info.fullpropname.substring(index + 1);
    path.splice(0, 0, propname);
    return path;
  }
  startEdit(setcallback, getCallback) {
    this.addToEditor();
    this._valueChangeCallback = setcallback;
    this._getValueCallback = getCallback;
    this.subElements.forEach((item) => {
      item.startEdit(setcallback, getCallback);
    });
  }
  stopEdit() {
    this.removeFromEditor();
    this._valueChangeCallback = null;
    this._getValueCallback = null;
    this.subElements.forEach((item) => {
      item.stopEdit();
    });
  }
  expand() {
    this.subElements.forEach((e) => {
      e.AllocateControls();
      e.show();
    });
    this._rootNode.tabReOrder(0);
    this._expanded = true;
    this.subElementPanel.style.display = "";
    this.expandCtrl.innerHTML = this.colapseIcon;
  }
  colapse() {
    this.subElementPanel.style.display = "none";
    this.expandCtrl.innerHTML = this.expandIcon;
  }
  get expanded() {
    return this._expanded;
  }
  set expanded(value) {
    this._expanded = value;
    if (this._expanded) {
      this.expand();
    } else {
      this.colapse();
    }
    this._rootNode.resizeAll();
  }
  ToggleExpand() {
    this.expanded = !this.expanded;
  }
  getSummary() {
    if (this._summaryProperty != null) {
      return " (" + Reflect.get(this._structRoot, this._summaryProperty.name) + ")";
    }
    return "";
  }
  sensorList() {
    let res = [];
    sensorsManager.sensorList.forEach((s) => {
      res.push(s);
    });
    return res;
  }
  ProcessNewType(dataStucture) {
    let subsections = {};
    this._structRoot = dataStucture;
    let toExpand = [];
    let properties = GenericProperties.getAllProperties(dataStucture);
    for (let i = 0; i < properties.byIndex.length; i++) {
      let ps = properties.byIndex[i];
      if (ps.isWritable) {
        let attr = new CustomAttributesExtractor(ps);
        if (attr.available) {
          let section = this;
          if (attr.category != "") {
            if (attr.category in subsections) {
              section = subsections[attr.category];
            } else {
              let sectionparam = new UIElementBaseParams(this._helpZoneLabel, this, this._rootNode, _UIElement.ARTIFICIALSECTIONNAME, attr.category, attr.category + " section, expand for more...", "");
              sectionparam.preExpanded = attr.PreExpandedCategory;
              sectionparam.expandable = true;
              sectionparam.structRoot = dataStucture;
              if (attr.summaryPropertyName != "") {
                sectionparam.summary = ps;
              }
              section = new _UIElement(sectionparam);
              if (attr.PreExpandedCategory)
                toExpand.push(section);
              section.showLabel = true;
              subsections[attr.category] = section;
              this.addSubElement(section);
            }
          }
          let elParam = new UIElementBaseParams(this._helpZoneLabel, section, this._rootNode, ps.name, attr.displayName, attr.displayDescription, attr.isReadOnlyCall);
          elParam.preExpanded = attr.PreExpanded;
          elParam.changeCausesParentRefresh = attr.changeCausesParentRefresh;
          let targetName = this._targetFullName;
          let targetPrefix = "";
          let p = targetName.indexOf("_");
          if (p >= 0) {
            targetPrefix = targetName.substring(0, p);
            targetName = targetName.substring(p + 1);
          }
          if (ps.isEnum) {
            let s = new UIElementEnum(elParam, dataStucture, ps);
            section.addSubElement(s);
          } else {
            switch (ps.type) {
              case "number":
                if (attr.prefinedValues == null) {
                  let n = new UIElementNumber(elParam, dataStucture, ps);
                  section.addSubElement(n);
                } else {
                  let s2 = new UIElementList(elParam, dataStucture, ps, () => {
                    return attr.prefinedValues;
                  });
                  section.addSubElement(s2);
                }
                break;
              case "boolean":
                let b = new UIElementBoolean(elParam, dataStucture, ps);
                section.addSubElement(b);
                break;
              case doubleNan.name:
                let d = new UIElementDoubleNan(elParam, dataStucture, ps);
                section.addSubElement(d);
                break;
              case NullYSensor.name:
              case CustomYSensor.name:
                let s = new UIElementList(elParam, dataStucture, ps, () => {
                  return this.sensorList();
                });
                section.addSubElement(s);
                break;
              case YColor.name:
                let c = new UIElementColor(elParam, dataStucture, ps);
                section.addSubElement(c);
                break;
              case xAxisPosition.name:
                let p2 = new UIElementMarkerPos(elParam, dataStucture, ps);
                section.addSubElement(p2);
                break;
              case "string":
                if (attr.prefinedValues == null) {
                  let s2 = new UIElementString(elParam, dataStucture, ps);
                  section.addSubElement(s2);
                } else {
                  let s2 = new UIElementList(elParam, dataStucture, ps, () => {
                    return attr.prefinedValues;
                  });
                  section.addSubElement(s2);
                }
                break;
              default:
                {
                  elParam.expandable = true;
                  elParam.preExpanded = attr.PreExpanded;
                  let subobjectsection = new _UIElement(elParam);
                  if (attr.PreExpanded)
                    toExpand.push(subobjectsection);
                  subobjectsection.showLabel = true;
                  section.addSubElement(subobjectsection);
                  subobjectsection.ProcessNewType(dataStucture[ps.name]);
                }
                break;
            }
          }
        }
      } else {
        if (ps.name == "summary") {
          this._summaryProperty = ps;
        }
      }
    }
    if (this._summaryProperty != null)
      this.refresh();
    toExpand.forEach((e) => {
      e.expand();
    });
  }
  show() {
    this._shown = true;
    if (this.mainlabel != null)
      this.mainlabel.style.display = "";
    if (this.expandCtrl != null)
      this.expandCtrl.style.display = this._expandable ? "" : "hidden";
    if (this.expanded) {
      this.subElements.forEach((e) => {
        e.show();
      });
    }
  }
  hide() {
    this._shown = false;
    if (this.mainlabel != null)
      this.mainlabel.style.display = "hidden";
    if (this.expandCtrl != null)
      this.expandCtrl.style.display = this._expandable ? "hidden" : "";
    this.subElements.forEach((e) => {
      e.hide();
    });
  }
  ExpandCtrl_Click_expand(sender) {
    this.expanded = !this._expanded;
  }
  resizeAll() {
    this.resize(0, 0, 0, 0);
    if (this.expanded) {
      this.subElements.forEach((e) => {
        e.resizeAll();
      });
    }
  }
  get showLabel() {
    return this._showLabel;
  }
  set showLabel(value) {
    this._showLabel = value;
    if (this.expandCtrl != null)
      this.expandCtrl.style.display = value && this._expandable ? "" : "hidden";
  }
  get expandable() {
    return this._expandable;
  }
  set expandable(value) {
    this._expandable = value;
    if (!value)
      return;
    if (this.expandCtrl == null) {
      this.AllocateControls();
      this.initExpandButton();
    }
    this.expandCtrl.style.display = value && this._showLabel ? "" : "hidden";
  }
  addSubElement(node) {
    this.subElements.push(node);
  }
  computeHeight() {
    return 0;
  }
  resize(top2, left1, left2, width) {
    return 0;
  }
};
UIElement.defaultFontFamily = constants.generalFontFamily;
UIElement.defaultFontSize = constants.generalFontSize;
UIElement.ARTIFICIALSECTIONNAME = "-ignore-";
UIElement.baseheight = 0;
UIElement.indentation = 16;
UIElement.expandableShift = 0;
UIElement.scrollBarWidth = 0;
UIElement.expandableVerticalOffset = 2;
var UIElementGeneric = class extends UIElement {
  constructor(p, dataContainer, prop) {
    super(p);
    this.input = null;
    this.select = null;
    this._prop = prop;
    this._dataContainer = dataContainer;
    this._showLabel = true;
    if (this._preExpanded)
      this.AllocateControls();
    if (this._expandable && this._preExpanded)
      this.expand();
  }
  removeFromEditor() {
    super.removeFromEditor();
  }
  tabReOrder(index) {
    if (this.input != null)
      this.input.tabIndex = index++;
    this.subElements.forEach((e) => {
      index = e.tabReOrder(index);
    });
    return index;
  }
  addToEditor() {
    super.addToEditor();
  }
  show() {
    super.show();
    if (this.input != null)
      this.input.style.visibility = "";
  }
  checkForReadOnly() {
    if (this.input == null && this.select == null)
      return;
    if (this._isReadOnlyCall != "") {
      let ro = Reflect.get(this._dataContainer, this._isReadOnlyCall);
      if (this.input != null)
        this.input.disabled = ro;
      if (this.select != null)
        this.select.disabled = ro;
    }
  }
  hide() {
    if (this.input != null)
      this.input.style.visibility = "hidden";
    super.hide();
  }
  resize(top2, left1, left2, width) {
    return 0;
  }
};
var UIElementString = class extends UIElementGeneric {
  constructor(p, dataContainer, prop) {
    super(p, dataContainer, prop);
    this._value = "";
    this.preExpandIfNeeded();
  }
  AllocateControls() {
    super.AllocateControls();
    if (this.input == null) {
      this.input = document.createElement("INPUT");
      this.input.type = "input";
      this.input.value = Reflect.get(this._dataContainer, this._prop.name);
      this.input.style.position = "absolute";
      this.input.style.marginTop = "0px";
      this.input.style.marginBottom = "0px";
      this.input.style.fontFamily = UIElement.defaultFontFamily;
      this.input.style.fontSize = UIElement.defaultFontSize.toString() + "px";
      this.input.style.border = "1px solid grey";
      this.input.style.borderRadius = "1px";
      this.input.style.top = "0px";
      this.input.style.right = "3px";
      this.input.style.width = "50%";
      this.mainlabel.appendChild(this.input);
      new InputFieldManager(this.input, 0, true, Number.NaN, Number.NaN, () => {
        this.Text_TextChanged(null);
      });
      this.input.addEventListener("focusin", () => {
        this.control_GotFocus(this);
      });
      this.input.addEventListener("focusout", () => {
        this.control_LostFocus(this);
      });
      this.checkForReadOnly();
    }
  }
  refresh() {
    if (this.input == null)
      return;
    if (this._getValueCallback == null)
      return;
    let value = this._getValueCallback(this);
    if (value == null)
      return;
    let s = value.toString();
    if (this.input != null) {
      if (s != this.input.value)
        this.input.value = s;
    }
    this.checkForReadOnly();
  }
  Text_TextChanged(sender) {
    if (this.input != null) {
      this._value = this.input.value;
      Reflect.set(this._dataContainer, this._prop.name, this._value);
      if (this._valueChangeCallback != null)
        this._valueChangeCallback(this);
      if (this._changeCausesParentRefresh)
        this.parentNode.refresh();
    }
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value;
    this.input.value = value;
  }
  resize(top2, left1, left2, width) {
    this.mainlabel.style.height = this.input.offsetHeight.toString() + "px";
    return 0;
  }
};
var UIElementNumber = class extends UIElementGeneric {
  constructor(p, dataContainer, prop) {
    super(p, dataContainer, prop);
    this._value = 0;
    this.preExpandIfNeeded();
  }
  AllocateControls() {
    super.AllocateControls();
    if (this.input == null) {
      this.input = document.createElement("INPUT");
      this.input.type = "input";
      this.input.value = Reflect.get(this._dataContainer, this._prop.name);
      this.input.style.textAlign = "right";
      this.input.style.position = "absolute";
      this.input.style.marginTop = "0px";
      this.input.style.marginBottom = "0px";
      this.input.style.fontFamily = UIElement.defaultFontFamily;
      this.input.style.fontSize = UIElement.defaultFontSize.toString() + "px";
      this.input.type = "number";
      this.input.style.border = "1px solid grey";
      this.input.style.borderRadius = "1px";
      this.input.style.top = "0px";
      this.input.style.right = "3px";
      this.input.style.width = "50%";
      this.mainlabel.appendChild(this.input);
      new InputFieldManager(this.input, 4, false, Number.NaN, Number.NaN, () => {
        this.Text_TextChanged(null);
      });
      this.input.addEventListener("focusin", () => {
        this.control_GotFocus(this);
      });
      this.input.addEventListener("focusout", () => {
        this.control_LostFocus(this);
      });
      this.checkForReadOnly();
    }
  }
  refresh() {
    if (this.input == null)
      return;
    if (this._getValueCallback == null)
      return;
    let s = this._getValueCallback(this);
    if (s == null)
      return;
    if (this.input != null) {
      if (s != parseFloat(this.input.value))
        this.input.value = s.toString();
    }
    this.checkForReadOnly();
  }
  Text_TextChanged(sender) {
    if (this.input != null) {
      this._value = parseFloat(this.input.value);
      Reflect.set(this._dataContainer, this._prop.name, this._value);
      if (this._valueChangeCallback != null)
        this._valueChangeCallback(this);
      if (this._changeCausesParentRefresh)
        this.parentNode.refresh();
    }
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value;
    this.input.value = value.toString();
  }
  resize(top2, left1, left2, width) {
    this.mainlabel.style.height = this.input.offsetHeight.toString() + "px";
    return 0;
  }
};
var UIElementBoolean = class extends UIElementGeneric {
  constructor(p, dataContainer, prop) {
    super(p, dataContainer, prop);
    this._text = null;
    this._value = false;
    this.preExpandIfNeeded();
  }
  AllocateControls() {
    super.AllocateControls();
    if (this.input == null) {
      let span = document.createElement("SPAN");
      span.style.position = "absolute";
      span.style.display = "inline-block";
      span.style.width = "50%";
      span.style.right = "0px";
      this.mainlabel.appendChild(span);
      this.input = document.createElement("INPUT");
      this.input.type = "input";
      this.input.checked = Reflect.get(this._dataContainer, this._prop.name);
      this.input.style.textAlign = "right";
      this.input.style.display = "inline";
      this.input.style.marginTop = "0px";
      this.input.style.marginBottom = "0px";
      this.input.type = "checkbox";
      this.input.style.transform = "scale(" + constants.generalSizeCoef.toString() + ")";
      this.input.style.marginRight = Math.round(5 * constants.generalSizeCoef).toString() + "px";
      this.input.style.top = "0px";
      this.input.style.border = "1px solid grey";
      this.input.style.borderRadius = "1px";
      span.appendChild(this.input);
      this.input.addEventListener("keyup", (e) => {
        if (e.key === " ")
          this.value_TextChanged(null);
      });
      this.input.addEventListener("change", () => {
        this.value_TextChanged(null);
      });
      this._text = document.createElement("SPAN");
      this._text.style.display = "inline";
      this._text.style.fontFamily = UIElement.defaultFontFamily;
      this._text.style.fontSize = UIElement.defaultFontSize.toString() + "px";
      span.appendChild(this._text);
      this.updateText();
      this.input.addEventListener("focusin", () => {
        this.control_GotFocus(this);
      });
      this.input.addEventListener("focusout", () => {
        this.control_LostFocus(this);
      });
      this.checkForReadOnly();
    }
  }
  updateText() {
    this._text.innerText = this.input.checked ? "Enabled" : "Disabled";
  }
  refresh() {
    if (this.input == null)
      return;
    this.checkForReadOnly();
    if (this._getValueCallback == null)
      return;
    let v = this._getValueCallback(this);
    if (v == null)
      return;
    let b = v;
    if (this.input != null) {
      this.input.checked = b.valueOf();
      this.updateText();
    }
  }
  value_TextChanged(sender) {
    if (this.input != null) {
      this._value = this.input.checked;
      this.updateText();
      Reflect.set(this._dataContainer, this._prop.name, this._value);
      if (this._valueChangeCallback != null)
        this._valueChangeCallback(this);
      if (this._changeCausesParentRefresh)
        this.parentNode.refresh();
    }
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value;
    this.input.checked = value;
    this.updateText();
  }
  resize(top2, left1, left2, width) {
    return 0;
  }
};
var UIElementDoubleNan = class extends UIElementGeneric {
  constructor(p, dataContainer, prop) {
    super(p, dataContainer, prop);
    this._value = 0;
    this.preExpandIfNeeded();
  }
  AllocateControls() {
    super.AllocateControls();
    if (this.input == null) {
      this.input = document.createElement("INPUT");
      this.input.type = "input";
      this.input.value = Reflect.get(this._dataContainer, this._prop.name).toString();
      this.input.style.textAlign = "right";
      this.input.style.position = "absolute";
      this.input.style.marginTop = "0px";
      this.input.style.marginBottom = "0px";
      this.input.style.fontFamily = UIElement.defaultFontFamily;
      this.input.style.fontSize = UIElement.defaultFontSize.toString() + "px";
      this.input.type = "number";
      this.input.style.border = "1px solid grey";
      this.input.style.borderRadius = "1px";
      this.input.style.top = "0px";
      this.input.style.right = "3px";
      this.input.style.width = "50%";
      this.mainlabel.appendChild(this.input);
      new InputFieldManager(this.input, 4, true, Number.NaN, Number.NaN, () => {
        this.Text_TextChanged(null);
      });
      this.input.addEventListener("focusin", () => {
        this.control_GotFocus(this);
      });
      this.input.addEventListener("focusout", () => {
        this.control_LostFocus(this);
      });
      this.checkForReadOnly();
    }
  }
  refresh() {
    if (this.input == null)
      return;
    if (this._getValueCallback == null)
      return;
    let s = this._getValueCallback(this).toString();
    if (this.input != null) {
      if (s != this.input.value)
        this.input.value = s;
    }
    this.checkForReadOnly();
  }
  Text_TextChanged(sender) {
    if (this.input != null) {
      this._value = this.input.value == "" ? Number.NaN : parseFloat(this.input.value);
      Reflect.set(this._dataContainer, this._prop.name, new doubleNan(this._value));
      if (this._valueChangeCallback != null)
        this._valueChangeCallback(this);
      if (this._changeCausesParentRefresh)
        this.parentNode.refresh();
    }
  }
  get value() {
    return new doubleNan(this._value);
  }
  set value(value) {
    this._value = value.value;
    this.input.value = value.toString();
  }
  resize(top2, left1, left2, width) {
    this.mainlabel.style.height = this.input.offsetHeight.toString() + "px";
    return 0;
  }
};
var UIElementEnum = class extends UIElementGeneric {
  constructor(p, dataContainer, prop) {
    super(p, dataContainer, prop);
    this.allValues = [];
    this._value = "";
    this.preExpandIfNeeded();
  }
  AllocateControls() {
    super.AllocateControls();
    if (this.select == null) {
      this.select = document.createElement("SELECT");
      let enumvalue = Reflect.get(this._dataContainer, this._prop.name);
      this.allValues = enumvalue.sibblings;
      for (let i = 0; i < this.allValues.length; i++) {
        let opt = document.createElement("OPTION");
        opt.text = this.allValues[i].description;
        opt.value = this.allValues[i].toString;
        this.select.add(opt, null);
      }
      this.select.value = enumvalue.toString;
      this.select.style.position = "absolute";
      this.select.style.marginTop = "0px";
      this.select.style.marginBottom = "0px";
      this.select.style.fontFamily = UIElement.defaultFontFamily;
      this.select.style.fontSize = UIElement.defaultFontSize.toString() + "px";
      this.select.style.top = "0px";
      this.select.style.right = "3px";
      this.select.style.width = "50%";
      this.mainlabel.appendChild(this.select);
      this.select.addEventListener("change", () => {
        this.valueChanged(null);
      });
      this.select.addEventListener("focusin", () => {
        this.control_GotFocus(this);
      });
      this.select.addEventListener("focusout", () => {
        this.control_LostFocus(this);
      });
      this.checkForReadOnly();
    }
  }
  refresh() {
    if (this.select == null)
      return;
    if (this._getValueCallback == null)
      return;
    let value = this._getValueCallback(this);
    let s = value.toString;
    if (this.select != null) {
      if (s != this.select.value)
        this.select.value = s;
    }
    this.checkForReadOnly();
  }
  valueChanged(sender) {
    if (this.select != null) {
      this._value = this.select.value;
      let it = null;
      for (let i = 0; i < this.allValues.length; i++) {
        if (this.allValues[i].toString == this._value)
          it = this.allValues[i];
      }
      if (it != null)
        Reflect.set(this._dataContainer, this._prop.name, it);
      if (this._valueChangeCallback != null)
        this._valueChangeCallback(this);
      if (this._changeCausesParentRefresh)
        this.parentNode.refresh();
    }
  }
  tabReOrder(index) {
    if (this.select != null)
      this.select.tabIndex = index++;
    return index;
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value;
    this.select.value = value;
  }
  resize(top2, left1, left2, width) {
    this.mainlabel.style.height = this.select.offsetHeight.toString() + "px";
    return 0;
  }
};
var UIElementList = class extends UIElementGeneric {
  constructor(p, dataContainer, prop, allowedValues) {
    super(p, dataContainer, prop);
    this._refreshCallback = null;
    this._indexedValue = true;
    this.allValues = [];
    this.valueType = "";
    this._value = "";
    this._refreshCallback = allowedValues;
    this.preExpandIfNeeded();
  }
  AllocateControls() {
    super.AllocateControls();
    if (this.select == null) {
      this.allValues = this._refreshCallback();
      this.select = document.createElement("SELECT");
      let value = Reflect.get(this._dataContainer, this._prop.name);
      this.valueType = typeof value;
      this._indexedValue = typeof value == "number" && typeof this.allValues[0] != "number";
      let found = false;
      let first = null;
      for (let i = 0; i < this.allValues.length; i++) {
        let opt = document.createElement("OPTION");
        if (i == 0)
          first = opt;
        opt.text = this.allValues[i].toString();
        opt.value = this._indexedValue ? i : this.allValues[i];
        this.select.add(opt, null);
        if (opt.value.toString() == value.toString())
          found = true;
      }
      if (!found && !this._indexedValue) {
        let opt = document.createElement("OPTION");
        opt.text = value.toString();
        opt.value = value;
        this.select.add(opt, first);
      }
      this.select.value = value;
      this.select.style.position = "absolute";
      this.select.style.marginTop = "0px";
      this.select.style.marginBottom = "0px";
      this.select.style.fontFamily = UIElement.defaultFontFamily;
      this.select.style.fontSize = UIElement.defaultFontSize.toString() + "px";
      this.select.style.top = "0px";
      this.select.style.right = "3px";
      this.select.style.width = "50%";
      this.mainlabel.appendChild(this.select);
      this.select.addEventListener("change", () => {
        this.valueChanged(null);
      });
      this.select.addEventListener("focusin", () => {
        this.control_GotFocus(this);
      });
      this.select.addEventListener("focusout", () => {
        this.control_LostFocus(this);
      });
      this.checkForReadOnly();
    }
  }
  refresh() {
    if (this.select == null)
      return;
    if (this._getValueCallback == null)
      return;
    this.allValues = this._refreshCallback();
    for (let i = 0; i < this.allValues.length; i++) {
      let opt = i < this.select.options.length ? this.select.options[i] : document.createElement("OPTION");
      opt.text = this.allValues[i].toString();
      opt.value = this._indexedValue ? i : this.allValues[i];
      if (i >= this.select.options.length)
        this.select.add(opt, null);
    }
    while (this.allValues.length < this.select.options.length) {
      this.select.options[this.select.options.length - 1].remove();
    }
    let v = Reflect.get(this._dataContainer, this._prop.name);
    if (v == null)
      return;
    if (this._indexedValue) {
      let it = Number(v).toString();
      if (this.select.value != it)
        this.select.value = it;
    } else {
      let it = v.toString();
      if (this.select.value != it)
        this.select.value = it;
    }
    this.checkForReadOnly();
  }
  valueChanged(sender) {
    if (this.select != null) {
      this._value = this.select.value;
      if (this.valueType == "number") {
        let it = parseInt(this._value);
        if (it >= 0)
          Reflect.set(this._dataContainer, this._prop.name, it);
      } else {
        let it = "";
        for (let i = 0; i < this.allValues.length; i++) {
          if (this.allValues[i] == this._value)
            it = this.allValues[i];
        }
        if (it != "")
          Reflect.set(this._dataContainer, this._prop.name, it);
      }
      if (this._valueChangeCallback != null)
        this._valueChangeCallback(this);
      if (this._changeCausesParentRefresh) {
        this.parentNode.refresh();
      }
    }
  }
  tabReOrder(index) {
    if (this.select != null)
      this.select.tabIndex = index++;
    return index;
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value;
    this.select.value = value;
  }
  resize(top2, left1, left2, width) {
    this.mainlabel.style.height = this.select.offsetHeight.toString() + "px";
    return 0;
  }
};
var UIElementColor = class extends UIElementGeneric {
  constructor(p, dataContainer, prop) {
    super(p, dataContainer, prop);
    this.colorSample = null;
    this.colorEditor = null;
    this.colorPreview = null;
    this.currentColor = null;
    this._value = "";
    this.preExpandIfNeeded();
  }
  get expandIcon() {
    return ressources.DotDotDotIcon(UIElement.defaultFontSize.toString(), false, false, false, false, "Click to open color chooser");
  }
  get colapseIcon() {
    return ressources.DotDotDotIcon(UIElement.defaultFontSize.toString(), false, false, false, false, "Click to close color chooser");
  }
  AllocateControls() {
    this._expandable = true;
    this._expandButtonSide = 1;
    super.AllocateControls();
    if (this.input == null) {
      let table = document.createElement("TABLE");
      table.style.position = "absolute";
      table.style.top = "0px";
      table.style.right = "3px";
      table.style.width = "50%";
      table.style.borderCollapse = "collapse";
      let tr = document.createElement("TR");
      table.appendChild(tr);
      let td1 = document.createElement("TD");
      tr.appendChild(td1);
      this.colorSample = document.createElement("Div");
      this.colorSample.style.display = "inline-block";
      this.colorSample.style.border = "1px solid black";
      this.colorSample.style.marginRight = "1px";
      this.colorSample.style.marginTop = "0px";
      this.colorSample.style.width = "16px";
      this.colorSample.style.height = "16px";
      this.colorSample.style.top = "0px";
      this.colorSample.style.bottom = "0px";
      this.colorPreview = new ColorSampler(this.colorSample, null);
      td1.appendChild(this.colorSample);
      let td2 = document.createElement("TD");
      td2.style.width = "100%";
      tr.appendChild(td2);
      this.input = document.createElement("INPUT");
      this.input.type = "input";
      this.currentColor = Reflect.get(this._dataContainer, this._prop.name);
      this.colorPreview.color = this.currentColor;
      this.input.value = this.currentColor.toString();
      this.input.style.marginTop = "0px";
      this.input.style.marginBottom = "0px";
      this.input.style.width = "100%";
      this.input.style.border = "1px solid grey";
      this.input.style.borderRadius = "1px";
      this.input.style.fontFamily = UIElement.defaultFontFamily;
      this.input.style.fontSize = UIElement.defaultFontSize.toString() + "px";
      td2.appendChild(this.input);
      let td3 = document.createElement("TD");
      td3.style.paddingLeft = "5px";
      tr.appendChild(td3);
      td3.appendChild(this.expandCtrl);
      this.mainlabel.appendChild(table);
      new InputFieldManager(this.input, 7, false, Number.NaN, Number.NaN, (sender, refreshInput) => {
        this.Text_TextChanged(sender, refreshInput);
      });
      this.input.addEventListener("focusin", () => {
        this.control_GotFocus(this);
      });
      this.input.addEventListener("focusout", () => {
        this.control_LostFocus(this);
      });
      this.checkForReadOnly();
    }
  }
  expand() {
    if (this.colorEditor == null) {
      this.subElementPanel.style.marginLeft = "20px";
      this.colorEditor = new colorEditor(this.subElementPanel, UIElement.defaultFontSize, this.currentColor, (c) => {
        this.coloredited(c);
      });
    }
    this._rootNode.tabReOrder(0);
    this._expanded = true;
    this.subElementPanel.style.display = "";
    this.expandCtrl.innerHTML = this.colapseIcon;
  }
  colapse() {
    this.subElementPanel.style.display = "none";
    this.expandCtrl.innerHTML = this.expandIcon;
  }
  coloredited(newColor) {
    this.currentColor = newColor.clone();
    this.colorPreview.color = this.currentColor;
    this.input.value = this.currentColor.toString();
    Reflect.set(this._dataContainer, this._prop.name, this.currentColor);
    if (this._valueChangeCallback != null)
      this._valueChangeCallback(this);
    if (this._changeCausesParentRefresh)
      this.parentNode.refresh();
  }
  refresh() {
    if (this.input == null)
      return;
    if (this._getValueCallback == null)
      return;
    let c = this._getValueCallback(this);
    if (c != null) {
      if (this.colorPreview != null)
        this.colorPreview.color = c;
      if (this.input != null) {
        let s = c.toString();
        if (s != this.input.value)
          this.input.value = s;
      }
    }
    this.checkForReadOnly();
  }
  Text_TextChanged(sender, refreshInput) {
    if (this.input != null) {
      this._value = this.input.value;
      let c = YColor.FromString(this._value);
      if (c != null) {
        this.colorPreview.color = c;
        this.currentColor = c;
        if (this.colorEditor != null)
          this.colorEditor.color = c;
        Reflect.set(this._dataContainer, this._prop.name, c);
        if (refreshInput)
          this.input.value = c.toString();
        if (this._valueChangeCallback != null)
          this._valueChangeCallback(this);
        if (this._changeCausesParentRefresh)
          this.parentNode.refresh();
      }
    }
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value;
    this.input.value = value;
  }
  resize(top2, left1, left2, width) {
    let h = this.input.offsetHeight;
    this.mainlabel.style.height = h.toString() + "px";
    return 0;
  }
};
var UIElementMarkerPos = class _UIElementMarkerPos extends UIElementGeneric {
  constructor(p, dataContainer, prop) {
    super(p, dataContainer, prop);
    this._cachedValue = null;
    this._value = "";
    this.preExpandIfNeeded();
  }
  static expandIconSVG(size) {
    return ressources.targetIcon(size.toString(), false, false, false, false, "Click to place marker on graph");
  }
  get expandIcon() {
    return _UIElementMarkerPos.expandIconSVG(UIElement.defaultFontSize);
  }
  get colapseIcon() {
    return _UIElementMarkerPos.expandIconSVG(UIElement.defaultFontSize);
  }
  AllocateControls() {
    this._expandable = true;
    this._expandButtonSide = 1;
    super.AllocateControls();
    if (this.input == null) {
      let table = document.createElement("TABLE");
      table.style.position = "absolute";
      table.style.top = "0px";
      table.style.right = "3px";
      table.style.width = "50%";
      table.style.borderCollapse = "collapse";
      let tr = document.createElement("TR");
      table.appendChild(tr);
      let td2 = document.createElement("TD");
      td2.style.width = "100%";
      tr.appendChild(td2);
      this.input = document.createElement("INPUT");
      this.input.type = "input";
      this._cachedValue = Reflect.get(this._dataContainer, this._prop.name);
      this.input.value = this._cachedValue.toString();
      this.input.style.marginTop = "0px";
      this.input.style.marginBottom = "0px";
      this.input.style.textAlign = "right";
      this.input.style.width = "100%";
      this.input.style.border = "1px solid grey";
      this.input.style.borderRadius = "1px";
      this.input.style.fontFamily = UIElement.defaultFontFamily;
      this.input.style.fontSize = UIElement.defaultFontSize.toString() + "px";
      this.input.addEventListener("keyup", () => {
        this.Text_TextChanged(null, true);
      });
      this.input.addEventListener("change", () => {
        this.Text_TextChanged(null, false);
      });
      td2.appendChild(this.input);
      let td3 = document.createElement("TD");
      td3.style.paddingLeft = "5px";
      tr.appendChild(td3);
      td3.appendChild(this.expandCtrl);
      this.mainlabel.appendChild(table);
      this.input.addEventListener("focusin", () => {
        this.control_GotFocus(this);
      });
      this.input.addEventListener("focusout", () => {
        this.control_LostFocus(this);
      });
      this.checkForReadOnly();
    }
  }
  expand() {
    let value = Reflect.get(this._dataContainer, this._prop.name);
    this.expanded = false;
    value.capture = true;
    Reflect.set(this._dataContainer, this._prop.name, value);
    if (this._valueChangeCallback != null)
      this._valueChangeCallback(this);
  }
  colapse() {
  }
  refresh() {
    if (this.input == null)
      return;
    if (this._getValueCallback == null)
      return;
    this._cachedValue = this._getValueCallback(this);
    if (this.input != null) {
      this.input.value = this._cachedValue.toString();
    }
    this.checkForReadOnly();
  }
  Text_TextChanged(sender, refreshInput) {
    let parsedValue = this._cachedValue.TryParse(this.input.value);
    if (parsedValue.success) {
      this._cachedValue.value = parsedValue.result;
      Reflect.set(this._dataContainer, this._prop.name, this._cachedValue);
      if (this._valueChangeCallback != null)
        this._valueChangeCallback(this);
      if (this._changeCausesParentRefresh)
        this.parentNode.refresh();
    }
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value;
    this.input.value = value;
  }
  resize(top2, left1, left2, width) {
    let h = this.input.offsetHeight;
    this.mainlabel.style.height = h.toString() + "px";
    return 0;
  }
};
var InputFieldManager = class {
  static nullCallback(sender) {
  }
  constructor(input, type, allowEmpty, min, max, callback) {
    this._allowEmpty = false;
    this._min = Number.NaN;
    this._max = Number.NaN;
    this._callback = null;
    this._input = input;
    this._type = type;
    this._allowEmpty = allowEmpty;
    this._min = min;
    this._max = max;
    this._callback = callback;
    this.checkData();
    this._input.addEventListener("keyup", () => {
      this.InputChange(this._input, true);
    });
    this._input.addEventListener("change", () => {
      this.InputChange(this._input, false);
    });
  }
  showError(msg) {
    this._input.title = msg;
  }
  clearError() {
    this._input.title = "";
  }
  backGroundColorFeedback(ErrorMsg, state) {
    if (state)
      this.clearError();
    else
      this.showError(ErrorMsg);
    let c = this._input.style.backgroundColor;
    if (state && c != "white")
      this._input.style.backgroundColor = "white";
    if (!state && c != "pink")
      this._input.style.backgroundColor = "pink";
    return state;
  }
  checkData() {
    let intValue = 0;
    let doubleValue = 0;
    if (this._input.disabled)
      return true;
    let strValue = this._input.value;
    if (strValue == "")
      return this.backGroundColorFeedback("This field can't be empty", this._allowEmpty);
    switch (this._type) {
      case 0:
        break;
      case 1:
        intValue = parseInt(strValue);
        doubleValue = parseFloat(strValue);
        if (Number.isNaN(intValue) || intValue != doubleValue)
          return this.backGroundColorFeedback("Integer value expected", false);
        if (!Number.isNaN(this._min) && intValue < this._min)
          return this.backGroundColorFeedback("Integer value greater or equal to " + this._min.toString() + " expected", false);
        if (!Number.isNaN(this._max) && intValue > this._max)
          return this.backGroundColorFeedback("Integer value lower or equal to  " + this._min.toString() + " expected", false);
        break;
      case 2:
        intValue = parseInt(strValue);
        doubleValue = parseFloat(strValue);
        if (Number.isNaN(intValue) || intValue != doubleValue)
          return this.backGroundColorFeedback("Positive integer  expected", false);
        if (intValue < 0)
          return this.backGroundColorFeedback("Positive integer value  expected", false);
        if (!Number.isNaN(this._min) && intValue < this._min)
          return this.backGroundColorFeedback("Positive integer value greater or equal to " + this._min.toString() + " expected", false);
        if (!Number.isNaN(this._max) && intValue > this._max)
          return this.backGroundColorFeedback("Positive integer value lower or equal to  " + this._min.toString() + " expected", false);
        break;
      case 3:
        intValue = parseInt(strValue);
        doubleValue = parseFloat(strValue);
        if (Number.isNaN(intValue) || intValue != doubleValue)
          return this.backGroundColorFeedback("Strictly positive Integer value expected", false);
        if (intValue <= 0)
          return this.backGroundColorFeedback("Strictly positive integer value  expected", false);
        if (!Number.isNaN(this._min) && intValue < this._min)
          return this.backGroundColorFeedback("Positive integer value greater or equal to " + this._min.toString() + " expected", false);
        if (!Number.isNaN(this._max) && intValue > this._max)
          return this.backGroundColorFeedback("Positive integer value lower or equal to  " + this._min.toString() + " expected", false);
        break;
      case 4:
        doubleValue = parseFloat(strValue);
        if (Number.isNaN(intValue))
          return this.backGroundColorFeedback("Floating point value expected", false);
        if (!Number.isNaN(this._min) && doubleValue < this._min)
          return this.backGroundColorFeedback("Floating point value greater or equal to " + this._min.toString() + " expected", false);
        if (!Number.isNaN(this._max) && doubleValue > this._max)
          return this.backGroundColorFeedback("Floating point value lower or equal to  " + this._min.toString() + " expected", false);
        break;
      case 5:
        doubleValue = parseFloat(strValue);
        if (Number.isNaN(doubleValue))
          return this.backGroundColorFeedback("Positive floating point value expected", false);
        if (doubleValue < 0)
          return this.backGroundColorFeedback("Positive floating point value expected", false);
        if (!Number.isNaN(this._min) && doubleValue < this._min)
          return this.backGroundColorFeedback("Floating point value greater or equal to " + this._min.toString() + " expected", false);
        if (!Number.isNaN(this._max) && doubleValue > this._max)
          return this.backGroundColorFeedback("Floating point value lower or equal to  " + this._min.toString() + " expected", false);
        break;
      case 6:
        doubleValue = parseFloat(strValue);
        if (Number.isNaN(doubleValue))
          return this.backGroundColorFeedback("Strictly positive floating point value expected", false);
        if (doubleValue <= 0)
          return this.backGroundColorFeedback("Strictly positive floating point value expected", false);
        if (!Number.isNaN(this._min) && doubleValue < this._min)
          return this.backGroundColorFeedback("Floating point value greater or equal to " + this._min.toString() + " expected", false);
        if (!Number.isNaN(this._max) && doubleValue > this._max)
          return this.backGroundColorFeedback("Floating point value greater or equal to " + this._min.toString() + " expected", false);
        break;
      case 7:
        if (YColor.FromString(strValue) == null)
          return this.backGroundColorFeedback("Value color name/definition expected", false);
        break;
    }
    return this.backGroundColorFeedback("", true);
  }
  InputChange(sender, refreshInput) {
    if (this.checkData()) {
      try {
        if (this._callback != null)
          this._callback(sender, refreshInput);
      } catch (ex) {
        this.backGroundColorFeedback(ex.message, false);
      }
    }
  }
};

// obj/full/colorEditor_rw.js
var ColorEditorTab = class {
  constructor(editor, label, fontSize) {
    this._realTab = false;
    this._div = null;
    this._tabLabel = null;
    this._td = document.createElement("TD");
    this._editor = editor;
    if (label != "") {
      this._div = document.createElement("DIV");
      this._div.style.display = "none";
      this._td.style.paddingTop = "4px";
      this._td.style.fontSize = fontSize.toString() + "px";
      this._td.style.paddingBottom = "2px";
      this._td.style.borderLeft = "1px solid " + this._editor.inactiveBorderColor;
      this._td.style.borderRight = "1px solid " + this._editor.inactiveBorderColor;
      this._td.style.borderTop = "1px solid " + this._editor.inactiveBorderColor;
      this._td.style.borderBottom = "1px solid " + this._editor.activeBorderColor;
      this._td.style.color = this._editor.inactiveColor;
      this._td.style.backgroundColor = this._editor.inactiveBackgroundColor;
      this._td.style.borderTopLeftRadius = "3px";
      this._td.style.borderTopRightRadius = "3px";
      this._td.style.paddingLeft = "5px";
      this._td.style.paddingRight = "5px";
      this._realTab = true;
      this._tabLabel = document.createElement("ANCHOR");
      this._tabLabel.innerText = label;
      this._tabLabel.addEventListener("click", () => {
        this._editor.tabSelected(this);
      });
      this._tabLabel.addEventListener("keyup", (e) => {
        if (e.key === "Enter" || e.key === " ")
          this._editor.tabSelected(this);
      });
      this._tabLabel.style.cursor = "pointer";
      this._td.appendChild(this._tabLabel);
    } else {
      this._td.style.borderBottom = "1px solid " + this._editor.activeBorderColor;
      this._td.innerHTML = "<span>&nbsp;</span>";
    }
  }
  setTabIndex(index) {
    this._tabLabel.tabIndex = index++;
    return index;
  }
  set active(value) {
    if (!this._realTab)
      return;
    this._td.style.borderLeftColor = value ? this._editor.activeBorderColor : this._editor.inactiveBorderColor;
    this._td.style.borderTopColor = value ? this._editor.activeBorderColor : this._editor.inactiveBorderColor;
    this._td.style.borderRightColor = value ? this._editor.activeBorderColor : this._editor.inactiveBorderColor;
    this._td.style.borderBottomColor = value ? "rgba(0, 0, 0, 0)" : this._editor.activeBorderColor;
    this._td.style.color = value ? this._editor.activeColor : this._editor.inactiveColor;
    this._td.style.backgroundColor = value ? this._editor.activeBackgroundColor : this._editor.inactiveBackgroundColor;
    this._div.style.display = value ? "" : "none";
  }
  get active() {
    return this._div.style.display == "";
  }
  get tabElement() {
    return this._td;
  }
  get divElement() {
    return this._div;
  }
};
var ColorEditorSroll = class _ColorEditorSroll {
  setTabIndex(index) {
    this._anchor.tabIndex = index++;
    this._input.tabIndex = index++;
    return index;
  }
  constructor(div, anchor, input, colorCallback, changeCallBack, checkerBoardBg, value) {
    this._value = 0;
    this._colorCallback = colorCallback;
    this._changeCallBack = changeCallBack;
    this._value = value;
    this._div = div;
    let s = _ColorEditorSroll.scrollHeight;
    if (checkerBoardBg)
      this._div.style.background = "url('data:image/svg+xml;utf8," + ColorSampler.checkerboardImage(s, s) + "')";
    this._anchor = anchor;
    this._input = input;
    this._input.size = 3;
    this._input.maxLength = 3;
    this._input.type = "number";
    this._input.min = "0";
    this._input.max = "255";
    this._input.style.fontSize = (12 * constants.guiDPIFactor).toString() + "px";
    this._input.style.textAlign = "right";
    this._input.value = this._value.toString();
    this._input.style.marginLeft = "10px";
    this._div.style.width = "100%";
    this._div.style.position = "relative";
    this._div.style.height = _ColorEditorSroll.scrollHeight.toString() + "px";
    this._div.style.border = "1px solid black";
    this._canvasBg = document.createElement("CANVAS");
    this._div.appendChild(this._canvasBg);
    this._canvasBg.style.left = "0px";
    this._canvasBg.style.top = "0px";
    this._canvasBg.style.width = "100%";
    this._canvasBg.style.height = "100%";
    this._canvasBg.width = 256;
    this._canvasBg.height = _ColorEditorSroll.scrollHeight;
    this._canvasCursor = document.createElement("CANVAS");
    this._div.appendChild(this._canvasCursor);
    this._canvasCursor.style.position = "absolute";
    this._canvasCursor.style.width = "100%";
    this._canvasCursor.style.height = "100%";
    this._canvasCursor.style.left = "0px";
    this._canvasCursor.style.top = "0px";
    this._canvasCursor.style.display = "block";
    this._div.addEventListener("mousedown", (e) => {
      this.MouseDown(this._div, e);
    });
    this._div.addEventListener("mousemove", (e) => {
      this.MouseMove(this._div, e);
    });
    this._anchor.addEventListener("wheel", (e) => {
      this.mouseWheelEvent(this._div, e);
    });
    this._anchor.addEventListener("keydown", (e) => {
      this.KeyDown(this._div, e);
    });
    this._input.addEventListener("keyup", (e) => {
      this.inputKeyUp();
    });
    this._input.addEventListener("change", (e) => {
      this.inputKeyUp();
    });
    this._anchor.tabIndex = 4;
  }
  get value() {
    return this._value;
  }
  set value(v) {
    if (v < 0)
      v = 0;
    if (v > 255)
      v = 255;
    this._value = v;
    this._input.value = this._value.toString();
  }
  inputKeyUp() {
    let value = parseInt(this._input.value);
    if (isNaN(value))
      return;
    if (value < 0)
      value = 0;
    if (value > 255)
      value = 255;
    this._value = value;
    this.refresh();
    this._changeCallBack(this);
  }
  TouchStart(div, e) {
    if (e.touches.length == 1)
      this.handleMouseStartCapture(div, e.touches[0].clientX, e.touches[0].clientY);
  }
  TouchCaptureRun(div, e) {
    if (e.touches.length == 1)
      this.handleMouseRun(div, e.touches[0].clientX, e.touches[0].clientY);
  }
  TouchCaptureEnd(div, e) {
  }
  MouseDown(sender, e) {
    if (e.buttons != 1)
      return;
    this.handleMouseStartCapture(sender, e.clientX, e.clientY);
  }
  handleMouseStartCapture(sender, x, y) {
    let SenderRect = sender.getBoundingClientRect();
    let eX = Math.round(x - SenderRect.left);
    let index = Math.round(256 * eX / this._div.offsetWidth) >> 0;
    if (index < 0)
      index = 0;
    if (index > 255)
      index = 255;
    this._value = index;
    this._input.value = index.toString();
    this.refresh();
    this._changeCallBack(this);
  }
  MouseMove(sender, e) {
    if (e.buttons != 1)
      return;
    this.handleMouseRun(sender, e.clientX, e.clientY);
  }
  handleMouseRun(sender, x, y) {
    let SenderRect = sender.getBoundingClientRect();
    let eX = Math.round(x - SenderRect.left);
    let index = Math.round(256 * eX / this._div.offsetWidth) >> 0;
    if (index < 0)
      index = 0;
    if (index > 255)
      index = 255;
    this._value = index;
    this._input.value = index.toString();
    this.refresh();
    this._changeCallBack(this);
  }
  mouseWheelEvent(sender, e) {
    this._value += e.deltaY > 0 ? -1 : 1;
    if (this._value < 0) {
      this._value = 0;
    } else if (this._value > 255) {
      this._value = 255;
    } else {
      e.preventDefault();
    }
    this._input.value = this._value.toString();
    this.refresh();
    this._changeCallBack(this);
  }
  KeyDown(sender, e) {
    if (e.code == "ArrowRight") {
      this._value++;
      if (this._value > 255)
        this._value = 255;
    }
    if (e.code == "ArrowLeft") {
      this._value--;
      if (this._value < 0)
        this._value = 0;
    }
    this._input.value = this._value.toString();
    this.refresh();
    this._changeCallBack(this);
  }
  refresh() {
    let color = this._colorCallback(this);
    let ctx = this._canvasBg.getContext("2d");
    ctx.clearRect(0, 0, this._canvasBg.width, this._canvasBg.height);
    for (let i = 0; i < 256; i++) {
      ctx.beginPath();
      ctx.moveTo(i + 0.5, 0);
      ctx.lineTo(i + 0.5, _ColorEditorSroll.scrollHeight);
      ctx.strokeStyle = color[i];
      ctx.stroke();
    }
    this._canvasCursor.width = this._div.offsetWidth;
    this._canvasCursor.height = this._div.offsetHeight;
    ctx = this._canvasCursor.getContext("2d");
    let x = 0.5 + this._value / 255 * this._canvasCursor.width;
    ctx.beginPath();
    let y = 0.5;
    ctx.moveTo(x, y + 5);
    ctx.lineTo(x + 3, y);
    ctx.lineTo(x - 3, y);
    ctx.fillStyle = "black";
    ctx.strokeStyle = "white";
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
    y = this._canvasCursor.height - 0.5;
    ctx.beginPath();
    ctx.moveTo(x, y - 5);
    ctx.lineTo(x + 3, y);
    ctx.lineTo(x - 3, y);
    ctx.fillStyle = "black";
    ctx.strokeStyle = "white";
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
  }
};
ColorEditorSroll.scrollHeight = 26 * constants.guiDPIFactor;
var ColorSampler = class _ColorSampler {
  setTabIndex(index) {
    this._colorDiv.tabIndex = index++;
    return index;
  }
  static checkerboardImage(width, height) {
    let halfWidth = width >> 1;
    let halfHeight = height >> 1;
    return '<svg xmlns="http://www.w3.org/2000/svg"   viewbox="0 0 ' + width + " " + height + '" width="' + width + 'px"  height="' + height + 'px" ><rect x="0" y="0" width="' + width + '" height="' + height + '" style="fill:white"/><rect x="0" y="0" width="' + halfWidth + '" height="' + halfHeight + '" style="fill:black"/><rect x="' + halfWidth + '" y="' + halfHeight + '" width="' + halfWidth + '" height="' + halfHeight + '" style="fill:black"/></svg>';
  }
  constructor(containerDiv, selectCallback) {
    this._containerDiv = containerDiv;
    this._selectCallback = selectCallback;
    this._containerDiv.style.border = "1px solid grey";
    this._containerDiv.style.background = "url('data:image/svg+xml;utf8," + _ColorSampler.checkerboardImage(100, 100) + "')";
    this._containerDiv.style.backgroundSize = "cover";
    this._containerDiv.style.backgroundPosition = "center";
    this._containerDiv.style.backgroundRepeat = "no-repeat";
    this._color = YColor.Transparent;
    this._colorDiv = document.createElement("DIV");
    this._colorDiv.style.display = "display-block";
    this._colorDiv.style.position = "relative";
    this._colorDiv.style.width = "100%";
    this._colorDiv.style.height = "100%";
    this._colorDiv.style.backgroundColor = "rgba(0,0,0,0)";
    this._containerDiv.appendChild(this._colorDiv);
    if (this._selectCallback != null) {
      this._colorDiv.addEventListener("click", () => {
        this._selectCallback(this.color);
      });
      this._colorDiv.addEventListener("keyup", (e) => {
        if (e.key === "Enter" || e.key === " ")
          this._selectCallback(this.color);
      });
      this._colorDiv.style.cursor = "pointer";
    }
  }
  set color(value) {
    this._color = value.clone();
    this._colorDiv.style.backgroundColor = this._color.htmlCode;
  }
  get color() {
    return this._color.clone();
  }
};
var colorEditor = class _colorEditor {
  static AddColorToHistory(c) {
    for (let i = 0; i < _colorEditor._colorHistory.length; i++) {
      if (c.equal(_colorEditor._colorHistory[i]))
        return;
    }
    _colorEditor._colorHistory.splice(_colorEditor._colorHistory.length - 1, 1);
    _colorEditor._colorHistory.splice(0, 0, c);
    for (let i = _colorEditor._editorsList.length - 1; i >= 0; i--) {
      _colorEditor._editorsList[i].refreshColorHistory();
    }
  }
  static get colorHistory() {
    return _colorEditor._colorHistory;
  }
  get activeBorderColor() {
    return "#767676";
  }
  get inactiveBorderColor() {
    return "#b0b0b0";
  }
  get activeColor() {
    return "black";
  }
  get inactiveColor() {
    return "grey";
  }
  get activeBackgroundColor() {
    return "white";
  }
  get inactiveBackgroundColor() {
    return "#f8f8f8";
  }
  tabSelected(source) {
    if (source == this._tabRGB) {
      this._tabRGB.active = true;
      this._rgb_R_editor.refresh();
      this._rgb_G_editor.refresh();
      this._rgb_B_editor.refresh();
      this._rgb_T_editor.refresh();
    } else {
      this._tabRGB.active = false;
    }
    if (source == this._tabHSL) {
      this._tabHSL.active = true;
      this._hsl_H_editor.refresh();
      this._hsl_S_editor.refresh();
      this._hsl_L_editor.refresh();
      this._hsl_T_editor.refresh();
    } else {
      this._tabHSL.active = false;
    }
    this._tabPredef.active = source == this._tabPredef;
  }
  HueScrollBg() {
    let s = 100;
    let l = 50;
    let t = this._hsl_T_editor.value / 255;
    let res = new Array(256);
    for (let i = 0; i < 256; i++) {
      res[i] = "hsl(" + (360 * i / 256).toString() + "," + s.toString() + "%," + l.toString() + "%)";
    }
    return res;
  }
  SaturationScrollBg() {
    let h = 360 * this._hsl_H_editor.value / 256;
    let l = 100 * this._hsl_L_editor.value / 255;
    let t = this._hsl_T_editor.value / 255;
    let res = new Array(256);
    for (let i = 0; i < 256; i++) {
      res[i] = "hsl(" + h.toString() + "," + (100 * i / 255).toString() + "%," + l.toString() + "%)";
    }
    return res;
  }
  LuminosityScrollBg() {
    let h = 360 * this._hsl_H_editor.value / 256;
    let s = 100 * this._hsl_S_editor.value / 255;
    let t = this._hsl_T_editor.value / 255;
    let res = new Array(256);
    for (let i = 0; i < 256; i++) {
      res[i] = "hsl(" + h.toString() + "," + s.toString() + "%," + (100 * i / 255).toString() + "%)";
    }
    return res;
  }
  HSLTranspScrollBg() {
    let h = 360 * this._hsl_H_editor.value / 256;
    let s = 100 * this._hsl_S_editor.value / 255;
    let l = 100 * this._hsl_L_editor.value / 255;
    let res = new Array(256);
    for (let i = 0; i < 256; i++) {
      res[i] = "hsla(" + h.toString() + "," + l.toString() + "%," + s.toString() + "%," + (i / 255).toString() + ")";
    }
    return res;
  }
  RedScrollBg() {
    let g = this._rgb_G_editor.value;
    let b = this._rgb_B_editor.value;
    let t = this._rgb_T_editor.value / 255;
    let res = new Array(256);
    for (let i = 0; i < 256; i++) {
      res[i] = "rgb(" + i.toString() + "," + g.toString() + "," + b.toString() + ")";
    }
    return res;
  }
  GreenScrollBg() {
    let r = this._rgb_R_editor.value;
    let b = this._rgb_B_editor.value;
    let t = this._rgb_T_editor.value / 255;
    let res = new Array(256);
    for (let i = 0; i < 256; i++) {
      res[i] = "rgb(" + r.toString() + "," + i.toString() + "," + b.toString() + ")";
    }
    return res;
  }
  BlueScrollBg() {
    let r = this._rgb_R_editor.value;
    let g = this._rgb_G_editor.value;
    let t = this._rgb_T_editor.value / 255;
    let res = new Array(256);
    for (let i = 0; i < 256; i++) {
      res[i] = "rgb(" + r.toString() + "," + g.toString() + "," + i.toString() + ")";
    }
    return res;
  }
  RGBTranspScrollBg() {
    let r = this._rgb_R_editor.value;
    let g = this._rgb_G_editor.value;
    let b = this._rgb_B_editor.value;
    let res = new Array(256);
    for (let i = 0; i < 256; i++) {
      res[i] = "rgba(" + r.toString() + "," + g.toString() + "," + b.toString() + "," + (i / 255).toString() + ")";
    }
    return res;
  }
  static defaultColorHistory() {
    let defaultHistory = [];
    defaultHistory.push(YColor.FromAhsl(100, 0, 0, 0));
    defaultHistory.push(YColor.FromAhsl(100, 0, 0, 51));
    defaultHistory.push(YColor.FromAhsl(100, 0, 0, 102));
    defaultHistory.push(YColor.FromAhsl(100, 0, 0, 153));
    defaultHistory.push(YColor.FromAhsl(100, 0, 0, 204));
    defaultHistory.push(YColor.FromAhsl(100, 0, 0, 255));
    defaultHistory.push(YColor.FromAhsl(100, 0, 255, 127));
    defaultHistory.push(YColor.FromAhsl(100, 42, 255, 127));
    defaultHistory.push(YColor.FromAhsl(100, 85, 255, 127));
    defaultHistory.push(YColor.FromAhsl(100, 96, 255, 127));
    defaultHistory.push(YColor.FromAhsl(100, 127, 255, 127));
    defaultHistory.push(YColor.FromAhsl(100, 170, 255, 127));
    defaultHistory.push(YColor.FromAhsl(100, 192, 255, 127));
    defaultHistory.push(YColor.FromAhsl(100, 212, 255, 127));
    defaultHistory.push(YColor.FromAhsl(255, 226, 217, 214));
    return defaultHistory;
  }
  destroy() {
    for (let i = _colorEditor._editorsList.length - 1; i >= 0; i--) {
      if (_colorEditor._editorsList[i] == this) {
        _colorEditor._editorsList.splice(i, 1);
      }
    }
  }
  refreshColorHistory() {
    for (let i = 0; i < this._samples.length; i++) {
      if (i < _colorEditor._colorHistory.length) {
        this._samples[i].color = _colorEditor._colorHistory[i].clone();
      }
    }
  }
  constructor(container, fontSize, initialColor, colorChangeCallback) {
    this._firstTabIndex = 0;
    this._memorizeTimer = null;
    _colorEditor._editorsList.push(this);
    this._colorChangeCallback = colorChangeCallback;
    this._container = container;
    this._table = document.createElement("TABLE");
    this._table.style.width = "100%";
    this._table.style.borderSpacing = "0";
    this._table.style.paddingLeft = "5px";
    this._table.style.paddingTop = "5px";
    this._table.style.paddingRight = "5px";
    this._table.style.borderCollapse = "separate";
    this._tr1 = document.createElement("TR");
    this._tr2 = document.createElement("TR");
    this._tabRGB = new ColorEditorTab(this, "RGB", fontSize);
    this._tabHSL = new ColorEditorTab(this, "HSL", fontSize);
    this._tabPredef = new ColorEditorTab(this, "Predefined", fontSize);
    this._tabStub = new ColorEditorTab(this, "", fontSize);
    this._contents = document.createElement("TD");
    this._contents.colSpan = 4;
    this._contents.style.borderLeft = "1px solid " + this.activeBorderColor;
    this._contents.style.borderRight = "1px solid " + this.activeBorderColor;
    this._contents.style.borderBottom = "1px solid " + this.activeBorderColor;
    this._contents.style.backgroundColor = this.activeBackgroundColor;
    this._tr1.appendChild(this._tabRGB.tabElement);
    this._tr1.appendChild(this._tabHSL.tabElement);
    this._tr1.appendChild(this._tabPredef.tabElement);
    this._tr1.appendChild(this._tabStub.tabElement);
    this._tr2.appendChild(this._contents);
    this._table.appendChild(this._tr1);
    this._table.appendChild(this._tr2);
    this._contents.appendChild(this._tabRGB.divElement);
    this._contents.appendChild(this._tabHSL.divElement);
    this._contents.appendChild(this._tabPredef.divElement);
    let RGBtable = document.createElement("TABLE");
    RGBtable.style.width = "100%";
    RGBtable.style.borderSpacing = "1";
    this._tabRGB.divElement.appendChild(RGBtable);
    let HSLtable = document.createElement("TABLE");
    HSLtable.style.width = "100%";
    HSLtable.style.borderSpacing = "1";
    this._tabHSL.divElement.appendChild(HSLtable);
    let predefTable = document.createElement("TABLE");
    this._tabPredef.divElement.appendChild(predefTable);
    predefTable.style.width = "100%";
    predefTable.style.borderSpacing = "1";
    predefTable.style.tableLayout = "fixed";
    this._container.appendChild(this._table);
    this._rgb_R_editor = this.AddColorScroll(RGBtable, "R", () => {
      return this.RedScrollBg();
    }, (src) => {
      this.RgbColorChangeCallBack(src);
    }, false, 1);
    this._rgb_G_editor = this.AddColorScroll(RGBtable, "G", () => {
      return this.GreenScrollBg();
    }, (src) => {
      this.RgbColorChangeCallBack(src);
    }, false, 2);
    this._rgb_B_editor = this.AddColorScroll(RGBtable, "B", () => {
      return this.BlueScrollBg();
    }, (src) => {
      this.RgbColorChangeCallBack(src);
    }, false, 3);
    this._rgb_T_editor = this.AddColorScroll(RGBtable, "T", () => {
      return this.RGBTranspScrollBg();
    }, (src) => {
      this.RgbColorChangeCallBack(src);
    }, true, 3);
    this._rgb_R_editor.value = initialColor.red;
    this._rgb_G_editor.value = initialColor.green;
    this._rgb_B_editor.value = initialColor.blue;
    this._rgb_T_editor.value = initialColor.alpha;
    this._rgb_R_editor.refresh();
    this._rgb_G_editor.refresh();
    this._rgb_B_editor.refresh();
    this._rgb_T_editor.refresh();
    this._hsl_H_editor = this.AddColorScroll(HSLtable, "H", () => {
      return this.HueScrollBg();
    }, (src) => {
      this.HslColorChangeCallBack(src);
    }, false, 1);
    this._hsl_S_editor = this.AddColorScroll(HSLtable, "S", () => {
      return this.SaturationScrollBg();
    }, (src) => {
      this.HslColorChangeCallBack(src);
    }, false, 2);
    this._hsl_L_editor = this.AddColorScroll(HSLtable, "L", () => {
      return this.LuminosityScrollBg();
    }, (src) => {
      this.HslColorChangeCallBack(src);
    }, false, 3);
    this._hsl_T_editor = this.AddColorScroll(HSLtable, "T", () => {
      return this.HSLTranspScrollBg();
    }, (src) => {
      this.HslColorChangeCallBack(src);
    }, true, 3);
    this._hsl_H_editor.value = initialColor.hue;
    this._hsl_S_editor.value = initialColor.saturation;
    this._hsl_L_editor.value = initialColor.luminosity;
    this._hsl_T_editor.value = initialColor.alpha;
    this._hsl_H_editor.refresh();
    this._hsl_S_editor.refresh();
    this._hsl_L_editor.refresh();
    this._hsl_T_editor.refresh();
    let samplesTable = document.createElement("TABLE");
    samplesTable.style.position = "relative";
    samplesTable.style.width = "100%";
    samplesTable.style.paddingLeft = "3px";
    samplesTable.style.paddingRight = "3px";
    samplesTable.style.paddingTop = "10px";
    samplesTable.style.bottom = "3px";
    samplesTable.style.tableLayout = "fixed";
    let samplesTD = [];
    let previewTD = null;
    let sampleHeight = 30;
    let sampletr1 = document.createElement("TR");
    sampletr1.style.height = sampleHeight.toString() + "px";
    for (let i = 0; i < 6; i++) {
      let td = document.createElement("TD");
      if (i == 5) {
        td.colSpan = 2;
        td.rowSpan = 3;
        previewTD = td;
      } else {
        samplesTD.push(td);
      }
      sampletr1.appendChild(td);
    }
    samplesTable.appendChild(sampletr1);
    let sampletr2 = document.createElement("TR");
    sampletr2.style.height = sampleHeight.toString() + "px";
    for (let i = 0; i < 5; i++) {
      let td = document.createElement("TD");
      samplesTD.push(td);
      sampletr2.appendChild(td);
    }
    samplesTable.appendChild(sampletr2);
    let sampletr3 = document.createElement("TR");
    sampletr3.style.height = sampleHeight.toString() + "px";
    for (let i = 0; i < 5; i++) {
      let td = document.createElement("TD");
      samplesTD.push(td);
      sampletr3.appendChild(td);
    }
    samplesTable.appendChild(sampletr3);
    this._container.appendChild(samplesTable);
    this._samples = [];
    for (let i = 0; i < samplesTD.length; i++) {
      let div2 = document.createElement("DIV");
      div2.style.position = "relative";
      div2.style.width = "100%";
      div2.style.height = (sampleHeight - 4).toString() + "px";
      div2.style.display = "inline-block";
      div2.title = "Color history";
      samplesTD[i].appendChild(div2);
      let sampler = new ColorSampler(div2, (c) => {
        this.sampleWasSelectedCallback(c);
      });
      sampler.color = _colorEditor._colorHistory[i];
      this._samples.push(sampler);
    }
    let prefinedColors = YColor.predefinedColors;
    let colors = [];
    let predefinedColorNames = Object.keys(prefinedColors);
    for (let i = 0; i < predefinedColorNames.length; i++) {
      colors.push(prefinedColors[predefinedColorNames[i]]);
    }
    colors.sort((c1, c2) => {
      if (c1.alpha < c2.alpha)
        return 1;
      if (c1.alpha > c2.alpha)
        return -1;
      if (c1.luminosity < c2.luminosity)
        return 1;
      if (c1.luminosity > c2.luminosity)
        return -1;
      if (c1.saturation < c2.saturation)
        return 1;
      if (c1.saturation > c2.saturation)
        return -1;
      if (c1.hue < c2.hue)
        return 1;
      if (c1.hue > c2.hue)
        return -1;
      return 0;
    });
    let currenTR = null;
    this._prefedDivs = [];
    for (let i = 0; i < colors.length; i++) {
      let c = colors[i];
      if (i % 16 == 0) {
        currenTR = document.createElement("TR");
        predefTable.appendChild(currenTR);
      }
      let td = document.createElement("TD");
      currenTR.appendChild(td);
      let div2 = document.createElement("DIV");
      this._prefedDivs.push(div2);
      div2.style.position = "relative";
      div2.style.width = "100%";
      div2.style.height = Math.round(10 * constants.guiDPIFactor).toString() + "px";
      div2.style.display = "inline-block";
      div2.title = c.name;
      td.appendChild(div2);
      let sampler = new ColorSampler(div2, (c2) => {
        this.sampleWasSelectedCallback(c2);
      });
      sampler.color = c;
    }
    let div = document.createElement("DIV");
    div.style.position = "relative";
    div.style.width = "100%";
    div.style.height = (3 * sampleHeight).toString() + "px";
    div.style.display = "inline-block";
    div.title = "Color preview";
    previewTD.appendChild(div);
    this._preview = new ColorSampler(div, null);
    this._preview.color = initialColor;
    this.selectApropriateTab(initialColor);
  }
  selectApropriateTab(color) {
    if (color.isPredefined) {
      this._tabPredef.active = true;
      this.tabSelected(this._tabPredef);
    } else {
      this._tabPredef.active = false;
      if (color.isRGB) {
        this._tabRGB.active = true;
        this._tabHSL.active = false;
        this.tabSelected(this._tabRGB);
      } else {
        this._tabRGB.active = false;
        this._tabHSL.active = true;
        this.tabSelected(this._tabHSL);
      }
    }
  }
  sampleWasSelectedCallback(color) {
    this._rgb_R_editor.value = color.red;
    this._rgb_G_editor.value = color.green;
    this._rgb_B_editor.value = color.blue;
    this._rgb_T_editor.value = color.alpha;
    this._hsl_H_editor.value = color.hue;
    this._hsl_S_editor.value = color.saturation;
    this._hsl_L_editor.value = color.luminosity;
    this._hsl_T_editor.value = color.alpha;
    this._preview.color = color;
    this._rgb_R_editor.refresh();
    this._rgb_G_editor.refresh();
    this._rgb_B_editor.refresh();
    this._rgb_T_editor.refresh();
    this._hsl_H_editor.refresh();
    this._hsl_S_editor.refresh();
    this._hsl_L_editor.refresh();
    this._hsl_T_editor.refresh();
    this.initColorMemorization(color);
    if (this._colorChangeCallback != null)
      this._colorChangeCallback(color);
  }
  initColorMemorization(color) {
    if (this._memorizeTimer != null)
      clearTimeout(this._memorizeTimer);
    this._memorizeTimer = setTimeout(() => {
      this._memorizeTimer = null;
      _colorEditor.AddColorToHistory(color);
    }, 2e3);
  }
  RgbColorChangeCallBack(src) {
    if (src != this._rgb_R_editor)
      this._rgb_R_editor.refresh();
    if (src != this._rgb_G_editor)
      this._rgb_G_editor.refresh();
    if (src != this._rgb_B_editor)
      this._rgb_B_editor.refresh();
    if (src != this._rgb_T_editor)
      this._rgb_T_editor.refresh();
    let color = YColor.FromArgb(this._rgb_T_editor.value, this._rgb_R_editor.value, this._rgb_G_editor.value, this._rgb_B_editor.value);
    this._preview.color = color;
    this.initColorMemorization(color);
    if (this._colorChangeCallback != null)
      this._colorChangeCallback(color);
  }
  HslColorChangeCallBack(src) {
    if (src != this._hsl_H_editor)
      this._hsl_H_editor.refresh();
    if (src != this._hsl_S_editor)
      this._hsl_S_editor.refresh();
    if (src != this._hsl_L_editor)
      this._hsl_L_editor.refresh();
    if (src != this._hsl_T_editor)
      this._hsl_T_editor.refresh();
    let color = YColor.FromAhsl(this._hsl_T_editor.value, this._hsl_H_editor.value, this._hsl_S_editor.value, this._hsl_L_editor.value);
    this._preview.color = color;
    this.initColorMemorization(color);
    if (this._colorChangeCallback != null)
      this._colorChangeCallback(color);
  }
  set color(color) {
    this._preview.color = color;
    this._hsl_H_editor.value = color.hue;
    this._hsl_S_editor.value = color.saturation;
    this._hsl_L_editor.value = color.luminosity;
    this._hsl_T_editor.value = color.alpha;
    this._rgb_R_editor.value = color.red;
    this._rgb_G_editor.value = color.green;
    this._rgb_B_editor.value = color.blue;
    this._rgb_T_editor.value = color.alpha;
    this._hsl_H_editor.refresh();
    this._hsl_S_editor.refresh();
    this._hsl_L_editor.refresh();
    this._hsl_T_editor.refresh();
    this._rgb_R_editor.refresh();
    this._rgb_G_editor.refresh();
    this._rgb_B_editor.refresh();
    this._rgb_T_editor.refresh();
    this.selectApropriateTab(color);
  }
  AddColorScroll(container, label, colorCallback, changeCallBack, checkerBoardBg, value) {
    let RGB_R_Row = document.createElement("TR");
    let RGB_R_Col1 = document.createElement("TD");
    RGB_R_Col1.innerHTML = "&nbsp;" + label + "&nbsp;";
    let RGB_R_Col2 = document.createElement("TD");
    let RGB_R_Anchor = document.createElement("ANCHOR");
    RGB_R_Col2.appendChild(RGB_R_Anchor);
    let RGB_R_Div = document.createElement("DIV");
    RGB_R_Col2.style.width = "100%";
    RGB_R_Anchor.appendChild(RGB_R_Div);
    let RGB_R_Col3 = document.createElement("TD");
    let RGB_R_Input = document.createElement("INPUT");
    RGB_R_Col3.appendChild(RGB_R_Input);
    RGB_R_Row.appendChild(RGB_R_Col1);
    RGB_R_Row.appendChild(RGB_R_Col2);
    RGB_R_Row.appendChild(RGB_R_Col3);
    container.appendChild(RGB_R_Row);
    return new ColorEditorSroll(RGB_R_Div, RGB_R_Anchor, RGB_R_Input, colorCallback, changeCallBack, checkerBoardBg, value);
  }
  setTabIndex(index) {
    this._firstTabIndex = index;
    index = this._tabRGB.setTabIndex(index);
    index = this._tabHSL.setTabIndex(index);
    index = this._tabPredef.setTabIndex(index);
    if (this._tabRGB.active) {
      index = this._rgb_R_editor.setTabIndex(index);
      index = this._rgb_G_editor.setTabIndex(index);
      index = this._rgb_B_editor.setTabIndex(index);
      index = this._rgb_T_editor.setTabIndex(index);
    } else if (this._tabHSL.active) {
      index = this._hsl_H_editor.setTabIndex(index);
      index = this._hsl_S_editor.setTabIndex(index);
      index = this._hsl_L_editor.setTabIndex(index);
      index = this._hsl_T_editor.setTabIndex(index);
    } else {
      for (let i = 0; i < this._prefedDivs.length; i++) {
        this._prefedDivs[i].tabIndex = index++;
      }
    }
    for (let i = 0; i < this._samples.length; i++) {
      index = this._samples[i].setTabIndex(index);
    }
    return index;
  }
};
colorEditor._colorHistory = colorEditor.defaultColorHistory();
colorEditor._editorsList = [];

// obj/full/configForm_rw.js
var configEditorTab = class {
  constructor(editor, label, fontSize, GUIcoef) {
    this._realTab = false;
    this._div = null;
    this._tabLabel = null;
    this._td = document.createElement("TD");
    if (label != "") {
      this._div = document.createElement("DIV");
      this._div.style.display = "none";
      let sz = Math.round(5 * GUIcoef).toString() + "px";
      this._div.style.padding = sz + " " + sz + " " + sz + " " + sz;
      this._td.style.paddingTop = Math.round(4 * GUIcoef).toString() + "px";
      this._td.style.fontSize = fontSize.toString() + "px";
      this._td.style.paddingBottom = Math.round(2 * GUIcoef).toString() + "px";
      this._td.tabIndex = 0;
      this._td.style.borderLeft = "1px solid " + configForm.inactiveBorderColor;
      this._td.style.borderRight = "1px solid " + configForm.inactiveBorderColor;
      this._td.style.borderTop = "1px solid " + configForm.inactiveBorderColor;
      this._td.style.borderBottom = "1px solid " + configForm.activeBorderColor;
      this._td.style.color = configForm.inactiveColor;
      this._td.style.backgroundColor = configForm.inactiveBackgroundColor;
      this._td.style.borderTopLeftRadius = Math.round(3 * GUIcoef).toString() + "px";
      this._td.style.borderTopRightRadius = Math.round(3 * GUIcoef).toString() + "px";
      this._td.style.paddingLeft = "5px";
      this._td.style.paddingRight = "5px";
      this._realTab = true;
      this._tabLabel = document.createElement("ANCHOR");
      this._tabLabel.innerText = label;
      this._tabLabel.addEventListener("click", () => {
        configForm.tabSelected(this);
      });
      this._tabLabel.addEventListener("keyup", (e) => {
        if (e.key === "Enter" || e.key === " ")
          configForm.tabSelected(this);
      });
      this._tabLabel.style.cursor = "pointer";
      this._td.appendChild(this._tabLabel);
    } else {
      this._td.style.borderBottom = "1px solid " + configForm.activeBorderColor;
      this._td.innerHTML = "<span>&nbsp;</span>";
    }
  }
  setTabIndex(index) {
    this._tabLabel.tabIndex = index++;
    return index;
  }
  set active(value) {
    if (!this._realTab)
      return;
    this._td.style.borderLeftColor = value ? configForm.activeBorderColor : configForm.inactiveBorderColor;
    this._td.style.borderTopColor = value ? configForm.activeBorderColor : configForm.inactiveBorderColor;
    this._td.style.borderRightColor = value ? configForm.activeBorderColor : configForm.inactiveBorderColor;
    this._td.style.borderBottomColor = value ? "rgba(0, 0, 0, 0)" : configForm.activeBorderColor;
    this._td.style.color = value ? configForm.activeColor : configForm.inactiveColor;
    this._td.style.backgroundColor = value ? configForm.activeBackgroundColor : configForm.inactiveBackgroundColor;
    this._div.style.display = value ? "" : "none";
  }
  get tabElement() {
    return this._td;
  }
  get divElement() {
    return this._div;
  }
};
var configForm = class _configForm {
  static get activeBorderColor() {
    return constants.WindowInnerBorderColor;
  }
  static get inactiveBorderColor() {
    return "#b0b0b0";
  }
  static get activeColor() {
    return "black";
  }
  static get inactiveColor() {
    return "grey";
  }
  static get activeBackgroundColor() {
    return constants.WindowInnerBackgroundColor;
  }
  static get inactiveBackgroundColor() {
    return constants.WindowBackgroundColor;
  }
  static async hubStateChanged(source) {
    if (_configForm._Hubtable == null)
      return;
    let srvNotification = source.removable ? "" : " (server)";
    for (let i = 1; i < _configForm._Hubtable.childElementCount; i++) {
      if (_configForm._Hubtable.childNodes[i]["YHUB"] == source) {
        _configForm._Hubtable.childNodes[i].childNodes[2].innerText = await source.ConnectionDescription() + srvNotification;
        switch (await source.ConnectionState()) {
          case 2:
            _configForm._Hubtable.childNodes[i].childNodes[0].innerHTML = ressources.OkIcon((1.2 * _configForm.fontSize).toString(), true, false, false, false, " ");
            break;
          case 3:
            _configForm._Hubtable.childNodes[i].childNodes[0].innerHTML = ressources.FailedIcon((1.2 * _configForm.fontSize).toString(), true, false, false, false, " ");
            break;
          default:
            _configForm._Hubtable.childNodes[i].childNodes[0].innerHTML = ressources.DontKnowIcon((1.2 * _configForm.fontSize).toString(), true, false, false, false, " ");
            break;
        }
      }
    }
  }
  static RefreshUI(h) {
    for (let i = 1; i < _configForm._Hubtable.childElementCount; i++) {
      if (_configForm._Hubtable.childNodes[i]["YHUB"] == h) {
        _configForm._Hubtable.childNodes[i].childNodes[1].innerText = h.toString();
        _configForm._Hubtable.childNodes[i].childNodes[2].innerText = "...";
      }
    }
  }
  static HublineSelected(source) {
    _configForm._selectedHub = null;
    for (let i = 1; i < _configForm._Hubtable.childElementCount; i++) {
      if (_configForm._Hubtable.childNodes[i] == source) {
        _configForm._selectedHub = _configForm._Hubtable.childNodes[i]["YHUB"];
        _configForm._Hubtable.childNodes[i].style.backgroundColor = "#2fa5ff";
        _configForm._Hubtable.childNodes[i].childNodes[0].style.color = "white";
        _configForm._Hubtable.childNodes[i].childNodes[1].style.color = "white";
        _configForm._Hubtable.childNodes[i].childNodes[2].style.color = "white";
      } else {
        _configForm._Hubtable.childNodes[i].style.backgroundColor = "white";
        _configForm._Hubtable.childNodes[i].childNodes[0].style.color = "black";
        _configForm._Hubtable.childNodes[i].childNodes[1].style.color = "black";
        _configForm._Hubtable.childNodes[i].childNodes[2].style.color = "black";
      }
    }
    _configForm._editButton.enabled = _configForm._selectedHub != null;
    _configForm._deleteButton.enabled = _configForm._selectedHub != null;
    this._editButton.showShortcut(_configForm._selectedHub != null);
    this._deleteButton.showShortcut(_configForm._selectedHub != null);
  }
  static newHub() {
    HubEdit.newHub(() => {
      _configForm._window.show();
    });
  }
  static async AddHubToUI(hub) {
    let HubtableTR = document.createElement("TR");
    HubtableTR.style.fontSize = _configForm.fontSize.toString() + "px";
    HubtableTR["YHUB"] = hub;
    HubtableTR.style.backgroundColor = "white";
    HubtableTR.style.cursor = "pointer";
    HubtableTR.tabIndex = 0;
    HubtableTR.addEventListener("keypress", (e) => {
      switch (e.key.toUpperCase()) {
        case "D":
          this._deleteButton.performAction();
          break;
        case "E":
          this._editButton.performAction();
          break;
      }
    });
    HubtableTR.style.outline = "none";
    HubtableTR.addEventListener("click", () => {
      _configForm.HublineSelected(HubtableTR);
    });
    HubtableTR.addEventListener("focusin", () => {
      _configForm.HublineSelected(HubtableTR);
    });
    let HubtableTD = document.createElement("TD");
    switch (await hub.ConnectionState()) {
      case 2:
        HubtableTD.innerHTML = ressources.OkIcon((1.2 * _configForm.fontSize).toString(), true, false, false, false, " ");
        break;
      case 3:
        HubtableTD.innerHTML = ressources.FailedIcon((1.2 * _configForm.fontSize).toString(), true, false, false, false, " ");
        break;
      case 1:
      default:
        HubtableTD.innerHTML = ressources.DontKnowIcon((1.2 * _configForm.fontSize).toString(), true, false, false, false, " ");
    }
    HubtableTD.style.width = (2 * _configForm.fontSize).toString() + "px";
    HubtableTD.style.verticalAlign = "center";
    HubtableTD.style.borderBottom = "1px solid " + _configForm.inactiveBorderColor;
    HubtableTD.style.paddingLeft = "5px";
    HubtableTR.appendChild(HubtableTD);
    HubtableTD = document.createElement("TD");
    HubtableTD.innerText = hub.toString();
    HubtableTD.style.borderBottom = "1px solid " + _configForm.inactiveBorderColor;
    HubtableTD.style.verticalAlign = "center";
    HubtableTD.style.height = (2 * _configForm.fontSize).toString() + "px";
    HubtableTR.appendChild(HubtableTD);
    HubtableTD = document.createElement("TD");
    HubtableTD.style.verticalAlign = "center";
    HubtableTD.style.whiteSpace = "nowrap";
    HubtableTD.innerText = await hub.ConnectionDescription() + (hub.removable ? "" : " (server)");
    HubtableTD.style.borderBottom = "1px solid " + _configForm.inactiveBorderColor;
    HubtableTR.appendChild(HubtableTD);
    _configForm._Hubtable.appendChild(HubtableTR);
  }
  static editSelectedHub() {
    if (_configForm._selectedHub == null)
      return;
    HubEdit.editHub(_configForm._selectedHub, () => {
      _configForm._window.show();
    });
  }
  static deleteSelectedHub() {
    if (_configForm._selectedHub == null)
      return;
    let ExtraMessage = _configForm._selectedHub.removable ? "" : "\n\nThis one is also the one serving the Yocto-Visualization software. If you remove it, you won't be able to save later on.";
    confirm.ask("Do you really want to remove connection " + _configForm._selectedHub.toString() + " ?" + ExtraMessage, () => {
      if (_configForm._selectedHub == null)
        return;
      _configForm._selectedHub.Disconnect().then((r) => {
      });
      for (let i = _configForm._Hubtable.childElementCount - 1; i > 0; i--) {
        if (_configForm._Hubtable.childNodes[i]["YHUB"] == _configForm._selectedHub) {
          _configForm._Hubtable.removeChild(_configForm._Hubtable.childNodes[i]);
        }
      }
      sensorsManager.hubWasremoved(_configForm._selectedHub);
      _configForm._selectedHub = null;
      _configForm._editButton.enabled = false;
      _configForm._deleteButton.enabled = false;
      constants.edited = true;
    }, null, null);
  }
  static hide() {
    if (_configForm._window == null)
      return;
    _configForm._window.visible = false;
  }
  static show() {
    if (_configForm._window == null) {
      _configForm.GUIcoef = constants.generalSizeCoef;
      if (_configForm.REFWIDH * _configForm.GUIcoef > screen.width)
        _configForm.GUIcoef = screen.width / _configForm.REFWIDH;
      if (_configForm.REFHEIGHT * _configForm.GUIcoef > screen.height)
        _configForm.GUIcoef = screen.height / _configForm.REFHEIGHT;
      _configForm.fontSize *= _configForm.GUIcoef / constants.generalSizeCoef;
      let params = new newWindowParam(_configForm.GUIcoef);
      params.positionType = 1;
      params.width = Math.round(_configForm.REFWIDH * this.GUIcoef);
      params.height = Math.round(_configForm.REFHEIGHT * this.GUIcoef);
      params.showContainerBorders = false;
      params.title = "Global configuration";
      _configForm._window = new YWindow(params);
      _configForm._contents = _configForm._window.innerContentDiv;
      _configForm._table = document.createElement("TABLE");
      _configForm._contents.appendChild(_configForm._table);
      _configForm._table.style.position = "absolute";
      _configForm._table.style.left = "0px";
      _configForm._table.style.right = "0px";
      _configForm._table.style.width = "100%";
      _configForm._table.style.height = "100%";
      _configForm._table.style.borderSpacing = "0";
      _configForm._table.style.paddingLeft = (5 * this.GUIcoef).toString() + "px";
      _configForm._table.style.paddingTop = (5 * this.GUIcoef).toString() + "px";
      _configForm._table.style.paddingRight = (5 * this.GUIcoef).toString() + "px";
      _configForm._table.style.borderCollapse = "separate";
      _configForm._tr1 = document.createElement("TR");
      _configForm._tr2 = document.createElement("TR");
      _configForm._tr1.style.height = (2 * _configForm.fontSize).toString() + "px";
      _configForm._tabNetwork = new configEditorTab(_configForm, "Network", _configForm.fontSize, _configForm.GUIcoef);
      _configForm._tabCapture = new configEditorTab(_configForm, "Screen capture", _configForm.fontSize, _configForm.GUIcoef);
      _configForm._tabResources = new configEditorTab(_configForm, "Ressources", _configForm.fontSize, _configForm.GUIcoef);
      _configForm._tabUI = new configEditorTab(_configForm, "User interface", _configForm.fontSize, _configForm.GUIcoef);
      _configForm._tabExport = new configEditorTab(_configForm, "Updates & XML", _configForm.fontSize, _configForm.GUIcoef);
      _configForm._tabStub = new configEditorTab(_configForm, "", _configForm.fontSize, _configForm.GUIcoef);
      this._tabPanelContents = document.createElement("TD");
      this._tabPanelContents.colSpan = 6;
      this._tabPanelContents.style.borderLeft = "1px solid " + this.activeBorderColor;
      this._tabPanelContents.style.borderRight = "1px solid " + this.activeBorderColor;
      this._tabPanelContents.style.borderBottom = "1px solid " + this.activeBorderColor;
      this._tabPanelContents.style.backgroundColor = this.activeBackgroundColor;
      _configForm._tr1.appendChild(this._tabNetwork.tabElement);
      _configForm._tr1.appendChild(this._tabCapture.tabElement);
      _configForm._tr1.appendChild(this._tabResources.tabElement);
      _configForm._tr1.appendChild(this._tabUI.tabElement);
      _configForm._tr1.appendChild(this._tabExport.tabElement);
      _configForm._tr1.appendChild(this._tabStub.tabElement);
      _configForm._tr2.appendChild(this._tabPanelContents);
      _configForm._tr2.childNodes[0].style.verticalAlign = "top";
      _configForm._table.appendChild(this._tr1);
      _configForm._table.appendChild(this._tr2);
      let p = document.createElement("P");
      p.style.textAlign = "justify";
      p.style.fontSize = _configForm.fontSize.toString() + "px";
      p.style.paddingTop = "0px";
      p.style.marginTop = Math.round(3 * this.GUIcoef).toString() + "px";
      p.innerText = "Enter the list of VirtualHub or YoctoHub this page can connect to";
      this._tabNetwork.divElement.appendChild(p);
      _configForm._Hubtable = document.createElement("TABLE");
      _configForm._Hubtable.style.position = "absolute";
      _configForm._Hubtable.style.display = "block";
      _configForm._Hubtable.style.left = Math.round(20 * this.GUIcoef).toString() + "px";
      _configForm._Hubtable.style.right = Math.round(20 * this.GUIcoef).toString() + "px";
      _configForm._Hubtable.style.tableLayout = "auto";
      _configForm._Hubtable.style.top = Math.round(80 * this.GUIcoef).toString() + "px";
      _configForm._Hubtable.style.bottom = Math.round(40 * this.GUIcoef).toString() + "px";
      _configForm._Hubtable.style.borderCollapse = "colapse";
      _configForm._Hubtable.style.borderSpacing = "0px";
      _configForm._Hubtable.style.border = "1px solid " + _configForm.activeBorderColor;
      let HubtableTR = document.createElement("TR");
      HubtableTR.style.fontSize = _configForm.fontSize.toString() + "px";
      let HubtableTH = document.createElement("TH");
      HubtableTH.colSpan = 2;
      HubtableTH.innerText = "Address";
      HubtableTH.style.borderBottom = "1px solid " + _configForm.activeBorderColor;
      HubtableTH.style.width = Math.round(400 * this.GUIcoef).toString() + "px";
      HubtableTR.appendChild(HubtableTH);
      HubtableTH = document.createElement("TH");
      HubtableTH.innerText = "Status";
      HubtableTH.style.width = "40%";
      HubtableTH.style.borderBottom = "1px solid " + _configForm.activeBorderColor;
      HubtableTH.style.borderLeft = "1px solid " + _configForm.activeBorderColor;
      HubtableTR.appendChild(HubtableTH);
      _configForm._Hubtable.appendChild(HubtableTR);
      let hubList = sensorsManager.hubList;
      for (let i = 0; i < hubList.length; i++) {
        _configForm.AddHubToUI(hubList[i]);
      }
      let div = document.createElement("DIV");
      div.style.position = "absolute";
      div.style.bottom = "0px";
      div.style.right = Math.round(20 * _configForm.GUIcoef).toString() + "px";
      div.style.height = Math.round(30 * _configForm.GUIcoef).toString() + "px";
      div.style.textAlign = "right";
      div.style.verticalAlign = "center";
      _configForm._newButton = new button("New", () => {
        _configForm._window.hide();
        _configForm.newHub();
      }, _configForm.GUIcoef);
      div.appendChild(_configForm._newButton.Element);
      _configForm._editButton = new button("Edit", () => {
        _configForm._window.hide();
        _configForm.editSelectedHub();
      }, _configForm.GUIcoef);
      _configForm._editButton.enabled = false;
      div.appendChild(_configForm._editButton.Element);
      _configForm._deleteButton = new button("Delete", () => {
        _configForm.deleteSelectedHub();
      }, _configForm.GUIcoef);
      _configForm._deleteButton.enabled = false;
      div.appendChild(_configForm._deleteButton.Element);
      this._tabNetwork.divElement.appendChild(div);
      this._tabNetwork.divElement.appendChild(_configForm._Hubtable);
      p = document.createElement("P");
      p.innerHTML = "Widgets content can be captured at anytime thought the <i>Snapshop</i> option available in right-click contextual menu";
      p.style.textAlign = "justify";
      p.style.fontSize = _configForm.fontSize.toString() + "px";
      this._tabCapture.divElement.appendChild(p);
      let tableSize = document.createElement("TABLE");
      tableSize.style.fontSize = _configForm.fontSize.toString() + "px";
      let row = document.createElement("TR");
      let td = document.createElement("TD");
      td.style.fontSize = _configForm.fontSize.toString() + "px";
      td.innerText = "ImageType";
      row.appendChild(td);
      td = document.createElement("TD");
      td.style.fontSize = _configForm.fontSize.toString() + "px";
      td.style.verticalAlign = "center";
      _configForm.inputPNG = document.createElement("INPUT");
      _configForm.inputSVG = document.createElement("INPUT");
      _configForm.inputPNG.checked = constants.captureType == YDataRenderer.CaptureType.PNG;
      _configForm.inputPNG.style.display = "inline";
      _configForm.inputPNG.type = "checkbox";
      _configForm.inputPNG.style.transform = "scale(" + this.GUIcoef.toString() + ")";
      _configForm.inputPNG.style.marginRight = Math.round(5 * this.GUIcoef).toString() + "px";
      _configForm.inputPNG.style.marginLeft = Math.round(5 * this.GUIcoef).toString() + "px";
      _configForm.inputPNG.addEventListener("change", () => {
        _configForm.captureFormatChange(_configForm.inputPNG);
      });
      td.append(_configForm.inputPNG);
      let span;
      span = document.createElement("SPAN");
      span.innerText = YDataRenderer.CaptureType.PNG.description;
      td.append(span);
      _configForm.inputSVG = document.createElement("INPUT");
      _configForm.inputSVG.checked = constants.captureType == YDataRenderer.CaptureType.SVG;
      _configForm.inputSVG.style.display = "inline";
      _configForm.inputSVG.type = "checkbox";
      _configForm.inputSVG.style.transform = "scale(" + this.GUIcoef.toString() + ")";
      _configForm.inputSVG.style.marginRight = Math.round(5 * this.GUIcoef).toString() + "px";
      _configForm.inputSVG.style.marginLeft = Math.round(5 * this.GUIcoef).toString() + "px";
      _configForm.inputSVG.addEventListener("change", () => {
        _configForm.captureFormatChange(_configForm.inputSVG);
      });
      td.append(_configForm.inputSVG);
      span = document.createElement("SPAN");
      span.innerText = YDataRenderer.CaptureType.SVG.description;
      td.append(span);
      row.appendChild(td);
      tableSize.appendChild(row);
      row = document.createElement("TR");
      td = document.createElement("TD");
      td.style.fontSize = _configForm.fontSize.toString() + "px";
      td.innerText = "Resolution:";
      row.appendChild(td);
      td = document.createElement("TD");
      td.style.fontSize = _configForm.fontSize.toString() + "px";
      _configForm.inputResolution = document.createElement("INPUT");
      _configForm.inputResolution.style.fontFamily = constants.generalFontFamily;
      _configForm.inputResolution.style.fontSize = constants.generalFontSize.toString() + "px";
      _configForm.inputResolution.style.border = "1px solid grey";
      _configForm.inputResolution.type = "number";
      _configForm.inputResolution.style.textAlign = "right";
      _configForm.inputResolution.style.marginRight = "5px";
      _configForm.inputResolution.style.width = "60px";
      _configForm.inputResolution.value = constants.captureDPI.toString();
      _configForm.inputResolution.style.display = "inline";
      new InputFieldManager(_configForm.inputResolution, 6, false, Number.NaN, Number.NaN, (sender, refreshInput) => {
        _configForm.captureDPIChange(_configForm.inputResolution);
      });
      td.append(_configForm.inputResolution);
      span = document.createElement("SPAN");
      span.innerText = "DPI";
      td.append(span);
      row.appendChild(td);
      tableSize.appendChild(row);
      row = document.createElement("TR");
      td = document.createElement("TD");
      td.style.fontSize = _configForm.fontSize.toString() + "px";
      td.innerText = "Size:";
      td.style.verticalAlign = "top";
      row.appendChild(td);
      td = document.createElement("TD");
      td.style.fontSize = _configForm.fontSize.toString() + "px";
      _configForm.inputSizeSelect = document.createElement("SELECT");
      _configForm.inputSizeSelect.style.border = "1px solid grey";
      _configForm.inputSizeSelect.style.fontFamily = constants.generalFontFamily;
      _configForm.inputSizeSelect.style.fontSize = constants.generalFontSize.toString() + "px";
      let sizingOptions = YDataRenderer.CaptureFormats.Keep.sibblings;
      for (let i = 0; i < sizingOptions.length; i++) {
        let option = document.createElement("OPTION");
        option.text = sizingOptions[i].description;
        option.value = sizingOptions[i].toString;
        _configForm.inputSizeSelect.add(option, null);
      }
      _configForm.inputSizeSelect.value = constants.captureSizePolicy.toString;
      _configForm.inputSizeSelect.addEventListener("change", () => {
        _configForm.captureSizeSelectChange(_configForm.inputSizeSelect);
      });
      td.append(_configForm.inputSizeSelect);
      row.appendChild(td);
      tableSize.appendChild(row);
      let subtable = document.createElement("TABLE");
      _configForm.captureWidthTR = document.createElement("TR");
      let subTD = document.createElement("TD");
      subTD.style.fontSize = _configForm.fontSize.toString() + "px";
      subTD.innerText = "Width:";
      _configForm.captureWidthTR.appendChild(subTD);
      subTD = document.createElement("TD");
      subTD.style.fontSize = _configForm.fontSize.toString() + "px";
      _configForm.inputCaptureWidth = document.createElement("INPUT");
      _configForm.inputCaptureWidth.style.border = "1px solid grey";
      _configForm.inputCaptureWidth.style.fontFamily = constants.generalFontFamily;
      _configForm.inputCaptureWidth.style.fontSize = constants.generalFontSize.toString() + "px";
      _configForm.inputCaptureWidth.type = "number";
      _configForm.inputCaptureWidth.style.textAlign = "right";
      _configForm.inputCaptureWidth.style.marginRight = "5px";
      _configForm.inputCaptureWidth.style.width = "60px";
      _configForm.inputCaptureWidth.value = constants.captureWidth.toString();
      _configForm.inputCaptureWidth.style.display = "inline";
      new InputFieldManager(_configForm.inputCaptureWidth, 3, false, Number.NaN, Number.NaN, (sender, refreshInput) => {
        _configForm.captureWidthChange(_configForm.inputCaptureWidth);
      });
      subTD.append(_configForm.inputCaptureWidth);
      _configForm.inputCaptureWidthInfo = document.createElement("SPAN");
      _configForm.inputCaptureWidthInfo.innerText = "pixels";
      subTD.append(_configForm.inputCaptureWidthInfo);
      _configForm.captureWidthTR.appendChild(subTD);
      subtable.appendChild(_configForm.captureWidthTR);
      _configForm.captureHeightTR = document.createElement("TR");
      subTD = document.createElement("TD");
      subTD.style.fontSize = _configForm.fontSize.toString() + "px";
      subTD.innerText = "Height:";
      _configForm.captureHeightTR.appendChild(subTD);
      subTD = document.createElement("TD");
      subTD.style.fontSize = _configForm.fontSize.toString() + "px";
      _configForm.inputCaptureHeight = document.createElement("INPUT");
      _configForm.inputCaptureHeight.style.border = "1px solid grey";
      _configForm.inputCaptureHeight.style.fontFamily = constants.generalFontFamily;
      _configForm.inputCaptureHeight.style.fontSize = constants.generalFontSize.toString() + "px";
      _configForm.inputCaptureHeight.type = "number";
      _configForm.inputCaptureHeight.style.textAlign = "right";
      _configForm.inputCaptureHeight.style.marginRight = "5px";
      _configForm.inputCaptureHeight.style.width = "60px";
      _configForm.inputCaptureHeight.value = constants.captureHeight.toString();
      _configForm.inputCaptureHeight.style.display = "inline";
      new InputFieldManager(_configForm.inputCaptureHeight, 3, false, Number.NaN, Number.NaN, (sender, refreshInput) => {
        _configForm.captureHeightChange(_configForm.inputCaptureHeight);
      });
      subTD.append(_configForm.inputCaptureHeight);
      _configForm.inputCaptureHeightInfo = document.createElement("SPAN");
      _configForm.inputCaptureHeightInfo.innerText = "pixels";
      subTD.append(_configForm.inputCaptureHeightInfo);
      _configForm.captureHeightTR.appendChild(subTD);
      subtable.appendChild(_configForm.captureHeightTR);
      td.appendChild(subtable);
      _configForm._tabCapture.divElement.appendChild(tableSize);
      let tableRessources = document.createElement("TABLE");
      row = document.createElement("TR");
      td = document.createElement("TD");
      td.style.fontSize = _configForm.fontSize.toString() + "px";
      td.innerText = "If you plan to use YoctoVisualization continuously for an extended period of time (i.e. several weeks),  or if you are running it on a computer with limited resources, you may want to limit the application memory consumption.";
      td.colSpan = 2;
      td.style.textAlign = "justify";
      row.appendChild(td);
      tableRessources.appendChild(row);
      row = document.createElement("TR");
      td = document.createElement("TD");
      td.style.fontSize = _configForm.fontSize.toString() + "px";
      td.innerText = "Max count of sensors data records:";
      row.appendChild(td);
      td = document.createElement("TD");
      td.style.fontSize = _configForm.fontSize.toString() + "px";
      let maxSensorRecs = document.createElement("INPUT");
      maxSensorRecs.style.border = "1px solid grey";
      maxSensorRecs.style.fontFamily = constants.generalFontFamily;
      maxSensorRecs.style.fontSize = constants.generalFontSize.toString() + "px";
      maxSensorRecs.type = "number";
      maxSensorRecs.style.textAlign = "right";
      maxSensorRecs.style.marginRight = "5px";
      maxSensorRecs.style.marginLeft = "5px";
      maxSensorRecs.style.width = "60px";
      maxSensorRecs.value = constants.maxDataRecordsPerSensor.toString();
      maxSensorRecs.style.display = "inline";
      new InputFieldManager(maxSensorRecs, 2, false, Number.NaN, Number.NaN, (sender, refreshInput) => {
        _configForm.maxSensorRecsChange(maxSensorRecs);
      });
      td.append(maxSensorRecs);
      span = document.createElement("SPAN");
      span.innerText = "(0 = unlimited)";
      td.append(span);
      row.appendChild(td);
      tableRessources.appendChild(row);
      row = document.createElement("TR");
      td = document.createElement("TD");
      td.style.fontSize = _configForm.fontSize.toString() + "px";
      td.innerText = "Max count of graph series data points:";
      row.appendChild(td);
      td = document.createElement("TD");
      td.style.fontSize = _configForm.fontSize.toString() + "px";
      let maxSeriesRecs = document.createElement("INPUT");
      maxSeriesRecs.style.border = "1px solid grey";
      maxSeriesRecs.style.fontFamily = constants.generalFontFamily;
      maxSeriesRecs.style.fontSize = constants.generalFontSize.toString() + "px";
      maxSeriesRecs.type = "number";
      maxSeriesRecs.style.textAlign = "right";
      maxSeriesRecs.style.marginRight = "5px";
      maxSeriesRecs.style.marginLeft = "5px";
      maxSeriesRecs.style.width = "60px";
      maxSeriesRecs.value = constants.maxPointsPerGraphSerie.toString();
      maxSeriesRecs.style.display = "inline";
      new InputFieldManager(maxSeriesRecs, 2, false, Number.NaN, Number.NaN, (sender, refreshInput) => {
        _configForm.maxSeriesRecsChange(maxSeriesRecs);
      });
      td.append(maxSeriesRecs);
      span = document.createElement("SPAN");
      span.innerText = "(0 = unlimited)";
      td.append(span);
      row.appendChild(td);
      tableRessources.appendChild(row);
      row = document.createElement("TR");
      td = document.createElement("TD");
      td.style.fontSize = _configForm.fontSize.toString() + "px";
      td.innerText = "\nYocto-Visualization automatically loads datalogger contents for all connected devices.  If you are using networked devices featuring  billable data transfers (GSM) you may want to limit or even disable that feature.";
      td.colSpan = 2;
      td.style.textAlign = "justify";
      row.appendChild(td);
      tableRessources.appendChild(row);
      row = document.createElement("TR");
      td = document.createElement("TD");
      td.style.fontSize = _configForm.fontSize.toString() + "px";
      td.innerText = "Max data points/series loaded from dataloggers:";
      row.appendChild(td);
      td = document.createElement("TD");
      td.style.fontSize = _configForm.fontSize.toString() + "px";
      let maxDataLogRecs = document.createElement("INPUT");
      maxDataLogRecs.style.border = "1px solid grey";
      maxDataLogRecs.style.fontFamily = constants.generalFontFamily;
      maxDataLogRecs.style.fontSize = constants.generalFontSize.toString() + "px";
      maxDataLogRecs.type = "number";
      maxDataLogRecs.style.textAlign = "right";
      maxDataLogRecs.style.marginRight = "5px";
      maxDataLogRecs.style.marginLeft = "5px";
      maxDataLogRecs.style.width = "60px";
      maxDataLogRecs.value = constants.maxPointsPerDataloggerSerie.toString();
      maxDataLogRecs.style.display = "inline";
      new InputFieldManager(maxDataLogRecs, 1, false, -1, Number.NaN, (sender, refreshInput) => {
        _configForm.maxDataLogRecsChange(maxDataLogRecs);
      });
      td.append(maxDataLogRecs);
      span = document.createElement("SPAN");
      span.innerText = "(0 = unlimited,\n-1 = disabled)";
      td.append(span);
      row.appendChild(td);
      tableRessources.appendChild(row);
      row = document.createElement("TR");
      td = document.createElement("TD");
      td.style.fontSize = _configForm.fontSize.toString() + "px";
      td.innerText = "After a  limit increase, you'll have to restart the application to get your old data back.";
      td.colSpan = 2;
      td.style.textAlign = "justify";
      row.appendChild(td);
      tableRessources.appendChild(row);
      _configForm._tabResources.divElement.appendChild(tableRessources);
      p = document.createElement("P");
      p.style.fontSize = _configForm.fontSize.toString() + "px";
      p.innerText = "You can alter user interface behavior according to your hardware capabilities.";
      this._tabUI.divElement.appendChild(p);
      let checkbox1 = document.createElement("INPUT");
      checkbox1.style.fontFamily = constants.generalFontFamily;
      checkbox1.style.fontSize = constants.generalFontSize.toString() + "px";
      checkbox1.style.display = "inline";
      checkbox1.type = "checkbox";
      checkbox1.style.transform = "scale(" + this.GUIcoef.toString() + ")";
      checkbox1.style.marginRight = Math.round(5 * this.GUIcoef).toString() + "px";
      checkbox1.checked = constants.dbleClickBringsUpContextMenu;
      checkbox1.addEventListener("change", () => {
        _configForm.dbleClickBringsUpContextMenuChange(checkbox1);
      });
      this._tabUI.divElement.appendChild(checkbox1);
      span = document.createElement("SPAN");
      span.style.fontSize = _configForm.fontSize.toString() + "px";
      span.innerText = "Double click/tap  brings up context menu\n";
      this._tabUI.divElement.appendChild(span);
      let checkbox2 = document.createElement("INPUT");
      checkbox2.style.display = "inline";
      checkbox2.type = "checkbox";
      checkbox2.style.transform = "scale(" + this.GUIcoef.toString() + ")";
      checkbox2.style.marginRight = Math.round(5 * this.GUIcoef).toString() + "px";
      checkbox2.checked = YGraph.verticalDragZoomEnabled;
      checkbox2.addEventListener("change", () => {
        _configForm.verticalDragZoomChange(checkbox2);
      });
      this._tabUI.divElement.appendChild(checkbox2);
      span = document.createElement("SPAN");
      span.style.fontSize = _configForm.fontSize.toString() + "px";
      span.innerText = "Graphs zoom can be driven by vertical drag\n";
      this._tabUI.divElement.appendChild(span);
      p = document.createElement("P");
      p.style.fontSize = _configForm.fontSize.toString() + "px";
      p.innerText = "Yocto-Visualization tries to ajust UI size to screen resolution the best it can through a DPI based zoom factor. Unfortunately not all devices can properly report their screen resolution. That's why you can manually override that factor.";
      this._tabUI.divElement.appendChild(p);
      let DPIoverride = document.createElement("INPUT");
      let checkbox3 = document.createElement("INPUT");
      checkbox3.style.display = "inline";
      checkbox3.type = "checkbox";
      checkbox3.style.transform = "scale(" + this.GUIcoef.toString() + ")";
      checkbox3.style.marginRight = Math.round(5 * this.GUIcoef).toString() + "px";
      checkbox3.checked = constants.guiDPIFactorIsOverriden;
      checkbox3.addEventListener("change", () => {
        _configForm.DPIoverrideChange(checkbox3, DPIoverride);
      });
      this._tabUI.divElement.appendChild(checkbox3);
      span = document.createElement("SPAN");
      span.style.fontSize = _configForm.fontSize.toString() + "px";
      span.innerText = "Override zoom factor to ";
      this._tabUI.divElement.appendChild(span);
      DPIoverride.style.border = "1px solid grey";
      DPIoverride.style.fontFamily = constants.generalFontFamily;
      DPIoverride.style.fontSize = constants.generalFontSize.toString() + "px";
      DPIoverride.disabled = !constants.guiDPIFactorIsOverriden;
      DPIoverride.type = "number";
      DPIoverride.style.textAlign = "right";
      DPIoverride.style.marginRight = "5px";
      DPIoverride.style.marginLeft = "5px";
      DPIoverride.style.width = "60px";
      DPIoverride.value = constants.guiDPIFactorOverrideValue.toString();
      DPIoverride.style.display = "inline";
      new InputFieldManager(DPIoverride, 5, false, Number.NaN, Number.NaN, (sender, refreshInput) => {
        _configForm.DPIoverrideChange(checkbox3, DPIoverride);
      });
      this._tabUI.divElement.appendChild(DPIoverride);
      p = document.createElement("P");
      p.style.fontSize = _configForm.fontSize.toString() + "px";
      p.innerText = "This setting is stored in your browser cookies. So it is specific to this device, browser and server.You will have to reload this page for this setting to take effect";
      this._tabUI.divElement.appendChild(p);
      p = document.createElement("P");
      p.style.fontSize = _configForm.fontSize.toString() + "px";
      p.style.textAlign = "justify";
      p.innerText = "As long as your web browser can reach www.yoctopuce.com, the read/write edition of Yocto-Visualization (for web) can automatically check for new version. If you find this feature anoying, feel free to disable it. ";
      this._tabExport.divElement.appendChild(p);
      let checkbox4 = document.createElement("INPUT");
      checkbox4.style.display = "inline";
      checkbox4.type = "checkbox";
      checkbox4.style.transform = "scale(" + this.GUIcoef.toString() + ")";
      checkbox4.style.marginLeft = Math.round(25 * this.GUIcoef).toString() + "px";
      checkbox4.checked = constants.mustCheckForUpdate;
      checkbox4.addEventListener("change", () => {
        _configForm.mustCheckForUpdateChange(checkbox4);
      });
      this._tabExport.divElement.appendChild(checkbox4);
      span = document.createElement("SPAN");
      span.style.fontSize = _configForm.fontSize.toString() + "px";
      span.innerText = "Automatically check for updates";
      let a2 = document.createElement("A");
      a2.innerText = "Check now";
      a2.style.paddingLeft = "25px";
      a2.style.cursor = "pointer";
      a2.style.color = "#0000EE";
      a2.style.textDecoration = "underline";
      a2.addEventListener("click", () => {
        YWebPage.CheckForNewVersion(true);
      });
      span.appendChild(a2);
      this._tabExport.divElement.appendChild(span);
      p = document.createElement("P");
      p.style.fontSize = _configForm.fontSize.toString() + "px";
      p.style.textAlign = "justify";
      p.innerText = "Yocto-Visualization (for web) stores its configuration in a XML file. This file can be used to create a static web page running Yocto-Visualization (for web) or it can be used in the Yocto-Visualization (for web) installer to create a pre-configured install. Also, it is mostly compatible with the native version of Yocto-Visualization: you can use it instead of the original config.xml file. Just click on the link below to export/download your current configuration.";
      this._tabExport.divElement.appendChild(p);
      p = document.createElement("P");
      p.style.fontSize = _configForm.fontSize.toString() + "px";
      p.style.textAlign = "right";
      let a = document.createElement("A");
      a.innerText = "Export current configuration";
      a.style.cursor = "pointer";
      a.style.color = "#0000EE";
      a.style.textDecoration = "underline";
      a.addEventListener("click", () => {
        _configForm.downloadCurrentConfig();
      });
      p.appendChild(a);
      this._tabExport.divElement.appendChild(p);
      _configForm._tabPanelContents.appendChild(this._tabNetwork.divElement);
      _configForm._tabPanelContents.appendChild(this._tabCapture.divElement);
      _configForm._tabPanelContents.appendChild(this._tabResources.divElement);
      _configForm._tabPanelContents.appendChild(this._tabUI.divElement);
      _configForm._tabPanelContents.appendChild(this._tabExport.divElement);
      _configForm.tabSelected(this._tabNetwork);
      _configForm.refreshSizeParams();
    }
    _configForm._window.show();
  }
  static DPIoverrideChange(checkbox, input) {
    let value = parseFloat(input.value);
    input.disabled = !checkbox.checked;
    if (checkbox.checked && value > 0) {
      constants.overrideGuiDPIFactor(true, value);
    } else {
      constants.overrideGuiDPIFactor(false);
    }
  }
  static hubWasAdded(hub) {
    if (sensorsManager.newHubCreated(hub)) {
      _configForm.AddHubToUI(hub);
      constants.edited = true;
      hub.Connect().then((r) => {
      });
    }
  }
  static hubGotEdited(hub) {
    _configForm.RefreshUI(hub);
    constants.edited = true;
    hub.Disconnect().then((r) => {
      YAPI.Sleep(1);
      hub.Connect();
    });
  }
  static dbleClickBringsUpContextMenuChange(source) {
    let prev = constants.dbleClickBringsUpContextMenu;
    constants.dbleClickBringsUpContextMenu = source.checked;
    if (prev != constants.dbleClickBringsUpContextMenu)
      constants.edited = true;
  }
  static verticalDragZoomChange(source) {
    let prev = YGraph.verticalDragZoomEnabled;
    YGraph.verticalDragZoomEnabled = source.checked;
    if (prev != YGraph.verticalDragZoomEnabled)
      constants.edited = true;
  }
  static mustCheckForUpdateChange(source) {
    let prev = constants.mustCheckForUpdate;
    constants.mustCheckForUpdate = source.checked;
    if (prev != constants.mustCheckForUpdate)
      constants.edited = true;
  }
  static maxDataLogRecsChange(source) {
    let value = parseInt(source.value);
    if (value != constants.maxPointsPerDataloggerSerie || value != CustomYSensor.MaxLoggerRecords) {
      constants.maxPointsPerDataloggerSerie = value;
      CustomYSensor.MaxLoggerRecords = value;
      constants.edited = true;
    }
  }
  static maxSeriesRecsChange(source) {
    let value = parseInt(source.value);
    if (value != constants.maxPointsPerGraphSerie || value != DataSerie.MaxPointsPerSeries) {
      constants.maxPointsPerGraphSerie = value;
      DataSerie.MaxPointsPerSeries = value;
      constants.edited = true;
    }
  }
  static maxSensorRecsChange(source) {
    let value = parseInt(source.value);
    if (value != constants.maxDataRecordsPerSensor || value != CustomYSensor.MaxDataRecords) {
      constants.maxDataRecordsPerSensor = value;
      CustomYSensor.MaxDataRecords = value;
      constants.edited = true;
    }
  }
  static captureDPIChange(source) {
    let prev = constants.captureDPI;
    constants.captureDPI = parseInt(source.value);
    if (constants.captureDPI != prev)
      constants.edited = true;
    _configForm.refreshSizeParams();
  }
  static captureWidthChange(source) {
    let prev = constants.captureWidth;
    constants.captureWidth = parseInt(source.value);
    if (constants.captureWidth != prev)
      constants.edited = true;
    _configForm.refreshSizeParams();
  }
  static captureHeightChange(source) {
    let prev = constants.captureHeight;
    constants.captureHeight = parseInt(source.value);
    if (constants.captureHeight != prev)
      constants.edited = true;
    _configForm.refreshSizeParams();
  }
  static captureSizeSelectChange(source) {
    let prev = constants.captureSizePolicy;
    constants.captureSizePolicy = YDataRenderer.CaptureFormats.fromString(YDataRenderer.CaptureFormats, source.value);
    if (constants.captureSizePolicy != prev)
      constants.edited = true;
    _configForm.refreshSizeParams();
  }
  static refreshSizeParams() {
    let value = YDataRenderer.CaptureFormats.fromString(YDataRenderer.CaptureFormats, _configForm.inputSizeSelect.value);
    if (value == YDataRenderer.CaptureFormats.Keep) {
      _configForm.captureWidthTR.style.display = "none";
      _configForm.captureHeightTR.style.display = "none";
    } else if (value == YDataRenderer.CaptureFormats.FixedWidth) {
      _configForm.captureWidthTR.style.display = "";
      _configForm.captureHeightTR.style.display = "none";
    } else if (value == YDataRenderer.CaptureFormats.FixedHeight) {
      _configForm.captureWidthTR.style.display = "none";
      _configForm.captureHeightTR.style.display = "";
    }
    if (value == YDataRenderer.CaptureFormats.Fixed) {
      _configForm.captureWidthTR.style.display = "";
      _configForm.captureHeightTR.style.display = "";
    }
    let sw = 25.4 * parseInt(_configForm.inputCaptureWidth.value) / parseInt(_configForm.inputResolution.value);
    _configForm.inputCaptureWidthInfo.innerText = "Pixels  (" + sw.toFixed(1) + "mm)";
    let sh = 25.4 * parseInt(_configForm.inputCaptureHeight.value) / parseInt(_configForm.inputResolution.value);
    _configForm.inputCaptureHeightInfo.innerText = "Pixels  (" + sh.toFixed(1) + "mm)";
  }
  static downloadCurrentConfig() {
    let element = document.createElement("a");
    let data = "data:text/xml;base64," + btoa(YWebPage.get_XmlData());
    element.setAttribute("href", data);
    element.setAttribute("download", "config.xml");
    element.style.display = "none";
    document.body.appendChild(element);
    element.click();
    document.body.removeChild(element);
  }
  static captureFormatChange(source) {
    if (source == _configForm.inputPNG)
      _configForm.inputSVG.checked = !source.checked;
    if (source == _configForm.inputSVG)
      _configForm.inputPNG.checked = !source.checked;
    let prev = constants.captureType;
    constants.captureType = _configForm.inputPNG.checked ? YDataRenderer.CaptureType.PNG : YDataRenderer.CaptureType.SVG;
    if (constants.captureType != prev)
      constants.edited = true;
  }
  static tabSelected(source) {
    this._tabNetwork.active = source == this._tabNetwork;
    this._tabCapture.active = source == this._tabCapture;
    this._tabResources.active = source == this._tabResources;
    this._tabUI.active = source == this._tabUI;
    this._tabExport.active = source == this._tabExport;
  }
};
configForm.GUIcoef = 1;
configForm.REFWIDH = 520;
configForm.REFHEIGHT = 300;
configForm.fontSize = constants.generalFontSize;

// obj/full/HubEdit_rw.js
var HubEdit = class _HubEdit {
  static get activeBorderColor() {
    return constants.WindowInnerBorderColor;
  }
  static get inactiveBorderColor() {
    return "#b0b0b0";
  }
  static get activeColor() {
    return "black";
  }
  static get inactiveColor() {
    return "grey";
  }
  static get activeBackgroundColor() {
    return constants.WindowInnerBackgroundColor;
  }
  static get inactiveBackgroundColor() {
    return constants.WindowBackgroundColor;
  }
  static newHub(whenDone) {
    _HubEdit._currenthub = new Hub(2, "ws", "", "", true, "", "", "");
    _HubEdit.show(_HubEdit._currenthub);
    _HubEdit._window.title = "New Connection";
    _HubEdit._thisIsEditing = false;
    _HubEdit._whenDone = whenDone;
  }
  static editHub(hub, whenDone) {
    _HubEdit._currenthub = hub;
    _HubEdit.show(_HubEdit._currenthub);
    _HubEdit._window.title = "Edit Connection";
    _HubEdit._thisIsEditing = true;
    _HubEdit._whenDone = whenDone;
  }
  static show(hub) {
    if (_HubEdit._window == null) {
      _HubEdit._okButton = new button("Ok", () => {
        _HubEdit.okClicked();
      });
      _HubEdit._cancelButton = new button("Cancel", () => {
        _HubEdit.hide();
      });
      let params = new newWindowParam();
      params.positionType = 1;
      params.width = Math.round(450 * constants.generalSizeCoef);
      params.height = Math.round(280 * constants.generalSizeCoef);
      params.isModal = true;
      params.closeIcon = false;
      params.title = "...";
      params.buttons.push(_HubEdit._okButton);
      params.buttons.push(_HubEdit._cancelButton);
      _HubEdit._window = new YWindow(params);
      _HubEdit._contents = _HubEdit._window.innerContentDiv;
      let p = document.createElement("P");
      p.style.paddingTop = "0px";
      p.style.marginTop = Math.round(3 * constants.generalSizeCoef).toString() + "px";
      p.style.lineHeight = Math.round(12 * constants.generalSizeCoef).toString() + "px";
      p.innerText = "Enter the hub connection parameter, The only mandatory parameter is the address, just leave the other fields empty if you want to use default values";
      p.style.textAlign = "justify";
      _HubEdit._contents.appendChild(p);
      p.appendChild(document.createElement("BR"));
      p.appendChild(document.createElement("BR"));
      let span = document.createElement("SPAN");
      span.innerText = "Protocol:";
      span.style.marginLeft = "20px";
      p.appendChild(span);
      _HubEdit._protocolSelect = document.createElement("SELECT");
      _HubEdit._protocolSelect.style.border = "1px solid grey";
      _HubEdit._protocolSelect.style.fontFamily = constants.generalFontFamily;
      _HubEdit._protocolSelect.style.fontSize = constants.generalFontSize.toString() + "px";
      let httpOption = document.createElement("OPTION");
      httpOption.text = "http";
      httpOption.value = "http";
      _HubEdit._protocolSelect.appendChild(httpOption);
      let httpsOption = document.createElement("OPTION");
      httpsOption.text = "https";
      httpsOption.value = "https";
      _HubEdit._protocolSelect.appendChild(httpsOption);
      let wsOption = document.createElement("OPTION");
      wsOption.text = "ws";
      wsOption.value = "ws";
      _HubEdit._protocolSelect.appendChild(wsOption);
      let wssOption = document.createElement("OPTION");
      wssOption.text = "wss";
      wssOption.value = "wss";
      _HubEdit._protocolSelect.appendChild(wssOption);
      p.appendChild(_HubEdit._protocolSelect);
      span = document.createElement("SPAN");
      span.style.marginLeft = "20px";
      span.innerText = "Address:";
      p.appendChild(span);
      _HubEdit._addressInput = document.createElement("INPUT");
      _HubEdit._addressInput.style.border = "1px solid grey";
      _HubEdit._addressInput.style.fontFamily = constants.generalFontFamily;
      _HubEdit._addressInput.style.fontSize = constants.generalFontSize.toString() + "px";
      _HubEdit._addressInput.maxLength = 512;
      _HubEdit._addressInput.size = 15;
      _HubEdit._addressInput.value = hub.addr;
      new InputFieldManager(_HubEdit._addressInput, 0, false, Number.NaN, Number.NaN, null);
      p.appendChild(_HubEdit._addressInput);
      span = document.createElement("SPAN");
      span.style.marginLeft = Math.round(20 * constants.generalSizeCoef).toString() + "px";
      span.innerText = "Port:";
      p.appendChild(span);
      _HubEdit._portInput = document.createElement("INPUT");
      _HubEdit._portInput.style.border = "1px solid grey";
      _HubEdit._portInput.style.fontFamily = constants.generalFontFamily;
      _HubEdit._portInput.style.fontSize = constants.generalFontSize.toString() + "px";
      _HubEdit._portInput.style.textAlign = "right";
      _HubEdit._portInput.maxLength = 5;
      _HubEdit._portInput.size = 5;
      new InputFieldManager(_HubEdit._portInput, 3, true, Number.NaN, Number.NaN, null);
      p.appendChild(_HubEdit._portInput);
      p.appendChild(document.createElement("BR"));
      p.appendChild(document.createElement("BR"));
      span = document.createElement("SPAN");
      span.innerText = "Path:";
      span.style.marginLeft = Math.round(20 * constants.generalSizeCoef).toString() + "px";
      p.appendChild(span);
      _HubEdit._pathInput = document.createElement("INPUT");
      _HubEdit._pathInput.style.border = "1px solid grey";
      _HubEdit._pathInput.style.fontFamily = constants.generalFontFamily;
      _HubEdit._pathInput.style.fontSize = constants.generalFontSize.toString() + "px";
      _HubEdit._pathInput.size = 45;
      p.appendChild(_HubEdit._pathInput);
      p.appendChild(document.createElement("BR"));
      p.appendChild(document.createElement("BR"));
      span = document.createElement("SPAN");
      span.innerText = "Username:";
      span.style.marginLeft = Math.round(20 * constants.generalSizeCoef).toString() + "px";
      p.appendChild(span);
      _HubEdit._usernameInput = document.createElement("INPUT");
      _HubEdit._usernameInput.style.border = "1px solid grey";
      _HubEdit._usernameInput.style.fontFamily = constants.generalFontFamily;
      _HubEdit._usernameInput.style.fontSize = constants.generalFontSize.toString() + "px";
      _HubEdit._usernameInput.size = 15;
      p.appendChild(_HubEdit._usernameInput);
      span = document.createElement("SPAN");
      span.innerText = "Password:";
      span.style.marginLeft = Math.round(20 * constants.generalSizeCoef).toString() + "px";
      p.appendChild(span);
      _HubEdit._passwordInput = document.createElement("INPUT");
      _HubEdit._passwordInput.type = "password";
      _HubEdit._passwordInput.style.border = "1px solid grey";
      _HubEdit._passwordInput.style.fontFamily = constants.generalFontFamily;
      _HubEdit._passwordInput.style.fontSize = constants.generalFontSize.toString() + "px";
      _HubEdit._passwordInput.size = 15;
      p.appendChild(_HubEdit._passwordInput);
      p = document.createElement("P");
      p.style.paddingTop = "0px";
      p.style.marginTop = Math.round(3 * constants.generalSizeCoef).toString() + "px";
      p.style.lineHeight = Math.round(12 * constants.generalSizeCoef).toString() + "px";
      p.innerText = "Important note: credentials are saved in the configuration file wich is easily accessible. Therefore, if hub is write-protected, it might be wise to use ReadOnly credentials here. When installed on a Yoctopuce hub, Yocto-Visualization (for web) will automatically ask for read/write credentials at save time if neccessary.";
      p.style.textAlign = "justify";
      _HubEdit._contents.appendChild(p);
    }
    _HubEdit._protocolSelect.value = hub.protocol;
    _HubEdit._addressInput.value = hub.addr;
    _HubEdit._portInput.value = hub.port;
    _HubEdit._pathInput.value = hub.path;
    _HubEdit._usernameInput.value = hub.user;
    _HubEdit._passwordInput.value = hub.encryptedPassword != "" ? _HubEdit.FakePassword : "";
    _HubEdit._window.show();
  }
  static hide() {
    if (_HubEdit._window == null)
      return;
    _HubEdit._window.hide();
    _HubEdit._passwordInput.value = "";
    if (_HubEdit._whenDone != null)
      _HubEdit._whenDone();
  }
  static okClicked() {
    _HubEdit._currenthub.protocol = _HubEdit._protocolSelect.value;
    _HubEdit._currenthub.addr = _HubEdit._addressInput.value;
    _HubEdit._currenthub.port = _HubEdit._portInput.value;
    _HubEdit._currenthub.path = _HubEdit._pathInput.value;
    _HubEdit._currenthub.user = _HubEdit._usernameInput.value;
    if (_HubEdit._currenthub.user != "") {
      if (_HubEdit._passwordInput.value != _HubEdit.FakePassword) {
        _HubEdit._currenthub.encryptedPassword = Hub.Encrypt(_HubEdit._passwordInput.value, Hub.loginCypherPassword);
      }
    } else {
      _HubEdit._currenthub.encryptedPassword = "";
    }
    if (_HubEdit._thisIsEditing) {
      configForm.hubGotEdited(_HubEdit._currenthub);
    } else {
      configForm.hubWasAdded(_HubEdit._currenthub);
    }
    _HubEdit.hide();
    if (_HubEdit._whenDone != null)
      _HubEdit._whenDone();
  }
};
HubEdit.FakePassword = "******";
HubEdit._thisIsEditing = false;
HubEdit._whenDone = null;
HubEdit.fontSize = constants.generalFontSize;

// obj/full/credPrompt_rw.js
var CredentialsPrompt = class _CredentialsPrompt {
  static get activeBorderColor() {
    return constants.WindowInnerBorderColor;
  }
  static get inactiveBorderColor() {
    return "#b0b0b0";
  }
  static get activeColor() {
    return "black";
  }
  static get inactiveColor() {
    return "grey";
  }
  static get activeBackgroundColor() {
    return constants.WindowInnerBackgroundColor;
  }
  static get inactiveBackgroundColor() {
    return constants.WindowBackgroundColor;
  }
  static get username() {
    return this._username;
  }
  static get password() {
    return this._password;
  }
  static show(targeturl, whenDone) {
    if (_CredentialsPrompt._window == null) {
      _CredentialsPrompt._okButton = new button("Ok", () => {
        _CredentialsPrompt.okClicked();
      });
      _CredentialsPrompt._cancelButton = new button("Cancel", () => {
        _CredentialsPrompt.hide();
      });
      let params = new newWindowParam();
      params.positionType = 1;
      params.width = Math.round(450 * constants.generalSizeCoef);
      params.height = Math.round(175 * constants.generalSizeCoef);
      params.isModal = true;
      params.closeIcon = false;
      params.title = "Some credentials are required";
      params.buttons.push(_CredentialsPrompt._okButton);
      params.buttons.push(_CredentialsPrompt._cancelButton);
      _CredentialsPrompt._window = new YWindow(params);
      _CredentialsPrompt._contents = _CredentialsPrompt._window.innerContentDiv;
      let p = document.createElement("P");
      p.style.paddingTop = "10px";
      p.style.marginTop = Math.round(5 * constants.generalSizeCoef).toString() + "px";
      p.style.lineHeight = Math.round(15 * constants.generalSizeCoef).toString() + "px";
      p.innerText = "Saving configuration on " + targeturl + " requires  read/write credentials.";
      p.style.textAlign = "justify";
      _CredentialsPrompt._contents.appendChild(p);
      p.appendChild(document.createElement("BR"));
      p.appendChild(document.createElement("BR"));
      let span = document.createElement("SPAN");
      span = document.createElement("SPAN");
      span.innerText = "Username:";
      span.style.marginLeft = Math.round(20 * constants.generalSizeCoef).toString() + "px";
      p.appendChild(span);
      _CredentialsPrompt._usernameInput = document.createElement("INPUT");
      _CredentialsPrompt._usernameInput.style.border = "1px solid grey";
      _CredentialsPrompt._usernameInput.style.fontFamily = constants.generalFontFamily;
      _CredentialsPrompt._usernameInput.style.fontSize = constants.generalFontSize.toString() + "px";
      _CredentialsPrompt._usernameInput.size = 15;
      p.appendChild(_CredentialsPrompt._usernameInput);
      span = document.createElement("SPAN");
      span.innerText = "Password:";
      span.style.marginLeft = Math.round(20 * constants.generalSizeCoef).toString() + "px";
      p.appendChild(span);
      _CredentialsPrompt._passwordInput = document.createElement("INPUT");
      _CredentialsPrompt._passwordInput.type = "password";
      _CredentialsPrompt._passwordInput.style.border = "1px solid grey";
      _CredentialsPrompt._passwordInput.style.fontFamily = constants.generalFontFamily;
      _CredentialsPrompt._passwordInput.style.fontSize = constants.generalFontSize.toString() + "px";
      _CredentialsPrompt._passwordInput.size = 15;
      _CredentialsPrompt._passwordInput.addEventListener("keypress", (e) => {
        if (e.key == "Enter")
          this.okClicked();
      });
      p.appendChild(_CredentialsPrompt._passwordInput);
    }
    _CredentialsPrompt._window.show();
    _CredentialsPrompt._usernameInput.focus();
    _CredentialsPrompt._whenDone = whenDone;
  }
  static hide() {
    if (_CredentialsPrompt._window == null)
      return;
    _CredentialsPrompt._window.hide();
    _CredentialsPrompt._passwordInput.value = "";
  }
  static okClicked() {
    _CredentialsPrompt._username = _CredentialsPrompt._usernameInput.value;
    _CredentialsPrompt._password = _CredentialsPrompt._passwordInput.value;
    _CredentialsPrompt.hide();
    if (_CredentialsPrompt._whenDone != null)
      _CredentialsPrompt._whenDone(_CredentialsPrompt._usernameInput.value, _CredentialsPrompt._passwordInput.value);
  }
};
CredentialsPrompt._whenDone = null;
CredentialsPrompt.fontSize = constants.generalFontSize;
CredentialsPrompt._username = "";
CredentialsPrompt._password = "";

// obj/full/YoctoVisualizationBinaries.js
var BinariesBlobs = class {
};
BinariesBlobs.ro_js = "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";
BinariesBlobs.rw_js = "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";
BinariesBlobs.ro_minjs = "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";
BinariesBlobs.rw_minjs = "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gApycZnXBrlgyKngFjw4neG5A6tIykEhXXL3/EK6y8bfF9rvx/I36Z7bbjKfwbj+zzzC8C0+83BsPgofkq50gaBFEJcul/3IcsGsuxwKKj6G+JSt81XvjLpCL8FsBPg2ey0M8cItp0u7VXbkR0eSCOYN9V9zIaDijvzoSIIh1CSU06a+qtriXof2yFrB/XnY35xsbneDHfT/PwofCt8hW7sDycOU47g7T+zVE1pIADpVG6ztLJSeSLaeDJyXA57olwMoxU5hboh58hR+P91/MngqLgQ/hhqfOut8f9puf6AVl6SVtDl26ELmMTre4d/oYOax5y0W5syxDgHFfILKirLl1q9qdCivcqj3w04YxUW4MCKUsdG7RPc1oqIf1nPJcrCNfsz1629GX7UCnlOFMjth6S56RyzVpV6xkpSq6EJmW1VVSW+uqiwtVZJkeISWrahthMFh80accqt062rQXrPpaTD+0A60cP60pV8Dt9ZedJOGntZE1I6kMxTvNXDCZG34AUma1zN/KBynsw/hOx0DydJnzbYH9bHdpPkpw3REXkV92wD9zfvs6pINWVlReccodS9qOteZbG3XdU7rmcMr/OrmKys86+YFOuhGnNBT/7V/7l/5t/6x/zpcoRBjuAEphS5ACl24VusLPVATW7AvPnR5SDRbBcCsqhyV9lC5XbJ0I9xA+lY1eD/EA+n6dYWjG49yztnBE4bFaWiBaLd4kBD+07DFRW5nBCtJe7TZetJRV1W2VGNaqv+4WupsdalXYetx56m3OaldVgav9tHd2quw79l906+j9Tdftfvq9u0bGMQ3++GrwRuxlhASPm2zxt5svRq4q2L31N74YmGBheRULS2EsLXlVK0ukOQxlvvv8LRjVcpmg85bbxCjA8St07kzWtjFoGMg999V5P7bRk6sfgZbihgKrkVCAuIPfb0wavAW2KmjytTaVOy5Zed5KARkNgvs0anU4A2O1L2pgYdBRCwI5OdpGLSdPFVpVTVa3e7iY4y6vM3p/pwN0kUFg626QgNGlQudDBc0DHil3xfVjl4M6ruFtUhGegI89GR/Ongi2PssPGo/2bwYnO3rt+ha1181K8+VR75rz79S3vrg6zZ8vdmadJxaC3o9PA7xhKdTY5zwNltLi3tUAhH9GalbL/CTzu3mOXD87eYV/D6mv483r5DhkTtg6EyBPqXym8vho/bFpoupnmjU8z5ff5Ug/G7E+06UW49sTtXmiabadOHfactz2jRAHdgW6sBZ2N3hIugfedniS/6mWPrFwr85lG5cT6UC0TrunHmb57YiwZKvLGVCVI2TS9MoqKZUUSmeVJU0qwuuRK5WnNK4H3J9t2ivREhFAdefZ1n6fFUF/4qNaU85DVMWOE0T0WyqIhACNbqyafA0tLXfTZcpbtMtjnBZo8McXRYtre5OpWlv/+lh3U1OWmSv5t4szawWbYdPqyU64dOFLqq1rC27m/6T0O4Tdmmz29uVmh8kdJ6AAL0ItW/Pv1D3U9tGNn57vkNiXHyrxJhsOiyhdLIfO/P6dGjYVDTzf2WTCkqeanvyHWNPDrxz+r6nttZKXMBEfR9oe+4zkCBZ52zzHDP6WgYVKu1jVmJbq4qWaNMSVROxuQ00jMdQ/nfSqpiPZZwvc4ppRf1Tb6kZF0TF5xorsQsd3Yis70qrZuSlrXo1lml1ibhfB8HvEtfmLzESDNiUV+O+a4z7Uxx0HHn/KY4yDjX86uOvPv7axl/b+GuHw6mlpqihkv8UwyVpBsa6YLl+D8C4Ye0sK8qzPBsCGJXWn5eLMjsS9YK+bDmqumBkLxH+ffNZRyNKYOeXRiWjq42EmUtRsApIBMx055H6P+t68oSHosR95Ct0O2a3VQGg7VWLyTYrWSvbXdZkpTV3Q842YKf+6oqey7+svqgxMsVTIg2cKQYbp/PpJcm7cXEanULavXtmSqUuUITrHpaAiiPe7JgFvu2VjlFXzesTo2uraFW9EmBk2rSSj2vuTCtYzJfQaj90FViHVtrjnBpC1T7TMfq1glDOiy5WtkUs64qLlVEvCL7DBfkrx70QTFvjxsZ6FyqMKxgrLk/sPGT/Ey1YAlFrqPbuRFXM7Dpywrz7TPvsnjw5fv7y6IXvmhacWYFVfRczLMmuHs+blzWulh/zEr5/28UgUXzL5hmnxVf6sewLhNCueKx5MOs+iaU1YPVGmFDaHnXUQa8T6agY56l/7hPPQWqccKbuE84fc87lCqlrHirRIHcy8tnXnrNKch6ENACxOt4Mg56nKCyzH+vZa1E1CstOSx3UqgNVPwnjjmqxrQ5UcV8UHWAw6gT+8oA7A+dcp1Q/bGWha76zTLW71bwI7Dng1eRi4J6/zgqk4PcdAIdqQkjM2Xx3SoG9dfQD1eKBA+CuLdaC02m719JEiAPAF5Q3x4VtgCYOK1fmywbFgd1cOKEyZK/wO+WqXkibUVgjoWlwdyuLxnLG6O61ZTIVI77b9PZ7y2rhPrCsXBpses5NbNrthIiZBiqrDloPqL1au6OQYBB14fwLbW8T/ZRyYpxS+hXbm05fNbTMtDZHs6Hmk8tC/vjJ6cWT1070OxPp1AuR+DNgy0dtj505N5v+MMy6GPTyuRhDv0klyZAOZCUXRtjzhwdhzxtDVjG/LJhC1/OH9JwUQ2egUXsY9gZD6T8NasreDz8coCd9YBj4uR82HzW/fMGfYdjsqJ8/qZ8NwMQbttuDSlPsOGvmOumuTJSBc2RmjN6dZSzm/VkGjcVTX8Zhf7p+mEaVb7IbL7HILO4UoZzHp2OqNn6wCOU6qVeGKEdRJSKQ42+YLi/IVUmDkzNJIHLZF4b/Jhjzk0Lw2SdA+CfAnJBhTJ3Z+Xy0BQj9AIDXNOw1xrTW0Q3Lhdc6Kr98gT8qpvUFofe7T0ldaGuugcJeKwzDT1k8avQOe3t8PG7DUk+FvUqS6Y91EDG26Hf5Sf4tkNHP4zUCad9I69NNXwSKvsW76bH4DTp/sazFQBRXhdUvxOMVx8PAQsSymg/RZhduBFKJnydlCHzkH+VLipVkJrYVV1TroUV+rdjvTmCl/Xwh9rhEBF4GKStd/t/Luyeo7oZlW1wlxVLsKg/MNsh/yfPz7hRm1qR4LwBf4mfL+6BA370TGwAB8xRW+Hew5WjpbgIHWF3BRWhLXBbp9GmjCxkvgFZ4pyppeV70+DXHG/1oUuwmHg3WNy9If+cZI5yoG9YB2f9n2Twv6vHFFA1lWvMU4zgDTPNZk4drMlHmVQ6A7Ecvm35xEASAHHydvQTKwScN9hgWnQAqLMKQaukhfrCWFSqid1MX5qCpzkviwL2516zDX1RYuCo8J8B+o6+rcFoEqkoDySSJi9qKuzUVb3taauAZXDItej+urX6lrR/Y2LYn1inKsPfubZj8ylkaN4yw2PzaPQkD/HsS9uGfl+EO/H33LnwI/0zC4D78Mw23MasI72MejAlw1UP6qxeE/d377Cf83g0Q7vg1iOo+gsbFa5JE+FgJNo07D2nFUPVO7xGWGTFLBpUU0NMX2TBKyEU8JeroO3szg3XtOMK4WlBC70UIFSglHWYE1dKNxDOaiNhRmRO+b/49SmHduSKX8Bc0B/gbzXL6+xb+/n2e0r8Jps/H8LcgM/ibDUv4m2af4O+IDJsf6Ir0V7k28BhIby6OT7NrU8T/KgIkXWRv0vgGe2dESIIhp2neVkC2BSxauHRoJnFpdfLeOF5RYvmbUBKHkhcu89uzKC84ES+yo8sCSVyt61U8KLXVY8CcJ4ohAQkSm4LST1kKl9h+xD7Z+MEOvgcbQNC0+L1iAnosu7kwIGpEGiDk0V0e5orgUJjoU72Y+SKGhWyEf8bSiTHNhKkzluHhZHRwFfmXKedjqZwP9/uDIbs5OAbVW+HQQRQYIWYhzeKtQMZgxstjGL8onCEhn6dla/a+98HbU5n9w5aRG3xA8pjgnQC2zAZU34YKEAoobRaEbXC40ZMCw8R+rw77PQv7ZCn2di6MnYkX4L4SBgabJjxNsoj3DzfVGz0ufzZGIHvmX74wC0bhiV+p/BXJX4n8lclfE/jVimnAWsGFTN31aSJbEBM/8+k1eJgGm63JfwUeu/UlFKHYnGO+xvO9JdMGVi0qimZRak8bUHx6A8rfhnhi0lxj9hPGtfS0G/6NdWIRY++Ht7RZl2NPcTZeJ+G9aIftePPh/R3QgAsagpKJ/cBT4kB2yi8pctoqAZtYXFAN5J5RneF7YBZvbt//fni9/I543f9qrDiggdk5YrbPtCpRJ8Y7WgtH1O0UZnVMWCimUxq3irCFhlqhc3NEQGj5JOzgq6GDkDKIDBmyRT/x8iIohe3IOKcaQakOg9/EkPEwZZF2ogrRfbypfljsNXsj1uhBiEOtWsAvnHoYJ1pTVeJ79xIliQDPhCqECaqlRTtpNye0eSxtto4pX76Q/bKKwURgcF9r//5XtT6lrd+32r5f1/K0OeAONVhQVVhwgQbysk8ql+SDbnCYhsq03PP2IK1nJgYs0Urte3vsU96Vi/HgEu3erZSinzL003azAN1fMIxQr5jd2jw+Ad5O8U+EfxJkngz/THCtJ/thN6B1I//BV0C5CT8Yjb98oSTxKPlEMhsePk6Ylcksyjc0j3EQZE5oZnwgWwroF2+JfdzHDkbiC6tlDbJvWhVrJhDaQU+Qe/4l1BVMvwBAmoZ7Bj9VX6Bp+5H4LEBTkVmwoonfMJMn4vcJLMCCwI9JQRePKweB2ZUek8g9RWRfV2WA5oJNkPSHfAMO3LEHCeqbfvblZx8/d+XnLgXuiW8GLD8p8Lb83MbPHfm5g5/35SerShUOeqy0Kk4THqmE+zQheKhS4DctdF8vRZMe9PVyrOAO2RZJj1hSP7hvVEYTd7a1stu8MOUEkYiV0+KbRnJ/U2TsmBk7MuOBmUE/GG52VTKr/9CuTGbt3jezHqisILCQC7Ry/b7V3HagMnd2rAbva8g8fGQ1+WibZ0p67XI1IcazDeRcGSWve/T4/NWLNxdPUHcVwgFnMHJrD7iVHLCiI/kLVPCD4P5DoXnQNvh8ZpNWJKkZLlLuq5kskvj0zoxEMccnJiinCE5Jq45dmTPiOcJ8RWe5+FRzP62kBkwI6IkFkwWyMqMAkw3OvIlCYINaXEDdHXlW5cevQaJYaSBkRlbSS88fW0nv3mkdpN86Imw7Daq6TMm7jhWB0Q4q+j6mZYOpVtqWBdMJ26/4hi0f7EyzZF4SZiDmVwykjZh/o5mYd4m5q8+LsoERgKnd2MCFGo7/CprWX5XZmJQOE6iyFr9ULkTwZob4qa42YWq5WPgfud1Z7PVZJ2VwA35TCUtKdZQMRPR4qKRD8waaZQBvumFaJ95slaCbbvV9CtmW3zK48gm5ikBx5Hf/RPD02xnGQAW2aIJWQq7ilIyaUsNlmcTIPOTNavdP1E9QQDhSPqHbFmcVntmBEnChsPuk/j4V+juO009REo8aoCtHU1KSvMDbVGa0mAMzWoxnEwvZjxMkLk4YQsqWsqEPgYA7zqaXPMBx7TCJrmAi8CGeqw8kaOkCpeXZYHma1cSuRNp4IG0/xr9ormXMRatlVVSz0MkyhTiI8YNl4SUyrVQ1C0vFVsd/jcsJG2JGAhEHVSPDoTaUsMTQRJXG6gWNlf44NAhQKpbRCAJz5ba0LWP04vNxNrvVQ3EJw00EOl20nw4iNNa8h53Kh5C8L+GfLj8yMS+WqWcWKAXC9zzaoQjcbgQIpu16Cljzli83cHlXx45LAIT28SqRgNLaINKLhCsm8SlxtpeLJ5Y/51E6T6I8Lm891RZeAid6I4Ed7JbPJzGRNJKwSUWvdMKUxSAcObVCMs8TsgmOdduFiRblQgPdJwPVF+adggUXWAxuS0ctYUC2qdCdqmOzMSkfz69AQM/oU0rz2uCnMjljwX33w94h1k05Ko/Z+L6V52Bv5QPbdzLtHT4VW5zMpxjxmop6xloDJE2WwChlY9i0z6fTKL+Fpe0TSbiZvSDJFT37bzf9hkyjvREG9XazIVIkSJmVUUK7gUdE7Ac3WqaaMwXGzq5KKYd/NtBriGagkciO7GnU8R7mw4wRi0b61Ktptfg468CUrZIPXsjuPsHmVp2Asn/2SPcmAMHrN9stPBFYWUNZqaFkR5RAjxEu0tHbsNnWtsp1VUK7HXxbbXYiXgOFuIJC3L3pi04Ua9RQVGpgR7Rf0Yl+Z0kHPbT1Lim7WFSOlMXRLIeXsk3jPKGivNWcn+HsEL/faenvtHQ11UQKrY96peIJcfEiKkp5jgwzkU+eFzh3LvJ4PCa5AJZzSIgtTKCiThyBq/pjs/7eYsaemXAJIr3gVaz7A2Z1VQa8geo7wYgGXHSKM3tKCFfGu0qJW41ErgwHyXUSatGmykGMD8tjfFguUqHMoNgnGEFKk6eDQjyERWR43vviwyDt3uxLPMW9UYpz2oVVArIPJLYqGzCn2arrqeivQrXdtlP4ywE5PKLCqwQF/EbgaQyWGgRMDaph22g6i8VxRBHaHfZpPzuBpK4f6R2HDD/BaF1oI+fHoZkB0P8wQOPeTSfr3iwAmU4kSCHR30y+oQPsKxqNTsn1k+msvOUs2fK0d6caKwgsmcKXt6zlJLCmgjURNi8Ifx0gIdiqKq7uqhkYd6tzZLFgiNLpaK7vqj7OaXn35PHP9+4Za02n02kcnZw8P/25cfrk18aLJ788wehn/IJmybtEvrIPpd0HrhmbErCnTU00Ztfn9ivSU8ulN2SiZfmgLyTaNM3gd+ZelDOclGaEVLPeTC28GDHVRjrjzU4+yAs8rjxEeT+lZpKlMN7yKg4iantZXgXOqKQd1nXDd1OiE/D7xI4iB30RIrcOooP2znrKBJ2aPJQON/2BldsOdEapKVuPClZ5MAdeRdngnN++zZlWkxXeNPOr3GnkO/nTgmAcCrM6oYYjgeZ5jLf8qeMRgSzdL/mRD5p3LYy2r3LN/QYoPQdMCW5UtWC6wShopUyvFVpp0+JGvgmg0C2uqovLcNC0wM8k9dciRLCW9TDB2+d0a0IxOCf/mANMHCVa+DN6a8uBB0jEBgXzpUSsYPNLmXC6hCJbW2GbWzxNCkkocvHq4ugFq7gIHTsIQ1ryeacvNOGFeGFrCP2KJhKKl9RMKTI1IVP9MXUe8aXVFficQpaGh9Zdk2idzkED8CKjRlDkZeNTnJfzCGgEP1V161DKIANsMIyF5b29vH7oukeXLkpMZWQX5+oGG/Gu5TlQ/suIjjCootxPwFu2MUC8AVX0OGFkHZQ13L20oQnAQWslGZZoUvNd2otTZn2/gf7uVO/e1miwBFVU+FOjwRJTgyVODfYubFlLdcaveD7PuvLtXLtUp/4uOFOmALlcYRJv8b1GcMHqhC1Yy6UUgID58oV4lmZQJ325Jmmue25d48Og5Ku4WLaZw4o7GH8qOzXc7IjaqhsfvN88mMY4LqieosmoiH+kpVKeMhiGypnchldNlYet72arFM3I5D2juTx2t7W+nVI0EEDN5ovH9auUtPinGC2LeJnR8lOpGy0b84LkJ1BFJe4HT2fhhgSQCjnEU0IiTPFY2cvohqkCZyQ/J3msuw3Oux+r2epCkLMwnnq4ikGrNHobnorhIUwlepvIUA/CnXAqp872Tmcdbd0wKqn+aw+sb49u4oLJP+mq2/QHnpAxSUeWk/DLigfz6FM8jgARqzT3BKkcgY/4239py/o4dPh3LytOxRkayru64Uy+YpUrqHUMqU5xgZXs6EY6rTQjZYjQ2/TQqhGVIPFBbjcwlDMljop9JwYo/Ei6xrGf59tDUwfCos5yVlC0t8dY5VBW1gDNsLCsOqNzNWd9pxksr8MJq6p6vqd8I2gMQfxKI+9toA/dozlUNMmEBwJHpNGqB+CK79+h5iCotH0CzapOftZ0/svjiUoWtjFTvG3ip/H8Siw3dSLxgvhqrFvm0ZC5l2IetqS3X1k7i+WsY+eacsw5Dk64ikcc14v2qnuoIXcMpQGwwCnanK2ES9Hns+X3yZjqjD6a5wcZ6YO1i/4pjO+xHbaie0kfcQcSQ70BJgyZEKlIQpbMPGRwEOUjgwsek4kNZxlCFNn1inRasQSSNUsJtqTqoctryFD6ChmaHkKGRtyb7yl/Xbj9OeKH3qG3rk4wOPd8puhzAGLOqWVj9pXBC+2qjpgZSNh+rHMj+iJgSFroFwLpeIsgtH189XzmOIi1tHN6GgsFT0mLXhLB2yFr6fQuu1wd6JCb6haTKB0lhJ81aVqzWl8N2aCSKwux2pZM41bPyvQv0CuvlWj4KpGpaKCrsSMh6fmXGChjza5evLCAQE+4ca/ldUUVFOoYYo/VCfwY/sjgAdUh5PjZvOK79DfYLV0Q6VCzOiK6daVhN4nkoqN5ELCnZU6zvLsItdV27lSij8d6eK3qjuUCWu6A3l6M92FbGx/0N0vgiRo6rUWQpUD+XfD7oE5SrRyxla2OmXMTIBGy4A+c0Pqm7RjU0vTNrCVjRF7O42R0LqZFyzM0TJgifwdZ/HOSXUbJhdxyKP62pVa1vs8XGFIO30Z888z2q1PYPkIzqAsCcTSfznRkJF+b0sEVTkYhZkeUURiQD112O4Vd5THMPpvwf1Rd5sANTGgCSvoofF4yt7UDchI6B3bzUU+6QB/cQSRzb2kW83TEttpOD+9Qte9cptxFQFcb1Gw2D4h4AeLG1E/uglQn8jPNWpF4eLlJmVnWX/d8qMjv+Xdq2vPXrz/M7lR3GPnuAYsWLiudfvbqLzu2XXZqe7v00HbtK1LsClTl7gzt16A8cF+qQdwcy4+e7fnxfs2NHLo60Of0ywA860A5oafHRQ1GGfSZPnapz/b8dH9p4XRZ4YWlW9ALpMKjtpYa3Yg7OJoyQYELRzJejVg8TwuSM13Rvp8TKvFjpAZfqxDxsflanYjyllyQ+ZWh91SvIIKdyXuiTRDMkN99xtMgcVLUp9bk0YoOFEkdqJZ/JR92LHR8vPXSqypCkVNhiHSFZpDgcp/sgyZDWQ0kSoYpGaTElH8i9sYSvRstEWzFB2FHdqcLfKvZFBfPN+omtfVU7NSVqtqh2Zat9VTv36aVvlXbT3n7lVS2MNUhlX4VUnx12giWXegUBRKpOYhGE+ewJ8bVKjr4+4RLvY1I7o6sxTUx9oD0mZo3iOSJkX2cw8GW93HxHab5nQsbE8azpinRp+ZXy5GIyZHvoVPXqdS2Sqyu62OOuuylXdYnSm4clOr3YSfY07L29axgr7dgnhkieaTy/sPAYpAsL1t512paUdZaSLU7mHjdsex0PHUHsjewF9ZSLNcxjAjhV8RsCIpx/EE9lVhcxenoOMkKUuivXXgjPl7FxKvWK/XiBurt617+0mzdlStGbHoJD8KrbyApwVx7XwoLUtRYj+qqGBSd+CAYsGrmYdwuDuBz8n6OfEAOi3C+F4dzFO1pGOPitc/eCuNzcrpcp7A/JGE4QRl2I+iCX3TVphntwMyCb/7Klll/5FNb9Krlz7u3rLbbdosXvu2wBG+zRTq8pS2ReSNS/DmzG4hR5un7Eo4cYsoe+6b3Lo1xLPPbz7VapTx5jdBDZOZ9HsEuE28qL7QtgqMgbBLMKBpOZbdDvLXvELLxrqk0Myv156sAl7AWIjXZT5ZcBKTdg8VsvhSqtgkoPJc+ECJF4oT6gam5pP4dz666LgfDvvvcEQMPlM6z0B491k2NtyiNUZxDdWe0mapNXuUtvs8ZsPs+gPOUlKTWmSVGlqFdOY2mxExmTpKi6Uwl44ieAf5xgXGL6KGbOsg0MsO8e6J/d89ePzl+fv781enH01cvnr98fiGPUdlbPeUPm1q4eEz1vkhlN5mgopOYXS8Id3vSIbJwaK2cdmOkc4x6zv7zVgdhpznVw9pZNBphJ2U08E8AFQ+j5CVzBC3TJ1ke/4GRjSs5Dnfk1lEB87etvnUWkTstxrTM97EKjmD46mZp/kN2T4YyFx9vm7d4MmUtASI5S/AIcbZsHjUY7GO3YmTStkxw2aLJhOu2K/nT1a7MlO0qcKNdxeXrtOuYAJUJXgWpFl1aiB3XGeDqzM6YZPI133Q2L8lHJ3YrerW0rAo2Zba7enY78ZUSQ+yjl8D0uk1+tsnkQ1WOsnR+tsmBVp3wnXDA1Qd8Ui6twxa6zKqEB9HyWHgQHXgVws+iNMEQEQi8GmlDdq7Fz7ZYrZDZBmD0rhQT/QjrKc8g16B8RdSzWyZczlfuDoxV6AoBomLnjI1QFU5hvIQ82oJRaVZlsaY1UNW8tuDUnBOvbr72mNvK1tD4IUfe9hr5FR3iy2nlXg1Lph0QIKsQP2Nwq9EWS/g608Fc3SvXNIxcdlvDLLAKaQa2GmdLy1hLBFkKSEUMWflMFNmFvlcHKurQOl3gk7M6wVcFvJAXhPh096zoH99wn6sulrucBv5Gz7OvadUGr/kurlGMlXela5TKyix8n1Qy0FlK0cB7gr5eLKgWCAA0sMB6DrgeAva6FVAnLAfuVaHd4ALeVaCmhCziLFNXSJVyF6stpxWsKVlfVC9bV3hJaaN4bfllFZg10Cos1qOecNL4yxf4o3zhPCP/yq0wvRZmXVes3A6T+ex6mA2+UpWBNbMALa5AV0FUCKIzxmGZ3NZeFpNN1MtB/f5ksYbWvvaWX2s8qLMCMLzprv2M/+w+fnVx8eqlCB4FK1ISaZaAf2+6/3WbbjFaleWMpzM9SgDJJuQgr9MGH/BKvDiWzOLEcRAVH44zyXpr/b+V+X8r8/9W5v+tzP//W5kXy+03hc+5eHWmZ/NPgLjIZh0dSoNguSLDiJwjvnkFIoDOivg6JdcYDCAtCUAfZ2WZTTt2CRNYwmkQeu9UiqqR91GRk+qmzwjopqCPSt30Tfmv1k3R4vwW3xz9LUtJ4TJcq1xpudYKGKZrlc5rz7kPSxaGyq7dzKW1WwWgdu4OmrB4iwe77GO3J2aFWWKlJLiDnvopJtezLC95RE7+LDenB3kamNVx+RzPQkxqghVdl4uVwA7y2u/L/0Rnh/O8yPLHhgJrBobtsf95+iPEZ2iExUUq777Tv7tHby5emUj010ai0jy+TmL6ds9Cd4Xiq3fKeoxzg+i6NHWacVFR1C9dlZj6/kk8/Vk6+OF5joqqmtz/xfq54LAa5TbQtdugot4GX6vfVri18mzLBmBPuCrF1HOuCv+T1Uy0DEVjfjjfiopM9VxUgku0zFl2hxHp14xIXx+RfmVE+t82IkvGwh4FJ/2dlP8KxnCpY3ptpvJktGM8wlRIeQ7J8w3qmRI/TrHjUs4sPlzG8dXHsRUmNp7I2rzvBzoCVlmKjMLfxkPl0MHWAOVYa7L3K/ZiJqWczV8YW0urwHfcWVprxVfvlB3DeVkzkJfuIaxT950cdWkM5Y+wFVzeVVpa2LoRuXBYDC5+nMWgOrB36hbgeCYNU8L3Ce6LWqYSKAK1boQxv0assl6LrKKSdSGy0krWY5EVedVtpxYw3sZAPWqw2lfPGqwmxJuYClphameYNmGZ/IzpsFRHf/76hU0x9TKcwwPMTbUWSJV+UlXqH1k2val2CpNvQ+oSJC+PoxnwGTH8xSrQV3kMnYkSqoXrj0FqICJHcwKCYu7oTR28GBT3WNWV+hvts4sQDprxzp8jId4qX1EKhgOgj1mcpYJYlTf9JjhQNpsp2Lo6A+4ngKXXVfptFpaiNC0s1s6o77S4/FgziLFRWh3uATZSMtQD/MaTy3mZTfGaO7UaPD999uS1OurknwD2PJ2QPIbewDaqMY3ilJKamg4MFKj94A2GB36jhQd+8YO893ykPqBhR6dFbdR8Q0PGJqGxoJgNgd6Q4qE3tCtaejp/VGpaF7R8M9i9nkNpdkxawf3thzuCEXQA6qJExVEWzFPCENFUGaj+QqSwKPWOmlQtPTOGtyrKY8QvLRzUFWbRv5eW7fOg27WUoiQ/w3vfWO9xlCSXsC+2h/xllP8Oi6MGQQe/Wk5yQbUEN+KsbZW6g23FHGCV7kBi2WXhG3mE1LNTnqsgrBL8VoI/6mtcEjZZs02bc8LqwC85bVQnjX7wqO8+bTyBhl5Lty11540R6ELX1In4rnUCues+gNytO3/crd8n0kZW2WbqnE/9IGOIsdjLY0JTdaMwbMAEJMJRVY4njHQFhVcjeWcZp5Td0gitE/7VCiYl4vOg59o/SJ5h7kGlRnyaLiVobWuHpKMq2SM1J+z1jwKWqurfYFLaCKV39FVWprsjx3eHdSfGN8aR8U31zNhNY0k8ji9/iraUQjjSuRjYWjy04arjhb2/1kQcY7c5jGZkTNUlvCUfermw2Ajly7DqzJPcNBABOOnbbrTHHraWyMcKA3fC2NtrrSFRZWY7FO7c15sGq3jYuFfwKqWKuxlj+h2x66yf2J5xA0FUJx54D5nU4O9RDRGkHraWJsN16V7UGywbKQz2zH6LzZ8Ew2GUk0wRrFwim1Rtd+J1Tsrbuhl3a8y42+qMU4sm1QCncUpN/ewjumn1fPl29k7TDxbWykUoSGOTBjOVqyFco+8uge6IDF3lXRjRDIkWAzNwY7oCWaHa3AGdAtbx8qKGQPLZZ793qFL3NAA9Gm/w0Gs3u/zpwg+643KHnv0IM9Y3KTJ3xv2H3pcpv8N9mfVX6K+mhNRPbRrIDNp7BSbHT2m25O7N/gnv93wf8fMdLgYtvdlzB1S+20WfFTd17jLvfujFHSU9nMzsakMXOEYzmnlfM+Qr8H/2TaHv6Ia0isUSr6I/1jQnt+TfdEWJbedFLvuC/GNgQ5KvvlykoUFNcy/QNPdCM83d5jx06p/7/XUZlwlRT6a/874+6Gu3HGhTVd/cJfczy7I1/5Jlst7T23pu89/EXzsIf7iuQ9FE9IX5N+oagPsYwS6XccuFKMVeOvrQKmGuQWDbSr7jXS56YDvBVa6y79eyaF06qKxOS7wbE+kF61WwcR7bznYrPsyPkiS7Fn6v1TYTQ2po8Xt5YnRTTaTxwCupVRObyzU63uT6GZBU7SLKFUPfLt5z6qlbTghUvUFkzyQ67MptxF0mFnewSz0ViVBlXu2k++7Owl0rCx9LuwkxxGYzcuD1piRpXVTUm+Slv4O7aiJcblbYbB2LmlGmMr/0TDbDDHA1x4yWyUKr0AEgSFidJ2rGGc589QxmFqWmD5xAL2GvLmJCibDR3r17/CeaI9AfUH1Aa4dr+8YwStOMKtDjnEQ0GC+03YCZidBljSP8qaYH4iQu16D+tKqKTrn2OZU3yx3dEo1g0osuI8PxhAx/P+G+xlm3JVh991f0VdSwRp+X3EV4qY0T2S/lFLojyTjNokr4A0hiNItuVtEsTpfRbD9UYHWX+W80miW4qWUEY6wki9cRLLpZz/EGCPzKtWVIY5eVMbPSz/pt4TnA63tv9o6O1D+ko8vNOmj+qV3DL72r9/387a/yn4Jrr+sGOqbLu+cUyLh1TpfsdcZALjmuZUsZnhSYbEbpAaRemVnVdO29KSNTovBD7kyZuspXdqZW4V4ZPmDhPxMaua5eagGjXqpAzvRTxXKOLgstE79UHp2G8neUl+ojkxkz+U64B4i8M58FC9u6jXgsDfDG+wTFGrFmoVfxhZyhhZh+whz8Se0EP6vatrrlFDtOXVghGQxEXtXxK0VKowSxSpS3M4yKFYdhcw4DjWF6Rs3DjWAvXnDvZ/qBi+E9stKUWbW3UFJdXQhR0OIiyF+7BRlSj0ezKL0QRfR2et6A77P+SlXwN2l8gwV0IFDfQtIF4j8FBn5H3bUZq0qHBjeE/JfApRNICSr5NBv2NcQq2uBZz7J5Xlh5e03qkH9Ml+15Scz8QSwt9dT3ftjsNdt4SBaW7RgLD3j4aKzgnAADjNB4mIoakyQuRKrYQRZh0U63ArLtF+xZDFYG9WKxsHeIX4WGwp5IeBrfgD64DY0vFhf5LWw7CqJd7bFH5/Cv3ZJDsapgZNQwQcG9KsDRZYHko0ND+NLhvog2FPfPNBC1gHDWJIvF4B3pnlyM4mKWRLdX7DyleXKy9fLl1rt3jclkbzrdK4ru1VUTIS/OLcjRqGvAoFHmOq+XPmzTeAIyYhol5wQEIJq0wma3CdLiv6W0kCamN/Fnx6RlxioVBuFjbEQAm8TjSYImpL+RPHM+d3+W/yFfvKPNigetTFOSs8uZvCq8LSh+04uVPaNBfsExvWJBu69z+b2ko5oAPQfBidoQLf0sduTYgtbMArEbuHOgzu7/Ye/dv9NGlkXh389f4XD3zUKWIICNH4Dsix3bcSZ+BOPEjo9PtgwCNAGJjUQISbh/+1fVL3VLLcCZzD53nfXNmhjoR3V1d3V1VXV1NXUq9HQPdJHExTDofGGyMKeMEfeyVAHSbUEWjfVl+GuKmTvb1M9odD3Dw1KjujzrKYu6nEnN6Urx2Jau0M7/C/fyWag24pna9Ls3TNqOH1YHwmF+CviGJQv7CsNXjyghiM0bX7CMt2frs1v0QvpuHAp7oLfrYmfSYO4YWxtFgXKpZFiK3wPJ52mhQSKFk7Jo3WUCRMi+Er9q2AjxZRCvYBerVmjCX6hN3qnGtHxY8IzNYglvwoU0FcrIqRFbEx75BksAoXOpxuPfsVXC+30b6qK3B9O7yEgY/JUHcsA+DPrlUt436k6B/O4NA+A1jkGbZ4V4ool2DGkcnUL54KBUp5G4SclxMMvjRcS4kIHPQLwaIhZBw64cMizs4auqXKxQMGqQX5XyK8l8nmNJaiSqhzxGrPeKlqgP5L4MWF8G9uCgdKhkmOWa8rtQjoeYgtocLBZS6HGaKG2A1tB2ioSjXPXywOCM+vAA90lpkAp5EVx8CA3UFEJUvDBVvhhZv+k4Q2L4f+lAY8VxhdQMObB4i9awt9Jd5HfaLe7fFd5jRBz6wrS9giSjzZ26/ClW93eRYnU/mzjjgc7kzqAIo3uq0mpHNlqMo8zM9p7v4TtZ6M2f3sZEFhkeuejKeD5YarUuJ4HkQyz2SPhSSJXaVFKuej1A7JV4VFDsnVDXZEKHqLrGDCpgM4aDZsoDworH6pScDOtAismuzAQR5kNApQNJ7HE3mZV+M4yE2PD5F8YkFig+i1H5vPawxM5jXmxhLAhwkmUQ8C14z0LFW6yekaHz5A6FW35CXSeu5GGilJgGJkQ/+zZ9SvyVJNsPk0gfy4ktz/hwRKbsrVLJ0pFGyVIwnRRPr1oXzbZ0pV115c1y0uTHM8xzMoYLqiRxVClJEji7B1WSglDB5jSTLthfJZKKr68ur9pvzi/P0uxEsuiqA4AkAfgGQtf9o3jbPr7EUwJj7cVKNuOtUvw0cpavq5IpfFZbss+qbkDX4ep8VFMHqSydtCYKiYbEZFA2y6ciRcQsnUARhWIa5jPoLp7cMOIkLj0y8UfxCDKwpZ7I1BFPHIFKnlpdKCo5X8SkUiopwakU4kGV950r0bFdepZ84VhDK+BLEH9Q+UJadivli8yILKvioijN2BED762NakhQTS4ega/HAIYKvmG8uAhmXj4nEgC518GGH8BY+31AMCzeHLeu3r3jBekvKHXTmQTDIb5TF2Fgf1L0+Oqy3Woet3lh/huL/2vqut9duXwabztEjxAUsN5JAtY/0gKW7/5Yg4Xim8cgvvErKW+ET5V8MeXktVwcZoMX/8B8wrSFY/+sa8kEkUoU3PIucf9EqvUhkSTq3PMzy6cwGIK6eJe6tMNz7lM59zcA0WWvqDMnQGk00q6AUiZzCJSLx7KpMqa/5IsojbIWDZ4ZoyGKq2iIufpL7nrXGUJ6ukTCZe86JbhriML9dafGLMSS+YpjYxqpFMX9AkopCkwd4ycL0KP8VLX4OD9F038BrftVaN1r0brPRuv+r6A1j9deEiFpWdJrA1JRgYS8dp/Z/PMU66nVtfqcceIPplirfHIt5frqVFavr07THoMnr1WfwZPXGq/BGAz7qariKmKrt8tUB+l2qXD2lXtl8+jqwwnf0cgPsb+Hat88fd/C4tHJu6uPvAj5kZABZITskCHir90tJzFvKbnFZyAdpW8Ombqjq9Zr5tDp0+mjKWwKmS8+4OnEuxkvLRLw4jZbOxt3wqZBKpGZVBuRkvgE02YS0yx4lsPwH649JIEy06kBGTKAgTIgAQpyEqpDIs4JRGHS49EI4n2alxUJ8mjcy6MRMIFQbUNOE4QRt5Tuhh2AnPQPlJP+IclJN7pDGuAq0sMWgh/lQHoLw4HjTfCU5jLS19SdmvKDV2EsFIbrHB7rqe9U0dJ48AbLQDa6enjyJt+Md7c2815BKWEQw4T78mNxFJa5dTdXKuVM2felHuEJjOlIt3eEYXLLUO/0GOJFcgq19FvAVlJgfw/cLfIUJ4IM+SOheBSaD//3TslQQQ6likPxVKlhRmYuzJEHPeXBD1/tYExAxPVXAedGOTNaAniQAFzZXhfwQA8YABDAr/nIhio87YAivC7C45swbJCXoK15nS/05S88JraB9sj6uUvrGe9+xK4Z1yhz6v0zSJZ4G6g9cTpfNO/cxFn/1shE/+5IRNHfE4ko+QimLCq/njh9NOCcJC9vT/ARGnr2pS/KoYVLoOF5/yo4cQiQDnFyZBdhj0lwMerKMeH3ZWmiEtiDvcye8z7ALjAr/XHWD5rw3+XN7eDktg/fjvFns3/cvIePo++uPylhwrs3rdOPb1qvO6MPg+7Z8OuTd3TrfCwPm6etoHvTnF8cHx11P3b6F3/i9+a3iz+Db5ftoAzfJxevT2YX11t7lwPS1pvuyfCy9b735fjo/dXb5tfjyaj0CTOO747OP95dNJun386g7U6rf3I7PLk8wryjs+5R+/YEEDm7Pt54tfFtcPQekkcf3rZOTm/dy0n0YXI6PX198v5Nd989Oh81z49Og2b/w3Hp8u3729PXs3dQ632/dfe92bv9vmFunM9L4/ez8Pxtc3D8/uL90e1NtVN5ffd1t13tfb+s/iuE8qffurPSn9f3W1HU3vozqm5/Gs3vzu9fvw7e3/lB9+PRByh003p792nw9ml2fBd83amOPwHw7e9fhr2j8FOrVzm5+HY1bf/ZgZJe/3xaCku3837zqx/4Hz+VLq+3e0eV91/ef9+Zv/l6jWV2dz5sn5T//ATfn7zO9rvz6YV/+Xr30+z1EABPtyF95MK3pv/lj+uvU/i2Ozm9uPx09P3Tzrbbao+qs53w/V6n2bn95H77MI+ujsdX/tfdP6Hk++7r1/Bx/Kb/x58X/b2S/3Hsvp/c97vbza3Zmz8/Xr9t/uty++hD8K4THpU/XXQr1U+vv3z/8nV2+a6707x4v313dj69Oxn+8X3nphlsTe7H7wbhpz/m87ej2bTysf3OO632AcN+5TL4fn5fhq9HX5xOa+bcf/nUv70eTnbfVU66bnPw57tv43/N2leT0tfmm6tPZ1u7p9fnV1dbo97d3Vn5Xycfm2dfLwDX9vFOa979AoD+GF183X0afRy+hh9f96v/ipzj9uBsHJTb1+Hp1/Hu7Oiq9HXbP/rXx+D+a6s0v3LfnbYHb0bdN9vtTv/s/XzPA4CDL34Vp+3j082fZ5Nddz94vb+ztVt59/aoHOx635+uo/s34+vZLhbam27Pv34//fL1un21dXE3vXj6tve2de39uRd+7Tc7zRmUOZkdu6Xe3t3Zt0/3p0c7b99/+o4zNXnz8c/yWa/68dO7D+0/q+N59c3Th+DuT/d0+2p6Mbj337/5Yzr8iLS8c7uzfXwdPfXGH769n+4e35WuXa9zEXzd6vwxHVdPPo2wnT9mF6eXT3vji2hYPdu6GJzP33y5utu6vr69uRjdfb+62z39Vzjbqp5Nq5de92R293ECtf70fZzyu9vT7++arbct5/Wdf/y+uhWUjsY377537r6/7zX/QKIY7p9Apckf7fmkfPXxzNkKT/13X69fh/5Ou793XbqeHHVuLlqVy6gXEiZxc/vhqvVH9fj+/HzDzpHnUBOsh8idN5O8EwVP+IAzew01Moj8FwxdPD4HXYY6IVOGttEBZg5SKQ2XmGO348mDb7j5hdp38EjOwul2X/NfyjHkP6gzmu7kMa4u3fhBP285fgkPdRPK92xGcgniYeF248A8lrZQMB5LhaKFJlSKuw589UrBspLiNFUpxPG7PT9G/cfzQbfvBTDyax0ZLe255KK6tPNxORCFIunp1EI5TgZFiF1LlVOp3pLIEHccySGxBF7teCrs8NJYxO9QY1wjGnEUTDsDMhK9jnKpiGTASnZ16Sd+N5E8Cqah+zqY+bp0DRiS/nHgukNdxh/uPA0LQ5h98NzZdTJwtvRQrjwe6WgCmeGw8TUX+s9YFbQ6/ehLPITXnt8ZiJf8CmV9AWr1ID3ouXnptleiHDmjzIBBYgmW9Hl0JCRPZyZSt9zexA0HOFjBlA0ssD2dMCbHpKXuEDIfigOAy9fOQvpIcHwNTfCnOE2QOgF6G6WBStoCdfPSNCz1iZpLvHQZla6H9gHlTW2RnE+yEWtoLHS0r9bF1JVV2fJQa0LisorKAhI1L3jqyqopdC946sqqYhmKunHyyVe80roKgrReBQyWtqSuzMNhByRNvYPV40ICKEk4aGSbyenm1FgbxgjGIKeZ2fUhAEXm0vO7Vn0yPF0Yh5xmnteHIPdBnu61IMxwInO6GV+r+hd3nupAPOHG6sfK69RPxS3O0MvYQk9J+nIB8UiniY5IXHRd2MWDuXCUVaZdkR9kvCdkjH6JhhSq+C0NqLMjE81vAa/Qn0JRzwO/DnEq5PYL4FdQrkqPz4O/kq6TtPo88KvonkiXRUGtFvXuKwIM3AjpFVmQTScnINblXWCLsAEPsQR6pZENy30oPbIoBsT2lHI7kzSBSzePHuHwz6gD0Dw1KJfqUUPefplZrx6ZpoE3E6m7Dsl6iB6LXXbLUonzFmcDCkKkRZ836vFc/IZe0uyOI/kBSQf4jbyX4hncduiCHvMn6EBnw+DJGbY5Q4jN3wlOgf7ScUQ6hYEcB6MnmJmPXjSg7vDJQpbLva8jQ7YQAZspRMRb76BkKIFfiTBTTLrGsAiu79y0exX146hFB3J9dIpSAMZ+d6KAsVncqwKV8YusoiC/c8suu7a4y6dcTLpSnWzXsxLwTB4Yj9zs5uAMOUSsrmPc5+TXurb/y11DjPntER3Gi7/5RZF/0zMZ6ccKtG8UqGF0MmPo8LdE0iFDSCK94UpWcOp+K0lF28I9QyLmJm8lsVoW5xn/SJgaaJbi4iy5K0MDN9iU0sBXyuISgBiTyoKkc5X+kTXMGrV5IYn31N5RpPIb75dtl2lgO7IW3Fi6htK8KPDk4tjpu3fppHv04U9CrCDpo2c/7h5M8OGET5uB7fqqR9oSwR9XqI7kXCf8F3RD3K2IkSkz/AoalCuGmV3jPl3j3oojoC9VU9PNm+nmDw4qVrrVdMF7KLhM6U2p+0oAe50qnK4hRdbX6serGN1CIQ4kpadpFAV+SGY8bZ95oQQmyTTdLLMsLbWNKSXzRGhAnxCBVJnV01E2J2dKwwtNEbxfSO+MEiA3nUnlZDgCUpp434ojoGhvPJwfzT/kYWTRHnJ3fxwEE1BooSIeWzKRAQT6sHhn4dHjPW7C/oFmZtgDBi9f+g1NLrmJWEint3gtRwezLXJ1MKlvtQYoe8UivkesmVI6MAG6IbJqpLPtACgsnwJpsfWC93HYGZ4Cs6gLJR3whxcI+Rm/l1TSOBhZ5kXGrBf0XPovdFga4vQLGqKj5ObeqhrcG12s1CU1VrICbS3lnQ0dpS6pK722kcWvlHTZ9HzPH09JIqu+yjEsLgGED3Nwzwq+2GLZoZh8NCRec7pC0tLTZadW4NKGnCUNyetRly+W5SpC1FRW6NF67rLNpgGMGjX4y9BWcDdsBfkmzPmBDVzh5Uv41rAHxW9Gsr9KMOmhldi+knI3uzCkE9GJ2jRFMivkoaECNGu8qlhde2qK3/UMDWVqdXUaCE16jd9LxmKxiC2nPEqURjAzlgtRsTlzXVmtzheGRmbD/TzZGgua8O+VvV4tFQQtfsFMIyVthnSHzWA+sNQP0KlM0o2dVUJPXc877Uy5i+uLWtGxeFfIXE4Z/cZ+FX4dpr9Uk15nTyCdypYaX4WGlTHe/MGr2NFYWP3jo9dMfWChkLckbb4gET4y+T+P/h7zBb7HK+JgpgaiW1uqtJg6RioKR+v88hMmLqMQra5N01ZUMVYdWsGcckh5g580iCG38KI+l281ff6xZB8tW2kOKz1ilT56KqoO5wIJzZD+TdJ1lsR6qGMKkgTwS0L3Upn7+SL3YcoGG0bzoVvsMM+vhD9GkTrnaky3ajXJaZfTZ1ZhW+ttdqhvuCYBNmqrkGCOcKtRECX/FpjZYiPXaZaL0mbeL6wUmxknz5aOC6tlXBCsnMIKYbm+RHbJr1YiCqs1Eyr1rAHLXA8W3tld4RP58qVwBh8YB2UWpIKE0iiWytbAqJWzRK9uYbrZLwRW1ySf2WKYuDLOlDthcNcI3jry0JXTUsmygoltf0lJiWZ0xZKkU3++QX1J43z6zMBasyxQwzPGfkG4CLlxwHxhyZOXRJPgtBS/fImnGLZtfw287kaJK0Mu5+SmdDcAoxIUXCK9GJsuFUhQ+XE5H3Y53y2otea01pzXmguDLVNhhgcHJSuAP8aCxpV5RvvOOu17xmaYbNTHRh3SaGKYbqYjgDNfc7QG2diW0+hO10AXAz0kRwyYRmYzlXQz/XWacb4tnZixlx9Y9ELPqmkp/9q8YEfJ1FjDZ/UuWLN3qWmHLoHKTi5v80nXqNpitlnNeMYP2SEpxQgUE1AV3Fg1YAhadFTNvCnQjIr3Maq84NyorQfPWwIqFD059fxuHH+X9oDOW9pZAukYVcRvB9HPn95DWAAN8ltDhDXkqlwJJgZWpl2KK0ChH3g0TDOhYn1YcA7KddrW1HZMWM3luvcwReju4dCe1hx7uggwnJMVNDBWEgCkJDUgAAjswWO8rrru07Tfdyc8B9F8RquN6BBarEHLi4E9NGGLO4AaJEYTfBoLn8Td8h6Cx+Lc8knwLfpDnHlP7cAs16cNe1Cf4iE3gp03SD0Aw+tjomHRzwMCh2YSeCRT0N4C9As3Yn5nro9HTrwtF0bX1Z6vu9C0nP7gPhZVOKAJIO9/J12MSUx9uVip1sUhvez5xlULVXlHgmxOJs48r8EI1+mKAsGqAoNVBaarCnSBBvrwrwP/xjh45CkLegnX8/tvYB3bHbd4A9+H7pEXXbuTa++bO8Q4u6deBKvzxo2Oh944jw19QudIoj3FLg9zgDrXTsk8OSXzxyIdU5Cec4dT+G3r82skL0cOMcONnJmfq1E8Yx8FeY7E/Wf7jVsUkQnaV9dcJ19dmN5qpPQwt6NCZVNTk74SZKZzEq+01NMl0Nlh6IyB9Of2vBBy7gXfmGJHZoyQ1zHMWAu+83Fuw/e2dpzb1LVEGcr2I4hZfXxklhc7KPHDibgICzX/8uWLZI7ql3KCofRcJyRCHpmCKRRKO4gWMTKwVXaroAdAAfuEeZABf0Aw15BAnMvMSql+bJNQcF1TlDKseeG4cX2IOYf5AAEcWwP8aFmtuJjVaVxDxY59bRi1vJxBqpR4lWP72uoq1Y5JtWOspkI/NqGslL/oH8zhe9+eG3HIubk0GTA59WPtZBxrJuN49WQcZ07GcXIyWprJOF4+GQ4UsFts7MvQU0yASSD9Zd+BX9FSfMqscQNToMzYxi/Ar7AAji98zK25KQpv+jjSZN54Ui3OW5Dtq2l3zL+0nKyR3f2LEGaA/Q1MneKGpOMKzAlJZg3kGemZna6TfPbKylz2h/mZaYtFD5iE3GRj5r2C+AHfuJw2ArUVqFXUMe0mH4JlKJipEomRQHH+xoZGSQOye1KCda7f6xtNIfWJsvUHxoxHxqj9HZ1f0uPaMixjJEH+1PHvQhMGtLB6uAqriVUmj1VDuxocUNHMBpx/J36rsFpjRcZdhMW9Ep5u9T+3SVRil0w/fbUdKH6dQWr+Vaov2IJyUlTfSlH959Vk//nX6P6ZvV67S8/gcH9Hd9fgcVTi+9v678ldLayilb9zILyVrcNALR+l/4dYozyu3WViemE1z/jvYZ5rzMeybq1sotC1xBCZKySn38FXV9DOf48g8Svr793vXn/PW3xEWO7ZVN2ekbWLf5r4Z0Q2L7d46g2HLbcTOai1a8RY5ptr9TBuOnp9LCs8dn1aUGsZaPqR1xx6Trimwp/UfeardZ95pu4zl3Uf2hOq8tzd59FEkKX06JOLT2RQZmYAVUHjMTMXBBl1c4DFlpUxmKLOIK4khFeVbHDmDjbaslc1aw4h+1UF93I6IO88383rzSjXMLPkwUo3f2y1DPHdLFfgp7HgxtDXwQ2dIjH73DJmEQswMeWH1AQ6/PkzfPCpCdThJlBqsQhsjPRM/WSC3kY3svABiyn861KjKAUB1Yg9j2YCqPq0MBDmyY49MKdongwfOtieczi1O7WB3Vl07UGhbHWJUbTLjaJ9AoDA7hP0ngG7MTwEuDWAv+jbU1B4+wc+MX0SoCSQUb/QPahsuuw4Xlib4VtL9ojrSGa4rU2sZeKLuWN7UtQeJ4UPXVCnm0SjLVOt1OpZ1KRaHzX6gG/nYWaajzabsnHxzhoX7w2rZ4cPIzTF3thQQe/95nJvN6iFanzxHrEpfqt3gw1a++AGennDQBkW/Wz0ILEnEkemWZ8NPGAZgNDLlyT5W2POaT6jZ8xGT0sDWzGApNcqemMYdXH0ely8L7Sguwfoyq+OxDGMxDGOhJrcgmSssXTQR4/iZhSrPbY6dqcYDr0O3vueGdbsAN22xcIK857VgVTh0hmkJ5zOtmCPY7tbHzfsfn0M3LDzMC50H7MxGj8a9WRrtC0OrgPgOkARHTSmxgveszJhdh6NJZlm+dEQpnZAXeIB9CRvOSuwAn6QFw9AZdPH1yimdJH7wBdjflE+CGKGUWkMVY7RTXEM2VYdA2mwZU1zcVl3Cn2xrC/tvtmhy/qSNDk87NiXtb59uRjb/QIaskrEisV4RjPmGU3E6iB4BvRKIzgEyDVoYYEmrTLszJRrNCnXwDojawYLdIxr2jquj6T51x2Xhg83MGWDh6lEz6PiXdkaFe8vzi/pimvZ+Kt5Z7Vtmmyd2KTQNTNL1m8adrNurNdY64BCA7Q5YMNqNyhkSOSNGNa1aQIed5WDEzwTUnA8wT2lXWiRVZrIMkmdg7LVhiVJMIUtJ9UFwN2AjdasXx+UNOA5DlmwGeKEUzt0troruu8YdRVaF8ewq22oi0h3aRucb0wP6NnYQDCNKV76kFfwAHo8XWAKueX1iTwuzXzOyNuUXNqRD5N8UFQTDxmx92MK2nQ8zcxrDnZdYUEQDMkBAnEaXpG+Rc1ENYeKaiz1wREiGPdqkHLQxT9QEjwflw97Fole+hzi3VOspu2EYSmFA4McbGb1zBo2Aj6dw/rQDqD57oL7Dyw9zB5mD5dvoIQ1tdXiAcsANqxI1Xf3bz7Kw4NfqFCd7ZGuy1vhyJftPAucZQoiGtLR3TPpiBznkztTSCPZsst/F4kgZhkEgZ7x8fRPxfRPF8vcRwLe3WdOpW7C2PqxGG0gzTzDmbKdOa3cCSGWujmHiHdY/cRueOqTcPJPdhL9TN6BTyWtYB9kOuND0rdu+rG6gR0cxmQV1mJS4yassO7//BlzR9DaPKJuDizREPmexIO7ESIjPnbz5Z2tvW2jPi0iEBJvGCUUGxZIMf4VHFZqXKrwNA/RbcpxWnWv273S1TLqTOEo2PpsqoTk804BymTxHkMLGzVIs4xDlI9WKN+0HUkwSsIT71gxUaeQWcCw+g0+4gZnAE2A2gQpswlrnqy8kcImu2ZzU9eDbGY7JAsREB0dwB7/Y6Tj2yPSqZmdBZ2MDGSwZ39RxDooYawDbZsvoB1ZdCfExh67tQSZWiMrRabWyLCE6jEzGmW3sPPypVdU3uBLgR6vA1ZH+2Y+OCxUahVQseiPaq1QhR8GneQbeyYe8RyjwhclTntvgAHER7swxD16sHvQIce57JdhvfC5HwNTB2nLW7UtbIypHRTm9WkM1ZNtJXOyBy0IwVGbQjHyoqGLDhwUejOFn1rSEj8VnDlyo8QaHxXl9T1KrfhRsT3xRiN8d6PEyId2q1No8pPnjsm/mhWDGr/d+BhCIsS24HrCQ6xC94/2xPFDfCcmD4K8BeAJfVyfv6rUxDc+u2IIl3Zc+cVGVw44RoilhQ5LcdvGomPavC8L3WaQ71Amom4KRGi4CHwvCiZ38g7DHZ28It0ccCtw7NTLOL7lS7dfi+rzOOjWtFysgK0j779yYh5XQXdyDROG5lkxkMobHvMYG5isMI7ICpsk3SbSvKWuLLyk57C6dDWcqaxZzbpidMV2QWsd1LsBswwkni7uE3pno7FVLpY393a2SyViZlLefUJqII8Sd9TXja2O9JqxVTZAvegf2GS06HyOM6SiPp1hZMarx2NsTfFfYRuDntvK00SH3XSfiuL9ZqdIqcaoLS3GtrA0u+imHLtjRiEvsKyCukR1fY2BNRCe+KoCHeTrCWbPWPQ5rS2oqavfIEtDuInevcMH0xLLp05vMCoPZGU+OWZERenRteTI+skhc6Uh88TIojex5P0mvYKZigy+mU9GqHcLUZE/sgWSCF5BrPu20ygd4lvYxAoX5QuO5F8nNUxztZkL4a8pdBTF9zu1hGJm0SiXuGxbZmqLug348jYgZNxYHIVR1LwwB1LtYXqZ1gSjr4daaTRmBUPNuh8azLgt6VUo+q7ggVM7HxCpj8t5zBUz7V7MZTB09mtpz1VaSUfKVnwuAiJSX4rPlO9byZIiQhO9yewJYrD7ZAPw1iZlKlgnuTiMB+soMCbq7UvGqE+de8kTwIRik/ogKWzEFsEuRchMN0JbKcSoG7zFRbdB8qgnoScJ5R0UlNWuvcjsGpGcugYKP/whOYJ+gWBUp1zWK0pPy0nZlqxxI42tKc6D0G2N6hRnm4m8VKQZ42Prp8MA2ulKC98gpkTGk2aw0MZWnwuNSbY6kqVEkCLL1EjY21y2Lo1X08YN5ZV1o2eadSo/ypvKrNARg4+yFXpCsq2vlWRmM4OrKrj1VfjGtz7B/Yir21s7VQqAcuG23ZK2xfosYy9tqXupmW8fVA/LNRC48GkNZmtfs7LVSmzE2LtZ41i44KOcPDtgBg6GpX5rnnGDxYDoSe2GnZoVfHE6of9kKDdtSZtu67RpnRrStoZm3gGduQCCLPtRqNaqKF5oqMxaRWE3bFs9aBJT+I3w6YVOzP93jzj7JuTlkVblYMZXhhLoRgIysFFE1qcG32N7Zs34krfkacBzaLafzxrMplRfosK0flGFCdNzvGxPKDAHXKpkWCfazcpsmtV4wyo0C8KNtlysqvLQL6kbZGRPYASbsfcuYJNQLtjTp/lmQrug6Ysx3hD4Rh/gxLvxLHQhDWDAXn9fMhD89Ck8KB16r8JaaYHLrh00p8jqxJETv6Gdy1m+svk69kPurePnrNyp+wR/L5wJPl40npDvc/j7duqTv0NMn/bxKUd3DH+vOhH8vQy+4ouRbif3KA6sqEWTbJ1S7xALEv0DihACWptxUZEhJdyhIvQQSGzkEQQF8pswHPmOA8gLJONNMMWnsmX5r8sEg0aFHIXjczVdbomiwD1/GrmJWn25Vp/U6vOtktSiAmSiVkeu1SG1OgbbECWOxpodDr2QQ3lVVh/mGcuQxjKk5mpIKij/wOZKVGjaAzO3kTOnaDculg8hIR+SCyaQWoM1bnZN+DT75G/HxJeMxrVhY72STSi5U1pVFApt7ZSWFIMCEsLpMm9y0kUDpJuWO3Tw8RkmbcRyiYUSKZDRCsG/VELB31MEfxjEOg5XQvIfSEMbCJFfTV1wBhESYf+19GKQLPK/yIzJoJ5RxCGt3wXKq5FkPdrk3v/Pn37xrpEdAwrz7xvZkcdIfRYXSb6aP1t+IEPAaqoNVkUsYx3MvjBFtZh14xWhnQXvAOKfv3wNTOgY6IjT1eoYXY3vVjfTMaubvJTSt5P5Pc/vHg+DEERmquk4xW/WizLwIRGYbwrl7L41eMhykUiPC1ahGg4JgfmQbHWOaih5hvKR3CtdtyzeHTWsfNAo/fw5PIhjAGC5+4KPniXk8EqXY+XTZN91I5c8aSkiSNoImYfgWlpUjkGArdxBK3dGY42a9BSta1AJKSCmdzrtA7yzyUL1qDA8ZwRgJlQo6dOC9ysLduzsEsxB8QRY+DhM+KYBcCqMdK2+1UHfGurFphaWoaKwygvTfcdq1nFpZ5+c5qPsY9XslQ9y2eEYllttbJctZAKZrAV92X/l6A8aaGIDTWbTGLFpMcebmo7TOCfvyPJE6Y+oWzM2QWZzc3kN1UFQGP2SIysQKO6WdjdXzbpoe/3SCHslptb6neIEs16vfmfL1siacW07l4uvoMpVUFcjt1YvYSDQx860k+RP5XLzn/85+Y9/6oIYIQjcsW8iZzTmCsoUa36rc3BJebmVPqKGHZm2sdAiSt4C4UeCYqeHndcrvlayrlsnx+c351eXny+v3p1fnLdFYQOwIXjNJdHMTHZ36ntRbLBs2atQ6bphZ+KNkatZbZueuwyDfrnEbEf5Fmylcsv0pKytb5k5U7upI7Q0Gky32zasOT9DE/7fCn0ptw3lnKTb9zHA4edQfwVQfQyKUt7VODVoqjLPb6DVQv744KBsoAtayg08ozauHX1N4XadOXT6ZMbtR2Zm/wlXYy0uLYXXdp85CIX5rw9DRt01B+L541CYP2MkqF8Qfe0r6T+ihhQkJUSYRW52r0cJMVU+DmuLb5mGQmup78hSWVd4Jy8DZqD4u6p6+oROIIBHkEtRRG0I5OpCuR6te+8B/VunjezRpdEvtOOPAS64IvRjQFw0BmljQ4qFc62ha78gURzq2dDRMDHJNky0Tt412+cfTg7l6lw3BO7StzPgfuNnLqauZg0wK9dWV7b6ByD9F1ArHbx82W8Mi99M9qPLzzCXe4n3MRArCH14E0bnS5KBwZxjsBmQHTwL0whIoDhxx0On4+Zz//mffs76J27PM5sbg4kvS9FDbeGql8/9I2cQ6TqRetFs/XHSap9fnPAC8q73y7P2RzF0O0QoGDu+OB9cOeoDFsQuKS6srKgjxfrIHsVDpPTUahF9Qx6ID813tyd0CNY730rqntIRl6G2TEGb+ZYaE8SEObFyOel0tG0nIaZ00r71ooT+yW0Wa7AtiRQlo5YrFHL19Vs/SQ3D7eV5+zmjkDUEhyoSBGzmCNTWLpxsDkUmI0np707OTi5f/w29YIDX7cfS4skmqZSthkmWSP0aHw9Fvp8M357PZBGpKvmRQb39dUcjGUBiIbNn3ySEzFRhVUBMZSfFzbk4dPldILWOtFlVmcw1LuR7RGZqFvJz8qWHnHdOVLcoU/xKY4o+KUtg0WtIdc2DQgm2ThwJ+KNCdLMnSTSgx7HNGzGXD5nyhI8Mhl4dBzgmhVNYCw6LQon12LVP4lSSOB9bRkVL8tTznmOraWSVpo/PUyNz4phw2bzEohbOx1jMz3NANE02p2ON/EepRV/dmUxAyQaJiV00WrX1H1SqfBt+4NfpCqtgC/TErcmx+Qt1RNLKysYjW23XwXDeD/z8sgp0qdFdd1X3G7v/nd1nhFH4e7oP/zGnSaLKGOJwgr3vLF1dk0hFeqeZblroOvzjb9aI+M45RL/VRgYi9aEsCcXZD0NJf5AjwSpFcOMOivObjjN0iVm7IQ4ARPBNin9lMxBqZ5Di+oNGuURVFHJkRHWf5BYXEOZqBZQZUctc156KPU00YKYaAFVmGu9Uywp24lhNgXTx/lqN0vQPGPpUHmHvR1et1yetWic+oZfZuL4e4edSxcSMrwbAD4HvalQ4eM6FnE7WBZdi8ykMhtPIvePrmgO8MURclwXVpKQx4zEG0iP2IZGDsW9Yr8exu3Sit6lK1PFOqpdyxF0BgA/WvbZ2QT8G92IMwgeF4B9ZhNZUMjneicdJjM8Y186byXdZSFBmNRYVrk5rnYLdNYNUBIhMkpAEBKxt2pl1uTiALbyqaLH8MIkSWPLBpM00j64+nNTGBRsXkhpbImMSaL2jk3dXH2tjRE5bi6OGkAVqOsEwEDJgh0gF+KdLDpUIc0it7gPhEZSEgwKCDgZzFlBdRdVRaickvr6blPiaiTsFJaspOZsqEZKUylTOS9auKLUriTFrpu4vNBXH1njVjljAj465hB/SY5Xx6iKMDR8cQIv5qeQ/hRfVZSkTRz7BygPFXgmyI/WRiwaw8ZK4wMSX9AT24Uk+d+z4fhBtTIj1zJ1s4H60QSZi43/lzKGipVkbfrARTjuDjfsNB7b1HO7fqJGzG+dkqWoeZ4gDupI728lwIg1h1CxwX+ISeZEhUY7FzgW6CHxgIy6eKuRzwyD4AvjhdfuNnBkl9+kUFLJDKxCgANQcmrmNh5wZl8ctG0eDXGA3c8WiNlNN6gCji8hNeTP3mDPqwq+QuG7WuZeSVMl/tAL5t0PGKDoYUvBDCaQIV1wokiC3USOIEeSZjskyD+xhOpd6vjdsVjHQQHfIZQfbhvUn3PHY7Ozvk3vaBR+fFuIQsT0WT8B08E73VO7OAKTCBggLpLmp1NwhtIEhkn17YNTg+4B8xzAElKTQ4hXiARohqnOfkdhS6oqbjR6Zf58SW7lhh+khKckeLXpYFG36Ai4H4SempCzFkPaJ2we71F8ncuuw4DTiQYsxcXAonNqwHrCgzlachweGh0M7qDl2sFhQ+7Z0fThqVPEuHfxVuxIueXVN9yIbF4sybj7bUebtWf7wrK4pW3fptiXy3OLNKAighN+/CLquPYNdF0C+nzpDL5qzsayKtdzD0WykH1Wt92RxmzqJ9BLXnI/xIEEVfXN7OStRRTiGiuip7CqZQ4LKOvaxscj0GFAsTpl3HEA+OyzVdA/UHT0HDJXYYki6KFosXrI+Wnaqff5EEJRu4m7gYDuxAkYacRIZBBJ/4UcDTNs/Ei84O7tqZN/mzqrbFnXrkgdofJ8lbQh3ZbMEWo/ra89etj+JPaxl9gsyraWvgMWPhRHNcD2q/xEsuYny7AhfsSeVbfeWBfHKjp+sCRRGYikH8uWWwJoUpcj9K57Ys7Lgk5jKwCOXFiBcmz+gGa/0TjAagwpC3jppguwSuWP0j8zmZBmU924Z1baW123FVLveZNNJnRTjkAPZhM17apVi6tZ6WdmJkVkaLOBwXlvC0teHRaRwBKZ7NUeYSNDBdpnj6IvsjczgI655zZoyiV7qFZ4Jc9ZlnvoZvqN45EzM1/Lzqav49LBWqqeeQXNFsbyWIy95JrWVmcN07162/5o5z2bOhfkSzm3avQUd1KETRu1gTBXMF8ucd0XxoyCKglF2jaPEvGkeJldazW7U0ra5pMnEg/PKe9MxGqAyhVFefazeUn6iyTTbs4Vr1c+Z5nZmzi/Ho7Ge/6RctpOkGDqivbZlk0Bezrl2/eSwinQcWMdVkslo6kEby5x/BND/WYNspJ7v+J/VvfV2PyHSSeG4Vm9/bOdLhF/KrMfeCXfl0wjrucIkiyfAomb+nXv7s7buQW1KcHtOJRrHgW8K627seCfAJI9u/I+m28wXa5/xPvUa7uz5FY8Lc+cyslHGgRd/1/vczx8zGJnm3/6g97J5Gdnj4jdrZjcxIKn9GwlIu5ZV1aqnUa16mRdwerFSlYim3NMEXBYPGiUKxnpbvZvKHGu3QzxgUaR1VJu0McbkQtkNP0oQUw2xWLOrmxPEvRwn/ujQsV3O6FrBPiaRfbQLdK5boH8hFNyr47UHCZu3M7CCXQe0UmLfzG1ubmCBDXwcs4CvY26E/BGtnhJJQPJLTNnge9YMGb7VzswfkfwT9Eu9tleQHzW8t9DrtU1cX6FaGUOQXkMC/mEJJzzeqhT4oWUWQUE+lZPaxEHttFEy4iMJdhqRRHSDG6X9Dc//6gy97gZxa9vI58xTM2fkCKjLvwrqEkC9YLAOVg7Gb2iLNXb6dzd2ShrD1nBijmJqyDKv96xLDKJ8tk7JUwx5dUWdmi9t+9S4so8KZ3UeaPmycWr8uMqkrYdTflxyZh4J7nprX5rl+m3jtH4L3PTKzK5+y6qTw7e38v3jq1c3ZHTfNtruz59ttyG5Pd4CureNFaNO2u6bKJKl46rrZLOutQzNtKFK1w9yOcnqrNHj2D/2Vl5W/KJN/q3xSnxvu4aBwbDcNFgSWxd/3D5ac2oeiUNg4zONY7fhuqmxGeM7jZBvp/NIEGUABTl9Nzqa9nruZEzfWTcsPp4ZMar1wyq18TB22VAmE8fRMRnAuSvGMKPIgp6EKqd/6Gy04UzcjWAael2XHIAi780R3yyNOqAzV6n8WxTY2NzMZZmc+OPH1nyJHfcMpuFMK2ycJb10z5SIQnPZ6Dq3kiUTEYWSuN1NMA9BuN8imCKAUC6WMAoNF3N7TJLqCTG2lxJbk/CK8SafzhIWBbTeELmRzNgLu8MFJ9075kKoigGyHGZ/StgA2b10V41ZrswffW06nkP+5rsK6YVi09BZGnW17G7QmWIzxc7EdSL3ZOjSRjsOcO5Q3xT1BLDZiGtLUPMkFKGijG4g7Q6hwzOc7kT3D89st3ZGrDFBpOuQxdsWDeyXYI9IaHiCFKBYW3zjZNISZBKX4gZLoXH1JEn+LNOcFs+1eCXldzYtB06UwynHr55IhtxBIBkXqPjz1v5F+n+1dFXVNVtYGkmydfEVLWXj5qGcivIdIVEGD2HmGVnOtzoN++WSa+piT9EvZlp0TorOs4titOjMqU5gEId97knxetylY/oWDfY92dkZsClAD3jOEkogYVOBCXohsGdgpN2MiTXShLHWjHO17sp6W+/JB4K6wnU699tIJcuoF6ZFq4D3uMK9bBnAupuvrp9YWJa8bMdk+/9mfbXn8KHbXIhS9AZvZpP7yrdR8V5OKWJYxfi96DdA7W+0O+AbSumqVv1GDmtxlrErC4XqjaxQWT1ZNY7hfcU9uaVMw3c3VUpSxAGpbipftI5K+dWKRqy3Sws436y3hSsi1lKUrwrFKtS5Ql8cIRxeuTaUql8V7Ct389Z6a5LPBa/C9vK5LdNTW9CT0HDzAIRdmnftJQzKuvAki+cVCpBX6kPf2I2kNHmF0uSFZ9pZBR+uXC72kiglnizpX3ivblwiwfQ9jbD/LCSy5P2edZaU75PopQV8bQdgbVhfDWWCdOJ730vL77dpgovld2jA+h6pAvwVOkJeRY3btAB/FaFmFcHK0wvwAOr2FwR4Ok4SzIeriA1NMpEL7N/ZkCwW6os58ppXzOVvuLn8u7tEaL7Bab/RPzJ/k3pl/sZVvR/eJA11WCC21OVp01y0/u5aqcLxUgXp+rssRkPpslnZvDUEB6B2ozd046Vb5hXumFf2d7aPvk2VhOVPS77Fkm9JydQDHQxKCeqXDcYuSIrEKwTLeyYzWHugk9bQZ451emS5BLOSs9+4CmtP8GOEJTNkwlqAfy1jb32Zvd1iz28TnOXG1VgSCGtJ8je55MOtwuA4U6AMru+9uqAB7ICNaawZz0NjfQ6XQjDN4vR9SPK4Wz2Pu3JTPK6uaOWXYkrz98278xv7/PLNSeu8bVgbJDoLmWL0SO66fuhF8w0v3Pi/ORM4eW4cha/IpfwNVOTQNZixyu9ul7o3D92vkJszb126sQHHS3ctNo8Ae71KsNceIQav8T1KDXXPg6GGfDudR9grgIKcX2SvEsyHnsemJZnI2etVzF51nFUbAeFNdgSEN4kbTN9d/Y3/Hr/xnwEkDkiQVeKvhEIggWGB756tusaYlMmAi95J6iP7mRKQFykdNO0AcbYsVHvsqbCW1molFdPUywBIGXq1QdZkpRDmaTtW6EZkIplLEtVF2ObAbT58izAWZ4pNLGFM+PkTeu+FMMewJS/o6c8SVdwsW60V+W07074AkhF5FvMkuwgpIMX0O9FgTN1KzkdO39WaP9rWiVVJj5rO9cV95tRD/+TJl1NTSl5ZGzlLDz6TirR5f6kpfU+W6IiE517/tlNqWO3W5d9+6IytnC6Jcaiz7DI+eA3qMFY/+rXql7R6xqPBcb3OdBIGkyNxcfxT/rR4V5Bn5Qh+Q5pZWWr2KJSNFbPPWhI0QNpJ2Vmk1GfTV7KFI3wHNdWClKpvQb5YzE7JMl3mmbi5tst8xmvLNx5OzpEXXQPmKIVg4O9TL5KYN4v5tNwTiVzz+GW//FKmX37ifvUqJGLVQ0JIH0BW9qKKOwuMEdiqfJsb9ufFH+78dTDzafBpEjehg7dA7FwTb4e/c3tRjgelLlY2V7vByAkw5Z9HWvfygpd0MC/wLk2I1T9P7+MryLSQsP4ObMwUNmYKGxWV23GOUSmJvPtx4AKByhwtFSUXLxRlODOTyA1lEtJDbgOn5Xe3UoBmFhIwKeQ4UQLGwSxfLlaqVvSqXCnh8zUZ7lWbHrlAeJCR/fJleFB2t/D5hhVT9Mo7qFQ34wcJeEw17S0NEy8Q3WW7BhmvMvAprKoXsotOK9BdSlApdDPumpjOKy/bby1MEF48Wydf2bU7ESUeC950JpWT4Qimb+J9K46mw8gbD+dH8w95AIkh0+/uj0Hj68JiGsP6v7Po572BcX+uqc4D8+yBkI2h4e/rGQSHIfGgbtcdRs79QemwUK6WavAPE8cTF3FjViBAelG/c4uf2dVdfkcauFD/E/TxhOou9osylurQU8Jjss9Q3e6rM9k4ntidoROG5IppNJl2YDPKGz8IcsE0cictp+tNQ365jYTUV5PI3kzuligpJ36X/553AGl3wn9+U3/SZdMOxmoC9WfnadTCxCUBO45TTR4ii4uwJ4uU69aMBIACVgPhpZbAcb6tA4eVWo0PvhWgVBEJX9mvxcLqRHSWNiYb1LAWbrz70cc72J4Ps6Xs9JC0CFmWS181YrHBP0MTL1++eFekq+l44Ha+vOZnB/rL0heev9GhF6af3I0+OcOdQEOOvwHA0OFGQFYuTqOfkkDHFibDAfBa0smGyBRe8nGmLTKTuwPpMvCBZJedb7TLkMW63LClFp7XZehX3OUhbOesvzAUcX89P6u/zjdNfw+kCcjsL5o00/2lmgco7MleiwztdYPx868bWIn61CHx2Blz10MpC2iQZKQqSTiTtvRYkywyZ3JRlzEeuZAYTKlb4paMOlAgm/WJFZHeUEm1nMinzScrxTgkcmJEUpd1lqFRWYFGRYdGJRONytpoqJOrnwaRLU1FXIUvpVLGShElN0bTkKwWZ4Oaur66G4R7iVWRAL10Uj+PQUTK6pbE5d0UbSmZpEtqcTGoSjJHRuUyng/rMashNZezW7mCaEpN17YVZU1SpExP9HdMjABKBVPkoPQL7h7WXgkfjVpjWqDezdh1uxrOTNI5e6aFBI/O6gApthp5DtB2Y9rQ0kRMCwka0M5HR8s+OjHT6CRYRUdhEGlYFS2sSgyrkoBV0cLCG/tJSJjGCfYC6SxdJM4hBXHfYZeREwXjHIKZVFBgF6eJJbyMLLpeOB46cwx4kGxMyiKtyUVFc1JiVnvL+CD2OfS+u8cDpK0YrACxkKVeFmginI6Jhs91B3mjZtIoEWrEdxgLjMxMtQR6LAHjQ2Pw23tpBYRsy8NoGQeU97/PxaMh7AGZvU1vVJ+JPtKc9J/ylWrVqmyX+D/DythUklWgP+xfxrVHu2rpWKmEVoLxSTkxz6lUrcRKLpZluGKQO7xnZxOX3/HgS+VzseXy0zxcDgkkGO3LqRIVc8NRkqzQlxDNOdfOhL4PEVIhnstOMmVOiP2f/Sq+Pr+5fte83y9pUMDAzFQeI5lWzGqpXcHino3Gq3LVyhv2AaXYBCEnARsLQ4NWpIzJM5quWpI/58TFhltTUHRGxL7IfolDqfbV0VX7DQvEwlwqXSsJlThQsovJxzQegTq8oPim6qRNevVQOmvpDF2HHlh0r57+BH0szAupKb1M4kWvb188ChUV7FDY+ENhD/cwuS2SebA4FkunUC1o14nl2F5m3tCOXlUwcI7F7k+yB1cTGmUnoT+ipkwe4iTpf0Z50stcjsf+llKUYLNpmmY6pm4l0+DSUo4cZFpTISYtlmGkFhvXUDR4CG1YyztkXKjmlcAkIXxJqIwUN+tkq1zlXt0q0W/XbxVVuVHqDY9VvU9xDPpO5Wx9QKxDGYBWtZ9trVjSlrZS0x7xRTxTX9nkPw0Ny2IB8DL4aQ3jZzUxZhb8DWzfCg4c/cIiT0qxvJSSGxz42hxSyc+oNKDi8fU5vsfNv2cOTWzSClaUEVaursRcHGsocSBgEWbwqlJomnomAo1s4uN5hcTmSt+L4MxkWKCBCemH+IMvtcuRATupWIG/sIiTprFhIR+YY3OkvCXa1XeHPHnAIrKSk64m+ViXduWwiOtWScZWXEXwqe5l96RbCMx8UBgXZkrfaZ+smdTPdddZ8TmY/mIHWTX6cTp0+iCoGXKQSe0CLe+xFcrem0ruRDdrc7GvEguLX+uFxQmrQLc812MEn38XJyhJHKBrB/rZBz6xfGH+Rt6RXON6jMym/CyxVdkkhUX8/XKKG5T/f27wS9wAu5dY8Eu6N3tW9343L1i9rCu7pRrbbF9V6HrC2+awdthPX1w+/x3UHLAFtrUZb7jy3uitXFj6HY+RO/1YRefl30LnS7YFMz8mS4BrXJUUoY/Udfn/NL1r+rKU4KWe/Q/bA7d2SjWMaM/WS3GvKtYM+f43rpvN4q6yULL3pQF7ohDW1jastOpm/Ou/YWXRQ/Ze/ErtmOLTCcL8AG9n2SwB88iX0PMxx6zE6ShjGZtS7qstZiN+1sbUo6Q7LzQ1K/LfvfWUf2Ep9vi+k+jIf+smU17QmOGy+VcDQ/Y2yCZ62QFhnFlK8kkYLC+EbgrTzCLcc6GbWYI7M2SaDZOuC/3lBZk23ckqlYiKnGlcXh5uOMuXT7wg+Fvj48pBmpfZ3jQ1hWc+sd7Re+YspHhlU6EZzsU28/HMFmRKMF7lK7wQc2BKWutxdQR2NoBhXTYliufLK5uw9MqGiISWeH7RHpJnFtmr1jJEc7oZSCAfBqb5aLOHaARpmZpuInPsGpYg0IKmDDLCrmEsYmQAjwPEqFD4K8hIKzATmVQZjkwcAvU5ESgTBxwZhxhGyhfhb3OMGAKD+zPwfNtxCbN7C9+LLUSFR8VU3wRS4mGS4U0fLr2QzbB0ghxbPR3hnpixx9yIvQtaF1uhBKSQbMJoOIcZziekQi3DTYdkpmqatpOqULCdhRJdXuTgUvYPJNeeH77iFONLXjDMSTDvy71M9p1YdocqCWcu3U0HxJ5MjjH8FUYxtVP1BiCBKWxhgGyBPIMq4sxgmJmGPaiPOUto2hLS481pvfvQfw4faK7BB5oSHxhj48gHxpwPPAMD7eJvrrH4m+zhwU7M0tmZni0f5hn0rOOLq5SRrteN5eLlojMcDxyrqSYOpq54NpUlhQ7IHmSzsmZqznAKhITuBXMePo+hwmD31ESEPVeTJNjHao4EuyVfchyb+RsUWB183+clHri24wXcKzSNhl2u7B627aZJfm46UK6Wx9+V6g5Jwy803WofwHdYQe2CjYl09ZzYIzM/L4xYmWt7ZuaPCzP6sy5GGT8+51+UrBa583NtYBxLmX91rG7iJoHmEhC92ZBgeZxZKkzPTT7ksrYNMP7K3nlJSlaWIkFpT5/Wbj37QCaZwJBZW9dYUxd4xkhln/k8F9ekWrGmuG/8Xbc2Mq5STLjUeh2E0fUk6EAx4ob5Y+mWylz8hXPIop7vTf0Ouf83MX5Q/1pX+NcOXcUlmj3IR51D8EcEEBQbwIk/HZ1H7sh26xRWJGB13R+LKD7IIovPzedEQs7K7Zf+89tRKUdeoxT29ERBSIGS8DdZtLKbLAopUBT+Jotu7SSLQgoUhb+sqNIpO1oY+U708yf8sX8sgLmg03jggS74r9AulK1/wN+K9Rb+blnv4e+2BeJVoWpF8HfHmsDfXSuEv3uWD3/3LQf+lkHKxo+yBYpToVyxhvhryxrgx7Y1xY+q1cWPHauDH7vWZ/zYs/r4sW/14KNSssb4UbZGvl0pb+9u723tbO9aT1jEmnn2fqWytbVbKW3t7FW3d3d33C2r6doFFjTgonn3mTyMbL23cy/OL+H7+esXOavpg+Y9B4jWzLe3rRvf3rOOPE21M89OpY1C+701Qdf4Tghgvk0AzFNod8Kf3yZWE5LcbWse2hX4ePLsrRIZzTC0c2HOmsFHlLNu4GOas47h42vOasPHLGd9g49vOasFH/Oc5cPH9xyp+xpgUijtCTToAGzy6xxxOEEcriHJ+hLaW9ZlCP35ip47QWjvWMPQ3rXehdC9+9DeJ7UGmH4BFfaszwjgFAHMYOJP2UKpfQ6tG9cPg0ntNFxYn1zN5QF0WeeKadi33cXC+uil3NeJo59Sr1gsunyBke+UEbhY8CJkD7b7wIIs8c3O3QdQl8ACGmZXHEAY63zBm1puzvNpQy9fko9iqgQ9tJ/AWrY+R7rO8KsQk/7tZAhLG/fWyM450yjIWR766of4B0gF/rPw5DaXq7vFcOgB8JK1a9h2bhBF49qrV7nDfER/5CzX5mV2DaMWl69i+VkoSs9CuWxVKbvHYYcK8JBhsyVV3FMq7tBG5FZ0lXaUSqQn2G1SS8ZfKrSPhUK3A2OMxXDLFQX3Dd5ExMsAt8F88V72K9gjik9znzylbbkPrggj8AhwE/DwSSURM5QKPQFkikfAX+WMekCuKA9FncCwZACB0Nmlev+HRiod4NvhTE2OawxQmu/GhWtQuA8lD/MeJPNSfbzpw3/2UQeoQbbUNOoFC6qUSy3j+2lKFwC6RbowxT9BY0oMx0oBawrbb9Ao4etirjV8AeSH+i6jjNwhsK9Sjf8Mc0TRgjkwDPIGmTwUeC0JQI9Gn50o8PJiyBB9w3IARIe9Is6hbHPvkPEkiALubzYNgaszY84Y1hO/aTWA3dpmITXGxFLFxIYAt397uMCm+270BsolnEWxKs++dlJ+0tiKyMYLxolsSOLZt2HKmRvxFdmTIVAYGrHQMdDDGL/iDV7aSWDO4VOOXZ8j35l1C5Y9gwqSRj5k8U9IJTOHiwHGiokg2CKbKF4Ok+IhizNxhgUsB00RmAgkKlJxbKxkSbzWyn/Q8bW8ly/Dhzgux+MLtqCwKiInRrAVBGQc1FGSBghGBkboRckQY46dTA46ppECeMHNfboJOl/cSFeI3jIJP3rRII/8zmCBLPl4E1abSGPsgyNwM316TXqZgE+7TkoNnLA5jQZEiNUQAI44x/aGAM9GmDLPJEp0fS3BM3LD6NzvBW/DwM8Au6Srmtb0GNBejLtO5B65IZsbcpkxXnmRtGxfMGCMNuU0wi6kJlxDAg6yf8vtehNUTWRjNFnmrpVqLE0KhxJo75CMaQ0JoKamU0xqFEsJAVzpOJ5y5yiacuOcRK4mXt/zneFt611i8OnWLvdsEozExs9A0k+JwbmJJYtF4ENidS5dmjEuLl2XMtNz+epUhAyO0sK687JvZz5Ne0SSv/X8aKtCTU6cIT95UZjK5MeNnn/EqpJ0GpUnv7MtsvdE1T1aM64mymxVUvC1pR5Kj/wk68nrn/hdz2GWPmgHMl+I3GmPlN3dqlT3tsv7W3Ey7P7bpcoWSPPboAmI5Moj2jsqW3tb5VIlTt6C5F0As7W3uxePBsIuST8BZmnx+Wkegbr7FXRa9xwXJbeRYZQpt1HeqbvcShfZcZfcx7r8w85HBwcHle2f+QhtOUajQb+Xd3bL5Z29kgG5e5iwU63Ar0ZjD1NKi8XnaOL4IbSJHIk2m893rb7VMeyDfOe/ui/z/f/qGKQ0DKmU6aJdBsQMA/YoqUr3v7A8LR7KGf3/ynd//l8Byud51thqkhDSWMbum908STLM/IiUPCDvGNv5fqMxw+8/+/B3q1KYsRyzQ4qheCBNojW0pbmzAluaMmtgSzNlTeNhrTs2XjkCEdoKrIE1BUDm1k55u7QPGhzKn1AVCwxYkSnANrf2S1WgjV1QKcsV4iMGJQJWZgrtmTulnXKpugdKY3kX7cVYYMiKTAEFE+ittA0Et7NjVSrYExWL7Udzu1wGDXJva39fh0X10SxXSqXSXmm7sqPFYufRrOxVgCSr+9WqFo1daKSyvV/ZKW+BHqxDYw9a2d0tlbaq26AUa9DYh0a2tnaqQGO7+1o0yiVsZR+aqUJJLR7lMkIpbVd3AI9tLSJlGNMy9HUH9eqKdlq2sJ3q9g50Z7+qRwVGtbK7X9nfqZZKO3pUyLhCh7aqW5V9gUoko4JTU9kv75Z293ZAdSKYRBImOzi7iEl1Z2cblBOCRyTjASB2treAXezCuJe3KRqRhAYS4X6lXNrZ39+HASmlsQA8YWK3tkt7O6WqDgsc9629UnmntLelRQIh7Gxtb+/t7e+UtVhsI4S9fZy97T0tFjD91Z297W3ozZ4WCQRR2a2Wd2Ax7ejQwFkrl3ZhXre2qloskAahfnWrXC2VtVjg1Ff2qiX4tweTpsGjQih9CwisWq7o0NhFQsc539ve1U8JUiAQxh4up52KwMNT5wTHqrq3twvDsU3R8CQ0oCuVym4FpnYPl0KZ4uElSKMMa760VcJWyjsUEU9GZJsQOhDx7i7er9pKI4LraXdna38XltyODpFtpPLdyt4+DLoeEeQN5a397Z19JGItHkhgwIKgCaB0PR4wMTt70BKslm0dHoTOt4B6SiUooMMDWWV1t7K9DfO/q8UDlhuQDyzIvX0tEvtI57AagTxK+zokcGZh2wb6Km/jStBNC0xtdQtwBCZW0mKBMCr7+zuVvZ3tqsAjVDcW2FV2gFtuVyvWDsUjlPBAGixXdvb2y9vlKgkZE5ASCQYGAsYOsKh9wLRK8QglPAgNbu1Wt7Yq27Baymk8CCsFnr69V63ulnWI4HKCbWd/D/hPSY8IZeqABBDhlhYRpMHKNjSzvb2/q0UEFzYMO/B8WFM6PMqkM0AdVfivokUEN7ndre1dHLUdPR7Qm/JWCTAt72zvaxEhm+02MLntCuylOkRwzwcS3q3u7CMVahCBQd2F3uztwsrU4oFkuA8UtgdwqgQNWQDNSz9M5yXZMHd2K/tVKvLIQmle+mEOs4tW5KKAXpBddEsuCuM1SBZdON0uRqLKu1wu5VYwC43yzMuGSbzk1FkRgUMzHzUaW3KrNKcRMgWQScemqQjLpk1k3H1oIEQR8OXOVt1rRHUqMuPXly/Dxs523RCyfYhHyO6DBx8khhHkKlGHhDrAw94mhHF+WTSWkaFxkJo7zrAzHYKeJoRmuR8CuV5eYOIiJuXKnuUeVHcYxq6KLClSksfr2cgxnWG7LgIuc/2gRII983arO+l212pzEQMF9qP0WtK3YKna8sylMWU27ISOB6yUdF9RfSJEX9CjiySAI7y3mXdfbhmo7XCjVwTa6o3Wgi60889zZ+yJa9yk5CUa8SNxndf33U7kdk/90P6xYKkT919TN0ymDmbn3aM5qS7S8ETgaP4GcuI0cvKXTHxyQrc9xxd/iNY/cYk9lZ9xxBdBZUeWGDgMCfCtF2Xec5+/sQJfcrnDiJtg09Wgp1CxZNTwUWBRJO7Kg/9o2+7Ll10XWnY3NNkWgX6ohV1TqqXwRQ1SQU0CHMFCBVXyMDVmCNiraZNV16pEJprvQ0HGfLht6alcnhbCJkBmAWiv70bxJChqt9qdehQ/RkO7pOvRspGMHq3s0TIsXZ94k0o9tUhdChemUDPmeaLvMkWTAVZxSVQ0GI2GwfCrK4YFmL10DFCkRxZeo0TN1Xaqwy4hHeI+Scn2BzlXwymolSx+xlbL+cGGS0/ToMXpMKrxq1rGou7FW41r2tComVjJxXD6BOs+D5IKBj17F8zcybGDV7WzSpaN2CFQN9y/hqwLyHKjvOWTkeEPj5AjD46lZ9T9+Ldnsrdsh3bMrrjd+7X7FQ9DHDLOLzR44cG3QIyW3njImY6Ze9zAUFKBjz6DAtNcbkE2RXvIW8Ag386Qnijj/gJbNQ6xryHG6PGvTiU5LAPhirbO3SBIEG32rEAA20DQGNQDNIBxZNTi5918QEdsml6lEdn0p3zVTIFf/DK69LGEH9JcleOQ/M6G52tWDvcSdlKrxOFA0Gf3l9FyEK3lVHAZbPChQlLwkRR66P8FxLDRFSQCQ/so0wW3WJ9OPNfvDsn6TbBDlSNYJEZkVBRovLB5fMeNiPteF2kDkved2H/t3EXQnQ7dHN/xQr61eel5hT3I45Pqsf3E1xUzrGeOKL4+JNz8AAll4mAHC+OFSxw/04tUHjGxkfDOWY7BxgA0hqEKfGAHB6XDYdxAYNRAlYib9JE3ZA9KqBmUqe2tPwQDsrymCzr5obwPJsJQqlNf91ifDjV7B89D2UC/84jTkYxtN9mYQmU2Px/X7nic4Agb8BR+teHJFwKSSPFhDtUH5zKg26G6eSaA4bEmeWhF8WBMFEqOOX1dJTnwyb2e90XMu21Hhy/KNb1AFMnnpYmGdAGrRE1e54gJTOlocjSdlBs5UWcgSsaAYa4+hz9/utzXVqmECHmTMHrjTLozZ+Ked4ViJV6AcGMmK6Fn0OtwvBEO7dL9JgNz42OVSA+GBAMDNvQiF7MtxJW4e2Aqd0Al0VsWluPp9QxxBtkjzkFM08AXI6QTzz5QTnj8ZHsAyM9QWGw8+49XKYMKLBuP5+KQMsHTn58pHUqJTjj3O+ci9qnT6bjjKJDjH0XBkXvjKhGJQoy+HYiQqhKaUjVv5AbT6LybqNfWpPswBXLsG/L4oggsCsTux7+ePJ/3wpVcrsgSjxI+WDhon7znDNoSWKlBRFexpnAVy5zdzx1HnoXPk6l/GYhIUdOoc4OP94oEEGuGYfyrFcziX8T1AAdQpHSZK3ecAORzA/CGbniODu5AuCKvh+uGxTR4nazYCYbTkY97UWg/cDU8lp3i2fDC42EQkkC9IqX5tR//pK7BArDztS//pM644idZWFKLXvgucLoS9NfNdvMz83e0m2zKX9+2mu3zq8tUxucxrGJfkAbV4eUcmmRFMMVBbwP1MZBw6OOBXDFDvuD5XoQH62i7unGjPE7nAkGE7rEz9J6ak4mk3FjE3RY7McQ/Af4ZWFOyA9nuQ+nxVdndIiasxpNnqKH1OHGQV5o9jZhA2qOTRZ7gw9A9eJCq7FEpYMjDwlgDctgXGHffLtf9Rlg3nOJ4Gg7yLpF+fBuEBiqlxkWDRC2zjPUGNtHtB/YAuwVyB/w0y3g4OiUJQwp3YEB98m1KwVfqKWR/hJMOCJHWoDuskUmpRRYMcs2xJs4MZBooUwsWFjV8JOck3vLo+JPBV9ugay1C22g+eig/Nhpogk+svAiNnJC9xbJhEh62HxXaznsv8a6CTQbCI1cgWBIIr4fQuc2tnVKpBmnVcgXTiJjpb+6IeHS6dYl1XvloBH3YebTCBgzeYXKhq7iaIY5wbXmhQmaLy/hA9FBV+iyCtOtLZ2YhgnQMdx+THAOkj51qdauK1Eu+wDB5thgjyuw8+RfIudlNiczuarT4W0YEaqFsbGYOUk0Lk9Rbv1LJQscYtoKR1PkSzqNuMEQbqAPUdKiu25rgVBKb4ZHtZGYcg5a0W0OevsN8iq3HizmdRdZpshkzh7ycP3q8Vnlg9s8qD7uBKE93vi2j9htQV2GWDZWmhJTO9ibB9rsuPrUAwwfsYA+YAnzsP/7XVmV3Z8+gzEGAYrtcoiokIaNh/IYxHEPd+vRVKA8qMyZkGIzpEVoAldN1RrI1DTYY3DRj/Zjvm+LBPr7o+A5B9he+H9iSyq3IGfpdiCL6MZh0w7yymWLmn2HgE1IMuTlLsUjKcyfmj5AoeSWvHplbDY+/bmZIpT1iFWVsAn6YZf7zMM9m/dK5xLt82u9ARjJtqOON4HDA8TMecX15pAbEBaiBYpGgh6x6vJ1t1k6Vt4PWssjcUQeJQAiZE7NBbxBusAEqP3uApHGo/WqvlqFHepDYzykJaWY+JdmVGG3PHJaU1BJ5Ua6ifZ4SB1+i5Qn9zc4Ng37fnRSRAA89kFDNNIN5CRIAZDCbjXSnUZIPDAPKwea5pBzfWvHhJYEUqqX/JsSkVqHFcNrred/S7a6FPVH4NoYwvoyrpB2nZZ7jzBwv2lAl6G4w8xFAXna1pnNkUKtBvAI4zxK0YrtESBQbX2w3sUVaEeTBfBSXKYJkKP0CPKRfIClKv+AfkudCpfRYVIzNYll4eAk8vL+Ah8eGmzPjNKHTdFYMhxFmnjy+mixKKEIqJ6S/ZEEhBuZBUHaLfjDLG0z/MHT1b9vHMYgU7Yhicl2gjOGNtn6iklRHIzRdhEsa1pTfRNFyOchU2O50EQkAERRfr4aiEyjl4Qhm7CziR5ojEmVAne1DKbsmrzB5VcoSi9xpKvro20Nh54WQKsnPlfCxUBo+Ea00YeATAlncmJS3qkmpqNwwv1GsiQf/QZk156s7cfqutjAV6GSo7O6vJtK/WhBpms9t1jJNqBs1zQorqIswQa04mQJ4Xicl2aWfP5MS3MuXyweUQkg0RXneb2tJPMqjAPn5M1LTH9xHlnU4UUw3tUQpED0Wi3rTS9p3SFLaukPue3pZ9s+cuNuI+nmJG94GwqobW690Fq2p70nWxqfp8AuKH2mr20VsiWOGTCmFG0FjHQUVuNiwFZKRlCxd+DqW587ihBFlMFIR+sbx/EI1qPFU1ZDGUttB5AzRZKFLl02Hz7OrvWm2Xn9stk7OX4us9zTn9PbyGKukc24vz9vJNI4Ojb8c8aDh5CEq4o+Szzbjudx2t86sCC1yNSSJJCKZInQthZux0BC35kupgg4KZXGComjpia1F5Cy01oIfSZuZ9ySLcHQ043MwIB1hDaNOipZyc8K6sXrWHN/cpQE0rEvr1Dqyzqwr6611a7muNXfJo9SKcsn7xBw2xm5SQXzy/AoePLqGhSdtuR+LnKpfctGRvJ+SL1StHDtRhq11hGsU3wePgmAjGHZzhlWoYuN9OyF9hi60bVj9htBe+4srmP238O/WPvMAf/vIs47w6xl8E6fubzbQ2CuvQ9IRJcoJbetNUS/gENnDatvJUvGWYZ3YLVOC16ZVWpxBSmQk7A8xCSE3PuGvgIlkwxgpLcZ7pHWjZKh7ojVTa4k90OrZLWtun1jHdpsGqYFReFNMKGM/f+bnrv1Glewt116qC8xhYt4U0yYLXNgyMvE2aEVpa4TUBBbmhMe8PDzA3smas2xhjk6En1Wxm12H2o65HktM4geVw6ldrk3Z965dqeFWwR856MHgzgHNEdLgDKmxY5fqnUYkNPivALPzCMkgO4W2UwP2YQ1tzwyt4cG6lOI1koQCBa/trw+DR+sSPqaP1il8dB+t3gF6cvXwdH/eQPVmbg8Na3RwDV9H9jWQSuMUvs7sU9BWwkvnMn+J89+0m+blJkZrH5shubc1BIw7Zrk+Pigd5m/s5qsxEFF+XugR0QfY7Q30/hhmcqFsb9RywLh9j6hcc/J3BKxoBpBvD0bQ/q09AgpzGzM8RHXtmWEdHfTg+5HdM6yzxhy+ntlzA1b6W/Nm89i6sq/M44Ui3chsGscolXpwZMSv2UmFjwxLO8iJtMaZoZmNM8O6EnboxOZ2RDp6Rv7eWm9fXUEP+WMMmn0Q9lryv2FlrgLG+sc0isxFMHGVUxBk/0tYP2Yz7s/Yuwg5w5tIcG2Wqt0J0itW3pFoMETPVpjugwoE9qo06/FSPCRCT2rajJdiIeqeq/40y1b4HBaj4RDe0u1gmFVhFS9ysiou4UVD6pA6tB3gZQ2HnDDB16kdSiwKWdEU2FIfWFSffe8Ai+oQFvUiDuzWxh0xNMaH+YHtm0PMLBs1/O4A12s/9B+twdrsyNewoxeUmwQG1365eKtwBHJcZNGDxDbyqwA+Oo8GsutBTHZcJj8QurQgRIXA2DCQzf3ZtLfeHtS0xclsbAEEdu8ltsuZmsJtdtYN7f/MEKHaYnKt97Tdefnyhn1rqMNRN5Kd7D1aL1Ide/lSg7JtNwnfX4XlyB6ZOStnEoR77Ix4vlwWAF7esrMPChziwQ/c/JhsmAlekzUGx40b6XtL7KeaIcjqrravtn3zcPyIhr8U52lBBmJ5bJZZ7xeraETSwscT76sTuYQNUNzSdjKSLNUZpLyaVCN7nC951seJtbxWSiNCIPErFCxT0o1pBZeUChW3XuLml+iq5sAxhiV3fy2dJy6OKlfKlAlpK02WihFaLbLQJ2cYKy/I4brUHmNn2a3JBRa6xEzrpuCUrxI2zZiSfmi34kbpsFRTkw5s3YI5LKNDQtmE/xNb/Ob+nvFKJCc4J7mzJfRLImEwQrQirRiwznFHWpGmLhKu7Zq5l71JMMo+CtFPoSEOqMRIyiCjYDVAeZ5I0CChEK0zvHyzwGC20h2GrM0mWmOzkaU6tb6VULehlQqo3PlcDrG2I3XrWUST+Y9ngV/KzEGFW3TQUzPvGb8ZrLy2mdyYXJw0WVkgRK9Irw+SLFt+mbzRjBRPLSIj4x9FTK7jxcQ0mRG7jhc7lpKQsGlbQkqY6ywTG6mrqGd3mIjM7mPlM4VcWYjldOPXnd8mrS4ROh2iMzqoMw4UQRP13wHRf8tE/x0QobNSk4MHd6iMGdgOCJjB2tKko5EmfUVqdIi8GJC/HVR2Oyg6dkBoJbE9AnHXTUMOqYMAls6KMjOTMKiRqccFFdlvb64uizw7XhJ4JehFpFecYGCypcm09bHodWUDZFTEj6RZOiri10OCCExXnv42aiVgMsQ+KFx/iAFa68pxCkswCvOsgiFbrPHarfqTH23UVoJlHiLk8HO1vff5ZnFBWR5QmdeIiipPrns8/E2Ylj57nt+NRTH2+iEH8OA90qtSodEJ/Mjzpy57KZNOX7hkYeGtcDNZLDYLYpF62hYBe5XTSFsGU1YHLCjikIvU2LpB+0/dMxKRj5MnEglBdVH3otTpCyZpTl8gWXcCgOk6+z+mq9b/f2tbeFY0DVc7ZpNxlw8PYrfrkEQNlTyv2W9BlcgzQzdSCJcOrZSEfu1e95uaEHkjkcDdWhlei8RvjaAqDjIQ3SiBnZdEv1C2SosQAxl3Ns4luGSNKNtg0mHYj/2MHFhsDjr+Dm33wUH35nMMuu13aWhVdFBk7DlA7uuY4q4xfRhhgt7TeAlqwHisT97y6ACzSPlQ8z0ZMevG8qboEJ6qiFvvcbIyDKrbEZ+opAuhmK5kBps0XTJMneLNVo8aKiJ1I4ELXt1NMhHsuEujIkgTG0+rkcScbn1GCnGSHnvPMrzTqYi2SLUjpsO7cVe6md35QZ6HUkBhlwJym4qa5JXWMXOqqKC8F5BTVPdhcSlO9Ihcwzywp0LPHzZQvgbCy4IYKynWsEHNY+X4EXAZsD1cGzHYWmIU8DUsUmsKm0QxqThYyaGxA2NBw7h2iTDTPUALGPwI2NijuNCVzJHYwcR0uHS2uriasiYm1a7dPfxLkzFIdjNxpOQKr/5U04mVg0l4O7nmSp6ZurkmzGLISJJrFmTsIOOV2mO8PeEc7O+TzP19lPMWC+uPzKtV5GXsdBiHCY0WKnHO2N4RuwCAQuuBDEOum4pEwLwLDWgT4wtUn59cpyPfx3G/3sMOUOCXYzA8/Ym4ZFRKpuJNI+m+JZe4OgPX/vHZ/Tb2mOdJySLmtFoiKgZQPgpQnSD44nZrPxaLxBG3tDc9TcN5zAyBpkFXfj+F4QBJ6xo0ci/ESMf0MqUhoYmk33J7Cuqpy0QwgMcs+q589QmSz8Nr+A1txfeFIHVMLpNhzNf4hEaeGa8o/9TMkleUfmkmzCtKv1JzJ3KFqYLNolekX9TJ9Oh1XPbidqFcYwlS5FARmfP+Oi8e5BHSMgvhwW7pYyYow+xsXLfzq0Tj6ogmkttQQC0PlMtXxEJ7rz8hgEh5vPy7eNiTxaUZifWwJeUJmRclKicHHhL7mrg9oMhBTI5SA3FsXz7LGgsaz0qUTlsoBTmI+6yEDFK3WUlq3Dl9qWf3i4HlIxwvuryGLliWXDrLjU1eqjTG78RDyx3MCS7KfBw8WlnAzD6RXsJKfKTE4i7V6Z3c3NlJewOywmL0LTrEdc7Ng3TZ1yWyheXVoned8wptWq5Fb7UZxWjg+nnmU2sfkGMeNZDADy2nYbvLIrt/KypSpfKb4uziSXdR8byKvj1yzm7q//M//s8/iU7pN0prAI8DBqDNksUMkJN8s2LUFYYpLABDHk5+SuVyGkLg3D8GVRa25Hw8xJpdj+z8RWhjlDeK4XgISsI//wMwR5uH+jDcgKvZ+DycLFVIg5kH6f1h+sjNI1N5EyaDB2XzuZNveMsYA014IrQEZGzwiO0kTvxCO2YLHmCm74URIV3RtCsNs5hc13KpZ/ehYM5Jqq/lE/uQtmGD37vna1GKFCXvi65uXxSRC16THSTlpUxSmc962Jl4T4loYXwl1DP5MQvj4NrprDS3FIVdM7eRlxYkL2DmjJxhpPdRKJ4z3UVqixPmstj45+Hcugb/GZKfaGdhATPwO0aicGy/GB8gWUtDoJSsoWFrekhhBgCJVK0HItwT6C7J63PhQ/BoPyhhVVDbjTsPEpJpLrhxOu4n8CZ50tNsXSL1M6STzhfmpm0qTK7nAMM4xtogW3tdfG5LgYiCHSjiMXOpc/cOYBny8YSQbsgTJkQbIxELDA9S6HmfcKhUxKmoSHNXSVWi3HLhShRbJmMlCyVFLZFPf+MTFBhNfoLMIZSvZiuEFxV5keLcHQ6D2TWoLKFRh7EqyeFZXlCdl48PMbvzITI060PXcyGarhyikMYvW9I9er+LxhqJeymeUUQdTAJYdwRBO9oWRSQorOh0QXOLQH7v0pcMxdUWmWcTWkxFEdESBjkF9iy+y9B4S3FoDLGuDEGb8lJDe7ItTG5KDr7q4IhRTWTZDh1G+og1LEcRoG2ZGE156CQYk/WVz16rJXXNCaXJ/kGD2iSCTP3gYdY1sUHiAXBNUw0vIp2BZ7HIJAwWXcROnCjEo+PhkNaRRbFXPXJKU3I8lURsHAUbwkleUNYhx41RIhQlYaZ5CSGOKI5vRfj8jCyxWQT83cbJ5zFyOMYcror5L2HN/EKFe6WH9oMXeVgIhfLjQW4fd5BCQURDIu6cUXA7Hsex3kSULstDn23tqKpRrX7DFJaXTKEItLN0JDjsF3bsCaKbPLays2aulmgcY/BBVZRS3Ay/Dby/cZhOgqHlwP78HvgV3MfohgnjQewTRS+kdgrX4ETniolLlokMcZbDyqCfJTZClAFfPg+iJmqv7oBk6j84j/GYSZig7To04rNBzoJ5LBAYx+DpT7cT5XjDeJvkxyIRu82IQF4Jr2Y+aI9ARdE876CFL7tZPP6HTHwDx0w2L7hFAhlXRkY3NLxifUkHEgfXvtj8Uj3wYawxZIP/yNgt7b/Ud5+Kc266JjJwbeqLBNIYZwTUSPgQ82kchhhFVDtsGD4Uq9SWFvEMMaRhYkjFFyrIsTBazetzJOw4sFxyazjIFOO46IpGNz/Kp4S2eHLlMEHSsTH5SvU5rzfP63cg9H1csHfbUHl+hYggeLzkpK9S99i+jS5ubAfnFyta7tAFRoezZNq5w94MFHDXx9Pa29Y5Pm8e+C50JquewZ9DTwkPmdp6xLV1EjJSG+cvrLs/f+aVayQ6udjQCMZyBCiipJJG9OOdcUtFBgGjrZKpDMsgkiIbGSXArkqJch0M05lEyQcFg0+QrxOxYLPQpkvFE/Mi10hOGZMiE9SmdKy+fGDtDIcjx8gSm6RRdwy6EOOIA7E8Zskhtgp7lhRgK8eoaaPneEO3a210gumwS6KRErgbsHI3/j/u3rY9bSRZGP5+fgXWda8XDQIDtpMMWPZNbJx4Nn5ZwDOb9e3Lg0E2mgGJRSK2N+a/P1X93q0WYGdmc/bZ65yMkbpb1dXV1VXV9fLTP8/PChRGzI5Q4Lort2KSD3/jN4h76pKPNNlHJDrF4loe2jbiShQuWzrXWLy1FNDAot3ZgM0qekx/sTVmdkpq6oncr9+6tt3layvYPOfnzGrKZHPNoCpY/SoOI+R1jU8x6YaZ0eUrLxBz8pTHrhbybFoMAnX1PBGEjx0utHsXw+ajX8qwcA1iq0S2x7x2GfZByMIrsJguIc1C6/22JDldNkiQ60pY+VpYsSgzErcL03CAwoZwNGC6PK+ZeMNp3Y+UG9gbTAmP5MmqKd50zk9votsbYJ+Bz6+Gjj+1xLNYaZdi3OpNEv478EdKU+XxXLku97lRAce5ie8S/567PyAjuqDOW9IHgoZFFIuuv09+/0RiszARz6CEyXveCfoYlPy699MCToulzenfdZrqhf7A/DL1HXWgHTLQxC/+xMa59Aeln4io1bzcH4Cee3VJaohWm+5luUwt6YFhfSZqC/WkH3iXrjr+T14QLMgpNCnuuBu+8/7zmYjHJCIhjtj1pyQgcFLEkjRP7L+H+N936L8P/62TQe64uObXq8/Ph/LXu+fnjvxVz3yhh0V9fazmXvXOsD6v9x5vTj94583kIUSy7QLZAk8s7DTgOx/8WnXH6/ktAOuc/Nvbr715fj7fEBpAGVpon6EpPckYu2yM+jv4DAHe2whBF5xRt34gRJR2gBZux0HxPQa54fzNz7nG9wAXOd9704CP7ew0GSGoywHU8MZtwkrU3jTp+sq1GwWPuHw/YbgbkST/ETaDoMLrZCjj1Gp1Jn09BdkBoI9SWoIs1OWG/xRwcB+luf0k+oLsTom1nfTv4QQL76M+1hf24M2YROAO4tlsPgX9wXskZ8Wn4EswhrWFQ0sZbzScFU6PdhvAoS+xpXhx+xTxFxgOarzB3YqvOHJR0EWcAuRrLlgP91updA1Uxf64IAt3pi5fe99GIoz5N9TUrPxv4qMUiMDo9yI0OvU+uCr/MGAKRCpYvrvYtVfKlgsOYTiDfqbsr0iy4knjdtmROZppSjIkIlbfNqQ5ltjvVLtZQrM4Gq3F/U/g7ktvUPdAXSo46ga/g1p2fxwG42GjAOuA8n/JKaBXBOr/HsZ9bVT1+1/7za+4NqWnQObSlD42LldzrlaVXL6qdGTJvEJe5zRvocOy7COxoHVWK7+K08gWYMHfiStzeVCZzZVXAjZ5hJmtlVfq2PIUsw0v36pfyO+jvxU3TshVLFlxZIHidJTBBTwD+eFfK+QH4UdJhQQlX2+aguCS+FnvFH1hiKih+tIQ16AbrMOefTrIT7UBPwCwANSUQCbSheN0EEgvE80NyBBrNHhCcxaJNiAlDuFHq1wICbAC24RS4WAuAyZuQnS3j2iaLHQ/DmS2Ppo1S+bk4h+seg7fBOxuqkD8BwPMm8AtQdlZ+Q5VJ0T1EfWtZEpPWKB+Oh/A4RJPHJeUCs/CUPOcIxbHAUOKc8WRsf7qJcMTLMvkJoi+VHjwBx43xSwYykq5/FbW/O6nl35zyffY6Rr6v1Et90IxGuhwqRRAHcWNNL6q2015x+MlNbgKQ+kNuC6csaj0DIOUJId3vPKOa1nkXc85RM5dCO8KVNnCnv0xHGXDJ7TE3YJOhDMLZg430DCr6Mt8AEpOhd+CkZtWgsioEibnpAAIt3ktqTGijuZWTF8jvXjB1u0TPV9osXsgrjG8FjXd0WeQ/yzXXF7yG9qUsOY3mSd1Kb4hTg+JBaqP89viyJVXf321jczKD80SYdscg6A93uMpkpvjUgntPgwZ/asx8Yd8LzAOepor5qRNfx8dUBIfu/BrK1I1JZuqWVvtcm19gnG9P4LghP6YCPPEJeEl2nw8kxV6xT7ewO9/tVBsqdj/4V21tFt1t2rVKrprjt0F9wPpW5IMKrPvVybwF8ik1tm9k++98jtSgifi1g8a4AGr6Vq4RdXGK6EX0vuwkMwHyIfvYGmeHBb8lx3kHYzxC2IKLRLpKODuKmmMpgpkvIww+0usL2+CHUJsfHsNQHiZMYtYcyO76TY3+/lW6KabYXfdcRBMi7vo+Jx5R9eVksenMMEBsh+UXgJ0ofViFhpCfgTe1CHnLbJhhg3ez+EARHi3fNMfj7vsTSsaHgMXTowPKe37X4JefAzyxggTjPLHLJuCLiP6Mmo9Iz8e5BBCly63w8KYMhvwMuqDTI/ryihFnjB5XdieG4bUkjULkCsTHQr2GhIV1zBEDAYVAYhQzgG/EUEpJD8vu4uEXaqXpAJmWAHhPavGc8v8o/XQC9AxTTveApDcQq55bETPz1HFEP0FQxaKGijEByQ/daRP5FCdSPvRLEUHMhw6sI+NOyopiCyTO4iRi7r1WCaoSRLOKE2nja2th4eHijbQ1nFnC/4ziaMt5hrJgf0URr9XpqPpAZddS4H3iK5wihFWt7fELiYIGVVgw/wO0xpVuK5AOVwsOJyifVFrJ+UVMGlQphUdPMLyhsRuW8AI6EIGeseLiR4u2OA3j4d17hxHHo4ctbOKSZKpF2juiO9cvDqNN6QbSlxZqpIB2YkWVMUQuyFEA2u41z+IGo6zlKQU+Vjzip5V7JSHXnraaKiAj8d4dH+iR7cQiDTRm1cm1eUDkmZbOjaAkJDINE4JDzXk0T3o7JCRE4wLah5URe6pQxbXg1fDAjUrwJdQK7jIn2Tx0bVoHcq9vhahbddLVkBUtI21DO51F8gO5XoLuoSkDEpShl5KeS/I0LBveHdrqM+EJlkGPqWyTt74qE2yXkT+YIKbzNIg8kHnXH+aJ7BSkzfd999sbio1B7HmhUPuORoyN6PMcGhTdEXvN15afuPKRIym1q5p9nkIq7kZjC283/LsEooHsLjmmlU+nX84OWx9OmudtnmUKK9No7vKQdvW0c/tTu+k2z6Cdpdme5K+lPsWcwcbrXIRCnXtrJuZaSK5m2sZSLH0pfhlAZenz8yBTmTXzClZKx2uFF9YYf14TUjSUCa1kYVq5zBLNDdlEKLHLgHZcLehcEiqvzyQ/y5WIvnPi5Hhabo7oGCDUPykMlouiGhXjNlkOc2sQUCOJzMGCLa2UV3ICg+tNGUEzG5GAnoz4iiIcxrZsBKF1FKvRi4mHIX4jS6a4ypvbuwBo4u5Q6CblGol7xprYT2WxEUGtHv52lImB/HKO1yUJ6y7vCFcTNR7bZHKPDEAN3PVc7mTnAyftIbAC31RvlVjXjAoWUxtGWBhefoESnaPFQbiTavz4fK0fdbzxDUNVoMrNIhEmmmlHkTG0nwvvOfwJIl7A04d/+YksvUCVqDZJF9ANT/+0Q6WKRUpB55VbkgLEJapLq6wyYDkIxaVCegV0SM+hl6t4bAXZ7vgInup7eOKUGMpRGDCobZWObco+kWyx/Bbq3QJSCm5RwqFwwSNmflZ5a8ZvPBwGa4Z3FD5QutE7AgkgwaWB1+zZc1dyt9FoI5Gh6pNRCRZMgmKVdVWySOMvsS/66Cg16THeZa1geoWaAUy436xpC2dtWD76RqRUNo4DULJBqudzA382uVv28ZyuiefgIE4fPPNo28ZTAyDjAI3YngLoynpHOQ2c2DCW0vTyKF1F7hdqIeqiyIjmfBZEYCXPbetM7Ae62ruKT3m1aiqYgAu8ujlp81jhQJnH4PxVI2irS4wQl4QiO7to0Q1kKBrjY4UYU6R4Fxa0klxXHqsdC8PD9vdbsZMlFps5UblU/NDQYU7C4q1pKyBmIJmFTuHUy8aFE48S7ITf6zkFHSVLEz6Z+V/W1H4tO9oqiRX8df/4lqzDZRJ5nNxVVoNTP98WlvSOoZaw6HwmOmofVw5Abg9UXXg1LupXzyUxuiAhcJS59xHTPqAnTsBhj3GR1QGSEwdPpfvE+j5NmFS97K21mExrnLYCabxLF1z8GU92K5XoiwFx0cdbEO6chSM7VByimpiw5Ljikhm7Nn85r1sdUREZZzuQp6pGRsfrIZtHrFvD53GOjPhn8nLRboCTX8qCopWgcD7lk95+jfcdRw+Z5a8VJjkJIM4LfOpGhRnwxx53PzDT4L/DNr0qazAXjZ7l9vkbJn7zqsOUhWFF3ObEuaVsVfV+F54/j4oUIhtFgbRcPykqt62UD6l2X9iL77ik6/bk8edk/bZ0afPqt6f2ZU8qyMLRtM8sr+qv9aN59asW+oAur1PG5relYoUj9QEqLWQZjHVLqg1QVuZEWOvTkav4Uc05FBzQCeZDjNlVYSouljwRb0hmFOMqnK1aRYOzL8RsCp9KE+4FZYSU32ONzLuAuV4OZ5IwMfywNLhEnQrYMX20EmeD6c9F1K4IAa8VxKXHPfMKBDYMrD8iUYQIiIWNecr8smr4Nq3FBhXquCcxeiHMCr0uQpVoN6ZsK53Qo0nQpmnj6vO+Th8DIbrTNxMPPO/e4JIxiCn9aeBMTf6EClnFkzH/UFQ3LoqXW/de85f6u8d5elf6lV8WtKf1fDZhv5sB5/9H/3ZW3z2V/3ZO3xW1J/9iM9c/dnV4JAA5BmP747J4y3t8fZVv0UeN4zHt+/J46bxmA1yoD3e5a2vjMfDI/L4WqjswnbG2WFqqyXPlrCOnhFseamBAq+fYQTiEKOtKl1G5lJnCTEMsI6HYFDKypLsOWgDCEswKfwXBNKk5GxWnKaVjulJlGMGz9va3vKoKWMc7tST8adBqtXjHm2HmSeDQfv5kUXKK68vD7W+GlkkLFZK5mw1MJwdNTQJOc3rwhwi1aOaWy1ci7mCmDr/7ire8JrPLlvQpfGfHo1U5USAsZ/cvJk/e+WVF8rZg+DWUFMrmfM/n6fnd+/70X8FImp/AiLmU0TDL2E6ulC8kEVa1ww2EoaN5KXYSBAbzP+TxTzTLc6mNFbi/WwnszeWEYD6e3HF7Y0XzFfo4rwLiKNzq4zSyRidh4S7BWdNGS+i52fMxJGk/WiAb+hlwUFuAGvqNrT2ZG2FiV9Z7tTVzI7KGmPgHDbuhwztMqSPLQ31R+Ex+Cq95CydhtWXEwrpvoRUvg804uUCP6mKk2q6EUmmoW/qbJw6WdY3f79vIVP6EkPySB/jW2jyZ4OLjc2FU3yl7hiLc3OIJxON9xO9FjLhQCZxZuYJhS7CdG40xEYUwfk9eFKxsTpqPZAxfmwbYP32DVX8OsAnIgcH/1LCL9C4/LTWtxaWkj2C4a41guE/xbJPKNXos9vTTJBwlVy7ctqh0PwJXOia/2IUogjC0tw5z4500Ir8ajPaE5nkI+7e1fcx/QQloRAziIS6sKSzjYXFByB/eqFWLZ1OKrNYgSz+cOA4jfXXTh01jNKcIasvGNFIoa+gXhi1jXudhlNSqsYoTiOohmYLdYt39n2pFRlgWRZYXazajk16faz83O50Mb/86Un3tNU7/KjWHX2YGHVHmR4i7kxopo9WyK7ylOQxNpgxywPju8S/W2JKz0Wlu86IGyyuXBuZSdrr5CXRgg+DV8uswh3pxeHyyk/fL7/RwuGl7WVVso8NOEgNEWKJj88iK03ktD4VDnO6/PwNeFLyL+UfkMorL5UHZJqXOIBhKkU3AyFTqLECX3PWl4AFR9ZSg562RqRUUtY4lUnXYafEV2hfLp8PP9QlndPzXLXYvj6GSTV/krVKYd6qOXWvqjgSvMoEnmbwCCcKz83RFPzQYsINMeJp9dwU98vQVSan0cpaphsK3zfOlk7NmKdnztH71smt7sryNd7Edzf8/kq507pR77Rc1UIuKM4mW1qubY7I5eAUXUpffu+Fg9BLAp3qcpLsvejqwTTFY1pztiALebusfBaXJGhoBQa5j2am1B57rrhmiaYisa5w8AwWi+ZvdkdVeJ7rpdoschwXZ/B9cR1y1O4edk4ueucdxaN1Zi86P7NXnLdfBPh/X7jF356fi7/BUQu7k1SGCbj3cAEIDKT1pPBb1o84maM9nLhXZROezioXnfOjy8OexaVYS+s0q3TbnRNA0eXp+3bHaClzo4rx5JT0Njzpk2jYaX9qt7rmt80cUYCUk84potDefoohLAngIOVhWvgFFJm6vfZZr9vu9U7OPnSNXuP5JIziBBgM+lZfnp6cnXdPep+NVixv0Kzyvt06lBV+uKvwFG/p4e3lRe8kg8N5cns4n2FkH7bovj+87HQAHqMVjbci5wvahqBpp/3+/Lx3eH551js6/yXzzQR932ZkyHbn51ZnmXM35UNG8QJbTQOY5N3hqB/dB7a3FAuWNxYC4l7cNpLh7zJ0Ipzw7YQhXucQghg3u+ifzltH7SPuD25p0G39DO9rue9Pz49Ojk+gST23iQlllprEK0ZG58fHHCT+5MzXm5g9dRLzH5j0kKUr0SOHjvx6beftzrvtNztv+RAaHWXeqy74lKCcpnoMEAkl4fUkuLRAan6huimPyoRJFtEyU0UzMopn+EZoHzeZ6DEI7ARWbxxzpKs/z/1ed/yhAZgUYVmfHyWVunHfTQU+U/hK91ldUIlOKajlolMK+CEvfZAJtr4iV1nXPMY6Jhoc1yK51y3JGUA7dETGsg21EimZyPPzhop1OLIyUv5xdiQt+vxPENbtWZAzwAut8CCoWJInN8o7xngnQ0t6W3O09CDNpr1F65Y+Vk7a4FWjsW7Z8ZYkUF41ptI1O66eQnjtMVm37Hh5WYJXDcj7yRFzAjgsQ8ocdPymN3OdtuRyXRhgK2YhmGZWIb+3xVFknDPtYR/pigAPXpANZbxKthHPs2rDZsinH2Z1ZWokG/dTkKh+SuKoSyRKS6Tp682nX9l9jkwZb9SrRJOpnrA4Elc4V31iyBz7oqQLtSOPlcTB2nCxnxDf7D65kR03Q17mb/FyQ6da6veWcjEtnNUaYTWfjZU2TTVFztV1U1ZoBVw5jhFsm5v3QwvCvSuG+RlCAGHZjCaBTNLF4+Npgvul47B8IKRWLPD6UJ8FMUoTLv7+6fPwERO840JvaCex3kXPfy3TkNPPD4MviWs+sE1HUceV2Wxu9jf8RJTd7bu2iroi98a3LKPjKMtoBluvWkElCDsf90l20lRB58sYyYlHy5cxUdO6iJq/jhDqzDUUIT7aOqIZP1RVcg07mkQjb8cCn9dsWRqEiJ544qZL4HYNKYefEiqa5AlBS1R203gKHYFza+HRmmnDPC4Yv3TFdWJe9Z6MkuWuER2pKOVG3KJWn4SHOqq4Mtrr9VF4B6Gi20dHUdloylRve3uul4tOhsJu9DLVefmtjN5ufi+r2MvwUKG+m9GhUq8Xjan+ajTkJU14I6rMG42Yhi8bCZ3ebCiVfdHYUO2NHqbir3yDaPiZD1C9XwldpSd/lr70aHylkhyPrc+7nCH1UInnSWYXYHia5l5VsdWqk9m3XuSZ54osEBaDwsLIBKCW5wlWxD/9wXPVFdBvnqzNRGLOVqttFGRXlniN/4nriuP/Uasq7T05a3oytE1RJtVcHRn8at/QPJukDADWoZHxv9bcTt8niDnHPCbnYMCpTyLLbr/XPPJtbMpyZKDVQ7Its3lxVLblhNLZqzxsvlu+gIytUUkXIKAzsgVIqF+MEuXc1VFxy6uGrmJGy1TrlzIpXqr0mzmUbnQ12RMrnxsoOGTTfTH+mCii445KGd+LhHTLsiQfCpXOI6SY892gzRi8FYgFdDrUhqj1vUDPMchL+A049V1rTuLFpGeKowYNUvny+y2rdgmhrimBS8cFB/bFOOCytZFfg1rplcB/L5FqL1ZCVK3x/CLBSzZEzqnyW3LZESj3DF7q/5bJzcHuT9Df1paZAx7/pqfBEB2yeTlMJwOpxGJaa+HeCRpDpEXjCQAjpUTAW+Janarwhxn4tZweHLLEntEjyZ1K8s35PH5bO5/Hb6/L58HuTf83Z/OgIK6Ty4MR9x+SyYMUDVLtzjlANy3ZlRTFrRUNO8GXMAlViUGm28iYhzQ1Vk+VbVMUvHS/dkB2I5DXl0rBKVG2UMGUkoej/uwwHgbFNztYOBD3N6dFLXtrThIRi1wpIlnhY0AEuF1ePEZVjoFc2p430H4MsI6sIPSxngl57XHKgZtjJtPyN2hcdZk5zdjeRolrg2svtQaSeJaD8k6jaCuMvQQg9EFkG0R6IrJrIgGMeQMsXxkzANZ3F97rThKqO7KZcSj3/jebcmhFU8GjLF4agck+rGCq/riZMXJ4SLYhK04rMsCtZCADCywNdDs1MwJxHL/XHE3+w9g1vFwymM0CJ5Cqd81BqN7oFfxYH8CaWokxgRwisO3hZbquU3fk8TQwE5BahI30IPFDenveT+OwaKZLMs0kbgMTaYYr9j9PTvuvUE9vikHhKGdEUrhhST6pz6gRAhq5wrWdFTfTMu+K6UjJbzlYifleSRROagSK+AThuyCTIMtE3dDTkoA8yYv9YlNc0d8lwV3/ClXPU4ItyZl1HNgPCgueNrS8DdqU5UGercvmDbypf3XttfDCj9wEWdNkOaJMKF5RCgTKQrED/69ewQERdNZPnMbVX2HA3JxcSdHpBRMgbFIfiiBVuV+dFDByzn0Rue7/GGzDYo54OrBJydlKgiihDkOON87LVmudLNaOwntsp9Pu3pz1Dp3nZ/7r08lZu9VxUMKM/Ymo7VzzJqKmVw3LUtDrtNh3ajC9+xycEmwRrB5M+/eB75RiaCzK15JE2Enpr1+du3DoNJy/wrT+6gCWyTo0/lrKmdO9W/p18T+/egN/UMIy5xgmTkt44ZNfr73/cTCxOS7Tr+oxPeonwlOYteCWHzv8pA2Fv+8Pw9nm0K9t3vmoYmVJJG1OleKmeuRXaiOBqRtZOmBg28RzIuKvIS5XEVkR1rpHQWM+RTZLqRVLJ/NVisQSeTVMPLzlHMzhq43iMCc1nCWYPALSmNuIidVNw/q6bNEIiLhqEV01jMwhv+elXx1zfUSK7jz28tevBaTtJcseuKVBybleOFKHw2n0RsFsEmJFhTaSm3qlCtte4wcE/wnfQ6gzk7XFHPf9aOj/0/GseEo0lxZzafMiZTEdfhVwyR0DmqNSbW/edPt+eDW6hi0E/ynVrj0bEbAwtr7LN7btbUyIKmcuEweWBQPIxrlzGvmjUt3Ul1BCJ9s2Y7xGbNIzN30pMjD2UvpaYASyq993KxGJfY9wAy3ZgTlzElea35+x8Zydn2RNRSYJJXkpEyPXtSHMVqhDNelQGiS2YiJ15IAeeGQHuMKXROEuZkZJ5fijJZWiJaOyU0tnJ8aI+qLnz99bAknorma31DEKaImdz811+S+tz0DMWzkzTT1nhh8Bys4lHeDEI+Cj8e+ONV8HVokg32Gldh0smdNMluCWTQz2c96mSCTxD5D4Y3eeN95AMP5h/hTmgkNbByBsGM/kZQMM8QAHpPZLtUY2pr04NDcA5f5kM9/LUhRjfwUxmCF9iF/i0FwYzme0DtkYawvhRwmqG2O2rVTi0ayjiEqNXgxvWdhe1Wa4lzaZs5+l5ckQgUt8P5Chn6Eflrh/w0bNmo3O3NPcg2w9aKyQEG9XBssB9xbLAdht2GcjvGbZONLtLG8ghApmK53SrI6XZjakld6ZXF3rj8NbXrRTUaSB4qqec7DdUEzaHguykk8K8KQKjWoN4rL1/Ez6OQfwmwcr1+FhJk6r2qir3+/Cv3r+Txznno13358nCfv7Fxg72CZfO3QOUvpRVTZP3b13B7U3jVq1SlpNWMdhcA9dq42a+t3zuzvYB8a0/1LofGSdJrf9Gftz/OgA1Nv1t2/eqiOAaIe2PKMYkKrTIPO8x38G+A9VbryJ9+B1sQYrPQuUtTfWw+vnvkxR3DBfUkwiJF6cecmmGyLLHQNXir3+3jYR6/36QXG4PALdG15Vr32/tv3mzebm8AorNtfqu9XqAagmNfhYFSh+7OML+IFtYQvAwDVi/LYs036t6pJ6d1Wg8AE/QqugqFW9aG+b8IMIACN/LIUtWALbCGCbE9hGFLY5hc0bilrO29ilfr1fdZE9PPjbpfoPRXzyF4DQe9jnLQHYB5//wIrW283J3kPTHdD9O7yaXOPTCTAmYv6m8Nfcr6RKCE3C4ClJGA7xdLl3h7S7ipxDqh4V2Z5CgBm2AEEK6FWEvCohr1HIqyshry2HnLrHFLuKjeYOsdwlSiDrVcVVM/46xfKaM+Clw+Kb3d3t3a2uK96RBy4TLSfAZyd7fNWbLszlYABg+EX8tzx3t0YN8ju77OGkP+7FR/EcixIrH8TmrjYN/NDUTjjHcISlhHJavjLGFHC3BfwFHgNd4GRbfqu8XeU4mwqA2aSm8FHagXyXyIzQEz2tB4pUGBBmSqvuIVSBX9yullpY9YxdROIAOkqKk80aMtcA7ycaToP8t+B4+F9j2j8ABAQKfTwEiPTyHEGRAF2NUMudzz+1Vcf6hYF/l4Wm/sNd0x1j5oynDB7JAmCeZLIi2ZVoPPkEtnEp9hgUKtxPNmARSIm3HeIBrPSBKf4Ao29flwewld2tAWxS+BO2szKWjM/hZtl09tR+DAZqvvaUCPa1pml7VdKOMYMrsHQQChY0q05VMdY+5hUitI6RubtQ0j6I8AK7jmKqdPgflGbgaIB/xvgPHDX4nzn+oxw43lQ9aki5b17s+9h7j6XpvZ+8Sy8IvKfAmwbeF+9j8w4w82GlyvNBtQoF/gfXu8CKPkGA/17iP4raZJNVrPoiFcBDySL/HSCPTMgRMA3yReR/k408FZWdpvi3kDnQAjTdqz4/t3x7BlvM+8frkSi21XK9eYgDiaCBqYsjl2peW3kMOC5PUVcjDOEQaIH9JfjtmD5ou96hzyMQtzTvbEDihd92F0hd8UqLJ6MqmLSNFNfof7bCYg3A+GfPzxckRxWBzbk5O7+hfqg3xyefeu3Oja5EZdc4tit2dI1jc41H/w1rPBdrPDTX+J6v8UIeb3PBy2FqT/4cuCHM4IlPYAB/ymLBAMtGcSBmQNDRgRYCsIFLLHQ1ryefDgAueP7F36h6HTVQChYNHtbg1eZmD16Yrvfme8VfPfOK+rubjy33QGaT/nASRhf9JHkAMc3yyWCW+9L0QcoOrdfByUAXB3nzwarSYYTFUc034bQ1HM5sbwDdUZCe9pPfs8PF85TuYO0xFs78+xyoLX3KjpaE2RkPRv0oCsbZxsEAdG/LKKxIcLZDeA8Knh0tA4qTpS87/Yfl7+fRCVJtFudzOL6RVizY6CcpvrlA7AbD3PeMPIcW+h0HCSGH7KtZEHSn/UEW4BRGvOwdZpcsHVhJeh6Fj9YXvM5CdqQ8XOGETpP77EjBuP8UDC/yUTV7tE8zzXk+Se7tL2aPp3mvUtsrIhXi394DiAAf8Y9L/x54VvNBlPLc3Nz42HRRX/D9/tXD9ebmnPwdkb+LH5EPgQwwhp/e5YYfBJubQbDhX9CvoKL34D9QMfkLMkVCVqiZUn/Bi/6sP3FcIiI/EVHiJ/znHP/hQL0QmicKDf8wjvze75ScLVjsVBt1ro363gd+LYf5CTBhG0W91Ft3rHNtrMuMls5NCiCTIfpBRDt3vWN+ddDhVwdOqUcCVW3XQpegq2liABeBj13vjih3XZpU587vMmetl30ggMOYMtMkHs9JXuuDlB6Bx6Brr/9xt0kVNl0aSF37CCgDZIZoZm3uahox746J1f0hsfX34o+93sV6TkaK+PR/Px++LzmlQLtMPChvN6p5RUSWV1YyRC7FI5RXbVEyIFscMlQtQwIQDuKoPiwu7+HQVpVpdO9o7k7AtD7F2XCOvDv4MbStpI+pfgd/8PdG7o2guAe8z5kVM2jLob38OyprkLV16rlx2Lb43twRbBHAemBrblc96JUUxjrlebr++8tiLctcpxerMiadXxLrlKe4yy+IJXyxLV94UTEs81trzJA4Li6a88Ce2Qhf2PMaKV20rEbK82xOI3yZm9GI9MzPZ5TzmmUzynkrcxnlNNBhs+YxwhdqFiP195mvvtb7ZPIXkYe27EX4YnXuIto9L3MRyZF28rocaQPMOSSTX6FAgdm2zk7M1F2q1A0t2ExsFZfH8UOQiIafzn9pd63tRuH9SGn48eTDx5yWhlAvP99p/WKH4P54hklBo8ETLSZ93Gn//bJ9dvg5k5AMa46pjTvti/NOL689qGywjVjVaaCwDKSGHIigwuv3nRamv7todVqnGQi48EE+3j3/dIlNMynqUETrAo8ISIa6s+55p9tr9ZZWu+6STuryptk6a9lG01nwpdcRVaVDAiH/qVIGz0RmowW/FfDS2Jn1F+9sSy5e5iyxMnB2VTlEOYuo1OSma3d62j46ASzy2fEXwC1Ozo9uWj9/4InKjDfAK3iONPNN6x/+tvEZI1dZHkVI6E0qEJO2rPzSFGZ0dZ018jIQVcKIwkdmICL1NbXbqGut8gbF1J1uvdmt7G6/cdGuL2tdC/aQqXUtGceqUVTmYQyj8ZVV45j2AuvEBONZPTfJeLKFvCWbUbImaPwnkzVB505qAXBkQ9nC34Q5ySUztVKzHLnBrBSwhEZkQiS41SpcKCwrk7hDMrOXZXhAivxuQXsK51Mi9gAiPf5S3QzfC1YbR24U5YlPZUM+BxXihq4n9afT8dOhpJOidV+QFDb2r5KypAqpBD+op4q7pf0y67wLdpAf+6gNjbezb9zc4u6S7xiB7cqHvldke/aUbOiIy7DIJYjU8ajywz8CkRrr1TGpfeo7odImVFhxqQK7FjKV3c0p/ztvcFM4knzJgFOfhHoWfT+Kz4pvSjYHBUKTKyiwvzyjg3pA67RrHLbfL27eKrqqcfManGbcvD6JV8TN6wKJjiMmYXwv3BgCtcQJg0vHBQf2xTjg0pU+d1Na+m5bP0d7UPa+AamOlsw8XoyfjFgpEUVpkMuIf8Rpo4ii5n4Vn/luW9XU09RdyqHTWa8i+34vsC06pIRbgc8LtLQRVJW0LGk28QPTOrEoii3xQ5DJliA6ZBM/0Fe2xA8ydHFp6gY+dmpP3ZDmApP+70/dwIw3/5tTN1AQ10ndwAjsO6VuMKoq27am3NP7PMSAGcdU974ts7Hb0NrWgh0vn1NTj3XqrS090YuGsRZdgU11juc8hweVZDbY8AOXRwWTqREtrktusGSCgDChWO8E/SGKPLhAenqpDNOSqaQ2ajI8Xjzh0Q0Kz8PokE8xhmrrYbO5KRF4pRcZLG27bcQCgazMceKHJaciv4MOpjGtTnMkP54QBTODDSPUDN3eiTsiCRgiHok0pteoEUPjCNQsXvn+uaGfMqdc9FIN925D17TEsIWl1T+zN1yKDv6xHw3HMB0ae5EtA6wMhhfSkch7442lg3rfrzX7e1HTZX596VX/mvjpM8+AWDYdGb1KNew397GLN/fnxOgzxJ8YWjj0h+RBTMedu9CfOmjT4etkby7BmnCH52Dv+fVl2ELc1q+9PxZp4Z5fqx5EftiAv+rkr3Kt2oj8XS8ivvWRF+2n0jNdItlVsZyHxW2OxXuKxQHHHluNe+FvOXA5Jlc4kd+7AtMrWg5cvhIZDHwFxtEIvNFw3Ei89GnaCD3YLY2xN+s/NGIPmjRGC3EQkMDgo8zmXnXjjh4acqtuzWDVZ1h/80D85deU2/h9DLQxA7rmIiMAAaKA443Z1i+/E9IoZkf5M+CrvgS+eJoDHpViccxgSKs2rZOYQS3XmE3LQC2kJCFCyGQH5GqWJDW97F2QRbijp7FdqrGMQCUWm2CzpLGQbfKvpzL5SXKgFzJI7lA5kkhu+1fII5axrPlL+OkfoOB6EYdRmqwmgRtapl1hbUpPnR6WaWzIB5WAdvtwX8mJJ/hWqvz5n9BVGIcu76jpNcc69642rQAKx+yQeGIJwQj4mBuwWCU3rxH8v5uKRsaiLcW/kiSGnOPCzzuR2edW+XUra1WY4mIFsFmTQjEJ/x0UJmEyQTp0gQH9nVUK53gCQZGeXRYl+xZVGVYwt+liKCZGsliU8auIBOKQmxw3p1GqNYJhIxnYydWl7M2BEdqp3kM0cq8P8u4y5GLBWSUKleJvOLWUX4BAT1t9T19mUameiB4KU9Hqs9vyu2BQCqFL4P/3flBOG/e+en8OZ3qgX6gPvHsaknbvD2S8/Z6/S31F+zQAEVcJtnGtmeyJLA4uiB9XCYqkcakPogec3j/Ud99AswQwX4w2a/V3LvUlhCblPsYYxEQKE7Pl+mGx5eu4a70adxhjAEjwWwsREjb3a6VieFW73txGGUOdUL05xzibdWeFgmWZiqK2+YkP7e/X+beG6J+T8w2QSpd+YwzDDtVRd7511BHMaijWYeqPyX8n/uhPXxdvagw1ff1QE2OoyeupZaGU3z5Mi2ITqaWvf1ZK7kgZJLCgKzUAS7+BjFMFgtaX++8CAXpTMoHj/w/elKbVLt+b0ph0vjclM8st86YUJkrLF17kTWl+a40ZMm/Kk8BwkcInOQ5S+MruHoVvcpyjlPEsrlF0SJtjFL7JdYvClxanKPWx6hJleU4comzP0R1KG166PuJMcl2hKLwWRyh8sdwNivhDHqbUH9L0gaRGHi7FE+1RyLNBNBR/T0IsuyZ+9r/cqz8n/Uf1Jx0mUIZJ9WFCfZhEHyZa0BBBGKRHw33MTJ3kHS2fHg1z2sAb0oJ+cp4prk6fkyb9L8Gsfx9Ym1EQ6UgEPMtI5HkG6Jt+ckTvNRRWT55k7t5JNyJDusasXjAIdGJDLLz4le6vejiY4lkKu/jsqP0Pw7+SRWNBO3TwRXBNb05uIsDrocPzztHJ2QfTh3SOcd5IMLNK67J3DmTc6VlL8R7Nwi+BLMh71Dn5uZ0tkYtZ7jCneOtDxhsVI0g+kiRT6Np6+Knd6nw86fbOO5+X+Y1Kk4niFpqDF+HUaOBD1GyVWFDqwCoPRSlY+eyifYb/5Q6WGTyKb0rsKWMrD8XYGTQbNWoZZjOVavlzo16tvhCyaq26BNLbU8X6cetTV3ibam8As23f1sUcT3XvlCu1jounGfto93XkW0E4A/IIRL053wmKzyAj/YzLIN8S0n2R7wDTgVHsDKOaFd0I1ppWbI8oBaUwntQsJ4V7RLpFKtvCRIK6Y17mm2jg73t7Bhn7NOsZxODUr6dTcbR8F+ANJiKBZnDpngwc2Bc7MHCKNh0KGKF+P38Cg9Gp7gQMNtPdh4P8Ckcfvl0NFx++B7+bk4/JqxU3Hw6b4egjQH65q4/gRLYCP5S3fC9E2M4aiQsVQh0dGuyvrNnDGK5ZNQXY6PermaIcrmrFFIDJcNFUePh348KWE1xhwQqEhnOWCvvLHbPUg82o+qLcg63jwnOk3qWv68ajdcq68sjX3+DOo35jbZcerdP/frceRQD/3+zaI8Fcx71HIcDvWp3lLp5hofLxGAGCDRX0J0lu8RJtP2rJ4PFKtxuk9q5ESJRNciPPARksnREf2uiZzZq1JBNyoOThlzdgEU9+rNwJc/4RMt+gZbl3E/MmLCHGyuy9+n+1wdLGm/KNlpbJ5xsuFeazzHipMeicr73IiGn77pozZ8bMOFii9uPbrNKPTw2V33iEcdPaE6Hu64/1LxmqvvGIjWlT8/F5VsnPPmVD5Cj4+MpU7wl6LMp95jlV7TOPlZHQYPkUWgyWjDWGyVk8DH7qYj4bnue62z26gN+LefR7BDyl+wTH2KQdfSG5jnXz2S9h0bmMkmkwCO/CYFiYgWwDKlAhiL6EsziaYA3BwlM8nxWms/i3YAAcdRTPx0PgvIPxfAhsNi1gTqO0EEcD6BamowAAjgHEG9gdNxEA91tSiNVno3QydtzFKI5/v4xGxPtq2AlwcHYZTG6+WeUN+xTQMvhLcNuNB78HaTu6xwOPyAvrdf2YplPZCy9zX/hJfoi8ZhD8uK0/ZtddbwRc39N+1GcS2xqdpDsHZpp6USd+KtGOa+JY79oJJnEaHKIIchcOWDmuNUZZeD8n5Gx6Cr3/E9qN9mwbYG6XCxCAQWObTIXxfTS/FaZ3RtmYq+Qkuov9VIh5MGIExMfXwv1KL/3CRHtxFj8UMWcTvOYd/zUPEjM1MoEX9AMi9Yic1vIA88vbHvt5mtz7zocgCmbh4OP8FmSVW2qoDh5hP6aY7j0S3yKxN/1wPJ9JEGlZmk906ndk6kUrPtBIXgEUF+mNapgc0pkFSiod2aacHWFP4FMerOlDPPsdTfPxPBUDH8czOGSGysAifTmKFfD6IojQtvD3OUybFiaAdf6cNovce604g65Xs8qn9ofW4We/eu079E/Hw8enJ//A1B7wlPxFH3bbcBq1/To8pX/Sxxed8975zeXZ387Ofznzt+Gt9sRZuMXP6fMz/ON/XbguYbYfU35dkENqJI9QW67nO894TNYVF7SfpqBkIA/FBPKFKE4Lt0EQ8epUuMCUZc9vaUl1TATGBEz8+f7p8/AR5TvNPEejo8tv+L1DH4VW9nCXPmQtcZXhFOGDIjl3qOQ1S8SwjM6zL2D5Zk9HmNDNr+0qlxiEcjBbPOZ3U7NDzB5ag0GQJMqz34Ng2ps9wXortcmr5jtGRCdDpWdqeYZnHbCQX4Du0GjMT7xh8AX1JvKFIOHDR9j0Ik6EdZw8OAR5+Okc5imwguWNkrQ1m4WgSYiqZxvysi9J8GNfF+wBYVWXs7FE1A3uTcJTxJN5ElzATsVMXAJMIi5ydiS4EFvvFD4cDBkiTtE97CbSdthpInlaJ7jzZ5X7cXzbH38kP4lNIpiVSrIR5Vrq+sBDkgTgc8r2y4L5mLHjS09KoBF5YKPxVE1epQ3FmYEFs+aFoQ37pHvC5Fazvyi4Z123YMH5E672E6y/8UFOFryduqlM2NR3vP2hurWMDtq245PQO3Do9R0aLIyUyUvWQjY9pRkyl7bGhGWO08iuHq2yEM8GvEImA8zYTLnmrwXTxrVTkDnF+U6HPm0USC0g+DdthlhZt+Q7hSJKEr5TCit3WF2k5KDHokXNT1yOQro4YuE1PhjwRj3JB2VTlTkGjCqPxMFODfr63ZXssAfsNNNFPTGtPXhgjQqkMtLFLDifdZhlaelg+36N9eEGHb2p2OIHxu9K5ohvbNQE+Qr2baN4/XsHaVoBjeesfdhrc79KY7bYpPX+vEMapJVe5zPoZ7miwJqQKx055P3h8G+M78rFFZy4wpSRpChU3nM4YsOoP77sfCq6Lg+Akj2I4SKntSJbse8JI9ef9UntUOBN8ONweMBRtFF1fanOa88ZMtSurFrhLJ5IG9dieSuLhLFXrnFapgwe9uSn4Esw3sfE9TazHGEkWEanP09HhQGQN4wFYkyChrUCS7RpzLETx2Q+GtaPMepsCPxnoFszeHxVY2vLcZspSc6uvdiCM720jXWPad52nuAaN3oVrc5uk5ZiQyH9Bgdv5uFFAUEYkz7GCSmiw39foDcw/w1HfhdzGQdUQxSL+mLsAUUU+nfAHgooPoDoT8FAc2djJRablAGrXyYUCGJC8v4J2lyFmU6kEGWyuZls+KQjLVWkI8WcHLTWyWXfz5KQ+5WxlGgE8iwpCM1sjAYCKM4lW0RohRlco2D7nJbihBbZ8CSDU6BZExQCBzUrvwyz5NML86u242kv0H4yGrGdbVo7GamQ+tVmCqMoqgN3Sk5LJV6DUHt/lV7jsbxhqhzwnJdq1Z/6KNrdFbMrvY8e2IHBQKp8634Vkk2j6nHVt0FUJEbPQgMCYaE/xhTmTwVx4joLDwHXtBQx7QRt2KGLFXxkVRTyWXxh9HKzehCLi3ObQY5+lNm/2/b9mzObMJETKYASuGIDlxyvMJzF0ylyAqlrYbgYiFL5+96jpwPWW4wjKa4UHUZ3jlf1loCYwXnhS9hfyWzYR6WlBG0kCkXSFSBlRPkpCL1yT9I079BMXSHVBw9C8qbGde4DyLhEkXzvYzyfJYjMESINHpyG0TwNyKMJe4R6VdH9y5tgxywtU3JuqtRpChTgHoixTGg6VnIcKCaVUtDM1XX3Ur6RrJpwmqsJb26S+yVuXslr5uar0gmdIvYuuv7+1zV0bk1cVso1r3mCIaqQxJjqDicXXrEOgaBViZsL+8MAjSPFx8rJ+U270znveHkD4BWYJxMiU6uKHtKnSqXV5+dgv6q81RWiqtVc0wkUCL1c3msTlAim8IvmHSdFWxAlcG5SJYtmaEb9CtTTzjyKaHWgbCeQd4X8jjmblVPT0ImMm1LLflwEsgq4nahr1aq7sKstBy8jAdifBWAtyFLo+gInkYitVCpC1bNZKDJWEPXbdnOIho0yvzMXZqqiWuhHYR4uz7ygL2R5m883Y+h6JSIUFs40ZdwQxLRWAO5RKCKzL1wxTqtZBUrONWrGWT6QBc5dwzxn2gTdxp8zoSguTKmJt6CCUzjYOBCK/jrrU7Qu0I7IZaE/r7tLlJVi3nmNhzMdZ/ykcylPB/4hHI8Lt4G03BaSGB7nrZvdoOEwUxAGpqeBkOV1kdnakfIgs5/C9eAULxJTiyv9BZi9XWr8InA3yzRlSaHKJOHRiiqH9CystJknCsoIXLy83/Nr+ugE9WgMlxKeV37btB9BS9hWILQ5JHJmdo6a9ArmAgTtMAmKxdgb4fEX6k/n3lAcihZ5cO56Mf6T2I/RtU9EdpDhUpD6sqAH65sIKGVeVOTj8ltFQF6j+4IcjfAvxQWvphk1ly+zxlTwZPkjl90cvEpA47U8hTeX2WysenngyuPGJXCNxX2Z1sq8wGMiwYZxwLgvW7NxHP9OMJ3Mw5SkakByDchQuOEDdX9b7fzKdQDzSyEuKhxtqjgNMilpinXFii43n2ZtEqb63bQJ5tQc4fuPlc/nh73zm6P2cevyU+8GoeveYHwXmmCxTk2TXlUWkwNnlKbTBA0qDfInMa2Ullmj0PAEInKIr4iDUvN16BUDoAsBKQ8vsUvqFqr0rIyUkFtiEKu+VLSr6UjhnC4t4/1T9/yMOlwVHzXnpT4aZygrrKipg3Stu6smFdIb4o7hlavwTmXD97/E4bCAZKu9wBh8KZll1LPAe6xcnh2enx2ffLjstI88h96VcyEKueRTQDjlXXg/xytDRQw0FS9mKCHTms7iNB7EYwSI/+0D6wVa2KpVao44FTUSruLEkH4pKY6Zs1hzvEcfizBn8nrk06dX41LpmpeAbSBL80dXVQyCVqu+jrCmZZMUuwWk3IJw/3tT3zCU934l4DbmHj5uDIG3LRYvIjFJWcmcXEjewfZ7ov5zQ5PUmPzcJ9TQV+7p0dGs+wmvim8O253eqlVU23r9CqtetnqxSID8ywyFIoEMygRysndwtmU2El3F1270Gmz0LUx6YyvqKDZpvP4mHWubNHez6bs1dvkqxatWQeiSsVgBjmj4H5UWxAiXSfAe+O8FkluRUKaw5ApHn6L7QsEfBi2I3mQb5xwdUgGy483i4URz9kjZ+AUgEVPyt0GjOE2x5EHoH5xz2uasUHnbQ3ez+RT3NmxGhIhzJxRspWmdLopcPZXE5IVR1nmHe8yTKoFwcstrMOnBoSmNVdd0wkhfZrhnVjXYdtJ6pm/A0OKYejELJ/3Zk1DuKfkZF4CEKYWGVl5TDA3hi60MYZ6JIVRZ4dLjxYAnNAzXoY5f/TUz0oZ5niHhEhMFu9tYbk1Wl8FZeJEfGobjMGvnDU0bUSLPAe0lmooSIYwKQ2cfDZ2R2xdX1pz4tHvjlwqiuSMVVhtmLfJ5eduQbqjJZNt9hW+NkkFuFk/zLFV5njWqs7bpfdTM80kyndaj4hI6kJQLxDCZQjckBleI4FZHANe8CZdI2nVfxRKWG/qFhQxL49akVpW17mi35y8AYagQjWHQUGz+CcIAp/twmTmDrRq5QKJyHhZITvwQ5LwS/F0qEvHqJEpJlhy3VFMt6lqMlfQr29sNtrkcKp/+4NdfgW5tdnJKYcQXQn4A7f0lJ8HpJsoZqBvIklyTmt0i8BLTGzs0rVT4UqN7h1jeDMscGuKM2UktOUFzuoESXOBFzpnNXJuzlvTUZkkPbbzHL9cPLNtqJ88Ka+VUu26uXV5u0MwyAD6/3YLqGj6J1kFT41JG92B0MeiqusRICTqkQzmCk0/lyhrf9UGgHhKhSZX412C92hGaStYZ4nGZtYg1rc6juYefLjVQj2ke2kJmmd0SBxs1m7l3v1y3EkL9j1mONXyRrD7gjGiXHfRoIuE+8PSaC6OAhHKSUhMo+gQTf2B0wwtv0QQtToQlUjSnEk8mK7FIa6++UTFuZnRjssKslBz+lNVRO2wz1Q2tmFGHM0nzWKf6foKhmn+KmXWoQovH1R9haeW3dfrFTMjXG3qZUnheFBywL9qouMKnB+X9QIpbtO4vk6IoNKgJ3YGANqJ6bCpTZBZs7Limx34SiOYG1Degl6HxhIVkeiAnf12sojfmBQxMxbQjc01Iwksuj1oXJyvjpqlqpBqH/9NzU77OOGhYiW9/u6HBg2gZJJV3Kw+jMA0u+vdBQhQPW5OnYDyOH0gbETV5UEz9F8OMG8tL96oHxfWWRN1Q6jHuWd9I27+li7BA6ErDwYsciEvq8EMxTb7qp0njZcPtVomHX2M9dGAmZopb4ldDs/wlg1l4GxDZnNle+7ifSWJm5aJdSOpregbJcOXhHOXhAp1tIYjmIGAQzReO8UzmKWEEsPoVrEfSDGgQ4BamdmNip/xukRfYZL1UWTPa6Z0W7fSR9+cIDqMQXUQxNB2jnSwls1Vjjw4Xdwp6j4m/+iSjA0t3+89/OyWSE+xuHIOYQtOD9aNhPCm6P9TevH37tl7bVRSU2htY83//0+FO8ZM2yeT7Ph4+KWkI/Jxa3X8lsbFRWobTcRonIV1QHKaM0drNQkQyMv0V6Ix6vP/qNAtoDqXPYTjn/83+hw9CDqcC5sjFUDkYaisGqSItJyQeXW0IM0ruglmZAAvTaBQAGsADtIH/+9XNJr7nEKcul/Sy75xy2cH8pjmvf6VDj/2rCFhQHxYiINUV4M+I1ki4xmy47OIgxpjXPZ72vhmXSu6o5I+v4mv+CDE7J2R0GUbpuxYJVx9RJzKSJz87whzj74s4iDdyPWM8RkFzGY//Hg5SNEAHM1H5XeW2nKqcD+2e4zlbd8DqRsSiftD3gTBToEsUb2oyQls7iw5UtqK88gJB97AZ3UbuZVRQgb/YOeG6Ffwkz0cQziYYss0iNIxAw40arBIok2MMVor94sTfV0FR5M2JdzW5BjkiKe56zuEoGPxeuBVIKaQALDNUjpYhRt4D0Hs/j9UbweN5ZD2eY+FlgVsdZjiNiWMI+9pcvaDLSTMw0pDjDf25dg/XHFaSMUpQVe+t6/vOzyed3sfL984BogdzRw/xr2qjuHRmt0/U8rtFlCidAojPhZirN1JviECdU+ETWf9J1YcNrOagj83cs++NzPwagWJyaH1On2FC3Y+fHG9KNsUUNsR0757T+5T79k78+6spceWe+H7gAlXUmtTWelccbG5O7IMqS3UegQYSA2v+jJHasHDl7igMMNQbbUVYXpKYU+jBU5hgGTTiDbwRbW6ONzc5RCClK4P24rgw6UdP7MxLMiMQ6slfnP7666ET3mE/Ii4mhNpJJ9RT+Y4CGBDj9POvoMN5JaG2CocOhET9/CyfEpAJpWcgolUpFECGxKnndp48oQ8PG4N48sCGrVVJmaqh7IAHB9tALV/EzE68B/frZB/Ehar3QP+DnUvF+rsfJlvwBHBlGQjNB5OS87f3hS346wH/gkXNX5OL8y5bFDrvConlJzUl+mHR4WODMCM0HKxe4Xotd+lqHevrohg3RtL347+aVDZ8hyTxVynikk5W/RifeMhS/vMXJmUgLHivfw/fSWDsWrW69sjcJK7NLOJcJGdWoet11clP3ApmP7nzvy6EKegQd3fXPQR4uL6DfgZ3V4fXfhf+oVT7lCdakNFptE5491S8cwlgSXEbZPVu/0vAffUwHRZq6QnIKa8iU7IF53hvcceOsiePGoUyZPL8jAD8+AcDwBcFIVjycVfdIWT5SNkYhIRDAAybqCiEE0duUtwBhnGMu0CsvKM5GGf3jHK/PwtQLiAaFV7bHxi//TKQ2bbcURmlpDsOgmnxbbDtkqPnq56aasWx+xI46lL6oFT7aKqD9WDHe/AwLUqTIuUXhAPtOkz7AkzeBkiwUhSCnTCMSbWC5Ue05QgG7OPxiyfv1y4aWol/y6L7/JyDpF30uX4YoVPERndz04R/b4Lcf2c3u5hkwne+wWAZLKXdWn1/H5j/k3foK5a0F3BKvLgZBVGxg06Td8WOJvBQJtHzdQm2o3I8r62yiZ7bbGdPRWAKbcG99urVA5xqSXm2tU1PrPasj9H3BayTEcbzROABj4bi3Q9KlzIWHXmH3cR5dkfPs0be6McMHpIJZ8nI9aq79faNbWh38aSaLg89sqxuhardHd2QmW8QkEwaIUJjQMf1rCMvhBZivCb1VkZrKzbkx2biw9YT21kzaD6ZzOhg9UlJBnU0VWetM3KhZPLKS3hiGAN0I59qI9D7catsP+mw7BRFxYAjMlbQO4HVymGOLxTFqvrEnz2gB4NkU8YHA21b6eXWeCMWR60Abm3G8naBvmPpDjQi+gssSihIPiKSQcISpA1PF0bwlt5GhmlR3cLl9hPqRZYUM5Ha/tX1whYArY1rGMK1hgvTOr6sp2jEe2lOZnpX4f6zsDmkcdRJJyGZaMJIhKONat6/8MGNTnz4bBoQ3kEYzix7QbbqiAtd0UzJ4kKbdQM05Obns7Gn+mD7SHik/RSHkTVviNyKD8FtYrZdZP3u1LsR06GZtvBS7a30lMgkNDEcsIVC7oouirer+7WIh9JDwoqpPiQgz+kXtNyScnbeu+leXlyQRAcgSvCZCd81buOQnm23T4WfQ5AyyfVgeQeQUXGUsmIgQYR7VmibIdfoufmON7gKaaQ29eetECk2+SVMR0Xi0em4eQ5G2y/1UqGB7iWHxr0AzqAd+yw8JP9FwRMBo2/QY9hYJqYCUv1WrjcbxmOdmJy0oH6wDDVeQpalWTTmX72mnWGxyIR5LJCtwQNZzCyh0FRSciVo5TP7SkR8JfrmSkTXTX1kSYPw0b4JZt8O1h+3TrhEk/AR6A4E3HFw3x88MftKNvcPSZvlknrCmOMahLGQBnv2cwlLzEB7h3NxSUgBe4tFeRkt4OjEDz7IjM/Qkhh4oYixjLUIN5bEov4xtG2h6nBdgkaPXHGAL5gD8SkuBmLccq4KgiErwYlYfUGJdFXetDVForz+i0XzY2rLIgU7AhOh/cQy7omqKf8nzFbMyRZOCVk4i+L/NOrXRLot2O7jifgVYdZI8Sue9kHc0l8SmJScXrdPEUsupCYG498MCf4n/d+Djn5ZROv0sbx5/VtYYtGAPUxgjpZOPBCCfCz2HUyCujUd98OoCXIwyrip/1iGFZ+Vh8Ed4HvoSDdDBhb3YmE/KQ7Mh2S2cCZJLDFXGb0bIxfS2mxAh5AedYhpyxAq6i0DZJHPLwesiRT5vurOb4/iCeAFr3a9uf/VeSw/YSYYp/F1EqSjeNgIPFB3GiOPjN2Qn1ksFO9Hy+ggvbdgIFKflEdJ3fu5F3yy3JN+xQc/PsUPweywnwTE0F4slYy5Lu0wXY4AEGtmyFgawuEQcC1/5nW76KNo77X8gLQdicJ6mGxR15xGwSMqT7bXT6dHu8Wpa4L88Kqxuh9btWIrM1jXV6ZDcEZ+Dsi/9/Avrjb8+eDdvf6zXfOzzfmVoKTrCm40cm26xlJ4Ws8BJfh7/Wk08Af6k3/FU3Iwjhz9Ob2+SgL/Dk1tIafCvIkSmym5GYUZVG7j4ZP/ld/5NljqM+/2zc6A3uY2btO4X7wHpgz8j1oPx75hEJ3TfThE2w/PeHSANiuWCCkVVzxDl/vZA6QbinI78jOJPOXteXMp0yLoOwAOCNyO2DSbhVvW1QeybcCbCWjzIej96ZZy+a02gjnp3zfu2kNv5GYcFUxuHntjxprZAQkKznHAqhkpqY2FCxoeU9wSY3J6qtgzGwiLI4amec7ljkdtFo0E3cGKFAzo0D9Yc/TxWqOPyeikrKxrdhjLDjHagxra20S+jRbEXpSf5lbVoyo52Qq91TSRNV6W9VYJZpDdr9WDbUVmWeLcp28m6uFHIkWUYDc9wEarbS3IQYlRdZuJcXGbsMzv/LQUIoRivOJtDCzQCWVMzkpqJH0G2Wgf0sJl6bboj6/6Ulj8sPUEPuoW1s0aORl9VFXAvtpOtkmOfysPBaL6muM0s+mBZfrNfb96AI0O+rdoblzWUokYaGRgtSYD3aiqIL+IpM6nAQZGFVAXMTItoednkfhVu6ZjtS6BLtn0zhY0rUBbGEcyFsyHsJHlwUZS0aXbZHvJnC64mZzZLQtJikpOwvJxIENWdo6aV03u8OJatO5l5qAnUt2rqmDao/GWk7HijmnNc51Zd7Jn218CrLgu3qGb2HfBvIg7ykG4JXJROU/+U9AyGpX00n9KGpkgYi0BHwcnE7miKLIvg0ZebZJLaw4T24EZcAzCYfZM4g6LNe/LtfrzM/63XgVVaKOvfjiHs1JXWq2VmUPJXZET3sL61+RDn9EWuTzmAF1UeaStxoDY/TBzBQ/UFbBTjAy51nRgy8jLFe5vP0RSN8/b1DSXrCAmax7i1ezpQPFcVQPHs3mB5lH/C1AoBt0DNWqSJdut1mOAzkcKfasBKr4OJBEO/lLSY5mZ4V+SJyEYEiFBgGHrxl01xq7r6iLqN0JAvVNwz8c0IbSODfiOS6XZhff31XYpSzlfngyld3hx0zm/PDu66XVOLm6wTI2/XbU0Om394+aXk7Oj819uuif/bPs7P7zZ3d3mWfc/n5xrrXGc88uej24HskUNi19f9tpakzd6kypr0zUa8ZT7l933N6ftXuvmsneIbyk0mbdHn44/XXY/0rc1823r8G83R/WPNxfwR7tHG9XNRr90b1pnZ4CbQ/aR+jtbk8vex/ZZ7+SQlOZe0pAQL33/xgbP5cWn89ZRTgPoT0rg3KBRIDsfeN35hc9AXDSp5QMG08NRPxJZPLEuVQv5zcnQ3+HQ6qF+Irh5RlKw/BzMEqVaAXtq1GlgT8+IaUGU4Y30n0mQ4Eg0abvKRJUXUay+wLs36sLVGvz+/ikNEh/zqVheEsBt7zpopM7tiW+NrnPxQj68exgak8EnNnzjcyXjs8A7eT6OE1F2TZ3mQE9GLigSFq+DVoPeLJwSKFduYdnxtP/4SxgN44du+G9bR2NbK1AawLDE40gzMg8HKUyjXJ2+WNb5pdtgHC8Wkcl5ViwlN3auDr8cka9WisQSq5pRngRmMRswiWSJTTeT0uoA74BofpqHRMlOk2vjU7Oga5H9D3y5cDZFwDXXxCyA52qVGzprWUM/x5AiKcrCZkD3GEE6hhgtBq5gkS2SqcYvhlTyXyXEbfjBqw0pJ+j9iSssc9QQrRAd44STlW3N1eRSZHCB5dPkvmjEbzDDp5uzz/0d1/5i11tLZ1RZsSuc3HO+VdUv0zVmfOBINJAHMrmi1q6hXPmfbJ3TttzqoXNxf6daO1hNK7U6iLoNqyYDdJSsUkd4sKJKRoTN/keISCKNfBP5UhB+AbpfQUUeSUwwJx59VxZTkAFijvL5WlAlOATqYYafZU6AfPGCfEpJZFFdQ8tE/iDJaMCYTRYuLcPbLJ62xmN2d6uk8lzXUmcjFCqH/GcJhXxzbUJR2A3P47W5WdzYKrTxsD8CAbmwVcHciUXxfrn5YUfzBXnhkW1MgsGIXpqhCA2uDMjdvXPUvuh9vPlnu3N+021/OgYZ48NZ+4hkhXPWYAt1zIDEZ5TLHmQT9z9Hjnm86IWESBqmy9Kc6y2s3ezpAjLVY56fi98gpqn5ZKhfHnfXjUGuyJWGDPTwXCvLaue5PPXKdJ4GeNNthvrRi9aQ3r6K2MyXXxBHmTvdsRl6eVVMNuu7u+7+/n7Vg7/f7NbfVfHXO/xVe/O2VntDH9TeeAn8p75z7Xqx3y+tAGps3uvm2HnkVXCsd3BX1BWyCfE+r8ek6S0bvpraQpdkkNnNnr7qmaKUTyqZOZaYpbXPVdAsZNyaCNlYTtx2h2aoqC6mLsJiGKChAeq30VGOuJuEvv/O/cp92sZ+rTneC0SIbankJiVWIb6CaSJBNZ4donNScDW+VoyC9hkZbkUrzO3qLFmQscAEkC6CvvmWwVx7foZ/6+TfH2kGzv1tBcM27Qv51mXES2QW7mb9CSn6UWAqP0hwfZoOO6ShUgo8Y58jBShWtRNc9Ylr5Ua8xsePMGO7/CwTJlZ8nc4X5jgul9ktPuK+udxuvLuERRHwyk5piBnvNDEMWFJc6TNjh8g/+/LTO/8LBRK4gqbbwv91SnHlhmg76FPXT3j2d1WMyUMlsciMZnFExADtE16BxwGMn7iN2NGypqLML+a54Q//jHmGUZIGNJCOtxKf5K3XmSiqXTOs4sSGoZ8hZyXMJ0BjgEJAMusl9dmIlWgJLxssz2N/xuUaCwzE+PgRhnTQP0kZLFoIvuaNMbCD9kA6kSP7c8/YjMYOATjQjEZakfcK9l9PZd1cEvjDsN9dQmWspghIPqLqbobKTFMAmXoavwcVNEo3N2PC4C/iZE8+5RhecTG0SgYB5FOASY5s8SGY/B75bX5uhagW50pesSpxqdwD5OZYz+cRK/k8eocXnAEy2YjFlOIYA4xyimcuSWAifxdjnpbkXqQlWVCUChCYc5VB6UDe93B8+LU3pb6p1pAzFv2nFnF+YjBjllKerHLXKnVDCC+r2jbNW71XdZfg4j1QKncSK4wCElDYFG7tyz3FtM+KzUocubyBf89zLhZorO4AkeA7539z3K8qQDS92zRvEt6wVKeO783pPvzddIf+1FvRfIrKRHHqDw1mYYd4Cl3EtmFgVgHMJWhTzvIpmtwTdIdTE29JHE59kWRyQJKJq8NOqemlXKs3jC+Q3MdUd3NK98xJDoHjjBPTXFN7bIz5hi5nY6QiuQcOXntG82t1/ZAcggrukfC5OXrEKJPQMhzCTqcnKb9R7LvKrkK2o+wotxGb5RPWOnzFzb8wf0nMucrmNM2h7OKZijW77tfkISQeeLgsXwcgrxd2GujEwFC8VyutuGwSupp++xJc1a9t1zJ7NVe9/I59+PT29d7ejluCv3bgrxoQb7wvAwcydwOxa7nDCa52r3GENzDCOzLWWxzrDfnzHfxZ35GxIy3/x2Zrrw7/0Ajg4Kp1rQhc2o3Rst2vnM8/ei2XB8XQw9/ggTuKuI53BMTp+ef+GBaxKPg/vbPBHPwlknafzmUEuGRzGRFkwVzsN2HLVZMcc9m2PZePdeWzd4iY28W2zixxqP60UffufVJdZo48ZqfqzWGW/i78p37tD701HK43iNsG58r2e0eWZENNxSg09HX8j9fx+86SSpYqJcVNYNaTvRbX7CaYDenqx9Lk2m9dTa4Xc1hW/x71d8DEDvxJ9PY50LSvEAZ7/0Z7iC3Zi7fmi9ob9uad+aa+Q97YzuI5I+Mm4Qa7jTwL/Ya//fy8nE9YqIXt/aX3hS9SrUu1nDvEvXp15x3n8eaX9t6q/EUH4i2VKQa+fdwfQJXfsnfd3682X+9Q1On1hJ+lOXLJmSRe4Zeu2kCDCutPKjfBTmlAsyUX/vZ+K3Fc74U8WmHRUx85NOfO74ggU5xu2i72XZlWS7mqE3HMG1WLe6h8W3M967hyX7sb/Fao5Wu8t/6jy8Mv/uP7PdJ3+gPs9Ie9Cd/pD/SEmVw9XG/AXn+45oeMfvsEEpDV6cDBOeDdPE0px9xtnBxOXtUvXczXO7pitHzCPvLZnHGaSvGTvHksxTiGMA4nYeTwIraKd6IMmz9YByP9pECG4qhpWDvhnB7i2ZAG+6Lggb6TvGLPSnwqDPFNwzZvfYt4Ky4Y11pj+0SUMkNMf9Oq3aUjITBbYMidpjK/t8jw+wpvkHYEvvWMx7Dz9OnjX7tS+nrDJJaHFey9qRX+1Dxl4CtENp7s5/nZEPCWvPQnXv7Y/gPhdF1/Us51x8GJ3vkP5TyPHGaJvNvbrVafn+/2apgiv7tHfM+0okn2sS3wKSP7D15LpDU5vN3cbClmDPVNceK1MsYFlr2pS06uu6bpNoTjV979YHlcqmz/8IT3Ca9Uo7D25EwrfagNr5xQhSLOGzO4dPGpSNmSoE5JbChFBMRVuriOVtn7Navufa8VWaEuUn6z0Pz8l1rVZfoCdsHY0MJNrPc6gWvWoLUt4WUEm3yId2iBSH4DzFa7e2lgDtzFQnPh6dKrk6+6hMloJXPDsmDRogYm5M0IMqlgDw4eepxqHCi4ZuLKBufXG7VVIdhKJZNcflQK8MaG2l3EGliA3NwMQe7j3iokpBXOo2Lo1XfdJivraHE+Vq5CI4x2wGzqaXk5SIs/1fdagxKjrgFKqqRzf99fCyxHrTcyb4jmNi1wn9bVI4abch2P/c2KAwojdxHWNc6q666+VykOmUHGL8pS3n95E6hpgbMxJjbLzlBYdnC3sClirlJhn/H78IMalvwU/mRWXCx3RJd7sCwsU8Qd5wZNDtxm7Mci+hMwVHL0dMI8ZtNTwzEHpV/5MgwFazHVd54MozQVTEc2JrcLUy9WXkmO5YfKD8piV39GCsAD2KqDPZGLYwA7Vna/GuBtxIBdY7bS4oDmCsTbw6FuaxxqtkbJ4eR9S0IS7MvlKg45RxtoBuqNkRlgkRsDk9Fxd1eGiHBKGB040v3SP7v89MnByFCTCDKfhm56nXXsxYQsCzwHtE4WldxEJWK9WUOL7FtnBzCh01McSLEUePwQkUDxaanlLpasj3S10csDr7NAc7KnudHWdPoulTJ+4Pt+rS7Ud90/XCTq1Q6IhEhm9/Q0ad6TPk333md/0f/4Q0WakD39YXPZWZ3wCCPLO/2YkacVO1GaSn52gfU/k1DXs3ena9AE2hN0YkjXIAZoJK6WkC7kTwwqkjdLGBBPFgZD7MNoHrBw1ZpgMbC+fBn5KrphqUQ8AVLBa1id2DUv1JfIsaFysgBa8Pac3ZV7BsbohHnhMukDaZ1R4qfKPazHEoOn/JTBmHtTcMSoHZzleL9eqwrjln7k+vXNTeI+S/Q4+O/Yx8a5EQpAkSJWIismKy8V2T24fp1xTLc/WL9GlongoJfnbKa/pSV9lQf5TmbWTbrICV7QK72y/N/lJVj0uDSgIUo7AJZYNW3IgGOg/sOgVKvWd8r3pcEPU6YbIQm0Svf7K6MkgEu2VsdSlO9dr7X3ZodnEoaP/FCs1d+VW+7WAD832QOaKk5Ifbf/7NJMpBvQfr/Uwvns1+o7ZF7F1hb8iVrhDzW0L4z9Ph5ThLv298ZNfhldK43L/eY99EPxEX6jXE7P7PtyDZrW3oGY2i8N4GD5ESc6gP/Wyn3v3gfcu15CXvrZ3bi5eb8Hgx0UM5c999gPr3H8t3VQI0ZX99dys+NOr7oNSy/W5x1GjY6IjKZ8U5g7+x6A43rwhX7JH3jZ8Amie43cBb3WAZrlLKXJCmdTKbbvib/30qwDBEMe0MJ8y0LXSBf3hC7uvwNd3KsOWrBAmMs+i9C6vgg1dRFy0YbASWmXJABAJWado2upSwh3WKH9pDqN/sj3dLGGGVaRqfVFl5DqJCgDsT9lYpktdK8e3FbSx9QhKRz4oHlxjQ3LGAD0PcuO+vpBZo+T5P6bx8CAFHRZeP0Y/fTbkIHZf5JvnIeaTTw7iDWU1AqKSAX8LaN8/vKwcwKjkDFQ+l45Ct0U1t16D1qsumG1+HR8ufCGrOIdWqOjl+nt6/trGJIYMRwWa1tYmlqV3lynhEXVhV9aKv3SvAIXz0AF87SScsSb0cGq2Ym4wWQy3cKSmc7jsqfiGKX/ZiEpmnBKpdys6xT6ajDvqSCPbYXL06lw41RNSZ+ZNiMqlEY+/cNNQITOQ3GytgwcklohbKaOu1CJRS0qaFtHdNGdItJV/1KunPTvUqx6Q8ci2SUYaSvmVJrDWGhn8LmFtxtsEwJcbUjl1QRpiCcbHb2C0Z2P2hxoGYfFIvsxseq6tgdyg/UxpR6NBAg/z1Wr1gVOVbNyD6sE9azlZ+xieRzT1zzf/Q2s5Jd1pucKuzVk1+Z8T663rH75NC9aU7cNq/jltie0FvNWWTU8FXvYXbY++dVKtWAXzSkxs6yvU8sR+8buKkplHDVxd7kqzpZTJxgcdYo5G8yh1qIcLEnHreuWRNG6Jdpiviqu3IUsa4ZeBHtAM9j/FqMk4G3UePIMnTACe1B7mhfTHuaHkde9QA3xTTjbskerHOQEse4e5DDshEbaNpaKjGT9p32yRBj+UYCPF1oXJ4Vissz8R1hUIx/a7QPlOgMvd2BIkqfz9/Rb4cLvabBZAKAc1CX4ZbGvS7G7TgYDdVUV7qM9L7oL4+IN5w1kNY8GAc7dlaY884001Wlg8Isn6nEWrOVCpzpPYqriF/gJYn5m5jeHDpv+jofX9Eiq6D9mt8js71NXL7ycz21Sq2MbI8v5DsloHlztlkLoiUnMbVnQVY8YoReHe/Uq6/0j6Z1tqtwBhHpMmUxesY5TZ/4O3l4S0sXLpmfon6ZXfKlb2/MzrssGLMxrE0z8etsfluEBJi2tYaHG3GlVFc0XqQCYKn6+fr1f/yM+Xl/747kuZUXdHWS5S9cqu+yaYG+vDbZtG78WgCguw0Dlh2S9r5O94yVZ3zUWb2ecW2S/0b0WZYoMjHkknOnwFsFOJel2PfLXtJ8kuc5rYqsxaQojEcTV3eZmfDUG+TXBeDeMRaSWZ19c+VEvBVRP9v1I2I2+fS13EJtBBfTucbHqbS8LzVwD6UiMz77NXdF7BbtpKmUF/kjMkyBHxH5fjf5E9glL0McVeA0Sdr+xmD0n2BWOEtvBNhbgCrFol16fYYfUYjDF6+ia5zYOZcmtMJMHnxPQJBzMYlJ96ybEPPdRH0vD0Bpc0CvZXw6e21wRU+/QGTueknYsL4HHymyCOQEXOZkq1s8A6IWGx0Vz3YR+htAUCrFL/JQJrsiFbch1L0VZDCuA+EkYAdSAcdNaSzopDZQf2igL78dq9Y9Lk5Hy0HKZama1ArJRa5Akc5VMVwBvmNAcdXpiOuGzi0U0giFe1LHhLcmxut2ji0PcQP7XhSxdHvSHSqPP2OgGy9L4tR+rVfXh6WGr27tpHR11brq9ju/Ut3+sgGzG/r/qqG0vO2c3n88Pe+cXl4dt34FpN56wBux0PgjKQOYNWjKvAVhs1LSeRyfdw/Of253PN6fdD/6vp+Vuu9U5/Fj4oYBBV1u1Su3/zf7n43m31/i1lAucTCov50NcU05bZw0nSYbTBtkqX4IZFso+/UdjF/5jjqlNQnq2yOIgfsAD/sPoS/y7lOeZxikDFNiLTOH1gd5DEuTyIm8hKdFY4HN4Esk2Gg46bNGSIfNw2IspZ5c3/o7jYXplLyH3urSkdjMBbpiUSl5U8utuao/rF3FyRERAN73Iq7senEH0nABuCuO8+YPGefdN4yDeS75TdmCKgTQvlw/Pj4/L7TbmgtwT5VoJc6Ff9t81AyL+g+gfgfznO1Wn6SJEfOvyb1W9d+Q9qw5ddTAfdVX8z2nwn0DbJT/k3bj0XsbssCVfgg4/GSk9IenR8txkrwpa2iP2mtCvvUNGFf6AF2BNNQ+VLa6K12QXWx/NS6SuJ5ooU8JeSGhJ4kWVSf+xdR+g6QHTWWCRmoOiSqwGkUesbjbARxq79D9+6jbW7EWMZeISW5FdDNpt9oWlSp2I/5UO1eh78N1G6qkzaiQenU8jXHhL4OlzQIQLI1mBCySvU2pjUXYP50GFerVaOP8b2Uxn572T488Kg3KoIE0CbFlx+wiL2uKFIAlg9dPnZ/ZXKD1J+z5e+SZcyuoLedpHp18esNvAiF2uz8IAeM8ZXY0x9hR2yaToXvtj0L3YD1rEtfLpnKqEm5tR5bKL/7lyDluHH9uwJc56nfNPzjV7JXZLHh9096u8ghXtwOFyXPgsZn8RX+OvtuAVKF+xjLXNfp77o5LPZvZAn6RrXWgrRKrOtx+n4azP7L5K2TerF7965GVMpso7N3s4Slk4JXcIOi3yGxKTRFPYa5ubQTnU9tp+yHYabme+6arLaDTke4bJRbjZ2KUBB9J6TW3H08IDqdhVUdlF6UGpdaHJFCKMVogUgWeuFaZFpCZEEZBEnh+xA0pITUJOqWbGyMDpeo+V7uXhYbvb1YGNp6IM5OsWM/ttlCrFBKT9PnetUxtfRSdyubSZKr2X0Sy4x2D0GSnaQFlmuhYBpBoBpBoBWKQ6KQ2qiJOLYTivb5PrCPr5R1ZMuFbd2wuyiEIL8QUxrxbzZDZTjswXIVGsTVOWenmWzbgsBO1ZcMd9vXqdzydnH7jlFdjHWfuw1z7i+Uk7bfYIGzEzW+s9KbLosxzJl2ed9oeTbq/dgWc8PeQgffSV+gH4QX4gkzoCKYgE6UwqeQYZQHes6fwhiLR6HDAMFUZYNVi6vRynyWPbaWC7w+kiGF7Oxk5DCBu2cqUkFsqR2oO1h8jzSlurZWSzjfUiCbQHvaihx5/SA2u3qq+g+TC462OBGT63hYI2YPXfgjbMfhcmJ9El5mThMFD9/KDWqPImhiYlm7IytjNtyRti3od6v6Jlqco1c6nC5Dwag2ZtoJE/LroEMta0AxwHnj+Jxmw7VbTiwQfVRo320F1qsitlZnlT1grv2GwLhc8zq1SuiVVKbKuEm0890ZauE10Q4tlpTgDVbXt5WtCPtTrAivlEO8aXfZlNNmAUEVSMysKNq+vsFlZOOZXf2vd4lpTzu1toPYtjilrLAHnLwIbAmWlMorhiFkWDp6gDWYov66XprcuiDKAxn9WQ6LzKPhDbgctxW8xudWWwxFqJOQ8ojSXyYRizWQ2H4Er7VdGVM4DVfRkHUTtzTrFOd8FV5ABAPoY/HhKqncCK5i71AhWNUU7x6Tx4jMHUoRQGtGoUycMyA4ijZtWSameWOgwavo/6ad80wfHnChJFU2FZ40/8YIHXx+GgQBJ8AzsyaOWRuGXw5yd845RrrrXjSUTiqR5VuTtYOQSF9BiUNAGAyZEeK3fw+jO8P57FE5I7Pb+3AkWGMwXmQMCOVPgyFs00BwUa214smmkqxDj8WxHi8KcuwuETIcDhD118I2Vlw2CZaZSqXsQHZcZvPQiDAziT908smY6QnZVXGFwnngvbLr4TxQgUrqw/BzDg8fAwmKXhHcbPB/Id2zIkWX2YPp0Tm14iohmeAFOgbOkSfTKcnvYjoGyt3MMw+JIojSIDZnxwhqUtxZM7eEJQIZ7opdqrtlLtThSz/OQi3gJV86PgyyeYe5cpG7wrc77juouCE37dxiVxfGAr4tDXk+err7DG5WBk7YU3WTm9Rsw6j6ZS2/s7moyV+jKIiYC+G95+JNfwM2UWpBUfBREgXyETHHYCDAe0N7gN+kijEvthchYPg5+60nBvulX7T4lc7HAQ4IAAQjgEyoG3Lf52MBv0sHqPMi8m9JHATlgR37kFLWL2xFZRuHljIBf2lLcHTOvmmMBa9SdnJ72T1qeTf8Ku45U7Ts7obXmr8+HytH3W88t12UEUt/fLTA87av98cti+wZfHWGvDLzM6AM2xi/4Kpyfd01bv8KNf3tV6vL/sfvbLrKALL2dTfsuAYLeGxMGMfvzm9LzTvjlq9Vp++Uf6sP2Pj63LLoGmxmZ1dH75/lP7poVThac1rh2iE8V5h02Uq5W9QwJ3p906AlBqbEbHJ5+0+dTYhLrdTxyoGptK5xjdCs6Pe+LFG+XFx1bnSLxgE3t/eXzc7tz0zs9vAC2fPsEbNsOjs65o/KP84uXZ30hWcKxTxicDrPT45MMl8spyvSYQ1OsQZNwctm4OP7YP/+bLV+1/XJx0qP8IfSXW9AZvXc5ap232gk2WVhb332k0RwwSnEy5ls3p5QRIRVZU1t9d4kuTwD6dw1HwEOoP6fr5Laa2n56c8UfvWUsMJmKPPhidu70OHi9/p08/trofgcqOaeWg04RTXw9OIVjfs7Y4Odizy+57f2A0a/f8x5n2CBftlrUi9lMR6oSWYnrJtgP/y2vRFU0YvSVPcKZMboLoC97LPmKZVPno+fnnxOQqRq8Kf8H5eBT+ax6cHFkvWPQK2G9/LO2889Z8ptyjdgK0TMZHlCwSdk+deZo9q80l+G84uf+A45g/qZzGw/mY+u11qbHNc+gzkTPrexzd9f+Ko/sPPaNNOUBx7641gz2/XiX2U8rNGVEdYh9qyGY9eamZT6D69S3v2fXEkgFuwxUjLDnXF2j/RmcQ42JaJ6HARkIpK1yUHZfHbiCN/hKCetAkHymohZEDL+Hlt0Pmw0pqTpj5QdBiHlQm8L3QTt6pDTYYgQ/aJVyuHX0Rkr/KLU3GGAhWuBCVA71KpZKqwS4YDeQlfog2kWMguc+Adq2kcMkpO6WiU4V/SKNT0KVG8LjmujK1iGxE2hwRQ4fy3ot8+fZjPJ/pZYu1kRrqSKdhNE+DZFmTLpb3GupNvL6fkIwirASqfhSUnOsCForfqNF4PnrPSLKl4BWjomFtbm6RddgKad0U830FNzwWSRn7sqaywjaYH7/8AB2B+bUfBCVf/d3gvxXMZMcs9ksBd6KIXaIPxuOAkiO80z0oBsDn40kBukv3CZh77Hq8H/G6AKpgyelTWjKcVJW9bwAbHh+YX2BE1FBHEE9pGoeXdqJKO+cLn+L743lEXZHMCzuVJwcedSNGmprfmoZ3/ai8CjL3BrR2QSpvikJ5FaZ3Fi505qDhtfX+wvcD63NXm0pmLM5E0kW2/nn+5KiIIOenX3Vc86RMmNzCB8AOii8dQXCW1RiFpgHGhlSW1qx7ft4Ilrdw8ZbRWvF1X6JWfwHzorcU0QjAT9GcUwwy1bA7mkAE/BDzXqaiFuyLkBJkvpeu+l5Kviet5v3h8FCR3BRftygXx8/PMqvV30IqNWWb0VtUcs1TmQV3syABpt2kfF/xEwVxopnsWWRI7qGRcA+NyLe0ukqus9dxxIPffOr7keZvugiNXCrss9N5MuIpycKkBUzgS8AwI2PJqs10Gcwphzm0wpxes5vm90+fh48kwHNzk8R4+oHIZbYQucy4p6S5UNolnwYGdy8JCC42iule1VW4DHEpD1QYMu7lxLdGvsfoDxppL2VwQL0i4xjSJV+yeVBBSyiVqaUdlNAMHJCVCRO2m3bZmK7G1wDL1TTQ1Yz5IiUe7diIFu6CHHF6BOgRseIUdWDZkRWhI+piFeK8dF9kYzcaocMNDo4pGNbY3eIWMIgS4DCXXDdgZqazOO3Mo4gctl9lsjmrDsHgsSYQsbXf265iRpamq1jzqedBfVewgLkBkHFFKVb4DwSIEflXIcE2qh6PWmxIbWphjTiy7rhQcTM3dhs7IsPEWjMUGT1fZkOvcr8Gins6EsWLwFkCC/raM0JAjylOv3a90YJhxkYVLYkGDyyBaMx3dmxlSeNrD+vV2FipGo7G9tXIZcVU7DXRayIVaybMVZaP+T2cFkzSI8H26HOL5QyMzMEfY0y2SML0RT31+O6OXvLJzEqkEgSORZycgmTPhj9SHOVmEiZY0hJ10JAyGixWvhAolcIYchAde4SnjC1nD+89ggUZ7YUc/SOO/rkfXo0s/WLp9DrnsTS+j8nRSHsOLEbkgKC/YBmkMhQQWtY7REABqybnga8mfN6s7BflEywJZAX2QTFBVUY5r8dY1Sdy+37/+XnM8p1zD8ocHs4g4iPEAGi8N27GHMJRTser+Jo7howq5Ahg7iGgf0ndOhNdJLMJkJkCLY3YUQaq2HQ8v79XiiOaW166jo/Y2VTBzB3FXLOrXmbNGK7IB+Fnz1ypU5b1Nqd3DwU2iOpuPneVHNTOljJ/w+CT8X033r8OIswvcB/kA1R+/YLMI3NJTEnCnJHx/nUzYoPYprRY5Njpcsib6vxj4gTcV4r54UbJMZS548rN6OFkCFuoIn0ampauOYY0+wDAu1DTGy89TrhgufLwZfJBRjyYzmLiUmXUuqwCnwBOOvaFqz/Z7IjzhO9z3NIiUyw3wuI2n/vMv6k414yxotaL0tifS0zBdJrDPV4XrTnkLOXeH10Nr0kJplF/Nnzoz4KToTeFn7dArzhQc04IZBYQkU9o+wPvHi0DIdAFGpHhV3/4BY3USUDNn96UWlsGkl8PZPBDBZPE9AWT1lme4M0K5wtx9mOfbwiq3bGCLCM6rjeEv5hNHBP5iHSx225zyAMpqphcd8uh2Xwyp0tpyKGt6Sky+TnWtGzf3dztSxgpnK3AkelpDKNgiu77A8dpoKd+wYGDOglSeBYsFb4O4Di/U95g8lPA4P3mZrBCaPv/yPv2vraVJNH/76cw2tkcK5aNbR4hNoIlQBLmhMfyyEmG5TCKLbDmCMlrySGcxPez36p+d6slG5KZzW/vnEkC6uru6ld1VXU90IWlhIbziKxVskf8WNmjIWSPmMsegxk587qgNL3yY+8WedFbvgzv5H7C/DUjdYPR5JmEut1KMdmuzP+njGvZPi6iRavjTv727bawn5b8ofL5FdHl06FRvb7LfTmVMYngj6raYOiNMGl6+Vr+C5cy1JmszsyK0fydGXJrTCsACISUeiFhlF2SNFQqApqkHc+VtNMfO0XN4hSlMyWCUpmUDYhyHWLC7g813ywXKEN7cFvuLEvfDfLo5jcgecihL8ENVZoCMVTj8IQVyabD8kzTgsahjwIJQMUyRyvZNWj8KacRlhkK0+QEmG0nLMkoXVqVS3R1DIwGA9+FXfdwDBdPI3e5jxN6OOE7CQsFm/SFn1wTM+NA+bZZG66XZjO76tWzZtMrFAKp7Uu3qDa6Ran+UBFLaSHdoNouF7NY8rZYXj8qJGH90i0/y+CfTT+B+z9U0pz7nTWOzEma0Rh08veGH8v8fn16S2rhQjpuc30NuAjtY9dtrm70p1v+OgYHnTbhX2/U8DvdDZ4hUifTIzK0oXbKhleceQB2pLO27eBW4nlYGATd/YxbOBi+egDOAdrDrFlI8ml2MkKzuOiS+PzKXnG9lCXZO816CcLiPeYn3IXrv9qOe9m+0kQKpCOsO8J/1Idwlp3GrZdoebrOs97A1zD1BtxmfECQzicRBnWEy+gEvta12lnW07sE6nGzS5j++lCD/AL94L8J+3c365EkUd6Of5kCC/LF2W738Ic/ne1Or0vF0zFsrrGMYTFGh9MdSnCksxrfzGPVwdQc0y20TFaFTvK9v3PZuWp019af71x2rxok2wr8uHLV6Ky/ePGi28HfVq+8MwBcu3q+6t2Q2Llin75wv541oGz9amtrneVJ2bl8cdV/aPh1/Pyss+Y+h/Y9+sv69o3/0IM/eNbpS9MNxrvnJB8P9Gl4U79vkDwm3g17jtJnV2HqxXIOBLcQZKIZV/+8N+VeW96OtipndBWUFFjDEPMMHNHNAxvnfbeekBm946EX6PwZFU6mnwC4fge70LvzOt665jFYuhfvVWmwdp/1uCcEE6hmIvOUIBHAXcaShV5F9vXjUbvjfD+pYI2uonp2ikMGyuX8h+PKetJFkh/NNZfxJ+zQCgDUdJFBtVHCnfqyAj+0nuMKjQ2G4KHURjSAmQ3NSaQMEztfmAnRI4HxoZduj+XgJP9s9EJDm6XnalrrzUeIUBhEQiUylQQGESLrirkZvQQJEs9sSZexiJSnX6KYUZcwEjTNFssKTSKFAQ2Gqwek7dhVFtZvcm5LszTB92oFU2qBwVgJ5CL/xp5pLJtdPI+0MYmLelPkLomHRV3zL9ue8h+5E6LNFcylvdVZe1lwXo+a/kqXTIlfj56tr5KEd+eTXpB50TN/faWfbY4yfGMHfnapnm+JtPUwg9yf14JMn4Zq38tYoij8lWARFLAICAbAKESbmy/cRgDIZI3OlR9tbW2tNTM6tEZDMmGFs22I7Y7jBczH63zy7Rv8E7CyWHhlYdF27KdAZTAQWKNxBctHj8VB1lM25D67FU7Yv3+wf4/Yv5/Zv9ASZzzo3RDDpdAQ+cVoF3f+DgwKI8j4d9IgAW4GLAG67BUKxKgpNjHr7SOljiPWMCEJDfbL5uaGp/zSWVd/6656se/HPOZrjfVEbfEwVjySBxrVwLeUkZcOuAbWUYUqbr8Ad3VyGTQ7Vyz0QbMZcDcrvbCF/AGUeoRH4LQyAAGZjfAdHdmUj2yqDmuqDWuqDouxRPXps3oHfl9xgYNssB+f16cw7Sudb0A+b33yS3cF9xUAdV94A3/4nAxyDDxt17ttQpXSKRg8x9H/s6bAcIrcdmZc10LxcZx+Ss5juokPl5cpJpHDSBNWS0wsBwbNcnaAzEkrkMtO2Fz34K81/GvVa7XbHfgL/nTgvuy04f/wB67+Tgg3UIhQCP4C/mzAn5dXl+EVbzi6C+LzdC+dfoqV8AdLHY8ECXvWba++IK+uyHkzpNr9cGul+2L9xXY9J2KRT3ieZuj2QpLxm32FD33l0VwdCSaG7QjHvmTL72xHfvY86cHfy8ridZYxYMZ2M+pRm7IhwRPtSQniJsJeIgiJgi2uhIkYUuTlzsuXL0lslGjLxBDVB8lmZ00LCgITslwEhBaARcAYUDhZ24FP5qYX+PUEdj1samU8GRlN0Au4cYvNfND0tlGtEpWVgw0DsulQySV2aYZH5KRfZAYLL6MrOmKypM5zhyQt4ZwRfvrguAlZ0DXPLPqIRWR0etGW7wQOv1u4oVez06xr9wy+RzZfvgBGhPJQsC0wYyLNbYGXXmNlS9xVfAb6iV9sZHUD6a7t++bmWt9yxWFpH263Thd5kcB/icZ4DT8gNTrtWU4FgcTVjY/oJL+O0yDXZhk2T5tE/lBelWC2s76qh+4A3W57QAm8EU47kkYCN1rCeDWYKmATyM63b6Mt56Xj0kw8Ecircui83ozxj03HAhT4QJgEJO1hCwnas2ejTR+ahh4IDeu79N/t1O/04s0VKvY977Qb9ZE6V22cR9eLG5jkHAa1zRvvjXxk3Pq0boy57RMSmwZuZDi/+HO73SP/YLQDMqPBc3VOmXMaCbybp5GcUhniR9CEKDsKjoA3AVGOnJ+bOKUhgPVGboxGyGLZm6FrKvKm82p8FUm0JNMkqA/8fbfNl1WJmZh5Isle1kAvDJQVrUS9FYzH8UOdWCKR8KqkFPaaa5jL5pPupyixImbEZ81dC54NN8JcUdq+z+Q8zAqpFxccv7B8CtHOSWV1cMD8Pt3sbqMtatJLxKgA9mI8RgNnEseN9T+YDLhtshrSiDs1EVshYP6orTFsiZUuy6Oxtm6GKYRP6hNzbLx7b5AH79RPn3W2V15ubHRfdlc2Vn9P8e7pkb/7qCz005nhV5Wxh+i8EcE5bnZYsqzNpI9Pzpjs/Pfssh78jmFfCO985eXykgh+b1JzKTrR9jXF3h+3rsUoWN3nGVNT6IsslaKiWxpNRvjRSybmBcq8ozwf95aXHUylLkrWsASkaPP7Bq9RLFqnVUjBdp2bnQkjPiCbXBtUz1WdSgTCnarhCq+2tfLwqqe1hm8WpDlbQyK81jU1NSi8exaDHhRAVNu1nEfGCpVHTqCLwi6rWJtZ77m9SDHfKoIxE67I67g6yiXvrUXESwAfhX5ZG9ZBlAGrQ1GVk7vorKvufvWRsp8zXYqMjpY3OkINrd+uAiRqAofrkput70bNZl9YCvJt2HF1ytMQZXDkmh090LN81IUzJnZnoUR9D85gk1FnBPZwa542ix1q5JeY0BI2wvZG19f2tbA+5qcpv0KXCKa+NY4G4Bu5di8j63tzJF9mkIUWJrOUefcChqFYVGb/RQUcjLAakAirTGUfGupppvOLpVo6NWDIgIGPHkk5Qd9AMZ8NsSTMesk2EqcRe6kyipmaKOOfs1TDEJPt1bQV87SPctm84mL5QMgK0KywYhnpiGyr+E9cuYVXKL0qQxIWiC/KJMzS+HMo/RzY29x9TrKWKPF5zNMalp7WUD+toVsw3wj55iGd461LKQ7p1aMhr5WAYLyetO00W7pDm59XzKijHqFlQObP69RTnadAXOUDzfoF2xgQ8aVxzFHKMgWjRw868dygZFmrp/EQzRju0M5k23VmnBd4PYlCkB3JhvqfmWgDiX/thBc7/5dMvKLR5uzuj59YtRMSVJYPWFvmf+q6iu5dGVtFV+WbXIuNP+gXVzoqDFE2p4sOBc7KiP8tjD8FqQv87DK56gfUfu3ZM/aD74dc1x/wwHxa4zjKmRyn+oRmaLRLR+oF1bxbVSR2RoIDZiuVcvRTBX2LoXTaYhGTXG79m3pDZmU7bTElhzoWOpK+gKAzYUEYcykr86E82IqYRFUWIaFyY4lAiNBGdEtbUZKmiD60ZyvdN4C585Kd7X9Oo2Gtzb1rZNGSL8INKvB539igKquAkT3rEYeH+t7ThsZQV/eScYrYDte8aqzHxX6k88Kx5A2aHQnS+QP6Em3JXkj0I2HyyPKZ/MuuGqN3l8W3p5dN9L2XTe6S2MyLdw90mY9XSOA4ypkww/miTdYjbuaWvQnzfi1b3FxGjVZknfJGSTRp8bxVNo+IfLbEUxGES34mLXYyVDEJN4nHXO/JY2Y8ETMutFFkxnkiis9KvjzUwpAEq75Q8+WqtVNAdh4ah5B4stS02Eupf98/X4+iFbzEgoz4iBbKCAbBNE+xhHrGgNCYcm9wtM6itrmpnzYwUDN5Qlak5i5CvNk/ry0nad769JAwnn9s6HHSq/6Y6H8VcWd8xaw1sd/YTka9JbGRAzVb3KoXKNnimH3vJeG0rkgy85QG0aMvO+Tdm+GJoXZpHlLWbtxieRp3Tg4qvCX6aDRmyn0zqjikk0KtFDD+NqrehYrTin9Xw/8g+Yzd8ISRHhlBmKTT21HtHl9r+rXwy5j4PNWC2l2Yj9JhDW1sa0GCXy5O37GRjqQ9xxO6zdO0dhckD7zTu+CPsIauf3BcQ+wF09tdnB40Q4wZFQ6xU8ocaKbz9GW8wqVLfTK3uHSN7Z6xqTAg35F+Rjvu12lJI8Jd9qa+NOXKKNMR+4pY7peUwfabLrD9gMdH1y/K2aMjGM6U00jZ7Ax9zOXsoWV/h/Bgt6raiVu/3/q3iqm7p3lVmbOhuFkVytxbX9QtrYmv5rcytP4YHehEll045n39i+ONGyv4qM6XYAzVZ3QkPG4EjOMZvnkvcQ5QC2JrncWOvh0pLFDaJAqHvVowvMMoDDKrFNmn0URuu4HPryYZa3DKT3N96N0SlrRFnWt2/C2WJV4lzfxuvdNTUd5JtHZ4iAnvbuaSIP3AamQi7+0YqAI3Sf7PKXDMYdaCw4L+GAMMxG+U+WO4G+gMjZmBHft1UBfIBMW4n0WWS2c2STQG7oDN+dKimirTDyoVdSoOqiL82M5YYj+okTiogdypAT7P2BvhB5Xhn337xjZRpm8ioSWGgVvDERPTqohdugoHY9MYkcdsuepLsKCRsgmUIi+SuyETP9LTk8MXaB1uC260oGmrUXCTBzlBTkD8njQ6rpoKTS5ogJcNjVpcj3SyE1lvvYDfeoQEOW4vaqWf/nFNEfO/XocibH6v2fFYbp2U/RANe4HHDxL8Enuje/gnn8mXRvbQwKa+VDgvLAvdDJreRDC1ZlFz1e6zLk24xROhcoPdjdMsiz5h9JWUZMEOBrBZkwfuLfcpHARTtPqlJFrkDJPRvRzg7qliQHXVK3ctX2qja7ww7tB2kL5cc7cQMPm96glkM49lGvepMZ5zlyDRkCR8sTpWdVk9HVayxH2e00NuLO4xhyvpK9pergyhS6ByVxm9x0UONbzT1e7g4KdKB9zVTD3WfOJHykQrjXgjOdGpnOjRLPbVli+DltzxV8w6VGAswlaQ5CKUupKUb/ThJPIdxkEyZwLBWC7DUVQabkTeSJ1pRYbgfUVD/uzQZmyjNv18sMKv7lOUsCEg9FSeDlToCMqz7bhbsra6ZlQQSYjnfuz/9ez4qEXeiKUzCTd1mLrcLXWIYSfoHCT6NZlYMjbfBFFM8h6n03hIiBLpgGTZ/YyaBcIh8Umq4YwhvaHkVHO+DFyUG/wAhQdtDLHpqYPRELVs5pQ42ac+ZBl9cMZ1ksJPscgIkt6rB1o5xPSRCMisXA+GymsMkEDpxilzIHvE3d1cLb27nxB3JiiLO2MEKDAvb2GsKG9vvL4VV/nCfRUXDo1KC2LFmY4SgLaunqBznXqxHsDNS7lxvGxnEVGt/CDJr+JIyY2FfjY4oKz1EMZxen8CXF/Wz5UoKRiq6OMJnA1xOebmwD0edP2Mz48aklfLdVERtzdEE1zW0Jvqhgxdva059OjY2lIQ0724LEgVwgyHEpmyygYiZhOygY+wfGejAC7fd2jGOHk4CfJRsR3HYVV2hsMLPMDTONRQZWBkSXu1IyA12XSMqmYQk4F+4CqfDSbROOcN7YF8h0ERMCKHEsDT4CWLceSVEKlD1sQpSYyqNELs+q/RisyV83xeCBaaGYFqnjAKuX5GoFFLs7XKwKShp86xBdnyFothULnxB7ZZEVeIU2clR7At4Ko1PI4OghYOGHfqay5yUFWEbblIYqiLHpKyFeQJe6pjpB5yzhoJVjVbcdWk0u5cFGCOf0D/bJqFIW2hWxLsx3AOFZfxlEzDI3BYbIn07po1HjeysGL2XqpIpj2nylzqWkU8rcki5pHZOfSrrM15xK5I4+wDLiGC1ZStjKAtRAgrKUMpknOoyFzaWLrcC9DSeQSytO359LTs7pzXpOWKLbtJy3ZQ6X0rcdL4H3GLW4OtKxe5Xksn8La6M2v6DuNmsMFoo4fDj0lDjj/9Q3DG4rmQv9coiUVYllMghvKdj0iEuXjX4xEYhqTSeSoSoyqGnYWkJ6xnQiv9UszxDaTPkor1lZAXNIWWnlPIx6jrarGRkknGSIR+oc+Wni1FWryLBQLS8T6cZJqCU1Bao3xm+cZ5i26r0+q0u51VftsfJBHhoYumHkqI9dCMKo/aOMzTh+aXz4zg9u4SEUKVnXtO3bbfKhG6Fe749SQMEQMl2aARtUxVUTCL3hZ+OtEUqnXNRfXXKI5Jq6wX8fvXQp4UIwWjUtJS8kiW5FdRc0CKiEeamOVqqcKNAJi2DJKF+Klzo9Ze9csCvTbXxEq0aIr4+heRCcNzZGa7GsmXPqx9euAL4iixMorB+dllQwN8i+hUIkC/LbY4X/D9ZPE6PC/lu/T2IhkRJ6YhC+12Gv6Doi4aUPdnmv4hKgjIOtnmPOmpwhAywJqArAV5j8eQqzle7jnAKAVZmmDgZyBdZrRlspqaOUkF98crIQvIeS7XC32aF8/RBOLimduum+fzm28cQa/82Cl6RhZgPfeaK57DrhYlU3iUUZ0NV6uiHqb2CaRzoHUOidxEPeV8Z5p90pEutA5kjTwcvo8m+TSIASV0q+50X7Ta8F8HVbYBffO5OHvFNLYZ7UTq84lIpSrzWcjqyO1n2/Mjt6mzHn5hEgCb/qgYbsqppfHQdxpZ8V3NU8Ol4qfIFcGPF0QAx1PaN3mdAYC37F6LeI9wr/3KMu7VhYm2GQHbElA6mxfkNfMw8jp/aglyQii63P2S+qmL56qMEN/X6URSj7pd0PeoBXBganmsxHARJDsSSUbNAkxHnt3yGaL2wjRnoVfciwzaC+jQ4idp+mND0/+ohadK0dp9lI+chtIS7Le6+HCY3TYc11FG8INmS+nQk30tOHn2yupnOAacyJ9MwolJGxc6yvgY586dUqX5xc6z7dD2ucnJY7t77OldyuaQx0QqevBxajxJ83SQxloHJ/gRFgaJ4neSg5kmXYgD31mMTLSLd9/bPB8Ly0TNPY9bNYkglZjHyPESvg0yYdKqbANKNpYC92ugTWXiMl2teTViPQWF/eQWHZXgtHv85Uuab5hLEJElwIeDGq9fu0uHIb8Ag89wZAN2A2LlGvQYTdLkDvgsekcFvD1AnvU9BQ6BvX6x2V3hNIeRU/k8tjA5je1KcyuBCPjhD/jhR6U6IZXFGWBFppb9cXRxZNBF3v2EGP2+hlmcTsL6SCE7RURG1gc89bO4akt3aUB3qYVF+y38RJMj2PZqIi3wGvVoG43u4PQ1nP8gAR0bjrGDA76D6Vu+sYMD8VYYazs44KG8LDu4gB3bSjFcW+x1aFhNR0QLT97JcXEnD/lOjo2dnPKdLB9lFt7JKX2aWWgnx3wnx3wnj7zUvpNzjxV5I04qnrKTp7YbfkHclLretGKv554dUv08f6/H+l4XG+CvaSQcR/RoEHaTiu2ljho+zXgobF+1bC2zTi8S7aYXTsPino8Kx4MZhKiRhueI/HGlyB/xnWeUd9ttl9l0RCVZ7Am/oQX/LgrY2VU/Jkb8BS4p8mMvh7bZO6o7W4SbkBPGWBbmGAQMoCXu7RxGEC7+qBCKEuNCFgPYFxB5S7q29YkkI4hB5B0+1IZKs848FiFSztFMMUvRg9cD9RRLpgTQBHqxhisW2WNrbv/wAUGzjtvje8iiIHmrmgpNE8VYSFyvXlTBPJfPkTdXTaAup4jcWbclq0hwgHeZwyL1zW2ZmamC1C23IhFJ5m5EduTPwyxnbD3LEhfalBc6l9X1HO1NE26cLj+dklgkBWKRMdeBucNCrGzSQFLk0cvfzMoaVXh+m0og0a554GqXkmqGs4rnz2w8P0tYxC9hRtgCfglzWTaxXcLId3DpVdi1aCgBk0HuzViKcIVcC6ESdjFf9GLt4A0l1PrqxWrBA/aTcinm8lJUPksErTkftZcrLYWhDRpWuxCc3wZHn8GoFVRWGZwf11Iq0ZTY/Jk7K2junn2ZMHV5jveLpjXXr9VIC3hoSNe5x0IJivNpUf2F0tauoMp2KxXgvI26KTGrynALQ4t1WTGp4LIEkVrPemI6NZNjf45WPpjkdeZsyFW6c3YEBZ6JBxa+kbSojHyeDBiacwi2gXIIItvd1sBUkCENO5FttUVQJxnwx+uuieMM68bUzHUQXGIciRLzGSRYQBdDJjctPclhXN9Fg0lKULRY4aid3Gi+vUpXobeCM3OmfjHD7BgDhW3nk8khoamZZ6wN0X6wuYoC4dYK3+HauGMQB/RxAzXCcWvBj4iSNdjyO2tt/cWmmBMG2As5280vJvPR6bRd7TjRtQ2aXeClEzRCEI525J1Kr85nFfNzthKMik0e3HZH4eAPNa6DfA3Fu9HZXmr3lkL0uWJ+OZ2XyHQv/3650/xb0Pyz3Xx5/V/Nq+d/WaZZMsXrcEXDggxZYAzpl06PGcldWHmZ6XhDa3XDr1baiBkZe+21T42kJ6K6mdU3LEruFoKsz0L5O4k1MXA4/4mEmSIS5ZBG05k0rdlmWaVpYxj2VL98EswwfX4+K8vfyy2/gTjQUweXPwppXkr8z5qxN2IBJPPNT9G2chjyf++0vUyEX+dWnT0lsGW4lV2Orp49azRGm0Gfu3zH3tBP+9jNiHYzwm7CTRCL4q0pcQscNuppc+g+r4fNqbtcj5tTGaIsbKTkkDwc7q3pEuKHSPIGwXAIhyqQIq+Mf4UR4WCGBtOYvGvSzIZJlGej4N42Hc0OD52nhgGiEeLXV2WI+KmfNwIPU7BMN0fbQz382dTtRdRMHq5mDMOOrNPU90ckRUnk9vDnxgpUi+iPq6QAIdGfg9SMGw0vwTBhGMtvpQvfm/4G+fLNH25upigwsk4iDDC4sT3aBJzW1tA4/7KzduVvPIcF4j/W11cb0A8qmZe44f/UzzA86jcaCIM6/ndoaDPs53d/Sj3FI9iDfL7Y/UVDXnoY8WbEzPBC3EgY6REDJ8M/3SuMA3O5cgWzGmIc8pEPjY82N9osPlp+OWquXP2O/2zQfzqr7N/1Kw/+vfJTwO9bSkKykl5ogLUubwEDAa99w/C/3RduI25gnUZnrbMBwmB39WWjnj1Lvv3f7FmAmrYANW+AGYx5pf0tw0p4P4Iknj5b7b5cfbn+ovtyjXWDXcDVU9nPxtrLFy/WVl6uQD+/J78/vhNsf3O9spPuarv9Evppb9DBwFi+JU8Yz3pbnXlrVysrL9dW11++2Og+fjyYN5lsgEakfIY17FyRDdHI9M/dK7JBGon+eeWKbJhGoH9evSIbqBErnylVOHu701ECZHZerHTXNlY7L1e81XZ3pbuystp5AUzTendlY6XT7nrdFwCysvFiw1vpbqytwPJ1YdNGLCC2iEgYiAB5PArgBogiw/SrZhapkJHMgwPoYWxeKcGLU4NCFLOBXKOWjmh2GmBa0azhr6/OSO7nerKVNV+qqn4lQB/wF4qxK2xObAaTFmNcY1yUK/xrtQnnPHq2QuNqc7GNcwPp3Xiahydnv6pvak+dMsy+hyHE8Yxf4gmHv4AUeFNvSBAd2mbQK05dToKPd0j7Q9vkRfh5SsjsWn8Ko84wy9AQ/npCP92V9dXVBftJtH6A8GilAZa2H4VCiAOFP0Mk8ZgSa6Pzstt3jT3F8ckQbngJtLvbWX2xugGYbwAG64BBh6IwpChgJg9C4+FYWMaVYDsBnMzfYTCwcAGcRvyxgz92yY9IqOHU4Y8r+OMq+REIdgpXUB3OOVAgl3irIqpsFjDK60qXIBJfAlXBDT2lu5DEYdc/dtYtHzfMbzwcPNyA0Oe61p8664+Z8S6Z8RnNGXnLI43SRhn+tw2f5LNnmt0YOnG1eKNKant+qm5n84wUeaC3zfZ2uxc2SJhoJCEZCRmtZpVMpApbt3XWtcuGHXRy1aJqLpIrgzgV+36uScWKmSSG5tjKSbgqTM7G4/RH5DdKfyJXixICld+ESUXyZ7sldyH7s4F2TvMMqLgrRo2RFjbDasSpv0o8AJMOHDAUYYBqm/3mVwsgsMizfhS2zi52d/fPzvAUha2j4/Prg6OD84Oddwd/29/D+Kvw9eDoPfy+d71z+ubicP/o3G92OfDZxcnJ8ek5gq7gt7399we7+9dY9Pr44gg+r+Ln9/unZwfHR9eHB2eHO+e7b/3mmgL96uLso99cxy/nB4f7xxfQwwvSMVMl+80N2uH14fHp/vXezvmO33yJn/Y/vN25OCP9d8gI9o4vXr3bv97BQcE3gv/F0c7F+dvjUzYkgvzp+S7B8nR/Zw867xDsXx+803DvEOTPzt5xNDoE7dPXMBlnx6/Pxed18fntzume+EwG8eri9ev90+vz4+NrGPy7d/CdjGbv6EwAvuT9XBz9er27f4pT3Kao7x4fvT54c3GKqHc7bBrOT8mgr3d3rnff7u/+6vOC/Q8nB6c75zjXtICt1PXb47Pzo53DffaZDOzd/pud3Y/+Rv9zMKl9IQQlCskvpxN/gGFqanDAw2SY1R6irxivKZ9MBzmcA/crCHBAJ1qtVjC5naLQJmxqsiMQAP56hkecfGASJZojlhgWwoa+h12e3qMQQxRJqIkIE+jASZMprzDhFRwvZyoTOGB9OLUtal6IWXypWgSVMeqjMHuNVe10SYhjKkTOmAWEhFJe/hBub8If7WwvzcJER4T4vX7A8ChMBv6iH5TvfWimcTUNmw3lOWFBJJ5ssiH6VxWUodpvWY82PcBCnaGLxU2keXRoKjAcN9sQ9DHkNQBjzIdw0s9aaUK03zLIBUi6UT1p5QG+OVHVuDvzEBA70uDyusGEimrMtZpUxIexnYwAvJre3JD5gA3Ifdwo6sbWE8gzDaw0Fvxw+A6XlvnZosvuOEzq6BzteCF5sYZPMIeTaBgeRnc0TpOD4c+Wx3EQJX3M1jvJwtz/0pxm4aQ5DOEOIY9uUDEhr3gYxz2kSX19mhsvIaN4IKbPPj7kYEIu+GUKonK3jRk5xK8r7dVt/ts2TcRD1M51uqnIhJKHIwriuj0N6IJYMNNAA3djEnmV1JNRe7g1LczftoNRkGEzqRoNxDUbAzkKz2HUrovaTugNCFXdcaR5cbmP4Xx3QW6qO5t5f9I9dTrpf+GvLWdEX7affK7/mbmEYO6ZBPOvOsFkh5NSTUZLaLStP0IjJAFVKvAoAMUdQfRTbCeldHPwAMWTaYLJ0a4Nx2R8ZUMbDWKm0cjxB8eB/5PwOGHO2n1LDgw6uQEDl+RN3FcOGuClT91uqXW74W4jIQvkhtvyV0R4RLZrtmhq8dTcllO2HadkH2LUIuCTO9++wb9d2JdMioDB/xUuBGzrbgxiSww7SOUC8AUxmOajdBL9ie/D1Hy6jlnnaff4XouzRdRUq9AwtqCzB4yGsm1b45EsSPUaVKnVRSgR2lZPqFRLXujjwus50EP9vZ20Y8CpWCgWshwVOSjVukB92CtJxilfhfhdUnzpVUrl0/skHY+phyZFioRsFTFERrZxqXglGIRBO+Esp5r+VeR83kKVYlI3Sqm4MgLBB4Nbox0WbVbbTYFRC4QksmvpjUFfZhaa7HSas/kmSzQjJ4vmnKHK2+AT0BZx0jHJHfmCObu9A5N4/Gf0Fevcc0bhmBxyVfMreAgSZx7jJwQTEpvPd0iOjE/kHnIoXYB2MgLs5zzw4SmwVOkdzbKmXKuMDRtMHsZ52irCgciA1O49w3ciMP6HSe0UWicdcIMhUIYs8yctZLsPjkDuuGbCBYO5CwY7Q+D0CNDhzu7O3t5pESoaS6CDEztMNv0EF8lhkP0BQGcXr472zw93zn41oCawcOEEEQKpA7h0vZT5AwGnDhC7F6enIPwg225iQwOnEmQou25AjCfRHawPbefk9OBw5/RjsZ0shDkcCrizfWhrzwqZ5OMzkkcPwI7OT872T98XcEdafAKLhDHoAOwCgE52zs5+Owb5RIckEcIU0J29w4OjElg08jyBfQtgeBSQt7NAZArImQUmYw6ih8B20pFenB6cfzw83ts3IJn/JIaQAMC9/dc7F+/OT3beFOAYY0lyiADgwdnuMczJDsqCOuT9/f1vaIkwTG9phslJ6zf4H0qle8dv9vbf7Xw0dwHjkuEaxW0AItyrnd1fL07flcAdksCCCujhPtw7eyXQ+xgDEHMcS/h9EPrgdLwpqXEeAtuEFEzWON8/PHm3c75fUmNXRn9TKu2CTAkbGmT9s5J66N8Ilfg88YpMQ1A1V2eDUYgReJVaZyB57l28K8PxMErMfmAbVvVxGHwp1Nj5YKsxTsNdepTx/B3vs6NsQH1Ww00zly4a6IeUS5K1d/zbEc95Kb/ufzg4Oz/zO+b3dwdHv4Lw3i183zm6Pv7VXzG/w2bE76vmd4Ysvs6RkiJ19L8IVc3Z+SlsIApYoJAlcEUiWQKo08oSoCK5LEVPp5klYEWyWTYMC90sAS3QzhI4G/EsAbUSzxJYk4IqYBcHR+cS6GwulEZCgTndfw2bZo9vUq2UaX06lqLDgw9yp2ol5Jd9vlltBFvsSwuRLhm/RqVfAxna5whrJeenF/scXRthFz2X0XHrjFnoeNlO1sn4yfHZOcfTKAIZnSNqVro45/NqvxXEIAqXwOvj00OzP1GIocf8TkXh9c7p6c5Hs28Bsnv2ni9qoezj8e758fXOyQGnRfYOji4O/bUSgP3D46PdwzN/vaR852+4q16UlB4cvX538WHvlb9RAnD4n+fn/st56F//9W84SWVTeHJ6/sbvdObgcP2+63e6pUD2NRTX8vHr1+YSyrLCApq3eaFdy809Z+/aruzKY2He1vPOhnFVV7Zt3tJW4OI1bQW7JpIImm353A2bxk0i4fJ28pxLIyyVMU1b7AhZxOlpbylSRsm9Dsmx60iRxIBVZBUBLCQTA1ZKLAJUCigGrCK5CGAqp5jIUuFFAElxxQBU5BgFUyq1FBBlwowAlMKLAapINXJQigxjDksVb0QFIcoY0FLEEaCqRGNAa8KOqKAJNkYNXegRVbh8Y0ALsUcDzEogMx1UlXaKcyIFIVFBEXoMeFUckuCK7GPCq2KRqGCKQEalgoQkN5iUhMwdpshIBXAqEJXUYNJSoRKXi0qqCbGpUJGLRyUVhfRUqKhISSV1VTmqUF0Vlkrqa/JUoQEuM5VUFiJVcX6Z6FQ2w1yyKlZkElRZRS5gSVogBCmTFkgJC4D5CzZRAbWK1Jgp6GlwH0Zw61S9FfYNVGDU+yLu8iZ7UCcKR92yWDP/R7V/XQG1xrdcUhtjz+DbFtVUrx76xu3gheoY5EWw0CDMCD/fg2xRCJTYSrR0dMVd9NNMeUFClYMQyOpjkHfkTzOIovgsRyHR1YdBb/CfZ+trgr2y7wmaOuqSp/hp0C+qHOQQJLrmYaD8zk90FnR1iHoUKKpyAJk6gGIUOGa9FWruGvh+SQix5AB1iizZup9mToq6HzkrEl19XpRhPHpmFJZXnxuVh/15CI9F4aWQHgVlfYa0wTx6jjROX58lwbv/NFNUUPTJ+RHI6pMjx/DomZEijT4tqpDy08yMTbUpJ0dFWZ8fbTDmFAk3rS+ttztnb69fXby+Pjv4274WEv5Lwa7Qc3iLJIVSnCa3tZ7TCL0iKMZ2mLcOmryIUSyVtdDEv59mMazKY7kaGtL6cujj+TnXQxfHjQXhEvZPsxamcl4uA0dVXwExgEfTC6Fz0MmF0CT8VFNyVj4nmX1SsqfPSmaZFlVl8jNdwYUHEe0KFigXrmA5mKdcwVKxpM+Soij6aSbJ8jAk50hBWJ8idSSPniFVk2ZMkKIZ+3lmyPK6pUyRgrIxR+pgHj9Jqv5QnyVTFfjTzFTZU5+cLRN1fcYKA3v0rBWUqPrMKQrRn0c+Lj55KgKyRFifKnUkj54lVWNsnyCq//3p5kh/nS1OE0XbPlNsSE+eLKYvt88XV3z/dDNmvoYW54yjbp81MbAnz5t4MrDPHNf8/3QzZ773FmeOo26fOTGwJ8+ceDOxz5zy7vHTTZ7lLbw4f8oA7FOojvDJs6g+IMmJ5KUYYSRRM/dwfz8/bDggVuWPaDyyrZL6uvTTLZPNAKG4TuoQ7AulDfLJK6W91dn3PH9u++lm0rTMKM4iR90+g2JgT5498VBZcqOz98af7043jFQstzpDveRe5wN7+s3OX2pLZo49uP58M2dY7FhmjqFeMnN8YE+fOf5UbTxWiHfnn+exomC4pDxWCHRxntBhJBrUXkfJkJkuWebnH61rBJDu38LMybNk85nUv+BnqIQ5pNJCDZbMp9jzQUL8vr7k1hvKREKFlq3nGOKD4xMxfIgDSBk+6AcHldiCcjf596ohdlGZSdMIbdPlgpZpCDOtEolkRoJJLrV5iNK5kCKsqNUQHKjpEhubslGi7DiJ0WnYJUvA9bSf0dkwC4ekKy9fIhlv1f0dJZ/TP3RM6rg0IjqjDSBU4g/acGQJgc2QjDZQnvOJRWWUIQI0Ty4tNqPWTI+cQ5rvl8bBJ6YeJWj3jXCA0yzce7t7Yrgsq5ki1YdNB2F7JLjqstNg9IJE5Zqgcx3OGykRTBFrPphi+M8FW1fqnpHDcbAwemfnO+cHu49BcGwXc7S4zcx5te4gcCv/km+P0iz3SbYbY614rmFBGXMamU2sQNkYDIFVKbVJ6NrrajiJQNYa7BaYipLUnzYGxAmJKziZuEbJxLkkyAjftYzG+8YEmInpDctQTybopnl31ECqXzjpdpWwG301Z5To5haTyH3J3waT4X0wCQ+GhY5C7hcuF5USK/yrN2lZCa7sBc+UIM2TrDDsLxwNUqrgISiq6Dgs7bgeWjtRSLqI27J4d4uMk1h+zfrvC5402ifuRqN95D40+kfmQKN95N4z2kdpRw2fF/CbAaj5TjMAtIDHDOJR7S4DEAv4yhCU5jjKAMwCXjKI9yIuMgA33z8GgBZyjgG4xTxjAHCOWwyDOKsGKXOIMYu4N4z5nbnCmJ+5H4z5Xdthi3jAIJjF/cX8TH1fzK9abwt6veA2W8DlRQHT/F2K34mziwUcPV2KnzWUS3xcbCXUwaWshHu32MqJa4utQPFrKW2XOLXYSoVHi62QubPYiqQvi62UOrJUIsu9WGxAzIWlql/qv2KHsKyM7rliLdCXxeKzopQu4rCigC/graJAz3VVUXdjtZ+KClntpIK0dp6HCvGV32fO/bqDvBr8F4QD7hcd/RlyP6HrwWSA0UjJTYx7skVsqIm/v6yatxLJ4JDqeQv/UdrIW/D3jNhlYXBjM6U5fCOFWMssxG+kEFowy7DRmfcqf1IoAAyJkxHB25+QsBpA3C4KDrk3kzA8GwcD9CJ+fbq/f3ays7tf5bSLcX8yxWX3Gv1H2HwWe7H6ExX6met1RDpdxOdIDtownldmQ1jai7GbsGJOHmdnL/v4aRQlxRWRihKJrm6uK4b/84zC3DDKIDiyhrKH7JiFVD10by2u6OHwRTUPKfkOJQ9reWEVD4f/+RU8lGj8zOodguEiyh26sf5HVTsY9WY3vbsLEtsDOKWBrX9kabIdoC7Ds+o8BOVC4VOm4bYceFiJLZYJBX/Gs6dpHSQyDgaFclwPIzQvASu0Imv5K+2e/CWiYm+Qp5GMSYsYIzLXf4QPeBzQutd15S3DEb5JJ3cBkCnxTurJbV2KGa2E2aH80g4ncJpcstXSPxzNblNZXRmniDbJIhQ5ngWGh6NSyZlCaOMok5oAOPOXNN5xPy8dxTCaPLuh+qnIMg4SlghWVkTQZ6GDafTX9KYWuVlrPM1GLFZcvUTJlbiu2HSZyEqPKbELGJvmryxVW/37xxBxg9q2GWxOCaZk3driNpuO6e92fdm1UiyI5136OVRGaFUc6sMJ46rh4NbK+daKFt1aUxG/j2JEZv8pW2xAA80R5lKOSouqj2FyZUjyyJcZD0d+cX+QhjDItUur6hpVlZR4+ebqQk1FLovtn/n1qNFdW3OXu2vrW1ttlrNKCQ25+pykY8UkCVnfjf2oGTwHWC/egr8xmYEP/2Lc67LeGLj7uxL4HcMa5vXLFMNCX3mrzwNXfGLBo8nXRkf9TiNN04KuWkDjUtOCFUQWKvbnzEICs4BDU7EaEaUsvW3+N6hkDeaoXCGrD7lcHUu5nyplLOcBi80/ShFrdDR/bEwJ+yqfLxARoDniEBFxP3EZ8CsbDGBa+0zPGsahFKLjpdNpdeD/7W5n1fGcF+Tfq5lS69M0iofyxlfveqVBuMLVSiBrhq+wYkWNjlZjSHLqnA2AQU9+i4b5SNbMyMfWPX59zuLhUfCT6EsYn6JgUdbU2zC6HeWFtkbk8yKNRdnJKE3C48k50lilpUmL9rB3crD1EqgJTUoTfKlPWoWxePo3ipS7rDSx2emqvQ6CMXQSnoG0f5LG0eBB7fdaCEMGEG8hs7aA12B5XT/UphDGuguf/3iFD0DZxZht1sMwmVpQ2asAV5GqbFbFr6pBHVOY8ZMUSH52Ek7eTILxCHOchrbpOrRCquiVtIWxIbdISpt5jfnhFvIfJehhMiDg9G/DyUI4GuBliJqtUmybnVJ0jQpWnBHmNBykkyHWOAuTjIQYt+FrAzVwtbZWMqs22CKKbHcbhKKwvUm55VTQegQDHQG1nh/aujQJSqEuBbB0ymqW90oB7N0CiajoE0otHWKd8t6g1N4VCSdc3hcWWzojtWwkhoRA1Y7sLcaRD+LXcKRfB3dRrBE3+bWkypmmFaUV8JsFHD/vppjMoQi+rBPcjBNiK4HX2p5G8OV1wKLuC2D4eEM+lgH/FmTHLGpzYq0oSstaONAaoBzPBA0DdtP0Dzj6pC0K+mv4UOB1QNAiysjXIMfgPtxql3XEuyGqhYW6oilziT6kODDGKGqdC/4IlQU9y/TxCNdv1Pkmsln47FkOmwoEVBS+pwkPb709QbbaiqCXy9QprreyvtZ2exXQTgJXvkPh1Dk6nSYJNHGc7CTDSRoN1WWMMvZRrfAbYTBeBYM/bon9xG4aK7vG+bebNv7nWKoAAQwVyM74Sw3Y92hY+7eNNv5nqXMSDJkbAkOqW4Q5SOBk0MYNXGr/ttPG/5yySuWD2MH/nMrObCNxGpOWHatiUzQUejkO7faL7iBwyioa4PejKA9LgSvmfk435uXQbZdBFinZxnOFOK1X1VuUaN5Ns5xk0nydTqgaViPrA61Iu7KLFfEeWfILtejFon/zQ2B3wyHM8JBm9ZEY0a8aFvST2jsDoncJ/WXJZz2xZkPvj9bZKL0/Cz5jGk6YHxIVQPSFxuRkyd9GGRzpB1VuI3qOEYgm2auHA6j4pe4KrRdNZCbimEc8a1CGCc2u+uz1CH9uoSTLXpFIT04P9cA0Z0TWwvee6NM0D0HkIRrpwL9uoRqf0aDE7QdcuX2bt3aGdEOfpxzhgCuLE/frDP7HBoaph+glRUkyTdfUX7pD2EOYnaDu1IHjahJhf4pyPibgDhXq13CG48h13BapE2Z9F1Zsc7PDiDSwWpgIiiX8jZr5VqfPJyFq5FDan9NZVtHZduRnvdzP+DNZ9LyuUM7tEnms19FXljIWJ8EkuMvKlpakjVVWlmQzUVfTS/h6Rmwdz0keEafnkCVzoIK6kGyrM6aGgPrvWrvq760bucJGkVfcE67b/zQJgz/o6yLJ7VDZtYWtkp3Ab/beMfH4vL6R5Dymb0VqFB29JurtzIoEK5uLx6nYR5XYSPaWshQHSV6f1zTh6BdplbL+yeItU5q/SNOMv1+45ddpPMQojAvsRwpqITysQUlB8ABdHHzn2TFPznt8fRsE8d4kuP1bmt5V4PwhbH02oPeJ+npowR4oycV4jGazWYgZ2Rw0vnK0SRKaAkVDUDllVTqIx6KgT6t+Zf7gKdbv2DmbQr+PnzSv0W2STqgOr7ozBbBqa+tdutYJPAzv4O67yILbHz17ds2O0wOxxT42nuW+6rD2Jy17u37ifc5bqs6FfM78ZKbMcIli5HuRSrhSpaR9QG4/bOmaFj9xDczKtEU/dspMVRRH7R35JpBTcaO8AZoQcDOQ758woR8xmwaEvrTOwnyvUAJ8WSsfoRzOZk7fyT9s415k4cXZq+oTOCUwTzvmhO3E4KqtAs+c6YD0ohGQGg+mg14ccChx0RgAhC7JXm10U6+hUAZeq0gsjE6y8H00yadB/Hb6ae4EStCnzSNmEXV6Hwhm8DMxcckKRA5loN3T3XMW4gT27YSY7ZEPS4b6RBT0lZ/xDZ0aXeAewqeeHA0BWAbmtXUqs4R+JMozKMo2N/oZFACn/6yzvfJyY6P7sruysfp7iFlwe+RvtRdM4RzOipjwccDvK12egZUiMWnxgQEyzY5HuxXp6rH3yMek0Bu/55f16HctM33mkuTQ3DwAipsdF2DbilzINDXMA0hmFgQaEvaJO8t5BIeLOMqQn9xG9Ly7+ny9jf/vhCs0iXXiOyFaowE1pqLKxfkul1b6w3RAMme2BqQzdAP3SaqsvtNI4O9xALzhsir+c6zEcccaMPgh0K5heHF6gAmu0wS9IY3G3VY2joFSQNuSICQwa8mmSFubcAE08DG1LpXJAjJzMGtt3Io1p+8GftDKYAOy1MBEGxe0UCr+cnxTz13lkV4FzEVicfaDq+W5ZYP8cPjuv6epmqKvhg+44xhN/pxfHM95FozTDEYhvv7i/AJfsRZ85e28CXNoinpoTakxoBBj/75Jv2/9n1ptk5I8agHlO39vSBK3TQ9ezyGm+Y7b+LuzzKvIA1yoKYtKG8Dju/V//t4PG/4H3EAf7hCcWNy4Hnz8O8AsMyD+OyWdWEvPQ3yLKyzpqJqCGHfUL7Uar8wx/aVh1LnMr1QhmmD5d6HOZeiI/jlCCkVkX2lfdiaFdV6D3sv4mCIOWqM27sJs1QYzp9ky7qAUYQOuqvniFa+1amEB7K2RBSjON9kW9GbUuqU6AL0rTZMgeilgjAK8VlF5bymvhRK6rZaU3MvrSinc1gJI3VUTTAVRraIgIKa4WqxNhG9br6Sgql8qW9uq0pKKZdQXDD8x/kTrQJeparSnGumqKHIBnZlMUUh7HcTAHBTRVYQmrSldnqpAWkeRIH2g9WCK5MrUVMjgcxG3idtq09XydUXzdFR8DH9H8kZvBPh9Nut/0h5ofOdjCj++jzKg69Gf5DJZ/S38JGAcqCDUin4SfI5uA/jcwgCkO7d4Cefpu/Ses3TirnQCWsVxQYqCNsQLoP+pJXSv8F0q3H1nZxIFsVd7G8afQ5xTr5YFSdaEnqIbhyJOX7Yor0De1KA5yTx8Mt7SPlmeBH17O5RnVGv4ttrPnilvb/aW3K329nygHk6rZhCzrTgHd9rPlSlbrr9cf95pdV13udPuddisIQXyO93nSgdQMl+5eXL0pghHlXWddne1WMa0bfZCXNEX7eL3Ks3mr2E4VmqUWIC0S0BMUdeAs0rqCkylQcwSTi4XA5fa7BdFpKEA1brr8xTt0hQ4plN0HPJNVynRTlTVD8O1IEGvrLdJEX8QophwaYbsXhQgxrlpsbYXkpyn9MmXPi87zrdvXKL491XG0gJ+9OmGG3921qn1pwixu9WVDDa1BuXGwv0AxZLL4EpqCEKWpjZ4vurBn8aq63XWqeiQ+dFl+0ppqqM01eyQxrLffWwPOfBsCX6UxVc6vglOrB2rZpc0lTRYJBaiU99l0lIdmm90rlBc+j1XZajg3zk/7/6OeDYCAiPg26sbIFJ1Opubdf6t8+JlF75tuAJqpftinYCtKWDdjfUXCNfpSjtvYaOwn1iWyVyakuy1ZSvWwI50kShURaLoMgG8fPrPs/W17kb7myZPJq4+N4k5Nwmfm8QyN0lhbhLb3CTG3PS11db3SgJ7JVH3Ch2GAo/7Jrli+0zZGnT4kTr8rOHXnXa77TSwimQSYJ+6bPc2V11daSHt89m6hXTd1ADV0lzEcbYd1LPIxZ20YgyWtvswHskQ3i56ImL2aN1kSKShpqZCCkioZLBmdkHYwniS5inIP2YT/DtpQwCJRvgX1gre7WYL+I3UJoWiJv7GarF5CIdK6HEdCfadNFOEltjwzFW03UEcBpN5bcqZ5tROLy+b9qzQgQUN2XhxrQmKwXBYmDD8RponhaJV/I0vFo1/beQamuR0kVhgafmZ1SKOCUztZaR3YwWkvgQTjYhPvP9ANfnjg0YzP16ozAVa8TH/hl2W2jxNSLLxwsDHEdyUFoczVkLUuMIivu4uES07c8ol2ctXuPMR+bXQ616YDSbRmOk9uCmBrEAVvrVO73vR2tax8qoqHYZZRgJSuz1nV+R+b7UcotWsdRkyrEXciwN0T0b3um3jG/MsScIcf3MbTu34V9bMSvmYthfCTiIHQinL8e70GffEGneOUjgUFCwctpzZzHB61h1ZqO5Sw1l6fd+lJK2X4rYshimBxhPgdtJpdnH6rvgx/XQzzQawAEOtmI5QbZhTwq5nEDVRhxAr2QE/37JNPJuyHM+c+E0enqW2pxwK6d9ONkm7v/z7fy0vt0CizOup23dTP2U3SYfexP3l/1r+ixWg7TU73AFekHVzMLk6lkhFNTbHlWxnZHvJ2ycrIYM9IG6ZOgmBOsS0MAXMaHDka0aDS+2eMBGGtUEjnQ93Mq4yLEzkO/cZKnWB63X4kPAlIdRfEtAvSnk64JCu5PdIAgxLzUSviVC0VkBq8bmx1AyMPvnckNoxrY0R+4s1Y6MmQNFaKeszH1lqpWZ/wFKRWrinGJPh4GJY6o70ugjloq8bWx9LjUyvIUBLHmQ86vyMJx3P+VLHG5HDnrk6NRZ6Z4T/W9hXj0LHO2wRd1w4ydw5GkhireY0RBgu7XAD7fT+aGEeujSJH759m4QtOAbkjgGePbkNqQOUq3pLEb95oAEkFDnR1hMq+KV1IjuFvVhHV3ug6C5D6XLpqrY4WkCBGamsowXYXXbbcFxHu6R4ouHH0bI+eiJTV3U/z1vUA2r66SC5yPjjZj9imglXoe/MBqweueLmZPQwQm/IqIUubEpDRdTySszKJmK2yPKwHbKHkff5JikgQN3K62w5LhLbStiR47E0v7RkLbLCZhfud9wujJhb7ppFZgCmYDKJPgcxvyz5BNBm+QXFL8tcvyujwkWZeXr1hVaB86U0F2KRNWVeqlkah0ocf1+/bhpOb3mZLwdW6xe4VbaSIY/0LApcL5xJtauGgdn3TDvGDBNBBQ0ZRnRoQ9VVrkcFM/nRuCQN7B8pPsAQseJ/OPQHOU2ePj/bxdnp0U+r8D+HtrLsKJeuhjd+wHKcUTZ1cMCBgytNwKDO1bZ9pgABuIzxpx+De6grgmcW8vE/trD/hv9zFl2tkt0s10IFEqeDXOAel1Y4hRbMj7rvlcVTKgPhppQtlHCET6d3G58yrpfo4G297NDYHewtGljIXChCMDZJERhvBwEcqcC570czYNh2leRDvoMPurV5CxY2fpHc9i+NT/KlSq/gNn5xar+ULOUvlD23VCdcnFbVssq/SH7ehgE/sqwZUoPy+xZowlARSPvW+IXKBsWaZKcYmGr75RcqNFgxhP2jVRVM2rdvtK5kwNmzOxkJ7MEtkNH649xGo3ynsfX8w+X2dTT6y9GL+52lmUPUxDe5LXSXJyKqoDEIGn8ICYQ+TeXkXuGF5sXCv8/EG60JQT7OZl7EI4dx5eeXcACcqYiugogUxU6GHHlj4rczcKLDiKQeZh/O0ulkIC5v+kjEfqEZnztrvCbpDGPgiJsfcMp34mByJyxi6m22HrRXNh3jgOWDZqJQpPlPwWI7FA1kxSOdFVeRFMpyFYYVwpF0xODK2pGjtzclyrG199xwy9YSnSjl4Uprhz5aIUZ3w3Jc5HzqSNwNoSYNcV5Sl66MfQykDKPlUnMSfOAR2+qXTbJaNTafcLCU6VVffeFgybniYOKLAfmeW5PImTHbuiN05r9bIdxv4xDlXHMOCBwdF2+J/FZ8i54RoyyGilC6SXTJeZIA+pES37EVOm7RBJsVUp8V6ZXpR6xJHRR5RToBpN57yzEm37CWCHyP7xWbbZeEVsHQLMED8X2qfQprQW2cZoDhZ2ZH4fSVFSdd8LwAahfkG50YMaPK1MidxiZHApnTI0pm5OlNXslL6J4DBz+TDizKpAgtYuY7hwdHjpcwC9S7KGFzopgt1roEbueDAhd80eG4lg0Ad96/kYAB5ie7DTXgmYqQPMRfdU1dn6EIw9iC9rbk4hC2YKltoIhwPgL61ZArCImA/hzAVQTcRMjNOZBrBBIBy+BmVE0jLBFhSy3l374F0gyxqZNoWbDZCVeey23DHs245mbn3c7pIQiVdUnGGx1XOYZ9KoYCp1lLEy59UgpPFmgkg5K4kuNTAG4mUQh7jBklQzN1p6HRlKiEkqAagamKzN3aR8WgsA78y9n+0dnx6fuddxf7f4FZVBrBsDsq5Nvf9g72/uJ4VaMw6xztHO5bqujjMitdHB2cWypN0Wq7AIxBmQ/OD46P/oIZfozCvZ3znfOPJ4hCZpadnx68ebN/yjsyp7AwkuPfAPSwhY/r5xwqcN0+OhWKiD2pW+dugSP3K9NC2PcJrCYaoOKSprBetUEA7OiwFiS1UISZA0lh1LqjOnZ3ZjASAbA7J5Nqbgu4IGAo20LOT8fKL1gUqkWUCSMFhaim+JEVp+NiaToGbP6oxuYwnNyGlAieqXhp3yWGBfDQDp5Dz/uhME6gIWFOw2B4nMQPxccsruBYoh9SEquQjGwoDEDepcEQ2qC+5GYTJWCWJk4m6a1NT2KHIveevb54L7PXZL6g0sCVRmVNJ3fZeXqU5tGNZuNaLL3MryJYsSAZIM95iO77Nhjc/ME70T1IXwPo/YDPAIGLBoGIXaV5FusmNJqHsV6kehoblajHseEZExq9aK4pZj9aodGTXlH0pbu6UE0JOYWfb208DNtR/PFNAewdTe8+hZPWUXAkGjkUl/mcRjigtRHBOcxrhAGqjQi9+010+zbIuLKP7bjBze3uSFvZ7Gw6RnGU+I7TE4kc2WmIsfdoM/Ipi2KAvyta5okCWtdSGMEuHoTcEd4mpvFYn3gXSK3qzST872mYDB7EJ+nv7HeE1IsLCNsU+TMdO/b7mCK2lyrfCh+qJ6RTNiESC0p/5Jdx/OcuHrxYP/saooDZMKYHnp64V9NMaaK8CBf9DeHxEYs2nxyciXC4R06zQkYs5cpDqDz8r8MAzc9ELzpZQH8KIEXKdCB+r8lDh/aJDlv5eIPvFO+AoceekQMDun8n7gNSKiepUI5jtVbkBVyWY3sEtxcqB6C/V8GwUAvYcTIBl1cMfDrRfmem8+J3ovkP7w+NauzzrlGbQxuNaPTCl6fUK57hklJGJoqlJdeWPKsld0vbXGNyGeP9StQ4rJiwJJkYh3ZziK8ZixVFfxvdD4/UZwrOFLK3CxFamD1UcY8ijCIZVcaIoLZ6iWpB+JWy7Aka/sUkMoQP/Dvi7HBNARHiyCfaXuaqI7vMrogEEU3q9NXEi10PXaZms5lZk3ld9ZXqDJfNsNHpu+p3Ebw1YqYOGrzHnn1gtOQ7j0WuUnmtAvIQDFKI/YL/KuKpjTC8amn6glztV1EiqJ3Pb1LXMAj8uELhccixWgpmUjHxaLS44kLgxFQVj0OJVlIwEgqPRyPE7nCBD1OCPA4fWknBR6hSHo0PU58oe0rRmDx2V8mq2r7SdDBP2FmKemb2RlXj0WeGXzaZ09PBnlCWFSTvvztFFzEOqR474SCmIpJftVT1oYzoFTb+vrlMe6cuEjSjgO2GM060HUjWt9yBthYsYIJjrOq+UM4TsFH26Hov/Y1lXRSR1638ifuVPcVSKXhpaal2N43zCJgDRU6qYb1akOfh3TgXQVlnvOkS1sLSdlmbtSDOR+n0dqQCRBl8Rl7sgcCiNZroupLlajPjE/UGazg9PjloZoDd1NAgnIT1IYKzpprBKNC0JB1rBfVhGAMvgJoCWtpk1VGn9Dr6Alz5iqtYiJTLizxov8bJ6QGv0csPd4MKUmf9ebR7qtuoZhk1tl7CEP7uMJ2EQh0Sc3WIOXNkre4A1KoBcRqxVIDQ41nWJUltStkqbprynTwZs41ve5Tr6IAUgyl6CiIohifg76NbhVLyOCqeTwvFkm+J/agfy9hWMedbUj+/jK+o0WVCuK6L810YYrrlswV79izd9OmicXZGH7rkM27yeuqJ9qTOmQfm1+emrJ6uWjbqsvGV9ilEXlSybQbPnmWbyXbdtjvUYwXkGvnVXq2WwwxkSJhqtymWYFYFEqYBvteINm3TaQSNOjTb7KB9tePVbqaTfAQHP4vuIiDcNWK9mtXu04S8JZAzhESAMnW91PcpXsKWaAHEhtNxjDJhqGBI8PkOTGDHpa6ghsbisB3X4eytBeayfdXir6c8jLoBUd5ysyMro9q8kvTByVUpX2yhean+jdE7IHdpMy7SOIv2BQ8a2/LoMf+VmjVWE4ToM4yAiH85EPy7rO56U38kRugNWU6F/hRbH25auu27wwbrZXQ5pbt4kt4ztqBaPjKqEdzFEfamzSYhMrccidtN2+mlyDKtnF52eSvXaLMKk75722j0b7c6JRQCYx0QY+HbZsdOC8oh+InXIEA0UtUq1+LyRu8GdNUkitxX6JcYYOwd+YDWptEy2Ka/0yZhq82lq01LKWwPdcdvqSDIqond7AIvR2YcSDMGFLQ3FVoOAnvj4o1GaqNRoyECNADd+4NYuroz2wx8Nc40v6PUECNlZ67WU3kZhRQNeAf4qlC+kaAF2L6ZYCSsQJyssCQYtgWzVAaqBdK5qbonIruht28Wwfqa4kVbE27JnrmotwEia+vcs1TJGgm/nrgGR/1lTsNs63uWKkrDXBWk/jIPYwrlWaqQhg1lRrlCP7Ar9IMFFPrBVYvKJ0fhPfb/Kk4HLMm1ZQmLnyp2GNDVNmaZmilGagPtbunnhGtSCi5z7ZjZZRFOvIrKvvKm7FpA/J2fHXlhw5EoOXGEcptCBhw6x11ISauLTiwy1YylZ6Paa1N9LwpE9htUjL/Gr8mAW0cUuXqZf4u/Gkn9uJY7isFnRApADfZrgYlRj5vG20UImA9ZkwkNS75z/Pq1nuFL6U+rYnZGcazbO6PGzHX0owQm9Dx9Des4ElJGJB5dmWE98B0D8qLBn9/lkgJYTXSKBDPikgbhP2Y0nZfxUoDKEGXFxMMcBWAburBQ6nKLd4ji0yQrmGUaGO+Dtqp+582q20OrV5SimereXXDnyEeTsG9kUateTVFx21jdHtkX1RuKr7GwXKUGABivIYipYruOF00akmwte2J09ajhKIOFblg2tpY+pSaO0NDp/u7xKcntenzU039//Zo/UtF2gimysfhIbmln5+L8+Ox85/SctaP8LtvJrZs3f8TmFX2Sm36RjUuPePkDM9tFZSqeAmX79q1e+vrUrnwXcjl7Y6W0nJe5C0CkkxKFJLxONce9Jbw+H6v9qGrVa7t8zyJ32kGdAFxyiV+pHunLd4AykM1Ou91XVWmlz4HsTMoXyfaCr2vtueqitrCV+oEan1RBmOPXVvR7yVL15Llf580uVY4k/XSzQxzfQCpJt16+JD+/fDlXSwbVtjs9rLH98mUvZQY2Zb01ky2/SzwBq7Fm5mZVQuldGGRAhLMfpabivGIKvGK6KTislCuQQES+TC0KJFiEkaJDGnEdkjvazOAq24xKtDKPVsmMiEoma9ShzScoQlDv3hv5PkWqTCWzqD5m9D1owLEfefVyxtf329++jbZsgnoVtyyZVXcBBd7IE+v5KAWeUu/RCjy1T0WB50pXw6k0bR+RaI7eUH5hm4x+v9W/p2P6eeBPia/PIIhRYRMqqiKnIYsoy88ShYz9YXmdob3Ojn9bXufWWsd+VSVpHoJg8Ec0HpMbix7rWpBDO4MG7C0AwFMwYXf4GOq0Wi34aQduabsaWVkGLNqNwyC5GCuv2/SQV20mcvDt6gVcQkORYQI01M1I7a7xxyY9P1GCDy/oHAm8nNOfo5jcLj2oGB6gUV5VUxQuOw3rd8YEZSQRjbCvfJJ2szlHdaprJ2tZOPBqRIBEyjKs0bm5DzL7oBZEwu39kOni01Kt3emKt4Unkypv9EjVEOpdTS3Q6ClaoGKlx6qFii00pgvpiRbsukJxVNV1pSZp0VGXq5aqui41r9IUK8qZmC3AjvaVhwlD/xMX9D/xj9P/xPP1P8AJYQblolxhqGqBoTM+fC1Ry5KaAwmnNkhnxP4GqqtzORvD0lC7FTZ+5mO5yvY/piskXANWz041nmjOZrXyqzBXnGOBqb3QWwnhJmHRF2mrVM9nmR+pVn+cXh1YfFP4IJqLaqNJmeIbw76EFbrf0K77DRfQ/YbkeDDE5N6mcTAWEBcNa/ffguwiC80oWiVDnA1VxobFWNdZoU0RD7vPM9sZEM9ftpcBka2tdl89+dxosNiihQbxrXJnPoFZnoOaoWsQcw1Yb1gA35kPY9pXAUyeiAos3w+aGX2rzpmgkofH6hfDCnYhnPOUWMEZhXPeGG2FyoyiXCE3MDvKMKkzqeW0WcuLxPGqjbpUz1CguepToUYhhup23RP1Z7IZv9rhdaepgp17mYKLAyhd8deAsir6W4Brmq7bRi79bUqMxbdNhfIibwnsFaFXZsGvm7d/ab1Bxz2MfKw8zFts8Qv6VvYKNFBD31NFAKZLy6UFklWzKhdTt2Cs8BR49mzJity22DS9er04xE3ULpjDbBbhttZAnmZ0X9/J7MnAE/3wRwm5TX7QIJSUc/+CocjeMEWC9dr9+p2+FPO8HBZyHyk3w+/8EL6LMKty7CLoq/1Q8hW0T4ootZh2QpOfqkL8b7YXYUCDAbaJ1pgwEyS8uTTDXDInlW0CyyDqiz7ZSlMJhc1VXzxQL3VCZ01mD2JXgoi95KrPYJxmhDwF9+KeT5VvYHKYVFGb65Yh1DKDRPa+iVPoV2jUXOm+vExyqvDV11kUIX2VWthSdwv1AS4XdkuJ8dxuYYFUASzws2bSD3wSkXOBul2zrusFxHDJutCwfYi+mU55De5eZNrzlJqWovLIVN5wwc98WqotxLkbRyzx0EWD+vaKe/DZszJU8RpFVB94XwnhyOn2UeJt1S3FO2wL8idfssF1Joc92i3Zz8q3b6ojDtlR7JPtga/KuFtaKFXvorBCzmAnfeFjkHPm1bYM4qDpW9WdWSfw63fLWC2txUEQx7gJmd9r6Zr+sH7VyGxG5zScT1zXbROkl53qZDlnC7J9ViByUgXi8HxBaoQ9tuFdb6mSS9bkGERvIaZQWgXMZVyzebwq0CIgMJEXz7FEMJ/YCHDcumF+/9xBBBXvZhmJ+ptinCxppyCcziw+lW1qQVNuusH0tnNMJ0YW6whaJbUYUxhmE96U2622DJOVJd+0jfCGGqw0jqCwmv0Dkovpt29wBVArEC9hHP524Cc9uB+Y0VA98J3OckYBKAOT0bcIYle5j5x5FWn1UJ2Fjy/MfCLKs5q6ibiRcs4tkxNuKVJp2pJgfK+lNurbQI6OnoRXauJVM7Ytxy3iuAVluJn7PZDo8Xmld8H0+2cQXeQJtsplKW1QAM/jI2FtMzKsbQzrGmLOvjT8cTipDCXsPsr12VCSe9Mw1GETxyxncP7o9Hl8S1JTO7opve9b8sy+4NDLE5c75EZ2sdWqKLVZFXF6XjQsIvFIdHsiISTLUKr02YvfOzWgjkj77SRJjw9ThOHtIrc3PCWD3OUXWh3jgPtb9CIjAKIIS2Zuwbmf7/yismPGOxJNcMs6/QLmmYZCzDDEmCAdgryLoxG7epPacFSG6RHuXbfY04E1UU2RH3LV/xk9iQp2HFXO8zIIfgkARvYteWzZLntriSpManO5jPMc7d1evQqg0aisv9lp27nsXo2kvaF2KIptLxJVXRSo83C9/BzoIwII8pZvnwXTYcX1Kkfji81UArDld9oy7rIWCCC32GzYQgLkhk2ILTBAbthw6Ppr1eQjssQkEA+VFrOUyIKS8bBZDs/wcbnfj80uQns3kDwZTWRadIYnKU11H37qVlzPrZWtfHhm58MzzocTrDUGHI7xDEkDTDPW4eEAFEt4W0fNTj/HjGZ5s+mGvm+Nv2N7yeH68NzrUFVexll0VY1HP85McqzBsPMzK+qaTbN0qapWAzGrcZ5VmL41ABPGLW34cAT5Bxn4nIWtCXt4AOtAzN8dHO27GIp0PyxE/2nzj3qYnjYJRprxsFDhlxzwyWr7oRabyv2aTccowmOQE8ehNFqPTuEcHQOTsI9hUTFQmmPT19thbPFSSl2pFwpAZdM1O471XjPuphJHA6hcsGe3biKSbrYQdNupJ2kSuk5Z1InK+BFtW9yF0igKbVtUhNIYB+3ymAXVsQdgQmbeBzPRGROCMZ2PyDmrCPITklYDc6rJsxziWQ7hLMtClN1FpF2Ucazh5nV4LX45IY28J3bsQ6/jijBbYiMQVrPA5lwPtO8ycJZebx/OyiQJ4rL6Zrlsp4zoYUCFCaNByjSReArqd/TQ09pQE7bznN0ledvNIDA037boKmImceivh+e6kJ/i7cUrh+s8x3lLyTOCdVBTsNQxnLIK607zy1micfvKHkG3qyIE0Yui7J+AeKw0TO7LzPVIsE6a9EDqpZW4ZwxeC3fGvnEw+PW3ICM7kHogygWy7WBxGymo51e+H5K3Y2MbktuH9QO3O8zeLtB15umoLZc2amO1ihPKlk1BIbqyzm8u0mfHIch3zjls2JoMdS6iPUCdLEfFgrAmqZmzjWqrtjwaOF2w5SfBQXKT4p7AHsWoSIK803dYCVnzEUifeCU0cpJ4Rb3+ImHHRTK/KSHtfdh+9/f3LRFGncCtYpz1mUaBjsL8Hu6LHfkQwUQzVlCj2R3hn5ykWOoJmSwsSmLa6wMtj8Y7PLGDETSe5IwIYvb0nGllQuXE36AzS5XAn7RK5lKtNCV0TomI0O7Hlm0RE8JR0t6kxfdKbBJQ4tWvlfNHHZZ7So1YqGYYlxkGTKpmokZixCBjU0OJWDs7LREEv/F3JVm42uXhO8pVZsLygKdfZ9+VLOMaRQW09gN800ZhuabY/2Q8ynveUuPjoOisxaihiYqViIi/Jul9wsrEFaB+lHQf1Yz04ztg5Yn1NMNfnhNMNUNOstqELtnqZZXUnXLtkcqkf6U5nCJgzfsJD/FF24KDlVAJSgT/BjJ6sEeIGUxZgtbYjEnVTxw9UHQwPDKiPHa7mr0AU/DAT+wYGqdP17jy81evAGEJFZDlansbRWpZvFEj80Zl5FI9+UarQDu5AsmsWQwKSZfQYCQUkyK9oE44FjvXoC89778EGOac5yt69uyPlr4ekbwJ1UVTqCTq03VqZyjuDWpXcDTUSOEUZF8MPP4g3AKcPbrgrEvUM/CUYgWmIVfj0ZnokLeCAEMPmyWwcAGZ/Rh2NSP3jh4A4z1R97My4gnpNFKuTPzQMi6PkSuUnbH+NuEybw72WmD1scSWzaeBfn3qG68DR9++md9O9o/wX8HwEFF50fl5BfflgnPETj6fIoZ0X1yY9zW61/mzPt6VLFHaVF01DA8ytJ21Z8+Wpv2hed6GxfPm+2hAN5WmAGYFfgeh2z9T19OeD+jcs0e3ETrO0BaGhU68AWFF9sP60LuFU1dOkm8xRbA6HML0DLhmdmCxaMC8UCAjZqN9kOLIl0HFk+FsxhdGyBXKeRVHetKyEFc4bNR4IZ3m9Tpqfq1gKBp4aIbqPYYYFcy+jGO7bzH4wmamWZ7eMSBbN7ZyRXhRidIpe5oV92I52TFoC3vURexw1JarP4LZwu1Tj/T73+ViTVTYNX2uKtvy5bbOtAtCpGUm90TUEo/Ls9njZt8TU8UmoXQqjXJlKk/ZhtpTKbwqp5Yth+RV9CaKXX0tQ0M2AUwy0A92OhQ5ijIltms542KMcvCzKzlw7bOFgISuhedDRoduIp1OEFGEEYPcCyuJQSjzhRdpQqQIIIDTESB7ZuiFJi35Vd/vVPW0J9LNFzI6imgCX1oF2JAm7+VZ/IxinjSxx5ImFoM/VNSIzHByZfkRc54fUWNRcjOdL1LsaIkHo8p8Z5e9UVLZk73pKXWN/Fs0qUOhcZFYF58WSB++3+x0XT3puMjpqm62RBghaMWYiJxnD8tdYdunlKrKqQxEmBZbRNQc1AaTcBgmORCoDF0af3kTp5+AHGkms7/U7mGnpfcYTJGuRObOMIuYnjbSYNeuJ9NkB38ytwjfHtWnPlcuCc7c5Cje2KubJ16tzqmzUn1S3JzkjjpIoEWEZZdUEWrmdcMVqZqbEsta5biQUWahRsvRrrN4DtVa4sFTzBl/Upz1P8DVPUW8YG980EU1spM/iNVGp/EPZaSSw9qpoCjVdYn654KKkBSjRv5XmajBkvxZy8OVi9e/PIiSUMSNjrJggG9n0jA3+uwP08H0DjOFDIjeaT8O8Te4PQ/eO5wXn7Te7hztvds/O/jbfrOrpeahPQLEKSmlcNe7+0fn+6eEU02ed13RWyvLH+KwRdMPYdqn4BOxPg4dE+QTOv5PfKc9/lIDkGhY+xTDfBTh4OPtBN0nfSefBElG8544xS4jXOD9z1AItAYNGgow99EwH/lamhhn/KUANgqj21Fug2MZiozJOD8+ebf/+rxnNDOYTnAzO8l9EzjE6M/iHMThTU5moFCC2TtIgZrQp9gtXYbSjsv6Fa3bEVpr/3uxCk49kNg7tgoxvp40AdJru3OQPD1487Z8csIyJCdkEZ48O3RqKvt+ctcLT1DbwymqnKBXx+fnx4eVeGZPQfRTmgONmjtNtPvqfZSVda/28c/fShTVqpOWPeGkLThPdIaqOn/qKf+Rm6l6HVEn/Jh1ehR2ZAFVBGf6HdUKxuMwGe6i2rLOG1QujmA4JLT7HYmgAGIeoItBj+GqJumrKgDzdDoYEds2ksyKPut/vi25+Y7O6s4oz8e95WV8WrhfaaWT2+Vuu91ehkqO5+DfshU0MBOZEesO+pS8SmEpnXatjeaRJDRGUg4fTjJMJuk5nVanvFlyM5lJxkpg6fVkAPeZnsiL4Q9G/inc4dV31yLXTOAny91FaD0ALkiZARIwrm5WpZAMflGCRjBeqAKZhHgBvDlgJcpm9/B3KquwkxFNBnH41E1Ka/MNRX8z9skAdmlQ3FB22AfHixeEnTheuiAooReA7U0Ux737UZRXY5yOg0GUP+Dhar1YU09LgXjQ+gwiALnw/qkzia+RjBEeqc9YU5AVppvGwg5ZtFymG9rq9KdcJzv0O4160uy6z+11Lqebm52r5U7Xu50HCcUI7CJ0f9Twp77f3nYOa07PeVdzPPhC3JsIV1wfunqME6ehFN6ahTOo7PzpKPNmrMEQ2nfLi3ElHZDEooSKGrtpLEQv60KRRlTybQJALddb5K4ghkC0V8Pwiss9aNvCIUL3a8jCqPFibkEoxKRw3jhpMQHenrSUEffMGUAp89dQEaPUJeq2n9c7je7z+qfW7TTaOzl4HaBsh5GgXaylNOQ7MVL320kYJg6Wad34DhQ8kO82Kg471lJCiZHfsZURqup3C0UKjfZXCqUKRfZXS0pZr2slxQTd9ZJ+SeGLkkJ/o1AwJB6el20P/3vhdb01+LvTxv+/gJ+78Hf7yrtch9JOBz5skD9wElfpX2sefAUA+KWNX0jlNfzcJpVpk20KsY7FHfhrA4Dxzyr8jH86tLyDsLyRLmmmSzHBEoIGQrFKq6yRDdYqlBMU2gzvF7QyQwbbIBDrFGc+APhrg42r02Ej3SD1u2QGSAudNoVcx582aHP0P/77Omutzau8YG0ghuseltEB0UHBb1dXRHfxJjQNw1DFJZ6DQ3dGzYbFIwWxN0NDv1MlAuDBzVEYDkmsDOqpFUonNpa7ZjYM0U2O25SHwyjHWEljrOR9UE2kiMMXIzthlk/SBxpllurliGFcKAOccSM31E/ylOKzLAnG2SiVCtpOu7vq5fQfFvz74mBXUK305gaIyFvCni0BxS4B+A15veXK2r0O598+tQbBGE0kz0C0OEnjaPDAGLl3rV1agsMN8qz1axiOe6Ff1auXV2OtsjSF9olJN8Mv9wVi9IsHHT+P5tcnaACWojrHK1xeoLatooGIymJd34bJKVwk4QTGyaB2kuEeyBS49w7uUI8s6qPWGk1dUeMmPgKxptvmVYC++HHBfvhaFJDbR4IJ20Dxid836uybSi4KaFRsjXJqH0MxIZozOy6yiGKjgEp85McKjJh6riPUc8zYX62u40UVc2RZDLzU5inUEVTyJcf2KR1yp9oyWNSTbjMlepRAKd1JFXVagzjiCCkI0m3yr8CQn5W5KFJAguMkBGkarvsTpkH9YC4x0oGD7JSBidghRi3aKaojTgkH0mm3n5ec/HfhTb6sZJQm80VSm1mQCWX4a6NI5EuWXxQOKHxu9rBMYiXZevlY3svHQi8fS3uhk7osQjIVu3nKzH58xMyep+PlAkIUmUctb8nq2peSTKllwRZq2A975iKWUgiiODKg7Zp1lQxrfuo6fUYj8nOuWiKvZrC0k+gLd8TZmwT3b9EunQdRtE+AV74aXvXdWHUz6sv28SnL9rFXjpm2ah8ft2ofC6v2sXzVSFpwHfh/86LJcypdIBSCgYc3dJFGaCTCdodVkwflMlqINCg8YCnVpVjQoBUhBjejIWeJ/0cNIwthEGa0Rhnk8UONPrl9Dp2+BTNBNulvjyTM7Mb8XkxoMwIV9utjybf1+q5eHPUeXmh1WN8W2k0zSfB+sFfAhAwh+JTVLTNvnd5m1a5wZR4qYxG/e3u5XgmqdHj26W9WHzELtmxlf8B8lyIsbpxHzS9SGhvC8rb7XrZpLsIfHzfJQP+qEP7ofy83Qg/XwgTPQu9Kdh+hIN9HwuYiIC4+jcgVLz367l9XYJtd137tqZXv5anjtf4X3Y2GzvWUPF4OmZJkcSprI7JlfZI98Z23yXwcxK7QL5zitmB2HnUVeqGNMVIInKj3/8vW0BegeouQBTcqlPC2S77QzxslgmPQP/8Tqbj3z6K23j/lWvf+edcv+UZ1GmIXCDUqbeRgz9wDShHZACqomjhJ+S4NeZnhLuwHx9kW6hfokb3nvXo4QGa+x92mCCCcMRYEkNKSo7T29vzwHauCjkf5KKyNg9uwdh/lo1o2HYxqB3toX0oiufQrdDT0FG9XaXGoslp5rlLg3J6mQ6qG5RFNtuslJEsa1vHVBvLUipIsnOSvwhtMMmTWhHIS34R06fLAIlVNS5s9HfXqbnRYtUvvCQTQ2HM/D1XUdi1VfJ6HXwpXJX4jm58UCpqHv9kupDzK49An9PIaXWNFDbUCzuDJJB2TMBesqZkxUV+Lc71HA4iehkOYPhH5xE5MDRpapK2eBvaxBOwjBVMpkUGeKIBCAHWiWHoFWfbSThzjBNDRzXbG4/hBFdAObk7D/55GE2V2oiRCc+1duZKUiNTL6E1ZNVclDurGKKvA8pj88hvPxMTido3jYIC0aYj7KUpqzi+NsiYav2AA1ySlRAzJXC2kqLZ+ce2ry9A5oG3pZdbjNhNPZl+ZQpt5FOuGV5rB27XaBjdvtq2XaNs7/vSPcJC3oE2RGcUVTjuhv/X1NLyJEQKOBQ0ggzmMaSySGbmGxLwck5Oqx1opnuQTQrM9nkeZeDOQ5MR+qNII+SshJ6H4ldbvK4mMj0KayBgXHw7kYZhMceyvRNgqJVGwNgtng0l3P76jVK91N43zCDbuq4f39UneIgEWPu6m6WTII+6mJJ4welW0PmyhCwj8u1n52IcgHxnox83qhz+eb0SO4iA7Hoc0xsrM/vnrzGKn7iVeoBAhJFfkiBT3gfpZPpFdt86lkbdXfLC6br2ZBA9eGefXLmXd2oXniXbhKaFt5c+Ac7JzWLKAAq6I3xkA/9V68GTg67LvxbMPVMpyC4mP5Ergv03YQSTPmGYsba3ww/EkuoW2DtHgkiOtQXycC8HbqKxuLaRlQQwnr7Icj2IlAF2EKgh9WTQQylYQZ/rKJuh5VfZuBdRB8lkB5AHVzk+F9ayjl2gD4B85zjxf0MMYfRcjuLCAq2eWCttRD40+WVmml2VQNuJliV6WQNmUlwV6WQBlQ5/6XLaOgiPvVvmFcd7SUX3HCDpDg1sgmBOnNDy+A/faDoW+93da/HMh/EDf+YKg93Afxz4QggyWJa/ft77A7eY88KJULXpwSehMh1xHejf4ydLFPW9npLZzj12MeNFULRqxLjgNIMTZ6EsrqxrXgoIr6f51nAZs+Or4FxRRtSYeSBP39iaswqhW/d7VpmcRqVOrPyL1qTmb3oidQN4zw7hCRKLz04t9hy6HoIPGUkhbwuIyREO9dwudvW9FQ3c2M+/MUmeq3Z2j9ztn3GJ1MeFqgob5eM2h73g4pJ5giP/AL1oReGO/YPzQt7Ls1rncVp5Zxs/L9h95bXF7sZ3Jn9vwoKzhj6zhtMj1Px5b+Ujl9kYWOePxaCpPTW5vurhFjOqw9nSbHkt9zRIVxUHHcz6mwGa9j7JpEEd/EsL5G5EWYM/pknfBdlZXMJSy6j76a1plb7bxio4XC/D/MzgnE5Ll82/ECwFPIOPRLcIWvziqRpv7bSPcS6jGeAkvo6ulArOLMRUxbgtdmj/pPZ8rml6SwrZfspQl8HCCmTZiT/jGWEBn9nD4GFCwImA98bfXCQQZFUZ5MWJOzGzxNkVIv1qUvQoBEdqI6qBuaV1EOcrT8T4LTFhAhOu168Z3wxzTRt9wPxDcUTAIJ3lE9sMMK/KsXlrXhUaIFDghPbG5F/nt2oioXJBqx1fb2tmJdAFM8eeylErfSkuhSRN0j1Zba1xFRjlLqJCOa4iAYx+A5gOLISgdI2XeS5I+QZ9AEXn217CutoqWkMSF27r65uITdy0SQ5wxwxhiwZ09pgniyFVswnX75SRORVghhSVeYtQFLnwkSlKIIuFVvo6DLIN7o7fUmc3vEjB9co94mB7XJVmFR4+S1HrqKEnl6fjJHdoHOfsZNL6WMzaMsnEcPChiduF+m6lYC/99QtwMkkuzzJSRM5lIxoIHfZyOCo+VFlD2XJnNN/RijyjD8NMUje5ZdACFia/kjTCW4X+GLaAk59wtlCn1m4nXTDC4UjmB8wNFCXZYLyrM9uO77tlgQltEhdju2VndrSSaCrlklju/ER6F86XKJYTuQlSvbvDTUvNtlH/Uyz/ycoW7pXuMfVeZVPYcXqR35NYOKQ0Qe8H3hQXIiIz1sEBqRRVMQ4zvXIiu8ekjtA1fUbEAW3AvvAlgvvE5r0i5GRrAgOZwHfo8ynh577xL3s+sFBSPA1MQVilY5ihMF9K9zNlDfRqWZl5Lj9HNVijeKpVmWetDldosa32cpxibSxxLdW7zSGeFrm0+aa1Sw1XS3jkqukjnAS8roa9aPCxKu0wVV0VFZkUeYP4RVcEXOZsVJ1PvuawP7QTy86dCsBwaS6V7VE+g9wOPhYcB1j40y/e/lwDAx2b5CfACv3r/e7FfuctRO1q9mb2RP2/Haj71ZZuNeWe1e0HDz7y44Sde2oSfRk3dubzTI2Xm5y79nDYsVVZ6/4+9t/9vGlcWh38/f4Xx2QPJNg2x+94S+BQobO8tL9+2uwcOl4d1E7fxJY27sUPbhfzvj2b0Lku28wL7clkWklijsTQjjUajmRE8Vp+s71LAFR1wY9d8skmbQ1tilG3JMvXxtuwBi6lKH4Q/qpmC0AqrP2q2BkWgQQGoLKQgqva/kjutYQG4UcHnO92UxfGUcPpOdyBvVgWoRroatsBrcEZfBqfils6guA3qwNbclbI0njWWz1bfocxFq1VzcbV0LkKyzvoqZc+lUl60Vi8qVMqeplJOtF/9ptAhp5rd4nPp6Zn6PsUO4t4m4Ca8ObXs6uiLCjshaiaxbJDcDeNLj7vRc6yVQathXyzvlK6WZZOLTcAytaHO3CzftDm8CNl0tjnwt86QPnBhcUfcclqwUuHtyQCPK2mpp3FcV4RxR1I7vMUBs/joM3eDAJsPzV3JYqVZSLPnPeBHbd5N9x4L47Srilo77nm3JeBkIqvQv967//Af5FXQKkjw7l137/26UsZp412DkndRzuqv8+CK1zzu3nsJQnfIXq+dwEF3WRuKZx3OrhZPLwzQ6yJoeYeMgwYDjs03Amwdt4/80/Ek9nf9Z9EwI5JEUFoMBS/pQz/P2m9eHP02SfO46F7JajFikAEjBzbc44GuNMYjee3La0iNyWzY4KyEQ0m/m42qjP5LkHVE2/Nf3t/3iVJHPyP2OYTsKpiGN7am4U27q8opDX4dphdBpxG3zYvYIR00O3DW72MiCrC8RRWSdTIo9aIuSAzJ7idL4WoGCfFCXA+mQkQqhLgcTIFokq5REHr/kMiYTyb2OEbXrob/w8v9Fwc/0FRW2vP9X57/sn/0M5RlZtmL/Te8LCqUHb7kZSOz7OeXh6fkOdzYNJ3uPZ8rLwmppawakBfzeWw7scT8DznP/yDuk3oef3YOKo8tLESE0NskGoFVtDFdK5pcxIYvPTyyyUfptyZfIf3N8Eqr5fmfOdyiPrZ54ggsyePLNlnLx5ikBJFYAD4lWXI2xB3qR3nF9i9wgX0BJCAgwBleItSQj1QVlUkz7OjVupjmAI88noiLL6GNHlLYN6E1PDQVRxETzaxhoDGANURRv/8iGn+0tRf62qf+q2UgWiNNYhuv1oprpAR5mnq36QSuLR0Ob73raISZi/tmJ71H/tQmHnk6czke5S2KHzL80K6BK5e2eB7idLujV7apj1rKfMG0ur2iwt0iA/wpVVdfgDf708OT10f7b3c6LTLhyUCy7Hm6Clp+T7bs1lU0iocqCHKYpm1+DWXycm2jEpl8oxzdR7pEJMHxQjR8Rh7BkuiqAlOw++vLlF5bTykqr3Ht/8MLvFXvRfQx9jIY3cDLQfQp9iIPD5mvJr2YX3jAElDH/fY/vJDUIqyPPMyxudobJr2PHlyK4A1TvNcXvG9TyjTmuEtqrZFaTwZpSvbP9hkFY+cML+CcXNGgBCEhvRjPcwmWdYklUrv1j19bYhghN8fIbZnpRrhcCjDmNvZbGy93GyoKrQBhV5fI0YY8wvs/ut2OyKudgl/ysH2GK20zbWPCxezfST5o+CfgD/EcOvgh0tH4TTj8seFeWTGuDreD4c3hxlgy4LjhlQGgny6ZRJbpkzIPB1tRU5ss7U+wzNPkM2S8s9t2EUArwYKWsrVwnjBIeksmttFbvciXZusI7hEl2sYTuJWTefD3FQOmuy7rgBNFoHUT15pj2O0QbYxth4xycOaaEEl7GbePxa/28cHR/unhLwenrx6/Ov2J1in1vacg1k2ZZbelNUL38Nfpr90NbJevhrbJ5DropHvCIGqvqSiTvBq7dNNXzaRmZbJl7iWQ9hMtn/zWZL8Nt7bDTQjolN0Aoye7Uy4jKhfL4FnWGqliiiVDqKGj5ko0ZRS8Zc4koX4b2yVZF4iiiteC9VA1I/MEbv0Qhk18MeRBolZMH6js7/5GNK2rW477w8npKbvNlTcVQoyICgJfwVuJ6LiKIVERDk5U2lJSjVFSxqeJS6fT54Q0HK24IXPxrjMy/wYWqOdCnb2t6j9VEYvdL0NXTYMW96CRF48yxxmq2NIfROMB9ZzqtmZDY35juGWkTKEUC23EbDXEbeOauWxqd+mRw/iYltqEXA0gIc0+FqUE5nmzppZzqArxiMpAQyK0jN+PCutAt7Or3NmjXmlc4nwlescVdH55sX12C7uV+l5VAj2y3XW92+FxMKbh59cHOOiASOrO32YqgrvuVGDYM+Z2hYDeHvzia+73CB8nw2j8vLjtU0v+8N3ft1P2/2qbzOD7JvMrbjJn3/2p0wZXwyQpbgKr9noqkvItnzZL/y47vz/d1i/7k2z99hVuz7L5a5Wg+R3PzKAufMtc20VZqGwStdG33+//Jx3FyvWoNbea5hh27Tg1uAU3nhCGAkMcs0nGf7I9pdrRyq2lRhX3DtME+yM3mvqw0fabf8pNlTpfSrZVRan9N9td6XQo31/VJMb/zW2WPsHduy2iUV5DwMokYyn2MXGCZRKxjZN1ggESyPUNOS+6Mn5Zh8GXHIH/Y+zc4+lVrJku5t8GsvsJZIfRZmTtEFhlSD+au9qGrYigpLZq3mnuFmpyu1O1wGp9u61qNfXrWOTmInQ9q92j2g2dg0st56i37dQr+bYQ091WALVOXWOApc50uvfCaRMgJVIZYzaCf39NGwFzr9LNA+zhd8vAX98y0E8uEoLGYyxd3EZgQfh3thYY3Z3PbsBkbUubXajw7eezGxBY/XLbAZ/C380GljG7XAPC6E9iQGC9+5oHx8qocm3kOciih8ccz1/4+Jh1oXKXz7vq3uBzCNRUXpORm5/04GIr5tcr2jMDqj/YTKD16PuJ9F/0RJoLVLfdRFus/mYmE9H7cmtJNQn+bxpKhHj8mifSVDZZt+tIdMeRtVjohnjLfE73ntT/WjNNfPnSKK8hd55LsCbUF4V1+lFz588yAldgXF3lTvogxnZr2j04NntqVce7lHyHmpZQZi2wrjfMUFDNO6dNgGmWzOuzrlXAWms63ft3ua9AbLMD2PfIXK+DujnR605i2IBTdS7nF60mXb79vmDbbypL/Ofj6GrwIcM6hKvaHbWw7BX4iSEKGLOgxCjgZ8o+ByJmIbPGLExcMQuZLWaBrq9Ez+5jdmv+YzezRTJkeiRD1M3KIhkmEISQlUUyEIhUhShGMkwInQYMhEUygAeKHsIAYSorgZ4kn4Yg6LA8rMEBH5nwPNTBAZ8W4Fn4gwN+aMJDSIQDdiDWsPjbGoqWFSAB494IkIBHrgAyi9GIDPGvbTdyg5ivKVqXwKpVK7bBBVT2Crd7ChBxCe4pHM2cBqdOtcGps4jByYlegzLySH1sXyJwdjI54xV4MgRMMWUFeBe/lzR6jTmvKZT3TzI3Y31utpwotIZNp2hNoG0XaUZ4dC1FAJUyNQ1Jc7p/k2Svo3F0SdbOjKlq+5M8hQBuUGdupb4e4wthVO3lguYx/1aiBy7D7QcGz1zmOxrSSsny7yg7GOnbd7WYmxtEwmJ8K+5T3sQVlj5n4AdKoO92PCEAlmK96wvRRgbbBRl0WR1yF2sp9A7CH/Xwv/I6PZaG+ykZOTIVtwX6zJG12wKK/Pxp/Pv+MLkYdS/i9k/pOPkdxtsQH5Hx2YY7wcsR/DLOBYJfgLA9pfrpq9fO2jiQxqgeHmHJURr1CaNeZBfOOrExnYRZ9SRZnln1LQipmYypVAWe3w1LU6GxmqKCO6Bv9284sGzwygrtArhf4YPX8fhtREqhJyzcF8j1Q97otO4EoHhaCJJKx60J9HrAez3R2oFnj7QFhfetrEyxIWx9YEVvLE35r3yhRrClhjbD8jbSEORven4OTg1UkmWv64pMS7X22QWfXpB9Z398cdYIdsJWuLHRgk/yt6yyNj9hOpP9pRu8MPlLoevM6OPD5z+dVqCoN6d7WsaL2iS1VLORNFzvtMJOh5F1raxygaTPwdztrmCRqKXwswlKJ4YqqhbOV+S8xlMVnDQDk8QIpLhaTkjlyQPLlNybEBwD6Zw5VVU1CDQ3X2+ZTa523EAjADWtQ5pDnonErv/dPk1/HiU3pwnZYsOcJzI/bq6kP24yzYc1gqZEJfvCWSMUOS0cx0xUsErZYuusavMQmM2KtIG17CBqpiEZ48gbim+TAZT4GAU6ZCZT9hdq+cIBlsVAYsCrvaMkLhHLK4+URFO1jQFvTQYtpVsELO+LVDtEoGNSh2nLBUENzQRCClew0jAJk9ED8jHRdxoaMxU/o1e0RgXknyeeFEjpPg6skhbFoZW+byMI3XV1pSW/elNmQwZJhq3vgDEC1U8IzUlfK6cakyezTysiZCDtPDXxpESZKdoaNfuMfkBggSZIprNMB+ex6LPDNwdPv9Jp6JCoycdxDxa9PvTg8Bx8OtVbuuRUFWel1ummbLVBGUfr6L0nuPMiuyZ6ORZsmfx7K+g8Os7hqhu4CYsK7Pa9Xd8Czgr9vXyl++s/jpX9HAHrgS13iHDQMXoXya+le+eYq/0lW2iZRvzV6A0uRmjkd6/IuPvI3eVip9GZWgUR9cJVBpe98Xdk6y1wvPl3XO2/e7dRzJJV2tzAmUnraweMUnHlNsv0yZi9JL2MT9OT+ALvHeB5aVlKWDgUb0VkdW4N+TVh2YN8JVkN9khLx7efh934XbYSvIeZG4M2sUp+y1/THqyPRIH4zFMpoyYx6pI6e6MHyd278buRVnm0qiB7EP443GuOyB6K7U5WM9hNpQ87XETJlSM1Fa6UqlfvJu+77IIyaOpEYm+x38jX5l4klB2ydHFDeOT2uKaT2jj5or4HrUyVsuBYMDKkLOlTs+b5zUg7v0mqTg6/fGmQtwdMk3GftGYtfqOn9ehRWZ7f5e8JQt2j2wHTsCkCUGbLUbXie0nm8UO6lhVlp0UvCqyur7oNa41SlQhWoO1+rsYx2DnoKS4e8gGTKyU7kQSuE+ESqe+8AqPidXs1TwStSjKhw55l3HTxpuGk4vTYzmg7s9habaP11E5mvPvaOFH8rCuuY9oDeqQh/Gum85+Acs8Sredg2sqFk4kX7ELGNKLnobVby0uLBdGNUtCniYqxpDcZy5Ipnf7UdmYRtlmr0+KHBfrWo9htPgCi7oj7JgV70UMyHKLV1aa97iFeVIvZh7PG6F303vWSMZHOybB/MrkkqgJdm/6UDkvI17LsGXL/9DdzVmI9r0icUdF9FaHae9Vz6U/nxWSTJuzmJN+vlIsWQQV3IHXjFXpj9qNf//Hrru83VxwrV3MPA7OYqmizzwllslEFAstyS4sUswFTxZ+s43eq8DWr0PDo2dI2dUo8mFTvTXYCrV85pRM84QtR5liIkvegv2XWtYhmZc/KXT0/W9mUvO9mDqfM2VSO5L0wBdiGHV97rPVKFA12f4itjWy9kCKdEGFEpHqTSZSsdJGySPPkPVj9aMZ5pvfa3suWNlX7blXAUT25qa+GC7SArqHVLZBwegv4sjt/ExjxK5ugwGlNmNpfjfEiWamX8HQ6Zb4GRD+kW0/Y/J3m7Sj72HCdh9MaHnnItvTZI59KTt0pQTPhKr4IpiuAlEtTimbKXHKE+wg9B6xsWTyG0dBj/nIeXKJK2iiPCzMPU//GfQCWZ8G89XQ+gQ3kNH2ivxpUEb1t+Xgy6oGTXxITjfpzrQXAqVVRmqG/2vkwha0pM4Y3msAttI837wfxmq45Ues6XFJPTYFEWsYrRQB2oeZ/0vQSs2ZLnx9to8+01QHsE6TyLySK3uFplN2O4GI6B7XY0qgY1Esl9aieCq3er9S0hOyha+Co4Bo4wlvspB/SkB4oN7hLPb30dhCN+9fROD6EfdWwG2l++XsReZBNzjL69k5r2GTWgOg6Sshn3H5G4JXBGq34eFJNf/p4hsxgtaWEWhAUuy21G4hbFCd4i+Lkfbeb4uUNZKXcG3z5ElM7QQpzuOT+RfpGvGyRQNHDVKRbTubOJdgOFYgMfSSB99DHFKI4nrw6fnr48vmHVy9pf9WQSfuA2ZtzRLUq6+XTvuYTQGCJHpEdZszi9TLNk/OE5laXGjO9W16P47C/gN+4UmUx+Uw9BmY3m1hG7FDxZkA/h0y5RGClaxZzh4cW8HaaPOxw3Ws2PwqigDTA+/J+It1NO0Qt+VfTb7J7mBB3jv88SH4MOp29Kt+LjClwL+NreOfjYUr1N+oIpWtx/K610d27tdnC5iokueYcAnPg0ODQkHMorcehoXZyAHY9h15IJ2qymq+gejR4GHDtKC3VjiL3zjt1qzqEbgPVlqjoZhPYbk/s2+2hsd2OiOQwdKVZ20MVn6/QHq45zdggpgYtv0FTO3gh0QCRuG4TmWWzwnZtZUNcV5z0AQ0qU62RHJfLGqra6Ksgix0Z4x2VsojFJ0zlkyeENeAGiQccswhTKoTLvav09ct+wq6saa5Nncu26ISXwmx/SAZA/xYkZNwX0ThW27rbXJuUmFxLMkIg/WrnhVSAIQdE7MwBEauDiD4oen/hY5svFhYoDm/427aUdH323Tsfp5eKsu1juMmNSDvxWXOZFSFYkFwLPXPp1ljzuIdS/AfKAOhDDy6Z5ddScyXz83SvUAsBIXVXJgIA4Obb+F0uENIDmXEjB9cBHT3evaMqsbXxy9t7AbHErF55z9AKZK2cdKHFbtAQV41DE1X/HeBJ9oBHhO5lMBHeJe+y9++Nig14KANAkbj76uvVzphtm05b0ZiyTGMY41cOK5tIQpBpv87xQqkIlEwluCqPx5dQQOelUsD8bZGV+Ji8+iZ2jRYuVT/QGK2Xk8uzeNx+Gb1sQRuIog8GrQlhG2lF3PebAM8Kul1/hOB+U0UR78VDsh7qgFS995tobXtkf+Nu8TFpIcUmzhelJObkZgiSjKBQ+9J85PsqSvWq8t4QPbI4CjasRNg6dWn/ROOGNLZSVNNMFIvzDNZ5QuyXNj5zuCT79zjJI5Y/gz06IHSU2rvKezm+YCjTkQ18hfd8KhlPZ3SqwdEu+43D4TNZYltH1vbJ6E3Er7j75qTOb2L8sJvTXxLtdohh4JxAdzr8VvU460VXMYTziEJPxijdf/f/eXf++cO/Gqt73Uerv7+/fwF3Z/t3/wknOT2yWXxCpu5+jnrznm9cA8GpjVfNgnNE1ydqsXeN3kM8hQcWPo56H4s+jhsbLfRzpH+bWgXNq/EIvCikN7dxW5HMDmDcpduxPX6rP6aXiq51tIfsstBQPFWuNRKjIb0mvwGc80elw0jSQQnvWjB0C0wceOXl5ZAuxqYXxpBunsT9wkZDqYv4tAglvBD2uASSncv52TW3YYyLWk4iLyzS1y65hwEn5hF3YuYO0Ow30T/plkTOR2lrGkDNCETdoNsd8ghIVVVMIPAOjOuAxCf745PoU9w/HL15cSRmrE+QpMoEJgpTv6s+aNvrEcRNdOU+zE5w3EOUBwQt2ugdvRuQGd6aUDGJLb3oMrk7afW6UF5Yi1pX3R4VdND8iWrWOYjh3XDl2c9XV3DwnRGSkhXg5c9HR/7du1dwukEJst99A0ZYMvuortYg+qY6lgiJWvvNKUpv8/kbaNJLwmBWtdkUa4bWGsIUs+qkDeoQE+RXroo3MW8kzIqbuKxxZt23oi5bg66aLbhjkd9uptOGrGenxz8f+AX08OK3cWO/ddl0vOgDfw8VUKJPe/tdHlAOZY+J1PzYbBWa32aLmAP7U9GNHgbAYB/QB7t1Tb5BhHPSa52Qr2fpsN86L4zvvXO6FFy1zmkEzf6drqoKPGLk2W/uBh3cjtzqPbkEFNTrm2Uwe3S7y/rDG09w05Z0r+10JQDQvu6JvZj2nZkLLtipLFM2dk2SXWnnw0x3KUAJrmvQZ2k6jKORv0tpelVzFOybe3Jx53w+GBNJPRnRG4z7Xo4Kngdz19v1/JWLFb/hr0zayvKH/Fjxm/6U/ocK6OnpsVwFPnxgUeua0u9T51ovT/Jh7FurPYny+CId30pl16jsqIYHwE+iSQbnjnBlGndYK+Ah6oG1vURZGCcYKml9N4SdedDvtncKBwvwFQ75yN7Mg60xRKjxFB4eqewluXcJS6k3iIdXeJiRp17SJ01Lzm+9mCx7PJjNo30SjTFVPVGA6p4EsyghsdE3oXw4GALlFxhM7+EE8d31Z+aM+u4K4uKoODPa0lbIInBZaSNKJYFkBZ1KUhsrkEqqXS5iIYSDUGrt2UmlvbsWsZS2tDwy7D28EfYKxz59DONtQAYcutxSeI2k8p12ospyhaxKJYOwitZqklbXWT98sOsb7hlq1rdyhxS3PbwOlQgy7yrN2n4FmpnZVGhHKacgFJYHrGoNQ13c48s4+kaLu0UBjkqYlkfUQLGQtuCkM73OAPoSYmwjjjlS/fW9tNebXN3isShZe5HzRLxnBPOnJL6+Ssd5i4gsgiIneyatnKrsrAGHSvsuwYIh2w2dwN6g4uaRAefFN1dwUEAWD6Jq/quS7DPLagsac8jqpXLAGrXEmDW2UeaIFRup2QerUtU6TuHeX99dZ+ZBqb6vzhoGF5dz8fFGsFURDAKhVSyIUkljWUEXCXI36iLv2/nJ+9ZB3tP0yndXmZu6b2tSN0+vOHHflhH3bSlx3xaJ+9ZB3LcF4uK2fnbCsmoOvY2U+fYKM5OUv6gOOa/li2VdK+mwRJKNAuoko/YOk1zU4DE7vXg9K8Fooe+oMjPJxLvq0GygvFupbaUaLZJkY6A63ZhJyCScYhianXpaZSsJRf4L7/CpX1Z7Zmrq7y4lKYHvkUUc1slrPsG9sxg1fnRDAf0qGnk/nb448uJhDIeaBDIfkPU5u4p74K5A2k/WYzx+8mCdBBBMZxF7V9EFLLbnAEL2EvHlVU52D8rbEkyDFUPQlhfl3jhNQYB/AlXnMXkxeLMQcFLypvXWo5e3Z7gkf4yvyEoPu47LSPpPAZ8J9kv4/p94nGpbD4Us5lhRiuRYUeHFgFGthfEUHGxGubS++p4P5tc4gmdTlmqJWnypqSjXdvZwtEdzNLNcmz7edg5XnVsscTlY4pirblS0uQ2lzS1Cm9tQs7lRs9ydzl6JFW2oW9EI+LCGGW3PEuXYGuIemuWd0Axsg2YT/ICSbrLCrqlBGoY/xs0V/wG4M+Du+9eH/zNWjhORkCtBa9C01bpvVJPWqhRPXgaGsSvrDsQphTToTbhBb8D90CeEXSkadoFXk+6gYCVotibMGCIMFwT5I2ql2PWf7R+dHPg2a4jahIZmAeFWlaz7W1ta+AeaE8QHfLkbiXcTSwjzVEaFe8vgoP/9Lul4t1+Ah7hIri13/Xsrjb6w0ZGOjicxdDQiVPQ11BlDjT8OlPdc4HsuuAvNhRE3RW2guxcFn7aCvyoYdshQ9GiCH9Tedz3F0gMmngY6yJBv1J5TNezuUbUfupmt/Orfx1Nq7syf8IMXbUArZy+8S8UDuS9ftPAcSloNkA0MA5AayTRAPtAMyMf0sfF0GBsPDswHH4zfNybA2/jRnWCXnW8Qnry65mHjt/SIN26yM92H4mQKwLACmCkxuAOlIJVysXEknEvHl0z6U+bvsvdS4O2N1CMrGbrTfNhd375711X6oLuxtdcEB0ko18tWIiJnR5pPpFKK3o5wiGrEFyatkXIGMCyW6eDD1lU0zuJDMtSiZrM4ksBjiAhRTtD9HjgEfjh5dsodzzg5wMwdjQkZxAn2SB5fj4pn1yPrwXXhKa4zBVZl3LHUsgyZKJosn+W7TBDvPRzr8MXpy5cGbykbxCaGd1rd96JjiuytqCISw/KqFfAWMV6kV2UrjQr0JK3Jj7oJqzQPgcTgUr7HV23lKYvs4FxmBEO+mSQZKp2mhUNLt3iTH3QD2TKZtyDYSx8I1yRIWWCMJK1teoeAAloHIUcCd9owOlCFJy/yu6RCoeOl0DZe89nHZuoHUg2P8XlkcjEoEh7vSVeLRHfW4LN6T8Z7c7mVqZIpM+WWq5TKLQh1YXJLKVuBpOuZJreUUsEBdAABQu02zK5k8pSLii0ho0bg51UmmuqIJXUEueRLcfrkxUdqI81CCEKUsZzBXiTHcYTjeBZcGcZ04sQrlVQ20eSUOSWzEQLvC7NHkS5C+loHKOTS4esTyhwl1lDxLA72hpIm4FQMiQYcSKMWeIo2WZ6BVMkzYMzkyDZbxUSMin2eirUyIiJQi0r48IEojAYZ1BiF4UrIYxT08avXae4ZbUxL25ha2sgJyIe+ERWq+IBzxpRPDj4JGYPoNFT7EKmTpBXp/ZETUA3OlSqBbIePGaYhvTSu7gNXwzSFYm+gvlwI0wj2EkAhgnJAhzT51qU7jbt3I/71yxfylG0b8DH7/kg9ktVe0Rpo/SM/zYnCDth3B2J6MW0YX3Az6wuYL4L5HvKCudvYdHDl9HSO0QFTlznewFfe6RtBVDF8ud8fUzYjk3LUuaT2yLrTBU6rRCgDB98bNUmL8H9gLb7TZQ1tisN2A0IZPrxL9IGrQ3vDdvzbJBo2ancJ9Mv6HRJDrbRjNlawJ86GfzUe1G3y20KT35Y3uaWL1dJG7zWGYs9/h4hQ/p0IAzoG4SF16Vxa52agqNm1Wdpg1jWaYslixo2BxaIDiGAct7nPZovUtyYWqo8hYC0wnfp4tmYIA1c364NcjVsYWu2IaHDETZv/hAiz05QSxlfSwGLkr2ILvGMvaKv1myDM7hjWvqxJdt/dzqOxJdUE+ixCNoXmrln8TCuW+21wLMyGSQ/8D1Pqqu773AJp0zXzVqp7pA1aPs++7fN97sRGpkzql3juO9GsrRdoSjXJx2He9XXyNS669iKdgC0VSBpv7969QP0Fu9tvKtnXCqNCnTNZi8Bi/m5CsyskmrRvkIEFYUBsTUsyVdex7H8Umw8/UGC+zGQvUmIaUpR0GowoFFLM3EQG77vRe7CSEfp9+cJ+ADGb/FyFqVJ3AtlWTpc/sK137/KNIAwq22bQ0vLCEGNhAdK0p2ARSypk9mkPokxpb8OXSJTznSdRbxD7wgIRt91QLKpJUoOA5im0hCjmRAQmuLH7NG7Rzey795i9jO1oqeqy12SZvjKdriomZQ4N1fi2IcS3DVdX+bFECVci2JcQzbZjpiVTw4vB0P9u8p7wQdHtCZPuwFMtqzLsOTCemk6IQauD2uLRGBG08G3kdcqdgH01UVD/YXew1ycNH8EURbfNLlQEiwVD2QeZPdUDPEfqNgyk5Aji8tDbTm0cHOFBvmdRWuyQvSL0CtJEK/MYATHITlRpqtmpX44bsmAv4YEMPCi7lXBRlCLI+27aUp24u2Plh/VlCI4BF/E78fS9ZpomIOq+TYXjRcoOTi0WuxYGppZZ9nfl3HAzAwcLo5kA0vevMPQebMjpyvLpSZRiO7sBmTwn1qIUdrqKdYnTfvDeIRRgK69AKSsKBNobu2XBEra97yvb+2kNYUH27cnUoaooWQ6dqoaQqrCM8hAZFKi8B6P3hbNKsNlLSrPsAw86TXrqk4yIspn0PT7c0V3VFxZV1TYWwT1F6qNoBdPDE3E2EKNdO/B4TlZcsselSadY+IW53NIIDrK8moGtcHPRACIpNZRJQlHuKxdhLwn1fk5R82v4loO1x7CepITMy2zuG0ZcmohrXpxEddn7rf3mckjU5PiXeAxXUXaJfIaIzf9lMXifp3v/G7efxp8gBHX//Bwv5Oj6HvrnQbwnJlChXn7XyXDoRQiD7gn9+FOi3P5Bk7n6gA+zFdNwiq5/SF0Q2a0f4I3APRHAY5VgFxeBUJ9pcKYeQqbDPlwAwr5FIpNSy+sBdu/nk8fefe9lnF+n4496I2AKwSsvhulZNLQ1UIbTIolhzPEHHmRUaHvez6Rx//M/I3TA7EXjcRJdxB4VBFnbO0kvwfmRPCWTkXpbRJ+iZAg/d70fnu6//cH74cWrl6c/kc+3B/vHPyAiSNfU8n746dXPx1B++PLn0wPy5eTgyauXTylIDomBPHGVV0Dh5Hd2ZRd8h6vB4BOu2SKfWP08GWdE0GBQMMbpKrhCBVeo4AoZrpDhChmuLCak66vIqONn6qUjg4x/YgoqnVb6zLrMevwD6y8OUZ4+CDrcpgHOFxmbLlJL9TDyO+5jJjMZcPvu/XTa+n95XXDmW6MVkmn7/3LjWfedH27cz/yWH3Twg/5Yx3/X8N+QFuO/m537l1BAP4IQPzbx33Vagv/S5wGHHVDYAcIOEHaAsAOExWLy73skSTo2ozBZBiJMlM2inzutnF/QQo9WMSdgiSaby3jArPvwc6ZrcMbdJ/HKytQMnY7xeJwnNGPpOTq7FjKznXEA8+WtB/HwumtGUFIpJNPAVicsqbM2LtTRs4pZKjUy8+q8fGAgmY7bkvCYsbp60GlVvnxRf4o84uaQJHqiOSTpQBiOFxzswyJmn6e6J0PuIfztkn/g7wP8hw3BgfFmuNkDhhHkxFT0M8hxMW/bBpa27ROZNSTNeDwmLPJO8DXei1Py5El6SV5yEo0y78UJ/p4Q0Tkmq9Q1+fUckuwTgQpf43R8kUTk20/x8FMMjvvk++HlVUS0+JZ/Gg3SS3gCOcEyqO4dkwcjeALpU8kKmNM3/AKXso0iRpCbZEFW3CTF7nbIazrtgP4bso819sbjRd94bHnj/qcLqnKAKHtBFnP5I7rhP+j7x1wK8WtOfysGktPL2nia5Q/F/CGFCNAipLjLu0tpUQDYJxrr5QkRawSmgzJvAFHj5YABBww4oFQlIdubCNVWH0c33aBjKQB31BeYIU5eyKEUYzhQIIPJxZ03BaCQAImLhtRSmF/Y4t/iBp8FYafFoihbd4KWyFJvdIQ06pmlclBdmWnsLyCFCFkznsqf7aeHJ6+P9t/uWDqrXwpE3+AAOh0kvY8juNQttICIcLQnnHxV4fvu2mGhdqfD/1pq57JhG9ZhcHIVE4HPY/+N+8cyOgifQU5K241FTw5enh4ct0aWy4gevzo9ffWiBVeEtej9sz/4LaXpnVYQbvG/zZISZK/W4w78EXfSmE0O/vRNLmYgaIkcxNEF0RrlRKcRTiy5taPss55rwLiixCGuSGtYKklHvqUmsxi0ctSNctgOxc1cU6UcAgm0KkABaStZBkkK5WpMU7rVF8ocPv1UyPqlFUvc+Z/KCxrLceCdNhwRzTZuw0eVfkVdqMA6jg9ursg2CO4EcTVSjXSw9W6+QGUbgUsDFwpXbp4TgUE39WRzDGKE+/4XUJvLdgEAQwCK1URCRke1PdcaHFdOJNfyfaebGxelYJcKfK3skuliPYJbyncdwJaEz1MarEHH93Ec9V+NhreVb20nGYe1spoMjN9KZ5IHEH5J3UUmE8UwQ2BPoe4hdi8l3YOLK4qVPZZ2SCdbCUKHekm2zLpuWULM0lnDqErNHb3fJgmLeYW6k3jUu237K0WbmTmNALqa93QQMbxkBGUWJCKsxpLrT6vuEMZCdXWMote83K+qvshAUltRSv6f0muPbHVuvX5ykeQZi7KKznmocp/guYyG3hVkdqx8l2OwkH1OcbDYMJSwUMCYXJOVbayTO4nY2nhtI1E+8VnwNVTwAr8OtvkmsoGEz9F56y8yjEzqlA6lfUoZahQEO7ZyuXMLAtbBmgmFl+k4bhdWQu1dJQNBgzMHg47ENiD0nWP1oAjqD4rQr4Nt8UERLDgoguUNiqDeoAiXMSiCmoMiKBsUQeWgCNRBoe+rHUPhBdmnXE4u6Vjw3ZVLiE7lojcG3asEQ0X2C7UdPDMOXitwdqsooRS/jrqQ20ErRYIaFWRaB92G4iBedOMiXnRTSTyovBjx8PUVqUNu5iNedFNGvOimQDy4U8BGvOjGQTxpanLQEJMheYT69wkSvxLHQqTUGlOu2UGr8I5KsiO+T7QMbkwsElEiLaGlBDJJqlS3UVYx1dkJTI117tntPTHyD1nqLkRU0YBSgmIrqLBUZ3qRnBRdCSkpgElGVs1GQmbOLCFf6J7fleQLl0G+cAbyqXPdQb6winyhlXyhm3yhg3xg53UQ7+dRknse2HL9kqoltIOqWVndeopEsbUVKRxGOT0+pp3iRhCk9304u5iAh3Af7pXgA8N4RQn1odikPVaxUR6N6M4FnRnKS2Y+DN8SBqg45mODimFmZmhdmJklbMHgRzwWtYAhL9cOGJBFSeDVHboCP6aws0c5inDwhz3EbFl+NY4ynRfOR2q0opTEgITF/Q/JPjq6igskVbCV0FSBMomqIrBRVT2/sZP1bN6cey4cc5H1rH72PSSrmnuvKLDP3Hn17FAmWc9sOfYcB1xlZBWnW+WkFWdNnl8P2QI0VptUSmcByLPY9SXhHRQXVSqpLiDtlJeI3NSXJ4cODhiHhzXTb2qmnFJ08zGh2Koao1228WIc9ROZXzKwDH7jDWW8MEALzDBRWblhHtLWYkdYlx2hXxPdMtgRLsiOsJIdYX12hBXsCOuww6Vk5hWSCTsq5VLjX02HbMoXlEr5QvKoBaerV/G4R3hA/RtlRk9gzaSoxuQ1hFTuEk95qWDKK0QS9xoo2RplUF5CboliLmorLSgj9j1u/aDNURcAN71JnVWiIrPkzOT/y5h5Gg+TS7Jv8fN4GEP6U0g25MV4cpO171kMKNjEcisKglhMKbSqw55CXTbi6WEmbX37WZZcjJTX3WnUOqBsWulbcANxsFpx13WsNxZMJRyX+LLa6GbeXdg6V77DnmR5epn8jmYzcEv2rrBiYU4WMJvMLwCYrC9iEGOg6JoT1+peUM270K+LaZm8C5bAu+Cr8S6o4l1QxbvAzbsAb7vJvpHb4ZK8CtWIGs2vUC/QPAu1IrgS71kEfRP+Zlo5aCETGggQdMoBIOlyJdArMhLGx7h8IvzOdjl80YnPAWhzCXSAPpvB21FDkU3O1BfCxWoblXDYzWow2dGgxqsr+joii9Ew5mDS5dMKNMrJSOOwT6PxxzrwFc2lsEcYaBh0dzpVMGE32HDD0NS+JQAv+ALc3nAOchvT11u0x3gDUwnf0Yy4CAa326oFTNLW2ps5XFfL6tdxXtXq/56StlGZdZo0Oq0NmDrS99hdJ+B1SI1tqPQ2BlcNd4WQVyDQIL9wKDeX7hbLir67xX53i63hFrtkDf+7c+1f0rl2RQ+G/e5r+93X9o/0tfVNivl/hJfs4m69f0o/2++Om98dN787bn533HQ4bpo2mBldN4vVSwiPUHg0VLDqWZqxPBdOE3kh+NcoR/IWKgmyFsxWTnLO7MxZrL4Mci7ZqdNEXk5O5oVYqOQgp+576LD2lXmBnSOEXwPHEkirNan8gBSkAs1VcwYU/pSQ3QSlrshkcxYTOQEfoK8zJkD6GQRhd+xlyeXVMB7Ltnlkj/Mxs7FGNq6UQxKsyCgFhZ1figXWxTZp+XNOBrLllf3J8vjKSXAV2RL4p7Wt4oCb6Ipk29YD/uTXcUxoeY23I2Zxb0IvI9T7gXyxsEW+s5QtEqzIFgWFnS2K4buaLWDjrckauFux8a+mXxPnUjnEmlkhx4osoK2Wx7Mt7XAWz27VE/GSt9fkF4CW8QxRVfENDe/VvDNOJOqxkXa3HiMLL1gqT4vNn529KeDgfVqUzUaDanLcqFXGfPMFVePAPHKqHhJVvnUGEYVvhj8L5qWOgtqud1b+mx2oeEdNluqOeJVIq9hodcorOwysxzzT97Qc41KZVssn1cow1Tm1DHlNTklH1VJkVRwqOK2WnL/WY8657g1fim+prJnFSb68l9Wu8hO4Whm2t7Lfw+hM+EOUoK/JXuEyX4aqirmm+3zFwbjLIjI5W1Xn3sTNXxvOJfDY2tR6ceuZ1vjGStBk07FSnZ2U67PFNpVytghe5K4FpZ3DFp+GWlwu0ZV0JldpvBasy2ZzHcVIb/TCam/h/fU5atd/ighr8LNU37G7n9TiaaXG48K9bM7W1nts7C1Te+xvqc/EEuXHgboGO6tVoKKbUE1BXKIE2XAuXxDXUIVsPHRqQkX0s8hUqz5kQVlLppZpRYqnloNTLxGinEUalhLeUFy1sJSzgjXqPBkOwdLm5IKCspT8ClyR7ioSO8FVf7cqSkt3tyqCI2Q9wqtIF6a/1sI6bNCaWsYGibkWNyS4mykKynLeKG6GtVhUtSIZfa9cklzIl8Ou+WPfRlo/qphXbymyV6lgYtVS5PD/LGcmcwEt5yHqyVV6ooFvQbbJdpVyi4IZrLqKxjnNUoVeQamy2GHQ0L+csULuhtRgJ4N0cZEjKmMed8itw7OwnGfnaZrPxLNwSTwL5+cZXECwXL6FtfkWlvMtrMG3sIJv6CZdzrVrAKnmGMO0IL94e0q5hUA6s2ZnBiKpwQqEczGCIiljA/VDL2fCi/JAPCHxlHg8vybCBdnxomaAHmuiFqdnYUmD9GH1Mhk154rKK2lfDT6+UKP0ylCVcfOFjNorOZquyJhylIxiM2mHA0kJ+04hCIpo0nFWjWYOo6TSkZrmSHbPSs7b5fWx4hkITsDmOiuvMkpyIMc5udsQKUI4nDtfEaPh2vHSXDCVDFMRzUFrtfpCHNc6NC/b0OnEo6hsm2TxjvLNsQCzbIolCsdmWAbPuHg3d6IQN5b6IcwlLZkrWYgLXymFzYQhTiR2GjuShpTFFs2RNqQc3UIUX2LqkDLsNXhQsltyJhApjeFy8mMJSUQqEM7Lkq+TSKT0HeWcsSUTKUfn4E1JQpHSGLl5UopUIFwOc5aVVqT0HbMwJ6xkTliPOe7dDg1AdLDkP6TQPUd41RLiA4Ksqv4cioFodSm7aPNhu0p6lcdj26pNMZUyhYIUWcGq2hnAAjtLyR6UkT30K6ouRPZgfrIHtcge1iB7UE32wEH2oIzsQTnZw/nJHi5I9nB+sodLI3tYTfbQQfawjOxuIbNgupUqXDMn7ahCOAePlpx0pRx3vbQrFTjqJV4pRTJj6pUqXMvlY7AUPgZfkY81U7BU4KhIwvKE3z1npF6B25ZpvU9JlsA93Hd49gkMIuHfo5tuzr6jltNNaDArjWY2e8BwPRKItGsZ221/RaBVSnblTYaSLQyVY4j9Qktt8HPGNsv3VYtZhE2GSX7LVD5W2UEOZCMHiU26K7Nt9ognGuQ0X49rBDZhby+L77aELfFIJS04yYhHmj0EiUYdzdm/6kgj2r/iuy1xRDx0SIsWMgKEeiVmFzObdq+OYQTbp1hqejbrR0+YOnq6XaPHjBjT1mmlFLjW8sKk0s9bphX6Lii+C4rvguLvLCjEO5X572jlKzXORT940ytXN1sNmSnLFKp4iTJTqvIms69KEfZYBRX9VsWc0vvrksPff1tOfa/rHM5iV+mh8WydvLYdyF6L09dr/aj1mp2rTlu/xS6Z38paIw4/Ir0TQhx8EEwpzn4leTRMet2M/TxLh/3uaHoqRLPePMC64ntcigNeRYyXLQw1aiLNAc7BIjzDgXLfBHekzxiMXbfi0WpzihXWxHKvMwLDze8yQmOk9kchDDIcC2Odf/KlmduXHOkC5b4JPmcHszq+4ODWUuhgZvHizrivdqZ5ZOOYfBHlgzbaMxtBp/Nj3LxPPuqJU+x1bx6ZSm8eUdreXopspTPJ0dpDLPQt0KVNPcxEI70svyVbUVrvEWsy/WW2mT7FRjMA0Wo23ZVmw4x3HnQNVYWMQc7YYKjFmwvfzcbCM2wqFoqGoiACcTf6m11ybrtHfH1bSw+oJ0lkIfq2nIZqkkQHWGiADca/Y4a8SyIMuvt5+yfld/v48PlPpxbAV+eEQeom4tX5MUgWopRiV27ixsvJ5Vk8br+MXjaLYERJqgFWzMX5PX/h9/yF3/MXfs9f+G3zFzJJ+n8ng+HCqQT/oBSI3zMYfs9g+P2m8Bo3hbe/XxX+PePk94yT3zNO/t/JOMm3wyXXuRoe7nqNUtdDBHRWrcdio4EVDor0ak1paFNrm9QVN7JqQIJ65h2sLvvCPM62blxz0XN2L1tKp2pHW9cbTFq64DT6uj1rnbabavrP5U/rxrUM+oeL0z8sp39Yk/5hGf3DSvqHNvqrBi8H7X8a/05WDAbjXcb5IO37VZjmorzRmApVkJuVHI2zITUJrZZpxNUqCcJqZsQKYqL1sBZF03MA9WuhW5isvFmz05Y2Uz/sa3svUxa/510P4pHXG6RkW+wNbAjIakoNf27+YOvKmIQATk7R6lZ2UWOuhWeaXXdGNwQHjhImIZAHofLjdFiNqZRNvx7H6EtHb6XX/RXaXnLOlL2LNM48ODHOkj6cztI6tFKLCSjMnUtJnnpwGg4HRWPWVjhsah/FRAn0zobR6COgvk0nHtmz3yNsZ5Gd/fgc4sqySW/gRbRu2/tV47TWOcsRtyzUOKxXU4+7FYN8OWdndsBw4FgOZysdNP7KnC26kGiFLs6q7iX6GUopZ8tCAy2drYFqKSyuGSeINgzGJ5CelK0J5l0VTTd0B+MlbmLLmEFXVQvBC5GCvO6CXu8laGZ2lC7BNdsmZMlu7k609Tzc3dXrObe76s/o116CZmmcChblVPB1OFXTh91dvcJ9fZAzJ6YSlyF6qkDPA8kun0ibPhqp2flbMurHN81ut/NIeo/u+gcj5keqOQkIpxNE6XQHQJTiflD6S/XBKTu8U6wvXn57pTnjsHozGJB4FYdd9jhxeTbVO/+ixp1MOQRgLW/sf4rHESyafKkFC49+b8MEfLY8wj1QgfN4TB4zrzn7gZjBR+3wlTKRugeJYzGtWuas1lIt+T0+OhzsOY1Jc8UQ8q0VZ+CPUsvBoqHT+UypO+d5p9rZGnwmjy8uMARf6774OdfEYz5RvMjFNmtl4Jx+FG/OUGXW4agr4+ovhsbKKszATf6KUlria5g5NPY0yjIfcACooCUiKdKRVnXRsFDJGPlEeo76kLTDRSXG/6hXGPtK1ZlGv/rKUqr9V/QpouVeNkqursDJ4waS/9JUHLeQl+5snF5npH1xRPTqPLmMkcLUNE9UQEZkyLADKnkvGkEmD+ZnBlMMxNGnaJyA5M92vR9ODl6evDr+Zf/o54MfWt4PP788PIXPn/799PApfEFfGvL55NXLp4enh69ewo/T48Pnzw+O4evT/dP907evEeblq3//0PYObiK4EMXb9R7k+UNsWePev6PxCF5N8Xld/cV37jX3Htwn0G3vLWt1D1wJvGF6kcFmgmwl+qje0q3GmHW4l5IdzHUqb1tRiF05URESsprYpqpE456sVgTacOvHsOCXDzSE8Qt1Zhhh/C21rmdCYHS+zmKQSFlLSzeNdM0wBRPZ2PWImD0nS/+tBwcYl9FH2M+NYxxa17jb641jot4xdhDlCSozbQleVMGEpwhTID+t6iJ8oRKQfNoaWsN7TBer7oh0h/tygcqyygJ5YGEno41wZH9I+tS/PUqjPvh9BHM5Sp4SrUYoR3nh0vFhfBGP+l3f1/zMVXe+2/2bJDvUdKzl+1eqfrkOxXLp3igrDbejDFHtceY+8ol26q16r549Ozp8eeA3p4ejJKf+qwY/Y5WZeZW3j9OLzV0lntNLTzaLuuvlle56CbrrJZh1qZnM5K6X1HbX+zqOdunV7Wl6Go0vFDvsneAvcP3uOLoa/Nmd1+r4prX0MXoH5RwdHPNMhz/w0lx0PPpaXmOzDNTvfmZ/uJ8ZkALsA+WjBqD8ivoz2wasWGYZPkrbyxOWEuVgQJkO+yUmpIhAlPcNeulIlVZElUN97EV0g3Bk15AM0WQFwxSxcMqSNcZ7EPz0e8HlhLfOxmfQXUx2CniNpajlxGWyZ4FV00rVMVFaxyC+y4eEAPOrsMwnTRQESxIQCsZZRplKj9JhRm1992FQ4VBR7VkCCU/42I8/JT0YTqtnaTTue1I5dosgW6PqSREF3Bx2sqhClKiAklB5RXbCU0uS97xu6kDM/Cmg2a4nd6UGzLU8gHkx6V9uy/BH9wmO1h9hoW+BLl9mBuk4ZwlYEYaH92UxUdR5Rygusxf0KXaBAYj2sy3N1wzwRoqruTEXjEKUeyznApE6LZNqZWsX33oRgfAdNcrPIQZpmsXeNS4NFA+dlzBbr8mOAG6szXrRkKwNecqIIdGbFJElSBYFUNBG2W7+VV2Iv/vt/ln8dv+OzrLT1tuxxcDEa8b0KE2ai9JP8XgYXckHVylV57s/xe3X7LsWRGoLdt0yoxHXQvp/U497PbvgAaESutNpQQ32V0AqqX31aFdaIpch0fCoDwtrN+B2qE8s+vIF0VCSkXwu3bfMknwc9Wi2e3YzdVBmcmK0fCTOJ60pbxiUYwKIo80i/JyGB/m+qtV1MuyjtKYrIj1CRoGNYSdkYI9S5rfHcDoIgIOWg8TmSFMzldCx5nJooaW+Db58FYqoNkg7wCrJjQjO2xb0J6N9vo5h9g6TXpKTbQi1Fl8RxuNkTvJHLF8JxVPwQKGPaZ4SBiI9TdhkUvrMp5MrAokV+9Yapd3mVblapLKRouOYzD7w59gJASR6ISSA0o36Lvez+MvX8ZM/Ukcn3BZEJkKGXvNMZyl1ly93k2fiqK5Xtm+rWb/xZwY+nkDhwurqxB7TNAoXhksTl6NazodZkslrfamf/F3vTzEJfEnedzPVuzW7uyOhuyHy58jhXsQwcz+Nm7YMjPbu6rsps4rRbevOiq1qLvFBS9WeygpVbv14OiJP1YQEZf0F9UY+5DOPSRb6koJgoY+pXGEgUqyw9Vl1A9BWaFdWOAYENx8SKLWvhfrlh/0cUb9W3zECczLGCUvazXquv7KQG04rpW4AegWZKU7XThSqmPqJy81eeqEXKWPBsYThYCeJ+a6Ch7tRjmQpVJJ+7aZ6ppDGVNDKdu0e2SYSAhMojwL7pXjKrxpBKHrZSJ4SZWcIVi9miWASNeGv44G7zEhVXJfNtxdsMEY5NcWYlaRFxtRaYRfwrIYz3t9FgZXuiH9mJXZOcsyoBBdooerDzFLvQQ5wVSM2y5CAv03i+Hc63g0dWciG5arK4Mjq9Am7yVXxxkDLKOL9b9yWfrt03pFahblGntH5BYVyTpFf+jJMugutwJCbslaKmBy/pHZlGgB06k0yGl8EXlLAggyt4WDv9i4nwzxZxYuUKCwY9tt8cVbfVlyj1VK2VGsVlBVbfV4gB08z5aDGG8+2udErzjknzNeX23HMGfFG7HkUenFsVnLxQkktAa4Tiz+27QBfYYTZGye1XpmBcsWKpf2U9GbBbOzyOq/BRcAluKHBQGnq+0P2Atc2kRVru0VepbBpZAWFwfLLuHTqvHUOFllxkcGivH62wfLWNlg4Nutg4YVysAhwfbDwx+7B8tZJrYrB8rbS22TBwfK2fLC8tQyWt67B8vbPYWjAUAYlHP+7XeG7XWHZdoXX3w0KX8OgYM2a3Ipaw1baGtQ/+kClD3wY411wGH/7w/0fXrx6efoT+Xx7sH/8g9+y6kWjuC1+8OSPNp2gNFukfRXttGzrhS2z5Omr1y27cO2UnNsEYfnBTfAtD242WuC5k557oztdn0gzDMzt+3fvNhT2jJocKrFDmd1PRIXMXoEPg0wARnZAToNIAA4dgAoJhgI4tQNjsmJMnJwK0EEJKPUOGAjY3EEGbcTkAjwuAZfaKziqT8wkvc/yz9+NAn8/owAekpnWAHpy9rczAzyHbs1pC5i2nrLQDW9c72wdhtsJmAihF/rj0+QyPsmjS2X1gWNKkZCwO24/VX+3Xx8fPDk8OXz18sPLV0eHLw5PRYpoeoWcyOQ8gGCf+CgeXeSDbrgx/6H9t5b9tDukL+jLwNWJ7kbn/8IZPPqWgCH3I1GUDEnVXqqo0galyy2HwHgn1Lg9NL33TARzdRGQ4FN0/bmXcVM6fRvrsfamQoiWWkiDjTVwGZalzUKDEmIellECgDIA8t2Vl0OFnL9JoYB4i40ColBQQIJrFJACR02qoIqYGXKkmvXKTSredXQLy8cwuUxySgCRCBSXlTiCmMvzyZAnPuXuvQqteLSe+uZCYjG1kEboaeAyhZgmarUsE1SaOr01klHuPWVAvrVe+SYJO49YeBV6wUxyo6RvoAXFtGn0OUvSwICUtGhsIVBPEpW1wHWKiCDmVSNGxdI+ZcqtIbSetgXsyy7zDSB191MOxNTXFU4PlTJ6cqgCy1NDddn7U9iTnqozfRidMePSt/Zamd249Itkj/dnsSvNZ1ZSe6IYIdgo/VtamCq6/Ce2OX0tkxPNQsX8xpbqvlJQVl1pZDic8Dzxy5GUR8izzC0cl7KAtDRKXKaQUgFIEKlS+JyH03DZRJZg0BDa3s8E/Pd4nFJHyNE53CISG20uNLewTJkALFTerCYXroLKT/Zae43zyQifNsbNz8wOISwRw1jbgKGxj98YBD/y5nRqbKAORpPLwzy+7MZ7FFsusPXjz9O8uMHC7RLZLRUK/Ja/T3SUzCfbHqVaUKwQENDAAOtY4DoACDcUGaBWWAbcKULbwTk8VjCo0s2nzcbT5MsX8k/387TZ3PsUjb0X4wV9R2rtjtmaEHSNXWgYir/GDjSsA4oT/7Sw0XRvTXuTcZaOi1tcuFIHL9ZpaoCPNURac3Y26f9NNTfCTzT5xkX357z9Vn3Q3v/59BWDvIGCYqPxsa3NVltup2o//1faEI+iT8kFOm991d0wH4TzJMZW6lbcGyi6UpnDmuN0aFeBql4FBf0qsHRtrpzTSt2FuxbqXQsdXQvVroWFroVFrep0Rq3KL0NQr5uq1nRarjWdWrSmU5fWdGrTmr6FhiwZ+PibnboqAtfRL9kqCuudQ57XwsWQGp5ZGKjULERlyiIam6mAyghNZckodOxxJdsK3RvG5/n9MdwVaDv8duKevcuP3RwtACjdf2zjbnE5NENW+UpXGnhK08D67qpVd1PKlYIh/D1NL71okqeXUZ70PNRlB/EYUpB452R99C4jojF/SsjySbqYgyPzIyU0lb/aGp3KC2WAqgDXY1TFsq8QRV/lnY5gLIy2KLUK9WcZAHpls3N6KfbOqCC6Z+gqZv/KBj7rmzmRtXo1xZWKqq300Dq2ZYnsmTGaFVWrnvXozSrU8L6yEanQ4UX8k6atfllsaJ7kw1jm+nL6C1BFlMZ1KmdxULvk3M4vgtZxCcpFVaxVOLKDh/TMDotjvTN/pgi2xTj3Q26/IVyEk5D9HFFuLXG8/xXDhbAilPfo4Bk/O7wsu+r1suyC1yyPr9ylPdvmSLu+1EwloR6NPh8nyi7xgvyybrZCst9hf5sKbHET5dwryXEsjjpZcgiA7o/ZM3CIZ7fUPkkandZGR7vYt6mCBRyMAG0D3NsYsjJoMCGHIQBBB4CO4z6H4GzMTYLEXekMJOIzIVGyhb27xjOM3i47RWVvrThFZVCuMC1aaoOfc9Mo31dv0xjlHm6wxY6RX1HNEDl6TaO0GEhszqdvEsr71sN2c3CvAQqhd99DlbC59GDey5mvArmsjiCjpNcuc2gRxVbevgBGRamVncUDsrSJtfuyGDZ2ySLFLtXgsEs9Huxy5qsvLiuvp+A9URHM0pPiFRGX7GKIS/UaiEv98geQqK4zaFKkqoEMtEYfABKP9mZoP9QpnDSTZ/SAGQrluTKsAl8zkQ6bF0+Wl0rnq2Za2rco7ktOtMTXgzJ3BSj3rVWq5Oi1B0uoer8RRhi1dNMbR2jzR4DnwhUBgTQvBLqUybaJ1d3RH4AvXG6iVirt0XNbZ7Qtg0Bl9kUUYGckmOiN1EuM7lTt77BRtt2dWXmOrhloNYy2HuobPh1c66l1u/fHadT7i+6EvmriMmyd6ja1hBxlVAl1tPM/ELKpWqY5dMmVJlAns1SpxyTRnFJC0HZ5V3A1PbimsPfRyiY56FMkBwMQ5GAauEmOoIwcoV+EnpUcwUzkCGqRI7STI7CSI5DkCAxyBAVyhGXkWPOL0LOSI5yJHGEtcqzZyRFayRFKcoQGOULcJB/nJbnViyeQNN7DV35R9/ej3BXQAf554/ic/IVz6v9ug1fdMf/d3n988uro59MDMxBj9AZEAm773sYNUiv9eZTcQN0GPIOAk6ayCb0VOvvORj0X3GAntLvgPo3GH2Wu9rpOuC5nYcuGWYmT/lt76EagvY9V59xHyz2IrPB6n83pnex+sK0ASt06/ud/RjRXnYgbZ4Un6WUsL9qgeXppIkl2JV7m/fBi//i/D45PD+kNG0cHzw9ePg3gK96KEfD7OAJbafiDF+e9Nly3kcejLCGbEPBKSc85PeW7L8lul8YYyAgEwlAyZCEiLSOTMTlPetEIsnZl0ESuxS0Q15/PG9Kff6to/twVyJ9rMfx5MXw/t0XuaxLM1Wm4rkUA+c7Kc849A8sMqRzNxtd1JmBDDa+hEUYWMpGjsywdkkoepmIeku0wGZ54jcs4Y57KwiP7kUcaGu9KOIo0YxeMEGz9cXQ98iajPBnCW8d412HUyyeQcojg4gxVO1G0ZyuFzK6tgiv2bXUliu1LTps3FkyF5mp1fHC0f3r4y4ElhpzWLhsdV25jl6xdR0QJdpD/6RFH24g3p+ic8ea0WI83Z1WK8eZsJWbkMmgoqPXIRapd14qvnF5WWAl/GeeKne9fTd9etV4iqysjBSAb59TZGOP5IZpRpF3H0K229x9w8QMzaZrn6SU7+XSZF281++Jt0cB4a7MwfvUAeDZ6/g6x76wrf+Ood72HopriuNr++4bAX2qd5yEQ7Cn3Sy6SYkkuyn+cjYYx/dlCp57/lZecV4N7Mtmb/CdNL7ub8oJPfEijv4tHZkdxm0hgcTL2+NXp6asXyubuuO7mDgJXz4kSKvw8COZXxrP2yZPjV0dH3+pUdKPTwj9f9ziUqT30QPQ4b3BGozuyChGYEKEJEZoQaybEmgmxbkKsmxAbJsSGCbFpQmyaEFsmxJYJse0rrg/KQHTMtUMK4QGI76pYYS1JL71h/Iks7GQvGl1B/mIa0Y33b02uiAhpk8X9GvIAcn0AfJxWr+AaBXmPHpMvyqvNSakU4dxUQWPb5IsLPaLTr4IYhRxGZuVSglAo3lNFY6dRDiBP43GPCNfoIlbpgeRAKrWJcBqLa+K8yNvo/IvFpuG98leTXMEt0KL4TvoQTmOgxesIM7wW8iwWySIvYLOQwTZ7DDzk4Rf0nhKxAuhsoZ1zMIYWqqxh4CZzmBD8JkfYb8wj7Dy98u4zHXP5R9iarJ5nG3tcdxu5P0ZbRJ9ONrEdzJybx/iGDLwEzAV0amKdR57c/B2Xbf6OC5u/Y/vmT65URh4KdQUqSUgBYB6H80tRVNwLReQR6XY/9a4HROfBxQKvBgNT0hlchkpKx/QeWGnXUZxdZfYI9b22NBJqucgnoVXSEkto6/PXPKd+8/2c+o84p+YplP8Gp9R6V/5GZ9RGx76fUH+bE+p6Pal3ns2k25JPtPk+wum/xXYVthr1eifhS0466Xsy62sqcoKjWsg28uYpJkdSdAWjz5k/GANSnMLY5qpIqKCcUKFvqzEToYL5CBVU3xcKG48KSgUOSgUqpYICpQILpcJySq35thozUSqcj1KVR+JEiI2rCBU6CBWqhAoLhAothForJ9S6b6sxE6HW5iPUWuXcSyfjfFBBqTUHpdZUSq0VKLVmodR6OaU2fFuNmSi1Ph+l1qulVCWd1h10WlfptF6g07qFThvldNr0bTVmotPGfHTaqBRSyU0loTYchNpQCbVRINSGhVCb5YTa8m01ZiLU5nyE2qyW5p/I1raKVJsOUm2qpNoskGrTQqqtclJt+7YaM5Fqaz5SbVUe/ce4yy2n1JaDUlsqpbYKlNpC+/hJYuTo/K0YH0TTYuTcookpED/QdGvUiDtMGh/ap+ANntqAAgn0NO1fxOPHw0lsAwwl4EkcacExKtiaBHueDvsGCNl+HeMduXEfMlVIkzct192bWBROdGuBKVq+Wakz7USH/23aKmjJJwB+vcP/6vDjGDzujyfDuHsZt4/Fr/azwzcHTzXQG+EX9l+5VnC7f8O580Pe6Cg3KCrlAS9XTfZKecjLw0I5VccxGzV1SxtrxWC/OaXZYbD4aaIVi4hbLHzB68oso4iYtX/iKg60YjBZAnnfXA6B73A98mEm77nczzJ0nZGT5dXZ/8a9HC5mfnU9ej1OySDPUUJkmNK22T5PxwdRb9DIuw8/J+eNvI3WuOzfZEFs+NiRjI1Iv3n37h2s9S5/334e55hECR+04I7wZrtwmbMwG0Ne4bjZFLIFHPmkpNAmm/MOVMx8qO50jGolwgmTjNGWZW4Er8fxAd5XGvfduFTB6K4/U716UtgkUo1dF72KFWu4rmLVsJoyVitEQauDC2mrS8vY3uignLOh76y2GGeDeShcd7s2I4mDMhIHBRIHdhIHLhKH5SRe853VFiNxOA+Ja+7zZqRwWEbhsEDh0E7h0EXhtXIKr/vOaotReG0eCtfdIM5I4rUyEq8VSLxmJ/GahcSGWuOgNXjqKmeD8NWvRlVCf6xSB0V6dXuansKldtJOaVnIit2o8AH5GGfKqc8wjaj7S4b3fmfWg1Bv/zyHzqOTODji4OXb53FEUMYt7zadEK341ruORuxkiZ5LUMphVg+8eR6e4CnTam9INEGK/4Zo1PFoorPe6JRjDBhQ6mAwEZijwii/041F3n2H1sscFNPrUTx+lo4v73RBD6mo9Uiv0wZqq+WH5y/juA861K4BOY4v00/xU8EMSoZm0+T/3BmJLNVnHrUzuNQ9iUafoowdL+qnKQVcdnab/nXFagaTHb521h3J7PmqHGjmpGHtExyDjqJlFlo6T3GsQAWaWk517Ju5Im0XyOBmYpidnjVTwD2uTPym43MQUU0CZ1QwyWZJCKdvZ+dJC2dimJde4fz0Cm30CkvpFRbpFTroZdGO5Ha+5CQRg+yLE1atOzOttBdXuqici1Z458lN3IfD8H4Kq+Ct18M4DeqecZ2M+uk1uH9T/P1HKj3lO+0UleUKTZVKBlUVU0iBrjclIQb0xNF3VCmh5Jv7kDIgdladRdO8qRPFQLNAFXRLlaY3tvAFpUih5I0etqAaiQr0oyYiV2o1PLEtijpeaRY68DrzkF00ssaeniZ7KFfTKT47MWmZQk0GbJCTmdbs9AxK6Rn6rkoz0zNYgJ51d/C1CRqUEDQwCRpYCRo4CBqWEnTNd1WamaDhAgStuV+vTc+whJ6hSc/QSk/LQqTYbEu9QbzX8mIFV/VZyKtVnHkV01td43JE2KdFCVwIAmnLZQUMZRoO1S09BJW6WaG82c4PBUBhilrN4IxqNS+wR7GZu9LAK0nX/dLqs7BHqzgze/RWV/vd9W9H0WXSY27SGGiWEcUiGcZKynnInpR+Ag6CF6bc/5fzS2mKnV8KgMIvtZrBL/UYo8AvcYhRlaTVL6k5M72VurMwWW1sOZMuYY5AHBAARENmeAFTATWlgBqYDmM+jeilLBjxjeWp99uEbLWGtzytauxFlykpwQDWUv6JNtq5J4oV3skqBufkCVOBb4VTJgf/lJuci3qQBUkJKyWqrA6mWRhr6035lnyS5ell8jsGdKJBi154EaisKGA1WVIAUJhSrCyYUzzhq2RPUM2e0K+BZEnsCRZjTzAve8Iy9gRV7AlK2BO42RPgTRpwo8Ozkryvp8fdftqbQMBCuzeOCZ0PhjH8avinxzwQ6vS4neKBK5on8WSUP0fEeLfacdw+OXi9f7x/+ur4A00awaCefuhFSDL3q56KVwngdpbfDuO2jPGl5jXymoT04/Fz/OmoxGIhj+LzvOuvXd345XDHYCmmgHtDSNnhbOhPhCZ7Jq5eOjwhjO6GhbdEV1dEZ3hCVkjwhhXF0IF6tABINyHYax5fqLQ41t6qImqWQjBkzWmenuRjNQaDbCnAfUWshuek5ZjDRT0suMIUEC/i0STJngzTjCKgt8aklxbT+unxdNr6Rb1shGgP477FBs+f4zwQQGLg8ye2q6BFiAWcAvyUEI0SWti9w0NDRV2wsPOoP4CIW0uYHn+lge8AJNpdHp9A6oCuP0qviRDyZxnG+tEFH9DJaBSPfzp9cdTNFxnq+5Xk3efUFaDKuxPBPfpWmtK+62OsH1HSRXEenR2O+vENDygWNdJJDoENQJlRzDNJkeXjY3zbT69H3az78HPWvhqj09zT+DyaDPMGaxGDaWTNqayIGjSozVgVH+OjMcRs2UAneQFykiuA+7VR7tfGiHNJAkW9PPkUwTKotA5FRDLqNpocDJ8cjopQ8EYDDN7I4UBa9fsHQMGjJMtjwr2GLzrlW2jXrKw4yf0iIcuqYZd9nQJl8Iy5xSFRGI41+rZf6Fp1ddnD/UIH7cuTjri5pMWkhEZsiPiFQVNZSecff2RZuDyzwzj5IauTYx2jFXhqaDmyP08RVipNbfZbWTKIKpRm8cnkDH6QoqkY8Z/rCXhDwt+968Zdf8nYhz7E+pJRLmmVGlM5Gz8vtEjNItun9Dx6f9QnynY+Tm8VqlMl42Xaj/nCUixh59nqeDyWQ4oWzjhdXfVqiqGSumWSSM7yei8vkxO1mrA/YwvKpaK1So1J767nmvcYUksbKrRC24JPt6scUp/zFvgpX6IJTjJIydDqdv398Ti9fgqDRZufXFS8hHxz6IHa0qv8fGWv8JooBwmhulnpAFUQVkUKIgUgIw2OfeEVIsWELpWkXg4XIGrTxgbABZvZftAo/ZJ6ho9KvdaIl00VlSSeQdYsJN3KZLfUfOJvKfpKd0vuywyEQtqnxpY7TCO1Xm5gAnfjR76/yyo4dnFIHniKc+GRSbj94ZC7FWmcJxu83tiIUfhl/FlZV227MzbK5Dul/3svGg6Bivow5k/JCwsbwFbGYyDoftBA1C1s1eRunrT+0Iyw6I0/V72COo070Yq0PnSw8Qbw38YMUXaTH2iJujstbGsD8doIJm29bSeCzjao1Soy0aSPHne+Fapkw0nBpJj27/5zZ3Njfc8v1TCxVg19mC1SI77BAGM4m+hkvNRAkKeT3gCjByiWURufxFl7SO8b7wYFMT1tGlz9nW4gTUay5yuButbgWGrLB4YkRhIKua8sDfobUbTi2TrIV5dOJcB1Wc2f9jl0izaqiGZqTmadvjQ1MPtlpGKgj6dahc+zkY1Z68i+nPxNumy87PVTL17pJu0UU+DA0vXlC4GRj07TK3iSiAc0gekenmU1EmbiE82AJj6hHqRUCK4UWoQ5hVaDDfKWDVX1p3QTv+tOOocSrmDDB3PMYYeIt44G27JsdEWlAaHj05isKHF/n17eLLf1bBFiE8WYg5bVVkXbg0iboY6ZvV2xFkxbb3LFlqiL0WIiPbWU5dPTKhgNEfKY6pBf0VJZuMqLzYGgQ/4Li0uBYrg0mqqU2MycKZGpT/gyyALQoG4OO2L3yrH/+OiALx4CnAt5nqvJ5+mRfDsg9evs+sHVjUcAk773z+0O/CHwt1cQVpUQHYaM4Pg8GcV9Ie1MPOD39iy6TIa33cTRJgA5SX6Pu43wx/j+WpNI72fgItcImiu+WIbsDQS7J2QP8jtOsJuTQUTkdNf31klf+F/o1/jiLGqwpHztzkbTgUITcfRHWxoy1MzzCvPkIJlKBeyzVJsss1NXmdTpJRBMrTNNTTkstPzeMI7GkGKLbMAaCkCxwbg901Hy+VAysRkCENXsJShL0Mi40WE3D8rxbp/fuLyIJezzOZlqbL3Yix8YzOiBcgHmA76s78UrK00n0Lv4vWLzt6yLe0ZVh+XCBlA0YAgotrKwZX2eHn0G+Lxbs2N7GDop7GSEb3zLtkfpPZ2qVjfaFt/f4w0jy/JeXt2wnDcsKWlYrjUs7sYrCd8+rfj+lPE/nibZm7evRnSdhgho0oU76qTh0ZoBdC5+aL5R6gx378YP3KUr1pJ/gxpAeOtAS/QOUvjAWWhHSiPJRZSpoG5CqJtUUzfh1M1KqJuYbM/UINfD5O5dsmwz7cCgsAx/FYeBmjkk5oOOkPzbNL3bjZvkdWRSDMEhiYxhaL4yjLPiMC4YZESzYbp+w4Z/Fodmhcmm9AFWxG5G1B4QhKh8GjLQOjKnhp1DWTLIQ6iSHdz04qu8QUU3XsmCa1LhShZ8Sq9koQDySha6osXzrHclRg4TUR1bh6OOZvJgC2bJkrT3FVcOqza+ZyzyLY1N3EY1ptctCLmrTK/lyt29RHHzsPl5PGokbgK3oGXNXROCLBNkDJMysphPya5bat5UG6aTB5IE9MY0GJ8W7NnHhGoiyNrMhka2rTTZBsOdPSG7otw5rgoEmtpmRizX3a+3vCWm9E249MX4QfFLWtoy2soke0UIoSbDtPcBSM4eqlRPtPmpbbMpMw6TRZiBaiPRNZ+wcE+mw+xVkfBhZ69kRnUqdLHpPukrd2ER0wV682xcowex7EE8LZgCQMWYTvfe5IVZ0fUz4TcD5comvOv/87wPf7BANwJDWQB/sEwxBJCC3nocnJ/76NU1MG2Tb/Jy2yT8KO4f85bY6p2l/duirU1RPq2dr73RKIxQeuRR3I3qGNQSfKN9XYFLc7uxspSU7O7y9Kqb20GF0O3sWWesVABXTdS9cTocVqiGrcyp+9nxVSiFe8lDGtNF7adM/Wy4KdSIVxvJaqFOs2mSg0xXDTV9nws3ULSRrzay1WIdC264rS2uMXwN270YqRYzLx2WMND8FvimAPdGsBfJ2jlGtvNRddY+noxg/L0aESExTpM+6dSoy8HIxwUsdM3WiKgWhy9f/3wKC5XLjcecEgQuuojftOjn2yaYgkua3T8bMgM1tPmsTX7HT+DBYyBX9vOVglsxnpW9sfyFytvY6kB+g3tPcwY5QCvxBUbY9iicujtgTYtZ0758UU0UDnlCp93ruE1KTlnJYyLK/5PAYgRqcvKgw/Yce8oyxf25vo1gyJYtGEZLFgzZjILhRZQP2nBHdacVm/PYKSJGM4oI5SVEWIzqCYs5Vgiycd/AjfYGg1HNJswr+ncmf8afsxyvwj755fkgjvpC3DAV9N6D7NOF591cDkdZ1x/k+dXu/fvX19ft67V2Or64H3Y6nfsExKfbsK5/byVeued7g5iedbGfkJvicXrT9TtexwvCbQ/+8R/eEwqIw+6ZdbMV/0Ge5MP4ob+SkO/32Q9CGFZ+7wGpkD18cJ4MIXlG0u/6RH3w4GW+dwv/krL4eTTJsiQaPR5O4OKDrk9Ts6BjedLzvSwnKtOnJKIW3ND37j98cJ+iJF/wDffIqoDvu4BQplFGlLfLro9fh3AG1GmRTjXJ27TyrBeRPVnQWg1I0T2iBkqCP0vTXIn4IZ27eEj/Eoo+9DkkkWOHRMKfAk7UKHrypkloTAqG2hx62t4grzCqnYx7T4iiqNS4iiA9TNe/9La9cN07Ih/rHfJBvvPPjU3ySX7wT3xOfvBPrEZ+8M9tWo19kP897z++R8g3JHrbeuf8fL0DJB6nH+Oufwa3rfCfq2zcbIsH4FRKlMKuj6c4/n3Zo35MBmVc1algw8NWwZcjL9jxwh38ub4GPze8DXhMnmFfyEP8Tf7BcujTDv2N1dfXERl5FmwrXYIOzd8l2SPsCw5E7A7TWlujVtQatlI6CQfdcVufnancepA5MOgO3GNys7W6CeNuJVrB4UXmTcLqjNvWgdVsQeFQgPFqmVlN8IBIQlFmYRFFiH3gA7414ATA+Qfgsu9igzpuO8mj8TukwzDorMkvQWcLvoX45XfOtyEIpYtxdIsPcjiEmYyHDbLlaOKEV5AKrPIzCNZ8z0N5TkQMQbgLW/w9xuRdgXxPGwe761c3e+pA+N80Ge3iQNjThwd7aGkbmQPzdpkM1fPzeAe7h3ef3gRdf5105JZ8hutETobsN/kkNeWY/me8Bn/MUR26RvU3fsOW8Yatpb8hCOkbNgL6BkJk+gp4sNQ3bO0Yb4AHS30DUkV7xcJ00objFoy9tXVvkwnTbfjc6tDnQafj7azxEYl2MfnmZ8/gbLf+m42ZZO91xxgcX6XXs4sIXCYWFQ9EGDSFEgHHx0S1uYgXkaEvgHO4HAb4Sf7dCL19b6MD/9M/AX145OE3BN6Rnwi+1oH/CSj5AxjJw//4GjGkiISfq1xx6bTX7VLvAYYR3jDx0fVX1zp8FLEV16FoibeS/dWud5YO+4RFcNxOoFchgv58b44GPQzCNaKAkjZp8vibkY/JcjGc6NjylVFZpylEl9kGRQ0Unq2wvUF0NfnyjvPl47ivv3jW9y6FBF9jOn3NUaaNGTFtj6NrzEq3mN5D1HAqXbfkF6YEbM6k99ybHa9tWBoawBYTwWzhwd/1JbC+1m/quPD3nLgChmtdLA2sYfBgTlybHQPXZmduXNA3DRc8qIdrAR7ivJpvWpnL4o63E+Ab1+UX+It7MfhiDp+zEP6IWf3PzXP4M2MDCuNuJzDHncpf+o66447jkuOuLi4555+ko/PkYjJebKXeZqpV0Am9bZS3wRqQeZ+I8wAVrfUNlLbe9qa3BeRfIyMAy8mONoDSAErJozUYDQSEAFqqE5yA+gjeAi9bcCW/92fsxMU4vv16utnT5CLJoyFLAbHwHncdKUZ7T79s71Clk3zOKemrsZapH/PICb7Uhjt0qd0I515q1zvupdaTbNgfXUyG0XhuJbmXjHvD2PN6pNWbZNr3buknoex6ZwayV+AptSStl+7mAQvd47ElDR+Qz531Crwgo+rsIpFb5HObvWBtu7hNXcoL1o0XrG8v6QU723oPQKIvtQf8BevGCxbtgcuut97aXC/YmseQAyVurG7Ry7B9dV0GkXhE/sI8Xw35r9UNc5bTWV0yxcOSKX7/Ibdhywl40E/yhTXd9W1cL7blF9zDkBLyOYd9b3uL7tm3NugOZHPLW4OFZjP0NuH5zhpsXMjCEYIJmG5Rwp35Neqq9i9bzi6jp2qbMBNGaYvC8hapEnk4XGw8bHaQgkfeOlEP6AHGFmws1xh5w21YwI4Abg0+d0L4zfqIZAeLVQeekOrk/zn5+lXaoY+EOF7vrEnVeCfYDjvBbGNBEv50HGULGtvX1miXyJDaWedaPg6jDSioPRMdYo0IrgCiBRxyLbDItdX1DsoysmtH2cY+8OkcgmF1h0rIHdpP8bEhxXgZMjLQhQSckXA647fhz0Ii4Mi0xW+HbEfEFtcwEC+d5T3qSYX6Gq6G8NdwLWTJr9ne1F+z3Vnma77ZuFw2t2uO4OVY0ujpuLnQn0Sf4sWkSwjOAWQfB4euzGi4Cf8zqwXu8WQZQAfswFp+QYG8s6V8wSK0QpBvOnYCA2jpikzeYRavo8Ceb3X483ZGG3trG9trfWna/WcYbp73tucefdh82vrNDWjBhrchDc9bHSrxtjp6EWzaNzfYURGpX5whW/BHtrK3CX9m00wVYbyJW13SlI78st3R6AWmB+b9QD7VElJ7G+ew3sR4A/4s0EQg5Dju4f54cwv3x7A9YfuEYJ171XhE2G3DrsEr5+TMDdCnMr0xZbEJvU0H/CYf00GIs+B3z2VNqjpMDzru9tMpueueka7WGGPt2f7BllSyzN81GmJq4LVeWymPq4aOY+laJVtF8rfpUXNKp02GcZv8lBDhZqcVBhv68vXXkF4anRZcN7+S5DJG0xw76q8stxZs4KJSa8HXU03bf5qO7kFOM3BihlTOGRFgbV/Is2wUXWWDdHE7xBru38iXrW1C203yh42Q0NtepztB+rkN2j0ZKG2y715rhxv8eHVjHUfKESCAL/u0FOE4zDZuDWCfyLDB6CdftDfCDCI4cBeJ+0utkFQIYRSQdoWbehF2AkbBfJaMvxEFtHG41YE/Uuqvb8KfGaXJE2rkRRvvBrXxbmygjTfc9M2Rv72zEe9sVrxxs+7mHuLnDPW7Fc2sgAdtQpztNgqQrXZAFq32GiXi9k4btzHbbeDfZjukS9o2SCFStiYeko1Se5uDb3cIrs118ZhU3+EVwpAjIa/a8ChyfBzMOz7/TO0vmPTOzyWvO531aDuc0ZBD+Mm5/SL9FJ+mmA1nPp5zkY0OYmSUhkJkE4kt3LfD9boWFI4v7Jj4thfCt7GJ+OB0nC8pmwrCnc3ZTTww+9ERhXziUrmxKT534HN7m7J8Y5Pa7cjnRjjTLrA+dZc+SmbgxNd7904115b/8mVw+BtMWoiFWXDOLnvSBp0lz9rgK8zanU3K0x3Gy61QfO4whRd5Sn4jT7fCuWftHzlta/DiK778D563c/P4q85bevXLorqViKshn1tM6PBP6h+1FcovWyHTesWXDUYI/hmuK7E4IMA259aavnrDHPt2k9CvPs5H5J6iduuuFRuods/qpOFAxHwwOp2zsHPum15v9OhvHQ5c8chvM6SHqTvUqLFDVU16Fug4XjXp8SxKhnH/r0CT8/OgE8Q6TdbXvJ0dqiBvodK8QX/Dpo/GB+xw1bpDo6/I03CbqdQ7NDorZAepLDyL1YAn2+C5XI+OT9NR/t+j9PovQcngLCJLgOIrtbZhuiVjN2fxldrZNH2lHglPKYVOyeg8/QvQ6Gnav4jHj4eTWCXTRucrkCmxkelJOoyulrDZNsSuKVSXJM0taGuI4v1+/0U0/hiPeS/LencnkP/7fomzG/KxY1pCsHu3MdzEtucMouz6fdKecdzX/AjXqcKyuj6/y/5mwWX/3ooeBs/GgF8kzmy2RCSN8BjDg+sAe6ieY0NgdLHLNSNLdXVqsyPlK37ZRku9MQDYO+gQEJrgOtNCpSYIDeSK4FpoOcB5ixys03jVbnUwjrIYoiGG6cXFXBS1HsmvbfAjede5yMZmK1zXDz3g6IHFU26DIROX63U86wAzYoihKR14uNNhUDvovoNnFtzXJ6AHJ+vwP41l2cRIaVNNpUk/DbpvbyPdQc3nDoIK3cOwEJQj6U0D6yzIdjq1kJ2BQLVg+4b0KZyIFZwni56xjoBAm4fCOM7i/Jckvn6djvNF5m7AozU2mBcKfRBSi09lm61RphxTOBsilTt4xoPqEv+kbmYhs9qH7CiSfIbbTDCIL/RwL2AWEdTJtm3q1fws0QfTVpvoh1tt0Jbh+LCz1cb9Alhwg2Adn29tt8HhP2R2WSzqrKFFF0AgwITA4S9AtB20aawLGH03N6mltkM+NgPAsL4DXzH6f4NsKymakODcBvPtf7zSvtLBSDpgW9pgno1peJI2wzd7ve2tM8uc8tRDva02HJ204TglxHAdekyxvgmd72y3mUZscRTdjvubO9vFRnplrQw2LQpARRs34fR239vYgQ3O6jo7fiFbmo4/z5R1pnrwtPjaNdgh7KORLvBWA3p+swMeq8t8q+6c+hQTGHxf3Ze0utO0UvNoypV65Hpo6pE0LNWtQLKRwaUv8gmV0VvmvkjdIwHvLXNgXBg/MlzDDw6My8F/y9vP3S9pxEHIXrQU/Nh+DT+2fzH8+t48p//PPUiE8ZJqO2uK8XJbDupg2yr21KOm9cXq73Tmqq8S4yi9eJYM5/Ci1IXPup79YI27yK5r/hdlLhfbVzdGXOWagXRjU0NaE6dnD10SSTzWl4CUi16OdHt7CUhZQ9c7OknXO0sgKUfKScqQzknSQEe601kC0h2jpUGwDKwM6camTlNqMVqQphwppylDuhhNOdLtZSBlDd0K9d5vhUvoPUe6oSOdr6EbmzpSekK1KFYeLbCtd397ewnd50g58xnSxZjPkW6FS0C6ta0jDTrzN/UeT+r3wkzqBykmG3gJwLj9gaYb7NJ7KZQ0wJ/iPXl5yentFdwoFNMrfbrbPxYyId4POg8fAgRb2DZ/LOYxFDCYXDEoQQJ5EcMyDJjur+uzhdFvyY5A219DtnN41mM5lbuinGJjuZafJp9UqOIFKn6PrKrjBO6TtMPRW1SCzo9n7QtIJhoN4cmTND4v5Gy0YIBrKc+HcFNKNMlT84oIAg8DQ0uZjWnWIOilwUvf5e+bU9k9ylsl2R8Ci7z9ritsXh8f+DSne87adklU9GR0ShiBN71oTx+neZ5esgJxf2w31rqoJUtt7qlFmKeavRvTjz8M4rW9pgqi3vehPj+HfJX4WHTyKuqfwFVk1ByNubNjRrMH+V4zhnauxHviMgyeNpD0/5SzKBbaVEwYmT8jk+FtHI0bOhdX/ZVxW7yugaAvSMsGpDBQQVthARqBn+KlYCagVwT8iYy7rAi5W4R8kYwmeVwJS4FPYkLIPgFeYXWHwyTjz+4TJsirgNaarU1B4mFKSdQmX16+Oj0hLNHIB5MO+kY7E6v1EBzrstF8NckGbHqqwxuGwN274mF2NUx6kDzTAFuFRsrpzpOeynkRg9h7wSp1371HERjlpgwcJDRPpIlIikTlrgHpMDyf5AyE5NyplpzbNeTecXQN4zdaUPBBryYZXtfuEgxPD3/xmzpsycVWNjgU9mftf2MrXtMrD22ysVARb06cqyajJGHSyen+6c8nR4cvD346OHz+02lNOV3AeEYl3jyNYbc8nvJUv2i0aWzM2xKGDtzFiCZTAcWulnSC8QXoDVuBZsBlyPmGVpOOmHiUpeMM8mzXGF4SuGJ8FQBrD7BCzTEfJrQISnBKFnmzsv2j8YZmvVeAJuOHzmLOgLcqAwpQcjwTdC9wCa47fIpktY4fF5g5gApw7NY6TpxDEDKP8ZkD3riIUa+oF7qGmUSKQyfFmyJqjjMFuHycFQGpBK8zWqysKCKsLeCKVXFYdZzF8w8YC31sA8YJZgyYIlzxmsNcJBrOXZJFQdPEVPP5nnj64vClk+30qgKF8QS4DVnFu34yuprkvl7SG8S9j3EfbhfSnuu39JCqION8G1bEcJbe+DYEBecDf6XAFI0nTSsaqoNTQs+xokh0lpsQBtHogvQMLxaEq23ZbUrTwtwxeUPwUc4ke4mTHSev919Cqmllz+AfjnrDST/2LpNRcjm59D5Fw0mc+Y73wY2WTvSPj31XO1VJsf/L8/oDhgA7BgyUiAHT0Z9XDRiJ1TJgJIKFBoxEs5QBA+iWOWAIPjIS5hoqEVk0o4v4GwyVF/tvZpAt+29csoWUWGULeV4pWwRWm2wRCBaTLQLNcmQLQbdU2bL/Zt6hchnd1JMq9oKy4TNXHXZPitMM4zf3suId8j1SGI/9PXp/D17SRRjMKGij6J5ufhm12Rvo+yOBIr65SuEOd4aB/rQgiAQCR6czLIAtqdh5VqpiKnS5LmaBrKv0W6rWVrssdfFOp1KtamWj1k7BgpvtMRvrJoKVufexNhLb1Dk3nKHPWQBte8ja+Cy6nlpXjJPTWhdwq8DVI0oFMyyxNhAccULnNkv50W6n8y9ruaawm4Vn3J7qKBeWZsH1Z+yJi+mnhXu7yY4K3ZPBpo1fSmDlHd8lDeImcukjW2S9KkNUNEWLdUuVX8IvT7/M8917w0L+RtmKqVZy9fm7/L1ybWQWf/kSUxOkAYQW6iwexnjBafFdcfHmSjhi38sfdo2NbuGmxkeNysVrVKlmjHTdYqQqFCOXFjEqqA6jBfSF0RKUhNFsmkGir2Nw1VKlGqDdtFkwLqmliQleunY3dwkfnbwmQ4hwMdHv4CTN1Z4E75uSc2jtFiOO2cVhJBKQpN+Fr2Ck/zCIxv1rsj0+7JNpkqnnLRzifJyQLgxv4Y6+BtyHPm7sVQ3Kh2JANw1Q4+hFLRr+/+y9e3vbNrI4/P9+CkXn2VSMaUWS4zS1TPtxbCfxr7n4sZ1eNq+PS0uQxY1E+pBUHDfR+ezvDG4EQICknKTd3dNeEhEYDK4zmBkMBqE4fAH8J2ye5Lulam++9HDmbRx9xFfuoez8+izJ5CkNf36anzd08I/u27P9Tv8HGt207xWPIAF955AlzjwIWtD7ZONBh/wdwPy8+UFPvspBT970oCdvfNCTr3LQk+sHPflKBz3mnNYeHJ69ONw7aFeJ52dP3xz82q6i3LOTSg5Is0OVI8+BI88LjjwHjhwK+pmfd0eLlL56K06M2MHmUNvHrM/pahAGGRQZGhEo6fqBp+/Mi5gUPkPOneAfU/xjAX2yGaPu3+/M0L6wgE5ajQ/0ka0SgKJyAkAiAXKTPeYGh6VtG1fMd9tUDsaeXw2PTF+Dr5rIGlRjjf/NbfwPYEDEARkmLt5WhPHFdLsNuv1fkx7+2y4gqBj0UtUxVMu2Dnai6RNuODwBskGVRhOPIVcYhjZwhi9q+vTz5wTfJq+Erx0zRV+lGla7NO2eP12xZ3sfrqw9m9U2V+neH9S3ZNVZCz9a+wazsVL3vnnPKEe4CgSVPlj4IyDbKl4MdLkT9O7fH22r/Pgdpp93cWvErR2GaxRU5LN6r4Oev0eP2BkTH+0A3uvttAsM7mTv54O9s72TNz+fDtk+NaeSwV6ahredK8+/Udp5Cr9Pi3aeCil+AswXH9AN351io+nhPoHfSqtOlVYFwYiVuwV8SKjzd7drpw8W5wEtNI9ipRC1Oqnb9S2y4GmplF6VvVRSriv8WFtqgowfAdbXl7yH9+9XdG/nBqq5CSogvCUM0L2JYxDabUsfRWJiSVwiuiuc1MUODP5epRQwZBPpBAFBZHiq0FjatcuRI5R+Xiao98jhOm3GP09LLP06CHq7FtAt6OFpLR3uOSA61/f7HmLm15W31CIqgZ4Wu+kEl/v2XCzxCQxv9WD56mDN303OZYPLbMEyPpO/L5r0XeFVnQmIz41KqRaGeRIn2XU4Ipa+6/rbnudfr60tR8ENLqs95tTj6axqryz7Ua6lpiNXUlv/VHf/UNo8pJ3pWH1GSpP+7Ble7TS9LJQ94XVC3Xqon1Hst5g61QpBWCQgdLZgo/dbsCe2krQF20eLG2JbEWg7U9LKk+t1Olstoe+TrO1tXf+BLUxi0mIKo2gU6B2Qf5nQwItbjZohhtl0Byiz/V1nO8+mJCMt0JpZI7Bt7bVrTcljHUmTm6zb3vpKiFqttxmDZLb01gSIboGFkxaNQQk5N9NkRvgoklwJRwkA+x8yzBBXOBiXjWEP1PSfMSzkcbGXjQv9p+cN8/v347U1fKgX/8roX0zhAG2jjcwwQ2bYrsL2iW/578bnSk8RdSdZC9rD9trVWrsDm53HXw5WUsMPVx5/GFiFDT9C6nIWJGu//X/p334bsjeMpVARgwL0ejG/JGn3+M3p0dnRT4cXR6+fHb0+Ovu1st/QxG3aTl3rw/1ETX6HgJrwsQgq8rnKuNh2tomN0Rj3sav6lqPENCpaPhJjfI3SR/huhH0YlfvQUVPfIZwqiSzwWXmUOtkwU9hCABlZhAI2WSq8jrsMn5n4pdBhh79mAsfoHDd8d8cq+rV9BVXi2nNCYDWfP8uut4atdtEx9pWpX95yigIGSOcugWDhraHetRaM2eqExXi15HakmSBPcTrGrdGujTXER+jxImQebuE2+nCUfRiOpmEKxB4s8sn6Ex/GMh7BPvP25AgYokL2qgnN6ppitQBYtX6Q2wlawPZy6OLlIied9jQlk7afe76ZAbw2niXhuO230/AGW9KFRrcpoG5Ypndqfdn1y2R8q23ABMuMZtHoPerhGphqT6FOumGueOmGeXGoFvR7PUww/KyCAUvWtwABbJ6QATStQTPpoy/wM8J8gT+NYOvM08UoT/iVXu9TPo2y7gWJ0WZDvTpYgvQEFgmj8JodKrWNBMK/Q1Zlzs97S4bxIdrlk0kruhe0YX8jExiHcRvWaBag3wLFAWPz3rnK9toqmLJhae1RQdhMAkVluNNfJxE9Uy5DGIcIl7Nk9F4cPWvW/qxs3Q9ViA0LxFCpLg8vj6DrH4NeuRH8tDCIqdFU+7MMzM4jgpDma3+WYeVhGBV3WKwNyyC4BfYSqCKpasdzLM0Oz6+NPLaN4R2mrMIJU4EtH7zMk0VG8OiTn71oyx83l9phYcoJntQ0qGiR37keMfy1NVHeY69GpUxaZS2y9+T2OiVZ1vZnllbPupAfBO1DOiufP4tv2HHslS1RAhQULC+cFC1YZighcqpA07uNWMhyAiwh62i5PIlWwJmVWQFPpnUIEFmFYHDEzQ40QLRPsb2AVsnHxKySJ9MqBYiokn3jRnBNUjyH3GND5TWYNdQ9TqewF48WedEHXgIEA3plwye7Jn98cfbqZdDeXuy01zQu2c0Wl1wQwBMkjOxUBdP3tuo571J28BO5F9gXvNhntFEvJnq3t7Xe9zXQ3c5duENzXjZiAOwSOmhrDXCRHv5bwbZgcwsXs9xd23/t9fBflNOW/gcib+rgynr+9gi3S3Nl8eSltoXzhcA2ytfJDZ6q0BR23bDHtxn0xJAfxgVHmsZcOR4JEO5LvSG+o+xVMg5nEjtbjSFewRHyASbhEVoYSUacaZkvSIgMWyTxWz1ou2QcnA/WSARvl5BTWvDpFR99Dsf8R34k5Hof1PBUdES4YRywGXjm9CJxgtfta9hAIIn9cDZDZZ2aW1iOVYM3lx4HKnmE6/uy5gsVDNREZafjFbTEaiqDlduyh/+2HQjVBnFmYK9ULc8mtlxVr/f9YBS2y6DaPmrBVB4bDZWghLKEWcbFrpKpEtrAdm+1XFAuHBBYGtTTZOGA3pED7YJM7nNJmJiSsKv90GhS3UZijA1sMrBQY9JRb+nBtAVvLv8JugFu2xnbWqS+HoG+Hm1Lp6IItNn8XXQObeQtb1PlHNPOKXdnP0sIlL6quIhMpFYbFQzQeIU7xNI/JubVReSLwF1wz3lF4sVTkuX/iKjIwBwsWB97Q7KddpmPleofRaB6en+xyHpHzgVXAxWe1b3eF43ok821wQMLKiv3vRhHHxQ2cEFZGz2LVRJpVQfRh9NpRGZjNSe7ifLR9DQakwMdDx8dyVXVvOswDedZgIonnWVfa6wcYSHsNfRQJcVOwqUQ4HLJiDp2UKnHuFBp7lGiGgprcGgTlvXA5ONUcDJLyoG2l5HChKheXmzVkw2fUw2l7nxaVVtJe2EjA5J+XjU0sEaWcsGVstiN2t17/S2ZZMiisPEJwZC3i2OrEoCbYjYlZC5HMjdFVpBdHqZyqL7w+Vgbq8V31SbNBzpBGFOmZ5ZQcPSXMAv5WfIsTVC5cHFVbdA04ScYyAqLhjJRiJRnuegcnpfKYvzAhY37kBFzxzZRjs7VkGTFeBR+vhP0ampXwSqevBVQhcduBRDzJa8F0xx8q+BMwSG9ugw7g81NX/zf6z7Z9FpVJjgbek9Zg43G2LJWmenPuYC8T6MwI61eibRsHtgmDJ0RDTWmOEwjRTGcIq0UJNQWYmtaK0aTagtyRUArydJKVq5LGNn3Qzog/bsPSHsTncltnXbk2APa9v7ut/BP708fi0HFWGhka/bW1oRUuUlg5gl62/ySBcBavizjpiK5ZcfUTG5KAYOobSWNk04NpFAwLRz6MvnIlc92CyNWi/9RYaDMg75BDGwD3ylmDhQkcO/2Q8nNlcqZhA07oa2gKpuvbTyoQF3tSEq5D62+ikyc/KL6Mk/uYhjNiqXlxd6soI1MysPmLO5eaqp26OfNF5pVP5UIFFO2s6yqyWl2HGeJch1UUauswXq3xX0jXV7RRzUab6/QiLU3aXiNeQ2sxLr0JO3ChfZSc+vAAC9ZBcX+hACGy61R1NOJX5qA+J2TOvqpIJ7IIrNEJWEn0rikYiyoo/3N8lFG9GVkEJUuZ6HgXaSX10GkHipFLgtp9KX0Ein25N+7xROLzTuov42wj8sRXUTobFN9pcU0WHahpX79co3EDl0cY2QAn2nHFlwlkOXNCzLLRhqDrrY3ETC1ErWCkQ36ayxQN/bUtJXVY69DedfNwInQpIuKkS1zTCesqffYYByHDjbQu29KFpQq2RnP5n0x7aF3QouMozxJW0ncQhGjleG42pdsA6IsClhIy4JT1dKM2yRLUy7TjYroOuuwkzUhRrNQLT06CnCxu5pqnLeiK1E3oce7YS65uhoXPyuGnd4FdSAvz7WOAu/uyVv5jmm3Yq6ZNBH6Z7Cpy+LcGO4aHLt9b03z53BgXFoti+7FY7vJv4psbUOyuoRuw4KsjzQD/dqGU3stLr5df7feCidlb2pA7VTD6GKo/SixZBh018v1ipqabdqH81zSK+vJ5qnrrsvs7VKsyr4zZtH6/cx23CgP0+0tUQ74uNbe4v957WbtaLsG3y4lFLzGaJdXa1qEot6Sx880LL8WA4XVfvgF9m6KxqIkKcfQ91QzvAOGnQh5zOUGda/SwQo7lCemamc01qbyEW+p65P82HG9X4rwWz6fY1F+lcO5/DygiwwPHIOcmkjudch2z8PopUp5HjGV+H3nAdjdqu/+zjSqfElH63fDPalq8nnJTr8H//TXBg+Idnt5hZMBEyE9lNSw4WQqAtcnq0kVyGS34zC2VhgZ2w2l0eLldf2UvW4nbiaSsrsdTCaV/MTsRhNDaWOh+lv0QhGs0Qv4mCirTfjonpXi9YbZe/NSBI+1G5uxdmNVNZxHWi8e9awuDwpEBnIy4SgedH/w8PbyVPGcMBD2HzdEyHA86H5PMUonoh5G1VA8gvr8u+w+1DdiN/2K8ax4yAwRS4VxZT+XHLBDnRxnstDrxFUmEmUiWgaGVXNRCLHVWsrMKwcf5tfHk4qww9O6KD7DqSWkDkW7qA4RMK6+GMgPg8cm9ra4lstJQHsVVpnHJzVB3n2YS+W5S89frHBL/qBdXE/XhL4B1cTHzXyNx6vHC7LcA/7nIsujyW1bv2tf7s5US1h4fqIlTJX1UQT54QnLpX+Rcj98NbY2jRLCDJ2cvCOTvKPVyVulaTSRrU7PGhHTWHMFAUcGAUeVBJxJWnzzI6fFg9wgxiUacjViA7GsgBLUxgNJxIGCwCS3sJbcQhe5zarJLWlEbkmZ3BKF3Ig/0xZNUofXT9xUkjSjkmR1KkkqqCRRjf3l7oRawswMhhGqEyvIpEgBOjkQeyFUAMWy1oX+kEfxdEG2uEYzACb+3lUeCf8SJoY3dfxJdqcm8Hfbv7R6KhEsIikRqG5nXMwDYWSEnn79YXUYfg247MqYdk8On/18dPDigQq4o7IPIZ4KJGreQ1neY6h4rD4bMsZJHNhY5kMFh+dbDN725nrFUwImrKU99I6Xxr6Ii31x4dF8boCf66qZJS7kPra6Vg+tikj5+llU8RbJI63x+jHRRHEBtUEpl3pf4KuFfuuGzEbJnF7O/TWB9bT+U5Qtwln0e0gvT7VupmHeukkWs3HrNlm0ZtF7CjtOdpWTs1KYztIZSk3QT8GIqyxnWck4nzVjdrIg3h94GUI3culrYbMyqVthT18pJa5oNT99AQLjiYSNFYs/LVmf+5sNMWjRGzPdkmqk6hEStQtxlXXxrboyvEVmi8UUVu+z5nZSt3WXy8yE0L5CmcTjF7hX6M/Uq5PiD6j0r0uVdfGoymXGImLNCmWuypGxhuzedhXjGlVQ7Mhy2j6yuQOO7E8rqVn6ArcV46bfgZpTXDR8UkMGI4U3XoLgCQPwE/B85IEj/a7OVUpuixrKUUL0QRyJGD6d/sDdhqFybecpFXo7od+G3WMSXWHohKtZchnOWtTuQIDBgtr7e1dmUxHjWhUcPOUILoHGMNDCq0OraQY10e9W2MItjdlgr8IFBqT8vXuKn8/xy1nP+y6UoyA/R+MrkjsqSoyKrtLweopVPMcfNdgRpBL7wm8/h5Eu3gX6vQu/8e58/fhwQAfmsdHucXQV5TAd3CCLNR2wpAOWUt0VHbayT1dGzWF8tZiBKCgnZ48lNJgeFbKoUzdi6xoYf+lJy+Jvq2mNlDYp4jTos9t08i69RWAgthflqkmW2FnDhppnv+tMaq8FEtcpP6m+QzxZxOISJ6m+MLz0KnDhNeEmqER7l17N3hrS7Yufhixy+t4VP46IFV00WmtvX6Z48dMepZYd72c0FG/hZWQDpddxMSgfXYH1Y+HEUVyZdiKRg2DFUrj+hIAkNFx/Mkp5xJA6lirTBMVOrHuNV3zC+AwsfTlcREITCTZ7Pf7JwzBsPO5RBe731B52QdDYNJ/PaAAmdimM2anpm8byDCZNElSxLfDLDLCx2BJZcTKhgVSFczbBeSzRLkzPvJN79FLLKdYw5lUYV0uKkvQCCrbTBMG0ZRHQukjUD6swRQmAvPTfVA8bzicfHuT7eEbjv7UV4fAzZmRfRtlRjL9xsCzuDjPjRAhj4rFTKJqFh0JQM7/nca/HjT33+ssJcMqvgbOlpWPXhEEJR2sZxRlRYwobN+7UqiJLVRGr6pOWwsaPV7Ms8NC1gPvPGzbwOCuH3BrxqZhROvPXYUyUK020rfSC/EfIGSs35O/1lnv8Cg2qyWkyw0UFmIm0c0hjy2H0qeJak/5YYfPLSzQaFVRh4sM0diqKmZKWcmYE1upkJ6RKMcQ5JbPrEn1A2pnASwEKGuVZEjcmHOMwKpzZwAJs7oywtZvCdprl0ZiHuKpzLy/7lqdkBsr+B8W33Ih/sk4DoAwN33PuIGdEK0H5u6X8b3qQ687KTknB8gSrhqy0B9yiOeMG9mfGTHbNWMRbxRG/xTmJv9vkDjXzev/FmxNqp1FMKO/Wzle2dDBn6aEaw7x9nCxITgNjs5nUzodtKllcM8eC9iqmOq6Z6rh8MBzXTnVsmerYMZOxayZnWBhUg1spmrBRyhaXLcL6mbnmOa6e5xgkhCU7hj3K9pk3hBI9g2ZQV+Yx+khclvwobBDARy4JD88k3RzKL5w+wtDreTD4nj4RsIgOjo+ehbgtyYvO2zl3b/DJTqn8er9Hc20ZUGCp73PUBC2dC6YJNo9ZLIsbw7a+KPkg+OJrdIcARcYo75wyQUTBwN4ssJS9ACZIw6LZ8nK25FMQpdI8Ihk/Fm/7BjN0gphNoofmuDm9TStN3wNfu/ekTJp6zxlPs0gpqEMulEVz8eQe7FelC8hp9wV0Q14IMt6ykW/YFgPisCv7xmKutjAbm0cjt9diq6lzWTQhG70+ZC/a8CVZe+FmTxfZy3Jzpjo9DUu6vBAdcGfGlT0TrPTmqWugaoJalQqs8rSoHUWjWF62Qg3PEe0ItKg7DpjSlXGbnITnGtdMCO22DpnHTZS1MLQfkl7rGoO0ktZNGOVd+Keti3PmrX2L65+stESd5bnNRiDVzto1gL9Qt8QxiV2AK80q70lZDwYhHeZDdc5noCc0fUytQUbKpyp+Y3i82YG6yWQCEi+jNYxdG8XsN6gspyCRw5zghIkN1jXlis+ac1WozpW8MaWgQEI8aNBYfNPI0do1lYHUNP2e6u1bu6Id7Vbr8yoMc+bG5vnWeeY2v+doUEmukUiomcm3GQEtKp2xSE2VnqtefFwccoQmVzlgFCMA//U0xAmTXS8EG30tlkSMZCLCFylluihmsMFkCcKQ6cflCoqYIrrQE7kknsy3N0UTZbivA/1tdLGQdViEno5o2lJJk5bXCpEu4xpD+wyv1MF/GH/5mjXoljen29qn3WqF8W1xyEAPfG9CECBaoKi3WM8zGgca2OIsImMMcA2yxayVR3PSbVO/XHUNiCgY4uYOrn8YDSsLtol1XcVGw9eKFYybXLh9w7Gc+CjRNsTCxiFaVrlMafT06pWKNitBTGLyXMCqoc5k+EX8dXEjpsibRCl/dWfomXlqZFkzT3mshx6myumoG3IRTc6hCtTOBz+HrRyMkllRGimToDdMtmfCiJVII6Vdt5u9S87FOVotPyGzjHxirWMHOiaDpjPoU7WljZPb9tsn7C/8asUJXiNoo+sYRTAl6NYU0nXAhA7a6xpVCgr+jga10KsiAWnnq1rbUDcyk5fhJaFh+cIus7eFPGZv2AUeNCJZ9prcoDbUoUWETQ4glk3Wd5jSLORFNWucG3FxxwHeISiC0R7uKcy2zu3oakQGlyAGZZ6ikINaGbCeOD9BBihMHb9tFyz2WZLOd/62TS2LsK+1Pgbf/bZGytFUvmvdBt+114gZMeW37x5CcWx5C/+5YcXL4TG+a01Z+VIWw/DQbNJvS/y7f0F9rSgzLWKBftE2aZrQm07Kkm5ZjK8Xz5yBMBLhHxn8MbRterpNRM9jYa1JpAgsqoPI97YHEhHcIWkF/e83MZvZxQJ2jDKOXNGrcYP0Q38mAqwqJNAXkStPSDhO4tkttlgKXtliPg/TW8VOwRAjzSuJ2KR/gJjJyIyTJOyXMNjIs8XBDJai31w6oEeHcTiLYV8VgsGMouCRnIHdj9KIhc/mAZvFsC4ykh3TGvi7dLIr1yk5lPRr795sufTnufso5A0o0xE0DFcqPhwmx2MCXUYZIVYTMYFaUtptwPvCeirDEYcfwmgWqvHCuajLalnE7+PkRug7eAJwlaSFGMxhD5RRab8GrisMGjJIDgwBjer1E33aWrVe1Y7ecTF6+6J+S14R4pStEE7Tt9posVF/Yy4qaPJp+IGMj+JfQDEViARoURvKW6INp3whAo42Qu2JgUziNghbpCtD1mdC2i3GWs3tGqU9v31QTIELlzpLGjalLGASrZUALnxyajVkpeLYuGKya7Fa1ofeWAsuqAJPm27EYnHhNpaUhldDgMPgWmX14+Jcn/pA1VYArbCs5Nr6batfq7kKqV7nKnU569BwW+ihthIbeeqVVWGFWo80zllbn0HyWlUOVFCJxhFq69D5h1aFHRHUIFol01ou7JIPqZnvbAjO6ybFWYeVten11SA+x6PmKXEdCBd7ryWcKM9hx7xhyp+6ZQ9kGge+Wq5yXE1dqiTw793DIjXtjp0XwR23ABlOHiCUP0Fu1rCvJN+hCvGwOZpMUCN8liZzppA4zuc59Vzy0wGq/LABoKVe8OMYWaDNwt3D+kdVxx7IPxXyD5Xp6Vl1IhshlM85qHBUCOI6thG3V51FZjKjqjF8GlF83YDvCL82XNQlDBLlQiVDb1HGbwBtjCCsWsMqhuhwIHVLlUg1g2Wh3MUMVqgfM6roeIVurIxRUXOmjoyZhwGOZZOG+jyV/W8wVVFmawFM69UyDy9PyBs8qVBuxnArlZTKOUKWsJ+nM31winTlRQD6gK/ZbxiWwxDDrKKXWJB3tdrRvWsJVHN1RVK6de/rGot8AKKcp/fbAiBeY6B2/rPkVfie/CR9VGzLXLmRL9aKliHBuwznUZwnP0WE+lwyJ5mL5wnwA3zrQmpsysmkoNdhLgzP+BjHWq6e90kNpuReougha7ms8GWSFTVWowHuINWSo8lrQsbKMULBkm1jQVeUMEiIJVB2EPINzY4jieIoZ9Vyp1TPl+mvYExpQ6VBvAxtBvLWTtCZFvQ6oZKzb9syhEpzRlMVuEPZ0ANynU/lOz/E1C94CmsPXkuXoIpNSTlGV1VGoXAUBKNAyhVlpFFmo+i7OgNTq5LsXI83LpTeUmoJQb02duFQoS74GszEQigGTB2vI5jPA1iOMnMupryUo7CNwsnSQtmGO8NPLncG+ghk8SoWl0NdkNI+Z7LCIs2m1sdMnKXTaF9/RDMy2IgdQDTzhWUdEdUQUTt3xK3FlLtHFJK1dJSo1gwxXoUFhijmGPuCIYbpQ58OoRYgIpbip93LMCPcIQBfBO5oKf0BQBRNPp1GE/QbKCDWEIDx6KdhKh5n88rkQRQDkUlQpDAVMW8mzN8qUqmzYEH/Bf9VeAKR/rZSxCoJYyxnaTDDsijGWvH5s52GNOGpxNiUuLrs4UjO5YceKbNro/Tamq8P1FBtWnMBybE5lHlr0PPUyOxGc3gcbx62WtmS7Q5rT4E1tHXGavNqsESBrkWdXl12vvf7j/oY+NyrrIR50quVbKxQSX/Q8/s/PGbVqEgerYBk0N/wBxvfl5FsroIEETzClmxIJFwNWgULxdBXm0IPfVqNUYQdEX7K73ncEG7ZVqxOzPIctLx/FVSnqVCc5hRRyCX6aJusWehanl2ZRG2j9gYOYuZIWb2GbYBOF2IbsPkaQalWt3OxDVwL91X41ZhgiqeTpmmrnk62MtTRqUo3VxydzPKlQEQmgDV8sw2w5BndaGELN2ldDGwS2dnCiZnjcqlqqypNnS2ql0qZKnaZU8+WNLTrG5iFINhaH5PLBap7q+n5y1r9NHDop7V+475zHyrpfey89ymBPZSY9fi24XSpPqZE34DajSJ1NG8Hr6R8e5Ei/qUx/cgSthRqcTSwmj3YC5UosaY3inuZHdJKkFWg6oXlO5iYPLeK1Fsuy6viUwNji65O4QPThiHGsBgUVlJTA7VHUi7lm5y/BGAPs1wCc1wsdEBr47/hrlzz+u3Vwp2YL+G4AOki6bvBlKXUq4N6WnpXx1Vrc8iqjjQI+nyWXF3NuDpXXGyuxPGe3C5gpyOAokPYFc3iVVmZUDwre4cq9Bup8rlHzaSmPYlbj814zrdsMLPgMy0WPXa3EjS4G+YBUShwqr65PPyYp+EoR1X2OMynhfVvve9HaMrImO5Fyqf6WVe3FgzHSQvvA+rH/CaUj3q3CtGlL+y9mXTaF7hhbNMbKRrEPRCL9k7Ojp4d7R/tvTw93D87evP69d6rw/v3IxGcE59i0Ut50HRVioVPto17+RRGBfaRDyFeDRNafAsLtYdA4TPYIbd7+Mq79E0wmqw+a5uLy1NOmHytLy9PaQ2OPT9aFv5PxeVT7WyjwppEXKak3G3NjmBdRV291qW3LNwMP3HHUfOg54utWrbWEH4DW1QOLSGc/D7VFLKoMvJGtWfYRFTbfc8rWUt7jfbqMtcy9i3l8G3Jf5e7UScGNNkW7VdfW3q32OvQAqi4jyatY8Yw7CqViCutshfmeKr+XjrXVAUCHFvtc6naVfRmG0Y1fhGv3eq0107IZIbPiWJ0CdOKZzfJUUsOaEweSvkwEDHs9shlpVvgu3NBkb90i2z9yIfH92VHPSVHR84nPy2HZcMiv/dJ2ef/YLNhoAq/PfRhFUducdAbxttZ9/KWnkSJs7Z4bY1VEAYy7118jgasEKTZn9OIhp3yFG/TFynGKAKAWeG7w/ITxsJplnCdwXMcT0tBr+vcA9h3Rdr5ULq0jsourbrR11ghvoNn+wV25edau5WREYsNxtZKC0aoNQdthfpyt2lMINW2O7M5k/gjw0F1pHrcYUhEi0cHP9IaSXe9EEMl0pdsOyPPt1aEOw9dHQmNm1jY4IGTqOMXJL5g6KeSA0ChJYvxVDGkiTmeIV3T0BzFm6r4UpyTIFE3Y2NIJufQ+dMKt6GZO49HnLIdG/hj5JVXwULb2nH9Xe1Qm/gYstQt9MrzF1rSFeyY6EkcZYfxYu4pC/AfaWfqo2/zMDEGdcT8r1vcAht2c/l2YhuQXILMt0UXvOGLxe1YWMUpreK5s4pTxcWbwR5HDJaKayZqK4LCftm+TJIZCeP2VtG9nyu6p5o+PxK6GrZYECgs+Yuz5LVWMuMl6cehgmav3CG2cynMs4x8T0N+UaCbU3Q/Ols11wr+qjSE3VT9p7PkjVqyzVZMw6l9+gdMrbAqf5oavKiCCIdFtSmN5qZmSl5z6vmnOq8pNwIgzJ3qHeMc57yByyWjE5Ya4A14yvaK+2Tm8VYobFjWLZqrTtILxI/kLhrDLhpLiWJpXDHTzzhLHg2dagNwu6ROOd08LPZAxRy32wYZgVt0NZw48nVyK5c29XhXvGP9u3XM1pQv6h5HuNVue3VyuAiSvDyU6C+oExhHKKVIQ7wrZE5FLhR6BCaIxzJXHWBVzGQKrVz/JflRZFC5twAj6rRoLvYrj61x8ldaPYpYHloCyhQ5imgeXqovZKhn2z6xmIS1hroOc8pWOs9v2DM5SHrHdDZDLLoZC+yEHi/z60VOTKNDj6+M4nKhzFgOp6R8UGK7Jm4A2q+GI5BV8gza69FVDBLlehthlGP5Hn6jrBLn9HJP0H+MKeZBPQUzDud7OuBPKOGPwtkbeuU3GNCbJUdmnOkpKV8yEc5BRM4hDKOqPBNUgTS3GGDD8qYoxlgqnibLy84hvbJ/BJ9z55Fg+cS7XFgyd4tjKAtZXc6ocOOjvdapkSZ9uaue7i7Kmqalic1JCbStToWtUYyG6K3UaBbldFdajqZk9P5ZkgoJnB/cKuW0x+z5vDJRRYyzLr9TXY3rrWVVWJt5qxsLd8x0dgOYAE7yOBBrj7VJB2VpKuxS2/VWGCS5w7Gh5puOmz/4T1ODgI7yCgLyi3uEzFilXDUqORHaztlZs9zMVZlCdVZdJ2FHr4/fnrXV0lQ1wZOs60XeVtNZc5vNMZI/M3P4pdF2xltRgazHAWWAsn1fhVFOu21c3F6AMu4yL7efdauFy4G9WNhcB+BJOI4WmXomosLk7p6n5hmOmslDWhcPxVecUdNynk9VO6IkgSwEHPk1VUu7r8PX6k/lxAPW+wX+Ie51Uiax1Cb8K5xIVCJa7TCizPw8xWVd+qgUJMQ9VMpmY8YQuW+YepXXhOQPcLFIhGahXHt10MIH4YdJfzr7YiSZO/u3LE0ScXNEzo9M9L6g+KwZxavMrcIs39DPvM4lkyNQ/IHkjDKJl2I2hV2ayIIm0myiOcQLEVwdY+LaAqz6kvrmL8OihlkpsRLcRp5/4TbS+z+2i1iCkP/nbzRsULnB8D95B3qEV7z+2oG+3g5ELNKvSII84J8ZeTZLwry0vXi2LUddpRV9u8P2U9WSv7Yic+y/9a708513pVy/a8O7UwrkUL1NAUU03qmEEloThZZUbA6kyp2vyFY5HLG891HB9XQDylfYTinVgcb7h2yoxrh8/d2U9ZL26TKxbkppGGeTJJ1joMFwRjrttVJwFW0he842lN4t2qx+pMyh9VVsk1+yHRPnZlm5J3GfMhq7tfAg45yJkuDqGyZjeOouV4OI0X4TB2sKWbm4VIhGUpZZoKmUZRlwioq3dHEN9ETYtfB/J/liuVRbrkR1N28Xaexkt30YU0taewtDqLCfdZJKx9EEv1KE+RpadI0JUfBIvoG+mXQsk8ojQ91dWea1WJbL/3GpRQw/KQ9NlV31l78U4or9u/Se+l+68f8h3fgv6+xX1I2rbbCkmQ2WfFMbLA0GXczz1ldVknGFfSRq/d6/3rZjaWTF9sMt13+q6vyPu+5fMI7cRUwP1rDqSWGt8qyd7n5Sk5yy++HLw33Y14arnPcWm9bQ6B8oz9HlJUj7V9nQ8nSUBFTfj/pU/WrNm2P0qKCv1uRStpWI6KtSijNq1FXoTYMSM6qOFPK5TuQzTqqmm4tLK1Sz32pQ1g3XAlHecTWgRltuqcRKe65WOq9ocGk/1HJX2RBZQc+ckWbaqnUbdCJZeR+sxvTlSlx5I1SJt/lOmDfbCYcWTwtxGKmuecP/ovY4UpsKYnbmnsqJ1J1QRc+7QcNsWN6AK/GMSAQGK8g7KsibB0u7kL0JSrDeUA7Byorcn7qPLitcmSqcaHRnJvKlOqDOIu+86XI0tbvucdRg18WKLXojHznbxTF6V4D7V0t3tfJGTXvJ4wVbt+5SHdk339KLVlpbYJT8pjt/MTyorCWTFrENr8gLpDYHi5ylGcTZO78nYThfuIc3QzXmkAFzyBzMIRMCRVwvUGQsZBJgp0/BWoSL7FzVymNVttB6uJttlUqW5IyYyRkCjYI50MRYyrTu9bwlDcBy//69cn2si1mDLrJuaTE3s66NnLGFGVCOTQz6S/r5S/r515N+mvHCVdUQDiJ2J6pVCLhdSxaoFlt3V10Usozc3CXfKpX0853A3VDN2VdTcmhQM+sgVPSbv9RidtwJv94/537YnTtvL3g0cM8I+mThgXnAjCgdUrb6qEwMRF2HaFtcxLJ57zXE4VzozeRj2UGHiGzKInKPFINAzUdHca6ZU4Y5vf+4uoyrDkm7fXehvKksjhdi79DKvyTxP1YS//Gu9i8a3O80nF/P1ECrNLUUE5amHqfkQ0Ruyi+5srg4JSeUKjuaOw76QZKz/2hGpaTgCFSewJbeoi1ujaZJkiFFVsVF//Ia8U1XUqrSrliUw7P2XCG8+v5X88o523v68rChW04haBGLeFXlncPOdGA50HEO2iP+q13zfPjZCW3aSu9mnx3QF8f1F7LLK9sZmiz60C6DVzsmOaDdL43b4bUQUcXBlwvQENTLYHwm+o8rYDhnqQbK62q6LGkEOmPAu/l8o1AKcw0rKgvbClDd4+Z0ujOjxz0q0RvPmH81zy+Nu93N8UsdHh5NtYS6fHxSAqk8hf4qp8f6iH7TQ91velCduQ54ax63p8srdr/IXHrrvVxPca/Wq3FNLJ81f1/hh42PjjmPmzFz+W/mKaXHdlIFDl06q4hvyKZmYPAhIbbA8F7lViR+eQmVaZ2GiiuwEvrWHb1C+p8eUUrv76cyF6TP18cyFNQ3YG93cuJSkf25ZwF/3D03XZVRZ8Kdw+eIlO80e55V2W56MW7Z3CkD49tpY+M8jlKq4LLgRRevkPPmaUp1VNvpyLKpRyXmYUHDn6HhWFZfoSiV2kYtKt/t+LMcQb7tDT628zp8OoYN9OHYqvj+My093dXYdXEUwlrl5yAr6a0ZBocYKarr6U/PFVPD7zzQJdUkGyiOwKZHpAV72nuStpIYxKrwetp2q8dpV6+5vJ1VaLpNCv+ls35znTWqV2Kir6fEaEv9S26vqHZwBee3V00aeNn+p2gvTe6c1Pie+nhGufJNEweqPqKKKlWqhhp7nUqVeTbVrblK9e+pAH3JIb/6zBeI5eE18HjKmFeVT77C5QdFLTEfJ9QDLViFWsM1V2VYVVJwTVyeen610oVaFFv5WWQJ5Vl6e4xHPWUnYWT2ixFG4rN1TwqCMGDAFu54gUVB+J8cB+IbSZE/8wdgP3HJDkdJeXH+09LxErzoQYiPnhzOr/Pi1e2LeRQHigWHJ4Yfy4kjqw8UbvpidumOLkJ5KZVFSl2ZUkVsYg6VVX4Ay0leFGu8zxwhIFssHaWoutNcNN9qnNj6IjjkYZqqD5JxySbKMR7ecjQjYcogbADt9hJ7/bx4r+EZiO5sMmlkdeYtoGJhx/hqxUOV0DUBQX8KQq66+/dB/+TvQkhCrygoYEEt4GWvo/h9w6IUFMZ9qUwp30lAKsfT4ImGRkTr4vaFez1L95iSDQUjvALhqdTkGs72GeS2JhGZjVujMP4ub12SFsG12S6tVpADlCfRLoqgvK3elhIAtr9Frx7KY3MUg9VABfDNKSjKgIZgpj5/xvP/Zu0FjOQK1CzaV9SugNWScRsXHvb8noZaEpd3/754MRi/7lDTFRWLQL0DPfV/FuEM9b72mkSpcaWGzQo/YrN2iq87NAvfm9cb1bRV2mNz33LGjqnC94G0It7y8vCQ7d4dcbFR+KbrwFHnv8yCcLTvq6yMjW+6MrAFo3x227oWXaihbrId9O6K+q8V84esmEe4YmrWSLNW0tJQX4u+7LQ6w89XnTZrhd9q0vJVJ83auq8yZZu1U5Z7Ky6sSaO5y1dm+5O/1sQfsyYef7U1UebETRfH3Xn9X8vkm7ZOWSff4zrRDvQiTzsIrWkaNXhwnzu0hjwc49sM9IDAVumyEdI2VWpVFVU7r1Q0Li9Pbz/pqrZuYhlJIwJ6xY5CVH8irrK66o+6c5Jl4RWh2vBySSOHj/hVK9vRlnCvD2dn4WVhgBhHH1SLQh5esgDgatq40nArjnf4Q+A+9Qfe7RToGzz5iXAVHgnQBMvThY+KJytlvjShR3aLeQmTOFAYWECYkZ8ZoosTAbF+WYe7URyOkB88FYdDwo/BxFN48X0hIvFu4xeiET13YqrFo7hxmLXb6zXsE/Z260DOIcBpEecvG87JA0A67lWQlgMHK8CJ+VZrQU09k3waPsUr4NXQT2ZWg6cuxRhCmVPqC07G+tFCFTZuxMvw0cvMfPQyKz96uUJlVY+n4vBa4nvxop631fnqq7bwZmpvZ9dhvHM/vsyuh9sP6Uebhq844x7+5qWAolPqHQCfmapZnYUdkq8LaaSzcBTuJLVb3fatO3OIb4qfUsI3rYFNs6iinV5dhp2e3+L/ee2tu3Aqa1srWtmIidkHQAfaWoHTlXdC9mgM3Q7ZwQlfbsYCLRdEEzfCw4oVDMhc1PSFxRYUdQBAznLpX0n/mU9VJBLGoyljDAWBaHZ3nXIcxyW+4eDVky9MwyCZt7Tl8RO+sYKHI5p7zkwRcphjWBKk/EkWfhoUSiItxq+Y4qC9SGed7/BsbSuag7T1MPtwtfZxPhsu8skTv732DxFMLb1MwnR8hDCdxE9A5vjOk2yeDYxk7ezYJtLGBk+wgg0tCUTvl/RylpFuCaslSkRx0O61TSwg3Wxu6qmGtNTpDzDU5iI6OD56FuKMOOJsXjRwt7gon6p+sPp/XJT9O7iwVbh3KNNSdt1QMp3Pwysw/HRPXwGOfiqrofLOBgjv8Ycwe3rl3PL3917/tHeqSbrlfU9g8QysjgfKzXzjOoaZbRk5A0Je+rCBsOKDzcdmhnVANaB9tvd/hbFhmDwL9rob7TZg54hoUO5R0cAcs6PB2GdIA5Gaj3qHiI1JSWibJ4uMjJObuO1PhRT4CtMOIK1gaP60kMoqEOFNXxPRK7z9a0XE2XwZ182UkJmCh+L+GRMp4IrYQPA0OvgjuXV3r+aMWiKhcIDp7XWn+Zl0dWlz33u0knsDYU+YBz3PJzvAqOkH/K3HziSNeetSbSM/7TWuF+t+J/JQpbNSU4oXHG07MVMJ8LHnxWh6iq+H81N1aCmkyIvHQdDnegUUH88IXXsUfp/5KWExUeZd77wLyg9M0S+2xF95dbzkySJeoU4OfbeqDmPu97MsiJBXfUkdXrNm/SxqlNVUgKNZhznWEfQIe4oSCyyBfVr0BDQzjHmixtPO1zPKrDw/VJOBsz+IHxZcgrnL0AfrvJ2d3jCkyyLEZRHyZRGWl0VoWaFhac9vsmqWBQNqMIhi4qrHjkP9xw6ZyWvZwBV1rQV5d0xmefjrTm93vb/VVxuy3dvVJO4t5Qtbr+XC91aOHu9YzwFzUzUkunrRr1GfBL/ni2CUjDFywl6aJjdUA23rMTqltiHbbcTwxPH3fB0RCpwGnvV1fWwMLD3vm3S2cIZUb/VoSo/wuwsMMQwWMnr+Yfzm9mBM7zpTryW6nvEdVZs8Z5flzJfmYZ3Tx+WBBAmI58dAAdiNLkoMZ0knXutu0ldau3j5WSTo8iDmgp6XvAf+dYuOWe/ic5kkwnTo8hCTzqzUZROf1FgICrwQRwNLkdKQMUen7uaaMpEPYcE8cDVvqA0Jd3Dubg7l2IA6u7apDE20tuFn6vc6/55EsxkbmrbQLLQB4x5glLElGZFzgOU6njKUfhY4R2cd5sUxidDQ9T+2ocvl8EpfJMHgsaGA0gONf+SNDA+USg5g4k3bHHPULGvoio8u2dnp48DBX9xJ77ttUPJboOTDhtOe5vn11sOHNzc33ZuNbpJePRz0ej00A7RbrRZeGrtMQMHutXqt79bIWhvNkWvftVtcwcC070Dqb7WELvEd5mPKznYK9NnCwu3WLf1TLdTWS7RbGRtjHMwtNtAPq1BEOorMRMFmUEHBi9xK6NVR4bDsfGcadsQ+NBLeyQdojhFPzlITsjTrSO1RgW1yN8NaoLkZJ7VYcUDp8+F/ZslpUgu1pLRHQFRpI/hjqbCOiGoYryx0Qq5Bg8bTsfWU/myr5rHgonuG77Ewp2tfp45GB3GSlAydlP/Q4luYwG4bjAFo0751CKvmrYOUvF25kZg9HG4dTIttgeP0rMvRvG4gGtDkSEbHpFwSLfTGCnxca43wUCYyD2Uiy6HMKtXZj2VY9G4KVJxkjGx3uetmQgHqTvP5bB/kLXHXkDpjl5m3qACNzQrPZ/x7b8wQnyUvYICS9Bbbp4eFSzkeDqDGhUOXvi71PugYUO/yc/nYiYkAVns0Ih073vW+3/d8RxFcf0QNW5cKy3+G8ytR0Ohew3x93dMBMKyciIKnoC9ulMqRlDnFtU2tRcphgXI2IsHb//X9Y/yXHRJYjmYUyMse/ttWMBoQbA/QMBkQlFurTdJXTQHINje9US7Y/5o8wX/bS/U0Eo0qInQZhl14/nS3o37xQ5ri2BY4x8WJOJ4xpXXMfF6V+bQq86yUyW8RmG3p+2qbX5y+VNoMX6U2T7PZxQtXzZh5WpX5siqzss1qW/rFge9xSsZkInLUrrCc5YsFOaUC39MrqePgFpsHmz1fXDHQapcyOIhnGKgD9LXwFjVvl5KSgWYBEls267TXOhuPe6ChI7Rm4YfNXr9M+XdI0Q8B/u61xXWNbHkawo8Qd7VS67EGy1yIZj+GrkEHH1gGvejZ1+84MbuLggwdiU1vlY6/XMyjGDf02y/v+Omf0vG81F3nUKgdhwXOZKhv1O/aNbFq30Nb56O6ucbhsAyFOhInZFwaAwtP5BEuAwtHZFlRYOGHd+wv4IDuxtU0Xeqt2qvnKSFxRb9O/sR+lboRN+/X05mFwzbq1vM/vFt5dT+1Rfj8qYMcv7Rvxmyu2q+wUceiEjuuITou5PH7/7oEyDv+7lyAg861gP2Z+cbuIR/ELZVpQJ7vzt3sV2b3e4Pq/M2NyvxB71F1PjXEuvJxkfUH3zshHg1qQZ5s1oL88LgWBPLqYb6vb3D/h/oWD/rVMJg3GECb+9CmPh3e5ZigQQ3XhViqxKlsEFQ2SFnZIDzI7/37RkmuzRDQdJZWdUSpFDBzZ/aMRmiUUYUxTC5xKGdSreZloCncT8tU0zCDqYfe0vpyBMMzidJM2gil29CczJM0+p2cRXPCI88aPaVDrV1pp0Z37cp74W8k7AnFtWsa5qYmMo0K6zaCqNnM3HV6HY7wUZTCq0eFcXqulmGo03A1SNm/tdyeIvhNRq5DEIwLF+20XxkAR4INGoFR5Yhy5FFEJ8dvQ0K7eMCFqSI6BCToEEz30IFYGkzhWIc9zReXOqSSj9MObcyaeMILWFzNMH9x8MjMaOBe7nJptOJwuZavhMTpWdsUi80KVOnTnfbtHsCoFhc+i14dOGqkK4BzTXWFErgyrPADq0WRjYpO8ha8ab8eZFBaU84BK3w4m5XBUVu1DB86pVhdrFQelyu28bzYzun6bd/RMSOyKq07rK07tNUd1tetD5BWd8jqntXW7R45Dd/M82e2Vs6crRQ5dOm8DG+TRY6HMR8pU9M3KvtUzohnMX4xohX2ViZxd2Jgvcy0TXM1rdC/FQbvk6vLfX3fpIfbt94S49j1bdY0V23PldoMba1pfQObgc5V31OlPl2Lalrdhs3k56ruTB3MsnbTrM6eXqeuAdE4QWPfpQVB9hUOq+/ShQDgUr5aYdEDIT+cXU/DP8N8ajF/Wgc6BHFAGegX9ml9kc2arFrVmOOq7VSpzWY1bFrpwGandVX6UqnUZrFrWumGzf7rqlRdwBZrWbM6e3qdL8wFNpXrr2xJg+xMjrDvMqYB1EwOie8yNxpr+Q81q/MrCXW7SFJxvprY9o3Eph/Qq2+JVeS3ZbFbhj01R8T018AtOxDt1hSf4FswhWscbPT8q+r4mIYn+tj0y5fmmFtQN2+3Hw9vxZtP+9VxBW+DYHO3sy+l8YG/302TG/p7A1q4721NmQ647/lX2m657y0TLeGKTdmouiuj1bqy2bgrRTtH1e0csXZeV7fz+tu387q6nddepbSSyGN5ZiJAy5fepqmwNDRoGnVzGO5XENO+jZj29VHqjNcflS/H7Fc/B7IvYo5RdtiaMsNG25++uz03RohO3Il4IGPfPxPMlI3Bz2EmzjnlYf+Zt/SGJw7jye25PoZsak68JdazF1ygJyfXh2njMn+OlHsTvLn8J0YYfE9us86eZ4z7jTruc4Zz790N1HbuDefdLEnzTufW34dt4pbx1+199vduf4un7IiUdUwqWDVAFh+7et6OlkcLFjsBFCw+dvW8HS2PFoQdBkrAn7v8a4d9QWaPTcMpe7dSBFMkEzI+iD5YluHcsgznMBjD27/3H7NXKk+rzR56mNJTT6yDSjo71QqdsDJnNQRg9oZN3pnnn1VQxpmNMs50ylDco/u92utkZ9UUc8YpZp/FrzzRenrGenooqOTMP66nkmOkkkNOJft0+U9qhmpSMSIT24hMDF6x8WBc7vmkuucTnVdcs9D0bX+hDcHEkzE+tRd1JvwJHS1Tj2vPXIX2MDhoGkGnz8LLToTeP+Vk9KToRllhMtvtOE78hV+CeStcAVXudJdKY2DaKKv31LA7IFgrheJajbqzRZVvhRUdwHkejJJzfRW3v8v6GKnWx0idPkZq9DHilmEFQKU8TRrJ06SRPK23RV+B5F9EY/zmkr0IUxuxE7xX7BCCjq+MQW07ZzACw5QB8HEZF9pPlhMPgZBeCMAUkNM7FjjPelyCTte8jOLaaD1SsTnpLf0B2fCWDjsGMpd7llNc0XvHItHKPLeUeV5T5qmlzNOaMmeWMg59Ludvj+zh2beLYn334bXTwcLBHJQdXX1cp2oF5l+0AnNv6VDs1RlVyU1gc5CgVubUUua0psxLS5mXNWXOLGXqZhQPYl18z8l7nVzXyWj/jBm1+P7aWfe/0ubyr7XT/jF7yp+xd9pFw6VhGdRCntecj6DKk1QrN4kar4dF6sG7NeInNzJVnscuauMwDaeaVL1gBD+u0QumNtlfl8/HDNNVdQNHdS+2CEefK8O8Y+iLiZkwNROu0KnEOHOir9+lnbG/8Edy5swgSDJEuO5eQXyieVh39WJqLkrY7lyuCBgAFqnds3p8ORBrdFAB87QBzJkdZoiPbLfk8GiqhGyrxiAcdWh8ogLmZQOYyrbqVyZKdgDlzoSZR5+6V+7WDW2oDN8fxCOaJlx8AI3RMOHIhlcCc910FVzlXasbHIVUPHjQHoO3BX/MXeEP0UlIztQ3iYGIQQ/FxvmlQQ/5obpiT9l8kJXsCMNSCBxmuA9iegtR+7MijKJSyyNLLV8rwKJ6d76ymtx04KoNx5iSLwrCuErxUujFVQrbHGygfMPgZUpNjeKSqS1bPaSiMl0bDVaFNdjiijj+rcMwpuSLgi+GeM8vNO/5hdo9v2ZVfEHIxSXdJL7S0q2JtfhnhFq0NXhrRer/ari0EIpfjK02XGJzPqO0ptSOhgERi8qMMIi1PKlB8MMvDmaYEvN+afU1ydZl9+coHic3R7ikFQj1Pmaz25Ol+uyXKC14rXcpy813XJM0uqBDWbtRh8iBI8xu41Frurg8zfFBT/EiGhW+0u7Fi8Ul85YuvWKcU8V9nnzAbDrlrU5G0g8k9Ypj6CjoD6NtBU93hHyMz/Y+tCYfRuzGbwkIHyDL3kXn3V9fvH0aBMTjzwy5AZWvwbmyM4Q3YZS3SHc/gaQRGjUOSDZKo2tqiPHWcr8MQYej4/GXjAZbjWrtnStc9Pfum/f0jdZOvzt4kEo5zNNeju0pL8fCpqG/snKXSp+F0YyM71oxl97vVPMB1PNjDEv2bnUvxZLkr9G9PdIvjffZpfGKlYT6i6PhuVxGsO+4YZSvvrqCtAhBjYprC7Dd7Xbb8jY4FMbTQ/XycyrCAZDxC/RpxzPsr9Zz6PRux6ihepgquuiI5PBfg0m4OZm0mw1O71zbwEQUmqbzcueyA2tZb6uzcn9XqdXsLY/Ec6ferlJ2YC3rDfllGvauc5fE9AG5QF8g9+S9mzEk5qQJcBEymUPjs3un0yTNR4u8Yysi1Wq1jvpSgpBicgOJsNVd5l3+m4n23YsbuudRXB369KC62+2NEdlZwjhMg5egS9F3C8ZW1pEYoyF+zfOAMr8s+WsatV0FuQYOmbEQ8HxbpHHfoTVvQV1I98NMbl7tAxF7WxtmgAIOM98bsU1Q2Xjah2qw7irw5dKT3UgWOXI1+QpEnfrVNdlgTnWj2hd+7QWbvM3NB6p+r4++7i4efcX9mT+lKLbp6OtswEv92fKOqyBb4QIYRD2gqXDGA0qLkEhRvR5qVZOihq9JR55fPdF+5Nq5v7RpNT0WPkTVw7d6bxpVTrkKXjihJHiThhiMaAUhuOMW5+8+cKW+qhuXZtiQLBp5zmnB8jumcCTORoHnIyiC6AB+zR7AuKBeBdM/VAGppO8QY9PTR+u3v/2NPpkKvK8Ff4WzLAEVltBvHEZ8Zgm/f01GebL+U5Qtwhk/CYYhnOQ3IWjaraNJ6zZZtChmwJP79PMm4Q+wYmX4HlMWQu6MPdMUd38bnsEwZ+877YOEFw9ns9vWTRjnCM2xjeS809nSuqI96rTbXiNsDEujwvdfY0a6B1HGsXdguU9J3Mmh9NKIqOQWX2lkJRlYqVJ812umV6AlPOsoW09OPN7wly5ouz+HGQMfG12kS9SUxX27yATc0yUgQdYlXZ/4G5+ipmg06WUajQlb3WyhytBlxdL9EGURKt/4YBQvxVYznxoGFshZef4WWD+ZBJfdK9w6wxlyoH1IgXaeHD77+ejgxQMJtQPUT0jMeD6tVhRXMx7Kkh5D8uLw6PmLszIaxvxseFjOQ6U0ohIM8kEgCzwstZtTHh57fiAFZm9YeHie4dsK6IzI9i7FhF30md1L42V9m/ur2jUTGodcvtPOuFvG/B+52+fzWXIZzpDCJtEVd5ugMjqfH2z+MVpAWQAyfi+5mGbKpPdZ+kH0AaGaXVFPHdc/U3lhMDXujVsi7hsgSmh8IydlZnxblnasbuTpgQHTujvzqfvCfGdTn5vS1po6L9LfsSg7uVi1sPvifdrg1n3a4Mo9w7OS2MHa+JrkN0n6ni7JH0G98ts8pa2QpF8QGi/GQ5grxU4pbbdGLKO69AnJkkU6IplSHtJ4YnXZt0dKobewldLXadMJyDnVBQ8/XoMOqRa+HsM4Zq37rV9evawuKwMLsJIu4MIjIozJbH+FgANmGXnV6bEL4AsCEFTiWjUQQSWylQMSuLA1D0yQVkQB4EtbCwRQBc9XeWN4ua4bl3h71BiUrd/G4KWIB6kr3IE55hLUZrIylI48uVa4nSNEQlodH2FYbXA5VuwtynNF/1xkeTS5LcwmzWwx5QuSPTWDPWFkOFVs1HD7XLXs0pNfKtrPoixvJZPWT1Gag3QPsiM+okoFfvyNOFvX4RVI4mEspHGQz5X4BWK9OmIO5Jr61EQ4kCJw5e5vQJmP2pQhqIiguof06vdHA0VqCmB3wKHdYw0XOJQWIH1un6xezWXJHebRXZDoIgHwe/zhBi1EoiqEpg5e4rN1djG0bkbNKYoHzXeie4FmNuXebqaSyt54zK2WDawJ5R0j02RNbTrq5iPS6CjDsPtVXdCbjdbBhdJqLus+Qmn2y3ridI/q2kxQRhdclpRIRHihei5aUaUafhz0hsfbsXD3O6aHRooxPH53fF4Xo4W504YVHCU07p7TBRxW0H3qnrjQeV9xo1G58nt3YbU1DUYV5D6mzFMJ8BnpgIh80zatSkx7B3hxCLFUJcPQVMck0q66QRc2BVnXISS5KysZx5aG8Gq3UpSao4Cp7VFNGbJFBzRRtsliPjMb4bKIlJqhAZqxmmr3w7A5qEIs+BpLhewhdnfmCPVzNL4iedbiWjbdui+J0HrGrRBIJb7Nozl6YSULWGFUFNiOdk5j4O/T5Hr7YbTTSqiRtRV+CKMZNeJFcYuux3V6JMLQf0SpoQUNWRTyyRcLQKZo6xQtGoZHmq24VyTVeuy0LipB865OVZ5N34NAyxBGvTC87GtuIKxWZw0zoe8NHb9+XndpQICe/tQYFLDyJzDGwWWXr0hqDAtedveLzy4AqmWsN5nVtvLXSinuy+Rju1w4x/AxeBoYtDPoNfCINXX/NQKllsszqfvEZOn1VhYrnpeGNLoCGvfzgZzZ8WF9Bn0Nc+Yc1SnK44GluI2iJtOVvxi677KcHu+9xssuypItzRkwWnk8U9SyuMtSAdBmSwUA1TLVSwUhHEulKHy3pVKU/7KlYuK541JBNF+yVKC8balgsv8FiwSb5VokSfXdoqTyLlc9Z/bvzJnRZgJyIrR369vyZj7IRX1NqaUoodT2LJxHs9viYOWZTKssRhupFWrW1poHlMrw+gvTLnxlcdgFqdIdO4R3QXJ16HHPDsTuYEquc3B8pLvS2ZGWeA4Koz9Lgirg/cfow/Ca9rv7Onyt/uwc+6812oTKdcIs8NjoU8ldjUzbUFH734McEWLLKchQc98fQKSYxzQK9zAfvjzcV/c0WaQZrZTgm1G1tVgzqub3UiXPZjsDvolMrrtZdIlOTFeZoZyPVeWcuqa9dg7Jm+Ozozew9oavKWEHY1DftQ3hNac+miFaZ+kZ7G2d1/xwupxrUDDmHMP4jm5rUDbaLosixpYp0607Z5FbT1p1t3q5ZiObRB+tPDuptpnVxJQ7UGLKNaGDkUqTtAFbuHL1FpkXikc1N5VXp8N9pb6m26VaphkpWko0I0ZHwdU2WQ2Jddu0VOPcOC2wzq3TAmvbPDUwg/h4q0sbqAV1zRaqlvA3VthEaQmdWFVcSK4jg1y1fFuTj+JJUrfBOoqphHMdfSSzrF1ZP5bxaknryrAe6dBKefYWag23+JqUqnEKVrvKKkR7/jBewR+DXY1ZsEIrcQutyErsolTyTvyCY6liGFpFdRxDA65jGRpwBc/gcAbTEE13cQ0NezO2wR9qXoVvsCJWxsFfnXZzDvEstS11dd5RlFuBeRSFvHpqc7APAV4INDLSR9rESjurjRErwg//OcoEd1+F9ROj4+ki4/6uursrGrujeJEsstktBrhoATQUh16SceuapFEyxmN0alTvRF3SbWXkA1Jq64aQ95nnt/BcPWJ1hSlppYs4Rv/aKG+hkR0qmMO8kbR1E+XT1iyaoxdmKxXOGsypdh4WHrIUhBruYbRBsmXtpDHTbrG52WJOBeou9rc43JxWGOlLUun1v4jC9yr8CF1axNRVISNxlqRZC59ZhgEaASfOvq1ZZshi2NbF0Nmr2Rv2mm0Ee6tz/T2Dxe85+fmek3nvlY2OeobGwvckv56HHw9gJk7YRByT9JTOj8q592rY9J4/aMKToSaGG+rKOE/e0zStvVVtHp1eK2gtYk5uXo3941+SHK7S8HqK7voR4TRB72T9ESQxryWJeQ1JzJuRxHx1kpgbJDF3ksTcSRJzF0nMbSQxV0nimM4BUMNznJ5TnB2VIuY1FDFfgSJw4hWKmGsUMf8/QRG//c12RQW9q+YhNQ3Cpj1LwjEjkFlydQUbrXBCZ9v5bCbc22DbHZMPEXpItsTlFtyx8TrfVStmZ/YFUGtCMOwg5rUuoxk7Kqd0yI6RCGxVneenrzzHDg6Vg6QQt2ApsKsy0zDnOEn3t/+MvVthSw85p8LpgEGcpMlcmZQ/gmvd1HKtmxquddOMa92szrVuDK514+RaN06udePiWjc2rnVj5VoHckZKrOumhnXd+PSG5nrfybIQ+cvkSuFZNxrPulmRZ/2m8yz/b+t9+Ob0NPZ++/fY1PcmKP2HLc4WohixZ4QK/t8Bd5ri/Tl6My7Lw7Qs+UMWhlYB6LSVzMaM5tAn/asqAMbdCJfSd13vsLSKQ7QyTL8CE0WHpnCGw7XQ7la0LgmMUoTsfITSKL2/mLAhmYbpGO8rohtUCHw6yoELdRVno7dHNX5Gp7V847QZXzhdnS+cuojutOTNcHo3J4bTL/NdOFV8NcZAdvvoIvYUIbK31/vMU+wViRcAWHvKUlWeM4xTLSSZe+pOG7GS5ktRYzsHyQI3bOoN9zAPr2H/pw1uLa6Fcxz1jPvbb02aymPCTmpX2cS1FialtTC521qYfNlamMi18EtxOHuQhlf/SJL5IfOsBKDadWAW5XM/aTj3k28591Ssz1q/Q7OEf+U4jVCOu7xtiYZDUnjVdPa/HcMsS8Y5FcGANYbI+ltvj1oZ4KG3tNkNuVR6EdB95hL2HLRUYU/zaYo+o7BTHRwfwQaTgRRHh2FCX2Dptt7GsNLyRQw9ALE7TnIqXAtpGVFggGeSQmZK8LoQVhGl5aq7rTOQhb/LWjfTWyo8Y9l5GC+oPJ/AKKfRWAjMrPJV+Pltrf1/v5YW9120uF+ixf270eL+l9HivsKX1YdyjrI3fPxigKklRSgnxptT4b5/25AO978hHbZFL9QliOu43ZDobmtE/dtmW/rt6lv6bVdIqME999zcGgrBrVMhuHUqBLcuheDWphDcSoVAbZNo0U+Yp6oDtzXqwK2/2cSS8SUL7Pab8U4aHSMjeU4t9fATRgLYXRQzmfIyTW4yaklI3qM02TpNkEsi4DUZRZNohEuR3qFj7M+XRcJ43GKRSroo0d5EmoSPyrFy9w4NFLnaFMQavictMpmQUd6Q6X3VQary9FeVGlT0ocFhxkbshlwWoxYisw9H09bNzU33Frep68UIA3/NfbrrQOb44U0KOh2Nr4KbUTKxBiPp4AgBbo+pBprdh/I/OoQsIEOa0a2FG3YmUcxHmptcYGaSW3QPggQya01gT8LhFtaZKO+qvIXfd63eaE5qt5ETFxGdlLaRk7ttIyeVLsWDum3kRNlG5jDT+/j1LEnZ9XR8Nq1uBymX4nR+olF59YCefMutZM+xbBbsCn675tW7PZjHMxUf7S3IPzfFI3RalKjBpvo+XSmg2pkeB++/evDP4WGRjrR3gIcuIbvLBvMIMhVdNWc1Yczed8VMvCY3PzGK6Nzr4UQsjAfwms7M4k9hL9W8gHLrDEg206OcIP8OMZ4CUD/U0qJcHn8KSX6BMi0QPesGwPIwNsi9KEMWh7fV9eOBb67hjGJnPKWiWBRDdbMZSbUmXKdkXfSCYqJA3dbeLEt8vuvMkyzHpZvMrwEpsit6mIxVxvQ5QcH+HHx0S0rZeApOjVCwfEJ2so1xoUDUiGIZNKb7cT7jQ/j/UI1g18K4ygAr8T30e5bcYDcIXTwPx8lNTPc2uhnAkk/p/TR1crorcNdvu+SYXMVfgKyi+kPtaj1ts71vbf/QRe2HDmo/rKf2w9qghWLY91mj9mmbOjxyoTKih94KY59aAmFUBrQoUK1QuOxcskJhm5lyheKaMLVCudLQYVnrY498aDCfP4VEHZXDNJxnHXRrNsLBcT5UFpaJnzPH6yi4DtOMPIPpzju5fOdL0TWI2Mp9+ev+/Wint3vZFUifK4I/7At+5G25MosYXyw+2d54zIID/8LvGO9TesEkGmVLi2KqRhvzZZA/PRybiv95kh9SeBZ9WA25bKCyB3f72D2dEXLd6XtqbUqQvXrDowy9Wm3mHFZnB8Uk5PdqUMGwKX2TbXUYx2T73Ka3oTtLb5cbztEmp4ynjFoZZmhLNEeoDOFqg+18SdZPieMIGDcRpNFh6N1nX58/A8Qh6b4KP76kqdzTxaMNqCgY5L6lGKQ6ml06yV+p1YWfAW3whxxrlrkMd7nJRSlol7VMVXsNX5wm7bW5CikjrGTLxtqKyLFVMh0tLV2jUhZjkTdUP8od8NXse0FuLD4H/9ZboPqgl9tAc4f6Z1U7KMAdW6J5tZabwrKHxndVYxjEHVtTuk1TblFxfWdoSSvfVkKvAi7fmXl+ufUFplV7YMn6xII/rtQkx/Ulb6jedVZvYu2WvPutD3xZfH5tYN6WrZ5n0Ucyptjra/sKNb0oInF+lZ618cE6R10NamlUAw8KNtjsPnogqcN5IcZ7aMKYN07xPlftfZFj6vLdaqHBB9QY2iGQaNba87nX5pGTqlqkutuv3iS7G7rSpqjUJild2bUQTjAuBStERS5oozfDFopED0HpHOKp0+NHfnvtMk/CzvvuFckvfpnPcDPoeBhnNSP5Xg7UdrnISac9BToFFY+GRdUyRJPafrtQadsUzrboZBsvk/GtJvvj84hdqnR1PANMDfBLTN6nXbzHZ40xWLAIyUCXaSkWQiHA0xVeQBTgapQNBXxocFW8jz/UQyuUEeyWYjxslcMvaEjKTFR0WtWB5MtaiobIAkgF0CszqxwTxgLLs3yL/meBlpma9dwC+PaopBVboFjOcjmEtolQwn384OF8g81Bj3+yiL3BRo8muI+M6GOTl/lfz0h9q2ekeBQs9pQNt9hMeRDV67wz8Ns3WRsjqcJ/oFa2+W8UCqhCrpXyitjJIsTya8BTRK5nMShhvRxlqMVinDwWi/sG9NMDYDABUcPJ05ahWq+3jTStHOuoqb2n1Z5r0bqJK1z3RfLeiLX1prA0Je+pGgv0jdYlbGIYj8jMKLBPE2UhFihsKfgTO6YZ5maw7NwSRG+z96AUfhutWuXQa4MnDtAoe5WMwxl91RFYeALbIewF9NVWMZT4EBJ8XdJeZN3rRUYf9BID4Vny1H575ajaecOo2jWREI+VQIilcKFRdbjQ8mA438xAO+OL0oj2B81wWOOOwppVg/tjqOk5gUy/dUYfIJjdoqcH7Pp4m0nmopGb+j2yoIx+i7qvzAg9OMVy8EfamkRkNs5aZH6d34orV8LnGg3b/B2SFhVwsqKbtuMGV7ByfAFDf4jbMUVPT9reSrA10SrZKddQC/Z4nCZ5MkpmW0VsR/Wsf9CzhpNM8eVlVrB5GAujSO1tWDt87VVYd7EVwljE9UEoYhaEoj3N8+u2LwK/8M9yM9QRjOuCTspKQqWSDIM5KrVkddWEdUHuZDUzXg3uWTNRx01tBfx+ZlJfQSIryNBVWNZQW0ViEkAJvCq4KT/Xda9sW7zWLfuC54zjCIXcBte/Nfj6tW6Brl/pjkKN73vrCObhx5c0Fkuw2R+U0SPS/mYpnU0lwYOktLg7rcH4PbcbD3sVrTTFavG7TbAecrXBbqOzRRDIHesAZfXGi0ACN+B2BmgDRmcp0XzuzdK2C/wKkLI6jNJY46Yy9TILr8v3Vpt3Wfab7ZFNFpO6EEIamuZrLDDrYgrRStN0MQngBovJAG2wmCwlVlhMRWks82jTMrUC5F9lavFxjRiEw284vQteReMp1grUT7MNvH6qXaWaT7eBgW8NpSnXwFanvCy7ga5/U+pjVaxAgUoB7l8n0tplgAZkWgZvQqr2UquQq4bBNX8aWNW7fcfKk3n/Dsrk0Rw3GtTr4iQnW+gqNYaOROEso/d18cE56XKlO4BRZ6+baDRFhZKEGcwJXhkDYQW9ptAjjKRkkqTER/0RdVWAo56o6yi3UgsmdbqaYz/QvesmyojQL09IOH6DGqzaIsTYbf08JbF08BqzyB+/Cs9XrMivcQ6jjsK6g2uYMT9FxV1WG4qcPb1HQ5NAb0Dlxo6G6W33rqrvsizuCwlSJFeLmJrsIYtCir4NyRxIKXMskYupZXoQuSQepbfXMF+CFd0L2u3dtPssfE8K7qQ8fGb42jR48E4Gurc2gePmVjZRXEnqFD4uivlMN/vJcQ0cQ+/r4DjKgXUKDED63FR5OkwomICgPDUGFE5EYJ8mCySfB9uY3Qv0+WGjrZQvTWpwnXcPWWLHjtMHiFkCvGv/9hpoURT0vK061O2y6XQXaFnzR9KNsVssW7pDlUy1xYqpXBfL5fAy10YiaD+g/7Qxo2RMponSnkvfY4eUmgOGw78OGL7ZAQPiENRQFGJnRiJdhRXr1oQV6bqFHg8H/hQbfSRs9JFpo48a2+gji42+//2mHVSx0Ue6jT4SNvrTZE5KIkBK/mcRQRpudG7rfbSq9T5axXqfVVrvM4vA1edWrQqJa7OZMaRS4tpc2aByGtIngXVZij7NS9baYrCzlkMS6RYtWkXcwIePVlEfV7S0x3WW9joAP3boo/FXsWfpJuf/e/poVqOPrjY9ij76rabnL33UNDXrGeXLCu/J7TV7Yy2EvSbswnfAzwrb9+/THVDfs7JqHbfkN19eXROYlkyXwIrz768g8rsketGKCjFZIAwccmxT6bG+BiUZRc3DkvB4WCk8IrzsT7tNv68LoZkKl+8jJlwK0XIyC3OY9f3pIn6fFY6ePRlQPgt6QNJEBJTPtuNhtrbm5WsBeZedi+RCCHkbxfmTvTQNb/G2pY6lB+tJwRRSTJ/YaRpiw6NzkndmPhBuvBbMOOiSi14RjAn24bgkIF9EcZTDhObp7SdGBtS9c38awuY/pi/bzW477PF0vY190PVGYT6aMqeT07OTi73j45e/Xrw92rt48yNINEvRBwKjQrYHm4+HhD55d7HIJ0+ghe/IeUB2gsHmYPfxFv549GR3k/3o7T6iPwaPdjfwR/+Hwe5gC72QaIcUHIPNR+eB+d337/WkhEm7NbhcTOQs+ZGf+bEf+jM5qn7Cpw4Gexhvz4YxNDWivvtsKPZy5Iqd6P7jR5v9gRcEwebm4IfH9+/Ha/1tJKnMAF7rA3imgD/eGPQALgoeb25uPF7rROsUw/Z2v+etdbJ1CoDztwabf7IWRNv9wZPd/la0PejByAzgBy0JI/KINjU3103iwTqh62UYbid/dhdY+/N34draeRCJbnR4Aszo52hnZ+exLxIGTz5D0zY82U8BCquAgvYHGiwWBvhyeVnuUY+Ve2KW6w/Mgi5kYsVJlgrraHCJdi+6Zyi3lYBPKEQLVJpTKo3WAgthdZBqJfJIRV7CjGs1yD9/lks1pPPOpjx+MGDMAhlFBPVGwGcK1hBBZ4agWc1wLrxP4bsMezcb8iDAZMkOzBX6mVH4ZOeRhMbJ2PChH8l6vyhI+3o/SGBZDHY3+lv4Y2O3v7n1/TDZ6d+/T9sxC2bb248/s3bg8Cbr6wx9X0evNIhPvmjqVme2zpabz5Pokvs8g1ns3e/3BhsyHRff5xlN85aSU+gTFvqZ3NGwy0z6YKOda6Oc74ifsOJzySiE3pjDYOAYDKOdAGkC+nh+HxY10gmM9dCLoKtifrd7nz9HkNHbzbeiNZUDQqnznXw32kKHy+Pcwkd7mCwKmBQPTNXDfGTjdLdDWMbTKcf/n1RyfAyknKcLetlNuKzOyAcyCw66/7g4OHy29/bl2cX+m1fHJ4enp0dvXjNf0TnJp8lYwLzcOzs8YBkj3Pnohtp/vPHkEUtkQsXTCHRJkJg4gvlLWs0T9g2NAPHx6larFroNmJ//ykDS8IZ6reHvq9+ja/kxBXUMZEW6H9GEcUS9rsL0VkkEbSxJyUWSMa/EPdzD9kE5S+ZvaBzpjF5b9AsXZguEMEmgEIt3hu+xi6oTUEDHbUHyby7/iWZLkPJQAvAzLUHZxNmekokNHNkj4sYzgDH5+GbSyd7F5952z/s0JpcLvGI1xNhEN+2jGGQakIiPw/eJeMUShZTWd+01LLPW/s7n9/sR5AIaCGIJdJ2B0qlvL5lzD+/JCYBgG69AXsh9WjFsg5ZMwjKRXMN7wcyztAhLUYM9r69oVatDPl6zCKSQOKPtvEpy/Ajhw2sPRVWZrMq3NA2kueXSn1Sv4gtcBReASK4TkMEXs1xZEqyBGSWf/8GS3ENTzRzmuPBATFdW8Q5QrLqo19WvrZyuTrOE/r3df4z8Q0lZA4Lh15NJmgLbZmSSXaF9liVjLHbZGUpoWfDuXNLPnPbjdVQkdOnbphf4FHePM6hfu3w1HAE7GHQkqJ8zsoe/GW37auNoKiNYepOc0SpdBdG9gNLsmx/ZWqBRSA7TFGbipxzb34k8CphzOr1/X7bhlOQvaJrWDgaGTqcFHTPayoYK7alUHrQZI2/vZsjrFOFOQ7IltLounizpecCH2+8SSqlsE326mExIeo4oTUFcw5kF6revDDF070BmKF3MQApqNGrmOu4tl9SCp8gXClZt2RaMGEVaOm5yDXlsA7rX5/JiEPzv/+a7wAu24H/4utfbxbY9O3p9dPpiC3++fnPx7OXb0xc+H3yijHjErlQY407MwSYVIyxQGOMMOEQO8aNuTD7msIuhRMMXNnxwAMFEh5yFFgs/oPtw1IXflipwKhhiSiS+WhLyOmHA5un019f7bAg+fxZpz96+fMnSPBBsioLbwWPOgpKY3tgRlXezxWVIq+0ptTL3EYVQpdADPYmL1dSJ/BDNQbxBZyeHe68uDl8feEKckBgps1mlfqWWw3hcrFTOj5IYU2NPY0M92ZQ3Pw7LY24fAU/rXIgNVZv91YZNWSDYlsuUhO+57AdExPGLjYJxUmYbh92f9ZbdVeL9Q1atbCDvo66u5ytoPM/KnpGlk4KlFxwavuT9MT7PCnXjak1RZqB94rSPtzYjxMhZR4RIPn8WfIPmSBmTt9mo4yTkxytCj2HCFd6XUFshj25gP9PhOQ8OVPmHCsSfaNANJp6V0DF7w/tct5mE4xlJNwYIgio463sckPso329+plYO1M4ey4QZ18qHyEZ7qNgE0c6AbOzC/1uRH62DLjNOAEe8llMtgCIJ1+LPveHNNJqRzvr6zBvGf0cVYtD3Q/5DqAfx5xCU18efe7zFB7zBy6HKDKFm/DzeOzk72uOcIOgPdXYRDIY6rwg2hgVzDR7Rj6cv3+z/GGzS30DXh6fB4yFbebyOgtp5Ba8PDw8uDo72zzj+w5OT12+C9b4GfXLy5iRYZwAHe2d7IoW14NWhBOGtePtMJGyKjiqCP2/K08NTEMyPoX7eFJqgwv0wdKgOon3Pjl6eHZ5IBC/ePnv2au/1xZvXL3/l3Tl5eSjH6RcAfDS0qQWiRUev907Ex9nhL2cc79vXP75+8/NrjlKoKcETdu2MmEavefienGH0B3Fl02e7xVGcbwwUvUqI70ytRvtVhJI7CSJD039CNX0CC7m/u/HDkyeDHwagEf03Xctb9M9hDopeQJamNWGUjsr0kHYhmTYQ1nK2Fg3Jfwdc22R6fTacbYfDGasT0D/57/hdh/x3Dsq7d3+wuXkumAL57/U+Hr0TiTG4xHMC2X86QgtBpppw7XMzGeedV0kyvmB7r+Rv4ceLWfj7bZCz7zgaEQESFSCjaQjcmV9OnCziURCDTP//UkulvC4m4krhHcdqkQlBGc3lIGtcgOyhwCipF9Rgb0CzTV9NEp83aXgtfl/9jiKpghbYG6poUkh3KcPQk/xiMgO2DTPF8WrtuLm4RP1Bfs3D7L384keyslaWoPcjJR8UCKOZUZxdTAXoNMymWlmaoFZPE9QWsCLTaCIH6XKWjN5f0PjssvNo7RXzqzTrgmboUHRTpuutJ5UUCzItaZYk70PaMRW5Xp9cT5Z0XIp6W5h5o2fYHcRc44LWwOn61VLGt1BRnhIipcn+Y8YgjrovDveOL06P/nH4YOAV0GMrdGfw4Kh7ABzy4PB0re/JEpezCzf805flArMLfGBWNYCYCZczSwp9YsfSh1d7vwBTPcMq5Lq6LsFhY4q2FIA4B3IF4TfMghw5cg2z0wTTjFKymLEox0919VLSgnSJWYUHHUhtBeOqagqdTiJXPhAKKVbcZaTigi9q24Dvo+7vJE06+hrwSsnjcjKfUT0RB8cojcMDYpL/q7k5gUynCWCEipFc5MNAcTJiRxi/p2cvFK5DQI7x1jtk59HuD1s9b0nrksdS8vCIClPr6/kOSlPkXX4eyIOSF3unLy7+8fLoKeP9EnO+vU0UDvHfkXefFCxELX2ngpRrXnCmrLYY80EbBKWbZw6jHVIoAvQcQvlmqjY1xUp1Ag1J6tZQKBi5ujP42tdahCEQpPah/F7DbU0DhQQ8Qc7DWfEpW7SugmsfXFfN9e2p8J5kY8J4MN4gZSviqAtr60LJg2SicmqY1F0tYQs2IyJ577qWx6JIqHy+gARx3pgWpiWK9sHgXlzeCg2GqEP8Tn6hTT5XSpxOkzR/dfq0vhCKNCjH+FVACFBErwkpWyhpFlI7FBJRvJPBwMeo8lONcbe31Smg1oPY5yZJbm2QC4YIq4Qvf62hxxULsQErlQkSQdDfRddgUHSC93lXajzsF7Quxhh0RpEBXbSsEJPVSkU8pdoglouOfcVyYjBEMQF+OWcns4V+SUpbp5+pEy5OQ5U910/gu9gT/akCD4TI5JP1tPvq6PXFyzdvftyDHfFgV1luHReQt9XzMXIck3N8DNbGJCL/ijfBHymVrbGN6tXe2f4L/zpYgKI3W++f+3vs5/lQa/YOlCz2duQSOzsB7J8JnucIEQOSsXfy20Mtklphcv9eZ/EuBrTATfY+f6a/oTb4uqZf+AvqPcePtTXxudY/97xP2VowwNNPwMbVT4TJzgOEQeD79/+khGx7xEz5gTKY653ROjqlBaN1dYjDnRk1rhFNSsthfYSQFyTMyjK0zMRyyXrdyYOrd/n98bm3AzOwvk45szRVzLbVod+dbSlfkgNGsxl3UVH3BLaeivN7GOhPtFdEFZrXFYTryiJX1m+Qr3Xy0rpEtiT8bSgTEB9y2/DzNeCbPSRHZXDWAxU5+1I4KyYgtUnJHHa1jNktCBXl38EQnfv8NyiKMbRvN17PtworRuYNMS6cUhDXvChIfzsLhmvAiOmEKmcFqsUMVwZ6fxZ8lFmaJYkqxKiMLZoplc+1INM+CRe3dnDNwTjT1eVRNTbQdiUG5hOux4haQZ2VaWmXCxg8wS+AkPSGAgnlpPVFlAbB+vXECM7uC050LmaGF5azI76DmQ8KuC/qXV8HvmHr/Lbad2/oDTmJKLDbxjK8f9+YKEo9hmHvgkXwV3k8NZpRCQ8FJVMjXt/kElM5w+PWdLVNQZ+7ZOuUqE4wk2JybjwVxjJPnrw/PWXWq1dvTg6HOnrFWKssLZUtaBX1uP+xRlVrESLtFOURKR7gF0ROQy+qiJRllymLOsikxKMJXff6bHvXDtiw6Wo164YM5tr1qNvdKpXYR3IpFYNCmRHnFNTUuOuopmevZpeiZ0UvTs/2Ts4OD7bUtIM3rw+9rY62+SsdXrlbvt6f8sKeiSsB0v2FqS3lRWry77oVW6a0L129aK4PemodGrdrxI50SUfjS5Hg8wXMCiyqKCQ4nLTgadYckclsH9rO5uuQgdZAoXFpuLeJYY3h7IzRSrRdRR9GZWnXlGcjz2jQdrBJy0nrjqAEZnhGOtVQBvrsaFSsdHvnUe+Hx165RVr3PWNUd0zcekM1WO9THNg31XUFCUgNTOnDW5a3dO3I9vbX1VnTW6Li0AhgXW8FVQ/V72AA0sXaWlHNdhD/y6xhKdJobWaipSKuqrbHytWrtHnNz74WeyYzfHHA0hzKncwJ7dmGkA5bhk7QVe0RLVend93e1IqWlketX4G+2HyMUtR7tGnXLDPlSUlKmfFtbb4U1XJLn8g/Yv8j0hC58kLZ1cedIacngRS3uf+lM2Jsf1w3Z4Pp2gtVxa5+I1Shv8ouSMzzAfeWqEgSPWqMUZcHsLwZOoNlgH4mlFfrb9DWQoeVoNC/69F82e94O0Tlw+QyhYYdrsfmnmUYIozSqlWiPLDaUO6C7KHTXN+oqnIjMEQAVQw3svSpBWEwakLr556NN3G+AvvCv7dA/McxhOliMlE4goMBcJtyncLmMbfWZgTvpu4vXwB/zX/d/M/mzJWbFGYpdq47eCAtYfxQiUlNjNFoJ6FpV7vjivF9Z+QdYUej5xLaV22mdYUUVwBftRDXlVP8A/yyPbpJUym8qrf3jCOMnm428JU1UWKzqj5kCoY2SZIfspsOViQjOUay53Fm75HPn+9x+36xXtmpnumygzuHsOMHyjkSrQ7jhF/QO5SKi8tQOxyTl1NUnwbT5YEeMmyz4yZ63rDO/mavSlHPCpYAqxLWNzrd7J3RNfn29Ff24YvDiVyeWOz2tjCsrOL3oHmPMuZAVy/onszDyTZwhW1XOpCpAyo7qDjogVIo6IKPsm86vRXexspJqjoxu+ZMaCcy97B/JQhRnXASyXm3TPsFc7eW7jN+yJeFWAwmYh4Usz9U2LLFpYr63D0GtWC7t9tBp4YsWM+8rWynjwrwLBj42Tp1LI+3+58/xzspE0IOX128PPzp8OXnz8IRWTiufP6cbT+BPwDB58853lDJd374/DnEX+GO9MiqX8MoDj2h8v8PIgAnnvv/v1R6IbGBCxI/Ya49BH7QhTSDH6rPTSL8ZDL6k9283d4WyTSR+q2IXCDWRPFvide+F99FWZktsjgGCVYgYS4w//u/nY5STFdovYeaSJV0lYAK6lU83kD03Ei4u47hDKG0AGGYh08J5kYCqL4R0LF47TGWMv2eNLgHj3SQcivN8lgR87DoP9BQYQNo+kY5nbrZ5Gx2mRUmhA/uLBX5OmkrTwcoFKP5PKTdEi1pLldsbf+MnivwG5KLde7b3Ac9t+OtT28aqLwB6UC6alLKECRAdp1EsGWl6lgyaloHd0ugVdHTZVSFVBs/0K1gyfgcQiGCnB2CjnZPlWlMsiSGDKO5eW6ViTbmlMgj/8YKJ8fGqt8ws1qzik3Co5BiS/DELoHewNJDIPY3+p6e0N/4wUh5gsENGCNAYU3J6Yh0Gmljt7+FF01l2nSUjnYHehqApeHuIz0RL03tPtHTRskcIxjs9h9DutGgotZoTtDToCqfeytUg/Qf18MMHllhGH0Fwf9f3tv3p40kjaL/76cgPPN40dAQXvwWQPZDbJx417G9xpkk4+PjkUEGbUBiJBHHm/h89lNV/S4J4mRmf3fvvZvMBvVrdXV1dVV1dfULGGqo1tiem3WpRfKhsr0WjX9FX1HCe7ExBqqs9a3vPha3YhVaMzKznESU0TfO4Drvh9DkUPqLNUQj0j1TUWhcH7yHZS8ItGNDn8XJH/3+s+Ymrp8NyS3OMQeiBTAQFGeJL271mqwQyZnvjbXdXm/T6fV2WYTOwk+FJXIbHfm1DV/Njh4Tfrc6kdtms69u1OttE3Bc8hauVpAR11FEGVySk7rDZlW33azN/rvdLB4KH7jyBQrZzMk3my0jqIHuBjhsRS6/NEBGeU5MTbpXY7IukzQozyRS5wsdnbqKyLqKwHqVYrrnPW5sPKuEhmtXmNtV0cplU7wqsxf8APnXAnIJynlpobFdr5H1MOFh9Jole6UGf63ZBX1Xq91/x2D0akZoi1nRihV/2n8zELPKjdqFed0sNRjVTGLAvQJkdoMOuJPJ/xun+EsCigW34mhitkYqkIt3H61kMw6Ennm6XtBJslt84givhoSfxvw7MJEIA9cKGgBV6c3g9HIVGVjZOUqwK5vEIISE/3/QgxhsAUnInP9gqlBT/frg4mAVGei8HA3orOzU7euprrb2iqa6YFaMKr1i8rBwJfewvCSl9j4hZGopu1hUcDrF6Roimg1xQpQF2y8+OQwzN1yERUefdZo+ZYgP8k5PnZ4rfnrOtzQYS2NxctNjK0O23vTtpvJ6lrIS8gQJm7RgIXny3p9le5fRVcKs04EpY+0rHZab70PQODu5GhcnA6MgHvxRuWJLaCgtoXiHigqS/9OM0JOzWH/9ms0gs7W9VKxhMVVBWabzjYjWlUqcu3+doRRp/KMgNLItbeomqxbHhXW7cp8bED2MrFgJnY6cHqoJlXg2d4ETvvAgndPLHo62/qurmFSDDOWhMJSHuYOT0LQqhxmrcqjsyE4xE/ZXHFWsWDjSrmmtiH2e2eEqdU9o8fpGaMdQtvd/lH0UZxZqpyq3UC/Vpuu1mas61vkr+tYFRPdSmfthvaCQSyNC+TG0sI6HwjpusUs5NZkL+Rm7krhOvuIUoNBEpGz5YlF2DcowTS2ce1oajEzSYqxMscQZmWjubzxFbw4yxeQHa4xd0hQuLpm5dmNWRX0bmdvI8vZyO3aGGfBC3ln6Hnwm6uJQ6PK7nbST4JIBro/XMzY2EpOzaxR//WrcQVzZiWitaYgshfc8AjJRqOulwZ4rr4Si6xdnOYInJYInWbcks1cw9d01bmSf5gJcyOa7U3HxSXmtB7VEec6T83rqTtGTXCSKAEF6jyRvE3ndBe9JkLWSzp2NnT7QV1LE+RiG3aC7Q8YJNPqtr/AEEXHKpq4eOFu6RulaxTa9o+d7YruiJUwkMHlt9mqa80DjV0mvphuJcjvjOL9KpNtZ5hvwMwU9VzqcLXl4YzE52JfePeyjw+zgJadPDPcKo3Zmmg1EqPm2S5uHm5krucmaE82k8ERTzt5MzV7EjAn2JPmGctt67H6wj5XcFyKFjPFucws+LXu8uwspJ4PTV5ev+b1Pt4VVTo4vBxf9E/ja2sZPkaczqs2qXQ8bFqXaDfiQt2PdJranLuO6rZ8/6CumAjgNm8KJ25ZDoa/W1q7IVe6orpFfNWpSq4bJy223IEGzEXcTvw0+7W4jhJpLuzvYt8Wj3RfYqObQbrOBZTRPdZtNTDD5s7u9jagzxTW3yRO0fOW2eIotvdHgbcHQ3YQkYYSkbCmU3oH44lZi5mP0dBE90/RAiQ2nsg8F7tgfrAUR4y68sgLI9Sv8Uj7kHNHiVY5oKamhK92xY8E/PnD+ETORAP8K/hGvdmXFY2piJboM6DqSp8Sch8SSp2S+3dhwxxaWTp1US1FXEqeaHwpuDlhr/UPGMxp2HBJwVrqKOeSobvrs4MhV57Hl8x2v8SGLTR8yu2CmXo+ybU/wVRODIWStPmvI62PTXeg/YuLUjmCDK663GeBy1dhIWY8rolm5seWGc/19g6f7UKSZZya8UVT82p7TGjOHQeGIgPw+5P2bYtK14nV+Wh8K/bRiubPFqxx941WOvn7Gr6sYrEYxWPsFnLDzIefXFZt+Xd837n17wJ0MM8bds0Cxd69QklumlQbjfzTz5Qquw0SBTbbJduE/mzsb2VusuQ0lVuZvs3YL/64ssIkNwF8DhFl0rwrsYl62iXyJZmuX/ltZBupjPmz+q8qoEtBSo7W5phgWwf/wxka22DXFt/kUPCG+jQgdQeE4RHwbOnzgjiWpleIlvgxw48/8eSKD2xC34+s5VIFVYBKpTRnZXFrc9xqPj+xkBWgCKPJ5i8a+GY/EhDCbj4Pg4T9SaPw4G1vi+2NC/Ao1RIhwtXqplVjF2uDhLlQyIudmHCRpNk3ce9GpIoUGYCZj5Wyi6EwE3NDBvcdUUIfBKFGc8X2zlSv/umN9Q4FqBcMm7TjXZkCDBC0H3w5O8M3ABDJ6gQpADnkCTBEeo05JSFh4pekq/bl1zf9B1q1iQQc3sGH5cWLFiWvQRfWvGGqK4RjwpZpeDwQ/uTFhcD0VEw4NI0Z7xMu4O6kKdgKq7LY0JkkM+CIyiqN+cUdLFSAFvV/l1x45f61BiGxDII5/AOS7RpM1d1fHoPNDQlci8cX1eh3zOrbi1lB0fDYjKvYAER7KHbJA16tWneTKu3YxRFxw5YE00OuJWFp4rbTnphRI6wt3XPOvZjQL3UjGEsEElACM6UiuomsQSCKMTitgJmMkkahYLSKumPQBzDl2WWPgd3bJpw/DicWW4lNrUnQxLGKtpKvkGlVwiq3f7EElzpxmSFb4JICItW8sMorC7SZd3pSdA3hxE8Ilh6G5ne0VFxD2Geb7HGf61Gst1D2GMOU7NDqhx63soNfbWd1HbSffC65ooyeMEZlaVID3DTxibNyIQY27zc02HoGbjOzKp+lH2oQZ9q52YaI5f4TyQL+ryr8Q5V9Y5XderCq/I8rvWOV3d54MT1zXy8SuAkxT6b90QZ8Gq7HOsWcyVNnJFsunZ0jfZ1tczuX9iVBT+IRWkAfDIEgESmn2GkKm58gxOi9udmw1S/RAEu3hurZubRizy5BERbGrz1SLLzPgnfBW5WLHJS4D8IjN1KA7NTiiOl/HjyI+LyhQFj3MFR2vKvrSblYEmpIlzX7i+uD0kMudmIn+7DJOlm+HyNJ3GOSdHwyVZewYqC0sF/aWsbe7v2K7MHeFxtM2hZVbjIqQGC0eVLQjEdyHSFKBJq5umhAF8jRBJvwfHkHHCgW1MsBHYBQ1flZd9U5DMsdXT+NsuCGYC2D1wc8t5fl8FV73fNh+vn7Fn7DZ4sfGRgK8qOcmV4EWQH4HMEIMFGbvenSxYwEFgTcHcufqhj2RgfOIZxc98xOIX8CXMlE/hPWtfuMvHoAMn/6osmdmhaSgmANioYTD1dkBhh4i4UPnJnre5vQUkjl3YlC0ITbYjEXiRqGgQdKi0cTrZgmHPJKrHlBzr7f7dWUuDjLMVZ7x7Gvm4TVfccPHFMrozLVCD5Kae2KIardZbla1uBhIuPhyhrntzq6ZFBxCtI6Y2/VMNScEvxAlCJaAxo1di17oJWirUyRm3c8420+i+qH9M9dLgr3Iq9NeT2Ob+LjRkcE1jIDAt8tgNiZOYx/NSE0Eg5FrtcPUovDREiNHaUIw92Y6KVBIC4zOR5filMGIL+jr4IKxNvQyLr7xMKgBSWl0UCfqXuEldtnItTslGzdRM6AIBdhASHoywLAu3Wt1naVb3EyvtV+tTjsNENeXkrfyVpfXBKpgtDCpoYhLINltDdb7kov4nK9r7W1KBy6yGwwXOwPBvjur1dBDz+QMAZs53aXroRYg61zppd1Uy1M3V6shSWRaaTp0rpOpjjfrJa6vCWMFyZEcO0c6CNUR6i8GHioa0xgNhf+Orvd1ckenOrCS1FxQW/hjaYxoSca/3AC6Mo6OwpvbcrqFIOuBcrHpFh/aDImgmSlIBWxK98l4vEy1BpKRF6olYHAxpFe8mZ1iyxFM/xTkuqW7KbQLvj6nbrO9C6lth6VXlYCCeeII6VBaCNtuQLKwhzGFoLVKIkuxZ5VqNepNNzYwFP0MvTei3nJf7/7IEqtu1PE47eM/IZoYrPwq0wlx/WJwftO+2aYMpxMB+27sZ/J/hQLNBpXo5LKazRsYEW83otemPPIcge71WDsEL6Zs8++KwI2OcUi850/AqoVCigX2LSzSuQTg0eEmZoMHehpTOtpExK27ZFG18VxZXRtfOsqycoV7s5zNraNam7UcOS2Vgvp8bta30Oa+EgV1+eStq91ssh3YL35gZh/tPUP0YIvI0JuxmAyhFUVRviFIrkig5QqPReFxvrC1VfkyEC63/UvhGZTpdM9tm0skxl/0ChQIZXxtYqj5FOZPX2ATbL3qtn+upEBX1S34s6kvHhIOQYSiJpOMXChHbuA5rbW2dthWFv2ghucTk9om2yQ7Bz4iRK8H2QUKxxLysbC22ucLkJ7Wmqq3AjQDOIa3RuqPYM+Wt1K1HXGz8aK93drc3NwRJ4M8XrrbbmK8dJaSlQpXZrrRRMRrRSUQm7bpbMFjvHPBUJds7l4/E9G9dGKrUZS4nWsSI8ULwNotgExLcRTQPdNVEVDUQg5IiRp11ZVeQjTsQDfjKPS/foW5z9qHWL6cy++jG/rqSWACxjJqt6NWgV14bBceq8K32aYF1eSU5ZU6GZ06GbqviQDLF8/Q1ExCreA7kWcXAyFmYsTiaiWhS11ApwzdHjPK3rOG1Qn3B/Sz7WKz/cvjA/6kAjTLW1sl3eZt14Zt1OzODrVrLmnaoVDrJpfMPRI76UBI39p2zXvbMkaVWQAdP3NrqoCRyUnJZcipRfUhy3NJD5Jcq13dgUXYZp6l/+tkHuQJ2D06D7ugwVa3WFDdpGTUyuhIbuUkdwqib71HB1TcKcL9SgENWJOVo4GM4pizK1mHAXqn0x0cfjhd1XqOUef2nWozv71A2qzaLITO3sN0VHAnu1h4QCfTcGGSmoyjYcTPLhXruVqDQyF8dazkfGnc2oqPL2aZsiCJi3IyBRk5iQJZVgkiYkXZjrAUhfnQZXKW5mtLi3akgKptX0oXTnmmY5qpXDy20reP6XmLY+P1kGPzmZBj/UzIsfVMyLHFh6ikSZRUXhERlTcdh44zjkPHOQenY9vBSQW9d49NBye7XvfYdHA6thycji0HJyOGfvfYcnCCWvIeeHNb5nHrpbsD34oHCrCEPMoLK+HSbe7ITy4vuk0cpGHoyPoeXsmja/mnKf60xJ+2+LMp/myJPw1Qho9N08bKlmVrshWsvQ1/duDPLvx5AX9ALsa/Tfrbor9t+Gv0cfs08LN/sNsdakbKV7km8Nh7hzV3ofQugPQCQANYthCUTYQEAYF2mps4ki1q6/CY3tM5HNwAHbhbTaQzk9Xln4XQM9/CNyF0+fGKRyoERfGy+sSkqKQJDJU2Vu2KpyO4W8ax6RtHONJWr4KKJs2r0gjZavBpoJLFkzMaaO7uHrcDc3OzpvxailsOl1++uj6eIMlS3BOcHRum4ZjFyhItf+GbOkZ7uj7TP6tuWtNlaBNa16VV0UGWpe0Qtned62vbmgrbDlPApGdzkaHNX2FoM9O1NwObFWXANJBNSGdodwY2ZUs2ZhM2YgvWFyazCfw7kYHk6JhtQqqJtJ9cTdQRxlXMLTCxNsoI4xubujoR+Nm0Z/C67hQaXIoCV9NrNgG9PhVWNPo/2JgnexEILxM3Yn3cK2S2O8FA7nuBQ2q6ARPsNiPod7nn4pPXI9e7WtZm1w5buFQVbURK21v8XJlUQcISur4WnTBHmvOgAH/3ss8vVo2jLxw9+F6yjQ56w2yCDwObyeRzpb+xSbdlJkVYpF9zW+I+XR/P+EUfXbqf0IVG6SwVsWU03V3yd9PGEom12hTtIWOOmPRqTEOAQhMaohp5ZVKTmc7P9OuayQR34rAl9Edbb16NwU1JvUcM+65yISFnnJsg65UShNoVqSDwIVqGTepjc3bPhuyOPbADdsEu2YCds1MdacNwXR9I13VYPEHVfOdhiwvI8mEPdu7K6Bx4Vl+rYDhY42WRmRvq6viyB2jvaEE9rd+TV/0Uf029Tz5b4i9slo3xF4+ePoGf02g2BsI7rdMKXMAPwDMt7D78Rv5HH3O30uz1KBMLOrUmuxdJWEakdf0OUNmoR7F/JlV3QEf7vd6IjaruLsulOGzoLq4mG/PrbtoxnHfv3OEe3q+BRQRK+h0b1eD/eCK/lQMfSNPn/CB/yLlZV177u9tobjtfHmQ6u9vAV5/vcFn17oogc9hDFSgNx3OHQzO6ddj3DacPw7m/7gbfORyEGEoeZGBeAe+qdJDuD1YNBDoMax472LsTMB3UIA3fQTitJ15IR6n02G8gnlLGefXCkV9Ko6h0hy/WeaOPZXZan+POG9df9g/5ld0SvXh5Aczr0h0DpclrnBf4NDv00XuAyQAI8HBAzNj46gJfgJemzDunewHQHUAD54/q9uayd6faqS6xpZq7fGJzAqAlFr6DWt/TvwIAOl7+wABo5h/2Wl1Jn5dUmK37gubb3QeY00wyPllvpzn89vAX6s+A6NxqtvCLOuEgA3iO2d95QX/nZn+ID1hY25sOn1+k9IogVtBlNc051+oh1FLAQV1FWMhZVhAUd5tf0fPi2z2nj5oZtFvOF9XJ5YfzgeqlCDrQ4vzYmz3nEsYTYOQIDXoJRl2dAVbdEVovgpr7gAvvoddrs8kGMcuRQ1H85P2WwHjDiR7P0XeYesn+VrWS1AKns1XDi1L2VU7oaB94fbUyq4VOB37VKmFt5jDOz0HG4PzcHcFeeBMg1Ki8wS8cvgsSPW55frL6qcO54b2JSm7Rq4S4seDT0PIbtsuJetFsbDy6Ri/Byw+6P2k8z2a+F3hvPUZovVOInakPRNrKVwoJA+rtNN2e/TJfdHeHL1o3DAdaoyBXLvRrdmIbNJLERqiGKzZB9Waf6f4aGg+/haRSGBhUGTgmq/0kp3m0Ww3xOt19FH/MP2O3u+uo2iCtZ0ZgpyDPV2jy9Pzce+hq88h+ynnpJvfeAu8S6rfd9tQlWO65ugursrWL0awqvvjZ6+3yTyzV67U2DXelJweqXH9FVR+HFAatTBXJ+eo1e6Jj46qkSMBL2nKl4wUXEUmSwlWa1M6pu93a2d4Vz8ULxCriU5SnqClVk2I/6YoW4LO3r16jfjvkb84LYkv1rK2ogsox1aHJxMCXNJP6PncBqv8wmlO9MvWyVGsSrYu5eS2Co2WGDv6hq7QKIAw9GVB43VpKQaAr6d7eJp7gp71N9AJOUZjCh7HxN0aXTPfguyCWpmQneI5KXvGCJ8E31rW4jbpFGzDJudLM8NFwnhm7Ch34lPCb/P1tP+nKi80BC0wQBD7sTnnrEjnJM+MNcfN+NIBfAJrhsq5alSDzkIbvLJ/Du+CzP6brIokgrLj+KYgnQYiHIUDxUCBLvlvNFho1kLgLcmG3FnQnPGDSXnNzEz29kCVepSiZ7MocNBdaOS9Uzm7DztnRObtFrf3iy/Hy6y8VcnceMl4SjW27u0wOiceVBh7MvuDEd17go+PkENlu2Y1vdQsapnWrW263NDqyLW89Iq44SkGHffQVQ1Gw+GozeoEGa8k+dJO+3p6U9/9yMQaIZDjuzCFSdoV5kujksqh4ggmAUONx4mee4gGe4gveijCkojr6me254mO/4pmPnFn3xEURcU0835Nsr4OnRfx3TZRixtOKqztIQF5L8OFEUQsd4EAkS9YBlWTASQrAEXn4GqIs5spsjkY+EkfW7VmZmAJ1MbhHI7Nan2iSACTljRKZ2dh02BF7yV79ceNxLmbpE6KLrg5poB9b5ZuyK+R3fDDMlOcPzxwdGgDNJqE2m0zNt1iJsqUVJlFWmMiMMbB0A24UGcMPImy04Y3cKTsXjLTrS+U+uQ/wlisHxvky8uhuJUoOHbygKKOioDpswytiXVEzY7zUwH1/9I3hkt+NajW2rLrJlUcaPgAEGv6janejtbGBunZ7axv2MuhAStmnV41rd0lmhVPyU1NHcbKMimUlEtgpTCKQ4BJqo/SigD066b8a6mj7gRLxg7p4JIL/qAsLm8OeSeiaztevlUplKeQ+FAIBkF3H+e920zA1jKI49kdpaUpxsUsETlkDoNQt7B4ag5FmwkWrtpbhxzC6D5WDbxCFJR7qd1V7iBh3k41r8H8Dl7de3cUdllglzoX8PVC2pcGeSMvZSzibKOHiLe6RS43AMUULKmSWnJemrLbcgD1yH/eJg8tjDPKPVCOnhzfXFcRGU9T5UULi87lk8ifN1p+HYdnq1k57czPXjphzKlIC7roCazalYbhdJOldFNZV+018qvaHCb+A8i+P3wwkivG3xDBu70/GcBb0YA5T+3SoT69a/FMYCU+v2vyb61zrRrVZPKqzoRzT2Y/RTGZEnwX9CHBEGF+ann/n5Azeg2QmR0IfHYPY8F4uj5n63aMTJoJljr+JM2ZQ45d//sCEqaqoSy6pd42RX1709cjhIztyaAA0EjEStqBDqIUbOWyhmoYfAzc7sJqqY+YAD7fBsQWEbCOOY9UmkSnRIpPHvOrCYQMni8OVmEpAjPEc9Fp14UcV/k+CCQmO+nDUzAbazKOQhiFOJM7wt4myVmNzt4BAFvxC64BIZIGWUYk6ED5kHz00QW7rGcP4pFV3mMZBOKnfxdH8QESlrAzUTQeovuhFJCj9MAoGjmm/zBEOgqHoJo8NEeBFIkR8mjihNwb/JJyIAJ3/AWgRkGRXFAa3kbjA3x0bhB9jJCBbwCYqYZWB3uT+J2WdeFSaBwm5KBVufZI9ZEeCsT9dAePe3ouNJrOksIaTEyzMjU3Zv+WohZDxAxtctpu4Lm2EywKujf2YfSKmnwXKrqZDNyqT+MyyeU8Ny7lnGssjxiV24tskro3J/kUBL6jXlYKWwIfc6OF3x3juRD61ID7J60qhxKhzeMapBm2FzhcSK8cbOyhY4j965b0eHPzdlvzbT0e20jXIIgnCKlvye/bQDfzeaAv9o9FRHXJnMnO2mx3xAJ+22gSOhhB20htmD5cPp4W9tOyTD95iS3d32X95YtFWu5MRkcnnsIQupTbBP+Y6kejlQyDizOD1e4Ux0h/4SsS1yeWq/51ZmhJQ7lAq4OWcLVkt5EqxQRzd5ij/4Oz8QxavGTKiIh2rhpmF02Zu6zRsc3PHc1z4OUV/ERMZ4Yo9eGZyTtxMMUC+tbsq+Xsl46D5VmLk5neqHnQoAlMC6mAVLx3Q9G7h5KLkxI9JRHYzm0n2LaGwbTJTj+Pt7rV2t79+Fa3stRtqfvEoe+6FD2JOS1GsTyOTh/ltNEtWaSHcoGUuFTQPSlyIT44NXronAO2qPaT9nbJocvXqircFWShkCiy1caztR7Ov5ouuU1Sn0ZUUSjgLxCEEn2jilTvsyOWmRpX2yM7dAqslv3seSKtl8wVTDTPEDFktjxyj7SNuQDnPrS+sI9fVOtUvg3SEwMS6/M6iHV2FxOxL7N+7CtirJR0ZB4YzyzUbuvfcR+OOfgiV68G9F4v6WWXYc8fOdxH5A0gNDs3YEGdM4k7Pj/vAH9DAshTxhAP70h1WW0AvL79P5LA6ItSR6SnLg4NUUn/sL3yvGPcD14IVMbRw21VckA4zuLU6Zif4dzT87e+D3wR+AFMuOttxLIonZMkedv5oD80mdtFsyU5oZ9nh3IkmaLFn09IP4pLob1GrqRWq53/wyLtT5k2oxceh1m2CYUSuC6eSVlGthlJkAsJ1CZZ2Lbqr0a61drcShwVPXfh0DqLWPcfJj69928FizfJHYNXBxTYL9NFGIE9GjSHIkivGwI9cxCDUEGhajZYzY1G9rxyM3D2+MYzV8lVGDsASHbO8kYFCQLTngnY13UMHfwTmz5CVb4J6xtdx9G+1pxdZ88W5tWMsGZHY+H+EdaN73d1Ga7MhnI4QoAPgHBfuHbsEtm3CdFlF0RLhOqheoB/S3t6B8xSwDqrfCRixqQNkUweMo6fqHuR5P88YKmnOfRD+kvoY4uT4UtMnd5FSk1CkLPJi25vOk9ylCjdzbkG6A6HNkqLwCqOmcfjiupTx9NFLV3x+55YoRl91JdHwNmtCnBTfiDT5U6JOfEMT6A1jWMaUKjs0VNnhZUeJGJKRKEI1vGP/PZT6TTJVIP3H0mkhYWW8BAtJSjhxPbBi6sKpMchLfP559MW7/0P0JSDlcccFnPSBUE4tKEgFHNWQDHnHe0INdGVCbcFQZKFTYzTJfY9bbwF+qS3k7vuVBY6BH6f38RcdsC+cTl8mi67Vi1haWXXY3JVOK1xanLshtDKrSbCZLtw1FFnSSk2FdByVwqsZik3zq77pfbswLJ08DoPJYBxbawXOl8etaFet9CnMuLULW02QIUef8Gr9brU94mvByh3VaJ9WnmpVdwSd0if+NN8flIYrYfXbz5lDQzZis9rI6RhB/7N5Dp1iS+vm/rJj2uvQKCIqFBzP4lXgNYez2lKpUfbq8rXB1+FLIwxpk2B4CubWWFcJVRubrRebL7Z3Wi8sO46EXO5LT4cdQ+IqlgG/O/zcXz+v0c3IbNCWKKNflciWeTN40zH8HDAOPS8n7VwfTg86Y//OW87SzgqHiMc/1UJaEcv469fRM9cU6nB2EBU9GplaTD1B9/pNIvFekoP3hzPuREpcNITIkXV3ZV+vUUAGs5DidCqTmilDjmqW1KkdPavuZM0KktT23StJQ71mSVmFHOtldI7kqjDW7m/zV18zcu9+s7WbTUfxHw1XKoHsgvugAeJN8cqEs7eRy9+GsqJOwzScG8+RVzhF6uemQHnJeBD9kWdhDGdQmnP+jLvpHGm9xVLojvrKfg79e+AIMnAonxhHvTJsO3byExKMlyx9VbLPpAugvvnsC3e26j7l8faKfvUlkS+4N9CnFKeXXnnB04l8vUTPPxYg77UmKGEGIYbiKReGLlTCw547tGoe1Kl4bm5lYrXAYd5+JVm3/gzvfoUpjCvb/YmbAUEt+4nsAm4TfpBy7bbgF71QgUnkl0JJ6D7htuHH2dDdhH/owN7dol+XF313G37hsay7Q43TcaS7i20dXBy4L6h5PKFymw3x221iD/Iqw0/iDMZtYif8wMBtblJjsHjw/jn/idfJf+JWa7xK/pM02uI18p+ULRHvtVPWjdsSg3RbTf4D7+y3WmLAbqstflEydijv3mPpY0jD/ohpui3RH+yDbgu7469gYFficsZPOA8YnOYn2gwwJMxPpmu4u7tlpHCMb71oUa/GOyc/aSdd18iCdOlD2qDLH7+k4vKHIH/YNpEZiFMm6czWEntROfR9FB3lwijL4ySRjRd7vTkaoEROQ+bw75oqeQciW8mP4ygWOa1sG0ZeW+aR/GHmbMqcIEyWd3fBKPDDtDT355EErrYli9xCAT+2qm/r6ujNBBi4BbAwliyMr9y1N2LhsHQfiiYeYRkQCv1VV0a50cmIs4y+mfJVoYhbQchPE2QPcXUZpOQG99aE/zDAje2x2UAPzeJozTLg9Kv12Wfsb9DKW+b77MHv8ju5je5SxCMmGllWq85LihhI+ehrNu4l3TElp1dBdXwt4/yChA7SpK462sOnp15ejfhl4hFGqaIjqhGJ8yOUPc13G0mkQ1+41ubX7c1er7n9tcGKUzm+gA3J693N7qQ3ws7EzWW83s2B6k2ot4kDmAQtDErmxgdA3WNsUHZfc3Gs7L4noao1EeR7HiJW7L7A6riA1HR0Kezr1RVdE+d92F28ulribWT457qKXeSQyVEpn6q+eqVxe41qNgZ+0t3vw04+Y2cZ1xt2BHzK6SipgYrF9Rldlz+tuXiidkYu4qCy/Y1/H2F0DeDtWHBMBc8o2A+UOKInEe/EweUSpKoBSJB9UMCQLC/QKDTEeVmwS3coHrzg/W5sDPesKyxfv8qdCziUlctvqwgKaKrHet66y9qcza7G172j/YqPBz4PvovfTgf/f4+nnl39rYqf15h7fnXKP/DRN999sY2JsBs+IJDY3AH+6MMCoyuSB3gXL7waVCt3e3tzp3pw7b4lIvN9IrIH/2tDaJMHPKoeAicaA0g3HrrOAx6249w88Fh7dxvuA2Diruo+OB3CXLXKajVaP/IGLPrnjoQ9f+niLBPQ3BKyIBPjJSpeF1wRmgvtdY6+TQOUbfuEm3saTLdfnSPdV4hy4QMvzN/38F2TrgP6MCO6RgiHVT76P2OWLlyAEXB3ce0uCGV9wtig5n1tPEqN5E4GlwUU310jzNYSduQaXjCogxcixHLBDQu+srucTtLbHKRJwQN+CskDfknRA34S8eeY4FWborJsUzyWFzIQS5s1t8i3/QVrtVlrh7WbrL3FNttsq8m2XrBtKN1mL6A8loPM5jZUebHFWlAWn/VoUIwY7JXu7RU4zhf+3TH+7hp/X+i/rYbxt6n/QvWdFtvZ5d2OiwfbpJgwOGB018dhIrisDWkwqC32AvptYTcwaGAJ7d0tGHCb7WwjZqBgc6sNFRpQuN3YaePjJTtsu7m5xXaxSrPV2n2BqIBqrc2tnR2NhvE30WAO2hwoH1+L/rbp7yb93aK/2/R3h/7u0t8X+Hd7E/5e89ANp8Hqe6z8+Th961E/DEifSkM2L6ca31yLzdZHXdtqwEjQ9w5FgrxyKN9Bse6VKo2xJZrjTygLAeOjki9AEhdh/O6D8cRPkyv/uk6JxvMUaQlT3vjh8jj15+bTKDdmhllh7INM4hdWsbOsSkGC8s0bL/7ox8V1i0qYTYxmvhcfwuhn0WSyopEVZcxmvPF4DRS5XLPqnHKS4fJW5iZW5YJ8awBRiJ7ovH1RyIa+oEBBA+/4dK5pwS5hNhHjbT9E0C+Bf1+IgcISZhNJ6C2SaVRMNNlMWdFbLGbBiF6KejWLbr2ZeFuEXMtu+IgPMNDLuR+/9z4HCW2H9PIIcYi/gRbu/l6H/vuz2XkcLfw4Dej+II+li+o2iNKltH77cOrNfSeo06NbybsgnVbKYmbKZHcq6q5afSRQ5l7oAeGoO2s6BaF472CAediax/h8FrWFqyQyy8sUuoUZ5CvMPZD4o3huVlFp9BQURfxXxACI5EVxJVupWPjCF0+ODPGqW0UFk5oj/pOzhR/S68AYBZ3dYqAmPHg7gkaOvHkwe7B6MsmOGp8GZuN274w4UlGTakLkax1F+JYPnxQsmfoCo1eugKuOC1QS3r/qfblcj6GwASywVO48XHGYj5pM+XzmjXyxgkvlagVTzVIVjrcigJBvLhM/Rs7LqUoMyFsA2WOEykcHI9PKaaYoqcVL8dto1VNo13zqZApeL4F37eYRfcbQEIOz2RrcPWuqv4BDKFsS7ZfZqiESFObeUQCC0f8ASj4ZgAPx4pxfwp1PwFKWc4edclhghyMw7P1oPSCXsZdMnwzJIbVcCAbv1AbExEf9U5Cg6QDtiTkYjUyqWMiN1w+EqmDxcwoK94TB0BVwOq/5BNXUQKy+5UgKAbKHlFkHxVvyN6gCJsPXlZ5GHNgRjYJXUuPIQPDUkWS5MDKbob/wYo9kxdxAc6LDt9eerLFmfA36m+Vg1vqzGCSn+yJZaj3GOUE/BZwmvUpZPuR9lIApKJjkCuBZkCPaExjPYSi7FIrAzpRZOyFrxjeMZsH4lbec+N9Y4xrh0HzJKyHHpsqlCdZWg4R0as5e6KsB6IeT5cyLfxQEUT0PhNnuU2E5DCYBLAeYwsXMe/gBaEQDJdGCCY/d9lMhehV7i+kPAEL1rDnBBN3rN7q98O6RAzyZ7Q+n0X0p9u6JzYhuvbQOEq9ikFkJeP2yk6WfDoGooMaMLQBYEseFQsh3rxa10T4ZLi7Vl6w3YSWMvoWgNWvU+/T0DrFwKYz0dpVAQgWDrH9r0k+iyVEw879v0mHv0AwOhwOtgHJBJ2TQpXow4sKfBEnqx4f+p2Dk9+M4+OTNDrzZDF1mUB1/X/9WkeKmLvx59I2m8kVkU+tkyS+rJDm+cQIXP8DcMAVlVytb9C6CMi1IV5xAPj+ZoP0iXCvu2p2xisdmArsLfxTcBSNeIAczHY2skIC7oZLUXW33CK6Z+RGE3Jspuiu9wZgZifs0/iMpwlnV2rtUtPZd/PWbzb6SzT55D/tmk29kk9+xK5mNriCYjISTWN3XLymyil4q35hnEUCenrSYS12MlMg9efqiYjvJSadbe39cvRALPZHmMn478o9qC8UaQoLNJ6UsUfr/Hqk+KZDq/X+f8J1o4ftECd/62aQMG/3yRm4UsoDa274U7KyGUi5ydM15EZsrlC+faTvMt+RPpPycDGvUXyff0oMLxaqQ0cKKEpl2TG3SqLxCyaS4WZaSaQ55nfb5BF0vNyc69yl7hcUfjB0bt7CXHn+YA00rWbOG7sa2rtld4KnssxXad1ZEiP07GO5UU1BmnXxZqTEqKsyuLNGQaZb4koVGVbYN83kN6stK/Ug1ka2U6PZyKvCX1Zq5bjC/dtUDSgYDU48n4aEEsC/fxXAtY/8uCP1xeT9v4pDtd/zuZVr3ko+VtE5yYzznjJLzGM5BrAlO60Hy0oc8ZOv+2DDASpJWCfVpMPYrFBuR2oSft4Rkf4zuLJo2s0SDJ/r4enxALxZq8qRofrpwgvZsv0Kv92Wb6OHBpmHWNYCTSZLRcTMqmXclco+AG74Ng9+X/ql/j7ZsjeHvX1O455qWcN8BLFaryhWPYvf6rl8tl8rV1ODvsC1IgLJalTDLixBnQQhCGGSl0+etvT0MqGhmvPaDyTSlnK7fa29xPwn4F2am12rwT/jXES56lVyrNd/hDSd2Jm+5lorcMDeR3ZC8MgI3/LmFrxPiP7wbHpPkjV8h5CuSIcebne0ttrkD8FAkkhsMjAFsMj8n5VOlfZpiFjdeexiaDdgBbJn8ZUY6qMvRg50qKdbU4dbQt+BjGxtZ3rHCJiBm7Y2XTuvzIMwjmuWxC7jNzJrw6FwzTUHhNOlJ9Pls0T9eftI8mrTU9XDSAvqHdzrjk5ZmJw39pdo7W6xNRPSESZOWFMJOweTNHDaTk5eAvPpvnbxZfvL+Pzhrr4pnbWuLtRrNp80aN8H9p85ZsdHrxyZvFybvBZ+7F+umbvPnp04elPxD0/eucPo20S2GCj5h+rIGQ4e3Hxlb2hS2tGl+S5taW9o0v6XNKAX2tQj2tYg2NJ7k8n9oa4usre0/iXqE4KnPtI+gcaCd4oPmfMM5wTXxwySKT4Ikfe0lo6kXTvwxCXwrepL1BvNF+nAhuuSqMFQ7FNbN3z5EozSq/RIkS28W/Ivse6UB+rb+5S8HptGvFCSl2yidlnxsr+SF4xKOo4StMn6nxrYSltC9t/6bgsNLHkKQgqIYDVqzyBsLWHw+BtO8aeOkksM212N8OVVeKn/dyl8Oe1MH8bdS5l3hjfh06pfup9HMt8Gsl6GBey9IS++5YPx6eTsDJBtGsbRImEz3xAusmojTaxBKkzSOHiomLQqRMuUiJYJzFEfz929O8MU9Lbw2JaI4Xg7EDBN6rKQDLlNz7TrRlLOmkMCKYDq34pqL73TTZzC2z/MZagMHFweAbIE33hjNYUkQW+nWn0JzpWjJLwo+K4sVJScPdIKi6e2sBc0VusJvNrVNvUT1C5+gWnzy47+8i5azcekhWpZmwUe8tgg0iH2VgnT/N2mGKYKBrYcBUfgo63+7IL/VYiLOTc2ZVDSPJmY0aF/4sE/Q7RZHWLSPw/Qw+GQ4ixiJ42i0xPhkME0+3s2Z+fhVKR8e/1KmByJVUeCXD7DIFlESINbcMkVzKheVmfl3qVveWnwuzE2jxerMfx0D7J/dMsjz8L/CIqNlDMzJLS+iAHTvOFOGb1+Xb05cfhhw6vtjf0xmtsrm7s+39ckyODw/PvLQXc9ZaY2y2vTG48EnQAsyRLQXV8ojWGYfrWMDC8Qx36LcchiFvgSQHywwhfHbaPxQ9xb49OTBNJiNrYlxCpEv2/X3y+UOb1xOv73Wv3Bn7nI5vwnYW9J+XqGENVTIx4XC96gjxB+evTn34gTV+voCfyAAAp8+9LrA4+ZKufesVtsrM/q3BFRVNjy5ngNdl/HVcoorT1c1R4iMU3yBvg5QDbzRtBICmsN6CGkoDsCkvQW0xQdeAowGRnlxdnZZ3thIFIlDc2QSFV5P6TSO7sunUQkLwkpelLAp9PUCbPFzuG7yA/0OB6fDs4shdP0e5Ze/Y3jZIW2dSQXx8xmEHocAWdW4UCVx7OIKDIpWUkRa1TW/JVM+ODs9On5V7tzWKYS+7tG4Nlx+ddE/f310dvGm3MmILFKBldUwrqFZs3/66u1J/+JV/+2rweoG0tUNrK/5ak3Nw+NXx5f9k8Pj4flJ/8PKJt4VNvH4HkiPn2lxxqoOs+RyLZRuYJp+gMQK7Db7FYM9sz9t+Tmd9U3ZtiG+CUvm0A+DOXB3kKJ/8eN7vGz0xk8Sb+LzTYKnY/KcJ2dYOWkfcbQMx5VmowFaQbX832Xm95rc+ILP8/l74sOFf4Hg/fQymPvRMpVIXweCYc8folB+jAcZsxnfw7gcsXaf6qa5zcm7TaLZEg9MUmvbafy3ThHblJmUxl6YkBtlmX5SxPsaFGH4f44ueI/6E1TeauBGJlOnpDa55faulSw2tRh9Ty+jxa/0WbE2H1n0lj+nWm4uPpeSiAcvpEAJusDn4dTD+67leHLrVRqsJP7WG1tOaRPqyf+aCMPq7SaVBrMvj11fCcDwuYijNBpFsw4gVPxksAXGHTrlidkiitMO8XvYnCqI9Th12AKIBGvAP2yEx1AztCR3njVglcinDHByP/yy+e4mUDOMB3Ry8g+Bf+I+1g/HWTrgB3kkNEvCChyGnvcRziSKkbI2CuCq/VKlXPWrZadeB+FbnPWtoqVzKJFIQgCtr4/Pq7vlkc/FDJl1p86K3YLzY6sYHnjBXG7jRCSGaGLBqkbZu433zmGECSgPoCQgyGzF4ozxmN6XYkNhERAlk5RKOKtaMakh4dgJV2InGcXBIi3j+TipV8jcwjrdIijPo/FyBmstrINIggqd68Git2bnyAPxfoxiNDCwey5Im5NEApaxImDOUC4wkWY2wdGnm2CIvAOpGaLmRd4WjwQSFnXFYaLRHtGYRS0C5fwIQaNMcipibXE9Q5voSrt6lYW4rSTxyFW28FWtC6kNY036e41v8OVo4Y2C9MGt+M8RKpOV5Hnv6h4fGdaWkp09iifQGDABKI5ijXkfxGBxdL+MHn3TdAUlBFElLx8uvQm38HCFA6+v8HMJ3/IHwSYS93Q5v4VJUqxHsBVo8CCaL4DbA9t4wBuw6K5Bkh/mCWPFwy/ebAkd/auG6tFnNB8le/Qyk5s48kZZWm3aNgQiKdDy9PBl7ILb+nyJC4znv6Xr7hsb6mUlof/OIi7nKk5aLT9/fn9/X39AW8hiOfIxQvTzo4vnGCga5GEA+MRL0iNQBO8BuydB+LG+mC72gaZcqvPJNJ9s3vu3dUW+G+ImsVuu3tZvlzBxAuZqeQNk8ZQ2tpsyC7pp/PAlcLkt4s5HuROoeIQhoSsH8i7GIw+UHH20PCWoaiKqBvV/JoCR4qoVyyOBrmY5X78agtLXr88qZXn5GYTx5Kpx7VDiDEatUszuQxeT6pjPPFcRAiWKljCG3C1s5Ev/JWKARTwY6axO0352VynXyk5P3Aw5cGcUK+NY5uEucbDHb8hCXrK8TdK4clBFn5VIdzhzHnlUPM+EbmpvCOSstHSnP7c22Rj+2WKTb8gxkzVyzMSSPJbVMm4qE1vwGNupT5A7JjmlXKbEXJRpmGnAD+K7GcoeIF+O/XCdeDFZte180+awhu0VIWZtBYGt2g7HzNqyEom11hMKo0IxIZn4IJqhOeLVNErSd9PgmyDlRbxxMJ/E6AK7th5NUeObgJFUy8mDiHK0Et8UkgKobvQ0wWaUFWymupPF6k4uYE77q7MPAYC+nF0QL4EsT7T5KJNzwWmy2eB5oNUPF14I6ocs9wmt0iNvJkS3OVApyiV9yyyEKhI3CE1/3lxlAmJlrklxL1QQby3i7nNpab5+XHNT2uiTs3GRCbwC/ZSAkTsowwguhiZwuuSJQnQ50/scJF8rYYHxt9fOwHpI2Twv9tL6L6ucDGZvozSN5nzy79339enyFhVqNuTGDGnOPgDme9C7l3v5Aezl91cH11y2wKF9/VoZupjEEXq3Esx+Ga/ZP122QbnmkW35bad7l5fIW0hAMn3EF3Dpv9DkOBjoDMTGoT+KuJ2Yu6TEsPf4Rt2sMfLuaYvprngxsaGwC1TuOO3QIZRSF+gohLQoU2bFTr9lolytWoVsyB5QBe/YfeaElG93I+QxJfN4SQLEUilP03TRKRJ7BqfP0yiaJSjhlMnrem7R9Z3zBMp/gnIzwo3ONrUW1cG2VtspGvq8bRlKjVQ4LKXPTIeljY1U6tNZW9TgM/wMDQfrNGPc1wcmTLQdZNrGMyq0DB8tQ4qL4wbqBKqvDaucTFjpnT8DTNP5xVreg2dTopVLvJFm2Gjp0rAHBMcjP6O6D2oYPqlCB13n3seoNAtuYy9+KFVwkidBCvyAZhgNaiPv+QLKmF2sBaVk8MCsJGu3gIRU6p8f2zU+14P5/OaVn0KOFNodPP66WIboy3kWwiqIo2C8sSEaewk7SQJ6KFSPeRk8CBKllN3AMIO16lubP9/Wx+QzPwRW5Yfcf+m2ntDX4fkxKH7fqCI8m8w6XXWWKNDMs+h5N4mPXK+W2vw5W4T3YpUpeSm1pPqFpPEiYKXK/ylXk2xzoZUwmjulsnHmKeBcBJ/9WYk4JYdTMAMOyTnmXmCmdYjOGwENJjmfRqF/Fl/inpDul0Fnu4WfD+Z0eCWKb5Ti6wleaYEV6uXOiqJjP/kI9KFJrmKf/LzzkjMgmjgAKXa/DMkldFAel/4VAVVHPAeySrhuoJNMgTtqA2NvU75TtRuHMR7h4Vil6eQRJd7rI07Lp9VVyNKuGdk5yDtnWCVg6yDP4uIr8gy4ELAsLLH6SBiPLfPKrnHAyBXiBbDC42Tme5/olAdDXy6wLO4H6devskF8R5RURHn21ZRH35/rR0B0sDQrTtaBYUDHHhX7kP57/BawgbPbf/qjVEfBenJraH5/Zz1MizcNtFnj5j3n0sop57fePjDuklK6m/VGubS/9xc85/pLqVT6+bv/h7XWs8YCv4cf7KpWA0jpQEwO4K+tevOvHHw8G4MvmcVKoPV5ZCsjQaf0CW0psEnEfgmnFw1xpYPlDO+yH4PYXD8OP3lx4IWpSCyhKF3CLn/r+lXY5IA7Awla5/CWFwS+aZzz40ktP540dwsHWrY8JMgwhD3waTOvsqS5qyw/WvnVH6n87imV1UPzVRC0J4Q4ccooz4YYZP3We46zCRjWbrc8XAenfUW2zxqqQTcrSvAgMb695IF3HIdcbLn00Vvli51PC1y+wi27E3YR6Ex4dqP3hrWKWKCEnVQ84buxEbiWk4jdSuLizS1HnJvOvmFMmeVsBkfcY2GWd1OY5cwgM1vzdMugMpQgpyT+1SXmHgU4pALGf7pAgcLvxR8nuPXqQoa+UO7D0pnZWaQjVJqtdQ4Msvw9GiFAMR756ICAAUB1W1n/itnq845ZxtRcbpaFwx3smHoEHfodI2KnmPNfty9833sB6f+F/8KvbkFLGjkZO8p0DdrK1UjlcqUNv7XO4q0xR82KDOMgko9nPrqJjE+jFC+ScU40E4bxR24ovcuK3HzzkNHK5EZnFakUEHwiDaWhineTVNDUQBdR7+h4A/Zx5S9nuykluhADhMTxw19+A9lMqC9ovHhUQXQMhSJglpuV2doYxSPrsFq99r0KM+pAlvt74K5Q8e3pdWr1xhau5xStrKvPFHx17pBpwE3XH2eshk3MmjxoWc7nD5I5rT9GPr9AQ5gKLqxJyl97gIoIe+x+VJfb3CZ5GHFtHxMOIv8O8o3paMCn4PXu1TV8FIWLETkyDBBaVD6aIX5EgsW6ZWJRICTs9FuuZlDE8AujFDx1+VAU5Uwqv+TNSjdlfeHwiqhfJhjw2PgkTAaPE3GXUEd70g1QJi+dzeapRgFsrrgQ5jw+MkAthxnryIOXbA2Z/igiesXZAphGmSi452pDGs8EDS+XCWmUideUzgGQe2Bl2UJmnoBhHoSrSluZHBc+7hI5PFAqLxB/epvgrj33c6XiT0uRJexNufROuSxbWQUTZC1EVrYVmY6t5AiHx6aV5GPiAXlQwXh1MizbsQprJwZrfGvwjWh3JjxCvqkn5CZba6JrT6fM7y+JxAarodpmE4mibyQKRd1IBMBfVxRFKnATipT9KYLdi/zj83CCXlRYQoHsOUaDz2C00o0cv+ujqRf30wq+xFJ+XlYNUOdGMT42Y2BFbZlY+WZbHE9IIzfT5e3beGZFLcfS+siz8/x5WXFXccUvY9XyOTTin0pQxQtlnXI1rZb/B3Yp+BaRCscxT6ceYAIsLxpKVEPDVmAgVZUM7TxymXXuffQv/N+XXJ7lgrE9jxzqqp523e1Npt9uFqco0quOb3jPlIQMnM5MuSiVknyRWgexPvuCAdI75REI+OVHKTIEcvHV2nj0mOK5LEe2dZib2ieyiarV5C+CIeT40gKNQF5xlfEWeDKepaIfOWyLnbIam6RuPGo1yd84g21e63N0c30Gdf6DH9+bqwNfCYoLV3xQt75z/niXF28HctlbHCSom58r6sG2rfZ6sWO5m41NczHgRO7XWh1doIGXR40NjbO8WlsVeQRaFqKBsRRoJ1VPaBT4gSYg1MDcJMr50HXxWQI3keLRI5Ittn22TA+AAYIwAthM0IzDN3UMRaKdfg3RtPtEX91il1xChh5TwLgXJOlqSb6fMFshkeEQeJUwX8XLVglZ+fXyNuEVvHyFGYtcz0AiqBzGLXEeWTyS5gIRdzu6Wl4buMUOynxyJq5wH8UiTr2fAjpulyk0O3InIGYmZ/eh9B6plJEHlJ39CfEg2NjYoqAQrgkqRE5y5V1QsfpFxcRy4kWlvx20OS8qDOTIC6KLHRS6LyiEVE+F8AcWGha2xJeFaE3t0ezOHdlLBQ/NyPcB6aPBNnHtvHv3ro7M7c41MzfFPawHV7PKTFsPq9t6cB/stvDJuIeNjblr7DiFG+d9we6+SOuH/ih+WKSVIYMP0HuC8OBhMdUcAV+TeGSLWMW4tcQTIZSgWY06kaIFLAkSc+X3NJ3PhvEIn5NXabgKhw8JyO/90QiUskM/DHxDdlH2Liwo5HBDTLlT1QsT0R34QTU20g2BTlETqbi7uL7Y4cj0qxQfdSY3jUEjsQeZGjOQ2u4wz8tOtSn9RK1a2p1mH1frnpJddLNWcZMCAimGmGhUepb8IZQzDIbMz9BZYXQACikOvNqap5WmWcvgWW7Vm2VI5NMCP5D38H+U2uCWf6sq5GqR5q9l0hnc8l+NXJISIIc2RisnIzBAob9WK0a23HD+SvpEpi6kYAVYp071t5I6OnfLR/2T4aD8HCB+LiB/roYijYEdCy/+99GakCkkjx5Gy3jkazo3okMJSyCeORYQHQ4BqYAFLrHExM3TWTfZa+ynSIxCvEycToqLK+dCB9ONJ8oJCe7Q4uZmuyy9V5Ghp0klV0e3gm46BIt25lKFYZb2ra9O4GD0EI6HsG5JjUYcgLgSKusBL+vVxfpjXLWFCTBtupYiJSZHxZ0xOhH6kiqPnQE7nwfAV++kpYmUKX3VFvjMa0CPaKIbGNpFYvwO5AkIJnKfg1kdNgp+tP2sQf2yWf0+SKeG1OE+azgdXRBLiOMy/00w9y9hiVbKaE18vph5QdjFm3Uxvpb4uYasuyaXLVUM0Vr8QOHJ+T0MVw0KRkS25IchBS93NyV/4bLWnkuRH4yUXrvR2A/pQsiHoMLPgIHjtG6DsEJXcxfA6H2HGVXImCjlOcfpqNp6URQWdB4JeO7pbED81PpYPfFDunQiuPWK5fWlaLkKizr29avf1YziCSKiycmpjqG+6UTDcsCsVLWJwgr+XB++PTgYDIcMGGnZcgv9rILKAVsCuTHFo/AUQ9ILtWTmQNlZnRCIFAPZM2nIRD0FSFI1T2LtKgYFYujn+tvT/tvL12cXx78ODh3b65zvxHhIC4MslatBtYyn02Pamhm52eOhFh6vffilNBJOGVierK3o3pAE6VLd3l270ctzlUd+3+zDL5tHJf4iVultSIFO6RIpx0zpNQFUOBNOtVwpV8MqdMjhuA9ms1IYpSV8I7pefuSc52UKoMToKzzzMbCeITITBKVirDWYBdppxG/eJlQGULEM6RrseviKAeOPq3ics/CnFSU7xOqmGojamEFblON8MTYciajcqvCU3dgDXQBfRhAIoOeb82jR4PDTC+rDgotfX6g45C5+s8QRdi0yentxUnLxlkJE1xK68kUlJQOhqYAmYMp9hyPI5PvYtNoGaccuDPNKgaWMYg02JQ9j15Ym/ihGfpwO5rhQcW2spwNOLyvIVBwfrgK7gL35bBWs60VswRIteUUWJYjpmr0lkeKtMR3jq1IgVovW0B6CTYziEbos8EGNDGu6GU8zz6tk5H1OfBlhUZmUCqVEZULScmCR0AjFUDYEIuMQ+wYZ43uvJiVD6jCYhB4eyrtAz5k7VAnNEcwt5OFbuBJDkXpid2pI8jK7JrNhTYv3xpZ8GYZjTokmYDYXqJYJV6jy80LLepCchehlWXE2Np5C/ktQ6Vbh/evX1TRhA/LMXQ2kej9M777fR2pksTMuPhRQWzG5ZTsOVnQsb0RlOsaL1SAmXApHVgwLUF6md7XdslMfUwJeowvdRHGnuJ5I+iBHUW666TUsSJ64WFiIng12e9I4w7ewwn4HIX+NzOuFjnrOz7OagiKS9loiykxiECZKxCSRCKD/Njw75VYvPNrlMggQ6qMxpkfxOkpuVR+NjMMfvvh9d8+YhRWsgJ+e4AldrgHxQIPRhigXCDcL/kCDZJ8wEIxSc+rfG6KdVg1Ws5yxf7vEqHvmzX3P2v+K6LdgN2QzIW2S+c3e9ZDt6KT/KbMIdjy2hERT5cdEtOV3SAb7n3J32mvsL6tWKSzTyaRNq4bj2NswNuRKT2eY4uaSzRxDfJQsxC6E4X/l2f6ztfOQyDUoyGYMoqvSnLKH9ygijNWJfLVcViZc7SmTnWY1f8Wbm5MXJrVQa27YILKt2aYNoRfvbSVo3+Buk9J4RhYPf5T64zq/9QbKZoobOa6K0CcdJ6H3cUAonhSE6gbxbyUp5gdhixusRFj0bslHkhp6ViQJFDR0ZOAAxoXiB+mNpQc/ZXz1INRe6Q4oOAGeF46TemEPxsbz7X6iu7sSls1Czpl0uSzt54aJayWP5UIl6j17DSfI1zMXUlJdwVGdKnE5XjC4ewAWVF3T0up2uv4s8U1x5SlDQDbwlMKSt0codKE4sRd9a8TR94wY8FheN+xptXAX4YMu8VnXyhrZgnzukglsA0ngNTmfxCXDbEx6I9JYFAeTANZ1Ca2VPCZV+TFwf+s9Ozw7wNeCSwjU3l9+qwbCXHUX1yf/ChagIwPCP/mzzotH4Goo0CJzKubRy0V+owcpavKvMvqrqs0tvxaJJyidGxWwWrPleKi46tGXIpSlPPlq7I9sFku5WYzdaXazmJhJsFmMgedLy9kEdKf9qWtKmBNg/50x16nsnDHpVRywgXCYmjK+vdKTCqbguGoHhYryPAF/S1aImy/o+ipoW5bNs9JINwMs5vdlEJNJ61nzkQsj3ycdivHPnqSPzGwB0QKzIcBMlrhD3EFyWfgoLbJryC0XUDWP0FApW8Vhlbh/Ffbk//W/Qlhhf+36n1FX+TIFeSIp9WdePB/yHYIFsZGUonUlYTOdhg6kSH2HPo8ngFUSnm0EHMWocjrGHLsMjAK/RqFVey5qA+OnbejcC/0ZO0oLUs1qy3h9AYrLymbUM8h2cToEjcBnE6pGrorcW30YR7MZ+zVVyUNvvsCABBc+T9Lvco3iTAr6erFfilJf4jO5x0FBjnATG4RA0+woW1e9zsGmZmX5QMKAg6mJF23Ji5QNOKzLJI3mH7hvMfuJ0tBczTH6kMrvoT/Bgxn2yUhB3CSB+l7O5178IAuGKuMyBuEYkHOYTTGnZkCZHL2IiEP/jv1O0OAFOrNkTOMvIpm31MYr9MQLRv3PQcJC30jhQ/rdTNF1h7wuEkCm1Q+U8/ry8jzm1vULP1nOUrYgTMBaYrfyF4LP0kR8oVM8e0cQHOPToEeBPxu/4c8CsgcaxYk/8cMxGxsf5lBf+zqdQ/8hzqSYxU8IDu4LyC6MD7PQP3yeDhz1c/tzm034NxdfeSc+rxqEb7zP7MbXH4JjsLdU4NT7FEyI7t7E1re1zqn6KXAlSWN3lHKOVwpYqn8fsTm1ipg/94ATIvb8QCbpyJMt9im2U+kS6qmZ+CBBgP7mvswA7oVPys/Ya2qWWOIwjRbD1F+wOU/jRMz+jh/oggqLCW/BwqDPglwaOVcIcrhLZfaYD5RCT7AJUUOW+00JprfH4riTjQPrGxcAtO3NE/YutnOiaOZ7Ifu7nUxMiL23Ew+jJYg0p1D6VztjEC7n7Di10sSKYOc2JITaf9rVOU2dRwl7ZWcIX5+XdqqIyh5Tf7/4KDy12Yx/iXcp1KZxQnh5T2v3b1SEfFlN1H3G1A/982MW+PKn4HjsJpQpNy/fHh0NLm4uz85uhm/6Jycs1XmHg1+ODwZQZPiB/SPJJp+eXd4cnb09PWQTo8rp8IZ0AhYZiWdvX54MbvqoczJPpw/ev+6/HV4ODtlUJx4dn5ht/6T7PT79pX9yfHjTv3j19s3g9JL1/Vwe74rNw1zOMVS4D3LJJ2enr9g/csnDy4tjyLjNt/MWG0qM9DMx4KFOOxm86h98YK90d2/67yVsL43U41OZ+rseJw7++PT48hj6+xWQ8zc7a/j2/PzsArH2EBoZgM3z44v+5fHZ6c3B68HB39m9lf36bHh52n8zEJmhlfnm7GJwc9i/7LO+lX55QfNzc9AX1UY6++IIsPG6f3Eoxj/OZA3Pji5F1szIujygUVwM+ocf2FJnDIcnovSdnfj29O83B4OLSxZpxMnTtVgXvTx+Mzh7e8n8WCWZZ19sERrpPDrg2wtI93X6L4OLIaLvzTEshcuD1ywQPRrSF7uNzTQUuNjfBB3iavyFV3kZL5Mpu6HfnOksE/ER0n0NUJ3GXDpIWcTr65cg2IlKuPDxXj0kBalKwzr9QH+moNPP2TuZ4LO+KGtFzWZj3g1xtZn+TYLWr+IbFaA3yYQN+ChR/L3AS/5j9jJVKQn7ZyA+eCAeTGS/22k86A875A2jcML+yX+KM2H2mrcoOCoKCOPETBkOD8+lGPCeN8MFzyjVH8EoYWP7e/jLK+ZxYFAaeRmNH1iYqm9x9s/+Joqk6WIAKjLMYyoKASQ/BfKnyEt43gn8BkqIvXGAuwzN8gHPeuN7CWgEbMlBfUPKH/uFPk65tYh5PO/ch72GfgFyUy+cQMFjniU2/3/yNvGaxBG7F1nzKML9fgJN++yjSERi4nCMUp3CafVAlKGd5YgCdrAHPjKudQ3CT+withNegxrORrwm2sY5BUIDr1ES+Ujp7/zbc5gX9o9Afg4jkFRTgaxXvDaP087O5Rfep2CfOZTv5zN0UmS3fMphU7kcHFze4A70ObaSTgeXLLZLnZ6dDtjITns7fMnmIukIVjgywsPB8ODi+Pzy7EKyb/YT7z67W77jA0Gtj9YAW8QqwVYDWUpFaeEfqJ9mWzfUxc2HDzdv4xkJt4eU4kHtlL3hv3MvSLAjQtPtMk1RU6SRjPgLyCTi+Cneg4FyE2pgpLUsFvs8hfRhmGV2maoE+LoVH3ixMgVZn0Y2tnhDRpR/l+aLCCg/U19jJTJNqTW8hYcepFn57RU1NDFG+YbqT/R7J+yOhkpi7Bv8NYv4IJaEXLzXQ58L/knyNReKP1FToS8uJhOW2Ckl0kXc9x9YHKivRIqsHsEU85cpqel/UQJI9nR4lrALqsUjoZIalhnVP1KdfwTKTjb/s1EflKFRgA512ULvdZlEcrkPBPxn3EjOxcVMFhGCH/o2wT52//J/AZLkEqg3aAwA";

// obj/full/installer_rw.js
var codeInstance = class {
  constructor(filename, EStarget, version, readonly) {
    this._compressed = filename.slice(-3) == ".gz";
    this._filename = this._compressed ? filename.slice(0, -3) : filename;
    this._version = version == "" ? "Unknown" : version;
    this._EStarget = EStarget == "" ? "Unknown" : EStarget;
    this._minified = filename.indexOf(".min.") > 0;
    this._readonly = readonly;
  }
  get compressed() {
    return this._compressed;
  }
  get version() {
    return this._version;
  }
  get readonly() {
    return this._readonly;
  }
  get EStarget() {
    return this._EStarget;
  }
  get minified() {
    return this._minified;
  }
  get filename() {
    return this._filename + (this.compressed ? ".gz" : "");
  }
};
var pageInstance = class {
  constructor(filename, contents) {
    let strContents = YAPI.imm_bin2str(contents);
    this._compressed = filename.slice(-3) == ".gz";
    this._filename = this._compressed ? filename.slice(0, -3) : filename;
    this._readonly = strContents.indexOf("yv4web-readonly") > 0;
    this._useMinified = strContents.indexOf("yv4web-readonly.min.js") > 0 || strContents.indexOf("yv4web-full.min.js") > 0;
    this._action = 0;
    this._contents = contents;
  }
  get compressed() {
    return this._compressed;
  }
  get readonly() {
    return this._readonly;
  }
  set readonly(value) {
    this._readonly = value;
  }
  get fs_filename() {
    return this._filename + (this.compressed ? ".gz" : "");
  }
  get http_filename() {
    return this._filename;
  }
  set action(value) {
    this._action = value;
  }
  get action() {
    return this._action;
  }
  get contents() {
    return this._contents;
  }
  get useMinified() {
    return this._useMinified;
  }
  set useMinified(value) {
    this._useMinified = value;
  }
};
var YV4W_installer = class _YV4W_installer {
  constructor(container, options) {
    this.CALLERISHTTPS = location.protocol.toLowerCase().substr(0, 5) == "HTTPS";
    this.DEFAULT_PROTOCOL = this.CALLERISHTTPS ? _YV4W_installer.HTTPS : _YV4W_installer.HTTP;
    this.FIRMWAREMINVERSION = 43805;
    this.DEFAULTADDR = "";
    this.DEFAULTPORT = "80";
    this.DEFAULTPATH = "";
    this.DEFAULTCANCELABLE = false;
    this.DEFAULTINTIALFOCUS = true;
    this.DEFAULTUSER = "";
    this.DEFAULTPWD = "";
    this.DEFAULTFILEPREFIX = "default";
    this.DEFAULTSRVUSERNAME = "";
    this.DEFAULTSRVPASSORD = "";
    this._currentStep = 0;
    this._warningRow = null;
    this._welcomeText = null;
    this._hubAddr = null;
    this._connectingText = null;
    this._ipAddrInput = null;
    this._protocolInput = null;
    this._ipPortInput = null;
    this._pathInput = null;
    this._configFileInput = null;
    this._webPageInput = null;
    this._connectiongError = null;
    this._pwdPanel = null;
    this._descPanel = null;
    this._customFilesPanel = null;
    this._doneMsgContainer = null;
    this._confirmUninstallPanel = null;
    this._modInstancesPanel = null;
    this._donePanel = null;
    this._runPanel = null;
    this._modifyInstallPanel = null;
    this._adminNameInput = null;
    this._adminPasswordInput = null;
    this._userNameInput = null;
    this._userPasswordInput = null;
    this._useReadOnlyInput = null;
    this._fileprefixInput = null;
    this._useFullVersionInput = null;
    this._removeUnusedJs = null;
    this._makeDefaultInput = null;
    this._userCredTable = null;
    this._optionsPanel = null;
    this._connectionErrorMsg = null;
    this._instancesFiles = [];
    this._jsCodeinstances = [];
    this._webPageinstances = [];
    this._uninstallOpt = null;
    this._updateOpt = null;
    this._addInstanceOpt = null;
    this._modInstanceOpt = null;
    this._confirmUninstall = null;
    this._history = [];
    this._ErrMsgContainer = null;
    this._currentHub = null;
    this._currentfs = null;
    this._currentHub_RW_username = "";
    this._currentHub_RW_password = "";
    this._currentHub_RO_username = "";
    this._currentHub_RO_password = "";
    this._currentHub_protocol = "";
    this._currentHubLink_protocol = "";
    this._currentHub_Addr = "";
    this._currentHub_port = "";
    this._currentHub_path = "";
    this._currentHub_ReadOnlyProtected = false;
    this._warning = "";
    this._finalURL = "";
    this._plannedaction = 0;
    this._alreadyInstalled = false;
    this._applicationURL = "";
    this.ESVersion = "es2017";
    this.WELCOMEPANEL = 0;
    this.ENTERHUBADDR = 1;
    this.CONNECTINGPANEL = 2;
    this.CONNECTIONERROR = 3;
    this.PASSWORDPANEL = 4;
    this.DESCRIPTIONPANEL = 5;
    this.CUSTOMFILESPANEL = 6;
    this.OPTIONSPANEL = 7;
    this.RUNPANEL = 8;
    this.DONEPANEL = 9;
    this.MODIFYINSTALLPANEL = 10;
    this.CONFIRMUNINSTALLPANEL = 11;
    this.MODINSTANCESPANEL = 12;
    this.ACTIONINSTALL = 1;
    this.ACTIONUNINSTALL = 2;
    this.ACTIONADDINSTANCE = 3;
    this.ACTIONMODINSTANCE = 4;
    this.ACTIONUPDATE = 5;
    this._MODIFYNOTHING = 0;
    this._MODIFYCOMPRESS = 1;
    this._MODIFYUNCOMPRESS = 2;
    this._MODIFYMAKEREADONLY = 3;
    this._MODIFYMAKEREADWRITE = 4;
    this._MODIFYUSEMINIFIED = 5;
    this._MODIFYUSEPLAIN = 6;
    this._MODIFYDELETE = 7;
    this._MODIFYUPDATE = 8;
    this.TARGETEXTENSION = ".html";
    this.icon = '<link rel="icon" type="image/svg+xml" href="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNjQiIGhlaWdodD0iNjQiIHZlcnNpb249IjEuMSIgdmlld0JveD0iMCAwIDE3IDE3IiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPjxyZWN0IHg9IjAiIHk9IjAiIHdpZHRoPSIxNyIgaGVpZ2h0PSIxNyIgcng9IjEuMSIgcnk9IjEuMSIgZmlsbD0iI2ZmZiIgZmlsbC1vcGFjaXR5PSIuOSIvPjxwYXRoIGQ9Im0xMC43IDEuMy0wLjI5IDAuMjljLTAuMDQ3IDAuMDQ3LTAuMDczIDAuMTEtMC4wNzIgMC4xOHYxLjFjLTEuMS0wLjktMi43LTAuODMtMy43IDAuMTRsLTAuNC0wLjR2LTAuOTdjMC4zNS0wLjI1IDAuMi0wLjgyLTAuMjMtMC44My0wLjQzLTAuMDE0LTAuNjMgMC41My0wLjI3IDAuODJ2MS4xYzAgMC4wNjcgMC4wMjcgMC4xMyAwLjA3NCAwLjE4bDAuNDkgMC40OWMtMC40MyAwLjU5LTAuNjMgMS4zLTAuNTQgMi4xdjAuMDA3MmwtMC44My0wLjgzYy0wLjA0Ny0wLjA0Ny0wLjExLTAuMDczLTAuMTgtMC4wNzJoLTJjLTAuMjctMC4zNi0wLjgzLTAuMTktMC44MyAwLjI1IDAuMDAxMiAwLjQ0IDAuNTYgMC42MiAwLjgyIDAuMjVoMS45bDEuMyAxLjNjMC40MyAwLjM4IDAuNzQgMS4yIDAuNTkgMS42aC0yLjVjLTAuMDY2IDAgLTAuMTMgMC4wMjctMC4xOCAwLjA3NGwtMS40IDEuNGMtMC4zOS0wLjA4OS0wLjcyIDAuMzQtMC40OCAwLjY5czAuODYgMC4yIDAuODItMC4zM2wxLjMtMS4zaDIuNmMwLjI2IDAuMTUgMC41MSAwLjQgMC42NyAwLjY1djEuOWwtMS41IDEuNWMtMC4wNDcgMC4wNDctMC4wNzMgMC4xMS0wLjA3NCAwLjE4djAuMjhjLTAuNDUgMC4zLTAuMTUgMC44MyAwLjIzIDAuODMgMC4zOCAwIDAuNjMtMC40NyAwLjI3LTAuODF2LTAuMjFsMS41LTEuNWMwLjA0Ny0wLjA0NiAwLjA3NC0wLjExIDAuMDc0LTAuMTh2LTEuN2MwLjI0LTAuMzIgMS4xLTAuNCAxLjQtMC4wM3YxLjJjIDAgMC4wNjYgMC4wMjcgMC4xMyAwLjA3NCAwLjE4bDEuNSAxLjV2MC42OWMtMC4zNiAwLjI0LTAuMjMgMC44MSAwLjI3IDAuODIgMC40OSAwLjAwMjEgMC41NC0wLjY0IDAuMjMtMC44MnYtMC43OWMgMCAtMC4wNjYtMC4wMjctMC4xMy0wLjA3NC0wLjE4bC0xLjUtMS41di0xLjRjMC4xNS0wLjIgMC4zLTAuMjUgMC41My0wLjI0aDMuMmwwLjkxIDAuOTFjLTAuMDk5IDAuNDQgMC40OCAwLjcyIDAuNzcgMC40IDAuMjgtMC4zMiAwLjA3Mi0wLjc5LTAuNDItMC43NmwtMC45OC0wLjk4Yy0wLjA0Ny0wLjA0Ny0wLjExLTAuMDcyLTAuMTgtMC4wNzJoLTNjLTAuMjEtMC4zMiAwLjI0LTEuNSAwLjY3LTEuOWwyLjIgMC4wMDU5YzAuMDY3IDAgMC4xMy0wLjAyNiAwLjE4LTAuMDcybDEuMS0xLjFjMC4zOSAwLjA5NiAwLjczLTAuNCAwLjQ0LTAuNzNzLTAuODctMC4xLTAuNzggMC4zNmwtMS4xIDEuMWgtMmMwLjI3LTAuOTUgMC4wMDY3LTEuOS0wLjQzLTIuNXYtMS41bDAuMjEtMC4yMWMwLjM4IDAuMDgyIDAuNzEtMC4zMyAwLjQ2LTAuNjlzLTAuODctMC4xOS0wLjggMC4zM3ptLTMuMiA0LjljMC44NC0wLjAyOSAwLjk2IDEuNSAwLjIgMS41LTAuNzYtMC4wMTQtMS0xLjQtMC4yLTEuNXptMi4xIDBjMC43NSAwLjA4NCAwLjYxIDEuNS0wLjIgMS41LTAuODEgMC4wMDMzLTAuNTUtMS41IDAuMi0xLjV6IiBmaWxsLW9wYWNpdHk9Ii4xIi8+PHJlY3QgeD0iMCIgeT0iMCIgd2lkdGg9IjE3IiBoZWlnaHQ9IjE2IiByeT0iMS44IiBvcGFjaXR5PSIwIiBzdHJva2Utd2lkdGg9Ii4yNiIvPjxlbGxpcHNlIGN4PSI5LjQiIGN5PSI3LjQiIHJ4PSIuMzQiIHJ5PSIuMzMiIG9wYWNpdHk9Ii4xIi8+PGVsbGlwc2UgY3g9IjcuNyIgY3k9IjcuNCIgcng9Ii4zNCIgcnk9Ii4zMyIgb3BhY2l0eT0iLjEiLz48ZyBmaWxsPSJub25lIj48cGF0aCBkPSJtMS4xIDEuOSAwLjA2NiAxNCIgc3Ryb2tlPSIjN2U3ZTdlIiBzdHJva2Utd2lkdGg9Ii4yIi8+PHBhdGggZD0ibTE1IDEzaC0xNSIgc3Ryb2tlPSIjN2U3ZTdlIiBzdHJva2Utd2lkdGg9Ii4yIi8+PHBhdGggZD0ibTEuMiAxM2M1LjQtMS4xIDEwLTIuNyAxNS02LjkiIHN0cm9rZT0ibGltZSIgIHN0cm9rZS13aWR0aD0iLjQiLz48cGF0aCBkPSJtMS4yIDEzYzAuMS0wLjA1MyAwLjQ1LTEuNCAxLjItMS40IDAuNzggMCAxLjQgMi44IDIuMyAyLjggMC44Ni0wLjAwMTUgMS42LTIuOCAyLjQtMi44IDAuODQgMCAxLjUgMi44IDIuNCAyLjggMC45IDAuMDEzIDEuNi0yLjggMi40LTIuOCAwLjgyIDAuMDI4IDEuNSAyLjcgMi4zIDIuOCAwLjI2IDAuMDQzIDAuNjgtMC4zNCAwLjY3LTAuNDIiICBzdHJva2U9InJlZCIgIHN0cm9rZS13aWR0aD0iLjQiLz48L2c+PHBhdGggZD0ibTE1IDEyLjQgMS4xIDAuNi0xLjEgMC41N3oiIGZpbGw9IiM3ZTdlN2UiLz48cGF0aCBkPSJtMC41MiAyIDAuNjItMSAwLjU5IDF6IiBmaWxsPSIjN2U3ZTdlIi8+PHBhdGggZD0ibTkuOCAwIDcuMiA3LjJ2LTRsLTMuMi0zLjJ6IiBmaWxsPSJncmVlbiIvPjxnIGZpbGw9IiNmZmYiIHN0cm9rZS13aWR0aD0iMSI+PHBhdGggZD0ibTEyLjcgMS42MyAwLjQ5LTEuMSAwLjE5IDAuMTktMC4zMyAwLjc0IDAuNzUtMC4zMiAwLjEyIDAuMTItMC4zMiAwLjc1IDAuNzMtMC4zNCAwLjE3IDAuMTctMS4xIDAuNDktMC4xMi0wLjEyIDAuMzMtMC43Ny0wLjc3IDAuMzN6Ii8+PHBhdGggZD0ibTEzLjggMi43OSAwLjc5LTAuNzkgMC44MiAwLjgyLTAuMTQgMC4xNC0wLjY0LTAuNjQtMC4xOCAwLjE4IDAuMzYgMC4zNi0wLjE0IDAuMTQtMC4zNi0wLjM2LTAuMTkgMC4xOSAwLjY0IDAuNjQtMC4xNSAwLjE1eiIvPjxwYXRoIGQ9Im0xNi4xIDMuOC0wLjQyLTAuNDItMC4xOSAwLjE5IDAuNDIgMC40MnEwLjA0OSAwLjA0OSAwLjA3OSAwLjA1MyAwLjAzMiAwIDAuMDY0LTAuMDI2bDAuMDc1LTAuMDc1cTAuMDMxLTAuMDMxIDAuMDI1LTAuMDYyLTAuMDA0NS0wLjAzMi0wLjA1Mi0wLjA3OXptLTAuMzIgMC4zMi0wLjQyLTAuNDItMC4yIDAuMiAwLjQyIDAuNDJxMC4wNTIgMC4wNTMgMC4wODYgMC4wNTQgMC4wMzUgMC4wMDMxIDAuMDc1LTAuMDM3bDAuMDYtMC4wNnEwLjA0LTAuMDQgMC4wMzYtMC4wNzQtMC4wMDIzLTAuMDM0LTAuMDU0LTAuMDg2em0tMC45NS0wLjI2IDAuNzktMC43OSAwLjY4IDAuNjhxMC4wOTQgMC4wOTQgMC4xIDAuMTcgMC4wMDUzIDAuMDc5LTAuMDc1IDAuMTZsLTAuMDk4IDAuMDk4cS0wLjA1NyAwLjA1Ny0wLjEyIDAuMDU3LTAuMDY5LTAuMDAxNS0wLjE1LTAuMDU5IDAuMDU5IDAuMDc3IDAuMDU3IDAuMTYtMC4wMDIzIDAuMDc3LTAuMDY2IDAuMTRsLTAuMSAwLjFxLTAuMDc5IDAuMDc5LTAuMTcgMC4wNTktMC4wOTYtMC4wMTktMC4yMi0wLjE0eiIvPjwvZz48L3N2Zz4=">';
    if (typeof options !== "undefined") {
      if (options != null) {
        if (typeof options["protocol"] === "string")
          this.DEFAULT_PROTOCOL = options["protocol"].toUpperCase() == _YV4W_installer.HTTPS.toUpperCase() ? _YV4W_installer.HTTPS : _YV4W_installer.HTTP;
        if (typeof options["addr"] === "string") {
          this.DEFAULTADDR = options["addr"];
          let n = this.DEFAULTADDR.indexOf(":");
          if (n > 0) {
            this.DEFAULTPORT = this.DEFAULTADDR.substring(n + 1);
            this.DEFAULTADDR = this.DEFAULTADDR.substring(0, n);
          }
        }
        if (typeof options["port"] === "number")
          this.DEFAULTPORT = options["port"].toString();
        if (typeof options["path"] === "string")
          this.DEFAULTPATH = options["path"];
        if (typeof options["cancelable"] === "boolean")
          this.DEFAULTCANCELABLE = options["cancelable"];
        if (typeof options["initialFocus"] === "boolean")
          this.DEFAULTINTIALFOCUS = options["initialFocus"];
      }
    }
    this._container = container;
    this._container.innerHTML = "";
    this._container.style.backgroundColor = constants.WindowBackgroundColor;
    this._container.style.fontFamily = constants.WindowHeaderFontFamily;
    let bottomdiv = document.createElement("DIV");
    bottomdiv.style.position = "absolute";
    bottomdiv.style.bottom = "0px";
    bottomdiv.style.right = "5px";
    bottomdiv.style.height = "30px";
    bottomdiv.style.textAlign = "right";
    bottomdiv.style.verticalAlign = "center";
    this._prevButton = new button("< Prev", () => {
      this.gotoPrevious();
    }, 1);
    this._cancelButton = new button("Cancel", async () => {
      this.closeWindow();
    }, 1);
    this._nextButton = new button("Next >", () => {
      this.gotoNext();
    }, 1);
    this._okButton = new button("Ok", async () => {
      this.DEFAULTCANCELABLE ? this.closeWindow() : await this.resetAll();
    }, 1);
    this._prevButton.tabIndex = 100;
    this._cancelButton.tabIndex = 101;
    this._nextButton.tabIndex = 102;
    this._okButton.tabIndex = 103;
    bottomdiv.appendChild(this._prevButton.Element);
    bottomdiv.appendChild(this._cancelButton.Element);
    bottomdiv.appendChild(this._nextButton.Element);
    bottomdiv.appendChild(this._okButton.Element);
    this._prevButton.visible = false;
    this._cancelButton.visible = this.DEFAULTCANCELABLE;
    this._container.appendChild(bottomdiv);
    let topDiv = document.createElement("DIV");
    topDiv.style.position = "absolute";
    topDiv.style.top = "5px";
    topDiv.style.paddingLeft = "10px";
    topDiv.style.paddingTop = "5px";
    topDiv.style.paddingBottom = "5px";
    topDiv.style.left = "5px";
    topDiv.style.right = "5px";
    topDiv.style.backgroundColor = constants.WindowHeaderBackgroundColor;
    topDiv.style.color = constants.WindowHeaderColor;
    topDiv.style.fontSize = "x-large";
    topDiv.style.whiteSpace = "nowrap";
    topDiv.style.overflow = "hidden";
    topDiv.innerText = "Yocto-Visualization (for web) installer";
    this._container.appendChild(topDiv);
    this.gotoPanel(this.WELCOMEPANEL);
  }
  closeWindow() {
    var _a;
    (_a = this._container.parentElement) === null || _a === void 0 ? void 0 : _a.removeChild(this._container);
  }
  createNewContentDiv() {
    let div = document.createElement("DIV");
    div.style.position = "absolute";
    div.style.textAlign = "justify";
    div.style.top = "50px";
    div.style.left = "15px";
    div.style.right = "15px";
    return div;
  }
  loadLocalFile(fileChooser) {
    return new Promise(function(resolve, reject) {
      if (fileChooser.files && fileChooser.files[0]) {
        let reader = new FileReader();
        reader.onload = function(e) {
          resolve(e.target.result);
        };
        reader.readAsText(fileChooser.files[0]);
      } else {
        resolve(null);
      }
    });
  }
  showWelcomePanel(visible, goingback) {
    if (!visible) {
      if (this._welcomeText != null)
        this._welcomeText.style.display = "none";
      return;
    }
    this._okButton.visible = false;
    this._prevButton.visible = false;
    this._nextButton.visible = true;
    this._nextButton.enabled = true;
    this._cancelButton.visible = this.DEFAULTCANCELABLE;
    if (this._welcomeText == null) {
      this._welcomeText = this.createNewContentDiv();
      this._welcomeText.innerText = "Yoctopuce is proud to offer you  Yocto-Visualization (for web), an application that  allows to view Yoctopuce sensors data with a simple web browser.\n\nThis wizard will help you to install Yocto-Visualization (for web) version " + constants.buildVersion + " (" + this.ESVersion + ') on a YoctoHub such as YoctoHub-Ethernet, YoctoHub-Wireless, VirtualHub etc..\n\n Click on "next" to start';
      this._container.appendChild(this._welcomeText);
    }
    this._currentHub = null;
    this._currentfs = null;
    this._currentHub_RW_username = "";
    this._currentHub_RW_password = "";
    this._currentHub_RO_username = "";
    this._currentHub_RO_password = "";
    this._currentHub_protocol = "";
    this._currentHub_Addr = "";
    this._currentHub_port = "";
    this._currentHub_path = "";
    let tabIndex = 1;
    this._nextButton.tabIndex = tabIndex++;
    if (this.DEFAULTINTIALFOCUS)
      this._nextButton.focus();
    this._welcomeText.style.display = "";
  }
  showEnterHubAddr(visible, goingback) {
    if (!visible) {
      if (this._hubAddr != null)
        this._hubAddr.style.display = "none";
      return;
    }
    if (this._hubAddr == null) {
      this._hubAddr = this.createNewContentDiv();
      let p = document.createElement("P");
      p.innerText = "Enter the address of the hub you want to install Yocto-Visualization on. This address must be reacheable from your web browser.";
      this._hubAddr.appendChild(p);
      let Table = document.createElement("TABLE");
      Table.style.fontSize = "smaller";
      let Row = document.createElement("TR");
      let TD1 = document.createElement("TD");
      TD1.innerText = "Hub address:";
      TD1.style.whiteSpace = "normal";
      Row.appendChild(TD1);
      let TD2 = document.createElement("TD");
      TD2.style.whiteSpace = "normal";
      this._protocolInput = document.createElement("SELECT");
      let httpopt1 = document.createElement("OPTION");
      httpopt1.text = "http://";
      httpopt1.value = _YV4W_installer.HTTP;
      this._protocolInput.add(httpopt1);
      let httpopt2 = document.createElement("OPTION");
      httpopt2.text = "https://";
      httpopt2.value = _YV4W_installer.HTTPS;
      this._protocolInput.add(httpopt2);
      this._protocolInput.value = this.DEFAULT_PROTOCOL;
      this._protocolInput.addEventListener("change", () => {
        if (this._protocolInput != null && this._ipPortInput != null) {
          if (this._protocolInput.value == _YV4W_installer.HTTPS && parseInt(this._ipPortInput.value) == 80)
            this._ipPortInput.value = "443";
          if (this._protocolInput.value == _YV4W_installer.HTTP && parseInt(this._ipPortInput.value) == 443)
            this._ipPortInput.value = "80";
          if (this._warningRow != null)
            this._warningRow.style.display = this._protocolInput.value == _YV4W_installer.HTTP && this.CALLERISHTTPS ? "" : "none";
        }
      });
      TD2.appendChild(this._protocolInput);
      this._ipAddrInput = document.createElement("INPUT");
      this._ipAddrInput.value = this.DEFAULTADDR;
      this._ipAddrInput.size = 34;
      this._ipAddrInput.addEventListener("input", () => {
        this._nextButton.enabled = this._ipAddrInput.value != "" && this._ipPortInput.value != "";
      });
      TD2.appendChild(this._ipAddrInput);
      let span = document.createElement("SPAN");
      span.innerText = ":";
      TD2.appendChild(span);
      this._ipPortInput = document.createElement("INPUT");
      this._ipPortInput.value = this.DEFAULTPORT != "" ? this.DEFAULTPORT : "4444";
      this._ipPortInput.type = "number";
      this._ipPortInput.min = "1";
      this._ipPortInput.max = "65535";
      this._ipPortInput.maxLength = 6;
      this._ipPortInput.style.width = "60px";
      this._ipPortInput.addEventListener("input", () => {
        this._nextButton.enabled = this._ipAddrInput.value != "" && this._ipPortInput.value != "";
      });
      TD2.appendChild(this._ipPortInput);
      Row.appendChild(TD2);
      Table.appendChild(Row);
      this._warningRow = document.createElement("TR");
      TD1 = document.createElement("TD");
      TD1.style.whiteSpace = "normal";
      TD1.style.fontSize = "smaller";
      TD1.innerText = "WARNING: Unless your web browser is configured to accept 'mixed content', trying to establish an HTTP connection from an HTTPS page is likely to fail.";
      TD1.colSpan = 2;
      this._warningRow.style.display = "none";
      this._warningRow.appendChild(TD1);
      Table.appendChild(this._warningRow);
      Row = document.createElement("TR");
      TD1 = document.createElement("TD");
      TD1.style.whiteSpace = "normal";
      TD1.style.paddingTop = "20px";
      TD1.style.paddingBottom = "20px";
      TD1.style.textAlign = "justify";
      TD1.innerText = "On YoctoHubs, protocol is HTTP and port is likely to be 80. On native Virtualhub, protocol is HTTP and port is likely to be 4444. On VirtualHub (for web), the  hub path is mandatory and should be set to your VirtualHub (for web) instance path, protocol and  port can be either HTTP and 80 or HTTPS and 433.";
      TD1.colSpan = 2;
      Row.appendChild(TD1);
      Table.appendChild(Row);
      Row = document.createElement("TR");
      TD1 = document.createElement("TD");
      TD1.style.whiteSpace = "normal";
      TD1.innerText = "Hub path:";
      Row.appendChild(TD1);
      TD2 = document.createElement("TD");
      TD2.style.whiteSpace = "normal";
      this._pathInput = document.createElement("INPUT");
      this._pathInput.value = this.DEFAULTPATH;
      this._pathInput.size = 48;
      TD2.appendChild(this._pathInput);
      Row.appendChild(TD2);
      Table.appendChild(Row);
      this._hubAddr.appendChild(Table);
      this._container.appendChild(this._hubAddr);
    }
    this._hubAddr.style.display = "";
    let tabIndex = 1;
    this._protocolInput.tabIndex = tabIndex++;
    this._ipAddrInput.tabIndex = tabIndex++;
    this._ipPortInput.tabIndex = tabIndex++;
    this._pathInput.tabIndex = tabIndex++;
    this._prevButton.tabIndex = tabIndex++;
    this._nextButton.tabIndex = tabIndex++;
    this._protocolInput.focus();
    this._nextButton.visible = true;
    this._nextButton.enabled = this._ipAddrInput.value != "";
  }
  async showConnectingPanel(visible, goingback) {
    if (!visible) {
      if (this._connectingText != null)
        this._connectingText.style.display = "none";
      return;
    }
    if (this._connectingText == null) {
      this._connectingText = this.createNewContentDiv();
      this._container.appendChild(this._connectingText);
    }
    this.removeCurrentPanelFromHistory();
    this._connectingText.innerText = "Connecting to hub " + this._ipAddrInput.value + ". Please wait...";
    this._connectingText.style.display = "";
    this._nextButton.visible = false;
    this._prevButton.visible = false;
    this._cancelButton.visible = false;
    let IP = this._ipAddrInput.value;
    let port = parseInt(this._ipPortInput.value);
    let protocol = this._protocolInput.value;
    this._currentHubLink_protocol = this._protocolInput.value;
    let RW_username = "";
    let RW_password = "";
    let RO_username = "";
    let RO_password = "";
    if (this._adminNameInput != null)
      RW_username = this._adminNameInput.value;
    if (this._adminPasswordInput != null)
      RW_password = this._adminPasswordInput.value;
    if (this._userNameInput != null)
      RO_username = this._userNameInput.value;
    if (this._userPasswordInput != null)
      RO_password = this._userPasswordInput.value;
    let url = protocol + "://" + IP + ":" + port.toString();
    let HubData = null;
    let serial = "";
    let path = this._pathInput.value;
    if (path != "") {
      if (path.charAt(0) == "/")
        path = path.slice(1);
      url += "/" + path;
    }
    let info = new HubInfo(
      protocol,
      IP,
      port,
      path,
      null,
      null
      /*srvusername, srvpassword*/
    );
    let infoRes = await info.makeRequest();
    if (infoRes !== true) {
      let err = "Failed to connect to the Hub while using the url\n\n" + url + "\n\n";
      let prvmsg = 'Click on the "prev" button,';
      switch (infoRes) {
        case 0:
          err += prvmsg + " and make sure that protocol, address, port and path are correct, and try again.\n\n";
          break;
        case -1:
          err += "(invalid server answer), contact yoctopuce support.";
          break;
        case -2:
          err += prvmsg + " then check path. If path is correct check hub firmware version. This installer doesn't work with versions older that " + this.FIRMWAREMINVERSION + ".";
          break;
        case -3:
          err += "An network error occured, make sure hub address is correct.\n\nAlso connexion migh have been  blocked by your web browser, most likely due to CORS policy.\n\nCheck your browser console (Shift-Control-I on most browsers), if you find an error message about a Cross-Origin Request Blocked over a 404 error, Press '<Prev' and check path carefuly.";
          break;
        case 404:
          err += prvmsg + " make sure the path is correct, and try again.";
          break;
        case 500:
          err += " the hub encountered an interal error (Error 500)";
          break;
        case 503:
          err += " the hub is  not available (Error 503)";
          break;
        case 401:
          err += " Unauthorized access, check server configuration(Error 401)";
          break;
        default:
          err += "server responded with an HTTP error " + infoRes;
          break;
      }
      this.gotoPanel(this.CONNECTIONERROR, err);
      return;
    }
    if (info.serial != "") {
      port = info.port;
      serial = info.serial;
      path = info.path;
      this._currentHub_ReadOnlyProtected = info.userPassword;
    }
    protocol = info.protocol;
    if (info.adminPassword && RW_username == "" && RW_password == "") {
      this.gotoPanel(this.PASSWORDPANEL);
      return;
    }
    await YAPI.DisableExceptions();
    let errmsg = new YErrorMsg();
    if (info.userPassword) {
      let RO_addr = info.get_hubUrl(RO_username, RO_password);
      let RO_res = await YAPI.TestHub(RO_addr, 5e3, errmsg);
      if (RO_res != YAPI.SUCCESS) {
        if (RO_res == YAPI.UNAUTHORIZED) {
          this.gotoPanel(this.PASSWORDPANEL, "ReadOnly test failed, check credentials for read only operations.");
          return;
        } else {
          let err = "Cannot connect to " + url + " : " + errmsg.msg + '.\n\nMake sure the Hub is Up and address is correct, then click the "prev" to try again';
          this.gotoPanel(this.CONNECTIONERROR, err);
          return;
        }
      }
    }
    await YAPI.FreeAPI();
    await YAPI.DisableExceptions();
    let addr = info.get_hubUrl(RW_username, RW_password);
    this._applicationURL = IP + ":" + port.toString() + (path != "" ? "/" + path : "");
    let res = await YAPI.TestHub(addr, 5e3, errmsg);
    if (res != YAPI.SUCCESS) {
      if (res == YAPI.UNAUTHORIZED) {
        this.gotoPanel(this.PASSWORDPANEL);
        return;
      } else {
        let err = "Cannot connect to " + url + " : " + errmsg.msg + '.\n\nMake sure the Hub is Up and address is correct, then click the "prev" to try again';
        this.gotoPanel(this.CONNECTIONERROR, err);
        return;
      }
    }
    await YAPI.FreeAPI();
    await YAPI.DisableExceptions();
    if (await YAPI.RegisterHub(addr, errmsg) != YAPI.SUCCESS) {
      let err = "Cannot connect to " + IP + " : " + errmsg.msg + '.\nMake sure the Hub is Up and address is correct, then click the "prev" to try again';
      this.gotoPanel(this.CONNECTIONERROR, err);
      return;
    }
    let m = YModule.FirstModule();
    while (m != null) {
      if (await m.get_parentHub() == "") {
        let urlMatch = false;
        let serialMatch = await m.get_serialNumber() == serial;
        if (!serialMatch)
          urlMatch = (await m.get_url()).indexOf(IP + ":" + port.toString()) > 0;
        if (serialMatch || urlMatch) {
          this._currentHub = m;
          this._currentHub_RW_username = RW_username;
          this._currentHub_RW_password = RW_password;
          this._currentHub_protocol = protocol;
          this._currentHub_Addr = IP;
          this._currentHub_port = port.toString();
          this._currentHub_path = path;
          if (await m.isReadOnly()) {
            await YAPI.UnregisterHub(await m.get_url());
            this._currentHub = null;
            this.gotoPanel(this.PASSWORDPANEL, "Write test failed, check credentials for read/write operations.");
          } else {
            this.gotoPanel(this.DESCRIPTIONPANEL);
          }
          return;
        }
      }
      m = m.nextModule();
    }
    this.gotoPanel(this.CONNECTIONERROR, "Internal Error, cannot find Hub after RegisterHub call");
  }
  removeCurrentPanelFromHistory() {
    this._history.pop();
  }
  async showConnectionError(visible, goingback, message) {
    if (!visible) {
      if (this._connectiongError != null)
        this._connectiongError.style.display = "none";
      return;
    }
    if (this._connectiongError == null) {
      this._connectiongError = this.createNewContentDiv();
      this._container.appendChild(this._connectiongError);
    }
    this.removeAllChilds(this._connectiongError);
    let Table = document.createElement("TABLE");
    let Row = document.createElement("TR");
    let TD1 = document.createElement("TD");
    TD1.style.whiteSpace = "normal";
    TD1.innerHTML = ressources.FailedIcon("64", true, false, false, false, "oops");
    Row.appendChild(TD1);
    this._ErrMsgContainer = document.createElement("TD");
    this._ErrMsgContainer.style.whiteSpace = "normal";
    this._ErrMsgContainer.style.textAlign = "justify";
    Row.appendChild(this._ErrMsgContainer);
    Table.appendChild(Row);
    this._connectiongError.appendChild(Table);
    this._ErrMsgContainer.innerText = message;
    this._nextButton.visible = false;
    this._prevButton.visible = true;
    this._cancelButton.visible = this.DEFAULTCANCELABLE;
    this._connectiongError.style.display = "";
    let tabIndex = 1;
    this._prevButton.tabIndex = tabIndex++;
    this._prevButton.focus();
  }
  MakeSureCredentialsAreNotEmpty() {
    if (this._currentHub_ReadOnlyProtected) {
      this._nextButton.enabled = this._userPasswordInput.value != "" && this._userNameInput.value != "";
    } else {
      this._nextButton.enabled = true;
    }
    if (this._adminPasswordInput.value == "" || this._adminNameInput.value == "") {
      this._nextButton.enabled = false;
    }
  }
  showPasswordPanel(visible, goingback, err) {
    if (!visible) {
      if (this._pwdPanel != null)
        this._pwdPanel.style.display = "none";
      return;
    }
    let errmsg = typeof err != "undefined" ? err : "Well, looks like this hub requires some authentication.";
    if (this._history[this._history.length - 2] == this.PASSWORDPANEL) {
      errmsg = "Invalid credentials. " + errmsg;
      this.removeCurrentPanelFromHistory();
    }
    if (this._pwdPanel == null) {
      this._pwdPanel = this.createNewContentDiv();
      this._connectionErrorMsg = document.createElement("P");
      this._connectionErrorMsg.style.marginTop = "0px";
      this._pwdPanel.appendChild(this._connectionErrorMsg);
      let Table = document.createElement("TABLE");
      let Row = document.createElement("TR");
      let TD1 = document.createElement("TD");
      TD1.style.whiteSpace = "normal";
      TD1.innerText = "Enter read/write credentials below, these are required for the installation but won't be saved in Yocto-Visualization's configuration.";
      TD1.style.fontSize = "smaller";
      TD1.colSpan = 4;
      Row.appendChild(TD1);
      Table.appendChild(Row);
      Row = document.createElement("TR");
      TD1 = document.createElement("TD");
      TD1.style.whiteSpace = "normal";
      TD1.innerText = "Username:";
      TD1.style.borderLeft = "20px solid transparent";
      TD1.style.fontSize = "smaller";
      Row.appendChild(TD1);
      let TD2 = document.createElement("TD");
      TD2.style.whiteSpace = "normal";
      TD2.style.fontSize = "smaller";
      this._adminNameInput = document.createElement("INPUT");
      this._adminNameInput.size = 12;
      this._adminNameInput.addEventListener("input", () => {
        this.MakeSureCredentialsAreNotEmpty();
      });
      TD2.appendChild(this._adminNameInput);
      Row.appendChild(TD2);
      let TD3 = document.createElement("TD");
      TD3.style.whiteSpace = "normal";
      TD3.innerText = "Password:";
      TD3.style.fontSize = "smaller";
      Row.appendChild(TD3);
      let TD4 = document.createElement("TD");
      TD4.style.whiteSpace = "normal";
      this._adminPasswordInput = document.createElement("INPUT");
      this._adminPasswordInput.type = "password";
      this._adminPasswordInput.size = 12;
      this._adminPasswordInput.addEventListener("input", () => {
        this.MakeSureCredentialsAreNotEmpty();
      });
      TD4.appendChild(this._adminPasswordInput);
      TD4.style.fontSize = "smaller";
      Row.appendChild(TD4);
      this._adminNameInput.value = this.DEFAULTSRVUSERNAME;
      this._adminPasswordInput.value = this.DEFAULTSRVPASSORD;
      Table.appendChild(Row);
      let userRow1 = document.createElement("TR");
      TD1 = document.createElement("TD");
      TD1.style.whiteSpace = "normal";
      TD1.innerText = "\n\nEnter read-only credentials below, these will be saved in the configuration";
      TD1.style.fontSize = "smaller";
      TD1.colSpan = 4;
      userRow1.appendChild(TD1);
      Table.appendChild(userRow1);
      let userRow2 = document.createElement("TR");
      TD1 = document.createElement("TD");
      TD1.style.whiteSpace = "normal";
      TD1.innerText = "Username:";
      TD1.style.borderLeft = "20px solid transparent";
      TD1.style.fontSize = "smaller";
      userRow2.appendChild(TD1);
      TD2 = document.createElement("TD");
      TD2.style.whiteSpace = "normal";
      TD2.style.fontSize = "smaller";
      this._userNameInput = document.createElement("INPUT");
      this._userNameInput.size = 12;
      this._userNameInput.addEventListener("input", () => {
        this.MakeSureCredentialsAreNotEmpty();
      });
      TD2.appendChild(this._userNameInput);
      userRow2.appendChild(TD2);
      TD3 = document.createElement("TD");
      TD3.style.whiteSpace = "normal";
      TD3.innerText = "Password:";
      TD3.style.fontSize = "smaller";
      userRow2.appendChild(TD3);
      TD4 = document.createElement("TD");
      TD4.style.whiteSpace = "normal";
      this._userPasswordInput = document.createElement("INPUT");
      this._userPasswordInput.type = "password";
      this._userPasswordInput.size = 12;
      this._userPasswordInput.addEventListener("input", () => {
        this.MakeSureCredentialsAreNotEmpty();
      });
      TD4.appendChild(this._userPasswordInput);
      TD4.style.fontSize = "smaller";
      userRow2.appendChild(TD4);
      this._userNameInput.value = this.DEFAULTUSER;
      this._userPasswordInput.value = this.DEFAULTPWD;
      Table.appendChild(userRow2);
      Table.style.marginTop = "0px";
      Table.style.marginBottom = "20px";
      this._pwdPanel.appendChild(Table);
      let userCredVisible = "";
      if (!this._currentHub_ReadOnlyProtected) {
        userCredVisible = "none";
        this._userPasswordInput.value = "";
        this._userNameInput.value = "";
      }
      userRow1.style.display = userCredVisible;
      userRow2.style.display = userCredVisible;
      let p = document.createElement("P");
      p.innerText = 'Note: On YoctoHubs and VirtualHub, username is either "user" for readonly or "admin" for read/write. Only ready-only credentials (if any) will saved in the configuration as Yocto-Visualization will ask for read/write credentials when saving, if needed.';
      p.style.fontSize = "smaller";
      this._pwdPanel.appendChild(p);
      this._container.appendChild(this._pwdPanel);
    }
    this._connectionErrorMsg.innerText = errmsg;
    this._nextButton.visible = true;
    this._prevButton.visible = true;
    this._cancelButton.visible = this.DEFAULTCANCELABLE;
    this._pwdPanel.style.display = "";
    let tabIndex = 1;
    this._adminNameInput.tabIndex = tabIndex++;
    this._adminPasswordInput.tabIndex = tabIndex++;
    this._userNameInput.tabIndex = tabIndex++;
    this._userPasswordInput.tabIndex = tabIndex++;
    this._prevButton.tabIndex = tabIndex++;
    this._nextButton.tabIndex = tabIndex++;
    this._adminNameInput.focus();
    this.MakeSureCredentialsAreNotEmpty();
  }
  createTextRow(caption, value) {
    let Row = document.createElement("TR");
    let TD1 = document.createElement("TD");
    TD1.style.whiteSpace = "normal";
    TD1.style.whiteSpace = "nowrap";
    TD1.innerText = caption;
    Row.appendChild(TD1);
    let TD2 = document.createElement("TD");
    TD2.style.whiteSpace = "normal";
    TD2.innerText = value;
    Row.appendChild(TD2);
    return Row;
  }
  async showHubDescription(visible, goingback) {
    if (!visible) {
      if (this._descPanel != null)
        this._descPanel.style.display = "none";
      return;
    }
    if (this._descPanel == null) {
      this._descPanel = this.createNewContentDiv();
      this._container.appendChild(this._descPanel);
    }
    if (!goingback) {
      this.removeAllChilds(this._descPanel);
      this._alreadyInstalled = false;
      let p = document.createElement("P");
      p.innerText = "Sucessfully connected to Hub " + this._ipAddrInput.value;
      this._descPanel.appendChild(p);
      let m = this._currentHub;
      let Table = document.createElement("TABLE");
      Table.style.marginTop = "20px";
      Table.style.marginBottom = "20px";
      let serial = await m.get_serialNumber();
      let firmware = "" + await m.get_firmwareRelease();
      Table.appendChild(this.createTextRow("Model:", await m.get_productName()));
      Table.appendChild(this.createTextRow("Serial:", serial));
      Table.appendChild(this.createTextRow("Firmware:", firmware));
      let tmp = firmware.lastIndexOf(".");
      if (tmp >= 0)
        firmware = firmware.substr(tmp + 1);
      this._instancesFiles = [];
      let freespace = 0;
      this._instancesFiles = [];
      this._currentfs = null;
      let error = "";
      if (firmware.indexOf("-") < 0 && parseInt(firmware) < this.FIRMWAREMINVERSION) {
        error = "Hub firmware is too old for Yocto-Visualization to run properly. You need at least version " + this.FIRMWAREMINVERSION;
        this._nextButton.enabled = false;
      }
      if (error == "") {
        let ids = await m.get_functionIds("Files");
        if (ids.length > 0) {
          this._currentfs = await YFiles.FindFiles(serial + "." + ids[0]);
          freespace = Math.floor(await this._currentfs.get_freeSpace() / 1024);
          this._instancesFiles = await this._currentfs.get_list("yv4web*");
          Table.appendChild(this.createTextRow("Free space:", freespace.toString() + "K"));
          this._nextButton.enabled = true;
          if (freespace < 200) {
            error = "Not enough free space on device, please make sure there is at least 200K available.";
            this._nextButton.enabled = false;
          }
        } else {
          error = "No filesystem found on hub. On VirtualHub, the filesystem feature needs to be explicitely enabled at startup with the -F flag.";
        }
      }
      if (error != "") {
        Table.appendChild(this.createTextRow(" ", " "));
        let Row = document.createElement("TR");
        let TD1 = document.createElement("TD");
        TD1.style.whiteSpace = "normal";
        TD1.innerHTML = ressources.FailedIcon("32", true, false, false, false, "oops");
        TD1.style.textAlign = "right";
        Row.appendChild(TD1);
        let TD2 = document.createElement("TD");
        TD2.style.whiteSpace = "normal";
        TD2.style.fontSize = "smaller";
        TD2.innerText = error;
        Row.appendChild(TD2);
        Table.appendChild(Row);
        this._nextButton.enabled = false;
      }
      this._descPanel.appendChild(Table);
      if (this._instancesFiles.length > 0) {
        let p2 = document.createElement("P");
        p2.innerText = "Yocto-Visualization (for web) appears to be already installed on this hub. Click on next to modify this installation.";
        this._descPanel.appendChild(p2);
        this._alreadyInstalled = true;
      }
    }
    this._descPanel.style.display = "";
    this._nextButton.visible = true;
    this._prevButton.visible = true;
    this._cancelButton.visible = this.DEFAULTCANCELABLE;
    let tabIndex = 1;
    this._prevButton.tabIndex = tabIndex++;
    this._nextButton.tabIndex = tabIndex++;
    this._nextButton.focus();
  }
  async loadWebPagesList(filenameDesc) {
    this._webPageinstances = [];
    let webFiles = await this._currentfs.get_list("*");
    for (let i = 0; i < webFiles.length; i++) {
      let filename = await webFiles[i].get_name();
      if (filename.indexOf(".html") >= 0) {
        if (filenameDesc != null) {
          filenameDesc.innerText = "Now downloading " + filename + "...";
        }
        let contents = await this._currentfs.download(filename);
        if (filename.slice(-3) == ".gz") {
          contents = Pako_Inflate.ungzip(contents, {});
        }
        let contentsStr = YAPI.imm_bin2str(contents);
        if (contentsStr.indexOf("window.runYV()") > 0) {
          this._webPageinstances.push(new pageInstance(filename, contents));
        }
      }
    }
  }
  async showModifyInstallPanel(visible, goingback) {
    if (!visible) {
      if (this._modifyInstallPanel != null)
        this._modifyInstallPanel.style.display = "none";
      return;
    }
    this._nextButton.visible = false;
    this._prevButton.visible = false;
    this._cancelButton.visible = false;
    if (this._modifyInstallPanel == null) {
      this._modifyInstallPanel = this.createNewContentDiv();
      this._container.appendChild(this._modifyInstallPanel);
    }
    if (!goingback) {
      this.removeAllChilds(this._modifyInstallPanel);
      this._jsCodeinstances = [];
      this._webPageinstances = [];
      let p = document.createElement("P");
      p.innerText = "Please wait, downloading and parsing files from the hub ";
      this._modifyInstallPanel.appendChild(p);
      this._modifyInstallPanel.style.display = "";
      let files = document.createElement("P");
      files.innerText = "";
      let filenameDesc = document.createElement("P");
      filenameDesc.style.fontSize = "smaller";
      this._modifyInstallPanel.appendChild(filenameDesc);
      for (let i = 0; i < this._instancesFiles.length; i++) {
        let filename = await this._instancesFiles[i].get_name();
        filenameDesc.innerText = "Now downloading " + filename + "...";
        files.innerText = filename;
        let contentsStr = "";
        let contents = await this._currentfs.download(filename);
        if (filename.slice(-3) == ".gz") {
          contents = Pako_Inflate.ungzip(contents, {});
        }
        contentsStr = YAPI.imm_bin2str(contents);
        let esTarget = "";
        let version = "";
        let readonlyVersion = true;
        let p2 = contentsStr.indexOf("*/");
        if (p2 > 0) {
          let firstLine = contentsStr.slice(0, p2);
          let p1 = firstLine.indexOf("(");
          let p22 = firstLine.indexOf(")");
          if (p1 > 0 && p22 > p1) {
            let tokens = firstLine.slice(p1 + 1, p22).split(" ");
            if (tokens.length > 0)
              esTarget = tokens[0];
            if (tokens.length > 1)
              readonlyVersion = tokens[1] != "full";
            if (tokens.length > 2)
              version = tokens[2];
          }
        }
        this._jsCodeinstances.push(new codeInstance(filename, esTarget, version, readonlyVersion));
      }
      await this.loadWebPagesList(filenameDesc);
      filenameDesc.style.display = "none";
      p.innerText = "What would you like to do ?";
      let uninstallLegend = document.createElement("span");
      uninstallLegend.innerText = "Uninstall / delete all Yocto-Visualization (for web) related files\n\n";
      this._uninstallOpt = document.createElement("input");
      this._uninstallOpt.setAttribute("type", "radio");
      this._uninstallOpt.setAttribute("name", "installType");
      this._modifyInstallPanel.appendChild(this._uninstallOpt);
      this._modifyInstallPanel.appendChild(uninstallLegend);
      let BuildsFound = {};
      for (let i = 0; i < this._jsCodeinstances.length; i++) {
        BuildsFound[this._jsCodeinstances[i].version] = 1;
      }
      let BuildsFoundList = "";
      for (let key in BuildsFound) {
        if (BuildsFound.hasOwnProperty(key)) {
          BuildsFoundList += (BuildsFoundList != "" ? ", " : "") + key;
        }
      }
      let updateLegend = document.createElement("span");
      updateLegend.innerText = "Update all from " + BuildsFoundList + " to " + constants.buildVersion + "\n\n";
      this._updateOpt = document.createElement("input");
      this._updateOpt.setAttribute("type", "radio");
      this._updateOpt.setAttribute("name", "installType");
      this._modifyInstallPanel.appendChild(this._updateOpt);
      this._modifyInstallPanel.appendChild(updateLegend);
      let addInstanceLegend = document.createElement("span");
      addInstanceLegend.innerText = "Add a new instance \n\n";
      this._addInstanceOpt = document.createElement("input");
      this._addInstanceOpt.setAttribute("type", "radio");
      this._addInstanceOpt.setAttribute("name", "installType");
      this._modifyInstallPanel.appendChild(this._addInstanceOpt);
      this._modifyInstallPanel.appendChild(addInstanceLegend);
      let modInstanceLegend = document.createElement("span");
      modInstanceLegend.innerText = "Modify or delete existing instances \n\n";
      this._modInstanceOpt = document.createElement("input");
      this._modInstanceOpt.setAttribute("type", "radio");
      this._modInstanceOpt.setAttribute("name", "installType");
      this._modifyInstallPanel.appendChild(this._modInstanceOpt);
      this._modifyInstallPanel.appendChild(modInstanceLegend);
      if (!this._uninstallOpt.checked && !this._updateOpt.checked && !this._addInstanceOpt.checked && !this._modInstanceOpt.checked) {
        this._updateOpt.checked = true;
      }
    }
    this._modifyInstallPanel.style.display = "";
    this._nextButton.enabled = true;
    this._prevButton.enabled = true;
    this._nextButton.visible = true;
    this._prevButton.visible = true;
    this._cancelButton.visible = this.DEFAULTCANCELABLE;
    let tabIndex = 1;
    this._uninstallOpt.tabIndex = tabIndex++;
    this._updateOpt.tabIndex = tabIndex++;
    this._addInstanceOpt.tabIndex = tabIndex++;
    this._modInstanceOpt.tabIndex = tabIndex++;
    this._prevButton.tabIndex = tabIndex++;
    this._nextButton.tabIndex = tabIndex++;
    this._nextButton.focus();
  }
  async showModInstancesPanel(visible, goingback) {
    if (!visible) {
      if (this._modInstancesPanel != null)
        this._modInstancesPanel.style.display = "none";
      return;
    }
    if (this._modInstancesPanel == null) {
      this._modInstancesPanel = this.createNewContentDiv();
      this._container.appendChild(this._modInstancesPanel);
    }
    let tabIndex = 1;
    if (!goingback) {
      this.removeAllChilds(this._modInstancesPanel);
      let p = document.createElement("P");
      this._modInstancesPanel.appendChild(p);
      p.innerText = "Here is a list of installed instances. Select an action for each one, then click on next to have them applied.";
      let table = document.createElement("Table");
      table.style.marginLeft = "20px";
      for (let i = 0; i < this._webPageinstances.length; i++) {
        let tr = document.createElement("TR");
        let td = document.createElement("TD");
        td.style.whiteSpace = "normal";
        td.innerText = this._webPageinstances[i].http_filename + (this._webPageinstances[i].compressed ? "[.gz]" : "");
        tr.appendChild(td);
        let td2 = document.createElement("TD");
        td2.style.whiteSpace = "normal";
        td2.style.paddingLeft = "10px";
        let chooser = document.createElement("SELECT");
        chooser.tabIndex = tabIndex++;
        let opt = document.createElement("OPTION");
        opt.tabIndex = tabIndex++;
        opt.text = "Do Nothing";
        opt.value = this._MODIFYNOTHING.toString();
        chooser.add(opt);
        let opt2 = document.createElement("OPTION");
        if (this._webPageinstances[i].compressed) {
          opt2.text = "Uncompress instance file";
          opt2.value = this._MODIFYUNCOMPRESS.toString();
        } else {
          opt2.text = "Compress instance file";
          opt2.value = this._MODIFYCOMPRESS.toString();
        }
        chooser.add(opt2);
        let opt3 = document.createElement("OPTION");
        if (this._webPageinstances[i].readonly) {
          opt3.text = "Allow read/write";
          opt3.value = this._MODIFYMAKEREADWRITE.toString();
        } else {
          opt3.text = "Make read only";
          opt3.value = this._MODIFYMAKEREADONLY.toString();
        }
        chooser.add(opt3);
        let opt4 = document.createElement("OPTION");
        if (this._webPageinstances[i].useMinified) {
          opt4.text = "Use human readable JS module";
          opt4.value = this._MODIFYUSEPLAIN.toString();
        } else {
          opt4.text = "Use minified JS module";
          opt4.value = this._MODIFYUSEMINIFIED.toString();
        }
        chooser.add(opt4);
        let opt5 = document.createElement("OPTION");
        opt5.text = "Update credentials";
        opt5.value = this._MODIFYUPDATE.toString();
        chooser.add(opt5);
        let opt6 = document.createElement("OPTION");
        opt6.text = "Delete (cannot be reverted)";
        opt6.value = this._MODIFYDELETE.toString();
        chooser.add(opt6);
        let index = i;
        chooser.addEventListener("change", () => {
          this._webPageinstances[index].action = Number(chooser.value);
        });
        td2.appendChild(chooser);
        tr.appendChild(td2);
        table.appendChild(tr);
      }
      this._modInstancesPanel.appendChild(table);
      let p2 = document.createElement("P");
      this._removeUnusedJs = document.createElement("INPUT");
      this._removeUnusedJs.tabIndex = tabIndex++;
      this._removeUnusedJs.type = "checkbox";
      this._removeUnusedJs.checked = true;
      p2.appendChild(this._removeUnusedJs);
      let span = document.createElement("SPAN");
      span.innerText = "Remove unused Yocto-Visualization (for web) JS module files";
      p2.appendChild(span);
      this._modInstancesPanel.appendChild(p2);
      this._prevButton.tabIndex = tabIndex++;
      this._nextButton.tabIndex = tabIndex++;
      this._nextButton.focus();
    }
    this._modInstancesPanel.style.display = "";
  }
  async showCustomFilesPanel(visible, goingback) {
    if (!visible) {
      if (this._customFilesPanel != null)
        this._customFilesPanel.style.display = "none";
      return;
    }
    if (this._customFilesPanel == null) {
      this._customFilesPanel = this.createNewContentDiv();
      this._container.appendChild(this._customFilesPanel);
    }
    if (!goingback) {
      this.removeAllChilds(this._customFilesPanel);
      let p = document.createElement("P");
      p.innerText = this._plannedaction == this.ACTIONINSTALL ? "Optionnaly, you can customize your Yocto-Visualization (for web) installation by providing some files" : "Optionnaly, you can customize your new instance by providing some files";
      this._customFilesPanel.appendChild(p);
      let Table = document.createElement("TABLE");
      Table.style.fontSize = "smaller";
      Table.style.marginTop = "20px";
      Table.style.marginBottom = "20px";
      let Row;
      let TD1;
      let TD2;
      Row = document.createElement("TR");
      TD1 = document.createElement("TD");
      TD1.style.whiteSpace = "normal";
      TD1.colSpan = 2;
      TD1.style.textAlign = "justify";
      TD1.innerText = 'You can choose an initial XML configuration file. You can get a XML configuration file from a Yocto-Visualization (for web) instance in the  "Global configulation" panel. You can also use a config.xml file from the Yocto-Visualization native version.';
      Row.appendChild(TD1);
      Table.appendChild(Row);
      Row = document.createElement("TR");
      TD1 = document.createElement("TD");
      TD1.style.whiteSpace = "normal";
      TD1.innerText = "Config file:";
      Row.appendChild(TD1);
      TD2 = document.createElement("TD");
      TD2.style.whiteSpace = "normal";
      this._configFileInput = document.createElement("INPUT");
      this._configFileInput.type = "file";
      this._configFileInput.accept = ".xml";
      TD2.appendChild(this._configFileInput);
      Row.style.marginBottom = "10px";
      Row.appendChild(TD2);
      Table.appendChild(Row);
      Row = document.createElement("TR");
      TD1 = document.createElement("TD");
      TD1.style.whiteSpace = "normal";
      TD1.colSpan = 2;
      TD1.style.textAlign = "justify";
      TD1.innerText = "\nYou can choose a container HTML file. Note: if this file relies on local dependencies such as images or CSS files, you'll have to upload them on the hub yourself.";
      Row.appendChild(TD1);
      Table.appendChild(Row);
      this._customFilesPanel.appendChild(Table);
      Row = document.createElement("TR");
      TD1 = document.createElement("TD");
      TD1.style.whiteSpace = "normal";
      TD1.innerText = "HTML file:";
      Row.appendChild(TD1);
      TD2 = document.createElement("TD");
      TD2.style.whiteSpace = "normal";
      this._webPageInput = document.createElement("INPUT");
      this._webPageInput.type = "file";
      this._webPageInput.accept = ".html";
      TD2.appendChild(this._webPageInput);
      Row.appendChild(TD2);
      Table.appendChild(Row);
    }
    this._customFilesPanel.style.display = "";
    this._nextButton.enabled = true;
    this._prevButton.enabled = true;
    this._nextButton.visible = true;
    this._prevButton.visible = true;
    this._cancelButton.visible = this.DEFAULTCANCELABLE;
    let tabIndex = 1;
    this._webPageInput.tabIndex = tabIndex++;
    this._configFileInput.tabIndex = tabIndex++;
    this._prevButton.tabIndex = tabIndex++;
    this._nextButton.tabIndex = tabIndex++;
    this._nextButton.focus();
  }
  async showOptionsPanel(visible, goingback) {
    if (!visible) {
      if (this._optionsPanel != null)
        this._optionsPanel.style.display = "none";
      return;
    }
    if (this._optionsPanel == null) {
      this._optionsPanel = this.createNewContentDiv();
      let p = document.createElement("P");
      p.innerText = this._plannedaction == this.ACTIONINSTALL ? "You can also customize the installation behavior" : "You can also customize this new instance behavior";
      this._optionsPanel.appendChild(p);
      p = document.createElement("P");
      p.style.fontSize = "smaller";
      p.style.marginBottom = "0px";
      p.style.marginTop = "0px";
      this._fileprefixInput = document.createElement("INPUT");
      let presetname = this.DEFAULTFILEPREFIX;
      let n = 1;
      let checkgain = false;
      do {
        checkgain = false;
        for (let i = 0; i < this._webPageinstances.length; i++) {
          if (presetname + this.TARGETEXTENSION == this._webPageinstances[i].http_filename) {
            n++;
            presetname = this.DEFAULTFILEPREFIX + "(" + n.toString() + ")";
            checkgain = true;
          }
        }
      } while (checkgain);
      this._fileprefixInput.value = presetname;
      this._fileprefixInput.maxLength = 10;
      this._fileprefixInput.size = 10;
      let span = document.createElement("SPAN");
      span.innerText = "Set the instance name to : ";
      p.appendChild(span);
      p.appendChild(this._fileprefixInput);
      this._optionsPanel.appendChild(p);
      p = document.createElement("P");
      p.style.fontSize = "smaller";
      p.style.marginBottom = "0px";
      p.style.marginTop = "0px";
      this._useFullVersionInput = document.createElement("INPUT");
      this._useFullVersionInput.type = "checkbox";
      p.appendChild(this._useFullVersionInput);
      span = document.createElement("SPAN");
      span.innerText = this._plannedaction == this.ACTIONINSTALL ? "Install the non-minified version (easier to debug)" : "Use the non-minified version (easier to debug)";
      p.appendChild(span);
      this._optionsPanel.appendChild(p);
      p = document.createElement("P");
      p.style.fontSize = "smaller";
      p.style.marginBottom = "0px";
      p.style.marginTop = "0px";
      this._makeDefaultInput = document.createElement("INPUT");
      this._makeDefaultInput.type = "checkbox";
      p.appendChild(this._makeDefaultInput);
      span = document.createElement("SPAN");
      span.innerText = this._plannedaction == this.ACTIONINSTALL ? "Make Yocto-Visualization (for web) the hub's default page" : "Make this instance the hub's default page";
      p.appendChild(span);
      this._optionsPanel.appendChild(p);
      p = document.createElement("P");
      p.style.fontSize = "smaller";
      p.style.marginBottom = "0px";
      p.style.marginTop = "0px";
      this._useReadOnlyInput = document.createElement("INPUT");
      this._useReadOnlyInput.type = "checkbox";
      p.appendChild(this._useReadOnlyInput);
      span = document.createElement("SPAN");
      span.innerText = this._plannedaction == this.ACTIONINSTALL ? "Make the install read-only" : "Make this instance read-only";
      p.appendChild(span);
      this._optionsPanel.appendChild(p);
      if (this._jsCodeinstances.length > 0) {
        this._useReadOnlyInput.checked = this._jsCodeinstances[0].readonly;
        this._useFullVersionInput.checked = !this._jsCodeinstances[0].minified;
      }
      p = document.createElement("P");
      p.innerText = 'Click on "Next" button to start the installation';
      this._optionsPanel.appendChild(p);
      this._container.appendChild(this._optionsPanel);
    }
    this._nextButton.visible = true;
    this._prevButton.visible = true;
    this._cancelButton.visible = this.DEFAULTCANCELABLE;
    this._optionsPanel.style.display = "";
    let tabIndex = 1;
    this._fileprefixInput.tabIndex = tabIndex++;
    this._useFullVersionInput.tabIndex = tabIndex++;
    this._makeDefaultInput.tabIndex = tabIndex++;
    this._useReadOnlyInput.tabIndex = tabIndex++;
    this._prevButton.tabIndex = tabIndex++;
    this._nextButton.tabIndex = tabIndex++;
    this._nextButton.focus();
  }
  logLine(line) {
    let p = document.createElement("P");
    p.innerText = line + " ";
    p.style.fontSize = "smaller";
    p.style.marginLeft = "10px";
    p.style.marginTop = "0px;";
    p.style.marginBottom = "0px;";
    p.style.paddingTop = "0px;";
    p.style.paddingBottom = "0px;";
    let span = document.createElement("SPAN");
    p.appendChild(span);
    this._runPanel.appendChild(p);
    return span;
  }
  async showRunPanel(visible, goingback) {
    if (!visible) {
      if (this._runPanel != null)
        this._runPanel.style.display = "none";
      return;
    }
    if (this._runPanel == null) {
      this._runPanel = this.createNewContentDiv();
    }
    this.removeAllChilds(this._runPanel);
    this._runPanel.style.display = "";
    let desc = document.createElement("P");
    this._runPanel.appendChild(desc);
    this._container.appendChild(this._runPanel);
    this._nextButton.visible = false;
    this._prevButton.visible = false;
    this._cancelButton.visible = false;
    switch (this._plannedaction) {
      case this.ACTIONINSTALL:
        desc.innerText = "Installing on " + this._currentHub_Addr + "... please wait.";
        try {
          await this.install((line) => {
            return this.logLine(line);
          });
        } catch (e) {
          this.gotoPanel(this.CONNECTIONERROR, "Installation failed with an internal error : " + e.toString() + "\n\nFeel free to contact Yoctopuce support.");
        }
        break;
      case this.ACTIONADDINSTANCE:
        desc.innerText = "Creating new instance  on " + this._currentHub_Addr + "... please wait.";
        try {
          await this.install((line) => {
            return this.logLine(line);
          });
        } catch (e) {
          this.gotoPanel(this.CONNECTIONERROR, "Instance creation failed with an internal error : " + e.toString() + "\n\nFeel free to contact Yoctopuce support.");
        }
        break;
      case this.ACTIONUNINSTALL:
        desc.innerText = "Uninstalling everything from " + this._currentHub_Addr + "... please wait.";
        try {
          await this.uninstall((line) => {
            return this.logLine(line);
          });
        } catch (e) {
          this.gotoPanel(this.CONNECTIONERROR, "Installation failed with an internal error : " + e.toString() + "\n\nFeel free to contact Yoctopuce support.");
        }
        break;
      case this.ACTIONUPDATE:
        desc.innerText = "Updating js files on " + this._currentHub_Addr + "... please wait.";
        try {
          await this.upgrade((line) => {
            return this.logLine(line);
          });
        } catch (e) {
          this.gotoPanel(this.CONNECTIONERROR, "Update failed with an internal error : " + e.toString() + "\n\nFeel free to contact Yoctopuce support.");
        }
        break;
      case this.ACTIONMODINSTANCE:
        desc.innerText = "Modifying instances on " + this._currentHub_Addr + "... please wait.";
        try {
          await this.modifyInstances((line) => {
            return this.logLine(line);
          });
        } catch (e) {
          this.gotoPanel(this.CONNECTIONERROR, "Instances modification failed with an internal error : " + e.toString() + "\n\nFeel free to contact Yoctopuce support.");
        }
        break;
    }
  }
  checkHTMLfile(htmlData, errmsg) {
    let upper = htmlData.toUpperCase();
    if (upper.indexOf("<HTML") < 0) {
      errmsg.msg = "Provided web page is not a proper HTML file: no HTML tag";
      return false;
    }
    if (upper.indexOf("</BODY>") < 0) {
      errmsg.msg = "Provided web page has an unexpected structure: no closing BODY tag";
      return false;
    }
    return true;
  }
  checkConfigfile(xmlData, errmsg) {
    let parser = new DOMParser();
    let doc = parser.parseFromString(xmlData, "application/xml");
    let root = null;
    doc.childNodes.forEach((node) => {
      if (node.nodeName.toUpperCase() == "ROOT" && root == null)
        root = node;
    });
    if (root == null) {
      errmsg.msg = "Provided config XML file is not a proper YoctoVisualization 2 config file. Unable to find ROOT node, either the root node does not exists or the file caused an XML parse error.";
      return false;
    }
    let rootNode = new YXmlNode(root);
    let attributes = rootNode.Attributes;
    if (!attributes.hasOwnProperty("version")) {
      errmsg.msg = "Provided  XML config file is not a proper Yocto-Visualization 2 config file (No ROOT Version attribute)";
      return false;
    }
    if (parseFloat(attributes["version"]) < 2) {
      errmsg.msg = "Provided XML config file is not a proper Yocto-Visualization 2 config file (at least Version 2.0 is required)";
      return false;
    }
    return true;
  }
  findChild(parent, name) {
    let res = null;
    parent.childNodes.forEach((node) => {
      if (node.nodeName == name) {
        res = node;
        return;
      }
    });
    return res;
  }
  patchConfigFile(xmlData) {
    let startTag = "<Hubs>";
    let endTag = "</Hubs>";
    let parser = new DOMParser();
    let doc = parser.parseFromString(xmlData, "application/xml");
    let rootNode = this.findChild(doc, "ROOT");
    if (rootNode == null)
      throw "No root node in config file.";
    let configNode = this.findChild(rootNode, "Config");
    if (configNode == null)
      throw "No config node in config file.";
    let Hubs = this.findChild(configNode, "Hubs");
    let HubSection;
    if (Hubs == null) {
      HubSection = startTag + "\n" + this.getHubConfig() + "\n" + endTag + "\n";
      xmlData = xmlData.replace("<Config>", "<Config>\n" + HubSection);
    } else {
      let list = Hubs.childNodes;
      let sourceHubFound = false;
      HubSection = startTag + "\n";
      for (let i = 0; i < list.length; i++) {
        if (list[i].nodeName == "Hub") {
          let node = new YXmlNode(list[i]);
          let attributes = node.Attributes;
          let addr = attributes.hasOwnProperty("addr") ? attributes["addr"] : "";
          let port = attributes.hasOwnProperty("port") ? attributes["port"] : "80";
          let protocol = attributes.hasOwnProperty("protocol") ? attributes["protocol"] : "";
          let path = attributes.hasOwnProperty("path") ? attributes["path"] : "";
          let username = attributes.hasOwnProperty("user") ? attributes["user"] : "";
          let password = attributes.hasOwnProperty("password") ? attributes["password"] : "";
          if (!sourceHubFound && addr == this._currentHub_Addr && port == this._currentHub_port && path == this._currentHub_path) {
            sourceHubFound = true;
            HubSection += "    " + this.getHubConfig() + "\n";
          } else {
            HubSection += "    " + this.createHubRecord(protocol, addr, port, path, username, password, true) + "\n";
          }
        }
      }
      if (!sourceHubFound)
        HubSection += "    " + this.getHubConfig() + "\n";
      HubSection += "  ";
      let indexStart = xmlData.indexOf(startTag);
      let indexStop = xmlData.indexOf(endTag);
      if (indexStart < 0)
        throw "Cannot locate Hubs start tag in provided  config file";
      if (indexStop < 0)
        throw "Cannot locate Hubs end tag in provided  config file";
      xmlData = xmlData.substr(0, indexStart) + HubSection + xmlData.substr(indexStop);
    }
    return xmlData;
  }
  createHubRecord(protocol, addr, port, path, username, password, removable) {
    let res = '<Hub protocol="' + constants.XMLquote(protocol) + '" addr="' + constants.XMLquote(addr) + '" port="' + constants.XMLquote(port) + '"';
    if (path != "")
      res += ' path="' + constants.XMLquote(path) + '"';
    if (username != "")
      res += ' user="' + constants.XMLquote(username) + '"';
    if (password != "")
      res += ' password="' + constants.XMLquote(password) + '"';
    if (!removable)
      res += ' removable="FALSE"';
    res += "/>";
    return res;
  }
  getHubConfig() {
    let username = "";
    let password = "";
    if (this._currentHub_ReadOnlyProtected) {
      username = this._userNameInput.value;
      password = Hub.encryptPassword(this._userPasswordInput.value);
    }
    return this.createHubRecord(this._currentHub_protocol, this._currentHub_Addr, this._currentHub_port, this._currentHub_path, username, password, false);
  }
  getSeedCode(configfile, readonly, minified) {
    let res = '\n<script type="module">\n';
    if (configfile == null)
      configfile = '<?xml version="1.0" ?><ROOT version="2.1"><Config><Hubs>' + this.getHubConfig() + "</Hubs></Config></ROOT>\n";
    let filename = "yv4web-" + (readonly ? "readonly" : "full") + (minified ? ".min" : "") + ".js";
    res += ' import { YWebPage, YoctoHubFileHandler }  from "./' + filename + '";\n';
    res += " window.runYV= async ()=>{";
    res += " let filehandler = await YoctoHubFileHandler.start(";
    if (configfile != null)
      res += JSON.stringify(configfile);
    res += ");\n";
    res += "  YWebPage.run(filehandler.xmlConfigData, filehandler.configChangeCallbackFct";
    if (!readonly)
      res += ",filehandler.saveFct";
    res += ");\n";
    res += "};\n window.runYV();<\/script>\n";
    res += '<script nomodule="">\n';
    res += `document.write("<p style='font-family: sans-serif; text-align:center'>Yocto-Visualization (for web) cannot run on this browser. Sorry.<br>Consider using a more recent browser, or <a href='https://www.yoctopuce.com/EN/tools.php'>the native version</a>. </p>")
`;
    res += "<\/script>\n";
    return res;
  }
  defaultHTMLfile(configfile, readonly, minified) {
    return "<!DOCTYPE HTML>\n<HTML lang='en-US'><HEAD>\n<title>\nYocto-Visualization</title>\n" + this.icon + "\n<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no'/></HEAD>\n<BODY>\n</BODY>" + this.getSeedCode(configfile, readonly, minified) + "\n</HTML>\n";
  }
  async uploadWidthProgress(str_path, bin_content, progress) {
    let yreq = await this._currentfs._uploadWithProgress(str_path, bin_content, progress);
    return yreq.errorType;
  }
  async upgrade(log) {
    let install_minified_readonly = false;
    let install_plain_readonly = false;
    let install_minified_readwrite = false;
    let install_plain_readwrite = false;
    for (let i = 0; i < this._jsCodeinstances.length; i++) {
      if (this._jsCodeinstances[i].minified) {
        if (this._jsCodeinstances[i].readonly) {
          install_minified_readonly = true;
        } else {
          install_minified_readwrite = true;
        }
      } else {
        if (this._jsCodeinstances[i].readonly) {
          install_plain_readonly = true;
        } else {
          install_plain_readwrite = true;
        }
      }
    }
    if (install_minified_readonly)
      await this.copyJsCode(log, true, true);
    if (install_plain_readonly)
      await this.copyJsCode(log, true, false);
    if (install_minified_readwrite)
      await this.copyJsCode(log, false, true);
    if (install_plain_readwrite)
      await this.copyJsCode(log, false, false);
    log("Done.");
    setTimeout(() => {
      this.gotoPanel(this.DONEPANEL);
    }, 2e3);
  }
  async syncJsFile(log, required, readonly, minified, removeunused) {
    let jsfile = this.get_js_filename(readonly, minified) + ".gz";
    let exists = await this._currentfs.fileExist(jsfile);
    if (required && !exists)
      await this.copyJsCode(log, readonly, minified);
    if (!required && exists && removeunused) {
      let span = log("Deleting " + jsfile);
      await this._currentfs.remove(jsfile);
      span.innerText = "done.";
    }
  }
  async syncJsFileVersions(log, removeunused) {
    let require_minified_readonly = false;
    let require_plain_readonly = false;
    let require_minified_readwrite = false;
    let require_plain_readwrite = false;
    for (let i = 0; i < this._webPageinstances.length; i++) {
      if (this._webPageinstances[i].useMinified) {
        if (this._webPageinstances[i].readonly) {
          require_minified_readonly = true;
        } else {
          require_minified_readwrite = true;
        }
      } else {
        if (this._webPageinstances[i].readonly) {
          require_plain_readonly = true;
        } else {
          require_plain_readwrite = true;
        }
      }
    }
    await this.syncJsFile(log, require_minified_readonly, true, true, removeunused);
    await this.syncJsFile(log, require_plain_readonly, true, false, removeunused);
    await this.syncJsFile(log, require_minified_readwrite, false, true, removeunused);
    await this.syncJsFile(log, require_plain_readwrite, false, false, removeunused);
  }
  async setInstanceCredentials(log, page, hubaddr, hubpath, newusername, newpwd) {
    let contents = YAPI.imm_bin2str(page.contents);
    let start = contents.indexOf("<Hub ");
    let mustupload = false;
    let end;
    while (start > 0) {
      let end2 = contents.indexOf("/>", start);
      if (end2 > start) {
        let hubline = contents.substring(start, end2 + 2);
        while (hubline.indexOf('\\"') > 0)
          hubline = hubline.replace('\\"', '"');
        let state = 0;
        let key = "";
        let value = "";
        let data = [];
        let parseError = false;
        for (let i = 4; i < hubline.length - 1 && !parseError; i++) {
          let c = hubline.charAt(i);
          switch (state) {
            case 0:
              if (c >= "A" && c <= "Z" || c >= "a" && c <= "z") {
                key = c;
                state = 1;
              } else if (c != " ")
                parseError = true;
              break;
            case 1:
              if (c >= "A" && c <= "Z" || c >= "a" && c <= "z" || c >= "0" && c <= "9" || c == "_")
                key = key + c;
              else if (c == " ")
                state = 2;
              else if (c == "=")
                state = 3;
              else
                parseError = true;
              break;
            case 2:
              if (c == "=")
                state = 3;
              else if (c != " ")
                parseError = true;
              break;
            case 3:
              if (c == '"')
                state = 4;
              else if (c == "'")
                state = 5;
              else if (c != " ")
                parseError = true;
              break;
            case 4:
              if (c == '"')
                state = 6;
              else
                value = value + c;
              break;
            case 5:
              if (c == "'")
                state = 6;
              else
                value = value + c;
              break;
            case 6:
              data.push([key, value]);
              key = "";
              value = "";
              state = 0;
              break;
          }
        }
        if (state != 0 || parseError)
          log("hub definition parse error");
        else {
          let addrok = false;
          let pathok = false;
          for (let i = 0; i < data.length; i++) {
            if (data[i][0] == "addr" && data[i][1].toUpperCase() == hubaddr.toUpperCase())
              addrok = true;
            if (data[i][0] == "path" && data[i][1] == hubpath)
              pathok = true;
          }
          if (addrok && pathok) {
            {
              for (let i = data.length - 1; i >= 0; i--)
                if (data[i][0] == "user" || data[i][0] == "password")
                  data.splice(i, 1);
            }
            if (newusername != "" && newpwd != "") {
              let p = Hub.Encrypt(newpwd, Hub.loginCypherPassword);
              data.splice(1, 0, ["user", "user"]);
              data.splice(2, 0, ["password", p]);
            }
            let newhubline = "<Hub ";
            for (let i = 0; i < data.length; i++) {
              newhubline += data[i][0] + '=\\"' + data[i][1] + '\\"' + (i < data.length - 1 ? " " : "");
            }
            contents = contents.substring(0, start) + newhubline + contents.substring(end2);
            mustupload = true;
          }
        }
        start = contents.indexOf("<Hub ", start + 4);
      }
    }
    if (mustupload)
      this.uploadpage(log, page, contents);
  }
  async patchPageInstance(log, page, signature1, replace1, altsignature1, altreplace1, signature2, replace2) {
    let contents = YAPI.imm_bin2str(page.contents);
    let p = contents.indexOf(signature1);
    if (p < 0 && altsignature1 != "") {
      signature1 = altsignature1;
      replace1 = altreplace1;
      p = contents.indexOf(signature1);
    }
    if (p < 0)
      throw "Operation failed: cannot find the [" + signature1 + "] import signature in " + page.fs_filename;
    contents = contents.substr(0, p) + replace1 + contents.substr(p + signature1.length);
    if (signature2 != "") {
      p = contents.indexOf(signature2);
      if (p < 0)
        throw "Operation failed: cannot find the [" + signature2 + "] signature parameter in " + page.fs_filename;
      contents = contents.substr(0, p) + replace2 + contents.substr(p + signature2.length);
    }
    this.uploadpage(log, page, contents);
  }
  async uploadpage(log, page, contents) {
    let bincontents = YAPI.imm_str2bin(contents);
    let filename = page.fs_filename;
    if (page.compressed) {
      let status2 = log("Compressing  " + filename);
      bincontents = Pako_Deflate.gzip(bincontents, { level: 9 });
      status2.innerText = "done";
    }
    let status = log("Uploading  " + filename + " to hub");
    status.innerText = "0%";
    let success = await this.uploadWidthProgress(filename, bincontents, (curr, total) => {
      status.innerText = Math.round(100 * curr / total).toString() + "%";
    });
    status.innerText = "done";
    if (success != YAPI_SUCCESS)
      throw "Upload failed (Error" + success.toString() + ").";
  }
  async modifyInstances(log) {
    for (let i = 0; i < this._webPageinstances.length; i++) {
      switch (this._webPageinstances[i].action) {
        case this._MODIFYNOTHING:
          break;
        case this._MODIFYDELETE:
          let span = log("Deleting " + this._webPageinstances[i].fs_filename);
          await this._currentfs.remove(this._webPageinstances[i].fs_filename);
          span.innerText = "done.";
          break;
        case this._MODIFYUNCOMPRESS:
          {
            let filename = this._webPageinstances[i].http_filename;
            let status = log("Uploading  " + filename + " to hub");
            status.innerText = "0%";
            let success = await this.uploadWidthProgress(filename, this._webPageinstances[i].contents, (curr, total) => {
              status.innerText = Math.round(100 * curr / total).toString() + "%";
            });
            status.innerText = "done";
            if (success != YAPI_SUCCESS)
              throw "Upload failed! (Error" + success.toString() + ")";
            status = log("Deleting " + this._webPageinstances[i].fs_filename);
            await this._currentfs.remove(this._webPageinstances[i].fs_filename);
            status.innerText = "done.";
          }
          break;
        case this._MODIFYCOMPRESS:
          {
            let filename = this._webPageinstances[i].http_filename + ".gz";
            let status = log("Compressing  " + filename);
            let GZ_data = Pako_Deflate.gzip(this._webPageinstances[i].contents, { level: 9 });
            status.innerText = "done";
            status = log("Uploading  " + filename + " to hub");
            status.innerText = "0%";
            let success = await this.uploadWidthProgress(filename, GZ_data, (curr, total) => {
              status.innerText = Math.round(100 * curr / total).toString() + "%";
            });
            status.innerText = "done";
            if (success != YAPI_SUCCESS)
              throw "Upload failed!! (Error" + success.toString() + ")";
            status = log("Deleting " + this._webPageinstances[i].http_filename);
            await this._currentfs.remove(this._webPageinstances[i].http_filename);
            status.innerText = "done.";
          }
          break;
        case this._MODIFYMAKEREADONLY:
          await this.patchPageInstance(log, this._webPageinstances[i], 'from "./yv4web-full', 'from "./yv4web-readonly', "", "", ",filehandler.saveFct);", ");");
          this._webPageinstances[i].readonly = true;
          break;
        case this._MODIFYMAKEREADWRITE:
          await this.patchPageInstance(log, this._webPageinstances[i], 'from "./yv4web-readonly', 'from "./yv4web-full', "", "", "filehandler.configChangeCallbackFct);", "filehandler.configChangeCallbackFct,filehandler.saveFct);");
          this._webPageinstances[i].readonly = false;
          break;
        case this._MODIFYUSEPLAIN:
          await this.patchPageInstance(log, this._webPageinstances[i], '"./yv4web-full.min.js"', '"./yv4web-full.js"', '"./yv4web-readonly.min.js"', '"./yv4web-readonly.js"', "", "");
          this._webPageinstances[i].useMinified = false;
          break;
        case this._MODIFYUPDATE:
          let RO_username = "";
          let RO_password = "";
          let HUBaddr = "";
          let HUBpath = "";
          if (this._userNameInput != null)
            RO_username = this._userNameInput.value;
          if (this._userPasswordInput != null)
            RO_password = this._userPasswordInput.value;
          if (this._ipAddrInput != null)
            HUBaddr = this._ipAddrInput.value;
          if (this._pathInput != null)
            HUBpath = this._pathInput.value;
          await this.setInstanceCredentials(log, this._webPageinstances[i], HUBaddr, HUBpath, RO_username, RO_password);
          break;
        case this._MODIFYUSEMINIFIED:
          await this.patchPageInstance(log, this._webPageinstances[i], '"./yv4web-full.js"', '"./yv4web-full.min.js"', '"./yv4web-readonly.js"', '"./yv4web-readonly.min.js"', "", "");
          this._webPageinstances[i].useMinified = true;
          break;
      }
    }
    await this.syncJsFileVersions(log, this._removeUnusedJs.checked);
    log("Done.");
    setTimeout(() => {
      this.gotoPanel(this.DONEPANEL);
    }, 2e3);
  }
  async uninstall(log) {
    for (let i = 0; i < this._jsCodeinstances.length; i++) {
      let filename = this._jsCodeinstances[i].filename;
      log("Deleteting " + filename);
      await this._currentfs.remove(filename);
    }
    let network = await YNetwork.FindNetwork(await this._currentHub.get_serialNumber() + ".network");
    let startPage = await network.get_defaultPage();
    let mustResetStartPage = false;
    for (let i = 0; i < this._webPageinstances.length; i++) {
      let filename = this._webPageinstances[i].fs_filename;
      if (startPage == this._webPageinstances[i].http_filename)
        mustResetStartPage = true;
      log("Deleteting " + filename);
      await this._currentfs.remove(filename);
    }
    if (mustResetStartPage) {
      log("Setting default page to index.html");
      await network.set_defaultPage("");
      await this._currentHub.saveToFlash();
    }
    log("Done.");
    setTimeout(() => {
      this.gotoPanel(this.DONEPANEL);
    }, 2e3);
  }
  get_js_filename(readonly, minified) {
    return "yv4web-" + (readonly ? "readonly" : "full") + (minified ? ".min" : "") + ".js";
  }
  get_js_blob(readonly, minified) {
    let data;
    if (readonly) {
      data = minified ? BinariesBlobs.ro_minjs : BinariesBlobs.ro_js;
    } else {
      data = minified ? BinariesBlobs.rw_minjs : BinariesBlobs.rw_js;
    }
    if (data == "")
      return null;
    return YAPI.imm_str2bin(atob(data));
  }
  async copyJsCode(log, readonly, minified) {
    let currentURL = window.location.href;
    let filename = currentURL.split("/").pop().split("#")[0].split("?")[0];
    let jsfile = this.get_js_filename(readonly, minified);
    let GZ_data = this.get_js_blob(readonly, minified);
    let status;
    if (GZ_data == null) {
      status = log("Downloading " + jsfile + " module from server..");
      let jsfileURL = currentURL.replace(filename, "../../dist/" + this.ESVersion + "/" + jsfile);
      let result;
      result = await YoctoHubFileHandler.makeRequest("GET", jsfileURL);
      if (result.data == null) {
        let err = "Installation Failed: cannot download the Yocto-Visualization file from the serveur serving this installer.\n\nError was : " + result.statusText + "\n\nURL was: " + jsfileURL;
        this.gotoPanel(this.CONNECTIONERROR, err);
        return;
      }
      status.innerText = "done.";
      status = log("Compressing JS Module..");
      GZ_data = Pako_Deflate.gzip(result.data, { level: 9 });
      status.innerText = "done.";
    }
    status = log("Copying JS Module to hub..");
    status.innerText = "0%";
    let success = await this.uploadWidthProgress(jsfile + ".gz", GZ_data, (curr, total) => {
      status.innerText = Math.round(100 * curr / total).toString() + "%";
    });
    if (success != YAPI_SUCCESS)
      throw "Upload failed. (Error" + success.toString() + ").";
    status.innerText = "done.";
  }
  async install(log) {
    let configFile = await this.loadLocalFile(this._configFileInput);
    if (configFile != null) {
      configFile = configFile.replace("<!-->", "<!-- ");
      let err = new YErrorMsg();
      if (!this.checkConfigfile(configFile, err)) {
        this.gotoPanel(this.CONNECTIONERROR, "Installation failed\n\n" + err.msg);
        return;
      }
      let index = configFile.toUpperCase().indexOf("</ROOT");
      if (index < 0)
        this.gotoPanel(this.CONNECTIONERROR, "Installation failed\n\nunable to find ROOT closing tag in provided config file");
      configFile = configFile.substring(0, index) + "</ROOT>\n";
      configFile = this.patchConfigFile(configFile);
    }
    let htmlFile = await this.loadLocalFile(this._webPageInput);
    if (htmlFile != null) {
      let err = new YErrorMsg();
      if (!this.checkHTMLfile(htmlFile, err)) {
        this.gotoPanel(this.CONNECTIONERROR, "Installation failed\n\n" + err.msg);
        return;
      }
    }
    let status;
    let GZ_data;
    let success;
    let readonly = this._useReadOnlyInput.checked;
    let minified = !this._useFullVersionInput.checked;
    let mustInstallJsCode = this._plannedaction == this.ACTIONINSTALL;
    if (this._plannedaction == this.ACTIONADDINSTANCE) {
      mustInstallJsCode = true;
      for (let i = 0; i < this._jsCodeinstances.length; i++) {
        if (this._jsCodeinstances[i].minified == minified && this._jsCodeinstances[i].readonly == readonly) {
          mustInstallJsCode = false;
        }
      }
    }
    if (mustInstallJsCode)
      await this.copyJsCode(log, readonly, minified);
    status = log("Creating HTML file..");
    let targetHTMLfile;
    if (htmlFile != null) {
      let index = htmlFile.toUpperCase().indexOf("</BODY>");
      let tag = htmlFile.substr(index, 7);
      targetHTMLfile = htmlFile.replace(tag, tag + this.getSeedCode(configFile, readonly, minified));
    } else {
      targetHTMLfile = this.defaultHTMLfile(configFile, readonly, minified);
    }
    status = log("Compressing  HTML file..");
    GZ_data = Pako_Deflate.gzip(YAPI.imm_str2bin(targetHTMLfile), { level: 9 });
    status.innerText = "done.";
    status = log("Saving HTML file on hub");
    let targetFile = this._fileprefixInput.value + this.TARGETEXTENSION;
    status.innerText = "0%";
    success = await this.uploadWidthProgress(targetFile + ".gz", GZ_data, (curr, total) => {
      status.innerText = Math.round(100 * curr / total).toString() + "%";
    });
    if (success != YAPI_SUCCESS)
      throw "Upload failed (Error" + success.toString() + ")";
    status.innerText = "done.";
    status = log("Configuring hub");
    let url = this._currentHubLink_protocol + "://" + this._applicationURL;
    let network = await YNetwork.FindNetwork(await this._currentHub.get_serialNumber() + ".network");
    if (this._makeDefaultInput.checked) {
      await network.set_defaultPage(targetFile);
    } else {
      if (await network.get_defaultPage() == targetFile)
        await network.set_defaultPage("");
      url += "/" + targetFile;
    }
    let warning = "";
    if (readonly && configFile == null)
      warning = "However, since you chose to install the read-only version without any configuration file, your install is probably useless.";
    await YAPI.UnregisterHub(await this._currentHub.get_url());
    status.innerText = "done.";
    this._warning = warning;
    this._finalURL = url;
    setTimeout(() => {
      this.gotoPanel(this.DONEPANEL);
    }, 2e3);
  }
  removeAllChilds(element) {
    while (element.firstChild) {
      element.removeChild(element.firstChild);
    }
  }
  async showConfirmUninstallPanel(visible, goingback) {
    if (!visible) {
      if (this._confirmUninstallPanel != null)
        this._confirmUninstallPanel.style.display = "none";
      return;
    }
    if (this._confirmUninstallPanel == null) {
      this._confirmUninstallPanel = this.createNewContentDiv();
      this._container.appendChild(this._confirmUninstallPanel);
    }
    if (!goingback) {
      this.removeAllChilds(this._confirmUninstallPanel);
      let p = document.createElement("P");
      p.innerText = "You are about to remove all files related to Yocto-Visualization (for web)  from hub " + this._currentHub_Addr + ", including instances that probably took you quite some time to configure. Are you sure you want to click on Next and start uninstallation? You will not be able to revert this operation.\n\n";
      this._confirmUninstallPanel.appendChild(p);
      this._confirmUninstall = document.createElement("input");
      this._confirmUninstall.type = "checkbox";
      let bt = this._nextButton;
      this._confirmUninstall.addEventListener("change", function() {
        bt.enabled = this.checked;
      });
      this._confirmUninstallPanel.appendChild(this._confirmUninstall);
      let txt = document.createElement("span");
      txt.innerText = "Yes, I know what I am doing.";
      this._confirmUninstallPanel.appendChild(txt);
    }
    this._confirmUninstallPanel.style.display = "";
    this._nextButton.visible = true;
    this._nextButton.enabled = this._confirmUninstall.checked;
    this._prevButton.visible = true;
    this._cancelButton.visible = this.DEFAULTCANCELABLE;
    let tabIndex = 1;
    this._confirmUninstall.tabIndex = tabIndex++;
    this._prevButton.tabIndex = tabIndex++;
    this._nextButton.tabIndex = tabIndex++;
    this._confirmUninstall.focus();
  }
  async showDonePanel(visible, goingback) {
    if (!visible) {
      if (this._donePanel != null)
        this._donePanel.style.display = "none";
      return;
    }
    if (this._donePanel == null) {
      this._donePanel = this.createNewContentDiv();
      let Table = document.createElement("TABLE");
      let Row = document.createElement("TR");
      let TD1 = document.createElement("TD");
      TD1.style.whiteSpace = "normal";
      TD1.innerHTML = ressources.OkIcon("64", true, false, false, false, "youpi!");
      Row.appendChild(TD1);
      this._doneMsgContainer = document.createElement("TD");
      Row.appendChild(this._doneMsgContainer);
      Table.appendChild(Row);
      this._donePanel.appendChild(Table);
      this._container.appendChild(this._donePanel);
    }
    this.removeAllChilds(this._doneMsgContainer);
    let p = document.createElement("P");
    p.style.whiteSpace = "normal";
    switch (this._plannedaction) {
      case this.ACTIONADDINSTANCE:
      case this.ACTIONINSTALL:
        p.innerText = this._plannedaction == this.ACTIONINSTALL ? "Installation sucessfully completed. Application can be accessed through the following URL:" : "New instance sucessfully completed, it can be accessed through the following URL:";
        this._doneMsgContainer.appendChild(p);
        let url = document.createElement("A");
        url.innerText = this._finalURL;
        url.style.cursor = "pointer";
        url.style.color = "#0000EE";
        url.style.textDecoration = "underline";
        url.addEventListener("click", () => {
          if (top)
            top.location.assign(this._finalURL);
        });
        this._doneMsgContainer.appendChild(url);
        if (this._warning != "") {
          p = document.createElement("P");
          p.innerText = this._warning;
          this._doneMsgContainer.appendChild(p);
        }
        break;
      case this.ACTIONUNINSTALL:
        p.innerText = "Files sucessfully removed.";
        this._doneMsgContainer.appendChild(p);
        break;
      case this.ACTIONUPDATE:
        p.innerText = "JS Files sucessfully updated.";
        this._doneMsgContainer.appendChild(p);
        break;
      case this.ACTIONMODINSTANCE:
        p.innerText = "Instances modifications done";
        this._doneMsgContainer.appendChild(p);
        break;
    }
    p = document.createElement("P");
    this._cancelButton.visible = this.DEFAULTCANCELABLE;
    p.innerText = this.DEFAULTCANCELABLE ? 'Click on the "Ok" button to close the wizard' : 'Click on the "Ok" button to restart the wizard';
    this._doneMsgContainer.appendChild(p);
    this.removeCurrentPanelFromHistory();
    this._nextButton.visible = false;
    this._prevButton.visible = false;
    this._cancelButton.visible = false;
    this._okButton.visible = true;
    this._donePanel.style.display = "";
    let tabIndex = 1;
    this._okButton.tabIndex = tabIndex++;
    this._okButton.focus();
  }
  showCurrentStep(back, msg) {
    this.showWelcomePanel(this._currentStep == this.WELCOMEPANEL, back);
    this.showEnterHubAddr(this._currentStep == this.ENTERHUBADDR, back);
    this.showConnectingPanel(this._currentStep == this.CONNECTINGPANEL, back);
    this.showConnectionError(this._currentStep == this.CONNECTIONERROR, back, msg);
    this.showPasswordPanel(this._currentStep == this.PASSWORDPANEL, back, msg);
    this.showHubDescription(this._currentStep == this.DESCRIPTIONPANEL, back);
    this.showCustomFilesPanel(this._currentStep == this.CUSTOMFILESPANEL, back);
    this.showOptionsPanel(this._currentStep == this.OPTIONSPANEL, back);
    this.showRunPanel(this._currentStep == this.RUNPANEL, back);
    this.showDonePanel(this._currentStep == this.DONEPANEL, back);
    this.showModifyInstallPanel(this._currentStep == this.MODIFYINSTALLPANEL, back);
    this.showConfirmUninstallPanel(this._currentStep == this.CONFIRMUNINSTALLPANEL, back);
    this.showModInstancesPanel(this._currentStep == this.MODINSTANCESPANEL, back);
  }
  gotoPrevious() {
    if (this._history.length > 1) {
      this._history.pop();
      this._currentStep = this._history[this._history.length - 1];
    }
    this.showCurrentStep(true);
  }
  gotoPanel(step, errmsg) {
    this._currentStep = step;
    this._prevButton.visible = step > 0;
    this._history.push(step);
    this.showCurrentStep(false, errmsg);
  }
  async resetAll() {
    this._currentStep = this.WELCOMEPANEL;
    this._history = [this.WELCOMEPANEL];
    this._alreadyInstalled = false;
    this._prevButton.visible = false;
    this._nextButton.visible = true;
    this._okButton.visible = false;
    this._cancelButton.visible = this.DEFAULTCANCELABLE;
    this._jsCodeinstances = [];
    this._webPageinstances = [];
    await YAPI.UnregisterHub(await this._currentHub.get_url());
    await YAPI.FreeAPI();
    this._currentHub = null;
    this.showCurrentStep(false);
  }
  gotoNext() {
    switch (this._currentStep) {
      case this.WELCOMEPANEL:
        this.gotoPanel(this.ENTERHUBADDR);
        break;
      case this.ENTERHUBADDR:
        this.gotoPanel(this.CONNECTINGPANEL);
        break;
      case this.PASSWORDPANEL:
        this.gotoPanel(this.CONNECTINGPANEL);
        break;
      case this.DESCRIPTIONPANEL:
        if (this._alreadyInstalled) {
          this.gotoPanel(this.MODIFYINSTALLPANEL);
        } else {
          this._plannedaction = this.ACTIONINSTALL;
          this.gotoPanel(this.CUSTOMFILESPANEL);
        }
        break;
      case this.CUSTOMFILESPANEL:
        this.gotoPanel(this.OPTIONSPANEL);
        break;
      case this.OPTIONSPANEL:
        this.gotoPanel(this.RUNPANEL);
        break;
      case this.MODIFYINSTALLPANEL:
        if (this._uninstallOpt.checked)
          this.gotoPanel(this.CONFIRMUNINSTALLPANEL);
        if (this._addInstanceOpt.checked) {
          this._plannedaction = this.ACTIONADDINSTANCE;
          this.gotoPanel(this.CUSTOMFILESPANEL);
        }
        if (this._updateOpt.checked) {
          this._plannedaction = this.ACTIONUPDATE;
          this.gotoPanel(this.RUNPANEL);
        }
        if (this._modInstanceOpt.checked) {
          this._plannedaction = this.ACTIONMODINSTANCE;
          this.gotoPanel(this.MODINSTANCESPANEL);
        }
        break;
      case this.MODINSTANCESPANEL:
        this.gotoPanel(this.RUNPANEL);
        break;
      case this.CONFIRMUNINSTALLPANEL:
        this._plannedaction = this.ACTIONUNINSTALL;
        this.gotoPanel(this.RUNPANEL);
        break;
    }
  }
};
YV4W_installer.HTTP = "http";
YV4W_installer.HTTPS = "https";
window.startYV4W_installer = (div, options) => {
  new YV4W_installer(div, options);
};
export {
  YV4W_installer
};
//# sourceMappingURL=yv4w-installer.js.map
