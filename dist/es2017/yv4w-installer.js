/* Yocto-Visualization-4web installer (version 1.10.56436) - www.yoctopuce.com */
// obj/full/Renderer/YDataRendererCommon.js
var Vector3 = class {
  constructor(a, b, c) {
    this.a = a;
    this.b = b;
    this.c = c;
  }
  static FromXYCoord(x, y) {
    return new Vector3(x, y, 1);
  }
  multiplyByM(m) {
    return new Vector3(m.a * this.a + m.b * this.b + m.c * this.c, m.d * this.a + m.e * this.b + m.f * this.c, m.g * this.a + m.h * this.b + m.i * this.c);
  }
  multiplyByN(n) {
    return new Vector3(this.a * n, this.b * n, this.c * n);
  }
  AddV(v) {
    return new Vector3(this.a + v.a, this.b + v.b, this.c + v.c);
  }
  SubstractV(v) {
    return new Vector3(this.a - v.a, this.b - v.b, this.c - v.c);
  }
  toPointF() {
    return new PointF(this.a, this.b);
  }
  toPoint() {
    return new Point(this.a, this.b);
  }
};
var Matrix3x3 = class {
  constructor(a, b, c, d, e, f, g, h, i, flags) {
    this.a = a;
    this.b = b;
    this.c = c;
    this.d = d;
    this.e = e;
    this.f = f;
    this.g = g;
    this.h = h;
    this.i = i;
    if (b == 0 && d == 0 && a == 1 && e == 1 && i == 1 && g == 0 && h == 0) {
      flags |= Matrix3x3.Flag_TRANSLATION;
      if (c == 0 && f == 0)
        flags |= Matrix3x3.Flag_IDENTITY;
    }
    this.isTranslation = (flags & Matrix3x3.Flag_TRANSLATION) != 0;
    this.isIdentity = (flags & Matrix3x3.Flag_IDENTITY) != 0;
  }
  clone() {
    let flag = 0;
    if (this.isTranslation)
      flag |= Matrix3x3.Flag_TRANSLATION;
    if (this.isIdentity)
      flag |= Matrix3x3.Flag_IDENTITY;
    return new Matrix3x3(this.a, this.b, this.c, this.d, this.e, this.f, this.g, this.h, this.i, flag);
  }
  get determinant() {
    let detA = this.e * this.i - this.h * this.f;
    let detB = this.d * this.i - this.g * this.f;
    let detC = this.d * this.h - this.g * this.e;
    return this.a * detA + -this.b * detB + this.c * detC;
  }
  get transpose() {
    if (this.isIdentity)
      return Matrix3x3.newIdentityMatrix();
    return new Matrix3x3(this.a, this.d, this.g, this.b, this.e, this.h, this.c, this.f, this.i, Matrix3x3.Flag_NONE);
  }
  multiplyByV(v) {
    if (this.isTranslation)
      return new Vector3(this.c + v.a, this.f + v.b, 1);
    return new Vector3(this.a * v.a + this.b * v.b + this.c * v.c, this.d * v.a + this.e * v.b + this.f * v.c, this.g * v.a + this.h * v.b + this.i * v.c);
  }
  static newMatrix(a, b, c, d, e, f, g, h, i) {
    return new Matrix3x3(a, b, c, d, e, f, g, h, i, Matrix3x3.Flag_NONE);
  }
  static newTranslateMatrix(offsetX, offsetY) {
    let flag = Matrix3x3.Flag_TRANSLATION;
    if (offsetX == 0 && offsetY == 0)
      flag |= Matrix3x3.Flag_IDENTITY;
    return new Matrix3x3(1, 0, offsetX, 0, 1, offsetY, 0, 0, 1, flag);
  }
  static newRotateMatrix(AngleDeg) {
    AngleDeg = Math.PI * AngleDeg / 180;
    return new Matrix3x3(Math.cos(AngleDeg), -Math.sin(AngleDeg), 0, Math.sin(AngleDeg), -Math.cos(AngleDeg), 0, 0, 0, 1, Matrix3x3.Flag_NONE);
  }
  static newScaleMatrix(Coef) {
    return new Matrix3x3(Coef, 0, 0, 0, Coef, 0, 0, 0, 1, Matrix3x3.Flag_NONE);
  }
  static newIdentityMatrix() {
    return new Matrix3x3(1, 0, 0, 0, 1, 0, 0, 0, 1, Matrix3x3.Flag_IDENTITY | Matrix3x3.Flag_TRANSLATION);
  }
  toCSS() {
    return "matrix(" + this.a.toString() + "," + this.d.toString() + "," + this.b.toString() + "," + this.e.toString() + "," + this.c.toString() + "," + this.f.toString() + ")";
  }
  toString() {
    return "| " + this.a.toFixed(2) + " " + this.b.toFixed(2) + " " + this.c.toFixed(2) + " |" + (this.isIdentity ? " I" : "") + "\n| " + this.d.toFixed(2) + " " + this.e.toFixed(2) + " " + this.f.toFixed(2) + " |" + (this.isTranslation ? " T" : "") + "\n| " + this.g.toFixed(2) + " " + this.g.toFixed(2) + " " + this.i.toFixed(2) + " |\n";
  }
  multiplyByM(m) {
    if (this.isIdentity)
      return m.clone();
    if (m.isIdentity)
      return this.clone();
    if (this.isTranslation && m.isTranslation)
      return Matrix3x3.newTranslateMatrix(this.c + m.c, this.f + m.f);
    return new Matrix3x3(this.a * m.a + this.b * m.d + this.c * m.g, this.a * m.b + this.b * m.e + this.c * m.h, this.a * m.c + this.b * m.f + this.c * m.i, this.d * m.a + this.e * m.d + this.f * m.g, this.d * m.b + this.e * m.e + this.f * m.h, this.d * m.c + this.e * m.f + this.f * m.i, this.g * m.a + this.h * m.d + this.i * m.g, this.g * m.b + this.h * m.e + this.i * m.h, this.g * m.c + this.h * m.f + this.i * m.i, Matrix3x3.Flag_NONE);
  }
  get inverse() {
    if (this.isIdentity)
      return Matrix3x3.newIdentityMatrix();
    if (this.isTranslation)
      return Matrix3x3.newTranslateMatrix(-this.c, -this.f);
    let det = this.determinant;
    if (det == 0)
      throw "matrix cannot be inverted";
    let detA = this.e * this.i - this.f * this.h;
    let detB = this.b * this.i - this.c * this.h;
    let detC = this.b * this.f - this.c * this.e;
    let detD = this.d * this.i - this.f * this.g;
    let detE = this.a * this.i - this.c * this.g;
    let detF = this.a * this.f - this.c * this.d;
    let detG = this.d * this.h - this.e * this.g;
    let detH = this.a * this.h - this.b * this.g;
    let detI = this.a * this.e - this.b * this.d;
    return new Matrix3x3(detA / det, -detB / det, detC / det, -detD / det, detE / det, -detF / det, detG / det, -detH / det, detI / det, Matrix3x3.Flag_NONE);
  }
  log() {
    console.log(this.toString());
  }
};
Matrix3x3.Flag_NONE = 0;
Matrix3x3.Flag_IDENTITY = 1;
Matrix3x3.Flag_TRANSLATION = 2;
var YEnum = class {
  static fromString(container, value) {
    let p = Object.getOwnPropertyNames(container);
    for (let i = 0; i < p.length; i++) {
      if (p[i] == value)
        return container[value];
    }
    throw "YEnum" + value + " is not a " + container + " value";
  }
  static siblings(container) {
    let res = [];
    let p = Object.getOwnPropertyNames(container);
    for (let i = 0; i < p.length; i++) {
      if (container[p[i]] instanceof YEnumItem) {
        res.push(container[p[i]]);
      }
    }
    return res;
  }
};
var YEnumItem = class {
  constructor(value, humanreadable, container) {
    this._value = value;
    this._container = container;
    this._humanreadable = humanreadable;
  }
  fromString(value) {
    return YEnum.fromString(this._container, value);
  }
  get toString() {
    return this._value.toString();
  }
  get description() {
    return this._humanreadable;
  }
  get sibblings() {
    return YEnum.siblings(this._container);
  }
};
var ViewPortSettings = class {
  constructor() {
    this.IRLx = 0;
    this.IRLy = 0;
    this.zoomx = 0;
    this.zoomy = 0;
    this.Lmargin = 0;
    this.Rmargin = 0;
    this.Tmargin = 0;
    this.Bmargin = 0;
    this.Width = 0;
    this.Height = 0;
    this.Capture = false;
    this.IRLCaptureStartX = 0;
    this.CaptureStartY = 0;
    this.OriginalXAxisMin = 0;
    this.OriginalXAxisMax = 0;
    this.OriginalIRLx = 0;
    this.OriginalLmargin = 0;
    this.OriginalZoomx = 0;
  }
};
var YFont = class {
  get userData() {
    return this._userData;
  }
  set userData(value) {
    this._userData = value;
  }
  get directParent() {
    return this._directParent;
  }
  constructor(parentRenderer, directParent, size, fontChangeCallback) {
    this._userData = null;
    this._fontChangeCallback = null;
    this._name = "Arial";
    this._italic = false;
    this._bold = false;
    this._color = YColor.Black;
    this._alternateColor = null;
    this._font = null;
    this._brush = new YSolidBrush(YColor.Black);
    this._parentRenderer = parentRenderer;
    this._directParent = directParent;
    this._fontChangeCallback = fontChangeCallback ? fontChangeCallback : null;
    this._size = new Proportional(size ? size : 10, Proportional.ResizeRule.FIXED, parentRenderer, this, this.ResetFont);
  }
  ResetFont(source) {
    this._font = null;
    if (source != null)
      this._parentRenderer.ProportionnalValueChanged(source);
  }
  get name() {
    return this._name;
  }
  set name(value) {
    this._name = value;
    this.ResetFont(null);
    this._parentRenderer.redraw();
  }
  get hasChanged() {
    return this._font == null;
  }
  get size() {
    return this._size.value;
  }
  set size(value) {
    if (value <= 0)
      throw new RangeError("Size must be a positive value");
    value = Math.round(100 * value) / 100;
    this._size.value = value;
    this.ResetFont(null);
    if (this._fontChangeCallback != null)
      this._fontChangeCallback(this);
    this._parentRenderer.redraw();
  }
  get italic() {
    return this._italic;
  }
  set italic(value) {
    if (this._italic != value) {
      this._italic = value;
      this.ResetFont(null);
      this._parentRenderer.redraw();
    }
  }
  get bold() {
    return this._bold;
  }
  set bold(value) {
    if (this._bold != value) {
      this._bold = value;
      this.ResetFont(null);
      this._parentRenderer.redraw();
    }
  }
  get color() {
    return this._color;
  }
  set color(value) {
    if (this._color != value) {
      this._color = value;
      this._brush = null;
      this._parentRenderer.redraw();
    }
  }
  get alternateColor() {
    return this._alternateColor;
  }
  set alternateColor(value) {
    if (this._alternateColor != value) {
      this._alternateColor = value;
      this._brush = null;
      this._parentRenderer.redraw();
    }
  }
  get fontObject() {
    return this._name ? this._name : "Arial";
  }
  get brush() {
    if (this._brush == null)
      this._brush = new YSolidBrush(this._alternateColor != null ? this._alternateColor : this._color);
    return this._brush;
  }
  get sizeInPoints() {
    return this._size.value * 0.75;
  }
  get sizeForCanvas() {
    return this._size.value * 1.15;
  }
  get htmlCode() {
    return (this._italic ? "italic " : "") + (this._bold ? "bold " : "") + this.sizeForCanvas.toString() + "px " + this._name;
  }
};
var YSizeF = class {
  constructor(font, st) {
    this._w = 0;
    this._h = 0;
    this._lines = [];
    this._linesCount = 0;
    this._lineHeight = 0;
    this._firstlineHeight = 0;
    if (font != null) {
      this._lineHeight = font.size * 1.25;
      this._firstlineHeight = this._lineHeight * 0.75;
      if (st.indexOf("\n") < 0) {
        this._lines = [st];
        this._linesCount = 1;
      } else {
        this._lines = st.split("\n");
        this._linesCount = this._lines.length;
      }
    }
  }
  get lines() {
    return this._lines;
  }
  get linesCount() {
    return this._linesCount;
  }
  get firstLineHeight() {
    return this._firstlineHeight;
  }
  get lineHeight() {
    return this._lineHeight;
  }
  get height() {
    return this._h;
  }
  get width() {
    return this._w;
  }
  set width(value) {
    this._w = value;
  }
  set height(value) {
    this._h = value;
  }
};
var YTextRenderingHint = class {
  constructor(value) {
    this._value = 0;
    this._value = value;
  }
};
YTextRenderingHint.SystemDefault = new YTextRenderingHint(0);
YTextRenderingHint.SingleBitPerPixelGridFit = new YTextRenderingHint(1);
YTextRenderingHint.SingleBitPerPixel = new YTextRenderingHint(2);
YTextRenderingHint.AntiAliasGridFit = new YTextRenderingHint(3);
YTextRenderingHint.AntiAlias = new YTextRenderingHint(4);
YTextRenderingHint.ClearTypeGridFit = new YTextRenderingHint(5);
var YSmoothingMode = class {
  constructor(value) {
    this._value = 0;
    this._value = value;
  }
};
YSmoothingMode.Invalid = new YSmoothingMode(-1);
YSmoothingMode.Default = new YSmoothingMode(0);
YSmoothingMode.HighSpeed = new YSmoothingMode(1);
YSmoothingMode.HighQuality = new YSmoothingMode(2);
YSmoothingMode.None = new YSmoothingMode(3);
YSmoothingMode.AntiAlias = new YSmoothingMode(4);
var YStringBuilder = class {
  constructor() {
    this._str = "";
  }
  AppendLine(s) {
    this._str += s + "\n";
  }
  Append(s) {
    this._str += s;
  }
  get contents() {
    return this._str;
  }
};
var YStringFormat = class {
  get Alignment() {
    return this._Alignment;
  }
  set Alignment(value) {
    this._Alignment = value;
  }
  get LineAlignment() {
    return this._LineAlignment;
  }
  set LineAlignment(value) {
    this._LineAlignment = value;
  }
  get FormatFlags() {
    return this._formatFlags;
  }
  set FormatFlags(value) {
    this._formatFlags = value;
  }
  get Trimming() {
    return this._Trimming;
  }
  set Trimming(value) {
    this._Trimming = value;
  }
  constructor(clip) {
    this._Alignment = 0;
    this._LineAlignment = 0;
    this._formatFlags = 0;
    this._Trimming = 0;
    this._clip = 16384;
    this._clip = clip;
  }
};
var YColor = class {
  get name() {
    return this._name;
  }
  set predefname(value) {
    this._name = value;
  }
  static get predefinedColors() {
    if (YColor._predefinedColors == null) {
      YColor._predefinedColors = {};
      let names = Object.getOwnPropertyNames(YColor);
      for (let i = 0; i < names.length; i++) {
        if (YColor[names[i]] instanceof YColor) {
          YColor._predefinedColors[names[i]] = YColor[names[i]];
          YColor._predefinedColors[names[i]].predefname = names[i];
        }
      }
    }
    return YColor._predefinedColors;
  }
  static FromString(value) {
    let valueUpper = value.toUpperCase();
    let propNames = Object.getOwnPropertyNames(YColor);
    for (let i = 0; i < propNames.length; i++) {
      if (propNames[i].toUpperCase() == valueUpper) {
        if (YColor[propNames[i]] instanceof YColor) {
          return YColor[propNames[i]];
        }
      }
    }
    if (value.length == 7 && value.substr(0, 1).toUpperCase() == "#") {
      let r = parseInt(value.substr(1, 2), 16);
      let g = parseInt(value.substr(3, 2), 16);
      let b = parseInt(value.substr(5, 2), 16);
      return new YColor(false, 255, r, g, b);
    }
    if (value.length == 12) {
      if (value.substr(0, 4).toUpperCase() == "RGB:") {
        let alpha = parseInt(value.substr(4, 2), 16);
        let r = parseInt(value.substr(6, 2), 16);
        let g = parseInt(value.substr(8, 2), 16);
        let b = parseInt(value.substr(10, 2), 16);
        return new YColor(false, alpha, r, g, b);
      } else if (value.substr(0, 4).toUpperCase() == "HSL:") {
        let alpha = parseInt(value.substr(4, 2), 16);
        let h = parseInt(value.substr(6, 2), 16);
        let s = parseInt(value.substr(8, 2), 16);
        let l = parseInt(value.substr(10, 2), 16);
        return new YColor(true, alpha, h, s, l);
      }
    }
    return null;
  }
  static hex(v) {
    let s = v.toString(16);
    if (s.length <= 1)
      return "0" + s;
    return s;
  }
  toString() {
    if (this.isHSLColor) {
      return "HSL:" + (YColor.hex(this.transparency) + YColor.hex(this.h) + YColor.hex(this.s) + YColor.hex(this.l)).toUpperCase();
    } else {
      let propNames = Object.getOwnPropertyNames(YColor);
      for (let i = 0; i < propNames.length; i++) {
        let o = Reflect.get(YColor, propNames[i]);
        let c = o;
        if (c.alpha == this.alpha && c.red == this.red && c.green == this.green && c.blue == this.blue)
          return propNames[i];
      }
    }
    return "RGB:" + (YColor.hex(this.transparency) + YColor.hex(this.r) + YColor.hex(this.g) + YColor.hex(this.b)).toUpperCase();
  }
  get svgCode() {
    return "rgb(" + this.r.toString() + ", " + this.g.toString() + ", " + this.b.toString() + ")";
  }
  get alphaCode() {
    return (this.transparency / 255).toFixed(3);
  }
  static hsl2rgbInt(temp1, temp2, temp3) {
    if (temp3 >= 170)
      return (temp1 + 127) / 255 >> 0;
    if (temp3 > 42) {
      if (temp3 <= 127)
        return (temp2 + 127) / 255 >> 0;
      temp3 = 170 - temp3;
    }
    return (temp1 * 255 + (temp2 - temp1) * (6 * temp3) + 32512) / 65025 >> 0;
  }
  hsl2rgb() {
    let temp1;
    let temp2;
    let temp3;
    this.rgbConvertionDone = true;
    if (this.s == 0) {
      this.r = this.l;
      this.g = this.l;
      this.b = this.l;
      return;
    }
    if (this.l <= 127) {
      temp2 = this.l * (255 + this.s);
    } else {
      temp2 = (this.l + this.s) * 255 - this.l * this.s;
    }
    temp1 = 510 * this.l - temp2;
    temp3 = this.h + 85;
    if (temp3 > 255)
      temp3 = temp3 - 255;
    this.r = YColor.hsl2rgbInt(temp1, temp2, temp3);
    temp3 = this.h;
    if (temp3 > 255)
      temp3 = temp3 - 255;
    this.g = YColor.hsl2rgbInt(temp1, temp2, temp3);
    if (this.h >= 85) {
      temp3 = this.h - 85;
    } else {
      temp3 = this.h + 170;
    }
    this.b = YColor.hsl2rgbInt(temp1, temp2, temp3);
    if (this.r > 255)
      this.r = 255;
    if (this.g > 255)
      this.g = 255;
    if (this.b > 255)
      this.b = 255;
  }
  computeHSL() {
    let R = this.r;
    let G = this.g;
    let B = this.b;
    let H;
    let S;
    let L;
    let max = R > G ? R : G;
    let min = R < G ? R : G;
    let correction = 0;
    let divisor = 0;
    this.hslConvertionDone = true;
    if (B > max)
      max = B;
    if (B < min)
      min = B;
    L = (max + min + 1) / 2 >> 0;
    if (max == min) {
      this.h = 0;
      this.s = 0;
      this.l = L;
      return;
    }
    correction = (max + min) / 2 >> 0;
    if (L <= 127) {
      S = (255 * (max - min) + correction) / (max + min) >> 0;
    } else {
      S = (255 * (max - min) + 255 - correction) / (510 - (max + min)) >> 0;
    }
    correction = 3 * (max - min);
    divisor = 2 * correction;
    if (R == max) {
      H = 0;
      R = G;
      G = B;
    } else if (G == max) {
      H = 85;
      G = R;
      R = B;
    } else {
      H = 170;
    }
    if (R >= G) {
      H += (255 * (R - G) + correction) / divisor >> 0;
    } else {
      H += 255 - (255 * (G - R) - correction) / divisor >> 0;
    }
    if (H > 255)
      H -= 255;
    if (S > 255)
      S = 255;
    if (L > 255)
      L = 255;
    this.h = H;
    this.s = S;
    this.l = L;
  }
  get hue() {
    if (!this.hslConvertionDone)
      this.computeHSL();
    return this.h;
  }
  get saturation() {
    if (!this.hslConvertionDone)
      this.computeHSL();
    return this.s;
  }
  get luminosity() {
    if (!this.hslConvertionDone)
      this.computeHSL();
    return this.l;
  }
  get red() {
    if (!this.rgbConvertionDone)
      this.hsl2rgb();
    return this.r;
  }
  get green() {
    if (!this.rgbConvertionDone)
      this.hsl2rgb();
    return this.g;
  }
  get blue() {
    if (!this.rgbConvertionDone)
      this.hsl2rgb();
    return this.b;
  }
  get alpha() {
    return this.transparency;
  }
  static FromArgb(a, r, g, b) {
    return new YColor(false, a, r, g, b);
  }
  static FromAhsl(a, h, s, l) {
    return new YColor(true, a, h, s, l);
  }
  get isHSL() {
    return this.isHSLColor;
  }
  get isRGB() {
    return !this.isHSLColor;
  }
  equal(c) {
    if (this.isHSLColor) {
      if (!c.isHSLColor)
        return false;
      if (c.hue != this.hue)
        return false;
      if (c.saturation != this.saturation)
        return false;
      if (c.luminosity != this.luminosity)
        return false;
      if (c.alpha != this.alpha)
        return false;
    } else {
      if (c.isHSLColor)
        return false;
      if (c.red != this.red)
        return false;
      if (c.green != this.green)
        return false;
      if (c.blue != this.blue)
        return false;
      if (c.alpha != this.alpha)
        return false;
    }
    return true;
  }
  clone() {
    if (this.isHSLColor)
      return new YColor(true, this.transparency, this.h, this.s, this.l, this.isPredefined);
    return new YColor(false, this.transparency, this.r, this.g, this.b, this.isPredefined);
  }
  get isPredefined() {
    return this._isPredefined;
  }
  constructor(isHsl, transparency, r_h, g_s, b_l, isPredefined) {
    this.hslConvertionDone = false;
    this.rgbConvertionDone = false;
    this.transparency = 0;
    this.r = 0;
    this.g = 0;
    this.b = 0;
    this.h = 0;
    this.s = 0;
    this.l = 0;
    this._name = "";
    this._htmlcode = this.computeHTMLCode();
    this.hslConvertionDone = isHsl;
    this.isHSLColor = isHsl;
    this.transparency = transparency;
    this._isPredefined = isPredefined === true;
    if (isHsl) {
      this.h = r_h;
      this.s = g_s;
      this.l = b_l;
      this.hsl2rgb();
    } else {
      this.r = r_h;
      this.g = g_s;
      this.b = b_l;
      this.rgbConvertionDone = true;
    }
    this._htmlcode = this.computeHTMLCode();
  }
  computeHTMLCode() {
    let a = this.transparency / 255;
    let r = this.r;
    let g = this.g;
    let b = this.b;
    return "rgba(" + r + "," + g + "," + b + "," + a.toFixed(3) + ")";
  }
  get htmlCode() {
    return this._htmlcode;
  }
};
YColor.AliceBlue = new YColor(false, 255, 240, 248, 255, true);
YColor.AntiqueWhite = new YColor(false, 255, 250, 235, 215, true);
YColor.Aqua = new YColor(false, 255, 0, 255, 255, true);
YColor.Aquamarine = new YColor(false, 255, 127, 255, 212, true);
YColor.Azure = new YColor(false, 255, 240, 255, 255, true);
YColor.Beige = new YColor(false, 255, 245, 245, 220, true);
YColor.Bisque = new YColor(false, 255, 255, 228, 196, true);
YColor.Black = new YColor(false, 255, 0, 0, 0, true);
YColor.BlanchedAlmond = new YColor(false, 255, 255, 235, 205, true);
YColor.Blue = new YColor(false, 255, 0, 0, 255, true);
YColor.BlueViolet = new YColor(false, 255, 138, 43, 226, true);
YColor.Brown = new YColor(false, 255, 165, 42, 42, true);
YColor.BurlyWood = new YColor(false, 255, 222, 184, 135, true);
YColor.CadetBlue = new YColor(false, 255, 95, 158, 160, true);
YColor.Chartreuse = new YColor(false, 255, 127, 255, 0, true);
YColor.Chocolate = new YColor(false, 255, 210, 105, 30, true);
YColor.Coral = new YColor(false, 255, 255, 127, 80, true);
YColor.CornflowerBlue = new YColor(false, 255, 100, 149, 237, true);
YColor.Cornsilk = new YColor(false, 255, 255, 248, 220, true);
YColor.Crimson = new YColor(false, 255, 220, 20, 60, true);
YColor.Cyan = new YColor(false, 255, 0, 255, 255, true);
YColor.DarkBlue = new YColor(false, 255, 0, 0, 139, true);
YColor.DarkCyan = new YColor(false, 255, 0, 139, 139, true);
YColor.DarkGoldenrod = new YColor(false, 255, 184, 134, 11, true);
YColor.DarkGray = new YColor(false, 255, 169, 169, 169, true);
YColor.DarkGreen = new YColor(false, 255, 0, 100, 0, true);
YColor.DarkKhaki = new YColor(false, 255, 189, 183, 107, true);
YColor.DarkMagenta = new YColor(false, 255, 139, 0, 139, true);
YColor.DarkOliveGreen = new YColor(false, 255, 85, 107, 47, true);
YColor.DarkOrange = new YColor(false, 255, 255, 140, 0, true);
YColor.DarkOrchid = new YColor(false, 255, 153, 50, 204, true);
YColor.DarkRed = new YColor(false, 255, 139, 0, 0, true);
YColor.DarkSalmon = new YColor(false, 255, 233, 150, 122, true);
YColor.DarkSeaGreen = new YColor(false, 255, 143, 188, 143, true);
YColor.DarkSlateBlue = new YColor(false, 255, 72, 61, 139, true);
YColor.DarkSlateGray = new YColor(false, 255, 47, 79, 79, true);
YColor.DarkTurquoise = new YColor(false, 255, 0, 206, 209, true);
YColor.DarkViolet = new YColor(false, 255, 148, 0, 211, true);
YColor.DeepPink = new YColor(false, 255, 255, 20, 147, true);
YColor.DeepSkyBlue = new YColor(false, 255, 0, 191, 255, true);
YColor.DimGray = new YColor(false, 255, 105, 105, 105, true);
YColor.DodgerBlue = new YColor(false, 255, 30, 144, 255, true);
YColor.Firebrick = new YColor(false, 255, 178, 34, 34, true);
YColor.FloralWhite = new YColor(false, 255, 255, 250, 240, true);
YColor.ForestGreen = new YColor(false, 255, 34, 139, 34, true);
YColor.Fuchsia = new YColor(false, 255, 255, 0, 255, true);
YColor.Gainsboro = new YColor(false, 255, 220, 220, 220, true);
YColor.GhostWhite = new YColor(false, 255, 248, 248, 255, true);
YColor.Gold = new YColor(false, 255, 255, 215, 0, true);
YColor.Goldenrod = new YColor(false, 255, 218, 165, 32, true);
YColor.Gray = new YColor(false, 255, 128, 128, 128, true);
YColor.Green = new YColor(false, 255, 0, 128, 0, true);
YColor.GreenYellow = new YColor(false, 255, 173, 255, 47, true);
YColor.Honeydew = new YColor(false, 255, 240, 255, 240, true);
YColor.HotPink = new YColor(false, 255, 255, 105, 180, true);
YColor.IndianRed = new YColor(false, 255, 205, 92, 92, true);
YColor.Indigo = new YColor(false, 255, 75, 0, 130, true);
YColor.Ivory = new YColor(false, 255, 255, 255, 240, true);
YColor.Khaki = new YColor(false, 255, 240, 230, 140, true);
YColor.Lavender = new YColor(false, 255, 230, 230, 250, true);
YColor.LavenderBlush = new YColor(false, 255, 255, 240, 245, true);
YColor.LawnGreen = new YColor(false, 255, 124, 252, 0, true);
YColor.LemonChiffon = new YColor(false, 255, 255, 250, 205, true);
YColor.LightBlue = new YColor(false, 255, 173, 216, 230, true);
YColor.LightCoral = new YColor(false, 255, 240, 128, 128, true);
YColor.LightCyan = new YColor(false, 255, 224, 255, 255, true);
YColor.LightGoldenrodYellow = new YColor(false, 255, 250, 250, 210, true);
YColor.LightGray = new YColor(false, 255, 211, 211, 211, true);
YColor.LightGreen = new YColor(false, 255, 144, 238, 144, true);
YColor.LightPink = new YColor(false, 255, 255, 182, 193, true);
YColor.LightSalmon = new YColor(false, 255, 255, 160, 122, true);
YColor.LightSeaGreen = new YColor(false, 255, 32, 178, 170, true);
YColor.LightSkyBlue = new YColor(false, 255, 135, 206, 250, true);
YColor.LightSlateGray = new YColor(false, 255, 119, 136, 153, true);
YColor.LightSteelBlue = new YColor(false, 255, 176, 196, 222, true);
YColor.LightYellow = new YColor(false, 255, 255, 255, 224, true);
YColor.Lime = new YColor(false, 255, 0, 255, 0, true);
YColor.LimeGreen = new YColor(false, 255, 50, 205, 50, true);
YColor.Linen = new YColor(false, 255, 250, 240, 230, true);
YColor.Magenta = new YColor(false, 255, 255, 0, 255, true);
YColor.Maroon = new YColor(false, 255, 128, 0, 0, true);
YColor.MediumAquamarine = new YColor(false, 255, 102, 205, 170, true);
YColor.MediumBlue = new YColor(false, 255, 0, 0, 205, true);
YColor.MediumOrchid = new YColor(false, 255, 186, 85, 211, true);
YColor.MediumPurple = new YColor(false, 255, 147, 112, 219, true);
YColor.MediumSeaGreen = new YColor(false, 255, 60, 179, 113, true);
YColor.MediumSlateBlue = new YColor(false, 255, 123, 104, 238, true);
YColor.MediumSpringGreen = new YColor(false, 255, 0, 250, 154, true);
YColor.MediumTurquoise = new YColor(false, 255, 72, 209, 204, true);
YColor.MediumVioletRed = new YColor(false, 255, 199, 21, 133, true);
YColor.MidnightBlue = new YColor(false, 255, 25, 25, 112, true);
YColor.MintCream = new YColor(false, 255, 245, 255, 250, true);
YColor.MistyRose = new YColor(false, 255, 255, 228, 225, true);
YColor.Moccasin = new YColor(false, 255, 255, 228, 181, true);
YColor.NavajoWhite = new YColor(false, 255, 255, 222, 173, true);
YColor.Navy = new YColor(false, 255, 0, 0, 128, true);
YColor.OldLace = new YColor(false, 255, 253, 245, 230, true);
YColor.Olive = new YColor(false, 255, 128, 128, 0, true);
YColor.OliveDrab = new YColor(false, 255, 107, 142, 35, true);
YColor.Orange = new YColor(false, 255, 255, 165, 0, true);
YColor.OrangeRed = new YColor(false, 255, 255, 69, 0, true);
YColor.Orchid = new YColor(false, 255, 218, 112, 214, true);
YColor.PaleGoldenrod = new YColor(false, 255, 238, 232, 170, true);
YColor.PaleGreen = new YColor(false, 255, 152, 251, 152, true);
YColor.PaleTurquoise = new YColor(false, 255, 175, 238, 238, true);
YColor.PaleVioletRed = new YColor(false, 255, 219, 112, 147, true);
YColor.PapayaWhip = new YColor(false, 255, 255, 239, 213, true);
YColor.PeachPuff = new YColor(false, 255, 255, 218, 185, true);
YColor.Peru = new YColor(false, 255, 205, 133, 63, true);
YColor.Pink = new YColor(false, 255, 255, 192, 203, true);
YColor.Plum = new YColor(false, 255, 221, 160, 221, true);
YColor.PowderBlue = new YColor(false, 255, 176, 224, 230, true);
YColor.Purple = new YColor(false, 255, 128, 0, 128, true);
YColor.Red = new YColor(false, 255, 255, 0, 0, true);
YColor.RosyBrown = new YColor(false, 255, 188, 143, 143, true);
YColor.RoyalBlue = new YColor(false, 255, 65, 105, 225, true);
YColor.SaddleBrown = new YColor(false, 255, 139, 69, 19, true);
YColor.Salmon = new YColor(false, 255, 250, 128, 114, true);
YColor.SandyBrown = new YColor(false, 255, 244, 164, 96, true);
YColor.SeaGreen = new YColor(false, 255, 46, 139, 87, true);
YColor.SeaShell = new YColor(false, 255, 255, 245, 238, true);
YColor.Sienna = new YColor(false, 255, 160, 82, 45, true);
YColor.Silver = new YColor(false, 255, 192, 192, 192, true);
YColor.SkyBlue = new YColor(false, 255, 135, 206, 235, true);
YColor.SlateBlue = new YColor(false, 255, 106, 90, 205, true);
YColor.SlateGray = new YColor(false, 255, 112, 128, 144, true);
YColor.Snow = new YColor(false, 255, 255, 250, 250, true);
YColor.SpringGreen = new YColor(false, 255, 0, 255, 127, true);
YColor.SteelBlue = new YColor(false, 255, 70, 130, 180, true);
YColor.Tan = new YColor(false, 255, 210, 180, 140, true);
YColor.Teal = new YColor(false, 255, 0, 128, 128, true);
YColor.Thistle = new YColor(false, 255, 216, 191, 216, true);
YColor.Tomato = new YColor(false, 255, 255, 99, 71, true);
YColor.Transparent = new YColor(false, 0, 255, 255, 255, true);
YColor.Turquoise = new YColor(false, 255, 64, 224, 208, true);
YColor.Violet = new YColor(false, 255, 238, 130, 238, true);
YColor.Wheat = new YColor(false, 255, 245, 222, 179, true);
YColor.White = new YColor(false, 255, 255, 255, 255, true);
YColor.WhiteSmoke = new YColor(false, 255, 245, 245, 245, true);
YColor.Yellow = new YColor(false, 255, 255, 255, 0, true);
YColor.YellowGreen = new YColor(false, 255, 154, 205, 50, true);
YColor._predefinedColors = null;
var YBrush = class {
  constructor(c, disableAntialias) {
    this._noAntiAlias = false;
    this._color = c;
    if (typeof disableAntialias != "undefined") {
      this._noAntiAlias = disableAntialias;
    }
  }
  get noAntiAlias() {
    return this._noAntiAlias;
  }
  get color() {
    return this._color;
  }
};
var YSolidBrush = class extends YBrush {
};
var YLinearGradientBrush = class extends YBrush {
  constructor(c1, c2) {
    super(c1);
    this._color1 = c1;
    this._color2 = c2;
  }
  get color1() {
    return this._color1;
  }
  get color2() {
    return this._color2;
  }
};
var YPen = class {
  constructor(color, thickness, disableAntialias) {
    this._thickness = 1;
    this._color = YColor.Black;
    this._noAntiAlias = false;
    this._startCap = 1;
    this._endCap = 1;
    this._linejoin = YPen.LineJoin.Miter;
    this._thickness = thickness;
    this._color = thickness > 0 ? color : YColor.Transparent;
    if (typeof disableAntialias != "undefined") {
      this._noAntiAlias = disableAntialias;
    }
  }
  get noAntiAlias() {
    return this._noAntiAlias;
  }
  get lineWidth() {
    return this._thickness;
  }
  get strokeStyle() {
    return this._color.htmlCode;
  }
  get color() {
    return this._color;
  }
  set startCap(value) {
    this._startCap = value;
  }
  set endCap(value) {
    this._endCap = value;
  }
  set linejoin(value) {
    this._linejoin = value;
  }
};
(function(YPen2) {
  let LineJoin;
  (function(LineJoin2) {
    LineJoin2[LineJoin2["Miter"] = 0] = "Miter";
    LineJoin2[LineJoin2["Bevel"] = 1] = "Bevel";
    LineJoin2[LineJoin2["Round"] = 2] = "Round";
    LineJoin2[LineJoin2["MiterClipped"] = 3] = "MiterClipped";
  })(LineJoin = YPen2.LineJoin || (YPen2.LineJoin = {}));
})(YPen || (YPen = {}));
var YRectangle = class {
  constructor(x, y, w, h) {
    this.x = x;
    this.y = y;
    this.w = w;
    this.h = h;
  }
};
var Point = class {
  constructor(valueX, valueY) {
    this.X = valueX >> 0;
    this.Y = valueY >> 0;
  }
};
var minMaxPoint = class {
  constructor(valueX1, valueYMIN, valueX2, valueYMAX) {
    this.X1 = valueX1 >> 0;
    this.YMIN = valueYMIN >> 0;
    this.X2 = valueX2 >> 0;
    this.YMAX = valueYMAX >> 0;
  }
};
var PointF = class {
  constructor(valueX, valueY) {
    this.X = valueX;
    this.Y = valueY;
  }
};
var GenericPanel = class {
  get userData() {
    return this._userData;
  }
  set userData(value) {
    this._userData = value;
  }
  get directParent() {
    return this._directParent;
  }
  constructor(parent, directParent) {
    this._userData = null;
    this._enabled = false;
    this._panelTextAlign = GenericPanel.TextAlign.LEFT;
    this._text = "";
    this._bgColor = new YColor(false, 255, 255, 255, 192);
    this._borderColor = YColor.Black;
    this._borderthickness = 1;
    this._padding = 10;
    this._verticalMargin = 10;
    this._horizontalMargin = 10;
    this._bgBrush = null;
    this._pen = null;
    this._font = null;
    this._directParent = directParent;
    this._parentRenderer = parent;
    this._font = new YFont(parent, this, 8, null);
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    if (this._enabled != value) {
      this._enabled = value;
      this._parentRenderer.clearCachedObjects();
      this._parentRenderer.redraw();
    }
  }
  get panelTextAlign() {
    return this._panelTextAlign;
  }
  set panelTextAlign(value) {
    this._panelTextAlign = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get text() {
    return this._text;
  }
  set text(value) {
    this._text = value;
    this._parentRenderer.clearCachedObjects();
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get bgColor() {
    return this._bgColor;
  }
  set bgColor(value) {
    this._bgColor = value;
    this._bgBrush = null;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get borderColor() {
    return this._borderColor;
  }
  set borderColor(value) {
    this._borderColor = value;
    this._pen = null;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get borderthickness() {
    return this._borderthickness;
  }
  set borderthickness(value) {
    if (value < 0)
      throw "Border thickness must be a positive value";
    this._borderthickness = value;
    this._parentRenderer.clearCachedObjects();
    this._pen = null;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get padding() {
    return this._padding;
  }
  set padding(value) {
    if (value < 0)
      throw new RangeError("Padding must be a positive value");
    this._padding = value;
    this._parentRenderer.clearCachedObjects();
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get verticalMargin() {
    return this._verticalMargin;
  }
  set verticalMargin(value) {
    this._verticalMargin = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get horizontalMargin() {
    return this._horizontalMargin;
  }
  set horizontalMargin(value) {
    this._horizontalMargin = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get bgBrush() {
    if (this._bgBrush == null)
      this._bgBrush = new YSolidBrush(this._bgColor);
    return this._bgBrush;
  }
  get pen() {
    if (this._pen == null) {
      this._pen = new YPen(this._borderColor, this._borderthickness, true);
    }
    return this._pen;
  }
  get font() {
    return this._font;
  }
};
(function(GenericPanel2) {
  class HorizontalAlignPosEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, HorizontalAlignPos);
    }
  }
  GenericPanel2.HorizontalAlignPosEnumItem = HorizontalAlignPosEnumItem;
  class HorizontalAlignPos extends YEnum {
  }
  HorizontalAlignPos.LEFT = new HorizontalAlignPosEnumItem("LEFT", "Left");
  HorizontalAlignPos.CENTER = new HorizontalAlignPosEnumItem("CENTER", "Center");
  HorizontalAlignPos.RIGHT = new HorizontalAlignPosEnumItem("RIGHT", "Right");
  GenericPanel2.HorizontalAlignPos = HorizontalAlignPos;
  class VerticalAlignPosEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, VerticalAlignPos);
    }
  }
  GenericPanel2.VerticalAlignPosEnumItem = VerticalAlignPosEnumItem;
  class VerticalAlignPos extends YEnum {
  }
  VerticalAlignPos.TOP = new VerticalAlignPosEnumItem("TOP", "Top");
  VerticalAlignPos.CENTER = new VerticalAlignPosEnumItem("CENTER", "Center");
  VerticalAlignPos.BOTTOM = new VerticalAlignPosEnumItem("BOTTOM", "Bottom");
  GenericPanel2.VerticalAlignPos = VerticalAlignPos;
  class TextAlignEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, TextAlign);
    }
  }
  GenericPanel2.TextAlignEnumItem = TextAlignEnumItem;
  class TextAlign extends YEnum {
  }
  TextAlign.LEFT = new TextAlignEnumItem("LEFT", "Left");
  TextAlign.CENTER = new TextAlignEnumItem("CENTER", "Center");
  TextAlign.RIGHT = new TextAlignEnumItem("RIGHT", "Right");
  GenericPanel2.TextAlign = TextAlign;
})(GenericPanel || (GenericPanel = {}));
var MessagePanel = class extends GenericPanel {
  constructor(parent, directParent) {
    super(parent, directParent);
    this._panelHrzAlign = GenericPanel.HorizontalAlignPos.CENTER;
    this._panelVrtAlign = GenericPanel.VerticalAlignPos.CENTER;
  }
  get panelHrzAlign() {
    return this._panelHrzAlign;
  }
  set panelHrzAlign(value) {
    this._panelHrzAlign = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get panelVrtAlign() {
    return this._panelVrtAlign;
  }
  set panelVrtAlign(value) {
    this._panelVrtAlign = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
};
var AnnotationPanel = class extends GenericPanel {
  constructor(parent, directParent) {
    super(parent, directParent);
    this._overlap = false;
    this._positionOffsetX = 50;
    this._positionOffsetY = 50;
    this._panelHrzAlign = GenericPanel.HorizontalAlignPos.CENTER;
    this._panelVrtAlign = GenericPanel.VerticalAlignPos.TOP;
  }
  get overlap() {
    return this._overlap;
  }
  set overlap(value) {
    if (!value && this._panelHrzAlign == GenericPanel.HorizontalAlignPos.CENTER && this._panelVrtAlign == GenericPanel.VerticalAlignPos.CENTER) {
      this._panelVrtAlign = GenericPanel.VerticalAlignPos.TOP;
    }
    this._overlap = value;
    this._parentRenderer.clearCachedObjects();
    this._parentRenderer.redraw();
  }
  get positionOffsetX() {
    return this._positionOffsetX;
  }
  set positionOffsetX(value) {
    this._positionOffsetX = value;
    this._parentRenderer.clearCachedObjects();
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get positionOffsetY() {
    return this._positionOffsetY;
  }
  set positionOffsetY(value) {
    this._positionOffsetY = value;
    this._parentRenderer.clearCachedObjects();
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get panelHrzAlign() {
    return this._panelHrzAlign;
  }
  set panelHrzAlign(value) {
    if (!this._overlap && value == GenericPanel.HorizontalAlignPos.CENTER && this._panelVrtAlign == GenericPanel.VerticalAlignPos.CENTER) {
      this._panelVrtAlign = GenericPanel.VerticalAlignPos.TOP;
    }
    this._panelHrzAlign = value;
    this._parentRenderer.clearCachedObjects();
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get panelVrtAlign() {
    return this._panelVrtAlign;
  }
  set panelVrtAlign(value) {
    if (!this._overlap && value == GenericPanel.VerticalAlignPos.CENTER && this._panelHrzAlign == GenericPanel.HorizontalAlignPos.CENTER) {
      this._panelHrzAlign = GenericPanel.HorizontalAlignPos.RIGHT;
    }
    this._panelVrtAlign = value;
    this._parentRenderer.clearCachedObjects();
    if (this._enabled)
      this._parentRenderer.redraw();
  }
};
var Zone = class {
  get directParent() {
    return this._directParent;
  }
  get userData() {
    return this._userData;
  }
  set userData(value) {
    this._userData = value;
  }
  resetCache() {
  }
  constructor(parentRenderer, directParent) {
    this._userData = null;
    this._zoneBrush = null;
    this._color = YColor.Red;
    this._visible = false;
    this._min = 0;
    this._max = 100;
    this._directParent = directParent;
    this._parentRenderer = parentRenderer;
  }
  get zoneBrush() {
    if (this._zoneBrush == null)
      this._zoneBrush = new YSolidBrush(this._color);
    return this._zoneBrush;
  }
  get color() {
    return this._color;
  }
  set color(value) {
    this._color = value;
    this._zoneBrush = null;
    if (this.visible)
      this._parentRenderer.redraw();
  }
  get visible() {
    return this._visible;
  }
  set visible(value) {
    this._visible = value;
    this._parentRenderer.redraw();
  }
  set_minMax(min, max) {
    if (min > max)
      throw new RangeError("Min cannot be greater than max ");
    this._min = min;
    this._max = max;
    this.resetCache();
    if (this.visible)
      this._parentRenderer.redraw();
  }
  get min() {
    return this._min;
  }
  set min(value) {
    if (value >= this._max && !YDataRenderer.minMaxCheckDisabled) {
      throw new RangeError("Min cannot be greater than max (" + this._max.toString() + ")");
    }
    this._min = value;
    this.resetCache();
    if (this.visible)
      this._parentRenderer.redraw();
  }
  get max() {
    return this._max;
  }
  set max(value) {
    if (value <= this._min && !YDataRenderer.minMaxCheckDisabled) {
      throw new RangeError("Max cannot be greater than min (" + this._min.toString() + ")");
    }
    this._max = value;
    this.resetCache();
    if (this.visible)
      this._parentRenderer.redraw();
  }
};
var Proportional = class {
  get userData() {
    return this._userData;
  }
  set userData(value) {
    this._userData = value;
  }
  get directParent() {
    return this._directParent;
  }
  get value() {
    return this._value;
  }
  set value(v) {
    this._value = v;
    this.set_refPoint();
    if (this._reset != null)
      this._reset(this);
  }
  get resizeRule() {
    return this._resizeRule;
  }
  set resizeRule(value) {
    this.set_refPoint();
    this._resizeRule = value;
  }
  set_refPoint() {
    this._refWidth = Math.max(1, this._parentRenderer.usableUiWidth());
    this._refHeight = Math.max(1, this._parentRenderer.usableUiHeight());
    this._refValue = this._value;
  }
  constructor(value, resizeRule, parentRenderer, directParent, resetCallBack) {
    this._reset = null;
    this._refWidth = 1;
    this._refHeight = 1;
    this._refValue = 1;
    this.valueStack = [];
    this._resizeRule = Proportional.ResizeRule.FIXED;
    this._userData = null;
    this._reset = resetCallBack;
    this._parentRenderer = parentRenderer;
    this._value = value;
    this._resizeRule = resizeRule;
    this._directParent = directParent;
    this.set_refPoint();
    this._parentRenderer.AddNewProportionalToSizeValue(this);
  }
  containerResizedPushNewCoef(coef) {
    this.valueStack.push(this._value);
    this._value = Math.round(100 * this._refValue * coef) / 100;
    if (this._reset != null)
      this._reset(this);
  }
  containerResizedPop() {
    if (this.valueStack.length <= 0)
      throw new RangeError("Can't pop, empty stack.");
    this._value = this.valueStack.pop();
    if (this._reset != null)
      this._reset(this);
  }
  static resizeCoef(rule, refWidth, refHeight, newWidth, newHeight) {
    switch (rule) {
      case Proportional.ResizeRule.RELATIVETOWIDTH:
        return newWidth / refWidth;
      case Proportional.ResizeRule.RELATIVETOHEIGHT:
        return newHeight / refHeight;
      case Proportional.ResizeRule.RELATIVETOBOTH:
        return Math.min(newHeight / refHeight, newWidth / refWidth);
    }
    return 1;
  }
  containerResized(newWidth, newHeight) {
    this._value = Math.round(100 * this._refValue * Proportional.resizeCoef(this._resizeRule, this._refWidth, this._refHeight, newWidth, newHeight)) / 100;
    if (this._reset != null)
      this._reset(this);
  }
  forceChangeCallback() {
    if (this._reset != null)
      this._reset(this);
  }
};
(function(Proportional2) {
  class ResizeRuleEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, ResizeRule);
    }
  }
  Proportional2.ResizeRuleEnumItem = ResizeRuleEnumItem;
  class ResizeRule extends YEnum {
  }
  ResizeRule.FIXED = new ResizeRuleEnumItem("FIXED", "Fixed");
  ResizeRule.RELATIVETOWIDTH = new ResizeRuleEnumItem("RELATIVETOWIDTH", "Relative to Width");
  ResizeRule.RELATIVETOHEIGHT = new ResizeRuleEnumItem("RELATIVETOHEIGHT", "Relative to height");
  ResizeRule.RELATIVETOBOTH = new ResizeRuleEnumItem("RELATIVETOBOTH", "Relative to Width and Height");
  Proportional2.ResizeRule = ResizeRule;
})(Proportional || (Proportional = {}));
var YDataRenderer = class {
  get annotationPanels() {
    return this._annotationPanels;
  }
  get userData() {
    return this._userData;
  }
  static get minMaxCheckDisabled() {
    return YDataRenderer._disableMinMaxCheck;
  }
  static set minMaxCheckDisabled(value) {
    YDataRenderer._disableMinMaxCheck = value;
  }
  resetlegendPens() {
  }
  get getCaptureParameters() {
    return this._getCaptureParameters;
  }
  set getCaptureParameters(value) {
    this._getCaptureParameters = value;
  }
  get messagePanels() {
    return this._messagePanels;
  }
  static globalMouseMove(e) {
    YDataRenderer.globalMouseX = e.pageX;
    YDataRenderer.globalMouseY = e.pageY;
  }
  clearTransformationMatrix() {
    this._Scr2ElmMatrix = null;
    this._Elm2ScrMatrix = null;
  }
  findElementAbsolutePosition(el) {
    let staticFound = false;
    let relativeFound = false;
    let dx = 0;
    let dy = 0;
    while (el != null) {
      let style = window.getComputedStyle(el);
      if (!relativeFound && style.position == "static" && !staticFound) {
        dx = el.offsetLeft + parseFloat(style.borderLeftWidth);
        dy = el.offsetTop + parseFloat(style.borderTopWidth);
        staticFound = true;
      }
      if (style.position == "relative" || style.position == "absolute") {
        dx += el.offsetLeft + parseFloat(style.borderLeftWidth);
        dy += el.offsetTop + parseFloat(style.borderTopWidth);
        relativeFound = true;
      }
      el = el.parentElement;
    }
    return new PointF(dx, dy);
  }
  get Elm2ScrMatrix() {
    if (this._Elm2ScrMatrix == null) {
      let el = this.UIContainer;
      let AsolutePositionsStack = [];
      while (el != null) {
        AsolutePositionsStack.push(this.findElementAbsolutePosition(el));
        el = el.parentElement;
      }
      el = this.UIContainer;
      let MatrixStack = [];
      let staticFound = false;
      let relativeFound = false;
      let index = 0;
      while (el != null) {
        let parent = el.parentElement;
        let style = window.getComputedStyle(el);
        let dx = AsolutePositionsStack[index].X;
        let dy = AsolutePositionsStack[index].Y;
        if (index < AsolutePositionsStack.length - 1) {
          dx -= AsolutePositionsStack[index + 1].X;
          dy -= AsolutePositionsStack[index + 1].Y;
        }
        let matrix = style["transform"];
        if (matrix != "none") {
          let matrixStr = matrix.match(/matrix.*\((.+)\)/)[1].split(", ");
          let matrixValues = [];
          for (let i = 0; i < 6; i++) {
            matrixValues.push(parseFloat(matrixStr[i]));
          }
          let OriginMatrixMatrixBefore = null;
          let TransformMatrix = Matrix3x3.newMatrix(matrixValues[0], matrixValues[2], matrixValues[4], matrixValues[1], matrixValues[3], matrixValues[5], 0, 0, 1);
          let OriginMatrixMatrixAfter = null;
          if (style.transformOrigin) {
            let parts = style.transformOrigin.split(" ");
            let Ox = Number.parseFloat(parts[0]);
            let Oy = Number.parseFloat(parts[1]);
            OriginMatrixMatrixBefore = Matrix3x3.newTranslateMatrix(-Ox, -Oy);
            OriginMatrixMatrixAfter = Matrix3x3.newTranslateMatrix(Ox, Oy);
          }
          if (OriginMatrixMatrixBefore != null)
            MatrixStack.push(OriginMatrixMatrixBefore);
          if (TransformMatrix != null)
            MatrixStack.push(TransformMatrix);
          if (OriginMatrixMatrixAfter != null)
            MatrixStack.push(OriginMatrixMatrixAfter);
        }
        if (dx != 0 || dy != 0)
          MatrixStack.push(Matrix3x3.newTranslateMatrix(dx, dy));
        el = parent;
        index++;
      }
      this._Elm2ScrMatrix = Matrix3x3.newIdentityMatrix();
      for (let i = MatrixStack.length - 1; i >= 0; i--) {
        this._Elm2ScrMatrix = this._Elm2ScrMatrix.multiplyByM(MatrixStack[i]);
      }
    }
    return this._Elm2ScrMatrix;
  }
  get Scr2ElmMatrix() {
    if (this._Scr2ElmMatrix == null) {
      this._Scr2ElmMatrix = this.Elm2ScrMatrix.inverse;
    }
    return this._Scr2ElmMatrix;
  }
  addAnnotationPanel() {
    let p = new AnnotationPanel(this, this);
    this._annotationPanels.push(p);
    this.redraw();
    return p;
  }
  AllowRedraw() {
    this._redrawAllowed--;
    if (this._redrawAllowed < 0)
      throw new RangeError("Too many AllowRedraw calls");
    if (this._redrawAllowed == 0)
      this.redraw();
  }
  AllowRedrawNoRefresh() {
    this._redrawAllowed--;
    if (this._redrawAllowed < 0)
      throw new RangeError("Too many AllowRedraw calls");
  }
  DisableRedraw() {
    this._redrawAllowed++;
  }
  AddNewProportionalToSizeValue(v) {
    if (this.ProportionalToSizeValues.indexOf(v) < 0)
      this.ProportionalToSizeValues.push(v);
  }
  canRedraw() {
    return this._redrawAllowed == 0;
  }
  setPatchAnnotationCallback(callback) {
    this._PatchAnnotationCallback = callback;
  }
  patchAnnotation(text) {
    text = text.replace("\\n", "\n");
    if (text.indexOf("$") < 0)
      return text;
    let now = new Date();
    text = text.replace("$DAY$", now.getDay().toString());
    text = text.replace("$MONTH$", now.getMonth().toString());
    text = text.replace("$YEAR$", now.getFullYear().toString());
    text = text.replace("$HOUR$", now.getHours().toString());
    text = text.replace("$MINUTE$", now.getMinutes().toString());
    text = text.replace("$SECOND$", now.getSeconds().toString());
    if (this._PatchAnnotationCallback != null)
      text = this._PatchAnnotationCallback(text);
    return text;
  }
  mouseLocalPosition() {
    let v = Vector3.FromXYCoord(YDataRenderer.globalMouseX, YDataRenderer.globalMouseY);
    let m = this.Scr2ElmMatrix;
    let p = m.multiplyByV(v).toPoint();
    if (p.X < 0 || p.Y < 0 || p.X > this.UIContainer.offsetWidth || p.Y > this.UIContainer.offsetHeight)
      return null;
    return p;
  }
  set proportionnalValueChangeCallback(value) {
    this._proportionnalValueChangeCallback = value;
  }
  ProportionnalValueChanged(source) {
    if (this._proportionnalValueChangeCallback != null)
      this._proportionnalValueChangeCallback(source);
  }
  getContainerInnerWidth() {
    return this.UIContainer.offsetWidth;
  }
  getContainerInnerHeight() {
    return this.UIContainer.offsetHeight;
  }
  Draw(timestamp) {
    if (!this.canRedraw())
      return 0;
    let w = this.getContainerInnerWidth();
    let h = this.getContainerInnerHeight();
    if (w <= 5 || h <= 5)
      return 0;
    this.DisableRedraw();
    let offscreenCanvas = document.createElement("canvas");
    offscreenCanvas.width = w;
    offscreenCanvas.height = h;
    let g = new YGraphics(offscreenCanvas, w, h, 90);
    let start = performance.now();
    try {
      this.Render(g, w, h);
    } catch (e) {
      debugger;
      this.log("Rendering error: " + e.message);
    }
    let elapsed = performance.now() - start;
    let drawArea = this.UIContainer.getContext("2d");
    drawArea.clearRect(0, 0, w, h);
    drawArea.drawImage(offscreenCanvas, 0, 0);
    this.rendererTimingTotal += elapsed;
    this.rendererTimingCount++;
    let avg = this.rendererTimingTotal / this.rendererTimingCount;
    g.Dispose();
    this.AllowRedrawNoRefresh();
    this.renderingPostProcessing();
    return 0;
  }
  renderingPostProcessing() {
  }
  get resizeRule() {
    return this._resizeRule;
  }
  set resizeRule(value) {
    if (value != this._resizeRule) {
      this.DisableRedraw();
      this._resizeRule = value;
      for (let i = 0; i < this.ProportionalToSizeValues.length; i++) {
        this.ProportionalToSizeValues[i].resizeRule = this._resizeRule;
      }
      this.AllowRedraw();
      this.redraw();
    }
  }
  redraw() {
    if (!(document.visibilityState === "visible"))
      return;
    if (this._redrawAllowed > 0)
      return;
    if (this.getContainerInnerWidth() < 2)
      return;
    if (this.getContainerInnerHeight() < 2)
      return;
    if (this.requestAnimationFrameID != null) {
      window.cancelAnimationFrame(this.requestAnimationFrameID);
    }
    this.requestAnimationFrameID = window.requestAnimationFrame((timestamp) => {
      try {
        this.Draw(timestamp);
      } catch (e) {
        console.log("caught");
        this.requestAnimationFrameID = null;
        throw e;
      }
      this.requestAnimationFrameID = null;
    });
  }
  usableUiWidth() {
    return this.getContainerInnerWidth();
  }
  usableUiHeight() {
    return this.getContainerInnerHeight();
  }
  resetProportionalSizeObjectsCachePush(newcoef) {
    this.clearCachedObjects();
    if (this._resizeRule != Proportional.ResizeRule.FIXED) {
      for (let i = 0; i < this.ProportionalToSizeValues.length; i++) {
        this.ProportionalToSizeValues[i].containerResizedPushNewCoef(newcoef);
      }
    }
  }
  resetProportionalSizeObjectsCachePop() {
    this.clearCachedObjects();
    if (this._resizeRule != Proportional.ResizeRule.FIXED) {
      for (let i = 0; i < this.ProportionalToSizeValues.length; i++) {
        this.ProportionalToSizeValues[i].containerResizedPop();
      }
    }
  }
  resetProportionalSizeObjectsCache(w, h) {
    this.clearCachedObjects();
    if (this._resizeRule != Proportional.ResizeRule.FIXED) {
      for (let i = 0; i < this.ProportionalToSizeValues.length; i++) {
        this.ProportionalToSizeValues[i].containerResized(w, h);
      }
    }
  }
  containerResized() {
    this.containerResize(null, null);
  }
  containerResize(sender, e) {
    this.clearTransformationMatrix();
    this.DisableRedraw();
    this.UIContainer.width = this.UIContainer.offsetWidth;
    this.UIContainer.height = this.UIContainer.offsetHeight;
    this.resetProportionalSizeObjectsCache(this.usableUiWidth(), this.usableUiHeight());
    this.AllowRedraw();
    this.redraw();
  }
  proportionnalsizeReset() {
    this.resetProportionalSizeObjectsCache(this.usableUiWidth(), this.usableUiHeight());
  }
  captureAndDownloadImage(captureType, defaultFilename, captureWidth, captureHeight, captureDPI) {
    let error = "";
    let w;
    let h;
    let ratio = this.getContainerInnerWidth() / this.getContainerInnerHeight();
    if (captureDPI == null)
      captureDPI = 90;
    if (defaultFilename == null || typeof defaultFilename == "undefined") {
      defaultFilename = "capture.";
      if (captureType == YDataRenderer.CaptureType.PNG) {
        defaultFilename = defaultFilename + "png";
      }
      if (captureType == YDataRenderer.CaptureType.SVG) {
        defaultFilename = defaultFilename + "svg";
      }
    }
    if (captureWidth == null || typeof captureWidth == "undefined") {
      w = this.getContainerInnerWidth();
      if (captureHeight == null || typeof captureHeight == "undefined") {
        h = this.getContainerInnerHeight();
      } else {
        h = captureHeight >> 0;
        w = h * ratio >> 0;
      }
    } else {
      w = captureWidth >> 0;
      if (captureHeight == null || typeof captureHeight == "undefined") {
        h = w * ratio >> 0;
      } else {
        h = captureHeight >> 0;
      }
    }
    if (w <= 5 || h <= 5)
      return;
    this.DisableRedraw();
    let DrawArea = document.createElement("canvas");
    DrawArea.width = w;
    DrawArea.height = h;
    let g;
    switch (captureType) {
      case YDataRenderer.CaptureType.PNG:
        g = new YGraphics(DrawArea, w, h, captureDPI);
        break;
      case YDataRenderer.CaptureType.SVG:
        g = new YGraphicsSVG(DrawArea, w, h, captureDPI);
        break;
      default:
        throw new RangeError("capture :unknown type");
    }
    let newCoef = Proportional.resizeCoef(Proportional.ResizeRule.RELATIVETOBOTH, this.refWidth, this.refHeight, w, h);
    this.log("start capture");
    this.resetProportionalSizeObjectsCachePush(newCoef);
    let renderok = false;
    this._snapshotPanel.enabled = false;
    try {
      let t = this.Render(g, w, h);
      renderok = true;
    } catch (e) {
      error = e.message;
      this.log("Render error: " + error);
    }
    this.log("capture completed");
    this.resetProportionalSizeObjectsCachePop();
    if (renderok) {
      let element = document.createElement("a");
      let data = g.get_downloadableData();
      element.setAttribute("href", data);
      element.setAttribute("download", defaultFilename);
      element.style.display = "none";
      document.body.appendChild(element);
      element.click();
      document.body.removeChild(element);
    }
    g.Dispose();
    this.AllowRedraw();
  }
  getFocus(sender, e) {
    this.log("got focus");
  }
  gainFocus() {
  }
  lostFocus(sender, e) {
  }
  get AllowPrintScreenCapture() {
    return this._AllowPrintScreenCapture;
  }
  set AllowPrintScreenCapture(value) {
    this._AllowPrintScreenCapture = value;
  }
  constructor(UIContainer, logFunction) {
    this._redrawAllowed = 1;
    this._refWidth = 1;
    this._refHeight = 1;
    this.rendererTimingTotal = 0;
    this.rendererTimingCount = 0;
    this._PatchAnnotationCallback = null;
    this._logFunction = null;
    this._annotationPanels = [];
    this._userData = null;
    this.documentVisibiltyChangeFct = null;
    this.containerResizedFct = null;
    this._getCaptureParameters = null;
    this.OnDblClick = null;
    this.OnRightClick = null;
    this._messagePanels = [];
    this._Scr2ElmMatrix = null;
    this._Elm2ScrMatrix = null;
    this.ProportionalToSizeValues = [];
    this._proportionnalValueChangeCallback = null;
    this._resizeRule = Proportional.ResizeRule.FIXED;
    this.requestAnimationFrameID = null;
    this._snapshotPanel = null;
    this._snapshotTimer = null;
    this._AllowPrintScreenCapture = false;
    if (!YDataRenderer.globalMouseMoveSet) {
      document.addEventListener("mousemove", (e) => {
        YDataRenderer.globalMouseMove(e);
      });
      YDataRenderer.globalMouseMoveSet = true;
    }
    this.UIContainer = UIContainer;
    this.UIContainer.width = this.getContainerInnerWidth();
    this.UIContainer.height = this.getContainerInnerHeight();
    this._logFunction = logFunction;
    this.parentForm = UIContainer.ownerDocument;
    this._annotationPanels = [];
    this._messagePanels = [];
    this.DisableRedraw();
    this._snapshotPanel = this.addMessagePanel();
    this._snapshotPanel.panelTextAlign = MessagePanel.TextAlign.CENTER;
    this._snapshotPanel.text = "Captured to clipboard";
    this._snapshotPanel.panelHrzAlign = MessagePanel.HorizontalAlignPos.CENTER;
    this._snapshotPanel.panelVrtAlign = MessagePanel.VerticalAlignPos.CENTER;
    this._snapshotPanel.bgColor = new YColor(false, 200, 204, 247, 161);
    this._snapshotPanel.font.size = 16;
    this.AllowRedrawNoRefresh();
    this.containerResizedFct = () => {
      this.containerResize(null, null);
    };
    document.addEventListener("resize", this.containerResizedFct);
    this.resetRefrenceSize();
    this.documentVisibiltyChangeFct = () => {
      if (document.visibilityState === "visible") {
        this.redraw();
      }
    };
    document.addEventListener("visibilitychange", this.documentVisibiltyChangeFct);
  }
  destroy() {
    document.removeEventListener("visibilitychange", this.documentVisibiltyChangeFct);
    document.removeEventListener("resize", this.containerResized);
    this.UIContainer.parentNode.removeChild(this.UIContainer);
    this.UIContainer = null;
    this.parentForm = null;
    this._annotationPanels = null;
    this._messagePanels = null;
    this._Scr2ElmMatrix = null;
    this._Elm2ScrMatrix = null;
  }
  resetRefrenceSize() {
    this._refWidth = this.getContainerInnerWidth();
    this._refHeight = this.getContainerInnerHeight();
  }
  get refWidth() {
    return this._refWidth;
  }
  get refHeight() {
    return this._refHeight;
  }
  RendererCanvas_Click(sender, e) {
  }
  RendererCanvas_DoubleClick(sender, e) {
  }
  addMessagePanel() {
    let p = new MessagePanel(this, this);
    this._messagePanels.push(p);
    return p;
  }
  DrawMessagePanels(g, viewPortWidth, viewPortHeight) {
    for (let i = 0; i < this._messagePanels.length; i++) {
      if (this._messagePanels[i].enabled) {
        let p = this._messagePanels[i];
        let AvailableWidth = viewPortWidth - 2 * p.padding - p.borderthickness;
        if (AvailableWidth < 100)
          AvailableWidth = 100;
        let ssize = null;
        let sizeok = false;
        while (!sizeok) {
          ssize = g.MeasureString(p.text, p.font, AvailableWidth);
          if ((ssize.width >= this.UIContainer.width || ssize.height >= this.UIContainer.height) && p.font.size > 5) {
            p.font.size = Math.round(p.font.size * 9) / 10;
          } else
            sizeok = true;
        }
        if (ssize == null)
          return;
        let panelWidth = ssize.width + 2 * p.padding + p.borderthickness;
        let panelHeight = ssize.height + 2 * p.padding + p.borderthickness;
        let x = 0;
        switch (p.panelHrzAlign) {
          case MessagePanel.HorizontalAlignPos.LEFT:
            x = p.horizontalMargin;
            break;
          case MessagePanel.HorizontalAlignPos.RIGHT:
            x = viewPortWidth - panelWidth - p.horizontalMargin;
            break;
          default:
            x = (viewPortWidth - panelWidth) / 2;
            break;
        }
        let y = 0;
        switch (p.panelVrtAlign) {
          case MessagePanel.VerticalAlignPos.TOP:
            y = p.verticalMargin;
            break;
          case MessagePanel.VerticalAlignPos.BOTTOM:
            y = viewPortHeight - panelHeight - p.verticalMargin;
            break;
          default:
            y = (viewPortHeight - panelHeight) / 2;
            break;
        }
        g.FillRectangleXYHW(p.bgBrush, x, y, panelWidth, panelHeight);
        if (p.borderthickness > 0)
          g.DrawRectangleXYHW(p.pen, x, y, panelWidth, panelHeight);
        let sf = new YStringFormat(16384);
        switch (p.panelTextAlign) {
          case MessagePanel.TextAlign.LEFT:
            sf.LineAlignment = 0;
            sf.Alignment = 0;
            break;
          case MessagePanel.TextAlign.RIGHT:
            sf.LineAlignment = 2;
            sf.Alignment = 2;
            break;
          default:
            sf.LineAlignment = 1;
            sf.Alignment = 1;
            break;
        }
        let r = new YRectangle(x + p.padding + p.borderthickness / 2 >> 0, y + p.padding + p.borderthickness / 2 >> 0, ssize.width + 1, ssize.height + 1);
        g.DrawStringRect(p.text, p.font, p.font.brush, r, sf);
      }
    }
  }
  drawAnnotationPanels(g, annotationPanels, viewPortWidth, viewPortHeight, overlap, mainViewPort) {
    let active = false;
    for (let i = 0; i < this.annotationPanels.length; i++) {
      if (this.annotationPanels[i].enabled)
        active = true;
    }
    if (!active)
      return;
    for (let i = 0; i < this.annotationPanels.length; i++) {
      if (annotationPanels[i].enabled && annotationPanels[i].overlap == overlap) {
        let p = annotationPanels[i];
        let AvailableWidth = viewPortWidth - 2 * p.padding - p.borderthickness;
        if (AvailableWidth < 100)
          AvailableWidth = 100;
        let textToDisplay = p.text.replace("\\n", "\n");
        if (textToDisplay.indexOf("$") >= 0) {
          textToDisplay = textToDisplay.replace("\\n", "\n");
          textToDisplay = this.patchAnnotation(textToDisplay);
        }
        let ssize = g.MeasureString(textToDisplay, p.font, AvailableWidth);
        let panelWidth = ssize.width + 2 * p.padding + p.borderthickness;
        let panelHeight = ssize.height + 2 * p.padding + p.borderthickness;
        let x = 0;
        switch (p.panelHrzAlign) {
          case MessagePanel.HorizontalAlignPos.LEFT:
            x = p.horizontalMargin;
            if (!annotationPanels[i].overlap && mainViewPort.Lmargin < panelWidth + 10) {
              mainViewPort.Lmargin = panelWidth + 10;
            }
            break;
          case MessagePanel.HorizontalAlignPos.RIGHT:
            x = viewPortWidth - panelWidth - p.horizontalMargin;
            if (!annotationPanels[i].overlap && mainViewPort.Rmargin < panelWidth + 20) {
              mainViewPort.Rmargin = panelWidth + 20;
            }
            break;
          default:
            x = (viewPortWidth - panelWidth) / 2;
            break;
        }
        let y = 0;
        switch (p.panelVrtAlign) {
          case MessagePanel.VerticalAlignPos.TOP:
            y = p.verticalMargin;
            if (!annotationPanels[i].overlap && mainViewPort.Tmargin < panelHeight + 20) {
              mainViewPort.Tmargin = panelHeight + 20;
            }
            break;
          case MessagePanel.VerticalAlignPos.BOTTOM:
            y = viewPortHeight - panelHeight - p.verticalMargin;
            if (!annotationPanels[i].overlap && mainViewPort.Bmargin < panelHeight + 20) {
              mainViewPort.Bmargin = panelHeight + 20;
            }
            break;
          default:
            y = (viewPortHeight - panelHeight) / 2;
            break;
        }
        if (annotationPanels[i].overlap) {
          x += annotationPanels[i].positionOffsetX / 100 * (viewPortWidth - panelWidth);
          y += annotationPanels[i].positionOffsetY / 100 * (viewPortHeight - panelHeight);
          if (x < 0)
            x = 0;
          if (y < 0)
            y = 0;
          if (x > viewPortWidth - panelWidth)
            x = viewPortWidth - panelWidth;
          if (y > viewPortHeight - panelHeight)
            y = viewPortHeight - panelHeight;
        }
        g.FillRectangleXYHW(p.bgBrush, x, y, panelWidth, panelHeight);
        if (p.borderthickness > 0)
          g.DrawRectangleXYHW(p.pen, x, y, panelWidth, panelHeight);
        let sf = new YStringFormat(16384);
        switch (p.panelTextAlign) {
          case MessagePanel.TextAlign.LEFT:
            sf.LineAlignment = 0;
            sf.Alignment = 0;
            break;
          case MessagePanel.TextAlign.RIGHT:
            sf.LineAlignment = 2;
            sf.Alignment = 2;
            break;
          default:
            sf.LineAlignment = 1;
            sf.Alignment = 1;
            break;
        }
        let r = new YRectangle(x + p.padding + p.borderthickness / 2, y + p.padding + p.borderthickness / 2, ssize.width + 1, ssize.height + 1);
        g.DrawStringRect(textToDisplay, p.font, p.font.brush, r, sf);
      }
    }
  }
  log(s) {
    if (this._logFunction == null)
      return;
    this._logFunction(s);
  }
};
YDataRenderer.RendererDebug = false;
YDataRenderer.FloatToStrformats = ["0", "0", "0", "0.0", "0.00", "0.000", "0.0000"];
YDataRenderer._disableMinMaxCheck = false;
YDataRenderer.globalMouseMoveSet = false;
YDataRenderer.globalMouseX = -1;
YDataRenderer.globalMouseY = -1;
(function(YDataRenderer2) {
  class CaptureTypeEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, CaptureType);
    }
  }
  YDataRenderer2.CaptureTypeEnumItem = CaptureTypeEnumItem;
  class CaptureType extends YEnum {
  }
  CaptureType.PNG = new CaptureTypeEnumItem("PNG", "Bitmap (PNG)");
  CaptureType.SVG = new CaptureTypeEnumItem("SVG", "Vector (SVG)");
  YDataRenderer2.CaptureType = CaptureType;
  class CaptureTargetEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, CaptureTarget);
    }
  }
  YDataRenderer2.CaptureTargetEnumItem = CaptureTargetEnumItem;
  class CaptureTarget extends YEnum {
  }
  CaptureTarget.ToClipBoard = new CaptureTargetEnumItem("ToClipBoard", "ClipBoard");
  CaptureTarget.ToFile = new CaptureTargetEnumItem("ToFile", "File");
  YDataRenderer2.CaptureTarget = CaptureTarget;
  class CaptureFormatsEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, CaptureFormats);
    }
  }
  YDataRenderer2.CaptureFormatsEnumItem = CaptureFormatsEnumItem;
  class CaptureFormats extends YEnum {
  }
  CaptureFormats.Keep = new CaptureFormatsEnumItem("Keep", "Keep original size");
  CaptureFormats.Fixed = new CaptureFormatsEnumItem("Fixed", "Fixed size");
  CaptureFormats.FixedWidth = new CaptureFormatsEnumItem("FixedWidth", "Fixed width, keep ration aspect");
  CaptureFormats.FixedHeight = new CaptureFormatsEnumItem("FixedHeight", "Fixed height, keep ration aspect");
  YDataRenderer2.CaptureFormats = CaptureFormats;
})(YDataRenderer || (YDataRenderer = {}));
var YGraphics = class {
  constructor(canvas, width, height, dpi) {
    this._c = null;
    this._g = null;
    this._width = 0;
    this._height = 0;
    this._dpi = 0;
    this._image = null;
    this._lastPen = null;
    this._lastBrush = null;
    this._lastFont = null;
    this._clipCounter = 0;
    this._textRenderingHint = null;
    this._smoothingMode = YSmoothingMode.Default;
    this._c = canvas;
    this._g = this._c.getContext("2d");
    this._g.textBaseline = "top";
    this._width = width;
    this._height = height;
    this._dpi = dpi;
  }
  get_downloadableData() {
    return this._c.toDataURL("image/png");
  }
  get graphics() {
    return this._g;
  }
  setPen(p) {
    if (p == this._lastPen)
      return;
    if (p != null) {
      this._g.lineWidth = p.lineWidth;
      let st = p.strokeStyle;
      this._g.strokeStyle = p.strokeStyle;
    } else {
      this._g.lineWidth = 0;
    }
    this._lastPen = p;
  }
  setBrush(b) {
    if (b == this._lastBrush)
      return;
    if (b instanceof YSolidBrush) {
      this._g.fillStyle = b.color.htmlCode;
    } else if (b instanceof YLinearGradientBrush) {
      let lingrad = this._g.createLinearGradient(0, 0, 0, this._height);
      lingrad.addColorStop(0, b.color1.htmlCode);
      lingrad.addColorStop(1, b.color2.htmlCode);
      this._g.fillStyle = lingrad;
    } else {
      throw new Error("invalid / insupported brush type");
    }
    this._lastBrush = b;
  }
  setFont(f) {
    if (f == this._lastFont && !f.hasChanged)
      return;
    this._g.font = f.htmlCode;
    this._lastFont = f;
  }
  DrawLineXY(p, x1, y1, x2, y2) {
    if (p.noAntiAlias) {
      let offset = p.lineWidth == p.lineWidth >> 0 && (p.lineWidth & 1) == 1 ? 0.5 : 0;
      x1 = Math.round(x1) + offset;
      y1 = Math.round(y1) + offset;
      x2 = Math.round(x2) + offset;
      y2 = Math.round(y2) + offset;
    }
    this.setPen(p);
    this._g.beginPath();
    this._g.moveTo(x1, y1);
    this._g.lineTo(x2, y2);
    this._g.stroke();
  }
  DrawLine(p, p1, p2) {
    this.setPen(p);
    this._g.beginPath();
    this._g.moveTo(p1.X, p1.Y);
    this._g.lineTo(p2.X, p2.Y);
    this._g.stroke();
  }
  SetClip(rect) {
    this._g.save();
    this._g.beginPath();
    this._g.rect(rect.x, rect.y, rect.w, rect.h);
    this._g.clip();
    this._clipCounter++;
  }
  ResetClip() {
    if (this._clipCounter <= 0)
      throw new Error("clipping stack error");
    this._g.restore();
    this._clipCounter--;
  }
  MeasureString(text, font, width) {
    this.setFont(font);
    let res = new YSizeF(font, text);
    let count = res.linesCount;
    if (count == 0)
      return res;
    res.height = res.firstLineHeight * 1.2 + (count - 1) * res.lineHeight;
    let max = 0;
    let dim;
    for (let i = 0; i < count; i++) {
      dim = this._g.measureText(res.lines[i]);
      max = Math.max(max, dim.width);
    }
    res.width = max;
    return res;
  }
  MeasureStringSF(text, font, width, stringFormat) {
    return this.MeasureString(text, font, width);
  }
  FillRectangle(brush, rect) {
    this.setBrush(brush);
    this._g.beginPath();
    this._g.fillRect(rect.x, rect.y, rect.w, rect.h);
    this._g.fill();
  }
  FillRectangleXYHW(brush, x, y, width, height) {
    this.setBrush(brush);
    this._g.beginPath();
    this._g.fillRect(x, y, width, height);
    this._g.fill();
  }
  DrawRectangle(p, rect) {
    this.setPen(p);
    this._g.beginPath();
    if (p.noAntiAlias) {
      let offset = p.lineWidth == p.lineWidth >> 0 && (p.lineWidth & 1) == 1 ? 0.5 : 0;
      this._g.rect(Math.round(rect.x) + offset, Math.round(rect.y) + offset, Math.round(rect.w), Math.round(rect.h));
    } else {
      this._g.rect(rect.x, rect.y, rect.w, rect.h);
    }
    this._g.stroke();
  }
  DrawRectangleXYHW(p, x, y, width, height) {
    if (p.noAntiAlias) {
      let offset = p.lineWidth == p.lineWidth >> 0 && (p.lineWidth & 1) == 1 ? 0.5 : 0;
      x = Math.round(x) + offset;
      y = Math.round(y) + offset;
      width = Math.round(width);
      height = Math.round(height);
    }
    this.setPen(p);
    this._g.beginPath();
    this._g.rect(x, y, width, height);
    this._g.stroke();
  }
  DrawStringXY(s, font, brush, x, y) {
    this.setPen(null);
    this.setBrush(brush);
    this.setFont(font);
    let totalsz = this.MeasureString(s, font, 0);
    let dy = totalsz.lineHeight;
    for (let i = 0; i < totalsz.linesCount; i++) {
      this._g.fillText(totalsz.lines[i], x, y);
      y += dy;
    }
  }
  DrawStringXYF(s, font, brush, x, y, format) {
    if (YGraphics._debugDrawString) {
      let pen = new YPen(YColor.Red, 1);
      this.DrawLineXY(pen, x - 5, y, x + 5, y);
      this.DrawLineXY(pen, x, y - 5, x, y + 5);
    }
    let sz = this.MeasureString(s, font, 1e4);
    if (format.Alignment == 1) {
      x -= sz.width >> 1;
    } else if (format.Alignment == 2)
      x -= sz.width;
    if (format.LineAlignment == 1) {
      y -= sz.height / 2 >> 0;
    } else if (format.LineAlignment == 2)
      y -= sz.height;
    this.DrawStringXY(s, font, brush, x, y);
  }
  DrawStringPF(s, font, brush, p, format) {
    this.DrawStringXYF(s, font, brush, p.X, p.Y, format);
  }
  DrawString(s, font, brush, p) {
    if (YGraphics._debugDrawString) {
      let pen = new YPen(YColor.Red, 1);
      this.DrawLineXY(pen, p.X - 5, p.Y, p.X + 5, p.Y);
      this.DrawLineXY(pen, p.X, p.Y - 5, p.X, p.Y + 5);
    }
    this.setPen(null);
    this.setBrush(brush);
    this.setFont(font);
    this._g.fillText(s, p.X, p.Y);
  }
  DrawStringRect(s, font, brush, layoutRectangle, format) {
    if (YGraphics._debugDrawString) {
      let pen = new YPen(YColor.Red, 1);
      this.DrawRectangle(pen, layoutRectangle);
    }
    this.setPen(null);
    this.setBrush(brush);
    this.setFont(font);
    let totalsz = this.MeasureString(s, font, 0);
    let dy = totalsz.lineHeight;
    let y = layoutRectangle.y;
    switch (format.LineAlignment) {
      case 0:
        break;
      case 1:
        y += (layoutRectangle.h - totalsz.height) / 2;
        break;
      case 2:
        y += layoutRectangle.h - totalsz.height;
        break;
    }
    let xOrigin = layoutRectangle.x;
    if (format.FormatFlags & 2) {
      this.Transform(layoutRectangle.x, layoutRectangle.y, Math.PI / 2);
      y -= layoutRectangle.y + layoutRectangle.w;
      xOrigin -= layoutRectangle.x;
    }
    for (let i = 0; i < totalsz.linesCount; i++) {
      let s2 = totalsz.lines[i];
      let sz = this.MeasureString(s2, font, 0);
      let x = xOrigin;
      switch (format.Alignment) {
        case 0:
          break;
        case 1:
          x += (layoutRectangle.w - sz.width) / 2;
          break;
        case 2:
          x += layoutRectangle.w - sz.width;
          break;
      }
      this._g.fillText(s2, x, y);
      y += dy;
    }
    if (format.FormatFlags & 2)
      this.ResetTransform();
  }
  Transform(dx, dy, angle) {
    let sin = Math.sin(angle);
    let cos = Math.cos(angle);
    this._g.save();
    this._g.transform(cos, sin, -sin, cos, dx, dy);
  }
  ResetTransform() {
    this._g.restore();
  }
  FillEllipse(brush, x, y, width, height) {
    this.setBrush(brush);
    this._g.beginPath();
    this._g.ellipse(x + width / 2, y + height / 2, width / 2, height / 2, 0, 0, 2 * Math.PI);
    this._g.fill();
  }
  DrawEllipse(pen, x, y, width, height) {
    this.setPen(pen);
    this._g.beginPath();
    this._g.ellipse(x + width / 2, y + height / 2, width / 2, height / 2, 0, 0, 2 * Math.PI);
    this._g.stroke();
  }
  FillPolygon(brush, points) {
    this.setBrush(brush);
    if (points.length <= 2)
      return;
    this._g.beginPath();
    if (brush.noAntiAlias) {
      this._g.moveTo(Math.round(points[0].X) + 0.5, Math.round(points[0].Y) + 0.5);
      for (let i = 1; i < points.length; i++) {
        this._g.lineTo(Math.round(points[i].X) + 0.5, Math.round(points[i].Y) + 0.5);
      }
    } else {
      this._g.moveTo(points[0].X, points[0].Y);
      for (let i = 1; i < points.length; i++) {
        this._g.lineTo(points[i].X, points[i].Y);
      }
    }
    this._g.closePath();
    this._g.fill();
  }
  DrawPolygon(pen, points) {
    this.setPen(pen);
    if (points.length <= 1)
      return;
    this._g.beginPath();
    if (pen.noAntiAlias) {
      let offset = pen.lineWidth == pen.lineWidth >> 0 && (pen.lineWidth & 1) == 1 ? 0.5 : 0;
      this._g.moveTo(Math.round(points[0].X) + offset, Math.round(points[0].Y) + offset);
      for (let i = 1; i < points.length; i++) {
        this._g.lineTo(Math.round(points[i].X) + offset, Math.round(points[i].Y) + offset);
      }
    } else {
      this._g.moveTo(points[0].X, points[0].Y);
      for (let i = 1; i < points.length; i++) {
        this._g.lineTo(points[i].X, points[i].Y);
      }
    }
    this._g.closePath();
    this._g.stroke();
  }
  DrawLines(pen, points) {
    this.setPen(pen);
    if (points.length <= 1)
      return;
    this._g.beginPath();
    this._g.lineCap = "round";
    this._g.lineJoin = "round";
    this._g.moveTo(points[0].X, points[0].Y);
    for (let i = 1; i < points.length; i++) {
      this._g.lineTo(points[i].X, points[i].Y);
    }
    this._g.stroke();
  }
  Dispose() {
    this._c = null;
    this._g = null;
    this._width = 0;
    this._height = 0;
    this._dpi = 0;
  }
  get TextRenderingHint() {
    return this._textRenderingHint;
  }
  set TextRenderingHint(value) {
    this._textRenderingHint = value;
  }
  get SmoothingMode() {
    return this._smoothingMode;
  }
  set SmoothingMode(value) {
    this._smoothingMode = value;
  }
  DrawImage(srcimage, destRect, srcRect, srcUnit) {
    this._g.drawImage(srcimage, srcRect.x, srcRect.y, srcRect.w, srcRect.h, destRect.x, destRect.y, destRect.w, destRect.h);
  }
  comment(s) {
  }
};
YGraphics._debugDrawString = false;
var YGraphicsSVG = class extends YGraphics {
  constructor(canvas, width, height, dpi) {
    super(canvas, width, height, dpi);
    this._clipcount = 0;
    this._clipSectionsToClose = 0;
    this._transformSectionsToClose = 0;
    this._gradientCount = 0;
    YGraphicsSVG.SVGID++;
    this._SVGdefs = new YStringBuilder();
    this._SVGcontents = new YStringBuilder();
    this._SVGdefs.AppendLine('<clipPath id="pageClip_' + YGraphicsSVG.SVGID.toString() + '"><rect x="0" y="0"  width="' + width.toString() + '" height="' + height.toString() + '"/></clipPath>');
  }
  static escapeXml(unsafe) {
    return unsafe.replace(/[^ !#$%(-;=?-z]/g, (c) => "&#" + c.charCodeAt(0) + ";");
  }
  get_downloadableData() {
    return "data:image/svg+xml;base64," + btoa(this.get_svgContents());
  }
  DrawLineXY(p, x1, y1, x2, y2) {
    this._SVGcontents.AppendLine('<line x1="' + x1.toString() + '"  y1 ="' + y1.toString() + '"  x2 ="' + x2.toString() + '"  y2 ="' + y2.toString() + '" style = "stroke:' + p.color.svgCode + ";stroke-opacity:" + p.color.alphaCode + "; stroke-width:" + p.lineWidth.toString() + '"/>');
  }
  DrawLine(p, p1, p2) {
    this.DrawLineXY(p, p1.X, p1.Y, p2.X, p2.Y);
  }
  SetClip(rect) {
    this.ResetClip();
    this._SVGdefs.AppendLine('<clipPath id="clip_' + YGraphicsSVG.SVGID.toString() + "_" + this._clipcount.toString() + '"><rect x="' + rect.x.toString() + '" y="' + rect.y.toString() + '"  width="' + rect.w.toString() + '" height="' + rect.h.toString() + '"/></clipPath>');
    this._SVGcontents.AppendLine('<g clip-path="url(#clip_' + YGraphicsSVG.SVGID.toString() + "_" + this._clipcount.toString() + ')">');
    this._clipcount++;
    this._clipSectionsToClose++;
  }
  ResetClip() {
    if (this._clipSectionsToClose > 0) {
      this._SVGcontents.AppendLine("</g>");
      this._clipSectionsToClose--;
    }
  }
  BrushToSVG(brush, revert) {
    let fillParam = "";
    if (brush instanceof YSolidBrush) {
      fillParam = 'fill = "' + brush.color.svgCode + '" fill-opacity="' + brush.color.alphaCode + '" ';
    } else if (brush instanceof YLinearGradientBrush) {
      this._SVGdefs.AppendLine('<linearGradient id="grad_' + YGraphicsSVG.SVGID.toString() + "_" + this._gradientCount + '" x1="0%" ' + (revert ? 'y1="100%" ' : 'y1="0%" ') + 'x2="0%" ' + (revert ? 'y2="0%" ' : 'y2="100%" ') + '>\r\n<stop offset="0%" style ="stop-color:' + brush.color1.svgCode + ";stop-opacity:" + brush.color1.alphaCode + '"/>\r\n<stop offset="100%" style ="stop-color:' + brush.color2.svgCode + ";stop-opacity:" + brush.color2.alphaCode + '"/>\r\n</linearGradient>');
      fillParam = 'fill="url(#grad_' + YGraphicsSVG.SVGID.toString() + "_" + this._gradientCount + ')" ';
      this._gradientCount++;
    } else {
      throw new ReferenceError("unsupported brush type.");
    }
    return fillParam;
  }
  FillRectangle(brush, rect) {
    this._SVGcontents.AppendLine('<rect x="' + rect.x.toString() + '"  y ="' + rect.y.toString() + '"  width ="' + rect.w.toString() + '"  height ="' + rect.h.toString() + '" ' + this.BrushToSVG(brush, true) + 'style="stroke-width:0"/>');
  }
  FillRectangleXYHW(brush, x, y, width, height) {
    this.FillRectangle(brush, new YRectangle(x, y, width, height));
  }
  DrawRectangle(p, rect) {
    this._SVGcontents.AppendLine('<rect x="' + rect.x.toString() + '"  y ="' + rect.y.toString() + '"  width ="' + rect.w.toString() + '"  height ="' + rect.h.toString() + '"  fill="none" style = "stroke:' + p.color.svgCode + ";stroke-opacity:" + p.color.alphaCode + "; stroke-width:" + p.lineWidth.toString() + '"/>');
  }
  DrawRectangleXYHW(p, x, y, width, height) {
    this.DrawRectangle(p, new YRectangle(x, y, width, height));
  }
  DrawEllipse(pen, x, y, width, height) {
    this._SVGcontents.AppendLine('<ellipse  cx="' + (x + width / 2).toString() + '"  cy ="' + (y + height / 2).toString() + '"  rx ="' + (width / 2).toString() + '"  ry ="' + (height / 2).toString() + '"  fill="none" style = "stroke:' + pen.color.svgCode + ";stroke-opacity:" + pen.color.alphaCode + "; stroke-width:" + pen.lineWidth.toString() + '"/>');
  }
  FillEllipse(brush, x, y, width, height) {
    this._SVGcontents.AppendLine('<ellipse  cx="' + (x + width / 2).toString() + '"  cy ="' + (y + height / 2).toString() + '"  rx ="' + (width / 2).toString() + '"  ry ="' + (height / 2).toString() + '" ' + this.BrushToSVG(brush, false) + 'style="stroke-width:0"/>');
  }
  DrawStringXY(s, font, brush, x, y) {
    let tokens = s.split("\n");
    for (let i = 0; i < tokens.length; i++) {
      s = tokens[i];
      this._SVGcontents.AppendLine('<text x="' + x.toString() + '" y="' + (y + font.sizeInPoints).toString() + '" text-anchor="start" font-family="' + font.name.toString() + '" font-size="' + font.sizeInPoints.toString() + 'pt" font-weight="' + (font.bold ? "bold" : "normal") + '" font-style="' + (font.italic ? "italic" : "normal") + '" ' + this.BrushToSVG(brush, false) + 'style="stroke-width:0">\r\n' + YGraphicsSVG.escapeXml(s) + "\r\n</text>");
      y += font.sizeInPoints * 1.75;
    }
  }
  DrawString(s, font, brush, p) {
    if (YGraphics._debugDrawString) {
      let pen = new YPen(YColor.Red, 1);
      this.DrawLineXY(pen, p.X - 5, p.Y, p.X + 5, p.Y);
      this.DrawLineXY(pen, p.X, p.Y - 5, p.X, p.Y + 5);
    }
    this.DrawStringXY(s, font, brush, p.X, p.Y);
  }
  DrawStringF(s, font, brush, point, format) {
    let totalsz = this.MeasureString(s, font, 0);
    let y = point.Y + font.size * 1.25;
    switch (format.LineAlignment) {
      case 0:
        break;
      case 1:
        y += -totalsz.height / 2;
        break;
      case 2:
        y += -totalsz.height;
        break;
    }
    let tokens = s.split("\n");
    for (let i = 0; i < tokens.length; i++) {
      let s2 = tokens[i];
      let sz = this.MeasureString(s2, font, 0);
      let x = point.X;
      switch (format.Alignment) {
        case 0:
          break;
        case 1:
          x += -sz.width / 2;
          break;
        case 2:
          x += -sz.width;
          break;
      }
      this._SVGcontents.AppendLine('<text x="' + x.toString() + '" y="' + y.toString() + '" text-anchor="start" font-family="' + font.name.toString() + '" font-size="' + font.sizeInPoints.toString() + 'pt" font-weight="' + (font.bold ? "bold" : "normal") + '" font-style="' + (font.italic ? "italic" : "normal") + '" ' + this.BrushToSVG(brush, false) + 'style="stroke-width:0">\r\n' + YGraphicsSVG.escapeXml(s2) + "\r\n</text>");
      y += font.sizeInPoints * 1.75;
    }
  }
  DrawStringRect(s, font, brush, layoutRectangle, format) {
    if (YGraphics._debugDrawString) {
      let pen = new YPen(YColor.Red, 1);
      this.DrawRectangle(pen, layoutRectangle);
    }
    let totalsz = this.MeasureString(s, font, 0);
    let y = layoutRectangle.y + font.sizeInPoints * 1.1;
    switch (format.LineAlignment) {
      case 0:
        break;
      case 1:
        y += (layoutRectangle.h - totalsz.height) / 2;
        break;
      case 2:
        y += layoutRectangle.h - totalsz.height;
        break;
    }
    let tokens = s.split("\n");
    for (let i = 0; i < tokens.length; i++) {
      let s2 = tokens[i];
      let sz = this.MeasureString(s2, font, 0);
      let x = layoutRectangle.x;
      switch (format.Alignment) {
        case 0:
          break;
        case 1:
          x += (layoutRectangle.w - sz.width) / 2;
          break;
        case 2:
          x += layoutRectangle.w - sz.width;
          break;
      }
      this._SVGcontents.AppendLine('<text x="' + x.toString() + '" y="' + y.toString() + '" text-anchor="start" font-family="' + font.name.toString() + '" font-size="' + (font.sizeInPoints * 1.1).toString() + 'pt" font-weight="' + (font.bold ? "bold" : "normal") + '" font-style="' + (font.italic ? "italic" : "normal") + '" ' + this.BrushToSVG(brush, false) + 'style="stroke-width:0">\r\n' + YGraphicsSVG.escapeXml(s2) + "\r\n</text>");
      y += font.sizeInPoints * 1.75;
    }
  }
  Transform(dx, dy, angle) {
    this._SVGcontents.AppendLine('<g transform="translate(' + dx.toString() + " " + dy.toString() + ") rotate(" + (180 * angle / Math.PI).toString() + ')">');
    this._transformSectionsToClose++;
  }
  ResetTransform() {
    if (this._transformSectionsToClose > 0) {
      this._SVGcontents.AppendLine("</g>");
      this._transformSectionsToClose--;
    }
  }
  DrawPolygon(pen, points) {
    if (points.length < 2)
      return;
    this._SVGcontents.Append('<path  d="M ' + points[0].X.toString() + " " + points[0].Y.toString());
    for (let i = 1; i < points.length; i += 1) {
      this._SVGcontents.Append(" L " + points[i].X.toString() + " " + points[i].Y.toString());
    }
    this._SVGcontents.AppendLine(' z" fill="none" style="stroke:' + pen.color.svgCode + ";stroke-opacity:" + pen.color.alphaCode + "; stroke-width:" + pen.lineWidth.toString() + '"/>');
  }
  DrawLines(pen, points) {
    if (points.length < 2)
      return;
    this._SVGcontents.Append('<path  d="M ' + points[0].X.toString() + " " + points[0].Y.toString());
    for (let i = 1; i < points.length; i++) {
      this._SVGcontents.Append(" L " + points[i].X.toString() + " " + points[i].Y.toString());
    }
    this._SVGcontents.AppendLine('" fill="none" style="stroke:' + pen.color.svgCode + ";stroke-opacity:" + pen.color.alphaCode + "; stroke-linecap:round; stroke-linejoin:round;stroke-width:" + pen.lineWidth.toString() + '"/>');
  }
  FillPolygon(brush, points) {
    if (points.length < 2)
      return;
    this._SVGcontents.Append('<path  d="M ' + points[0].X.toString() + " " + points[0].Y.toString());
    for (let i = 1; i < points.length; i++) {
      this._SVGcontents.Append(" L " + points[i].X.toString() + " " + points[i].Y.toString());
    }
    this._SVGcontents.AppendLine(' z" ' + this.BrushToSVG(brush, false) + 'style="stroke-width:0"/>\r\n');
  }
  DrawImage(image, destRect, srcRect, srcUnit) {
    throw new Error("DrawImage not supported, find an other way.");
  }
  save(filename) {
    throw new Error("Direct save to file not supported.");
  }
  comment(s) {
    this._SVGcontents.AppendLine("<!--" + s + "-->");
  }
  get_svgContents() {
    let physicalWidth = (2.54 * (this._width / this._dpi)).toFixed(3);
    let physicalheight = (2.54 * (this._height / this._dpi)).toFixed(3);
    while (this._clipSectionsToClose > 0) {
      this._SVGcontents.AppendLine("</g>");
      this._clipSectionsToClose--;
    }
    while (this._transformSectionsToClose > 0) {
      this._SVGcontents.AppendLine("</g>");
      this._transformSectionsToClose--;
    }
    return '<?xml version = "1.0" standalone = "no" ?>\r\n<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">\r\n<svg width = "' + physicalWidth + 'cm" height = "' + physicalheight + 'cm" viewBox = "0 0 ' + this._width.toString() + " " + this._height.toString() + '" xmlns = "http://www.w3.org/2000/svg" version = "1.1" >\r\n<defs>\r\n' + this._SVGdefs.contents + '</defs>\r\n<g clip-path="url(#pageClip_' + YGraphicsSVG.SVGID.toString() + ')">\r\n' + this._SVGcontents.contents + "</g>\r\n</svg>\n";
  }
};
YGraphicsSVG.SVGID = 0;

// obj/full/Renderer/YAngularGauge.js
var YAngularZone = class extends Zone {
  get path() {
    return this._path;
  }
  setPathSize(count) {
    this._path = new Array(count).fill(null);
  }
  setPathPoint(index, p) {
    this._path[index] = p;
  }
  resetPath() {
    this._path = null;
  }
  resetCache() {
    this.resetPath();
  }
  get width() {
    return this._width;
  }
  set width(value) {
    if (value <= 0)
      throw new RangeError("Width must be a positive value");
    this._width = value;
    this._path = null;
    this._parentRenderer.redraw();
  }
  get outerRadius() {
    return this._outerRadius;
  }
  set outerRadius(value) {
    this._outerRadius = Math.max(0, Math.min(100, value));
    this._path = null;
    this._parentRenderer.redraw();
  }
  constructor(parentRenderer, directParent) {
    super(parentRenderer, directParent);
    this._path = null;
    this._width = 10;
    this._outerRadius = 98;
  }
};
var YAngularGauge = class extends YDataRenderer {
  get min() {
    return this._min;
  }
  set min(value) {
    if (value >= this._max && !YDataRenderer.minMaxCheckDisabled) {
      throw new RangeError("Min cannot be greater than max (" + this._max.toString() + ")");
    }
    this._min = value;
    for (let i = 0; i < this._zones.length; i++) {
      this._zones[i].resetPath();
    }
    if (this._needleValue < this._min) {
      this._needleValue = this._min;
    }
    this.redraw();
  }
  get max() {
    return this._max;
  }
  set max(value) {
    if (value <= this._min && !YDataRenderer.minMaxCheckDisabled) {
      throw new RangeError("Max cannot be less than min (" + this._min.toString() + ")");
    }
    this._max = value;
    for (let i = 0; i < this._zones.length; i++) {
      this._zones[i].resetPath();
    }
    if (this._needleValue > this._max) {
      this._needleValue = this._max;
    }
    this.redraw();
  }
  get borderpen() {
    if (this._borderpen == null) {
      this._borderpen = new YPen(this._borderColor, this._borderThickness);
      this._borderpen.startCap = 1;
      this._borderpen.endCap = 1;
    }
    return this._borderpen;
  }
  get borderColor() {
    return this._borderColor;
  }
  set borderColor(value) {
    this._borderColor = value;
    this._borderpen = null;
    this.redraw();
  }
  get backgroundColor1() {
    return this._backgroundColor1;
  }
  set backgroundColor1(value) {
    this._backgroundColor1 = value;
    this._bgBrush = null;
    this.redraw();
  }
  get backgroundColor2() {
    return this._backgroundColor2;
  }
  set backgroundColor2(value) {
    this._backgroundColor2 = value;
    this._bgBrush = null;
    this.redraw();
  }
  get borderThickness() {
    return this._borderThickness;
  }
  set borderThickness(value) {
    if (value < 0)
      throw new RangeError("thickness must be a positive value");
    this._borderThickness = value;
    this._borderpen = null;
    this.redraw();
  }
  get valueFormater() {
    return this._valueFormater;
  }
  set valueFormater(value) {
    this._valueFormater = value;
    this.redraw();
  }
  get minmaxFormater() {
    return this._minmaxFormater;
  }
  set minmaxFormater(value) {
    this._minmaxFormater = value;
    this.redraw();
  }
  get thickness() {
    return this._thickness;
  }
  set thickness(value) {
    if (value < 0)
      throw new RangeError("Thickness must be a positive value");
    this._thickness = Math.max(Math.min(value, 80), 1);
    this.redraw();
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value;
    this.redraw();
  }
  get color1() {
    return this._color1;
  }
  set color1(value) {
    this._color1 = value;
    this.redraw();
  }
  get color2() {
    return this._color2;
  }
  set color2(value) {
    this._color2 = value;
    this.redraw();
  }
  get graduationColor() {
    return this._graduationColor;
  }
  set graduationColor(value) {
    this._graduationColor = value;
    this._graduationPen = null;
    this.redraw();
  }
  get graduationThickness() {
    return this._graduationThickness;
  }
  set graduationThickness(value) {
    if (value < 0)
      throw new RangeError("Thickness must be a positive value");
    this._graduationThickness = value;
    this._graduationPen = null;
    this.redraw();
  }
  get graduationSize() {
    return this._graduationSize;
  }
  set graduationSize(value) {
    if (value <= 0)
      throw new RangeError("Graduation size must be a positive value");
    this._graduationSize = value;
    this.redraw();
  }
  get graduation() {
    return this._graduation;
  }
  set graduation(value) {
    this._graduation = value;
    this.redraw();
  }
  get unitFactor() {
    return this._unitFactor;
  }
  set unitFactor(value) {
    if (value == 0)
      throw new RangeError("Factor cannot be zero.");
    this._unitFactor = value;
    this.redraw();
  }
  get unit() {
    return this._unit;
  }
  set unit(value) {
    this._unit = value;
    this.redraw();
  }
  get unitFont() {
    return this._unitFont;
  }
  get subgraduationColor() {
    return this._subgraduationColor;
  }
  set subgraduationColor(value) {
    this._subgraduationColor = value;
    this._subgraduationPen = null;
    this.redraw();
  }
  get subgraduationThickness() {
    return this._subgraduationThickness;
  }
  set subgraduationThickness(value) {
    if (value < 0)
      throw new RangeError("Thickness must be a positive value");
    this._subgraduationThickness = value;
    this._subgraduationPen = null;
    this.redraw();
  }
  get subgraduationSize() {
    return this._subgraduationSize;
  }
  set subgraduationSize(value) {
    if (value <= 0)
      throw new RangeError("Size must be a positive value");
    this._subgraduationSize = value;
    this.redraw();
  }
  get graduationOuterRadiusSize() {
    return this._graduationOuterRadiusSize;
  }
  set graduationOuterRadiusSize(value) {
    this._graduationOuterRadiusSize = Math.max(0, Math.min(100, value));
    this.redraw();
  }
  get subgraduationCount() {
    return this._subgraduationCount;
  }
  set subgraduationCount(value) {
    if (value < 0)
      throw new RangeError("Count must be a positive value");
    this._subgraduationCount = value;
    this.redraw();
  }
  get statusColor() {
    return this._statusColor;
  }
  set statusColor(value) {
    this._statusColor = value;
    this.redraw();
  }
  get statusFont() {
    return this._unitFont;
  }
  get statusLine() {
    return this._statusLine;
  }
  set statusLine(value) {
    this._statusLine = value;
    this.redraw();
  }
  get showNeedle() {
    return this._showNeedle;
  }
  set showNeedle(value) {
    this._showNeedle = value;
    this.redraw();
  }
  get needleColor() {
    return this._needleColor;
  }
  set needleColor(value) {
    this._needleColor = value;
    this._needleBrush = null;
    this.redraw();
  }
  get needleMaxSpeed() {
    return this._needleMaxSpeed;
  }
  set needleMaxSpeed(value) {
    if (value <= 0)
      throw new RangeError("Speed must be a positive value");
    this._needleMaxSpeed = value;
    this.redraw();
  }
  get needleLength1() {
    return this._needleLength1;
  }
  set needleLength1(value) {
    this._needleLength1 = value;
    this.redraw();
  }
  get needleLength2() {
    return this._needleLength2;
  }
  set needleLength2(value) {
    this._needleLength2 = value;
    this.redraw();
  }
  get needleWidth() {
    return this._needleWidth;
  }
  set needleWidth(value) {
    if (value <= 0)
      throw new RangeError("Width must be a positive value");
    this._needleWidth = value;
    this.redraw();
  }
  get needleContourColor() {
    return this._needleContourColor;
  }
  set needleContourColor(value) {
    this._needleContourColor = value;
    this._needleContourPen = null;
    this.redraw();
  }
  get needleContourThickness() {
    return this._needleContourThickness;
  }
  set needleContourThickness(value) {
    if (value < 0)
      throw new RangeError("Thickness must be a positive value");
    this._needleContourThickness = value;
    this._needleContourPen = null;
    this.redraw();
  }
  get graduationFont() {
    return this._graduationFont;
  }
  get showMinMax() {
    return this._showMinMax;
  }
  set showMinMax(value) {
    this._showMinMax = value;
    this.redraw();
  }
  constructor(UIContainer, logFunction) {
    super(UIContainer, logFunction);
    this._min = 0;
    this._max = 100;
    this.SegmentMaxLength = 8;
    this._borderpen = null;
    this._borderColor = YColor.Black;
    this._bgBrush = null;
    this._backgroundColor1 = YColor.FromArgb(255, 240, 240, 240);
    this._backgroundColor2 = YColor.FromArgb(255, 200, 200, 200);
    this._borderThickness = 5;
    this._valueFormater = null;
    this._minmaxFormater = null;
    this._thickness = 20;
    this._value = 0;
    this._needleValue = 0;
    this._color1 = YColor.Green;
    this._color2 = YColor.Red;
    this._graduationPen = null;
    this._graduationColor = YColor.Black;
    this._graduationThickness = 2;
    this._graduationSize = 10;
    this._graduation = 10;
    this._unitFactor = 1;
    this._unit = "";
    this._subgraduationPen = null;
    this._subgraduationColor = YColor.Black;
    this._subgraduationThickness = 1;
    this._subgraduationSize = 5;
    this._graduationOuterRadiusSize = 98;
    this._subgraduationCount = 5;
    this._statusColor = YColor.Gray;
    this._statusLine = "";
    this._showNeedle = true;
    this._needleBrush = null;
    this._needleColor = YColor.Red;
    this._needleMaxSpeed = 5;
    this._needleLength1 = 90;
    this._needleLength2 = 5;
    this._needleWidth = 5;
    this._needleContourPen = null;
    this._needleContourColor = YColor.DarkRed;
    this._needleContourThickness = 1;
    this._showMinMax = true;
    this._path = null;
    this._graduationFont = new YFont(this, this, Math.min(this.getContainerInnerWidth(), this.getContainerInnerHeight()) / 15, null);
    this._unitFont = new YFont(this, this, Math.min(this.getContainerInnerWidth(), this.getContainerInnerHeight()) / 20, null);
    this._statusFont = new YFont(this, this, Math.min(this.getContainerInnerWidth(), this.getContainerInnerHeight()) / 15, null);
    this.unitFont.color = YColor.DarkGray;
    this._statusFont.color = YColor.DarkGray;
    this.resizeRule = Proportional.ResizeRule.RELATIVETOBOTH;
    this._zones = [];
  }
  clearCachedObjects() {
    if (this._zones != null) {
      for (let i = 0; i < this._zones.length; i++) {
        this._zones[i].resetPath();
      }
    }
    this._path = null;
    this._bgBrush = null;
  }
  get zones() {
    return this._zones;
  }
  AddZone() {
    let z = new YAngularZone(this, this);
    this._zones.push(z);
    return z;
  }
  Render(g, w, h) {
    let mainViewPort = new ViewPortSettings();
    mainViewPort.Lmargin = 0;
    mainViewPort.Rmargin = 0;
    mainViewPort.Tmargin = 0;
    mainViewPort.Bmargin = 0;
    g.SmoothingMode = YSmoothingMode.HighQuality;
    g.TextRenderingHint = YTextRenderingHint.AntiAlias;
    let stringFormat4Sizing = new YStringFormat(16384);
    let stringFormat = new YStringFormat(16384);
    stringFormat.Alignment = 1;
    stringFormat.LineAlignment = 1;
    this.drawAnnotationPanels(g, this._annotationPanels, w, h, false, mainViewPort);
    g.TextRenderingHint = YTextRenderingHint.AntiAlias;
    let xcenter = mainViewPort.Lmargin + (w - mainViewPort.Lmargin - mainViewPort.Rmargin) / 2;
    let ycenter = mainViewPort.Tmargin + (h - mainViewPort.Tmargin - mainViewPort.Bmargin) / 2;
    let radius = Math.min((w - mainViewPort.Lmargin - mainViewPort.Rmargin) / 2, (h - mainViewPort.Tmargin - mainViewPort.Bmargin) / 2) - this.borderThickness;
    let circonference = 2 * radius * 3.14 >> 0;
    let AngleAperture = 4 * 2 * Math.PI / 5;
    if (this._path == null) {
      let outterlength = 2 * radius * Math.PI;
      let stepCount = outterlength / this.SegmentMaxLength >> 0;
      let stepsize = 2 * Math.PI / stepCount;
      this._path = new Array(stepCount).fill(null);
      let n = 0;
      for (let i = 0; i < stepCount; i++) {
        let a = 2 * i * Math.PI / stepCount;
        this._path[n++] = new PointF(xcenter + radius * Math.cos(a), ycenter - radius * Math.sin(a));
      }
    }
    if (this._bgBrush == null)
      this._bgBrush = new YLinearGradientBrush(this._backgroundColor1, this._backgroundColor2);
    if (this._borderpen == null) {
      this._borderpen = new YPen(this._borderColor, this._borderThickness);
      this._borderpen.linejoin = YPen.LineJoin.Round;
    }
    if (this._path.length > 3)
      g.FillPolygon(this._bgBrush, this._path);
    if (this._graduationPen == null)
      this._graduationPen = new YPen(this._graduationColor, this._graduationThickness);
    if (this._subgraduationPen == null)
      this._subgraduationPen = new YPen(this._subgraduationColor, this._subgraduationThickness);
    let unitDesc = (this._unitFactor != 1 ? "x" + this._unitFactor.toString() + " " : "") + this._unit;
    let size = g.MeasureStringSF(unitDesc.toString(), this._unitFont, 1e4, stringFormat4Sizing);
    let unitPos = new YRectangle(xcenter - size.width / 2 >> 0, ycenter + radius / 2 - size.height / 2 >> 0, size.width + 1 >> 0, size.height + 1 >> 0);
    g.DrawStringRect(unitDesc, this._unitFont, this._unitFont.brush, unitPos, stringFormat);
    if (this._statusLine != "") {
      size = g.MeasureStringSF(this._statusLine, this._statusFont, 1e4, stringFormat4Sizing);
      let statusPos = new YRectangle(xcenter - size.width / 2 >> 0, ycenter - radius / 3 - size.height / 2 >> 0, size.width + 1, size.height + 1);
      g.DrawStringRect(this._statusLine, this._statusFont, this._statusFont.brush, statusPos, stringFormat);
    }
    let firstGraduation;
    let gratuationCount;
    let Angle, C, S, R1, R2;
    let outerCoef = this._graduationOuterRadiusSize / 100;
    for (let i = 0; i < this._zones.length; i++) {
      if (this._zones[i].visible) {
        if (this._zones[i].path == null) {
          let zmin = Math.max(this._min, Math.min(this._max, this._zones[i].min));
          let zmax = Math.max(this._min, Math.min(this._max, this._zones[i].max));
          if (zmax > zmin) {
            let zOuterCoef = this._zones[i].outerRadius / 100;
            let Angle1 = (Math.PI - AngleAperture) / 2 + AngleAperture * (zmin - this._min) / (this._max - this._min);
            let Angle2 = (Math.PI - AngleAperture) / 2 + AngleAperture * (zmax - this._min) / (this._max - this._min);
            let outterlength = (Angle2 - Angle1) * radius;
            let stepCount = outterlength / this.SegmentMaxLength >> 0;
            if (stepCount < 2)
              stepCount = 2;
            this._zones[i].setPathSize(2 * stepCount + 2);
            for (let j = 0; j <= stepCount; j++) {
              let A = Angle1 + (Angle2 - Angle1) * j / stepCount;
              this._zones[i].setPathPoint(j, new PointF(xcenter - radius * zOuterCoef * Math.cos(A), ycenter - radius * zOuterCoef * Math.sin(A)));
            }
            let innerRadiusCoef = zOuterCoef - this._zones[i].width / 100;
            for (let j = stepCount; j >= 0; j--) {
              let A = Angle1 + (Angle2 - Angle1) * j / stepCount;
              this._zones[i].setPathPoint(2 * stepCount + 1 - j, new PointF(xcenter - radius * innerRadiusCoef * Math.cos(A), ycenter - radius * innerRadiusCoef * Math.sin(A)));
            }
          }
        }
        if (this._zones[i].path != null)
          g.FillPolygon(this._zones[i].zoneBrush, this._zones[i].path);
      }
    }
    firstGraduation = this._graduation * (this._min / this._graduation) >> 0;
    if (this._min < 0)
      firstGraduation -= this._graduation;
    while (firstGraduation < this._min) {
      firstGraduation += this._graduation;
    }
    gratuationCount = 1 + (this._max - this._min) / this._graduation >> 0;
    if (this._subgraduationCount > 0 && this._subgraduationCount * gratuationCount < circonference) {
      let subgraduation = this._graduation / this._subgraduationCount;
      firstGraduation = subgraduation * (this._min / subgraduation >> 0);
      if (this._min < 0)
        firstGraduation -= subgraduation;
      while (firstGraduation < this._min) {
        firstGraduation += subgraduation;
      }
      gratuationCount = 1 + (this._max - this._min) / subgraduation >> 0;
      for (let i = 0; i < gratuationCount; i++) {
        let value = firstGraduation + i * subgraduation;
        if (value <= this._max) {
          Angle = (Math.PI - AngleAperture) / 2 + AngleAperture * (value - this._min) / (this._max - this._min);
          C = Math.cos(Angle);
          S = Math.sin(Angle);
          R1 = outerCoef * (radius - this._borderThickness / 2);
          R2 = (100 - this._subgraduationSize) * (outerCoef * (radius - this._borderThickness / 2)) / 100;
          g.DrawLineXY(this._subgraduationPen, xcenter - R1 * C, ycenter - R1 * S, xcenter - R2 * C, ycenter - R2 * S);
        }
      }
    }
    if (gratuationCount < circonference) {
      for (let i = 0; i < gratuationCount; i++) {
        let gvalue = firstGraduation + i * this._graduation;
        if (gvalue <= this._max) {
          Angle = (Math.PI - AngleAperture) / 2 + AngleAperture * (gvalue - this._min) / (this._max - this._min);
          C = Math.cos(Angle);
          S = Math.sin(Angle);
          R1 = outerCoef * (radius - this._borderThickness / 2);
          R2 = (100 - this._graduationSize) * (outerCoef * (radius - this._borderThickness / 2)) / 100;
          g.DrawLineXY(this._graduationPen, xcenter - R1 * C, ycenter - R1 * S, xcenter - R2 * C, ycenter - R2 * S);
          size = g.MeasureStringSF(gvalue.toString().trim(), this._graduationFont, 1e3, stringFormat4Sizing);
          let HalfDiagonal = 0.4 * Math.sqrt(size.width * size.width + size.height * size.height);
          let position = new YRectangle(xcenter - (R2 - HalfDiagonal) * C - size.width / 2 >> 0, ycenter - (R2 - HalfDiagonal) * S - size.height / 2 >> 0, (size.width >> 0) + 1, size.height >> 0);
          g.DrawStringRect(gvalue.toString(), this._graduationFont, this._graduationFont.brush, position, stringFormat);
        }
      }
    }
    if (this._borderThickness > 0 && this._path.length > 3)
      g.DrawPolygon(this._borderpen, this._path);
    this.drawAnnotationPanels(g, this._annotationPanels, w, h, true, mainViewPort);
    if (this._showNeedle) {
      if (this._needleValue != this._value) {
        let step = this._unitFactor * this._needleMaxSpeed * (this._max - this._min) / 100;
        if (Math.abs(this._value - this._needleValue) < step) {
          this._needleValue = this._value;
        } else if (this._needleValue < this.value) {
          this._needleValue += step;
        } else {
          this._needleValue -= step;
        }
      }
      let needlevalue = this._needleValue / this._unitFactor;
      let allowedOverflow = (this._max - this.min) * 0.05;
      if (needlevalue < this._min - allowedOverflow)
        needlevalue = this._min - allowedOverflow;
      if (needlevalue > this._max + allowedOverflow)
        needlevalue = this._max + allowedOverflow;
      Angle = (Math.PI - AngleAperture) / 2 + AngleAperture * (needlevalue - this._min) / (this._max - this._min);
      C = Math.cos(Angle);
      S = Math.sin(Angle);
      R1 = radius * this._needleLength1 / 100;
      R2 = radius * this._needleLength2 / 100;
      let R3 = radius * this._needleWidth / 200;
      let needlepath = new Array(4).fill(null);
      needlepath[0] = new PointF(xcenter - R1 * C, ycenter - R1 * S);
      needlepath[1] = new PointF(xcenter + R3 * S, ycenter - R3 * C);
      needlepath[2] = new PointF(xcenter + R2 * C, ycenter + R2 * S);
      needlepath[3] = new PointF(xcenter - R3 * S, ycenter + R3 * C);
      if (this._needleBrush == null)
        this._needleBrush = new YSolidBrush(this._needleColor);
      g.FillPolygon(this._needleBrush, needlepath);
      if (this._needleContourThickness > 0) {
        if (this._needleContourPen == null) {
          this._needleContourPen = new YPen(this._needleContourColor, this._needleContourThickness);
          this._needleContourPen.startCap = 2;
          this._needleContourPen.endCap = 2;
          this._needleContourPen.linejoin = YPen.LineJoin.Round;
        }
        let needlepath2 = new Array(5).fill(null);
        needlepath2[0] = needlepath[0];
        needlepath2[1] = needlepath[1];
        needlepath2[2] = needlepath[2];
        needlepath2[3] = needlepath[3];
        needlepath2[4] = needlepath[0];
        g.DrawLines(this._needleContourPen, needlepath2);
      }
    }
    this.DrawMessagePanels(g, w, h);
    return 0;
  }
  renderingPostProcessing() {
    if (this._needleValue != this._value)
      this.redraw();
  }
};

// obj/full/Renderer/YDigitalDisplay.js
var YDigitalDisplay = class extends YDataRenderer {
  get backgroundColor1() {
    return this._backgroundColor1;
  }
  set backgroundColor1(value) {
    this._backgroundColor1 = value;
    this._bgBrush = null;
    this.redraw();
  }
  get backgroundColor2() {
    return this._backgroundColor2;
  }
  set backgroundColor2(value) {
    this._backgroundColor2 = value;
    this._bgBrush = null;
    this.redraw();
  }
  get alternateValue() {
    return this._alternateValue;
  }
  set alternateValue(value) {
    this._alternateValue = value;
    this.redraw();
  }
  get valueFormater() {
    return this._valueFormater;
  }
  set valueFormater(value) {
    this._valueFormater = value;
    this.redraw();
  }
  get hrzAlignmentOfset() {
    return this._hrzAlignmentOfset;
  }
  set hrzAlignmentOfset(value) {
    this._hrzAlignmentOfset = value;
    this.redraw();
  }
  get hrzAlignment() {
    return this._hrzAlignment;
  }
  set hrzAlignment(value) {
    this._hrzAlignment = value;
    this.redraw();
  }
  get outOfRangeMin() {
    return this._outOfRangeMin;
  }
  set outOfRangeMin(value) {
    if (!Number.isNaN(value) && !Number.isNaN(this._outOfRangeMax) && !YDataRenderer.minMaxCheckDisabled) {
      if (value >= this._outOfRangeMax)
        throw new RangeError("Min cannot be greater than max (" + this._outOfRangeMax.toString() + ")");
    }
    this._outOfRangeMin = value;
    this.redraw();
  }
  get outOfRangeMax() {
    return this._outOfRangeMax;
  }
  set outOfRangeMax(value) {
    if (!Number.isNaN(value) && !Number.isNaN(this._outOfRangeMin) && !YDataRenderer.minMaxCheckDisabled) {
      if (value <= this._outOfRangeMin)
        throw new RangeError("Min cannot be less than max (" + this._outOfRangeMin.toString() + ")");
    }
    this._outOfRangeMax = value;
    this.redraw();
  }
  get outOfRangeColor() {
    return this._outOfRangeColor;
  }
  set outOfRangeColor(value) {
    this._outOfRangeColor = value;
    this.redraw();
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value;
    this.redraw();
  }
  get font() {
    return this._font;
  }
  constructor(UIContainer, logFunction) {
    super(UIContainer, logFunction);
    this._bgBrush = null;
    this._backgroundColor1 = YColor.Black;
    this._backgroundColor2 = YColor.FromArgb(255, 48, 48, 48);
    this._alternateValue = null;
    this._valueFormater = null;
    this._hrzAlignmentOfset = 5;
    this._hrzAlignment = YDigitalDisplay.HrzAlignment.DECIMAL;
    this._outOfRangeMin = Number.NaN;
    this._outOfRangeMax = Number.NaN;
    this._outOfRangeColor = YColor.Red;
    this._value = 0;
    this._font = new YFont(this, this, Math.min(UIContainer.width / 5, UIContainer.height / 2), null);
    this._font.color = YColor.LightGreen;
    this.resizeRule = Proportional.ResizeRule.RELATIVETOBOTH;
  }
  clearCachedObjects() {
    if (this.font != null)
      this.font.ResetFont(null);
    this._bgBrush = null;
  }
  Render(g, w, h) {
    let mainViewPort = new ViewPortSettings();
    mainViewPort.Lmargin = 0;
    mainViewPort.Rmargin = 0;
    mainViewPort.Tmargin = 0;
    mainViewPort.Bmargin = 0;
    g.SmoothingMode = YSmoothingMode.HighQuality;
    g.TextRenderingHint = YTextRenderingHint.AntiAlias;
    let stringFormat = new YStringFormat(16384);
    stringFormat.Alignment = 1;
    stringFormat.LineAlignment = 1;
    if (this._bgBrush == null) {
      this._bgBrush = new YLinearGradientBrush(this._backgroundColor1, this._backgroundColor2);
    }
    g.FillRectangleXYHW(this._bgBrush, 0, 0, w, h);
    this.drawAnnotationPanels(g, this._annotationPanels, w, h, false, mainViewPort);
    if (mainViewPort.Tmargin >= 20)
      mainViewPort.Tmargin -= 10;
    if (mainViewPort.Bmargin >= 20)
      mainViewPort.Bmargin -= 10;
    g.TextRenderingHint = YTextRenderingHint.AntiAlias;
    let availWidth = w - (mainViewPort.Lmargin + mainViewPort.Rmargin);
    let availHeight = h - (mainViewPort.Tmargin + mainViewPort.Bmargin);
    if (availWidth > 10 && availHeight > 10) {
      let svalue;
      if (this._alternateValue == null) {
        svalue = this._valueFormater == null ? this.value.toFixed(3) : this._valueFormater(this, this.value);
        if (!Number.isNaN(this._outOfRangeMin) && this.value < this._outOfRangeMin) {
          this.font.alternateColor = this._outOfRangeColor;
        } else if (!Number.isNaN(this._outOfRangeMax) && this.value > this._outOfRangeMax) {
          this.font.alternateColor = this._outOfRangeColor;
        } else {
          this.font.alternateColor = null;
        }
      } else {
        this._font.alternateColor = null;
        svalue = this._alternateValue;
      }
      let size = g.MeasureStringSF(svalue, this.font, 1e4, stringFormat);
      let pos;
      let align = this._hrzAlignment;
      if (this._alternateValue != null && align == YDigitalDisplay.HrzAlignment.DECIMAL)
        align = YDigitalDisplay.HrzAlignment.RIGHT;
      if (align == YDigitalDisplay.HrzAlignment.DECIMAL && svalue.indexOf(".") < 0)
        align = YDigitalDisplay.HrzAlignment.RIGHT;
      switch (align) {
        case YDigitalDisplay.HrzAlignment.LEFT:
          pos = new YRectangle(mainViewPort.Lmargin + (availWidth * this.hrzAlignmentOfset / 100 >> 0), mainViewPort.Tmargin + (availHeight - size.height) / 2 >> 0, size.width + 1 >> 0, size.height + 1 >> 0);
          g.DrawStringRect(svalue, this.font, this.font.brush, pos, stringFormat);
          break;
        case YDigitalDisplay.HrzAlignment.CENTER:
          pos = new YRectangle(mainViewPort.Lmargin + (availWidth - size.width) / 2 >> 0, mainViewPort.Tmargin + (availHeight - size.height) / 2 >> 0, size.width + 1 >> 0, size.height + 1 >> 0);
          g.DrawStringRect(svalue, this.font, this.font.brush, pos, stringFormat);
          break;
        case YDigitalDisplay.HrzAlignment.DECIMAL:
          let left = "";
          let p = svalue.lastIndexOf(",");
          if (p < 0)
            p = svalue.lastIndexOf(".");
          if (p >= 0) {
            left = svalue.substring(0, p + 1);
          } else {
            p = 0;
            while (p < svalue.length && (svalue[p] >= "0" && svalue[p] <= "9" || svalue[p] == "-" || svalue[p] == "'" || svalue[p] == " ")) {
              p++;
            }
            left = svalue.substring(0, p);
          }
          let lsize = g.MeasureStringSF(left, this.font, 1e4, stringFormat);
          pos = new YRectangle(mainViewPort.Lmargin + (availWidth - lsize.width - availWidth * this.hrzAlignmentOfset / 100) >> 0, mainViewPort.Tmargin + (availHeight - size.height) / 2 >> 0, size.width + 1 >> 0, size.height + 1 >> 0);
          g.DrawStringRect(svalue, this.font, this.font.brush, pos, stringFormat);
          break;
        case YDigitalDisplay.HrzAlignment.RIGHT:
          pos = new YRectangle(mainViewPort.Lmargin + (availWidth - size.width - availWidth * this.hrzAlignmentOfset / 100) >> 0, mainViewPort.Tmargin + (availHeight - size.height) / 2 >> 0, size.width + 1 >> 0, size.height + 1 >> 0);
          g.DrawStringRect(svalue, this.font, this.font.brush, pos, stringFormat);
          break;
      }
    }
    this.drawAnnotationPanels(g, this._annotationPanels, w, h, true, mainViewPort);
    this.DrawMessagePanels(g, w, h);
    return 0;
  }
};
(function(YDigitalDisplay2) {
  class HrzAlignmentEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, HrzAlignment);
    }
  }
  YDigitalDisplay2.HrzAlignmentEnumItem = HrzAlignmentEnumItem;
  class HrzAlignment extends YEnum {
  }
  HrzAlignment.LEFT = new HrzAlignmentEnumItem("LEFT", "Left");
  HrzAlignment.CENTER = new HrzAlignmentEnumItem("CENTER", "Center");
  HrzAlignment.DECIMAL = new HrzAlignmentEnumItem("DECIMAL", "Decimal");
  HrzAlignment.RIGHT = new HrzAlignmentEnumItem("RIGHT", "Right");
  YDigitalDisplay2.HrzAlignment = HrzAlignment;
})(YDigitalDisplay || (YDigitalDisplay = {}));

// obj/full/Renderer/YGraph.js
var SUMMARY_GRANULARITY = 100;
var pointXY = class {
  constructor(X, Y) {
    this.x = X === void 0 ? 0 : X;
    this.y = Y === void 0 ? 0 : Y;
  }
  clone() {
    return new pointXY(this.x, this.y);
  }
};
var pointsSummary = class {
  constructor(X1, X2, YMIN, YMAX) {
    this.x1 = X1;
    this.x2 = X2;
    this.ymin = YMIN;
    this.ymax = YMAX;
  }
  clone() {
    return new pointsSummary(this.x1, this.x2, this.ymin, this.ymin);
  }
};
var TimeConverterParseResult = class {
  constructor() {
    this.success = false;
    this.result = 0;
  }
};
var TimeResolution = class {
  constructor() {
    this.step = 0;
    this.format = 0;
  }
};
var YDate = class extends Date {
  ToString(format) {
    let res = "";
    let ampm = "";
    if (format & YDate.D)
      res = res + this.getDate() + " ";
    if (format & YDate.M)
      res = res + YDate.months[this.getMonth()] + " ";
    if (format & YDate.YY) {
      let y = this.getFullYear().toString();
      res = res + y.substr(y.length - 2) + " ";
    } else if (format & YDate.YYYY) {
      let y = this.getFullYear().toString();
      res = res + y + " ";
    }
    if (format & YDate.CR)
      res = res + "\n";
    if (format & YDate.h) {
      if (YDate.use24Hformat) {
        let h = "0" + this.getHours().toString();
        res = res + h.substring(h.length - 2);
        if (!(format & YDate.m))
          res = res + "H";
      } else {
        let hour = this.getHours();
        ampm = "AM";
        if (hour > 11)
          ampm = "PM";
        if (hour > 12)
          hour = hour - 12;
        if (hour == 0)
          hour = 12;
        res = res + hour.toString();
      }
    }
    if (format & YDate.m) {
      let m = "0" + this.getMinutes().toString();
      res = res + ":" + m.substring(m.length - 2);
    }
    if (format & YDate.s) {
      let s = "0" + this.getSeconds().toString();
      res = res + ":" + s.substring(s.length - 2);
    }
    if (format & YDate.ms1) {
      let ms = "00" + this.getMilliseconds().toString();
      res = res + "." + ms.substring(ms.length - 3).substring(1);
    } else if (format & YDate.ms01) {
      let ms = "00" + this.getMilliseconds().toString();
      res = res + "." + ms.substring(ms.length - 3).substring(2);
    } else if (format & YDate.ms001) {
      let ms = "00" + this.getMilliseconds().toString();
      res = res + "." + ms.substring(ms.length - 3).substring(3);
    }
    if (format & YDate.h && !YDate.use24Hformat) {
      res = res + ampm;
    }
    return res;
  }
};
YDate.D = 1;
YDate.DD = 2;
YDate.M = 4;
YDate.YY = 8;
YDate.h = 16;
YDate.m = 32;
YDate.s = 64;
YDate.ms1 = 128;
YDate.ms01 = 256;
YDate.ms001 = 512;
YDate.CR = 1024;
YDate.isRelative = 2048;
YDate.YYYY = 4096;
YDate.d = new Date().toLocaleTimeString().toUpperCase();
YDate.use24Hformat = YDate.d.indexOf("AM") < 0 && YDate.d.indexOf("PM") < 0;
YDate.months = ["jan", "feb", "mar", "apr", "may", "jun", "jul", "aug", "sep", "oct", "nov", "dec"];
var TimeConverter = class {
  static UTCNow() {
    return new YDate();
  }
  static ToUnixTime(datetime) {
    return datetime.getTime() / 1e3;
  }
  static FromUnixTime(unixtime) {
    let t = new YDate();
    t.setTime(unixtime * 1e3);
    return t;
  }
  static tryParseStringToAbsDateTime(str) {
    let res = new TimeConverterParseResult();
    res.success = false;
    let date = new Date();
    let year = date.getFullYear();
    let month = date.getMonth();
    let day = date.getDate();
    let hours = 0;
    let minutes = 0;
    let seconds = 0;
    str = str.trim();
    while (str.indexOf("  ") > 0) {
      str = str.replace("  ", " ");
    }
    let dateFound = false;
    let timeFound = false;
    let it = str.split(" ");
    if (it.length <= 0)
      return res;
    for (let i = 0; i < it.length && i < 2; i++) {
      if (it[i].indexOf("-") > 0) {
        let tokens = it[i].split("-");
        if (tokens.length == 1) {
          day = parseInt(tokens[0]);
        } else if (tokens.length == 2) {
          day = parseInt(tokens[1]);
          month = parseInt(tokens[0]) - 1;
        } else {
          day = parseInt(tokens[2]);
          month = parseInt(tokens[1]) - 1;
          year = parseInt(tokens[0]);
        }
        dateFound = true;
      } else if (it[i].indexOf(":") > 0) {
        let tokens = it[i].split(":");
        if (tokens.length == 1) {
          hours = parseInt(tokens[0]);
        } else if (tokens.length == 2) {
          hours = parseInt(tokens[0]);
          minutes = parseInt(tokens[1]);
        } else {
          hours = parseInt(tokens[0]);
          minutes = parseInt(tokens[1]);
          seconds = parseFloat(tokens[2]);
        }
        timeFound = true;
      }
    }
    if (!timeFound && !dateFound)
      return res;
    if (isNaN(year) || isNaN(month) || isNaN(day) || isNaN(hours) || isNaN(minutes) || isNaN(seconds))
      return res;
    date.setFullYear(year, month, day);
    date.setHours(hours, minutes, seconds >> 0, 1e3 * (seconds % 1) >> 0);
    res.result = date.getTime() / 1e3;
    res.success = true;
    return res;
  }
  static tryParseStringToSecTimeSpan(st) {
    let res = new TimeConverterParseResult();
    let d = 0;
    st = st.toUpperCase();
    let n = st.indexOf("D");
    if (n > 0) {
      d = parseFloat(st.substring(0, n));
      if (isNaN(d)) {
        return res;
      }
      res.result += +d * 86400;
      if (n == st.length - 1) {
        res.success = true;
        return res;
      }
      st = st.substring(n + 1);
    }
    n = st.indexOf("H");
    if (n > 0) {
      d = parseFloat(st.substring(0, n));
      if (isNaN(d)) {
        return res;
      }
      res.result += d * 3600;
      if (n == st.length - 1) {
        res.success = true;
        return res;
      }
      st = st.substring(n + 1);
    }
    n = st.indexOf("M");
    if (n > 0) {
      d = parseFloat(st.substring(0, n));
      if (isNaN(d)) {
        return res;
      }
      res.result += d * 60;
      if (n == st.length - 1) {
        res.success = true;
        return res;
      }
      st = st.substring(n + 1);
    }
    n = st.indexOf("S");
    if (n < 0)
      n = st.length;
    d = parseFloat(st.substring(0, n));
    if (isNaN(d)) {
      return res;
    }
    res.result += d;
    res.success = true;
    return res;
  }
  static secTimeSpanToString(timespan, resolution) {
    let started = false;
    let res = "";
    if (timespan < 0) {
      res = "-";
      timespan = -timespan;
    }
    if (timespan >= 86400) {
      let d = timespan / 86400 >> 0;
      res = res + d.toString() + "d";
      timespan -= 86400 * d;
      started = true;
    }
    if (resolution >= 86400)
      return res != "" ? res : "0d";
    if (timespan >= 3600) {
      let d = timespan / 3600 >> 0;
      let ds = d.toString();
      if (started && ds.length == 1)
        ds = "0" + ds;
      res = res + ds + "h";
      timespan -= 3600 * d;
      started = true;
    }
    if (resolution >= 3600)
      return res != "" ? res : "0h";
    if (timespan < resolution)
      return res != "" ? res : "0h";
    if (timespan >= 60) {
      let d = timespan / 60 >> 0;
      let ds = d.toString();
      if (started && ds.length == 1)
        ds = "0" + ds;
      res = res + ds + "m";
      timespan -= 60 * d;
      started = true;
    }
    if (resolution >= 60)
      return res != "" ? res : "0m";
    if (timespan < resolution)
      return res != "" ? res : "0m";
    timespan = Math.round(timespan * 100) / 100;
    let s;
    if (resolution > 0.1) {
      s = timespan.toFixed(0);
    } else if (resolution > 0.01) {
      s = timespan.toFixed(1);
    } else if (resolution > 1e-3) {
      s = timespan.toFixed(2);
    } else {
      s = timespan.toString();
    }
    if (started && timespan < 10)
      s = "0" + s;
    res = res + s + "s";
    return res;
  }
  static RelativeFormat(dataDeltaTime, viewportDeltaTime, resolution) {
    let ShowSecondsTenth = true;
    let ShowSecondsHundredth = true;
    let ShowSeconds = true;
    let ShowMinutes = false;
    let ShowHours = false;
    let ShowDays = false;
    if (dataDeltaTime <= 0.1) {
      ShowSecondsHundredth = true;
    }
    if (dataDeltaTime <= 1) {
      ShowSecondsTenth = true;
    }
    if (dataDeltaTime >= 60 || viewportDeltaTime >= 60) {
      ShowMinutes = true;
    }
    if (dataDeltaTime >= 3600 || viewportDeltaTime >= 3600) {
      ShowHours = true;
    }
    if (dataDeltaTime >= 86400 || viewportDeltaTime >= 86400) {
      ShowDays = true;
    }
    if (resolution >= 0.1)
      ShowSecondsHundredth = false;
    if (resolution >= 1)
      ShowSecondsTenth = false;
    if (resolution >= 60)
      ShowSeconds = false;
    if (resolution >= 3600)
      ShowMinutes = false;
    if (resolution >= 86400)
      ShowHours = false;
    let format = 0;
    format |= YDate.isRelative;
    if (ShowSecondsTenth)
      format |= YDate.ms1;
    if (ShowSecondsHundredth)
      format |= YDate.ms01;
    if (ShowSeconds)
      format |= YDate.s;
    if (ShowMinutes)
      format |= YDate.m;
    if (ShowHours)
      format |= YDate.h;
    if (ShowDays)
      format |= YDate.D;
    return format;
  }
  static BestTimeformat(dataDeltaTime, viewportDeltaTime, tref) {
    let res = new TimeResolution();
    let ShowSecondsTenth = true;
    let ShowSecondsHundredth = true;
    let ShowSeconds = true;
    let ShowMinutes = false;
    let ShowHours = false;
    let ShowDays = false;
    let ShowMonths = false;
    let ShowYears = false;
    if (viewportDeltaTime <= 0.1) {
      res.step = 0.01;
    } else if (viewportDeltaTime <= 1) {
      res.step = 0.1;
    } else if (viewportDeltaTime <= 2) {
      res.step = 0.2;
    } else if (viewportDeltaTime <= 5) {
      res.step = 0.5;
    } else if (viewportDeltaTime <= 10) {
      res.step = 1;
    } else if (viewportDeltaTime <= 20) {
      res.step = 2;
    } else if (viewportDeltaTime <= 30) {
      res.step = 3;
    } else if (viewportDeltaTime <= 40) {
      res.step = 4;
    } else if (viewportDeltaTime <= 60) {
      res.step = 5;
    } else if (viewportDeltaTime <= 120) {
      res.step = 10;
    } else if (viewportDeltaTime <= 300) {
      res.step = 30;
    } else if (viewportDeltaTime <= 900) {
      res.step = 60;
    } else if (viewportDeltaTime <= 1800) {
      res.step = 180;
    } else if (viewportDeltaTime <= 3600) {
      res.step = 300;
    } else if (viewportDeltaTime <= 7200) {
      res.step = 600;
    } else if (viewportDeltaTime <= 14e3) {
      res.step = 900;
    } else if (viewportDeltaTime <= 21600) {
      res.step = 1800;
    } else if (viewportDeltaTime <= 43200) {
      res.step = 3600;
    } else if (viewportDeltaTime <= 86400) {
      res.step = 7200;
    } else if (viewportDeltaTime <= 2 * 86400) {
      res.step = 2 * 7200;
    } else if (viewportDeltaTime <= 4 * 86400) {
      res.step = 4 * 7200;
    } else if (viewportDeltaTime <= 7 * 86400) {
      res.step = 86400;
    } else if (viewportDeltaTime <= 14 * 86400) {
      res.step = 2 * 86400;
    } else if (viewportDeltaTime <= 28 * 86400) {
      res.step = 4 * 86400;
    } else if (viewportDeltaTime <= 56 * 86400) {
      res.step = 7 * 86400;
    } else if (viewportDeltaTime <= 112 * 86400) {
      res.step = 14 * 86400;
    } else if (viewportDeltaTime <= 224 * 86400) {
      res.step = 31 * 86400;
    } else if (viewportDeltaTime <= 448 * 86400) {
      res.step = 62 * 86400;
    } else if (viewportDeltaTime <= 896 * 86400) {
      res.step = 93 * 86400;
    } else {
      res.step = 365 * 86400;
    }
    if (tref == TimeConverter.TimeReference.ABSOLUTE) {
      ShowSecondsHundredth = true;
      ShowSecondsTenth = true;
      ShowMinutes = true;
      ShowHours = true;
      ShowDays = dataDeltaTime > 86400;
      ShowMonths = dataDeltaTime > 86400;
      ShowYears = dataDeltaTime > 28 * 6 * 86400;
      if (res.step >= 0.1)
        ShowSecondsHundredth = false;
      if (res.step >= 1)
        ShowSecondsTenth = false;
      if (res.step >= 60)
        ShowSeconds = false;
      if (res.step >= 3600)
        ShowMinutes = false;
      if (res.step >= 86400)
        ShowHours = false;
      if (res.step >= 31 * 86400)
        ShowDays = false;
      if (res.step >= 365 * 86400)
        ShowMonths = false;
      res.format = 0;
      if (ShowSecondsHundredth)
        res.format |= YDate.ms01;
      if (ShowSecondsTenth)
        res.format |= YDate.ms1;
      if (ShowSeconds)
        res.format |= YDate.s;
      if (ShowMinutes)
        res.format = res.format |= YDate.m;
      if (ShowHours)
        res.format = res.format |= YDate.h;
      if (res.format != 0 && (ShowDays || ShowMonths))
        res.format |= YDate.CR;
      if (ShowDays)
        res.format |= YDate.D;
      if (ShowMonths)
        res.format |= YDate.M;
      if (ShowYears)
        res.format |= YDate.YY;
      if (res.format == YDate.YY)
        res.format = YDate.YYYY;
    } else {
      res.format = TimeConverter.RelativeFormat(dataDeltaTime, viewportDeltaTime, res.step);
    }
    return res;
  }
};
(function(TimeConverter2) {
  class TimeReferenceEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, TimeReference);
    }
  }
  TimeConverter2.TimeReferenceEnumItem = TimeReferenceEnumItem;
  class TimeReference extends YEnum {
  }
  TimeReference.ABSOLUTE = new TimeReferenceEnumItem("ABSOLUTE", "Absolute");
  TimeReference.RELATIVE = new TimeReferenceEnumItem("RELATIVE", "Relative to first data");
  TimeConverter2.TimeReference = TimeReference;
})(TimeConverter || (TimeConverter = {}));
var MinMax = class {
  constructor(minimum, maximum) {
    this.Min = 0;
    this.Max = 0;
    this.Min = minimum;
    this.Max = maximum;
  }
};
var MinMaxHandler = class {
  static extend(M, factor) {
    if (isNaN(M.Min))
      return M;
    let delta = M.Max - M.Min;
    return new MinMax(M.Min - delta * (factor - 1) / 2, M.Max + delta * (factor - 1) / 2);
  }
  static DefaultValue(value1, value2) {
    if (typeof value2 === "undefined") {
      if (typeof value1 === "undefined")
        return new MinMax(Number.NaN, Number.NaN);
      return new MinMax(value1, value1);
    }
    if (typeof value1 === "undefined")
      return new MinMax(value2, value2);
    if (value2 < value1)
      throw new RangeError("MinMax invalid parameters (" + value1.toString() + ">" + value2.toString());
    return new MinMax(value1, value2);
  }
  static isDefined(v) {
    return !isNaN(v.Min);
  }
  static Combine(M1, M2) {
    if (isNaN(M1.Min))
      return new MinMax(M2.Min, M2.Max);
    if (isNaN(M2.Min))
      return new MinMax(M1.Min, M1.Max);
    let res = new MinMax(M2.Min, M2.Max);
    if (M1.Min < res.Min)
      res.Min = M1.Min;
    if (M1.Max < res.Min)
      res.Min = M1.Max;
    if (M1.Min > res.Max)
      res.Max = M1.Min;
    if (M1.Max > res.Max)
      res.Max = M1.Max;
    return res;
  }
  static CombineWithNumber(M1, value) {
    if (isNaN(M1.Min))
      return new MinMax(value, value);
    if (value < M1.Min)
      return new MinMax(value, M1.Max);
    if (value > M1.Max)
      return new MinMax(M1.Min, value);
    return new MinMax(M1.Min, M1.Max);
  }
};
var DataSegment = class {
  static ArrayCopy(sourceArray, sourceIndex, destinationArray, destinationIndex, length) {
    for (let i = 0; i < length; i++) {
      destinationArray[destinationIndex + i] = sourceArray[sourceIndex + i].clone();
    }
  }
  constructor(p) {
    this.data = [];
    this.count = 0;
    if (p instanceof Array) {
      this.data = new Array(p.length);
      DataSegment.ArrayCopy(p, 0, this.data, 0, p.length);
      this.count = p.length;
    } else if (p instanceof pointXY) {
      this.data = new Array(DataSegment.SegmentGranularity);
      this.data[0] = p;
      this.count = 1;
    } else {
      throw new Error("invalid constructor paramter type");
    }
  }
  grow() {
    let targetCount = this.data.length + DataSegment.SegmentGranularity;
    while (this.data.length < targetCount) {
      this.data.push(null);
    }
  }
};
DataSegment.SegmentGranularity = 1e3;
var Summary = class {
  getBufferpoint() {
    if (this.vtlPtCount <= 0)
      return null;
    return new pointsSummary(this.Xmin, this.Xmax, this.Ymin, this.Ymax);
  }
  Dump() {
    var _a, _b, _c, _d;
    console.log("Summary level" + this.selfIndex + ", " + this.segments.length + " segments, " + this.totalpoints + " points");
    let lastx = 0;
    for (let s = 0; s < this.segments.length; s++) {
      console.log("  segment " + s);
      for (let i = 0; i < this.segments[s].ptCount; i++) {
        console.log(((_a = this.segments[s].data[i]) === null || _a === void 0 ? void 0 : _a.x1) + "," + ((_b = this.segments[s].data[i]) === null || _b === void 0 ? void 0 : _b.ymin) + " delataX=" + Math.round(this.segments[s].data[i].x1 - lastx));
        console.log(((_c = this.segments[s].data[i]) === null || _c === void 0 ? void 0 : _c.x2) + "," + ((_d = this.segments[s].data[i]) === null || _d === void 0 ? void 0 : _d.ymax) + " delataX=" + Math.round(this.segments[s].data[i].x2 - this.segments[s].data[i].x1));
        lastx = this.segments[s].data[i].x2;
      }
    }
  }
  constructor(index, array, pointSize) {
    this.segments = [];
    this.totalpoints = 0;
    this.Xmin = 0;
    this.Xmax = 0;
    this.Ymin = 0;
    this.Ymax = 0;
    this.vtlPtCount = 0;
    this.pointSize = 0;
    this.isLast = false;
    this.newSummaryLevelTrigger = 0;
    this.selfIndex = index;
    this.selfArray = array;
    this.pointSize = pointSize;
    this.isLast = true;
  }
  processSegments(segments) {
    if (segments.length <= 0)
      return;
    let last = segments.length - 1;
    this.Xmin = segments[last].data[0].x;
    this.Xmax = segments[last].data[0].x;
    this.Ymin = segments[last].data[0].y;
    this.Ymax = segments[last].data[0].y;
    this.totalpoints = 0;
    this.vtlPtCount = 0;
    for (let s = last; s >= 0; s--) {
      for (let i = 0; i < segments[s].data.length; i++) {
        let p = segments[s].data[i];
        if (p.x < this.Ymin)
          this.Ymin = p.y;
        if (p.x > this.Ymax)
          this.Ymax = p.y;
        this.Xmax = p.x;
        this.vtlPtCount++;
        if (this.vtlPtCount >= this.pointSize) {
          this.flush(false);
          this.Xmin = p.x;
          this.Ymin = p.y;
          this.Ymax = p.y;
        }
      }
      if (s > 0) {
        let len = segments[s].data.length;
        let p2 = segments[s - 1].data[0];
        let p1 = segments[s].data[len - 1];
        let lastDelta = 1;
        if (len > 1) {
          let p0 = segments[s].data[len - 2];
          lastDelta = p1.x - p0.x;
        }
        if (p2.x - p1.x > this.pointSize * lastDelta) {
          this.flush(false);
          this.Xmin = p2.x;
          this.Ymin = p2.y;
          this.Ymax = p2.y;
          this.addNewEmptySegment();
        }
      }
    }
    if (this.totalpoints > 1) {
      let it = new Summary(this.selfIndex + 1, this.selfArray, this.pointSize * SUMMARY_GRANULARITY);
      this.selfArray.push(it);
      this.isLast = false;
      it.processSegments(segments);
    }
  }
  addNewLevel() {
    let newIndex = this.selfArray.length;
    if (Summary.DBG)
      console.log("--- ADDING NEW LEVEL " + newIndex);
    let it = new Summary(newIndex, this.selfArray, this.pointSize * SUMMARY_GRANULARITY);
    this.selfArray.push(it);
    this.isLast = false;
    let _xmin = this.segments[0].data[0].x1;
    let _xmax = this.segments[0].data[0].x2;
    let _ymin = this.segments[0].data[0].ymin;
    let _ymax = this.segments[0].data[0].ymax;
    let _count = 0;
    for (let s = 0; s < this.segments.length; s++) {
      for (let i = 0; i < this.segments[s].ptCount; i++) {
        _xmax = this.segments[s].data[i].x2;
        if (this.segments[s].data[i].ymin < _ymin)
          _ymin = this.segments[s].data[i].ymin;
        if (this.segments[s].data[i].ymin > _ymax)
          _ymax = this.segments[s].data[i].ymin;
      }
      _count += this.segments[s].ptCount;
      if (s < this.segments.length - 1) {
        if (this.segments[s].ptCount > 2) {
          let lastIndex = this.segments[s].ptCount - 1;
          let lastDelta = this.segments[s].data[lastIndex].x1 - this.segments[s].data[lastIndex - 1].x2;
          if (this.segments[s + 1].data[0].x1 - this.segments[s].data[this.segments[s].ptCount - 1].x2 > lastDelta * SUMMARY_GRANULARITY) {
            it.addNewEmptySegment();
            _xmin = this.segments[s + 1].data[0].x1;
            _xmax = this.segments[s + 1].data[0].x2;
            _ymin = this.segments[s + 1].data[0].ymin;
            _ymax = this.segments[s + 1].data[0].ymax;
            _count = 0;
          }
        }
      }
    }
    if (_count != 0) {
      it.addNewSinglePointSegment(_xmin, _xmax, _ymin, _ymax, _count);
    }
  }
  addNewSinglePointSegment(xmin, xmax, ymin, ymax, _count) {
    if (Summary.DBG)
      console.log(" ===> level " + this.selfIndex + " new single point segment");
    this.segments.push(new DataSummarySegment(new pointsSummary(xmin, xmax, ymin, ymax), _count));
  }
  addNewEmptySegment() {
    if (Summary.DBG)
      console.log(" ===> level " + this.selfIndex + " new empty segment");
    this.segments.push(new DataSummarySegment(null, null));
  }
  addSequentialPoint(p, maxHoleSize) {
    if (Summary.DBG)
      console.log(" ADD Point, LEVEL " + this.selfIndex + " Vtl point = " + this.vtlPtCount + "/" + this.pointSize + " TOTAL Points= " + this.totalpoints);
    if (this.isLast && this.totalpoints >= SUMMARY_GRANULARITY)
      this.addNewLevel();
    if (this.vtlPtCount == 0) {
      this.Xmin = p.x;
      this.Xmax = p.x;
      this.Ymin = p.y;
      this.Ymax = p.y;
      this.vtlPtCount = 1;
      if (Summary.DBG) {
        if (this.selfIndex == 1)
          console.log(" --> added 1srt virtual pt vtlPtCount=" + this.vtlPtCount + "/" + this.pointSize);
      }
      if (!this.isLast)
        this.selfArray[this.selfIndex + 1].addSequentialPoint(p, maxHoleSize * SUMMARY_GRANULARITY);
      return;
    } else {
      if (Summary.DBG)
        console.log(" --> level " + this.selfIndex + " delta = " + (p.x - this.Xmax) + "/" + maxHoleSize);
      if (maxHoleSize > 0 && p.x - this.Xmax > maxHoleSize) {
        if (Summary.DBG)
          console.log(" --> level " + this.selfIndex + " hole detected");
        this.flush(false);
        this.addNewEmptySegment();
        this.Xmin = p.x;
        this.Xmax = p.x;
        this.Ymin = p.y;
        this.Ymax = p.y;
        this.vtlPtCount = 1;
        if (!this.isLast)
          this.selfArray[this.selfIndex + 1].addSequentialPoint(p, maxHoleSize * SUMMARY_GRANULARITY);
        return;
      }
      if (p.y < this.Ymin)
        this.Ymin = p.y;
      if (p.y > this.Ymax)
        this.Ymax = p.y;
      this.Xmax = p.x;
      this.vtlPtCount++;
      if (Summary.DBG) {
        if (this.selfIndex == 1)
          console.log(" --> level " + this.selfIndex + " added subsequent virtual pt vtlPtCount=" + this.vtlPtCount + "/" + this.pointSize);
      }
      if (this.vtlPtCount >= this.pointSize) {
        if (Summary.DBG) {
          if (this.selfIndex == 1)
            console.log(" --> level " + this.selfIndex + " flushing");
        }
        this.flush(false);
      }
    }
    if (!this.isLast)
      this.selfArray[this.selfIndex + 1].addSequentialPoint(p, maxHoleSize * SUMMARY_GRANULARITY);
  }
  flush(forceNewSegment) {
    if (this.segments.length == 0 || forceNewSegment)
      this.segments.push(new DataSummarySegment(null, null));
    let lastsegment = this.segments[this.segments.length - 1];
    lastsegment.data[lastsegment.ptCount] = new pointsSummary(this.Xmin, this.Xmax, this.Ymin, this.Ymax);
    this.totalpoints++;
    lastsegment.ptCount++;
    this.vtlPtCount = 0;
  }
};
Summary.DBG = false;
var DataSummarySegment = class {
  static ArrayCopy(sourceArray, sourceIndex, destinationArray, destinationIndex, length) {
    for (let i = 0; i < length; i++) {
      destinationArray[destinationIndex + i] = sourceArray[sourceIndex + i].clone();
    }
  }
  constructor(p, virtualPointCount) {
    this.data = [];
    this.ptCount = 0;
    if (p instanceof Array) {
      this.data = new Array(p.length);
      DataSummarySegment.ArrayCopy(p, 0, this.data, 0, p.length);
      this.ptCount = p.length;
    } else if (p instanceof pointsSummary) {
      this.data = new Array(DataSummarySegment.SegmentGranularity);
      this.data[0] = p;
      this.ptCount = 1;
    } else if (p == null) {
      this.data = new Array(DataSummarySegment.SegmentGranularity);
      this.ptCount = 0;
    }
  }
  grow() {
    let targetCount = this.data.length + DataSummarySegment.SegmentGranularity;
    while (this.data.length < targetCount) {
      this.data.push(null);
    }
  }
};
DataSummarySegment.SegmentGranularity = 1e3;
var DataSerie = class {
  get userData() {
    return this._userData;
  }
  set userData(value) {
    this._userData = value;
  }
  static get MaxPointsPerSeries() {
    return DataSerie._MaxPointsPerSeries;
  }
  static set MaxPointsPerSeries(value) {
    DataSerie._MaxPointsPerSeries = value;
  }
  get timeRange() {
    return this._timeRange;
  }
  get valueRange() {
    return this._valueRange;
  }
  constructor(parent) {
    this.totalPointCount = 0;
    this._userData = null;
    this._yAxisIndex = 0;
    this._pen = null;
    this._legendPen = null;
    this._brush = null;
    this._navigatorpen = null;
    this._visible = true;
    this._disabled = false;
    this._color = YColor.Black;
    this._thickness = 1;
    this._legend = "";
    this._unit = "";
    this.segments = [];
    this.summaries = null;
    if (parent.yAxes.length <= 0)
      throw new Error("Define at least one yAxis");
    this._timeRange = MinMaxHandler.DefaultValue();
    this._valueRange = MinMaxHandler.DefaultValue();
    this.parent = parent;
  }
  get yAxisIndex() {
    return this._yAxisIndex;
  }
  set yAxisIndex(value) {
    if (value >= this.parent.yAxes.length)
      throw new RangeError("No such yAxis (" + value.toString() + ")");
    this._yAxisIndex = value;
    this.parent.yAxes[this._yAxisIndex].AutoShow();
  }
  get pen() {
    if (this._pen == null) {
      this._pen = new YPen(this._color, this._thickness);
      this._pen.endCap = 2;
      this._pen.linejoin = YPen.LineJoin.Round;
    }
    return this._pen;
  }
  get legendPen() {
    if (this._legendPen == null) {
      this._legendPen = new YPen(this._color, this._thickness * this.parent.legendPanel.traceWidthFactor);
    }
    return this._legendPen;
  }
  resetlegendPen() {
    this._legendPen = null;
  }
  get brush() {
    if (this._brush == null)
      this._brush = new YSolidBrush(this._color);
    return this._brush;
  }
  get navigatorpen() {
    if (this._navigatorpen == null) {
      this._navigatorpen = new YPen(YColor.FromArgb(100, this._color.red, this._color.green, this._color.blue), 1);
    }
    return this._navigatorpen;
  }
  get visible() {
    return this._visible;
  }
  set visible(value) {
    this._visible = value;
    this.parent.redraw();
  }
  get disabled() {
    return this._disabled;
  }
  set disabled(value) {
    this._disabled = value;
    this.parent.redraw();
  }
  get color() {
    return this._color;
  }
  set color(value) {
    this._color = value;
    this._pen = null;
    this._legendPen = null;
    this._brush = null;
    this._navigatorpen = null;
    this.parent.redraw();
  }
  get thickness() {
    return this._thickness;
  }
  set thickness(value) {
    if (value < 0)
      throw new RangeError("Thickness must be a positive value");
    this._thickness = value;
    this._pen = null;
    this._legendPen = null;
    this.parent.redraw();
  }
  get legend() {
    return this._legend;
  }
  set legend(value) {
    this._legend = value;
    this.parent.redraw();
  }
  get unit() {
    return this._unit;
  }
  set unit(value) {
    this._unit = value;
    this.parent.redraw();
  }
  AddNewSegment(p) {
    this.segments.splice(0, 0, new DataSegment(p));
  }
  getlastPoint() {
    if (this.segments.length <= 0) {
      return new pointXY(NaN, NaN);
    }
    return this.segments[this.segments.length - 1].data[this.segments[this.segments.length - 1].count - 1];
  }
  handleSummary(p, delta) {
    if (this.summaries == null) {
      this.summaries = [];
      this.summaries.push(new Summary(0, this.summaries, SUMMARY_GRANULARITY));
    }
    if (this.summaries != null)
      this.summaries[0].addSequentialPoint(p, delta);
  }
  AddPoint(p) {
    this._timeRange = MinMaxHandler.CombineWithNumber(this._timeRange, p.x);
    this._valueRange = MinMaxHandler.CombineWithNumber(this._valueRange, p.y);
    let delta1 = -1;
    let delta2 = -1;
    if (this.segments.length <= 0) {
      this.AddNewSegment(p);
      this.totalPointCount++;
      if (SUMMARY_GRANULARITY > 0)
        this.handleSummary(p, delta1);
      return;
    } else if (this.segments[0].count > 1) {
      delta1 = this.segments[0].data[this.segments[0].count - 1].x - this.segments[0].data[this.segments[0].count - 2].x;
      delta2 = p.x - this.segments[0].data[this.segments[0].count - 1].x;
      if (delta2 > 0.1 && (delta2 < 0 || delta2 > 2 * delta1)) {
        this.AddNewSegment(p);
        if (SUMMARY_GRANULARITY > 0)
          this.handleSummary(p, delta1);
        return;
      }
    }
    if (SUMMARY_GRANULARITY > 0)
      this.handleSummary(p, delta1);
    this.segments[0].data[this.segments[0].count] = p;
    this.segments[0].count++;
    this.totalPointCount++;
    if (DataSerie._MaxPointsPerSeries > 0 && this.totalPointCount > DataSerie._MaxPointsPerSeries) {
      this.dataCleanUp();
      this.rebuildSummaries();
    }
    this.parent.adjustGlobalTimeRange(p.x);
    this.parent.redraw();
  }
  rebuildSummaries() {
    if (SUMMARY_GRANULARITY <= 0)
      return;
    this.summaries = [];
    this.summaries.push(new Summary(0, this.summaries, SUMMARY_GRANULARITY));
    this.summaries[0].processSegments(this.segments);
  }
  dumpSummaries() {
    if (this.summaries != null)
      for (let i = 0; i < this.summaries.length; i++)
        this.summaries[i].Dump();
    else
      console.log("****No summaries ****");
  }
  dataCleanUp() {
    if (this.segments.length <= 0)
      return;
    let newLimit = DataSerie._MaxPointsPerSeries * 90 / 100;
    while (this.segments[this.segments.length - 1].count <= this.totalPointCount - newLimit) {
      this.totalPointCount -= this.segments[this.segments.length - 1].count;
      this.segments.splice(this.segments.length - 1, 1);
    }
    if (this.totalPointCount > newLimit) {
      let delta = this.totalPointCount - newLimit;
      let newsize = this.segments[this.segments.length - 1].count - delta;
      let newdata = new Array(newsize);
      DataSegment.ArrayCopy(this.segments[this.segments.length - 1].data, delta, newdata, 0, this.segments[this.segments.length - 1].count - delta);
      this.segments[this.segments.length - 1].data = newdata;
      this.segments[this.segments.length - 1].count -= delta;
      this.totalPointCount -= delta;
    }
    let tmin = this.segments[0].data[0].x;
    let tmax = this.segments[0].data[0].x;
    let ymin = this.segments[0].data[0].y;
    let ymax = this.segments[0].data[0].y;
    for (let i = 0; i < this.segments.length; i++) {
      let count = this.segments[i].count;
      if (tmin > this.segments[i].data[0].x)
        tmin = this.segments[i].data[0].x;
      if (tmax < this.segments[i].data[count - 1].x)
        tmax = this.segments[i].data[count - 1].x;
      for (let j = 0; j < count; j++) {
        if (ymin > this.segments[i].data[j].y)
          ymin = this.segments[i].data[j].y;
        if (ymax < this.segments[i].data[j].y)
          ymax = this.segments[i].data[j].y;
      }
    }
    this._timeRange.Min = tmin;
    this._timeRange.Max = tmax;
    this._valueRange.Min = ymin;
    this._valueRange.Max = ymax;
  }
  InsertPoints(points) {
    if (points.length == 0)
      return;
    if (points.length == 1) {
      this._timeRange = MinMaxHandler.CombineWithNumber(this._timeRange, points[0].x);
      this._valueRange = MinMaxHandler.CombineWithNumber(this._valueRange, points[0].y);
      return;
    }
    let FirstStep = points[1].x - points[0].x;
    let LastStep = points[points.length - 1].x - points[points.length - 2].x;
    let InsertAtBegining = -1;
    let InsertAtEnd = -1;
    for (let i = 0; i < this.segments.length; i++) {
      if (this.segments[i].count > 1) {
        let DeltaInsertAtBegining = this.segments[i].data[0].x - points[points.length - 1].x;
        let DeltaInsertAtEnd = points[0].x - this.segments[i].data[this.segments[i].count - 1].x;
        if (DeltaInsertAtBegining > 0 && DeltaInsertAtBegining < 2 * FirstStep)
          InsertAtBegining = i;
        if (DeltaInsertAtEnd > 0 && DeltaInsertAtEnd < 2 * LastStep)
          InsertAtEnd = i;
      }
    }
    if (InsertAtBegining >= 0) {
      DataSegment.ArrayCopy(this.segments[InsertAtBegining].data, 0, this.segments[InsertAtBegining].data, points.length, this.segments[InsertAtBegining].count);
      DataSegment.ArrayCopy(points, 0, this.segments[InsertAtBegining].data, 0, points.length);
      this.segments[InsertAtBegining].count += points.length;
      this.totalPointCount += points.length;
    } else if (InsertAtEnd >= 0) {
      DataSegment.ArrayCopy(points, 0, this.segments[InsertAtEnd].data, this.segments[InsertAtEnd].count, points.length);
      this.segments[InsertAtEnd].count += points.length;
      this.totalPointCount += points.length;
    } else {
      let inserted = false;
      for (let i = 0; i < this.segments.length; i++) {
        if (this.segments[i].data[this.segments[i].data.length - 1].x < points[0].x && !inserted) {
          this.segments.splice(i, 0, new DataSegment(points));
          inserted = true;
        }
      }
      if (!inserted)
        this.segments.push(new DataSegment(points));
      this.totalPointCount += points.length;
    }
    this._timeRange = MinMaxHandler.CombineWithNumber(this._timeRange, points[0].x);
    this._timeRange = MinMaxHandler.CombineWithNumber(this._timeRange, points[points.length - 1].x);
    for (let i = 0; i < points.length; i++) {
      this._valueRange = MinMaxHandler.CombineWithNumber(this._valueRange, points[i].y);
    }
    if (DataSerie._MaxPointsPerSeries > 0 && this.totalPointCount > DataSerie._MaxPointsPerSeries)
      this.dataCleanUp();
    this.parent.redraw();
  }
  static CompareSegments(a, b) {
    if (a.data[0].x > b.data[0].x)
      return -1;
    if (a.data[0].x < b.data[0].x)
      return 1;
    return 0;
  }
  getData() {
    let res = [];
    this.segments.sort(DataSerie.CompareSegments);
    for (let i = this.segments.length - 1; i >= 0; i--) {
      for (let j = 0; j < this.segments[i].count; j++) {
        res.push(this.segments[i].data[j]);
      }
    }
    return res;
  }
  findClosestValue(x, AllowInterpolation) {
    let N1 = 0;
    let N2 = 0;
    let Pos = 0;
    if (this.segments.length <= 0)
      return null;
    for (let i = 0; i < this.segments.length; i++) {
      if (x >= this.segments[i].data[0].x && x <= this.segments[i].data[this.segments[i].count - 1].x) {
        let data = this.segments[i].data;
        N1 = 0;
        N2 = this.segments[i].count - 1;
        while (N2 - N1 > 1) {
          let N = N1 + N2 >> 1;
          if (data[N].x > x)
            N2 = N;
          else
            N1 = N;
        }
        Pos = N1 - 1;
        if (Pos < 0)
          Pos = 0;
        if (!AllowInterpolation) {
          if (x - data[Pos].x < data[Pos + 1].x - x)
            return data[Pos];
          else
            return data[Pos + 1];
        } else {
          Pos++;
          if (x == data[Pos].x)
            return data[Pos];
          if (x == data[Pos + 1].x)
            return data[Pos + 1];
          let p = new pointXY();
          p.x = x;
          p.y = data[Pos].y + (data[Pos + 1].y - data[Pos].y) * (x - data[Pos].x) / (data[Pos + 1].x - data[Pos].x);
          return p;
        }
      }
    }
    if (AllowInterpolation)
      return null;
    try {
      this.segments[0].data[0].clone();
    } catch (e) {
      debugger;
    }
    let match = this.segments[0].data[0];
    let delta = Math.abs(this.segments[0].data[0].x - x);
    for (let i = 0; i < this.segments.length; i++) {
      let d1 = Math.abs(this.segments[i].data[0].x - x);
      let d2 = Math.abs(this.segments[i].data[this.segments[i].count - 1].x - x);
      if (d1 < delta) {
        match = this.segments[i].data[0];
        delta = d1;
      }
      if (d2 < delta) {
        match = this.segments[i].data[this.segments[i].count - 1];
        delta = d2;
      }
    }
    return match.clone();
  }
  clear() {
    this.segments = [];
    this._timeRange = MinMaxHandler.DefaultValue();
    this._valueRange = MinMaxHandler.DefaultValue();
    this.parent.clearCachedObjects();
    this.totalPointCount = 0;
  }
};
DataSerie._MaxPointsPerSeries = 0;
var DataTracker = class {
  get directParent() {
    return this._directParent;
  }
  get userData() {
    return this._userData;
  }
  set userData(value) {
    this._userData = value;
  }
  constructor(parent, directParent) {
    this._userData = null;
    this._enabled = false;
    this._showSerieName = false;
    this._showTimeStamp = false;
    this._dataPrecisionString = "";
    this._dataPrecision = DataTracker.DataPrecision.PRECISION_NOLIMIT;
    this._diameter = 5;
    this._handleLength = 25;
    this._detectionDistance = 50;
    this._bgColor = YColor.FromArgb(200, 255, 255, 255);
    this._borderColor = YColor.Black;
    this._borderthickness = 1;
    this._padding = 10;
    this._verticalMargin = 10;
    this._horizontalMargin = 10;
    this._bgBrush = null;
    this._pen = null;
    this._font = null;
    this._directParent = directParent;
    this._parentRenderer = parent;
    this._font = new YFont(parent, this, 8, null);
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    this._enabled = value;
    this._parentRenderer.redraw();
  }
  get showSerieName() {
    return this._showSerieName;
  }
  set showSerieName(value) {
    this._showSerieName = value;
    this._parentRenderer.redraw();
  }
  get showTimeStamp() {
    return this._showTimeStamp;
  }
  set showTimeStamp(value) {
    this._showTimeStamp = value;
    this._parentRenderer.redraw();
  }
  get dataPrecisionString() {
    return this._dataPrecisionString;
  }
  get dataPrecision() {
    return this._dataPrecision;
  }
  set dataPrecision(value) {
    this._dataPrecision = value;
    this.compute_dataPrecisionString();
    this._parentRenderer.redraw();
  }
  compute_dataPrecisionString() {
    if (this._dataPrecision == DataTracker.DataPrecision.PRECISION_NOLIMIT) {
      this._dataPrecisionString = "";
      return;
    }
    this._dataPrecisionString = "0.";
  }
  get diameter() {
    return this._diameter;
  }
  set diameter(value) {
    if (value < 0)
      throw new RangeError("Diameter must be a positive value");
    this._diameter = value;
    this._parentRenderer.redraw();
  }
  get handleLength() {
    return this._handleLength;
  }
  set handleLength(value) {
    if (value < 0)
      throw new RangeError("Hanle length must be a positive value");
    this._handleLength = value;
    this._parentRenderer.redraw();
  }
  get detectionDistance() {
    return this._detectionDistance;
  }
  set detectionDistance(value) {
    if (value <= 0)
      throw new RangeError("Distance must be a positive value");
    this._detectionDistance = value;
  }
  get bgColor() {
    return this._bgColor;
  }
  set bgColor(value) {
    this._bgColor = value;
    this._bgBrush = null;
    this._parentRenderer.redraw();
  }
  get borderColor() {
    return this._borderColor;
  }
  set borderColor(value) {
    this._borderColor = value;
    this._pen = null;
    this._parentRenderer.redraw();
  }
  get borderthickness() {
    return this._borderthickness;
  }
  set borderthickness(value) {
    if (value < 0)
      throw new RangeError("Thickness must be a positive value");
    this._borderthickness = value;
    this._pen = null;
    this._parentRenderer.redraw();
  }
  get padding() {
    return this._padding;
  }
  set padding(value) {
    if (value < 0)
      throw new RangeError("Padding must be a positive value");
    this._padding = value;
    this._parentRenderer.redraw();
  }
  get verticalMargin() {
    return this._verticalMargin;
  }
  set verticalMargin(value) {
    if (value < 0)
      throw new RangeError("Margin must be a positive value");
    this._verticalMargin = value;
    this._parentRenderer.redraw();
  }
  get horizontalMargin() {
    return this._horizontalMargin;
  }
  set horizontalMargin(value) {
    if (value < 0)
      throw new RangeError("Margin must be a positive value");
    this._horizontalMargin = value;
    this._parentRenderer.redraw();
  }
  get bgBrush() {
    if (this._bgBrush == null) {
      this._bgBrush = new YSolidBrush(this._bgColor);
    }
    return this._bgBrush;
  }
  get pen() {
    if (this._pen == null)
      this._pen = new YPen(this._borderColor, this._borderthickness, true);
    return this._pen;
  }
  get font() {
    return this._font;
  }
};
(function(DataTracker2) {
  class DataPrecisionEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, DataPrecision);
    }
  }
  DataTracker2.DataPrecisionEnumItem = DataPrecisionEnumItem;
  class DataPrecision extends YEnum {
  }
  DataPrecision.PRECISION_NOLIMIT = new DataPrecisionEnumItem("PRECISION_NOLIMIT", "As is");
  DataPrecision.PRECISION_1 = new DataPrecisionEnumItem("PRECISION_1", "1");
  DataPrecision.PRECISION_01 = new DataPrecisionEnumItem("PRECISION_01", "0.1");
  DataPrecision.PRECISION_001 = new DataPrecisionEnumItem("PRECISION_001", "0.01");
  DataPrecision.PRECISION_0001 = new DataPrecisionEnumItem("PRECISION_0001", "0.001");
  DataPrecision.PRECISION_00001 = new DataPrecisionEnumItem("PRECISION_00001", "0.0001");
  DataPrecision.PRECISION_000001 = new DataPrecisionEnumItem("PRECISION_000001", "0.00001");
  DataPrecision.PRECISION_0000001 = new DataPrecisionEnumItem("PRECISION_0000001", "0.000001");
  DataPrecision.PRECISION_00000001 = new DataPrecisionEnumItem("PRECISION_00000001", "0.0000001");
  DataPrecision.PRECISION_000000001 = new DataPrecisionEnumItem("PRECISION_000000001", "0.00000001");
  DataPrecision.PRECISION_0000000001 = new DataPrecisionEnumItem("PRECISION_0000000001", "0.000000001");
  DataTracker2.DataPrecision = DataPrecision;
})(DataTracker || (DataTracker = {}));
var LegendPanel = class {
  get directParent() {
    return this._directParent;
  }
  get userData() {
    return this._userData;
  }
  set userData(value) {
    this._userData = value;
  }
  get traceWidthFactor() {
    return this._traceWidth;
  }
  set traceWidthFactor(value) {
    if (value <= 0)
      throw new RangeError("This has to be a strictly positive value");
    this._traceWidth = value;
    this._parentRenderer.resetlegendPens();
    this._parentRenderer.redraw();
  }
  constructor(parent, directParent) {
    this._userData = null;
    this._traceWidth = 1;
    this._enabled = false;
    this._position = LegendPanel.Position.BOTTOM;
    this._overlap = false;
    this._bgColor = YColor.FromArgb(200, 255, 255, 255);
    this._borderColor = YColor.Black;
    this._borderthickness = 1;
    this._padding = 10;
    this._verticalMargin = 10;
    this._horizontalMargin = 10;
    this._bgBrush = null;
    this._pen = null;
    this._font = null;
    this._directParent = directParent;
    this._parentRenderer = parent;
    this._font = new YFont(parent, this, 8, null);
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    this._enabled = value;
    this._parentRenderer.redraw();
  }
  get position() {
    return this._position;
  }
  set position(value) {
    this._position = value;
    this._parentRenderer.redraw();
  }
  get overlap() {
    return this._overlap;
  }
  set overlap(value) {
    this._overlap = value;
    this._parentRenderer.redraw();
  }
  get bgColor() {
    return this._bgColor;
  }
  set bgColor(value) {
    this._bgColor = value;
    this._bgBrush = null;
    this._parentRenderer.redraw();
  }
  get borderColor() {
    return this._borderColor;
  }
  set borderColor(value) {
    this._borderColor = value;
    this._pen = null;
    this._parentRenderer.redraw();
  }
  get borderthickness() {
    return this._borderthickness;
  }
  set borderthickness(value) {
    if (value < 0)
      throw new RangeError("Thickness must be a positive value");
    this._borderthickness = value;
    this._pen = null;
    this._parentRenderer.redraw();
  }
  get padding() {
    return this._padding;
  }
  set padding(value) {
    if (value < 0)
      throw new RangeError("Padding must be a positive value");
    this._padding = value;
    this._parentRenderer.redraw();
  }
  get verticalMargin() {
    return this._verticalMargin;
  }
  set verticalMargin(value) {
    if (value < 0)
      throw new RangeError("Margin must be a positive value");
    this._verticalMargin = value;
    this._parentRenderer.redraw();
  }
  get horizontalMargin() {
    return this._horizontalMargin;
  }
  set horizontalMargin(value) {
    if (value < 0)
      throw new RangeError("Margin must be a positive value");
    this._horizontalMargin = value;
    this._parentRenderer.redraw();
  }
  get bgBrush() {
    if (this._bgBrush == null) {
      this._bgBrush = new YSolidBrush(this._bgColor);
    }
    return this._bgBrush;
  }
  get pen() {
    if (this._pen == null)
      this._pen = new YPen(this._borderColor, this._borderthickness, true);
    return this._pen;
  }
  get font() {
    return this._font;
  }
};
(function(LegendPanel2) {
  class PositionEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, Position);
    }
  }
  LegendPanel2.PositionEnumItem = PositionEnumItem;
  class Position extends YEnum {
  }
  Position.LEFT = new PositionEnumItem("LEFT", "Left");
  Position.TOPLEFT = new PositionEnumItem("TOPLEFT", "Top-Left");
  Position.TOP = new PositionEnumItem("TOP", "Top");
  Position.TOPRIGHT = new PositionEnumItem("TOPRIGHT", "Top-Right");
  Position.RIGHT = new PositionEnumItem("RIGHT", "Right");
  Position.BOTTOMRIGHT = new PositionEnumItem("BOTTOMRIGHT", "Bottom-Right");
  Position.BOTTOM = new PositionEnumItem("BOTTOM", "Bottom");
  Position.BOTTOMLEFT = new PositionEnumItem("BOTTOMLEFT", "Bottom-Left");
  LegendPanel2.Position = Position;
})(LegendPanel || (LegendPanel = {}));
var Navigator = class {
  get directParent() {
    return this._directParent;
  }
  get userData() {
    return this._userData;
  }
  set userData(value) {
    this._userData = value;
  }
  get showXAxisZones() {
    return this._showXAxisZones;
  }
  set showXAxisZones(value) {
    this._showXAxisZones = value;
  }
  get relativeheight() {
    return this._relativeheight;
  }
  set relativeheight(value) {
    if (value < 10)
      value = 10;
    if (value > 50)
      value = 50;
    this._relativeheight = value;
    this._parentRenderer.redraw();
  }
  constructor(parent, directParent) {
    this._userData = null;
    this._viewport = new ViewPortSettings();
    this.Xrange = null;
    this._showXAxisZones = true;
    this._relativeheight = 10;
    this._enabled = false;
    this._bgColor1 = YColor.FromArgb(255, 225, 225, 225);
    this._cursorBorderColor = YColor.FromArgb(255, 40, 40, 40);
    this._yAxisHandling = Navigator.YAxisHandling.AUTO;
    this._bgColor2 = YColor.FromArgb(255, 225, 225, 225);
    this._cursorColor = YColor.FromArgb(100, 0, 255, 0);
    this._cursorBrush = null;
    this._pen = null;
    this._cursorBorderPen = null;
    this._xAxisColor = YColor.Black;
    this._xAxisThickness = 1;
    this._borderPen = null;
    this._borderColor = YColor.DimGray;
    this._borderThickness = 1;
    this._bgBrush = null;
    this._font = null;
    this._directParent = directParent;
    this._parentRenderer = parent;
    this._font = new YFont(parent, this, 8, null);
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    this._enabled = value;
    this._parentRenderer.redraw();
  }
  get bgColor1() {
    return this._bgColor1;
  }
  set bgColor1(value) {
    this._bgColor1 = value;
    this._bgBrush = null;
    this._parentRenderer.redraw();
  }
  get cursorBorderColor() {
    return this._cursorBorderColor;
  }
  set cursorBorderColor(value) {
    this._cursorBorderColor = value;
    this._cursorBorderPen = null;
    this._parentRenderer.redraw();
  }
  get yAxisHandling() {
    return this._yAxisHandling;
  }
  set yAxisHandling(value) {
    this._yAxisHandling = value;
    this._parentRenderer.redraw();
  }
  get bgColor2() {
    return this._bgColor2;
  }
  set bgColor2(value) {
    this._bgColor2 = value;
    this._bgBrush = null;
    this._parentRenderer.redraw();
  }
  get cursorColor() {
    return this._cursorColor;
  }
  set cursorColor(value) {
    this._cursorColor = value;
    this._cursorBrush = null;
    this._parentRenderer.redraw();
  }
  get cursorBrush() {
    if (this._cursorBrush == null) {
      this._cursorBrush = new YSolidBrush(this._cursorColor);
    }
    return this._cursorBrush;
  }
  get pen() {
    if (this._pen == null)
      this._pen = new YPen(this._xAxisColor, this._xAxisThickness, true);
    return this._pen;
  }
  get cursorBorderPen() {
    if (this._cursorBorderPen == null)
      this._cursorBorderPen = new YPen(this._cursorBorderColor, 1, true);
    return this._cursorBorderPen;
  }
  get xAxisColor() {
    return this._xAxisColor;
  }
  set xAxisColor(value) {
    this._xAxisColor = value;
    this._pen = null;
    this._parentRenderer.redraw();
  }
  get xAxisThickness() {
    return this._xAxisThickness;
  }
  set xAxisThickness(value) {
    if (value < 0)
      throw new RangeError("Thickness must be a positive value");
    this._xAxisThickness = value;
    this._pen = null;
    this._parentRenderer.redraw();
  }
  get borderPen() {
    if (this._borderPen == null)
      this._borderPen = new YPen(this._borderColor, this._borderThickness, true);
    return this._borderPen;
  }
  get borderColor() {
    return this._borderColor;
  }
  set borderColor(value) {
    this._borderColor = value;
    this._borderPen = null;
    this._parentRenderer.redraw();
  }
  get borderThickness() {
    return this._borderThickness;
  }
  set borderThickness(value) {
    if (value < 0)
      throw new RangeError("Thickness must be a positive value");
    this._borderThickness = value;
    this._borderPen = null;
    this._parentRenderer.redraw();
  }
  setPosition(ParentWidth, ParentHeight, Lmargin, Rmargin, Tmargin, Bmargin) {
    if (this._viewport.Lmargin != Lmargin || this._viewport.Rmargin != Rmargin || this._viewport.Tmargin != Tmargin || this._viewport.Bmargin != Bmargin) {
      this._bgBrush = null;
    }
    this._viewport.Lmargin = Lmargin;
    this._viewport.Rmargin = Rmargin;
    this._viewport.Bmargin = Bmargin;
    this._viewport.Tmargin = Tmargin;
    this._viewport.Width = ParentWidth;
    this._viewport.Height = ParentHeight;
  }
  setIRLPosition(IRLx, IRLy, xZoom, yZoom) {
    this._viewport.IRLx = IRLx;
    this._viewport.IRLy = IRLy;
    this._viewport.zoomx = xZoom;
    this._viewport.zoomy = yZoom;
  }
  startCapture(IRLStartPoint, xAxisMin, xAxisMax) {
    this._viewport.OriginalXAxisMin = xAxisMin;
    this._viewport.OriginalXAxisMax = xAxisMax;
    this._viewport.OriginalIRLx = this._viewport.IRLx;
    this._viewport.OriginalLmargin = this._viewport.Lmargin;
    this._viewport.OriginalZoomx = this._viewport.zoomx;
    this._viewport.IRLCaptureStartX = IRLStartPoint.x;
    this._viewport.Capture = true;
  }
  get Capture() {
    return this._viewport.Capture;
  }
  stopCapture() {
    this._viewport.Capture = false;
  }
  get viewport() {
    return this._viewport;
  }
  get bgBrush() {
    if (this._bgBrush == null) {
      this._bgBrush = new YLinearGradientBrush(this._bgColor1, this._bgColor2);
    }
    return this._bgBrush;
  }
  get font() {
    return this._font;
  }
};
(function(Navigator2) {
  class YAxisHandlingEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, YAxisHandling);
    }
  }
  Navigator2.YAxisHandlingEnumItem = YAxisHandlingEnumItem;
  class YAxisHandling extends YEnum {
  }
  YAxisHandling.AUTO = new YAxisHandlingEnumItem("AUTO", "Automatic");
  YAxisHandling.INHERIT = new YAxisHandlingEnumItem("INHERIT", "Inherit from main view");
  Navigator2.YAxisHandling = YAxisHandling;
})(Navigator || (Navigator = {}));
var Marker = class {
  get userData() {
    return this._userData;
  }
  set userData(value) {
    this._userData = value;
  }
  static _round100(v) {
    return Math.round(100 * v) / 100;
  }
  get stringFormat() {
    if (this._stringFormat != null)
      return this._stringFormat;
    this._stringFormat = new YStringFormat(16384);
    this._stringFormat.LineAlignment = 1;
    switch (this._textAlign) {
      case Marker.TextAlign.LEFT:
        this._stringFormat.Alignment = 0;
        break;
      case Marker.TextAlign.CENTER:
        this._stringFormat.Alignment = 1;
        break;
      case Marker.TextAlign.RIGHT:
        this._stringFormat.Alignment = 2;
        break;
    }
    return this._stringFormat;
  }
  get PatchTextCallback() {
    return this._MarkerTextCallback;
  }
  set PatchTextCallback(callback) {
    this._MarkerTextCallback = callback;
  }
  get directParent() {
    return this._directParent;
  }
  constructor(parent, directParent) {
    this._userData = null;
    this._stringFormat = null;
    this._MarkerTextCallback = null;
    this._enabled = false;
    this._xposition = 0;
    this._xpositionIsRelative = false;
    this._yposition = 92;
    this._text = "Marker";
    this._textAlign = Marker.TextAlign.CENTER;
    this._bgColor = YColor.FromArgb(255, 255, 255, 192);
    this._borderColor = YColor.DarkRed;
    this._borderthickness = 1;
    this._arrowSize = 5;
    this._padding = 5;
    this._verticalMargin = 5;
    this._horizontalMargin = 5;
    this._bgBrush = null;
    this._arrowBrush = null;
    this._pen = null;
    this._navigatorpen = null;
    this._font = null;
    this._directParent = directParent;
    this._parentRenderer = parent;
    this._font = new YFont(parent, this, 8, null);
  }
  startCapture() {
    this._parentRenderer.startMarkerCapture(this);
  }
  setCapturedPosition(position, axis) {
    this.enabled = true;
    this._xpositionIsRelative = axis.timeReference == TimeConverter.TimeReference.RELATIVE && axis.zeroTime > 0;
    this._xposition = Marker._round100(this._xpositionIsRelative ? position - axis.zeroTime : position);
    this._parentRenderer.clearCachedObjects();
    this._parentRenderer.redraw();
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    if (this._enabled != value) {
      this._enabled = value;
      this._parentRenderer.clearCachedObjects();
      this._parentRenderer.redraw();
    }
  }
  get xposition() {
    return this._xposition;
  }
  set xposition(value) {
    this._xposition = Marker._round100(value);
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get timereference() {
    return this._xpositionIsRelative ? TimeConverter.TimeReference.RELATIVE : TimeConverter.TimeReference.ABSOLUTE;
  }
  set timereference(value) {
    let v = value == TimeConverter.TimeReference.RELATIVE;
    if (this._xpositionIsRelative != v) {
      let ZeroPosition = this._directParent.zeroTime;
      if (isNaN(ZeroPosition))
        ZeroPosition = 0;
      if (v) {
        this._xpositionIsRelative = true;
        this._xposition -= ZeroPosition;
      } else {
        this._xpositionIsRelative = false;
        this._xposition += ZeroPosition;
      }
      this._xposition = Marker._round100(this._xposition);
      this._parentRenderer.redraw();
    }
  }
  get positionOnXAxis() {
    return new xAxisPosition(this._xposition, this._xpositionIsRelative);
  }
  set positionOnXAxis(value) {
    if (value.capture) {
      this.startCapture();
    } else {
      let v = Marker._round100(value.value);
      if (this._xpositionIsRelative != value.relative || this._xposition != v) {
        this._xposition = v;
        this._xpositionIsRelative = value.relative;
        if (this._enabled)
          this._parentRenderer.redraw();
      }
    }
  }
  get yposition() {
    return this._yposition;
  }
  set yposition(value) {
    this._yposition = Math.min(100, Math.max(0, value));
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get text() {
    return this._text;
  }
  set text(value) {
    this._text = value;
    this._parentRenderer.clearCachedObjects();
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get textAlign() {
    return this._textAlign;
  }
  set textAlign(value) {
    this._textAlign = value;
    this._stringFormat = null;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get shortText() {
    if (this._text.length <= 20)
      return this._text;
    return this._text.substring(0, 18) + "..";
  }
  get bgColor() {
    return this._bgColor;
  }
  set bgColor(value) {
    this._bgColor = value;
    this._bgBrush = null;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get borderColor() {
    return this._borderColor;
  }
  set borderColor(value) {
    this._borderColor = value;
    this._arrowBrush = null;
    this._pen = null;
    this._navigatorpen = null;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get borderthickness() {
    return this._borderthickness;
  }
  set borderthickness(value) {
    if (value < 0)
      throw new RangeError("thickness must be a positive value");
    this._borderthickness = value;
    this._parentRenderer.clearCachedObjects();
    this._pen = null;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get arrowSize() {
    return this._arrowSize;
  }
  set arrowSize(value) {
    this._arrowSize = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get padding() {
    return this._padding;
  }
  set padding(value) {
    if (value < 0)
      throw new RangeError("Padding must be a positive value");
    this._padding = value;
    this._parentRenderer.clearCachedObjects();
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get verticalMargin() {
    return this._verticalMargin;
  }
  set verticalMargin(value) {
    this._verticalMargin = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get horizontalMargin() {
    return this._horizontalMargin;
  }
  set horizontalMargin(value) {
    this._horizontalMargin = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get bgBrush() {
    if (this._bgBrush == null) {
      this._bgBrush = new YSolidBrush(this._bgColor);
    }
    return this._bgBrush;
  }
  get arrowBrush() {
    if (this._arrowBrush == null) {
      this._arrowBrush = new YSolidBrush(this._borderColor, true);
    }
    return this._arrowBrush;
  }
  get pen() {
    if (this._pen == null)
      this._pen = new YPen(this._borderColor, this._borderthickness, true);
    return this._pen;
  }
  get navigatorpen() {
    if (this._navigatorpen == null)
      this._navigatorpen = new YPen(this._borderColor, 1);
    return this._navigatorpen;
  }
  get font() {
    return this._font;
  }
};
(function(Marker2) {
  class TextAlignEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, TextAlign);
    }
  }
  Marker2.TextAlignEnumItem = TextAlignEnumItem;
  class TextAlign extends YEnum {
  }
  TextAlign.LEFT = new TextAlignEnumItem("LEFT", "Left");
  TextAlign.CENTER = new TextAlignEnumItem("CENTER", "Center");
  TextAlign.RIGHT = new TextAlignEnumItem("RIGHT", "Right");
  Marker2.TextAlign = TextAlign;
})(Marker || (Marker = {}));
var Legend = class {
  get directParent() {
    return this._directParent;
  }
  get userData() {
    return this._userData;
  }
  set userData(value) {
    this._userData = value;
  }
  constructor(parent, directParent) {
    this._userData = null;
    this._title = "";
    this._font = null;
    this._directParent = directParent;
    this._parentRenderer = parent;
    this._font = new YFont(parent, this, 12, null);
  }
  get title() {
    return this._title;
  }
  set title(value) {
    this._title = value;
    this._parentRenderer.redraw();
  }
  get font() {
    return this._font;
  }
};
var GenericAxis = class {
  get directParent() {
    return this._directParent;
  }
  get zones() {
    return this._zones;
  }
  AddZone() {
    let z = new Zone(this._parentRenderer, this);
    this._zones.push(z);
    return z;
  }
  get userData() {
    return this._userData;
  }
  set userData(value) {
    this._userData = value;
  }
  get AxisChanged() {
    return this._AxisChanged;
  }
  set AxisChanged(value) {
    this._AxisChanged = value;
  }
  constructor(parent, directParent) {
    this._userData = null;
    this._AxisChanged = null;
    this._pen = null;
    this._gridPen = null;
    this._visible = true;
    this._AllowAutoShow = false;
    this._min = Number.NaN;
    this._max = Number.NaN;
    this._step = Number.NaN;
    this._thickness = 1;
    this._color = YColor.Black;
    this._showGrid = false;
    this._gridColor = YColor.FromArgb(50, 0, 0, 0);
    this._gridThickness = 1;
    this._font = null;
    this._zones = [];
    this._directParent = directParent;
    this._parentRenderer = parent;
    this._legend = new Legend(parent, this);
    this._font = new YFont(parent, this);
  }
  get pen() {
    if (this._pen == null)
      this._pen = new YPen(this._color, this._thickness, true);
    return this._pen;
  }
  get gridPen() {
    if (this._gridPen == null)
      this._gridPen = new YPen(this._gridColor, this._gridThickness, true);
    return this._gridPen;
  }
  get visible() {
    return this._visible;
  }
  set visible(value) {
    this._visible = value;
    if (!value) {
      this._AllowAutoShow = false;
    }
    this._parentRenderer.redraw();
  }
  get AllowAutoShow() {
    return this._AllowAutoShow;
  }
  set AllowAutoShow(value) {
    this._AllowAutoShow = value;
  }
  AutoShow() {
    if (this._AllowAutoShow) {
      this.visible = true;
      if (this._AxisChanged != null)
        this._AxisChanged(this);
    }
  }
  set_minMax(value_min, value_max) {
    if (!isNaN(value_min) && !isNaN(value_max) && value_min >= value_max) {
      throw new RangeError("Min (" + value_min.toString() + ") cannot be greater than max (" + value_max.toString() + ")");
    }
    this._min = value_min;
    this._max = value_max;
    this._parentRenderer.redraw();
  }
  get min() {
    return this._min;
  }
  set min(value) {
    if (!isNaN(value) && !isNaN(this._max) && !YDataRenderer.minMaxCheckDisabled) {
      if (value >= this._max) {
        throw new RangeError("Min cannot be greater than max (" + this._max.toString() + ")");
      }
    }
    this._min = value;
    this._parentRenderer.redraw();
  }
  setMinMax(min, max) {
    if (min < max) {
      this._min = min;
      this._max = max;
      this._parentRenderer.redraw();
    }
  }
  get max() {
    return this._max;
  }
  set max(value) {
    if (!isNaN(value) && !isNaN(this._min) && !YDataRenderer.minMaxCheckDisabled) {
      if (value <= this._min)
        throw new RangeError("Max cannot be less than min (" + this._min.toString() + ")");
    }
    this._max = value;
    this._parentRenderer.redraw();
  }
  get step() {
    return this._step;
  }
  set step(value) {
    if (!isNaN(value) && value < 0)
      throw new RangeError("Steps must be a strictely positive value");
    this._step = value;
    this._parentRenderer.redraw();
  }
  get thickness() {
    return this._thickness;
  }
  set thickness(value) {
    if (value < 0)
      throw new RangeError("Thickness must be a positive value");
    this._thickness = value;
    this._pen = null;
    this._parentRenderer.redraw();
  }
  get color() {
    return this._color;
  }
  set color(value) {
    this._color = value;
    this._pen = null;
    this._parentRenderer.redraw();
  }
  get showGrid() {
    return this._showGrid;
  }
  set showGrid(value) {
    this._showGrid = value;
    this._parentRenderer.redraw();
  }
  get gridColor() {
    return this._gridColor;
  }
  set gridColor(value) {
    this._gridColor = value;
    this._gridPen = null;
    this._parentRenderer.redraw();
  }
  get gridThickness() {
    return this._gridThickness;
  }
  set gridThickness(value) {
    if (value < 0)
      throw new RangeError("Thickness must be a positive value");
    this._gridThickness = value;
    this._gridPen = null;
    this._parentRenderer.redraw();
  }
  get font() {
    return this._font;
  }
  get legend() {
    return this._legend;
  }
};
var StartStopStep = class {
  constructor() {
    this.dataMin = 0;
    this.dataMax = 0;
    this.absMin = 0;
    this.absMax = 0;
    this.step = 0;
    this.start = 0;
    this.stop = 0;
    this.precision = 0;
  }
};
var xAxisPosition = class {
  get relative() {
    return this._isRelative;
  }
  set relative(value) {
    this._isRelative = value;
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value;
  }
  constructor(v, rel, capture) {
    this._isRelative = false;
    this._value = 0;
    this._capture = false;
    this._isRelative = rel;
    this._value = v;
    this._capture = typeof capture == "undefined" ? false : capture;
  }
  clone() {
    return new xAxisPosition(this._value, this._isRelative, this._capture);
  }
  toString() {
    if (this._isRelative) {
      return TimeConverter.secTimeSpanToString(this._value, 0);
    } else {
      let date = TimeConverter.FromUnixTime(this._value);
      let res = date.getFullYear().toString() + "-" + (date.getMonth() + 1).toString() + "-" + date.getDate().toString() + " " + date.getHours().toString() + ":";
      let st = date.getMinutes().toString();
      if (st.length <= 1)
        st = "0" + st;
      res = res + st + ":";
      let s = date.getSeconds();
      let ms = date.getMilliseconds();
      s = s + ms / 1e3;
      if (s < 10)
        res = res + "0";
      if (ms == 0) {
        res = res + s.toString();
      } else {
        res = res + s.toFixed(3);
      }
      return res;
    }
  }
  TryParse(str) {
    if (this._isRelative)
      return TimeConverter.tryParseStringToSecTimeSpan(str);
    return TimeConverter.tryParseStringToAbsDateTime(str);
  }
  get capture() {
    return this._capture;
  }
  set capture(value) {
    this._capture = value;
  }
};
xAxisPosition.DTdisplayformat = "DD/MM/YY hh:mm:ss.ff";
xAxisPosition.TSdisplayformat = "dd.hh:mm:ss.ff";
var YNumberFormatInfo = class {
  constructor() {
    this.NumberDecimalSeparator = ".";
  }
};
var YAxis = class extends GenericAxis {
  constructor(parent, directParent, index) {
    super(parent, directParent);
    this._index = 0;
    this._highlightZero = false;
    this._position = YAxis.HrzPosition.LEFT;
    this.innerWidth = 0;
    this.zoom = 0;
    this.IRLy = 0;
    this._index = index;
    this.nfi = new YNumberFormatInfo();
    this.nfi.NumberDecimalSeparator = ".";
    this.startStopStep = new StartStopStep();
    this.startStopStep.start = 0;
    this.startStopStep.stop = 1;
    this.startStopStep.step = 0.1;
  }
  get index() {
    return this._index;
  }
  lockMinMax() {
    this._min = this.startStopStep.absMin;
    this._max = this.startStopStep.absMax;
    this._parentRenderer.redraw();
  }
  unlockMinMax() {
    this._min = Number.NaN;
    this._max = Number.NaN;
    this._parentRenderer.redraw();
  }
  get highlightZero() {
    return this._highlightZero;
  }
  set highlightZero(value) {
    this._highlightZero = value;
    this._parentRenderer.redraw();
  }
  get position() {
    return this._position;
  }
  set position(value) {
    this._position = value;
    this._parentRenderer.redraw();
  }
  computeStartAndStep(M) {
    let res = new StartStopStep();
    let min = this.min;
    let max = this.max;
    res.step = this.step;
    res.precision = 0;
    if (!MinMaxHandler.isDefined(M)) {
      M = MinMaxHandler.DefaultValue();
      M.Min = 0;
      M.Max = 100;
    }
    if (isNaN(min))
      min = M.Min;
    if (isNaN(max))
      max = M.Max;
    res.absMax = max;
    res.absMin = min;
    if (min == max) {
      min -= 0.5;
      max += 0.5;
    }
    if (min != 0)
      min -= (max - min) * 0.025;
    if (max != 0)
      max += (max - min) * 0.025;
    res.start = min;
    res.stop = max;
    res.dataMin = min;
    res.dataMax = max;
    let Delta = max - min;
    if (isNaN(res.step)) {
      let MagnitudePwr = Math.log10(Delta);
      if (MagnitudePwr - Math.floor(MagnitudePwr) != 0)
        MagnitudePwr = Math.floor(MagnitudePwr) + 1;
      res.precision = MagnitudePwr - 1 >> 0;
      let Magnitude = Math.pow(10, res.precision);
      let C = Delta / Magnitude;
      if (C <= 2) {
        res.step = Magnitude / 5;
        res.precision--;
      } else if (C <= 5) {
        res.step = Magnitude / 2;
        res.precision--;
      } else {
        res.step = Magnitude;
      }
      if (isNaN(this.min)) {
        let c = min / res.step;
        if (c - Math.floor(c) != 0)
          c = c > 0 ? Math.floor(c) + 1 : Math.floor(c) - 1;
        res.start = res.step * c;
      }
    } else {
      let v = res.step.toString();
      let p = v.indexOf(".");
      if (p >= 0) {
        res.precision = -(v.length - p - 1);
      } else {
        res.precision = 0;
      }
    }
    this.startStopStep = res;
    return res;
  }
};
(function(YAxis2) {
  class HrzPositionEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, HrzPosition);
    }
  }
  YAxis2.HrzPositionEnumItem = HrzPositionEnumItem;
  class HrzPosition extends YEnum {
  }
  HrzPosition.LEFT = new HrzPositionEnumItem("LEFT", "Left");
  HrzPosition.RIGHT = new HrzPositionEnumItem("RIGHT", "Right");
  YAxis2.HrzPosition = HrzPosition;
})(YAxis || (YAxis = {}));
var XAxis = class extends GenericAxis {
  get position() {
    return this._position;
  }
  set position(value) {
    this._position = value;
    this._parentRenderer.redraw();
  }
  get markers() {
    return this._markers;
  }
  AddMarker() {
    let m = new Marker(this._parentGraph, this);
    this._markers.push(m);
    this._parentGraph.clearCachedObjects();
    this._parentGraph.redraw();
    return m;
  }
  get initialZoom() {
    return this._initialZoom;
  }
  set initialZoom(value) {
    if (value <= 0)
      throw new RangeError("Zoom must be a positive value");
    this._initialZoom = value;
    this.min = this.min - this._initialZoom * this._initialOffset / 100;
    this.max = this.min + this.initialZoom;
    this._parentRenderer.redraw();
  }
  get initialOffset() {
    return this._initialOffset;
  }
  set initialOffset(value) {
    this._initialOffset = value;
    let p = this._parentGraph.getMostRecentPoint();
    if (isNaN(p.x)) {
      this._min = this._min - this._initialZoom * this._initialOffset / 100;
      this._max = this._min + this._initialZoom;
      this._parentRenderer.redraw();
    } else {
      let zoom = this._max - this._min;
      this._min = p.x - zoom * this._initialOffset / 100;
      this._max = this._min + zoom;
    }
    this._parentRenderer.redraw();
  }
  get labelFormat() {
    return this._format;
  }
  set labelFormat(value) {
    this._format = value;
    this._parentRenderer.redraw();
  }
  constructor(parent, directParent) {
    super(parent, directParent);
    this._position = XAxis.VrtPosition.BOTTOM;
    this._markers = [];
    this._initialZoom = 300;
    this._initialOffset = 0;
    this._format = XAxis.FORMATAUTO;
    this._timeReference = TimeConverter.TimeReference.ABSOLUTE;
    this._zeroTime = 0;
    this._fullSize = 0;
    this.innerHeight = 0;
    this._overflowHandling = XAxis.OverflowHandling.DONOTHING;
    this._parentGraph = parent;
    this._markers = [];
    this.min = TimeConverter.ToUnixTime(TimeConverter.UTCNow());
    this.max = this.min + this.initialZoom;
    this.step = 30;
  }
  get timeReference() {
    return this._timeReference;
  }
  set timeReference(value) {
    this._timeReference = value;
    this._parentRenderer.redraw();
  }
  get zeroTime() {
    return this._zeroTime;
  }
  set zeroTime(value) {
    this._zeroTime = value;
  }
  get fullSize() {
    return this._fullSize;
  }
  set fullSize(value) {
    this._fullSize = value;
  }
  bestFormat(dataTimedelta, viewportTimedelta) {
    return TimeConverter.BestTimeformat(dataTimedelta, viewportTimedelta, this._timeReference);
  }
  get overflowHandling() {
    return this._overflowHandling;
  }
  set overflowHandling(value) {
    this._overflowHandling = value;
  }
};
XAxis.FORMATAUTO = 0;
(function(XAxis2) {
  class VrtPositionEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, VrtPosition);
    }
  }
  XAxis2.VrtPositionEnumItem = VrtPositionEnumItem;
  class VrtPosition extends YEnum {
  }
  VrtPosition.TOP = new VrtPositionEnumItem("TOP", "Top");
  VrtPosition.BOTTOM = new VrtPositionEnumItem("BOTTOM", "Bottom");
  XAxis2.VrtPosition = VrtPosition;
  class OverflowHandlingEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, OverflowHandling);
    }
  }
  XAxis2.OverflowHandlingEnumItem = OverflowHandlingEnumItem;
  class OverflowHandling extends YEnum {
  }
  OverflowHandling.DONOTHING = new OverflowHandlingEnumItem("DONOTHING", "Do nothing");
  OverflowHandling.SCROLL = new OverflowHandlingEnumItem("SCROLL", "Scroll contents");
  OverflowHandling.CONTRACT = new OverflowHandlingEnumItem("CONTRACT", "Squeeze contents");
  XAxis2.OverflowHandling = OverflowHandling;
})(XAxis || (XAxis = {}));
var DataPanel = class extends GenericPanel {
  constructor(parent, directParent) {
    super(parent, directParent);
    this._panelHrzAlign = DataPanel.HorizontalAlign.CENTERED;
    this._panelVrtAlign = DataPanel.VerticalAlign.CENTERED;
    this._horizontalPosition = DataPanel.HorizontalPosition.ABSOLUTEX;
    this._verticalPosition = DataPanel.VerticalPosition.ABSOLUTEY;
    this._AbsoluteXposition = 0;
    this._AbsoluteYposition = 0;
    this._YScaleIndex = 0;
  }
  get panelHrzAlign() {
    return this._panelHrzAlign;
  }
  set panelHrzAlign(value) {
    this._panelHrzAlign = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get panelVrtAlign() {
    return this._panelVrtAlign;
  }
  set panelVrtAlign(value) {
    this._panelVrtAlign = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get horizontalPosition() {
    return this._horizontalPosition;
  }
  set horizontalPosition(value) {
    this._horizontalPosition = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get verticalPosition() {
    return this._verticalPosition;
  }
  set verticalPosition(value) {
    this._verticalPosition = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get AbsoluteXposition() {
    return this._AbsoluteXposition;
  }
  set AbsoluteXposition(value) {
    this._AbsoluteXposition = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get AbsoluteYposition() {
    return this._AbsoluteYposition;
  }
  set AbsoluteYposition(value) {
    this._AbsoluteYposition = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
  get yScaleIndex() {
    return this._YScaleIndex;
  }
  set yScaleIndex(value) {
    this._YScaleIndex = value;
    if (this._enabled)
      this._parentRenderer.redraw();
  }
};
(function(DataPanel2) {
  class HorizontalAlignEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, HorizontalAlign);
    }
  }
  DataPanel2.HorizontalAlignEnumItem = HorizontalAlignEnumItem;
  class HorizontalAlign extends YEnum {
  }
  HorizontalAlign.LEFTOF = new HorizontalAlignEnumItem("LEFTOF", "Left");
  HorizontalAlign.CENTERED = new HorizontalAlignEnumItem("CENTERED", "Center");
  HorizontalAlign.RIGHTOF = new HorizontalAlignEnumItem("RIGHTOF", "Right");
  DataPanel2.HorizontalAlign = HorizontalAlign;
  class VerticalAlignEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, VerticalAlign);
    }
  }
  DataPanel2.VerticalAlignEnumItem = VerticalAlignEnumItem;
  class VerticalAlign extends YEnum {
  }
  VerticalAlign.ABOVE = new VerticalAlignEnumItem("ABOVE", "Top");
  VerticalAlign.CENTERED = new VerticalAlignEnumItem("CENTERED", "Center");
  VerticalAlign.BELOW = new VerticalAlignEnumItem("BELOW", "Bottom");
  DataPanel2.VerticalAlign = VerticalAlign;
  class HorizontalPositionEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, HorizontalPosition);
    }
  }
  DataPanel2.HorizontalPositionEnumItem = HorizontalPositionEnumItem;
  class HorizontalPosition extends YEnum {
  }
  HorizontalPosition.LEFTBORDER = new HorizontalPositionEnumItem("LEFTBORDER", "Left border");
  HorizontalPosition.ABSOLUTEX = new HorizontalPositionEnumItem("ABSOLUTEX", "Absolute X position");
  HorizontalPosition.RIGHTBORDER = new HorizontalPositionEnumItem("RIGHTBORDER", "Right borde");
  DataPanel2.HorizontalPosition = HorizontalPosition;
  class VerticalPositionEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, VerticalPosition);
    }
  }
  DataPanel2.VerticalPositionEnumItem = VerticalPositionEnumItem;
  class VerticalPosition extends YEnum {
  }
  VerticalPosition.TOPBORDER = new VerticalPositionEnumItem("TOPBORDER", "Top border");
  VerticalPosition.ABSOLUTEY = new VerticalPositionEnumItem("ABSOLUTEY", "Absolute Y position");
  VerticalPosition.BOTTOMBORDER = new VerticalPositionEnumItem("BOTTOMBORDER", "Bottom border");
  DataPanel2.VerticalPosition = VerticalPosition;
})(DataPanel || (DataPanel = {}));
var YCursor = class {
  constructor(pngImageData) {
  }
  get handle() {
    return "crosshair";
  }
};
var YTimeSpan = class {
  constructor(value) {
    this._value = 0;
    this._value = value;
  }
  toString(format) {
    let res = "";
    let v = Math.abs(this._value / 1e3);
    let dec = Math.floor(v);
    let frac = Math.round(1e3 * (v - Math.floor(v)));
    if (format & YDate.ms1) {
      let ms = "00" + frac.toString();
      res = "." + ms.substring(ms.length - 3).substring(0, 1);
    } else if (format & YDate.ms01) {
      let ms = "00" + frac.toString();
      res = "." + ms.substring(ms.length - 3).substring(0, 2);
    } else if (format & YDate.ms001) {
      let ms = "00" + frac.toString();
      res = "." + ms.substring(ms.length - 3).substring(0, 3);
    }
    if (format & YDate.s) {
      let sec = dec % 60;
      let s = "0" + sec.toString();
      res = s.substring(s.length - 2) + res + "s";
    }
    dec = Math.floor(dec / 60);
    if (format & YDate.m) {
      let min = dec % 60;
      let s = "0" + min.toString();
      res = s.substring(s.length - 2) + "m" + res;
    }
    dec = Math.floor(dec / 60);
    if (format & YDate.h) {
      let hrs = dec % 24;
      let s = "0" + hrs.toString();
      res = s.substring(s.length - 2) + "h" + res;
    }
    dec = Math.floor(dec / 24);
    if (format & YDate.D) {
      let s = dec.toString();
      res = s.substring(s.length - 2) + "d" + res;
    }
    return res;
  }
};
YTimeSpan.TicksPerSecond = 1e3;
var YGraph = class extends YDataRenderer {
  get legendPanel() {
    return this._legendPanel;
  }
  get dataTracker() {
    return this._dataTracker;
  }
  get borderColor() {
    return this._borderColor;
  }
  set borderColor(value) {
    this._borderColor = value;
    this._borderPen = null;
    this.redraw();
  }
  get borderThickness() {
    return this._borderThickness;
  }
  set borderThickness(value) {
    if (value < 0)
      throw new RangeError("thickness must be a positive value");
    this._borderThickness = value;
    this._borderPen = null;
    this.redraw();
  }
  static get verticalDragZoomEnabled() {
    return YGraph._defaultVerticalDragZoomEnabled;
  }
  static set verticalDragZoomEnabled(value) {
    YGraph._defaultVerticalDragZoomEnabled = value;
  }
  static createCaptureCursor() {
    if (YGraph.captureCursor != null)
      return;
    let base64png = "iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAALHRFWHRDcmVhdGlvbiBUaW1lAFRodSAyMCBBdWcgMjAyMCAxMjoxNTo1MCArMDEwMP38NhoAAAAHdElNRQfkCBQOJAvCrm0ZAAAACXBIWXMAAFxGAABcRgEUlENBAAAABGdBTUEAALGPC / xhBQAAAmVJREFUeNrtVrFuFDEQHd9eBImAIBFoAgVC0NJQUFDwL / QgRXzAfUz + Iy0pQwsIJAhCQMQBUS5c2DXv7T5fzN5qs / Fxdw0jPY3ttT3jt54ZmyXIYDDoQXnodWBV / SRJXZhJbwCXov65pZ + 4zklfBsZRf2EMxOuTjc / igIu0s0UygAvnonWZ0NP4fB2QkQz6yHvP / i76V4E1jZ / bic4LIuMnND7ZwDl + u4 / me + AnkKPvu + 7rFMNZBzZ64eRTm5w6sQ8cAcUZexVytOCpOnv7j + QdDD + CHgKjMg80nWpeQrYgd4A3wHjWPJAqN4BVoLcsB1ZMd25ZDkzkvwNLd6AMQ4XGIuXElKz6SAo3rYpLhsZKyyJmwu2WTLiF5g / g2NozIY1 / BkacRwaYkZgUPlr7L2EdeAhjLxpqwTOr0vAHOZG37FPIOO3mfXXG1qEWAGvM + TC6Rydk / KmMv7bmWlD / v95qtaCThGpo1TPsFvp7wBO0v4nBqWoYvR0yOeLFThHmdH4TcgGQy8i + hkn5V / WbSjGr7e9oD96372LJB1o7izbPtYHpPw7V / 8u4yvzFkvPTO3MXuMbx8JRPij8svgAcAw / EwCe0f8XGxZYFB6JQZzl + rHWj1Gf5WZLVTj5py5HbVoXjeF4OuMhYnQHKulW / x6U64CPtbfpVxQu7CX0PeicMov3cKup5EZmw / KwMFNb8pMtl5G3MhIyHkOX3PPUSMmXzOX7Fqsw35Gu5NidEwXWr / jnnD + XUFzLARJRaDXnCQ53o0BpSLzcXzQfAK + Cl9EEwXrKTyr1OWGa3sFnLvPDsn6Tg8P0PrBcSMR2NtfsAAAAASUVORK5CYII =";
    try {
      YGraph.captureCursor = new YCursor(atob(base64png));
    } catch (Exception) {
      console.log("Cannot create custom cursor");
    }
  }
  get dataPanels() {
    return this._dataPanels;
  }
  addDataPanel() {
    let p = new DataPanel(this, this);
    this._dataPanels.push(p);
    return p;
  }
  setMarkerCaptureCallbacks(start, stop) {
    this._markerCaptureStartedCallback = start;
    this._markerCaptureStoppedCallback = stop;
  }
  startMarkerCapture(m) {
    if (this._markerCaptureStartedCallback != null)
      this._markerCaptureStartedCallback(m);
    this.markerCapture = m;
    this.UIContainer.focus();
  }
  constructor(ChartContainer, logFunction) {
    super(ChartContainer, logFunction);
    this._markerCaptureStartedCallback = null;
    this._markerCaptureStoppedCallback = null;
    this.lastPointCount = -1;
    this.lastTopMargin = -1;
    this.lastBottomMargin = -1;
    this.navigatorCache = null;
    this.markerCapture = null;
    this._borderPen = null;
    this._borderColor = YColor.LightGray;
    this._borderThickness = 1;
    this._touchStartfct = null;
    this._touchMovefct = null;
    this._touchEndfct = null;
    this._mouseDownfct = null;
    this._mouseMovefct = null;
    this._mouseWheelfct = null;
    this._mouseKeyDownfct = null;
    this.mainViewPort = new ViewPortSettings();
    this._timeRange = null;
    this._bgBrush = null;
    this._bgColor1 = YColor.FromArgb(255, 200, 200, 200);
    this._bgColor2 = YColor.FromArgb(255, 255, 255, 255);
    this._touchStartPinchDistance = -1;
    this._touchStartPinchCenter = new Point(0, 0);
    this._touchStartPinchZoom = 1;
    this._touchStartPinchIRLx = 0;
    this._touchStartPinchRange = 0;
    this.dataTrackerRefreshtimeout = null;
    YGraph.createCaptureCursor();
    this._xAxis = new XAxis(this, this);
    this._yAxes = [];
    this._series = [];
    this._dataPanels = [];
    this._navigator = new Navigator(this, this);
    this._legendPanel = new LegendPanel(this, this);
    this._dataTracker = new DataTracker(this, this);
    this._touchStartfct = (e) => {
      this.TouchStart(this.UIContainer, e);
    };
    this._touchMovefct = (e) => {
      this.TouchMove(this.UIContainer, e);
    };
    this._touchEndfct = (e) => {
      this.TouchEnd(this.UIContainer, e);
    };
    this._mouseDownfct = (e) => {
      this.MouseDown(this.UIContainer, e);
    };
    this._mouseMovefct = (e) => {
      this.MouseMove(this.UIContainer, e);
    };
    this._mouseWheelfct = (e) => {
      this.mouseWheelEvent(this.UIContainer, e);
    };
    this._mouseKeyDownfct = (e) => {
      this.KeyDown(this.UIContainer, e);
    };
    this.UIContainer.addEventListener("touchstart", this._touchStartfct);
    this.UIContainer.addEventListener("touchmove", this._touchMovefct);
    this.UIContainer.addEventListener("touchend", this._touchEndfct);
    this.UIContainer.addEventListener("mousedown", this._mouseDownfct);
    this.UIContainer.addEventListener("mousemove", this._mouseMovefct);
    this.UIContainer.addEventListener("wheel", this._mouseWheelfct);
    this.UIContainer.addEventListener("keydown", this._mouseKeyDownfct);
    this._timeRange = MinMaxHandler.DefaultValue();
    let originalContainerWidth = ChartContainer.width;
    let originalContainerHeight = ChartContainer.height;
    let originalFormWidth = ChartContainer.width;
    let originalFormHeight = ChartContainer.height;
  }
  destroy() {
    if (this._touchStartfct != null)
      this.UIContainer.removeEventListener("touchstart", this._touchStartfct);
    if (this._touchMovefct != null)
      this.UIContainer.removeEventListener("touchstart", this._touchMovefct);
    if (this._touchEndfct != null)
      this.UIContainer.removeEventListener("touchstart", this._touchEndfct);
    if (this._mouseDownfct != null)
      this.UIContainer.removeEventListener("mousedown", this._mouseDownfct);
    if (this._mouseMovefct != null)
      this.UIContainer.removeEventListener("mousemove", this._mouseMovefct);
    if (this._mouseWheelfct != null)
      this.UIContainer.removeEventListener("wheel", this._mouseWheelfct);
    if (this._mouseKeyDownfct != null)
      this.UIContainer.removeEventListener("keydown", this._mouseKeyDownfct);
    super.destroy();
    Object.entries(this).forEach((pair) => {
      Reflect.set(this, pair[0], null);
    });
  }
  getMostRecentPoint() {
    let res = new pointXY(NaN, NaN);
    for (let i = 0; i < this._series.length; i++)
      if (!this.series[i].disabled) {
        let p = this.series[i].getlastPoint();
        if (!isNaN(p.x)) {
          if (isNaN(res.x))
            res = p;
          else if (p.x > res.x)
            res = p;
        }
      }
    return res;
  }
  adjustGlobalTimeRange(x) {
    let max = this._timeRange.Max;
    this._timeRange = MinMaxHandler.CombineWithNumber(this._timeRange, x);
    if (isNaN(max))
      return;
    let ofset = x - max;
    if (ofset > 0) {
      switch (this._xAxis.overflowHandling) {
        case XAxis.OverflowHandling.SCROLL:
          if (max > this._xAxis.min + (this._xAxis.max - this._xAxis.min) * 0.85 && max <= this._xAxis.max) {
            this.DisableRedraw();
            this._xAxis.set_minMax(this._xAxis.min + ofset, this._xAxis.max + ofset);
            this.AllowRedraw();
          }
          break;
        case XAxis.OverflowHandling.CONTRACT:
          if (max > this._xAxis.min + (this._xAxis.max - this._xAxis.min) * 0.95 && max <= this._xAxis.max) {
            this.DisableRedraw();
            this._xAxis.max += ofset;
            this.AllowRedraw();
          }
          break;
      }
    }
  }
  get bgColor1() {
    return this._bgColor1;
  }
  set bgColor1(value) {
    this._bgColor1 = value;
    this._bgBrush = null;
    this.redraw();
  }
  get bgColor2() {
    return this._bgColor2;
  }
  set bgColor2(value) {
    this._bgColor2 = value;
    this._bgBrush = null;
    this.redraw();
  }
  get xAxis() {
    return this._xAxis;
  }
  get navigator() {
    return this._navigator;
  }
  get yAxes() {
    return this._yAxes;
  }
  get series() {
    return this._series;
  }
  addYAxis() {
    let s = new YAxis(this, this, this._yAxes.length);
    this._yAxes.push(s);
    this.redraw();
    return s;
  }
  addSerie() {
    let s = new DataSerie(this);
    this._series.push(s);
    this.redraw();
    return s;
  }
  clearCachedObjects() {
    this._bgBrush = null;
    this.navigatorCache = null;
  }
  TouchStart(sender, e) {
    if (e.touches.length == 1) {
      this.HandleMouseDown(sender, e.touches[0].pageX, e.touches[0].pageY);
    } else if (e.touches.length == 2) {
      e.preventDefault();
      this.HandleEndOfMouseCapture();
      this._touchStartPinchDistance = Math.sqrt(Math.pow(e.touches[1].pageX - e.touches[0].pageX, 2) + Math.pow(e.touches[1].pageY - e.touches[0].pageY, 2));
      this._touchStartPinchCenter = new Point(e.touches[1].pageX + e.touches[0].pageX >> 2, e.touches[1].pageY + e.touches[0].pageY >> 2);
      this._touchStartPinchZoom = this.mainViewPort.zoomx;
      this._touchStartPinchIRLx = this.mainViewPort.IRLx;
      this._touchStartPinchRange = this._xAxis.max - this._xAxis.min;
    }
  }
  MouseDown(sender, e) {
    if (e.buttons == 2 && this.markerCapture != null) {
      this.markerCapture = null;
      if (this._markerCaptureStoppedCallback != null)
        this._markerCaptureStoppedCallback(null);
    }
    if (e.buttons != 1)
      return;
    this.HandleMouseDown(sender, e.pageX, e.pageY);
  }
  HandleMouseDown(sender, pageX, pageY) {
    let p = this.Scr2ElmMatrix.multiplyByV(Vector3.FromXYCoord(pageX, pageY)).toPoint();
    let eX = p.X;
    let eY = p.Y;
    if (eX >= this.mainViewPort.Lmargin && eX <= this.mainViewPort.Width - this.mainViewPort.Rmargin && eY >= this.mainViewPort.Tmargin && eY <= this.mainViewPort.Height - this.mainViewPort.Bmargin) {
      if (this.markerCapture != null) {
        let p22 = YGraph.ViewPortPointToIRL(this.mainViewPort, new Point(eX, eY));
        this.markerCapture.setCapturedPosition(p22.x, this.xAxis);
        if (this._markerCaptureStoppedCallback != null)
          this._markerCaptureStoppedCallback(this.markerCapture);
        this.markerCapture = null;
        return;
      }
      let p2 = YGraph.ViewPortPointToIRL(this.mainViewPort, new Point(eX, eY));
      this.mainViewPort.OriginalXAxisMin = this.xAxis.min;
      this.mainViewPort.OriginalXAxisMax = this.xAxis.max;
      this.mainViewPort.OriginalIRLx = this.mainViewPort.IRLx;
      this.mainViewPort.OriginalLmargin = this.mainViewPort.Lmargin;
      this.mainViewPort.OriginalZoomx = this.mainViewPort.zoomx;
      this.mainViewPort.CaptureStartY = eY;
      this.mainViewPort.IRLCaptureStartX = p2.x;
      this.mainViewPort.Capture = true;
    } else if (eX >= this._navigator.viewport.Lmargin && eX <= this._navigator.viewport.Width - this._navigator.viewport.Rmargin && eY >= this._navigator.viewport.Lmargin && eY <= this._navigator.viewport.Height - this._navigator.viewport.Bmargin) {
      let p2 = YGraph.ViewPortPointToIRL(this._navigator.viewport, new Point(eX, eY));
      let p22 = YGraph.ViewPortPointToIRL(this.mainViewPort, new Point(this.mainViewPort.Lmargin, 0));
      let p3 = YGraph.ViewPortPointToIRL(this.mainViewPort, new Point(this.mainViewPort.Width - this.mainViewPort.Rmargin, 0));
      if (p2.x >= p22.x && p2.x <= p3.x) {
        this._navigator.startCapture(p2, this._xAxis.min, this._xAxis.max);
      } else {
        this.DisableRedraw();
        let min = p2.x - (p3.x - p22.x) / 2;
        let max = min + (p3.x - p22.x);
        this._xAxis.set_minMax(min, max);
        this.AllowRedraw();
        this.Draw(0);
      }
    }
  }
  TouchMove(sender, e) {
    if (e.touches.length == 1) {
      e.preventDefault();
      this.HandleMouseMove(sender, e.touches[0].pageX, e.touches[0].pageY);
    } else if (e.touches.length == 2) {
      e.preventDefault();
      let newdistance = Math.sqrt(Math.pow(e.touches[1].pageX - e.touches[0].pageX, 2) + Math.pow(e.touches[1].pageY - e.touches[0].pageY, 2));
      let ZoomFactor = newdistance / this._touchStartPinchDistance;
      let NextZoomX = this._touchStartPinchZoom * ZoomFactor;
      if (NextZoomX > this.mainViewPort.zoomx && NextZoomX > 1e3)
        return;
      let currentRange = this._xAxis.max - this._xAxis.min;
      this.mainViewPort.IRLx = this._touchStartPinchIRLx + (this._touchStartPinchCenter.X - this.mainViewPort.Lmargin) / this._touchStartPinchZoom - (this._touchStartPinchCenter.X - this.mainViewPort.Lmargin) / NextZoomX;
      this._xAxis.set_minMax(this.mainViewPort.IRLx, this.mainViewPort.IRLx + this._touchStartPinchRange / ZoomFactor);
      this.mainViewPort.zoomx = NextZoomX;
      this.redraw();
    }
  }
  TouchEnd(sender, e) {
    this.HandleEndOfMouseCapture();
  }
  MouseMove(sender, e) {
    if (e.buttons != 1 && (this.mainViewPort.Capture || this._navigator.Capture))
      this.HandleEndOfMouseCapture();
    this.HandleMouseMove(sender, e.pageX, e.pageY);
    if (this.dataTracker.enabled) {
      if (this.dataTrackerRefreshtimeout != null)
        clearTimeout(this.dataTrackerRefreshtimeout);
      this.dataTrackerRefreshtimeout = setTimeout(() => {
        this.redraw();
      }, 100);
    }
  }
  HandleEndOfMouseCapture() {
    this.mainViewPort.Capture = false;
    this._navigator.stopCapture();
    if (this._dataTracker.enabled)
      this.redraw();
  }
  HandleMouseMove(sender, pageX, pageY) {
    let p = this.Scr2ElmMatrix.multiplyByV(Vector3.FromXYCoord(pageX, pageY)).toPoint();
    let eX = p.X;
    let eY = p.Y;
    if (this.markerCapture != null) {
      if (eX > this.mainViewPort.Lmargin && eX < this.mainViewPort.Width - this.mainViewPort.Rmargin && eY > this.mainViewPort.Tmargin && eY < this.mainViewPort.Height - this.mainViewPort.Bmargin) {
        if (this.UIContainer.style.cursor != YGraph.captureCursor.handle && this.UIContainer.style.cursor != "crosshair") {
          this.UIContainer.style.cursor = YGraph.captureCursor != null ? YGraph.captureCursor.handle : "crosshair";
        }
      } else if (this.UIContainer.style.cursor != "default")
        this.UIContainer.style.cursor = "default";
    } else if (this.UIContainer.style.cursor != "default")
      this.UIContainer.style.cursor = "default";
    if (this.mainViewPort.Capture) {
      let x1 = this.mainViewPort.OriginalIRLx + (eX - this.mainViewPort.OriginalLmargin) / this.mainViewPort.OriginalZoomx;
      let deltaX = x1 - this.mainViewPort.IRLCaptureStartX;
      let deltaY = eY - this.mainViewPort.CaptureStartY;
      this.DisableRedraw();
      let halfAxisDelta = (this.mainViewPort.OriginalXAxisMax - this.mainViewPort.OriginalXAxisMin) / 2;
      let Axismiddle = (this.mainViewPort.OriginalXAxisMax + this.mainViewPort.OriginalXAxisMin) / 2;
      let deltaCoef = YGraph._defaultVerticalDragZoomEnabled && Math.abs(deltaY) > 10 ? Math.pow(1.01, deltaY) : 1;
      this._xAxis.set_minMax(Axismiddle - halfAxisDelta * deltaCoef - deltaX, Axismiddle + halfAxisDelta * deltaCoef - deltaX);
      this.AllowRedraw();
      this.redraw();
      return;
    }
    if (this._navigator.viewport.Capture) {
      let x1 = this._navigator.viewport.OriginalIRLx + (eX - this._navigator.viewport.OriginalLmargin) / this._navigator.viewport.OriginalZoomx;
      let delta = x1 - this._navigator.viewport.IRLCaptureStartX;
      this.DisableRedraw();
      this._xAxis.set_minMax(this._navigator.viewport.OriginalXAxisMin + delta, this._navigator.viewport.OriginalXAxisMax + delta);
      this.AllowRedraw();
      this.redraw();
      return;
    }
  }
  cross(p) {
  }
  static IRLPointToViewPort(viewport, p, IRLy, zoomy) {
    if (IRLy === void 0) {
      let xx2 = viewport.Lmargin + Math.round((p.x - viewport.IRLx) * viewport.zoomx);
      let yy2 = viewport.Height - viewport.Bmargin - Math.round((p.y - viewport.IRLy) * viewport.zoomy);
      return new Point(xx2 >> 0, yy2 >> 0);
    }
    let xx = viewport.Lmargin + Math.round((p.x - viewport.IRLx) * viewport.zoomx);
    let yy = viewport.Height - viewport.Bmargin - Math.round((p.y - IRLy) * zoomy);
    return new Point(xx >> 0, yy >> 0);
  }
  static IRLPointSummaryToViewPort(viewport, p, IRLy, zoomy) {
    if (IRLy === void 0) {
      let x12 = viewport.Lmargin + Math.round((p.x1 - viewport.IRLx) * viewport.zoomx);
      let ymin2 = viewport.Height - viewport.Bmargin - Math.round((p.ymin - viewport.IRLy) * viewport.zoomy);
      let x22 = viewport.Lmargin + Math.round((p.x2 - viewport.IRLx) * viewport.zoomx);
      let ymax2 = viewport.Height - viewport.Bmargin - Math.round((p.ymax - viewport.IRLy) * viewport.zoomy);
      return new minMaxPoint(x12, ymin2, x22, ymax2);
    }
    let x1 = viewport.Lmargin + Math.round((p.x1 - viewport.IRLx) * viewport.zoomx);
    let ymin = viewport.Height - viewport.Bmargin - Math.round((p.ymin - IRLy) * zoomy);
    let x2 = viewport.Lmargin + Math.round((p.x2 - viewport.IRLx) * viewport.zoomx);
    let ymax = viewport.Height - viewport.Bmargin - Math.round((p.ymax - IRLy) * zoomy);
    return new minMaxPoint(x1, ymin, x2, ymax);
  }
  static ViewPortPointToIRL(viewport, p, IRLy, zoomy) {
    if (IRLy === void 0) {
      return new pointXY(viewport.IRLx + (p.X - viewport.Lmargin) / viewport.zoomx, viewport.IRLy + (+viewport.Height - p.Y - viewport.Bmargin) / viewport.zoomy);
    }
    return new pointXY(viewport.IRLx + (p.X - viewport.Lmargin) / viewport.zoomx, IRLy + (+viewport.Height - p.Y - viewport.Bmargin) / zoomy);
  }
  static FindMinMax(start, end, data, count) {
    let res = MinMaxHandler.DefaultValue();
    if (data[0].x > end)
      return res;
    if (data[count - 1].x < start)
      return res;
    let N1 = 0;
    let N2 = 0;
    let First = 0;
    if (data[0].x < start) {
      N1 = 0;
      N2 = count - 1;
      while (N2 - N1 > 1) {
        let N = N1 + N2 >> 1;
        if (data[N].x > start)
          N2 = N;
        else
          N1 = N;
      }
      First = N1 - 1;
      if (First < 0)
        First = 0;
    }
    let Last = count - 1;
    if (data[Last] === void 0) {
      debugger;
    }
    if (data[Last].x > end) {
      N1 = 0;
      N2 = count - 1;
      while (N2 - N1 > 1) {
        let N = N1 + N2 >> 1;
        if (data[N].x < end)
          N1 = N;
        else
          N2 = N;
      }
      Last = N2 + 1;
      if (Last > count - 1)
        Last = count - 1;
    }
    res.Min = data[First].y;
    res.Max = data[First].y;
    for (let i = First + 1; i <= Last; i++) {
      if (data[i].y < res.Min)
        res.Min = data[i].y;
      if (data[i].y > res.Max)
        res.Max = data[i].y;
    }
    return res;
  }
  resetlegendPens() {
    for (let i = 0; i < this._series.length; i++) {
      this._series[i].resetlegendPen();
    }
  }
  drawLegendPanel(g, viewPortWidth, viewPortHeight, mainViewPort) {
    let verticalRatio = 1.25;
    if (!this._legendPanel.enabled)
      return;
    let legendWidths = new Array(this._series.length);
    let legendHeight = new Array(this._series.length);
    let ofsetx = new Array(this._series.length);
    let ofsety = new Array(this._series.length);
    let legends = new Array(this._series.length);
    let totalHeight = 0;
    let totalWidth = 0;
    let maxWidth = 0;
    let maxHeight = 0;
    g.TextRenderingHint = YTextRenderingHint.SingleBitPerPixelGridFit;
    g.SetClip(new YRectangle(0, 0, viewPortWidth, viewPortHeight));
    for (let i = 0; i < this._series.length; i++) {
      if (this._series[i].legend != "")
        legends[i] = this._series[i].legend;
      else
        legends[i] = "Series " + (i + 1).toString();
    }
    if (this._legendPanel.position == LegendPanel.Position.TOP || this._legendPanel.position == LegendPanel.Position.BOTTOM) {
      let availableWidth = viewPortWidth - 2 * this._legendPanel.padding + this._legendPanel.borderthickness;
      if (this._legendPanel.overlap)
        availableWidth = availableWidth - mainViewPort.Lmargin - mainViewPort.Rmargin;
      totalHeight = 0;
      let xx = 0;
      let yy = 0;
      for (let i = 0; i < this._series.length; i++) {
        if (this._series[i].segments.length > 0 && this._series[i].visible && !this._series[i].disabled) {
          let ssize = g.MeasureString(legends[i], this._legendPanel.font, 1e5);
          legendHeight[i] = ssize.height + 1;
          let ww = ssize.width + 20;
          if (xx == 0)
            totalHeight += ssize.height;
          if (availableWidth - xx < ww) {
            if (xx == 0) {
              ofsetx[i] = xx;
              ofsety[i] = yy;
              yy += ssize.height;
              if (maxWidth < ww)
                maxWidth = ww;
            } else {
              yy += ssize.height;
              ofsetx[i] = 0;
              ofsety[i] = yy;
              xx = ww;
              totalHeight += ssize.height;
              if (maxWidth < xx)
                maxWidth = xx;
            }
          } else {
            ofsetx[i] = xx;
            ofsety[i] = yy;
            xx += ww;
            if (maxWidth < xx)
              maxWidth = xx;
          }
        }
      }
      if (totalWidth > availableWidth) {
        totalWidth = availableWidth;
      }
    } else {
      let ty = 0;
      for (let i = 0; i < this._series.length; i++) {
        if (this._series[i].segments.length > 0 && this._series[i].visible && !this._series[i].disabled) {
          let ssize = g.MeasureString(legends[i], this._legendPanel.font, 1e5);
          legendWidths[i] = ssize.width + 1;
          if (maxWidth < legendWidths[i] + 20)
            maxWidth = legendWidths[i] + 20;
          legendHeight[i] = ssize.height + 1;
          if (maxHeight < legendHeight[i])
            maxHeight = legendHeight[i];
          ofsetx[i] = 0;
          ofsety[i] = ty;
          ty += ssize.height * verticalRatio;
          totalHeight += i == 0 ? ssize.height : ssize.height * verticalRatio;
        }
      }
    }
    let w = maxWidth + 2 * this._legendPanel.padding + this._legendPanel.borderthickness;
    let h = totalHeight + 2 * this._legendPanel.padding + this._legendPanel.borderthickness;
    let x = 0;
    let y = 0;
    switch (this._legendPanel.position) {
      case LegendPanel.Position.LEFT:
        x = this._legendPanel.horizontalMargin;
        if (!this._legendPanel.overlap) {
          mainViewPort.Lmargin += w + 2 * this.legendPanel.horizontalMargin + this.legendPanel.borderthickness >> 0;
          y = (viewPortHeight - h) / 2;
        } else {
          x += mainViewPort.Lmargin;
          y = mainViewPort.Tmargin + (viewPortHeight - mainViewPort.Tmargin - mainViewPort.Bmargin - h) / 2;
        }
        break;
      case LegendPanel.Position.TOPLEFT:
        x = this._legendPanel.horizontalMargin;
        y = this._legendPanel.verticalMargin;
        if (!this._legendPanel.overlap) {
          mainViewPort.Lmargin += w + 2 * this.legendPanel.horizontalMargin + this.legendPanel.borderthickness >> 0;
        } else {
          x += mainViewPort.Lmargin;
          y += mainViewPort.Tmargin;
        }
        break;
      case LegendPanel.Position.TOP:
        if (!this._legendPanel.overlap) {
          x = (viewPortWidth - w) / 2 - this._legendPanel.horizontalMargin - this._legendPanel.borderthickness;
          y = this._legendPanel.verticalMargin + this._legendPanel.borderthickness;
          mainViewPort.Tmargin += totalHeight + this._legendPanel.verticalMargin + 2 * this._legendPanel.verticalMargin + this._legendPanel.borderthickness >> 0;
        } else {
          x = mainViewPort.Lmargin + (viewPortWidth - mainViewPort.Lmargin - mainViewPort.Rmargin - w) / 2 - this._legendPanel.horizontalMargin - this._legendPanel.borderthickness;
          y = mainViewPort.Tmargin + this._legendPanel.verticalMargin - this._legendPanel.borderthickness;
        }
        break;
      case LegendPanel.Position.TOPRIGHT:
        x = viewPortWidth - this._legendPanel.horizontalMargin - w;
        y = this._legendPanel.verticalMargin;
        if (!this._legendPanel.overlap) {
          mainViewPort.Rmargin += w + 2 * this._legendPanel.horizontalMargin + this._legendPanel.borderthickness >> 0;
        } else {
          x -= mainViewPort.Rmargin;
          y += mainViewPort.Tmargin;
        }
        break;
      case LegendPanel.Position.RIGHT:
        x = viewPortWidth - this._legendPanel.horizontalMargin - w;
        if (!this._legendPanel.overlap) {
          mainViewPort.Rmargin += w + 2 * this._legendPanel.horizontalMargin + this._legendPanel.borderthickness >> 0;
          y = (viewPortHeight - h) / 2;
        } else {
          x -= mainViewPort.Rmargin;
          y = mainViewPort.Tmargin + (viewPortHeight - mainViewPort.Tmargin - mainViewPort.Bmargin - h) / 2;
        }
        break;
      case LegendPanel.Position.BOTTOMRIGHT:
        x = viewPortWidth - this._legendPanel.horizontalMargin - w;
        if (!this._legendPanel.overlap) {
          mainViewPort.Rmargin += w + 2 * this._legendPanel.horizontalMargin + this._legendPanel.borderthickness >> 0;
          y = viewPortHeight - this._legendPanel.verticalMargin - h;
        } else {
          x -= mainViewPort.Rmargin;
          y = viewPortHeight - mainViewPort.Bmargin - h - this._legendPanel.verticalMargin;
        }
        break;
      case LegendPanel.Position.BOTTOM:
        if (!this._legendPanel.overlap) {
          x = (viewPortWidth - w) / 2 - this._legendPanel.horizontalMargin - this._legendPanel.borderthickness;
          y = viewPortHeight - this._legendPanel.verticalMargin - 2 * this._legendPanel.padding - this._legendPanel.borderthickness - totalHeight;
          mainViewPort.Bmargin += totalHeight + 2 * this._legendPanel.padding + 2 * this._legendPanel.verticalMargin + this._legendPanel.borderthickness;
        } else {
          x = mainViewPort.Lmargin + (viewPortWidth - mainViewPort.Lmargin - mainViewPort.Rmargin - w) / 2 - this._legendPanel.horizontalMargin - this._legendPanel.borderthickness;
          y = viewPortHeight - mainViewPort.Bmargin - totalHeight - 2 * this._legendPanel.padding - 2 * this._legendPanel.verticalMargin - this._legendPanel.borderthickness;
        }
        break;
      case LegendPanel.Position.BOTTOMLEFT:
        x = this._legendPanel.horizontalMargin;
        y = this._legendPanel.verticalMargin;
        if (!this._legendPanel.overlap) {
          mainViewPort.Lmargin += w + 2 * this._legendPanel.horizontalMargin + this._legendPanel.borderthickness;
          y = viewPortHeight - this._legendPanel.verticalMargin - h;
        } else {
          x += mainViewPort.Lmargin;
          y = viewPortHeight - mainViewPort.Bmargin - h - this._legendPanel.verticalMargin;
        }
        break;
    }
    let rect = new YRectangle(x >> 0, y >> 0, w >> 0, h >> 0);
    g.FillRectangle(this._legendPanel.bgBrush, rect);
    g.DrawRectangle(this._legendPanel.pen, rect);
    g.TextRenderingHint = YTextRenderingHint.AntiAlias;
    for (let i = 0; i < this._series.length; i++) {
      if (this._series[i].segments.length > 0 && this._series[i].visible && !this._series[i].disabled) {
        g.DrawStringXY(legends[i], this._legendPanel.font, this._legendPanel.font.brush, x + ofsetx[i] + 20 + this._legendPanel.padding >> 0, y + ofsety[i] + this._legendPanel.padding >> 0);
        let px = x + ofsetx[i] + this._legendPanel.borderthickness / 2 + this._legendPanel.padding + 6 >> 0;
        let py = y + ofsety[i] + this._legendPanel.padding + legendHeight[i] / 2 >> 0;
        g.DrawLine(this._series[i].legendPen, new PointF(px, py), new PointF(px + 12, py));
      }
    }
  }
  static DoSegmentRendering(w, g, p, data, count, xTimeStart, xTimeEnd) {
    if (data[0].x > xTimeEnd || data[count - 1].x < xTimeStart)
      return 0;
    let isSVG = g instanceof YGraphicsSVG;
    let N1 = 0;
    let N2 = 0;
    let First = 0;
    if (data[0].x < xTimeStart) {
      N1 = 0;
      N2 = count - 1;
      while (N2 - N1 > 1) {
        let N = N1 + N2 >> 1;
        if (data[N].x > xTimeStart)
          N2 = N;
        else
          N1 = N;
      }
      First = N1 - 1;
      if (First < 0)
        First = 0;
    }
    let Last = count - 1;
    if (data[Last].x > xTimeEnd) {
      N1 = 0;
      N2 = count - 1;
      while (N2 - N1 > 1) {
        let N = N1 + N2 >> 1;
        if (data[N].x < xTimeEnd)
          N1 = N;
        else
          N2 = N;
      }
      Last = N2 + 1;
      if (Last > count - 1)
        Last = count - 1;
    }
    if (Last - First > 2 * w.Width - w.Lmargin - w.Rmargin) {
      let ToDraw = new Array(3 * (Last - First + 1));
      let Current = YGraph.IRLPointToViewPort(w, data[First]);
      let New;
      let i = First + 1;
      let n = 0;
      let max;
      let min;
      let limit;
      while (i < Last) {
        ToDraw[n++] = new PointF(Current.X, Current.Y);
        min = data[i].y;
        max = min;
        limit = YGraph.ViewPortPointToIRL(w, new Point(Current.X + 1, Current.Y + 1)).x;
        do {
          if (data[i].y > max)
            max = data[i].y;
          if (data[i].y < min)
            min = data[i].y;
          i++;
        } while (i < Last && data[i].x < limit);
        let p1 = YGraph.IRLPointToViewPort(w, new pointXY(data[i].x, min));
        let p2 = YGraph.IRLPointToViewPort(w, new pointXY(data[i].x, max));
        if (Math.abs(p1.Y - p2.Y) > 2) {
          ToDraw[n++] = new PointF(p1.X, p1.Y);
          ToDraw[n++] = new PointF(p2.X, p2.Y);
        }
        Current = YGraph.IRLPointToViewPort(w, data[i]);
      }
      ToDraw[n++] = Current;
      ToDraw = ToDraw.slice(0, n);
      if (n > 1)
        g.DrawLines(p, ToDraw);
      return n;
    } else {
      if (isSVG) {
        let ToDraw = new Array(Last - First + 1);
        for (let i = First; i <= Last; i++) {
          ToDraw[i - First] = YGraph.IRLPointToViewPort(w, data[i]);
        }
        g.DrawLines(p, ToDraw);
      } else {
        for (let i = First; i < Last; i++) {
          g.DrawLine(p, YGraph.IRLPointToViewPort(w, data[i]), YGraph.IRLPointToViewPort(w, data[i + 1]));
        }
      }
    }
    return Last - First;
  }
  static DoSummarySegmentRendering(w, g, p, data, count, finalPoint, xTimeStart, xTimeEnd) {
    let ToDraw = new Array(2 * count + 1);
    let n = 0;
    if (count > 0) {
      if (data[0].x1 > xTimeEnd || data[count - 1].x2 < xTimeStart)
        return 0;
      let isSVG = g instanceof YGraphicsSVG;
      let N1 = 0;
      let N2 = 0;
      let First = 0;
      if (data[0].x1 < xTimeStart) {
        N1 = 0;
        N2 = count - 1;
        while (N2 - N1 > 1) {
          let N = N1 + N2 >> 1;
          if (data[N].x1 > xTimeStart)
            N2 = N;
          else
            N1 = N;
        }
        First = N1 - 1;
        if (First < 0)
          First = 0;
      }
      let Last = count - 1;
      if (data[Last].x2 > xTimeEnd) {
        N1 = 0;
        N2 = count - 1;
        while (N2 - N1 > 1) {
          let N = N1 + N2 >> 1;
          if (data[N].x2 < xTimeEnd)
            N1 = N;
          else
            N2 = N;
        }
        Last = N2 + 1;
        if (Last > count - 1)
          Last = count - 1;
      }
      let Current;
      let New;
      let i = First;
      let max;
      let min;
      let limit;
      Current = YGraph.IRLPointSummaryToViewPort(w, data[i]);
      ToDraw[n++] = new PointF(Current.X1, Current.YMIN);
      let ymin = Current.YMAX;
      let ymax = Current.YMIN;
      let x = Current.X1;
      let buffered = 0;
      while (i <= Last) {
        Current = YGraph.IRLPointSummaryToViewPort(w, data[i]);
        if (ymin > Current.YMAX)
          ymin = Current.YMAX;
        if (ymax < Current.YMIN)
          ymax = Current.YMIN;
        buffered++;
        if (Current.X2 > x) {
          ToDraw[n++] = new PointF(x, ymin);
          if (ymax - ymin > 2)
            ToDraw[n++] = new PointF(x + Current.X2 >> 1, ymax);
          x = Current.X2;
          ymin = Current.YMAX;
          ymax = Current.YMIN;
          buffered = 0;
        }
        i++;
      }
      if (buffered > 0) {
        ToDraw[n++] = new PointF(x, Current.YMIN);
        ToDraw[n++] = new PointF(x + Current.X2 >> 1, Current.YMAX);
      }
    }
    if (finalPoint) {
      let Current = YGraph.IRLPointSummaryToViewPort(w, finalPoint);
      ToDraw[n++] = new PointF(Current.X1, Current.YMIN);
      ToDraw[n++] = new PointF(Current.X2, Current.YMAX);
    }
    if (n > 1) {
      ToDraw = ToDraw.slice(0, n);
      g.DrawLines(p, ToDraw);
    }
    return n;
  }
  DrawYAxisZones(w, g, scale) {
    if (!scale.visible)
      return;
    let Delta = scale.startStopStep.dataMax - scale.startStopStep.dataMin;
    let YZoom = Delta / (w.Height - w.Bmargin - w.Tmargin);
    for (let i = 0; i < scale.zones.length; i++) {
      if (scale.zones[i].visible) {
        let max = scale.zones[i].max;
        let min = scale.zones[i].min;
        if (Number.isNaN(max)) {
          max = scale.startStopStep.dataMax;
        }
        if (Number.isNaN(min))
          min = scale.startStopStep.dataMin;
        if (max < min) {
          let t = max;
          max = min;
          min = t;
        }
        let y0 = w.Height - w.Bmargin - Math.round((max - scale.startStopStep.dataMin) / YZoom) >> 0;
        let h = Math.round((max - min) / YZoom) >> 0;
        g.FillRectangleXYHW(scale.zones[i].zoneBrush, this.mainViewPort.Lmargin, y0, this.mainViewPort.Width - this.mainViewPort.Rmargin - this.mainViewPort.Lmargin + 1, h);
      }
    }
  }
  DrawXAxisZones(w, g, scale) {
    if (!scale.visible)
      return;
    let delta = scale.max - scale.min;
    let XZoom = delta / (w.Width - w.Lmargin - w.Rmargin);
    for (let i = 0; i < scale.zones.length; i++) {
      if (scale.zones[i].visible) {
        let max = scale.zones[i].max;
        let min = scale.zones[i].min;
        if (Number.isNaN(max))
          max = scale.min;
        if (Number.isNaN(min))
          min = scale.max;
        if (max < min) {
          let t = max;
          max = min;
          min = t;
        }
        let x0 = w.Lmargin + Math.round((min - scale.min) / XZoom) >> 0;
        g.FillRectangleXYHW(scale.zones[i].zoneBrush, x0, this.mainViewPort.Tmargin, (max - min) / XZoom >> 0, this.mainViewPort.Height - this.mainViewPort.Tmargin - this.mainViewPort.Bmargin);
      }
    }
  }
  static DrawYAxis(w, g, axis, ofset, simulation) {
    if (!axis.visible) {
      axis.innerWidth = 0;
      return axis.innerWidth;
    }
    let Delta = axis.startStopStep.dataMax - axis.startStopStep.dataMin;
    let YZoom = Delta / (w.Height - w.Bmargin - w.Tmargin);
    let leftSide = axis.position == YAxis.HrzPosition.LEFT;
    let x = leftSide ? w.Lmargin - ofset : w.Width - w.Rmargin + ofset;
    if (!simulation)
      g.DrawLineXY(axis.pen, x, w.Tmargin, x, w.Height - w.Bmargin);
    let format = new YStringFormat(16384);
    format.LineAlignment = 1;
    format.Alignment = leftSide ? 2 : 0;
    let FirstStep = axis.startStopStep.step * Math.floor(axis.startStopStep.start / axis.startStopStep.step);
    if (FirstStep < 0) {
      FirstStep -= axis.startStopStep.step;
    }
    let stepCount = ((Delta - (FirstStep - axis.startStopStep.dataMin)) / axis.startStopStep.step >> 0) + 1;
    if (!simulation)
      g.TextRenderingHint = YTextRenderingHint.AntiAlias;
    let UnitWidth = 0;
    let labelPrecision = 0;
    if (axis.startStopStep.precision < 0)
      labelPrecision = -axis.startStopStep.precision;
    if (stepCount < w.Height) {
      for (let i = 0; i < stepCount; i++) {
        let y = Math.round((FirstStep + i * axis.startStopStep.step - axis.startStopStep.dataMin) / YZoom) >> 0;
        if (y >= 0) {
          y = w.Height - w.Bmargin - y;
          let v = FirstStep + i * axis.startStopStep.step;
          if (!simulation) {
            if (axis.showGrid && (i > 0 || axis.startStopStep.dataMin != 0))
              g.DrawLineXY(axis.gridPen, w.Lmargin, y, w.Width - w.Rmargin, y);
            if (Math.abs(v) < 1e-6 && axis.highlightZero) {
              g.DrawLineXY(axis.pen, w.Lmargin, y, w.Width - w.Rmargin, y);
            }
            g.DrawLineXY(axis.pen, x + (leftSide ? -2 : 2), y, x + (leftSide ? 5 : -5), y);
          }
          let label = v.toFixed(labelPrecision);
          let ssize = g.MeasureString(label, axis.font, 1e5);
          if (ssize.width > UnitWidth)
            UnitWidth = ssize.width;
          if (!simulation) {
            let p = new Point(x + (leftSide ? -3 : 3), y);
            g.DrawStringPF(label, axis.font, axis.font.brush, p, format);
          }
        }
      }
    }
    if (axis.legend.title != "") {
      let size = g.MeasureString(axis.legend.title, axis.legend.font, 1e5);
      if (!simulation) {
        let format2 = new YStringFormat(16384);
        format2.Alignment = 1;
        format2.LineAlignment = 1;
        format2.Trimming = 0;
        let legendX = x + (leftSide ? -UnitWidth - size.height : UnitWidth + size.height + 2) >> 0;
        let legendY = w.Tmargin + (w.Height - w.Tmargin - w.Bmargin) / 2 >> 0;
        g.Transform(legendX, legendY, leftSide ? -Math.PI / 2 : Math.PI / 2);
        g.DrawStringPF(axis.legend.title, axis.legend.font, axis.legend.font.brush, new Point(0, 0), format2);
        g.ResetTransform();
      }
      UnitWidth += size.height;
    }
    axis.innerWidth = (UnitWidth >> 0) + 10;
    return axis.innerWidth;
  }
  DrawMonitorXAxis(w, g, xRange, format) {
    let delta = xRange.Max - xRange.Min;
    let scale = TimeConverter.BestTimeformat(delta, delta, this.xAxis.timeReference);
    let XZoom = delta / (w.Width - w.Lmargin - w.Rmargin);
    let stepCount = (delta / scale.step >> 0) + 2;
    let FirstStep = scale.step * Math.floor(xRange.Min / scale.step);
    if (FirstStep < xRange.Min)
      FirstStep += scale.step;
    g.TextRenderingHint = YTextRenderingHint.AntiAlias;
    let y = w.Height - w.Bmargin;
    g.DrawLineXY(this._navigator.pen, w.Lmargin, w.Height - w.Bmargin - 1, w.Width - w.Rmargin, w.Height - w.Bmargin - 1);
    let label;
    let t = FirstStep;
    do {
      let d = TimeConverter.FromUnixTime(t);
      if (scale.step > 31.1 * 86400) {
        t = TimeConverter.ToUnixTime(new Date(d.getFullYear(), d.getMonth(), 1));
      }
      if (t >= xRange.Min) {
        let x = w.Lmargin + Math.round((t - xRange.Min) / XZoom);
        g.DrawLineXY(this._navigator.pen, x, y, x, y - 4);
        if (format == XAxis.FORMATAUTO) {
          label = TimeConverter.FromUnixTime(t).ToString(scale.format);
        } else {
          label = TimeConverter.FromUnixTime(t).ToString(format);
        }
        let ssize = g.MeasureString(label, this._navigator.font, 1e5);
        g.DrawString(label, this._navigator.font, this._navigator.font.brush, new Point(x - ssize.width / 2, y - ssize.height - 1));
      }
      t += scale.step;
    } while (t < xRange.Max);
  }
  static XLabel(t, scale, scaleFormat, timeRange) {
    let label;
    if (scale.timeReference == TimeConverter.TimeReference.ABSOLUTE) {
      if (scale.labelFormat == XAxis.FORMATAUTO) {
        label = TimeConverter.FromUnixTime(t).ToString(scaleFormat.format);
      } else {
        label = t.toString();
      }
    } else {
      let ticks = YTimeSpan.TicksPerSecond * (Math.round(1e3 * (t - scale.zeroTime)) / 1e3);
      label = ticks < 0 ? "-" + new YTimeSpan(-ticks).toString(scaleFormat.format) : new YTimeSpan(ticks).toString(scaleFormat.format);
    }
    return label;
  }
  DrawXAxis(w, g, scale, simulation) {
    if (w.Width - w.Rmargin - w.Lmargin < 10)
      return 1;
    let stringFormat = new YStringFormat(16384);
    stringFormat.Alignment = 1;
    let bottomSide = scale.position == XAxis.VrtPosition.BOTTOM;
    let y = bottomSide ? w.Height - w.Bmargin : w.Tmargin;
    if (!simulation)
      g.DrawLineXY(scale.pen, w.Lmargin, y, w.Width - w.Rmargin, y);
    let delta = scale.max - scale.min;
    let XZoom = delta / (w.Width - w.Lmargin - w.Rmargin);
    let stepCount = (delta / scale.step >> 0) + 1;
    let FirstStep = 0;
    let timeRange = MinMaxHandler.DefaultValue();
    for (let i = 0; i < this._series.length; i++) {
      if (!this._series[i].disabled) {
        timeRange = MinMaxHandler.Combine(timeRange, this._series[i].timeRange);
      }
    }
    scale.zeroTime = timeRange.Min;
    if (scale.timeReference == TimeConverter.TimeReference.ABSOLUTE) {
      FirstStep = scale.step * Math.floor(scale.min / scale.step);
      timeRange.Min = scale.min;
      timeRange.Max = scale.max;
    } else {
      if (Number.isNaN(timeRange.Min))
        return 0;
      FirstStep = timeRange.Min + scale.step * Math.floor((scale.min - scale.zeroTime) / scale.step);
    }
    if (FirstStep < scale.min)
      FirstStep += scale.step;
    let timeOffset = 0;
    if (scale.timeReference != TimeConverter.TimeReference.ABSOLUTE) {
      timeOffset = FirstStep;
    }
    scale.fullSize = timeRange.Max - timeRange.Min;
    let scaleFormat = scale.bestFormat(timeRange.Max - timeRange.Min, scale.max - scale.min);
    if (!simulation)
      g.TextRenderingHint = YTextRenderingHint.AntiAlias;
    let UnitHeight = 0;
    let label;
    scale.step = scaleFormat.step;
    let t = parseFloat(FirstStep.toString());
    label = YGraph.XLabel(t, scale, scaleFormat, timeRange);
    let ssize = g.MeasureString(label, scale.font, 1e5);
    let mod = 1;
    while (mod * (w.Width - w.Rmargin - w.Lmargin) / stepCount < ssize.width) {
      mod++;
    }
    let steps = Math.round((t - timeOffset) / scale.step) >> 0;
    let previousT = 0;
    do {
      let d = TimeConverter.FromUnixTime(t);
      if (scale.step > 32 * 86400 && scale.timeReference == TimeConverter.TimeReference.ABSOLUTE) {
        if (scale.step >= 365 * 86400) {
          let m = d.getMonth();
          t = TimeConverter.ToUnixTime(new Date(d.getFullYear() + (m > 5 ? 1 : 0), 0, 1));
        } else
          t = TimeConverter.ToUnixTime(new Date(d.getFullYear(), d.getMonth(), 1));
        if (t < previousT) {
          debugger;
        }
      }
      if (t >= scale.min) {
        let x = w.Lmargin + Math.round((t - scale.min) / XZoom) >> 0;
        if (x <= w.Width - w.Rmargin) {
          if (!simulation) {
            if (scale.showGrid)
              g.DrawLineXY(scale.gridPen, x, w.Tmargin, x, w.Height - w.Bmargin);
            g.DrawLineXY(scale.pen, x, y + (bottomSide ? 2 : -2), x, y + (bottomSide ? -5 : 5));
          }
          label = YGraph.XLabel(t, scale, scaleFormat, timeRange);
          ssize = g.MeasureString(label, scale.font, 1e5);
          if (ssize.height > UnitHeight)
            UnitHeight = ssize.height;
          if (!simulation) {
            if (steps % mod == 0) {
              g.DrawStringPF(label, scale.font, scale.font.brush, new PointF(x, y + (bottomSide ? 5 : -ssize.height >> 0) - 2), stringFormat);
            }
          }
        }
      }
      previousT = t;
      t += scale.step;
      if (t < previousT)
        debugger;
      steps++;
    } while (t <= scale.max);
    if (scale.legend.title != "") {
      let size = g.MeasureString(scale.legend.title, scale.legend.font, 1e5);
      if (!simulation) {
        let legendX = w.Lmargin + (w.Width - w.Lmargin - w.Rmargin - size.width) / 2 >> 0;
        let legendY = bottomSide ? w.Height - w.Bmargin + UnitHeight + 5 : w.Tmargin - UnitHeight - size.height * 1.5;
        g.DrawString(scale.legend.title, scale.legend.font, scale.legend.font.brush, new PointF(legendX, legendY));
      }
      UnitHeight += size.height >> 0;
    }
    scale.innerHeight = (UnitHeight >> 0) + 10;
    return scale.innerHeight;
  }
  pixelxSize(mainViewPort, scaleX) {
    let dtime = scaleX.max - scaleX.min;
    let dview = mainViewPort.Width - mainViewPort.Lmargin - mainViewPort.Rmargin;
    if (dview > 0)
      return dtime / dview;
    return 0;
  }
  TimeToAutoSting(t, mainViewPort, scaleX) {
    let strValue = "";
    let dtime = scaleX.max - scaleX.min;
    let months = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
    if (dtime > 0) {
      let pixelSize = this.pixelxSize(mainViewPort, scaleX);
      if (pixelSize > 0) {
        if (scaleX.timeReference == TimeConverter.TimeReference.ABSOLUTE) {
          let date = TimeConverter.FromUnixTime(t);
          let MMMM = months[date.getMonth()];
          let dd = date.getDate().toString();
          let HH = date.getHours().toString();
          if (HH.length < 2)
            HH = "0" + HH;
          let mm = date.getMinutes().toString();
          if (mm.length < 2)
            mm = "0" + mm;
          let ss = date.getSeconds().toString();
          if (ss.length < 2)
            ss = "0" + ss;
          let ff = Math.round(date.getMilliseconds() / 10).toString();
          if (ff.length < 2)
            ff = "0" + ss;
          let f = Math.round(date.getMilliseconds() / 100).toString();
          if (dtime >= 86400)
            strValue += MMMM + " " + dd;
          if (pixelSize < 0.1) {
            strValue += (strValue != "" ? " " : "") + HH + ":" + mm + ":" + ss + "." + ff;
          } else if (pixelSize < 1) {
            strValue += (strValue != "" ? " " : "") + HH + ":" + mm + ":" + ss + "." + f;
          } else if (pixelSize < 60) {
            strValue += (strValue != "" ? " " : "") + HH + ":" + mm + ":" + ss;
          } else if (pixelSize < 3600) {
            strValue += (strValue != "" ? " " : "") + HH + ":" + mm;
          } else if (pixelSize < 86400)
            strValue += (strValue != "" ? " " : "") + HH + "H";
        } else {
          let format = TimeConverter.RelativeFormat(scaleX.fullSize, dtime, pixelSize);
          let ticks = YTimeSpan.TicksPerSecond * (Math.round(100 * (t - scaleX.zeroTime)) / 100);
          strValue += ticks < 0 ? "-" + new YTimeSpan(-ticks).toString(format) : new YTimeSpan(ticks).toString(format);
        }
      }
    }
    return strValue;
  }
  DrawDataTracker(g, viewPortWidth, viewPortHeight, scaleX) {
    if (!this._dataTracker.enabled) {
      return;
    }
    let p = this.mouseLocalPosition();
    if (p == null) {
      return;
    }
    if (p.X <= this.mainViewPort.Lmargin) {
      return;
    }
    if (p.Y <= this.mainViewPort.Tmargin) {
      return;
    }
    if (p.X >= this.UIContainer.width - this.mainViewPort.Rmargin) {
      return;
    }
    if (p.Y >= this.UIContainer.height - this.mainViewPort.Bmargin) {
      return;
    }
    g.SetClip(new YRectangle(0, 0, viewPortWidth, viewPortHeight));
    let DataPoint = YGraph.ViewPortPointToIRL(this.mainViewPort, p);
    let delta = -1;
    let bestindex = -1;
    let bestmatch = new Array(this._series.length);
    let IRLmatch = new Array(this._series.length);
    for (let i = 0; i < this._series.length; i++) {
      if (this._series[i].visible && !this._series[i].disabled) {
        let p2 = this._series[i].findClosestValue(DataPoint.x, false);
        if (p2 != null) {
          IRLmatch[i] = p2;
          bestmatch[i] = YGraph.IRLPointToViewPort(this.mainViewPort, IRLmatch[i], this.yAxes[this._series[i].yAxisIndex].IRLy, this.yAxes[this._series[i].yAxisIndex].zoom);
          if (bestindex < 0 || delta > Math.abs(bestmatch[i].Y - p.Y)) {
            delta = Math.abs(bestmatch[i].Y - p.Y);
            if (this._dataTracker.detectionDistance == 0 || delta <= this._dataTracker.detectionDistance && Math.abs(bestmatch[i].X - p.X) < this._dataTracker.detectionDistance) {
              bestindex = i;
            }
          }
        }
      }
    }
    if (bestindex >= 0) {
      let xx = bestmatch[bestindex].X - this._dataTracker.diameter / 2 >> 0;
      let yy = bestmatch[bestindex].Y - this._dataTracker.diameter / 2 >> 0;
      let dd = this._dataTracker.diameter;
      g.FillEllipse(this._series[bestindex].brush, xx, yy, dd, dd);
      g.DrawEllipse(this._dataTracker.pen, xx, yy, dd, dd);
      let dx;
      let dy;
      if (p.X > this.mainViewPort.Lmargin + (viewPortWidth - this.mainViewPort.Lmargin - this.mainViewPort.Rmargin) / 2)
        dx = -1;
      else
        dx = 1;
      if (p.Y > this.mainViewPort.Tmargin + (viewPortHeight - this.mainViewPort.Tmargin - this.mainViewPort.Bmargin) / 2)
        dy = -1;
      else
        dy = 1;
      let xx2 = bestmatch[bestindex].X + dx * (this._dataTracker.handleLength * 1.5) >> 0;
      let yy2 = bestmatch[bestindex].Y + dy * this._dataTracker.handleLength >> 0;
      g.DrawLineXY(this._dataTracker.pen, bestmatch[bestindex].X + dx * 0.707 * this._dataTracker.diameter / 2 >> 0, bestmatch[bestindex].Y + dy * 0.707 * this._dataTracker.diameter / 2 >> 0, bestmatch[bestindex].X + dx * this._dataTracker.handleLength >> 0, bestmatch[bestindex].Y + dy * this._dataTracker.handleLength >> 0);
      g.DrawLineXY(this._dataTracker.pen, bestmatch[bestindex].X + dx * this._dataTracker.handleLength >> 0, bestmatch[bestindex].Y + dy * this._dataTracker.handleLength >> 0, xx2, yy2);
      let strValue = "";
      if (this._dataTracker.showSerieName)
        strValue += this._series[bestindex].legend + "\r\n";
      if (this._dataTracker.showTimeStamp) {
        let t = IRLmatch[bestindex].x;
        strValue += this.TimeToAutoSting(t, this.mainViewPort, scaleX) + "\r\n";
      }
      if (this._dataTracker.dataPrecision.toString == DataTracker.DataPrecision.PRECISION_NOLIMIT.toString) {
        strValue += IRLmatch[bestindex].y.toString() + this._series[bestindex].unit;
      } else {
        let strvalue = this._dataTracker.dataPrecision.description;
        let precision = -Math.log10(Number(strvalue));
        strValue += IRLmatch[bestindex].y.toFixed(precision) + this._series[bestindex].unit;
      }
      let ssize = g.MeasureString(strValue, this._dataTracker.font, 1e4);
      let labelwidth = ssize.width + 2 * this._dataTracker.padding + this._dataTracker.borderthickness;
      let labelHeight = ssize.height + 2 * this._dataTracker.padding + this._dataTracker.borderthickness;
      if (dx > 0) {
        g.FillRectangleXYHW(this._dataTracker.bgBrush, xx2, yy2 - (labelHeight >> 1), labelwidth, labelHeight);
        g.DrawRectangleXYHW(this._dataTracker.pen, xx2, yy2 - (labelHeight >> 1), labelwidth, labelHeight);
        g.DrawStringXY(strValue, this._dataTracker.font, this._dataTracker.font.brush, xx2 + this._dataTracker.padding >> 0, yy2 - (labelHeight >> 1) + this._dataTracker.padding >> 0);
      } else {
        g.FillRectangleXYHW(this._dataTracker.bgBrush, xx2 - labelwidth, yy2 - (labelHeight >> 1), labelwidth, labelHeight);
        g.DrawRectangleXYHW(this._dataTracker.pen, xx2 - labelwidth, yy2 - (labelHeight >> 1), labelwidth, labelHeight);
        g.DrawStringXY(strValue, this._dataTracker.font, this.dataTracker.font.brush, xx2 + this._dataTracker.padding - labelwidth >> 0, yy2 - (labelHeight >> 1) + this._dataTracker.padding >> 0);
      }
    }
  }
  DrawMarkers(w, g, scaleX, viewPortWidth, viewPortHeight) {
    if (this._xAxis.markers.length == 0)
      return;
    g.SetClip(new YRectangle(w.Lmargin, w.Tmargin, w.Width - w.Rmargin - w.Lmargin, w.Height - w.Bmargin - w.Tmargin));
    let Bottomleft = YGraph.ViewPortPointToIRL(w, new Point(w.Lmargin, w.Height - w.Bmargin));
    let TopRight = YGraph.ViewPortPointToIRL(w, new Point(w.Width - w.Rmargin, w.Tmargin));
    let dy = (w.Height - w.Bmargin - w.Tmargin) / 100;
    let pixelSize = -1;
    g.TextRenderingHint = YTextRenderingHint.AntiAlias;
    for (let i = 0; i < this._xAxis.markers.length; i++) {
      if (this._xAxis.markers[i].enabled) {
        if (pixelSize < 0)
          pixelSize = this.pixelxSize(this.mainViewPort, scaleX);
        let mustdraw = true;
        let xpos = 0;
        if (this._xAxis.markers[i].timereference == TimeConverter.TimeReference.RELATIVE) {
          if (this._xAxis.zeroTime > 0) {
            xpos = this._xAxis.markers[i].xposition + this._xAxis.zeroTime;
          } else {
            mustdraw = false;
          }
        } else {
          xpos = this._xAxis.markers[i].xposition;
        }
        if (xpos > Bottomleft.x - 100 * pixelSize && xpos < TopRight.x + 100 * pixelSize && mustdraw) {
          let p = YGraph.IRLPointToViewPort(w, new pointXY(xpos, 0));
          let xxCenter = p.X >> 0;
          let yyCenter = w.Height - w.Bmargin - this._xAxis.markers[i].yposition * dy >> 0;
          let strValue = this._xAxis.markers[i].text.replace("\\n", "\n");
          let now = new Date();
          if (strValue.indexOf("$") >= 0) {
            if (strValue.indexOf("$MARKERTIME$") >= 0) {
              let s = this._xAxis.markers[i].timereference == TimeConverter.TimeReference.RELATIVE ? TimeConverter.secTimeSpanToString(this._xAxis.markers[i].xposition, pixelSize) : this.TimeToAutoSting(this._xAxis.markers[i].xposition, this.mainViewPort, scaleX);
              strValue = strValue.replace("$MARKERTIME$", s);
            }
            if (strValue.indexOf("$VALUE") >= 0) {
              for (let j = 0; j < this._series.length; j++) {
                if (!this._series[j].disabled) {
                  let pt = this._series[j].findClosestValue(xpos, true);
                  let st = pt != null ? pt.y.toFixed(0) : "--";
                  strValue = strValue.replace("$VALUE" + (j + 1).toString() + "$", st);
                } else {
                  strValue = strValue.replace("$VALUE" + (j + 1).toString() + "$", "");
                }
              }
            }
            if (strValue.indexOf("$UNIT") >= 0) {
              for (let j = 0; j < this._series.length; j++) {
                if (!this._series[j].disabled) {
                  strValue = strValue.replace("$UNIT" + (j + 1).toString() + "$", this._series[j].unit);
                } else {
                  strValue = strValue.replace("$UNIT" + (j + 1).toString() + "$", "");
                }
              }
            }
            if (strValue.indexOf("$LEGEND") >= 0) {
              for (let j = 0; j < this._series.length; j++) {
                if (!this._series[j].disabled) {
                  strValue = strValue.replace("$LEGEND" + (j + 1).toString() + "$", this._series[j].legend);
                } else {
                  strValue = strValue.replace("$LEGEND" + (j + 1).toString() + "$", "");
                }
              }
            }
            if (this._xAxis.markers[i].PatchTextCallback != null) {
              strValue = this._xAxis.markers[i].PatchTextCallback(strValue);
            }
          }
          let ssize = g.MeasureString(strValue, this._xAxis.markers[i].font, 1e4);
          let labelWidth = ssize.width + 2 * this._xAxis.markers[i].padding + this._xAxis.markers[i].borderthickness;
          let labelHeight = ssize.height + 2 * this._xAxis.markers[i].padding + this._xAxis.markers[i].borderthickness;
          g.FillRectangleXYHW(this._xAxis.markers[i].bgBrush, xxCenter - (labelWidth >> 1), yyCenter - (labelHeight >> 1), labelWidth >> 0, labelHeight >> 0);
          g.DrawRectangleXYHW(this._xAxis.markers[i].pen, xxCenter - (labelWidth >> 1), yyCenter - (labelHeight >> 1), labelWidth >> 0, labelHeight >> 0);
          let xText;
          switch (this._xAxis.markers[i].textAlign) {
            case Marker.TextAlign.LEFT:
              xText = xxCenter - (labelWidth >> 1) + this._xAxis.markers[i].padding;
              break;
            case Marker.TextAlign.RIGHT:
              xText = xxCenter + (labelWidth >> 1) - this._xAxis.markers[i].padding;
              break;
            default:
              xText = xxCenter;
              break;
          }
          g.DrawStringPF(strValue, this._xAxis.markers[i].font, this._xAxis.markers[i].font.brush, new PointF(xText, yyCenter), this._xAxis.markers[i].stringFormat);
          g.DrawLineXY(this._xAxis.markers[i].pen, xxCenter, w.Tmargin >> 0, xxCenter, yyCenter - (labelHeight >> 1));
          g.DrawLineXY(this._xAxis.markers[i].pen, xxCenter, yyCenter + (labelHeight >> 1), xxCenter, w.Height - w.Bmargin >> 0);
          if (this._xAxis.markers[i].arrowSize > 0) {
            if (this._xAxis.markers[i].yposition > 25) {
              let triangle = [
                new PointF(xxCenter - this._xAxis.markers[i].arrowSize, yyCenter + (labelHeight >> 1)),
                new PointF(xxCenter + this._xAxis.markers[i].arrowSize, yyCenter + (labelHeight >> 1)),
                new PointF(xxCenter, yyCenter + (labelHeight >> 1) + this._xAxis.markers[i].arrowSize)
              ];
              g.FillPolygon(this._xAxis.markers[i].arrowBrush, triangle);
            }
            if (this._xAxis.markers[i].yposition < 75) {
              let triangle = [
                new PointF(xxCenter - this._xAxis.markers[i].arrowSize, yyCenter + (labelHeight >> 1)),
                new PointF(xxCenter + this._xAxis.markers[i].arrowSize, yyCenter + (labelHeight >> 1)),
                new PointF(xxCenter, yyCenter - (labelHeight >> 1) - this._xAxis.markers[i].arrowSize)
              ];
              g.FillPolygon(this._xAxis.markers[i].arrowBrush, triangle);
            }
          }
        }
      }
    }
    g.ResetClip();
  }
  DrawDataPanels(w, g, scaleX, scalesY, viewPortWidth, viewPortHeight) {
    if (this._dataPanels.length == 0)
      return;
    g.SetClip(new YRectangle(w.Lmargin, w.Tmargin, w.Width - w.Rmargin - w.Lmargin, w.Height - w.Bmargin - w.Tmargin));
    for (let i = 0; i < this._dataPanels.length; i++) {
      if (this._dataPanels[i].enabled) {
        let p = this._dataPanels[i];
        if (p.yScaleIndex < scalesY.length) {
          let AvailableWidth = w.Width - 2 * p.padding - p.borderthickness;
          if (AvailableWidth < 100)
            AvailableWidth = 100;
          let ssize = g.MeasureString(p.text, p.font, AvailableWidth >> 0);
          let panelWidth = ssize.width + 2 * p.padding + p.borderthickness;
          let panelHeight = ssize.height + 2 * p.padding + p.borderthickness;
          let x = 0;
          switch (p.horizontalPosition) {
            case DataPanel.HorizontalPosition.LEFTBORDER:
              x = w.Lmargin;
              break;
            case DataPanel.HorizontalPosition.RIGHTBORDER:
              x = w.Width - w.Rmargin;
              break;
            case DataPanel.HorizontalPosition.ABSOLUTEX:
              let delta = scaleX.max - scaleX.min;
              let XZoom = delta / (w.Width - w.Lmargin - w.Rmargin);
              x = w.Lmargin + Math.round((p.AbsoluteXposition - scaleX.min) / XZoom) >> 0;
              break;
          }
          let y = 0;
          switch (p.verticalPosition) {
            case DataPanel.VerticalPosition.TOPBORDER:
              y = w.Tmargin;
              break;
            case DataPanel.VerticalPosition.BOTTOMBORDER:
              y = w.Height - w.Bmargin;
              break;
            case DataPanel.VerticalPosition.ABSOLUTEY:
              y = w.Height - w.Bmargin - Math.round((p.AbsoluteYposition - scalesY[p.yScaleIndex].IRLy) * scalesY[p.yScaleIndex].zoom) >> 0;
              break;
          }
          switch (p.panelHrzAlign) {
            case DataPanel.HorizontalAlign.LEFTOF:
              x -= panelWidth + p.horizontalMargin;
              break;
            case DataPanel.HorizontalAlign.RIGHTOF:
              x += p.horizontalMargin;
              break;
            default:
              x -= panelWidth / 2;
              break;
          }
          switch (p.panelVrtAlign) {
            case DataPanel.VerticalAlign.ABOVE:
              y -= panelHeight + p.verticalMargin;
              break;
            case DataPanel.VerticalAlign.BELOW:
              y += p.verticalMargin;
              break;
            default:
              y -= panelHeight / 2;
              break;
          }
          g.FillRectangleXYHW(p.bgBrush, x >> 0, y >> 0, panelWidth >> 0, panelHeight >> 0);
          if (p.borderthickness > 0)
            g.DrawRectangleXYHW(p.pen, x >> 0, y >> 0, panelWidth >> 0, panelHeight >> 0);
          let sf = new YStringFormat(16384);
          switch (p.panelTextAlign) {
            case MessagePanel.TextAlign.LEFT:
              sf.LineAlignment = 0;
              sf.Alignment = 0;
              break;
            case MessagePanel.TextAlign.RIGHT:
              sf.LineAlignment = 2;
              sf.Alignment = 2;
              break;
            default:
              sf.LineAlignment = 1;
              sf.Alignment = 1;
              break;
          }
          let rect = new YRectangle(x + p.padding + p.borderthickness / 2 >> 0, y + p.padding + p.borderthickness / 2 >> 0, ssize.width >>= 1, (ssize.height >> 0) + 1);
          g.DrawStringRect(p.text, p.font, p.font.brush, rect, sf);
        } else {
          throw new RangeError("Cannot renderer data panel #" + i.toString() + ", no such Y axis");
        }
      }
    }
  }
  findSegmentIndex(serieIndex, timeStamp, debug) {
    let s = this._series[serieIndex];
    if (s.segments.length <= 0)
      return -1;
    let start = 0;
    let end = s.segments.length - 1;
    if (debug) {
      console.log("looking for " + timeStamp);
      for (let i = 0; i < s.segments.length; i++)
        console.log("seg " + i + " [" + s.segments[i].data[0].x + ".." + s.segments[i].data[s.segments[i].count - 1].x + "]");
      debugger;
    }
    while (true) {
      let startSeg = s.segments[start];
      let endSeg = s.segments[end];
      if (timeStamp > startSeg.data[startSeg.count - 1].x)
        return start - 0.5;
      if (timeStamp < endSeg.data[0].x)
        return end + 0.5;
      if (timeStamp >= startSeg.data[0].x)
        return start;
      if (timeStamp <= endSeg.data[endSeg.count - 1].x)
        return end;
      if (end == start) {
        debugger;
        return -99;
      }
      if (end - start == 1)
        return start + 0.5;
      let middle = start + end >> 1;
      let middleSeg = s.segments[middle];
      if (timeStamp <= middleSeg.data[middleSeg.count - 1].x) {
        end = end - 1;
        start = middle;
      } else {
        end = middle - 1;
        start = start + 1;
      }
    }
  }
  findTimestampIndexInSegment(serieIndex, segmentIndex, timeStamp) {
    let seg = this._series[serieIndex].segments[segmentIndex];
    if (!seg)
      debugger;
    if (timeStamp <= seg.data[0].x)
      return 0;
    let count = this._series[serieIndex].segments[segmentIndex].count;
    if (timeStamp >= seg.data[count - 1].x)
      return count - 1;
    let start = 0;
    let end = count - 1;
    let middle = 0;
    while (true) {
      if (end - start <= 1) {
        if (timeStamp <= seg.data[start].x)
          return start;
        return end;
      }
      middle = start + end >> 1;
      if (timeStamp <= seg.data[middle].x)
        end = middle;
      else
        start = middle;
    }
  }
  Render(g, UIw, UIh) {
    if (UIw < 50 || UIh < 50)
      return 0;
    let lastLmargin = this.mainViewPort.Lmargin;
    let lastRmargin = this.mainViewPort.Rmargin;
    this.mainViewPort.Width = UIw;
    this.mainViewPort.Height = UIh;
    this.mainViewPort.Lmargin = 0;
    this.mainViewPort.Rmargin = 0;
    g.SmoothingMode = YSmoothingMode.HighQuality;
    let yMarginOffset = 5;
    for (let i = 0; i < this._yAxes.length; i++) {
      if (this._yAxes[i].visible) {
        let s = g.MeasureString("8", this._yAxes[i].font, 1e5);
        let o = (s.height + 1) / 2 >> 0;
        if (yMarginOffset < o)
          yMarginOffset = o;
      }
    }
    this.mainViewPort.Tmargin = this._xAxis.position == XAxis.VrtPosition.TOP ? 0 : yMarginOffset;
    this.mainViewPort.Bmargin = this._xAxis.position == XAxis.VrtPosition.BOTTOM ? 0 : yMarginOffset;
    if (!this._legendPanel.overlap)
      this.drawLegendPanel(g, UIw, UIh, this.mainViewPort);
    this.drawAnnotationPanels(g, this._annotationPanels, UIw, UIh, false, this.mainViewPort);
    if (this.mainViewPort.Bmargin == 0)
      this.mainViewPort.Bmargin = 5;
    if (this.mainViewPort.Tmargin == 0)
      this.mainViewPort.Tmargin = 5;
    let h = this.DrawXAxis(this.mainViewPort, g, this._xAxis, true);
    if (this._xAxis.position == XAxis.VrtPosition.TOP)
      this.mainViewPort.Tmargin += h;
    else
      this.mainViewPort.Bmargin += h;
    this.mainViewPort.IRLx = this._xAxis.min;
    let M;
    for (let i = 0; i < this._yAxes.length; i++) {
      M = MinMaxHandler.DefaultValue();
      for (let k = 0; k < this._series.length; k++) {
        if (this._series[k].yAxisIndex == i && !this._series[k].disabled) {
          for (let j = 0; j < this._series[k].segments.length; j++) {
            M = MinMaxHandler.Combine(M, YGraph.FindMinMax(this._xAxis.min, this._xAxis.max, this._series[k].segments[j].data, this._series[k].segments[j].count));
          }
        }
      }
      this._yAxes[i].computeStartAndStep(M);
    }
    if (this.mainViewPort.Lmargin == 0)
      this.mainViewPort.Lmargin = 5;
    if (this.mainViewPort.Rmargin == 0)
      this.mainViewPort.Rmargin = 5;
    for (let i = 0; i < this._yAxes.length; i++) {
      let sw = YGraph.DrawYAxis(this.mainViewPort, g, this._yAxes[i], 0, true);
      this.mainViewPort.Lmargin += this._yAxes[i].position == YAxis.HrzPosition.LEFT ? sw : 0;
      this.mainViewPort.Rmargin += this._yAxes[i].position == YAxis.HrzPosition.RIGHT ? sw : 0;
    }
    if (this._navigator.enabled) {
      if (lastLmargin != this.mainViewPort.Lmargin || lastRmargin != this.mainViewPort.Rmargin) {
        this.navigatorCache = null;
      }
      let nh = this._navigator.relativeheight * this.UIContainer.height / 100 >> 0;
      let ofset = this.xAxis.position == XAxis.VrtPosition.BOTTOM ? h : 0;
      this._navigator.setPosition(UIw, UIh, this.mainViewPort.Lmargin, this.mainViewPort.Rmargin, this.mainViewPort.Height - nh - this.mainViewPort.Bmargin + ofset, this.mainViewPort.Bmargin - ofset);
      this.mainViewPort.Bmargin += nh;
    }
    if (this.lastTopMargin != this.mainViewPort.Tmargin || this.lastBottomMargin != this.mainViewPort.Bmargin) {
      this._bgBrush = null;
      this.lastTopMargin = this.mainViewPort.Tmargin;
      this.lastBottomMargin = this.mainViewPort.Bmargin;
    }
    if (this._bgBrush == null) {
      this._bgBrush = new YLinearGradientBrush(this._bgColor2, this._bgColor1);
    }
    g.FillRectangleXYHW(this._bgBrush, this.mainViewPort.Lmargin, this.mainViewPort.Tmargin, this.mainViewPort.Width - this.mainViewPort.Rmargin - this.mainViewPort.Lmargin, this.mainViewPort.Height - this.mainViewPort.Bmargin - this.mainViewPort.Tmargin);
    if (this._borderThickness > 0) {
      if (this._borderPen == null)
        this._borderPen = new YPen(this._borderColor, this._borderThickness);
      g.DrawRectangleXYHW(this._borderPen, this.mainViewPort.Lmargin, this.mainViewPort.Tmargin, this.mainViewPort.Width - this.mainViewPort.Rmargin - this.mainViewPort.Lmargin, this.mainViewPort.Height - this.mainViewPort.Bmargin - this.mainViewPort.Tmargin);
    }
    g.SetClip(new YRectangle(this.mainViewPort.Lmargin, this.mainViewPort.Tmargin, this.mainViewPort.Width - this.mainViewPort.Rmargin - this.mainViewPort.Lmargin, this.mainViewPort.Height - this.mainViewPort.Bmargin - this.mainViewPort.Tmargin));
    for (let i = 0; i < this._yAxes.length; i++) {
      this.DrawYAxisZones(this.mainViewPort, g, this._yAxes[i]);
    }
    this.DrawXAxisZones(this.mainViewPort, g, this.xAxis);
    g.ResetClip();
    this.DrawXAxis(this.mainViewPort, g, this._xAxis, false);
    let leftOffset = 0;
    let rightOffset = 0;
    for (let i = 0; i < this._yAxes.length; i++) {
      let ww = YGraph.DrawYAxis(this.mainViewPort, g, this._yAxes[i], this._yAxes[i].position == YAxis.HrzPosition.LEFT ? leftOffset : rightOffset, false);
      if (this._yAxes[i].position == YAxis.HrzPosition.LEFT)
        leftOffset += ww;
      if (this._yAxes[i].position == YAxis.HrzPosition.RIGHT)
        rightOffset += ww;
    }
    g.SetClip(new YRectangle(this.mainViewPort.Lmargin, this.mainViewPort.Tmargin, this.mainViewPort.Width - this.mainViewPort.Rmargin - this.mainViewPort.Lmargin, this.mainViewPort.Height - this.mainViewPort.Bmargin - this.mainViewPort.Tmargin));
    this.mainViewPort.zoomx = (this.mainViewPort.Width - this.mainViewPort.Lmargin - this.mainViewPort.Rmargin) / (this._xAxis.max - this._xAxis.min);
    let mypenb = null;
    let lineCount = 0;
    let pointCount = 0;
    let Bottomleft = YGraph.ViewPortPointToIRL(this.mainViewPort, new Point(this.mainViewPort.Lmargin, this.mainViewPort.Height - this.mainViewPort.Bmargin));
    let TopRight = YGraph.ViewPortPointToIRL(this.mainViewPort, new Point(this.mainViewPort.Width - this.mainViewPort.Rmargin, this.mainViewPort.Tmargin));
    let xTimeStart = Bottomleft.x;
    let xTimeEnd = TopRight.x;
    let availabelPixelWidth = this.mainViewPort.Width - this.mainViewPort.Rmargin - this.mainViewPort.Lmargin;
    for (let k = 0; k < this._series.length; k++) {
      if (this._series[k].visible && !this._series[k].disabled && this._series[k].segments.length > 0) {
        let scaleIndex = this._series[k].yAxisIndex;
        mypenb = this._series[k].pen;
        this.mainViewPort.IRLy = this._yAxes[scaleIndex].startStopStep.dataMin;
        this._yAxes[this._series[k].yAxisIndex].IRLy = this.mainViewPort.IRLy;
        let delta = this._yAxes[scaleIndex].startStopStep.dataMax - this._yAxes[scaleIndex].startStopStep.dataMin;
        if (delta == 0) {
          delta = 1;
          this.mainViewPort.IRLy -= delta / 2;
        }
        this.mainViewPort.zoomy = (this.mainViewPort.Height - this.mainViewPort.Tmargin - this.mainViewPort.Bmargin) / delta;
        this._yAxes[this._series[k].yAxisIndex].zoom = this.mainViewPort.zoomy;
        g.comment("** main view-port series " + k.toString());
        let FirstSegmentIndexTmp = this.findSegmentIndex(k, xTimeEnd, false);
        let LastSegmentIndexTmp = this.findSegmentIndex(k, xTimeStart, false);
        let inside = true;
        let maxIndex = this._series[k].segments.length - 1;
        if (FirstSegmentIndexTmp < 0 && LastSegmentIndexTmp < 0) {
          inside = false;
        }
        if (FirstSegmentIndexTmp > maxIndex && LastSegmentIndexTmp > maxIndex) {
          inside = false;
        }
        if (inside) {
          let FirstSegmentIndex = Math.floor(FirstSegmentIndexTmp + 0.5);
          let LastSegmentIndex = Math.floor(LastSegmentIndexTmp);
          if (LastSegmentIndex < 0) {
            throw new Error("findSegmentIndex return an invalid index (" + LastSegmentIndex + ")");
          }
          if (FirstSegmentIndex < 0) {
            throw new Error("findSegmentIndex return an invalid index (" + FirstSegmentIndex + ")!");
          }
          if (FirstSegmentIndex > this._series[k].segments.length - 1) {
            throw new Error("findSegmentIndex return an invalid index (" + FirstSegmentIndex + ")!!");
          }
          if (LastSegmentIndex > this._series[k].segments.length - 1) {
            throw new Error("findSegmentIndex return an invalid index (" + LastSegmentIndex + ")!!!");
          }
          let firstDataIndex = this.findTimestampIndexInSegment(k, FirstSegmentIndex, xTimeEnd);
          let lastDataIndex = this.findTimestampIndexInSegment(k, LastSegmentIndex, xTimeStart);
          let totalPointsToDraw = 0;
          if (FirstSegmentIndex == LastSegmentIndex)
            totalPointsToDraw = firstDataIndex - lastDataIndex;
          else if (FirstSegmentIndex < LastSegmentIndex) {
            totalPointsToDraw = this._series[k].segments[LastSegmentIndex].count - lastDataIndex + firstDataIndex;
            for (let i = FirstSegmentIndex + 1; i < LastSegmentIndex; i++)
              totalPointsToDraw += this._series[k].segments[i].count;
          }
          let density = Math.round(totalPointsToDraw / availabelPixelWidth);
          if (density < SUMMARY_GRANULARITY || SUMMARY_GRANULARITY <= 0) {
            for (let i = 0; i < this._series[k].segments.length; i++) {
              lineCount += YGraph.DoSegmentRendering(this.mainViewPort, g, mypenb, this._series[k].segments[i].data, this._series[k].segments[i].count, xTimeStart, xTimeEnd);
              pointCount += this._series[k].segments[i].count;
            }
          } else {
            let level = Math.floor(Math.log(density) / Math.log(SUMMARY_GRANULARITY)) - 1;
            let s = this._series[k].summaries[level];
            let finalpoint = null;
            for (let i = 0; i < s.segments.length; i++) {
              if (i == s.segments.length - 1) {
                finalpoint = s.getBufferpoint();
              }
              lineCount += YGraph.DoSummarySegmentRendering(this.mainViewPort, g, mypenb, s.segments[i].data, s.segments[i].ptCount, finalpoint, xTimeStart, xTimeEnd);
              pointCount += s.segments[i].ptCount;
            }
          }
        } else
          console.log("Data are ouside dataview");
      }
    }
    g.ResetClip();
    if (this._navigator.enabled) {
      g.comment("** navigator **");
      let v = this._navigator.viewport;
      let range = MinMaxHandler.DefaultValue();
      for (let i = 0; i < this._series.length; i++) {
        if (!this._series[i].disabled)
          range = MinMaxHandler.Combine(range, this._series[i].timeRange);
      }
      this._navigator.Xrange = MinMaxHandler.extend(range, 1.05);
      v.zoomx = (v.Width - v.Lmargin - v.Rmargin) / (this._navigator.Xrange.Max - this._navigator.Xrange.Min);
      if (this.lastPointCount != pointCount && !this.mainViewPort.Capture && !this._navigator.Capture || this.navigatorCache == null || g instanceof YGraphicsSVG) {
        g.comment("Redraw navigator");
        if (this.navigatorCache != null)
          this.navigatorCache = null;
        this.navigatorCache = document.createElement("canvas");
        this.navigatorCache.width = v.Width;
        this.navigatorCache.height = v.Height;
        this.lastPointCount = pointCount;
        let ng;
        if (g instanceof YGraphicsSVG) {
          ng = g;
        } else {
          ng = new YGraphics(this.navigatorCache, v.Width, v.Height, 90);
        }
        ng.SetClip(new YRectangle(v.Lmargin, v.Tmargin, v.Width - v.Rmargin - v.Lmargin, v.Height - v.Bmargin - v.Tmargin));
        ng.FillRectangleXYHW(this._navigator.bgBrush, v.Lmargin, v.Tmargin, v.Width - v.Rmargin - v.Lmargin, v.Height - v.Bmargin - v.Tmargin);
        if (this.xAxis.zones.length > 0 && this._navigator.showXAxisZones) {
          let delta = this._navigator.Xrange.Max - this._navigator.Xrange.Min;
          let XZoom = delta / (v.Width - v.Lmargin - v.Rmargin);
          for (let i = 0; i < this.xAxis.zones.length; i++) {
            if (this.xAxis.zones[i].visible) {
              let min = this.xAxis.zones[i].min;
              let max = this.xAxis.zones[i].max;
              if (isNaN(min))
                min = this._navigator.Xrange.Min;
              if (isNaN(max))
                max = this._navigator.Xrange.Max;
              ng.FillRectangleXYHW(this.xAxis.zones[i].zoneBrush, v.Lmargin + (min - this._navigator.Xrange.Min) / XZoom >> 0, v.Tmargin >> 0, (max - min) / XZoom >> 0, v.Height - v.Bmargin - v.Tmargin);
            }
          }
        }
        if (MinMaxHandler.isDefined(this._navigator.Xrange) && this._navigator.Xrange.Max - this._navigator.Xrange.Min > 0) {
          let Min;
          let Max;
          v.IRLx = this._navigator.Xrange.Min;
          let dontSticktoBorderZoom = 4 / (v.Height - v.Bmargin - v.Tmargin);
          let Bottomleft2 = YGraph.ViewPortPointToIRL(v, new Point(v.Lmargin, v.Height - v.Bmargin));
          let TopRight2 = YGraph.ViewPortPointToIRL(v, new Point(v.Width - v.Rmargin, v.Tmargin));
          let xTimeStart2 = Bottomleft2.x;
          let xTimeEnd2 = TopRight2.x;
          if (this._navigator.yAxisHandling == Navigator.YAxisHandling.AUTO) {
            for (let k = 0; k < this._series.length; k++) {
              if (!this._series[k].disabled) {
                ng.comment("** navigator series " + k.toString());
                v.IRLy = this._series[k].valueRange.Min;
                let yAxisIndex = this._series[k].yAxisIndex;
                mypenb = this._series[k].navigatorpen;
                Min = this._series[k].valueRange.Min;
                Max = this._series[k].valueRange.Max;
                if (Max - Min <= 0) {
                  v.IRLy = Min - 0.5;
                  Max = Min + 0.5;
                } else {
                  let delta = Max - Min;
                  Min -= delta * dontSticktoBorderZoom;
                  Max += delta * dontSticktoBorderZoom;
                }
                v.IRLy = Min;
                v.zoomy = (v.Height - v.Tmargin - v.Bmargin) / (Max - Min);
                let availableWidth = v.Width - v.Lmargin - v.Rmargin;
                let totalPoint = 0;
                for (let i = 0; i < this._series[k].segments.length; i++)
                  totalPoint += this._series[k].segments[i].count;
                let density = Math.round(totalPoint / availableWidth);
                if (density < SUMMARY_GRANULARITY || SUMMARY_GRANULARITY <= 0) {
                  for (let i = 0; i < this._series[k].segments.length; i++) {
                    lineCount += YGraph.DoSegmentRendering(v, ng, mypenb, this._series[k].segments[i].data, this._series[k].segments[i].count, xTimeStart2, xTimeEnd2);
                  }
                } else {
                  let level = Math.floor(Math.log(density) / Math.log(SUMMARY_GRANULARITY)) - 1;
                  let s = this._series[k].summaries[level];
                  let finalpoint = null;
                  for (let i = 0; i < s.segments.length; i++) {
                    if (i == s.segments.length - 1)
                      finalpoint = s.getBufferpoint();
                    lineCount += YGraph.DoSummarySegmentRendering(v, ng, mypenb, s.segments[i].data, s.segments[i].ptCount, finalpoint, xTimeStart2, xTimeEnd2);
                  }
                }
              }
            }
          } else {
            for (let i = 0; i < this._yAxes.length; i++) {
              let Yrange = MinMaxHandler.DefaultValue();
              for (let j = 0; j < this._series.length; j++) {
                if (this._series[j].yAxisIndex == i && !this._series[j].disabled) {
                  Yrange = MinMaxHandler.Combine(Yrange, this._series[j].valueRange);
                }
              }
              Yrange = MinMaxHandler.extend(Yrange, 1 + 2 * dontSticktoBorderZoom);
              Min = this._yAxes[i].min;
              if (isNaN(Min))
                Min = Yrange.Min;
              Max = this._yAxes[i].max;
              if (isNaN(Max))
                Max = Yrange.Max;
              if (Number.isNaN(Min)) {
                Min = 0;
                Max = 1;
              }
              if (Max - Min <= 0) {
                Min = Min - 0.5;
                Max = Min + 0.5;
              }
              v.IRLy = Min;
              v.zoomy = (v.Height - v.Tmargin - v.Bmargin) / (Max - Min);
              for (let j = 0; j < this._series.length; j++) {
                if (this._series[j].yAxisIndex == i && !this._series[j].disabled && this._series[j].visible) {
                  ng.comment("** navigator series " + j.toString());
                  mypenb = this._series[j].navigatorpen;
                  let availableWidth = v.Width - v.Lmargin - v.Rmargin;
                  let totalPoint = 0;
                  for (let i2 = 0; i2 < this._series[j].segments.length; i2++)
                    totalPoint += this._series[j].segments[i2].count;
                  let density = Math.round(totalPoint / availableWidth);
                  if (density < SUMMARY_GRANULARITY || SUMMARY_GRANULARITY <= 0) {
                    for (let i2 = 0; i2 < this._series[j].segments.length; i2++) {
                      lineCount += YGraph.DoSegmentRendering(v, ng, mypenb, this._series[j].segments[i2].data, this._series[j].segments[i2].count, xTimeStart2, xTimeEnd2);
                    }
                  } else {
                    let level = Math.floor(Math.log(density) / Math.log(SUMMARY_GRANULARITY)) - 1;
                    console.log("Navigator (YAXIS=INHERIT), Serie " + j + ", density is ~" + density + "pts/pixel drawing summarized data level " + level);
                    let s = this._series[j].summaries[level];
                    let finalpoint = null;
                    for (let i2 = 0; i2 < s.segments.length; i2++) {
                      if (i2 == s.segments.length - 1)
                        finalpoint = s.getBufferpoint();
                      lineCount += YGraph.DoSummarySegmentRendering(v, ng, mypenb, s.segments[i2].data, s.segments[i2].ptCount, finalpoint, xTimeStart2, xTimeEnd2);
                    }
                  }
                }
              }
            }
          }
          for (let i = 0; i < this._xAxis.markers.length; i++) {
            if (this._xAxis.markers[i].enabled) {
              let p = YGraph.IRLPointToViewPort(v, new pointXY(this._xAxis.markers[i].xposition + (this._xAxis.markers[i].timereference == TimeConverter.TimeReference.RELATIVE ? this._xAxis.zeroTime : 0), 0));
              ng.DrawLineXY(this._xAxis.markers[i].navigatorpen, p.X, v.Tmargin, p.X, v.Height - v.Bmargin);
            }
          }
          if (this._navigator.borderThickness > 0) {
            ng.DrawLineXY(this._navigator.borderPen, v.Lmargin, v.Tmargin, v.Width - v.Rmargin, v.Tmargin);
          }
          this.DrawMonitorXAxis(v, ng, this._navigator.Xrange, this.xAxis.labelFormat);
          this._navigator.setIRLPosition(v.IRLx, v.IRLy, v.zoomx, v.zoomy);
        }
        ng.ResetClip();
        if (!(g instanceof YGraphicsSVG))
          ng.Dispose();
      }
      let cacheW = v.Width - v.Rmargin - v.Lmargin + 1;
      let cacheH = v.Width - v.Rmargin - v.Lmargin + 1;
      let rectsrc = new YRectangle(v.Lmargin, v.Tmargin - 1, cacheW, cacheH);
      let rectdst = new YRectangle(v.Lmargin, v.Tmargin, cacheW, cacheH);
      g.SetClip(rectdst);
      if (!(g instanceof YGraphicsSVG)) {
        g.DrawImage(this.navigatorCache, rectsrc, rectdst, 2);
      }
      if (this._navigator.borderThickness > 0) {
        g.DrawLineXY(this._navigator.borderPen, v.Lmargin + 1, v.Tmargin, v.Lmargin + 1, v.Height - v.Bmargin - 1);
        g.DrawLineXY(this._navigator.borderPen, v.Width - v.Rmargin, v.Tmargin, v.Width - v.Rmargin, v.Height - v.Bmargin - 1);
        g.DrawLineXY(this._navigator.borderPen, v.Lmargin + 1, v.Tmargin, v.Width - v.Rmargin, v.Tmargin);
      }
      let IRLCursorStart = YGraph.ViewPortPointToIRL(this.mainViewPort, new Point(this.mainViewPort.Lmargin, 0));
      let IRLCursorEnd = YGraph.ViewPortPointToIRL(this.mainViewPort, new Point(this.mainViewPort.Width - this.mainViewPort.Rmargin, 0));
      let CursorStart = YGraph.IRLPointToViewPort(this._navigator.viewport, new pointXY(IRLCursorStart.x, 0));
      let CursorEnd = YGraph.IRLPointToViewPort(this._navigator.viewport, new pointXY(IRLCursorEnd.x, 0));
      g.FillRectangle(this._navigator.cursorBrush, new YRectangle(CursorStart.X - 1, v.Tmargin, CursorEnd.X - CursorStart.X + 2, v.Height - v.Bmargin - v.Tmargin - 1));
      g.DrawLineXY(this._navigator.cursorBorderPen, CursorStart.X - 1 >> 0, v.Tmargin >> 0, CursorStart.X - 1 >> 0, v.Height - v.Bmargin - 1);
      g.DrawLineXY(this._navigator.cursorBorderPen, CursorEnd.X + 1 >> 0, v.Tmargin >> 0, CursorEnd.X + 1 >> 0, v.Height - v.Bmargin - 1);
      g.ResetClip();
    }
    if (this._legendPanel.overlap)
      this.drawLegendPanel(g, UIw, UIh, this.mainViewPort);
    g.TextRenderingHint = YTextRenderingHint.SingleBitPerPixelGridFit;
    this.DrawMarkers(this.mainViewPort, g, this.xAxis, UIw, UIh);
    this.drawAnnotationPanels(g, this._annotationPanels, UIw, UIh, true, this.mainViewPort);
    this.DrawDataPanels(this.mainViewPort, g, this.xAxis, this._yAxes, UIw, UIh);
    this.DrawDataTracker(g, UIw, UIh, this.xAxis);
    this.DrawMessagePanels(g, UIw, UIh);
    return 0;
  }
  KeyDown(sender, e) {
    if (e.code == "ArrowLeft") {
      let delta = 0.2 * (this._xAxis.max - this._xAxis.min);
      this._xAxis.set_minMax(this._xAxis.min - delta, this._xAxis.max - delta);
      this.redraw();
    }
    if (e.code == "ArrowRight") {
      let delta = 0.2 * (this._xAxis.max - this._xAxis.min);
      this._xAxis.set_minMax(this._xAxis.min + delta, this._xAxis.max + delta);
      this.redraw();
    }
    if (e.code == "ArrowUp") {
      this.mouseWheel(new Point(this.UIContainer.width >> 1, this.UIContainer.height >> 1), 10);
    }
    if (e.code == "ArrowDown") {
      this.mouseWheel(new Point(this.UIContainer.width >> 1, this.UIContainer.height >> 1), -10);
    }
  }
  mouseWheel(pos, delta) {
    let ZoomFactor = Math.pow(1.25, delta / 120);
    let NextZoomX = this.mainViewPort.zoomx * ZoomFactor;
    if (NextZoomX > this.mainViewPort.zoomx && NextZoomX > 1e3)
      return;
    let currentRange = this._xAxis.max - this._xAxis.min;
    if (currentRange / ZoomFactor > 25 * 365 * 86400)
      return;
    this.mainViewPort.IRLx += (pos.X - this.mainViewPort.Lmargin) / this.mainViewPort.zoomx - (pos.X - this.mainViewPort.Lmargin) / NextZoomX;
    let range = this._xAxis.max - this._xAxis.min;
    this._xAxis.set_minMax(this.mainViewPort.IRLx, this.mainViewPort.IRLx + range / ZoomFactor);
    this.mainViewPort.zoomx = NextZoomX;
    this.redraw();
  }
  mouseWheelEvent(sender, e) {
    let p = this.Scr2ElmMatrix.multiplyByV(Vector3.FromXYCoord(e.pageX, e.pageY)).toPoint();
    let eX = p.X;
    let eY = p.Y;
    this.mouseWheel(new Point(eX, eY), e.deltaY > 0 ? -150 : 150);
    e.preventDefault();
  }
};
YGraph._defaultVerticalDragZoomEnabled = false;
YGraph.captureCursor = null;

// obj/full/Renderer/YSolidGauge.js
var DrawPrameters = class {
  constructor() {
    this.outerRadius = 0;
    this.innerRadius = 0;
    this.angleStart = 0;
    this.angleEnd = 0;
    this.ycenter = 0;
    this.xcenter = 0;
    this.heightTop = 0;
    this.heightBottom = 0;
    this.valueRectangle = new YRectangle(0, 0, 0, 0);
    this.valueFormat = new YStringFormat(16384);
    this.minValueRectangle = new YRectangle(0, 0, 0, 0);
    this.minValueFormat = new YStringFormat(16384);
    this.maxValueRectangle = new YRectangle(0, 0, 0, 0);
    this.maxValueFormat = new YStringFormat(16384);
    this.minValue = "";
    this.maxValue = "";
    this.value = "";
  }
};
var YSolidGauge = class extends YDataRenderer {
  get min() {
    return this._min;
  }
  set min(value) {
    if (value >= this._max && !YDataRenderer.minMaxCheckDisabled) {
      throw new RangeError("Min cannot be greater than max (" + this._max.toString() + ")");
    }
    this._min = value;
    if (this._shownValue < this._min)
      this._shownValue = this._min;
    this.redraw();
  }
  get max() {
    return this._max;
  }
  set max(value) {
    if (value <= this._min && !YDataRenderer.minMaxCheckDisabled) {
      throw new RangeError("Max cannot be less than min (" + this._min.toString() + ")");
    }
    this._max = value;
    if (this._shownValue > this._max)
      this._shownValue = this._max;
    this.redraw();
  }
  get borderpen() {
    if (this._borderpen == null) {
      this._borderpen = new YPen(this._borderColor, this._borderThickness);
      this._borderpen.startCap = 1;
      this._borderpen.endCap = 1;
    }
    return this._borderpen;
  }
  get borderColor() {
    return this._borderColor;
  }
  set borderColor(value) {
    this._borderColor = value;
    this._borderpen = null;
    this.redraw();
  }
  get backgroundColor1() {
    return this._backgroundColor1;
  }
  set backgroundColor1(value) {
    this._backgroundColor1 = value;
    this._bgBrush = null;
    this.redraw();
  }
  get backgroundColor2() {
    return this._backgroundColor2;
  }
  set backgroundColor2(value) {
    this._backgroundColor2 = value;
    this._bgBrush = null;
    this.redraw();
  }
  get borderThickness() {
    return this._borderThickness;
  }
  set borderThickness(value) {
    if (value < 0)
      throw new RangeError("Thickness must be a positive value");
    this._borderThickness = value;
    this._borderpen = null;
    this._path = null;
    this.redraw();
  }
  get valueFormater() {
    return this._valueFormater;
  }
  set valueFormater(value) {
    this._valueFormater = value;
    this.redraw();
  }
  get minmaxFormater() {
    return this._minmaxFormater;
  }
  set minmaxFormater(value) {
    this._minmaxFormater = value;
    this.redraw();
  }
  get thickness() {
    return this._thickness;
  }
  set thickness(value) {
    if (value < 0)
      throw new RangeError("Thickness must be a positive value");
    this._thickness = Math.max(Math.min(value, 80), 1);
    this._path = null;
    this.redraw();
  }
  get maxSpeed() {
    return this._maxSpeed;
  }
  set maxSpeed(value) {
    if (value <= 0)
      throw new RangeError("Speed must be a positive value");
    this._maxSpeed = value;
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value;
    this.redraw();
  }
  get color1() {
    return this._color1;
  }
  set color1(value) {
    this._color1 = value;
    this.redraw();
  }
  get color2() {
    return this._color2;
  }
  set color2(value) {
    this._color2 = value;
    this.redraw();
  }
  get font() {
    return this._font;
  }
  get minMaxFont() {
    return this._minMaxFont;
  }
  get showMinMax() {
    return this._showMinMax;
  }
  set showMinMax(value) {
    this._showMinMax = value;
    this._path = null;
    this.redraw();
  }
  get displayMode() {
    return this._displayMode;
  }
  set displayMode(value) {
    this._displayMode = value;
    this._path = null;
    this._bgBrush = null;
    this.redraw();
  }
  FontsizeChange(source) {
    this._path = null;
  }
  constructor(UIContainer, mode, logFunction) {
    super(UIContainer, logFunction);
    this._shownValue = 0;
    this._min = 0;
    this._max = 100;
    this.SegmentMaxLength = 8;
    this.mainViewPort = new ViewPortSettings();
    this._borderpen = null;
    this._borderColor = YColor.Black;
    this._bgBrush = null;
    this._backgroundColor1 = YColor.FromArgb(255, 240, 240, 240);
    this._backgroundColor2 = YColor.FromArgb(255, 200, 200, 200);
    this._borderThickness = 5;
    this._valueFormater = null;
    this._minmaxFormater = null;
    this._thickness = 25;
    this._maxSpeed = 0.1;
    this._value = 0;
    this._color1 = YColor.Green;
    this._color2 = YColor.Red;
    this._font = null;
    this._minMaxFont = null;
    this._showMinMax = true;
    this._path = null;
    this.lastDrawParameters = new DrawPrameters();
    this._displayMode = YSolidGauge.DisplayMode.DISPLAY90;
    this._minMaxFont = new YFont(this, this, Math.min(UIContainer.width, UIContainer.height) / 15, () => {
      this.FontsizeChange(this._minMaxFont);
    });
    this._displayMode = mode;
    this._font = new YFont(this, this, Math.min(UIContainer.width, UIContainer.height) / 5, null);
    this.resizeRule = Proportional.ResizeRule.RELATIVETOBOTH;
    let g = new YGraphics(UIContainer, UIContainer.width, UIContainer.height, 90);
    let p = this.ComputeDrawParameters(g, UIContainer.width, UIContainer.height, this.mainViewPort);
    g.Dispose();
  }
  clearCachedObjects() {
    this._bgBrush = null;
    this._path = null;
  }
  ComputeDrawParameters(g, UIw, UIh, mainViewPort) {
    UIw -= mainViewPort.Lmargin + mainViewPort.Rmargin;
    UIh -= mainViewPort.Tmargin + mainViewPort.Bmargin;
    let w = UIw - 5 - this._borderThickness;
    let h = UIh - 5 - this._borderThickness;
    let xcenter = UIw / 2;
    let outerRadius = 0;
    let angleStart = 0;
    let angleEnd = 0;
    let ycenter = 0;
    let ValueRectangle = new YRectangle(0, 0, 0, 0);
    let valueFormat = new YStringFormat(16384);
    let innerRadius = 0;
    let minMaxHeight = 0;
    let s1 = new YSizeF(null, "");
    let s2 = new YSizeF(null, "");
    this.lastDrawParameters.value = this._valueFormater == null ? this._value.toFixed(0) : this._valueFormater(this, this._value);
    if (this._showMinMax) {
      this.lastDrawParameters.minValue = this._minmaxFormater == null ? this._min.toFixed(0) : this._minmaxFormater(this, this._min);
      this.lastDrawParameters.maxValue = this._minmaxFormater == null ? this._max.toFixed(0) : this._minmaxFormater(this, this._max);
      s1 = g.MeasureString(this.lastDrawParameters.minValue, this._minMaxFont, 1e5);
      s2 = g.MeasureString(this.lastDrawParameters.maxValue, this._minMaxFont, 1e5);
      this.lastDrawParameters.minValueFormat = new YStringFormat(16384);
      this.lastDrawParameters.maxValueFormat = new YStringFormat(16384);
      minMaxHeight = s1.height;
      if (s2.height > minMaxHeight)
        minMaxHeight = s2.height;
    }
    switch (this._displayMode) {
      case YSolidGauge.DisplayMode.DISPLAY90:
        h = h - minMaxHeight;
        w = w - minMaxHeight;
        outerRadius = w;
        if (outerRadius > h - this._borderThickness)
          outerRadius = h - this.borderThickness;
        if (outerRadius > w - this.borderThickness)
          outerRadius = w - this.borderThickness;
        angleStart = Math.PI / 2;
        angleEnd = Math.PI;
        this.lastDrawParameters.heightTop = outerRadius;
        this.lastDrawParameters.heightBottom = 0;
        ycenter = mainViewPort.Tmargin + h;
        xcenter = mainViewPort.Lmargin + UIw / 2 + outerRadius / 2 - minMaxHeight + this._borderThickness;
        innerRadius = outerRadius * (100 - this._thickness) / 100;
        ValueRectangle = new YRectangle(xcenter - innerRadius >> 0, ycenter - innerRadius >> 0, innerRadius >> 0, innerRadius >> 0);
        valueFormat.Alignment = 2;
        valueFormat.LineAlignment = 2;
        if (this._showMinMax) {
          this.lastDrawParameters.minValueRectangle = new YRectangle(xcenter - (outerRadius + innerRadius + s1.width) / 2 >> 0, ycenter + this._borderThickness >> 0, s1.width + 1 >> 0, minMaxHeight + 1 >> 0);
          this.lastDrawParameters.minValueFormat.Alignment = 0;
          this.lastDrawParameters.minValueFormat.LineAlignment = 0;
          this.lastDrawParameters.maxValueRectangle = new YRectangle(xcenter + this._borderThickness >> 0, ycenter - outerRadius + (outerRadius - innerRadius - s2.width) / 2 >> 0, minMaxHeight + 1 >> 0, s2.width + 1 >> 0);
          this.lastDrawParameters.maxValueFormat.Alignment = 0;
          this.lastDrawParameters.maxValueFormat.LineAlignment = 0;
          this.lastDrawParameters.maxValueFormat.FormatFlags = 2;
        }
        break;
      case YSolidGauge.DisplayMode.DISPLAY180:
        h = h - minMaxHeight;
        let s0 = new YSizeF(null, "");
        s0 = g.MeasureString(this.lastDrawParameters.value, this._font, 1e5);
        outerRadius = w / 2 - this.borderThickness;
        if (outerRadius > h - this._borderThickness)
          outerRadius = h - this._borderThickness;
        if (outerRadius > w - this.borderThickness)
          outerRadius = w - this.borderThickness;
        angleStart = 0;
        angleEnd = Math.PI;
        ycenter = outerRadius + this._borderThickness / 2;
        innerRadius = outerRadius * (100 - this._thickness) / 100;
        this.lastDrawParameters.heightTop = outerRadius;
        this.lastDrawParameters.heightBottom = 0;
        ValueRectangle = new YRectangle(xcenter - innerRadius >> 0, ycenter + this._borderThickness + minMaxHeight - s0.height >> 0, 2 * innerRadius >> 0, s0.height + 1 >> 0);
        valueFormat.Alignment = 1;
        valueFormat.LineAlignment = 2;
        if (this._showMinMax) {
          this.lastDrawParameters.minValueRectangle = new YRectangle(xcenter - (outerRadius + innerRadius + s1.width) / 2 >> 0, ycenter + this._borderThickness >> 0, s1.width + 1 >> 0, minMaxHeight + 1 >> 0);
          this.lastDrawParameters.minValueFormat.Alignment = 0;
          this.lastDrawParameters.minValueFormat.LineAlignment = 0;
          this.lastDrawParameters.maxValueRectangle = new YRectangle(xcenter + (outerRadius + innerRadius - s2.width) / 2 >> 0, ycenter + this._borderThickness >> 0, s2.width + 1 >> 0, minMaxHeight + 1 >> 0);
          this.lastDrawParameters.maxValueFormat.Alignment = 0;
          this.lastDrawParameters.maxValueFormat.LineAlignment = 0;
        }
        break;
      case YSolidGauge.DisplayMode.DISPLAY270:
        outerRadius = w;
        if (outerRadius > h / 2)
          outerRadius = h / 2;
        if (outerRadius > w / 2)
          outerRadius = w / 2;
        this.lastDrawParameters.heightTop = outerRadius;
        this.lastDrawParameters.heightBottom = outerRadius;
        angleStart = 0;
        angleEnd = 3 * Math.PI / 2;
        ycenter = mainViewPort.Tmargin + UIh / 2;
        innerRadius = outerRadius * (100 - this._thickness) / 100;
        ValueRectangle = new YRectangle(xcenter - innerRadius >> 0, ycenter - innerRadius >> 0, 2 * innerRadius >> 0, 2 * innerRadius >> 0);
        valueFormat.Alignment = 1;
        valueFormat.LineAlignment = 1;
        if (this._showMinMax) {
          this.lastDrawParameters.minValueRectangle = new YRectangle(xcenter + this._borderThickness >> 0, ycenter + (innerRadius + innerRadius + s1.height) / 2 >> 0, s1.width + 1 >> 0, s1.height + 1 >> 0);
          this.lastDrawParameters.minValueFormat.Alignment = 0;
          this.lastDrawParameters.minValueFormat.LineAlignment = 0;
          this.lastDrawParameters.maxValueRectangle = new YRectangle(xcenter + (innerRadius + innerRadius + s1.height) / 2 >> 0, ycenter + this._borderThickness >> 0, s2.height + 1 >> 0, s2.width + 1 >> 0);
          this.lastDrawParameters.maxValueFormat.Alignment = 0;
          this.lastDrawParameters.maxValueFormat.LineAlignment = 0;
          this.lastDrawParameters.maxValueFormat.FormatFlags = 2;
        }
        break;
      case YSolidGauge.DisplayMode.DISPLAY360:
        outerRadius = w;
        if (outerRadius > h / 0.85 / 2)
          outerRadius = h / 0.85 / 2;
        if (outerRadius > w / 2)
          outerRadius = w / 2;
        this.lastDrawParameters.heightTop = outerRadius;
        this.lastDrawParameters.heightBottom = outerRadius * 0.7;
        ycenter = mainViewPort.Tmargin + outerRadius + this._borderThickness / 2;
        angleStart = -Math.PI / 4;
        angleEnd = 5 * Math.PI / 4;
        innerRadius = outerRadius * (100 - this._thickness) / 100;
        ValueRectangle = new YRectangle(xcenter - innerRadius >> 0, ycenter - innerRadius >> 0, 2 * innerRadius >> 0, 2 * innerRadius >> 0);
        valueFormat.Alignment = 1;
        valueFormat.LineAlignment = 1;
        if (this._showMinMax) {
          let dx = Math.abs(innerRadius * Math.cos(angleStart));
          let dy = innerRadius * Math.abs(Math.sin(angleStart)) + 2 * Math.abs((outerRadius - innerRadius) * Math.sin(angleStart) / 3);
          this.lastDrawParameters.minValueRectangle = new YRectangle(xcenter - dx >> 0, ycenter + dy - minMaxHeight / 2 >> 0, s1.width + 1 >> 0, minMaxHeight + 1 >> 0);
          this.lastDrawParameters.minValueFormat.Alignment = 0;
          this.lastDrawParameters.minValueFormat.LineAlignment = 1;
          this.lastDrawParameters.maxValueRectangle = new YRectangle(xcenter + dx - s2.width >> 0, ycenter + dy - minMaxHeight / 2 >> 0, s2.width + 1 >> 0, minMaxHeight + 1 >> 0);
          this.lastDrawParameters.maxValueFormat.Alignment = 0;
          this.lastDrawParameters.maxValueFormat.LineAlignment = 1;
        }
        break;
    }
    this.lastDrawParameters.outerRadius = outerRadius;
    this.lastDrawParameters.innerRadius = innerRadius;
    this.lastDrawParameters.angleStart = angleStart;
    this.lastDrawParameters.angleEnd = angleEnd;
    this.lastDrawParameters.ycenter = ycenter;
    this.lastDrawParameters.xcenter = xcenter;
    this.lastDrawParameters.valueRectangle = ValueRectangle;
    this.lastDrawParameters.valueFormat = valueFormat;
    return this.lastDrawParameters;
  }
  Render(g, w, h) {
    this.mainViewPort = new ViewPortSettings();
    g.SmoothingMode = YSmoothingMode.HighQuality;
    g.TextRenderingHint = YTextRenderingHint.AntiAlias;
    this.drawAnnotationPanels(g, this._annotationPanels, w, h, false, this.mainViewPort);
    let p = this.ComputeDrawParameters(g, w, h, this.mainViewPort);
    if (this._path == null) {
      let outterlength = 2 * p.outerRadius * Math.PI * (p.angleEnd - p.angleStart) / (2 * Math.PI);
      let stepCount = outterlength / this.SegmentMaxLength >> 0;
      let stepsize = (p.angleEnd - p.angleStart) / stepCount;
      this._path = new Array(2 * (stepCount + 1));
      let n = 0;
      for (let i = 0; i <= stepCount; i++) {
        let a = p.angleStart + i * stepsize;
        this._path[n++] = new PointF(p.xcenter + p.outerRadius * Math.cos(a), p.ycenter - p.outerRadius * Math.sin(a));
      }
      for (let i = stepCount; i >= 0; i--) {
        let a = p.angleStart + i * stepsize;
        this._path[n++] = new PointF(p.xcenter + p.innerRadius * Math.cos(a), p.ycenter - p.innerRadius * Math.sin(a));
      }
    }
    if (this._bgBrush == null) {
      this._bgBrush = new YLinearGradientBrush(this._backgroundColor1, this._backgroundColor2);
    }
    if (this._borderpen == null) {
      this._borderpen = new YPen(this._borderColor, this._borderThickness);
      this._borderpen.linejoin = YPen.LineJoin.Round;
    }
    g.FillPolygon(this._bgBrush, this._path);
    if (this._shownValue != this._value) {
      let step = this._maxSpeed * (this._max - this._min) / 100;
      if (Math.abs(this._value - this._shownValue) < step) {
        this._shownValue = this._value;
      } else if (this._shownValue < this._value) {
        this._shownValue += step;
      } else {
        this._shownValue -= step;
      }
    }
    let v = this._shownValue;
    if (v >= this._min) {
      if (v > this._max)
        v = this._max;
      let valueFactor = (v - this._min) / (this._max - this.min);
      let angleValue = p.angleStart + (p.angleEnd - p.angleStart) * valueFactor;
      let outterlength = 2 * p.outerRadius * Math.PI * (angleValue - p.angleStart) / (2 * Math.PI);
      let stepCount = outterlength / this.SegmentMaxLength >> 0;
      let stepsize = (angleValue - p.angleStart) / stepCount;
      let pt = new Array(2 * (stepCount + 1));
      let n = 0;
      for (let i = 0; i <= stepCount; i++) {
        let a = p.angleEnd - i * stepsize;
        pt[n++] = new PointF(p.xcenter + p.outerRadius * Math.cos(a), p.ycenter - p.outerRadius * Math.sin(a));
      }
      for (let i = stepCount; i >= 0; i--) {
        let a = p.angleEnd - i * stepsize;
        pt[n++] = new PointF(p.xcenter + p.innerRadius * Math.cos(a), p.ycenter - p.innerRadius * Math.sin(a));
      }
      let b;
      if (this._color1 == this._color2) {
        b = new YSolidBrush(this._color1);
      } else {
        let A1 = this._color1.alpha;
        let H1 = this._color1.hue;
        let S1 = this._color1.saturation;
        let L1 = this._color1.luminosity;
        let A2 = this._color2.alpha;
        let H2 = this._color2.hue;
        let S2 = this._color2.saturation;
        let L2 = this._color2.luminosity;
        let A = Math.round(A1 + (A2 - A1) * valueFactor) >> 0 & 255;
        let H;
        if (Math.abs(H2 - H1) <= 127) {
          H = H1 + (H2 - H1) * valueFactor >> 0;
        } else {
          H = H1 + 256 + (H2 - H1 + 256) * valueFactor >> 0;
          if (H > 256)
            H -= 256;
        }
        let S = S1 + (S2 - S1) * valueFactor >> 0;
        let L = L1 + (L2 - L1) * valueFactor >> 0;
        b = new YSolidBrush(new YColor(true, A, H, S, L));
      }
      g.FillPolygon(b, pt);
    }
    if (this._borderThickness > 0)
      g.DrawPolygon(this._borderpen, this._path);
    g.DrawStringRect(this.lastDrawParameters.value, this._font, this._font.brush, p.valueRectangle, p.valueFormat);
    if (this._showMinMax) {
      g.DrawStringRect(this.lastDrawParameters.minValue, this._minMaxFont, this._minMaxFont.brush, this.lastDrawParameters.minValueRectangle, this.lastDrawParameters.minValueFormat);
      g.DrawStringRect(this.lastDrawParameters.maxValue, this._minMaxFont, this._minMaxFont.brush, this.lastDrawParameters.maxValueRectangle, this.lastDrawParameters.maxValueFormat);
    }
    this.drawAnnotationPanels(g, this._annotationPanels, w, h, true, this.mainViewPort);
    this.DrawMessagePanels(g, w, h);
    return 0;
  }
  renderingPostProcessing() {
    if (this._shownValue != this._value)
      this.redraw();
  }
};
(function(YSolidGauge2) {
  class DisplayModeEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, DisplayMode);
    }
  }
  YSolidGauge2.DisplayModeEnumItem = DisplayModeEnumItem;
  class DisplayMode extends YEnum {
  }
  DisplayMode.DISPLAY90 = new DisplayModeEnumItem("DISPLAY90", "90\xB0");
  DisplayMode.DISPLAY180 = new DisplayModeEnumItem("DISPLAY180", "180\xB0");
  DisplayMode.DISPLAY270 = new DisplayModeEnumItem("DISPLAY270", "270\xB0");
  DisplayMode.DISPLAY360 = new DisplayModeEnumItem("DISPLAY360", "360\xB0");
  YSolidGauge2.DisplayMode = DisplayMode;
})(YSolidGauge || (YSolidGauge = {}));

// obj/full/Api/yocto_api.js
var YAPI_SUCCESS = 0;
var YAPI_INVALID_ARGUMENT = -2;
var YAPI_NOT_SUPPORTED = -3;
var YAPI_DEVICE_NOT_FOUND = -4;
var YAPI_VERSION_MISMATCH = -5;
var YAPI_DEVICE_BUSY = -6;
var YAPI_TIMEOUT = -7;
var YAPI_IO_ERROR = -8;
var YAPI_UNAUTHORIZED = -12;
var YAPI_FILE_NOT_FOUND = -14;
var YAPI_INVALID_INT = 2147483647;
var YAPI_INVALID_UINT = -1;
var YAPI_INVALID_LONG = 9223372036854776e3;
var YAPI_INVALID_DOUBLE = -Number.MAX_VALUE;
var YAPI_INVALID_STRING = "!INVALID!";
var YAPI_MIN_DOUBLE = -Number.MAX_VALUE;
var YAPI_MAX_DOUBLE = Number.MAX_VALUE;
var Y_FUNCTIONDESCRIPTOR_INVALID = YAPI_INVALID_STRING;
var Y_DETECT_NONE = 0;
var Y_DETECT_USB = 1;
var Y_DETECT_NET = 2;
var Y_DETECT_ALL = Y_DETECT_USB | Y_DETECT_NET;
var DEFAULT_DEVICE_LIST_VALIDITY_MS = 1e4;
var DEFAULT_NETWORK_TIMEOUT_MS = 2e4;
var YOCTO_CALIB_TYPE_OFS = 30;
var NOTIFY_NETPKT_CONFCHGYDX = "s";
var NOTIFY_NETPKT_FLUSHV2YDX = "t";
var NOTIFY_NETPKT_FUNCV2YDX = "u";
var NOTIFY_NETPKT_TIMEV2YDX = "v";
var NOTIFY_NETPKT_DEVLOGYDX = "w";
var NOTIFY_NETPKT_TIMEVALYDX = "x";
var NOTIFY_NETPKT_FUNCVALYDX = "y";
var NOTIFY_NETPKT_TIMEAVGYDX = "z";
var NOTIFY_NETPKT_STOP = 10;
var NOTIFY_V2_6RAWBYTES = 1;
var NOTIFY_V2_TYPEDDATA = 2;
var PUBVAL_LEGACY = 0;
var PUBVAL_1RAWBYTE = 1;
var PUBVAL_2RAWBYTES = 2;
var PUBVAL_3RAWBYTES = 3;
var PUBVAL_4RAWBYTES = 4;
var PUBVAL_5RAWBYTES = 5;
var PUBVAL_6RAWBYTES = 6;
var PUBVAL_C_LONG = 7;
var PUBVAL_C_FLOAT = 8;
var PUBVAL_YOCTO_FLOAT_E3 = 9;
var YOCTO_PUBVAL_SIZE = 6;
var YOCTO_HASH_BUF_SIZE = 28;
var YOCTO_BASETYPE_FUNCTION = 0;
var YOCTO_BASETYPE_SENSOR = 1;
var Y_BASETYPES = {
  Function: YOCTO_BASETYPE_FUNCTION,
  Sensor: YOCTO_BASETYPE_SENSOR
};
var YErrorMsg = class {
  constructor(msg = "") {
    this.msg = msg;
  }
};
var YoctoError = class extends Error {
  constructor(...params) {
    super(...params);
    this.errorMsg = this.name;
    this.name = "YoctoError";
    if ("captureStackTrace" in Error) {
      Error.captureStackTrace(this, YoctoError);
    }
  }
};
var Y_MD5Ctx = class {
  constructor() {
    this.buf = new Uint32Array(4);
    this.bits = new Uint32Array(2);
    this.inBuf = new ArrayBuffer(64);
    this.in8 = new Uint8Array(this.inBuf);
    this.in32 = new Uint32Array(this.inBuf);
    this.in32[0] = 1;
    this.bigEndian = this.in8[0] != 1;
    this.buf[0] = 1732584193 >>> 0;
    this.buf[1] = 4023233417 >>> 0;
    this.buf[2] = 2562383102 >>> 0;
    this.buf[3] = 271733878 >>> 0;
    this.bits[0] = 0;
    this.bits[1] = 0;
  }
  _byteReverseIn() {
    for (let i = 0; i < 16; i++) {
      let a = this.in32[i];
      this.in32[i] = (a >>> 24 | (a & 255) << 24 | (a & 16711680) >>> 8 | (a & 65280) << 8) >>> 0;
    }
  }
  _transform() {
    let F1 = (x, y, z) => (z ^ x & (y ^ z)) >>> 0;
    let F2 = (x, y, z) => F1(z, x, y);
    let F3 = (x, y, z) => (x ^ y ^ z) >>> 0;
    let F4 = (x, y, z) => (y ^ (x | ~z)) >>> 0;
    let MD5STEP = (f, w, x, y, z, data, s) => {
      w = w + f(x, y, z) + (data >>> 0) >>> 0;
      w = (w << s >>> 0 | w >>> 32 - s) >>> 0;
      return w + x >>> 0;
    };
    let a = this.buf[0];
    let b = this.buf[1];
    let c = this.buf[2];
    let d = this.buf[3];
    let dataIn = this.in32;
    a = MD5STEP(F1, a, b, c, d, dataIn[0] + 3614090360, 7);
    d = MD5STEP(F1, d, a, b, c, dataIn[1] + 3905402710, 12);
    c = MD5STEP(F1, c, d, a, b, dataIn[2] + 606105819, 17);
    b = MD5STEP(F1, b, c, d, a, dataIn[3] + 3250441966, 22);
    a = MD5STEP(F1, a, b, c, d, dataIn[4] + 4118548399, 7);
    d = MD5STEP(F1, d, a, b, c, dataIn[5] + 1200080426, 12);
    c = MD5STEP(F1, c, d, a, b, dataIn[6] + 2821735955, 17);
    b = MD5STEP(F1, b, c, d, a, dataIn[7] + 4249261313, 22);
    a = MD5STEP(F1, a, b, c, d, dataIn[8] + 1770035416, 7);
    d = MD5STEP(F1, d, a, b, c, dataIn[9] + 2336552879, 12);
    c = MD5STEP(F1, c, d, a, b, dataIn[10] + 4294925233, 17);
    b = MD5STEP(F1, b, c, d, a, dataIn[11] + 2304563134, 22);
    a = MD5STEP(F1, a, b, c, d, dataIn[12] + 1804603682, 7);
    d = MD5STEP(F1, d, a, b, c, dataIn[13] + 4254626195, 12);
    c = MD5STEP(F1, c, d, a, b, dataIn[14] + 2792965006, 17);
    b = MD5STEP(F1, b, c, d, a, dataIn[15] + 1236535329, 22);
    a = MD5STEP(F2, a, b, c, d, dataIn[1] + 4129170786, 5);
    d = MD5STEP(F2, d, a, b, c, dataIn[6] + 3225465664, 9);
    c = MD5STEP(F2, c, d, a, b, dataIn[11] + 643717713, 14);
    b = MD5STEP(F2, b, c, d, a, dataIn[0] + 3921069994, 20);
    a = MD5STEP(F2, a, b, c, d, dataIn[5] + 3593408605, 5);
    d = MD5STEP(F2, d, a, b, c, dataIn[10] + 38016083, 9);
    c = MD5STEP(F2, c, d, a, b, dataIn[15] + 3634488961, 14);
    b = MD5STEP(F2, b, c, d, a, dataIn[4] + 3889429448, 20);
    a = MD5STEP(F2, a, b, c, d, dataIn[9] + 568446438, 5);
    d = MD5STEP(F2, d, a, b, c, dataIn[14] + 3275163606, 9);
    c = MD5STEP(F2, c, d, a, b, dataIn[3] + 4107603335, 14);
    b = MD5STEP(F2, b, c, d, a, dataIn[8] + 1163531501, 20);
    a = MD5STEP(F2, a, b, c, d, dataIn[13] + 2850285829, 5);
    d = MD5STEP(F2, d, a, b, c, dataIn[2] + 4243563512, 9);
    c = MD5STEP(F2, c, d, a, b, dataIn[7] + 1735328473, 14);
    b = MD5STEP(F2, b, c, d, a, dataIn[12] + 2368359562, 20);
    a = MD5STEP(F3, a, b, c, d, dataIn[5] + 4294588738, 4);
    d = MD5STEP(F3, d, a, b, c, dataIn[8] + 2272392833, 11);
    c = MD5STEP(F3, c, d, a, b, dataIn[11] + 1839030562, 16);
    b = MD5STEP(F3, b, c, d, a, dataIn[14] + 4259657740, 23);
    a = MD5STEP(F3, a, b, c, d, dataIn[1] + 2763975236, 4);
    d = MD5STEP(F3, d, a, b, c, dataIn[4] + 1272893353, 11);
    c = MD5STEP(F3, c, d, a, b, dataIn[7] + 4139469664, 16);
    b = MD5STEP(F3, b, c, d, a, dataIn[10] + 3200236656, 23);
    a = MD5STEP(F3, a, b, c, d, dataIn[13] + 681279174, 4);
    d = MD5STEP(F3, d, a, b, c, dataIn[0] + 3936430074, 11);
    c = MD5STEP(F3, c, d, a, b, dataIn[3] + 3572445317, 16);
    b = MD5STEP(F3, b, c, d, a, dataIn[6] + 76029189, 23);
    a = MD5STEP(F3, a, b, c, d, dataIn[9] + 3654602809, 4);
    d = MD5STEP(F3, d, a, b, c, dataIn[12] + 3873151461, 11);
    c = MD5STEP(F3, c, d, a, b, dataIn[15] + 530742520, 16);
    b = MD5STEP(F3, b, c, d, a, dataIn[2] + 3299628645, 23);
    a = MD5STEP(F4, a, b, c, d, dataIn[0] + 4096336452, 6);
    d = MD5STEP(F4, d, a, b, c, dataIn[7] + 1126891415, 10);
    c = MD5STEP(F4, c, d, a, b, dataIn[14] + 2878612391, 15);
    b = MD5STEP(F4, b, c, d, a, dataIn[5] + 4237533241, 21);
    a = MD5STEP(F4, a, b, c, d, dataIn[12] + 1700485571, 6);
    d = MD5STEP(F4, d, a, b, c, dataIn[3] + 2399980690, 10);
    c = MD5STEP(F4, c, d, a, b, dataIn[10] + 4293915773, 15);
    b = MD5STEP(F4, b, c, d, a, dataIn[1] + 2240044497, 21);
    a = MD5STEP(F4, a, b, c, d, dataIn[8] + 1873313359, 6);
    d = MD5STEP(F4, d, a, b, c, dataIn[15] + 4264355552, 10);
    c = MD5STEP(F4, c, d, a, b, dataIn[6] + 2734768916, 15);
    b = MD5STEP(F4, b, c, d, a, dataIn[13] + 1309151649, 21);
    a = MD5STEP(F4, a, b, c, d, dataIn[4] + 4149444226, 6);
    d = MD5STEP(F4, d, a, b, c, dataIn[11] + 3174756917, 10);
    c = MD5STEP(F4, c, d, a, b, dataIn[2] + 718787259, 15);
    b = MD5STEP(F4, b, c, d, a, dataIn[9] + 3951481745, 21);
    this.buf[0] = (this.buf[0] + a & 4294967295) >>> 0;
    this.buf[1] = (this.buf[1] + b & 4294967295) >>> 0;
    this.buf[2] = (this.buf[2] + c & 4294967295) >>> 0;
    this.buf[3] = (this.buf[3] + d & 4294967295) >>> 0;
  }
  addData(buf) {
    let len = buf.length;
    let pos = 0;
    let t = this.bits[0];
    this.bits[0] = t + (len << 3) >>> 0;
    if (this.bits[0] < t) {
      this.bits[1]++;
    }
    this.bits[1] += len >>> 29;
    t = t >>> 3 & 63;
    while (pos < len) {
      while (pos < len && t < 64) {
        this.in8[t++] = buf[pos++];
      }
      if (t < 64)
        return;
      if (this.bigEndian)
        this._byteReverseIn();
      this._transform();
      t = 0;
    }
  }
  calculate() {
    let t = this.bits[0] >>> 3 & 63;
    this.in8[t++] = 128;
    if (t > 56) {
      while (t < 64) {
        this.in8[t++] = 0;
      }
      if (this.bigEndian)
        this._byteReverseIn();
      this._transform();
      for (t = 0; t < 14; t++) {
        this.in32[t] = 0;
      }
    } else {
      while (t < 56) {
        this.in8[t++] = 0;
      }
      if (this.bigEndian)
        this._byteReverseIn();
    }
    this.in32[14] = this.bits[0];
    this.in32[15] = this.bits[1];
    this._transform();
    let res = new Uint8Array(16);
    for (t = 0; t < 16; t++) {
      res[t] = this.buf[t >>> 2] >>> 8 * (t & 3) & 255;
    }
    return res;
  }
};
var YFunctionType = class {
  constructor(yapi, classname) {
    this._yapi = yapi;
    this._className = classname;
    this._connectedFns = {};
    this._requestedFns = {};
    this._hwIdByName = {};
    this._nameByHwId = {};
    this._valueByHwId = {};
    this._baseType = 0;
  }
  imm_reindexFunction(str_hwid, str_name, str_val, int_basetype) {
    let currname = this._nameByHwId[str_hwid];
    let res = false;
    if (currname == void 0 || currname == "") {
      if (str_name != "") {
        this._nameByHwId[str_hwid] = str_name;
        res = true;
      }
    } else if (currname != str_name) {
      if (this._hwIdByName[currname] == str_hwid) {
        delete this._hwIdByName[currname];
      }
      if (str_name != "") {
        this._nameByHwId[str_hwid] = str_name;
      } else {
        delete this._nameByHwId[str_hwid];
      }
      res = true;
    }
    if (str_name != "") {
      this._hwIdByName[str_name] = str_hwid;
    }
    if (str_val) {
      this._valueByHwId[str_hwid] = str_val;
    } else {
      if (this._valueByHwId[str_hwid] == void 0) {
        this._valueByHwId[str_hwid] = "";
      }
    }
    if (int_basetype) {
      if (this._baseType == 0) {
        this._baseType = int_basetype;
      }
    }
    return res;
  }
  imm_forgetFunction(str_hwid) {
    let currname = this._nameByHwId[str_hwid];
    if (currname != void 0) {
      if (currname != "" && this._hwIdByName[currname] == str_hwid) {
        delete this._hwIdByName[currname];
      }
      delete this._nameByHwId[str_hwid];
    }
    if (this._valueByHwId[str_hwid] != void 0) {
      delete this._valueByHwId[str_hwid];
    }
    let con_fn = this._connectedFns[str_hwid];
    if (con_fn) {
      this._requestedFns[str_hwid] = con_fn;
      delete this._connectedFns[str_hwid];
    }
  }
  imm_resolve(str_func) {
    let res;
    let dotpos = str_func.indexOf(".");
    if (dotpos < 0) {
      res = this._hwIdByName[str_func];
      if (res != void 0) {
        return {
          errorType: YAPI_SUCCESS,
          errorMsg: "no error",
          result: String(res)
        };
      }
      dotpos = str_func.length;
      str_func += "." + this._className.substr(0, 1).toLowerCase() + this._className.substr(1);
    }
    if (this._valueByHwId[str_func] != void 0) {
      return {
        errorType: YAPI_SUCCESS,
        errorMsg: "no error",
        result: String(str_func)
      };
    }
    let serial = "";
    let funcid;
    if (dotpos > 0) {
      let devid = str_func.substr(0, dotpos);
      funcid = str_func.substr(dotpos + 1);
      let dev = this._yapi.imm_getDevice(devid);
      if (!dev) {
        return {
          errorType: YAPI_DEVICE_NOT_FOUND,
          errorMsg: "Device [" + devid + "] not online",
          result: ""
        };
      }
      serial = dev.imm_getSerialNumber();
      res = serial + "." + funcid;
      if (this._valueByHwId[res] != void 0) {
        return {
          errorType: YAPI_SUCCESS,
          errorMsg: "no error",
          result: String(res)
        };
      }
      let i, nfun = dev.imm_functionCount();
      for (i = 0; i < nfun; i++) {
        res = serial + "." + dev.imm_functionId(i);
        let name = this._nameByHwId[res];
        if (name != void 0 && name == funcid) {
          return {
            errorType: YAPI_SUCCESS,
            errorMsg: "no error",
            result: String(res)
          };
        }
      }
    } else {
      funcid = str_func.substr(1);
      for (let hwid_str in this._connectedFns) {
        let pos = hwid_str.indexOf(".");
        let str_function = hwid_str.substr(pos + 1);
        if (str_function == funcid) {
          return {
            errorType: YAPI_SUCCESS,
            errorMsg: "no error",
            result: String(hwid_str)
          };
        }
      }
    }
    return {
      errorType: YAPI_DEVICE_NOT_FOUND,
      errorMsg: "No function [" + funcid + "] found on device [" + serial + "]",
      result: ""
    };
  }
  imm_getFriendlyName(str_func) {
    let resolved = this.imm_resolve(str_func);
    let name;
    if (resolved.errorType != YAPI_SUCCESS) {
      return resolved;
    }
    let hwId = resolved.result;
    if (this._className == "Module") {
      let friend = hwId;
      name = this._nameByHwId[friend];
      if (name != void 0 && name != "") {
        friend = this._nameByHwId[friend];
      }
      return {
        errorType: YAPI_SUCCESS,
        errorMsg: "no error",
        result: String(friend)
      };
    } else {
      let pos = hwId.indexOf(".");
      let str_serialMod = hwId.substr(0, pos);
      let str_friendModFull = this._yapi.imm_getFriendlyNameFunction("Module", str_serialMod).result;
      let int_friendModDot = str_friendModFull.indexOf(".");
      let str_friendMod = int_friendModDot > 0 ? str_friendModFull.substr(0, int_friendModDot) : str_friendModFull;
      let str_friendFunc = hwId.substr(pos + 1);
      name = this._nameByHwId[hwId];
      if (name != void 0 && name != "") {
        str_friendFunc = name;
      }
      return {
        errorType: YAPI_SUCCESS,
        errorMsg: "no error",
        result: String(str_friendMod + "." + str_friendFunc)
      };
    }
  }
  imm_setFunction(str_func, obj_func) {
    let funres = this.imm_resolve(str_func);
    if (funres.result) {
      this._connectedFns[funres.result] = obj_func;
    } else {
      this._requestedFns[str_func] = obj_func;
    }
  }
  imm_getFunction(str_func) {
    let funres = this.imm_resolve(str_func);
    if (funres.errorType == YAPI_SUCCESS) {
      let conn_fn = this._connectedFns[funres.result];
      if (conn_fn != void 0) {
        return conn_fn;
      }
      let req_fn = this._requestedFns[str_func];
      if (req_fn != void 0) {
        this._connectedFns[funres.result] = req_fn;
        delete this._requestedFns[str_func];
      }
      return req_fn;
    } else {
      return this._requestedFns[str_func];
    }
  }
  imm_setFunctionValue(str_hwid, str_pubval) {
    let currval = this._valueByHwId[str_hwid];
    if (!(currval == void 0) && currval == str_pubval) {
      return false;
    }
    this._valueByHwId[str_hwid] = str_pubval;
    return true;
  }
  imm_getFunctionValue(str_hwid) {
    return this._valueByHwId[str_hwid];
  }
  imm_getBaseType() {
    return this._baseType;
  }
  imm_matchBaseType(baseclass) {
    return baseclass == YOCTO_BASETYPE_FUNCTION || baseclass == this._baseType;
  }
  imm_getFirstHardwareId() {
    let res = null;
    for (res in this._valueByHwId) {
      break;
    }
    return res;
  }
  imm_getNextHardwareId(str_hwid) {
    for (let iter_hwid in this._valueByHwId) {
      if (str_hwid == "!") {
        return iter_hwid;
      }
      if (str_hwid == iter_hwid) {
        str_hwid = "!";
      }
    }
    return null;
  }
};
var YHTTPBody = class {
  constructor(str_fname, bin_data, fun_progressCb) {
    this.fname = str_fname;
    this.data = bin_data;
    this.progressCb = fun_progressCb;
  }
};
var YHTTPRequest = class {
  constructor(bin_res, int_errType = YAPI_SUCCESS, str_errMsg = "no error") {
    this.devUrl = null;
    this.obj_result = null;
    this.asyncId = 0;
    this.acceptor = null;
    this.toBeSent = null;
    this.sendPos = 0;
    this.progressCb = null;
    this.timeoutId = null;
    this.sendTimeoutId = null;
    this.next = null;
    this._creat = "";
    this._sent = "";
    this.bin_result = bin_res;
    this.errorType = int_errType;
    this.errorMsg = str_errMsg;
  }
};
var YFuncRequest = class {
  constructor(obj_res, int_errType = YAPI_SUCCESS, str_errMsg = "no error") {
    this.errorType = int_errType;
    this.errorMsg = str_errMsg;
    this.obj_result = obj_res;
  }
};
var YDataStream = class {
  constructor(obj_parent, obj_dataset, encoded) {
    this._runNo = 0;
    this._utcStamp = 0;
    this._nCols = 0;
    this._nRows = 0;
    this._startTime = 0;
    this._duration = 0;
    this._dataSamplesInterval = 0;
    this._firstMeasureDuration = 0;
    this._columnNames = [];
    this._functionId = "";
    this._isClosed = false;
    this._isAvg = false;
    this._minVal = 0;
    this._avgVal = 0;
    this._maxVal = 0;
    this._caltyp = 0;
    this._calpar = [];
    this._calraw = [];
    this._calref = [];
    this._values = [];
    this._isLoaded = false;
    this.DATA_INVALID = YAPI_INVALID_DOUBLE;
    this.DURATION_INVALID = YAPI_INVALID_DOUBLE;
    this._parent = obj_parent;
    this._yapi = this._parent._yapi;
    this.imm_calhdl = null;
    if (typeof obj_dataset != "undefined") {
      this.imm_initFromDataSet(obj_dataset, encoded);
    }
  }
  imm_initFromDataSet(dataset, encoded) {
    let val;
    let i;
    let maxpos;
    let ms_offset;
    let samplesPerHour;
    let fRaw;
    let fRef;
    let iCalib = [];
    this._runNo = encoded[0] + (encoded[1] << 16);
    this._utcStamp = encoded[2] + (encoded[3] << 16);
    val = encoded[4];
    this._isAvg = (val & 256) == 0;
    samplesPerHour = val & 255;
    if ((val & 256) != 0) {
      samplesPerHour = samplesPerHour * 3600;
    } else {
      if ((val & 512) != 0) {
        samplesPerHour = samplesPerHour * 60;
      }
    }
    this._dataSamplesInterval = 3600 / samplesPerHour;
    ms_offset = encoded[6];
    if (ms_offset < 1e3) {
      this._startTime = this._utcStamp + ms_offset / 1e3;
    } else {
      this._startTime = this._utcStamp - this._dataSamplesInterval;
    }
    this._firstMeasureDuration = encoded[5];
    if (!this._isAvg) {
      this._firstMeasureDuration = this._firstMeasureDuration / 1e3;
    }
    val = encoded[7];
    this._isClosed = val != 65535;
    if (val == 65535) {
      val = 0;
    }
    this._nRows = val;
    if (this._nRows > 0) {
      if (this._firstMeasureDuration > 0) {
        this._duration = this._firstMeasureDuration + (this._nRows - 1) * this._dataSamplesInterval;
      } else {
        this._duration = this._nRows * this._dataSamplesInterval;
      }
    } else {
      this._duration = 0;
    }
    iCalib = dataset.imm_get_calibration();
    this._caltyp = iCalib[0];
    if (this._caltyp != 0) {
      this.imm_calhdl = this._yapi.imm_getCalibrationHandler(this._caltyp);
      maxpos = iCalib.length;
      this._calpar.length = 0;
      this._calraw.length = 0;
      this._calref.length = 0;
      i = 1;
      while (i < maxpos) {
        this._calpar.push(iCalib[i]);
        i = i + 1;
      }
      i = 1;
      while (i + 1 < maxpos) {
        fRaw = iCalib[i];
        fRaw = fRaw / 1e3;
        fRef = iCalib[i + 1];
        fRef = fRef / 1e3;
        this._calraw.push(fRaw);
        this._calref.push(fRef);
        i = i + 2;
      }
    }
    this._functionId = dataset.imm_get_functionId();
    if (this._isAvg) {
      this._columnNames.length = 0;
      this._columnNames.push(this._functionId + "_min");
      this._columnNames.push(this._functionId + "_avg");
      this._columnNames.push(this._functionId + "_max");
      this._nCols = 3;
    } else {
      this._columnNames.length = 0;
      this._columnNames.push(this._functionId);
      this._nCols = 1;
    }
    if (this._nRows > 0) {
      this._avgVal = this.imm_decodeAvg(encoded[8] + ((encoded[9] ^ 32768) << 16), 1);
      this._minVal = this.imm_decodeVal(encoded[10] + (encoded[11] << 16));
      this._maxVal = this.imm_decodeVal(encoded[12] + (encoded[13] << 16));
    }
    return 0;
  }
  imm_parseStream(sdata) {
    let idx;
    let udat = [];
    let dat = [];
    if (this._isLoaded && !this._isClosed) {
      return YAPI_SUCCESS;
    }
    if (sdata.length == 0) {
      this._nRows = 0;
      return YAPI_SUCCESS;
    }
    udat = this._yapi.imm_decodeWords(this._parent.imm_json_get_string(sdata));
    this._values.length = 0;
    idx = 0;
    if (this._isAvg) {
      while (idx + 3 < udat.length) {
        dat.length = 0;
        if (udat[idx] == 65535 && udat[idx + 1] == 65535) {
          dat.push(NaN);
          dat.push(NaN);
          dat.push(NaN);
        } else {
          dat.push(this.imm_decodeVal(udat[idx + 2] + (udat[idx + 3] << 16)));
          dat.push(this.imm_decodeAvg(udat[idx] + ((udat[idx + 1] ^ 32768) << 16), 1));
          dat.push(this.imm_decodeVal(udat[idx + 4] + (udat[idx + 5] << 16)));
        }
        idx = idx + 6;
        this._values.push(dat.slice());
      }
    } else {
      while (idx + 1 < udat.length) {
        dat.length = 0;
        if (udat[idx] == 65535 && udat[idx + 1] == 65535) {
          dat.push(NaN);
        } else {
          dat.push(this.imm_decodeAvg(udat[idx] + ((udat[idx + 1] ^ 32768) << 16), 1));
        }
        this._values.push(dat.slice());
        idx = idx + 2;
      }
    }
    this._nRows = this._values.length;
    this._isLoaded = true;
    return YAPI_SUCCESS;
  }
  imm_wasLoaded() {
    return this._isLoaded;
  }
  imm_get_url() {
    let url;
    url = "logger.json?id=" + this._functionId + "&run=" + String(Math.round(this._runNo)) + "&utc=" + String(Math.round(this._utcStamp));
    return url;
  }
  imm_get_baseurl() {
    let url;
    url = "logger.json?id=" + this._functionId + "&run=" + String(Math.round(this._runNo)) + "&utc=";
    return url;
  }
  imm_get_urlsuffix() {
    let url;
    url = String(Math.round(this._utcStamp));
    return url;
  }
  async loadStream() {
    return this.imm_parseStream(await this._parent._download(this.imm_get_url()));
  }
  imm_decodeVal(w) {
    let val;
    val = w;
    val = val / 1e3;
    if (this._caltyp != 0) {
      if (this.imm_calhdl != null) {
        val = this.imm_calhdl(val, this._caltyp, this._calpar, this._calraw, this._calref);
      }
    }
    return val;
  }
  imm_decodeAvg(dw, count) {
    let val;
    val = dw;
    val = val / 1e3;
    if (this._caltyp != 0) {
      if (this.imm_calhdl != null) {
        val = this.imm_calhdl(val, this._caltyp, this._calpar, this._calraw, this._calref);
      }
    }
    return val;
  }
  async isClosed() {
    return this._isClosed;
  }
  async get_runIndex() {
    return this._runNo;
  }
  async get_startTime() {
    return this._utcStamp - (Date.now() / 1e3 >> 0);
  }
  async get_startTimeUTC() {
    return Math.round(this._startTime);
  }
  async get_realStartTimeUTC() {
    return this._startTime;
  }
  async get_dataSamplesIntervalMs() {
    return Math.round(this._dataSamplesInterval * 1e3);
  }
  async get_dataSamplesInterval() {
    return this._dataSamplesInterval;
  }
  async get_firstDataSamplesInterval() {
    return this._firstMeasureDuration;
  }
  async get_rowCount() {
    if (this._nRows != 0 && this._isClosed) {
      return this._nRows;
    }
    await this.loadStream();
    return this._nRows;
  }
  async get_columnCount() {
    if (this._nCols != 0) {
      return this._nCols;
    }
    await this.loadStream();
    return this._nCols;
  }
  async get_columnNames() {
    if (this._columnNames.length != 0) {
      return this._columnNames;
    }
    await this.loadStream();
    return this._columnNames;
  }
  async get_minValue() {
    return this._minVal;
  }
  async get_averageValue() {
    return this._avgVal;
  }
  async get_maxValue() {
    return this._maxVal;
  }
  async get_realDuration() {
    if (this._isClosed) {
      return this._duration;
    }
    return (Date.now() / 1e3 >> 0) - this._utcStamp;
  }
  async get_dataRows() {
    if (this._values.length == 0 || !this._isClosed) {
      await this.loadStream();
    }
    return this._values;
  }
  async get_data(row, col) {
    if (this._values.length == 0 || !this._isClosed) {
      await this.loadStream();
    }
    if (row >= this._values.length) {
      return YDataStream.DATA_INVALID;
    }
    if (col >= this._values[row].length) {
      return YDataStream.DATA_INVALID;
    }
    return this._values[row][col];
  }
};
YDataStream.DATA_INVALID = YAPI_INVALID_DOUBLE;
YDataStream.DURATION_INVALID = YAPI_INVALID_DOUBLE;
var YDataSet = class {
  constructor(obj_parent, str_functionId = "", str_unit = "", double_startTime = 0, double_endTime = 0) {
    this._hardwareId = "";
    this._functionId = "";
    this._unit = "";
    this._bulkLoad = 0;
    this._startTimeMs = 0;
    this._endTimeMs = 0;
    this._progress = 0;
    this._calib = [];
    this._streams = [];
    this._preview = [];
    this._measures = [];
    this._summaryMinVal = 0;
    this._summaryMaxVal = 0;
    this._summaryTotalAvg = 0;
    this._summaryTotalTime = 0;
    this.DATA_INVALID = YAPI_INVALID_DOUBLE;
    this.DURATION_INVALID = YAPI_INVALID_DOUBLE;
    this.HARDWAREID_INVALID = YAPI_INVALID_STRING;
    this.FUNCTIONID_INVALID = YAPI_INVALID_STRING;
    this.UNIT_INVALID = YAPI_INVALID_STRING;
    this._summary = new YMeasure(0, 0, 0, 0, 0);
    if (str_functionId == "") {
      this._parent = obj_parent;
      this._yapi = obj_parent._yapi;
      this._startTimeMs = 0;
      this._endTimeMs = 0;
    } else {
      this._parent = obj_parent;
      this._yapi = obj_parent._yapi;
      this._functionId = str_functionId;
      this._unit = str_unit;
      this._startTimeMs = double_startTime * 1e3;
      this._endTimeMs = double_endTime * 1e3;
      this._progress = -1;
    }
  }
  imm_get_functionId() {
    return this._functionId;
  }
  imm_get_calibration() {
    return this._calib;
  }
  async loadSummary(data) {
    let dataRows = [];
    let tim;
    let mitv;
    let itv;
    let fitv;
    let end_;
    let nCols;
    let minCol;
    let avgCol;
    let maxCol;
    let res;
    let m_pos;
    let previewTotalTime;
    let previewTotalAvg;
    let previewMinVal;
    let previewMaxVal;
    let previewAvgVal;
    let previewStartMs;
    let previewStopMs;
    let previewDuration;
    let streamStartTimeMs;
    let streamDuration;
    let streamEndTimeMs;
    let minVal;
    let avgVal;
    let maxVal;
    let summaryStartMs;
    let summaryStopMs;
    let summaryTotalTime;
    let summaryTotalAvg;
    let summaryMinVal;
    let summaryMaxVal;
    let url;
    let strdata;
    let measure_data = [];
    if (this._progress < 0) {
      strdata = this._yapi.imm_bin2str(data);
      if (strdata == "{}") {
        this._parent._throw(YAPI_VERSION_MISMATCH, "device firmware is too old");
        return YAPI_VERSION_MISMATCH;
      }
      res = await this._parse(strdata);
      if (res < 0) {
        return res;
      }
    }
    summaryTotalTime = 0;
    summaryTotalAvg = 0;
    summaryMinVal = YAPI_MAX_DOUBLE;
    summaryMaxVal = YAPI_MIN_DOUBLE;
    summaryStartMs = YAPI_MAX_DOUBLE;
    summaryStopMs = YAPI_MIN_DOUBLE;
    for (let ii in this._streams) {
      streamStartTimeMs = Math.round(await this._streams[ii].get_realStartTimeUTC() * 1e3);
      streamDuration = await this._streams[ii].get_realDuration();
      streamEndTimeMs = streamStartTimeMs + Math.round(streamDuration * 1e3);
      if (streamStartTimeMs >= this._startTimeMs && (this._endTimeMs == 0 || streamEndTimeMs <= this._endTimeMs)) {
        previewMinVal = await this._streams[ii].get_minValue();
        previewAvgVal = await this._streams[ii].get_averageValue();
        previewMaxVal = await this._streams[ii].get_maxValue();
        previewStartMs = streamStartTimeMs;
        previewStopMs = streamEndTimeMs;
        previewDuration = streamDuration;
      } else {
        if (!this._streams[ii].imm_wasLoaded()) {
          url = this._streams[ii].imm_get_url();
          data = await this._parent._download(url);
          this._streams[ii].imm_parseStream(data);
        }
        dataRows = await this._streams[ii].get_dataRows();
        if (dataRows.length == 0) {
          return await this.get_progress();
        }
        tim = streamStartTimeMs;
        fitv = Math.round(await this._streams[ii].get_firstDataSamplesInterval() * 1e3);
        itv = Math.round(await this._streams[ii].get_dataSamplesInterval() * 1e3);
        nCols = dataRows[0].length;
        minCol = 0;
        if (nCols > 2) {
          avgCol = 1;
        } else {
          avgCol = 0;
        }
        if (nCols > 2) {
          maxCol = 2;
        } else {
          maxCol = 0;
        }
        previewTotalTime = 0;
        previewTotalAvg = 0;
        previewStartMs = streamEndTimeMs;
        previewStopMs = streamStartTimeMs;
        previewMinVal = YAPI_MAX_DOUBLE;
        previewMaxVal = YAPI_MIN_DOUBLE;
        m_pos = 0;
        while (m_pos < dataRows.length) {
          measure_data = dataRows[m_pos];
          if (m_pos == 0) {
            mitv = fitv;
          } else {
            mitv = itv;
          }
          end_ = tim + mitv;
          if (end_ > this._startTimeMs && (this._endTimeMs == 0 || tim < this._endTimeMs)) {
            minVal = measure_data[minCol];
            avgVal = measure_data[avgCol];
            maxVal = measure_data[maxCol];
            if (previewStartMs > tim) {
              previewStartMs = tim;
            }
            if (previewStopMs < end_) {
              previewStopMs = end_;
            }
            if (previewMinVal > minVal) {
              previewMinVal = minVal;
            }
            if (previewMaxVal < maxVal) {
              previewMaxVal = maxVal;
            }
            if (!isNaN(avgVal)) {
              previewTotalAvg = previewTotalAvg + avgVal * mitv;
              previewTotalTime = previewTotalTime + mitv;
            }
          }
          tim = end_;
          m_pos = m_pos + 1;
        }
        if (previewTotalTime > 0) {
          previewAvgVal = previewTotalAvg / previewTotalTime;
          previewDuration = (previewStopMs - previewStartMs) / 1e3;
        } else {
          previewAvgVal = 0;
          previewDuration = 0;
        }
      }
      this._preview.push(new YMeasure(previewStartMs / 1e3, previewStopMs / 1e3, previewMinVal, previewAvgVal, previewMaxVal));
      if (summaryMinVal > previewMinVal) {
        summaryMinVal = previewMinVal;
      }
      if (summaryMaxVal < previewMaxVal) {
        summaryMaxVal = previewMaxVal;
      }
      if (summaryStartMs > previewStartMs) {
        summaryStartMs = previewStartMs;
      }
      if (summaryStopMs < previewStopMs) {
        summaryStopMs = previewStopMs;
      }
      summaryTotalAvg = summaryTotalAvg + previewAvgVal * previewDuration;
      summaryTotalTime = summaryTotalTime + previewDuration;
    }
    if (this._startTimeMs == 0 || this._startTimeMs > summaryStartMs) {
      this._startTimeMs = summaryStartMs;
    }
    if (this._endTimeMs == 0 || this._endTimeMs < summaryStopMs) {
      this._endTimeMs = summaryStopMs;
    }
    if (summaryTotalTime > 0) {
      this._summary = new YMeasure(summaryStartMs / 1e3, summaryStopMs / 1e3, summaryMinVal, summaryTotalAvg / summaryTotalTime, summaryMaxVal);
    } else {
      this._summary = new YMeasure(0, 0, YAPI_INVALID_DOUBLE, YAPI_INVALID_DOUBLE, YAPI_INVALID_DOUBLE);
    }
    return await this.get_progress();
  }
  async processMore(progress, data) {
    let stream;
    let dataRows = [];
    let tim;
    let itv;
    let fitv;
    let avgv;
    let end_;
    let nCols;
    let minCol;
    let avgCol;
    let maxCol;
    let firstMeasure;
    let baseurl;
    let url;
    let suffix;
    let suffixes = [];
    let idx;
    let bulkFile;
    let streamStr = [];
    let urlIdx;
    let streamBin;
    if (progress != this._progress) {
      return this._progress;
    }
    if (this._progress < 0) {
      return await this.loadSummary(data);
    }
    stream = this._streams[this._progress];
    if (!stream.imm_wasLoaded()) {
      stream.imm_parseStream(data);
    }
    dataRows = await stream.get_dataRows();
    this._progress = this._progress + 1;
    if (dataRows.length == 0) {
      return await this.get_progress();
    }
    tim = Math.round(await stream.get_realStartTimeUTC() * 1e3);
    fitv = Math.round(await stream.get_firstDataSamplesInterval() * 1e3);
    itv = Math.round(await stream.get_dataSamplesInterval() * 1e3);
    if (fitv == 0) {
      fitv = itv;
    }
    if (tim < itv) {
      tim = itv;
    }
    nCols = dataRows[0].length;
    minCol = 0;
    if (nCols > 2) {
      avgCol = 1;
    } else {
      avgCol = 0;
    }
    if (nCols > 2) {
      maxCol = 2;
    } else {
      maxCol = 0;
    }
    firstMeasure = true;
    for (let ii in dataRows) {
      if (firstMeasure) {
        end_ = tim + fitv;
        firstMeasure = false;
      } else {
        end_ = tim + itv;
      }
      avgv = dataRows[ii][avgCol];
      if (end_ > this._startTimeMs && (this._endTimeMs == 0 || tim < this._endTimeMs) && !isNaN(avgv)) {
        this._measures.push(new YMeasure(tim / 1e3, end_ / 1e3, dataRows[ii][minCol], avgv, dataRows[ii][maxCol]));
      }
      tim = end_;
    }
    if (this._bulkLoad > 0 && this._progress < this._streams.length) {
      stream = this._streams[this._progress];
      if (stream.imm_wasLoaded()) {
        return await this.get_progress();
      }
      baseurl = stream.imm_get_baseurl();
      url = stream.imm_get_url();
      suffix = stream.imm_get_urlsuffix();
      suffixes.push(suffix);
      idx = this._progress + 1;
      while (idx < this._streams.length && suffixes.length < this._bulkLoad) {
        stream = this._streams[idx];
        if (!stream.imm_wasLoaded() && stream.imm_get_baseurl() == baseurl) {
          suffix = stream.imm_get_urlsuffix();
          suffixes.push(suffix);
          url = url + "," + suffix;
        }
        idx = idx + 1;
      }
      bulkFile = await this._parent._download(url);
      streamStr = this._parent.imm_json_get_array(bulkFile);
      urlIdx = 0;
      idx = this._progress;
      while (idx < this._streams.length && urlIdx < suffixes.length && urlIdx < streamStr.length) {
        stream = this._streams[idx];
        if (stream.imm_get_baseurl() == baseurl && stream.imm_get_urlsuffix() == suffixes[urlIdx]) {
          streamBin = this._yapi.imm_str2bin(streamStr[urlIdx]);
          stream.imm_parseStream(streamBin);
          urlIdx = urlIdx + 1;
        }
        idx = idx + 1;
      }
    }
    return await this.get_progress();
  }
  async get_privateDataStreams() {
    return this._streams;
  }
  async get_hardwareId() {
    let mo;
    if (!(this._hardwareId == "")) {
      return this._hardwareId;
    }
    mo = await this._parent.get_module();
    this._hardwareId = await mo.get_serialNumber() + "." + await this.get_functionId();
    return this._hardwareId;
  }
  async get_functionId() {
    return this._functionId;
  }
  async get_unit() {
    return this._unit;
  }
  async get_startTimeUTC() {
    return this.imm_get_startTimeUTC();
  }
  imm_get_startTimeUTC() {
    return this._startTimeMs / 1e3;
  }
  async get_endTimeUTC() {
    return this.imm_get_endTimeUTC();
  }
  imm_get_endTimeUTC() {
    return Math.round(this._endTimeMs / 1e3);
  }
  async get_progress() {
    if (this._progress < 0) {
      return 0;
    }
    if (this._progress >= this._streams.length) {
      return 100;
    }
    return (1 + (1 + this._progress) * 98) / (1 + this._streams.length) >> 0;
  }
  async loadMore() {
    let url;
    let stream;
    if (this._progress < 0) {
      url = "logger.json?id=" + this._functionId;
      if (this._startTimeMs != 0) {
        url = url + "&from=" + String(Math.round(this.imm_get_startTimeUTC()));
      }
      if (this._endTimeMs != 0) {
        url = url + "&to=" + String(Math.round(this.imm_get_endTimeUTC() + 1));
      }
    } else {
      if (this._progress >= this._streams.length) {
        return 100;
      } else {
        stream = this._streams[this._progress];
        if (stream.imm_wasLoaded()) {
          return await this.processMore(this._progress, this._yapi.imm_str2bin(""));
        }
        url = stream.imm_get_url();
      }
    }
    try {
      return await this.processMore(this._progress, await this._parent._download(url));
    } catch (e) {
      return await this.processMore(this._progress, await this._parent._download(url));
    }
  }
  async get_summary() {
    return this._summary;
  }
  async get_preview() {
    return this._preview;
  }
  async get_measuresAt(measure) {
    let startUtcMs;
    let stream;
    let dataRows = [];
    let measures = [];
    let tim;
    let itv;
    let end_;
    let nCols;
    let minCol;
    let avgCol;
    let maxCol;
    startUtcMs = measure.get_startTimeUTC() * 1e3;
    stream = null;
    for (let ii in this._streams) {
      if (Math.round(await this._streams[ii].get_realStartTimeUTC() * 1e3) == startUtcMs) {
        stream = this._streams[ii];
      }
    }
    if (stream == null) {
      return measures;
    }
    dataRows = await stream.get_dataRows();
    if (dataRows.length == 0) {
      return measures;
    }
    tim = Math.round(await stream.get_realStartTimeUTC() * 1e3);
    itv = Math.round(await stream.get_dataSamplesInterval() * 1e3);
    if (tim < itv) {
      tim = itv;
    }
    nCols = dataRows[0].length;
    minCol = 0;
    if (nCols > 2) {
      avgCol = 1;
    } else {
      avgCol = 0;
    }
    if (nCols > 2) {
      maxCol = 2;
    } else {
      maxCol = 0;
    }
    for (let ii in dataRows) {
      end_ = tim + itv;
      if (end_ > this._startTimeMs && (this._endTimeMs == 0 || tim < this._endTimeMs)) {
        measures.push(new YMeasure(tim / 1e3, end_ / 1e3, dataRows[ii][minCol], dataRows[ii][avgCol], dataRows[ii][maxCol]));
      }
      tim = end_;
    }
    return measures;
  }
  async get_measures() {
    return this._measures;
  }
  async _parse(str_json) {
    let loadval = null;
    try {
      loadval = JSON.parse(str_json);
    } catch (err) {
    }
    if (!loadval) {
      this._progress = 0;
      return await this.get_progress();
    }
    this._functionId = loadval.id;
    this._unit = loadval.unit;
    this._bulkLoad = loadval.bulk ? parseInt(loadval.bulk) : 0;
    if (loadval.calib) {
      this._calib = this._yapi.imm_decodeFloats(loadval.calib);
      this._calib[0] = this._calib[0] / 1e3 >> 0;
    } else {
      this._calib = this._yapi.imm_decodeWords(loadval.cal);
    }
    this._summary = new YMeasure(0, 0, 0, 0, 0);
    this._streams = [];
    this._preview = [];
    this._measures = [];
    for (let i = 0; i < loadval.streams.length; i++) {
      let stream = this._parent.imm_findDataStream(this, loadval.streams[i]);
      if (!stream)
        continue;
      let streamStartTime = await stream.get_realStartTimeUTC() * 1e3;
      let streamEndTime = streamStartTime + await stream.get_realDuration() * 1e3;
      if (this._startTimeMs > 0 && streamEndTime <= this._startTimeMs) {
      } else if (this._endTimeMs > 0 && streamStartTime >= this._endTimeMs) {
      } else {
        this._streams.push(stream);
      }
    }
    this._progress = 0;
    return this.get_progress();
  }
};
YDataSet.DATA_INVALID = YAPI_INVALID_DOUBLE;
YDataSet.DURATION_INVALID = YAPI_INVALID_DOUBLE;
YDataSet.HARDWAREID_INVALID = YAPI_INVALID_STRING;
YDataSet.FUNCTIONID_INVALID = YAPI_INVALID_STRING;
YDataSet.UNIT_INVALID = YAPI_INVALID_STRING;
YDataSet.DATA_INVALID = YAPI_INVALID_DOUBLE;
YDataSet.DURATION_INVALID = YAPI_INVALID_DOUBLE;
YDataSet.HARDWAREID_INVALID = YAPI_INVALID_STRING;
YDataSet.FUNCTIONID_INVALID = YAPI_INVALID_STRING;
YDataSet.UNIT_INVALID = YAPI_INVALID_STRING;
var YDevice = class {
  constructor(obj_yapi, str_rooturl, obj_wpRec, obj_ypRecs) {
    this._yapi = obj_yapi;
    this._rootUrl = str_rooturl;
    this._serialNumber = "";
    this._logicalName = "";
    this._productName = "";
    this._productId = 0;
    this._beacon = 0;
    this._devYdx = -1;
    this._lastErrorType = YAPI_SUCCESS;
    this._lastErrorMsg = "no error";
    this._cache = {_expiration: 0, _json: new Uint8Array(0), _precooked: {}};
    this._functions = [];
    this._busy = 0;
    this._pendingQueries = Promise.resolve();
    this._lastTimeRef = 0;
    this._lastDuration = 0;
    this._logCallback = null;
    this._logIsPulling = false;
    this._logpos = 0;
    if (obj_wpRec && obj_ypRecs) {
      this._serialNumber = obj_wpRec.serialNumber;
      this._logicalName = obj_wpRec.logicalName;
      this._productName = obj_wpRec.productName;
      this._productId = obj_wpRec.productId;
      this._beacon = obj_wpRec.beacon;
      this._devYdx = obj_wpRec.index == void 0 ? -1 : obj_wpRec.index;
      this.imm_updateFromYP(obj_ypRecs);
      this._yapi.imm_reindexDevice(this);
    }
  }
  _throw(int_errType, str_errMsg, obj_retVal) {
    this._lastErrorType = int_errType;
    this._lastErrorMsg = str_errMsg;
    return this._yapi._throw(int_errType, str_errMsg, obj_retVal);
  }
  imm_getRootUrl() {
    return this._rootUrl;
  }
  imm_getSerialNumber() {
    return this._serialNumber;
  }
  imm_getLogicalName() {
    return this._logicalName;
  }
  async getLogicalName() {
    if (this._cache._expiration == 0) {
      await this.refresh();
    }
    return this._logicalName;
  }
  imm_getProductName() {
    return this._productName;
  }
  imm_getProductId() {
    return this._productId;
  }
  imm_getBeacon() {
    return this._beacon;
  }
  async getBeacon() {
    if (this._cache._expiration == 0) {
      await this.refresh();
    }
    return this._beacon;
  }
  imm_getLastTimeRef() {
    return this._lastTimeRef;
  }
  imm_getLastDuration() {
    return this._lastDuration;
  }
  imm_triggerLogPull() {
    if (this._logCallback == null || this._logIsPulling) {
      return;
    }
    this._logIsPulling = true;
    let request = "GET logs.txt?pos=" + this._logpos;
    let prom = this._yapi.devRequest(this._rootUrl, request, null, 0);
    prom.then(async (yreq) => {
      if (yreq.errorType != YAPI_SUCCESS) {
        this._logIsPulling = false;
        return;
      }
      if (this._logCallback == null) {
        this._logIsPulling = false;
        return;
      }
      let resultStr = YAPI.imm_bin2str(yreq.bin_result);
      let pos = resultStr.lastIndexOf("\n@");
      if (pos < 0) {
        this._logIsPulling = false;
        return;
      }
      let logs = resultStr.substring(0, pos);
      let posStr = resultStr.substring(pos + 2);
      this._logpos = parseInt(posStr);
      let module = YModule.FindModuleInContext(this._yapi, this._serialNumber);
      let lines = logs.trim().split("\n");
      try {
        for (let i = 0; i < lines.length; i++) {
          await this._logCallback(module, lines[i]);
        }
      } catch (e) {
        this._yapi.imm_log("Exception in device log callback:", e);
      }
      this._logIsPulling = false;
    });
  }
  imm_registerLogCallback(callback) {
    this._logCallback = callback;
    if (callback != null) {
      this.imm_triggerLogPull();
    }
  }
  imm_setTimeRef(float_timestamp, float_duration) {
    this._lastTimeRef = float_timestamp;
    this._lastDuration = float_duration;
  }
  imm_getDevYdx() {
    return this._devYdx;
  }
  imm_describe() {
    let res = this._rootUrl;
    if (this._serialNumber != "") {
      res = this._serialNumber;
      if (this._logicalName != "") {
        res = res + " (" + this._logicalName + ")";
      }
    }
    return this._productName + " " + res;
  }
  imm_updateFromYP(obj_ypRecs) {
    let funidx = 0;
    for (let categ in obj_ypRecs) {
      for (let key in obj_ypRecs[categ]) {
        let rec = obj_ypRecs[categ][key];
        let hwid = rec["hardwareId"];
        let dotpos = hwid.indexOf(".");
        if (hwid.substr(0, dotpos) == this._serialNumber) {
          let funydx = rec["index"];
          if (funydx == void 0)
            funydx = funidx;
          this._functions[funydx] = [hwid.substr(dotpos + 1), rec["logicalName"]];
          funidx++;
        }
      }
    }
  }
  async updateFromReq(yreq, loadval) {
    this._cache._expiration = this._yapi.GetTickCount() + this._yapi.defaultCacheValidity;
    this._cache._json = yreq.bin_result;
    let func;
    let reindex = false;
    if (this._productName == "") {
      for (func in loadval) {
        if (func == "module") {
          this._serialNumber = loadval.module.serialNumber;
          this._logicalName = loadval.module.logicalName;
          this._productName = loadval.module.productName;
          this._productId = loadval.module.productId;
          this._beacon = loadval.module.beacon;
        } else if (func == "services") {
          this.imm_updateFromYP(loadval.services.yellowPages);
        }
      }
      reindex = true;
    } else {
      let renamed = false;
      for (func in loadval) {
        if (func == "module") {
          if (this._logicalName != loadval.module.logicalName) {
            this._logicalName = loadval.module.logicalName;
            reindex = true;
          }
          this._beacon = loadval.module.beacon;
        } else if (func != "services") {
          let name = loadval[func]["logicalName"];
          if (name == void 0)
            name = loadval.module.logicalName;
          let pubval = loadval[func]["advertisedValue"];
          if (pubval != void 0) {
            await this._yapi.setFunctionValue(loadval.module.serialNumber + "." + func, pubval);
          }
          let funydx;
          for (funydx in this._functions) {
            if (this._functions[funydx][0] == func) {
              if (this._functions[funydx][1] != name) {
                this._functions[funydx][1] = name;
                reindex = true;
              }
              break;
            }
          }
        }
      }
    }
    if (reindex) {
      this._yapi.imm_reindexDevice(this);
    }
  }
  imm_dropCache() {
    this._cache._expiration = 0;
    this._cache._precooked = {};
  }
  imm_functionCount() {
    let funcPos = 0;
    for (let key in this._functions) {
      funcPos++;
    }
    return funcPos;
  }
  imm_functionId(int_idx) {
    let funcPos = 0;
    for (let key in this._functions) {
      if (int_idx === funcPos) {
        return this._functions[key][0];
      }
      funcPos++;
    }
    return "";
  }
  imm_functionBaseType(int_idx) {
    let funid = this.imm_functionId(int_idx);
    if (funid !== "") {
      let ftype = this._yapi.imm_getFunctionBaseType(this._serialNumber + "." + funid);
      for (let baseType in Y_BASETYPES) {
        if (Y_BASETYPES[baseType] === ftype) {
          return baseType;
        }
      }
    }
    return "Function";
  }
  imm_functionType(int_idx) {
    let funid = this.imm_functionId(int_idx);
    if (funid !== "") {
      let i;
      for (i = funid.length; i > 0; i--) {
        if (funid[i - 1] > "9") {
          break;
        }
      }
      let functionType = funid[0].toUpperCase() + funid.substr(1, i - 1);
      return functionType;
    }
    return "";
  }
  imm_functionName(int_idx) {
    let funcPos = 0;
    for (let key in this._functions) {
      if (int_idx === funcPos) {
        return this._functions[key][1];
      }
      funcPos++;
    }
    return "";
  }
  imm_functionValue(int_idx) {
    let funid = this.imm_functionId(int_idx);
    if (funid !== "") {
      return this._yapi.imm_getFunctionValue(this._serialNumber + "." + funid);
    }
    return "";
  }
  imm_functionIdByFunYdx(int_funydx) {
    if (this._functions[int_funydx]) {
      return this._functions[int_funydx][0];
    }
    return "";
  }
  imm_jzon2json(jzon, json) {
    if (Array.isArray(jzon)) {
      let sz = jzon.length;
      if (Array.isArray(json)) {
        let defval = json.length > 0 ? json[0] : null;
        let res = [];
        for (let idx = 0; idx < sz; idx++) {
          res[idx] = this.imm_jzon2json(jzon[idx], defval);
        }
        return res;
      } else if (typeof json === "object") {
        let idx = 0;
        let res = {};
        for (let key in json) {
          if (json.hasOwnProperty(key)) {
            res[key] = this.imm_jzon2json(jzon[idx], json[key]);
            idx++;
          }
        }
        return res;
      } else {
        return jzon;
      }
    } else if (typeof jzon === "object") {
      if (Array.isArray(json)) {
        return jzon;
      } else if (typeof json === "object") {
        let defval = null;
        for (let key in json) {
          if (json.hasOwnProperty(key)) {
            defval = json[key];
            break;
          }
        }
        let res = {};
        for (let key in jzon) {
          if (jzon.hasOwnProperty(key)) {
            if (json.hasOwnProperty(key) && (!Array.isArray(json[key]) || json[key].length > 0)) {
              res[key] = this.imm_jzon2json(jzon[key], json[key]);
            } else {
              res[key] = this.imm_jzon2json(jzon[key], defval);
            }
          }
        }
        return res;
      } else {
        return jzon;
      }
    }
    return jzon;
  }
  async requestAPI(int_msValidity) {
    if (this._cache._expiration > this._yapi.GetTickCount()) {
      let res = new YHTTPRequest(this._cache._json);
      res.obj_result = JSON.parse(JSON.stringify(this._cache._precooked));
      return res;
    }
    let req = "GET /api.json";
    let precooked = this._cache._precooked;
    if (precooked.module && precooked.module.firmwareRelease) {
      req += "?fw=" + encodeURIComponent(precooked.module.firmwareRelease);
    }
    let yreq = await this._yapi.devRequest(this._rootUrl, req, null, 0);
    if (yreq.errorType != YAPI_SUCCESS)
      return yreq;
    if (!int_msValidity) {
      int_msValidity = this._yapi.defaultCacheValidity;
    }
    this._cache._json = yreq.bin_result;
    try {
      yreq.obj_result = JSON.parse(this._yapi.imm_bin2str(yreq.bin_result));
      if (Array.isArray(yreq.obj_result)) {
        if (precooked.module) {
          let objres = this.imm_jzon2json(yreq.obj_result, precooked);
          yreq.obj_result = objres;
          if (objres.module && objres.module.serialNumber === objres.module.serialNumber && objres.module.firmwareRelease === objres.module.firmwareRelease) {
            let jsonstr = JSON.stringify(yreq.obj_result);
            this._cache._json = yreq.bin_result = this._yapi.imm_str2bin(jsonstr);
            this._cache._precooked = JSON.parse(jsonstr);
          } else {
            this.imm_dropCache();
            yreq.errorType = YAPI_IO_ERROR;
            yreq.errorMsg = "Request failed, could not parse API JZON result for " + this._rootUrl;
          }
        } else {
          yreq.errorType = YAPI_IO_ERROR;
          yreq.errorMsg = "Request failed, could not parse API array result for " + this._rootUrl;
        }
      } else if (yreq.obj_result.module && yreq.obj_result.module.firmwareRelease) {
        this._cache._precooked = JSON.parse(JSON.stringify(yreq.obj_result));
      }
      this._cache._expiration = this._yapi.GetTickCount() + int_msValidity;
      this._logicalName = yreq.obj_result.module.logicalName;
      this._beacon = yreq.obj_result.module.beacon;
    } catch (err) {
      yreq.errorType = YAPI_IO_ERROR;
      yreq.errorMsg = "Request failed, could not parse API JSON result for " + this._rootUrl;
    }
    return yreq;
  }
  async refresh() {
    let yreq = await this.requestAPI(this._yapi.defaultCacheValidity);
    if (yreq.errorType != YAPI_SUCCESS) {
      return this._throw(yreq.errorType, yreq.errorMsg, yreq.errorType);
    }
    await this.updateFromReq(yreq, yreq.obj_result);
    return YAPI_SUCCESS;
  }
};
var YFirmwareFile = class {
  constructor(path, serial, pictype, product, firmware, prog_version, ROM_nb_zone, FLA_nb_zone, ROM_total_size, FLA_total_size, data, zone_ofs) {
    this._path = path;
    this._serial = serial;
    this._pictype = pictype;
    this._product = product;
    this._firmware = firmware;
    this._prog_version = prog_version;
    this._ROM_nb_zone = ROM_nb_zone;
    this._FLA_nb_zone = FLA_nb_zone;
    this._ROM_total_size = ROM_total_size;
    this._FLA_total_size = FLA_total_size;
    this._data = data;
    this._zone_ofs = zone_ofs;
  }
  static imm_Parse(path, data, force) {
    const BYN_REV_V4 = 4;
    const BYN_REV_V5 = 5;
    const BYN_REV_V6 = 6;
    const MAX_ROM_ZONES_PER_FILES = 16;
    const MAX_FLASH_ZONES_PER_FILES = 4;
    const BYN_HEAD_SIZE_V4 = 96 + 8;
    const BYN_HEAD_SIZE_V5 = 96 + 32;
    const BYN_HEAD_SIZE_V6 = 96 + 48;
    const BYN_MD5_OFS_V6 = 96 + 16;
    let pos = 0;
    let getShort = () => {
      let res = data[pos] + (data[pos + 1] << 8);
      pos += 2;
      return res;
    };
    let getInt = () => {
      let res = data[pos] + (data[pos + 1] << 8) + (data[pos + 2] << 16) + (data[pos + 3] << 24);
      pos += 4;
      return res;
    };
    let getString = (maxlen) => {
      let end = pos + maxlen;
      while (end > pos && data[end - 1] == 0) {
        end--;
      }
      let res = YAPI.imm_bin2str(data.subarray(pos, end));
      pos += maxlen;
      return res;
    };
    let sign = getString(4);
    if (sign != "BYN")
      return null;
    let rev = getShort();
    let serial = getString(20);
    let pictype = getString(20);
    let product = getString(28);
    let firmware = getString(22);
    if (serial.length >= 20)
      return null;
    if (product.length >= 28)
      return null;
    if (firmware.length >= 22)
      return null;
    let ROM_nb_zone = 0;
    let FLA_nb_zone = 0;
    let ROM_total_size = 0;
    let FLA_total_size = 0;
    let prog_buf;
    let prog_version = "";
    let zone_ofs;
    let datasize;
    switch (rev) {
      case BYN_REV_V4:
        zone_ofs = BYN_HEAD_SIZE_V4;
        ROM_nb_zone = getInt();
        datasize = getInt();
        if (ROM_nb_zone > MAX_ROM_ZONES_PER_FILES)
          return null;
        if (datasize != data.length - BYN_HEAD_SIZE_V4)
          return null;
        break;
      case BYN_REV_V5:
        zone_ofs = BYN_HEAD_SIZE_V5;
        prog_version = getString(22);
        if (!force && !YFirmwareFile.imm_progCompatible(prog_version))
          return null;
        getShort();
        ROM_nb_zone = getInt();
        datasize = getInt();
        if (ROM_nb_zone > MAX_ROM_ZONES_PER_FILES)
          return null;
        if (datasize != data.length - BYN_HEAD_SIZE_V5)
          return null;
        break;
      case BYN_REV_V6:
        zone_ofs = BYN_HEAD_SIZE_V6;
        let md5hdr = data.subarray(pos, pos + 16);
        pos += 16;
        let md5hdrstr = YAPI.imm_bin2hexstr(md5hdr);
        let md5ctx = new Y_MD5Ctx();
        md5ctx.addData(data.subarray(BYN_MD5_OFS_V6));
        let md5bynstr = YAPI.imm_bin2hexstr(md5ctx.calculate());
        if (md5hdrstr != md5bynstr) {
          YAPI.imm_log("Invalid firmware image signature, file is corrupt");
          if (YAPI._logLevel >= 2) {
            YAPI.imm_log("hdr MD5: " + md5hdrstr);
            YAPI.imm_log("byn MD5: " + md5bynstr);
            YAPI.imm_log("byn size: " + data.length);
          }
          return null;
        }
        prog_version = getString(22);
        if (!force && !YFirmwareFile.imm_progCompatible(prog_version))
          return null;
        ROM_nb_zone = data[pos++];
        FLA_nb_zone = data[pos++];
        ROM_total_size = getInt();
        FLA_total_size = getInt();
        if (ROM_nb_zone > MAX_ROM_ZONES_PER_FILES)
          return null;
        if (FLA_nb_zone > MAX_FLASH_ZONES_PER_FILES)
          return null;
        break;
      default:
        return null;
    }
    return new YFirmwareFile(path, serial, pictype, product, firmware, prog_version, ROM_nb_zone, FLA_nb_zone, ROM_total_size, FLA_total_size, data, zone_ofs);
  }
  static imm_progCompatible(prog_version) {
    if (prog_version == "")
      return true;
    let apiVer = YAPI.imm_GetAPIVersion();
    let dashpos = apiVer.indexOf("-");
    if (dashpos > 0) {
      apiVer = apiVer.slice(0, dashpos);
    }
    apiVer = apiVer.slice(apiVer.lastIndexOf(".") + 1);
    if (parseInt(prog_version) > parseInt(apiVer)) {
      YAPI.imm_log("checkProgField: byn=" + prog_version + " api=" + apiVer);
      return false;
    }
    return true;
  }
  imm_getSerial() {
    return this._serial;
  }
  imm_getPictype() {
    return this._pictype;
  }
  imm_getProduct() {
    return this._product;
  }
  imm_getFirmwareRelease() {
    return this._firmware;
  }
  imm_getFirmwareReleaseAsInt() {
    return parseInt(this._firmware);
  }
  imm_getProg_version() {
    return this._prog_version;
  }
  imm_getROM_nb_zone() {
    return this._ROM_nb_zone;
  }
  imm_getFLA_nb_zone() {
    return this._FLA_nb_zone;
  }
  imm_getROM_total_size() {
    return this._ROM_total_size;
  }
  imm_getFLA_total_size() {
    return this._FLA_total_size;
  }
  imm_getData() {
    return this._data;
  }
  imm_getPath() {
    return this._path;
  }
};
var YFirmwareUpdate = class {
  constructor(obj_yapi, str_serial, str_path, bin_settings, bool_force) {
    this._serial = "";
    this._settings = new Uint8Array(0);
    this._firmwarepath = "";
    this._progress_msg = "";
    this._progress_c = 0;
    this._progress = 0;
    this._restore_step = 0;
    this._force = false;
    this._yapi = obj_yapi;
    this._serial = str_serial;
    this._firmwarepath = str_path;
    this._settings = bin_settings;
    this._force = bool_force;
  }
  imm_progress(progress, msg) {
    this._progress = progress;
    this._progress_msg = msg;
  }
  async _processMore_internal(newupdate) {
    if (!newupdate)
      return YAPI_SUCCESS;
    let bytes;
    this.imm_progress(0, "Firmware update started");
    if (typeof this._firmwarepath == "string" && this._firmwarepath.indexOf("yoctopuce.com") >= 0) {
      this.imm_progress(1, "Downloading firmware");
      bytes = await this._yapi.system_env.downloadfile(this._firmwarepath);
    } else {
      this.imm_progress(1, "Loading firmware");
      bytes = await this._yapi.system_env.loadfile(this._firmwarepath);
    }
    let firmware = YFirmwareFile.imm_Parse(this._firmwarepath, bytes, this._force);
    if (!firmware) {
      return this._yapi._throw(YAPI_DEVICE_NOT_FOUND, "Device " + this._serial + " is not detected", YAPI_DEVICE_NOT_FOUND);
    }
    this.imm_progress(5, "Check if module is already in bootloader");
    let hub = null;
    let module = YModule.FindModuleInContext(this._yapi, this._serial + ".module");
    if (await module.isOnline()) {
      let dev = this._yapi.imm_getDevice(this._serial);
      let baseUrl = dev.imm_getRootUrl();
      let byPos = baseUrl.indexOf("/bySerial/");
      if (byPos >= 0) {
        baseUrl = baseUrl.slice(0, byPos + 1);
      } else if (baseUrl.slice(-1) != "/")
        baseUrl = baseUrl + "/";
      let urlInfo = this._yapi.imm_parseRegisteredUrl(baseUrl);
      hub = this._yapi.imm_getHub(urlInfo);
    } else {
      let hubs = this._yapi._connectedHubs;
      for (let i = 0; i < hubs.length; i++) {
        let ldrs = await hubs[i].getBootloaders();
        if (ldrs.indexOf(this._serial) >= 0) {
          hub = hubs[i];
          break;
        }
      }
    }
    if (hub == null) {
      this.imm_progress(-1, "Device " + this._serial + " is not detected");
      return this._yapi._throw(YAPI_DEVICE_NOT_FOUND, "Device " + this._serial + " is not detected", YAPI_DEVICE_NOT_FOUND);
    }
    try {
      await hub.firmwareUpdate(this._serial, firmware, this._settings, (percent, msg) => {
        this.imm_progress(5 + (percent * 80 + 50) / 100 >> 0, msg);
      });
    } catch (e) {
      this.imm_progress(-1, e.message);
      return this._yapi._throw(YAPI_IO_ERROR, e.message, YAPI_IO_ERROR);
    }
    this.imm_progress(80, "Wait for the device to restart");
    let timeout = this._yapi.GetTickCount() + 6e4;
    await module.clearCache();
    while (!await module.isOnline() && timeout > this._yapi.GetTickCount()) {
      await this._yapi.Sleep(500);
      await this._yapi.UpdateDeviceList();
    }
    if (await module.isOnline()) {
      if (this._settings != null) {
        this.imm_progress(95, "Restoring device settings");
        await module.set_allSettingsAndFiles(this._settings);
        await module.saveToFlash();
      }
      let real_fw = await module.get_firmwareRelease();
      if (real_fw == firmware.imm_getFirmwareRelease()) {
        this.imm_progress(100, "Success");
      } else {
        this.imm_progress(-1, "Unable to update firmware");
      }
    } else {
      this.imm_progress(-1, "Device did not reboot correctly");
    }
    return YAPI_SUCCESS;
  }
  static async checkFirmware_r(file, serial_base, force) {
    if (file.substr(-4).toLowerCase() != ".byn")
      return null;
    let bynfile = await YAPI.system_env.loadfile(file);
    let firmware = YFirmwareFile.imm_Parse(file, bynfile, force);
    if (!firmware)
      return null;
    if (firmware.imm_getSerial().slice(0, serial_base.length) != serial_base)
      return null;
    return firmware;
  }
  static async CheckFirmwareEx(serial, path, minrelease, force) {
    let link = "";
    let best_rev = 0;
    let current_rev;
    if (typeof path == "string" && path.indexOf("yoctopuce.com") >= 0) {
      try {
        let data = await YAPI.system_env.downloadfile("http://www.yoctopuce.com/FR/common/getLastFirmwareLink.php?serial=" + serial);
        let obj = JSON.parse(YAPI.imm_bin2str(data));
        link = obj["link"];
        best_rev = obj["version"];
      } catch (e) {
        YAPI.imm_log("failed to retrieve firmware information from www.yoctopuce.com", e);
        YAPI._throw(YAPI_IO_ERROR, "failed to retrieve firmware information from www.yoctopuce.com", "");
        return "";
      }
    } else {
      let firmware = await YFirmwareUpdate.checkFirmware_r(path, serial.substring(0, 8), force);
      if (firmware != null) {
        best_rev = firmware.imm_getFirmwareReleaseAsInt();
        link = firmware.imm_getPath();
      }
    }
    if (minrelease != 0) {
      if (minrelease < best_rev) {
        return link;
      } else {
        return "";
      }
    }
    return link;
  }
  static async CheckFirmware_internal(serial, path, minrelease) {
    return YFirmwareUpdate.CheckFirmwareEx(serial, path, minrelease, false);
  }
  static async GetAllBootLoadersInContext_internal(yctx) {
    let hubs = yctx._connectedHubs;
    let res = [];
    for (let i = 0; i < hubs.length; i++) {
      let ldrs = await hubs[i].getBootloaders();
      for (let j = 0; j < ldrs.length; j++) {
        res.push(ldrs[j]);
      }
    }
    return res;
  }
  static async GetAllBootLoaders_internal() {
    return YFirmwareUpdate.GetAllBootLoadersInContext(YAPI);
  }
  async _processMore(newupdate) {
    return await this._processMore_internal(newupdate);
  }
  static async GetAllBootLoaders() {
    return await this.GetAllBootLoaders_internal();
  }
  static async GetAllBootLoadersInContext(yctx) {
    return await this.GetAllBootLoadersInContext_internal(yctx);
  }
  static async CheckFirmware(serial, path, minrelease) {
    return await this.CheckFirmware_internal(serial, path, minrelease);
  }
  async get_progress() {
    if (this._progress >= 0) {
      await this._processMore(0);
    }
    return this._progress;
  }
  async get_progressMessage() {
    return this._progress_msg;
  }
  async startUpdate() {
    let err;
    let leng;
    err = this._yapi.imm_bin2str(this._settings);
    leng = err.length;
    if (leng >= 6 && err.substr(0, 6) == "error:") {
      this._progress = -1;
      this._progress_msg = err.substr(6, leng - 6);
    } else {
      this._progress = 0;
      this._progress_c = 0;
      await this._processMore(1);
    }
    return this._progress;
  }
};
var YFunction = class {
  constructor(obj_yapi, str_func) {
    this._logicalName = YFunction.LOGICALNAME_INVALID;
    this._advertisedValue = YFunction.ADVERTISEDVALUE_INVALID;
    this._valueCallbackFunction = null;
    this._cacheExpiration = 0;
    this._serial = "";
    this._funId = "";
    this._hwId = "";
    this.LOGICALNAME_INVALID = YAPI_INVALID_STRING;
    this.ADVERTISEDVALUE_INVALID = YAPI_INVALID_STRING;
    this._yapi = obj_yapi;
    this._className = "Function";
    this._func = str_func;
    this._lastErrorType = YAPI_SUCCESS;
    this._lastErrorMsg = "no error";
    this._dataStreams = {};
    this._userData = null;
    this._cache = {_expiration: -1, functionid: "", hwid: ""};
    this._valueCallbackFunction = null;
  }
  _throw(int_errType, str_errMsg, obj_retVal) {
    this._lastErrorType = int_errType;
    this._lastErrorMsg = str_errMsg;
    return this._yapi._throw(int_errType, str_errMsg, obj_retVal);
  }
  async isReadOnly_internal() {
    try {
      let serial = await this.get_serialNumber();
      return this._yapi.isReadOnly(serial);
    } catch (e) {
      return true;
    }
  }
  imm_parseAttr(name, val) {
    switch (name) {
      case "_expiration":
        this._cacheExpiration = val;
        return 1;
      case "logicalName":
        this._logicalName = val;
        return 1;
      case "advertisedValue":
        this._advertisedValue = val;
        return 1;
    }
    return 0;
  }
  async get_logicalName() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YFunction.LOGICALNAME_INVALID;
      }
    }
    res = this._logicalName;
    return res;
  }
  async set_logicalName(newval) {
    let rest_val;
    if (!await YAPI.CheckLogicalName(newval)) {
      return this._throw(YAPI.INVALID_ARGUMENT, "Invalid name :" + newval, YAPI.INVALID_ARGUMENT);
    }
    rest_val = String(newval);
    return await this._setAttr("logicalName", rest_val);
  }
  async get_advertisedValue() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YFunction.ADVERTISEDVALUE_INVALID;
      }
    }
    res = this._advertisedValue;
    return res;
  }
  async set_advertisedValue(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("advertisedValue", rest_val);
  }
  static FindFunction(func) {
    let obj;
    obj = YFunction._FindFromCache("Function", func);
    if (obj == null) {
      obj = new YFunction(YAPI, func);
      YFunction._AddToCache("Function", func, obj);
    }
    return obj;
  }
  static FindFunctionInContext(yctx, func) {
    let obj;
    obj = YFunction._FindFromCacheInContext(yctx, "Function", func);
    if (obj == null) {
      obj = new YFunction(yctx, func);
      YFunction._AddToCache("Function", func, obj);
    }
    return obj;
  }
  async registerValueCallback(callback) {
    let val;
    if (callback != null) {
      await YFunction._UpdateValueCallbackList(this, true);
    } else {
      await YFunction._UpdateValueCallbackList(this, false);
    }
    this._valueCallbackFunction = callback;
    if (callback != null && await this.isOnline()) {
      val = this._advertisedValue;
      if (!(val == "")) {
        await this._invokeValueCallback(val);
      }
    }
    return 0;
  }
  async _invokeValueCallback(value) {
    if (this._valueCallbackFunction != null) {
      try {
        await this._valueCallbackFunction(this, value);
      } catch (e) {
        this._yapi.imm_log("Exception in valueCallback:", e);
      }
    } else {
    }
    return 0;
  }
  async muteValueCallbacks() {
    return await this.set_advertisedValue("SILENT");
  }
  async unmuteValueCallbacks() {
    return await this.set_advertisedValue("");
  }
  async loadAttribute(attrName) {
    let url;
    let attrVal;
    url = "api/" + await this.get_functionId() + "/" + attrName;
    attrVal = await this._download(url);
    return this._yapi.imm_bin2str(attrVal);
  }
  async isReadOnly() {
    return await this.isReadOnly_internal();
  }
  async get_serialNumber() {
    let m;
    m = await this.get_module();
    return await m.get_serialNumber();
  }
  async _parserHelper() {
    return 0;
  }
  nextFunction() {
    let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
    if (resolve.errorType != YAPI.SUCCESS)
      return null;
    let next_hwid = this._yapi.imm_getNextHardwareId(this._className, resolve.result);
    if (next_hwid == null)
      return null;
    return YFunction.FindFunctionInContext(this._yapi, next_hwid);
  }
  static FirstFunction() {
    let next_hwid = YAPI.imm_getFirstHardwareId("Function");
    if (next_hwid == null)
      return null;
    return YFunction.FindFunction(next_hwid);
  }
  static FirstFunctionInContext(yctx) {
    let next_hwid = yctx.imm_getFirstHardwareId("Function");
    if (next_hwid == null)
      return null;
    return YFunction.FindFunctionInContext(yctx, next_hwid);
  }
  static _FindFromCacheInContext(yctx, className, func) {
    return yctx.imm_getFunction(className, func);
  }
  static _FindFromCache(className, func) {
    return YAPI.imm_getFunction(className, func);
  }
  static _AddToCache(className, func, obj) {
    obj._yapi.imm_setFunction(className, func, obj);
  }
  static _ClearCache(obj_yapi = null) {
    if (!obj_yapi)
      obj_yapi = YAPI;
    obj_yapi.imm_ResetToDefaults();
  }
  static async _UpdateValueCallbackList(obj_func, bool_add) {
    await obj_func._yapi._UpdateValueCallbackList(obj_func, bool_add);
  }
  static async _UpdateTimedReportCallbackList(obj_func, bool_add) {
    await obj_func._yapi._UpdateTimedReportCallbackList(obj_func, bool_add);
  }
  async describe() {
    if (this._hwId != "") {
      return this._className + "(" + this._func + ")=" + this._hwId;
    }
    let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
    if (resolve.errorType != YAPI_SUCCESS && resolve.result != this._func) {
      return this._className + "(" + this._func + ")=unresolved";
    }
    return this._className + "(" + this._func + ")=" + resolve.result;
  }
  async get_hardwareId() {
    if (this._hwId != "") {
      return this._hwId;
    }
    let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
    if (resolve.errorType != YAPI_SUCCESS) {
      await this.isOnline();
      resolve = this._yapi.imm_resolveFunction(this._className, this._func);
      if (resolve.errorType != YAPI_SUCCESS) {
        return this._throw(resolve.errorType, resolve.errorMsg, YFunction.HARDWAREID_INVALID);
      }
    }
    return resolve.result;
  }
  async get_functionId() {
    if (this._funId != "") {
      return this._funId;
    }
    let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
    if (resolve.errorType != YAPI_SUCCESS) {
      await this.isOnline();
      resolve = this._yapi.imm_resolveFunction(this._className, this._func);
      if (resolve.errorType != YAPI_SUCCESS) {
        return this._throw(resolve.errorType, resolve.errorMsg, YFunction.FUNCTIONID_INVALID);
      }
    }
    let hardwareId = resolve.result;
    let pos = hardwareId.indexOf(".");
    return hardwareId.substr(pos + 1);
  }
  imm_get_functionId() {
    if (this._funId != "") {
      return this._funId;
    }
    let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
    if (resolve.errorType != YAPI_SUCCESS) {
      return this._throw(resolve.errorType, resolve.errorMsg, YFunction.FUNCTIONID_INVALID);
    }
    let hardwareId = resolve.result;
    let pos = hardwareId.indexOf(".");
    return hardwareId.substr(pos + 1);
  }
  async get_friendlyName() {
    let resolve = this._yapi.imm_getFriendlyNameFunction(this._className, this._func);
    if (resolve.errorType != YAPI_SUCCESS) {
      await this.isOnline();
      resolve = this._yapi.imm_getFriendlyNameFunction(this._className, this._func);
      if (resolve.errorType != YAPI_SUCCESS) {
        return this._throw(resolve.errorType, resolve.errorMsg, YFunction.FRIENDLYNAME_INVALID);
      }
    }
    return resolve.result;
  }
  async _parse(yreq, msValidity) {
    if (!yreq.obj_result)
      return;
    yreq.obj_result._expiration = this._yapi.GetTickCount() + msValidity;
    this._cache = yreq.obj_result;
    this._serial = yreq.obj_result.deviceid;
    this._funId = yreq.obj_result.functionid;
    this._hwId = yreq.obj_result.hwid;
    for (let key in yreq.obj_result) {
      this.imm_parseAttr(key, yreq.obj_result[key]);
    }
    await this._parserHelper();
  }
  isOnline_async(func, ctx) {
    this.isOnline().then((res) => {
      func(ctx, this, res);
    }).catch((e) => {
      func(ctx, this, false);
    });
  }
  load_async(ms_validiy, func, ctx) {
    this.load(ms_validiy).then((res) => {
      func(ctx, this, YAPI_SUCCESS);
    }).catch((e) => {
      func(ctx, this, this.get_errorType());
    });
  }
  async _getAttr(str_attr) {
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS)
        return null;
    }
    if (typeof this._cache[str_attr] == "undefined") {
      this._throw(YAPI_VERSION_MISMATCH, "No such attribute " + str_attr + " in function", null);
    }
    return this._cache[str_attr];
  }
  async _getFixedAttr(str_attr) {
    if (this._cacheExpiration == 0) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS)
        return null;
    }
    if (typeof this._cache[str_attr] == "undefined") {
      this._throw(YAPI_VERSION_MISMATCH, "No such attribute " + str_attr + " in function", null);
    }
    return this._cache[str_attr];
  }
  imm_escapeAttr(str_newval) {
    return escape(str_newval).replace(/[+]/g, "%2B").replace(/%20/g, "+").replace(/%21/g, "!").replace(/%24/g, "$").replace(/%27/g, "'").replace(/%28/g, "(").replace(/%29/g, ")").replace(/%2[cC]/g, ",").replace(/%2[fF]/g, "/").replace(/%3[aA]/g, ":").replace(/%3[bB]/g, ";").replace(/%3[fF]/g, "?").replace(/%5[bB]/g, "[").replace(/%5[dD]/g, "]");
  }
  async _setAttr(str_attr, str_newval) {
    if (str_newval == void 0) {
      return this._throw(YAPI_INVALID_ARGUMENT, "Undefined value to set for attribute " + str_attr, null);
    }
    let attrname = encodeURIComponent(str_attr);
    let attrval = this.imm_escapeAttr(str_newval);
    let extra = "/" + attrname + "?" + attrname + "=" + attrval + "&.";
    if (this._cacheExpiration != 0) {
      this._cacheExpiration = this._yapi.GetTickCount();
      this._cache._expiration = this._cacheExpiration;
    }
    let yreq = await this._yapi.funcRequest(this._className, this._func, extra);
    if (yreq.errorType != YAPI_SUCCESS) {
      return this._throw(yreq.errorType, yreq.errorMsg, yreq.errorType);
    }
    return YAPI_SUCCESS;
  }
  async _download(str_path) {
    let devid = this._serial;
    if (devid == "") {
      devid = await (await this.module()).get_serialNumber();
    }
    if (devid == YAPI_INVALID_STRING) {
      return new Uint8Array(0);
    }
    let yreq = await this._yapi.devRequest(devid, "GET /" + str_path, null, 0);
    if (yreq.errorType != YAPI_SUCCESS) {
      return this._throw(yreq.errorType, yreq.errorMsg, "");
    }
    return yreq.bin_result;
  }
  async _downloadOutOfBand(str_path) {
    let devid = this._serial;
    if (devid == "") {
      devid = await (await this.module()).get_serialNumber();
    }
    if (devid == YAPI_INVALID_STRING) {
      return new Uint8Array(0);
    }
    let yreq = await this._yapi.devRequest(devid, "GET /" + str_path, null, 1);
    if (yreq.errorType != YAPI_SUCCESS) {
      return this._throw(yreq.errorType, yreq.errorMsg, "");
    }
    return yreq.bin_result;
  }
  async _uploadWithProgress(str_path, bin_content, fun_progressCb) {
    let devid = this._serial;
    if (devid == "") {
      devid = await (await this.module()).get_serialNumber();
    }
    if (devid == YAPI_INVALID_STRING) {
      let res = new YHTTPRequest(null);
      res.errorType = this.get_errorType();
      res.errorMsg = this.get_errorMessage();
      return res;
    }
    let httpreq = "POST /upload.html";
    let len = bin_content.length;
    if (typeof bin_content == "string" || bin_content instanceof String) {
      bin_content = this._yapi.imm_str2bin(bin_content);
    } else if (bin_content instanceof Array) {
      bin_content = new Uint8Array(bin_content);
    }
    return this._yapi.devRequest(devid, httpreq, new YHTTPBody(str_path, bin_content, fun_progressCb), 0);
  }
  async _uploadEx(str_path, bin_content) {
    let yreq = await this._uploadWithProgress(str_path, bin_content, null);
    if (yreq.errorType != YAPI_SUCCESS) {
      return this._throw(yreq.errorType, yreq.errorMsg, null);
    }
    return yreq.bin_result;
  }
  async _upload(str_path, bin_content) {
    let yreq = await this._uploadWithProgress(str_path, bin_content, null);
    if (yreq.errorType != YAPI_SUCCESS) {
      return this._throw(yreq.errorType, yreq.errorMsg, null);
    }
    return yreq.errorType;
  }
  wait_async(callback, context) {
    let devid = this._serial;
    if (devid == "") {
      this.module().then((module) => module.get_serialNumber().then(() => this.wait_async(callback, context)));
      return YAPI_SUCCESS;
    }
    if (devid == YAPI_INVALID_STRING) {
      callback(context, this);
      return YAPI_SUCCESS;
    }
    let lockdev = this._yapi.imm_getDevice(devid);
    let delayedCode = () => {
      callback(context, this);
    };
    lockdev._pendingQueries = lockdev._pendingQueries.then(delayedCode, delayedCode);
    return YAPI_SUCCESS;
  }
  imm_json_get_key(bin_jsonbuff, str_key) {
    let loadval = JSON.parse(this._yapi.imm_bin2str(bin_jsonbuff));
    if (typeof loadval[str_key] != "undefined") {
      return loadval[str_key];
    }
    return "";
  }
  imm_json_get_string(bin_jsonbuff) {
    return JSON.parse(this._yapi.imm_bin2str(bin_jsonbuff));
  }
  imm_json_get_array(bin_jsonbuff) {
    let loadval = JSON.parse(this._yapi.imm_bin2str(bin_jsonbuff));
    let res = [];
    for (let idx in loadval) {
      res.push(JSON.stringify(loadval[idx]));
    }
    return res;
  }
  imm_get_json_path(str_json, str_path) {
    let json = JSON.parse(str_json);
    let paths = str_path.split("|");
    for (let i = 0; i < paths.length; i++) {
      let tmp = paths[i];
      json = json[tmp];
      if (json == void 0) {
        return "";
      }
    }
    return JSON.stringify(json);
  }
  imm_decode_json_string(str_json) {
    if (str_json === "") {
      return "";
    }
    return JSON.parse(str_json);
  }
  imm_findDataStream(obj_dataset, str_def) {
    let key = obj_dataset.imm_get_functionId() + ":" + str_def;
    if (this._dataStreams[key]) {
      return this._dataStreams[key];
    }
    let words = this._yapi.imm_decodeWords(str_def);
    if (words.length < 14) {
      this._throw(YAPI.VERSION_MISMATCH, "device firwmare is too old", null);
      return null;
    }
    let newDataStream = new YDataStream(this, obj_dataset, words);
    this._dataStreams[key] = newDataStream;
    return newDataStream;
  }
  async clearDataStreamCache() {
    this._dataStreams = {};
  }
  async isOnline() {
    if (this._cacheExpiration > this._yapi.GetTickCount())
      return true;
    let yreq = await this._yapi.funcRequest(this._className, this._func, "", this._yapi.defaultCacheValidity);
    if (yreq.errorType != YAPI_SUCCESS) {
      return yreq.errorType == YAPI_DEVICE_BUSY;
    }
    await this._parse(yreq, this._yapi.defaultCacheValidity);
    return true;
  }
  get_errorType() {
    return this._lastErrorType;
  }
  get_errorMessage() {
    return this._lastErrorMsg;
  }
  async load(msValidity) {
    let yreq = await this._yapi.funcRequest(this._className, this._func, "", msValidity);
    if (yreq.errorType != YAPI_SUCCESS) {
      return this._throw(yreq.errorType, yreq.errorMsg, yreq.errorType);
    }
    await this._parse(yreq, msValidity);
    return YAPI_SUCCESS;
  }
  async clearCache() {
    let devreq = await this._yapi._funcDev(this._className, this._func);
    if (devreq.errorType != YAPI_SUCCESS) {
      return;
    }
    devreq.obj_result.device.imm_dropCache();
    if (this._cacheExpiration > 0) {
      this._cacheExpiration = this._yapi.GetTickCount();
    }
  }
  async module() {
    if (this._serial != "") {
      return YModule.FindModuleInContext(this._yapi, this._serial + ".module");
    }
    let hwid = this._func;
    let resolve;
    if (hwid.indexOf(".") < 0) {
      resolve = this._yapi.imm_resolveFunction(this._className, this._func);
      if (resolve.errorType == YAPI_SUCCESS)
        hwid = resolve.result;
    }
    let dotidx = hwid.indexOf(".");
    if (dotidx >= 0) {
      return YModule.FindModuleInContext(this._yapi, hwid.substr(0, dotidx) + ".module");
    }
    if (await this.load(this._yapi.defaultCacheValidity) == YAPI_SUCCESS) {
      resolve = this._yapi.imm_resolveFunction(this._className, this._func);
      if (resolve.result)
        hwid = resolve.result;
    }
    dotidx = hwid.indexOf(".");
    if (dotidx >= 0) {
      return YModule.FindModuleInContext(this._yapi, hwid.substr(0, dotidx) + ".module");
    }
    return YModule.FindModuleInContext(this._yapi, "module_of_" + this._className + "_" + this._func);
  }
  async get_module() {
    return this.module();
  }
  async get_functionDescriptor() {
    if (this._hwId != "") {
      return this._hwId;
    }
    let hwid = this._func;
    if (hwid.indexOf(".") < 0) {
      let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
      if (resolve.errorType != YAPI_SUCCESS)
        hwid = resolve.result;
    }
    let dotidx = hwid.indexOf(".");
    if (dotidx >= 0) {
      return hwid;
    }
    return Y_FUNCTIONDESCRIPTOR_INVALID;
  }
  async get_userData() {
    return this._userData;
  }
  async set_userData(data) {
    this._userData = data;
  }
};
YFunction.LOGICALNAME_INVALID = YAPI_INVALID_STRING;
YFunction.ADVERTISEDVALUE_INVALID = YAPI_INVALID_STRING;
(function(YFunction2) {
  YFunction2.FUNCTIONDESCRIPTOR_INVALID = YAPI_INVALID_STRING;
  YFunction2.HARDWAREID_INVALID = YAPI_INVALID_STRING;
  YFunction2.FUNCTIONID_INVALID = YAPI_INVALID_STRING;
  YFunction2.FRIENDLYNAME_INVALID = YAPI_INVALID_STRING;
})(YFunction || (YFunction = {}));
var YModule = class extends YFunction {
  constructor(yapi, func) {
    super(yapi, func);
    this._productName = YModule.PRODUCTNAME_INVALID;
    this._serialNumber = YModule.SERIALNUMBER_INVALID;
    this._productId = YModule.PRODUCTID_INVALID;
    this._productRelease = YModule.PRODUCTRELEASE_INVALID;
    this._firmwareRelease = YModule.FIRMWARERELEASE_INVALID;
    this._persistentSettings = YModule.PERSISTENTSETTINGS_INVALID;
    this._luminosity = YModule.LUMINOSITY_INVALID;
    this._beacon = YModule.BEACON_INVALID;
    this._upTime = YModule.UPTIME_INVALID;
    this._usbCurrent = YModule.USBCURRENT_INVALID;
    this._rebootCountdown = YModule.REBOOTCOUNTDOWN_INVALID;
    this._userVar = YModule.USERVAR_INVALID;
    this._valueCallbackModule = null;
    this._logCallback = null;
    this._confChangeCallback = null;
    this._beaconCallback = null;
    this.PRODUCTNAME_INVALID = YAPI_INVALID_STRING;
    this.SERIALNUMBER_INVALID = YAPI_INVALID_STRING;
    this.PRODUCTID_INVALID = YAPI_INVALID_UINT;
    this.PRODUCTRELEASE_INVALID = YAPI_INVALID_UINT;
    this.FIRMWARERELEASE_INVALID = YAPI_INVALID_STRING;
    this.PERSISTENTSETTINGS_LOADED = 0;
    this.PERSISTENTSETTINGS_SAVED = 1;
    this.PERSISTENTSETTINGS_MODIFIED = 2;
    this.PERSISTENTSETTINGS_INVALID = -1;
    this.LUMINOSITY_INVALID = YAPI_INVALID_UINT;
    this.BEACON_OFF = 0;
    this.BEACON_ON = 1;
    this.BEACON_INVALID = -1;
    this.UPTIME_INVALID = YAPI_INVALID_LONG;
    this.USBCURRENT_INVALID = YAPI_INVALID_UINT;
    this.REBOOTCOUNTDOWN_INVALID = YAPI_INVALID_INT;
    this.USERVAR_INVALID = YAPI_INVALID_INT;
    this._className = "Module";
    let devid = this._func;
    let dotidx = devid.indexOf(".");
    if (dotidx > 0)
      devid = devid.substr(0, dotidx);
    let dev = this._yapi.imm_getDevice(devid);
    if (dev) {
      this._serial = dev.imm_getSerialNumber();
      this._funId = "module";
      this._hwId = this._serial + ".module";
    }
  }
  _throw(int_errType, str_errMsg, obj_retVal) {
    this._lastErrorType = int_errType;
    this._lastErrorMsg = str_errMsg;
    return this._yapi._throw(int_errType, str_errMsg, obj_retVal);
  }
  static async _updateModuleCallbackList(YModule_module, bool_add) {
  }
  imm_getDev() {
    let devid = this._func;
    let dotidx = devid.indexOf(".");
    if (dotidx > 0)
      devid = devid.substr(0, dotidx);
    let dev = this._yapi.imm_getDevice(devid);
    if (!dev) {
      this._throw(YAPI_DEVICE_NOT_FOUND, "Device [" + devid + "] is not online", null);
    }
    return dev;
  }
  async forceDeviceRefresh() {
    let dev = this.imm_getDev();
    if (!dev || !this._serial)
      return;
    await this._yapi.ForceDeviceRefresh(this._serial);
    if (this._cacheExpiration > 0) {
      this._cacheExpiration = this._yapi.GetTickCount();
    }
  }
  async functionCount() {
    let dev = this.imm_getDev();
    if (!dev)
      return YAPI_DEVICE_NOT_FOUND;
    return dev.imm_functionCount();
  }
  async functionId(functionIndex) {
    let dev = this.imm_getDev();
    if (!dev)
      return "";
    return dev.imm_functionId(functionIndex);
  }
  async functionType(functionIndex) {
    let dev = this.imm_getDev();
    if (!dev)
      return "";
    return dev.imm_functionType(functionIndex);
  }
  async functionBaseType(functionIndex) {
    let dev = this.imm_getDev();
    if (!dev)
      return "";
    return dev.imm_functionBaseType(functionIndex);
  }
  async functionName(functionIndex) {
    let dev = this.imm_getDev();
    if (!dev)
      return "";
    return dev.imm_functionName(functionIndex);
  }
  async functionValue(functionIndex) {
    let dev = this.imm_getDev();
    if (!dev)
      return "";
    return dev.imm_functionValue(functionIndex);
  }
  async get_logicalName() {
    let dev = this.imm_getDev();
    if (dev != null && this._cache._expiration <= this._yapi.GetTickCount()) {
      return dev.getLogicalName();
    }
    let json_val = await this._getAttr("logicalName");
    return json_val == null ? YModule.LOGICALNAME_INVALID : json_val;
  }
  async set_logicalName(newval) {
    let res = await super.set_logicalName(newval);
    let dev = this.imm_getDev();
    if (dev != null) {
      dev.imm_dropCache();
    }
    return res;
  }
  imm_flattenJsonStruct_internal(jsoncomplex) {
    let decoded = JSON.parse(this._yapi.imm_bin2str(jsoncomplex));
    let attrs = [];
    for (let function_name in decoded) {
      if (function_name == "services") {
        continue;
      }
      let function_attrs = decoded[function_name];
      for (let attr_name in function_attrs) {
        let attr_value = function_attrs[attr_name];
        if (attr_value === null || typeof attr_value === "object") {
          continue;
        }
        let flat = function_name + "/" + attr_name + "=" + attr_value;
        attrs.push(flat);
      }
    }
    return this._yapi.imm_str2bin(JSON.stringify(attrs));
  }
  async get_subDevices_internal() {
    let baseUrl = await this.get_url_internal();
    if (!baseUrl) {
      return [];
    }
    let hub = null;
    let hubUrl = "";
    for (let i = 0; i < this._yapi._connectedHubs.length; i++) {
      hubUrl = this._yapi._connectedHubs[i].urlInfo.rootUrl;
      if (baseUrl.slice(0, hubUrl.length) == hubUrl) {
        hub = this._yapi._connectedHubs[i];
        break;
      }
    }
    if (!hub || !hubUrl) {
      return [];
    }
    let hubSerial = hub.serialByYdx[0];
    if (hubSerial != this._serial) {
      return [];
    }
    let res = [];
    for (let serial in this._yapi._devs) {
      let rooturl = this._yapi._devs[serial].imm_getRootUrl();
      if (rooturl.substr(0, hubUrl.length) == hubUrl && serial != hubSerial) {
        res.push(serial);
      }
    }
    return res;
  }
  async get_parentHub_internal() {
    let baseUrl = await this.get_url_internal();
    if (!baseUrl) {
      return "";
    }
    let hub = null;
    for (let i = 0; i < this._yapi._connectedHubs.length; i++) {
      let hubUrl = this._yapi._connectedHubs[i].urlInfo.rootUrl;
      if (baseUrl.slice(0, hubUrl.length) == hubUrl) {
        hub = this._yapi._connectedHubs[i];
        break;
      }
    }
    if (!hub) {
      return "";
    }
    let hubSerial = hub.serialByYdx[0];
    if (hubSerial == this._serial) {
      return "";
    }
    return hubSerial;
  }
  async get_url_internal() {
    let devid = this._serial;
    if (devid == "") {
      devid = await this.get_serialNumber();
    }
    if (devid == YAPI_INVALID_STRING) {
      return "";
    }
    let lockdev = this._yapi.imm_getDevice(devid);
    if (!lockdev) {
      return "";
    }
    return lockdev.imm_getRootUrl();
  }
  async _startStopDevLog_internal(str_serial, bool_start) {
    let dev = this.imm_getDev();
    if (dev != null) {
      return dev.imm_registerLogCallback(this._logCallback);
    }
  }
  imm_parseAttr(name, val) {
    switch (name) {
      case "productName":
        this._productName = val;
        return 1;
      case "serialNumber":
        this._serialNumber = val;
        return 1;
      case "productId":
        this._productId = val;
        return 1;
      case "productRelease":
        this._productRelease = val;
        return 1;
      case "firmwareRelease":
        this._firmwareRelease = val;
        return 1;
      case "persistentSettings":
        this._persistentSettings = val;
        return 1;
      case "luminosity":
        this._luminosity = val;
        return 1;
      case "beacon":
        this._beacon = val;
        return 1;
      case "upTime":
        this._upTime = val;
        return 1;
      case "usbCurrent":
        this._usbCurrent = val;
        return 1;
      case "rebootCountdown":
        this._rebootCountdown = val;
        return 1;
      case "userVar":
        this._userVar = val;
        return 1;
    }
    return super.imm_parseAttr(name, val);
  }
  async get_productName() {
    let res;
    let dev;
    if (this._cacheExpiration == 0) {
      dev = this.imm_getDev();
      if (!(dev == null)) {
        return dev.imm_getProductName();
      }
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YModule.PRODUCTNAME_INVALID;
      }
    }
    res = this._productName;
    return res;
  }
  async get_serialNumber() {
    let res;
    let dev;
    if (this._cacheExpiration == 0) {
      dev = this.imm_getDev();
      if (!(dev == null)) {
        return dev.imm_getSerialNumber();
      }
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YModule.SERIALNUMBER_INVALID;
      }
    }
    res = this._serialNumber;
    return res;
  }
  async get_productId() {
    let res;
    let dev;
    if (this._cacheExpiration == 0) {
      dev = this.imm_getDev();
      if (!(dev == null)) {
        return dev.imm_getProductId();
      }
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YModule.PRODUCTID_INVALID;
      }
    }
    res = this._productId;
    return res;
  }
  async get_productRelease() {
    let res;
    if (this._cacheExpiration == 0) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YModule.PRODUCTRELEASE_INVALID;
      }
    }
    res = this._productRelease;
    return res;
  }
  async get_firmwareRelease() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YModule.FIRMWARERELEASE_INVALID;
      }
    }
    res = this._firmwareRelease;
    return res;
  }
  async get_persistentSettings() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YModule.PERSISTENTSETTINGS_INVALID;
      }
    }
    res = this._persistentSettings;
    return res;
  }
  async set_persistentSettings(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("persistentSettings", rest_val);
  }
  async get_luminosity() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YModule.LUMINOSITY_INVALID;
      }
    }
    res = this._luminosity;
    return res;
  }
  async set_luminosity(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("luminosity", rest_val);
  }
  async get_beacon() {
    let res;
    let dev;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      dev = this.imm_getDev();
      if (!(dev == null)) {
        return dev.imm_getBeacon();
      }
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YModule.BEACON_INVALID;
      }
    }
    res = this._beacon;
    return res;
  }
  async set_beacon(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("beacon", rest_val);
  }
  async get_upTime() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YModule.UPTIME_INVALID;
      }
    }
    res = this._upTime;
    return res;
  }
  async get_usbCurrent() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YModule.USBCURRENT_INVALID;
      }
    }
    res = this._usbCurrent;
    return res;
  }
  async get_rebootCountdown() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YModule.REBOOTCOUNTDOWN_INVALID;
      }
    }
    res = this._rebootCountdown;
    return res;
  }
  async set_rebootCountdown(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("rebootCountdown", rest_val);
  }
  async get_userVar() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YModule.USERVAR_INVALID;
      }
    }
    res = this._userVar;
    return res;
  }
  async set_userVar(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("userVar", rest_val);
  }
  static FindModule(func) {
    let obj;
    let cleanHwId;
    let modpos;
    cleanHwId = func;
    modpos = func.indexOf(".module");
    if (modpos != func.length - 7) {
      cleanHwId = func + ".module";
    }
    obj = YFunction._FindFromCache("Module", cleanHwId);
    if (obj == null) {
      obj = new YModule(YAPI, cleanHwId);
      YFunction._AddToCache("Module", cleanHwId, obj);
    }
    return obj;
  }
  static FindModuleInContext(yctx, func) {
    let obj;
    let cleanHwId;
    let modpos;
    cleanHwId = func;
    modpos = func.indexOf(".module");
    if (modpos != func.length - 7) {
      cleanHwId = func + ".module";
    }
    obj = YFunction._FindFromCacheInContext(yctx, "Module", cleanHwId);
    if (obj == null) {
      obj = new YModule(yctx, cleanHwId);
      YFunction._AddToCache("Module", cleanHwId, obj);
    }
    return obj;
  }
  async registerValueCallback(callback) {
    let val;
    if (callback != null) {
      await YFunction._UpdateValueCallbackList(this, true);
    } else {
      await YFunction._UpdateValueCallbackList(this, false);
    }
    this._valueCallbackModule = callback;
    if (callback != null && await this.isOnline()) {
      val = this._advertisedValue;
      if (!(val == "")) {
        await this._invokeValueCallback(val);
      }
    }
    return 0;
  }
  async _invokeValueCallback(value) {
    if (this._valueCallbackModule != null) {
      try {
        await this._valueCallbackModule(this, value);
      } catch (e) {
        this._yapi.imm_log("Exception in valueCallback:", e);
      }
    } else {
      await super._invokeValueCallback(value);
    }
    return 0;
  }
  async get_productNameAndRevision() {
    let prodname;
    let prodrel;
    let fullname;
    prodname = await this.get_productName();
    prodrel = await this.get_productRelease();
    if (prodrel > 1) {
      fullname = prodname + " rev. " + String.fromCharCode(64 + prodrel);
    } else {
      fullname = prodname;
    }
    return fullname;
  }
  async saveToFlash() {
    return await this.set_persistentSettings(1);
  }
  async revertFromFlash() {
    return await this.set_persistentSettings(0);
  }
  async reboot(secBeforeReboot) {
    return await this.set_rebootCountdown(secBeforeReboot);
  }
  async triggerFirmwareUpdate(secBeforeReboot) {
    return await this.set_rebootCountdown(-secBeforeReboot);
  }
  async _startStopDevLog(serial, start) {
    return await this._startStopDevLog_internal(serial, start);
  }
  async registerLogCallback(callback) {
    let serial;
    serial = await this.get_serialNumber();
    if (serial == YAPI_INVALID_STRING) {
      return YAPI_DEVICE_NOT_FOUND;
    }
    this._logCallback = callback;
    await this._startStopDevLog(serial, callback != null);
    return 0;
  }
  async get_logCallback() {
    return this._logCallback;
  }
  async registerConfigChangeCallback(callback) {
    if (callback != null) {
      await YModule._updateModuleCallbackList(this, true);
    } else {
      await YModule._updateModuleCallbackList(this, false);
    }
    this._confChangeCallback = callback;
    return 0;
  }
  async _invokeConfigChangeCallback() {
    if (this._confChangeCallback != null) {
      try {
        await this._confChangeCallback(this);
      } catch (e) {
        this._yapi.imm_log("Exception in configChangeCallback:", e);
      }
    }
    return 0;
  }
  async registerBeaconCallback(callback) {
    if (callback != null) {
      await YModule._updateModuleCallbackList(this, true);
    } else {
      await YModule._updateModuleCallbackList(this, false);
    }
    this._beaconCallback = callback;
    return 0;
  }
  async _invokeBeaconCallback(beaconState) {
    if (this._beaconCallback != null) {
      try {
        await this._beaconCallback(this, beaconState);
      } catch (e) {
        this._yapi.imm_log("Exception in beaconCallback:", e);
      }
    }
    return 0;
  }
  async triggerConfigChangeCallback() {
    await this._setAttr("persistentSettings", "2");
    return 0;
  }
  async checkFirmware(path, onlynew) {
    let serial;
    let release;
    let tmp_res;
    if (onlynew) {
      release = YAPIContext.imm_atoi(await this.get_firmwareRelease());
    } else {
      release = 0;
    }
    serial = await this.get_serialNumber();
    tmp_res = await YFirmwareUpdate.CheckFirmware(serial, path, release);
    if (tmp_res.indexOf("error:") == 0) {
      this._throw(YAPI_INVALID_ARGUMENT, tmp_res);
    }
    return tmp_res;
  }
  async updateFirmwareEx(path, force) {
    let serial;
    let settings;
    serial = await this.get_serialNumber();
    settings = await this.get_allSettings();
    if (settings.length == 0) {
      this._throw(YAPI_IO_ERROR, "Unable to get device settings");
      settings = this._yapi.imm_str2bin("error:Unable to get device settings");
    }
    return new YFirmwareUpdate(this._yapi, serial, path, settings, force);
  }
  async updateFirmware(path) {
    return await this.updateFirmwareEx(path, false);
  }
  async get_allSettings() {
    let settings;
    let json;
    let res;
    let sep;
    let name;
    let item;
    let t_type;
    let id;
    let url;
    let file_data;
    let file_data_bin;
    let temp_data_bin;
    let ext_settings;
    let filelist = [];
    let templist = [];
    settings = await this._download("api.json");
    if (settings.length == 0) {
      return settings;
    }
    ext_settings = ', "extras":[';
    templist = await this.get_functionIds("Temperature");
    sep = "";
    for (let ii in templist) {
      if (YAPIContext.imm_atoi(await this.get_firmwareRelease()) > 9e3) {
        url = "api/" + templist[ii] + "/sensorType";
        t_type = this._yapi.imm_bin2str(await this._download(url));
        if (t_type == "RES_NTC" || t_type == "RES_LINEAR") {
          id = templist[ii].substr(11, templist[ii].length - 11);
          if (id == "") {
            id = "1";
          }
          temp_data_bin = await this._download("extra.json?page=" + id);
          if (temp_data_bin.length > 0) {
            item = sep + '{"fid":"' + templist[ii] + '", "json":' + this._yapi.imm_bin2str(temp_data_bin) + "}\n";
            ext_settings = ext_settings + item;
            sep = ",";
          }
        }
      }
    }
    ext_settings = ext_settings + '],\n"files":[';
    if (await this.hasFunction("files")) {
      json = await this._download("files.json?a=dir&f=");
      if (json.length == 0) {
        return json;
      }
      filelist = this.imm_json_get_array(json);
      sep = "";
      for (let ii in filelist) {
        name = this.imm_json_get_key(this._yapi.imm_str2bin(filelist[ii]), "name");
        if (name.length > 0 && !(name == "startupConf.json")) {
          file_data_bin = await this._download(this.imm_escapeAttr(name));
          file_data = this._yapi.imm_bin2hexstr(file_data_bin);
          item = sep + '{"name":"' + name + '", "data":"' + file_data + '"}\n';
          ext_settings = ext_settings + item;
          sep = ",";
        }
      }
    }
    res = this._yapi.imm_str2bin('{ "api":' + this._yapi.imm_bin2str(settings) + ext_settings + "]}");
    return res;
  }
  async loadThermistorExtra(funcId, jsonExtra) {
    let values = [];
    let url;
    let curr;
    let currTemp;
    let ofs;
    let size;
    url = "api/" + funcId + ".json?command=Z";
    await this._download(url);
    values = this.imm_json_get_array(this._yapi.imm_str2bin(jsonExtra));
    ofs = 0;
    size = values.length;
    while (ofs + 1 < size) {
      curr = values[ofs];
      currTemp = values[ofs + 1];
      url = "api/" + funcId + ".json?command=m" + curr + ":" + currTemp;
      await this._download(url);
      ofs = ofs + 2;
    }
    return YAPI_SUCCESS;
  }
  async set_extraSettings(jsonExtra) {
    let extras = [];
    let functionId;
    let data;
    extras = this.imm_json_get_array(this._yapi.imm_str2bin(jsonExtra));
    for (let ii in extras) {
      functionId = this.imm_get_json_path(extras[ii], "fid");
      functionId = this.imm_decode_json_string(functionId);
      data = this.imm_get_json_path(extras[ii], "json");
      if (await this.hasFunction(functionId)) {
        await this.loadThermistorExtra(functionId, data);
      }
    }
    return YAPI_SUCCESS;
  }
  async set_allSettingsAndFiles(settings) {
    let down;
    let json;
    let json_api;
    let json_files;
    let json_extra;
    let fuperror;
    let globalres;
    fuperror = 0;
    json = this._yapi.imm_bin2str(settings);
    json_api = this.imm_get_json_path(json, "api");
    if (json_api == "") {
      return await this.set_allSettings(settings);
    }
    json_extra = this.imm_get_json_path(json, "extras");
    if (!(json_extra == "")) {
      await this.set_extraSettings(json_extra);
    }
    await this.set_allSettings(this._yapi.imm_str2bin(json_api));
    if (await this.hasFunction("files")) {
      let files = [];
      let res;
      let name;
      let data;
      down = await this._download("files.json?a=format");
      res = this.imm_get_json_path(this._yapi.imm_bin2str(down), "res");
      res = this.imm_decode_json_string(res);
      if (!(res == "ok")) {
        return this._throw(YAPI_IO_ERROR, "format failed", YAPI_IO_ERROR);
      }
      json_files = this.imm_get_json_path(json, "files");
      files = this.imm_json_get_array(this._yapi.imm_str2bin(json_files));
      for (let ii in files) {
        name = this.imm_get_json_path(files[ii], "name");
        name = this.imm_decode_json_string(name);
        data = this.imm_get_json_path(files[ii], "data");
        data = this.imm_decode_json_string(data);
        if (name == "") {
          fuperror = fuperror + 1;
        } else {
          await this._upload(name, this._yapi.imm_hexstr2bin(data));
        }
      }
    }
    globalres = await this.set_allSettings(this._yapi.imm_str2bin(json_api));
    if (!(fuperror == 0)) {
      return this._throw(YAPI_IO_ERROR, "Error during file upload", YAPI_IO_ERROR);
    }
    return globalres;
  }
  async hasFunction(funcId) {
    let count;
    let i;
    let fid;
    count = await this.functionCount();
    i = 0;
    while (i < count) {
      fid = await this.functionId(i);
      if (fid == funcId) {
        return true;
      }
      i = i + 1;
    }
    return false;
  }
  async get_functionIds(funType) {
    let count;
    let i;
    let ftype;
    let res = [];
    count = await this.functionCount();
    i = 0;
    while (i < count) {
      ftype = await this.functionType(i);
      if (ftype == funType) {
        res.push(await this.functionId(i));
      } else {
        ftype = await this.functionBaseType(i);
        if (ftype == funType) {
          res.push(await this.functionId(i));
        }
      }
      i = i + 1;
    }
    return res;
  }
  imm_flattenJsonStruct(jsoncomplex) {
    return this.imm_flattenJsonStruct_internal(jsoncomplex);
  }
  async calibVersion(cparams) {
    if (cparams == "0,") {
      return 3;
    }
    if (cparams.indexOf(",") >= 0) {
      if (cparams.indexOf(" ") > 0) {
        return 3;
      } else {
        return 1;
      }
    }
    if (cparams == "" || cparams == "0") {
      return 1;
    }
    if (cparams.length < 2 || cparams.indexOf(".") >= 0) {
      return 0;
    } else {
      return 2;
    }
  }
  async calibScale(unit_name, sensorType) {
    if (unit_name == "g" || unit_name == "gauss" || unit_name == "W") {
      return 1e3;
    }
    if (unit_name == "C") {
      if (sensorType == "") {
        return 16;
      }
      if (YAPIContext.imm_atoi(sensorType) < 8) {
        return 16;
      } else {
        return 100;
      }
    }
    if (unit_name == "m" || unit_name == "deg") {
      return 10;
    }
    return 1;
  }
  async calibOffset(unit_name) {
    if (unit_name == "% RH" || unit_name == "mbar" || unit_name == "lx") {
      return 0;
    }
    return 32767;
  }
  async calibConvert(param, currentFuncValue, unit_name, sensorType) {
    let paramVer;
    let funVer;
    let funScale;
    let funOffset;
    let paramScale;
    let paramOffset;
    let words = [];
    let words_str = [];
    let calibData = [];
    let iCalib = [];
    let calibType;
    let i;
    let maxSize;
    let ratio;
    let nPoints;
    let wordVal;
    paramVer = await this.calibVersion(param);
    funVer = await this.calibVersion(currentFuncValue);
    funScale = await this.calibScale(unit_name, sensorType);
    funOffset = await this.calibOffset(unit_name);
    paramScale = funScale;
    paramOffset = funOffset;
    if (funVer < 3) {
      if (funVer == 2) {
        words = this._yapi.imm_decodeWords(currentFuncValue);
        if (words[0] == 1366 && words[1] == 12500) {
          funScale = 1;
          funOffset = 0;
        } else {
          funScale = words[1];
          funOffset = words[0];
        }
      } else {
        if (funVer == 1) {
          if (currentFuncValue == "" || YAPIContext.imm_atoi(currentFuncValue) > 10) {
            funScale = 0;
          }
        }
      }
    }
    calibData.length = 0;
    calibType = 0;
    if (paramVer < 3) {
      if (paramVer == 2) {
        words = this._yapi.imm_decodeWords(param);
        if (words[0] == 1366 && words[1] == 12500) {
          paramScale = 1;
          paramOffset = 0;
        } else {
          paramScale = words[1];
          paramOffset = words[0];
        }
        if (words.length >= 3 && words[2] > 0) {
          maxSize = 3 + 2 * (words[2] % 10);
          if (maxSize > words.length) {
            maxSize = words.length;
          }
          i = 3;
          while (i < maxSize) {
            calibData.push(words[i]);
            i = i + 1;
          }
        }
      } else {
        if (paramVer == 1) {
          words_str = param.split(",");
          for (let ii in words_str) {
            words.push(YAPIContext.imm_atoi(words_str[ii]));
          }
          if (param == "" || words[0] > 10) {
            paramScale = 0;
          }
          if (words.length > 0 && words[0] > 0) {
            maxSize = 1 + 2 * (words[0] % 10);
            if (maxSize > words.length) {
              maxSize = words.length;
            }
            i = 1;
            while (i < maxSize) {
              calibData.push(words[i]);
              i = i + 1;
            }
          }
        } else {
          if (paramVer == 0) {
            ratio = parseFloat(param);
            if (ratio > 0) {
              calibData.push(0);
              calibData.push(0);
              calibData.push(Math.round(65535 / ratio));
              calibData.push(65535);
            }
          }
        }
      }
      i = 0;
      while (i < calibData.length) {
        if (paramScale > 0) {
          calibData[i] = (calibData[i] - paramOffset) / paramScale;
        } else {
          calibData[i] = this._yapi.imm_decimalToDouble(Math.round(calibData[i]));
        }
        i = i + 1;
      }
    } else {
      iCalib = this._yapi.imm_decodeFloats(param);
      calibType = Math.round(iCalib[0] / 1e3);
      if (calibType >= 30) {
        calibType = calibType - 30;
      }
      i = 1;
      while (i < iCalib.length) {
        calibData.push(iCalib[i] / 1e3);
        i = i + 1;
      }
    }
    if (funVer >= 3) {
      if (calibData.length == 0) {
        param = "0,";
      } else {
        param = (30 + calibType).toString();
        i = 0;
        while (i < calibData.length) {
          if ((i & 1) > 0) {
            param = param + ":";
          } else {
            param = param + " ";
          }
          param = param + Math.round(calibData[i] * 1e3 / 1e3).toString();
          i = i + 1;
        }
        param = param + ",";
      }
    } else {
      if (funVer >= 1) {
        nPoints = calibData.length / 2 >> 0;
        param = nPoints.toString();
        i = 0;
        while (i < 2 * nPoints) {
          if (funScale == 0) {
            wordVal = this._yapi.imm_doubleToDecimal(Math.round(calibData[i]));
          } else {
            wordVal = calibData[i] * funScale + funOffset;
          }
          param = param + "," + Math.round(wordVal).toString();
          i = i + 1;
        }
      } else {
        if (calibData.length == 4) {
          param = Math.round(1e3 * (calibData[3] - calibData[1]) / calibData[2] - calibData[0]).toString();
        }
      }
    }
    return param;
  }
  async _tryExec(url) {
    let res;
    let done;
    res = YAPI_SUCCESS;
    done = 1;
    try {
      await this._download(url);
    } catch (e) {
      done = 0;
    }
    if (done == 0) {
      try {
        await YAPI.Sleep(500);
        await this._download(url);
      } catch (e) {
        res = await this.get_errorType();
      }
    }
    return res;
  }
  async set_allSettings(settings) {
    let restoreLast = [];
    let old_json_flat;
    let old_dslist = [];
    let old_jpath = [];
    let old_jpath_len = [];
    let old_val_arr = [];
    let actualSettings;
    let new_dslist = [];
    let new_jpath = [];
    let new_jpath_len = [];
    let new_val_arr = [];
    let cpos;
    let eqpos;
    let leng;
    let i;
    let j;
    let subres;
    let res;
    let njpath;
    let jpath;
    let fun;
    let attr;
    let value;
    let url;
    let tmp;
    let new_calib;
    let sensorType;
    let unit_name;
    let newval;
    let oldval;
    let old_calib;
    let each_str;
    let do_update;
    let found;
    res = YAPI_SUCCESS;
    tmp = this._yapi.imm_bin2str(settings);
    tmp = this.imm_get_json_path(tmp, "api");
    if (!(tmp == "")) {
      settings = this._yapi.imm_str2bin(tmp);
    }
    oldval = "";
    newval = "";
    old_json_flat = this.imm_flattenJsonStruct(settings);
    old_dslist = this.imm_json_get_array(old_json_flat);
    for (let ii in old_dslist) {
      each_str = this.imm_json_get_string(this._yapi.imm_str2bin(old_dslist[ii]));
      leng = each_str.length;
      eqpos = each_str.indexOf("=");
      if (eqpos < 0 || leng == 0) {
        this._throw(YAPI_INVALID_ARGUMENT, "Invalid settings");
        return YAPI_INVALID_ARGUMENT;
      }
      jpath = each_str.substr(0, eqpos);
      eqpos = eqpos + 1;
      value = each_str.substr(eqpos, leng - eqpos);
      old_jpath.push(jpath);
      old_jpath_len.push(jpath.length);
      old_val_arr.push(value);
    }
    try {
      actualSettings = await this._download("api.json");
    } catch (e) {
      await YAPI.Sleep(500);
      actualSettings = await this._download("api.json");
    }
    actualSettings = this.imm_flattenJsonStruct(actualSettings);
    new_dslist = this.imm_json_get_array(actualSettings);
    for (let ii in new_dslist) {
      each_str = this.imm_json_get_string(this._yapi.imm_str2bin(new_dslist[ii]));
      leng = each_str.length;
      eqpos = each_str.indexOf("=");
      if (eqpos < 0 || leng == 0) {
        this._throw(YAPI_INVALID_ARGUMENT, "Invalid settings");
        return YAPI_INVALID_ARGUMENT;
      }
      jpath = each_str.substr(0, eqpos);
      eqpos = eqpos + 1;
      value = each_str.substr(eqpos, leng - eqpos);
      new_jpath.push(jpath);
      new_jpath_len.push(jpath.length);
      new_val_arr.push(value);
    }
    i = 0;
    while (i < new_jpath.length) {
      njpath = new_jpath[i];
      leng = njpath.length;
      cpos = njpath.indexOf("/");
      if (cpos < 0 || leng == 0) {
        continue;
      }
      fun = njpath.substr(0, cpos);
      cpos = cpos + 1;
      attr = njpath.substr(cpos, leng - cpos);
      do_update = true;
      if (fun == "services") {
        do_update = false;
      }
      if (do_update && attr == "firmwareRelease") {
        do_update = false;
      }
      if (do_update && attr == "usbCurrent") {
        do_update = false;
      }
      if (do_update && attr == "upTime") {
        do_update = false;
      }
      if (do_update && attr == "persistentSettings") {
        do_update = false;
      }
      if (do_update && attr == "adminPassword") {
        do_update = false;
      }
      if (do_update && attr == "userPassword") {
        do_update = false;
      }
      if (do_update && attr == "rebootCountdown") {
        do_update = false;
      }
      if (do_update && attr == "advertisedValue") {
        do_update = false;
      }
      if (do_update && attr == "poeCurrent") {
        do_update = false;
      }
      if (do_update && attr == "readiness") {
        do_update = false;
      }
      if (do_update && attr == "ipAddress") {
        do_update = false;
      }
      if (do_update && attr == "subnetMask") {
        do_update = false;
      }
      if (do_update && attr == "router") {
        do_update = false;
      }
      if (do_update && attr == "linkQuality") {
        do_update = false;
      }
      if (do_update && attr == "ssid") {
        do_update = false;
      }
      if (do_update && attr == "channel") {
        do_update = false;
      }
      if (do_update && attr == "security") {
        do_update = false;
      }
      if (do_update && attr == "message") {
        do_update = false;
      }
      if (do_update && attr == "signalValue") {
        do_update = false;
      }
      if (do_update && attr == "currentValue") {
        do_update = false;
      }
      if (do_update && attr == "currentRawValue") {
        do_update = false;
      }
      if (do_update && attr == "currentRunIndex") {
        do_update = false;
      }
      if (do_update && attr == "pulseTimer") {
        do_update = false;
      }
      if (do_update && attr == "lastTimePressed") {
        do_update = false;
      }
      if (do_update && attr == "lastTimeReleased") {
        do_update = false;
      }
      if (do_update && attr == "filesCount") {
        do_update = false;
      }
      if (do_update && attr == "freeSpace") {
        do_update = false;
      }
      if (do_update && attr == "timeUTC") {
        do_update = false;
      }
      if (do_update && attr == "rtcTime") {
        do_update = false;
      }
      if (do_update && attr == "unixTime") {
        do_update = false;
      }
      if (do_update && attr == "dateTime") {
        do_update = false;
      }
      if (do_update && attr == "rawValue") {
        do_update = false;
      }
      if (do_update && attr == "lastMsg") {
        do_update = false;
      }
      if (do_update && attr == "delayedPulseTimer") {
        do_update = false;
      }
      if (do_update && attr == "rxCount") {
        do_update = false;
      }
      if (do_update && attr == "txCount") {
        do_update = false;
      }
      if (do_update && attr == "msgCount") {
        do_update = false;
      }
      if (do_update && attr == "rxMsgCount") {
        do_update = false;
      }
      if (do_update && attr == "txMsgCount") {
        do_update = false;
      }
      if (do_update) {
        do_update = false;
        newval = new_val_arr[i];
        j = 0;
        found = false;
        while (j < old_jpath.length && !found) {
          if (new_jpath_len[i] == old_jpath_len[j] && new_jpath[i] == old_jpath[j]) {
            found = true;
            oldval = old_val_arr[j];
            if (!(newval == oldval)) {
              do_update = true;
            }
          }
          j = j + 1;
        }
      }
      if (do_update) {
        if (attr == "calibrationParam") {
          old_calib = "";
          unit_name = "";
          sensorType = "";
          new_calib = newval;
          j = 0;
          found = false;
          while (j < old_jpath.length && !found) {
            if (new_jpath_len[i] == old_jpath_len[j] && new_jpath[i] == old_jpath[j]) {
              found = true;
              old_calib = old_val_arr[j];
            }
            j = j + 1;
          }
          tmp = fun + "/unit";
          j = 0;
          found = false;
          while (j < new_jpath.length && !found) {
            if (tmp == new_jpath[j]) {
              found = true;
              unit_name = new_val_arr[j];
            }
            j = j + 1;
          }
          tmp = fun + "/sensorType";
          j = 0;
          found = false;
          while (j < new_jpath.length && !found) {
            if (tmp == new_jpath[j]) {
              found = true;
              sensorType = new_val_arr[j];
            }
            j = j + 1;
          }
          newval = await this.calibConvert(old_calib, new_val_arr[i], unit_name, sensorType);
          url = "api/" + fun + ".json?" + attr + "=" + this.imm_escapeAttr(newval);
          subres = await this._tryExec(url);
          if (res == YAPI_SUCCESS && subres != YAPI_SUCCESS) {
            res = subres;
          }
        } else {
          url = "api/" + fun + ".json?" + attr + "=" + this.imm_escapeAttr(oldval);
          if (attr == "resolution") {
            restoreLast.push(url);
          } else {
            subres = await this._tryExec(url);
            if (res == YAPI_SUCCESS && subres != YAPI_SUCCESS) {
              res = subres;
            }
          }
        }
      }
      i = i + 1;
    }
    for (let ii in restoreLast) {
      subres = await this._tryExec(restoreLast[ii]);
      if (res == YAPI_SUCCESS && subres != YAPI_SUCCESS) {
        res = subres;
      }
    }
    await this.clearCache();
    return res;
  }
  async addFileToHTTPCallback(filename) {
    let content;
    content = await this._download("@YCB+" + filename);
    if (content.length == 0) {
      return YAPI_NOT_SUPPORTED;
    }
    return YAPI_SUCCESS;
  }
  async get_hardwareId() {
    let serial;
    serial = await this.get_serialNumber();
    return serial + ".module";
  }
  async download(pathname) {
    return await this._download(pathname);
  }
  async get_icon2d() {
    return await this._download("icon2d.png");
  }
  async get_lastLogs() {
    let content;
    content = await this._download("logs.txt");
    return this._yapi.imm_bin2str(content);
  }
  async log(text) {
    return await this._upload("logs.txt", this._yapi.imm_str2bin(text));
  }
  async get_subDevices() {
    return await this.get_subDevices_internal();
  }
  async get_parentHub() {
    return await this.get_parentHub_internal();
  }
  async get_url() {
    return await this.get_url_internal();
  }
  nextModule() {
    let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
    if (resolve.errorType != YAPI.SUCCESS)
      return null;
    let next_hwid = this._yapi.imm_getNextHardwareId(this._className, resolve.result);
    if (next_hwid == null)
      return null;
    return YModule.FindModuleInContext(this._yapi, next_hwid);
  }
  static FirstModule() {
    let next_hwid = YAPI.imm_getFirstHardwareId("Module");
    if (next_hwid == null)
      return null;
    return YModule.FindModule(next_hwid);
  }
  static FirstModuleInContext(yctx) {
    let next_hwid = yctx.imm_getFirstHardwareId("Module");
    if (next_hwid == null)
      return null;
    return YModule.FindModuleInContext(yctx, next_hwid);
  }
};
YModule.PRODUCTNAME_INVALID = YAPI_INVALID_STRING;
YModule.SERIALNUMBER_INVALID = YAPI_INVALID_STRING;
YModule.PRODUCTID_INVALID = YAPI_INVALID_UINT;
YModule.PRODUCTRELEASE_INVALID = YAPI_INVALID_UINT;
YModule.FIRMWARERELEASE_INVALID = YAPI_INVALID_STRING;
YModule.PERSISTENTSETTINGS_LOADED = 0;
YModule.PERSISTENTSETTINGS_SAVED = 1;
YModule.PERSISTENTSETTINGS_MODIFIED = 2;
YModule.PERSISTENTSETTINGS_INVALID = -1;
YModule.LUMINOSITY_INVALID = YAPI_INVALID_UINT;
YModule.BEACON_OFF = 0;
YModule.BEACON_ON = 1;
YModule.BEACON_INVALID = -1;
YModule.UPTIME_INVALID = YAPI_INVALID_LONG;
YModule.USBCURRENT_INVALID = YAPI_INVALID_UINT;
YModule.REBOOTCOUNTDOWN_INVALID = YAPI_INVALID_INT;
YModule.USERVAR_INVALID = YAPI_INVALID_INT;
var YSensor = class extends YFunction {
  constructor(yapi, func) {
    super(yapi, func);
    this._unit = YSensor.UNIT_INVALID;
    this._currentValue = YSensor.CURRENTVALUE_INVALID;
    this._lowestValue = YSensor.LOWESTVALUE_INVALID;
    this._highestValue = YSensor.HIGHESTVALUE_INVALID;
    this._currentRawValue = YSensor.CURRENTRAWVALUE_INVALID;
    this._logFrequency = YSensor.LOGFREQUENCY_INVALID;
    this._reportFrequency = YSensor.REPORTFREQUENCY_INVALID;
    this._advMode = YSensor.ADVMODE_INVALID;
    this._calibrationParam = YSensor.CALIBRATIONPARAM_INVALID;
    this._resolution = YSensor.RESOLUTION_INVALID;
    this._sensorState = YSensor.SENSORSTATE_INVALID;
    this._valueCallbackSensor = null;
    this._timedReportCallbackSensor = null;
    this._prevTimedReport = 0;
    this._iresol = 0;
    this._offset = 0;
    this._scale = 0;
    this._decexp = 0;
    this._caltyp = 0;
    this._calpar = [];
    this._calraw = [];
    this._calref = [];
    this.imm_calhdl = null;
    this.UNIT_INVALID = YAPI_INVALID_STRING;
    this.CURRENTVALUE_INVALID = YAPI_INVALID_DOUBLE;
    this.LOWESTVALUE_INVALID = YAPI_INVALID_DOUBLE;
    this.HIGHESTVALUE_INVALID = YAPI_INVALID_DOUBLE;
    this.CURRENTRAWVALUE_INVALID = YAPI_INVALID_DOUBLE;
    this.LOGFREQUENCY_INVALID = YAPI_INVALID_STRING;
    this.REPORTFREQUENCY_INVALID = YAPI_INVALID_STRING;
    this.ADVMODE_IMMEDIATE = 0;
    this.ADVMODE_PERIOD_AVG = 1;
    this.ADVMODE_PERIOD_MIN = 2;
    this.ADVMODE_PERIOD_MAX = 3;
    this.ADVMODE_INVALID = -1;
    this.CALIBRATIONPARAM_INVALID = YAPI_INVALID_STRING;
    this.RESOLUTION_INVALID = YAPI_INVALID_DOUBLE;
    this.SENSORSTATE_INVALID = YAPI_INVALID_INT;
    this._className = "Sensor";
  }
  imm_parseAttr(name, val) {
    switch (name) {
      case "unit":
        this._unit = val;
        return 1;
      case "currentValue":
        this._currentValue = Math.round(val / 65.536) / 1e3;
        return 1;
      case "lowestValue":
        this._lowestValue = Math.round(val / 65.536) / 1e3;
        return 1;
      case "highestValue":
        this._highestValue = Math.round(val / 65.536) / 1e3;
        return 1;
      case "currentRawValue":
        this._currentRawValue = Math.round(val / 65.536) / 1e3;
        return 1;
      case "logFrequency":
        this._logFrequency = val;
        return 1;
      case "reportFrequency":
        this._reportFrequency = val;
        return 1;
      case "advMode":
        this._advMode = val;
        return 1;
      case "calibrationParam":
        this._calibrationParam = val;
        return 1;
      case "resolution":
        this._resolution = Math.round(val / 65.536) / 1e3;
        return 1;
      case "sensorState":
        this._sensorState = val;
        return 1;
    }
    return super.imm_parseAttr(name, val);
  }
  async get_unit() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YSensor.UNIT_INVALID;
      }
    }
    res = this._unit;
    return res;
  }
  async get_currentValue() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YSensor.CURRENTVALUE_INVALID;
      }
    }
    res = await this._applyCalibration(this._currentRawValue);
    if (res == YSensor.CURRENTVALUE_INVALID) {
      res = this._currentValue;
    }
    res = res * this._iresol;
    res = Math.round(res) / this._iresol;
    return res;
  }
  async set_lowestValue(newval) {
    let rest_val;
    rest_val = String(Math.round(newval * 65536));
    return await this._setAttr("lowestValue", rest_val);
  }
  async get_lowestValue() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YSensor.LOWESTVALUE_INVALID;
      }
    }
    res = this._lowestValue * this._iresol;
    res = Math.round(res) / this._iresol;
    return res;
  }
  async set_highestValue(newval) {
    let rest_val;
    rest_val = String(Math.round(newval * 65536));
    return await this._setAttr("highestValue", rest_val);
  }
  async get_highestValue() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YSensor.HIGHESTVALUE_INVALID;
      }
    }
    res = this._highestValue * this._iresol;
    res = Math.round(res) / this._iresol;
    return res;
  }
  async get_currentRawValue() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YSensor.CURRENTRAWVALUE_INVALID;
      }
    }
    res = this._currentRawValue;
    return res;
  }
  async get_logFrequency() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YSensor.LOGFREQUENCY_INVALID;
      }
    }
    res = this._logFrequency;
    return res;
  }
  async set_logFrequency(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("logFrequency", rest_val);
  }
  async get_reportFrequency() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YSensor.REPORTFREQUENCY_INVALID;
      }
    }
    res = this._reportFrequency;
    return res;
  }
  async set_reportFrequency(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("reportFrequency", rest_val);
  }
  async get_advMode() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YSensor.ADVMODE_INVALID;
      }
    }
    res = this._advMode;
    return res;
  }
  async set_advMode(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("advMode", rest_val);
  }
  async get_calibrationParam() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YSensor.CALIBRATIONPARAM_INVALID;
      }
    }
    res = this._calibrationParam;
    return res;
  }
  async set_calibrationParam(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("calibrationParam", rest_val);
  }
  async set_resolution(newval) {
    let rest_val;
    rest_val = String(Math.round(newval * 65536));
    return await this._setAttr("resolution", rest_val);
  }
  async get_resolution() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YSensor.RESOLUTION_INVALID;
      }
    }
    res = this._resolution;
    return res;
  }
  async get_sensorState() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YSensor.SENSORSTATE_INVALID;
      }
    }
    res = this._sensorState;
    return res;
  }
  static FindSensor(func) {
    let obj;
    obj = YFunction._FindFromCache("Sensor", func);
    if (obj == null) {
      obj = new YSensor(YAPI, func);
      YFunction._AddToCache("Sensor", func, obj);
    }
    return obj;
  }
  static FindSensorInContext(yctx, func) {
    let obj;
    obj = YFunction._FindFromCacheInContext(yctx, "Sensor", func);
    if (obj == null) {
      obj = new YSensor(yctx, func);
      YFunction._AddToCache("Sensor", func, obj);
    }
    return obj;
  }
  async registerValueCallback(callback) {
    let val;
    if (callback != null) {
      await YFunction._UpdateValueCallbackList(this, true);
    } else {
      await YFunction._UpdateValueCallbackList(this, false);
    }
    this._valueCallbackSensor = callback;
    if (callback != null && await this.isOnline()) {
      val = this._advertisedValue;
      if (!(val == "")) {
        await this._invokeValueCallback(val);
      }
    }
    return 0;
  }
  async _invokeValueCallback(value) {
    if (this._valueCallbackSensor != null) {
      try {
        await this._valueCallbackSensor(this, value);
      } catch (e) {
        this._yapi.imm_log("Exception in valueCallback:", e);
      }
    } else {
      await super._invokeValueCallback(value);
    }
    return 0;
  }
  async _parserHelper() {
    let position;
    let maxpos;
    let iCalib = [];
    let iRaw;
    let iRef;
    let fRaw;
    let fRef;
    this._caltyp = -1;
    this._scale = -1;
    this._calpar.length = 0;
    this._calraw.length = 0;
    this._calref.length = 0;
    if (this._resolution > 0) {
      this._iresol = Math.round(1 / this._resolution);
    } else {
      this._iresol = 1e4;
      this._resolution = 1e-4;
    }
    if (this._calibrationParam == "" || this._calibrationParam == "0") {
      this._caltyp = 0;
      return 0;
    }
    if (this._calibrationParam.indexOf(",") >= 0) {
      iCalib = this._yapi.imm_decodeFloats(this._calibrationParam);
      this._caltyp = iCalib[0] / 1e3 >> 0;
      if (this._caltyp > 0) {
        if (this._caltyp < YOCTO_CALIB_TYPE_OFS) {
          this._caltyp = -1;
          return 0;
        }
        this.imm_calhdl = this._yapi.imm_getCalibrationHandler(this._caltyp);
        if (!(this.imm_calhdl != null)) {
          this._caltyp = -1;
          return 0;
        }
      }
      this._offset = 0;
      this._scale = 1e3;
      maxpos = iCalib.length;
      this._calpar.length = 0;
      position = 1;
      while (position < maxpos) {
        this._calpar.push(iCalib[position]);
        position = position + 1;
      }
      this._calraw.length = 0;
      this._calref.length = 0;
      position = 1;
      while (position + 1 < maxpos) {
        fRaw = iCalib[position];
        fRaw = fRaw / 1e3;
        fRef = iCalib[position + 1];
        fRef = fRef / 1e3;
        this._calraw.push(fRaw);
        this._calref.push(fRef);
        position = position + 2;
      }
    } else {
      iCalib = this._yapi.imm_decodeWords(this._calibrationParam);
      if (iCalib.length < 2) {
        this._caltyp = -1;
        return 0;
      }
      this._offset = 0;
      this._scale = 1;
      this._decexp = 1;
      position = iCalib[0];
      while (position > 0) {
        this._decexp = this._decexp * 10;
        position = position - 1;
      }
      if (iCalib.length == 2) {
        this._caltyp = 0;
        return 0;
      }
      this._caltyp = iCalib[2];
      this.imm_calhdl = this._yapi.imm_getCalibrationHandler(this._caltyp);
      if (this._caltyp <= 10) {
        maxpos = this._caltyp;
      } else {
        if (this._caltyp <= 20) {
          maxpos = this._caltyp - 10;
        } else {
          maxpos = 5;
        }
      }
      maxpos = 3 + 2 * maxpos;
      if (maxpos > iCalib.length) {
        maxpos = iCalib.length;
      }
      this._calpar.length = 0;
      this._calraw.length = 0;
      this._calref.length = 0;
      position = 3;
      while (position + 1 < maxpos) {
        iRaw = iCalib[position];
        iRef = iCalib[position + 1];
        this._calpar.push(iRaw);
        this._calpar.push(iRef);
        this._calraw.push(this._yapi.imm_decimalToDouble(iRaw));
        this._calref.push(this._yapi.imm_decimalToDouble(iRef));
        position = position + 2;
      }
    }
    return 0;
  }
  async isSensorReady() {
    if (!await this.isOnline()) {
      return false;
    }
    if (!(this._sensorState == 0)) {
      return false;
    }
    return true;
  }
  async get_dataLogger() {
    let logger;
    let modu;
    let serial;
    let hwid;
    modu = await this.get_module();
    serial = await modu.get_serialNumber();
    if (serial == YAPI_INVALID_STRING) {
      return null;
    }
    hwid = serial + ".dataLogger";
    logger = YDataLogger.FindDataLogger(hwid);
    return logger;
  }
  async startDataLogger() {
    let res;
    res = await this._download("api/dataLogger/recording?recording=1");
    if (!(res.length > 0)) {
      return this._throw(YAPI_IO_ERROR, "unable to start datalogger", YAPI_IO_ERROR);
    }
    return YAPI_SUCCESS;
  }
  async stopDataLogger() {
    let res;
    res = await this._download("api/dataLogger/recording?recording=0");
    if (!(res.length > 0)) {
      return this._throw(YAPI_IO_ERROR, "unable to stop datalogger", YAPI_IO_ERROR);
    }
    return YAPI_SUCCESS;
  }
  async get_recordedData(startTime, endTime) {
    let funcid;
    let funit;
    funcid = await this.get_functionId();
    funit = await this.get_unit();
    return new YDataSet(this, funcid, funit, startTime, endTime);
  }
  async registerTimedReportCallback(callback) {
    let sensor;
    sensor = this;
    if (callback != null) {
      await YFunction._UpdateTimedReportCallbackList(sensor, true);
    } else {
      await YFunction._UpdateTimedReportCallbackList(sensor, false);
    }
    this._timedReportCallbackSensor = callback;
    return 0;
  }
  async _invokeTimedReportCallback(value) {
    if (this._timedReportCallbackSensor != null) {
      try {
        await this._timedReportCallbackSensor(this, value);
      } catch (e) {
        this._yapi.imm_log("Exception in timedReportCallback:", e);
      }
    } else {
    }
    return 0;
  }
  async calibrateFromPoints(rawValues, refValues) {
    let rest_val;
    let res;
    rest_val = await this._encodeCalibrationPoints(rawValues, refValues);
    res = await this._setAttr("calibrationParam", rest_val);
    return res;
  }
  async loadCalibrationPoints(rawValues, refValues) {
    rawValues.length = 0;
    refValues.length = 0;
    if (this._scale == 0) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YAPI_DEVICE_NOT_FOUND;
      }
    }
    if (this._caltyp < 0) {
      this._throw(YAPI_NOT_SUPPORTED, "Calibration parameters format mismatch. Please upgrade your library or firmware.");
      return YAPI_NOT_SUPPORTED;
    }
    rawValues.length = 0;
    refValues.length = 0;
    for (let ii in this._calraw) {
      rawValues.push(this._calraw[ii]);
    }
    for (let ii in this._calref) {
      refValues.push(this._calref[ii]);
    }
    return YAPI_SUCCESS;
  }
  async _encodeCalibrationPoints(rawValues, refValues) {
    let res;
    let npt;
    let idx;
    npt = rawValues.length;
    if (npt != refValues.length) {
      this._throw(YAPI_INVALID_ARGUMENT, "Invalid calibration parameters (size mismatch)");
      return YAPI_INVALID_STRING;
    }
    if (npt == 0) {
      return "0";
    }
    if (this._scale == 0) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YAPI_INVALID_STRING;
      }
    }
    if (this._caltyp < 0 || this._scale < 0) {
      this._throw(YAPI_NOT_SUPPORTED, "Calibration parameters format mismatch. Please upgrade your library or firmware.");
      return "0";
    }
    res = String(Math.round(YOCTO_CALIB_TYPE_OFS));
    idx = 0;
    while (idx < npt) {
      res = res + "," + String(Math.round(rawValues[idx] * 1e3) / 1e3) + "," + String(Math.round(refValues[idx] * 1e3) / 1e3);
      idx = idx + 1;
    }
    return res;
  }
  async _applyCalibration(rawValue) {
    if (rawValue == YSensor.CURRENTVALUE_INVALID) {
      return YSensor.CURRENTVALUE_INVALID;
    }
    if (this._caltyp == 0) {
      return rawValue;
    }
    if (this._caltyp < 0) {
      return YSensor.CURRENTVALUE_INVALID;
    }
    if (!(this.imm_calhdl != null)) {
      return YSensor.CURRENTVALUE_INVALID;
    }
    return this.imm_calhdl(rawValue, this._caltyp, this._calpar, this._calraw, this._calref);
  }
  async _decodeTimedReport(timestamp, duration, report) {
    let i;
    let byteVal;
    let poww;
    let minRaw;
    let avgRaw;
    let maxRaw;
    let sublen;
    let difRaw;
    let startTime;
    let endTime;
    let minVal;
    let avgVal;
    let maxVal;
    if (duration > 0) {
      startTime = timestamp - duration;
    } else {
      startTime = this._prevTimedReport;
    }
    endTime = timestamp;
    this._prevTimedReport = endTime;
    if (startTime == 0) {
      startTime = endTime;
    }
    if (report.length <= 5) {
      poww = 1;
      avgRaw = 0;
      byteVal = 0;
      i = 1;
      while (i < report.length) {
        byteVal = report[i];
        avgRaw = avgRaw + poww * byteVal;
        poww = poww * 256;
        i = i + 1;
      }
      if ((byteVal & 128) != 0) {
        avgRaw = avgRaw - poww;
      }
      avgVal = avgRaw / 1e3;
      if (this._caltyp != 0) {
        if (this.imm_calhdl != null) {
          avgVal = this.imm_calhdl(avgVal, this._caltyp, this._calpar, this._calraw, this._calref);
        }
      }
      minVal = avgVal;
      maxVal = avgVal;
    } else {
      sublen = 1 + (report[1] & 3);
      poww = 1;
      avgRaw = 0;
      byteVal = 0;
      i = 2;
      while (sublen > 0 && i < report.length) {
        byteVal = report[i];
        avgRaw = avgRaw + poww * byteVal;
        poww = poww * 256;
        i = i + 1;
        sublen = sublen - 1;
      }
      if ((byteVal & 128) != 0) {
        avgRaw = avgRaw - poww;
      }
      sublen = 1 + (report[1] >> 2 & 3);
      poww = 1;
      difRaw = 0;
      while (sublen > 0 && i < report.length) {
        byteVal = report[i];
        difRaw = difRaw + poww * byteVal;
        poww = poww * 256;
        i = i + 1;
        sublen = sublen - 1;
      }
      minRaw = avgRaw - difRaw;
      sublen = 1 + (report[1] >> 4 & 3);
      poww = 1;
      difRaw = 0;
      while (sublen > 0 && i < report.length) {
        byteVal = report[i];
        difRaw = difRaw + poww * byteVal;
        poww = poww * 256;
        i = i + 1;
        sublen = sublen - 1;
      }
      maxRaw = avgRaw + difRaw;
      avgVal = avgRaw / 1e3;
      minVal = minRaw / 1e3;
      maxVal = maxRaw / 1e3;
      if (this._caltyp != 0) {
        if (this.imm_calhdl != null) {
          avgVal = this.imm_calhdl(avgVal, this._caltyp, this._calpar, this._calraw, this._calref);
          minVal = this.imm_calhdl(minVal, this._caltyp, this._calpar, this._calraw, this._calref);
          maxVal = this.imm_calhdl(maxVal, this._caltyp, this._calpar, this._calraw, this._calref);
        }
      }
    }
    return new YMeasure(startTime, endTime, minVal, avgVal, maxVal);
  }
  imm_decodeVal(w) {
    let val;
    val = w;
    if (this._caltyp != 0) {
      if (this.imm_calhdl != null) {
        val = this.imm_calhdl(val, this._caltyp, this._calpar, this._calraw, this._calref);
      }
    }
    return val;
  }
  imm_decodeAvg(dw) {
    let val;
    val = dw;
    if (this._caltyp != 0) {
      if (this.imm_calhdl != null) {
        val = this.imm_calhdl(val, this._caltyp, this._calpar, this._calraw, this._calref);
      }
    }
    return val;
  }
  nextSensor() {
    let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
    if (resolve.errorType != YAPI.SUCCESS)
      return null;
    let next_hwid = this._yapi.imm_getNextHardwareId(this._className, resolve.result);
    if (next_hwid == null)
      return null;
    return YSensor.FindSensorInContext(this._yapi, next_hwid);
  }
  static FirstSensor() {
    let next_hwid = YAPI.imm_getFirstHardwareId("Sensor");
    if (next_hwid == null)
      return null;
    return YSensor.FindSensor(next_hwid);
  }
  static FirstSensorInContext(yctx) {
    let next_hwid = yctx.imm_getFirstHardwareId("Sensor");
    if (next_hwid == null)
      return null;
    return YSensor.FindSensorInContext(yctx, next_hwid);
  }
};
YSensor.UNIT_INVALID = YAPI_INVALID_STRING;
YSensor.CURRENTVALUE_INVALID = YAPI_INVALID_DOUBLE;
YSensor.LOWESTVALUE_INVALID = YAPI_INVALID_DOUBLE;
YSensor.HIGHESTVALUE_INVALID = YAPI_INVALID_DOUBLE;
YSensor.CURRENTRAWVALUE_INVALID = YAPI_INVALID_DOUBLE;
YSensor.LOGFREQUENCY_INVALID = YAPI_INVALID_STRING;
YSensor.REPORTFREQUENCY_INVALID = YAPI_INVALID_STRING;
YSensor.ADVMODE_IMMEDIATE = 0;
YSensor.ADVMODE_PERIOD_AVG = 1;
YSensor.ADVMODE_PERIOD_MIN = 2;
YSensor.ADVMODE_PERIOD_MAX = 3;
YSensor.ADVMODE_INVALID = -1;
YSensor.CALIBRATIONPARAM_INVALID = YAPI_INVALID_STRING;
YSensor.RESOLUTION_INVALID = YAPI_INVALID_DOUBLE;
YSensor.SENSORSTATE_INVALID = YAPI_INVALID_INT;
var YMeasure = class {
  constructor(float_start, float_end, float_minVal, float_avgVal, float_maxVal) {
    this._start = 0;
    this._end = 0;
    this._minVal = 0;
    this._avgVal = 0;
    this._maxVal = 0;
    this._start = float_start;
    this._end = float_end;
    this._minVal = float_minVal;
    this._avgVal = float_avgVal;
    this._maxVal = float_maxVal;
  }
  get_startTimeUTC() {
    return this._start;
  }
  get_endTimeUTC() {
    return this._end;
  }
  get_minValue() {
    return this._minVal;
  }
  get_averageValue() {
    return this._avgVal;
  }
  get_maxValue() {
    return this._maxVal;
  }
  get_startTimeUTC_asDate() {
    return new Date(Math.round(this._start * 1e3));
  }
  get_endTimeUTC_asDate() {
    return new Date(Math.round(this._end * 1e3));
  }
};
var YDataLogger = class extends YFunction {
  constructor(yapi, func) {
    super(yapi, func);
    this._currentRunIndex = YDataLogger.CURRENTRUNINDEX_INVALID;
    this._timeUTC = YDataLogger.TIMEUTC_INVALID;
    this._recording = YDataLogger.RECORDING_INVALID;
    this._autoStart = YDataLogger.AUTOSTART_INVALID;
    this._beaconDriven = YDataLogger.BEACONDRIVEN_INVALID;
    this._usage = YDataLogger.USAGE_INVALID;
    this._clearHistory = YDataLogger.CLEARHISTORY_INVALID;
    this._valueCallbackDataLogger = null;
    this.CURRENTRUNINDEX_INVALID = YAPI_INVALID_UINT;
    this.TIMEUTC_INVALID = YAPI_INVALID_LONG;
    this.RECORDING_OFF = 0;
    this.RECORDING_ON = 1;
    this.RECORDING_PENDING = 2;
    this.RECORDING_INVALID = -1;
    this.AUTOSTART_OFF = 0;
    this.AUTOSTART_ON = 1;
    this.AUTOSTART_INVALID = -1;
    this.BEACONDRIVEN_OFF = 0;
    this.BEACONDRIVEN_ON = 1;
    this.BEACONDRIVEN_INVALID = -1;
    this.USAGE_INVALID = YAPI_INVALID_UINT;
    this.CLEARHISTORY_FALSE = 0;
    this.CLEARHISTORY_TRUE = 1;
    this.CLEARHISTORY_INVALID = -1;
    this._className = "DataLogger";
  }
  imm_parseAttr(name, val) {
    switch (name) {
      case "currentRunIndex":
        this._currentRunIndex = val;
        return 1;
      case "timeUTC":
        this._timeUTC = val;
        return 1;
      case "recording":
        this._recording = val;
        return 1;
      case "autoStart":
        this._autoStart = val;
        return 1;
      case "beaconDriven":
        this._beaconDriven = val;
        return 1;
      case "usage":
        this._usage = val;
        return 1;
      case "clearHistory":
        this._clearHistory = val;
        return 1;
    }
    return super.imm_parseAttr(name, val);
  }
  async get_currentRunIndex() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YDataLogger.CURRENTRUNINDEX_INVALID;
      }
    }
    res = this._currentRunIndex;
    return res;
  }
  async get_timeUTC() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YDataLogger.TIMEUTC_INVALID;
      }
    }
    res = this._timeUTC;
    return res;
  }
  async set_timeUTC(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("timeUTC", rest_val);
  }
  async get_recording() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YDataLogger.RECORDING_INVALID;
      }
    }
    res = this._recording;
    return res;
  }
  async set_recording(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("recording", rest_val);
  }
  async get_autoStart() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YDataLogger.AUTOSTART_INVALID;
      }
    }
    res = this._autoStart;
    return res;
  }
  async set_autoStart(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("autoStart", rest_val);
  }
  async get_beaconDriven() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YDataLogger.BEACONDRIVEN_INVALID;
      }
    }
    res = this._beaconDriven;
    return res;
  }
  async set_beaconDriven(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("beaconDriven", rest_val);
  }
  async get_usage() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YDataLogger.USAGE_INVALID;
      }
    }
    res = this._usage;
    return res;
  }
  async get_clearHistory() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != YAPI_SUCCESS) {
        return YDataLogger.CLEARHISTORY_INVALID;
      }
    }
    res = this._clearHistory;
    return res;
  }
  async set_clearHistory(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("clearHistory", rest_val);
  }
  static FindDataLogger(func) {
    let obj;
    obj = YFunction._FindFromCache("DataLogger", func);
    if (obj == null) {
      obj = new YDataLogger(YAPI, func);
      YFunction._AddToCache("DataLogger", func, obj);
    }
    return obj;
  }
  static FindDataLoggerInContext(yctx, func) {
    let obj;
    obj = YFunction._FindFromCacheInContext(yctx, "DataLogger", func);
    if (obj == null) {
      obj = new YDataLogger(yctx, func);
      YFunction._AddToCache("DataLogger", func, obj);
    }
    return obj;
  }
  async registerValueCallback(callback) {
    let val;
    if (callback != null) {
      await YFunction._UpdateValueCallbackList(this, true);
    } else {
      await YFunction._UpdateValueCallbackList(this, false);
    }
    this._valueCallbackDataLogger = callback;
    if (callback != null && await this.isOnline()) {
      val = this._advertisedValue;
      if (!(val == "")) {
        await this._invokeValueCallback(val);
      }
    }
    return 0;
  }
  async _invokeValueCallback(value) {
    if (this._valueCallbackDataLogger != null) {
      try {
        await this._valueCallbackDataLogger(this, value);
      } catch (e) {
        this._yapi.imm_log("Exception in valueCallback:", e);
      }
    } else {
      await super._invokeValueCallback(value);
    }
    return 0;
  }
  async forgetAllDataStreams() {
    return await this.set_clearHistory(1);
  }
  async get_dataSets() {
    return await this.parse_dataSets(await this._download("logger.json"));
  }
  async parse_dataSets(json) {
    let dslist = [];
    let dataset;
    let res = [];
    dslist = this.imm_json_get_array(json);
    res.length = 0;
    for (let ii in dslist) {
      dataset = new YDataSet(this);
      await dataset._parse(dslist[ii]);
      res.push(dataset);
    }
    return res;
  }
  nextDataLogger() {
    let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
    if (resolve.errorType != YAPI.SUCCESS)
      return null;
    let next_hwid = this._yapi.imm_getNextHardwareId(this._className, resolve.result);
    if (next_hwid == null)
      return null;
    return YDataLogger.FindDataLoggerInContext(this._yapi, next_hwid);
  }
  static FirstDataLogger() {
    let next_hwid = YAPI.imm_getFirstHardwareId("DataLogger");
    if (next_hwid == null)
      return null;
    return YDataLogger.FindDataLogger(next_hwid);
  }
  static FirstDataLoggerInContext(yctx) {
    let next_hwid = yctx.imm_getFirstHardwareId("DataLogger");
    if (next_hwid == null)
      return null;
    return YDataLogger.FindDataLoggerInContext(yctx, next_hwid);
  }
};
YDataLogger.CURRENTRUNINDEX_INVALID = YAPI_INVALID_UINT;
YDataLogger.TIMEUTC_INVALID = YAPI_INVALID_LONG;
YDataLogger.RECORDING_OFF = 0;
YDataLogger.RECORDING_ON = 1;
YDataLogger.RECORDING_PENDING = 2;
YDataLogger.RECORDING_INVALID = -1;
YDataLogger.AUTOSTART_OFF = 0;
YDataLogger.AUTOSTART_ON = 1;
YDataLogger.AUTOSTART_INVALID = -1;
YDataLogger.BEACONDRIVEN_OFF = 0;
YDataLogger.BEACONDRIVEN_ON = 1;
YDataLogger.BEACONDRIVEN_INVALID = -1;
YDataLogger.USAGE_INVALID = YAPI_INVALID_UINT;
YDataLogger.CLEARHISTORY_FALSE = 0;
YDataLogger.CLEARHISTORY_TRUE = 1;
YDataLogger.CLEARHISTORY_INVALID = -1;
var YSystemEnv = class {
  constructor() {
    this.isNodeJS = false;
    this.hasSSDP = false;
  }
  unknownSystemEnvError() {
    return new YoctoError("Unspecified runtime environment, your project should include at least once either yocto_api_nodejs or yocto_api_html");
  }
  hookUnhandledRejection(handler) {
    throw this.unknownSystemEnvError();
  }
  getWebSocketHub(obj_yapi, urlInfo) {
    throw this.unknownSystemEnvError();
  }
  getHttpHub(obj_yapi, urlInfo) {
    throw this.unknownSystemEnvError();
  }
  getWebSocketCallbackHub(obj_yapi, urlInfo, ws) {
    throw this.unknownSystemEnvError();
  }
  getHttpCallbackHub(yapi, urlInfo, incomingMessage, serverResponse) {
    throw this.unknownSystemEnvError();
  }
  getSSDPManager(obj_yapi) {
    throw this.unknownSystemEnvError();
  }
  async loadfile(file) {
    throw this.unknownSystemEnvError();
  }
  async downloadfile(url) {
    throw this.unknownSystemEnvError();
  }
};
var _UnspecifiedSystemEnv = new YSystemEnv();
var YGenericHub = class {
  constructor(yapi, urlInfo) {
    this._lastErrorType = YAPI_IO_ERROR;
    this._lastErrorMsg = "Hub attachment has not been triggered";
    this.hubSerial = "";
    this.serialByYdx = [];
    this._currentState = -6;
    this._targetState = -5;
    this.currentConnID = "";
    this.connResolvers = [];
    this.disconnResolvers = [];
    this.retryDelay = 15;
    this._reconnectionTimer = null;
    this._rwAccess = null;
    this.keepTryingExpiration = 0;
    this.keepTryingTimeoutId = null;
    this.timeoutId = null;
    this.lastPingStamp = 0;
    this.isNotifWorking = false;
    this.devListExpires = 0;
    this.notifPos = -1;
    this.notifCarryOver = "";
    this.missing = {};
    this._firstArrivalCallback = true;
    this._missing = {};
    this._knownUrls = [];
    this._yapi = yapi;
    this.urlInfo = urlInfo;
    this.stalledTimeoutMs = yapi._networkTimeoutMs;
    this._hubRef = YGenericHub.globalHubRefCounter++;
    this._knownUrls.push(urlInfo.orgUrl);
  }
  _throw(int_errType, str_errMsg, obj_retVal) {
    this._lastErrorType = int_errType;
    this._lastErrorMsg = str_errMsg;
    return this._yapi._throw(int_errType, str_errMsg, obj_retVal);
  }
  get_errorType() {
    return this._lastErrorType;
  }
  get_errorMessage() {
    return this._lastErrorMsg;
  }
  imm_forceUpdate() {
    this.devListExpires = this._yapi.GetTickCount();
  }
  imm_logrequest(method, devUrl, obj_body) {
    let msg = "Request: " + method + " " + devUrl;
    if (obj_body) {
      msg += " (file=" + obj_body.fname + ")";
    }
    this._yapi.imm_log(msg);
  }
  imm_setState(newState) {
    this._currentState = newState;
  }
  imm_setTargetState(newState) {
    this._targetState = newState;
  }
  imm_isDisconnecting() {
    return this._targetState <= -5;
  }
  imm_isDisconnected() {
    return this._targetState <= -5 && this._currentState <= -5;
  }
  imm_isPreOrRegistered() {
    return this._targetState >= 1;
  }
  imm_isOnline() {
    return Date.now() - this.lastPingStamp < this.stalledTimeoutMs;
  }
  imm_isForwarded() {
    return false;
  }
  imm_updateUrl(urlInfo) {
    if (!this._knownUrls.includes(urlInfo.orgUrl)) {
      this._knownUrls.push(urlInfo.orgUrl);
    }
    if (this.urlInfo.authUrl == urlInfo.authUrl) {
      this.urlInfo = urlInfo;
      return;
    }
    this.urlInfo = urlInfo;
    if (this._currentState < -1) {
      if (this._yapi._logLevel >= 4) {
        this._yapi.imm_log("Updating auth credentials for " + this.urlInfo.rootUrl);
      }
    }
  }
  imm_inheritFrom(otherHub) {
    if (this._targetState < otherHub._targetState) {
      this.imm_setTargetState(otherHub._targetState);
    }
    for (let j = 0; j < otherHub.serialByYdx.length; j++) {
      let serial = otherHub.serialByYdx[j];
      if (serial && !this.serialByYdx[j]) {
        this.serialByYdx[j] = serial;
      }
    }
    if (this._currentState >= 0 && otherHub._currentState < 0) {
      let res_struct = {errorType: YAPI_SUCCESS, errorMsg: "Hub " + this.hubSerial + " already connected"};
      let resolvers = otherHub.connResolvers;
      for (let resolveOne of resolvers) {
        resolveOne(res_struct);
      }
    } else {
      for (let resolver of otherHub.connResolvers) {
        this.connResolvers.push(resolver);
      }
    }
    otherHub.connResolvers = [];
    if (this._yapi._logLevel >= 3) {
      this._yapi.imm_log("Hub " + this.hubSerial + " is connected as " + this.urlInfo.rootUrl + ", dropping connection to " + otherHub.urlInfo.rootUrl);
    }
    otherHub.imm_commonDisconnect("inherit", YAPI_SUCCESS, "Hub " + this.hubSerial + " is already connected via " + this.urlInfo.rootUrl);
    otherHub.imm_disconnectNow();
    for (const url of otherHub.get_knownUrls()) {
      if (!this._knownUrls.includes(url)) {
        this._knownUrls.push(url);
      }
    }
  }
  imm_getNewConnID() {
    let time = new Date();
    return (time.getHours() + "h" + time.getMinutes() + "m" + time.getTime() % 6e4 / 1e3).toString() + "_0";
  }
  imm_tryTestConnectFor(mstimeout) {
    let minimalExpiration = Date.now() + mstimeout;
    if (this.keepTryingExpiration < minimalExpiration) {
      this.keepTryingExpiration = minimalExpiration;
      if (this.keepTryingTimeoutId) {
        clearTimeout(this.keepTryingTimeoutId);
      }
      this.keepTryingTimeoutId = setTimeout(() => {
        this.keepTryingTimeoutId = null;
        if (this._targetState == 0) {
          if (this._yapi._logLevel >= 4) {
            this._yapi.imm_log("TestHub timeout reached, disconnecting");
          }
          this.detach(YAPI.IO_ERROR, "TestHub timeout reached");
        }
      }, mstimeout);
    }
  }
  async attach(targetConnType) {
    if (this._targetState <= 0 || targetConnType > 0) {
      this.imm_setTargetState(targetConnType);
      if (this._currentState == 0 && targetConnType > 0) {
        try {
          await this._yapi._ensureUpdateDeviceListNotRunning();
          await this._yapi._addConnectedHub(this);
          this.imm_setState(targetConnType);
        } catch (e) {
          this.imm_disconnectNow();
        }
      }
      if (targetConnType == 0) {
        this.imm_tryTestConnectFor(100);
      }
    }
    if (this._currentState <= -5) {
      this.imm_setState(-1);
      this.reconnect(this.imm_getNewConnID());
    } else if (this._currentState == -3) {
      if (this._reconnectionTimer) {
        if (this._yapi._logLevel >= 4) {
          this._yapi.imm_log("New hub connection requested, retry now (drop [" + this.currentConnID + "])");
        }
        clearTimeout(this._reconnectionTimer);
        this._reconnectionTimer = null;
        this.currentConnID = "";
      } else {
        if (this._yapi._logLevel >= 4) {
          this._yapi.imm_log("New hub connection requested, retry now (no pending reconnection ?!?)");
        }
      }
      this.reconnect(this.imm_getNewConnID());
    } else if (this._currentState == -4 || this._currentState == -2) {
      if (this._yapi._logLevel >= 4) {
        this._yapi.imm_log("Hub is currently disconnecting, reconnection will be triggered soon [" + this.currentConnID + "]");
        this._yapi.imm_log("Current state: " + this._currentState);
        this._yapi.imm_log("Target state: " + this._targetState + " (" + targetConnType + ")");
      }
    }
  }
  async waitForConnection(mstimeout, errmsg) {
    if (this._targetState < 0) {
      errmsg.msg = this._lastErrorMsg;
      return this._lastErrorType;
    }
    if (this._currentState >= 0) {
      return YAPI_SUCCESS;
    }
    if (mstimeout <= 1) {
      errmsg.msg = "Hub not connected";
      return YAPI_TIMEOUT;
    }
    if (this._targetState == 0) {
      this.imm_tryTestConnectFor(mstimeout);
    }
    let connOpenPromise = null;
    let connOpenTimeoutObj = null;
    let addResolverPromise;
    addResolverPromise = new Promise((resolverReady, noResolver) => {
      connOpenPromise = new Promise((resolve, reject) => {
        this.connResolvers.push(resolve);
        resolverReady(resolve);
        connOpenTimeoutObj = setTimeout(() => {
          if (this._yapi._logLevel >= 4) {
            this._yapi.imm_log("Timeout waiting for hub connection");
          }
          resolve({errorType: YAPI_TIMEOUT, errorMsg: "Timeout waiting for hub connection"});
        }, mstimeout);
      });
    });
    let resolver = await addResolverPromise;
    if (this._targetState < 0) {
      clearTimeout(connOpenTimeoutObj);
      errmsg.msg = this._lastErrorMsg;
      return this._lastErrorType;
    }
    if (this._currentState >= 0) {
      clearTimeout(connOpenTimeoutObj);
      return YAPI_SUCCESS;
    }
    let openRes = await connOpenPromise;
    clearTimeout(connOpenTimeoutObj);
    if (openRes.errorType != YAPI_SUCCESS) {
      if (errmsg) {
        errmsg.msg = openRes.errorMsg;
      }
    }
    return openRes.errorType;
  }
  async reconnect(tryOpenID) {
  }
  async signalHubConnected(tryOpenID, hubSerial) {
    this.imm_setState(0);
    this.hubSerial = hubSerial;
    if (this._yapi._logLevel >= 4) {
      this._yapi.imm_log("Hub " + hubSerial + " connected [" + tryOpenID + "]");
    }
    let primaryHub = this._yapi.imm_getPrimaryHub(this);
    if (primaryHub._targetState >= 1) {
      if (primaryHub._currentState < 1) {
        try {
          await primaryHub._yapi._ensureUpdateDeviceListNotRunning();
          await primaryHub._yapi._addConnectedHub(primaryHub);
        } catch (e) {
          primaryHub.imm_disconnectNow();
          return;
        }
      }
      if (primaryHub._currentState < primaryHub._targetState) {
        primaryHub.imm_setState(primaryHub._targetState);
      }
    } else {
      primaryHub.keepTryingExpiration = 0;
      primaryHub.imm_tryTestConnectFor(100);
    }
    let res_struct = {errorType: YAPI_SUCCESS, errorMsg: "Hub " + hubSerial + " connected"};
    let resolvers = primaryHub.connResolvers;
    primaryHub.connResolvers = [];
    primaryHub._lastErrorType = res_struct.errorType;
    primaryHub._lastErrorMsg = res_struct.errorMsg;
    for (let resolveOne of resolvers) {
      resolveOne(res_struct);
    }
  }
  imm_signalHubDisconnected(tryOpenID) {
    if (this._currentState > -3) {
      this.imm_setState(-3);
    }
    this.isNotifWorking = false;
    this.devListExpires = 0;
    this._yapi.imm_dropConnectedHub(this);
    this._firstArrivalCallback = true;
    let resolvers = this.disconnResolvers;
    this.disconnResolvers = [];
    for (let resolveOne of resolvers) {
      resolveOne({errorType: YAPI_SUCCESS, errorMsg: "Hub disconnect completed"});
    }
    if (this.imm_isDisconnecting()) {
      this.imm_setState(-5);
      if (this._yapi._logLevel >= 4) {
        this._yapi.imm_log("Hub " + this.urlInfo.rootUrl + " detached");
      }
      return false;
    }
    if (this._reconnectionTimer) {
      if (this._yapi._logLevel >= 4) {
        this._yapi.imm_log("Hub disconnected, reconnection is already scheduled [" + this.currentConnID + "]");
      }
      return true;
    }
    let openIDwords = tryOpenID.split("_");
    let nextOpenID = openIDwords[0] + "_" + (parseInt(openIDwords[1]) + 1).toString();
    if (this.retryDelay < 5e3)
      this.retryDelay *= 2;
    if (this._yapi._logLevel >= 4) {
      this._yapi.imm_log("Hub reconnection scheduled in " + this.retryDelay / 1e3 + "s [" + nextOpenID + "]");
    }
    this.currentConnID = nextOpenID;
    this._reconnectionTimer = setTimeout(() => {
      this._reconnectionTimer = null;
      this.currentConnID = "";
      if (this.imm_isDisconnecting()) {
        return;
      }
      if (this._yapi._logLevel >= 4) {
        this._yapi.imm_log("Retry hub connection now [" + nextOpenID + "]");
      }
      this.reconnect(nextOpenID);
    }, this.retryDelay);
    return true;
  }
  imm_commonDisconnect(tryOpenID, errType, errMsg) {
    this._lastErrorType = errType;
    this._lastErrorMsg = errMsg;
    if (this._currentState >= -2) {
      this.imm_setState(-4);
    } else if (this._currentState == -3) {
      this.imm_setState(-5);
    }
    this.imm_setTargetState(-5);
    if (this._reconnectionTimer) {
      clearTimeout(this._reconnectionTimer);
      this._reconnectionTimer = null;
    }
    if (this.timeoutId) {
      clearTimeout(this.timeoutId);
      this.timeoutId = null;
    }
    if (errType != YAPI_SUCCESS && this._yapi._logLevel >= 4 && tryOpenID != "detach") {
      this._yapi.imm_log("Hub connection failed: " + errMsg + " [" + tryOpenID + "]");
    }
    this._firstArrivalCallback = true;
    let res_struct = {errorType: errType, errorMsg: errMsg};
    let resolvers = this.connResolvers;
    this.connResolvers = [];
    for (let resolveOne of resolvers) {
      resolveOne(res_struct);
    }
  }
  imm_disconnectNow(connID = "") {
    if (connID && connID != this.currentConnID) {
      return false;
    }
    if (this._currentState > -2) {
      this.imm_setState(-2);
    }
    if (this.timeoutId) {
      clearTimeout(this.timeoutId);
      this.timeoutId = null;
    }
    return true;
  }
  async detach(errType = YAPI.IO_ERROR, errMsg = "Hub has been forcibly detached") {
    this.imm_commonDisconnect("detach", errType, errMsg);
    this.imm_disconnectNow();
  }
  async waitForDisconnection(mstimeout) {
    let disconnPromise = null;
    let disconnTimeoutObj = null;
    disconnPromise = new Promise((resolve, reject) => {
      this.disconnResolvers.push(resolve);
      disconnTimeoutObj = setTimeout(() => {
        if (this._yapi._logLevel >= 4) {
          this._yapi.imm_log("Timeout waiting for hub disconnection");
        }
        resolve({errorType: YAPI_TIMEOUT, errorMsg: "Timeout waiting for hub connection"});
      }, mstimeout);
    });
    await disconnPromise;
    clearTimeout(disconnTimeoutObj);
  }
  async hubUpdateDeviceList() {
    let hubDev = this._yapi.imm_getDevice(this.urlInfo.rootUrl);
    try {
      hubDev.imm_dropCache();
      let retcode = await hubDev.refresh();
      if (retcode != YAPI_SUCCESS) {
        if (this._currentState >= 1) {
          await this._yapi.updateDeviceList_process(this, hubDev, [], {});
        }
        this.imm_disconnectNow();
        return this._throw(retcode, hubDev._lastErrorMsg, retcode);
      }
      let yreq = await hubDev.requestAPI(this._yapi.defaultCacheValidity);
      if (yreq.errorType != YAPI_SUCCESS) {
        if (this._currentState >= 1) {
          await this._yapi.updateDeviceList_process(this, hubDev, [], {});
        }
        this.imm_disconnectNow();
        return yreq.errorType;
      }
      let whitePages = yreq.obj_result.services.whitePages;
      let yellowPages = yreq.obj_result.services.yellowPages;
      if (!whitePages) {
        this.imm_disconnectNow();
        return this._throw(YAPI_IO_ERROR, "Device " + hubDev.imm_describe() + " is not a hub", YAPI_IO_ERROR);
      }
      retcode = await this._yapi.updateDeviceList_process(this, hubDev, whitePages, yellowPages);
      if (retcode < 0) {
        this.imm_disconnectNow();
        return this._throw(this._yapi._lastErrorType, this._yapi._lastErrorMsg, this._yapi._lastErrorType);
      }
      if (this.isNotifWorking) {
        this.devListExpires = this._yapi.GetTickCount() + this._yapi._deviceListValidityMs;
      } else {
        this.devListExpires = this._yapi.GetTickCount() + 500;
      }
      return retcode;
    } catch (e) {
      this._yapi.imm_log("Exception during device enumeration: ", e);
      if (this._currentState >= 1) {
        try {
          await this._yapi.updateDeviceList_process(this, hubDev, [], {});
        } catch (e2) {
        }
      }
      this.imm_disconnectNow();
      return YAPI_IO_ERROR;
    }
  }
  async request(method, devUrl, obj_body, tcpchan) {
    let res = new YHTTPRequest(null);
    res.errorType = YAPI_NOT_SUPPORTED;
    res.errorMsg = "GenericHub subclass expected";
    return res;
  }
  imm_getBoundary() {
    return "Zz" + Math.floor(Math.random() * 16777215).toString(16) + "zZ";
  }
  imm_formEncodeBody(obj_body, str_boundary) {
    let hdr = this._yapi.imm_str2bin('Content-Disposition: form-data; name="' + obj_body.fname + '"; filename="api"\r\nContent-Type: application/octet-stream\r\nContent-Transfer-Encoding: binary\r\n\r\n');
    let boundary = this._yapi.imm_str2bin(str_boundary);
    let dash = this._yapi.imm_str2bin("--");
    let crlf = this._yapi.imm_str2bin("\r\n");
    let parts = [dash, boundary, crlf, hdr, obj_body.data, crlf, dash, boundary, dash, crlf];
    let i, len = 0;
    for (i = 0; i < parts.length; i++) {
      len += parts[i].length;
    }
    let res = new Uint8Array(len);
    len = 0;
    for (i = 0; i < parts.length; i++) {
      res.set(parts[i], len);
      len += parts[i].length;
    }
    return res;
  }
  async getBootloaders() {
    let yreq = await this.request("GET", "/flash.json?a=list", null, 1);
    if (yreq.errorType != YAPI_SUCCESS) {
      return this._throw(yreq.errorType, yreq.errorMsg, []);
    }
    let flashState = JSON.parse(YAPI.imm_bin2str(yreq.bin_result));
    return flashState["list"];
  }
  async firmwareUpdate(serial, firmware, settings, progress) {
    let use_self_flash = false;
    let baseUrl = "";
    let need_reboot = true;
    let _throw = (msg) => {
      return this._throw(YAPI.IO_ERROR, msg, [msg]);
    };
    progress(5, "Check bootloader type");
    let yreq = await this.request("GET", "/api/module.json", null, 0);
    if (yreq.errorType != YAPI_SUCCESS) {
      return _throw("Hub is not responding");
    }
    let json = JSON.parse(this._yapi.imm_bin2str(yreq.bin_result));
    let ownSerial = json.serialNumber;
    if (ownSerial.slice(0, 7) == "VIRTHUB") {
      use_self_flash = false;
    } else if (serial == ownSerial) {
      use_self_flash = true;
    } else {
      yreq = await this.request("GET", "/bySerial/" + serial + "/flash.json?a=state", null, 0);
      if (yreq.errorType == YAPI_SUCCESS && yreq.bin_result.length > 0) {
        use_self_flash = true;
        baseUrl = "/bySerial/" + serial;
      }
    }
    let bootloaders = await this.getBootloaders();
    let is_shield = serial.slice(0, 7) == "YHUBSHL";
    let i;
    for (i = 0; i < bootloaders.length; i++) {
      let bl = bootloaders[i];
      if (bl == serial) {
        need_reboot = false;
      } else if (is_shield) {
        if (bl.slice(0, 7) == "YHUBSHL") {
          return _throw("Only one YoctoHub-Shield is allowed in update mode");
        }
      }
    }
    if (!use_self_flash && need_reboot) {
      if (bootloaders.length >= 4) {
        return _throw("Too many devices in update mode");
      }
    }
    yreq = await this.request("GET", baseUrl + "/flash.json?a=state", null, 0);
    if (yreq.errorType != YAPI_SUCCESS) {
      return _throw("Cannot check state of firmware upload");
    }
    json = JSON.parse(this._yapi.imm_bin2str(yreq.bin_result));
    if (json["state"] == "uploading" || json["state"] == "flashing") {
      return _throw("Cannot start firmware update: busy (" + json["state"] + ")");
    }
    progress(10, "Send firmware file");
    let progressCb = function(curr, total) {
      curr >>= 10;
      total >>= 10;
      progress(10 + (28 * curr / total >> 0), "Send firmware file: " + curr + "KB / " + total + "KB");
    };
    yreq = await this.request("POST", baseUrl + "/upload.html", new YHTTPBody("firmware", firmware.imm_getData(), progressCb), 0);
    if (yreq.errorType != YAPI_SUCCESS) {
      return _throw("Firmware upload failed: " + yreq.errorMsg);
    }
    yreq = await this.request("GET", baseUrl + "/flash.json?a=state", null, 0);
    if (yreq.errorType != YAPI_SUCCESS) {
      return _throw("Cannot check state of firmware upload");
    }
    json = JSON.parse(this._yapi.imm_bin2str(yreq.bin_result));
    if (json["state"] != "valid") {
      return _throw("Upload of firmware failed: invalid firmware(" + json["state"] + ")");
    }
    if (json["progress"] != "100") {
      return _throw("Upload of firmware failed: incomplete upload");
    }
    if (use_self_flash) {
      let settingsStr = this._yapi.imm_bin2str(settings);
      let settingsAndFiles = JSON.parse(settingsStr);
      let settingsOnly = settingsAndFiles["api"];
      let startupApi = {};
      for (let key in settingsOnly) {
        if (key != "services") {
          startupApi[key] = settingsOnly[key];
        }
      }
      let startupConf = this._yapi.imm_str2bin(JSON.stringify(startupApi));
      progress(38, "Save current settings");
      yreq = await this.request("POST", baseUrl + "/upload.html", new YHTTPBody("startupConf.json", startupConf, null), 0);
      if (yreq.errorType != YAPI_SUCCESS) {
        return _throw("Failed to save settings on hub");
      }
      progress(39, "Save current settings");
      yreq = await this.request("POST", baseUrl + "/upload.html", new YHTTPBody("firmwareConf", startupConf, null), 0);
      if (yreq.errorType != YAPI_SUCCESS) {
        return _throw("Failed to save settings on hub");
      }
    }
    if (use_self_flash) {
      progress(40, "Flash firmware");
      await this.request("GET", baseUrl + "/api/module/rebootCountdown?rebootCountdown=-1003", null, 0);
      await this._yapi.Sleep(7e3);
    } else {
      if (need_reboot) {
        await this.request("GET", "/bySerial/" + serial + "/api/module/rebootCountdown?rebootCountdown=-2", null, 0);
      }
      let timeout = YAPI.GetTickCount() + 2e4;
      let res;
      let found = false;
      progress(40, "Wait for device to be in bootloader");
      do {
        bootloaders = await this.getBootloaders();
        for (i = 0; i < bootloaders.length; i++) {
          let bl = bootloaders[i];
          if (bl == serial) {
            found = true;
            break;
          }
        }
        if (!found) {
          await this._yapi.Sleep(500);
        }
      } while (!found && YAPI.GetTickCount() < timeout);
      progress(45, "Flash firmware");
      let fwsize = firmware.imm_getData().length + 512 >> 10;
      let checkTimer;
      let checkFlash = () => {
        this.request("GET", baseUrl + "/flash.json?a=state", null, 1).then((flashReq) => {
          if (flashReq.errorType == YAPI_SUCCESS) {
            let jsonState = YAPI.imm_bin2str(flashReq.bin_result);
            let res2 = JSON.parse(jsonState);
            if (res2.state == "flashing") {
              if (res2.progress < 20) {
                progress(45 + (res2.progress / 3 >> 0), "Erasing previous firmware: " + (fwsize * (res2.progress - 3) / 18 >> 0) + "KB / " + fwsize + "KB");
              } else {
                progress(45 + (res2.progress / 3 >> 0), "Flashing new firmware: " + (fwsize * (res2.progress - 20) / 76 >> 0) + "KB / " + fwsize + "KB");
              }
            }
          }
          checkTimer = setTimeout(checkFlash, 500);
        }).catch((e) => {
          this._yapi.imm_log("Exception during firmware flash: ", e);
          checkTimer = setTimeout(checkFlash, 500);
        });
      };
      checkTimer = setTimeout(checkFlash, 1e3);
      yreq = await this.request("GET", "/flash.json?a=flash&s=" + serial, null, 0);
      clearTimeout(checkTimer);
      if (yreq.errorType != YAPI_SUCCESS) {
        return _throw("Cannot check state of firmware flash");
      }
      return JSON.parse(this._yapi.imm_bin2str(yreq.bin_result));
    }
    return null;
  }
  async reportFailure(message) {
  }
  async hasRwAccess() {
    if (this._rwAccess == null) {
      let yreq = await this.request("GET", "/api/module/serialNumber.json?serialNumber=rwTest", null, 0);
      this._rwAccess = yreq.errorType == YAPI_SUCCESS;
    }
    return this._rwAccess;
  }
  getHubRef() {
    return this._hubRef;
  }
  get_knownUrls() {
    let res = this._knownUrls.slice();
    return res;
  }
  imm_forgetUrls() {
    this._knownUrls = [];
  }
};
YGenericHub.globalHubRefCounter = 0;
var YHttpHub = class extends YGenericHub {
  constructor(yapi, urlInfo) {
    super(yapi, urlInfo);
    this.infoJson = null;
    this.realm = "";
    this.nonce = "";
    this.nonceCount = 0;
    this.notbynRequest = null;
  }
  imm_makeRequest(method, relUrl, contentType, body, onProgress, onSuccess, onError) {
  }
  imm_abortRequest(clientRequest) {
  }
  imm_sendRequest(method, relUrl, obj_body, onProgress, onSuccess, onError) {
    let body = null;
    let contentType = "text/plain; charset=x-user-defined";
    if (this.infoJson && this.infoJson.realm && this.infoJson.nonce) {
      if (this.realm != this.infoJson.realm || this.nonce != this.infoJson.nonce) {
        this.realm = this.infoJson.realm;
        this.nonce = this.infoJson.nonce;
        this.nonceCount = 0;
      }
      let shorturi = "/" + this.urlInfo.domain + relUrl;
      let jsonBody = {
        "x-yauth": {
          method,
          uri: shorturi
        }
      };
      if (this.urlInfo.user || this.urlInfo.pass) {
        let cnonce = Math.floor(Math.random() * 2147483647).toString(16).toLowerCase();
        let nc = (++this.nonceCount).toString(16).toLowerCase();
        let ha1_str = this.urlInfo.user + ":" + this.realm + ":" + this.urlInfo.pass;
        let ha2_str = method + ":" + shorturi;
        let A1 = this._yapi.imm_bin2hexstr(this._yapi.imm_yMD5(ha1_str)).toLowerCase();
        let A2 = this._yapi.imm_bin2hexstr(this._yapi.imm_ySHA1(ha2_str)).toLowerCase();
        let signature = A1 + ":" + this.nonce + ":" + nc + ":" + cnonce + ":auth:" + A2;
        let response = this._yapi.imm_bin2hexstr(this._yapi.imm_ySHA1(signature)).toLowerCase();
        jsonBody["x-yauth"]["username"] = this.urlInfo.user;
        jsonBody["x-yauth"]["cnonce"] = cnonce;
        jsonBody["x-yauth"]["nonce"] = this.nonce;
        jsonBody["x-yauth"]["nc"] = nc;
        jsonBody["x-yauth"]["qop"] = "auth";
        jsonBody["x-yauth"]["response"] = response;
      }
      if (obj_body) {
        let binstr = this._yapi.imm_bin2str(obj_body.data);
        jsonBody["body"] = {
          filename: obj_body.fname,
          b64content: btoa(binstr)
        };
      }
      method = "POST";
      body = JSON.stringify(jsonBody);
      let qpos = relUrl.indexOf("?");
      if (qpos > 0) {
        relUrl = relUrl.slice(0, qpos);
      }
    } else if (obj_body != null) {
      let boundary = this.imm_getBoundary();
      if (this.infoJson && this.infoJson.nonce) {
        contentType = "x-upload; boundary=" + boundary;
      } else {
        contentType = "multipart/form-data; boundary=" + boundary;
      }
      body = this.imm_formEncodeBody(obj_body, boundary);
    }
    return this.imm_makeRequest(method, relUrl, contentType, body, onProgress, onSuccess, onError);
  }
  async tryFetch(relUrl) {
    return new Promise((resolve, reject) => {
      this.imm_sendRequest("GET", relUrl, null, null, (responseText) => {
        resolve({errorType: YAPI_SUCCESS, errorMsg: "", result: responseText});
      }, (errorType, errorMsg) => {
        resolve({errorType, errorMsg});
      });
    });
  }
  async reconnect(tryOpenID) {
    this.currentConnID = tryOpenID;
    if (!this.hubSerial || this.infoJson && this.infoJson.nonce && YAPI.GetTickCount() - this.infoJson.stamp > 12e3) {
      if (this._yapi._logLevel >= 4) {
        this._yapi.imm_log("Trying info.json [" + tryOpenID + "]");
      }
      let res_struct = await this.tryFetch("info.json");
      if (res_struct.errorType == YAPI_SUCCESS && res_struct.result) {
        this.infoJson = JSON.parse(res_struct.result);
        this.infoJson.stamp = YAPI.GetTickCount();
        if (this.infoJson && this.infoJson.serialNumber) {
          this.hubSerial = this.infoJson.serialNumber;
        }
      } else if (res_struct.errorType == YAPI_FILE_NOT_FOUND) {
        res_struct = await this.tryFetch("api/module/serialNumber");
        if (res_struct.errorType == YAPI_SUCCESS && res_struct.result) {
          this.hubSerial = res_struct.result;
        }
      }
      if (!this.hubSerial) {
        if (!super.imm_disconnectNow(tryOpenID)) {
          return;
        }
        if (!this.imm_isDisconnecting()) {
          if (this._yapi._logLevel >= 3) {
            this._yapi.imm_log("Failed to load info.json: " + res_struct.errorMsg + " [" + tryOpenID + "]");
          }
        }
        this._lastErrorType = res_struct.errorType;
        this._lastErrorMsg = res_struct.errorMsg;
        this.currentConnID = "";
        this.imm_signalHubDisconnected(tryOpenID);
        return;
      }
    }
    let primaryHub = this._yapi.imm_getPrimaryHub(this);
    if (primaryHub !== this) {
      this.imm_commonDisconnect(tryOpenID, YAPI_SUCCESS, "Hub " + this.hubSerial + " is already connected");
      this.currentConnID = "";
      this.imm_signalHubDisconnected(tryOpenID);
      return;
    }
    let args = "";
    if (this.notifPos >= 0) {
      args = "?abs=" + this.notifPos.toString();
    } else {
      this._firstArrivalCallback = true;
    }
    if (this._yapi._logLevel >= 4) {
      this._yapi.imm_log("Opening http connection to hub (" + args + ") [" + tryOpenID + "]");
    }
    this.notbynRequest = this.imm_sendRequest("GET", "not.byn" + args, null, (moreText) => {
      if (tryOpenID != this.currentConnID) {
        if (this._yapi._logLevel >= 3) {
          this._yapi.imm_log("Previous request still sending data [" + tryOpenID + "]");
        }
        return;
      }
      if (this.infoJson) {
        this.infoJson.stamp = YAPI.GetTickCount();
      }
      if (this._currentState < 0) {
        this.signalHubConnected(tryOpenID, this.hubSerial);
      }
      this._yapi.parseEvents(this, moreText);
    }, (resultText) => {
      if (tryOpenID != this.currentConnID) {
        if (this._yapi._logLevel >= 3) {
          this._yapi.imm_log("Previous request completed [" + tryOpenID + "]");
        }
        return;
      }
      this.reconnect(tryOpenID);
    }, (errorType, errorMsg) => {
      if (tryOpenID != this.currentConnID) {
        if (this._yapi._logLevel >= 3) {
          this._yapi.imm_log("Previous not.byn request says: " + errorMsg + " [" + tryOpenID + "]");
        }
        return;
      }
      if (!this.imm_isDisconnecting()) {
        if (this._yapi._logLevel >= 3) {
          this._yapi.imm_log("Failed to load not.byn (" + args + "): " + errorMsg + " [" + tryOpenID + "]");
        }
      }
      this._lastErrorType = errorType;
      this._lastErrorMsg = errorMsg;
      if (errorType == YAPI_UNAUTHORIZED) {
        this.imm_commonDisconnect(tryOpenID, errorType, errorMsg);
      }
      this.imm_disconnectNow();
    });
  }
  imm_disconnectNow(connID = "") {
    if (!super.imm_disconnectNow(connID)) {
      return false;
    }
    if (!this.notbynRequest) {
      return false;
    }
    let closeConnID = connID ? connID : this.currentConnID;
    this.imm_abortRequest(this.notbynRequest);
    this.notbynRequest = null;
    this.currentConnID = "";
    this.imm_signalHubDisconnected(closeConnID);
    return true;
  }
  async request(method, devUrl, obj_body, tcpchan) {
    if (this._yapi._logLevel >= 3) {
      this.imm_logrequest(method, devUrl, obj_body);
    }
    if (this._currentState < 0) {
      return new YHTTPRequest(null, YAPI.IO_ERROR, "Hub is currently unavailable");
    }
    return new Promise((resolve, reject) => {
      this.imm_sendRequest(method, devUrl.slice(1), obj_body, null, (responseText) => {
        if (this._currentState < 0) {
          resolve(new YHTTPRequest(null, YAPI.IO_ERROR, "Hub is currently unavailable"));
        } else {
          if (this._yapi._logLevel >= 4) {
            this._yapi.imm_log(method + " " + devUrl + " succeeded");
          }
          resolve(new YHTTPRequest(this._yapi.imm_str2bin(responseText)));
        }
      }, (errorType, errorMsg) => {
        if (this._yapi._logLevel >= 4) {
          this._yapi.imm_log(method + " " + devUrl + " failed (" + errorMsg + ")");
        }
        resolve(new YHTTPRequest(null, errorType, errorMsg));
      });
    });
  }
};
var YWebSocketHub = class extends YGenericHub {
  constructor(yapi, urlInfo) {
    super(yapi, urlInfo);
    this._DEFAULT_TCP_ROUND_TRIP_TIME = 30;
    this._DEFAULT_TCP_MAX_WINDOW_SIZE = 4 * 65536;
    this._YIO_DEFAULT_TCP_TIMEOUT = 2e4;
    this._YIO_1_MINUTE_TCP_TIMEOUT = 6e4;
    this._YIO_10_MINUTES_TCP_TIMEOUT = 6e5;
    this._USB_META_UTCTIME_SIZE = 5;
    this._USB_META_DLFLUSH_SIZE = 1;
    this._USB_META_ACK_D2H_PACKET_SIZE = 2;
    this._USB_META_WS_ANNOUNCE_SIZE = 8 + 20;
    this._USB_META_WS_AUTHENTICATION_SIZE = 28;
    this._USB_META_WS_ERROR_SIZE = 6;
    this._USB_META_ACK_UPLOAD_SIZE = 6;
    this._USB_META_WS_VALID_SHA1 = 1;
    this._USB_META_WS_RW = 2;
    this.websocket = null;
    this.tcpChan = [];
    this.nextAsyncId = 48;
    this._connectionTime = 0;
    this._remoteVersion = 0;
    this._remoteSerial = "";
    this._remoteNonce = -1;
    this._nonce = -1;
    this._session_error = null;
    this._session_errno = null;
    this._lastUploadAckBytes = [0];
    this._lastUploadAckTime = [0];
    this._lastUploadRateBytes = [0];
    this._lastUploadRateTime = [0];
    this._uploadRate = [0];
    this.fwd_nonce = -1;
    this.fwd_websocket = null;
    this.fwd_credentials = [];
    this.fwd_closeCallback = null;
    this._connectionState = 2;
    this._tcpRoundTripTime = this._DEFAULT_TCP_ROUND_TRIP_TIME;
    this._tcpMaxWindowSize = this._DEFAULT_TCP_MAX_WINDOW_SIZE;
    this.fwd_connectionState = 1;
  }
  imm_asyncWebSocketError(errorType, message) {
    this._yapi.imm_log("WS: " + message + " on " + this.urlInfo.rootUrl);
  }
  async reconnect(tryOpenID) {
    this._connectionState = 2;
    if (this._yapi._logLevel >= 4) {
      this._yapi.imm_log("Opening websocket connection [" + tryOpenID + "]");
    }
    this.currentConnID = tryOpenID;
    this.imm_webSocketOpen(this.urlInfo.authUrl + "not.byn");
    this._firstArrivalCallback = true;
    if (!this.websocket) {
      this.imm_commonDisconnect(tryOpenID, YAPI_IO_ERROR, "Failed to create WebSocket");
      return;
    }
    this.websocket.onmessage = (evt) => {
      if (this.currentConnID != tryOpenID) {
        if (this._yapi._logLevel >= 4) {
          this._yapi.imm_log("Incoming WebSocket data for previous connection [" + tryOpenID + "]");
        }
        return;
      }
      this._webSocketMsg(new Uint8Array(evt.data));
      if (this._connectionState == 4) {
        this._connectionState = 5;
        this.signalHubConnected(tryOpenID, this._remoteSerial);
      } else if (this._connectionState == 0) {
        let errMsg = this._session_error ? "WebSocket error: " + this._session_error : "Websocket I/O error";
        if (this._session_errno == 401) {
          this.imm_commonDisconnect(tryOpenID, YAPI_UNAUTHORIZED, errMsg);
        } else {
          this._lastErrorType = YAPI_IO_ERROR;
          this._lastErrorMsg = errMsg;
        }
        this.imm_disconnectNow();
      }
    };
    this.websocket.onclose = (evt) => {
      if (this.currentConnID != tryOpenID) {
        if (this._yapi._logLevel >= 4) {
          this._yapi.imm_log("WebSocket close received for previous connection [" + tryOpenID + "], now using [" + this.currentConnID + "]");
        }
        return;
      }
      if (this._yapi._logLevel >= 4) {
        this._yapi.imm_log("WebSocket connection closed [" + tryOpenID + "]");
      }
      this._connectionState = 1;
      this.websocket = null;
      if (this.retryDelay < 0) {
        this.imm_commonDisconnect(tryOpenID, YAPI_IO_ERROR, "Websocket callback connection closed");
      }
      this.imm_dropAllPendingConnection();
      this.imm_signalHubDisconnected(tryOpenID);
    };
    this.websocket.onerror = (evt) => {
      if (this.currentConnID != tryOpenID) {
        if (this._yapi._logLevel >= 4) {
          this._yapi.imm_log("WebSocket error received for previous connection [" + tryOpenID + "]");
        }
        return;
      }
      if (evt.message && (!/ ETIMEDOUT /.test(evt.message) || this._yapi._logLevel >= 4)) {
        this._yapi.imm_log("WebSocket error [" + tryOpenID + "]: ", evt);
        this._lastErrorType = YAPI_IO_ERROR;
        this._lastErrorMsg = evt.message;
      }
      if (this.retryDelay < 0) {
        this.imm_commonDisconnect(tryOpenID, YAPI_IO_ERROR, "Websocket callback connection closed");
      }
      this.imm_disconnectNow();
      this.imm_signalHubDisconnected(tryOpenID);
    };
    if (this.timeoutId) {
      clearTimeout(this.timeoutId);
    }
    this.timeoutId = setTimeout(() => {
      if (!this.imm_isForwarded()) {
        this._yapi.imm_log("WS: connection stalled during open [" + tryOpenID + "]");
        this.imm_disconnectNow();
      }
    }, this.stalledTimeoutMs);
  }
  imm_computeAuth(user, pass, serial, nonce) {
    let ha1_str = user + ":" + serial + ":" + pass;
    let ha1 = this._yapi.imm_bin2hexstr(this._yapi.imm_yMD5(ha1_str)).toLowerCase();
    let nonce8 = new Uint8Array([(nonce & 255) >>> 0, (nonce & 65280) >>> 8, (nonce & 16711680) >>> 16, nonce >>> 24]);
    let sha1_raw = ha1 + this._yapi.imm_bin2hexstr(nonce8).toLowerCase();
    return this._yapi.imm_ySHA1(sha1_raw.toLowerCase());
  }
  imm_isForwarded() {
    return this.fwd_connectionState == 5 && this.fwd_websocket !== null;
  }
  async _webSocketMsg(arr_bytes) {
    try {
      if (this.imm_isForwarded()) {
        this.lastPingStamp = Date.now();
        this.fwd_websocket.send(arr_bytes);
        return;
      }
      let reltime = (this._yapi.GetTickCount() - this._connectionTime) / 1e3;
      let ystream = arr_bytes[0] >>> 3;
      let text = "";
      if (ystream == 8) {
        for (let i = 1; i < arr_bytes.length; i++) {
          text += String.fromCharCode(arr_bytes[i]);
        }
        await this._yapi.parseEvents(this, text);
        return;
      }
      let ws = this.websocket;
      let tcpchan = arr_bytes[0] & 7;
      if (ystream == 1 || ystream == 2 || ystream == 9) {
        if (tcpchan > 3) {
          this.imm_asyncWebSocketError(YAPI_IO_ERROR, "Unexpected frame for tcpChan " + tcpchan + " (" + ystream + ")");
          return;
        }
        let tcp_end = arr_bytes.length;
        let yreq = this.tcpChan[tcpchan];
        if (!yreq) {
          this.imm_asyncWebSocketError(YAPI_IO_ERROR, "Drop frame for closed tcpChan " + tcpchan + " (" + ystream + ")");
          return;
        }
        if (ystream == 9) {
          tcp_end--;
          let rcvId = arr_bytes[tcp_end];
          if (this._yapi._logLevel >= 5) {
            this._yapi.imm_log("async-" + rcvId + " close received");
          }
          if (yreq.asyncId == 0) {
            if (this._yapi._logLevel >= 4) {
              this._yapi.imm_log("async-" + rcvId + " close received while req @" + yreq._creat + " was pending");
            }
            this.imm_asyncWebSocketError(YAPI_IO_ERROR, "Asynchronous close received, sync reply request");
            return;
          } else if (yreq.asyncId != rcvId) {
            if (this._yapi._logLevel >= 4) {
              this._yapi.imm_log("async-" + rcvId + " close received instead of async-" + yreq.asyncId + " close");
            }
            this.imm_asyncWebSocketError(YAPI_IO_ERROR, "Incorrect async-close signature on tcpChan " + tcpchan);
            return;
          }
        }
        let oldArr = yreq.bin_result;
        let newArr = new Uint8Array(oldArr.length + tcp_end - 1);
        newArr.set(oldArr, 0);
        newArr.set(arr_bytes.subarray(1, tcp_end), oldArr.length);
        yreq.bin_result = newArr;
        if (ystream == 2 || ystream == 9) {
          this.tcpChan[tcpchan] = yreq.next;
          if (ystream == 2) {
            if (yreq.asyncId != 0) {
              if (this._yapi._logLevel >= 4) {
                this._yapi.imm_log("Synchronous close received instead of async-" + yreq.asyncId + " close");
              }
              this.imm_asyncWebSocketError(YAPI_IO_ERROR, "Synchronous close received, async ack expected");
              return;
            } else if (this.websocket) {
              if (yreq.toBeSent && yreq.sendPos < yreq.toBeSent.length) {
                this._yapi.imm_log("WS: tcpclose at " + yreq.sendPos + " < " + yreq.toBeSent.length);
                this.imm_disconnectNow();
                if (yreq.timeoutId) {
                  clearTimeout(yreq.timeoutId);
                }
                if (yreq.asyncId == 0) {
                  yreq.errorType = YAPI_IO_ERROR;
                  yreq.errorMsg = "TCP closed during upload";
                  if (yreq.acceptor) {
                    try {
                      yreq.acceptor(yreq);
                    } catch (e) {
                    }
                  }
                }
                return;
              }
              if (yreq.timeoutId) {
                let frame = new Uint8Array(1);
                frame[0] = (2 << 3) + tcpchan;
                this.websocket.send(frame);
              }
            }
          }
          if (yreq.timeoutId) {
            clearTimeout(yreq.timeoutId);
            yreq.timeoutId = 0;
          }
          let pos = yreq.bin_result.indexOf(13);
          if (pos < 0) {
            yreq.errorType = YAPI_IO_ERROR;
            yreq.errorMsg = "Bad response header";
          } else {
            let header = this._yapi.imm_bin2str(yreq.bin_result.subarray(0, pos));
            let words = header.split(" ");
            if (words[0] == "OK") {
              yreq.errorType = YAPI_SUCCESS;
              let nextpos = yreq.bin_result.indexOf(13, pos + 2);
              while (nextpos > pos + 2) {
                pos = nextpos;
                nextpos = yreq.bin_result.indexOf(13, pos + 2);
              }
              if (nextpos < 0) {
                nextpos = pos;
              }
              yreq.bin_result = yreq.bin_result.subarray(nextpos + 2);
            } else if (words[0] == "0K") {
              yreq.errorType = YAPI_IO_ERROR;
              yreq.errorMsg = "Unexpected persistent connection";
            } else {
              let status = parseInt(words[1]);
              yreq.errorType = status == 401 ? YAPI_UNAUTHORIZED : YAPI_IO_ERROR;
              yreq.errorMsg = "HTTP error " + header.slice(words[0].length + 1) + " on " + yreq.devUrl;
            }
          }
          if (yreq.asyncId == 0) {
            if (this._yapi._logLevel >= 5) {
              this._yapi.imm_log("request @" + yreq._creat + " done, status=" + yreq.errorType);
            }
            this.imm_sendPendingRequest(tcpchan);
            if (yreq.acceptor) {
              yreq.acceptor(yreq);
            }
          } else {
            if (yreq.errorType != YAPI_SUCCESS) {
              this.imm_asyncWebSocketError(YAPI_IO_ERROR, "Async request error: " + yreq.errorMsg);
            }
          }
        }
        return;
      }
      if (!this.websocket) {
        return;
      }
      if (ystream == 5) {
        let metatype = arr_bytes[1];
        switch (metatype) {
          case 4:
            if (arr_bytes.length < 1 + this._USB_META_WS_ANNOUNCE_SIZE) {
              return;
            }
            this._remoteVersion = arr_bytes[2];
            if (this._remoteVersion < 1) {
              return;
            }
            let maxtcpws = (arr_bytes[3] << 4) + (arr_bytes[4] << 12);
            if (maxtcpws > 0) {
              this._tcpMaxWindowSize = maxtcpws;
            }
            this._remoteNonce = arr_bytes[5] + (arr_bytes[6] << 8) + (arr_bytes[7] << 16) + (arr_bytes[8] << 24);
            for (let i = 9; i < 9 + 20; i++) {
              if (arr_bytes[i] == 0) {
                this._remoteSerial = this._yapi.imm_bin2str(arr_bytes.subarray(9, i));
                break;
              }
            }
            let nonce = new Uint8Array(4);
            this.imm_getRandomValues(nonce);
            this._nonce = nonce[0] + (nonce[1] << 8) + (nonce[2] << 16) + (nonce[3] << 24);
            this._connectionTime = this._yapi.GetTickCount();
            this._connectionState = 3;
            let frame = new Uint8Array(1 + this._USB_META_WS_AUTHENTICATION_SIZE);
            let version = this._remoteVersion < 2 ? this._remoteVersion : 2;
            let flags = 0;
            frame[0] = 5 << 3;
            frame[1] = 5;
            frame[2] = version;
            if (this.urlInfo.pass != "") {
              flags = this._USB_META_WS_VALID_SHA1;
              let sha1 = this.imm_computeAuth(this.urlInfo.user, this.urlInfo.pass, this._remoteSerial, this._remoteNonce);
              for (let i = 0; i < sha1.length; i++) {
                frame[9 + i] = sha1[i];
              }
            }
            frame[3] = flags & 255;
            frame[4] = flags >>> 8;
            frame[5] = this._nonce & 255;
            frame[6] = this._nonce >>> 8 & 255;
            frame[7] = this._nonce >>> 16 & 255;
            frame[8] = this._nonce >>> 24 & 255;
            this.websocket.send(frame);
            break;
          case 5:
            if (this._connectionState != 3) {
              return;
            }
            if (arr_bytes.length < 1 + this._USB_META_WS_AUTHENTICATION_SIZE) {
              return;
            }
            this._tcpRoundTripTime = this._yapi.GetTickCount() - this._connectionTime + 1;
            if (this._tcpMaxWindowSize < 2048 && this._tcpRoundTripTime < 7) {
              this._tcpRoundTripTime = 7;
            }
            let uploadRate = this._tcpMaxWindowSize * 1e3 / this._tcpRoundTripTime >> 0;
            if (this._yapi._logLevel >= 4) {
              this._yapi.imm_log("RTT=" + this._tcpRoundTripTime + "ms, WS=" + this._tcpMaxWindowSize + ", uploadRate=" + uploadRate / 1e3 + " KB/s");
            }
            this._remoteVersion = arr_bytes[2];
            if (this._remoteVersion < 1) {
              return;
            }
            let inflags = arr_bytes[3] + (arr_bytes[4] << 8);
            if ((inflags & this._USB_META_WS_RW) != 0) {
              this._rwAccess = true;
            } else {
              this._rwAccess = false;
            }
            if ((inflags & this._USB_META_WS_VALID_SHA1) != 0) {
              let remote_sha1 = arr_bytes.subarray(9, 29);
              let sha1 = this.imm_computeAuth(this.urlInfo.user, this.urlInfo.pass, this._remoteSerial, this._nonce);
              for (let i = 0; i < sha1.length; i++) {
                if (sha1[i] != remote_sha1[i]) {
                  this._session_errno = 401;
                  this._session_error = "Authentication failed";
                  this._connectionState = 0;
                  return;
                }
              }
              this._connectionState = 4;
            } else {
              if (this.urlInfo.pass == "") {
                this._connectionState = 4;
              } else {
                this._session_errno = 401;
                if (this.urlInfo.user == "admin" && !this._rwAccess) {
                  this._session_error = "Authentication as admin failed";
                } else {
                  this._session_error = "Password not set on remote hub";
                }
                this._connectionState = 0;
                return;
              }
            }
            break;
          case 6:
            this._session_errno = arr_bytes[3] + (arr_bytes[4] << 8);
            if (this._session_errno == 401) {
              this._session_error = "Authentication failed";
            } else {
              this._session_error = "Remote hub closed connection with error " + this._session_errno;
            }
            this._connectionState = 0;
            break;
          case 7:
            tcpchan = arr_bytes[2];
            if (this.tcpChan[tcpchan]) {
              let yreq = this.tcpChan[tcpchan];
              let ackBytes = arr_bytes[3] + (arr_bytes[4] << 8) + (arr_bytes[5] << 16) + (arr_bytes[6] << 24);
              let ackTime = this._yapi.GetTickCount();
              if (this._lastUploadAckTime[tcpchan] != 0 && ackBytes > this._lastUploadAckBytes[tcpchan]) {
                this._lastUploadAckBytes[tcpchan] = ackBytes;
                this._lastUploadAckTime[tcpchan] = ackTime;
                let deltaBytes = ackBytes - this._lastUploadRateBytes[tcpchan];
                let deltaTime = ackTime - this._lastUploadRateTime[tcpchan];
                if (deltaTime < 500)
                  break;
                if (deltaTime < 1e3 && deltaBytes < 65536)
                  break;
                this._lastUploadRateBytes[tcpchan] = ackBytes;
                this._lastUploadRateTime[tcpchan] = ackTime;
                if (yreq.progressCb && yreq.toBeSent) {
                  yreq.progressCb(ackBytes, yreq.toBeSent.length);
                }
                let newRate = deltaBytes * 1e3 / deltaTime;
                this._uploadRate[tcpchan] = 0.8 * this._uploadRate[tcpchan] + 0.3 * newRate >> 0;
                if (this._yapi._logLevel >= 5) {
                  this._yapi.imm_log("New rate: " + this._uploadRate[tcpchan] / 1e3 + " KB/s (last " + (deltaBytes / 1e3 >> 0) + "KB sent at " + (newRate >> 0) / 1e3 + " KB/s)");
                }
              } else {
                this._lastUploadAckBytes[tcpchan] = ackBytes;
                this._lastUploadAckTime[tcpchan] = ackTime;
                this._lastUploadRateBytes[tcpchan] = ackBytes;
                this._lastUploadRateTime[tcpchan] = ackTime;
                if (yreq.progressCb && yreq.toBeSent) {
                  yreq.progressCb(ackBytes, yreq.toBeSent.length);
                }
                this.imm_sendPendingRequest(tcpchan);
              }
            }
            break;
        }
        return;
      }
      this.imm_asyncWebSocketError(YAPI_IO_ERROR, "Unsupported message: " + this._yapi.imm_bin2hexstr(arr_bytes));
    } catch (e) {
      this._yapi.imm_log("Unhandled exception in _webSocketMsg:", e);
    }
  }
  imm_webSocketSend(arr_bytes) {
    if (this.websocket) {
      this.websocket.send(arr_bytes);
    }
  }
  async request(method, devUrl, obj_body, tcpchan) {
    if (this._yapi._logLevel >= 3) {
      this.imm_logrequest(method, devUrl, obj_body);
    }
    let httpPromise = new Promise((resolve, reject) => {
      let subReq = method + " " + devUrl + " \r\n\r\n";
      let ws = this.websocket;
      let isAsync = this._remoteVersion > 0 && devUrl.slice(-2) == "&.";
      let yreq = new YHTTPRequest(new Uint8Array(0));
      if (this._yapi._logLevel >= 5) {
        yreq._creat = (Date.now() % 6e5).toString();
        this._yapi.imm_log("request @" + yreq._creat + ": " + method + " " + devUrl);
      }
      yreq.acceptor = resolve;
      yreq.devUrl = devUrl;
      yreq.sendPos = 0;
      if (obj_body) {
        let boundary = this.imm_getBoundary();
        let body = this.imm_formEncodeBody(obj_body, boundary);
        subReq = subReq.slice(0, -2) + "Content-Type: x-upload, boundary=" + boundary + "\r\n\r\n";
        yreq.toBeSent = new Uint8Array(subReq.length + body.length);
        yreq.toBeSent.set(body, subReq.length);
        yreq.progressCb = obj_body.progressCb;
      } else {
        yreq.toBeSent = new Uint8Array(subReq.length);
      }
      for (let i = 0; i < subReq.length; i++) {
        yreq.toBeSent[i] = subReq.charCodeAt(i);
      }
      if (tcpchan > 3) {
        yreq.errorType = YAPI_IO_ERROR;
        yreq.errorMsg = "Unsupported tcpChan " + tcpchan;
        try {
          yreq.acceptor(yreq);
        } catch (e) {
        }
        return;
      }
      if (!ws || this.imm_isDisconnecting() || this._connectionState != 5) {
        if (this._yapi._logLevel >= 4) {
          let wsState = ws ? " websocket=NULL" : "";
          let dsState = this.imm_isDisconnecting() ? " disconnecting" : "";
          let cnState = this._connectionState != 5 ? " connState=" + this._connectionState : "";
          this._yapi.imm_log("request @" + yreq._creat + " failed, websocket is down:" + wsState + dsState + cnState);
        }
        yreq.errorType = YAPI_IO_ERROR;
        yreq.errorMsg = "WebSocket not connected";
        try {
          yreq.acceptor(yreq);
        } catch (e) {
        }
        return;
      }
      if (isAsync) {
        yreq.asyncId = this.nextAsyncId++;
        if (this.nextAsyncId >= 127) {
          this.nextAsyncId = 48;
        }
      }
      let queue = this.tcpChan[tcpchan];
      if (queue) {
        while (queue.next) {
          queue = queue.next;
        }
        queue.next = yreq;
      } else {
        this.tcpChan[tcpchan] = yreq;
      }
      this.imm_sendPendingRequest(tcpchan);
    });
    return httpPromise;
  }
  imm_sendPendingRequest(tcpchan) {
    let yreq = this.tcpChan[tcpchan];
    while (yreq) {
      if (!this.websocket || this.imm_isDisconnecting() || this._connectionState != 5) {
        if (this._yapi._logLevel >= 4) {
          this._yapi.imm_log("request @" + yreq._creat + " failed, websocket is down");
        }
        yreq.errorType = YAPI_IO_ERROR;
        yreq.errorMsg = "WebSocket not connected";
        if (yreq.acceptor) {
          try {
            yreq.acceptor(yreq);
          } catch (e) {
          }
        }
        yreq = yreq.next;
        continue;
      }
      let pendingCount = 1;
      for (let yr = yreq; yr.next; yr = yr.next) {
        pendingCount++;
      }
      if (!yreq.toBeSent) {
        if (yreq.asyncId == 0) {
          if (this._yapi._logLevel >= 5) {
            this._yapi.imm_log(pendingCount.toString() + " req pending, @" + yreq._creat + " not completed");
          }
          return;
        }
        yreq = yreq.next;
        continue;
      }
      let isAsync = yreq.asyncId != 0;
      let asyncCloseSet = false;
      let pos = yreq.sendPos;
      let end = yreq.toBeSent.length;
      let i, frame;
      if (end > 2108 && this._remoteVersion >= 2 && tcpchan == 0) {
        if (pos == 0) {
          end = 2108;
          this._lastUploadAckBytes[tcpchan] = 0;
          this._lastUploadAckTime[tcpchan] = 0;
          this._uploadRate[tcpchan] = this._tcpMaxWindowSize * 1e3 / this._tcpRoundTripTime >> 0;
        } else if (this._lastUploadAckTime[tcpchan] == 0) {
          if (yreq.sendTimeoutId)
            clearTimeout(yreq.sendTimeoutId);
          yreq.sendTimeoutId = setTimeout(() => {
            this.imm_sendPendingRequest(tcpchan);
          }, this._tcpRoundTripTime);
          return;
        } else {
          let bytesOnTheAir = pos - this._lastUploadAckBytes[tcpchan];
          let uploadRate = this._uploadRate[tcpchan];
          let timeOnTheAir = this._yapi.GetTickCount() - this._lastUploadAckTime[tcpchan];
          let toBeSent = 2 * uploadRate + 1024 - bytesOnTheAir + uploadRate * timeOnTheAir / 1e3 >> 0;
          if (toBeSent + bytesOnTheAir > this._DEFAULT_TCP_MAX_WINDOW_SIZE) {
            toBeSent = this._DEFAULT_TCP_MAX_WINDOW_SIZE - bytesOnTheAir;
          }
          if (toBeSent < 64) {
            let waitTime = 1e3 * (128 - toBeSent) / uploadRate >> 0;
            if (waitTime < 2)
              waitTime = 2;
            if (yreq.sendTimeoutId)
              clearTimeout(yreq.sendTimeoutId);
            yreq.sendTimeoutId = setTimeout(() => {
              this.imm_sendPendingRequest(tcpchan);
            }, waitTime);
            return;
          }
          if (end > pos + toBeSent) {
            if (toBeSent > 124) {
              toBeSent = (toBeSent / 124 >> 0) * 124;
            }
            end = pos + toBeSent;
          }
        }
      }
      while (pos < end) {
        let framelen = 1 + end - pos;
        if (framelen > 125)
          framelen = 125;
        let datalen = framelen - 1;
        if (isAsync && pos + datalen == yreq.toBeSent.length && framelen < 125) {
          frame = new Uint8Array(framelen + 1);
          frame[0] = 8 * 9 + tcpchan;
          frame[framelen] = yreq.asyncId;
          asyncCloseSet = true;
        } else {
          frame = new Uint8Array(framelen);
          frame[0] = 8 * 1 + tcpchan;
        }
        frame.set(yreq.toBeSent.subarray(pos, pos + datalen), 1);
        pos += datalen;
        this.imm_webSocketSend(frame);
      }
      let sent = pos - yreq.sendPos;
      yreq.sendPos = pos;
      if (yreq.sendPos < yreq.toBeSent.length) {
        let waitTime = 1e3 * sent / this._uploadRate[tcpchan] >> 0;
        if (waitTime < 2)
          waitTime = 2;
        if (yreq.sendTimeoutId)
          clearTimeout(yreq.sendTimeoutId);
        yreq.sendTimeoutId = setTimeout(() => {
          this.imm_sendPendingRequest(tcpchan);
        }, waitTime);
        return;
      }
      if (isAsync && !asyncCloseSet) {
        frame = new Uint8Array(2);
        frame[0] = 8 * 9 + tcpchan;
        frame[1] = yreq.asyncId;
        this.imm_webSocketSend(frame);
      }
      yreq.toBeSent = null;
      if (isAsync && yreq.acceptor) {
        try {
          yreq.acceptor(yreq);
        } catch (e) {
          this._yapi.imm_log("WS: async acceptor exception: ", e);
        }
      }
      let mstimeout = this._yapi._networkTimeoutMs;
      if (yreq.devUrl) {
        if (yreq.devUrl.indexOf("/testcb.txt") >= 0) {
          mstimeout = this._YIO_1_MINUTE_TCP_TIMEOUT;
        } else if (yreq.devUrl.indexOf("/logger.json") >= 0) {
          mstimeout = this._YIO_1_MINUTE_TCP_TIMEOUT;
        } else if (yreq.devUrl.indexOf("/rxmsg.json") >= 0) {
          mstimeout = this._YIO_1_MINUTE_TCP_TIMEOUT;
        } else if (yreq.devUrl.indexOf("/rxdata.bin") >= 0) {
          mstimeout = this._YIO_1_MINUTE_TCP_TIMEOUT;
        } else if (yreq.devUrl.indexOf("/at.txt") >= 0) {
          mstimeout = this._YIO_1_MINUTE_TCP_TIMEOUT;
        } else if (yreq.devUrl.indexOf("/files.json") >= 0) {
          mstimeout = this._YIO_1_MINUTE_TCP_TIMEOUT;
        } else if (yreq.devUrl.indexOf("/upload.html") >= 0) {
          mstimeout = this._YIO_10_MINUTES_TCP_TIMEOUT;
        } else if (yreq.devUrl.indexOf("/flash.json") >= 0) {
          mstimeout = this._YIO_10_MINUTES_TCP_TIMEOUT;
        } else if (yreq.devUrl.indexOf("/Yvw4I.js") >= 0) {
          mstimeout = this._YIO_10_MINUTES_TCP_TIMEOUT;
        }
      }
      yreq.timeoutId = setTimeout((chan, yr) => {
        this.imm_abortRequest(chan, yr);
      }, mstimeout, tcpchan, yreq);
      yreq._sent = (Date.now() % 6e5).toString();
      if (this._yapi._logLevel >= 5) {
        this._yapi.imm_log("req @" + yreq._creat + " sent (1/" + pendingCount.toString() + ")" + (isAsync ? " async-" + yreq.asyncId + ", continue" : ", waiting for reply"));
      }
      if (!isAsync) {
        return;
      }
      yreq = yreq.next;
    }
  }
  imm_abortRequest(tcpchan, yreq) {
    if (!yreq.timeoutId)
      return;
    yreq.timeoutId = null;
    if (yreq.asyncId == 0) {
      let frame = new Uint8Array(1);
      frame[0] = 8 * 2 + tcpchan;
      this.imm_webSocketSend(frame);
      if (this._yapi._logLevel >= 4) {
        let pendingCount = 1;
        for (let yr = yreq; yr.next; yr = yr.next) {
          pendingCount++;
        }
        this._yapi.imm_log(pendingCount.toString() + " req pending, @" + yreq._creat + " is in timeout");
      }
      setTimeout((chan, yr) => {
        this._yapi.imm_log("Dropping synchronous request after timeout: " + yr.devUrl);
        this.imm_forgetRequest(chan, yr);
      }, 5e3, tcpchan, yreq);
    }
    this.imm_asyncWebSocketError(YAPI_IO_ERROR, "Timeout on " + yreq.devUrl + " (tcpchan " + tcpchan + ")");
  }
  imm_forgetRequest(tcpchan, yreq) {
    let queue = this.tcpChan[tcpchan];
    if (queue == yreq) {
      this.tcpChan[tcpchan] = yreq.next;
      if (yreq.asyncId == 0) {
        yreq.errorType = YAPI_IO_ERROR;
        yreq.errorMsg = "Timeout on " + yreq.devUrl + " (tcpchan " + tcpchan + ")";
        if (yreq.acceptor) {
          try {
            yreq.acceptor(yreq);
          } catch (e) {
          }
        }
      }
      this.imm_sendPendingRequest(tcpchan);
    }
  }
  imm_dropAllPendingConnection() {
    if (this.fwd_connectionState != 1 && this.fwd_websocket) {
      this.fwd_connectionState = 1;
      this.fwd_websocket.close();
      this.fwd_websocket = null;
    }
    for (let tcpchan = 0; tcpchan < this.tcpChan.length; tcpchan++) {
      for (let yreq = this.tcpChan[tcpchan]; yreq; yreq = yreq.next) {
        this.tcpChan[tcpchan] = yreq.next;
        if (yreq.timeoutId) {
          clearTimeout(yreq.timeoutId);
          yreq.timeoutId = 0;
        }
        if (yreq.asyncId == 0) {
          if (this._yapi._logLevel >= 4) {
            this._yapi.imm_log("drop @" + yreq._creat + " (websocket down)");
          }
          yreq.errorType = YAPI_IO_ERROR;
          yreq.errorMsg = "Request " + yreq.devUrl + " dropped (websocket down)";
          if (yreq.acceptor) {
            try {
              yreq.acceptor(yreq);
            } catch (e) {
            }
          }
        }
      }
    }
  }
  async websocketJoin(ws, arr_credentials, close_callback) {
    if (this._connectionState != 5) {
      this.imm_asyncWebSocketError(YAPI_IO_ERROR, "Hub is disconnected, cannot join");
      return false;
    }
    this.fwd_websocket = ws;
    this.fwd_credentials = arr_credentials;
    this.fwd_closeCallback = close_callback;
    this.fwd_connectionState = 2;
    ws.onmessage = (evt) => {
      if (this.fwd_connectionState == 5) {
        if (this._connectionState == 5) {
          this.imm_webSocketSend(evt.data);
        } else {
          this._yapi.imm_log("WS: drop packet from fwd API (state=" + this._connectionState + ")");
        }
      } else if (this.fwd_connectionState == 3) {
        this.imm_handleAPIAuthPkt(evt.data);
      } else {
        this._yapi.imm_log("WS: drop packet from fwd API (fwd_state=" + this.fwd_connectionState + ")");
      }
    };
    ws.onclose = (evt) => {
      this.fwd_connectionState = 1;
      this.fwd_websocket = null;
      if (this.fwd_closeCallback) {
        this.fwd_closeCallback();
      }
    };
    return this.imm_sendAPIAnnouncePkt();
  }
  imm_sendAPIAnnouncePkt() {
    if (!this.fwd_websocket) {
      return false;
    }
    let frame = new Uint8Array(1 + this._USB_META_WS_ANNOUNCE_SIZE);
    let nonce = new Uint8Array(4);
    this.imm_getRandomValues(nonce);
    frame[0] = 5 << 3;
    frame[1] = 4;
    frame[2] = 2;
    frame[3] = this._tcpMaxWindowSize >> 4 & 255;
    frame[4] = this._tcpMaxWindowSize >> 12 & 255;
    for (let i = 0; i < 4; i++) {
      frame[5 + i] = nonce[i];
    }
    for (let i = 0; i < this._remoteSerial.length && i < 20; i++) {
      frame[9 + i] = this._remoteSerial.charCodeAt(i);
    }
    this.fwd_nonce = frame[5] + (frame[6] << 8) + (frame[7] << 16) + (frame[8] << 24);
    this.fwd_connectionState = 3;
    this.fwd_websocket.send(frame);
    return true;
  }
  imm_handleAPIAuthPkt(msg) {
    if (msg.length < 1 + this._USB_META_WS_AUTHENTICATION_SIZE || msg[0] != 5 << 3) {
      this._yapi.imm_log("bad-apiauth1\n");
      this.fwd_connectionState = 0;
      return;
    }
    if (msg[1] != 5 || msg[2] > 2) {
      this._yapi.imm_log("bad-apiauth2\n");
      this.fwd_connectionState = 0;
      return;
    }
    this._remoteVersion = msg[2];
    let flags = msg[3] + (msg[4] << 8);
    if ((flags & this._USB_META_WS_VALID_SHA1) == 0) {
      this._yapi.imm_log("bad-apiauth3\n");
      this.fwd_connectionState = 0;
      return;
    }
    if (!this.fwd_websocket) {
      this._yapi.imm_log("no-fwd-ws\n");
      this.fwd_connectionState = 0;
      return;
    }
    let credIdx, remote_sha1 = msg.subarray(9, 29);
    let credentials = this.fwd_credentials;
    for (credIdx = 0; credIdx < credentials.length; credIdx++) {
      let j, sha12 = this.imm_computeAuth(credentials[credIdx].user, credentials[credIdx].pass, this._remoteSerial, this.fwd_nonce);
      for (j = 0; j < sha12.length; j++) {
        if (sha12[j] != remote_sha1[j])
          break;
      }
      if (j >= sha12.length)
        break;
    }
    if (credIdx >= credentials.length) {
      this._yapi.imm_log("bad-apiauth4\n");
      msg.fill(0, 3);
      this.fwd_websocket.send(msg);
      this.fwd_connectionState = 0;
      return;
    }
    msg[3] |= this._USB_META_WS_RW;
    this.fwd_nonce = msg[5] + (msg[6] << 8) + (msg[7] << 16) + (msg[8] << 24);
    let sha1 = this.imm_computeAuth(credentials[credIdx].user, credentials[credIdx].pass, this._remoteSerial, this.fwd_nonce);
    for (let i = 0; i < sha1.length; i++) {
      msg[9 + i] = sha1[i];
    }
    this.fwd_websocket.send(msg);
    this.fwd_connectionState = 5;
  }
  async detach(errType = YAPI.IO_ERROR, errMsg = "Hub has been forcibly detached") {
    let tcpchan_busy;
    let timeout = this._yapi.GetTickCount() + 3e3;
    do {
      tcpchan_busy = false;
      for (let tcpchan = 0; tcpchan < 4; tcpchan++) {
        if (this.tcpChan[tcpchan] != null) {
          tcpchan_busy = true;
          break;
        }
      }
      if (tcpchan_busy) {
        await this._yapi._microSleep_internal();
      }
    } while (tcpchan_busy && timeout > this._yapi.GetTickCount());
    this.imm_commonDisconnect("detach", errType, errMsg);
    this.imm_disconnectNow();
  }
  imm_disconnectNow(connID = "") {
    if (!super.imm_disconnectNow(connID)) {
      return false;
    }
    if (!this.websocket) {
      return false;
    }
    this._connectionState = 1;
    let prevOpenID = connID ? connID : this.currentConnID;
    let websocket = this.websocket;
    this.currentConnID = "";
    this.websocket = null;
    websocket.onclose = null;
    websocket.onerror = null;
    try {
      websocket.close();
    } catch (e) {
    }
    if (websocket.terminate) {
      setTimeout(() => {
        try {
          if (websocket.terminate) {
            websocket.terminate();
          }
        } catch (e) {
        }
      }, 900);
    }
    this.imm_dropAllPendingConnection();
    this.imm_signalHubDisconnected(prevOpenID);
    return true;
  }
  imm_isOnline() {
    if (this._connectionState != 5) {
      return false;
    }
    return super.imm_isOnline();
  }
};
var YHub = class {
  constructor(obj_yapi, hubref) {
    this._hubref = 0;
    this._ctx = obj_yapi;
    this._hubref = hubref;
  }
  async _getStrAttr_internal(attrName) {
    let hub = this._ctx.getGenHub(this._hubref);
    if (hub == null) {
      return "";
    }
    switch (attrName) {
      case "registeredUrl":
        return hub.urlInfo.orgUrl;
      case "connectionUrl":
        return hub.urlInfo.rootUrl;
      case "serialNumber":
        return hub.hubSerial;
      case "errorMessage":
        return hub.get_errorMessage();
      default:
        return "";
    }
  }
  async _getIntAttr_internal(attrName) {
    let hub = this._ctx.getGenHub(this._hubref);
    if (attrName == "isInUse") {
      return hub != null ? 1 : 0;
    }
    if (hub == null) {
      return -1;
    }
    switch (attrName) {
      case "isOnline":
        return hub.imm_isOnline() ? 1 : 0;
      case "isReadOnly":
        return await hub.hasRwAccess() ? 0 : 1;
      case "networkTimeout":
        return hub.stalledTimeoutMs;
      case "errorType":
        return hub.get_errorType();
      default:
        return -1;
    }
  }
  async _setIntAttr_internal(attrName, value) {
    let hub = this._ctx.getGenHub(this._hubref);
    if (hub != null && attrName == "networkTimeout") {
      hub.stalledTimeoutMs = value;
    }
  }
  get_knownUrls_internal() {
    let hub = this._ctx.getGenHub(this._hubref);
    if (hub != null) {
      return hub.get_knownUrls();
    }
    return [];
  }
  async _getStrAttr(attrName) {
    return await this._getStrAttr_internal(attrName);
  }
  async _getIntAttr(attrName) {
    return await this._getIntAttr_internal(attrName);
  }
  async _setIntAttr(attrName, value) {
    return await this._setIntAttr_internal(attrName, value);
  }
  async get_registeredUrl() {
    return await this._getStrAttr("registeredUrl");
  }
  async get_knownUrls() {
    return await this.get_knownUrls_internal();
  }
  async get_connectionUrl() {
    return await this._getStrAttr("connectionUrl");
  }
  async get_serialNumber() {
    return await this._getStrAttr("serialNumber");
  }
  async isInUse() {
    return await this._getIntAttr("isInUse") > 0;
  }
  async isOnline() {
    return await this._getIntAttr("isOnline") > 0;
  }
  async isReadOnly() {
    return await this._getIntAttr("isReadOnly") > 0;
  }
  async set_networkTimeout(networkMsTimeout) {
    await this._setIntAttr("networkTimeout", networkMsTimeout);
  }
  async get_networkTimeout() {
    return await this._getIntAttr("networkTimeout");
  }
  async get_errorType() {
    return await this._getIntAttr("errorType");
  }
  async get_errorMessage() {
    return await this._getStrAttr("errorMessage");
  }
  async get_userData() {
    return this._userData;
  }
  async set_userData(data) {
    this._userData = data;
  }
  static FirstHubInUse() {
    return YAPI.nextHubInUseInternal(-1);
  }
  static FirstHubInUseInContext(yctx) {
    return yctx.nextHubInUseInternal(-1);
  }
  nextHubInUse() {
    return this._ctx.nextHubInUseInternal(this._hubref);
  }
};
var YAPIContext = class {
  constructor(system_env) {
    this._detectType = Y_DETECT_NONE;
    this._knownHubsBySerial = {};
    this._knownHubsByUrl = {};
    this._connectedHubs = [];
    this._yhub_cache = {};
    this._ssdpManager = null;
    this._devs = {};
    this._snByUrl = {};
    this._snByName = {};
    this._fnByType = {};
    this._lastErrorType = YAPI_SUCCESS;
    this._lastErrorMsg = "no error";
    this._updateDevListStarted = 0;
    this._pendingCallbacks = [];
    this._logLevel = 2;
    this._logCallback = null;
    this._arrivalCallback = null;
    this._namechgCallback = null;
    this._removalCallback = null;
    this._hubDiscoveryCallback = null;
    this._forwardValues = 0;
    this._calibHandlers = [];
    this._ValueCallbackList = [];
    this._TimedReportCallbackList = [];
    this._beacons = {};
    this._isNodeJS = false;
    this._networkTimeoutMs = DEFAULT_NETWORK_TIMEOUT_MS;
    this._deviceListValidityMs = DEFAULT_DEVICE_LIST_VALIDITY_MS;
    this.defaultEncoding = "binary";
    this.exceptionsDisabled = false;
    this.SUCCESS = 0;
    this.NOT_INITIALIZED = -1;
    this.INVALID_ARGUMENT = -2;
    this.NOT_SUPPORTED = -3;
    this.DEVICE_NOT_FOUND = -4;
    this.VERSION_MISMATCH = -5;
    this.DEVICE_BUSY = -6;
    this.TIMEOUT = -7;
    this.IO_ERROR = -8;
    this.NO_MORE_DATA = -9;
    this.EXHAUSTED = -10;
    this.DOUBLE_ACCES = -11;
    this.UNAUTHORIZED = -12;
    this.RTC_NOT_READY = -13;
    this.FILE_NOT_FOUND = -14;
    this.SSL_ERROR = -15;
    this.RFID_SOFT_ERROR = -16;
    this.RFID_HARD_ERROR = -17;
    this.BUFFER_TOO_SMALL = -18;
    this.defaultCacheValidity = 5;
    this.INVALID_INT = YAPI_INVALID_INT;
    this.INVALID_UINT = YAPI_INVALID_UINT;
    this.INVALID_LONG = YAPI_INVALID_LONG;
    this.INVALID_DOUBLE = YAPI_INVALID_DOUBLE;
    this.MIN_DOUBLE = YAPI_MIN_DOUBLE;
    this.MAX_DOUBLE = YAPI_MAX_DOUBLE;
    this.INVALID_STRING = YAPI_INVALID_STRING;
    this.HASH_BUF_SIZE = YOCTO_HASH_BUF_SIZE;
    this.DETECT_NONE = Y_DETECT_NONE;
    this.DETECT_USB = Y_DETECT_USB;
    this.DETECT_NET = Y_DETECT_NET;
    this.DETECT_ALL = Y_DETECT_ALL;
    this.system_env = system_env || YAPI && YAPI.system_env || _UnspecifiedSystemEnv;
    this._isNodeJS = this.system_env.isNodeJS;
    this._uniqueID = String.fromCharCode(Math.random() * 79 + 48, Math.random() * 79 + 48, Math.random() * 79 + 48);
    this.imm_ResetToDefaults();
  }
  imm_ResetToDefaults() {
    this._detectType = this.DETECT_NONE;
    this._knownHubsBySerial = {};
    this._knownHubsByUrl = {};
    this._connectedHubs = [];
    this._devs = {};
    this._snByUrl = {};
    this._snByName = {};
    this._fnByType = {};
    this._fnByType.Module = new YFunctionType(this, "Module");
    this._lastErrorType = YAPI_SUCCESS;
    this._lastErrorMsg = "no error";
    this._updateDevListStarted = 0;
    this._pendingCallbacks = [];
    this._logLevel = 2;
    this._logCallback = null;
    this._arrivalCallback = null;
    this._namechgCallback = null;
    this._removalCallback = null;
    this._hubDiscoveryCallback = null;
    this._forwardValues = 0;
    this._ValueCallbackList = [];
    this._TimedReportCallbackList = [];
    this._beacons = {};
    this._calibHandlers = [];
    for (let i = 1; i <= 20; i++) {
      this.RegisterCalibrationHandler(i, this.LinearCalibrationHandler);
    }
    this.RegisterCalibrationHandler(YOCTO_CALIB_TYPE_OFS, this.LinearCalibrationHandler);
    this.exceptionsDisabled = false;
  }
  _throw(int_errType, str_errMsg, obj_retVal) {
    this._lastErrorType = int_errType;
    this._lastErrorMsg = str_errMsg;
    if (!this.exceptionsDisabled) {
      let exc = new YoctoError(str_errMsg);
      exc.errorType = int_errType;
      throw exc;
    }
    return obj_retVal;
  }
  imm_setErr(errmsg, int_errType, str_errMsg, obj_retVal) {
    if (errmsg) {
      errmsg.msg = str_errMsg;
    }
    this._lastErrorType = int_errType;
    this._lastErrorMsg = str_errMsg;
    return obj_retVal;
  }
  imm_setSystemEnv(env) {
    this.system_env = env;
    this._isNodeJS = env.isNodeJS;
  }
  imm_log(msg, ...moreArgs) {
    let now = new Date();
    let day = now.getFullYear().toString() + "-" + ("0" + (now.getMonth() + 1)).slice(-2) + "-" + ("0" + now.getDate()).slice(-2);
    let time = ("0" + now.getHours().toString()).slice(-2) + ":" + ("0" + now.getMinutes()).slice(-2) + ":" + ("0" + now.getSeconds()).slice(-2);
    let prefix = day + " " + time + " [" + this._uniqueID + "] ";
    let isError = false;
    if (moreArgs.length > 0) {
      if (moreArgs[0].constructor && /Error/i.test(moreArgs[0].constructor.name)) {
        isError = true;
      }
    }
    if (this._logCallback) {
      try {
        if (moreArgs.length > 0) {
          if (moreArgs[0].message) {
            msg += moreArgs[0].message;
          } else {
            msg += moreArgs[0].toString();
          }
        }
        this._logCallback(prefix + msg);
      } catch (e) {
        console.error(prefix + "Exception in custom log callback: ", e);
        console.log("... while trying to log:");
        if (isError) {
          console.error(prefix + msg, ...moreArgs);
        } else {
          console.log(prefix + msg, ...moreArgs);
        }
      }
    } else {
      if (isError) {
        console.error(prefix + msg, ...moreArgs);
      } else {
        console.log(prefix + msg, ...moreArgs);
      }
    }
  }
  async RegisterLogFunction(logfun) {
    this._logCallback = logfun;
    return YAPI_SUCCESS;
  }
  imm_getHub(obj_urlInfo) {
    return this._knownHubsByUrl[obj_urlInfo.rootUrl];
  }
  imm_getPrimaryHub(hub) {
    let primaryHub = this._knownHubsBySerial[hub.hubSerial];
    if (!primaryHub || primaryHub === hub) {
      this._knownHubsBySerial[hub.hubSerial] = hub;
      this._knownHubsByUrl[hub.urlInfo.rootUrl] = hub;
      return hub;
    }
    if (primaryHub._currentState >= hub._currentState) {
      primaryHub.imm_inheritFrom(hub);
      return primaryHub;
    }
    this._knownHubsBySerial[hub.hubSerial] = hub;
    hub.imm_inheritFrom(primaryHub);
    return hub;
  }
  async _addConnectedHub(newhub) {
    let serial = this._snByUrl[newhub.urlInfo.rootUrl];
    if (!serial) {
      let newdev = new YDevice(this, newhub.urlInfo.rootUrl, null, null);
      await newdev.refresh();
    }
    let hubFound = false;
    for (let i = 0; i < this._connectedHubs.length; i++) {
      let url = this._connectedHubs[i].urlInfo.rootUrl;
      if (newhub.urlInfo.rootUrl == url) {
        hubFound = true;
        break;
      }
    }
    if (!hubFound) {
      this._connectedHubs.push(newhub);
    }
  }
  imm_isActiveHub(hubSerial) {
    for (let i = 0; i < this._connectedHubs.length; i++) {
      let hubSerials = this._connectedHubs[i].serialByYdx;
      if (hubSerials && hubSerials[0] == hubSerial) {
        return true;
      }
    }
    return false;
  }
  imm_dropConnectedHub(hub) {
    let idx = this._connectedHubs.indexOf(hub);
    if (idx < 0) {
      return;
    }
    for (let j = 0; j < hub.serialByYdx.length; j++) {
      let serial = hub.serialByYdx[j];
      if (serial && this._devs[serial]) {
        if (this._removalCallback) {
          let module = YModule.FindModuleInContext(this, serial + ".module");
          this._pendingCallbacks.push({event: "-", serial, module});
        }
        try {
          this.imm_forgetDevice(this._devs[serial]);
        } catch (e) {
        }
      }
    }
    idx = this._connectedHubs.indexOf(hub);
    if (idx >= 0) {
      this._connectedHubs.splice(idx, 1);
    }
  }
  async _ensureUpdateDeviceListNotRunning() {
    while (this._updateDevListStarted && this.GetTickCount() - this._updateDevListStarted < 30 * 1e3) {
      await this.Sleep(25);
    }
  }
  async _updateDeviceList_internal(bool_forceupdate, bool_invokecallbacks) {
    if (this._updateDevListStarted && this.GetTickCount() - this._updateDevListStarted < 30 * 1e3) {
      return {
        errorType: YAPI_SUCCESS,
        errorMsg: "no error"
      };
    }
    for (let i = 0; i < this._connectedHubs.length; i++) {
      if (this._connectedHubs[i]._firstArrivalCallback && bool_invokecallbacks && this._arrivalCallback) {
        bool_forceupdate = true;
        break;
      }
    }
    if (bool_forceupdate) {
      for (let i = 0; i < this._connectedHubs.length; i++) {
        this._connectedHubs[i].imm_forceUpdate();
      }
    }
    try {
      this._updateDevListStarted = this.GetTickCount();
      let hubs = [];
      for (let i = 0; i < this._connectedHubs.length; i++) {
        let hub = this._connectedHubs[i];
        let rootUrl = hub.urlInfo.rootUrl;
        let hubDev = this.imm_getDevice(rootUrl);
        if (!hubDev) {
          continue;
        }
        if (hub._currentState < 1) {
          if (this._logLevel >= 4) {
            this.imm_log("Skip updateDeviceList for hub " + hub.urlInfo.host + ", currently offline");
          }
          continue;
        }
        if (hub.devListExpires <= this.GetTickCount()) {
          hub._missing = {};
          hubs.push(hub);
        }
      }
      for (let serial in this._devs) {
        let rooturl = this._devs[serial].imm_getRootUrl();
        for (let i = 0; i < hubs.length; i++) {
          let huburl = hubs[i].urlInfo.rootUrl;
          if (rooturl.substr(0, huburl.length) == huburl) {
            hubs[i]._missing[serial] = true;
          }
        }
      }
      let update_promises = [];
      for (let i = 0; i < hubs.length; i++) {
        let prom = hubs[i].hubUpdateDeviceList();
        update_promises.push(prom);
      }
      let newDeviceCounts = await Promise.all(update_promises);
      let newDeviceArrived = false;
      for (let res of newDeviceCounts) {
        newDeviceArrived = newDeviceArrived || res > 0;
      }
      if (bool_invokecallbacks) {
        let nbEvents = this._pendingCallbacks.length;
        for (let i = 0; i < nbEvents; i++) {
          let evt = this._pendingCallbacks[i];
          switch (evt.event) {
            case "+":
              if (this._logLevel >= 3) {
                this.imm_log("Device " + evt.serial + " plugged");
              }
              if (this._arrivalCallback) {
                try {
                  await evt.module.load(this.defaultCacheValidity);
                  await this._arrivalCallback(evt.module);
                } catch (e) {
                  this.imm_log("Exception in device arrival callback:", e);
                }
              }
              break;
            case "/":
              if (this._namechgCallback) {
                try {
                  await this._namechgCallback(evt.module);
                } catch (e) {
                  this.imm_log("Exception in device change callback:", e);
                }
              }
              break;
            case "-":
              if (this._logLevel >= 3) {
                this.imm_log("Device " + evt.serial + " unplugged");
              }
              if (this._removalCallback) {
                try {
                  await this._removalCallback(evt.module);
                } catch (e) {
                  this.imm_log("Exception in device removal callback:", e);
                }
              }
              break;
          }
        }
        this._pendingCallbacks = this._pendingCallbacks.slice(nbEvents);
      }
      if (newDeviceArrived) {
        for (let fun of this._ValueCallbackList) {
          if (!fun._hwId) {
            fun.isOnline();
          }
        }
        for (let fun of this._TimedReportCallbackList) {
          if (!fun._hwId) {
            fun.isOnline();
          }
        }
      }
    } finally {
      this._updateDevListStarted = 0;
    }
    return {
      errorType: YAPI_SUCCESS,
      errorMsg: "no error"
    };
  }
  async updateDeviceList_process(hub, hubDev, whitePages, yellowPages) {
    let newDevices = 0;
    let refresh = {};
    let serial = null;
    for (let classname in yellowPages) {
      let obj_yprecs = yellowPages[classname];
      let ftype = this._fnByType[classname];
      if (ftype == void 0) {
        ftype = new YFunctionType(this, classname);
        this._fnByType[classname] = ftype;
      }
      for (let i = 0; i < obj_yprecs.length; i++) {
        let yprec = obj_yprecs[i];
        let hwid = yprec.hardwareId;
        let basetype = yprec.baseType;
        if (ftype.imm_reindexFunction(hwid, yprec["logicalName"], yprec["advertisedValue"], basetype)) {
          serial = hwid.substr(0, hwid.indexOf("."));
          refresh[serial] = true;
        }
      }
    }
    for (let i = 0; i < whitePages.length; i++) {
      let devinfo = whitePages[i];
      serial = devinfo.serialNumber;
      let devydx = devinfo.index;
      let rooturl = devinfo.networkUrl.slice(0, -3);
      if (rooturl.charAt(0) == "/")
        rooturl = hubDev.imm_getRootUrl() + rooturl.substr(1);
      let currdev = this._devs[serial];
      if (this._logLevel >= 5) {
        this.imm_log("Device " + serial + " present, currdev " + (currdev ? "" : "NOT ") + "set" + (hub._firstArrivalCallback ? ", firstArrival" : ""));
      }
      if (currdev && hub._firstArrivalCallback) {
        newDevices++;
        if (this._arrivalCallback) {
          let module = YModule.FindModuleInContext(this, serial + ".module");
          this._pendingCallbacks.push({event: "+", serial, module});
        }
      }
      hub.serialByYdx[devydx] = serial;
      if (!currdev) {
        new YDevice(this, rooturl, devinfo, yellowPages);
        newDevices++;
        if (this._arrivalCallback) {
          let module = YModule.FindModuleInContext(this, serial + ".module");
          this._pendingCallbacks.push({event: "+", serial, module});
        }
      } else if (currdev.imm_getLogicalName() != devinfo["logicalName"]) {
        await currdev.refresh();
        if (this._namechgCallback) {
          let module = YModule.FindModuleInContext(this, serial + ".module");
          this._pendingCallbacks.push({event: "/", serial, module});
        }
      } else if (refresh[serial] || currdev.imm_getRootUrl() != rooturl || currdev.imm_getBeacon() != devinfo["beacon"]) {
        await currdev.refresh();
      }
      hub._missing[serial] = false;
    }
    if (this._arrivalCallback && hub._firstArrivalCallback) {
      hub._firstArrivalCallback = false;
    }
    for (serial in hub._missing) {
      if (hub._missing[serial] && this._devs[serial]) {
        if (this._removalCallback) {
          let module = YModule.FindModuleInContext(this, serial + ".module");
          this._pendingCallbacks.push({event: "-", serial, module});
        }
        this.imm_forgetDevice(this._devs[serial]);
      }
    }
    return newDevices;
  }
  async parseEvents(hub, str_lines) {
    if (hub.imm_isDisconnecting()) {
      return;
    }
    hub.isNotifWorking = true;
    hub.lastPingStamp = Date.now();
    if (hub.timeoutId) {
      clearTimeout(hub.timeoutId);
    }
    hub.timeoutId = setTimeout(() => {
      if (!hub.imm_isForwarded()) {
        this.imm_log("Closing stalled connection after " + hub.stalledTimeoutMs / 1e3 + "s");
        hub.imm_disconnectNow();
      }
    }, hub.stalledTimeoutMs);
    let rows = (hub.notifCarryOver + str_lines).split("\n");
    let nrows = rows.length;
    let value;
    if (str_lines.substr(-1) != "\n") {
      hub.notifCarryOver = rows[--nrows];
    } else {
      nrows--;
      hub.notifCarryOver = "";
    }
    for (let idx = 0; idx < nrows; idx++) {
      let ev = rows[idx];
      if (ev.length == 0)
        continue;
      let firstCode = ev.charAt(0);
      if (ev.length >= 3 && firstCode >= NOTIFY_NETPKT_CONFCHGYDX && firstCode <= NOTIFY_NETPKT_TIMEAVGYDX) {
        hub.retryDelay = 15;
        if (hub.notifPos >= 0)
          hub.notifPos += ev.length + 1;
        let devydx = ev.charCodeAt(1) - 65;
        let funydx = ev.charCodeAt(2) - 48;
        if (funydx >= 64) {
          funydx -= 64;
          devydx += 128;
        }
        let serial = hub.serialByYdx[devydx];
        if (serial && this._devs[serial]) {
          let funcid = funydx == 15 ? "time" : this._devs[serial].imm_functionIdByFunYdx(funydx);
          if (funcid != "") {
            let dev;
            value = ev.slice(3);
            switch (firstCode) {
              case NOTIFY_NETPKT_FUNCVALYDX:
                if (value != "")
                  value = value.split("\0")[0];
                await this.setFunctionValue(serial + "." + funcid, value);
                break;
              case NOTIFY_NETPKT_DEVLOGYDX:
                dev = this._devs[serial];
                if (dev != null) {
                  dev.imm_triggerLogPull();
                }
                break;
              case NOTIFY_NETPKT_CONFCHGYDX:
                await this.setConfChange(serial);
                break;
              case NOTIFY_NETPKT_TIMEVALYDX:
              case NOTIFY_NETPKT_TIMEAVGYDX:
              case NOTIFY_NETPKT_TIMEV2YDX:
                let pos, arr = [firstCode == "x" ? 0 : firstCode == "z" ? 1 : 2];
                for (pos = 0; pos < value.length; pos += 2) {
                  arr.push(parseInt(value.substr(pos, 2), 16));
                }
                dev = this._devs[serial];
                if (funcid == "time") {
                  let time = arr[1] + 256 * arr[2] + 65536 * arr[3] + 16777216 * arr[4];
                  let ms = arr[5] * 4;
                  let duration;
                  if (arr.length >= 7) {
                    ms += arr[6] >> 6;
                    let duration_ms = arr[7];
                    duration_ms += (arr[6] & 15) * 256;
                    if (arr[6] & 16) {
                      duration = duration_ms;
                    } else {
                      duration = duration_ms / 1e3;
                    }
                  } else {
                    duration = 0;
                  }
                  dev.imm_setTimeRef(time + ms / 1e3, duration);
                } else {
                  await this.setTimedReport(serial + "." + funcid, dev.imm_getLastTimeRef(), dev.imm_getLastDuration(), arr);
                }
                break;
              case NOTIFY_NETPKT_FUNCV2YDX:
                let rawval = this.imm_decodeNetFuncValV2(value);
                if (rawval != null) {
                  let decodedval = this.imm_decodePubVal(rawval[0], rawval, 1, 6);
                  await this.setFunctionValue(serial + "." + funcid, decodedval);
                }
                break;
              case NOTIFY_NETPKT_FLUSHV2YDX:
              default:
                break;
            }
          }
        }
      } else if (ev.length > 5 && ev.substr(0, 4) == "YN01") {
        hub.retryDelay = 15;
        if (hub.notifPos >= 0)
          hub.notifPos += ev.length + 1;
        let notype = ev.substr(4, 1);
        let parts;
        if (notype == "@") {
          hub.notifPos = parseInt(ev.slice(5));
        } else {
          switch (parseInt(notype)) {
            case 0:
              parts = ev.slice(5).split(",");
              if (parts.length > 2) {
                let int_beacon = parseInt(parts[2]);
                await this.setBeaconChange(parts[0], int_beacon);
              }
            case 2:
            case 4:
            case 8:
              hub.devListExpires = 0;
              break;
            case 5:
              parts = ev.slice(5).split(",");
              if (parts.length > 2) {
                value = parts[2].split("\0");
                await this.setFunctionValue(parts[0] + "." + parts[1], value[0]);
              }
              break;
          }
        }
      } else {
        hub.devListExpires = 0;
        this.imm_log("Bad event on received from server:", ev);
        hub.notifPos = -1;
      }
    }
    if (this._forwardValues > 0) {
      await this.HandleEvents(new YErrorMsg());
    }
  }
  imm_decodeNetFuncValV2(p) {
    let p_ofs = 0;
    let ch = p.charCodeAt(p_ofs) & 255;
    let len = 0;
    let funcVal = [0, 0, 0, 0, 0, 0, 0];
    if (ch < 32 || ch > 32 + 127) {
      return null;
    }
    ch -= 32;
    funcVal[0] = (ch & 64) != 0 ? NOTIFY_V2_6RAWBYTES : NOTIFY_V2_TYPEDDATA;
    ch &= 63;
    while (len < YOCTO_PUBVAL_SIZE) {
      p_ofs++;
      if (p_ofs >= p.length) {
        break;
      }
      let newCh = p.charCodeAt(p_ofs) & 255;
      if (newCh == NOTIFY_NETPKT_STOP) {
        break;
      }
      if (newCh < 32 || newCh > 32 + 127) {
        return null;
      }
      newCh -= 32;
      ch = (ch << 7) + newCh;
      funcVal[len + 1] = ch >>> 5 - len & 255;
      len++;
    }
    return funcVal;
  }
  imm_decodePubVal(int_typeV2, arr_funcval, int_ofs, int_funcvalen) {
    let buffer = "";
    let endp;
    if (int_typeV2 == NOTIFY_V2_6RAWBYTES || int_typeV2 == NOTIFY_V2_TYPEDDATA) {
      let funcValType;
      if (int_typeV2 == NOTIFY_V2_6RAWBYTES) {
        funcValType = PUBVAL_6RAWBYTES;
      } else {
        funcValType = arr_funcval[int_ofs++];
      }
      switch (funcValType) {
        case PUBVAL_LEGACY:
          break;
        case PUBVAL_1RAWBYTE:
        case PUBVAL_2RAWBYTES:
        case PUBVAL_3RAWBYTES:
        case PUBVAL_4RAWBYTES:
        case PUBVAL_5RAWBYTES:
        case PUBVAL_6RAWBYTES:
          for (let i = 0; i < funcValType; i++) {
            let c = arr_funcval[int_ofs++];
            let b = c >>> 4;
            buffer += b.toString(16);
            b = c & 15;
            buffer += b.toString(16);
          }
          return buffer;
        case PUBVAL_C_LONG:
        case PUBVAL_YOCTO_FLOAT_E3:
          let numVal = arr_funcval[int_ofs++];
          numVal += arr_funcval[int_ofs++] << 8;
          numVal += arr_funcval[int_ofs++] << 16;
          numVal += arr_funcval[int_ofs++] << 24;
          if (funcValType == PUBVAL_C_LONG) {
            return String(Math.round(numVal));
          } else {
            buffer = String(Math.round(numVal * 1e3) / 1e6);
            endp = buffer.length;
            while (endp > 0 && buffer[endp - 1] == "0") {
              --endp;
            }
            if (endp > 0 && buffer[endp - 1] == ".") {
              --endp;
              buffer = buffer.substr(0, endp);
            }
            return buffer;
          }
        case PUBVAL_C_FLOAT:
          let v = arr_funcval[int_ofs++];
          v += arr_funcval[int_ofs++] << 8;
          v += arr_funcval[int_ofs++] << 16;
          v += arr_funcval[int_ofs++] << 24;
          let fraction = (v & (1 << 23) - 1) + (1 << 23) * (v >>> 31 | 1);
          let exp = (v >>> 23 & 255) - 127;
          let floatVal = fraction * Math.pow(2, exp - 23);
          buffer = String(Math.round(floatVal * 1e6) / 1e6);
          endp = buffer.length;
          while (endp > 0 && buffer[endp - 1] == "0") {
            --endp;
          }
          if (endp > 0 && buffer[endp - 1] == ".") {
            --endp;
            buffer = buffer.substr(0, endp);
          }
          return buffer;
        default:
          return "?";
      }
      let len = 0;
      buffer = "";
      while (len < YOCTO_PUBVAL_SIZE && len < int_funcvalen) {
        if (arr_funcval[len] == 0) {
          break;
        }
        buffer += String.fromCharCode(arr_funcval[len]);
        len++;
      }
    }
    return buffer;
  }
  imm_decExp(int_pow) {
    const arr = [
      1e-6,
      1e-5,
      1e-4,
      1e-3,
      0.01,
      0.1,
      1,
      10,
      100,
      1e3,
      1e4,
      1e5,
      1e6,
      1e7,
      1e8,
      1e9
    ];
    return arr[int_pow];
  }
  imm_decimalToDouble(val) {
    let negate = false;
    let res;
    let mantis = val & 2047;
    if (mantis == 0)
      return 0;
    if (val > 32767) {
      negate = true;
      val = 65536 - val;
    } else if (val < 0) {
      negate = true;
      val = -val;
    }
    let decexp = this.imm_decExp(val >>> 11);
    if (decexp >= 1) {
      res = mantis * decexp;
    } else {
      res = mantis / Math.round(1 / decexp);
    }
    return negate ? -res : res;
  }
  imm_doubleToDecimal(val) {
    let negate = false;
    let comp, mant;
    let decpow;
    let res;
    if (val == 0) {
      return 0;
    }
    if (val < 0) {
      negate = true;
      val = -val;
    }
    comp = val / 1999;
    decpow = 0;
    while (comp > this.imm_decExp(decpow) && decpow < 15) {
      decpow++;
    }
    mant = val / this.imm_decExp(decpow);
    if (decpow == 15 && mant > 2047) {
      res = (15 << 11) + 2047;
    } else {
      res = (decpow << 11) + Math.round(mant);
    }
    return negate ? -res : res;
  }
  imm_getCalibrationHandler(calibType) {
    return this._calibHandlers[calibType];
  }
  imm_decodeWords(data) {
    let udata = [];
    for (let i = 0; i < data.length; ) {
      let c = data[i];
      let val = 0;
      if (c == "*") {
        i++;
      } else if (c == "X") {
        val = 65535;
        i++;
      } else if (c == "Y") {
        val = 32767;
        i++;
      } else if (c >= "a") {
        let srcpos = udata.length - 1 - (data.charCodeAt(i++) - 97);
        if (srcpos >= 0) {
          val = udata[srcpos];
        }
      } else {
        if (i + 3 > data.length) {
          return udata;
        }
        val = data.charCodeAt(i++) - 48;
        val += data.charCodeAt(i++) - 48 << 5;
        let lastcode = data.charCodeAt(i++);
        if (lastcode == 122)
          lastcode = 92;
        val += lastcode - 48 << 10;
      }
      udata.push(val);
    }
    return udata;
  }
  imm_decodeFloats(data) {
    let idata = [];
    let p = 0;
    let datalen = data.length;
    while (p < datalen) {
      let val = 0;
      let sign = 1;
      let dec = 0;
      let decInc = 0;
      let c = data[p++];
      while (c != "-" && (c < "0" || c > "9")) {
        if (p >= datalen) {
          return idata;
        }
        c = data[p++];
      }
      if (c == "-") {
        if (p >= datalen) {
          return idata;
        }
        sign = -sign;
        c = data[p++];
      }
      while (c >= "0" && c <= "9" || c == ".") {
        if (c == ".") {
          decInc = 1;
        } else if (dec < 3) {
          val = val * 10 + (c.charCodeAt(0) - 48);
          dec += decInc;
        }
        if (p < datalen) {
          c = data[p++];
        } else {
          c = "\0";
        }
      }
      if (dec < 3) {
        if (dec == 0) {
          val *= 1e3;
        } else if (dec == 1) {
          val *= 100;
        } else {
          val *= 10;
        }
      }
      idata.push(sign * val);
    }
    return idata;
  }
  static imm_atoi(str_data) {
    let num = parseInt(str_data);
    if (isNaN(num)) {
      return 0;
    }
    return Math.floor(num);
  }
  imm_bin2str(bin_data) {
    let len = bin_data.length;
    let res = "";
    for (let i = 0; i < len; i += 20) {
      let subdata = bin_data.subarray(i, Math.min(i + 20, len));
      res += String.fromCharCode.apply(null, Array.from(subdata));
    }
    return res;
  }
  imm_str2bin(str_data) {
    let len = str_data.length;
    let res = new Uint8Array(len);
    for (let i = 0; i < len; i++) {
      res[i] = str_data.charCodeAt(i);
    }
    return res;
  }
  imm_bin2hexstr(bin_data) {
    let len = bin_data.length;
    let res = "";
    for (let i = 0; i < len; i++) {
      let n = bin_data[i].toString(16);
      res += n.length < 2 ? "0" + n : n;
    }
    return res.toUpperCase();
  }
  imm_hexstr2bin(str_data) {
    let len = str_data.length >>> 1;
    let res = new Uint8Array(len);
    for (let i = 0; i < len; i++) {
      res[i] = parseInt(str_data.substr(2 * i, 2), 16);
    }
    return res;
  }
  imm_getDevice(str_device) {
    let dev = null;
    let serial;
    if (str_device.substr(0, 7) == "http://" || str_device.substr(0, 5) == "ws://" || str_device.substr(0, 8) == "https://" || str_device.substr(0, 6) == "wss://") {
      serial = this._snByUrl[str_device];
      if (serial != void 0)
        dev = this._devs[serial];
    } else {
      if (this._devs[str_device]) {
        dev = this._devs[str_device];
      } else {
        serial = this._snByName[str_device];
        if (serial) {
          dev = this._devs[serial];
        }
      }
    }
    return dev;
  }
  async _UpdateValueCallbackList(obj_func, bool_add) {
    let index = this._ValueCallbackList.indexOf(obj_func);
    if (bool_add) {
      await obj_func.isOnline();
      if (index < 0) {
        this._ValueCallbackList.push(obj_func);
      }
    } else if (index >= 0) {
      this._ValueCallbackList.splice(index, 1);
    }
  }
  async _UpdateTimedReportCallbackList(obj_func, bool_add) {
    let index = this._TimedReportCallbackList.indexOf(obj_func);
    if (bool_add) {
      await obj_func.isOnline();
      if (index < 0) {
        this._TimedReportCallbackList.push(obj_func);
      }
    } else if (index >= 0) {
      this._TimedReportCallbackList.splice(index, 1);
    }
  }
  imm_functionClass(str_funcid) {
    let dotpos = str_funcid.indexOf(".");
    if (dotpos >= 0)
      str_funcid = str_funcid.substr(dotpos + 1);
    let classlen = str_funcid.length;
    while (str_funcid.substr(classlen - 1, 1) <= "9") {
      classlen--;
    }
    let classname = str_funcid.substr(0, 1).toUpperCase() + str_funcid.substr(1, classlen - 1);
    if (this._fnByType[classname] == void 0) {
      this._fnByType[classname] = new YFunctionType(this, classname);
    }
    return classname;
  }
  imm_reindexDevice(obj_dev) {
    let rootUrl = obj_dev.imm_getRootUrl();
    let serial = obj_dev.imm_getSerialNumber();
    let lname = obj_dev.imm_getLogicalName();
    this._devs[serial] = obj_dev;
    this._snByUrl[rootUrl] = serial;
    if (lname != "")
      this._snByName[lname] = serial;
    this._fnByType["Module"].imm_reindexFunction(serial + ".module", lname, null, null);
    let i, count = obj_dev.imm_functionCount();
    for (i = 0; i < count; i++) {
      let funcid = obj_dev.imm_functionId(i);
      if (funcid != "") {
        let funcname = obj_dev.imm_functionName(i);
        let classname = this.imm_functionClass(funcid);
        this._fnByType[classname].imm_reindexFunction(serial + "." + funcid, funcname, null, null);
      }
    }
  }
  imm_forgetDevice(obj_dev) {
    let rootUrl = obj_dev.imm_getRootUrl();
    let serial = obj_dev.imm_getSerialNumber();
    let lname = obj_dev.imm_getLogicalName();
    delete this._devs[serial];
    delete this._snByUrl[rootUrl];
    if (this._snByName[lname] == serial) {
      delete this._snByName[lname];
    }
    this._fnByType["Module"].imm_forgetFunction(serial + ".module");
    let i, count = obj_dev.imm_functionCount();
    for (i = 0; i < count; i++) {
      let funcid = obj_dev.imm_functionId(i);
      if (funcid != "") {
        let classname = this.imm_functionClass(funcid);
        this._fnByType[classname].imm_forgetFunction(serial + "." + funcid);
      }
    }
  }
  imm_resolveFunction(str_className, str_func) {
    if (Y_BASETYPES[str_className] == void 0) {
      if (this._fnByType[str_className] == void 0) {
        this._fnByType[str_className] = new YFunctionType(this, str_className);
      }
      return this._fnByType[str_className].imm_resolve(str_func);
    }
    let baseType = Y_BASETYPES[str_className];
    let res;
    for (str_className in this._fnByType) {
      if (this._fnByType[str_className].imm_matchBaseType(baseType)) {
        res = this._fnByType[str_className].imm_resolve(str_func);
        if (res.errorType == YAPI_SUCCESS)
          return res;
      }
    }
    return {
      errorType: YAPI_DEVICE_NOT_FOUND,
      errorMsg: "No " + str_className + " [" + str_func + "] found (old firmware?)"
    };
  }
  imm_getFriendlyNameFunction(str_className, str_func) {
    if (Y_BASETYPES[str_className] == void 0) {
      if (this._fnByType[str_className] == void 0) {
        this._fnByType[str_className] = new YFunctionType(this, str_className);
      }
      return this._fnByType[str_className].imm_getFriendlyName(str_func);
    }
    let baseType = Y_BASETYPES[str_className];
    let res;
    for (str_className in this._fnByType) {
      if (this._fnByType[str_className].imm_matchBaseType(baseType)) {
        res = this._fnByType[str_className].imm_getFriendlyName(str_func);
        if (res.errorType == YAPI_SUCCESS)
          return res;
      }
    }
    return {
      errorType: YAPI_DEVICE_NOT_FOUND,
      errorMsg: "No " + str_className + " [" + str_func + "] found (old firmware?)"
    };
  }
  imm_setFunction(str_className, str_func, obj_func) {
    if (this._fnByType[str_className] == void 0) {
      this._fnByType[str_className] = new YFunctionType(this, str_className);
    }
    this._fnByType[str_className].imm_setFunction(str_func, obj_func);
  }
  imm_getFunction(str_className, str_func) {
    if (this._fnByType[str_className] == void 0) {
      this._fnByType[str_className] = new YFunctionType(this, str_className);
    }
    return this._fnByType[str_className].imm_getFunction(str_func);
  }
  async setFunctionValue(str_hwid, str_pubval) {
    let classname = this.imm_functionClass(str_hwid);
    if (this._fnByType[classname].imm_setFunctionValue(str_hwid, str_pubval)) {
      let receivers = this._ValueCallbackList;
      for (let i = 0; i < receivers.length; i++) {
        let fun = receivers[i];
        if (!fun._hwId)
          continue;
        if (fun._hwId == str_hwid) {
          await fun._invokeValueCallback(str_pubval);
        }
      }
    }
  }
  async setTimedReport(str_hwid, float_timestamp, float_duration, arr_report) {
    let classname = this.imm_functionClass(str_hwid);
    let receivers = this._TimedReportCallbackList;
    for (let i = 0; i < receivers.length; i++) {
      let fun = receivers[i];
      if (!fun._hwId)
        continue;
      if (fun._hwId == str_hwid) {
        let dev = this.imm_getDevice(fun._serial);
        if (dev) {
          let sensor = fun;
          let report = await sensor._decodeTimedReport(float_timestamp, float_duration, arr_report);
          await sensor._invokeTimedReportCallback(report);
        }
      }
    }
  }
  async setConfChange(str_serial) {
    let module = YModule.FindModuleInContext(this, str_serial + ".module");
    await module._invokeConfigChangeCallback();
  }
  async setBeaconChange(str_serial, int_beacon) {
    if (this._beacons[str_serial] === void 0 || this._beacons[str_serial] != int_beacon) {
      this._beacons[str_serial] = int_beacon;
      let dev = this.imm_getDevice(str_serial);
      if (dev) {
        dev._beacon = int_beacon;
      }
      let module = YModule.FindModuleInContext(this, str_serial + ".module");
      await module._invokeBeaconCallback(int_beacon);
    }
  }
  imm_getFunctionValue(str_hwid) {
    let classname = this.imm_functionClass(str_hwid);
    return this._fnByType[classname].imm_getFunctionValue(str_hwid);
  }
  imm_getFunctionBaseType(str_hwid) {
    let classname = this.imm_functionClass(str_hwid);
    return this._fnByType[classname].imm_getBaseType();
  }
  imm_getFirstHardwareId(str_className) {
    if (Y_BASETYPES[str_className] == void 0) {
      if (this._fnByType[str_className] == void 0) {
        this._fnByType[str_className] = new YFunctionType(this, str_className);
      }
      return this._fnByType[str_className].imm_getFirstHardwareId();
    }
    let baseType = Y_BASETYPES[str_className];
    let res;
    for (str_className in this._fnByType) {
      if (this._fnByType[str_className].imm_matchBaseType(baseType)) {
        res = this._fnByType[str_className].imm_getFirstHardwareId();
        if (res)
          return res;
      }
    }
    return null;
  }
  imm_getNextHardwareId(str_className, str_hwid) {
    if (Y_BASETYPES[str_className] == void 0) {
      return this._fnByType[str_className].imm_getNextHardwareId(str_hwid);
    }
    let baseType = Y_BASETYPES[str_className];
    let prevclass = this.imm_functionClass(str_hwid);
    let res = this._fnByType[prevclass].imm_getNextHardwareId(str_hwid);
    if (res)
      return res;
    for (str_className in this._fnByType) {
      if (prevclass != "") {
        if (str_className != prevclass)
          continue;
        prevclass = "";
        continue;
      }
      if (this._fnByType[str_className].imm_matchBaseType(baseType)) {
        res = this._fnByType[str_className].imm_getFirstHardwareId();
        if (res)
          return res;
      }
    }
    return null;
  }
  async devRequest(str_device, str_request, obj_body = null, int_tcpchan = 0) {
    let lines = str_request.split("\n");
    let res = new YHTTPRequest(null);
    let lockdev = null;
    let baseUrl;
    if (str_device.substr(0, 7) == "http://" || str_device.substr(0, 5) == "ws://" || str_device.substr(0, 8) == "https://" || str_device.substr(0, 6) == "wss://") {
      baseUrl = str_device;
      if (baseUrl.slice(-1) != "/")
        baseUrl = baseUrl + "/";
      if (lines[0].substr(0, 12) != "GET /not.byn") {
        let serial = this._snByUrl[baseUrl];
        if (serial) {
          lockdev = this._devs[serial];
        }
      }
    } else {
      lockdev = this.imm_getDevice(str_device);
      if (!lockdev) {
        res.errorType = YAPI_DEVICE_NOT_FOUND;
        res.errorMsg = "Device [" + str_device + "] not online";
        return res;
      }
      if (lines[0] == "GET /api.json") {
        return lockdev.requestAPI(this.defaultCacheValidity);
      }
      baseUrl = lockdev.imm_getRootUrl();
    }
    let words = lines[0].split(" ");
    if (words.length < 2) {
      res.errorType = YAPI_INVALID_ARGUMENT;
      res.errorMsg = "Invalid request, not enough words; expected a method name and a URL";
      return res;
    } else if (words.length > 2) {
      res.errorType = YAPI_INVALID_ARGUMENT;
      res.errorMsg = "Invalid request, too many words; make sure the URL is URI-encoded";
      return res;
    }
    let hub = null;
    for (let i = 0; i < this._connectedHubs.length; i++) {
      let hubUrl = this._connectedHubs[i].urlInfo.rootUrl;
      if (baseUrl.slice(0, hubUrl.length) == hubUrl) {
        hub = this._connectedHubs[i];
        break;
      }
    }
    if (!hub && this._knownHubsByUrl[str_device]) {
      hub = this._knownHubsByUrl[str_device];
    }
    if (!hub) {
      res.errorType = YAPI_DEVICE_NOT_FOUND;
      res.errorMsg = "No hub found for URL " + baseUrl;
      return res;
    }
    let method = words[0];
    let devUrl = words[1];
    if (devUrl.substr(0, 1) == "/")
      devUrl = devUrl.substr(1);
    if (baseUrl.substr(0, hub.urlInfo.rootUrl.length) == hub.urlInfo.rootUrl) {
      devUrl = baseUrl.substr(hub.urlInfo.rootUrl.length - 1) + devUrl;
    } else {
      let pos = baseUrl.indexOf("//");
      pos = baseUrl.indexOf("/", pos + 3);
      devUrl = baseUrl.slice(pos) + devUrl;
    }
    if (devUrl.slice(-2) == "&." && !await hub.hasRwAccess()) {
      res.errorType = YAPI_UNAUTHORIZED;
      res.errorMsg = "Access denied: admin credentials required";
      return res;
    }
    let delayedCode = function delayedRequest() {
      return hub.request(method, devUrl, obj_body, int_tcpchan).catch((e) => {
        let res2 = new YHTTPRequest(null);
        res2.errorType = YAPI_IO_ERROR;
        res2.errorMsg = e.message;
        return res2;
      });
    };
    if (lockdev && int_tcpchan == 0) {
      let newPromise = lockdev._pendingQueries.then(delayedCode, delayedCode);
      lockdev._pendingQueries = newPromise;
      res = await newPromise;
    } else {
      res = await delayedCode();
    }
    return res;
  }
  async isReadOnly(str_device) {
    let lockdev = this.imm_getDevice(str_device);
    if (!lockdev) {
      return true;
    }
    let baseUrl = lockdev.imm_getRootUrl();
    let hub = null;
    for (let i = 0; i < this._connectedHubs.length; i++) {
      let hubUrl = this._connectedHubs[i].urlInfo.rootUrl;
      if (baseUrl.slice(0, hubUrl.length) == hubUrl) {
        hub = this._connectedHubs[i];
        break;
      }
    }
    if (!hub || !await hub.hasRwAccess()) {
      return true;
    }
    return false;
  }
  imm_funcDev_internal(str_className, str_func) {
    let res = new YFuncRequest(null);
    let resolve = this.imm_resolveFunction(str_className, str_func);
    if (resolve.errorType != YAPI_SUCCESS) {
      res.errorType = resolve.errorType;
      res.errorMsg = resolve.errorMsg;
    } else {
      str_func = resolve.result;
      let dotpos = str_func.indexOf(".");
      let devid = str_func.substr(0, dotpos);
      let funcid = str_func.substr(dotpos + 1);
      let dev = this.imm_getDevice(devid);
      if (dev == null) {
        res.errorType = YAPI_DEVICE_NOT_FOUND;
        res.errorMsg = "Device [" + devid + "] not found";
      } else {
        res.obj_result = {_expiration: -1, device: dev, deviceid: devid, functionid: funcid, hwid: str_func};
      }
    }
    return res;
  }
  async _funcDev(str_className, str_func) {
    let res = this.imm_funcDev_internal(str_className, str_func);
    if (res.errorType == YAPI_SUCCESS) {
      return res;
    } else if (res.errorType == YAPI_DEVICE_NOT_FOUND && this._connectedHubs.length == 0) {
      res.errorMsg = "Impossible to contact any device because no hub has been registered";
      return res;
    }
    let updRes = await this._updateDeviceList_internal(true, false);
    if (updRes.errorType != YAPI_SUCCESS) {
      res.errorType = updRes.errorType;
      res.errorMsg = updRes.errorMsg;
      return res;
    }
    return this.imm_funcDev_internal(str_className, str_func);
  }
  async funcRequest(str_className, str_func, str_extra, int_msValidity = 0) {
    let funcreq = this.imm_funcDev_internal(str_className, str_func);
    if (funcreq.errorType != YAPI_SUCCESS) {
      funcreq = await this._funcDev(str_className, str_func);
      if (funcreq.errorType != YAPI_SUCCESS) {
        return funcreq;
      }
    }
    let devreq = funcreq.obj_result;
    let loadval = null;
    if (str_extra == "") {
      let yreq = await devreq.device.requestAPI(int_msValidity);
      if (yreq != null) {
        if (yreq.errorType != YAPI_SUCCESS || !yreq.obj_result) {
          let res = new YFuncRequest(null);
          res.errorType = yreq.errorType;
          res.errorMsg = yreq.errorMsg;
          return res;
        }
        loadval = yreq.obj_result[devreq.functionid];
      }
    } else {
      devreq.device.imm_dropCache();
    }
    if (!loadval) {
      if (str_extra == "")
        str_extra = ".json";
      let httpreq = "GET /api/" + devreq.functionid + str_extra;
      let yreq = await this.devRequest(devreq.deviceid, httpreq, null, 0);
      if (yreq.errorType != YAPI_SUCCESS)
        return yreq;
      let replyBuff = yreq.bin_result;
      if (replyBuff.length == 0 && httpreq.indexOf("?") >= 0) {
        funcreq.obj_result = null;
        return funcreq;
      }
      try {
        loadval = JSON.parse(this.imm_bin2str(replyBuff));
      } catch (err) {
      }
    }
    if (!loadval) {
      funcreq.errorType = YAPI_IO_ERROR;
      funcreq.errorMsg = "Request failed, could not parse API value for function " + devreq.hwid;
    } else {
      for (let key in devreq) {
        loadval[key] = devreq[key];
      }
      funcreq.obj_result = loadval;
    }
    return funcreq;
  }
  async HTTPRequest(str_device, str_request) {
    let yreq = await this.devRequest(str_device, str_request, null, 0);
    if (yreq.errorType != YAPI_SUCCESS) {
      return this._throw(yreq.errorType, yreq.errorMsg, null);
    }
    return yreq.bin_result;
  }
  async ForceDeviceRefresh(str_device) {
    let dev = this.imm_getDevice(str_device);
    if (!dev)
      return YAPI_DEVICE_NOT_FOUND;
    let rootUrl = dev.imm_getRootUrl();
    for (let i = 0; i < this._connectedHubs.length; i++) {
      let hub = this._connectedHubs[i];
      let hubUrl = hub.urlInfo.rootUrl;
      if (rootUrl.substr(0, hubUrl.length) === hubUrl) {
        let hubDev = this.imm_getDevice(hubUrl);
        hubDev.imm_dropCache();
        let retcode = await hubDev.refresh();
        if (retcode != YAPI_SUCCESS) {
          return this._throw(retcode, hubDev._lastErrorMsg, retcode);
        }
        let yreq = await hubDev.requestAPI(this.defaultCacheValidity);
        if (yreq.errorType != YAPI_SUCCESS) {
          return yreq.errorType;
        }
        let yellowPages = yreq.obj_result["services"]["yellowPages"];
        dev.imm_updateFromYP(yellowPages);
      }
    }
    dev.imm_dropCache();
    return YAPI_SUCCESS;
  }
  async SetDeviceListValidity_internal(deviceListValidity) {
    this._deviceListValidityMs = deviceListValidity * 1e3;
  }
  async GetDeviceListValidity_internal() {
    return this._deviceListValidityMs / 1e3 >> 0;
  }
  async SetNetworkTimeout_internal(networkMsTimeout) {
    this._networkTimeoutMs = networkMsTimeout;
  }
  async GetNetworkTimeout_internal() {
    return this._networkTimeoutMs;
  }
  async AddUdevRule_internal(force) {
    return "error: Not supported in TypeScript";
  }
  async SetDeviceListValidity(deviceListValidity) {
    return await this.SetDeviceListValidity_internal(deviceListValidity);
  }
  async GetDeviceListValidity() {
    return await this.GetDeviceListValidity_internal();
  }
  async AddUdevRule(force) {
    return await this.AddUdevRule_internal(force);
  }
  async SetNetworkTimeout(networkMsTimeout) {
    return await this.SetNetworkTimeout_internal(networkMsTimeout);
  }
  async GetNetworkTimeout() {
    return await this.GetNetworkTimeout_internal();
  }
  async SetCacheValidity(cacheValidityMs) {
    this.defaultCacheValidity = cacheValidityMs;
  }
  async GetCacheValidity() {
    return this.defaultCacheValidity;
  }
  nextHubInUseInternal(hubref) {
    return this.nextHubInUseInternal_internal(hubref);
  }
  getYHubObj(hubref) {
    let obj;
    obj = this._findYHubFromCache(hubref);
    if (obj == null) {
      obj = new YHub(this, hubref);
      this._addYHubToCache(hubref, obj);
    }
    return obj;
  }
  async GetAPIVersion() {
    return this.imm_GetAPIVersion();
  }
  imm_GetAPIVersion() {
    return "1.10.56436";
  }
  async InitAPI(mode, errmsg) {
    this._detectType = mode;
    if (this.system_env.hasSSDP) {
      if ((mode & this.DETECT_NET) !== 0) {
        await this.TriggerHubDiscovery();
      }
    } else {
    }
    return YAPI_SUCCESS;
  }
  async FreeAPI() {
    for (let serial in this._devs) {
      let lockdev = this._devs[serial];
      let newPromise = lockdev._pendingQueries;
      if (newPromise != null) {
        try {
          await newPromise;
        } catch (e) {
        }
      }
    }
    await this.KillAPI();
  }
  async KillAPI() {
    if (this._ssdpManager) {
      await this._ssdpManager.ySSDPStop();
      this._ssdpManager = null;
    }
    for (let hub of this._connectedHubs) {
      this.imm_dropConnectedHub(hub);
    }
    for (let serial in this._knownHubsBySerial) {
      let hub = this._knownHubsBySerial[serial];
      if (hub._currentState > -5) {
        await hub.detach(YAPI.IO_ERROR, "Connection closed by FreeAPI");
      }
    }
    this.imm_ResetToDefaults();
  }
  async DisableExceptions() {
    this.exceptionsDisabled = true;
  }
  async EnableExceptions() {
    this.exceptionsDisabled = false;
  }
  async LogUnhandledPromiseRejections() {
    this.system_env.hookUnhandledRejection((reason, promise) => {
      this.imm_log("Unhandled Rejection at: Promise ", promise, " reason: ", reason);
    });
  }
  imm_parseRegisteredUrl(str_url) {
    let org_url = str_url;
    let proto = "ws://";
    let user = "";
    let pass = "";
    let port = "4444";
    let host;
    let dom = "";
    let url = "";
    let rooturl = "";
    if (!this._isNodeJS && window && window.navigator && window.navigator.userAgent && /(iPad|iPhone|iPod)/g.test(window.navigator.userAgent)) {
      proto = "http://";
    }
    if (str_url.slice(0, 7) == "http://") {
      proto = "http://";
      str_url = str_url.slice(7);
    } else if (str_url.slice(0, 5) == "ws://") {
      str_url = str_url.slice(5);
    } else if (str_url.slice(0, 8) == "https://") {
      proto = "https://";
      str_url = str_url.slice(8);
    } else if (str_url.slice(0, 6) == "wss://") {
      proto = "wss://";
      str_url = str_url.slice(6);
    }
    str_url = str_url.replace("/not.byn", "");
    let pos = str_url.indexOf("/");
    if (pos > 0) {
      dom = str_url.slice(pos + 1);
      if (dom.length > 0 && dom.slice(-1) != "/") {
        dom += "/";
      }
      str_url = str_url.slice(0, pos);
    }
    url = proto;
    let authpos = str_url.indexOf("@");
    if (authpos >= 0) {
      let auth = str_url.slice(0, authpos);
      let passpos = auth.indexOf(":");
      if (passpos >= 0) {
        user = auth.slice(0, passpos);
        pass = auth.slice(passpos + 1);
        url += user + ":" + pass + "@";
      } else {
        user = auth;
        url += user + "@";
      }
      str_url = str_url.slice(authpos + 1);
    }
    pos = str_url.indexOf(":");
    if (pos < 0) {
      host = str_url;
      if (dom != "") {
        if (proto == "http://") {
          port = "80";
        } else if (proto == "https://") {
          port = "443";
        }
      }
    } else {
      host = str_url.slice(0, pos);
      port = str_url.slice(pos + 1);
    }
    if (host == "callback") {
      if (proto == "ws:") {
        url = "ws://callback:4444/";
      } else {
        url = "http://callback:4444/";
      }
      rooturl = url;
    } else {
      url += host + ":" + port + "/" + dom;
      rooturl = proto + host + ":" + port + "/" + dom;
    }
    return {
      proto,
      user,
      pass,
      host,
      port,
      domain: dom,
      authUrl: url,
      rootUrl: rooturl,
      orgUrl: org_url
    };
  }
  imm_registerHub_internal(urlInfo) {
    let newhub;
    if (urlInfo.proto.slice(0, 3) == "ws:" || urlInfo.proto.slice(0, 4) == "wss:") {
      newhub = this.system_env.getWebSocketHub(this, urlInfo);
    } else {
      newhub = this.system_env.getHttpHub(this, urlInfo);
    }
    if (newhub) {
      this._knownHubsByUrl[urlInfo.rootUrl] = newhub;
    }
    return newhub;
  }
  async RegisterHub(url, errmsg) {
    if (url === "net") {
      if (this.system_env.hasSSDP) {
        this._detectType |= this.DETECT_NET;
        return this.TriggerHubDiscovery();
      } else {
        return this.imm_setErr(errmsg, YAPI_NOT_SUPPORTED, "Network discovery is not possible in a browser", YAPI_NOT_SUPPORTED);
      }
    }
    if (url === "usb") {
      return this.imm_setErr(errmsg, YAPI_NOT_SUPPORTED, "Use the VirtualHub on 127.0.0.1 to access USB devices", YAPI_NOT_SUPPORTED);
    }
    let urlInfo = this.imm_parseRegisteredUrl(url);
    let hub = this.imm_getHub(urlInfo);
    if (!hub) {
      if (this._logLevel >= 3) {
        this.imm_log("Registering new hub: " + urlInfo.rootUrl);
      }
      hub = this.imm_registerHub_internal(urlInfo);
      if (!hub) {
        return this.imm_setErr(errmsg, YAPI_NOT_SUPPORTED, "Unsupported hub protocol: " + urlInfo.proto, YAPI_NOT_SUPPORTED);
      }
    } else {
      if (this._logLevel >= 3) {
        this.imm_log("Registering existing hub: " + urlInfo.rootUrl);
      }
      hub.imm_updateUrl(urlInfo);
    }
    await hub.attach(2);
    let sub_errmsg = new YErrorMsg();
    let retcode = await hub.waitForConnection(this._networkTimeoutMs, sub_errmsg);
    if (retcode != YAPI_SUCCESS) {
      this.imm_dropConnectedHub(hub);
      await hub.detach(retcode, sub_errmsg.msg);
      return this.imm_setErr(errmsg, retcode, sub_errmsg.msg, retcode);
    }
    let yreq = await this._updateDeviceList_internal(true, false);
    if (yreq.errorType != YAPI_SUCCESS) {
      this.imm_dropConnectedHub(hub);
      await hub.detach(yreq.errorType, yreq.errorMsg);
      return this.imm_setErr(errmsg, yreq.errorType, yreq.errorMsg, yreq.errorType);
    }
    return YAPI_SUCCESS;
  }
  async PreregisterHub(url, errmsg) {
    let urlInfo = this.imm_parseRegisteredUrl(url);
    let hub = this.imm_getHub(urlInfo);
    if (!hub) {
      if (this._logLevel >= 3) {
        this.imm_log("Preregistering new hub: " + urlInfo.rootUrl);
      }
      hub = this.imm_registerHub_internal(urlInfo);
      if (!hub) {
        return this.imm_setErr(errmsg, YAPI_NOT_SUPPORTED, "Unsupported hub protocol: " + urlInfo.proto, YAPI_NOT_SUPPORTED);
      }
    } else {
      if (this._logLevel >= 3) {
        this.imm_log("Preregistering existing hub: " + urlInfo.rootUrl);
      }
      hub.imm_updateUrl(urlInfo);
    }
    await hub.attach(1);
    return YAPI_SUCCESS;
  }
  async RegisterHubHttpCallback(incomingMessage, serverResponse, errmsg) {
    let url = "http://callback:4444";
    let urlInfo = this.imm_parseRegisteredUrl(url);
    let hub = this.imm_getHub(urlInfo);
    if (!hub) {
      hub = this.system_env.getHttpCallbackHub(this, urlInfo, incomingMessage, serverResponse);
      if (!hub) {
        return this.imm_setErr(errmsg, YAPI_NOT_SUPPORTED, "HTTP Callback mode is not available in this environment", YAPI_NOT_SUPPORTED);
      }
    }
    await hub.attach(3);
    let sub_errmsg = new YErrorMsg();
    let retcode = await hub.waitForConnection(this._networkTimeoutMs, sub_errmsg);
    if (retcode != YAPI_SUCCESS) {
      this.imm_dropConnectedHub(hub);
      await hub.detach(retcode, sub_errmsg.msg);
      return this.imm_setErr(errmsg, retcode, sub_errmsg.msg, retcode);
    }
    let yreq = await this._updateDeviceList_internal(true, false);
    if (yreq.errorType != YAPI_SUCCESS) {
      await hub.reportFailure(yreq.errorMsg);
      return this.imm_setErr(errmsg, yreq.errorType, yreq.errorMsg, yreq.errorType);
    }
    return YAPI_SUCCESS;
  }
  async RegisterHubWebSocketCallback(ws, errmsg, authpwd) {
    let authstr = authpwd ? "ws:" + authpwd + "@" : "";
    let url = "http://" + authstr + "callback:4444";
    let urlInfo = this.imm_parseRegisteredUrl(url);
    let hub = this.imm_getHub(urlInfo);
    if (!hub) {
      hub = this.system_env.getWebSocketCallbackHub(this, urlInfo, ws);
      if (!hub) {
        return this.imm_setErr(errmsg, YAPI_NOT_SUPPORTED, "WebSocket Callback mode is not available in this environment", YAPI_NOT_SUPPORTED);
      }
    }
    await hub.attach(3);
    let sub_errmsg = new YErrorMsg();
    let retcode = await hub.waitForConnection(this._networkTimeoutMs, sub_errmsg);
    if (retcode != YAPI_SUCCESS) {
      this.imm_dropConnectedHub(hub);
      await hub.detach(retcode, sub_errmsg.msg);
      return this.imm_setErr(errmsg, retcode, sub_errmsg.msg, retcode);
    }
    let yreq = await this._updateDeviceList_internal(true, false);
    if (yreq.errorType != YAPI_SUCCESS) {
      this.imm_dropConnectedHub(hub);
      await hub.detach(yreq.errorType, yreq.errorMsg);
      return this.imm_setErr(errmsg, yreq.errorType, yreq.errorMsg, yreq.errorType);
    }
    return YAPI_SUCCESS;
  }
  async WebSocketJoin(ws, arr_credentials, closeCallback) {
    if (this._connectedHubs.length == 0) {
      return false;
    }
    return this._connectedHubs[0].websocketJoin(ws, arr_credentials, closeCallback);
  }
  async UnregisterHub(url) {
    let urlInfo = this.imm_parseRegisteredUrl(url);
    let hub = this.imm_getHub(urlInfo);
    if (hub) {
      if (hub.hubSerial) {
        let activeHub = this._knownHubsBySerial[hub.hubSerial];
        if (activeHub) {
          hub.imm_forgetUrls();
          hub = activeHub;
          urlInfo = hub.urlInfo;
        }
      }
      if (this._logLevel >= 3) {
        this.imm_log("Unregistering hub " + url + " (" + urlInfo.rootUrl + ")");
      }
      this.imm_dropConnectedHub(hub);
      if (hub.imm_isDisconnected()) {
        if (this._logLevel >= 3) {
          this.imm_log("Hub " + urlInfo.rootUrl + " is already disconnected");
        }
        return;
      }
      let before = this.GetTickCount();
      let disconnected = hub.waitForDisconnection(500);
      if (hub.imm_isDisconnecting()) {
        if (this._logLevel >= 3) {
          this.imm_log("Hub " + urlInfo.rootUrl + " is already disconnecting");
        }
      } else {
        await hub.detach(YAPI.IO_ERROR, "Hub has been unregistered");
      }
      await disconnected;
      hub.imm_forgetUrls();
      if (this._logLevel >= 4) {
        this.imm_log("Disconnected after " + (this.GetTickCount() - before) + " ms");
      }
    }
  }
  async TestHub(url, mstimeout, errmsg) {
    let urlInfo = this.imm_parseRegisteredUrl(url);
    let hub = this.imm_getHub(urlInfo);
    if (!hub) {
      if (this._logLevel >= 4) {
        this.imm_log("Testing new hub: " + urlInfo.rootUrl);
      }
      hub = this.imm_registerHub_internal(urlInfo);
      if (!hub) {
        return this.imm_setErr(errmsg, YAPI_NOT_SUPPORTED, "Unsupported hub protocol: " + urlInfo.proto, YAPI_NOT_SUPPORTED);
      }
    } else {
      if (this._logLevel >= 4) {
        this.imm_log("Testing existing hub: " + urlInfo.rootUrl);
      }
    }
    await hub.attach(0);
    let sub_errmsg = new YErrorMsg();
    let retcode = await hub.waitForConnection(mstimeout, sub_errmsg);
    if (retcode != YAPI_SUCCESS) {
      return this.imm_setErr(errmsg, retcode, sub_errmsg.msg, retcode);
    }
    return YAPI_SUCCESS;
  }
  async UpdateDeviceList(errmsg = null) {
    let yreq = await this._updateDeviceList_internal(false, true);
    if (yreq.errorType !== YAPI_SUCCESS) {
      return this.imm_setErr(errmsg, yreq.errorType, yreq.errorMsg, yreq.errorType);
    }
    return YAPI_SUCCESS;
  }
  async _hubDiscoveryCallback_internal(serial, urlToRegister, urlToUnregister) {
    if (this._hubDiscoveryCallback && urlToRegister) {
      try {
        await this._hubDiscoveryCallback(serial, urlToRegister, urlToUnregister);
      } catch (e) {
        this.imm_log("Exception in hub discovery callback:", e);
      }
    }
    if ((this._detectType & Y_DETECT_NET) !== 0) {
      if (urlToRegister) {
        if (urlToUnregister) {
          await this.UnregisterHub(urlToUnregister);
        }
        await this.PreregisterHub(urlToRegister, new YErrorMsg());
      }
    }
  }
  async TriggerHubDiscovery(errmsg = null) {
    if (!this._ssdpManager) {
      this._ssdpManager = this.system_env.getSSDPManager(this);
      if (!this._ssdpManager)
        return this._lastErrorType;
      await this._ssdpManager.ySSDPStart((serial, newUrl, oldUrl) => {
        this._hubDiscoveryCallback_internal(serial, newUrl, oldUrl);
      });
    } else {
      await this._ssdpManager.ySSDPDiscover();
    }
    return YAPI_SUCCESS;
  }
  async HandleEvents(errmsg = null) {
    return YAPI_SUCCESS;
  }
  async Sleep(ms_duration, errmsg = null) {
    let end = this.GetTickCount() + ms_duration;
    let remaining = ms_duration;
    while (remaining > 0) {
      let waitTime = Math.min(remaining, 25);
      await new Promise((resolve, reject) => {
        setTimeout(resolve, waitTime);
      });
      remaining = end - this.GetTickCount();
    }
    return YAPI_SUCCESS;
  }
  _microSleep_internal() {
    return new Promise(function(resolve, reject) {
      setTimeout(resolve, 3);
    });
  }
  SetTimeout(callback, ms_timeout, args) {
    let endtime = this.GetTickCount() + ms_timeout;
    let setTimeout_internal = async () => {
      let delay = endtime - this.GetTickCount();
      if (delay < 40) {
        if (delay > 3) {
          await new Promise((resolve, reject) => {
            setTimeout(resolve, delay);
          });
        }
        callback.apply(null, args);
      } else {
        if (delay >= 150) {
          await this.UpdateDeviceList();
          delay = Math.min(endtime - YAPI.GetTickCount(), 110);
        }
        await this.Sleep(delay - 20);
        setTimeout_internal();
      }
    };
    setTimeout_internal();
    return YAPI_SUCCESS;
  }
  GetTickCount() {
    return Date.now();
  }
  imm_CheckLogicalName(name) {
    if (name == "")
      return true;
    if (!name)
      return false;
    if (name.length > 19)
      return false;
    return /^[A-Za-z0-9_\-]*$/.test(name);
  }
  async CheckLogicalName(name) {
    return this.imm_CheckLogicalName(name);
  }
  async RegisterDeviceArrivalCallback(arrivalCallback) {
    this._arrivalCallback = arrivalCallback;
  }
  async RegisterDeviceChangeCallback(changeCallback) {
    this._namechgCallback = changeCallback;
  }
  async RegisterDeviceRemovalCallback(removalCallback) {
    this._removalCallback = removalCallback;
  }
  async RegisterHubDiscoveryCallback(hubDiscoveryCallback) {
    if (!this.system_env.hasSSDP) {
      return this._throw(YAPI_NOT_SUPPORTED, "Hub discovery is not supported in this environment", YAPI_NOT_SUPPORTED);
    }
    this._hubDiscoveryCallback = hubDiscoveryCallback;
    return this.TriggerHubDiscovery();
  }
  async RegisterCalibrationHandler(calibrationType, calibrationHandler) {
    this._calibHandlers[calibrationType] = calibrationHandler;
  }
  LinearCalibrationHandler(float_rawValue, int_calibType, arr_calibParams, arr_calibRawValues, arr_calibRefValues) {
    let npt;
    let x = arr_calibRawValues[0];
    let adj = arr_calibRefValues[0] - x;
    let i = 0;
    if (int_calibType < YOCTO_CALIB_TYPE_OFS) {
      npt = Math.min(int_calibType % 10, arr_calibRawValues.length, arr_calibRefValues.length);
    } else {
      npt = arr_calibRefValues.length;
    }
    while (float_rawValue > arr_calibRawValues[i] && ++i < npt) {
      let x2 = x;
      let adj2 = adj;
      x = arr_calibRawValues[i];
      adj = arr_calibRefValues[i] - x;
      if (float_rawValue < x && x > x2) {
        adj = adj2 + (adj - adj2) * (float_rawValue - x2) / (x - x2);
      }
    }
    return float_rawValue + adj;
  }
  imm_yMD5(text) {
    let ctx = new Y_MD5Ctx();
    ctx.addData(this.imm_str2bin(text));
    return ctx.calculate();
  }
  imm_initshaw(str_s, int_ofs, int_pad, int_xinit, _shaw) {
    let ii;
    let j = -1;
    let k = 0;
    let n = str_s.length;
    for (ii = 0; ii < 64; ii++) {
      let i = int_ofs + ii;
      let c = 0;
      if (i < n) {
        c = str_s.charCodeAt(i);
      } else if (int_pad != 0) {
        if ((int_pad & 128) != 0) {
          if (i == n)
            c = int_pad;
        } else {
          if (i == n + 3) {
            c = int_pad;
          } else if (i == n + 4)
            c = 128;
        }
      }
      if (k == 0) {
        j++;
        _shaw[j] = 0;
        k = 32;
      }
      k -= 8;
      _shaw[j] |= c << k;
    }
    if (int_pad != 0) {
      if (int_pad == 128) {
        if (n <= int_ofs + 55) {
          _shaw[15] = 8 * n;
        }
      } else {
        _shaw[15] = 8 * (64 + n + 4);
      }
    }
    if (int_xinit != 0) {
      let xdw = int_xinit << 16 | int_xinit;
      for (j = 0; j < 16; j++) {
        _shaw[j] ^= xdw;
      }
    }
  }
  imm_itershaw(s, _shaw) {
    let a, b, c, d, e, t, k;
    a = s[0];
    b = s[1];
    c = s[2];
    d = s[3];
    e = s[4];
    for (k = 16; k < 80; k++) {
      t = _shaw[k - 3] ^ _shaw[k - 8] ^ _shaw[k - 14] ^ _shaw[k - 16];
      _shaw[k] = t << 1 | t >>> 31;
    }
    for (k = 0; k < 20; k++) {
      t = (a << 5 | a >>> 27) + e + _shaw[k] + 1518500249 + (b & c | ~b & d);
      e = d;
      d = c;
      c = b << 30 | b >>> 2;
      b = a;
      a = t & 4294967295;
    }
    for (k = 20; k < 40; k++) {
      t = (a << 5 | a >>> 27) + e + _shaw[k] + 1859775393 + (b ^ c ^ d);
      e = d;
      d = c;
      c = b << 30 | b >>> 2;
      b = a;
      a = t & 4294967295;
    }
    for (k = 40; k < 60; k++) {
      t = (a << 5 | a >>> 27) + e + _shaw[k] + 2400959708 + (b & c | b & d | c & d);
      e = d;
      d = c;
      c = b << 30 | b >>> 2;
      b = a;
      a = t & 4294967295;
    }
    for (k = 60; k < 80; k++) {
      t = (a << 5 | a >>> 27) + e + _shaw[k] + 3395469782 + (b ^ c ^ d);
      e = d;
      d = c;
      c = b << 30 | b >>> 2;
      b = a;
      a = t & 4294967295;
    }
    _shaw[0] = s[0] + a & 4294967295;
    _shaw[1] = s[1] + b & 4294967295;
    _shaw[2] = s[2] + c & 4294967295;
    _shaw[3] = s[3] + d & 4294967295;
    _shaw[4] = s[4] + e & 4294967295;
  }
  imm_ySHA1(text) {
    let shau = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
    let i, ofs = 0;
    let n = text.length;
    let _shaw = new Uint32Array(80);
    do {
      this.imm_initshaw(text, ofs, 128, 0, _shaw);
      this.imm_itershaw(shau, _shaw);
      for (i = 0; i < 5; i++) {
        shau[i] = _shaw[i];
      }
      ofs += 64;
    } while (n > ofs - 9);
    let res = new Uint8Array(20);
    for (i = 0; i < 20; i++) {
      res[i] = shau[i >>> 2] >>> 24 - 8 * (i & 3) & 255;
    }
    return res;
  }
  async ComputePSK(ssid, pass) {
    let sha1_init = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
    let inner = [], outer = [], shau = [], res = [];
    let iter, pos, k, _shaw;
    _shaw = new Uint32Array(80);
    this.imm_initshaw(pass, 0, 0, 13878, _shaw);
    this.imm_itershaw(sha1_init, _shaw);
    for (k = 0; k < 5; k++) {
      inner[k] = _shaw[k];
    }
    _shaw = new Uint32Array(80);
    this.imm_initshaw(pass, 0, 0, 23644, _shaw);
    this.imm_itershaw(sha1_init, _shaw);
    for (k = 0; k < 5; k++) {
      outer[k] = _shaw[k];
    }
    pos = 0;
    for (k = 0; k < 5; k++) {
      shau[k] = 0;
    }
    _shaw = new Uint32Array(80);
    this.imm_initshaw(ssid, 0, 1, 0, _shaw);
    for (iter = 0; iter < 8192; ) {
      this.imm_itershaw(inner, _shaw);
      _shaw[5] = 2147483648;
      for (k = 6; k < 15; k++) {
        _shaw[k] = 0;
      }
      _shaw[15] = 8 * (64 + 20);
      this.imm_itershaw(outer, _shaw);
      shau[0] ^= _shaw[0];
      shau[1] ^= _shaw[1];
      shau[2] ^= _shaw[2];
      shau[3] ^= _shaw[3];
      shau[4] ^= _shaw[4];
      iter++;
      if ((iter & 4095) == 0) {
        for (k = 0; k < 5 && pos < 32; k++) {
          res[pos++] = shau[k] >>> 24 & 255;
          res[pos++] = shau[k] >>> 16 & 255;
          res[pos++] = shau[k] >>> 8 & 255;
          res[pos++] = shau[k] & 255;
        }
        if (iter == 4096) {
          for (k = 0; k < 5; k++) {
            shau[k] = 0;
          }
          _shaw = new Uint32Array(80);
          this.imm_initshaw(ssid, 0, 2, 0, _shaw);
        }
      }
    }
    let hex = "";
    for (k = 0; k < 32; k++) {
      hex += ("0" + Number(res[k]).toString(16)).slice(-2);
    }
    return hex;
  }
  nextHubInUseInternal_internal(hubref) {
    let nextref = hubref < 0 ? 0 : hubref + 1;
    for (let url in this._knownHubsByUrl) {
      let hub = this._knownHubsByUrl[url];
      if (hub.getHubRef() == nextref) {
        if (hub.imm_isPreOrRegistered()) {
          return this.getYHubObj(nextref);
        } else {
          nextref++;
        }
      }
    }
    return null;
  }
  getGenHub(hubref) {
    for (let url in this._knownHubsByUrl) {
      let hub = this._knownHubsByUrl[url];
      if (hub.getHubRef() == hubref && hub.imm_isPreOrRegistered()) {
        return hub;
      }
    }
    return null;
  }
  _findYHubFromCache(hubref) {
    return this._yhub_cache[hubref];
  }
  _addYHubToCache(hubref, obj) {
    this._yhub_cache[hubref] = obj;
  }
};
YAPIContext.SUCCESS = 0;
YAPIContext.NOT_INITIALIZED = -1;
YAPIContext.INVALID_ARGUMENT = -2;
YAPIContext.NOT_SUPPORTED = -3;
YAPIContext.DEVICE_NOT_FOUND = -4;
YAPIContext.VERSION_MISMATCH = -5;
YAPIContext.DEVICE_BUSY = -6;
YAPIContext.TIMEOUT = -7;
YAPIContext.IO_ERROR = -8;
YAPIContext.NO_MORE_DATA = -9;
YAPIContext.EXHAUSTED = -10;
YAPIContext.DOUBLE_ACCES = -11;
YAPIContext.UNAUTHORIZED = -12;
YAPIContext.RTC_NOT_READY = -13;
YAPIContext.FILE_NOT_FOUND = -14;
YAPIContext.SSL_ERROR = -15;
YAPIContext.RFID_SOFT_ERROR = -16;
YAPIContext.RFID_HARD_ERROR = -17;
YAPIContext.BUFFER_TOO_SMALL = -18;
var YAPI = new YAPIContext();

// obj/full/Api/yocto_api_html.js
var YSystemEnvHtml = class extends YSystemEnv {
  constructor() {
    super(...arguments);
    this.isNodeJS = false;
    this.hasSSDP = false;
  }
  hookUnhandledRejection(handler) {
    window.addEventListener("onunhandledrejection", (event) => {
      let promiseRejectionEvent = event;
      handler(promiseRejectionEvent.reason, promiseRejectionEvent.promise);
    });
  }
  getWebSocketHub(obj_yapi, urlInfo) {
    return new YWebSocketHtmlHub(obj_yapi, urlInfo);
  }
  getHttpHub(obj_yapi, urlInfo) {
    return new YHttpHtmlHub(obj_yapi, urlInfo);
  }
  getWebSocketCallbackHub(obj_yapi, urlInfo, ws) {
    return obj_yapi._throw(YAPI.NOT_SUPPORTED, "WebSocket Callback mode is not available in this environment", null);
  }
  getHttpCallbackHub(obj_yapi, urlInfo, incomingMessage, serverResponse) {
    return obj_yapi._throw(YAPI.NOT_SUPPORTED, "HTTP Callback mode is not available in this environment", null);
  }
  getSSDPManager(obj_yapi) {
    return obj_yapi._throw(YAPI.NOT_SUPPORTED, "Hub discovery is not available in this environment", null);
  }
  loadfile(file) {
    return new Promise((resolve, reject) => {
      let reader = new FileReader();
      reader.onerror = function(evt) {
        reject(evt.target.error);
      };
      reader.onload = function(evt) {
        resolve(new Uint8Array(evt.target.result));
      };
      reader.readAsArrayBuffer(file);
    });
  }
  downloadfile(url) {
    return new Promise((resolve, reject) => {
      let httpRequest = new XMLHttpRequest();
      httpRequest.open("GET", url, true);
      httpRequest.overrideMimeType("text/plain; charset=x-user-defined");
      httpRequest.onreadystatechange = () => {
        if (httpRequest.readyState == 4) {
          if (httpRequest.status != 200 && httpRequest.status != 304) {
            if (httpRequest.status) {
              reject(new Error("HTTP error " + httpRequest.status));
            } else {
              reject(new Error("Unable to complete HTTP request, network down?"));
            }
          } else {
            resolve(YAPI.imm_str2bin(httpRequest.responseText));
          }
        }
      };
      httpRequest.send("");
    });
  }
};
var _HtmlSystemEnv = new YSystemEnvHtml();
YAPI.imm_setSystemEnv(_HtmlSystemEnv);
var YHttpHtmlHub = class extends YHttpHub {
  constructor(yapi, urlInfo) {
    super(yapi, urlInfo);
  }
  imm_makeRequest(method, relUrl, contentType, body, onProgress, onSuccess, onError) {
    let xhr = new XMLHttpRequest();
    let currPos = 0;
    xhr.open(method, this.urlInfo.authUrl + relUrl, true, "", "");
    xhr.setRequestHeader("Content-Type", contentType);
    xhr.overrideMimeType("text/plain; charset=x-user-defined");
    xhr.onreadystatechange = () => {
      if (xhr.readyState >= 3) {
        let httpStatus = xhr.status >> 0;
        if (xhr.readyState == 4 && httpStatus != 200 && httpStatus != 304) {
          if (httpStatus == 401 || httpStatus == 204) {
            this.infoJson.stamp = 0;
            onError(YAPI.UNAUTHORIZED, "Unauthorized access (" + xhr.status + ")");
          } else if (httpStatus == 404) {
            onError(YAPI.FILE_NOT_FOUND, "HTTP request return status 404 (not found)");
          } else if (this.imm_isDisconnecting()) {
            onError(YAPI.IO_ERROR, "Hub is disconnecting");
          } else {
            onError(YAPI.IO_ERROR, "HTTP request failed with status " + xhr.status);
          }
          return;
        }
        if (this.imm_isDisconnecting()) {
          if (this._yapi._logLevel >= 4) {
            this._yapi.imm_log("Dropping request " + relUrl + " because hub is disconnecting");
          }
          return;
        }
        if (onProgress && xhr.responseText) {
          let newlen = xhr.responseText.length;
          if (newlen > currPos) {
            onProgress(xhr.responseText.slice(currPos, newlen));
            currPos = newlen;
          }
        }
        if (onSuccess && xhr.readyState == 4) {
          onSuccess(xhr.responseText);
        }
      }
    };
    xhr.onerror = () => {
      onError(YAPI.IO_ERROR, "HTTP request failed without status");
    };
    xhr.send(body);
    return xhr;
  }
  imm_abortRequest(clientRequest) {
    clientRequest.abort();
  }
};
var YWebSocketHtmlHub = class extends YWebSocketHub {
  imm_webSocketOpen(str_url) {
    let websock = new WebSocket(str_url);
    websock.binaryType = "arraybuffer";
    this.websocket = websock;
  }
  imm_getRandomValues(arr) {
    return window.crypto.getRandomValues(arr);
  }
};

// obj/full/Api/yocto_network.js
var YNetwork = class extends YFunction {
  constructor(yapi, func) {
    super(yapi, func);
    this._readiness = YNetwork.READINESS_INVALID;
    this._macAddress = YNetwork.MACADDRESS_INVALID;
    this._ipAddress = YNetwork.IPADDRESS_INVALID;
    this._subnetMask = YNetwork.SUBNETMASK_INVALID;
    this._router = YNetwork.ROUTER_INVALID;
    this._currentDNS = YNetwork.CURRENTDNS_INVALID;
    this._ipConfig = YNetwork.IPCONFIG_INVALID;
    this._primaryDNS = YNetwork.PRIMARYDNS_INVALID;
    this._secondaryDNS = YNetwork.SECONDARYDNS_INVALID;
    this._ntpServer = YNetwork.NTPSERVER_INVALID;
    this._userPassword = YNetwork.USERPASSWORD_INVALID;
    this._adminPassword = YNetwork.ADMINPASSWORD_INVALID;
    this._httpPort = YNetwork.HTTPPORT_INVALID;
    this._defaultPage = YNetwork.DEFAULTPAGE_INVALID;
    this._discoverable = YNetwork.DISCOVERABLE_INVALID;
    this._wwwWatchdogDelay = YNetwork.WWWWATCHDOGDELAY_INVALID;
    this._callbackUrl = YNetwork.CALLBACKURL_INVALID;
    this._callbackMethod = YNetwork.CALLBACKMETHOD_INVALID;
    this._callbackEncoding = YNetwork.CALLBACKENCODING_INVALID;
    this._callbackTemplate = YNetwork.CALLBACKTEMPLATE_INVALID;
    this._callbackCredentials = YNetwork.CALLBACKCREDENTIALS_INVALID;
    this._callbackInitialDelay = YNetwork.CALLBACKINITIALDELAY_INVALID;
    this._callbackSchedule = YNetwork.CALLBACKSCHEDULE_INVALID;
    this._callbackMinDelay = YNetwork.CALLBACKMINDELAY_INVALID;
    this._callbackMaxDelay = YNetwork.CALLBACKMAXDELAY_INVALID;
    this._poeCurrent = YNetwork.POECURRENT_INVALID;
    this._valueCallbackNetwork = null;
    this.READINESS_DOWN = 0;
    this.READINESS_EXISTS = 1;
    this.READINESS_LINKED = 2;
    this.READINESS_LAN_OK = 3;
    this.READINESS_WWW_OK = 4;
    this.READINESS_INVALID = -1;
    this.MACADDRESS_INVALID = YAPI.INVALID_STRING;
    this.IPADDRESS_INVALID = YAPI.INVALID_STRING;
    this.SUBNETMASK_INVALID = YAPI.INVALID_STRING;
    this.ROUTER_INVALID = YAPI.INVALID_STRING;
    this.CURRENTDNS_INVALID = YAPI.INVALID_STRING;
    this.IPCONFIG_INVALID = YAPI.INVALID_STRING;
    this.PRIMARYDNS_INVALID = YAPI.INVALID_STRING;
    this.SECONDARYDNS_INVALID = YAPI.INVALID_STRING;
    this.NTPSERVER_INVALID = YAPI.INVALID_STRING;
    this.USERPASSWORD_INVALID = YAPI.INVALID_STRING;
    this.ADMINPASSWORD_INVALID = YAPI.INVALID_STRING;
    this.HTTPPORT_INVALID = YAPI.INVALID_UINT;
    this.DEFAULTPAGE_INVALID = YAPI.INVALID_STRING;
    this.DISCOVERABLE_FALSE = 0;
    this.DISCOVERABLE_TRUE = 1;
    this.DISCOVERABLE_INVALID = -1;
    this.WWWWATCHDOGDELAY_INVALID = YAPI.INVALID_UINT;
    this.CALLBACKURL_INVALID = YAPI.INVALID_STRING;
    this.CALLBACKMETHOD_POST = 0;
    this.CALLBACKMETHOD_GET = 1;
    this.CALLBACKMETHOD_PUT = 2;
    this.CALLBACKMETHOD_INVALID = -1;
    this.CALLBACKENCODING_FORM = 0;
    this.CALLBACKENCODING_JSON = 1;
    this.CALLBACKENCODING_JSON_ARRAY = 2;
    this.CALLBACKENCODING_CSV = 3;
    this.CALLBACKENCODING_YOCTO_API = 4;
    this.CALLBACKENCODING_JSON_NUM = 5;
    this.CALLBACKENCODING_EMONCMS = 6;
    this.CALLBACKENCODING_AZURE = 7;
    this.CALLBACKENCODING_INFLUXDB = 8;
    this.CALLBACKENCODING_MQTT = 9;
    this.CALLBACKENCODING_YOCTO_API_JZON = 10;
    this.CALLBACKENCODING_PRTG = 11;
    this.CALLBACKENCODING_INFLUXDB_V2 = 12;
    this.CALLBACKENCODING_INVALID = -1;
    this.CALLBACKTEMPLATE_OFF = 0;
    this.CALLBACKTEMPLATE_ON = 1;
    this.CALLBACKTEMPLATE_INVALID = -1;
    this.CALLBACKCREDENTIALS_INVALID = YAPI.INVALID_STRING;
    this.CALLBACKINITIALDELAY_INVALID = YAPI.INVALID_UINT;
    this.CALLBACKSCHEDULE_INVALID = YAPI.INVALID_STRING;
    this.CALLBACKMINDELAY_INVALID = YAPI.INVALID_UINT;
    this.CALLBACKMAXDELAY_INVALID = YAPI.INVALID_UINT;
    this.POECURRENT_INVALID = YAPI.INVALID_UINT;
    this._className = "Network";
  }
  imm_parseAttr(name, val) {
    switch (name) {
      case "readiness":
        this._readiness = val;
        return 1;
      case "macAddress":
        this._macAddress = val;
        return 1;
      case "ipAddress":
        this._ipAddress = val;
        return 1;
      case "subnetMask":
        this._subnetMask = val;
        return 1;
      case "router":
        this._router = val;
        return 1;
      case "currentDNS":
        this._currentDNS = val;
        return 1;
      case "ipConfig":
        this._ipConfig = val;
        return 1;
      case "primaryDNS":
        this._primaryDNS = val;
        return 1;
      case "secondaryDNS":
        this._secondaryDNS = val;
        return 1;
      case "ntpServer":
        this._ntpServer = val;
        return 1;
      case "userPassword":
        this._userPassword = val;
        return 1;
      case "adminPassword":
        this._adminPassword = val;
        return 1;
      case "httpPort":
        this._httpPort = val;
        return 1;
      case "defaultPage":
        this._defaultPage = val;
        return 1;
      case "discoverable":
        this._discoverable = val;
        return 1;
      case "wwwWatchdogDelay":
        this._wwwWatchdogDelay = val;
        return 1;
      case "callbackUrl":
        this._callbackUrl = val;
        return 1;
      case "callbackMethod":
        this._callbackMethod = val;
        return 1;
      case "callbackEncoding":
        this._callbackEncoding = val;
        return 1;
      case "callbackTemplate":
        this._callbackTemplate = val;
        return 1;
      case "callbackCredentials":
        this._callbackCredentials = val;
        return 1;
      case "callbackInitialDelay":
        this._callbackInitialDelay = val;
        return 1;
      case "callbackSchedule":
        this._callbackSchedule = val;
        return 1;
      case "callbackMinDelay":
        this._callbackMinDelay = val;
        return 1;
      case "callbackMaxDelay":
        this._callbackMaxDelay = val;
        return 1;
      case "poeCurrent":
        this._poeCurrent = val;
        return 1;
    }
    return super.imm_parseAttr(name, val);
  }
  async get_readiness() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.READINESS_INVALID;
      }
    }
    res = this._readiness;
    return res;
  }
  async get_macAddress() {
    let res;
    if (this._cacheExpiration == 0) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.MACADDRESS_INVALID;
      }
    }
    res = this._macAddress;
    return res;
  }
  async get_ipAddress() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.IPADDRESS_INVALID;
      }
    }
    res = this._ipAddress;
    return res;
  }
  async get_subnetMask() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.SUBNETMASK_INVALID;
      }
    }
    res = this._subnetMask;
    return res;
  }
  async get_router() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.ROUTER_INVALID;
      }
    }
    res = this._router;
    return res;
  }
  async get_currentDNS() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.CURRENTDNS_INVALID;
      }
    }
    res = this._currentDNS;
    return res;
  }
  async get_ipConfig() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.IPCONFIG_INVALID;
      }
    }
    res = this._ipConfig;
    return res;
  }
  async set_ipConfig(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("ipConfig", rest_val);
  }
  async get_primaryDNS() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.PRIMARYDNS_INVALID;
      }
    }
    res = this._primaryDNS;
    return res;
  }
  async set_primaryDNS(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("primaryDNS", rest_val);
  }
  async get_secondaryDNS() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.SECONDARYDNS_INVALID;
      }
    }
    res = this._secondaryDNS;
    return res;
  }
  async set_secondaryDNS(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("secondaryDNS", rest_val);
  }
  async get_ntpServer() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.NTPSERVER_INVALID;
      }
    }
    res = this._ntpServer;
    return res;
  }
  async set_ntpServer(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("ntpServer", rest_val);
  }
  async get_userPassword() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.USERPASSWORD_INVALID;
      }
    }
    res = this._userPassword;
    return res;
  }
  async set_userPassword(newval) {
    let rest_val;
    if (newval.length > YAPI.HASH_BUF_SIZE) {
      return this._throw(YAPI.INVALID_ARGUMENT, "Password too long :" + newval, YAPI.INVALID_ARGUMENT);
    }
    rest_val = String(newval);
    return await this._setAttr("userPassword", rest_val);
  }
  async get_adminPassword() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.ADMINPASSWORD_INVALID;
      }
    }
    res = this._adminPassword;
    return res;
  }
  async set_adminPassword(newval) {
    let rest_val;
    if (newval.length > YAPI.HASH_BUF_SIZE) {
      return this._throw(YAPI.INVALID_ARGUMENT, "Password too long :" + newval, YAPI.INVALID_ARGUMENT);
    }
    rest_val = String(newval);
    return await this._setAttr("adminPassword", rest_val);
  }
  async get_httpPort() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.HTTPPORT_INVALID;
      }
    }
    res = this._httpPort;
    return res;
  }
  async set_httpPort(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("httpPort", rest_val);
  }
  async get_defaultPage() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.DEFAULTPAGE_INVALID;
      }
    }
    res = this._defaultPage;
    return res;
  }
  async set_defaultPage(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("defaultPage", rest_val);
  }
  async get_discoverable() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.DISCOVERABLE_INVALID;
      }
    }
    res = this._discoverable;
    return res;
  }
  async set_discoverable(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("discoverable", rest_val);
  }
  async get_wwwWatchdogDelay() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.WWWWATCHDOGDELAY_INVALID;
      }
    }
    res = this._wwwWatchdogDelay;
    return res;
  }
  async set_wwwWatchdogDelay(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("wwwWatchdogDelay", rest_val);
  }
  async get_callbackUrl() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.CALLBACKURL_INVALID;
      }
    }
    res = this._callbackUrl;
    return res;
  }
  async set_callbackUrl(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("callbackUrl", rest_val);
  }
  async get_callbackMethod() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.CALLBACKMETHOD_INVALID;
      }
    }
    res = this._callbackMethod;
    return res;
  }
  async set_callbackMethod(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("callbackMethod", rest_val);
  }
  async get_callbackEncoding() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.CALLBACKENCODING_INVALID;
      }
    }
    res = this._callbackEncoding;
    return res;
  }
  async set_callbackEncoding(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("callbackEncoding", rest_val);
  }
  async get_callbackTemplate() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.CALLBACKTEMPLATE_INVALID;
      }
    }
    res = this._callbackTemplate;
    return res;
  }
  async set_callbackTemplate(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("callbackTemplate", rest_val);
  }
  async get_callbackCredentials() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.CALLBACKCREDENTIALS_INVALID;
      }
    }
    res = this._callbackCredentials;
    return res;
  }
  async set_callbackCredentials(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("callbackCredentials", rest_val);
  }
  async callbackLogin(username, password) {
    let rest_val;
    rest_val = username + ":" + password;
    return await this._setAttr("callbackCredentials", rest_val);
  }
  async get_callbackInitialDelay() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.CALLBACKINITIALDELAY_INVALID;
      }
    }
    res = this._callbackInitialDelay;
    return res;
  }
  async set_callbackInitialDelay(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("callbackInitialDelay", rest_val);
  }
  async get_callbackSchedule() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.CALLBACKSCHEDULE_INVALID;
      }
    }
    res = this._callbackSchedule;
    return res;
  }
  async set_callbackSchedule(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("callbackSchedule", rest_val);
  }
  async get_callbackMinDelay() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.CALLBACKMINDELAY_INVALID;
      }
    }
    res = this._callbackMinDelay;
    return res;
  }
  async set_callbackMinDelay(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("callbackMinDelay", rest_val);
  }
  async get_callbackMaxDelay() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.CALLBACKMAXDELAY_INVALID;
      }
    }
    res = this._callbackMaxDelay;
    return res;
  }
  async set_callbackMaxDelay(newval) {
    let rest_val;
    rest_val = String(newval);
    return await this._setAttr("callbackMaxDelay", rest_val);
  }
  async get_poeCurrent() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YNetwork.POECURRENT_INVALID;
      }
    }
    res = this._poeCurrent;
    return res;
  }
  static FindNetwork(func) {
    let obj;
    obj = YFunction._FindFromCache("Network", func);
    if (obj == null) {
      obj = new YNetwork(YAPI, func);
      YFunction._AddToCache("Network", func, obj);
    }
    return obj;
  }
  static FindNetworkInContext(yctx, func) {
    let obj;
    obj = YFunction._FindFromCacheInContext(yctx, "Network", func);
    if (obj == null) {
      obj = new YNetwork(yctx, func);
      YFunction._AddToCache("Network", func, obj);
    }
    return obj;
  }
  async registerValueCallback(callback) {
    let val;
    if (callback != null) {
      await YFunction._UpdateValueCallbackList(this, true);
    } else {
      await YFunction._UpdateValueCallbackList(this, false);
    }
    this._valueCallbackNetwork = callback;
    if (callback != null && await this.isOnline()) {
      val = this._advertisedValue;
      if (!(val == "")) {
        await this._invokeValueCallback(val);
      }
    }
    return 0;
  }
  async _invokeValueCallback(value) {
    if (this._valueCallbackNetwork != null) {
      try {
        await this._valueCallbackNetwork(this, value);
      } catch (e) {
        this._yapi.imm_log("Exception in valueCallback:", e);
      }
    } else {
      await super._invokeValueCallback(value);
    }
    return 0;
  }
  async useDHCP(fallbackIpAddr, fallbackSubnetMaskLen, fallbackRouter) {
    return await this.set_ipConfig("DHCP:" + fallbackIpAddr + "/" + String(Math.round(fallbackSubnetMaskLen)) + "/" + fallbackRouter);
  }
  async useDHCPauto() {
    return await this.set_ipConfig("DHCP:");
  }
  async useStaticIP(ipAddress, subnetMaskLen, router) {
    return await this.set_ipConfig("STATIC:" + ipAddress + "/" + String(Math.round(subnetMaskLen)) + "/" + router);
  }
  async ping(host) {
    let content;
    content = await this._download("ping.txt?host=" + host);
    return this._yapi.imm_bin2str(content);
  }
  async triggerCallback() {
    return await this.set_callbackMethod(await this.get_callbackMethod());
  }
  async set_periodicCallbackSchedule(interval, offset) {
    return await this.set_callbackSchedule("every " + interval + "+" + String(Math.round(offset)));
  }
  nextNetwork() {
    let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
    if (resolve.errorType != YAPI.SUCCESS)
      return null;
    let next_hwid = this._yapi.imm_getNextHardwareId(this._className, resolve.result);
    if (next_hwid == null)
      return null;
    return YNetwork.FindNetworkInContext(this._yapi, next_hwid);
  }
  static FirstNetwork() {
    let next_hwid = YAPI.imm_getFirstHardwareId("Network");
    if (next_hwid == null)
      return null;
    return YNetwork.FindNetwork(next_hwid);
  }
  static FirstNetworkInContext(yctx) {
    let next_hwid = yctx.imm_getFirstHardwareId("Network");
    if (next_hwid == null)
      return null;
    return YNetwork.FindNetworkInContext(yctx, next_hwid);
  }
};
YNetwork.READINESS_DOWN = 0;
YNetwork.READINESS_EXISTS = 1;
YNetwork.READINESS_LINKED = 2;
YNetwork.READINESS_LAN_OK = 3;
YNetwork.READINESS_WWW_OK = 4;
YNetwork.READINESS_INVALID = -1;
YNetwork.MACADDRESS_INVALID = YAPI.INVALID_STRING;
YNetwork.IPADDRESS_INVALID = YAPI.INVALID_STRING;
YNetwork.SUBNETMASK_INVALID = YAPI.INVALID_STRING;
YNetwork.ROUTER_INVALID = YAPI.INVALID_STRING;
YNetwork.CURRENTDNS_INVALID = YAPI.INVALID_STRING;
YNetwork.IPCONFIG_INVALID = YAPI.INVALID_STRING;
YNetwork.PRIMARYDNS_INVALID = YAPI.INVALID_STRING;
YNetwork.SECONDARYDNS_INVALID = YAPI.INVALID_STRING;
YNetwork.NTPSERVER_INVALID = YAPI.INVALID_STRING;
YNetwork.USERPASSWORD_INVALID = YAPI.INVALID_STRING;
YNetwork.ADMINPASSWORD_INVALID = YAPI.INVALID_STRING;
YNetwork.HTTPPORT_INVALID = YAPI.INVALID_UINT;
YNetwork.DEFAULTPAGE_INVALID = YAPI.INVALID_STRING;
YNetwork.DISCOVERABLE_FALSE = 0;
YNetwork.DISCOVERABLE_TRUE = 1;
YNetwork.DISCOVERABLE_INVALID = -1;
YNetwork.WWWWATCHDOGDELAY_INVALID = YAPI.INVALID_UINT;
YNetwork.CALLBACKURL_INVALID = YAPI.INVALID_STRING;
YNetwork.CALLBACKMETHOD_POST = 0;
YNetwork.CALLBACKMETHOD_GET = 1;
YNetwork.CALLBACKMETHOD_PUT = 2;
YNetwork.CALLBACKMETHOD_INVALID = -1;
YNetwork.CALLBACKENCODING_FORM = 0;
YNetwork.CALLBACKENCODING_JSON = 1;
YNetwork.CALLBACKENCODING_JSON_ARRAY = 2;
YNetwork.CALLBACKENCODING_CSV = 3;
YNetwork.CALLBACKENCODING_YOCTO_API = 4;
YNetwork.CALLBACKENCODING_JSON_NUM = 5;
YNetwork.CALLBACKENCODING_EMONCMS = 6;
YNetwork.CALLBACKENCODING_AZURE = 7;
YNetwork.CALLBACKENCODING_INFLUXDB = 8;
YNetwork.CALLBACKENCODING_MQTT = 9;
YNetwork.CALLBACKENCODING_YOCTO_API_JZON = 10;
YNetwork.CALLBACKENCODING_PRTG = 11;
YNetwork.CALLBACKENCODING_INFLUXDB_V2 = 12;
YNetwork.CALLBACKENCODING_INVALID = -1;
YNetwork.CALLBACKTEMPLATE_OFF = 0;
YNetwork.CALLBACKTEMPLATE_ON = 1;
YNetwork.CALLBACKTEMPLATE_INVALID = -1;
YNetwork.CALLBACKCREDENTIALS_INVALID = YAPI.INVALID_STRING;
YNetwork.CALLBACKINITIALDELAY_INVALID = YAPI.INVALID_UINT;
YNetwork.CALLBACKSCHEDULE_INVALID = YAPI.INVALID_STRING;
YNetwork.CALLBACKMINDELAY_INVALID = YAPI.INVALID_UINT;
YNetwork.CALLBACKMAXDELAY_INVALID = YAPI.INVALID_UINT;
YNetwork.POECURRENT_INVALID = YAPI.INVALID_UINT;

// obj/full/Api/yocto_files.js
var YFileRecord = class {
  constructor(str_json) {
    this._name = "";
    this._size = 0;
    this._crc = 0;
    const loadval = JSON.parse(str_json);
    this._name = loadval.name;
    this._size = loadval.size;
    this._crc = loadval.crc;
  }
  get_name() {
    return this._name;
  }
  get_size() {
    return this._size;
  }
  get_crc() {
    return this._crc;
  }
};
var YFiles = class extends YFunction {
  constructor(yapi, func) {
    super(yapi, func);
    this._filesCount = YFiles.FILESCOUNT_INVALID;
    this._freeSpace = YFiles.FREESPACE_INVALID;
    this._valueCallbackFiles = null;
    this.FILESCOUNT_INVALID = YAPI.INVALID_UINT;
    this.FREESPACE_INVALID = YAPI.INVALID_UINT;
    this._className = "Files";
  }
  imm_parseAttr(name, val) {
    switch (name) {
      case "filesCount":
        this._filesCount = val;
        return 1;
      case "freeSpace":
        this._freeSpace = val;
        return 1;
    }
    return super.imm_parseAttr(name, val);
  }
  async get_filesCount() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YFiles.FILESCOUNT_INVALID;
      }
    }
    res = this._filesCount;
    return res;
  }
  async get_freeSpace() {
    let res;
    if (this._cacheExpiration <= this._yapi.GetTickCount()) {
      if (await this.load(this._yapi.defaultCacheValidity) != this._yapi.SUCCESS) {
        return YFiles.FREESPACE_INVALID;
      }
    }
    res = this._freeSpace;
    return res;
  }
  static FindFiles(func) {
    let obj;
    obj = YFunction._FindFromCache("Files", func);
    if (obj == null) {
      obj = new YFiles(YAPI, func);
      YFunction._AddToCache("Files", func, obj);
    }
    return obj;
  }
  static FindFilesInContext(yctx, func) {
    let obj;
    obj = YFunction._FindFromCacheInContext(yctx, "Files", func);
    if (obj == null) {
      obj = new YFiles(yctx, func);
      YFunction._AddToCache("Files", func, obj);
    }
    return obj;
  }
  async registerValueCallback(callback) {
    let val;
    if (callback != null) {
      await YFunction._UpdateValueCallbackList(this, true);
    } else {
      await YFunction._UpdateValueCallbackList(this, false);
    }
    this._valueCallbackFiles = callback;
    if (callback != null && await this.isOnline()) {
      val = this._advertisedValue;
      if (!(val == "")) {
        await this._invokeValueCallback(val);
      }
    }
    return 0;
  }
  async _invokeValueCallback(value) {
    if (this._valueCallbackFiles != null) {
      try {
        await this._valueCallbackFiles(this, value);
      } catch (e) {
        this._yapi.imm_log("Exception in valueCallback:", e);
      }
    } else {
      await super._invokeValueCallback(value);
    }
    return 0;
  }
  async sendCommand(command) {
    let url;
    url = "files.json?a=" + command;
    return await this._download(url);
  }
  async format_fs() {
    let json;
    let res;
    json = await this.sendCommand("format");
    res = this.imm_json_get_key(json, "res");
    if (!(res == "ok")) {
      return this._throw(this._yapi.IO_ERROR, "format failed", this._yapi.IO_ERROR);
    }
    return this._yapi.SUCCESS;
  }
  async get_list(pattern) {
    let json;
    let filelist = [];
    let res = [];
    json = await this.sendCommand("dir&f=" + pattern);
    filelist = this.imm_json_get_array(json);
    res.length = 0;
    for (let ii in filelist) {
      res.push(new YFileRecord(filelist[ii]));
    }
    return res;
  }
  async fileExist(filename) {
    let json;
    let filelist = [];
    if (filename.length == 0) {
      return false;
    }
    json = await this.sendCommand("dir&f=" + filename);
    filelist = this.imm_json_get_array(json);
    if (filelist.length > 0) {
      return true;
    }
    return false;
  }
  async download(pathname) {
    return await this._download(pathname);
  }
  async upload(pathname, content) {
    return await this._upload(pathname, content);
  }
  async remove(pathname) {
    let json;
    let res;
    json = await this.sendCommand("del&f=" + pathname);
    res = this.imm_json_get_key(json, "res");
    if (!(res == "ok")) {
      return this._throw(this._yapi.IO_ERROR, "unable to remove file", this._yapi.IO_ERROR);
    }
    return this._yapi.SUCCESS;
  }
  nextFiles() {
    let resolve = this._yapi.imm_resolveFunction(this._className, this._func);
    if (resolve.errorType != YAPI.SUCCESS)
      return null;
    let next_hwid = this._yapi.imm_getNextHardwareId(this._className, resolve.result);
    if (next_hwid == null)
      return null;
    return YFiles.FindFilesInContext(this._yapi, next_hwid);
  }
  static FirstFiles() {
    let next_hwid = YAPI.imm_getFirstHardwareId("Files");
    if (next_hwid == null)
      return null;
    return YFiles.FindFiles(next_hwid);
  }
  static FirstFilesInContext(yctx) {
    let next_hwid = yctx.imm_getFirstHardwareId("Files");
    if (next_hwid == null)
      return null;
    return YFiles.FindFilesInContext(yctx, next_hwid);
  }
};
YFiles.FILESCOUNT_INVALID = YAPI.INVALID_UINT;
YFiles.FREESPACE_INVALID = YAPI.INVALID_UINT;

// obj/full/constants.js
var constants = class {
  static get buildVersion() {
    return "1.10.56436";
  }
  static get deviceScreenWidth() {
    return screen.width * window.devicePixelRatio;
  }
  static get deviceScreenHeight() {
    return screen.height * window.devicePixelRatio;
  }
  static get isPhoneOrTablet() {
    return constants.ScreenDPI > 96 && Math.max(constants.deviceScreenWidth, constants.deviceScreenHeight) / constants.ScreenDPI < 12;
  }
  static get captureSizePolicy() {
    return constants._defaultCaptureSizePolicy;
  }
  static set captureSizePolicy(value) {
    constants._defaultCaptureSizePolicy = value;
  }
  static get dbleClickBringsUpContextMenu() {
    return constants._defaulDbleClickBringsUpContextMenu;
  }
  static set dbleClickBringsUpContextMenu(value) {
    constants._defaulDbleClickBringsUpContextMenu = value;
  }
  static get maxPointsPerGraphSerie() {
    return constants._defaultMaxPointsPerGraphSerie;
  }
  static set maxPointsPerGraphSerie(value) {
    if (value >= 0)
      constants._defaultMaxPointsPerGraphSerie = value >> 0;
  }
  static get maxPointsPerDataloggerSerie() {
    return constants._defaultMaxPointsPerDataloggerSerie;
  }
  static set maxPointsPerDataloggerSerie(value) {
    if (value >= -1)
      constants._defaultMaxPointsPerDataloggerSerie = value >> 0;
  }
  static get maxDataRecordsPerSensor() {
    return constants._defaultMaxDataRecordsPerSensor;
  }
  static set maxDataRecordsPerSensor(value) {
    if (value >= 0)
      constants._defaultMaxDataRecordsPerSensor = value >> 0;
  }
  static get captureWidth() {
    return constants._defaultCaptureWidth;
  }
  static set captureWidth(value) {
    if (value > 0)
      constants._defaultCaptureWidth = value;
  }
  static get captureHeight() {
    return constants._defaultCaptureHeight;
  }
  static set captureHeight(value) {
    if (value > 0)
      constants._defaultCaptureHeight = value;
  }
  static get captureDPI() {
    return constants._defaultCaptureDPI;
  }
  static set captureDPI(value) {
    if (value > 0)
      constants._defaultCaptureDPI = value;
  }
  static get captureType() {
    return constants._defaultCaptureType;
  }
  static set captureType(value) {
    constants._defaultCaptureType = value;
  }
  static get generalFontFamily() {
    return constants.FontFamily;
  }
  static get generalFontSize() {
    return constants.FontSize;
  }
  static get generalSizeCoef() {
    return constants.FontSize / 12;
  }
  static get screenDPI() {
    return constants.ScreenDPI;
  }
  static get guiDPIFactor() {
    return constants.DPIfactor;
  }
  static get guiDPIFactorWasOverriden() {
    return constants.DPIfactorOverriden;
  }
  static get guiDPIFactorIsOverriden() {
    let vs = constants.getCookie(constants.DPIFactorKey);
    if (vs == null)
      return false;
    let v = parseFloat(vs);
    if (v > 0)
      return true;
    return false;
  }
  static get guiDPIFactorOverrideValue() {
    let vs = constants.getCookie(constants.DPIFactorKey);
    if (vs == null)
      return constants.DPIfactor;
    let v = parseFloat(vs);
    if (v > 0)
      return v;
    return constants.DPIfactor;
  }
  static overrideGuiDPIFactor(override, value) {
    if (override && typeof value !== "undefined") {
      constants.setCookie(constants.DPIFactorKey, value.toString(), 3650);
    } else {
      constants.setCookie(constants.DPIFactorKey, "none", 3650);
    }
  }
  static get RunningOnAndroid() {
    return constants.isAndroid;
  }
  static get WindowBackgroundColor() {
    return "#f0f0f0";
  }
  static get WindowBorder() {
    return "1px solid #808080";
  }
  static get WindowPadding() {
    return 2;
  }
  static get WindowInnerBorderColor() {
    return " #A0A0A0";
  }
  static get WindowInnerBackgroundColor() {
    return "#fAfAfA";
  }
  static get WindowInnerBorder() {
    return "1px solid " + constants.WindowInnerBorderColor;
  }
  static get WindowHeaderBackgroundColor() {
    return "#0072ca";
  }
  static get WindowHeaderColor() {
    return "white";
  }
  static get WindowHeaderBorder() {
    return "1px solid #0072ca";
  }
  static get WindowHeaderHeight() {
    return 20;
  }
  static get WindowHeaderFontSize() {
    return 8 * constants.FontSize / 6;
  }
  static get WindowHeaderFontFamily() {
    return constants.FontFamily;
  }
  static get mustCheckForUpdate() {
    return constants._checkForUpdate;
  }
  static set mustCheckForUpdate(value) {
    if (value != constants._checkForUpdate) {
      constants._checkForUpdate = value;
      constants.edited = true;
    }
  }
  static get edited() {
    return constants._edited;
  }
  static set edited(value) {
    if (constants._edited != value) {
      constants._edited = value;
      YWebPage.ShowSaveReminder(value);
    }
  }
  static InitColorHistory(node) {
    let nodes = node.get_childsByIndex();
    for (let i = 0; i < nodes.length; i++) {
      let node2 = nodes[i];
      switch (nodes[i].Name) {
        case "Color":
          try {
            let colordef = node2.Attributes["value"];
            let color = YColor.FromString(colordef);
            if (color != null)
              colorEditor.AddColorToHistory(color);
          } catch (_a) {
          }
      }
    }
  }
  static findDPI() {
    let DPI = 1;
    while (!matchMedia("(max-resolution: " + DPI.toString() + "dpi)").matches) {
      DPI = DPI << 1;
    }
    let a = DPI >> 1;
    let b = DPI;
    while (b - a > 1) {
      let pivot = b + a >> 1;
      if (matchMedia("(max-resolution: " + pivot.toString() + "dpi)").matches) {
        b = pivot;
      } else {
        a = pivot;
      }
    }
    return b * (constants.isAndroid ? window.devicePixelRatio : 1);
  }
  static InitCaptureParams(node) {
    let nodes = node.get_childsByName();
    for (let nodeName in nodes) {
      let node2 = nodes[nodeName];
      let value;
      switch (nodeName) {
        case "Target":
          if ("value" in node2.Attributes) {
            constants._captureTarget = YDataRenderer.CaptureTarget.fromString(YDataRenderer.CaptureTarget, node2.Attributes["value"]);
          }
          break;
        case "Type":
          if ("value" in node2.Attributes) {
            constants._defaultCaptureType = YDataRenderer.CaptureType.fromString(YDataRenderer.CaptureType, node2.Attributes["value"]);
          }
          break;
        case "Size":
          if ("value" in node2.Attributes) {
            constants._defaultCaptureSizePolicy = YDataRenderer.CaptureFormats.fromString(YDataRenderer.CaptureFormats, node2.Attributes["value"]);
          }
          break;
        case "Resolution":
          if ("value" in node2.Attributes) {
            constants.captureDPI = parseInt(node2.Attributes["value"]);
          }
          break;
        case "Width":
          if ("value" in node2.Attributes) {
            constants.captureWidth = value = parseInt(node2.Attributes["value"]);
          }
          break;
        case "Height":
          if ("value" in node2.Attributes) {
            constants.captureHeight = parseInt(node2.Attributes["value"]);
          }
          break;
        case "Folder":
          if ("value" in node2.Attributes) {
            constants._captureFolder = node2.Attributes["value"];
          }
          break;
      }
    }
  }
  static InitUIParams(node) {
    let nodes = node.get_childsByName();
    for (let nodeName in nodes) {
      let node2 = nodes[nodeName];
      switch (nodeName) {
        case "VerticalDragZoom":
          if ("value" in node2.Attributes) {
            YGraph.verticalDragZoomEnabled = node2.Attributes["value"].toUpperCase() == "TRUE";
          }
          break;
        case "DbleClickContextMenu":
          if ("value" in node2.Attributes) {
            constants.dbleClickBringsUpContextMenu = node2.Attributes["value"].toUpperCase() == "TRUE";
          }
          break;
      }
    }
  }
  static InitCheckForUpdateParams(node) {
    let nodes = node.get_childsByName();
    for (let nodeName in nodes) {
      let node2 = nodes[nodeName];
      switch (nodeName) {
        case "checkForUpdate":
          if ("value" in node2.Attributes) {
            constants._checkForUpdate = node2.Attributes["value"].toUpperCase() == "TRUE";
          }
          break;
        case "ignoreBuild":
          if ("value" in node2.Attributes) {
            constants._ignoreBuild = parseInt(node2.Attributes["value"].toUpperCase());
          }
          break;
      }
    }
  }
  static InitMemoryUsageParams(node) {
    let nodes = node.get_childsByName();
    for (let nodeName in nodes) {
      let node2 = nodes[nodeName];
      switch (nodeName) {
        case "maxPointsPerGraphSerie":
          if ("value" in node2.Attributes) {
            let value = parseInt(node2.Attributes["value"]);
            constants.maxPointsPerGraphSerie = value;
            DataSerie.MaxPointsPerSeries = value;
          }
          break;
        case "maxDataRecordsPerSensor":
          if ("value" in node2.Attributes) {
            let value = parseInt(node2.Attributes["value"]);
            if (value >= 0) {
              constants.maxDataRecordsPerSensor = value;
              CustomYSensor.MaxDataRecords = value;
            }
          }
          break;
        case "maxPointsPerDataloggerSerie":
          if ("value" in node2.Attributes) {
            let value = parseInt(node2.Attributes["value"]);
            constants.maxPointsPerDataloggerSerie = value;
            CustomYSensor.MaxLoggerRecords = value;
          }
          break;
        case "deviceListValidity":
          if ("value" in node2.Attributes) {
            let value = parseInt(node2.Attributes["value"]);
            if (value > 0) {
              constants._deviceListValidity = value;
              YAPI.SetDeviceListValidity(value).then();
            }
          }
          break;
      }
    }
  }
  static Init(initData) {
    let nodes = initData.get_childsByName();
    for (let nodeName in nodes) {
      let node = nodes[nodeName];
      switch (nodeName) {
        case "UseUSB":
          if ("value" in node.Attributes) {
            constants._useUSB = node.Attributes["value"].toUpperCase() == "TRUE";
          }
          break;
        case "Colors":
          constants.InitColorHistory(node);
          break;
        case "Capture":
          constants.InitCaptureParams(node);
          break;
        case "UI":
          constants.InitUIParams(node);
          break;
        case "Updates":
          constants.InitCheckForUpdateParams(node);
          break;
        case "MemoryUsage":
          constants.InitMemoryUsageParams(node);
          break;
        case "UseVirtualHub":
          if ("value" in node.Attributes) {
            constants._useVirtualHub = node.Attributes["value"].toUpperCase() == "TRUE";
          }
          break;
        case "Hubs":
          sensorsManager.InitHubList(node);
          break;
      }
    }
  }
  static get CRCTable() {
    if (constants._crcTable != null)
      return constants._crcTable;
    constants._crcTable = [];
    let c;
    var crcTable = [];
    for (var n = 0; n < 256; n++) {
      c = n;
      for (var k = 0; k < 8; k++) {
        c = c & 1 ? 3988292384 ^ c >>> 1 : c >>> 1;
      }
      constants._crcTable[n] = c;
    }
    return constants._crcTable;
  }
  static crc32(str) {
    var crcTable = constants.CRCTable;
    var crc = 0 ^ -1;
    for (var i = 0; i < str.length; i++) {
      crc = crc >>> 8 ^ crcTable[(crc ^ str.charCodeAt(i)) & 255];
    }
    return (crc ^ -1) >>> 0;
  }
  static setCookie(cname, cvalue, exdays) {
    let d = new Date();
    d.setTime(d.getTime() + exdays * 24 * 60 * 60 * 1e3);
    let expires = "expires=" + d.toUTCString();
    document.cookie = cname + "=" + cvalue + ";" + expires + ";path=/";
  }
  static getCookie(cname) {
    let name = cname + "=";
    let decodedCookie = decodeURIComponent(document.cookie);
    let ca = decodedCookie.split(";");
    for (let i = 0; i < ca.length; i++) {
      let c = ca[i];
      while (c.charAt(0) == " ") {
        c = c.substring(1);
      }
      if (c.indexOf(name) == 0) {
        return c.substring(name.length, c.length);
      }
    }
    return null;
  }
  static XMLquote(st) {
    return st.replace("'", "&apos;").replace('"', "&quot;");
  }
  static GetXMLConfiguration() {
    let res = '<Config>\n  <UseUSB value="' + (constants._useUSB ? "TRUE" : "FALSE") + '"/>\n  <UseVirtualHub value="' + (constants._useVirtualHub ? "TRUE" : "FALSE") + '"/>\n  <Hubs>\n';
    res += sensorsManager.getXmlHublist();
    res += "  </Hubs>\n";
    res += "  <Colors>\n";
    for (let i = 0; i < colorEditor.colorHistory.length; i++) {
      res = res + '    <Color value="' + colorEditor.colorHistory[i].toString() + '"/>\n';
    }
    res += "  </Colors>\n";
    res += "  <MemoryUsage>\n";
    res += '    <maxPointsPerGraphSerie value= "' + constants.maxPointsPerGraphSerie.toString() + '"/>\n';
    res += '    <maxDataRecordsPerSensor value= "' + constants.maxDataRecordsPerSensor.toString() + '"/>\n';
    res += '    <maxPointsPerDataloggerSerie value= "' + constants.maxPointsPerDataloggerSerie.toString() + '"/>\n';
    res += '    <deviceListValidity value= "' + constants._deviceListValidity.toString() + '"/>\n';
    res += "  </MemoryUsage>\n";
    res += "  <Capture>\n";
    res += '    <Target value= "' + constants._captureTarget.toString + '"/>\n';
    res += '    <Type value= "' + constants.captureType.toString + '"/>\n';
    res += '    <Size value= "' + constants.captureSizePolicy.toString + '"/>\n';
    res += '    <Resolution value= "' + constants.captureDPI.toString() + '"/>\n';
    res += '    <Folder value= "' + constants.XMLquote(constants._captureFolder) + '"/>\n';
    res += '    <Width value= "' + constants.captureWidth.toString() + '"/>\n';
    res += '    <Height value= "' + constants.captureHeight.toString() + '"/>\n';
    res += "  </Capture>\n";
    res += "  <Updates>\n";
    res += '    <checkForUpdate  value = "' + (constants._checkForUpdate ? "True" : "False") + '"/>\n';
    res += '    <ignoreBuild  value = "' + constants._ignoreBuild.toString() + '"/>\n';
    res += "  </Updates>\n";
    res += "  <UI>\n";
    res += '    <VerticalDragZoom value= "' + (YGraph.verticalDragZoomEnabled ? "True" : "False") + '"/>\n';
    res += '    <DbleClickContextMenu value= "' + (constants.dbleClickBringsUpContextMenu ? "True" : "False") + '"/>\n';
    res += "  </UI>\n";
    res += "</Config>\n";
    return res;
  }
};
constants.DPIFactorKey = "YoctoVisualization4WebDPIFactor";
constants.isAndroid = navigator.userAgent.toLowerCase().indexOf("android") >= 0;
constants.ScreenDPI = constants.findDPI();
constants.FontFamily = "Arial, Helvetica, sans-serif";
constants.DPIfactorCookieValue = constants.getCookie(constants.DPIFactorKey);
constants.DPIfactorOverriden = constants.DPIfactorCookieValue != null;
constants.DPIfactor = constants.DPIfactorOverriden && parseFloat(constants.DPIfactorCookieValue) > 0 ? parseFloat(constants.DPIfactorCookieValue) : constants.isPhoneOrTablet ? Math.round(10 * constants.ScreenDPI / (96 * 1.2)) / 10 : 1;
constants.FontSize = 12 * constants.DPIfactor;
constants._defaultCaptureType = YDataRenderer.CaptureType.PNG;
constants._defaultCaptureWidth = 1024;
constants._defaultCaptureHeight = 1024;
constants._defaultCaptureDPI = 70;
constants._defaultCaptureSizePolicy = YDataRenderer.CaptureFormats.Keep;
constants._defaultMaxPointsPerGraphSerie = 0;
constants._defaultMaxPointsPerDataloggerSerie = 0;
constants._defaultMaxDataRecordsPerSensor = 0;
constants._defaulDbleClickBringsUpContextMenu = false;
constants._useUSB = true;
constants._useVirtualHub = false;
constants._captureTarget = YDataRenderer.CaptureTarget.ToFile;
constants._captureFolder = "";
constants._checkForUpdate = true;
constants._ignoreBuild = 0;
constants._deviceListValidity = 3600;
constants._edited = false;
constants._crcTable = null;

// obj/full/sensorManager.js
var Hub = class {
  static Decrypt(data, loginCypherPassword) {
    if (data == "")
      return "";
    if (data.length % 4)
      return "";
    let buffer = new Uint16Array(data.length >> 2);
    for (let i = 0; i < buffer.length; i++) {
      buffer[i] = parseInt(data.slice(i * 4, i * 4 + 4), 16);
    }
    let checksum = buffer[0];
    for (let i = 1; i < buffer.length - 1; i++) {
      checksum ^= buffer[i];
    }
    if (checksum != buffer[buffer.length - 1])
      return "";
    let res = "";
    for (let i = 0; i < buffer.length - 2; i++) {
      res += String.fromCharCode(buffer[i + 1] & 255 ^ loginCypherPassword.charCodeAt(i % loginCypherPassword.length) ^ buffer[0] + i & 255 ^ (buffer[i + 1] & 2048) >> 11 << ((buffer[i + 1] & 1792) >> 8) ^ (buffer[i + 1] & 32768) >> 15 << ((buffer[i + 1] & 28672) >> 12));
    }
    return res;
  }
  static Encrypt(data, loginCypherPassword) {
    if (data == "")
      return "";
    let buffer = crypto.getRandomValues(new Uint16Array(data.length + 2));
    for (let i = 0; i < data.length; i++) {
      buffer[i + 1] = buffer[i + 1] & 65280 | data.charCodeAt(i) ^ loginCypherPassword.charCodeAt(i % loginCypherPassword.length) ^ buffer[0] + i & 255 ^ (buffer[i + 1] & 2048) >> 11 << ((buffer[i + 1] & 1792) >> 8) ^ (buffer[i + 1] & 32768) >> 15 << ((buffer[i + 1] & 28672) >> 12);
    }
    buffer[buffer.length - 1] = buffer[0];
    for (let i = 1; i < buffer.length - 1; i++) {
      buffer[buffer.length - 1] ^= buffer[i];
    }
    let res = "";
    for (let i = 0; i < buffer.length; i++) {
      res += ("000" + buffer[i].toString(16)).slice(-4).toUpperCase();
    }
    return res;
  }
  static encryptPassword(clearPassword) {
    return clearPassword == "" ? "" : Hub.Encrypt(clearPassword, Hub.loginCypherPassword);
  }
  get hubType() {
    return this._hubType;
  }
  set hubType(value) {
    this._hubType = value;
  }
  get protocol() {
    return this._protocol;
  }
  set protocol(value) {
    this._protocol = value;
  }
  get user() {
    return this._user;
  }
  set user(value) {
    this._user = value;
  }
  get encryptedPassword() {
    return this._password;
  }
  set encryptedPassword(value) {
    this._password = value;
  }
  get clearPassword() {
    return this._password == "" ? "" : Hub.Decrypt(this._password, Hub.loginCypherPassword);
  }
  set clearPassword(value) {
    this._password = value == "" ? "" : Hub.encryptPassword(value);
  }
  get addr() {
    return this._addr;
  }
  set addr(value) {
    this._addr = value;
  }
  get port() {
    return this._port;
  }
  set port(value) {
    this._port = value;
  }
  get removable() {
    return this._removable;
  }
  set removable(value) {
    this._removable = value;
  }
  get path() {
    return this._path;
  }
  set path(value) {
    this._path = value;
  }
  get ConnectionState() {
    return this._state;
  }
  get ConnectionDescription() {
    switch (this._state) {
      case 1:
        return "Connecting..";
      case 2:
        return (this._logicname != "" ? this._logicname : this._netname) + " OK";
      case 3:
        return "Connection failed ";
      default:
        return "Not connected.";
    }
  }
  constructor(hubType, protocol, user, password, clearPassword, addr, port, path, removeable) {
    this._netname = "";
    this._module = null;
    this._logicname = "";
    this._previousURL = "";
    this._previousobfuscatedURL = "";
    this._hubType = 2;
    this._protocol = "";
    this._user = "";
    this._password = "";
    this._addr = "";
    this._port = "";
    this._removable = true;
    this._path = "";
    this._state = 0;
    while (/^\//.test(path)) {
      path = path.slice(1);
    }
    while (/\/$/.test(path)) {
      path = path.slice(0, -1);
    }
    this._hubType = hubType;
    this._protocol = protocol;
    this._user = user;
    this._port = port;
    this._password = clearPassword ? password != "" ? Hub.Encrypt(password, Hub.loginCypherPassword) : "" : password;
    this._addr = addr;
    this._path = path;
    this._removable = typeof removeable === "undefined" ? true : removeable;
  }
  static HubFromXml(subnode) {
    let hubType = 2;
    let protocol = "ws";
    let removable = true;
    if ("protocol" in subnode.Attributes)
      protocol = subnode.Attributes["protocol"];
    let user = "";
    if ("user" in subnode.Attributes)
      user = subnode.Attributes["user"];
    let password = "";
    if ("password" in subnode.Attributes)
      password = subnode.Attributes["password"];
    let port = "";
    if ("port" in subnode.Attributes)
      port = subnode.Attributes["port"];
    let path = "";
    if ("path" in subnode.Attributes)
      path = subnode.Attributes["path"];
    let addr = "";
    if ("addr" in subnode.Attributes)
      addr = subnode.Attributes["addr"];
    if ("removable" in subnode.Attributes)
      removable = subnode.Attributes["removable"].toUpperCase() == "TRUE";
    return new Hub(hubType, protocol, user, password, false, addr, port, path, removable);
  }
  async Connect() {
    let errmsg = new YErrorMsg();
    this._state = 1;
    logForm.log("preregistering  " + this.get_obfuscatedURL());
    if (!YWebPage.readonly)
      configForm.hubStateChanged(this);
    let url = this.get_fullUrl();
    if (await YAPI.PreregisterHub(url, errmsg) != YAPI_SUCCESS) {
      logForm.log("[!] preregistering  " + this.get_obfuscatedURL() + " failed (" + errmsg.msg + ")");
      this._state = 3;
      this._previousURL = "";
      this._previousobfuscatedURL = "";
    } else {
      this._previousURL = url;
      this._previousobfuscatedURL = this.get_obfuscatedURL();
    }
    if (!YWebPage.readonly)
      configForm.hubStateChanged(this);
  }
  async Disconnect() {
    if (this._previousURL == "")
      return;
    logForm.log("Unregistering  " + this._previousobfuscatedURL);
    await YAPI.UnregisterHub(this._previousURL);
    this._previousURL = "";
    this._previousobfuscatedURL = "";
    this._state = 0;
    if (!YWebPage.readonly)
      configForm.hubStateChanged(this);
  }
  arrival(ip, netname, module, logicname) {
    this._state = 2;
    this._netname = netname;
    this._module = module;
    this._logicname = logicname;
    this._state = 2;
    if (!YWebPage.readonly) {
      configForm.hubStateChanged(this);
    }
  }
  get address() {
    return this._addr;
  }
  get_consoleUrl() {
    let fullurl = this._protocol + "://" + this._addr;
    if (this._port != "")
      fullurl = fullurl + ":" + this._port;
    return fullurl;
  }
  toString() {
    return this.get_consoleUrl();
  }
  get_fullUrl() {
    let fullurl = "";
    if (this._protocol != "")
      fullurl = this._protocol + "://";
    if (this._user != "") {
      fullurl = fullurl + this._user;
      if (this._password != "")
        fullurl = fullurl + ":" + Hub.Decrypt(this._password, Hub.loginCypherPassword);
      fullurl = fullurl + "@";
    }
    fullurl = fullurl + this._addr;
    if (this._port != "")
      fullurl = fullurl + ":" + this._port;
    else
      fullurl = fullurl + ":4444";
    fullurl = fullurl + "/";
    if (this._path) {
      fullurl = fullurl + this._path + "/";
    }
    return fullurl;
  }
  get_connexionUrl() {
    let fullurl;
    if (this._protocol != "")
      fullurl = this._protocol + "://";
    else
      fullurl = "ws://";
    fullurl = fullurl + this._addr;
    if (this._port != "")
      fullurl = fullurl + ":" + this._port;
    else
      fullurl = fullurl + ":4444";
    fullurl = fullurl + "/";
    return fullurl.toLowerCase();
  }
  get_obfuscatedURL() {
    let fullurl = "";
    if (this._protocol != "")
      fullurl = this._protocol + "://";
    if (this._user != "") {
      fullurl = fullurl + this._user;
      if (this._password != "")
        fullurl = fullurl + ":#####";
      fullurl = fullurl + "@";
    }
    fullurl = fullurl + this._addr;
    if (this._port != "")
      fullurl = fullurl + ":" + this._port;
    if (this._path != "")
      fullurl = fullurl + "/" + this._path;
    return fullurl;
  }
  XmlCode() {
    let NodeLine = "<Hub ";
    if (this._protocol != "")
      NodeLine = NodeLine + 'protocol="' + constants.XMLquote(this._protocol) + '" ';
    if (this._user != "")
      NodeLine = NodeLine + 'user="' + constants.XMLquote(this._user) + '" ';
    if (this._password != "")
      NodeLine = NodeLine + 'password="' + constants.XMLquote(this._password) + '" ';
    NodeLine = NodeLine + 'addr="' + constants.XMLquote(this._addr) + '" ';
    if (this._port != "")
      NodeLine = NodeLine + 'port="' + constants.XMLquote(this.port) + '" ';
    if (this._path != "")
      NodeLine = NodeLine + 'path="' + constants.XMLquote(this._path) + '" ';
    if (!this._removable)
      NodeLine = NodeLine + 'removable="FALSE" ';
    return NodeLine + "/>";
  }
};
Hub.loginCypherPassword = "+>*X[?_ih$N7wA!}";
var TimedSensorValue = class {
  constructor(DateTime, value) {
    this._DateTime = DateTime;
    this._value = value;
  }
  get DateTime() {
    return this._DateTime;
  }
  get value() {
    return this._value;
  }
};
var AlarmSettings = class {
  static ExecuteCommand(source, command) {
  }
  constructor(index, owner, xmldata) {
    this.index = 0;
    this.Condition = 0;
    this.Source = 0;
    this.Value = 0;
    this.Delay = 15;
    this.Commandline = "";
    this.lastAlarm = new Date(0);
    this.index = index;
    this.parent = owner;
    if (typeof xmldata !== "undefined") {
      if ("Source" in xmldata.Attributes)
        this.Source = parseInt(xmldata.Attributes["Source"]);
      if ("Condition" in xmldata.Attributes)
        this.Condition = parseInt(xmldata.Attributes["Condition"]);
      if ("Value" in xmldata.Attributes)
        this.Value = parseFloat(xmldata.Attributes["Value"]);
      if ("Cmd" in xmldata.Attributes)
        this.Commandline = xmldata.Attributes["Cmd"];
      if ("Delay" in xmldata.Attributes)
        this.Delay = parseInt(xmldata.Attributes["Delay"]);
    }
  }
  getXmlData() {
    return '<Alarm Source="' + this.Source.toString() + '" Condition="' + this.Condition.toString() + '" Value="' + this.Value.toString() + '" Cmd="' + GenericProperties.escapeXml(this.Commandline) + '" Delay="' + this.Delay.toString() + '"/>\n';
  }
  setCondition(condition) {
    this.Condition = condition;
  }
  getCondition() {
    return this.Condition;
  }
  setSource(source) {
    this.Source = source;
  }
  getSource() {
    return this.Source;
  }
  setValue(value) {
    this.Value = value;
  }
  getValue() {
    return this.Value;
  }
  setDelay(value) {
    if (value < 0)
      throw "delay must be a positive value";
    this.Delay = value;
  }
  getDelay() {
    return this.Delay;
  }
  setCommandline(value) {
    this.Commandline = value;
  }
  getCommandline() {
    return this.Commandline;
  }
  check(m) {
    let alarm = false;
    let reason = "";
    let src;
    let SensorValue;
    switch (this.Source) {
      case 1:
        src = "MIN";
        SensorValue = m.get_minValue();
        break;
      case 2:
        src = "MAX";
        SensorValue = m.get_maxValue();
        break;
      default:
        src = "AVG";
        SensorValue = m.get_averageValue();
        break;
    }
    switch (this.Condition) {
      default:
        return;
      case 1:
        reason = ">";
        if (SensorValue > this.Value)
          alarm = true;
        break;
      case 2:
        reason = ">=";
        if (SensorValue >= this.Value)
          alarm = true;
        break;
      case 3:
        reason = "=";
        if (SensorValue == this.Value)
          alarm = true;
        break;
      case 4:
        reason = "<=";
        if (SensorValue <= this.Value)
          alarm = true;
        break;
      case 5:
        reason = "<";
        if (SensorValue < this.Value)
          alarm = true;
        break;
    }
    let now = new Date();
    if (!alarm)
      return;
    if (now.getTime() - this.lastAlarm.getTime() < 1e3 * this.Delay)
      return;
    let source = "ALARM " + (this.index + 1).toString();
    logForm.log(source + " on " + this.parent.get_hardwareId() + "/" + this.parent.get_friendlyName() + " (" + SensorValue.toString() + reason + this.Value.toString() + ")");
    let Execute = this.Commandline;
    Execute = Execute.replace("$SENSORVALUE$", SensorValue.toString());
    Execute = Execute.replace("$HWDID$", this.parent.get_hardwareId());
    Execute = Execute.replace("$NAME$", this.parent.get_friendlyName());
    Execute = Execute.replace("$UNIT$", this.parent.get_unit());
    Execute = Execute.replace("$CONDITION$", reason);
    Execute = Execute.replace("$DATATYPE$", src);
    Execute = Execute.replace("$TRIGGER$", this.Value.toString());
    Execute = Execute.replace("$NOW$", logForm.dateToString(now));
    try {
      Function(Execute)();
    } catch (e) {
      logForm.log("ALARM " + (this.index + 1) + " code (" + Execute + ") caused an exception :" + e.message);
    }
    this.lastAlarm = now;
  }
};
var DataLoggerBoundary = class {
  constructor(start, stop) {
    this._start = 0;
    this._stop = 0;
    this._start = start;
    this._stop = stop;
  }
  get start() {
    return this._start;
  }
  get stop() {
    return this._stop;
  }
};
var MergeSourceRange = class {
  constructor(start, stop) {
    this.MergeSourceStart = 0;
    this.MergeSourceStop = 0;
    this.MergeSourceStart = start;
    this.MergeSourceStop = stop;
  }
};
var CustomYSensor = class {
  get isReadOnly() {
    return this._readonly || !this._online;
  }
  get dataloggerLoadisRunning() {
    return this._dataloggerLoadisRunning;
  }
  get dataloggerLoadProgress() {
    return this._dataloggerLoadProgress;
  }
  setDataloggerLoadProgress(value) {
    this._dataloggerLoadProgress = value;
    for (let i = 0; i < this.FormsToNotify.length; i++) {
      if (this.FormsToNotify[i] instanceof graphWidget) {
        this.FormsToNotify[i].dataLoggerLoadprocessIsRunningNotification(this);
      }
    }
  }
  static get MaxDataRecords() {
    return CustomYSensor._MaxDataRecords;
  }
  static set MaxDataRecords(value) {
    CustomYSensor._MaxDataRecords = value;
  }
  static get MaxLoggerRecords() {
    return CustomYSensor._MaxLoggerRecords;
  }
  static set MaxLoggerRecords(value) {
    CustomYSensor._MaxLoggerRecords = value;
  }
  get_lastAvgValue() {
    if (this._online)
      return this._lastAvgValue;
    return Number.NaN;
  }
  get_lastMaxValue() {
    if (this._online)
      return this._lastMaxValue;
    return Number.NaN;
  }
  get_lastMinValue() {
    if (this._online)
      return this._lastMinValue;
    return Number.NaN;
  }
  async ConfigHasChanged() {
    this.cfgChgNotificationsSupported = true;
    this.mustReloadConfig = true;
    this._online = true;
    await this.reloadConfig();
    await this.forceUpdate();
  }
  constructor(s, name, SensorLocalConfig) {
    this.unit = "";
    this._frequency = "";
    this.resolution = 1;
    this._recording = false;
    this._online = false;
    this.preloadDone = false;
    this.loadDone = false;
    this.cfgChgNotificationsSupported = false;
    this.mustReloadConfig = false;
    this._readonly = false;
    this._plzCancelDataloggerLoading = false;
    this._predloadProcessIsBusy = false;
    this._loadProcessIsBusy = false;
    this.lastGetConfig = 0;
    this.recordedDataLoadProgress = 0;
    this.recordedData = null;
    this.dataLoggerFeature = false;
    this.dataLoggerLoadCompleted = false;
    this.loadFailed = false;
    this.loadCanceled = false;
    this.firstLiveDataTimeStamp = 0;
    this.firstDataloggerTimeStamp = 0;
    this.lastDataTimeStamp = 0;
    this.lastDataSource = "";
    this.consecutiveBadTimeStamp = 0;
    this.minData = [];
    this.curData = [];
    this.maxData = [];
    this.previewMinData = [];
    this.previewCurData = [];
    this.previewMaxData = [];
    this._lastAvgValue = Number.NaN;
    this._lastMinValue = Number.NaN;
    this._lastMaxValue = Number.NaN;
    this._dataloggerLoadisRunning = true;
    this._dataloggerLoadProgress = 0;
    this.dataLoggerStartReadTime = 0;
    this.Alarms = [];
    this.FormsToNotify = [];
    this.sensor = s;
    this.hwdName = name;
    this._friendlyname = name;
    if (s == null)
      return;
    if (SensorLocalConfig != null) {
      let index = 0;
      let childs = SensorLocalConfig.get_childsByIndex();
      for (let i = 0; i < childs.length; i++) {
        let n = childs[i];
        if (n.Name == "Alarm") {
          this.checkAlarmIndex(index);
          this.Alarms[index] = new AlarmSettings(index, this, n);
          index++;
        }
      }
    }
  }
  checkAlarmIndex(index) {
    while (this.Alarms.length < index + 1) {
      this.Alarms.push(new AlarmSettings(this.Alarms.length, this));
    }
  }
  getAlarmCount() {
    return this.Alarms.length;
  }
  setAlarmCondition(index, condition) {
    this.checkAlarmIndex(index);
    this.Alarms[index].setCondition(condition);
  }
  getAlarmCondition(index) {
    this.checkAlarmIndex(index);
    return this.Alarms[index].getCondition();
  }
  setAlarmSource(index, source) {
    this.checkAlarmIndex(index);
    this.Alarms[index].setSource(source);
  }
  getAlarmSource(index) {
    this.checkAlarmIndex(index);
    return this.Alarms[index].getSource();
  }
  setAlarmValue(index, value) {
    this.checkAlarmIndex(index);
    this.Alarms[index].setValue(value);
  }
  getAlarmValue(index) {
    this.checkAlarmIndex(index);
    return this.Alarms[index].getValue();
  }
  setAlarmDelay(index, value) {
    this.checkAlarmIndex(index);
    this.Alarms[index].setDelay(value);
  }
  getAlarmDelay(index) {
    this.checkAlarmIndex(index);
    return this.Alarms[index].getDelay();
  }
  setAlarmCommandline(index, value) {
    this.checkAlarmIndex(index);
    this.Alarms[index].setCommandline(value);
  }
  getAlarmCommandline(index) {
    this.checkAlarmIndex(index);
    return this.Alarms[index].getCommandline();
  }
  GetXmlData() {
    let res = '<Sensor ID="' + this.get_hardwareId() + '">\n';
    for (let i = 0; i < this.getAlarmCount(); i++) {
      res = res + this.Alarms[i].getXmlData();
    }
    res = res + "</Sensor>\n";
    return res;
  }
  get_firstLiveDataTimeStamp() {
    return this.firstLiveDataTimeStamp;
  }
  get_firstDataloggerTimeStamp() {
    return this.firstDataloggerTimeStamp;
  }
  get_lastDataTimeStamp() {
    return this.lastDataTimeStamp;
  }
  async preload_DoWork(arg) {
    if (this._predloadProcessIsBusy) {
      console.log("!!! multiple datalogger load attempt");
      return;
    }
    if (this.dataLoggerLoadCompleted) {
      console.log("!!!  datalogger load attempt although datalogger is already loaded.");
      return;
    }
    this._predloadProcessIsBusy = true;
    logForm.log(this.hwdName + ": preloading data from " + arg.start.toString() + " to " + arg.stop.toString() + "(delta= " + (arg.stop - arg.start).toFixed(3) + ")");
    this.setDataloggerLoadProgress(1);
    this.recordedData = await this.sensor.get_recordedData(arg.start, arg.stop);
    try {
      this.recordedDataLoadProgress = await this.recordedData.loadMore();
    } catch (e) {
      logForm.log(this.hwdName + ": load more caused an exception " + e.message);
    }
    let measures = await this.recordedData.get_preview();
    this.previewMinData = [];
    this.previewCurData = [];
    this.previewMaxData = [];
    let startIndex = 0;
    let errCount = 0;
    let maxErrorCount = 10;
    let lastT = -1;
    if (CustomYSensor._MaxDataRecords > 0 && measures.length > CustomYSensor._MaxDataRecords)
      startIndex = measures.length - CustomYSensor._MaxDataRecords;
    for (let i = startIndex; i < measures.length; i++) {
      let t = measures[i].get_endTimeUTC();
      if (t >= arg.start && t <= arg.stop) {
        this.previewMinData.push(new TimedSensorValue(t, measures[i].get_minValue()));
        this.previewCurData.push(new TimedSensorValue(t, measures[i].get_averageValue()));
        this.previewMaxData.push(new TimedSensorValue(t, measures[i].get_maxValue()));
        if (t < lastT && errCount < maxErrorCount) {
          logForm.log(this.hwdName + " preloading warning:  timestamp going back in time " + t + "<" + lastT + (errCount < maxErrorCount - 1 ? "" : ", further similar errors wont be logged."));
          errCount++;
        } else if (t == lastT && errCount < maxErrorCount) {
          logForm.log(this.hwdName + " preloading warning: duplicate timestamp  " + t + (errCount < maxErrorCount - 1 ? "" : ", further similar errors wont be logged."));
          errCount++;
        }
        lastT = t;
      }
    }
    if (this.previewCurData.length > 1) {
      let a = this.previewCurData[0].DateTime;
      let b = this.previewCurData[this.previewCurData.length - 1].DateTime;
      logForm.log(this.hwdName + ": preloaded data from " + a.toString() + " to " + b.toString() + " (delta=" + (b - a).toFixed(3) + ")");
      if (CustomYSensor._MaxLoggerRecords > 0 && arg.start == 0) {
        let list = await this.recordedData.get_privateDataStreams();
        let index = list.length - 1;
        let totalRecords = 0;
        while (index > 0 && totalRecords < CustomYSensor._MaxLoggerRecords) {
          totalRecords += await list[index].get_rowCount();
          this.dataLoggerStartReadTime = await list[index].get_startTimeUTC();
          index--;
        }
        let n = 0;
        while (n < this.previewMinData.length && this.previewMinData[n].DateTime < this.dataLoggerStartReadTime) {
          n++;
        }
        if (n > 1) {
          this.previewMinData.splice(0, n - 1);
          this.previewCurData.splice(0, n - 1);
          this.previewMaxData.splice(0, n - 1);
        }
      }
    }
    this.preload_Completed(arg);
  }
  findMergeBoundaries(previewMinData) {
    let MergeSourceStart = 0;
    let MergeSourceStop = 0;
    if (this.minData.length > 0) {
      while (MergeSourceStart < this.minData.length && previewMinData[0].DateTime > this.minData[MergeSourceStart].DateTime) {
        MergeSourceStart++;
      }
      MergeSourceStop = MergeSourceStart;
      while (MergeSourceStop < this.minData.length && previewMinData[previewMinData.length - 1].DateTime >= this.minData[MergeSourceStop].DateTime) {
        MergeSourceStop++;
      }
    }
    return new MergeSourceRange(MergeSourceStart, MergeSourceStop);
  }
  preload_Completed(arg) {
    if (this.previewMinData == null)
      return;
    logForm.log(this.hwdName + " : datalogger preloading completed (" + this.previewMinData.length + " rows)");
    if (this.previewMinData.length > 1) {
      let it = this.findMergeBoundaries(this.previewMinData);
      let insertIndex = it.MergeSourceStart;
      let deleteCount = it.MergeSourceStop - it.MergeSourceStart;
      this.minData = this.minData.slice(0, insertIndex).concat(this.previewMinData, this.minData.slice(insertIndex + deleteCount));
      this.curData = this.curData.slice(0, insertIndex).concat(this.previewCurData, this.curData.slice(insertIndex + deleteCount));
      this.maxData = this.maxData.slice(0, insertIndex).concat(this.previewMaxData, this.maxData.slice(insertIndex + deleteCount));
      for (let i = 0; i < this.FormsToNotify.length; i++) {
        if (this.FormsToNotify[i] instanceof graphWidget) {
          this.FormsToNotify[i].SensorNewDataBlock(this, it.MergeSourceStart, it.MergeSourceStart + this.previewMinData.length - 1, 0, true);
        }
      }
    }
    let count = this.curData.length;
    if (count > 0) {
      if (this.curData[count - 1].DateTime > this.lastDataTimeStamp) {
        this.lastDataTimeStamp = this.curData[count - 1].DateTime;
        this.lastDataSource = "last preload timestamp";
      }
    }
    logForm.log(this.hwdName + " : start datalogger loading");
    this._predloadProcessIsBusy = false;
    this.load_DoWork(arg).then();
  }
  get_frequency() {
    return this._frequency;
  }
  async updateFrequncy(frequencyToSet) {
    if (await this.sensor.isOnline()) {
      this._frequency = frequencyToSet;
      await this.sensor.set_reportFrequency(this._frequency);
      let lfreq = await this.sensor.get_logFrequency();
      try {
        if (lfreq != "OFF")
          await this.sensor.set_logFrequency(this._frequency);
        let m = await this.sensor.get_module();
        await m.saveToFlash();
      } catch (e) {
        logForm.log("failed to change " + this.hwdName + " log frequency (" + e.message + ")");
      }
    } else {
      this._online = false;
    }
  }
  set_frequency(frequencyToSet) {
    if (this._online) {
      this.updateFrequncy(frequencyToSet).then();
    }
  }
  get_recording() {
    return this._recording;
  }
  set_recording(recordingStatus) {
    this.updaterecording(recordingStatus).then();
  }
  async updaterecording(recordingStatus) {
    if (!this.dataLoggerFeature)
      return;
    if (await this.sensor.isOnline()) {
      this._recording = recordingStatus;
      try {
        await this.sensor.set_logFrequency(this._recording ? this._frequency : "OFF");
        let module = await this.sensor.get_module();
        let serial = await module.get_serialNumber();
        let dl = YDataLogger.FindDataLogger(serial + ".dataLogger");
        await dl.set_recording(this._recording ? YDataLogger.RECORDING_ON : YDataLogger.RECORDING_OFF);
        await dl.set_autoStart(this._recording ? YDataLogger.AUTOSTART_ON : YDataLogger.AUTOSTART_OFF);
        await module.saveToFlash();
      } catch (e) {
        logForm.log("failed to change " + this.hwdName + " recording (" + e.message + ")");
      }
    } else {
      this._online = false;
    }
  }
  reportDataloggerLoadProgress(progress) {
  }
  async load_DoWork(arg) {
    if (this._loadProcessIsBusy)
      return;
    this._loadProcessIsBusy = true;
    if (this.dataLoggerLoadCompleted)
      return;
    logForm.log(this.hwdName + " loading main data from datalogger");
    if (this.dataLoggerStartReadTime > 0) {
      this.recordedData = await this.sensor.get_recordedData(this.dataLoggerStartReadTime, 0);
    }
    let errCount = 0;
    let maxErrorCount = 10;
    let lastT = -1;
    let lastProgress = this.recordedDataLoadProgress;
    while (this.recordedDataLoadProgress < 100) {
      if (this._plzCancelDataloggerLoading) {
        this.loadDone = true;
        this.loadFailed = false;
        this.loadCanceled = true;
        this.setDataloggerLoadProgress(100);
        break;
      }
      try {
        this.recordedDataLoadProgress = await this.recordedData.loadMore();
      } catch (Exception) {
        this.loadFailed = true;
        return;
      }
      if (lastProgress != this.recordedDataLoadProgress) {
        lastProgress = this.recordedDataLoadProgress;
        let p = lastProgress;
        if (p < 1)
          p = 1;
        if (p > 99)
          p = 99;
        this.setDataloggerLoadProgress(p < 1 ? 1 : p > 99 ? 99 : p);
      }
      if (this.recordedDataLoadProgress - lastProgress >= 2) {
        lastProgress = this.recordedDataLoadProgress;
      }
    }
    let measures = await this.recordedData.get_measures();
    this.previewMinData = [];
    this.previewCurData = [];
    this.previewMaxData = [];
    for (let i = 0; i < measures.length; i++) {
      let t = measures[i].get_endTimeUTC();
      if (t >= arg.start && t <= arg.stop) {
        if (t < lastT && errCount < maxErrorCount) {
          logForm.log(this.hwdName + " loading warning:  timestamp going back in time " + t + "<" + lastT + (errCount < maxErrorCount - 1 ? "" : ", further similar errors wont be logged."));
          errCount++;
        } else if (t == lastT && errCount < maxErrorCount) {
          logForm.log(this.hwdName + " loading warning: duplicate timestamp  " + t + (errCount < maxErrorCount - 1 ? "" : ", further similar errors wont be logged."));
          errCount++;
        }
        lastT = t;
        if (this.previewMinData.length == 0 || t > this.previewMinData[this.previewMinData.length - 1].DateTime) {
          this.previewMinData.push(new TimedSensorValue(t, measures[i].get_minValue()));
          this.previewCurData.push(new TimedSensorValue(t, measures[i].get_averageValue()));
          this.previewMaxData.push(new TimedSensorValue(t, measures[i].get_maxValue()));
        }
      } else {
        let d = new Date(t * 1e3);
        let d1 = new Date(arg.start * 1e3);
        let d2 = new Date(arg.stop * 1e3);
        let dstr = d.toLocaleDateString() + " " + d.toLocaleTimeString();
        let d1str = d1.toLocaleDateString() + " " + d1.toLocaleTimeString();
        let d2str = d2.toLocaleDateString() + " " + d2.toLocaleTimeString();
        logForm.log(this.hwdName + " note: skipping measure at " + dstr + ", not in range " + d1str + " ... " + d2str);
      }
    }
    if (CustomYSensor._MaxDataRecords > 0)
      this.previewDataCleanUp();
    for (let i = 0; i < this.previewMinData.length - 1; i++) {
      if (this.previewMinData[i].DateTime >= this.previewMinData[i + 1].DateTime) {
        throw "Time-stamp inconsistency";
      }
    }
    if (this.previewCurData.length > 1) {
      logForm.log(this.hwdName + " loaded " + this.previewCurData.length.toString() + "/" + measures.length.toString() + " records over " + (this.previewCurData[this.previewCurData.length - 1].DateTime - this.previewCurData[0].DateTime).toFixed(3) + " sec, last timed stamp was " + this.previewCurData[this.previewCurData.length - 1].DateTime);
    } else {
      logForm.log(this.hwdName + " loaded " + this.previewCurData.length.toString() + " records");
    }
    if (this.previewMinData.length > 2) {
      let lastPreviewTimeStamp = this.previewMinData[this.previewMinData.length - 1].DateTime;
      let it = this.findMergeBoundaries(this.previewMinData);
      let deleteCount = it.MergeSourceStop - it.MergeSourceStart;
      this.minData = this.minData.slice(0, it.MergeSourceStart).concat(this.previewMinData, this.minData.slice(it.MergeSourceStart + deleteCount));
      this.curData = this.curData.slice(0, it.MergeSourceStart).concat(this.previewCurData, this.curData.slice(it.MergeSourceStart + deleteCount));
      this.maxData = this.maxData.slice(0, it.MergeSourceStart).concat(this.previewMaxData, this.maxData.slice(it.MergeSourceStart + deleteCount));
      this.firstDataloggerTimeStamp = this.curData[0].DateTime;
    }
    this.loadDone = true;
    this.loadFailed = false;
    let count = this.curData.length;
    if (count > 0) {
      if (this.curData[count - 1].DateTime > this.lastDataTimeStamp) {
        this.lastDataTimeStamp = this.curData[count - 1].DateTime;
        this.lastDataSource = "end of datalogger";
      }
    }
    this.load_Completed();
  }
  load_Completed() {
    logForm.log(this.hwdName + ".loadcompleted()");
    if (this.loadFailed) {
      logForm.log(this.hwdName + " : datalogger loading failed");
      this._loadProcessIsBusy = false;
      return;
    }
    if (this.loadCanceled) {
      logForm.log(this.hwdName + " : datalogger loading was canceled");
      this.previewMinData = [];
      this.previewCurData = [];
      this.previewMaxData = [];
      this.loadCanceled = false;
      this._loadProcessIsBusy = false;
      this.preloadDone = false;
      this.loadDone = false;
      return;
    }
    if (this.previewCurData.length <= 2) {
      this.preloadDone = false;
      this.loadDone = false;
    }
    logForm.log(this.hwdName + " : datalogger loading completed  (" + this.previewMinData.length + " rows)");
    this.resetDataloggerLoader();
    this.dataLoggerLoadCompleted = true;
    for (let i = 0; i < this.FormsToNotify.length; i++) {
      if (this.FormsToNotify[i] instanceof graphWidget) {
        this.FormsToNotify[i].DataloggerCompleted(this);
      }
    }
    this.setDataloggerLoadProgress(100);
  }
  get dataloggerWasUsed() {
    return this.dataLoggerLoadCompleted;
  }
  dataCleanUp() {
    if (CustomYSensor._MaxDataRecords <= 0)
      return;
    let newsize = CustomYSensor._MaxDataRecords * 90 / 100 >> 0;
    if (this.curData != null && CustomYSensor._MaxDataRecords < this.curData.length) {
      this.minData.splice(0, this.minData.length - newsize);
      this.curData.splice(0, this.curData.length - newsize);
      this.maxData.splice(0, this.maxData.length - newsize);
    }
  }
  previewDataCleanUp() {
    if (CustomYSensor._MaxDataRecords <= 0)
      return;
    let newsize = CustomYSensor._MaxDataRecords * 90 / 100 >> 0;
    if (this.previewMinData != null && CustomYSensor._MaxDataRecords < this.previewMinData.length) {
      this.previewMinData.splice(0, this.previewMinData.length - newsize);
      this.previewCurData.splice(0, this.previewCurData.length - newsize);
      this.previewMaxData.splice(0, this.previewMaxData.length - newsize);
    }
  }
  stopDataloggerloading() {
  }
  isOnline() {
    return this._online;
  }
  async reloadConfig() {
    if (this._online) {
      let ison = await this.sensor.isOnline();
      if (ison) {
        try {
          this.unit = await this.sensor.get_unit();
          this._friendlyname = await this.sensor.get_friendlyName();
          this.resolution = await this.sensor.get_resolution();
          this._frequency = await this.sensor.get_reportFrequency();
          this._readonly = await this.sensor.isReadOnly();
          if (this.dataLoggerFeature) {
            this._recording = await this.sensor.get_logFrequency() != "OFF";
          } else {
            this._recording = false;
          }
          this.lastGetConfig = YAPI.GetTickCount();
          this.mustReloadConfig = false;
        } catch (e) {
          logForm.log("reload configuration error: " + e.message);
        }
      } else {
        this._online = false;
      }
    }
  }
  get_unit() {
    if (this.cfgChgNotificationsSupported && !this.mustReloadConfig)
      return this.unit;
    if (this.lastGetConfig <= 0 || YAPI.GetTickCount() - this.lastGetConfig > 5e3)
      this.reloadConfig().then();
    return this.unit;
  }
  get_resolution() {
    if (this.cfgChgNotificationsSupported && !this.mustReloadConfig)
      return this.resolution;
    if (this.lastGetConfig <= 0 || YAPI.GetTickCount() - this.lastGetConfig > 5e3)
      this.reloadConfig().then();
    return this.resolution;
  }
  resetDataloggerLoader() {
    this._predloadProcessIsBusy = false;
    this._loadProcessIsBusy = false;
    this.dataLoggerLoadCompleted = false;
    this.preloadDone = false;
    this.loadDone = false;
    this._dataloggerLoadisRunning = false;
    this.previewMinData = [];
    this.previewCurData = [];
    this.previewMaxData = [];
  }
  loadDatalogger(start, stop) {
    if (!this.dataLoggerFeature)
      return;
    if (this._predloadProcessIsBusy)
      return;
    if (this._loadProcessIsBusy)
      return;
    if (constants.maxPointsPerDataloggerSerie < 0) {
      logForm.log(this.hwdName + " : datalogger access is disabled");
      return;
    }
    if (!this.preloadDone && this.dataLoggerFeature) {
      logForm.log(this.hwdName + " : start datalogger preloading");
      this.preload_DoWork(new DataLoggerBoundary(start, stop)).then();
    }
  }
  async arrival(dataloggerOn) {
    await this.configureSensor();
    this._online = true;
    await this.reloadConfig();
    let dt = await this.sensor.get_dataLogger();
    if (dt == null)
      return;
    let now = Math.floor(new Date().getTime() / 1e3);
    if (this.curData.length > 0 && this.dataLoggerLoadCompleted) {
      let end = await dt.get_timeUTC();
      let start = this.curData[this.curData.length - 1].DateTime;
      let duration = end - start;
      if (duration == 0) {
        start = this.curData[this.curData.length - 2].DateTime;
        duration = end - start;
      }
      if (duration > 1) {
        logForm.log(this.hwdName + " is back online trying to load " + duration.toFixed(3) + " sec of data from datalogger ");
        this.resetDataloggerLoader();
        this.loadDatalogger(start, end);
      }
    }
    if (this.isReadOnly)
      logForm.log(this.hwdName + " is read only");
    this.notifySensorStateChange();
    this.notifySensorArrival();
  }
  async startDataloggerload(source) {
    if (!this.dataLoggerFeature)
      return;
    if (this.sensor == null)
      return;
    if (this._loadProcessIsBusy)
      return;
    if (this._predloadProcessIsBusy)
      return;
    if (this.dataLoggerLoadCompleted) {
      source.DataloggerCompleted(this);
      return;
    }
    let dt = await this.sensor.get_dataLogger();
    if (dt == null)
      return;
    this.loadDatalogger(0, await dt.get_timeUTC());
  }
  notifySensorArrival() {
    for (let i = 0; i < this.FormsToNotify.length; i++) {
      this.FormsToNotify[i].SensorArrivalcallback(this);
    }
  }
  notifySensorStateChange() {
    for (let i = 0; i < this.FormsToNotify.length; i++) {
      this.FormsToNotify[i].SensorStateChangedcallback(this);
    }
  }
  removal() {
    this._online = false;
    this.forceUpdate();
    this.notifySensorStateChange();
  }
  async configureSensor() {
    logForm.log("Configuring  " + this.hwdName);
    if (!await this.sensor.isOnline())
      return;
    let mustSave = false;
    let olfreq = await this.sensor.get_logFrequency();
    let orfreq = await this.sensor.get_reportFrequency();
    let readOnly = await this.sensor.isReadOnly();
    let lfreq = olfreq;
    let rfreq = orfreq;
    let m = await this.sensor.get_module();
    for (let i = 0; i < await m.functionCount(); i++) {
      if (await m.functionType(i) == "DataLogger") {
        this.dataLoggerFeature = true;
      }
    }
    try {
      if (this.dataLoggerFeature) {
        let m2 = await this.sensor.get_module();
        let dl = YDataLogger.FindDataLogger(await m2.get_serialNumber() + ".dataLogger");
        let dataloggerOn = await dl.get_recording() != YDataLogger.RECORDING_OFF;
        let dataloggerAS = await dl.get_autoStart() != YDataLogger.AUTOSTART_OFF;
        if (!dataloggerOn) {
          lfreq = "OFF";
        }
        if (lfreq != "OFF") {
          rfreq = lfreq;
        } else if (rfreq == "OFF") {
          rfreq = "1/s";
        }
        if (lfreq != olfreq) {
          if (readOnly)
            throw new Error(this.hwdName + " is read only, cannot change its logFrequency from " + olfreq + " to " + lfreq);
          await this.sensor.set_logFrequency(lfreq);
          mustSave = true;
        }
        if (rfreq != orfreq) {
          if (readOnly)
            throw new Error(this.hwdName + " is read only, connot change its  reportFrequency from " + orfreq + " to " + rfreq);
          await this.sensor.set_reportFrequency(rfreq);
          mustSave = true;
        }
        if (lfreq != "OFF") {
          if (!dataloggerOn) {
            if (readOnly)
              throw new Error(this.hwdName + " is read only, cannot change set its  datalogger recording to ON");
            await dl.set_recording(YDataLogger.RECORDING_ON);
          }
          if (!dataloggerAS) {
            if (readOnly)
              throw new Error(this.hwdName + " is read only, cannot change set its datalogger autostart to ON");
            await dl.set_autoStart(YDataLogger.AUTOSTART_ON);
            mustSave = true;
          }
        }
      } else {
        lfreq = "OFF";
        if (rfreq == "OFF") {
          rfreq = "1/s";
          if (readOnly)
            throw new Error(this.hwdName + " is read only, connot change is reportFrequency from OFF to " + rfreq);
          await this.sensor.set_reportFrequency(rfreq);
          mustSave = true;
        }
      }
      if (mustSave)
        await m.saveToFlash();
    } catch (e) {
      logForm.log("failed to configure " + this.hwdName + "  (" + e.message + ")");
    }
    logForm.log("registering timed callback for  " + await this.sensor.get_hardwareId());
    await this.sensor.registerTimedReportCallback((callbacksource, M) => {
      this.TimedCallback(callbacksource, M);
    });
    this._recording = lfreq != "OFF";
    this._frequency = rfreq;
  }
  registerCallback(f) {
    if (this.FormsToNotify.indexOf(f) >= 0)
      return;
    this.FormsToNotify.push(f);
    return;
  }
  forceUpdate() {
    this.TimedCallback(this.sensor, null).then();
  }
  async TimedCallback(source, M) {
    this._online = true;
    if (M != null) {
      let t = M.get_endTimeUTC();
      if (this.firstLiveDataTimeStamp == 0)
        this.firstLiveDataTimeStamp = t;
      if (t > this.lastDataTimeStamp) {
        this.lastDataTimeStamp = t;
        this.lastDataSource = "last timedReport";
        this.consecutiveBadTimeStamp = 0;
      } else {
        this.consecutiveBadTimeStamp++;
        if (this.consecutiveBadTimeStamp < 10) {
          logForm.log(this.hwdName + ": ignoring bad timestamp " + t.toFixed(3) + " (previous " + this.lastDataSource + " at " + this.lastDataTimeStamp.toFixed(3) + ")");
        }
      }
      if (this.consecutiveBadTimeStamp == 0 || this.consecutiveBadTimeStamp >= 10) {
        this._lastAvgValue = M.get_averageValue();
        this._lastMinValue = M.get_minValue();
        this._lastMaxValue = M.get_maxValue();
        this.curData.push(new TimedSensorValue(t, this._lastAvgValue));
        this.minData.push(new TimedSensorValue(t, this._lastMinValue));
        this.maxData.push(new TimedSensorValue(t, this._lastMaxValue));
        if (CustomYSensor._MaxDataRecords > 0)
          this.dataCleanUp();
      }
      for (let i = 0; i < this.Alarms.length; i++) {
        this.Alarms[i].check(M);
      }
      for (let i = 0; i < this.FormsToNotify.length; i++) {
        this.FormsToNotify[i].SensorValuecallback(this, M);
      }
    }
  }
  forgetForm(source) {
    for (let i = this.FormsToNotify.length - 1; i >= 0; i--) {
      if (source == this.FormsToNotify[i]) {
        this.FormsToNotify.splice(i, 1);
      }
    }
  }
  get_sensor() {
    return this.sensor;
  }
  get_hardwareId() {
    return this.hwdName;
  }
  get_friendlyName() {
    return this._friendlyname;
  }
  toString() {
    let name = this._friendlyname;
    if (this._readonly)
      name += " (readonly)";
    if (this._online)
      return name;
    return name + " (OFFLINE)";
  }
};
CustomYSensor._MaxDataRecords = 0;
CustomYSensor._MaxLoggerRecords = 0;
var NullYSensor = class extends CustomYSensor {
  constructor() {
    super(null, "", null);
    this.hwdName = "NOTAREALSENSOR";
    this._friendlyname = "NOTAREALSENSOR";
    this.dataLoggerFeature = false;
  }
  async preload_DoWork(arg) {
    return;
  }
  get dataloggerLoadisRunning() {
    return false;
  }
  get_unit() {
    return "";
  }
  registerCallback(Form) {
  }
  forceUpdate() {
  }
  get_frequency() {
    return "";
  }
  set_frequency(frequencyToSet) {
  }
  get_sensor() {
    return null;
  }
  toString() {
    return "(none)";
  }
  setAlarmCondition(index, condition) {
  }
  getAlarmCondition(index) {
    return 0;
  }
  setAlarmValue(index, value) {
  }
  getAlarmValue(index) {
    return 0;
  }
  setAlarmDelay(index, value) {
  }
  getAlarmDelay(index) {
    return 0;
  }
  setAlarmCommandline(index, value) {
  }
  getAlarmCommandline(index) {
    return "";
  }
};
var sensorsManager = class {
  static async clearHublist() {
    for (let i = sensorsManager._hubList.length - 1; i >= 0; i--) {
      if (sensorsManager._hubList[i].removable) {
        await YAPI.UnregisterHub(sensorsManager._hubList[i].get_fullUrl());
        sensorsManager._hubList.splice(i, 1);
      }
    }
  }
  static registerChangeCallback(changeCallback) {
    this._changeCallback = changeCallback;
  }
  static registerChangeExternalCallback(changeCallback) {
    this._changeExternalCallback = changeCallback;
  }
  static forgetForm(source) {
    for (let i = 0; i < sensorsManager.sensorList.length; i++) {
      sensorsManager.sensorList[i].forgetForm(source);
    }
  }
  static InitHubList(node) {
    let nodes = node.get_childsByIndex();
    for (let i = 0; i < nodes.length; i++) {
      if (nodes[i].Name.toUpperCase() == "HUB") {
        let h = Hub.HubFromXml(nodes[i]);
        let alreadthere = false;
        for (let j = 0; j < sensorsManager._hubList.length; j++) {
          if (h.get_connexionUrl() == sensorsManager._hubList[j].get_connexionUrl())
            alreadthere = true;
        }
        if (!alreadthere) {
          sensorsManager._hubList.push(h);
          h.Connect().then();
        }
      }
    }
  }
  static get hubList() {
    return sensorsManager._hubList;
  }
  static hubWasremoved(h) {
    for (let i = sensorsManager._hubList.length - 1; i >= 0; i--) {
      if (sensorsManager._hubList[i] == h)
        sensorsManager._hubList.splice(i, 1);
    }
  }
  static newHubCreated(h) {
    let url = h.get_connexionUrl();
    for (let i = 0; i < sensorsManager._hubList.length; i++) {
      if (sensorsManager._hubList[i].get_connexionUrl() == url) {
        alert("This connection already exists");
        return false;
      }
    }
    sensorsManager._hubList.push(h);
    return true;
  }
  static removeExtraInfoFromUrl(url) {
    let it = new URL(url);
    let res = it.hostname + it.pathname;
    if (res.slice(0, 4).toLowerCase() === "www.") {
      res = res.slice(4);
    }
    return res;
  }
  static async NetworkArrival(net) {
    logForm.log("Network device detected: " + await net.get_hardwareId());
    let ip = await net.get_ipAddress();
    let netname = await net.get_logicalName();
    let module = await net.get_module();
    let loginame = await module.get_logicalName();
    let url = sensorsManager.removeExtraInfoFromUrl(await module.get_url());
    for (let i = 0; i < sensorsManager._hubList.length; i++) {
      let str = sensorsManager.removeExtraInfoFromUrl(sensorsManager.hubList[i].get_fullUrl());
      if (str == url) {
        sensorsManager.hubList[i].arrival(ip, netname, module, loginame);
      }
    }
  }
  static getXmlHublist() {
    let res = "";
    for (let i = 0; i < sensorsManager._hubList.length; i++) {
      res += "    " + sensorsManager._hubList[i].XmlCode() + "\n";
    }
    return res;
  }
  static getXMLSensorsConfig() {
    let res = "<Sensors>\n";
    sensorsManager.sensorList.forEach((s) => {
      if (!(s instanceof NullYSensor)) {
        res = res + s.GetXmlData();
      }
    });
    res = res + "</Sensors>\n";
    return res;
  }
  static setKnownSensors(sensorXMLList) {
    this.KnownSensors = sensorXMLList;
  }
  static FindSensorLastLocalConfig(hwdId) {
    let SensorConfig = null;
    if (sensorsManager.KnownSensors != null) {
      let childs = sensorsManager.KnownSensors.get_childsByIndex();
      for (let i = 0; i < childs.length; i++) {
        let node = childs[i];
        if (node.Name == "Sensor") {
          let id = node.get_attributes()["ID"];
          if (id == hwdId) {
            SensorConfig = node;
          }
        }
      }
    }
    return SensorConfig;
  }
  static async deviceConfigChanged(m) {
    logForm.log("Configuration change on device  " + await m.get_serialNumber());
    let serialprefix = (await m.get_serialNumber()).substring(0, 8);
    for (let i = 0; i < sensorsManager.sensorList.length; i++) {
      if (sensorsManager.sensorList[i].get_hardwareId().substring(0, 8) == serialprefix) {
        await sensorsManager.sensorList[i].ConfigHasChanged();
      }
    }
    if (sensorsManager._changeCallback != null)
      sensorsManager._changeCallback();
    if (sensorsManager._changeExternalCallback != null) {
      let data = await sensorsManager._changeExternalCallback(m);
      if (data != null)
        YWebPage.ConfigChanged(data);
    }
  }
  static async deviceArrival(m) {
    try {
      let count = await m.functionCount();
      let serial = await m.get_serialNumber();
      let luminosity = await m.get_luminosity();
      logForm.log("Device Arrival " + serial);
      let recording = false;
      for (let i = 0; i < count; i++) {
        let ftype = await m.functionType(i);
        let fid = await m.functionId(i);
        if (ftype == "Network") {
          let net = await YNetwork.FindNetwork(serial + "." + fid);
          await sensorsManager.NetworkArrival(net);
        } else if (ftype == "DataLogger") {
          let dlog = YDataLogger.FindDataLogger(serial + "." + fid);
          let state = await dlog.get_recording();
          if (state == YDataLogger.RECORDING_ON || state == YDataLogger.RECORDING_PENDING) {
            recording = true;
          }
        }
      }
      for (let i = 0; i < count; i++) {
        let fbasetype = await m.functionBaseType(i);
        let fid = await m.functionId(i);
        if (fbasetype == "Sensor") {
          let hwdID = serial + "." + fid;
          logForm.log("New sensor arrival: " + hwdID);
          let found = false;
          for (let j = 0; j < sensorsManager.sensorList.length && !found; j++) {
            if (sensorsManager.sensorList[j].get_hardwareId() == hwdID) {
              found = true;
              await sensorsManager.sensorList[j].arrival(recording);
            }
          }
          if (!found) {
            let s = YSensor.FindSensor(hwdID);
            let hwd = await s.get_hardwareId();
            let cs = new CustomYSensor(s, hwd, sensorsManager.FindSensorLastLocalConfig(hwd));
            sensorsManager.sensorList.push(cs);
            await cs.configureSensor();
            YWebPage.refreshEditor();
            cs.notifySensorStateChange();
          }
        }
      }
      await m.registerConfigChangeCallback(sensorsManager.deviceConfigChanged);
      setTimeout(() => {
        sensorsManager.deviceConfigChanged(m);
      }, 100);
      if (sensorsManager._changeCallback != null)
        sensorsManager._changeCallback();
    } catch (e) {
      logForm.log("Device Arrival Error: " + e.message);
    }
    if (sensorsManager._customArrivalCallback != null)
      sensorsManager._customArrivalCallback(m);
  }
  static async deviceRemoval(m) {
    let serial = await m.get_serialNumber();
    logForm.log("Device removal " + serial);
    sensorsManager.sensorList.forEach((alreadyThereSensor) => {
      if (!(alreadyThereSensor instanceof NullYSensor)) {
        let hwd = alreadyThereSensor.get_hardwareId();
        if (hwd.length >= serial.length) {
          if (hwd.substring(0, serial.length) == serial) {
            alreadyThereSensor.removal();
          }
        }
      }
    });
    if (sensorsManager._changeCallback != null)
      sensorsManager._changeCallback();
    if (sensorsManager._customRemovalCallback != null)
      sensorsManager._customRemovalCallback(m);
  }
  static RegisterDeviceArrivalCallback(arrivalCallback) {
    sensorsManager._customArrivalCallback = arrivalCallback;
  }
  static RegisterDeviceRemovalCallback(removalCallback) {
    sensorsManager._customRemovalCallback = removalCallback;
  }
  static AddNewSensor(hwdID) {
    for (let i = 0; i < sensorsManager.sensorList.length; i++) {
      if (sensorsManager.sensorList[i] != null) {
        if (sensorsManager.sensorList[i].get_hardwareId() == hwdID)
          return sensorsManager.sensorList[i];
      }
    }
    let s = YSensor.FindSensor(hwdID);
    let cs = new CustomYSensor(s, hwdID, sensorsManager.FindSensorLastLocalConfig(hwdID));
    sensorsManager.sensorList.push(cs);
    return cs;
  }
  static getNullSensor() {
    return sensorsManager.NullSensor;
  }
  static async UpdateDeviceList() {
    let err = new YErrorMsg();
    try {
      if (await YAPI.UpdateDeviceList(err) != YAPI_SUCCESS) {
        logForm.log("UpdateDeviceList failed :" + err.msg);
      }
    } catch (e) {
      logForm.log("UpdateDeviceList failed :" + e.message);
    }
  }
  static async _runAsync() {
    let errmsg = new YErrorMsg();
    await YAPI.RegisterDeviceArrivalCallback((m) => {
      sensorsManager.deviceArrival(m);
    });
    await YAPI.RegisterDeviceRemovalCallback((m) => {
      sensorsManager.deviceRemoval(m);
    });
    await sensorsManager.UpdateDeviceList();
    setInterval(() => {
      sensorsManager.UpdateDeviceList();
    }, 2e3);
  }
  static run() {
    sensorsManager.NullSensor = new NullYSensor();
    sensorsManager.sensorList = [];
    sensorsManager.sensorList.push(sensorsManager.NullSensor);
    this._runAsync().then();
  }
};
sensorsManager.counter = 0;
sensorsManager.KnownSensors = null;
sensorsManager._hubList = [];
sensorsManager._customArrivalCallback = null;
sensorsManager._customRemovalCallback = null;
sensorsManager._changeCallback = null;
sensorsManager._changeExternalCallback = null;

// obj/full/formManager.js
var ResizeMoveHandle = class {
  constructor(container, index, mouseDownListener, touchStartlistener) {
    this.index = index;
    this.container = container;
    this.isactive = false;
    this.div = document.createElement("DIV");
    let size = ResizeMoveHandle.HANDLESIZE - 2;
    if (this.index == ResizeMoveHandle.RESIZEHANDLE_CENTER)
      size = size * 2;
    this.div.style.position = "absolute";
    this.div.style.border = "0px solid black";
    this.div.style.background = "transparent";
    this.div.style.pointerEvents = "auto";
    this.div.style.width = size.toString() + "px";
    this.div.style.height = size.toString() + "px";
    switch (index) {
      case ResizeMoveHandle.RESIZEHANDLE_TOPLEFT:
        this.div.style.cursor = "nw-resize";
        this.div.style.left = "0px";
        this.div.style.top = "0px";
        break;
      case ResizeMoveHandle.RESIZEHANDLE_TOPCENTER:
        this.div.style.cursor = "n-resize";
        this.div.style.top = "0px";
        this.div.style.left = "50%";
        this.div.style.transform = "translate(-50%,0)";
        break;
      case ResizeMoveHandle.RESIZEHANDLE_TOPRIGHT:
        this.div.style.cursor = "ne-resize";
        this.div.style.right = "0px";
        this.div.style.top = "0px";
        break;
      case ResizeMoveHandle.RESIZEHANDLE_CENTERRIGHT:
        this.div.style.cursor = "e-resize";
        this.div.style.right = "0px";
        this.div.style.top = "50%";
        this.div.style.transform = "translate(0,-50%)";
        break;
      case ResizeMoveHandle.RESIZEHANDLE_BOTTOMRIGHT:
        this.div.style.cursor = "se-resize";
        this.div.style.right = "0px";
        this.div.style.bottom = "0px";
        break;
      case ResizeMoveHandle.RESIZEHANDLE_BOTTOMCENTER:
        this.div.style.cursor = "s-resize";
        this.div.style.bottom = "0px";
        this.div.style.left = "50%";
        this.div.style.transform = "translate(-50%,0)";
        break;
      case ResizeMoveHandle.RESIZEHANDLE_BOTTOMLEFT:
        this.div.style.cursor = "sw-resize";
        this.div.style.left = "0px";
        this.div.style.bottom = "0px";
        break;
      case ResizeMoveHandle.RESIZEHANDLE_CENTERLEFT:
        this.div.style.cursor = "w-resize";
        this.div.style.left = "0px";
        this.div.style.top = "50%";
        this.div.style.transform = "translate(0,-50%)";
        break;
      case ResizeMoveHandle.RESIZEHANDLE_CENTER:
        this.div.style.cursor = "move";
        this.div.style.left = "50%";
        this.div.style.top = "50%";
        this.div.style.transform = "translate(-50%,-50%)";
        break;
    }
    this.container.appendChild(this.div);
    this.div.addEventListener("mousedown", mouseDownListener);
    this.div.addEventListener("touchstart", touchStartlistener);
    this.svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    this.svg.setAttribute("viewBox", "0 0 " + size + " " + size);
    this.svg.setAttribute("version", "1.1");
    this.svg.setAttribute("width", size.toString());
    this.svg.setAttribute("height", size.toString());
    let x = 0;
    let y = 0;
    let r = size;
    switch (this.index) {
      case ResizeMoveHandle.RESIZEHANDLE_TOPLEFT:
        break;
      case ResizeMoveHandle.RESIZEHANDLE_TOPCENTER:
        x = size / 2;
        break;
      case ResizeMoveHandle.RESIZEHANDLE_TOPRIGHT:
        x = size;
        break;
      case ResizeMoveHandle.RESIZEHANDLE_CENTERRIGHT:
        x = size;
        y = size / 2;
        break;
      case ResizeMoveHandle.RESIZEHANDLE_BOTTOMRIGHT:
        x = size;
        y = size;
        break;
      case ResizeMoveHandle.RESIZEHANDLE_BOTTOMCENTER:
        x = size / 2;
        y = size;
        break;
      case ResizeMoveHandle.RESIZEHANDLE_BOTTOMLEFT:
        y = size;
        break;
      case ResizeMoveHandle.RESIZEHANDLE_CENTERLEFT:
        y = size / 2;
        break;
      case ResizeMoveHandle.RESIZEHANDLE_CENTER:
        x = size / 2;
        y = size / 2;
        r = size / 2;
        break;
    }
    this.circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
    this.circle.setAttribute("cx", x.toString());
    this.circle.setAttribute("cy", y.toString());
    this.circle.setAttribute("r", r.toString());
    this.circle.setAttribute("style", "fill:white");
    this.circle.setAttribute("opacity", "0.75");
    this.svg.appendChild(this.circle);
    this.arrow = document.createElementNS("http://www.w3.org/2000/svg", "path");
    let d = "";
    for (let i = 0; i < ResizeMoveHandle.RESIZEHANDLE_data[index].length >> 1; i++) {
      let x2 = 1 + (size - 2) * ResizeMoveHandle.RESIZEHANDLE_data[index][i << 1] / 12;
      let y2 = 1 + (size - 2) * ResizeMoveHandle.RESIZEHANDLE_data[index][1 + (i << 1)] / 12;
      d += i == 0 ? "M " : "L ";
      d += Math.round(x2).toString() + " " + Math.round(y2).toString() + " ";
    }
    d += "z";
    this.arrow.setAttribute("d", d);
    this.arrow.setAttribute("fill", ResizeMoveHandle.inactiveColor);
    this.svg.appendChild(this.arrow);
    this.div.appendChild(this.svg);
    this.container.appendChild(this.div);
  }
  get active() {
    return this.isactive;
  }
  set active(value) {
    if (value != this.isactive) {
      this.isactive = value;
      this.arrow.setAttribute("fill", this.active ? ResizeMoveHandle.activeColor : ResizeMoveHandle.inactiveColor);
    }
  }
};
ResizeMoveHandle.HANDLESIZE = Math.round(20 * (1 + 2 * (constants.guiDPIFactor - 1)));
ResizeMoveHandle.activeColor = "lightgreen";
ResizeMoveHandle.inactiveColor = "grey";
ResizeMoveHandle.RESIZEHANDLE_TOPLEFT = 0;
ResizeMoveHandle.RESIZEHANDLE_TOPCENTER = 1;
ResizeMoveHandle.RESIZEHANDLE_TOPRIGHT = 2;
ResizeMoveHandle.RESIZEHANDLE_CENTERRIGHT = 3;
ResizeMoveHandle.RESIZEHANDLE_BOTTOMRIGHT = 4;
ResizeMoveHandle.RESIZEHANDLE_BOTTOMCENTER = 5;
ResizeMoveHandle.RESIZEHANDLE_BOTTOMLEFT = 6;
ResizeMoveHandle.RESIZEHANDLE_CENTERLEFT = 7;
ResizeMoveHandle.RESIZEHANDLE_CENTER = 8;
ResizeMoveHandle.RESIZEHANDLE_data = [
  [0, 0, 0, 7, 2, 5, 7, 10, 10, 7, 5, 2, 7, 0],
  [6, 0, 11, 5, 8, 5, 8, 12, 4, 12, 4, 5, 1, 5],
  [12, 0, 12, 7, 10, 5, 5, 10, 2, 7, 7, 2, 5, 0],
  [12, 6, 7, 11, 7, 8, 0, 8, 0, 4, 7, 4, 7, 1],
  [12, 12, 5, 12, 7, 10, 2, 5, 5, 2, 10, 7, 12, 5],
  [6, 12, 1, 7, 4, 7, 4, 0, 8, 0, 8, 7, 11, 7],
  [0, 12, 0, 5, 2, 7, 7, 2, 10, 5, 5, 10, 7, 12],
  [0, 6, 5, 1, 5, 4, 12, 4, 12, 8, 5, 8, 5, 11],
  [
    6,
    0,
    8,
    2,
    7,
    2,
    7,
    5,
    10,
    5,
    10,
    4,
    12,
    6,
    10,
    8,
    10,
    7,
    7,
    7,
    7,
    10,
    8,
    10,
    6,
    12,
    4,
    10,
    5,
    10,
    5,
    7,
    2,
    7,
    2,
    8,
    0,
    6,
    2,
    4,
    2,
    5,
    5,
    5,
    5,
    2,
    4,
    2
  ]
];
var YWidget = class {
  static log(st) {
    logForm.log(st);
  }
  SourceChanged(src, index) {
  }
  loadRecordedDataIfNeeded() {
  }
  removeDataloggerData() {
  }
  delete() {
    this.editStopped();
    sensorsManager.forgetForm(this);
    this.destroy();
  }
  get confirmDeleteString() {
    return "not defined";
  }
  snapshot() {
    let w = 1024;
    let h = 1024;
    let ratio = this.UIContainer.offsetHeight != 0 ? this.UIContainer.offsetWidth / this.UIContainer.offsetHeight : 1;
    switch (constants.captureSizePolicy) {
      case YDataRenderer.CaptureFormats.Keep:
        w = this.UIContainer.offsetWidth;
        h = this.UIContainer.offsetHeight;
        break;
      case YDataRenderer.CaptureFormats.FixedHeight:
        h = constants.captureHeight;
        w = h * ratio;
        break;
      case YDataRenderer.CaptureFormats.FixedWidth:
        w = constants.captureWidth;
        h = w / ratio;
        break;
      case YDataRenderer.CaptureFormats.Fixed:
        w = constants.captureWidth;
        h = constants.captureHeight;
        break;
    }
    this._genRenderer.captureAndDownloadImage(constants.captureType, "", w, h, constants.captureDPI);
  }
  get BackColor() {
    return this._BackColor;
  }
  set BackColor(value) {
    this._BackColor = value;
    this.UIContainer.style.backgroundColor = this._BackColor.htmlCode;
  }
  get BorderColor() {
    return this._BorderColor;
  }
  set BorderColor(value) {
    this._BorderColor = value;
    this.UIContainer.style.border = "1px solid " + this._BorderColor.htmlCode;
  }
  get parentWidth() {
    if (this.UIContainer.parentNode == document.body || this.UIContainer.parentNode == null)
      return window.innerWidth;
    return this.UIContainer.parentNode.clientWidth;
  }
  get parentHeight() {
    if (this.UIContainer.parentNode == document.body || this.UIContainer.parentNode == null)
      return window.innerHeight;
    return this.UIContainer.parentNode.clientHeight;
  }
  get relativePositionX() {
    if (this._SizeIsRelative)
      return this._relativePositionX;
    return this.sizeRound(100 * this.UIContainer.offsetLeft / this.parentWidth);
  }
  set relativePositionX(value) {
    this._relativePositionX = value;
    this._PositionX = Math.round(value * this.parentWidth / 100);
  }
  set relativePositionY(value) {
    this._relativePositionY = value;
    this._PositionY = Math.round(value * this.parentHeight / 100);
  }
  get relativePositionY() {
    if (this._SizeIsRelative)
      return this._relativePositionY;
    return this.sizeRound(100 * this.UIContainer.offsetTop / this.parentHeight);
  }
  get PositionX() {
    if (this._SizeIsRelative)
      return this.relativePositionX;
    return this.UIContainer.offsetLeft;
  }
  set PositionX(value) {
    if (this._SizeIsRelative)
      this.relativePositionX = value;
    else
      this._PositionX = value;
    this.UIContainer.style.left = this._PositionX.toString() + "px";
    if (this._genRenderer != null)
      this._genRenderer.clearTransformationMatrix();
    this.DrawHandles(this.UIContainer.offsetLeft, this.UIContainer.offsetTop, this.UIContainer.offsetWidth, this.UIContainer.offsetHeight);
  }
  get PositionY() {
    if (this._SizeIsRelative)
      return this.relativePositionY;
    return this.UIContainer.offsetTop;
  }
  set PositionY(value) {
    if (this._SizeIsRelative)
      this.relativePositionY = value;
    else
      this._PositionY = value;
    this.UIContainer.style.top = this._PositionY.toString() + "px";
    if (this._genRenderer != null)
      this._genRenderer.clearTransformationMatrix();
    this.DrawHandles(this.UIContainer.offsetLeft, this.UIContainer.offsetTop, this.UIContainer.offsetWidth, this.UIContainer.offsetHeight);
  }
  sizeRound(v) {
    return Math.round(100 * v) / 100;
  }
  get relativeWidth() {
    if (this._SizeIsRelative)
      return this._relativeWidth;
    return this.sizeRound(100 * this.UIContainer.offsetWidth / this.parentWidth);
  }
  set relativeWidth(value) {
    if (value <= 0)
      throw "Value must be strictly positive";
    this._relativeWidth = value;
    this._Width = Math.round(value * this.parentWidth / 100);
  }
  set relativeHeight(value) {
    if (value <= 0)
      throw "Value must be strictly positive";
    this._relativeHeight = value;
    this._Height = Math.round(value * this.parentHeight / 100);
  }
  get relativeHeight() {
    if (this._SizeIsRelative)
      return this._relativeHeight;
    return this.sizeRound(100 * this.UIContainer.offsetHeight / this.parentHeight);
  }
  updateRelativeSize() {
    if (Math.abs(this._relativeWidth * this.parentWidth / 100 - this.UIContainer.offsetWidth) > 1)
      this._relativeWidth = this.sizeRound(100 * this.UIContainer.offsetWidth / this.parentWidth);
    if (Math.abs(this._relativeHeight * this.parentHeight / 100 - this.UIContainer.offsetHeight) > 1)
      this._relativeHeight = this.sizeRound(100 * this.UIContainer.offsetHeight / this.parentHeight);
    if (Math.abs(this._relativePositionX * this.parentWidth / 100 - this.UIContainer.offsetLeft) > 1)
      this._relativePositionX = this.sizeRound(100 * this.UIContainer.offsetLeft / this.parentWidth);
    if (Math.abs(this._relativePositionY * this.parentHeight / 100 - this.UIContainer.offsetTop) > 1)
      this._relativePositionY = this.sizeRound(100 * this.UIContainer.offsetTop / this.parentHeight);
  }
  get Width() {
    if (this._SizeIsRelative)
      return this.relativeWidth;
    else
      return this.UIContainer.offsetWidth;
  }
  set Width(value) {
    if (value <= 0)
      throw "Value must be strictly positive";
    if (this._SizeIsRelative)
      this.relativeWidth = value;
    else
      this._Width = value;
    this.UIContainer.style.width = (this._Width - 2).toString() + "px";
    this.UIContainer.width = this._Width - 2;
    if (this._genRenderer != null)
      this._genRenderer.clearTransformationMatrix();
    this.DrawHandles(this.UIContainer.offsetLeft, this.UIContainer.offsetTop, this.UIContainer.offsetWidth, this.UIContainer.offsetHeight);
    this.containerResized();
  }
  get Height() {
    if (this._SizeIsRelative)
      return this.relativeHeight;
    else
      return this.UIContainer.offsetHeight;
  }
  set Height(value) {
    if (value <= 0)
      throw "Value must be strictly positive";
    if (this._SizeIsRelative)
      this.relativeHeight = value;
    else
      this._Height = value;
    this.UIContainer.style.height = (this._Height - 2).toString() + "px";
    this.UIContainer.height = this._Height - 2;
    if (this._genRenderer != null)
      this._genRenderer.clearTransformationMatrix();
    this.DrawHandles(this.UIContainer.offsetLeft, this.UIContainer.offsetTop, this.UIContainer.offsetWidth, this.UIContainer.offsetHeight);
    this.containerResized();
  }
  get SizeIsRelative() {
    return this._SizeIsRelative;
  }
  set SizeIsRelative(value) {
    if (this._SizeIsRelative != value) {
      this._SizeIsRelative = value;
      if (this._SizeIsRelative) {
        this._relativePositionX = this.sizeRound(100 * this.UIContainer.offsetLeft / this.parentWidth);
        this._relativePositionY = this.sizeRound(100 * this.UIContainer.offsetTop / this.parentHeight);
        this._relativeWidth = this.sizeRound(100 * this.UIContainer.offsetWidth / this.parentWidth);
        this._relativeHeight = this.sizeRound(100 * this.UIContainer.offsetHeight / this.parentHeight);
      }
      this.windowResized();
    }
  }
  get containerID() {
    return this._containerID;
  }
  set containerID(value) {
    if (this._containerID == value)
      return;
    let target = value != "" ? document.getElementById(value) : null;
    if (value != "" && target == null)
      throw "No HTMLElement on the page with such ID (" + value + ")";
    if (this.UIContainer.parentNode != null) {
      this.UIContainer.parentNode.removeChild(this.UIContainer);
    } else {
      document.body.removeChild(this.UIContainer);
    }
    if (target != null) {
      this.UIContainer.style.position = "relative";
      target.insertBefore(this.UIContainer, target.firstChild);
    } else {
      this.UIContainer.style.position = "absolute";
      document.body.insertBefore(this.UIContainer, document.body.firstChild);
    }
    this._genRenderer.clearTransformationMatrix();
    this.windowResized();
    this.DrawHandles(this.UIContainer.offsetLeft, this.UIContainer.offsetTop, this.UIContainer.offsetWidth, this.UIContainer.offsetHeight);
    this._containerID = value;
  }
  get Text() {
    return this._Text;
  }
  set Text(value) {
    this._Text = value;
    this.UIContainer.title = value;
  }
  set_name(name) {
    this.Text = name;
    this._genProp.Form_Text = name;
  }
  windowResized() {
    this._genRenderer.DisableRedraw();
    if (this._SizeIsRelative) {
      this.PositionX = this._relativePositionX;
      this.PositionY = this._relativePositionY;
      this.Height = this._relativeHeight;
      this.Width = this._relativeWidth;
    }
    this.containerResized();
    this._genRenderer.AllowRedraw();
  }
  ApplyRelativeSizeIfRequired() {
    if (this._initialContainerID != "") {
      if (document.getElementById(this._initialContainerID) != null) {
        this.containerID = this._initialContainerID;
      } else {
        logForm.log('Warning: cannot place widget in "' + this._initialContainerID + '" : no such HTML element.');
      }
    }
    this._SizeIsRelative = this._InitialSizeIsRelative;
    this.windowResized();
  }
  destroy() {
    window.removeEventListener("resize", this._windowResizeCallback);
    this._genRenderer.destroy();
    Object.entries(this).forEach((pair) => {
      Reflect.set(this, pair[0], null);
    });
  }
  getContainerOffset() {
    let it = this.UIContainer.offsetParent;
    let absx = 0;
    let absy = 0;
    while (it) {
      absy += it.offsetTop;
      absx += it.offsetLeft;
      it = it.offsetParent;
    }
    return new pointXY(absx, absy);
  }
  contextMenuCallBack(mouseX, mouseY) {
    let p = this._genRenderer.Scr2ElmMatrix.multiplyByV(Vector3.FromXYCoord(mouseX, mouseY)).toPoint();
    if (p.X >= 0 && p.X <= this.UIContainer.offsetWidth && p.Y >= 0 && p.Y <= this.UIContainer.offsetHeight) {
      this.contextMenuIsOpening();
    }
  }
  contextMenuIsOpening() {
  }
  constructor(node, editor, default_x, default_y, default_width, default_height) {
    this._genProp = null;
    this._genRenderer = null;
    this._BackColor = YColor.Transparent;
    this._BorderColor = YColor.Gray;
    this._relativePositionX = 0;
    this._relativePositionY = 0;
    this._PositionX = 0;
    this._PositionY = 0;
    this._relativeWidth = 100;
    this._relativeHeight = 100;
    this._Width = 300;
    this._Height = 0;
    this._InitialSizeIsRelative = false;
    this._SizeIsRelative = false;
    this._initialContainerID = "";
    this._containerID = "";
    this._Text = "";
    this.resizeCaptureRunning = false;
    this.resizeCaptureXOrigineMouse = 0;
    this.resizeCaptureYOrigineMouse = 0;
    this.resizeCaptureXOrigine = 0;
    this.resizeCaptureYOrigine = 0;
    this.resizeCaptureOriginalTop = 0;
    this.resizeCaptureOriginalLeft = 0;
    this.resizeCaptureOriginalWidth = 0;
    this.resizeCaptureOriginalHeight = 0;
    this.resizeCaptureHandleIndex = 0;
    this.resizeCaptureOriginalMatrix = null;
    this.resizeCaptureOriginalMatrixInv = null;
    this.previousTRansform = "";
    this.previousWidth = 0;
    this.previousHeight = 0;
    let left = typeof default_x != "undefined" ? default_x : 0;
    let top2 = typeof default_y != "undefined" ? default_y : 0;
    let width = typeof default_width != "undefined" ? default_width : 0;
    let height = typeof default_height != "undefined" ? default_height : 0;
    let bottom = Number.NaN;
    let right = Number.NaN;
    if (node != null) {
      let childnodes = node.get_childsByName();
      if ("location" in childnodes) {
        let it = childnodes["location"];
        let attributes = it.get_attributes();
        if ("x" in attributes)
          left = parseInt(attributes["x"]);
        if ("y" in attributes)
          top2 = parseInt(attributes["y"]);
      }
      if ("size" in childnodes) {
        let it = childnodes["size"];
        let attributes = it.get_attributes();
        if ("w" in attributes)
          width = parseInt(attributes["w"]);
        if ("h" in attributes)
          height = parseInt(attributes["h"]);
      }
      if ("relativeCoord" in childnodes) {
        let it = childnodes["relativeCoord"];
        let attributes = it.get_attributes();
        if ("x" in attributes)
          this._relativePositionX = this.sizeRound(parseFloat(attributes["x"]));
        if ("y" in attributes)
          this._relativePositionY = this.sizeRound(parseFloat(attributes["y"]));
        if ("w" in attributes)
          this._relativeWidth = this.sizeRound(parseFloat(attributes["w"]));
        if ("h" in attributes)
          this._relativeHeight = this.sizeRound(parseFloat(attributes["h"]));
        if ("active" in attributes)
          this._InitialSizeIsRelative = attributes["active"].toUpperCase() == "TRUE";
      }
      if ("container" in childnodes) {
        let it = childnodes["container"];
        let attributes = it.get_attributes();
        if ("id" in attributes)
          this._initialContainerID = attributes["id"];
      }
    }
    this.UIContainer = document.createElement("CANVAS");
    this.UIContainer.style.position = "absolute";
    YWidget.currentEdited = null;
    let h = window.innerHeight;
    let w = window.innerWidth;
    this.PositionX = this._InitialSizeIsRelative ? Math.round(w * (this._relativePositionX / 100)) : left;
    this.PositionY = this._InitialSizeIsRelative ? Math.round(h * (this._relativePositionY / 100)) : top2;
    this.Width = this._InitialSizeIsRelative ? Math.round(w * (this._relativeWidth / 100)) : width;
    this.Height = this._InitialSizeIsRelative ? Math.round(h * (this._relativeHeight / 100)) : height;
    this.UIContainer.style.border = "1px solid black";
    this.UIContainer.style.backgroundColor = this._BackColor.htmlCode;
    this.UIContainer.setAttribute("name", "YoctoVisualizationWidget");
    document.body.appendChild(this.UIContainer);
    this._windowResizeCallback = () => this.windowResized();
    window.addEventListener("resize", this._windowResizeCallback);
  }
  rearrangeZindexes() {
    let containers = document.getElementsByName("YoctoVisualizationWidget");
    let n = 0;
    for (let i = 0; i < containers.length; i++) {
      if (containers[i] != this.UIContainer) {
        containers[i].style.zIndex = n.toString();
        n++;
      }
    }
    this.UIContainer.style.zIndex = n.toString();
    n++;
    YWidget.HandlesDiv.style.zIndex = n.toString();
  }
  SensorArrivalcallback(source) {
  }
  SensorStateChangedcallback(source) {
    if (YWidget.currentEdited == this) {
      YWebPage.refreshEditor();
    }
  }
  SensorValuecallback(source, M) {
  }
  get isBeingEdited() {
    return YWidget.currentEdited == this;
  }
  static stopEdition() {
    if (YWidget.currentEdited != null) {
      YWidget.currentEdited.editStopped();
      YWidget.currentEdited = null;
    }
  }
  refreshProperties() {
  }
  edit() {
    YWidget.stopEdition();
    YWidget.currentEdited = this;
    if (YWidget.editHandles.length <= 0) {
      YWidget.HandlesDiv = document.createElement("DIV");
      YWidget.HandlesDiv.style.position = "absolute";
      YWidget.HandlesDiv.style.left = "0px";
      YWidget.HandlesDiv.style.top = "0px";
      YWidget.HandlesDiv.style.backgroundColor = "transparent";
      YWidget.HandlesDiv.style.transformOrigin = "top left";
      YWidget.HandlesDiv.style.pointerEvents = "none";
      for (let i = 0; i < 9; i++) {
        YWidget.editHandles.push(new ResizeMoveHandle(YWidget.HandlesDiv, i, (e) => {
          if (YWidget.currentEdited != null)
            YWidget.currentEdited.mouseStartCapture(e, i);
        }, (e) => {
          if (YWidget.currentEdited != null) {
            YWidget.currentEdited.touchStartCapture(e, i);
          }
        }));
      }
      document.body.appendChild(YWidget.HandlesDiv);
      document.addEventListener("touchmove", (e) => {
        if (YWidget.currentEdited != null)
          YWidget.currentEdited.touchCaptureRun(e);
      }, {passive: false});
      document.addEventListener("touchend", (e) => {
        if (YWidget.currentEdited != null)
          YWidget.currentEdited.touchCaptureStop(e);
      }, {passive: false});
      document.addEventListener("mousemove", (e) => {
        if (YWidget.currentEdited != null)
          YWidget.currentEdited.mouseCaptureRun(e);
      }, {passive: false});
      document.addEventListener("mouseup", (e) => {
        if (YWidget.currentEdited != null)
          YWidget.currentEdited.mouseCaptureStop(e);
      }, {passive: false});
    }
    this.DrawHandles(this.UIContainer.offsetLeft, this.UIContainer.offsetTop, this.UIContainer.offsetWidth, this.UIContainer.offsetHeight);
    YWidget.HandlesDiv.style.display = "";
    this.rearrangeZindexes();
  }
  DrawHandles(offsetLeft, offsetTop, offsetWidth, offsetHeight) {
    if (YWidget.currentEdited == null)
      return;
    if (YWidget.editHandles.length <= 0)
      return;
    YWidget.HandlesDiv.style.width = offsetWidth.toString() + "px";
    YWidget.HandlesDiv.style.height = offsetHeight.toString() + "px";
    if (this._genRenderer == null)
      debugger;
    let borderWidth = parseFloat(this.UIContainer.style.border);
    let borderMatrix = Matrix3x3.newTranslateMatrix(-borderWidth, -borderWidth);
    YWidget.HandlesDiv.style.transform = borderMatrix.multiplyByM(this._genRenderer.Elm2ScrMatrix).toCSS();
    YWidget.HandlesDiv.style.transform = "top left";
  }
  updateWindowPositionProperties(prop) {
    prop.Form_PositionX = this.PositionX;
    prop.Form_PositionY = this.PositionY;
    prop.Form_Width = this.Width;
    prop.Form_Height = this.Height;
  }
  touchStartCapture(e, handleIndex) {
    if (e.touches.length == 1) {
      this.handleMouseStartCapture(e.touches[0].pageX, e.touches[0].pageY, handleIndex);
      e.preventDefault();
    }
  }
  mouseStartCapture(e, handleIndex) {
    if (e.button != 0)
      return;
    this.handleMouseStartCapture(e.pageX, e.pageY, handleIndex);
  }
  handleMouseStartCapture(pageX, pageY, handleIndex) {
    this.resizeCaptureOriginalMatrix = this._genRenderer.Scr2ElmMatrix;
    this.resizeCaptureOriginalMatrixInv = this._genRenderer.Elm2ScrMatrix;
    let p = this.resizeCaptureOriginalMatrix.multiplyByV(Vector3.FromXYCoord(pageX, pageY)).toPoint();
    this.resizeCaptureRunning = true;
    this.resizeCaptureXOrigine = p.X;
    this.resizeCaptureYOrigine = p.Y;
    this.resizeCaptureOriginalLeft = this.UIContainer.offsetLeft;
    this.resizeCaptureOriginalTop = this.UIContainer.offsetTop;
    this.resizeCaptureOriginalWidth = this.UIContainer.offsetWidth;
    this.resizeCaptureOriginalHeight = this.UIContainer.offsetHeight;
    this.resizeCaptureHandleIndex = handleIndex;
    YWidget.editHandles[this.resizeCaptureHandleIndex].active = true;
    this.previousTRansform = YWidget.HandlesDiv.style.transform;
  }
  touchCaptureRun(e) {
    if (e.touches.length == 1) {
      this.handleCaptureRun(e.touches[0].pageX, e.touches[0].pageY);
      e.preventDefault();
    }
  }
  mouseCaptureRun(e) {
    this.handleCaptureRun(e.pageX, e.pageY);
  }
  handleCaptureRun(pageX, pageY) {
    if (!this.resizeCaptureRunning)
      return;
    let p = this.resizeCaptureOriginalMatrix.multiplyByV(Vector3.FromXYCoord(pageX, pageY)).toPoint();
    let dx = p.X - this.resizeCaptureXOrigine;
    let dy = p.Y - this.resizeCaptureYOrigine;
    let newLeft = this.resizeCaptureOriginalLeft;
    let newTop = this.resizeCaptureOriginalTop;
    let newWidth = this.resizeCaptureOriginalWidth;
    let newHeight = this.resizeCaptureOriginalHeight;
    switch (this.resizeCaptureHandleIndex) {
      case 0:
        newLeft += dx;
        newTop += dy;
        newWidth -= dx;
        newHeight -= dy;
        break;
      case 1:
        newTop += dy;
        newHeight -= dy;
        break;
      case 2:
        newTop += dy;
        newWidth += dx;
        newHeight -= dy;
        break;
      case 3:
        newWidth += dx;
        break;
      case 4:
        newWidth += dx;
        newHeight += dy;
        break;
      case 5:
        newHeight += dy;
        break;
      case 6:
        newLeft += dx;
        newWidth -= dx;
        newHeight += dy;
        break;
      case 7:
        newLeft += dx;
        newWidth -= dx;
        break;
      case 8:
        newLeft += dx;
        newTop += dy;
        break;
    }
    if (newWidth < 2 * YWidget.HANDLESIZE)
      newWidth = 2 * YWidget.HANDLESIZE;
    if (newHeight < 2 * YWidget.HANDLESIZE)
      newHeight = 2 * YWidget.HANDLESIZE;
    this.UIContainer.style.left = newLeft.toString() + "px";
    this.UIContainer.style.top = newTop.toString() + "px";
    if (this.resizeCaptureOriginalWidth != newWidth || this.resizeCaptureOriginalHeight != newHeight) {
      this.resize(newWidth - 2, newHeight - 2);
    }
    this._genRenderer.clearTransformationMatrix();
    YWidget.HandlesDiv.style.width = newWidth.toString() + "px";
    YWidget.HandlesDiv.style.height = newHeight.toString() + "px";
    YWidget.HandlesDiv.style.left = "0px";
    YWidget.HandlesDiv.style.top = "0px";
    let A = this.resizeCaptureOriginalMatrixInv;
    let B = Matrix3x3.newTranslateMatrix(newLeft - this.resizeCaptureOriginalLeft, newTop - this.resizeCaptureOriginalTop);
    let borderWidth = parseFloat(this.UIContainer.style.border);
    let borderMatrix = Matrix3x3.newTranslateMatrix(-borderWidth, -borderWidth);
    YWidget.HandlesDiv.style.transform = borderMatrix.multiplyByM(A.multiplyByM(B)).toCSS();
  }
  editStopped() {
    this.resizeCaptureRunning = false;
    if (YWidget.HandlesDiv != null)
      YWidget.HandlesDiv.style.display = "none";
  }
  touchCaptureStop(e) {
    this.mouseCaptureStop(null);
  }
  mouseCaptureStop(e) {
    if (!this.resizeCaptureRunning)
      return;
    this.resizeCaptureRunning = false;
    YWidget.editHandles[this.resizeCaptureHandleIndex].active = false;
    if (this.previousTRansform != YWidget.HandlesDiv.style.transform || this.resizeCaptureOriginalWidth != this.UIContainer.offsetWidth || this.resizeCaptureOriginalHeight != this.UIContainer.offsetHeight) {
      if (this._SizeIsRelative)
        this.updateRelativeSize();
      constants.edited = true;
    }
    this.refreshProperties();
  }
  resize(newWidth, newHeight) {
    this.UIContainer.style.width = newWidth.toString() + "px";
    this.UIContainer.style.height = newHeight.toString() + "px";
    this.containerResized();
  }
  containerResized() {
  }
  getContentsConfigData() {
    return "  <location x='" + this.UIContainer.offsetLeft.toString() + "' y='" + this.UIContainer.offsetTop.toString() + "'/>\n  <size     w='" + this.UIContainer.offsetWidth.toString() + "' h='" + this.UIContainer.offsetHeight.toString() + "'  state='Normal'/>\n  <relativeCoord x='" + this._relativePositionX.toString() + "' y='" + this._relativePositionY.toString() + "' w='" + this._relativeWidth.toString() + "' h='" + this._relativeHeight.toString() + "' active='" + (this._SizeIsRelative ? "True" : "False") + "'/>\n  <container id='" + constants.XMLquote(this._containerID) + "'/>\n" + this.getPropertiesXml();
  }
  getPropertiesXml() {
    return "";
  }
  PatchSensorAnnotationCallback(sensor, text) {
    let name = "None";
    let avgvalue = "N/A";
    let minvalue = "N/A";
    let maxvalue = "N/A";
    let unit = "";
    if (!(sensor instanceof NullYSensor)) {
      let resolution = -Math.round(Math.log10(sensor.get_resolution()));
      name = sensor.get_friendlyName();
      if (sensor.isOnline()) {
        avgvalue = sensor.get_lastAvgValue().toFixed(resolution);
        minvalue = sensor.get_lastMinValue().toFixed(resolution);
        maxvalue = sensor.get_lastMaxValue().toFixed(resolution);
      }
      unit = sensor.get_unit();
    }
    text = text.replace("$NAME$", name);
    text = text.replace("$AVGVALUE$", avgvalue);
    text = text.replace("$MAXVALUE$", maxvalue);
    text = text.replace("$MINVALUE$", minvalue);
    text = text.replace("$UNIT$", unit);
    return text;
  }
};
YWidget.HANDLESIZE = Math.round(20 * (1 + 2 * (constants.guiDPIFactor - 1)));
YWidget.editHandles = [];
YWidget.currentEdited = null;
var gaugeWidget = class extends YWidget {
  getPropertiesXml() {
    return this.prop.getXml(1);
  }
  containerResized() {
    if (this._gauge != null)
      this._gauge.containerResized();
  }
  destroy() {
    this.prop.destroy();
    super.destroy();
    Object.entries(this).forEach((pair) => {
      Reflect.set(this, pair[0], null);
    });
  }
  contextMenuIsOpening() {
    YWebPage.snapshotMenuItem.userdata = this;
    YWebPage.snapshotMenuItem.visible = true;
    YWebPage.resetDataViewMenuItem.visible = false;
    if (YWebPage.editMenuItem == null)
      return;
    YWebPage.clearDataloggerMenuItem.visible = true;
    YWebPage.editMenuItem.caption = "Configure this gauge";
    YWebPage.editMenuItem.visible = true;
    YWebPage.deleteMenuItem.caption = "Delete this gauge";
    YWebPage.deleteMenuItem.visible = true;
    YWebPage.addMarkerMenuItem.visible = false;
    YWebPage.disableMarkerMenuItem.visible = false;
    YWebPage.editMenuItem.userdata = this;
    YWebPage.deleteMenuItem.userdata = this;
  }
  get confirmDeleteString() {
    return "Do you really want to delete this gauge ?";
  }
  AnnotationCallback(text) {
    let sensor = this.prop.DataSource_source;
    return this.PatchSensorAnnotationCallback(sensor, text);
  }
  constructor(node, editor, x, y, width, height) {
    super(node, editor, x, y, width, height);
    this._gauge = new YSolidGauge(this.UIContainer, YSolidGauge.DisplayMode.DISPLAY90, YWidget.log);
    this._genRenderer = this._gauge;
    this.noDataSourcepanel = this._gauge.addMessagePanel();
    this.noDataSourcepanel.font.size = constants.generalFontSize;
    this.noDataSourcepanel.text = 'No data source configured\n 1 - Make sure you have a Yoctopuce sensor connected.\n 2 - Do a right-click or a long touch on this widget.\n 3 - Choose "Configure this gauge" to bring up the properties editor.\n 4 - Choose a data source\n';
    this.prop = new GaugeFormProperties(node, this);
    this._genProp = this.prop;
    let propDesc = GenericProperties.getAllProperties(this.prop);
    if (gaugeWidget.AnnotationPanelCount == 0) {
      for (let propname in propDesc.byName) {
        if (propname.startsWith("SolidGauge_annotationPanel"))
          gaugeWidget.AnnotationPanelCount++;
      }
    }
    for (let i = 0; i < gaugeWidget.AnnotationPanelCount; i++) {
      this._gauge.addAnnotationPanel();
    }
    this._gauge.setPatchAnnotationCallback((s) => {
      return this.AnnotationCallback(s);
    });
    this._gauge.valueFormater = (source, value) => {
      return this.valueFormater(source, value);
    };
    this.updateWindowPositionProperties(this.prop);
    this.prop.ApplyAllProperties(this);
    YDataRenderer.minMaxCheckDisabled = true;
    this.prop.ApplyAllProperties(this._gauge);
    YDataRenderer.minMaxCheckDisabled = false;
    this._gauge.resetRefrenceSize();
    this._gauge.resizeRule = Proportional.ResizeRule.RELATIVETOBOTH;
    this.ApplyRelativeSizeIfRequired();
    if (this.SizeIsRelative)
      this.refreshProperties();
    this._gauge.AllowRedraw();
  }
  valueFormater(source, value) {
    if (this.prop.DataSource_source instanceof NullYSensor) {
      return "N/A";
    } else if (!this.prop.DataSource_source.isOnline())
      return "OFFLINE";
    let format = this.prop.DataSource_precision;
    let p = format.indexOf(".");
    let n = 0;
    if (p >= 0)
      n = format.length - p - 1;
    let unit = this.prop.DataSource_source.get_unit();
    return value.toFixed(n) + unit;
  }
  PropertyChanged2(src) {
    let info = new PropPathinfo();
    let path = src.ExtractPropPath(info);
    switch (info.propType) {
      case "Form":
        GenericProperties.copyProperty_STT(this, this.prop, info.fullpropname, path);
        break;
      case "SolidGauge":
        GenericProperties.copyProperty_STT(this._gauge, this.prop, info.fullpropname, path);
        break;
      case "DataSource":
        break;
    }
  }
  Get_PropertyValue(src) {
    let info = new PropPathinfo();
    let path = src.ExtractPropPath(info);
    switch (info.propType) {
      case "Form":
        return GenericProperties.newGetProperty(this, this.prop, info.fullpropname, path, null);
      case "SolidGauge":
        return GenericProperties.newGetProperty(this._gauge, this.prop, info.fullpropname, path, null);
    }
    return null;
  }
  edit() {
    super.edit();
    YWebPage.EditObject(this, this.prop, (src) => {
      this.PropertyChanged2(src);
    }, (src) => {
      return this.Get_PropertyValue(src);
    }, () => {
      this.editStopped();
    });
  }
  refreshProperties() {
    this.prop.RefreshAllProperties(this);
    this.prop.RefreshAllProperties(this._gauge);
    YWebPage.refreshPropertiesForm();
  }
  SourceChanged(value, index) {
    this.noDataSourcepanel.enabled = value instanceof NullYSensor;
    if (value instanceof NullYSensor) {
      this._gauge.value = 0;
    } else {
      value.registerCallback(this);
    }
  }
  SensorValuecallback(source, M) {
    if (this.prop == null)
      return;
    if (source == this.prop.DataSource_source) {
      this._gauge.value = source.isOnline() ? M.get_averageValue() : 0;
    }
  }
  getConfigData() {
    return "<GaugeForm>\n" + this.getContentsConfigData() + "</GaugeForm>\n";
  }
};
gaugeWidget.AnnotationPanelCount = 0;
var angularGaugeWidget = class extends YWidget {
  getPropertiesXml() {
    return this.prop.getXml(1);
  }
  containerResized() {
    if (this._angularGauge != null)
      this._angularGauge.containerResized();
  }
  destroy() {
    this.prop.destroy();
    super.destroy();
    Object.entries(this).forEach((pair) => {
      Reflect.set(this, pair[0], null);
    });
  }
  AnnotationCallback(text) {
    let sensor = this.prop.DataSource_source;
    return this.PatchSensorAnnotationCallback(sensor, text);
  }
  contextMenuIsOpening() {
    YWebPage.snapshotMenuItem.userdata = this;
    YWebPage.snapshotMenuItem.visible = true;
    YWebPage.resetDataViewMenuItem.visible = false;
    if (YWebPage.editMenuItem == null)
      return;
    YWebPage.clearDataloggerMenuItem.visible = false;
    YWebPage.editMenuItem.caption = "Configure this gauge";
    YWebPage.editMenuItem.visible = true;
    YWebPage.deleteMenuItem.caption = "Delete this gauge";
    YWebPage.deleteMenuItem.visible = true;
    YWebPage.addMarkerMenuItem.visible = false;
    YWebPage.disableMarkerMenuItem.visible = false;
    YWebPage.editMenuItem.userdata = this;
    YWebPage.deleteMenuItem.userdata = this;
  }
  get confirmDeleteString() {
    return "Do you really want to delete this gauge ?";
  }
  constructor(node, editor, x, y, width, height) {
    super(node, editor, x, y, width, height);
    this._angularGauge = new YAngularGauge(this.UIContainer, YWidget.log);
    this._genRenderer = this._angularGauge;
    this.noDataSourcepanel = this._angularGauge.addMessagePanel();
    this.noDataSourcepanel.font.size = constants.generalFontSize;
    this.noDataSourcepanel.text = 'No data source configured\n 1 - Make sure you have a Yoctopuce sensor connected.\n 2 - Do a right-click  or a long touch on this widget.\n 3 - Choose "Configure this gauge" to bring up the properties editor.\n 4 - Choose a data source\n';
    this.prop = new AngularGaugeFormProperties(node, this);
    this._genProp = this.prop;
    let propDesc = GenericProperties.getAllProperties(this.prop);
    if (angularGaugeWidget.AnnotationPanelCount == 0) {
      for (let propname in propDesc.byName) {
        if (propname.startsWith("AngularGauge_annotationPanel"))
          angularGaugeWidget.AnnotationPanelCount++;
        if (propname.startsWith("AngularGauge_zone"))
          angularGaugeWidget.zonesCount++;
      }
    }
    for (let i = 0; i < angularGaugeWidget.zonesCount; i++) {
      this._angularGauge.AddZone();
    }
    for (let i = 0; i < angularGaugeWidget.AnnotationPanelCount; i++) {
      this._angularGauge.addAnnotationPanel();
    }
    this._angularGauge.setPatchAnnotationCallback((s) => {
      return this.AnnotationCallback(s);
    });
    this.initDataNode = node;
    this.updateWindowPositionProperties(this.prop);
    this.prop.ApplyAllProperties(this);
    YDataRenderer.minMaxCheckDisabled = true;
    this.prop.ApplyAllProperties(this._angularGauge);
    YDataRenderer.minMaxCheckDisabled = false;
    this._angularGauge.resetRefrenceSize();
    this._angularGauge.resizeRule = Proportional.ResizeRule.RELATIVETOBOTH;
    this.ApplyRelativeSizeIfRequired();
    if (this.SizeIsRelative)
      this.refreshProperties();
    this._angularGauge.AllowRedraw();
  }
  PropertyChanged2(src) {
    let info = new PropPathinfo();
    let path = src.ExtractPropPath(info);
    switch (info.propType) {
      case "Form":
        GenericProperties.copyProperty_STT(this, this.prop, info.fullpropname, path);
        break;
      case "AngularGauge":
        GenericProperties.copyProperty_STT(this._angularGauge, this.prop, info.fullpropname, path);
        break;
      case "DataSource":
        break;
    }
  }
  Get_PropertyValue(src) {
    let info = new PropPathinfo();
    let path = src.ExtractPropPath(info);
    switch (info.propType) {
      case "Form":
        return GenericProperties.newGetProperty(this, this.prop, info.fullpropname, path, null);
      case "AngularGauge":
        return GenericProperties.newGetProperty(this._angularGauge, this.prop, info.fullpropname, path, null);
    }
    return null;
  }
  edit() {
    super.edit();
    YWebPage.EditObject(this, this.prop, (src) => {
      this.PropertyChanged2(src);
    }, (src) => {
      return this.Get_PropertyValue(src);
    }, () => {
      this.editStopped();
    });
  }
  refreshProperties() {
    this.prop.RefreshAllProperties(this);
    this.prop.RefreshAllProperties(this._angularGauge);
    YWebPage.refreshPropertiesForm();
  }
  showStatus(status) {
    if (status != "")
      this._angularGauge.value = 0;
    this._angularGauge.showNeedle = status == "";
    this._angularGauge.statusLine = status;
  }
  SourceChanged(value, index) {
    this._angularGauge.DisableRedraw();
    this.noDataSourcepanel.enabled = value instanceof NullYSensor;
    if (value instanceof NullYSensor) {
      this.showStatus("N/A");
      this._angularGauge.unit = "";
    } else if (!value.isOnline()) {
      this.showStatus("OFFLINE");
    } else {
      this.showStatus("");
      this._angularGauge.unit = value.get_unit();
    }
    this._angularGauge.AllowRedraw();
    value.registerCallback(this);
  }
  SensorValuecallback(source, M) {
    if (this.prop == null)
      return;
    if (source == this.prop.DataSource_source) {
      this._angularGauge.DisableRedraw();
      if (this.prop.DataSource_source instanceof NullYSensor) {
        this.showStatus("N/A");
        this._angularGauge.unit = "";
      } else if (!this.prop.DataSource_source.isOnline()) {
        this.showStatus("OFFLINE");
      } else {
        this._angularGauge.DisableRedraw();
        this.showStatus("");
        this._angularGauge.unit = source.get_unit();
        this._angularGauge.value = M.get_averageValue();
        this._angularGauge.AllowRedraw();
      }
      this._angularGauge.AllowRedraw();
    }
  }
  getConfigData() {
    return "<angularGaugeForm>\n" + this.getContentsConfigData() + "</angularGaugeForm>\n";
  }
};
angularGaugeWidget.AnnotationPanelCount = 0;
angularGaugeWidget.zonesCount = 0;
var digitalDisplayWidget = class extends YWidget {
  getPropertiesXml() {
    return this.prop.getXml(1);
  }
  containerResized() {
    if (this._display != null)
      this._display.containerResized();
  }
  destroy() {
    this.prop.destroy();
    super.destroy();
    Object.entries(this).forEach((pair) => {
      Reflect.set(this, pair[0], null);
    });
  }
  AnnotationCallback(text) {
    let sensor = this.prop.DataSource_source;
    return this.PatchSensorAnnotationCallback(sensor, text);
  }
  contextMenuIsOpening() {
    YWebPage.snapshotMenuItem.userdata = this;
    YWebPage.snapshotMenuItem.visible = true;
    YWebPage.resetDataViewMenuItem.visible = false;
    if (YWebPage.editMenuItem == null)
      return;
    YWebPage.clearDataloggerMenuItem.visible = false;
    YWebPage.editMenuItem.caption = "Configure this digital display";
    YWebPage.editMenuItem.visible = true;
    YWebPage.deleteMenuItem.caption = "Delete this digital display";
    YWebPage.deleteMenuItem.visible = true;
    YWebPage.addMarkerMenuItem.visible = false;
    YWebPage.disableMarkerMenuItem.visible = false;
    YWebPage.editMenuItem.userdata = this;
    YWebPage.deleteMenuItem.userdata = this;
  }
  get confirmDeleteString() {
    return "Do you really want to delete this digital display ?";
  }
  constructor(node, editor, x, y, width, height) {
    super(node, editor, x, y, width, height);
    this._unit = "";
    this._display = new YDigitalDisplay(this.UIContainer, YWidget.log);
    this._genRenderer = this._display;
    this.noDataSourcepanel = this._display.addMessagePanel();
    this.noDataSourcepanel.font.size = constants.generalFontSize;
    this.noDataSourcepanel.text = 'No data source configured\n 1 - Make sure you have a Yoctopuce sensor connected.\n 2 - Do a right-click  or a long touch on this widget.\n 3 - Choose "Configure this digital display" to bring up the properties editor.\n 4 - Choose a data source\n';
    this.prop = new digitalDisplayFormProperties(node, this);
    this._genProp = this.prop;
    let propDesc = GenericProperties.getAllProperties(this.prop);
    if (digitalDisplayWidget.AnnotationPanelCount == 0) {
      for (let propname in propDesc.byName) {
        if (propname.startsWith("display_annotationPanel"))
          digitalDisplayWidget.AnnotationPanelCount++;
      }
    }
    for (let i = 0; i < digitalDisplayWidget.AnnotationPanelCount; i++) {
      this._display.addAnnotationPanel();
    }
    this._display.setPatchAnnotationCallback((s) => {
      return this.AnnotationCallback(s);
    });
    this._display.valueFormater = (source, value) => {
      return this.valueFormater(source, value);
    };
    this.updateWindowPositionProperties(this.prop);
    this.prop.ApplyAllProperties(this);
    YDataRenderer.minMaxCheckDisabled = true;
    this.prop.ApplyAllProperties(this._display);
    YDataRenderer.minMaxCheckDisabled = false;
    this._display.resetRefrenceSize();
    this._display.AllowPrintScreenCapture = true;
    this._display.resetRefrenceSize();
    this._display.resizeRule = Proportional.ResizeRule.RELATIVETOBOTH;
    this.ApplyRelativeSizeIfRequired();
    if (this.SizeIsRelative)
      this.refreshProperties();
    this._display.AllowRedraw();
  }
  valueFormater(source, value) {
    if (this.prop.DataSource_source instanceof NullYSensor) {
      return "N/A";
    } else if (!this.prop.DataSource_source.isOnline())
      return "OFFLINE";
    let format = this.prop.DataSource_precision;
    let p = format.indexOf(".");
    let n = 0;
    if (p >= 0)
      n = format.length - p - 1;
    let unit = this.prop.DataSource_source.get_unit();
    return value.toFixed(n) + unit;
  }
  PropertyChanged2(src) {
    let info = new PropPathinfo();
    let path = src.ExtractPropPath(info);
    switch (info.propType) {
      case "Form":
        GenericProperties.copyProperty_STT(this, this.prop, info.fullpropname, path);
        break;
      case "display":
        GenericProperties.copyProperty_STT(this._display, this.prop, info.fullpropname, path);
        break;
      case "DataSource":
        break;
    }
  }
  Get_PropertyValue(src) {
    let info = new PropPathinfo();
    let path = src.ExtractPropPath(info);
    switch (info.propType) {
      case "Form":
        return GenericProperties.newGetProperty(this, this.prop, info.fullpropname, path, null);
      case "display":
        return GenericProperties.newGetProperty(this._display, this.prop, info.fullpropname, path, null);
    }
    return null;
  }
  edit() {
    super.edit();
    YWebPage.EditObject(this, this.prop, (src) => {
      this.PropertyChanged2(src);
    }, (src) => {
      return this.Get_PropertyValue(src);
    }, () => {
      this.editStopped();
    });
  }
  refreshProperties() {
    this.prop.RefreshAllProperties(this);
    this.prop.RefreshAllProperties(this._display);
    YWebPage.refreshPropertiesForm();
  }
  SourceChanged(value, index) {
    this.noDataSourcepanel.enabled = value instanceof NullYSensor;
    this.SensorValuecallback(value, null);
    if (value instanceof NullYSensor) {
      this._display.alternateValue = "N/A";
    } else if (!value.isOnline())
      this._display.alternateValue = "OFFLINE";
    value.registerCallback(this);
  }
  SensorValuecallback(source, M) {
    if (this.prop == null)
      return;
    if (this.prop.DataSource_source instanceof NullYSensor) {
      this._display.alternateValue = "N/A";
    } else if (!this.prop.DataSource_source.isOnline()) {
      this._display.alternateValue = "OFFLINE";
    } else if (M == null) {
      this._display.alternateValue = "--" + this._unit;
    } else if (source == this.prop.DataSource_source) {
      this._display.DisableRedraw();
      this._display.alternateValue = null;
      this._display.value = M.get_averageValue();
      this._display.AllowRedraw();
    }
  }
  getConfigData() {
    return "<digitalDisplayForm>\n" + this.getContentsConfigData() + "</digitalDisplayForm>\n";
  }
};
digitalDisplayWidget.AnnotationPanelCount = 0;
var graphWidget = class extends YWidget {
  AnnotationCallback(text) {
    for (let i = 0; i < graphWidget.SeriesCount; i++) {
      let s = Reflect.get(this.prop, "Graph_series" + i.toString());
      let sensor = s.DataSource_source;
      let name = "None";
      let avgvalue = "N/A";
      let minvalue = "N/A";
      let maxvalue = "N/A";
      let unit = "";
      if (!(sensor instanceof NullYSensor)) {
        let resolution = -Math.round(Math.log10(sensor.get_resolution()));
        name = s.legend != "" ? s.legend : sensor.get_friendlyName();
        if (sensor.isOnline()) {
          avgvalue = sensor.get_lastAvgValue().toFixed(resolution);
          minvalue = sensor.get_lastMinValue().toFixed(resolution);
          maxvalue = sensor.get_lastMaxValue().toFixed(resolution);
        }
        unit = sensor.get_unit();
      }
      text = text.replace("$NAME" + (i + 1).toString() + "$", name);
      text = text.replace("$AVGVALUE" + (i + 1).toString() + "$", avgvalue);
      text = text.replace("$MAXVALUE" + (i + 1).toString() + "$", maxvalue);
      text = text.replace("$MINVALUE" + (i + 1).toString() + "$", minvalue);
      text = text.replace("$UNIT" + (i + 1).toString() + "$", unit);
    }
    return text;
  }
  destroy() {
    this.prop.destroy();
    super.destroy();
    Object.entries(this).forEach((pair) => {
      Reflect.set(this, pair[0], null);
    });
  }
  getPropertiesXml() {
    return this.prop.getXml(1);
  }
  containerResized() {
    if (this._graph != null)
      this._graph.containerResized();
  }
  contextMenuIsOpening() {
    YWebPage.snapshotMenuItem.userdata = this;
    YWebPage.snapshotMenuItem.visible = true;
    YWebPage.resetDataViewMenuItem.visible = true;
    YWebPage.resetDataViewMenuItem.userdata = this;
    if (YWebPage.editMenuItem == null)
      return;
    YWebPage.clearDataloggerMenuItem.visible = true;
    YWebPage.clearDataloggerMenuItem.userdata = this;
    YWebPage.editMenuItem.caption = "Configure this graph";
    YWebPage.editMenuItem.visible = true;
    YWebPage.deleteMenuItem.caption = "Delete this graph";
    YWebPage.deleteMenuItem.visible = true;
    YWebPage.addMarkerMenuItem.visible = true;
    YWebPage.disableMarkerMenuItem.visible = true;
    YWebPage.editMenuItem.userdata = this;
    YWebPage.deleteMenuItem.userdata = this;
    YWebPage.disableMarkerMenuItem.userdata = this;
    for (let i = 0; i < YWebPage.markersSubMenuItems.length; i++) {
      YWebPage.markersSubMenuItems[i].caption = "Place marker #" + (i + 1).toString();
      YWebPage.markersSubMenuItems[i].userdata = this;
    }
  }
  startMarkerCapture(markerIndex) {
    this.markers[markerIndex].startCapture();
  }
  AxisParamtersChangedAutomatically(source) {
    let yaxis = source.userData;
    yaxis.visible = source.visible;
    YWebPage.refreshPropertiesForm();
  }
  get confirmDeleteString() {
    return "Do you really want to delete this graph ?";
  }
  constructor(node, editor, x, y, width, height) {
    super(node, editor, x, y, width, height);
    this.editedMarkerWasEnabled = false;
    this.editedMarkerPosition = 0;
    this._graph = new YGraph(this.UIContainer, YWidget.log);
    this.noDataSourcepanel = this._graph.addMessagePanel();
    this.noDataSourcepanel.font.size = constants.generalFontSize;
    this.noDataSourcepanel.text = 'No data source configured\n 1 - Make sure you have a Yoctopuce sensor connected.\n 2 - Do a right-click  or a long touch on this widget.\n 3 - Choose "Configure this graph" to bring up the properties editor.\n 4 - Choose a data source\n';
    this.dataloggerProgress = this._graph.addMessagePanel();
    this.dataloggerProgress.font.size = 12 * constants.guiDPIFactor;
    this.dataloggerProgress.font.color = YColor.DarkGray;
    this.dataloggerProgress.borderColor = YColor.Gray;
    this.dataloggerProgress.panelHrzAlign = MessagePanel.HorizontalAlignPos.LEFT;
    this.dataloggerProgress.panelVrtAlign = MessagePanel.VerticalAlignPos.TOP;
    this.dataloggerProgress.text = graphWidget.DataLoggerLoadingMsg;
    this.dataloggerProgress.enabled = false;
    this.prop = new GraphFormProperties(node, this);
    this._genProp = this.prop;
    let propDesc = GenericProperties.getAllProperties(this.prop);
    if (graphWidget.YAxisCount == 0) {
      for (let propname in propDesc.byName) {
        if (propname.startsWith("Graph_annotationPanel"))
          graphWidget.AnnotationPanelCount++;
        if (propname.startsWith("Graph_series"))
          graphWidget.SeriesCount++;
        if (propname.startsWith("Graph_yAxes"))
          graphWidget.YAxisCount++;
      }
    }
    if (graphWidget.ZoneCountPerYaxis == 0) {
      let yAxisProp = new YaxisDescription(0, false);
      let propDesc2 = GenericProperties.getAllProperties(yAxisProp);
      for (let propname in propDesc2.byName) {
        if (propname.startsWith("zones"))
          graphWidget.ZoneCountPerYaxis++;
      }
    }
    if (graphWidget.MarkerCountPerXaxis == 0) {
      let xAxisProp = new XaxisDescription();
      let propDesc2 = GenericProperties.getAllProperties(xAxisProp);
      for (let propname in propDesc2.byName) {
        if (propname.startsWith("markers"))
          graphWidget.MarkerCountPerXaxis++;
      }
    }
    this.offLineSourcesPanel = this._graph.addMessagePanel();
    this.offLineSourcesPanel.bgColor = YColor.FromArgb(192, 255, 192, 192);
    this.offLineSourcesPanel.borderColor = YColor.DarkRed;
    this.offLineSourcesPanel.font.color = YColor.DarkRed;
    this.offLineSourcesPanel.panelHrzAlign = MessagePanel.HorizontalAlignPos.RIGHT;
    this.offLineSourcesPanel.panelVrtAlign = MessagePanel.VerticalAlignPos.TOP;
    this.captureRunningPanel = this._graph.addMessagePanel();
    this.captureRunningPanel.bgColor = YColor.FromArgb(240, 200, 255, 193);
    this.captureRunningPanel.borderColor = YColor.DarkGreen;
    this.captureRunningPanel.font.color = YColor.DarkGreen;
    this.captureRunningPanel.panelHrzAlign = MessagePanel.HorizontalAlignPos.LEFT;
    this.captureRunningPanel.panelVrtAlign = MessagePanel.VerticalAlignPos.TOP;
    for (let i = 0; i < graphWidget.YAxisCount; i++) {
      let axis = this._graph.addYAxis();
      for (let j = 0; j < graphWidget.ZoneCountPerYaxis; j++) {
        axis.AddZone();
      }
    }
    this.markers = [];
    for (let i = 0; i < graphWidget.MarkerCountPerXaxis; i++) {
      let m = this._graph.xAxis.AddMarker();
      m.xposition = TimeConverter.ToUnixTime(new Date()) + i * 60;
      this.markers.push(m);
    }
    for (let i = 0; i < graphWidget.AnnotationPanelCount; i++) {
      this._graph.addAnnotationPanel();
    }
    this.seriesProperties = [];
    for (let i = 0; i < graphWidget.SeriesCount; i++) {
      this.seriesProperties.push(Reflect.get(this.prop, "Graph_series" + i.toString()));
      this._graph.addSerie();
    }
    this._graph.yAxes[0].visible = true;
    this._graph.setPatchAnnotationCallback((s) => {
      return this.AnnotationCallback(s);
    });
    this._genRenderer = this._graph;
    this._graph.resetRefrenceSize();
    this._graph.AllowPrintScreenCapture = true;
    this._graph.setMarkerCaptureCallbacks((m) => {
      this.MarkedCaptureStarted(m);
    }, (m) => {
      this.MarkedCaptureStopped(m);
    });
    this.offlineMessages = new Array(graphWidget.SeriesCount);
    this.showOffline = new Array(graphWidget.SeriesCount);
    this.updateWindowPositionProperties(this.prop);
    this.prop.ApplyAllProperties(this);
    YDataRenderer.minMaxCheckDisabled = true;
    this.prop.ApplyAllProperties(this._graph);
    YDataRenderer.minMaxCheckDisabled = false;
    for (let i = 0; i < graphWidget.YAxisCount; i++) {
      this._graph.yAxes[i].AxisChanged = () => {
        this.AxisParamtersChangedAutomatically(this._graph.yAxes[i]);
      };
      this._graph.yAxes[i].AllowAutoShow = true;
    }
    for (let i = 0; i < graphWidget.SeriesCount; i++) {
      let s = Reflect.get(this.prop, "Graph_series" + i.toString());
      s.Init(this, i);
      if (s.DataSource_source != null) {
        this.SourceChanged(s.DataSource_source, i);
      }
    }
    this._graph.resetRefrenceSize();
    this._graph.resizeRule = Proportional.ResizeRule.FIXED;
    this.ApplyRelativeSizeIfRequired();
    if (this.SizeIsRelative)
      this.refreshProperties();
    this.loadRecordedDataIfNeeded();
    this._graph.AllowRedraw();
  }
  MarkedCaptureStarted(src) {
    let str = src.text != "" ? 'Click to place the "' + src.shortText + '" marker.' : "Click to place the marker.";
    str += "\nRight-click to cancel the operation.";
    this.editedMarkerWasEnabled = src.enabled;
    this.editedMarkerPosition = src.positionOnXAxis.value;
    this.captureRunningPanel.text = str;
    this.captureRunningPanel.enabled = true;
  }
  MarkedCaptureStopped(src) {
    if (src != null) {
      if (this.editedMarkerWasEnabled != src.enabled && this.editedMarkerPosition != src.positionOnXAxis.value) {
        constants.edited = true;
      }
    }
    this.captureRunningPanel.enabled = false;
    this.refreshProperties();
  }
  refreshProperties() {
    this.prop.RefreshAllProperties(this);
    this.prop.RefreshAllProperties(this._graph);
    YWebPage.refreshPropertiesForm();
  }
  decomposeToSegments(data, start, dataCount) {
    let n1 = start;
    let n2 = 0;
    let l = [];
    let deltaT = 0;
    while (n1 < start + dataCount - 1) {
      try {
        deltaT = data[n1 + 1].DateTime - data[n1].DateTime;
      } catch (Exception) {
        debugger;
      }
      n2 = n1 + 1;
      while (n2 < dataCount && data[n2].DateTime - data[n2 - 1].DateTime < 2 * deltaT) {
        n2++;
      }
      let count = n2 - n1;
      if (count > 0) {
        let p = new Array(count);
        for (let i = 0; i < count; i++) {
          p[i] = new pointXY(data[n1 + i].DateTime, data[n1 + i].value);
        }
        l.push(p);
      }
      n1 = n2;
    }
    return l;
  }
  SourceChanged(value, index) {
    this._graph.DisableRedraw();
    let s;
    let noDataSource = true;
    for (let i = 0; i < graphWidget.SeriesCount; i++) {
      s = Reflect.get(this.prop, "Graph_series" + i.toString());
      if (!(s.DataSource_source instanceof NullYSensor))
        noDataSource = false;
    }
    this.noDataSourcepanel.enabled = noDataSource;
    if (value != null) {
      if (!(value instanceof NullYSensor)) {
        if (value.isOnline()) {
          this.showOffline[index] = false;
        } else {
          this.offlineMessages[index] = value.get_friendlyName() + " is OFFLINE";
          this.showOffline[index] = true;
          logForm.log(value.get_friendlyName() + " is OFFLINE");
        }
      } else {
        this.showOffline[index] = false;
      }
    } else {
      this.showOffline[index] = false;
    }
    this.updateOfflinePanel();
    this.preLoadSensorData(value, index);
    this.loadRecordedDataIfNeeded();
    if (value)
      value.registerCallback(this);
    this._graph.AllowRedraw();
  }
  SensorArrivalcallback(source) {
    this.loadRecordedDataIfNeeded();
  }
  preLoadSensorData(value, index) {
    if (value instanceof NullYSensor) {
      this._graph.series[index].clear();
      return;
    }
    let s = Reflect.get(this.prop, "Graph_series" + index.toString());
    let data;
    switch (s.DataSource_datatype) {
      case 1:
        data = value.minData;
        break;
      case 2:
        data = value.maxData;
        break;
      default:
        data = value.curData;
        break;
    }
    let l = this.decomposeToSegments(data, 0, data.length);
    this._graph.series[index].clear();
    for (let i = l.length - 1; i >= 0; i--) {
      this._graph.series[index].InsertPoints(l[i]);
    }
    this._graph.series[index].rebuildSummaries();
  }
  PropertyChanged2(src) {
    let info = new PropPathinfo();
    let path = src.ExtractPropPath(info);
    switch (info.propType) {
      case "Form":
        GenericProperties.copyProperty_STT(this, this.prop, info.fullpropname, path);
        break;
      case "Graph":
        GenericProperties.copyProperty_STT(this._graph, this.prop, info.fullpropname, path);
        break;
      case "DataSource":
        break;
    }
  }
  Get_PropertyValue(src) {
    let info = new PropPathinfo();
    let path = src.ExtractPropPath(info);
    switch (info.propType) {
      case "Form":
        return GenericProperties.newGetProperty(this, this.prop, info.fullpropname, path, null);
      case "Graph":
        return GenericProperties.newGetProperty(this._graph, this.prop, info.fullpropname, path, null);
      case "DataSource":
        return null;
    }
    return null;
  }
  edit() {
    super.edit();
    YWebPage.EditObject(this, this.prop, (src) => {
      this.PropertyChanged2(src);
    }, (src) => {
      return this.Get_PropertyValue(src);
    }, () => {
      this.editStopped();
    });
  }
  updateOfflinePanel() {
    let message = "";
    for (let i = 0; i < graphWidget.SeriesCount; i++) {
      if (this.showOffline[i])
        message = message + (message != "" ? "\n" : "") + this.offlineMessages[i];
    }
    if (message == "" && this.offLineSourcesPanel.enabled)
      this.offLineSourcesPanel.enabled = false;
    if (message != "" && (this.offLineSourcesPanel.text != message || !this.offLineSourcesPanel.enabled)) {
      this.offLineSourcesPanel.text = message;
      this.offLineSourcesPanel.enabled = true;
    }
  }
  SensorValuecallback(source, M) {
    if (this.prop == null)
      return;
    for (let i = 0; i < graphWidget.SeriesCount; i++) {
      let s = this.seriesProperties[i];
      if (s.DataSource_source == source) {
        if (!s.DataSource_source.isOnline()) {
          this.offlineMessages[i] = s.DataSource_source.get_friendlyName() + " is OFFLINE";
          this.showOffline[i] = true;
          this.updateOfflinePanel();
          return;
        }
        this.showOffline[i] = false;
        this.updateOfflinePanel();
        let index = s.DataSource_source.curData.length - 1;
        if (index >= 0)
          switch (s.DataSource_datatype) {
            case 1:
              this._graph.series[i].AddPoint(new pointXY(s.DataSource_source.minData[index].DateTime, s.DataSource_source.minData[index].value));
              break;
            case 2:
              this._graph.series[i].AddPoint(new pointXY(s.DataSource_source.maxData[index].DateTime, s.DataSource_source.maxData[index].value));
              break;
            default:
              this._graph.series[i].AddPoint(new pointXY(s.DataSource_source.curData[index].DateTime, s.DataSource_source.curData[index].value));
              break;
          }
        this._graph.series[i].unit = s.DataSource_source.get_unit();
      }
    }
  }
  disableAllMarkers() {
    confirm.ask("Do you really want to disable all markers?", () => {
      for (let i = 0; i < this.markers.length; i++) {
        this.markers[i].enabled = false;
      }
    }, () => {
    }, null);
  }
  clearDataLogger() {
    confirm.ask("Do you really want to erase contents of all dataloggers related to this graph?", () => {
      this.startToClearDataLoggers();
    }, () => {
    }, null);
  }
  truncateView() {
    for (let i = 0; i < graphWidget.SeriesCount; i++) {
      this._graph.series[i].clear();
    }
    let FirstLiveValue = Math.floor(new Date().getTime() / 1e3);
    this._graph.xAxis.set_minMax(FirstLiveValue, FirstLiveValue + this._graph.xAxis.initialZoom);
  }
  resetDataView() {
    this.prop.Graph_showRecordedData = false;
    this.truncateView();
  }
  async startToClearDataLoggers() {
    let loggers = [];
    for (let i = 0; i < graphWidget.SeriesCount; i++) {
      let s = Reflect.get(this.prop, "Graph_series" + i.toString());
      let sensor = s.DataSource_source;
      if (!(sensor instanceof NullYSensor)) {
        sensor.stopDataloggerloading();
        let serial = sensor.get_hardwareId();
        let n = serial.indexOf(".");
        serial = serial.substring(0, n);
        let d = await YDataLogger.FindDataLogger(serial + ".dataLogger");
        if (await d.isOnline()) {
          let found = false;
          for (let j = 0; j < loggers.length; j++) {
            if (loggers[j] == d)
              found = true;
          }
          if (!found)
            loggers.push(d);
        }
      }
    }
    for (let i = 0; i < loggers.length; i++) {
      await loggers[i].forgetAllDataStreams();
      await loggers[i].set_recording(YDataLogger.RECORDING_ON);
    }
    let tmp = this.prop.Graph_showRecordedData;
    this.prop.Graph_showRecordedData = false;
    this.truncateView();
    this.prop.Graph_showRecordedData = tmp;
  }
  dataLoggerLoadprocessIsRunningNotification(source) {
    let loadTotalPercent = 0;
    let sensorCount = 0;
    if (!this.prop.Graph_showRecordedData)
      return;
    for (let i = 0; i < graphWidget.SeriesCount; i++) {
      let s = Reflect.get(this.prop, "Graph_series" + i.toString());
      let sensor = s.DataSource_source;
      if (sensor.dataloggerLoadisRunning) {
        loadTotalPercent += sensor.dataloggerLoadProgress;
        sensorCount++;
      }
    }
    if (sensorCount > 0)
      this.dataloggerProgress.text = graphWidget.DataLoggerLoadingMsg + " (" + (loadTotalPercent / sensorCount).toFixed(0) + "%)";
    let showPanel = sensorCount > 0 && loadTotalPercent > 0 && loadTotalPercent < sensorCount * 100;
    this.dataloggerProgress.enabled = showPanel;
  }
  SensorNewDataBlock(source, sourceFromIndex, sourcetoIndex, targetIndex, fromDataLogger) {
    if (this.prop == null)
      return;
    if (fromDataLogger && !this.prop.Graph_showRecordedData)
      return;
    let l = null;
    for (let i = 0; i < graphWidget.SeriesCount; i++) {
      let s = Reflect.get(this.prop, "Graph_series" + i.toString());
      if (s.DataSource_source == source) {
        let count = sourcetoIndex - sourceFromIndex + 1;
        if (count > 1) {
          switch (s.DataSource_datatype) {
            case 1:
              l = this.decomposeToSegments(s.DataSource_source.minData, sourceFromIndex, count);
              for (let j = l.length - 1; j >= 0; j--) {
                this._graph.series[i].InsertPoints(l[j]);
              }
              break;
            case 2:
              l = this.decomposeToSegments(s.DataSource_source.maxData, sourceFromIndex, count);
              for (let j = l.length - 1; j >= 0; j--) {
                this._graph.series[i].InsertPoints(l[j]);
              }
              break;
            default:
              l = this.decomposeToSegments(s.DataSource_source.curData, sourceFromIndex, count);
              for (let j = l.length - 1; j >= 0; j--) {
                this._graph.series[i].InsertPoints(l[j]);
              }
              break;
          }
        }
      }
    }
  }
  loadRecordedDataIfNeeded() {
    if (this.prop == null)
      return;
    if (!this.prop.Graph_showRecordedData)
      return;
    for (let i = 0; i < graphWidget.SeriesCount; i++) {
      let s = Reflect.get(this.prop, "Graph_series" + i.toString());
      s.DataSource_source.startDataloggerload(this);
    }
  }
  removeDataloggerData() {
  }
  DataloggerCompleted(Source) {
    if (!this.prop.Graph_showRecordedData)
      return;
    let props = GenericProperties.getAllProperties(this.prop);
    for (let i = 0; i < this.seriesProperties.length; i++) {
      if (this.seriesProperties[i].DataSource_source == Source) {
        if (!this.seriesProperties[i].dataloggerAlreadyLoaded) {
          this._graph.DisableRedraw();
          this.preLoadSensorData(Source, i);
          this._graph.AllowRedraw();
        }
      }
    }
  }
  getConfigData() {
    return "<GraphForm>\n" + this.getContentsConfigData() + "</GraphForm>\n";
  }
};
graphWidget.AnnotationPanelCount = 0;
graphWidget.SeriesCount = 0;
graphWidget.ZoneCountPerYaxis = 0;
graphWidget.MarkerCountPerXaxis = 0;
graphWidget.YAxisCount = 0;
graphWidget.DataLoggerLoadingMsg = "Loading from datalogger";

// obj/full/propertiesMngmt.js
var YXmlNode = class {
  constructor(node) {
    this.node = node;
  }
  get Name() {
    return this.node.nodeName;
  }
  get_childsByName() {
    let res = {};
    this.node.childNodes.forEach((child) => {
      res[child.nodeName] = new YXmlNode(child);
    });
    return res;
  }
  get_childsByIndex() {
    let res = [];
    this.node.childNodes.forEach((child) => {
      res.push(new YXmlNode(child));
    });
    return res;
  }
  get_attributes() {
    let el = this.node;
    let res = {};
    let keys = el.getAttributeNames();
    for (let i = 0; i < keys.length; i++) {
      res[keys[i]] = el.getAttribute(keys[i]);
    }
    return res;
  }
  get Attributes() {
    return this.get_attributes();
  }
};
var PropertyAccess = class {
  constructor() {
    this.ttype = "";
    this.stype = "";
    this.finalTarget = null;
    this.terminalSource = null;
    this.propertyName = null;
  }
};
var doubleNan = class {
  constructor(v) {
    this._value = Number.NaN;
    if (typeof v == "undefined") {
      return;
    } else if (typeof v == "number") {
      this._value = v;
    } else if (typeof v == "string") {
      if (v == "") {
        this._value = Number.NaN;
      } else {
        this._value = Number(v);
      }
    } else {
      debugger;
    }
  }
  toString() {
    if (Number.isNaN(this._value))
      return "";
    return this._value.toString();
  }
  clone() {
    return new doubleNan(this.value);
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value;
  }
};
var PropertyDescriptor = class {
  constructor(name) {
    this.isWritable = false;
    this.isEnum = false;
    this.type = "";
    this.Attributes = {};
    this.name = name;
  }
};
var PropertiesList = class {
  constructor() {
    this.byIndex = [];
    this.byName = {};
  }
};
var PropDescription = class {
  constructor(name, prop) {
    this.name = name;
    this.prop = prop;
  }
};
var GenericProperties = class {
  static NoFilter(propNname) {
    return true;
  }
  static escapeXml(unsafe) {
    return unsafe.replace(/[^ !#$%(-;=?-z]/g, (c) => "&#" + c.charCodeAt(0) + ";");
  }
  constructor(Owner) {
    this._Form_Text = "New window";
    this._Form_BackColor = YColor.FromArgb(255, 240, 240, 240);
    this._Form_BorderColor = YColor.LightGray;
    this._SizeIsRelative = false;
    this._Form_PositionX = 0;
    this._Form_PositionY = 0;
    this._Form_Width = 300;
    this._Form_Height = 200;
    this._containerID = "";
    this.ownerForm = Owner;
    this._Form_Text = "new window";
  }
  destroy() {
    Object.entries(this).forEach((pair) => {
      Reflect.set(this, pair[0], null);
    });
  }
  initFromXmlData(initData) {
    if (initData != null)
      this.loadProperties(initData, this.ownerForm, this);
  }
  loadProperties(initData, Owner, o) {
    let value;
    this.ownerForm = Owner;
    if (initData != null) {
      let properties = GenericProperties.getAllProperties(o);
      let childs = initData.get_childsByName();
      for (let propname in properties.byName) {
        let p = properties.byName[propname];
        if (p.isWritable) {
          for (let childName in childs) {
            if (childName == propname) {
              let target = Reflect.get(o, propname);
              let Mustload = true;
              if ("NotSavedInXMLAttribute" in p.Attributes) {
                Mustload = p.Attributes["NotSavedInXMLAttribute"];
              }
              if (Mustload) {
                if (GenericProperties.IsStructured(target)) {
                  this.loadProperties(childs[childName], Owner, target);
                } else {
                  let targetType = typeof target;
                  let attributes = childs[childName].get_attributes();
                  let value2 = attributes["value"];
                  if (target instanceof CustomYSensor) {
                    if (value2.toUpperCase() != "NULL" && value2 != "") {
                      let s = sensorsManager.AddNewSensor(value2);
                      Reflect.set(o, propname, s);
                    } else {
                      Reflect.set(o, propname, sensorsManager.getNullSensor());
                    }
                  } else if (target instanceof YEnumItem) {
                    Reflect.set(o, propname, target.fromString(value2));
                  } else if (target instanceof doubleNan) {
                    let d = new doubleNan(value2);
                    Reflect.set(o, propname, d);
                  } else if (target instanceof xAxisPosition) {
                    let xpos = Number(value2);
                    let rel = attributes["relative"].toUpperCase() == "TRUE";
                    Reflect.set(o, propname, new xAxisPosition(xpos, rel));
                  } else if (target instanceof YColor) {
                    let c = YColor.FromString(value2);
                    if (c == null)
                      c = YColor.Black;
                    Reflect.set(o, propname, c.clone());
                  } else if (target instanceof YFont) {
                    let size = attributes["size"];
                    let color = attributes["color"];
                    let italic = attributes["italic"];
                    let bold = attributes["bold"];
                    let f = Reflect.get(o, propname);
                    f.name = value2;
                    f.size = size !== "undefined" ? Number(size) : 10;
                    let c = YColor.FromString(color);
                    f.color = c != null ? c : YColor.Black.clone();
                    f.italic = italic.toUpperCase() == "TRUE";
                    f.bold = bold.toUpperCase() == "TRUE";
                  } else {
                    switch (targetType) {
                      case "string":
                        Reflect.set(o, propname, value2);
                        break;
                      case "number":
                        Reflect.set(o, propname, Number(value2));
                        break;
                      case "boolean":
                        let v = value2.toUpperCase() == "TRUE";
                        Reflect.set(o, propname, v);
                        break;
                      default:
                        debugger;
                        throw "unhandled target type : " + targetType + "(" + target.constructor.name + ")";
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  get ATTR_Form_Text__DisplayName() {
    return "Window title";
  }
  get ATTR_Form_Text__CategoryAttribute() {
    return "Window";
  }
  get ATTR_Form_Text__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_Form_Text__DescriptionAttribute() {
    return "Widget name. This name is not show on display, but it might help you to identify each widget. ";
  }
  get Form_Text() {
    return this._Form_Text;
  }
  set Form_Text(value) {
    this._Form_Text = value;
  }
  get ATTR_Form_BackColor__DisplayName() {
    return "Background color";
  }
  get ATTR_Form_BackColor__CategoryAttribute() {
    return "Window";
  }
  get ATTR_Form_BackColor__DescriptionAttribute() {
    return "Window background color.";
  }
  get Form_BackColor() {
    return this._Form_BackColor;
  }
  set Form_BackColor(value) {
    this._Form_BackColor = value;
  }
  get ATTR_Form_BorderColor__DisplayName() {
    return "Border color";
  }
  get ATTR_Form_BorderColor__CategoryAttribute() {
    return "Window";
  }
  get ATTR_Form_BorderColor__DescriptionAttribute() {
    return "Window border color, use transparent color to hide the border.";
  }
  get Form_BorderColor() {
    return this._Form_BorderColor;
  }
  set Form_BorderColor(value) {
    this._Form_BorderColor = value;
  }
  get ATTR_Form_SizeIsRelative__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_Form_SizeIsRelative__DisplayName() {
    return "Rel. size and pos.";
  }
  get ATTR_Form_SizeIsRelative__CategoryAttribute() {
    return "Window";
  }
  get ATTR_Form_SizeIsRelative__DescriptionAttribute() {
    return "Makes widget size and position relative to container size. This, for instance, allows to make a widget automatically occupy all of the browser viewport, no matter the browser window size. In relative mode, position and size value are expressed in %";
  }
  get ATTR_Form_SizeIsRelative__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get Form_SizeIsRelative() {
    return this._SizeIsRelative;
  }
  set Form_SizeIsRelative(value) {
    this._SizeIsRelative = value;
  }
  get ATTR_Form_PositionX__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_Form_PositionX__DisplayName() {
    return "Left";
  }
  get ATTR_Form_PositionX__CategoryAttribute() {
    return "Window";
  }
  get ATTR_Form_PositionX__DescriptionAttribute() {
    return "Widget left border X position";
  }
  get Form_PositionX() {
    return this._Form_PositionX;
  }
  set Form_PositionX(value) {
    this._Form_PositionX = value;
  }
  get ATTR_Form_PositionY__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_Form_PositionY__DisplayName() {
    return "Top";
  }
  get ATTR_Form_PositionY__CategoryAttribute() {
    return "Window";
  }
  get ATTR_Form_PositionY__DescriptionAttribute() {
    return "Widget top border Y position";
  }
  get Form_PositionY() {
    return this._Form_PositionY;
  }
  set Form_PositionY(value) {
    this._Form_PositionY = value;
  }
  get ATTR_Form_Width__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_Form_Width__DisplayName() {
    return "Width";
  }
  get ATTR_Form_Width__CategoryAttribute() {
    return "Window";
  }
  get ATTR_Form_Width__DescriptionAttribute() {
    return "Widget width";
  }
  get Form_Width() {
    return this._Form_Width;
  }
  set Form_Width(value) {
    this._Form_Width = value;
  }
  get ATTR_Form_Height__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_Form_Height__DisplayName() {
    return "Height";
  }
  get ATTR_Form_Height__CategoryAttribute() {
    return "Window";
  }
  get ATTR_Form_Height__DescriptionAttribute() {
    return "Widget height";
  }
  get Form_Height() {
    return this._Form_Height;
  }
  set Form_Height(value) {
    this._Form_Height = value;
  }
  get ATTR_Form_containerID__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_Form_containerID__DisplayName() {
    return "Container ID";
  }
  get ATTR_Form_containerID__CategoryAttribute() {
    return "Window";
  }
  get ATTR_Form_containerID__DescriptionAttribute() {
    return "Forces the widget to be shown inside an HTML element with a specific ID already present on the page. If ID is empty, the widget is inserted at root level. Be aware that X,Y offsets are kept, you may want to set them to Zero. ";
  }
  get Form_containerID() {
    return this._containerID;
  }
  set Form_containerID(value) {
    this._containerID = value;
  }
  indent(n) {
    return " ".repeat(n);
  }
  getXml(deep, o) {
    if (typeof o == "undefined")
      o = this;
    let res = "";
    let value = "";
    let properties = GenericProperties.getAllProperties(o);
    let propName = "";
    for (propName in properties.byName) {
      let p = properties.byName[propName];
      if (p.isWritable) {
        let Mustsave = true;
        if ("NotSavedInXMLAttribute" in p.Attributes)
          Mustsave = !p.Attributes["NotSavedInXMLAttribute"];
        let child = Reflect.get(o, p.name);
        if (GenericProperties.IsStructured(child)) {
          if (Mustsave) {
            res = res + this.indent(2 * deep) + "<" + p.name + ">\r\n" + this.getXml(deep + 1, child) + this.indent(2 * deep) + "</" + p.name + ">\r\n";
          }
        } else {
          if (Mustsave) {
            if (child instanceof YEnumItem) {
              value = child.toString;
            } else {
              let type = typeof child;
              if (type == "object")
                type = child.constructor.name;
              switch (type) {
                case "boolean":
                  value = child ? "TRUE" : "FALSE";
                  break;
                case "number":
                  value = child.toString();
                  break;
                case "string":
                  value = GenericProperties.escapeXml(child);
                  break;
                case YColor.name:
                  value = child.toString();
                  break;
                case doubleNan.name:
                  value = child.value.toString();
                  break;
                case xAxisPosition.name:
                  let it = child;
                  value = it.value.toString() + '" relative="' + (it.relative ? "True" : "False");
                  break;
                case NullYSensor.name:
                case CustomYSensor.name:
                  let s = child;
                  value = s == null || s instanceof NullYSensor ? "NULL" : s.get_hardwareId();
                  break;
                default:
                  throw "XML generation : unhandled type (" + p.type + ")";
              }
            }
            res = res + this.indent(2 * deep) + "<" + p.name + ' value="' + value + '"/>\n';
          }
        }
      }
    }
    return res;
  }
  static IsStructured(o) {
    if (o == null)
      return false;
    if (typeof o === "string" || o instanceof String)
      return false;
    if (typeof o === "number" || o instanceof Number)
      return false;
    if (typeof o === "boolean" || o instanceof Boolean)
      return false;
    if (o instanceof YEnumItem)
      return false;
    if (o instanceof CustomYSensor)
      return false;
    if (o instanceof YColor)
      return false;
    if (o instanceof doubleNan)
      return false;
    if (o instanceof xAxisPosition)
      return false;
    if (Object.getOwnPropertyNames(o).length > 0)
      return true;
    return false;
  }
  static getObjectFromPath(rootTarget, path) {
    let FinalTarget = rootTarget;
    for (let i = 0; i < path.length - 1; i++) {
      let name = path[i];
      let index = "";
      while (name.charCodeAt(name.length - 1) >= 48 && name.charCodeAt(name.length - 1) <= 57) {
        index = name.charAt(name.length - 1) + index;
        name = name.substring(0, name.length - 1);
      }
      if (index == "") {
        FinalTarget = Reflect.get(FinalTarget, name);
      } else {
        let arrayObject = Reflect.get(FinalTarget, name);
        FinalTarget = Reflect.get(arrayObject, parseInt(index));
      }
    }
    return FinalTarget;
  }
  static computePropertyAccess_SFT(WidgetObject, SettingObject, propertySourceName, path) {
    let res = new PropertyAccess();
    res.ttype = "";
    res.stype = "";
    res.finalTarget = null;
    res.terminalSource = null;
    res.terminalSource = GenericProperties.getObjectFromPath(WidgetObject, path);
    let props = GenericProperties.getAllProperties(res.terminalSource);
    if (!(path[path.length - 1] in props.byName))
      return res;
    res.stype = typeof res.terminalSource[path[path.length - 1]];
    if (res.stype == "object" && res.terminalSource[path[path.length - 1]] != null) {
      res.stype = res.terminalSource[path[path.length - 1]].constructor.name;
    }
    res.terminalSource = res.terminalSource[path[path.length - 1]];
    if (res.terminalSource == null)
      return res;
    res.propertyName = propertySourceName;
    res.finalTarget = SettingObject;
    let o = res.finalTarget[propertySourceName];
    res.ttype = typeof o;
    if (res.ttype == "object" && o != null)
      res.ttype = o.constructor.name;
    if (path.length <= 1)
      return res;
    for (let i = 1; i < path.length; i++) {
      res.finalTarget = res.finalTarget[res.propertyName];
      res.propertyName = path[i];
    }
    res.ttype = typeof res.finalTarget[res.propertyName];
    if (res.ttype == "object" && res.finalTarget[res.propertyName] != null)
      res.ttype = res.finalTarget[res.propertyName].constructor.name;
    return res;
  }
  static Reflect_getIndexed(o, indexedProp) {
    let res = Reflect.get(o, indexedProp);
    if (typeof res !== "undefined")
      return res;
    let name = indexedProp;
    let index = "";
    while (name.charCodeAt(name.length - 1) >= 48 && name.charCodeAt(name.length - 1) <= 57) {
      index = name.charAt(name.length - 1) + index;
      name = name.substring(0, name.length - 1);
    }
    if (index == "") {
      return null;
    }
    res = Reflect.get(o, name);
    return Reflect.get(res, parseInt(index));
  }
  static computePropertyAccess(rootTarget, source, propertySourceName, path) {
    let res = new PropertyAccess();
    res.ttype = "";
    res.finalTarget = GenericProperties.getObjectFromPath(rootTarget, path);
    res.terminalSource = source;
    res.terminalSource = Reflect.get(res.terminalSource, propertySourceName);
    for (let i = 1; i < path.length; i++) {
      res.terminalSource = Reflect.get(res.terminalSource, path[i]);
    }
    res.stype = typeof res.terminalSource;
    if (res.stype == "object")
      res.stype = res.terminalSource.constructor.name;
    if (path.length > 0) {
      res.propertyName = path[path.length - 1];
      let o = GenericProperties.Reflect_getIndexed(rootTarget, path[0]);
      if (o == null)
        return null;
      for (let i = 1; i < path.length; i++) {
        try {
          o = GenericProperties.Reflect_getIndexed(o, path[i]);
        } catch (e) {
          debugger;
        }
      }
      res.ttype = typeof o;
      if (res.ttype == "object")
        res.ttype = o.constructor.name;
    } else {
      let targetname = propertySourceName;
      let n = targetname.indexOf("__");
      res.propertyName = targetname.substring(n + 2);
      let o = Reflect.get(rootTarget, res.propertyName);
      res.ttype = typeof o;
      if (res.ttype == "object")
        res.ttype = o.constructor.name;
    }
    return res;
  }
  static newGetProperty(rootTarget, source, propertySourceName, path, filterAllow) {
    let access = GenericProperties.computePropertyAccess(rootTarget, source, propertySourceName, path);
    if (access == null)
      return null;
    return Reflect.get(access.finalTarget, access.propertyName);
  }
  static copyProperty_SFT(rootTarget, source, propertySourceName, path, filterAllow) {
    let ttype = "";
    let stype = "";
    let TerminalSource = null;
    let p = GenericProperties.computePropertyAccess_SFT(rootTarget, source, propertySourceName, path);
    if (p.finalTarget == null)
      return;
    ttype = p.ttype;
    stype = p.stype;
    if (stype == YColor.name && ttype == YColor.name) {
      Reflect.set(p.finalTarget, p.propertyName, p.terminalSource.clone());
    } else if (stype == xAxisPosition.name && ttype == xAxisPosition.name) {
      Reflect.set(p.finalTarget, p.propertyName, p.terminalSource.clone());
    } else if (p.stype == "number" && ttype == doubleNan.name) {
      Reflect.set(p.finalTarget, p.propertyName, new doubleNan(p.terminalSource));
    } else {
      Reflect.set(p.finalTarget, p.propertyName, p.terminalSource);
    }
  }
  static copyProperty_STT(rootTarget, source, propertySourceName, path, filterAllow) {
    let p = GenericProperties.computePropertyAccess(rootTarget, source, propertySourceName, path);
    if (p == null)
      return;
    if (p.stype == doubleNan.name && p.ttype == "number") {
      let v = p.terminalSource.value;
      if (Reflect.get(p.finalTarget, p.propertyName) != v) {
        Reflect.set(p.finalTarget, p.propertyName, v);
        constants.edited = true;
      }
    } else if (p.stype != p.ttype) {
      debugger;
    } else if (p.stype == YColor.name && p.ttype == YColor.name) {
      let color = p.terminalSource;
      if (!color.equal(Reflect.get(p.finalTarget, p.propertyName))) {
        Reflect.set(p.finalTarget, p.propertyName, color.clone());
        constants.edited = true;
      }
    } else if (p.stype == doubleNan.name && p.ttype == doubleNan.name) {
      let v = p.terminalSource;
      if (Reflect.get(p.finalTarget, p.propertyName) != v) {
        Reflect.set(p.finalTarget, p.propertyName, v.clone());
        constants.edited = true;
      }
    } else if (p.stype == xAxisPosition.name && p.ttype == xAxisPosition.name) {
      let x = p.terminalSource;
      let x2 = Reflect.get(p.finalTarget, p.propertyName);
      if (x.relative != x2.relative || x.value != x2.value) {
        Reflect.set(p.finalTarget, p.propertyName, x.clone());
        constants.edited = true;
      }
    } else if (Reflect.get(p.finalTarget, p.propertyName) != p.terminalSource) {
      Reflect.set(p.finalTarget, p.propertyName, p.terminalSource);
      constants.edited = true;
    }
  }
  ApplyAllProperties(target) {
    this.ApplyAllPropertiesEx(target, GenericProperties.NoFilter, 0);
  }
  RefreshAllProperties(target) {
    this.ApplyAllPropertiesEx(target, GenericProperties.NoFilter, 1);
  }
  ApplyProperties(rootSource, rootTarget, fullpropname, sourceValue, path, direction) {
    if (sourceValue instanceof AlarmSection)
      return;
    let sourceproperties = GenericProperties.getAllProperties(this);
    if ("CopyToTarget" in sourceproperties.byName[fullpropname].Attributes) {
      if (!sourceproperties.byName[fullpropname].Attributes["CopyToTarget"]) {
        return;
      }
    }
    if (!GenericProperties.IsStructured(sourceValue)) {
      if (direction == 0) {
        GenericProperties.copyProperty_STT(rootTarget, this, fullpropname, path);
      } else {
        GenericProperties.copyProperty_SFT(rootTarget, this, fullpropname, path);
      }
    } else {
      let path2 = path.slice();
      path2.push("");
      let target = GenericProperties.getObjectFromPath(rootTarget, path2);
      Reflect.set(target, "userData", sourceValue);
      let sourceproperties2 = GenericProperties.getAllProperties(sourceValue);
      for (let subpropname in sourceproperties2.byName) {
        let shouldcopy = true;
        if ("CopyToTarget" in sourceproperties2.byName[subpropname].Attributes) {
          shouldcopy = sourceproperties2.byName[subpropname].Attributes["CopyToTarget"];
        }
        if (sourceproperties2.byName[subpropname].isWritable && shouldcopy) {
          path.push(subpropname);
          this.ApplyProperties(rootSource, rootTarget, fullpropname, Reflect.get(sourceValue, subpropname), path, direction);
          path.splice(path.length - 1, 1);
        }
      }
    }
  }
  static isProperty(proto, propName) {
    let d = Reflect.getOwnPropertyDescriptor(proto, propName);
    let list = Object.getOwnPropertyNames(d);
    for (let i = 0; i < list.length; i++) {
      if (list[i] == "set")
        return true;
      if (list[i] == "get")
        return true;
    }
    return false;
  }
  static isWritable(proto, propName) {
    let d = Reflect.getOwnPropertyDescriptor(proto, propName);
    let list = Object.getOwnPropertyNames(d);
    for (let i = 0; i < list.length; i++) {
      if (list[i] == "set") {
        if (typeof d.set !== "undefined")
          return true;
      }
    }
    return false;
  }
  static getAllProperties(o) {
    if (typeof o === "undefined")
      debugger;
    if (o.hasOwnProperty("PropertiesDescriptionCache")) {
      return o["PropertiesDescriptionCache"];
    }
    let proto = Object.getPrototypeOf(o);
    let res = new PropertiesList();
    let p = proto;
    let entries = [];
    let genealogy = [];
    while (p != null) {
      genealogy.push(p);
      p = Object.getPrototypeOf(p);
    }
    for (let j = genealogy.length - 1; j >= 0; j--) {
      let names = Object.getOwnPropertyNames(genealogy[j]);
      let index = 0;
      for (let i = 0; i < names.length; i++) {
        if (names[i] != "constructor" && !names[i].startsWith("__")) {
          entries.splice(index, 0, new PropDescription(names[i], genealogy[j]));
          index++;
          for (let k = entries.length - 1; k >= index; k--) {
            if (entries[k].name == names[i])
              entries.splice(k, 1);
          }
        }
      }
    }
    for (let i = 0; i < entries.length; i++) {
      if (!entries[i].name.startsWith("ATTR") && entries[i].name != "constructor" && !entries[i].name.startsWith("__")) {
        if (GenericProperties.isProperty(entries[i].prop, entries[i].name)) {
          let d = new PropertyDescriptor(entries[i].name);
          res.byIndex.push(d);
          res.byName[d.name] = d;
          d.isWritable = GenericProperties.isWritable(entries[i].prop, entries[i].name);
          d.isEnum = o[entries[i].name] instanceof YEnumItem;
          d.type = typeof o[entries[i].name];
          if (d.type == "object" && o[entries[i].name] != null) {
            d.type = o[entries[i].name].constructor.name;
          }
        }
      }
    }
    for (let i = 0; i < entries.length; i++) {
      if (entries[i].name.startsWith("ATTR_")) {
        let p2 = entries[i].name.indexOf("__");
        if (p2 < 5)
          debugger;
        let name = entries[i].name.substring(5, p2);
        let attr = entries[i].name.substring(p2 + 2);
        if (typeof res.byName[name] === "undefined")
          debugger;
        try {
          res.byName[name].Attributes[attr] = Reflect.get(o, entries[i].name);
        } catch (e) {
          debugger;
        }
      }
    }
    o["PropertiesDescriptionCache"] = res;
    return res;
  }
  ApplyAllPropertiesEx(target, filter, direction) {
    let properties = GenericProperties.getAllProperties(this);
    for (let fullpropname in properties.byName) {
      if (properties.byName[fullpropname].isWritable) {
        let index = fullpropname.indexOf("_");
        if (index < 0)
          throw "invalid Property name";
        let propType = fullpropname.substring(0, index);
        let propname = fullpropname.substring(index + 1);
        let path = [];
        path.push(propname);
        if (target instanceof YWidget && propType == "Form") {
          this.ApplyProperties(this, target, fullpropname, Reflect.get(this, fullpropname), path, direction);
        }
        if (target instanceof YAngularGauge && propType == "AngularGauge") {
          this.ApplyProperties(this, target, fullpropname, Reflect.get(this, fullpropname), path, direction);
        }
        if (target instanceof YDigitalDisplay && propType == "display") {
          this.ApplyProperties(this, target, fullpropname, Reflect.get(this, fullpropname), path, direction);
        }
        if (target instanceof YSolidGauge && propType == "SolidGauge") {
          this.ApplyProperties(this, target, fullpropname, Reflect.get(this, fullpropname), path, direction);
        }
        if (target instanceof YGraph && propType == "Graph") {
          this.ApplyProperties(this, target, fullpropname, Reflect.get(this, fullpropname), path, direction);
        }
      }
    }
  }
};
GenericProperties.XmlFileVersion = -1;

// obj/full/properties.js
var GenericHints = class {
};
GenericHints.DevConfAffected = " Changing this value will affect the device configuration.";
GenericHints.CheckSensor = "If the sensor you want to use is connected, but not listed or listed as OFFLINE, check USB / Network configuration in the global configuration.";
GenericHints.AnnotationGraph = "Annotation text.  Use \\n for carriage returns. Some variables are available: $DAY$ $MONTH$ $YEAR$ for date, $HOUR$ $MINUTE$ $SECOND$ for time, $AVGVALUE1$ $MINVALUE1$ $MAXVALUE1$ $NAME1$ $UNIT1$  for first series data, $AVGVALUE2$ $MINVALUE2$ $MAXVALUE2$ $NAME2$ $UNIT2$  for second series data and so on";
GenericHints.Annotation = "Annotation text.  Use \\n for carriage returns. Some variables are available: $DAY$ $MONTH$ $YEAR$ for date, $HOUR$ $MINUTE$ $SECOND$ for time, $AVGVALUE$ $MINVALUE$ $MAXVALUE$ $NAME$ $UNIT$ for sensor related data.";
var sensorFreqTypeDescription = class {
  static get AllowedValues() {
    return this._AllowedValues;
  }
};
sensorFreqTypeDescription._AllowedValues = [
  "25/s",
  "10/s",
  "5/s",
  "4/s",
  "3/s",
  "2/s",
  "1/s",
  "60/m",
  "30/m",
  "12/m",
  "6/m",
  "4/m",
  "3/m",
  "2/m",
  "1/m",
  "30/h",
  "12/h",
  "6/h",
  "4/h",
  "3/h",
  "2/h",
  "1/h"
];
var yAxisDescription = class {
  static initialize() {
    let yaxiscount = 0;
    let obj = new GraphFormProperties(null, null);
    let names = Object.getOwnPropertyNames(obj);
    names.forEach((name) => {
      if (name.startsWith("_Graph_yAxes"))
        yaxiscount++;
    });
    for (let i = 0; i < yaxiscount; i++) {
      switch (i) {
        case 0:
          this._AllowedValues.push("1rst Y axis");
          break;
        case 1:
          this._AllowedValues.push("2nd Y axis");
          break;
        case 2:
          this._AllowedValues.push("3rd Y axis");
          break;
        default:
          this._AllowedValues.push((i + 1).toString() + "th Y axis");
          break;
      }
    }
    yAxisDescription.initialized = true;
  }
  static get AllowedValues() {
    if (!yAxisDescription.initialized)
      yAxisDescription.initialize();
    return this._AllowedValues;
  }
};
yAxisDescription._AllowedValues = [];
var AlarmTestTypeDescription = class {
  static get AllowedValues() {
    return this._AllowedValues;
  }
};
AlarmTestTypeDescription._AllowedValues = ["Disabled", ">", ">=", "=", "<=", "<"];
var fontNameTypeDescription = class {
  static fontNameTypeDescription() {
  }
  static get AllowedValues() {
    return this._AllowedValues;
  }
};
fontNameTypeDescription._AllowedValues = [
  "Arial",
  "Brush Script MT",
  "Comic Sans MS",
  "Courier New",
  "Garamond",
  "Georgia",
  "Helvetica",
  "Impact",
  "Tahoma",
  "Times New Roman",
  "Trebuchet MS",
  "Verdana"
];
var sensorPrecisionTypeDescription = class {
  static get AllowedValues() {
    return this._AllowedValues;
  }
};
sensorPrecisionTypeDescription._AllowedValues = ["0", "0.1", "0.12", "0.123"];
var sensorDataTypeDescription = class {
  static get AllowedValues() {
    return this._AllowedValues;
  }
};
sensorDataTypeDescription._AllowedValues = ["Avg values", "Min values", "Max values"];
var GaugeFormProperties = class extends GenericProperties {
  constructor(initData, owner) {
    super(owner);
    this._DataSource_source = sensorsManager.getNullSensor();
    this._DataSource_precision = "0.1";
    this._DataSource_AlarmSection0 = new AlarmSection(0);
    this._DataSource_AlarmSection1 = new AlarmSection(1);
    this._SolidGauge_min = 0;
    this._SolidGauge_max = 100;
    this._SolidGauge_showMinMax = true;
    this._SolidGauge_color1 = YColor.LightGreen;
    this._SolidGauge_color2 = YColor.Red;
    this._SolidGauge_font = new FontDescription("Arial", 20, YColor.Black, false, true);
    this._SolidGauge_minMaxFont = new FontDescription("Arial", 10, YColor.Black, false, true);
    this._SolidGauge_displayMode = YSolidGauge.DisplayMode.DISPLAY90;
    this._SolidGauge_borderColor = YColor.Black;
    this._SolidGauge_borderThickness = 2;
    this._SolidGauge_backgroundColor1 = YColor.FromArgb(255, 240, 240, 240);
    this._SolidGauge_backgroundColor2 = YColor.FromArgb(255, 200, 200, 200);
    this._SolidGauge_thickness = 25;
    this._SolidGauge_maxSpeed = 1;
    this._annotationPanels0 = new AnnotationPanelDescription(GenericPanel.HorizontalAlignPos.CENTER, GenericPanel.VerticalAlignPos.BOTTOM, 0, false, "$NAME$", YColor.FromArgb(0, 127, 127, 127), YColor.FromArgb(0, 127, 127, 127), 10, YColor.FromArgb(255, 0, 0, 0));
    this._annotationPanels1 = new AnnotationPanelDescription(GenericPanel.HorizontalAlignPos.CENTER, GenericPanel.VerticalAlignPos.BOTTOM, 0, false, "$NAME$", YColor.FromArgb(0, 127, 127, 127), YColor.FromArgb(0, 127, 127, 127), 10, YColor.FromArgb(255, 0, 0, 0));
    this.initFromXmlData(initData);
    this.PropagateDataSourceChange();
  }
  PropagateDataSourceChange() {
    this.ownerForm.SourceChanged(this._DataSource_source, 0);
    let props = GenericProperties.getAllProperties(this).byName;
    let name;
    for (name in props) {
      if (name.startsWith("DataSource_AlarmSection")) {
        this[name].setDataSource(this._DataSource_source);
      }
    }
  }
  get ATTR_DataSource_source__DisplayName() {
    return "Sensor";
  }
  get ATTR_DataSource_source__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_source__ParamCategorySummaryAttribute() {
    return "sensorDescription";
  }
  get ATTR_DataSource_source__PreExpandedCategoryAttribute() {
    return true;
  }
  get ATTR_DataSource_source__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_DataSource_source__DescriptionAttribute() {
    return "Yoctopuce sensor feeding the gauge. ";
  }
  get DataSource_source() {
    return this._DataSource_source;
  }
  set DataSource_source(value) {
    let prev = this._DataSource_source;
    this._DataSource_source = value;
    this.PropagateDataSourceChange();
    if (this._DataSource_source != prev)
      constants.edited = true;
  }
  get sensorDescription() {
    return this._DataSource_source instanceof NullYSensor ? "none" : this._DataSource_source.get_friendlyName();
  }
  get isSensorReadOnly() {
    return this._DataSource_source.isReadOnly;
  }
  get ATTR_DataSource_freq__DisplayName() {
    return "Sensor freq";
  }
  get ATTR_DataSource_freq__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_freq__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_DataSource_freq__IsReadonlyCallAttribute() {
    return this.isSensorReadOnly;
  }
  get ATTR_DataSource_freq__AllowedValues() {
    return sensorFreqTypeDescription.AllowedValues;
  }
  get ATTR_DataSource_freq__DescriptionAttribute() {
    return "Sensor data acquisition frequency." + GenericHints.DevConfAffected;
  }
  get DataSource_freq() {
    return this._DataSource_source.get_frequency();
  }
  set DataSource_freq(value) {
    this._DataSource_source.set_frequency(value);
  }
  get ATTR_DataSource_precision__DisplayName() {
    return "Precision";
  }
  get ATTR_DataSource_precision__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_precision__DescriptionAttribute() {
    return "How many digits shown after the decimal point";
  }
  get ATTR_DataSource_precision__AllowedValues() {
    return sensorPrecisionTypeDescription.AllowedValues;
  }
  get DataSource_precision() {
    return this._DataSource_precision;
  }
  set DataSource_precision(value) {
    this._DataSource_precision = value;
  }
  get ATTR_DataSource_AlarmSection0__DisplayName() {
    return "Sensor value alarm 1";
  }
  get ATTR_DataSource_AlarmSection0__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection0__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection0__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_AlarmSection0__DescriptionAttribute() {
    return "Alarm 1 for this data source, expand for more.";
  }
  get DataSource_AlarmSection0() {
    return this._DataSource_AlarmSection0;
  }
  set DataSource_AlarmSection0(value) {
    this._DataSource_AlarmSection0 = value;
  }
  get ATTR_DataSource_AlarmSection1__DisplayName() {
    return "Sensor value alarm 2";
  }
  get ATTR_DataSource_AlarmSection1__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection1__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection1__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_AlarmSection1__DescriptionAttribute() {
    return "Alarm 2 for this data source, expand for more.";
  }
  get DataSource_AlarmSection1() {
    return this._DataSource_AlarmSection1;
  }
  set DataSource_AlarmSection1(value) {
    this._DataSource_AlarmSection1 = value;
  }
  get ATTR_SolidGauge_min__DisplayName() {
    return "Minimum value";
  }
  get ATTR_SolidGauge_min__CategoryAttribute() {
    return "Values range";
  }
  get ATTR_SolidGauge_min__DescriptionAttribute() {
    return "Minimum value displayable by the gauge.";
  }
  get SolidGauge_min() {
    return this._SolidGauge_min;
  }
  set SolidGauge_min(value) {
    this._SolidGauge_min = value;
  }
  get ATTR_SolidGauge_max__DisplayName() {
    return "Maximum value";
  }
  get ATTR_SolidGauge_max__CategoryAttribute() {
    return "Values range";
  }
  get ATTR_SolidGauge_max__DescriptionAttribute() {
    return "Maximum value displayable by the gauge.";
  }
  get SolidGauge_max() {
    return this._SolidGauge_max;
  }
  set SolidGauge_max(value) {
    this._SolidGauge_max = value;
  }
  get ATTR_SolidGauge_showMinMax__DisplayName() {
    return "show  min/max";
  }
  get ATTR_SolidGauge_showMinMax__CategoryAttribute() {
    return "Values range";
  }
  get ATTR_SolidGauge_showMinMax__DescriptionAttribute() {
    return "Show the min / max values.";
  }
  get SolidGauge_showMinMax() {
    return this._SolidGauge_showMinMax;
  }
  set SolidGauge_showMinMax(value) {
    this._SolidGauge_showMinMax = value;
  }
  get ATTR_SolidGauge_color1__DisplayName() {
    return "Min Color";
  }
  get ATTR_SolidGauge_color1__CategoryAttribute() {
    return "Values range";
  }
  get ATTR_SolidGauge_color1__DescriptionAttribute() {
    return "Color for minimum value.";
  }
  get SolidGauge_color1() {
    return this._SolidGauge_color1;
  }
  set SolidGauge_color1(value) {
    this._SolidGauge_color1 = value;
  }
  get ATTR_SolidGauge_color2__DisplayName() {
    return "Max Color";
  }
  get ATTR_SolidGauge_color2__CategoryAttribute() {
    return "Values range";
  }
  get ATTR_SolidGauge_color2__DescriptionAttribute() {
    return "Color for maximum value.";
  }
  get SolidGauge_color2() {
    return this._SolidGauge_color2;
  }
  set SolidGauge_color2(value) {
    this._SolidGauge_color2 = value;
  }
  get ATTR_SolidGauge_font__DisplayName() {
    return "Unit  Font";
  }
  get ATTR_SolidGauge_font__CategoryAttribute() {
    return "Fonts";
  }
  get ATTR_SolidGauge_font__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_SolidGauge_font__DescriptionAttribute() {
    return "Font for displaying the value/status indicator";
  }
  get SolidGauge_font() {
    return this._SolidGauge_font;
  }
  set SolidGauge_font(value) {
    this._SolidGauge_font = value;
  }
  get ATTR_SolidGauge_minMaxFont__DisplayName() {
    return "Min Max  Font";
  }
  get ATTR_SolidGauge_minMaxFont__CategoryAttribute() {
    return "Fonts";
  }
  get ATTR_SolidGauge_minMaxFont__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_SolidGauge_minMaxFont__DescriptionAttribute() {
    return "Font for displaying min/max values";
  }
  get SolidGauge_minMaxFont() {
    return this._SolidGauge_minMaxFont;
  }
  set SolidGauge_minMaxFont(value) {
    this._SolidGauge_minMaxFont = value;
  }
  get ATTR_SolidGauge_displayMode__DisplayName() {
    return "Display mode";
  }
  get ATTR_SolidGauge_displayMode__CategoryAttribute() {
    return "Dial";
  }
  get ATTR_SolidGauge_displayMode__DescriptionAttribute() {
    return "Dial general shape";
  }
  get SolidGauge_displayMode() {
    return this._SolidGauge_displayMode;
  }
  set SolidGauge_displayMode(value) {
    this._SolidGauge_displayMode = value;
  }
  get ATTR_SolidGauge_borderColor__DisplayName() {
    return "Border color";
  }
  get ATTR_SolidGauge_borderColor__CategoryAttribute() {
    return "Dial";
  }
  get ATTR_SolidGauge_borderColor__DescriptionAttribute() {
    return "Dial border color.";
  }
  get SolidGauge_borderColor() {
    return this._SolidGauge_borderColor;
  }
  set SolidGauge_borderColor(value) {
    this._SolidGauge_borderColor = value;
  }
  get ATTR_SolidGauge_borderThickness__DisplayName() {
    return "Border thickness ";
  }
  get ATTR_SolidGauge_borderThickness__CategoryAttribute() {
    return "Dial";
  }
  get ATTR_SolidGauge_borderThickness__DescriptionAttribute() {
    return "Thickness of the dial border";
  }
  get SolidGauge_borderThickness() {
    return this._SolidGauge_borderThickness;
  }
  set SolidGauge_borderThickness(value) {
    this._SolidGauge_borderThickness = value;
  }
  get ATTR_SolidGauge_backgroundColor1__DisplayName() {
    return "Background color 1";
  }
  get ATTR_SolidGauge_backgroundColor1__CategoryAttribute() {
    return "Dial";
  }
  get ATTR_SolidGauge_backgroundColor1__DescriptionAttribute() {
    return "Dial background gradient color 1.";
  }
  get SolidGauge_backgroundColor1() {
    return this._SolidGauge_backgroundColor1;
  }
  set SolidGauge_backgroundColor1(value) {
    this._SolidGauge_backgroundColor1 = value;
  }
  get ATTR_SolidGauge_backgroundColor2__DisplayName() {
    return "Background color 2";
  }
  get ATTR_SolidGauge_backgroundColor2__CategoryAttribute() {
    return "Dial";
  }
  get ATTR_SolidGauge_backgroundColor2__DescriptionAttribute() {
    return "Dial background gradient color 2.";
  }
  get SolidGauge_backgroundColor2() {
    return this._SolidGauge_backgroundColor2;
  }
  set SolidGauge_backgroundColor2(value) {
    this._SolidGauge_backgroundColor2 = value;
  }
  get ATTR_SolidGauge_thickness__DisplayName() {
    return "Dial thickness (%) ";
  }
  get ATTR_SolidGauge_thickness__CategoryAttribute() {
    return "Dial";
  }
  get ATTR_SolidGauge_thickness__DescriptionAttribute() {
    return "Thickness of the dial, in percentage relative to radius";
  }
  get SolidGauge_thickness() {
    return this._SolidGauge_thickness;
  }
  set SolidGauge_thickness(value) {
    this._SolidGauge_thickness = value;
  }
  get ATTR_SolidGauge_maxSpeed__DisplayName() {
    return "Max speed (%) ";
  }
  get ATTR_SolidGauge_maxSpeed__CategoryAttribute() {
    return "Dial";
  }
  get ATTR_SolidGauge_maxSpeed__DescriptionAttribute() {
    return 'Maximum speed of the dial in percentage relative to Max-Min. This is meant to limit "teleporting" effects.';
  }
  get SolidGauge_maxSpeed() {
    return this._SolidGauge_maxSpeed;
  }
  set SolidGauge_maxSpeed(value) {
    this._SolidGauge_maxSpeed = value;
  }
  IsDataSourceAssigned() {
    return !(this._DataSource_source instanceof NullYSensor);
  }
  get ATTR_SolidGauge_annotationPanels0__DisplayName() {
    return "Annotation 1";
  }
  get ATTR_SolidGauge_annotationPanels0__CategoryAttribute() {
    return "Annotations";
  }
  get ATTR_SolidGauge_annotationPanels0__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_SolidGauge_annotationPanels0__DescriptionAttribute() {
    return "Customizable text panels";
  }
  get SolidGauge_annotationPanels0() {
    return this._annotationPanels0;
  }
  set SolidGauge_annotationPanels0(value) {
    this._annotationPanels0 = value;
  }
  get ATTR_SolidGauge_annotationPanels1__DisplayName() {
    return "Annotation 2";
  }
  get ATTR_SolidGauge_annotationPanels1__CategoryAttribute() {
    return "Annotations";
  }
  get ATTR_SolidGauge_annotationPanels1__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_SolidGauge_annotationPanels1__DescriptionAttribute() {
    return "Customizable text panels";
  }
  get SolidGauge_annotationPanels1() {
    return this._annotationPanels1;
  }
  set SolidGauge_annotationPanels1(value) {
    this._annotationPanels1 = value;
  }
};
var AngularGaugeFormProperties = class extends GenericProperties {
  constructor(initData, owner) {
    super(owner);
    this._DataSource_source = sensorsManager.getNullSensor();
    this._DataSource_AlarmSection0 = new AlarmSection(0);
    this._DataSource_AlarmSection1 = new AlarmSection(1);
    this._AngularGauge_min = 0;
    this._AngularGauge_max = 100;
    this._AngularGauge_unitFactor = 1;
    this._AngularGauge_graduation = 10;
    this._AngularGauge_graduationSize = 10;
    this._AngularGauge_graduationOuterRadiusSize = 98;
    this._AngularGauge_graduationThickness = 2;
    this._AngularGauge_graduationColor = YColor.Black;
    this._AngularGauge_graduationFont = new FontDescription("Arial", 20, YColor.Black, false, true);
    this._AngularGauge_subgraduationCount = 5;
    this._AngularGauge_subgraduationSize = 5;
    this._AngularGauge_subgraduationThickness = 1;
    this._AngularGauge_subgraduationColor = YColor.Black;
    this._AngularGauge_needleColor = YColor.Red;
    this._AngularGauge_needleContourColor = YColor.DarkRed;
    this._AngularGauge_needleContourThickness = 1;
    this._AngularGauge_needleLength1 = 90;
    this._AngularGauge_needleLength2 = 15;
    this._AngularGauge_needleWidth = 5;
    this._AngularGauge_needleMaxSpeed = 0.5;
    this._AngularGauge_unitFont = new FontDescription("Arial", 24, YColor.DarkGray, false, true);
    this._AngularGauge_statusFont = new FontDescription("Arial", 24, YColor.DarkGray, false, true);
    this._AngularGauge_borderColor = YColor.Black;
    this._AngularGauge_borderThickness = 5;
    this._AngularGauge_backgroundColor1 = YColor.FromArgb(255, 240, 240, 240);
    this._AngularGauge_backgroundColor2 = YColor.FromArgb(255, 200, 200, 200);
    this._AngularGauge_zones0 = new AngularZoneDescription(0, 50, YColor.LightGreen);
    this._AngularGauge_zones1 = new AngularZoneDescription(50, 80, YColor.Yellow);
    this._AngularGauge_zones2 = new AngularZoneDescription(80, 100, YColor.Red);
    this._annotationPanels0 = new AnnotationPanelDescription(GenericPanel.HorizontalAlignPos.CENTER, GenericPanel.VerticalAlignPos.CENTER, 0, false, "$NAME$", YColor.FromArgb(0, 127, 127, 127), YColor.FromArgb(0, 127, 127, 127), 10, YColor.FromArgb(255, 0, 0, 0));
    this._annotationPanels1 = new AnnotationPanelDescription(GenericPanel.HorizontalAlignPos.CENTER, GenericPanel.VerticalAlignPos.BOTTOM, 0, false, "$NAME$", YColor.FromArgb(0, 127, 127, 127), YColor.FromArgb(0, 127, 127, 127), 10, YColor.FromArgb(255, 0, 0, 0));
    this.initFromXmlData(initData);
    this.PropagateDataSourceChange();
  }
  PropagateDataSourceChange() {
    this.ownerForm.SourceChanged(this._DataSource_source, 0);
    let props = GenericProperties.getAllProperties(this).byName;
    let name;
    for (name in props) {
      if (name.startsWith("DataSource_AlarmSection")) {
        this[name].setDataSource(this._DataSource_source);
      }
    }
  }
  IsDataSourceAssigned() {
    return !(this._DataSource_source instanceof NullYSensor);
  }
  get ATTR_DataSource_source__DisplayName() {
    return "Sensor";
  }
  get ATTR_DataSource_source__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_source__ParamCategorySummaryAttribute() {
    return "sensorDescription";
  }
  get ATTR_DataSource_source__PreExpandedCategoryAttribute() {
    return true;
  }
  get ATTR_DataSource_source__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_DataSource_source__DescriptionAttribute() {
    return "Yoctopuce sensor feeding the gauge. " + GenericHints.CheckSensor;
  }
  get DataSource_source() {
    return this._DataSource_source;
  }
  set DataSource_source(value) {
    let prev = this._DataSource_source;
    this._DataSource_source = value;
    this.PropagateDataSourceChange();
    if (this._DataSource_source != prev)
      constants.edited = true;
  }
  get sensorDescription() {
    return this._DataSource_source instanceof NullYSensor ? "none" : this._DataSource_source.get_friendlyName();
  }
  get isSensorReadOnly() {
    return this._DataSource_source.isReadOnly;
  }
  get ATTR_DataSource_freq__DisplayName() {
    return "Sensor freq";
  }
  get ATTR_DataSource_freq__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_freq__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_DataSource_freq__IsReadonlyCallAttribute() {
    return "isSensorReadOnly";
  }
  get ATTR_DataSource_freq__DescriptionAttribute() {
    return "Sensor data acquisition frequency." + GenericHints.DevConfAffected;
  }
  get ATTR_DataSource_freq__AllowedValues() {
    return sensorFreqTypeDescription.AllowedValues;
  }
  get DataSource_freq() {
    return this._DataSource_source.get_frequency();
  }
  set DataSource_freq(value) {
    this._DataSource_source.set_frequency(value);
  }
  get ATTR_DataSource_AlarmSection0__DisplayName() {
    return "Sensor value alarm 1";
  }
  get ATTR_DataSource_AlarmSection0__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection0__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection0__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_AlarmSection0__DescriptionAttribute() {
    return "Alarm 1 for this data source, expand for more.";
  }
  get DataSource_AlarmSection0() {
    return this._DataSource_AlarmSection0;
  }
  set DataSource_AlarmSection0(value) {
    this._DataSource_AlarmSection0 = value;
  }
  get ATTR_DataSource_AlarmSection1__DisplayName() {
    return "Sensor value alarm 2";
  }
  get ATTR_DataSource_AlarmSection1__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection1__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection1__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_AlarmSection1__DescriptionAttribute() {
    return "Alarm 2 for this data source, expand for more.";
  }
  get DataSource_AlarmSection1() {
    return this._DataSource_AlarmSection1;
  }
  set DataSource_AlarmSection1(value) {
    this._DataSource_AlarmSection1 = value;
  }
  get ATTR_AngularGauge_min__DisplayName() {
    return "Minimum value";
  }
  get ATTR_AngularGauge_min__CategoryAttribute() {
    return "Gauge gradations";
  }
  get ATTR_AngularGauge_min__DescriptionAttribute() {
    return "Minimum value displayable by the gauge.";
  }
  get AngularGauge_min() {
    return this._AngularGauge_min;
  }
  set AngularGauge_min(value) {
    this._AngularGauge_min = value;
  }
  get ATTR_AngularGauge_max__DisplayName() {
    return "Maximum value";
  }
  get ATTR_AngularGauge_max__CategoryAttribute() {
    return "Gauge gradations";
  }
  get ATTR_AngularGauge_max__DescriptionAttribute() {
    return "Maximum value displayable by the gauge.";
  }
  get AngularGauge_max() {
    return this._AngularGauge_max;
  }
  set AngularGauge_max(value) {
    this._AngularGauge_max = value;
  }
  get ATTR_AngularGauge_unitFactor__DisplayName() {
    return "Unit factor";
  }
  get ATTR_AngularGauge_unitFactor__CategoryAttribute() {
    return "Gauge gradations";
  }
  get ATTR_AngularGauge_unitFactor__DescriptionAttribute() {
    return "Data  will be divided by this value before being displayed, this allows simpler gradation marks.";
  }
  get AngularGauge_unitFactor() {
    return this._AngularGauge_unitFactor;
  }
  set AngularGauge_unitFactor(value) {
    this._AngularGauge_unitFactor = value;
  }
  get ATTR_AngularGauge_graduation__DisplayName() {
    return "Main gradation steps";
  }
  get ATTR_AngularGauge_graduation__CategoryAttribute() {
    return "Gauge gradations";
  }
  get ATTR_AngularGauge_graduation__DescriptionAttribute() {
    return "Difference between two consecutive main gradation marks";
  }
  get AngularGauge_graduation() {
    return this._AngularGauge_graduation;
  }
  set AngularGauge_graduation(value) {
    this._AngularGauge_graduation = value;
  }
  get ATTR_AngularGauge_graduationSize__DisplayName() {
    return "Main gradation size (%)";
  }
  get ATTR_AngularGauge_graduationSize__CategoryAttribute() {
    return "Gauge gradations";
  }
  get ATTR_AngularGauge_graduationSize__DescriptionAttribute() {
    return "Main gradation marks size in percent, relative to dial radius";
  }
  get AngularGauge_graduationSize() {
    return this._AngularGauge_graduationSize;
  }
  set AngularGauge_graduationSize(value) {
    this._AngularGauge_graduationSize = value;
  }
  get ATTR_AngularGauge_graduationOuterRadiusSize__DisplayName() {
    return "Main gradation radius (%)";
  }
  get ATTR_AngularGauge_graduationOuterRadiusSize__CategoryAttribute() {
    return "Gauge gradations";
  }
  get ATTR_AngularGauge_graduationOuterRadiusSize__DescriptionAttribute() {
    return "Main gradation marks outer radius in percent, relative to dial radius";
  }
  get AngularGauge_graduationOuterRadiusSize() {
    return this._AngularGauge_graduationOuterRadiusSize;
  }
  set AngularGauge_graduationOuterRadiusSize(value) {
    this._AngularGauge_graduationOuterRadiusSize = value;
  }
  get ATTR_AngularGauge_graduationThickness__DisplayName() {
    return "Main gradation thickness";
  }
  get ATTR_AngularGauge_graduationThickness__CategoryAttribute() {
    return "Gauge gradations";
  }
  get ATTR_AngularGauge_graduationThickness__DescriptionAttribute() {
    return "Main gradation marks thickness";
  }
  get AngularGauge_graduationThickness() {
    return this._AngularGauge_graduationThickness;
  }
  set AngularGauge_graduationThickness(value) {
    this._AngularGauge_graduationThickness = value;
  }
  get ATTR_AngularGauge_graduationColor__DisplayName() {
    return "Main gradation color";
  }
  get ATTR_AngularGauge_graduationColor__CategoryAttribute() {
    return "Gauge gradations";
  }
  get ATTR_AngularGauge_graduationColor__DescriptionAttribute() {
    return "Main gradation marks color.";
  }
  get AngularGauge_graduationColor() {
    return this._AngularGauge_graduationColor;
  }
  set AngularGauge_graduationColor(value) {
    this._AngularGauge_graduationColor = value;
  }
  get ATTR_AngularGauge_graduationFont__DisplayName() {
    return "Main gradation font";
  }
  get ATTR_AngularGauge_graduationFont__CategoryAttribute() {
    return "Gauge gradations";
  }
  get ATTR_AngularGauge_graduationFont__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_AngularGauge_graduationFont__DescriptionAttribute() {
    return "Font used for gradation labels";
  }
  get AngularGauge_graduationFont() {
    return this._AngularGauge_graduationFont;
  }
  set AngularGauge_graduationFont(value) {
    this._AngularGauge_graduationFont = value;
  }
  get ATTR_AngularGauge_subgraduationCount__DisplayName() {
    return "Sub-gradation count";
  }
  get ATTR_AngularGauge_subgraduationCount__CategoryAttribute() {
    return "Gauge gradations";
  }
  get ATTR_AngularGauge_subgraduationCount__DescriptionAttribute() {
    return "How many sub-gradation (+1) marks between two consecutive main graduation marks";
  }
  get AngularGauge_subgraduationCount() {
    return this._AngularGauge_subgraduationCount;
  }
  set AngularGauge_subgraduationCount(value) {
    this._AngularGauge_subgraduationCount = value;
  }
  get ATTR_AngularGauge_subgraduationSize__DisplayName() {
    return "Sub-gradation size (%)";
  }
  get ATTR_AngularGauge_subgraduationSize__CategoryAttribute() {
    return "Gauge gradations";
  }
  get ATTR_AngularGauge_subgraduationSize__DescriptionAttribute() {
    return "Sub-gradation marks size in percent, relative to dial radius";
  }
  get AngularGauge_subgraduationSize() {
    return this._AngularGauge_subgraduationSize;
  }
  set AngularGauge_subgraduationSize(value) {
    this._AngularGauge_subgraduationSize = value;
  }
  get ATTR_AngularGauge_subgraduationThickness__DisplayName() {
    return "Sub-gradation thickness";
  }
  get ATTR_AngularGauge_subgraduationThickness__CategoryAttribute() {
    return "Gauge gradations";
  }
  get ATTR_AngularGauge_subgraduationThickness__DescriptionAttribute() {
    return "Sub-gradation marks thickness";
  }
  get AngularGauge_subgraduationThickness() {
    return this._AngularGauge_subgraduationThickness;
  }
  set AngularGauge_subgraduationThickness(value) {
    this._AngularGauge_subgraduationThickness = value;
  }
  get ATTR_AngularGauge_subgraduationColor__DisplayName() {
    return "Sub-gradation color";
  }
  get ATTR_AngularGauge_subgraduationColor__CategoryAttribute() {
    return "Gauge gradations";
  }
  get ATTR_AngularGauge_subgraduationColor__DescriptionAttribute() {
    return "Sub-gradation marks color.";
  }
  get AngularGauge_subgraduationColor() {
    return this._AngularGauge_subgraduationColor;
  }
  set AngularGauge_subgraduationColor(value) {
    this._AngularGauge_subgraduationColor = value;
  }
  get ATTR_AngularGauge_needleColor__DisplayName() {
    return "Needle color";
  }
  get ATTR_AngularGauge_needleColor__CategoryAttribute() {
    return "Needle";
  }
  get ATTR_AngularGauge_needleColor__DescriptionAttribute() {
    return "Needle filling color.";
  }
  get AngularGauge_needleColor() {
    return this._AngularGauge_needleColor;
  }
  set AngularGauge_needleColor(value) {
    this._AngularGauge_needleColor = value;
  }
  get ATTR_AngularGauge_needleContourColor__DisplayName() {
    return "Needle contour color";
  }
  get ATTR_AngularGauge_needleContourColor__CategoryAttribute() {
    return "Needle";
  }
  get ATTR_AngularGauge_needleContourColor__DescriptionAttribute() {
    return "Needle contour color.";
  }
  get AngularGauge_needleContourColor() {
    return this._AngularGauge_needleContourColor;
  }
  set AngularGauge_needleContourColor(value) {
    this._AngularGauge_needleContourColor = value;
  }
  get ATTR_AngularGauge_needleContourThickness__DisplayName() {
    return "Needle contour thickness";
  }
  get ATTR_AngularGauge_needleContourThickness__CategoryAttribute() {
    return "Needle";
  }
  get ATTR_AngularGauge_needleContourThickness__DescriptionAttribute() {
    return "Thickness of the needle contour";
  }
  get AngularGauge_needleContourThickness() {
    return this._AngularGauge_needleContourThickness;
  }
  set AngularGauge_needleContourThickness(value) {
    this._AngularGauge_needleContourThickness = value;
  }
  get ATTR_AngularGauge_needleLength1__DisplayName() {
    return "Needle main size (%)";
  }
  get ATTR_AngularGauge_needleLength1__CategoryAttribute() {
    return "Needle";
  }
  get ATTR_AngularGauge_needleLength1__DescriptionAttribute() {
    return "Length of the needle part pointing to gradations, in % relative to radius";
  }
  get AngularGauge_needleLength1() {
    return this._AngularGauge_needleLength1;
  }
  set AngularGauge_needleLength1(value) {
    this._AngularGauge_needleLength1 = value;
  }
  get ATTR_AngularGauge_needleLength2__DisplayName() {
    return "Needle foot size (%)";
  }
  get ATTR_AngularGauge_needleLength2__CategoryAttribute() {
    return "Needle";
  }
  get ATTR_AngularGauge_needleLength2__DescriptionAttribute() {
    return "Length of the needle part not pointing to gradations, in % relative to radius";
  }
  get AngularGauge_needleLength2() {
    return this._AngularGauge_needleLength2;
  }
  set AngularGauge_needleLength2(value) {
    this._AngularGauge_needleLength2 = value;
  }
  get ATTR_AngularGauge_needleWidth__DisplayName() {
    return "Needle width (%)";
  }
  get ATTR_AngularGauge_needleWidth__CategoryAttribute() {
    return "Needle";
  }
  get ATTR_AngularGauge_needleWidth__DescriptionAttribute() {
    return "Width of the needle, in % relative to radius";
  }
  get AngularGauge_needleWidth() {
    return this._AngularGauge_needleWidth;
  }
  set AngularGauge_needleWidth(value) {
    this._AngularGauge_needleWidth = value;
  }
  get ATTR_AngularGauge_needleMaxSpeed__DisplayName() {
    return "Needle max speed (%)";
  }
  get ATTR_AngularGauge_needleMaxSpeed__CategoryAttribute() {
    return "Needle";
  }
  get ATTR_AngularGauge_needleMaxSpeed__DescriptionAttribute() {
    return 'Needle Maximum speed, in % relative to (max-min). This is meant to limit "teleporting" effects.';
  }
  get AngularGauge_needleMaxSpeed() {
    return this._AngularGauge_needleMaxSpeed;
  }
  set AngularGauge_needleMaxSpeed(value) {
    this._AngularGauge_needleMaxSpeed = value;
  }
  get ATTR_AngularGauge_unitFont__DisplayName() {
    return "Unit Line Font";
  }
  get ATTR_AngularGauge_unitFont__CategoryAttribute() {
    return "Text lines";
  }
  get ATTR_AngularGauge_unitFont__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_AngularGauge_unitFont__DescriptionAttribute() {
    return "Font used in the text line describing unit";
  }
  get AngularGauge_unitFont() {
    return this._AngularGauge_unitFont;
  }
  set AngularGauge_unitFont(value) {
    this._AngularGauge_unitFont = value;
  }
  get ATTR_AngularGauge_statusFont__DisplayName() {
    return "Status Line Font";
  }
  get ATTR_AngularGauge_statusFont__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_AngularGauge_statusFont__CategoryAttribute() {
    return "Text lines";
  }
  get ATTR_AngularGauge_statusFont__DescriptionAttribute() {
    return "Font used in the text line gauge status";
  }
  get AngularGauge_statusFont() {
    return this._AngularGauge_statusFont;
  }
  set AngularGauge_statusFont(value) {
    this._AngularGauge_statusFont = value;
  }
  get ATTR_AngularGauge_borderColor__DisplayName() {
    return "Border color";
  }
  get ATTR_AngularGauge_borderColor__CategoryAttribute() {
    return "Dial";
  }
  get ATTR_AngularGauge_borderColor__DescriptionAttribute() {
    return "Dial border color.";
  }
  get AngularGauge_borderColor() {
    return this._AngularGauge_borderColor;
  }
  set AngularGauge_borderColor(value) {
    this._AngularGauge_borderColor = value;
  }
  get ATTR_AngularGauge_borderThickness__DisplayName() {
    return "Border thickness ";
  }
  get ATTR_AngularGauge_borderThickness__CategoryAttribute() {
    return "Dial";
  }
  get ATTR_AngularGauge_borderThickness__DescriptionAttribute() {
    return "Thickness of the dial border";
  }
  get AngularGauge_borderThickness() {
    return this._AngularGauge_borderThickness;
  }
  set AngularGauge_borderThickness(value) {
    this._AngularGauge_borderThickness = value;
  }
  get ATTR_AngularGauge_backgroundColor1__DisplayName() {
    return "Background color 1";
  }
  get ATTR_AngularGauge_backgroundColor1__CategoryAttribute() {
    return "Dial";
  }
  get ATTR_AngularGauge_backgroundColor1__DescriptionAttribute() {
    return "Dial background gradient color 1.";
  }
  get AngularGauge_backgroundColor1() {
    return this._AngularGauge_backgroundColor1;
  }
  set AngularGauge_backgroundColor1(value) {
    this._AngularGauge_backgroundColor1 = value;
  }
  get ATTR_AngularGauge_backgroundColor2__DisplayName() {
    return "Background color 2";
  }
  get ATTR_AngularGauge_backgroundColor2__CategoryAttribute() {
    return "Dial";
  }
  get ATTR_AngularGauge_backgroundColor2__DescriptionAttribute() {
    return "Dial background gradient color 2.";
  }
  get AngularGauge_backgroundColor2() {
    return this._AngularGauge_backgroundColor2;
  }
  set AngularGauge_backgroundColor2(value) {
    this._AngularGauge_backgroundColor2 = value;
  }
  get ATTR_AngularGauge_zones0__DisplayName() {
    return "Zone 1";
  }
  get ATTR_AngularGauge_zones0__CategoryAttribute() {
    return "Zones";
  }
  get ATTR_AngularGauge_zones0__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_AngularGauge_zones0__DescriptionAttribute() {
    return "Zone 1 parameters";
  }
  get AngularGauge_zones0() {
    return this._AngularGauge_zones0;
  }
  set AngularGauge_zones0(value) {
    this._AngularGauge_zones0 = value;
  }
  get ATTR_AngularGauge_zones1__DisplayName() {
    return "Zone 2";
  }
  get ATTR_AngularGauge_zones1__CategoryAttribute() {
    return "Zones";
  }
  get ATTR_AngularGauge_zones1__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_AngularGauge_zones1__DescriptionAttribute() {
    return "Zone 2 parameters";
  }
  get AngularGauge_zones1() {
    return this._AngularGauge_zones1;
  }
  set AngularGauge_zones1(value) {
    this._AngularGauge_zones1 = value;
  }
  get ATTR_AngularGauge_zones2__DisplayName() {
    return "Zone 2";
  }
  get ATTR_AngularGauge_zones2__CategoryAttribute() {
    return "Zones";
  }
  get ATTR_AngularGauge_zones2__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_AngularGauge_zones2__DescriptionAttribute() {
    return "Zone 2 parameters";
  }
  get AngularGauge_zones2() {
    return this._AngularGauge_zones2;
  }
  set AngularGauge_zones2(value) {
    this._AngularGauge_zones2 = value;
  }
  get ATTR_AngularGauge_annotationPanels0__DisplayName() {
    return "Annotation 1";
  }
  get ATTR_AngularGauge_annotationPanels0__CategoryAttribute() {
    return "Annotations";
  }
  get ATTR_AngularGauge_annotationPanels0__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_AngularGauge_annotationPanels0__DescriptionAttribute() {
    return "Customizable text panels";
  }
  get AngularGauge_annotationPanels0() {
    return this._annotationPanels0;
  }
  set AngularGauge_annotationPanels0(value) {
    this._annotationPanels0 = value;
  }
  get ATTR_AngularGauge_annotationPanels1__DisplayName() {
    return "Annotation 2";
  }
  get ATTR_AngularGauge_annotationPanels1__CategoryAttribute() {
    return "Annotations";
  }
  get ATTR_AngularGauge_annotationPanels1__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_AngularGauge_annotationPanels1__DescriptionAttribute() {
    return "Customizable text panels";
  }
  get AngularGauge_annotationPanels1() {
    return this._annotationPanels1;
  }
  set AngularGauge_annotationPanels1(value) {
    this._annotationPanels1 = value;
  }
};
var ZoneDescription = class {
  constructor(min, max, color) {
    this._visible = false;
    this._min = min;
    this._max = max;
    this._color = color;
  }
  get summary() {
    return this._visible ? this._min.toString() + ".." + this._max.toString() : "Disabled";
  }
  get ATTR_visible__DisplayName() {
    return "Visible";
  }
  get ATTR_visible__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_visible__DescriptionAttribute() {
    return "Zone visibility.";
  }
  get visible() {
    return this._visible;
  }
  set visible(value) {
    this._visible = value;
  }
  get ATTR_min__DisplayName() {
    return "Minimum value";
  }
  get ATTR_min__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_min__DescriptionAttribute() {
    return "Zone minimum value";
  }
  get min() {
    return this._min;
  }
  set min(value) {
    this._min = value;
  }
  get ATTR_max__DisplayName() {
    return "Maximum value";
  }
  get ATTR_max__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_max__DescriptionAttribute() {
    return "Zone maximum value";
  }
  get max() {
    return this._max;
  }
  set max(value) {
    this._max = value;
  }
  get ATTR_color__DisplayName() {
    return "Color";
  }
  get ATTR_color__DescriptionAttribute() {
    return "Zone color";
  }
  get color() {
    return this._color;
  }
  set color(value) {
    this._color = value;
  }
};
var AngularZoneDescription = class {
  constructor(min, max, color) {
    this._width = 5;
    this._outerRadius = 98;
    this._visible = false;
    this._min = min;
    this._max = max;
    this._color = color;
  }
  get summary() {
    return this._visible ? this._min.toString() + ".." + this._max.toString() : "Disabled";
  }
  get ATTR_visible__DisplayName() {
    return "Visible";
  }
  get ATTR_visible__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_visible__DescriptionAttribute() {
    return "Zone visibility.";
  }
  get visible() {
    return this._visible;
  }
  set visible(value) {
    this._visible = value;
  }
  get ATTR_min__DisplayName() {
    return "Minimum value";
  }
  get ATTR_min__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_min__DescriptionAttribute() {
    return "Zone minimum value";
  }
  get min() {
    return this._min;
  }
  set min(value) {
    this._min = value;
  }
  get ATTR_max__DisplayName() {
    return "Maximum value";
  }
  get ATTR_max__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_max__DescriptionAttribute() {
    return "Zone maximum value";
  }
  get max() {
    return this._max;
  }
  set max(value) {
    this._max = value;
  }
  get ATTR_color__DisplayName() {
    return "Color";
  }
  get ATTR_color__DescriptionAttribute() {
    return "Zone color";
  }
  get color() {
    return this._color;
  }
  set color(value) {
    this._color = value;
  }
  get ATTR_outerRadius__DisplayName() {
    return "Outer radius (%)";
  }
  get ATTR_outerRadius__DescriptionAttribute() {
    return "Zone outer radius, in percentage relative to dial radius ";
  }
  get outerRadius() {
    return this._outerRadius;
  }
  set outerRadius(value) {
    this._outerRadius = value;
  }
  get ATTR_width__DisplayName() {
    return "Width (%)";
  }
  get ATTR_width__DescriptionAttribute() {
    return "Zone  width, in percentage relative to dial radius ";
  }
  get width() {
    return this._width;
  }
  set width(value) {
    this._width = value;
  }
};
var FontDescription = class {
  constructor(name, size, color, italic, bold) {
    this._name = name;
    this._size = size;
    this._color = color;
    this._italic = italic;
    this._bold = bold;
  }
  ToString() {
    return this._name + " " + this._size.toString();
  }
  get summary() {
    return this._name + " " + this._size.toString();
  }
  get ATTR_name__DisplayName() {
    return "Font name";
  }
  get ATTR_name__AllowedValues() {
    return fontNameTypeDescription.AllowedValues;
  }
  get ATTR_name__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_name__DescriptionAttribute() {
    return "Name of the font";
  }
  get name() {
    return this._name;
  }
  set name(value) {
    this._name = value;
  }
  get ATTR_size__DisplayName() {
    return "Font size";
  }
  get ATTR_size__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_size__DescriptionAttribute() {
    return "Size of the font";
  }
  get size() {
    return this._size;
  }
  set size(value) {
    this._size = Math.round(100 * value) / 100;
  }
  get ATTR_color__DisplayName() {
    return "Font color";
  }
  get ATTR_color__DescriptionAttribute() {
    return "Color of the font.";
  }
  get color() {
    return this._color;
  }
  set color(value) {
    this._color = value;
  }
  get ATTR_italic__DisplayName() {
    return "Italic";
  }
  get ATTR_italic__DescriptionAttribute() {
    return "Is the font style italic?.";
  }
  get italic() {
    return this._italic;
  }
  set italic(value) {
    this._italic = value;
  }
  get ATTR_bold__DisplayName() {
    return "Bold";
  }
  get ATTR_bold__DescriptionAttribute() {
    return "Is the font style bold?.";
  }
  get bold() {
    return this._bold;
  }
  set bold(value) {
    this._bold = value;
  }
};
var digitalDisplayFormProperties = class extends GenericProperties {
  constructor(initData, owner) {
    super(owner);
    this._DataSource_source = sensorsManager.getNullSensor();
    this._DataSource_precision = "0.1";
    this._DataSource_AlarmSection0 = new AlarmSection(0);
    this._DataSource_AlarmSection1 = new AlarmSection(1);
    this._font = new FontDescription("Arial", 48, YColor.LightGreen, false, true);
    this._display_backgroundColor1 = YColor.Black;
    this._display_backgroundColor2 = YColor.Black;
    this._hrzAlignment = YDigitalDisplay.HrzAlignment.RIGHT;
    this._hrzAlignmentOfset = 5;
    this._outOfRangeMin = new doubleNan(Number.NaN);
    this._outOfRangeMax = new doubleNan(Number.NaN);
    this._outOfRangeColor = YColor.Red;
    this._annotationPanels0 = new AnnotationPanelDescription(GenericPanel.HorizontalAlignPos.CENTER, GenericPanel.VerticalAlignPos.CENTER, 0, false, "$NAME$", YColor.FromArgb(0, 127, 127, 127), YColor.FromArgb(0, 127, 127, 127), 10, YColor.FromArgb(255, 0, 0, 0));
    this._annotationPanels1 = new AnnotationPanelDescription(GenericPanel.HorizontalAlignPos.CENTER, GenericPanel.VerticalAlignPos.BOTTOM, 0, false, "$NAME$", YColor.FromArgb(0, 127, 127, 127), YColor.FromArgb(0, 127, 127, 127), 10, YColor.FromArgb(255, 0, 0, 0));
    this.initFromXmlData(initData);
    this.PropagateDataSourceChange();
  }
  PropagateDataSourceChange() {
    this.ownerForm.SourceChanged(this._DataSource_source, 0);
    let props = GenericProperties.getAllProperties(this).byName;
    let name;
    for (name in props) {
      if (name.startsWith("DataSource_AlarmSection")) {
        this[name].setDataSource(this._DataSource_source);
      }
    }
  }
  IsDataSourceAssigned() {
    return !(this._DataSource_source instanceof NullYSensor);
  }
  get ATTR_DataSource_source__DisplayName() {
    return "Sensor";
  }
  get ATTR_DataSource_source__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_source__ParamCategorySummaryAttribute() {
    return "sensorDescription";
  }
  get ATTR_DataSource_source__PreExpandedCategoryAttribute() {
    return true;
  }
  get ATTR_DataSource_source__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_DataSource_source__DescriptionAttribute() {
    return "Yoctopuce sensor feeding the display. " + GenericHints.CheckSensor;
  }
  get DataSource_source() {
    return this._DataSource_source;
  }
  set DataSource_source(value) {
    let prev = this._DataSource_source;
    this._DataSource_source = value;
    this.PropagateDataSourceChange();
    if (this._DataSource_source != prev)
      constants.edited = true;
  }
  get isSensorReadOnly() {
    return this._DataSource_source.isReadOnly;
  }
  get sensorDescription() {
    return this._DataSource_source instanceof NullYSensor ? "none" : this._DataSource_source.get_friendlyName();
  }
  get ATTR_DataSource_freq__DisplayName() {
    return "Sensor freq";
  }
  get ATTR_DataSource_freq__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_freq__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_DataSource_freq__IsReadonlyCallAttribute() {
    return "isSensorReadOnly";
  }
  get ATTR_DataSource_freq__DescriptionAttribute() {
    return "Sensor data acquisition frequency." + GenericHints.DevConfAffected;
  }
  get ATTR_DataSource_freq__AllowedValues() {
    return sensorFreqTypeDescription.AllowedValues;
  }
  get DataSource_freq() {
    return this._DataSource_source.get_frequency();
  }
  set DataSource_freq(value) {
    this._DataSource_source.set_frequency(value);
  }
  get ATTR_DataSource_precision__DisplayName() {
    return "Precision";
  }
  get ATTR_DataSource_precision__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_precision__DescriptionAttribute() {
    return "How many digits shown after the decimal point.";
  }
  get ATTR_DataSource_precision__AllowedValues() {
    return sensorPrecisionTypeDescription.AllowedValues;
  }
  get DataSource_precision() {
    return this._DataSource_precision;
  }
  set DataSource_precision(value) {
    this._DataSource_precision = value;
  }
  get ATTR_DataSource_AlarmSection0__DisplayName() {
    return "Sensor value alarm 1";
  }
  get ATTR_DataSource_AlarmSection0__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection0__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection0__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_AlarmSection0__DescriptionAttribute() {
    return "Alarm 1 for this data source, expand for more.";
  }
  get DataSource_AlarmSection0() {
    return this._DataSource_AlarmSection0;
  }
  set DataSource_AlarmSection0(value) {
    this._DataSource_AlarmSection0 = value;
  }
  get ATTR_DataSource_AlarmSection1__DisplayName() {
    return "Sensor value alarm 2";
  }
  get ATTR_DataSource_AlarmSection1__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection1__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection1__CategoryAttribute() {
    return "Data source";
  }
  get ATTR_DataSource_AlarmSection1__DescriptionAttribute() {
    return "Alarm 2 for this data source, expand for more.";
  }
  get DataSource_AlarmSection1() {
    return this._DataSource_AlarmSection1;
  }
  set DataSource_AlarmSection1(value) {
    this._DataSource_AlarmSection1 = value;
  }
  get ATTR_display_font__DisplayName() {
    return "Font";
  }
  get ATTR_display_font__CategoryAttribute() {
    return "Display";
  }
  get ATTR_display_font__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_display_font__DescriptionAttribute() {
    return "Display font";
  }
  get display_font() {
    return this._font;
  }
  set display_font(value) {
    this._font = value;
  }
  get ATTR_display_backgroundColor1__DisplayName() {
    return "Background color 1";
  }
  get ATTR_display_backgroundColor1__CategoryAttribute() {
    return "Display";
  }
  get ATTR_display_backgroundColor1__DescriptionAttribute() {
    return "Display background gradient color 1.";
  }
  get display_backgroundColor1() {
    return this._display_backgroundColor1;
  }
  set display_backgroundColor1(value) {
    this._display_backgroundColor1 = value;
  }
  get ATTR_display_backgroundColor2__DisplayName() {
    return "Background color 2";
  }
  get ATTR_display_backgroundColor2__CategoryAttribute() {
    return "Display";
  }
  get ATTR_display_backgroundColor2__DescriptionAttribute() {
    return "Display background gradient color 2.";
  }
  get display_backgroundColor2() {
    return this._display_backgroundColor2;
  }
  set display_backgroundColor2(value) {
    this._display_backgroundColor2 = value;
  }
  get ATTR_display_hrzAlignment__DisplayName() {
    return "Hrz alignment method";
  }
  get ATTR_display_hrzAlignment__CategoryAttribute() {
    return "Display";
  }
  get ATTR_display_hrzAlignment__DescriptionAttribute() {
    return "Horizontal alignment method";
  }
  get display_hrzAlignment() {
    return this._hrzAlignment;
  }
  set display_hrzAlignment(value) {
    this._hrzAlignment = value;
  }
  get ATTR_display_hrzAlignmentOfset__DisplayName() {
    return "Hrz alignment offset";
  }
  get ATTR_display_hrzAlignmentOfset__CategoryAttribute() {
    return "Display";
  }
  get ATTR_display_hrzAlignmentOfset__DescriptionAttribute() {
    return "Horizontal alignment offset in percentage. No effect when chosen horizontal alignment is CENTER";
  }
  get display_hrzAlignmentOfset() {
    return this._hrzAlignmentOfset;
  }
  set display_hrzAlignmentOfset(value) {
    this._hrzAlignmentOfset = value;
  }
  get ATTR_display_outOfRangeMin__DisplayName() {
    return "Minimum value";
  }
  get ATTR_display_outOfRangeMin__CategoryAttribute() {
    return "Range Control";
  }
  get ATTR_display_outOfRangeMin__DescriptionAttribute() {
    return `Regular range minimum value. if value goes  outside regular  range, color will turn to "Out of range Color".Leave blank if you don't want to define such a range. `;
  }
  get display_outOfRangeMin() {
    return this._outOfRangeMin;
  }
  set display_outOfRangeMin(value) {
    this._outOfRangeMin = value;
  }
  get ATTR_display_outOfRangeMax__DisplayName() {
    return "Maximum value";
  }
  get ATTR_display_outOfRangeMax__CategoryAttribute() {
    return "Range Control";
  }
  get ATTR_display_outOfRangeMax__DescriptionAttribute() {
    return `Regular range minimum value. if value goes  outside regular  range, color will turn to "Out of range Color".Leave blank if you don't want to define such a range. `;
  }
  get display_outOfRangeMax() {
    return this._outOfRangeMax;
  }
  set display_outOfRangeMax(value) {
    this._outOfRangeMax = value;
  }
  get ATTR_display_outOfRangeColor__DisplayName() {
    return "Out of range Color";
  }
  get ATTR_display_outOfRangeColor__CategoryAttribute() {
    return "Range Control";
  }
  get ATTR_display_outOfRangeColor__DescriptionAttribute() {
    return "Digits color when value is out of range.";
  }
  get display_outOfRangeColor() {
    return this._outOfRangeColor;
  }
  set display_outOfRangeColor(value) {
    this._outOfRangeColor = value;
  }
  get ATTR_display_annotationPanels0__DisplayName() {
    return "Annotation 1";
  }
  get ATTR_display_annotationPanels0__CategoryAttribute() {
    return "Annotations";
  }
  get ATTR_display_annotationPanels0__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_display_annotationPanels0__DescriptionAttribute() {
    return "Customizable text panels";
  }
  get display_annotationPanels0() {
    return this._annotationPanels0;
  }
  set display_annotationPanels0(value) {
    this._annotationPanels0 = value;
  }
  get ATTR_display_annotationPanels1__DisplayName() {
    return "Annotation 2";
  }
  get ATTR_display_annotationPanels1__CategoryAttribute() {
    return "Annotations";
  }
  get ATTR_display_annotationPanels1__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_display_annotationPanels1__DescriptionAttribute() {
    return "Customizable text panels";
  }
  get display_annotationPanels1() {
    return this._annotationPanels1;
  }
  set display_annotationPanels1(value) {
    this._annotationPanels1 = value;
  }
};
var AlarmSection = class {
  get summary() {
    let c = this._sensor.getAlarmCondition(this._index);
    if (c == 0)
      return "Disabled";
    return "Enabled";
  }
  constructor(index) {
    this._sensor = sensorsManager.getNullSensor();
    this._index = 0;
    this._index = index;
  }
  get ATTR_source__DisplayName() {
    return "Data source type";
  }
  get ATTR_source__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_source__AllowedValues() {
    return sensorDataTypeDescription.AllowedValues;
  }
  get ATTR_source__DescriptionAttribute() {
    return "Alarm sensor data source (Average, minimum or maximum value during last interval)";
  }
  get source() {
    return this._sensor.getAlarmSource(this._index);
  }
  set source(value) {
    this._sensor.setAlarmSource(this._index, value);
  }
  get ATTR_condition__DisplayName() {
    return "Test Condition";
  }
  get ATTR_condition__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_condition__AllowedValues() {
    return AlarmTestTypeDescription.AllowedValues;
  }
  get ATTR_condition__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_condition__DescriptionAttribute() {
    return "Alarm trigger condition";
  }
  get condition() {
    return this._sensor.getAlarmCondition(this._index);
  }
  set condition(value) {
    this._sensor.setAlarmCondition(this._index, value);
  }
  setDataSource(sensor) {
    this._sensor = sensor;
  }
  get ATTR_value__DisplayName() {
    return "Test Value";
  }
  get ATTR_value__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_value__DescriptionAttribute() {
    return "Value for the Alarm trigger";
  }
  get value() {
    return this._sensor.getAlarmValue(this._index);
  }
  set value(value) {
    this._sensor.setAlarmValue(this._index, value);
  }
  get ATTR_commandLine__DisplayName() {
    return "Trigger action";
  }
  get ATTR_commandLine__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_commandLine__DescriptionAttribute() {
    return "Javascript snippet executed in your browser each time the alarm is triggered, you can use the following variables: $SENSORVALUE$, $UNIT$, $HWDID$, $NAME$, $CONDITION$, $TRIGGER$, $DATATYPE$, $NOW$. Example : <tt>alarm('Warning $NAME$ = $SENSORVALUE$!');</tt>. You can check logs to find out if your alarm code works.";
  }
  get commandLine() {
    return this._sensor.getAlarmCommandline(this._index);
  }
  set commandLine(value) {
    this._sensor.setAlarmCommandline(this._index, value);
  }
  get ATTR_delay__DisplayName() {
    return "Trigger delay";
  }
  get ATTR_delay__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_delay__DescriptionAttribute() {
    return "Minimum delay, in seconds, between two alarms. Think carefully and make sure you won't create alarm storms.";
  }
  get delay() {
    return this._sensor.getAlarmDelay(this._index);
  }
  set delay(value) {
    this._sensor.setAlarmDelay(this._index, value);
  }
};
var ChartSerie = class {
  constructor(defaultColor) {
    this.ownerForm = null;
    this.index = -1;
    this.dataloggerAlreadyLoaded = false;
    this._DataSource_source = sensorsManager.getNullSensor();
    this._DataType = 0;
    this._thickness = 2;
    this._legend = "";
    this._color = YColor.Red;
    this._yAxisIndex = 0;
    this._DataSource_AlarmSection0 = new AlarmSection(0);
    this._DataSource_AlarmSection1 = new AlarmSection(1);
    this._color = defaultColor;
  }
  get summary() {
    return this._DataSource_source instanceof NullYSensor ? "none" : this._DataSource_source.get_friendlyName() + (this._DataSource_source.isOnline() ? "" : " - OFFLINE");
  }
  Init(owner, serieIndex) {
    this.ownerForm = owner;
    this.index = serieIndex;
    this.PropagateDataSourceChange(this._DataSource_source);
  }
  PropagateDataSourceChange(value) {
    this.ownerForm.SourceChanged(this._DataSource_source, this.index);
    let props = GenericProperties.getAllProperties(this).byName;
    let name;
    for (name in props) {
      if (name.startsWith("DataSource_AlarmSection")) {
        this[name].setDataSource(this._DataSource_source);
      }
    }
  }
  get ATTR_DataSource_source__DisplayName() {
    return "Sensor";
  }
  get ATTR_DataSource_source__CopyToTarget() {
    return false;
  }
  get ATTR_DataSource_source__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_DataSource_source__DescriptionAttribute() {
    return "Yoctopuce sensor feeding the graph. " + GenericHints.CheckSensor;
  }
  get DataSource_source() {
    return this._DataSource_source;
  }
  set DataSource_source(value) {
    let prev = this._DataSource_source;
    this._DataSource_source = value;
    if (this._DataSource_source != prev)
      constants.edited = true;
    if (this.ownerForm != null)
      this.PropagateDataSourceChange(this._DataSource_source);
  }
  get isSensorReadOnly() {
    return this._DataSource_source.isReadOnly;
  }
  get ATTR_DataSource_freq__DisplayName() {
    return "Sensor frequency";
  }
  get ATTR_DataSource_freq__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_DataSource_freq__CopyToTarget() {
    return false;
  }
  get ATTR_DataSource_freq__IsReadonlyCallAttribute() {
    return "isSensorReadOnly";
  }
  get ATTR_DataSource_freq__DescriptionAttribute() {
    return "Sensor data acquisition frequency." + GenericHints.DevConfAffected;
  }
  get ATTR_DataSource_freq__AllowedValues() {
    return sensorFreqTypeDescription.AllowedValues;
  }
  get DataSource_freq() {
    return this._DataSource_source.get_frequency();
  }
  set DataSource_freq(value) {
    this._DataSource_source.set_frequency(value);
  }
  get ATTR_DataSource_datatype__DisplayName() {
    return "Sensor data";
  }
  get ATTR_DataSource_datatype__AllowedValues() {
    return sensorDataTypeDescription.AllowedValues;
  }
  get ATTR_DataSource_datatype__CopyToTarget() {
    return false;
  }
  get ATTR_DataSource_datatype__DescriptionAttribute() {
    return "Which data for sensor are displayed on the graph. Min and Max are available only for frequencies <1Hz";
  }
  get DataSource_datatype() {
    return this._DataType;
  }
  set DataSource_datatype(value) {
    this._DataType = value;
    if (this.ownerForm != null) {
      this.ownerForm.SourceChanged(this._DataSource_source, this.index);
    }
  }
  get ATTR_DataSource_recording__DisplayName() {
    return "Sensor recording";
  }
  get ATTR_DataSource_recording__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_DataSource_recording__IsReadonlyCallAttribute() {
    return "isSensorReadOnly";
  }
  get ATTR_DataSource_recording__CopyToTarget() {
    return false;
  }
  get ATTR_DataSource_recording__DescriptionAttribute() {
    return "Enable/ disable sensor data recording in the device on-board datalogger." + GenericHints.DevConfAffected;
  }
  get DataSource_recording() {
    return this._DataSource_source.get_recording();
  }
  set DataSource_recording(value) {
    this._DataSource_source.set_recording(value);
  }
  get ATTR_thickness__DisplayName() {
    return "Thickness";
  }
  get ATTR_thickness__DescriptionAttribute() {
    return "Line thickness.";
  }
  get thickness() {
    return this._thickness;
  }
  set thickness(value) {
    this._thickness = value;
  }
  get ATTR_legend__DisplayName() {
    return "Legend";
  }
  get ATTR_legend__DescriptionAttribute() {
    return "Short description of the series.";
  }
  get legend() {
    return this._legend;
  }
  set legend(value) {
    this._legend = value;
  }
  get ATTR_color__DisplayName() {
    return "Color";
  }
  get ATTR_color__DescriptionAttribute() {
    return "Line color.";
  }
  get color() {
    return this._color;
  }
  set color(value) {
    this._color = value;
  }
  get ATTR_yAxisIndex__AllowedValues() {
    return yAxisDescription.AllowedValues;
  }
  get ATTR_yAxisIndex__DisplayName() {
    return "Y axis";
  }
  get ATTR_yAxisIndex__DescriptionAttribute() {
    return "Choose which Y axis the data with be scaled to.";
  }
  get yAxisIndex() {
    return this._yAxisIndex;
  }
  set yAxisIndex(value) {
    this._yAxisIndex = value;
  }
  get ATTR_DataSource_AlarmSection0__DisplayName() {
    return "Sensor value alarm 1";
  }
  get ATTR_DataSource_AlarmSection0__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection0__DescriptionAttribute() {
    return "Alarm 1 for this data source, expand for more.";
  }
  get DataSource_AlarmSection0() {
    return this._DataSource_AlarmSection0;
  }
  set DataSource_AlarmSection0(value) {
    this._DataSource_AlarmSection0 = value;
  }
  get ATTR_DataSource_AlarmSection1__DisplayName() {
    return "Sensor value alarm 2";
  }
  get ATTR_DataSource_AlarmSection1__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_DataSource_AlarmSection1__DescriptionAttribute() {
    return "Alarm 2 for this data source, expand for more.";
  }
  get DataSource_AlarmSection1() {
    return this._DataSource_AlarmSection1;
  }
  set DataSource_AlarmSection1(value) {
    this._DataSource_AlarmSection1 = value;
  }
};
var LegendPanelDescription = class {
  constructor() {
    this._enabled = false;
    this._overlap = false;
    this._position = LegendPanel.Position.RIGHT;
    this._font = new FontDescription("Arial", 7, YColor.FromArgb(255, 32, 32, 32), false, true);
    this._bgColor = YColor.FromArgb(200, 255, 255, 255);
    this._borderColor = YColor.Black;
    this._borderthickness = 1;
    this._padding = 10;
    this._verticalMargin = 10;
    this._horizontalMargin = 10;
    this._traceWidthFactor = 1;
  }
  get summary() {
    return this._enabled ? "Enabled" : "Disabled";
  }
  get ATTR_enabled__DisplayName() {
    return "Enabled";
  }
  get ATTR_enabled__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_enabled__DescriptionAttribute() {
    return "Should the legend panel be shown or not";
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    this._enabled = value;
  }
  get ATTR_overlap__DisplayName() {
    return "Overlap";
  }
  get ATTR_overlap__DescriptionAttribute() {
    return "Can the panel overlap the graph data, or should we explicitly make space for it?";
  }
  get overlap() {
    return this._overlap;
  }
  set overlap(value) {
    this._overlap = value;
  }
  get ATTR_position__DisplayName() {
    return "Position";
  }
  get ATTR_position__DescriptionAttribute() {
    return "Position of the legend panel";
  }
  get position() {
    return this._position;
  }
  set position(value) {
    this._position = value;
  }
  get ATTR_font__DisplayName() {
    return "Font";
  }
  get ATTR_font__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_font__DescriptionAttribute() {
    return "Legend panel contents fonts";
  }
  get font() {
    return this._font;
  }
  set font(value) {
    this._font = value;
  }
  get ATTR_bgColor__DisplayName() {
    return "Background color ";
  }
  get ATTR_bgColor__DescriptionAttribute() {
    return "Legend panel background color.";
  }
  get bgColor() {
    return this._bgColor;
  }
  set bgColor(value) {
    this._bgColor = value;
  }
  get ATTR_borderColor__DisplayName() {
    return "Border color ";
  }
  get ATTR_borderColor__DescriptionAttribute() {
    return "Legend panel border color.";
  }
  get borderColor() {
    return this._borderColor;
  }
  set borderColor(value) {
    this._borderColor = value;
  }
  get ATTR_borderthickness__DisplayName() {
    return "Border thickness ";
  }
  get ATTR_borderthickness__DescriptionAttribute() {
    return "Legend panel border thickness";
  }
  get borderthickness() {
    return this._borderthickness;
  }
  set borderthickness(value) {
    this._borderthickness = value;
  }
  get ATTR_padding__DisplayName() {
    return "Padding ";
  }
  get ATTR_padding__DescriptionAttribute() {
    return "Distance between the panel border and the panel contents";
  }
  get padding() {
    return this._padding;
  }
  set padding(value) {
    this._padding = value;
  }
  get ATTR_verticalMargin__DisplayName() {
    return "Vertical margin ";
  }
  get ATTR_verticalMargin__DescriptionAttribute() {
    return "Vertical distance between the panel border and its surroundings";
  }
  get verticalMargin() {
    return this._verticalMargin;
  }
  set verticalMargin(value) {
    this._verticalMargin = value;
  }
  get ATTR_horizontalMargin__DisplayName() {
    return "Horizontal margin ";
  }
  get ATTR_horizontalMargin__DescriptionAttribute() {
    return "Distance between the panel border and its surroundings";
  }
  get horizontalMargin() {
    return this._horizontalMargin;
  }
  set horizontalMargin(value) {
    this._horizontalMargin = value;
  }
  get ATTR_traceWidthFactor__DisplayName() {
    return "Color Indicator Factor";
  }
  get ATTR_traceWidthFactor__DescriptionAttribute() {
    return "Factor used to enlarge series color indicators shown in the legend panel";
  }
  get traceWidthFactor() {
    return this._traceWidthFactor;
  }
  set traceWidthFactor(value) {
    this._traceWidthFactor = value;
  }
};
var AnnotationPanelDescription = class {
  get summary() {
    return this._enabled ? "Enabled" : "Disabled";
  }
  get ATTR_enabled__DisplayName() {
    return "Enabled";
  }
  get ATTR_enabled__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_enabled__DescriptionAttribute() {
    return "Should the annotation panel be shown or not";
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    this._enabled = value;
  }
  get ATTR_overlap__DisplayName() {
    return "Overlap";
  }
  get ATTR_overlap__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_overlap__DescriptionAttribute() {
    return "Can the annotation panel overlap the display zone, or should the display zone be squeezed to make space for the panel?";
  }
  get overlap() {
    return this._overlap;
  }
  set overlap(value) {
    this._overlap = value;
  }
  get ATTR_text__DisplayName() {
    return "Text ";
  }
  get ATTR_text__DescriptionAttribute() {
    return GenericHints.Annotation;
  }
  get text() {
    return this._text;
  }
  set text(value) {
    this._text = value;
  }
  get ATTR_panelTextAlign__DisplayName() {
    return "Text Alignment";
  }
  get ATTR_panelTextAlign__DescriptionAttribute() {
    return "How text is aligned, makes sense on multi-lines text only.";
  }
  get panelTextAlign() {
    return this._panelTextAlign;
  }
  set panelTextAlign(value) {
    this._panelTextAlign = value;
  }
  get ATTR_panelHrzAlign__DisplayName() {
    return "X Position";
  }
  get ATTR_panelHrzAlign__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_panelHrzAlign__DescriptionAttribute() {
    return "Annotation panel X position";
  }
  get panelHrzAlign() {
    return this._panelHrzAlign;
  }
  set panelHrzAlign(value) {
    this._panelHrzAlign = value;
  }
  get ATTR_positionOffsetX__DisplayName() {
    return "X Offset";
  }
  get ATTR_positionOffsetX__DescriptionAttribute() {
    return "X Position offset, in %  (overlap mode only)";
  }
  get positionOffsetX() {
    return this._positionOffsetX;
  }
  set positionOffsetX(value) {
    this._positionOffsetX = value;
  }
  get ATTR_panelVrtAlign__DisplayName() {
    return "Y Position";
  }
  get ATTR_panelVrtAlign__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_panelVrtAlign__DescriptionAttribute() {
    return "Annotation panel Y position";
  }
  get panelVrtAlign() {
    return this._panelVrtAlign;
  }
  set panelVrtAlign(value) {
    this._panelVrtAlign = value;
  }
  get ATTR_positionOffsetY__DisplayName() {
    return "Y Offset";
  }
  get ATTR_positionOffsetY__DescriptionAttribute() {
    return "Y Position offset, in %  (overlap mode only)";
  }
  get positionOffsetY() {
    return this._positionOffsetY;
  }
  set positionOffsetY(value) {
    this._positionOffsetY = value;
  }
  get ATTR_font__DisplayName() {
    return "Font";
  }
  get ATTR_font__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_font__DescriptionAttribute() {
    return "Panel font";
  }
  get font() {
    return this._font;
  }
  set font(value) {
    this._font = value;
  }
  get ATTR_bgColor__DisplayName() {
    return "Background color ";
  }
  get ATTR_bgColor__DescriptionAttribute() {
    return "Legend panel background color.";
  }
  get bgColor() {
    return this._bgColor;
  }
  set bgColor(value) {
    this._bgColor = value;
  }
  get ATTR_borderColor__DisplayName() {
    return "Border color ";
  }
  get ATTR_borderColor__DescriptionAttribute() {
    return "Legend panel border color.";
  }
  get borderColor() {
    return this._borderColor;
  }
  set borderColor(value) {
    this._borderColor = value;
  }
  get ATTR_borderthickness__DisplayName() {
    return "Border thickness ";
  }
  get ATTR_borderthickness__DescriptionAttribute() {
    return "Panel border thickness";
  }
  get borderthickness() {
    return this._borderthickness;
  }
  set borderthickness(value) {
    this._borderthickness = value;
  }
  get ATTR_padding__DisplayName() {
    return "Padding ";
  }
  get ATTR_padding__DescriptionAttribute() {
    return "Distance between the panel border and the panel contents";
  }
  get padding() {
    return this._padding;
  }
  set padding(value) {
    this._padding = value;
  }
  constructor(hrzAlignInit, vrtAlignInit, offsetY, overlap, textInit, BgColorInit, BorderColorInit, fontSizeInit, FontColorInit) {
    this._enabled = false;
    this._overlap = false;
    this._text = "Date: $DAY$/$MONTH$/$YEAR$";
    this._panelTextAlign = GenericPanel.TextAlign.CENTER;
    this._panelHrzAlign = GenericPanel.HorizontalAlignPos.CENTER;
    this._positionOffsetX = 0;
    this._panelVrtAlign = GenericPanel.VerticalAlignPos.TOP;
    this._positionOffsetY = 0;
    this._font = new FontDescription("Arial", 12, YColor.FromArgb(255, 32, 32, 32), false, false);
    this._bgColor = YColor.FromArgb(200, 255, 255, 255);
    this._borderColor = YColor.Black;
    this._borderthickness = 1;
    this._padding = 5;
    if (typeof textInit != "undefined")
      this._text = textInit;
    if (typeof offsetY != "undefined")
      this._positionOffsetY = offsetY;
    if (typeof overlap != "undefined")
      this._overlap = overlap;
    if (typeof BgColorInit != "undefined")
      this._bgColor = BgColorInit;
    if (typeof BorderColorInit != "undefined")
      this._borderColor = BorderColorInit;
    if (typeof fontSizeInit != "undefined")
      this._font.size = fontSizeInit;
    if (typeof FontColorInit != "undefined")
      this._font.color = FontColorInit;
    if (typeof vrtAlignInit != "undefined")
      this._panelVrtAlign = vrtAlignInit;
    if (typeof hrzAlignInit != "undefined")
      this._panelHrzAlign = hrzAlignInit;
  }
};
var AnnotationPanelDescriptionGraph = class extends AnnotationPanelDescription {
  get ATTR_enabled__DisplayName() {
    return "Enabled";
  }
  get ATTR_enabled__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_enabled__DescriptionAttribute() {
    return "Should the annotation panel be shown or not";
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    this._enabled = value;
  }
  get ATTR_overlap__DisplayName() {
    return "Overlap";
  }
  get ATTR_overlap__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_overlap__DescriptionAttribute() {
    return "Can the annotation panel overlap the graph, or should the graph be squeezed to make space for the panel?";
  }
  get overlap() {
    return this._overlap;
  }
  set overlap(value) {
    this._overlap = value;
  }
  get ATTR_text__DisplayName() {
    return "Text ";
  }
  get ATTR_text__DescriptionAttribute() {
    return GenericHints.AnnotationGraph;
  }
  get text() {
    return this._text;
  }
  set text(value) {
    this._text = value;
  }
};
var DataTrackerDescription = class {
  constructor() {
    this._enabled = false;
    this._showSerieName = false;
    this._showTimeStamp = false;
    this._dataPrecision = DataTrackerDescription.DataPrecision.PRECISION_NOLIMIT;
    this._diameter = 5;
    this._handleLength = 25;
    this._font = new FontDescription("Arial", 7, YColor.FromArgb(255, 32, 32, 32), false, false);
    this._bgColor = YColor.FromArgb(200, 255, 255, 255);
    this._borderColor = YColor.Black;
    this._borderthickness = 1;
    this._padding = 5;
    this._detectionDistance = 50;
  }
  get summary() {
    return this._enabled ? "Enabled" : "Disabled";
  }
  get ATTR_enabled__DisplayName() {
    return "Enabled";
  }
  get ATTR_enabled__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_enabled__DescriptionAttribute() {
    return "Should the data tracker be shown or not.";
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    this._enabled = value;
  }
  get ATTR_showSerieName__DisplayName() {
    return "Show Series legend";
  }
  get ATTR_showSerieName__DescriptionAttribute() {
    return "Should the data tracker show the value's series legend.";
  }
  get showSerieName() {
    return this._showSerieName;
  }
  set showSerieName(value) {
    this._showSerieName = value;
  }
  get ATTR_showTimeStamp__DisplayName() {
    return "Show Timestamp";
  }
  get ATTR_showTimeStamp__DescriptionAttribute() {
    return "Should the data tracker show the value's timestamp.";
  }
  get showTimeStamp() {
    return this._showTimeStamp;
  }
  set showTimeStamp(value) {
    this._showTimeStamp = value;
  }
  get ATTR_dataPrecision__DisplayName() {
    return "Precision";
  }
  get ATTR_dataPrecision__DescriptionAttribute() {
    return "A way to limit data precision to meaningful digits in the data tracker.";
  }
  get dataPrecision() {
    return this._dataPrecision;
  }
  set dataPrecision(value) {
    this._dataPrecision = value;
  }
  get ATTR_diameter__DisplayName() {
    return "Point Diameter";
  }
  get ATTR_diameter__DescriptionAttribute() {
    return "Data point diameter, in pixels";
  }
  get diameter() {
    return this._diameter;
  }
  set diameter(value) {
    this._diameter = value;
  }
  get ATTR_handleLength__DisplayName() {
    return "Handle size";
  }
  get ATTR_handleLength__DescriptionAttribute() {
    return "size of the handle between the data point and the value panel";
  }
  get handleLength() {
    return this._handleLength;
  }
  set handleLength(value) {
    this._handleLength = value;
  }
  get ATTR_font__DisplayName() {
    return "Font";
  }
  get ATTR_font__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_font__DescriptionAttribute() {
    return "Data tracker label fonts";
  }
  get font() {
    return this._font;
  }
  set font(value) {
    this._font = value;
  }
  get ATTR_bgColor__DisplayName() {
    return "Background color";
  }
  get ATTR_bgColor__DescriptionAttribute() {
    return "Value panel ground color.";
  }
  get bgColor() {
    return this._bgColor;
  }
  set bgColor(value) {
    this._bgColor = value;
  }
  get ATTR_borderColor__DisplayName() {
    return "Border color";
  }
  get ATTR_borderColor__DescriptionAttribute() {
    return "Value panel border and handle  color.";
  }
  get borderColor() {
    return this._borderColor;
  }
  set borderColor(value) {
    this._borderColor = value;
  }
  get ATTR_borderthickness__DisplayName() {
    return "Border thickness ";
  }
  get ATTR_borderthickness__DescriptionAttribute() {
    return "Value panel border and handle  thickness";
  }
  get borderthickness() {
    return this._borderthickness;
  }
  set borderthickness(value) {
    this._borderthickness = value;
  }
  get ATTR_padding__DisplayName() {
    return "Padding";
  }
  get ATTR_padding__DescriptionAttribute() {
    return "Distance between the panel border and its contents ";
  }
  get padding() {
    return this._padding;
  }
  set padding(value) {
    this._padding = value;
  }
  get ATTR_detectionDistance__DisplayName() {
    return "Detection distance";
  }
  get ATTR_detectionDistance__DescriptionAttribute() {
    return "Maximum distance, in pixels, between the mouse and a data point for data tracker to show. Use zero for infinite distance";
  }
  get detectionDistance() {
    return this._detectionDistance;
  }
  set detectionDistance(value) {
    this._detectionDistance = value;
  }
};
(function(DataTrackerDescription2) {
  class DataPrecisionEnumItem extends YEnumItem {
    constructor(value, humanreadable, container) {
      super(value, humanreadable, DataPrecision);
    }
  }
  DataTrackerDescription2.DataPrecisionEnumItem = DataPrecisionEnumItem;
  class DataPrecision extends YEnum {
  }
  DataPrecision.PRECISION_NOLIMIT = new DataPrecisionEnumItem("PRECISION_NOLIMIT", "As is");
  DataPrecision.PRECISION_1 = new DataPrecisionEnumItem("PRECISION_1", "1");
  DataPrecision.PRECISION_01 = new DataPrecisionEnumItem("PRECISION_01", "0.1");
  DataPrecision.PRECISION_001 = new DataPrecisionEnumItem("PRECISION_001", "0.01");
  DataPrecision.PRECISION_0001 = new DataPrecisionEnumItem("PRECISION_0001", "0.001");
  DataTrackerDescription2.DataPrecision = DataPrecision;
})(DataTrackerDescription || (DataTrackerDescription = {}));
var NavigatorDescription = class {
  get summary() {
    return this._enabled ? "Enabled" : "Disabled";
  }
  constructor() {
    this._enabled = false;
    this._bgColor1 = YColor.FromArgb(255, 225, 225, 225);
    this._bgColor2 = YColor.FromArgb(255, 225, 225, 225);
    this._borderThickness = 1;
    this._borderColor = YColor.Black;
    this._cursorColor = YColor.FromArgb(25, 0, 255, 0);
    this._cursorBorderColor = YColor.FromArgb(255, 96, 96, 96);
    this._yAxisHandling = Navigator.YAxisHandling.AUTO;
    this._xAxisThickness = 1;
    this._xAxisColor = YColor.Black;
    this._font = new FontDescription("Arial", 10, YColor.FromArgb(255, 32, 32, 32), false, false);
  }
  get ATTR_enabled__DisplayName() {
    return "Enabled";
  }
  get ATTR_enabled__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_enabled__DescriptionAttribute() {
    return "Should the navigator be shown or not.";
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    this._enabled = value;
  }
  get ATTR_bgColor1__DisplayName() {
    return "Background color 1";
  }
  get ATTR_bgColor1__DescriptionAttribute() {
    return "Navigator background gradient color 1.";
  }
  get bgColor1() {
    return this._bgColor1;
  }
  set bgColor1(value) {
    this._bgColor1 = value;
  }
  get ATTR_bgColor2__DisplayName() {
    return "Background color 2";
  }
  get ATTR_bgColor2__DescriptionAttribute() {
    return "Navigator background gradient color 2.";
  }
  get bgColor2() {
    return this._bgColor2;
  }
  set bgColor2(value) {
    this._bgColor2 = value;
  }
  get ATTR_borderThickness__DisplayName() {
    return "Border thickness";
  }
  get ATTR_borderThickness__DescriptionAttribute() {
    return "Navigator";
  }
  get borderThickness() {
    return this._borderThickness;
  }
  set borderThickness(value) {
    this._borderThickness = value;
  }
  get ATTR_borderColor__DisplayName() {
    return "Border color";
  }
  get ATTR_borderColor__DescriptionAttribute() {
    return "Navigator Border color.";
  }
  get borderColor() {
    return this._borderColor;
  }
  set borderColor(value) {
    this._borderColor = value;
  }
  get ATTR_cursorColor__DisplayName() {
    return "Navigator cursor fill color";
  }
  get ATTR_cursorColor__DescriptionAttribute() {
    return "Navigator";
  }
  get cursorColor() {
    return this._cursorColor;
  }
  set cursorColor(value) {
    this._cursorColor = value;
  }
  get ATTR_cursorBorderColor__DisplayName() {
    return "Navigator cursor left/right border color.";
  }
  get ATTR_cursorBorderColor__DescriptionAttribute() {
    return "Navigator";
  }
  get cursorBorderColor() {
    return this._cursorBorderColor;
  }
  set cursorBorderColor(value) {
    this._cursorBorderColor = value;
  }
  get ATTR_yAxisHandling__DisplayName() {
    return "Y axis range";
  }
  get ATTR_yAxisHandling__DescriptionAttribute() {
    return "Is navigator Y axis zoom automatic or inherited from main view settings?";
  }
  get yAxisHandling() {
    return this._yAxisHandling;
  }
  set yAxisHandling(value) {
    this._yAxisHandling = value;
  }
  get ATTR_xAxisThickness__DisplayName() {
    return "X axis thickness";
  }
  get ATTR_xAxisThickness__DescriptionAttribute() {
    return "Navigator";
  }
  get xAxisThickness() {
    return this._xAxisThickness;
  }
  set xAxisThickness(value) {
    this._xAxisThickness = value;
  }
  get ATTR_xAxisColor__DisplayName() {
    return "X axis color";
  }
  get ATTR_xAxisColor__DescriptionAttribute() {
    return "Navigator X axis color.";
  }
  get xAxisColor() {
    return this._xAxisColor;
  }
  set xAxisColor(value) {
    this._xAxisColor = value;
  }
  get ATTR_font__DisplayName() {
    return "X-Axis Font";
  }
  get ATTR_font__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_font__DescriptionAttribute() {
    return "Navigator X axis font";
  }
  get font() {
    return this._font;
  }
  set font(value) {
    this._font = value;
  }
};
var LegendDescription = class {
  constructor() {
    this._title = "";
    this._font = new FontDescription("Arial", 12, YColor.Black, false, true);
  }
  get ATTR_title__DisplayName() {
    return "Text";
  }
  get ATTR_title__DescriptionAttribute() {
    return "Legend text";
  }
  get title() {
    return this._title;
  }
  set title(value) {
    this._title = value;
  }
  get ATTR_font__DisplayName() {
    return "Font";
  }
  get ATTR_font__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_font__DescriptionAttribute() {
    return "Legend font";
  }
  get font() {
    return this._font;
  }
  set font(value) {
    this._font = value;
  }
};
var YaxisDescription = class {
  constructor(index, shown) {
    this._visible = false;
    this._position = YAxis.HrzPosition.LEFT;
    this._min = new doubleNan(Number.NaN);
    this._max = new doubleNan(Number.NaN);
    this._step = new doubleNan(Number.NaN);
    this._color = YColor.FromArgb(255, 127, 127, 127);
    this._thickness = 1;
    this._showGrid = false;
    this._gridColor = YColor.FromArgb(255, 210, 210, 210);
    this._gridThickness = 1;
    this._font = new FontDescription("Arial", 10, YColor.Black, false, false);
    this._legend = new LegendDescription();
    this._zones0 = new ZoneDescription(0, 50, YColor.LightGreen);
    this._zones1 = new ZoneDescription(50, 80, YColor.Yellow);
    this._zones2 = new ZoneDescription(80, 100, YColor.Red);
    this._visible = shown;
    this._showGrid = index == 0;
    this._position = index == 0 ? YAxis.HrzPosition.LEFT : YAxis.HrzPosition.RIGHT;
  }
  get summary() {
    return this._visible ? "Enabled" : "Disabled";
  }
  get ATTR_visible__DisplayName() {
    return "Visible";
  }
  get ATTR_visible__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_visible__DescriptionAttribute() {
    return "Should that YAxis be shown?.";
  }
  get visible() {
    return this._visible;
  }
  set visible(value) {
    this._visible = value;
  }
  get ATTR_position__DisplayName() {
    return "Position";
  }
  get ATTR_position__DescriptionAttribute() {
    return "Y Axis position (left / right)";
  }
  get position() {
    return this._position;
  }
  set position(value) {
    this._position = value;
  }
  get ATTR_min__DisplayName() {
    return "Minimum value";
  }
  get ATTR_min__DescriptionAttribute() {
    return "YAxis minimum value, leave blank for automatic behavior.";
  }
  get min() {
    return this._min;
  }
  set min(value) {
    this._min = value;
  }
  get ATTR_max__DisplayName() {
    return "Maximum value";
  }
  get ATTR_max__DescriptionAttribute() {
    return "YAxis maximum value, leave blank for automatic behavior.";
  }
  get max() {
    return this._max;
  }
  set max(value) {
    this._max = value;
  }
  get ATTR_step__DisplayName() {
    return "Steps";
  }
  get ATTR_step__DescriptionAttribute() {
    return "YAxis step size, leave blank for automatic behavior.";
  }
  get step() {
    return this._step;
  }
  set step(value) {
    this._step = value;
  }
  get ATTR_color__DisplayName() {
    return "Color";
  }
  get ATTR_color__DescriptionAttribute() {
    return "Y Axis Color.";
  }
  get color() {
    return this._color;
  }
  set color(value) {
    this._color = value;
  }
  get ATTR_thickness__DisplayName() {
    return "Thickness";
  }
  get ATTR_thickness__DescriptionAttribute() {
    return "Axis thickness";
  }
  get thickness() {
    return this._thickness;
  }
  set thickness(value) {
    this._thickness = value;
  }
  get ATTR_showGrid__DisplayName() {
    return "Show Grid";
  }
  get ATTR_showGrid__DescriptionAttribute() {
    return "Show grid horizontal lines, or not.";
  }
  get showGrid() {
    return this._showGrid;
  }
  set showGrid(value) {
    this._showGrid = value;
  }
  get ATTR_gridColor__DisplayName() {
    return "Grid Color";
  }
  get ATTR_gridColor__DescriptionAttribute() {
    return "Grid horizontal lines color.";
  }
  get gridColor() {
    return this._gridColor;
  }
  set gridColor(value) {
    this._gridColor = value;
  }
  get ATTR_gridThickness__DisplayName() {
    return "Grid thickness";
  }
  get ATTR_gridThickness__DescriptionAttribute() {
    return "Grid horizontal lines thickness";
  }
  get gridThickness() {
    return this._gridThickness;
  }
  set gridThickness(value) {
    this._gridThickness = value;
  }
  get ATTR_font__DisplayName() {
    return "Font";
  }
  get ATTR_font__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_font__DescriptionAttribute() {
    return "Axis font";
  }
  get font() {
    return this._font;
  }
  set font(value) {
    this._font = value;
  }
  get ATTR_legend__DisplayName() {
    return "Legend";
  }
  get ATTR_legend__DescriptionAttribute() {
    return "Axis legend";
  }
  get legend() {
    return this._legend;
  }
  set legend(value) {
    this._legend = value;
  }
  get ATTR_zones0__DisplayName() {
    return "Zone 1";
  }
  get ATTR_zones0__CategoryAttribute() {
    return "Zones";
  }
  get ATTR_zones0__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_zones0__DescriptionAttribute() {
    return "Zone 1 parameters";
  }
  get zones0() {
    return this._zones0;
  }
  set zones0(value) {
    this._zones0 = value;
  }
  get ATTR_zones1__DisplayName() {
    return "Zone 2";
  }
  get ATTR_zones1__CategoryAttribute() {
    return "Zones";
  }
  get ATTR_zones1__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_zones1__DescriptionAttribute() {
    return "Zone 2 parameters";
  }
  get zones1() {
    return this._zones1;
  }
  set zones1(value) {
    this._zones1 = value;
  }
  get ATTR_zones2__DisplayName() {
    return "Zone 3";
  }
  get ATTR_zones2__CategoryAttribute() {
    return "Zones";
  }
  get ATTR_zones2__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_zones2__DescriptionAttribute() {
    return "Zone 3 parameters";
  }
  get zones2() {
    return this._zones2;
  }
  set zones2(value) {
    this._zones2 = value;
  }
};
var MarkerDescription = class {
  constructor(defaultText) {
    this._enabled = false;
    this._text = "";
    this._textAlign = Marker.TextAlign.CENTER;
    this._timereference = TimeConverter.TimeReference.ABSOLUTE;
    this._positionOnXAxis = new xAxisPosition(TimeConverter.ToUnixTime(new Date()), false);
    this._yposition = 95;
    this._bgColor = YColor.FromArgb(200, 255, 255, 192);
    this._borderColor = YColor.DarkRed;
    this._borderthickness = 1;
    this._padding = 5;
    this._font = new FontDescription("Arial", 7, YColor.Black, false, false);
    this._text = defaultText;
  }
  get summary() {
    return this._enabled ? "Enabled" : "Disabled";
  }
  get ATTR_enabled__DisplayName() {
    return "Enabled";
  }
  get ATTR_enabled__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_enabled__DescriptionAttribute() {
    return "Should that marker be shown?.";
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    this._enabled = value;
  }
  get ATTR_text__DisplayName() {
    return "Text";
  }
  get ATTR_text__DescriptionAttribute() {
    return "Marker text. Use \\n for multi-line text. Some variables are allowed such as $MARKERTIME$, $LEGEND1$, $VALUE1$, $UNIT1$, $LEGEND1$, $VALUE2$ etc.. Extensive use of marker variables migh make the graph rendering significantly slower.";
  }
  get text() {
    return this._text;
  }
  set text(value) {
    this._text = value;
  }
  get ATTR_textAlign__DisplayName() {
    return "Text Alignment";
  }
  get ATTR_textAlign__DescriptionAttribute() {
    return "How text is aligned, makes sense on multi-lines text only.";
  }
  get textAlign() {
    return this._textAlign;
  }
  set textAlign(value) {
    this._textAlign = value;
  }
  get ATTR_timereference__DisplayName() {
    return "Time reference";
  }
  get ATTR_timereference__ChangeCausesParentRefreshAttribute() {
    return true;
  }
  get ATTR_timereference__NotSavedInXMLAttribute() {
    return true;
  }
  get ATTR_timereference__DescriptionAttribute() {
    return "Should the marker time position be absolute or relative to first data timestamp? Note: relative markers won't be drawn until there is actual data.";
  }
  get timereference() {
    return this._timereference;
  }
  set timereference(value) {
    this._timereference = value;
    this._positionOnXAxis.relative = value == TimeConverter.TimeReference.RELATIVE;
  }
  get ATTR_positionOnXAxis__DisplayName() {
    return "Time position";
  }
  get ATTR_positionOnXAxis__DescriptionAttribute() {
    return "Marker position on X axis.";
  }
  get positionOnXAxis() {
    return this._positionOnXAxis;
  }
  set positionOnXAxis(value) {
    this._positionOnXAxis = value;
    this.timereference = value.relative ? TimeConverter.TimeReference.RELATIVE : TimeConverter.TimeReference.ABSOLUTE;
  }
  get ATTR_yposition__DisplayName() {
    return "Vrt position (%)";
  }
  get ATTR_yposition__DescriptionAttribute() {
    return "Vertical position of the marker label in % of available space. Zero is bottom";
  }
  get yposition() {
    return this._yposition;
  }
  set yposition(value) {
    this._yposition = value;
  }
  get ATTR_bgColor__DisplayName() {
    return "Background color ";
  }
  get ATTR_bgColor__DescriptionAttribute() {
    return "Marker  background color.";
  }
  get bgColor() {
    return this._bgColor;
  }
  set bgColor(value) {
    this._bgColor = value;
  }
  get ATTR_borderColor__DisplayName() {
    return "Border color ";
  }
  get ATTR_borderColor__DescriptionAttribute() {
    return "Marker border color.";
  }
  get borderColor() {
    return this._borderColor;
  }
  set borderColor(value) {
    this._borderColor = value;
  }
  get ATTR_borderthickness__DisplayName() {
    return "Border thickness ";
  }
  get ATTR_borderthickness__DescriptionAttribute() {
    return "Marker border thickness, in pixels.";
  }
  get borderthickness() {
    return this._borderthickness;
  }
  set borderthickness(value) {
    this._borderthickness = value;
  }
  get ATTR_padding__DisplayName() {
    return "Padding ";
  }
  get ATTR_padding__DescriptionAttribute() {
    return "Distance between the marker border and the marker contents, in pixels.";
  }
  get padding() {
    return this._padding;
  }
  set padding(value) {
    this._padding = value;
  }
  get ATTR_font__DisplayName() {
    return "Font";
  }
  get ATTR_font__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_font__DescriptionAttribute() {
    return "Marker Font";
  }
  get font() {
    return this._font;
  }
  set font(value) {
    this._font = value;
  }
};
var XaxisDescription = class {
  constructor() {
    this._initialZoom = 60;
    this._initialOffset = 0;
    this._position = XAxis.VrtPosition.BOTTOM;
    this._timeReference = TimeConverter.TimeReference.ABSOLUTE;
    this._overflowHandling = XAxis.OverflowHandling.SCROLL;
    this._color = YColor.FromArgb(255, 127, 127, 127);
    this._thickness = 1;
    this._showGrid = false;
    this._gridColor = YColor.FromArgb(50, 0, 0, 0);
    this._gridThickness = 1;
    this._font = new FontDescription("Arial", 10, YColor.Black, false, false);
    this._legend = new LegendDescription();
    this._markers0 = new MarkerDescription("Marker 1");
    this._markers1 = new MarkerDescription("Marker 2");
    this._markers2 = new MarkerDescription("Marker 3");
    this._markers3 = new MarkerDescription("Marker 4");
    this._markers4 = new MarkerDescription("Marker 5");
    this._markers5 = new MarkerDescription("Marker 6");
    this._markers6 = new MarkerDescription("Marker 7");
    this._markers7 = new MarkerDescription("Marker 8");
  }
  get ATTR_initialZoom__DisplayName() {
    return "Initial Zoom";
  }
  get ATTR_initialZoom__DescriptionAttribute() {
    return "Zoom level at application startup, i.e. width of the view-port in seconds.";
  }
  get initialZoom() {
    return this._initialZoom;
  }
  set initialZoom(value) {
    this._initialZoom = value;
  }
  get ATTR_initialOffset__DisplayName() {
    return "Initial Offset";
  }
  get ATTR_initialOffset__DescriptionAttribute() {
    return "Offset of the first data point in percentage of the viewport width. For instance a 50% value will put the first point in the middle of the viewport. This can be used to give some room for datalogger contents.";
  }
  get initialOffset() {
    return this._initialOffset;
  }
  set initialOffset(value) {
    this._initialOffset = value;
  }
  get ATTR_position__DisplayName() {
    return "Position";
  }
  get ATTR_position__DescriptionAttribute() {
    return "X Axis position (top / bottom)";
  }
  get position() {
    return this._position;
  }
  set position(value) {
    this._position = value;
  }
  get ATTR_timeReference__DisplayName() {
    return "Time reference";
  }
  get ATTR_timeReference__DescriptionAttribute() {
    return "Are gradation timestamps absolute or relative to experiment start time? ";
  }
  get timeReference() {
    return this._timeReference;
  }
  set timeReference(value) {
    this._timeReference = value;
  }
  get ATTR_overflowHandling__DisplayName() {
    return "Overflow Handling";
  }
  get ATTR_overflowHandling__DescriptionAttribute() {
    return "What to do when new data are about to reach the graph right border";
  }
  get overflowHandling() {
    return this._overflowHandling;
  }
  set overflowHandling(value) {
    this._overflowHandling = value;
  }
  get ATTR_color__DisplayName() {
    return "Color";
  }
  get ATTR_color__DescriptionAttribute() {
    return "X Axis Color.";
  }
  get color() {
    return this._color;
  }
  set color(value) {
    this._color = value;
  }
  get ATTR_thickness__DisplayName() {
    return "Thickness";
  }
  get ATTR_thickness__DescriptionAttribute() {
    return "Axis thickness";
  }
  get thickness() {
    return this._thickness;
  }
  set thickness(value) {
    this._thickness = value;
  }
  get ATTR_showGrid__DisplayName() {
    return "Show Grid";
  }
  get ATTR_showGrid__DescriptionAttribute() {
    return "Show grid vertical lines, or not.";
  }
  get showGrid() {
    return this._showGrid;
  }
  set showGrid(value) {
    this._showGrid = value;
  }
  get ATTR_gridColor__DisplayName() {
    return "Grid Color";
  }
  get ATTR_gridColor__DescriptionAttribute() {
    return "Grid vertical lines color.";
  }
  get gridColor() {
    return this._gridColor;
  }
  set gridColor(value) {
    this._gridColor = value;
  }
  get ATTR_gridThickness__DisplayName() {
    return "Grid thickness";
  }
  get ATTR_gridThickness__DescriptionAttribute() {
    return "Grid vertical lines thickness";
  }
  get gridThickness() {
    return this._gridThickness;
  }
  set gridThickness(value) {
    this._gridThickness = value;
  }
  get ATTR_font__DisplayName() {
    return "Font";
  }
  get ATTR_font__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_font__DescriptionAttribute() {
    return "Axis font";
  }
  get font() {
    return this._font;
  }
  set font(value) {
    this._font = value;
  }
  get ATTR_legend__DisplayName() {
    return "Legend";
  }
  get ATTR_legend__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_legend__DescriptionAttribute() {
    return "X Axis legend";
  }
  get legend() {
    return this._legend;
  }
  set legend(value) {
    this._legend = value;
  }
  get ATTR_markers0__DisplayName() {
    return "Marker 1";
  }
  get ATTR_markers0__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_markers0__CategoryAttribute() {
    return "Markers";
  }
  get ATTR_markers0__DescriptionAttribute() {
    return "First marker parameters";
  }
  get markers0() {
    return this._markers0;
  }
  set markers0(value) {
    this._markers0 = value;
  }
  get ATTR_markers1__DisplayName() {
    return "Marker 2";
  }
  get ATTR_markers1__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_markers1__CategoryAttribute() {
    return "Markers";
  }
  get ATTR_markers1__DescriptionAttribute() {
    return "Second marker parameters";
  }
  get markers1() {
    return this._markers1;
  }
  set markers1(value) {
    this._markers1 = value;
  }
  get ATTR_markers2__DisplayName() {
    return "Marker 3";
  }
  get ATTR_markers2__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_markers2__CategoryAttribute() {
    return "Markers";
  }
  get ATTR_markers2__DescriptionAttribute() {
    return "Third marker parameters";
  }
  get markers2() {
    return this._markers2;
  }
  set markers2(value) {
    this._markers2 = value;
  }
  get ATTR_markers3__DisplayName() {
    return "Marker 4";
  }
  get ATTR_markers3__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_markers3__CategoryAttribute() {
    return "Markers";
  }
  get ATTR_markers3__DescriptionAttribute() {
    return "Fourth marker parameters";
  }
  get markers3() {
    return this._markers3;
  }
  set markers3(value) {
    this._markers3 = value;
  }
  get ATTR_markers4__DisplayName() {
    return "Marker 5";
  }
  get ATTR_markers4__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_markers4__CategoryAttribute() {
    return "Markers";
  }
  get ATTR_markers4__DescriptionAttribute() {
    return "Fith marker parameters";
  }
  get markers4() {
    return this._markers4;
  }
  set markers4(value) {
    this._markers4 = value;
  }
  get ATTR_markers5__DisplayName() {
    return "Marker 6";
  }
  get ATTR_markers5__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_markers5__CategoryAttribute() {
    return "Markers";
  }
  get ATTR_markers5__DescriptionAttribute() {
    return "Sixth marker parameters";
  }
  get markers5() {
    return this._markers5;
  }
  set markers5(value) {
    this._markers5 = value;
  }
  get ATTR_markers6__DisplayName() {
    return "Marker 7";
  }
  get ATTR_markers6__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_markers6__CategoryAttribute() {
    return "Markers";
  }
  get ATTR_markers6__DescriptionAttribute() {
    return "Seventh marker parameters";
  }
  get markers6() {
    return this._markers6;
  }
  set markers6(value) {
    this._markers6 = value;
  }
  get ATTR_markers7__DisplayName() {
    return "Marker 8";
  }
  get ATTR_markers7__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_markers7__CategoryAttribute() {
    return "Markers";
  }
  get ATTR_markers7__DescriptionAttribute() {
    return "Height marker parameters";
  }
  get markers7() {
    return this._markers7;
  }
  set markers7(value) {
    this._markers7 = value;
  }
};
var GraphFormProperties = class extends GenericProperties {
  constructor(initData, owner) {
    super(owner);
    this._Graph_series0 = new ChartSerie(YColor.Tomato);
    this._Graph_series1 = new ChartSerie(YColor.DodgerBlue);
    this._Graph_series2 = new ChartSerie(YColor.SeaGreen);
    this._Graph_series3 = new ChartSerie(YColor.Gold);
    this._Graph_showRecordedData = false;
    this._Graph_borderColor = YColor.LightGray;
    this._Graph_borderThickness = 1;
    this._Graph_bgColor1 = YColor.FromArgb(255, 220, 220, 220);
    this._Graph_bgColor2 = YColor.FromArgb(55, 240, 240, 240);
    this._Graph_resizeRule = Proportional.ResizeRule.FIXED;
    this._Graph_xAxis = new XaxisDescription();
    this._Graph_yAxes0 = new YaxisDescription(0, true);
    this._Graph_yAxes1 = new YaxisDescription(1, false);
    this._Graph_yAxes2 = new YaxisDescription(2, false);
    this._Graph_legendPanel = new LegendPanelDescription();
    this._Graph_dataTracker = new DataTrackerDescription();
    this._Graph_navigator = new NavigatorDescription();
    this._annotationPanels0 = new AnnotationPanelDescriptionGraph();
    this._annotationPanels1 = new AnnotationPanelDescriptionGraph();
    this.initFromXmlData(initData);
  }
  IsDataSourceAssigned() {
    let propList = Object.getOwnPropertyNames(this);
    propList.forEach((name) => {
      if (name.startsWith("Graphs_series")) {
        let s = this[name].GetValue(this, null);
        if (!(s.DataSource_source instanceof NullYSensor))
          return true;
      }
    });
    return false;
  }
  get ATTR_Graph_series0__DisplayName() {
    return "Series 1";
  }
  get ATTR_Graph_series0__CategoryAttribute() {
    return "Data Sources";
  }
  get ATTR_Graph_series0__PreExpandedCategoryAttribute() {
    return true;
  }
  get ATTR_Graph_series0__PreExpandedAttribute() {
    return true;
  }
  get ATTR_Graph_series0__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_Graph_series0__DescriptionAttribute() {
    return "First data series, expand for more.";
  }
  get Graph_series0() {
    return this._Graph_series0;
  }
  set Graph_series0(value) {
    this._Graph_series0 = value;
  }
  get ATTR_Graph_series1__DisplayName() {
    return "Series 2";
  }
  get ATTR_Graph_series1__CategoryAttribute() {
    return "Data Sources";
  }
  get ATTR_Graph_series1__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_Graph_series1__DescriptionAttribute() {
    return "Second data series, expand for more.";
  }
  get Graph_series1() {
    return this._Graph_series1;
  }
  set Graph_series1(value) {
    this._Graph_series1 = value;
  }
  get ATTR_Graph_series2__DisplayName() {
    return "Series 3";
  }
  get ATTR_Graph_series2__CategoryAttribute() {
    return "Data Sources";
  }
  get ATTR_Graph_series2__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_Graph_series2__DescriptionAttribute() {
    return "Third data series, expand for more.";
  }
  get Graph_series2() {
    return this._Graph_series2;
  }
  set Graph_series2(value) {
    this._Graph_series2 = value;
  }
  get ATTR_Graph_series3__DisplayName() {
    return "Series 4";
  }
  get ATTR_Graph_series3__CategoryAttribute() {
    return "Data Sources";
  }
  get ATTR_Graph_series3__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_Graph_series3__DescriptionAttribute() {
    return "Fourth data series, expand for more.";
  }
  get Graph_series3() {
    return this._Graph_series3;
  }
  set Graph_series3(value) {
    this._Graph_series3 = value;
  }
  get ATTR_Graph_showRecordedData__DisplayName() {
    return "Use datalogger data";
  }
  get ATTR_Graph_showRecordedData__CategoryAttribute() {
    return "Graph";
  }
  get ATTR_Graph_showRecordedData__CopyToTarget() {
    return false;
  }
  get ATTR_Graph_showRecordedData__DescriptionAttribute() {
    return "Makes the graph load the sensors datalogger contents. After disabling this feature, you may want to reset the dataview with the right-click context menu.";
  }
  get Graph_showRecordedData() {
    return this._Graph_showRecordedData;
  }
  set Graph_showRecordedData(value) {
    if (this._Graph_showRecordedData != value) {
      this._Graph_showRecordedData = value;
      if (this.ownerForm != null) {
        this._Graph_showRecordedData ? this.ownerForm.loadRecordedDataIfNeeded() : this.ownerForm.removeDataloggerData();
      }
    }
  }
  get ATTR_Graph_borderColor__DisplayName() {
    return "Border color";
  }
  get ATTR_Graph_borderColor__CategoryAttribute() {
    return "Graph";
  }
  get ATTR_Graph_borderColor__DescriptionAttribute() {
    return "Canvas borders color.";
  }
  get Graph_borderColor() {
    return this._Graph_borderColor;
  }
  set Graph_borderColor(value) {
    this._Graph_borderColor = value;
  }
  get ATTR_Graph_borderThickness__DisplayName() {
    return "Border thickness";
  }
  get ATTR_Graph_borderThickness__CategoryAttribute() {
    return "Graph";
  }
  get ATTR_Graph_borderThickness__DescriptionAttribute() {
    return "Canvas borders thickness.";
  }
  get Graph_borderThickness() {
    return this._Graph_borderThickness;
  }
  set Graph_borderThickness(value) {
    this._Graph_borderThickness = value;
  }
  get ATTR_Graph_bgColor1__DisplayName() {
    return "Background color 1";
  }
  get ATTR_Graph_bgColor1__CategoryAttribute() {
    return "Graph";
  }
  get ATTR_Graph_bgColor1__DescriptionAttribute() {
    return "Background gradient color 1.";
  }
  get Graph_bgColor1() {
    return this._Graph_bgColor1;
  }
  set Graph_bgColor1(value) {
    this._Graph_bgColor1 = value;
  }
  get ATTR_Graph_bgColor2__DisplayName() {
    return "Background color 2";
  }
  get ATTR_Graph_bgColor2__CategoryAttribute() {
    return "Graph";
  }
  get ATTR_Graph_bgColor2__DescriptionAttribute() {
    return "Background gradient color 2.";
  }
  get Graph_bgColor2() {
    return this._Graph_bgColor2;
  }
  set Graph_bgColor2(value) {
    this._Graph_bgColor2 = value;
  }
  get ATTR_Graph_resizeRule__DisplayName() {
    return "Font sizes";
  }
  get ATTR_Graph_resizeRule__CategoryAttribute() {
    return "Graph";
  }
  get ATTR_Graph_resizeRule__DescriptionAttribute() {
    return "Are font sizes fixed or do they change when window is resized?";
  }
  get Graph_resizeRule() {
    return this._Graph_resizeRule;
  }
  set Graph_resizeRule(value) {
    this._Graph_resizeRule = value;
  }
  get ATTR_Graph_xAxis__DisplayName() {
    return "X Axis";
  }
  get ATTR_Graph_xAxis__CategoryAttribute() {
    return "X/Y Axes";
  }
  get ATTR_Graph_xAxis__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_Graph_xAxis__DescriptionAttribute() {
    return "X-Axis, expand for more";
  }
  get Graph_xAxis() {
    return this._Graph_xAxis;
  }
  set Graph_xAxis(value) {
    this._Graph_xAxis = value;
  }
  get ATTR_Graph_yAxes0__DisplayName() {
    return "YAxis 1";
  }
  get ATTR_Graph_yAxes0__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_Graph_yAxes0__CategoryAttribute() {
    return "X/Y Axes";
  }
  get ATTR_Graph_yAxes0__DescriptionAttribute() {
    return "First Y Axis, expand for more.";
  }
  get Graph_yAxes0() {
    return this._Graph_yAxes0;
  }
  set Graph_yAxes0(value) {
    this._Graph_yAxes0 = value;
  }
  get ATTR_Graph_yAxes1__DisplayName() {
    return "YAxis 2";
  }
  get ATTR_Graph_yAxes1__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_Graph_yAxes1__CategoryAttribute() {
    return "X/Y Axes";
  }
  get ATTR_Graph_yAxes1__DescriptionAttribute() {
    return "Second Y Axis, expand for more.";
  }
  get Graph_yAxes1() {
    return this._Graph_yAxes1;
  }
  set Graph_yAxes1(value) {
    this._Graph_yAxes1 = value;
  }
  get ATTR_Graph_yAxes2__DisplayName() {
    return "YAxis 3";
  }
  get ATTR_Graph_yAxes2__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_Graph_yAxes2__CategoryAttribute() {
    return "X/Y Axes";
  }
  get ATTR_Graph_yAxes2__DescriptionAttribute() {
    return "Third Y Axis, expand for more.";
  }
  get Graph_yAxes2() {
    return this._Graph_yAxes2;
  }
  set Graph_yAxes2(value) {
    this._Graph_yAxes2 = value;
  }
  get ATTR_Graph_legendPanel__DisplayName() {
    return "Legend Panel";
  }
  get ATTR_Graph_legendPanel__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_Graph_legendPanel__CategoryAttribute() {
    return "Graph";
  }
  get ATTR_Graph_legendPanel__DescriptionAttribute() {
    return "Panel containing a description of all data series. Expand for more.";
  }
  get Graph_legendPanel() {
    return this._Graph_legendPanel;
  }
  set Graph_legendPanel(value) {
    this._Graph_legendPanel = value;
  }
  get ATTR_Graph_dataTracker__DisplayName() {
    return "Data tracker";
  }
  get ATTR_Graph_dataTracker__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_Graph_dataTracker__CategoryAttribute() {
    return "Graph";
  }
  get ATTR_Graph_dataTracker__DescriptionAttribute() {
    return "Show dynamic value labels while the mouse is moving over the graph. Expand for more.";
  }
  get Graph_dataTracker() {
    return this._Graph_dataTracker;
  }
  set Graph_dataTracker(value) {
    this._Graph_dataTracker = value;
  }
  get ATTR_Graph_navigator__DisplayName() {
    return "Navigator";
  }
  get ATTR_Graph_navigator__CategoryAttribute() {
    return "Graph";
  }
  get ATTR_Graph_navigator__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_Graph_navigator__DescriptionAttribute() {
    return "Small additional graph showing the whole data set and allowing to quickly navigate among data. Expand for more.";
  }
  get Graph_navigator() {
    return this._Graph_navigator;
  }
  set Graph_navigator(value) {
    this._Graph_navigator = value;
  }
  get ATTR_Graph_annotationPanels0__DisplayName() {
    return "Annotation 1";
  }
  get ATTR_Graph_annotationPanels0__CategoryAttribute() {
    return "Annotations";
  }
  get ATTR_Graph_annotationPanels0__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_Graph_annotationPanels0__DescriptionAttribute() {
    return "Customizable text panel 1";
  }
  get Graph_annotationPanels0() {
    return this._annotationPanels0;
  }
  set Graph_annotationPanels0(value) {
    this._annotationPanels0 = value;
  }
  get ATTR_Graph_annotationPanels1__DisplayName() {
    return "Annotation 2";
  }
  get ATTR_Graph_annotationPanels1__CategoryAttribute() {
    return "Annotations";
  }
  get ATTR_Graph_annotationPanels1__ReadOnlyAttribute() {
    return true;
  }
  get ATTR_Graph_annotationPanels1__DescriptionAttribute() {
    return "Customizable text panel 2";
  }
  get Graph_annotationPanels1() {
    return this._annotationPanels1;
  }
  set Graph_annotationPanels1(value) {
    this._annotationPanels1 = value;
  }
};

// obj/full/contextMenu.js
var ContextMenuSeparator = class {
  constructor() {
    this.TR = document.createElement("TR");
    this.TR["objectData"] = this;
    this.TR.className = ContextMenu.SEPARATOR_MARKER;
    this.TD_caption = document.createElement("TD");
    this.TD_caption.style.backgroundColor = ContextMenu.iconBGColor;
    this.TD_caption.style.paddingLeft = "3px";
    this.TD_caption.style.paddingRight = "3px";
    let hr = document.createElement("HR");
    this.TD_caption.colSpan = 2;
    this.TD_caption.appendChild(hr);
    this.TD_icon = document.createElement("TD");
    this.TD_icon.style.backgroundColor = ContextMenu.captionBgColor;
    this.TR.appendChild(this.TD_icon);
    this.TR.appendChild(this.TD_caption);
  }
  toString() {
    return "Separator";
  }
  get focusable() {
    return false;
  }
  parentMenuisClosing() {
  }
  get domData() {
    return this.TR;
  }
};
var ContextMenuItemBase = class {
  get userdata() {
    return this._userdata;
  }
  set userdata(value) {
    this._userdata = value;
  }
  constructor(menu, icon, caption) {
    this._clickHidesMenu = true;
    this._userdata = null;
    this._menu = menu;
    this.TR = document.createElement("TR");
    this.TR["objectData"] = this;
    this.TD_caption = document.createElement("TD");
    this.TD_caption.style.backgroundColor = ContextMenu.iconBGColor;
    this.TD_caption.style.paddingLeft = "3px";
    this.TD_caption.style.paddingRight = "3px";
    this.TD_caption.style.whiteSpace = "nowrap";
    this.TD_icon = document.createElement("TD");
    if (icon != null)
      this.TD_icon.innerHTML = icon;
    this.TD_icon.style.backgroundColor = ContextMenu.captionBgColor;
    this.A_caption = document.createElement("A");
    this.A_caption.innerHTML = caption;
    this.TR.style.cursor = "pointer";
    this.TR.tabIndex = 0;
    this.TR.style.outline = "none";
    this._TR_keydown = (e) => {
      e.preventDefault();
      this.keydown(e);
    };
    this._TR_mouseover = (e) => {
      this.mouserOver(e);
    };
    this._TR_mouseout = (e) => {
      this.mouserOut(e);
    };
    this._A_mouseover = (e) => {
      this.mouserOver(e);
    };
    this._A_mouseout = (e) => {
      this.mouserOut(e);
    };
    this._A_click = (e) => {
      this.activate();
    };
    this._TR_focusin = () => {
      this.focusIn();
    };
    this._TR_focusout = () => {
      this.focusOut();
    };
    this.TR.addEventListener("mouseover", this._TR_mouseover);
    this.TR.addEventListener("mouseout", this._TR_mouseout);
    this.TR.addEventListener("click", this._A_click);
    this.TR.addEventListener("keydown", this._TR_keydown);
    this.A_caption.addEventListener("mouseover", this._A_mouseover);
    this.A_caption.addEventListener("mouseout", this._A_mouseout);
    this.TD_caption.appendChild(this.A_caption);
    this.TR.appendChild(this.TD_icon);
    this.TR.appendChild(this.TD_caption);
    this.TR.addEventListener("focusin", this._TR_focusin);
    this.TR.addEventListener("focusout", this._TR_focusout);
  }
  toString() {
    return this.TD_caption.innerText;
  }
  get focusable() {
    return this.visible;
  }
  activate() {
  }
  focus() {
    this.TR.focus();
    this._menu.closeSubmenus();
  }
  focusIn() {
    if (this.TD_caption.style.backgroundColor == ContextMenu.iconBGColor)
      this._menu.closeSubmenus();
    this.TD_caption.style.backgroundColor = ContextMenu.ActiveColor;
    this.TD_icon.style.backgroundColor = ContextMenu.ActiveColor;
  }
  focusOut() {
    this.TD_caption.style.backgroundColor = ContextMenu.iconBGColor;
    this.TD_icon.style.backgroundColor = ContextMenu.captionBgColor;
  }
  removeAndDestroy() {
    if (this.TR.parentNode != null)
      this.TR.parentNode.removeChild(this.TR);
    this.TR.removeEventListener("keydown", this._TR_keydown);
    this.TR.removeEventListener("mouseover", this._TR_mouseover);
    this.TR.removeEventListener("mouseout", this._TR_mouseout);
    this.A_caption.removeEventListener("mouseover", this._A_mouseover);
    this.A_caption.removeEventListener("mouseout", this._A_mouseout);
    this.A_caption.removeEventListener("click", this._A_click);
    this.TR.removeEventListener("focusin", this._TR_focusin);
    this.TR.removeEventListener("focusout", this._TR_focusout);
  }
  set caption(value) {
    this.A_caption.innerHTML = value;
  }
  get caption() {
    return this.A_caption.innerHTML;
  }
  keydown(e) {
    if (e.code == "ArrowDown")
      this._menu.activateNext(this);
    if (e.code == "ArrowUp")
      this._menu.activatePrevious(this);
    if (e.code == "Enter")
      this.activate();
    if (e.code == "Escape") {
      this._menu.close();
      if (this._menu.parentMenuItem != null)
        this._menu.parentMenuItem.focus();
    }
    if (e.code == "ArrowLeft") {
      if (this._menu.parentMenuItem != null) {
        this._menu.close();
        this._menu.parentMenuItem.focus();
      }
    }
  }
  mouserOver(e) {
    this.TD_caption.style.backgroundColor = ContextMenu.ActiveColor;
    this.TD_icon.style.backgroundColor = ContextMenu.ActiveColor;
    this._menu.closeSubmenus();
  }
  mouserOut(e) {
    this.TD_caption.style.backgroundColor = ContextMenu.iconBGColor;
    this.TD_icon.style.backgroundColor = ContextMenu.captionBgColor;
  }
  get domData() {
    return this.TR;
  }
  get visible() {
    return this.TR.style.display != "none";
  }
  set visible(value) {
    this.TR.style.display = value ? "" : "none";
  }
  parentMenuisClosing() {
  }
  closeMenu(all) {
    if (all)
      this._menu.closeAll();
    else
      this._menu.close();
  }
};
var ContextMenuItem = class extends ContextMenuItemBase {
  activate() {
    if (this._clickHidesMenu)
      this.closeMenu(true);
    if (this._callback != null)
      this._callback();
  }
  constructor(menu, icon, caption, callback) {
    super(menu, icon, caption);
    this._callback = callback;
    this.TD_caption.colSpan = 2;
  }
};
var ContextMenuItemSubMenuEntry = class extends ContextMenuItem {
  constructor(menu, icon, caption, submenu) {
    super(menu, icon, caption, null);
    this.TD_caption.colSpan = 1;
    this._submenu = submenu;
    this._submenu.parentMenuItem = this;
    this._parentmenu = menu;
    this._clickHidesMenu = false;
    this.TD_arrow = document.createElement("TD");
    this.TD_arrow.style.backgroundColor = ContextMenu.iconBGColor;
    this.TD_arrow.style.textAlign = "right";
    this.TD_arrow.style.paddingRight = "3px";
    this.TD_arrow.innerHTML = "&#9654;";
    this.TR.appendChild(this.TD_arrow);
    this.A_caption.addEventListener("click", (e) => {
      this.showSubmenu();
    });
    this.A_caption.addEventListener("touchstart", (e) => {
      if (e.touches.length == 1)
        this.activate();
    });
    this._submenu.zIndex = this._parentmenu.zIndex + 1;
  }
  keydown(e) {
    super.keydown(e);
    if (e.code == "ArrowRight") {
      this.activate();
      this._submenu.focusFirst();
    }
  }
  removeAndDestroy() {
    this._submenu.close();
    this._submenu.destroy();
    super.removeAndDestroy();
  }
  activate() {
    this.showSubmenu();
  }
  get submenu() {
    return this._submenu;
  }
  showSubmenu() {
    this._submenu.zIndex = this._parentmenu.zIndex + 1;
    let x = 0;
    let y = 0;
    let it = this.TR;
    do {
      x += it.offsetLeft || 0;
      y += it.offsetTop || 0;
      it = it.offsetParent;
    } while (it);
    this._submenu.showContextMenu(x + this._parentmenu.width - 15, y + 5);
  }
  focusIn() {
    super.focusIn();
    this.TD_arrow.style.backgroundColor = ContextMenu.ActiveColor;
  }
  focusOut() {
    super.focusOut();
    this.TD_arrow.style.backgroundColor = ContextMenu.iconBGColor;
  }
  parentMenuisClosing() {
    this._submenu.close();
  }
  mouserOver(e) {
    this.focusIn();
    this._parentmenu.setDelayedAction(() => {
      if (this.visible)
        this.showSubmenu();
    });
  }
  mouserOut(e) {
    this._parentmenu.cancelDelayedAction();
    this.focusOut();
  }
};
var ContextMenuBase = class {
  get parentMenuItem() {
    return this._parentMenuItem;
  }
  set parentMenuItem(value) {
    this._parentMenuItem = value;
  }
  get userdata() {
    return this._userdata;
  }
  set userdata(value) {
    this._userdata = value;
  }
  constructor(baseSize, openCallback, fontFamily) {
    this._visible = false;
    this._zIndex = 100002;
    this._parentmenu = null;
    this._parentMenuItem = null;
    this._userdata = null;
    this._openCallback = openCallback;
    this.Menutable = document.createElement("TABLE");
    this.Menutable.style.position = "absolute";
    this.Menutable.style.border = "1px solid #808080";
    if (typeof fontFamily !== "undefined")
      this.Menutable.style.fontFamily = fontFamily;
    this.Menutable.style.fontSize = (2 * baseSize / 3).toFixed(1) + "px";
    this.Menutable.style.borderSpacing = "0";
    this.Menutable.style.boxShadow = " 4px 4px 4px 1px rgba(0,0,0,0.05)";
    this.Menutable.style.zIndex = this._zIndex.toString();
    this._timer = null;
    this.visible = false;
  }
  closeAll() {
    this.close();
    if (this._parentmenu != null)
      this._parentmenu.closeAll();
  }
  cancelDelayedAction() {
    if (this._timer != null) {
      clearTimeout(this._timer);
      this._timer = null;
    }
  }
  setDelayedAction(action) {
    this.cancelDelayedAction();
    this._timer = setTimeout(() => {
      action();
    }, 500);
  }
  get parentMenu() {
    return this._parentmenu;
  }
  destroy() {
    for (let i = 0; i < this.Menutable.childNodes.length; i++) {
      let item = this.Menutable.childNodes[i]["objectData"];
      item.removeAndDestroy();
    }
    if (this.Menutable.parentNode != null)
      this.Menutable.parentNode.removeChild(this.Menutable);
  }
  focusFirst() {
    for (let i = 0; i < this.Menutable.childNodes.length; i++) {
      let item = this.Menutable.childNodes[i]["objectData"];
      if (item.focusable) {
        item.focus();
        return;
      }
    }
  }
  toString() {
    let res = "";
    for (let i = 0; i < this.Menutable.childNodes.length; i++) {
      let item = this.Menutable.childNodes[i]["objectData"];
      res = res + item.caption + "";
    }
    return res;
  }
  isXYOnMenu(x, y) {
    if (!this.visible)
      return false;
    if (x >= this.Menutable.offsetLeft && x <= this.Menutable.offsetLeft + this.Menutable.offsetWidth && y >= this.Menutable.offsetTop && y <= this.Menutable.offsetTop + this.Menutable.offsetHeight) {
      return true;
    }
    for (let i = 0; i < this.Menutable.childNodes.length; i++) {
      let item = this.Menutable.childNodes[i]["objectData"];
      if (item instanceof ContextMenuItemSubMenuEntry) {
        if (item.submenu.isXYOnMenu(x, y))
          return true;
      }
    }
    return false;
  }
  activateNext(source) {
    let found = false;
    for (let i = 0; i < this.Menutable.childNodes.length; i++) {
      let item = this.Menutable.childNodes[i]["objectData"];
      if (item == source) {
        found = true;
      } else if (found && item.focusable) {
        item.focus();
        return;
      }
    }
  }
  activatePrevious(source) {
    let previous = null;
    for (let i = 0; i < this.Menutable.childNodes.length; i++) {
      let item = this.Menutable.childNodes[i]["objectData"];
      if (item == source) {
        if (previous != null)
          previous.focus();
        return;
      }
      if (item.focusable)
        previous = item;
    }
  }
  get width() {
    return this.Menutable.offsetWidth;
  }
  closeSubmenus() {
    this.closeSubMenusExcept(null);
  }
  get zIndex() {
    return this._zIndex;
  }
  set zIndex(value) {
    this._zIndex = value;
    this.Menutable.style.zIndex = this._zIndex.toString();
  }
  get visible() {
    return this.Menutable.style.display != "none";
  }
  set visible(value) {
    this.Menutable.style.display = value ? "" : "none";
  }
  close() {
    this.cancelDelayedAction();
    for (let i = 0; i < this.Menutable.childNodes.length; i++) {
      let item = this.Menutable.childNodes[i]["objectData"];
      item.parentMenuisClosing();
    }
    this.visible = false;
    this.closeSubmenus();
  }
  refresh() {
    let showSeparation = false;
    for (let i = 0; i < this.Menutable.childNodes.length; i++) {
      let element = this.Menutable.childNodes[i];
      if (element.className == ContextMenu.SEPARATOR_MARKER) {
        element.style.display = showSeparation ? "" : "none";
        showSeparation = false;
      } else if (element.style.display == "")
        showSeparation = true;
    }
  }
  addMenuItem(icon, caption, callback) {
    let menuItem = new ContextMenuItem(this, icon, caption, callback);
    this.Menutable.appendChild(menuItem.domData);
    return menuItem;
  }
  get menuItemsCount() {
    return this.Menutable.childNodes.length;
  }
  closeSubMenusExcept(doNotClose) {
    for (let i = 0; i < this.Menutable.childNodes.length; i++) {
      let item = this.Menutable.childNodes[i]["objectData"];
      if (item instanceof ContextMenuItemSubMenuEntry) {
        if (item.submenu != doNotClose) {
          item.submenu.close();
        }
      }
    }
  }
  subMenuisOpening(source) {
    this.closeSubMenusExcept(source);
  }
  addSubMenuItem(icon, caption, submenu) {
    submenu.zIndex = this.zIndex + 1;
    let menuItem = new ContextMenuItemSubMenuEntry(this, icon, caption, submenu);
    this.Menutable.appendChild(menuItem.domData);
    return menuItem;
  }
  clearAllContents() {
    while (this.Menutable.childNodes.length > 0) {
      let item = this.Menutable.childNodes[0]["objectData"];
      item.removeAndDestroy();
    }
  }
  AddSeparator() {
    let separator = new ContextMenuSeparator();
    this.Menutable.appendChild(separator.domData);
    return separator;
  }
  showContextMenu(x, y) {
  }
};
ContextMenuBase.SEPARATOR_MARKER = "separator";
ContextMenuBase.iconBGColor = "#fdfdfd";
ContextMenuBase.captionBgColor = "#f1f1f1";
ContextMenuBase.ActiveColor = "#c4e1ff";
var ContextSubMenu = class extends ContextMenuBase {
  constructor(baseSize, parentMenu, openCallback, fontFamily) {
    super(baseSize, openCallback, fontFamily);
    this._parentmenu = parentMenu;
    document.body.appendChild(this.Menutable);
  }
  showContextMenu(x, y) {
    if (this._parentmenu != null)
      this._parentmenu.subMenuisOpening(this);
    if (this._openCallback != null)
      this._openCallback(x, y);
    this.Menutable.style.left = x.toString() + "px";
    this.Menutable.style.top = y.toString() + "px";
    this.visible = true;
    let right = this.Menutable.offsetLeft - this.Menutable.scrollLeft + this.Menutable.offsetWidth;
    let bottom = this.Menutable.offsetTop - this.Menutable.scrollTop + this.Menutable.offsetHeight;
    if (right > window.innerWidth)
      this.Menutable.style.left = (x - (right - window.innerWidth)).toString() + "px";
    if (bottom > window.innerHeight)
      this.Menutable.style.top = (y - (bottom - window.innerHeight)).toString() + "px";
  }
};
var ContextMenu = class extends ContextMenuBase {
  constructor(baseSize, openCallback, fontFamily) {
    super(baseSize, openCallback, fontFamily);
    document.addEventListener("contextmenu", (e) => {
      let tagname = "";
      if (e.target != null && constants.RunningOnAndroid)
        tagname = e.target.tagName;
      if (tagname != "INPUT") {
        e.preventDefault();
        this.showContextMenu(e.pageX, e.pageY);
      }
    });
    document.addEventListener("dblclick", (e) => {
      if (constants.dbleClickBringsUpContextMenu)
        this.showContextMenu(e.pageX, e.pageY);
    });
    document.addEventListener("click", (e) => {
      this.click(e);
    });
    document.body.appendChild(this.Menutable);
  }
  click(e) {
    if (!this.visible)
      return;
    if (!this.isXYOnMenu(e.pageX, e.pageY)) {
      this.close();
    }
  }
  showContextMenu(x, y) {
    let z = YWindow.ConTextMenuBestZindex;
    if (z < 0)
      return;
    this.zIndex = z;
    this.Menutable.style.left = x.toString() + "px";
    this.Menutable.style.top = y.toString() + "px";
    this.visible = true;
    let right = this.Menutable.offsetLeft - this.Menutable.scrollLeft + this.Menutable.offsetWidth;
    let bottom = this.Menutable.offsetTop - this.Menutable.scrollTop + this.Menutable.offsetHeight;
    if (right > window.innerWidth)
      this.Menutable.style.left = Math.max(0, x - (right - window.innerWidth)).toString() + "px";
    if (bottom > window.innerHeight)
      this.Menutable.style.top = Math.max(0, y - (bottom - window.innerHeight)).toString() + "px";
    if (this._openCallback != null)
      this._openCallback(x, y);
    if (x <= 5 && y <= 5)
      this.focusFirst();
  }
};

// obj/full/ressources.js
var ressources = class {
  static SVGheader(size, shadowDef, title) {
    let res = '<svg  xmlns="http://www.w3.org/2000/svg" width="' + size + '" height="' + size + '" viewBox="0 0 128  128">';
    if (typeof title != "undefined")
      res = res + "<title>" + title + "</title>";
    if (shadowDef)
      res = res + '<defs><filter id="f1" x="0" y="0"><feGaussianBlur in="SourceGraphic" stdDeviation="2" /></filter></defs>';
    res = res + '<g transform="translate(0,128)"><g transform="scale(1,-1)">';
    return res;
  }
  static SVGFooter() {
    return "</g></g></svg>";
  }
  static addIconTransparency() {
    return '<g opacity="0.5">';
  }
  static addIconSrcCode() {
    return '<path d="m 8 24 L 8 40 L 24 40 L 24 56 L 40 56 L 40 40 L 56 40 L 56 24 L 40 24 L 40 8 L 24 8 L 24 24   Z" fill="#40ff40" stroke="black" stroke-width="8" stroke-linecap="round"/>';
  }
  static deleteIconSrcCode() {
    return '<path d="m 15 4 L 4 15 L 19 29 L 4 43 L 15 55 L 29 40 L 43 55 L 55 43 L 40 29 L 55 15 L 44 4 L 29 18 Z" fill="#ff4040" stroke="black" stroke-width="8" stroke-linecap="round">';
  }
  static IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, shadowcode, activeCode, title) {
    let res = ressources.SVGheader(size, shadow, title);
    if (shadow)
      res = res + '<g transform="translate(6,-6)">' + shadowcode + "</g>";
    if (semitransparent)
      res = res + ressources.addIconTransparency();
    res = res + activeCode;
    if (semitransparent)
      res = res + "</g>";
    if (addIcon)
      res = res + ressources.addIconSrcCode();
    if (deleteIcon)
      res = res + ressources.deleteIconSrcCode();
    res = res + ressources.SVGFooter();
    return res;
  }
  static GraphIcon(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="m 12 24 L 103 24 L 103 107 L 12 107 z" fill="lightgray" filter="url(#f1)" /><path d="m 112 24 L 12 24 L 12 113"  style="fill:none; stroke:lightgray; stroke-width:4px; stroke-linejoin:round;stroke-linecap:round;" filter="url(#f1)"/>', '<path d="m 12 24 L 103 24 L 103 107 L 12 107 z" fill="#ffffe9" /><line x1="43" y1="24" x2="43" y2="107" stroke="#e3e3e3" stroke-width="2" stroke-linecap="round" /><line x1="43" y1="24" x2="43" y2="107" stroke="#e3e3e3" stroke-width="2" stroke-linecap="round" /><line x1="73" y1="24" x2="73" y2="107" stroke="#e3e3e3" stroke-width="2" stroke-linecap="round" /><line x1="12" y1="51" x2="103" y2="51" stroke="#e3e3e3" stroke-width="2" stroke-linecap="round" /><line x1="12" y1="79" x2="103" y2="79" stroke="#e3e3e3" stroke-width="2" stroke-linecap="round" /><line x1="12" y1="107" x2="103" y2="107" stroke="#e3e3e3" stroke-width="2" stroke-linecap="round" /><path d="m 12 77 L 34 65 L 55 85 L 70 77 L 100 93" fill="none" stroke="#FF0000" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" /><line x1="103" y1="24" x2="103" y2="107" stroke="#e3e3e3" stroke-width="2" stroke-linecap="round" /><path d="m 112 24 L 12 24 L 12 113"  style="fill:none; stroke:black; stroke-width:4px; stroke-linejoin:round;stroke-linecap:round;"/>');
  }
  static SolidGaugeIcon(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="M 34 40 L 14 40 14 52 A 50 50 0 0 0 114 52 L  114 40 L 94 40 L 94 52 A 30 30 0 1 1  34 52 Z" style="fill:lightgray;fill-opacity=0.4;" filter="url(#f1)"/><text x="43" y="-30" fill="black" transform="scale(1,-1)" style="font: bold 24px sans-serif;fill:lightgray;fill-opacity=0.4;" filter="url(#f1)">123</text>', '<path d="M 34 40 L 14 40 14 52 A 50 50 0 0 0 114 52 L  114 40 L 94 40 L 94 52 A 30 30 0 1 1  34 52 Z" style="fill:#ffffe9; stroke:none; "/><path d="M 34 40 L 14 40 14 52 A 50 50 0 0 0 29 88 L  43 72.5   A 30 30 0 0 1  34 52 Z" style="fill:red; stroke:none;"/><path d="M 34 40 L 14 40 14 52 A 50 50 0 0 0 114 52 L  114 40 L 94 40 L 94 52 A 30 30 0 1 1  34 52 Z" style="fill:none; stroke:black; stroke-width:4px; stroke-linejoin:round;stroke-linecap:round;"/><text x="43" y="-30" fill="black" transform="scale(1,-1)" style="font: bold 24px sans-serif;">123</text>');
  }
  static RawDataIcon(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="m 16 27 L 107 27 L 107 107 L 16 107 z" fill="lightgray" filter="url(#f1)" />', '<path d="m 16 27 L 107 27 L 107 107 L 16 107 z" style="fill:#ffffe9;" /><line x1="47" y1="27" x2="47" y2="107" stroke="#e3e3e3" stroke-width="2"  /><line x1="76" y1="27" x2="76" y2="107" stroke="#e3e3e3" stroke-width="2"  /><line x1="16" y1="44" x2="107" y2="44" stroke="#e3e3e3" stroke-width="2"  /><line x1="16" y1="60" x2="107" y2="60" stroke="#e3e3e3" stroke-width="2"  /><line x1="16" y1="76" x2="107" y2="76" stroke="#e3e3e3" stroke-width="2"  /><path d="m 16 27 L 107 27 L 107 107 L 16 107 z" style="fill:none;stroke:black; stroke-width:4px; stroke-linejoin:round;" /><path d="m 19 91 L 104 91 L 104 104 L 19 104 z" style="fill:#b2b2b2; stroke:#6f6f6f; stroke-width:4px; stroke-linejoin:round;" /><line x1="47" y1="91" x2="47" y2="104" stroke="#6f6f6f" stroke-width="2"  /><line x1="76" y1="91" x2="76" y2="104" stroke="#6f6f6f" stroke-width="2"  />');
  }
  static ConfigureIcon(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="M85 85 L 102 80 L 113 91 A  41 100 45 0 0  86 71 L 37 21 A  5 11 45 1 0  21 37 L 71 86  A  41 100 45 0 0  91 113 L 80 102 Z" style="fill:lightgray;fill-opacity=0.4;" filter="url(#f1)"/>', '<path d="M85 85 L 102 80 L 113 91 A  41 100 45 0 0  86 71 L 37 21 A  5 11 45 1 0  21 37 L 71 86  A  41 100 45 0 0  91 113 L 80 102 Z" style="fill:grey; stroke:black; stroke-width:4px; stroke-linejoin:round;stroke-linecap:round;"/>');
  }
  static DigitalDisplayIcon(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="m 12 45 L 111 45 L 111 89 L 12 89 z" fill="lightgray" filter="url(#f1)" />', '<path d="m 12 45 L 111 45 L 111 89 L 12 89 z" style="fill:#ffffe9; stroke:black; stroke-width:4px; stroke-linejoin:round;" /><text x="29" y="-52" fill="black" transform="scale(1,-1)" style="font: bold 40px sans-serif;">123</text> ');
  }
  static AngularGaugeIcon(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<circle  cx="64" cy="64" r="40" fill="lightgray" filter="url(#f1)" />', '<circle  cx="64" cy="64" r="40" stroke="black" stroke-width="4" fill="#ffffe9" /><line x1="64" y1="104" x2="64" y2="94" stroke="black" stroke-width="2"   stroke-linecap="round" /><line x1="29" y1="84" x2="38" y2="79" stroke="black" stroke-width="2"   stroke-linecap="round" /><line x1="29" y1="44" x2="38" y2="48" stroke="black" stroke-width="2"   stroke-linecap="round" /><line x1="98" y1="84" x2="91" y2="79" stroke="black" stroke-width="2"   stroke-linecap="round" /><line x1="98" y1="44" x2="91" y2="48" stroke="black" stroke-width="2"   stroke-linecap="round" /><g transform="translate(64,64)"><g transform="rotate(-70,0,0)"><path d="m 5 0 L 0 5 L -25 0 L 0 -5 z" style="fill:black;stroke:black; stroke-width:2px; stroke-linejoin:round;"/></g></g>');
  }
  static EditIcon(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="m 16 48 L 108 48 L 108 88 L 16 88 z" fill="lightgray" filter="url(#f1)" /><path d="m 87 24 L 75 40 L 67 31 L 62 64 L 93 50 L 82 44  L 94 29 z" fill="lightgray" filter="url(#f1)" />', '<path d="m 16 48 L 108 48 L 108 88 L 16 88 z" style="fill:#ffffe9; stroke:black; stroke-width:4px; stroke-linejoin:round;" /><path d="m 87 24 L 75 40 L 67 31 L 62 64 L 93 50 L 82 44  L 94 29 z" style="fill:white; stroke:black; stroke-width:2px; stroke-linejoin:round;" /> ');
  }
  static AllIcon(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="m 60 108 L 46 74 L 8 72 L 38 48 L 28 12 L 60 32 L 92 12  L 82 48 L 112 70  L 74 74  z" fill="lightgray" filter="url(#f1)" />', '<path d="m 60 108 L 46 74 L 8 72 L 38 48 L 28 12 L 60 32 L 92 12  L 82 48 L 112 70  L 74 74  z" style="fill:#fee403; stroke:#918201; stroke-width:4px; stroke-linejoin:round;" />');
  }
  static TrashIcon(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="m 33 12 L 24 94 L 104 94 L 95 12 z" fill="lightgray" filter="url(#f1)" /><g transform="translate(70,105)"><g transform="rotate(-10,0,0)"><path d="m -40 0 L -30 5 L 30 5 L 40 0 z" fill="lightgray" filter="url(#f1)" /><path d="m -9 5 L -9 12 L 9 12 L 9 5" stroke="lightgray" filter="url(#f1)"/> </g></g>', '<path d="m 33 12 L 24 94 L 104 94 L 95 12 z" style="fill:#f8f8f8; stroke:black; stroke-width:4px; stroke-linejoin:round;" /><Line x1="43" y1="82" x2="48" y2="21" style=" stroke:black; stroke-width:4px; stroke-linecap:round;" /><Line x1="64" y1="82" x2="64" y2="21" style=" stroke:black; stroke-width:4px; stroke-linecap:round;" /><Line x1="86" y1="82" x2="80" y2="21" style=" stroke:black; stroke-width:4px; stroke-linecap:round;" /><g transform="translate(70,105)"><g transform="rotate(-10,0,0)"><path d="m -40 0 L -30 5 L 30 5 L 40 0 z" style="fill:#f8f8f8; stroke:black; stroke-width:4px; stroke-linejoin:round;" /><path d="m -9 5 L -9 12 L 9 12 L 9 5" style="fill:none; stroke:black; stroke-width:4px; stroke-linejoin:round;" /></g></g>');
  }
  static SaveIcon(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="m 20 12 A 4 4 0 0 0 16 16 L 16 106  A 4 4 0 0 0 20 110 L 24 110 L 24 108 L 97 108 L 97 110 L 104 110  A 4 4 0 0 0 108 106 L 108 16   A 4 4 0 0 0 104 12  z" fill="lightgray" filter="url(#f1)" />', '<path d="m 20 12 A 4 4 0 0 0 16 16 L 16 106  A 4 4 0 0 0 20 110 L 24 110 L 24 108 L 97 108 L 97 110 L 104 110  A 4 4 0 0 0 108 106 L 108 16   A 4 4 0 0 0 104 12  z" style="fill:#3583dd; stroke:#226fc8; stroke-width:4px; stroke-linejoin:round;" /><path d="m 24 11 L 24 65  A 5 5 0 0 0 29 70 L 95 70  A 5 5 0 0 0 100 65 L 100 11  z" style="fill:#f7f7f7; stroke:#c6c6c6; stroke-width:2px; stroke-linejoin:round;"/><path d="m 36 111 L 90 111 L 90 80 A 4 4 0 0 0 86 76 L 40 76 A 4 4 0 0 0 36 80 z"  style="fill:#e5e5e5; stroke:#c6c6c6; stroke-width:2px; stroke-linejoin:round;" /><rect x="67" y="79" width="14" height ="28"     style="fill:#3583dd; stroke:#c6c6c6; stroke-width:2px; stroke-linejoin:round;"');
  }
  static SaveNeededIcon(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="m 8 16 L 64 110 L 120 16 z " style="fill:lightgray; stroke:lightgray; stroke-width:10px; stroke-linejoin:round;filter:url(#f1)" />', '<path d="m 8 16 L 64 110 L 120 16 z" style="fill:#FAE701; stroke:#FAE701; stroke-width:10px; stroke-linejoin:round;" /><path d="m 8 16 L 64 110 L 120 16 z" style="fill:none; stroke:black; stroke-width:2px; stroke-linejoin:round;" /><g transform="translate(-64,-64) scale(0.4 0.4) translate(260,215)"><path d="m 20 12 A 4 4 0 0 0 16 16 L 16 106  A 4 4 0 0 0 20 110 L 24 110 L 24 108 L 97 108 L 97 110 L 104 110  A 4 4 0 0 0 108 106 L 108 16   A 4 4 0 0 0 104 12  z" style="fill:black; stroke:black; stroke-width:4px; stroke-linejoin:round;" /><path d="m 24 11 L 24 65  A 5 5 0 0 0 29 70 L 95 70  A 5 5 0 0 0 100 65 L 100 11  z" style="fill:#FAE701; stroke:black; stroke-width:2px; stroke-linejoin:round;"/><path d="m 36 111 L 90 111 L 90 80 A 4 4 0 0 0 86 76 L 40 76 A 4 4 0 0 0 36 80 z"  style="fill:#FAE701; stroke:black; stroke-width:2px; stroke-linejoin:round;" /><rect x="67" y="79" width="14" height ="28"     style="fill:#FAE701; stroke:black; stroke-width:2px; stroke-linejoin:round;"</g>', "Don't forget to save.");
  }
  static snapshotIcon(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="m 16 32  L 16 78 A 6 6 0 0 0 22 84 L 46 84 L 48 94 A 5.75 3.25 30 0 0 54 100 L 78 100 A 3.25 5.75  30 0 0 84 94  L 86 84 L 104 84  A 6 6 0 0 0 110 78  L 110 32 A 6 6 0 0 0 104 26 L 22 26 A 6 6 0 0 0 16 32 z"  fill="lightgray" filter="url(#f1)" />', '<path d="m 16 32  L 16 78 A 6 6 0 0 0 22 84 L 46 84 L 48 94 A 5.75 3.25 30 0 0 54 100 L 78 100 A 3.25 5.75  30 0 0 84 94  L 86 84 L 104 84  A 6 6 0 0 0 110 78  L 110 32 A 6 6 0 0 0 104 26 L 22 26 A 6 6 0 0 0 16 32 z" style="fill:#707070; stroke:#464646; stroke-width:4px; stroke-linejoin:round;" /><Circle cx="65" cy="55" r="26"   style="fill:#895e96; stroke:#464646; stroke-width:6px; stroke-linejoin:round;" />');
  }
  static CloseIcon(size, shadow, semitransparent, addIcon, deleteIcon, title) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="m 21.6 38.6 L 47.1 64.3 L 22 89.5 L 38.4 106.2 L 64 81 L 89.3 106.2 L 105.8 89.5 L 80.6 64 L 105.8 38.9 L 89.3 22.2 L 64 47.5  L 38.3 22.1 z"  fill="lightgray" filter="url(#f1)" />', '<path d="m 21.6 38.6 L 47.1 64.3 L 22 89.5 L 38.4 106.2 L 64 81 L 89.3 106.2 L 105.8 89.5 L 80.6 64 L 105.8 38.9 L 89.3 22.2 L 64 47.5  L 38.3 22.1 z" style="fill:#ffffff; stroke:#004a82; stroke-width:4px; stroke-linejoin:round;" />', title);
  }
  static MoveToRightIcon(size, shadow, semitransparent, addIcon, deleteIcon, title) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<rect x="12" y="52" width="4"  height="24" fill="lightgray" filter="url(#f1)" /><rect x="20" y="52" width="8"  height="24" fill="lightgray" filter="url(#f1)" /><rect x="56" y="16" width="16"  height="96" fill="lightgray" filter="url(#f1)" /><path d="m  32 52 L 32 76 L 56 76 L 56 96 L 88 64 L 56 32 L 56 52 z" fill="lightgray" filter="url(#f1)" />', '<rect x="12" y="52" width="4"  height="24" style="fill:#ffffff; stroke:#004a82; stroke-width:4px; stroke-linejoin:round;" /><rect x="20" y="52" width="8"  height="24" style="fill:#ffffff; stroke:#004a82; stroke-width:4px; stroke-linejoin:round;" /><rect x="96" y="16" width="16"  height="96" style="fill:#ffffff; stroke:#004a82; stroke-width:4px; stroke-linejoin:round;" /><path d="m  32 52 L 32 76 L 56 76 L 56 96 L 88 64 L 56 32 L 56 52 z" style="fill:#ffffff; stroke:#004a82; stroke-width:4px; stroke-linejoin:round;" />', title);
  }
  static MoveToLeftIcon(size, shadow, semitransparent, addIcon, deleteIcon, title) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<rect x="112" y="52" width="4"  height="24" fill="lightgray" filter="url(#f1)" /><rect x="100" y="52" width="8"  height="24" fill="lightgray" filter="url(#f1)" /><rect x="16" y="16" width="16"  height="96" fill="lightgray" filter="url(#f1)" /><path d="m  96 52 L 96 76 L 72 76 L 72 96 L 40 64 L 72 32 L 72 52 z" fill="lightgray" filter="url(#f1)" />', '<rect x="112" y="52" width="4"  height="24" style="fill:#ffffff; stroke:#004a82; stroke-width:4px; stroke-linejoin:round;" /><rect x="100" y="52" width="8"  height="24" style="fill:#ffffff; stroke:#004a82; stroke-width:4px; stroke-linejoin:round;" /><rect x="16" y="16" width="16"  height="96" style="fill:#ffffff; stroke:#004a82; stroke-width:4px; stroke-linejoin:round;" /><path d="m  96 52 L 96 76 L 72 76 L 72 96 L 40 64 L 72 32 L 72 52 z" style="fill:#ffffff; stroke:#004a82; stroke-width:4px; stroke-linejoin:round;" />', title);
  }
  static ExpandIcon(size, shadow, semitransparent, addIcon, deleteIcon, title) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="m  24 56 L 24 72 L 56 72 L 56 104 L 72 104 L 72 72 L 104 72 L 104 56 L 72 56 L 72 24 L 56 24 L 56 56 z"  fill="lightgray" filter="url(#f1)" />', '<path d="m 24 56 L 24 72 L 56 72 L 56 104 L 72 104 L 72 72 L 104 72 L 104 56 L 72 56 L 72 24 L 56 24 L 56 56  z" style="fill:black; " />', title);
  }
  static OkIcon(size, shadow, semitransparent, addIcon, deleteIcon, title) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<circle cx="64" cy="64" r="56"   fill="lightgray" filter="url(#f1)" />', '<circle cx="64" cy="64" r="56" fill="#00b20f"/><path d="m 19 72 L 34 87 L 60 62 L 94 96 L 109 81 L 60 32  z" style="fill:white; " />', title);
  }
  static FailedIcon(size, shadow, semitransparent, addIcon, deleteIcon, title) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<circle cx="64" cy="64" r="56"   fill="lightgray" filter="url(#f1)" />', '<circle cx="64" cy="64" r="56" fill="#ff101e"/><path d="m 43 99 L 64 79 L 85 99 L 100 85 L 79 64 L 100 43 L 85 28 L 64 49 L 43 28 L 28  43 L 49 64 L  28 85   z" style="fill:white; " />', title);
  }
  static DontKnowIcon(size, shadow, semitransparent, addIcon, deleteIcon, title) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<circle cx="64" cy="64" r="56"   fill="lightgray" filter="url(#f1)" />', '<circle cx="64" cy="64" r="56" fill="#f1ba00"/><text x="35" y="-30" fill="white" transform="scale(1,-1)" style="font: bold 96px sans-serif;">?</text> ', title);
  }
  static infoIcon(size, shadow, semitransparent, addIcon, deleteIcon, title) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<circle cx="64" cy="64" r="56"   fill="lightgray" filter="url(#f1)" />', '<circle cx="64" cy="64" r="56" fill="DodgerBlue"/><text x="50" y="-30" fill="white" transform="scale(1,-1)" style="font: bold 96px sans-serif;">i</text> ', title);
  }
  static ColapseIcon(size, shadow, semitransparent, addIcon, deleteIcon, title) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, '<path d="m 24 56 L 24 72 L 104 72 L 104 56 z"  fill="lightgray" filter="url(#f1)" />', '<path d="m 24 56 L 24 72 L 104 72 L 104 56 z" style="fill:black; " />', title);
  }
  static AddMarkerIcon(size, index) {
    return ressources.IconSourceCode(size, false, false, false, false, "", '<circle  cx="64" cy="64"  r="50"   style="fill:lightyellow;" stroke-width="8" stroke="darkred" /><text x="46" y="-40" fill="black" transform="scale(1,-1)" style="font: bold 64px sans-serif;">' + index.toString() + "</text>");
  }
  static AddMarker(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, "", '<line x1="80" y1="8" x2="80" y2="128" stroke="darkred" stroke-width="8" stroke-linecap="round" /><path d="m 60 64 L 100 64 L 80 20 z" style="fill:darkred; " /><rect x="40" y="56" width="80" height="32" style="fill:lightYellow" stroke="darkred" stroke-width="8" />');
  }
  static EraseDatalogger(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, "", '<g transform="rotate(-35,0,0)"><g transform="translate(-56,24)"><path d="m 108 24 L 108 46 L 60 46  A 22 22 0 1 0 60 90 L 108 90  L 108 112 L 60 112 A 44 44 0 1 1 60 24 z" style="fill:#808080; " /><rect x="88" y="24" width="20" height="22" style="fill:red" stroke="none"  /><rect x="88" y="90" width="20" height="22" style="fill:blue" stroke="none"  /><path d="m 108 24 L 108 46 L 60 46  A 22 22 0 1 0 60 90 L 108 90  L 108 112 L 60 112 A 44 44 0 1 1 60 24 z"  style="fill:none" stroke="black"  stroke-width="4" stroke-linejoin="round"/></g></g>');
  }
  static resetViewPort(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, "", '<line x1="116" y1="52" x2="116" y2="12"  stroke="black"  stroke-width="4"/><line x1="12" y1="52" x2="12" y2="12"  stroke="black"  stroke-width="4"/><path d="m 100 36 L 28 36 L 28 48 L 12 32  L 28 16 L 28 28 L 100 28 L 100 16 L 116 32 L 100 48z" style="fill:white" stroke="black"  stroke-width="4" stroke-linejoin="round" /><path d="m 7.3 97.7 L 20 107.4 L 51.6 114.7 L 78.5 112.2 L 101.6 103.3 L 114.4 91.7  L 117.7 81.7 L 104.3 66.9 L 80.9 61.2 L49.9 65 L 25 76.3 L 12.6 87.5 Z " style="fill:white" stroke="none" /><circle  cx="64" cy="88" r="27" style="fill:#6cc87b" stroke="none"  /> <path d="m 37.2 84.8 A 27 27 0 0 0 46.5 108.8 L 64 88 z" style="fill:#8ed698" stroke="none" /> <circle  cx="64" cy="88" r="16" style="fill:black" stroke="none"  /> <path d="m 6 97 A 59 34 -4 0 0 119 80" style="fill:none" stroke="black"  stroke-width="4"  stroke-linecap="round"/> <path d="m 113 79 A 56 31 -16 0 0 9 93 " style="fill:none" stroke="black"  stroke-width="4"  stroke-linecap="round" /> ');
  }
  static DeleteMarker(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, "", '<line x1="80" y1="8" x2="80" y2="128" stroke="darkred" stroke-width="8" stroke-linecap="round" /><path d="m 60 64 L 100 64 L 80 20 z" style="fill:darkred; " /><rect x="40" y="56" width="80" height="32" style="fill:lightYellow" stroke="darkred" stroke-width="8" />');
  }
  static targetIcon(size, shadow, semitransparent, addIcon, deleteIcon, title) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, "", '<circle  cx="64" cy="64"  r="42"   style="fill:none;" stroke-width="8" stroke="black" /><line  x1="0"   y1="64"  x2="42"  y2="64"  style="fill:none;" stroke-width="8" stroke="black" /><line  x1="128" y1="64"  x2="86"  y2="64"  style="fill:none;" stroke-width="8" stroke="black" /><line  y1="0"   x1="64"  y2="42"  x2="64"  style="fill:none;" stroke-width="8" stroke="black" /><line  y1="128" x1="64"  y2="86"  x2="64"  style="fill:none;" stroke-width="8" stroke="black" />', title);
  }
  static DotDotDotIcon(size, shadow, semitransparent, addIcon, deleteIcon, title) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, "", '<rect x="18" y="36" width="18" height="18" style="fill:black" /><rect x="54" y="36" width="18" height="18" style="fill:black" /><rect x="90" y="36" width="18" height="18" style="fill:black" />', title);
  }
  static LogFileIcon(size, shadow, semitransparent, addIcon, deleteIcon) {
    return ressources.IconSourceCode(size, shadow, semitransparent, addIcon, deleteIcon, "", '<line x1="4" y1="24" x2="30" y2="24"     style=" stroke:black; stroke-width:8px;" /><line x1="34" y1="24" x2="56" y2="24"    style=" stroke:black; stroke-width:8px; " /><line x1="64" y1="24" x2="74" y2="24"    style=" stroke:black; stroke-width:8px; " /><line x1="80" y1="24" x2="88" y2="24"    style=" stroke:black; stroke-width:8px; " /><line x1="4" y1="40" x2="30" y2="40"     style=" stroke:black; stroke-width:8px;" /><line x1="34" y1="40" x2="56" y2="40"    style=" stroke:black; stroke-width:8px; " /><line x1="61" y1="40" x2="90" y2="40"    style=" stroke:black; stroke-width:8px; " /><line x1="94" y1="40" x2="110" y2="40"    style=" stroke:black; stroke-width:8px; " /><line x1="4" y1="56" x2="30" y2="56"     style=" stroke:black; stroke-width:8px;" /><line x1="34" y1="56" x2="56" y2="56"    style=" stroke:black; stroke-width:8px; " /><line x1="61" y1="56" x2="86" y2="56"    style=" stroke:black; stroke-width:8px; " /><line x1="4" y1="72" x2="30" y2="72"     style=" stroke:black; stroke-width:8px;" /><line x1="34" y1="72" x2="50" y2="72"    style=" stroke:black; stroke-width:8px; " /><line x1="56" y1="72" x2="100" y2="72"    style=" stroke:black; stroke-width:8px; " /><line x1="4" y1="88" x2="30" y2="88"     style=" stroke:black; stroke-width:8px;" /><line x1="34" y1="88" x2="56" y2="88"    style=" stroke:black; stroke-width:8px; " /><line x1="61" y1="88" x2="72" y2="88"    style=" stroke:black; stroke-width:8px; " /><line x1="78" y1="88" x2="106" y2="88"    style=" stroke:black; stroke-width:8px; " />');
  }
};

// obj/full/Pako/utils/common.js
var utils_common = class {
  static flattenChunks(chunks) {
    let len = 0;
    for (let i = 0, l = chunks.length; i < l; i++) {
      len += chunks[i].length;
    }
    const result = new Uint8Array(len);
    for (let i = 0, pos = 0, l = chunks.length; i < l; i++) {
      let chunk = chunks[i];
      result.set(chunk, pos);
      pos += chunk.length;
    }
    return result;
  }
};

// obj/full/Pako/utils/strings.js
var Pako_strings = class {
  static _init() {
    try {
      String.fromCharCode.apply(null, new Uint8Array(1));
    } catch (__) {
      Pako_strings.STR_APPLY_UIA_OK = false;
    }
    for (let q = 0; q < 256; q++) {
      Pako_strings._utf8len[q] = q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1;
    }
    Pako_strings._utf8len[254] = Pako_strings._utf8len[254] = 1;
    return true;
  }
  static string2buf(str) {
    let buf;
    let c;
    let c2;
    let m_pos;
    let i;
    let str_len = str.length;
    let buf_len = 0;
    for (m_pos = 0; m_pos < str_len; m_pos++) {
      c = str.charCodeAt(m_pos);
      if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
        c2 = str.charCodeAt(m_pos + 1);
        if ((c2 & 64512) === 56320) {
          c = 65536 + (c - 55296 << 10) + (c2 - 56320);
          m_pos++;
        }
      }
      buf_len += c < 128 ? 1 : c < 2048 ? 2 : c < 65536 ? 3 : 4;
    }
    buf = new Uint8Array(buf_len);
    for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
      c = str.charCodeAt(m_pos);
      if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
        c2 = str.charCodeAt(m_pos + 1);
        if ((c2 & 64512) === 56320) {
          c = 65536 + (c - 55296 << 10) + (c2 - 56320);
          m_pos++;
        }
      }
      if (c < 128) {
        buf[i++] = c;
      } else if (c < 2048) {
        buf[i++] = 192 | c >>> 6;
        buf[i++] = 128 | c & 63;
      } else if (c < 65536) {
        buf[i++] = 224 | c >>> 12;
        buf[i++] = 128 | c >>> 6 & 63;
        buf[i++] = 128 | c & 63;
      } else {
        buf[i++] = 240 | c >>> 18;
        buf[i++] = 128 | c >>> 12 & 63;
        buf[i++] = 128 | c >>> 6 & 63;
        buf[i++] = 128 | c & 63;
      }
    }
    return buf;
  }
  static buf2binstring(buf, len) {
    let result = "";
    for (let i = 0; i < len; i++) {
      result += String.fromCharCode(buf[i]);
    }
    return result;
  }
  static buf2string(buf, max) {
    let i;
    let out;
    const len = max || buf.length;
    const utf16buf = new Array(len * 2);
    for (out = 0, i = 0; i < len; ) {
      let c = buf[i++];
      if (c < 128) {
        utf16buf[out++] = c;
        continue;
      }
      let c_len = Pako_strings._utf8len[c];
      if (c_len > 4) {
        utf16buf[out++] = 65533;
        i += c_len - 1;
        continue;
      }
      c &= c_len === 2 ? 31 : c_len === 3 ? 15 : 7;
      while (c_len > 1 && i < len) {
        c = c << 6 | buf[i++] & 63;
        c_len--;
      }
      if (c_len > 1) {
        utf16buf[out++] = 65533;
        continue;
      }
      if (c < 65536) {
        utf16buf[out++] = c;
      } else {
        c -= 65536;
        utf16buf[out++] = 55296 | c >> 10 & 1023;
        utf16buf[out++] = 56320 | c & 1023;
      }
    }
    return Pako_strings.buf2binstring(utf16buf, out);
  }
  static utf8border(buf, max) {
    max = max || buf.length;
    if (max > buf.length) {
      max = buf.length;
    }
    let pos = max - 1;
    while (pos >= 0 && (buf[pos] & 192) === 128) {
      pos--;
    }
    if (pos < 0) {
      return max;
    }
    if (pos === 0) {
      return max;
    }
    return pos + Pako_strings._utf8len[buf[pos]] > max ? pos : max;
  }
};
Pako_strings.STR_APPLY_UIA_OK = true;
Pako_strings._utf8len = new Uint8Array(256);
Pako_strings.initDone = Pako_strings._init();

// obj/full/Pako/deflate.js
var Pako_deflate_option = class {
  constructor(CustOption) {
    this.level = zlib_constants.Z_DEFAULT_COMPRESSION;
    this.method = zlib_constants.Z_DEFLATED;
    this.chunkSize = 16384;
    this.windowBits = 15;
    this.memLevel = 8;
    this.strategy = zlib_constants.Z_DEFAULT_STRATEGY;
    this.raw = false;
    this.gzip = false;
    this.header = null;
    this.dictionary = null;
    this.ignore_os = false;
    Pako_deflate_option.ApplyCustomOptions(this, CustOption);
  }
  static ApplyCustomOptions(StdOption, CustOption) {
    if (typeof CustOption != "undefined") {
      let stdKeys = Object.keys(StdOption);
      let custKeys = Object.keys(CustOption);
      for (let i = 0; i < custKeys.length; i++) {
        if (stdKeys.indexOf(custKeys[i]) < 0) {
          debugger;
          throw "Invalid Pako option name '" + custKeys[i] + "', check Pako_deflate_option class";
        }
        let srcType = typeof Reflect.get(CustOption, custKeys[i]);
        let trgtType = typeof Reflect.get(StdOption, custKeys[i]);
        if (srcType != trgtType)
          throw "Invalid Pako type for option '" + custKeys[i] + "' (expected '" + trgtType + "', got '" + srcType + "')";
        Reflect.set(StdOption, custKeys[i], Reflect.get(CustOption, custKeys[i]));
      }
    }
  }
};
var Pako_Deflate = class {
  constructor(options) {
    this._dict_set = false;
    this.result = null;
    this.options = new Pako_deflate_option(options);
    let opt = this.options;
    if (opt.raw && opt.windowBits > 0) {
      opt.windowBits = -opt.windowBits;
    } else if (opt.gzip && opt.windowBits > 0 && opt.windowBits < 16) {
      opt.windowBits += 16;
    }
    this.err = 0;
    this.msg = "";
    this.ended = false;
    this.chunks = [];
    this.strm = new zlib_ZStream();
    this.strm.avail_out = 0;
    let status = zlib_deflate.deflateInit2(this.strm, opt.level, opt.method, opt.windowBits, opt.memLevel, opt.strategy);
    if (status !== zlib_constants.Z_OK) {
      throw new Error(zlib_messages.msg(status));
    }
    if (opt.header) {
      zlib_deflate.deflateSetHeader(this.strm, opt.header);
    }
    if (opt.dictionary) {
      let dict;
      if (typeof opt.dictionary === "string") {
        dict = Pako_strings.string2buf(opt.dictionary);
      } else if (toString.call(opt.dictionary) === "[object ArrayBuffer]") {
        dict = new Uint8Array(opt.dictionary);
      } else {
        dict = opt.dictionary;
      }
      status = zlib_deflate.deflateSetDictionary(this.strm, dict);
      if (status !== zlib_constants.Z_OK) {
        throw new Error(zlib_messages.msg(status));
      }
      this._dict_set = true;
    }
  }
  push(data, flush_mode) {
    const strm = this.strm;
    const chunkSize = this.options.chunkSize;
    let status;
    let _flush_mode;
    if (this.ended) {
      return false;
    }
    if (flush_mode === ~~flush_mode) {
      _flush_mode = flush_mode;
    } else {
      _flush_mode = flush_mode === true ? zlib_constants.Z_FINISH : zlib_constants.Z_NO_FLUSH;
    }
    if (typeof data === "string") {
      strm.input = Pako_strings.string2buf(data);
    } else if (toString.call(data) === "[object ArrayBuffer]") {
      strm.input = new Uint8Array(data);
    } else {
      strm.input = data;
    }
    strm.next_in = 0;
    strm.avail_in = strm.input.length;
    for (; ; ) {
      if (strm.avail_out === 0) {
        strm.output = new Uint8Array(chunkSize);
        strm.next_out = 0;
        strm.avail_out = chunkSize;
      }
      if ((_flush_mode === zlib_constants.Z_SYNC_FLUSH || _flush_mode === zlib_constants.Z_FULL_FLUSH) && strm.avail_out <= 6) {
        this.onData(strm.output.subarray(0, strm.next_out));
        strm.avail_out = 0;
        continue;
      }
      status = zlib_deflate.deflate(strm, _flush_mode);
      if (status === zlib_constants.Z_STREAM_END) {
        if (strm.next_out > 0) {
          this.onData(strm.output.subarray(0, strm.next_out));
        }
        status = zlib_deflate.deflateEnd(this.strm);
        this.onEnd(status);
        this.ended = true;
        return status === zlib_constants.Z_OK;
      }
      if (strm.avail_out === 0) {
        this.onData(strm.output);
        continue;
      }
      if (_flush_mode > 0 && strm.next_out > 0) {
        this.onData(strm.output.subarray(0, strm.next_out));
        strm.avail_out = 0;
        continue;
      }
      if (strm.avail_in === 0)
        break;
    }
    return true;
  }
  onData(chunk) {
    this.chunks.push(chunk);
  }
  onEnd(status) {
    if (status === zlib_constants.Z_OK) {
      this.result = utils_common.flattenChunks(this.chunks);
    }
    this.chunks = [];
    this.err = status;
    this.msg = this.strm.msg;
  }
  static deflate(input, options) {
    const deflator = new Pako_Deflate(options);
    deflator.push(input, true);
    if (deflator.err) {
      throw deflator.msg || zlib_messages.msg(deflator.err);
    }
    return deflator.result;
  }
  static deflateRaw(input, options) {
    options.raw = true;
    return Pako_Deflate.deflate(input, options);
  }
  static gzip(input, options) {
    if (typeof options == "undefined")
      options = {};
    options.gzip = true;
    return Pako_Deflate.deflate(input, options);
  }
};

// obj/full/Pako/inflate.js
var Pako_inflate_option = class {
  constructor(CustOption) {
    this.chunkSize = 1024 * 64;
    this.windowBits = 15;
    this.to = "";
    this.raw = false;
    this.dictionary = null;
    Pako_inflate_option.ApplyCustomOptions(this, CustOption);
  }
  static ApplyCustomOptions(StdOption, CustOption) {
    if (typeof CustOption != "undefined") {
      let stdKeys = Object.keys(StdOption);
      let custKeys = Object.keys(CustOption);
      for (let i = 0; i < custKeys.length; i++) {
        if (stdKeys.indexOf(custKeys[i]) < 0)
          throw "Invalid Pako option name '" + custKeys[i] + "', check Pako_inflate_option class";
        let srcType = typeof Reflect.get(CustOption, custKeys[i]);
        let trgtType = typeof Reflect.get(StdOption, custKeys[i]);
        if (srcType != trgtType) {
          throw "Invalid Pako type for option '" + custKeys[i] + "' (expected '" + trgtType + "', got '" + srcType + "')";
        }
        Reflect.set(StdOption, custKeys[i], Reflect.get(CustOption, custKeys[i]));
      }
    }
  }
};
var Pako_Inflate = class {
  constructor(options) {
    this.err = 0;
    this.msg = "";
    this.ended = false;
    this.result = null;
    this.options = new Pako_inflate_option(options);
    const opt = this.options;
    if (opt.raw && opt.windowBits >= 0 && opt.windowBits < 16) {
      opt.windowBits = -opt.windowBits;
      if (opt.windowBits === 0) {
        opt.windowBits = -15;
      }
    }
    if (opt.windowBits >= 0 && opt.windowBits < 16 && !(options && options.windowBits)) {
      opt.windowBits += 32;
    }
    if (opt.windowBits > 15 && opt.windowBits < 48) {
      if ((opt.windowBits & 15) === 0) {
        opt.windowBits |= 15;
      }
    }
    this.err = 0;
    this.msg = "";
    this.ended = false;
    this.chunks = [];
    this.strm = new zlib_ZStream();
    this.strm.avail_out = 0;
    let status = zlib_inflate.inflateInit2(this.strm, opt.windowBits);
    if (status !== zlib_constants.Z_OK) {
      throw new Error(zlib_messages.msg(status));
    }
    this.header = new zlib_GZheader();
    zlib_inflate.inflateGetHeader(this.strm, this.header);
    if (opt.dictionary) {
      if (typeof opt.dictionary === "string") {
        opt.dictionary = Pako_strings.string2buf(opt.dictionary);
      } else if (toString.call(opt.dictionary) === "[object ArrayBuffer]") {
        opt.dictionary = new Uint8Array(opt.dictionary);
      }
      if (opt.raw) {
        status = zlib_inflate.inflateSetDictionary(this.strm, opt.dictionary);
        if (status !== zlib_constants.Z_OK) {
          throw new Error(zlib_messages.msg(status));
        }
      }
    }
  }
  push(data, flush_mode) {
    const strm = this.strm;
    const chunkSize = this.options.chunkSize;
    const dictionary = this.options.dictionary;
    let status;
    let _flush_mode;
    let last_avail_out;
    if (this.ended)
      return false;
    if (flush_mode === ~~flush_mode) {
      _flush_mode = flush_mode;
    } else {
      _flush_mode = flush_mode === true ? zlib_constants.Z_FINISH : zlib_constants.Z_NO_FLUSH;
    }
    if (toString.call(data) === "[object ArrayBuffer]") {
      strm.input = new Uint8Array(data);
    } else {
      strm.input = data;
    }
    strm.next_in = 0;
    strm.avail_in = strm.input.length;
    for (; ; ) {
      if (strm.avail_out === 0) {
        strm.output = new Uint8Array(chunkSize);
        strm.next_out = 0;
        strm.avail_out = chunkSize;
      }
      status = zlib_inflate.inflate(strm, _flush_mode);
      if (status === zlib_constants.Z_NEED_DICT && dictionary) {
        status = zlib_inflate.inflateSetDictionary(strm, dictionary);
        if (status === zlib_constants.Z_OK) {
          status = zlib_inflate.inflate(strm, _flush_mode);
        } else if (status === zlib_constants.Z_DATA_ERROR) {
          status = zlib_constants.Z_NEED_DICT;
        }
      }
      while (strm.avail_in > 0 && status === zlib_constants.Z_STREAM_END && strm.state.wrap > 0 && data[strm.next_in] !== 0) {
        zlib_inflate.inflateReset(strm);
        status = zlib_inflate.inflate(strm, _flush_mode);
      }
      switch (status) {
        case zlib_constants.Z_STREAM_ERROR:
        case zlib_constants.Z_DATA_ERROR:
        case zlib_constants.Z_NEED_DICT:
        case zlib_constants.Z_MEM_ERROR:
          this.onEnd(status);
          this.ended = true;
          return false;
      }
      last_avail_out = strm.avail_out;
      if (strm.next_out) {
        if (strm.avail_out === 0 || status === zlib_constants.Z_STREAM_END) {
          if (this.options.to === "string") {
            let next_out_utf8 = Pako_strings.utf8border(strm.output, strm.next_out);
            let tail = strm.next_out - next_out_utf8;
            let utf8str = Pako_strings.buf2string(strm.output, next_out_utf8);
            strm.next_out = tail;
            strm.avail_out = chunkSize - tail;
            if (tail)
              strm.output.set(strm.output.subarray(next_out_utf8, next_out_utf8 + tail), 0);
            this.onData(utf8str);
          } else {
            this.onData(strm.output.length === strm.next_out ? strm.output : strm.output.subarray(0, strm.next_out));
          }
        }
      }
      if (status === zlib_constants.Z_OK && last_avail_out === 0)
        continue;
      if (status === zlib_constants.Z_STREAM_END) {
        status = zlib_inflate.inflateEnd(this.strm);
        this.onEnd(status);
        this.ended = true;
        return true;
      }
      if (strm.avail_in === 0)
        break;
    }
    return true;
  }
  onData(chunk) {
    this.chunks[this.chunks.length] = chunk;
  }
  onEnd(status) {
    if (status === zlib_constants.Z_OK) {
      if (this.options.to === "string") {
        this.result = this.chunks.join("");
      } else {
        this.result = utils_common.flattenChunks(this.chunks);
      }
    }
    this.chunks = [];
    this.err = status;
    this.msg = this.strm.msg;
  }
  static inflate(input, options) {
    const inflator = new Pako_Inflate(options);
    inflator.push(input, false);
    if (inflator.err)
      throw inflator.msg || zlib_messages.msg(inflator.err);
    return inflator.result;
  }
  inflateRaw(input, options) {
    options.raw = true;
    return Pako_Inflate.inflate(input, options);
  }
  static ungzip(input, options) {
    return Pako_Inflate.inflate(input, options);
  }
};

// obj/full/Pako/zlib/adler32.js
"use strict";
var zlib_adler32 = class {
  static adler32(adler, buf, len, pos) {
    let s1 = adler & 65535 | 0, s2 = adler >>> 16 & 65535 | 0, n = 0;
    while (len !== 0) {
      n = len > 2e3 ? 2e3 : len;
      len -= n;
      do {
        s1 = s1 + buf[pos++] | 0;
        s2 = s2 + s1 | 0;
      } while (--n);
      s1 %= 65521;
      s2 %= 65521;
    }
    return s1 | s2 << 16 | 0;
  }
};

// obj/full/Pako/zlib/constants.js
"use strict";
var zlib_constants = class {
};
zlib_constants.Z_NO_FLUSH = 0;
zlib_constants.Z_PARTIAL_FLUSH = 1;
zlib_constants.Z_SYNC_FLUSH = 2;
zlib_constants.Z_FULL_FLUSH = 3;
zlib_constants.Z_FINISH = 4;
zlib_constants.Z_BLOCK = 5;
zlib_constants.Z_TREES = 6;
zlib_constants.Z_OK = 0;
zlib_constants.Z_STREAM_END = 1;
zlib_constants.Z_NEED_DICT = 2;
zlib_constants.Z_ERRNO = -1;
zlib_constants.Z_STREAM_ERROR = -2;
zlib_constants.Z_DATA_ERROR = -3;
zlib_constants.Z_MEM_ERROR = -4;
zlib_constants.Z_BUF_ERROR = -5;
zlib_constants.Z_NO_COMPRESSION = 0;
zlib_constants.Z_BEST_SPEED = 1;
zlib_constants.Z_BEST_COMPRESSION = 9;
zlib_constants.Z_DEFAULT_COMPRESSION = -1;
zlib_constants.Z_FILTERED = 1;
zlib_constants.Z_HUFFMAN_ONLY = 2;
zlib_constants.Z_RLE = 3;
zlib_constants.Z_FIXED = 4;
zlib_constants.Z_DEFAULT_STRATEGY = 0;
zlib_constants.Z_BINARY = 0;
zlib_constants.Z_TEXT = 1;
zlib_constants.Z_UNKNOWN = 2;
zlib_constants.Z_DEFLATED = 8;

// obj/full/Pako/zlib/crc32.js
"use strict";
var zlib_crc32 = class {
  static makeTable() {
    let c;
    let table = new Int32Array(256);
    for (let n = 0; n < 256; n++) {
      c = n;
      for (let k = 0; k < 8; k++) {
        c = c & 1 ? 3988292384 ^ c >>> 1 : c >>> 1;
      }
      table[n] = c;
    }
    return table;
  }
  static crc32(crc, buf, len, pos) {
    let t = zlib_crc32.crcTable;
    let end = pos + len;
    crc ^= -1;
    for (let i = pos; i < end; i++) {
      crc = crc >>> 8 ^ t[(crc ^ buf[i]) & 255];
    }
    return crc ^ -1;
  }
};
zlib_crc32.crcTable = zlib_crc32.makeTable();

// obj/full/Pako/zlib/deflate.js
"use strict";
var zlib_config = class {
  constructor(good_length, max_lazy, nice_length, max_chain, func) {
    this.good_length = good_length;
    this.max_lazy = max_lazy;
    this.nice_length = nice_length;
    this.max_chain = max_chain;
    this.func = func;
  }
};
var zlib_DeflateState = class {
  constructor() {
    this.strm = null;
    this.status = 0;
    this.pending_buf = null;
    this.pending_buf_size = 0;
    this.pending_out = 0;
    this.pending = 0;
    this.wrap = 0;
    this.gzhead = null;
    this.gzindex = 0;
    this.method = zlib_constants.Z_DEFLATED;
    this.last_flush = -1;
    this.w_size = 0;
    this.w_bits = 0;
    this.w_mask = 0;
    this.window = null;
    this.window_size = 0;
    this.prev = null;
    this.head = null;
    this.ins_h = 0;
    this.hash_size = 0;
    this.hash_bits = 0;
    this.hash_mask = 0;
    this.hash_shift = 0;
    this.block_start = 0;
    this.match_length = 0;
    this.prev_match = 0;
    this.match_available = 0;
    this.strstart = 0;
    this.match_start = 0;
    this.lookahead = 0;
    this.prev_length = 0;
    this.max_chain_length = 0;
    this.max_lazy_match = 0;
    this.level = 0;
    this.strategy = 0;
    this.good_match = 0;
    this.nice_match = 0;
    this.dyn_ltree = new Uint16Array(zlib_Pako_trees.HEAP_SIZE * 2);
    this.dyn_dtree = new Uint16Array((2 * zlib_Pako_trees.D_CODES + 1) * 2);
    this.bl_tree = new Uint16Array((2 * zlib_Pako_trees.BL_CODES + 1) * 2);
    this.l_desc = null;
    this.d_desc = null;
    this.bl_desc = null;
    this.bl_count = new Uint16Array(zlib_Pako_trees.MAX_BITS + 1);
    this.heap = new Uint16Array(2 * zlib_Pako_trees.L_CODES + 1);
    this.heap_len = 0;
    this.heap_max = 0;
    this.depth = new Uint16Array(2 * zlib_Pako_trees.L_CODES + 1);
    this.l_buf = 0;
    this.lit_bufsize = 0;
    this.last_lit = 0;
    this.d_buf = 0;
    this.opt_len = 0;
    this.static_len = 0;
    this.matches = 0;
    this.insert = 0;
    this.bi_buf = 0;
    this.bi_valid = 0;
    zlib_Pako_trees.zero(this.dyn_ltree);
    zlib_Pako_trees.zero(this.dyn_dtree);
    zlib_Pako_trees.zero(this.bl_tree);
    zlib_Pako_trees.zero(this.heap);
    zlib_Pako_trees.zero(this.depth);
  }
};
var zlib_deflate = class {
  static err(strm, errorCode) {
    strm.msg = zlib_messages.msg(errorCode);
    return errorCode;
  }
  static rank(f) {
    return (f << 1) - (f > 4 ? 9 : 0);
  }
  zero(buf) {
    let len = buf.length;
    while (--len >= 0) {
      buf[len] = 0;
    }
  }
  static HASH_ZLIB(s, prev, data) {
    return (prev << s.hash_shift ^ data) & s.hash_mask;
  }
  static HASH(s, prev, data) {
    return (prev << s.hash_shift ^ data) & s.hash_mask;
  }
  static flush_pending(strm) {
    const s = strm.state;
    let len = s.pending;
    if (len > strm.avail_out) {
      len = strm.avail_out;
    }
    if (len === 0) {
      return;
    }
    strm.output.set(s.pending_buf.subarray(s.pending_out, s.pending_out + len), strm.next_out);
    strm.next_out += len;
    s.pending_out += len;
    strm.total_out += len;
    strm.avail_out -= len;
    s.pending -= len;
    if (s.pending === 0) {
      s.pending_out = 0;
    }
  }
  static flush_block_only(s, last) {
    zlib_Pako_trees._tr_flush_block(s, s.block_start >= 0 ? s.block_start : -1, s.strstart - s.block_start, last);
    s.block_start = s.strstart;
    zlib_deflate.flush_pending(s.strm);
  }
  static put_byte(s, b) {
    s.pending_buf[s.pending++] = b;
  }
  static putShortMSB(s, b) {
    s.pending_buf[s.pending++] = b >>> 8 & 255;
    s.pending_buf[s.pending++] = b & 255;
  }
  static read_buf(strm, buf, start, size) {
    let len = strm.avail_in;
    if (len > size) {
      len = size;
    }
    if (len === 0) {
      return 0;
    }
    strm.avail_in -= len;
    buf.set(strm.input.subarray(strm.next_in, strm.next_in + len), start);
    if (strm.state.wrap === 1) {
      strm.adler = zlib_adler32.adler32(strm.adler, buf, len, start);
    } else if (strm.state.wrap === 2) {
      strm.adler = zlib_crc32.crc32(strm.adler, buf, len, start);
    }
    strm.next_in += len;
    strm.total_in += len;
    return len;
  }
  static longest_match(s, cur_match) {
    let chain_length = s.max_chain_length;
    let scan = s.strstart;
    let match;
    let len;
    let best_len = s.prev_length;
    let nice_match = s.nice_match;
    const limit = s.strstart > s.w_size - zlib_deflate.MIN_LOOKAHEAD ? s.strstart - (s.w_size - zlib_deflate.MIN_LOOKAHEAD) : 0;
    const _win = s.window;
    const wmask = s.w_mask;
    const prev = s.prev;
    const strend = s.strstart + zlib_Pako_trees.MAX_MATCH;
    let scan_end1 = _win[scan + best_len - 1];
    let scan_end = _win[scan + best_len];
    if (s.prev_length >= s.good_match) {
      chain_length >>= 2;
    }
    if (nice_match > s.lookahead) {
      nice_match = s.lookahead;
    }
    do {
      match = cur_match;
      if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1]) {
        continue;
      }
      scan += 2;
      match++;
      do {
      } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend);
      len = zlib_Pako_trees.MAX_MATCH - (strend - scan);
      scan = strend - zlib_Pako_trees.MAX_MATCH;
      if (len > best_len) {
        s.match_start = cur_match;
        best_len = len;
        if (len >= nice_match) {
          break;
        }
        scan_end1 = _win[scan + best_len - 1];
        scan_end = _win[scan + best_len];
      }
    } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);
    if (best_len <= s.lookahead) {
      return best_len;
    }
    return s.lookahead;
  }
  static fill_window(s) {
    const _w_size = s.w_size;
    let p;
    let n;
    let m;
    let more;
    let str;
    do {
      more = s.window_size - s.lookahead - s.strstart;
      if (s.strstart >= _w_size + (_w_size - zlib_deflate.MIN_LOOKAHEAD)) {
        s.window.set(s.window.subarray(_w_size, _w_size + _w_size), 0);
        s.match_start -= _w_size;
        s.strstart -= _w_size;
        s.block_start -= _w_size;
        n = s.hash_size;
        p = n;
        do {
          m = s.head[--p];
          s.head[p] = m >= _w_size ? m - _w_size : 0;
        } while (--n);
        n = _w_size;
        p = n;
        do {
          m = s.prev[--p];
          s.prev[p] = m >= _w_size ? m - _w_size : 0;
        } while (--n);
        more += _w_size;
      }
      if (s.strm.avail_in === 0) {
        break;
      }
      n = zlib_deflate.read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
      s.lookahead += n;
      if (s.lookahead + s.insert >= zlib_Pako_trees.MIN_MATCH) {
        str = s.strstart - s.insert;
        s.ins_h = s.window[str];
        s.ins_h = zlib_deflate.HASH(s, s.ins_h, s.window[str + 1]);
        while (s.insert) {
          s.ins_h = zlib_deflate.HASH(s, s.ins_h, s.window[str + zlib_Pako_trees.MIN_MATCH - 1]);
          s.prev[str & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = str;
          str++;
          s.insert--;
          if (s.lookahead + s.insert < zlib_Pako_trees.MIN_MATCH) {
            break;
          }
        }
      }
    } while (s.lookahead < zlib_deflate.MIN_LOOKAHEAD && s.strm.avail_in !== 0);
  }
  static deflate_stored(s, flush) {
    let max_block_size = 65535;
    if (max_block_size > s.pending_buf_size - 5) {
      max_block_size = s.pending_buf_size - 5;
    }
    for (; ; ) {
      if (s.lookahead <= 1) {
        zlib_deflate.fill_window(s);
        if (s.lookahead === 0 && flush === zlib_constants.Z_NO_FLUSH) {
          return zlib_deflate.BS_NEED_MORE;
        }
        if (s.lookahead === 0) {
          break;
        }
      }
      s.strstart += s.lookahead;
      s.lookahead = 0;
      const max_start = s.block_start + max_block_size;
      if (s.strstart === 0 || s.strstart >= max_start) {
        s.lookahead = s.strstart - max_start;
        s.strstart = max_start;
        zlib_deflate.flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return zlib_deflate.BS_NEED_MORE;
        }
      }
      if (s.strstart - s.block_start >= s.w_size - zlib_deflate.MIN_LOOKAHEAD) {
        zlib_deflate.flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return zlib_deflate.BS_NEED_MORE;
        }
      }
    }
    s.insert = 0;
    if (flush === zlib_constants.Z_FINISH) {
      zlib_deflate.flush_block_only(s, true);
      if (s.strm.avail_out === 0) {
        return zlib_deflate.BS_FINISH_STARTED;
      }
      return zlib_deflate.BS_FINISH_DONE;
    }
    if (s.strstart > s.block_start) {
      zlib_deflate.flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return zlib_deflate.BS_NEED_MORE;
      }
    }
    return zlib_deflate.BS_NEED_MORE;
  }
  static deflate_slow(s, flush) {
    let hash_head;
    let bflush;
    let max_insert;
    for (; ; ) {
      if (s.lookahead < zlib_deflate.MIN_LOOKAHEAD) {
        zlib_deflate.fill_window(s);
        if (s.lookahead < zlib_deflate.MIN_LOOKAHEAD && flush === zlib_constants.Z_NO_FLUSH) {
          return zlib_deflate.BS_NEED_MORE;
        }
        if (s.lookahead === 0) {
          break;
        }
      }
      hash_head = 0;
      if (s.lookahead >= zlib_Pako_trees.MIN_MATCH) {
        s.ins_h = zlib_deflate.HASH(s, s.ins_h, s.window[s.strstart + zlib_Pako_trees.MIN_MATCH - 1]);
        hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
        s.head[s.ins_h] = s.strstart;
      }
      s.prev_length = s.match_length;
      s.prev_match = s.match_start;
      s.match_length = zlib_Pako_trees.MIN_MATCH - 1;
      if (hash_head !== 0 && s.prev_length < s.max_lazy_match && s.strstart - hash_head <= s.w_size - zlib_deflate.MIN_LOOKAHEAD) {
        s.match_length = zlib_deflate.longest_match(s, hash_head);
        if (s.match_length <= 5 && (s.strategy === zlib_constants.Z_FILTERED || s.match_length === zlib_Pako_trees.MIN_MATCH && s.strstart - s.match_start > 4096)) {
          s.match_length = zlib_Pako_trees.MIN_MATCH - 1;
        }
      }
      if (s.prev_length >= zlib_Pako_trees.MIN_MATCH && s.match_length <= s.prev_length) {
        max_insert = s.strstart + s.lookahead - zlib_Pako_trees.MIN_MATCH;
        bflush = zlib_Pako_trees._tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - zlib_Pako_trees.MIN_MATCH);
        s.lookahead -= s.prev_length - 1;
        s.prev_length -= 2;
        do {
          if (++s.strstart <= max_insert) {
            s.ins_h = zlib_deflate.HASH(s, s.ins_h, s.window[s.strstart + zlib_Pako_trees.MIN_MATCH - 1]);
            hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
            s.head[s.ins_h] = s.strstart;
          }
        } while (--s.prev_length !== 0);
        s.match_available = 0;
        s.match_length = zlib_Pako_trees.MIN_MATCH - 1;
        s.strstart++;
        if (bflush) {
          zlib_deflate.flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return zlib_deflate.BS_NEED_MORE;
          }
        }
      } else if (s.match_available) {
        bflush = zlib_Pako_trees._tr_tally(s, 0, s.window[s.strstart - 1]);
        if (bflush) {
          zlib_deflate.flush_block_only(s, false);
        }
        s.strstart++;
        s.lookahead--;
        if (s.strm.avail_out === 0) {
          return zlib_deflate.BS_NEED_MORE;
        }
      } else {
        s.match_available = 1;
        s.strstart++;
        s.lookahead--;
      }
    }
    if (s.match_available) {
      bflush = zlib_Pako_trees._tr_tally(s, 0, s.window[s.strstart - 1]);
      s.match_available = 0;
    }
    s.insert = s.strstart < zlib_Pako_trees.MIN_MATCH - 1 ? s.strstart : zlib_Pako_trees.MIN_MATCH - 1;
    if (flush === zlib_constants.Z_FINISH) {
      zlib_deflate.flush_block_only(s, true);
      if (s.strm.avail_out === 0) {
        return zlib_deflate.BS_FINISH_STARTED;
      }
      return zlib_deflate.BS_FINISH_DONE;
    }
    if (s.last_lit) {
      zlib_deflate.flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return zlib_deflate.BS_NEED_MORE;
      }
    }
    return zlib_deflate.BS_BLOCK_DONE;
  }
  static deflate_rle(s, flush) {
    let bflush;
    let prev;
    let scan;
    let strend;
    const _win = s.window;
    for (; ; ) {
      if (s.lookahead <= zlib_Pako_trees.MAX_MATCH) {
        zlib_deflate.fill_window(s);
        if (s.lookahead <= zlib_Pako_trees.MAX_MATCH && flush === zlib_constants.Z_NO_FLUSH) {
          return zlib_deflate.BS_NEED_MORE;
        }
        if (s.lookahead === 0) {
          break;
        }
      }
      s.match_length = 0;
      if (s.lookahead >= zlib_Pako_trees.MIN_MATCH && s.strstart > 0) {
        scan = s.strstart - 1;
        prev = _win[scan];
        if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
          strend = s.strstart + zlib_Pako_trees.MAX_MATCH;
          do {
          } while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);
          s.match_length = zlib_Pako_trees.MAX_MATCH - (strend - scan);
          if (s.match_length > s.lookahead) {
            s.match_length = s.lookahead;
          }
        }
      }
      if (s.match_length >= zlib_Pako_trees.MIN_MATCH) {
        bflush = zlib_Pako_trees._tr_tally(s, 1, s.match_length - zlib_Pako_trees.MIN_MATCH);
        s.lookahead -= s.match_length;
        s.strstart += s.match_length;
        s.match_length = 0;
      } else {
        bflush = zlib_Pako_trees._tr_tally(s, 0, s.window[s.strstart]);
        s.lookahead--;
        s.strstart++;
      }
      if (bflush) {
        zlib_deflate.flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return zlib_deflate.BS_NEED_MORE;
        }
      }
    }
    s.insert = 0;
    if (flush === zlib_constants.Z_FINISH) {
      zlib_deflate.flush_block_only(s, true);
      if (s.strm.avail_out === 0) {
        return zlib_deflate.BS_FINISH_STARTED;
      }
      return zlib_deflate.BS_FINISH_DONE;
    }
    if (s.last_lit) {
      zlib_deflate.flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return zlib_deflate.BS_NEED_MORE;
      }
    }
    return zlib_deflate.BS_BLOCK_DONE;
  }
  static deflate_huff(s, flush) {
    let bflush;
    for (; ; ) {
      if (s.lookahead === 0) {
        zlib_deflate.fill_window(s);
        if (s.lookahead === 0) {
          if (flush === zlib_constants.Z_NO_FLUSH) {
            return zlib_deflate.BS_NEED_MORE;
          }
          break;
        }
      }
      s.match_length = 0;
      bflush = zlib_Pako_trees._tr_tally(s, 0, s.window[s.strstart]);
      s.lookahead--;
      s.strstart++;
      if (bflush) {
        zlib_deflate.flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return zlib_deflate.BS_NEED_MORE;
        }
      }
    }
    s.insert = 0;
    if (flush === zlib_constants.Z_FINISH) {
      zlib_deflate.flush_block_only(s, true);
      if (s.strm.avail_out === 0) {
        return zlib_deflate.BS_FINISH_STARTED;
      }
      return zlib_deflate.BS_FINISH_DONE;
    }
    if (s.last_lit) {
      zlib_deflate.flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return zlib_deflate.BS_NEED_MORE;
      }
    }
    return zlib_deflate.BS_BLOCK_DONE;
  }
  static lm_init(s) {
    s.window_size = 2 * s.w_size;
    zlib_Pako_trees.zero(s.head);
    s.max_lazy_match = zlib_deflate.configuration_table[s.level].max_lazy;
    s.good_match = zlib_deflate.configuration_table[s.level].good_length;
    s.nice_match = zlib_deflate.configuration_table[s.level].nice_length;
    s.max_chain_length = zlib_deflate.configuration_table[s.level].max_chain;
    s.strstart = 0;
    s.block_start = 0;
    s.lookahead = 0;
    s.insert = 0;
    s.match_length = s.prev_length = zlib_Pako_trees.MIN_MATCH - 1;
    s.match_available = 0;
    s.ins_h = 0;
  }
  static deflateResetKeep(strm) {
    if (!strm || !strm.state) {
      return zlib_deflate.err(strm, zlib_constants.Z_STREAM_ERROR);
    }
    strm.total_in = strm.total_out = 0;
    strm.data_type = zlib_constants.Z_UNKNOWN;
    let s = strm.state;
    s.pending = 0;
    s.pending_out = 0;
    if (s.wrap < 0) {
      s.wrap = -s.wrap;
    }
    s.status = s.wrap ? zlib_deflate.INIT_STATE : zlib_deflate.BUSY_STATE;
    strm.adler = s.wrap === 2 ? 0 : 1;
    s.last_flush = zlib_constants.Z_NO_FLUSH;
    zlib_Pako_trees._tr_init(s);
    return zlib_constants.Z_OK;
  }
  static deflateReset(strm) {
    const ret = zlib_deflate.deflateResetKeep(strm);
    if (ret === zlib_constants.Z_OK) {
      zlib_deflate.lm_init(strm.state);
    }
    return ret;
  }
  static deflateSetHeader(strm, head) {
    if (!strm || !strm.state) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    if (strm.state.wrap !== 2) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    strm.state.gzhead = head;
    return zlib_constants.Z_OK;
  }
  static deflateInit2(strm, level, method, windowBits, memLevel, strategy) {
    if (!strm) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    let wrap = 1;
    if (level === zlib_constants.Z_DEFAULT_COMPRESSION) {
      level = 6;
    }
    if (windowBits < 0) {
      wrap = 0;
      windowBits = -windowBits;
    } else if (windowBits > 15) {
      wrap = 2;
      windowBits -= 16;
    }
    if (memLevel < 1 || memLevel > zlib_deflate.MAX_MEM_LEVEL || method !== zlib_constants.Z_DEFLATED || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > zlib_constants.Z_FIXED) {
      return zlib_deflate.err(strm, zlib_constants.Z_STREAM_ERROR);
    }
    if (windowBits === 8) {
      windowBits = 9;
    }
    const s = new zlib_DeflateState();
    strm.state = s;
    s.strm = strm;
    s.wrap = wrap;
    s.gzhead = null;
    s.w_bits = windowBits;
    s.w_size = 1 << s.w_bits;
    s.w_mask = s.w_size - 1;
    s.hash_bits = memLevel + 7;
    s.hash_size = 1 << s.hash_bits;
    s.hash_mask = s.hash_size - 1;
    s.hash_shift = ~~((s.hash_bits + zlib_Pako_trees.MIN_MATCH - 1) / zlib_Pako_trees.MIN_MATCH);
    s.window = new Uint8Array(s.w_size * 2);
    s.head = new Uint16Array(s.hash_size);
    s.prev = new Uint16Array(s.w_size);
    s.lit_bufsize = 1 << memLevel + 6;
    s.pending_buf_size = s.lit_bufsize * 4;
    s.pending_buf = new Uint8Array(s.pending_buf_size);
    s.d_buf = 1 * s.lit_bufsize;
    s.l_buf = (1 + 2) * s.lit_bufsize;
    s.level = level;
    s.strategy = strategy;
    s.method = method;
    return zlib_deflate.deflateReset(strm);
  }
  static deflateInit(strm, level) {
    return zlib_deflate.deflateInit2(strm, level, zlib_constants.Z_DEFLATED, zlib_deflate.MAX_WBITS, zlib_deflate.DEF_MEM_LEVEL, zlib_constants.Z_DEFAULT_STRATEGY);
  }
  static deflate(strm, flush) {
    let beg, val;
    if (!strm || !strm.state || flush > zlib_constants.Z_BLOCK || flush < 0) {
      return strm ? zlib_deflate.err(strm, zlib_constants.Z_STREAM_ERROR) : zlib_constants.Z_STREAM_ERROR;
    }
    let s = strm.state;
    if (!strm.output || !strm.input && strm.avail_in !== 0 || s.status === zlib_deflate.FINISH_STATE && flush !== zlib_constants.Z_FINISH) {
      return zlib_deflate.err(strm, strm.avail_out === 0 ? zlib_constants.Z_BUF_ERROR : zlib_constants.Z_STREAM_ERROR);
    }
    s.strm = strm;
    const old_flush = s.last_flush;
    s.last_flush = flush;
    if (s.status === zlib_deflate.INIT_STATE) {
      if (s.wrap === 2) {
        strm.adler = 0;
        zlib_deflate.put_byte(s, 31);
        zlib_deflate.put_byte(s, 139);
        zlib_deflate.put_byte(s, 8);
        if (!s.gzhead) {
          zlib_deflate.put_byte(s, 0);
          zlib_deflate.put_byte(s, 0);
          zlib_deflate.put_byte(s, 0);
          zlib_deflate.put_byte(s, 0);
          zlib_deflate.put_byte(s, 0);
          zlib_deflate.put_byte(s, s.level === 9 ? 2 : s.strategy >= zlib_constants.Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
          zlib_deflate.put_byte(s, zlib_deflate.OS_CODE);
          s.status = zlib_deflate.BUSY_STATE;
        } else {
          zlib_deflate.put_byte(s, (s.gzhead.text ? 1 : 0) + (s.gzhead.hcrc ? 2 : 0) + (!s.gzhead.extra ? 0 : 4) + (!s.gzhead.name ? 0 : 8) + (!s.gzhead.comment ? 0 : 16));
          zlib_deflate.put_byte(s, s.gzhead.time & 255);
          zlib_deflate.put_byte(s, s.gzhead.time >> 8 & 255);
          zlib_deflate.put_byte(s, s.gzhead.time >> 16 & 255);
          zlib_deflate.put_byte(s, s.gzhead.time >> 24 & 255);
          zlib_deflate.put_byte(s, s.level === 9 ? 2 : s.strategy >= zlib_constants.Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
          zlib_deflate.put_byte(s, s.gzhead.os & 255);
          if (s.gzhead.extra && s.gzhead.extra.length) {
            zlib_deflate.put_byte(s, s.gzhead.extra.length & 255);
            zlib_deflate.put_byte(s, s.gzhead.extra.length >> 8 & 255);
          }
          if (s.gzhead.hcrc) {
            strm.adler = zlib_crc32.crc32(strm.adler, s.pending_buf, s.pending, 0);
          }
          s.gzindex = 0;
          s.status = zlib_deflate.EXTRA_STATE;
        }
      } else {
        let header = zlib_constants.Z_DEFLATED + (s.w_bits - 8 << 4) << 8;
        let level_flags = -1;
        if (s.strategy >= zlib_constants.Z_HUFFMAN_ONLY || s.level < 2) {
          level_flags = 0;
        } else if (s.level < 6) {
          level_flags = 1;
        } else if (s.level === 6) {
          level_flags = 2;
        } else {
          level_flags = 3;
        }
        header |= level_flags << 6;
        if (s.strstart !== 0) {
          header |= zlib_deflate.PRESET_DICT;
        }
        header += 31 - header % 31;
        s.status = zlib_deflate.BUSY_STATE;
        zlib_deflate.putShortMSB(s, header);
        if (s.strstart !== 0) {
          zlib_deflate.putShortMSB(s, strm.adler >>> 16);
          zlib_deflate.putShortMSB(s, strm.adler & 65535);
        }
        strm.adler = 1;
      }
    }
    if (s.status === zlib_deflate.EXTRA_STATE) {
      if (s.gzhead.extra) {
        beg = s.pending;
        while (s.gzindex < (s.gzhead.extra.length & 65535)) {
          if (s.pending === s.pending_buf_size) {
            if (s.gzhead.hcrc && s.pending > beg) {
              strm.adler = zlib_crc32.crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
            }
            zlib_deflate.flush_pending(strm);
            beg = s.pending;
            if (s.pending === s.pending_buf_size) {
              break;
            }
          }
          zlib_deflate.put_byte(s, s.gzhead.extra[s.gzindex] & 255);
          s.gzindex++;
        }
        if (s.gzhead.hcrc && s.pending > beg) {
          strm.adler = zlib_crc32.crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
        }
        if (s.gzindex === s.gzhead.extra.length) {
          s.gzindex = 0;
          s.status = zlib_deflate.NAME_STATE;
        }
      } else {
        s.status = zlib_deflate.NAME_STATE;
      }
    }
    if (s.status === zlib_deflate.NAME_STATE) {
      if (s.gzhead.name) {
        beg = s.pending;
        do {
          if (s.pending === s.pending_buf_size) {
            if (s.gzhead.hcrc && s.pending > beg) {
              strm.adler = zlib_crc32.crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
            }
            zlib_deflate.flush_pending(strm);
            beg = s.pending;
            if (s.pending === s.pending_buf_size) {
              val = 1;
              break;
            }
          }
          if (s.gzindex < s.gzhead.name.length) {
            val = s.gzhead.name.charCodeAt(s.gzindex++) & 255;
          } else {
            val = 0;
          }
          zlib_deflate.put_byte(s, val);
        } while (val !== 0);
        if (s.gzhead.hcrc && s.pending > beg) {
          strm.adler = zlib_crc32.crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
        }
        if (val === 0) {
          s.gzindex = 0;
          s.status = zlib_deflate.COMMENT_STATE;
        }
      } else {
        s.status = zlib_deflate.COMMENT_STATE;
      }
    }
    if (s.status === zlib_deflate.COMMENT_STATE) {
      if (s.gzhead.comment) {
        beg = s.pending;
        do {
          if (s.pending === s.pending_buf_size) {
            if (s.gzhead.hcrc && s.pending > beg) {
              strm.adler = zlib_crc32.crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
            }
            zlib_deflate.flush_pending(strm);
            beg = s.pending;
            if (s.pending === s.pending_buf_size) {
              val = 1;
              break;
            }
          }
          if (s.gzindex < s.gzhead.comment.length) {
            val = s.gzhead.comment.charCodeAt(s.gzindex++) & 255;
          } else {
            val = 0;
          }
          zlib_deflate.put_byte(s, val);
        } while (val !== 0);
        if (s.gzhead.hcrc && s.pending > beg) {
          strm.adler = zlib_crc32.crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
        }
        if (val === 0) {
          s.status = zlib_deflate.HCRC_STATE;
        }
      } else {
        s.status = zlib_deflate.HCRC_STATE;
      }
    }
    if (s.status === zlib_deflate.HCRC_STATE) {
      if (s.gzhead.hcrc) {
        if (s.pending + 2 > s.pending_buf_size) {
          zlib_deflate.flush_pending(strm);
        }
        if (s.pending + 2 <= s.pending_buf_size) {
          zlib_deflate.put_byte(s, strm.adler & 255);
          zlib_deflate.put_byte(s, strm.adler >> 8 & 255);
          strm.adler = 0;
          s.status = zlib_deflate.BUSY_STATE;
        }
      } else {
        s.status = zlib_deflate.BUSY_STATE;
      }
    }
    if (s.pending !== 0) {
      zlib_deflate.flush_pending(strm);
      if (strm.avail_out === 0) {
        s.last_flush = -1;
        return zlib_constants.Z_OK;
      }
    } else if (strm.avail_in === 0 && zlib_deflate.rank(flush) <= zlib_deflate.rank(old_flush) && flush !== zlib_constants.Z_FINISH) {
      return zlib_deflate.err(strm, zlib_constants.Z_BUF_ERROR);
    }
    if (s.status === zlib_deflate.FINISH_STATE && strm.avail_in !== 0) {
      return zlib_deflate.err(strm, zlib_constants.Z_BUF_ERROR);
    }
    if (strm.avail_in !== 0 || s.lookahead !== 0 || flush !== zlib_constants.Z_NO_FLUSH && s.status !== zlib_deflate.FINISH_STATE) {
      let bstate = s.strategy === zlib_constants.Z_HUFFMAN_ONLY ? zlib_deflate.deflate_huff(s, flush) : s.strategy === zlib_constants.Z_RLE ? zlib_deflate.deflate_rle(s, flush) : zlib_deflate.configuration_table[s.level].func(s, flush);
      if (bstate === zlib_deflate.BS_FINISH_STARTED || bstate === zlib_deflate.BS_FINISH_DONE) {
        s.status = zlib_deflate.FINISH_STATE;
      }
      if (bstate === zlib_deflate.BS_NEED_MORE || bstate === zlib_deflate.BS_FINISH_STARTED) {
        if (strm.avail_out === 0) {
          s.last_flush = -1;
        }
        return zlib_constants.Z_OK;
      }
      if (bstate === zlib_deflate.BS_BLOCK_DONE) {
        if (flush === zlib_constants.Z_PARTIAL_FLUSH) {
          zlib_Pako_trees._tr_align(s);
        } else if (flush !== zlib_constants.Z_BLOCK) {
          zlib_Pako_trees._tr_stored_block(s, 0, 0, false);
          if (flush === zlib_constants.Z_FULL_FLUSH) {
            zlib_Pako_trees.zero(s.head);
            if (s.lookahead === 0) {
              s.strstart = 0;
              s.block_start = 0;
              s.insert = 0;
            }
          }
        }
        zlib_deflate.flush_pending(strm);
        if (strm.avail_out === 0) {
          s.last_flush = -1;
          return zlib_constants.Z_OK;
        }
      }
    }
    if (flush !== zlib_constants.Z_FINISH) {
      return zlib_constants.Z_OK;
    }
    if (s.wrap <= 0) {
      return zlib_constants.Z_STREAM_END;
    }
    if (s.wrap === 2) {
      zlib_deflate.put_byte(s, strm.adler & 255);
      zlib_deflate.put_byte(s, strm.adler >> 8 & 255);
      zlib_deflate.put_byte(s, strm.adler >> 16 & 255);
      zlib_deflate.put_byte(s, strm.adler >> 24 & 255);
      zlib_deflate.put_byte(s, strm.total_in & 255);
      zlib_deflate.put_byte(s, strm.total_in >> 8 & 255);
      zlib_deflate.put_byte(s, strm.total_in >> 16 & 255);
      zlib_deflate.put_byte(s, strm.total_in >> 24 & 255);
    } else {
      zlib_deflate.putShortMSB(s, strm.adler >>> 16);
      zlib_deflate.putShortMSB(s, strm.adler & 65535);
    }
    zlib_deflate.flush_pending(strm);
    if (s.wrap > 0) {
      s.wrap = -s.wrap;
    }
    return s.pending !== 0 ? zlib_constants.Z_OK : zlib_constants.Z_STREAM_END;
  }
  static deflateEnd(strm) {
    if (!strm || !strm.state) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    let status = strm.state.status;
    if (status !== zlib_deflate.INIT_STATE && status !== zlib_deflate.EXTRA_STATE && status !== zlib_deflate.NAME_STATE && status !== zlib_deflate.COMMENT_STATE && status !== zlib_deflate.HCRC_STATE && status !== zlib_deflate.BUSY_STATE && status !== zlib_deflate.FINISH_STATE) {
      return zlib_deflate.err(strm, zlib_constants.Z_STREAM_ERROR);
    }
    strm.state = null;
    return status === zlib_deflate.BUSY_STATE ? zlib_deflate.err(strm, zlib_constants.Z_DATA_ERROR) : zlib_constants.Z_OK;
  }
  static deflateSetDictionary(strm, dictionary) {
    let dictLength = dictionary.length;
    if (!strm || !strm.state) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    const s = strm.state;
    const wrap = s.wrap;
    if (wrap === 2 || wrap === 1 && s.status !== zlib_deflate.INIT_STATE || s.lookahead) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    if (wrap === 1) {
      strm.adler = zlib_adler32.adler32(strm.adler, dictionary, dictLength, 0);
    }
    s.wrap = 0;
    if (dictLength >= s.w_size) {
      if (wrap === 0) {
        zlib_Pako_trees.zero(s.head);
        s.strstart = 0;
        s.block_start = 0;
        s.insert = 0;
      }
      let tmpDict = new Uint8Array(s.w_size);
      tmpDict.set(dictionary.subarray(dictLength - s.w_size, dictLength), 0);
      dictionary = tmpDict;
      dictLength = s.w_size;
    }
    const avail = strm.avail_in;
    const next = strm.next_in;
    const input = strm.input;
    strm.avail_in = dictLength;
    strm.next_in = 0;
    strm.input = dictionary;
    zlib_deflate.fill_window(s);
    while (s.lookahead >= zlib_Pako_trees.MIN_MATCH) {
      let str = s.strstart;
      let n = s.lookahead - (zlib_Pako_trees.MIN_MATCH - 1);
      do {
        s.ins_h = zlib_deflate.HASH(s, s.ins_h, s.window[str + zlib_Pako_trees.MIN_MATCH - 1]);
        s.prev[str & s.w_mask] = s.head[s.ins_h];
        s.head[s.ins_h] = str;
        str++;
      } while (--n);
      s.strstart = str;
      s.lookahead = zlib_Pako_trees.MIN_MATCH - 1;
      zlib_deflate.fill_window(s);
    }
    s.strstart += s.lookahead;
    s.block_start = s.strstart;
    s.insert = s.lookahead;
    s.lookahead = 0;
    s.match_length = s.prev_length = zlib_Pako_trees.MIN_MATCH - 1;
    s.match_available = 0;
    strm.next_in = next;
    strm.input = input;
    strm.avail_in = avail;
    s.wrap = wrap;
    return zlib_constants.Z_OK;
  }
};
zlib_deflate.MAX_MEM_LEVEL = 9;
zlib_deflate.MAX_WBITS = 15;
zlib_deflate.DEF_MEM_LEVEL = 8;
zlib_deflate.LENGTH_CODES = 29;
zlib_deflate.LITERALS = 256;
zlib_deflate.L_CODES = zlib_deflate.LITERALS + 1 + zlib_deflate.LENGTH_CODES;
zlib_deflate.D_CODES = 30;
zlib_deflate.BL_CODES = 19;
zlib_deflate.HEAP_SIZE = 2 * zlib_deflate.L_CODES + 1;
zlib_deflate.MAX_BITS = 15;
zlib_deflate.MIN_MATCH = 3;
zlib_deflate.MAX_MATCH = 258;
zlib_deflate.MIN_LOOKAHEAD = zlib_deflate.MAX_MATCH + zlib_deflate.MIN_MATCH + 1;
zlib_deflate.PRESET_DICT = 32;
zlib_deflate.INIT_STATE = 42;
zlib_deflate.EXTRA_STATE = 69;
zlib_deflate.NAME_STATE = 73;
zlib_deflate.COMMENT_STATE = 91;
zlib_deflate.HCRC_STATE = 103;
zlib_deflate.BUSY_STATE = 113;
zlib_deflate.FINISH_STATE = 666;
zlib_deflate.BS_NEED_MORE = 1;
zlib_deflate.BS_BLOCK_DONE = 2;
zlib_deflate.BS_FINISH_STARTED = 3;
zlib_deflate.BS_FINISH_DONE = 4;
zlib_deflate.OS_CODE = 3;
zlib_deflate.deflate_fast = (s, flush) => {
  let hash_head;
  let bflush;
  for (; ; ) {
    if (s.lookahead < zlib_deflate.MIN_LOOKAHEAD) {
      zlib_deflate.fill_window(s);
      if (s.lookahead < zlib_deflate.MIN_LOOKAHEAD && flush === zlib_constants.Z_NO_FLUSH) {
        return zlib_deflate.BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break;
      }
    }
    hash_head = 0;
    if (s.lookahead >= zlib_Pako_trees.MIN_MATCH) {
      s.ins_h = zlib_deflate.HASH(s, s.ins_h, s.window[s.strstart + zlib_Pako_trees.MIN_MATCH - 1]);
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
    }
    if (hash_head !== 0 && s.strstart - hash_head <= s.w_size - zlib_deflate.MIN_LOOKAHEAD) {
      s.match_length = zlib_deflate.longest_match(s, hash_head);
    }
    if (s.match_length >= zlib_Pako_trees.MIN_MATCH) {
      bflush = zlib_Pako_trees._tr_tally(s, s.strstart - s.match_start, s.match_length - zlib_Pako_trees.MIN_MATCH);
      s.lookahead -= s.match_length;
      if (s.match_length <= s.max_lazy_match && s.lookahead >= zlib_Pako_trees.MIN_MATCH) {
        s.match_length--;
        do {
          s.strstart++;
          s.ins_h = zlib_deflate.HASH(s, s.ins_h, s.window[s.strstart + zlib_Pako_trees.MIN_MATCH - 1]);
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
        } while (--s.match_length !== 0);
        s.strstart++;
      } else {
        s.strstart += s.match_length;
        s.match_length = 0;
        s.ins_h = s.window[s.strstart];
        s.ins_h = zlib_deflate.HASH(s, s.ins_h, s.window[s.strstart + 1]);
      }
    } else {
      bflush = zlib_Pako_trees._tr_tally(s, 0, s.window[s.strstart]);
      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      zlib_deflate.flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return zlib_deflate.BS_NEED_MORE;
      }
    }
  }
  s.insert = s.strstart < zlib_Pako_trees.MIN_MATCH - 1 ? s.strstart : zlib_Pako_trees.MIN_MATCH - 1;
  if (flush === zlib_constants.Z_FINISH) {
    zlib_deflate.flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return zlib_deflate.BS_FINISH_STARTED;
    }
    return zlib_deflate.BS_FINISH_DONE;
  }
  if (s.last_lit) {
    zlib_deflate.flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return zlib_deflate.BS_NEED_MORE;
    }
  }
  return zlib_deflate.BS_BLOCK_DONE;
};
zlib_deflate.configuration_table = [
  new zlib_config(0, 0, 0, 0, zlib_deflate.deflate_stored),
  new zlib_config(4, 4, 8, 4, zlib_deflate.deflate_fast),
  new zlib_config(4, 5, 16, 8, zlib_deflate.deflate_fast),
  new zlib_config(4, 6, 32, 32, zlib_deflate.deflate_fast),
  new zlib_config(4, 4, 16, 16, zlib_deflate.deflate_slow),
  new zlib_config(8, 16, 32, 32, zlib_deflate.deflate_slow),
  new zlib_config(8, 16, 128, 128, zlib_deflate.deflate_slow),
  new zlib_config(8, 32, 128, 256, zlib_deflate.deflate_slow),
  new zlib_config(32, 128, 258, 1024, zlib_deflate.deflate_slow),
  new zlib_config(32, 258, 258, 4096, zlib_deflate.deflate_slow)
];

// obj/full/Pako/zlib/trees.js
"use strict";
var zlib_StaticTreeDesc = class {
  constructor(static_tree, extra_bits, extra_base, elems, max_length) {
    this.static_tree = static_tree;
    this.extra_bits = extra_bits;
    this.extra_base = extra_base;
    this.elems = elems;
    this.max_length = max_length;
    this.has_stree = static_tree != null && static_tree.length > 0;
  }
};
var zlib_TreeDesc = class {
  constructor(dyn_tree, stat_desc) {
    this.max_code = 0;
    this.dyn_tree = dyn_tree;
    this.max_code = 0;
    this.stat_desc = stat_desc;
  }
};
var zlib_Pako_trees = class {
  static zero(buf) {
    let len = buf.length;
    while (--len >= 0) {
      buf[len] = 0;
    }
  }
  static Zeroinit() {
    zlib_Pako_trees.zero(zlib_Pako_trees.static_ltree);
    zlib_Pako_trees.zero(zlib_Pako_trees.base_dist);
    zlib_Pako_trees.zero(zlib_Pako_trees.base_length);
    zlib_Pako_trees.zero(zlib_Pako_trees._length_code);
    zlib_Pako_trees.zero(zlib_Pako_trees._dist_code);
    zlib_Pako_trees.zero(zlib_Pako_trees.static_dtree);
    return true;
  }
  static d_code(dist) {
    return dist < 256 ? zlib_Pako_trees._dist_code[dist] : zlib_Pako_trees._dist_code[256 + (dist >>> 7)];
  }
  static put_short(s, w) {
    s.pending_buf[s.pending++] = w & 255;
    s.pending_buf[s.pending++] = w >>> 8 & 255;
  }
  static send_code(s, c, tree) {
    zlib_Pako_trees.send_bits(s, tree[c * 2], tree[c * 2 + 1]);
  }
  static bi_reverse(code, len) {
    let res = 0;
    do {
      res |= code & 1;
      code >>>= 1;
      res <<= 1;
    } while (--len > 0);
    return res >>> 1;
  }
  static bi_flush(s) {
    if (s.bi_valid === 16) {
      zlib_Pako_trees.put_short(s, s.bi_buf);
      s.bi_buf = 0;
      s.bi_valid = 0;
    } else if (s.bi_valid >= 8) {
      s.pending_buf[s.pending++] = s.bi_buf & 255;
      s.bi_buf >>= 8;
      s.bi_valid -= 8;
    }
  }
  static gen_codes(tree, max_code, bl_count) {
    const next_code = new Array(zlib_Pako_trees.MAX_BITS + 1);
    let code = 0;
    let bits;
    let n;
    for (bits = 1; bits <= zlib_Pako_trees.MAX_BITS; bits++) {
      next_code[bits] = code = code + bl_count[bits - 1] << 1;
    }
    for (n = 0; n <= max_code; n++) {
      let len = tree[n * 2 + 1];
      if (len === 0) {
        continue;
      }
      tree[n * 2] = zlib_Pako_trees.bi_reverse(next_code[len]++, len);
    }
  }
  static tr_static_init() {
    let n;
    let bits;
    let length;
    let code;
    let dist;
    const bl_count = new Uint16Array(zlib_Pako_trees.MAX_BITS + 1);
    length = 0;
    for (code = 0; code < zlib_Pako_trees.LENGTH_CODES - 1; code++) {
      zlib_Pako_trees.base_length[code] = length;
      for (n = 0; n < 1 << zlib_Pako_trees.extra_lbits[code]; n++) {
        zlib_Pako_trees._length_code[length++] = code;
      }
    }
    zlib_Pako_trees._length_code[length - 1] = code;
    dist = 0;
    for (code = 0; code < 16; code++) {
      zlib_Pako_trees.base_dist[code] = dist;
      for (n = 0; n < 1 << zlib_Pako_trees.extra_dbits[code]; n++) {
        zlib_Pako_trees._dist_code[dist++] = code;
      }
    }
    dist >>= 7;
    for (; code < zlib_Pako_trees.D_CODES; code++) {
      zlib_Pako_trees.base_dist[code] = dist << 7;
      for (n = 0; n < 1 << zlib_Pako_trees.extra_dbits[code] - 7; n++) {
        zlib_Pako_trees._dist_code[256 + dist++] = code;
      }
    }
    for (bits = 0; bits <= zlib_Pako_trees.MAX_BITS; bits++) {
      bl_count[bits] = 0;
    }
    n = 0;
    while (n <= 143) {
      zlib_Pako_trees.static_ltree[n * 2 + 1] = 8;
      n++;
      bl_count[8]++;
    }
    while (n <= 255) {
      zlib_Pako_trees.static_ltree[n * 2 + 1] = 9;
      n++;
      bl_count[9]++;
    }
    while (n <= 279) {
      zlib_Pako_trees.static_ltree[n * 2 + 1] = 7;
      n++;
      bl_count[7]++;
    }
    while (n <= 287) {
      zlib_Pako_trees.static_ltree[n * 2 + 1] = 8;
      n++;
      bl_count[8]++;
    }
    zlib_Pako_trees.gen_codes(zlib_Pako_trees.static_ltree, zlib_Pako_trees.L_CODES + 1, bl_count);
    for (n = 0; n < zlib_Pako_trees.D_CODES; n++) {
      zlib_Pako_trees.static_dtree[n * 2 + 1] = 5;
      zlib_Pako_trees.static_dtree[n * 2] = zlib_Pako_trees.bi_reverse(n, 5);
    }
    zlib_Pako_trees.static_l_desc = new zlib_StaticTreeDesc(zlib_Pako_trees.static_ltree, zlib_Pako_trees.extra_lbits, zlib_Pako_trees.LITERALS + 1, zlib_Pako_trees.L_CODES, zlib_Pako_trees.MAX_BITS);
    zlib_Pako_trees.static_d_desc = new zlib_StaticTreeDesc(zlib_Pako_trees.static_dtree, zlib_Pako_trees.extra_dbits, 0, zlib_Pako_trees.D_CODES, zlib_Pako_trees.MAX_BITS);
    zlib_Pako_trees.static_bl_desc = new zlib_StaticTreeDesc(new Uint16Array(0), zlib_Pako_trees.extra_blbits, 0, zlib_Pako_trees.BL_CODES, zlib_Pako_trees.MAX_BL_BITS);
  }
  static init_block(s) {
    let n;
    for (n = 0; n < zlib_Pako_trees.L_CODES; n++) {
      s.dyn_ltree[n * 2] = 0;
    }
    for (n = 0; n < zlib_Pako_trees.D_CODES; n++) {
      s.dyn_dtree[n * 2] = 0;
    }
    for (n = 0; n < zlib_Pako_trees.BL_CODES; n++) {
      s.bl_tree[n * 2] = 0;
    }
    s.dyn_ltree[zlib_Pako_trees.END_BLOCK * 2] = 1;
    s.opt_len = s.static_len = 0;
    s.last_lit = s.matches = 0;
  }
  static bi_windup(s) {
    if (s.bi_valid > 8) {
      zlib_Pako_trees.put_short(s, s.bi_buf);
    } else if (s.bi_valid > 0) {
      s.pending_buf[s.pending++] = s.bi_buf;
    }
    s.bi_buf = 0;
    s.bi_valid = 0;
  }
  static copy_block(s, buf, len, header) {
    zlib_Pako_trees.bi_windup(s);
    if (header) {
      zlib_Pako_trees.put_short(s, len);
      zlib_Pako_trees.put_short(s, ~len);
    }
    s.pending_buf.set(s.window.subarray(buf, buf + len), s.pending);
    s.pending += len;
  }
  static smaller(tree, n, m, depth) {
    const _n2 = n * 2;
    const _m2 = m * 2;
    return tree[_n2] < tree[_m2] || tree[_n2] === tree[_m2] && depth[n] <= depth[m];
  }
  static pqdownheap(s, tree, k) {
    const v = s.heap[k];
    let j = k << 1;
    while (j <= s.heap_len) {
      if (j < s.heap_len && zlib_Pako_trees.smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
        j++;
      }
      if (zlib_Pako_trees.smaller(tree, v, s.heap[j], s.depth)) {
        break;
      }
      s.heap[k] = s.heap[j];
      k = j;
      j <<= 1;
    }
    s.heap[k] = v;
  }
  static compress_block(s, ltree, dtree) {
    let dist;
    let lc;
    let lx = 0;
    let code;
    let extra;
    if (s.last_lit !== 0) {
      do {
        dist = s.pending_buf[s.d_buf + lx * 2] << 8 | s.pending_buf[s.d_buf + lx * 2 + 1];
        lc = s.pending_buf[s.l_buf + lx];
        lx++;
        if (dist === 0) {
          zlib_Pako_trees.send_code(s, lc, ltree);
        } else {
          code = zlib_Pako_trees._length_code[lc];
          zlib_Pako_trees.send_code(s, code + zlib_Pako_trees.LITERALS + 1, ltree);
          extra = zlib_Pako_trees.extra_lbits[code];
          if (extra !== 0) {
            lc -= zlib_Pako_trees.base_length[code];
            zlib_Pako_trees.send_bits(s, lc, extra);
          }
          dist--;
          code = zlib_Pako_trees.d_code(dist);
          zlib_Pako_trees.send_code(s, code, dtree);
          extra = zlib_Pako_trees.extra_dbits[code];
          if (extra !== 0) {
            dist -= zlib_Pako_trees.base_dist[code];
            zlib_Pako_trees.send_bits(s, dist, extra);
          }
        }
      } while (lx < s.last_lit);
    }
    zlib_Pako_trees.send_code(s, zlib_Pako_trees.END_BLOCK, ltree);
  }
  static build_tree(s, desc) {
    const tree = desc.dyn_tree;
    const stree = desc.stat_desc.static_tree;
    const has_stree = desc.stat_desc.has_stree;
    const elems = desc.stat_desc.elems;
    let n, m;
    let max_code = -1;
    let node;
    s.heap_len = 0;
    s.heap_max = zlib_Pako_trees.HEAP_SIZE;
    for (n = 0; n < elems; n++) {
      if (tree[n * 2] !== 0) {
        s.heap[++s.heap_len] = max_code = n;
        s.depth[n] = 0;
      } else {
        tree[n * 2 + 1] = 0;
      }
    }
    while (s.heap_len < 2) {
      node = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0;
      tree[node * 2] = 1;
      s.depth[node] = 0;
      s.opt_len--;
      if (has_stree) {
        s.static_len -= stree[node * 2 + 1];
      }
    }
    desc.max_code = max_code;
    for (n = s.heap_len >> 1; n >= 1; n--) {
      zlib_Pako_trees.pqdownheap(s, tree, n);
    }
    node = elems;
    do {
      n = s.heap[1];
      s.heap[1] = s.heap[s.heap_len--];
      zlib_Pako_trees.pqdownheap(s, tree, 1);
      m = s.heap[1];
      s.heap[--s.heap_max] = n;
      s.heap[--s.heap_max] = m;
      tree[node * 2] = tree[n * 2] + tree[m * 2];
      s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
      tree[n * 2 + 1] = tree[m * 2 + 1] = node;
      s.heap[1] = node++;
      zlib_Pako_trees.pqdownheap(s, tree, 1);
    } while (s.heap_len >= 2);
    s.heap[--s.heap_max] = s.heap[1];
    zlib_Pako_trees.gen_bitlen(s, desc);
    zlib_Pako_trees.gen_codes(tree, max_code, s.bl_count);
  }
  static scan_tree(s, tree, max_code) {
    let n;
    let prevlen = -1;
    let curlen;
    let nextlen = tree[0 * 2 + 1];
    let count = 0;
    let max_count = 7;
    let min_count = 4;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    }
    tree[(max_code + 1) * 2 + 1] = 65535;
    for (n = 0; n <= max_code; n++) {
      curlen = nextlen;
      nextlen = tree[(n + 1) * 2 + 1];
      if (++count < max_count && curlen === nextlen) {
        continue;
      } else if (count < min_count) {
        s.bl_tree[curlen * 2] += count;
      } else if (curlen !== 0) {
        if (curlen !== prevlen) {
          s.bl_tree[curlen * 2]++;
        }
        s.bl_tree[zlib_Pako_trees.REP_3_6 * 2]++;
      } else if (count <= 10) {
        s.bl_tree[zlib_Pako_trees.REPZ_3_10 * 2]++;
      } else {
        s.bl_tree[zlib_Pako_trees.REPZ_11_138 * 2]++;
      }
      count = 0;
      prevlen = curlen;
      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      } else if (curlen === nextlen) {
        max_count = 6;
        min_count = 3;
      } else {
        max_count = 7;
        min_count = 4;
      }
    }
  }
  static send_tree(s, tree, max_code) {
    let n;
    let prevlen = -1;
    let curlen;
    let nextlen = tree[0 * 2 + 1];
    let count = 0;
    let max_count = 7;
    let min_count = 4;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    }
    for (n = 0; n <= max_code; n++) {
      curlen = nextlen;
      nextlen = tree[(n + 1) * 2 + 1];
      if (++count < max_count && curlen === nextlen) {
        continue;
      } else if (count < min_count) {
        do {
          zlib_Pako_trees.send_code(s, curlen, s.bl_tree);
        } while (--count !== 0);
      } else if (curlen !== 0) {
        if (curlen !== prevlen) {
          zlib_Pako_trees.send_code(s, curlen, s.bl_tree);
          count--;
        }
        zlib_Pako_trees.send_code(s, zlib_Pako_trees.REP_3_6, s.bl_tree);
        zlib_Pako_trees.send_bits(s, count - 3, 2);
      } else if (count <= 10) {
        zlib_Pako_trees.send_code(s, zlib_Pako_trees.REPZ_3_10, s.bl_tree);
        zlib_Pako_trees.send_bits(s, count - 3, 3);
      } else {
        zlib_Pako_trees.send_code(s, zlib_Pako_trees.REPZ_11_138, s.bl_tree);
        zlib_Pako_trees.send_bits(s, count - 11, 7);
      }
      count = 0;
      prevlen = curlen;
      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      } else if (curlen === nextlen) {
        max_count = 6;
        min_count = 3;
      } else {
        max_count = 7;
        min_count = 4;
      }
    }
  }
  static build_bl_tree(s) {
    let max_blindex;
    zlib_Pako_trees.scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
    zlib_Pako_trees.scan_tree(s, s.dyn_dtree, s.d_desc.max_code);
    zlib_Pako_trees.build_tree(s, s.bl_desc);
    for (max_blindex = zlib_Pako_trees.BL_CODES - 1; max_blindex >= 3; max_blindex--) {
      if (s.bl_tree[zlib_Pako_trees.bl_order[max_blindex] * 2 + 1] !== 0) {
        break;
      }
    }
    s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
    return max_blindex;
  }
  static send_all_trees(s, lcodes, dcodes, blcodes) {
    let rank;
    zlib_Pako_trees.send_bits(s, lcodes - 257, 5);
    zlib_Pako_trees.send_bits(s, dcodes - 1, 5);
    zlib_Pako_trees.send_bits(s, blcodes - 4, 4);
    for (rank = 0; rank < blcodes; rank++) {
      zlib_Pako_trees.send_bits(s, s.bl_tree[zlib_Pako_trees.bl_order[rank] * 2 + 1], 3);
    }
    zlib_Pako_trees.send_tree(s, s.dyn_ltree, lcodes - 1);
    zlib_Pako_trees.send_tree(s, s.dyn_dtree, dcodes - 1);
  }
  static detect_data_type(s) {
    let black_mask = 4093624447;
    let n;
    for (n = 0; n <= 31; n++, black_mask >>>= 1) {
      if (black_mask & 1 && s.dyn_ltree[n * 2] !== 0) {
        return zlib_constants.Z_BINARY;
      }
    }
    if (s.dyn_ltree[9 * 2] !== 0 || s.dyn_ltree[10 * 2] !== 0 || s.dyn_ltree[13 * 2] !== 0) {
      return zlib_constants.Z_TEXT;
    }
    for (n = 32; n < zlib_Pako_trees.LITERALS; n++) {
      if (s.dyn_ltree[n * 2] !== 0) {
        return zlib_constants.Z_TEXT;
      }
    }
    return zlib_constants.Z_BINARY;
  }
  static _tr_init(s) {
    if (!zlib_Pako_trees.static_init_done) {
      zlib_Pako_trees.tr_static_init();
      zlib_Pako_trees.static_init_done = true;
    }
    s.l_desc = new zlib_TreeDesc(s.dyn_ltree, zlib_Pako_trees.static_l_desc);
    s.d_desc = new zlib_TreeDesc(s.dyn_dtree, zlib_Pako_trees.static_d_desc);
    s.bl_desc = new zlib_TreeDesc(s.bl_tree, zlib_Pako_trees.static_bl_desc);
    s.bi_buf = 0;
    s.bi_valid = 0;
    zlib_Pako_trees.init_block(s);
  }
  static _tr_stored_block(s, buf, stored_len, last) {
    zlib_Pako_trees.send_bits(s, (zlib_Pako_trees.STORED_BLOCK << 1) + (last ? 1 : 0), 3);
    zlib_Pako_trees.copy_block(s, buf, stored_len, true);
  }
  static _tr_align(s) {
    zlib_Pako_trees.send_bits(s, zlib_Pako_trees.STATIC_TREES << 1, 3);
    zlib_Pako_trees.send_code(s, zlib_Pako_trees.END_BLOCK, zlib_Pako_trees.static_ltree);
    zlib_Pako_trees.bi_flush(s);
  }
  static _tr_flush_block(s, buf, stored_len, last) {
    let opt_lenb;
    let static_lenb;
    let max_blindex = 0;
    if (s.level > 0) {
      if (s.strm.data_type === zlib_constants.Z_UNKNOWN) {
        s.strm.data_type = zlib_Pako_trees.detect_data_type(s);
      }
      zlib_Pako_trees.build_tree(s, s.l_desc);
      zlib_Pako_trees.build_tree(s, s.d_desc);
      max_blindex = zlib_Pako_trees.build_bl_tree(s);
      opt_lenb = s.opt_len + 3 + 7 >>> 3;
      static_lenb = s.static_len + 3 + 7 >>> 3;
      if (static_lenb <= opt_lenb) {
        opt_lenb = static_lenb;
      }
    } else {
      opt_lenb = static_lenb = stored_len + 5;
    }
    if (stored_len + 4 <= opt_lenb && buf !== -1) {
      zlib_Pako_trees._tr_stored_block(s, buf, stored_len, last);
    } else if (s.strategy === zlib_constants.Z_FIXED || static_lenb === opt_lenb) {
      zlib_Pako_trees.send_bits(s, (zlib_Pako_trees.STATIC_TREES << 1) + (last ? 1 : 0), 3);
      zlib_Pako_trees.compress_block(s, zlib_Pako_trees.static_ltree, zlib_Pako_trees.static_dtree);
    } else {
      zlib_Pako_trees.send_bits(s, (zlib_Pako_trees.DYN_TREES << 1) + (last ? 1 : 0), 3);
      zlib_Pako_trees.send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
      zlib_Pako_trees.compress_block(s, s.dyn_ltree, s.dyn_dtree);
    }
    zlib_Pako_trees.init_block(s);
    if (last) {
      zlib_Pako_trees.bi_windup(s);
    }
  }
  static _tr_tally(s, dist, lc) {
    s.pending_buf[s.d_buf + s.last_lit * 2] = dist >>> 8 & 255;
    s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 255;
    s.pending_buf[s.l_buf + s.last_lit] = lc & 255;
    s.last_lit++;
    if (dist === 0) {
      s.dyn_ltree[lc * 2]++;
    } else {
      s.matches++;
      dist--;
      s.dyn_ltree[(zlib_Pako_trees._length_code[lc] + zlib_Pako_trees.LITERALS + 1) * 2]++;
      s.dyn_dtree[zlib_Pako_trees.d_code(dist) * 2]++;
    }
    return s.last_lit === s.lit_bufsize - 1;
  }
};
zlib_Pako_trees.Z_FIXED = 4;
zlib_Pako_trees.Z_BINARY = 0;
zlib_Pako_trees.Z_TEXT = 1;
zlib_Pako_trees.Z_UNKNOWN = 2;
zlib_Pako_trees.STORED_BLOCK = 0;
zlib_Pako_trees.STATIC_TREES = 1;
zlib_Pako_trees.DYN_TREES = 2;
zlib_Pako_trees.MIN_MATCH = 3;
zlib_Pako_trees.MAX_MATCH = 258;
zlib_Pako_trees.LENGTH_CODES = 29;
zlib_Pako_trees.LITERALS = 256;
zlib_Pako_trees.L_CODES = zlib_Pako_trees.LITERALS + 1 + zlib_Pako_trees.LENGTH_CODES;
zlib_Pako_trees.D_CODES = 30;
zlib_Pako_trees.BL_CODES = 19;
zlib_Pako_trees.HEAP_SIZE = 2 * zlib_Pako_trees.L_CODES + 1;
zlib_Pako_trees.MAX_BITS = 15;
zlib_Pako_trees.Buf_size = 16;
zlib_Pako_trees.MAX_BL_BITS = 7;
zlib_Pako_trees.END_BLOCK = 256;
zlib_Pako_trees.REP_3_6 = 16;
zlib_Pako_trees.REPZ_3_10 = 17;
zlib_Pako_trees.REPZ_11_138 = 18;
zlib_Pako_trees.extra_lbits = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0]);
zlib_Pako_trees.extra_dbits = new Uint8Array([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]);
zlib_Pako_trees.extra_blbits = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7]);
zlib_Pako_trees.bl_order = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
zlib_Pako_trees.DIST_CODE_LEN = 512;
zlib_Pako_trees.static_ltree = new Uint16Array((zlib_Pako_trees.L_CODES + 2) * 2);
zlib_Pako_trees.static_dtree = new Uint16Array(zlib_Pako_trees.D_CODES * 2);
zlib_Pako_trees._dist_code = new Uint16Array(zlib_Pako_trees.DIST_CODE_LEN);
zlib_Pako_trees._length_code = new Uint16Array(zlib_Pako_trees.MAX_MATCH - zlib_Pako_trees.MIN_MATCH + 1);
zlib_Pako_trees.base_length = new Uint16Array(zlib_Pako_trees.LENGTH_CODES);
zlib_Pako_trees.base_dist = new Uint16Array(zlib_Pako_trees.D_CODES);
zlib_Pako_trees.send_bits = (s, value, length) => {
  if (s.bi_valid > zlib_Pako_trees.Buf_size - length) {
    s.bi_buf |= value << s.bi_valid & 65535;
    zlib_Pako_trees.put_short(s, s.bi_buf);
    s.bi_buf = value >> zlib_Pako_trees.Buf_size - s.bi_valid;
    s.bi_valid += length - zlib_Pako_trees.Buf_size;
  } else {
    s.bi_buf |= value << s.bi_valid & 65535;
    s.bi_valid += length;
  }
};
zlib_Pako_trees.gen_bitlen = (s, desc) => {
  const tree = desc.dyn_tree;
  const max_code = desc.max_code;
  const stree = desc.stat_desc.static_tree;
  const has_stree = desc.stat_desc.has_stree;
  const extra = desc.stat_desc.extra_bits;
  const base = desc.stat_desc.extra_base;
  const max_length = desc.stat_desc.max_length;
  let h;
  let n, m;
  let bits;
  let xbits;
  let f;
  let overflow = 0;
  for (bits = 0; bits <= zlib_Pako_trees.MAX_BITS; bits++) {
    s.bl_count[bits] = 0;
  }
  tree[s.heap[s.heap_max] * 2 + 1] = 0;
  for (h = s.heap_max + 1; h < zlib_Pako_trees.HEAP_SIZE; h++) {
    n = s.heap[h];
    bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;
    if (bits > max_length) {
      bits = max_length;
      overflow++;
    }
    tree[n * 2 + 1] = bits;
    if (n > max_code) {
      continue;
    }
    s.bl_count[bits]++;
    xbits = 0;
    if (n >= base) {
      xbits = extra[n - base];
    }
    f = tree[n * 2];
    s.opt_len += f * (bits + xbits);
    if (has_stree) {
      s.static_len += f * (stree[n * 2 + 1] + xbits);
    }
  }
  if (overflow === 0) {
    return;
  }
  do {
    bits = max_length - 1;
    while (s.bl_count[bits] === 0) {
      bits--;
    }
    s.bl_count[bits]--;
    s.bl_count[bits + 1] += 2;
    s.bl_count[max_length]--;
    overflow -= 2;
  } while (overflow > 0);
  for (bits = max_length; bits !== 0; bits--) {
    n = s.bl_count[bits];
    while (n !== 0) {
      m = s.heap[--h];
      if (m > max_code) {
        continue;
      }
      if (tree[m * 2 + 1] !== bits) {
        s.opt_len += (bits - tree[m * 2 + 1]) * tree[m * 2];
        tree[m * 2 + 1] = bits;
      }
      n--;
    }
  }
};
zlib_Pako_trees.static_init_done = false;
zlib_Pako_trees.initDone = zlib_Pako_trees.Zeroinit();

// obj/full/Pako/zlib/gzheader.js
"use strict";
var zlib_GZheader = class {
  constructor() {
    this.text = 0;
    this.time = 0;
    this.xflags = 0;
    this.os = 0;
    this.extra = null;
    this.extra_len = 0;
    this.name = "";
    this.comment = "";
    this.hcrc = 0;
    this.done = false;
  }
};

// obj/full/Pako/zlib/inffast.js
"use strict";
var zlib_inffast = class {
  static inflate_fast(strm, start) {
    let _in;
    let last;
    let _out;
    let beg;
    let end;
    let wsize;
    let whave;
    let wnext;
    let s_window;
    let hold;
    let bits;
    let lcode;
    let dcode;
    let lmask;
    let dmask;
    let here;
    let op;
    let len;
    let dist;
    let from;
    let from_source;
    let input;
    let output;
    let state = strm.state;
    _in = strm.next_in;
    input = strm.input;
    last = _in + (strm.avail_in - 5);
    _out = strm.next_out;
    output = strm.output;
    beg = _out - (start - strm.avail_out);
    end = _out + (strm.avail_out - 257);
    wsize = state.wsize;
    whave = state.whave;
    wnext = state.wnext;
    s_window = state.window;
    hold = state.hold;
    bits = state.bits;
    lcode = state.lencode;
    dcode = state.distcode;
    lmask = (1 << state.lenbits) - 1;
    dmask = (1 << state.distbits) - 1;
    top:
      do {
        if (bits < 15) {
          hold += input[_in++] << bits;
          bits += 8;
          hold += input[_in++] << bits;
          bits += 8;
        }
        here = lcode[hold & lmask];
        dolen:
          for (; ; ) {
            op = here >>> 24;
            hold >>>= op;
            bits -= op;
            op = here >>> 16 & 255;
            if (op === 0) {
              output[_out++] = here & 65535;
            } else if (op & 16) {
              len = here & 65535;
              op &= 15;
              if (op) {
                if (bits < op) {
                  hold += input[_in++] << bits;
                  bits += 8;
                }
                len += hold & (1 << op) - 1;
                hold >>>= op;
                bits -= op;
              }
              if (bits < 15) {
                hold += input[_in++] << bits;
                bits += 8;
                hold += input[_in++] << bits;
                bits += 8;
              }
              here = dcode[hold & dmask];
              dodist:
                for (; ; ) {
                  op = here >>> 24;
                  hold >>>= op;
                  bits -= op;
                  op = here >>> 16 & 255;
                  if (op & 16) {
                    dist = here & 65535;
                    op &= 15;
                    if (bits < op) {
                      hold += input[_in++] << bits;
                      bits += 8;
                      if (bits < op) {
                        hold += input[_in++] << bits;
                        bits += 8;
                      }
                    }
                    dist += hold & (1 << op) - 1;
                    hold >>>= op;
                    bits -= op;
                    op = _out - beg;
                    if (dist > op) {
                      op = dist - op;
                      if (op > whave) {
                        if (state.sane) {
                          strm.msg = "invalid distance too far back";
                          state.mode = zlib_inffast.BAD;
                          break top;
                        }
                      }
                      from = 0;
                      from_source = s_window;
                      if (wnext === 0) {
                        from += wsize - op;
                        if (op < len) {
                          len -= op;
                          do {
                            output[_out++] = s_window[from++];
                          } while (--op);
                          from = _out - dist;
                          from_source = output;
                        }
                      } else if (wnext < op) {
                        from += wsize + wnext - op;
                        op -= wnext;
                        if (op < len) {
                          len -= op;
                          do {
                            output[_out++] = s_window[from++];
                          } while (--op);
                          from = 0;
                          if (wnext < len) {
                            op = wnext;
                            len -= op;
                            do {
                              output[_out++] = s_window[from++];
                            } while (--op);
                            from = _out - dist;
                            from_source = output;
                          }
                        }
                      } else {
                        from += wnext - op;
                        if (op < len) {
                          len -= op;
                          do {
                            output[_out++] = s_window[from++];
                          } while (--op);
                          from = _out - dist;
                          from_source = output;
                        }
                      }
                      while (len > 2) {
                        output[_out++] = from_source[from++];
                        output[_out++] = from_source[from++];
                        output[_out++] = from_source[from++];
                        len -= 3;
                      }
                      if (len) {
                        output[_out++] = from_source[from++];
                        if (len > 1) {
                          output[_out++] = from_source[from++];
                        }
                      }
                    } else {
                      from = _out - dist;
                      do {
                        output[_out++] = output[from++];
                        output[_out++] = output[from++];
                        output[_out++] = output[from++];
                        len -= 3;
                      } while (len > 2);
                      if (len) {
                        output[_out++] = output[from++];
                        if (len > 1) {
                          output[_out++] = output[from++];
                        }
                      }
                    }
                  } else if ((op & 64) === 0) {
                    here = dcode[(here & 65535) + (hold & (1 << op) - 1)];
                    continue dodist;
                  } else {
                    strm.msg = "invalid distance code";
                    state.mode = zlib_inffast.BAD;
                    break top;
                  }
                  break;
                }
            } else if ((op & 64) === 0) {
              here = lcode[(here & 65535) + (hold & (1 << op) - 1)];
              continue dolen;
            } else if (op & 32) {
              state.mode = zlib_inffast.TYPE;
              break top;
            } else {
              strm.msg = "invalid literal/length code";
              state.mode = zlib_inffast.BAD;
              break top;
            }
            break;
          }
      } while (_in < last && _out < end);
    len = bits >> 3;
    _in -= len;
    bits -= len << 3;
    hold &= (1 << bits) - 1;
    strm.next_in = _in;
    strm.next_out = _out;
    strm.avail_in = _in < last ? 5 + (last - _in) : 5 - (_in - last);
    strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);
    state.hold = hold;
    state.bits = bits;
    return;
  }
};
zlib_inffast.BAD = 30;
zlib_inffast.TYPE = 12;

// obj/full/Pako/zlib/inflate.js
"use strict";
var zlib_InflateState = class {
  constructor() {
    this.mode = 0;
    this.last = 0;
    this.wrap = 0;
    this.havedict = 0;
    this.flags = 0;
    this.dmax = 0;
    this.check = 0;
    this.total = 0;
    this.head = null;
    this.wbits = 0;
    this.wsize = 0;
    this.whave = 0;
    this.wnext = 0;
    this.window = null;
    this.hold = 0;
    this.bits = 0;
    this.length = 0;
    this.offset = 0;
    this.extra = 0;
    this.lencode = null;
    this.distcode = null;
    this.lenbits = 0;
    this.distbits = 0;
    this.ncode = 0;
    this.nlen = 0;
    this.ndist = 0;
    this.have = 0;
    this.next = null;
    this.lens = new Uint16Array(320);
    this.work = new Uint16Array(288);
    this.lendyn = null;
    this.distdyn = null;
    this.sane = 0;
    this.back = 0;
    this.was = 0;
  }
};
var zlib_inflate = class {
  static zswap32(q) {
    return (q >>> 24 & 255) + (q >>> 8 & 65280) + ((q & 65280) << 8) + ((q & 255) << 24);
  }
  static inflateResetKeep(strm) {
    if (!strm || !strm.state) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    let state = strm.state;
    strm.total_in = strm.total_out = state.total = 0;
    strm.msg = "";
    if (state.wrap) {
      strm.adler = state.wrap & 1;
    }
    state.mode = zlib_inflate.HEAD;
    state.last = 0;
    state.havedict = 0;
    state.dmax = 32768;
    state.head = null;
    state.hold = 0;
    state.bits = 0;
    state.lencode = state.lendyn = new Int32Array(zlib_inflate.ENOUGH_LENS);
    state.distcode = state.distdyn = new Int32Array(zlib_inflate.ENOUGH_DISTS);
    state.sane = 1;
    state.back = -1;
    return zlib_constants.Z_OK;
  }
  static inflateReset(strm) {
    if (!strm || !strm.state) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    const state = strm.state;
    state.wsize = 0;
    state.whave = 0;
    state.wnext = 0;
    return zlib_inflate.inflateResetKeep(strm);
  }
  static inflateReset2(strm, windowBits) {
    let wrap;
    if (!strm || !strm.state) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    let state = strm.state;
    if (windowBits < 0) {
      wrap = 0;
      windowBits = -windowBits;
    } else {
      wrap = (windowBits >> 4) + 1;
      if (windowBits < 48) {
        windowBits &= 15;
      }
    }
    if (windowBits && (windowBits < 8 || windowBits > 15)) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    if (state.window !== null && state.wbits !== windowBits) {
      state.window = null;
    }
    state.wrap = wrap;
    state.wbits = windowBits;
    return zlib_inflate.inflateReset(strm);
  }
  static inflateInit2(strm, windowBits) {
    if (!strm) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    let state = new zlib_InflateState();
    strm.state = state;
    state.window = null;
    const ret = zlib_inflate.inflateReset2(strm, windowBits);
    if (ret !== zlib_constants.Z_OK) {
      strm.state = null;
    }
    return ret;
  }
  static inflateInit(strm) {
    return zlib_inflate.inflateInit2(strm, zlib_inflate.DEF_WBITS);
  }
  static fixedtables(state) {
    if (zlib_inflate.virgin) {
      zlib_inflate.lenfix = new Int32Array(512);
      zlib_inflate.distfix = new Int32Array(32);
      let sym = 0;
      while (sym < 144) {
        state.lens[sym++] = 8;
      }
      while (sym < 256) {
        state.lens[sym++] = 9;
      }
      while (sym < 280) {
        state.lens[sym++] = 7;
      }
      while (sym < 288) {
        state.lens[sym++] = 8;
      }
      zlib_inftrees.inflate_table(zlib_inflate.LENS, state.lens, 0, 288, zlib_inflate.lenfix, 0, state.work, {bits: 9});
      sym = 0;
      while (sym < 32) {
        state.lens[sym++] = 5;
      }
      zlib_inftrees.inflate_table(zlib_inflate.DISTS, state.lens, 0, 32, zlib_inflate.distfix, 0, state.work, {bits: 5});
      zlib_inflate.virgin = false;
    }
    state.lencode = zlib_inflate.lenfix;
    state.lenbits = 9;
    state.distcode = zlib_inflate.distfix;
    state.distbits = 5;
  }
  static updatewindow(strm, src, end, copy) {
    let dist;
    const state = strm.state;
    if (state.window === null) {
      state.wsize = 1 << state.wbits;
      state.wnext = 0;
      state.whave = 0;
      state.window = new Uint8Array(state.wsize);
    }
    if (copy >= state.wsize) {
      state.window.set(src.subarray(end - state.wsize, end), 0);
      state.wnext = 0;
      state.whave = state.wsize;
    } else {
      dist = state.wsize - state.wnext;
      if (dist > copy) {
        dist = copy;
      }
      state.window.set(src.subarray(end - copy, end - copy + dist), state.wnext);
      copy -= dist;
      if (copy) {
        state.window.set(src.subarray(end - copy, end), 0);
        state.wnext = copy;
        state.whave = state.wsize;
      } else {
        state.wnext += dist;
        if (state.wnext === state.wsize) {
          state.wnext = 0;
        }
        if (state.whave < state.wsize) {
          state.whave += dist;
        }
      }
    }
    return 0;
  }
  static inflate(strm, flush) {
    let state;
    let input, output;
    let next;
    let put;
    let have, left;
    let hold;
    let bits;
    let _in;
    let _out;
    let copy;
    let from;
    let from_source;
    let here = 0;
    let here_bits;
    let here_op;
    let here_val;
    let last_bits;
    let last_op;
    let last_val;
    let len;
    let ret;
    const hbuf = new Uint8Array(4);
    let opts;
    let n;
    let order = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
    if (!strm || !strm.state || !strm.output || !strm.input && strm.avail_in !== 0) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    state = strm.state;
    if (state.mode === zlib_inflate.TYPE) {
      state.mode = zlib_inflate.TYPEDO;
    }
    put = strm.next_out;
    output = strm.output;
    left = strm.avail_out;
    next = strm.next_in;
    input = strm.input;
    have = strm.avail_in;
    hold = state.hold;
    bits = state.bits;
    _in = have;
    _out = left;
    ret = zlib_constants.Z_OK;
    inf_leave:
      for (; ; ) {
        switch (state.mode) {
          case zlib_inflate.HEAD:
            if (state.wrap === 0) {
              state.mode = zlib_inflate.TYPEDO;
              break;
            }
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (state.wrap & 2 && hold === 35615) {
              state.check = 0;
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              state.check = zlib_crc32.crc32(state.check, hbuf, 2, 0);
              hold = 0;
              bits = 0;
              state.mode = zlib_inflate.FLAGS;
              break;
            }
            state.flags = 0;
            if (state.head) {
              state.head.done = false;
            }
            if (!(state.wrap & 1) || (((hold & 255) << 8) + (hold >> 8)) % 31) {
              strm.msg = "incorrect header check";
              state.mode = zlib_inflate.BAD;
              break;
            }
            if ((hold & 15) !== zlib_constants.Z_DEFLATED) {
              strm.msg = "unknown compression method";
              state.mode = zlib_inflate.BAD;
              break;
            }
            hold >>>= 4;
            bits -= 4;
            len = (hold & 15) + 8;
            if (state.wbits === 0) {
              state.wbits = len;
            } else if (len > state.wbits) {
              strm.msg = "invalid window size";
              state.mode = zlib_inflate.BAD;
              break;
            }
            state.dmax = 1 << state.wbits;
            strm.adler = state.check = 1;
            state.mode = hold & 512 ? zlib_inflate.DICTID : zlib_inflate.TYPE;
            hold = 0;
            bits = 0;
            break;
          case zlib_inflate.FLAGS:
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.flags = hold;
            if ((state.flags & 255) !== zlib_constants.Z_DEFLATED) {
              strm.msg = "unknown compression method";
              state.mode = zlib_inflate.BAD;
              break;
            }
            if (state.flags & 57344) {
              strm.msg = "unknown header flags set";
              state.mode = zlib_inflate.BAD;
              break;
            }
            if (state.head) {
              state.head.text = hold >> 8 & 1;
            }
            if (state.flags & 512) {
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              state.check = zlib_crc32.crc32(state.check, hbuf, 2, 0);
            }
            hold = 0;
            bits = 0;
            state.mode = zlib_inflate.TIME;
          case zlib_inflate.TIME:
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (state.head) {
              state.head.time = hold;
            }
            if (state.flags & 512) {
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              hbuf[2] = hold >>> 16 & 255;
              hbuf[3] = hold >>> 24 & 255;
              state.check = zlib_crc32.crc32(state.check, hbuf, 4, 0);
            }
            hold = 0;
            bits = 0;
            state.mode = zlib_inflate.OS;
          case zlib_inflate.OS:
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (state.head) {
              state.head.xflags = hold & 255;
              state.head.os = hold >> 8;
            }
            if (state.flags & 512) {
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              state.check = zlib_crc32.crc32(state.check, hbuf, 2, 0);
            }
            hold = 0;
            bits = 0;
            state.mode = zlib_inflate.EXLEN;
          case zlib_inflate.EXLEN:
            if (state.flags & 1024) {
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.length = hold;
              if (state.head) {
                state.head.extra_len = hold;
              }
              if (state.flags & 512) {
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                state.check = zlib_crc32.crc32(state.check, hbuf, 2, 0);
              }
              hold = 0;
              bits = 0;
            } else if (state.head) {
              state.head.extra = null;
            }
            state.mode = zlib_inflate.EXTRA;
          case zlib_inflate.EXTRA:
            if (state.flags & 1024) {
              copy = state.length;
              if (copy > have) {
                copy = have;
              }
              if (copy) {
                if (state.head) {
                  len = state.head.extra_len - state.length;
                  if (!state.head.extra) {
                    state.head.extra = new Uint8Array(state.head.extra_len);
                  }
                  state.head.extra.set(input.subarray(next, next + copy), len);
                }
                if (state.flags & 512) {
                  state.check = zlib_crc32.crc32(state.check, input, copy, next);
                }
                have -= copy;
                next += copy;
                state.length -= copy;
              }
              if (state.length) {
                break inf_leave;
              }
            }
            state.length = 0;
            state.mode = zlib_inflate.NAME;
          case zlib_inflate.NAME:
            if (state.flags & 2048) {
              if (have === 0) {
                break inf_leave;
              }
              copy = 0;
              do {
                len = input[next + copy++];
                if (state.head && len && state.length < 65536) {
                  state.head.name += String.fromCharCode(len);
                }
              } while (len && copy < have);
              if (state.flags & 512) {
                state.check = zlib_crc32.crc32(state.check, input, copy, next);
              }
              have -= copy;
              next += copy;
              if (len) {
                break inf_leave;
              }
            } else if (state.head) {
              state.head.name = null;
            }
            state.length = 0;
            state.mode = zlib_inflate.COMMENT;
          case zlib_inflate.COMMENT:
            if (state.flags & 4096) {
              if (have === 0) {
                break inf_leave;
              }
              copy = 0;
              do {
                len = input[next + copy++];
                if (state.head && len && state.length < 65536) {
                  state.head.comment += String.fromCharCode(len);
                }
              } while (len && copy < have);
              if (state.flags & 512) {
                state.check = zlib_crc32.crc32(state.check, input, copy, next);
              }
              have -= copy;
              next += copy;
              if (len) {
                break inf_leave;
              }
            } else if (state.head) {
              state.head.comment = null;
            }
            state.mode = zlib_inflate.HCRC;
          case zlib_inflate.HCRC:
            if (state.flags & 512) {
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (hold !== (state.check & 65535)) {
                strm.msg = "header crc mismatch";
                state.mode = zlib_inflate.BAD;
                break;
              }
              hold = 0;
              bits = 0;
            }
            if (state.head) {
              state.head.hcrc = state.flags >> 9 & 1;
              state.head.done = true;
            }
            strm.adler = state.check = 0;
            state.mode = zlib_inflate.TYPE;
            break;
          case zlib_inflate.DICTID:
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            strm.adler = state.check = zlib_inflate.zswap32(hold);
            hold = 0;
            bits = 0;
            state.mode = zlib_inflate.DICT;
          case zlib_inflate.DICT:
            if (!state.havedict) {
              strm.next_out = put;
              strm.avail_out = left;
              strm.next_in = next;
              strm.avail_in = have;
              state.hold = hold;
              state.bits = bits;
              return zlib_constants.Z_NEED_DICT;
            }
            strm.adler = state.check = 1;
            state.mode = zlib_inflate.TYPE;
          case zlib_inflate.TYPE:
            if (flush === zlib_constants.Z_BLOCK || flush === zlib_constants.Z_TREES) {
              break inf_leave;
            }
          case zlib_inflate.TYPEDO:
            if (state.last) {
              hold >>>= bits & 7;
              bits -= bits & 7;
              state.mode = zlib_inflate.CHECK;
              break;
            }
            while (bits < 3) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.last = hold & 1;
            hold >>>= 1;
            bits -= 1;
            switch (hold & 3) {
              case 0:
                state.mode = zlib_inflate.STORED;
                break;
              case 1:
                zlib_inflate.fixedtables(state);
                state.mode = zlib_inflate.LEN_;
                if (flush === zlib_constants.Z_TREES) {
                  hold >>>= 2;
                  bits -= 2;
                  break inf_leave;
                }
                break;
              case 2:
                state.mode = zlib_inflate.TABLE;
                break;
              case 3:
                strm.msg = "invalid block type";
                state.mode = zlib_inflate.BAD;
            }
            hold >>>= 2;
            bits -= 2;
            break;
          case zlib_inflate.STORED:
            hold >>>= bits & 7;
            bits -= bits & 7;
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if ((hold & 65535) !== (hold >>> 16 ^ 65535)) {
              strm.msg = "invalid stored block lengths";
              state.mode = zlib_inflate.BAD;
              break;
            }
            state.length = hold & 65535;
            hold = 0;
            bits = 0;
            state.mode = zlib_inflate.COPY_;
            if (flush === zlib_constants.Z_TREES) {
              break inf_leave;
            }
          case zlib_inflate.COPY_:
            state.mode = zlib_inflate.COPY;
          case zlib_inflate.COPY:
            copy = state.length;
            if (copy) {
              if (copy > have) {
                copy = have;
              }
              if (copy > left) {
                copy = left;
              }
              if (copy === 0) {
                break inf_leave;
              }
              output.set(input.subarray(next, next + copy), put);
              have -= copy;
              next += copy;
              left -= copy;
              put += copy;
              state.length -= copy;
              break;
            }
            state.mode = zlib_inflate.TYPE;
            break;
          case zlib_inflate.TABLE:
            while (bits < 14) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.nlen = (hold & 31) + 257;
            hold >>>= 5;
            bits -= 5;
            state.ndist = (hold & 31) + 1;
            hold >>>= 5;
            bits -= 5;
            state.ncode = (hold & 15) + 4;
            hold >>>= 4;
            bits -= 4;
            if (state.nlen > 286 || state.ndist > 30) {
              strm.msg = "too many length or distance symbols";
              state.mode = zlib_inflate.BAD;
              break;
            }
            state.have = 0;
            state.mode = zlib_inflate.LENLENS;
          case zlib_inflate.LENLENS:
            while (state.have < state.ncode) {
              while (bits < 3) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.lens[order[state.have++]] = hold & 7;
              hold >>>= 3;
              bits -= 3;
            }
            while (state.have < 19) {
              state.lens[order[state.have++]] = 0;
            }
            state.lencode = state.lendyn;
            state.lenbits = 7;
            opts = {bits: state.lenbits};
            ret = zlib_inftrees.inflate_table(zlib_inflate.CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
            state.lenbits = opts.bits;
            if (ret) {
              strm.msg = "invalid code lengths set";
              state.mode = zlib_inflate.BAD;
              break;
            }
            state.have = 0;
            state.mode = zlib_inflate.CODELENS;
          case zlib_inflate.CODELENS:
            while (state.have < state.nlen + state.ndist) {
              for (; ; ) {
                here = state.lencode[hold & (1 << state.lenbits) - 1];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (here_val < 16) {
                hold >>>= here_bits;
                bits -= here_bits;
                state.lens[state.have++] = here_val;
              } else {
                if (here_val === 16) {
                  n = here_bits + 2;
                  while (bits < n) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  hold >>>= here_bits;
                  bits -= here_bits;
                  if (state.have === 0) {
                    strm.msg = "invalid bit length repeat";
                    state.mode = zlib_inflate.BAD;
                    break;
                  }
                  len = state.lens[state.have - 1];
                  copy = 3 + (hold & 3);
                  hold >>>= 2;
                  bits -= 2;
                } else if (here_val === 17) {
                  n = here_bits + 3;
                  while (bits < n) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  hold >>>= here_bits;
                  bits -= here_bits;
                  len = 0;
                  copy = 3 + (hold & 7);
                  hold >>>= 3;
                  bits -= 3;
                } else {
                  n = here_bits + 7;
                  while (bits < n) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  hold >>>= here_bits;
                  bits -= here_bits;
                  len = 0;
                  copy = 11 + (hold & 127);
                  hold >>>= 7;
                  bits -= 7;
                }
                if (state.have + copy > state.nlen + state.ndist) {
                  strm.msg = "invalid bit length repeat";
                  state.mode = zlib_inflate.BAD;
                  break;
                }
                while (copy--) {
                  state.lens[state.have++] = len;
                }
              }
            }
            if (state.mode === zlib_inflate.BAD) {
              break;
            }
            if (state.lens[256] === 0) {
              strm.msg = "invalid code -- missing end-of-block";
              state.mode = zlib_inflate.BAD;
              break;
            }
            state.lenbits = 9;
            opts = {bits: state.lenbits};
            ret = zlib_inftrees.inflate_table(zlib_inflate.LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
            state.lenbits = opts.bits;
            if (ret) {
              strm.msg = "invalid literal/lengths set";
              state.mode = zlib_inflate.BAD;
              break;
            }
            state.distbits = 6;
            state.distcode = state.distdyn;
            opts = {bits: state.distbits};
            ret = zlib_inftrees.inflate_table(zlib_inflate.DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
            state.distbits = opts.bits;
            if (ret) {
              strm.msg = "invalid distances set";
              state.mode = zlib_inflate.BAD;
              break;
            }
            state.mode = zlib_inflate.LEN_;
            if (flush === zlib_constants.Z_TREES) {
              break inf_leave;
            }
          case zlib_inflate.LEN_:
            state.mode = zlib_inflate.LEN;
          case zlib_inflate.LEN:
            if (have >= 6 && left >= 258) {
              strm.next_out = put;
              strm.avail_out = left;
              strm.next_in = next;
              strm.avail_in = have;
              state.hold = hold;
              state.bits = bits;
              zlib_inffast.inflate_fast(strm, _out);
              put = strm.next_out;
              output = strm.output;
              left = strm.avail_out;
              next = strm.next_in;
              input = strm.input;
              have = strm.avail_in;
              hold = state.hold;
              bits = state.bits;
              if (state.mode === zlib_inflate.TYPE) {
                state.back = -1;
              }
              break;
            }
            state.back = 0;
            for (; ; ) {
              here = state.lencode[hold & (1 << state.lenbits) - 1];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (here_op && (here_op & 240) === 0) {
              last_bits = here_bits;
              last_op = here_op;
              last_val = here_val;
              for (; ; ) {
                here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (last_bits + here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              hold >>>= last_bits;
              bits -= last_bits;
              state.back += last_bits;
            }
            hold >>>= here_bits;
            bits -= here_bits;
            state.back += here_bits;
            state.length = here_val;
            if (here_op === 0) {
              state.mode = zlib_inflate.LIT;
              break;
            }
            if (here_op & 32) {
              state.back = -1;
              state.mode = zlib_inflate.TYPE;
              break;
            }
            if (here_op & 64) {
              strm.msg = "invalid literal/length code";
              state.mode = zlib_inflate.BAD;
              break;
            }
            state.extra = here_op & 15;
            state.mode = zlib_inflate.LENEXT;
          case zlib_inflate.LENEXT:
            if (state.extra) {
              n = state.extra;
              while (bits < n) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.length += hold & (1 << state.extra) - 1;
              hold >>>= state.extra;
              bits -= state.extra;
              state.back += state.extra;
            }
            state.was = state.length;
            state.mode = zlib_inflate.DIST;
          case zlib_inflate.DIST:
            for (; ; ) {
              here = state.distcode[hold & (1 << state.distbits) - 1];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if ((here_op & 240) === 0) {
              last_bits = here_bits;
              last_op = here_op;
              last_val = here_val;
              for (; ; ) {
                here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (last_bits + here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              hold >>>= last_bits;
              bits -= last_bits;
              state.back += last_bits;
            }
            hold >>>= here_bits;
            bits -= here_bits;
            state.back += here_bits;
            if (here_op & 64) {
              strm.msg = "invalid distance code";
              state.mode = zlib_inflate.BAD;
              break;
            }
            state.offset = here_val;
            state.extra = here_op & 15;
            state.mode = zlib_inflate.DISTEXT;
          case zlib_inflate.DISTEXT:
            if (state.extra) {
              n = state.extra;
              while (bits < n) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.offset += hold & (1 << state.extra) - 1;
              hold >>>= state.extra;
              bits -= state.extra;
              state.back += state.extra;
            }
            state.mode = zlib_inflate.MATCH;
          case zlib_inflate.MATCH:
            if (left === 0) {
              break inf_leave;
            }
            copy = _out - left;
            if (state.offset > copy) {
              copy = state.offset - copy;
              if (copy > state.whave) {
                if (state.sane) {
                  strm.msg = "invalid distance too far back";
                  state.mode = zlib_inflate.BAD;
                  break;
                }
              }
              if (copy > state.wnext) {
                copy -= state.wnext;
                from = state.wsize - copy;
              } else {
                from = state.wnext - copy;
              }
              if (copy > state.length) {
                copy = state.length;
              }
              from_source = state.window;
            } else {
              from_source = output;
              from = put - state.offset;
              copy = state.length;
            }
            if (copy > left) {
              copy = left;
            }
            left -= copy;
            state.length -= copy;
            do {
              output[put++] = from_source[from++];
            } while (--copy);
            if (state.length === 0) {
              state.mode = zlib_inflate.LEN;
            }
            break;
          case zlib_inflate.LIT:
            if (left === 0) {
              break inf_leave;
            }
            output[put++] = state.length;
            left--;
            state.mode = zlib_inflate.LEN;
            break;
          case zlib_inflate.CHECK:
            if (state.wrap) {
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold |= input[next++] << bits;
                bits += 8;
              }
              _out -= left;
              strm.total_out += _out;
              state.total += _out;
              if (_out) {
                strm.adler = state.check = state.flags ? zlib_crc32.crc32(state.check, output, _out, put - _out) : zlib_adler32.adler32(state.check, output, _out, put - _out);
              }
              _out = left;
              if ((state.flags ? hold : zlib_inflate.zswap32(hold)) !== state.check) {
                strm.msg = "incorrect data check";
                state.mode = zlib_inflate.BAD;
                break;
              }
              hold = 0;
              bits = 0;
            }
            state.mode = zlib_inflate.LENGTH;
          case zlib_inflate.LENGTH:
            if (state.wrap && state.flags) {
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (hold !== (state.total & 4294967295)) {
                strm.msg = "incorrect length check";
                state.mode = zlib_inflate.BAD;
                break;
              }
              hold = 0;
              bits = 0;
            }
            state.mode = zlib_inflate.DONE;
          case zlib_inflate.DONE:
            ret = zlib_constants.Z_STREAM_END;
            break inf_leave;
          case zlib_inflate.BAD:
            ret = zlib_constants.Z_DATA_ERROR;
            break inf_leave;
          case zlib_inflate.MEM:
            return zlib_constants.Z_MEM_ERROR;
          case zlib_inflate.SYNC:
          default:
            return zlib_constants.Z_STREAM_ERROR;
        }
      }
    strm.next_out = put;
    strm.avail_out = left;
    strm.next_in = next;
    strm.avail_in = have;
    state.hold = hold;
    state.bits = bits;
    if (state.wsize || _out !== strm.avail_out && state.mode < zlib_inflate.BAD && (state.mode < zlib_inflate.CHECK || flush !== zlib_constants.Z_FINISH)) {
      if (zlib_inflate.updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) {
        state.mode = zlib_inflate.MEM;
        return zlib_constants.Z_MEM_ERROR;
      }
    }
    _in -= strm.avail_in;
    _out -= strm.avail_out;
    strm.total_in += _in;
    strm.total_out += _out;
    state.total += _out;
    if (state.wrap && _out) {
      strm.adler = state.check = state.flags ? zlib_crc32.crc32(state.check, output, _out, strm.next_out - _out) : zlib_adler32.adler32(state.check, output, _out, strm.next_out - _out);
    }
    strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === zlib_inflate.TYPE ? 128 : 0) + (state.mode === zlib_inflate.LEN_ || state.mode === zlib_inflate.COPY_ ? 256 : 0);
    if ((_in === 0 && _out === 0 || flush === zlib_constants.Z_FINISH) && ret === zlib_constants.Z_OK) {
      ret = zlib_constants.Z_BUF_ERROR;
    }
    return ret;
  }
  static inflateEnd(strm) {
    if (!strm || !strm.state) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    let state = strm.state;
    if (state.window) {
      state.window = null;
    }
    strm.state = null;
    return zlib_constants.Z_OK;
  }
  static inflateGetHeader(strm, head) {
    if (!strm || !strm.state) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    let state = strm.state;
    if ((state.wrap & 2) === 0) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    state.head = head;
    head.done = false;
    return zlib_constants.Z_OK;
  }
  static inflateSetDictionary(strm, dictionary) {
    const dictLength = dictionary.length;
    let state;
    let dictid;
    let ret;
    if (!strm || !strm.state) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    state = strm.state;
    if (state.wrap !== 0 && state.mode !== zlib_inflate.DICT) {
      return zlib_constants.Z_STREAM_ERROR;
    }
    if (state.mode === zlib_inflate.DICT) {
      dictid = 1;
      dictid = zlib_adler32.adler32(dictid, dictionary, dictLength, 0);
      if (dictid !== state.check) {
        return zlib_constants.Z_DATA_ERROR;
      }
    }
    ret = zlib_inflate.updatewindow(strm, dictionary, dictLength, dictLength);
    if (ret) {
      state.mode = zlib_inflate.MEM;
      return zlib_constants.Z_MEM_ERROR;
    }
    state.havedict = 1;
    return zlib_constants.Z_OK;
  }
};
zlib_inflate.CODES = 0;
zlib_inflate.LENS = 1;
zlib_inflate.DISTS = 2;
zlib_inflate.HEAD = 1;
zlib_inflate.FLAGS = 2;
zlib_inflate.TIME = 3;
zlib_inflate.OS = 4;
zlib_inflate.EXLEN = 5;
zlib_inflate.EXTRA = 6;
zlib_inflate.NAME = 7;
zlib_inflate.COMMENT = 8;
zlib_inflate.HCRC = 9;
zlib_inflate.DICTID = 10;
zlib_inflate.DICT = 11;
zlib_inflate.TYPE = 12;
zlib_inflate.TYPEDO = 13;
zlib_inflate.STORED = 14;
zlib_inflate.COPY_ = 15;
zlib_inflate.COPY = 16;
zlib_inflate.TABLE = 17;
zlib_inflate.LENLENS = 18;
zlib_inflate.CODELENS = 19;
zlib_inflate.LEN_ = 20;
zlib_inflate.LEN = 21;
zlib_inflate.LENEXT = 22;
zlib_inflate.DIST = 23;
zlib_inflate.DISTEXT = 24;
zlib_inflate.MATCH = 25;
zlib_inflate.LIT = 26;
zlib_inflate.CHECK = 27;
zlib_inflate.LENGTH = 28;
zlib_inflate.DONE = 29;
zlib_inflate.BAD = 30;
zlib_inflate.MEM = 31;
zlib_inflate.SYNC = 32;
zlib_inflate.ENOUGH_LENS = 852;
zlib_inflate.ENOUGH_DISTS = 592;
zlib_inflate.MAX_WBITS = 15;
zlib_inflate.DEF_WBITS = zlib_inflate.MAX_WBITS;
zlib_inflate.virgin = true;

// obj/full/Pako/zlib/messages.js
"use strict";
var zlib_messages = class {
  static msg(index) {
    switch (index) {
      case 2:
        return "need dictionary";
      case 1:
        return "stream end";
      case 0:
        return "";
      case -1:
        return "file error";
      case -2:
        return "stream error";
      case -3:
        return "data error";
      case -4:
        return "insufficient memory";
      case -5:
        return "buffer error";
      case -6:
        return "incompatible version";
      default:
        return "unknowwn error";
    }
  }
};

// obj/full/Pako/zlib/inftrees.js
"use strict";
var zlib_inftrees = class {
  static inflate_table(type, lens, lens_index, codes, table, table_index, work, opts) {
    const bits = opts.bits;
    let len;
    let sym;
    let min = 0;
    let max;
    let root;
    let curr = 0;
    let drop = 0;
    let left = 0;
    let used = 0;
    let huff = 0;
    let incr;
    let fill;
    let low;
    let mask;
    let next;
    let base;
    let base_index = 0;
    let end;
    const count = new Uint16Array(zlib_inftrees.MAXBITS + 1);
    const offs = new Uint16Array(zlib_inftrees.MAXBITS + 1);
    let extra;
    let extra_index = 0;
    let here_bits;
    let here_op;
    let here_val;
    for (len = 0; len <= zlib_inftrees.MAXBITS; len++) {
      count[len] = 0;
    }
    for (sym = 0; sym < codes; sym++) {
      count[lens[lens_index + sym]]++;
    }
    root = bits;
    for (max = zlib_inftrees.MAXBITS; max >= 1; max--) {
      if (count[max] !== 0) {
        break;
      }
    }
    if (root > max) {
      root = max;
    }
    if (max === 0) {
      table[table_index++] = 1 << 24 | 64 << 16 | 0;
      table[table_index++] = 1 << 24 | 64 << 16 | 0;
      opts.bits = 1;
      return 0;
    }
    for (min = 1; min < max; min++) {
      if (count[min] !== 0) {
        break;
      }
    }
    if (root < min) {
      root = min;
    }
    left = 1;
    for (len = 1; len <= zlib_inftrees.MAXBITS; len++) {
      left <<= 1;
      left -= count[len];
      if (left < 0) {
        return -1;
      }
    }
    if (left > 0 && (type === zlib_inftrees.CODES || max !== 1)) {
      return -1;
    }
    offs[1] = 0;
    for (len = 1; len < zlib_inftrees.MAXBITS; len++) {
      offs[len + 1] = offs[len] + count[len];
    }
    for (sym = 0; sym < codes; sym++) {
      if (lens[lens_index + sym] !== 0) {
        work[offs[lens[lens_index + sym]]++] = sym;
      }
    }
    if (type === zlib_inftrees.CODES) {
      base = work;
      extra = new Uint8Array();
      end = 19;
    } else if (type === zlib_inftrees.LENS) {
      base = zlib_inftrees.lbase;
      base_index -= 257;
      extra = zlib_inftrees.lext;
      extra_index -= 257;
      end = 256;
    } else {
      base = zlib_inftrees.dbase;
      extra = zlib_inftrees.dext;
      end = -1;
    }
    huff = 0;
    sym = 0;
    len = min;
    next = table_index;
    curr = root;
    drop = 0;
    low = -1;
    used = 1 << root;
    mask = used - 1;
    if (type === zlib_inftrees.LENS && used > zlib_inftrees.ENOUGH_LENS || type === zlib_inftrees.DISTS && used > zlib_inftrees.ENOUGH_DISTS) {
      return 1;
    }
    for (; ; ) {
      here_bits = len - drop;
      if (work[sym] < end) {
        here_op = 0;
        here_val = work[sym];
      } else if (work[sym] > end) {
        here_op = extra[extra_index + work[sym]];
        here_val = base[base_index + work[sym]];
      } else {
        here_op = 32 + 64;
        here_val = 0;
      }
      incr = 1 << len - drop;
      fill = 1 << curr;
      min = fill;
      do {
        fill -= incr;
        table[next + (huff >> drop) + fill] = here_bits << 24 | here_op << 16 | here_val | 0;
      } while (fill !== 0);
      incr = 1 << len - 1;
      while (huff & incr) {
        incr >>= 1;
      }
      if (incr !== 0) {
        huff &= incr - 1;
        huff += incr;
      } else {
        huff = 0;
      }
      sym++;
      if (--count[len] === 0) {
        if (len === max) {
          break;
        }
        len = lens[lens_index + work[sym]];
      }
      if (len > root && (huff & mask) !== low) {
        if (drop === 0) {
          drop = root;
        }
        next += min;
        curr = len - drop;
        left = 1 << curr;
        while (curr + drop < max) {
          left -= count[curr + drop];
          if (left <= 0) {
            break;
          }
          curr++;
          left <<= 1;
        }
        used += 1 << curr;
        if (type === zlib_inftrees.LENS && used > zlib_inftrees.ENOUGH_LENS || type === zlib_inftrees.DISTS && used > zlib_inftrees.ENOUGH_DISTS) {
          return 1;
        }
        low = huff & mask;
        table[low] = root << 24 | curr << 16 | next - table_index | 0;
      }
    }
    if (huff !== 0) {
      table[next + huff] = len - drop << 24 | 64 << 16 | 0;
    }
    opts.bits = root;
    return 0;
  }
};
zlib_inftrees.MAXBITS = 15;
zlib_inftrees.ENOUGH_LENS = 852;
zlib_inftrees.ENOUGH_DISTS = 592;
zlib_inftrees.CODES = 0;
zlib_inftrees.LENS = 1;
zlib_inftrees.DISTS = 2;
zlib_inftrees.lbase = new Uint16Array([
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  13,
  15,
  17,
  19,
  23,
  27,
  31,
  35,
  43,
  51,
  59,
  67,
  83,
  99,
  115,
  131,
  163,
  195,
  227,
  258,
  0,
  0
]);
zlib_inftrees.lext = new Uint8Array([
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  17,
  17,
  17,
  17,
  18,
  18,
  18,
  18,
  19,
  19,
  19,
  19,
  20,
  20,
  20,
  20,
  21,
  21,
  21,
  21,
  16,
  72,
  78
]);
zlib_inftrees.dbase = new Uint16Array([
  1,
  2,
  3,
  4,
  5,
  7,
  9,
  13,
  17,
  25,
  33,
  49,
  65,
  97,
  129,
  193,
  257,
  385,
  513,
  769,
  1025,
  1537,
  2049,
  3073,
  4097,
  6145,
  8193,
  12289,
  16385,
  24577,
  0,
  0
]);
zlib_inftrees.dext = new Uint8Array([
  16,
  16,
  16,
  16,
  17,
  17,
  18,
  18,
  19,
  19,
  20,
  20,
  21,
  21,
  22,
  22,
  23,
  23,
  24,
  24,
  25,
  25,
  26,
  26,
  27,
  27,
  28,
  28,
  29,
  29,
  64,
  64
]);

// obj/full/Pako/zlib/zstream.js
"use strict";
var zlib_ZStream = class {
  constructor() {
    this.input = null;
    this.next_in = 0;
    this.avail_in = 0;
    this.total_in = 0;
    this.output = null;
    this.next_out = 0;
    this.avail_out = 0;
    this.total_out = 0;
    this.msg = "";
    this.state = null;
    this.data_type = 2;
    this.adler = 0;
  }
};

// obj/full/webPage.js
var YWebPage = class {
  edit(widgetIndex) {
    YWebPage.widgets[widgetIndex].edit();
  }
  static get editMenuItem() {
    return YWebPage._editMenuItem;
  }
  static get deleteMenuItem() {
    return YWebPage._deleteMenuItem;
  }
  static get disableMarkerMenuItem() {
    return YWebPage._disableMarkerMenuItem;
  }
  static get clearDataloggerMenuItem() {
    return YWebPage._clearDataloggerMenuItem;
  }
  static get addMarkerMenuItem() {
    return YWebPage._addMarkerMenuItem;
  }
  static get markersSubMenuItems() {
    return YWebPage._markersSubMenuItems;
  }
  static get contextMarkerSubMenu() {
    return YWebPage._contextMarkerSubMenu;
  }
  static get contextWidgetsSubMenu() {
    return YWebPage._contextWidgetsSubMenu;
  }
  static get resetDataViewMenuItem() {
    return YWebPage._resetDataViewMenuItem;
  }
  static get snapshotMenuItem() {
    return YWebPage._snapshotMenuItem;
  }
  static applicationGlobalinit() {
    if (YWebPage._MarkerCountPerXaxis == 0) {
      let xAxisProp = new XaxisDescription();
      let propDesc = GenericProperties.getAllProperties(xAxisProp);
      for (let propname in propDesc.byName) {
        if (propname.startsWith("markers"))
          YWebPage._MarkerCountPerXaxis++;
      }
    }
    if (YWebPage.manager == null)
      YWebPage.manager = new sensorsManager();
    if (!YWebPage.readonly && YWebPage._editor == null)
      YWebPage._editor = new PropertiesForm2();
    if (!YWebPage.readonly && YWebPage._mainform == null)
      YWebPage._mainform = new mainForm();
    if (YWebPage._contextMenu == null) {
      YWebPage._contextMenu = new ContextMenu(YWebPage.baseSize, (mouseX, mouseY) => {
        YWebPage.menuIsOpening(mouseX, mouseY);
      }, constants.generalFontFamily);
      YWebPage._contextMarkerSubMenu = new ContextSubMenu(YWebPage.baseSize, YWebPage._contextMenu, null, constants.generalFontFamily);
      for (let i = 0; i < YWebPage._MarkerCountPerXaxis; i++) {
        YWebPage._markersSubMenuItems.push(YWebPage._contextMarkerSubMenu.addMenuItem(ressources.AddMarkerIcon(YWebPage.baseSize.toString(), i + 1), "Place marker " + (i + 1).toString(), () => {
          let target = YWebPage._markersSubMenuItems[i].userdata;
          target.startMarkerCapture(i);
        }));
      }
      if (!YWebPage.readonly) {
        YWebPage._contextWidgetsSubMenu = new ContextSubMenu(YWebPage.baseSize, YWebPage._contextMenu, (mouseX, mouseY) => {
          YWebPage.WidgetsSubMenuIsOpening(mouseX, mouseY);
        }, constants.generalFontFamily);
        YWebPage._widgetsMenuItem = YWebPage._contextMenu.addSubMenuItem(ressources.AllIcon(YWebPage.baseSize.toString(), false, false, false, false), "All widgets", YWebPage._contextWidgetsSubMenu);
        YWebPage._editMenuItem = YWebPage._contextMenu.addMenuItem(ressources.EditIcon(YWebPage.baseSize.toString(), false, false, false, false), "Configure this widget", () => {
          YWebPage.editWidget();
        });
        YWebPage._deleteMenuItem = YWebPage._contextMenu.addMenuItem(ressources.TrashIcon(YWebPage.baseSize.toString(), false, false, false, false), "Delete this widget", () => {
          YWebPage.deleteWidget();
        });
        YWebPage._editMenuItem.visible = false;
        YWebPage._deleteMenuItem.visible = false;
      }
      YWebPage._resetDataViewMenuItem = YWebPage._contextMenu.addMenuItem(ressources.resetViewPort(YWebPage.baseSize.toString(), false, false, false, false), "Reset dataview", () => {
        YWebPage.resetDataView();
      });
      YWebPage._resetDataViewMenuItem.visible = false;
      if (!YWebPage.readonly) {
        YWebPage._clearDataloggerMenuItem = YWebPage._contextMenu.addMenuItem(ressources.EraseDatalogger(YWebPage.baseSize.toString(), false, false, false, false), "Clear datalogger", () => {
          YWebPage.clearDatalogger();
        });
        YWebPage._resetDataViewMenuItem.visible = false;
      }
      YWebPage._contextMenu.AddSeparator();
      if (!YWebPage.readonly) {
        YWebPage._addMarkerMenuItem = YWebPage._contextMenu.addSubMenuItem(ressources.AddMarker(YWebPage.baseSize.toString(), false, true, true, false), "Place markers", YWebPage._contextMarkerSubMenu);
        YWebPage._disableMarkerMenuItem = YWebPage._contextMenu.addMenuItem(ressources.DeleteMarker(YWebPage.baseSize.toString(), false, true, false, true), "Disable Allmarkers", () => {
          YWebPage.disableAllMarker();
        });
        YWebPage._addMarkerMenuItem.visible = false;
        YWebPage._disableMarkerMenuItem.visible = false;
        YWebPage._contextMenu.AddSeparator();
        YWebPage._contextMenu.addMenuItem(ressources.SolidGaugeIcon(YWebPage.baseSize.toString(), false, true, true, false), "Add a new Solid gauge", () => {
          YWebPage.newGaugeWidget();
        });
        YWebPage._contextMenu.addMenuItem(ressources.AngularGaugeIcon(YWebPage.baseSize.toString(), false, true, true, false), "Add a new Angular gauge", () => {
          YWebPage.newAngularGaugeWidget();
        });
        YWebPage._contextMenu.addMenuItem(ressources.DigitalDisplayIcon(YWebPage.baseSize.toString(), false, true, true, false), "Add a new Digital Display", () => {
          YWebPage.newDigitalDisplayWidget();
        });
        YWebPage._contextMenu.addMenuItem(ressources.GraphIcon(YWebPage.baseSize.toString(), false, true, true, false), "Add a new Graph", () => {
          YWebPage.newGraphWidget();
        });
      }
      YWebPage._contextMenu.addMenuItem(ressources.RawDataIcon(YWebPage.baseSize.toString(), false, false, false, false), "Show raw data", () => {
        rawDataForm.show();
      });
      YWebPage._snapshotMenuItem = YWebPage._contextMenu.addMenuItem(ressources.snapshotIcon(YWebPage.baseSize.toString(), false, false, false, false), "Snapshot", () => {
        YWebPage.snapShot();
      });
      if (!YWebPage.readonly) {
        YWebPage._contextMenu.AddSeparator();
        YWebPage._contextMenu.addMenuItem(ressources.ConfigureIcon(YWebPage.baseSize.toString(), false, false, false, false), "Global configuration", () => {
          configForm.show();
        });
        YWebPage._contextMenu.addMenuItem(ressources.SaveIcon(YWebPage.baseSize.toString(), false, false, false, false), "Save now", () => {
          YWebPage.save(true);
        });
      }
      YWebPage._contextMenu.addMenuItem(ressources.LogFileIcon(YWebPage.baseSize.toString(), false, false, false, false), "Show logs", () => {
        YWebPage.showLogsWindow();
      });
    }
  }
  static RegisterDeviceArrivalCallback(arrivalCallback) {
    sensorsManager.RegisterDeviceArrivalCallback(arrivalCallback);
  }
  static RegisterDeviceRemovalCallback(removalCallback) {
    sensorsManager.RegisterDeviceRemovalCallback(removalCallback);
  }
  static WidgetsSubMenuIsOpening(mouseX, mouseY) {
    YWebPage._contextWidgetsSubMenu.clearAllContents();
    for (let i = 0; i < YWebPage.widgets.length; i++) {
      let icon = "";
      let subMenu = new ContextSubMenu(YWebPage.baseSize, YWebPage._contextWidgetsSubMenu, (mouseX2, mouseY2) => {
        YWebPage.specificWidgetSubMenuIsOpening(subMenu, mouseX2, mouseY2);
      }, constants.generalFontFamily);
      subMenu.userdata = YWebPage.widgets[i];
      if (YWebPage.widgets[i] instanceof graphWidget)
        icon = ressources.GraphIcon(YWebPage.baseSize.toString(), false, false, false, false);
      if (YWebPage.widgets[i] instanceof digitalDisplayWidget)
        icon = ressources.DigitalDisplayIcon(YWebPage.baseSize.toString(), false, false, false, false);
      if (YWebPage.widgets[i] instanceof gaugeWidget)
        icon = ressources.SolidGaugeIcon(YWebPage.baseSize.toString(), false, false, false, false);
      if (YWebPage.widgets[i] instanceof angularGaugeWidget)
        icon = ressources.AngularGaugeIcon(YWebPage.baseSize.toString(), false, false, false, false);
      YWebPage._contextWidgetsSubMenu.addSubMenuItem(icon, YWebPage.widgets[i].Text, subMenu);
    }
  }
  static specificWidgetSubMenuIsOpening(source, mouseX, mouseY) {
    if (source.menuItemsCount > 0)
      return;
    let w = source.userdata;
    source.addMenuItem(ressources.EditIcon(YWebPage.baseSize.toString(), false, false, false, false), "Configure", () => {
      w.edit();
    });
    source.addMenuItem(ressources.TrashIcon(YWebPage.baseSize.toString(), false, false, false, false), "Delete", () => {
      YWebPage.deleteWidget(w);
    });
    if (w instanceof graphWidget) {
      source.addMenuItem(ressources.resetViewPort(YWebPage.baseSize.toString(), false, false, false, false), "Reset dataview", () => {
        w.resetDataView();
      });
      source.addMenuItem(ressources.EraseDatalogger(YWebPage.baseSize.toString(), false, false, false, false), "Clear datalogger", () => {
        w.clearDataLogger();
      });
    }
  }
  static showLogsWindow() {
    logForm.show();
  }
  static snapShot() {
    let w = YWebPage._snapshotMenuItem.userdata;
    w.snapshot();
  }
  static menuIsOpening(mouseX, mouseY) {
    if (YWebPage.disableMarkerMenuItem != null)
      YWebPage.disableMarkerMenuItem.visible = false;
    if (YWebPage.addMarkerMenuItem != null)
      YWebPage.addMarkerMenuItem.visible = false;
    if (YWebPage.clearDataloggerMenuItem != null)
      YWebPage.clearDataloggerMenuItem.visible = false;
    if (YWebPage.editMenuItem != null)
      YWebPage.editMenuItem.visible = false;
    if (YWebPage.deleteMenuItem != null)
      YWebPage.deleteMenuItem.visible = false;
    YWebPage.resetDataViewMenuItem.visible = false;
    YWebPage.snapshotMenuItem.visible = false;
    for (let i = 0; i < YWebPage.widgets.length; i++) {
      YWebPage.widgets[i].contextMenuCallBack(mouseX, mouseY);
    }
    YWebPage._widgetsMenuItem.visible = !YWebPage.readonly && YWebPage.widgets.length > 0 && !YWebPage._editMenuItem.visible;
    YWebPage._contextMenu.refresh();
  }
  static resetDataView() {
    YWebPage._resetDataViewMenuItem.userdata.resetDataView();
  }
  static editWidget() {
    let w = YWebPage._editMenuItem.userdata;
    w.edit();
  }
  static disableAllMarker() {
    YWebPage._disableMarkerMenuItem.userdata.disableAllMarkers();
  }
  static clearDatalogger() {
    YWebPage._clearDataloggerMenuItem.userdata.clearDataLogger();
  }
  static deleteWidget(widget) {
    let w = typeof widget == "undefined" ? YWebPage._deleteMenuItem.userdata : widget;
    confirm.ask(w.confirmDeleteString, () => {
      if (!YWebPage.readonly && w.isBeingEdited && YWebPage._editor != null)
        YWebPage._editor.hide();
      w.delete();
      constants.edited = true;
      for (let i = YWebPage.widgets.length - 1; i >= 0; i--) {
        if (YWebPage.widgets[i] == w) {
          YWebPage.widgets.splice(i, 1);
        }
      }
      if (YWebPage.widgets.length <= 0 && YWebPage._mainform != null)
        YWebPage._mainform.show();
    }, null, null);
  }
  static FindUniqueNewName(prefix) {
    let n = 1;
    for (let i = 0; i < YWebPage.widgets.length; i++) {
      if (YWebPage.widgets[i].Text.startsWith(prefix))
        n++;
    }
    if (n > 1)
      prefix = prefix + " " + n.toString();
    return prefix;
  }
  static newGraphWidget() {
    let w = window.innerWidth / 2 >> 0;
    let h = window.innerHeight / 2 >> 0;
    if (w < 350)
      w = 350;
    if (h < 200)
      w = 200;
    let x = (window.innerWidth - w) / 2 >> 0;
    let y = (window.innerHeight - h) / 2 >> 0;
    let index = YWebPage.widgets.length;
    if (index > 0) {
      x = index * 25;
      y = index * 25;
    }
    let wdg = new graphWidget(null, YWebPage._editor, x, y, 765, 470);
    wdg.set_name(YWebPage.FindUniqueNewName("New Graph"));
    YWebPage.widgets.push(wdg);
    wdg.resize(w, h);
    if (this._mainform != null)
      this._mainform.hide();
    if (!YWebPage.readonly) {
      if (YWebPage._editor != null && YWebPage._editor.visible)
        wdg.edit();
    }
  }
  static newAngularGaugeWidget() {
    let s = Math.min(window.innerWidth, window.innerHeight) / 2;
    if (s < 350)
      s = 350;
    let x = (window.innerWidth - s) / 2 >> 0;
    let y = (window.innerHeight - s) / 2 >> 0;
    let w = s >> 0;
    let h = s >> 0;
    let index = YWebPage.widgets.length;
    if (index > 0) {
      x = index * 25;
      y = index * 25;
    }
    let wdg = new angularGaugeWidget(null, YWebPage._editor, x, y, 375, 300);
    wdg.set_name(YWebPage.FindUniqueNewName("New Angular Gauge"));
    YWebPage.widgets.push(wdg);
    wdg.resize(w, h);
    if (this._mainform != null)
      this._mainform.hide();
    if (!YWebPage.readonly) {
      if (YWebPage._editor != null && YWebPage._editor.visible)
        wdg.edit();
    }
  }
  static newGaugeWidget() {
    let s = Math.min(window.innerWidth, window.innerHeight) / 2;
    if (s < 350)
      s = 350;
    let x = (window.innerWidth - s) / 2 >> 0;
    let y = (window.innerHeight - s) / 2 >> 0;
    let w = s >> 0;
    let h = s >> 0;
    let index = YWebPage.widgets.length;
    if (index > 0) {
      x = index * 25;
      y = index * 25;
    }
    let wdg = new gaugeWidget(null, YWebPage._editor, x, y, 355, 201);
    wdg.set_name(YWebPage.FindUniqueNewName("New Solid Gauge"));
    YWebPage.widgets.push(wdg);
    wdg.resize(w, h);
    if (this._mainform != null)
      this._mainform.hide();
    if (!YWebPage.readonly) {
      if (YWebPage._editor != null && YWebPage._editor.visible)
        wdg.edit();
    }
  }
  static newDigitalDisplayWidget() {
    let s = Math.min(window.innerWidth, window.innerHeight) / 8;
    if (s < 90)
      s = 90;
    let x = (window.innerWidth - 4 * s) / 2 >> 0;
    let y = (window.innerHeight - s) / 2 >> 0;
    let w = 4 * s >> 0;
    let h = s >> 0;
    let index = YWebPage.widgets.length;
    if (index > 0) {
      x = index * 25;
      y = index * 25;
    }
    let wdg = new digitalDisplayWidget(null, YWebPage._editor, x, y, 410, 125);
    wdg.set_name(YWebPage.FindUniqueNewName("New Digital Display"));
    let n = 1;
    for (let i = 0; i < YWebPage.widgets.length; i++) {
      if (YWebPage.widgets[i].Text.startsWith(wdg.Text))
        n++;
    }
    if (n > 1)
      wdg.Text = wdg.Text + " " + n.toString();
    YWebPage.widgets.push(wdg);
    wdg.resize(w, h);
    if (this._mainform != null)
      this._mainform.hide();
    if (!YWebPage.readonly) {
      if (YWebPage._editor != null && YWebPage._editor.visible)
        wdg.edit();
    }
  }
  static refreshPropertiesForm() {
    if (!YWebPage.readonly && YWebPage._editor != null)
      YWebPage._editor.refresh();
  }
  static sensorListHaschanged() {
    YWebPage.refreshPropertiesForm();
  }
  static EmptyReadonlyConfig() {
    alert2.show("Yocto-Visualization Error\n\nConfiguration is both empty and read only, check configuration file.");
  }
  static async ForceReloadConfig(newXMLdata) {
    if (!YWebPage.readonly) {
      if (YWebPage._editor != null)
        YWebPage._editor.visible = false;
      configForm.hide();
      rawDataForm.hide();
      HubEdit.hide();
    }
    logForm.log("Reloading the whole configuration.");
    await sensorsManager.clearHublist();
    for (let i = YWebPage.widgets.length - 1; i >= 0; i--) {
      YWebPage.widgets[i].destroy();
      YWebPage.widgets.splice(i, 1);
    }
    YWebPage.loadFromXML(newXMLdata);
    constants.edited = false;
  }
  static ConfigChanged(newXMLdata) {
    if (YWebPage.ConfigChangedConfirmWindows != null) {
      YWebPage.ConfigChangedConfirmWindows.hide();
    }
    let newCRC = constants.crc32(newXMLdata);
    if (newCRC == YWebPage.xmlDataCRC)
      return;
    logForm.log("Config file changed behind our back!");
    if (!this.readonly) {
      YWebPage.ConfigChangedConfirmWindows = confirm.ask("Configuration has changed on server\nWould you like to reload it?", () => {
        YWebPage.ForceReloadConfig(newXMLdata);
        YWebPage.ConfigChangedConfirmWindows = null;
      }, () => {
        YWebPage.ConfigChangedConfirmWindows = null;
      }, null);
    } else {
      YWebPage.ForceReloadConfig(newXMLdata);
    }
    YWebPage.xmlDataCRC = newCRC;
    constants.edited = false;
  }
  static ShowSaveReminder(visible) {
    if (YWebPage.saveIntDiv == null) {
      YWebPage.saveIntDiv = document.createElement("DIV");
      YWebPage.saveIntDiv.style.position = "fixed";
      YWebPage.saveIntDiv.style.left = "5px";
      YWebPage.saveIntDiv.style.top = "5px";
      YWebPage.saveIntDiv.style.zIndex = "200000";
      YWebPage.saveIntDiv.style.cursor = "pointer";
      YWebPage.saveIntDiv.innerHTML = ressources.SaveNeededIcon((48 * constants.guiDPIFactor).toString(), false, false, false, false);
      YWebPage.saveIntDiv.addEventListener("click", () => {
        YWebPage.saveIntDiv.style.display = "none";
        YWebPage.save(true);
      });
      document.body.appendChild(YWebPage.saveIntDiv);
    }
    YWebPage.saveIntDiv.style.display = visible ? "" : "none";
  }
  static loadFromXML(xmlData) {
    if (xmlData == "") {
      if (!YWebPage.readonly && YWebPage._mainform != null) {
        YWebPage._mainform.show();
      } else {
        YWebPage.EmptyReadonlyConfig();
      }
      return;
    }
    let parser = new DOMParser();
    let doc = parser.parseFromString(xmlData.replace("<!-->", "<!-- "), "application/xml");
    let root = null;
    doc.childNodes.forEach((node) => {
      if (node.nodeName.toUpperCase() == "ROOT" && root == null)
        root = node;
    });
    if (root == null)
      throw "No ROOT top node in XML data";
    root.childNodes.forEach((node) => {
      if (node.nodeName.toUpperCase() == "SENSORS") {
        sensorsManager.setKnownSensors(new YXmlNode(node));
      }
    });
    root.childNodes.forEach((node) => {
      let editor = null;
      editor = YWebPage._editor;
      switch (node.nodeName.toUpperCase()) {
        case "CONFIG":
          constants.Init(new YXmlNode(node));
          break;
        case "GRAPHFORM":
          YWebPage.widgets.push(new graphWidget(new YXmlNode(node), editor));
          break;
        case "ANGULARGAUGEFORM":
          YWebPage.widgets.push(new angularGaugeWidget(new YXmlNode(node), editor));
          break;
        case "GAUGEFORM":
          YWebPage.widgets.push(new gaugeWidget(new YXmlNode(node), editor));
          break;
        case "DIGITALDISPLAYFORM":
          YWebPage.widgets.push(new digitalDisplayWidget(new YXmlNode(node), editor));
          break;
      }
      sensorsManager.registerChangeCallback(() => {
        YWebPage.sensorListHaschanged();
      });
      if (node.nodeName.toUpperCase() == "ROOT" && root == null)
        root = node;
    });
    if (YWebPage.widgets.length <= 0) {
      constants.edited = false;
      if (!YWebPage.readonly && YWebPage._mainform != null) {
        YWebPage._mainform.show();
      } else {
        YWebPage.EmptyReadonlyConfig();
      }
    } else if (!YWebPage.readonly && YWebPage._mainform != null)
      YWebPage._mainform.hide();
  }
  static AnimateNewVerwsionMessage(step) {
    YWebPage.NewVersionmessageDiv.style.left = Math.round(100 - step) + "%";
    if (step < 100) {
      step += 2;
      if (step > 100)
        step = 100;
      setTimeout(() => {
        YWebPage.AnimateNewVerwsionMessage(step);
      });
    }
  }
  static StartInstaller(roothub) {
    let installerDiv = document.createElement("DIV");
    installerDiv.style.position = "absolute";
    installerDiv.style.top = "50%";
    installerDiv.style.left = "50%";
    installerDiv.style.transform = "translate(-50%,-50%)";
    installerDiv.style.width = "550px";
    installerDiv.style.height = "380px";
    installerDiv.style.zIndex = YWebPage.getTopZIndex().toString();
    installerDiv.style.border = "1px solid black";
    installerDiv.style.boxShadow = "rgba(0, 0, 0, 0.05) 4px 4px 4px 1px";
    document.body.appendChild(installerDiv);
    let options = {};
    if (roothub != null)
      options = {
        protocol: roothub.protocol,
        addr: roothub.addr,
        port: parseInt(roothub.port),
        path: roothub.path,
        cancelable: true
      };
    window.startYV4W_installer(installerDiv, options);
  }
  static DownloadAndStartInstaller(installerURL, roothub, deleteTimer) {
    clearTimeout(deleteTimer);
    console.log("Downloading installer (" + installerURL + ")...");
    let P = document.createElement("P");
    P.style.textAlign = "center";
    P.style.fontFamily = constants.generalFontFamily;
    P.style.fontSize = "16px";
    P.innerHTML = "Downloading Installer<br>Please wait...";
    YWebPage.NewVersionmessageDiv.removeChild(YWebPage.NewVersionmessageDiv.firstChild);
    YWebPage.NewVersionmessageDiv.appendChild(P);
    let script = document.createElement("script");
    script.async = false;
    script.type = "module";
    script.onerror = (err) => {
      console.log("Failed to donwload installer (" + Event.toString() + ")");
      P.innerHTML = "Failed to download installer,<br>Check conole logs";
    };
    script.onload = () => {
      P.innerHTML = "Starting installer...";
      YWebPage.DeleteNewVersionMessage(100);
      YWebPage.StartInstaller(roothub);
    };
    document.body.appendChild(script);
    script.src = installerURL;
  }
  static DeleteNewVersionMessage(opacity) {
    opacity -= 5;
    if (opacity > 0) {
      YWebPage.NewVersionmessageDiv.style.opacity = (opacity / 100).toString();
      setTimeout(() => {
        YWebPage.DeleteNewVersionMessage(opacity);
      }, 100);
      return;
    }
    document.body.removeChild(YWebPage.NewVersionmessageDiv.parentNode);
  }
  static getTopZIndex() {
    var elems = document.getElementsByTagName("DIV");
    var highestZ = 0;
    for (var i = 0; i < elems.length; i++) {
      var z = Number.parseInt(window.getComputedStyle(elems[i], null).getPropertyValue("z-index"));
      if (z > highestZ)
        highestZ = z;
    }
    return highestZ + 1;
  }
  static async CheckForNewVersion(force) {
    if (!constants.mustCheckForUpdate && !force)
      return;
    let checkurl = location.protocol + "//www.yoctopuce.com/FR/common/getLastFirmwareLink.php?app=yoctovisualization4web.installer&version=" + constants.buildVersion + "&platform=_";
    let response;
    try {
      response = await fetch(checkurl);
    } catch (e) {
      return;
    }
    if (!response.ok)
      return;
    let json;
    try {
      json = await response.json();
    } catch (e) {
      return;
    }
    if (!(json instanceof Array))
      return;
    if (json.length <= 0)
      return;
    if (!("version" in json[0]))
      return;
    if (!("link" in json[0]))
      return;
    let newVersionInstallerURL = json[0]["link"];
    let newVersionNumber = parseInt(json[0]["version"]);
    let currentVersionStr = constants.buildVersion;
    let currentVersionNumber = 0;
    if (currentVersionStr.indexOf("-") < 0) {
      let n = currentVersionStr.lastIndexOf(".");
      if (n >= 0)
        currentVersionStr = currentVersionStr.substr(n + 1);
      currentVersionNumber = parseInt(currentVersionStr);
    }
    if (currentVersionNumber >= newVersionNumber)
      return;
    let generalSize = constants.generalFontSize;
    let NewVersionSizeX = generalSize * 24;
    let NewVersionSizeY = generalSize * 5;
    let containerDiv = document.createElement("DIV");
    containerDiv.style.position = "absolute";
    containerDiv.style.width = NewVersionSizeX + "px";
    containerDiv.style.height = NewVersionSizeY + "px";
    containerDiv.style.zIndex = YWebPage.getTopZIndex().toString();
    containerDiv.style.top = "5px";
    containerDiv.style.right = "0px";
    containerDiv.style.overflow = "hidden";
    document.body.appendChild(containerDiv);
    YWebPage.NewVersionmessageDiv = document.createElement("DIV");
    YWebPage.NewVersionmessageDiv.style.position = "absolute";
    YWebPage.NewVersionmessageDiv.style.width = NewVersionSizeX - 7 + "px";
    YWebPage.NewVersionmessageDiv.style.height = NewVersionSizeY - 2 + "px";
    YWebPage.NewVersionmessageDiv.style.backgroundColor = "GhostWhite";
    YWebPage.NewVersionmessageDiv.style.border = "1px solid dimgray";
    YWebPage.NewVersionmessageDiv.style.top = "0px";
    YWebPage.NewVersionmessageDiv.style.left = NewVersionSizeX + "px";
    let table = document.createElement("TABLE");
    table.style.fontFamily = constants.generalFontFamily;
    table.style.fontSize = generalSize + "px";
    let TR = document.createElement("TR");
    let TD1 = document.createElement("TD");
    TD1.style.paddingLeft = "5px";
    TD1.style.paddingRight = "10px";
    TD1.rowSpan = 2;
    TD1.style.verticalAlign = "middle";
    TD1.innerHTML = ressources.infoIcon((generalSize * 4).toString(), false, false, false, false, "information");
    TR.appendChild(TD1);
    let TD2 = document.createElement("TD");
    TD2.innerHTML = "A new Yocto-Visualization (for web)<br>version is available";
    TR.appendChild(TD2);
    table.appendChild(TR);
    TR = document.createElement("TR");
    TD2 = document.createElement("TD");
    TD2.style.textAlign = "right";
    TD2.style.verticalAlign = "bottom";
    let hubList = sensorsManager.hubList;
    let rootHub = null;
    for (let i = 0; i < hubList.length; i++) {
      if (!hubList[i].removable)
        rootHub = hubList[i];
    }
    let a = document.createElement("A");
    let deleteTimer = setTimeout(() => {
      YWebPage.DeleteNewVersionMessage(100);
    }, 5e3);
    a.style.fontSize = "12px";
    a.style.color = " #0000EE";
    a.style.textDecoration = "underline";
    a.style.cursor = "pointer";
    a.style.fontFamily = constants.generalFontFamily;
    a.style.fontSize = generalSize + "px";
    if (rootHub != null) {
      a.innerText = "Download and start installer..";
      a.addEventListener("click", () => {
        YWebPage.DownloadAndStartInstaller(newVersionInstallerURL, rootHub, deleteTimer);
      });
    } else {
      a.innerText = "www.yoctopuce.com";
      a.addEventListener("click", () => {
        window.location.assign("http://www.yoctopuce.com/EN/tools.php");
      });
    }
    TD2.appendChild(a);
    TR.appendChild(TD2);
    table.appendChild(TR);
    YWebPage.NewVersionmessageDiv.appendChild(table);
    containerDiv.appendChild(YWebPage.NewVersionmessageDiv);
    YWebPage.AnimateNewVerwsionMessage(0);
  }
  static run(xmlData, ExternalConfigChange, saveFunction) {
    if (typeof ExternalConfigChange !== "undefined") {
      if (ExternalConfigChange != null) {
        sensorsManager.registerChangeExternalCallback(ExternalConfigChange);
      }
    }
    YWebPage.xmlDataCRC = constants.crc32(xmlData);
    if (typeof saveFunction !== "undefined")
      YWebPage._saveFunction = saveFunction;
    logForm.log("Application start, Welcome to Yocto-Visualization (for web).");
    logForm.log("This application contains code ported from the Pako library (www.github.com/nodeca/pako).");
    logForm.log("Yocto-Visualization version is " + constants.buildVersion);
    logForm.log("Yoctopuce API version is " + YAPI.imm_GetAPIVersion());
    if (constants.RunningOnAndroid)
      logForm.log("Browser is running on Android");
    let widthCm = Math.round(2.54 * constants.deviceScreenWidth / constants.screenDPI);
    let heightCm = Math.round(2.54 * constants.deviceScreenHeight / constants.screenDPI);
    logForm.log("Reported screen size is " + constants.deviceScreenWidth.toString() + "x" + constants.deviceScreenHeight.toString() + " at " + constants.screenDPI + " dpi, (~" + widthCm.toString() + "x" + heightCm.toString() + "cm) ");
    logForm.log("Reported pixel ratio is " + window.devicePixelRatio.toString());
    logForm.log(constants.isPhoneOrTablet ? "Probably running on a tablet or a phone." : "Probably running on a desktop.");
    logForm.log((constants.guiDPIFactorWasOverriden ? "DPI based zoom overridden  to " : "DPI based zoom factor set to ") + constants.guiDPIFactor.toFixed(1));
    logForm.log("Reported window inner size =" + window.innerWidth.toString() + "x" + window.innerHeight.toString() + "px");
    YWebPage.applicationGlobalinit();
    sensorsManager.run();
    YWebPage.loadFromXML(xmlData);
    constants.edited = false;
    YWebPage.CheckForNewVersion(false);
  }
  static async pageIsleaving(e) {
    if (!e.persistent) {
      if (constants.edited) {
        await YWebPage.save(false);
        await YAPI.FreeAPI();
      }
    }
  }
  static refreshEditor() {
    if (YWebPage.readonly)
      return;
    if (YWebPage._editor == null)
      return;
    YWebPage._editor.refresh();
  }
  static EditObject(widget, structData, setvalueCallBack, getvalueCallBack, EditStoppedCallBack) {
    if (YWebPage.readonly)
      return;
    if (YWebPage._editor == null)
      return;
    YWebPage._editor.showWindow(widget, structData, setvalueCallBack, getvalueCallBack, EditStoppedCallBack);
  }
  static get_XmlData() {
    let XmlConfigFile = `<?xml version="1.0" ?>
<!--
   **************************************************
   Yocto-Visualization (for web)  configuration file
   **************************************************
-->
<ROOT version='2.1'>
<!-- in 2.1 version, floating point values are saved in CultureInfo.InvariantCulture form -->
`;
    XmlConfigFile += constants.GetXMLConfiguration();
    for (let i = 0; i < YWebPage.widgets.length; i++) {
      if (YWebPage.widgets[i] instanceof graphWidget)
        XmlConfigFile += YWebPage.widgets[i].getConfigData();
      if (YWebPage.widgets[i] instanceof angularGaugeWidget)
        XmlConfigFile += YWebPage.widgets[i].getConfigData();
      if (YWebPage.widgets[i] instanceof gaugeWidget)
        XmlConfigFile += YWebPage.widgets[i].getConfigData();
      if (YWebPage.widgets[i] instanceof digitalDisplayWidget)
        XmlConfigFile += YWebPage.widgets[i].getConfigData();
    }
    XmlConfigFile += sensorsManager.getXMLSensorsConfig();
    XmlConfigFile += "</ROOT>\n";
    return XmlConfigFile;
  }
  static get readonly() {
    let res = true;
    res = YWebPage._saveFunction == null;
    return res;
  }
  static async runInternalTest() {
  }
  static async save(force) {
    if (YWebPage.readonly)
      return true;
    let xml = this.get_XmlData();
    let newCRC = constants.crc32(xml);
    if (!force && newCRC == YWebPage.xmlDataCRC)
      return true;
    let saveDoneCallback = (ok, message) => {
      let div = document.createElement("DIV");
      div.style.position = "Fixed";
      div.style.left = "5px";
      div.style.top = "5px";
      div.style.padding = "2px 5px 2px 5px";
      div.style.margin = "2px 2px 2px 2px";
      div.style.border = "1px solid darkgreen";
      div.style.fontFamily = "Arial";
      div.style.fontSize = (12 * constants.guiDPIFactor).toString();
      div.style.whiteSpace = "nowrap";
      div.style.zIndex = "200000";
      div.style.textAlign = "center";
      div.style.opacity = "1";
      let fgcolor = ok ? "darkgreen" : "darkred";
      let bgcolor = ok ? "#b9eea9" : "#eea9a9";
      div.style.opacity = "1";
      div.style.backgroundColor = bgcolor;
      div.style.border = "1px solid " + fgcolor;
      div.style.color = fgcolor;
      div.innerText = message;
      document.body.appendChild(div);
      setTimeout(() => {
        YWebPage.handleSavedNotification(div);
      }, 100);
    };
    try {
      if (YWebPage._saveFunction != null) {
        return await YWebPage._saveFunction(this.get_XmlData(), saveDoneCallback);
      }
    } catch (e) {
      saveDoneCallback(false, "Save failed");
      alert2.show("Configuration save failed, sorry\n" + e.message);
      return false;
    }
    YWebPage.xmlDataCRC = newCRC;
    logForm.log("Configuration saved.");
    constants.edited = false;
    return true;
  }
  static handleSavedNotification(div) {
    let opacity = parseFloat(div.style.opacity) - 0.05;
    if (opacity < 0) {
      document.body.removeChild(div);
      return;
    }
    div.style.opacity = opacity.toString();
    setTimeout(() => {
      YWebPage.handleSavedNotification(div);
    }, 100);
  }
  static Dummysave(xml) {
    let contents = document.createElement("PRE");
    contents.innerText = xml;
    document.body.appendChild(contents);
    return true;
  }
};
YWebPage.baseSize = 18 * constants.generalSizeCoef;
YWebPage.xmlDataCRC = 0;
YWebPage.widgets = [];
YWebPage._markersSubMenuItems = [];
YWebPage._editor = null;
YWebPage._mainform = null;
YWebPage._saveFunction = null;
YWebPage._MarkerCountPerXaxis = 0;
YWebPage.ConfigChangedConfirmWindows = null;
YWebPage.saveIntDiv = null;
var HTTPrequestResult = class {
  constructor(data, status, statusText) {
    this._data = data;
    this._status = status;
    this._statusText = statusText;
  }
  get data() {
    return this._data;
  }
  get status() {
    return this._status;
  }
  get statusText() {
    return this._statusText;
  }
};
var HubInfo = class {
  get protocol() {
    return this._protocol;
  }
  get addr() {
    return this._addr;
  }
  get port() {
    return this._port;
  }
  get path() {
    return this._path;
  }
  get userPassword() {
    return this._userPassword;
  }
  get adminPassword() {
    return this._adminPassword;
  }
  get serial() {
    return this._serial;
  }
  get srvUsername() {
    return this._srvusername != null ? this._srvusername : "";
  }
  get srvPassword() {
    return this._srvpassword != null ? this._srvpassword : "";
  }
  constructor(protocol, addr, port, path, srvusername, srvpassword) {
    this._userPassword = false;
    this._adminPassword = false;
    this._cred = "";
    this._serial = "";
    this._srvusername = null;
    this._srvpassword = null;
    if (protocol.slice(-1) == ":")
      protocol = protocol.slice(0, -1);
    this._protocol = protocol;
    this._addr = addr;
    this._port = port;
    this._protocol = protocol;
    this._path = path;
    if (srvusername !== void 0)
      this._srvusername = srvusername;
    if (srvpassword !== void 0)
      this._srvpassword = srvpassword;
    if (this._path != "") {
      if (this._path.charAt(0) == "/") {
        this._path = this._path.slice(1);
      }
    }
    if (this._path != "") {
      if (this._path.slice(-1) == "/") {
        this._path = this._path.slice(0, -1);
      }
    }
  }
  get_hubUrl(user, password) {
    let url = this.protocol + "://";
    if (typeof user != "undefined" && user != "") {
      if (user != "") {
        url += user + ":" + password + "@";
      }
    }
    url += this.addr + ":" + this.port.toString();
    if (this.path != "")
      url += "/" + this.path;
    return url;
  }
  async makeRequest() {
    let url = this._protocol + "://" + this._addr + ":" + this._port.toString();
    if (this._path != "")
      url += "/" + this._path;
    url += "/info.json";
    let response;
    try {
      response = await fetch(url, {mode: "cors"});
    } catch (e) {
      return -3;
    }
    if (response.ok) {
      let HubData;
      try {
        HubData = await response.json();
      } catch (e) {
        return -1;
      }
      if (HubData.port && HubData.port.length > 0) {
        let proto_port = HubData.port[0].split(":");
        this._protocol = proto_port[0];
        this._port = parseInt(proto_port[1]);
      }
      this._serial = HubData.serialNumber;
      this._path = HubData.dir;
      this._adminPassword = HubData.adminPassword.toUpperCase() == "TRUE";
      this._userPassword = HubData.userPassword.toUpperCase() == "TRUE";
      return true;
    }
    if (response.status == 404 && this._path != "")
      return -2;
    if (response.status == 0 && response.statusText == null)
      return -3;
    return response.status;
  }
  findChild(parent, name) {
    let res = null;
    parent.childNodes.forEach((node) => {
      if (node.nodeName == name) {
        res = node;
        return;
      }
    });
    return res;
  }
  findOutCredentialsFromConfigFile(xmlData) {
    if (xmlData == null)
      return;
    let parser = new DOMParser();
    let doc = parser.parseFromString(xmlData, "application/xml");
    let rootNode = this.findChild(doc, "ROOT");
    if (rootNode == null)
      return;
    let configNode = this.findChild(rootNode, "Config");
    if (configNode == null)
      return;
    let Hubs = this.findChild(configNode, "Hubs");
    if (Hubs == null)
      return;
    let HubSection;
    let list = Hubs.childNodes;
    let sourceHubFound = false;
    for (let i = 0; i < list.length; i++) {
      if (list[i].nodeName == "Hub") {
        let node = new YXmlNode(list[i]);
        let attributes = node.Attributes;
        let addr = attributes.hasOwnProperty("addr") ? attributes["addr"] : "";
        let port = attributes.hasOwnProperty("port") ? attributes["port"] : "80";
        let protocol = attributes.hasOwnProperty("protocol") ? attributes["protocol"] : "";
        let path = attributes.hasOwnProperty("path") ? attributes["path"] : "";
        let username = attributes.hasOwnProperty("user") ? attributes["user"] : "";
        let password = attributes.hasOwnProperty("password") ? attributes["password"] : "";
        let a1 = addr.toUpperCase();
        if (a1.substring(0, 4) == "WWW.")
          a1 = a1.substring(4);
        let a2 = this._addr.toUpperCase();
        if (a2.substring(0, 4) == "WWW.")
          a2 = a2.substring(4);
        if (a1 == a2 && path == this._path) {
          this._srvusername = username;
          this._srvpassword = Hub.Decrypt(password, Hub.loginCypherPassword);
        }
      }
    }
  }
};
var YoctoHubFileHandler = class {
  constructor(hubInfo) {
    this.filename = "";
    this.xmldata = "";
    this.htmlSrcCode = "";
    this.FileSystemAccessDenied = false;
    this._XMLConfigFileChanged = null;
    this.fileSystem = null;
    this.fileSystemReady = false;
    this.configFileCRC = -1;
    this.info = hubInfo;
  }
  async init(defaultXmlConfigFileContents) {
    let url = location.href;
    this.filename = url.substring(url.lastIndexOf("/") + 1);
    let p = this.filename.indexOf("?");
    if (p > 0)
      this.filename = this.filename.substring(0, p);
    this.htmlSrcCode = document.documentElement.outerHTML;
    if (typeof defaultXmlConfigFileContents === "undefined" || defaultXmlConfigFileContents == "") {
      this.xmldata = '<?xml version="1.0" ?>\n<ROOT version="2.1">\n<Config>\n<Hubs>\n<Hub protocol="' + this.info.protocol + '" addr="' + this.info.addr + '" port="' + this.info.port.toString() + '"' + (this.info.path != "" ? ' path="' + this.info.path + '"' : "") + ' removable="FALSE"/>\n</Hubs>\n</Config>\n</ROOT>\n';
    } else {
      this.xmldata = defaultXmlConfigFileContents;
    }
    this.fileSystem = null;
    this.fileSystemReady = false;
    await this.findSourceFileSystem(defaultXmlConfigFileContents);
  }
  static async start(defaultXmlConfigFileContents) {
    let dirpath = location.pathname;
    let defport = "80";
    let slashpos = dirpath.lastIndexOf("/");
    if (slashpos > 0) {
      dirpath = dirpath.slice(0, slashpos);
    } else {
      dirpath = "";
    }
    if (location.protocol == "https:") {
      defport = "443";
    }
    let hubinfo = new HubInfo(location.protocol, location.hostname, parseInt(location.port ? location.port : defport), dirpath);
    await hubinfo.makeRequest();
    let filehandler = new YoctoHubFileHandler(hubinfo);
    await filehandler.init(defaultXmlConfigFileContents);
    return filehandler;
  }
  get xmlConfigData() {
    return this.xmldata;
  }
  static makeRequest(method, url, username, password) {
    return new Promise(function(resolve, reject) {
      let xhr = new XMLHttpRequest();
      if (username !== void 0 && password !== void 0 && username != null && password !== null) {
        xhr.open(method, url, true, username, password);
        xhr.withCredentials = true;
      } else {
        xhr.open(method, url);
      }
      xhr.overrideMimeType("text/plain; charset=x-user-defined");
      xhr.onreadystatechange = function() {
        if (xhr.readyState == 4) {
          if (this.status >= 200 && this.status < 300) {
            resolve(new HTTPrequestResult(YAPI.imm_str2bin(xhr.response), this.status, xhr.statusText));
          } else {
            resolve(new HTTPrequestResult(null, this.status, xhr.statusText));
          }
        }
      };
      xhr.onerror = function() {
        resolve(new HTTPrequestResult(null, this.status, xhr.statusText));
      };
      xhr.send();
    });
  }
  async findSourceFileSystem(xmldata) {
    this.fileSystem = null;
    let errmsg = new YErrorMsg();
    this.info.findOutCredentialsFromConfigFile(xmldata);
    let url = this.info.get_hubUrl(this.info.srvUsername, this.info.srvPassword);
    try {
      await YAPI.RegisterHub(url, errmsg);
    } catch (e) {
      this.fileSystemReady = false;
      if (e.errorType == YAPI.UNAUTHORIZED) {
        console.log("Access to hub " + url + " is denied, waiting for YV callback to save the situation.");
        this.FileSystemAccessDenied = true;
        return;
      }
      throw "YV4F ERROR: Unable to register Hub " + this.info.get_hubUrl() + "(" + e.message + "), save will not work.";
    }
    let fs = YFiles.FirstFiles();
    if (fs == null) {
      this.fileSystemReady = true;
      throw "YV4F ERROR: No file system found on Hub " + this.info.get_hubUrl() + ", save will not work.";
    }
    while (fs != null) {
      if (await fs.get_serialNumber() == this.info.serial) {
        await this.registerSourceFileSystem(fs);
        return;
      }
      fs = fs.nextFiles();
    }
    fs = YFiles.FirstFiles();
    while (fs != null) {
      let m = await fs.get_module();
      let url2 = await m.get_url();
      console.log("URL = (" + url2 + ")");
      let p = url2.indexOf("://");
      if (p >= 0)
        url2 = url2.slice(p + 3);
      p = url2.indexOf(":");
      if (p > 0)
        url2 = url2.slice(0, p);
      {
        if (url2 == this.info.addr) {
          await this.registerSourceFileSystem(fs);
          return;
        }
      }
      fs = fs.nextFiles();
    }
    this.fileSystemReady = true;
    throw "YV4F ERROR: No file system matching Hub " + this.info.get_hubUrl() + " found, save will not work.";
  }
  async registerSourceFileSystem(fs) {
    this.fileSystem = fs;
    this.fileSystemReady = true;
    this.FileSystemAccessDenied = false;
    let entries = await this.fileSystem.get_list(this.filename);
    if (entries.length > 0)
      this.configFileCRC = await entries[0].get_crc();
  }
  async configChangeCallback(m) {
    if (this.fileSystem == null) {
      let urlSignature = this.info.addr + ":" + this.info.port.toString() + "/" + this.info.path + (this.info.path != "" ? "/" : "");
      let sourceUrl = await m.get_url();
      console.log("urlSignature=" + urlSignature);
      console.log("sourceUrl=" + sourceUrl);
      if (sourceUrl.length > urlSignature.length && sourceUrl.substring(sourceUrl.length - urlSignature.length) == urlSignature) {
        let fs = YFiles.FindFiles(await m.get_serialNumber() + ".files");
        if (await fs.isOnline())
          await this.registerSourceFileSystem(fs);
      }
    }
    if (this.fileSystem == null)
      return null;
    if (await this.fileSystem.get_serialNumber() != await m.get_serialNumber())
      return null;
    let entries = await this.fileSystem.get_list(this.filename);
    if (entries.length <= 0)
      return null;
    if (this.configFileCRC == await entries[0].get_crc())
      return null;
    let data = await this.fileSystem.download(this.filename);
    let file = new TextDecoder("utf-8").decode(data);
    let indexStart = file.indexOf(YoctoHubFileHandler.signatureStart);
    if (indexStart < 0)
      return null;
    this.configFileCRC = await entries[0].get_crc();
    indexStart += YoctoHubFileHandler.signatureStart.length;
    let indexEnd = file.indexOf(YoctoHubFileHandler.signatureEnd);
    if (indexEnd < indexStart)
      return "";
    indexEnd += YoctoHubFileHandler.signatureEnd.length - 2;
    let configdata = file.substring(indexStart, indexEnd);
    try {
      return JSON.parse(configdata);
    } catch (e) {
    }
    return null;
  }
  get configChangeCallbackFct() {
    return async (module) => {
      return await this.configChangeCallback(module);
    };
  }
  get saveFct() {
    return async (xml, callback) => {
      return await this.saveFctinternal(xml, callback);
    };
  }
  async retryWithNewCredentials(xml, username, password, callback) {
    if (this.fileSystem == null) {
      debugger;
      return;
    }
    let m = await this.fileSystem.get_module();
    let url = await m.get_url();
    let err = new YErrorMsg();
    let p1 = url.indexOf("://");
    let p2 = url.indexOf("@", p1 + 3);
    let newurl = url.substring(0, p1 + 3) + username + ":" + password + "@";
    if (p2 < 0)
      newurl += url.substring(p1 + 3);
    else
      newurl += url.substring(p2 + 1);
    await YAPI.UnregisterHub(url);
    if (await YAPI.RegisterHub(newurl, err) != YAPI.SUCCESS) {
      await YAPI.RegisterHub(url, err);
    }
    try {
      if (!await this.saveFctinternal(xml, callback))
        return;
    } catch (e) {
      if (callback != null)
        callback(false, "Save failed (" + e.message) + ")";
      return;
    }
  }
  async saveFctinternal(xml, callback) {
    if (this.FileSystemAccessDenied) {
      throw "YV4F ERROR: Access to file system on " + this.info.get_hubUrl() + " is denied, it is probably password protected. Check network connections in the global configuration.";
    }
    if (this.fileSystem == null) {
      throw "YV4F ERROR: No file system, Save aborted";
    }
    if (!this.fileSystemReady) {
      throw "YV4F ERROR: File system is not ready yet, retry in a few seconds.";
    }
    if (!this.fileSystem.isOnline()) {
      throw "YV4F ERROR: File system is off line, Save aborted";
    }
    let tosave = "";
    let index = this.htmlSrcCode.indexOf(YoctoHubFileHandler.signatureStart + ")");
    if (index > 0) {
      tosave = this.htmlSrcCode.substring(0, index + YoctoHubFileHandler.signatureStart.length) + JSON.stringify(xml) + this.htmlSrcCode.substring(index + YoctoHubFileHandler.signatureStart.length);
    } else {
      let index1 = this.htmlSrcCode.indexOf(YoctoHubFileHandler.signatureStart);
      let index2 = this.htmlSrcCode.indexOf(YoctoHubFileHandler.signatureEnd);
      if (index1 > 0 && index2 && index2 > index1) {
        tosave = this.htmlSrcCode.substring(0, index1 + YoctoHubFileHandler.signatureStart.length) + JSON.stringify(xml) + ");" + this.htmlSrcCode.substring(index2 + YoctoHubFileHandler.signatureEnd.length);
      } else {
        throw "Unable to locate YoctoHubFileHandler constructor call in original HTML file.";
      }
    }
    tosave = "<!DOCTYPE html>\n" + tosave;
    let GZdata = Pako_Deflate.gzip(tosave, {level: 9});
    let askForRwCredentials = false;
    try {
      await this.fileSystem.upload(this.filename + ".gz", GZdata);
    } catch (e) {
      if (this.fileSystem.get_errorType() == YAPI_UNAUTHORIZED)
        askForRwCredentials = true;
      else
        throw e;
    }
    if (askForRwCredentials) {
      let m = await this.fileSystem.get_module();
      let url = await m.get_url();
      let err = new YErrorMsg();
      let p1 = url.indexOf("://");
      let p2 = url.indexOf("@", p1 + 3);
      if (p2 >= 0)
        url = url.substring(p2 + 1);
      else if (p1 >= 0)
        url = url.substring(p1 + 3);
      await CredentialsPrompt.show(url, async () => {
        await this.retryWithNewCredentials(xml, CredentialsPrompt.username, CredentialsPrompt.password, callback);
      });
      if (callback != null)
        callback(false, "Save failed, credentials required");
      return false;
    }
    let entries = await this.fileSystem.get_list(this.filename);
    if (entries.length > 0)
      this.configFileCRC = await entries[0].get_crc();
    if (callback != null)
      callback(true, "Save sucessfull");
    return true;
  }
};
YoctoHubFileHandler.signatureStart = "YoctoHubFileHandler.start(";
YoctoHubFileHandler.signatureEnd = '</ROOT>\\n");';

// obj/full/logForm.js
var logForm = class {
  static show() {
    if (logForm._window == null) {
      let params = new newWindowParam();
      params.positionType = 0;
      params.width = 8 * window.innerWidth / 10 >> 0;
      params.height = 6 * window.innerHeight / 10 >> 0;
      params.left = 1 * window.innerWidth / 10 >> 0;
      params.top = 2 * window.innerHeight / 10 >> 0;
      params.title = "LogFile";
      logForm._window = new YWindow(params);
      logForm._contents = logForm._window.innerContentDiv;
      logForm._contents.style.fontFamily = "courrier";
      logForm._contents.style.fontSize = (10 * constants.generalSizeCoef).toString() + "px";
      logForm._contents.style.overflow = "auto";
      for (let i = 0; i < logForm._lines.length; i++) {
        logForm.addLine(logForm._lines[i]);
      }
    }
    logForm._window.show();
  }
  static addLine(st) {
    let pre = document.createElement("PRE");
    pre.style.marginTop = "0";
    pre.style.marginBottom = "0";
    pre.innerText = st;
    logForm._contents.appendChild(pre);
    while (logForm._contents.childElementCount > 1e3) {
      logForm._contents.removeChild(logForm._contents.firstChild);
    }
  }
  static padStart(st, length) {
    while (st.length < length) {
      st = "0" + st;
    }
    return st;
  }
  static dateToString(d) {
    return d.getFullYear().toString() + "-" + logForm.padStart((d.getMonth() + 1).toString(), 2) + "-" + logForm.padStart(d.getDate().toString(), 2) + " " + logForm.padStart(d.getHours().toString(), 2) + ":" + logForm.padStart(d.getMinutes().toString(), 2) + ":" + logForm.padStart((d.getSeconds() + d.getMilliseconds() / 1e3).toFixed(3), 6);
  }
  static log(st) {
    logForm.logNOTS(logForm.dateToString(new Date()) + " " + st);
  }
  static logNOTS(st) {
    logForm._lines.push(st);
    if (logForm._lines.length > 1e3) {
      logForm._lines.splice(0, logForm._lines.length - 1e3);
    }
    if (logForm._window != null)
      logForm.addLine(st);
  }
};
logForm._lines = [];

// obj/full/rawDataForm.js
var rawDataForm = class {
  static hide() {
    if (rawDataForm._window == null)
      return;
    rawDataForm._window.visible = false;
  }
  static show() {
    if (rawDataForm._window == null) {
      let params = new newWindowParam();
      params.positionType = 1;
      params.width = 9 * window.innerWidth / 10 >> 0;
      params.height = 8 * window.innerHeight / 10 >> 0;
      params.title = "Raw data";
      rawDataForm._window = new YWindow(params);
      rawDataForm._contents = rawDataForm._window.innerContentDiv;
      rawDataForm._statusline = document.createElement("DIV");
      rawDataForm._statusline.style.position = "absolute";
      rawDataForm._statusline.style.left = constants.WindowPadding.toString() + "px";
      rawDataForm._statusline.style.right = constants.WindowPadding.toString() + "px";
      rawDataForm._statusline.style.height = (rawDataForm.STATUSLINEHEIGHT * constants.generalSizeCoef).toString() + "px";
      rawDataForm._statusline.style.bottom = constants.WindowPadding.toString() + "px";
      rawDataForm._statusline.style.paddingTop = Math.round(5 * constants.generalSizeCoef).toString() + "px";
      rawDataForm._statusline.style.paddingLeft = "5px";
      rawDataForm._statusline.style.paddingRight = "5px";
      rawDataForm._statusline.style.overflowX = "auto";
      rawDataForm._statusline.style.paddingRight = "5px";
      rawDataForm._contents.append(rawDataForm._statusline);
      rawDataForm._sensorsList = document.createElement("DIV");
      rawDataForm._sensorsList.style.position = "absolute";
      rawDataForm._sensorsList.style.left = constants.WindowPadding.toString() + "px";
      rawDataForm._sensorsList.style.right = (rawDataForm.sensorListWidth * constants.generalSizeCoef + 8 * constants.WindowPadding).toString() + "px";
      rawDataForm._sensorsList.style.top = "2px";
      rawDataForm._sensorsList.style.overflowY = "auto";
      rawDataForm._sensorsList.style.height = (rawDataForm.topMargin * constants.generalSizeCoef).toString() + "px";
      rawDataForm._sensorsList.style.paddingLeft = "5px";
      rawDataForm._sensorsList.style.paddingRight = "5px";
      rawDataForm._sensorsList.style.border = constants.WindowInnerBorder;
      rawDataForm._sensorsList.style.backgroundColor = constants.WindowInnerBackgroundColor;
      rawDataForm._contents.append(rawDataForm._sensorsList);
      rawDataForm._optionsList = document.createElement("DIV");
      rawDataForm._optionsList.style.position = "absolute";
      rawDataForm._optionsList.style.width = (rawDataForm.sensorListWidth * constants.generalSizeCoef).toString() + "px";
      rawDataForm._optionsList.style.right = constants.WindowPadding.toString() + "px";
      rawDataForm._optionsList.style.top = "0px";
      rawDataForm._optionsList.style.height = (rawDataForm.topMargin * constants.generalSizeCoef).toString() + "px";
      rawDataForm._optionsList.style.paddingLeft = "5px";
      rawDataForm._optionsList.style.paddingRight = "5px";
      rawDataForm._optionsList.style.border = "1px solid transparent";
      rawDataForm._contents.append(rawDataForm._optionsList);
      let br;
      rawDataForm._optionMIN = document.createElement("INPUT");
      rawDataForm._optionMIN.type = "input";
      rawDataForm._optionMIN.checked = false;
      rawDataForm._optionMIN.style.display = "inline";
      rawDataForm._optionMIN.type = "checkbox";
      rawDataForm._optionMIN.style.transform = "scale(" + constants.generalSizeCoef.toString() + ")";
      rawDataForm._optionMIN.style.marginRight = Math.round(5 * constants.generalSizeCoef).toString() + "px";
      rawDataForm._optionMIN.addEventListener("change", () => {
        rawDataForm.refresh();
      });
      rawDataForm._optionsList.append(rawDataForm._optionMIN);
      let span;
      span = document.createElement("SPAN");
      span.innerText = "Include minimum values";
      rawDataForm._optionsList.append(span);
      br = document.createElement("BR");
      rawDataForm._optionsList.append(br);
      rawDataForm._optionAVG = document.createElement("INPUT");
      rawDataForm._optionAVG.type = "input";
      rawDataForm._optionAVG.checked = true;
      rawDataForm._optionAVG.style.display = "inline";
      rawDataForm._optionAVG.type = "checkbox";
      rawDataForm._optionAVG.style.transform = "scale(" + constants.generalSizeCoef.toString() + ")";
      rawDataForm._optionAVG.style.marginRight = Math.round(5 * constants.generalSizeCoef).toString() + "px";
      rawDataForm._optionAVG.addEventListener("change", () => {
        rawDataForm.refresh();
      });
      rawDataForm._optionsList.append(rawDataForm._optionAVG);
      span = document.createElement("SPAN");
      span.innerText = "Include average values";
      rawDataForm._optionsList.append(span);
      br = document.createElement("BR");
      rawDataForm._optionsList.append(br);
      rawDataForm._optionMAX = document.createElement("INPUT");
      rawDataForm._optionMAX.type = "input";
      rawDataForm._optionMAX.checked = false;
      rawDataForm._optionMAX.style.display = "inline";
      rawDataForm._optionMAX.type = "checkbox";
      rawDataForm._optionMAX.style.transform = "scale(" + constants.generalSizeCoef.toString() + ")";
      rawDataForm._optionMAX.style.marginRight = Math.round(5 * constants.generalSizeCoef).toString() + "px";
      rawDataForm._optionMAX.addEventListener("change", () => {
        rawDataForm.refresh();
      });
      rawDataForm._optionsList.append(rawDataForm._optionMAX);
      span = document.createElement("SPAN");
      span.innerText = "Include maximum values";
      rawDataForm._optionsList.append(span);
      rawDataForm._optionsList.append(document.createElement("BR"));
      rawDataForm._optionsList.append(document.createElement("BR"));
      let p = document.createElement("P");
      p.style.textAlign = "center";
      let refreshBtn = new button("refresh", () => {
        rawDataForm.refresh();
      });
      p.appendChild(refreshBtn.Element);
      let ExportBtn = new button("export", () => {
        rawDataForm.export();
      });
      p.appendChild(ExportBtn.Element);
      rawDataForm._optionsList.append(p);
      rawDataForm._datacontents = document.createElement("DIV");
      rawDataForm._datacontents.style.position = "absolute";
      rawDataForm._datacontents.style.left = constants.WindowPadding.toString() + "px";
      rawDataForm._datacontents.style.right = constants.WindowPadding.toString() + "px";
      rawDataForm._datacontents.style.top = (rawDataForm.topMargin * constants.generalSizeCoef + 5 * constants.WindowPadding).toString() + "px";
      rawDataForm._datacontents.style.bottom = (4 * constants.WindowPadding + rawDataForm.STATUSLINEHEIGHT * constants.generalSizeCoef).toString() + "px";
      rawDataForm._datacontents.style.paddingLeft = "5px";
      rawDataForm._datacontents.style.paddingRight = "5px";
      rawDataForm._datacontents.style.overflowX = "auto";
      rawDataForm._datacontents.style.paddingRight = "5px";
      rawDataForm._contents.append(rawDataForm._datacontents);
      rawDataForm._dataTable = document.createElement("TABLE");
      rawDataForm._dataTable.style.position = "absolute";
      rawDataForm._dataTable.style.overflow = "auto";
      rawDataForm._dataTable.style.left = "0px";
      rawDataForm._dataTable.style.width = "100%";
      rawDataForm._dataTable.style.top = "0px";
      rawDataForm._dataTable.style.bottom = "0px";
      rawDataForm._dataTable.style.fontSize = constants.generalFontSize.toString() + "px";
      rawDataForm._dataTable.style.borderCollapse = "colapse";
      rawDataForm._dataTable.style.borderSpacing = "0px";
      rawDataForm._dataTable.style.fontFamily = "sans-serif";
      rawDataForm._datacontents.appendChild(rawDataForm._dataTable);
    }
    rawDataForm._window.show();
    rawDataForm.refresh();
  }
  static refresh() {
    let list = [];
    for (let i = 0; i < sensorsManager.sensorList.length; i++) {
      if (!(sensorsManager.sensorList[i] instanceof NullYSensor)) {
        list.push(sensorsManager.sensorList[i]);
      }
    }
    rawDataForm._selection = [];
    for (let i = 0; i < list.length; i++) {
      let spanNode;
      let spanText;
      let input;
      if (i >= rawDataForm._sensorsList.childNodes.length) {
        spanNode = document.createElement("SPAN");
        input = document.createElement("INPUT");
        input.type = "input";
        input.checked = false;
        input.style.display = "inline";
        input.type = "checkbox";
        input.style.transform = "scale(" + constants.generalSizeCoef.toString() + ")";
        input.style.marginRight = Math.round(5 * constants.generalSizeCoef).toString() + "px";
        input.addEventListener("change", () => {
          rawDataForm.refresh();
        });
        spanNode.appendChild(input);
        spanText = document.createElement("SPAN");
        spanNode.appendChild(spanText);
        rawDataForm._sensorsList.appendChild(spanNode);
        spanNode.appendChild(document.createElement("BR"));
      } else {
        spanNode = rawDataForm._sensorsList.childNodes[i];
        input = spanNode.childNodes[0];
        spanText = spanNode.childNodes[1];
      }
      if (input.checked)
        rawDataForm._selection.push(list[i]);
      input.id = list[i].get_hardwareId();
      spanText.innerText = list[i].get_friendlyName();
    }
    while (rawDataForm._sensorsList.childNodes.length > list.length) {
      rawDataForm._sensorsList.removeChild(rawDataForm._sensorsList.lastChild);
    }
    rawDataForm.RefreshContents(rawDataForm._selection);
  }
  static padStart(st, length) {
    while (st.length < length) {
      st = "0" + st;
    }
    return st;
  }
  static UnixTimeStampTostring(ts) {
    let d = new Date(Date.UTC(1970, 0, 1));
    d.setUTCSeconds(ts >> 0, 1e3 * (ts % 1));
    return d.getFullYear().toString() + "-" + rawDataForm.padStart((d.getMonth() + 1).toString(), 2) + "-" + rawDataForm.padStart(d.getDate().toString(), 2) + " " + rawDataForm.padStart(d.getHours().toString(), 2) + ":" + rawDataForm.padStart(d.getMinutes().toString(), 2) + ":" + rawDataForm.padStart((d.getSeconds() + d.getMilliseconds() / 1e3).toFixed(3), 6);
  }
  static RefreshContents(slist) {
    let TH = document.createElement("THEAD");
    let TB = document.createElement("TBODY");
    let HR1 = document.createElement("TR");
    let HR2 = document.createElement("TR");
    let indexes = [];
    for (let i = 0; i < slist.length; i++) {
      indexes.push(slist[i].curData.length - 1);
    }
    while (rawDataForm._dataTable.childNodes.length > 0) {
      rawDataForm._dataTable.removeChild(rawDataForm._dataTable.lastChild);
    }
    rawDataForm._dataTable.appendChild(TH);
    rawDataForm._dataTable.appendChild(TB);
    let sMin = false;
    let sMax = false;
    let sAvg = false;
    let toShow = 0;
    if (rawDataForm._optionMIN.checked) {
      sMin = true;
      toShow++;
    }
    if (rawDataForm._optionAVG.checked) {
      sAvg = true;
      toShow++;
    }
    if (rawDataForm._optionMAX.checked) {
      sMax = true;
      toShow++;
    }
    TH.appendChild(HR1);
    TH.appendChild(HR2);
    let cell = document.createElement("TH");
    HR1.appendChild(cell);
    cell = document.createElement("TH");
    HR2.appendChild(cell);
    for (let i = 0; i < slist.length; i++) {
      cell = document.createElement("TH");
      cell.innerText = slist[i].get_friendlyName();
      cell.colSpan = Math.max(1, toShow);
      cell.style.backgroundColor = "#f0f0f0";
      cell.style.borderLeft = constants.WindowInnerBorder;
      cell.style.borderRight = constants.WindowInnerBorder;
      cell.style.borderTop = constants.WindowInnerBorder;
      HR1.appendChild(cell);
      if (sMin) {
        cell = document.createElement("TH");
        cell.innerText = "Min";
        cell.style.borderLeft = constants.WindowInnerBorder;
        cell.style.borderRight = sAvg || sMax ? "" : constants.WindowInnerBorder;
        cell.style.backgroundColor = "#f0f0f0";
        cell.style.textAlign = "right";
        HR2.appendChild(cell);
      }
      if (sAvg) {
        cell = document.createElement("TH");
        cell.innerText = "Avg";
        cell.style.borderLeft = sMin ? "" : constants.WindowInnerBorder;
        cell.style.borderRight = sMax ? "" : constants.WindowInnerBorder;
        cell.style.backgroundColor = "#f0f0f0";
        cell.style.textAlign = "right";
        HR2.appendChild(cell);
      }
      if (sMax) {
        cell = document.createElement("TH");
        cell.innerText = "Max";
        cell.style.borderLeft = sAvg || sMin ? "" : constants.WindowInnerBorder;
        cell.style.borderRight = constants.WindowInnerBorder;
        cell.style.backgroundColor = "#f0f0f0";
        cell.style.textAlign = "right";
        HR2.appendChild(cell);
      }
    }
    let colcount = slist.length * toShow;
    let MaxTimeStamp = 0;
    for (let i = 0; i < slist.length; i++) {
      if (indexes[i] >= 0) {
        if (MaxTimeStamp < slist[i].curData[indexes[i]].DateTime) {
          MaxTimeStamp = slist[i].curData[indexes[i]].DateTime;
        }
      }
    }
    let rowcount = 0;
    let currentRow = null;
    while (MaxTimeStamp > 0 && rowcount < rawDataForm.MAXRAWDATAROWS) {
      let row = new Array(colcount);
      let nextTimeStamp = 0;
      for (let i = 0; i < slist.length; i++) {
        let Shown = false;
        if (indexes[i] >= 0) {
          if (slist[i].curData[indexes[i]].DateTime == MaxTimeStamp) {
            let n = 0;
            if (sMin) {
              row[n + i * toShow] = slist[i].minData[indexes[i]].value.toString();
              n++;
            }
            if (sAvg) {
              row[n + i * toShow] = slist[i].curData[indexes[i]].value.toString();
              n++;
            }
            if (sMax) {
              row[n + i * toShow] = slist[i].maxData[indexes[i]].value.toString();
              n++;
            }
            Shown = true;
            indexes[i]--;
          }
          if (indexes[i] >= 0) {
            if (slist[i].curData[indexes[i]].DateTime > nextTimeStamp) {
              nextTimeStamp = slist[i].curData[indexes[i]].DateTime;
            }
          }
        }
        if (!Shown) {
          let n = 0;
          if (sMin) {
            row[n + i * toShow] = "";
            n++;
          }
          if (sAvg) {
            row[n + i * toShow] = "";
            n++;
          }
          if (sMax) {
            row[n + i * toShow] = "";
            n++;
          }
        }
      }
      if (colcount > 0 && toShow > 0) {
        currentRow = document.createElement("TR");
        let cell2 = document.createElement("TD");
        cell2.innerText = rawDataForm.UnixTimeStampTostring(MaxTimeStamp).toLocaleString();
        cell2.style.borderLeft = constants.WindowInnerBorder;
        cell2.style.borderTop = rowcount == 0 ? constants.WindowInnerBorder : "";
        cell2.style.backgroundColor = "#f0f0f0";
        currentRow.style.backgroundColor = (rowcount & 1) == 0 ? "white" : "#f0f0f0";
        currentRow.appendChild(cell2);
        for (let j = 0; j < row.length; j++) {
          cell2 = document.createElement("TD");
          cell2.innerText = row[j];
          cell2.style.textAlign = "right";
          cell2.style.borderLeft = j % toShow == 0 ? constants.WindowInnerBorder : "";
          cell2.style.borderRight = (j + 1) % toShow == 0 ? constants.WindowInnerBorder : "";
          cell2.style.fontFamily = "monospace";
          currentRow.appendChild(cell2);
        }
        TB.appendChild(currentRow);
        rowcount++;
      }
      MaxTimeStamp = nextTimeStamp;
    }
    if (currentRow != null) {
      for (let i = 0; i < currentRow.childNodes.length; i++) {
        currentRow.childNodes[i].style.borderBottom = constants.WindowInnerBorder;
      }
    }
    if (toShow == 0) {
      rawDataForm._statusline.style.backgroundColor = "#FF8080";
      rawDataForm._statusline.innerText = "No data shown, select at least Min, Avg or Max options in the top-right checkboxes";
    } else if (rowcount == 0) {
      rawDataForm._statusline.style.backgroundColor = "#FF8080";
      rawDataForm._statusline.innerText = "No data shown, select at least one sensor in the list above.";
    } else {
      rawDataForm._statusline.style.backgroundColor = constants.WindowBackgroundColor;
      if (rowcount < rawDataForm.MAXRAWDATAROWS) {
        rawDataForm._statusline.innerText = "These are the last " + rowcount.toString() + " data rows.";
      } else {
        rawDataForm._statusline.innerText = "These are the last " + rowcount.toString() + " data rows.  Use the export feature to get the whole data set.";
      }
    }
  }
  static getCvsdata(slist, sMin, sAvg, sMax) {
    let toShow = 0;
    let indexes = [];
    for (let i = 0; i < slist.length; i++) {
      indexes.push(0);
    }
    if (sMin)
      toShow++;
    if (sAvg)
      toShow++;
    if (sMax)
      toShow++;
    let res;
    let ColumnHeader = "Timestamp";
    for (let i = 0; i < slist.length; i++) {
      let sName = slist[i].toString();
      if (sMin)
        ColumnHeader += ";" + sName + "(min)";
      if (sAvg)
        ColumnHeader += ";" + sName + "(avg)";
      if (sMax)
        ColumnHeader += ";" + sName + "(max)";
    }
    res = ColumnHeader + "\r\n";
    let colcount = slist.length * toShow;
    let MinTimeStamp = Number.POSITIVE_INFINITY;
    for (let i = 0; i < slist.length; i++) {
      if (indexes[i] < slist[i].curData.length) {
        if (MinTimeStamp > slist[i].curData[indexes[i]].DateTime) {
          MinTimeStamp = slist[i].curData[indexes[i]].DateTime;
        }
      }
    }
    while (MinTimeStamp < Number.POSITIVE_INFINITY) {
      let line = "";
      let nextTimeStamp = Number.POSITIVE_INFINITY;
      for (let i = 0; i < slist.length; i++) {
        let Shown = false;
        if (indexes[i] < slist[i].curData.length) {
          if (slist[i].curData[indexes[i]].DateTime == MinTimeStamp) {
            if (sMin)
              line += ";" + slist[i].minData[indexes[i]].value.toString();
            if (sAvg)
              line += ";" + slist[i].curData[indexes[i]].value.toString();
            if (sMax)
              line += ";" + slist[i].maxData[indexes[i]].value.toString();
            Shown = true;
            indexes[i]++;
          }
          if (indexes[i] < slist[i].curData.length) {
            if (slist[i].curData[indexes[i]].DateTime < nextTimeStamp) {
              nextTimeStamp = slist[i].curData[indexes[i]].DateTime;
            }
          }
        }
        if (!Shown) {
          if (sMin)
            line += " ; ";
          if (sAvg)
            line += " ; ";
          if (sMax)
            line += " ; ";
        }
      }
      if (colcount > 0)
        line = rawDataForm.UnixTimeStampTostring(MinTimeStamp) + line;
      res += line + "\r\n";
      MinTimeStamp = nextTimeStamp;
    }
    return res;
  }
  static export() {
    let element = document.createElement("a");
    let data = "data:text/csv;charset=utf-8," + encodeURI(rawDataForm.getCvsdata(rawDataForm._selection, rawDataForm._optionMIN.checked, rawDataForm._optionAVG.checked, rawDataForm._optionMAX.checked));
    element.setAttribute("href", data);
    element.setAttribute("download", "rawdata.csv");
    element.style.display = "none";
    document.body.appendChild(element);
    element.click();
    document.body.removeChild(element);
  }
};
rawDataForm._lines = [];
rawDataForm.topMargin = 100;
rawDataForm.sensorListWidth = 200;
rawDataForm.MAXRAWDATAROWS = 100;
rawDataForm.STATUSLINEHEIGHT = 20;
rawDataForm._selection = [];

// obj/full/windowManager.js
var button = class {
  constructor(caption, action, sizeCoefOverload) {
    this._enabled = true;
    this._visible = true;
    this._caption = "";
    this._caption = caption;
    this._action = action;
    let GUIcoef = constants.generalSizeCoef;
    if (typeof sizeCoefOverload !== "undefined")
      GUIcoef = sizeCoefOverload;
    this._link = document.createElement("A");
    this._link.innerText = this._caption;
    this._link.style.cursor = "pointer";
    this._link.style.display = "inlineblock";
    let padding = Math.round(5 * GUIcoef).toString() + "px";
    let margin = Math.round(3 * GUIcoef).toString() + "px";
    this._link.tabIndex = 0;
    this._link.style.padding = padding + " " + padding + " " + padding + " " + padding;
    this._link.style.margin = margin + " " + margin + " " + margin + " " + margin;
    this._link.style.borderColor = "#808080";
    this._link.style.backgroundColor = "#f0f0f0";
    this._link.style.fontFamily = constants.generalFontFamily;
    this._link.style.fontSize = (16 * GUIcoef).toString() + "px";
    this._link.style.cursor = "pointer";
    this._link.style.border = constants.WindowInnerBorder;
    this._link.addEventListener("mouseover", () => {
      if (this._enabled)
        this._link.style.backgroundColor = "white";
    });
    this._link.addEventListener("mouseout", () => {
      if (this._enabled)
        this._link.style.backgroundColor = "#f0f0f0";
    });
    this._link.addEventListener("click", () => {
      if (this._enabled)
        this._action(this);
    });
    this._link.addEventListener("keypress", (e) => {
      if (this._enabled && (e.key == "Enter" || e.key == " "))
        this._action(this);
    });
  }
  get Element() {
    return this._link;
  }
  set tabIndex(index) {
    this._link.tabIndex = index;
  }
  focus() {
    this._link.focus();
  }
  get visible() {
    return this._visible;
  }
  set visible(value) {
    this._visible = value;
    this._link.style.display = this._visible ? "" : "none";
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    this.enable(value);
  }
  performAction() {
    if (!this._enabled)
      return;
    this._action(this);
  }
  showShortcut(enable) {
    if (!this._enabled)
      enable = false;
    if (enable) {
      this._link.innerHTML = "<u>" + this._caption.substring(0, 1) + "</u>" + this._caption.substring(1);
    } else {
      this._link.innerText = this._caption;
    }
  }
  enable(state) {
    if (state == this._enabled)
      return;
    this._enabled = state;
    this._link.tabIndex = state ? 0 : -1;
    if (this._enabled) {
      this._link.style.cursor = "pointer";
      this._link.style.backgroundColor = "#f0f0f0";
      this._link.style.color = "black";
    } else {
      this._link.style.backgroundColor = "#e0e0e0";
      this._link.style.cursor = "default";
      this._link.style.color = "#A0A0A0";
    }
  }
};
var newWindowParam = class {
  get GUICoef() {
    return this._GUICoef;
  }
  constructor(sizeCoefOverload) {
    this.createNow = false;
    this.left = 100;
    this.top = 100;
    this.positionType = 0;
    this.width = 400;
    this.height = 300;
    this.isModal = false;
    this.showShadow = true;
    this.showContainerBorders = true;
    this.showHeader = true;
    this.title = "new Window";
    this.closeIcon = true;
    this.headerBgColor = "";
    this.bottomKeepClear = 0;
    this.contentsDefaultFontSize = constants.generalFontSize;
    this.contentsDefaultFontFamily = constants.generalFontFamily;
    this.closingCallBack = null;
    this.WindowBackgroundColor = "#f0f0f0";
    this.WindowBorder = "1px solid #808080";
    this.WindowPadding = 2;
    this.WindowInnerBorderColor = " #A0A0A0";
    this.WindowInnerBackgroundColor = "#fAfAfA";
    this.WindowInnerBorder = "1px solid " + this.WindowInnerBorderColor;
    this.WindowHeaderBackgroundColor = "#0072ca";
    this.WindowHeaderColor = "white";
    this.WindowHeaderBorder = "1px solid #0072ca";
    this._GUICoef = constants.generalSizeCoef;
    this.WindowHeaderHeight = Math.round(20 * constants.generalSizeCoef);
    this.WindowHeaderFontSize = 16 * constants.generalSizeCoef;
    this.WindowHeaderFontFamily = constants.generalFontFamily;
    this.buttons = [];
    if (typeof sizeCoefOverload !== "undefined") {
      this.WindowHeaderHeight = 20 * sizeCoefOverload;
      this.WindowHeaderFontSize = 16 * sizeCoefOverload;
      this._GUICoef = sizeCoefOverload;
    }
  }
  clone() {
    let it = new newWindowParam();
    let keys = Object.keys(this);
    for (let i = 0; i < keys.length; i++) {
      if (keys[i] != "buttons")
        it[keys[i]] = this[keys[i]];
    }
    for (let i = 0; i < this.buttons.length; i++) {
      it.buttons.push(this.buttons[i]);
    }
    return it;
  }
};
var YWindow = class {
  static get ConTextMenuBestZindex() {
    for (let i = 0; i < YWindow.windowList.length; i++) {
      if (YWindow.windowList[i].isModal())
        return -1;
    }
    return 1e5 + 2 * YWindow.windowList.length;
  }
  constructor(params) {
    this._div = null;
    this._titleSpan = null;
    this._ModalDivShield = null;
    this._switchSideDiv = null;
    this._buttonsContainer = null;
    this._params = params.clone();
    YWindow.windowList.push(this);
    this._contents = document.createElement("DIV");
    if (params.createNow)
      this.allocate();
  }
  get innerContentDiv() {
    return this._contents;
  }
  get bottomKeepClear() {
    return this._params.bottomKeepClear;
  }
  set bottomKeepClear(value) {
    this._params.bottomKeepClear = value;
    if (this._contents != null) {
      this._contents.style.bottom = (this._params.WindowPadding + this._params.bottomKeepClear).toString() + "px";
    }
  }
  get outterContentDiv() {
    return this._div;
  }
  isModal() {
    if (this._div == null)
      return false;
    return this._div.style.display == "" && this._params.isModal;
  }
  get visible() {
    if (this._div == null)
      return false;
    return this._div.style.display == "";
  }
  set visible(v) {
    v ? this.show() : this.hide();
  }
  show(width) {
    if (this._div == null)
      this.allocate();
    this._div.style.display = "";
    if (this._ModalDivShield != null)
      this._ModalDivShield.style.display = "";
    this.brintToFront();
    if (typeof width !== "undefined" && this._params.positionType == 2) {
      this._div.style.width = width.toString() + "px";
    }
  }
  allocate() {
    if (this._div != null)
      return;
    if (this._params.isModal) {
      this._ModalDivShield = document.createElement("DIV");
      this._ModalDivShield.style.position = "fixed";
      this._ModalDivShield.style.left = "0px";
      this._ModalDivShield.style.top = "0px";
      this._ModalDivShield.style.right = "0px";
      this._ModalDivShield.style.bottom = "0px";
      this._ModalDivShield.style.backgroundColor = "rgba(255,255,255,0.85) ";
      document.body.appendChild(this._ModalDivShield);
    }
    this._div = document.createElement("DIV");
    this._div.style.display = "none";
    switch (this._params.positionType) {
      case 0:
        this._div.style.position = "absolute";
        this._div.style.left = this._params.left.toString() + "px";
        this._div.style.top = this._params.top.toString() + "px";
        this._div.style.width = this._params.width.toString() + "px";
        this._div.style.height = this._params.height.toString() + "px";
        break;
      case 1:
        this._div.style.position = "absolute";
        this._div.style.left = "50%";
        this._div.style.top = "50%";
        this._div.style.transform = "translate(-50%, -50%)";
        this._div.style.width = this._params.width.toString() + "px";
        this._div.style.height = this._params.height.toString() + "px";
        break;
      case 2:
        this._div.style.position = "fixed";
        this._div.style.top = "5px";
        this._div.style.right = "5px";
        this._div.style.bottom = "5px";
        this._div.style.width = this._params.width.toString() + "px";
        break;
    }
    this._div.style.border = this._params.WindowBorder;
    this._div.style.backgroundColor = this._params.WindowBackgroundColor;
    if (this._params.showShadow)
      this._div.style.boxShadow = " 4px 4px 4px 1px rgba(0,0,0,0.05)";
    let containerTop = this._params.WindowPadding;
    if (this._params.showHeader) {
      containerTop = this._params.WindowHeaderHeight + 3 * this._params.WindowPadding;
      let title = document.createElement("DIV");
      title.style.position = "absolute";
      title.style.left = this._params.WindowPadding.toString() + "px";
      title.style.top = this._params.WindowPadding.toString() + "px";
      title.style.right = this._params.WindowPadding.toString() + "px";
      title.style.height = this._params.WindowHeaderHeight.toString() + "px";
      title.style.border = this._params.WindowHeaderBorder;
      title.style.backgroundColor = this._params.WindowHeaderBackgroundColor;
      title.style.fontFamily = this._params.WindowHeaderFontFamily;
      title.style.color = this._params.WindowHeaderColor;
      title.style.fontSize = this._params.WindowHeaderFontSize.toString() + "px";
      title.style.paddingLeft = "5px";
      title.style.whiteSpace = "nowrap";
      title.addEventListener("click", () => {
        this.brintToFront();
      });
      this._titleSpan = document.createElement("SPAN");
      this._titleSpan.innerText = this._params.title;
      title.appendChild(this._titleSpan);
      if (this._params.closeIcon) {
        let closeDiv = document.createElement("DIV");
        closeDiv.style.position = "absolute";
        closeDiv.style.right = "0px";
        closeDiv.style.top = "0px";
        closeDiv.style.width = Math.round(this._params.WindowHeaderHeight + 5).toString() + "px";
        closeDiv.style.height = this._params.WindowHeaderHeight.toString() + "px";
        closeDiv.style.overflow = "hide";
        closeDiv.style.paddingLeft = "5px";
        closeDiv.tabIndex = 0;
        closeDiv.style.cursor = "pointer";
        closeDiv.style.backgroundColor = this._params.WindowHeaderBackgroundColor;
        closeDiv.innerHTML = ressources.CloseIcon(this._params.WindowHeaderHeight.toString(), false, false, false, false, "Click to close this window");
        closeDiv.addEventListener("click", () => {
          this.hide();
        });
        closeDiv.addEventListener("keypress", (e) => {
          if (e.key == "Enter")
            this.hide();
        });
        title.appendChild(closeDiv);
      }
      if (this._params.positionType == 2) {
        this._switchSideDiv = document.createElement("DIV");
        this._switchSideDiv.style.position = "absolute";
        this._switchSideDiv.style.width = Math.round(this._params.WindowHeaderHeight + 5).toString() + "px";
        this._switchSideDiv.style.right = Math.round(this._params.WindowHeaderHeight + 5) + "px";
        this._switchSideDiv.style.height = this._params.WindowHeaderHeight.toString() + "px";
        this._switchSideDiv.style.overflow = "hide";
        this._switchSideDiv.style.paddingLeft = "5px";
        this._switchSideDiv.style.top = "0px";
        this._switchSideDiv.style.cursor = "pointer";
        this._switchSideDiv.style.backgroundColor = this._params.WindowHeaderBackgroundColor;
        this._switchSideDiv.innerHTML = ressources.MoveToLeftIcon(this._params.WindowHeaderHeight.toString(), false, false, false, false, "Click to move editor on left side");
        this._switchSideDiv.addEventListener("click", () => {
          this.switchSide();
        });
        title.appendChild(this._switchSideDiv);
      }
      this._div.appendChild(title);
    }
    if (this._params.buttons.length > 0) {
      this._buttonsContainer = document.createElement("DIV");
      this._buttonsContainer.style.position = "absolute";
      this._buttonsContainer.style.bottom = Math.round(this._params.WindowPadding).toString() + "px";
      this._buttonsContainer.style.right = Math.round(this._params.WindowPadding).toString() + "px";
      this._buttonsContainer.style.textAlign = "right";
      for (let i = 0; i < this._params.buttons.length; i++) {
        this._buttonsContainer.appendChild(this._params.buttons[i].Element);
      }
      this._div.appendChild(this._buttonsContainer);
      this._buttonsContainer.style.height = (25 * this._params.GUICoef).toString() + "px";
      this._params.bottomKeepClear += Math.round(35 * this._params.GUICoef);
    }
    this._contents.style.position = "absolute";
    this._contents.style.left = this._params.WindowPadding.toString() + "px";
    this._contents.style.right = this._params.WindowPadding.toString() + "px";
    this._contents.style.top = containerTop.toString() + "px";
    this._contents.style.bottom = (this._params.WindowPadding + this._params.bottomKeepClear).toString() + "px";
    this._contents.style.paddingLeft = "5px";
    this._contents.style.paddingRight = "5px";
    if (this._contents.style.fontSize == "") {
      this._contents.style.fontSize = this._params.contentsDefaultFontSize.toString() + "px";
    }
    if (this._contents.style.fontFamily == "") {
      this._contents.style.fontFamily = this._params.contentsDefaultFontFamily;
    }
    if (this._params.showContainerBorders) {
      this._contents.style.border = this._params.WindowInnerBorder;
      this._contents.style.backgroundColor = this._params.WindowInnerBackgroundColor;
    } else {
      this._contents.style.border = "1px solid rgba(0, 0, 0, 0)";
      this._contents.style.backgroundColor = "";
    }
    this._contents.style.overflow = "hide";
    this._div.append(this._contents);
    document.body.appendChild(this._div);
  }
  hide() {
    if (this._div == null)
      return;
    this._div.style.display = "none";
    if (this._ModalDivShield != null)
      this._ModalDivShield.style.display = "none";
    if (this._params.closingCallBack != null)
      this._params.closingCallBack(this);
  }
  set title(value) {
    this._params.title = value;
    if (this._titleSpan != null) {
      this._titleSpan.innerText = value;
    }
  }
  brintToFront() {
    let n = -1;
    for (let i = 0; i < YWindow.windowList.length; i++) {
      if (YWindow.windowList[i] == this)
        n = i;
    }
    if (n < 0)
      return;
    YWindow.windowList.splice(n, 1);
    YWindow.windowList.push(this);
    for (let i = 0; i < YWindow.windowList.length; i++) {
      YWindow.windowList[i].zIndex = i;
    }
  }
  set zIndex(index) {
    if (this._div == null)
      return;
    this._div.style.zIndex = (100001 + 2 * index).toString();
    if (this._params.isModal)
      this._ModalDivShield.style.zIndex = (1e5 + 2 * index).toString();
  }
  switchSide() {
    if (this._div.style.left == "") {
      this._div.style.left = "5px";
      this._div.style.right = "";
      this._switchSideDiv.innerHTML = ressources.MoveToRightIcon(Math.round(20 * this._params.GUICoef).toString(), false, false, false, false, "Click to move editor on right side");
    } else {
      this._div.style.left = "";
      this._div.style.right = "5px";
      this._switchSideDiv.innerHTML = ressources.MoveToLeftIcon(Math.round(20 * this._params.GUICoef).toString(), false, false, false, false, "Click to move editor on left side");
    }
  }
};
YWindow.windowList = [];
var confirm = class {
  static ask(message, yes, no, userdata) {
    let params = new newWindowParam();
    params.positionType = 1;
    params.width = Math.min(Math.round(400 * constants.generalSizeCoef), Math.round(screen.width * 0.9));
    params.height = Math.min(Math.round(160 * constants.generalSizeCoef), Math.round(screen.height * 0.7));
    params.isModal = true;
    params.showHeader = false;
    params.showContainerBorders = false;
    let YesButton = new button("Yes", () => {
      confirm._window.hide();
      if (yes != null)
        yes(userdata);
    });
    let NoButton = new button("No", () => {
      confirm._window.hide();
      if (no != null)
        no(userdata);
    });
    params.buttons.push(YesButton);
    params.buttons.push(NoButton);
    confirm._window = new YWindow(params);
    let contents = confirm._window.innerContentDiv;
    let table = document.createElement("TABLE");
    table.style.width = "100%";
    let TR = document.createElement("TR");
    let TD = document.createElement("TD");
    TD.style.width = "10";
    TD.innerHTML = ressources.DontKnowIcon(Math.round(80 * constants.generalSizeCoef).toString(), true, false, false, false, "");
    TR.appendChild(TD);
    TD = document.createElement("TD");
    TD.style.paddingLeft = "20px";
    TD.style.fontFamily = constants.generalFontFamily;
    TD.style.fontSize = constants.generalFontSize.toString() + "px";
    TD.style.textAlign = "justify";
    TD.innerText = message;
    TR.appendChild(TD);
    table.appendChild(TR);
    contents.appendChild(table);
    confirm._window.show();
    return confirm._window;
  }
};
var notififaction = class {
  static show(icon, message) {
    let params = new newWindowParam();
    params.positionType = 1;
    params.width = Math.min(Math.round(400 * constants.generalSizeCoef), screen.width);
    params.height = Math.min(Math.round(160 * constants.generalSizeCoef), screen.height);
    params.isModal = true;
    params.showHeader = false;
    params.showContainerBorders = false;
    let okButton = new button("OK", () => {
      alert2._window.hide();
    });
    params.buttons.push(okButton);
    alert2._window = new YWindow(params);
    let contents = alert2._window.innerContentDiv;
    let table = document.createElement("TABLE");
    table.style.width = "100%";
    let TR = document.createElement("TR");
    let TD = document.createElement("TD");
    TD.style.width = "10";
    TD.innerHTML = icon;
    TR.appendChild(TD);
    TD = document.createElement("TD");
    TD.style.paddingLeft = "20px";
    TD.style.fontFamily = constants.generalFontFamily;
    TD.style.fontSize = constants.generalFontSize.toString() + "px";
    TD.style.textAlign = "justify";
    TD.innerText = message;
    TR.appendChild(TD);
    table.appendChild(TR);
    contents.appendChild(table);
    alert2._window.show();
    return alert2._window;
  }
};
var alert2 = class extends notififaction {
  static show(message) {
    return super.show(ressources.FailedIcon(Math.round(80 * constants.generalSizeCoef).toString(), true, false, false, false, ""), message);
  }
};

// obj/full/mainForm_rw.js
var mainForm = class {
  constructor() {
    this.GUIcoef = 1;
    let params = new newWindowParam();
    params.positionType = 1;
    this.GUIcoef = constants.generalSizeCoef;
    if (mainForm.REFWIDH * this.GUIcoef > screen.width)
      this.GUIcoef = screen.width / mainForm.REFWIDH;
    if (mainForm.REFHEIGHT * this.GUIcoef > screen.height)
      this.GUIcoef = screen.height / mainForm.REFHEIGHT;
    params.width = Math.round(mainForm.REFWIDH * this.GUIcoef);
    params.height = Math.round(mainForm.REFHEIGHT * this.GUIcoef);
    params.showHeader = false;
    params.showContainerBorders = false;
    this._window = new YWindow(params);
    let contents = this._window.innerContentDiv;
    let title = document.createElement("p");
    title.style.paddingTop = "0px";
    title.style.marginTop = 4 * this.GUIcoef + "px";
    title.style.fontSize = 16 * this.GUIcoef + "px";
    title.innerText = "Hello, welcome to Yocto-Visualization, what would you like to do?";
    title.style.textAlign = "center";
    contents.appendChild(title);
    let table = document.createElement("TABLE");
    table.style.position = "absolute";
    table.style.top = "0px";
    table.style.fontFamily = constants.generalFontFamily;
    table.style.tableLayout = "fixed";
    table.style.paddingLeft = Math.round(10 * this.GUIcoef).toString() + "px";
    table.style.paddingRight = Math.round(10 * this.GUIcoef).toString() + "px";
    table.style.paddingTop = Math.round(30 * this.GUIcoef).toString() + "px";
    table.style.paddingBottom = Math.round(15 * this.GUIcoef).toString() + "px";
    table.style.width = "100%";
    table.style.height = "100%";
    table.style.borderSpacing = Math.round(5 * this.GUIcoef).toString() + "px";
    let tr1 = document.createElement("TR");
    table.appendChild(tr1);
    let td11 = document.createElement("TD");
    tr1.appendChild(td11);
    let td12 = document.createElement("TD");
    tr1.appendChild(td12);
    let td13 = document.createElement("TD");
    tr1.appendChild(td13);
    let tr2 = document.createElement("TR");
    table.appendChild(tr2);
    let td21 = document.createElement("TD");
    tr2.appendChild(td21);
    let td22 = document.createElement("TD");
    tr2.appendChild(td22);
    let td23 = document.createElement("TD");
    tr2.appendChild(td23);
    contents.appendChild(table);
    let version = document.createElement("p");
    version.style.position = "absolute";
    version.style.right = "0px";
    version.style.bottom = "0px";
    version.style.marginBottom = "0px";
    version.style.paddingBottom = "0px";
    version.style.marginRight = "2px";
    version.style.fontSize = (8 * this.GUIcoef).toString() + "px";
    version.innerText = constants.buildVersion;
    version.style.color = "grey";
    version.style.textAlign = "right";
    contents.appendChild(version);
    let size = (128 * this.GUIcoef).toString();
    this.createButton(td11, "Configure global parameters", ressources.ConfigureIcon(size, true, false, false, false), () => {
      this.openConfig();
    });
    this.createButton(td12, "Create a new solid gauge", ressources.SolidGaugeIcon(size, true, false, false, false), () => {
      YWebPage.newGaugeWidget();
    });
    this.createButton(td13, "Create a new graph", ressources.GraphIcon(size, true, false, false, false), () => {
      YWebPage.newGraphWidget();
    });
    this.createButton(td21, "Get Raw data", ressources.RawDataIcon(size, true, false, false, false), () => {
      this.openRawData();
    });
    this.createButton(td22, "Create a new digital display", ressources.DigitalDisplayIcon(size, true, false, false, false), () => {
      YWebPage.newDigitalDisplayWidget();
    });
    this.createButton(td23, "Create a new angular gauge", ressources.AngularGaugeIcon(size, true, false, false, false), () => {
      YWebPage.newAngularGaugeWidget();
    });
  }
  hide() {
    this._window.hide();
  }
  show() {
    this._window.show();
  }
  createButton(container, caption, icon, callback) {
    container.style.border = "1px solid black";
    container.style.textAlign = "center";
    container.style.fontSize = (10 * this.GUIcoef).toString() + "px";
    container.style.paddingBottom = "3px";
    container.style.borderColor = "#808080";
    container.style.backgroundColor = "#f0f0f0";
    container.style.cursor = "pointer";
    container.addEventListener("mouseover", function() {
      container.style.backgroundColor = "white";
    });
    container.addEventListener("mouseout", function() {
      container.style.backgroundColor = "#f0f0f0";
    });
    let a = document.createElement("a");
    a.style.outline = "none";
    a.innerHTML = icon + "<br>" + caption;
    a.addEventListener("click", callback);
    a.tabIndex = 0;
    a.addEventListener("focusin", () => {
      container.style.backgroundColor = "white";
    });
    a.addEventListener("focusout", () => {
      container.style.backgroundColor = "f0f0f0";
    });
    a.addEventListener("keypress", (e) => {
      if (e.key == "Enter")
        callback();
    });
    container.appendChild(a);
  }
  openConfig() {
    configForm.show();
  }
  openRawData() {
    rawDataForm.show();
  }
};
mainForm.REFWIDH = 500;
mainForm.REFHEIGHT = 360;

// obj/full/Editor_rw.js
var EditedDataSource = class {
  constructor(source, root) {
    this._htmlchilds = [];
    this._source = source;
    this._root = root;
    this._htmlchilds = [];
  }
  storeChilds(childsList) {
    this._htmlchilds = [];
    for (let i = 0; i < childsList.length; i++) {
      this._htmlchilds.push(childsList.item(i));
    }
  }
  getStoredChilds() {
    return this._htmlchilds;
  }
  get root() {
    return this._root;
  }
  refresh() {
    if (this._root != null)
      this._root.refresh();
  }
};
var keyDataObject = class {
  constructor(key, data) {
    this.key = key;
    this.data = data;
  }
};
var objectDictionnary = class {
  constructor() {
    this.list = [];
  }
  isInlist(key) {
    for (let i = 0; i < this.list.length; i++) {
      if (key == this.list[i].key)
        return true;
    }
    return false;
  }
  find(key) {
    for (let i = 0; i < this.list.length; i++) {
      if (key == this.list[i].key)
        return this.list[i].data;
    }
    return null;
  }
  insert(key, data) {
    for (let i = 0; i < this.list.length; i++) {
      if (key == this.list[i].key) {
        this.list[i].data = data;
        return;
      }
    }
    this.list.push(new keyDataObject(key, data));
  }
};
var EditorBaseDef = class {
  refresh() {
  }
  get panel() {
    return null;
  }
  get expanded() {
    return true;
  }
  AllocateControls() {
  }
};
var PropertiesForm2 = class extends EditorBaseDef {
  get visible() {
    return this._window.visible;
  }
  set visible(v) {
    v ? this.show() : this.hide();
  }
  get text() {
    return this._text;
  }
  set text(value) {
    this._text = value;
    this._window.title = this._text;
  }
  get help() {
    return this._helpText;
  }
  set help(value) {
    this._helpText = value;
    this._helpPanel.innerHTML = this._helpText;
  }
  addTest(parentDiv) {
    PropertiesForm2.testid++;
    let mainlabel = document.createElement("DIV");
    mainlabel.style.position = "relative";
    mainlabel.style.display = "inline-block;";
    mainlabel.style.left = "0px";
    mainlabel.style.padding = "2px 2px 2px 2px";
    mainlabel.style.right = "5px";
    mainlabel.style.border = "1px solid black";
    mainlabel.style.marginTop = "2px";
    mainlabel.style.backgroundColor = "yellow";
    if (parentDiv != null) {
      parentDiv.appendChild(mainlabel);
    } else {
      this._container.appendChild(mainlabel);
    }
    let expandCtrl = document.createElement("ANCHOR");
    expandCtrl.innerText = "[+]";
    mainlabel.appendChild(expandCtrl);
    let mainText = document.createElement("SPAN");
    mainText.innerText = "Pouet " + PropertiesForm2.testid.toString();
    mainlabel.appendChild(mainText);
    let subElementPanel = document.createElement("DIV");
    subElementPanel.style.position = "relative";
    subElementPanel.style.display = "inline-block;";
    subElementPanel.style.left = "5px";
    subElementPanel.style.padding = "2px 2px 2px 2px";
    subElementPanel.style.right = "5px";
    subElementPanel.style.marginTop = "2px";
    subElementPanel.style.backgroundColor = "lightgray";
    subElementPanel.innerText = "sub elements";
    if (parentDiv != null) {
      parentDiv.appendChild(subElementPanel);
    } else {
      this._container.appendChild(subElementPanel);
    }
    return subElementPanel;
  }
  editorIsClosing(source) {
    if (this._editorClosedCallback != null)
      this._editorClosedCallback();
  }
  bestWidth() {
    let w = window.innerWidth / 4 >> 0;
    let minWidth = 275 * constants.guiDPIFactor;
    if (w < minWidth)
      w = minWidth;
    if (w > window.innerWidth - 10)
      w = window.innerWidth - 10;
    return w;
  }
  constructor() {
    super();
    this._hostWindow = null;
    this._editorClosedCallback = null;
    this.currentEditedDataSource = null;
    this._changeCallback = null;
    this._getvalueCallback = null;
    this._text = "Properties editor";
    this._helpText = "Properties editor";
    this.EditedDataSourceList = new objectDictionnary();
    let params = new newWindowParam();
    params.positionType = 2;
    params.width = this.bestWidth();
    params.createNow = true;
    params.closingCallBack = (source) => {
      this.editorIsClosing(source);
    };
    params.bottomKeepClear = PropertiesForm2.HelpHeight + 3 * constants.WindowPadding;
    params.title = this._text;
    this._window = new YWindow(params);
    this._container = this._window.innerContentDiv;
    this._helpPanel = document.createElement("DIV");
    this._helpPanel.style.position = "absolute";
    this._helpPanel.style.left = constants.WindowPadding.toString() + "px";
    this._helpPanel.style.bottom = constants.WindowPadding.toString() + "px";
    this._helpPanel.style.right = constants.WindowPadding.toString() + "px";
    this._helpPanel.style.height = PropertiesForm2.HelpHeight.toString() + "px";
    this._helpPanel.style.paddingLeft = "5px";
    this._helpPanel.style.paddingTop = "5px";
    this._helpPanel.style.overflowY = "auto";
    this._helpPanel.style.border = constants.WindowInnerBorder;
    this._helpPanel.style.backgroundColor = constants.WindowInnerBackgroundColor;
    this._helpPanel.style.fontFamily = constants.generalFontFamily;
    this._helpPanel.style.fontSize = constants.generalFontSize.toString() + "px";
    this._helpPanel.style.color = "black";
    this._helpPanel.style.display = "";
    this._helpPanel.innerHTML = "Help panel. Editor is loading, please wait....";
    this._window.outterContentDiv.appendChild(this._helpPanel);
    this._container.style.overflowY = "scroll";
    this._container.style.overflowX = "hidden";
    this._container.style.backgroundColor = constants.WindowInnerBackgroundColor;
    window.addEventListener("resize", () => {
      this.windowResized();
    });
  }
  windowResized() {
    if (this._window.innerContentDiv == null)
      return;
    if (this._window.innerContentDiv.offsetHeight < PropertiesForm2.MinHeightforShowingHelp && this._helpPanel.style.display == "") {
      this._helpPanel.style.display = "none";
      this._window.bottomKeepClear = 0;
    } else if (this._window.innerContentDiv.offsetHeight >= PropertiesForm2.MinHeightforShowingHelp + PropertiesForm2.HelpHeight && this._helpPanel.style.display != "") {
      this._helpPanel.style.display = "";
      this._window.bottomKeepClear = PropertiesForm2.HelpHeight;
    }
  }
  show() {
    this._window.show(this.bestWidth());
    this.windowResized();
  }
  hide() {
    YWidget.stopEdition();
    this._window.hide();
  }
  get panel() {
    return this._container;
  }
  refresh() {
    if (!this.visible)
      return;
    if (this.currentEditedDataSource == null)
      return;
    this.currentEditedDataSource.refresh();
  }
  refreshBanner() {
    if (this._hostWindow != null) {
      this.text = "Properties of " + this._hostWindow.Text;
    }
  }
  showWindow(hostWindow, structData, setvalueCallBack, getvalueCallBack, EditStoppedCallBack) {
    this._hostWindow = hostWindow;
    this._changeCallback = setvalueCallBack;
    this._getvalueCallback = getvalueCallBack;
    this.text = "Properties editor";
    this.show();
    this.refreshBanner();
    this.EditObject(structData, setvalueCallBack, getvalueCallBack, EditStoppedCallBack);
  }
  EditObject(structData, setvalueCallBack, getvalueCallBack, EditStoppedCallBack) {
    this._editorClosedCallback = EditStoppedCallBack;
    let helpYourselfMsg = "This is the property editor. Change any parameter you want. All changes are applied in real time.";
    if (!this.visible)
      return;
    this.help = "Please wait....";
    if (this.EditedDataSourceList.isInlist(structData)) {
      if (this.EditedDataSourceList.find(structData) == this.currentEditedDataSource) {
        this.help = helpYourselfMsg;
        return;
      }
    }
    if (this.currentEditedDataSource != null) {
      this.currentEditedDataSource.root.stopEdit();
      this.currentEditedDataSource.storeChilds(this._container.childNodes);
      while (this._container.firstChild) {
        this._container.removeChild(this._container.lastChild);
      }
    }
    let it;
    if (!this.EditedDataSourceList.isInlist(structData)) {
      let rootparam = new UIElementBaseParams(this._helpPanel, this, null, "root", "Root", "root node", "");
      it = new UIElement(rootparam);
      it.rootEditor = this;
      this.currentEditedDataSource = new EditedDataSource(structData, it);
      this.EditedDataSourceList.insert(structData, this.currentEditedDataSource);
      it.showLabel = false;
      it.expandable = true;
      it.ProcessNewType(structData);
      it.expanded = true;
    } else {
      this.currentEditedDataSource = this.EditedDataSourceList.find(structData);
      let childNodes = this.currentEditedDataSource.getStoredChilds();
      for (let i = 0; i < childNodes.length; i++) {
        this._container.appendChild(childNodes[i]);
      }
      this.currentEditedDataSource.refresh();
    }
    this.currentEditedDataSource.root.startEdit(setvalueCallBack, getvalueCallBack);
    this.currentEditedDataSource.root.resizeAll();
    this.help = helpYourselfMsg;
  }
  getConfigData() {
    let p = this._window.outterContentDiv.getBoundingClientRect();
    return "<PropertiesForm>\n<location x='" + p.left.toString() + "' y='" + p.top.toString() + "'/>\n<size     w='" + p.width.toString() + "' h='" + p.width.toString() + "'/>\n</PropertiesForm>\n";
  }
  Form1_SizeChanged(sender) {
    if (this.currentEditedDataSource == null)
      return;
    if (this.currentEditedDataSource.root != null)
      this.currentEditedDataSource.root.resizeAll();
  }
  valuechange(src) {
    let OriginalPropName = "";
    let fullpropname = "";
    let propType = "";
    if (this._changeCallback != null)
      this._changeCallback(src);
  }
};
PropertiesForm2.HelpHeight = Math.round(75 * constants.generalSizeCoef);
PropertiesForm2.MinHeightforShowingHelp = 175;
PropertiesForm2.testid = 0;

// obj/full/UIElements_rw.js
var UIElementBaseParams = class {
  constructor(p_descriptionLabel, p_parentNode, p_RootNode, p_internalname, p_label, p_description, p_isReadonlyCall) {
    this.expandable = false;
    this.isReadonlyCall = "";
    this.summary = null;
    this.structRoot = null;
    this.HelpZoneLabel = p_descriptionLabel;
    this.parentNode = p_parentNode;
    this.RootNode = p_RootNode;
    this.internalname = p_internalname;
    this.label = p_label;
    this.description = p_description;
    this.changeCausesParentRefresh = false;
    this.preExpanded = false;
    this.isReadonlyCall = p_isReadonlyCall;
  }
};
var PropPathinfo = class {
  constructor() {
    this.OriginalPropName = "";
    this.fullpropname = "";
    this.propType = "";
  }
};
var CustomAttributesExtractor = class {
  constructor(ps) {
    this.available = true;
    this.displayName = "unknown";
    this.category = "";
    this.displayDescription = "Not documented";
    this.prefinedValues = null;
    this.changeCausesParentRefresh = false;
    this.PreExpandedCategory = false;
    this.PreExpanded = false;
    this.summaryPropertyName = "";
    this.isReadOnlyCall = "";
    this.NotSavedInXML = false;
    this.ReadOnly = false;
    this.ParamCategorySummary = "";
    if ("OnlyAvailableon" in ps.Attributes)
      this.available = ps.Attributes["OnlyAvailableon"];
    if ("DisplayName" in ps.Attributes)
      this.displayName = ps.Attributes["DisplayName"];
    if ("CategoryAttribute" in ps.Attributes)
      this.category = ps.Attributes["CategoryAttribute"];
    if ("DescriptionAttribute" in ps.Attributes)
      this.displayDescription = ps.Attributes["DescriptionAttribute"];
    if ("AllowedValues" in ps.Attributes)
      this.prefinedValues = ps.Attributes["AllowedValues"];
    if ("ChangeCausesParentRefreshAttribute" in ps.Attributes)
      this.changeCausesParentRefresh = ps.Attributes["ChangeCausesParentRefreshAttribute"];
    if ("PreExpandedCategoryAttribute" in ps.Attributes)
      this.PreExpandedCategory = ps.Attributes["PreExpandedCategoryAttribute"];
    if ("PreExpandedAttribute" in ps.Attributes)
      this.PreExpanded = ps.Attributes["PreExpandedAttribute"];
    if ("ParamCategorySummaryAttribute" in ps.Attributes)
      this.summaryPropertyName = ps.Attributes["ParamCategorySummaryAttribute"];
    if ("IsReadonlyCallAttribute" in ps.Attributes)
      this.isReadOnlyCall = ps.Attributes["IsReadonlyCallAttribute"];
    if ("NotSavedInXMLAttribute" in ps.Attributes)
      this.NotSavedInXML = ps.Attributes["NotSavedInXMLAttribute"];
    if ("ReadOnlyAttribute " in ps.Attributes)
      this.ReadOnly = ps.Attributes["ReadOnlyAttribute "];
    if ("ParamCategorySummaryAttribute " in ps.Attributes)
      this.ParamCategorySummary = ps.Attributes["ParamCategorySummaryAttribute "];
  }
};
var UIElement = class extends EditorBaseDef {
  get parentNode() {
    return this._parentNode;
  }
  get targetFullName() {
    return this._targetFullName;
  }
  get expandIcon() {
    return ressources.ExpandIcon(UIElement.defaultFontSize.toString(), false, false, false, false, "Click to expand");
  }
  get colapseIcon() {
    return ressources.ColapseIcon(UIElement.defaultFontSize.toString(), false, false, false, false, "Click to colapse");
  }
  removeFromEditor() {
  }
  get panel() {
    return this.subElementPanel;
  }
  get editorHelpText() {
    return "";
  }
  get isRootElement() {
    return this._rootNode == this;
  }
  addToEditor() {
    if (this.mainlabel != null) {
      for (let i = 0; i < this._parentPanel.children.length; i++) {
        if (this._parentPanel.children[i] == this.mainlabel)
          return;
      }
      this._parentPanel.appendChild(this.mainlabel);
      this._parentPanel.appendChild(this.subElementPanel);
    }
  }
  refresh() {
    if (this.mainText != null)
      this.mainText.innerText = this.name + this.getSummary();
    for (let i = 0; i < this.subElements.length; i++) {
      this.subElements[i].refresh();
    }
    if (this._rootNode != null && this._rootNode.rootEditor != null)
      this._rootNode.rootEditor.refreshBanner();
  }
  tabReOrder(index) {
    if (this._expandable && this.expandCtrl != null)
      this.expandCtrl.tabIndex = index++;
    this.subElements.forEach((e) => {
      index = e.tabReOrder(index);
    });
    return index;
  }
  triggerValueChangeCallback() {
    if (this._valueChangeCallback != null)
      this._valueChangeCallback(this);
  }
  scrollToMakeVisible() {
    if (this.mainlabel == null)
      return;
    if (this._parentPanel == null)
      return;
    this.mainlabel.scrollIntoView();
  }
  control_GotFocus(sender) {
    let extraHelp = this.editorHelpText;
    if (extraHelp != "")
      extraHelp = " " + extraHelp;
    this._helpZoneLabel.innerHTML = this._description + extraHelp;
  }
  control_LostFocus(sender) {
    this._helpZoneLabel.innerHTML = "";
  }
  preExpandIfNeeded() {
    if (this._parentNode != null && this._parentNode.expanded) {
      this.AllocateControls();
      if (this.expandable)
        this.initExpandButton();
      this.initMainLabel();
    }
    this.initExpandButton();
  }
  constructor(p) {
    super();
    this.name = "NoName";
    this._targetFullName = "unknowTargetName";
    this.ExpandableDepth = 0;
    this._expanded = false;
    this._expandButtonSide = 0;
    this._rootEditor = null;
    this._description = "";
    this.expandCtrl = null;
    this.mainlabel = null;
    this.mainText = null;
    this.subElementPanel = null;
    this._rootNode = null;
    this._parentNode = null;
    this._parentPanel = null;
    this._changeCausesParentRefresh = false;
    this._isReadOnlyCall = "";
    this._controlsAllocated = false;
    this.expandButtonInitDone = false;
    this.mainLabelInitDone = false;
    this.subElements = [];
    this._valueChangeCallback = null;
    this._getValueCallback = null;
    this._shown = true;
    this._summaryCallback = null;
    this._showLabel = false;
    this._expandable = false;
    this._preExpanded = false;
    this.name = p.label;
    this._targetFullName = p.internalname;
    this._helpZoneLabel = p.HelpZoneLabel;
    this._description = p.description;
    this._changeCausesParentRefresh = p.changeCausesParentRefresh;
    this._expandable = p.expandable;
    this._preExpanded = p.preExpanded;
    this._structRoot = p.structRoot;
    this._isReadOnlyCall = p.isReadonlyCall;
    this._summaryProperty = p.summary;
    if (UIElement.baseheight == 0) {
      UIElement.baseheight = 12;
      UIElement.expandableShift = UIElement.baseheight + 2;
      UIElement.scrollBarWidth = 20;
    }
    this._parentNode = p.parentNode;
    this._rootNode = p.RootNode == null ? this : p.RootNode;
  }
  set rootEditor(value) {
    this._rootEditor = value;
  }
  get rootEditor() {
    return this._rootEditor;
  }
  initMainLabel() {
    if (this.mainlabel == null)
      return;
    if (this.mainLabelInitDone)
      return;
    this.ExpandableDepth = 0;
    let p = this;
    while (p != null) {
      if (p.expandable)
        this.ExpandableDepth++;
      p = p.parentNode;
    }
    this.mainText.innerText = this.name + this.getSummary();
    if (this.expandable && this._expandButtonSide == 0) {
      switch (this.ExpandableDepth) {
        case 1:
          this.mainlabel.style.backgroundColor = "Blue";
          this.mainText.style.color = "black";
          break;
        case 2:
          this.mainlabel.style.backgroundColor = "rgb(7,141,255)";
          this.mainText.style.color = "white";
          break;
        case 3:
          this.mainlabel.style.backgroundColor = "rgb(120,196,255)";
          break;
        case 4:
          this.mainlabel.style.backgroundColor = "rgb(213,237,255)";
          break;
        case 5:
          this.mainlabel.style.backgroundColor = "rgb(237,246,253)";
          break;
        default:
          this.mainlabel.style.backgroundColor = "rgb(246,251,255)";
          break;
      }
    } else {
      this.mainlabel.style.backgroundColor = "rgba( 0, 0, 0,0)";
    }
    this.mainLabelInitDone = true;
  }
  AllocateControls() {
    if (this._controlsAllocated)
      return;
    if (!this.isRootElement)
      this.parentNode.AllocateControls();
    this._parentPanel = this.parentNode.panel;
    if (this.mainlabel == null) {
      this.mainlabel = document.createElement("DIV");
      this.mainlabel.style.position = "relative";
      this.mainlabel.style.display = "inline-block;";
      this.mainlabel.style.left = "0px";
      this.mainlabel.style.padding = "2px 2px 2px 2px";
      this.mainlabel.style.overflow = "hidden";
      this.mainlabel.style.fontFamily = UIElement.defaultFontFamily;
      this.mainlabel.style.fontSize = UIElement.defaultFontSize.toString() + "px";
      this.mainlabel.style.right = "5px";
      this.mainlabel.style.whiteSpace = "nowrap";
      this.mainlabel.style.marginTop = "2px";
      this.mainlabel.style.backgroundColor = "yellow";
      this.mainText = document.createElement("SPAN");
      this.mainText.innerText = "Pouet";
      this.mainlabel.appendChild(this.mainText);
      this.mainlabel.style.display = this.isRootElement ? "none" : "";
      this.initMainLabel();
      if (this._parentPanel == null) {
        debugger;
      }
      this._parentPanel.appendChild(this.mainlabel);
    }
    if (this._expandable && this.expandCtrl == null) {
      this.expandCtrl = document.createElement("ANCHOR");
      if (this._expandButtonSide == 0) {
        this.mainlabel.insertBefore(this.expandCtrl, this.mainText);
      }
      this.initExpandButton();
      this.subElementPanel = document.createElement("DIV");
      this.subElementPanel.style.position = "relative";
      this.subElementPanel.style.display = "inline-block;";
      this.subElementPanel.style.left = this.isRootElement ? "0px" : "5px";
      this.subElementPanel.style.padding = "2px 2px 2px 2px";
      this.subElementPanel.style.right = "5px";
      this.subElementPanel.style.display = "none";
      this.subElementPanel.style.marginTop = "2px";
      this.subElementPanel.style.marginRight = "2px";
      this._parentPanel.appendChild(this.subElementPanel);
    }
    this._controlsAllocated = true;
  }
  initExpandButton() {
    if (this.expandCtrl == null)
      return;
    if (this.expandButtonInitDone)
      return;
    this.expandCtrl.innerHTML = this.expandIcon;
    this.expandCtrl.style.top = "0px";
    this.expandCtrl.style.left = "0px";
    this.expandCtrl.style.cursor = "pointer";
    this.expandCtrl.style.backgroundColor = "white";
    this.expandCtrl.style.marginRight = "3px";
    this.expandCtrl.style.paddingLeft = "0px";
    this.expandCtrl.style.paddingRight = "0px";
    this.expandCtrl.style.paddingTop = "1px";
    this.expandCtrl.style.marginTop = "0px";
    this.expandCtrl.style.marginBottom = "0px";
    this.expandCtrl.style.paddingBottom = "0px";
    this.expandCtrl.style.paddingRight = "0px";
    this.expandCtrl.addEventListener("click", () => {
      this.ToggleExpand();
    });
    this.expandCtrl.addEventListener("keyup", (e) => {
      if (e.key === "Enter" || e.key === " ")
        this.ToggleExpand();
    });
    this.expandCtrl.addEventListener("focusin", () => {
      this.control_GotFocus(this);
    });
    this.expandCtrl.addEventListener("focusout", () => {
      this.control_LostFocus(this);
    });
    this.expandButtonInitDone = true;
  }
  get rowHeight() {
    return UIElement.baseheight;
  }
  ExtractPropPath(info) {
    let index = -1;
    let path = [];
    let p = this;
    info.OriginalPropName = p.targetFullName;
    do {
      info.fullpropname = p.targetFullName;
      index = info.fullpropname.indexOf("_");
      if (index < 0) {
        if (info.fullpropname != UIElement.ARTIFICIALSECTIONNAME)
          path.splice(0, 0, info.fullpropname);
        p = p.parentNode;
        if (p == null)
          throw "invalid Property name";
      }
    } while (index < 0);
    info.propType = info.fullpropname.substring(0, index);
    let propname = info.fullpropname.substring(index + 1);
    path.splice(0, 0, propname);
    return path;
  }
  startEdit(setcallback, getCallback) {
    this.addToEditor();
    this._valueChangeCallback = setcallback;
    this._getValueCallback = getCallback;
    this.subElements.forEach((item) => {
      item.startEdit(setcallback, getCallback);
    });
  }
  stopEdit() {
    this.removeFromEditor();
    this._valueChangeCallback = null;
    this._getValueCallback = null;
    this.subElements.forEach((item) => {
      item.stopEdit();
    });
  }
  expand() {
    this.subElements.forEach((e) => {
      e.AllocateControls();
      e.show();
    });
    this._rootNode.tabReOrder(0);
    this._expanded = true;
    this.subElementPanel.style.display = "";
    this.expandCtrl.innerHTML = this.colapseIcon;
  }
  colapse() {
    this.subElementPanel.style.display = "none";
    this.expandCtrl.innerHTML = this.expandIcon;
  }
  get expanded() {
    return this._expanded;
  }
  set expanded(value) {
    this._expanded = value;
    if (this._expanded) {
      this.expand();
    } else {
      this.colapse();
    }
    this._rootNode.resizeAll();
  }
  ToggleExpand() {
    this.expanded = !this.expanded;
  }
  getSummary() {
    if (this._summaryProperty != null) {
      return " (" + Reflect.get(this._structRoot, this._summaryProperty.name) + ")";
    }
    return "";
  }
  sensorList() {
    let res = [];
    sensorsManager.sensorList.forEach((s) => {
      res.push(s);
    });
    return res;
  }
  ProcessNewType(dataStucture) {
    let subsections = {};
    this._structRoot = dataStucture;
    let toExpand = [];
    let properties = GenericProperties.getAllProperties(dataStucture);
    for (let i = 0; i < properties.byIndex.length; i++) {
      let ps = properties.byIndex[i];
      if (ps.isWritable) {
        let attr = new CustomAttributesExtractor(ps);
        if (attr.available) {
          let section = this;
          if (attr.category != "") {
            if (attr.category in subsections) {
              section = subsections[attr.category];
            } else {
              let sectionparam = new UIElementBaseParams(this._helpZoneLabel, this, this._rootNode, UIElement.ARTIFICIALSECTIONNAME, attr.category, attr.category + " section, expand for more...", "");
              sectionparam.preExpanded = attr.PreExpandedCategory;
              sectionparam.expandable = true;
              sectionparam.structRoot = dataStucture;
              if (attr.summaryPropertyName != "") {
                sectionparam.summary = ps;
              }
              section = new UIElement(sectionparam);
              if (attr.PreExpandedCategory)
                toExpand.push(section);
              section.showLabel = true;
              subsections[attr.category] = section;
              this.addSubElement(section);
            }
          }
          let elParam = new UIElementBaseParams(this._helpZoneLabel, section, this._rootNode, ps.name, attr.displayName, attr.displayDescription, attr.isReadOnlyCall);
          elParam.preExpanded = attr.PreExpanded;
          elParam.changeCausesParentRefresh = attr.changeCausesParentRefresh;
          let targetName = this._targetFullName;
          let targetPrefix = "";
          let p = targetName.indexOf("_");
          if (p >= 0) {
            targetPrefix = targetName.substring(0, p);
            targetName = targetName.substring(p + 1);
          }
          if (ps.isEnum) {
            let s = new UIElementEnum(elParam, dataStucture, ps);
            section.addSubElement(s);
          } else {
            switch (ps.type) {
              case "number":
                if (attr.prefinedValues == null) {
                  let n = new UIElementNumber(elParam, dataStucture, ps);
                  section.addSubElement(n);
                } else {
                  let s2 = new UIElementList(elParam, dataStucture, ps, () => {
                    return attr.prefinedValues;
                  });
                  section.addSubElement(s2);
                }
                break;
              case "boolean":
                let b = new UIElementBoolean(elParam, dataStucture, ps);
                section.addSubElement(b);
                break;
              case doubleNan.name:
                let d = new UIElementDoubleNan(elParam, dataStucture, ps);
                section.addSubElement(d);
                break;
              case NullYSensor.name:
              case CustomYSensor.name:
                let s = new UIElementList(elParam, dataStucture, ps, () => {
                  return this.sensorList();
                });
                section.addSubElement(s);
                break;
              case YColor.name:
                let c = new UIElementColor(elParam, dataStucture, ps);
                section.addSubElement(c);
                break;
              case xAxisPosition.name:
                let p2 = new UIElementMarkerPos(elParam, dataStucture, ps);
                section.addSubElement(p2);
                break;
              case "string":
                if (attr.prefinedValues == null) {
                  let s2 = new UIElementString(elParam, dataStucture, ps);
                  section.addSubElement(s2);
                } else {
                  let s2 = new UIElementList(elParam, dataStucture, ps, () => {
                    return attr.prefinedValues;
                  });
                  section.addSubElement(s2);
                }
                break;
              default:
                {
                  elParam.expandable = true;
                  elParam.preExpanded = attr.PreExpanded;
                  let subobjectsection = new UIElement(elParam);
                  if (attr.PreExpanded)
                    toExpand.push(subobjectsection);
                  subobjectsection.showLabel = true;
                  section.addSubElement(subobjectsection);
                  subobjectsection.ProcessNewType(dataStucture[ps.name]);
                }
                break;
            }
          }
        }
      } else {
        if (ps.name == "summary") {
          this._summaryProperty = ps;
        }
      }
    }
    if (this._summaryProperty != null)
      this.refresh();
    toExpand.forEach((e) => {
      e.expand();
    });
  }
  show() {
    this._shown = true;
    if (this.mainlabel != null)
      this.mainlabel.style.display = "";
    if (this.expandCtrl != null)
      this.expandCtrl.style.display = this._expandable ? "" : "hidden";
    if (this.expanded) {
      this.subElements.forEach((e) => {
        e.show();
      });
    }
  }
  hide() {
    this._shown = false;
    if (this.mainlabel != null)
      this.mainlabel.style.display = "hidden";
    if (this.expandCtrl != null)
      this.expandCtrl.style.display = this._expandable ? "hidden" : "";
    this.subElements.forEach((e) => {
      e.hide();
    });
  }
  ExpandCtrl_Click_expand(sender) {
    this.expanded = !this._expanded;
  }
  resizeAll() {
    this.resize(0, 0, 0, 0);
    if (this.expanded) {
      this.subElements.forEach((e) => {
        e.resizeAll();
      });
    }
  }
  get showLabel() {
    return this._showLabel;
  }
  set showLabel(value) {
    this._showLabel = value;
    if (this.expandCtrl != null)
      this.expandCtrl.style.display = value && this._expandable ? "" : "hidden";
  }
  get expandable() {
    return this._expandable;
  }
  set expandable(value) {
    this._expandable = value;
    if (!value)
      return;
    if (this.expandCtrl == null) {
      this.AllocateControls();
      this.initExpandButton();
    }
    this.expandCtrl.style.display = value && this._showLabel ? "" : "hidden";
  }
  addSubElement(node) {
    this.subElements.push(node);
  }
  computeHeight() {
    return 0;
  }
  resize(top2, left1, left2, width) {
    return 0;
  }
};
UIElement.defaultFontFamily = constants.generalFontFamily;
UIElement.defaultFontSize = constants.generalFontSize;
UIElement.ARTIFICIALSECTIONNAME = "-ignore-";
UIElement.baseheight = 0;
UIElement.indentation = 16;
UIElement.expandableShift = 0;
UIElement.scrollBarWidth = 0;
UIElement.expandableVerticalOffset = 2;
var UIElementGeneric = class extends UIElement {
  constructor(p, dataContainer, prop) {
    super(p);
    this.input = null;
    this.select = null;
    this._prop = prop;
    this._dataContainer = dataContainer;
    this._showLabel = true;
    if (this._preExpanded)
      this.AllocateControls();
    if (this._expandable && this._preExpanded)
      this.expand();
  }
  removeFromEditor() {
    super.removeFromEditor();
  }
  tabReOrder(index) {
    if (this.input != null)
      this.input.tabIndex = index++;
    this.subElements.forEach((e) => {
      index = e.tabReOrder(index);
    });
    return index;
  }
  addToEditor() {
    super.addToEditor();
  }
  show() {
    super.show();
    if (this.input != null)
      this.input.style.visibility = "";
  }
  checkForReadOnly() {
    if (this.input == null && this.select == null)
      return;
    if (this._isReadOnlyCall != "") {
      let ro = Reflect.get(this._dataContainer, this._isReadOnlyCall);
      if (this.input != null)
        this.input.disabled = ro;
      if (this.select != null)
        this.select.disabled = ro;
    }
  }
  hide() {
    if (this.input != null)
      this.input.style.visibility = "hidden";
    super.hide();
  }
  resize(top2, left1, left2, width) {
    return 0;
  }
};
var UIElementString = class extends UIElementGeneric {
  constructor(p, dataContainer, prop) {
    super(p, dataContainer, prop);
    this._value = "";
    this.preExpandIfNeeded();
  }
  AllocateControls() {
    super.AllocateControls();
    if (this.input == null) {
      this.input = document.createElement("INPUT");
      this.input.type = "input";
      this.input.value = Reflect.get(this._dataContainer, this._prop.name);
      this.input.style.position = "absolute";
      this.input.style.marginTop = "0px";
      this.input.style.marginBottom = "0px";
      this.input.style.fontFamily = UIElement.defaultFontFamily;
      this.input.style.fontSize = UIElement.defaultFontSize.toString() + "px";
      this.input.style.border = "1px solid grey";
      this.input.style.borderRadius = "1px";
      this.input.style.top = "0px";
      this.input.style.right = "3px";
      this.input.style.width = "50%";
      this.mainlabel.appendChild(this.input);
      new InputFieldManager(this.input, 0, true, Number.NaN, Number.NaN, () => {
        this.Text_TextChanged(null);
      });
      this.input.addEventListener("focusin", () => {
        this.control_GotFocus(this);
      });
      this.input.addEventListener("focusout", () => {
        this.control_LostFocus(this);
      });
      this.checkForReadOnly();
    }
  }
  refresh() {
    if (this.input == null)
      return;
    if (this._getValueCallback == null)
      return;
    let value = this._getValueCallback(this);
    if (value == null)
      return;
    let s = value.toString();
    if (this.input != null) {
      if (s != this.input.value)
        this.input.value = s;
    }
    this.checkForReadOnly();
  }
  Text_TextChanged(sender) {
    if (this.input != null) {
      this._value = this.input.value;
      Reflect.set(this._dataContainer, this._prop.name, this._value);
      if (this._valueChangeCallback != null)
        this._valueChangeCallback(this);
      if (this._changeCausesParentRefresh)
        this.parentNode.refresh();
    }
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value;
    this.input.value = value;
  }
  resize(top2, left1, left2, width) {
    this.mainlabel.style.height = this.input.offsetHeight.toString() + "px";
    return 0;
  }
};
var UIElementNumber = class extends UIElementGeneric {
  constructor(p, dataContainer, prop) {
    super(p, dataContainer, prop);
    this._value = 0;
    this.preExpandIfNeeded();
  }
  AllocateControls() {
    super.AllocateControls();
    if (this.input == null) {
      this.input = document.createElement("INPUT");
      this.input.type = "input";
      this.input.value = Reflect.get(this._dataContainer, this._prop.name);
      this.input.style.textAlign = "right";
      this.input.style.position = "absolute";
      this.input.style.marginTop = "0px";
      this.input.style.marginBottom = "0px";
      this.input.style.fontFamily = UIElement.defaultFontFamily;
      this.input.style.fontSize = UIElement.defaultFontSize.toString() + "px";
      this.input.type = "number";
      this.input.style.border = "1px solid grey";
      this.input.style.borderRadius = "1px";
      this.input.style.top = "0px";
      this.input.style.right = "3px";
      this.input.style.width = "50%";
      this.mainlabel.appendChild(this.input);
      new InputFieldManager(this.input, 4, false, Number.NaN, Number.NaN, () => {
        this.Text_TextChanged(null);
      });
      this.input.addEventListener("focusin", () => {
        this.control_GotFocus(this);
      });
      this.input.addEventListener("focusout", () => {
        this.control_LostFocus(this);
      });
      this.checkForReadOnly();
    }
  }
  refresh() {
    if (this.input == null)
      return;
    if (this._getValueCallback == null)
      return;
    let s = this._getValueCallback(this);
    if (s == null)
      return;
    if (this.input != null) {
      if (s != parseFloat(this.input.value))
        this.input.value = s.toString();
    }
    this.checkForReadOnly();
  }
  Text_TextChanged(sender) {
    if (this.input != null) {
      this._value = parseFloat(this.input.value);
      Reflect.set(this._dataContainer, this._prop.name, this._value);
      if (this._valueChangeCallback != null)
        this._valueChangeCallback(this);
      if (this._changeCausesParentRefresh)
        this.parentNode.refresh();
    }
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value;
    this.input.value = value.toString();
  }
  resize(top2, left1, left2, width) {
    this.mainlabel.style.height = this.input.offsetHeight.toString() + "px";
    return 0;
  }
};
var UIElementBoolean = class extends UIElementGeneric {
  constructor(p, dataContainer, prop) {
    super(p, dataContainer, prop);
    this._text = null;
    this._value = false;
    this.preExpandIfNeeded();
  }
  AllocateControls() {
    super.AllocateControls();
    if (this.input == null) {
      let span = document.createElement("SPAN");
      span.style.position = "absolute";
      span.style.display = "inline-block";
      span.style.width = "50%";
      span.style.right = "0px";
      this.mainlabel.appendChild(span);
      this.input = document.createElement("INPUT");
      this.input.type = "input";
      this.input.checked = Reflect.get(this._dataContainer, this._prop.name);
      this.input.style.textAlign = "right";
      this.input.style.display = "inline";
      this.input.style.marginTop = "0px";
      this.input.style.marginBottom = "0px";
      this.input.type = "checkbox";
      this.input.style.transform = "scale(" + constants.generalSizeCoef.toString() + ")";
      this.input.style.marginRight = Math.round(5 * constants.generalSizeCoef).toString() + "px";
      this.input.style.top = "0px";
      this.input.style.border = "1px solid grey";
      this.input.style.borderRadius = "1px";
      span.appendChild(this.input);
      this.input.addEventListener("keyup", (e) => {
        if (e.key === " ")
          this.value_TextChanged(null);
      });
      this.input.addEventListener("change", () => {
        this.value_TextChanged(null);
      });
      this._text = document.createElement("SPAN");
      this._text.style.display = "inline";
      this._text.style.fontFamily = UIElement.defaultFontFamily;
      this._text.style.fontSize = UIElement.defaultFontSize.toString() + "px";
      span.appendChild(this._text);
      this.updateText();
      this.input.addEventListener("focusin", () => {
        this.control_GotFocus(this);
      });
      this.input.addEventListener("focusout", () => {
        this.control_LostFocus(this);
      });
      this.checkForReadOnly();
    }
  }
  updateText() {
    this._text.innerText = this.input.checked ? "Enabled" : "Disabled";
  }
  refresh() {
    if (this.input == null)
      return;
    this.checkForReadOnly();
    if (this._getValueCallback == null)
      return;
    let v = this._getValueCallback(this);
    if (v == null)
      return;
    let b = v;
    if (this.input != null) {
      this.input.checked = b.valueOf();
      this.updateText();
    }
  }
  value_TextChanged(sender) {
    if (this.input != null) {
      this._value = this.input.checked;
      this.updateText();
      Reflect.set(this._dataContainer, this._prop.name, this._value);
      if (this._valueChangeCallback != null)
        this._valueChangeCallback(this);
      if (this._changeCausesParentRefresh)
        this.parentNode.refresh();
    }
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value;
    this.input.checked = value;
    this.updateText();
  }
  resize(top2, left1, left2, width) {
    return 0;
  }
};
var UIElementDoubleNan = class extends UIElementGeneric {
  constructor(p, dataContainer, prop) {
    super(p, dataContainer, prop);
    this._value = 0;
    this.preExpandIfNeeded();
  }
  AllocateControls() {
    super.AllocateControls();
    if (this.input == null) {
      this.input = document.createElement("INPUT");
      this.input.type = "input";
      this.input.value = Reflect.get(this._dataContainer, this._prop.name).toString();
      this.input.style.textAlign = "right";
      this.input.style.position = "absolute";
      this.input.style.marginTop = "0px";
      this.input.style.marginBottom = "0px";
      this.input.style.fontFamily = UIElement.defaultFontFamily;
      this.input.style.fontSize = UIElement.defaultFontSize.toString() + "px";
      this.input.type = "number";
      this.input.style.border = "1px solid grey";
      this.input.style.borderRadius = "1px";
      this.input.style.top = "0px";
      this.input.style.right = "3px";
      this.input.style.width = "50%";
      this.mainlabel.appendChild(this.input);
      new InputFieldManager(this.input, 4, true, Number.NaN, Number.NaN, () => {
        this.Text_TextChanged(null);
      });
      this.input.addEventListener("focusin", () => {
        this.control_GotFocus(this);
      });
      this.input.addEventListener("focusout", () => {
        this.control_LostFocus(this);
      });
      this.checkForReadOnly();
    }
  }
  refresh() {
    if (this.input == null)
      return;
    if (this._getValueCallback == null)
      return;
    let s = this._getValueCallback(this).toString();
    if (this.input != null) {
      if (s != this.input.value)
        this.input.value = s;
    }
    this.checkForReadOnly();
  }
  Text_TextChanged(sender) {
    if (this.input != null) {
      this._value = this.input.value == "" ? Number.NaN : parseFloat(this.input.value);
      Reflect.set(this._dataContainer, this._prop.name, new doubleNan(this._value));
      if (this._valueChangeCallback != null)
        this._valueChangeCallback(this);
      if (this._changeCausesParentRefresh)
        this.parentNode.refresh();
    }
  }
  get value() {
    return new doubleNan(this._value);
  }
  set value(value) {
    this._value = value.value;
    this.input.value = value.toString();
  }
  resize(top2, left1, left2, width) {
    this.mainlabel.style.height = this.input.offsetHeight.toString() + "px";
    return 0;
  }
};
var UIElementEnum = class extends UIElementGeneric {
  constructor(p, dataContainer, prop) {
    super(p, dataContainer, prop);
    this.allValues = [];
    this._value = "";
    this.preExpandIfNeeded();
  }
  AllocateControls() {
    super.AllocateControls();
    if (this.select == null) {
      this.select = document.createElement("SELECT");
      let enumvalue = Reflect.get(this._dataContainer, this._prop.name);
      this.allValues = enumvalue.sibblings;
      for (let i = 0; i < this.allValues.length; i++) {
        let opt = document.createElement("OPTION");
        opt.text = this.allValues[i].description;
        opt.value = this.allValues[i].toString;
        this.select.add(opt, null);
      }
      this.select.value = enumvalue.toString;
      this.select.style.position = "absolute";
      this.select.style.marginTop = "0px";
      this.select.style.marginBottom = "0px";
      this.select.style.fontFamily = UIElement.defaultFontFamily;
      this.select.style.fontSize = UIElement.defaultFontSize.toString() + "px";
      this.select.style.top = "0px";
      this.select.style.right = "3px";
      this.select.style.width = "50%";
      this.mainlabel.appendChild(this.select);
      this.select.addEventListener("change", () => {
        this.valueChanged(null);
      });
      this.select.addEventListener("focusin", () => {
        this.control_GotFocus(this);
      });
      this.select.addEventListener("focusout", () => {
        this.control_LostFocus(this);
      });
      this.checkForReadOnly();
    }
  }
  refresh() {
    if (this.select == null)
      return;
    if (this._getValueCallback == null)
      return;
    let value = this._getValueCallback(this);
    let s = value.toString;
    if (this.select != null) {
      if (s != this.select.value)
        this.select.value = s;
    }
    this.checkForReadOnly();
  }
  valueChanged(sender) {
    if (this.select != null) {
      this._value = this.select.value;
      let it = null;
      for (let i = 0; i < this.allValues.length; i++) {
        if (this.allValues[i].toString == this._value)
          it = this.allValues[i];
      }
      if (it != null)
        Reflect.set(this._dataContainer, this._prop.name, it);
      if (this._valueChangeCallback != null)
        this._valueChangeCallback(this);
      if (this._changeCausesParentRefresh)
        this.parentNode.refresh();
    }
  }
  tabReOrder(index) {
    if (this.select != null)
      this.select.tabIndex = index++;
    return index;
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value;
    this.select.value = value;
  }
  resize(top2, left1, left2, width) {
    this.mainlabel.style.height = this.select.offsetHeight.toString() + "px";
    return 0;
  }
};
var UIElementList = class extends UIElementGeneric {
  constructor(p, dataContainer, prop, allowedValues) {
    super(p, dataContainer, prop);
    this._refreshCallback = null;
    this._indexedValue = true;
    this.allValues = [];
    this.valueType = "";
    this._value = "";
    this._refreshCallback = allowedValues;
    this.preExpandIfNeeded();
  }
  AllocateControls() {
    super.AllocateControls();
    if (this.select == null) {
      this.allValues = this._refreshCallback();
      this.select = document.createElement("SELECT");
      let value = Reflect.get(this._dataContainer, this._prop.name);
      this.valueType = typeof value;
      this._indexedValue = typeof value == "number" && typeof this.allValues[0] != "number";
      let found = false;
      let first = null;
      for (let i = 0; i < this.allValues.length; i++) {
        let opt = document.createElement("OPTION");
        if (i == 0)
          first = opt;
        opt.text = this.allValues[i].toString();
        opt.value = this._indexedValue ? i : this.allValues[i];
        this.select.add(opt, null);
        if (opt.value.toString() == value.toString())
          found = true;
      }
      if (!found && !this._indexedValue) {
        let opt = document.createElement("OPTION");
        opt.text = value.toString();
        opt.value = value;
        this.select.add(opt, first);
      }
      this.select.value = value;
      this.select.style.position = "absolute";
      this.select.style.marginTop = "0px";
      this.select.style.marginBottom = "0px";
      this.select.style.fontFamily = UIElement.defaultFontFamily;
      this.select.style.fontSize = UIElement.defaultFontSize.toString() + "px";
      this.select.style.top = "0px";
      this.select.style.right = "3px";
      this.select.style.width = "50%";
      this.mainlabel.appendChild(this.select);
      this.select.addEventListener("change", () => {
        this.valueChanged(null);
      });
      this.select.addEventListener("focusin", () => {
        this.control_GotFocus(this);
      });
      this.select.addEventListener("focusout", () => {
        this.control_LostFocus(this);
      });
      this.checkForReadOnly();
    }
  }
  refresh() {
    if (this.select == null)
      return;
    if (this._getValueCallback == null)
      return;
    this.allValues = this._refreshCallback();
    for (let i = 0; i < this.allValues.length; i++) {
      let opt = i < this.select.options.length ? this.select.options[i] : document.createElement("OPTION");
      opt.text = this.allValues[i].toString();
      opt.value = this._indexedValue ? i : this.allValues[i];
      if (i >= this.select.options.length)
        this.select.add(opt, null);
    }
    while (this.allValues.length < this.select.options.length) {
      this.select.options[this.select.options.length - 1].remove();
    }
    let v = Reflect.get(this._dataContainer, this._prop.name);
    if (v == null)
      return;
    if (this._indexedValue) {
      let it = Number(v).toString();
      if (this.select.value != it)
        this.select.value = it;
    } else {
      let it = v.toString();
      if (this.select.value != it)
        this.select.value = it;
    }
    this.checkForReadOnly();
  }
  valueChanged(sender) {
    if (this.select != null) {
      this._value = this.select.value;
      if (this.valueType == "number") {
        let it = parseInt(this._value);
        if (it >= 0)
          Reflect.set(this._dataContainer, this._prop.name, it);
      } else {
        let it = "";
        for (let i = 0; i < this.allValues.length; i++) {
          if (this.allValues[i] == this._value)
            it = this.allValues[i];
        }
        if (it != "")
          Reflect.set(this._dataContainer, this._prop.name, it);
      }
      if (this._valueChangeCallback != null)
        this._valueChangeCallback(this);
      if (this._changeCausesParentRefresh) {
        this.parentNode.refresh();
      }
    }
  }
  tabReOrder(index) {
    if (this.select != null)
      this.select.tabIndex = index++;
    return index;
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value;
    this.select.value = value;
  }
  resize(top2, left1, left2, width) {
    this.mainlabel.style.height = this.select.offsetHeight.toString() + "px";
    return 0;
  }
};
var UIElementColor = class extends UIElementGeneric {
  constructor(p, dataContainer, prop) {
    super(p, dataContainer, prop);
    this.colorSample = null;
    this.colorEditor = null;
    this.colorPreview = null;
    this.currentColor = null;
    this._value = "";
    this.preExpandIfNeeded();
  }
  get expandIcon() {
    return ressources.DotDotDotIcon(UIElement.defaultFontSize.toString(), false, false, false, false, "Click to open color chooser");
  }
  get colapseIcon() {
    return ressources.DotDotDotIcon(UIElement.defaultFontSize.toString(), false, false, false, false, "Click to close color chooser");
  }
  AllocateControls() {
    this._expandable = true;
    this._expandButtonSide = 1;
    super.AllocateControls();
    if (this.input == null) {
      let table = document.createElement("TABLE");
      table.style.position = "absolute";
      table.style.top = "0px";
      table.style.right = "3px";
      table.style.width = "50%";
      table.style.borderCollapse = "collapse";
      let tr = document.createElement("TR");
      table.appendChild(tr);
      let td1 = document.createElement("TD");
      tr.appendChild(td1);
      this.colorSample = document.createElement("Div");
      this.colorSample.style.display = "inline-block";
      this.colorSample.style.border = "1px solid black";
      this.colorSample.style.marginRight = "1px";
      this.colorSample.style.marginTop = "0px";
      this.colorSample.style.width = "16px";
      this.colorSample.style.height = "16px";
      this.colorSample.style.top = "0px";
      this.colorSample.style.bottom = "0px";
      this.colorPreview = new ColorSampler(this.colorSample, null);
      td1.appendChild(this.colorSample);
      let td2 = document.createElement("TD");
      td2.style.width = "100%";
      tr.appendChild(td2);
      this.input = document.createElement("INPUT");
      this.input.type = "input";
      this.currentColor = Reflect.get(this._dataContainer, this._prop.name);
      this.colorPreview.color = this.currentColor;
      this.input.value = this.currentColor.toString();
      this.input.style.marginTop = "0px";
      this.input.style.marginBottom = "0px";
      this.input.style.width = "100%";
      this.input.style.border = "1px solid grey";
      this.input.style.borderRadius = "1px";
      this.input.style.fontFamily = UIElement.defaultFontFamily;
      this.input.style.fontSize = UIElement.defaultFontSize.toString() + "px";
      td2.appendChild(this.input);
      let td3 = document.createElement("TD");
      td3.style.paddingLeft = "5px";
      tr.appendChild(td3);
      td3.appendChild(this.expandCtrl);
      this.mainlabel.appendChild(table);
      new InputFieldManager(this.input, 7, false, Number.NaN, Number.NaN, (sender, refreshInput) => {
        this.Text_TextChanged(sender, refreshInput);
      });
      this.input.addEventListener("focusin", () => {
        this.control_GotFocus(this);
      });
      this.input.addEventListener("focusout", () => {
        this.control_LostFocus(this);
      });
      this.checkForReadOnly();
    }
  }
  expand() {
    if (this.colorEditor == null) {
      this.subElementPanel.style.marginLeft = "20px";
      this.colorEditor = new colorEditor(this.subElementPanel, UIElement.defaultFontSize, this.currentColor, (c) => {
        this.coloredited(c);
      });
    }
    this._rootNode.tabReOrder(0);
    this._expanded = true;
    this.subElementPanel.style.display = "";
    this.expandCtrl.innerHTML = this.colapseIcon;
  }
  colapse() {
    this.subElementPanel.style.display = "none";
    this.expandCtrl.innerHTML = this.expandIcon;
  }
  coloredited(newColor) {
    this.currentColor = newColor.clone();
    this.colorPreview.color = this.currentColor;
    this.input.value = this.currentColor.toString();
    Reflect.set(this._dataContainer, this._prop.name, this.currentColor);
    if (this._valueChangeCallback != null)
      this._valueChangeCallback(this);
    if (this._changeCausesParentRefresh)
      this.parentNode.refresh();
  }
  refresh() {
    if (this.input == null)
      return;
    if (this._getValueCallback == null)
      return;
    let c = this._getValueCallback(this);
    if (c != null) {
      if (this.colorPreview != null)
        this.colorPreview.color = c;
      if (this.input != null) {
        let s = c.toString();
        if (s != this.input.value)
          this.input.value = s;
      }
    }
    this.checkForReadOnly();
  }
  Text_TextChanged(sender, refreshInput) {
    if (this.input != null) {
      this._value = this.input.value;
      let c = YColor.FromString(this._value);
      if (c != null) {
        this.colorPreview.color = c;
        this.currentColor = c;
        if (this.colorEditor != null)
          this.colorEditor.color = c;
        Reflect.set(this._dataContainer, this._prop.name, c);
        if (refreshInput)
          this.input.value = c.toString();
        if (this._valueChangeCallback != null)
          this._valueChangeCallback(this);
        if (this._changeCausesParentRefresh)
          this.parentNode.refresh();
      }
    }
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value;
    this.input.value = value;
  }
  resize(top2, left1, left2, width) {
    let h = this.input.offsetHeight;
    this.mainlabel.style.height = h.toString() + "px";
    return 0;
  }
};
var UIElementMarkerPos = class extends UIElementGeneric {
  constructor(p, dataContainer, prop) {
    super(p, dataContainer, prop);
    this._cachedValue = null;
    this._value = "";
    this.preExpandIfNeeded();
  }
  static expandIconSVG(size) {
    return ressources.targetIcon(size.toString(), false, false, false, false, "Click to place marker on graph");
  }
  get expandIcon() {
    return UIElementMarkerPos.expandIconSVG(UIElement.defaultFontSize);
  }
  get colapseIcon() {
    return UIElementMarkerPos.expandIconSVG(UIElement.defaultFontSize);
  }
  AllocateControls() {
    this._expandable = true;
    this._expandButtonSide = 1;
    super.AllocateControls();
    if (this.input == null) {
      let table = document.createElement("TABLE");
      table.style.position = "absolute";
      table.style.top = "0px";
      table.style.right = "3px";
      table.style.width = "50%";
      table.style.borderCollapse = "collapse";
      let tr = document.createElement("TR");
      table.appendChild(tr);
      let td2 = document.createElement("TD");
      td2.style.width = "100%";
      tr.appendChild(td2);
      this.input = document.createElement("INPUT");
      this.input.type = "input";
      this._cachedValue = Reflect.get(this._dataContainer, this._prop.name);
      this.input.value = this._cachedValue.toString();
      this.input.style.marginTop = "0px";
      this.input.style.marginBottom = "0px";
      this.input.style.textAlign = "right";
      this.input.style.width = "100%";
      this.input.style.border = "1px solid grey";
      this.input.style.borderRadius = "1px";
      this.input.style.fontFamily = UIElement.defaultFontFamily;
      this.input.style.fontSize = UIElement.defaultFontSize.toString() + "px";
      this.input.addEventListener("keyup", () => {
        this.Text_TextChanged(null, true);
      });
      this.input.addEventListener("change", () => {
        this.Text_TextChanged(null, false);
      });
      td2.appendChild(this.input);
      let td3 = document.createElement("TD");
      td3.style.paddingLeft = "5px";
      tr.appendChild(td3);
      td3.appendChild(this.expandCtrl);
      this.mainlabel.appendChild(table);
      this.input.addEventListener("focusin", () => {
        this.control_GotFocus(this);
      });
      this.input.addEventListener("focusout", () => {
        this.control_LostFocus(this);
      });
      this.checkForReadOnly();
    }
  }
  expand() {
    let value = Reflect.get(this._dataContainer, this._prop.name);
    this.expanded = false;
    value.capture = true;
    Reflect.set(this._dataContainer, this._prop.name, value);
    if (this._valueChangeCallback != null)
      this._valueChangeCallback(this);
  }
  colapse() {
  }
  refresh() {
    if (this.input == null)
      return;
    if (this._getValueCallback == null)
      return;
    this._cachedValue = this._getValueCallback(this);
    if (this.input != null) {
      this.input.value = this._cachedValue.toString();
    }
    this.checkForReadOnly();
  }
  Text_TextChanged(sender, refreshInput) {
    let parsedValue = this._cachedValue.TryParse(this.input.value);
    if (parsedValue.success) {
      this._cachedValue.value = parsedValue.result;
      Reflect.set(this._dataContainer, this._prop.name, this._cachedValue);
      if (this._valueChangeCallback != null)
        this._valueChangeCallback(this);
      if (this._changeCausesParentRefresh)
        this.parentNode.refresh();
    }
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value;
    this.input.value = value;
  }
  resize(top2, left1, left2, width) {
    let h = this.input.offsetHeight;
    this.mainlabel.style.height = h.toString() + "px";
    return 0;
  }
};
var InputFieldManager = class {
  static nullCallback(sender) {
  }
  constructor(input, type, allowEmpty, min, max, callback) {
    this._allowEmpty = false;
    this._min = Number.NaN;
    this._max = Number.NaN;
    this._callback = null;
    this._input = input;
    this._type = type;
    this._allowEmpty = allowEmpty;
    this._min = min;
    this._max = max;
    this._callback = callback;
    this.checkData();
    this._input.addEventListener("keyup", () => {
      this.InputChange(this._input, true);
    });
    this._input.addEventListener("change", () => {
      this.InputChange(this._input, false);
    });
  }
  showError(msg) {
    this._input.title = msg;
  }
  clearError() {
    this._input.title = "";
  }
  backGroundColorFeedback(ErrorMsg, state) {
    if (state)
      this.clearError();
    else
      this.showError(ErrorMsg);
    let c = this._input.style.backgroundColor;
    if (state && c != "white")
      this._input.style.backgroundColor = "white";
    if (!state && c != "pink")
      this._input.style.backgroundColor = "pink";
    return state;
  }
  checkData() {
    let intValue = 0;
    let doubleValue = 0;
    if (this._input.disabled)
      return true;
    let strValue = this._input.value;
    if (strValue == "")
      return this.backGroundColorFeedback("This field can't be empty", this._allowEmpty);
    switch (this._type) {
      case 0:
        break;
      case 1:
        intValue = parseInt(strValue);
        doubleValue = parseFloat(strValue);
        if (Number.isNaN(intValue) || intValue != doubleValue)
          return this.backGroundColorFeedback("Integer value expected", false);
        if (!Number.isNaN(this._min) && intValue < this._min)
          return this.backGroundColorFeedback("Integer value greater or equal to " + this._min.toString() + " expected", false);
        if (!Number.isNaN(this._max) && intValue > this._max)
          return this.backGroundColorFeedback("Integer value lower or equal to  " + this._min.toString() + " expected", false);
        break;
      case 2:
        intValue = parseInt(strValue);
        doubleValue = parseFloat(strValue);
        if (Number.isNaN(intValue) || intValue != doubleValue)
          return this.backGroundColorFeedback("Positive integer  expected", false);
        if (intValue < 0)
          return this.backGroundColorFeedback("Positive integer value  expected", false);
        if (!Number.isNaN(this._min) && intValue < this._min)
          return this.backGroundColorFeedback("Positive integer value greater or equal to " + this._min.toString() + " expected", false);
        if (!Number.isNaN(this._max) && intValue > this._max)
          return this.backGroundColorFeedback("Positive integer value lower or equal to  " + this._min.toString() + " expected", false);
        break;
      case 3:
        intValue = parseInt(strValue);
        doubleValue = parseFloat(strValue);
        if (Number.isNaN(intValue) || intValue != doubleValue)
          return this.backGroundColorFeedback("Strictly positive Integer value expected", false);
        if (intValue <= 0)
          return this.backGroundColorFeedback("Strictly positive integer value  expected", false);
        if (!Number.isNaN(this._min) && intValue < this._min)
          return this.backGroundColorFeedback("Positive integer value greater or equal to " + this._min.toString() + " expected", false);
        if (!Number.isNaN(this._max) && intValue > this._max)
          return this.backGroundColorFeedback("Positive integer value lower or equal to  " + this._min.toString() + " expected", false);
        break;
      case 4:
        doubleValue = parseFloat(strValue);
        if (Number.isNaN(intValue))
          return this.backGroundColorFeedback("Floating point value expected", false);
        if (!Number.isNaN(this._min) && doubleValue < this._min)
          return this.backGroundColorFeedback("Floating point value greater or equal to " + this._min.toString() + " expected", false);
        if (!Number.isNaN(this._max) && doubleValue > this._max)
          return this.backGroundColorFeedback("Floating point value lower or equal to  " + this._min.toString() + " expected", false);
        break;
      case 5:
        doubleValue = parseFloat(strValue);
        if (Number.isNaN(doubleValue))
          return this.backGroundColorFeedback("Positive floating point value expected", false);
        if (doubleValue < 0)
          return this.backGroundColorFeedback("Positive floating point value expected", false);
        if (!Number.isNaN(this._min) && doubleValue < this._min)
          return this.backGroundColorFeedback("Floating point value greater or equal to " + this._min.toString() + " expected", false);
        if (!Number.isNaN(this._max) && doubleValue > this._max)
          return this.backGroundColorFeedback("Floating point value lower or equal to  " + this._min.toString() + " expected", false);
        break;
      case 6:
        doubleValue = parseFloat(strValue);
        if (Number.isNaN(doubleValue))
          return this.backGroundColorFeedback("Strictly positive floating point value expected", false);
        if (doubleValue <= 0)
          return this.backGroundColorFeedback("Strictly positive floating point value expected", false);
        if (!Number.isNaN(this._min) && doubleValue < this._min)
          return this.backGroundColorFeedback("Floating point value greater or equal to " + this._min.toString() + " expected", false);
        if (!Number.isNaN(this._max) && doubleValue > this._max)
          return this.backGroundColorFeedback("Floating point value greater or equal to " + this._min.toString() + " expected", false);
        break;
      case 7:
        if (YColor.FromString(strValue) == null)
          return this.backGroundColorFeedback("Value color name/definition expected", false);
        break;
    }
    return this.backGroundColorFeedback("", true);
  }
  InputChange(sender, refreshInput) {
    if (this.checkData()) {
      try {
        if (this._callback != null)
          this._callback(sender, refreshInput);
      } catch (ex) {
        this.backGroundColorFeedback(ex.message, false);
      }
    }
  }
};

// obj/full/colorEditor_rw.js
var ColorEditorTab = class {
  constructor(editor, label, fontSize) {
    this._realTab = false;
    this._div = null;
    this._tabLabel = null;
    this._td = document.createElement("TD");
    this._editor = editor;
    if (label != "") {
      this._div = document.createElement("DIV");
      this._div.style.display = "none";
      this._td.style.paddingTop = "4px";
      this._td.style.fontSize = fontSize.toString() + "px";
      this._td.style.paddingBottom = "2px";
      this._td.style.borderLeft = "1px solid " + this._editor.inactiveBorderColor;
      this._td.style.borderRight = "1px solid " + this._editor.inactiveBorderColor;
      this._td.style.borderTop = "1px solid " + this._editor.inactiveBorderColor;
      this._td.style.borderBottom = "1px solid " + this._editor.activeBorderColor;
      this._td.style.color = this._editor.inactiveColor;
      this._td.style.backgroundColor = this._editor.inactiveBackgroundColor;
      this._td.style.borderTopLeftRadius = "3px";
      this._td.style.borderTopRightRadius = "3px";
      this._td.style.paddingLeft = "5px";
      this._td.style.paddingRight = "5px";
      this._realTab = true;
      this._tabLabel = document.createElement("ANCHOR");
      this._tabLabel.innerText = label;
      this._tabLabel.addEventListener("click", () => {
        this._editor.tabSelected(this);
      });
      this._tabLabel.addEventListener("keyup", (e) => {
        if (e.key === "Enter" || e.key === " ")
          this._editor.tabSelected(this);
      });
      this._tabLabel.style.cursor = "pointer";
      this._td.appendChild(this._tabLabel);
    } else {
      this._td.style.borderBottom = "1px solid " + this._editor.activeBorderColor;
      this._td.innerHTML = "<span>&nbsp;</span>";
    }
  }
  setTabIndex(index) {
    this._tabLabel.tabIndex = index++;
    return index;
  }
  set active(value) {
    if (!this._realTab)
      return;
    this._td.style.borderLeftColor = value ? this._editor.activeBorderColor : this._editor.inactiveBorderColor;
    this._td.style.borderTopColor = value ? this._editor.activeBorderColor : this._editor.inactiveBorderColor;
    this._td.style.borderRightColor = value ? this._editor.activeBorderColor : this._editor.inactiveBorderColor;
    this._td.style.borderBottomColor = value ? "rgba(0, 0, 0, 0)" : this._editor.activeBorderColor;
    this._td.style.color = value ? this._editor.activeColor : this._editor.inactiveColor;
    this._td.style.backgroundColor = value ? this._editor.activeBackgroundColor : this._editor.inactiveBackgroundColor;
    this._div.style.display = value ? "" : "none";
  }
  get active() {
    return this._div.style.display == "";
  }
  get tabElement() {
    return this._td;
  }
  get divElement() {
    return this._div;
  }
};
var ColorEditorSroll = class {
  setTabIndex(index) {
    this._anchor.tabIndex = index++;
    this._input.tabIndex = index++;
    return index;
  }
  constructor(div, anchor, input, colorCallback, changeCallBack, checkerBoardBg, value) {
    this._value = 0;
    this._colorCallback = colorCallback;
    this._changeCallBack = changeCallBack;
    this._value = value;
    this._div = div;
    let s = ColorEditorSroll.scrollHeight;
    if (checkerBoardBg)
      this._div.style.background = "url('data:image/svg+xml;utf8," + ColorSampler.checkerboardImage(s, s) + "')";
    this._anchor = anchor;
    this._input = input;
    this._input.size = 3;
    this._input.maxLength = 3;
    this._input.type = "number";
    this._input.min = "0";
    this._input.max = "255";
    this._input.style.fontSize = (12 * constants.guiDPIFactor).toString() + "px";
    this._input.style.textAlign = "right";
    this._input.value = this._value.toString();
    this._input.style.marginLeft = "10px";
    this._div.style.width = "100%";
    this._div.style.position = "relative";
    this._div.style.height = ColorEditorSroll.scrollHeight.toString() + "px";
    this._div.style.border = "1px solid black";
    this._canvasBg = document.createElement("CANVAS");
    this._div.appendChild(this._canvasBg);
    this._canvasBg.style.left = "0px";
    this._canvasBg.style.top = "0px";
    this._canvasBg.style.width = "100%";
    this._canvasBg.style.height = "100%";
    this._canvasBg.width = 256;
    this._canvasBg.height = ColorEditorSroll.scrollHeight;
    this._canvasCursor = document.createElement("CANVAS");
    this._div.appendChild(this._canvasCursor);
    this._canvasCursor.style.position = "absolute";
    this._canvasCursor.style.width = "100%";
    this._canvasCursor.style.height = "100%";
    this._canvasCursor.style.left = "0px";
    this._canvasCursor.style.top = "0px";
    this._canvasCursor.style.display = "block";
    this._div.addEventListener("mousedown", (e) => {
      this.MouseDown(this._div, e);
    });
    this._div.addEventListener("mousemove", (e) => {
      this.MouseMove(this._div, e);
    });
    this._anchor.addEventListener("wheel", (e) => {
      this.mouseWheelEvent(this._div, e);
    });
    this._anchor.addEventListener("keydown", (e) => {
      this.KeyDown(this._div, e);
    });
    this._input.addEventListener("keyup", (e) => {
      this.inputKeyUp();
    });
    this._input.addEventListener("change", (e) => {
      this.inputKeyUp();
    });
    this._anchor.tabIndex = 4;
  }
  get value() {
    return this._value;
  }
  set value(v) {
    if (v < 0)
      v = 0;
    if (v > 255)
      v = 255;
    this._value = v;
    this._input.value = this._value.toString();
  }
  inputKeyUp() {
    let value = parseInt(this._input.value);
    if (isNaN(value))
      return;
    if (value < 0)
      value = 0;
    if (value > 255)
      value = 255;
    this._value = value;
    this.refresh();
    this._changeCallBack(this);
  }
  TouchStart(div, e) {
    if (e.touches.length == 1)
      this.handleMouseStartCapture(div, e.touches[0].clientX, e.touches[0].clientY);
  }
  TouchCaptureRun(div, e) {
    if (e.touches.length == 1)
      this.handleMouseRun(div, e.touches[0].clientX, e.touches[0].clientY);
  }
  TouchCaptureEnd(div, e) {
  }
  MouseDown(sender, e) {
    if (e.buttons != 1)
      return;
    this.handleMouseStartCapture(sender, e.clientX, e.clientY);
  }
  handleMouseStartCapture(sender, x, y) {
    let SenderRect = sender.getBoundingClientRect();
    let eX = Math.round(x - SenderRect.left);
    let index = Math.round(256 * eX / this._div.offsetWidth) >> 0;
    if (index < 0)
      index = 0;
    if (index > 255)
      index = 255;
    this._value = index;
    this._input.value = index.toString();
    this.refresh();
    this._changeCallBack(this);
  }
  MouseMove(sender, e) {
    if (e.buttons != 1)
      return;
    this.handleMouseRun(sender, e.clientX, e.clientY);
  }
  handleMouseRun(sender, x, y) {
    let SenderRect = sender.getBoundingClientRect();
    let eX = Math.round(x - SenderRect.left);
    let index = Math.round(256 * eX / this._div.offsetWidth) >> 0;
    if (index < 0)
      index = 0;
    if (index > 255)
      index = 255;
    this._value = index;
    this._input.value = index.toString();
    this.refresh();
    this._changeCallBack(this);
  }
  mouseWheelEvent(sender, e) {
    this._value += e.deltaY > 0 ? -1 : 1;
    if (this._value < 0) {
      this._value = 0;
    } else if (this._value > 255) {
      this._value = 255;
    } else {
      e.preventDefault();
    }
    this._input.value = this._value.toString();
    this.refresh();
    this._changeCallBack(this);
  }
  KeyDown(sender, e) {
    if (e.code == "ArrowRight") {
      this._value++;
      if (this._value > 255)
        this._value = 255;
    }
    if (e.code == "ArrowLeft") {
      this._value--;
      if (this._value < 0)
        this._value = 0;
    }
    this._input.value = this._value.toString();
    this.refresh();
    this._changeCallBack(this);
  }
  refresh() {
    let color = this._colorCallback(this);
    let ctx = this._canvasBg.getContext("2d");
    ctx.clearRect(0, 0, this._canvasBg.width, this._canvasBg.height);
    for (let i = 0; i < 256; i++) {
      ctx.beginPath();
      ctx.moveTo(i + 0.5, 0);
      ctx.lineTo(i + 0.5, ColorEditorSroll.scrollHeight);
      ctx.strokeStyle = color[i];
      ctx.stroke();
    }
    this._canvasCursor.width = this._div.offsetWidth;
    this._canvasCursor.height = this._div.offsetHeight;
    ctx = this._canvasCursor.getContext("2d");
    let x = 0.5 + this._value / 255 * this._canvasCursor.width;
    ctx.beginPath();
    let y = 0.5;
    ctx.moveTo(x, y + 5);
    ctx.lineTo(x + 3, y);
    ctx.lineTo(x - 3, y);
    ctx.fillStyle = "black";
    ctx.strokeStyle = "white";
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
    y = this._canvasCursor.height - 0.5;
    ctx.beginPath();
    ctx.moveTo(x, y - 5);
    ctx.lineTo(x + 3, y);
    ctx.lineTo(x - 3, y);
    ctx.fillStyle = "black";
    ctx.strokeStyle = "white";
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
  }
};
ColorEditorSroll.scrollHeight = 26 * constants.guiDPIFactor;
var ColorSampler = class {
  setTabIndex(index) {
    this._colorDiv.tabIndex = index++;
    return index;
  }
  static checkerboardImage(width, height) {
    let halfWidth = width >> 1;
    let halfHeight = height >> 1;
    return '<svg xmlns="http://www.w3.org/2000/svg"   viewbox="0 0 ' + width + " " + height + '" width="' + width + 'px"  height="' + height + 'px" ><rect x="0" y="0" width="' + width + '" height="' + height + '" style="fill:white"/><rect x="0" y="0" width="' + halfWidth + '" height="' + halfHeight + '" style="fill:black"/><rect x="' + halfWidth + '" y="' + halfHeight + '" width="' + halfWidth + '" height="' + halfHeight + '" style="fill:black"/></svg>';
  }
  constructor(containerDiv, selectCallback) {
    this._containerDiv = containerDiv;
    this._selectCallback = selectCallback;
    this._containerDiv.style.border = "1px solid grey";
    this._containerDiv.style.background = "url('data:image/svg+xml;utf8," + ColorSampler.checkerboardImage(100, 100) + "')";
    this._containerDiv.style.backgroundSize = "cover";
    this._containerDiv.style.backgroundPosition = "center";
    this._containerDiv.style.backgroundRepeat = "no-repeat";
    this._color = YColor.Transparent;
    this._colorDiv = document.createElement("DIV");
    this._colorDiv.style.display = "display-block";
    this._colorDiv.style.position = "relative";
    this._colorDiv.style.width = "100%";
    this._colorDiv.style.height = "100%";
    this._colorDiv.style.backgroundColor = "rgba(0,0,0,0)";
    this._containerDiv.appendChild(this._colorDiv);
    if (this._selectCallback != null) {
      this._colorDiv.addEventListener("click", () => {
        this._selectCallback(this.color);
      });
      this._colorDiv.addEventListener("keyup", (e) => {
        if (e.key === "Enter" || e.key === " ")
          this._selectCallback(this.color);
      });
      this._colorDiv.style.cursor = "pointer";
    }
  }
  set color(value) {
    this._color = value.clone();
    this._colorDiv.style.backgroundColor = this._color.htmlCode;
  }
  get color() {
    return this._color.clone();
  }
};
var colorEditor = class {
  static AddColorToHistory(c) {
    for (let i = 0; i < colorEditor._colorHistory.length; i++) {
      if (c.equal(colorEditor._colorHistory[i]))
        return;
    }
    colorEditor._colorHistory.splice(colorEditor._colorHistory.length - 1, 1);
    colorEditor._colorHistory.splice(0, 0, c);
    for (let i = colorEditor._editorsList.length - 1; i >= 0; i--) {
      colorEditor._editorsList[i].refreshColorHistory();
    }
  }
  static get colorHistory() {
    return colorEditor._colorHistory;
  }
  get activeBorderColor() {
    return "#767676";
  }
  get inactiveBorderColor() {
    return "#b0b0b0";
  }
  get activeColor() {
    return "black";
  }
  get inactiveColor() {
    return "grey";
  }
  get activeBackgroundColor() {
    return "white";
  }
  get inactiveBackgroundColor() {
    return "#f8f8f8";
  }
  tabSelected(source) {
    if (source == this._tabRGB) {
      this._tabRGB.active = true;
      this._rgb_R_editor.refresh();
      this._rgb_G_editor.refresh();
      this._rgb_B_editor.refresh();
      this._rgb_T_editor.refresh();
    } else {
      this._tabRGB.active = false;
    }
    if (source == this._tabHSL) {
      this._tabHSL.active = true;
      this._hsl_H_editor.refresh();
      this._hsl_S_editor.refresh();
      this._hsl_L_editor.refresh();
      this._hsl_T_editor.refresh();
    } else {
      this._tabHSL.active = false;
    }
    this._tabPredef.active = source == this._tabPredef;
  }
  HueScrollBg() {
    let s = 100;
    let l = 50;
    let t = this._hsl_T_editor.value / 255;
    let res = new Array(256);
    for (let i = 0; i < 256; i++) {
      res[i] = "hsl(" + (360 * i / 256).toString() + "," + s.toString() + "%," + l.toString() + "%)";
    }
    return res;
  }
  SaturationScrollBg() {
    let h = 360 * this._hsl_H_editor.value / 256;
    let l = 100 * this._hsl_L_editor.value / 255;
    let t = this._hsl_T_editor.value / 255;
    let res = new Array(256);
    for (let i = 0; i < 256; i++) {
      res[i] = "hsl(" + h.toString() + "," + (100 * i / 255).toString() + "%," + l.toString() + "%)";
    }
    return res;
  }
  LuminosityScrollBg() {
    let h = 360 * this._hsl_H_editor.value / 256;
    let s = 100 * this._hsl_S_editor.value / 255;
    let t = this._hsl_T_editor.value / 255;
    let res = new Array(256);
    for (let i = 0; i < 256; i++) {
      res[i] = "hsl(" + h.toString() + "," + s.toString() + "%," + (100 * i / 255).toString() + "%)";
    }
    return res;
  }
  HSLTranspScrollBg() {
    let h = 360 * this._hsl_H_editor.value / 256;
    let s = 100 * this._hsl_S_editor.value / 255;
    let l = 100 * this._hsl_L_editor.value / 255;
    let res = new Array(256);
    for (let i = 0; i < 256; i++) {
      res[i] = "hsla(" + h.toString() + "," + l.toString() + "%," + s.toString() + "%," + (i / 255).toString() + ")";
    }
    return res;
  }
  RedScrollBg() {
    let g = this._rgb_G_editor.value;
    let b = this._rgb_B_editor.value;
    let t = this._rgb_T_editor.value / 255;
    let res = new Array(256);
    for (let i = 0; i < 256; i++) {
      res[i] = "rgb(" + i.toString() + "," + g.toString() + "," + b.toString() + ")";
    }
    return res;
  }
  GreenScrollBg() {
    let r = this._rgb_R_editor.value;
    let b = this._rgb_B_editor.value;
    let t = this._rgb_T_editor.value / 255;
    let res = new Array(256);
    for (let i = 0; i < 256; i++) {
      res[i] = "rgb(" + r.toString() + "," + i.toString() + "," + b.toString() + ")";
    }
    return res;
  }
  BlueScrollBg() {
    let r = this._rgb_R_editor.value;
    let g = this._rgb_G_editor.value;
    let t = this._rgb_T_editor.value / 255;
    let res = new Array(256);
    for (let i = 0; i < 256; i++) {
      res[i] = "rgb(" + r.toString() + "," + g.toString() + "," + i.toString() + ")";
    }
    return res;
  }
  RGBTranspScrollBg() {
    let r = this._rgb_R_editor.value;
    let g = this._rgb_G_editor.value;
    let b = this._rgb_B_editor.value;
    let res = new Array(256);
    for (let i = 0; i < 256; i++) {
      res[i] = "rgba(" + r.toString() + "," + g.toString() + "," + b.toString() + "," + (i / 255).toString() + ")";
    }
    return res;
  }
  static defaultColorHistory() {
    let defaultHistory = [];
    defaultHistory.push(YColor.FromAhsl(100, 0, 0, 0));
    defaultHistory.push(YColor.FromAhsl(100, 0, 0, 51));
    defaultHistory.push(YColor.FromAhsl(100, 0, 0, 102));
    defaultHistory.push(YColor.FromAhsl(100, 0, 0, 153));
    defaultHistory.push(YColor.FromAhsl(100, 0, 0, 204));
    defaultHistory.push(YColor.FromAhsl(100, 0, 0, 255));
    defaultHistory.push(YColor.FromAhsl(100, 0, 255, 127));
    defaultHistory.push(YColor.FromAhsl(100, 42, 255, 127));
    defaultHistory.push(YColor.FromAhsl(100, 85, 255, 127));
    defaultHistory.push(YColor.FromAhsl(100, 96, 255, 127));
    defaultHistory.push(YColor.FromAhsl(100, 127, 255, 127));
    defaultHistory.push(YColor.FromAhsl(100, 170, 255, 127));
    defaultHistory.push(YColor.FromAhsl(100, 192, 255, 127));
    defaultHistory.push(YColor.FromAhsl(100, 212, 255, 127));
    defaultHistory.push(YColor.FromAhsl(255, 226, 217, 214));
    return defaultHistory;
  }
  destroy() {
    for (let i = colorEditor._editorsList.length - 1; i >= 0; i--) {
      if (colorEditor._editorsList[i] == this) {
        colorEditor._editorsList.splice(i, 1);
      }
    }
  }
  refreshColorHistory() {
    for (let i = 0; i < this._samples.length; i++) {
      if (i < colorEditor._colorHistory.length) {
        this._samples[i].color = colorEditor._colorHistory[i].clone();
      }
    }
  }
  constructor(container, fontSize, initialColor, colorChangeCallback) {
    this._firstTabIndex = 0;
    this._memorizeTimer = null;
    colorEditor._editorsList.push(this);
    this._colorChangeCallback = colorChangeCallback;
    this._container = container;
    this._table = document.createElement("TABLE");
    this._table.style.width = "100%";
    this._table.style.borderSpacing = "0";
    this._table.style.paddingLeft = "5px";
    this._table.style.paddingTop = "5px";
    this._table.style.paddingRight = "5px";
    this._table.style.borderCollapse = "separate";
    this._tr1 = document.createElement("TR");
    this._tr2 = document.createElement("TR");
    this._tabRGB = new ColorEditorTab(this, "RGB", fontSize);
    this._tabHSL = new ColorEditorTab(this, "HSL", fontSize);
    this._tabPredef = new ColorEditorTab(this, "Predefined", fontSize);
    this._tabStub = new ColorEditorTab(this, "", fontSize);
    this._contents = document.createElement("TD");
    this._contents.colSpan = 4;
    this._contents.style.borderLeft = "1px solid " + this.activeBorderColor;
    this._contents.style.borderRight = "1px solid " + this.activeBorderColor;
    this._contents.style.borderBottom = "1px solid " + this.activeBorderColor;
    this._contents.style.backgroundColor = this.activeBackgroundColor;
    this._tr1.appendChild(this._tabRGB.tabElement);
    this._tr1.appendChild(this._tabHSL.tabElement);
    this._tr1.appendChild(this._tabPredef.tabElement);
    this._tr1.appendChild(this._tabStub.tabElement);
    this._tr2.appendChild(this._contents);
    this._table.appendChild(this._tr1);
    this._table.appendChild(this._tr2);
    this._contents.appendChild(this._tabRGB.divElement);
    this._contents.appendChild(this._tabHSL.divElement);
    this._contents.appendChild(this._tabPredef.divElement);
    let RGBtable = document.createElement("TABLE");
    RGBtable.style.width = "100%";
    RGBtable.style.borderSpacing = "1";
    this._tabRGB.divElement.appendChild(RGBtable);
    let HSLtable = document.createElement("TABLE");
    HSLtable.style.width = "100%";
    HSLtable.style.borderSpacing = "1";
    this._tabHSL.divElement.appendChild(HSLtable);
    let predefTable = document.createElement("TABLE");
    this._tabPredef.divElement.appendChild(predefTable);
    predefTable.style.width = "100%";
    predefTable.style.borderSpacing = "1";
    predefTable.style.tableLayout = "fixed";
    this._container.appendChild(this._table);
    this._rgb_R_editor = this.AddColorScroll(RGBtable, "R", () => {
      return this.RedScrollBg();
    }, (src) => {
      this.RgbColorChangeCallBack(src);
    }, false, 1);
    this._rgb_G_editor = this.AddColorScroll(RGBtable, "G", () => {
      return this.GreenScrollBg();
    }, (src) => {
      this.RgbColorChangeCallBack(src);
    }, false, 2);
    this._rgb_B_editor = this.AddColorScroll(RGBtable, "B", () => {
      return this.BlueScrollBg();
    }, (src) => {
      this.RgbColorChangeCallBack(src);
    }, false, 3);
    this._rgb_T_editor = this.AddColorScroll(RGBtable, "T", () => {
      return this.RGBTranspScrollBg();
    }, (src) => {
      this.RgbColorChangeCallBack(src);
    }, true, 3);
    this._rgb_R_editor.value = initialColor.red;
    this._rgb_G_editor.value = initialColor.green;
    this._rgb_B_editor.value = initialColor.blue;
    this._rgb_T_editor.value = initialColor.alpha;
    this._rgb_R_editor.refresh();
    this._rgb_G_editor.refresh();
    this._rgb_B_editor.refresh();
    this._rgb_T_editor.refresh();
    this._hsl_H_editor = this.AddColorScroll(HSLtable, "H", () => {
      return this.HueScrollBg();
    }, (src) => {
      this.HslColorChangeCallBack(src);
    }, false, 1);
    this._hsl_S_editor = this.AddColorScroll(HSLtable, "S", () => {
      return this.SaturationScrollBg();
    }, (src) => {
      this.HslColorChangeCallBack(src);
    }, false, 2);
    this._hsl_L_editor = this.AddColorScroll(HSLtable, "L", () => {
      return this.LuminosityScrollBg();
    }, (src) => {
      this.HslColorChangeCallBack(src);
    }, false, 3);
    this._hsl_T_editor = this.AddColorScroll(HSLtable, "T", () => {
      return this.HSLTranspScrollBg();
    }, (src) => {
      this.HslColorChangeCallBack(src);
    }, true, 3);
    this._hsl_H_editor.value = initialColor.hue;
    this._hsl_S_editor.value = initialColor.saturation;
    this._hsl_L_editor.value = initialColor.luminosity;
    this._hsl_T_editor.value = initialColor.alpha;
    this._hsl_H_editor.refresh();
    this._hsl_S_editor.refresh();
    this._hsl_L_editor.refresh();
    this._hsl_T_editor.refresh();
    let samplesTable = document.createElement("TABLE");
    samplesTable.style.position = "relative";
    samplesTable.style.width = "100%";
    samplesTable.style.paddingLeft = "3px";
    samplesTable.style.paddingRight = "3px";
    samplesTable.style.paddingTop = "10px";
    samplesTable.style.bottom = "3px";
    samplesTable.style.tableLayout = "fixed";
    let samplesTD = [];
    let previewTD = null;
    let sampleHeight = 30;
    let sampletr1 = document.createElement("TR");
    sampletr1.style.height = sampleHeight.toString() + "px";
    for (let i = 0; i < 6; i++) {
      let td = document.createElement("TD");
      if (i == 5) {
        td.colSpan = 2;
        td.rowSpan = 3;
        previewTD = td;
      } else {
        samplesTD.push(td);
      }
      sampletr1.appendChild(td);
    }
    samplesTable.appendChild(sampletr1);
    let sampletr2 = document.createElement("TR");
    sampletr2.style.height = sampleHeight.toString() + "px";
    for (let i = 0; i < 5; i++) {
      let td = document.createElement("TD");
      samplesTD.push(td);
      sampletr2.appendChild(td);
    }
    samplesTable.appendChild(sampletr2);
    let sampletr3 = document.createElement("TR");
    sampletr3.style.height = sampleHeight.toString() + "px";
    for (let i = 0; i < 5; i++) {
      let td = document.createElement("TD");
      samplesTD.push(td);
      sampletr3.appendChild(td);
    }
    samplesTable.appendChild(sampletr3);
    this._container.appendChild(samplesTable);
    this._samples = [];
    for (let i = 0; i < samplesTD.length; i++) {
      let div2 = document.createElement("DIV");
      div2.style.position = "relative";
      div2.style.width = "100%";
      div2.style.height = (sampleHeight - 4).toString() + "px";
      div2.style.display = "inline-block";
      div2.title = "Color history";
      samplesTD[i].appendChild(div2);
      let sampler = new ColorSampler(div2, (c) => {
        this.sampleWasSelectedCallback(c);
      });
      sampler.color = colorEditor._colorHistory[i];
      this._samples.push(sampler);
    }
    let prefinedColors = YColor.predefinedColors;
    let colors = [];
    let predefinedColorNames = Object.keys(prefinedColors);
    for (let i = 0; i < predefinedColorNames.length; i++) {
      colors.push(prefinedColors[predefinedColorNames[i]]);
    }
    colors.sort((c1, c2) => {
      if (c1.alpha < c2.alpha)
        return 1;
      if (c1.alpha > c2.alpha)
        return -1;
      if (c1.luminosity < c2.luminosity)
        return 1;
      if (c1.luminosity > c2.luminosity)
        return -1;
      if (c1.saturation < c2.saturation)
        return 1;
      if (c1.saturation > c2.saturation)
        return -1;
      if (c1.hue < c2.hue)
        return 1;
      if (c1.hue > c2.hue)
        return -1;
      return 0;
    });
    let currenTR = null;
    this._prefedDivs = [];
    for (let i = 0; i < colors.length; i++) {
      let c = colors[i];
      if (i % 16 == 0) {
        currenTR = document.createElement("TR");
        predefTable.appendChild(currenTR);
      }
      let td = document.createElement("TD");
      currenTR.appendChild(td);
      let div2 = document.createElement("DIV");
      this._prefedDivs.push(div2);
      div2.style.position = "relative";
      div2.style.width = "100%";
      div2.style.height = Math.round(10 * constants.guiDPIFactor).toString() + "px";
      div2.style.display = "inline-block";
      div2.title = c.name;
      td.appendChild(div2);
      let sampler = new ColorSampler(div2, (c2) => {
        this.sampleWasSelectedCallback(c2);
      });
      sampler.color = c;
    }
    let div = document.createElement("DIV");
    div.style.position = "relative";
    div.style.width = "100%";
    div.style.height = (3 * sampleHeight).toString() + "px";
    div.style.display = "inline-block";
    div.title = "Color preview";
    previewTD.appendChild(div);
    this._preview = new ColorSampler(div, null);
    this._preview.color = initialColor;
    this.selectApropriateTab(initialColor);
  }
  selectApropriateTab(color) {
    if (color.isPredefined) {
      this._tabPredef.active = true;
      this.tabSelected(this._tabPredef);
    } else {
      this._tabPredef.active = false;
      if (color.isRGB) {
        this._tabRGB.active = true;
        this._tabHSL.active = false;
        this.tabSelected(this._tabRGB);
      } else {
        this._tabRGB.active = false;
        this._tabHSL.active = true;
        this.tabSelected(this._tabHSL);
      }
    }
  }
  sampleWasSelectedCallback(color) {
    this._rgb_R_editor.value = color.red;
    this._rgb_G_editor.value = color.green;
    this._rgb_B_editor.value = color.blue;
    this._rgb_T_editor.value = color.alpha;
    this._hsl_H_editor.value = color.hue;
    this._hsl_S_editor.value = color.saturation;
    this._hsl_L_editor.value = color.luminosity;
    this._hsl_T_editor.value = color.alpha;
    this._preview.color = color;
    this._rgb_R_editor.refresh();
    this._rgb_G_editor.refresh();
    this._rgb_B_editor.refresh();
    this._rgb_T_editor.refresh();
    this._hsl_H_editor.refresh();
    this._hsl_S_editor.refresh();
    this._hsl_L_editor.refresh();
    this._hsl_T_editor.refresh();
    this.initColorMemorization(color);
    if (this._colorChangeCallback != null)
      this._colorChangeCallback(color);
  }
  initColorMemorization(color) {
    if (this._memorizeTimer != null)
      clearTimeout(this._memorizeTimer);
    this._memorizeTimer = setTimeout(() => {
      this._memorizeTimer = null;
      colorEditor.AddColorToHistory(color);
    }, 2e3);
  }
  RgbColorChangeCallBack(src) {
    if (src != this._rgb_R_editor)
      this._rgb_R_editor.refresh();
    if (src != this._rgb_G_editor)
      this._rgb_G_editor.refresh();
    if (src != this._rgb_B_editor)
      this._rgb_B_editor.refresh();
    if (src != this._rgb_T_editor)
      this._rgb_T_editor.refresh();
    let color = YColor.FromArgb(this._rgb_T_editor.value, this._rgb_R_editor.value, this._rgb_G_editor.value, this._rgb_B_editor.value);
    this._preview.color = color;
    this.initColorMemorization(color);
    if (this._colorChangeCallback != null)
      this._colorChangeCallback(color);
  }
  HslColorChangeCallBack(src) {
    if (src != this._hsl_H_editor)
      this._hsl_H_editor.refresh();
    if (src != this._hsl_S_editor)
      this._hsl_S_editor.refresh();
    if (src != this._hsl_L_editor)
      this._hsl_L_editor.refresh();
    if (src != this._hsl_T_editor)
      this._hsl_T_editor.refresh();
    let color = YColor.FromAhsl(this._hsl_T_editor.value, this._hsl_H_editor.value, this._hsl_S_editor.value, this._hsl_L_editor.value);
    this._preview.color = color;
    this.initColorMemorization(color);
    if (this._colorChangeCallback != null)
      this._colorChangeCallback(color);
  }
  set color(color) {
    this._preview.color = color;
    this._hsl_H_editor.value = color.hue;
    this._hsl_S_editor.value = color.saturation;
    this._hsl_L_editor.value = color.luminosity;
    this._hsl_T_editor.value = color.alpha;
    this._rgb_R_editor.value = color.red;
    this._rgb_G_editor.value = color.green;
    this._rgb_B_editor.value = color.blue;
    this._rgb_T_editor.value = color.alpha;
    this._hsl_H_editor.refresh();
    this._hsl_S_editor.refresh();
    this._hsl_L_editor.refresh();
    this._hsl_T_editor.refresh();
    this._rgb_R_editor.refresh();
    this._rgb_G_editor.refresh();
    this._rgb_B_editor.refresh();
    this._rgb_T_editor.refresh();
    this.selectApropriateTab(color);
  }
  AddColorScroll(container, label, colorCallback, changeCallBack, checkerBoardBg, value) {
    let RGB_R_Row = document.createElement("TR");
    let RGB_R_Col1 = document.createElement("TD");
    RGB_R_Col1.innerHTML = "&nbsp;" + label + "&nbsp;";
    let RGB_R_Col2 = document.createElement("TD");
    let RGB_R_Anchor = document.createElement("ANCHOR");
    RGB_R_Col2.appendChild(RGB_R_Anchor);
    let RGB_R_Div = document.createElement("DIV");
    RGB_R_Col2.style.width = "100%";
    RGB_R_Anchor.appendChild(RGB_R_Div);
    let RGB_R_Col3 = document.createElement("TD");
    let RGB_R_Input = document.createElement("INPUT");
    RGB_R_Col3.appendChild(RGB_R_Input);
    RGB_R_Row.appendChild(RGB_R_Col1);
    RGB_R_Row.appendChild(RGB_R_Col2);
    RGB_R_Row.appendChild(RGB_R_Col3);
    container.appendChild(RGB_R_Row);
    return new ColorEditorSroll(RGB_R_Div, RGB_R_Anchor, RGB_R_Input, colorCallback, changeCallBack, checkerBoardBg, value);
  }
  setTabIndex(index) {
    this._firstTabIndex = index;
    index = this._tabRGB.setTabIndex(index);
    index = this._tabHSL.setTabIndex(index);
    index = this._tabPredef.setTabIndex(index);
    if (this._tabRGB.active) {
      index = this._rgb_R_editor.setTabIndex(index);
      index = this._rgb_G_editor.setTabIndex(index);
      index = this._rgb_B_editor.setTabIndex(index);
      index = this._rgb_T_editor.setTabIndex(index);
    } else if (this._tabHSL.active) {
      index = this._hsl_H_editor.setTabIndex(index);
      index = this._hsl_S_editor.setTabIndex(index);
      index = this._hsl_L_editor.setTabIndex(index);
      index = this._hsl_T_editor.setTabIndex(index);
    } else {
      for (let i = 0; i < this._prefedDivs.length; i++) {
        this._prefedDivs[i].tabIndex = index++;
      }
    }
    for (let i = 0; i < this._samples.length; i++) {
      index = this._samples[i].setTabIndex(index);
    }
    return index;
  }
};
colorEditor._colorHistory = colorEditor.defaultColorHistory();
colorEditor._editorsList = [];

// obj/full/configForm_rw.js
var configEditorTab = class {
  constructor(editor, label, fontSize, GUIcoef) {
    this._realTab = false;
    this._div = null;
    this._tabLabel = null;
    this._td = document.createElement("TD");
    if (label != "") {
      this._div = document.createElement("DIV");
      this._div.style.display = "none";
      let sz = Math.round(5 * GUIcoef).toString() + "px";
      this._div.style.padding = sz + " " + sz + " " + sz + " " + sz;
      this._td.style.paddingTop = Math.round(4 * GUIcoef).toString() + "px";
      this._td.style.fontSize = fontSize.toString() + "px";
      this._td.style.paddingBottom = Math.round(2 * GUIcoef).toString() + "px";
      this._td.tabIndex = 0;
      this._td.style.borderLeft = "1px solid " + configForm.inactiveBorderColor;
      this._td.style.borderRight = "1px solid " + configForm.inactiveBorderColor;
      this._td.style.borderTop = "1px solid " + configForm.inactiveBorderColor;
      this._td.style.borderBottom = "1px solid " + configForm.activeBorderColor;
      this._td.style.color = configForm.inactiveColor;
      this._td.style.backgroundColor = configForm.inactiveBackgroundColor;
      this._td.style.borderTopLeftRadius = Math.round(3 * GUIcoef).toString() + "px";
      this._td.style.borderTopRightRadius = Math.round(3 * GUIcoef).toString() + "px";
      this._td.style.paddingLeft = "5px";
      this._td.style.paddingRight = "5px";
      this._realTab = true;
      this._tabLabel = document.createElement("ANCHOR");
      this._tabLabel.innerText = label;
      this._tabLabel.addEventListener("click", () => {
        configForm.tabSelected(this);
      });
      this._tabLabel.addEventListener("keyup", (e) => {
        if (e.key === "Enter" || e.key === " ")
          configForm.tabSelected(this);
      });
      this._tabLabel.style.cursor = "pointer";
      this._td.appendChild(this._tabLabel);
    } else {
      this._td.style.borderBottom = "1px solid " + configForm.activeBorderColor;
      this._td.innerHTML = "<span>&nbsp;</span>";
    }
  }
  setTabIndex(index) {
    this._tabLabel.tabIndex = index++;
    return index;
  }
  set active(value) {
    if (!this._realTab)
      return;
    this._td.style.borderLeftColor = value ? configForm.activeBorderColor : configForm.inactiveBorderColor;
    this._td.style.borderTopColor = value ? configForm.activeBorderColor : configForm.inactiveBorderColor;
    this._td.style.borderRightColor = value ? configForm.activeBorderColor : configForm.inactiveBorderColor;
    this._td.style.borderBottomColor = value ? "rgba(0, 0, 0, 0)" : configForm.activeBorderColor;
    this._td.style.color = value ? configForm.activeColor : configForm.inactiveColor;
    this._td.style.backgroundColor = value ? configForm.activeBackgroundColor : configForm.inactiveBackgroundColor;
    this._div.style.display = value ? "" : "none";
  }
  get tabElement() {
    return this._td;
  }
  get divElement() {
    return this._div;
  }
};
var configForm = class {
  static get activeBorderColor() {
    return constants.WindowInnerBorderColor;
  }
  static get inactiveBorderColor() {
    return "#b0b0b0";
  }
  static get activeColor() {
    return "black";
  }
  static get inactiveColor() {
    return "grey";
  }
  static get activeBackgroundColor() {
    return constants.WindowInnerBackgroundColor;
  }
  static get inactiveBackgroundColor() {
    return constants.WindowBackgroundColor;
  }
  static hubStateChanged(source) {
    if (configForm._Hubtable == null)
      return;
    let srvNotification = source.removable ? "" : " (server)";
    for (let i = 1; i < configForm._Hubtable.childElementCount; i++) {
      if (configForm._Hubtable.childNodes[i]["YHUB"] == source) {
        configForm._Hubtable.childNodes[i].childNodes[2].innerText = source.ConnectionDescription + srvNotification;
        switch (source.ConnectionState) {
          case 2:
            configForm._Hubtable.childNodes[i].childNodes[0].innerHTML = ressources.OkIcon((1.2 * configForm.fontSize).toString(), true, false, false, false, " ");
            break;
          case 3:
            configForm._Hubtable.childNodes[i].childNodes[0].innerHTML = ressources.FailedIcon((1.2 * configForm.fontSize).toString(), true, false, false, false, " ");
            break;
          default:
            configForm._Hubtable.childNodes[i].childNodes[0].innerHTML = ressources.DontKnowIcon((1.2 * configForm.fontSize).toString(), true, false, false, false, " ");
            break;
        }
      }
    }
  }
  static RefreshUI(h) {
    for (let i = 1; i < configForm._Hubtable.childElementCount; i++) {
      if (configForm._Hubtable.childNodes[i]["YHUB"] == h) {
        configForm._Hubtable.childNodes[i].childNodes[1].innerText = h.toString();
        configForm._Hubtable.childNodes[i].childNodes[2].innerText = "...";
      }
    }
  }
  static HublineSelected(source) {
    configForm._selectedHub = null;
    for (let i = 1; i < configForm._Hubtable.childElementCount; i++) {
      if (configForm._Hubtable.childNodes[i] == source) {
        configForm._selectedHub = configForm._Hubtable.childNodes[i]["YHUB"];
        configForm._Hubtable.childNodes[i].style.backgroundColor = "#2fa5ff";
        configForm._Hubtable.childNodes[i].childNodes[0].style.color = "white";
        configForm._Hubtable.childNodes[i].childNodes[1].style.color = "white";
        configForm._Hubtable.childNodes[i].childNodes[2].style.color = "white";
      } else {
        configForm._Hubtable.childNodes[i].style.backgroundColor = "white";
        configForm._Hubtable.childNodes[i].childNodes[0].style.color = "black";
        configForm._Hubtable.childNodes[i].childNodes[1].style.color = "black";
        configForm._Hubtable.childNodes[i].childNodes[2].style.color = "black";
      }
    }
    configForm._editButton.enabled = configForm._selectedHub != null;
    configForm._deleteButton.enabled = configForm._selectedHub != null;
    this._editButton.showShortcut(configForm._selectedHub != null);
    this._deleteButton.showShortcut(configForm._selectedHub != null);
  }
  static newHub() {
    HubEdit.newHub(() => {
      configForm._window.show();
    });
  }
  static AddHubToUI(hub) {
    let HubtableTR = document.createElement("TR");
    HubtableTR.style.fontSize = configForm.fontSize.toString() + "px";
    HubtableTR["YHUB"] = hub;
    HubtableTR.style.backgroundColor = "white";
    HubtableTR.style.cursor = "pointer";
    HubtableTR.tabIndex = 0;
    HubtableTR.addEventListener("keypress", (e) => {
      switch (e.key.toUpperCase()) {
        case "D":
          this._deleteButton.performAction();
          break;
        case "E":
          this._editButton.performAction();
          break;
      }
    });
    HubtableTR.style.outline = "none";
    HubtableTR.addEventListener("click", () => {
      configForm.HublineSelected(HubtableTR);
    });
    HubtableTR.addEventListener("focusin", () => {
      configForm.HublineSelected(HubtableTR);
    });
    let HubtableTD = document.createElement("TD");
    switch (hub.ConnectionState) {
      case 2:
        HubtableTD.innerHTML = ressources.OkIcon((1.2 * configForm.fontSize).toString(), true, false, false, false, " ");
        break;
      case 3:
        HubtableTD.innerHTML = ressources.FailedIcon((1.2 * configForm.fontSize).toString(), true, false, false, false, " ");
        break;
      case 1:
      default:
        HubtableTD.innerHTML = ressources.DontKnowIcon((1.2 * configForm.fontSize).toString(), true, false, false, false, " ");
    }
    HubtableTD.style.width = (2 * configForm.fontSize).toString() + "px";
    HubtableTD.style.verticalAlign = "center";
    HubtableTD.style.borderBottom = "1px solid " + configForm.inactiveBorderColor;
    HubtableTD.style.paddingLeft = "5px";
    HubtableTR.appendChild(HubtableTD);
    HubtableTD = document.createElement("TD");
    HubtableTD.innerText = hub.toString();
    HubtableTD.style.borderBottom = "1px solid " + configForm.inactiveBorderColor;
    HubtableTD.style.verticalAlign = "center";
    HubtableTD.style.height = (2 * configForm.fontSize).toString() + "px";
    HubtableTR.appendChild(HubtableTD);
    HubtableTD = document.createElement("TD");
    HubtableTD.style.verticalAlign = "center";
    HubtableTD.innerText = hub.ConnectionDescription + (hub.removable ? "" : " (server)");
    HubtableTD.style.borderBottom = "1px solid " + configForm.inactiveBorderColor;
    HubtableTR.appendChild(HubtableTD);
    configForm._Hubtable.appendChild(HubtableTR);
  }
  static editSelectedHub() {
    if (configForm._selectedHub == null)
      return;
    HubEdit.editHub(configForm._selectedHub, () => {
      configForm._window.show();
    });
  }
  static deleteSelectedHub() {
    if (configForm._selectedHub == null)
      return;
    let ExtraMessage = configForm._selectedHub.removable ? "" : "\n\nThis one is also the one serving the Yocto-Visualization software. If you remove it, you won't be able to save later on.";
    confirm.ask("Do you really want to remove connection " + configForm._selectedHub.toString() + " ?" + ExtraMessage, () => {
      if (configForm._selectedHub == null)
        return;
      configForm._selectedHub.Disconnect().then((r) => {
      });
      for (let i = configForm._Hubtable.childElementCount - 1; i > 0; i--) {
        if (configForm._Hubtable.childNodes[i]["YHUB"] == configForm._selectedHub) {
          configForm._Hubtable.removeChild(configForm._Hubtable.childNodes[i]);
        }
      }
      sensorsManager.hubWasremoved(configForm._selectedHub);
      configForm._selectedHub = null;
      configForm._editButton.enabled = false;
      configForm._deleteButton.enabled = false;
      constants.edited = true;
    }, null, null);
  }
  static hide() {
    if (configForm._window == null)
      return;
    configForm._window.visible = false;
  }
  static show() {
    if (configForm._window == null) {
      configForm.GUIcoef = constants.generalSizeCoef;
      if (configForm.REFWIDH * configForm.GUIcoef > screen.width)
        configForm.GUIcoef = screen.width / configForm.REFWIDH;
      if (configForm.REFHEIGHT * configForm.GUIcoef > screen.height)
        configForm.GUIcoef = screen.height / configForm.REFHEIGHT;
      configForm.fontSize *= configForm.GUIcoef / constants.generalSizeCoef;
      let params = new newWindowParam(configForm.GUIcoef);
      params.positionType = 1;
      params.width = Math.round(configForm.REFWIDH * this.GUIcoef);
      params.height = Math.round(configForm.REFHEIGHT * this.GUIcoef);
      params.showContainerBorders = false;
      params.title = "Global configuration";
      configForm._window = new YWindow(params);
      configForm._contents = configForm._window.innerContentDiv;
      configForm._table = document.createElement("TABLE");
      configForm._contents.appendChild(configForm._table);
      configForm._table.style.position = "absolute";
      configForm._table.style.left = "0px";
      configForm._table.style.right = "0px";
      configForm._table.style.width = "100%";
      configForm._table.style.height = "100%";
      configForm._table.style.borderSpacing = "0";
      configForm._table.style.paddingLeft = (5 * this.GUIcoef).toString() + "px";
      configForm._table.style.paddingTop = (5 * this.GUIcoef).toString() + "px";
      configForm._table.style.paddingRight = (5 * this.GUIcoef).toString() + "px";
      configForm._table.style.borderCollapse = "separate";
      configForm._tr1 = document.createElement("TR");
      configForm._tr2 = document.createElement("TR");
      configForm._tr1.style.height = (2 * configForm.fontSize).toString() + "px";
      configForm._tabNetwork = new configEditorTab(configForm, "Network", configForm.fontSize, configForm.GUIcoef);
      configForm._tabCapture = new configEditorTab(configForm, "Screen capture", configForm.fontSize, configForm.GUIcoef);
      configForm._tabResources = new configEditorTab(configForm, "Ressources", configForm.fontSize, configForm.GUIcoef);
      configForm._tabUI = new configEditorTab(configForm, "User interface", configForm.fontSize, configForm.GUIcoef);
      configForm._tabExport = new configEditorTab(configForm, "Updates & XML", configForm.fontSize, configForm.GUIcoef);
      configForm._tabStub = new configEditorTab(configForm, "", configForm.fontSize, configForm.GUIcoef);
      this._tabPanelContents = document.createElement("TD");
      this._tabPanelContents.colSpan = 6;
      this._tabPanelContents.style.borderLeft = "1px solid " + this.activeBorderColor;
      this._tabPanelContents.style.borderRight = "1px solid " + this.activeBorderColor;
      this._tabPanelContents.style.borderBottom = "1px solid " + this.activeBorderColor;
      this._tabPanelContents.style.backgroundColor = this.activeBackgroundColor;
      configForm._tr1.appendChild(this._tabNetwork.tabElement);
      configForm._tr1.appendChild(this._tabCapture.tabElement);
      configForm._tr1.appendChild(this._tabResources.tabElement);
      configForm._tr1.appendChild(this._tabUI.tabElement);
      configForm._tr1.appendChild(this._tabExport.tabElement);
      configForm._tr1.appendChild(this._tabStub.tabElement);
      configForm._tr2.appendChild(this._tabPanelContents);
      configForm._tr2.childNodes[0].style.verticalAlign = "top";
      configForm._table.appendChild(this._tr1);
      configForm._table.appendChild(this._tr2);
      let p = document.createElement("P");
      p.style.textAlign = "justify";
      p.style.fontSize = configForm.fontSize.toString() + "px";
      p.style.paddingTop = "0px";
      p.style.marginTop = Math.round(3 * this.GUIcoef).toString() + "px";
      p.innerText = "Enter the list of VirtualHub or YoctoHub this page can connect to";
      this._tabNetwork.divElement.appendChild(p);
      configForm._Hubtable = document.createElement("TABLE");
      configForm._Hubtable.style.position = "absolute";
      configForm._Hubtable.style.display = "block";
      configForm._Hubtable.style.left = Math.round(20 * this.GUIcoef).toString() + "px";
      configForm._Hubtable.style.right = Math.round(20 * this.GUIcoef).toString() + "px";
      configForm._Hubtable.style.tableLayout = "auto";
      configForm._Hubtable.style.top = Math.round(80 * this.GUIcoef).toString() + "px";
      configForm._Hubtable.style.bottom = Math.round(40 * this.GUIcoef).toString() + "px";
      configForm._Hubtable.style.borderCollapse = "colapse";
      configForm._Hubtable.style.borderSpacing = "0px";
      configForm._Hubtable.style.border = "1px solid " + configForm.activeBorderColor;
      let HubtableTR = document.createElement("TR");
      HubtableTR.style.fontSize = configForm.fontSize.toString() + "px";
      let HubtableTH = document.createElement("TH");
      HubtableTH.colSpan = 2;
      HubtableTH.innerText = "Address";
      HubtableTH.style.borderBottom = "1px solid " + configForm.activeBorderColor;
      HubtableTH.style.width = Math.round(400 * this.GUIcoef).toString() + "px";
      HubtableTR.appendChild(HubtableTH);
      HubtableTH = document.createElement("TH");
      HubtableTH.innerText = "Status";
      HubtableTH.style.width = "40%";
      HubtableTH.style.borderBottom = "1px solid " + configForm.activeBorderColor;
      HubtableTH.style.borderLeft = "1px solid " + configForm.activeBorderColor;
      HubtableTR.appendChild(HubtableTH);
      configForm._Hubtable.appendChild(HubtableTR);
      let hubList = sensorsManager.hubList;
      for (let i = 0; i < hubList.length; i++) {
        configForm.AddHubToUI(hubList[i]);
      }
      let div = document.createElement("DIV");
      div.style.position = "absolute";
      div.style.bottom = "0px";
      div.style.right = Math.round(20 * configForm.GUIcoef).toString() + "px";
      div.style.height = Math.round(30 * configForm.GUIcoef).toString() + "px";
      div.style.textAlign = "right";
      div.style.verticalAlign = "center";
      configForm._newButton = new button("New", () => {
        configForm._window.hide();
        configForm.newHub();
      }, configForm.GUIcoef);
      div.appendChild(configForm._newButton.Element);
      configForm._editButton = new button("Edit", () => {
        configForm._window.hide();
        configForm.editSelectedHub();
      }, configForm.GUIcoef);
      configForm._editButton.enabled = false;
      div.appendChild(configForm._editButton.Element);
      configForm._deleteButton = new button("Delete", () => {
        configForm.deleteSelectedHub();
      }, configForm.GUIcoef);
      configForm._deleteButton.enabled = false;
      div.appendChild(configForm._deleteButton.Element);
      this._tabNetwork.divElement.appendChild(div);
      this._tabNetwork.divElement.appendChild(configForm._Hubtable);
      p = document.createElement("P");
      p.innerHTML = "Widgets content can be captured at anytime thought the <i>Snapshop</i> option available in right-click contextual menu";
      p.style.textAlign = "justify";
      p.style.fontSize = configForm.fontSize.toString() + "px";
      this._tabCapture.divElement.appendChild(p);
      let tableSize = document.createElement("TABLE");
      tableSize.style.fontSize = configForm.fontSize.toString() + "px";
      let row = document.createElement("TR");
      let td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      td.innerText = "ImageType";
      row.appendChild(td);
      td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      td.style.verticalAlign = "center";
      configForm.inputPNG = document.createElement("INPUT");
      configForm.inputSVG = document.createElement("INPUT");
      configForm.inputPNG.checked = constants.captureType == YDataRenderer.CaptureType.PNG;
      configForm.inputPNG.style.display = "inline";
      configForm.inputPNG.type = "checkbox";
      configForm.inputPNG.style.transform = "scale(" + this.GUIcoef.toString() + ")";
      configForm.inputPNG.style.marginRight = Math.round(5 * this.GUIcoef).toString() + "px";
      configForm.inputPNG.style.marginLeft = Math.round(5 * this.GUIcoef).toString() + "px";
      configForm.inputPNG.addEventListener("change", () => {
        configForm.captureFormatChange(configForm.inputPNG);
      });
      td.append(configForm.inputPNG);
      let span;
      span = document.createElement("SPAN");
      span.innerText = YDataRenderer.CaptureType.PNG.description;
      td.append(span);
      configForm.inputSVG = document.createElement("INPUT");
      configForm.inputSVG.checked = constants.captureType == YDataRenderer.CaptureType.SVG;
      configForm.inputSVG.style.display = "inline";
      configForm.inputSVG.type = "checkbox";
      configForm.inputSVG.style.transform = "scale(" + this.GUIcoef.toString() + ")";
      configForm.inputSVG.style.marginRight = Math.round(5 * this.GUIcoef).toString() + "px";
      configForm.inputSVG.style.marginLeft = Math.round(5 * this.GUIcoef).toString() + "px";
      configForm.inputSVG.addEventListener("change", () => {
        configForm.captureFormatChange(configForm.inputSVG);
      });
      td.append(configForm.inputSVG);
      span = document.createElement("SPAN");
      span.innerText = YDataRenderer.CaptureType.SVG.description;
      td.append(span);
      row.appendChild(td);
      tableSize.appendChild(row);
      row = document.createElement("TR");
      td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      td.innerText = "Resolution:";
      row.appendChild(td);
      td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      configForm.inputResolution = document.createElement("INPUT");
      configForm.inputResolution.style.fontFamily = constants.generalFontFamily;
      configForm.inputResolution.style.fontSize = constants.generalFontSize.toString() + "px";
      configForm.inputResolution.style.border = "1px solid grey";
      configForm.inputResolution.type = "number";
      configForm.inputResolution.style.textAlign = "right";
      configForm.inputResolution.style.marginRight = "5px";
      configForm.inputResolution.style.width = "60px";
      configForm.inputResolution.value = constants.captureDPI.toString();
      configForm.inputResolution.style.display = "inline";
      new InputFieldManager(configForm.inputResolution, 6, false, Number.NaN, Number.NaN, (sender, refreshInput) => {
        configForm.captureDPIChange(configForm.inputResolution);
      });
      td.append(configForm.inputResolution);
      span = document.createElement("SPAN");
      span.innerText = "DPI";
      td.append(span);
      row.appendChild(td);
      tableSize.appendChild(row);
      row = document.createElement("TR");
      td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      td.innerText = "Size:";
      td.style.verticalAlign = "top";
      row.appendChild(td);
      td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      configForm.inputSizeSelect = document.createElement("SELECT");
      configForm.inputSizeSelect.style.border = "1px solid grey";
      configForm.inputSizeSelect.style.fontFamily = constants.generalFontFamily;
      configForm.inputSizeSelect.style.fontSize = constants.generalFontSize.toString() + "px";
      let sizingOptions = YDataRenderer.CaptureFormats.Keep.sibblings;
      for (let i = 0; i < sizingOptions.length; i++) {
        let option = document.createElement("OPTION");
        option.text = sizingOptions[i].description;
        option.value = sizingOptions[i].toString;
        configForm.inputSizeSelect.add(option, null);
      }
      configForm.inputSizeSelect.value = constants.captureSizePolicy.toString;
      configForm.inputSizeSelect.addEventListener("change", () => {
        configForm.captureSizeSelectChange(configForm.inputSizeSelect);
      });
      td.append(configForm.inputSizeSelect);
      row.appendChild(td);
      tableSize.appendChild(row);
      let subtable = document.createElement("TABLE");
      configForm.captureWidthTR = document.createElement("TR");
      let subTD = document.createElement("TD");
      subTD.style.fontSize = configForm.fontSize.toString() + "px";
      subTD.innerText = "Width:";
      configForm.captureWidthTR.appendChild(subTD);
      subTD = document.createElement("TD");
      subTD.style.fontSize = configForm.fontSize.toString() + "px";
      configForm.inputCaptureWidth = document.createElement("INPUT");
      configForm.inputCaptureWidth.style.border = "1px solid grey";
      configForm.inputCaptureWidth.style.fontFamily = constants.generalFontFamily;
      configForm.inputCaptureWidth.style.fontSize = constants.generalFontSize.toString() + "px";
      configForm.inputCaptureWidth.type = "number";
      configForm.inputCaptureWidth.style.textAlign = "right";
      configForm.inputCaptureWidth.style.marginRight = "5px";
      configForm.inputCaptureWidth.style.width = "60px";
      configForm.inputCaptureWidth.value = constants.captureWidth.toString();
      configForm.inputCaptureWidth.style.display = "inline";
      new InputFieldManager(configForm.inputCaptureWidth, 3, false, Number.NaN, Number.NaN, (sender, refreshInput) => {
        configForm.captureWidthChange(configForm.inputCaptureWidth);
      });
      subTD.append(configForm.inputCaptureWidth);
      configForm.inputCaptureWidthInfo = document.createElement("SPAN");
      configForm.inputCaptureWidthInfo.innerText = "pixels";
      subTD.append(configForm.inputCaptureWidthInfo);
      configForm.captureWidthTR.appendChild(subTD);
      subtable.appendChild(configForm.captureWidthTR);
      configForm.captureHeightTR = document.createElement("TR");
      subTD = document.createElement("TD");
      subTD.style.fontSize = configForm.fontSize.toString() + "px";
      subTD.innerText = "Height:";
      configForm.captureHeightTR.appendChild(subTD);
      subTD = document.createElement("TD");
      subTD.style.fontSize = configForm.fontSize.toString() + "px";
      configForm.inputCaptureHeight = document.createElement("INPUT");
      configForm.inputCaptureHeight.style.border = "1px solid grey";
      configForm.inputCaptureHeight.style.fontFamily = constants.generalFontFamily;
      configForm.inputCaptureHeight.style.fontSize = constants.generalFontSize.toString() + "px";
      configForm.inputCaptureHeight.type = "number";
      configForm.inputCaptureHeight.style.textAlign = "right";
      configForm.inputCaptureHeight.style.marginRight = "5px";
      configForm.inputCaptureHeight.style.width = "60px";
      configForm.inputCaptureHeight.value = constants.captureHeight.toString();
      configForm.inputCaptureHeight.style.display = "inline";
      new InputFieldManager(configForm.inputCaptureHeight, 3, false, Number.NaN, Number.NaN, (sender, refreshInput) => {
        configForm.captureHeightChange(configForm.inputCaptureHeight);
      });
      subTD.append(configForm.inputCaptureHeight);
      configForm.inputCaptureHeightInfo = document.createElement("SPAN");
      configForm.inputCaptureHeightInfo.innerText = "pixels";
      subTD.append(configForm.inputCaptureHeightInfo);
      configForm.captureHeightTR.appendChild(subTD);
      subtable.appendChild(configForm.captureHeightTR);
      td.appendChild(subtable);
      configForm._tabCapture.divElement.appendChild(tableSize);
      let tableRessources = document.createElement("TABLE");
      row = document.createElement("TR");
      td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      td.innerText = "If you plan to use YoctoVisualization continuously for an extended period of time (i.e. several weeks),  or if you are running it on a computer with limited resources, you may want to limit the application memory consumption.";
      td.colSpan = 2;
      td.style.textAlign = "justify";
      row.appendChild(td);
      tableRessources.appendChild(row);
      row = document.createElement("TR");
      td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      td.innerText = "Max count of sensors data records:";
      row.appendChild(td);
      td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      let maxSensorRecs = document.createElement("INPUT");
      maxSensorRecs.style.border = "1px solid grey";
      maxSensorRecs.style.fontFamily = constants.generalFontFamily;
      maxSensorRecs.style.fontSize = constants.generalFontSize.toString() + "px";
      maxSensorRecs.type = "number";
      maxSensorRecs.style.textAlign = "right";
      maxSensorRecs.style.marginRight = "5px";
      maxSensorRecs.style.marginLeft = "5px";
      maxSensorRecs.style.width = "60px";
      maxSensorRecs.value = constants.maxDataRecordsPerSensor.toString();
      maxSensorRecs.style.display = "inline";
      new InputFieldManager(maxSensorRecs, 2, false, Number.NaN, Number.NaN, (sender, refreshInput) => {
        configForm.maxSensorRecsChange(maxSensorRecs);
      });
      td.append(maxSensorRecs);
      span = document.createElement("SPAN");
      span.innerText = "(0 = unlimited)";
      td.append(span);
      row.appendChild(td);
      tableRessources.appendChild(row);
      row = document.createElement("TR");
      td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      td.innerText = "Max count of graph series data points:";
      row.appendChild(td);
      td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      let maxSeriesRecs = document.createElement("INPUT");
      maxSeriesRecs.style.border = "1px solid grey";
      maxSeriesRecs.style.fontFamily = constants.generalFontFamily;
      maxSeriesRecs.style.fontSize = constants.generalFontSize.toString() + "px";
      maxSeriesRecs.type = "number";
      maxSeriesRecs.style.textAlign = "right";
      maxSeriesRecs.style.marginRight = "5px";
      maxSeriesRecs.style.marginLeft = "5px";
      maxSeriesRecs.style.width = "60px";
      maxSeriesRecs.value = constants.maxPointsPerGraphSerie.toString();
      maxSeriesRecs.style.display = "inline";
      new InputFieldManager(maxSeriesRecs, 2, false, Number.NaN, Number.NaN, (sender, refreshInput) => {
        configForm.maxSeriesRecsChange(maxSeriesRecs);
      });
      td.append(maxSeriesRecs);
      span = document.createElement("SPAN");
      span.innerText = "(0 = unlimited)";
      td.append(span);
      row.appendChild(td);
      tableRessources.appendChild(row);
      row = document.createElement("TR");
      td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      td.innerText = "\nYocto-Visualization automatically loads datalogger contents for all connected devices.  If you are using networked devices featuring  billable data transfers (GSM) you may want to limit or even disable that feature.";
      td.colSpan = 2;
      td.style.textAlign = "justify";
      row.appendChild(td);
      tableRessources.appendChild(row);
      row = document.createElement("TR");
      td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      td.innerText = "Max data points/series loaded from dataloggers:";
      row.appendChild(td);
      td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      let maxDataLogRecs = document.createElement("INPUT");
      maxDataLogRecs.style.border = "1px solid grey";
      maxDataLogRecs.style.fontFamily = constants.generalFontFamily;
      maxDataLogRecs.style.fontSize = constants.generalFontSize.toString() + "px";
      maxDataLogRecs.type = "number";
      maxDataLogRecs.style.textAlign = "right";
      maxDataLogRecs.style.marginRight = "5px";
      maxDataLogRecs.style.marginLeft = "5px";
      maxDataLogRecs.style.width = "60px";
      maxDataLogRecs.value = constants.maxPointsPerDataloggerSerie.toString();
      maxDataLogRecs.style.display = "inline";
      new InputFieldManager(maxDataLogRecs, 1, false, -1, Number.NaN, (sender, refreshInput) => {
        configForm.maxDataLogRecsChange(maxDataLogRecs);
      });
      td.append(maxDataLogRecs);
      span = document.createElement("SPAN");
      span.innerText = "(0 = unlimited,\n-1 = disabled)";
      td.append(span);
      row.appendChild(td);
      tableRessources.appendChild(row);
      row = document.createElement("TR");
      td = document.createElement("TD");
      td.style.fontSize = configForm.fontSize.toString() + "px";
      td.innerText = "After a  limit increase, you'll have to restart the application to get your old data back.";
      td.colSpan = 2;
      td.style.textAlign = "justify";
      row.appendChild(td);
      tableRessources.appendChild(row);
      configForm._tabResources.divElement.appendChild(tableRessources);
      p = document.createElement("P");
      p.style.fontSize = configForm.fontSize.toString() + "px";
      p.innerText = "You can alter user interface behavior according to your hardware capabilities.";
      this._tabUI.divElement.appendChild(p);
      let checkbox1 = document.createElement("INPUT");
      checkbox1.style.fontFamily = constants.generalFontFamily;
      checkbox1.style.fontSize = constants.generalFontSize.toString() + "px";
      checkbox1.style.display = "inline";
      checkbox1.type = "checkbox";
      checkbox1.style.transform = "scale(" + this.GUIcoef.toString() + ")";
      checkbox1.style.marginRight = Math.round(5 * this.GUIcoef).toString() + "px";
      checkbox1.checked = constants.dbleClickBringsUpContextMenu;
      checkbox1.addEventListener("change", () => {
        configForm.dbleClickBringsUpContextMenuChange(checkbox1);
      });
      this._tabUI.divElement.appendChild(checkbox1);
      span = document.createElement("SPAN");
      span.style.fontSize = configForm.fontSize.toString() + "px";
      span.innerText = "Double click/tap  brings up context menu\n";
      this._tabUI.divElement.appendChild(span);
      let checkbox2 = document.createElement("INPUT");
      checkbox2.style.display = "inline";
      checkbox2.type = "checkbox";
      checkbox2.style.transform = "scale(" + this.GUIcoef.toString() + ")";
      checkbox2.style.marginRight = Math.round(5 * this.GUIcoef).toString() + "px";
      checkbox2.checked = YGraph.verticalDragZoomEnabled;
      checkbox2.addEventListener("change", () => {
        configForm.verticalDragZoomChange(checkbox2);
      });
      this._tabUI.divElement.appendChild(checkbox2);
      span = document.createElement("SPAN");
      span.style.fontSize = configForm.fontSize.toString() + "px";
      span.innerText = "Graphs zoom can be driven by vertical drag\n";
      this._tabUI.divElement.appendChild(span);
      p = document.createElement("P");
      p.style.fontSize = configForm.fontSize.toString() + "px";
      p.innerText = "Yocto-Visualization tries to ajust UI size to screen resolution the best it can through a DPI based zoom factor. Unfortunately not all devices can properly report their screen resolution. That's why you can manually override that factor.";
      this._tabUI.divElement.appendChild(p);
      let DPIoverride = document.createElement("INPUT");
      let checkbox3 = document.createElement("INPUT");
      checkbox3.style.display = "inline";
      checkbox3.type = "checkbox";
      checkbox3.style.transform = "scale(" + this.GUIcoef.toString() + ")";
      checkbox3.style.marginRight = Math.round(5 * this.GUIcoef).toString() + "px";
      checkbox3.checked = constants.guiDPIFactorIsOverriden;
      checkbox3.addEventListener("change", () => {
        configForm.DPIoverrideChange(checkbox3, DPIoverride);
      });
      this._tabUI.divElement.appendChild(checkbox3);
      span = document.createElement("SPAN");
      span.style.fontSize = configForm.fontSize.toString() + "px";
      span.innerText = "Override zoom factor to ";
      this._tabUI.divElement.appendChild(span);
      DPIoverride.style.border = "1px solid grey";
      DPIoverride.style.fontFamily = constants.generalFontFamily;
      DPIoverride.style.fontSize = constants.generalFontSize.toString() + "px";
      DPIoverride.disabled = !constants.guiDPIFactorIsOverriden;
      DPIoverride.type = "number";
      DPIoverride.style.textAlign = "right";
      DPIoverride.style.marginRight = "5px";
      DPIoverride.style.marginLeft = "5px";
      DPIoverride.style.width = "60px";
      DPIoverride.value = constants.guiDPIFactorOverrideValue.toString();
      DPIoverride.style.display = "inline";
      new InputFieldManager(DPIoverride, 5, false, Number.NaN, Number.NaN, (sender, refreshInput) => {
        configForm.DPIoverrideChange(checkbox3, DPIoverride);
      });
      this._tabUI.divElement.appendChild(DPIoverride);
      p = document.createElement("P");
      p.style.fontSize = configForm.fontSize.toString() + "px";
      p.innerText = "This setting is stored in your browser cookies. So it is specific to this device, browser and server.You will have to reload this page for this setting to take effect";
      this._tabUI.divElement.appendChild(p);
      p = document.createElement("P");
      p.style.fontSize = configForm.fontSize.toString() + "px";
      p.style.textAlign = "justify";
      p.innerText = "As long as your web browser can reach www.yoctopuce.com, the read/write edition of Yocto-Visualization (for web) can automatically check for new version. If you find this feature anoying, feel free to disable it. ";
      this._tabExport.divElement.appendChild(p);
      let checkbox4 = document.createElement("INPUT");
      checkbox4.style.display = "inline";
      checkbox4.type = "checkbox";
      checkbox4.style.transform = "scale(" + this.GUIcoef.toString() + ")";
      checkbox4.style.marginLeft = Math.round(25 * this.GUIcoef).toString() + "px";
      checkbox4.checked = constants.mustCheckForUpdate;
      checkbox4.addEventListener("change", () => {
        configForm.mustCheckForUpdateChange(checkbox4);
      });
      this._tabExport.divElement.appendChild(checkbox4);
      span = document.createElement("SPAN");
      span.style.fontSize = configForm.fontSize.toString() + "px";
      span.innerText = "Automatically check for updates";
      let a2 = document.createElement("A");
      a2.innerText = "Check now";
      a2.style.paddingLeft = "25px";
      a2.style.cursor = "pointer";
      a2.style.color = "#0000EE";
      a2.style.textDecoration = "underline";
      a2.addEventListener("click", () => {
        YWebPage.CheckForNewVersion(true);
      });
      span.appendChild(a2);
      this._tabExport.divElement.appendChild(span);
      p = document.createElement("P");
      p.style.fontSize = configForm.fontSize.toString() + "px";
      p.style.textAlign = "justify";
      p.innerText = "Yocto-Visualization (for web) stores its configuration in a XML file. This file can be used to create a static web page running Yocto-Visualization (for web) or it can be used in the Yocto-Visualization (for web) installer to create a pre-configured install. Also, it is mostly compatible with the native version of Yocto-Visualization: you can use it instead of the original config.xml file. Just click on the link below to export/download your current configuration.";
      this._tabExport.divElement.appendChild(p);
      p = document.createElement("P");
      p.style.fontSize = configForm.fontSize.toString() + "px";
      p.style.textAlign = "right";
      let a = document.createElement("A");
      a.innerText = "Export current configuration";
      a.style.cursor = "pointer";
      a.style.color = "#0000EE";
      a.style.textDecoration = "underline";
      a.addEventListener("click", () => {
        configForm.downloadCurrentConfig();
      });
      p.appendChild(a);
      this._tabExport.divElement.appendChild(p);
      configForm._tabPanelContents.appendChild(this._tabNetwork.divElement);
      configForm._tabPanelContents.appendChild(this._tabCapture.divElement);
      configForm._tabPanelContents.appendChild(this._tabResources.divElement);
      configForm._tabPanelContents.appendChild(this._tabUI.divElement);
      configForm._tabPanelContents.appendChild(this._tabExport.divElement);
      configForm.tabSelected(this._tabNetwork);
      configForm.refreshSizeParams();
    }
    configForm._window.show();
  }
  static DPIoverrideChange(checkbox, input) {
    let value = parseFloat(input.value);
    input.disabled = !checkbox.checked;
    if (checkbox.checked && value > 0) {
      constants.overrideGuiDPIFactor(true, value);
    } else {
      constants.overrideGuiDPIFactor(false);
    }
  }
  static hubWasAdded(hub) {
    if (sensorsManager.newHubCreated(hub)) {
      configForm.AddHubToUI(hub);
      constants.edited = true;
      hub.Connect().then((r) => {
      });
    }
  }
  static hubGotEdited(hub) {
    configForm.RefreshUI(hub);
    constants.edited = true;
    hub.Disconnect().then((r) => {
    });
    hub.Connect().then((r) => {
    });
  }
  static dbleClickBringsUpContextMenuChange(source) {
    let prev = constants.dbleClickBringsUpContextMenu;
    constants.dbleClickBringsUpContextMenu = source.checked;
    if (prev != constants.dbleClickBringsUpContextMenu)
      constants.edited = true;
  }
  static verticalDragZoomChange(source) {
    let prev = YGraph.verticalDragZoomEnabled;
    YGraph.verticalDragZoomEnabled = source.checked;
    if (prev != YGraph.verticalDragZoomEnabled)
      constants.edited = true;
  }
  static mustCheckForUpdateChange(source) {
    let prev = constants.mustCheckForUpdate;
    constants.mustCheckForUpdate = source.checked;
    if (prev != constants.mustCheckForUpdate)
      constants.edited = true;
  }
  static maxDataLogRecsChange(source) {
    let value = parseInt(source.value);
    if (value != constants.maxPointsPerDataloggerSerie || value != CustomYSensor.MaxLoggerRecords) {
      constants.maxPointsPerDataloggerSerie = value;
      CustomYSensor.MaxLoggerRecords = value;
      constants.edited = true;
    }
  }
  static maxSeriesRecsChange(source) {
    let value = parseInt(source.value);
    if (value != constants.maxPointsPerGraphSerie || value != DataSerie.MaxPointsPerSeries) {
      constants.maxPointsPerGraphSerie = value;
      DataSerie.MaxPointsPerSeries = value;
      constants.edited = true;
    }
  }
  static maxSensorRecsChange(source) {
    let value = parseInt(source.value);
    if (value != constants.maxDataRecordsPerSensor || value != CustomYSensor.MaxDataRecords) {
      constants.maxDataRecordsPerSensor = value;
      CustomYSensor.MaxDataRecords = value;
      constants.edited = true;
    }
  }
  static captureDPIChange(source) {
    let prev = constants.captureDPI;
    constants.captureDPI = parseInt(source.value);
    if (constants.captureDPI != prev)
      constants.edited = true;
    configForm.refreshSizeParams();
  }
  static captureWidthChange(source) {
    let prev = constants.captureWidth;
    constants.captureWidth = parseInt(source.value);
    if (constants.captureWidth != prev)
      constants.edited = true;
    configForm.refreshSizeParams();
  }
  static captureHeightChange(source) {
    let prev = constants.captureHeight;
    constants.captureHeight = parseInt(source.value);
    if (constants.captureHeight != prev)
      constants.edited = true;
    configForm.refreshSizeParams();
  }
  static captureSizeSelectChange(source) {
    let prev = constants.captureSizePolicy;
    constants.captureSizePolicy = YDataRenderer.CaptureFormats.fromString(YDataRenderer.CaptureFormats, source.value);
    if (constants.captureSizePolicy != prev)
      constants.edited = true;
    configForm.refreshSizeParams();
  }
  static refreshSizeParams() {
    let value = YDataRenderer.CaptureFormats.fromString(YDataRenderer.CaptureFormats, configForm.inputSizeSelect.value);
    if (value == YDataRenderer.CaptureFormats.Keep) {
      configForm.captureWidthTR.style.display = "none";
      configForm.captureHeightTR.style.display = "none";
    } else if (value == YDataRenderer.CaptureFormats.FixedWidth) {
      configForm.captureWidthTR.style.display = "";
      configForm.captureHeightTR.style.display = "none";
    } else if (value == YDataRenderer.CaptureFormats.FixedHeight) {
      configForm.captureWidthTR.style.display = "none";
      configForm.captureHeightTR.style.display = "";
    }
    if (value == YDataRenderer.CaptureFormats.Fixed) {
      configForm.captureWidthTR.style.display = "";
      configForm.captureHeightTR.style.display = "";
    }
    let sw = 25.4 * parseInt(configForm.inputCaptureWidth.value) / parseInt(configForm.inputResolution.value);
    configForm.inputCaptureWidthInfo.innerText = "Pixels  (" + sw.toFixed(1) + "mm)";
    let sh = 25.4 * parseInt(configForm.inputCaptureHeight.value) / parseInt(configForm.inputResolution.value);
    configForm.inputCaptureHeightInfo.innerText = "Pixels  (" + sh.toFixed(1) + "mm)";
  }
  static downloadCurrentConfig() {
    let element = document.createElement("a");
    let data = "data:text/xml;base64," + btoa(YWebPage.get_XmlData());
    element.setAttribute("href", data);
    element.setAttribute("download", "config.xml");
    element.style.display = "none";
    document.body.appendChild(element);
    element.click();
    document.body.removeChild(element);
  }
  static captureFormatChange(source) {
    if (source == configForm.inputPNG)
      configForm.inputSVG.checked = !source.checked;
    if (source == configForm.inputSVG)
      configForm.inputPNG.checked = !source.checked;
    let prev = constants.captureType;
    constants.captureType = configForm.inputPNG.checked ? YDataRenderer.CaptureType.PNG : YDataRenderer.CaptureType.SVG;
    if (constants.captureType != prev)
      constants.edited = true;
  }
  static tabSelected(source) {
    this._tabNetwork.active = source == this._tabNetwork;
    this._tabCapture.active = source == this._tabCapture;
    this._tabResources.active = source == this._tabResources;
    this._tabUI.active = source == this._tabUI;
    this._tabExport.active = source == this._tabExport;
  }
};
configForm.GUIcoef = 1;
configForm.REFWIDH = 520;
configForm.REFHEIGHT = 300;
configForm.fontSize = constants.generalFontSize;

// obj/full/HubEdit_rw.js
var HubEdit = class {
  static get activeBorderColor() {
    return constants.WindowInnerBorderColor;
  }
  static get inactiveBorderColor() {
    return "#b0b0b0";
  }
  static get activeColor() {
    return "black";
  }
  static get inactiveColor() {
    return "grey";
  }
  static get activeBackgroundColor() {
    return constants.WindowInnerBackgroundColor;
  }
  static get inactiveBackgroundColor() {
    return constants.WindowBackgroundColor;
  }
  static newHub(whenDone) {
    HubEdit._currenthub = new Hub(2, "ws", "", "", true, "", "", "");
    HubEdit.show(HubEdit._currenthub);
    HubEdit._window.title = "New Connection";
    HubEdit._thisIsEditing = false;
    HubEdit._whenDone = whenDone;
  }
  static editHub(hub, whenDone) {
    HubEdit._currenthub = hub;
    HubEdit.show(HubEdit._currenthub);
    HubEdit._window.title = "Edit Connection";
    HubEdit._thisIsEditing = true;
    HubEdit._whenDone = whenDone;
  }
  static show(hub) {
    if (HubEdit._window == null) {
      HubEdit._okButton = new button("Ok", () => {
        HubEdit.okClicked();
      });
      HubEdit._cancelButton = new button("Cancel", () => {
        HubEdit.hide();
      });
      let params = new newWindowParam();
      params.positionType = 1;
      params.width = Math.round(450 * constants.generalSizeCoef);
      params.height = Math.round(280 * constants.generalSizeCoef);
      params.isModal = true;
      params.closeIcon = false;
      params.title = "...";
      params.buttons.push(HubEdit._okButton);
      params.buttons.push(HubEdit._cancelButton);
      HubEdit._window = new YWindow(params);
      HubEdit._contents = HubEdit._window.innerContentDiv;
      let p = document.createElement("P");
      p.style.paddingTop = "0px";
      p.style.marginTop = Math.round(3 * constants.generalSizeCoef).toString() + "px";
      p.style.lineHeight = Math.round(12 * constants.generalSizeCoef).toString() + "px";
      p.innerText = "Enter the hub connection parameter, The only mandatory parameter is the address, just leave the other fields empty if you want to use default values";
      p.style.textAlign = "justify";
      HubEdit._contents.appendChild(p);
      p.appendChild(document.createElement("BR"));
      p.appendChild(document.createElement("BR"));
      let span = document.createElement("SPAN");
      span.innerText = "Protocol:";
      span.style.marginLeft = "20px";
      p.appendChild(span);
      HubEdit._protocolSelect = document.createElement("SELECT");
      HubEdit._protocolSelect.style.border = "1px solid grey";
      HubEdit._protocolSelect.style.fontFamily = constants.generalFontFamily;
      HubEdit._protocolSelect.style.fontSize = constants.generalFontSize.toString() + "px";
      let httpOption = document.createElement("OPTION");
      httpOption.text = "http";
      httpOption.value = "http";
      HubEdit._protocolSelect.appendChild(httpOption);
      let httpsOption = document.createElement("OPTION");
      httpsOption.text = "https";
      httpsOption.value = "https";
      HubEdit._protocolSelect.appendChild(httpsOption);
      let wsOption = document.createElement("OPTION");
      wsOption.text = "ws";
      wsOption.value = "ws";
      HubEdit._protocolSelect.appendChild(wsOption);
      let wssOption = document.createElement("OPTION");
      wssOption.text = "wss";
      wssOption.value = "wss";
      HubEdit._protocolSelect.appendChild(wssOption);
      p.appendChild(HubEdit._protocolSelect);
      span = document.createElement("SPAN");
      span.style.marginLeft = "20px";
      span.innerText = "Address:";
      p.appendChild(span);
      HubEdit._addressInput = document.createElement("INPUT");
      HubEdit._addressInput.style.border = "1px solid grey";
      HubEdit._addressInput.style.fontFamily = constants.generalFontFamily;
      HubEdit._addressInput.style.fontSize = constants.generalFontSize.toString() + "px";
      HubEdit._addressInput.maxLength = 512;
      HubEdit._addressInput.size = 15;
      HubEdit._addressInput.value = hub.addr;
      new InputFieldManager(HubEdit._addressInput, 0, false, Number.NaN, Number.NaN, null);
      p.appendChild(HubEdit._addressInput);
      span = document.createElement("SPAN");
      span.style.marginLeft = Math.round(20 * constants.generalSizeCoef).toString() + "px";
      span.innerText = "Port:";
      p.appendChild(span);
      HubEdit._portInput = document.createElement("INPUT");
      HubEdit._portInput.style.border = "1px solid grey";
      HubEdit._portInput.style.fontFamily = constants.generalFontFamily;
      HubEdit._portInput.style.fontSize = constants.generalFontSize.toString() + "px";
      HubEdit._portInput.style.textAlign = "right";
      HubEdit._portInput.maxLength = 5;
      HubEdit._portInput.size = 5;
      new InputFieldManager(HubEdit._portInput, 3, true, Number.NaN, Number.NaN, null);
      p.appendChild(HubEdit._portInput);
      p.appendChild(document.createElement("BR"));
      p.appendChild(document.createElement("BR"));
      span = document.createElement("SPAN");
      span.innerText = "Path:";
      span.style.marginLeft = Math.round(20 * constants.generalSizeCoef).toString() + "px";
      p.appendChild(span);
      HubEdit._pathInput = document.createElement("INPUT");
      HubEdit._pathInput.style.border = "1px solid grey";
      HubEdit._pathInput.style.fontFamily = constants.generalFontFamily;
      HubEdit._pathInput.style.fontSize = constants.generalFontSize.toString() + "px";
      HubEdit._pathInput.size = 45;
      p.appendChild(HubEdit._pathInput);
      p.appendChild(document.createElement("BR"));
      p.appendChild(document.createElement("BR"));
      span = document.createElement("SPAN");
      span.innerText = "Username:";
      span.style.marginLeft = Math.round(20 * constants.generalSizeCoef).toString() + "px";
      p.appendChild(span);
      HubEdit._usernameInput = document.createElement("INPUT");
      HubEdit._usernameInput.style.border = "1px solid grey";
      HubEdit._usernameInput.style.fontFamily = constants.generalFontFamily;
      HubEdit._usernameInput.style.fontSize = constants.generalFontSize.toString() + "px";
      HubEdit._usernameInput.size = 15;
      p.appendChild(HubEdit._usernameInput);
      span = document.createElement("SPAN");
      span.innerText = "Password:";
      span.style.marginLeft = Math.round(20 * constants.generalSizeCoef).toString() + "px";
      p.appendChild(span);
      HubEdit._passwordInput = document.createElement("INPUT");
      HubEdit._passwordInput.type = "password";
      HubEdit._passwordInput.style.border = "1px solid grey";
      HubEdit._passwordInput.style.fontFamily = constants.generalFontFamily;
      HubEdit._passwordInput.style.fontSize = constants.generalFontSize.toString() + "px";
      HubEdit._passwordInput.size = 15;
      p.appendChild(HubEdit._passwordInput);
      p = document.createElement("P");
      p.style.paddingTop = "0px";
      p.style.marginTop = Math.round(3 * constants.generalSizeCoef).toString() + "px";
      p.style.lineHeight = Math.round(12 * constants.generalSizeCoef).toString() + "px";
      p.innerText = "Important note: credentials are saved in the configuration file wich is easily accessible. Therefore, if hub is write-protected, it might be wise to use ReadOnly credentials here. When installed on a Yoctopuce hub, Yocto-Visualization (for web) will automatically ask for read/write credentials at save time if neccessary.";
      p.style.textAlign = "justify";
      HubEdit._contents.appendChild(p);
    }
    HubEdit._protocolSelect.value = hub.protocol;
    HubEdit._addressInput.value = hub.addr;
    HubEdit._portInput.value = hub.port;
    HubEdit._pathInput.value = hub.path;
    HubEdit._usernameInput.value = hub.user;
    HubEdit._passwordInput.value = hub.encryptedPassword != "" ? HubEdit.FakePassword : "";
    HubEdit._window.show();
  }
  static hide() {
    if (HubEdit._window == null)
      return;
    HubEdit._window.hide();
    HubEdit._passwordInput.value = "";
    if (HubEdit._whenDone != null)
      HubEdit._whenDone();
  }
  static okClicked() {
    HubEdit._currenthub.protocol = HubEdit._protocolSelect.value;
    HubEdit._currenthub.addr = HubEdit._addressInput.value;
    HubEdit._currenthub.port = HubEdit._portInput.value;
    HubEdit._currenthub.path = HubEdit._pathInput.value;
    HubEdit._currenthub.user = HubEdit._usernameInput.value;
    if (HubEdit._currenthub.user != "") {
      if (HubEdit._passwordInput.value != HubEdit.FakePassword) {
        HubEdit._currenthub.encryptedPassword = Hub.Encrypt(HubEdit._passwordInput.value, Hub.loginCypherPassword);
      }
    } else {
      HubEdit._currenthub.encryptedPassword = "";
    }
    if (HubEdit._thisIsEditing) {
      configForm.hubGotEdited(HubEdit._currenthub);
    } else {
      configForm.hubWasAdded(HubEdit._currenthub);
    }
    HubEdit.hide();
    if (HubEdit._whenDone != null)
      HubEdit._whenDone();
  }
};
HubEdit.FakePassword = "******";
HubEdit._thisIsEditing = false;
HubEdit._whenDone = null;
HubEdit.fontSize = constants.generalFontSize;

// obj/full/credPrompt_rw.js
var CredentialsPrompt = class {
  static get activeBorderColor() {
    return constants.WindowInnerBorderColor;
  }
  static get inactiveBorderColor() {
    return "#b0b0b0";
  }
  static get activeColor() {
    return "black";
  }
  static get inactiveColor() {
    return "grey";
  }
  static get activeBackgroundColor() {
    return constants.WindowInnerBackgroundColor;
  }
  static get inactiveBackgroundColor() {
    return constants.WindowBackgroundColor;
  }
  static get username() {
    return this._username;
  }
  static get password() {
    return this._password;
  }
  static show(targeturl, whenDone) {
    if (CredentialsPrompt._window == null) {
      CredentialsPrompt._okButton = new button("Ok", () => {
        CredentialsPrompt.okClicked();
      });
      CredentialsPrompt._cancelButton = new button("Cancel", () => {
        CredentialsPrompt.hide();
      });
      let params = new newWindowParam();
      params.positionType = 1;
      params.width = Math.round(450 * constants.generalSizeCoef);
      params.height = Math.round(175 * constants.generalSizeCoef);
      params.isModal = true;
      params.closeIcon = false;
      params.title = "Some credentials are required";
      params.buttons.push(CredentialsPrompt._okButton);
      params.buttons.push(CredentialsPrompt._cancelButton);
      CredentialsPrompt._window = new YWindow(params);
      CredentialsPrompt._contents = CredentialsPrompt._window.innerContentDiv;
      let p = document.createElement("P");
      p.style.paddingTop = "10px";
      p.style.marginTop = Math.round(5 * constants.generalSizeCoef).toString() + "px";
      p.style.lineHeight = Math.round(15 * constants.generalSizeCoef).toString() + "px";
      p.innerText = "Saving configuration on " + targeturl + " requires  read/write credentials.";
      p.style.textAlign = "justify";
      CredentialsPrompt._contents.appendChild(p);
      p.appendChild(document.createElement("BR"));
      p.appendChild(document.createElement("BR"));
      let span = document.createElement("SPAN");
      span = document.createElement("SPAN");
      span.innerText = "Username:";
      span.style.marginLeft = Math.round(20 * constants.generalSizeCoef).toString() + "px";
      p.appendChild(span);
      CredentialsPrompt._usernameInput = document.createElement("INPUT");
      CredentialsPrompt._usernameInput.style.border = "1px solid grey";
      CredentialsPrompt._usernameInput.style.fontFamily = constants.generalFontFamily;
      CredentialsPrompt._usernameInput.style.fontSize = constants.generalFontSize.toString() + "px";
      CredentialsPrompt._usernameInput.size = 15;
      p.appendChild(CredentialsPrompt._usernameInput);
      span = document.createElement("SPAN");
      span.innerText = "Password:";
      span.style.marginLeft = Math.round(20 * constants.generalSizeCoef).toString() + "px";
      p.appendChild(span);
      CredentialsPrompt._passwordInput = document.createElement("INPUT");
      CredentialsPrompt._passwordInput.type = "password";
      CredentialsPrompt._passwordInput.style.border = "1px solid grey";
      CredentialsPrompt._passwordInput.style.fontFamily = constants.generalFontFamily;
      CredentialsPrompt._passwordInput.style.fontSize = constants.generalFontSize.toString() + "px";
      CredentialsPrompt._passwordInput.size = 15;
      CredentialsPrompt._passwordInput.addEventListener("keypress", (e) => {
        if (e.key == "Enter")
          this.okClicked();
      });
      p.appendChild(CredentialsPrompt._passwordInput);
    }
    CredentialsPrompt._window.show();
    CredentialsPrompt._usernameInput.focus();
    CredentialsPrompt._whenDone = whenDone;
  }
  static hide() {
    if (CredentialsPrompt._window == null)
      return;
    CredentialsPrompt._window.hide();
    CredentialsPrompt._passwordInput.value = "";
  }
  static okClicked() {
    CredentialsPrompt._username = CredentialsPrompt._usernameInput.value;
    CredentialsPrompt._password = CredentialsPrompt._passwordInput.value;
    CredentialsPrompt.hide();
    if (CredentialsPrompt._whenDone != null)
      CredentialsPrompt._whenDone(CredentialsPrompt._usernameInput.value, CredentialsPrompt._passwordInput.value);
  }
};
CredentialsPrompt._whenDone = null;
CredentialsPrompt.fontSize = constants.generalFontSize;
CredentialsPrompt._username = "";
CredentialsPrompt._password = "";

// obj/full/YoctoVisualizationBinaries.js
var BinariesBlobs = class {
};
BinariesBlobs.ro_js = "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";
BinariesBlobs.rw_js = "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";
BinariesBlobs.ro_minjs = "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";
BinariesBlobs.rw_minjs = "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";

// obj/full/installer_rw.js
var codeInstance = class {
  constructor(filename, EStarget, version, readonly) {
    this._compressed = filename.slice(-3) == ".gz";
    this._filename = this._compressed ? filename.slice(0, -3) : filename;
    this._version = version == "" ? "Unknown" : version;
    this._EStarget = EStarget == "" ? "Unknown" : EStarget;
    this._minified = filename.indexOf(".min.") > 0;
    this._readonly = readonly;
  }
  get compressed() {
    return this._compressed;
  }
  get version() {
    return this._version;
  }
  get readonly() {
    return this._readonly;
  }
  get EStarget() {
    return this._EStarget;
  }
  get minified() {
    return this._minified;
  }
  get filename() {
    return this._filename + (this.compressed ? ".gz" : "");
  }
};
var pageInstance = class {
  constructor(filename, contents) {
    let strContents = YAPI.imm_bin2str(contents);
    this._compressed = filename.slice(-3) == ".gz";
    this._filename = this._compressed ? filename.slice(0, -3) : filename;
    this._readonly = strContents.indexOf("yv4web-readonly") > 0;
    this._useMinified = strContents.indexOf("yv4web-readonly.min.js") > 0 || strContents.indexOf("yv4web-full.min.js") > 0;
    this._action = 0;
    this._contents = contents;
  }
  get compressed() {
    return this._compressed;
  }
  get readonly() {
    return this._readonly;
  }
  set readonly(value) {
    this._readonly = value;
  }
  get fs_filename() {
    return this._filename + (this.compressed ? ".gz" : "");
  }
  get http_filename() {
    return this._filename;
  }
  set action(value) {
    this._action = value;
  }
  get action() {
    return this._action;
  }
  get contents() {
    return this._contents;
  }
  get useMinified() {
    return this._useMinified;
  }
  set useMinified(value) {
    this._useMinified = value;
  }
};
var YV4W_installer = class {
  constructor(container, options) {
    this.CALLERISHTTPS = location.protocol.toLowerCase().substr(0, 5) == "HTTPS";
    this.DEFAULT_PROTOCOL = this.CALLERISHTTPS ? YV4W_installer.HTTPS : YV4W_installer.HTTP;
    this.FIRMWAREMINVERSION = 43805;
    this.DEFAULTADDR = "";
    this.DEFAULTPORT = "80";
    this.DEFAULTPATH = "";
    this.DEFAULTCANCELABLE = false;
    this.DEFAULTINTIALFOCUS = true;
    this.DEFAULTUSER = "";
    this.DEFAULTPWD = "";
    this.DEFAULTFILEPREFIX = "default";
    this.DEFAULTSRVUSERNAME = "";
    this.DEFAULTSRVPASSORD = "";
    this._currentStep = 0;
    this._warningRow = null;
    this._welcomeText = null;
    this._hubAddr = null;
    this._connectingText = null;
    this._ipAddrInput = null;
    this._protocolInput = null;
    this._ipPortInput = null;
    this._pathInput = null;
    this._configFileInput = null;
    this._webPageInput = null;
    this._connectiongError = null;
    this._pwdPanel = null;
    this._descPanel = null;
    this._customFilesPanel = null;
    this._doneMsgContainer = null;
    this._confirmUninstallPanel = null;
    this._modInstancesPanel = null;
    this._donePanel = null;
    this._runPanel = null;
    this._modifyInstallPanel = null;
    this._adminNameInput = null;
    this._adminPasswordInput = null;
    this._userNameInput = null;
    this._userPasswordInput = null;
    this._useReadOnlyInput = null;
    this._fileprefixInput = null;
    this._useFullVersionInput = null;
    this._removeUnusedJs = null;
    this._makeDefaultInput = null;
    this._userCredTable = null;
    this._optionsPanel = null;
    this._connectionErrorMsg = null;
    this._instancesFiles = [];
    this._jsCodeinstances = [];
    this._webPageinstances = [];
    this._uninstallOpt = null;
    this._updateOpt = null;
    this._addInstanceOpt = null;
    this._modInstanceOpt = null;
    this._confirmUninstall = null;
    this._history = [];
    this._ErrMsgContainer = null;
    this._currentHub = null;
    this._currentfs = null;
    this._currentHub_RW_username = "";
    this._currentHub_RW_password = "";
    this._currentHub_RO_username = "";
    this._currentHub_RO_password = "";
    this._currentHub_protocol = "";
    this._currentHubLink_protocol = "";
    this._currentHub_Addr = "";
    this._currentHub_port = "";
    this._currentHub_path = "";
    this._currentHub_ReadOnlyProtected = false;
    this._warning = "";
    this._finalURL = "";
    this._plannedaction = 0;
    this._alreadyInstalled = false;
    this._applicationURL = "";
    this.ESVersion = "es2017";
    this.WELCOMEPANEL = 0;
    this.ENTERHUBADDR = 1;
    this.CONNECTINGPANEL = 2;
    this.CONNECTIONERROR = 3;
    this.PASSWORDPANEL = 4;
    this.DESCRIPTIONPANEL = 5;
    this.CUSTOMFILESPANEL = 6;
    this.OPTIONSPANEL = 7;
    this.RUNPANEL = 8;
    this.DONEPANEL = 9;
    this.MODIFYINSTALLPANEL = 10;
    this.CONFIRMUNINSTALLPANEL = 11;
    this.MODINSTANCESPANEL = 12;
    this.ACTIONINSTALL = 1;
    this.ACTIONUNINSTALL = 2;
    this.ACTIONADDINSTANCE = 3;
    this.ACTIONMODINSTANCE = 4;
    this.ACTIONUPDATE = 5;
    this._MODIFYNOTHING = 0;
    this._MODIFYCOMPRESS = 1;
    this._MODIFYUNCOMPRESS = 2;
    this._MODIFYMAKEREADONLY = 3;
    this._MODIFYMAKEREADWRITE = 4;
    this._MODIFYUSEMINIFIED = 5;
    this._MODIFYUSEPLAIN = 6;
    this._MODIFYDELETE = 7;
    this.TARGETEXTENSION = ".html";
    this.icon = '<link rel="icon" type="image/svg+xml" href="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNjQiIGhlaWdodD0iNjQiIHZlcnNpb249IjEuMSIgdmlld0JveD0iMCAwIDE3IDE3IiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPjxyZWN0IHg9IjAiIHk9IjAiIHdpZHRoPSIxNyIgaGVpZ2h0PSIxNyIgcng9IjEuMSIgcnk9IjEuMSIgZmlsbD0iI2ZmZiIgZmlsbC1vcGFjaXR5PSIuOSIvPjxwYXRoIGQ9Im0xMC43IDEuMy0wLjI5IDAuMjljLTAuMDQ3IDAuMDQ3LTAuMDczIDAuMTEtMC4wNzIgMC4xOHYxLjFjLTEuMS0wLjktMi43LTAuODMtMy43IDAuMTRsLTAuNC0wLjR2LTAuOTdjMC4zNS0wLjI1IDAuMi0wLjgyLTAuMjMtMC44My0wLjQzLTAuMDE0LTAuNjMgMC41My0wLjI3IDAuODJ2MS4xYzAgMC4wNjcgMC4wMjcgMC4xMyAwLjA3NCAwLjE4bDAuNDkgMC40OWMtMC40MyAwLjU5LTAuNjMgMS4zLTAuNTQgMi4xdjAuMDA3MmwtMC44My0wLjgzYy0wLjA0Ny0wLjA0Ny0wLjExLTAuMDczLTAuMTgtMC4wNzJoLTJjLTAuMjctMC4zNi0wLjgzLTAuMTktMC44MyAwLjI1IDAuMDAxMiAwLjQ0IDAuNTYgMC42MiAwLjgyIDAuMjVoMS45bDEuMyAxLjNjMC40MyAwLjM4IDAuNzQgMS4yIDAuNTkgMS42aC0yLjVjLTAuMDY2IDAgLTAuMTMgMC4wMjctMC4xOCAwLjA3NGwtMS40IDEuNGMtMC4zOS0wLjA4OS0wLjcyIDAuMzQtMC40OCAwLjY5czAuODYgMC4yIDAuODItMC4zM2wxLjMtMS4zaDIuNmMwLjI2IDAuMTUgMC41MSAwLjQgMC42NyAwLjY1djEuOWwtMS41IDEuNWMtMC4wNDcgMC4wNDctMC4wNzMgMC4xMS0wLjA3NCAwLjE4djAuMjhjLTAuNDUgMC4zLTAuMTUgMC44MyAwLjIzIDAuODMgMC4zOCAwIDAuNjMtMC40NyAwLjI3LTAuODF2LTAuMjFsMS41LTEuNWMwLjA0Ny0wLjA0NiAwLjA3NC0wLjExIDAuMDc0LTAuMTh2LTEuN2MwLjI0LTAuMzIgMS4xLTAuNCAxLjQtMC4wM3YxLjJjIDAgMC4wNjYgMC4wMjcgMC4xMyAwLjA3NCAwLjE4bDEuNSAxLjV2MC42OWMtMC4zNiAwLjI0LTAuMjMgMC44MSAwLjI3IDAuODIgMC40OSAwLjAwMjEgMC41NC0wLjY0IDAuMjMtMC44MnYtMC43OWMgMCAtMC4wNjYtMC4wMjctMC4xMy0wLjA3NC0wLjE4bC0xLjUtMS41di0xLjRjMC4xNS0wLjIgMC4zLTAuMjUgMC41My0wLjI0aDMuMmwwLjkxIDAuOTFjLTAuMDk5IDAuNDQgMC40OCAwLjcyIDAuNzcgMC40IDAuMjgtMC4zMiAwLjA3Mi0wLjc5LTAuNDItMC43NmwtMC45OC0wLjk4Yy0wLjA0Ny0wLjA0Ny0wLjExLTAuMDcyLTAuMTgtMC4wNzJoLTNjLTAuMjEtMC4zMiAwLjI0LTEuNSAwLjY3LTEuOWwyLjIgMC4wMDU5YzAuMDY3IDAgMC4xMy0wLjAyNiAwLjE4LTAuMDcybDEuMS0xLjFjMC4zOSAwLjA5NiAwLjczLTAuNCAwLjQ0LTAuNzNzLTAuODctMC4xLTAuNzggMC4zNmwtMS4xIDEuMWgtMmMwLjI3LTAuOTUgMC4wMDY3LTEuOS0wLjQzLTIuNXYtMS41bDAuMjEtMC4yMWMwLjM4IDAuMDgyIDAuNzEtMC4zMyAwLjQ2LTAuNjlzLTAuODctMC4xOS0wLjggMC4zM3ptLTMuMiA0LjljMC44NC0wLjAyOSAwLjk2IDEuNSAwLjIgMS41LTAuNzYtMC4wMTQtMS0xLjQtMC4yLTEuNXptMi4xIDBjMC43NSAwLjA4NCAwLjYxIDEuNS0wLjIgMS41LTAuODEgMC4wMDMzLTAuNTUtMS41IDAuMi0xLjV6IiBmaWxsLW9wYWNpdHk9Ii4xIi8+PHJlY3QgeD0iMCIgeT0iMCIgd2lkdGg9IjE3IiBoZWlnaHQ9IjE2IiByeT0iMS44IiBvcGFjaXR5PSIwIiBzdHJva2Utd2lkdGg9Ii4yNiIvPjxlbGxpcHNlIGN4PSI5LjQiIGN5PSI3LjQiIHJ4PSIuMzQiIHJ5PSIuMzMiIG9wYWNpdHk9Ii4xIi8+PGVsbGlwc2UgY3g9IjcuNyIgY3k9IjcuNCIgcng9Ii4zNCIgcnk9Ii4zMyIgb3BhY2l0eT0iLjEiLz48ZyBmaWxsPSJub25lIj48cGF0aCBkPSJtMS4xIDEuOSAwLjA2NiAxNCIgc3Ryb2tlPSIjN2U3ZTdlIiBzdHJva2Utd2lkdGg9Ii4yIi8+PHBhdGggZD0ibTE1IDEzaC0xNSIgc3Ryb2tlPSIjN2U3ZTdlIiBzdHJva2Utd2lkdGg9Ii4yIi8+PHBhdGggZD0ibTEuMiAxM2M1LjQtMS4xIDEwLTIuNyAxNS02LjkiIHN0cm9rZT0ibGltZSIgIHN0cm9rZS13aWR0aD0iLjQiLz48cGF0aCBkPSJtMS4yIDEzYzAuMS0wLjA1MyAwLjQ1LTEuNCAxLjItMS40IDAuNzggMCAxLjQgMi44IDIuMyAyLjggMC44Ni0wLjAwMTUgMS42LTIuOCAyLjQtMi44IDAuODQgMCAxLjUgMi44IDIuNCAyLjggMC45IDAuMDEzIDEuNi0yLjggMi40LTIuOCAwLjgyIDAuMDI4IDEuNSAyLjcgMi4zIDIuOCAwLjI2IDAuMDQzIDAuNjgtMC4zNCAwLjY3LTAuNDIiICBzdHJva2U9InJlZCIgIHN0cm9rZS13aWR0aD0iLjQiLz48L2c+PHBhdGggZD0ibTE1IDEyLjQgMS4xIDAuNi0xLjEgMC41N3oiIGZpbGw9IiM3ZTdlN2UiLz48cGF0aCBkPSJtMC41MiAyIDAuNjItMSAwLjU5IDF6IiBmaWxsPSIjN2U3ZTdlIi8+PHBhdGggZD0ibTkuOCAwIDcuMiA3LjJ2LTRsLTMuMi0zLjJ6IiBmaWxsPSJncmVlbiIvPjxnIGZpbGw9IiNmZmYiIHN0cm9rZS13aWR0aD0iMSI+PHBhdGggZD0ibTEyLjcgMS42MyAwLjQ5LTEuMSAwLjE5IDAuMTktMC4zMyAwLjc0IDAuNzUtMC4zMiAwLjEyIDAuMTItMC4zMiAwLjc1IDAuNzMtMC4zNCAwLjE3IDAuMTctMS4xIDAuNDktMC4xMi0wLjEyIDAuMzMtMC43Ny0wLjc3IDAuMzN6Ii8+PHBhdGggZD0ibTEzLjggMi43OSAwLjc5LTAuNzkgMC44MiAwLjgyLTAuMTQgMC4xNC0wLjY0LTAuNjQtMC4xOCAwLjE4IDAuMzYgMC4zNi0wLjE0IDAuMTQtMC4zNi0wLjM2LTAuMTkgMC4xOSAwLjY0IDAuNjQtMC4xNSAwLjE1eiIvPjxwYXRoIGQ9Im0xNi4xIDMuOC0wLjQyLTAuNDItMC4xOSAwLjE5IDAuNDIgMC40MnEwLjA0OSAwLjA0OSAwLjA3OSAwLjA1MyAwLjAzMiAwIDAuMDY0LTAuMDI2bDAuMDc1LTAuMDc1cTAuMDMxLTAuMDMxIDAuMDI1LTAuMDYyLTAuMDA0NS0wLjAzMi0wLjA1Mi0wLjA3OXptLTAuMzIgMC4zMi0wLjQyLTAuNDItMC4yIDAuMiAwLjQyIDAuNDJxMC4wNTIgMC4wNTMgMC4wODYgMC4wNTQgMC4wMzUgMC4wMDMxIDAuMDc1LTAuMDM3bDAuMDYtMC4wNnEwLjA0LTAuMDQgMC4wMzYtMC4wNzQtMC4wMDIzLTAuMDM0LTAuMDU0LTAuMDg2em0tMC45NS0wLjI2IDAuNzktMC43OSAwLjY4IDAuNjhxMC4wOTQgMC4wOTQgMC4xIDAuMTcgMC4wMDUzIDAuMDc5LTAuMDc1IDAuMTZsLTAuMDk4IDAuMDk4cS0wLjA1NyAwLjA1Ny0wLjEyIDAuMDU3LTAuMDY5LTAuMDAxNS0wLjE1LTAuMDU5IDAuMDU5IDAuMDc3IDAuMDU3IDAuMTYtMC4wMDIzIDAuMDc3LTAuMDY2IDAuMTRsLTAuMSAwLjFxLTAuMDc5IDAuMDc5LTAuMTcgMC4wNTktMC4wOTYtMC4wMTktMC4yMi0wLjE0eiIvPjwvZz48L3N2Zz4=">';
    if (typeof options !== "undefined") {
      if (options != null) {
        if (typeof options["protocol"] === "string")
          this.DEFAULT_PROTOCOL = options["protocol"].toUpperCase() == YV4W_installer.HTTPS.toUpperCase() ? YV4W_installer.HTTPS : YV4W_installer.HTTP;
        if (typeof options["addr"] === "string") {
          this.DEFAULTADDR = options["addr"];
          let n = this.DEFAULTADDR.indexOf(":");
          if (n > 0) {
            this.DEFAULTPORT.substring(n + 1);
            this.DEFAULTADDR.substring(0, n);
          }
        }
        if (typeof options["port"] === "number")
          this.DEFAULTPORT = options["port"].toString();
        if (typeof options["path"] === "string")
          this.DEFAULTPATH = options["path"];
        if (typeof options["cancelable"] === "boolean")
          this.DEFAULTCANCELABLE = options["cancelable"];
        if (typeof options["initialFocus"] === "boolean")
          this.DEFAULTINTIALFOCUS = options["initialFocus"];
      }
    }
    this._container = container;
    this._container.innerHTML = "";
    this._container.style.backgroundColor = constants.WindowBackgroundColor;
    this._container.style.fontFamily = constants.WindowHeaderFontFamily;
    let bottomdiv = document.createElement("DIV");
    bottomdiv.style.position = "absolute";
    bottomdiv.style.bottom = "0px";
    bottomdiv.style.right = "5px";
    bottomdiv.style.height = "30px";
    bottomdiv.style.textAlign = "right";
    bottomdiv.style.verticalAlign = "center";
    this._prevButton = new button("< Prev", () => {
      this.gotoPrevious();
    }, 1);
    this._cancelButton = new button("Cancel", async () => {
      this.closeWindow();
    }, 1);
    this._nextButton = new button("Next >", () => {
      this.gotoNext();
    }, 1);
    this._okButton = new button("Ok", async () => {
      this.DEFAULTCANCELABLE ? this.closeWindow() : await this.resetAll();
    }, 1);
    this._prevButton.tabIndex = 100;
    this._cancelButton.tabIndex = 101;
    this._nextButton.tabIndex = 102;
    this._okButton.tabIndex = 103;
    bottomdiv.appendChild(this._prevButton.Element);
    bottomdiv.appendChild(this._cancelButton.Element);
    bottomdiv.appendChild(this._nextButton.Element);
    bottomdiv.appendChild(this._okButton.Element);
    this._prevButton.visible = false;
    this._cancelButton.visible = this.DEFAULTCANCELABLE;
    this._container.appendChild(bottomdiv);
    let topDiv = document.createElement("DIV");
    topDiv.style.position = "absolute";
    topDiv.style.top = "5px";
    topDiv.style.paddingLeft = "10px";
    topDiv.style.paddingTop = "5px";
    topDiv.style.paddingBottom = "5px";
    topDiv.style.left = "5px";
    topDiv.style.right = "5px";
    topDiv.style.backgroundColor = constants.WindowHeaderBackgroundColor;
    topDiv.style.color = constants.WindowHeaderColor;
    topDiv.style.fontSize = "x-large";
    topDiv.style.whiteSpace = "nowrap";
    topDiv.style.overflow = "hidden";
    topDiv.innerText = "Yocto-Visualization (for web) installer";
    this._container.appendChild(topDiv);
    this.gotoPanel(this.WELCOMEPANEL);
  }
  closeWindow() {
    var _a;
    (_a = this._container.parentElement) === null || _a === void 0 ? void 0 : _a.removeChild(this._container);
  }
  createNewContentDiv() {
    let div = document.createElement("DIV");
    div.style.position = "absolute";
    div.style.textAlign = "justify";
    div.style.top = "50px";
    div.style.left = "15px";
    div.style.right = "15px";
    return div;
  }
  loadLocalFile(fileChooser) {
    return new Promise(function(resolve, reject) {
      if (fileChooser.files && fileChooser.files[0]) {
        let reader = new FileReader();
        reader.onload = function(e) {
          resolve(e.target.result);
        };
        reader.readAsText(fileChooser.files[0]);
      } else {
        resolve(null);
      }
    });
  }
  showWelcomePanel(visible, goingback) {
    if (!visible) {
      if (this._welcomeText != null)
        this._welcomeText.style.display = "none";
      return;
    }
    this._okButton.visible = false;
    this._prevButton.visible = false;
    this._nextButton.visible = true;
    this._nextButton.enabled = true;
    this._cancelButton.visible = this.DEFAULTCANCELABLE;
    if (this._welcomeText == null) {
      this._welcomeText = this.createNewContentDiv();
      this._welcomeText.innerText = "Yoctopuce is proud to offer you  Yocto-Visualization (for web), an application that  allows to view Yoctopuce sensors data with a simple web browser.\n\nThis wizard will help you to install Yocto-Visualization (for web) version " + constants.buildVersion + " (" + this.ESVersion + ') on a YoctoHub such as YoctoHub-Ethernet, YoctoHub-Wireless, VirtualHub etc..\n\n Click on "next" to start';
      this._container.appendChild(this._welcomeText);
    }
    this._currentHub = null;
    this._currentfs = null;
    this._currentHub_RW_username = "";
    this._currentHub_RW_password = "";
    this._currentHub_RO_username = "";
    this._currentHub_RO_password = "";
    this._currentHub_protocol = "";
    this._currentHub_Addr = "";
    this._currentHub_port = "";
    this._currentHub_path = "";
    let tabIndex = 1;
    this._nextButton.tabIndex = tabIndex++;
    if (this.DEFAULTINTIALFOCUS)
      this._nextButton.focus();
    this._welcomeText.style.display = "";
  }
  showEnterHubAddr(visible, goingback) {
    if (!visible) {
      if (this._hubAddr != null)
        this._hubAddr.style.display = "none";
      return;
    }
    if (this._hubAddr == null) {
      this._hubAddr = this.createNewContentDiv();
      let p = document.createElement("P");
      p.innerText = "Enter the address of the hub you want to install Yocto-Visualization on. This address must be reacheable from your web browser.";
      this._hubAddr.appendChild(p);
      let Table = document.createElement("TABLE");
      Table.style.fontSize = "smaller";
      let Row = document.createElement("TR");
      let TD1 = document.createElement("TD");
      TD1.innerText = "Hub address:";
      TD1.style.whiteSpace = "normal";
      Row.appendChild(TD1);
      let TD2 = document.createElement("TD");
      TD2.style.whiteSpace = "normal";
      this._protocolInput = document.createElement("SELECT");
      let httpopt1 = document.createElement("OPTION");
      httpopt1.text = "http://";
      httpopt1.value = YV4W_installer.HTTP;
      this._protocolInput.add(httpopt1);
      let httpopt2 = document.createElement("OPTION");
      httpopt2.text = "https://";
      httpopt2.value = YV4W_installer.HTTPS;
      this._protocolInput.add(httpopt2);
      this._protocolInput.value = this.DEFAULT_PROTOCOL;
      this._protocolInput.addEventListener("change", () => {
        if (this._protocolInput != null && this._ipPortInput != null) {
          if (this._protocolInput.value == YV4W_installer.HTTPS && parseInt(this._ipPortInput.value) == 80)
            this._ipPortInput.value = "443";
          if (this._protocolInput.value == YV4W_installer.HTTP && parseInt(this._ipPortInput.value) == 443)
            this._ipPortInput.value = "80";
          if (this._warningRow != null)
            this._warningRow.style.display = this._protocolInput.value == YV4W_installer.HTTP && this.CALLERISHTTPS ? "" : "none";
        }
      });
      TD2.appendChild(this._protocolInput);
      this._ipAddrInput = document.createElement("INPUT");
      this._ipAddrInput.value = this.DEFAULTADDR;
      this._ipAddrInput.size = 34;
      this._ipAddrInput.addEventListener("input", () => {
        this._nextButton.enabled = this._ipAddrInput.value != "" && this._ipPortInput.value != "";
      });
      TD2.appendChild(this._ipAddrInput);
      let span = document.createElement("SPAN");
      span.innerText = ":";
      TD2.appendChild(span);
      this._ipPortInput = document.createElement("INPUT");
      this._ipPortInput.value = this.DEFAULTPORT != "" ? this.DEFAULTPORT : "4444";
      this._ipPortInput.type = "number";
      this._ipPortInput.min = "1";
      this._ipPortInput.max = "65535";
      this._ipPortInput.maxLength = 6;
      this._ipPortInput.style.width = "60px";
      this._ipPortInput.addEventListener("input", () => {
        this._nextButton.enabled = this._ipAddrInput.value != "" && this._ipPortInput.value != "";
      });
      TD2.appendChild(this._ipPortInput);
      Row.appendChild(TD2);
      Table.appendChild(Row);
      this._warningRow = document.createElement("TR");
      TD1 = document.createElement("TD");
      TD1.style.whiteSpace = "normal";
      TD1.style.fontSize = "smaller";
      TD1.innerText = "WARNING: Unless your web browser is configured to accept 'mixed content', trying to establish an HTTP connection from an HTTPS page is likely to fail.";
      TD1.colSpan = 2;
      this._warningRow.style.display = "none";
      this._warningRow.appendChild(TD1);
      Table.appendChild(this._warningRow);
      Row = document.createElement("TR");
      TD1 = document.createElement("TD");
      TD1.style.whiteSpace = "normal";
      TD1.style.paddingTop = "20px";
      TD1.style.paddingBottom = "20px";
      TD1.style.textAlign = "justify";
      TD1.innerText = "On YoctoHubs, protocol is HTTP and port is likely to be 80. On native Virtualhub, protocol is HTTP and port is likely to be 4444. On VirtualHub (for web), the  hub path is mandatory and should be set to your VirtualHub (for web) instance path, protocol and  port can be either HTTP and 80 or HTTPS and 433.";
      TD1.colSpan = 2;
      Row.appendChild(TD1);
      Table.appendChild(Row);
      Row = document.createElement("TR");
      TD1 = document.createElement("TD");
      TD1.style.whiteSpace = "normal";
      TD1.innerText = "Hub path:";
      Row.appendChild(TD1);
      TD2 = document.createElement("TD");
      TD2.style.whiteSpace = "normal";
      this._pathInput = document.createElement("INPUT");
      this._pathInput.value = this.DEFAULTPATH;
      this._pathInput.size = 48;
      TD2.appendChild(this._pathInput);
      Row.appendChild(TD2);
      Table.appendChild(Row);
      this._hubAddr.appendChild(Table);
      this._container.appendChild(this._hubAddr);
    }
    this._hubAddr.style.display = "";
    let tabIndex = 1;
    this._protocolInput.tabIndex = tabIndex++;
    this._ipAddrInput.tabIndex = tabIndex++;
    this._ipPortInput.tabIndex = tabIndex++;
    this._pathInput.tabIndex = tabIndex++;
    this._prevButton.tabIndex = tabIndex++;
    this._nextButton.tabIndex = tabIndex++;
    this._protocolInput.focus();
    this._nextButton.visible = true;
    this._nextButton.enabled = this._ipAddrInput.value != "";
  }
  async showConnectingPanel(visible, goingback) {
    if (!visible) {
      if (this._connectingText != null)
        this._connectingText.style.display = "none";
      return;
    }
    if (this._connectingText == null) {
      this._connectingText = this.createNewContentDiv();
      this._container.appendChild(this._connectingText);
    }
    this.removeCurrentPanelFromHistory();
    this._connectingText.innerText = "Connecting to hub " + this._ipAddrInput.value + ". Please wait...";
    this._connectingText.style.display = "";
    this._nextButton.visible = false;
    this._prevButton.visible = false;
    this._cancelButton.visible = false;
    let IP = this._ipAddrInput.value;
    let port = parseInt(this._ipPortInput.value);
    let protocol = this._protocolInput.value;
    this._currentHubLink_protocol = this._protocolInput.value;
    let RW_username = "";
    let RW_password = "";
    let RO_username = "";
    let RO_password = "";
    if (this._adminNameInput != null)
      RW_username = this._adminNameInput.value;
    if (this._adminPasswordInput != null)
      RW_password = this._adminPasswordInput.value;
    if (this._userNameInput != null)
      RO_username = this._userNameInput.value;
    if (this._userPasswordInput != null)
      RO_password = this._userPasswordInput.value;
    let url = protocol + "://" + IP + ":" + port.toString();
    let HubData = null;
    let serial = "";
    let path = this._pathInput.value;
    if (path != "") {
      if (path.charAt(0) == "/")
        path = path.slice(1);
      url += "/" + path;
    }
    let info = new HubInfo(protocol, IP, port, path, null, null);
    let infoRes = await info.makeRequest();
    if (infoRes !== true) {
      let err = "Failed to connect to the Hub while using the url\n\n" + url + "\n\n";
      let prvmsg = 'Click on the "prev" button,';
      switch (infoRes) {
        case 0:
          err += prvmsg + " and make sure that protocol, address, port and path are correct, and try again.\n\n";
          break;
        case -1:
          err += "(invalid server answer), contact yoctopuce support.";
          break;
        case -2:
          err += prvmsg + " then check path. If path is correct check hub firmware version. This installer doesn't work with versions older that " + this.FIRMWAREMINVERSION + ".";
          break;
        case -3:
          err += "An network error occured, make sure hub address is correct.\n\nAlso connexion migh have been  blocked by your web browser, most likely due to CORS policy.\n\nCheck your browser console (Shift-Control-I on most browsers), if you find an error message about a Cross-Origin Request Blocked over a 404 error, Press '<Prev' and check path carefuly.";
          break;
        case 404:
          err += prvmsg + " make sure the path is correct, and try again.";
          break;
        case 500:
          err += " the hub encountered an interal error (Error 500)";
          break;
        case 503:
          err += " the hub is  not available (Error 503)";
          break;
        case 401:
          err += " Unauthorized access, check server configuration(Error 401)";
          break;
        default:
          err += "server responded with an HTTP error " + infoRes;
          break;
      }
      this.gotoPanel(this.CONNECTIONERROR, err);
      return;
    }
    if (info.serial != "") {
      port = info.port;
      serial = info.serial;
      path = info.path;
      this._currentHub_ReadOnlyProtected = info.userPassword;
    }
    protocol = info.protocol;
    if (info.adminPassword && RW_username == "" && RW_password == "") {
      this.gotoPanel(this.PASSWORDPANEL);
      return;
    }
    await YAPI.DisableExceptions();
    let errmsg = new YErrorMsg();
    if (info.userPassword) {
      let RO_addr = info.get_hubUrl(RO_username, RO_password);
      let RO_res = await YAPI.TestHub(RO_addr, 5e3, errmsg);
      if (RO_res != YAPI.SUCCESS) {
        if (RO_res == YAPI.UNAUTHORIZED) {
          this.gotoPanel(this.PASSWORDPANEL, "ReadOnly test failed, check credentials for read only operations.");
          return;
        } else {
          let err = "Cannot connect to " + url + " : " + errmsg.msg + '.\n\nMake sure the Hub is Up and address is correct, then click the "prev" to try again';
          this.gotoPanel(this.CONNECTIONERROR, err);
          return;
        }
      }
    }
    let addr = info.get_hubUrl(RW_username, RW_password);
    this._applicationURL = IP + ":" + port.toString() + (path != "" ? "/" + path : "");
    let res = await YAPI.TestHub(addr, 5e3, errmsg);
    if (res != YAPI.SUCCESS) {
      if (res == YAPI.UNAUTHORIZED) {
        this.gotoPanel(this.PASSWORDPANEL);
        return;
      } else {
        let err = "Cannot connect to " + url + " : " + errmsg.msg + '.\n\nMake sure the Hub is Up and address is correct, then click the "prev" to try again';
        this.gotoPanel(this.CONNECTIONERROR, err);
        return;
      }
    }
    if (await YAPI.RegisterHub(addr, errmsg) != YAPI.SUCCESS) {
      let err = "Cannot connect to " + IP + " : " + errmsg.msg + '.\nMake sure the Hub is Up and address is correct, then click the "prev" to try again';
      this.gotoPanel(this.CONNECTIONERROR, err);
      return;
    }
    let m = YModule.FirstModule();
    while (m != null) {
      if (await m.get_parentHub() == "") {
        let urlMatch = false;
        let serialMatch = await m.get_serialNumber() == serial;
        if (!serialMatch)
          urlMatch = (await m.get_url()).indexOf(IP + ":" + port.toString()) > 0;
        if (serialMatch || urlMatch) {
          this._currentHub = m;
          this._currentHub_RW_username = RW_username;
          this._currentHub_RW_password = RW_password;
          this._currentHub_protocol = protocol;
          this._currentHub_Addr = IP;
          this._currentHub_port = port.toString();
          this._currentHub_path = path;
          if (await m.isReadOnly()) {
            await YAPI.UnregisterHub(await m.get_url());
            this._currentHub = null;
            this.gotoPanel(this.PASSWORDPANEL, "Write test failed, check credentials for read/write operations.");
          } else {
            this.gotoPanel(this.DESCRIPTIONPANEL);
          }
          return;
        }
      }
      m = m.nextModule();
    }
    this.gotoPanel(this.CONNECTIONERROR, "Internal Error, cannot find Hub after RegisterHub call");
  }
  removeCurrentPanelFromHistory() {
    this._history.pop();
  }
  async showConnectionError(visible, goingback, message) {
    if (!visible) {
      if (this._connectiongError != null)
        this._connectiongError.style.display = "none";
      return;
    }
    if (this._connectiongError == null) {
      this._connectiongError = this.createNewContentDiv();
      this._container.appendChild(this._connectiongError);
    }
    this.removeAllChilds(this._connectiongError);
    let Table = document.createElement("TABLE");
    let Row = document.createElement("TR");
    let TD1 = document.createElement("TD");
    TD1.style.whiteSpace = "normal";
    TD1.innerHTML = ressources.FailedIcon("64", true, false, false, false, "oops");
    Row.appendChild(TD1);
    this._ErrMsgContainer = document.createElement("TD");
    this._ErrMsgContainer.style.whiteSpace = "normal";
    this._ErrMsgContainer.style.textAlign = "justify";
    Row.appendChild(this._ErrMsgContainer);
    Table.appendChild(Row);
    this._connectiongError.appendChild(Table);
    this._ErrMsgContainer.innerText = message;
    this._nextButton.visible = false;
    this._prevButton.visible = true;
    this._cancelButton.visible = this.DEFAULTCANCELABLE;
    this._connectiongError.style.display = "";
    let tabIndex = 1;
    this._prevButton.tabIndex = tabIndex++;
    this._prevButton.focus();
  }
  MakeSureCredentialsAreNotEmpty() {
    if (this._currentHub_ReadOnlyProtected) {
      this._nextButton.enabled = this._userPasswordInput.value != "" && this._userNameInput.value != "";
    } else {
      this._nextButton.enabled = true;
    }
    if (this._adminPasswordInput.value == "" || this._adminNameInput.value == "") {
      this._nextButton.enabled = false;
    }
  }
  showPasswordPanel(visible, goingback, err) {
    if (!visible) {
      if (this._pwdPanel != null)
        this._pwdPanel.style.display = "none";
      return;
    }
    let errmsg = typeof err != "undefined" ? err : "Well, looks like this hub requires some authentication.";
    if (this._history[this._history.length - 2] == this.PASSWORDPANEL) {
      errmsg = "Invalid credentials. " + errmsg;
      this.removeCurrentPanelFromHistory();
    }
    if (this._pwdPanel == null) {
      this._pwdPanel = this.createNewContentDiv();
      this._connectionErrorMsg = document.createElement("P");
      this._connectionErrorMsg.style.marginTop = "0px";
      this._pwdPanel.appendChild(this._connectionErrorMsg);
      let Table = document.createElement("TABLE");
      let Row = document.createElement("TR");
      let TD1 = document.createElement("TD");
      TD1.style.whiteSpace = "normal";
      TD1.innerText = "Enter read/write credentials below, these are required for the installation but won't be saved in Yocto-Visualization's configuration.";
      TD1.style.fontSize = "smaller";
      TD1.colSpan = 4;
      Row.appendChild(TD1);
      Table.appendChild(Row);
      Row = document.createElement("TR");
      TD1 = document.createElement("TD");
      TD1.style.whiteSpace = "normal";
      TD1.innerText = "Username:";
      TD1.style.borderLeft = "20px solid transparent";
      TD1.style.fontSize = "smaller";
      Row.appendChild(TD1);
      let TD2 = document.createElement("TD");
      TD2.style.whiteSpace = "normal";
      TD2.style.fontSize = "smaller";
      this._adminNameInput = document.createElement("INPUT");
      this._adminNameInput.size = 12;
      this._adminNameInput.addEventListener("input", () => {
        this.MakeSureCredentialsAreNotEmpty();
      });
      TD2.appendChild(this._adminNameInput);
      Row.appendChild(TD2);
      let TD3 = document.createElement("TD");
      TD3.style.whiteSpace = "normal";
      TD3.innerText = "Password:";
      TD3.style.fontSize = "smaller";
      Row.appendChild(TD3);
      let TD4 = document.createElement("TD");
      TD4.style.whiteSpace = "normal";
      this._adminPasswordInput = document.createElement("INPUT");
      this._adminPasswordInput.type = "password";
      this._adminPasswordInput.size = 12;
      this._adminPasswordInput.addEventListener("input", () => {
        this.MakeSureCredentialsAreNotEmpty();
      });
      TD4.appendChild(this._adminPasswordInput);
      TD4.style.fontSize = "smaller";
      Row.appendChild(TD4);
      this._adminNameInput.value = this.DEFAULTUSER;
      this._adminPasswordInput.value = this.DEFAULTPWD;
      Table.appendChild(Row);
      let userRow1 = document.createElement("TR");
      TD1 = document.createElement("TD");
      TD1.style.whiteSpace = "normal";
      TD1.innerText = "\n\nEnter read-only credentials below, these will be saved in the configuration";
      TD1.style.fontSize = "smaller";
      TD1.colSpan = 4;
      userRow1.appendChild(TD1);
      Table.appendChild(userRow1);
      let userRow2 = document.createElement("TR");
      TD1 = document.createElement("TD");
      TD1.style.whiteSpace = "normal";
      TD1.innerText = "Username:";
      TD1.style.borderLeft = "20px solid transparent";
      TD1.style.fontSize = "smaller";
      userRow2.appendChild(TD1);
      TD2 = document.createElement("TD");
      TD2.style.whiteSpace = "normal";
      TD2.style.fontSize = "smaller";
      this._userNameInput = document.createElement("INPUT");
      this._userNameInput.size = 12;
      this._userNameInput.addEventListener("input", () => {
        this.MakeSureCredentialsAreNotEmpty();
      });
      TD2.appendChild(this._userNameInput);
      userRow2.appendChild(TD2);
      TD3 = document.createElement("TD");
      TD3.style.whiteSpace = "normal";
      TD3.innerText = "Password:";
      TD3.style.fontSize = "smaller";
      userRow2.appendChild(TD3);
      TD4 = document.createElement("TD");
      TD4.style.whiteSpace = "normal";
      this._userPasswordInput = document.createElement("INPUT");
      this._userPasswordInput.type = "password";
      this._userPasswordInput.size = 12;
      this._userPasswordInput.addEventListener("input", () => {
        this.MakeSureCredentialsAreNotEmpty();
      });
      TD4.appendChild(this._userPasswordInput);
      TD4.style.fontSize = "smaller";
      userRow2.appendChild(TD4);
      this._userNameInput.value = this.DEFAULTUSER;
      this._userPasswordInput.value = this.DEFAULTPWD;
      Table.appendChild(userRow2);
      Table.style.marginTop = "0px";
      Table.style.marginBottom = "20px";
      this._pwdPanel.appendChild(Table);
      let userCredVisible = "";
      if (!this._currentHub_ReadOnlyProtected) {
        userCredVisible = "none";
        this._userPasswordInput.value = "";
        this._userNameInput.value = "";
      }
      userRow1.style.display = userCredVisible;
      userRow2.style.display = userCredVisible;
      let p = document.createElement("P");
      p.innerText = 'Note: On YoctoHubs and VirtualHub, username is either "user" for readonly or "admin" for read/write. Only ready-only credentials (if any) will saved in the configuration as Yocto-Visualization will ask for read/write credentials when saving, if needed.';
      p.style.fontSize = "smaller";
      this._pwdPanel.appendChild(p);
      this._container.appendChild(this._pwdPanel);
    }
    this._connectionErrorMsg.innerText = errmsg;
    this._nextButton.visible = true;
    this._prevButton.visible = true;
    this._cancelButton.visible = this.DEFAULTCANCELABLE;
    this._pwdPanel.style.display = "";
    let tabIndex = 1;
    this._adminNameInput.tabIndex = tabIndex++;
    this._adminPasswordInput.tabIndex = tabIndex++;
    this._userNameInput.tabIndex = tabIndex++;
    this._userPasswordInput.tabIndex = tabIndex++;
    this._prevButton.tabIndex = tabIndex++;
    this._nextButton.tabIndex = tabIndex++;
    this._adminNameInput.focus();
    this.MakeSureCredentialsAreNotEmpty();
  }
  createTextRow(caption, value) {
    let Row = document.createElement("TR");
    let TD1 = document.createElement("TD");
    TD1.style.whiteSpace = "normal";
    TD1.style.whiteSpace = "nowrap";
    TD1.innerText = caption;
    Row.appendChild(TD1);
    let TD2 = document.createElement("TD");
    TD2.style.whiteSpace = "normal";
    TD2.innerText = value;
    Row.appendChild(TD2);
    return Row;
  }
  async showHubDescription(visible, goingback) {
    if (!visible) {
      if (this._descPanel != null)
        this._descPanel.style.display = "none";
      return;
    }
    if (this._descPanel == null) {
      this._descPanel = this.createNewContentDiv();
      this._container.appendChild(this._descPanel);
    }
    if (!goingback) {
      this.removeAllChilds(this._descPanel);
      this._alreadyInstalled = false;
      let p = document.createElement("P");
      p.innerText = "Sucessfully connected to Hub " + this._ipAddrInput.value;
      this._descPanel.appendChild(p);
      let m = this._currentHub;
      let Table = document.createElement("TABLE");
      Table.style.marginTop = "20px";
      Table.style.marginBottom = "20px";
      let serial = await m.get_serialNumber();
      let firmware = await m.get_firmwareRelease();
      Table.appendChild(this.createTextRow("Model:", await m.get_productName()));
      Table.appendChild(this.createTextRow("Serial:", serial));
      Table.appendChild(this.createTextRow("Firmware:", firmware));
      let tmp = firmware.lastIndexOf(".");
      if (tmp >= 0)
        firmware = firmware.substr(tmp + 1);
      this._instancesFiles = [];
      let freespace = 0;
      this._instancesFiles = [];
      this._currentfs = null;
      let error = "";
      if (firmware.indexOf("-") < 0 && parseInt(firmware) < this.FIRMWAREMINVERSION) {
        error = "Hub firmware is too old for Yocto-Visualization to run properly. You need at least version " + this.FIRMWAREMINVERSION;
        this._nextButton.enabled = false;
      }
      if (error == "") {
        let ids = await m.get_functionIds("Files");
        if (ids.length > 0) {
          this._currentfs = await YFiles.FindFiles(serial + "." + ids[0]);
          freespace = Math.floor(await this._currentfs.get_freeSpace() / 1024);
          this._instancesFiles = await this._currentfs.get_list("yv4web*");
          Table.appendChild(this.createTextRow("Free space:", freespace.toString() + "K"));
          this._nextButton.enabled = true;
          if (freespace < 200) {
            error = "Not enough free space on device, please make sure there is at least 200K available.";
            this._nextButton.enabled = false;
          }
        } else {
          error = "No filesystem found on hub. On VirtualHub, the filesystem feature needs to be explicitely enabled at startup with the -F flag.";
        }
      }
      if (error != "") {
        Table.appendChild(this.createTextRow(" ", " "));
        let Row = document.createElement("TR");
        let TD1 = document.createElement("TD");
        TD1.style.whiteSpace = "normal";
        TD1.innerHTML = ressources.FailedIcon("32", true, false, false, false, "oops");
        TD1.style.textAlign = "right";
        Row.appendChild(TD1);
        let TD2 = document.createElement("TD");
        TD2.style.whiteSpace = "normal";
        TD2.style.fontSize = "smaller";
        TD2.innerText = error;
        Row.appendChild(TD2);
        Table.appendChild(Row);
        this._nextButton.enabled = false;
      }
      this._descPanel.appendChild(Table);
      if (this._instancesFiles.length > 0) {
        let p2 = document.createElement("P");
        p2.innerText = "Yocto-Visualization (for web) appears to be already installed on this hub. Click on next to modify this installation.";
        this._descPanel.appendChild(p2);
        this._alreadyInstalled = true;
      }
    }
    this._descPanel.style.display = "";
    this._nextButton.visible = true;
    this._prevButton.visible = true;
    this._cancelButton.visible = this.DEFAULTCANCELABLE;
    let tabIndex = 1;
    this._prevButton.tabIndex = tabIndex++;
    this._nextButton.tabIndex = tabIndex++;
    this._nextButton.focus();
  }
  async loadWebPagesList(filenameDesc) {
    this._webPageinstances = [];
    let webFiles = await this._currentfs.get_list("*");
    for (let i = 0; i < webFiles.length; i++) {
      let filename = await webFiles[i].get_name();
      if (filename.indexOf(".html") >= 0) {
        if (filenameDesc != null) {
          filenameDesc.innerText = "Now downloading " + filename + "...";
        }
        let contents = await this._currentfs.download(filename);
        if (filename.slice(-3) == ".gz") {
          contents = Pako_Inflate.ungzip(contents, {});
        }
        let contentsStr = YAPI.imm_bin2str(contents);
        if (contentsStr.indexOf("window.runYV()") > 0) {
          this._webPageinstances.push(new pageInstance(filename, contents));
        }
      }
    }
  }
  async showModifyInstallPanel(visible, goingback) {
    if (!visible) {
      if (this._modifyInstallPanel != null)
        this._modifyInstallPanel.style.display = "none";
      return;
    }
    this._nextButton.visible = false;
    this._prevButton.visible = false;
    this._cancelButton.visible = false;
    if (this._modifyInstallPanel == null) {
      this._modifyInstallPanel = this.createNewContentDiv();
      this._container.appendChild(this._modifyInstallPanel);
    }
    if (!goingback) {
      this.removeAllChilds(this._modifyInstallPanel);
      this._jsCodeinstances = [];
      this._webPageinstances = [];
      let p = document.createElement("P");
      p.innerText = "Please wait, downloading and parsing files from the hub ";
      this._modifyInstallPanel.appendChild(p);
      this._modifyInstallPanel.style.display = "";
      let files = document.createElement("P");
      files.innerText = "";
      let filenameDesc = document.createElement("P");
      filenameDesc.style.fontSize = "smaller";
      this._modifyInstallPanel.appendChild(filenameDesc);
      for (let i = 0; i < this._instancesFiles.length; i++) {
        let filename = await this._instancesFiles[i].get_name();
        filenameDesc.innerText = "Now downloading " + filename + "...";
        files.innerText = filename;
        let contentsStr = "";
        let contents = await this._currentfs.download(filename);
        if (filename.slice(-3) == ".gz") {
          contents = Pako_Inflate.ungzip(contents, {});
        }
        contentsStr = YAPI.imm_bin2str(contents);
        let esTarget = "";
        let version = "";
        let readonlyVersion = true;
        let p2 = contentsStr.indexOf("*/");
        if (p2 > 0) {
          let firstLine = contentsStr.slice(0, p2);
          let p1 = firstLine.indexOf("(");
          let p22 = firstLine.indexOf(")");
          if (p1 > 0 && p22 > p1) {
            let tokens = firstLine.slice(p1 + 1, p22).split(" ");
            if (tokens.length > 0)
              esTarget = tokens[0];
            if (tokens.length > 1)
              readonlyVersion = tokens[1] != "full";
            if (tokens.length > 2)
              version = tokens[2];
          }
        }
        this._jsCodeinstances.push(new codeInstance(filename, esTarget, version, readonlyVersion));
      }
      await this.loadWebPagesList(filenameDesc);
      filenameDesc.style.display = "none";
      p.innerText = "What would you like to do ?";
      let uninstallLegend = document.createElement("span");
      uninstallLegend.innerText = "Uninstall / delete all Yocto-Visualization (for web) related files\n\n";
      this._uninstallOpt = document.createElement("input");
      this._uninstallOpt.setAttribute("type", "radio");
      this._uninstallOpt.setAttribute("name", "installType");
      this._modifyInstallPanel.appendChild(this._uninstallOpt);
      this._modifyInstallPanel.appendChild(uninstallLegend);
      let BuildsFound = {};
      for (let i = 0; i < this._jsCodeinstances.length; i++) {
        BuildsFound[this._jsCodeinstances[i].version] = 1;
      }
      let BuildsFoundList = "";
      for (let key in BuildsFound) {
        if (BuildsFound.hasOwnProperty(key)) {
          BuildsFoundList += (BuildsFoundList != "" ? ", " : "") + key;
        }
      }
      let updateLegend = document.createElement("span");
      updateLegend.innerText = "Update all from " + BuildsFoundList + " to " + constants.buildVersion + "\n\n";
      this._updateOpt = document.createElement("input");
      this._updateOpt.setAttribute("type", "radio");
      this._updateOpt.setAttribute("name", "installType");
      this._modifyInstallPanel.appendChild(this._updateOpt);
      this._modifyInstallPanel.appendChild(updateLegend);
      let addInstanceLegend = document.createElement("span");
      addInstanceLegend.innerText = "Add a new instance \n\n";
      this._addInstanceOpt = document.createElement("input");
      this._addInstanceOpt.setAttribute("type", "radio");
      this._addInstanceOpt.setAttribute("name", "installType");
      this._modifyInstallPanel.appendChild(this._addInstanceOpt);
      this._modifyInstallPanel.appendChild(addInstanceLegend);
      let modInstanceLegend = document.createElement("span");
      modInstanceLegend.innerText = "Modify or delete existing instances \n\n";
      this._modInstanceOpt = document.createElement("input");
      this._modInstanceOpt.setAttribute("type", "radio");
      this._modInstanceOpt.setAttribute("name", "installType");
      this._modifyInstallPanel.appendChild(this._modInstanceOpt);
      this._modifyInstallPanel.appendChild(modInstanceLegend);
      if (!this._uninstallOpt.checked && !this._updateOpt.checked && !this._addInstanceOpt.checked && !this._modInstanceOpt.checked) {
        this._updateOpt.checked = true;
      }
    }
    this._modifyInstallPanel.style.display = "";
    this._nextButton.enabled = true;
    this._prevButton.enabled = true;
    this._nextButton.visible = true;
    this._prevButton.visible = true;
    this._cancelButton.visible = this.DEFAULTCANCELABLE;
    let tabIndex = 1;
    this._uninstallOpt.tabIndex = tabIndex++;
    this._updateOpt.tabIndex = tabIndex++;
    this._addInstanceOpt.tabIndex = tabIndex++;
    this._modInstanceOpt.tabIndex = tabIndex++;
    this._prevButton.tabIndex = tabIndex++;
    this._nextButton.tabIndex = tabIndex++;
    this._nextButton.focus();
  }
  async showModInstancesPanel(visible, goingback) {
    if (!visible) {
      if (this._modInstancesPanel != null)
        this._modInstancesPanel.style.display = "none";
      return;
    }
    if (this._modInstancesPanel == null) {
      this._modInstancesPanel = this.createNewContentDiv();
      this._container.appendChild(this._modInstancesPanel);
    }
    let tabIndex = 1;
    if (!goingback) {
      this.removeAllChilds(this._modInstancesPanel);
      let p = document.createElement("P");
      this._modInstancesPanel.appendChild(p);
      p.innerText = "Here is a list of installed instances. Select an action for each one, then click on next to have them applied.";
      let table = document.createElement("Table");
      table.style.marginLeft = "20px";
      for (let i = 0; i < this._webPageinstances.length; i++) {
        let tr = document.createElement("TR");
        let td = document.createElement("TD");
        td.style.whiteSpace = "normal";
        td.innerText = this._webPageinstances[i].http_filename + (this._webPageinstances[i].compressed ? "[.gz]" : "");
        tr.appendChild(td);
        let td2 = document.createElement("TD");
        td2.style.whiteSpace = "normal";
        td2.style.paddingLeft = "10px";
        let chooser = document.createElement("SELECT");
        chooser.tabIndex = tabIndex++;
        let opt = document.createElement("OPTION");
        opt.tabIndex = tabIndex++;
        opt.text = "Do Nothing";
        opt.value = this._MODIFYNOTHING.toString();
        chooser.add(opt);
        let opt2 = document.createElement("OPTION");
        if (this._webPageinstances[i].compressed) {
          opt2.text = "Uncompress instance file";
          opt2.value = this._MODIFYUNCOMPRESS.toString();
        } else {
          opt2.text = "Compress instance file";
          opt2.value = this._MODIFYCOMPRESS.toString();
        }
        chooser.add(opt2);
        let opt3 = document.createElement("OPTION");
        if (this._webPageinstances[i].readonly) {
          opt3.text = "Allow read/write";
          opt3.value = this._MODIFYMAKEREADWRITE.toString();
        } else {
          opt3.text = "Make read only";
          opt3.value = this._MODIFYMAKEREADONLY.toString();
        }
        chooser.add(opt3);
        let opt4 = document.createElement("OPTION");
        if (this._webPageinstances[i].useMinified) {
          opt4.text = "Use human readable JS module";
          opt4.value = this._MODIFYUSEPLAIN.toString();
        } else {
          opt4.text = "Use minified JS module";
          opt4.value = this._MODIFYUSEMINIFIED.toString();
        }
        chooser.add(opt4);
        let opt5 = document.createElement("OPTION");
        opt5.text = "Delete (cannot be reverted)";
        opt5.value = this._MODIFYDELETE.toString();
        chooser.add(opt5);
        let index = i;
        chooser.addEventListener("change", () => {
          this._webPageinstances[index].action = Number(chooser.value);
        });
        td2.appendChild(chooser);
        tr.appendChild(td2);
        table.appendChild(tr);
      }
      this._modInstancesPanel.appendChild(table);
      let p2 = document.createElement("P");
      this._removeUnusedJs = document.createElement("INPUT");
      this._removeUnusedJs.tabIndex = tabIndex++;
      this._removeUnusedJs.type = "checkbox";
      this._removeUnusedJs.checked = true;
      p2.appendChild(this._removeUnusedJs);
      let span = document.createElement("SPAN");
      span.innerText = "Remove unused Yocto-Visualization (for web) JS module files";
      p2.appendChild(span);
      this._modInstancesPanel.appendChild(p2);
      this._prevButton.tabIndex = tabIndex++;
      this._nextButton.tabIndex = tabIndex++;
      this._nextButton.focus();
    }
    this._modInstancesPanel.style.display = "";
  }
  async showCustomFilesPanel(visible, goingback) {
    if (!visible) {
      if (this._customFilesPanel != null)
        this._customFilesPanel.style.display = "none";
      return;
    }
    if (this._customFilesPanel == null) {
      this._customFilesPanel = this.createNewContentDiv();
      this._container.appendChild(this._customFilesPanel);
    }
    if (!goingback) {
      this.removeAllChilds(this._customFilesPanel);
      let p = document.createElement("P");
      p.innerText = this._plannedaction == this.ACTIONINSTALL ? "Optionnaly, you can customize your Yocto-Visualization (for web) installation by providing some files" : "Optionnaly, you can customize your new instance by providing some files";
      this._customFilesPanel.appendChild(p);
      let Table = document.createElement("TABLE");
      Table.style.fontSize = "smaller";
      Table.style.marginTop = "20px";
      Table.style.marginBottom = "20px";
      let Row;
      let TD1;
      let TD2;
      Row = document.createElement("TR");
      TD1 = document.createElement("TD");
      TD1.style.whiteSpace = "normal";
      TD1.colSpan = 2;
      TD1.style.textAlign = "justify";
      TD1.innerText = 'You can choose an initial XML configuration file. You can get a XML configuration file from a Yocto-Visualization (for web) instance in the  "Global configulation" panel. You can also use a config.xml file from the Yocto-Visualization native version.';
      Row.appendChild(TD1);
      Table.appendChild(Row);
      Row = document.createElement("TR");
      TD1 = document.createElement("TD");
      TD1.style.whiteSpace = "normal";
      TD1.innerText = "Config file:";
      Row.appendChild(TD1);
      TD2 = document.createElement("TD");
      TD2.style.whiteSpace = "normal";
      this._configFileInput = document.createElement("INPUT");
      this._configFileInput.type = "file";
      this._configFileInput.accept = ".xml";
      TD2.appendChild(this._configFileInput);
      Row.style.marginBottom = "10px";
      Row.appendChild(TD2);
      Table.appendChild(Row);
      Row = document.createElement("TR");
      TD1 = document.createElement("TD");
      TD1.style.whiteSpace = "normal";
      TD1.colSpan = 2;
      TD1.style.textAlign = "justify";
      TD1.innerText = "\nYou can choose a container HTML file. Note: if this file relies on local dependencies such as images or CSS files, you'll have to upload them on the hub yourself.";
      Row.appendChild(TD1);
      Table.appendChild(Row);
      this._customFilesPanel.appendChild(Table);
      Row = document.createElement("TR");
      TD1 = document.createElement("TD");
      TD1.style.whiteSpace = "normal";
      TD1.innerText = "HTML file:";
      Row.appendChild(TD1);
      TD2 = document.createElement("TD");
      TD2.style.whiteSpace = "normal";
      this._webPageInput = document.createElement("INPUT");
      this._webPageInput.type = "file";
      this._webPageInput.accept = ".html";
      TD2.appendChild(this._webPageInput);
      Row.appendChild(TD2);
      Table.appendChild(Row);
    }
    this._customFilesPanel.style.display = "";
    this._nextButton.enabled = true;
    this._prevButton.enabled = true;
    this._nextButton.visible = true;
    this._prevButton.visible = true;
    this._cancelButton.visible = this.DEFAULTCANCELABLE;
    let tabIndex = 1;
    this._webPageInput.tabIndex = tabIndex++;
    this._configFileInput.tabIndex = tabIndex++;
    this._prevButton.tabIndex = tabIndex++;
    this._nextButton.tabIndex = tabIndex++;
    this._nextButton.focus();
  }
  async showOptionsPanel(visible, goingback) {
    if (!visible) {
      if (this._optionsPanel != null)
        this._optionsPanel.style.display = "none";
      return;
    }
    if (this._optionsPanel == null) {
      this._optionsPanel = this.createNewContentDiv();
      let p = document.createElement("P");
      p.innerText = this._plannedaction == this.ACTIONINSTALL ? "You can also customize the installation behavior" : "You can also customize this new instance behavior";
      this._optionsPanel.appendChild(p);
      p = document.createElement("P");
      p.style.fontSize = "smaller";
      p.style.marginBottom = "0px";
      p.style.marginTop = "0px";
      this._fileprefixInput = document.createElement("INPUT");
      let presetname = this.DEFAULTFILEPREFIX;
      let n = 1;
      let checkgain = false;
      do {
        checkgain = false;
        for (let i = 0; i < this._webPageinstances.length; i++) {
          if (presetname + this.TARGETEXTENSION == this._webPageinstances[i].http_filename) {
            n++;
            presetname = this.DEFAULTFILEPREFIX + "(" + n.toString() + ")";
            checkgain = true;
          }
        }
      } while (checkgain);
      this._fileprefixInput.value = presetname;
      this._fileprefixInput.maxLength = 10;
      this._fileprefixInput.size = 10;
      let span = document.createElement("SPAN");
      span.innerText = "Set the instance name to : ";
      p.appendChild(span);
      p.appendChild(this._fileprefixInput);
      this._optionsPanel.appendChild(p);
      p = document.createElement("P");
      p.style.fontSize = "smaller";
      p.style.marginBottom = "0px";
      p.style.marginTop = "0px";
      this._useFullVersionInput = document.createElement("INPUT");
      this._useFullVersionInput.type = "checkbox";
      p.appendChild(this._useFullVersionInput);
      span = document.createElement("SPAN");
      span.innerText = this._plannedaction == this.ACTIONINSTALL ? "Install the non-minified version (easier to debug)" : "Use the non-minified version (easier to debug)";
      p.appendChild(span);
      this._optionsPanel.appendChild(p);
      p = document.createElement("P");
      p.style.fontSize = "smaller";
      p.style.marginBottom = "0px";
      p.style.marginTop = "0px";
      this._makeDefaultInput = document.createElement("INPUT");
      this._makeDefaultInput.type = "checkbox";
      p.appendChild(this._makeDefaultInput);
      span = document.createElement("SPAN");
      span.innerText = this._plannedaction == this.ACTIONINSTALL ? "Make Yocto-Visualization (for web) the hub's default page" : "Make this instance the hub's default page";
      p.appendChild(span);
      this._optionsPanel.appendChild(p);
      p = document.createElement("P");
      p.style.fontSize = "smaller";
      p.style.marginBottom = "0px";
      p.style.marginTop = "0px";
      this._useReadOnlyInput = document.createElement("INPUT");
      this._useReadOnlyInput.type = "checkbox";
      p.appendChild(this._useReadOnlyInput);
      span = document.createElement("SPAN");
      span.innerText = this._plannedaction == this.ACTIONINSTALL ? "Make the install read-only" : "Make this instance read-only";
      p.appendChild(span);
      this._optionsPanel.appendChild(p);
      if (this._jsCodeinstances.length > 0) {
        this._useReadOnlyInput.checked = this._jsCodeinstances[0].readonly;
        this._useFullVersionInput.checked = !this._jsCodeinstances[0].minified;
      }
      p = document.createElement("P");
      p.innerText = 'Click on "Next" button to start the installation';
      this._optionsPanel.appendChild(p);
      this._container.appendChild(this._optionsPanel);
    }
    this._nextButton.visible = true;
    this._prevButton.visible = true;
    this._cancelButton.visible = this.DEFAULTCANCELABLE;
    this._optionsPanel.style.display = "";
    let tabIndex = 1;
    this._fileprefixInput.tabIndex = tabIndex++;
    this._useFullVersionInput.tabIndex = tabIndex++;
    this._makeDefaultInput.tabIndex = tabIndex++;
    this._useReadOnlyInput.tabIndex = tabIndex++;
    this._prevButton.tabIndex = tabIndex++;
    this._nextButton.tabIndex = tabIndex++;
    this._nextButton.focus();
  }
  logLine(line) {
    let p = document.createElement("P");
    p.innerText = line + " ";
    p.style.fontSize = "smaller";
    p.style.marginLeft = "10px";
    p.style.marginTop = "0px;";
    p.style.marginBottom = "0px;";
    p.style.paddingTop = "0px;";
    p.style.paddingBottom = "0px;";
    let span = document.createElement("SPAN");
    p.appendChild(span);
    this._runPanel.appendChild(p);
    return span;
  }
  async showRunPanel(visible, goingback) {
    if (!visible) {
      if (this._runPanel != null)
        this._runPanel.style.display = "none";
      return;
    }
    if (this._runPanel == null) {
      this._runPanel = this.createNewContentDiv();
    }
    this.removeAllChilds(this._runPanel);
    this._runPanel.style.display = "";
    let desc = document.createElement("P");
    this._runPanel.appendChild(desc);
    this._container.appendChild(this._runPanel);
    this._nextButton.visible = false;
    this._prevButton.visible = false;
    this._cancelButton.visible = false;
    switch (this._plannedaction) {
      case this.ACTIONINSTALL:
        desc.innerText = "Installing on " + this._currentHub_Addr + "... please wait.";
        try {
          await this.install((line) => {
            return this.logLine(line);
          });
        } catch (e) {
          this.gotoPanel(this.CONNECTIONERROR, "Installation failed with an internal error : " + e.toString() + "\n\nFeel free to contact Yoctopuce support.");
        }
        break;
      case this.ACTIONADDINSTANCE:
        desc.innerText = "Creating new instance  on " + this._currentHub_Addr + "... please wait.";
        try {
          await this.install((line) => {
            return this.logLine(line);
          });
        } catch (e) {
          this.gotoPanel(this.CONNECTIONERROR, "Instance creation failed with an internal error : " + e.toString() + "\n\nFeel free to contact Yoctopuce support.");
        }
        break;
      case this.ACTIONUNINSTALL:
        desc.innerText = "Uninstalling everything from " + this._currentHub_Addr + "... please wait.";
        try {
          await this.uninstall((line) => {
            return this.logLine(line);
          });
        } catch (e) {
          this.gotoPanel(this.CONNECTIONERROR, "Installation failed with an internal error : " + e.toString() + "\n\nFeel free to contact Yoctopuce support.");
        }
        break;
      case this.ACTIONUPDATE:
        desc.innerText = "Updating js files on " + this._currentHub_Addr + "... please wait.";
        try {
          await this.upgrade((line) => {
            return this.logLine(line);
          });
        } catch (e) {
          this.gotoPanel(this.CONNECTIONERROR, "Update failed with an internal error : " + e.toString() + "\n\nFeel free to contact Yoctopuce support.");
        }
        break;
      case this.ACTIONMODINSTANCE:
        desc.innerText = "Modifying instances on " + this._currentHub_Addr + "... please wait.";
        try {
          await this.modifyInstances((line) => {
            return this.logLine(line);
          });
        } catch (e) {
          this.gotoPanel(this.CONNECTIONERROR, "Instances modification failed with an internal error : " + e.toString() + "\n\nFeel free to contact Yoctopuce support.");
        }
        break;
    }
  }
  checkHTMLfile(htmlData, errmsg) {
    let upper = htmlData.toUpperCase();
    if (upper.indexOf("<HTML") < 0) {
      errmsg.msg = "Provided web page is not a proper HTML file: no HTML tag";
      return false;
    }
    if (upper.indexOf("</BODY>") < 0) {
      errmsg.msg = "Provided web page has an unexpected structure: no closing BODY tag";
      return false;
    }
    return true;
  }
  checkConfigfile(xmlData, errmsg) {
    let parser = new DOMParser();
    let doc = parser.parseFromString(xmlData, "application/xml");
    let root = null;
    doc.childNodes.forEach((node) => {
      if (node.nodeName.toUpperCase() == "ROOT" && root == null)
        root = node;
    });
    if (root == null) {
      errmsg.msg = "Provided config XML file is not a proper YoctoVisualization 2 config file. Unable to find ROOT node, either the root node does not exists or the file caused an XML parse error.";
      return false;
    }
    let rootNode = new YXmlNode(root);
    let attributes = rootNode.Attributes;
    if (!attributes.hasOwnProperty("version")) {
      errmsg.msg = "Provided  XML config file is not a proper Yocto-Visualization 2 config file (No ROOT Version attribute)";
      return false;
    }
    if (parseFloat(attributes["version"]) < 2) {
      errmsg.msg = "Provided XML config file is not a proper Yocto-Visualization 2 config file (at least Version 2.0 is required)";
      return false;
    }
    return true;
  }
  findChild(parent, name) {
    let res = null;
    parent.childNodes.forEach((node) => {
      if (node.nodeName == name) {
        res = node;
        return;
      }
    });
    return res;
  }
  patchConfigFile(xmlData) {
    let startTag = "<Hubs>";
    let endTag = "</Hubs>";
    let parser = new DOMParser();
    let doc = parser.parseFromString(xmlData, "application/xml");
    let rootNode = this.findChild(doc, "ROOT");
    if (rootNode == null)
      throw "No root node in config file.";
    let configNode = this.findChild(rootNode, "Config");
    if (configNode == null)
      throw "No config node in config file.";
    let Hubs = this.findChild(configNode, "Hubs");
    let HubSection;
    if (Hubs == null) {
      HubSection = startTag + "\n" + this.getHubConfig() + "\n" + endTag + "\n";
      xmlData = xmlData.replace("<Config>", "<Config>\n" + HubSection);
    } else {
      let list = Hubs.childNodes;
      let sourceHubFound = false;
      HubSection = startTag + "\n";
      for (let i = 0; i < list.length; i++) {
        if (list[i].nodeName == "Hub") {
          let node = new YXmlNode(list[i]);
          let attributes = node.Attributes;
          let addr = attributes.hasOwnProperty("addr") ? attributes["addr"] : "";
          let port = attributes.hasOwnProperty("port") ? attributes["port"] : "80";
          let protocol = attributes.hasOwnProperty("protocol") ? attributes["protocol"] : "";
          let path = attributes.hasOwnProperty("path") ? attributes["path"] : "";
          let username = attributes.hasOwnProperty("user") ? attributes["user"] : "";
          let password = attributes.hasOwnProperty("password") ? attributes["password"] : "";
          if (!sourceHubFound && addr == this._currentHub_Addr && port == this._currentHub_port && path == this._currentHub_path) {
            sourceHubFound = true;
            HubSection += "    " + this.getHubConfig() + "\n";
          } else {
            HubSection += "    " + this.createHubRecord(protocol, addr, port, path, username, password, true) + "\n";
          }
        }
      }
      if (!sourceHubFound)
        HubSection += "    " + this.getHubConfig() + "\n";
      HubSection += "  ";
      let indexStart = xmlData.indexOf(startTag);
      let indexStop = xmlData.indexOf(endTag);
      if (indexStart < 0)
        throw "Cannot locate Hubs start tag in provided  config file";
      if (indexStop < 0)
        throw "Cannot locate Hubs end tag in provided  config file";
      xmlData = xmlData.substr(0, indexStart) + HubSection + xmlData.substr(indexStop);
    }
    return xmlData;
  }
  createHubRecord(protocol, addr, port, path, username, password, removable) {
    let res = '<Hub protocol="' + constants.XMLquote(protocol) + '" addr="' + constants.XMLquote(addr) + '" port="' + constants.XMLquote(port) + '"';
    if (path != "")
      res += ' path="' + constants.XMLquote(path) + '"';
    if (username != "")
      res += ' user="' + constants.XMLquote(username) + '"';
    if (password != "")
      res += ' password="' + constants.XMLquote(password) + '"';
    if (!removable)
      res += ' removable="FALSE"';
    res += "/>";
    return res;
  }
  getHubConfig() {
    let username = "";
    let password = "";
    if (this._currentHub_ReadOnlyProtected) {
      username = this._userNameInput.value;
      password = Hub.encryptPassword(this._userPasswordInput.value);
    }
    return this.createHubRecord(this._currentHub_protocol, this._currentHub_Addr, this._currentHub_port, this._currentHub_path, username, password, false);
  }
  getSeedCode(configfile, readonly, minified) {
    let res = '\n<script type="module">\n';
    if (configfile == null)
      configfile = '<?xml version="1.0" ?><ROOT version="2.1"><Config><Hubs>' + this.getHubConfig() + "</Hubs></Config></ROOT>\n";
    let filename = "yv4web-" + (readonly ? "readonly" : "full") + (minified ? ".min" : "") + ".js";
    res += ' import { YWebPage, YoctoHubFileHandler }  from "./' + filename + '";\n';
    res += " window.runYV= async ()=>{";
    res += " let filehandler = await YoctoHubFileHandler.start(";
    if (configfile != null)
      res += JSON.stringify(configfile);
    res += ");\n";
    res += "  YWebPage.run(filehandler.xmlConfigData, filehandler.configChangeCallbackFct";
    if (!readonly)
      res += ",filehandler.saveFct";
    res += ");\n";
    res += "};\n window.runYV();</script>\n";
    res += '<script nomodule="">\n';
    res += `document.write("<p style='font-family: sans-serif; text-align:center'>Yocto-Visualization (for web) cannot run on this browser. Sorry.<br>Consider using a more recent browser, or <a href='https://www.yoctopuce.com/EN/tools.php'>the native version</a>. </p>")
`;
    res += "</script>\n";
    return res;
  }
  defaultHTMLfile(configfile, readonly, minified) {
    return "<!DOCTYPE HTML>\n<HTML lang='en-US'><HEAD>\n<title>\nYocto-Visualization</title>\n" + this.icon + "\n<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no'/></HEAD>\n<BODY>\n</BODY>" + this.getSeedCode(configfile, readonly, minified) + "\n</HTML>\n";
  }
  async uploadWidthProgress(str_path, bin_content, progress) {
    let yreq = await this._currentfs._uploadWithProgress(str_path, bin_content, progress);
    return yreq.errorType;
  }
  async upgrade(log) {
    let install_minified_readonly = false;
    let install_plain_readonly = false;
    let install_minified_readwrite = false;
    let install_plain_readwrite = false;
    for (let i = 0; i < this._jsCodeinstances.length; i++) {
      if (this._jsCodeinstances[i].minified) {
        if (this._jsCodeinstances[i].readonly) {
          install_minified_readonly = true;
        } else {
          install_minified_readwrite = true;
        }
      } else {
        if (this._jsCodeinstances[i].readonly) {
          install_plain_readonly = true;
        } else {
          install_plain_readwrite = true;
        }
      }
    }
    if (install_minified_readonly)
      await this.copyJsCode(log, true, true);
    if (install_plain_readonly)
      await this.copyJsCode(log, true, false);
    if (install_minified_readwrite)
      await this.copyJsCode(log, false, true);
    if (install_plain_readwrite)
      await this.copyJsCode(log, false, false);
    log("Done.");
    setTimeout(() => {
      this.gotoPanel(this.DONEPANEL);
    }, 2e3);
  }
  async syncJsFile(log, required, readonly, minified, removeunused) {
    let jsfile = this.get_js_filename(readonly, minified) + ".gz";
    let exists = await this._currentfs.fileExist(jsfile);
    if (required && !exists)
      await this.copyJsCode(log, readonly, minified);
    if (!required && exists && removeunused) {
      let span = log("Deleting " + jsfile);
      await this._currentfs.remove(jsfile);
      span.innerText = "done.";
    }
  }
  async syncJsFileVersions(log, removeunused) {
    let require_minified_readonly = false;
    let require_plain_readonly = false;
    let require_minified_readwrite = false;
    let require_plain_readwrite = false;
    for (let i = 0; i < this._webPageinstances.length; i++) {
      if (this._webPageinstances[i].useMinified) {
        if (this._webPageinstances[i].readonly) {
          require_minified_readonly = true;
        } else {
          require_minified_readwrite = true;
        }
      } else {
        if (this._webPageinstances[i].readonly) {
          require_plain_readonly = true;
        } else {
          require_plain_readwrite = true;
        }
      }
    }
    await this.syncJsFile(log, require_minified_readonly, true, true, removeunused);
    await this.syncJsFile(log, require_plain_readonly, true, false, removeunused);
    await this.syncJsFile(log, require_minified_readwrite, false, true, removeunused);
    await this.syncJsFile(log, require_plain_readwrite, false, false, removeunused);
  }
  async patchPageInstance(log, page, signature1, replace1, altsignature1, altreplace1, signature2, replace2) {
    let contents = YAPI.imm_bin2str(page.contents);
    let p = contents.indexOf(signature1);
    if (p < 0 && altsignature1 != "") {
      signature1 = altsignature1;
      replace1 = altreplace1;
      p = contents.indexOf(signature1);
    }
    if (p < 0)
      throw "Operation failed: cannot find the [" + signature1 + "] import signature in " + page.fs_filename;
    contents = contents.substr(0, p) + replace1 + contents.substr(p + signature1.length);
    if (signature2 != "") {
      p = contents.indexOf(signature2);
      if (p < 0)
        throw "Operation failed: cannot find the [" + signature2 + "] signature parameter in " + page.fs_filename;
      contents = contents.substr(0, p) + replace2 + contents.substr(p + signature2.length);
    }
    let bincontents = YAPI.imm_str2bin(contents);
    let filename = page.fs_filename;
    if (page.compressed) {
      let status2 = log("Compressing  " + filename);
      bincontents = Pako_Deflate.gzip(bincontents, {level: 9});
      status2.innerText = "done";
    }
    let status = log("Uploading  " + filename + " to hub");
    status.innerText = "0%";
    let success = await this.uploadWidthProgress(filename, bincontents, (curr, total) => {
      status.innerText = Math.round(100 * curr / total).toString() + "%";
    });
    status.innerText = "done";
    if (success != YAPI_SUCCESS)
      throw "Upload failed (Error" + success.toString() + ").";
  }
  async modifyInstances(log) {
    for (let i = 0; i < this._webPageinstances.length; i++) {
      switch (this._webPageinstances[i].action) {
        case this._MODIFYNOTHING:
          break;
        case this._MODIFYDELETE:
          let span = log("Deleting " + this._webPageinstances[i].fs_filename);
          await this._currentfs.remove(this._webPageinstances[i].fs_filename);
          span.innerText = "done.";
          break;
        case this._MODIFYUNCOMPRESS:
          {
            let filename = this._webPageinstances[i].http_filename;
            let status = log("Uploading  " + filename + " to hub");
            status.innerText = "0%";
            let success = await this.uploadWidthProgress(filename, this._webPageinstances[i].contents, (curr, total) => {
              status.innerText = Math.round(100 * curr / total).toString() + "%";
            });
            status.innerText = "done";
            if (success != YAPI_SUCCESS)
              throw "Upload failed! (Error" + success.toString() + ")";
            status = log("Deleting " + this._webPageinstances[i].fs_filename);
            await this._currentfs.remove(this._webPageinstances[i].fs_filename);
            status.innerText = "done.";
          }
          break;
        case this._MODIFYCOMPRESS:
          {
            let filename = this._webPageinstances[i].http_filename + ".gz";
            let status = log("Compressing  " + filename);
            let GZ_data = Pako_Deflate.gzip(this._webPageinstances[i].contents, {level: 9});
            status.innerText = "done";
            status = log("Uploading  " + filename + " to hub");
            status.innerText = "0%";
            let success = await this.uploadWidthProgress(filename, GZ_data, (curr, total) => {
              status.innerText = Math.round(100 * curr / total).toString() + "%";
            });
            status.innerText = "done";
            if (success != YAPI_SUCCESS)
              throw "Upload failed!! (Error" + success.toString() + ")";
            status = log("Deleting " + this._webPageinstances[i].http_filename);
            await this._currentfs.remove(this._webPageinstances[i].http_filename);
            status.innerText = "done.";
          }
          break;
        case this._MODIFYMAKEREADONLY:
          await this.patchPageInstance(log, this._webPageinstances[i], 'from "./yv4web-full', 'from "./yv4web-readonly', "", "", ",filehandler.saveFct);", ");");
          this._webPageinstances[i].readonly = true;
          break;
        case this._MODIFYMAKEREADWRITE:
          await this.patchPageInstance(log, this._webPageinstances[i], 'from "./yv4web-readonly', 'from "./yv4web-full', "", "", "filehandler.configChangeCallbackFct);", "filehandler.configChangeCallbackFct,filehandler.saveFct);");
          this._webPageinstances[i].readonly = false;
          break;
        case this._MODIFYUSEPLAIN:
          await this.patchPageInstance(log, this._webPageinstances[i], '"./yv4web-full.min.js"', '"./yv4web-full.js"', '"./yv4web-readonly.min.js"', '"./yv4web-readonly.js"', "", "");
          this._webPageinstances[i].useMinified = false;
          break;
        case this._MODIFYUSEMINIFIED:
          await this.patchPageInstance(log, this._webPageinstances[i], '"./yv4web-full.js"', '"./yv4web-full.min.js"', '"./yv4web-readonly.js"', '"./yv4web-readonly.min.js"', "", "");
          this._webPageinstances[i].useMinified = true;
          break;
      }
    }
    await this.syncJsFileVersions(log, this._removeUnusedJs.checked);
    log("Done.");
    setTimeout(() => {
      this.gotoPanel(this.DONEPANEL);
    }, 2e3);
  }
  async uninstall(log) {
    for (let i = 0; i < this._jsCodeinstances.length; i++) {
      let filename = this._jsCodeinstances[i].filename;
      log("Deleteting " + filename);
      await this._currentfs.remove(filename);
    }
    let network = await YNetwork.FindNetwork(await this._currentHub.get_serialNumber() + ".network");
    let startPage = await network.get_defaultPage();
    let mustResetStartPage = false;
    for (let i = 0; i < this._webPageinstances.length; i++) {
      let filename = this._webPageinstances[i].fs_filename;
      if (startPage == this._webPageinstances[i].http_filename)
        mustResetStartPage = true;
      log("Deleteting " + filename);
      await this._currentfs.remove(filename);
    }
    if (mustResetStartPage) {
      log("Setting default page to index.html");
      await network.set_defaultPage("");
      await this._currentHub.saveToFlash();
    }
    log("Done.");
    setTimeout(() => {
      this.gotoPanel(this.DONEPANEL);
    }, 2e3);
  }
  get_js_filename(readonly, minified) {
    return "yv4web-" + (readonly ? "readonly" : "full") + (minified ? ".min" : "") + ".js";
  }
  get_js_blob(readonly, minified) {
    let data;
    if (readonly) {
      data = minified ? BinariesBlobs.ro_minjs : BinariesBlobs.ro_js;
    } else {
      data = minified ? BinariesBlobs.rw_minjs : BinariesBlobs.rw_js;
    }
    if (data == "")
      return null;
    return YAPI.imm_str2bin(atob(data));
  }
  async copyJsCode(log, readonly, minified) {
    let currentURL = window.location.href;
    let filename = currentURL.split("/").pop().split("#")[0].split("?")[0];
    let jsfile = this.get_js_filename(readonly, minified);
    let GZ_data = this.get_js_blob(readonly, minified);
    let status;
    if (GZ_data == null) {
      status = log("Downloading " + jsfile + " module from server..");
      let jsfileURL = currentURL.replace(filename, "../../dist/" + this.ESVersion + "/" + jsfile);
      let result;
      result = await YoctoHubFileHandler.makeRequest("GET", jsfileURL);
      if (result.data == null) {
        let err = "Installation Failed: cannot download the Yocto-Visualization file from the serveur serving this installer.\n\nError was : " + result.statusText + "\n\nURL was: " + jsfileURL;
        this.gotoPanel(this.CONNECTIONERROR, err);
        return;
      }
      status.innerText = "done.";
      status = log("Compressing JS Module..");
      GZ_data = Pako_Deflate.gzip(result.data, {level: 9});
      status.innerText = "done.";
    }
    status = log("Copying JS Module to hub..");
    status.innerText = "0%";
    let success = await this.uploadWidthProgress(jsfile + ".gz", GZ_data, (curr, total) => {
      status.innerText = Math.round(100 * curr / total).toString() + "%";
    });
    if (success != YAPI_SUCCESS)
      throw "Upload failed. (Error" + success.toString() + ").";
    status.innerText = "done.";
  }
  async install(log) {
    let configFile = await this.loadLocalFile(this._configFileInput);
    if (configFile != null) {
      configFile = configFile.replace("<!-->", "<!-- ");
      let err = new YErrorMsg();
      if (!this.checkConfigfile(configFile, err)) {
        this.gotoPanel(this.CONNECTIONERROR, "Installation failed\n\n" + err.msg);
        return;
      }
      let index = configFile.toUpperCase().indexOf("</ROOT");
      if (index < 0)
        this.gotoPanel(this.CONNECTIONERROR, "Installation failed\n\nunable to find ROOT closing tag in provided config file");
      configFile = configFile.substring(0, index) + "</ROOT>\n";
      configFile = this.patchConfigFile(configFile);
    }
    let htmlFile = await this.loadLocalFile(this._webPageInput);
    if (htmlFile != null) {
      let err = new YErrorMsg();
      if (!this.checkHTMLfile(htmlFile, err)) {
        this.gotoPanel(this.CONNECTIONERROR, "Installation failed\n\n" + err.msg);
        return;
      }
    }
    let status;
    let GZ_data;
    let success;
    let readonly = this._useReadOnlyInput.checked;
    let minified = !this._useFullVersionInput.checked;
    let mustInstallJsCode = this._plannedaction == this.ACTIONINSTALL;
    if (this._plannedaction == this.ACTIONADDINSTANCE) {
      mustInstallJsCode = true;
      for (let i = 0; i < this._jsCodeinstances.length; i++) {
        if (this._jsCodeinstances[i].minified == minified && this._jsCodeinstances[i].readonly == readonly) {
          mustInstallJsCode = false;
        }
      }
    }
    if (mustInstallJsCode)
      await this.copyJsCode(log, readonly, minified);
    status = log("Creating HTML file..");
    let targetHTMLfile;
    if (htmlFile != null) {
      let index = htmlFile.toUpperCase().indexOf("</BODY>");
      let tag = htmlFile.substr(index, 7);
      targetHTMLfile = htmlFile.replace(tag, tag + this.getSeedCode(configFile, readonly, minified));
    } else {
      targetHTMLfile = this.defaultHTMLfile(configFile, readonly, minified);
    }
    status = log("Compressing  HTML file..");
    GZ_data = Pako_Deflate.gzip(YAPI.imm_str2bin(targetHTMLfile), {level: 9});
    status.innerText = "done.";
    status = log("Saving HTML file on hub");
    let targetFile = this._fileprefixInput.value + this.TARGETEXTENSION;
    status.innerText = "0%";
    success = await this.uploadWidthProgress(targetFile + ".gz", GZ_data, (curr, total) => {
      status.innerText = Math.round(100 * curr / total).toString() + "%";
    });
    if (success != YAPI_SUCCESS)
      throw "Upload failed (Error" + success.toString() + ")";
    status.innerText = "done.";
    status = log("Configuring hub");
    let url = this._currentHubLink_protocol + "://" + this._applicationURL;
    let network = await YNetwork.FindNetwork(await this._currentHub.get_serialNumber() + ".network");
    if (this._makeDefaultInput.checked) {
      await network.set_defaultPage(targetFile);
    } else {
      if (await network.get_defaultPage() == targetFile)
        await network.set_defaultPage("");
      url += "/" + targetFile;
    }
    let warning = "";
    if (readonly && configFile == null)
      warning = "However, since you chose to install the read-only version without any configuration file, your install is probably useless.";
    await YAPI.UnregisterHub(await this._currentHub.get_url());
    status.innerText = "done.";
    this._warning = warning;
    this._finalURL = url;
    setTimeout(() => {
      this.gotoPanel(this.DONEPANEL);
    }, 2e3);
  }
  removeAllChilds(element) {
    while (element.firstChild) {
      element.removeChild(element.firstChild);
    }
  }
  async showConfirmUninstallPanel(visible, goingback) {
    if (!visible) {
      if (this._confirmUninstallPanel != null)
        this._confirmUninstallPanel.style.display = "none";
      return;
    }
    if (this._confirmUninstallPanel == null) {
      this._confirmUninstallPanel = this.createNewContentDiv();
      this._container.appendChild(this._confirmUninstallPanel);
    }
    if (!goingback) {
      this.removeAllChilds(this._confirmUninstallPanel);
      let p = document.createElement("P");
      p.innerText = "You are about to remove all files related to Yocto-Visualization (for web)  from hub " + this._currentHub_Addr + ", including instances that probably took you quite some time to configure. Are you sure you want to click on Next and start uninstallation? You will not be able to revert this operation.\n\n";
      this._confirmUninstallPanel.appendChild(p);
      this._confirmUninstall = document.createElement("input");
      this._confirmUninstall.type = "checkbox";
      let bt = this._nextButton;
      this._confirmUninstall.addEventListener("change", function() {
        bt.enabled = this.checked;
      });
      this._confirmUninstallPanel.appendChild(this._confirmUninstall);
      let txt = document.createElement("span");
      txt.innerText = "Yes, I know what I am doing.";
      this._confirmUninstallPanel.appendChild(txt);
    }
    this._confirmUninstallPanel.style.display = "";
    this._nextButton.visible = true;
    this._nextButton.enabled = this._confirmUninstall.checked;
    this._prevButton.visible = true;
    this._cancelButton.visible = this.DEFAULTCANCELABLE;
    let tabIndex = 1;
    this._confirmUninstall.tabIndex = tabIndex++;
    this._prevButton.tabIndex = tabIndex++;
    this._nextButton.tabIndex = tabIndex++;
    this._confirmUninstall.focus();
  }
  async showDonePanel(visible, goingback) {
    if (!visible) {
      if (this._donePanel != null)
        this._donePanel.style.display = "none";
      return;
    }
    if (this._donePanel == null) {
      this._donePanel = this.createNewContentDiv();
      let Table = document.createElement("TABLE");
      let Row = document.createElement("TR");
      let TD1 = document.createElement("TD");
      TD1.style.whiteSpace = "normal";
      TD1.innerHTML = ressources.OkIcon("64", true, false, false, false, "youpi!");
      Row.appendChild(TD1);
      this._doneMsgContainer = document.createElement("TD");
      Row.appendChild(this._doneMsgContainer);
      Table.appendChild(Row);
      this._donePanel.appendChild(Table);
      this._container.appendChild(this._donePanel);
    }
    this.removeAllChilds(this._doneMsgContainer);
    let p = document.createElement("P");
    p.style.whiteSpace = "normal";
    switch (this._plannedaction) {
      case this.ACTIONADDINSTANCE:
      case this.ACTIONINSTALL:
        p.innerText = this._plannedaction == this.ACTIONINSTALL ? "Installation sucessfully completed. Application can be accessed through the following URL:" : "New instance sucessfully completed, it can be accessed through the following URL:";
        this._doneMsgContainer.appendChild(p);
        let url = document.createElement("A");
        url.innerText = this._finalURL;
        url.style.cursor = "pointer";
        url.style.color = "#0000EE";
        url.style.textDecoration = "underline";
        url.addEventListener("click", () => {
          if (top)
            top.location.assign(this._finalURL);
        });
        this._doneMsgContainer.appendChild(url);
        if (this._warning != "") {
          p = document.createElement("P");
          p.innerText = this._warning;
          this._doneMsgContainer.appendChild(p);
        }
        break;
      case this.ACTIONUNINSTALL:
        p.innerText = "Files sucessfully removed.";
        this._doneMsgContainer.appendChild(p);
        break;
      case this.ACTIONUPDATE:
        p.innerText = "JS Files sucessfully updated.";
        this._doneMsgContainer.appendChild(p);
        break;
      case this.ACTIONMODINSTANCE:
        p.innerText = "Instances modifications done";
        this._doneMsgContainer.appendChild(p);
        break;
    }
    p = document.createElement("P");
    this._cancelButton.visible = this.DEFAULTCANCELABLE;
    p.innerText = this.DEFAULTCANCELABLE ? 'Click on the "Ok" button to close the wizard' : 'Click on the "Ok" button to restart the wizard';
    this._doneMsgContainer.appendChild(p);
    this.removeCurrentPanelFromHistory();
    this._nextButton.visible = false;
    this._prevButton.visible = false;
    this._cancelButton.visible = false;
    this._okButton.visible = true;
    this._donePanel.style.display = "";
    let tabIndex = 1;
    this._okButton.tabIndex = tabIndex++;
    this._okButton.focus();
  }
  showCurrentStep(back, msg) {
    this.showWelcomePanel(this._currentStep == this.WELCOMEPANEL, back);
    this.showEnterHubAddr(this._currentStep == this.ENTERHUBADDR, back);
    this.showConnectingPanel(this._currentStep == this.CONNECTINGPANEL, back);
    this.showConnectionError(this._currentStep == this.CONNECTIONERROR, back, msg);
    this.showPasswordPanel(this._currentStep == this.PASSWORDPANEL, back, msg);
    this.showHubDescription(this._currentStep == this.DESCRIPTIONPANEL, back);
    this.showCustomFilesPanel(this._currentStep == this.CUSTOMFILESPANEL, back);
    this.showOptionsPanel(this._currentStep == this.OPTIONSPANEL, back);
    this.showRunPanel(this._currentStep == this.RUNPANEL, back);
    this.showDonePanel(this._currentStep == this.DONEPANEL, back);
    this.showModifyInstallPanel(this._currentStep == this.MODIFYINSTALLPANEL, back);
    this.showConfirmUninstallPanel(this._currentStep == this.CONFIRMUNINSTALLPANEL, back);
    this.showModInstancesPanel(this._currentStep == this.MODINSTANCESPANEL, back);
  }
  gotoPrevious() {
    if (this._history.length > 1) {
      this._history.pop();
      this._currentStep = this._history[this._history.length - 1];
    }
    this.showCurrentStep(true);
  }
  gotoPanel(step, errmsg) {
    this._currentStep = step;
    this._prevButton.visible = step > 0;
    this._history.push(step);
    this.showCurrentStep(false, errmsg);
  }
  async resetAll() {
    this._currentStep = this.WELCOMEPANEL;
    this._history = [this.WELCOMEPANEL];
    this._alreadyInstalled = false;
    this._prevButton.visible = false;
    this._nextButton.visible = true;
    this._okButton.visible = false;
    this._cancelButton.visible = this.DEFAULTCANCELABLE;
    this._jsCodeinstances = [];
    this._webPageinstances = [];
    await YAPI.UnregisterHub(await this._currentHub.get_url());
    await YAPI.FreeAPI();
    this._currentHub = null;
    this.showCurrentStep(false);
  }
  gotoNext() {
    switch (this._currentStep) {
      case this.WELCOMEPANEL:
        this.gotoPanel(this.ENTERHUBADDR);
        break;
      case this.ENTERHUBADDR:
        this.gotoPanel(this.CONNECTINGPANEL);
        break;
      case this.PASSWORDPANEL:
        this.gotoPanel(this.CONNECTINGPANEL);
        break;
      case this.DESCRIPTIONPANEL:
        if (this._alreadyInstalled) {
          this.gotoPanel(this.MODIFYINSTALLPANEL);
        } else {
          this._plannedaction = this.ACTIONINSTALL;
          this.gotoPanel(this.CUSTOMFILESPANEL);
        }
        break;
      case this.CUSTOMFILESPANEL:
        this.gotoPanel(this.OPTIONSPANEL);
        break;
      case this.OPTIONSPANEL:
        this.gotoPanel(this.RUNPANEL);
        break;
      case this.MODIFYINSTALLPANEL:
        if (this._uninstallOpt.checked)
          this.gotoPanel(this.CONFIRMUNINSTALLPANEL);
        if (this._addInstanceOpt.checked) {
          this._plannedaction = this.ACTIONADDINSTANCE;
          this.gotoPanel(this.CUSTOMFILESPANEL);
        }
        if (this._updateOpt.checked) {
          this._plannedaction = this.ACTIONUPDATE;
          this.gotoPanel(this.RUNPANEL);
        }
        if (this._modInstanceOpt.checked) {
          this._plannedaction = this.ACTIONMODINSTANCE;
          this.gotoPanel(this.MODINSTANCESPANEL);
        }
        break;
      case this.MODINSTANCESPANEL:
        this.gotoPanel(this.RUNPANEL);
        break;
      case this.CONFIRMUNINSTALLPANEL:
        this._plannedaction = this.ACTIONUNINSTALL;
        this.gotoPanel(this.RUNPANEL);
        break;
    }
  }
};
YV4W_installer.HTTP = "http";
YV4W_installer.HTTPS = "https";
window.startYV4W_installer = (div, options) => {
  new YV4W_installer(div, options);
};
export {
  YV4W_installer
};
//# sourceMappingURL=yv4w-installer.js.map
